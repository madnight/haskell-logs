00:07:12 * hackage hextra 0.3.0.0 - Generic and niche utility functions and more for Haskell.  https://hackage.haskell.org/package/hextra-0.3.0.0 (anselmschueler)
00:50:23 <random> hey guys
00:50:38 <random> does anyone know if you can achieve this with Symbol
00:50:43 <random> and if yes, how exactly
00:50:44 <random> https://pastebin.com/UXpQ9npN
01:07:57 <phadej> Why not data Error = FirstError | SecondError; errorText FirstError = "Some constant error text"; errorText SecondError = "Some other constant error text"
01:09:44 <random> just experimenting
01:09:47 <random> I'd like it inline
01:16:53 <lortabac> random: yes, it is possible to promote error messages to symbols, but I'd only do it if I had a very good reason
01:17:06 <random> I think I've done it
01:17:10 <random> just need a few more minutes
01:22:03 <random> yeah so
01:22:10 <random> for anyone curious
01:22:53 <random> https://pastebin.com/T4QbXgJ3
01:22:56 <random> this is what I came up with
01:24:51 <sicklorkin> Has anyone here worked with flatbuffers?
01:25:36 <phadej> random: data Error = FirstError (Proxy "Something") | ... is something which I'd proposed - and what you essentially did
01:26:01 <random> sorry I didn't see you proposed that
01:26:13 <random> yeah it seems neat enough
01:26:25 <phadej> I would proposed, I didn't. I don' understand why you want it
01:26:48 <phadej> Fwiw, you want to make fields strict FirstError !(Proxy "Something")
01:27:55 <phadej> as having that field unstrict there is not "free"
01:31:04 <random> phadej: thanks!
01:31:21 <random> phadej: what problems could arise from not having this strict?
01:32:41 <phadej> "who knows", what problems would arise by not having that field strict?
01:33:27 <phadej> making Proxy strict (and IIRC {-# UNPACK #-} ing it) will make it non-existent at runtime
01:33:36 <phadej> which is most likely what you have in mind when adding it
01:36:55 <random> got it
01:37:06 <random> it's a slightly bigger example the one we've got
01:37:42 <random> there's this Aggregate class that has a `data Error a :: Type` inside it
01:37:46 <random> we have many aggregates
01:38:01 <random> each definition a few hundred lines
01:38:12 <random> so I didn't like having the error text separate from the error type
01:39:40 <random> as you need to scroll a lot
01:42:15 <sicklorkin> random: does this help w/ur scrolling issue? https://en.wikipedia.org/wiki/Code_folding
01:43:07 <random> lol yes we use code folding
01:43:35 <random> it's just prettier having the error text inline in my opinion
01:43:41 <random> as it's always constant
01:44:36 <phadej> I'd really say it's using fancy features for the sake of fanciness
01:44:46 <phadej> but its your shop
01:46:03 <phadej> if you have structured errors, than I think the idea is precisely to decouple error texts ("styles") from the data ("content")
01:46:22 <phadej> and having them inline is like using <font name="Arial"> all over the HTML
01:46:52 <phadej> yes, it will reduce need for scrolling when editing, but is that good code?
01:51:11 <sicklorkin> I wonder if PatternSynonyms would work well here..
01:55:11 <phadej> they would be equally "far from data def"
01:56:44 <sheepfleece> It is a slightly strange question, but am I using `Set` in the wrong way? Say I have a data structure with two fields in it, and I define `Eq` and `Ord` through the first element in this structure, so even though nominally things might be different, represantationally they are not. This way I would like to have a function which 'updates' the value in a set, but at the same time while preserving 
01:56:51 <sheepfleece> `Eq`uality. I know only how to do this with `IORef`s, but it doesn't feel right, doesn't feel right at all! I, of course, can split my data structure in two and then use `Map` but that's suboptimal and requires me to either pass tuples around or to create another syntatic types, just to distinguish two things. And the problem became even more annoying when I tried to encapsulate 'Sorted` lists in 
01:56:57 <sheepfleece> their own type.
01:58:54 <frobnicator> doesn't it work sheepfleece? I don't see why you cannot do this with your proposed version of eq and ord
01:59:02 <sicklorkin> phadej: i was thinking you could just do.. pattern FstErr = "one error"\npattern SndErr = "another error". I see no reason to define `data` here
01:59:39 <sheepfleece> frobnicator: what exactly? IORefs? I don't want to use IO monad for essentially pure computations.
01:59:56 <merijn> sheepfleece: Can you rewind and explain what you're trying to do?
02:00:23 <typetetris> What are some number formatting functions beside show, Text.Printf ?
02:00:44 <frobnicator> sheepfleece: you propose to create a data structure with an Eq and and Ord instance that is special so that you can use it to update values in a set. I don't see any problem with this
02:01:29 <merijn> typetetris: You want the Numeric module
02:01:29 <sicklorkin> typetetris: What you got agains't printf?
02:01:42 <merijn> sicklorkin: Printf is a god awful abomination, for one :p
02:01:52 <sheepfleece> I have a list sorted by one field, and I have another list with just that field, so in essence I have 'SortedList a', 'SortedList b' and monotonic function 'a -> b'. And I want to somehow update both lists. I'm just not sure how to write a nice API around it.
02:02:12 * hackage ngx-export-tools-extra 0.5.1.0 - More extra tools for Nginx haskell module  https://hackage.haskell.org/package/ngx-export-tools-extra-0.5.1.0 (lyokha)
02:02:12 <sheepfleece> frobnicator: Set does not provide such functions, sadly. 
02:02:22 <frobnicator> data Pair a b = Pair a b
02:02:26 <frobnicator> instance (Eq a, Eq b) => Eq (Pair a b) where Pair l1 r1 == Pair l2 r2 = l1 == l2
02:02:35 <frobnicator> instance (Ord a, Ord b) => Ord (Pair a b) where Pair l1 r1 <= Pair l2 r2 = l1 <= l2
02:02:44 <frobnicator> and voila, if you create a set with Pairs you are set
02:04:02 <sicklorkin> merijn: if you're supplying untrusted input then 100% I agree it should be avoided.
02:04:22 <sheepfleece> So I can have Either `Set (Pair a b)` or `Map a b`. Now I'm not even sure what I'm trying to do.
02:05:03 <sheepfleece> Both feel suboptimal somewhat, because sets do not have a notion of updating values in it.
02:05:25 <merijn> sicklorkin: Even if you don't you should avoid it, tbh
02:06:07 <merijn> Printf is a fun hack to show how to do polymorphic recursion in Haskell, but it's the last thing you should ever seriously use >.>
02:08:46 <typetetris> sicklorkin: I makes strings? And I just wanted to know the options
02:10:19 <sheepfleece> Now I even feel silly for asking, sorry!
02:13:14 <__monty__> sheepfleece: A Map with a custom lookup function that wraps up the key and value sounds like what you want tbh. `retrieve key m = MyData key (lookup key m)`.
02:13:41 * hackage registry 0.1.9.1 - data structure for assembling components  https://hackage.haskell.org/package/registry-0.1.9.1 (etorreborre)
02:14:15 <sheepfleece> __monty__: Yes, this should work wonderfully, thank you! 
02:16:25 <__monty__> np
02:23:48 <sicklorkin> merijn: what's you horror story with printf? performance, memory leaks, runtime errors, or something else?
02:24:13 <merijn> sicklorkin: It succesfully compiles even for utterly wrong invocations
02:24:22 <merijn> Which means you can compile code that will always crash at runtime
02:25:14 <merijn> And the functions in Numeric can do basically anything Printf can, without those problems
02:26:12 <sicklorkin> I see typelits-printf, hav eyou tried that?
02:26:32 <sicklorkin> https://hackage.haskell.org/package/typelits-printf
02:26:56 <merijn> tbh, I just use mconcat + show and/or Numeric :p
02:31:05 <ph88> can i individually enable all the optimization flags that are turned on with -O1 ?  My program is behaving really weird with -O1 and i want to see which optimization is causing this
02:34:34 <fendor> ph88, yeah, flag reference: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/flags.html#options-f-compact
02:44:28 <ph88> thanks fendor 
02:44:43 <ph88> is -O the same as -O0  ?
02:44:52 <ph88> is -O the same as -O1  ?    ***
02:48:35 <merijn> -O is -O1
03:05:42 * hackage azure-functions-worker 0.0.0.0 - Azure Functions Worker  https://hackage.haskell.org/package/azure-functions-worker-0.0.0.0 (alexeyraga)
03:13:29 <bergsans> Hello! Does anyone know of a channel for Haskell beginners?
03:13:46 <ph88> fendor, merijn i tried to switch off optimization with -O0 and then turn on all the optimization individually with all the flags i could find that were said to be switched on with -O1  so i get this  https://bpa.st/CBZQ   but this does not result in the same behaviour of the program as simply switching on the -O1 flag ... Do you know what else i can do to control individual optimizations and get the same effect as -O1 ? I want to see 
03:13:46 <ph88> which optimization is causing problems
03:14:24 <ph88> bergsans, there is #haskell-beginners but it's also ok to ask beginners questions here
03:14:27 <dminuoso> bergsans: There is #haskell-beginners - but you can ask in here as well.
03:14:49 <bergsans> diminuoso: aight! thank you
03:14:56 <ph88> hi dminuoso my twin brother
03:24:12 * hackage posix-pty 0.2.2 - Pseudo terminal interaction with subprocesses.  https://hackage.haskell.org/package/posix-pty-0.2.2 (MerijnVerstraaten)
03:35:42 * hackage mason 0.2.2 - Fast and extensible bytestring builder  https://hackage.haskell.org/package/mason-0.2.2 (FumiakiKinoshita)
04:11:55 <dminuoso> ph88: Mind my asking, what behavioral change are you observing?
04:13:42 <ph88> dminuoso, program finished within a second VS program runs significantly longer and uses all system memory and gets killed by linux kernel
04:15:39 <dminuoso> ph88: Run the second version with profiling enabled? :)
04:16:05 <ph88> this doesn't manifest in a profiling build
04:16:07 <dminuoso> (btw, is the OOM killer triggered by the version with more optimization flags?)
04:16:24 <dminuoso> ph88: Try granularly adding cost centers by hand then.
04:16:45 <dminuoso> (as opposed to something like --profiling-detail=all-functions)
04:17:22 <dminuoso> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/profiling.html#inserting-cost-centres-by-hand
04:17:29 <ph88> is the OOM killer triggered by the version with more optimization flags? --> with these flags https://bpa.st/CBZQ it's not OOM
04:17:55 <dminuoso> And -O1 triggers it?
04:17:59 <ph88> yes
04:18:18 <ph88> dminuoso, are you saying that i should look at a partial prof file (partial because the program never finished and is killed) ?
04:18:20 <dminuoso> Curious. Id try inserting cost centers by hand, in a binary search fashion from outwards towards inwards.
04:18:45 <ph88> ignore that last line please
04:19:10 <ph88> the bug doesn't happen in a profiling build, so what would adding cost centres by hand accomplish ??
04:19:22 <dminuoso> Ah.
04:19:28 <dminuoso> well
04:19:45 <dminuoso> ph88: Does profiling mean just raw -prof to you
04:19:48 <dminuoso> Or -fprof-auto as well?
04:20:03 <dminuoso> That is, does merely adding -prof to GHC flags make it go away?
04:20:40 <dminuoso> (I just blindly assumed that a profiling build would include some `-fprof-*` flag (either directly or implicitly via cabal)
04:20:45 <ph88> stack build --executable-profiling     just this does it make it go away
04:20:50 <ph88> not sure what stack is passing to GHC
04:21:00 <dminuoso> ph88: Its likely stack will include -fprof-auto or something similar.
04:21:16 <ph88> one moment i will run stack verbose to see what is there
04:22:05 <dminuoso> ph88: Try --ghc-options="-prof" instead of --profiling
04:22:27 <dminuoso> (This would produce a largely useless profiling file, but the point is to see whether it still triggers)
04:22:40 <dminuoso> Oh probably
04:22:44 <dminuoso> --ghc-options="-prof -rtsopts"
04:23:04 <dminuoso> And if it still triggers, you can manually annotate SCCs
04:23:20 <dminuoso> If not I cant help.
04:23:35 <dminuoso> (Beyond a binary search through optimization flags)
04:26:42 <ph88> -enable-library-profiling --enable-profiling --ghc-options -fprof-auto --ghc-options -fprof-cafs    i think these are the raw options that stack uses, i still don't see the actual invocation command to ghc though
04:27:33 <ph88> dminuoso, i did the binary search on optimization flags can i could not reproduce the problem if i enable all flags that are supposed to be enable with -O1 where the problem happens
04:29:02 <ph88> dminuoso, https://bpa.st/V6LQ 
04:33:12 * hackage pandoc-plot 0.7.2.0 - A Pandoc filter to include figures generated from code blocks using your plotting toolkit of choice.  https://hackage.haskell.org/package/pandoc-plot-0.7.2.0 (LaurentRDC)
04:47:12 <dminuoso> ph88: Mmm, perhaps you could just generate the .cabal file and use cabal instead? That way you can specify `--profiling-detail=none`
04:47:51 <dminuoso> (Assuming the problem is reproducible with cabal, Im not quite sure whether you can convince cabal to use the packages from the stack resolver)
05:04:17 <HighMemoryDaemon> In Python I can do somefunction.__doc__ to get some documentation on what it is. Any similar thing I can do in Haskell, from GHCI perhaps?
05:06:29 <fendor> HighMemoryDaemon, there is the `:doc` command in ghci
05:07:33 <fendor> for local modules, you have to load the file with -haddock, I think
05:08:10 <HighMemoryDaemon> Awesome, it worked! Thanks, fendor.
05:22:16 <ph88> dminuoso, yes i can certainly try that. Though in some stack issue i read something along the lines of "stack just uses cabal under the hood" .. so i'm not sure if cabal also just adds that -fprof-auto flag
05:24:00 <dminuoso> ph88: Well stack perhaps adds cabal flags, I just dont see any stack options giving you control over the profiling detail
05:47:23 <typetetris> have Int always been 64 bit?
05:48:05 <c_wraith> 64-bit builds of GHC have always had 64-bit Int
05:48:41 <c_wraith> 32-bit builds of GHC had a 32-bit Int.  When I started using Haskell, 32-bit was still the more common, but it's rare now
05:49:42 <fendor> Isnt it only garantueed that Ints have 29 bits? https://hackage.haskell.org/package/base-4.14.0.0/docs/GHC-Exts.html#t:Int
05:49:54 <c_wraith> That's what the spec guarantees, yes
05:50:05 <c_wraith> GHC gives you more bits than that
05:50:19 <fendor> yeah but you should not rely on it
05:50:28 <c_wraith> GHC isn't going to change that.
05:50:49 <c_wraith> If you're depending on GHC's changes to the libraries, you can depend on GHC's Int size
05:56:10 <boxscape> don't you need 30 bits for -2^29...2^29-1?
05:56:29 <c_wraith> hmm, yes.  you are better at counting than me.  :)
06:34:41 * hackage sr-extra 1.80 - Module limbo  https://hackage.haskell.org/package/sr-extra-1.80 (DavidFox)
06:34:52 <dminuoso> Is the duality of (,) and Either expressible in Haskell terms?
06:41:54 <ph88> how do i dump the assembly output in case of using the llvm backend ?
06:52:48 <boxscape> dminuoso what does it mean to be expressible in haskell terms? Like a type family or something like that which goes from "(c -> a) -> (c -> b) -> (c -> (a, b))" to "(a -> c) -> (b -> c) -> (Either a b -> c)" ?
06:53:41 <kuribas> is it possible to stop a program in an infinite loop, and get a stacktrace of where it's stuck?
06:54:29 <boxscape> kuribas https://wiki.haskell.org/Debugging has a section on debugging at the very bottom
06:54:35 <boxscape> section on infinite loops, rather
06:54:43 <kuribas> boxscape: I saw that, does it still work?
06:54:50 <boxscape> I'm not entirely sure tbh
06:55:15 <kuribas> and can I :trace the whole program?
06:55:19 <kuribas> including IO?
06:55:21 <comerijn> kuribas: Profiling build with +RTS -xc gets you a stacktrace
06:55:36 <comerijn> You can also use the DWARF symbols in ghc 8.x for ghetto stacktraces
06:55:37 <kuribas> comerijn: if I finish it with KILL?
06:55:49 <comerijn> If you finish with kill you cannot get anything ever
06:55:57 <comerijn> In no language
06:56:01 <dminuoso> boxscape: No rather Ive been wondering whether the relationship is expressible akin to how an isomorphism can be represented by a pair of functions
06:59:23 <kuribas> merijn: kill with sigTERM
06:59:52 <kuribas> dminuoso: isn't that in category theory for programmers?
07:00:13 <merijn> kuribas: Honestly no clue, you might need to setup a signal handler and kill the infinite looping code somewhow
07:21:26 <kuribas> merijn: looks like sigQUIT does the job: https://www.well-typed.com/blog/2020/04/dwarf-3/
07:24:44 <GreyFaceNoSpace> https://pastebin.com/6Ea7Pq8C
07:24:47 <GreyFaceNoSpace> whats wrong here?
07:25:13 <GreyFaceNoSpace>     Couldn't match expected type ‘IO a0’ with actual type ‘[Char]’
07:25:13 <GreyFaceNoSpace>     In a stmt of a 'do' block:
07:25:13 <GreyFaceNoSpace>       putStrLn "Matches: " ++ show m ++ "Player 2?"
07:25:16 <oats> huh, pastebin.com's haskell highlighting is interesting
07:25:21 <GreyFaceNoSpace> yeah
07:25:24 <GreyFaceNoSpace> my eyes
07:25:32 <GreyFaceNoSpace> were gonna explode when i saw it
07:25:46 <merijn> GreyFaceNoSpace: Missing parenthesis
07:25:53 <oats> GreyFaceNoSpace: you're gonna have to add some parentheses, or sprinkle in some $
07:26:04 <oats> putStrLn (foo + bar)
07:26:07 <GreyFaceNoSpace> parantheses around the show m ?
07:26:08 <merijn> GreyFaceNoSpace: function application *always* binds tigher than infix operatprs
07:26:15 <boxscape> it's parsing it as `(putStrLn "Matches: ") ++ show m ++ "Player 2?"`
07:26:16 <GreyFaceNoSpace> ok
07:26:19 <GreyFaceNoSpace> gonna try it out
07:26:20 <GreyFaceNoSpace> sec
07:26:22 <merijn> GreyFaceNoSpace: So in that code you're applying ++ to "putStrLn "Matches: ""
07:26:38 <merijn> Which doesn't typecheck, cause the result of 'putStrLn "Matches: "' is "IO ()"
07:27:05 <GreyFaceNoSpace> yep
07:27:07 <GreyFaceNoSpace> fixed it
07:27:09 <GreyFaceNoSpace> thanks guys
07:35:50 <typetetris> Can I tell cabal to skip linking? (For usage from editor)
07:54:46 <halogenandtoast> This is probably a silly question, with the answer of "You can't", but I want to make sure there isn't some pattern I am missing. If I have a record type with some functions inside the record, is there anyway to reasonable access other fields in the record
07:56:06 <typetetris> How Can I generate a client for a servant api with Stream Endpoints? I get ` No instance for (RunStreamingClient ClientM)`
07:56:54 <typetetris> halogenandtoast: I don't understand? Just use the field accessor functions?
07:56:56 <halogenandtoast> data Foo = Foo { bar :: Int, baz :: String -> Int }; Foo { bar = 1, baz = \s -> #bar# * length s } <- There is no real way to do this right, I'd need to either pass in Foo, or have some other way of grabbing a Foo
07:58:34 <merijn> halogenandtoast: Well, you can make a wrapper that computes that
07:58:52 <merijn> halogenandtoast: Keep in mind that Foo is immutable, so that value of "bar" never changes
07:59:10 <merijn> halogenandtoast: So you can simply define "baz = \s -> 1 * length s"
07:59:19 <merijn> Make some smart wrappers for updating things and done
08:01:52 <halogenandtoast> merijn: Yeah, my simple example doesn't cover the complexity of what I am doing, I have a default record implementation that is a collection of functions and I update the default with some additional values. (defaultRecord arg1 arg2) { field1 = override1, fieldN = overrideN }
08:02:12 <halogenandtoast> I think I'll just pass the value in I care about as an argument to the defaultRecord
08:02:30 <halogenandtoast> So it can generate the function I want
08:02:36 <merijn> halogenandtoast: The only sorta sane way keep functions in a record up to date is by capturing things in, like, an IORef
08:02:49 <typetetris> A confused Servant.Client.ClientM with Servant.Client.Streaming.ClientM
08:03:15 <merijn> halogenandtoast: which, tbh, works surprisingly well
08:04:42 <typetetris> Why are there two client implementations in Servant? Why not just stick with the one, which can also generate clients for apis with streaming endpoints?
08:06:42 <halogenandtoast> merijn: Yeah that might not be what I want in this case, I'm implementing a card game and each card is unique, managing IORefs in this case sounds complex
08:06:50 <halogenandtoast> But thanks for the suggestion
08:24:58 <GreyFaceNoSpace> im sorry ... one more question
08:25:00 <GreyFaceNoSpace> https://pastebin.pl/view/c98d6866
08:25:20 <GreyFaceNoSpace> i cant seem to convert from Int to float
08:25:32 <GreyFaceNoSpace> only functions i can find are fromInteger
08:25:58 <boxscape> GreyFaceNoSpace "fromIntegral" is the function you're looking for
08:26:17 <boxscape> % :t fromInteger
08:26:18 <yahb> boxscape: Num a => Integer -> a
08:26:21 <boxscape> % :t fromIntegral
08:26:21 <yahb> boxscape: (Integral a, Num b) => a -> b
08:27:55 <GreyFaceNoSpace> boxscape,     Couldn't match type ‘IO Float’ with ‘Float’
08:28:18 <GreyFaceNoSpace> https://pastebin.pl/view/659f1a79
08:28:21 <boxscape> GreyFaceNoSpace where in the code are you using the function?
08:28:23 <GreyFaceNoSpace> this is how i changed it
08:28:31 <boxscape> ah
08:29:13 <boxscape> GreyFaceNoSpace not sure if that's the problem but your b' isn't aligned with your x'
08:29:38 <boxscape> indentation-wise
08:29:40 <GreyFaceNoSpace> hmm
08:29:49 <GreyFaceNoSpace> in my ide they are 
08:29:52 <GreyFaceNoSpace> aligned
08:30:01 <boxscape> huh, okay
08:30:14 <GreyFaceNoSpace> this is the exact error from ghc:
08:30:15 <GreyFaceNoSpace>    Couldn't match type ‘IO Float’ with ‘Float’
08:30:15 <GreyFaceNoSpace>     Expected type: IO Float
08:30:15 <GreyFaceNoSpace>       Actual type: IO (IO Float)
08:30:47 <boxscape> GreyFaceNoSpace it's because of the last line in redaN
08:30:52 <boxscape> s/redaN/readN
08:31:01 <boxscape> aux n n 0 is already an IO Float
08:31:06 <GreyFaceNoSpace> oh
08:31:12 <GreyFaceNoSpace> yea thats right
08:31:44 <GreyFaceNoSpace> but removing the return makes things worse
08:31:47 <GreyFaceNoSpace> lol
08:33:18 <boxscape> GreyFaceNoSpace right, n and 0 are of type Int, but aux takes type IO Int in its parameters
08:36:24 <boxscape> GreyFaceNoSpace maybe aux should just get Ints instead of IO Ints?
08:36:40 <GreyFaceNoSpace> boxscape, yep
08:36:43 <GreyFaceNoSpace> fixed it this way
08:36:47 <GreyFaceNoSpace> i got mixed up
08:36:53 <GreyFaceNoSpace> and threw IO everywhere
08:37:09 <GreyFaceNoSpace> when i had already used <- to get an Int out of IO Int
08:37:09 * ski suspects GreyFaceNoSpace added `IO' to the parameter types, in an attempt to avoid type errors
08:37:18 <GreyFaceNoSpace> ski, :)
08:38:00 <ski> the most common case is to only want `IO' (or any other monad) in the return type
08:39:15 <ski> if you want to pass an action that hasn't happened yet, as parameter, perhaps because you want to perform it multiple times (or maybe sometimes not at all), or maybe in a different context .. that's when you want `IO' in a parameter type
08:40:09 <ski>   replicateM :: Int -> IO a -> IO [a]
08:40:21 <ski>   when :: Bool -> IO () -> IO ()
08:40:44 <ski>   forkIO :: IO () -> IO ThreadId
08:40:53 <ski> are some examples
08:43:48 <GreyFaceNoSpace> ski, gonna keep that in mind
08:43:48 <GreyFaceNoSpace> ty
08:54:50 <Drezil> Hi! Does anyone know how i can prevent the automatic exporting of orphan instances i defined locally in my code?
08:55:18 <monochrom> Cannot.
08:55:36 <Drezil> i.e. i want to have local "instance MonadFail Either String where fail = Left" .. but not poison the whole project with that instance...
08:55:48 <dolio> You cannot prevent instances from being exported, ever.
08:55:51 <Drezil> monochrom: really not?! .. :(
08:56:05 <monochrom> Really not.
08:56:32 <Drezil> then i think i just have to mark them {-# OVERLAPPABLE #-} .. so that any other instance overwrites that ..
08:57:04 <Drezil> thanks.
08:57:21 <monochrom> Or don't use Either. Make your own type.
08:59:19 <Drezil> well.. i'm just fixing code failing with the MFP .. before they used "... -> Maybe a" in the lib, now they use "MonadFail m => ... -> m a" .. And in the adaptation of the overlaying library they switched from Mabe a to Except [Text] a ..
08:59:49 <Drezil> which in the fixing code i have to unwrap/wrap/collect errors .. 
09:00:01 <Drezil> so the Either-Instance would be handy :/
09:01:58 <infinisil> Huh why is `Either String` not MonadFail by default?
09:04:21 <Drezil> infinisil: https://gitlab.haskell.org/ghc/ghc/-/issues/12160 - haskell-steering-committee said no in 2018
09:10:05 <infinisil> I don't get the "the instances "get in the way of a user who wants to treat the parameter uniformly"" argument
09:13:49 <mokulus> hi, are there any good repos to study for a beginner? something small preferable, like cli program
09:14:44 <maerwald> mokulus: https://github.com/kowainik
09:14:55 <dminuoso> mokulus: Ideally, something you like to use.
09:15:51 <mokulus> I don't know many haskell programs, I use shellcheck and pandoc, but these are too complex I think
09:16:26 <mokulus> maerwald: any specific repo?
09:16:41 <maerwald> mokulus: check out stan maybe
09:16:42 <Cheery> I've walked through pandoc before
09:16:48 <dminuoso> maerwald: https://hackage.haskell.org/package/cabal-plan
09:16:51 <dminuoso> Err mokulus  ^-
09:17:01 <dminuoso> This is a neat and useful tool, and it's very easy to digest. :)
09:17:05 <maerwald> mok
09:17:25 <mokulus> static analysis seems too hard for now
09:17:36 <maerwald> mokulus: can also look at ghcup code, but it's probably rather boring
09:17:54 <maerwald> stan is likely more interesting
09:20:05 <Cheery> mokulus: to start with pandoc you find the entry point.. or then look at the library API
09:20:11 <Cheery> https://github.com/jgm/pandoc/blob/master/pandoc.hs
09:23:11 * hackage ListLike 4.7.1 - Generalized support for list-like structures  https://hackage.haskell.org/package/ListLike-4.7.1 (DavidFox)
09:23:40 <Cheery> mokulus: if you look at the definition, it shows parse and convertwithopts -step.
09:24:09 <Cheery> the latter is just options being parsed, so not interesting maybe.
09:24:26 <Cheery> https://github.com/jgm/pandoc/blob/34775b4128de2801e4d127064f012501ca18d208/src/Text/Pandoc/App.hs#L68
09:25:26 <maerwald> pandoc is a monstrosity
09:25:56 <maerwald> you gonna give them anxiety and bad dreams :p
09:25:56 <Cheery> It is. Though, it can be worked with.
09:26:11 <Cheery> I was thinking same just short moment ago.
09:27:23 <Cheery> https://github.com/jgm/pandoc/blob/34775b4128de2801e4d127064f012501ca18d208/src/Text/Pandoc/App/Opt.hs
09:27:37 <mokulus> why isn't ghc written in haskell?
09:27:51 <solonarv> uh
09:27:55 <solonarv> it *is* written in haskell
09:29:27 <Gurkenglas_> Was there a name for the theorem that each Functor instance is unique?
09:31:03 <ja> maybe it is implying that ghc extensions are not standard, so therefore not haskell ;) almost flamebait :P
09:31:32 <Cheery> theorem that functor of the algebraic type is unique if it has one?
09:35:44 <dminuoso> mokulus: https://gitlab.haskell.org/ghc/ghc/-/blob/master/ghc/Main.hs
09:35:52 <dminuoso> It's all Haskell :)
09:36:13 <dminuoso> Probably one of the largest Haskell projects around.
09:37:01 <dminuoso> A total of roughly half a million lines of haskell code.
09:37:28 <dminuoso> Ah well, actually thats wrong. I included some incorrect directories.
09:37:59 <dminuoso> About 120k lines of code.
09:38:07 <dminuoso> Still large. :)
09:38:47 <dminuoso> Ah if I drop _build its even less. 25k lines is not so much after all.
09:39:17 <dminuoso> (And thats including things like Cabal)
09:39:59 <maerwald> what???
09:40:15 <maerwald> ghc is 25k loc?
09:41:18 <fragamus> hi all - I can't seem to import the Binary instance for HieFile
09:41:36 <fragamus> It is defined in HieTypes
09:41:52 <fragamus> but import no workie
09:42:02 <Cheery> Gurkenglas_: did you mean functor laws?
09:42:33 <Gurkenglas_> Cheery, no, your previous guess
09:43:25 <Cheery> Gurkenglas_: https://stackoverflow.com/questions/19774904/are-functor-instances-unique
09:43:52 <Cheery> I'm just kind of confused because I'm not sure whether there's such a theorem.
09:45:08 <Gurkenglas_> That link's good enough, thanks
09:47:19 <fragamus> https://hackage.haskell.org/package/ghc-8.10.1/docs/src/HieTypes.html#HieFile
09:47:42 * hackage opentelemetry 0.5.1 -   https://hackage.haskell.org/package/opentelemetry-0.5.1 (DmitryIvanov)
09:48:02 <fragamus> can anyone tell me why I can not access the Binary instance for HieFile
09:48:42 * hackage opentelemetry-lightstep 0.5.1, opentelemetry-wai 0.5.1, opentelemetry-extra 0.5.1 (DmitryIvanov)
09:51:40 <dsal> fragamus: What are you trying to do?  Your question isn't very clear.
09:52:43 <fragamus> I have a HieFile and I want to serialize it using Data.Binary.encode
09:53:33 <dsal> What do you mean by "import Binary instance" ?
09:54:07 <fragamus> No instance for (Binary HieFile) arising from a use of ‘encode’
09:54:53 <fragamus> I import HieTypes but I can't get at the instance
09:56:25 <tommd> Does the 'haskell' github organization have a policy for agreeing to take maintainership of pacakges?
10:05:33 <dsal> fragamus: Nobody can guess what's wrong without you pasting at least a small reproduction.
10:07:16 <dsal> I suspect you're confusing two different classes that are both named Binary, though.
10:09:23 <fragamus> dsal: oh perhaps. I'll look into that
10:23:01 <__monty__> I'm counting ~11kloc in haskell files in the GHC codebase, which includes some libraries.
10:23:35 <__monty__> Sounds like GHC could be read start to finish, reasonably.
10:27:09 <Uniaika> interesting
10:27:20 <maerwald> hp2ps requires the non-free helvetica font??
10:27:38 <Uniaika> `cloc bootstrapping compiler driver ghc includes inplace rts` gives me 225613 lines of haskell, __monty__ 
10:27:42 <Uniaika> maerwald: big if true
10:28:17 <maerwald> I cannot convert to pdf, bc I'm missing that font
10:28:23 <Uniaika> (you can get said `cloc` util at github.com/AlDanial/cloc)
10:28:31 <Uniaika> maerwald: this warrants an issue in the bug tracker
10:28:33 <__monty__> Of haskell or of code? I just counted lines (including comments etc.) in all the *.hs files in the GHC repo (including submodules).
10:28:57 <maerwald> software never works lol
10:29:50 <maerwald> you want to do something simple and you end up solving things you don't care about
10:31:08 <Uniaika> __monty__: of Haskell
10:31:17 <monochrom> hp2ps probably needs an update to use a freer font
10:31:32 <Uniaika> Software needs its own software to work
10:31:47 <maerwald> the online documentation about it does not match the actual cli arguments
10:32:04 <monochrom> But evince can render ps.
10:32:06 <Uniaika> __monty__: I didn't include submodules or test suite, or libraries
10:32:17 <Uniaika> maerwald: oof that is not good
10:32:21 <maerwald> and the graphs it produces are garbage and non-colorized although I passed -c
10:32:22 <Uniaika> it really needs some love
10:32:25 <monochrom> but yeah hp2ps is a pretty old program
10:32:30 <__monty__> Uniaika: Then there must be a *ton* of haskell that's not in *.hs files.
10:33:11 * monochrom repeats his usual gripe about how it's more glamorous to add dependent typing than updating hp2ps.
10:33:18 <__monty__> Missed about 150 lines of lhs but nowhere near 100k.
10:33:30 <Uniaika> __monty__: run the same command as I did, you'll see by yourself!
10:33:57 <maerwald> monochrom: evince cannot open .ps here
10:34:17 <maerwald> and ps2pdf doest not work due to helvetica font
10:34:33 <__monty__> Uniaika: Yep, was grepping the find output >.< : D
10:34:45 <monochrom> But hey don't you diss greyscale! Look at my name! :)
10:35:12 * ski . o O ( `gv' )
10:37:42 <__monty__> Uniaika: Yeah, getting 900k non-empty lines now, which is probably high. Don't expect GHC+libs to be so big.
10:37:55 <maerwald> not compiled with postscript support :>
10:38:06 <monochrom> Oh haha
10:38:24 <maerwald> joys of using source distros
10:39:25 <maerwald> https://making.pusher.com/memory-profiling-in-haskell/
10:39:36 <maerwald> but... mine never looks like that one
10:40:42 * hackage secp256k1-haskell 0.3.1 - Bindings for secp256k1  https://hackage.haskell.org/package/secp256k1-haskell-0.3.1 (jprupp)
10:56:12 <monochrom> I am able to get 2 colours (blue and black) with -c.
11:00:07 <maerwald> The documentation says there is a more modern tool: hp2any-manager
11:00:19 <maerwald> But cabal cannot find an install plan anymore
11:02:32 <Uniaika> bgamari: nevermind my previous messages, it's actually a good addition to our toolbelt because some issues fit perfectly in this label!
11:03:59 <maerwald> monochrom: we have been cheated
11:04:05 <monochrom> aahhh hp2any-manager wants to display by gtk directly. That's going to be a different uphill battle, yeah.
11:06:56 <maerwald> now I wanted to try with stack, but it wants to invoke sudo and mess with my root file system
11:07:09 <maerwald> never ending story...
11:07:17 <monochrom> I thought it just installs into home directory.
11:07:23 <monochrom> (default)
11:07:36 <maerwald> Installing Stack to: /usr/local/bin/stack..
11:07:45 <maerwald> that's when I killed it
11:08:08 <monochrom> I think this all begins with your build of evince that doesn't do ps? If you could rebuild it with ps support, you would be done?
11:08:53 <maerwald> I'm gonna throw my PC out the window instead, sec...
11:09:38 * monochrom applies Occam's Razor to Gordian Knot. I guess that's what Alexander The Great did.
11:13:12 <monochrom> Ah, there is still this risk: After recompiling evince to do ps, it will complain "I don't know how to display helvetica, you don't have it"
11:13:49 <monochrom> because p22pdf works on my computer, too. (ubuntu here)
11:15:38 <monochrom> It is possible that ubuntu has some free mock-off of helvetica, or even a font redirection/mapping that lies about having helvetica (and maps it to free sans or something)
11:16:38 <monochrom> (many versions ago I saw the xml file that defines the mapping and even edited it myself to customize some Chinese fonts)
11:16:56 <slack1256> I want to confirm this: When the RTS confirms that a thread it's blocked on a STM transaction (for example reading a TChan that has no writers and was GC'd) it will throw and exception. Is this right?
11:18:32 <slack1256> s/throw and/throw an/
11:24:33 <maerwald> and stack fails to build a haskell package... so much for reproducable
11:24:44 <maerwald> I'm giving up lol
11:24:51 <maerwald> this will never end
11:28:58 <maerwald> https://wiki.haskell.org/Hp2any someone should delete that page and fix the ghc doc to not point to it
11:29:17 <Rembane> maerwald: What's the link to the GHC doc? 
11:29:28 <maerwald> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/profiling.html#profiling-memory-usage
11:30:11 * hackage sweet-egison 0.1.0.1 - Shallow embedding implementation of non-linear pattern matching  https://hackage.haskell.org/package/sweet-egison-0.1.0.1 (coord_e)
11:55:47 <maerwald> I managed to build it :p
11:59:18 <fragamus> dsal: you were absolutely right
11:59:43 <monochrom> maerwald: Which one?
11:59:59 <maerwald> all of them
12:00:06 <monochrom> haha yikes
12:00:23 <monochrom> well enjoy your colourful pictures I guess
12:04:01 <maerwald> https://files.hasufell.de/jule/hp2any-manager.png
12:05:33 <maerwald> now... not sure if that was worth it... what do I do with it :p
12:06:37 <monochrom> haha
12:07:27 <maerwald> I think lzma is not actually lazy
12:08:02 <monochrom> I think it means one kind (I think "PINNED") dominates and all the other kinds are marginalized so they aren't even visible at this scale.
12:08:08 <maerwald> and the catchAll cost centre is just sad
12:10:44 <ddellacosta> What does the Monad instance for Maybe really provide other than do notation? It seems to me like the Applicative instance provides more utility, but I'm wondering if I'm missing something.
12:11:47 <dminuoso> ddellacosta: Well the point of Monad is not do-notation.
12:11:49 <dminuoso> The point of any regular typeclass is its methods.
12:11:59 <dminuoso> The do-notation is just what desugars into uses of Monad (and other bits)
12:12:00 <monochrom> but yeah looks like some bytestrings (major user of PINNED) were live for longer than streaming would have it.
12:12:43 <dminuoso> ddellacosta: Consider that you have a series of computations that may all fail, and you want to chain them together such that the entire chain only computes, if every individual part succeeds.
12:12:50 <ddellacosta> dminuoso: sorry, no I get that, let me try to rephrase: is there some reason I'd reach for do notation or whatever for a Maybe value vs. Applicative in most situations where you're sequencing a bunch of Maybe computations?
12:13:06 <ddellacosta> dminuoso: okay that's what I'm looking for
12:13:20 <dminuoso> ddellacosta: Monad is strictly more powerful.
12:13:25 <dolio> Sometimes naming intermediate things is nice.
12:13:40 <dminuoso> And do-notation can sometimes be the most expressive way
12:14:07 <maerwald> so pinned memory probably means some bytestring foo?
12:14:44 <monochrom> I have found both >>= and <|> useful for Maybe. <*> or liftA2 too. And fmap. I don't need a popularity competition among them.
12:14:45 <ddellacosta> dolio: yeah that's reasonable too, and I had thought of that--in fact this I think is a good example of how working with named values can be nice: https://www.futurelearn.com/courses/functional-programming-haskell/0/steps/27247
12:15:00 <dminuoso> ddellacosta: The thing you cant do with Alternative is composing two functions `Int -> Maybe Int` with each other.
12:15:03 <dminuoso> But you can with Monad.
12:15:12 <monochrom> bytestring and text are the two most prominent users of PINNED, yes.
12:15:14 <dminuoso> *Applicative
12:15:21 <ddellacosta> dminuoso: right, I got what you meant
12:15:30 <ddellacosta> thanks this is very helpful
12:15:38 <maerwald> so it must be lzma
12:18:02 <monochrom> Basically IIRC each bytestring chunk (similarly text chunk) is created by asking for pinned memory for the array of bytes (16-bit words for text). There are a couple of benefits.
12:19:19 <monochrom> So yeah a triangular growth means someone is not streaming.
12:19:51 <dolio> I think text uses non-pinned memory.
12:19:54 <maerwald> so when heap goes to 300mb, that means the tar is forced in memory
12:20:13 <slack1256> dolio: I thought that too.
12:20:20 <dminuoso> ddellacosta: https://gist.github.com/dminuoso/7242f3226ef2ac4d033e934ea7c9814e
12:20:35 <dolio> ByteString could, too, but it'd older, and I think has some considerations for being backed by something from e.g. C.
12:20:40 <dminuoso> This is an example where I think do notation for Maybe is the most comprehensible way.
12:22:16 <ddellacosta> dminuoso: cool, thanks--is the alternative syntax for the Maybe's do block just so you can easily differentiate it from the outer do block?
12:23:17 <dminuoso> ddellacosta: Yeah, for a while I was trying out SPJs style of do-notation. The benefit is that you have a visual line making nested do-blocks easier to read
12:23:29 <dminuoso> Nowadays I'd just move it into a where binding instead.
12:23:36 <maerwald> lol, cabal is terrible with data files and new-build
12:23:47 <ddellacosta> dminuoso: gotcha
12:23:55 <maerwald> it expects the file in the install location, but there was no installation
12:24:15 <monochrom> There was a time I used this style because editor indentation support was much better for it. :)
12:24:43 <ddellacosta> haha it's kinda sad when you have to make a choice like that
12:25:04 <Cale> I'd usually just write it like... https://gist.github.com/dminuoso/7242f3226ef2ac4d033e934ea7c9814e#gistcomment-3363350
12:25:28 <ddellacosta> ah yeah that's pretty legible
12:26:07 <dminuoso> Cale: Sure, the point was about the do block itself, not the style of it. :)
12:26:19 <monochrom> maerwald: I wonder if "new-run" would help
12:26:23 <dminuoso> I guess with BlockArguments you could also get rid of the ($), but I dont know the implications of that argument.
12:26:37 <dminuoso> *extension
12:27:22 <maerwald> monochrom: apparently... still sad
12:27:44 <dminuoso> Ultimately I think a separate binding is better, since you can type annotate it and make it obvious which monad instance is being used there.
12:28:01 <monochrom> Having either $ or parentheses helps the human eyes.  If you omit both, it may come off as too many consecutive words, you forgot there is a boundary between "return" and "do".
12:28:02 <dminuoso> (Visually nesting do-blocks of different monads is confusing)
12:28:28 <dminuoso> monochrom: Or, BlockArguments and SPJ style perhaps!
12:28:35 <monochrom> haha
12:29:07 <frdg>  /join #emacs 
12:30:08 <dminuoso> Ive come to a realization. Perhaps one part of why Monad is so confusing, is that its a noun. A colleague of mine, dabbling with Haskell, has been confusing himself with things like "But you're in context of *the* monad"
12:30:36 <monochrom> One would complain the same about Functor.
12:30:52 <monochrom> Monoid. Semigroup. Even Num.
12:31:13 <Cale> I think the only reason Monad is confusing is that people usually try to learn the concept before they've seen many or even any examples of it
12:31:26 <Uniaika> tru
12:31:29 <Cale> It's hard to learn abstractions of things for which you have no examples
12:31:35 <dminuoso> There's probably multiple reasons to it.
12:31:58 <monochrom> Actually I have seen people confused about Num for the same reason. So perhaps there is truth in it.
12:32:04 <maerwald> monochrom: https://github.com/hasufell/hp2any if you fancy to build
12:32:47 <Cale> If you're already familiar with parser combinators and IO and various other monads, making that type class will be obvious.
12:33:14 <dminuoso> Cale: Well people often try to use the name of something to draw useful information from it.
12:33:24 <dminuoso> If its a noun, it could easily suggest that "the monad" is some particular entity.
12:33:44 <dminuoso> Disregarding the fact that typeclasses offer interfaces, rather than being single entities.
12:34:08 <monochrom> Functor, Monad, Monoid, Num, Enum follow the math tradition of using a noun for a class.  Bounded, Integral, Foldable, Traversable follow the OO tradition of using an adjective.  Applicative is a cunning bat, lucky guy. :)
12:34:09 <dminuoso> At least this bit about "what is *the* monad" I've heard from my colleague and someone else quite a few times.
12:34:21 <dminuoso> Didn't we have this topic like yesterday, monochrom?
12:34:33 <monochrom> Yes heh
12:34:40 <Cale> It's important to reinforce that "the monad" refers to the type-level function
12:34:40 <xerox_> Applicable
12:34:50 <monochrom> But I forgot Bounded and Integral.
12:35:19 <ddellacosta> I was far more confused by working with numbers in general in Haskell when I started than I was when learning Monad
12:35:21 <dminuoso> Cale: Oh yes, constraing producing type level functions makes it much easier. That's something you should reinforce with beginners.
12:35:25 <dminuoso> *constraint
12:35:32 <ddellacosta> probably because I didn't expect them to be challening to work with
12:35:34 <dminuoso> ;)
12:35:45 <ddellacosta> *challenging
12:36:16 <Cale> dminuoso: constraint-producing?
12:36:33 <Cale> I mean like IO and Maybe are monads, but getLine and Nothing are not
12:36:54 <dminuoso> 21:34:18             Cale | It's important to reinforce that "the monad" refers to the type-level function
12:36:58 <dminuoso> What eactly did you mean by that?
12:37:06 <Cale> IO is a type-level function
12:37:13 <dminuoso> Oh, no you misunderstand.
12:37:42 <dminuoso> By "the monad" both of them were not talking about "List as the monad" (or confusing [Int] as the monad). But rather, they seemed to have a lose and abstract notion of "The monad being something"
12:37:55 <dminuoso> Something you could 
12:38:00 <dminuoso> "enter" and "exit"
12:38:15 <monochrom> Mathematicians have no trouble with "(Z, +, 0) is a group, (Z, *, 1) is not a group". They don't need to change "group" to an adjective to deconfuse. This can be learned, it is not that hard.
12:38:15 <dminuoso> Haven't been able to get them to verbalize their exact mind model.
12:38:54 <dminuoso> Well to be fair, its easy to state that "a group is a triplet following some conditions", then identify the triplet as being that entity.
12:39:09 <dminuoso> Category theory makes this a bit easier since you can just point at an object and say "well this is a monoid"
12:39:30 <monochrom> Conversely, I see all the time OO students who confuse an object with the class that the object belongs to.
12:40:07 <monochrom> Notice that the OO community has already agreed to use nouns for non-abstract class names.
12:40:24 <monochrom> (adjective for interface names, sure)
12:40:40 <maerwald> In my first OOP class they talked about ice cream (as objects)... much worse than burritos
12:40:55 <maerwald> quite confusing overall
12:41:02 <monochrom> Their poster-child example is "class Shape" not "class Shapable" or "class HasShapeMethods"
12:42:15 <maerwald> The only analogy that would be worthwhile would be platos thoery of ideas
12:42:38 <maerwald> Classes don't exist. They are just ideas.
12:43:10 <dminuoso> Languages that have reflection would like to disagree.
12:44:19 <Cale> Classes ought to be the types of objects, except that OO languages confuse the matter by tying method implementations to classes
12:44:59 <dminuoso> What do you mean by "tying method implementations to classes" exactly?
12:45:43 <monochrom> I think "enter and exit [the] monad" is not caused by the noun, but rather caused by the * -> * kind, you are confronted with "prog :: M X", and you are unhealthily hell bent looking for "e :: M X -> X".
12:46:11 <monochrom> For example beginners don't think in terms of entering and exiting Monoid.
12:46:48 <dminuoso> monochrom: to be fair, I entertain the idea of "entering and exiting the monad" somewhat frequently, where "exiting" is equated to "running the effects" 
12:54:53 <frdg> monochrom: I can't see enough of the chat to be able to tell this, but are you saying the mindset of seeing a monad as something you enter and exit is incorrect?
12:55:56 <monochrom> I think so, but see also dminuoso's point. But I was not saying it, I was explaining where it came from.
13:01:37 <dmj`> that monad mindset
13:19:41 * hackage opentelemetry 0.5.2 -   https://hackage.haskell.org/package/opentelemetry-0.5.2 (DmitryIvanov)
13:20:42 * hackage opentelemetry-lightstep 0.5.2, opentelemetry-wai 0.5.2, opentelemetry-extra 0.5.2 (DmitryIvanov)
13:24:32 <GreyFaceNoSpace> can someone send me a good guide for lazy evaluation?
13:27:57 <koz_> GreyFaceNoSpace: Start here: https://apfelmus.nfshost.com/articles/lazy-eval-intro.html
13:35:42 <GreyFaceNoSpace> koz_ thanks
13:44:37 <maerwald> pinned memory seems to be all ARR_WORDS
13:44:46 <maerwald> what is that exactly
13:46:45 <int-e> could be any variable-sized object (word granularity) without pointers. UArray, Vector, Bytestring, a chunk of Text...
13:47:08 <merijn> int-e: ByteStrings aren't pinned
13:47:17 <merijn> int-e: They use ForeignPtrs
13:47:40 <merijn> oh, wait, maybe that means they are pinned? Now I confused myself
13:47:49 <dolio> Yes, that's what it means.
13:48:24 <dolio> ForeignPtrs need to be pinned so that they don't move from where the foreign code thinks they are.
13:48:56 <dolio> Most of those other things aren't necessarily pinned, though.
13:51:36 <int-e> merijn: Oh right, hrm. There's Data.ByteString.Short though.
13:52:35 <int-e> Which is apparently used by the bytestring builder. But yeah, it shouldn't account for big amounts of memory.
13:53:35 <int-e> I'm right about Text though, phew.
13:54:04 <GreyFaceNoSpace> i am trying to figure out lazy evaluation and can't seem to 100% grasp it. https://pastebin.com/0TuQEfY9   here is an example i am trying to understand. 
13:54:10 <GreyFaceNoSpace> is there an algorithm i can follow
13:54:20 <GreyFaceNoSpace> to be able to evaluate like the compiler does
13:54:52 <merijn> GreyFaceNoSpace: Not really
13:54:57 <merijn> GreyFaceNoSpace: Evaluation order isn't specified
13:55:05 <merijn> In fact, laziness isn't even specified :p
13:55:06 <GreyFaceNoSpace> hmm
13:55:12 <GreyFaceNoSpace> thats weird.
13:55:17 <merijn> Why?
13:55:20 <GreyFaceNoSpace> considering everything is so well defined in haskell
13:55:23 <GreyFaceNoSpace> and specified
13:55:41 <merijn> GreyFaceNoSpace: It's explicitly not specified so compilers can optimise whatever works out best
13:55:48 <GreyFaceNoSpace> so the example i sent can be evaluated in another way?
13:57:17 <dolio> int-e: It's probably still byte strings, because I think the straight forward way to allocate a foreign pointer inside GHC is implemented by allocating a pinned byte array and then getting the foreign pointer to it.
13:57:19 <int-e> Well, compilers are not allowed to evaluate thunks unless they're needed or guaranteed not to be bottom...
13:57:21 <merijn> Theoretically, yes. In general, probably not
13:57:45 <merijn> int-e: Or they implement a funky "try, throw, and rewind" logic ;)
13:58:05 <int-e> ouch
13:58:06 <merijn> int-e: Maybe a timeout on evaluation ;)
13:58:16 <merijn> int-e: Maximally malicious language implementation, baby!
13:58:28 <int-e> Because that's the spirit of Haskell?!
13:58:42 <dolio> There was an experimental implementation that did that.
13:58:55 <merijn> I've been inspired by the thought experiment of the maximally malicious C compiler. Which is a strictly standard compliant compiler designed for maximum maliciousness :)
13:59:08 <dolio> It is not malicious.
13:59:12 <merijn> int-e: The spirit of Haskell is to not worry about these banal and dirty implementation details
13:59:49 <int-e> merijn: That's relying on a benign compiler if you ask me.
14:03:32 <dolio> The main tricky part in doing that kind of thing is making sure you don't make the program asymptotically slower by repeatedly trying out evaluations that won't finish.
14:03:42 <dolio> So it requires some bookkeeping.
14:04:52 <dolio> Like, when you optimistically evaluate an argument, you need to write back something that indicates that it has already been tried.
14:06:42 <dolio> However, the advantage is that you need to worry less about some things. For instance, everyone says (correctly) that you should use foldl' and not foldl, because the examples of situations where it is beneficial to not keep the accumulator reduced are pretty contrived.
14:06:55 <dolio> However, with optimistic evaluation, foldl just does the right thing in most scenarios.
14:27:29 <monochrom> optimistic evaluation for pessimistic performance, heh
14:31:53 <maerwald> the %alloc in the ghc profiling is about the size or the number of allocations?
14:45:06 <maerwald> and what is SYSTEM when running heap profile with -hm
14:55:27 <hyiltiz_> is it an ENV var?
14:57:49 <maerwald> a what?
15:06:35 <monochrom> The answer is "no".
15:09:00 <monochrom> I guess RTS but I don't actually know.
15:09:18 <maerwald> Well, there is 1.2GB in it
15:09:22 <maerwald> what does it do
15:09:38 <dmj`> maerwald: are you using +RTS -c -RTS
15:09:51 <monochrom> I guess evaluation stack but same caveat :)
15:10:02 <maerwald> +RTS -hm -p -RTS
15:18:17 <suzu_> -hmmm
15:20:30 <maerwald> it's impossible to analyse memory leak or strictness issues with this
15:20:52 <maerwald> all is just pinned system memory...
15:41:06 <dmj`> maerwald: use -hy
15:41:19 <dmj`> maerwald:  also I prefer +RTS -s -RTS because you don't need to compile with profiling
15:42:18 <dmj`> maerwald: pinned system memory is probably ByteString, since bytestring allocates on the C heap but its represented as pinned by the profiler, this means the GC won't relocate it
15:51:41 * hackage base64 0.4.2.2 - Fast RFC 4648-compliant Base64 encoding  https://hackage.haskell.org/package/base64-0.4.2.2 (topos)
21:22:45 <Guest32899> Im trying to use opengl with haskell but GHC cant find the OpenGL or GLUT package even though ive installed it ith cabal
23:33:49 <jchia1> Is there a package that lets me generate random values of my own type in a monad? E.g. I want to make a tuple of 10 random [Int] without explicitly stepping through the intermediate values of the RandomGen.
23:35:13 <jchia1> Similar to Test.QuickCheck.Gen but I don't want to run it in IO but want to explicitly provide the initial RandomGen and get back the final RandomGen.
23:37:31 <jchia1> Maybe it's too simple so I can define it myself with State?
23:50:19 <dsal> If you don't want to run in IO and you don't want to supply a random generator, then what do you want it to do?
