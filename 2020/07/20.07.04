00:48:54 <jchia1> dsal: This is what I do:
00:48:54 <jchia1> randomM :: (Random a, RandomGen g) => State g a
00:48:54 <jchia1> randomM = state random
00:54:03 <jchia1> cabal-install question: How do I actually run "cabal bench" on bz2 while turning off the "with-bzlib" flag so that the benchmark does not test bzlib? https://hub.darcs.net/vmchale/bz2/browse/bz2.cabal
00:56:08 <jchia1> I tried "cabal bench --flags='-with-bzlib'" but it complained like this:
00:56:08 <jchia1> cabal: Could not resolve dependencies:
00:56:08 <jchia1> [__0] trying: bz2-1.0.1.0 (user goal)
00:56:08 <jchia1> [__1] rejecting: bz2:+with-bzlib (constraint from config file, command line flag, or user target requires opposite flag selection)
00:56:08 <jchia1> ...
00:59:00 <sclv> cabal configure with the flag you want, then cabal bench
01:01:56 <jchia1> sclv: "cabal configure --flags='-with-bzlib'" gave the same error.
01:03:51 <sclv> then beats me
01:15:33 <AlexandrosLiarok> hi everyone
01:16:27 <AlexandrosLiarok> quick question, what's the main difference between fixplate and recursion-schemes? 
01:35:37 <jchia1> sclv: It turns out the cabal.project.freeze is the culprit. I just had to remove the bz2 line from it and "cabal clean", remove any cabal.project.local, and rerun the cabal bench with the flags I want.
02:29:38 <kuribas> I can get the dataconstructor names and fieldnames from an ADT using Data.Data, but how do I get the types of the constructor arguments?
03:08:51 <adsfasdf> hello
03:10:33 <adsfasdf> hi
03:10:41 <juri_> hio!
03:17:08 <kuribas> oh, generics-eot looks interesting
03:17:57 <kuribas> it's a generics library that keeps things simple, so it doesn't require you to be a haskell wizzard.
03:22:22 <int-e> . o O ( scrap your brain? )
03:25:41 * hackage rpmbuild-order 0.3.1 - Order RPM packages by dependencies  https://hackage.haskell.org/package/rpmbuild-order-0.3.1 (JensPetersen)
04:05:41 <kuribas> int-e: actually, it simplified my definitions :)
04:05:54 <kuribas> and it has proper termination, unlike Generics.
04:06:11 <kuribas> Like (Either a Void)
04:06:21 <kuribas> and (a, (b, ()))
04:09:01 <kuribas> which generics got wrong IMO
04:09:26 <kuribas> and a lot of type level libraries as well
04:23:12 <maerwald> any easy to understand Haskell library? Heretic!
04:23:20 <kuribas> I know, right?
04:41:00 <mniip> kuribas, caveat: generics will actually balance the binary tree
04:41:11 <mniip> in an attempt to salvage type family performances
04:42:10 <kuribas> mniip: yeah, generics-eot will generate Right (Right (Right (Right ...))) 
04:42:19 <kuribas> for constructors
04:42:53 <kuribas> mniip: if I write a library, I would use generics, but I need to something simple for haskell beginners.
04:43:35 <mniip> >haskell beginners
04:43:37 <mniip> >generics
04:44:43 <kuribas> mniip: Not that they need to write it.
04:44:52 <kuribas> mniip: just not to scare them away
04:46:01 <kuribas> besides, if you understand typeclasses, sum types and product types, generic-eot should be udnerstandable.
04:46:47 <kuribas> you need to understand the isomorphism between ADTs and Eithers of Tuples.
04:47:02 <kuribas> which IMO is not advanced haskell
04:47:04 <kuribas> I could be wrong...
05:00:22 <kuribas> absurd has a weird implementation: absurd a = a `seq` spin a where spin (Void b) = spin b
05:00:31 <kuribas> why not just absurd a = undefined ?
05:13:27 <xerox_> one difference is that that one is strict
05:13:31 <xerox_> dunno what spin is about
05:15:46 <int-e> kuribas: well, absurd a = undefined  would lose information about the kind of bottom that `a` is. But why it's not a `seq` undefined I can't say.
05:16:31 <kuribas> why do you want to "seq" a value that cannot exist?
05:16:40 <int-e> because undefined does exist
05:17:41 <int-e> absurd (error "This was an error somewhere interesting") = undefined  would lose the potentially interesting error message.
05:19:05 <int-e> And maybe ghc is too clever when you write  absurd a = a `seq` undefined?
05:19:44 <kuribas> right...
05:23:09 <int-e> Meh, superficial testing suggests a `seq` undefined would be fine.
05:24:26 <int-e> The alternative is that `spin` constitutes a proof that `absurd` is total in absense of bottoms.
05:26:41 <boxscape> huh why not just `absurd a = case a of {}`
05:27:15 <boxscape> wait I might be talking about a different absurd
05:28:00 <boxscape> since the one in Data.Void is defined this way
05:28:05 <int-e> boxscape: I suspect this one is a Haskell 98 variant, newtype Void a = Void (Void a).
05:28:13 <boxscape> ah, isee
05:28:56 <int-e> (I guess I'm too lazy to check whether Haskell 2010 has empty data types)
05:29:11 <boxscape> it does
05:29:24 <int-e> thanks
05:33:45 <maerwald> kuribas: generics-eot is too easy to understand. This should not be allowed
05:34:07 <maerwald> https://hackage.haskell.org/package/generics-eot-0.4.0.1/docs/Generics-Eot.html#t:Datatype
05:34:11 * hackage haskoin-store-data 0.34.6 - Data for Haskoin Store  https://hackage.haskell.org/package/haskoin-store-data-0.34.6 (jprupp)
05:34:39 <maerwald> That datatype makes actual sense without a PhD in maths
05:35:11 * hackage haskoin-store 0.34.6 - Storage and index for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-store-0.34.6 (jprupp)
05:36:12 <kuribas> maerwald: it also doesn't look very efficient.
05:36:19 <idnar> kuribas, int-e, boxscape : https://stackoverflow.com/a/38559050/31490
05:43:56 <int-e> idnar: nice. seems I got pretty close.
05:45:05 <int-e> (the missing bit would have been to try older ghc's all the way up to 7.10)
05:56:11 <dminuoso> You dont need a PdH in maths to understand GHC.Generis either.
05:56:41 <dminuoso> And indeed, generics-eot likely has rather poor runtime characteristics.
06:00:47 <kuribas> dminuoso: depending on the amount of GHC inlining and deforestation
06:03:11 <int-e> Yeah, GHC.Generics is not too bad. I found the syb types tricky, e.g. https://hackage.haskell.org/package/syb-0.7.1/docs/Data-Generics-Twins.html#v:gzipWithM
06:05:22 <dminuoso> kuribas: Well that's putting a lot of faith into it, with GHC.Generics you just avoid the need for list fusion. 
06:05:55 <kuribas> dminuoso: you also want fusion for generics.  Conversion to and from Rep a is expensive.
06:06:13 <kuribas> dminuoso: also, I am not talking about list fusion
06:06:36 <kuribas> I mean GHC being eliminate constructors without rewrite rules.
06:07:46 <dminuoso> I thought deforestation was specifically about lists *shrugs*
06:07:48 <dminuoso> Anyhow
06:08:04 <dminuoso> Generics relies much less on it, because the pattern matching happens at the type level using typeclasses.
06:08:38 <dminuoso> And the price you pay for `to` and `from` you incur whether you use generics-eot or GHC.Generics either way.
06:08:50 <dminuoso> Since generics-eot uses GHC.Generics behind the scenes
06:09:48 <kuribas> dminuoso: I may have used the wrong term :)
06:10:43 <kuribas> dminuoso: it does seem like ghc could eliminate it.  At least when I added INLINE pragmas to my generic functions.
06:13:18 <kuribas> well it makes sense that if it can eliminate intermedia Rep, it can eliminate Eot.
06:13:40 <kuribas> up to some depth of constructors I assume.
06:31:41 * hackage opentelemetry 0.5.3 -   https://hackage.haskell.org/package/opentelemetry-0.5.3 (DmitryIvanov)
06:32:41 * hackage opentelemetry-lightstep 0.5.3, opentelemetry-wai 0.5.3, opentelemetry-extra 0.5.3 (DmitryIvanov)
06:45:33 <ocramz> hullo!
06:48:11 <ocramz> anyone with ekg-core experience? I'm logging the GC stats of a process that runs on Google cloud run, and both 'rts.gc.current_bytes_used' and 'rts.gc.max_bytes_used' return 0. First, wtf? Second, I'd appreciate any pointers
06:50:21 <ocramz> what I find strange is that another service that was built with the same RTS options and deployment config (container OS etc.) outputs reasonable memory usage numbers
07:09:11 * hackage cmdargs-browser 0.1.4 - Helper to enter cmdargs command lines using a web browser  https://hackage.haskell.org/package/cmdargs-browser-0.1.4 (NeilMitchell)
07:34:41 <maerwald> l'm reading thinking with types and it says: Use Curry–Howard to prove that a^b x a^c = a^(b+c)
07:34:41 <maerwald> That is, provide a function of type (b -> c -> a) -> (b, c) -> a, and one of ((b, c) -> a) -> b -> c -> a. 
07:34:56 <maerwald> But that makes no sense. According to the isomorphism it would be: (b -> a, c -> a) -> Either b c -> a
07:34:56 <maerwald> I think the two exercises are flipped.
07:35:54 <maerwald> What he means is: (a^b)^c = a^(b x c)
07:36:56 <maerwald> Seems the pdf doesn't have that error, only the epub -.-
07:39:59 <maerwald> Confusing learning material is confusing. You never know if you're too dumb or if it's a legit error
07:43:19 <yogani> i'm learning about FRP with Yampa and I'm wondering about stateful signal functions - I've been studying this codebase: https://github.com/pedromartins/cuboid
07:44:20 <yogani> I'm pretty surprised to see the use of switches to force a reset to a stateful signal function - this doesn't feel correct to me, and I'm wondering if rather this state should be extracted to the input/output state
07:45:24 <whataday> we have Functor, why we need Monad?
07:45:58 <whataday> :t fmap
07:45:59 <lambdabot> Functor f => (a -> b) -> f a -> f b
07:46:17 <whataday> :t (<*>)
07:46:18 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
07:46:22 <oats> whataday: Functor and Monad are different things
07:46:33 <whataday> :t (>>=)
07:46:34 <oats> all monads are functors, but not all functors are monads
07:46:35 <lambdabot> Monad m => m a -> (a -> m b) -> m b
07:47:17 <whataday> that fmap ap and bind all are just turn f a to f b
07:47:40 <whataday> what's the different here?
07:47:48 <frdg> when :sprint returns _ does this mean that the expression is in WHNF?
07:48:39 <oats> whataday: you're only looking at the second parameter and the return types though, that doesn't tell you the whole storey
07:49:01 <whataday> what's the whole story?
07:49:09 <oats> notice that fmap' first parameter is a plain function, (a -> b)
07:49:35 <oats> but <*> will take a function that is in a "container" of some sort
07:50:49 <whataday> and bind takes a -> m b
07:50:56 <ski> @type liftA2
07:50:57 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
07:51:07 <ski> you can't do that, with only `Functor'
07:51:08 <oats> a more abstract way of thinking about these differences is that Functor will let you use "lift" functions of one value into a context, and Applicative will let you lift functions of multiple values into a context
07:51:16 <ski> @type (>=>)
07:51:18 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
07:51:26 <ski> and you can't do that, with only `Applicative'
07:51:37 <oats> and then you have Monad, yes
07:52:35 <oats> Monad is for when you want to the things I mentioned already, but you also want to compose functions that take a "plain" value and return "wrapped" values
07:52:46 <oats> which you can't use the regular composition function (.) on
07:53:04 <ski> `Functor' lets you operate, independently, on each "element" of a "collection". or to add (non-effectful) "post-processing" operations to an effectful operation
07:54:26 <ski> `Applicative' let's you merge multiple effectful operations into one, sequencing them. but it doesn't let you decide what effectful operation to do later, depending on what intermediate result you got earlier, while `Monad' allows that. one might call what `Applicative' gives you, "static sequencing", while `Monad' gives "dynamic sequencing"
07:56:37 <whataday> and `Monad'?
07:56:56 <frdg> ski: "Applicative gives static sequencing while Monad gives dynamic sequencing." This is the best explanation I've heard, it really all just clicked from this sentence.
07:58:02 <oats> > (+) <*> Just 5 <*> Just 4
07:58:05 <lambdabot>  error:
07:58:05 <lambdabot>      • Couldn't match expected type ‘Maybe (Integer -> Integer -> b)’
07:58:05 <lambdabot>                    with actual type ‘Integer -> Integer -> Integer’
07:58:09 <ski> frdg : yea, i've been starting to use those terms, "static sequencing" vs. "dynamic sequencing", more, over the years, to describe the difference
07:58:11 <oats> oh
07:58:22 <oats> Just (+) <*> Just 5 <*> Just 4
07:58:28 <oats> > Just (+) <*> Just 5 <*> Just 4
07:58:30 <lambdabot>  Just 9
07:58:31 <ski> @where applicative-vs-monadic
07:58:31 <lambdabot> "Applicative vs Monadic build systems" by ndm in 2014-07-23 at <https://neilmitchell.blogspot.se/2014/07/applicative-vs-monadic-build-systems.html>. (cf. "static sequencing" vs. "dynamic sequencing")
07:58:41 <oats> > Just (+) <*> Nothing <*> Just 4
07:58:44 <lambdabot>  Nothing
07:58:55 <oats> ^^ this computation cannot be done with just Functor, something extra is needed
07:59:03 <ski> whataday : `Monad' gives dynamic sequencing
08:00:41 * hackage path-like 0.1.0.0 - FileLike and DirLike type classes for the Path library.  https://hackage.haskell.org/package/path-like-0.1.0.0 (locallycompact)
08:01:53 <ski> `mpa toLower <$> getLine' attaches a "to lower case" transformation to be done after doing the I/O effect of getting a line. that's just using `Functor'
08:01:58 <ski> er, s/mpa/map/
08:03:34 <ski> `replicate <$> readLn <*> getLine' will combine two effectful operations, in order : first read (parse) an `Int', then get a line. give back a list containing that line, repeated the specified number of times
08:04:37 <frdg> ski: reading that link now
08:04:51 <ski> we can combine the two intermediate result values here, with `Applicative', but we can't use any of them to decide what effects to perform .. unless we start using other "plumbing" operations thatn just `Applicative', such as `Monad'
08:05:02 <frdg> this is the guy that made ghcid!
08:07:24 <ski> `flip replicateM getLine =<< readLn' will first get the `Int', then use that to get that many lines (rather than getting a single line, then replicating that value). this is an example of "dynamic sequenceing", with `Monad', letting previous intermediate results of effectful operations determine what effects you do later. you could also imagine having an `if' or a `case' on the intermediate value, branching out
08:09:51 <ski> .. for some time, some people were a bit reluctant to use the terminology "sequencing" with `Applicative' and `Monad', saying that they're not really about sequencing
08:10:25 <ski> but i've increasingly becoming convinced that it is indeed about sequencing. with a few caveats
08:11:20 <ski> (a) not every `Applicative' or `Monad' instance cares about the sequencing you may express. there are "commutative" instances, such as `Reader r', e.g.
08:12:04 <ski> (b) the sequencing that is being expressed doesn't necessarily have to correspond directly to what you may think of as sequencing, depending on the particular instance
08:12:43 <EvanR> what does it (sequencing) directly correspond to
08:12:46 <ski> e.g., with lists expressing (angelic) nondetermism, the "sequencing" you express with them would usually be described in terms of "nested loops"
08:13:32 <frdg> ski: What do you think of the mindset of a monad being something you enter and exit?
08:13:59 <ski> i'd have to try to understand what you mean by "enter" and "exit", there
08:15:03 <EvanR> that only makes sense for some monads, the ones that have a 'run'
08:15:23 <EvanR> which corresponds to "exiting"
08:16:13 <frdg> ski: I guess it would be this: In a monadic expression once you first use (>>=) You have "entered" the monad. While in the monad you can do the monad stuff (dynamic sequencing), and then once you return/pure you have exited the monad.
08:16:20 <EvanR> since run and exit don't seem related at all... i'm not sure exiting is real
08:17:05 <ski> frdg : hm. that seems to me to be a not very useful analogy or way of describing it
08:17:42 * ski . o O ( "You can enter a room once, yet leave it twice." )
08:17:45 <EvanR> >>= doesn't enter a monad. Other ways to create a value with a monadic type are return and API specific ways
08:18:50 <ski> presumably frdg had the step from `m a' to `a' in mind, in `m a -> (a -> m b) -> m b'
08:18:59 <EvanR> also wouldn't most people see a run-style api and call that entering
08:19:37 <EvanR> withFile enters a file, try enters an exception handler
08:19:51 <frdg> This is kind of how I have thought of monads up to this point but I think my new-found revelation of dynamic-sequencing has given me new insight
08:20:57 <ski> the sequencing, or ordering, that we're talking about, is similar to the ordering in `x * y * z'. not all number systems care about the ordering of factors, when multiplying. but if we're talking about quaternions, or matrices, then the ordering matters
08:21:34 <EvanR> * here is like join?
08:21:41 <ski> e.g.
08:21:50 <EvanR> i had not thought of join allowing ambiguity
08:21:52 <ski> or `liftA2 (,)' if you prefer
08:21:57 <monochrom> IMO * here is like liftA2
08:22:30 <EvanR> liftA2 f... ok
08:23:37 <EvanR> but isn't x * y * z an example which lacks ordering
08:23:45 <EvanR> because it forgot the parens
08:23:51 <ski> re (b), the ordering we're talking about is not necessarily an operational ordering, in which order the machine will do low-level steps. it's a conceptual ordering. each instance of `Applicative' or `Monad' will define it's own notion of what "sequencing" means
08:23:56 <monochrom> compared to z * y * z
08:24:00 <ski> what monochrom said
08:24:01 <monochrom> err, z * y * x
08:24:09 <ski> (ordering is not grouping)
08:24:36 <monochrom> Fortunately liftA2 and >>= have associative laws like * does. The analogy is an isomorphism.
08:24:56 <ski> we have associativity (and neutral element laws), so grouping doesn't matter. `(x * y) * z' is the same as `x * (y * z)', also for quaternions and matrices
08:25:24 <monochrom> What they all lack is a commutative law. This is license to call them sequencing.
08:26:07 <monochrom> (Aside: Associative laws justify refactoring.)
08:26:40 <frdg> And if monads did commute there would be no need for transformers?
08:27:09 <monochrom> We are talking about term-level commute, not type-level commute.
08:27:24 <frdg> oh ok
08:29:21 <EvanR> so sequencing is dealing in liftA2s. But monads are based on fmap and joins, which are unary
08:29:21 <ski> sometimes people say "the monad", when they're really meaning "the monadic action"
08:29:43 <ski> `join' is binary
08:29:54 <ski>   join : M . M >---> M
08:30:12 <whataday> the "context" is on value level or type level?
08:30:15 <monochrom> >>= and >=> are binary.
08:30:38 <EvanR> >>= is a combination of fmap and join. Excuse my while ski's remark warps my brain
08:31:22 <whataday> that "sequence" stuff confuse me too...
08:31:30 <ski> `join' "takes an `M' inside another `M', and combines them" ("smashing two layers into one")
08:31:34 <whataday> I never heard that before
08:31:50 <EvanR> i knew what much
08:32:00 <ski> that's binary
08:32:02 <EvanR> now how do i go from that to thinking of it as a binary op
08:32:32 <ski> what about `sequence' confuses you, whataday ?
08:34:26 <whataday> sorry, my English is not good, you sequence story is really plain, but I still have no idea what it's about dynamic and static, could Applicative have if-else?
08:35:23 <whataday> also the "context", we describe it on type level or value level?
08:35:39 <whataday> we say Maybe is a context or Just is a context?
08:37:04 <ski> oh. i was thinking maybe you were asking about
08:37:07 <ski> @type sequence
08:37:09 <lambdabot> (Traversable t, Monad m) => t (m a) -> m (t a)
08:37:10 <ski> @type sequenceA
08:37:11 <ocramz> whataday : to be honest, I've been using haskell for ~ 5 years now and still it's not clear to me why people use this static/dynamic terminology for applicative vs monad. I think it's easiest to understand applicative via examples rather than metaphor
08:37:11 <lambdabot> (Traversable t, Applicative f) => t (f a) -> f (t a)
08:37:23 <whataday> I know when I should use Functor or Applicative now, like that fmap and liftA2 type signature
08:38:30 <whataday> ski, confused on your dynamic/static sequences
08:38:31 <ski> whataday : tbh, i don't really understand the "context" terminology much. i'm not sure how much it helps, or how coherent it is
08:38:41 <ski> yea, i realized that, after a little while
08:38:55 <whataday> but you used "context"
08:39:08 <whataday> and a lot of people use it...
08:39:18 <monochrom> This is why I don't use it :)
08:39:23 <ski> and no, with just `Applicative', you can't express a choice of effects, depending on the intermediate result of performing some earlier effectful operation
08:39:37 <EvanR> context applies to another subclass of monads, one where you keep a hidden record of importnat data as the actions are applied
08:39:48 <EvanR> it's not a general monad thing
08:40:12 <ski> whataday : i did not use "context" in this discussion (apart from referring to when you mentioned it)
08:40:25 <EvanR> aiui this context is elevated to an actual thing in effect systems
08:41:35 <whataday> oh, my fault, oats used it
08:41:51 <ski> ocramz : do you need the ability to decide which actions to perform later, depending on earlier intermediate results of actions ? then you need dynamic sequencing
08:42:34 <grfn> how do I get cabal to dump-simpl with the new-style-builds?
08:42:53 <grfn> I'm building with `cabal build --ghc-options -ddump-simpl --ghc-options -ddump-to-file`
08:43:07 <monochrom> don't you need more = signs?
08:43:08 <grfn> but 1. cabal says "up to date" and 2. I don't see any `.dump-simpl` files
08:43:27 <grfn> I thought it parsed even without the `=` but I'll try that
08:43:39 <monochrom> also I'm afraid this is one of those things you need to say at configure time
08:43:39 <grfn> yeah, adding `=` doesn't change anything
08:43:58 <grfn> yeah, I tried `cabal configure --ghc-options -ddump-simpl --ghc-options -ddump-to-file` too
08:44:02 <grfn> also no dice
08:44:09 <ski> whataday : i try to not use analogies which i feel i don't really understand :)
08:44:16 <monochrom> OK, then I don't know.
08:44:39 <grfn> tried a clean
08:44:45 <grfn> and now they're in `dist-newstyle`
08:45:03 <grfn> so guess cabal doesn't bust builds based on changed ghc-options? *shrug*
08:45:10 <grfn> feels like maybe a bug
08:46:11 <monochrom> On this front, cabal just delegates to ghc.
08:46:34 <ski> ocramz : but yes, examples really help to substantiate. but i think the metaphors (if used carefully) can help to catalogize, make sense of, one's experiences
08:47:39 <oats> whataday: I apologize, in my experience it's kind of hard to convey the idea of Functor in an intuitive way
08:47:59 <oats> the technical explanation is that it's anything that can be mapped over
08:48:18 <oats> so a "plain" value could be an integer of some kind, say type Int
08:48:32 <oats> an Int in a Functor could be a list, [Int]
08:48:33 <ski> `Functor' is commonly described in terms of the "collection" analogy
08:48:38 <oats> here [] is the Functor
08:49:14 <oats> or could be a 'Maybe Functor', where Maybe is the Functor
08:49:29 <oats> shit, I meant 'Maybe Int' :P
08:49:32 <oats> apologies
08:49:46 <oats> or it could be 'IO Int' where IO is the functor
08:49:52 <oats> these all seem like separate concepts
08:49:59 <ski> "an Int in a Functor" sounds confused. "an Int" presumably refers to a value. but the `Functor' is not the list that you're talking about, containing `Int's. rather the list type constructor, `[]', (together with its `fmap' implementation) is the functor
08:50:07 <oats> but there's an underlying idea that you're modifying the idea of an Int in some way
08:50:42 <oats> either to say that there's a collection of Ints in a List, the possiblility that there is no Int in a Maybe, or that you've got some IO recipe that will produce an Int
08:50:42 <monochrom> I think it's just broken natural languages. People do have the right thoughts.
08:50:48 <oats> these are all "contexts" around an Int
08:51:00 <ski> (perhaps you didn't mean it like that. but i've other heard people confusing terminology like this, saying things like "well, my function takes a monad, and a list, ...")
08:51:07 <EvanR> yeah Functor goes way beyond containers, and beyond haskell. You necessarily need to truncate the analogy somewhere
08:51:09 <dminuoso> oats: The notion of collection can be stretched quite a bit. 
08:51:24 <monochrom> "an Int in a Functor" is short form for "an Int in a type like Maybe, in which Maybe is an instance of Functor".
08:51:36 <oats> I don't think I said anything about collections
08:51:40 <dminuoso> I mean claiming `Const a Int` is a container with no ints is stretching the definition of "container" a bit.
08:51:42 <oats> I threw in IO for some variety :P
08:51:53 <EvanR> "an Int in a Functor"
08:52:04 <EvanR> containerization of concepts
08:52:11 <oats> EvanR: I guess in that case, we're talking about the type
08:52:31 <oats> the type Int is in a container 'f' where 'Functor f'
08:52:36 <EvanR> i was kind of supporting the containre analogy, as far as it goes
08:52:41 <dminuoso> Im reiterating my claim from yesterday: Part of the confusions relating to Monad or Functor, is that they are nouns.
08:52:41 <oats> ahhh
08:52:48 <dminuoso> If Functor was called Mappable, we wouldn't have this discussion.
08:52:55 <monochrom> Note that also for example speak like "I'm adding two Ints".  They definitely don't mean "Int :+: Int at the type level" (unlike the "join :: M.M -> M is 2-ary" example, haha).  They mean "I'm adding two values, both have type Int".
08:53:02 <EvanR> agreed
08:53:43 <monochrom> Natural languages collapses terms and types and kinds and all levels. It can't be helped.
08:53:47 <ski> oats : "but there's an underlying idea that you're modifying the idea of an Int in some way" .. yes, if you replace "modify" by "operate on", or something like that
08:53:49 <oats> hmm, so Functor => Mappable, Applicative => Sequenceable, Monad => ....Composable? :P
08:53:58 <dminuoso> oats: Joinable.
08:54:06 <oats> ah right, that's a better one
08:54:10 <EvanR> but if Functor was Mappable and Monad was AndThenable, people might slip and extend ghc in a direction that broke its category theory or didn't achieve its real potential
08:54:37 <EvanR> lens might not have been invented :)
08:54:45 <ski> EvanR : or just generalize "container" to cover any instance of `Functor'
08:54:50 <EvanR> no!
08:54:51 <EvanR> no
08:54:52 <oats> EvanR: huh, good point
08:55:15 <dminuoso> EvanR: Note Im not making the case to rename Functor Mappable, just that these nouns could add to confusion.
08:55:29 <EvanR> everything is a container is like , as annoying as "every function/operator is a matrix"
08:56:02 <monochrom> dminuoso: I think I have looked at how OO people confuse themselves and found that adjectives don't make a difference.
08:56:11 * hackage ghc-lib-parser-ex 8.10.0.15 - Algorithms on GHC parse trees  https://hackage.haskell.org/package/ghc-lib-parser-ex-8.10.0.15 (shayne_fletcher)
08:56:17 <ski> dminuoso : hm, interesting point
08:56:42 <ski> not everything. just everything which has an `fmap' ;)
08:56:55 <dolio> I don't see how Functor being a noun causes the confusion of things being 'inside' functors.
08:57:17 <ski> (and it's more like "could be seen as a container", rather than "is a container")
08:57:34 <dminuoso> dolio: Its an abstract noun that doesn't make it clear that it's just an interface.
08:58:10 <oats> sidestepping just a bit, I also kinda like the idea of explaning them as "overloading" some more basic ideas. Functor lets you overload single function application, Applicative lets you overload multiple-function-application, Monad lets you overload function composition, in a sense
08:58:20 <monochrom> I go one step further and say that Java etc encourages the confusion.
08:58:38 <dminuoso> oats: Functor is not about function application, its about lifting functions rather.
08:58:52 <dminuoso> really, functor is so abstract, its not about anything other than the laws it carries.
08:59:02 <dminuoso> It just so happens that *most* instances are containers of some kind. Most.
08:59:10 <oats> dminuoso: I'm not certain these two ideas are mutually exclusive
08:59:17 <oats> I'm attempting to speak really broadly
08:59:48 <dminuoso> The only way to talk about it broadly, is stop using suggestive names or examples, and just call it what it is. An abstract interface consisting of a single method with a simple law `fmap id = id`
09:00:37 <monochrom> "mappable" is one of those suggestive names.
09:00:43 <dminuoso> An `IO Int` for instance contains as much an `Int` as the command `ls` contains files.
09:00:50 <oats> dminuoso: the trouble there is, I don't believe that explanation is useful for building intuition or understanding for folks coming from more "traditional" imperative, less strongly typed paradigms
09:01:27 <dminuoso> Of course not, you'd usually start by having the user explore various instances, and then discover the common pattern themselves.
09:01:34 <oats> yes!
09:01:44 <dminuoso> Along this path there's usually some notion of "oh this is about containers", until you stare at IO, Async, Const a, etc..
09:02:39 <ski> does `chr' contain `Char'acters ?
09:02:44 <ski> @type chr
09:02:45 <lambdabot> Int -> Char
09:02:46 <monochrom> Is "Reader E" a container? >:)
09:03:00 <ski> squinting a bit, i'd say yes
09:04:45 <monochrom> I once broke a student's mind by pointing out the correspondence between Bool->Y and (Y, Y), the former felt like computation and the latter felt like data structure to the student.
09:04:57 <ski> (and `Const c' clearly is about always-empty containers, with some extra data associated with the container, no ?)
09:05:16 <ski> @quote is.the.solution
09:05:16 <lambdabot> quicksilver says: head-explosion is the solution, not the problem.
09:07:52 <EvanR> you can container anything
09:08:07 <EvanR> somehow it's very appealing
09:08:38 <oats> monochrom: had they seen lambda calculus yet?
09:08:44 <monochrom> yes
09:08:50 <oats> hmm, cool :>
09:08:59 <monochrom> or no, depending on how deeply you mean
09:09:03 <ski> well, whether you want to, whether it'd be much useful to, think of it in such terms, is another question
09:09:05 <oats> heh
09:09:06 <frdg> monochrom: What is the correspondence? I see exactly what your student saw. 
09:09:11 <monochrom> I didn't show them Church encoding.
09:09:20 <ski> frdg : `Y^2 = Y * Y'
09:09:48 <EvanR> another non-commutative *
09:09:48 <monochrom> Convert f::Bool->Y to (Y,Y): (f False, f True).
09:10:00 <ski> EvanR : "commutative upto isomorphism"
09:10:23 <monochrom> Convert p::(Y,Y) to Bool->Y: \b -> if b then snd p else fst p
09:10:48 <frdg> so the correspondence is related to functor?
09:11:05 <EvanR> if only this isomorphism was a software thing in practice :)
09:11:09 <ski> not really, frdg
09:11:20 <ski> it's "just algebra"
09:11:45 <ski> EvanR : Homotopy something something :)
09:11:45 <monochrom> In general: What is "array", mathematically? Answer: An array with index set I and element type Y is modelled by a function f::I->Y.
09:11:52 <EvanR> "algebra" is a good analogy for functoring, applicativing, and monading stuff
09:12:22 <frdg> Ohhh I get it
09:12:23 <EvanR> rather than container, enter, exiting, sequencing, contexting, or whatever, you are doing algebra
09:12:27 <whataday> I don't think Functor or Monad are useful in OOP
09:12:29 <monochrom> Actually the correspondence carries all the way to monad.
09:12:59 <EvanR> i don't think functional programming and OOP are mutually exclusive
09:13:34 <whataday> they're really twisted in OOP, I'm seeing kotlin's arrow library, I have no idea what they're tring to do
09:13:48 <EvanR> well, color me surprised
09:13:49 <ski> in a quite narrow sense, one might say FP is more about variant/sum types, while OOP is more about record/product types
09:14:03 <EvanR> brand new web lang makes a weird library
09:14:08 <ski> however, one really needs both
09:14:11 <monochrom> Define "data P a = MkP a a".  What does its monadic join look like?  Answer: join (MkP (MkP b _) (MkP _ e)) = MkP (b e).
09:14:44 <whataday> most OOP don't support higher-kinded polymorphism
09:14:59 <whataday> so basically they can't implement Functor
09:15:05 <ski> (another term i'm not happy about)
09:15:18 <EvanR> well then, functor and monad are not useful in certain oop languages, is another story
09:15:21 <monochrom> Question: What?! Just that?! And why another combination?!  Answer: It's what you would do for the (->) Bool monad.
09:15:58 <monochrom> err, s/why another/why not another/
09:17:15 <whataday> now I feel type constraints on generics is important, but in OOP they can't have typeclass...
09:17:32 <ski> EvanR : anyway .. i've been pondering a system in which the fact that `join' is binary is reflected in the syntax ..
09:17:38 <EvanR> in any language, you can compute all the types you want in your mind :)
09:17:43 <whataday> though use Sum type can do that too...
09:18:01 <whataday> enum type, union type, sealed class whatever
09:19:20 <EvanR> please do that, because if it doesn't take two arguments I'm having a hard time seeing it as binary
09:19:38 <ski> having a sane way to express pattern-matching on sum types really is of great importance, although people don't seem to talk that much about it, when talking about what FPLs tend to bring to the table
09:19:46 <EvanR> i can't even see the two arguments anywhere, on the term level
09:20:19 <EvanR> a value of type M (M A) isn't necessarily two of anything
09:20:19 <dminuoso> whataday: Plenty traditional languages have typeclasses, they are just called differently.
09:20:22 <dminuoso> Traits, concepts, etc..
09:21:35 <EvanR> (who decided to call something a concept... this... doesn't evoke a damn thing. Not very specific)
09:21:59 * ski idly ponders idioms
09:22:42 <EvanR> Person, Place, Thing, or Concept. Perhaps we should create a programming language feature... Noun
09:24:11 <EvanR> i'll take a container over a concept any day
09:24:39 <ski> @let data CoYoneda f b = forall a. MkCoYoneda (a -> b) (f a)
09:24:40 <lambdabot>  Defined.
09:24:47 <ski> @type \(MkCoYoneda amb ma) -> ma >>= amb
09:24:48 <lambdabot> Monad f => CoYoneda f (f b) -> f b
09:25:50 <ski> `(>>=)' is basically just `join', "expanded coyonedally"
09:27:01 <EvanR> are you saying any value of type M (M A) has at least two terms combined with some monad related operator, like >>= or MkCoYoneda
09:28:06 <ski> if `F' is a functor, then `F T' is equivalent to `exists a. (a -> T,f a)' (and also to `forall a. (T -> a) -> f a', via yoneda)
09:28:09 <EvanR> :t MkCoYoneda
09:28:10 <lambdabot> (a -> b) -> f a -> CoYoneda f b
09:28:40 <EvanR> uh huh
09:29:53 <ski> @type \bc (MkCoYoneda ab fa) -> MkCoYoneda (bc . ab) fa
09:29:54 <lambdabot> (b1 -> b2) -> CoYoneda f b1 -> CoYoneda f b2
09:30:05 <ski> @type \(MkCoYoneda ab fa) -> fmap ab fa
09:30:06 <lambdabot> Functor f => CoYoneda f b -> f b
09:30:22 <ski> @type \fa -> MkCoYoneda id fa
09:30:24 <lambdabot> f b -> CoYoneda f b
09:31:49 <ski> (note that `CoYoneda f' is a functor, even if `f' isn't. e.g. `f' could be `IORef', then we basically get a "read-only view of a reference", that we can `fmap' over (attach post-processing steps to))
09:31:50 <EvanR> exists a . (a -> T, F a) and forall a . (T -> a) -> F a   ?
09:32:06 <ski> yes
09:32:53 <ski> "are you saying any value of type M (M A) has at least two terms combined with some monad related operator, like >>= or MkCoYoneda" -- no
09:33:29 <ski> i'm saying it "consists of two outer `M' layers, wrapping the `A'"
09:33:54 <EvanR> clearly the type is doing that
09:34:25 <ski> what i was experimenting with was allowing to directly name the individual layers
09:35:28 <EvanR> example?
09:37:18 <monochrom> "join :: M.M -> M" is pretty strongly a type-level thing. (object-level thing in category theory)
09:37:42 <monochrom> err worse, in category theory it's even one level above objects.
09:37:54 <ski> well, consider the "associative law" for `join'
09:38:22 <monochrom> It's a natural transformation from the composed functor M.M to the functor M.
09:38:33 <ski>   join (join mmma)  =  join (fmap join mmma)
09:38:42 <ski> or, expressed pointlessly
09:38:46 <monochrom> So you have to think really high-level for it.
09:38:55 <ski>   join . join  =  join . fmap join
09:39:57 <ski> with a more categorical syntax, this would be
09:41:01 <ski>   join_A . join_(M A)  =  join_A . M join_A
09:41:49 * EvanR puts brain on top shelf
09:41:57 <ski> where `join_A : M (M A) >---> M A', and where `M f : M A >---> M B' if `f : A >---> B' expresses the functor `M' acting on a morphism `f'
09:42:32 <ski> one could reformulate the latter, more pointlessly (not mentioning `A'), as
09:42:53 <ski>   join . (join o M)  =  join . (M o join)
09:43:23 <ski> where `o' is "vertical composition" of natural transformations, while `.' is "horizontal composition". (or maybe it's the other way around. i can never recall which is which ..)
09:43:46 <ski> anyway, that's just showcasing a few different ways to express it
09:43:51 <juri_> hmm. I'm aparently being dumb. I have a type that has two constructors. I haave a typeclass attached to both types that are being constructed. i want to write a typeclass instance that only applies to one of those constructors, so i can have a function that will not compile if the other type is passed to it.
09:43:55 <ski> i want to express it in a pointful way, like :
09:44:08 <juri_> I think datakinds might be useful, but i may just be being dumb.
09:44:31 <ski>   join (| join (| m0,m1 |),m2 |)  =  join (|  m0,join (| m1,m2 |) |)
09:44:35 <monochrom> I think you went wrong when you flipped from "I have a type" to "both types".
09:44:46 <juri_> monochrom: sure.
09:45:03 <EvanR> violated conservation of type number
09:45:11 <ski> here `m0',`m1',`m2' are the names of the three individual `M' layers in `M . M . M'. each of `m0',`m1',`m2' has type `M' (not type `M T', for some `T')
09:46:47 <juri_> I guess failing at runtime it is, then.
09:46:59 <ski> EvanR : so, my syntax above is meant to more directly express that it doesn't matter if you first smash together the outer two `M' layers (`m0' and `m1'), and then smash the result of that with the inner one (`m2'), or else first smash the two inner ones together, then merge with the outer one ..
09:48:45 <ski> juri_ : i think monochrom meant that we didn't understand what you meant, what you have done, and what you want
09:49:36 <ski> you have a type with two data constructors. what are the two types you mention then ? maybe argument types to these data constructors ?
09:49:52 <ski> perhaps you should show some (possibly simplified) code ?
09:50:39 <juri_> I want to apply a typeclass to values constructed with one constructor, but not the other, so i can force a function to fail at compile time if it's called with values created with the wrong constructor.
09:51:12 <ski> what does it mean to apply a type class to values ?
09:51:25 <ski> maybe you mean apply some methods of a type class to them
09:51:58 <juri_> https://paste.rs/vY9.hs
09:52:05 <ski> it's hard to comment on your issue, without seeing how your type is defined, and how the types of the two data constructors differ
09:52:25 <juri_> I'm having problems with the second instance declaration.
09:52:35 <juri_> (obviously. it's soup).
09:53:02 <ski> perhaps `SpacePoint' should be a subclass of `PlanePoint' ?
09:54:35 <ski> i'm not sure i see why you want to have a type inhabited by both plane and space points
09:54:51 <ski> but perhaps you could make the type indexed ?
09:55:13 <ski> (i dunno whether you'd want to do that, since i don't know why you're doing this)
09:55:20 <juri_> because a point is a point, and a pile of my logic works fine this way.
09:55:41 <juri_> i'd just like to move from having an error to something using the type resolver.
09:55:44 <monochrom> I am skeptical of the merit of the Point type in the first place.  If someone else gave me xs :: [Point], then it means it might be a mixture of 2D points and 3D points.  Why would they do that, and if they mistakenly misguidedly insist doing that, why should I entertain them?
09:56:47 <maerwald> Point is obviously an abstract interface
09:56:50 <juri_> because there are a ton of functions that don't care how many dimensions your point has, and duplicating them makes not so much sense.
09:56:58 <maerwald> and you have a PointFactory
09:57:30 <ski> something like `data Point :: Dim -> Type where Point2 :: ℝ2 -> Point Two; Point3 :: ℝ3 -> Point Three' might be more useful ?
09:57:33 <ski> (i don't know)
09:57:52 <juri_> yeah, i'm not doing a good job explaining it.
09:57:59 <monochrom> Instead, it seems much safer to make Point a parameterized type, the type parameter being a phatom one that indicates whether the point is 2D or 3D.  For example a GADT going like: "data Point d where Point3 :: R3 -> Point Space; Point2 :: R2 -> Point Plane".  (You will have to define Space and Plane separately.)
09:58:01 <ski> at least then you could say `xs :: [Point Three]', and know that you're only being given space points
09:58:06 <maerwald> ski: that makes actual sense
09:58:37 <monochrom> Then you can have "instance SpacePoint (Point Space)"
09:58:40 <ski> (monochrom is saying the same thing as me)
09:59:23 <juri_> yeah, you've both lost me.. and i have no idea how many types i'll have to flip in function definitions if i do that. :P
10:00:03 <max_> hello, I am playing with parallel programming but I seem to be enable to engage more than 1 core
10:00:20 <monochrom> This is what prototypes are for. To find out a design is completely borked, and throw it away. The value of which is you have learned one more anti-pattern.
10:00:43 <ski> juri_ : with a GADT as suggested, i think you'd probably still be able to express your generic "functions that don't care how many dimensions your point has"
10:00:46 <max_> in my toy program I am launching 4 threads (pretty heavy computations, lasting several seconds)
10:01:39 <max_> I added -threaded to the executable stanza in my .cabal file
10:02:30 <max_> and I am launching my executable with "cabal run MyProg -- +RTS -N4 -RTS" 
10:03:12 <max_> from the system monitor I clearly see only 1 core is 100% busy 
10:03:30 <monochrom> On further thought, I even think that the GADT version Point type is completely eliminable.
10:03:35 <max_> anything obvious I am doing wrong here?
10:04:08 <juri_> GADTs are a bit beyond me. :P
10:04:21 <dolio> What are the examples of functions that don't care about the dimension?
10:04:29 <ski> juri_ : could be nice to dive into, at some point :)
10:04:34 <dolio> Because every function is actually getting told the dimension of every point.
10:05:06 * ski supposes it might be functions that are constrained polymorphic over `PlanePoint'
10:05:15 <monochrom> You definitely have some functions like "Planepoint p => p -> p -> p" and some like "Spacepoint p => p -> p -> Double -> p" etc etc.  Isn't it enough that you can use the former for both R2 and R3, and the latter for R3?  Why need a unified point type?
10:05:18 <juri_> dolio: i have very few functions that even look at the Z dimension.
10:06:19 <juri_> monochrom: most of my functions take both, strip the type, then do something with x and y, not z.
10:06:54 <dolio> juri_: You didn't answer my question.
10:06:59 <monochrom> That just means (Planepoint p, Planepoint q) => p -> q -> Foo
10:08:22 <juri_> dolio: honestly, i'm not sure i know how to answer your question. surely, you don't want function definitions for my 'do not care' functions.
10:08:28 <monochrom> Are you sure you haven't completely purged OO thinking from your mind?  Because only OO thinking could suggest the current design.  The obsession with using existential types to unify things.  Even the obsession with unifying things that shouldn't be.
10:09:00 <juri_> monochrom: never had it in the first place. :P
10:09:01 <monochrom> (The last sentence explains the 2nd last sentence.)
10:09:05 <dolio> There's no name for any of them?
10:09:14 <dolio> Like `transpose` or `sum` or something?
10:09:18 <juri_> (i am natively a C / Assembly programmer)
10:09:57 <monochrom> C also kind of pushes you towards OO unless you use its union type all the time.
10:10:35 <monochrom> Because OO is a natural consequence, a logical conclusion of "I only have structs, but I still want better generality".
10:11:20 <juri_> I think the biggest 'offender' is my Line type. i suppose i can demote it to always taking Point2...
10:11:39 <juri_> welp. i wasn't doing anything with my weekend anyways.
10:11:45 * juri_ breaks point into two.
10:11:49 * ski . o O ( "If all you have is `struct' (and function pointers), everythings starts to look like OO." ? )
10:12:03 <monochrom> You can make Line a parameterized type.
10:12:26 <monochrom> Yes ski. Just look at Windows API. :)
10:12:33 <juri_> I don't think there's a good reason for it to take 3d points.
10:12:53 <monochrom> I learned OO and Win16 around about the same time.  The correspondence was striking.
10:13:00 <juri_> i'm trying to go weed-whacking in my code, and have removed 95% of the stuff that works in 3d.
10:13:00 <dolio> juri_: Anyhow, the eventual point of my question was going to be: if they don't need to know the dimension of the type, maybe they don't need to know that it's a point at all, or it only has to know that it's got some functions available, which is possible with classes and two separate types.
10:13:24 <juri_> dolio: yeah, classes and seperate types make some sense.
10:14:44 <juri_> I'll just be doing a lot of editing today, for not much gain. my code works, i just wanted to move the "wrong constructor (wrong type) code from being patteren matched error invocations to something in the type system, without breaking Point in two.
10:14:54 <monochrom> Also, I learned OO from Turbo Pascal
10:15:18 * Clint claps.
10:20:31 * ski . o O ( Turbo Prolog )
10:22:10 * ski . o O ( `forall p <: Point2. p -> p' )
10:23:04 <monochrom> We make do with HasFieldX, HasFieldY, and a dose of lens, don't we?
10:24:30 <ski> i suppose
10:25:30 <juri_> ok, now that i have two types, how do i type functions that MAY take either type?
10:25:46 <juri_> I was using patern matching to handle this before.
10:26:18 <juri_> for instance, calculating the magnitude of a point is different in 2d and 3d, but i'd like one function that does that.
10:26:57 <juri_> or adding points together, or getting the distance between two points..
10:28:13 <juri_> sounds like i need a single parametric type.
10:29:01 <dolio> You don't add a 2d point to a 3d point, though, right?
10:29:08 <juri_> sure i do.
10:30:34 <ski> so you're considering a particular embedding of the plane into space ?
10:31:13 <juri_> yep.
10:31:17 <ski> (also, i'm wondering whether your points are not really vectors)
10:33:40 <juri_> I suppose i could make the functions that 'care' part of the typeclass..
10:34:40 <juri_> or maybe a seperate typeclass.
10:34:53 * juri_ plays with that a bit.
10:36:29 <juri_> ok, i think that works.
10:37:33 <juri_> I'll just strip out the mixed type vectors.
10:51:11 <maerwald> I sigabort on cabal and it still builds the package successfully
10:52:15 <maerwald> should I be amazed or shocked
10:52:23 <dmwit> If you are considering a particular embedding of the plane into space, why not *only* have 3d points?
10:52:58 <juri_> dmwit: because that is a lot of math to toss around.. plus, i'm intending on changing that. just not done yet.
10:53:18 * dmwit scratches is head in confusion
10:53:44 <dolio> You mean adding zeroes and stuff?
10:53:52 * juri_ tears up reams of haskell.
10:53:54 <dolio> Worried about performance?
10:53:57 <juri_> yep.
10:54:09 <juri_> and, it was quite a measurable difference.
10:54:11 <dolio> But instead you're testing constructor tags all over the place.
10:54:12 * hackage path-like 0.1.1.0 - PathLike, FileLike and DirLike type classes for the Path library.  https://hackage.haskell.org/package/path-like-0.1.1.0 (locallycompact)
10:55:10 <juri_> the numbers didn't lie. like i said, this is working code.
10:55:32 <juri_> it only saved me around 10 percent, but..
11:02:15 <Uniaika> < maerwald> should I be amazed or shocked // It's shockingly amusing :P
11:02:55 <monochrom> reminds me of a movie scene "missile out of range, can't abort".
11:04:54 <EvanR> maybe there is a parallel between the difficulty of aborting a computation and the difficulty of designing a reliable abort system for rockets
11:06:09 <maerwald> how do you profile memory spikes, when most of it is just PINNED in the heap profiler?
11:25:02 <maerwald> blergh :>
11:25:57 <ziman> in my servant application, I have a broadcast TChan, which handlers of long-poll requests duplicate and then read (= block until a message is available); but when i write into the broadcast TChan, the handlers do not receive the message and keep blocking. I'm out of ideas; are there common gotchas in this scenario?
11:26:52 <ziman> (i'm compiling with -threaded)
11:30:00 <dsal> ziman: example code?
11:30:23 <dsal> I do something quite similar for sending monadlogger into websocket.
11:31:45 <ziman> here's an excerpt: https://gist.github.com/ziman/812168cff75704870259e901fffb4162
11:39:45 <dsal> I think you want to use STM.orElse
11:39:53 <dsal> I'm not certain <|> is equivalent.
11:40:36 <EvanR> this seems like unnecessary fear uncertainty and doubt
11:41:01 <ziman> i also tried to remove the timeout
11:41:27 <ziman> so it would just block directly on the read, and it did not solve the problem (the readers would keep blocking)
11:42:28 <EvanR> http://codepad.org/JdPmrGC1
11:42:50 <monochrom> STM's <|> is orElse.
11:42:52 <dsal> Well that seems clear.  :)
11:43:37 <ziman> for the record, orElse behaves the same :)
11:43:51 <EvanR> sanity check passed
11:45:04 <dsal> Are you broadcasting after you receive?  I can't see enough code here to really know what's going on.
11:46:30 <ziman> yes, first the readers get blocked on a duplicate of the broadcast channel, and then another request handler writes into the broadcast channel
11:47:29 <ziman> the whole code is a bit too big for a paste; i wonder if i can meaningfully reduce it
11:47:39 <ziman> while making sure that whatever makes it not work stays in
11:47:59 <EvanR> the devil in the details
11:48:05 <EvanR> the proof in the pudding
11:49:28 <ziman> https://git.functor.sk/ziman/dixit/src/branch/master/backend/src/Dixit/API.hs#L655 <- here's the long poll handler
11:49:47 <EvanR> on the bright side, if you reduce your code so much that it still works but it fails to reproduce the bug, you win
11:50:10 <ziman> that's a good point ;)
11:51:50 <ziman> and state updates are announced by invocations of this function: https://git.functor.sk/ziman/dixit/src/branch/master/backend/src/Dixit/API.hs#L374
11:56:35 <bifunc2> Why is doing malloc once and packCStringLen many times on it    way faster than   doing malloc+unsafePackMallocCStringLen many times?
11:57:05 <bifunc2> Can Haskell do some further optimizations in the first way?
11:57:21 <EvanR> malloc has a cost
12:01:59 <bifunc2> EvanR yeah but shouldn't that cost be same/similar to the packCStringLen cost?
12:02:07 <bifunc2> as that's probably doing malloc under the hood too?
12:05:47 <EvanR> I'm having a hard time locating packCStringLen right now
12:11:42 * hackage hoop 0.3.0.0 - Object-Oriented Programming in Haskell  https://hackage.haskell.org/package/hoop-0.3.0.0 (mbg)
12:14:11 * hackage hpath-directory 0.14.0 - Alternative to 'directory' package with ByteString based filepaths  https://hackage.haskell.org/package/hpath-directory-0.14.0 (maerwald)
12:15:11 * hackage hpath-io 0.14.0 - High-level IO operations on files/directories  https://hackage.haskell.org/package/hpath-io-0.14.0 (maerwald)
12:18:09 <ja> bifunc2: could it be that haskells allocator is somehow much faster than your OS allocator?
12:18:23 <bifunc2> no idea, maybe
12:18:28 <bifunc2> i'm on macos
12:18:42 <ja> i remember reading some stories about people getting crazy speedups switching to e.g. jemalloc
12:18:47 <maerwald> then probably yes
12:19:02 <maerwald> ja: yeah, rust ppl have the same problem
12:19:04 <bifunc2> i didn't realize haskell had it's own allocator..
12:19:50 <bifunc2> if os malloc is so slow, why haven't they made it faster already
12:19:55 <ja> my haskell programs are the only onces consuming 4T of virtual memory :P
12:20:13 <dolio> Are you calling `malloc` the GHC function? That doesn't use "the OS allocator".
12:21:14 <bifunc2> yes i'm  using malloc from foreign
12:21:40 <ja> oh my, that is confusing. so you can't malloc in ghc and then free it in C?
12:22:21 <dsal> malloc is complicated
12:23:01 <ja> depends what you mean by 'malloc' ;) implementation, eco system or type signature ?
12:23:06 <dsal> It's a simple abstraction, but getting a concurrent, efficient, non-wasteful malloc implementation that is the best in all use cases has been difficult.
12:23:13 <dsal> Best to just never malloc.
12:23:46 <ja> ehm, what is the alternative? everything on the stack?
12:23:49 <dolio> Oh actually, `malloc` does call out to the system.
12:24:00 <EvanR> sanity check passed
12:24:01 <dolio> That's why it's so bad, I guess. It's a foreign call and everything.
12:24:36 <dolio> mallocForeignPtr and the like don't do that, though.
12:24:37 <EvanR> i could not verify if 'packCStringLen' uses malloc under the good
12:24:44 <dolio> It doesn't.
12:24:49 <EvanR> ok
12:25:14 <dolio> You should probably never use `malloc` unless you actually need to free it in C code or something.
12:29:06 <ja> bifunc2: regarding "why does my OS suck", i encourage you to go down that rabbit hole :P first, you switch to alpine to avoid glibc. then you realize unix is from the 70es and install Genode. then you need to port some drivers from linux, maybe some from freebsd, why not ;) etc etc
12:29:11 * hackage path-like 0.1.2.0 - PathLike, FileLike and DirLike type classes for the Path library.  https://hackage.haskell.org/package/path-like-0.1.2.0 (locallycompact)
12:30:11 <dolio> Also calling a foreign function has overhead.
12:31:10 <bifunc2> highly interesting
12:31:12 <bifunc2> https://hackage.haskell.org/package/base-4.9.1.0/docs/Foreign-ForeignPtr.html#v:mallocForeignPtr
12:31:23 <bifunc2> "you may not assume that the memory returned by mallocForeignPtr has been allocated with malloc."
12:32:25 <c_wraith> because it usually hasn't. :)
12:34:55 <EvanR> mallocInNameOnly
12:35:08 <bifunc2> :)
12:35:37 <ja> oh, why isn't Ptr a type class then ;) then we could have SystemMallocAllocatedPtr and JemallocAllocatedPtr and HaskellRuntimeAllocatedPtr 
12:36:15 <dolio> Why?
12:36:18 <c_wraith> Ptr is lower-level than all of those concepts.  ForeignPtr handles all of them just fine.
12:37:12 <bifunc2> i'm guessing repeated uses of malloc should be replaced with replaced with repeated uses of foreignptrs
12:37:23 <bifunc2> one rare malloc here and there ought not to do much harm
12:39:27 <ja> the road to memory leak oblivion is paved with rare mallocs ;)
12:41:05 <bifunc2> <maerwald>	ja: yeah, rust ppl have the same problem
12:41:07 <bifunc2> what problem?
12:41:28 <ja> they switched from jemalloc to the system one and got a slowdown iirc
12:41:38 <ja> https://internals.rust-lang.org/t/jemalloc-was-just-removed-from-the-standard-library/8759
12:42:50 <bifunc2> is linux better than macos in this regard?
12:44:18 <maerwald> in every regard
12:45:10 <slack1256> On pipes-concurrency, can a duplicate and `Input a`?
12:45:45 <slack1256> can I duplicate an `Input a`.
12:45:54 <slack1256> Writing is hard...
13:01:39 <juri_> typechecks. is broken. yay!
13:09:39 <ja> but does it pass the type check of your heart? :O
13:17:11 <dmj`> typeCheck :: Maybe Feelings -> Expr -> Bool; typeCheck (Just _) _ = True
13:17:16 <koz_> Heart of the type checker.
13:17:52 <koz_> "You just activated my trap card - Dreaded Monomorphism Restriction!"
13:19:19 <slack1256> Impossible, nobody has triggered the Forbidden Monomorphism Restriction in years!
13:22:37 <koz_> King of Types.
13:26:51 <dmj`> he who hath triggered the forbidden monomorphism restriction must face its wrath
13:30:23 <[exa]> [All players pay 1 explicit type annotation card.]
13:32:03 <EvanR> i want to see the card art for these
13:33:32 <kuribas> I am getting an error with the language server ‘Distribution.Types.GenericPackageDescription’ does not export ‘unFlagAssignment’
13:33:43 <kuribas> apparently since it is downloading Cabal-3.2.0.0
13:33:48 <kuribas> but why?
13:34:40 <kuribas> all these small issue are really annoying when just wanting to get stuff done.
13:34:53 <kuribas> And really a dealbreaker for trying to introduce haskell in my team.
13:35:14 <kuribas> is Cabal-3.2.0.0 broken for hie?
13:35:22 <kuribas> Should I downgrade?
13:35:53 <dmj`> kuribas: what build tool are you using for everything? you'll need the same version of Cabal
13:35:55 <sm[m]> if you don't want to deal with small issues, don't even bother with IDE stuff
13:36:13 <kuribas> dmj`: Cabal-3.2.0.0
13:36:35 <kuribas> sm[m]: true it's annoying in other language as well
13:36:58 <dmj`> kuribas: you should attempt to use the same version of GHC for your tooling (IDE) as well as your project
13:37:14 <kuribas> dmj`: but I am AFAIK?
13:38:15 <kuribas> wait, cabal-version is set to an old version...
13:38:34 <sm[m]> and I agree it's annoying, but that's the status, still, for now
13:39:16 <kuribas> I'd be willing to pay money for better tooling
13:39:20 <sm[m]> Doesn't Just Work
13:40:14 <kuribas> I understand that java IDEs have a lot more $$$ behind it
13:40:19 <dmj`> kuribas: If you guys all use emacs, then haskell-mode is going to get you most of the way there.  As sm[m] says, I wouldn't bother, its more trouble than its worth
13:40:30 <sm[m]> #haskell-ide-engine and #ghc at least are working hard on it, you could put up some bounties
13:40:44 <dmj`> kuribas: If a language can't be used w/o an IDE, it probably shouldn't be used at all.
13:40:51 <kuribas> dmj`: I do use emacs
13:40:53 <sm[m]> not to make the existing devs go faster, but to maybe attract a few more
13:41:04 <kuribas> dmj`: I cannot sell it to my coworkers though
13:41:19 <dmj`> kuribas: what is the background of your coworkers?
13:41:26 <dmj`> kuribas: C# / Java ?
13:41:26 <kuribas> dmj`: java, now clojure
13:41:38 <kuribas> dmj`: using intellij
13:42:55 <sm[m]> I would set them up with intellij's haskell code highlighting and a terminal pane running ghcid and another running ghci
13:43:13 <kuribas> hmm, okay
13:43:22 <kuribas> I was hoping on vscode with hie
13:43:28 <dmj`> kuribas: can they use emacs?
13:43:36 <sm[m]> and I would use stack because it's more beginner friendly/repeatable/polished, but YMMV
13:43:37 <kuribas> dmj`: not all of them want to
13:44:08 <kuribas> sm[m]: all right, maybe hie with stack will be more robust
13:44:17 <dmj`> kuribas: I'd just give them a terminal with ghcid in it, and tell them to use whatever editor they want.
13:44:37 <kuribas> dmj`: showing types would be nice though
13:44:38 <sm[m]> oh, you jumped way beyond what Im suggesting :)
13:45:22 <sm[m]> I'm curious, if they're used to intellij, why force them to jump to vscode ? Isn't haskell enough of a change
13:45:52 <kuribas> sm[m]: because I thought the tooling was better on vscode.
13:46:43 <dmj`> kuribas: you can use typed holes to get types, or simply put the wrong type in there. Otherwise, haddocks + ghcid + text editor
13:46:48 <Cheery> I just came with a weird thought sort of.
13:46:53 <sm[m]> I think it's similar. You get more positive reports of vscode because it's a more popular first IDE among haskellers 
13:47:26 <Cheery> if you think that zero/succ is initial encoding for natural numbers, then is the a -> (a -> a) -> a the final encoding in some way?
13:47:28 <kuribas> sm[m]: when it works, vscode is a lot better than just what you suggest.
13:47:50 <kuribas> sm[m]: it gives types for any expression, plus documentation.  It allows you to jump to definitions, etc...
13:48:20 <sm[m]> sure. That all works in intellij too "when it work"
13:48:49 <kuribas> does it?
13:48:59 <kuribas> with which plugin?
13:49:00 <sm[m]> using the intellij-haskell plugin
13:49:18 <dmj`> sm[m]: that would win them over for sure
13:49:42 <kuribas> sm[m]: in that case they would prefer it 
13:50:21 <sm[m]> but I'm not recommending you start them with that. Unless you have the time to thoroughly test it yourself and make absolutely sure it's rock solid for your project
13:50:57 <dmj`> kuribas: I always tell people that edwardk just uses a vanilla VIM setup when they try to argue that the best haskellers "type fast" and use "pimped out doom emacs with ghcide" setup. These are the same people that think mastery of lens is master of haskell.
13:51:09 <sm[m]> start them with code highlighting + ghcid + ghci, then let them/you experiment with the smarter features in free time
13:51:10 <dmj`> mastery*
13:51:48 <dmj`> kuribas: just print out on paper the haddocks for all your packages and hand it to them, say you want this finished by Friday.
13:52:03 <bifunc2> i'm using haskell-ide-engine with vs code. am i on the wrong path?
13:52:15 <kuribas> dmj`: that's nice and well, but I cannot work without flycheck anymore.
13:52:35 <sm[m]> bifunc2: no no, carry on. If it's working for you, these comments don't apply
13:52:49 <kuribas> dmj`: it's not because it works that it's the most efficient workflow.
13:53:41 <savva> is there a way to view everything that has been said in this chat over the last week?
13:54:19 <sm[m]> there's a log url in the /topic, savva
13:54:26 <kuribas> bifunc2: what's your setup?
13:54:45 <savva> I shouldve seen that...thank you
13:55:12 <bifunc2> macos, vscode, haskell ide engine (HIE): https://github.com/haskell/haskell-ide-engine
13:56:24 <monochrom> If it works for you, you are not on the wrong path.
13:57:41 <monochrom> Still, here is a roast of IDEs in general: https://www.youtube.com/watch?v=FyCYva9DhsI&feature=youtu.be&t=1858
13:57:46 <dmj`> there is an inverse relationship between the knowledge of the types and the necessity of flycheck
13:58:13 <dmj`> ghcid will essentially give you the same information
13:59:23 <kuribas> dmj`: I don't want to know the types, I want emacs to quickly show me where stuff breaks.
14:00:09 <kuribas> dmj`: sure, when writing new code I turn of flycheck.
14:00:20 <kuribas> but when refactoring it just allows me to move fast.
14:01:12 <dmj`> kuribas: refactoring is a fair use case, in emacs haskell-mode C-c C-l sends code to the repl and errors shown in ghcid can be jumped to using a hotkey defined in haskell-mode
14:01:18 <dmj`> in ghci*
14:01:48 <dmj`> C-c C-i used on an import shows me all the definitions in a module in a popup buffer
14:02:16 <kuribas> dmj`: and I actually found that running vscode in another windows to check some complicated types can be quite useful.
14:02:22 <kuribas> dmj`: even though I still use emacs.
14:02:53 <dmj`> sure, I use ghci and ghcid inside of emacs to get type info
14:04:15 <kuribas> ghci only gives you outer types
14:04:42 <dmj`> that's true, I just use holes for types of expressions in where blocks
14:04:47 <sm[m]> if we're talking emacs: you can run ghcid in compile-mode, which I assume makes it easy to jump to next error
14:05:11 <kuribas> sm[m]: what does it give me over flycheck?
14:05:31 <sm[m]> I don't know
14:11:50 <kuribas> sm[m]: does intellij gives you inner types, haddock documentation, jump to definition, etc?
14:13:23 <sm[m]> kuribas: I believe it can, if you manage to get it working and keep it working on your project. But why not take a look at its web page
14:14:29 <kuribas> sm[m]: I did: "Type information and documentation (via hoogle) on hover", not clear if that's just for top-level expressions.
14:14:34 <sm[m]> I'm not advocating it, but it you try it I will say make sure to get the latest available beta, not the release
14:15:18 <kuribas> sm[m]: emacs is out of the question
14:15:22 <sm[m]> sorry, I'm not sure. I didn't have it working long enough to learn that much detail
14:18:43 <frdg> I was lurking earlier and saw someone mention that there is downside to using flymake. If I understood this correctly, what was the reasoning?
14:23:06 <kuribas> frdg: do you mean flycheck?  I've been using it without problems.
14:25:31 <frdg> kuribas: I must have misread
14:26:37 <kuribas> frdg: I don't know why some people are against it
14:26:56 <kuribas> I couldn't code without it.
14:27:48 <sm[m]> nobody's against it. There's no conspiracy. :)
14:27:59 <frdg> kuribas: It's the most convenient thing I have ever experienced.
14:28:56 <kuribas> unless is tracking unvaccinated people who are against 5G
14:29:08 <kuribas> frdg: I find it too.
14:29:11 * hackage dobutokO-effects 0.5.0.0 - A library to deal with SoX effects and possibilities  https://hackage.haskell.org/package/dobutokO-effects-0.5.0.0 (OleksandrZhabenko)
14:35:45 <kuribas> nice explanation: https://www.quora.com/What-are-powerful-Haskell-IDEs
14:41:09 <Cheery> kuribas: that answer is dumb in the "ide dumbness"
14:42:17 <kuribas> I agree and disagree at the same time.  People who use IDEs often forget what is running behind.
14:42:33 <kuribas> how compiler and linker phases work etc...
14:42:35 <Cheery> I mean that it's fairly bad answer because Haskell IDE would be a bit different.
14:42:56 <Cheery> A proper IDE would be able to expand on case.
14:43:11 <kuribas> but because you can code without tools helping doesn't mean these tools wouldn't improve productivity
14:43:30 <Cheery> likewise proper IDE would be a bit like a proof search engine, plus hoogle, maybe.
14:44:06 <kuribas> there's so much where tooling could be improved.
14:44:20 <kuribas> Especially since haskell offers much more static information.
14:46:27 <Cheery> I think it'll get there eventually, but those would be important things. I don't worry so much about debugger interaction or even syntax highlighting.
14:51:02 <Cheery> Also if you have a haskell IDE, it should be haskell-extensible, or even controlled with haskell.
14:57:07 <sm[m]> fun to see dons coding again: https://donsbot.wordpress.com/2020/07/04/back-to-old-tricks-or-baby-steps-in-rust/
14:59:23 <hpc> that's another data point confirming how similar rust is to haskell as well
14:59:33 <hpc> "Non-fancy Haskell, including type class designs, can basically be ported directly to Rust, though you now annotate allocation behavior explicitly."
14:59:51 <hpc> whenever i bring it up i always seem to get shot down, nice to see i am not completely crazy
15:10:25 <c_wraith> I think how similar one sees the two languages has an inverse relation to how happy one is with laziness.
15:10:44 <c_wraith> A *lot* of haskell code I write would be infinite loops in rust.
15:11:18 <dolio> He ported a super low level Haskell library to Rust.
15:12:05 <c_wraith> One time I ran into him on a lunch break and complained that a recent change he'd made to bytestring had broken some of my code that was using laziness. :)
15:12:09 <dolio> One that manipulates foreign pointers and memory allocation and exactly cares about inlining and optimising out data structures, and ...
15:12:43 <c_wraith> (back when we worked at offices that were like 2 blocks apart)
15:14:20 <dolio> For instance, I'm sure vector-algorithms would be just as good or better in Rust.
15:15:02 <dolio> But if you use that as one of your points, people aren't going to take you seriously.
15:16:20 <maerwald> just because rust has ADTs doesn't make it similar to haskell. Anything that is non-pure can barely be compared. There is only one pure-ish imperative lang I know of
15:16:51 <maerwald> https://mars-lang.appspot.com/
15:20:11 <ja> maerwald: what makes ATS violate whatever metric you measure?
15:20:28 <maerwald> ATS?
15:20:46 <ja> maerwald: http://www.ats-lang.org/
15:21:23 <maerwald> emphasis on *I know of*
15:21:28 <ja> it's funny you didn't hear about it, given that there are not that many dependently typed languages :O
15:23:11 <ja> not the prettiest language though :O but i like the minimal website style
15:25:08 <maerwald> nice eye cancer
15:25:45 <ja> hahaha :P
15:26:42 <ja> anyway, to get back on topic: i think nothing is preventing you from making a c-like subset in a functional programming language, where everything is implicitly rewritten to use a state monad, or such
15:26:52 <ja> if i write haskell using the state monad, is my code not pure?
15:27:59 <Uniaika> (it is)
15:28:53 <ja> in that case, is 'purity' merely syntax? 
15:29:35 <maerwald> no, purity is a language property
15:29:42 <maerwald> which can be proven
15:30:05 <maerwald> unlikely that you get it by accident
15:30:23 <maerwald> even if 99% of your code is morally pure
15:31:04 <ja> maerwald: if i make some template haskell that compiles c-like syntax to using the state monad, would that be compiling impure code to pure code then?
15:31:20 <maerwald> purity is not about code
15:31:24 <maerwald> it's about the language
15:31:53 <Uniaika> maerwald: you escape purity when the compiler is not able to tell you if you are in IO (or any other effect) anymore
15:31:56 <Uniaika> er
15:31:58 <Uniaika> ja ^
15:32:23 <Uniaika> unsafePerformIO is an escape hatch from purity
15:32:53 <ja> Uniaika: your definition of purity is just, "the type has IO in it" ?
15:33:26 <peutri> more like "does not have"
15:33:34 <ja> ah yes, sorry
15:33:42 <maerwald> ja: the definition is that call-by-name, call-by-need and call-by-value are weakly equivalent
15:33:44 <Uniaika> ja: the "IO" in the type is more a requirement of the compiler for us puny humans
15:34:10 <Uniaika> it is the syntax for the underlying concepts of purity 
15:34:13 <maerwald> it has little to do with IO, except that's the easiest way to mess up purity
15:35:06 <maerwald> if semantics of your program depend on the evaluation stragey, then your language is not pure 
15:35:16 <maerwald> (modulo bottom)
15:35:49 <maerwald> and that makes sense intuitionally as well
15:36:24 <ja> ah interesting! somebody mentioned the other day that haskell does not specify execution order. if that is true, then is it also incorrect to say haskell is a pure language?
15:37:27 <Cheery> that's up to debate kind of?
15:37:50 <peutri> if you like pointless debating?
15:38:05 <maerwald> ja: no
15:38:15 <maerwald> ja: purity is not defined for execution.
15:38:40 <maerwald> unless you can come up with a definition
15:38:51 <maerwald> (a scientific that is)
15:39:35 <ja> peutri: i am just trying to find out which terms are wonky, and which are not
15:40:15 <peutri> imho they all are until the debaters agree on definitions
15:40:25 <maerwald> SPJ said that purity is actually more of a nice property for compiler engineers (e.g. when implementing STM), less of interest to the actual programmer
15:40:41 * hackage path-like 0.2.0.0 - PathLike, FileLike and DirLike type classes for the Path library.  https://hackage.haskell.org/package/path-like-0.2.0.0 (locallycompact)
15:41:08 <Uniaika> although many people (me included) do like purity for its engineering benefits
15:41:11 <peutri> specifying execution order seems like "oh of course haskell", but when you look close almost all languages end up saying it's defined up to observability
15:41:37 <peutri> so C++ introduced its seauence points
15:41:48 <peutri> haskell theoretically sequences in IO
15:42:00 <maerwald> bc although IO functions/values are also pure semantically... they suck morally, because as a programmer you don't just care about evaluation, but you gotta run your program at some point
15:42:02 <peutri> and then the processor reorders everything at will anyway
15:42:20 <maerwald> and then the theoretical benefit of purity is quickly lost
15:44:09 <ja> peutri: but i think terms like "untyped/unityped" are fairly well defined, and it doesn't seem like it needs much discussion. also, it seems like there are two versions of 'non-deterministic', but isn't it usually very clear from context which one people are talking about? but to quote maerwald, "pure-ish imperative", that is the term i was trying to understand
15:45:02 <peutri> i agree with your first 2/3ds, and wasn't there for the rest
15:45:33 <EvanR> at least two versions of non-deterministic
15:47:31 <ski> maerwald : yes, the main gain is clear separation
15:48:14 <ski> @where purely-functional
15:48:14 <lambdabot> "What is a Purely Functional Language?" by Amr Sabry in 1993-01 at <https://www.cs.indiana.edu/~sabry/papers/purelyFunctional.ps>
15:48:30 <maerwald> ski: yeah, which has some amazing benefits, but is also largely overrated
15:48:40 <peutri> how do i get ghci to tell me which version it is?
15:51:16 <dmj`> peutri: ghci --version
15:51:21 <peutri> from within
15:51:28 <ski> maerwald : yes, effectful code is still as hard as every to reason about
15:51:42 <dmj`> peutri: just call ghci, it will show the version when it loads
15:52:03 <peutri> right now i'm at :show packages, and guess from "base-4.13.0.0"
15:52:13 <peutri> but i can't just call it
15:52:26 <peutri> i already have it (emacs, stack, whatever)
15:52:42 <peutri> and wish to inquire where it comes from
15:53:13 <peutri> i expected there'd be some :cmd for that
15:53:29 <peutri> but i haven't found better than base-4.13 yet
15:53:46 <ja> % readFile "/proc/self/cmdline"
15:53:46 <yahb> ja: "/srv/sandbox/root/usr/lib/ghc-8.10.1/bin/ghc\NUL-B/srv/sandbox/root/usr/lib/ghc-8.10.1\NUL--interactive\NUL-v0\NUL-ghci-script\NUL/srv/sandbox/root/usr/lib/run/ghci-init\NUL-tmpdir\NUL/srv/sandbox/root/data/tmp/\NUL-odir\NUL/srv/sandbox/root/data/tmp/\NUL-hidir\NUL/srv/sandbox/root/data/tmp/\NUL-ignore-dot-ghci\NUL+RTS\NUL-M200M\NUL-V0\NUL-C0\NUL-K100M\NUL"
15:53:58 <peutri> nice
15:54:13 <peutri> i LIKE that
15:54:16 <peutri> thanks ja
15:54:39 <ja> leaky abstractions, they never fail to leave an impression :O
15:54:53 <peutri> i'm usually not the last to abuse them
15:55:05 <peutri> well let's be honest, i was looking for a native way first
16:05:04 <zfnmxt> I'm sort of surprised that there isn't ann equivalent of `local` for `MonadState`. Wanting to save your state, do something, and then pop that save seems like a common pattern.
16:05:43 <peutri> you can simply use runState for that, no?
16:06:19 <zfnmxt> Oh, yes, you can!
16:06:31 <zfnmxt> So...nevermind that, then. 
16:06:44 <peutri> it's when state is in the middle of a monad stack that it gets more interesting
16:07:08 <zfnmxt> Mmm, true.
16:07:19 <zfnmxt> But defining your own `local` regardless isn't hard.
16:08:20 <dmj`> zfnmxt: can use `zoom` too
16:08:47 <maerwald> zoom zoom
16:10:23 <Cheery> I'm trying to build an argument that formal logic propositions are intuitive to understand. Ideas?
16:11:05 <ski> "intuitive", in which sense ?
16:11:52 <peutri> in the sense that best "constructs" the argument
16:13:13 <Cheery> perhaps in a way that it is similar how people use natural languages.
16:13:59 <Cheery> eg. "if it doesn't rain tomorrow, I'm going outside".
16:15:38 <ja> i live on venus, the rain has acid. when it rains, we never go outside, everybody knows that, it is intuitive
16:16:32 <Cheery> that is ambiguous, did you mean that you never go outside, or that you never go outside when it rains?
16:17:02 <ja> :O i don't know who is trolling who anymore :P
16:17:20 <peutri> it's not ambiguous if it's the same proposition
16:18:31 <ja> wasn't formal logic invented because of all these failures with natural language? how could you possibly hope to achieve this?
16:22:11 * hackage ghc-lib-parser 0.20200704 - The GHC API, decoupled from GHC versions  https://hackage.haskell.org/package/ghc-lib-parser-0.20200704 (shayne_fletcher)
16:23:11 * hackage ghc-lib 0.20200704 - The GHC API, decoupled from GHC versions  https://hackage.haskell.org/package/ghc-lib-0.20200704 (shayne_fletcher)
16:34:42 <dostrow> new to haskell and cabal and I had a question, I am able to install things with `cabal install` perfectly fine but when I attempt to then see if they are installed using `cabal list` or `ghc-pkg  list` the packages don't show up despite completing the install into ~/.cabal, I'm clearly missing something here
16:38:05 <Cale> Perhaps you could put the result of ghc-pkg list on dpaste.com or something? What package.conf.d's does it show?
16:38:34 <Cale> There should be one in your ~/.ghc which has whatever you installed with cabal-install in it
16:39:25 <sm[m]> dostrow: packages providing only executables (no library) won’t be listed
16:43:11 <dostrow> so as a for instance, in this case I am trying to install xmonad via cabal, it installs, the binary is created but 2 things are troubling, 1). When I do a `cabal list xmonad` it shows as [ Not Installed ], which I thought was a little odd, secondarily, when I try to run it it fails to find any of my imports (which are all libs installed with cabal
16:43:11 <dostrow> as well, seemingly successfully)
16:43:46 <dostrow> my package database in ~/.ghc is functionally empty despite a rescan
16:48:42 <dostrow> http://dpaste.com/24ZCN0G that's the output of `ghc-pkg list`
16:50:27 <dostrow> `cabal list --installed` also only shows those same packages
16:53:18 <dostrow> also I'm using a bone stock cabal config, running on FreeBSD 12.1 with only the ghc and hs-cabal-install packages installed, my plan was to do everything else through cabal
16:56:41 <sm[m]> dostrow: I can’t test right now, but maybe that no longer works in these days of “nix-style” v2 install
17:00:13 <sm[m]> dostrow: ah, it no longer installs libraries by default, see https://cabal.readthedocs.io/en/latest/cabal-commands.html#cabal-v2-install
17:01:41 <sm[m]> but I don’t know your version, YMMV
17:08:32 <slack1256> On the pipes ecosystem, what is the closest you can get to a continous Behaviour as in reactive-banana?
17:24:39 <frdg> I went to run `cabal repl` and I got this error message. I don't believe that I have updated my `.cabal` file recently. What does this error mean: https://pastebin.com/ArDGGGf5
17:25:30 <slack1256> It could not resolve dependencies, what trifecta declares it needs cannot be made compatible with what other packages ask.
17:26:32 <slack1256> You could try relaxing the restrictions via `cabal v2-build --allow-newer`
17:26:34 <frdg> and this can happen out of nowhere? So basically one of the packages I am using got updated and now it is not compatible?
17:27:11 <slack1256> frdg: Well that and you did a `cabal update` I guess.
17:27:31 <slack1256> Cabal has a rollback feature you can use, I haven't used though.
17:27:36 <frdg> yes I did do a cabal update
17:27:36 <slack1256> used it.
17:27:55 <slack1256> You could rollback to the previous snapshot of cabal packages
17:28:08 <frdg> that would be ideal
17:28:19 <slack1256> I don't remember the syntax, I haven't done that ever.
17:29:35 <frdg> is it possible to which exact package needs to be rolled back? I did not specify any versions in my build-depends so I could just specify an older version.
17:31:27 <slack1256> You could rollback, do a `cabal freeze` so it prints out the resolved versions, cabal v2-update again an `cabal freeze` again. You could compare both freeze outputs for the change on versions.
17:33:08 <frdg> ok I'm gonna go for it. This isn't really a huge deal either way.
17:34:22 <dolio> Not specifying any versions might be why you're having trouble. That means there's no information to guide the solver, so it's going to start from the latest of everything and go from there, and it might give up before it finds a solution.
17:35:07 <slack1256> The option you want is `cabal v2-update --index-state=2016-09-24T17:47:48Z` for example. But you need to know at which state you where before, as it seems this doesn't have local revisions.
17:36:24 <frdg> hmm well on the other hand I might just trash the project and start a new one. Lesson learned about not specifying versions.
17:40:58 <slack1256> Good thing the fish shell saves "when" I executed a command on the history file.
17:49:50 <ezzieyguywuf> how do I import just this? https://hackage.haskell.org/package/OpenGLRaw-3.3.4.0/docs/Graphics-GL-Core33.html#v:GL_TRIANGLES
17:50:59 <monochrom> I think import Graphics.GL.Core33(pattern GL_TRIANGLES)
17:52:37 <ezzieyguywuf> monochrom: that did it!
17:53:54 <infinisil> TIL ^
17:58:42 * hackage ghc-lib-parser-ex 0.20200704 - Algorithms on GHC parse trees  https://hackage.haskell.org/package/ghc-lib-parser-ex-0.20200704 (shayne_fletcher)
18:45:30 <whataday> data Tree a = Leaf a | Node (Leaf a, Tree a) (Leaf a, Tree a)
18:45:49 <whataday> let v = Node (Leaf 1, Node (Leaf 3, Leaf 5) (Leaf 4, Leaf 6)) (Leaf 2, Leaf 5)
18:46:18 <whataday> how to get the sum of Leaf a?
18:46:46 <solonarv> back up a little. your 'data' declaration is wrong already.
18:46:48 <whataday> how many Leaf on this node
18:50:31 <whataday> if there's a tree, 0 connects to 1 and 2, 1 connect to 3 and 4, 2 connects to 5 and 6, 3 connects 7 and 8, 4 connects to 9 and 10, etc... how I can express this data in Haskell?
18:52:50 <solonarv> I'd go with something like: data Tree a = Leaf | Node a (Tree a) (Tree a)
18:54:47 <whataday> Leaf or Leaf a?
19:03:02 <solonarv> for the kind of tree you're describing (which has annotations at the nodes), I'd go with Leaf
19:04:04 <whataday> so let's v = Node 0 (Node 1 (Node 3 ???
19:04:33 <whataday> how to express 0 connects 1 and 2, 1 connects 3 and 4 with your type?
19:05:34 <solonarv> Node 0 (Node 1 (Node 3 ... ...) (Node 4 ... ...)) (Node 2 ... ...)
19:05:53 <solonarv> each of the ... can be another tree; if it doesn't continue on from there, it's Leaf
19:08:27 <whataday> let v = Node 0 (Node 1 (Node 3 Leaf Leaf) (Node 4 Leaf Leaf)) (Node 2 Leaf Leaf)
19:08:55 <whataday> how to get sum of node?
19:09:15 <whataday> here is sum 0..4
19:09:45 <solonarv> have you tried to solve this yourself?
19:10:39 <whataday> why would you ask this?
19:10:58 <solonarv> because this looks suspiciously like you're asking somebody to do your homework
19:11:08 <whataday> you think I know how to solve it and I still do it?
19:11:31 <whataday> this is not a homework
19:11:48 <solonarv> okay, then why are you asking? is it because you are trying to learn haskell?
19:11:51 <jephron> btw if you wrote "Leaf a | Node a (Tree a) (Tree a)", you'd have trouble representing trees with odd numbers of leaf nodes, because you'd force every Node to have two populated descendents
19:12:40 <whataday> I don't understand, if I have a question, I shouldn't ask here?
19:13:08 <solonarv> you should ask, but you shouldn't expect to have the finished answer served to you on a silver platter
19:13:38 <dmj`> whataday: just be honest, is this homework? We can help ask /you/ questions so you can come to an understanding if so.
19:14:07 <solonarv> if you are trying to learn haskell, then just asking people to give you code that solves your problem is not very productive
19:14:30 <whataday> I said it's not a homework, I just have this question this morning
19:14:57 <whataday> I need to know do I need this type to be Functor or Monad to get its sum
19:15:02 <whataday> or needn't
19:15:11 <solonarv> aha, now we're getting somewhere!
19:15:24 <solonarv> there's a 'sum' function in the Prelude, have you looked at its type?
19:15:54 <jephron> (1 is odd :facepalm:)
19:18:12 <whataday> I haven't looked at it
19:19:10 <solonarv> okay. maybe you should start there?
19:20:11 <whataday> do you do this to everyone who asked a question here?
19:20:29 <whataday> why I get this?
19:21:17 <c_wraith> in general, we do try to teach people how to learn on their own,.
19:21:42 <solonarv> no, I don't. sometimes I just don't respond at all. if the asker shows that they've put some effort in, I'll be more likely to answer their questions
19:21:49 <dsal> And sometimes it takes some effort to figure out where someone is coming from so we don't give them answers they can't possibly understand.
19:22:13 <solonarv> if it's a simple question like "what's the name of the function that does X?" I might just give a straight answer
19:22:57 <solonarv> but your questions makes it blindingly obvious that you don't understand the basics of the language very well, so that is what I will work on first
19:28:17 <dmj`> whataday: http://www.catb.org/~esr/faqs/smart-questions.html
19:39:32 <dsal> The best answer to the original question is probably "just make a Foldable instance," but that probably won't get you very far.
20:59:07 <bibek> hello
21:03:07 <bibek> \query amx Hi there
21:03:32 <bibek> \close
