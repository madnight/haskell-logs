00:00:41 <fog> where it seems like they are just abserving the isomorphism to the list model of nondeterminism
00:01:05 <fog> from here; http://www.randomhacks.net.s3-website-us-east-1.amazonaws.com/2007/02/21/randomly-sampled-distributions/
00:48:38 <kuribas> are type synonym families not allowed in class instances?
00:49:17 <kuribas> like instance MyClass (MyType API), where API is a servant type including type families.
01:32:47 <dminuoso> kuribas: afaik you must specify type constructors.
01:39:48 <kuribas> what do you mean?
01:40:18 <kuribas> putting a type synonym works fine with FlexibleInstances
01:44:00 <merijn> kuribas: Only fully applied ones
01:44:22 <merijn> So it depends on how you define "works fine" :)
01:44:35 <kuribas> ah I see...
01:44:55 <int-e> There's a specific TypeSynonymInstances extension, but usually you'll want FlexibleInstances which implies TypeSynonymInstances.
01:47:50 <kuribas> in which ghc version?
01:50:15 <kuribas> ah, but that doesn't include Type Synonym Families right?
01:50:49 * hackage ngx-export-tools-extra 0.5.2.1 - More extra tools for Nginx haskell module  https://hackage.haskell.org/package/ngx-export-tools-extra-0.5.2.1 (lyokha)
01:50:59 <int-e> type families are different beasts
01:51:38 <kuribas> I'll just make another tag for my API that I can use for this.
01:51:49 * hackage symmetry-operations-symbols 0.0.1.0 -   https://hackage.haskell.org/package/symmetry-operations-symbols-0.0.1.0 (narumij)
01:55:17 <merijn> kuribas: You can't use type synonym families that aren't fully applied either
01:55:33 <merijn> kuribas: In fact, type families are even *more* impossible to use without being fully applied
01:55:53 <kuribas> merijn: but they are fully applied in my API
02:05:47 <ADG1089_> what is the etiquette on editing your coworkers' files in VCS?
02:06:52 <kuribas> ADG1089_: I would expect a team to have guidelines and workflows for that.
02:07:27 <ADG1089_> without any guidelines is it frowned upon if I change code in somone else's files
02:07:33 <kuribas> ADG1089_: also depends on what "coworkers' files' means.  We don't have coworkers files, only company code.
02:07:54 <ADG1089_> yeah, some people are possesive wrt their code
02:08:04 <kuribas> well, there you have the problem already.
02:08:09 <kuribas> it isn't their code, it's the company code.
02:08:26 <kuribas> unless they own it, and licence it to the company
02:09:10 <ADG1089_> I am being questioned along the lines: "If possible can you share the pull requests for these changes? And in future before merging please ask first if you change anything on my code."
02:09:58 <ADG1089_> though i get your point
02:10:26 <kuribas> yeah, we work with pull requests.  So when commenting on a pull request, we can show example code, but it's the pull request author which does the changes.
02:10:47 <kuribas> And it's always a good idea to discuss changes.
02:10:53 <ADG1089_> sure idea.
02:11:37 <kuribas> the point is, there has to be a process, so everyone is in on changes.
02:12:02 <svipal> Yo
02:12:05 <kuribas> I think pull requests are great for that.
02:12:16 <kuribas> I've been pushing it in our company, and now everyone is happy :)
02:12:33 <svipal> can you choose where to install 
02:12:38 <svipal> when you do stack install
02:14:29 <kuribas> ADG1089_: if you have a review process, nobody gets unpleasant surprise :)  But "my code" is bullshit when you get payed for writing it.
02:15:29 <ADG1089_> sounds great
02:17:09 <kuribas> I also think "It’s Easier To Ask Forgiveness Than To Get Permission", applies here (within limits of course).
02:17:35 <kuribas> You change code to the best of your abilities, and if someone disagrees you can discuss it.
02:18:29 <kuribas> ADG1089_: BTW, that response is very reasonable, except for the "my code" part.
02:18:56 <kuribas> hence "pull requests" :)
02:19:09 <ADG1089_> i can disregard "my code" part for now
02:19:18 <ADG1089_> i hope he doesn't refer to that again
02:20:21 <kuribas> ADG1089_: if he does, politely refer him to the fact that you're a team, and that you're in it together.
02:20:52 <ADG1089_> is there an irc for workplace skills or similar?
02:20:56 <kuribas> of course that might be hard if he's a senior...
02:21:08 <ADG1089_> maybe i am spamming here non-haskell queries
02:21:25 <kuribas> ADG1089_: you can try #haskell-offtopic 
02:21:45 <kuribas> also #programming
02:23:35 <[exa]> ADG1089_: a pull request is a great way to make sure that you don't introduce a change that would break any assumptions of the code "owner", basically a notification with "accept" button
02:24:33 <[exa]> ADG1089_: otherwise, people frowning upon _non-breaking_ changes in their codebases are likely too touchy
02:24:40 <ADG1089_> I made some changes on a pull request and a couple of commits on dev 
02:24:59 <ADG1089_> changes response format and moved code closer to usage and added type annotations
02:25:07 <ADG1089_> shouldn't have done on dev
02:25:07 <[exa]> also, explaining the changes in non-negative way is hard sometimes, especially if you fix the other person's bugs
02:25:13 <ADG1089_> and informed him of the pull request
02:25:49 <kuribas> [exa]: we're all agressive refactorers, and nobody cares really.  But I guess it's not like that everywhere.
02:26:07 <[exa]> oh "stylish" changes, these are likely to trigger :]
02:26:25 <kuribas> [exa]: that's because you don't have style guides
02:26:50 <[exa]> even variable naming, the verbosity of type annotations, etc.
02:40:19 * hackage ptr 0.16.7.1 - Abstractions for operations on pointers  https://hackage.haskell.org/package/ptr-0.16.7.1 (NikitaVolkov)
02:50:49 * hackage ptr 0.16.7.2 - Abstractions for operations on pointers  https://hackage.haskell.org/package/ptr-0.16.7.2 (NikitaVolkov)
02:55:50 * hackage hasql-dynamic-statements 0.2.0.2 - Toolkit for constructing Hasql statements dynamically  https://hackage.haskell.org/package/hasql-dynamic-statements-0.2.0.2 (NikitaVolkov)
03:26:19 * hackage symmetry-operations-symbols 0.0.1.1 -   https://hackage.haskell.org/package/symmetry-operations-symbols-0.0.1.1 (narumij)
03:36:12 <Orbstheorem> Is the OverloadedLabels part of HasField already been implemented? Or it's still just a proposal (c.f. magic classes)
03:41:33 <dminuoso> Orbstheorem: I think you're conflating OverloadedLabels with OverloadedRecordFields
03:43:01 <Orbstheorem> In the Overloaded labels section of the latest ghc user guide, it says that GHC will replace `#foo` with `fromLabel @"foo"` during typechecking.
03:43:42 <Orbstheorem> Oh
03:43:49 <Orbstheorem> Yes, sorry
03:43:50 <Orbstheorem> ><"
03:44:03 <kuribas> Orbstheorem: yes, that's implemented
03:44:05 * Orbstheorem fast-read `fromLabel` as `getField`
03:44:11 <Orbstheorem> Nevermind ><"
03:45:49 * hackage rebase 1.7 - A more progressive alternative to the "base" package  https://hackage.haskell.org/package/rebase-1.7 (NikitaVolkov)
03:50:03 <Orbstheorem> So, I found [the proposal](https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0023-overloaded-record-fields.rst), which says it was implemented in 8.2, but I can't get it working in my install of 8.6.5.
03:50:51 <kuribas> Orbstheorem: did you put a LANGUAGE pragma in your file?
03:51:47 <Orbstheorem> https://paste.gnugen.ch/raw/YfxD
03:52:12 <Orbstheorem> (Sorry https://paste.gnugen.ch/raw/a7eI)
03:52:19 <svipal> why oh why do foreign libs have to recompile every stack run
03:52:27 <svipal> even if you did not change any code pertaining to them
03:54:19 * hackage rerebase 1.7 - Reexports from "base" with a bunch of other standard libraries  https://hackage.haskell.org/package/rerebase-1.7 (NikitaVolkov)
03:58:45 <Orbstheorem> kuribas: From the code above, am I missing something?
04:02:53 <kuribas> Orbstheorem: what type is #ff ?
04:05:25 <kuribas> Orbstheorem: I would expect an isLabel instance at least: https://hackage.haskell.org/package/base-4.14.0.0/docs/GHC-OverloadedLabels.html
04:06:49 * hackage hasql 1.4.4.1 - An efficient PostgreSQL driver with a flexible mapping API  https://hackage.haskell.org/package/hasql-1.4.4.1 (NikitaVolkov)
04:08:49 * hackage symmetry-operations-symbols 0.0.1.2 -   https://hackage.haskell.org/package/symmetry-operations-symbols-0.0.1.2 (narumij)
04:09:05 <Orbstheorem> ff should be provided by HasField, shouldn't it?
04:09:19 <kuribas> that's not how it works
04:09:57 <Orbstheorem> I'd expect it to be desugared to `fromLabel @"ff"`, which translate to `getField @"ff"`
04:10:53 <kuribas> http://dev.stephendiehl.com/hask/#overloadedlabels
04:11:43 <kuribas> Orbstheorem: but what's the type of getField @"ff" ?
04:11:50 <Orbstheorem> Bool
04:12:21 <Orbstheorem> `Sub a -> Bool` *
04:12:32 <kuribas> No it isn't.
04:13:13 * Orbstheorem is confused
04:13:18 <Orbstheorem> Okay, so which one is it?
04:13:30 <kuribas> I don't know?  You have to define a type for it.
04:13:38 <kuribas> then implement a HasLabel instance.
04:13:50 <kuribas> Which I don't see in your code.
04:13:58 <kuribas> Or use an existing one, like genericLens
04:14:18 <Orbstheorem> Right, I thought the `instance HasField x r a => IsLabel x (r -> a)` was provided by `GHC.OverloadedLabels`.
04:14:32 <Orbstheorem> Got it.
04:14:39 <Orbstheorem> (Thanks for the link btw)
04:15:04 <kuribas> it isn't.  And probably not a good idea either.
04:15:21 <kuribas> It will give confusing error messages.
04:23:49 * hackage hasql 1.4.4.2 - An efficient PostgreSQL driver with a flexible mapping API  https://hackage.haskell.org/package/hasql-1.4.4.2 (NikitaVolkov)
04:35:18 * hackage hasql-implicits 0.1.0.2 - Implicit definitions for Hasql, such as default codecs for standard types  https://hackage.haskell.org/package/hasql-implicits-0.1.0.2 (NikitaVolkov)
05:23:19 * hackage aws-lambda-haskell-runtime 3.0.2 - Haskell runtime for AWS Lambda  https://hackage.haskell.org/package/aws-lambda-haskell-runtime-3.0.2 (NickSeagull)
05:25:15 <carbolymer> damn, refactoring in haskell is time-consuming and mundane
05:25:24 <carbolymer> I miss java-level IDE support :/
05:30:22 <maerwald> you mean when you keep clicking "solve problem" until the errors go away?
05:33:35 <carbolymer> no, shift+F6 renames functions/modules and all references
05:33:39 <stefan-_> carbolymer, this was released recently: https://github.com/facebookincubator/retrie/
05:34:57 <carbolymer> stefan-_, yeah, I saw that, but I'm not sure if writing code is an effective way of renaming & reorganizing a dozen of modules with too much inter-dependencies in them
05:45:50 * hackage hall-symbols 0.1.0.4 - Symmetry operations generater of Hall Symbols  https://hackage.haskell.org/package/hall-symbols-0.1.0.4 (narumij)
05:46:44 <typetetris> Does `throwSTM` roll back the stm transaction?
05:48:54 <hpc> typetetris: https://hackage.haskell.org/package/stm-2.5.0.0/docs/Control-Monad-STM.html#v:throwSTM "Throwing an exception in STM aborts the transaction and propagates the exception."
05:49:06 <typetetris> hpc: Thank yue!
05:50:24 <infinisil> Didn't know STM had exceptions. Not sure how I feel about that, feels a little nasty
05:51:19 <typetetris> infinisil, async exceptions are everythere anyway ...
05:51:59 <Arahael> Are exceptions actually useful, or are they an unfortunate historical accident?
05:52:19 <hpc> sometimes they're useful
05:52:58 <hpc> i am conflicted on the idea of having them everywhere, but in some ways it's sort of mandatory
05:53:08 <Arahael> Yeah? Mandatory?
05:53:27 <hpc> if you accept that you can kill a thread from another thread, and that sometimes you want to clean stuff up before the thread actually exits, what else is there but async exceptions?
05:53:59 <hpc> the thread you're killing could be executing any code, so you need something that can fit itself anywhere to handle it
05:54:30 <Arahael> So they compose well in that case, is that what you're saying?
05:54:50 <hpc> i don't know about composing well, but just the functionality has to be there
05:55:17 <Arahael> I mean, you typically handle this sort of thing explicitly in most languages, but it sounds like you're saying that haskell's exceptiosn lets you deal with that for any thread even if that thread is executing code that was never designed for it.
05:55:19 <hpc> there's probably some ST-like thing you could make so it would be better
05:55:40 <hpc> like, technically in haskell you can do IO anywhere too, it's just not exposed that way to the programmer
05:55:43 <merijn> Haskell having unchecked exceptions was a mistake, tbh
05:56:05 <merijn> I think the Haskell design would be great if they were checked
05:56:14 <Arahael> I remember being very confused when I used Wreq, and suddenly had HTTP exceptions that were not documented at all by Wreq.
05:56:20 <hpc> ah right, i forgot about checked exceptions
05:56:35 <merijn> Most libraries don't bother to document their exceptions, which sucks
05:56:42 <hpc> probably the one good idea java ever had
05:56:49 <hpc> that would be nice to have
05:57:03 <typetetris> any they don't like it and don't use it, at least in the companies I worked for.
05:57:09 <merijn> hpc: But inferrable :)
05:57:21 <Arahael> merijn: When I pointed it out, I was basically told (with different words) that I was simply naive and a bit of an idiot. :(  Wreq uses HTTP, so "of course" it raises exceptions from the underlying HTTP. :(
05:57:23 <merijn> hpc: So you don't have to document them manually except where it matters
05:57:37 <hpc> yessssss
05:59:04 <merijn> hpc: I have some ideas on how to do that, but 1) no one wants to pay me to explore it and 2) I don't it can be backwards compatible with GHC as it is now
05:59:09 <merijn> :p
05:59:42 <hpc> checked async exceptions might be an interesting thing to try and figure out
06:00:19 <hpc> like have async exceptions masked everywhere except code that has the right type
06:00:28 <Arahael> Would be awesome if hlint or something was able to scan the program and say: "You've got the following unhandled exceptions in your application".
06:01:03 <Arahael> Bed time for me.
06:04:20 <infinisil> I am excited for https://github.com/hasura/eff, and would like some effect system like it to become the standard
06:04:53 <infinisil> Which would allow explicit errors
06:05:07 <maerwald> infinisil: good, wait 2 years until the patch is accepted, another year for a release and then 5 years for adoption
06:05:43 <infinisil> Slow but steady!
06:05:52 <maerwald> if you only care about explicit errors, have a look at open variants
06:06:30 <maerwald> https://hackage.haskell.org/package/plucky
06:06:34 <maerwald> https://hackage.haskell.org/package/haskus-utils-variant-3.0/docs/Haskus-Utils-Variant-Excepts.html
06:06:50 <maerwald> that is usable *now*
06:07:20 <maerwald> I believe the latter may block inlining, I'm not sure
06:09:28 <infinisil> Neat
06:10:09 <maerwald> https://www.parsonsmatt.org/2020/01/03/plucking_constraints.html
06:10:19 <AndreasK> What's the easiest way to resolve an executable in PATH in a haskell program? E.g. go from "ghc" to the path /usr/bin/.../gc
06:11:55 <infinisil> AndreasK: https://hackage.haskell.org/package/directory-1.3.6.1/docs/System-Directory.html#v:findExecutable
06:12:18 <AndreasK> infinisil: That's what I was looking for! Thanks
06:20:53 <nlhowell1> can someone recommend me a comparison of libraries for building CLI tools? e.g. argument parsing
06:23:10 <dminuoso> nlhowell1: optparse-applicative
06:23:12 <dminuoso> No contest.
06:23:20 <merijn> Does "just use optparse-applictive" count as a comparison? :p
06:23:29 <nlhowell1> even better :D
06:23:32 <nlhowell1> thanks!
06:25:03 <maerwald> It's basically the only maintained one no?
06:25:36 <nlhowell1> I love easy choices
06:25:47 <merijn> There's a few others, but those prefer "magic" over configurability
06:25:49 <dminuoso> There's a couple other active libraries, but optparse-applicative is just too good to have contesters.
06:26:05 <dminuoso> The only thing I sorely miss, is optparse-selective.
06:26:13 <dminuoso> But alas, can't have everything.
06:26:29 <dminuoso> I think it's a WIP though.
06:26:35 <merijn> optparse is very explicit, so for very simple parsers it's a bit more verbose, but it's not too bad and it's very future proof in that it scales well to very complex setups
06:27:05 <merijn> dminuoso: There's a ticket for selective support, and that's on my (extremely) long-term todo list to look into, but feel free to implement it sooner :p
06:27:26 <merijn> Selective would be great with optparse
07:01:41 <kuribas> where is the syntax reference for Dhall?
07:02:02 <kuribas> in particular record field names...
07:02:28 <merijn> kuribas: The website has a reference, so presumably there?
07:03:41 <dmj`> @package dhall
07:03:41 <lambdabot> https://hackage.haskell.org/package/dhall
07:04:17 <kuribas> found it: https://github.com/dhall-lang/dhall-lang/blob/master/standard/dhall.abnf
07:06:38 <rkrishnan> dminuoso: there is also optparse-generic, which seem to build on top of optparse-applicative and uses GHC generics.
07:07:13 <merijn> rkrishnan: That undermines like half the reason I'd recommend optparse, though
07:07:27 <rkrishnan> merijn: you mean the ghc generics part?
07:07:47 <merijn> Auto-generating stuff from records is a bad idea for long-term maintainability
07:07:50 <rkrishnan> merijn: for speed reasons? I still prefer optparse-applicative.
07:07:56 <rkrishnan> merijn: agree.
07:08:12 <merijn> Tying your external interface/API to internal data structures is always a mistake
07:08:53 <sm[m]> morning all
07:09:04 <sm[m]> cmdargs is missed, as usual. It’s as good as optparse
07:09:13 <merijn> Hard disagree :)
07:09:44 <sm[m]> and certainly maintained, at least let’s agree on that ? ;)
07:10:17 <dmj`> merijn: are you saying GHC.Generics is a bad idea?
07:10:28 <dmj`> it's all about auto generating stuff from records
07:10:28 <maerwald> is there a canonical way to test your MonadBaseControl instances? Probably something with state I guess
07:10:33 <merijn> dmj`: No, I'm saying that auto-generating is a bad idea
07:10:58 <merijn> dmj`: See my later remark that tying your external interface/API to internal data structures is a dumb idea
07:11:10 <merijn> dmj`: The same reason why using typeclasses for (de)serialisation of data is a dumb idea
07:11:22 <dmj`> I did, and I don't see how that's any different from what GHC.Generics does
07:11:37 <dmj`> merijn: so aeson From/To is a bad idea?
07:12:01 <merijn> dmj`: There are usecases for GHC generics that *don't* involve external uses, but just generalising code and that's fine
07:12:04 <merijn> dmj`: Yes
07:12:10 <merijn> dmj`: It's the worst part of aeson by far
07:12:25 <merijn> (except maybe the part where aeson's API uses ByteString which is objectively wrong)
07:12:46 <dmj`> One of the major use cases of GHC.Generics is serialization (in the context of default signatures w/ typeclasses) and "auto generating stuff"
07:13:14 <merijn> dmj`: "auto generating code" is fine, auto-generating external representations is dumb
07:13:16 <maerwald> sm[m]: last upload was in 2018?
07:13:40 <merijn> dmj`: Default signatures and generic instances of classes have many use cases other than serialisation
07:14:25 <dminuoso> I think From/ToJSON are fine if all you care about is dumping/restoring internal data. 
07:14:29 <dminuoso> But that's the extend of it.
07:14:43 <merijn> dmj`: Seems a weird strawman to pretend I am (or should be) arguing against generic when I was pretty explicit about my objection being against deriving external representations
07:15:47 <merijn> dminuoso: Right, typeclass serialisation is fine IF AND ONLY IF you don't actually care about portability or future proving. Which of course, it turns out, you always will care about eventually in the real world and then you regret making such a dumb mistake
07:15:59 <sm[m]> maerwald: woah, that really surprises me. Could swear I saw updates. I’d still call it maintained since it’s ndmitchell, but indeed it couldn’t be called active
07:16:12 <dmj`> merijn: I'm not pretending, deriving parsers, objects, etc. that external representations rely on is almost entirely what GHC.Generics is used for.
07:16:19 <merijn> Literally every time I was like "eh, it's fine, I can just use typeclass based (de)serialisation or use an un-versioned format" it's come to bite me in the ass
07:16:19 <sm[m]> I guess it’s perfect. No need for churn.
07:16:41 <dmj`> deriving anyclass FromJSON is fantastic
07:16:44 <maerwald> merijn: sure that wasn't just your cat?
07:17:12 <merijn> maerwald: Naah, she's a sweetheart
07:17:22 <maerwald> sm[m]: the repo has some more commits, bur probably just cabal file updating etc
07:17:27 <merijn> dmj`: Until you need to support a legacy schema and a new one
07:17:32 <merijn> dmj`: Now you're hosed :)
07:17:37 <dminuoso> merijn: Absolutely. In my case it's about being able separate stages of my compiler, where each stage could halt, dump json, and then restore from the json later. So it's an internal API only.
07:17:49 <dminuoso> And I literally dont care about the representation, since it's an internal feature.
07:17:57 <merijn> dminuoso: Famous last words
07:18:01 <dminuoso> Heh.
07:18:07 <dmj`> merijn: I don't see why you can't have multiple generic instances for each schema
07:19:38 <dminuoso> I'd much prefer if we had a TH based mechanism, such that you can just go `fromFoo = $(deriveFromJSON opts ''Foo)` over typeclass based mechanisms, if we insist on having boilerplate tools.
07:19:52 <dmj`> merijn: oh I see what you're saying now, if you have a v0 and then v1, and you remove a field
07:19:57 <dminuoso> Tying representation to a type in an open-world assumption is a bad idea.
07:20:07 <merijn> dminuoso: Seriously, biggest regret in my original phd code was lack of versioning internal data
07:20:11 <merijn> dmj`: Yes
07:20:34 <dminuoso> merijn: In my case its not applicable, since there couldn't be cross version portability. It's only use is being able to debug the compiler.
07:20:40 <merijn> dmj`: I just don't see how the typeclass approach is better than the Get/Put datatypes of, say, binary.
07:21:13 <merijn> dmj`: Like, how is "instance FromJSON Foo" superior to just having "myFooParser :: Get Foo" using binary's API.
07:21:14 <dmj`> yea that would be problematic, safecopy is kind of very verbose as well. 
07:21:28 <maerwald> merijn: so, you're a fan of waargonaut?
07:21:38 <dmj`> merijn: I'd say its equivalent operationally, but nicer aesthetically.
07:21:51 <merijn> dmj`: But the Get approach is more robust later :p
07:22:11 <merijn> dmj`: Since you can have infinitely many unique "Get Foo" in one program, but only one FromJSON :)
07:22:30 <merijn> maerwald: I don't do JSON, so I have no opinion
07:22:46 <dmj`> merijn: this is what newtyping is for
07:23:41 <dmj`> merijn: there should be a library that allows one to version fields and generics will take advantage of this
07:23:41 <merijn> dmj`: And now you just wanna add a new version for one sub-field
07:24:23 <merijn> dmj`: Sounds like a lot of complex engineering and API overhead for what could just be "a regular parser with Functor/Applicative/Monad/Alternative instances" :)
07:24:44 <dmj`> merijn: an alternative is to git checkout the old code base build it, and then have all requests dispatch to those servers by way of the URL
07:24:46 <merijn> maerwald: Spending 5 seconds going over the waargonaut haddocks I can confidently say I already don't like it :)
07:24:59 <merijn> dmj`: Not everything is a webserver :)
07:25:06 <dmj`> merijn: didn't say it was :) 
07:25:08 <maerwald> merijn: I tried to use it and got lost in complicated internal API
07:25:11 <merijn> dmj`: Some people write programs that are run by users and need to operate on actual files
07:25:29 <dmj`> merijn: are you implying I don't ?
07:25:32 <merijn> maerwald: Way too verbose, 15 billion type synonyms, can't be bothered
07:25:46 <merijn> dmj`: Well "dispatch to server using old code" isn't really an option there :)
07:26:13 <dmj`> merijn: why the smiley faces?
07:27:17 <dmwit> `instance FromJSON Foo` is nicer when it's `instance (FromJSON a, FromJSON b, FromJSON c) => FromJSON (a,b,c)`.
07:27:30 <dmj`> merijn: there's no need to be condescending
07:27:39 <dmwit> (is nicer than `getFoo :: Get Foo`, I mean)
07:27:57 <merijn> dmwit: Just Applicative Get and done
07:28:16 <merijn> When did smileys become condescending
07:28:18 <dmwit> merijn: (,,) is a particularly simple parameterized data type, but by no means the only one.
07:28:38 <merijn> dmwit: Right, but that's why we invented Applicative and Monad, no?
07:28:40 <dmwit> It is possible but incredibly annoying to reflect the type-level structure at the term-level all the time.
07:28:53 <dmwit> merijn: I don't see how those help with the problem I'm describing.
07:29:07 <dmwit> Which is: the Get version is `getTriple :: Get a -> Get b -> Get c -> Get (a,b,c)`.
07:29:33 <merijn> dmwit: The get version is to not write getTriple and just write the Applicative expression in line...
07:29:39 <dmwit> And so now every time you want to get a triple, you must supply arguments for each of the fields. If they are themselves parameterized data structures, it gets incredibly nasty.
07:29:48 <merijn> And/or "liftA3 (,,)"
07:29:49 * hackage icfpc2020-galaxy 0.1.0.0 - A strange message received at the Pegovka observatory  https://hackage.haskell.org/package/icfpc2020-galaxy-0.1.0.0 (mniip)
07:29:51 <dmj`> merijn: an alternative is to always keep around old fields, but mark them as deprecated and no-op when you start your CLI
07:30:00 <dmwit> `getTriple (getList (getTree Bool)) (getPair getInt getChar) getString`... ugh
07:30:10 <dmwit> `fromJSON` is much, much shorter
07:30:13 <merijn> dmj`: That works if you only remove them, not add alternate/new ways of representing them
07:30:50 <dmwit> merijn: Right. That's why I'm saying `(,,)` is just a particularly trivial example of a parameterized data type. You can't get away with `liftA3` for more complex ones.
07:30:56 <merijn> dmwit: No one writers binary or parsec parsers like that, so why would you write json like that?
07:31:01 <dmwit> Like list (you also going to write `fix` every time?) or tree.
07:31:21 <dmj`> merijn: well you could prefix the fields to be "legacy" or something then keep the old commands around
07:31:41 <dmj`> merijn-v1 build 
07:32:02 <merijn> dmj`: But if you derive your FromJSON using generics from your record than that won't correctly parse old data
07:32:22 <merijn> Which is the exact reason why I argued that coupling them is bad
07:32:43 <dmwit> "no one writes binary parsers like that" sounds like a blub argument to me.
07:32:48 <dmj`> why not make a custom FromJSON that does correctly parse old data
07:33:00 <dmwit> "It's too hard to do this nice thing, so everybody does a worse thing instead."
07:33:01 <dmj`> w/ generics
07:33:49 <dmwit> I'm not saying that FromJSON is a godly invention and we should only use it for everything or anything like that. I'm the first to remind people that their aeson parsers don't need to be named `fromJSON`. But I think it's just as silly to claim there's no benefit to that style ever.
07:33:49 <merijn> dmj`: Right, but then you gain literally nothing by having typeclass based serialisation
07:34:29 <dmj`> merijn: you gain the aesthetics of having it nicely coupled with the data type definition
07:34:32 <merijn> dmwit: I'm not saying there isn't any benefit. I'm saying that it will bite you in the ass eventually, so the benefit isn't worth it
07:35:49 <merijn> dmj`: In my experience that aesthetic is a massive liability and every time I've done it (and over 50% of the time I've seen others do it) it turned out to cause future trouble. (And in the other 50% it might still become trouble), so it's just not worth it
07:36:17 <merijn> The bigger my Haskell codebase grows, the more I'm convinced "encapsulation boilerplate is good, actually"
07:38:11 <dmj`> I agree there isn't a one-size-fits-all generic deriving for JSON for everybody's needs, but you could write your own (GMerijnFromJSON) that would encompass all of your parsing needs, and encapsulate the versioning logic on fields inside of it.
07:53:49 * hackage icfpc2020-galaxy 0.1.0.1 - A strange message received at the Pegovka observatory  https://hackage.haskell.org/package/icfpc2020-galaxy-0.1.0.1 (mniip)
08:29:32 <IngvarLynn[m]> Hi. Can anyone point me to documentation for the following language feature: `type Strange = ("synonym" :! Int)`? I'am especially puzzled about origin of `:!` operator.
08:32:32 <c_wraith> IngvarLynn[m]: that *is* the origin of the :! operator
08:32:46 <frdg> question about passing an argument to a function that returns IO. https://dpaste.org/Rvqx
08:33:19 <c_wraith> IngvarLynn[m]: whoops, no, that's type, not data.  Well.  It's imported from a library somewhere!  all I can tell you.
08:34:05 <c_wraith> frdg: what's the error?
08:34:55 <frdg> err I'm confused ignore me
08:35:36 <c_wraith> IngvarLynn[m]: any operator starting with : is available for use as the name of a data constructor.  That's not a name I recognize, so you'd have to look at your imports.
08:36:08 <c_wraith> IngvarLynn[m]: I *can* tell you that DataKinds is in use there, as it's using both a String and that constructor as types.
08:42:21 <IngvarLynn[m]> hmm...
08:43:31 <ibloom> I've been trying to implement an extensible tree based on the paper "Tree That Grow" and I kind of got stuck. Created a simple example of a function that I couldn't typecheck. https://repl.it/@ibloom/GaseousVagueLocatorprogram#main.hs
08:43:32 <ibloom> *Trees
08:45:38 <ibloom> Basically the sticking point occurs as soon as I want to create some generic functions such as my function fullSTree which takes a tree of Maybe items and collapses out the Maybes. So far I've been unable to figure out how to make this polymorphic.
08:45:57 <c_wraith> ibloom: so the first thing to note is that the error mentions a0, which is not in your type signature
08:46:07 <c_wraith> ibloom: that means that something isn't unifying
08:46:10 <ibloom> Right.
08:46:48 <ibloom> Maybe there is just a bug in my case expressions, but I've been beating my head against the wall trying to find it.
08:48:24 <ibloom> I made an even simpler example with my own version of List. I was able to typecheck the generic version of that.
08:52:21 <ibloom> Here's that test: https://repl.it/@ibloom/SevereSlightEngineering
08:53:22 <ibloom> The last commented out function both2 won't type check.
08:54:00 <c_wraith> hmm.  this isn't the problem, but the shadowing of tree in that case doesn't help read it
08:57:16 <c_wraith> ok, I can tell you why both2 doesn't typecheck
08:57:38 <ibloom> Hit me.
08:58:03 <c_wraith> it doesn't know the return type of catMaybes2
08:58:40 <kuribas> shouldn't the cabal new-stuff cache builds?  Because it looks to me like it's compile the same packages over and over...
08:59:07 <ibloom> c_wraith shouldn't that just be Elem b?
09:02:42 <IngvarLynn[m]> Answering my own question: it's the `named` package https://www.stackage.org/haddock/lts-14.26/named-0.3.0.1/Named.html#t::-33-
09:04:55 <c_wraith> ibloom: type families aren't injective, though.  catMaybes2 is List a -> List b, as long as Elem a ~ Maybe (Elem b).  But that doesn't enforce any kind of uniqueness on b given a particular a
09:05:42 <c_wraith> ibloom: so GHC doesn't know the intermediate type. That's what it's trying to tell you with not being able to unify the fresh type variable with anything.
09:06:11 <ibloom> I see. Is there a way I can approach constructing these type families, so that I don't constantly run into this problem?
09:06:36 <c_wraith> if they're actually intended to be injective, you can use injective type families.
09:06:55 <ibloom> Aha.
09:07:44 <c_wraith> I haven't used them, but vaguely recall someone saying that GHC's use of injectivity is weaker than they'd like.
09:07:52 <c_wraith> It's something to try, anyway
09:10:15 <ibloom> Yeah, I haven't had a good time with injective typeclasses in the past.
09:12:09 <ibloom> I just went through it and I don't think that will work. What I'm really looking for is a way to talk about Functors over type families.
09:12:35 <c_wraith> that's not something ghc is really equipped to talk about.
09:13:06 <ibloom> Yeah. I think that's the case. I'll have to go with less generic functions.
09:14:48 <lortabac> ibloom: there are solutions, but they are quite complex
09:15:38 <lortabac> the common workaround to the like of higher-order type families is defunctionalization
09:15:44 <lortabac> s/like/lack
09:16:14 <ibloom> Yeah, just by specifying the types for fullSTree it compiles immediately... https://repl.it/@ibloom/GaseousVagueLocatorprogram
09:16:38 <lortabac> @hackage first-class-families
09:16:39 <lambdabot> https://hackage.haskell.org/package/first-class-families
09:16:55 <ibloom> What is defunctionalization exactly?
09:18:07 <kuribas> IngvarLynn[m]: which code is using that package?
09:18:07 <dminuoso> ibloom: https://en.wikipedia.org/wiki/Defunctionalization
09:18:07 <dminuoso> This is actually a surprisingly good wiki article
09:18:35 <dminuoso> You know, provide you with an example and not explain it. But I think the basic idea should be obvious
09:21:34 <ibloom> Alright I'll look into this. Thank you. Unfortunately sometimes it's better to maintain a bunch of functions that are all almost the same but with different type signatures than to get stuck trying to get the typechecker to accept your super generic code...
09:22:23 <ibloom> That's an unfortunate conclusion, I know.
09:26:17 <lortabac> ibloom: I think most Haskellers would agree with your conclusion
09:27:56 <kuribas> ibloom: that or you go the lens route
09:28:12 <kuribas> include as much category theory as you can
09:57:34 <dsal> I'm slightly interested in rust, but I'm a bit sad that all of my Haskell RSS feeds seem to be rust tutorials lately.
10:00:00 <maerwald> you'll lose some of your enthusiasm if you look at async
10:02:19 <dsal> My rust knowledge is very small and almost entirely theoretical.
10:02:47 <dsal> It currently occupies that part of my brain where I think there's a thing that needs a solution and this thing claims to be a solution, so it's a perfect fit.
10:19:11 <merijn> dsal: Basically, don't think of Rust as an alternative to Haskell, but as an alternative to C/C++ with nice stuff like typeclasses and ADTs :)
10:19:17 <hyperisco> maerwald, what is async?
10:19:48 <merijn> dsal: My main problem with Rust is that I just don't really have a use for it. Rust would be great if I couldn't afford GHC's GC pauses
10:20:00 <merijn> dsal: But in reality for 99% of my code GC pauses just aren't an issue
10:20:16 <dsal> merijn: Yeah, that's how I think of it.  I can understand the appeal *from* Haskell, of course, but it seems to be quite appealing for Haskellers now.
10:20:19 <dsal> I'm exactly where you are.
10:20:29 <dsal> "Sure wish I needed that."
10:20:42 <dolio> Sometimes Haskellers need to do some C-like stuff.
10:21:05 <merijn> dolio: Yeah, but often it's less work to FFI to C from Haskell for those bits ;)
10:21:10 <dsal> Sure.  Though when I need to do C stuff, I end up just using C.
10:21:28 <dsal> I don't *like* doing C, but it's either got the APIs I need or the compiler I need.
10:21:38 <maerwald> hyperisco: https://blog.rust-lang.org/2019/11/07/Async-await-stable.html
10:22:00 <dsal> I'd like to do some rust, but it's a rather high bar to get me where I already am.
10:22:35 <merijn> dolio: In fact, the ease with which you can wrap tiny amounts of C into nice abstractions using Haskell is really undersold, imo
10:23:29 <hyperisco> maerwald, oh no
10:23:31 <dolio> Okay, but if someone never learns rust, they'll never be able to make an informed call on that.
10:23:37 <merijn> dolio: And I'm not arguing there's no usecases for Rust, clearly for stuff like bare metal/OS/kernel/whatever stuff it's nice :)
10:23:46 <hyperisco> maerwald, it is like specialising the Either monad wasn't a good long term choice after all
10:24:12 <merijn> dolio: I don't think anyone was arguing against learning Rust, more lamenting not having a need to bother investing the time :)
10:24:40 <dsal> Yeah.  I'd like to have a rust as a usable tool.  I just have a super nice hammer.
10:25:16 <hyperisco> of course you could point to new Haskell extensions and laugh at earlier choices too
10:25:45 <hyperisco> difference being… the hindsight was unnecessary for Rust oO
10:26:06 <[exa]> sad truth about rust: the "safety" will start getting seriously in the way exactly at the point where you could start enjoying the lowlevel stuff
10:26:40 <merijn> hyperisco: I actually argued on twitter a while ago that we're doing haskell a disservice by underselling how unsafe it is ;)
10:26:44 <hyperisco> you know this or you're guessing, [exa] ?
10:31:07 <[exa]> first I tried to write a tiny udp server that would manage some led switches in /sys, I switched to C in the middle because it was just easier. A friend was trying to port some array stuff from python/numpy and we spent quite some time pushing it to generate reasonable simd code and I ended up with coding a "comparison version" in C++ again
10:31:28 <hyperisco> if the result of the borrow checker is that it must be intricately woven through new features like async, I import my concerns from dependently typed programming
10:31:29 <[exa]> perhaps I didn't try enough
10:31:57 <hyperisco> though for some reason I don't go as far as to agree with incremental typing
10:33:28 <hyperisco> I think if the objective is to generate specific simd instructions then the method is broken
10:34:31 <hyperisco> why not write the assembly and call that
10:35:34 <[exa]> because I'm not the compiler
10:35:58 <hyperisco> yeah I'm saying don't use one
10:37:00 <[exa]> but that would take ages to code&maintain
10:37:43 <dsal> I did an interview challenge thing a while back that was really trivial, but I found people couldn't do it.  Argh... should find that.  It's basically:  Given a list of usernames in a file, write a program that will tell if a given username is in the list.  There were ~a million usernames.
10:39:09 <dsal> Someone submitted this large complex C++ trie that used a ton of memory and ran destructors for a full minute at the end of execution.  I wrote a thing in python on the commandline that did it faster, so I realized people were just bad at things and I needed to make it clearer that it had to not suck.  I generated 100 million usernames (~900MB, I think it was) and asked for a solution that would run on my laptop.
10:39:22 <[exa]> hyperisco: that being said I really hope rust catches up at tcp networking, the safety bounds seem really spot-on there
10:39:39 <[exa]> dsal: is grep allowed?
10:39:40 <dsal> My C solution was ~79 SLOC with no external libraries and super easy to follow.
10:39:49 <kuribas> dsal: so... grep?
10:39:51 <dsal> [exa]: At part 1 of the test, sure.  :)
10:40:36 <dsal> Technically, you're supposed to make an API that asks for a username, but yeah... grep's a fine case.  For my own test, I'd reiterate the list and do a presence check for each one and then a random subset.
10:41:15 <dsal> I think mine used < 1.5GB of RAM.  I've not tried it in Haskell.  I think it'd be hard to keep the footprint low.
10:41:51 <[exa]> I guess any language will do just OK until some C++ expert tries to smash the data in the memory
10:42:29 <[exa]> perhaps even R could do this quickly
10:42:52 <kuribas> read USERNAME; grep -F $USERNAME liftOfUsernames.txt
10:43:00 <hyperisco> why would it take more than a kilobyte of memory
10:43:02 <dsal> This is why I suggested 100 million usernames.  It's trivial at 1 million.  At 100 million, (and ~4GB of RAM which is what my laptop had), you have to get a bit neater.
10:43:10 <dsal> kuribas: Sure, but now do it in < O(n)
10:43:36 <[exa]> can we mmap()?
10:43:38 <kuribas> ah you want a hashmap
10:43:42 <dolio> What is n?
10:43:48 <dsal> [exa]: Yes, great start.  :)
10:43:53 <dsal> dolio: 100,000,000
10:44:06 <dsal> kuribas: I didn't use a hash map.  That'd *also* be huge.
10:44:07 <dolio> That answer doesn't make any sense.
10:44:32 <dolio> I guess n is the number of usernames?
10:44:36 <kuribas> sort the list, then do a binary search?
10:44:47 <[exa]> max length of the username is the only limiting factor
10:44:54 <dsal> dolio: 100 million usernames, about 900 MB.
10:44:57 <dsal> variable length usernames.
10:46:27 <dsal> It's a bit hard to binsearch lines out of an opaque blob, but it can be done (that's not exactly what I did), but I did a variation where I presorted the data with gnu sort and it's *incredibly* slow relative to my original code unless you throw enough LC_ vars at it.
10:46:28 <dolio> I don't think your problem is specified such that it can be completed in less than linear time.
10:46:34 <hyperisco> are we supposing every programmer should be a von Neumann machine expert or what
10:47:15 <dsal> Nah, the point is that in the original version, the trivial thing was significantly faster and smaller than the fancy thing people were trying to submit.
10:47:22 <dsal> You should at least know that pointers are larger than characters.
10:47:27 <kuribas> sdal: you can make an index of line start
10:47:29 <dsal> (or that they have size at all)
10:47:46 <dsal> kuribas: Yeah, that's what I did.  See, people here are good at things.  :)
10:48:07 <[exa]> dolio: that starts to seem to be the part were rust comes in :]
10:48:38 <dsal> The exact thing with similar memory footprints seems very hard in haskell.  Rust might be able to do it, but only because it's perfect in my head.
10:48:38 <dolio> [exa]: Huh?
10:49:40 <dsal> dolio: The lookup API should be better than linear.  It's expected to happen a lot.  Opening the file can be slower since it should only happen once.
10:49:51 <kuribas> dsal: or store them in a db
10:50:17 <dolio> Okay, I was right.
10:50:22 <[exa]> dsal: you could have specified that earlier :]
10:50:38 <hyperisco> a trie with pointers is probably faster to update
10:50:48 <hyperisco> maybe you didn't specify updating but that could have been an implicit assumption
10:51:01 <dsal> That's not generally how one does interviews.  But I don't have the exact text used.  Typically, people are expected to state assumptions / ask questions.
10:51:21 <dsal> So when you say, "can I use grep?"  I can respond, "sure, that's a way to do it, but that's O(n) for each lookup.  Can we make lookup faster?"
10:51:42 <hyperisco> so I'm talking with a client, or a less technical person
10:51:46 <kuribas> dsal: that feels like cheating on them.
10:51:47 <hyperisco> I'm not asking those sorts of questions
10:52:03 <hyperisco> I'm making 99% assumptions as to what they want based on the 1% of information they provide
10:52:11 <kuribas> if you don't state O(n), grep is perfectly fine.
10:52:32 <kuribas> Or at least make it clear you need to do the search repeatedly
10:52:36 <dsal> kuribas: If I give you an exact specification, I've nearly stated a solution.  If someone submits answers with ambiguity without asking questions, then that's a bad sign as well.
10:52:52 <dsal> Ironically, nobody suggested grep, so it never came up.
10:53:09 <hyperisco> I think I'd fail your test lol
10:53:21 <dsal> Only if you say, "GREP!  FINAL ANSWER!"
10:53:30 <hyperisco> if you set forth the criteria and I submit something satisfying, but the secret was that I was supposed to ask for more details…
10:53:41 <dsal> "Ok, but now can we..."  "FINAL ANSWER"
10:54:18 <[exa]> interviews are weird.
10:54:32 <dsal> That's literally how our interview training works.  Problem should start easy so someone feels like there's an answer within reach.  If they get there fast, we add complexity.  If they never get there, then... that's a useful interview.
10:55:26 <monochrom> Yes during interview you can always interactively clarify, even re-negotiate the problem.
10:55:33 <dsal> People who start out with really complex solutions do poorly.  And they present their test results with like, 5 usernames.  I'd run their code with 1 million and it'd take several minutes and all the RAM.
10:55:55 <dsal> TBH, I've challenged people in interviews where the best answer is, "That's stupid, I wouldn't do that."
10:56:08 <monochrom> And even after you have solved the clarified problem, they can always follow-up with "now if I change this part of the problem..."
10:56:57 <hyperisco> okay, but if you don't stipulate it has to run this fast with that amount of memory, or on this large an input, and then fail them when they don't meet that challenge…
10:57:01 <kuribas> would a bash script using the mysql command line tool be a valid solution?
10:57:02 <monochrom> People keep forgetting that an interview is a discussion, not a Starfleet Academy automarked multiple-choice exam.
10:57:45 <maerwald> interviews make sense if you value self-confidence over skill
10:58:02 <monochrom> Or at least a good interview. In which the potential employer wants to know how you think, and you want to know what they care.
10:58:14 <dsal> hyperisco: So, the original thing did say 1 million.  When you test your code with 5 and assume it scales to 1 million, that's a bad sign.  My objection was that one million doesn't sound like a particularly big number.
10:58:37 <hyperisco> dsal, okay, sorry, it was sounding like these extra requirements were being kept secret
10:58:50 <dsal> "should work" is not a big secret
11:00:18 <kuribas> I think interviews are completely random.
11:00:43 <kuribas> most interviews I did they thought I was a complete idiot.  Even for a haskell interview.
11:00:45 <dsal> I just directed the challenge back at myself at 100 million and found that it was easy to just mmap(2) some stuff, and combine qsort(3) and bsearch(3) with a slightly custom strcmp
11:01:18 <kuribas> dsal: did you try a RDBMs?
11:02:00 <dsal> Interviewing is hard in general.  At least at $company we pretend to have science around it.
11:02:20 <maerwald> kuribas: some ppl don't bother reading your github profile and then ask you questions like "do you know what fmap is?"
11:03:11 <kuribas> maerwald: those guys where using multiple languages, and they probably thought haskell can be only used for pure computations.
11:03:41 <kuribas> maerwald: The job was for go and haskell, so they used go for side-effects, and haskell for pure stuff :)
11:04:10 <hyperisco> how does that work… do you use Haskell through FFI?
11:04:25 <[exa]> dsal: what's the expected ratio of hits/misses? because I'm searching for bloom filters usecase for today :D
11:04:27 <dsal> kuribas: No rdbms.  I had a similar thing in production where I wrote an ocaml implementation of djb's cdb thing for a locally replicated DB that would scale pretty nicely.
11:04:59 <dsal> [exa]: so, that's actually an interesting point.  This project was my first real world use of a bloom filter!  But it wasn't in that part, it was in the part where I had to generate 100 million unique usernames.  heh
11:05:11 <kuribas> hyperisco: I don't know, I didn't get the job (fortunatly)
11:06:03 <dsal> kuribas: I'm now curious how sqlite in RAM works, though...
11:06:12 <hyperisco> I think it is impossible to use Haskell and not realise you can have side effects
11:06:49 <kuribas> hyperisco: they may believe side-effects are painful in haskell, I've heard that from other people.
11:07:10 <kuribas> I think side-effects are painful in other languages :)
11:07:31 <maerwald> effects are painful everywhere
11:07:37 <maerwald> including haskell
11:08:17 <monochrom> No no. Effects are joyful when you want them, painful when you don't want them.
11:08:58 <kuribas> like children
11:08:59 <maerwald> they are difficult to combine and reason about
11:09:06 <dsal> like children
11:10:05 <maerwald> those are all your own faults though 
11:11:03 <maerwald> effects are more like worms in your warm cheese... you keep eating, bc you don't wanna waste the cheese
11:11:33 <kuribas> I eat neither worms nor warm cheese...
11:17:19 * hackage composite-base 0.7.2.0 - Shared utilities for composite-* packages.  https://hackage.haskell.org/package/composite-base-0.7.2.0 (dridus)
11:18:19 * hackage composite-swagger 0.7.2.0, composite-opaleye 0.7.2.0, composite-ekg 0.7.2.0, composite-aeson-refined 0.7.2.0, composite-aeson 0.7.2.0 (dridus)
11:18:35 <monochrom> You all are making me re-think why we have effects at all. Actually more carefully: Regarding a job the computer does, why do we cut it into a math function and an effect.
11:19:06 <monochrom> Because for example you look at EE people's Moore machines and Mealy machines, they don't do that split.
11:21:06 <maerwald> that's the old question whether programming is maths
11:21:39 <maerwald> effects are behavior, not maths
11:22:01 <monochrom> They don't say their Moore and Mealy machines are State monads or RWST monads. They don't even say the Algol view of "side-effectful function that has a hidden state". They simply don't say "function" at all. It's an interactive machine.
11:23:37 <monochrom> And empirically they still are more successful than us in composable reasoning.
11:23:58 <maerwald> behavior doesn't compose well, I think
11:24:33 <maerwald> some would argue that's bc our "effects systems" are ad-hoc
11:24:36 <maerwald> but I'm not sure
11:25:29 <maerwald> composing anything bigger than small functions leads to behaviour analysis 
11:25:47 <maerwald> program1 | program2
11:27:18 <maerwald> program1 throws an error on kernel version 2.6.12 when the moon is behind pluto
11:27:40 <maerwald> gl expressing that in types
11:27:54 <monochrom> :)
11:29:15 <maerwald> I'm regretting switching to libarchive
11:29:26 <maerwald> since we talk about behaviour
11:29:29 <maerwald> https://github.com/libarchive/libarchive/issues/1381
11:29:30 <maerwald> boom
11:30:06 <maerwald> and it was just a single function I exchanged
11:31:43 <maerwald> where are you know, maths?
11:32:56 <MarcelineVQ> extentional equawhaaaaatity
11:33:48 <monochrom> In GHC, RankNTypes and Rank2Types enjoy extentional equality. >:)
11:34:10 <monochrom> err extensional!
11:43:49 * hackage git-annex 8.20200720 - manage files with git, without checking their contents into git  https://hackage.haskell.org/package/git-annex-8.20200720 (JoeyHess)
11:56:50 * hackage lambdabot 5.3.0.1 - Lambdabot is a development tool and advanced IRC bot  https://hackage.haskell.org/package/lambdabot-5.3.0.1 (BertramFelgenhauer)
11:57:26 <ezzieyguywuf> someone in here PM'd me a while back about some CAD stuff, including implicitcad as well as some other IRC channels I may be interested in
11:57:37 <ezzieyguywuf> ....are you still here? lol my comp crashed and I lost the irc channels
11:57:50 * hackage lambdabot-core 5.3.0.1 - Lambdabot core functionality  https://hackage.haskell.org/package/lambdabot-core-5.3.0.1 (BertramFelgenhauer)
12:02:03 <srk> ezzieyguywuf: #haskell-embedded and #distrap :) how's HaskellCAD progressing?
12:03:02 <ezzieyguywuf> srk: *mycad. Recently updated the parser to use megaparsec rather than my custom-made parsing stuff. still finalizing that branch before merging to master. I'm THIS close to being able to do something like `add line v1 v2` and it drawing a line in 3d in an opengl window!
12:03:10 <ezzieyguywuf> which would be a big milestone for the project :-P
12:03:39 <srk> nice! I've managed to clean-up GL UI thingie a bit, still not quite publishable
12:04:10 <ezzieyguywuf> srk: that's right, you're trying to add a GUI for implicitcad right?
12:04:18 <ezzieyguywuf> my GL stuff ended up.....mostly cleanish!
12:04:40 <srk> not a primary goal but that too 
12:04:45 <ezzieyguywuf> I know it can use some refactor/cleanup, but it's in a state right now that I think I should be able to grow/maintain it rather painlessly
12:04:55 <ezzieyguywuf> srk: you're using gpipe right?
12:05:11 <srk> yup, playing with it recently for 3D
12:05:32 <srk> UI is idenpendent of it, that uses nanovg-hs
12:06:38 <ezzieyguywuf> yea, I've bookarked nanovg-hs, I'm probably going to use that for buttons and stuff whenever the gui gets more advanced
12:06:42 <ezzieyguywuf> orrrr do the gui in qt...
12:06:49 * hackage hascard 0.1.1.0 - A TUI for reviewing notes using 'flashcards' written with markdown-like syntax.  https://hackage.haskell.org/package/hascard-0.1.1.0 (Yvee1)
12:56:12 <fog> so, i thought of another difference between pure and monadic folds
12:56:29 <fog> basically, you can "carry" () in a monadic fold
12:56:37 <fog> embeding results into the monad
12:56:57 <fog> while in a pure setting this would have, with () as the basecase, () as the result also
12:57:18 <fog> in the monad version, we have m () instead
12:58:15 <fog> and all of the `a' encountered while folding over the monadic foldable, are not simply consted away, but are imbedded into the monad 
12:58:30 <fog> :t foldr
12:58:31 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
12:58:34 <fog> :t const
12:58:35 <lambdabot> a -> b -> a
12:58:46 <fog> :t (flip const)
12:58:47 <lambdabot> b -> c -> c
12:59:10 <fog> % :t (flip (const @()))
12:59:11 <yahb> fog: b -> () -> ()
12:59:23 <fog> % :t foldr (flip (const @()))
12:59:23 <yahb> fog: Foldable t => () -> t b -> ()
12:59:32 <fog> % :t foldr (flip (const @())) ()
12:59:32 <yahb> fog: Foldable t => t b -> ()
12:59:51 <fog> so there should be a monadic varient of that, which results in `m ()' instead
13:00:02 <fog> (trying to derive the type of foldrM)
13:00:50 <fog> :t foldr
13:00:51 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
13:01:09 <fog> :t (undefined :: (a -> b -> b) -> b -> t a -> b)
13:01:10 <lambdabot> (a -> b -> b) -> b -> t a -> b
13:01:21 <fog> :t (undefined :: (a -> b -> b) -> b -> t a -> b) (flip (const @())) ()
13:01:23 <lambdabot> error:
13:01:23 <lambdabot>     Pattern syntax in expression context: const@()
13:01:23 <lambdabot>     Did you mean to enable TypeApplications?
13:01:27 <fog> % :t (undefined :: (a -> b -> b) -> b -> t a -> b) (flip (const @())) ()
13:01:28 <yahb> fog: t b -> ()
13:02:04 <fog> % :t (undefined :: Monad m => (a -> m (b -> b)) -> b -> t a -> b) (flip (return (const @()))) ()
13:02:04 <yahb> fog: t () -> ()
13:02:40 <fog> % :t (undefined :: Monad m => (a -> m (b -> b)) -> b -> t m a -> m b) (flip (return (const @()))) ()
13:02:41 <yahb> fog: t ((->) a) () -> a -> ()
13:02:49 <fog> rrrg
13:04:28 <fog> :t flip (return (const @()))
13:04:29 <lambdabot> error:
13:04:29 <lambdabot>     Pattern syntax in expression context: const@()
13:04:29 <lambdabot>     Did you mean to enable TypeApplications?
13:04:33 <fog> % :t flip (return (const @()))
13:04:34 <yahb> fog: () -> a -> b -> ()
13:06:00 <fog> % :t  (\a -> (return (flip (const @()) a)))
13:06:00 <yahb> fog: Monad m => b -> m (() -> ())
13:06:29 <fog> % :t (undefined :: Monad m => (a -> m (b -> b)) -> b -> t m a -> m b) (\a -> (return (flip (const @()) a))) ()
13:06:29 <yahb> fog: Monad m => t m b -> m ()
13:06:33 <fog> woop
13:07:04 <MarcelineVQ> use ghci for that please, or pm the bot if that's not an option somehow
13:07:14 <fog> im trying to show you something
13:07:17 <MarcelineVQ> Then share your finished example.
13:07:24 <fog> thats the finished example
13:07:45 <MarcelineVQ> lucky me, were all the others also your finished example?
13:07:45 <fog> i used yahb after i made a mistake
13:07:58 <fog> no they were the derivation i was trying to show you
13:08:11 <fog> except when i made an error, after which i used yahb
13:08:41 <dminuoso> 16 yahb invocations were the final example?
13:08:48 <dminuoso> Must be quite an elaborate thing.
13:08:51 <fog> oh, and when i didnt put a % before the versions that used type annotations, but i dont think ghci could have helped with that!
13:09:07 <fog> dminuouso: you understand what a derivation is?
13:09:19 <fog> im sorry i made an error omg!
13:13:43 <hseg> hi. trying to adapt iso-deriving to retraction-deriving (i.e. given a "subtype" s < t (viewed as i:s->t, r:t->s s.t. r.i=id) coherent with an instance C t, pull back the C t instance to a C s instance)
13:14:01 <hseg> (dually, this permits pushing forward instances to quotient types)
13:14:21 <hseg> having great success so far, except for one point
13:15:21 <hseg> have a tyfam Unit picking out the units of a ring, with obvious injection Unit r -> r. Would like to pull back an instance Action m r to Action m (Unit r)
13:16:43 <hseg> but ghc complains: http://ix.io/2sap
13:17:01 <fog> here is the version with the error redacted;
13:17:02 <fog> https://pastebin.com/raw/hfsHyzTv
13:17:42 <hseg> ... oh wait. i haven't defined an instance for Action m (a `As` b), have i?
13:17:54 <hseg> lemme check if that'll get ghc to shut up
13:19:24 <hseg> hrm. nope
13:19:40 <hseg> didn't change instance one bit
13:20:52 <hseg> ok, so replacing r with a concrete type that has a tyfam instance works
13:21:29 <hseg> ... note, Unit is a *datafam*, to avoid generativity issues
13:23:59 <hyiltiz> https://wiki.haskell.org/Tying_the_Knot#Migrated_from_the_old_wiki
13:24:08 <hseg> ok, so writing an explicit instance works
13:24:25 <hseg> but why is ghc rejecting my deriving via attempt?
13:24:29 <hyiltiz> Anyone care to explain the DList data type defined there, and how `go` manages to "tie the knot"?
13:24:45 <hyiltiz> Can't quite understand the wiki
13:28:22 <dolio> go isn't tying the knot. The `(first,last) = go last xs first` is.
13:28:47 <hseg> http://ix.io/2saq with full context
13:30:43 <hyiltiz> dolio: that is also what the wiki says; I can see symbolically how that is tyring the reverse ends
13:31:06 <hyiltiz> but I do not understand how the pointers "go off from the right and come back from the left" part
13:32:21 <dminuoso> hyiltiz: The important bit to understand is that you're building up nested data constructors.
13:34:13 <ski> hyiltiz : perhaps do some somewhat similar, but simpler, example, like `repMin :: Ord a => Tree a -> Tree a' (where `data Tree a = Leaf a | Branch (Tree a) (Tree a)') ?
13:35:00 <hyiltiz> The DList "looks like" a /\ structure, right, with left and right nodes and a "a" in between the two nodes? 
13:35:20 <ski> (replace all elements in a tree with the minimum element. in one pass of the tree. if you prefer, you could subtract the average from all elements instead (normalizing the tree))
13:37:25 <hyiltiz> ski: are u inviting me to do that excercise first? 
13:38:02 <hyiltiz> I can not sure how normalizing a binary tree and tying the knot is related, except they both use nested data structure
13:38:39 <ski> "in one pass of the tree"
13:39:46 <hyiltiz> that goes into functional memoizing isnt it?
13:40:04 <ski> dunno what you mean by that
13:40:25 <ski> but i wouldn't say this involves memoizing, really
13:40:31 <hyiltiz> hmm finding the min and replacing everything *should* take two passes tho :(
13:41:02 <hyiltiz> say, what if the min is the last leaf I inspect?
13:43:15 <hyiltiz> Hmm can I "cheat" by appending the tree into itself then going thru it "once" then return the appended tree?
13:43:16 <ski> one pass
13:43:33 <ski> dunno what you mean by that
13:43:50 <dolio> You should stop thinking in terms of eager evaluation.
13:44:05 <dolio> Because it won't work for reasoning about lazy evaluation.
13:45:20 <ski> have you seen `ones = 1 : ones',`repeat x = xs where xs = x : xs',`cycle xs = ys where ys = xs ++ ys',`fibs = 0 : 1 : zipWith (+) fibs (tail fibs)' ?
13:45:46 <maerwald> who can really reason about lazy evaluation? It's already hard for folds... for large parts of a program you may as well just give up
13:46:37 <maerwald> I've met only one person who could do the latter
13:46:38 <hyiltiz> ski: I meant this: Find rightmost and deepest leaf L of the tree T, create a branch there and put the value of L on the left and the tree itself to the right to create TT. Pass TT once by a) find min leaf from T part of the TT; b) normalize the 2nd part (after L) of TT; return this 2nd part
13:47:06 <hyiltiz> ski: yes ive seen those
13:48:05 <ski> so you have some familiarity with defining a non-function recursively, that is in terms of itself
13:48:10 <hyiltiz> I realize what I described is quite ugly and not what u r trying to hint me towards
13:48:49 <ski> you know how to make a function that returns (at least) the minimum, yes ?
13:49:26 <ski> so, make sure that you pass back this global minimum as a parameter of the same initial call
13:49:26 <hyiltiz> yeah (e.g. with a fold)
13:50:33 <hyiltiz> so it will be using fmap and fold?
13:50:44 <hyiltiz> I do not see how that would be a one pass still :(
13:50:45 <ski> direct recursion was what i had in mind
13:51:12 <ski> (by "fold", do you mean a custom `foldTree :: (a -> o) -> (o -> o -> o) -> (Tree a -> o)' ?)
13:51:43 <ski> you only have one function call that traverses the whole tree
13:53:15 <hyiltiz> but the function that returns global minimum also traverses it to compute it s.t. the comput*ed* values can *then* be used for replacement?
13:53:25 <hyiltiz> I can see I am thinking greedy evaluation
13:54:11 <ski> try it ?
13:54:46 <hyiltiz> I think I'd need to think about the thunk expansion to see how it becomes just one pass
13:54:50 <hyiltiz> sure
13:55:53 <NewToHaskell> So I made this simple function `addThree x y z = x + y + z`, if I call it with two arguments e.g. `addThree 3 4` I get an error saying No instance for (Show (Integer -> Integer)), can I make my function a part of the Show type class so I can print the result anyway?
13:56:10 <ski> hyiltiz : print which result ?
13:56:12 <ski> er
13:56:12 <NewToHaskell> deriving (Show) doesn't work.
13:56:18 <ski> NewToHaskell : print which result ?
13:57:02 <NewToHaskell> well print something, it says there is no instance for Show (Integer -> Integer)
13:57:20 <dminuoso> what should it print?
13:57:31 <Uniaika> NewToHaskell: first of all, do you understand the error you get?
13:57:36 <ski> you can write `instance Show (a -> b) where showsPrec _ _ = "<function>"'
13:57:38 <NewToHaskell> function: addThree x y z = x + y + z,  and the example was: addThree 3 4 if you can't see what I pasted.
13:58:00 <hseg> ski: is this use of laziness basically just a hidden cps transform?
13:58:06 <ski> hseg : no CPS
13:58:20 <ski> (and i dunno what you mean by "hidden" there)
13:58:33 <hyperisco> so if I want the prefix of a list that satisfies the predicate plus the last element that satisfies the predicate... explicit recursion?
13:58:56 <hseg> hidden=implicit
13:59:18 <Uniaika> hyperisco: takeWhile and takeWhileEnd?
13:59:44 <hyperisco> Uniaika, the list is infinite
13:59:50 <ski> hseg : one could make an explicitly staged version `replaceMin :: Ord a => Tree a -> (a,a -> Tree a)' .. but that's not CPS
14:00:05 <ski> (still dunno what "implicit CPS" would mean)
14:00:29 <koz_> hyperisco: If the list is infinite, how do you know what the last element that satisfies a predicate is?
14:00:40 <hyperisco> koz_, I know it when I see it
14:00:41 <koz_> Maybe there's infinitely many of them after the current one?
14:00:52 <koz_> Or there's another one a million entries later?
14:00:57 <Uniaika> uh
14:01:01 <Uniaika> hi koz_ :)
14:01:04 <ezzieyguywuf> hm, I have a list `assocs :: [(Text, MyData)]` and I'd like to do something like `parseFirst :: Parser MyData` that finds the first matching Text in the list and returns the associated MyData
14:01:07 <koz_> Uniaika: Wazzup?
14:01:12 <ezzieyguywuf> is this a job for fmap?
14:01:14 <hseg> i'm probably confusing things. lemme work through this a little more
14:01:24 <koz_> :t lookup
14:01:26 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
14:01:26 <hyperisco> koz_ it is takeWhile plus knowing the last element of the taken list
14:01:31 <koz_> ezzieyguywuf: ^
14:01:37 <Uniaika> koz_: fought a bit with PureScript, I've known better days
14:01:38 <Uniaika> you?
14:01:40 <koz_> Oh, of the _taken_ list.
14:01:56 <koz_> I think Gabriel's fancy composable folds library may make this easier to write.
14:02:03 <ezzieyguywuf> koz_: thanks!
14:02:34 <koz_> Uniaika: I'm fighting with... legacy code in a non-sensible language and a database schema from the ninth circle of Hell.
14:02:40 <koz_> So yeah, not the best either lol.
14:07:19 <hseg> ski: sorry, was a brain fart
14:07:28 <frdg> is there any guide to learning proper modularization and variable naming? I am worried that my code is going to become very complicated soon.
14:08:24 <ski> hseg : nw, just wondering what you meant
14:08:24 <superstar64> frdg, if there is i haven't heard of it, in any language
14:08:28 <koz_> frdg: There isn't a simple algorithm for this.
14:10:53 <frdg> is there anything wrong with having the majority of imports qualified? I am thinking this could help me out. I definetly am not at any tipping point but If I want to scale this application I will need to figure something out.
14:11:19 <acowley> frdg: That style is quite popular
14:12:26 <frdg> ok cool
14:14:22 <ski>   import qualified Control.Foo.Frob.Barf as CFFB (T,C,length,map,...)
14:18:36 * ski looks at NewToHaskell
14:19:18 <NewToHaskell> >:
14:20:05 <frdg> I feel like I heard that there is some controversy surrounding qualified imports. Is this accurate?
14:20:10 <NewToHaskell> Is it better to write code in the first example? Or should I always do the latter one? https://pastebin.com/vBsgQHCy
14:20:32 <monochrom> I never heard of that kind of controversy.
14:20:58 <frdg> ok
14:21:28 <ski> frdg : perhaps you're thinking about Henning-style
14:22:10 <monochrom> Henning-style has many facets, not just one.
14:22:42 <ski> NewToHaskell : i'd probably prefer the latter, but sometimes that blows up code a bit, so ..
14:22:54 <ski> i guess
14:23:09 <yilin> Is there anything I should watch out for when using `finally` in `Control.Exception`? I get a core dump with `stp_ap_p_ret` when using it.
14:24:15 <monochrom> That sounds like the cause has nothing to do with finally.
14:24:20 <NewToHaskell> Amazing
14:24:28 <nak> frdg: I've heard some some people create a module with all imports in it, and re-export functions with non-conflicting names to the rest of the project
14:25:12 <yilin> Possibly, but the core dump doesn't happen when I execute the offending action in the do block itself.
14:31:51 <dmwit> NewToHaskell: The latter style gives the compiler the power to warn you when new patterns appear and have not been considered.
14:31:52 <yilin> No, turns out I'm a twit who can't read.
14:32:27 <dmwit> With the former, if you refactor the data type, the code will silently capture the new constructors with the catch-all pattern, which may not behave as intended for the new constructors.
14:32:43 <dmwit> (For lists this seems like a very small risk, but for your own types less so.)
14:37:27 <ski> NewToHaskell : and the latter is easier to reason about, as the cases are not overlapping (except when they are, in this case, but then they give the same result, so it's okay, one can still reason about them as general true facts about the function)
14:38:50 <monochrom> These are very micro style things that don't worth more than 10 seconds to decide on.
14:38:54 <hyiltiz> ski: here is an implementation for repMin; even with ur hints, I couldnt make it *one pass* though https://termbin.com/m30y
14:40:31 <ski> hyiltiz : combine `findAMin' and `repAll' into a single function
14:41:17 <hseg> q: why does ghc dislike my deriving via call here? http://ix.io/2saq
14:41:17 <monochrom> I know the model solution for one-pass, but it has another cost.
14:41:47 <hseg> especially given that what i'd think is an equivalent declaration is accepted
14:41:56 <superstar64> i never really liked how haskell mixes the "try this, then that, then that" pattern match with the destructing a sum type pattern match
14:42:02 <monochrom> I conclude that seeking out the one-pass solution is good for curiosity but if you expect it to be efficient, it is not at all.
14:42:15 <superstar64> like, i feel those two things should be seperate
14:42:31 <hyiltiz> ski: hmm I thought about doing that but pieces didn't quite fit in. I'll keep trying then
14:43:10 <hyiltiz> I still do not see how this relates to the "tying the knot" example; hope I am not going to be profoundly disaaopinted :D
14:43:41 <hseg> monochrom: i can see it costing a large thunk that then gets squashed, anything i'm missing
14:43:44 <hseg> ?
14:44:02 <hyiltiz> oh wait findAMin and repAll is "combined" into a single function as repMin :D
14:44:05 <hseg> superstar64: what's wrong with it?
14:44:06 <monochrom> superstar64: If you separate them, what would your programming language semantics look like? For example when I deliberately write overlapping, redundant patterns?
14:44:17 <ski> one can force it, when going up
14:44:46 <superstar64> like, when does a pattern match require an `Eq`` constraint?
14:44:49 <monochrom> hseg: Yes, it builds a thunk as large as the input tree.
14:45:44 <hseg> right, and that can't be solved with strictness
14:46:57 <superstar64> `f 1 = 0; f x = 0;`, is what i would call an "if then" pattern match, and i think this should be different from deconstructing a sum type 
14:47:27 <hpc> numeric literal pattern matches are special
14:47:50 <hpc> you essentially have f x | x == 1 = 0
14:48:13 <superstar64> yea, pattern matches that require `Eq`
14:48:29 <hpc> well, at that point it's not a pattern match, it's a guard
14:49:53 <superstar64> monochrom, for my language, i plan to have only have unnamed product and unnamed sum types, and only allow newtype to be isomorphisms
14:49:56 <hpc> the other syntactic sugar that looks like pattern matching is f "a string" or f ["a", "list"]
14:50:03 <hpc> but those desugar to using (:)
14:50:14 <hpc> which is actual pattern matching
14:50:24 <monochrom> Hrm, interesting.
14:50:52 <superstar64> where sum type pattern matches, can only match every case of a sum type and nothing else
14:51:17 <hseg> superstar64: so basically named structural types?
14:51:23 <superstar64> yes
14:51:41 <koz_> Are there optics (specifically Prisms) for aeson's 'Value'?
14:51:45 <hseg> still don't see what that buys you
14:51:49 <superstar64> i feel that haskell's `newtype` is a wart
14:51:53 <monochrom> I feel that this language would not be very usable in practice. One of the reason Haskell mixes the two things you want to separate is to support, for example, nested patterns.
14:52:25 <monochrom> More detailedly, nested patterns that also have a few catch-all cases here and there.
14:52:44 <hseg> oh sure. newtype=data, the distinction b/w the two is an optimization that has no business lying in the surface syntax
14:52:45 <koz_> What do you know, phadej has me covered. :D
14:52:58 <monochrom> Further refinement: s/catch-all cases/local catch-all cases/
14:53:18 <hseg> superstar64: but that doesn't explain breaking up pattern matching
14:53:53 <superstar64> monochrom i was thinking i could 2 types of pattern matching, one for sum types and one for catch all style patterns
14:54:02 <monochrom> Yes there is a whole cottage industry of lensing and prisming into Value because people use Value wrong (IMO).
14:54:14 <monochrom> s/use/love to use/
14:54:27 <superstar64> where a catchall style match must have a catch all as it's last clause
14:54:59 <hseg> all that seems to buy you is an abdication from having to write a pattern totality checker
14:55:38 <superstar64> that sounds like a good thing to me
14:56:04 <hseg> ... oh. you want to distinguish between total matches (which are of form `split c1 c2 ... cn`) and partial matches (which are of form `case c1 c2 ... cn`)?
14:56:16 <hyiltiz> ski: https://termbin.com/0vw4 This still isn't one pass, and GHC is complaining about the scope of x
14:56:20 <superstar64> yes
14:57:01 <superstar64> where a catchall style match requires `Eq`, and a sum types style doesn't
14:57:18 <hseg> ok. but what if you want e.g. split (Just x:xs -> ..; Nothing:xs -> ...; [] -> ...) ?
14:57:28 <ski> hyiltiz : merge the pattern-matching
14:57:32 <monochrom> hyiltiz: ski means Ord a => Tree a -> b -> (Tree b, a).
14:57:55 <dolio> Pattern matching requiring Eq has nothing to do with catch-all cases.
14:58:05 <dolio> The example in question requires Eq because it's numeric matching.
14:58:28 <hyiltiz> Are you sure? ski's specification said Ord a => Tree a -> Tree a though...
14:58:33 <superstar64> hseg, i'm not too sure yet
14:58:36 <monochrom> such that, mathematically (but not implementationally), f tree x = (repAll tree x, findMin tree).
14:58:44 <superstar64> i don't have sum types in my language yet, so i have a lot of work to do
14:58:51 <ski> hyiltiz : i didn't say the main recursion would be of a function of that type
14:59:34 <monochrom> helper functions necessarily solve a much more general problem and take more parameters and have richer codomains.
14:59:52 <monochrom> lest you wouldn't be helper-functioning in the first place
15:00:01 <monochrom> err, s/lest/else/
15:00:22 <hseg> superstar64: sure. a quick and dirty rule would be to permit implicit fusion of nested splits
15:00:54 <monochrom> Recall that even with summing a list [Integer] -> Integer, we feel like making a helper function [Integer] -> Integer -> Integer
15:02:06 <hseg> superstar64: so e.g. split {(x:xs) -> case {Left l -> ..; _ -> ..}; [] -> ..} is unfusable, but if you replace the catchall by Right r you can fuse it into split { Left l:xs ->..; Right r:xs ->..; [] -> ..}
15:03:08 <superstar64> what do you mean by fusion?
15:03:28 <hseg> split { .. -> split} => split
15:04:00 <hseg> so e.g. splitting on (:)/[], we can then split the head on Left/Right 
15:04:06 <hseg> and write that as one split
15:04:08 <hyiltiz> monochrom: thx I'll give another try
15:04:26 <superstar64> i plan for sum types to compile to computed gotos and catchall pattern matches to compile to a series of `if then` statements
15:04:44 <hseg> or for a more salient example, i suppose this should be legal, right? split { [] -> ..; [x] -> ..; x:y:xs -> ..}
15:05:12 <superstar64> i can't say, i still planning how i'm going to implement this, i don't even have syntax yet
15:06:18 <hseg> sure. but i'm basically saying that based on your tastes, you seem to want to distinguish constructor splitting from case analysis
15:06:30 <superstar64> yes
15:06:49 <hseg> and so i'm saying that fusing split/split, case/case, and case/split looks ok
15:07:01 <hseg> but split/case doesn't look like it fuses
15:07:23 <hseg> ... or more accurately, the moment you try to fuse a case, you end up with a case overall
15:07:40 <hseg> so split/split=>split, split/case,case/split,case/case=>case
15:11:04 <superstar64> i don't want to allow my constructor matching to match anything more then just a single type
15:11:12 <superstar64> so nothing more complicated then `match (Left a) = ...; match (Right a) = ...;`
15:12:08 <hseg> right. i'm saying that in practice, you'll probably want to allow e.g. matc h{ (Left (Just a) ->; Left Nothing ->; Right a }
15:12:34 <hseg> .. that should be match {Left (Just a); Left Nothing; Right a}
15:12:51 <superstar64> when i implement it, i'll see how bad it is without it
15:12:55 <hseg> ok
15:13:01 <hseg> your language, your rules
15:13:36 <superstar64> https://github.com/Superstar64/aith i need to rewrite in haskell eventually
15:13:38 <hseg> but def see benefit of being able to statically jump to tag
15:14:26 <hseg> hrm. best of luck with it!
15:15:29 <hyiltiz> How about now? Is this /one pass/? I feel like I need to implement a traversal (like repAll) then use it to define both repAll and repMin, maybe using a const etc. https://termbin.com/ykqvl
15:16:23 <hseg> returning to on-topic conversation: while monad transformers basically give you a way to compose effects, is there some sort of parallel composition of effects, giving a semiring of effects?
15:16:41 <dsal> hyiltiz: if you want to know if it's one pass, you'd need to look at optimized core.
15:17:03 <hseg> eg Reader + Reader, Writer + Writer is doable for distinct effect types
15:17:36 <superstar64> parallelism kinda sounds like applicatives
15:17:41 <superstar64> maybe monad is too powerful
15:18:50 * hackage xcffib 0.10.0 - A cffi-based python binding for X  https://hackage.haskell.org/package/xcffib-0.10.0 (TychoAndersen)
15:19:15 <hseg> hrm. you definitely have this for applicatives -- type-level (&&&) and (.) give you the desired sum/product of effects iiuc
15:20:32 <hseg> needs more thought
15:21:49 <hseg> ok, final question for today: http://ix.io/2saq -- any reason the derivingVia fails, yet its inlining doesn't? 
15:24:48 <koz_> hseg: DerivingVia leans on coerce. Coerce and type families interact... not well.
15:25:19 <koz_> This is one reason that you can't DerivingVia your way into Unbox instances.
15:25:27 * koz_ looks wistfully.
15:26:22 <hseg> hrm. seems my counterexamples call for explicit cases of my tyfam
15:26:59 <hseg> eg have deriving via (Loc m r `As` Unit (Loc m r)) instance Eq (Unit (Loc m r)) 
15:28:02 <hseg> so it's just the general instance that gets stuck
15:29:28 <hseg> though problems with coerce+tyfam don't seem like they should affect coerce+datafam, right?
15:29:37 <hseg> since datafams are generative
15:29:49 <hseg> so why is ghc being so conservative here?
15:30:57 <koz_> Data families _are_ type families.
15:31:11 <koz_> They're not generative - two instances can look _very_ different.
15:31:25 <koz_> And coerce relies on representational equality.
15:32:23 <hseg> ah right. F Int and F Age can be completely different types
15:32:34 <koz_> That's exactly it.
15:32:59 <koz_> Coerce through representationally-equivalent types falls right the hell apart as soon as we can parameterize representations by type.
15:33:07 <koz_> Which is exactly what data families enable us to do.
15:33:10 <hseg> actually, *must be* completely different types
15:33:53 <koz_> So GHC's design for it is more or less 'nope out as soon as data families become involved'.
15:34:03 <hseg> hrm. but in this case, my use of type families is phantom
15:34:11 <koz_> It assumes it's nominal.
15:34:13 <hseg> wait, no it isn't
15:34:25 <koz_> I dunno if type (or data) families can have role annotations.
15:34:43 <hseg> i see a ticket for it, haven't read it yet
15:35:42 <hseg> hrm. but basically am trying to coerce Tagged a (F b) into F b and back
15:35:49 <hseg> why should that be ill-typed?
15:36:52 <koz_> It shouldn't, but you have a data family in play.
15:36:59 <koz_> So things get _super_ conservative.
15:39:17 <hseg> wait, so we don't even have coerce_refl :: F b -> F b ?
15:39:44 <hseg> bc that's the only axiom i can think of that'd be missing
15:40:03 <koz_> I dunno. Basically, my experience is 'coerce turns to custard around data families'.
15:40:11 <koz_> This is one more piece of evidence to that effect.
15:40:44 <hseg> :( ok thanks
15:41:19 <hseg> next up: breaking my unwitting circular class definition
15:41:49 <hseg> (basically accidentally tricked ghc into defining Unit N = ((), Unit N))
15:42:23 <hseg> which isn't that bad, except i then defined injU ((),u) = 1 * injU u
15:42:27 <hseg> chaos!
15:42:43 <hseg> (injU :: Unit r -> r)
16:02:03 <hyiltiz> dsal: I did learn reading Core from someone's slides, but I cannot wish to understand something this large https://termbin.com/n4f2
16:03:04 <hyiltiz> it "looks" like it is not single pass
16:04:53 <hyiltiz> monochrom: is repMin' what u meant? https://termbin.com/ge1s
16:06:26 <monochrom> No.
16:07:00 <monochrom> This is why I said "mathematically equals this answer, implementationally you have to code up cleverly".
16:07:29 <monochrom> In the same way mathematically split n xs = (take n xs, drop n xs), but no one really codes up split like that.
16:07:30 <nh> implementationally
16:09:10 <hyiltiz> I am not clever enough tho :(
16:10:13 <monochrom> Don't do function-call reuse, do copy-paste reuse.
16:10:47 <emmanuel`> is anyone here familiar with the groundhog libraryL?
16:10:49 <hyiltiz> I've read LYHGG, RWH and WYS48H but I guess I'll have to read more
16:11:04 <monochrom> "f oldtree x = (new tree like oldtree but with x, min of oldtree)" can clearly be done in one pass.
16:11:12 <hyiltiz> by copy-paste reuse, you mean, literally copy paste some more lines of code?
16:11:30 <monochrom> Yes and modify too
16:12:12 <hyiltiz> that is not "clear" to me though
16:12:18 <monochrom> OK
16:12:27 <hyiltiz> u still need to compute x
16:12:41 <monochrom> compute both the sum and the product of list xs.
16:13:18 <monochrom> If you re-use "sum" and "product" "(sum xs, product xs)", that's two passes.
16:13:33 <monochrom> You know how to do one pass if you don't call sum or product.
16:13:40 <hyiltiz> I tried using tuple, with something like (tree, subtree) -> (a->a->a) -> (tree, subtree) but couldn't get the pieces fit in to work
16:14:43 <hyiltiz> for that, I'd traverse the list, accumulating (sums, products)
16:15:34 <monochrom> So "f oldtree x" also walk the tree oncee and accumulate (newtree, min)
16:15:46 <hyiltiz> Something like foldr (+,*) (0,1) 
16:16:20 * hackage servant-rawm-client 1.0.0.1 - The client implementation of servant-rawm.  https://hackage.haskell.org/package/servant-rawm-client-1.0.0.1 (Krasjet)
16:17:13 <dsal> fold can do that.
16:17:19 * hackage servant-rawm-server 1.0.0.1, servant-rawm-docs 1.0.0.1 (Krasjet): https://qbin.io/yn-dash-ybil
16:17:28 <solonarv> you can't just write (+,*) like that, but if you write out the lambda that does work
16:29:21 <hyiltiz> this works :D foldr (\x p -> ((fst p)+x, (snd p)*x)) (0,1)
16:31:35 <hyiltiz> Yes I got a) how to traverse a list only once while folding two computations, but a) doesn't explain b) how to get the min (a global property of a tree/list) while "overwriting" it, and neither a) nor b) explains my initial question c) how did that "trying the knot" work in https://wiki.haskell.org/Tying_the_Knot#Migrated_from_the_old_wiki
16:32:38 <hyiltiz> I did enjoy the puzzles tho, but am just left puzzled/confused/curious after 2+ h of symbol packing/unpacking
16:34:24 <dmj`> :t foldl' (\(a,b) x -> (x + a, x * b)) (0,1)
16:34:25 <lambdabot> (Foldable t, Num a) => t a -> (a, a)
16:50:35 <koz_> :t uncurry
16:50:36 <lambdabot> (a -> b -> c) -> (a, b) -> c
17:00:19 * hackage git-annex 8.20200720.1 - manage files with git, without checking their contents into git  https://hackage.haskell.org/package/git-annex-8.20200720.1 (JoeyHess)
17:01:19 * hackage ipfs 1.1.0 - Access IPFS locally and remotely  https://hackage.haskell.org/package/ipfs-1.1.0 (dholms)
17:05:40 <koz_> > Just 1 <|> Nothing
17:05:42 <lambdabot>  Just 1
17:05:54 <koz_> > Nothing <|> Just 2
17:05:56 <lambdabot>  Just 2
17:06:03 <koz_> > Just 1 <|> Just 2
17:06:05 <lambdabot>  Just 1
17:06:17 <koz_> Woop woop,
17:06:55 <hyiltiz> > Just 2 <|> Just 1
17:06:57 <lambdabot>  Just 2
17:18:56 <koz_> If I have x :: Maybe a, y :: Maybe b, f :: a -> b -> Maybe c, is there a way I can stitch them together to get something of type 'Maybe c' without multiple >>=?
17:20:25 <koz_> I mean, I guess x >>= (\arg1 -> y >>= \arg2 -> f arg1 arg2) isn't too gory, but surely there has to be a nicer way?
17:20:49 <koz_> Or should I just use do-notation?
17:22:05 <solonarv> koz_: join (liftA2 f x y)
17:22:33 <koz_> solonarv: Nice.
17:31:12 <ski> koz_ : `infixl 4 <*>>; (<*>>) :: Monad m => m (a -> m b) -> (m a -> m b); mamb <*>> ma = join (mamb <*> ma)', then use `f <$> x <*>> y' (or `f <$> x <*> y <*>> z',`f <$> x <*> y <*> z <*>> w',&c.)
17:32:23 <koz_> ski: Ah, a super-splat.
17:32:56 <hyiltiz> join $ f <$> x <*> y
17:56:19 * hackage b9 1.1.1 - A tool and library for building virtual machine images.  https://hackage.haskell.org/package/b9-1.1.1 (SvenHeyll)
17:57:19 * hackage hall-symbols 0.1.0.5 - Symmetry operations generater of Hall Symbols  https://hackage.haskell.org/package/hall-symbols-0.1.0.5 (narumij)
18:11:19 * hackage libarchive 2.2.5.2 - Haskell interface to libarchive  https://hackage.haskell.org/package/libarchive-2.2.5.2 (vmchale)
18:38:49 * hackage hhp 0.0.3 - Happy Haskell Programming  https://hackage.haskell.org/package/hhp-0.0.3 (KazuYamamoto)
18:39:31 <ezzieyguywuf> oh boi. just learned about nand2tetris - I think I'm going to do it.
18:41:56 <dsal> Heh.  It's pretty neat.
18:42:08 <dsal> I didn't finish it, though.  It can get a little tedious.
18:45:04 <ezzieyguywuf> looks interesting enough to start, at least
18:45:53 <hyiltiz> > devils
18:45:56 <lambdabot>  error:
18:45:56 <lambdabot>      • Variable not in scope: devils
18:45:56 <lambdabot>      • Perhaps you meant one of these:
18:46:00 <hyiltiz> :lb devils
19:05:40 <ezzieyguywuf> is there a more concise way to do something like `do a; b <- c; d; pure b`?
19:07:46 <dolio> a *> c <* d
19:11:35 <ski> @type bracket_
19:11:37 <lambdabot> IO a -> IO b -> IO c -> IO c
19:11:37 <ski> @type bracket
19:11:38 <lambdabot> IO a -> (a -> IO b) -> (a -> IO c) -> IO c
19:11:48 <ezzieyguywuf> dolio: i had it that way at first
19:12:19 * hackage cl3 2.0.0.0 - Clifford Algebra of three dimensional space.  https://hackage.haskell.org/package/cl3-2.0.0.0 (nwaivio)
19:12:23 <ezzieyguywuf> but then `c` turned into a multi-line case statement and I couldn't find a good way to write it like that
19:12:38 <ezzieyguywuf> ski: this is not an IO though
19:13:54 <dolio> Give the case statement a name.
19:14:01 <ezzieyguywuf> ah
19:14:03 <ezzieyguywuf> nice one
19:20:50 * hackage cassava-conduit 0.6.0 - Conduit interface for cassava package  https://hackage.haskell.org/package/cassava-conduit-0.6.0 (domdere)
19:23:19 * hackage symmetry-operations-symbols 0.0.1.3 - Derivation of symbols and coordinate triplets Library  https://hackage.haskell.org/package/symmetry-operations-symbols-0.0.1.3 (narumij)
19:24:18 * hackage cl3-linear-interface 2.0.0.0 - Interface to/from Cl3 and Linear.  https://hackage.haskell.org/package/cl3-linear-interface-2.0.0.0 (nwaivio)
19:31:19 * hackage cl3-hmatrix-interface 2.0.0.0 - Interface to/from Cl3 and HMatrix.  https://hackage.haskell.org/package/cl3-hmatrix-interface-2.0.0.0 (nwaivio)
19:47:02 <ski> ezzieyguywuf : ok
20:43:33 <hololeap> anyone know of any packages that give ISO/IEC 80000 units?
20:44:52 <hololeap> specifically the multiples of bytes like KiB, MiB, etc
20:53:44 <dmwit> ezzieyguywuf: Or don't name it: `a *> c <* do e; f; case g of ...` works fine.
20:54:04 <infinisil> hololeap: Looks like https://hackage.haskell.org/package/prefix-units should work
20:54:21 <dmwit> `a *> c <* case e of ...` also works fine, depending on exactly what "multiline case statement" means.
20:54:40 <dolio> That doesn't help if c is the big thing.
20:54:59 <dmwit> Ooooh, I completely misread! Okay, yeah, ignore me.
20:55:01 <dmwit> whoops
21:04:35 <dolio> If you use braces can you do `a *> case ... of { ... } <* d`? Not that I'd reccomend it.
21:07:33 <bradparker> It'd be handy if `between` was in base I suppose: http://hackage.haskell.org/package/parsers-0.12.10/docs/Text-Parser-Combinators.html#v:between. `between a d $ case b of ...`
21:07:58 <dsal> Why base?
21:09:11 <bradparker> I dunno, it feels very generic I suppose. Like `forever` http://hackage.haskell.org/package/base-4.14.0.0/docs/Control-Monad.html#v:forever
21:09:52 <glguy> The nice thing about that one is that it's so simple that you might as well just define it locally if you need it
21:09:52 <dsal> `between open close p = open *> p <* close`
21:10:50 * hackage matrix-as-xyz 0.1.1.2 - Read and Display representation of matrix like "x,y,z"  https://hackage.haskell.org/package/matrix-as-xyz-0.1.1.2 (narumij)
21:10:59 <bradparker> That's true, I think I've done that a few times. I was thinking it might have helped with the above query.
21:13:30 <gaussian> `(open *>) . (<* close) $ case .. of ..` maybe if you don't feel like writing a helper function
21:14:08 <glguy> If you get the feeling to write it like that ^ write the helper function
21:15:40 <dolio> Or name the middle, it's not that bad.
21:58:45 <hyiltiz> For http://www.paulgraham.com/accgen.html, what's wrong with "foo n = bar where bar i = n + i"?
21:59:02 <hyiltiz> It is "not accumulater but plus" since it is returning a new number?
22:00:15 <c_wraith> It's a weird, weird problem that doesn't match basically anything in the real world.
22:00:38 <c_wraith> Note that you have to mutate the stored value according to his rules.
22:01:03 <c_wraith> (In Haskell, you'd just pass the value around.  Why bother with all that encapsulation?)
22:02:59 <hyiltiz> gotcha; one can claim a case saying if that encapsulated value is a huge data structure (some business logic represented as a tree)
22:03:24 <c_wraith> There's still little reason to encapsulate it in a mutable wrapper
22:03:27 <hyiltiz> then creating a new tree just to increment is much expensive than direct modification
22:03:46 <c_wraith> Unless modifications to it need to be visible between threads.
22:03:52 <c_wraith> In which case, sure.  IORef or MVar it.
22:04:24 <ja> i am on ghc 8.8.4 and i just noticed there is a show instance for a function of type [Word64] -> Word64 -> Int -> ([[(Word64, Word64)]], [Maybe (Word64, Word64)])    where could this instance be? i don't have :instances from 8.10...
22:04:51 <c_wraith> wait, what's 8.10 got to do with anything?
22:05:00 <ja> because it has :instances
22:05:02 <c_wraith> also, use :info Show 
22:05:32 <c_wraith> or  :into (->)
22:05:36 <c_wraith> ... *info
22:08:41 <ja> hmm i looked it through but i still don't get it...
22:08:54 <ja> aaah maybe it is from smallcheck?
22:09:00 <c_wraith> that sounds plausible
22:09:18 <ja> oh my, that is so weird, that is not even one of my direct dependencies
22:09:31 <c_wraith> https://hackage.haskell.org/package/smallcheck-1.2.0/docs/Test-SmallCheck-Series.html#v:-36-fShow-45--62-
22:09:50 <ja> almost all my imports are listing the names, i must have forgotten one
22:10:14 <c_wraith> that's the way instances work!  Though something depending on smallcheck for its library code is weird.  Or it means the test code is intermixed with the library code.
22:10:47 <ja> oh yeah i have everything in one giant 1500 line module :O i submit myself for crucifixion
22:11:21 <c_wraith> 1500 lines isn't terrible.  It happens sometimes.  But mixing tests in can have weird consequences.  Like that.  :P
22:14:13 <ja> it is actually a pleasant surprise, i never even thought about thinking of this as a tree...
22:21:00 <ja> the magic of typeclasses...
22:40:49 * hackage vulkan 3.6.2 - Bindings to the Vulkan graphics API.  https://hackage.haskell.org/package/vulkan-3.6.2 (jophish)
23:05:20 * hackage matrix-as-xyz 0.1.1.3 - Read and Display representation of matrix like "x,y,z"  https://hackage.haskell.org/package/matrix-as-xyz-0.1.1.3 (narumij)
23:09:12 <_xor> Anyone have any tips on how to solve a ghcup install problem?  I'm trying to install 8.10.1 via ghcup on FreeBSD, which worked fine a week ago.  Now it's throwning an error regarding gmake.
23:09:20 <_xor> I add -v, but it's not being super specific.
23:11:56 <_xor> Nevermind, making progress. Added --keep=error and examined the build dir.
23:45:03 <liiae> what "Box a is isomorphic to a" mean?
23:45:28 <liiae> type Box a = forall b. (a -> b) -> b
23:45:36 <liiae> box :: a -> Box a
23:45:46 <liiae> unbox :: Box a -> a
23:46:37 <int-e> satisfying box . unbox = id, unbox . box = id.
23:47:00 <liiae> int-e: but Box a and a both are types
23:47:14 <liiae> int-e: box and unbox are values
23:47:38 <int-e> box and unbox are maps between those types
23:48:21 <liiae> int-e: sorry, I don't get it
23:49:12 <_xor> Is --with-system-libffi gone from the configure script for 8.10.1?
23:49:35 <int-e> liiae: I don't know what you're missing. box and unbox are not arbtirary, we have to find their implementations.
23:50:11 <liiae> box a f = f a
23:50:14 <int-e> Which isn't hard. box a = \f -> f a, unbox f = f id.
23:50:16 <liiae> unbox f = f id
23:50:36 <liiae> rebox :: Box a -> Box a
23:50:40 <liiae> rebox f = box (unbox f)
23:52:46 <liiae> int-e: fromJust . return = id?
23:52:54 <liiae> in Maybe context
23:53:16 <liiae> :t fromJust
23:53:17 <lambdabot> Maybe a -> a
23:53:21 <Axman6> isomorphic means they are equivalent - if you have a 
23:53:24 <liiae> :t return
23:53:25 <lambdabot> Monad m => a -> m a
23:53:53 <Axman6> box a you can get an a, nd if you have an a you can get a Box a. there is a one to one mapping between every Box a to an a, and from every a to a Box a
23:54:31 <Axman6> Maybe a is not ispmorphic to a, because there is no function which has type Maybe a -> a which is total
23:55:42 <Axman6> if there was, then it would be possible to construct a value of any type out of thin air - myMaghicFunction :: Maybe a -> a; iNeedAnA :: a;  iNeedAnA = myMagicFunction Nothing
