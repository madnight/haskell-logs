01:11:21 <kuribas> is there an equivalent function for pattern matching in a list comprehension?  like [x | Pattern x <- values]?
01:11:51 <dminuoso> % :t guard
01:11:52 <yahb> dminuoso: Alternative f => Bool -> f ()
01:11:55 <dminuoso> Mmm
01:12:09 <dminuoso> kuribas: well do-notation with pattern matching..
01:12:12 <kuribas> mapMaybe (\case Pattern x -> Just x; _ -> Nothing) would work
01:12:19 <kuribas> it's more verbose
01:12:24 <dminuoso> kuribas: optics.
01:12:35 <kuribas> a prisma?
01:12:38 <dminuoso> Yeah
01:13:24 <dminuoso> % [Left 'a', Right 1, Left 'b', Right 2, Left 'c'] ^.. each . _Left
01:13:24 <yahb> dminuoso: "abc"
01:15:04 <dminuoso> kuribas: Or just.. do/list comprehension. :)
01:16:20 <kuribas> list comprehensions are nice, but I don't like the idea of "magick", something which only works under some syntax.
01:16:49 <kuribas> because it isn't first class
01:17:20 <dminuoso> @undo do { Foo f <- g ; pure f }
01:17:20 <lambdabot> g >>= \ a -> case a of { Foo f -> pure f; _ -> fail ""}
01:17:28 <dminuoso> kuribas: It's not "magick" and "only works under some syntax"
01:17:41 <dminuoso> You're just hiding the boilerplate behind desugaring
01:18:26 <kuribas> fail has it problems too
01:18:29 <dminuoso> And in case of optics/lens, you're hiding it behind the elaborate machinery that drives lens..
01:18:41 <dminuoso> kuribas: for [] it doesn't matter, does it? :)
01:18:53 <kuribas> as long as fail works, no.
01:19:08 <dminuoso> I just used undo because I dont know whether we have some unlistcomp command.
01:19:14 <dminuoso> It should be roughly equivalent though
01:19:39 <dminuoso> (havent read the report about how list-comprehensions are desugared, but it's likely similar)
01:19:42 <kuribas> yeah, it should be the same
01:24:26 <phadej> kuribas: [x | Pattern x <- values] just works, doesn't it?
01:30:21 <danysdragons> nickserv register MegasChimo39! michael.hamel80@gmail.com
01:31:28 <dminuoso> MegasChimo?
01:31:30 * dminuoso chuckles
01:31:45 <danysdragons> Whoops
01:32:20 <dminuoso> Oh yes. Quitting your IRC client unleaks leaked password! :)
01:33:23 <MarcelineVQ> worse about the email, passswords should be unique anyway (one would hope)
01:34:12 <[exa]> yeah, there's no point at all trying that password on the gmail account right
01:34:20 <MarcelineVQ> noooone
01:36:28 <[exa]> still /quitting gives you a great tranquility, helping to focus on all the password changes you might need to do in the unlikely case of passwords being shared
01:36:58 <Tordek> I got spooked when I read "leaked password" because I was typing my gpg pass and the window lost focus
01:37:09 <Tordek> but joke's on you because I forgot the password anyway
01:37:15 <Tordek> *sigh*
02:33:15 <kuribas> phadej: it does, but it's not first class.
02:33:30 <kuribas> phadej: I cannot accept "Pattern x" in a function, or compose it.
02:33:52 <phadej> then indeed, you are looking for prisms
02:34:09 <phadej> or a -> Maybe b functions
02:37:09 <kuribas> or genericLens: https://hackage.haskell.org/package/generic-lens-2.0.0.0/docs/Data-Generics-Sum-Any.html
02:39:05 <kuribas> this one more likely: https://hackage.haskell.org/package/generic-lens-2.0.0.0/docs/Data-Generics-Sum-Any.html
02:42:43 <fog> someone was asking about simulated annealing yesterday, following discussions on probabilistic haskell, as pertains to sampling vs optimisation (the question of why monte carlo often outperforms stochastic gradient)
02:43:32 <fog> i described it as "heating up the distribution, to smooth out local minima, transferring the metropolis-hastings accept reject rule into a modification on the distribution"
02:44:23 <fog> this might not be the best way to describe it, and instead Rubins work on ABC (approximate bayesian inference) might be better
02:45:01 <fog> bascially, then we see the accept reject stage, metropolis hastings, as essentially encoding bayes rule 
02:45:41 <fog> sampling parameters from the prior, and rejecting those which do not result in simulations which match observables
02:46:26 <fog> then, we can find ways to "modify the unknown distribution" based on similar and more advanced versions of metropolis hastings
02:47:12 <fog> i *guess* thats how simulated annealing works, but i need to read more about it as compared to modern metropolis hastings rules
02:50:51 <MarcelineVQ> fog: Pretend, and it's super unlikely I know, but just pretend that when you're talking to a room or whatever it is you're doing just now that the people you're talking to don't know the jargon you've appropriated. In this super unlikely pretend situation you are liteally saying nothing.
02:55:12 <maerwald> those read like lecture notes
02:55:32 <maerwald> but what was the lecture?
02:56:23 <MarcelineVQ> And you my find yourself, Living in a shotgun shack
03:02:18 * hackage morley 1.5.0 - Developer tools for the Michelson Language  https://hackage.haskell.org/package/morley-1.5.0 (gromak)
03:04:49 * hackage lorentz 0.5.0 - EDSL for the Michelson Language  https://hackage.haskell.org/package/lorentz-0.5.0 (gromak)
03:09:18 * hackage reanimate-svg 0.10.0.0 - SVG file loader and serializer  https://hackage.haskell.org/package/reanimate-svg-0.10.0.0 (DavidHimmelstrup)
03:36:19 * hackage transient-universe 0.6.0.0 - fully composable remote execution for the creation of distributed systems  https://hackage.haskell.org/package/transient-universe-0.6.0.0 (AlbertoCorona)
03:39:18 * hackage core-text 0.2.3.5 - A rope type based on a finger tree over UTF-8 fragments  https://hackage.haskell.org/package/core-text-0.2.3.5 (AndrewCowie)
04:51:29 <thblt> Is there an ETA on a print version of HPFFP?
04:53:23 <int-e> @where hpffp
04:53:23 <lambdabot> "Haskell Programming: from first principles - Pure functional programming without fear or frustration" by Chistopher Allen (bitemyapp),Julie Moronuki at <http://haskellbook.com/>,#haskell-beginners
04:54:18 <int-e> . o O ( I got as close as "Haskell Programming for Functional Programmers" ;-) )
04:54:49 <merijn> Is there even a plan to make a print version?
04:54:51 <thblt> Err sorry :)
04:54:59 <merijn> I thought that wasn't planned?
04:55:12 <thblt> merijn: Yes, third entry of the FAQ.
04:55:19 <thblt> “We're working on it!”
04:55:28 <merijn> Right, I don't think that's changed in...5 years or something
04:55:47 <merijn> The book is also like 1100+ pages which is why it's incredibly to turn into print
04:55:53 <merijn> So...I wouldn't hold my breath
04:57:52 <thblt> Yeah, thought so.
04:57:55 <thblt> Thanks 
05:09:28 <sshine> int-e, I got as close as "High-Performance F... Functional Programming" :-P
05:10:10 <int-e> sshine: that too :)
05:13:58 <buggymcbugfix> Getting a parse error here that stumps me:  https://www.irccloud.com/pastebin/GttuQzCK/
05:14:39 <buggymcbugfix> ugh never mind
05:14:55 <merijn> buggymcbugfix: You need unboxed tuples or whatever for that too :)
05:14:55 <buggymcbugfix> -XUnboxedTuples
05:15:03 <buggymcbugfix> haha yeah
05:16:16 <merijn> Also, generating -XMagicHash/-XUnboxedTuples code with TH sounds like an adventure :p
05:19:07 <buggymcbugfix> yep, I'm benchmarking stuff for my Summer of Haskell project. I guess I should write a blog post about this at some point :/
05:20:38 <merijn> buggymcbugfix: If you're investigating performance, are you aware of our lord and saviour, speedscope.app? ;)
05:31:54 <buggymcbugfix> merijn: no, thanks for the ptr
05:32:17 <merijn> buggymcbugfix: https://mpickering.github.io/posts/2019-11-07-hs-speedscope.html
05:34:12 <brj> I'm trying to read a file line-by-line and I don't want any runtime errors so I wrapped the filename argument into a Maybe. However I get a type mismatch between IO and []. Code -  https://gist.github.com/iambrj/ca41060b4e3b8839754b648b75d07bb6. Any help would be appreciated.
05:36:41 <tomsmeding> 'filelines <-', and 'return []' ?
05:38:58 <brj> tomsmeding: could you please elaborate? I don't understand what you mean, I'm relatively new to haskell
05:39:30 <tomjaguarpaw> Instead of "let filelines" write "filelines <-" and instead of "[]" write "return []"
05:39:37 <tomsmeding> sorry yes that :p
05:40:06 <tomjaguarpaw> Always happy to paraphrase another Tom
05:40:25 <tomsmeding> \o\
05:41:14 <brj> Ah thanks! Now I shall try to reason about the types
05:42:54 <tomsmeding> working out small examples like this explicitly, and understanding why the types are as they are, is quite instructive, I think
05:43:06 <thblt> I'm surprised that the binary function in Semigroup is <> but mappend in Monoid.  Does it mean that I can lawfully define a Monoid where mappend is not the same as <>?  Say, newtype Int as a Semigroup under substraction and a Monoid under addition?
05:43:20 <thblt> This sounds horrible but I can't find a law in the doc that prevents it.
05:43:21 <tomsmeding> not _lawfully_, no :)
05:43:56 <thblt> tomsmeding: That's what I hoped, but is this restriction stated somewhere?
05:43:58 <tomsmeding> > Should it be implemented manually, since mappend is a synonym for (<>), it is expected that the two functions are defined the same way.
05:43:59 <lambdabot>  <hint>:1:34: error: parse error on input ‘,’
05:44:05 <tomsmeding> sorry lambdabot
05:44:20 <merijn> tomsmeding: Note that that doesn't mention lawfulness at all
05:44:23 <tomsmeding> mappend is supposed to be the same as <> always, it's not really a mathematical thing
05:44:52 <tomsmeding> the mathematical operations are <> and mempty, and due to historical legacy, Haskell has two synonyms for the <> operation
05:45:34 <tomsmeding> also note that laws are only documentation in Haskell :p
05:45:52 <merijn> thblt: Semigroup wasn't in base and thus not a superclass of Monoid for a long time
05:46:18 <merijn> thblt: Moving Semigroup into base and making it a superclass is fairly recent, so this split is for historical reasons
05:46:55 <merijn> thblt: See also the mappend docs which say it will be removed in the future
05:48:18 <thblt> merijn: got it! “it is expected that the two functions are defined the same way.”
05:48:30 <thblt> Thank you both.
05:50:50 <L29Ah> https://github.com/fpco/inline-c/issues/115#issuecomment-665013011 why does unsafePerformIO make things so much slower on the threaded runtime?
05:52:20 <ADG1089_> a little flex for my new vscode setup: https://imgur.com/a/HYV6DMJ
05:52:35 <tomsmeding> L29Ah: perhaps see the docs for unsafeDupablePerformIO: https://hackage.haskell.org/package/base-4.14.0.0/docs/System-IO-Unsafe.html#v:unsafeDupablePerformIO
05:52:37 <merijn> L29Ah: That depends entirely how inline-c generates the wrapper code for blocks and how it calls that
05:52:51 <tomsmeding> not suggesting that you should use that, but unsafePerformIO does some checks
05:52:56 <merijn> L29Ah: You are saying "unsafePerformIO makes things slower"
05:53:04 <merijn> L29Ah: But your data does not support that conclusion
05:53:15 <merijn> Because you are not comparing the same code
05:53:42 <merijn> L29Ah: C.pure almost certainly uses unsafePerformIO directly or indirectly via the FFI
05:54:03 <merijn> L29Ah: So what your data *actually* shows is "C.pure is faster than C.block"
05:54:06 <L29Ah> merijn: cublockfun and cublockiofun is the same code
05:54:46 <L29Ah> tomsmeding: thanks
05:56:35 <L29Ah> yeah with unsafeDupablePerformIO it becomes much faster (though still slower than pure Haskell)
05:56:58 <merijn> cublockfun and cioblockiofun have comparable performance, though
05:57:40 <merijn> Also, using unsafeDupablePerformIO is a great way to create impossible to figure out bugs unless you know what you're doing
05:59:06 <L29Ah> merijn: b-but i'm writing a pure C code!
05:59:18 <int-e> unsafePerformIO uses noDuplicate# which all but suspends the current thread; it is rather expensive.
05:59:20 <L29Ah> that only does math and array lookup
06:00:32 <L29Ah> i wonder if it will bite me if i take multiple foreign ptrs from a haskell array in multiple threads at the same time
06:01:48 <int-e> L29Ah: as long as you only read from memory you'll be fine. mutation or any kind of locking is bound to screw you up.
06:02:39 <int-e> (in the nasty sporadic way that may go unnoticed for ages)
06:03:53 <tomjaguarpaw> c
06:05:41 <L29Ah> benchmark: <<loop>>
06:05:42 <L29Ah> Benchmark benchmark: ERROR
06:05:43 <L29Ah> okay, unsafeDupablePerformIO have bitten my foot
06:06:41 <L29Ah> but why? the code doesn't modify anything except its local variables: https://dpaste.com/GULZJ9UUS
06:06:52 <L29Ah> ouch
06:07:01 <L29Ah> https://dpaste.com/2AEKN59U9
06:09:20 <L29Ah> a simpler chunk explodes too: https://dpaste.com/45QNDVRNG
06:09:36 <Orbstheorem> Hi o/ Is there anyway I could get GeneralizedNewtypeDeriving-style behaviour on Associated type instances? Or anyway to have the associated type reuse a previously-existing type? minimal example: https://paste.gnugen.ch/raw/lzIF
06:11:13 <int-e> L29Ah: withCArray?!
06:11:33 <L29Ah> int-e: https://hackage.haskell.org/package/carray-0.1.6.8/docs/Data-Array-CArray.html
06:11:54 <int-e> L29Ah: I guess that only touches and is fine... but it also matters a lot what happens inside the CU thing.
06:15:17 <int-e> I would guess that the <<loop>> means that a lock was taken and not released, something that unsafeDupablePerformIO can actually accomplish.
06:15:50 <int-e> With strong emphasis on "guess" though.
06:36:08 <int-e> L29Ah: This is a bit odd actually. Did you use unsafeDupablePerformIO on the safe import as well? I imagine that will cause trouble, but as far as I can see, the unsafe import should be fine.
06:37:50 <int-e> (I'm writing "import" because inline-c internally generates an extra C file with the given code, and a foreign import (safe/unsafe depending on which C.Inline module you use) to be called.)
06:47:15 <dminuoso> merijn: My latest discovery: optics + prettyprinter is an amazing combination! :)
06:48:45 <L29Ah> int-e: no, i didn't touch the safe import as it's slow
06:56:21 <merijn> int-e: <<loop>> is when GHC tries to enter a blackholed thunk
06:59:00 <Cheery> Once I have a type function, how do I use them?
06:59:36 <merijn> Cheery: What do you mean? A type family?
07:00:06 <Cheery> well say I got type family Foo x
07:00:16 <Cheery> then I do a function something -> Foo x
07:00:23 <Cheery> how do I implement this?
07:00:24 <int-e> merijn: I knew that (or reminded myself of that in the meantime, at least). I don't know why that is happening here. It could even be a weird interaction with criterion (which has some trickery to reevaluate things that I've never fully investigated).
07:01:20 <merijn> Cheery: Well, you just write it. Of course, that assumes you have some form of way of getting the right result type which will probably require something like GADTs or something
07:01:45 <merijn> Cheery: Do you have an example of what you're trying to do?
07:02:38 <Cheery> I kind of want to showcase this, if it's possible to do with this thing.
07:02:52 <Cheery> I want to create a structure that relates Js types to haskell types
07:02:56 <Cheery> then translates between them.
07:03:07 <Cheery> Mainly FFI interest.
07:03:18 <Cheery> maybe JSON schema as well.
07:04:13 <merijn> Cheery: I have an example combining a heterogeneous list using GADTs and a type family to do stuff with it here: https://gist.github.com/merijn/dc00bc7cebd6df012c5e#file-gistfile1-hs-L29-L35
07:05:07 <merijn> Cheery: It's not very useful in an FFI context I think, though. Since if you get a JS value via FFI you don't know what type it is beyond "some JS value" so you can't really apply a type family to anything
07:09:39 <dminuoso> Sigh GHC. Why cant I have cicular module imports.
07:10:16 <dminuoso> I keep structuring packages to avoid circular imports, and its annoying. It's very counter intuitive when all of haskell makes things like mutually recursive bindings possible.
07:11:19 <merijn> dminuoso: hs-boot files! Although I can never get them to work so I act as if they don't exist :p
07:13:05 <Cheery> *TypeFam> decode (YabList YabDouble) (VArray [VNum 3.4, VNum 5.4, VNum 6.2])
07:13:12 <Cheery> ok.. next encode.
07:14:18 <thblt> Mathish slang question: an “endomorphism”, in Haskell, is a function mapping a type to itself, a -> a, right?
07:14:47 <Cheery> encode (YabList YabDouble) [1.2, 4, 2.1] = VArray [VNum 1.2,VNum 4.0,VNum 2.1]
07:15:08 <Cheery> thblt: it depends which category
07:15:41 <Cheery> but yeah, if you got category where non-total functions are morphisms, yup.
07:16:11 <thblt> Cheery: thanks.
07:16:35 <Cheery> just need to check if it forms a category though.. but I'd guess it has identity, associativity works, etc..
07:17:05 <Cheery> not certain
07:17:34 <Cheery> but there's a category corresponding to STLC
07:17:55 <Cheery> in that category endomorphism is indeed a function from type to itself.
07:30:12 <Cheery> merijn: I did it.
07:35:14 <Cheery> https://gist.github.com/cheery/1e1eb5dcdfbda7bb77dd9018bf8a510e
07:36:06 <Cheery> Does purescript support this?
07:56:26 <pmwhite> Question/concern about Scotty: Using `jsonData` and `parseJSON` to validate the input data to my endpoint causes a 500 error when the client sends a malformed request. I can probably work around it by not using the built-in error handling of Scotty, but that feels dumb.
08:00:55 <pmwhite> Ideally, I would be able to control what response code gets sent in the various failure scenarios.
08:01:19 <dolio> Cheery: I don't think purescript has type families.
08:07:22 <deech> I'm running into an issue where on Linux GHC 8.10 allows absolute paths to the '-l' option but not on macos. eg, 'ghc -shared -dynamic -l/an/absolute/path/lib.a' throws a linker error on macos. Anyone see this before?
08:07:27 <pmwhite> Oh, I guess there is a rescue function.
08:10:01 <merijn> deech: Full path to static libraries should just be passed as arguments, not via -l (should work on linux too)
08:11:23 <deech> I'm aware, Cabal tacks on the '-l' unfortunately. I could extract the directory part into `extraLibDirs` but I was wondering why there was a difference in platforms.
08:12:06 <Cheery> dolio: yeah, and I read up they haven't figured out why they might like to have it.
08:14:50 <merijn> deech: Because GHC doesn't do linking, it calls the system linker
08:15:04 <merijn> deech: Which will do whatever the system linker does, portable or not
08:15:19 <merijn> And the macOS and linux linkers are very different
08:15:39 <merijn> Hell, linux' linkers are very different, depending on whether they're shipping the old ld, gold, or something else
08:16:33 <deech> merijn: I don't know much about linkers, is '-L/an/absolute/path lib.a' portable?
08:17:18 <merijn> The most portable way to link /an/absolute/path/libfoo.a would be via "-L/an/absolute/path -lfoo"
08:17:36 <merijn> That should work on any platform anyone actually cares about
08:18:09 <deech> Is there a way to make it favor 'libfoo.a' instead of 'libfoo.so'?
08:18:36 <merijn> eh, then we dive deep into linker arcana and that never ends happy
08:18:53 <deech> Ah, then I'll keep it simple for now. Thanks!
08:19:02 <merijn> The more you know about linking, the more likely you are to end up in Arkham Asylum :p
08:19:16 <merijn> Locked in a straight jacket, rocking back and forth, cackling to yourself...
08:30:50 <wineta> Hello , I am facing the following error
08:30:53 <wineta>    • Couldn't match expected type ‘IO [C.ByteString]’                  with actual type ‘ZMQ z [C.ByteString]’
08:31:43 <ski> perhaps you could show the relevant code ?
08:32:15 <ski> it sounds like you might need to use a "run" function for `ZMQ z'
08:32:30 <Cheery> Trying to think of a title for a post that makes js developers soil their pants.
08:32:48 <wineta> startZMQRouter :: (SomeEnv env m, MonadIO m) => Z.Socket z t -> m ()startZMQRouter router = do    continue <- liftIO $ newIORef True    rm <- liftIO $ Z.receiveMulti router
08:34:07 <ski> wineta> :t Z.receiveMulti
08:35:20 <ski> it's looking to me now like the second `liftIO $ ' shouldn't be there .. but i can't know, without knowing the type of that function
08:35:35 <wineta> https://codeshare.io/5MLVoW
08:35:47 <wineta> sorry it took me a while to share the appropriate code
08:36:16 <ski> hm, is there any raw code link on that page ?
08:36:56 <ski> (i only see "Please update your browser. Sorry but your browser is not compatible with Codeshare. Download the latest Chrome, Firefox, Edge, or Safari." .. no alternative method of seeing the plain text)
08:36:57 <wineta> are you unable to see the code snippet?
08:37:14 <ski> correct
08:37:24 <wineta> ohh, I am able to see in all my 3 browsers (firefox, chrome, chromium)
08:38:04 <thblt> ski: are you using noscript?
08:38:08 <ski> (the Haskell code doesn't seem to be embedded in the HTML source .. and i see no likely raw / plain text link in it, either)
08:38:10 <wineta> receiveMulti :: Z.Receiver t => Socket z t -> ZMQ z [ByteString]
08:38:16 <ski> thblt : W3m
08:39:52 <wineta> :ski I shared the method type
08:40:08 <thblt> ski: https://paste.thb.lt/1595950755.html
08:40:34 <ski> wineta : yes, so don't pass a `ZMQ z [ByteString]' to `liftIO'. i think either you should scrap the second `liftIO' (not the first, though), or else you need some other function roughly of type `ZMQ z a -> m a' .. and then you'll probably need to either specify `m', or add some more constraint on `m', to record the fact that it may do `ZMQ z' effects
08:41:30 <ski> thblt : yea, that's the same as wineta pasted above. ty, anyway
08:41:44 <wineta> thblt: thank you
08:42:03 <wineta> ski: thanks for the answer, I am afraid I am not understanding it yet..
08:42:11 <ski> wineta : is that a method signature of a type class ? which typeclass, with which type class head ? (i'd like to know the names of the parameters of it)
08:42:40 <ski> wineta : first try to remove the second `liftIO $ ' -- i suspect it'll not work, but try that at first
08:42:49 <wineta> https://gitlab.com/twittner/zeromq-haskell/-/blob/develop/src/System/ZMQ4/Monadic.hs
08:42:58 <ski> wineta : also, i think there's at least one command in that `do'-expression that you're not showing
08:44:09 <wineta> If i remove liftIO, then I get this >> Couldn't match type ‘m’ with ‘ZMQ z’      ‘m’ is a rigid type variable bound by
08:44:42 <ski> yes, i suspected that
08:44:48 <wineta> I cant swap out m() with ZMQ z (), as the other ENV I am getting in the context will be gone
08:45:37 <ski> ah, `receiveMulti' is not a typeclass method !
08:46:23 <wineta> :ski not being a typeclass makes it easier?
08:47:31 <ski> not really, that i know. i just wanted to know the full type of the operation. and for a type class method, that includes not just the stated signature in the type class, but also the type class head
08:47:50 <ski> example :
08:47:51 <ski> @src RealFrac
08:47:52 <lambdabot> class (Real a, Fractional a) => RealFrac a where
08:47:52 <lambdabot>     properFraction                  :: (Integral b) => a -> (b, a)
08:47:52 <lambdabot>     truncate, round, ceiling, floor :: (Integral b) => a -> b
08:48:05 <ski> the stated signature for `properFraction' is
08:48:18 <ski>   properFraction :: Integral b => a -> (b, a)
08:48:28 <wineta> yes
08:48:41 <ski> but, since this is in a type class, with head `RealFrac a', the effective signature also includes that head, like :
08:48:48 <ski>   properFraction :: (RealFrac a,Integral b) => a -> (b, a)
08:48:57 <ski> and this is what we'll get if we ask for the type
08:49:02 <ski> @type properFraction
08:49:03 <lambdabot> (RealFrac a, Integral b) => a -> (b, a)
08:49:10 <ski> (`:type' in the interactor)
08:49:42 <ski> (but if you use `:info', you'll get both the type class head, and the separate method signature)
08:49:43 <wineta> ok..
08:49:46 <ski> anyway
08:50:20 <ski> in your case, there was no type class head constraining `z' in `receiveMulti :: Z.Receiver t => Socket z t -> ZMQ z [ByteString]' (which was what i wondered about)
08:50:41 <wineta> yes true
08:51:55 <wineta> still not sure whats the best way to fix this..
08:52:42 <ski> i think you either need to have the `ZMQ' operations that you use/need, expressed as type class methods (like `put',`get' for `MonadState') .. or else, you need to replace that `m' with something like `EnvT env (ZMQ z)'
08:53:20 <ski> (where `EnvT env' is a concrete monad transformer, which is an instance of `SomeEnv env')
08:54:02 <wineta> I see..
08:54:27 <wineta> thank you , I will try this out in some time..
08:54:34 <wineta> appreciate your help!
08:55:05 <ski> what is `SomeEnv' ?
08:55:28 <wineta> it has a whole bunch of things, DB , network stuff
08:55:39 <ski> defined by you ?
08:55:42 <wineta> yes
08:55:48 <ski> (i assume you didn't define `ZMQ')
08:56:03 <wineta> no ZMQ is the Zero Message Queue library
08:57:00 <ski> it looks like `ZMQ z a' is currently defined as `ReaderT ZMQEnv IO a' (with `z' being used similarly to `s' for `ST s', keeping track of different invocations of `runZMQ', making sure they're not mixed together)
08:57:53 <ski> i wonder whether it would be feasible to make a `MonadZMQ' type class ..
08:58:14 <ski> (.. or maybe there already is one, somewhere)
09:00:21 <ski> but, barring that, it seems like you should try the `startZMQRouter :: Z.Socket z t -> EnvT env (ZMQ z) ()' route (making sure to have instances `MonadIO m => MonadIO (EnvT env m)' and `SomeEnv env (EnvT env m)', where the type class `SomeEnv env m' presumably will have `Monad m' as superclass)
09:00:33 <ski> wineta ^
09:06:39 <L29Ah> how do i figure where <<loop>> comes from when i use unsafeDupablePerformIO? -xc tells nothing particularily helpful: https://dpaste.com/5T6AZ448Y
09:07:42 <wineta> ski: thanks once again, will try your suggestions!
09:08:55 <glguy> Clint: I don't know if you're still involved, but you were packaging my program for Debian. I've added a simple man page and I'm wondering if there's anything in particular I have to do to make that useful to a packager
09:08:56 <x0r-255> I am trying to use media keys via `XMonad.Util.EZConfig`, the volume keys work just fine for me, but whenever I use anything other than `<XF86Audio Mute/Lower/RaiseVolume` my xmonad session crashes. As in the only window I'm able to interact with is the last focused one, and I am no longer able to use any xmonad keybindings or switch windows.
09:08:57 <L29Ah> in fact it seems like the call spoils something downstream
09:08:59 <x0r-255> Any clue why?
09:09:39 <L29Ah> x0r-255: you can run xmonad in a terminal to see its screams
09:09:51 <L29Ah> `DISPLAY=:0 xmonad` or something
09:09:56 <x0r-255> The keys in particular are: `<XF86AudioPlay> <XF86AudioPause> <XF86AudioPrev> <XF86AudioNext> <XF86MonBrightnessDown> <XF86MonBrightnessUp>`
09:10:01 <thblt> x0r-255: or sometimes it's piped to ~/.xsession-errors
09:10:53 <x0r-255> I'll attempt to get some more logs, yes.
09:11:32 <thblt> x0r-255: Just to be clear, if you bind the exact same action to XF86AudioMute and XF86AudioPause, it works on the first, crashes on the second?
09:13:41 <x0r-255> it doesn't seem to matter what I put, I tried the same stuff as audioraise/lower, but it still crashes
09:15:06 <x0r-255> The command I'm using for audioplay/pause is `playerctl -a play-pause &`, and originally I thought it was that, but it appears not.
09:17:12 <ezzieyguywuf> hrm, in `maybe (pure ()) doSomethingElse`, is there a different/better way to write `pure ()`?
09:18:08 <ezzieyguywuf> in general, is the use of `maybe` here appropriate? Or is there some other idiomatic way of approaching this? `doSomethingElse :: SomeVal -> m ()`, but I have a `Maybe SomeVal`, thus the use of `maybe`
09:19:06 <dsal> I wrote a justM for that case.
09:19:09 <c_wraith> that looks a lot like traverse_
09:19:31 <dsal> justM :: Monad m => (a -> m ()) -> Maybe a -> m ()
09:19:31 <dsal> justM = traverse_
09:19:59 <ezzieyguywuf> lol
09:20:05 <ezzieyguywuf> great minds think alike I guess
09:20:12 <c_wraith> or for_, if you want a more convenient order for doing things inline
09:20:15 <c_wraith> :t for_
09:20:16 <lambdabot> (Foldable t, Applicative f) => t a -> (a -> f b) -> f ()
09:20:50 <ezzieyguywuf> c_wraith: dsal: thank you, I will spend some time exploring traverse_ and for_
09:21:04 <c_wraith> they're the same function, just have their argument orders swapped
09:23:13 <ezzieyguywuf> yea I get that.
09:23:34 <mniip> maerwald, :(
09:23:48 <dsal> I think I wrote justM before I realized it was traverse_, and then left it for readability.
09:24:01 <ezzieyguywuf> I think what threw me off initially about the documentation of for/traverse was the use of the word "action"
09:26:10 <ezzieyguywuf> hah, what a neat function/concept! this whole traverse thing
09:26:15 <ezzieyguywuf> it was, ofc, exactly what I was looking for
09:58:59 <thblt> Is there a name for the type argument of a type of kind * -> * ? Say Maybe Int or [String], what's x for “Int is the x of Maybe” or “String is the x of []”?
10:00:02 <Lycurgus> type innit?
10:00:14 <tomsmeding> "type argument"? :p
10:00:35 <thblt> That’ll do, thanks :)
10:04:19 <thblt> I've been trying to understand the default implementation of foldr in terms of foldMap, that thing is trickier than I'd expected.  But I've learned about coerce, the Endo newtype and the weird function composition #.
10:06:01 <thblt> (the latter being, spoiler, totally irrelevant to the question, since it's equivalent to . except for performance)
10:06:25 <ski> @type ( # )
10:06:26 <lambdabot> AReview t b -> b -> t
10:06:28 <ski> @type review
10:06:29 <lambdabot> MonadReader b m => AReview t b -> m t
10:07:17 <ski> @type \l b -> review l b
10:07:18 <lambdabot> AReview t b -> b -> t
10:08:17 <thblt> ski: I'm not sure that's what you're looking for, but the weird operator I mentioned is "#.", the period is part of the name.
10:08:31 <ski> oh
10:08:56 <ski> @hoogle #.
10:08:56 <lambdabot> Data.Profunctor.Unsafe ( #. ) :: forall a b c q . (Profunctor p, Coercible c b) => q b c -> p a b -> p a c
10:08:56 <lambdabot> Linear.Affine ( #. ) :: Coercible c b => (b -> c) -> (a -> b) -> a -> c
10:08:56 <lambdabot> Lens.Micro.Internal ( #. ) :: Coercible c b => (b -> c) -> (a -> b) -> a -> c
10:09:35 <thblt> Also it's not exposed :)
10:09:38 <ski> mhm
10:09:47 <thblt> https://hackage.haskell.org/package/base-4.14.0.0/docs/src/Data.Functor.Utils.html#%23.
10:09:59 <thblt> ski ^
10:10:34 <thblt> It's . with an extra coerce IIUC
10:11:17 <thblt> (“IIUC” being the important word here)
10:11:36 <ski> (hm, no `infix(|lr)' declaration ?)
10:12:34 <thblt> Doesn't it just mean “happy with the defaults”?
10:14:23 <thblt> Except . is infixr 9 but default is infixl 9 
10:24:34 <x0r-255> Sorry, I had to go for a while, it appears that my binding of the `<XF86...>` keys doesn't seem to have any effect on xmonad crashing... It happens regardless.
10:24:56 <x0r-255> I'm curious to know why the volume keys don't cause the same behaviour.
10:25:30 <thblt> x0r-255: it's a real crash? The XMonad process is dead, not just frozen?
10:26:10 <x0r-255> No, it's still alive, so it freezes up would be a better way to put it.
10:26:22 <x0r-255> I just hop into another tty and kill it that way.
10:31:25 <thblt> x0r-255: have you tried binding to something dumber, like resizing the layout or something similar, so we can rule out external applications acting crazy?
10:32:08 <thblt> I really love that type of bugs especially when it's not to me they happen.
10:32:33 <x0r-255> I binded the same action to Super+= and Super+- and the action works fine, it appears to be only on the media keys.
10:32:54 <thblt> x0r-255: what's that action?
10:33:19 <fog> whats the point in Seq if we can just use memory addresses directly?
10:33:21 <thblt> x0r-255: what I suggest you try is eliminate external programs as a factor.
10:33:39 <fog> am i misunderstanding something? 
10:34:35 <fog> as far as i can tell the fastest implementation of a buffer should be using "circular" MVector and keeping track of the index that is the "start", and then just calculating the rest of the indicies modulo
10:35:07 <fog> modulo indexing cant be more expensive than, eg, having to fold over a Seq
10:35:25 <fog> to put it into a "fast random access container" 
10:35:37 <fog> but, Seq must exist for a reason...
10:36:12 <fog> why was it made? it seems to imply there is something wrong with that logic about mutable buffers
10:37:13 <x0r-255> I've ruled out the external program being the issue here, the action is: `xbrightness -inc(or dec) 5`, it doesn't work properly and causes the freezing of the keys, window switching etc. However, that same action works fine via super+=/super+-.
10:38:45 <x0r-255> Even without the keybindings attached to those keys they cause the crashing.
10:39:37 <x0r-255> As far as I can tell it applies to any media key excluding volUp volDown volMute kbdBacklight and airplaneMode.
10:43:15 <x0r-255> thblt: You there?
10:45:32 <thblt> x0r-255: Yes.  You could try with an unconfigured XMonad (just delete/rename ~/.config/xmonad/)  or maybe even without xmonad.  The root cause may be somewhere else in X.
10:47:11 <x0r-255> It works fine in KDE, I'll try it with an unmodded xmonad.
10:49:04 <maerwald> mniip: :D
10:49:42 <thblt> x0r-255: also what's your OS, is it reasonably up-to-date, and so on?
10:52:06 <x0r-255> Manjaro, rolling release, yes.
10:53:00 <L29Ah> do i get it right that each haskell thread has its own stack, and that it runs foreign code like C in it?
10:59:14 <fog> i guess i could just not care about it, and do whatever seems fastest, but i would prefer to understand
10:59:41 <x0r-255> Okay, just tried an unconfigured xmonad, the same issue still exists.
11:01:08 <thblt> x0r-255: Can you sho
11:01:21 <thblt> x0r-255: Can you paste the output of `ps aux` somewhere?
11:01:28 <x0r-255> sure thing
11:04:11 <x0r-255> thblt: https://pastebin.com/0qjZsQGi
11:05:06 <thblt> x0r-255: you use Xmonad in KDE?
11:05:23 <x0r-255> no, I use them seperately
11:05:39 <x0r-255> I am transitioning to only xmonad, but this takes time.
11:06:22 <x0r-255> I have multiple virtual consoles and launch KDE first, as I don't have any networkmanager or other usual startup programs setup in xmonad yet.
11:08:31 <thblt> And there's CKB in the mix.  
11:08:33 <maerwald> Is there any consensus on how to achieve xdg support for cli apps without breaking backwards compat?
11:09:05 <maerwald> I thought about `app --xdg`, then ppl caring about xdg can set a bash alias
11:09:11 <dmwit> maerwald: Not really. The state of the art appears to be "check if the old configuration directory is still around and use it if it is, otherwise do XDG".
11:09:47 <thblt> x0r-255: Ok to be honest I don't even know if it will help but I'll try reducing the factors.  A single X display, pure XMonad, no KDE, no compositor, no ckb. 
11:09:55 <maerwald> dmwit: but that's only mildly backwards compat... e.g. if some CI assumes the directory is gonna be ~/.foo and does cleanup steps, these may silentyl fail
11:10:05 <thblt> I doubt it's a pure XMonad issue, my best guess is things are fighting.
11:10:39 <maerwald> (in fact, that would be the case for my own CI)
11:10:43 * dmwit nods agreement
11:11:00 <x0r-255> alright
11:11:54 <dmwit> maerwald: Fix your CI. ;-)
11:12:01 <thblt> s/I'll try/I'd try/
11:12:20 <maerwald> dmwit: the "app" is used in github actions... imagine I break that :)
11:14:03 <maerwald> so to me the options are: env variable APP_XDG_DIRS=True or a cli switch
11:15:12 <maerwald> cli switch causes problems with tab completion if used as an alias I think
11:15:24 <tomsmeding> fog: are you arguing for a mutable vector versus containers:Data.Seq?
11:15:48 <fog> im questioning about that yes
11:16:00 <fog> any ideas?
11:16:05 <dmwit> maerwald: zsh at least has no problem with inheriting tab-completion for aliases.
11:16:08 <tomsmeding> a mutable vector has a finite length, right?
11:16:15 <fog> its for buffers
11:16:20 <tomsmeding> are you suggesting resizing it?
11:16:21 <fog> of fixed length
11:16:25 <fog> no resizing
11:16:25 <tomsmeding> or is your application a circular buffer
11:16:29 <fog> yes
11:16:33 <tomsmeding> right
11:16:42 <tomsmeding> then Seq might not be the tool for the job :p
11:16:53 <tomsmeding> but that doesn't mean there aren't other jobs for which it is the right tool
11:17:03 <fog> hmm, so it has advantages when?
11:17:32 <fog> you seem already to suggest if it is of variable length
11:17:41 <tomsmeding> well I don't know of another functional data structure that has the complexity properties stated in the docs
11:17:41 <fog> so is that to do with it being a malloc driving thing
11:18:01 <fog> its something to do with it being "a functional data structure" ?
11:18:03 <tomsmeding> the key thing with Seq is the amortised constant head/last access
11:18:10 <fog> i get how it works
11:18:22 <tomsmeding> so you can implement a veritable "constant-time" queue using a functional data structure
11:18:24 <fog> i just dont get how a "functional data structure" could be a good thing
11:18:26 <tomsmeding> yes it being functional is key :)
11:18:36 <tomsmeding> it means there is no unsafePerformIO, which is good
11:18:44 <fog> hmm
11:19:01 <fog> i think i can use the ST monad though right?
11:19:09 <fog> for "purish" mallocation
11:19:20 <tomsmeding> you could almost certainly implement Seq-like functionality faster using mutable arrays, but then how do you wrap that efficiently in a functional interface
11:19:40 <tomsmeding> you can use ST, yes, but then you have to repeatedly thaw and freeze the array you're working on
11:19:52 <tomsmeding> and that can introduce copies (though I'm not sure how many, exactly)
11:20:15 <fog> this seemed to be the problem
11:20:21 <fog> about having to fold over the Seq 
11:20:51 <fog> i guess thats basically doing the copying or freeze/thaw of which you speak
11:20:59 <tomsmeding> fold where?
11:21:02 <fog> putting it into another datatype for fast random access
11:21:25 <tomsmeding> yes I'm talking about the freeze/thaw of Data.Array.ST
11:22:00 <x0r-255> thblt: Alright, tried that, and it works fine when it's on the first display.
11:22:13 <tomsmeding> fog: https://hackage.haskell.org/package/array-0.5.4.0/docs/Data-Array-MArray.html#g:7
11:22:15 <fog> i mean, Seq seems fast for a buffer update, but it also seems to impose buffer access
11:22:18 <x0r-255> I also tried it on a second display, and that caused the issue
11:22:26 <x0r-255> so it's probably connected to that
11:22:44 <thblt> x0r-255: so with two separate X displays, or after closing the first one?
11:22:44 <tomsmeding> fog: indeed
11:23:04 <fog> if i want to fast access *and* fast buffering update, of fixed length then it seems like a modulo accessor increment is better 
11:23:15 <tomsmeding> for performance, certainly
11:23:24 <tomsmeding> but I challenge you to make a nice, purely functional interface to that
11:23:32 <fog> i cant actually see how the purity could be more of an important consideration than performance 
11:23:45 <tomsmeding> recall the channel you're in :p
11:23:49 <x0r-255> thblt: it always works when on the first display, KDE, Openbox xmonad or a combination of them, however not on the second display (ctrl+alt+f1,2,3...).
11:23:54 <x0r-255> at least in my testing
11:24:07 <fog> it seems like a lot of trouble to go to, to design functional datatypes for certain types of structured memory management, for the sake of purity 
11:24:11 <x0r-255> So KDE isn't the issue (I think) nor picom.
11:24:12 <tomsmeding> noone programming in C or Rust or Java or whatever would even think about implementing a finger tree
11:24:24 <fog> so why do we?
11:24:44 <tomsmeding> because we want to see how far we can go while retaining purity
11:25:02 <tomsmeding> you _can_ do impure stuff in Haskell; you can even do it without IO, by using ST
11:25:04 <fog> and thats how we end up being discarded as being "purely accademic" ?
11:25:15 <tomsmeding> but then your interface becomes monadic in ST, which is certainly a possibility
11:25:25 <tomsmeding> see e.g. Data.Array.ST.STArray
11:25:31 <tomsmeding> and if you want that, use that :)
11:25:46 <tomsmeding> but for the ones that do not want that, there are some alternatives, like Seq
11:26:13 <fog> well i spent about 4 years designing 2d buffers. and had to contend with this notion of it being for no reason
11:26:13 <tomsmeding> well purity gives some correctness guarantees that are hard to come by in non-pure code
11:26:42 <fog> in the end it seemed to be down to hardware
11:27:02 <fog> maybe if someone wrote Seq-RAM it would be faster
11:27:24 <x0r-255> thblt: so it doesn't seem to matter if I have multiple displays open, but when pressed whilst on the latter displays it causes the holdup.
11:27:27 <fog> but the whole point is the hardware we have is for "fast random access, hence Random Access Memory"
11:27:29 <tomsmeding> but just to jump a tack back: your ideal circular buffer would use a mutable array I understand
11:27:41 <tomsmeding> what would you imagine be the API in haskell?
11:28:04 <fog> yeah, i was worried about the cost of the modulo int, but that should be far less than the random access over the Seq
11:28:39 <tomsmeding> your mutable buffer with modulo's is far cheaper than the extensive pointer chasing that Seq is doing, no doubt at all about that
11:28:48 <merijn> tomsmeding: Nitpick: ST and IO are pure, that's the point of having them in the language ;)
11:28:49 <fog> the API would be something like a State monad holding the "start" and then, a calculation to determine the relative index, moding round 
11:29:30 <fog> there is a difference between "effectless" and "pure" ?
11:29:57 <tomsmeding> I guess there are different interpretations of the word "pure", and merijn is using the correct one and I was using the vague one
11:30:11 <fog> basiclly my main concern is to avoid having to shift all the memory along one
11:30:17 <tomsmeding> the "pure" I meant refers to the functional coding style that allows equational reasoning
11:30:30 <merijn> tomsmeding: In context it'd probably have been less ambiguous to say that we can have *mutability* "even without IO, by using ST" :)
11:30:32 <tomsmeding> you mostly lose that when introducing explicit sequencing of operations using monadic code
11:30:46 <fog> so instead, i can just overwrite the memory position with the "last" value that would be discarded by the buffer, which you called a "circular buffer" which seems about right
11:30:50 <merijn> Anyway </pedantic>
11:31:15 <tomsmeding> merijn: pedanticity is always in order when someone mis-uses "pure" and related terms, thanks :)
11:31:40 <fog> but IO isnt pure?
11:31:43 <tomsmeding> fog: yes what you describe is the standard implementation of such a thing https://hackage.haskell.org/package/array-0.5.4.0/docs/Data-Array-MArray.html#g:7
11:32:01 <tomsmeding> well all code in Haskell is pure because it doesn't do crap without someone interpreting that IO
11:32:04 <fog> you just linked freeze thaw?
11:32:19 <fog> whats that got to do with the circular thing i described?
11:32:32 <tomsmeding> I can construct `putStrLn "cheese"`, throw around that value of type IO (), and nothing happens
11:32:34 <tomsmeding> all is pure
11:32:40 <tomsmeding> in the technical sense
11:33:04 <fog> by linking that you throw me off completely
11:33:15 <tomsmeding> but there is a sense in which Data.Array is pure and Data.Array.MArray is non-pure
11:33:21 <fog> the whole point is to avoid any freezing or thawing
11:33:22 <tomsmeding> perhaps not-in-functional-style is a better term
11:33:28 <fog> it needs to stay mutable
11:33:35 <tomsmeding> implementing it using Seq does not involve freezing and thawing :)
11:33:36 <fog> so you can fastly overwrite the "last"
11:33:41 <fog> which is actually circling round
11:33:47 <tomsmeding> but it does use lots of memory allocations
11:33:52 <fog> the idea is, i dont need to malloc anything
11:33:57 <tomsmeding> I know
11:34:00 <fog> i have a fixed malloc at the start
11:34:31 <fog> and then, i have one mutable replacement, of the last, and still have fast random access
11:34:52 <fog> and i just need to change which of the circle is considered the first
11:35:03 <tomsmeding> you can implement a circular buffer using a mutable array in the exact way you describe, e.g. using an STArray, and the API will be in the ST monad
11:35:05 <fog> and do the modulo arithmetic for the accessor
11:35:27 <tomsmeding> and there's probably someone who did that before us
11:35:33 <fog> tomsmeding: but why did you link to freeze and thaw, saying that i described an implementation of that?
11:36:05 <tomsmeding> that is probably a miscommunication: I didn't say you described an implementation of that
11:36:08 <fog> "fog: yes what you describe is the standard implementation of such a thing https://hackage.haskell.org/package/array-0.5.4.0/docs/Data-Array-MArray.html#g:7"
11:36:28 <tomsmeding> wut
11:36:39 <fog> im quoting what you said
11:36:42 <tomsmeding> oh crap I mislinked :')
11:36:48 <tomsmeding> I intended to link https://en.wikipedia.org/wiki/Circular_buffer
11:36:50 <tomsmeding> sorry
11:37:15 <fog> damn! i thought there was an implementation of a circular buffer using MVector you were trying to link to!
11:37:48 <tomsmeding> well there is https://hackage.haskell.org/package/circular-0.1.1/docs/Data-Stack-Circular.html but it looks _really unsafe_
11:37:54 <x0r-255> thblt: I have to go for now, but I will be back, I found this https://unix.stackexchange.com/questions/306441/system-x-freezes-graphically-on-function-keys-press , however, I couldn't find more pertaining to the second display server being related.
11:37:59 <fog> ahh, no, from the animation what i need is not a typical circular buffer
11:38:08 <tomsmeding> and more, let me look on the other search results on hackage
11:38:09 <tomsmeding> oh
11:38:10 <fog> which seems like it could work better with pure setting 
11:38:20 <fog> it seems to read from the head each time
11:38:27 <fog> i just need to write to it in a circular way
11:38:36 <fog> and to read from it using MVectors fast random access
11:38:39 <tomsmeding> aha
11:38:49 <fog> the way they have it is index free
11:38:57 <fog> and would need no mod 
11:39:05 <tomsmeding> that's not a standard data structure I know, but it's certainly something you can implement with almost exactly the same code as a circular buffer
11:39:22 <tomsmeding> except that you need an extra modulo operation indeed
11:39:38 <fog> again, strange this doesnt already exist
11:39:57 <fog> i guess performant haskell using MVectors might be a new movement
11:40:44 <tomsmeding> people haven't really focused on performance in the past, that's true
11:40:54 <tomsmeding> but people are also attached to their nice functional, non-monadic interfaces
11:41:16 <fog> noramlly the things i write, the subsections of a larger project, dont seem as good as candidates for standalone libraries as this
11:41:51 <fog> i wonder if there would be anyone up for getting something like this onto hackage
11:42:30 <tomsmeding> let me write up some basic type signatures for an API for something like this
11:42:34 <tomsmeding> and you say whether you like that
11:43:45 <fog> ill see if i can find any code snippets from when i was trying to work with mvectors before
11:47:06 <fog> hmm, the only thing i have is very much a work in progress... not even sure what of it works
11:47:43 <fog> here; https://github.com/fog-hs/fognet2-partially-complete-/tree/master/fognet/Vectors
11:48:00 <tomsmeding> fog: how about something like this https://gist.github.com/1a9f9f6d64ab60699751c9bdeb99bc81
11:48:08 <tomsmeding> is that somewhat like your idea of the data structure?
11:48:41 <tomsmeding> okay sure you have type-level nats for the vector length, but that's orthogonal to the issue at hand
11:50:05 <fog> hey, thats really good!
11:50:27 <fog> im not used to working with Data.Array (hence the total mess of a repo i just linked)
11:50:51 <fog> i guess the last part is to have it use something like a Store to update the index thats accesing over it
11:51:50 <fog> like, so, get xs i == get (push xs undefined) (i+1)
11:52:12 <fog> ignoring the ST monad momentarily! 
11:52:14 <tomsmeding> wait what do you eman exactly?
11:52:18 <tomsmeding> *mean
11:52:28 <tomsmeding> sure, functionally first, monadic later :p
11:52:50 <fog> well, the relative index of the previous element at some index, after the buffer is added to, gets shifted around by one
11:53:05 <tomsmeding> oh right
11:53:05 <fog> as if it had been consed ontp
11:53:29 <tomsmeding> so it's as if you have a vector on which you push elements, and it forgets the old ones?
11:53:53 <fog> just the last one
11:54:03 <fog> like, a buffer
11:54:25 <tomsmeding> so if the thing has 4 slots, and I push 1, 2, 3, 4, 5, then it's as if I just pushed 2, 3, 4, 5
11:54:28 <fog> so the new head, being consed on, gets written over the previous "last" 
11:54:43 <tomsmeding> or as if I just pushed 5, 2, 3, 4
11:55:12 <fog> push <4,3,2,1> 5 = <5,4,3,2>
11:55:24 <tomsmeding> (also I messed up some of the types in the implementation I linked, so it doesn't actually compile, but the general idea is the same, fixing at the moment)
11:55:33 <tomsmeding> right
11:55:42 <tomsmeding> so my first option, except you see the whole thing in reverse
11:56:41 <fog> but really thats more like [4,3,2,1] ; [4,3,2,5] ; [4,3,6,5] ... 
11:57:15 <fog> but eg, for the last of those you want get 0 to give 6
11:57:35 <tomsmeding> yes that makes sense
11:57:42 <tomsmeding> okay let me change my code so it does that
11:58:11 <fog> so helpful, thanks
11:59:15 <tomsmeding> are you okay with the thing being filled with zeros at the start? :)
12:00:03 <fog> yeah
12:00:19 <fog> i have another implementation of a buffer that uses list
12:00:55 <fog> which is here
12:00:56 <fog> https://pastebin.com/raw/jF7HT1nR
12:01:04 <fog> it has an updateBuffer function
12:01:16 <fog> i guess i could make it into a class so your version could be an instance of it
12:01:46 <fog> i guess it would need the accessor function in the class aswell
12:02:33 <fog> basically, its just a way of casing from Lengthed List upon initialisation, so it can be guarantied to be the correct length by type safety
12:03:02 <fog> though im not sure if thats totally superfluous since it might as well just have a value level bounds check
12:03:06 <tomsmeding> okay, but the type-level length is orthogonal to the issue :p
12:03:11 <tomsmeding> it's cool and good and stuff
12:03:29 <fog> i know, im just saying, that with your version, it could fit into this setup if i make a class
12:03:35 <tomsmeding> indeed
12:04:06 <fog> but im not sure if its a bad idea to have this type machinery doing what could be done with a value level bounds check 
12:04:21 <tomsmeding> that's always the tradeoff :)
12:04:25 <fog> i guess having the length avoiable at type level could allow for the "fast" accessors
12:04:41 <fog> like, the ones that are "unsafe" because they dont do a bounds check
12:05:24 <fog> and also, maybe something like a dot product between two buffers, where the type safety could be actually useful
12:07:32 <tomsmeding> yep in those kinds of operations the type-level length is nice
12:19:57 <maerwald> I did sort -u and was confused why brittany does such weird formatting
12:21:35 <Cheery> http://boxbase.org/entries/2020/jul/29/hasked/
12:22:37 <fog> tomsmeding: here is a version that has the class; https://pastebin.com/raw/qqYvX1SY
12:23:12 <fog>  updateBuffer :: (a,Buffer m n a) -> (Buffer m n a,a)
12:23:39 <fog> the version i have is with m ~ []
12:23:44 <tomsmeding> oh right updateBuffer is supposed to give the value "pushed-out"?
12:23:56 <tomsmeding> sorry was distracted IRL for a while just now
12:24:03 <fog> no worries
12:24:13 <fog> erm, yeah, i guess so
12:24:24 <fog> thats just for this "streaming buffers" application
12:24:42 <fog> where the pusued-out value gets pushed back in to the next buffer
12:25:44 <fog> dont worry about the `n' param, that should be handled by it being able to be folded from the lengthed list
12:25:57 <fog> ie, all it needs for that is a "set" instance, which push provides
12:27:02 <fog> ie, i have;
12:27:04 <fog> toBuffer ::(Empty m,Set m) => List n a -> Buffer m n a
12:27:16 <fog> to initialise it
12:28:05 <fog> where the "smart constructors" of List are doing the bounds checking to allow for the "unsafe" access and modify methods to be used for the vectors
12:28:26 <tomsmeding> interesting
12:28:46 <tomsmeding> if you'll allow I'll first make this work without the type-level lengths
12:29:01 <fog> thats the point
12:29:04 <fog> you dont need to
12:29:14 <fog> it just needs an empty and a set instance
12:29:38 <fog> Buffer wraps the version that has no type annotations
12:30:07 <fog> so for the [] implementation, Buffer n a = [a]
12:30:16 <tomsmeding> wait I only need to implement Empty and Set for my array stuff?
12:30:22 <tomsmeding> that makes no sense
12:30:45 <fog> its just because Buffer only adds a phantom type parameter
12:31:06 <fog> to initialise it, you build up a List, which adds the correct type level Nat annotation
12:31:20 <fog> then, toBuffer folds this, suing set and empty
12:31:54 <fog> and wraps the resulting thing, like a [], or your thing, wihtout type annotations, in a Buffer, which adds the type annotation
12:31:57 <tomsmeding> :W
12:32:00 <tomsmeding> fail
12:32:03 <fog> ok, nvm
12:32:08 <fog> im bad at explaining
12:32:22 <fog> i can just write it into the interface, just ignore all the code i put!
12:32:59 <tomsmeding> okay I have code that does stuff
12:33:09 <fog> woop!
12:33:27 <tomsmeding> https://gist.github.com/tomsmeding/1a9f9f6d64ab60699751c9bdeb99bc81 (same url as just now)
12:33:39 <tomsmeding> see the `test` routine at the bottom
12:34:06 <tomsmeding> that prints [6,5,4,3]
12:34:50 <fog> *FogBuffer> test ; [6,5,4,3]
12:34:55 <fog> nice!
12:34:58 <fog> thanks!
12:35:16 <tomsmeding> was this the idea, in terms of data structure?
12:35:24 <tomsmeding> and is this an API that suits your purpose?
12:35:54 <tomsmeding> (letting `push` return the value pushed-out is trivial, by the way)
12:35:58 <fog> i think so, i like the sequence at the end, putting it into a list using get
12:36:16 <tomsmeding> yeah that's just to get some easy output
12:36:25 <fog> oh, how does that work with push?
12:36:34 <tomsmeding> well currently push returns nothing
12:36:35 <fog> push :: FogBuffer s a -> a -> ST s ()
12:36:37 <tomsmeding> but let me fix that
12:38:16 <tomsmeding> https://gist.github.com/tomsmeding/1a9f9f6d64ab60699751c9bdeb99bc81/revisions#diff-62f257e0965bf2ef5c3ebed53c070cdf
12:38:21 <tomsmeding> now it returns the old value
12:38:33 <tomsmeding> and `test` now prints (2,[6,5,4,3])
12:38:35 <fog> ah, so the way it does new means this casting from List is not going to be able to use Empty and Set...
12:38:41 <tomsmeding> because the push of 6 evicted the 2
12:39:12 <tomsmeding> would you expect `push` to return the new buffer, instead of mutating the existing one?
12:39:23 <tomsmeding> because if so, I'm not sure how you expected to implement this
12:39:35 <fog> *FogBuffer> test (2,[6,5,4,3])
12:39:59 <fog> push should use the mutability in order to be fast
12:40:10 <tomsmeding> yep
12:40:11 <fog> and should not freeze it afterwards, so that it stays mutable
12:40:19 <tomsmeding> indeed
12:40:24 <tomsmeding> which is what this does
12:40:25 <fog> so no, it should not make a "new" version
12:40:31 <tomsmeding> okay
12:40:32 <fog> i think its perfect!
12:40:52 <fog> i just need to figure a way to initialise it since it doesnt have a basecase for folding
12:41:11 <fog> i guess i can just make a class function to do that.
12:41:12 <tomsmeding> do you want to fold over a list of bufferes?
12:41:17 <tomsmeding> s/bufferes/buffers/
12:41:36 <fog> um, no, i mean for folding the List, for the typesafe construction
12:42:14 <tomsmeding> what purpose does folding the List have / where do you do that in your code?
12:42:18 <fog> eg;
12:42:20 <fog> instance ZeroList n => ZeroList (S n) where zeroList = 0 `Cons` (zeroList @n)
12:42:37 <fog> erm, no wait, that makes the List
12:43:04 <fog> unList :: List n a -> [a]
12:43:09 <fog>  unList Empty = [] 
12:43:10 <fog> unList (x `Cons` xs) = x : unList xs
12:43:27 <tomsmeding> how about unList :: List n a -> ST s [a]
12:43:35 <tomsmeding> I can implement that ;)
12:43:52 <tomsmeding> unList buf = sequence [get buf i | i <- [0 .. size buf]]
12:43:55 <fog> yeah, i guess thats what the class function it needs would be aswell
12:44:01 <tomsmeding> yep
12:44:05 <fog> oh, List is not []
12:44:16 <tomsmeding> because reading from the thing is a monadic action
12:44:32 <tomsmeding> letting that be a pure value would break referential transparency
12:44:34 <fog> but i guess i can go via list, its not too costly since its just at initialisation
12:45:47 <fog> A.newArray (0, len - 1) defVal
12:45:51 <fog> thats what your using
12:46:06 <fog> i guess if that could take a [] instead
12:46:12 <dminuoso> Given a typeclass C with some methods, say there is a function f that is implemented in terms of those methods. Beyond the ability to perhaps provide a more efficient implementation, what other benefit or downside do I have when I move `f` into a typeclass method?
12:46:19 <fog> but, i guess i can implement that just by pushing onto it
12:46:24 <dminuoso> Im particularly wondering about performance impact
12:46:29 <fog> no, i think you have provided everything nessacary
12:46:42 <fog> ill link something when i build it onto what i have so far
12:47:42 <tomsmeding> fog: if you want to share something with me later, and I don't see your ping, try pinging me personally
12:47:47 <fog> unless there is some really easy wat to create a an array from a list
12:47:54 <tomsmeding> there is
12:48:18 <tomsmeding> fromList :: [a] -> ST s (FogBuffer s a)
12:48:19 <fog> i guess that would be better than trying to fold over the list using push
12:48:20 <tomsmeding> is that what you want?
12:48:23 <fog> yeah
12:48:35 <tomsmeding> can implement that using https://hackage.haskell.org/package/array-0.5.4.0/docs/Data-Array-MArray.html#v:newListArray
12:48:41 <fog> ah perfect!
12:48:51 <fog> ill dm you shortly
12:50:03 <fog> really helpful btw - its always difficult to get started using a new library, this is the perfect walkthrough, thanks
12:50:05 <tomsmeding> my gist has been updated with a fromList implementation
12:50:11 <tomsmeding> np :)
12:50:21 <tomsmeding> happy to do something useful on this quiet holiday evening
12:51:14 <fog> ok, im going to percolate myself some coffee, ciao
13:01:37 <mniip> how do you install to the global package store with new cabal?
13:02:35 <dminuoso> mniip: just do it outside a cabal project directory with v2-install
13:03:14 <dminuoso> You can separate between environments with --package-env
13:03:26 <dminuoso> (Possibly this works inside a cabal controlled directory as well)
13:03:43 <mniip> I mean the *global* global package story
13:03:44 <mniip> store
13:03:56 <dminuoso> You mean without adding it to an environment?
13:04:00 <maerwald> cabal v1-install
13:04:10 <mniip> ...
13:04:24 <tomsmeding> dminuoso: regarding your question about putting an `f` inside a typeclass `C`: I seem to recall that can have some impact on inlining
13:04:27 <mniip> wasn't the idea to deprecate v1-install?
13:04:40 <maerwald> wouldn't that break nix?
13:04:45 <dminuoso> mniip: Well you can definitely just do `cabal v2-install foo` and it will install it in the global store.
13:04:47 <dminuoso> maerwald: no
13:04:54 <dminuoso> maerwald: nix does not use v1-install
13:04:59 <maerwald> interesting
13:05:09 <mniip> nix can build a version of cabal from 1995 if it wants to
13:05:17 <maerwald> only sandboxes have been dropped, not v1
13:05:43 <dminuoso> I have to ask then, what global global global store are you talking about?
13:05:49 <dminuoso> The v2- store?
13:06:14 <mniip> /usr/lib/ghc-ver/package.conf.d
13:06:55 <maerwald> cabal v1-install --global
13:07:46 <dminuoso> mniip: Thats obsolete with v2
13:08:09 <mniip> that's stupid
13:08:56 <dminuoso> What's wrong with v2-install?
13:09:40 <mniip> I'm going to be running ghc as a different user so $HOME is off-limits
13:09:57 <maerwald> oh
13:10:00 <maerwald> easy
13:10:16 <maerwald> you can use -v2 with a "global" store as well
13:10:53 <dminuoso> mniip: Im confident you can configure cabal to place its stuff wherever you like
13:11:09 <maerwald> cabal --store-dir=/global-cabal-store v2-install
13:11:36 <solonarv> you might also need to set a few other paths alongside the store path? not sure
13:11:40 <maerwald> with this you can also emulate sandboxing
13:13:54 <dminuoso> mniip: Just set CABAL_DIR to whatever you like, then use cabal v2-install
13:14:23 <dminuoso> If you keep it all at default settings, cabal will keep all its luggage in there somewhere.
13:14:59 <ja> dminuoso: but you still have to be outside of a cabal project directory for that to work, right?
13:15:39 <dminuoso> ja: I think not
13:16:07 <dminuoso> v2-install will manage the GHC environment at ~/.ghc/$ARCH-$OS-$GHCVER/environments/default by default
13:16:15 <dminuoso> but you can override that with --package-env
13:16:40 <dminuoso> So if you set both CABAL_DIR and specify --package-env, I think you can detach yourself from $HOME
13:17:15 <nshepperd> to resort to installing things in the global package store like some kind of madman, these must be dark times 
13:17:41 <dminuoso> nshepperd: dunno, `cabal v2-install cabal` seems to be a reasonable thing to od.
13:17:59 <dminuoso> err, `cabal v2-install cabal-install`
13:19:51 <mniip> nshepperd, it's a toy universe anyway
13:21:11 <nshepperd> you am play god
13:21:51 <mniip> dminuoso, I'm trying to do something like a reverse chroot
13:22:08 <mniip> keeping all the intermediate build artefacts to a directory, and only populating / with the real stuff
13:22:24 <mniip> that way I can then rm . and be done with it
13:22:35 <merijn> mniip: Is the real stuff "an executable"?
13:22:45 <mniip> ghc + a bunch of libraries
13:23:04 <mniip> the ghc part is already done
13:23:14 <dminuoso> How does cabal v2-install fit into all of this?
13:23:20 <merijn> mniip: I'm sure you can do what you want, but I don't think there's great docs for how
13:23:23 <dminuoso> Oh, so you want the libraries?
13:23:28 <mniip> :(
13:24:23 <mniip> merijn, right...
13:24:30 <merijn> mniip: There's a section prefix independence (i.e. how to package stuff to be elsewhere than cabal-install's defaults): https://cabal.readthedocs.io/en/latest/setup-commands.html#prefix-independence
13:24:52 <merijn> oh, ha
13:25:15 <mniip> the cabal docs are really lacking in documentation for --*dir options
13:25:26 <merijn> Libraries can't be prefix independent it says there >.> There's code for controlling where cabal should put things
13:25:55 <maerwald> I like cabal --help, because it throws an unsorted uncategorized bunch of arbitrary options at me :D
13:25:56 <mniip> last time I was toying around with this (v1 days), I was actually patching cabal
13:26:10 <mniip> fixing up some hardcoded paths
13:26:35 <mniip> nowadays I'm actually satisfied with /usr and /usr/local
13:29:15 <mniip> oh golly
13:29:20 <mniip> CABAL_DIR is not in 3.2
13:29:47 <merijn> mniip: The global store is just a single huge GHC package database holding (potentially) conflicting packages (i.e. everything) and cabal-install dynamically builds an environment out of those. All these things are controllable, but I'm not sure there's been a comprehensive write up on how it all fits together
13:30:08 <merijn> mniip: The GHC environment stuff is probably relevant if you haven't read it: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/packages.html#package-environments
13:30:13 <mniip> I have a decent understanding of the package.conf.d structure
13:30:19 <mniip> but not so much this environment stuff
13:31:13 <merijn> mniip: What makes you say CABAL_DIR isn't in 3.2?
13:32:30 <merijn> mniip: Looking at the code the stuff dealing with CABAL_DIR was added 2 years ago
13:32:35 <merijn> So that seems unlikely
13:32:36 <mniip> huh
13:32:46 <mniip> docs though
13:32:59 <mniip> actually I'll need to check how old this other cabal is
13:33:05 <merijn> mniip: Which docs?
13:33:12 <mniip> https://cabal.readthedocs.io/en/3.2/installing-packages.html
13:33:31 <merijn> oh, looks like 3.2 is exactly when it was added judging by the git tag
13:33:32 <merijn> https://github.com/haskell/cabal/commit/a343dee124098e6af6b7d004bfd084edec5a6829
13:33:34 <mniip> 2.2.0.0 oof
13:34:19 <merijn> mniip: So it looks like 3.2 docs weren't up to date with actual 3.2 features
13:52:23 <fog> https://github.com/fog-hs/FogBuffer/blob/master/FogBuffer/FogBuffer.hs
13:52:31 <fog> tomsmeding^
13:52:38 <fog> now its type safe!
14:03:53 <fog> I could also write it like this
14:03:54 <fog> https://gist.github.com/fog-hs/397316dd2667815f3dea66635f72e1f5
14:04:00 <fog> where it doesnt store the Int length
14:04:10 <fog> but gets it from the Nat singleton
14:04:18 <fog> but then it needs to convert from the nat each time
14:04:23 <fog> which is slower
14:04:56 <fog> using;
14:04:57 <fog> getInt :: forall n. IsNat n => Proxy n -> Int
14:04:58 <fog> getInt = fromNat . getNat
14:08:58 <gentauro> I'm generating `Haskell` code files with my project and I transitioned from `stacks` package.yaml to a `project_name.cabal` file. One of the downsides is that modules aren't added automatically to the .cabal file :( Is there any way to do this in a semi-/automatic way?
14:13:25 <ja> fog: what made you choose type-level-numbers over singleton-nats (kovács) or typelits-witnesses ?
14:15:14 <x0r-255> thblt: I'm back online, were you able to find anything?
14:17:08 <merijn> gentauro: Not really
14:17:25 <merijn> gentauro: Unless you include "write a script that post-processes the cabal file"
14:28:58 <maerwald> gentauro: yes
14:29:05 <maerwald> with cabal-fmt
14:29:28 <maerwald> https://oleg.fi/gists/posts/2019-08-11-cabal-fmt.html
14:30:12 <maerwald> a fully (but probably discouraged) automatic way is: https://github.com/kowainik/autopack
14:30:39 <maerwald> discouraged as in: don't uplopad it to hackage
14:31:11 <maerwald> it's a neat Setup.hs hack
14:31:12 <fog> ja: i didnt see those
14:32:04 <ja> fog: i choose typelits-witnesses and it worked fine. but kovács is very famous, maybe i should have chosen that one. according to the readme of typelits-witnesses, everything is also in the singletons package, which has wide usage
14:32:21 <ja> *chose, not choose!
14:32:29 <gentauro> merijn: so I need to write a .cabal parser then :)
14:32:38 <fog> whats wrong with my version?
14:32:40 <gentauro> so I can inject all the modules :)
14:32:56 <ja> fog: i dunno, havn't tried it, that's why i asked... ;)
14:33:07 <fog> well, the only reason i type it each time
14:33:08 <gentauro> oh, I didn't see maerwald message
14:33:12 <gentauro> looking at your links now
14:33:32 <merijn> gentauro: *personally* I would recommend "just write out the modules, because deriving them is a Bad Idea (TM)", but I guess that's not a particularly welcome solution to your problem :)
14:33:46 <maerwald> cabal-fmt has an annotation that adds modules from the specified dir on run
14:34:29 <fog> https://github.com/fog-hs/FogBuffer/blob/master/FogBuffer/TypeLevel/Nat.hs
14:34:56 <maerwald> all this would be easier, if the Cabal file format wouldn't be so terribly custom
14:35:21 <fog> i mean, noramlly i would just write data Nat = Z | S Nat
14:35:34 <fog> but for this i needed to have them be singletons
14:35:41 <fog> actually, im not sure if i do
14:35:48 <fog> anyway, they are for the BoundedInts
14:35:58 <merijn> maerwald: It should instead be a terribly custom schema on top of some other file type, without any form of specification like everyone's YAML configs for everything?
14:36:05 <fog> that are the type safe accssors over the phantom lengthed MVec buffers
14:36:13 <maerwald> merijn: toml
14:36:27 <fog> also, i like the ToNat that casts it from symbol
14:36:57 <fog> eg; https://github.com/fog-hs/FogBuffer/blob/master/FogBuffer/FogBuffer.hs#L79
14:36:59 <phadej> https://hackage.haskell.org/package/fin-0.1.1/docs/Data-Type-Nat.html#t:FromGHC ...
14:37:04 <phadej> shameless plug
14:37:05 <maerwald> merijn: there is *no way* to preserve cabal file formatting if you parse it with Cabal library....
14:37:20 <fog> phadej: mine are cheaper than yours
14:37:27 <gentauro> maerwald: and merijn I gill give those two tools a try :)
14:37:43 <phadej> fog: cheaper_
14:37:45 <phadej> ?
14:38:02 <gentauro> thx
14:38:22 <fog> yeah, you can get them from costcutter
14:38:37 <phadej> I'm not sure what you are talking about
14:38:46 <fog> some of the more fancy versions have opperations like multiplication
14:38:55 <fog> luxury Nats
14:38:58 <merijn> phadej: No one is >.>
14:39:30 <fog> sorry, im bleary eyed from coding at full speed
14:39:44 <maerwald> :D
14:40:15 <phadej> `fin` has Mult...
14:40:32 <phadej> and even some proofs about it
14:40:44 <phadej> but whatever, coding peano naturals is fun
14:41:23 <fog> oh cool, yours has reification
14:42:12 <fog> one day we will have things like this, and Get and Set as part of the prelude
14:42:43 <fog> and hetrogenous containers
14:43:05 <fog> working towards a type level hetrogenous monadic scanner
14:43:35 <fog> on a graph...
14:44:20 <fog> oh that reminds me, i need a version of "fold" for a tree, maybe the Cofree version
14:44:39 <fog> um, with hetrogenous branches
14:44:41 <fog> as monoids
14:44:52 <fog> wait, im explaining this all wrong.. sorry. one sec
14:45:23 <fog> parametric monoids on a hetrogenous tree
14:46:57 * phadej hides
14:47:00 <fog> eg, i can have (++) for type lengthed lists
14:47:10 <fog> thats kind of like a parametric monoid, right?
14:47:19 <fog> so then i can fold up a tree of them
14:47:21 <fog> :t fold
14:47:22 <lambdabot> (Foldable t, Monoid m) => t m -> m
14:48:13 <phadej> if you talking about something like, https://hackage.haskell.org/package/vec-0.3/docs/Data-Vec-Lazy.html#v:-43--43-  then yes, you can append Vecs
14:48:19 <fog> right
14:48:19 <phadej> and Vecs are Foldable
14:48:26 <fog> erm
14:48:27 <phadej> (among plenty of other things)
14:48:33 <fog> hetrogenous not though?
14:49:25 <phadej> you can append HLists too, but fold on them will look different
14:50:10 <phadej> closer to https://hackage.haskell.org/package/sop-core-0.5.0.1/docs/Data-SOP-NP.html#v:cfoldMap_NP
14:50:40 <phadej> one can also have heterogenous vec, but most likely you don't need one
14:50:46 <phadej> as type-level list already has length
14:50:52 <fog> i have a hetrogenous tree here; https://gist.github.com/fog-hs/19abbf2ee8cf1f9f0c39abf0772da34e#file-pair-hs-L136
14:52:17 <phadej> Ok, I leave you having fun by yourself ;)
14:52:17 <fog> and i have foldable for hetrogenous things here; https://gist.github.com/fog-hs/4f0b1c6f05bfaa9b7cb050751e84ec6d#file-foldingflist-hs-L148
14:52:30 <fog> what did i do wrong?
14:53:03 <phadej> nothing, but it looks like you are "having fun" not trying to solve some practical problem :)
14:53:18 <phadej> "having fun", and not ..
14:53:41 <phadej> (or it would take too much time to get to the problem description, so I rather go to sleep)
14:54:01 <fog> you think my extensible datatype is not good compared to SOP?
14:54:26 <fog> im not sure what you mean its not practical...
14:54:32 <mniip> phadej, is installing to the global package db officially unsupported now?
14:55:23 <phadej> fog: I cannot tell, you have pages of code, without narrative. Maybe your code is good, but just by looking at it, it's hard to tell
14:55:39 <phadej> fog: one way is to write blog posts about your experiments
14:55:47 <fog> why?
14:55:49 <phadej> with a rule that you must have more text lines than code lines
14:56:00 <phadej> because code is "too concise"
14:56:01 <fog> its just an extensible datatype
14:56:36 <phadej> mniip: no, but cabal doesn't try to make it easy
14:56:41 <phadej> cabal-install*
14:56:57 <mniip> right... what's the way?
14:57:01 <phadej> v2-build
14:57:03 <fog> i shouldnt need to "write a blog post" when people far more accademic than I have written papers on the subject we are all familiar with, such as trees that grow
14:57:14 <fog> thats why we have *words*
14:57:45 <phadej> I don't see how your thing is trees that grow
14:57:52 <fog> if i say, hetrogenous fold of an extensible datatype...
14:57:57 <sm[m]> fog, you'll get more engagement if you get better at explaining/introducing what you're talking about. Remember not everyone here is in your head space
14:57:59 <phadej> (or at least trees that grow as GHC implements it)
14:58:44 <fog> https://gist.github.com/fog-hs/19abbf2ee8cf1f9f0c39abf0772da34e#file-pair-hs-L155
14:58:52 <sm[m]> also when you need to do extensive brainstorming, here are two channels worth knowing about:
14:58:52 <sm[m]> #haskell-overflow: Overflow conversations and technical discussion from #haskell
14:58:52 <sm[m]> #haskell-in-depth: Haskell in depth - slower paced discussion of use, theory, implementation etc with no monad tutorials!
14:59:23 <fog> im not going to be provoked into response to then be banished for doing so
14:59:58 <fog> "i have a HTree here" is about as non-overflowing as required
15:00:13 <mniip> phadej, sorry, what?
15:01:23 <sm[m]> you're fine right now, I'm sharing those channels for the very long discursions you may have in future. Because you might get banned here otherwise
15:01:49 <fog> ok, the in depth and overflow channels could certainly be useful for that
15:02:57 <phadej> mniip: if you ask how to install to global db, then the answer is v1-build. If the question "what should I be using instead", then the answer is (v2-)build
15:03:16 <mniip> and v1-build is not "unsupported"?
15:04:00 <mniip> by which I mean, what are the chances that 6 months from now my cabal won't have a v1-build at all
15:04:09 <phadej> probably it will
15:04:19 <phadej> but it's not really maintained
15:04:49 <maerwald> would break quite a few distros if it was removed
15:04:51 <mniip> I mean I understand you're going for "best practices" and all that
15:04:53 <phadej> but it shouldn't just "break"
15:05:00 <mniip> but that's a downgrade in functionality
15:05:11 <phadej> mniip: I'm not engaging in that discussion
15:05:20 <phadej> I'm not removing it, but I'm also not maintaining it
15:06:00 <sm[m]> in 3.4, sandboxes have been removed, but not v1-build ?
15:06:07 <phadej> sm[m]: yes
15:06:13 <sm[m]> aww
15:06:29 <phadej> maerwald: fwiw, distros probably use ./Setup
15:06:30 <fog> i thought i was in #ghc for a minute then
15:06:33 <phadej> or at least they should
15:06:58 <phadej> cabal doesn't add any value to them
15:07:03 <phadej> (nixpkgs uses ./Setup, e.g.)
15:07:21 <phadej> cabal-install doesn't add any value to them
15:08:16 <phadej> recall, v2-build will pick up dependencies from global db too, if it think that they fit
15:09:26 <fog> im being sure to get this right.  folding a hetrogenous tree of parametric monoids (at the leafs) such as type lengthed lists (aka Vector)
15:09:37 <fog> under concatination
15:11:09 <fog> concerning "practicality" aka, "the why". its a first step towards tensor nets, where instead of concatenation you have contraction
15:11:42 <fog> and the "wtf"; the abstraction is the idea of "parametric monoids"
15:12:18 <fog> over.
15:14:20 <fog> come in #haskell, do you read me? over.
15:16:11 <fog> . o 0 ; fog has quit; killed by space junk
15:16:32 <hyiltiz> fog is a bot!?
15:17:30 <ski> no
15:17:57 <maerwald> haskell blogger
15:20:33 <monochrom> 1% haskell, 99% machine learning statistics physics type-system mad scientist.
15:21:38 <maerwald> Fascinating method, I'm just not sure the medium is the correct one
15:30:51 <solonarv> I am sure: this medium is not the correct one.
15:38:13 <thblt> I recently came accross (.) :: (a -> a) -> (a -> a) -> (a -> a) in base.  How would you call this?  I'd say it's a specialization of (.), but I'm not sure.
15:39:01 <ski> maybe "composition on endo-morphisms" ?
15:39:06 <ski> "endocomposition" ?
15:39:15 <Uniaika> thblt: it reads like a specialisation yes
15:39:30 <ski> (assuming it actually uses both arguments)
15:40:18 <thblt> Uniaika: ski: thank you both.
15:40:38 <ski> > (Endo ("foo" ++) <> Endo ("bar" ++)) `appEndo` "!"
15:40:40 <lambdabot>  "foobar!"
15:41:08 <ski> @type \f g -> appEndo (Endo f <> Endo g)
15:41:09 <lambdabot> (a -> a) -> (a -> a) -> a -> a
15:41:28 <ski> > (Endo f <> Endo g) `appEndo` x
15:41:30 <lambdabot>  f (g x)
15:42:07 <ski> @type (<>) `asTypeIn` \(<>) f g -> appEndo (Endo f <> Endo g)
15:42:08 <lambdabot> Endo a -> Endo a -> Endo a
15:43:40 <Uniaika> thblt: you're welcome! don't hesitate to hang out on #haskell-fr if you want. :)
15:53:14 <koz_> This sounds a bit silly, but how does one combine multiple changes to something using optics and set?
15:53:45 <dsal> thing .~ x & .~ y
15:54:04 <dsal> er... not that...
15:54:36 <dsal> thing & x .~ 1 & y .~ 2
15:54:39 <dsal> or whatever.
15:54:44 <koz_> Ah, I see.
15:54:50 <dsal> magics happen and the right result comes out
15:55:30 <koz_> (&) is 'flip ($)'?
15:55:35 <dsal> yeah.
15:55:49 <dsal> It seems common for this construct.  It feels fairly natural, anyway.
15:55:52 <koz_> OK, will try, thanks.
15:59:30 <koz_> Oh yeah, works, modulo some syntactic changes of my preference.
15:59:41 <koz_> (aka 'no use of APL')
16:00:37 <dsal> ha
16:01:39 <dsal> I often use the .~ and  %~ but sometimes it's easier the other way.  My brain doesn't actually have `.~` and `set` as aliases in my head.
16:01:47 <koz_> Is there a 'flip fmap' in operator form, to just totally contradict myself?
16:01:53 <solonarv> <&>
16:01:57 <dsal> :t (<&>)
16:01:59 <lambdabot> Functor f => f a -> (a -> b) -> f b
16:02:30 <koz_> Yay, thanks !
16:04:42 * ski 's sometimes called that `pamf'
16:05:23 <dsal> That'd be confusing if you live in the Bay Area.
16:09:13 <ski> how so ?
16:11:36 <dsal> PAMF is the Palo Alto Medical Foundation.  When my wife says something about PAMF, she's talking about going to the doctor.
16:11:55 <dsal> She never talks about fmap, though.
16:13:23 <ski> oh :(
16:13:51 <ski> @quote please.talk
16:13:51 <lambdabot> Dave_Benjamin says: please talk to your son or daughter about parametric polymorphism
16:15:20 <monochrom> heh
16:15:44 <monochrom> paramedic metamorphism
16:18:09 <int-e> . o O ( Offspring a )
16:42:31 <oats> parallelogram polytheism
18:16:02 <koz_> What's the name of the extension that lets you specify the package name that a module comes from?
18:16:08 <koz_> I am in that unfortunate pickle.
18:16:44 <sm[m]> PackageImports
18:16:51 <koz_> sm[m]: Thanks!
18:17:39 <sm[m]> I think it’s a good one for readability, I consider using it everywhere
18:18:02 <koz_> sm[m]: I only had to use it twice ever, and this is time number 2.
18:18:41 <infinisil> koz_: I bookmarked this page, very useful for this kind of stuff: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html
18:19:09 <koz_> infinisil: Thanks!
18:19:55 <sm[m]> in a stack script, as you add imports it’s really easy to forget to add the —package argument above. PackageImports helps there too
18:21:41 <sm[m]> Likewise for adding deps to your yaml/cabal file. Making the packages explicit in imports reduced mistakes.
18:22:10 <sm[m]> this is much less clunky in other languages though. (Java ?)
18:31:22 <ezzieyguywuf> in y'alls opinion: is there much difference in a function returning a `[a]` versus a `Maybe (NonEmpty a)`?
18:31:40 <Cale> not usually
18:31:51 <Cale> Unless I was in the middle of using Maybe as a monad or something
18:31:58 <ezzieyguywuf> Cale: that's what I was thinking
18:39:18 <infinisil> ezzieyguywuf: It would make a difference if it was mono-traversable's NonNull: https://hackage.haskell.org/package/mono-traversable-1.0.15.1/docs/Data-NonNull.html
18:40:12 <infinisil> (since the caller could then choose the non-empty type)
18:52:10 <x0r-255> how might I convert a hex string "#aaa" to a full hex string "#aaaaaa" in haskell? I've tried `bg3' = [r + r + g + g + b + b | (a,r,g,b) <- bg3]`, however to no avail.
18:52:35 <x0r-255> with a type of `[Char]` (string)
18:55:38 <ski> `a' ?
18:56:51 <x0r-255> if the string is 4 long, then it will be in the format of #rgb, but I don't care much for #, (I can add it later if need be) so a is an arbitrary variable name.
18:57:02 <ski> > let bg3 = "f3b"; bg3' = [r,r,g,g,b,b] where [r,g,b] = bg3 in bg3'
18:57:04 <lambdabot>  "ff33bb"
18:57:12 <ski> something like that ?
18:57:33 <x0r-255> exactly, thanks.
18:57:33 <ski> (i think you probably don't want to use a list comprehension, here)
19:32:53 <xsperry>  
20:28:03 <xacktm> hello, my ~/.cabal has references to old ghc versions, is there a tool to clean the cache?
20:31:13 <glguy> xacktm: I don't know of one. When I stop using a GHC version I clear out its ~/.cabal/store directory after looking through the symlinks in ~/.cabal/bin to see if I have any executables pointing to it
20:35:14 <Axman6> ezzieyguywuf: in the past we have ued Maybe (NonEmpty a) a lot to signify that either "there is a list that has values", or "there is no list", which can be semantically different to "there is a list which may be empty"
20:35:23 <xacktm> thanks, my ~/.cabal/bin is empty in my case, but good to know
20:36:04 <Axman6> while they are isomorphic, using the Maybe version can play better with things like parsers for serialisation etc.
21:23:11 <sm[m]> xacktm: ncdu is good
21:25:09 <xacktm> that's more of a general cruft overviewer, right?  not specific to ghc
21:25:31 <sm[m]> right
21:26:16 <xacktm> still, I find myself using `du` often, so I might use it, thanks :)
21:26:30 <sm[m]> but fast and effective
22:41:30 <siraben> How do "f x e = x e" and "f x = x" compile differently?
22:45:14 <shachaf> I imagine the first one takes two arguments in two registers, and the second one takes one argument in one register, or something?
22:45:46 <shachaf> And then "let y = f a" would use a generated wrapper or something in the first case.
22:45:51 <shachaf> (Assuming they're not inlined, of course.)
