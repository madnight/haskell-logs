00:14:49 * hackage uri-encode 1.5.0.6 - Unicode aware uri-encoding.  https://hackage.haskell.org/package/uri-encode-1.5.0.6 (ErikHesselink)
00:46:03 <nlhowell> Is there a form of semigroup which is "indexed" ? In the following sense: I have type T: Nat -> *; i want a flavour of semigroup where I can write (<>) :: T n -> T m -> T (n+m), and just imagine usual types T' as being ()-indexed, reducing to the usual Semigroup
01:42:20 * hackage jsaddle-dom 0.9.4.1 - DOM library that uses jsaddle to support both GHCJS and GHC  https://hackage.haskell.org/package/jsaddle-dom-0.9.4.1 (HamishMackenzie)
01:44:20 * hackage gloss 1.13.1.2 - Painless 2D vector graphics, animations and simulations.  https://hackage.haskell.org/package/gloss-1.13.1.2 (BenLippmeier)
01:50:49 * hackage gloss-raster 1.13.1.2 - Parallel rendering of raster images.  https://hackage.haskell.org/package/gloss-raster-1.13.1.2 (BenLippmeier)
01:55:20 * hackage gloss-algorithms 1.13.0.2 - Data structures and algorithms for working with 2D graphics.  https://hackage.haskell.org/package/gloss-algorithms-1.13.0.2 (BenLippmeier)
02:24:19 * hackage gloss-examples 1.13.0.3 - Examples using the gloss library  https://hackage.haskell.org/package/gloss-examples-1.13.0.3 (BenLippmeier)
03:45:02 <Orbstheorem> Hi, what's the name of the extension to make a new context that implies one or many other contexts?
03:50:48 <Orbstheorem> Found it: ConstraintKindsw
04:21:03 <kuribas> Is there a "recommended ghc version"?
04:21:12 <kuribas> one that doesn't have bugs?
04:21:58 <kuribas> I noticed stack also pins ghc versions, so using recent libraries also means using a recent ghc.
04:25:59 <Uniaika> don't they all have bugs?
04:26:02 <Uniaika> I mean
04:26:41 <Rembane> kuribas: AFAIK it is a good plan to not use the first or three versions of every "major" version. 
04:27:10 <kuribas> are bugs backported?
04:28:07 <kuribas> so 8.8.4 is ok?
04:28:13 <kuribas> but 8.8.3 not?
04:28:54 <kuribas> Rembane: by major, do you mean 8.8, or 8 ?
04:30:09 <Rembane> kuribas: I mean 8.8, I wasn't very clear on that. 
04:30:27 <Rembane> kuribas: I would use the newest minor version 
04:30:42 <kuribas> maybe I'll stick to the before latest major release.
04:30:45 <kuribas> so 8.6
04:31:14 <Rembane> Sounds like a good way to handle it. 
04:31:52 <Arahael> Alternatively... Stick to a specific version, forever.  There are no bugs, only features!
04:32:36 <kuribas> Arahael: also possible
04:33:39 <kuribas> I likely stick to a version, until it becomes to old.
04:33:53 * Arahael wasn't being serious.
04:34:16 <Rembane> Arahael: The Bob Ross route.
04:34:53 <Arahael> I don't know him.  I was actually thinking of TeX, version PI.
04:35:36 <kuribas> Arahael: it's not yet at version pi though
04:36:09 <Rembane> Arahael: TeX is cool in that regard.
04:36:26 <Arahael> kuribas: Well, Pi is an irrational number.
04:36:31 <Arahael> Rembane: Indeed!
04:37:30 <kuribas> Arahael: that's why it isn't there yet
04:37:41 <Orbstheorem> Sounds like an irrational version to me :D
04:52:19 * hackage validity-time 0.4.0.0 - Validity instances for time  https://hackage.haskell.org/package/validity-time-0.4.0.0 (Norfair)
05:13:20 <typetetris> Is there a better ui to the haskell mailinglists? mail.haskell.org isn't that great, for example I would like to see, which mailing lists had traffic in 2020 at a quick glance, rather then clicking through all of them.
05:58:31 <kuribas> I wish there was a SHADOW pragma for a variable, which would allow for shadowing of variables
05:59:12 <kuribas> without warning at least
06:00:42 <maerwald> kuribas: 8.6.5 is very solid
06:00:55 <maerwald> and widely used in production
06:01:27 <maerwald> 8.8.4 is what I would use for my OSS projects and 8.10.1 if I'm feeling lucky
06:01:37 <kuribas> there is already 10?
06:01:43 <maerwald> yeah
06:01:53 <kuribas> maerwald: it's for company production code
06:02:03 <maerwald> 8.6.5 I would use then
06:02:38 <maerwald> but also check the known bugs and whether they would affect you
06:02:55 <kuribas> right, thanks.  I am now on 8.4.4, but the stack lts seems quite old.
06:03:00 <maerwald> I believe there were fixes to code generation in 8.8.x
06:04:56 <kuribas> "code generation" is pretty general
06:05:06 <kuribas> is 8.8 supposed to be stable?
06:06:52 <maerwald> stable?
06:07:29 <kuribas> bugfree
06:07:35 <maerwald> no version is
06:07:56 <maerwald> you'll have to skim the issuer tracker for that
06:08:23 <kuribas> are bugs fixed in previous versions?
06:08:26 <kuribas> or only the latest
06:08:28 <maerwald> 8.8.4 was a minor bugfix release
06:08:54 <maerwald> you could assume it's stable, because the bugfixes were rather small
06:10:24 <maerwald> https://github.com/input-output-hk/cardano-node/blob/master/stack.yaml#L2
06:10:36 <maerwald> is also a good indicator of stability
06:11:57 <kuribas> right
06:25:54 <kuribas> yuck, writing documentation...
06:26:38 <kuribas> It takes so much time to write good documentation.
06:32:32 <Mrbuck> any one here in ocaml room? I get this error to join. freenode  -- | zettel.freenode.net: Only users using SSL could join this channel!  Can some one ask the ops to exempt it for tor users
06:38:10 <Arahael> Mrbuck: You'd probably be best to use sasl authentication, though joining IRC over tor, might leak your identity.  For network specific questions you probably should ask #freenode?
06:38:32 * Arahael is not a tor user, though.  Just trying to help.
06:41:53 <Mrbuck> Arahael:  Thank you
06:42:10 <frdg> does anyone happen to know how I can bookmark a web page at a current location within the page in firefox?
06:42:19 * hackage named-servant 0.0.2 -   https://hackage.haskell.org/package/named-servant-0.0.2 (KristofBastiaensen)
06:42:29 <Mrbuck> Arahael:  one query please?
06:42:58 <frdg> oh wrong channel
06:43:01 <Arahael> Mrbuck: Yeah?
06:43:19 * hackage named-servant-server 0.0.2, named-servant-client 0.0.2 (KristofBastiaensen): https://qbin.io/jets-isbn-60sx
06:53:20 * hackage mackerel-client 0.3.0 - An API client library for Mackerel  https://hackage.haskell.org/package/mackerel-client-0.3.0 (itchyny)
06:56:53 <sm[m]> kuribas: found any tricks to speed up doc writing  ?
07:00:28 <kuribas> sm[m]: well, in some cases, copying the structure from other docs helps
07:00:56 <kuribas> then I don't have to think so much about documentation structure...
07:01:12 <sm[m]> nod
07:01:57 <sm[m]> you saw https://documentation.divio.com/, probably
07:02:16 <kuribas> nice, I haven't
07:02:41 <sm[m]> I found that idea helpful
07:03:25 <sm[m]> I think this could be helpful too, but I haven't tried yet: have CI require doc changes in PRs
07:05:37 <frdg> I see documentation related things discussed often on here. Is there some big movement being made? What documentation is being worked on?
07:06:02 <kuribas> frdg: I would think good documentation was always a good idea :)
07:06:59 <kuribas> I see this at work, where we have a poorly documented and large system.  The time spend on documenting the system get paid back in the time new people take to learn it.
07:07:35 <kuribas> I think quality documentation is just as important as quality code, maybe even more.
07:08:49 <Rembane> frdg: There is a movement being made, see #Haskell-docs for more info. :) 
07:09:12 <kuribas> IMO haddock is one of the better documentation systems.
07:09:23 <kuribas> I don't get why people say haskell libs are poorly documented
07:09:28 <frdg> I was more wondering if current haskell documentation is considered outdated, or if updating it is just a constant thing.
07:09:49 <kuribas> frdg: clarify "haskell documentation"
07:10:04 <kuribas> libs? ghc? language standard? extensions?
07:10:10 <frdg> I was thinking the wiki and base libraries
07:10:28 <kuribas> I rarely go to the wiki, but base libraries are well documented IMO.
07:10:52 <kuribas> They contain the necessary information and no more.
07:11:31 <kuribas> unlike, say Python, where you get libraries with walls of text, but the necessary information is missing.
07:16:49 * hackage github-release 1.3.4 - Upload files to GitHub releases.  https://hackage.haskell.org/package/github-release-1.3.4 (fozworth)
07:17:01 <ADG1089__> While building package mysql-0.1.7 using: ... Process exited with code: ExitFailure 1?
07:18:08 <Rembane> One of the more interesting parts of Haskell source code and docs is that what you see is what you get, when you know the laziness semantics.
07:18:38 <kuribas> Rembane: what has lazyness to do with documentation?
07:20:28 <frdg> ADG1089: I had issues with building persistent-postgresql and the solution was to install a ghc package for postgres support. You may want to paste the exact error though.
07:20:54 <maerwald> kuribas: everything
07:21:00 <int-e> ADG1089__: that's not the error. I suspect you're seeing something like 'setup: The program 'mysql_config' is required but it could not be found' in which case the answer is what frdg wrote
07:21:20 <kuribas> maerwald: are you sure?  everything is a lot
07:21:27 <maerwald> laziness is a property, not a guarantee
07:21:45 <Rembane> 0.96*everything
07:21:54 <ADG1089__> shall i paste the error here?
07:22:01 <maerwald> laziness properties must be documented
07:22:04 <int-e> ADG1089__: no, use a pastebin
07:23:05 <ADG1089__> here: https://hastebin.com/dicomizobi.rb
07:24:20 <int-e> does stack really suppress the relevant information like that?
07:24:48 <int-e> I'd hope that there's information further up.
07:25:23 * ski . o O ( "What nobody tells you about documentation" by Daniele Procida in 2017-05-19 at <https://web.archive.org/web/20200202173927/https://www.divio.com/blog/documentation/> )
07:25:26 <ADG1089__> I ran `stack install mysql` and it said ssl and crypto are required
07:25:36 <ADG1089__> it didn't came with stack build
07:26:57 <maerwald> ski: yeah, but even he missed a few ðŸ˜…
07:27:50 <maerwald> it's all about audience 
07:28:50 <kuribas> ski: that's the same as what sm[m] posted?
07:29:39 <maerwald> Explanation? For whom? API user, contributor, maintainer, someone trying to understand the architecture? The latter might be less interested in what functions do, but in an architecture decision backlog
07:30:44 <ski> kuribas : oh, yes. i just noticed it was linked to, earlier
07:30:46 <maerwald> Someone else might want to understand how code relates to features/tickets
07:30:51 <ski> maerwald : missed a few what ?
07:31:23 <maerwald> Types of documentation
07:32:04 <frdg> ADG1089: I suggest making a paste of the full error that you are getting
07:33:20 <sm[m]> discussion of that link: https://news.ycombinator.com/item?id=21289832
07:34:33 <ADG1089__> mysql> setup: Missing dependencies on foreign libraries:
07:34:34 <ADG1089__> mysql> * Missing (or bad) C libraries: ssl, crypto
07:35:40 <sm[m]> These are c libraries you must install with your OS package system ADG1089__
07:35:56 <ADG1089__> can't seem to find the relevant ones on homebrew
07:36:22 <sm[m]> brew search openssl maybe
07:38:29 <ADG1089__> i installed that one
07:39:00 <Arahael> Isn't brew's openssl bottled or something? (Ie, it's not in a "standard" location)
07:39:54 <sm[m]> Then maybe you need to add cabal/stack config/options like â€”extra-lib-did
07:40:00 <sm[m]> dir
07:40:05 <ADG1089__> yes I found relevant solution here: https://qiita.com/minarai/items/9848973045a86261808b
07:40:13 <ADG1089__> some parts in japanese
07:40:45 <ADG1089__> suggest to edit ~/.stack/config.yaml
07:40:53 <sm[m]> Thatâ€™s it
07:42:01 <ADG1089__> just trying yesod to see the difference from flask_restx (python)
07:42:14 <ADG1089__> for making rest apis
07:45:19 * hackage hercules-ci-api-agent 0.2.2.0 - API definition for Hercules CI Agent to talk to hercules-ci.com or Hercules CI Enterprise  https://hackage.haskell.org/package/hercules-ci-api-agent-0.2.2.0 (RobertHensing)
07:45:38 <ADG1089__> shouldn't liftIO be called fromIO ?
07:46:11 <ADG1089__> I interpret lifting as a -> m a and if we are doing IO a -> m a wouldn't that be at the same level?
07:46:30 <Arahael> I think of it as "to" IO.
07:53:49 * hackage hercules-ci-agent 0.7.3 - Runs Continuous Integration tasks on your machines  https://hackage.haskell.org/package/hercules-ci-agent-0.7.3 (RobertHensing)
09:03:29 <Orbstheorem> I'm looking for a way to establish a bijective relationship between Types and a String. I have a bunch of types `data Foo = Foo`, `data Bar = Bar` and I want to associate them with strings "Foos" and "Bars" such that, if I have the string "Foos", I can retrieve the type Foo (through a proxy?) and if I have the type Foo, I can retrieve the string "Foos" through type applications (which I currently do via
09:03:30 <Orbstheorem> AllowAmbiguousTypes and a typeclass with a string member).
09:04:16 <kuribas> Orbstheorem: but how do you know all possible types?
09:04:40 <kuribas> Orbstheorem: there is no way for haskell to know types which don't exist yet.
09:05:00 <kuribas> Orbstheorem: the best you can do is make a list with existentials.
09:05:13 <Orbstheorem> For the moment I have a sum type summing them up.
09:06:17 <Orbstheorem> What do you mean by list with existentials?
09:06:28 <kuribas> a sum type will do as well
09:06:36 <kuribas> but it looks like an overcomplicated solution
09:07:51 <monochrom> As usual, the really important information is "how will you use these 'types'?" and is always missing.
09:08:45 <Orbstheorem> I'm also associating Foo and Bar using an ambiguous typeclass to my sum type.
09:09:06 <dmj`> yea, this doesn't sound like a good idea. Converting the string representation of a type to a type sounds like you're going against the grain of the type system.
09:09:14 <dmj`> Orbstheorem: what are you attempting to accomplish here
09:09:55 <Orbstheorem> I need to associate a string, because that string corresponds to an URL fragment.
09:10:18 <Orbstheorem> And Foo and Bar live in different modules out of my control.
09:10:26 <dmj`> Orbstheorem: are the URLs statically known?
09:10:40 <dmj`> Or are they dynamic, only known at runtime
09:10:55 <Orbstheorem> They are statically known
09:11:03 <monochrom> For example, "once I get a type, I'll use it to get a default value" is a very different problem, and admits a very different solution, from "once I get a type, I use that type to unsafeCoerce my value".
09:11:15 <dmj`> Orbstheorem: why do you need to associate a data type with them
09:11:51 <Orbstheorem> So, when I have the type, I can see which instance of a type family to use.
09:12:34 <dmj`> Orbstheorem: are you issuing requests with the URLs and then deserializing the request bodies into Foo/Bar ?
09:13:07 <monochrom> Do you really need to "see"? Or do you just need to go ahead and use? Because the latter can be done by existential quantification, without "seeing".
09:14:32 <dmj`> Orbstheorem: you should check out servant-client, it does exactly this
09:15:14 <Orbstheorem> dmj`: Yep. My associated type has a function like `deserialize :: forall c. Body -> Maybe (Fam c)` and I type-apply the c that I'm expecting.
09:17:04 <dmj`> Orbstheorem: have you seen servant-client? It uses an open type family to associate type level Symbols with data types, and enforces instances to be defined, and uses them to construct parsers and IO actions to perform requests (with proper deserialization)
09:17:29 <Orbstheorem> Not that part, taking a look.
09:18:14 <dmj`> Orbstheorem: I have a presentation that is extremely good on how to implement servant-client from scratch
09:18:22 <dmj`> Orbstheorem: https://github.com/dmjio/servant-from-scratch/blob/master/Main.lhs#L19 
09:18:32 <Orbstheorem> Wonderful
09:18:36 <dmj`> it takes a detour through GHC.Generics as well
09:18:47 <dmj`> and now has a bonus section on implementing servant-server
09:18:54 * Orbstheorem has been trying to avoid GHC.Generics :s
09:19:18 <dmj`> Orbstheorem: Please don't! Avoid GADTs and existential quantifications instead.
09:19:36 <Orbstheorem> Yep, also in my blacklist xD
09:20:10 <c_wraith> GHC.Generics makes no sense to me.  Data.Data is easier for me to work with.
09:20:11 <dmj`> Orbstheorem: GHC.Generics is the only good use of type level programming for modern haskell development, since its about eradicating boilerplate. Servant is just a specialized version of GHC.Generics for web programming
09:20:44 <kuribas> well, Servant uses the same techniques as GHC.Generics
09:20:49 <kuribas> but it doesn't use Generics itself
09:20:59 <dmj`> kuribas: exactly :) servant *is* GHC.Generics in disguise
09:21:03 <dmj`> but shhhh
09:21:11 <kuribas> though my new named-servant library does use Generics :)
09:22:00 <Orbstheorem> Oh, right. So what I'm trying to avoid is writing quasi-quoters and template-haskell because nobody will be able to maintain it x)
09:23:05 <dmj`> Orbstheorem: avoid GADTs since it makes introducing existentials very easy. Existentials hide types from GHC and force you to carry a witness around to prove anything. GADTs also make it very difficult to derive anything. Using GHC.Generics and DerivingStrategies is good form. 
09:23:45 <dmj`> Orbstheorem: TemplateHaskell is the certain death if you want to cross compile Haskell. 
09:24:33 <dmj`> Orbstheorem: I have a package that uses a preprocessor to manipulate a Haskell module to rewrite lens TH splices into pure lens functions so TH can be avoided. 
09:24:36 <Orbstheorem> (About existentials): I just spent a couple of hours studying that nightmare: https://paste.gnugen.ch/raw/Y4Wj
09:24:50 <kuribas> And the Generics-Eot library is nice if it suits your needs.
09:25:01 <kuribas> https://hackage.haskell.org/package/generics-eot-0.4.0.1/docs/Generics-Eot.html
09:25:09 <c_wraith> I just write lenses by hand, because it's not really any slower than writing the TH, and when you count compilation time it's a lot faster.  >_>
09:25:16 <kuribas> not as general as GHC.Generics, but much easier in many cases.
09:25:22 <dmj`> Orbstheorem: yes, keep your type variables present on both the left and right hand side of a definition, data Coco = forall a. (Fam a, Show a) => Coco {rescue :: Wrapped a} is very bad news
09:26:00 <dmj`> Orbstheorem: you can now derive lenses with GHC.Generics using generic-lens
09:26:38 <dmj`> Orbstheorem: Generics is the most underrated part of GHC Haskell, by far.
09:27:12 <dmj`> Or if you want to waste a lot of time and money, use existentials
09:27:13 <Orbstheorem> To be clear, the comment about lenses does not apply to my original question (bijection) right?
09:27:31 <dmj`> Orbstheorem: no, it applies to your comment about avoiding TH though
09:27:37 <Orbstheorem> Right
09:27:44 <dolio> I used existentials in my code and it didn't cost any money.
09:27:57 <Orbstheorem> allnighters then? :D
09:29:24 <c_wraith> existentials are fine when when they aren't also packing up a class instance.
09:29:40 <Orbstheorem> (To be fair, I'm not trashing a language feature, I'm just making fun of the fact that when I read about them I thought they were a magical solution, but fortunately I took the time to study it because it would only have brought more problems to my particular problems.)
09:29:42 <c_wraith> That's the main rule of thumb.  If you're packing up an instance, you're in trouble.
09:29:56 <c_wraith> If you're using an existential in some other way, you're fine.
09:31:09 <dolio> I don't really see the problem with pairing them with constraints, either, in general.
09:31:13 <dmj`> Orbstheorem: Mature haskell programmers know when *not* to use something. So go ahead and experiment, and then choose /not/ to do it ever again.
09:31:50 <c_wraith> dolio: it's mostly that the ergonomics are better if you're just using a record in that case.
09:33:29 <dolio> I probably wouldn't define a class just to use it with existential types.
09:33:44 <dmj`> > data Foo = forall a . Show a => Foo a; value = [ Foo "hey", Foo 3 ]
09:33:46 <lambdabot>  <hint>:1:1: error: parse error on input â€˜dataâ€™
09:34:14 <dmj`> this is just laziness (not the good kind) imo. You should know the gamut of things you want to represent, not leave it up to some type class instance
09:34:18 <c_wraith> dmj`: how is that better than ["\"hey\"", "3"] ?
09:34:20 <dmj`> and now you cannot derive any instances for Foo
09:34:47 <dmj`> c_wraith: they're both terrible
09:35:12 <EvanR> stringly typed programming
09:35:35 <dmj`> the types just get heavy, and people want to cut corners and get all fancy, and they pay the price in the long term
09:36:36 <dmj`> a genius is someone who can solve the problem with the least amount of type level extensions, without sacrificing too much performance
09:37:16 <dmj`> and doesn't hide behind an obscure extension to hide their lack of domain knowledge
09:37:28 * dmj` gets off soapbox
09:38:37 <dolio> You can do everything in Haskell 98. That doesn't mean that using some other stuff won't make it nicer.
09:41:38 <kuribas> typelevel stuff is nice when hidden in libraries
09:46:13 <c_wraith> It's even fine when it does stuff that can't be done without it.  (Not in the Turing sense, in the ergonomic sense.)  Still waiting on a proper printf putting the format string in the type and computing the necessary args from that.
09:46:38 <c_wraith> (There are proofs of concept of that, but none that are really intended to be used)
09:46:54 <kuribas> c_wraith: or don't use printf at all?
09:47:15 <c_wraith> Why not?  It's great.  Or it would be if it was type safe.
09:47:21 <kuribas> use formatting?
09:47:41 <c_wraith> I said "ergonomics".  I wasn't kidding.
09:48:00 <kuribas> I suppose we do need dependent types.
09:48:19 <dolio> printf seems pretty overrated to me.
09:48:36 <c_wraith> We don't need full dependent types.  GHC has all the tools necessary already, though Symbol is very awkward.
09:48:49 <c_wraith> promoting Char would be a lot better.
09:49:38 <dolio> Like, there are other languages that have stuff strictly better than printf, and they would probably be doable with quasiquoters.
09:50:37 <dolio> E.g. scala has formatting strings where you just put the expression yo want to format directly in the string, instead of using some obscure formatting syntax and having to match it to a corresponding argument of the function.
09:50:49 <c_wraith> I've never seen something strictly better than printf.
09:51:10 <dolio> Like shell interpolation.
09:51:21 <c_wraith> How does that specify *formatting*?
09:51:37 <__monty__> dolio: Python has that too now, I think.
09:52:29 <c_wraith> Oh, I see.  Scala has an additional special string form that interpolates with formatting that uses... printf formatting.
09:52:56 <kuribas> c_wraith: type level programming in haskell is extremely awkward.
09:54:34 <dolio> Are you just talking about the format specification of printf, not the interpolation part?
09:55:01 <c_wraith> that's the useful part, yes.
09:55:11 <dolio> I see.
09:56:44 <c_wraith> and sure, you can do that with a quasiquoter, but something that doesn't destroy compilation time would also be nice.
09:57:26 <dolio> I guess I agree with that. It's mainly the interpolation part that I think is seriously overrated.
09:57:42 <dolio> And it's most of the complication.
10:00:04 <kuribas> c_wraith: what's wrong with formatting?
10:01:37 <c_wraith> it's a lot more typing to describe the same formats.
10:01:42 <c_wraith> and that really does matter
10:03:31 <__monty__> But all those obscure formats? How many people know "g?"
10:05:01 <MarcelineVQ> c_wraith: so is what you're after, given  :t printf "%s, %d, %.4f"   you'd like to see   printf "%s, %d, %.4f" :: String -> Integer -> Double -> String    ?
10:05:42 <redmp> srhb: i made an issue https://github.com/ucsd-progsys/liquidhaskell/issues/1710
10:05:43 <MarcelineVQ> Or did you mean the format string itself is in the type?
10:05:48 <redmp> thanks for your help
10:05:57 <c_wraith> yes, though *that* would require pi types.  I'd be happy with requiring  printf @"%s, %d, %.4f"  instead
10:06:36 <MarcelineVQ> ah that @ wouldn't be too bad an option
10:16:42 <kuribas>  <c_wraith> We don't need full dependent types.  GHC has all the tools necessary already
10:16:46 <kuribas> the tools suck so much
10:17:12 <kuribas> Typelevel programming is a frankenstein monster
10:17:38 <kuribas> it's ok if it's hidden in a library, but it's far from easy or elegant.
10:20:24 <c_wraith> my point was that you can hide the mechanics in the library and still have it expose things that wouldn't be possible without it.
10:24:49 * hackage commonmark 0.1.0.0 - Pure Haskell commonmark parser.  https://hackage.haskell.org/package/commonmark-0.1.0.0 (JohnMacFarlane)
10:25:50 * hackage commonmark-cli 0.1.0.0, commonmark-pandoc 0.1.0.0, commonmark-extensions 0.1.0.0 (JohnMacFarlane)
10:27:14 <Guest21344> Listen here, jack
10:27:18 <Guest21344> How do I foldM
10:27:57 <dmj`> dolio: sure, if there is a proper use of existential types, I'd like to see it, but using it has always disadvantaged me more than it was worth. Haskell 98 is great, my ideal language would be a subset of Haskell 2010 layered on Haskell 98.
10:28:10 <dmj`> :t foldM
10:28:11 <lambdabot> (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m b
10:29:08 <syd> Does anyone here have haskell.nix experience and 15min to help me with https://github.com/input-output-hk/haskell.nix/issues/768 please?
10:29:29 <dmj`> > foldM (\b a -> pure (a:b)) [] [1..10]
10:29:31 <lambdabot>  error:
10:29:31 <lambdabot>      â€¢ Ambiguous type variable â€˜m0â€™ arising from a use of â€˜show_M394429552409...
10:29:31 <lambdabot>        prevents the constraint â€˜(Show (m0 [Integer]))â€™ from being solved.
10:29:49 <dmj`> > (foldM (\b a -> pure (a:b)) [] [1..10]) :: [Int]
10:29:51 <lambdabot>  error:
10:29:51 <lambdabot>      â€¢ Couldn't match type â€˜[Integer]â€™ with â€˜Intâ€™
10:29:51 <lambdabot>        Expected type: [Int]
10:30:47 <dmj`> syd: you can't override boot packages with nix
10:31:00 <dmj`> syd: then come caked into the GHC that nix delivers
10:31:08 <dmj`> they*
10:31:21 <syd> dmj': so there's just no way to get this working? How does stack get this working?
10:31:59 <dmj`> attempts at using multiple packages in the same package list will cause a serious compile time warning from Cabal
10:32:20 <dmj`> syd: You'll need to let stack procure your ghc
10:32:27 <syd> yeah! that makes sense but somehow stack makes it work
10:32:30 <dmj`> syd: or use a later ghc w/ nix
10:32:38 <dmj`> syd: or just don't use stack
10:32:39 <syd> there's no later ghc that uses time-1.10 yet
10:32:57 <dmj`> syd: there is one option that I haven't tried, that might work
10:32:59 <syd> when I use stack, it works. It's nix that fails to build this :p
10:33:40 <raehik> Quick question, I'd like to use a type-level vector. I found a number of pkgs and implementations after searching around. Is there a standard/recommended one? (looking at vec)
10:34:15 <dmj`> syd: override ghc to use a newer hash
10:34:39 <syd> raehik this smells like an XY problem.  You probably shouldn't be using a type-level vector. Why do you want to? (I don't know which one you would use either, to answer your question.)
10:34:47 <syd> dmj' how would that work in practice?
10:34:55 <dmj`> @package sized-vector
10:34:55 <lambdabot> https://hackage.haskell.org/package/sized-vector
10:35:44 <dmj`> pkgs.haskell.compiler.ghc8103.override { rev = "..."; } something like this
10:36:01 <dmj`> syd: why use stack w/ nix ?
10:36:05 <raehik> syd: fair point. Want to make a set of functions which take a list of dimensions (axis sizes). Want generic functions that work on any dimensions, and specific ones for e.g. 2D
10:36:39 <syd> dmj' I'm not using stack with nix. I'm using stack for dev and nix for deployment, and haskell.nix so I don't have to keep two different ways of building in sync.
10:36:40 <raehik> I don't need the type-level guarantees, but it would let me write a bit less and a bit safer code
10:36:56 <syd> raehik have a look at easytensor
10:37:09 <syd> that's not a type-level vector btw. That's a vector with type-level size.
10:39:03 <raehik> syd: That's probably better suited. Thanks!
10:40:11 <syd> dmj when I'd use this override, I'd have to go update the submodule in a fork of the ghc etc. I'd like to know how stack manages to do this
10:44:59 <dmj`> stack uses stack.yaml to fetch a ghc
10:45:53 <syd> yes but it also uses the correct version of `time` when I put `time` in the extra-deps
10:47:09 <monochrom> stack uses default or your config files to determine a "resolver version". That version in turn nails one single version for GHC and all library packages.
10:47:40 <syd> monochrom well clearly there's something more to it
10:47:57 <syd> unless you're suggesting it has a cached version of every possible ghc with any possible combination of boot libraries that I may override
10:48:52 <monochrom> Ah OK, I didn't read scrollback, didn't notice you're overriding something.
10:49:30 <Guest21344> Could anyone explain to me how to "add a flag" to Cabal?
10:49:40 <monochrom> That's vague.
10:49:49 <monochrom> Many different kinds of "flags".
10:49:58 <Guest21344> A flag of any kind. I don't know what it looks like.
10:50:07 <infinisil> dmj`: I think you might be thinking of nixpkgs' haskell tooling, which is entirely different than haskell.nix's tooling
10:50:12 <Guest21344> -Wno-tabs, eg.
10:50:30 <monochrom> You can call that "ghc flag".
10:50:49 <monochrom> in your *.cabal file, use "ghc-options:"
10:50:51 <dmj`> infinisil: possibly, but I believe that the ghc derivation includes the boot pkgs in both nixpkgs haskell and haskell.nix
10:51:25 <Guest21344> Hallelujah. Thanks, mono. I don't know why this was so hard to find.
10:51:40 <infinisil> dmj`: I'll answer syd in #haskell.nix, it's possible to make it not use the boot packages
10:52:16 <monochrom> I don't know. One day in the past, I spent an hour or two reading the cabal user guide from cover to cover. That's how I knew.
10:52:34 <monochrom> in fact, make it s/spent/devoted/
10:52:39 <dmj`> infinisil: is it? I know GHC itself imports Data.Time everywhere
10:53:07 <monochrom> Very valuable investment if you ask me.
10:56:05 <infinisil> dmj`: cabal-install even relies on having non-boot Cabal versions
10:56:13 <infinisil> As an example
10:56:20 <monochrom> Sometimes I give ungooglable homework to my students. Sometimes I'm even evil, I make it googlable but I use the wrong keywords so they find the wrong hits.
10:57:01 <monochrom> Example of the latter: I gave them the probability monad, I called it "random monad".
10:57:33 <infinisil> Hehe nice monochrom 
10:57:49 <monochrom> And recently, I accidentally gave them a googlable question on a test, but it comes out perfect because stackoverflow is full of wrong solutions to that problem.
10:57:53 <dmj`> infinisil: I still don't think it's possible to override time w/o compiling a new GHC that uses that time.
10:58:42 <monochrom> My question was this: (C programming) How do you detect eof on stdin?
10:59:14 <monochrom> stackoverflow wrong solution: use fseek, then ftell. Yes, the answerers even use that on stdin.
11:02:06 <oats> monochrom: getchar() == EOF
11:02:08 <oats> ?
11:02:11 <monochrom> Yeah!
11:02:21 <oats> \o/
11:02:27 <oats> my C hasn't yet left me
11:05:16 * MarcelineVQ pushes feof and read under the rug
11:10:12 <syd> dmj' I got something working! 
11:13:47 <dmj`> syd: how'd ya do it
11:14:18 <dmj`> I'm skeptical
11:17:49 * hackage rib 0.12.0.0 - Static site generator based on Shake  https://hackage.haskell.org/package/rib-0.12.0.0 (sridca)
11:17:53 <syd> https://github.com/NorfairKing/smos/tree/dependency-upgrade
11:22:37 <dmj`> syd: did you reinstall ghc
11:22:42 <syd> nope
11:25:48 <dmj`> syd: what does ghc-pkg list show ?
11:26:04 <syd> Not sure where I'd run that. I don't have cabal
11:29:22 <monochrom> The risk of using a works-99%-of-the-time abstraction such as stack.
11:29:51 <monochrom> i.e., in the remaining 1%, it's too opague to be trouble-shot.
11:29:54 <dmj`> syd: you don't need cabal to run that
11:30:28 <dmj`> syd: ghc-pkg comes with all ghc installations
11:30:34 <monochrom> Ah but since stack owns its private copy of GHC, you first have to dig out where that GHC is.
11:30:35 <dmj`> syd: can you try stack exec -- ghc-pkg list
11:30:38 <syd> https://pastebin.com/XRJMyWea
11:31:05 <monochrom> onoes, nix and stack?
11:31:08 <dmj`> syd: it seems you have a globally installed ghc
11:31:16 <syd> yeah that too
11:31:20 <syd> I have about 20 probably
11:31:23 <syd> nixos .. :p
11:31:26 <dmj`> syd: can you try the stack command I gave
11:31:31 <monochrom> I use neither, but I heard from nix users and stack users that you should choose one of them.
11:31:37 <dmj`> syd: I wouldn't recommend installing compiler tools in your global environment
11:31:39 <evanjs> this ^^^^^
11:31:46 <syd> https://pastebin.com/fbs5Zk7W
11:31:56 <syd> I need `ghci` to _just work_ for quick calculations
11:32:04 <dmj`> oof
11:32:11 <dmj`> I'm not convinced you have the latest time version
11:32:20 <evanjs> I remember going through this a while ago -- https://functor.tokyo/blog/2018-02-16-setup-xmonad-on-nixos
11:32:26 <evanjs> wayyyyyyyyyyyy happier now just doing things with nix
11:32:33 <dmj`> syd: why do you need a newer time anyways
11:32:48 <syd> `stack haddock time` clearly builds `time-1.10`
11:32:54 <syd> because 1.9.3 contains an important bug
11:33:30 <syd> `time> Registering library for time-1.10..`
11:33:35 <monochrom> If you choose stack, you don't call ghci by hand, you go through stack again, something along "stack repl" or "stack exec -- ghci", I don't know which.
11:33:50 <monochrom> The risk of using a works-99%-of-the-time abstraction such as stack.
11:33:51 <syd> it's not for a project
11:33:59 <syd> for quickly doing some calculations
11:34:00 <syd> I use ghci
11:34:18 <syd> it's for when I don't have any deps
11:34:35 <syd> and just want to run `sum $ map (uncurry (*)) [...]`
11:34:43 <monochrom> I used to think that too, for cabal.
11:35:03 <monochrom> But one day someone taught me "cabal repl" still works without any notion of "package" or "project".
11:35:08 <dminuoso> monochrom: Honestlz, if you use cabal you too don't call ghci by hand. You go through cabal again, something along `cabal repl` :D
11:35:12 <monochrom> I assume stack can do the same.
11:35:21 <monochrom> Yeah, that.
11:35:34 <syd> stack takes 2seconds to start :)
11:35:45 <monochrom> Well, if I only use libraries that come from GHC, ghci suffices, but yeah, cabal repl doesn't hurt either.
11:35:50 <MarcelineVQ> it can, and you specify extra packages similarily,   --package for stack   -b for cabal
11:35:58 <monochrom> The price of using any abstraction at all.
11:36:32 <monochrom> Actually I'm naughty, I install some libraries by "cabal v1-install", so ghci still sees them.
11:37:29 <monochrom> I can't dictate to you what to do. But logically, if you use both nix's ghc and stack, know that they don't know each other.
11:37:48 <monochrom> well, unless you go out of your way to reconfigure stack to know nix's ghc.
11:38:32 <monochrom> This is what's wrong when every program thinks that it has a monopoly on all of your programs.
11:38:39 <syd> no worries, I know what I'm doing there :)
11:39:37 <dmj`> syd: you can build boot packages, but it will use the boot packages that ghc was built with to build your project
11:39:58 <syd> evidently not :P
11:40:23 <dmj`> I'm not convinced
11:40:27 <syd> otherwise my tests wouldn't pass
11:40:55 <dmj`> You're probably using stack only then, and not nix
11:41:05 <syd> if I remove the lines from the `extra-deps` then my tests fail. When I don't, then they don't.
11:41:20 <syd> and this happens when I run `nix-build`
11:42:39 <dmj`> you might be able to get it to work with stack build, but not with nix-build
11:42:52 <syd> this is with nix-build
11:44:46 <dmj`> why would nix-build care about stack.yaml
11:44:53 <syd> because I'm using haskell.nix
11:45:00 <monochrom> One day I ought to get drunk and write this ranting article: "stack: one-stop shopping or tyranny?"
11:45:24 <MarcelineVQ> spell it tearanny
11:45:37 <syd> monochrom: what's the problem with using stack?
11:45:41 <dmj`> syd: I don't buy it
11:45:51 <syd> dmj' that's ok :p  It works for me :shrug:
11:46:07 <monochrom> I guess you'll have to wait for me to get drunk.
11:46:20 <orion> Hi. What's the successor, if any, to distributed-process?
11:46:57 <ja> monochrom: do you have a newsletter? i'd like to subscribe to your drunk writings
11:47:39 <dmj`> syd: do you know how and why it works?
11:48:00 <syd> yeah
11:48:03 <dmj`> orion: there is none, why
11:48:07 <syd> well not the boot modules
11:48:07 <dmj`> syd: can you explain to me
11:48:09 <syd> but therest
11:48:34 <sm[m]> yes what's with the automatic stack put-downs every time it gets mentioned ? it has been going a long time now
11:50:01 <syd> haskell.nix builds a nix pkgsset from my stack.yaml
11:50:32 <syd> that includes the new time one
11:50:33 <dmj`> stack represents a divergence in the community w/o consensus for corporate reasons, nix luckily saved us from that drama
11:51:03 <dminuoso> dmj`: That sounds a bit silly.
11:51:16 <sm[m]> that's, like, your opinion man
11:51:38 <sm[m]> now it's 2020, could we all agree we are blessed with multiple fine, imperfect tools each with areas of usefulness
11:52:08 <dminuoso> stack's goal is different from nix.
11:52:29 <dminuoso> (or cabal v2-* for that matter
11:52:42 <dminuoso> Which we can pretend to be a subset of nix.
11:52:50 <dminuoso> At least in spirit.
11:53:32 <dmj`> stack and cabal are no different imo, the only thing I appreciate stack for is its curated package lists
11:53:41 <dmj`> dminuoso: I agree, it was silly
11:54:01 <dminuoso> They are different in that stack provides you with a curated resolver, in which versions are sort of guaranteed to all work with each other.
11:54:21 <dmj`> right, that is separate from stack itself though
11:54:39 <dmj`> and that is valuable I believe, nix relies heavily on that
11:54:52 <dmj`> but the stack binary itself isn't necessary
11:55:02 <dmj`> esp. w/ cabal
11:56:53 <sm[m]> I still far prefer the stack binary to the cabal binary for my needs, that doesn't mean I constantly tell people on IRC that cabal shouldn't exist
11:57:12 <dminuoso> I say we're lucky to have both. 
11:57:15 <dmj`> sm[m]: I don't even use cabal :) 
11:57:18 <sm[m]> right
11:57:23 <dminuoso> And best of all, if you're a stack user in most cases cabal users can still use it.
11:57:58 <dminuoso> That is, cabal users can usually compile your stack project as long as you ship the .cabal file.
11:57:58 <dmj`> runghc Setup.hs subsumes all stack / cabal functionality
11:58:29 <dminuoso> dmj`: Does it? What about dependencies?
11:59:00 <dminuoso> Or native libraries?
11:59:02 <dmj`> sm[m]: I didn't tell anybody not to use it, or that it shouldn't exist, it's just not necessary compared to what has existed for decades prior
11:59:03 <monochrom> runghc Setup.hs doesn't do v2 things
11:59:18 <dmj`> dminuoso: conflating the curation process with the build tool, I'm delineating between those two things
11:59:50 <dminuoso> dmj`: They are intertwined.
11:59:54 <sm[m]> dmj`: it's just a recurring theme here on #haskell, I'm pretty tired of it
11:59:56 <sm[m]> not your fault
12:00:05 <dminuoso> Consider something like `--enable-optimizations`. You want this to propagate into dependencies usually.
12:00:14 <dmj`> sm[m]: yea I mean, people can use whatever they want, I use bash functions on runghc :P 
12:00:21 <monochrom> Well, I started it, so I should answer.
12:00:39 <dminuoso> I mean honestly, if `runghc Setup.hs` is all you need, then that's great.
12:01:02 <dmj`> dminuoso: yea I do that with nix, nix + runghc is great. Works great with ghcid as well.
12:01:20 <monochrom> But first, I don't put-down at every mention. Only when my criticism explains the cause of the problem.
12:01:44 <dmj`> dminuoso: stack and cabal are just build runners, if you're using nix, you should never rely on cabal's resolver or stack to fetch and install dependencies, from Haskell or third-party
12:01:59 <dminuoso> I use nix, but I refuse to build my haskell projects with it for so many reasons.
12:02:08 <dminuoso> cabal v2-* addresses all my needs perfectly
12:03:02 <monochrom> One criticism is what I already explained. An abstraction that works only 99% (or something) of the time. This is a risk because in the 1% that you need to trouble-shoot or spoon-feed the computer, it puts up hurdles.
12:03:19 * hackage shake-plus 0.3.0.0 - Re-export of Shake using well-typed paths and ReaderT.  https://hackage.haskell.org/package/shake-plus-0.3.0.0 (locallycompact)
12:03:51 <monochrom> Another is a criticism on the culture of the users. Please allow me to conflate the program and the user culture, as you all do to Haskell the language and Haskell the culture.
12:04:46 <monochrom> The culture of stack users is exactly of the anti-diversity kind you spoke against. They blog like "just use this stack command", "just run this #! /usr/bin/env stack script", without caring about other users.
12:05:05 <monochrom> Yes they secretly wish cabal doesn't exist.
12:05:07 <sm[m]> I'm not accusing anyone in particular. We're all guilty of it for certain tools, sometimes it's fun. It's just a recurring pattern here. In the case of stack, you critics tend to ignore  or are unaware of some of its very real benefits especially for beginners. Let's criticise real weakness and acknowledge real strengths and not just reflexively bash
12:05:48 <sm[m]> nor project our particular negative interpretations of reality
12:06:19 * hackage dobutokO-effects 0.11.0.0 - A library to deal with SoX effects and possibilities  https://hackage.haskell.org/package/dobutokO-effects-0.11.0.0 (OleksandrZhabenko)
12:07:08 <sclv_> a criticism i would level is that as someone who used to spend a lot of time trying to help people with tricky install and setup problems, often someone would jump in to any thread about any problem (or irc convo or stackoverflow question) and say "use stack".
12:07:19 <sclv_> and well if stack actually solved the problem, fine
12:07:51 <sclv_> but it virtually never did, because the problem was about some sort of binary compatibility issue or encoding issue or fundamental conceptual issue or a package too bitrotted to be built by any recent ghc, etc
12:08:04 <monochrom> Yeah, that, I forgot.
12:08:12 <sm[m]> sclv_: sure, most promising tools go through that phase. nix, eg.
12:08:18 <sclv_> so now the person i was trying to help had two problems -- 1) the original problem and 2) some new tool that they understood even less than the first tool they didn't understand
12:08:31 <sm[m]> we get too partisan, both pro and con
12:08:45 <sclv_> i mean if the question was "how do i have a vetted and pinned set of packages" then fine
12:08:59 <monochrom> When stack is not mentioned, someone puts-up stack. How about that?
12:09:13 <ja> sclv_: but how does stack not solve compatiblity issues? stackage is consistent with itself, no?
12:09:25 <sclv_> but like imagine going into a discussion about how to design a fly-by-wire system for an aircraft and the difficulties of numerical analysis
12:09:34 <sclv_> and saying "use haskell"
12:09:53 <ja> that's not a fair comparison since often switching build systems is not that hard
12:10:06 <sclv_> the point is that "use stack" did not solve their problems
12:10:18 <sclv_> it meant they got confused by having to learn a new tool which  left them with the same probblem
12:10:32 <sclv_> because people did not listen and think about what the problem was
12:10:53 <sclv_> like if you spell "module" as "mdoule" at the top of the file, i don't care what build tool you use, it wont compile
12:11:00 <sm[m]> sclv_: you made your point, that doesn't mean stack is never a good solution right
12:11:19 <sclv_> why would you think i was even implying that?
12:11:34 <sclv_> i literally just said "i mean if the question was "how do i have a vetted and pinned set of packages" then fine"
12:11:35 <frdg> how do imports effect performance?
12:11:47 <sm[m]> I'm asking if you agree
12:11:49 <sclv_> import statements themselves don't hurt
12:12:09 <sclv_> linking in a lot of deps can bloat binary size
12:12:18 <ja> imports can hurt in ghci, no?
12:12:19 * hackage reflex-dom-pandoc 0.2.0.0 - Render Pandoc documents to HTML using reflex-dom  https://hackage.haskell.org/package/reflex-dom-pandoc-0.2.0.0 (sridca)
12:12:20 <sclv_> and that can hurt runtime pref, but only modestly
12:12:31 <sclv_> nobody should care about performance in gci
12:12:33 <sclv_> ghci
12:12:39 <sclv_> ghci is _always_ slow because it is interprreted
12:12:52 <sclv_> sm: i dont know what you're asking me to agree with. i said what i said
12:13:02 <monochrom> "import" is the wrong tree to bark up.
12:13:42 <monochrom> unoptimized code is the one hurting performance.
12:14:12 <sclv_> now a particular thing you import and use may itself be optimized or not...
12:14:24 <monochrom> Many pathways to unoptimized code, and they're all orthogonal to importing vs copy-pasting.
12:14:42 <sm[m]> "that doesn't mean stack is never a good solution right". <- sounds like we agree. Let's move on
12:14:48 <monochrom> especially since GHC crosses module boundaries all the time.
12:14:56 <monochrom> even package boundaries
12:15:11 <frdg> say I am importing a large library but only using 3 of the functions. Will the performance really be effected if I specify which functions I want to import vs importing the whole thing?
12:15:20 <sclv_> no, it won't matter at all
12:15:26 <frdg> ok thanks
12:15:27 <sclv_> the whole lib gets linked regardless
12:15:54 <sclv_> and unless you're using on the order of 200 deps, you  won't notice too much perf hit from how many libs get linked per se
12:16:13 <sclv_> or unless you're micro-optimizing just for a benchmark
12:16:21 <sclv_> and worried about like cache lines
12:18:43 <monochrom> I think that makes no difference.
12:19:05 <monochrom> I mean, first you should think in terms of: import, compared to what?
12:19:33 <monochrom> The obvious "what" I can think of is "copy-paste the code into my own file so I don't import the module".
12:20:23 <monochrom> But if you have 1GB of hot-spot code that spams the cache, then you have 1GB of hot-spot code that spams the cache whether it comes from import or you copied-pasted it.
12:20:54 <monochrom> Likewise if you have 1KB of hot-spot code plus 1GB of dead code.
12:21:39 <monochrom> Even if you talk about exe size therefore launch time, I have an advanced story to tell you that it doesn't matter either.
12:22:39 <monochrom> In the old days, you could build a library with -split-objs. This is non-default, also takes a while to build, but libraries that come with GHC have it.
12:23:33 <monochrom> In recent days, there is -split-sections. This is faster and has equivalent effect. It is still non-default, but I recommend you to tell $HOME/cabal.config to default it.
12:24:00 <monochrom> With either, your exe has only library code that you call, not the whole library file.
12:24:41 <monochrom> With that, once again import vs copy-paste doesn't matter. You call 3 functions, your exe has 3 functions, doesn't matter which source code they come from.
12:26:41 <monochrom> s/which source code/which source file/
12:27:05 * monochrom is the only one in the world who proof-reads after writing.
12:32:22 <frdg> monochrom: if I tell my $HOME/cabal.config file to default -split-sections only good things will happen?
12:32:31 <monochrom> Yes.
12:32:51 <frdg> do you happen to know the syntax?
12:32:53 <monochrom> I think the only factor stopping it is Windows.
12:33:17 <c_wraith> It's not just about windows - ld is kind of bad at handling thousands of object files.
12:33:22 <monochrom> err oops the filename is $HOME/.cabal/config
12:33:31 <monochrom> "split-sections: True"
12:33:40 <frdg> ok thanks ill add that now
12:33:42 <c_wraith> thought I guess ghc tries to use gold these days, which is far better at that.
12:33:58 <monochrom> well ld's problem is with -split-objs, not quite -split-sections
12:34:14 <c_wraith> oh, wow.  I totally misread.  sorry
12:34:25 <monochrom> but "split sections" is not a thing on Windows at all
12:34:37 <quarters> hello. is it better to omit type declarations whenever possible?
12:35:05 <c_wraith> No.  It's best to always put them at the top level, and below that when it makes things clearer.
12:35:12 <c_wraith> At the top level they're important documentation.
12:35:26 <quarters> c_wraith: gotcha. tyvm
12:35:40 <ja> frdg: and while you are at it you can lower 'jobs' if you think you could run out of memory
12:36:12 <monochrom> No no. It's best to always leave out first, then ask ghci to tell you, then check against your understanding, then write it explicitly.
12:36:48 <monochrom> Also haddock works better if you have type declarations.
12:37:19 <quarters> monochrom: ah interesting. ty.
12:37:25 <monochrom> also one haddock feature requires type declarations.
12:38:03 <frdg> I am a little bit confused about my ~/.cabal/config. I am using ghcup and my cabal is in `~/.ghcup/bin/`. No where in .ghcup is there a config file. Does cabal still use the `~/.cabal/config` file?
12:38:03 <monochrom> (the one for writing a blurb for every parameter, and the codomain)
12:38:39 <ja> frdg: if you write cabal --help it will tell you where it is
12:39:02 <monochrom> It is very like still $HOME/.cabal/config regardless of ghcup
12:39:14 <frdg> ja: ok it is indeed where monochrom said
12:41:08 <frdg> I am assuming I need to change `-- split-sections: True` to `split-sections: True` ?
12:41:08 <frdg>  
12:41:23 <frdg> as in remove the dashes
12:41:23 <monochrom> yes, the -- is commenting out
12:41:32 <frdg> ok thank you
12:53:55 <hyiltiz> How feasible it is to use system package managers (like apt/yum/pacman) for developing in Haskell? I have now ended up with ghc and a bunch of libghc-* installed via apt, but still have some stack stuff
12:54:41 <hyiltiz> and nothing builds without having to tweak a few yaml files and getting some more libghc-* libraries first
12:54:51 <hyiltiz> even then it may give headahces
12:55:08 <c_wraith> system installs of ghc are usually not very usable
12:55:14 <dmj`> hyiltiz: it's probably infeasible at worst, highly discouraged at best
12:55:39 <hyiltiz> highly discouraged by #haskell for sure but not by #debian
12:55:44 <hyiltiz> I'm split :(
12:55:54 <c_wraith> which is funny given that debian ships an intentionally broken ghc install
12:56:04 <hyiltiz> huh!?
12:56:28 <Ariakenom> debian too?
12:57:18 <hyiltiz> how is it "a intentionally broken ghc"?
12:57:28 <Clint> it's not
12:57:32 <dolio> Is there a tool to automatically figure out and build debs for everything that isn't already packaged in their repositories? Otherwise it sounds like a lot more manual work.
12:57:33 <c_wraith> They split out the docs and profiling libraries.  You could install the extra packages, but it's really not a good look when installing ghc doesn't install all of ghc
12:57:50 <c_wraith> the profiling libraries really aren't optional
12:57:50 <Ariakenom> is there a writeup of how arch (debian) package managers have broken haskell packages? seems like it comes up a lot
12:58:47 <hyiltiz> hmm profiling libs are supposed to be optional for end-users though, no?
12:58:53 <Clint> it would have to be largely written without facts
12:58:55 <c_wraith> ghc isn't for end users
12:58:58 <hyiltiz> even for most developers (until they start optimizing)
12:59:46 <hyiltiz> I thought I was an end user of ghc and someone else's library, without having to optimize either
13:00:33 <ja> i agree, "end user" == "user", other definitions are confusing
13:00:58 <c_wraith> Of course, on top of that, they ship out of date packages that register globally.  That breaks all sorts of things.
13:01:34 <c_wraith> Unless you use proper tooling, at which point you might as well use it to get ghc at the same time.
13:02:39 <hyiltiz> but i'd rather use global packages not local for each proj.
13:02:45 <c_wraith> that will not work
13:02:49 <dmj`> even arch had a broken ghc until recently
13:02:49 <hyiltiz> so I (hopefully) only install lens once
13:03:03 <c_wraith> You will very quickly end up unable to build anything
13:03:06 <c_wraith> We tried that.
13:03:10 <dmj`> hyiltiz: why use debian
13:03:13 <hyiltiz> I am already there LOL
13:03:34 <c_wraith> this is why proper tooling does not use global package installations
13:03:37 <hyiltiz> dmj`: I'd jump but that seem not related to current topic tho
13:03:38 <Clint> "proper"
13:03:52 <dmj`> hyiltiz: well, you'd be surprised :) 
13:04:07 <c_wraith> I mean, you can run ghcup on debian.  it doesn't interfere.
13:04:25 <hyiltiz> ghcup + cabal is the proper tooling u r talking about?
13:04:30 <Clint> a/k/a "we've just given up on trying to maintain dependency sanity and decided to do things like the crazy rubygems and npm people"
13:04:45 <c_wraith> It's what I prefer.  some people use stack, but I find it too magical.
13:05:13 <c_wraith> Clint: we've given up on ossifying dependencies, and have to allow for things improving.
13:05:23 <Clint> and i don't find that reasonable
13:06:40 <hyiltiz> i wish each lang didn't come with their own centralized package repo, and rather used distro. specific repos
13:06:54 <hyiltiz> but i also c their point so cant argue much there
13:07:02 <hyiltiz> just a wish 
13:07:20 <c_wraith> also, I don't know what magical thing you're comparing to.  You can't build software that depends on older versions of openssl on macs these days, because you can't build old versions of openssl.  C is no better.
13:07:39 <Clint> openssl is hardly a beacon of api/abi sanity
13:07:44 <Clint> that's not C's fault
13:07:59 <c_wraith> It's a very common example of "you only need to update it in one spot if there's a security fix"
13:08:02 <c_wraith> except that's not true.
13:08:09 <dmj`> hyiltiz: NixOS has a distro specific distribution of GHC / Haskell 
13:08:34 <Clint> it's also a very common example of "good, safe crypto" and that's not at all true either
13:11:25 <dolio> hyiltiz: Why doesn't debian just have everything from Hackage? Then you could use its packages.
13:11:56 <c_wraith> dolio: well, you really couldn't.  Version incompatibilities break everything quickly.
13:12:05 <Clint> dolio: lack of volunteer manpower
13:12:21 <hyiltiz> dolio: not the person to answer that question and my guess is probably as good as yours
13:13:39 <dolio> Clint gave the right answer. You're "wishing" for 10x more work to be done than already is done.
13:13:57 <dolio> Probably more, than 10x, really.
13:15:09 <dolio> Alternately for libraries to be randomly available or not on whatever platform you choose to use, instead of available in one common way.
13:15:52 <Clint> also a lot of things on hackage won't build with any GHC from the past few years
13:15:53 <hyiltiz> Is it theoretically impossible to automate building debian packages for haskell based on hackage/stackage though?
13:16:53 <hyiltiz> I guess we can probably ignore the ones that do not build anyways
13:17:16 <Clint> you could get pretty far
13:17:17 <hyiltiz> Is there some review procedure for security before packages are posted in hackage/stackage?
13:18:01 <Clint> there is no review for anything
13:18:25 <Clint> well, that's not completely true
13:23:24 <ADG1089__> can persistent models be generated from existing database?
13:26:47 <dmj`> ADG1089__: no
13:26:55 <ADG1089__> that's a bummer
13:27:04 <ADG1089__> for sqlalchemy there's sqlacodegen
13:27:32 <LambdaDuck> > foldr (+) 0 [a, b, c, d] -- I find this very cool!
13:27:34 <lambdabot>  a + (b + (c + (d + 0)))
13:27:49 * hackage postgresql-pure 0.2.2.0 - pure Haskell PostgreSQL driver  https://hackage.haskell.org/package/postgresql-pure-0.2.2.0 (kakkun61)
13:28:34 <ja> does anyone know of a module like http://hackage.haskell.org/package/combinat-0.2.9.0/docs/Math-Combinat-Trees-Binary.html that can colour the nodes and export to graphviz or similar, like that one?
13:31:20 * hackage shake-plus-extended 0.1.0.0 - Experimental extensions to shake-plus  https://hackage.haskell.org/package/shake-plus-extended-0.1.0.0 (locallycompact)
13:45:48 <kuribas> Can anyone tell me why line 64 gives me a "Pattern match is redundant" warning?  https://github.com/kuribas/named-servant-server/blob/master/src/Servant/Server/Named.hs
13:46:08 <kuribas> SFalse and STrue look pretty different to me
13:47:54 <monochrom> I think it's because you re-ask about the same sbool.
13:48:47 <monochrom> I wonder if yahb can show it.
13:48:57 <kuribas> but is it correct?
13:49:26 <monochrom> % let x=True in case x of {True -> case x of {True -> 0; False -> 1}}
13:49:27 <yahb> monochrom: ; <interactive>:36:56: warning: [-Woverlapping-patterns]; Pattern match is redundant; In a case alternative: False -> ...; 0
13:49:32 <solonarv> hm, I don't see how this would be redundant
13:49:48 <solonarv> it is *not* the same sbool being matched against (assuming it's a typeclass method)
13:49:53 <monochrom> It is legal, but it really is redundant.
13:50:28 <kuribas>  I don't see how it's redundant
13:50:46 <monochrom> Oh OK, the types are different.
13:51:18 <monochrom> I'm ready to chalk it up to a bug in the not-so-mission-critical redundancy checker.
13:51:30 <kuribas> ok, so I can safely ignore this?
13:51:44 <monochrom> Sorry, I did pay attention to the types throughout, I just misread them earlier. :)
13:51:50 <monochrom> Yes.
13:51:51 <kuribas> my the redundancy checker is confused when it get GADTs?
13:52:16 <kuribas> which is fair, since I get confused with GADTs as well...
13:52:24 <monochrom> Actually my impression is that the checker has not take GADT into account.
13:52:29 <monochrom> s/take/taken/
13:53:09 <monochrom> Perhaps to be paranoid, insert some Debug.Trace things to show that all 4 possibilities can happen.
13:53:35 <kuribas>  hmm, okay
13:53:58 <monochrom> or find out that only 2 possibilities can happen!
13:54:31 <monochrom> You would call it "coverage test" anyway :)
13:56:17 <monochrom> But if "SBool t" is a GADT, then STrue stays as STrue regardless of changing t.
13:57:07 <monochrom> Only class method and type family can make a case of "sbool becomes a different value".
13:57:22 <kuribas> FoldRequired is a type family
13:57:45 <monochrom> But it looks like t is a phantom type.
13:58:03 <kuribas> ah wait it isn't...
13:58:10 <monochrom> from SBool's POV
13:58:23 <kuribas> FoldLenient' is
13:58:37 <kuribas> So I am using the type, when I needed the type family!
13:59:28 <monochrom> Yes, I see that "x :: FoldRequired mods" and "x :: FoldLenient mods" are different. But you don't have that.
14:00:34 <kuribas> no, it's still right.
14:01:03 <kuribas> type FoldLenient = FoldLenient' False
14:01:10 <kuribas> so it still reduces to a type family
14:01:12 <monochrom> I'll leave it at "I hate type-level types".
14:01:29 <kuribas> yeah
14:01:40 <kuribas> I'll just test it to see if it doesn't crash anything
14:02:21 <monochrom> But coverage test is the best idea. You want to test that the computer is on the same page as yours.
14:12:01 <sm[m]> ADG1089__: yes, I once did that using a tool called DBDirect-hdbc-postgresql which might come from https://github.com/m4dc4p/haskelldb
14:12:17 <kuribas> it looks as if it treats the two sbool as being the same.
14:13:09 <kuribas> that sbool :: SBool (FoldRequired mods) == STrue => sbool :: SBool (FoldLenient mods) == STrue
14:13:29 <sm[m]> on another note, https://youtu.be/Wu8eJh6OqhI is a great practitioner talk (haskell for space mission control)
14:13:35 <monochrom> I may be unfair to say that t is a phantom type for all of the "SBool t" type. But, if STrue doesn't have a field, then t is a phantom type from the POV of STrue.
14:13:58 <ja> maerwald: do you know why ghcup recommends 8.8.3 over 8.8.4?
14:14:29 <monochrom> it still recommends 8.8.3
14:14:45 <ja> correct
14:15:16 <monochrom> maerwald or a co-conspirator balances several factors in choosing the recommendation.
14:15:48 <kuribas> https://hackage.haskell.org/package/singleton-bool-0.1.5/docs/Data-Singletons-Bool.html
14:15:58 <solonarv> monochrom: presumably it's a GADT. In that case there *is* a (hidden) field in each constructor, and its type is 't ~ True' or `t ~ False'
14:16:04 <monochrom> So while 8.8.4 is much recommended from the POV of GHC bug fix, there is also a factor of "have most libraries been updated to be compatible" that pulls it back.
14:17:37 <ja> oh, i thought it was a minor upgrade and couldn't possibly break anything
14:17:50 <monochrom> Although, after occam-razoring, a simpler explanation is "maerwald just haven't got around to update the recommendation" :)
14:19:04 <monochrom> Yeah, you're right, it shouldn't. "Library breakage" just means "people have not updated dependency version numbers".
14:27:50 * hackage input-parsers 0.1 - Extension of the parsers library with more capability and efficiency  https://hackage.haskell.org/package/input-parsers-0.1 (MarioBlazevic)
14:40:19 * hackage incremental-parser 0.5 - Generic parser library capable of providing partial results from partial input.  https://hackage.haskell.org/package/incremental-parser-0.5 (MarioBlazevic)
14:42:18 <frdg> Do you guys ever parse json without aeson? 
14:42:56 <dmj`> ghc does, https://hackage.haskell.org/package/ghc-8.10.1/docs/Json.html
14:44:57 <MarcelineVQ> frdg: wanting an alternative? waargonaut is kinda neat
14:46:20 <frdg> I just dont want to put in the effort to learn a new parsing library when I already know how to use one. I am struggling to use aeson and know how I could solve the problem with trifecta. I just dont know if I will have performance issues.
14:46:58 <frdg> I know I can figure out soon enough If I keep reading the docs but I just wanna finish this part of my project
14:48:44 <monochrom> I only know and use aeson for json.
14:49:19 * hackage construct 0.3 - Haskell version of the Construct library for easy specification of file formats  https://hackage.haskell.org/package/construct-0.3 (MarioBlazevic)
14:49:55 <monochrom> I don't impose it on you, but if you ask for a suggestion, aeson is the only one I know to suggest. Sorry!
14:52:09 <koz_> What is the strategy used to derive Exception? I tried 'deriving stock', and GHC didn't like that very much.
14:53:24 <frdg> The right decision is probably to stick with aeson even if it is not the easiest immediate solution.
14:54:53 <dmj`> frdg: yea, just use aeson
15:01:20 * hackage dlist 1.0 - Difference lists  https://hackage.haskell.org/package/dlist-1.0 (SeanLeather)
15:06:47 <frdg> dmj: Well in this case I have a question. So I have written an instance of FromJSON for my type. I am able to create a function of type IO () and get the json file into the format I need after using the getResponseBody function. I do not know what I need to do from this point though. How do I apply the parser? Here is the code: https://dpaste.org/oC5b
15:12:29 <maerwald> monochrom: there's one more concern: whethe a ghc release has all the bindists as the previous one (otherwise, the bootstrap script will fail on certain platforms)
15:12:37 <maerwald> so I'm currently fixing that 
15:14:52 <maerwald> doesn't help to recommend a release, when certain users cannot install it
15:21:30 <yushyin> frdg: httpJSON already parses it as JSON, no? just change the type from fetchJSON so that it returns a IO (Response WeatherObj) and not a IO (Response Value)
15:21:47 <monochrom> Ah OK thanks maerwald.
15:22:13 <quarters> hello. I was trying to run ghci under stack and declared the function type "surface :: Shape -> Float" after defining Shape but am getting Variable not in scope: surface :: Shape -> Float and was wondering how I can address this. I'm following http://learnyouahaskell.com/making-our-own-types-and-typeclasses#the-functor-typeclass
15:22:29 <monochrom> ja: Please see maerwald's answer above. But TL;DR bindist completion/coverage.
15:23:54 <maerwald> I consider alpine bindists important, bc alpine is the most common docker image these days (and I use it to build ghcup)
15:24:31 <maerwald> and 8.8.4 on 32bit alpine currently segfaults during build
15:24:36 <monochrom> yikes
15:29:22 <frdg> yushyin: Ok I am able to change the type to `IO (Response WeatherObj)`. When I just print the body of the response the json data looks equivalent though. From here am I just supposed to parse the data like I would in other parser combinator libs?
15:30:05 <frdg> or am I supposed to use other aeson functions to construct WeatherObj types?
15:32:37 <yushyin> at that point it is already parsed and it is already a WeatherObj type, no?
15:37:13 <frdg> yushyin: ah what I did not realize is that now I get a JSONConversionExpeption: https://dpaste.org/z0gu
15:37:39 <frdg> Is this because my datatype must specify every json element that is available at that link?
15:39:46 <frdg> this is probably more relevant information that what the other paste showed: https://dpaste.org/XRPH
15:47:29 <yushyin> frdg: seems to me that your FromJSON instance doesn't match up with that JSON schema/shape at all.
15:48:06 <dmj`> frdg: just derive it generically
15:48:53 <yushyin> and no, you do not need to map all the keys:values from a JSON object
15:51:02 <koz_> For atomicModifyIORef, why does the second argument have type (a -> (a,b))?
15:53:07 <frdg> when I try to add deriving (FromJSON) I get this error â€¢ No instance for (GHC.Generics.Generic WeatherObj) arising from the 'deriving' clause of a data type declaration
15:53:08 <frdg>       
15:53:33 <frdg> I did add the DeriveAnyClass pragma
15:53:45 <koz_> frdg: If you want automagic derivation, you need to derive Generic as well.
15:53:53 <koz_> That's what that error is saying.
15:54:32 <koz_> You wanna do something like 'deriving (Generic, FromJSON)'.
15:57:11 <yushyin> frdg: there is still the fundamental issue that the data type doesn't represent the actual JSON shape at all
15:58:03 <frdg> right. I got it to compile but am back to square 2 where I am getting that same exception
15:58:36 <koz_> What's the exact error frdg ?
15:58:50 <frdg> https://dpaste.org/cRtF
15:59:35 <yushyin> frdg: yup, look at the raw JSON string, that cannot work from your WeatherObj data type alone
16:00:13 <koz_> frdg: If you're gonna automagically derive, you have to map _everything_ _exactly_ one-for-one to the JSON you seek to parse.
16:00:27 <koz_> Otherwise, you need to get a Value, and take it apart by hand.
16:01:00 <koz_> Since Value has a FromJSON instance, that's OK.
16:01:13 <frdg> the issue is in the name of the records in the WeatherObj type not mathching the names in the json string?
16:02:53 <koz_> frdg: Basically, your WeatherObj must be an exact match. Same fields, same types, same names, same everything.
16:03:14 <koz_> Otherwise, the autoderived parser won't make heads or tails of your data.
16:03:40 <koz_> The alternative, as I said, is 'parse a Value, then take it apart manually to build the structure you actually want'.
16:04:43 <frdg> ok so if I autoderive I need to have a record for every json element from that link?
16:04:57 <frdg> but if I manually derive I do not?
16:05:12 <yushyin> one can leave out keys one does not care about, though.
16:05:53 <koz_> frdg: In order for autoderivation to work, in your specific case, you have to have WeatherObj be a record containing a host field of type Text, a port field of type Int or something, a secure field of type Bool, etc.
16:05:55 <yushyin> but the general shape must be preserved
16:06:15 <koz_> And _no_ fields of any name that are not present in the JSON you are trying to parse.
16:06:24 <koz_> You have a 'feelsLike' field which has no correespondent.
16:06:56 <koz_> (for instance)
16:08:31 <frdg> ok the issue is in a lack of understanding of json which is a positive. I should be able to figure this out.
16:12:49 <mdiamond> just had a simple question: if a function has a return type like MaybeT IO String, are those right-associative? like is the type equivalent to MaybeT (IO String)?
16:13:20 <mdiamond> 90% sure the answer is yes but just wanted to check
16:13:50 <koz_> mdiamond: Not quite. MaybeT has two type arguments. One indicates the 'inner monad', the other the result.
16:13:55 <gaussian> @unmtl MaybeT IO String
16:13:55 <lambdabot> IO (Maybe String)
16:14:06 <koz_> gaussian: Beat me to it.
16:15:09 <mdiamond> oh, interesting... I saw an instance declaration with the format Monad (MaybeT m) so I assumed that MaybeT was a type constructor with one parameter "m"
16:15:31 <koz_> mdiamond: Monad wants something of kind Type -> Type.
16:15:38 <koz_> Much like Functor and Applicative.
16:15:51 <mdiamond> ah, that makes sense
16:16:29 <mdiamond> thanks for clarifying... glad I asked then
16:18:25 <mdiamond> oh duh, I just looked again and saw that the newtype declaration was MaybeT m a... it all makes sense
16:18:49 <koz_> Yeah, it's an easy mistake to make.
16:20:58 <mdiamond> though I'm not sure I understand why "instance Monad m => Monad (MaybeT m) where" isn't written as "instance Monad m => Monad (MaybeT m a) where"
16:21:57 <mdiamond> is it because the "a" has no typeclass restriction, whereas "m" does so it has to be included?
16:22:16 <koz_> Because Monad wants something of kind Type -> Type.
16:22:23 <koz_> MaybeT m a would have kind Type.
16:22:50 <mdiamond> ah... okay now I see what you were trying to say before
16:23:12 <mdiamond> thanks again
16:23:42 <koz_> No worries. This isn't something you see a lot in other languages, so it can be confusing.
16:44:25 <ja> with "reanimate" (haskell package), i do "cabal run", it opens up a browser window that says "compiling..." but nothing ever shows up, and there are no errors in the console i launched cabal from, or in the browser console. what could i be doing wrong?
16:51:57 <monochrom> I don't know, but there is a chance "cabal run -v" is more chatty.
16:53:39 <monochrom> On an earlier conversation: Once again Dunning-Kruger strikes, when a person is 90% confident, the other 10% is right.  MaybeT IO a = (MaybeT IO) a.
17:06:51 <koz_> monochrom: So... you're saying I messed up there?
17:07:20 <dolio> No.
17:07:23 <Waldkauz> I'm 10% confident that's not the case
17:07:38 <monochrom> No.
17:09:45 <Cale> I think everyone was right in the previous discussion?
17:10:26 <Cale> At least, koz was right about why Monad (MaybeT m a) would be a kind error
17:10:27 <koz_> I mean, I'm genuinely asking - the comment was a bit cryptic, and if I'm missing something or giving bad info, I'd rather be corrected.
17:10:45 <monochrom> Yes, everyone was right.
17:11:23 <monochrom> But "(MaybeT IO) a" is worth emphasizing because you need to know when you unify "a -> m a" with "a -> MaybeT IO a" for example.
17:11:42 <monochrom> If you believe "MaybeT (IO a)" you can't do it.
17:16:29 <ja> ok i circumvented my problem by having reanimate render to an mp4 file and just viewing it like that
17:48:43 <gentauro> is there a way in `GHCi` to avoid seeing all the modules that are loaded when typing multiline?
17:49:09 <gentauro> in my ~/.ghci I have the following line: `:set prompt "Î»> "`
17:49:17 <gentauro> which makes it more readable
17:49:42 <gentauro> but as soon as I turn on multiline: `:{ â€¦ :}` it adds all the modules that are loaded
17:49:57 <monochrom> I think it's prompt2 or something for that.
17:50:21 <monochrom> prompt-cont
17:50:44 <monochrom> You can find it by :help
17:50:46 <gentauro> monochrom: thx -> https://stackoverflow.com/a/22726325
17:52:46 <gentauro> monochrom: but yes, it's `prompt-cont` and not `prompt2` :)
17:53:06 <monochrom> interesting, prompt2 used to be right
17:55:55 <slack1256> I got a Text value on which I am `replace`-ing extraneous chars (like '_-\\) with the empty string. I do this by repeatedly applying `replace`. Is there a better way?
18:04:10 <dminuoso> slack1256: Id do what Data.Text.Lazy.replace does with a slight modification.
18:04:33 <dminuoso> replace s d = intercalate d . splitOn s
18:05:20 <dminuoso> replace' ss = TL.intercalate ' ' . TL.split (`elem` ss)
18:06:16 <dminuoso> Then you can just use it as `replace' "'_-\\" someText`
18:08:49 <dminuoso> % replace' ss = TL.intercalate " " . TL.split (`elem` ss)
18:08:49 <yahb> dminuoso: 
18:11:26 <dminuoso> Ah that doesnt work mm.
18:12:48 <dminuoso> Why doesnt this work?
18:17:50 <dminuoso> % replace' ",." "foo.bar . quux ,baz"
18:17:51 <yahb> dminuoso: "foo bar quux baz"
18:18:20 <dminuoso> % TL.split (`elem` ",.") "foo.bar . quux ,baz"
18:18:21 <yahb> dminuoso: ["foo","bar "," quux ","baz"]
18:18:36 <dminuoso> % mconcat $ TL.split (`elem` ",.") "foo.bar . quux ,baz"
18:18:37 <yahb> dminuoso: "foobar quux baz"
18:19:05 <dminuoso> Why is the additional space consumed there?
18:50:17 <glguy> % TL.split (`elem` ",.") "foo.bar . quux ,baz"
18:50:17 <yahb> glguy: ["foo","bar "," quux ","baz"]
18:50:53 <glguy> % mconcat ["foo","bar "," quux ","baz"]
18:50:53 <yahb> glguy: "foobar quux baz"
18:51:31 <glguy> % "bar " <> " quux "
18:51:32 <yahb> glguy: "bar quux "
18:52:16 <glguy> % "don't  know"
18:52:16 <yahb> glguy: "don't know"
18:52:28 <Clint> % "bar " ++ " quux "
18:52:29 <yahb> Clint: "bar quux "
18:52:39 <glguy> mniip: What's that about ^ ?
18:53:13 <glguy> % putStrLn "a  b"
18:53:14 <yahb> glguy: a b
18:53:27 <slack1256> Mmmm interesting.
18:54:14 <glguy> The IO wrapper the bot uses around GHCi might do something like use 'words' and 'unwords' on the output after cleaning something up
18:57:01 <dminuoso> glguy: Ah good catch. Thinking I was going crazy here.
19:10:47 <MarcelineVQ> ye interesting
19:10:53 <MarcelineVQ> % "   sdfsds   " :: String
19:10:54 <yahb> MarcelineVQ: " sdfsds "
19:26:49 * hackage ring-buffers 0.1.1 - mutable ring buffers with atomic updates in GHC Haskell  https://hackage.haskell.org/package/ring-buffers-0.1.1 (chessai)
19:40:14 <slack1256> I got this function for `pipes` that I am sure I could express combinators on its Prelude: https://pastebin.com/uTcT3Ag3 . Does anyone have an idea?
19:41:16 <slack1256> *via combinators
19:44:43 <c_wraith> is that supposed to be firstSong <- await   ?
19:46:43 <slack1256> yeah...
19:46:45 <slack1256> I will fix it
19:47:43 <slack1256> https://pastebin.com/c2PK82hx
19:53:42 <c_wraith> I don't see any combinators that obviously improve that.
20:01:31 <solonarv> slack1256: you can simplify it a bit using 'dropWhile'
20:04:58 <solonarv> slack1256: this should work: https://gist.github.com/Solonarv/c4893654782766eabd72ec9eeeb1f3d3
20:06:21 <slack1256> Yeah, that plus a `yield` of the first element should be equivalent.
20:06:30 <slack1256> Cool!
20:07:55 <solonarv> I updated the gist to add that yield
20:08:02 <solonarv> noticed it was missing right after I sent that message :>
20:11:01 <koz_> @pl \f -> traverse_ (const f)
20:11:01 <lambdabot> traverse_ . const
20:11:09 <koz_> :t traverse_ . const
20:11:10 <lambdabot> (Foldable t, Applicative f) => f b -> t a -> f ()
20:11:23 <koz_> :t replicateM
20:11:24 <lambdabot> Applicative m => Int -> m a -> m [a]
20:11:37 <koz_> What am I hunting for?
20:11:48 <koz_> Is there something which is basically traverse_ . const?
20:15:00 <solonarv> hm, I'm not aware of anything
20:15:17 <solonarv> well, I suppose...
20:15:22 <solonarv> > :t replicateM . length
20:15:25 <lambdabot>  <hint>:1:1: error: parse error on input â€˜:â€™
20:15:27 <solonarv> :t replicateM . length
20:15:29 <lambdabot> (Applicative m, Foldable t) => t a1 -> m a2 -> m [a2]
20:15:43 <solonarv> that one is stricter though
20:16:16 <solonarv> e.g. (replicateM . length) [0..] (putStrLn "Hi") -- will just hang
20:17:31 <koz_> solonarv: It also returns a list, as opposed to unit.
20:17:42 <solonarv> oh, right, forgot the _
20:17:43 <koz_> You can assume the Foldable isn't infinite in my case.
20:17:49 <koz_> :t replicateM_
20:17:51 <lambdabot> Applicative m => Int -> m a -> m ()
20:18:12 <koz_> I guess this works too in my case.
20:18:16 <solonarv> you could also reassociate it as sequence_ (f <$ xs)
20:18:20 <solonarv> perhaps that looks nicer
20:37:02 <slack1256> Thank you solonarv.
21:03:39 <fog> im using encodeFile from Data.Binary, but it crashes
21:03:56 <fog> is there a version that i can "append" to a file?
21:04:02 <fog> where*
21:04:36 <fog> im streaming data, which i can read into ram from a file, its not too large
21:05:00 <fog> but for whatever reason (something encodeFile is doing must be using up too much memory)
21:05:17 <fog> i cant convert all this data to binary, and sotre it all in ram, to write it to the file
21:05:38 <fog> it would be better, since its a list, if i could convert each element to binary, and append it to the file
21:05:51 <fog> is there any library that does this?
21:06:56 <fog> i can do the streaming lazily, thats easy, i just basically want to fold over the data
21:07:15 <fog> but i need an appendFile like opperation
21:07:45 <fog> hmm, actually fold would kind of only work for lists, not arbitrary foldables. so lets just use lists for now
21:08:13 <fog> like, i dont actually need any extra data in the file to indicate the datatype
21:08:48 <fog> like that a Binary instance (eg. instance Binary a => Binary [a]) gives
21:09:21 <fog> all i need is the Binary a constraint. 
21:09:56 <fog> since its always going to be used with list, no information about the datatype needs to be encoded to binary
21:10:46 <fog> if it was done properly it would probably unfold the data with the structure directing index when reading in from the binary file
21:11:25 <fog> so that would just need a Binary instance for (i,a) where `i' is the structure directing index eg. of Tree
21:11:51 <fog> since the Tree is foldable i should be able to just sequentially append the binary file with (i,a)
21:12:04 <fog> basically [(i,a)] <-> Tree a
21:12:20 <fog> so i still just need to be able to do this for lists
21:12:32 <fog> ie. just need an "appendBinaryFile" function
21:12:57 <fog> appendBinaryFile :: Binary a => FilePath -> a ->  IO ()
21:14:10 <fog> I can find an idea similar to this here;
21:14:10 <fog> https://hackage.haskell.org/package/Cabal-3.2.0.0/docs/Distribution-Utils-Structured.html#v:structuredEncodeFile
21:14:18 <fog> by hoogling the type above
21:14:24 <fog> but its the same type as;
21:14:40 <fog> encodeFile :: Binary a => FilePath -> a -> IO ()
21:15:05 <fog> where this is not append, but overwrites the file
21:18:55 <fog> there is a stackoverflow post on this issue here;
21:18:56 <fog> https://stackoverflow.com/questions/52156838/can-i-append-to-a-file-using-binarys-data-binary
21:19:07 <fog> it suggests to use appendFile directly
21:19:26 <fog> but this does not allow for "separators" 
21:19:37 <fog> should i just use newline characters or commas?
21:19:59 <fog> i guess the binary way done properly would know how many bits each datatype value was
21:20:17 <fog> and then you would consume without having to match for a separator on reading
21:20:45 <fog> i guess i could do all that, and use appendFile - but isnt there a library that has done this already!?
21:23:06 <fog> the other issue with using appendFile is that it takes String, not ByteString 
21:24:03 <fog> hmm, i guess there is;
21:24:04 <fog> http://hackage.haskell.org/package/bytestring-0.10.10.1/docs/src/Data.ByteString.html#appendFile
21:24:36 <fog> but that still would require keeping track of how big the binary data was
21:24:55 <fog> which is the kind of thing the Data.Binary should do... 
21:25:37 <fog> then for reading i could use;
21:25:38 <fog> hGet :: Handle -> Int -> IO ByteString
21:25:54 <fog> but really i want the library that does those things... it must exist...
21:26:24 <sm[m]> fog: are you needing a streaming library, like the ones with conduit in their name ?
21:26:34 <fog> nono
21:26:41 <fog> like i say, i can just fold the list of data
21:26:51 <fog> i just need the appendBinary opperation
21:28:29 <fog> aha! i find; 
21:28:30 <fog> https://hackage.haskell.org/package/serialise-0.2.3.0/docs/src/Codec.Serialise.html#hPutSerialise
21:37:39 <fog> argh! it still requires me to keep track of the length of the bits
21:37:56 <fog> i think...
21:38:34 <fog> if i just keep appending to the file, im not sure if i can read the whole file in using readFileDeserialise
21:38:48 <fog> because that has a Serialize a instance for the whole list 
21:53:06 <fog> this is the error i get; https://pastebin.com/raw/y9fGFEsR
21:58:52 <sm[m]> so it canâ€™t read something it just wrote ?
21:59:06 <sm[m]> Maybe thereâ€™s something in the issue tracker
21:59:52 <dolio> No, what's happening is that writing many individual list elements is not the same format as writing a list.
22:00:35 <fog> yeah, but there should be an instance for Serialise [a]
22:00:59 <dolio> You didn't use it for the writing.
22:01:04 <fog> its just not the same data as appending the `a' sequentially
22:01:15 <fog> i just kind of presumed they would be the same...
22:01:36 <fog> or, at least, wanted to show what i meant and how it doesnt work
22:03:02 <typetetris> Where is the documentation about cabal components again? The cabal user guide mentions `lib:` and `exe:`, the componentized cabal proposal doesn't mention these. Are there more? How are test-suites addressed?
22:03:35 <dolio> Also the error message tells you why it might be using memory, because it might be writing the length of the list first.
22:03:49 <fog> ahh
22:04:11 <dolio> Finding the length of the list forces it to be fully evaluated in memory. To stream it out, it would require using a format that does not know the length up front.
22:04:36 <fog> good plan!
22:05:09 <fog> still slightly dismayed this doesnt exist already..
22:05:22 <dolio> It might exist.
22:05:32 <dolio> It might be what 'indef' is.
22:06:02 <fog> maybe i should abandon the Serial package and try to work again with Binary instances 
22:06:31 <fog> but im always going to be stuck with having to determine the length of the binary representation of `a'
22:07:00 <fog> but the more i think about it, the less it seems like someone would have written this already
22:07:22 <fog> the asymetry between appending on write, and reading the whole thing in on read 
22:07:55 <fog> i guess i should be working with lazy bytestrings and somehow keeping the file handle open and reading from it sequentially too...
22:08:03 <fog> then i could eg. copy huge files
22:08:26 <fog> but then, thats such an elementary concept im sure it would exist!
22:08:50 <dolio> According to the code, the default encoding is indefinite length, so doesn't require finding the length of the list.
22:08:58 <fog> i guess it will do for sure just with the normal lazy bytestrings
22:09:02 <dolio> However, any particular instance might override that.
22:09:27 <fog> hmm..
22:09:54 <fog> im thinking now instead i should be doing some kind of chunked traversal of lazy bytestrings
22:10:15 <fog> and just bite the bullet and accept im going to need to find the length of the binary representation of the datatype
22:13:56 <rand809809> Hi
22:14:00 <rand809809> I have this thing https://gist.github.com/bananabrick/0b34347826f79960d17f5d80bd6cb05a
22:14:28 <rand809809> App is a constructor which takes two arguments and produce a `CoreExpr`
22:15:15 <rand809809> If I'm parsing the string "f 2 3", I want the result to be App (App (f 2) 3)
22:15:23 <rand809809> But instead, I'm getting the opposite result
22:15:31 <rand809809> App f (App 2 3)
22:15:43 <rand809809> I specifically used foldl so that I would get the former result
22:15:48 <rand809809> Anyone know what's up?
22:16:23 <ja> rand809809: but those two notations are not using the same types?
22:16:45 <ja> rand809809: if App takes two types, and f is a type, how can f be applied to 2 in the first snippet?
22:17:02 <rand809809> App takes two `CoreExpr`
22:17:11 <rand809809> to Product a `CoreExpr`
22:17:30 <rand809809> oh my bad
22:17:47 <rand809809> the first one should be App (App f 2) 3
22:18:00 <rand809809> and the second one should be App f (App 2 3)
22:18:04 <rand809809> I'm trying to get the first one
22:19:34 <rand809809> It seems like using fold here "should" work as expected?
22:19:37 <rand809809> foldl*
22:21:40 <fog> i can see here that its calling B.Length
22:21:40 <fog> https://hackage.haskell.org/package/binary-0.8.8.0/docs/src/Data.Binary.Get.html#calculateOffset
22:22:42 <dolio> rand809809: It does seem like that's correct.
22:22:55 <rand809809> Then why does it produce the other result?
22:22:59 <rand809809> It makes no sense
22:23:25 <fog> argh! giving up
22:24:25 <dolio> Can't answer that.
22:25:02 <dolio> The only answer that makes sense is that it's not really running the code you pasted.
22:26:02 <dolio> Or not running it in the way you think. Perhaps `f 2 3` already gets parsed with `2 3` together.
22:27:38 <rand809809> oh yea maybe that's it
22:28:05 <rand809809> thanks
22:33:49 * hackage streamly-lmdb 0.0.1 - Stream data to or from LMDB databases using the streamly library.  https://hackage.haskell.org/package/streamly-lmdb-0.0.1 (shlok)
22:49:13 <fog> ok! the thing I needed was decodeOrFail
22:49:33 <fog> https://pastebin.com/raw/2W3uz9ms
23:41:04 <Zemyla> Okay, suppose I have a newtype Rep f a = Rep { unRep :: forall b. Coercible a b => f b }
23:41:16 <Zemyla> It basically turns a potnetially nominal argument into a representational one.
23:43:41 <Zemyla> Converting to a Rep generally requires f to be a Functor, Contravariant, or Invariant.
23:44:31 <Zemyla> But if g is a Functor, can I turn a value of type Rep (Compose g f) a to a value of g (Rep f a)?
23:54:36 <fog> hGetContents of Lazy.Bytestring does not seem to be lazy...
23:54:42 <fog> i must be doing something wrong
23:55:21 <fog> i can copy a large file, but it does not start writing to the new file until the whole input file has been read in
23:56:03 <fog> https://pastebin.com/raw/C7aQaVXR
23:57:15 <c_wraith> I'd guess it has a lot more to do with the rest of that line
23:59:26 <c_wraith> like..  what package is IOList coming from?
