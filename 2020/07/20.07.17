00:00:07 <ja> the field i was talking about is called "resolver"
00:00:39 <Haskell-Newbie-o> Thank you for the hello world link! That was my next step.
00:01:40 <Haskell-Newbie-o> "A package is identified by a *globally-unique* package name"
00:02:13 <Haskell-Newbie-o> How *global* is *global*?
00:02:46 <ja> well, it doesn't include the version, which is important too
00:04:26 <ja> for the purposes of the hello-world example, i think you can assume that it is just global to your hello-world project
00:04:30 <ja> so not very global ;)
00:04:59 <ja> if you publish the package it would go on hackage and it should use a name that isn't used there
00:06:44 <Haskell-Newbie-o> it seemed to accept 'helloworld' like in the docs, so either I'm the first person to follow the instructions on the whole globe, or not very global as you say.
00:07:37 <ja> it's not gonna upload anything behind your back
00:08:27 <Haskell-Newbie-o> How long have you used Haskell? I'm just trying to understand working with lambda constructions, as the explanations I've read make them sound like just functions without a name, so I don't understand why they are a big deal.
00:08:49 <ja> a few years, i think, it's a long process though :P
00:09:23 <ja> they are foundational, i dunno what you expect of them. is algebra a big deal ? :P
00:09:58 <ja> it's just another theoretical foundation of computation. are turing machines big deals? :)
00:10:42 <Haskell-Newbie-o> Yes foundations are big deals. :)
00:11:44 <ja> i prefer starting out from type theory, and that seems more unique to haskell since it has 'purity'
00:12:08 <ja> what do you mean when you say working with lambda constructions?
00:13:05 <Haskell-Newbie-o> I have no idea. X)  I am working through https://leanprover.github.io/theorem_proving_in_lean/dependent_type_theory.html
00:15:31 <Haskell-Newbie-o> somewhere, I thought in that document (maybe elsewhere), it suggested I needed to understand lambda constructions eg in Haskell.
00:18:33 <ja> here's a document on making your own lambda calculus: http://dev.stephendiehl.com/fun/lambda_calculus.html in haskell
00:20:20 <Haskell-Newbie-o> Oooh aah
00:20:24 <Haskell-Newbie-o> :)
00:41:35 <bewakes> Hi, Is there a numeric class that includes all of Num as well as Rational class? Or say, why is Rational number not in Num?
00:45:12 <lortabac> bewakes: what do you mean by Rational class? Rational is defined as type Rational = Ratio Integer
00:45:29 <lortabac> and Ratio Integer has a Num instance
01:11:34 <vilpan> a typo in `catch` doc (https://hackage.haskell.org/package/base-4.14.0.0/docs/Control-Exception.html#v:catch): the second sentence from the end has a superfluous "a" article, in case someone can fix that very easily
01:16:25 <phadej> vilpan: (a) the opposite behaviour?
01:17:06 <vilpan> phadej: yes
01:17:42 <phadej> vilpan: thanks, https://gitlab.haskell.org/ghc/ghc/-/merge_requests/3711/diffs
01:20:23 <vilpan> phadej: thank you. That's so minor, I wasn't sure it's worth bothering anyone, but I thought it's very likely someone will have the code at their fingertips :)
01:20:57 <phadej> yes, checking out ghc source tree is the most time consuming part in making changes like that :)
01:21:38 <phadej> (though I argue you should do it sometimes, I do find often looking at it)
01:22:07 <vilpan> you mean looking at the implementation?
01:23:58 <phadej> yes, even browsing `base`s code is nicer locally, then via web-interfaces
01:29:20 <vilpan> I still need a lot more experience points before delving into GHC/base libraries :)
01:29:20 <vilpan> I actually tried looking at the source tree to find the location of the typo, but was a bit confused it's not in Control.Exception. Any tips on how to map the module as written in documentation to the location in source tree?
01:30:08 <phadej> git grep '^symbolname'
01:31:16 <phadej> I don't remember where (such low-level) things live in GHC.* namespaces
01:33:17 <phadej> and because GHC.Base is imported openly (i.e. not qualified, nor explicit import list) in Control.Exception, you are out of luck to figure out by just looking at the single file at time
01:34:13 <phadej> or actually it comes via Control.Exception.Base, but that's just proves the point
02:21:14 <AWizzArd> When I run `cabal update -v` I get an "Unexpected response 416" error for this one:
02:21:17 <AWizzArd> /usr/bin/curl 'http://hackage.haskell.org/01-index.tar.gz' --output /run/user/1000/transportAdapterGet45775-7 --location --write-out '%{http_code}' --user-agent 'cabal-install/3.2.0.0 (linux; x86_64)' --silent --show-error --dump-header /run/user/1000/curl-headers45775-8.txt --header 'Range: bytes=86978952-90941670'
02:21:43 <AWizzArd> Does this work for anyone else?
02:38:20 <AWizzArd> `cat /run/user/1000/curl-headers46140-8.txt` says "HTTP/1.1 416 Requested range not satisfiable".   When I try that curl call without the `--header` setting I get a file of size 90_941_671  and the requested range was bytes=86978952-90_941_670 so that sounds doable.
02:39:49 <liiae> how this "yoneda" pronouce?
02:40:06 <liiae> it's not an english word, right?
02:40:19 <dminuoso> liiae: It's a name
02:40:44 <dminuoso> It's from a Japanese mathematician called Nobuo Yoneda.
02:40:47 <dminuoso> https://en.wikipedia.org/wiki/Nobuo_Yoneda
02:41:40 <dminuoso> En: /ˈjɔʊ.neɪ.də/
02:42:05 <liiae> I see
02:42:36 <liiae> dminuoso: I found "yoda" in it
02:43:23 <dminuoso> liiae:  http://www.youtube.com/watch?v=rAh59DAcFuk
02:43:27 <dminuoso> 20 seconds in you can hear it
02:45:48 <liiae> dminuoso: I've read an article 'bout it, yoneda lemma, Kan Extensions, no idea what's that
02:47:20 <liiae> as I see, it just `flip fmap fa f`
02:47:26 <dminuoso> liiae: It is a very fundamental lemma from category theory. 
02:47:55 <liiae> :t (flip fmap)
02:47:56 <lambdabot> Functor f => f a -> (a -> b) -> f b
02:49:53 <liiae> :t uncurry (flip fmap)
02:49:55 <lambdabot> Functor f => (f a, a -> b) -> f b
02:50:15 <dminuoso> liiae: Anyhow, the category theory aside, in Haskell Coyoneda is essentially a way to sort of "ensure" you get fusion on fmap.
02:50:36 <dminuoso> (The relationship of category need not interest you)
02:51:14 <liiae> dminuoso: what this `uncurry (flip fmap)` is used for?
02:51:30 <liiae> I forget where I saw this code
02:51:36 <liiae> I can't find that article
02:54:13 <dminuoso> The reason is essentially that GHC cant know that `fmap f . fmap g = fmap (f . g)`, and it cant optimize that based on the law alone. 
02:55:15 <dminuoso> If you use Coyoneda you get fusion instead. :)
02:56:53 <liiae> dminuoso: more questions, put Co- on yoneda will change its meaning to? I saw the terms of Co-monad and free monad, and I don't know them yet
02:56:58 <dminuoso> So if your code somehow does a lot of `fmap f . fmap g . fmap h`, and your fmap is computationally expensive, then sprinkling Coyoneda can make this far more efficient. :)
02:57:18 <liiae> routine, Co-routine
02:57:54 <dminuoso> liiae: The co- prefix in most haskell stuff comes from cateogry theory. Very roughly speaking, for every construction you have, there's an identical sort of "opposite" construction.
02:58:03 <liiae> dminuoso: this `fmap f . fmap g` is related to lens?
02:58:04 <dminuoso> In category theory we call this "dual" rather than "opposite"
02:58:32 <dminuoso> Anyhow. So the Yoneda lemma has a "dual/opposite" construction called Coyoneda.
02:58:59 <liiae> ismorphism?
02:59:03 <dminuoso> No
03:00:07 <merijn> "co-" is just math speak for "opposite world"
03:00:29 <dminuoso> liiae: So a category can be thought of as a directed graph (dont worry aobut what that graph contains, its not important)
03:00:30 <merijn> monad return is "a -> m a" comonad "return" is "m a -> a"
03:00:48 <dminuoso> liiae: These graphs sometimes have objects that satisfy special properties.
03:01:02 <dminuoso> (by objects I mean vertices)
03:01:14 <liiae> merijn: wait a sec, return "m a -> a" is possible?
03:01:15 <dminuoso> Say, sometimes you have vertices that are Foo (whatever Fo omeans)
03:01:18 <dminuoso> liiae: So far so good?
03:01:33 <liiae> dminuoso: yes
03:01:37 <dminuoso> Now, recall its a directed graph!
03:01:52 <dminuoso> It turns out, that if you flip all directed edges/arrows around (so they connect in reverse)
03:02:04 <dminuoso> Then you sort of get the same property again.
03:02:17 <dminuoso> And in that "all arrows flipped around" you call it a Cofoo.
03:02:32 <dminuoso> So in the "regular world" the object of interest is a Foo, and in the "flipped aroud world" you call it Cofoo.
03:03:19 <dminuoso> actually let me iterate
03:03:21 <dminuoso> 12:01:43         dminuoso | Then you sort of get the same property again.
03:03:23 <dminuoso> This was wrong.
03:03:26 * hackage quickspec 2.1.4 - Equational laws for free!  https://hackage.haskell.org/package/quickspec-2.1.4 (NickSmallbone)
03:03:32 <dminuoso> The object Foo in this opposite world has suddenly *different* special properties.
03:03:58 <dminuoso> So, if it has properties in one world, it has different but related properties in the "all arrows reversed" world.
03:06:45 <dexterfoo> what is the correct way to call a rust function with a single "i64" parameter? Should i use the haskell "CLong" type, or "Int64" type? Or something else?
03:07:03 <merijn> liiae: For Comonads, yes, not for monads
03:07:25 <merijn> dexterfoo: Int64
03:07:53 <dexterfoo> merijn: thank you. this will work correctly on 32bit and 64bit operating systems?
03:07:56 * hackage monad-control-identity 0.1.0.1 - Stronger classes than monad-control  https://hackage.haskell.org/package/monad-control-identity-0.1.0.1 (jumper149)
03:08:11 <liiae> dminuoso: what this Coyoneda related to `fmap (f . g)` ?
03:08:22 <merijn> dexterfoo: Int64 is always 64 bits, that's the point of it being Int64 ;)
03:09:03 <merijn> Also, at this point in time I say "sod anyone with a 32bit OS, join us in the 21st century, luddites"
03:09:24 <liiae> what's the relation between monad and yoneda?
03:09:38 <dminuoso> If you want to learn the relationships, learn category theory
03:09:50 <dminuoso> If not, just trust that Coyoneda is a trick to get fusion on fmap.
03:10:05 <dminuoso> (That is, if you do repeated `fmap f` applications, use Coyoneda if fmap has non-trivial costs)
03:10:20 <dminuoso> Think of it as an "efficient fmap" :)
03:11:07 <liiae> ok...
03:11:59 <liiae> dminuoso: what about that `uncurry (flip fmap)`
03:12:10 <liiae> that's weird, I never saw that
03:12:21 <liiae> which case I would use that code?
03:17:35 <liiae> ok, I found that article
03:18:00 <liiae> :t flip fmap -- yoneda
03:18:01 <lambdabot> Functor f => f a -> (a -> b) -> f b
03:18:13 <liiae> :t uncurry fmap -- coyoneda
03:18:15 <lambdabot> Functor f => (a -> b, f a) -> f b
03:21:01 <dminuoso> lambdabot: Not really. :)
03:21:18 <liiae> adjoint functor, natural isomorphism, profunctor, hom-functor,  what I'm reading...
03:21:49 <merijn> liiae: Math! :p
03:22:03 <stefan-_> :t fmap
03:22:04 <lambdabot> Functor f => (a -> b) -> f a -> f b
03:22:21 <merijn> liiae: Actually, how did you get into this discussion? :p What did you wanna know?
03:24:23 <liiae> merijn: I just want to understand yoneda lemma in haskell simply, and what it's used to do
03:24:48 <merijn> ah, then you've only got yourself to blame ;)
03:24:51 <bewakes> Hi, do we have any class that is superset of Rational and Num? I want to return either (Num a) or Rational from a function. How should I do that?
03:25:08 <merijn> bewakes: You mean Fractional?
03:25:36 <dminuoso> liiae: The Yoneda lemma requires quite a bit of category theory to understand.
03:25:40 <liiae> fine...
03:25:45 <merijn> Also, Num is a superclass of Fractional...
03:25:50 <dminuoso> It's nothing you can absorb in an afternoon.
03:26:05 <merijn> dminuoso: That explains why I haven't bothered ;)
03:34:09 <typetetris> Strange, I thought cassava would raise an error, if some expected text isn't utf8. Now it just turned a byte of value 255 into the string "\255" ...
03:38:03 <dminuoso> typetetris: what type are you FromField'ing into?
03:38:08 <bewakes> merijn: Ah, fractional, Let me see if that works.
03:38:57 <typetetris> dminuoso: Text, but I found my error. Just didn't properly destroy my test data.
03:39:02 <dminuoso> :)
03:55:26 * hackage effet 0.1.0.0 - An Effect System based on Type Classes  https://hackage.haskell.org/package/effet-0.1.0.0 (MichaelSzvetits)
03:59:26 <typetetris> Why doesn't `cassava-conduit` just use the `MonadThrow`instance on the conduits for stream halting errors. This MonadError really makes it a pita to combine it with RessourceT (`sourceFileBS` and stuff). Or is there some easy way I am missing?
04:02:21 <christianne> my test
04:03:08 <typetetris> your test succeeded (I guess)
04:08:40 <dminuoso> typetetris: because MonadThrow and MonadError are really different things
04:12:38 <typetetris> dminuoso: Mental block. put the runExceptT in front and then didn't parse the type error correctly, which is more than obvious in hindsight. 
04:12:43 <typetetris> Maybe I need a break.
04:12:55 <dminuoso> typetetris: You can just newtype it, and implement MonadError to throw.
04:13:05 <dminuoso> Or that.
04:14:05 <typetetris> Hmm, still get `No instance for (MonadUnliftIO (ExceptT String IO))`
04:14:15 <dminuoso> Of course.
04:14:24 <dminuoso> Where does the MonadUnliftIO come from?
04:14:32 <typetetris> `runConduitRes`
04:14:42 <typetetris> `runExceptT $ runConduitRes $ sourceFileBS "ExampleData.csv" .| fromNamedCsvStreamError defDecodeOptions show .| mapM_C (liftIO . (print :: Either CsvStreamRecordParseError Cdr -> IO ()))`
04:14:54 <dminuoso> Well, transform the Left into an exception.
04:14:59 <dminuoso> Get rid of ExceptT
04:15:23 <dminuoso> 13:12:33         dminuoso | typetetris: You can just newtype it, and implement MonadError to throw.
04:15:42 <dminuoso> (Use GND to de-derive all other usual instances you want from your stack)
04:16:18 <dminuoso> Or rewrite cassava-conduit
04:17:03 <siraben> I've used cassava, how does cassava-conduit compare?
04:17:17 <absence> i want to kill a thread from a signal handler, and the documentation for the safe-exceptions package suggests to use the async package. that's great, because i already use its race/concurrently combinators, but in order to kill a thread, it seems like I need an "Async a" value to pass to cancel? is that correct, and does it mean i have to lose the race/concurrently convenience in order to safely kill thre
04:17:19 <dminuoso> *conduit-cassava
04:17:20 <siraben> Not familiar with the conduit library either
04:17:23 <absence> ads?
04:17:44 <typetetris> siraben: Just cassava and conduit for streaming
04:17:57 <typetetris> siraben: So you get nice bounded memory.
04:18:04 <dminuoso> absence: What do you mean by "lose the race" exactly?
04:18:06 <siraben> typetetris:  I see.
04:18:49 <absence> dminuoso: loose the convenience of the race/concurrently combinators
04:18:56 <absence> lose*
04:19:48 <dminuoso> absence: You can build a tree of asyncs.
04:20:01 <dminuoso> And then, in your signal handler, just cancel the root one.
04:20:04 <dminuoso> Then the entire tree goes down.
04:21:06 <dminuoso> Well actually, what do you mean by "lose the concenienve"?
04:21:10 <absence> dminuoso: right, so it means i can't use "race" and "concurrently"?
04:21:14 <dminuoso> why not?
04:21:52 <absence> dminuoso: because they don't give me an "Async a" value i can pass to cancel
04:23:44 <dminuoso> absence: I see. Well you can just use withAsync yourself.
04:24:00 <dminuoso> You can emulate the behavior of race with waitEither and concurrently with waitBoth
04:25:34 <dminuoso> absence: Actually staring at this, with race/concurrently you get automatic abortion already
04:26:27 <absence> dminuoso: yes, problem is how to perform the abort
04:26:58 <dminuoso> absence: put everything in a thread.
04:27:54 <absence> dminuoso: using the "async" function? (you mentioned withAsync, but i don't think that gives me "Async a" either)
04:27:58 <dminuoso> `t <- async (race ...)` and then you can call `cancel t` in your signal handler.
04:28:03 <dminuoso> For example, sure.
04:30:09 <absence> oh wait, it does provide the "Async a", i'm supposed to put all the code in the second argument
04:31:02 <absence> dminuoso: thanks, it feels a bit convoluted to make dummy threads, but given the complexity of exception handling, i'm sure the alternative is worse :)
04:43:13 <typetetris> oh my goodness: `catchError action handler = MyExceptT $ withRunInIO $ \unlift -> (unlift (runMyExceptT action) `catch` (\e -> unlift (runMyExceptT (handler e))))` or how could that be easier? `MyExceptT` is a newtype wrapper around `ResourceT IO`.
04:48:55 <dminuoso> absence: well, you could also just use withAsync yourself.
04:49:38 <dminuoso> say:
04:49:56 <dminuoso> `withAsync $ \l -> withAsync $ \r -> ... `
04:50:03 <dminuoso> Then you can just throw cancel at `l` and `r` as you like it.
04:50:40 <dminuoso> Or, pretty wrap it in an async, wait on it, and put the async handle from `async` into your signal handler
05:08:04 <jchia_> Is there a library function Bool -> Maybe () that returns Nothing for False and Just () for True?
05:10:25 <jchia_> :t guard
05:10:27 <lambdabot> Alternative f => Bool -> f ()
05:10:36 <typetetris> `https://hoogle.haskell.org/?hoogle=Bool%20-%3E%20Maybe%20()`
05:10:40 <absence> dminuoso: i think my problem is that i want to cancel l from within r for example, which i guess means mvars or something
05:11:19 <absence> dminuoso: would be much nicer if a thread was given its own Async handle
05:11:45 <hpc> unsafeCoerce technically works too :D
05:11:56 <hpc> or wait, that's the other way around
05:13:16 <maralorn> jchia_: Nice find. Although I am not convinced that that will make your code more readable.
05:13:38 <jchia_> It'll make my code more concise in some cases
05:13:49 <dminuoso> o.o
05:14:14 <jchia_> findSomething <* guard doIReallyWantit
05:14:27 <jchia_> doIReallyWantIt :: Bool, findSomething :: Maybe a
05:15:22 <dminuoso> jchia_: That smells like an antipattern
05:15:32 <jchia_> Why?
05:16:15 <dminuoso> jchia_: If at all, I'd rather do: () <$ findSomething
05:16:31 <dminuoso> That makes the intent clear.
05:16:53 <dminuoso> Ah wait. what
05:17:44 <dminuoso> I suppose the guard code is concise. it just took a few minutes to grasp what you're doing.
05:18:47 <jchia_> findSomething <* guard doIReallyWantit :: Maybe a. It's not Maybe (). In context, I have a UI where there are 3 lists. Each list has its own selection and above that one of the 3 lists can be selected. I want to get a selected item from the first list. findSomething returns Maybe a for the selection in the first list. doIReallyWantIt tells me whether the first list is selected. I will get a Just if the first list is selected and it has 
05:18:47 <jchia_> an item selected.
05:19:16 <jchia_> if the first list has no selection or the first list itself is not the selected list, then I get Nothing
05:20:41 <jchia_> I could nest one layer of case, but my code already takes a lot of horizontal space. I could break out something into another function. I suppose in the end it depends on familiarity with guard and the frequency of using this idiom.
05:25:11 <jchia_> I ended up expressing this another way
05:34:08 <merijn> jchia_: Don't you just want the Alternative instance of Maybe?
05:36:37 <jchia_> merijn: I used guard at first, which is about maybe, then I ended up changing to something else. (selectedFirstList :: Maybe UiList) >> (selectedListItem :: UiList -> Maybe UiListItem) :: Maybe UiListItem
05:36:47 <jchia_> i mean guard is about Alternative
05:37:12 <merijn> I meant like:
05:37:14 <merijn> :t asum
05:37:15 <lambdabot> (Foldable t, Alternative f) => t (f a) -> f a
05:37:18 <merijn> :t (<|>)
05:37:19 <lambdabot> Alternative f => f a -> f a -> f a
05:41:29 <frdg> Is there a way to get info on type classes from a repl similar to `:t` and `:i`?
05:41:48 <merijn> frdg: There was a way to get haddocks in ghci, but I forget how
05:42:04 <maerwald> :doc
05:42:07 <maerwald> ?
05:43:37 <frdg> Ya :doc gives the haddock
05:44:26 <frdg> Another thing I have been wishing existed is graphs of type class hierarchies for every library
05:46:02 <absence> dminuoso: withAsync works for installing a signal handler, but if the code i want to run is "doWorkWithErrorHandler (killThreadFromHere)", it seems i'm out of luck
05:46:10 <boxscape> that seems non-trivial once you get into multi-parameter typeclasses
05:46:38 <boxscape> i.e. What should the graph for (Ord a, Show b) => MyClass a b look like
05:48:21 <absence> dminuoso: i guess that in general it's safest to use async for cancelling threads, but if i have to start threading things around in mvars, it seems like it's easier to throw an async exception and catch it somewhere, even though packages like safe-exceptions really don't want me to do that
05:48:40 <absence> or is there a trick i'm not seeing?
06:31:27 * hackage stackcollapse-ghc 0.0.1.2 - Program to fold GHC prof files into flamegraph input  https://hackage.haskell.org/package/stackcollapse-ghc-0.0.1.2 (rzeznik)
06:47:45 <xwvvvvwx> Hi, I'm learning haskell, and following along with some example code about the composition of various algebraic structures, and I've come across an example that does not compile. The error is quite mysterious to me, and I'm wondering if someone here might have some insight.
06:47:56 <xwvvvvwx> The code and error is here: https://ipfs.io/ipfs/QmRJVfF1gZycu48imapmRZDS1vwYPK4NvHFngCHwTnsgF7/Main.html
06:48:36 <xwvvvvwx> In essence the `tuple2` function should allow for the composition of two lax monoidal functors (the `Monoidal` typeclass).
06:49:51 <xwvvvvwx> Does someone have some tips or advice for implementing this function?
06:53:14 <absence> xwvvvvwx: did you mean "tuple2 (x, y)" rather than "tuple2 x y"?
06:53:34 <xwvvvvwx> oups
06:53:35 <xwvvvvwx> yes
06:56:47 <xwvvvvwx> corrected example & error: https://ipfs.io/ipfs/QmVwfwKXeiZB26Znt5T3MGcBm4iKaFZZMY9KLwHEMFLNVa/Main.html
06:56:53 <Uniaika> french detected!!!!
06:57:21 <Uniaika> (nice pandoc btw)
06:58:46 <xwvvvvwx> I'm not french :D and thx :)
06:58:46 <Rembane> xwvvvvwx: What happens if you remove fmap (&&&) in tuple2? 
07:00:25 <xwvvvvwx> Rembane: https://ipfs.io/ipfs/QmQjsFKBy1HYnXxyGcuAa7rN3icwEfrj9AQLN2xvgT1HpL/hi.html
07:01:11 <xwvvvvwx> (&&&) is correctly applied to the outer Monoidal, giving `f (g a, g b)`
07:01:37 <xwvvvvwx> but when I try to fmap (&&&) onto the inner Monoidal something goes wrong
07:01:56 <Rembane> xwvvvvwx: Well, that gives the clue that you need to unwrap f from x and y, and then unwrap the gs and then combine them.
07:04:00 <xwvvvvwx> Rembane: hmmmm, how would I unwrap f from x and y?
07:04:49 <xwvvvvwx> I don't think I can get to the inner types with pattern matching?
07:05:01 <xwvvvvwx> Or at least I don't know how to write a pattern that can do that...
07:05:03 <Rembane> That's true and makes it harder 
07:05:54 <lortabac> I would simply rely on Applicative (though it might be considered cheating)
07:06:41 <Rembane> I gotta go, good luck!
07:08:49 <dolio> xwvvvvwx: Without the `fmap`, you still wrote `tuple2 (x, y) = x &&& y` to get `(f a, f b) -> f (a, b)` right?
07:09:39 <dolio> You can't write `tuple2 = (&&&)`. But that's effectively what you're doing for the `fmap` part.
07:10:21 <dolio> You have `f (g a, g b)` and need `(g a, g b) -> g (a, b)`.
07:10:29 <dolio> For the fmapping.
07:11:03 <dolio> But `(&&&) :: g a -> g b -> g (a, b)`
07:15:19 <xwvvvvwx> hmmm yes, maybe I can just make a little lambda or something in a where block?
07:15:58 <xwvvvvwx> yes!
07:16:38 <xwvvvvwx> https://ipfs.io/ipfs/QmSKS4Gg2kCLSTXYtwN7v8XLeeJdrzuvWFvi8bLn3werM7/Main.html
07:16:48 <xwvvvvwx> thanks dolio!!
07:16:51 <xwvvvvwx> much appreciated :)
07:17:02 <dolio> There is also a function that does this.
07:17:06 <dolio> :t uncurry
07:17:08 <lambdabot> (a -> b -> c) -> (a, b) -> c
07:18:22 <dolio> You don't actually need the where clause either, of course.
07:25:28 <absence> what could be wrong when the print doesn't trigger? withException (flip throwTo ShutdownException =<< myThreadId) (\e -> print (e :: ShutdownException))
07:27:45 <dolio> `throwTo` is asynchronous, so maybe it's not actually getting thrown to your thread until the `withException` no longer applies?
07:29:49 <dolio> Oh, no, the docs say that it doesn't work like that.
07:30:05 <absence> dolio: i do get the top-level "*** Exception: ShutdownException" 
07:30:13 <jumper149> Is there an easy way to read offline haddock documentation when in a nix-shell?
07:30:48 <absence> dolio: do you mean the docs says it doesn't work like what i'm trying, or about the async part you suggested?
07:31:05 <dolio> No, they say it doesn't work like I was guessing.
07:31:17 <dolio> It says it works like `throwIO` if you throw to yourself.
07:31:47 <nlhowell> I have several Nat-parameterised types that behave similarly; is there some upgraded notion of typeclass I can use?
07:32:41 <nlhowell> e.g. all have `data X (n :: Nat)` , and methods `productX`, `restrictX`
07:33:22 <nlhowell> the former has signature `productX :: X n -> X m -> X (n+m)`
07:33:37 <dolio> absence: Does it work if you use `throwIO` though?
07:34:30 <absence> dolio: hm, no
07:34:44 <absence> dolio: no wait, i mean yes :D
07:35:19 <absence> dolio: so it's the async part that doesn't work
07:35:35 <lortabac> nlhowell: aren't standard type classes enough?
07:35:36 <dolio> Maybe something changed and it isn't reflected in the documentation.
07:36:52 <nlhowell> lortabac: how can I have access to both X n and X m for the signature in the class?
07:37:47 <nlhowell> I need something like `instance C X`, but `X :: Nat -> *`
07:37:49 <nlhowell> is that possible?
07:38:00 <lortabac> nlhowell: class X t where product :: t n -> t m -> t (n + m)
07:38:15 <lortabac> unless I misunderstood what you are trying to do
07:39:55 <nlhowell> and just `instance C X where ...` ? i think i tried it, let me check again
07:44:45 <nlhowell> lortabac: ok, that seems to work; and what about if i have more type parameters?
07:45:22 <nlhowell> e.g. a type Y :: Nat -> * -> *
07:45:59 <nlhowell> can I write something like `instance C (\ n -> Y n a)` , where a is my extra type parameter?
07:46:46 <lortabac> nlhowell: no, this is not possibile
07:48:10 <lortabac> nlhowell: you might need to add a parameter to the type class (depending on how this new variable is used)
07:50:59 <boxscape> nlhowell you might be able to do something like `newtype FlippedY a n = Y n a` and then `instance C (FlippedY a), I think
07:51:21 <boxscape> that might or might not be enough for what you want
07:51:48 <nlhowell> lortabac: well, the new variable doesn't really interact with this class
07:52:10 <nlhowell> boxscape: ok, i will try this; it's an interesting idea
07:54:48 <nlhowell> boxscape: I am having trouble with the alias; does the rhs expect the type or the constructor?
07:55:29 <boxscape> nlhowell er, newtypes need an additional constructor, so newtype FlippedY a n = FlippedY (Y n a) for example
07:55:52 <nlhowell> oh, so i will have to apply this constructor any time i wish to use the functions from the typeclass?
07:56:04 <boxscape> nlhowell yeah, that's the main downside of this
07:56:32 <nlhowell> hmm ok
07:57:13 <boxscape> nlhowell type level lambdas like you tried to use above are something that a lot of people want and might enter the language at some point, but it's definitely still a ways off
07:58:02 <boxscape> (though if we somehow get the ability to use type synonyms in instances before then it would alleviate that somewhat)
08:00:01 <dolio> You can't have arbitrary lambda expressions as instances because it becomes impossible to infer what the instance is supposed to be for.
08:01:03 <boxscape> dolio hm, what do you suppose will happen if/when type level lambdas are introduced? You still won't be able to use them in instances?
08:01:06 <dolio> Or rather, which instance should be used at use sites.
08:01:17 <dolio> Yes, that is the sensible restriction.
08:01:22 <boxscape> hm, okay
08:14:56 * hackage wai-control 0.1.0.0 - Give wai Applications an IO-based inner monad  https://hackage.haskell.org/package/wai-control-0.1.0.0 (jumper149)
08:18:56 * hackage git-cuk 0.0.1 - Haskell Git Helper Tool  https://hackage.haskell.org/package/git-cuk-0.0.1 (shitiomatic)
08:22:35 <polyphem> if i have have a function "ternary :: x -> a -> b" , why cant i do "a `ternary x` b" ?
08:24:34 <ChaiTRex> polyphem: That has b as a final output, not as an argument.
08:25:14 <ChaiTRex> polyphem: ternary is called bool in Haskell, I think.
08:25:31 <ChaiTRex> polyphem: If you mean the standard ternary operator in other languages.
08:25:32 <kuribas> :t bool
08:25:33 <lambdabot> a -> a -> Bool -> a
08:25:50 <kuribas> ChaiTRex: the order of arguments is different
08:25:59 <ChaiTRex> polyphem: See how it has four parts in its type?
08:26:10 <ChaiTRex> kuribas: True.
08:26:16 <dolio> polyphem: You can't put arbitrary expressions inside backticks.
08:26:59 <dolio> It is a syntax for making prefix function names infix.
08:27:06 <AWizzArd> Question for the Nix gurus: I am using this Nix template file: https://github.com/Gabriel439/haskell-nix/blob/master/project0/project0.nix
08:27:09 <AWizzArd> Now I wanted to add curl, and I've done this by adding `curl` to line 1, inside the curly braces, and by adding a new line `buildDepends = [ curl ]`. But when I start this in a nix shell there is no curl available: `nix-shell --pure -A env release.nix`
08:27:18 <AWizzArd> How do I need to update that nix file to have curl available in an otherwise pure nix shell?
08:27:47 <polyphem> ok , my fault , i meant :  "ternary :: x -> a -> a -> a" , why cant i do "a `ternary x` a" ? use partially applied func as infix operator .
08:28:48 <dolio> You just can't. That's the rule. :)
08:29:00 <ChaiTRex> polyphem: Backticks only allow one 'word', so to speak.
08:29:03 <polyphem> > let f x a a = x a a in 4 `f (+)` 5
08:29:05 <lambdabot>  <hint>:1:29: error: parse error on input ‘(’
08:29:37 <polyphem> ChaiTRex: yeah, i see, only "one" word :(
08:30:34 <dolio> The presumable reason is that it becomes very difficult to parse otherwise.
08:30:44 <[exa]> polyphem: consider operators like `x `oper` y`
08:32:17 <polyphem> [exa]: ok nesting is taking it to far , however partially apply a func would be nice like : "a `linkWith something` b"
08:32:46 <[exa]> ...and no one wants to parse it as mode-switching, like $ in tex
08:33:52 <[exa]> polyphem: just ⌜linkWith something a b⌝ might even read better. infix is sometimes overrated
08:35:28 <polyphem> hmm ..
08:36:03 <MarcelineVQ> occasionally someone brings up writing   a &ternary x$  b
08:37:37 <[exa]> wow that's cool
08:38:02 <[exa]> (bonus feature: looks a bit like ^full line regex$ )
08:50:39 <c_wraith> You can always just implement it yourself....
08:50:41 <c_wraith> > let a <| b = flip b a ; infixl 1 <| ; a |> c = a c ; infixl 1 |> in Just 1 <| liftA2 (+) |> Just 2
08:50:43 <lambdabot>  Just 3
08:56:16 <kuribas> ugh, from and to are the worst named functions in haskell
08:56:26 <kuribas> from what?  to what?
08:56:37 <kuribas> The one in Generics, not Lens
08:56:54 <kuribas> why not fromRep, toRep?
08:57:31 <c_wraith> toEnum and fromEnum are pretty bad, too. I always expect them to work the opposite of how they do.
08:57:45 <kuribas> :t toEnum
08:57:46 <lambdabot> Enum a => Int -> a
08:58:09 <kuribas> should be intToEnum
08:58:14 <c_wraith> funny, that's what I expected today. maybe I've finally learned.
09:00:05 <ezzieyguywuf> so, when using megaparsec, if I wanted to "lex" first then "parse", I guess I would do something like `myLexer :: Text -> Parser [Token]` and then `myParser :: [Token] -> Expression` or something like that?
09:00:16 <ezzieyguywuf> I'm just getting confused between all the parsing lingo
09:02:26 * hackage wai-control 0.1.0.1 - Give wai Applications an IO-based inner monad  https://hackage.haskell.org/package/wai-control-0.1.0.1 (jumper149)
09:02:56 <solonarv> you might have 'lex :: Parsec e Text [Token]' and 'parse :: Parsec e [Token] Expression'
09:03:53 <ja> AWizzArd: are you sure the env is getting rebuilt at all? i had a problem recently where i noticed it only rebuilt if i used nix-build instead of nix-shell
09:05:01 <kuribas> ezzieyguywuf: sure, that's reasonable
09:05:04 <ja> which is not what i would expect since i gave it the file name of a file that changed, i thought it would notice that
09:06:15 <ezzieyguywuf> kuribas: so in that case I'm only using megaparsec for lexing, and using some sort of other logic for the parsing
09:06:21 <ezzieyguywuf> unless I do something like solonarv said
09:07:07 <kuribas> ezzieyguywuf: the other way around is more common
09:08:21 <ezzieyguywuf> kuribas: you mean using something else to lex and then mepaparsec to parse?
09:08:33 <ezzieyguywuf> I guess `words inputText` could be considered the 'lex' stage
09:08:39 <kuribas> ezzieyguywuf: yeah.  But using megaparsec to lex is also fine.
09:08:48 <ezzieyguywuf> but then my tokens are all String, they're not `Token`
09:08:59 <ezzieyguywuf> hah all this parsing stuff is pretty confusing
09:09:04 <kuribas> ezzieyguywuf: type Token = String :-)
09:10:07 <ezzieyguywuf> kuribas: hah, nice.
09:11:19 <ezzieyguywuf> So my problem statement is: I want to take an arbitrary string, and turn it into a "Command" that the user can execute in a REPL-interface, i.e. "quit", "print", "help", etc. where the "Command" may have argument(s), i.e. "help quit", "help print", "addThings 1 2" etc.
09:11:55 <ezzieyguywuf> so I was thinking of doing `data Command = Help (Maybe Command) | Quit | Print` and then 'lexing' the input to create a `[Commond]`
09:11:58 <ezzieyguywuf> but this doesn't seem right...
09:12:26 * hackage monad-control-identity 0.1.0.2 - Stronger classes than monad-control  https://hackage.haskell.org/package/monad-control-identity-0.1.0.2 (jumper149)
09:13:04 <Cheery> ezzieyguywuf: So you want a command. Well it's a (string → Maybe command)
09:13:51 <ezzieyguywuf> Cheery: yes that's ultimately what I want
09:14:40 <Cheery> your 'data' command is an abstract syntax tree
09:14:46 <Cheery> it's fine way to do this.
09:14:50 <ap_> how to setup ide for haskell?
09:15:25 <Cheery> ap_: I use ubuntu and probably in future nixos
09:15:36 <ap_> i use macos & windows
09:15:38 <Cheery> the whole OS is my ide
09:15:54 <kuribas> ap_: maybe visual studio code with hie?
09:16:07 <ap_> it leaks memory
09:16:49 <kuribas> leaks how?
09:16:56 <kuribas> then you restart it?
09:17:19 <ap_> i have around 200 files, it keeps on reloading them for no reason
09:17:29 <monochrom> IDE roast: https://youtu.be/FyCYva9DhsI?t=1858
09:17:46 <ap_> it also sometimes does not update lint in the file unless i reload vscode
09:18:07 <ezzieyguywuf> Cheery: the part that I'm getting tripped up on is - what do I use megaparsec for? where in the `string -> Maybe Command` does it fit in?
09:18:15 <kuribas> ap_: emacs with flycheck mode then?
09:18:36 <ap_> wish there was something like intellij
09:19:04 <ap_> i don't like emacs & vim because there is high learning curve and 
09:19:18 <ap_> seems like i am just complaining
09:19:19 <kuribas> ap_: there are plugins for intellij
09:19:31 <kuribas> ap_: but I never tried them, so I don't know how well they work
09:19:45 <kuribas> ap_: AFAIK a lot of people are happy with them.
09:19:53 <ap_> they only do identifier completion i think
09:19:59 <ap_> haskell ide engine is very good
09:20:11 <ap_> but i think it will need few years before it becomes stable
09:20:22 <c_wraith> instead of "an ide", what features do you actually want?
09:20:57 <ap_> code completion, show types, jump to definition
09:21:00 <ap_> linting
09:21:05 <frdg> I have a link to a json file that is from an api request I made to a website. How could I extract this page into a file that I can parse? 
09:21:16 <c_wraith> I never got value from anything past indentation assistance.
09:21:33 <ap_> irrelevant.
09:22:59 <LCRERGO> how could I create a circular list in Haskell?
09:23:19 <int-e> > let xs = 1 : 2 : 3 : xs in xs
09:23:21 <lambdabot>  [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2...
09:24:07 <int-e> > cycle [1,2,3]
09:24:09 <lambdabot>  [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2...
09:24:34 <seanparsons> int-e: Beat me to it!
09:25:32 <int-e> LCRERGO: thanks to lazy evaluation both of those actually evaluate to circular (linked) lists.
09:26:56 <dsal> ezzieyguywuf: You just write a `Parser Command`.  When you run the parser, it will give you the thing yo want (or an error describing why it couldn't).
09:26:59 <solonarv> LCRERGO: is this the "circular list" you were asking for, or did you mean something different?
09:27:16 <LCRERGO> I think I meant something different
09:27:51 <LCRERGO> I guess I wanted a datatype just like Enum that could be wrapped
09:28:14 <LCRERGO> so I could access "succ x" of an element
09:28:18 <LCRERGO> and wrap around
09:29:04 <dsal> LCRERGO: I have `succ' :: (Bounded a, Enum a, Eq a) => a -> a` in some toolboxes.
09:30:31 <dsal> Though if you wanted `everything :: (Bounded a, Enum a, Eq a) => a -> [a]` that's just something like `allthethings = [minBound..] <> allthethings`
09:31:17 <dsal> > let allthethings = [minBound ..] <> allthethings in    allthethings :: [Bool]
09:31:19 <lambdabot>  [False,True,False,True,False,True,False,True,False,True,False,True,False,Tru...
09:31:55 <dsal> > let allthethings = cycle [minBound ..] in    allthethings :: [Bool]
09:31:57 <lambdabot>  [False,True,False,True,False,True,False,True,False,True,False,True,False,Tru...
09:32:16 <dsal> > let allthethings = cycle [minBound ..] in    allthethings :: [Int8]
09:32:18 <lambdabot>  [-128,-127,-126,-125,-124,-123,-122,-121,-120,-119,-118,-117,-116,-115,-114,...
09:32:46 <dsal> :t cycle [minBound ..]
09:32:47 <lambdabot> (Bounded a, Enum a) => [a]
09:32:56 <dsal> Oh yeah, don't need Eq for this one.
09:35:42 <ezzieyguywuf> dsal: I understand the concept of writing a `Parser Command`, but then how do I split it between "lexing" and "parsing"?
09:38:42 <monochrom> There are two ways.
09:39:16 <monochrom> One is the input stream you give to the parser is already a stream of tokens. Something else made those tokens.
09:40:12 <monochrom> Another is your parser still takes input string directly, you have some parser command that plays the role of chunking out one token, and some other parser commands do purely CFG things.
09:40:39 <ezzieyguywuf> hrm I see
09:41:03 <ezzieyguywuf> in the case of the former, my parser would be something like `type Parser = Parsec Void MyTokens`
09:41:13 <Cheery> ezzieyguywuf: sorry I was distracted by a person trying to teach monads without understanding type theory or category theory
09:41:32 <Cheery> lets check on megaparsec a bit
09:41:41 <monochrom> my course notes show the 2nd one. http://www.cs.utoronto.ca/~trebla/CSCC24-2020-Winter/08-parsing.html
09:42:09 <monochrom> It uses my own Parser type, but the lessons apply to parsec and megaparsec just as well.
09:42:12 <Cheery> ezzieyguywuf: https://hackage.haskell.org/package/megaparsec-8.0.0/docs/Text-Megaparsec.html
09:42:34 <Cheery> https://markkarpov.com/tutorial/megaparsec.html
09:42:46 <ezzieyguywuf> Cheery: Yea I've been clunking my way through the tutorial
09:42:55 <ezzieyguywuf> monochrom: I'll take a lok at your notes thanks
09:43:03 <monochrom> I have a "lexeme/token level", then I have a "CFG parsing" level that calls the lexeme/token level.
09:43:46 <ezzieyguywuf> what is CFG?
09:44:14 <Cheery> ezzieyguywuf: context free grammar
09:44:30 <Cheery> you get terminals, nonterminals, thoes are symbols
09:44:34 <monochrom> it's when you say something like "expr ::= openparen expr closeparen | varname"
09:44:52 <Cheery> then you got production rules that give rules for how nonterminals form.
09:45:15 <ezzieyguywuf> ah yes, contex-free grammar
09:45:18 <ezzieyguywuf> I've been reading about this.
09:45:35 <Cheery> in monochrom's example, he states two rules for how 'expr' forms. They are separated by colon
09:46:35 <Cheery> in CFG you see how it forms that kind of sequences and alternation.
09:47:23 <Cheery> Monad and MonadPlus can encode those ideas.
09:48:34 <Cheery> the megaparsec module, and parser combinators, produce a way to merge syntactic definition and the way to construct it into an abstract syntax tree.
09:48:57 <ezzieyguywuf> I'm still working through understanding what an abstract syntax tree is
09:49:12 <Cheery> the abstract syntax tree describes syntax, but abstractly
09:49:25 <Cheery> for example your "data Command" is an abstract syntax tree
09:50:38 <ezzieyguywuf> yea, but my `data Command` is poorly written, as it allows for `Help (Just Help (Just Help (...infinitely)`
09:51:15 <Cheery> that's super funny
09:51:22 <Cheery> yeah.
09:51:43 <Cheery> yup, you need CommandDesc
09:51:46 <Cheery> or CommandTag
09:51:55 <dsal> Or just a separate toplevel thing that's Help or a Command
09:52:01 <Cheery> that then got HelpTag | ExitTag | PrintTag
09:52:17 <ezzieyguywuf> `data Toke = HelpTag | ExitTag | PrintTag`
09:52:21 <ezzieyguywuf> s/Toke/Token/
09:53:10 <Cheery> well that's one way
09:53:27 <ezzieyguywuf> So then my parser would be `type Parser = Parsec Void Token`, but what are the repurcussions of using not Text or Char or Byte or w/e for the parser? Do I have to define instances for Applicative and stuff?
09:53:30 <Cheery> not sure it's token, it's just string in beginning of the command that says which one it is?
09:54:29 <Cheery> hm.. well Parsec probably doesn't rely on much of properties of Text?
09:54:38 <Cheery> the types actually tell that if they do.
09:54:39 <ezzieyguywuf> hah I dunno, this is why my brain is all wrapped up and confused
09:56:20 <dsal> What does your input look like?
09:56:35 <dsal> Oh, it says it up there...
09:57:44 <ezzieyguywuf> input could be "help", "help show", "show v1", "addVertex 10 20 30", "makeEdge v1 v2", etc.
09:58:57 <Cheery> is there a specific reason why you want tokenization?
09:59:12 <Cheery> with utilities such as megaparsec it's kind of superfluous detail
09:59:17 <dsal> If you're parsing a string.  You could literally have a type like your token above and do something like     `parseToken :: Parser Token;   parseToken = HelpTag <$ symbol "help" <|> ExitTag <$ symbol "exit    ...`
09:59:53 <ezzieyguywuf> Cheery: no, I'm just trying to write this in such a way that it is maintainable and understandable
09:59:54 <dsal> The `option` combinator will handle  `help` vs. `help x`
10:00:07 <ezzieyguywuf> I've been reading/learning about parsing and such and it seems that it's a best practice to first lex then parse
10:00:20 <dsal> Are the docs you're reading from the 70s?  :)
10:00:30 <ezzieyguywuf> dsal: *optional, maybe?
10:00:34 <dsal> Idiomatic megaparsec is very readable and maintainable.
10:00:38 <ezzieyguywuf> dsal: lol, actually some of them are.
10:01:04 <Cheery> lex is traditionally needed if you want to do pure context-free-grammar parsing and carve words out of identifiers as keywords.
10:01:10 <ezzieyguywuf> dsal: therefore, I shouldn't worry so much about splitting out the lex/parse step, and just focuse on writing "idiomatic" megaparsec stuff?
10:01:16 <Cheery> otherwise it's not mathematically necessary.
10:01:59 <ezzieyguywuf> I imagine that maybe one day I would want to do something like `fmap addVertex [p1, p2, p3, etc...]`, but maybe not
10:02:28 <Cheery> ok, so what kind of arguments do you have?
10:02:45 <Cheery> make parsers for each of those
10:03:22 <Cheery> Parser AST, where the 'AST' is the abstract syntax given, eg. if it's number of some sort, then it's probably Integer.
10:03:44 <dsal> Yeah... for simple things like this, I usually just write out an example of the input I want and the AST and parser almost write themselves.
10:05:11 <Cheery> Then you do symbol "addVertex"; x <- numericArgument; y...; pure (AddVertex (x,y,z))
10:06:10 <ezzieyguywuf> hrm
10:06:23 <ezzieyguywuf> I had actually started somewhat along these lines, not even using megaparsec.
10:06:40 <dsal> Your toplevel parser is just something that chains a bunch of those together with asum or <|> or something.
10:07:04 <ezzieyguywuf> https://gitlab.com/ezzieyguywuf/mycad/-/blob/drawEntity/MyCAD/app/TUI/CommandParser.hs#L109
10:08:25 <ezzieyguywuf> I'm trying to rewrite this using megaparsec, because I think it will be easier to extend in the long-run
10:08:46 <dsal> It's slightly funny to me that your type is centered around failure rather than success.  :)
10:09:29 <ezzieyguywuf> hah, I'm admittedly stumbling my way through this
10:09:38 <dsal> That's the only way to do it.
10:09:39 <ezzieyguywuf> one of my goals with this project is to learn more about programming and stuff :-P
10:10:05 <dsal> megaparsec will be similar.  If you just start throwing stuff at it, your first pass will be kind of gross.  As you progress, you have less and less code to do more things.
10:10:26 * ezzieyguywuf nods
10:10:41 <dsal> e.g., I'd often start with a big monadic thing extracting bits of junk.  Much of that ends up as a liftA3 or something by the time I'm done.
10:10:46 <ezzieyguywuf> perhaps I should stop overthinking it and just "throw something together" using megaparsec like I did the first time *without* megaparsec
10:10:49 <ezzieyguywuf> and just go froum there
10:10:56 <dsal> Yeah, throw something together and then RFC
10:11:24 <ezzieyguywuf> RFC?
10:11:26 <dsal> There are still a couple of edge cases I don't feel like I do very well.
10:11:29 <ezzieyguywuf> ReFaCtor?
10:11:30 <dsal> Request For Comments
10:11:43 <ezzieyguywuf> lol, who do I request comments from? y'all?
10:11:54 <dsal> Apparently.  :p
10:12:28 <dsal> Some part won't feel right.  You'll ask for a better way to do it.  People will be super excited to tell you.  They'll also point out twelve other things you could make better.
10:12:41 <ezzieyguywuf> lol, yea you're right
10:12:50 <ezzieyguywuf> dsal: thanks for putting things back into perspective this was helpful
10:13:25 <dsal> The parser stuff was scary to me at first.  Now the only scary part is that I make more languages than anyone really should.
10:13:48 <ezzieyguywuf> hah
10:14:06 <ezzieyguywuf> I always thought it was weird that all the CS folks at school were talking about compilers and writing compilers etc.
10:14:19 <ezzieyguywuf> but I guess they do it in order to expose you to this kind of thing, that can ultimately be helpful
10:17:01 <dsal> I didn't have that kind of background.  It was always something super fancy and magical that only wizards could do.  Like much of haskell.
10:17:42 <ezzieyguywuf> hah yea me too
10:18:07 <ezzieyguywuf> like 3d graphics. but I sat down and worked through learnopengl.org one day, and now I'm like "Wow I'm so proud of myself I can make triangles!"
10:28:23 <dsal> I was doing similar things with OpenSCAD.  It quickly becomes the easiest way to throw some things together.
10:29:50 <quarters> hello. I'm trying to import hedis per the blog entry http://www.wjwh.eu/posts/2019-11-01-haskell-shorturls.html but wasn't sure how to do this after checking out hedis's github and https://hackage.haskell.org/package/hedis
10:30:25 <dsal> quarters: how are you building your project?
10:30:34 <quarters> dsal: I'm using stack
10:30:50 <dsal> And you added 'hedis' to your package.yaml ?
10:34:40 <ezzieyguywuf> dsal: openSCAD is nice.
10:35:22 <quarters> the project generated from "stack new shorturls scotty-hspec-wai" didn't include a package.yaml, and manually adding one after scaffolding it didn't change anything, so I changed the cabal file. I'm importing Hedis with "import Hedis"
10:35:57 <dsal> quarters: the link you provided says the package is called Database.Redis
10:35:59 <fog> Hi, I am reading this; https://link.springer.com/content/pdf/10.1007%2F978-3-642-19718-5_5.pdf
10:36:03 <dsal> (er, the module)
10:36:13 <fog> Measure Transformer Semantics for Bayesian Machine Learning
10:36:25 <fog> and was wondering if there was something like this in haskell?
10:36:54 <quarters> dsal: oooh, I see a link to the file for this. thanks. I was just going off of the instructions alone
10:37:03 <fog> I found this; https://uu.diva-portal.org/smash/get/diva2:1265819/FULLTEXT01.pdf
10:37:16 <fog> Interacting Particle Inference for Probabilistic Programming in Haskell
10:37:33 <fog> and this; http://www.cs.nott.ac.uk/~psznhn/Talks/SCB-2017-03-31.pdf
10:37:35 <dsal> quarters: This is why I don't like documentation.  Every time someone finishes writing something, everything changes and now you're more confused than if you'd just read the source.
10:37:48 <fog> Ebba: An Embedded DSL for Bayesian Inference
10:37:55 <fog> (written in haskell)
10:38:49 <dsal> Though haddock at least has the property of not totally lying since the types do a lot of the work.
10:38:53 <fog> this first of those says; Monte Carlo sampler is implemented in Haskell and the domain-specific language Monad-Bayes
10:39:16 <fog> which i find here; https://hackage.haskell.org/package/monad-bayes
10:40:22 <fog> from what i can tell, the idea is that the `do' notation should allow for "sampling from a distribution" to be written using the <- binding arrow 
10:41:04 <fog> and that this is "probabilistic computing" which seems to be something to do with distributions modelling non-determinism
10:41:17 <fog> (i guess theres a random number generator in there somewhere)
10:47:15 <fog> i cant find any "probability distribution monad" though
10:49:00 <fog> i made this as an example before; https://pastebin.com/raw/w96DfBzZ
10:49:13 <fog> when i was arguing with someone about if you needed to normalise or not
10:50:03 <fog> and about if integrating the distribution was required to sample from it (which this demo is supposed to answer as "yes", at least using this implementation)
10:50:36 <fog> does that look like it could be a candidate for a "distribution monad"? 
10:51:00 <fog> or am i being really dense to not be able to find a better approach / existing library..
10:52:35 <gentauro> I finally managed to make public my `pcx-utils` project where I update old schoold PC Fútbol/PC Calcio/Premier Manager/PC Apertura games with EA Sports FUT/FIFA data :D https://gitlab.com/spisemisu/pcx-utils
10:53:10 * gentauro it's a bit sad that EA Sports doesn't mantain the DB anymore :(
10:53:11 <fog> actually, whats the idea behind a distribution monad?
10:53:27 <fog> wouldnt it just be the IO monad for the random number generator?
10:53:51 <fog> i guess thats not reproducible though...
10:54:04 <fog> can you "set up" a monad that has a certain rng seed?
10:54:16 <fog> and then work within that as if it were IO
10:54:37 <fog> maybe thats just State over the current StdGen
10:55:15 <fog> i kind of get confused about trying to "read from streams of variables"
10:55:32 <fog> :t randomRIO
10:55:34 <lambdabot> Random a => (a, a) -> IO a
10:56:08 <fog> its kind of as if there were an infinite stream of random numers and you kind of just reading the next one from the head
10:56:46 <fog> i guess i would want all that to happen under the hood, so i could just draw from the distribution using <-
10:57:23 <fog> and somewhere behind the scenes the "next" random number would be made available as the next head, of tail of that stream
10:58:03 <fog> and i cant understand if its like a monadicList, or a state variable that is unfolding that list, for use with the StateT monad Transformer...
10:59:11 <ezzieyguywuf> monochrom: those notes are very helpful, thanks again for providing them.
10:59:17 <monochrom> :)
10:59:36 <ezzieyguywuf> [;
11:00:10 <frdg> How do people typically go about turning a web page of json data like this: https://api.weather.gov/points/38.8894,-77.0352 ,  into something that can be parsed? 
11:00:48 <monochrom> I would use aeson to parse JSON
11:00:53 <fog> frdg: i think you would make a datatype to hold the data, and write some toJson, fromJson things
11:01:36 <frdg> and aeson takes a web link? And if so does it turn it into a file?
11:01:49 <fog> if you make the constructors right, you might even be able to just use the deriving using Generic 
11:02:09 <monochrom> Ah, no, I would need something else to speak http.
11:02:19 <monochrom> aeson takes bytestring input
11:02:25 <fog> frdg: oh if you need to download things from urls you could try httpSimple from conduit
11:02:51 <monochrom> For simplicity I sometimes just go system("curl", ...)
11:02:56 <frdg> ok thanks ill look at that now
11:03:16 <monochrom> especially if https is involved
11:03:18 <fog> monochrom: yeah, thats actually a more stable option
11:04:03 <monochrom> Consider the fact that cabal-install and ghcup simply go system("curl", ...).  (An option allows you to s/curl/wget/ )
11:04:33 <fog> um, so for this distributions monad thing, if i have this "behind the scenes" list of random numbers, being stored as a lazy (monadic?) list being unfolded from a random number generator for a given seed 
11:05:00 <fog> do i save the current state, or the whole list, as something embeded into the State monad?
11:05:03 <monochrom> If you dig into it, even libcurl is not worth bothering, the API is a chore for little gain.
11:05:21 <fog> (which i think is what im supposed to use to embed data into a "surrounding environment")
11:05:25 <fog> (in a monad)
11:06:26 <fog> if its the state, then when i sample from the distribution, the state moves onto its next value, from the state update function 
11:06:41 <frdg> I am designing a web app though that will be frequently making requests that result in links like the one above and I will need to parse these files over and over. Is System (curl) still a good option in this case?
11:07:01 <fog> if its a list, then it kind of has a trivial kind of state update function, which is just (x:xs) -> (x,xs)
11:07:41 <monochrom> If you worry about performance and "I want to, at the http level, open connection just once and reuse it", then no.
11:07:42 <fog> frdg: no, but you said you wanted to download the file
11:07:56 <fog> if you want to stream it strait into ram then you are better off with the http appraoch
11:08:13 <monochrom> But there are a lot of http libraries, all pretty easy to use if you don't need https
11:08:39 <frdg> ok Ill look into all the options mentioned thanks
11:08:44 <monochrom> https is not too difficult if you don't care about checking certificates, I guess.
11:08:54 <fog> well, yu should use https for sure if your transfering user data like passwords and stuff
11:09:02 <monochrom> but if you want to do https properly, it's its own yak shaving
11:09:40 <fog> yesod and conduit do tht well
11:09:51 <fog> i think thats what httpSimple is built on
11:10:22 <monochrom> proper https certificate checking is why cabal-install sub-contract it to curl, I believe.
11:10:33 <fog> https://hackage.haskell.org/package/http-conduit-2.3.7.3/docs/Network-HTTP-Simple.html
11:10:39 <fog> http-conduit-2.3.7.3: HTTP client package with conduit interface and HTTPS support.
11:11:29 <frdg> fog: thanks for that.
11:11:59 <fog> monochrom: yeah but there is some latency issue if you want to use it for web dev proper
11:12:32 <fog> as a package manager cabal has a much more restricted demand on functionality, which curl is perfect for
11:13:11 <monochrom> I think someone did some empirical investigation and found that reusing a connection doesn't really save that much time.
11:13:54 <fog> no i mean vs, writing to disk using curl, and then parsing that file. 
11:14:10 <monochrom> Ever heard of stdout redirection
11:14:33 <fog> especially if you dont need to store it, and its just going to be discarded from ram the next time the data is accessed
11:15:25 <fog> monochrom: ok fair enough, maybe curls not actually so bad for that either then
11:16:07 <fog> i guess it can even do Post headers and stuff, but at that point i think the conduit interface is better, with its Manager settings and stuff
11:17:03 <fog> ...
11:17:05 <quarters> I'm trying to follow the docs for Scotty and was wondering how I can read from a querystring like curl localhost:8080/hello?name=foo . using the code "get "/hello" $ do \ name <- param "name" \ text name gives me an error "no matches found: localhost:8080/hello?name=you"
11:18:03 <dsal> quarters: Do you have a full code listing?
11:19:34 <fog> suppose i just wanted to store the seed in the monadic environment, how would i do that?
11:20:07 <fog> does it need to have a transformer stack to allow it to be extendable? if so, what does that allow it to do?
11:20:45 <monochrom> http://hackage.haskell.org/package/MonadRandom
11:21:30 <nlhowell> Doesn't base have something like maybeAll :: [Maybe a] -> Maybe [a], maybeAll x = if any isNothing x then Nothing else map fromJust x ?
11:21:58 <monochrom> that's sequenceA
11:22:25 <ja> hehehe i love it when something is traverse and sequenceA!!! i don't know why i think it's so funny
11:22:32 <quarters> dsal: dsal: yes. http://dpaste.com/1B6NTVF
11:23:41 <fog> hmm, i think it should also be able to support different ways of representing the distribution
11:24:06 <fog> i dont the "histogram" representation i was using is particularly good for high dimensions
11:24:07 <fog> https://pastebin.com/raw/w96DfBzZ
11:28:18 <nlhowell> monochrom: thanks very much :)
11:29:43 <fog> monochrom: monad random looks pretty much perfect!
11:29:59 <fog> do you know if there is a way to return the last seed after the list is used?
11:30:04 <fog> :t mapAccumL
11:30:06 <lambdabot> Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)
11:30:42 <fog> like, in that type `t c' would be a list of random numbers, and `a' would be the argument needed to continue streaming from that RNG
11:31:08 <fog> for input as the basecase as the second argument, next time it was called upon
11:31:39 <EvanR> monad random can do that
11:31:41 <monochrom> I'll let you find it in the doc.
11:31:43 <fog> (thinking of this as the input and final "state")
11:31:52 <fog> monochrom:ok
11:32:15 <fog> EvanR: thanks
11:33:17 <fog> i guess now, what i need is to have however the PDF is represented, as eg, histograms, or mean and varience of gausians
11:33:32 <fog> as a monad transformer so it can be put into the stack
11:33:57 <fog> idk about monad transformers... does that sound like a good idea?
11:34:18 <EvanR> random monad isn't necessarily a transformer
11:34:35 <fog> hmm
11:34:41 <fog> i just thought it seemed like State
11:34:45 <EvanR> you only use transformers to upgrade existing monads
11:34:56 <EvanR> State is just State, not a transformer
11:35:04 <EvanR> (don't look at the implementation though)
11:35:04 <fog> er, StateT sorry
11:35:44 <fog> well, yeah, i guess i dont need to embed the stored value in the monadic environment
11:36:01 <fog> i guess its because in production code i might want to be using the IO monad
11:36:11 <EvanR> whether transformers are a good idea or scary and to be avoided is irrelevant to using a basic random monad
11:36:13 <fog> like, randomIO instead of the version with the deterministic seed
11:36:43 <fog> i mean, i think to have my "testing" envoronment, which could just be pure, since it uses a given seed
11:36:58 <fog> and my "production" version, which works with IO for randomIO
11:37:03 <fog> have the same interface
11:37:09 <EvanR> if you are really worried about the generator state, no it seems like random IO would be awkward
11:37:34 <fog> then i might as well try and handle the storage of the current RNG state as if it were somehow stored in the monadic environment 
11:37:59 <fog> EvanR: in one setting I am, in the other im not, but i need them to have the same interface
11:38:17 <EvanR> then that reduces to caring about the generator and IO would be awkward
11:38:25 <monochrom> IO is an instance of MonadRandom, if you studied the doc instead of using chat to deceive other people to study it for you.
11:38:36 <fog> basically i want my deterministic version to be the same, just with Identity as the monad, and the "live" version paramatrised over by IO
11:39:31 <fog> monochrom: im explaining *why* i think im in a monad transformer to begin with
11:39:44 <EvanR> if you just want to set the generator for a test... you can do that in IO
11:40:11 <monochrom> See this is why no one engages with you, and it is not their fault.
11:40:14 <fog> since i thought that the distribution would then be incorperated as part of the sonad transformer stack - which wouldnt be the case if i just used pure 
11:40:24 <monochrom> You ask a million different questions in one go.
11:40:34 <monochrom> OK, so I answer question #54.
11:40:53 <EvanR> but now i'm questioning whether it's better to test with random generator as opposed to the same one every time
11:41:02 <unclechu> hey, i'm trying to use `PatternSynonyms` extension, but i get `parse error on input '+'` for `pattern (+) a b = (:<|>) a b`
11:41:03 <monochrom> Then you speak like "no, look at my question #5948", and behave like you never asked question #54.
11:41:06 <fog> yes, thanks for reminding me why i was explaining my thinking
11:41:07 <unclechu> am i doing something wrong?
11:41:25 <unclechu> i have `{-# LANGUAGE PatternSynonyms #-}` in the module
11:42:00 <dolio> unclechu: I think pattern synonyms have to follow the constructor naming rules.
11:42:07 <dolio> (+) isn't the name of a constructor.
11:42:25 <fog> EvanR: the motivation for using a rng, is that distributions are to be updated by monte carlo, which is basically adding white noise, and rejecting when thats worse. the rng is for making gausian noise to "noise up the distribution" before discarding it it that makes it worse
11:42:43 <unclechu> dolio: but it could be, right?
11:42:48 <monochrom> Yeah you can't use (+) for the name.
11:43:03 <unclechu> monochrom: why not?
11:43:18 <unclechu> monochrom: what i can use as an operator?
11:43:22 <dolio> What do you mean? It's not the name of a constructor in Haskell. It could be in a language that isn't Haskell.
11:43:31 <monochrom> It's how the parser knows "this is a pattern name" vs "this is a function name"
11:44:21 <monochrom> start with colon, e.g., :+
11:45:02 <monochrom> Maybe I should teach this to my students too. Constructor names can be infix operators if you start with colon.
11:45:25 <unclechu> so, a constructor must have colon in its name, got it
11:45:32 <unclechu> thanks
11:45:42 <dolio> It has to start with a colon.
11:45:46 <fog> only if its a symbol
11:45:57 <dolio> Like a prefix must start with a capital letter.
11:45:57 <unclechu> well, yes
11:46:19 <fog> the only capital letter!
11:47:39 <fog> argh, well, anyway, i explained all my justifications to support the question "does a probability distribution seem like a good layer for a monad transformer stack" 
11:47:57 <fog> and im no closer to understanding why it would or wouldnt be
11:48:42 <fog> basically the upshot of it was, that i think im in a monad transformer stack to begin with, because my rng is sometimes in IO
11:48:42 <quarters> I just found the issue to be resolved by using "curl ':8080/foo?a=queryString'" instead of "curl localhost:8080/foo?a=queryString'". Is this issue unique to Scotty or does servant only accept queryString in that curl format as well?
11:49:03 <fog> look a monad! how do i extend on that? it could be a monad transformer stack, but i dont really understand those
11:49:30 <fog> maybe ill ask because i doubt if thats good logic
11:50:33 <fog> monochrom says "your questions suck, think with your brain, not mine"
11:51:14 <fog> "ill put you in a monad transformer stack..."
11:51:39 <frdg> https://dpaste.org/1N2k I am having trouble telling if this code worked or not. On one hand I got thrown an exception but on the other hand it seems that all the json was parsed.
11:51:45 <sm[m]> fog :) are you coding, chatting, and reading ? Sometimes we neglect one or the other
11:52:19 <fog> argh! the rest of my life! why would you remind me...
11:52:36 <fog> damn these monads. i shall return 
11:53:18 <sm[m]> and btw reading should include both official docs and real world code (not just blog posts from random eras)
11:53:43 <sm[m]> Also some of this stuff just takes time to grok. Good luck!
11:54:11 <Cale> I finally actually had something relevant to say to fog, but they just left :)
11:54:56 <sm[m]> doh :) they’ll be back
11:55:16 <Cale> Just that WriterT (Product Rational) over some monad which supports nondeterminism can be a useful way of encoding probability distributions / measures.
11:56:16 <Cale> It's not especially useful if your goal is to generate random values though, but it's possible through switching monads to either compute information about the distribution or sample from it.
11:56:16 <dsal> quarters: Sorry, lunched.  Do you have another web server running on 8080?
11:56:31 <maralorn> Hm, blaming monads for your troubles feels like blaming spherical objects for everything bad. I guess most issues have something to do with spherical objects, e.g. earth. But that doesn't mean that this is a reasonable category to think in... 
11:57:23 <quarters> dsal: I don't
11:58:00 <quarters> on another note, I was wondering if there's a way to "flatten" a do block, so I can submit a single line of code here for review
11:58:10 <quarters> instead of using paste site
11:58:12 <Cale> ;
11:58:35 <Cale> You can insert ;'s between the statements of the do-block
11:58:58 <sm[m]> or write with >>/>>=
11:58:59 <dsal> @undo do { a; b' <- b; c b a }
11:58:59 <lambdabot> a >> b >>= \ b' -> c b a
11:59:12 <Cale> If there's a contained "let", you may also need to add curly braces
11:59:13 <sm[m]> Nice
11:59:19 <maralorn> Although to be fair I can see how one would do that with monads. Seeing that the fact that monads are everywhere is far more overemphasized than the fact that spherical objects are everywhere... 
12:01:02 <quarters> Cale: thank you
12:04:49 <monochrom> That's only because you been seeing spheres for 50 years and monads only 5 days.
12:05:42 <monochrom> Remember how you were excited with spheres when you were 5 months old or something, during your first 5 days of recognizing spheres for the first time.
12:07:20 <dmj`> monads are spherical?
12:07:41 <maerwald> monads are wormholes
12:07:54 <dmj`> monads are UFOs
12:07:55 <monochrom> monad's sphere of influence
12:08:15 <maerwald> dmj`: stop watching those yt channels
12:10:05 <maerwald> monads were invented by flat earth theorists to infiltrate modern maths
12:12:01 <frdg> https://dpaste.org/qgPf I am very confused about if this code is correct or not. I am thrown an exception yet everything else tells me that things went smoothly, especially the fact that the http status code is 200.
12:13:37 <monochrom> No, rather, flat earth theorists invented the name "flatmap" for monad join to promote flat earth theory. >:)
12:13:45 <monochrom> "See, it's a flat map"
12:13:52 <maerwald> lel
12:16:39 <maerwald> frdg: maybe problems with query string encoding
12:18:04 <maerwald> oh no, you actually get the right data
12:18:09 <dmj`> frdg: you need to scroll left, "expected String, but encountered Object"
12:18:20 <dmj`> right*
12:18:29 <dmj`> frdg: check your FromJSON instance
12:19:05 <maerwald> It's String
12:20:23 <frdg> yep I changed the type of main to `IO (Response Object)` and it worked.
12:20:46 <frdg> Why is this? I do not understand what the problem was.
12:20:55 <dmj`> frdg: what was it before?
12:21:07 <dmj`> frdg: IO (Response String) ?
12:21:11 <frdg> `IO (Response String)`
12:21:34 <dmj`> ah, it's using `FromJSON String` to convert `Value -> Result String` and that's failing 
12:22:12 <maerwald> Just use `Value` and it will convert anything
12:22:14 <dmj`> frdg: aeson converts the bytes from the body into `Value` for you, the Parser from `Value -> a` is what you need to write.
12:22:21 <maerwald> then toString
12:22:31 <frdg> ok I see 
12:22:45 <dmj`> maerwald: that will show the String representation of the Haskell object
12:22:52 <maerwald> yes
12:23:15 <dmj`> doesn't sound too useful
12:23:38 <monochrom> Oh wait, flatmap is >>=, not join. But hey, even better.
12:23:59 <monochrom> Therefore, UFO = unit-flatmap object = monad, yes!
12:27:48 <frdg> is using `parseRequest_ :: String -> Request` a bad idea?
12:29:13 <maerwald> impure exception means that it happens on evaluation, afail
12:29:19 <maerwald> *afaik
12:29:36 <monochrom> ah, that's bad usually, yes.
12:30:12 <maerwald> as the documentation says, it's ok for static strings
12:30:34 <maerwald> but MonadThrow can be coneniently used in IO etc
12:30:48 <monochrom> I wanted to ask "in what context? for what purpose?", but I retracted because I would not follow up anyway.
12:32:02 <frdg> ok I'll read through the docs cause I am sure there is another way
12:33:32 <maerwald> for what
12:34:12 <maerwald> I'm surprised there is no quasi-quoter for it
12:34:49 <monochrom> perhaps people who love quasi-quoters have already joined yesod
12:35:04 <maerwald> I like them, but not yesod
12:35:13 <maerwald> but they break all your tools
12:35:19 <maerwald> formatters, ctags, ...
12:35:38 <frdg> I produce my api requests which are links to the internet as strings based off database info. I need to turn these links (which are strings) into requests
12:36:00 <maerwald> what's wrong with parseRequest?
12:36:06 <dmj`> this whole time we thought monads were burritos, they were simply UFOs
12:36:16 <monochrom> I have a feeling that parseRequest is unrelated to this.
12:36:48 <frdg> well parseRequest is String -> Request which is perfect
12:36:58 <monochrom> "parse request" sounds more like what a web server does when it receives your request.
12:37:25 <maerwald> I'm not gonna mock the API (hah), but...
12:37:38 <maerwald> naming is hard
12:38:07 <monochrom> and the "string" is of the "GET /index.html HTTP/1.1\nHost: xxx.com\n\n" form
12:38:23 <monochrom> i.e., what a web server receives
12:39:15 <maerwald> dmj`: first one is still in Area 51
12:39:43 <maerwald> upcoming blockbuster: Free the monad
12:39:55 <frdg> ohh I see whats going on now
12:39:58 <maerwald> so that's where all the effects systems come from
12:40:18 <frdg> ok this isnt complicated
12:40:18 <maerwald> activists trying to rescue aliens
12:40:51 <dmj`> Oleg Kiselyov's job was to reverse engineer monads in Area 51
12:40:56 <maerwald> lol
12:41:13 <maerwald> reading his papers he sure sounds mysterious, in a way
12:41:31 <maerwald> he got access to the firs monad
12:41:34 <maerwald> makes sense
12:42:04 <maerwald> but can we trust them?
12:42:16 <monochrom> why not?
12:42:50 <maerwald> they could try to manipulate our understanding of programming, so we don't see that programming is in fact a flat domain
12:43:39 <monochrom> which side is your "they"?  activists?  cover-up people?
12:43:59 <monochrom> aliens?
12:44:23 <maerwald> like... others tried to convince me that programming is objects... my first object I created was an Ice cream object with toppings (also objects). I felt abused
12:44:57 <maerwald> monochrom: the monad people
12:45:33 <maerwald> trying to convince us FP is about monads
12:46:16 <monochrom> https://link.springer.com/book/10.1007/978-1-4419-8598-9
12:46:32 <monochrom> I think that the book's cover picture is very telling.
12:46:46 <dmj`> what planet did monad come from though
12:47:27 <dmj`> zeta reticalculi
12:47:41 <monochrom> amazon probably has a bigger picture for that.
12:47:59 <maerwald> dmj`: none, the first scientist found one in a lab on Babylon 5
12:48:33 <maerwald> And was seized by the thought police
12:49:00 <monochrom> Oh! thoughtpolice was one of us!
12:49:09 <maerwald> back then it was a crime to think functionally
12:49:59 <dmj`> Anyone caught thinking functionally would be branded a terrorist
12:51:51 <maerwald> they would meet at night and give each other lambdas
13:00:45 <revenemene> guys I found my grandpas haskell badge in a box in the attic
13:22:25 * hackage slack-progressbar 0.1.0.1 -   https://hackage.haskell.org/package/slack-progressbar-0.1.0.1 (thomasjm)
13:43:17 <maxfm> how difficult is learning Agda, and will knowing Agda be beneficial when I am taking future math courses at Uni? I have a working knowledge of haskell.
13:44:37 <maxfm> I am going to be majoring in math I should mention
13:45:50 <dolio> I don't think it's that difficult, but I think it's unlikely to be very useful.
13:47:09 <maxfm> is there any computer languages that would be useful? What drew me to Agda was the proofs.
13:47:40 <maxfm> *That would be especially useful
13:47:44 <ja> maxfm: it seems like professtional mathematicians are working more with Lean these days?
13:47:50 <ja> maxfm: did you see the Xena Project?
13:47:50 <dolio> No, I just think the current state of computer formalization is unlikely to be helpful for a university course.
13:48:31 <maxfm> ja: I have not heard of lean or the Xena project. I will look at those now.
13:49:19 <dolio> Maybe you could do some simple algebra arguments in it.
13:50:12 <ja> maxfm: kevin buzzard of the xena project is on twitch too, if you're into that sort of stuff: https://www.twitch.tv/kbuzzard
13:50:28 <maxfm> What is Agda very useful for?
13:50:51 <ja> maxfm: i think it is nice for people who think tactics are too much magic?
13:53:02 <gaussian> agda works well for formalizing semantics of programming languages
13:53:09 <ja> maxfm: not everybody needs dependent types. for example, I believe they are not used in Isabelle/HOL. maybe it would give some intuition to look at what people prove with dependent types, and what they prove without?
13:54:32 <dolio> It's okay for formalizing mathematics. I'm just saying that if you think formalizing all your homework will make it easier or something, you're probably wrong.
13:55:02 <maxfm> dolio: ya that is what I was thinking
13:57:25 <dolio> The advantage would be that the computer can tell you when you've successfully answered the question, but it might be considerably more work.
13:57:29 <ja> maxfm: my buddy just did his thesis on formalizing some logic, look how many errors he found in the original proofs (page 67): https://backend.orbit.dtu.dk/ws/portalfiles/portal/163079794/phd493_Schlichtkrull_A.pdf that should provide some motivation for computer formalization!
13:59:14 <maxfm> ja: wow he found a lot
14:05:39 <koz_> Can someone tell me what QSem here is actually useful for? https://hackage.haskell.org/package/base-4.14.0.0/docs/Control-Concurrent-QSem.html
14:05:55 <koz_> It talks about acquiring and releasing resources, but it just looks like a lock.
14:05:58 <koz_> Am I missing something here?
14:09:11 <hpc> imagine you're writing the first perl6 interpreter or something along those lines
14:09:23 <hpc> and you need to count references to data in a thread-safe way for garbage collection
14:12:02 <hpc> oh wait, this counts down, bad example
14:12:25 <hpc> maybe you're writing a server, and to prevent DDoS you have a finite limit on the number of simultaneous connections
14:12:27 <ja> are you saying this was invented for Pugs?
14:12:38 <hpc> no, just using it as an example
14:12:59 <koz_> hpc: OK, let's go with the server example.
14:13:06 <koz_> Suppose I have a limit set at 10.
14:13:09 <hpc> anyhoo, so you start the semaphore with the number of connections you want available
14:13:26 <hpc> when a connection opens, your code waits
14:13:29 <hpc> now the semaphore is at 9
14:13:29 <koz_> How do I 'start' a QSem with any number of anything?
14:13:37 <hpc> that happens a few more times, now the semaphore is at 0
14:13:38 <koz_> It doesn't have any numbers, or data stored, or anything.
14:13:54 <hpc> the next connection has to wait for something to signal, which bumps it back to 1
14:14:06 <hpc> you'd do newQSem 10
14:14:31 <koz_> Ah, OK.
14:14:56 <koz_> So basically, if exhausted, waitQSem blocks?
14:15:01 <hpc> yeah
14:15:04 <koz_> Until someone signals it?
14:15:05 <hpc> like MVar and such
14:15:30 <koz_> OK, that makes more sense. Thanks.
14:37:29 <quarters> hello. I am trying this on Scotty, but am getting an error for putStrLn and was wondering why that would happen: "  S.get "/hello" $ do {putStrLn "hi"; name <- S.param "name"; S.text name}"
14:38:33 <c_wraith> usually the error tells you something
14:39:05 <c_wraith> in this case, it's probably telling you something can't be matched with IO ()
14:40:41 <quarters> c_wraith: ah yes. I'm seeing that
14:41:06 <c_wraith> not all do blocks are IO
14:41:27 <c_wraith> In this case, the do block is probably something like ScottyM somethingorother
14:41:43 <quarters> it is: Expected type: Web.Scotty.Internal.Types.ActionT TL.Text IO ()
14:41:50 <c_wraith> Fortunately, you can run IO actions from there - you just need to tell the compiler what's going on
14:41:58 <c_wraith> :t liftIO
14:41:59 <lambdabot> MonadIO m => IO a -> m a
14:42:21 <c_wraith> You can use that to convert an IO action to...  that giant blob.  :)
14:46:16 <quarters> c_wraith: I reckon that it's not feasible to run putStrLn at all in the do block?
14:46:52 <c_wraith> it's not possible to run it directly. but IO values are just *values*. that's sort of the point of them.
14:47:11 <c_wraith> you can manipulate them, including with functions like liftIO
14:47:34 <c_wraith> try using   liftIO (putStrLn "hi")
14:48:11 <quarters> that did it! ty
14:52:51 <TheCommieDuck> hey. is there a nice way to do "when (isJust x && isJust y && isJust z ...) doStuff" when all of x,y,z may be different Maybe types?
14:54:26 <dolio> Do you care what the values are?
14:54:32 <TheCommieDuck> No.
14:54:40 <sm[m]> when (all isJust [x,y,z..]) $ ...
14:54:43 <c_wraith> that's sort of a weird one because isJust is usually a sign that something has already gone wrong.
14:55:09 <monochrom> I think the "nice" sought is along the line of "map isJust [x,y,z]" except heterogeneous list.
14:55:12 <TheCommieDuck> oh, I figured that wouldn't work because [x,y,z..] is a heterogenous list.
14:55:36 <sm[m]> oops no
14:56:04 <TheCommieDuck> I could be just bandaiding over something where I want a maybeT monad - "when these values are all Just whatever, then do things with them in state and return true, else return false"
14:56:26 <sm[m]> does isJust (x >> y >> zz >> ...) work ?
14:56:50 <TheCommieDuck> seems to, thanks :)
14:57:07 <dolio> You can `traverse_` instead of `when (isJust ...)`, too.
14:57:28 <monochrom> except traverse_ wants the list [x,y,z] again.
14:57:45 <dolio> No, you traverse the Maybe.
14:57:52 <monochrom> Oh, that.
14:58:23 <dolio> for_ (x >> y >> z >> ...) (\_ -> doStuff)
14:58:41 <infinisil> I'd prefer `when isJust` for the clarity
14:58:42 <xsperry> TheCommieDuck, how will you get the values once you know they are all Just?
14:58:58 <TheCommieDuck> yeah, I hadn't worked out that roadbump.
14:59:09 <infinisil> Also, the trick with >> is also really obscure
14:59:14 <dolio> Oh, so you do care about the values inside.
14:59:27 <c_wraith> infinisil: I disagree with both of those assertions.
14:59:43 <xsperry> then perhaps: case [mx,my,mz] of [Just x, Just y, Just z] -> ... _ -> ...
15:00:01 <dolio> They can't be put in a list.
15:00:14 <xsperry> they are of different type? a tuple then
15:01:04 <dolio> If the values inside matter, then `traverse_` is even more clearly the right answer.
15:01:16 <c_wraith> I mean...   nothing from with "fromMaybe oopsVal $ do ... " either 
15:01:20 <infinisil> c_wraith: I feel like Haskellers have the tendency to prefer code that's only a bit shorter but much less obvious
15:01:22 <TheCommieDuck> case (x, y, z) of (Just x2, Just y2, Just z2) -> doStuff _ -> return does work, it seems
15:01:37 <c_wraith> infinisil: I think it's a lot more obvious....
15:02:42 <c_wraith> it reduces a bunch of special cases to the general purpose machinery 
15:03:07 <infinisil> c_wraith: You find `traverse_` on a Maybe more obvious than `when isJust`?
15:03:12 <c_wraith> much
15:03:35 <infinisil> And you find `isJust (x >> y >> z)` more obvious than `isJust x && isJust y && isJust z`?
15:03:50 <c_wraith> if I see "isJust", I'm immediately looking for what went wrong, because obviously something has.
15:03:55 <TheCommieDuck> though if it was possible to generalise it so I could have f :: (Maybe a) -> (Maybe b) -> (Maybe c) -> (a, b, c -> ... it'd be nice but I guess just writing out a couple of short case wrappers works
15:04:16 <c_wraith> if I see traverse_, I know what's going on 
15:04:33 <c_wraith> TheCommieDuck: do you just want liftA3 ?
15:05:02 <dolio> for_ (liftA3 (,,) x y z) (\(a,b,c) -> doStuff)
15:05:05 <infinisil> c_wraith: I agreed with there probably something being wrong or could be modeled better
15:05:07 <TheCommieDuck> ...possibly?
15:05:43 <c_wraith> liftA3 doStuff x y z
15:05:46 <sm[m]> TheCommieDuck: you're going to end up where you started as the most readable :)
15:06:03 <sm[m]> I guess it all hinges on the definition of "nic"
15:06:07 <sm[m]> "nice"
15:06:33 <TheCommieDuck> if that liftA3 works as I'm intending with the case statement, then I can just wrap it up with a more informative name than lift and it suits me just fine :P
15:06:51 <TheCommieDuck> and I'm fairly sure it does, so thank you
15:06:54 <c_wraith> and remember you have eliminators like maybe and fromMaybe to handle the errors cases.
15:08:25 <younder> These categories have really perverted the language to something I pretty much find unreadable.
15:09:19 <xsperry> TheCommieDuck, what do you do if one of the values is Nothing?
15:09:39 <TheCommieDuck> do nothing and (in my state monad) return False
15:11:06 <xsperry> then case may be the cleanest
15:11:09 <xsperry> case (mx, my, mz) of (x,y,z) -> ...; _ -> return False
15:11:29 <xsperry> with liftA3 you need separate check
15:11:36 <TheCommieDuck> ahhh, true
15:12:50 <dolio> What categories?
15:16:43 <quarters> I installed stack through homebrew for macos and was wondering if I should remove that and instead install ghcup per https://www.haskell.org/platform/
15:16:58 <maerwald> quarters: what's your goal
15:17:10 <quarters> maerwald: I'd like to also have a repl, which I realized I don't have
15:17:28 <quarters> I'm not sure if I should add that separately through homebrew as well
15:17:35 <maerwald> do you want stack features?
15:18:04 <maerwald> For ghcup, follow https://www.haskell.org/ghcup/
15:18:15 <quarters> maerwald: yes, I believe so. I initially installed stack to follow this tutorial: http://www.wjwh.eu/posts/2019-11-01-haskell-shorturls.html
15:19:06 <maerwald> usually you don't "need" stack, unless a large project depends on it
15:19:23 <maerwald> proper libraries do not
15:19:30 <maerwald> so it's more of a user choice
15:20:18 <quarters> it sounds like installing ghcup is established as common practice regardless of whether stack is installed or not?
15:20:42 <maerwald> quarters: if you *only* use stack, you might not need ghcup
15:20:51 <monochrom> There are two established common practice. ghcup and stack.
15:20:53 <maerwald> stack has its own way of installint ghc
15:21:15 <quarters> ah, I see
15:21:41 <maerwald> quarters: but both methods do not conflict. stack will not use a system/ghcup ghc unless you tell it to
15:22:15 <maerwald> cabal picks whatever it finds in PATH or what you tell it to use
15:22:41 <quarters> excellent. ty maerwald and monochrom 
16:15:48 * hackage discord-haskell 1.6.1 - Write bots for Discord in Haskell  https://hackage.haskell.org/package/discord-haskell-1.6.1 (Aquarial)
17:02:19 * hackage mod 0.1.2.0 - Fast type-safe modular arithmetic  https://hackage.haskell.org/package/mod-0.1.2.0 (Bodigrim)
17:16:48 <koz_> @pl \s -> foo s >> bar s
17:16:48 <lambdabot> liftM2 (>>) foo bar
17:16:49 * hackage language-dickinson 1.0.0.0 - A language for generative literature  https://hackage.haskell.org/package/language-dickinson-1.0.0.0 (vmchale)
17:18:25 <koz_> @pl \s -> (liftIO . foo $ s) >> (liftIO . bar $ s)
17:18:26 <lambdabot> ap ((>>) . liftIO . foo) (liftIO . bar)
17:21:15 <solonarv> I would write: liftIO . liftA2 (*>) foo bar
17:26:18 <koz_> solonarv: I _just_ realized that I could drag liftIO out of there.
17:50:41 <c_wraith> that's actually one of the few requirements on what liftIO does. :)
17:54:17 <koz_> c_wraith: Something like (liftIO f >> liftIO g) = liftIO (f >> g) or something?
17:55:15 <monochrom> yeah
17:55:24 <c_wraith> I think even (liftIO f >>= \x -> liftIO g) = liftIO (f >>= \x -> g)
17:56:18 <c_wraith> where g may or may not use x :)
17:56:56 <koz_> Close. It's apparently a combo of 'liftIO . pure = pure' and 'liftIO (m >>= f) = liftIO m >>= (liftIO . f)'.
17:58:10 <c_wraith> the latter is the same thing I said. :P
17:59:04 <koz_> Yeah, good point.
18:33:37 <rand809809> Hi, is there a functionality in haskell to query if a function is total similar to idris?
18:33:51 <rand809809> Or even create a hole like "?somHole" and query its type
18:33:58 <rand809809> If not, why isn't this possible in haskell?
18:34:18 <c_wraith> totality is basically impossible to guarantee in Haskell.
18:34:26 <c_wraith> Thanks to the halting problem.
18:35:07 <rand809809> yea, I was wondering how idris gets around that?
18:35:21 <c_wraith> it requires termination proofs.
18:35:42 <rand809809> can I read about this somewhere?
18:36:30 <solonarv> probably, but I wouldn't know where. have you tried asking in idris-related chat rooms?
18:36:39 <c_wraith> http://docs.idris-lang.org/en/latest/tutorial/theorems.html#directives-and-compiler-flags-for-totality
18:37:04 <solonarv> to answer your other question, Haskell does have holes; they look like _someHole
18:37:27 <solonarv> GHC will tell you what type the hole should have and will also suggest a few type-correct ways to fill it
19:04:25 <ezzieyguywuf> what is RealFloat?
19:04:42 <ezzieyguywuf> is it like an unbounded float?
19:07:51 <monochrom> I think it's best to infer from its methods.
19:08:11 <monochrom> yahb: %:info RealFloat
19:08:26 <monochrom> err how do I use that again :)
19:08:48 <monochrom> ah, need one more space
19:08:52 <monochrom> yahb: % :info RealFloat
19:09:07 <monochrom> and probably none of the "yahb:" business
19:09:11 <ezzieyguywuf> lol
19:09:12 <monochrom> % :info RealFloat
19:09:12 <yahb> monochrom: type RealFloat :: * -> Constraint; class (RealFrac a, Floating a) => RealFloat a where; floatRadix :: a -> Integer; floatDigits :: a -> Int; floatRange :: a -> (Int, Int); decodeFloat :: a -> (Integer, Int); encodeFloat :: Integer -> Int -> a; exponent :: a -> Int; significand :: a -> a; scaleFloat :: Int -> a -> a; isNaN :: a -> Bool; isInfinite :: a -> Bool; isDenormalized :: a -> Bool
19:10:01 <monochrom> So it means a number type that really is a finite precision floating point thing underneath.
19:14:05 <ezzieyguywuf> hrm
19:14:09 <ezzieyguywuf> i think I get it
19:15:26 <monochrom> the methods let you pick apart the components of every floating point format: mantissa (significand), exponent, base (radix).
19:16:49 <monochrom> and since some floating point formats (e.g. IEEE 705) also have a notion of NaN and a notion of infinity (just so +1/0 and -1/0 are allowed), there are methods for asking about those too.
19:18:28 <monochrom> Despite the infinities, it is still bounded, since the mantissa and the exponent have only so many bits. There is such a thing as the largest representable number just below infinity.
19:18:44 <monochrom> err, largest finite number
19:19:13 <monochrom> whereas "unbounded" means all large numbers are representable.
19:19:21 <monochrom> (at least to most people)
19:22:39 <ezzieyguywuf> but a Rational may be considered unbounded
19:22:41 <ezzieyguywuf> maybe..
19:45:19 * hackage influxdb 1.9.0 - Haskell client library for InfluxDB  https://hackage.haskell.org/package/influxdb-1.9.0 (MitsutoshiAoe)
23:35:50 * hackage jsaddle 0.9.7.1 - Interface for JavaScript that works with GHCJS and GHC  https://hackage.haskell.org/package/jsaddle-0.9.7.1 (HamishMackenzie)
23:36:50 * hackage jsaddle-clib 0.9.7.1, jsaddle-webkit2gtk 0.9.7.1, jsaddle-wkwebview 0.9.7.1, jsaddle-warp 0.9.7.1 (HamishMackenzie)
