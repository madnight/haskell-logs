00:00:11 <rand809809> Right, and wrapping it in try makes it so that it always fails without consuming input
00:00:50 <ja> that's such a useful enumeration of possibilities
00:01:04 <Cale> It's literally how ParsecT is defined
00:01:10 <Cale> newtype ParsecT e s m a = ParsecT
00:01:10 <Cale>   { unParser
00:01:10 <Cale>       :: forall b. State s e
00:01:10 <Cale>       -> (a -> State s e -> Hints (Token s) -> m b) -- consumed-OK
00:01:10 <Cale>       -> (ParseError s e -> State s e       -> m b) -- consumed-error
00:01:12 <Cale>       -> (a -> State s e -> Hints (Token s) -> m b) -- empty-OK
00:01:14 <Cale>       -> (ParseError s e -> State s e       -> m b) -- empty-error
00:01:16 <Cale>       -> m b }
00:01:47 <ja> i would have glossed over it if you pasted the code first :O i must reconsider my priorities
00:02:58 <rand809809> I had this annoying itch when I was going to proceed by wrapping everything in a `try` without understanding what was going on. Thanks for the help
00:05:29 <hololeap> interesting that megaparsec takes this approach while attoparsec essentially wraps everything in `try`
00:07:19 <dminuoso> Well there are reasons for both. Ideally a parser combinator package would expose both through different modules.
00:08:05 <Cale> attoparsec was originally designed to operate on strict ByteStrings which would be entirely loaded into memory already anyway
00:08:44 <Cale> There's not a whole lot to be gained by the extra bookkeeping if you can't start deallocating the initial part of the input early
00:09:03 <Cale> (perhaps at the same time as generating/loading the input)
00:27:34 <typetetris> What is the reason monad-logger uses `Chan` instead of `TChan` ?
00:30:41 <dminuoso> typetetris: monad-logger strictly speaking doesnt use anything
00:30:45 <dminuoso> It's the point of the package.
00:31:24 <dminuoso> It separates the logging interface from the implementation. It just so happens that it also brings some default implementations for you to use.
00:31:43 <dminuoso> If you want to use it with TChan, implement it yourself! :)
00:33:14 <typetetris> dminuoso: Are there any downsides to just use the `Chan` default implementation over doing a `TChan` implementation myself, despite the extra work?
00:34:35 <dminuoso> runChanLoggingT chan = (`runLoggingT` sink chan) where sink chan' loc src lvl msg = writeChan chan' (loc,src,lvl,msg)
00:35:03 <dminuoso> runTChanLoggingT chan = (`runLoggingT` sink chan) where sink chan' loc src lvl msg = atomically $ writeTChan chan' (loc,src,lvl,msg)
00:36:16 <typetetris> `unChanLoggingT` uses `forever` wasn't there some space leak gotchas with `forever` ? 
01:17:54 <jackdk> Cale: I'm trying to encode the "monoidal functor" idea but I'm getting errors the the type variable `p` is ambiguous. Do you know how to deal with this? https://www.irccloud.com/pastebin/MXRmWNOz/MonoidalFunctor.hs
01:18:09 <jackdk> C is Control.Category.Monoidal from categories package.
01:24:03 <Cale> jackdk: You might want to say something like  unit :: (a ~ C.Id (->) p) => f a
01:24:32 <Cale> see if that resolves it
01:25:17 <Cale> Oh, you might also want a fundep
01:25:34 <Cale> Or maybe not
01:26:13 <jackdk> Cale: if I fundep `f -> p` it becomes unambiguous
01:26:28 <Cale> yeah, the question is just whether that rules out instances you care about
01:31:31 <jackdk> Cale: that's promising, should let me to have an Applicative and Divisible in the same structure, but if I want to use different monoid objects (i.e., Either and (,) in the same structure) I think I get stuck
01:31:43 <jackdk> thanks
01:31:58 <Cale> yeah
01:32:01 <Cale> cool
01:32:46 <jackdk> I think it's less bad than I first feared now that I can lean on Control.Category.Monoidal
01:33:22 <Cale> I think that stuff ought to replace Arrow
01:33:38 <Cale> Might need a few additional things
01:34:06 <Cale> But it's basically the same as the stuff we did back in the day when fixing the performance of our arrowized FRP systems
01:34:42 <Cale> We stole the definition of a symmetric monoidal category, put in all the extra widgets explicitly rather than relying on arr to make them
01:35:10 <Cale> and that removed black boxes from the computation and allowed us to route things directly to where they were going to end up in the computation graph
01:35:22 <jackdk> i'm not across that history, i'm just looking to generalise over Applicative/Allternative/Divisible/Decidable
01:35:28 <Cale> the removal of all that tupling and untupling made our game 6 times faster
01:35:54 <Cale> even before we started doing extra optimisations it exposed
01:36:20 <jackdk> but the class is starting to look solid in that it looks like something categorical
01:37:38 <Cale> yeah, it's a bit funny that now that you don't have fmap you need these extra operations
01:37:41 <Cale> but that's natural
01:38:38 <Cale> a bit hard to express any laws without the functor though
01:39:44 <jackdk> i'm at least demanding Invariant so I can map the (un)tupling through the functor
01:39:49 <Cale> oh, maybe you can with invmap, hmm
01:40:23 <jackdk> now that i fixed the ambiguity i can provide default implementations at least
03:41:42 * hackage ngx-export-tools-extra 0.5.2.0 - More extra tools for Nginx haskell module  https://hackage.haskell.org/package/ngx-export-tools-extra-0.5.2.0 (lyokha)
03:41:46 <Cheery> the build systems a la carte -paper describes "Store", but where does it come from?
03:48:22 <[exa]> Cheery: Control.Comonad.Store?
03:50:17 <Cheery> nope, seems like it's just something of their own.
03:53:02 <[exa]> uh you mean the one "defined" in Fig5?
03:53:08 <Cheery> yup
03:53:52 <[exa]> I guess that can be safely implemented as ⌜(i, Map k v)⌝
03:54:53 <Cheery> if you can convert a function to a map, then yes. Though I doubt so because keys in a map can be enumerated.
03:57:06 <Cheery> I'll try (i, k -> v)
03:59:25 <[exa]> oh noes, then the function will work
04:00:15 <Cheery> that's the implementation all right.
04:34:42 * hackage neat-interpolation 0.5.1.1 - A quasiquoter for neat and simple multiline text interpolation  https://hackage.haskell.org/package/neat-interpolation-0.5.1.1 (NikitaVolkov)
04:45:42 * hackage purebred-email 0.4.2 - types and parser for email messages (including MIME)  https://hackage.haskell.org/package/purebred-email-0.4.2 (frasertweedale)
05:11:42 * hackage hie-bios 0.6.1 - Set up a GHC API session  https://hackage.haskell.org/package/hie-bios-0.6.1 (fendor)
05:37:14 <refried_> Hi everyone
05:37:27 <[exa]> hello!
05:40:14 <refried_> :)   Is there some good package or tool for computing timing data for certain phases of your application, hidden during normal execution, but maybe activated for debugging / profiling, and producing nice output?
05:40:41 <refried_> So far I have some clock subtraction and IO prints that are hidden behind a Bool constant
05:40:47 <merijn> refried_: https://mpickering.github.io/posts/2019-11-07-hs-speedscope.html ? :)
05:41:18 <refried_> Oooh interesting
05:42:46 <merijn> refried_: There's a whole bunch of profiling stuff supported by GHC
05:42:50 <merijn> @where userguide
05:42:50 <lambdabot> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/
05:44:30 <merijn> see also the eventlog stuff, etc.
05:44:36 <frdg> Has Database.Persist changed somewhat recently? Looking through documentation from a few years ago it seems that I should be able to import `Database.Persist.Postgresql` but I am getting unrecognized import errors. I am also not able to import `Database.Persist.Sqlite`. I am however able to import `Database.Persist.Sql`.
05:45:43 <refried_> merijn, yes I've been using GHC profiling, but ... not totally happy with it.  I want some simpler output that maybe even an end-user could enable to produce a timing report
05:46:05 <refried_> also I noticed that a few of the profiling modes crash
05:46:11 <jackdk> frdg: https://hackage.haskell.org/packages/search?terms=persistent maybe it's split into multiple sub-packages? I haven't used the persistent ecosystem at all.
05:46:16 <refried_> i'm on ghc 8.8 so maybe the situation is different in 8.10
05:46:58 <refried_> what do folks do in production to collect diagnostic data?    I haven't really tried custom cost centres yet though
05:47:15 <refried_> so maybe that's the missing ingredient? i'm not sure
05:49:07 <frdg> jackdk: Yes I noticed that as well but looking at `persistent-postgresql` I notice that the package is just `Database.Persist.Postgresql`. 
05:49:07 <frdg>  
05:49:30 <jackdk> frdg: I do not understand what you are saying.
05:50:33 <merijn> frdg: Well yes, that package is just the postgres support for the persistent package
05:50:36 <merijn> You need both
05:50:52 <merijn> refried_: Oh, maybe you want ekg?
05:50:54 <merijn> @hackage ekg
05:50:54 <lambdabot> https://hackage.haskell.org/package/ekg
05:51:22 <frdg> I should have also mentioned that I am able to import Database.Persist and Database.Persist.TH
05:51:29 <refried_> oh hm interesting @merijn 
05:51:42 <merijn> frdg: Because you're depending on the persistent package, but not persistent-postgresql, presumably
05:52:11 <Clint> and persistent-template
05:54:36 <frdg> so If I add persistent-postgresql to my cabal file and go to compile I get this error: https://pastebin.com/WncfLD61
05:57:44 <dminuoso> refried_: We use https://hackage.haskell.org/package/prometheus-metrics-ghc - functionally you get the same data from ekg.
05:57:53 <dminuoso> It just fits into our infrastructure because we use prometheus for everything anyhow
05:58:51 <dminuoso> (You get some seamless graphing from grafana that ties well into prometheus as well)
05:59:11 <merijn> frdg: Well, it says right there "setup: The program 'pg_config' is required but it could not be found."
05:59:26 <dminuoso> (There's plenty of prometheus exporters going on here, servant exporters, custom prometheus instrumentation for our apps, etc)
06:00:03 <frdg> merijn: ya I realized thanks. Im off to the internet.
06:28:09 <frdg> turns out that I needed to install a special package for compatability with postgres called `ghc-postgresql-libpq-devel`, in case anyone is interested.
06:45:08 <Orbstheorem> Hi o/ Is there a way to enable `AllowAmbiguousTypes` for a single typeclass, without enabling it in the whole module?
06:45:56 <dminuoso> Orbstheorem: No.
06:46:31 <dminuoso> It's a benign extension though, at worst you just transfer type errors to usage sites.
06:48:42 <carbolymer> if i'm reexporting type in a different module, will it be the same type as in the original module, or Haskell will treat it as different types?
06:48:53 <dminuoso> It will be the same type
06:48:57 <sm[m]> refried_: there’s also the very simple timeit
06:49:04 <Orbstheorem> dminuoso: I want to associate a String to types
06:49:27 <carbolymer> interesting, because of that I got overlapping instances error :s
06:49:45 <Orbstheorem> Meh, I'll try to shove in a type somehow...
06:53:12 * hackage tree-sitter 0.9.0.2 - Unstable bindings for the tree-sitter parsing library.  https://hackage.haskell.org/package/tree-sitter-0.9.0.2 (robrix)
06:53:41 <yorick> what's the current preferred clipboard library?
06:57:42 * hackage tree-sitter-go 0.5.0.2 - Tree-sitter grammar/parser for Go  https://hackage.haskell.org/package/tree-sitter-go-0.5.0.2 (robrix)
07:02:12 * hackage tree-sitter-haskell 0.3.0.1 - Tree-sitter grammar/parser for Haskell (with GHC extensions)  https://hackage.haskell.org/package/tree-sitter-haskell-0.3.0.1 (robrix)
07:03:15 <Cheery> Tried tree sitter while back and I'm not sure it's correct. Though it could have been my own stuff was not working.
07:05:12 * hackage tree-sitter-java 0.7.0.2 - Tree-sitter grammar/parser for Java  https://hackage.haskell.org/package/tree-sitter-java-0.7.0.2 (robrix)
07:07:13 * hackage postgresql-pure 0.2.0.0 - pure Haskell PostgreSQL driver  https://hackage.haskell.org/package/postgresql-pure-0.2.0.0 (kakkun61)
07:08:12 * hackage tree-sitter-json 0.7.0.2 - Tree-sitter grammar/parser for JSON  https://hackage.haskell.org/package/tree-sitter-json-0.7.0.2 (robrix)
07:10:41 * hackage tree-sitter-php 0.5.0.1 - Tree-sitter grammar/parser for PHP  https://hackage.haskell.org/package/tree-sitter-php-0.5.0.1 (robrix)
07:11:20 <dminuoso> yorick: Clipboard seems like the way to go.
07:11:40 <yorick> dminuoso: I looked at that, but it seems to lack wayland support
07:11:54 <dminuoso> It does only one thing and does it well.
07:12:13 <dminuoso> yorick: Well then just do it yourself. If you look at the implementation, it should be obvious that it's trivial.
07:12:39 <yorick> dminuoso: yeah, that's the plan, thanks
07:12:42 * hackage tree-sitter-python 0.9.0.3 - Tree-sitter grammar/parser for Python  https://hackage.haskell.org/package/tree-sitter-python-0.9.0.3 (robrix)
07:17:12 * hackage tree-sitter-ruby 0.5.0.3 - Tree-sitter grammar/parser for Ruby  https://hackage.haskell.org/package/tree-sitter-ruby-0.5.0.3 (robrix)
07:21:12 * hackage tree-sitter-tsx 0.5.0.2 - Tree-sitter grammar/parser for TSX  https://hackage.haskell.org/package/tree-sitter-tsx-0.5.0.2 (robrix)
07:23:12 * hackage tree-sitter-typescript 0.5.0.2 - Tree-sitter grammar/parser for TypeScript  https://hackage.haskell.org/package/tree-sitter-typescript-0.5.0.2 (robrix)
07:34:42 * hackage tree-sitter-rust 0.1.0.1 - Tree-sitter grammar/parser for Rust  https://hackage.haskell.org/package/tree-sitter-rust-0.1.0.1 (robrix)
07:44:36 <hseg> hi. i remember seeing a proposal for deriving the provenance for type errors by inverting type inference
07:44:44 <hseg> anybody remember the video in question?
07:52:58 <hseg> it was a short video, on the order of 10m
07:56:58 <dminuoso>     • Could not deduce (Eq (a -> Bool))a rising from a use of ‘NE.groupWith’ (maybe you haven't applied a function to enough arguments?)
07:57:15 <dminuoso> Huh, how does GHC come up with that hint?
07:57:33 <dminuoso> Does GHC try and see whether the constraint could be satisfied if more arguments were applied?
07:57:49 <Cale> That might be a special case...
07:57:55 <Taneb> It might just be "This is a function"
07:58:06 <Taneb> (or "function type" or whatever)
07:58:53 <Cale> https://github.com/ghc/ghc/blob/a3d69dc6c2134afe239caf4f881ba5542d2c2be0/compiler/GHC/Tc/Errors.hs#L2393
08:00:13 <Cale> So if any of the types that the class is applied to is a function type (ignoring any invisible arguments, e.g. due to kind polymorphism)
08:00:48 <Cale> it'll guess that
08:02:54 <Cale> GHC's code is almost... almost becoming possible for me to read
08:03:53 <Cale> I still don't like the way they often name things by writing a sentence decribing the thing and then deleting 80% of all the letters at random
08:08:54 <dminuoso> Ah indeed.
08:28:04 <maerwald> I want to see where a function was called from in a printf manner, is that possible?
08:29:12 * hackage fused-effects-exceptions 1.1.0.0 - Handle exceptions thrown in IO with fused-effects.  https://hackage.haskell.org/package/fused-effects-exceptions-1.1.0.0 (robrix)
08:37:12 * hackage interpolator 1.1.0.1 - Runtime interpolation of environment variables in records using profunctors  https://hackage.haskell.org/package/interpolator-1.1.0.1 (MossPrescott)
08:38:51 <infinisil> maerwald: https://hackage.haskell.org/package/base-4.14.0.0/docs/GHC-Stack.html
08:41:12 * hackage fused-effects-readline 0.1.0.0 - A readline-like effect and carrier for fused-effects  https://hackage.haskell.org/package/fused-effects-readline-0.1.0.0 (robrix)
09:09:11 * hackage postgresql-pure 0.2.1.0 - pure Haskell PostgreSQL driver  https://hackage.haskell.org/package/postgresql-pure-0.2.1.0 (kakkun61)
09:13:42 * hackage zre 0.1.2.0 - ZRE protocol implementation  https://hackage.haskell.org/package/zre-0.1.2.0 (srk)
09:53:12 * hackage MapWith 0.1.0.0 - mapWith: like fmap, but with additional arguments (isFirst, isLast, etc).  https://hackage.haskell.org/package/MapWith-0.1.0.0 (davtjames)
10:33:57 <frdg> are transformers something that will just start to make sense over time? 
10:34:20 <ja> frdg: yup
10:34:42 <Clint> only if you use them
10:35:09 <frdg> I am using them non-stop with yesod. But using other peoples.
10:35:41 <ja> frdg: haskellbook.com has a really slow walkthrough of them
10:35:53 <Clint> yesod isn't a great place for haskell things to make sense on their own
10:36:51 <frdg> Like I understand the whole issue around monad composition and not being able to run join on two different monads so you need to add extra structure and all that but looking at these type signatures is pretty confusing
10:37:07 <frdg> ill look at haskellbook
10:38:17 <happy-moose> what does parse error on input ')' mean? Can't seem to find the issue...
10:38:51 <sm[m]> frdg: I try not to look at the disturbing things but just fix them and move on
10:39:12 <sm[m]> sometimes that works, and after a while they start making sense
10:40:13 <Clint> happy-moose: probably that whatever's parsing what's being parsed wasn't expecting a closing parenthesis where it found one
10:40:31 <frdg> sm[m]: ya Ive been embracing the cargo-cult mentality and hoping that over time it will make sense.
10:41:16 <happy-moose> i see, tried putting another parenthesis around the entire statement but i still get the same error
10:41:32 <sm[m]> and by "just fix them" I mean fix them in a way that's more right now than plumbing the very depths of the error, eg look for existing code that compiles and try to understand why it's written that way, or just copy the pattern it uses, or reapply the fix you used for the same error in the past
10:41:37 <EvanR> in haskell ((x)) = (x)
10:41:38 <sm[m]> more accessible right now
10:41:43 <hseg> hrm. debugging why ormolu -v gives me different answers installed and built. copying it out of .stack-work breaks it. any ideas what it might be looking at?
10:42:51 <sm[m]> for errors related to package api changes, package release notes and issue tracker are often a good source as well
10:43:41 <frdg> sm[m]: thanks for the advice. I'm gonna take it cause I kinda have to :)
10:43:48 <happy-moose> turns out you don't need parenthesis in if statements
10:44:27 <EvanR> (if f then g else h) x vs if f then g else h x
10:45:49 <EvanR> parentheses matter, but they don't doubly matter like lisp
10:45:56 <happy-moose> is there any difference between 'if (x && y) || (x &&z)' and 'if x && y)|| x &&z' ?
10:46:16 <sm[m]> thought when you do want to plumb the depths, you can always paste and this channel will help you
10:46:55 <Clint> happy-moose: yes
10:50:39 <oats> numerous differences lol
10:51:13 <happy-moose> then i think i solved the problem by accident lmao
10:53:38 <infinisil> > :t (&&)
10:53:39 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
10:53:52 <infinisil> :t (&&)
10:53:53 <lambdabot> Bool -> Bool -> Bool
10:53:57 <infinisil> :i (&&)
10:54:20 <infinisil> > :i (&&)
10:54:21 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
10:54:38 <infinisil> No way to display the precedence in lambdabot?
10:56:22 <ja> frdg: also, did you see 'Monad Transformers Step-by-Step' ?
10:57:56 <monochrom> Oh! yahb is not on.  (It would have the :info command you're looking for.)
10:58:13 <infinisil> Ahh
10:58:52 <monochrom> && has higher precedence than ||,  you would not need the parentheses in (x&&y)||(x&&z)
10:59:09 <monochrom> although! I would consider x&&(y||z)
10:59:45 <ja> is there an editor that knows about precedence? so that you could explore expressions using a paredit-like interface
11:00:40 <monochrom> I think "structured haskell mode" does. But not sure if it is kept up to date.
11:00:42 * hackage snap-core 1.0.4.2 - Snap: A Haskell Web Framework (core interfaces and types)  https://hackage.haskell.org/package/snap-core-1.0.4.2 (DougBeardsley)
11:01:25 <monochrom> also I haven't actually used it, only heard from its authors and a very few interested users, and that was a long time ago.
11:02:37 <infinisil> I tried to use it once, I think it worked, but only if you stuck to about standard haskell
11:03:01 <infinisil> Didn't work well with vim bindings though, so I didn't pursue it further
11:03:24 <infinisil> iirc at least
11:03:37 <ja> hmmm maybe ghcide will get that feature some day
11:03:45 <ja> seems like it could be useful especially for beginners
11:03:58 <ja> but a lot of people would probably argue that beginners shouldn't use ghcide...
11:05:00 <ja> ok, maybe it isn't actually something that ghcide needs to support at all, maybe it isn't compatible with the LSP model
11:05:35 <ezzieyguywuf> If I'm using a `someFunc :: a -> IO b -> IO c`, and I'm calling it `someFunc someA (do someStuff)`, is there a way to drop the parentheses?
11:05:36 <monochrom> Can Programming Be Liberated From The Plain Text File?
11:06:22 <monochrom> Yes, the BlockArguments extension.
11:06:50 <monochrom> "f do { ... }" and "g \x -> ..." are OK.
11:06:58 <dolio> I've heard LSP has some kind of code modification options, but I'm not clear on the extent of it.
11:07:00 <frdg> ja: haven't seen that one either
11:07:35 <monochrom> I still like the parentheses because it's helpful visual cue for humans.
11:07:57 <infinisil> monochrom: I'd love if we all used AST editors in the future
11:08:02 <dolio> Obviously it's not going to automatically parse your entire file and remove unnecessary parentheses, though.
11:08:13 <monochrom> OTOH if you say your editor already uses colours on "do" and "\" for visual cues, I guess that works too.
11:08:33 <solonarv> 'do' is a keyword, what kind of editor doesn't color those?
11:08:40 <ezzieyguywuf> ah, BlockArguments indeed
11:08:49 <monochrom> monochromatic editors
11:08:54 <solonarv> I mean, I guess maybe you just don't have synta highlighting at all, yeah
11:09:12 <ezzieyguywuf> yikes, why wouldn't you use syntax highlighting?
11:09:15 <monochrom> pastebin.com
11:09:23 <solonarv> use a better paste site
11:09:25 <ezzieyguywuf> use a better pastebin, lol
11:09:36 <ezzieyguywuf> hah, yea what solonarv said
11:09:38 <dolio> I've seen people that are anti-highlighting.
11:09:42 * solonarv high fives
11:09:51 <ezzieyguywuf> O/
11:10:22 <ja> syntax-highlighting is a misnomer imho... you wanna HIDE the syntax, make the stuff show that actually matters
11:10:32 <monochrom> an editor that does colours but it chooses all the wrong colours and I'm too lazy to change colours so I turn it off completely, e.g., nano
11:11:10 <ezzieyguywuf> *shrug* to each their own, BlockArguments sounds a no-brainer.
11:11:10 <ja> why should "do", "type" and "class" grow a bright purple? they should be almost invisible, the important thing is the custom name i write immediately after!
11:11:18 <ezzieyguywuf> if someone wants to haxe on my code with nano that's on them
11:11:37 <infinisil> ja: Relevant: https://www.benkuhn.net/syntax/
11:11:50 <monochrom> I don't mean I use nano all the time.
11:11:53 * ezzieyguywuf proceeds to just use the parens anyway
11:12:31 <monochrom> But once in a while I ssh to a remote computer and I just want to edit one line, then nano is right for that.
11:12:56 <ja> infinisil: ah thanks! comments in bold, hmmmm dunno about that
11:13:27 <monochrom> But then whereas my background colour is black, nano chooses dark colours presets for most things, so I am turning it off.
11:14:01 <monochrom> And I just want to edit one line, change one character.  Not going to go out of my way to change colours.
11:14:13 <monochrom> I don't even know how to change nano colours.
11:14:23 <ja> you must be coding a lot of APL since you only change single characters :P
11:15:14 <ja> but anyway, syntax coloring is easy to get rid of. what if you want proportional fonts :D now the fun starts
11:15:32 <monochrom> You know what, if you think your editor's colouring is backwards, i.e., wrong emphasis, you can just invert background colours to right it. :)
11:15:40 <infinisil> Hah
11:15:51 <monochrom> (Learned from nano colouring! >:) )
11:15:57 <infinisil> (doesn't actually work, because contrast doesn't change then)
11:16:16 <ja> don't know how to easily invert window colors since i moved off compiz :O
11:16:50 <ja> i remember i had a keyboard shortcut for that, it went a long way! i wonder how many programmer hours have been used for implementing dark-mode everywhere since that...
11:17:23 <ezzieyguywuf> lol, "People on the internet will get very angry at you if you tell them you don’t like syntax highlighting. VERY ANGRY."
11:19:23 <Cale> I like syntax highlighting, but I hate how many syntax highlighters choose a colour for comments which is ridiculously low contrast
11:19:39 <Cale> also, I can live without syntax highlighting
11:20:12 <Tuplanolla> Rainbow vomit or go home.
11:20:34 <Cale> Matching-paren highlighting is more important than syntax highlighting
11:21:03 <Cale> and some form of jump-to-definition is far more important than anything which might improve the appearance of code
11:21:40 <Cale> (at least if you ever work on projects where you're not the only developer)
11:22:16 <monochrom> I hate how pastebin.com basically redacts all string literals.
11:22:21 <Cale> hahaha
11:22:25 <Cale> it's so bad
11:22:27 <hseg> wait, what?
11:22:35 <merijn> pastebin is bad for a billion reasons, tbh
11:22:37 <monochrom> black characters on dark dark green background, are you kidding me?
11:22:51 <hseg> but yeah, ever since i've installed ghc-tags my life has improved so much
11:24:45 <monochrom> Also why is it double-spacing your code.
11:25:00 <hseg> because it's using ormolu?
11:25:15 <ezzieyguywuf> I've been meaning to build a ctags file for my haskell stuff...
11:25:27 <hseg> ezzieyguywuf: ghc-tags. never looked back
11:26:06 <hseg> seriously, the double-spacing (esp grouping-breaking spacing) is the main reason i'm steering away from ormolu
11:26:58 <ja> hseg: do you have an opinion about fourmolu?
11:27:06 <monochrom> heh
11:27:17 <hseg> does it solve the double-spacing problem?
11:27:37 <hseg> (not the two-space indent thing. the two-*newline* thing)
11:28:04 <ja> i think i still don't understand what the problem is, sorry :(
11:28:28 <hseg> https://github.com/tweag/ormolu/issues/635
11:29:33 <monochrom> I think pastebin.com's behaviour predates ormolu.
11:30:32 <hseg> was meant in jest
11:30:44 <monochrom> Oh OK! Heh.
11:40:12 * hackage interpolator 1.1.0.2 - Runtime interpolation of environment variables in records using profunctors  https://hackage.haskell.org/package/interpolator-1.1.0.2 (MossPrescott)
11:44:39 <frdg> I am reading an old paper that is using the function Data.Map.empty. Looking through Data.Map it appears that this function no longer exists. Is this function the same as Data.Map.null?
11:45:16 <ezzieyguywuf> I see empty here https://hackage.haskell.org/package/containers-0.4.0.0/docs/Data-Map.html
11:45:32 <phadej> empty is empty map
11:45:38 <phadej> null checks whether map is empty
11:45:54 <phadej> :t Data.Map.empty
11:45:55 <lambdabot> M.Map k a
11:46:00 <phadej> :t :t Data.Map.null
11:46:01 <lambdabot> error: parse error on input ‘:’
11:46:03 <phadej> :t Data.Map.null
11:46:04 <lambdabot> M.Map k a -> Bool
11:46:08 <ezzieyguywuf> ah, here https://hackage.haskell.org/package/containers-0.6.2.1/docs/Data-Map-Lazy.html#v:empty
11:46:11 <phadej> types almost tell it
11:46:27 <frdg> huh not sure how I missed this thanks
11:49:12 * hackage org-mode-lucid 1.4.0 - Lucid integration for org-mode.  https://hackage.haskell.org/package/org-mode-lucid-1.4.0 (fosskers)
11:58:15 <dsal> I pretty much always use 'mempty'
12:04:36 <zeta_0> this error is thrown when i try to install ghc? https://dpaste.org/0mnx
12:05:58 <zeta_0> i setup the gpg and ssh keys for gitlab about 6 months ago, so maybe something has changed? i don't think someone else is trying to hack me?
12:06:24 <EvanR> mempty does save 1 character (assuming you qualified import). But then you need to import Monoid
12:06:30 <monochrom> Perhaps also ask in #ghc to confirm/refute the key change.
12:06:38 <maerwald> ze
12:06:43 <maerwald> yes they changed
12:07:35 <dmwit> ezzieyguywuf: you might be interested in some awful hacks: https://github.com/dmwit/cabtags
12:08:24 <zeta_0> ok i'll go ask in #ghc
12:08:46 <zeta_0> maerwald: are you responding to me and monochrom?
12:08:51 <maerwald> to you
12:09:51 <zeta_0> maerwald: oh, so i need to setup the gpg and ssh keys again, in order to get things working?
12:11:03 <maerwald> the sha256 fingerprint you got is correct
12:11:38 <maerwald> zeta_0: remove the host entry from your ~/.ssh/known_hosts
12:13:33 <zeta_0> maerwald: which one is the host entry, there's a bunch of stuff in that directory?
12:14:37 <maerwald> check you own paste
12:14:44 <maerwald> it tells you the exact line
12:17:17 <zeta_0> maerwald: oh ok, one second, i'll remove it now and check if it fixes the error being thrown
12:21:24 <zeta_0> maerwald: ok, i deleted the while line where the ED25519 host key is on, now to test it
12:22:06 <zeta_0> typo, ignore `while`
12:25:49 <zeta_0> ok, i think i'm making progress: https://dpaste.org/jLFO
12:28:22 <kuribas> I want to make a library to add named parameters to servant (using named).  
12:28:50 <kuribas> Should I add client and server support in one package, or make many (servant-named-client, etc...)
12:28:52 <kuribas> ?
12:29:56 <kuribas> like auth, there is servant-auth, servant-auth-client, servant-auth-server
12:30:11 <kuribas> it's a bit silly
12:30:26 <zeta_0> maerwald: it's throwing another error, should i just setup the gpg and ssh keys from scratch again? https://dpaste.org/oekb
12:31:12 * hackage hnix 0.9.1 - Haskell implementation of the Nix language  https://hackage.haskell.org/package/hnix-0.9.1 (AntonLatukha)
12:32:29 <kuribas> maybe include client support, but have server support as a separate package?
12:35:26 <koz_> Does anyone know how beam wants you to define autoincrement fields?
12:36:17 <zeta_0> maerwald: i'm now able to clone ghc, thanks for helping me fix this error, i don't understand ssh and gpg that well
12:36:25 <bitmapper> agh
12:36:32 <bitmapper> how do i represent the type t ~ t -> t
12:37:03 <bitmapper> i'm guessing using Fix?
12:37:09 <Taneb> Think very hard about why you want to
12:39:04 <kuribas> what does that even mean?  Isn't ~ a constraint?
12:39:28 <bitmapper> Taneb: combinatory logic
12:39:41 <bitmapper> i'm trying to write the combinators right now
12:39:46 <kuribas> ah t ~ (t -> t)
12:39:50 <bitmapper> yeah
12:43:53 <Tuplanolla> The occurs check should stop you from doing that.
12:45:47 <bitmapper> i get that
12:45:56 <bitmapper> wait
12:52:18 <byorgey> bitmapper: how about  data D = Wrap { unwrap :: D -> D } ?
12:52:39 <byorgey> you can't literally have t ~ (t -> t)  but you can have isomorphism.
12:54:11 <bitmapper> apparently
12:54:14 <bitmapper> "compile :: Ski -> a Fix a" is valid
12:54:50 <bitmapper> oh nvm
12:55:10 <bitmapper> hie just did not like that
12:56:31 <bitmapper> byorgey: i'll give that a try
12:58:15 <bitmapper> oh
12:58:22 <bitmapper> that's... concerning?
13:00:43 <maerwald> sm[m]: ping
13:04:17 <sm[m]> Hi maerwald
13:04:44 <maerwald> sm[m]: can you test a binary for me on mac? :p
13:06:35 <maerwald> I should rephrase: congratulations! You get to be beta tester.
13:06:39 <sm[m]> I’m actually driving, so that’s a no :)
13:06:44 <maerwald> heh
13:06:51 <maerwald> driving and texting!
13:07:06 <sm[m]> Pulled over to type this. But time to turn this off maybe eh :)
13:07:23 <sm[m]> see you o/
13:08:25 <ezzieyguywuf> sm[m]: just set up macos in a virtual machine?
13:10:45 <maerwald> don't make him pull over again, he'll never get home :p
13:23:47 <ezzieyguywuf> that was aimed at you actually maerwald :-P
13:23:49 <ezzieyguywuf> lol
13:24:25 <ezzieyguywuf> I was checking my irssi on my phone the other day, my wife is all "what are you doing?" I said "Chatting" she said "with who?" and I said "...with a bunch of other haskell dorks like me."
13:24:29 <maerwald> virtual machines are not a good metric for what happens on real user systems
13:25:17 <maerwald> messed up brew installations, custom soname symlinks... random hacks
13:25:17 <ezzieyguywuf> maerwald: how so?
13:25:19 <maerwald> etc
13:25:44 <maerwald> CI already runs on mac, that doesn't help
13:25:45 <ezzieyguywuf> ah
13:26:06 <ezzieyguywuf> so you're saying that sm[m] is a bad macos sysadmin, got it
13:26:13 <ezzieyguywuf> 😂
13:27:07 <ezzieyguywuf> srsly though, is it reasonable to do this kind of test? If someone misnamed a library or did a random hack: how is that "your problem", as a MyApp developer?
13:27:26 <ezzieyguywuf> you could go down some serious rabit holes using that logic
13:27:56 * ezzieyguywuf has never released a production piece of software to the world
13:29:11 <maerwald> I wanna know if it runs in a non-CI environment
13:29:57 <maerwald> also, I'm not sure why I'm arguing about this
13:31:52 <ezzieyguywuf> :)
13:33:23 * ski . o O ( "Occurs check: cannot construct the infinite kind" )
13:45:12 * hackage dobutokO-effects 0.9.0.0 - A library to deal with SoX effects and possibilities  https://hackage.haskell.org/package/dobutokO-effects-0.9.0.0 (OleksandrZhabenko)
14:04:12 * hackage Rattus 0.1.0.0 - A modal FRP language  https://hackage.haskell.org/package/Rattus-0.1.0.0 (PatrickBahr)
14:07:16 <frdg> what would this line: `The constructor was exposed in 2.10.0.` mean in regards to documentation? Are data constructors often hidden in libraries?
14:08:15 <EvanR> yeah they are
14:08:32 <EvanR> it's a way to enforce abstract data types
14:09:04 <dminuoso> frdg: If you expose a data constructor you can a) pattern match on it (and thus gain access to its internal implementation) and b) freely construct data types, possibly violating contracts.
14:09:33 <dminuoso> So encapsulation is done by simply not exporting (a data constructor).
14:09:57 <EvanR> but also people sometimes want to reach into the guts of a library. You can export the constructor in an 'Internal' module to signal that you are possibly entering shaky ground
14:10:14 <frdg> ok this makes sense
14:37:22 <koz_> What's the story with Cabal 3 and private/public libraries?
14:38:18 <maerwald> what's that
14:39:27 <koz_> maerwald: That's what I aim to find out. I know it's a thing, but not what that means or how to use them.
14:40:23 <maerwald> *x-files music intensifies*
14:41:46 <fog> % traversePair f1 f2 (a1,a2) = liftA2 (,) (f1 a1) (f2 a2)
14:41:56 <fog> % let traversePair f1 f2 (a1,a2) = liftA2 (,) (f1 a1) (f2 a2)
14:42:21 <fog> @let traversePair f1 f2 (a1,a2) = liftA2 (,) (f1 a1) (f2 a2)
14:42:22 <lambdabot>  Defined.
14:42:35 <fog> :t traversePair
14:42:37 <lambdabot> Applicative f => (t1 -> f a) -> (t2 -> f b) -> (t1, t2) -> f (a, b)
14:42:57 <fog> :t traversePair pure pure
14:42:58 <lambdabot> Applicative f => (a, b) -> f (a, b)
14:43:23 <fog> @let bug f = traversePair f f
14:43:25 <lambdabot>  Defined.
14:43:28 <fog> :t bug
14:43:29 <lambdabot> Applicative f => (t -> f b) -> (t, t) -> f (b, b)
14:43:44 <fog> now it says the pair has to have the same type!
14:43:47 <fog> rrg
14:44:19 <fog> is there any way to define "bug" so that it can use the supplied function over two different types in the pair?
14:45:42 <fog> something like; bug f = traversePair (rePolymorphize f) (rePolymorphize f)
14:46:24 <fog> i cant write the type of bug to be like;
14:46:37 <fog> Applicative f => (forall t b. t -> f b) -> (t, t) -> f (b, b)
14:46:54 <fog> so i think it could have something to do with "exists"
14:47:08 <fog> aka existential quantification 
14:55:22 <infinisil> fog: That seems to make sense to me? Doesn't look like a bug
14:55:42 <fog> hmm
14:56:07 <infinisil> You have `traversePair f f` making `(t1 -> f a) ~ (t2 -> f b)`
14:56:26 <infinisil> `t1 ~ t2` and `a ~ b` follow
14:56:59 <fog> yeah, i get why it unifies the types
14:57:05 <fog> but is there a way to get it not to?
14:57:58 <fog> like, pure must have some special property that i cant seem to write in a type signature
14:58:08 <fog> :t traversePair pure pure
14:58:09 <lambdabot> Applicative f => (a, b) -> f (a, b)
14:58:14 <fog> :t pure
14:58:15 <lambdabot> Applicative f => a -> f a
14:58:31 <fog> ah.... that must have a forall
14:58:47 <fog> the problem is when i try to use (a -> f b)
14:59:00 <fog> so maybe it can *only* work for (a -> f a)
14:59:11 <fog> because thats the only thing that makes sense with a forall...
14:59:38 <fog> not being able to cast to any other type than `a', from `a', with forall...
14:59:46 <nil> "It is true that the Type :: Type axiom can lead to non-termination [...]" -- can anyone point me to an example of a non-terminating term based only on Type :: Type? or just a handwavey idea of how to construct such a term? (would the evaluation not terminate, or the type inference?)
15:00:09 <nil> i think this is related to Girard's paradox, but have no idea how it works
15:00:39 <koz_> I too would love to see this.
15:01:16 <fog> ok, i might do better trying to ask what im actually trying to do...
15:01:36 <infinisil> fog: I think the problem is that if you use existential quantification on an argument like `(forall t b . t -> f b)`, this means "a function that given any type t can produce an f of any other type b"
15:01:40 <fog> is there a way to turn a pair in a monad into a pair of monads?
15:01:56 <infinisil> fog: And that of course doesn't really exist
15:01:57 <fog> im trying to write something like sequence but with this traversePair
15:02:46 <fog> infinisil: yeah i figure its something like the only thing that can have a forall on its type in a simple function mapping is id
15:03:41 <fog> the type of the function i want is; Monad m => m (a,b) -> (m a,m b)
15:03:59 <nil> koz_: from what i'm reading now, it's apparently quite complicated (i.e. wouldn't fit in a single line)
15:04:53 <nil> this is apparently an implementation of girard's paradox in Agda https://github.com/luqui/experiments/blob/master/hypergame.agda
15:05:08 <infinisil> fog: That looks impossible
15:05:15 <fog> i can do it with one half;
15:05:19 <fog> :t sequence @((,)Int) @IO
15:05:20 <lambdabot> error: parse error on input ‘@’
15:05:24 <fog> % :t sequence @((,)Int) @IO
15:05:31 <fog> where is yahb?
15:05:39 <fog> ghci says;
15:05:40 <fog> sequence @((,)Int) @IO :: (Int, IO a) -> IO (Int, a)
15:06:11 <infinisil> > fmap fst
15:06:13 <lambdabot>  error:
15:06:13 <lambdabot>      • No instance for (Typeable f0)
15:06:13 <lambdabot>          arising from a use of ‘show_M455317545249491805731638’
15:06:13 <infinisil> :t fmap fst
15:06:14 <lambdabot> Functor f => f (b1, b2) -> f b1
15:06:15 <fog> oh wait thats the wrong way round
15:06:18 <infinisil> :t fmap snd
15:06:19 <lambdabot> Functor f => f (a, b) -> f b
15:06:35 <infinisil> :t fmap fst &&& fmap snd
15:06:37 <lambdabot> Functor f => f (b1, b2) -> (f b1, f b2)
15:06:40 <infinisil> fog: ^
15:06:51 <fog> basically, pair is traversable in its second argument, so i can use sequence
15:06:54 <fog> :t sequence 
15:06:55 <lambdabot> (Traversable t, Monad m) => t (m a) -> m (t a)
15:07:12 <fog> argh, damn, im trying to do that backwards...
15:07:30 <fog> and my Monad is IO, which isnt Traversable
15:07:55 <infinisil> Why do you need this?
15:09:43 <fog> i have a newtype wrapper around a monad
15:09:58 <fog> its ListT 
15:10:35 <fog> ListT :: MList m a -> ListT m a
15:10:46 <fog> type MList m a  = m (ML m a)
15:10:52 <fog> data ML m a = MEmpty | a `MCons` MList m a
15:11:23 <fog> i have;
15:11:23 <fog>  setM  :: Monad m => m (Maybe (a, f m a)) -> f m a 
15:11:42 <fog>  getM :: Monad m => f m a -> m (Maybe (a, f m a))
15:11:58 <fog> so, even though getM returns the contents into a monad
15:12:17 <dolio> nil: https://github.com/agda/agda/blob/master/test/Succeed/Hurkens.agda
15:12:18 <fog> if setM is used, the monad can be wrapped away again
15:12:27 <fog> and im trying to comute this through a pair
15:12:33 <fog> for writing unzipM
15:13:35 <nil> dolio: thanks
15:13:37 <fog> i get the head and tail into the monad, and then recurse into the tail, so i have a pair at the head, and a pair at the tail
15:13:44 <dolio> No data types in that one.
15:14:04 <fog> getM*
15:14:13 * nil . o O ( geez, that's a simplification? )
15:15:13 * hackage zeolite-lang 0.7.1.0 - Zeolite is a statically-typed, general-purpose programming language.  https://hackage.haskell.org/package/zeolite-lang-0.7.1.0 (ta0kira)
15:15:15 <fog> i can map fst and snd over those, and gather the unziped thing into a pair of heads and tails
15:15:32 <fog> but, these are still in the monad produced by getM
15:15:32 <hseg> Trying to use DuplicateRecordFields, how do I express "d :: { add :: { op, _ }, _}" ? 
15:15:38 <infinisil> You lost me fog
15:16:08 <hseg> Thought (HasField "add" d a, HasField "op" a t) would work
15:16:32 <fog> i end up with :: m ((a,ListT m a),(b,ListT m b))
15:16:52 <hseg> but ghc doesn't allow me to assign this to a type synonym type HasAdditionOp d t 
15:16:59 <hseg> (i.e. not mentioning a)
15:17:07 <fog> now, if i had;  (m (a,ListT m a),m (b,ListT m b))
15:17:20 <fog> then i could use SetM on each half
15:17:34 <fog> and obtain (ListT m a,ListT m b)
15:17:46 <fog> for unzipM
15:18:05 <fog> i just cant do that last step where i need to commute the pair and the monad
15:18:24 <fog> m ((a,ListT m a),(b,ListT m b)) -> (m (a,ListT m a),m (b,ListT m b))
15:19:02 <hseg> ... actually, why am i extracting this in a synonym?
15:20:43 <fog> the "magic" where setM makes the monad disappear, seems difficult to use here, since all the opperations that occur within the monad dont end up with the type that setM needs to take 
15:22:09 <fog> im used to working with things that are not monadic lists, where set and get seem fine to do most things
15:22:19 <fog> maybe something more general is needed for the monadic setting
15:22:44 <fog> something to do with commuting the monad
15:23:49 <fog> setM  z = ListT $ maybe (return MEmpty) (\(x,ListT xs) -> return (x `MCons` xs)) =<< z
15:24:03 <fog> the magic happens when the ListT data constructer eats up the monad
15:25:09 <fog> i could write something similar that would work over a pair within a monad
15:25:29 <fog> but then i would have rewritten setM... which is the central abstraction!
15:26:12 <fog> if the monad is Identity, none of these things are a problem, because it commutes trivially with everything
15:26:32 <fog> but when extending from regular lists (monadic lists that use Identity for the monad)
15:27:03 <fog> it seems there is some new technique needed for the commuting of the monad 
15:43:12 <fog> i can write it like this;
15:43:13 <fog> https://pastebin.com/raw/HVJWNjsi
15:43:29 <fog> but it seems like it cannot share the value being recursed over
15:44:27 <fog> h1 and h2 end up totally separately performing the recursive tail call, having copied the tail  
15:44:37 <fog> this seems bad!
16:23:53 <fog> I can define it like this instead, which seems ok;
16:23:54 <fog> https://pastebin.com/raw/PZbb5TT5
16:40:23 <erlikhan> close
16:50:12 * hackage semirings 0.5.4 - two monoids as one, in holy haskimony  https://hackage.haskell.org/package/semirings-0.5.4 (chessai)
17:03:12 * hackage predicate-typed 0.7.1.0 - Predicates, Refinement types and Dsl  https://hackage.haskell.org/package/predicate-typed-0.7.1.0 (gbwey)
17:34:12 * hackage pandoc-plot 0.8.0.0 - A Pandoc filter to include figures generated from code blocks using your plotting toolkit of choice.  https://hackage.haskell.org/package/pandoc-plot-0.8.0.0 (LaurentRDC)
18:46:42 * hackage smash-optics 0.1.0.0 - Optics for the `smash` library using `optics-core`  https://hackage.haskell.org/package/smash-optics-0.1.0.0 (topos)
19:11:13 * hackage interpolator 1.1.0.2, interpolator 1.1.0.1 (MossPrescott): https://qbin.io/ave-bus-vq7d
19:11:13 * hackage hnix 0.9.1 - Haskell implementation of the Nix language  https://hackage.haskell.org/package/hnix-0.9.1 (AntonLatukha)
19:11:13 * hackage hie-bios 0.6.1, hie-bios 0.6.0 (fendor): https://qbin.io/oliver-perry-3up4
19:11:14 * hackage fused-effects-readline 0.1.0.0, fused-effects-exceptions 1.1.0.0, tree-sitter-rust 0.1.0.1, tree-sitter-typescript 0.5.0.2, tree-sitter-tsx 0.5.0.2, tree-sitter-ruby 0.5.0.3, tree-sitter-python 0.9.0.3, tree-sitter-php 0.5.0.1, tree-sitter-json 0.7.0.2, tree-sitter-java 0.7.0.2, tree-sitter-haskell 0.3.0.1, tree-sitter-go 0.5.0.2, tree-sitter 0.9.0.2, fused-effects-random 1.1.0.0 (robrix)
19:11:15 * hackage smash-optics 0.1.0.0, base16 0.3.0.0 (topos): https://qbin.io/vg-us-9kpi
19:11:16 * hackage trek-app 0.1.0.0, trek-db 0.1.0.0 (JonathanFischoff): https://qbin.io/ought-ceo-r1ke
19:11:18 * hackage servant-seo 0.1.1 - Generate Robots.txt and Sitemap.xml specification for your servant API.  https://hackage.haskell.org/package/servant-seo-0.1.1 (swamp_agr)
19:11:20 * hackage massiv 0.5.3.2 - Massiv (Массив) is an Array Library.  https://hackage.haskell.org/package/massiv-0.5.3.2 (lehins)
19:11:22 * hackage dobutokO-effects 0.9.0.0 - A library to deal with SoX effects and possibilities  https://hackage.haskell.org/package/dobutokO-effects-0.9.0.0 (OleksandrZhabenko)
19:11:24 * hackage ngx-export-tools-extra 0.5.2.0 - More extra tools for Nginx haskell module  https://hackage.haskell.org/package/ngx-export-tools-extra-0.5.2.0 (lyokha)
19:11:26 * hackage pandoc-plot 0.8.0.0 - A Pandoc filter to include figures generated from code blocks using your plotting toolkit of choice.  https://hackage.haskell.org/package/pandoc-plot-0.8.0.0 (LaurentRDC)
19:11:27 * hackage heredocs 0.2.0.0, magma 0.6.0.0, birds-of-paradise 0.2.0.0, stable-marriage 0.2.0.0 (KatsutoshiItoh)
19:11:29 * hackage lambdabot-xmpp 0.1.0.5 - Lambdabot plugin for XMPP (Jabber) protocol  https://hackage.haskell.org/package/lambdabot-xmpp-0.1.0.5 (SergeyAlirzaev)
19:11:31 * hackage predicate-typed 0.7.1.0 - Predicates, Refinement types and Dsl  https://hackage.haskell.org/package/predicate-typed-0.7.1.0 (gbwey)
19:11:33 * hackage language-python-test 0.5.8, language-python 0.5.8 (BerniePope): https://qbin.io/jon-uc-10x4
19:11:34 * hackage Rattus 0.1.0.0 - A modal FRP language  https://hackage.haskell.org/package/Rattus-0.1.0.0 (PatrickBahr)
19:11:36 * hackage HaskellAnalysisProgram 0.1.0 - Haskell source code analysis program  https://hackage.haskell.org/package/HaskellAnalysisProgram-0.1.0 (BastiaanHeeren)
19:11:38 * hackage snap-core 1.0.4.2 - Snap: A Haskell Web Framework (core interfaces and types)  https://hackage.haskell.org/package/snap-core-1.0.4.2 (DougBeardsley)
19:11:40 * hackage org-mode-lucid 1.4.0 - Lucid integration for org-mode.  https://hackage.haskell.org/package/org-mode-lucid-1.4.0 (fosskers)
19:11:42 * hackage xml-types 0.3.8 - Basic types for representing XML  https://hackage.haskell.org/package/xml-types-0.3.8 (StephenWeber)
19:11:44 * hackage purebred-email 0.4.2 - types and parser for email messages (including MIME)  https://hackage.haskell.org/package/purebred-email-0.4.2 (frasertweedale)
19:11:46 * hackage zeolite-lang 0.7.1.0 - Zeolite is a statically-typed, general-purpose programming language.  https://hackage.haskell.org/package/zeolite-lang-0.7.1.0 (ta0kira)
19:11:47 * hackage zre 0.1.2.0 - ZRE protocol implementation  https://hackage.haskell.org/package/zre-0.1.2.0 (srk)
19:11:49 * hackage protocol 0.1.0.1, protocol 0.1.0.0 (epoberezkin): https://qbin.io/worse-hey-ba3w
19:11:50 * hackage semirings 0.5.4, country 0.2.1, refined 0.5 (chessai)
19:11:52 * hackage webkit2gtk3-javascriptcore 0.14.4.1 - JavaScriptCore FFI from webkitgtk  https://hackage.haskell.org/package/webkit2gtk3-javascriptcore-0.14.4.1 (HamishMackenzie)
19:11:53 * hackage postgresql-pure 0.2.1.0, postgresql-pure 0.2.0.0 (kakkun61): https://qbin.io/nutten-agreed-79rk
19:11:55 * hackage neat-interpolation 0.5.1.1 - A quasiquoter for neat and simple multiline text interpolation  https://hackage.haskell.org/package/neat-interpolation-0.5.1.1 (NikitaVolkov)
19:11:57 * hackage MapWith 0.1.0.0 - mapWith: like fmap, but with additional arguments (isFirst, isLast, etc).  https://hackage.haskell.org/package/MapWith-0.1.0.0 (davtjames)
19:13:56 <MarcelineVQ> what a goofster
19:17:42 * hackage b9 1.1.0 - A tool and library for building virtual machine images.  https://hackage.haskell.org/package/b9-1.1.0 (SvenHeyll)
19:23:35 <wroathe> Holy hackage spam batman
19:42:24 <dsal> Haskell's so hot right now.
20:09:52 <moet> hi.. i have a package.conf.d with all my required dependencies "conf" files in it, which ghc-pkg can see and utilize, but for some reason cabal tells me it cannot find necessary dependencies.. is there something special i need to do to tell cabal to get its dependencies from there?
20:22:48 <monochrom> You have two package.conf.d's, one comes with GHC, one in home directory.  cabal default behaviour (v2) refuses to honour the one in home directory.  v1 honours both.
21:03:11 <hololeap> @hoogle unzipR
21:03:12 <lambdabot> Data.Functor.Adjunction unzipR :: Functor u => u (a, b) -> (u a, u b)
21:03:21 <hololeap> fog: ^
21:03:30 <hololeap> "Every functor in Haskell permits unzipping"
21:06:20 <monochrom> Hey may I put it on my midterm test? :)
21:08:21 <hololeap> you'll have to ask edwardk 
21:08:56 <Cale> Another one like that is how every monad in Haskell is what is known as a strong monad: strength :: Monad m => (a, m b) -> m (a, b)
21:12:28 <moet> monochrom: in my case, i think i'm seeing cabal v2-build say it can't see the one with GHC
21:12:59 <moet> monochrom: do you know how cabal usually finds it? it's in a nonstandard location .. ghc-pkg can see it fine though
22:08:58 <dminuoso> Interesting, given a single thread, how can uses of hPutStrLn of a and b be interleaved in `a >> b`?
22:10:01 <dminuoso> (actually, it's hPutStr and hPutChar beneath)
22:10:28 <dminuoso> Specifically, `a` is using putDoc from prettyprinter-ansi-terminal and `b` is using `hPutStr`, but the former I've checked uses the latter.
22:14:00 <Axman6> sounds like something else is happening
22:14:04 <MarcelineVQ> dminuoso: any change if you mess with the butter mode?
22:14:11 <MarcelineVQ> or buffer mode
22:14:46 <Axman6> yum
22:15:32 <rredpoppy> good morning (my slice of the world), good people. how does one traverse a Free tree to modify each node's contents (need access to the functor in the node)
22:19:57 <rredpoppy> tried hoistFree with same functor, ran into quantification errors
22:37:00 <shachaf> Hmm, you could try doing the same thing but not running into quantification errors.
22:37:40 <shachaf> Or you could write down the general type of the thing you want, I guess.
22:39:51 <moet> how can i tell cabal where to locate ghc's package.conf.d?
22:45:48 <rredpoppy> @shachaf any idea how to do this? I get an error saying "Couldn't match type ‘MyF c0 -> MyF c0’ with ‘forall a1. MyF a1 -> MyF a1’ In the first argument of ‘flip’, namely ‘hoistFree’"
22:45:48 <lambdabot> Unknown command, try @list
22:46:07 <rredpoppy> \shachaf any idea how to do this? I get an error saying "Couldn't match type ‘MyF c0 -> MyF c0’ with ‘forall a1. MyF a1 -> MyF a1’ In the first argument of ‘flip’, namely ‘hoistFree’"
22:46:35 <shachaf> rredpoppy: Well, I don't know your code, so the best I could do is guess randomly.
22:46:56 <shachaf> I'd say to take flip out of your program and write out everything explicitly with lambdas.
22:47:14 <dminuoso> Ah, they put out data on separate handles, and there's no flushing.
22:47:19 <shachaf> You can take out the lambdas later, but my suggestion is to never put flip back. It only makes programs more confusing.
22:47:27 <shachaf> (But in this case it might have a rank-n problem too, I don't know.)
22:47:58 <rredpoppy> \shachaf it's all there is, calling hoistFree with a lambda, constrained by the signature of the encompassing function, which is polymorphic in a
22:48:31 <shachaf> No, you're calling "flip" and its first argument is "hoistFree". It says so right there.
22:48:51 <rredpoppy> ok, let me try without flip
22:49:04 <shachaf> Or at least that's my best guess based on you not showing your code.
22:50:02 <rredpoppy> I cannot believe it, it compiles without flip
22:50:25 <rredpoppy> \shachaf why does flip has that effect on polymorphism?
22:51:07 <nlhowell> forgive my overloading, is there a way to associate to 'N a type of cardinality N, and terms 0, 1, ..., N ?
22:51:18 <shachaf> Because inferring higher-rank types is hard, or something?
22:51:43 <nlhowell> err, guess I should start from 1
22:52:33 <nlhowell> and that I should add the qualifier "idiomatic"
22:52:38 <shachaf> Hmm, maybe it's not an inference issue.
22:53:19 <shachaf> This is the same as the $ runST problem, I think.
22:53:30 <shachaf> I mean, runST $ problem.
22:54:22 <shachaf> :t Control.Monad.Free.hoistFree
22:54:23 <lambdabot> Functor g => (forall a. f a -> g a) -> Control.Monad.Free.Free f b -> Control.Monad.Free.Free g b
22:54:24 <shachaf> :t id Control.Monad.Free.hoistFree
22:54:26 <lambdabot> error:
22:54:26 <lambdabot>     • Couldn't match expected type ‘a’
22:54:26 <lambdabot>                   with actual type ‘(forall a1. f a1 -> g a1)
22:54:30 <shachaf> See, you can't even apply id to it.
22:55:59 <rredpoppy> yup, it is the same error, so why does this happen, I read on it to no avail
22:57:01 <rredpoppy> :t id
22:57:02 <lambdabot> a -> a
22:57:48 <rredpoppy> does the universal quantifier have an effect on f and g forcing them to be different?
22:57:53 <dminuoso> I wish GHC would display whether or not a variable is a skolem or metavariable. :(
22:58:14 <dminuoso> (In more subtle situations it's really hard to see what the heck GHC is doing)
22:58:48 <rredpoppy> \schachaf thank you very much for the help in any case, you saved my bacon; beer's on me
22:59:52 <shachaf> The funny thing is that I think hoistFree is only ever used at one type?
23:01:10 <shachaf> :t let hoistFree' f (Pure x) = return x; hoistFree' f (Free as) = Free (hoistFree' f <$> f as) in hoistFree'
23:01:11 <lambdabot> Functor f1 => (f2 (Free f2 a) -> f1 (Free f2 a)) -> Free f2 a -> Free f1 a
23:01:43 <shachaf> So the rank-2 type that takes a natural transformation may be nicer theoretically, but it's much more awkward in practice, and is less general.
23:08:07 <Vitaly_Sivkov> Hello everyone!
23:08:58 <Vitaly_Sivkov> Can anyone recommend good resources on how to get started with FP and Haskell?
23:09:34 <dminuoso> @where cis194
23:09:34 <lambdabot> https://www.seas.upenn.edu/~cis194/spring13/lectures.html
23:09:43 <dminuoso> Vitaly_Sivkov: What's your background?
23:10:36 <Vitaly_Sivkov> About 10 years of experience, mostly web applications with JavaScript/TypeScript
23:11:06 <dminuoso> Do you have any formal CS backgroud?
23:11:22 <Vitaly_Sivkov> Unfortunately no
23:11:36 <dminuoso> Don't worry, just trying to get a feeling for what resource might be adequate for you.
23:11:56 <dminuoso> Do you want something beginner oriented? Something a bit more formal/uni oriented? 
23:14:18 <Vitaly_Sivkov> I know and use some FP basics (immutability, pure functions). But would prefer to start from the beginning to get a solid foundation
23:14:43 <ja> http://haskellbook.com
23:15:04 <dminuoso> Vitaly_Sivkov: CIS194 or haskellbook are the two commonly cited references currently.
23:15:07 <dminuoso> Other good books exist too.
23:15:36 <dminuoso> Graham Huttons book is well accepted too
23:16:14 <dminuoso> Just be prepared to do a lot of "unlearning". Haskell is rather different, so learning it is like learning programming from scratch all over again.
23:16:30 <Vitaly_Sivkov> Big thanks! I'll check the books
23:16:51 <dminuoso> Until you reach a certain degree of competenence, your previous experience carries over very little
23:17:16 <dminuoso> So it's best to forget everything you know, learn programming from scratch again, and then later once you're competent reintegrate your knowledge.
23:17:54 <Vitaly_Sivkov> I already realized that when tried programming in Elixir, it also very different from what I used to :)
23:18:30 <dminuoso> If you know elixir, some of the idioms might become familiar to you. The common theme that comes to mind is heavy reliance on pattern matching
23:19:51 <dminuoso> But Haskell is far more principled. For instance, |> in elixir is a macro, in haskell you'd just use (.) which is a simple function instead.
23:19:51 <dminuoso> (The difference is that |> has really special semantics, cant be used in many places and leads to very quirky error messages)
23:19:52 <Vitaly_Sivkov> Does Haskell heavily rely on pattern matching as well?
23:20:07 <dminuoso> Yes. In fact, in GHC all evaluation is at the end derived from pattern matching. :)
23:20:24 <dminuoso> But you can hide it all inside functions
23:20:29 <dminuoso> i.e. you could do:
23:20:44 <Vitaly_Sivkov> Great, I fall in love pattern matching recently :D
23:20:46 <dminuoso> q = case m of Nothing -> 1; Just x -> f x
23:21:04 <dminuoso> q = maybe 1 f m
23:21:14 <dminuoso> Those are equivalent because maybe is essentially implemented as the above
23:21:58 <dminuoso> Vitaly_Sivkov: The real benefit of pattern matching begins when you can create *custom* data types (sum or product types), and then pattern match on these as well.
23:22:02 <dminuoso> It's a real bummer elixir doesnt let you do that.
23:22:10 <dminuoso> Once you learn that in Haskell, you'll sorely miss this in most other languages
23:22:36 <dminuoso> @let data Color = Red | Green
23:22:38 <lambdabot>  Defined.
23:23:08 <dminuoso> @let f Red = "Stop, don't go!"; f Green = "Go!"
23:23:09 <lambdabot>  Defined.
23:23:11 <dminuoso> > f Red
23:23:13 <lambdabot>  error:
23:23:13 <lambdabot>      Ambiguous occurrence ‘f’
23:23:13 <lambdabot>      It could refer to
23:23:16 <dminuoso> Gha
23:23:22 <dminuoso> @let fun Red = "Stop, don't go!"; fun Green = "Go!"
23:23:23 <lambdabot>  Defined.
23:23:24 <dminuoso> > fun Green
23:23:26 <lambdabot>  error:
23:23:26 <lambdabot>      Ambiguous occurrence ‘fun’
23:23:26 <lambdabot>      It could refer to
23:23:30 * dminuoso sighs
23:23:35 <dminuoso> Too many imported things. :(
23:24:21 <Vitaly_Sivkov> dminuoso Thank you so much for your advice! I'll get back here when I read any of the books :)
