00:01:23 <fog> oh, sorry
00:01:33 <fog> here; https://github.com/fog-hs/streaming-binary-files
00:02:05 <fog> IOList is here; https://github.com/fog-hs/streaming-binary-files/blob/master/Stream/ListT.hs#L24
00:03:59 <fog> warning, readBinaryStream leaves the file handle open
00:09:28 <fog> here is a shorter example; https://pastebin.com/raw/L8yC3H13
00:09:47 <fog> i would expect this to write each time the bang pattern forces the evaluation of hPut
00:10:49 <fog> er, here is a version that has the bang pattern! https://pastebin.com/raw/nbRu3n0v
00:12:05 <fog> the file being written to still does not in size until the function is completed 
00:12:20 <fog> hmmm, maybe i should close the file handle after each write
00:12:32 <fog> i didnt, for the sake of speed, but maybe thats whats causing it 
00:15:06 <fog> hmm, then it crashes, saying the file is locked
00:18:49 <fog> ha! i was looping before closing the handle... 
00:18:52 <fog> this works
00:18:52 <fog> https://pastebin.com/raw/rn1rZVHE
00:18:56 <fog> but it is so slow!
00:19:17 <fog> maybe the user has to specify how large chunks to make
00:20:11 <fog> (turns out it didnt need the bang pattern after all)
00:21:29 <nlhowell> can someone point me, either to a more sophisticated Parsec tutorial explaining the types, or to a parsec-3 tutorial? It seems that all I can find are parsec-2 tutorials which don't explain the types, so I'm having trouble translating to parsec-3
00:23:53 <nlhowell> to be clear, by parsec-2 I mean the parsec-2 interface Text.ParserCombinators.Parsec, and by parsec-3 Text.Parsec
00:24:20 <fog> aha! it works! much faster; https://pastebin.com/raw/7tPCwbf3
00:39:49 <c_wraith> nlhowell: https://hackage.haskell.org/package/parsec-3.1.14.0/docs/Text-Parsec.html#t:ParsecT is the starting point - what would you like elaboration on?
00:42:24 <nlhowell> I ended up solving my problem, which was that Text.ParserCombinators.Parsec exports more than Text.Parsec
00:43:05 <c_wraith> ah, yes.  that happens too
00:44:00 <nlhowell> I don't really understand the typechecker complaints I was getting *before* I added the additional imports
00:44:17 <nlhowell> but I don't feel quite invested enough to explore that right now :)
00:44:34 <c_wraith> were they about missing instances?
00:45:06 <nlhowell> yes
00:45:15 <nlhowell> also ambiguous type variables
00:45:23 <nlhowell> so the missing instance part makes sense to me, in retrospect
00:45:34 <nlhowell> oh i see
00:45:56 <nlhowell> the ambiguous type variables is a result of inability to find the correct instance
00:46:10 <nlhowell> i foolishly only read the first few error messages
00:46:39 <nlhowell> i that common? that the informative error message is not the first one?
00:47:22 <c_wraith> It's not common, but it does happen sometimes.  Especially when non-local type inference gets involved.
00:48:28 <nlhowell> thanks for prodding me into a second look! I feel I understand better what was happening
00:49:05 <c_wraith> woo, learning! :)
00:49:38 <nlhowell> a:D
01:14:18 * hackage qrcode-core 0.9.4 - QR code library in pure Haskell  https://hackage.haskell.org/package/qrcode-core-0.9.4 (alexkazik)
01:18:52 <Ariakenom> dmj`: did you say arch fixed their ghc package?
01:19:37 <dmj`> Ariakenom: that was the word on the street
01:33:09 <Ariakenom> great news
01:54:04 <koz_> dmj`: In what sense did they 'fix' them?
01:54:16 <koz_> I haven't heard of any changes in this regard, and I'm an Arch user.
01:54:31 <dmj`> koz_: no idea, that's just what someone told me, I am not an Arch user
01:55:18 <koz_> dmj`: AFAIK, nothing's changed.
01:55:26 <koz_> And basically, the correct answer is still 'use ghcup'.
01:55:40 <dmj`> koz_: try it out
02:05:03 <fog>  i have kind of messed up the library behind it, but i have the streaming of chunked binary file copy example working using scanners here;
02:05:24 <fog> https://github.com/fog-hs/streaming-binary-files-take2/blob/master/BinaryAppendFile.hs#L82
02:06:20 <fog> foldableM is going to need more work...
02:06:51 <fog> it seems like its *too* lazy in some of the things i tried and ended up abandoning 
02:07:06 <fog> it just returned immediately without doing anything
02:07:20 <fog> so i have to use a scanner and force its evaluation with "discard"
02:07:35 <fog> which uses the old broken version of fold!
02:08:07 <fog> so because this version of fold isnt maximally lazy, it can be used to force the consumption of the scanner
02:08:23 <fog> so when i tried to fix fold it just broke everything
02:08:52 <fog> at least the version above actually allows fast copying and streaming to and from binary files 
02:09:09 <fog> in "chunks", with the test case linked copying at about 1Mb/s
02:09:29 <fog> from ghci, with no optimisations 
02:25:18 * hackage musicScroll 0.3.1.0 - Supply your tunes info without leaving your music player.  https://hackage.haskell.org/package/musicScroll-0.3.1.0 (RubenAstudillo)
02:29:19 * hackage relational-query-postgresql-pure 0.1.1.0 - The connector of relational-record and postgresql-pure.  https://hackage.haskell.org/package/relational-query-postgresql-pure-0.1.1.0 (kakkun61)
02:29:44 <svipal> Yo
02:30:01 <svipal> is there a way to tell ghc to take it cool with the compilation and only take 1 core or something
02:30:19 * hackage publish 2.1.3 - Publishing tools for papers, books, and presentations  https://hackage.haskell.org/package/publish-2.1.3 (AndrewCowie)
02:34:33 <tomjaguarpaw> Is is possible to get cabal (v2-)build to typecheck only?
02:36:19 <tomjaguarpaw> The usual ghc option is -fno-code.  If I apply that to cabal using --ghc-options=-fno-code it wants to rebuild all my dependencies using -fno-code!  This obviously fails.
02:37:50 <tomjaguarpaw> Is it possible to apply a --ghc-option without having it apply to all the dependencies?
02:39:30 <tomjaguarpaw> Hmm, seems to be a known issue: https://github.com/haskell/cabal/issues/3883
02:55:49 * hackage hpdft 0.1.0.6 - A tool for looking through PDF file using Haskell  https://hackage.haskell.org/package/hpdft-0.1.0.6 (keiichiroShikano)
03:13:43 <kozova1> Haskell noob here, can somebody help me understand the use case of mapM and mapM_ as well as what exactly is their purpose?
03:17:38 <systemfault> :t mapM
03:17:40 <lambdabot> (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
03:17:44 <systemfault> :t traverse
03:17:45 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
03:18:38 <systemfault> :t sequence
03:18:39 <lambdabot> (Traversable t, Monad m) => t (m a) -> m (t a)
03:19:02 <systemfault> So, it's basically a "map" operation followed by "sequence"
03:19:31 <systemfault> mapM_ is like mapM but discards the result.
03:21:03 <dmj`> tomjaguarpaw: ghcid seems to be able to accomplish this
03:22:28 <dmj`> :t foldr (>>) (pure ())
03:22:29 <lambdabot> (Foldable t, Monad m) => t (m a) -> m ()
03:22:34 <dmj`> @src sequence
03:22:34 <lambdabot> sequence []     = return []
03:22:34 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
03:22:34 <lambdabot> --OR
03:22:34 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
03:24:19 * hackage shake-plus 0.3.1.0 - Re-export of Shake using well-typed paths and ReaderT.  https://hackage.haskell.org/package/shake-plus-0.3.1.0 (locallycompact)
03:42:44 <kozova1> systemfault: so sequence can "invert" a traversable of monads to a monad of traversable?
03:43:48 <systemfault> kozova1: That's the "sequence" part
03:43:56 <systemfault> Yeah
03:44:40 <kozova1> so for example [IO String] -> IO [String], right?
03:45:47 <systemfault> % mapM (putStr . show ) [1..10]
03:45:48 <yahb> systemfault: 12345678910[(),(),(),(),(),(),(),(),(),()]
03:45:49 * hackage hoogle 5.0.18 - Haskell API Search  https://hackage.haskell.org/package/hoogle-5.0.18 (NeilMitchell)
03:45:55 <systemfault> % mapM_ (putStr . show ) [1..10]
03:45:56 <yahb> systemfault: 12345678910
03:45:59 <systemfault> See?
03:46:08 <kozova1> oh I see
03:46:28 <kozova1> so it can be used kinda like a "map with side effects" (in the case of IO of course)
03:46:55 <systemfault> Yeah... but I'm not sure if anyone still uses mapM these days...
03:47:03 <systemfault> % traverse (putStr . show ) [1..10]
03:47:03 <yahb> systemfault: 12345678910[(),(),(),(),(),(),(),(),(),()]
03:47:07 <systemfault> % traverse_ (putStr . show ) [1..10]
03:47:08 <yahb> systemfault: 12345678910
03:47:26 <kozova1> so traverse and traverse_ is a more generic version?
03:47:34 <kozova1> :t traverse
03:47:36 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
03:47:49 <kozova1> makes sense
03:50:16 <kozova1> one more question, Clojure has this website called 4clojure.com, is there anything similar for Haskell?
03:51:25 <kozova1> https://4clojure.com
03:51:39 <kozova1> whoops
03:51:49 <kozova1> no https there
03:59:59 <kuribas> monochrom: I did a test on ghci with sbool, and it seemed to work even with the warning.
04:00:47 <kuribas> monochrom: of course it could work in ghci, then fail after optimizations.
04:01:13 <kuribas> monochrom: so I looked at the core with -O2, and it looked correct.
04:01:58 <kuribas> I guess the next step is to watch out if I get misterious crashes.
04:10:48 <kuribas> btw, I found this interesting talk: https://codesync.global/media/revisiting-pattern-match-overlap-checks-in-haskell-cmldn19/
04:14:52 <kuribas> overlap checks aren't as easy as they look
04:37:31 <kozova1> I wish the $ operator was available for bash instead of the ugly $() syntax
04:39:55 <Ariakenom> fish shell uses ()
04:42:09 <MPoehls> I have a question regarding ghc profiling. The .hp file, created during profiling, displays the memory usage until a certain point, which seems to be the end of the execution of the program (based on the execution time the program usually takes), as expected.But after that an extra sample is created, that contains no data (no cost centers, it is
04:42:10 <MPoehls> just begin sample followed by end sample). This sample is also created out of the 0.1 second gaps used before.For example the last "correct" sample is at 17s and the empty sample is at 40s. When plotting the data, this results in an monotonous increasing graph (for all centers), that has its maximum at the last correct sample (17s) followed by a
04:42:10 <MPoehls> straight line to zero (40s).Does anyone know, what leads to this behavior and how it can be prevented?
04:46:13 <gentauro> does anybody know how to write Perls non-greedy regexp (`.*?`) with `Text.Regex.TDFA.String`?
04:47:41 <kuribas> isn't nongreedy impossible with a dfa?
04:48:08 <gentauro> kuribas: I don't know
04:50:14 <gentauro> kuribas: I was aiming for something that was fast and build on POSIX -> https://wiki.haskell.org/Regular_expressions#Overview
04:52:19 * hackage wai-secure-cookies 0.1.0.5 -   https://hackage.haskell.org/package/wai-secure-cookies-0.1.0.5 (alaminium)
04:52:50 <kuribas> gentauro: does regex-pcre not build on POSIX?
04:54:35 <gentauro> kuribas: `regex-pcre> * Missing (or bad) C library: pcre`
04:54:42 <gentauro> I guess there is a `C` dependency
04:54:48 <kuribas> gentauro: yeah
04:54:58 <kuribas> apt-install libpcre?
04:55:35 <kuribas> apt install libpcre3-dev on ubuntu
04:56:19 * hackage Glob 0.10.1 - Globbing library  https://hackage.haskell.org/package/Glob-0.10.1 (MattiNiemenmaa)
04:57:13 <gentauro> kuribas: I'm on NixOS, so it might gonna take a while ;)
04:57:36 <kuribas> right :) I don't know a thing about NixOS...
04:57:49 <gentauro> kuribas: oh, it's just `pcre` :)
05:01:37 <gentauro> kuribas: didn't work
05:01:52 <gentauro> :(
05:01:56 <kuribas> gentauro: does pcre include sources?
05:02:03 <kuribas> or at least headers?
05:03:37 <gentauro> kuribas: that's a good question
05:03:46 <kuribas> it might be just the library
05:03:48 <gentauro> but I think I will go another path
05:04:03 <gentauro> if my Haskell code needs to rely on some C lib, I would rather write the code in C
05:06:09 <maerwald> why
05:06:18 <maerwald> calling into C works ok
05:06:37 <kozova1> Usually those C libraries aren't built for functional programming
05:07:34 <maerwald> so?
05:07:59 <kuribas> kozova1: you can always make a functional layer over it. See llvm for example.
05:08:40 <kuribas> kozova1: in fact, that's how a lot of libraries work, you have a low-level package which just binds the library, than another library on top which makes it more idiomatic haskell.
05:15:44 <kozova1> Yeah I know, but for large libraries it is often easier to just write it in the intended language
05:16:31 <gentauro> maerwald: cos it's a headache to ensure that libs are installed *corectly* on other peoples machines. I can't be bothered with that
05:16:41 <nlhowell> It seems that Parsec only does parsing, and not both directions. What's idiomatic for structures that I need both to parse and to serialise?
05:16:51 <maerwald> gentauro: link statically
05:16:51 <kuribas> writing ffi bindings isn't that hard.
05:17:02 <nlhowell> Should I just write a separate "serialise" function by hand?
05:17:13 <gentauro> kuribas: writing FFI bindings are trivial
05:17:35 <gentauro> ensuring that those libs you are binding to will work for OS: A,B,C or D, not so much
05:17:36 <kuribas> gentauro: it depends
05:18:28 <kuribas> but duplicating work, just because it ain't written in the right language is pretty dumb IMO
05:19:05 <kuribas> good luck replicating llvm, z3, blas, etc...
05:19:14 <maerwald> heh
05:19:29 <maerwald> gmp has been done in haskell and was sloooow
05:25:47 <gentauro> kuribas: I didn't wrote I would duplicate the code. I wrote if I'm gonna go that way, I would rather writhe that `tool` in C (`Unix philosophy`)
05:26:12 <gentauro> and then I would use the outputed result in my Haskell code
05:26:54 <kuribas> I wouldn't use C unless I need ultimate speed, or unless I am on a microcontroller.
05:27:12 <kuribas> Or if the code needs to run on a system without haskell compiler.
05:27:37 <kuribas> I see nothing wrong with using the ffi.
05:27:55 <kuribas> sure, if there is a choice, I'd pick a pure haskell solution.
05:28:45 <gentauro> 14:27 < kuribas> sure, if there is a choice, I'd pick a pure haskell solution
05:28:49 <gentauro> I totally agree
05:29:06 <kuribas> if they equal in functionality
05:29:13 <kuribas> functionality that I need
05:29:52 <maerwald> depends how good the choice is
05:32:14 <bussller> haskellites
05:32:36 <bussller> how to compile haskell code with cabal with -O3 optimization
05:32:50 <bussller> I am able to compile with -O3 like 
05:33:03 <bussller> ghc -O3 Main.hs -o main
05:33:53 <dmj`> bussller: Any -On where n > 2 is the same as -O2.
05:34:45 <bussller> !. so not possible to achieve O3 level optimizations with GHC compiler?
05:35:03 <bussller> O.K. Does cabal uses -O2 by-default?
05:36:33 <maerwald> O1
05:36:59 <bussller> mm
05:37:15 <bussller> how about getting -O2 into cabal?
05:37:25 <lordgrenville> In a literate haskell document, is there a way to enrich text (headings, italic, bold, etc) when converting to html/pdf? I thought markdown syntax would work, but pandoc doesn't seem to recognise it
05:37:55 <lordgrenville> (I guess LaTeX is probably the answer but anyway to skate by with just markdown?)
05:39:04 <maerwald> bussller: use -O2
05:39:31 <frdg`> is there a function in some library you know of for converting a unix time stamp to a regular time?
05:39:38 <bussller> maerwald: in cabal config?
05:39:56 <maerwald> cabal build -O2
05:40:22 <bussller> maerwald: thanks mate
05:40:31 <maerwald> cheers mate
05:41:26 <bussller> maerwald: cabal v1-build throws error
05:41:38 <maerwald> use v2
05:41:50 <bussller> maerwald: cabal: unrecognized `v1-build` option '-O2
05:42:27 <bussller> maerwald: says "Up to date"
05:42:47 <maerwald> cabal v2-build -O2
05:43:00 <Ariakenom> frdg`: I would think https://hackage.haskell.org/package/time-1.10/docs/Data-Time-LocalTime.html#v:utcToLocalTime
05:44:12 <bussller> maerwald: yes. cabal v2-build -O2 throws "Up to date"
05:44:33 <maerwald> then you've already built it
05:45:26 <bussller> maerwald: wov. thank you mate
05:45:41 <maerwald> also try: cabal clean
05:45:47 <maerwald> and then build again
05:46:54 <bussller> maerwald: That worked mate. Thanks a lot
05:46:54 <nlhowell> is there a variant of `interact` that allows error reporting?
05:47:08 <nlhowell> e.g. `interact2 :: String -> Either String` ?
05:47:34 <bussller> I have a weired difference between execution time when I compile using cabal and using ghc
05:47:43 <bussller> cabal v2-build -O2
05:47:57 <bussller> execution time 0.36s
05:48:13 <bussller> ghc -O3 Main.hs -o main
05:48:35 <bussller> execution time 0.20s
05:48:48 <bussller> does that mean -O3 is effective? 
05:49:12 <bussller> If so how can I make cabal compile using -O3?
05:51:49 * hackage mono-traversable-instances 0.1.1.0 - Extra typeclass instances for mono-traversable  https://hackage.haskell.org/package/mono-traversable-instances-0.1.1.0 (MichaelSnoyman)
05:52:42 <Ariakenom> nlhowell: no. note that lazy IO isn't great. I like it for small things and playing around though
05:53:37 <bussller> ?
05:54:27 <nlhowell> Ariakenom: "isn't great" here means that the API isn't full, or performance problems, or ... ?
05:54:34 <Ariakenom> nlhowell: that said you can build one yourself with hGetContents
05:54:42 <nlhowell> yeah, that's what i'm doing now :)
05:54:55 <nlhowell> class Interactable a where ...
05:55:17 <nlhowell> though i think i spelled it wrong :3
05:55:20 * hackage streaming-commons 0.2.2.0 - Common lower-level functions needed by various streaming data libraries  https://hackage.haskell.org/package/streaming-commons-0.2.2.0 (MichaelSnoyman)
05:55:55 <Ariakenom> nlhowell: files are resources and should be handled like it. lazy io is bad at managing opening closing and consumption of the file
05:56:49 <nlhowell> i think that getContents will read to the end, no?
05:57:00 <nlhowell> eventually, i mena
05:57:24 <Ariakenom> if you evaluate the entire string
05:57:48 <dmj`> frdg`: posixSecondsToUTCTime
05:57:50 <Ariakenom> but maybe you read a json blob and you stop reading at the end of the object instead of the end of the string
05:58:18 <nlhowell> oh, my parser has an eof requirement
05:58:24 <nlhowell> but i agree this is theoretically a problem
05:59:47 <frdg`> dmj`: in the end I found a stack overflow post to copy and paste :)
06:00:01 <dmj`> frdg`: did it use that function ?
06:00:04 <frdg`> yes
06:00:08 <dmj`> good
06:41:13 <ibloom> Is there something close to an infinite type in haskell. I don't even know what to google...
06:41:49 * hackage os-release 1.0.1 - /etc/os-release helpers  https://hackage.haskell.org/package/os-release-1.0.1 (maerwald)
06:46:46 <dmj`> ibloom: no, https://stackoverflow.com/questions/43018103/what-are-infinite-types
06:47:35 <ibloom> Got myself in kind of a type hell for no reason. Just trying to see if I can figure it out before I abandon this idea :)
06:55:35 <MarcelineVQ> You should ask about your specific type hell instead of the more general question :>
06:55:56 <frdg`> does anyone who uses haskell-mode in emacs know how I can cycle through the command history in haskell-interactive? `haskell-interactive-mode-history-previous/next` dont do anything. This has been kind of driving me crazy.
07:00:37 <dmj`> frdg`: M-p
07:00:59 <dmj`> and M-n to go back
07:01:29 <frdg`> ya they dont anything for me
07:02:53 <frdg`> ok its cause of evil mode. I need to be in insert mode haha
07:02:58 <frdg`> thanks
07:08:50 <ibloom> MarcelineVQ: Basically I am trying to recursively traverse a data structure using two polymorphic functions and the first function gives the next the function the function it needs  to call in order to recurse and vice versa.
07:09:14 <ibloom> It seemed beautiful when I thought it up but in practice it's really hard to implement.
07:10:04 <ibloom> I'm gonna give it one more try and then go back to the non-compositional method.
07:11:20 <MarcelineVQ> you're allowed to link to (haskell) code here if you get stuck
07:14:12 <ibloom> Basically I boiled it down to I need to construct a function with this type: 
07:14:21 <ibloom> https://www.irccloud.com/pastebin/etMDieix/
07:14:33 <ibloom> Which I don't think is possible.
07:16:15 <ibloom> Basically I've been trying to refactor a bunch of code in my rasterizer and I'm wasting a bunch of time trying to make things super polymorphic.
07:20:52 <ibloom> Basically I wanted to traverse a tree like this using some generic traversal functions.
07:21:05 <ibloom> https://www.irccloud.com/pastebin/rJxcxdyF/
07:21:53 <ibloom> I tried to boil this down to the most basic version of the code I can. The actual code has tons of complicated types in it.
07:23:45 <ibloom> So basically I wanted to write a simple traversal for Tree, that doesn't know the node type but can pass tag information down through the recursion.
07:24:30 <ibloom> In practice my Branch data constructor also includes information that is passed down to child items.
07:26:17 <ibloom> So the goal is to write two tag teaming traversal functions that pass state information as the traversal goes down the tree, but this proved to be really complex to construct.
07:26:34 <MarcelineVQ> ibloom: have you seen? https://www.microsoft.com/en-us/research/uploads/prod/2016/11/trees-that-grow.pdf
07:27:00 <ibloom> No but I'll read it.
07:27:38 <MarcelineVQ> there's also things like https://apfelmus.nfshost.com/articles/monoid-fingertree.html https://chrispenner.ca/posts/intro-to-finger-trees that show how monoids can fill in the tagging role
07:27:59 <MarcelineVQ> or at least hint it
07:28:34 <ibloom> Ok great, those are some great places to look.
07:59:03 * ski . o O ( "Ornamental Algebras, Algebraic Ornaments" by Conor McBride in 2010-08-09 at <https://personal.cis.strath.ac.uk/conor.mcbride/pub/OAAO/Ornament.pdf> )
08:22:02 <ibloom> Thanks, those end up being really useful.
08:56:19 * hackage ghc-tags-core 0.2.1.0 - a library to work with tags created from Haskell parsed tree  https://hackage.haskell.org/package/ghc-tags-core-0.2.1.0 (coot)
08:57:19 * hackage ghc-tags-plugin 0.2.1.0 - A compiler plugin which generates tags file from GHC parsed syntax tree.  https://hackage.haskell.org/package/ghc-tags-plugin-0.2.1.0 (coot)
09:18:19 * hackage ghc-tags-plugin 0.2.2.0 - A compiler plugin which generates tags file from GHC parsed syntax tree.  https://hackage.haskell.org/package/ghc-tags-plugin-0.2.2.0 (coot)
09:19:19 * hackage ghc-tags-core 0.2.2.0 - a library to work with tags created from Haskell parsed tree  https://hackage.haskell.org/package/ghc-tags-core-0.2.2.0 (coot)
09:25:19 * hackage microlens-aeson 2.3.1 - Law-abiding lenses for Aeson, using microlens.  https://hackage.haskell.org/package/microlens-aeson-2.3.1 (fosskers)
09:44:49 * hackage fused-effects-th 0.1.0.0 - Template Haskell helpers for fused-effects.  https://hackage.haskell.org/package/fused-effects-th-0.1.0.0 (patrick_thomson)
09:51:12 <nlhowell1> I have a columnar plain-text file format, and I want to use a Nat type parameter in my parsed object
09:51:40 <nlhowell1> I've written the polymorphic parser, but I am not sure how to write the generic parse function
09:52:03 <nlhowell1> I'm following https://blog.jle.im/entry/fixed-length-vector-types-in-haskell.html
09:52:19 * hackage input-parsers 0.1.0.1 - Extension of the parsers library with more capability and efficiency  https://hackage.haskell.org/package/input-parsers-0.1.0.1 (MarioBlazevic)
09:52:20 <nlhowell1> and it seems I need to know the size ahead of time
09:52:41 <monochrom> I would think that's what "fixed length" means.
09:53:12 <monochrom> That means all tutorials on "fixed length thing" are poor fit for your use case.
09:54:13 <monochrom> For dynamically determined sizes and you still want to statically ensure safety, you need to go existential, e.g., SomeNat.
09:54:30 <nlhowell1> yes, that's exactly what I'm referring to
09:55:02 <monochrom> When you finally achieve it, you will start questioning whether it is worthwhile. I certainly say "no" in most cases.
09:55:23 <nlhowell1> but my question is, what's the easiest way to do this? should I parse a little bit, extract the column length, then use this to decide the type?
09:55:24 <monochrom> But perhaps the journey is more important than the destination.
09:55:48 <monochrom> Yes. Find the size, hide it behind SomeNat.
09:56:28 <nlhowell1> OK; some strategy like "parse for all possible sizes, and reject those with errors" I suspect would be too slow
09:57:23 <monochrom> If you say you will have two tables and they have equal size, except that the common size is dynamically determined. Now you need to define your own existential type that holds both tables and there is only one size to hide.
09:58:00 <monochrom> That would be an example of how SomeNat doesn't serve you, but it illustrates a spirit you can follow.
09:58:39 <nlhowell1> I see. Thanks!
09:58:50 <monochrom> If you say "parsing" then you have accepted that rejection is possible.
09:59:14 <nlhowell1> yes, that was another concern: if all parsers fail...
09:59:35 <nlhowell1> but perhaps I could encode the inconsistent column count failure differently
09:59:50 <monochrom> You need to learn modal logic.
10:00:30 <monochrom> In modal logic the correct sentence is "must may fail", not "must fail".
10:01:22 <monochrom> Concretized in 1st-order logic for parsers, it goes: for all parser, there exists input, that parser rejects that input.
10:02:30 <Aruro> OSx Mojave, installsed ghcup, did cabal install implicit. Compiling example ghc tells me Graphics.Implicit not found.
10:02:50 <nlhowell1> I don't quite understand what you are getting at here, but I think I have enough to continue
10:03:19 * hackage shift 0.2.1.3 - A tool to quickly switch between directories  https://hackage.haskell.org/package/shift-0.2.1.3 (vmchale)
10:03:26 <maerwald> Aruro: what exactly are you building and how
10:03:42 <Aruro> implicit cad, just did cabal install after ghcup installation
10:03:50 <ja> Graphics.Implicit isn't in the standard library, is it?
10:03:57 <monochrom> No.
10:04:17 <Aruro> no, i already installed and compiled successfully, but ghc does not know about it :D
10:04:40 <maerwald> I feel there's information missing
10:05:02 <Aruro> uninstall-haskell, ghcup, cabal install implicit
10:05:23 <maerwald> Aruro: you want to install a library?
10:05:25 <monochrom> Is implicit a library package? Then "cabal install implicit" doesn't buy you anything.
10:05:38 <ja> Aruro: but where are you using 'implicit' from? usually that project would need a cabal file too with the dependency specified
10:05:56 <Aruro> cabal install doesnt fetch it from hackage?
10:06:14 <Aruro> http://www.implicitcad.org/docs/install
10:06:20 <monochrom> "install" is good for exe only.  At least as a 1st-order story.
10:06:25 <monochrom> s/story/model/
10:06:47 <Aruro> hm, i remember in past install was good for everything
10:07:10 <monochrom> Yes. Past.
10:07:15 <monochrom> cabal-install changed.
10:07:35 <Aruro> hm a bit confusing they say install ghcup then stack on haskell.org
10:07:50 <Aruro> in stack docks they say stack can install ghc
10:08:10 <Aruro> do i need stack now?
10:08:12 <monochrom> I think they mean choose one.
10:08:36 <Aruro> quote : The recommended way to install the components of the mac platform is using ghcup to install ghc and cabal-install, and following the instructions at haskellstack.org to install stack.
10:09:00 <monochrom> Oh, well, darn, then they're wrong.
10:09:40 <maerwald> Aruro: so what do you want to do with implicit?
10:09:43 <monochrom> stack will ignore everything else you installed yourself. At least that's the 1st-order model.
10:09:45 <solonarv> well, that's if you want "the entire haskell platform", which I guess is meant to include stack *and* cabal
10:10:10 <Aruro> maerwald: i wanted to use library to make stl files
10:10:28 <monochrom> solonarv is right. In retrospect that idea is completely broken, as I explained.
10:10:33 <maerwald> Aruro: so you're coding haskell?
10:10:49 <Aruro> developer claims cabal install implicit should be enough
10:11:09 <maerwald> will you use a binary or a programming API?
10:11:09 <Aruro> maerwald: scripting a bit
10:11:14 <Aruro> api
10:11:19 <maerwald> haskell api?
10:11:26 <Aruro> yes
10:11:35 <maerwald> then you need to make a proper project
10:11:39 <Aruro> i wanna use runhaskell exmaple.hs to make stl
10:11:48 <maerwald> cabal init --interactive
10:11:58 <monochrom> "cabal install implicit" is good for the exes such as extopenscad
10:12:15 <Aruro> yes that compiled well, how do i get library?
10:12:19 <monochrom> But really the instruction is outdated and does not know that cabal-install has changed.
10:12:45 <monochrom> Do you plan to write a *.cabal file?
10:13:02 <monochrom> in other words start your own package that depends on implicit?
10:13:23 <monochrom> There is one solution if "yes". There is a different solution if "no".
10:14:02 <Aruro> no i just want simplest version, run runhaskell on file
10:14:07 <Aruro> no project needed
10:14:09 <Aruro> 1 file
10:14:29 <Aruro> i guess there is a mess with my path variables, so ghc does not see libraries?
10:14:50 <monochrom> OK I'll take a minute to check exact command syntax before I post it
10:17:35 <Aruro> i get this error in ghci : <no location info>: error:
10:17:35 <Aruro>     Could not find module ‘Graphics.Implicit’
10:17:48 <maerwald> https://cabal.readthedocs.io/en/latest/cabal-commands.html?highlight=%2Fusr%2Fbin%2Fenv#cabal-v2-run
10:18:04 <maerwald> there is an explanation on how to make a script file
10:19:05 <monochrom> Oh, that. Yeah, that's nice.
10:19:36 <monochrom> I was looking for "cabal run --dependency=implicit" but I couldn't confirm that it exists.
10:20:23 <monochrom> or if it's called "--dependency"
10:21:29 <monochrom> Did cabal stole that idea from stack haha
10:21:30 <Aruro> yes this kinda works, it does see implicit package
10:21:45 <Aruro> but then there is mess with dependencies :D
10:22:17 <monochrom> You will have to list base and maybe other packages that have the modules you import.
10:22:26 <Aruro> ok i probably have to install stack
10:22:47 <monochrom> stack will make you do a similar thing actually.
10:23:12 <Aruro> really? but i remember back in old days all these was not needed just cabal install and runhaskell
10:23:26 <Aruro> maybe i made mistake somewhere
10:23:26 <monochrom> It's all over again either "write a script that lists all packages, except in stack syntax" or "write package.yaml".
10:23:40 <monochrom> How back in old days? 2 decades?
10:23:46 <Aruro> 5 years ago
10:23:54 <Aruro> 2015
10:24:14 <monochrom> I forgot whether stack existed, but it certainly was like this since day one.
10:24:26 <Aruro> stack appeared around 16-17
10:24:41 <maerwald> you can also do this: cabal v2-repl --build-depends implicit
10:24:45 <monochrom> cabal-install changed. What you're seeing now as cabal-install new behaviour, most of it is inspired by stack.
10:24:52 <maerwald> and then in the repl :load yourscrpit.hs
10:25:42 <monochrom> ah, --build-depends
10:25:59 <monochrom> (and for repl, not for run)
10:26:02 <Aruro> maerwald: thank you, that actually worked
10:26:19 <Aruro> but what is function of runhaskell now?
10:27:16 <monochrom> when you only use libraries that come with GHC
10:27:38 <Aruro> btw, can i just install older version of haskell platform from 2018 and be happy with it?
10:27:43 <Aruro> i just need this implicit package
10:27:48 <maerwald> Aruro: there's something we aren't telling you, but for your own sake
10:27:51 <monochrom> Yes, if it still runs on new OSes
10:28:08 <Aruro> i have mojave
10:28:13 <monochrom> Yeah I totally refuse to step outside of my 1st-order models I told.
10:29:55 <ja> maerwald: what is this secrit?
10:30:20 <monochrom> May I tell the secret but in ROT13? >:)
10:30:25 <ja> yes
10:31:10 <monochrom> bah now I have to lookup my own solution for an exercise for my students about using tr to implement ROT13
10:31:23 <maerwald> https://cabal.readthedocs.io/en/latest/cabal-commands.html?highlight=ghc%20environment#cabal-v2-install
10:31:32 <monochrom> yeah, that.
10:32:37 <Aruro> maerwald: i did load script with v2-repl, but it tells me main is not in scope
10:32:43 <ja> oh, i didn't know about --package-env , that is useful
10:32:48 <monochrom> also, stack can use your manually installed GHC, if you write a non-default config file. (I would rather not.)
10:33:23 <maerwald> Aruro: do you have one?
10:33:37 <Aruro> in script file there is main = writeSLT ...
10:33:46 <maerwald> :main
10:33:48 <maerwald> ?
10:33:50 <Aruro> main = writeSTL 1 "test.stl" out
10:33:56 <Aruro> yes i tried no success
10:34:28 <maerwald> Aruro: you typed ":main"?
10:34:32 <Aruro> yes
10:34:48 <Aruro> <interactive>:10:53: error:
10:34:48 <Aruro>     • Variable not in scope: main :: IO a0
10:35:14 <Aruro> but there was a line 1 module interpreted
10:35:30 <Aruro> loaded*
10:35:56 <Aruro> ok, prehaps best thing i wipe out ghcup and friends and try 2018 haskell platform
10:36:07 <maerwald> Aruro: :script file.hs?
10:36:13 <Aruro> :load ?
10:37:02 <monochrom> "main doesn't exist" sounds like a completely orthogonal issue
10:37:43 <Aruro> with script it complains about incorrect identation
10:37:51 <maerwald> then fix it
10:38:13 <halogenandtoast> Hoping someone can help make a suggestion here. I have this line of code https://github.com/halogenandtoast/ArkhamHorrorLCG/blob/main/src/Arkham/Types/Investigator.hs#L143, which wants to check if an asset can be damaged. To avoid module cycles I've limited most modules to only being able to see the Id types from other modules. But I need info about an Asset to make this assertion.
10:38:48 <halogenandtoast> I tried something like this: https://github.com/halogenandtoast/ArkhamHorrorLCG/blob/main/src/Arkham/Types/Classes.hs#L52-L53, but that constraint is still meaningless and results in Could not deduce (IsAsset (Elem AssetId))
10:38:51 <monochrom> Hrm, :script is weird
10:39:20 <halogenandtoast> Am I screwed or is there someway to utilize polymorphism to allow me to check this.
10:39:40 <Aruro> ok success! :) ty guys
10:39:46 <monochrom> I'm now pretty sure :script has a different purpose.
10:39:47 <Aruro> there were some tabs in file
10:40:59 <maerwald> I'm guessing his file does not have a module line
10:41:09 <maerwald> then :load will be confused
10:41:45 <Aruro> it does
10:42:01 <Aruro> simple import Graphics.Implicit and output using main = writeSTL...
10:42:08 <monochrom> No, :load is perfectly happy with "main = putStrLn "hi"" without declaring a module.
10:42:26 <Aruro> aa, sorry it does not have module line
10:42:27 <Aruro> yes
10:42:35 <maerwald> Aruro: do you have "module Main ...where"?
10:42:36 <Aruro> only import and main
10:42:37 <maerwald> ...
10:42:43 <Aruro> no
10:43:01 <Aruro> import Graphics.Implicit
10:43:01 <Aruro> out = union [ rect3R 0 (0,0,0) (20,20,20), translate (20,20,20) (sphere 15)]
10:43:01 <Aruro> main = writeSTL 1 "test.stl" out
10:43:11 <Aruro> this is script
10:46:01 <Aruro> thank you for help guys, all works now, with v2-repl thing
10:47:04 <maerwald> monochrom: I can reproduce the issue, there's also one about it on the issue tracker
10:47:07 <maerwald> but can't find it
10:47:18 <monochrom> The meaning of :script is this: Instead of entering lines by hand, it enters lines from file for you. Every rule about entering lines by hand applies.
10:48:09 <monochrom> In particular, you cannot split "f x = x" into two lines "f x =" "x", for example.
10:48:33 <monochrom> You cannot split your block comment "{- comment -}" into two lines, for example.
10:48:54 <monochrom> Any individual line that would be rejected by ghci prompt is also rejected by :script
10:49:05 <maerwald> https://github.com/haskell/cabal/issues/5665
10:49:09 <maerwald> there it is
10:49:12 <monochrom> It really is for, shall we say, "replay command history"
10:49:29 <maerwald> cabal is violating the haskell standard there
10:49:56 <monochrom> Is it still true of cabal-install 3.0?
10:49:59 <maerwald> yes
10:51:44 <maerwald> Aruro: so easiest way is to add "module Main where" and then use :load
10:52:26 <monochrom> Oh! I see now.  I stopped after ":load h.hs" finished.  I did not actually test that my main exists.
10:53:28 <monochrom> I should have paid attention to how the prompt remainded "Prelude>" and did not change to "*Main>"
10:54:09 <maerwald> very counter intuitive
10:54:49 <monochrom> How did cabal-install actually manage this?  It's a fundamentally GHC territory...
10:55:22 <maerwald> yeah, it work in plain ghci
10:57:26 <monochrom> I have a feeling it has to do with -hide-all-packages
10:57:50 * hackage language-dickinson 1.0.0.1 - A language for generative literature  https://hackage.haskell.org/package/language-dickinson-1.0.0.1 (vmchale)
11:03:30 <Aruro> maerwald: ty
11:12:13 <xsperry> with scalpel web scraping library is it possible to get an actual error message that hints what went wrong? all the functions I found return Nothing on error. https://hackage.haskell.org/package/scalpel-0.6.2/docs/Text-HTML-Scalpel.html#g:7
11:16:55 <monochrom> maerwald: Found it.  Consider: ghci -this-unit-id foo  (or replace foo by any made-up package name)
11:17:32 <monochrom> OK where is the github issue again? :)
11:17:45 <monochrom> found it
11:17:57 <maerwald> it's a ghc bug then?
11:18:01 <monochrom> OK where did I misplace my github password :)
11:18:26 <dmwit> monochrom: I got you: hunter2
11:19:02 <monochrom> Can't say bug. Perhaps very subtle semantics of -this-unit-id and "cabal repl" without package (ie with fake-package) runs into a corner case.
11:28:24 <fog> i get strange behaviour if i try to rewrite the type of foldrM
11:28:29 <fog> https://github.com/fog-hs/streaming-binary-files-take2/blob/master/Stream/ListT.hs#L57
11:29:04 <fog> replacing that with this; 
11:29:05 <fog> https://pastebin.com/raw/dkW2BZ2w
11:29:18 <fog> foldrM' :: (StackM t, Monad m) => (a -> b -> m b) -> b -> t m a -> m b
11:29:21 <dminuoso> xsperry: Not from the looks of it.
11:29:38 <fog> foldrM :: (FoldableM t, Monad m) => (a -> m (b -> m b)) -> b -> t m a -> m b
11:29:46 <fog> this version seems wrong^
11:29:54 <fog> but its seemingly more powerful
11:30:00 <fog> i must have written it for a reason
11:30:18 <fog> because when i try and use the more intuitive type foldrM' above, it vreaks the test
11:30:31 <fog> it prevents lazy streaming
11:31:01 <fog> i cant understand whats happening other than somehow that the extra monad wrapper allows it to defer evaluation somehow
11:31:30 <fog> comparing; (a -> b -> m b) 
11:31:32 <fog> to; (a -> m (b -> m b))
11:31:55 <fog> the second one subsumes the first, so seems more general 
11:32:13 <dmwit> a -> m (b -> m b) does not subsume a -> b -> m b.
11:32:39 <dmwit> If they were different monads, then you could specialize one to Identity, and your subsumption claim would be true.
11:32:56 <dmwit> But since they are the same monad, any monad with a strict bind makes these types different.
11:33:15 <fog> oh! that sounds like it could be an issue 
11:33:25 <fog> maybe even *the* issue
11:33:51 <nil> dmwit: why a strict bind?
11:34:45 <dmwit> Because to do anything with the b -> m b inside, you must use bind.
11:35:00 <dmwit> Whereas if you just have your hands on a b -> m b in the first place, you do not.
11:35:37 <fog> and i guess its this "having to do bind" that kind of shields them from being evaluated? allowing the more lazy functionality?
11:36:23 <fog> anyway, this seems like a problem, my foldrM has a confusing type
11:36:49 <fog> is it actually more correct with this extra monadic partial application business?
11:38:00 <fog> like, im basically just making something with a type *similar* to that of foldr
11:38:12 <fog> i have no idea what the correct type for the monadic varian of foldr should be
11:38:32 <fog> and it seems depending on this issue, i have 2 different versions with totally different functionalities
11:38:47 <fog> i cant see anything that unifies both
11:39:13 <dmwit> Unpopular opinion: screw the types. Work out what you want the behavior to be. Then make it do that.
11:39:15 <fog> so now im left with something new, or just 2 types of foldr
11:39:26 <fog> its more of a naming issue at this point
11:39:34 <fog> i feel bad to cally them foldrM
11:39:40 <monochrom> maerwald: Here is the complete flow.  When "cabal repl" without package, cabal-install goes to tempdir and creates a fake-package so it still has a package to work on.  This package is a library package.  When cabal repl calls ghci for a library package, it tells ghci -this-unit-id <packagename>.  I don't know the semantics of that, but I reckon it is at least important when building library binary.  -this-unit-id will cause ghci the strange behaviour 
11:39:40 <monochrom> we saw when :load any file that doesn't declare "module".
11:39:43 <fog> since i cant really decide which of them is more like foldr
11:40:30 <fog> certainly i dont want it to break the lazy evaluation like the (a -> b -> m b) version seems to
11:41:19 <monochrom> I think for now we can go on our limbs and propose it's a -this-unit-id bug. ghci should fill in "module Main(main)" where there is no "module", let's say all the time.
11:41:22 <fog> foldrMDefault :: (GetM t,Monad m) => (a -> m (b -> m b)) -> b -> t m a -> m b
11:41:24 <fog> foldrMDefault f b xs = getM xs >>= maybe (return b) (\(x,xs)->f x >>= \g -> foldrMDefault f b xs >>= g) 
11:41:46 <fog> vs
11:41:48 <fog> foldrM' :: (StackM t, Monad m) => (a -> b -> m b) -> b -> t m a -> m b
11:41:53 <fog> foldrM' f b xs = getM xs >>= maybe (return b) (\(x,xs)->f x =<< (foldrM' f b xs)) 
11:42:35 <fog> oh, the StackM constraint is excessive 
11:42:56 <monochrom> I believe that fake-package should stay as a library package because it's the safer bet when you don't know what the user is up to.
11:51:28 <monochrom> Or maybe cabal-install can special-case repl to not give -this-unit-id at all.  Afterall it is only important when building binaries.
11:52:21 <ja> i am trying to calculate the bounding box of the tree produced by uniqueXLayout here: https://hackage.haskell.org/package/diagrams-contrib-1.3.0.8/docs/src/Diagrams-TwoD-Layout-Tree.html
11:53:10 <ja> i was thinking of walking the tree produced and using the Max monoid or something
11:53:47 <ja> since the algorithm tries to minimize space usage, i guess that must be necessary
11:54:00 <monochrom> OK posted my comment!
11:54:06 <ja> but since i don't really understand how the algorithm works, i thought i'd ask here
11:55:07 <ja> if one wants to find both the min and the max in a traversible/foldable, i shouldn't need to walk it twice. how to do that? effectively use to monoids at once?
11:55:40 <ja> *two
11:57:16 <monochrom> Perhaps define a type MinMax = Ctor Int Int, and its Monoid instance (or Semigroup?) that does min on the 1st Int, max on the 2nd Int.
11:57:54 <ja> oh, i didn't realize that would be a monoid/semigroup too. thanks!
11:58:24 <ja> so i guess in general product types of monoids are also monoids?
11:58:33 <merijn> ja: Data.Semigroup already has them, btw :p
11:58:37 <merijn> ja: Yes
11:59:27 <ja> awesome... i should get used to asking in here more... just the rubber ducking makes things clearer too... don't know how to feel about that :O
12:01:13 <monochrom> But Data.Semigroup's are separate Min and Max.
12:01:48 <merijn> monochrom: Add a tuple, done?
12:01:59 <monochrom> Oh! Forgot that.
12:02:06 <merijn> "foldMap (\x -> (Min x, Max x))"
12:02:44 <merijn> Well, I guess you need "\x -> Just (Min x, Max x)" since you need a Monoid for foldMap
12:03:35 <monochrom> ArgMin and ArgMax are neat, too.
12:03:44 <monochrom> wish I had that in C.
12:05:41 <hseg> diagnosing quickcheck testcase failure, got an exception thrown with unusable callstack info. how do i extract the specific input that made the case crash?
12:06:55 <hseg> eg have the idea of replacing the predicate by a const true predicate, then use verboseCheck with the right seed to force quickCheck to spit out the input
12:14:57 <bergsans> hello, perhaps this beginner reflection on haskell might be of interest: https://herebeseaswines.net/essays/2020-the-stillness-of-haskell-code
12:17:09 <dminuoso> bergsans: Here's some smell: renderCamShot cs = sequence_ [drawShot c | c <- cs]
12:17:16 <dminuoso> That should read `traverse_ drawShot cs` :)
12:17:35 <dminuoso> (Generally, whenever you use sequence, chances are you should have been using traverse instead)
12:17:52 <bergsans> dminuoso: thanks! I did not know that!!
12:19:42 <frdg>  I have a list of json objects that look like the first line in the
12:19:42 <frdg>       paste. I want to make a function that is a `Object -> Maybe
12:19:42 <frdg>       WeatherObj`. What aeson functions should I be looking at using to
12:19:42 <frdg>       achieve this?
12:20:05 <frdg> geez that didnt go well hold on
12:20:30 <ja> hseg: i don't know about quickcheck, sorry, but it is weird it doesn't catch the exception. i think hedgehog does, and then you would be able to see annotated values... i am not trying to discourage you from using quickcheck, just musing here
12:20:47 <hseg> using quickcheck through tasty
12:21:07 <hseg> but yeah, too deep here to bother trying to convert
12:21:49 <ja> with hedgehog, maybe it only works because they make you use a function in IO?
12:21:57 <hseg> dunno
12:22:16 <hseg> :facepalm: of course i was getting negative exponent exceptions
12:22:17 <frdg> I have a list of json objects that look like the first line in the paste. I want to make a function that goes from `Object -> Maybe WeatherObj` that I can map to this list. What aeson functions should I be looking at using to achieve this? https://dpaste.org/a2v5
12:22:44 <hseg> explicitly wrote act (Exp e) r = r ^ e
12:22:56 <hseg> and e can of course be negative
12:23:02 <dminuoso> frdg: decode
12:23:17 <hseg>  a shame i didn't get better call stacks though
12:23:26 <hseg> would've made this easier
12:23:39 <evanjs> sooo somebody in #nixos brought up an interesting bit on hoogle -- it seems to provide access to the entire filesystem, and I am wondering if that's due to the nature of the [systemd] service definition, or an implementation detail of hoogle itself
12:23:43 <dminuoso> frdg: (There is an instance `FromJSON Value`)
12:24:25 <evanjs> here is the service definition in the NixOS module https://github.com/NixOS/nixpkgs/blob/5aa6f9018842f389d47378000d403858a4d7c195/nixos/modules/services/development/hoogle.nix#L56
12:24:53 <frdg> dminuoso: looking at the type sig of decode Im not sure how I am supposed to specify that I want to decode into WeatherObj's. The list that I have is of type [Object]. 
12:25:19 <bergsans> dminuoso: updated after you suggestion! thank you for sharing knowledge! 
12:25:43 <evanjs> in short: <hoogle-ip>:<hoogle-port>/file/xxx lets you view just about anything
12:29:03 <evanjs> also not 100% certain if this is the best place to ask 😃 wanted to at least ask here before I open an issue in the repo
12:29:21 <evanjs> Assuming it's not a project issue, and that I'm just using it wrong, like usual 😝
12:30:45 <dminuoso> evanjs: Try #haskell-infrastructure
12:30:58 <dminuoso> Maybe a query would be more suitable, since this could be security relevant
12:33:35 <dminuoso> definitely dont open an issue in the repo
12:33:46 <dminuoso> Try contacting the maintainer by email if need be.
12:36:47 <evanjs> oh boy.  yeah, I see "file not found" on the main hoogle instance when I try the same thing
12:36:52 <evanjs> thanks dminuoso, will do
12:37:28 <ja> evanjs: but if you see file not found on the main instance, that's a good thing no? since it means it may just be a nixos config issue
12:38:14 <dminuoso> That is, if you think this could be security relevant, you should be careful not to publically announce it on issue trackers, as if the time between reporting and closing the bug is too large, secrets could be exposed.
12:39:10 <ddellacosta> is there a nicer way to compose some lens operations like ((count %~ succ) . (url .~ "https://duckduckgo.com")) ?
12:40:18 <evanjs> right right yeah I'm familiar with that concept
12:40:32 <evanjs> controversy between bug bounties and blah blah blah
12:40:56 <evanjs> ja: yeah I can get both access denied (when I try a dir) and file not found (when I hit a non-existent file)
12:41:02 <evanjs> locally, at least
12:41:03 <dminuoso> But like I said, getting the attention of someone in #haskell-infrastructure is likely the easiest way to get an idea.
12:41:11 <evanjs> yeah, posted there 👍
12:41:22 <evanjs> s/posted/commented/, bah
12:42:36 * ja can't find any pages on hoogle.haskell.org that do requests that matches the filter "file"
12:42:40 <frdg> How can I get a string into a lazy bytestring? I am having trouble using pack without getting Couldn't match type ‘Char’ with `‘GHC.Word.Word8’`
12:43:13 <dminuoso> frdg: You need to encode it first.
12:43:15 <evanjs> ja: It might only be with the local flag?
12:43:24 <dminuoso> frdg: Go through Data.Text.Encoding
12:43:27 <dminuoso> for instance
12:43:35 <frdg> ok thank you
12:43:49 <dminuoso> frdg: Also, why Word8? Are you using Data.ByteString.Char8?
12:44:39 <merijn> frdg: The correct way to do it is to convert to Text and then encode
12:44:39 <evanjs> ja: clever discovered it via paths to doc sets that would start with e.g. `/file/nix/store/`.....
12:44:44 <merijn> frdg: Anything else is wrong
12:45:08 <merijn> dminuoso: Word8 is the type of ByteString's pack
12:45:18 <merijn> dminuoso: "pack :: [Word8] -> ByteString"
12:45:28 <dminuoso> merijn: ah
12:46:07 <ja> evanjs: ah ok. seems not to affect hoogle.haskell.org then, great
12:47:25 <evanjs> Well, that might just be links aren't served with that path.  idk.  if the file filter is still usable then I can see how that could be bad
12:47:43 <evanjs> assuming it lets you grep anything on the fs.  but yeah I don't know
12:48:33 <ja> i think systemd has a few containerization features, but i don't know how widely used they are
12:48:47 <ja> for example, yahb lets you read the whole fs and apparently that is no problem
12:48:56 <ja> % readFile "/proc/cpuinfo"
12:48:57 <yahb> ja: *** Exception: /proc/cpuinfo: openFile: does not exist (No such file or directory)
12:49:32 <ja> % readFile "/proc/self/environ"
12:49:32 <yahb> ja: "LIBRARY_PATH=/srv/sandbox/root/lib/x86_64-linux-gnu/:/srv/sandbox/root/usr/lib/x86_64-linux-gnu/\NULC_INCLUDE_PATH=/srv/sandbox/root/usr/include/:/srv/sandbox/root/usr/include/x86_64-linux-gnu/\NULUSER=xsbot\NULSHLVL=0\NULLD_LIBRARY_PATH=/srv/sandbox/root/lib/x86_64-linux-gnu/:/srv/sandbox/root/usr/lib/x86_64-linux-gnu/\NULHOME=/srv/sandbox/root/data/\NULTMPDIR=/srv/sandbox/root/data/tmp/\NULPATH
12:50:11 <merijn> ja: There's nothing on yahb's machine except yahb, so *if* it gets corrupted it can just be nuked :p
12:54:38 <Cale> evanjs, ja: Do we know what kind of machine hoogle.haskell.org is running on? Perhaps it's a Windows machine, and that's why, e.g. /etc/passwd doesn't exist?
12:55:12 <ja> Cale: curl -Is hoogle.haskell.org says Ubuntu
12:55:18 <Cale> ah, okay
12:55:30 <Cale> Well, that's a good sign that it's not sharing everything then
12:56:20 <ja> that could be a load balancer, or a lie, of course. but i wouldn't expect weird obscurity hacks like that from haskell people :O
13:00:25 <ja> Cale: also, given that evan said it should give "access denied" for directories, you should be able to get "access denied" when requesting "/". unless reading a directory as a file on windows doesn't actually provoke that error ... IIRC windows began with a strict separation of those two concepts, unlike on unix where a directory is technically also a file
13:04:43 <hseg> hrmph. derivingvia is annoyingly weaker than i'd like it to be, for probably Good Reasons
13:08:12 <Cale> aha -- there are some other conditions under which it will serve files directly, but at least the handler for /file paths seems to be guarded by "local", which I suspect might lead back to the commandline flag
13:10:39 <Cale> Yes, that appears to be the case
13:10:47 <Cale> So it's the --local flag which turns that behaviour on.
13:15:16 <fog> does anyone have a principled approach for deriving the type of a monadic version of Foldable?
13:15:26 <fog> well, the type of foldrM,,,
13:27:11 <hseg> any way to get ghc to trace why it thinks a particular superclass instance is necessary?
13:27:55 <hseg> manual computation doesn't yield results
13:28:29 <Cale> fog: Write it and let type inference figure it out?
13:28:48 <Cale> hseg: That kind of thing would be nice
13:29:53 <frdg> for decoding a json object could this function ever work? When I map it to my list of objects I get back a list of nothings. `(decode . LBS.fromStrict . encodeUtf8 . T.pack . show)`
13:30:08 <hseg> https://mgsloan.com/posts/inspecting-haskell-instance-resolution/ suggests as of last year that this doesn't exist
13:31:42 <Cale> frdg: It might help if you JSON encoded the objects on the other side
13:32:24 <Cale> show will typically just give you something which looks like Haskell source code
13:32:28 <hseg> https://gitlab.haskell.org/ghc/ghc/-/issues/15044 suggests -ddump-cs-trace might help
13:32:56 <frdg> ok I'll start working on a ToJSON instance
13:33:01 <Cale> You're converting that to Text and then encoding it as a UTF-8 ByteString, and then attempting to JSON decode it, which... isn't likely to work
13:36:51 <fog> Cale: how do you mean?
13:37:05 <fog> there are many possible implementations and they all have different types
13:37:12 <fog> and they all do different things
13:37:24 <fog> thats why i was asking for a "principled approach"
13:37:46 <fog> as in, how to make decisions between which potential type to choose
13:38:49 <fog> basically, going from regular, to monadic Foldables, means there are some monads to be sprinkled over the type, but where to put them, thats the question
13:38:59 <fog> :t foldr
13:39:01 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
13:39:16 <fog> the first obvious choice would be;
13:39:20 <fog> Foldable t => (a -> b -> m b) -> b -> t a -> b
13:39:32 <fog> but what about having a monadic input b?
13:39:41 <fog> Foldable t => (a -> b -> m b) -> m b -> t a -> b
13:39:59 <fog> and what about another monadic wrapper around the partially applied folding function?
13:40:09 <fog> Foldable t => (a -> m (b -> m b)) -> m b -> t a -> b
13:40:29 <fog> is that inner monad on the folding function now too much ?
13:40:36 <fog> Foldable t => (a -> m (b -> b)) -> m b -> t a -> b
13:40:49 <fog> is there a hierarchy that fits these?
13:40:56 <fog> how can i decide which is best?
13:41:18 <frdg> Cale: by encode on the other side do you mean something different than changing the original function to `(decode . encode)`? because this still give me a list of nothings.
13:41:42 <fog> (in all of the above it should be a Foldablem (t :: (* -> *) -> * -> *) => constraint)
13:41:56 <fog> and also Monad m => t m a 
13:42:04 <ja> oh noooo, i just finished implementing my own hbox layouter, and then i realize that Diagrams.TwoD.Align is working with typeclasses exclusively and i could totally use it :(
13:44:37 <hseg> ok, that gives me a ~200-step derivation. here's hoping...
13:46:16 <hseg> ugh, this derivation is clear as mud
13:47:02 <monochrom> computer-generated steps are usually like that.
13:47:47 <monochrom> every step is correct. the premise is as you gave. the conclusion is what you want. how the hell did it figure out these steps though haha
13:48:34 <monochrom> and we think that deep learning models are a mess.
13:51:30 <fog> are you speaking of genetic lambda codes again?
13:51:50 <monochrom> Neither genetic nor lambda.
13:52:01 <monochrom> To a large extent no code either.
13:52:15 <fog> oh, how is it making proofs then? 
13:52:35 <monochrom> brute-forcing satisfiability and resolution proofs etc?
13:52:37 <fog> anyway, i would love to see what the "next most complex higher order functions" are
13:52:51 <fog> from refactoring large random lambda programs 
13:54:06 <fog> oh right, you mean about the input output mapping. i guess thats an issue of surrogate modeling
13:54:15 <fog> you dont want unexpected long tail distributions
13:54:17 <monochrom> Right? You know that when Battlechess or monochrom is playing Chess and seems to be playing well, they are brute-forcing the game tree, no biology-inspired algorithm is involved at all.
13:54:19 * hackage calamity 0.1.18.0 - A library for writing discord bots in haskell  https://hackage.haskell.org/package/calamity-0.1.18.0 (nitros12)
13:54:52 <fog> wait, your a chess bot?
13:55:22 <fog> no, genetic, is just referring to generating to a sampling proceadure
13:55:33 <monochrom> no genes, no training, no neural network, no tensorflow, no linear regression, no principle eigenvalue.
13:55:35 <fog> its just an order of that brute force approach of enumerating inputs
13:55:46 <monochrom> no sampling. no probability.
13:55:57 <fog> there is always an order
13:56:23 <fog> im certain they dont exhaust the combinatoric complexity, its intractable 
13:56:25 <monochrom> sampling and brute-forcing are mutually anti-theses by definition.
13:56:44 <monochrom> Oh we just cut at "level 5" or something.
13:56:52 <fog> hmm, then i would just contest that they are brute forcing
13:57:10 <monochrom> I said brute-forcing.
13:57:12 <fog> and as soon as you have, which branches to check first, then you are sampling
13:57:24 <fog> well its not brute forcing for chess. there are too many possibilities
13:57:41 <fog> the only way these solvers work well is by not brute forcing
13:58:09 <fog> and, as for surrogate emulation of black boxes, as in "compressed nets"
13:58:36 <fog> its a similar situation. you only *need* the brute force if you want absolute certainty about those tail distributions
13:58:47 <fog> that there is 0 probability of a catastrophe 
13:59:01 <monochrom> I'm done.
13:59:08 <fog> its rare thats necessary 
14:00:12 <fog> well you claim that "black boxes are a mess" sighting brute-forcing as evidence of intractability
14:00:22 <fog> when thats just a bad approach
14:01:07 <fog> there wouldnt be such a large literature on "privacy concerns" of black box models if it wasnt so easy to reverse engineer them
14:01:20 <fog> and for them to leak information about their training data
14:09:37 <dmj`> they're all overfit anyways
14:11:50 <[exa]> :]
14:15:51 <[exa]> fog: btw did you arrive at some reasonable result with the foldable? imho there are pretty easy constraints of minimal stuff that it should be able to do, and another set of easy conversions of the overly specific foldrM's to the more generic ones
14:17:21 <kuribas> Aren't Proxys deprecated now we have TypeApplications?
14:18:23 <[exa]> kuribas: Proxys are a smaller gun
14:18:32 <kuribas> and a larger runtime overhead
14:18:40 <jumper149> kuribas: I personally find TypeApplications confusing in practice and think Proxys are much more readable, when there are many type variables.
14:19:13 <kuribas> would they disappear if I make them strict?
14:19:29 <lyxia> There's Proxy# that has no runtime representation
14:21:11 <monochrom> TypeApplications will be non-confusing when we all agree on a protocol to write our forall's explicitly for all type variables so your users always know the correct order for their @Type
14:21:19 <kuribas> for example f !Proxy x = ...
14:21:56 <monochrom> I think it still won't disappear, but I haven't checked compiled core code.
14:22:47 <lyxia> Also because you have to quantify over type variables explicitly, with typeclasses it can become annoying to use InstanceSigs, whereas proxies actually result in less boilerplate.
14:23:15 <kuribas> monochrom: but since it has only one value, can never be bottom, it could be removed?
14:25:27 <monochrom> I don't know whether the optimizer does that.
14:25:54 <lyxia> kuribas: This is the kind of thing that I wouldn't be certain about off-hand but if you care enough about performance it's easy for yourself enough to check and fix it.
14:26:30 <kuribas> lyxia: well, I doubt it's going to be a significant impact, it just annoys me.
14:30:50 <fog> [exa] no, my library is in dissaray, i have idea about how to specify the type of FoldbleM or TraversableM. i can do various different things that all seem to work in different ways, and none of which are an obvious choice for a class as central as Traversable or Foldable are in the pure setting
14:32:10 <fog> kuribas: no, Proxies are useful, for example, if you want to take the type applications as an argument and pass them into a subfunction. while its possible to do this with AllowAmbiguousTypes and TypeApplications, it can be more readable and convinient to pass the Proxy
14:32:53 <kuribas> I used TypeApplications a few types, and I find them convenient...
14:33:13 <kuribas> but if Proxy is more idiomatic, I'll use that.
14:34:05 <fog> there is also an issue i think with the new GHC, where they put the kinds not nesacarily at the front
14:34:25 <fog> there is then potentially a backwards dependency issue
14:35:29 <fog> but i guess the order the forall variables are defaulted to will normalise after a few years we wont notice
14:36:02 <monochrom> TypeApplications is nicer for some use cases. You don't have to avoid them. Just make an aesthetic judgment and be proud. :)
14:36:19 <fog> [exa] basically Scanner is the only thing i can get to work well - but it needs one of the strager forms of FoldableM to force its evaluation
14:37:15 <fog> and im not sure about keeping that as the actual form of foldrM
14:37:31 <fog> or if to have it as a special function just used for forcing the evaluation of the scanner
14:38:31 <fog> there are kind of more and less lazy versions, one where the it freezes, and the other where it just returns immediately having been so lazy as to completely not even bother evaluating anything 
14:38:54 <fog> i dont know if the more or less lazy versions would make better FoldableM functions
14:39:15 <fog> but the middlingly lazy version is needed to get the scanner to work
14:39:27 <fog> its a bunch of design choices i dont feel qualified to make
14:40:07 <fog> i hardely even understand all of the reasons some of the implementations hang and some just return immediately having done nothing 
14:58:20 * hackage c-storable 0.3 - CStorable class  https://hackage.haskell.org/package/c-storable-0.3 (EvanLaforge)
15:01:49 * hackage commonmark-extensions 0.2.0.0 - Pure Haskell commonmark parser.  https://hackage.haskell.org/package/commonmark-extensions-0.2.0.0 (JohnMacFarlane)
15:02:49 * hackage commonmark-cli 0.1.0.1, commonmark-pandoc 0.2.0.0 (JohnMacFarlane): https://qbin.io/univ-bw-k18d
15:46:58 <koz_> Is the name of the 'unagi-chan' package some kind of obscure reference?
15:50:01 <monochrom> maybe because unagi is Japanese for eel.
16:07:49 <koz_> monochrom: I'm aware of the 'unagi = eel in Japanese' thing. However, I'm not sure what eels have to do with concurrent queues.
16:07:56 <koz_> Which makes me think it's some kind of obscure reference.
16:16:08 <yushyin> at least I don't think there is more meaning to it
16:18:01 <yushyin> -chan is japanese so the author needed to also put a japanese word upfront or so is my guess 
16:21:14 <Axman6> I'm pretty sure the author is japanese, so I'm sure it makes sense. are eels not just queues which accept food and produce poop?
16:23:38 <yushyin> but the pooping part applies to almost? all animals!
16:25:30 <koz_> The author is named Brandon Simmons.
16:25:36 <koz_> A very traditional, Japanese name.
16:25:38 <koz_> Steeped in history.
16:25:59 <Axman6> huh, KI thought Kazu wrote it
16:26:32 <koz_> Not that I can tell.
16:30:17 <hololeap> my library will be named backpfeifengesicht
16:30:45 <monochrom> artistic license to think of a queue as an eel. they're both long anyway.
16:31:14 <monochrom> an eel for a queue. a view for a kill.
16:31:44 <koz_> Half the fun of Haskell is figuring out what obscure reference(s) were used in naming each library.
16:32:19 <monochrom> Now you're going to tell me, that doesn't rhyme, the vowels for eel, queue, view, and kill are all different and unrelated.
16:32:51 <monochrom> the thing is to my Chinese ear they're all closely related
16:33:02 <Axman6> I need to sit down one day and actually write RPG: the library which lets you execute Grenade ML models using Accelerate
16:33:53 <yushyin> koz_: i'm ok with that, mich better than genericlibaryname1 and samegenericlibraryname_but_better/faster/simpler/lighter
16:34:08 <koz_> yushyin: Never said it was a bad thing!
16:34:21 <hololeap> koz_: what's the other half?
16:34:32 <koz_> hololeap: Lifting.
16:34:40 <koz_> Haskell is the most powerful language: all we do is lift.
16:36:16 <hololeap> `lift`ing `wait`s
16:36:34 <koz_> I mean, think about it.
16:36:36 <koz_> fmap? Lifting.
16:36:41 <koz_> pure? Lifting
16:36:43 <koz_> ?
16:36:45 <koz_> liftIO? Lifting.
16:36:53 <koz_> lift method from MonadTrans? Lifting.
16:36:54 <koz_> Etc.
16:37:09 <hololeap> what about extract?
16:37:10 <Axman6> :t lift . fmap fmap fmap lift
16:37:11 <lambdabot> (MonadTrans t1, MonadTrans t2, Monad m1, Monad m2, Functor f) => m1 (f (m2 a)) -> t1 m1 (f (t2 m2 a))
16:37:25 <koz_> hololeap: When was the last time you used a comonad in actual code?
16:37:27 <hololeap> nvm that's just co-lifting
16:37:33 <koz_> That too.
16:37:42 <Rembane> hololeap: Does that mean putting things down again?
16:37:52 <monochrom> aaaaiiiiiieeeeee I have wrote too much C code, I wrote != in Haskell
16:37:54 <koz_> Rembane: lower ~ co-lift.
16:38:10 <hololeap> koz_: whenever i pull a value from a tuple
16:38:24 <Rembane> koz_: Sweet
16:38:49 <koz_> hololeap: You make a valid point. After all, what is lifted must, once again, be lowered.
16:38:52 <koz_> Gravity say so.
16:39:21 <Axman6> monochrom: recite the monad laws tens time over to atone
16:39:56 <Axman6> the only thin I lower is the (absolute) unit in main :: 
16:40:01 <Axman6> IO ()
16:41:03 <koz_> Axman6: How does one recite 'm >>= (\x -> k x >>= h) = (m >>= k) >>= h'>
16:41:05 <koz_> ?*
16:41:05 <lambdabot> Maybe you meant: v @ ? .
16:41:52 <koz_> 'Emm bind ecks to kay ecks bind eych equals emm bind kay bind eych'?
16:42:06 <monochrom> Is it OK if I play a recording? I already have my monad lecture recorded for my students, it has monad laws.
16:42:07 <Axman6> koz_: when you know how, you will have achieved true kmettdom
16:42:19 <hololeap> associativity?
16:42:35 <monochrom> Or even better, if I recited it to 20 students, does that count as 20 times? >:)
16:42:46 <koz_> monochrom: I assume not individually?
16:42:48 <koz_> (yet?)
16:43:08 <monochrom> Naw.
16:43:23 <Axman6> monochrom: preaching the good word definitely counts
16:43:45 <hpc> preaching the good Word64?
16:43:55 <monochrom> The logic is this. If I waste one minute during lecture, and the audience is 20 people, then I'm wasting 20 minutes.
16:44:25 <monochrom> Therefore, if I explain the monad law to an audience of 20 people, I'm explaining it 20 times, too.
16:44:49 <koz_> So is this IRL user time versus system time?
16:45:02 <monochrom> totally user time
16:45:22 <monochrom> "wall-clock time 1 minute, user time 20 minutes"
16:46:10 <monochrom> On that note I once received a TAship application that indicated, on the field "how many hours do you want to work for?", "99999" or something. Maybe one more 9.
16:46:31 <monochrom> The TAship is only 4 months.
16:46:53 <Axman6> so like 2880 hours in total
16:47:07 <monochrom> Suddenly I realized: How many hours are there in 4 months? If they can work 99999 hours in 4 months, HOW MANY CORES DO THEY THINK THEY HAVE?!!
16:47:17 <Rembane> They gotta be very effective then, to squeeze in so many hours 
16:48:03 <Axman6> monochrom: 34.72, assuming amdahl's law doesn't get in the way
16:48:38 <koz_> Axman6: They're a ThreadRipper!
16:49:45 <Axman6> AyyMD4lyf
16:51:31 <Cale> Maybe they were trying to answer the question of how many hours they want to work in the remainder of their lifetime
16:52:15 <Axman6> that's only eleven and a half years of 24h/d work
16:52:33 <Cale> > 99999 / (8*5*52)
16:52:35 <lambdabot>  48.07644230769231
16:53:02 <Axman6> 42? pfft, what pleb country are you living in. 48
16:53:08 <Axman6> uh, 52*
16:53:59 <Cale> This is a TA position we're talking about. No benefits, no time off!
16:54:29 <Rembane> In the distant future there is only work
16:54:57 <Axman6> ah of course
16:55:15 <monochrom> No, in the distant future there is no work. Entropy death and universal equilibrium and all.
16:56:02 <monochrom> On the bright side, there is no work. :)
16:56:13 <Rembane> Yay! In the distant future there is only rave! 
16:56:16 <Rembane> Untz untz untz etc.
16:56:22 <monochrom> Although, I doubt that it will actually be bright haha.
16:57:15 <Rembane> Night forest rave it is then. :)
17:11:49 <caseof> Hey all!
17:12:00 <caseof> Is there a better way to write something like: https://pastebin.com/zhbpKb9F ?
17:13:52 <suzu_> looks fine to me
17:13:58 <suzu_> not certain what an improvement on it would look like
17:18:55 <Axman6> looks related to MonadBase things
17:36:11 <justsomeguy> What does the "forall a ." in type signatures such as "maximum :: forall a . Ord a => t a -> a" mean? I thought that there was an implicit forall preceding every type signature.
17:37:17 <justsomeguy> Oh, I should have checked the Haskell report, first.
17:39:20 <suzu_> it means you can 'reuse' that bound type 'a' in the function body
17:44:05 <justsomeguy> Can't you already do that without the "forall" keyword? Are the type signatures   "forall a . Ord a => t a -> a"   and    "Ord a => t a -> a"   effectively the same?
17:45:40 <justsomeguy> My assumption is that in "Ord a => t a -> a", all occurrences of "a" are constrained to "Ord".
17:47:37 <koz_> justsomeguy: Yeah, the difference is with ScopedTypeVariables.
17:48:04 <koz_> If you don't have an explicit forall like that, any references to 'a' as a type in the body of 'maximum' are going to be a _different_ type.
17:48:12 <koz_> (or rather, GHC will not assume they're the same)
17:48:26 <koz_> Whereas with an explicit forall, we 'bind' the type variable.
17:48:27 <dmwit> justsomeguy: There are also types for which dropping the forall is not the same. For example, `(forall r. (a -> r) -> r) -> a` cannot be written without any foralls in a way that means the same thing.
17:48:48 <dmwit> I guess a simpler example is `(forall r. r) -> a`. =P
17:49:25 <koz_> dmwit: Or, famously, (forall s . ST s a) -> a
17:49:44 <dmwit> I think runCont is pretty famous, too. ^_^
17:51:47 <ski> @type runCont
17:51:48 <lambdabot> Cont r a -> (a -> r) -> r
17:52:02 <dmwit> Okay. It's not runCont. Whoops.
17:52:28 <dmwit> caseof: I think I would write it without the `t` bit, and leave the caller to do the partial application.
17:52:49 <justsomeguy> So, is the "forall
17:53:12 <justsomeguy> " keyword something I wouldn't see outside of code that doesn't use language extensions that change how quantification of type variables works?
17:53:17 <dmwit> caseof: So: `passEnvIO :: (IO a -> IO b) -> ReaderT env IO a -> ReaderT env IO b`. Once you do that, I think it's just `passEnvIO = mapReaderT`?
17:53:35 <dmwit> justsomeguy: Yes, forall is only available with extensions.
17:53:46 <dmwit> It is not part of Haskell 2010.
17:54:02 <ski> justsomeguy : "I thought that there was an implicit forall preceding every type signature." -- not preceding every one. e.g. not for `not :: Bool -> Bool' or `chr :: Int -> Char'
17:54:17 <koz_> justsomeguy: You need either ScopedTypeVariables or RankNTypes on, yeah.
17:54:25 <dmwit> (unless you're okay with trivial forall's that don't bind any variables)
17:54:48 <ski> justsomeguy : `forall a. Ord a => t a -> a' and `Ord a => t a -> a' are not type signatures. they're types
17:55:26 <justsomeguy> Ok, that's actually pretty straight-forward, koz_
17:55:35 <ski> or `ExplicitForall'
17:55:53 <ski> (er, `ExplicitForAll')
17:56:22 <justsomeguy> ski: Why do you say those are types rather than type signatures? Is it because I omited the function name and double colon? Or am I about to have some sort of misconceptions cleared up...?
17:56:43 <ski> (that doesn't enable any extension that does something, apart from being able to explicitly state the `forall's that you'd other have implicitly)
17:57:01 <ski> justsomeguy : a type signature has a `::' in it
17:57:25 <justsomeguy> So, it was a syntax issue. I'll be sure to include the "::" next time.
17:57:25 <ski> (and they need not be functions)
17:57:42 <caseof> dmwit : thanks. I'm not sure how I would do that since I don't really control t. I'll think about it.
17:58:10 <ski> `Int -> [a] -> [a]' does not mean `forall a. Int -> [a] -> [a]'
17:58:36 <ski> but `foo :: Int -> [a] -> [a]' does mean `foo :: forall a. Int -> [a] -> [a]' (in most contexts, there are a few exceptions)
17:58:40 <ski> justsomeguy ^
17:59:39 <justsomeguy> Good to know. Thank you ski.
17:59:40 <ski> anyway, omitting the `forall' in the former is merely a convenience issues. the language could have required all `forall's to be explicit
17:59:49 * hackage hall-symbols 0.1.0.3 - Symmetry operations generater of Hall Symbols  https://hackage.haskell.org/package/hall-symbols-0.1.0.3 (narumij)
18:01:36 <ski> justsomeguy : exceptions are : if that `foo :: ...' is a method signature in a `class' declaration, or a field signature, using record syntax when declaring a `data' type or `newtype'. (also, if you use `ScopedTypeVariables')
18:02:23 <ski> (in each case, a type variable like `a' may already be in scope, in a scope surrounding the signature. and then there would be no implicit `forall a.' inserted just after the `::' in the signature)
18:03:24 <ski> (hm, also method signatures in `instance' declarations, if you enable `InstanceSigs')
18:03:47 <ski> justsomeguy : i'm not sure whether you've seen `class' declarations, or record syntax, yet ?
18:04:11 <justsomeguy> I have.
18:04:16 <ski> @src Eq
18:04:16 <lambdabot> class Eq a where
18:04:16 <lambdabot>     (==), (/=) :: a -> a -> Bool
18:05:22 <justsomeguy> ....oh, you can have multiple function names separated with a comma that have the same signature, that's new to me. 
18:05:47 <justsomeguy> (Unless it meta-syntax, or typographical.)
18:06:06 <ski> that signature does not mean `(==),(/=) :: forall a. a -> a -> Bool' (those methods are monomorphic, not polymorphic). `a' is already in scope, in the `class' head. `a' is referring to whatever type we're going to make an instance of the class. the `instance' declaration will determine what `a' will be, in the signature for `(==)' and `(/=)'
18:06:16 <ski> yes, you can
18:06:27 <ski> and again, they don't have to be functions
18:06:33 <ski> @src Bounded
18:06:33 <lambdabot> class Bounded a where
18:06:33 <lambdabot>     minBound, maxBound :: a
18:07:19 <justsomeguy> Ohh
18:08:56 <ski> @let primes :: [Integer]; primes = sieve [2 ..] where sieve (p:ns) = p : sieve [n | n <- ns,n `mod` p /= 0]
18:08:58 <lambdabot>  Defined.
18:09:02 <ski> > take 25 primes
18:09:04 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97]
18:09:13 <ski> `primes' is not a function
18:10:29 <dmwit> caseof: The caller will just pass in `foo . ($t)` instead of passing in `foo`.
18:11:20 <dmwit> caseof: I can think of maybe one or two rare cases where this wouldn't be possible. I'd be interested to see how you're using `passEnvIO` to see if you are really in one of those cases.
18:13:52 <hololeap> just out of curiosity: is it impossible to have a Bimonad, or is it just not very useful?
18:14:20 <infinisil> hololeap: That might just be Arrow
18:14:49 <hololeap> i don't even know what Bimonad would mean, except that it follows from Bifunctor and Biapplicative
18:15:20 <koz_> hololeap: https://stackoverflow.com/a/13568897/2629787
18:16:05 <hololeap> koz_: thanks, guess i should have searched first
18:21:00 <ski> @type let passEnvIO :: ((t -> IO a) -> IO a) -> (t -> ReaderT rho IO a) -> ReaderT rho IO a; passEnvIO f k = ReaderT (\rho -> f (\t -> runReaderT (k t) rho)) in passEnvIO
18:21:01 <lambdabot> ((t -> IO a) -> IO a) -> (t -> ReaderT rho IO a) -> ReaderT rho IO a
18:22:39 <dmwit> ski: FWIW the original let a change to b
18:22:48 <dmwit> I think this one does, too, with the right type signature?
18:24:20 <ski> ah, yes. i did notice that, at first
18:24:21 <ski> @type let passEnvIO :: ((t -> IO a) -> IO b) -> (t -> ReaderT rho IO a) -> ReaderT rho IO b; passEnvIO f k = ReaderT (\rho -> f (\t -> runReaderT (k t) rho)) in passEnvIO
18:24:22 <lambdabot> ((t -> IO a) -> IO b) -> (t -> ReaderT rho IO a) -> ReaderT rho IO b
18:25:04 <ski> my first thought was `Control.Monad.Morph.hoist' .. but then i recalled there's no `ContT o' instance of `MFunctor' ..
18:25:52 <ski> (and `ContT o' isn't indexed, hence i started by merging `a' and `b'. then forgot to change back, when i tried the more direct approach)
18:29:20 * hackage sweet-egison 0.1.0.2 - Shallow embedding implementation of non-linear pattern matching  https://hackage.haskell.org/package/sweet-egison-0.1.0.2 (coord_e)
18:33:43 <ski> @type let passEnvIO :: ((t -> IO a) -> IO b) -> (t -> ReaderT rho IO a) -> ReaderT rho IO b; passEnvIO = (ReaderT .) . (. (flip . (runReaderT .))) . (.) in passEnvIO
18:33:45 <lambdabot> ((t -> IO a) -> IO b) -> (t -> ReaderT rho IO a) -> ReaderT rho IO b
18:42:45 <ski> @let infixr 0 ~>; (~>) :: (a1 -> a0) -> (b0 -> b1) -> ((a0 -> b0) -> (a1 -> b1)); (f ~> g) h = g . h . f; arg :: (a1 -> a0) -> ((a0 -> b) -> (a1 -> b)); arg f = f ~> id; res :: (b0 -> b1) -> ((a -> b0) -> (a -> b1)); res g = id ~> g
18:42:46 <lambdabot>  Defined.
18:43:06 <ski> @type let passEnvIO :: ((t -> IO a) -> IO b) -> (t -> ReaderT rho IO a) -> ReaderT rho IO b; passEnvIO = res ((flip . res runReaderT) ~> ReaderT) (.) in passEnvIO
18:43:07 <lambdabot> ((t -> IO a) -> IO b) -> (t -> ReaderT rho IO a) -> ReaderT rho IO b
18:43:12 <ski> @where SEC
18:43:12 <lambdabot> http://conal.net/blog/posts/semantic-editor-combinators/
18:43:51 <ski> @type let passEnvIO :: ((t -> IO a) -> IO b) -> (t -> ReaderT rho IO a) -> ReaderT rho IO b; passEnvIO = res (res runReaderT >>> flip ~> ReaderT) (.) in passEnvIO
18:43:52 <lambdabot> ((t -> IO a) -> IO b) -> (t -> ReaderT rho IO a) -> ReaderT rho IO b
18:44:03 <ski> @type let passEnvIO :: ((t -> IO a) -> IO b) -> (t -> ReaderT rho IO a) -> ReaderT rho IO b; passEnvIO = res (res runReaderT >>> flip ~> ReaderT) res in passEnvIO
18:44:04 <lambdabot> ((t -> IO a) -> IO b) -> (t -> ReaderT rho IO a) -> ReaderT rho IO b
19:10:05 <liiae> f :: a -> r,    k = f x
19:10:09 <liiae> (\f -> f x) >>= (\k -> \y -> y $ y k) = (\y -> y $ y k)
19:10:25 <liiae> this is Reader Monad or Cont Monad?
19:21:03 <ski> liiae : i guess it looks slightly more like `Cont r' .. but i'm not following the example
19:21:21 <ski> (where did `x' go, e.g. ?)
19:22:11 <ski> (and `k = f x' doesn't seem to fit with the rest)
19:27:30 <liiae> ski: sorry, x should be a concret value like 3
19:27:52 <liiae> ski: that k=f x is just a notation, not real syntax
19:28:34 <ski> it still doesn't seem to fit with the `f' and `k' (and `x'), on the next line
19:29:00 <ski> anyway. in that case i'm still confused about why `3' isn't on the right side of the `='
19:30:27 <liiae> ski: (\y -> y $ y (f 3))
19:30:40 <ski> where did `f' come from ?
19:30:53 <ski> there is no free `f' in scope, on the left side of `='
19:31:59 <ski> if it was `(\y -> y $ y x)', or `(\y -> y $ y 3)' if you prefer, then it would make more sense to me
19:32:16 <liiae> vCPS = \f -> f 3
19:32:17 <ski>   (\f -> f x) >>= (\k -> \y -> y $ y k) = (\y -> y $ y x)  -- that is
19:32:23 <liiae> v9CPS = \x -> \y -> y $ y x
19:32:28 <liiae> v10 = vCPS v9CPS
19:32:29 <ski>   (\f -> f 3) >>= (\k -> \y -> y $ y k) = (\y -> y $ y 3)  -- or this
19:34:03 <liiae> (\k -> \y -> y $ y k) is f
19:34:10 <ski> either of those would fit in with `Cont r' (or `ContT r m' .. well, i guess the latter wouldn't fit with that, unless you're using some `Num (m a)' instance, for some particular `m' and `a')
19:34:59 <ski> it would not quite be `f', in CPS
19:35:10 <liiae> ski: that cont definiton is really twisted, const bind = ma => amb => cb => ma(a => amb(a)(cb))
19:35:41 <ski> (that is, `v10 = vCPS v9CPS' doesn't quite look right)
19:35:52 <liiae> ski: right, it's not right
19:36:17 <liiae> that's not cont
19:36:33 <ski> `const bind = ma => amb => cb => ma(a => amb(a)(cb))' looks right (what language is this ?)
19:36:57 <liiae> ski: js
19:37:09 <ski> mhm
19:37:35 <ski> anyway, it looks like you're doing nqCPS, with `Cont r'
19:37:36 <liiae> bind = \ma -> amb -> cb -> ma (\a -> amb a cb)
19:37:44 <ski> (in the example before, that is)
19:38:21 <ski>   bind = \ma -> \amb -> \cb -> ma (\a -> amb a cb)  -- this
19:38:38 <ski>   bind = \ma amb -> \cb -> ma (\a -> (amb a) cb)  -- or this
19:38:46 <ski>   bind = \ma amb cb -> ma (\a -> amb a cb)  -- or this
19:39:24 <liiae> ski: they don't have currying in other languages
19:39:47 <ski> Haskell doesn't "have currying", either
19:39:56 <ski> currying is in your mind, not in the language
19:39:59 <liiae> ski: but this bind definition make no sense to me
19:40:26 <liiae> I have no idea why cont is looks like this
19:40:35 <ski> follow the types
19:40:36 <liiae> twisted and meaningless
19:41:47 <liiae> ski: types can tell me function's meaning?
19:41:58 <monochrom> My http://www.vex.net/~trebla/haskell/cont.xhtml#Cont explains two ways how to code up Cont's >>=
19:42:00 <liiae> id and (+1) both have a -> a
19:42:20 <liiae> Num a => a -> a
19:42:38 <liiae> but id and (+1) don't have the same behavior, 
19:43:11 <liiae> types can't tell me what id or (+1) are used to, what's their meaning
19:43:53 <dolio> (+1) doesn't have type `a -> a`.
19:44:10 <liiae> dolio: Num a => a -> a?
19:44:17 <liiae> :t (+1)
19:44:18 <lambdabot> Num a => a -> a
19:44:19 <dolio> That's not `a -> a`
19:44:43 <monochrom> This is really pointless bickering, besides being wrong.
19:45:06 <liiae> :t (*3)
19:45:07 <lambdabot> Num a => a -> a
19:45:24 <ski> `(+ 1)' has type `a -> a', if `a' is a instance of `Num'
19:45:31 <liiae> (+1) and (*3) have the same type, what the types tell you about the meaning of (+1) and (*3)
19:46:10 <ski> (`reverse' also has type `String -> String')
19:46:37 <ski> liiae : but i think you're following a red herring, atm
19:47:20 <liiae> ski: sorry, I don't understand your metaphor
19:48:21 <ski> "red herring" refers to a clue, or a trail one's investigating, that doesn't actually help, lead somewhere useful
19:49:50 <hololeap> liiae: can you present your original question in a different way? perhaps with some working haksell code?
19:50:10 <berberman> types can help you understand functions with complex context. if we can grab everying from types, we can just write code expressing types.
19:51:20 <liiae> hololeap: bind = \ma -> amb -> cb -> ma (\a -> amb a cb), why its definition looks like this?
19:51:52 <liiae> berberman: you can't get a function from any types 
19:51:56 <hololeap> liiae: where are you getting that from?
19:52:16 <hololeap> so i can look at it myself
19:52:51 <hololeap> and get the context of what's going on
19:52:57 <liiae> hololeap: https://paste.ubuntu.com/p/s9Sh6xTJk9/
19:53:00 <dolio> I imagine when ski said "follow the types," it meant that there is only one type correct way to implement the bind function without doing something like throwing an exception.
19:53:51 <monochrom> Also I think that it also means to use this approach for Cont's bind. Not necessarily for everything under the sun.
19:54:13 <monochrom> So my metaphor would be "blowing strawman out of proportion"
19:54:39 <dolio> It's so constrained that a chat bot can automatically write it, I think.
19:59:13 <hololeap> liiae: i don't recognize the language, but i see `callcc` in there, so my guess is it's Const
19:59:23 <liiae> hololeap: it's js
20:00:05 <liiae> nowaday not everyone has leanred js?
20:00:13 <hololeap> oh... is that from ghcjs or something?
20:00:25 <liiae> hololeap: not from ghcjs
20:02:19 <ski> @djinn-add type Cont o a = (a -> o) -> o
20:02:24 <ski> @djinn Cont o a -> (a -> Cont o b) -> Cont o b
20:02:24 <lambdabot> f a b c = a (\ d -> b d c)
20:04:33 <hololeap> oops! i meant Cont not Const
20:11:52 <ski> @hackage managed
20:11:52 <lambdabot> https://hackage.haskell.org/package/managed
20:12:13 <ski> liiae : ^ see that for an example use of continuation stuff
20:12:51 <ski> (but also see monochrom's article)
20:16:39 <liiae> ski: wow, kan-extensions...
20:20:12 <ski> you don't have to understand that, to use `managed' ..
20:22:17 <liiae> kan-extensions, yoneda lemma, lens, now continuation...
20:23:10 <ski> @quote top.enterprise.industry.analysts
20:23:10 <lambdabot> slava says: Because top enterprise industry analysts recommend that managers need to focus on Agile methodologies, SOA, B2B and Yoneda's lemma in today's rich internet application-driven environment.
20:23:10 <lambdabot>  Don't get left behind by the AJAX craze by missing out on call center outsourcing and Yoneda's lemma!
20:31:43 <liiae> :t (getLine >>=)
20:31:44 <lambdabot> (String -> IO b) -> IO b
20:33:48 <liiae> "However, you can wrap anything of the form ((a -> IO r) -> IO r) in the Managed monad, which translates binds to callbacks for you"
20:34:15 <liiae> but this is already in IO Monad, why we need wrap them into Manage monad?
20:34:25 <liiae> https://hackage.haskell.org/package/managed-1.0.7/docs/Control-Monad-Managed.html
20:36:02 <ski> @type ContT . (>>=)
20:36:04 <lambdabot> Monad m => m a -> ContT r m a
20:36:31 <ski> liiae : to avoid nesting `withX' type functions
20:37:24 <liiae> ski: what it looks like when wrap (getLine >>=) into Manage monad?
20:38:27 <ski> @type let withHandlers :: [(a -> IO o) -> IO o] -> ([a] -> IO o) -> IO o; withHandlers = runContT . sequence . map ContT in withHandlers
20:38:28 <lambdabot> [(a -> IO o) -> IO o] -> ([a] -> IO o) -> IO o
20:39:02 <ski> could be useful, if you have a list of `withX' type functions, each providing a value of type `x', in a local context
20:39:43 <ski> liiae : you'd get `Managed String'
20:40:36 <ski> (but `(getLine >>=)' is basically `lift getLine', going from `IO' to `Managed' .. and so isn't doing anything interesting, on its own)
20:42:33 <ski> instead of
20:42:40 <ski>   withX $ \x ->
20:42:46 <ski>     withY $ \y ->
20:42:50 <koz_> TIL about Managed.
20:42:54 <ski>       withZ $ \z ->
20:42:55 <koz_> That sounds super useful.
20:43:01 <ski>         ..x..y..z..
20:43:04 <ski> you could then use
20:43:12 <c_wraith> is Managed different than Codensity?
20:43:18 <ski>   withHandlers [withX,withY,withZ] $ \[x,y,z] ->
20:43:21 <ski>     ..x..y..z..
20:44:15 <ski> c_wraith : special case, is `Codensity IO'
21:43:49 * hackage streaming-commons 0.2.2.1 - Common lower-level functions needed by various streaming data libraries  https://hackage.haskell.org/package/streaming-commons-0.2.2.1 (MichaelSnoyman)
22:16:54 <hololeap> where can i read up more on the precedence level of showsPrec (and readsPrec). i see that showsPrec for (Maybe Int) adds parentheses when it's above 10
22:21:28 <fog> ski: what is all this madness?
22:23:34 <dolio> hololeap: The precedence level is supposed to correspond to operator precedence, and application is above all the infix levels.
22:24:47 <dolio> So, the highest infix is 9, application is 10, and if the surrounding context is higher than 10, application requires parentheses around it.
22:27:05 <c_wraith> Just for fun, there are contexts that bind more tightly than function application.
22:27:07 <c_wraith> > (Node "hi" []) {rootLabel = "boo"}
22:27:09 <lambdabot>  Node {rootLabel = "boo", subForest = []}
22:27:56 <c_wraith> > rootLabel (Node "hi" []) {rootLabel = "boo"}
22:27:58 <lambdabot>  "boo"
22:28:03 <dolio> Only operators that associate in a particular direction pass their actual precedence, though, because that's the only situation that will correctly parse. So `infixl N` passes N on the left and N+1 on the right, I believe.
22:29:18 <dolio> And application can be treated as left associative, so it is 10 on the left (which is `Just`) and 11 on the right (the argument to `Just`).
22:32:29 <dolio> Yeah, record syntax is tighter, too. Does GHC take that into account?
22:32:50 <dolio> Seems like it'd be confusing to most people, since it's such a rarely used case.
22:37:39 <fog> im still trying to understand the "probability distribution monad"
22:37:46 <fog> and if it is a valid monad transformer
22:38:01 <fog> how could it be?
22:41:28 <fog> i guess a simple way to approach the problem would be to see how it is an Applicative, then how it is a monad, and then how it has a monad transformer, recovering the original version with Identity
22:42:03 <fog> maybe if its not a valid Monad, it could still have values drawn from it using <- with ApplicativeDo 
22:42:43 <fog> i guess join of monad would be something like "a distribution of distributions is a distribution"
22:43:02 <fog> where then they seem much like lists
22:43:22 <fog> so if they are nonempty, then they also would be comonads, as they can be partitioned 
22:43:37 <fog> or, just have return mapped over them...
22:43:50 <fog> which would be the inverse of join
22:44:17 <fog> i guess the difference with lists is on how they are constructed
22:44:34 <fog> like, im not sure if its usual to "add" to distributions
22:44:44 <fog> normally they are completely supported on some domain
22:44:50 <c_wraith> it is a list of (item, weight) pairs
22:45:23 <fog> well, put like that it should be reasonable to cons to them
22:45:43 <c_wraith> assuming it's not normalized internally
22:46:03 <c_wraith> if the weights are normalized, adding another element is more complex than just consing
22:46:06 <fog> oh yeah, that might be a really costly opperation on large distributions
22:46:44 <fog> i think it might be more natural to have them defined over some interval
22:46:53 <fog> that would be specified as a type parameter
22:47:48 <fog> like a lower and upper bound integers indicating a 1d discretization, and then extending that to higher dimensions 
22:48:11 <fog> though possibly you can have distributions over graphs or other things, but the should still have some type level shape
22:48:35 <fog> the point being you might want to monoid two distributions together more than you would want to ++ them
22:50:04 <fog> still confused about how bind is supposed to draw values from it though;
22:50:08 <fog> :t (>>=)
22:50:09 <lambdabot> Monad m => m a -> (a -> m b) -> m b
22:50:48 <fog> seems like the value `a' in (a -> m b) has to be used to create a new distribution...
22:51:03 <fog> im not sure its the kind of monad you want to "work in"
22:51:33 <fog> just for the sake of being able to draw values using the <- syntax, only to then end up "stuck in a distribution"
22:53:18 <fog> i think the blog post that suggested it was doing something like bays rule within the monad, so returning a new distribution
22:53:22 <EvanR> you don't need bounds if the final interface is basically X -> P
22:53:37 <EvanR> user chooses their own values to sample the probability
22:53:42 <fog> i just mean it might be more natural to, and then not bother having ++
22:53:58 <fog> but instead being able to elementWise match up two distributions on the same domain
22:54:04 <fog> like, so you can zipWith 
22:54:14 <EvanR> if X is every possible value, no need to mess with bounds
22:54:26 <EvanR> and consing wouldn't make sense
22:54:35 <fog> like, its common to "support" the distribution with a mixture of gausians as a sort of basis
22:54:44 <fog> then you are "adding up" distributions 
22:54:56 <fog> so they would have to have the same domain
22:55:03 <EvanR> you can add distributions without messing with bounds
22:55:25 <fog> well i dont want users being able to try and mix different dimensional domains
22:55:38 <EvanR> that's why X is X and not Y
22:55:56 <EvanR> i.e. each space is a different type
22:56:11 <fog> oh, i was thinking more like, some subsection of the real line
22:56:21 <fog> or like, the unit hypercube
22:56:30 <EvanR> just use the entire real line
22:56:42 <EvanR> windowing it can go at the very end
22:56:54 <fog> sounds like i couldnt normalise that at all
22:57:03 <EvanR> why
22:57:13 <fog> well because that is deviding by the integral
22:57:29 <fog> if i have it discritised, then an infinite domain would require an infinite sum
22:57:45 <EvanR> indeed we work with infinite data here in haskell
22:58:04 <fog> only when you dont have to use it all!
22:58:07 <EvanR> a gaussian for instance works fine, and it's not windowed
22:58:20 <EvanR> logically, you can't use it all anyway
22:58:32 <EvanR> er, yeah
22:58:53 <fog> ah, so as long as the distribution is a superposition of gausians, then i can normalise it using the analytic integrability of those gaussians 
22:59:19 <fog> still, im guessing thats not always going to be the case
22:59:21 <EvanR> you can come up with any number of other shapes
22:59:41 <EvanR> you can also embed a finite distribution into the real line
22:59:41 <fog> what if i want to "noise up" my distribution with shaped noise that might not have mean 0
22:59:54 <EvanR> then do it
23:00:08 <fog> no i mean, it then might not be analytically integrable 
23:00:36 <fog> as soon as i want to use arbitrary support, that might not be integrable, then its totally messed up
23:01:06 <fog> i mean, it seems like a good idea, to only have analytically integrable support, and to be able to then work with infinite distributions
23:01:22 <fog> but if i just have a biased dice, then this seems like the wrong approach 
23:01:33 <EvanR> the idea was to replace a infinite list of weights with a function from X to P
23:01:49 <EvanR> that supports noise
23:01:52 <fog> so X then is {0,1,2,3,4,5}
23:02:00 <fog> and we are back to a subset
23:02:13 <fog> i think bounds and shape parameters are good
23:02:16 <EvanR> that set doesn't need to be a subset, it's just 6 things
23:02:35 <fog> ok, well what if i have a graph
23:02:44 <EvanR> i'm just suggesting your intuitive complication may be overcomplication
23:02:49 <fog> then if im adding the distributions together, they better be the same graph
23:03:15 <EvanR> X better be... X ?
23:03:18 <fog> i think its the same thing from 2 angles 
23:03:34 <fog> you call it X, i say it has a shape parameter 
23:03:55 <fog> eg. a lengthed list of doubles from 0 to 1
23:04:22 <fog> im just not sure how you would create such an X, without those shape parameters
23:04:27 <EvanR> sure, and at the very end the user is able to take subsets if they wish
23:04:43 <EvanR> but if you hoisted a choice of subset on them from te beginning, they have less options
23:04:53 <fog> i mean, how are they supposed to specify it to begin with, without taking subsets!
23:05:12 <EvanR> that is the key thing i hope to make you knock your noggin about
23:05:26 <EvanR> mathematical objects are cool
23:05:53 <fog> right, i see no real criticism of using type level information to specify the shape of the subset
23:05:56 <EvanR> and subsets is a popular and overcomplicated side show
23:06:26 <EvanR> it blows up many nice properties of what came before the subsets
23:06:36 <fog> so i have Double, that an unbounded representation of the Real line, as long as i dont strey too far from 0
23:07:04 <fog> so now you just want the distribution to be Double -> Weight
23:07:08 <EvanR> imagine if haskell was designed not with "functions" as a basic feature, but with "subfunctions". Every function comes with bounding and shape info, even if it didn't need any
23:07:17 <EvanR> it's so useful, the designer said
23:07:34 <EvanR> implementors struggle keeping the feature working, when many programs don't use it
23:07:40 <fog> but we already have functions
23:07:57 <EvanR> in fact many nice properties of functions don't even work anymore because of the necessity to have the shape and bounds specified
23:08:13 <fog> if your saying distributions are modled best by functions over some type, im not disagreeing, im just saying, that i can have subsets!
23:08:19 <EvanR> spoiler alert, probability distributions are functions
23:08:40 <fog> on types!
23:08:51 <fog> and i want them to match
23:08:58 <fog> based on having the same shape!
23:09:16 <EvanR> if cairo images were required to have bounds and size info, it would overcomplicate the theory. And it turns out the user can window and crop images at any stage, not necessarily the beginning
23:09:54 <EvanR> 'but how would i ever specify a cairo image without first specifying the size of the final canvas'
23:10:04 <fog> yeah, but you dont need to normalise them with an intractable infinite integral
23:10:15 <fog> you *always* work with finite distributions
23:10:21 <EvanR> :|
23:10:30 <fog> unless you force the user to use integrable support
23:10:31 <EvanR> if you wish to believe that
23:11:02 <EvanR> on the contrary you would be forcing them to use discrete distributions
23:11:23 <EvanR> by relying on an integral
23:11:41 <fog> if its a choice between, forcing the user to use integrable support, or have unnormalisable distributions, *or* to have nice intuitive finite shape bounds that allow for type safe monoidal composition
23:12:11 <EvanR> composable distributions
23:12:16 <EvanR> composable pictures
23:12:22 <EvanR> composable functions
23:12:29 <fog> right, i get that types that dont have bounds are also composable
23:12:44 <EvanR> would all be easier without bolting the extra info on from the beginning
23:13:04 <fog> but by giving the bounds your giving them an interface to specify how to differentiate subtypes (if thats not already a reserved term)
23:13:14 <fog> distinguish between*
23:13:24 <EvanR> you want to put that info in the type, and have it change when composing?
23:13:46 <fog> no, i want to specifically prevent type changing
23:13:56 <fog> keep on that domain
23:14:13 <fog> no changing the bounds, no ++ for distributions
23:14:16 <EvanR> so... what is the point of it being in the type?
23:14:36 <fog> to stop the user monoiding them together with bounds that dont match up
23:14:54 <EvanR> that's covered by my 'X' story
23:15:13 <EvanR> X, all reals, Y, first four ints, etc
23:15:19 <fog> if i had type level graph shape, you wouldnt say, why not work with all the different shaped graphs all at the same time, specifying a subset is so restrictive 
23:15:48 <EvanR> i would be saying different graphs have different types for this
23:16:26 <EvanR> i doesn't really serve a purpose to put your info in the type if it can't be used for anything
23:16:29 <fog> yeah, we never differ, except that i acknowledge a concrete interface for specifying this using type parameters indicating shape
23:17:09 <EvanR> what you say makes sense but it's just a big lost opportunity for abstraction
23:17:11 <fog> its used just to specify the type, and then its matched over as usual during type checking 
23:17:20 <EvanR> overly concretized
23:17:44 <EvanR> and no case for why it helps
23:18:04 <fog> it prevents the user working with infinite distributions
23:18:15 <EvanR> why would you want this
23:18:25 <fog> allowing for tractable normalization schemes
23:18:33 <EvanR> :\
23:18:36 <fog> and non-integrable support
23:18:54 <fog> i might not want to just have mixture of gausian support 
23:19:03 <EvanR> don't be silly
23:19:10 <fog> ?
23:19:21 <fog> its a bad support set! 
23:19:52 <fog> it has very poor sparsity/support tradeoff, wavelets are much better (though probably still integrable) 
23:20:25 <EvanR> no one was suggesting a basis for anything
23:20:57 <fog> if i have a lengthed list, and it has too few values to allow for the law of large numbers to kick in, and its filled with random numbers centered at 0, then it wont have converged to having 0 mean
23:21:09 <fog> i might need to integrate it, which i can do, since it has finite length
23:21:30 <fog> if it was infinite, it would have converged and i wouldnt need to normalise it
23:21:38 <fog> but then, if i add two of these together
23:21:47 <EvanR> if you might need to do something, then that is a special case, not the rule
23:21:53 <fog> and then, i need to take a finite truncation so i dont do infinite adding
23:22:03 <fog> then, it will not be normalised on the domain
23:22:20 <EvanR> "i need it to be finite so i can add them", this is haskell, we do this all the time
23:22:20 <fog> and i would have been better having forced the user to work with a specified bounds to begin with
23:22:33 <EvanR> add two infinite things
23:22:44 <fog> no, i need them to be finite so i can normalise them, with distributions, we do this all the time
23:23:11 <EvanR> I'm not sure that's true
23:23:12 <fog> you *were* suggesting a basis
23:23:19 <EvanR> no i wasn't
23:23:35 <fog> you said, if your distribution is a mixture of gausians then its normalisable by the integrability of that support set
23:23:45 <EvanR> no you went there
23:24:17 <fog> well thats the only way you could have an infinite distribution be normalisable 
23:24:34 <fog> if it was a finite composition of integrable support vectors
23:24:42 <fog> aka a basis, or frame
23:24:44 <EvanR> you can normalize finite data all you want without crunching infinite amount of data
23:25:24 <fog> i just cant see how you get finite data without restricting over something infinite using bounds
23:25:29 <fog> ahhh, now we have it
23:25:37 <EvanR> yes, i can't see != proven false
23:25:38 <fog> so, you just use Datatypes, which are always finite
23:25:54 <EvanR> they are not
23:26:00 <fog> whereas i thought you meant the unrestricted real line
23:26:08 <fog> the infinite domain
23:26:27 <EvanR> no you're lost now
23:26:56 <EvanR> i meant use the real line as an example domain, one of many
23:27:09 <fog> you basically had bounds just by using those datatypes which *are* finite
23:27:23 <EvanR> no, no
23:27:39 <fog> anyway, i dont know why you dont like parametric types
23:27:50 <EvanR> you just want bounds, for a specific feature, it's fine. Ignore me
23:27:59 <fog> then they form a similar family 
23:28:09 <fog> im not 
23:28:58 <fog> you cant just act like normalisability of distributions is some esoteric superfluous design feature, its like, the most important thing
23:29:14 <fog> i *can* work with infinite domains, but its *much more difficult*
23:29:27 <fog> id rather restrict the domain than the support
23:29:39 <EvanR> another thing is just having type parameters doesn't give you the feature of iterating over all the domain elements
23:30:17 <fog> yes it needs an Ix instance, for range
23:30:20 <fog> :t range
23:30:21 <lambdabot> Ix a => (a, a) -> [a]
23:30:36 <fog> or a traversable instance
23:31:08 <fog> which is why i want graphs to compose while preserving a traversable instance... but thats a different issue
23:31:09 <EvanR> why don't you work this out then come back with a fully baked plan for honest criticism
23:31:59 <fog> i wasnt presenting a plan for defence of - i was asking about if they are good candidates for Monads
23:32:12 <fog> and was trying to understand their applicative and bind instances
23:32:18 <EvanR> obviously yes
23:32:30 <fog> they just *seem* like lists in this respect
23:32:42 <fog> and infact, thats where i get the idea of *then adding bounds*
23:32:51 <EvanR> it's not the list data structure that is interesting 
23:32:59 <EvanR> it's the non determinism
23:33:06 <EvanR> which also makes sense for probabilities
23:33:13 <fog> well, the (co)monadicity is cool
23:33:25 <fog> and there might be an interesting thing to do with applicative
23:34:21 <fog> i guess thats why arbitrary types are not my strating point, i start from existing known Monads/Containers like graphs and lists
23:34:51 <fog> that their "containing" data, of uniform type, supporting functor instances etc
23:35:02 <fog> then seems ameanable to adding bounds
23:35:04 <EvanR> that is just the wrong way to think about list monad, it's not a container monad
23:35:13 <fog> as opposed to just, having functions on arbitrary types
23:35:25 <EvanR> it's non determinism
23:36:01 <fog> where it does seem restrictive to have done this refinement, and it may be a bad intuition to think that existing instances should be built on, instead of just demanding the constraints
23:36:46 <fog> oh yeah, your right, im forgetting you have to make selections from these things
23:37:14 <fog> im too wrapped up thinking of in terms of a polynomial shaped plot on some cartesian domain 
23:37:51 <fog> and how that can extend to graphs... i forget its only supposed to exist at all for sampling from
23:38:08 <fog> the problem is that i have a particular sampling scheme in mind
23:38:22 <fog> and that this consists of integrating the data
23:38:33 <fog> for which an infinite domain is a complete killer
23:39:09 <fog> i think you might be fine representing it as infinite, but not only is it going to be difficult to normalise, its also going to be difficult to sample from
23:40:07 <cole> can you use Happy with Data.Text instead of String?
23:40:15 <cole> er... Alex
23:40:37 <EvanR> disclaimer, the opinions of fog are their own and do not reflect the views of this network or its sponsors
23:41:12 <fog> all semblance made to public figures is purely coincidental  
23:41:49 <dminuoso> cole: The way I read the documentation, you should be able to feed it a ByteString.
23:41:53 <EvanR> cole: a quick glance at the docs suggests yes. Did you check the docs?
23:42:08 <cole> EvanR: I am ashamed to say that I did, but I am bad at reading
23:42:09 <cole> Thank you.
23:42:11 <dminuoso> (As long as you verify correct UTF8 encoding yourself)
23:43:53 <fog> EvanR: i think in the end you are right, it should be up to the user to ensure their distribution can be sampled from, and the class instantiation mechanism is the correct way to do this. basically in the end we need a sampling function in a distribution class
23:44:43 <fog> a scheme built on sampling by integrating eg over lengthed lists, is then just an instance
23:45:07 <fog> and that the monadicity of these lists should not confuse that abstraction
23:45:21 <fog> good ol' #haskell 
23:46:04 <hyiltiz> read the past 100ish lines of fog & EvanR 's discussion
23:46:26 <EvanR> condolences
23:46:42 <hyiltiz> I would be very much like to see an implementation of probabilistic intefence over graphs etc.
23:47:10 <hyiltiz> so the model shape can change around (maybe with a lens corresponding to them to extract statistics from it)
23:47:27 <hyiltiz> EvanR: LOL! It was truly a wall of text, tho not the boring kind
23:56:02 <fog> the only thing im left wondering then, is about this idea of sampling using the monadic <-
23:56:31 <fog> if the conclusion is that arbitrary types should be sampleable by being an instance
23:56:51 <fog> then it does not seem like they are Monads with bind as the function of this class
23:57:16 <fog> unless, that class is Monad itself, but that just seems wrong 
23:57:37 <fog> ill see if i can find that blog post where i saw the idea 
23:58:43 <fog> https://news.ycombinator.com/item?id=5642891
23:59:47 <fog> they have;
23:59:53 <fog> class (Functor d, Monad d) => Dist d where weighted :: [(a, Weight)] -> d a
