00:12:37 <pikachu3> I'm having a little bit of trouble doing io. If I type `(+) <$> Just 2 <*> Just 3` in ghci, it works and gives me Just 5 as expected. But this code https://pastebin.com/1XkwMX2z gives the following error on line 12 . "No instance for (Num (Maybe Float)) arising from use of +"  Which does not make sense since I'm not trying to directly add Maybe
00:12:37 <pikachu3> Int. I'm using fmap
00:14:26 <pikachu3> Never mind
00:14:29 <pikachu3> I'm dumb
00:14:33 <pikachu3> Saw the mistake
00:14:48 <pikachu3> I'm trying to add Just Just 2 and Just Just 3
00:16:14 <Axman6> that problem also doesn't appear to be related to IO btw :)
00:18:20 <pikachu3> Yeah.. I assumed it was io since it as working in ghci but not while taking input
01:01:43 <dminuoso> Mmm, is there a way to have list comprehensions for sets?
01:01:54 <dminuoso> Without roundtripping through a list manually, of course.
01:02:46 <dminuoso> % :set -XOverloadedLists
01:02:46 <yahb> dminuoso: 
01:03:20 <dminuoso> % [e | Just e <- (S.fromList [Just 'a', Just 'b']) ]
01:03:20 <yahb> dminuoso: ; <interactive>:60:17: error:; * Couldn't match expected type `[Maybe a]' with actual type `S.Set (Maybe Char)'; * In the expression: (S.fromList [Just 'a', Just 'b']); In a stmt of a list comprehension: Just e <- (S.fromList [Just 'a', Just 'b']); In the expression: [e | Just e <- (S.fromList [Just 'a', Just 'b'])]; * Relevant bindings include it :: [a] (bound at <interactive>:6
01:03:24 <dminuoso> :(
01:03:30 <merijn> dminuoso: Witherable?
01:03:48 <merijn> Oh, I guess Set isn't Witherable because it's not Traversable either
01:03:50 <dminuoso> Right.
01:04:02 <dminuoso> I think I need to use optics/lens here.
01:05:18 <dminuoso> Mmm, that might fail for the same reason. :(
01:06:03 <dminuoso>  % toListOf (each . _Just) (S.fromList [Just 'a', Just 'b'])
01:06:05 <dminuoso> % toListOf (each . _Just) (S.fromList [Just 'a', Just 'b'])
01:06:05 <yahb> dminuoso: ; <interactive>:62:1: error:; * No instance for (Each (S.Set (Maybe Char)) (S.Set (Maybe Char)) (Maybe ()) (Maybe ())) arising from a use of `it'; * In the first argument of `print', namely `it'; In a stmt of an interactive GHCi command: print it
01:06:22 <dminuoso> Ah, maybe I can fold it
01:06:25 <dminuoso> % toListOf (folded . _Just) (S.fromList [Just 'a', Just 'b'])
01:06:25 <yahb> dminuoso: "ab"
01:06:42 <dminuoso> I could live with that, I suppose
01:15:42 <merijn> So...that's just foldMap with extra steps? ;)
01:17:25 <dminuoso> merijn: well I already make heavy use of optics anyway. :)
01:17:26 <Taneb> merijn: that's all lens is, when you get down to it
01:20:02 <idhugo> ?src (liftIO)
01:20:02 <lambdabot> Source not found. There are some things that I just don't know.
01:20:14 <idhugo> ?src ($)
01:20:14 <lambdabot> f $ x = f x
01:20:31 <Taneb> idhugo: liftIO is a class method, from the MonadIO typeclass
01:20:48 <Taneb> So different instances will have different definitions
01:21:24 <idhugo> Ah! Thanks Taneb. Do I understand well, when I assume that is the reason why lambdabot will not present its definition, then?
01:21:35 <Taneb> It's one of the reasons
01:21:42 <c_wraith> it's not the only reason.  Lambdabot only has a small database of definitions
01:21:50 <Taneb> ^
01:21:58 <merijn> https://i.imgflip.com/49vhvu.jpg
01:22:21 <idhugo> Humm OK. Thanks for helping.
01:22:36 <merijn> idhugo: Lambdabot doesn't have actual source definitions, it just has a few preprogrammed definitions that may or not be the real oe
01:50:32 <haskell_noob> have the following expression abs ((height l) - (height r)) > 1
01:51:00 <haskell_noob> wondering can it be simplified using ($) and (.)
01:52:08 <merijn> haskell_noob: not really, although the parantheses around "height l" and "height r" are redundant
01:52:32 <merijn> So "(height l - height r) > 1"
01:52:33 <haskell_noob> thanks I thought so but thought I would check
01:52:55 <merijn> haskell_noob: Simple rule of thumb: function application *always* binds more strongly than any operator
01:53:13 <haskell_noob> thanks for that
01:53:23 <xerox_> (abs $ height l - height r) > 1
01:53:52 <sshine> abs (height l - height r) > 1
01:54:46 <haskell_noob> yes xerox thanks
01:55:07 <haskell_noob> wait will that work?
01:55:25 <haskell_noob> since function application higher precedence
01:55:29 <haskell_noob> >
01:55:31 <haskell_noob> ?
01:58:18 <sshine> will what work?
01:59:17 <haskell_noob> (abs $ height l - height r) > 1
02:00:50 <nerdypepper> yes that will haskell_noob 
02:01:17 <haskell_noob> thanks
02:01:40 <haskell_noob> how do I lookup operator precedence?
02:01:52 <nerdypepper> the order of eval would be minus, function application, greater than
02:03:39 <nerdypepper> haskell_noob: one way would be typing ":info <operator>" at ghci's prompt
02:04:01 <nerdypepper> you can see its fixity, precedence and signature
02:04:29 <haskell_noob> thanks
02:04:41 <nerdypepper> multiplication and division have 7, which is higher precedence, and `$` has 0, which is a lower precedence
02:05:48 <solonarv> and function application has higher precedence than *all* operators
02:06:06 <solonarv> % :i > -- example
02:06:06 <yahb> solonarv: ; <interactive>:1:3: error: parse error (possibly incorrect indentation or mismatched brackets)
02:06:10 <solonarv> % :i >
02:06:11 <yahb> solonarv: type Ord :: * -> Constraint; class Eq a => Ord a where; ...; (>) :: a -> a -> Bool; ...; -- Defined in `GHC.Classes'; infix 4 >
02:09:21 <nerdypepper> solonarv: i would say, function application with a whitespace has the highest precedence, whereas function application with `$` has the lowest
02:09:46 <nerdypepper> (unless `$` as an operator has a better name)
02:10:05 <solonarv> $ isn't function application, it is just another operator
02:10:24 <nerdypepper> oh I see
02:11:25 <solonarv> it is special-cased in the type checker, but that has nothing to do with parsing and syntax
02:11:56 <solonarv> (and the special-casing only matters very rarely)
02:15:01 <dminuoso> In attoparsec (Data.Attoparsec.ByteString.Char8), how can I do 2 character lookahead?
02:16:48 <Taneb> dminuoso: does Data.Attoparsec.Combinator.lookAhead help?
02:17:05 <dminuoso> Taneb: It does indeed! Thanks.
02:26:34 <johnnyboy[m]> I don't understand how folding is supposed to require a monoid structure
02:27:07 <johnnyboy[m]> for example, foldr f w [x,y,z] just produces f x (f y (f z w))
02:29:01 <johnnyboy[m]> or x `f` (y `f` (z `f` w)) might be more readable
02:29:07 <HoolaBoola> Wait so the lambdabot responds to ?src ?
02:29:10 <HoolaBoola> ?src <
02:29:11 <lambdabot> x < y = case compare x y of
02:29:11 <lambdabot>           LT -> True
02:29:11 <lambdabot>           _  -> False
02:29:27 <johnnyboy[m]> why is it supposed to be the same as  ((x `f` y) `f` z) `f` w?
02:30:33 <solonarv> the function that meks this obvious is foldMap, not foldr
02:30:43 <solonarv> (they can be implemented in terms of each other)
02:31:24 <HoolaBoola> How is less than function implemented for Ints?
02:31:32 <solonarv> foldr f z xs = appEndo (foldMap (Endo . f) xs) z
02:31:42 <solonarv> foldMap f xs = foldr (<>) mempty xs
02:31:49 <HoolaBoola> ?src compare
02:31:49 <lambdabot> compare x y | x == y    = EQ
02:31:49 <lambdabot>             | x <= y    = LT
02:31:49 <lambdabot>             | otherwise = GT
02:32:04 <solonarv> HoolaBoola: in the end it just uses the appropriate CPU instruction
02:32:11 <HoolaBoola> Ah
02:32:14 <HoolaBoola> True
02:32:39 <HoolaBoola> I keep forgetting that CPUs are optimized for various things
02:33:36 <johnnyboy[m]> solonarv: I do realize that there are situations in which associativity can be exploited for optimization
02:34:25 <solonarv> this isn't "associativity can be exploited for optimization", those are the default definitions of these methods
02:34:42 <solonarv> (with minor differences)
02:35:16 <johnnyboy[m]> for example, if we have 4×2, 2×3, and 3×4 matrices, A, B, and C respectively, then (AB)C takes 72 multiplications of scalars while A(BC) only takes 40 multiplications
02:35:25 <johnnyboy[m]> the result is the same
02:35:38 <solonarv> yes, and this has nothing at all to do with Monoid or Foldable
02:35:59 <johnnyboy[m]> but in this case foldr (*) i [a,b,c] would be more efficient than foldl
02:36:12 <dminuoso> HoolaBoola: As long as the compiler is able to produce native integers that are representable on the machine.
02:37:50 <johnnyboy[m]> solonarv: I understand that monoid operations can be used for folding, but how about the other direction?
02:37:53 <dminuoso> Which is why Integer arithmatic is, in the general case, slower than Int arithmatic.
02:37:59 <johnnyboy[m]> how folding depends on associativity and units?
02:38:15 <dminuoso> (Since Integer might not be representable, and you need to pattern match on it to figure out whether it can be represented with an Int)
02:38:16 <solonarv> johnnyboy[m]: look at the foldr implementation I gave
02:38:41 <johnnyboy[m]> ok, I'll have a look at the definitions
02:46:12 <johnnyboy[m]> solonarv: did you mean foldMap f xs = foldr (<> . f) mempty xs?
02:48:38 <solonarv> oh, yes I did
02:48:44 <solonarv> (need parentheses around <> though)
02:50:43 <sshine> I'm trying to compile a Haskell package inside a Docker image, but first I'm trying to install cabal-install 3.2.0.0; unfortunately building it fails. so far I've got: https://gist.github.com/sshine/644722183b80187b8333eb44b587f95e (minimal example of what fails).
02:51:14 <solonarv> sshine: can you add the error message to the gist?
02:51:42 <sshine> solonarv, just did.
02:52:04 <sshine> solonarv, I'm pretty sure this is me being a Docker retard.
02:52:22 <maerwald> that's not the full log
02:53:46 <sshine> maerwald, sorry. :) updated it to the full output.
02:54:24 <sshine> oh, wait, derp. it says it just succeeded installing Cabal-2.4.0.0 and then that it fails for Cabal-3.2.0.0. >_<
02:55:38 <phadej> don't build cabal-install, download bindist
02:55:38 <maerwald> try -j1
02:55:43 <johnnyboy[m]> solonarv: Thanks! I need to do some induction to see how this works
02:55:49 <phadej> will make you docker image building a lot faster
02:56:00 <sshine> phadej, I looked for a binary distribution but couldn't find it.
02:56:06 <maerwald> sshine: you can use ghcup
02:56:08 <johnnyboy[m]> the foldMap => foldr direction seems pretty non-trivial
02:56:20 <merijn> sshine: They're, like, right on the cabal download page?
02:56:20 <phadej> sshine: https://www.haskell.org/cabal/download.html
03:00:07 <sshine> thanks, I'll create an image by downloading from there.
03:02:03 <phadej> although for ubuntu, I download bindists from hvr-ppa
03:02:06 <phadej> even less "work"
03:02:20 <phadej> https://github.com/phadej/docker-ghc/blob/master/8.6.5/bionic/Dockerfile
03:03:00 <phadej> half of the file is installing stack (which I'll remove from my dockerfiles, as I hardly ever use it)
03:03:12 <sshine> phadej, yeah, I'm trying to go with alpine. :)
03:03:25 <sshine> phadej, otherwise that's what I'd do.
03:04:01 <phadej> alpine is "I like challenges", whatever makes your boat float :)
03:04:17 <sshine> alpine is "I like RUN commands!"
03:04:35 <solonarv> (but as you can see there are bindists for alpine as well)
03:04:45 <sshine> "Who needs a full-fledged Linux distro when I can recreate one in my Dockerfile!"
03:04:53 <sshine> solonarv, yes, this is great.
03:07:22 <sshine> what's the cabal.sig file in the bindist?
03:10:41 <merijn> sshine: cryptographic signature
03:11:11 <merijn> sshine: i.e. did you actually download the actual cabal or a MITM copy. Of course having the signature in the bindist renders it kinda pointless
03:14:07 <merijn> Actually, I guess it's PGP key looking at it, so that's not pointless in the bindist
03:38:52 <sshine> merijn, yeah, I always get a bit puzzled about people distributing checksums along with their files. but a signature is at least connected to something elsewhere. :)
03:39:08 <sshine> merijn, that is, checksums with any cryptographic quality beyond CRC.
03:45:36 <int-e> sshine: it's not completely useless; for example, you can get the checksums from an official source and the other files from a mirror with better bandwidth
03:50:48 <int-e> (I guess this made more sense historically though. If your official source is a CDN, you're always in a PITM scenario.)
03:57:49 <phadej> checksums are usually signed
03:58:03 <phadej> it's faster to sign checksums file, the all files individually
03:58:39 <phadej> e.g. https://downloads.haskell.org/ghc/8.10.1/ SHA256SUMS and SHA256SUMS.sig
03:59:23 <phadej> (then in dockerfile you write you can only check for checksum, as you verified it's correct)
04:00:06 <phadej> ... "off-line"
04:08:39 <Orbstheorem> Hi, is there a sensible way to check for over/underflow when constructed a Bounded Num a type?
04:10:43 <Orbstheorem> More precisely I have a function (Bounded a, Show a) => a -> Bool that checks for overflows by running this:
04:10:52 <Orbstheorem> % :t maybe True (>value) . readMaybe . show $ Bounded @a
04:10:52 <yahb> Orbstheorem: ; <interactive>:1:51: error: Not in scope: type variable `a'
04:11:03 <Orbstheorem> % :t maybe True (>value) . readMaybe . show $ Bounded @Int
04:11:03 <yahb> Orbstheorem: ; <interactive>:1:14: error: Variable not in scope: value; <interactive>:1:23: error: Variable not in scope: readMaybe :: String -> Maybe a0; <interactive>:1:42: error: Data constructor not in scope: Bounded
04:11:47 <Orbstheorem> % foo :: forall a. (Bounded a, Show a) => a -> Bool
04:11:48 <yahb> Orbstheorem: ; <interactive>:69:1: error:; * Variable not in scope: foo :: a1 -> Bool; * Perhaps you meant `for' (imported from Data.Traversable)
04:12:00 * Orbstheorem gives up
04:12:54 <solonarv> Orbstheorem: in the general case, no, not really
04:13:26 <solonarv> although one should hope that readMaybe will produce Nothing when given an out-of-bounds value, rather than producinc Just (error "boom")
04:15:02 <phadej> read "1000000000000000" :: Word8
04:15:05 <phadej> > read "1000000000000000" :: Word8
04:15:07 <lambdabot>  0
04:15:11 <phadej> they do weird things
04:15:16 <phadej> > read "10000000000000000" :: Word8
04:15:18 <lambdabot>  0
04:15:30 <phadej> > 10000000000000000 `mod` 256
04:15:32 <lambdabot>  0
04:15:42 <phadej> > read "10000000000000123" :: Word8
04:15:44 <lambdabot>  123
04:15:47 <phadej> eg
04:15:50 <phadej> > read "100000000000001234" :: Word8
04:15:52 <lambdabot>  210
04:15:56 <phadej> anyway, you get the point.
04:16:03 <phadej> don't use `read` :)
04:16:14 <phadej> (nor `readMaybe`) for such things
04:16:47 <johnnyboy[m]> @solonarv I still don't get it. I tried to calculate the foldr definition, but I get stuck in the induction step
04:16:47 <lambdabot> Unknown command, try @list
04:16:48 <phadej> `read` is usable in throw-away scripts, with trusted inputs
04:18:06 <johnnyboy[m]> Also, if we have an expression of the form x `f` (y `f` z), I dare to claim tha all we need is that f :: a -> a -> a. Any magma operation would do
04:18:47 <johnnyboy[m]> I don't understand this fuzz about such a strong assumption than a monoid
04:18:59 <phadej> foldr doesn't assume anything, does it?
04:19:55 <phadej> :t foldr
04:19:56 <johnnyboy[m]> To me, it seems that associativity is only needed if we want to have a some sort of confluence
04:19:57 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
04:20:28 <Orbstheorem> > fromInteger 10e10 :: Word8
04:20:31 <lambdabot>  error:
04:20:31 <lambdabot>      • No instance for (Fractional Integer)
04:20:31 <lambdabot>          arising from the literal ‘10e10’
04:20:47 <Orbstheorem> > fromInteger (product $ replicate 10 10) :: Word8
04:20:49 <lambdabot>  0
04:21:01 <Orbstheorem> phadej: fromInteger is also flawed :(
04:21:12 <phadej> it's sensible
04:21:45 <Orbstheorem> It's silent, I had the same problem when serializing data into a database.
04:22:16 <Orbstheorem> The db would return me impossible numbers because what was sent to it was wrong.
04:22:45 <phadej> it's sensible trade-off
04:23:02 <phadej> narrowing of (fixed-width)numbers is important operation
04:23:41 <phadej> so that one would still need to exist
04:24:42 <phadej> also Haskell prelude was formed when people didn't care that much of "make invalid states irrepresentable", which sometimes is not-bad.
04:25:00 <phadej> People avoid NonEmpty because "it's non-ergonomic"
04:25:20 <phadej> and where to draw a line, so _everybody_ would agree, is impossible to get consensus
04:25:34 <phadej> (i.e. how "painful" types can become in `base` / `Prelude`)
04:25:42 <phadej> for the sake of correctness.
04:26:02 <phadej> maerwald can probably rant for a day about FilePath ;)
04:26:12 <Orbstheorem> x)
04:27:35 <phadej> as there's another extreme to NonEmpty-avoidance, "we 'just' need refinement types and a single List type, which we refine with its length / other predicates"
04:27:49 <phadej> my personal opinion is "it depends"
04:28:15 <maerwald> phadej: two days
04:31:32 <sshine> > readMaybe "10000000000000123" :: Maybe Word8
04:31:34 <lambdabot>  error:
04:31:34 <lambdabot>      Variable not in scope: readMaybe :: [Char] -> Maybe Word8
04:31:48 <sshine> > Text.Read.readMaybe "10000000000000123" :: Maybe Word8
04:31:49 <lambdabot>  error:
04:31:49 <lambdabot>      Not in scope: ‘Text.Read.readMaybe’
04:31:49 <lambdabot>      No module named ‘Text.Read’ is imported.
04:31:52 <typetetris> In a cabal file where I declare a test-suite, can I depend on an executable from the same package? Like for integration tests?
04:33:35 <sshine> typetetris, you mean depend on the executable being in your testing environment's PATH?
04:35:10 <sshine> typetetris, second answer here seems to hint at a solution: https://www.reddit.com/r/haskell/comments/ac9x19/how_to_find_the_path_to_an_executable_in_the_test/
04:35:53 <dminuoso> typetetris: https://cabal.readthedocs.io/en/3.4/cabal-package.html?highlight=depends#pkg-field-build-tool-depends
04:36:30 <dminuoso> `Executables are provided during the whole duration of the component, so this field can be used for executables needed during test-suite as well.`
04:37:01 <dminuoso> Note, that the executable can be a sub-library component of the same package sa well.
05:21:59 <merijn> phadej, Orbstheorem: FWIW I think we really do need an additional library that has good primitives for "safe" conversions between numeric types, but coming up with a good API for it is hard...every so often I ponder what I'd want, but it's hard to pin down
05:22:19 <merijn> This stuff can produce really nasty errors that are hard to spot/fix
05:23:32 <dminuoso> At times I wonder whether we're just too paranoid. We humans tend to overdramatize potential pitfalls when we've fallen prey to them. In the past 2 years, I can't say I've had to spend more than a few minutes on debugging an unsafe-conversion bug.
05:24:03 <dminuoso> It's not like haskell programmers are stepping into "implicit loss of information due to fromIntegral" on a daily basis.
05:25:08 <merijn> dminuoso: Counter example, I have a bugfix in GHC that has, like, 5 lines of code and 30+ lines of comments because the first 2 (reviewed and merged!) attempts were still buggy
05:25:40 <dminuoso> merijn: Like I said. Once you've stepped into such a mine, then it's suddenly a big problem.
05:25:47 <merijn> It took me a literal week to figure out how correctly handle it despite being an essentially trivial problem
05:25:58 <dminuoso> Especially because you yourself have wasted a week now on this.
05:26:21 <dminuoso> I mean is it worth spending so much engineering on a problem that seems to rarely cause issues?
05:26:25 <merijn> dminuoso: It also meant that literally any linux or macOS program using large threadDelay was broken, so there's that ;)
05:26:47 <merijn> So..."probably" :p
05:26:52 <dminuoso> Well sure, but that's unrelated, rather.
05:27:10 <dminuoso> The problem affected potentially many users not because of the problem itself, but rather that it was located inside GHC somewhere.
05:27:18 <dminuoso> or base, rater
05:27:32 <merijn> dminuoso: The problem is that we don't have a library/API for doing conversions safely and writing such good yourself is *super* hard
05:27:34 <dminuoso> But that would apply to pretty much any problem.
05:27:46 <merijn> fromIntegral is fine, but we *do* need a safe conversion method too
05:29:42 <phadej> merijn: general case is tricky. If you restrict yourself to "bittwiddling", then it's easier to pin what you want
05:30:06 <phadej> merijn: and that's part of the problem, there are different domains and their needs are not the same
05:30:13 <phadej> so indeed, general interface is tricky.
05:31:15 <dminuoso> phadej: Well it would be kind of nice if we had some generic signature for error handling, and you could then use backpack to load some concrete implementation. But I think the power of backpack is not big enough for this, since you'd need different type signatures for different behaviors possibly.
05:31:30 <dminuoso> (in a world with ml-functors we could make it happen perhaps)
05:32:38 <phadej> dminuoso: re "how much more painful you can accept usng base to be"
05:33:02 <dminuoso> heh yeah
05:33:02 <phadej> mentioning backpack for number conversions is straight no from me.
05:33:02 <merijn> phadej: Well, over-/underflow detecting conversions are painful
05:33:42 <phadej> merijn: yes, but if you do bitfiddling / some low-levelish stuff, then you don't need "general interface"
05:33:43 <merijn> phadej: Specific example from GHC being the conversion between Int and CInt and Int64 being, essentially, unknowable
05:34:03 <phadej> especially if you talk about FFi/C
05:34:18 <merijn> phadej: I'm not really thinking of bitfiddling, though, merely converting between types and handling over-/underflow properly
05:34:43 <phadej> at least it doesn't happen implicitly ;)
05:34:58 <merijn> phadej: It does, though :\
05:35:08 <merijn> Int gets converted to CInt implicitly
05:35:33 <merijn> You need to manually convert to CInt and check to ensure correctness
05:36:14 <phadej> when you define signatures to foreign export, yes you can use Int in place of where you should use CInt
05:36:17 <phadej> don't.
05:36:32 <merijn> phadej: Tell that to GHC-HQ circa a decade ago :p
05:37:01 <phadej> merijn: as I a lso mentioned, back then people didn't care about "make invalid states irrepresentable"
05:37:35 <phadej> merijn: most recent example is "algorithm design with haskell" using lists [] and saying in proces "these are non-empty"
05:37:50 <phadej> in prose
05:39:00 <phadej> acdameic haskell and industrial haskell are quire different "dialects" :)
05:39:32 <merijn> tbh, I'm increasingly convinced that (GHC) haskell is the UNIX of purely functional programming >.>
05:39:48 <merijn> (In the "UNIX Hater's Handbook" sense)
05:40:13 <merijn> Just good enough, to hold back serious pure functional (systems) programming for decades to come!
05:42:41 <merijn> I'm sad Habit died, that could've been interesting
05:58:34 <ezzieyguywuf> hololeap: the "these" package looks like it may be along the lines of what I need, though I don't see how the "align" package fits in
06:00:27 <alehander92> ok guys
06:00:45 <alehander92> if i want to make something each 5 seconds
06:00:51 <merijn> ezzieyguywuf: align used to be part of these but it (and a bunch of other libraries) was split off
06:00:54 <phadej> ezzieyguywuf: are you looking at semialign package, not align
06:01:05 <phadej> latter ones is not related
06:01:08 <alehander92> should I use a job queue lib etc, or just using forkIO is enough
06:01:15 <merijn> alehander92: Do you care about it being *exactly* 5 seconds? Or just "approximately"
06:01:22 <alehander92> approximately
06:01:22 <ezzieyguywuf> https://hackage.haskell.org/package/align
06:01:24 <phadej> (the name was taken, so semialign was the next option)
06:01:30 <ezzieyguywuf> ah hah
06:01:50 <phadej> btw, https://hackage.haskell.org/package/these I wrote the description
06:01:51 <phadej> rtfm
06:01:55 <merijn> alehander92: Then I'd just use forkIO (well, async!) to spawn a thread that does "run actions, sleep 5 seconds using threadDelay"
06:02:02 <alehander92> i am using snap as a web library
06:02:16 <alehander92> i see, so it's not too low level for reading for other people
06:02:20 <alehander92> thanks
06:02:27 <merijn> alehander92: async makes it easier to track/handle exceptions in the timer, with forkIO you'd have to do that yourself which is...tricky
06:02:45 <alehander92> ah so async is more high level 
06:02:55 <phadej> yes
06:03:09 <phadej> implementing async with forkIO is something you would do in uni labs
06:03:11 <phadej> not at at work
06:03:31 <merijn> alehander92: Async is a very lightweight/thin wrapper around forkIO that does a lot of the complicated stuff like "how do I track exceptions/handle aborting" taken care off
06:03:59 <alehander92> phadej very useful remark, thanks
06:04:08 <merijn> phadej: Hey! I implemented my own async alternative at work and I only had 1 race condition!
06:04:31 <phadej> merijn: :)
06:04:37 <alehander92> merijn i understand. good!
06:04:51 <phadej> async is not complete
06:05:01 <phadej> but more often than not the thing you think isn't there, in fact is there
06:05:08 <merijn> Yeah, that's why I had to roll my own :p
06:06:17 <Athas> Can anyone recommend a library for implementing isomorphisms between data structures?  Or guaranteed compatible parser/prettyprinter combinations?
06:06:19 <merijn> F--, would not recommend ;)
06:06:45 <merijn> Athas: I just know the fancy paper that combined defining parser and pretty-printer simultaneously
06:06:55 <merijn> I'm not sure if that stuff ever went anywhere, though
06:07:26 <Athas> Yes, I am familiar with the idea, and there's an abandoned library on Hackage, but I wonder if people are doing this in practice.
06:07:49 <merijn> I don't think so, tbh
06:09:17 <phadej> text is hard
06:09:31 <phadej> I tried to do something like that with ASN
06:09:51 <phadej> kind of works, but hard to say if it's worth that
06:09:55 <phadej> trouble
06:10:07 <phadej> (it was fun though)
06:18:29 <mniip> Athas, that's not an isomorphism
06:18:35 <mniip> that's a retract
06:19:01 <mniip> or a maybe monad algebra
06:19:13 <mniip> errr
06:19:17 <mniip> disregard that
06:41:22 <johnnyboy[m]> does Endo f <> Endo g evaluate to Endo (f . g)?
06:41:47 <johnnyboy[m]> I see that (<>) = coerce ((.) :: (a -> a) -> (a -> a) -> (a -> a))
06:42:26 <johnnyboy[m]> so Endo f is just f in runtime?
06:42:37 <phadej> yes
06:44:23 <merijn> johnnyboy[m]: Newtypes are *always* only at compile time
06:44:57 <merijn> johnnyboy[m]: So "newtype Foo = Foo x" is *always* just 'x' at runtime
06:45:22 <johnnyboy[m]> so Endo f <> Endo g is just a fancy way of saying f . g ?
06:46:54 <merijn> johnnyboy[m]: Yes, the main reason it exists is so that we can have "instance Monoid (Endo a)"
06:47:23 <johnnyboy[m]> so Endo is a monoid in the category theoretical sense of the word?
06:47:28 <merijn> johnnyboy[m]: Which means you can do stuff like "appEndo . foldMap Endo" to fold a list of functions by composing them
06:47:36 <johnnyboy[m]> i.e. a single-object category
06:47:57 <merijn> Honestly, I'm not sure :p
06:48:28 <dolio> Endo is a monoid in the ordinary algebra sense.
06:48:29 <merijn> johnnyboy[m]: If you believe in the "Hask" category where types are objects, then "a -> a" is an endomorphism, hence the name
06:49:10 <merijn> johnnyboy[m]: It exists purely to instantiate the monoid for functions of type "a -> a"
06:49:51 <merijn> (because functions already have a (much better) monoid instance, so you need the newtype to disambiguate)
06:51:27 <Orbstheorem> Why Persistant says that using the max Numeric precision and scale values is probably not what you want?
06:51:55 <merijn> Orbstheorem: You are missing a whole bunch of context in that question
06:52:00 <Orbstheorem> pgsql Numeric storage is very efficient, not storing trailing nor leading zeroes.
06:52:07 <johnnyboy[m]> If we have some Endo a, then if we consider the type a as an object and functions a -> a as morphisms, then Endo a is a single-object category, I think
06:52:20 <johnnyboy[m]> in that case the composition of morphisms is the composition of functions
06:52:25 <merijn> johnnyboy[m]: Best not think too hard about the name
06:52:38 <merijn> There's no real rigorous math underlying it
06:52:42 <dolio> johnnyboy[m]: Yes, that's correct.
06:52:43 <Orbstheorem> merijn: As in, I have not given enough context or there is something I should have read?
06:53:02 <merijn> Orbstheorem: Well, for example *where* does persistent say that?
06:54:04 <merijn> Orbstheorem: Also, the remark "not storing trailing nor leading zeroes" makes me question a lot. What exactly do you mean by that?
06:54:35 <Orbstheorem> Oh, right. When I use a PersistFieldSql instance returning 'SqlOther "Numeric"', the migration raises an exception "No precision and scale were specified(...) Postgres defaults to a maximum of (...), which is probably not what you intended).”
06:55:25 <merijn> Orbstheorem: Presumably because that maximum takes up lots of space?
06:55:38 <Orbstheorem> <trailing zeros> The PostgreSQL docs say that Numeric values are physically stored without any extra leading or trailing zeroes.
06:55:56 <merijn> that makes no sense
06:56:13 <merijn> Unless they're storing numbers as decimal strings, to which I then say "that makes no sense either"
06:56:15 <Orbstheorem> ...> The actual storage requirement is two bytes for each group of four decimal digits, plus three to eight bytes overhead.
06:56:37 <merijn> Orbstheorem: I would not call that efficient
06:56:44 <merijn> I would call that abysmally inefficient, tbh
06:57:20 <Orbstheorem> Okay, not the most efficient, but it's not like specifying min/max would optimize it more.
06:57:28 <merijn> 32 bit ints store >6 decimal digits in 4 bytes with no overhead :)
06:58:12 <merijn> Anyway the answer to most things persistent and "why would it say that?" is "because it's opinionated and if you don't like its opinions, then, uh, too bad?"
06:58:53 <Orbstheorem> tbc, I wasn't critisizing Persistant, but rather dubious on whether there was something I wasn't considering.
06:59:05 <Orbstheorem> Maybe in the haskell side?
07:06:15 <carter> hello everyone
07:06:32 <carter> speaking of desimal strings, i wrote an email related to that https://mail.haskell.org/pipermail/haskell-cafe/2020-July/132565.html 
07:06:34 <carter> *decimal
07:06:40 <carter> merijn:  dolio  sup!
07:08:49 <carter> mniip:  btw, keep up the poking at ghc improvments stuff
07:08:59 <carter> you have really interesting neat ideas 
07:09:12 <mniip> time is scarce
07:09:26 <carter> valid and true!
07:09:29 <mniip> and at work we're not ready to throw manpower at potentially fruitless research
07:09:31 <carter> be more selfish :) 
07:09:34 <carter> valid
07:09:56 <carter> mniip:  i'm trying to poke along my parser ideas, once its further along your feedback would be fun :) 
07:10:47 <dminuoso> Waah. That moment when you trust your type instincts
07:10:58 <dminuoso> Ive been chasing a bug for a while, after some refactoring I was missing some elements.
07:11:04 <dminuoso> % :t Data.NonEmpty.tail
07:11:04 <yahb> dminuoso: ; <interactive>:1:1: error:; Not in scope: `Data.NonEmpty.tail'; No module named `Data.NonEmpty' is imported.
07:11:17 <dminuoso> % :t Data.List.NonEmpty.tail
07:11:18 <yahb> dminuoso: GHC.Base.NonEmpty a -> [a]
07:11:27 <dminuoso> This does not what I thought it did, based on its type signature. :D
07:11:29 <merijn> carter: Not much Haskell is up, sadly :p
07:12:26 <mniip> speaking of yahb
07:12:34 <mniip> I'm working on some changes in the backend
07:12:45 <mniip> chances are there's going to be undo support
07:12:58 <mniip> but I have great trouble imagining a usable UI for it
07:13:02 <mniip> especially on IRC
07:17:11 <carter> mniip:  whats YAHB?
07:17:33 <mniip> Yet Another Haskell Bot
07:25:58 <carter> Cool
07:26:55 <mniip> basically, I used to maintain my own "from scratch" containerization implementation
07:27:13 <carter> Ohhh
07:27:33 <mniip> and now I've discovered google's gvisor and it seems to include the right features
07:27:38 <carter> As in an lxc / cgroups tool?
07:27:41 <mniip> nope
07:27:55 <mniip> essentially a highly specialized debugger
07:28:03 <mniip> using ptrace to intercept system calls
07:28:12 <mniip> I started writing this before lxc was a thing
07:28:43 <mniip> well... before lxc was a popular and commonly used thing
07:29:14 <carter> Ok. So user space real isolation. Cool
07:29:26 <carter> Docker flavored containers are so weird
07:29:58 <carter> mniip: how’s this relate to the boy?
07:30:01 <carter> Bot?
07:30:19 <mniip> well the bot has to contain a ghci process
07:30:28 <mniip> I can say things like
07:30:37 <mniip> % I# (indexIntOffAddr# nullAddr# 0#)
07:30:37 <yahb> mniip: [Segmentation fault]
07:30:50 <mniip> so it kinda has to do full process level isolation
07:31:13 <ezzieyguywuf> is there a general form of `fmap . fmap`, i.e. if I have [Just 1, Just 2, Just 3] and I want to (+1) each int?
07:31:33 <mniip> ezzieyguywuf, what's wrong with fmap . fmap
07:32:15 <merijn> ezzieyguywuf: There's Data.Compose which has "newtype Compose f g a = Compose { getCompose :: f (g a) }" with associated functor instance
07:32:37 <ezzieyguywuf> mniip: nothing is wrong with it, just wondering
07:33:51 <dolio> Composing fmap (in one way or another) is almost always going to be the best way.
07:33:57 <ddellacosta> ezzieyguywuf: you may find this interesting too https://github.com/ekmett/lens/wiki/Derivation
07:36:27 <mniip> carter, I think I'll need to write my own container manager on top of gvisor though
07:36:50 <mniip> neither docker with gvisor's runtime, nor their runsc (drop-in replacement for runc) does what I want
07:37:11 <carter> mniip: cool! What do you want that they don’t do?
07:41:37 <mniip> carter, I need a trusted source of information on whether the process has exited or had been killed by a signal
07:41:54 <mniip> and whether it had indeed exited or has requested being suspended
07:42:09 <carter> Ooo. Nice / makes sense
07:42:21 <mniip> also their checkpoint/restore mechanism requires a full directory allocated to the saved data
07:42:26 <mniip> but it only ever writes a single file
07:42:37 <mniip> whose name I can't control
07:47:42 <mniip> I do like the OCI config.json specification though
07:50:55 <ezzieyguywuf> dolio: ddellacosta: thanks for the help.
07:52:45 <ezzieyguywuf> I ended up with `fmap (fmap Something) someNestedList`
07:53:22 <dolio> Depending on the context, I sometimes like to write that as `fmap something <$> list`.
07:54:09 <dolio> carter: Not much going on.
07:54:38 <dmwit> insanity wolf: ```(something <$>) `fmap` list```
07:59:03 <mniip> (<*>) . pure . (<*>) . pure
08:04:52 <x0r-255> does anyone know why this doesn't work?
08:04:54 <x0r-255> mstartupHook :: X ()
08:04:55 <x0r-255> mstartupHook = do
08:04:57 <x0r-255>  fmap (\x -> spawnOnce $ x ++ " &") ["nitrogen --restore", "picom"]
08:05:56 <dolio> X isn't the same as [].
08:06:11 <dolio> Presumably.
08:06:18 <x0r-255> right, but how might I achieve something like that?
08:06:34 <x0r-255> isn't that what fmap is for?
08:06:45 <x0r-255> vs regular map?
08:07:31 <nil> are you looking for traverse (or traverse_)?
08:07:46 <x0r-255> not sure
08:07:58 <x0r-255> I also tried Protolude.Functor.foreach
08:08:56 <nil> your function presumably has a type like [X ()] now; using sequence_ would get you from there to X (), but traverse_ is just fmap followed by sequence_
08:11:29 <x0r-255> thanks that works for me
08:15:21 <dmwit> x0r-255: There's also an #xmonad
08:16:58 <dmwit> There's a lot of overlap (e.g. Haskell expertise will get you through fixing type errors in existing code like this pretty easily) but you'll also find that folks there know the library much better, and so they can give you advice about what new code to write.
08:17:45 <typetetris> does `cabal test` somehow alter the process environment? (The tests can't call programs, I can call on the command line in the same shell as I use to start `cabal test`.)
08:18:36 <dmwit> I believe cabal test extends PATH. I don't think it should restrict it.
08:19:25 <ezzieyguywuf> dmwit: insanity wolf?
08:19:28 <dmwit> One possible explanation would be if your shell is modifying, but not exporting, PATH. But I think that would be very unusual -- you would have had to explicitly ask for that in your shell configuration files, I think, so you'd know if it was doing that and know to watch for it.
08:19:31 <x0r-255> dmwit: https://imgur.com/a/E7cGpuq <--
08:19:39 <x0r-255> would use that, but I can't
08:19:58 <dmwit> ezzieyguywuf: Google image search it for more fine examples. ^_^
08:20:00 <ezzieyguywuf> dolio: I like the `fmap something <$> list` representation, it is a bit more clear.
08:20:25 <ezzieyguywuf> dolio: lol.
08:20:29 <dmwit> x0r-255: Huh. Perhaps you aren't registered with services?
08:20:43 <x0r-255> no clue
08:21:09 <dmwit> x0r-255: Ah, no, it's +n. You have to be in the channel to send to it.
08:21:50 <dmwit> ...although, hm, it does seem like you're in there. When did you send the message that gave you that error?
08:22:01 <x0r-255> just now
08:22:21 <x0r-255> I first went there, but realised I couldn't send anything, so I hopped in here
08:22:31 <x0r-255> as what I'm making IS in haskell after all
08:22:45 <dmwit> Odd. I'll ping the ops, maybe one of the ones that understands IRC better can say what's happening there.
08:23:05 <x0r-255> I figured it was just a news outlet-type channel
08:24:24 <dmwit> It is intended for users to be able to help each other with configuration stuff, too.
08:24:34 <dmwit> Let's see if we can get you access. Be patient.
08:25:20 <dmwit> (I'm an op, too, but I don't know what's broken so although I probably have the permissions to fix it I don't have the know-how. =P)
08:26:33 <x0r-255>  will do... You guys here have been quite helpful.
08:45:47 <dmwit> x0r-255: Okay. To chat in #xmonad you have to be registered and identified with ChanServ. Let me know if you are interested in setting that up and need help with it.
08:45:55 <dmwit> err, NickServ, not ChanServ
08:46:36 <dmwit> https://freenode.net/kb/answer/registration has some documentation.
09:00:30 <kraeXen> dmwit: thx for the help mate
09:00:51 <kraeXen> x0r-255 here*
09:03:26 <frdg> How can I pattern match on a UTCTime?
09:13:44 <hexagoxel> let UTCTime day time = myUTCTime
09:14:13 <hexagoxel> maybe there are more useful patttern synonyms for time types somewhere, dunno
09:14:20 <hexagoxel> frdg: 
09:37:02 <ezzieyguywuf> how can I turn off -WunusedImports for just my test module?
09:37:15 <ezzieyguywuf> or better yet for one specific import
09:37:36 <Uniaika> ezzieyguywuf: you can give custom ghc options for different stanzas if the .cabal/package.yaml IIRC
09:37:55 <Cale> Something like {-# OPTIONS_GHC -Wno-unused-imports #-} ?
09:38:10 <ezzieyguywuf> Cale: I think that's what I was looking for
09:38:18 <Cale> But why have the unused import?
09:38:21 <ezzieyguywuf> Uniaika: I think you're right
09:38:25 <Cale> Just expect to need it soon?
09:38:41 <Cale> If you only want to import instances, you can write  import Foo.Bar ()
09:39:04 <ezzieyguywuf> Cale: `import Test.Hspec (xit)`, sometimes I have some "xit" sometimes I don't
09:39:16 <Cale> ah, okay
09:39:17 <ezzieyguywuf> I guess I _could_ just import Hspec unqualified
09:39:56 <Cale> I probably would
10:09:34 <mniip> hmm
10:09:57 <mniip> with parametricity, existentially forgetting the context type of a Store is equivalent to extracting it
10:10:31 <mniip> data AStore a = forall s. AStore (Store s a)
10:12:39 <dmwit> (Quick reminder: `data Store s a = Store s (s -> a)`, right?)
10:12:43 <mniip> yes
10:12:57 <mniip> I think it's Store (s -> a) s
10:13:07 <dmwit> Then, yep, I agree with your claim so far.
10:13:10 <mniip> but shouldn't matter
10:14:23 <mniip> more abstractly,
10:14:52 <mniip> existential quantification is "like" a coend (but not quite), and being a colimiting operation it "glues" elements together
10:15:32 <mniip> homotopy type theory makes this precise as sum types are particular fibrations and they can add more connectedness by the base time if the indexing type has nontrivial equalities, which the universe has via univalence
10:15:48 <mniip> s/time/type/
10:16:06 <mniip> tagging topos
10:17:05 <mniip> broke: profunctorial semantics of universal quantification; woke: geometrical semantics of existential quantification
10:17:22 <dolio> I don't think you need homotopy stuff to make it precise.
10:18:02 <mniip> dolio, making it precise is fairly tricky
10:18:36 <mniip> you have the fundamental theorem of ends that int_X Hom(FX, GX) = Nat(F, G)
10:18:58 <mniip> but the analogy very quickly breaks down if in `forall x. f x -> g x`, f and g aren't covariant functors
10:19:49 <topos> sup?
10:22:47 <mniip> topos, just thinking out loud
10:22:56 <mniip> maybe HoTT has some insight
10:23:05 <topos> mniip yeah, pretty much. nothing to add here. `forall x. f x -> g x` is a stronger gaurantee than `Nat(f,g)` due to parametricity
10:23:33 <mniip> Nat(f,g) is not even well defined if f and g aren't covariant
10:23:37 <mniip> but also
10:24:00 <dolio> HoTT is cool, but it isn't automatically the only or best perspective on everything.
10:24:11 <mniip> double hom in either f or g will break this
10:24:22 <topos> i like Ghani's bifibrational approach but admittedly i haven't finished the papers
10:24:37 <mniip> soon^tm
10:24:40 <topos> https://github.com/cohomolo-gy/parametricity/blob/master/Resources/Bifibrational%20Functorial%20Semantics%20of%20Parametric%20Polymorphism.pdf
10:25:08 <mniip> that's... the one I linked you to
10:25:10 <topos> mniip btw i'm like, an hour or two from Appalachian State and def. wanna hit up Prof. Johann for our work
10:25:12 <topos> yeah
10:25:15 <topos> it's really good
10:25:15 <mniip> with what physicists call a cylinder
10:26:11 <topos> dolio also hello it's been a minute
10:26:19 <dolio> Hi.
10:40:44 <Cheery> Purescript's "FFI" is stupid.
10:42:01 <hyperisco> Cheery, no u
10:42:24 <hyperisco> Cheery, come down to #purescript and we can fight
10:42:44 <Cheery> lol, lets fight.
10:42:46 <Cheery> #purescript
11:58:22 <maerwald> Cale: what do you think is the mean time for someone getting started with FRP and obelisk and building a small prototype project?
12:00:27 <Cale> Depends, I suppose a good place to start would be the tutorial in reflex-platform's readme https://github.com/reflex-frp/reflex-platform
12:00:48 <Cale> That'll get you started with the basics for using reflex-dom
12:01:01 <Cale> (which you'll use to write frontends in Obelisk)
12:01:22 <Cale> We really need to make a better, more comprehensive Obelisk tutorial
12:01:55 <maerwald> is 3 weeks realistic with no frp background?
12:02:17 <Cale> I think you should be able to do *something* in that time, maybe even in less.
12:02:50 <Cale> What's the project?
12:03:18 <maerwald> Cale: don't know yet, just probing tech :)
12:03:26 <Cale> btw, https://gitlab.com/obsidian.systems/lithograph is a simple example you might want to have a look at as well
12:03:44 <Cale> which has at least *some* backend component
12:04:56 <Cale> Currently, Obelisk is unopinionated to the point of being completely silent about what database you use, which has the downside that you have to actually figure out what to do with respect to that.
12:05:49 <Cale> That example uses Groundhog, but you could use anything you like
12:09:26 <maerwald> I'll check it out
12:13:26 <redmp> > (Show a) => ["hello", 'f']
12:13:29 <lambdabot>  <hint>:1:10: error: parse error on input ‘=>’
12:13:48 <redmp> > ["hello", 'f'] :: Show a => [a]
12:13:50 <lambdabot>  error:
12:13:50 <lambdabot>      • Couldn't match expected type ‘a1’ with actual type ‘[Char]’
12:13:50 <lambdabot>        ‘a1’ is a rigid type variable bound by
12:14:14 <redmp> Is this what ImpredicativeTypes is for?
12:14:40 <monochrom> No.
12:15:18 <monochrom> Much more simply, ["hello", 'f'] is a type error, even before checking against your type annotation.
12:15:59 <redmp> ok, what about this monochrom 
12:16:00 <redmp> > f b = case b of True -> "foo"; False -> 'f' :: Show a => Bool -> a
12:16:02 <lambdabot>  <hint>:1:5: error: parse error on input ‘=’
12:16:12 <redmp> > let f b = case b of True -> "foo"; False -> 'f' :: Show a => Bool -> a
12:16:14 <lambdabot>  <no location info>: error:
12:16:15 <lambdabot>      not an expression: ‘let f b = case b of True -> "foo"; False -> 'f' :: S...
12:16:25 <redmp> > \f b = case b of True -> "foo"; False -> 'f' :: Show a => Bool -> a
12:16:28 <lambdabot>  <hint>:1:6: error: parse error on input ‘=’
12:16:35 <redmp> > \b -> case b of True -> "foo"; False -> 'f' :: Show a => Bool -> a
12:16:37 <lambdabot>  error:
12:16:37 <lambdabot>      • Couldn't match expected type ‘Bool -> a’ with actual type ‘Char’
12:16:37 <lambdabot>      • In the expression: 'f' :: Show a => Bool -> a
12:17:05 <redmp> I swear i've been able to do something like this in the past without any language extensions
12:17:12 <monochrom> I think you need parentheses.
12:18:39 <shachaf> @quote cmccann ->
12:18:40 <lambdabot> cmccann says: :t \f -> \x -> f x :: Int :: (Int -> Int) :: (Int -> Int) -> Int -> Int
12:18:44 <monochrom> After fixing parentheses, you will run into very basic parametric polymorphism, still not about predicativity.
12:18:47 <shachaf> No parentheses needed!
12:19:13 <monochrom> :t \f -> \x -> f x :: Int :: (Int -> Int) :: (Int -> Int) -> Int -> Int
12:19:14 <lambdabot> (Int -> Int) -> Int -> Int
12:19:15 <redmp> understood.. 
12:19:28 <redmp> is there any way to have a list of `Show a => [a]`?
12:19:46 <redmp> or a function that uses `case` to return `Blah a => a`?
12:19:59 <shachaf> The thing you want isn't "[forall a.] Show a => a", because "=>" means the caller supplies the Show instance.
12:20:06 <monochrom> Yes, but you have [exists a. Show a => a] in mind, big difference.
12:20:13 <shachaf> It's [exists a. Show a *> a], where each element of the list is packaged with its own Show instance.
12:20:30 <shachaf> Where *> is like a tuple where => is like a function.
12:20:38 <monochrom> that too
12:20:42 <shachaf> GHC doesn't really meaningfully support this.
12:20:56 <shachaf> You can make a data type: data ShowBox = forall a. Show a => ShowBox a
12:21:13 <shachaf> And then [ShowBox "hello", ShowBox 'f'] is a list of things you can show.
12:21:15 <frdg> I have a Aeson Value that looks like this when I `show` it. `Array [Object (fromList [("icon",String "03d"),("main",String "Clouds"),("id",Number 802.0),("description",String "scattered clouds")])]`. How can I parse out "description"? I am struggling to figure out how to parse Values.
12:21:19 <monochrom> Why do people keep mixing up forall and exists.
12:21:20 <shachaf> But [show "hello", show 'f'] is even better.
12:21:23 <redmp> Yes, i've seen examples of those forall data structurures.. for some reason i thought there was a way to do it without
12:21:30 <monochrom> It's like a beginner level error.
12:21:43 <shachaf> Why do people mix up => and *>, that's what I want to know.
12:21:52 <shachaf> Other than "Haskell has no notion of *>"
12:22:32 <monochrom> I think people don't make a semantics mistake by that level. Only too lazy to change notation.
12:23:32 <shachaf> Perhaps they're too lazy change notation from forall to exists, too.
12:23:52 <monochrom> I think that of GHC.
12:24:36 <monochrom> But beginners make the semantic mistake, not the syntactic mistake. We know because they haven't even heard of the "forall" syntax.
12:25:17 <monochrom> We know because they ask about "v :: a; v = True" and really believe it is not wrong.
12:26:05 <hyperisco> I have never seen => and *> confused
12:26:11 <koz_> frdg: Array is secretly Vector, Object is secretly 'HashMap Text Value'.
12:26:17 <koz_> Does that help any?
12:26:43 <koz_> Welcome to Koz's Exhibit Number 49 of 'why type synonyms only create confusion'.
12:27:06 <monochrom> I thought Array and Object were data constructors there.
12:27:15 <koz_> monochrom: They are also type synonyms.
12:27:25 <monochrom> Darn yes.
12:27:26 <maerwald> yeah, why not both
12:27:26 <koz_> Because it wasn't confusing enough already.
12:27:35 <frdg> What I dont understand is why I can parse this as a Value but the parse fails if I parse it as an Array or Object
12:27:39 <maerwald> there's also object
12:27:59 <maerwald> https://hackage.haskell.org/package/aeson-1.4.6.0/docs/Data-Aeson-Types.html#v:object
12:28:00 <koz_> frdg: Because Value is a type, but Array and Object (as here) are constructors.
12:28:10 <monochrom> Some of the functions in aeson insist on Value.
12:28:14 <hyperisco> koz_, hm I too am not fond of using type synonyms
12:28:22 <koz_> Alternatively, use phadej's aeson-optics and never think about this inane mess again.
12:28:27 <hyperisco> I feel like if it is worth naming then it is worth opaqueness
12:28:30 <maerwald> and object creates a value, not an Object
12:28:42 <hyperisco> if it is in that awkward grey area then maybe it isn't thought through well enough
12:28:56 <koz_> maerwald: More precisely, it creates a Value which is an Object.
12:29:01 <koz_> (because it uses that constructor)
12:29:02 <maerwald> heh
12:29:07 <koz_> (and also houses an Object)
12:29:09 <monochrom> oh haha, object :: ... -> Value, now that's something.
12:29:12 <koz_> (as in the type synonym)
12:29:17 <koz_> INCREDIBLE DESIGN
12:29:29 <koz_> wow, such clear, very understand
12:29:48 <hyperisco> meme so dead
12:30:00 <monochrom> such meme, so dead
12:30:16 <koz_> frdg: Basically, you have to either do a tonne of pattern matches (and then Vector and HashMap ops), or as I said, use aeson-optics and never think about it again.
12:30:35 <koz_> monochrom, hyperisco: amaze
12:30:37 <monochrom> popularity kills the meme. self reference brings it back!
12:30:54 <koz_> monochrom: Everything is better with knot-tying.
12:30:56 <hyperisco> koz_, what does it say about my indoctrination when I don't seem to have a problem with this nomenclature
12:31:16 <koz_> hyperisco: You're suffering from nomenclatural Stockholm Syndrome.
12:31:26 <monochrom> hahaha
12:31:29 <hyperisco> I've defined Value before :o
12:31:38 <hyperisco> and  type
12:31:50 <monochrom> I just defined a Value type this morning in class.
12:31:58 <hyperisco> should be turned into a t-shirt
12:32:03 <Cale> Which nomenclature?
12:32:32 <hyperisco> Don't confuse type with Value
12:32:56 <koz_> Cale: The fact that aeson has Object and Array as both type synonyms (for HashMap Text Value and Vector Value respectively) and data constructors of the Value type.
12:33:08 <maerwald> type Value = Object
12:33:11 <koz_> As well as having an 'object' function, which produces... a Value.
12:33:21 <Cale> ah, okay
12:33:40 <monochrom> and "data Value = Array Array | Object Object | Pee Pee | Whiz Whiz | Bang Bang"
12:33:46 <hyperisco> maybe could benefit from renaming Value to JsonValue
12:33:52 <koz_> monochrom: Rofl.
12:34:02 <monochrom> and "object :: ... -> Value"
12:34:06 <koz_> hyperisco: It could benefit by burning all type synonyms it uses with fire.
12:34:09 <Cale> hyperisco: But it's already Aeson.Value ;)
12:34:17 <koz_> That's the most egregious problem, but far from the only one.
12:34:28 <koz_> Case in point - Key is just (Text, Value).
12:34:30 <hyperisco> I thought types were imported unqualified and values imported qualified
12:34:38 <Cale> Yeah, it should lose the type synonyms to start with
12:34:56 <Cale> I also wish that Aeson were more usable without having to define instances of its type classes
12:35:18 <hyperisco> you should visit the recreation in PureScript
12:35:30 <koz_> Cale: What's your take on waargonaut?~
12:35:32 <Cale> The ToJSON and FromJSON classes are good, because we often want conventions for how to convert things to and from JSON
12:35:32 <hyperisco> which had that part excised, allowing different codecs
12:35:58 <Cale> But at the same time, the library should be usable without them.
12:36:29 <koz_> Cale: You can manually use its generic* functions, provided your type is an instance of Generic, but that's not too much better.
12:36:30 <Cale> I haven't *actually* used waargonaut in anger, so I'm not sure.
12:36:33 <hyperisco> all that irks me is people think they're trapped using auto codecs
12:36:44 <koz_> Cale: I'd like to, but it lacks GHC 8.10 support.
12:37:07 <Cale> I think we're still on 8.6.5 here
12:37:16 <hyperisco> they're like puppies, pawing at the walls of their cage and oblivious to the fact the door is wide open
12:37:22 <koz_> Cale: I helped lift the work code to 8.8.3 recently.
12:37:37 <koz_> However, we're (fairly) chained to aeson sadly.
12:37:58 <Cale> hyperisco: It's not even especially hard. You can already do it, it's just kind of awkward.
12:38:00 <hyperisco> then what ensued are tortured extensions to auto codecs, so they're somewhat less auto
12:38:23 <hyperisco> (not sure about the Haskell story in that regard but that plays out in every other language I've seen)
12:38:46 <monochrom> If you give them a solution, you violate their right to use their alternative solution. If you don't give them a solution, you violate their right to use your solution.
12:39:01 <koz_> hyperisco: Somewhat relevant anecdote: I had someone on this very channel insist new Unbox instances are not derivable.
12:39:27 <monochrom> I am saying this because I need to vent off some seriously misguided, disturbing questions from some seriously misguided, disturbing student mindsets.
12:39:51 <koz_> monochrom: You teach at Arkham University?
12:39:56 <maerwald> lol
12:40:55 <monochrom> My assignment handout wrote like "Create a pipe (this is a unix and C assignment).  Let's say the FDs are 42 and 43 for concreteness sake, but this is just an example.  Construct the filename /dev/fd/42 and give it to such-and-such"
12:41:18 <monochrom> I have a student ask "can I hardcode /dev/fd/42"?
12:41:41 <monochrom> Like did I clearly say "this is just an example"?
12:41:55 <koz_> (sorry, I think it's Miskatonic University?)
12:42:29 <monochrom> In fact it tells you what's wrong with the millenials, if I even have to write in black and white "this is just an example". Isn't this implicitly universally understood?
12:42:45 * koz_ is a millenial.
12:43:10 <monochrom> Anyway so I feel like this. If you give them an example, they fixate on that example. If you don't give them an example, they complain you're too abstract, no example.
12:43:28 <koz_> Solution is clearly to give 2 examples. :P
12:43:36 <ystael> or i examples
12:43:53 <koz_> ystael: pi examples.
12:43:54 <Clint> ∞
12:44:12 <hyperisco> I think the auto deriving problem is the cliff you have to push yourself over to admit they won't work
12:44:48 <hyperisco> wish I could use the auto codec, but I really need snake case converted to camel case, so guess that won't work now
12:46:34 <monochrom> Here is another one. Later I wrote that you have to do an exec, and I even arranged it so it's a no-brainer. Your function takes several parameters, among them a prog2 string and a prog2_argv array. You just have to do execvp(prog2, prog2_argv) and not even worry what's in prog2_argv and is it in the right format, I guarantee it is.
12:46:56 <alehander92> hey
12:47:12 <maralorn> I have a function from type to value. I.e. f :: forall a. String. I use it as "f @MyType". How hard would it be to write a list of types and map it to a list of strings? Just enabling a few extensions or doubling my dependency footprint?
12:47:17 <monochrom> And my starter code shows a sample test case with prog2="sort", prog2_argv = ["sort", "-r", "filename"].
12:47:48 <alehander92> does someone use snap? do you guys usually start with snap init
12:47:48 <monochrom> There were people who asked "is it true that prog2_argv[2] is a filename? is it an error if not?"
12:47:52 <alehander92> or do you use a more custom build 
12:47:53 <solonarv> maralorn: are you looking for something like `f :: forall [a]. [String]` ?
12:48:03 <frdg> I tried to use the (!) function from vector to just grab the value I need out but am being given index out of bounds exceptions for every index other than 0. I looked at aeson-optics but was not sure of what was going on.
12:48:41 <solonarv> (and presumably there are some typeclass or other constraints that you omitted)
12:49:03 <frdg> and I parsed the json as a [Value] instead of a Value
12:49:38 <monochrom> hyperisco: snake case is great, please keep snake case if you receive it.
12:49:40 <maralorn> solonarv: no, I want to specify a list of different types and convert it to a list of strings.
12:49:57 <maralorn> solonarv: Yes, there are constraints.
12:50:04 <solonarv> maralorn: brainfart, what I typed isn't even valid; one sec
12:50:08 <solonarv> (writing a gist)
12:50:47 <monochrom> is "a list of types" a type-leve list? term-level list?
12:51:55 <frdg> oh sorry I parsed it as a Vector Value
12:53:00 <maralorn> monochrom: typelevel I guess? Think of it like I have something like "show (def @a)" and want to apply to multiple a.
12:53:49 <hyperisco> monochrom, a string can be a syntactically valid path but not resolve to a file, so maybe that was the question
12:53:54 <solonarv> maralorn: here is a geenric example: https://gist.github.com/Solonarv/a9909229f317532b6265c2bd50d96184
12:55:15 <hyperisco> and nowadays I'd need a few weeks to readjust… because my regular conversations cannot assume anywhere near that level of precision, even if offered :P
12:56:05 <monochrom> hyperisco: Either question is moot if you don't fixated on prog2="sort"
12:56:25 <monochrom> or even don't fixate on prog2_argv[1] happens to be -r
12:56:30 <solonarv> maralorn: I didn't actually compile this so I might have missed an extension, but the actual code should be right
12:57:14 <maralorn> solonarv: Perfect thanks. Have all extensions enabled anyway.
12:57:17 <maralorn> Not all, but those four.
12:58:52 <maralorn> Now I need to decide if I think this is useful enough to introduce into my production code.
13:02:30 <widmanstatten> Hi! Is anyone using nix on mac Catalina onwards?
13:04:03 <hyperisco> monochrom, at first I was confused as to what exactly a program ought to be doing. Good programs are supposed to validate their inputs and handle errors, right?
13:05:21 <hyperisco> so when you're taught to watch out because you might open a file that doesn't exist, a new task that starts talking about filenames triggers that reflex
13:07:16 <monochrom> sort might open a file. you might not, you're just execing.
13:07:30 <merijn> hyperisco: The real reflex that it should trigger is that checking for a file's existence is irrelevant and pointless
13:07:43 <monochrom> Separation of concerns is more important.
13:08:39 <hyperisco> I'm just saying that putting all the pieces together of what you're being taught takes time
13:09:44 <monochrom> Sure, but separation of concerns is the source of how the hell do you even define what "validate" means, what "input" means, what "error" means, and what "handle" means.
13:10:21 <monochrom> An event is or is not an "error" depending on the concern assigned to you. You are not supposed to reflex on this.
13:11:20 <monochrom> But yes, people are taught to have a strong conviction on moral judgments such as what's an error.
13:13:51 <hyperisco> you should comment every line, you should use consistent formatting, you should use descriptive names
13:14:41 <hyperisco> you should catch errors, you should print good error messages, you should inform the user as to what is wrong
13:15:45 <monochrom> Really, the correct reflex is this: what if prog2 is a program the evil grader invents anew and I have no idea what counts as valid arguments? I cannot judge all cases, perhaps therefore I should judge no case at all.
13:16:26 <monochrom> Instead of "what if sort's filename is wrong" you should be "what if I've never heard of prog2".
13:16:38 <maerwald> what's the best monospace font
13:16:47 <merijn> maerwald: Monaco :p
13:18:05 <hyperisco> I just see how you can get there in a reasoned way, so I have an easy time remotely sympathising with your students :P
13:20:33 <merijn> hyperisco: Clearly you haven't interacted with students before, or you'd realise that empathising with them is undeserved :p
13:21:28 <maerwald> merijn: do you use Monaco?
13:21:36 <hyperisco> I said I sympathise, but I think I empathise too
13:22:20 <hyperisco> we're well along on the Dunning-Kruger curve here
13:22:30 <merijn> maerwald: I do, although tastes differ and I know some people hate it. It also depends whether you're one of the masochists that think "Courier New" at 9 or 10 points is perfectly legible or not :p
13:23:30 <merijn> maerwald: I prefer using considerably larger font sizes and then it's often nice (imo) to have a bit heftier fonts so the letters don't look so itty-bitty thin
13:23:37 <hyperisco> I just see more and more clearly how I have failed to make obvious connections, how I've needlessly overcomplicated, how past experience so strongly shapes how I approach new problems
13:23:40 <maerwald> I tried Fira and got eye cancer
13:23:45 <merijn> (well "considerable" being 14 or something)
13:23:54 <hyperisco> so if I can devise some analogous story for monochrom's students, I feel for them
13:24:22 <hyperisco> maybe I'm just apologising for myself ;)
13:25:16 <sm[m]> I feel for monochrom’s students :)
13:25:48 <hyperisco> also, spending time thinking about how we know anything, at least my experience of it, undermines most confidences
13:26:15 <merijn> I'm torn
13:26:28 <merijn> On the one hand I'm an optimist and like to believe any student can be taught...
13:27:15 <merijn> On the other hand, I had to include an explicit whitelist of acceptable file formats in our syllabus because people were submitting their assmebly code homework as PNG images of their editor showing the assembly, embedded in PDFs...
13:27:26 <merijn> (we're talking 3rd year bachelors...)
13:27:30 <merijn> (in CS)
13:28:06 <hyperisco> wow, sounds like a shoo-in for graduate school
13:28:43 <hyperisco> no graduate I worked with knew how computers worked XD
13:29:13 <hyperisco> that's for the applied branch
13:30:03 <hyperisco> and I can feel myself trending towards taking pictures of my monitor with my polaroid camera because I cannot figure out how software works anymore
13:30:47 <hyperisco> do designers even care to make buttons look depressible anymore?
13:31:36 <merijn> hyperisco: Just do everything in the terminal, problem solved!
13:32:39 <rotaerk> I'm confused ... https://gitlab.haskell.org/haskell/ghcup-hs says to follow the instructions on https://www.haskell.org/ghcup/
13:32:49 <hyperisco> I was taught super+shift+s and that'll last me until the next desktop remaster, hopefully
13:32:53 <rotaerk> but that page just says to install haskell platform
13:33:07 <rotaerk> so is ghcup now part of haskell platform?
13:33:23 <maerwald> rotaerk: haskell platform redirects to ghcup too
13:33:31 <rotaerk> oh
13:33:32 <maerwald> and ghcup redirects to haskell platform
13:33:36 <maerwald> it's a great mess
13:34:24 <rotaerk> this is why it's hard to get people into haskell
13:34:33 <rotaerk> you pique their interest and then they're like ... how the hell do I install this?
13:34:45 <sm[m]> documentation: the really hard thing in computing
13:34:48 <maerwald> also related https://github.com/haskell-infra/www.haskell.org/issues/12
13:34:53 <hyperisco> one doesn't simply get into Haskell
13:35:06 <maerwald> rotaerk: https://www.haskell.org/ghcup/  is a good starting point :)
13:35:21 <maerwald> ask further questions here
13:35:25 <rotaerk> lol
13:35:33 <sm[m]> How goes a person find that maerwald
13:36:08 <rotaerk> I don't use ghcup; I usually use nix.  but I got someone wanting to install it, and was having trouble finding usable instructions
13:36:12 <sm[m]> does
13:36:15 <int-e> hyperisco: Is that a LotR reference?
13:36:23 <rotaerk> mostly because these instructions led to haskell platform, and I remember HP being a mess
13:36:44 <maerwald> rotaerk: exactly, I proposed to remove haskell platform page
13:36:51 <maerwald> but it seems controversial
13:37:01 <int-e> . o O ( s/Mordor/Haskell/g )
13:37:04 <hyperisco> int-e, if they rode the eagles there wouldn't have been a book to write about it, is all I'm saying
13:44:51 <dolio> Pretty sure this isn't the limiting factor of people getting into Haskell.
13:46:01 <rotaerk> I just told him to go to https://gitlab.haskell.org/haskell/ghcup-hs and follow the manual install rather than the bootstrap instructions
13:47:46 <rotaerk> dolio, I know one person who showed some interest in haskell but gave up when the windows installer wouldn't do what he wanted
13:48:20 <maerwald> rotaerk: ghcup doesn't work on windows btw
13:48:47 <maerwald> rotaerk: https://github.com/kakkun61/ghcups/ this is for windows
13:49:04 <rotaerk> yeah *this* person is on linux; the windows guy was someone else
13:49:26 <rotaerk> I didn't know there was a ghcup for windows though; neat.  I only knew of chocolatey
13:49:33 <maerwald> but then the ghcup homepage should have worked?
13:49:45 <maerwald> rotaerk: it uses chocolatey under the hood
13:49:56 <rotaerk> the ghcup homepage takes you to haskell platform
13:50:06 <maerwald> rotaerk: no, only for windows
13:50:18 <rotaerk> oh the page behaves differently if you browse to it from linux?
13:50:25 <maerwald> yes
13:50:26 <rotaerk> that's confusing...
13:50:49 <maerwald> there is also "display all supported installers" link
13:51:22 <rotaerk> ah
13:51:56 <rotaerk> I didn't know that black box with the curl command was for ghcup; I just kind of ignored it
13:52:01 <maerwald> lol
13:52:04 <rotaerk> because it's inside the larger box that seems to be dedicated to haskell platform
13:52:22 <rotaerk> like there's ghcup at the top, and then below it a haskell platform box containing a curl command
13:52:25 <maerwald> compare with https://rustup.rs/
13:52:37 <rotaerk> also confusing af :P
13:52:46 <maerwald> PRs welcome
13:52:52 <rotaerk> well wait no, the rust one makes sense
13:53:05 <sclv_> wanted to check in if hackage is working well forr everyone
13:53:14 <rotaerk> the haskell one doesn't because it says Haskell Platform above the black box
13:53:16 <rotaerk> anyway...
13:53:32 <maerwald> rotaerk: wut?
13:53:48 <maerwald> screenshot pls
13:53:54 <sclv_> i just updated the root key signatures and by my testing its fine
13:54:00 <sclv_> but i want to be super sure
13:54:16 <sclv_> if anyone runs into problems with like cabal update or the like, please let me know
13:55:29 <Maria20> Hello, let's talk in private chat via webcam >>> www.seⅹ0.space Nick Mari99
13:55:40 <sclv_> no thanks
13:56:11 <solonarv> man these spambots are annoying
13:56:14 <rotaerk> maerwald, when I visit it from windows, I see this https://i.paste.pics/812fbba15346d5b464a22dc4c42c0403.png
13:56:22 <rotaerk> if I click the display all supported installers link, I see.....
13:56:45 <maerwald> rotaerk: yes, it clearly says the blackbox is for WSL users
13:57:01 <maerwald> I can add a voice that reads the text out loud
13:57:22 <monochrom> haha
13:57:31 <rotaerk> right, but what if you use linux
13:57:33 <monochrom> I have learned that people won't read what you clearly write.
13:57:55 <rotaerk> I know it says it's for WSL; I was going to point that out as a reason the page *doesn't*
13:57:58 <rotaerk> work
13:58:00 <maerwald> rotaerk: can you read the line in small letters at the bottom?
13:58:12 <maerwald> "You appear to be running Windows.. if not..."
13:58:14 <dolio> If you use linux there is no mention of the Haskell Platform.
13:58:57 <maerwald> so the platform detection is obviously not facebook grade spyware
13:59:23 <maerwald> not sure it makes sense to put effort into that
13:59:28 <rotaerk> my point is that the big rectangle had Haskell Platform in big bold letters at the top, so I ignored the entire conttents of the box
13:59:36 <rotaerk> including the small letters at the bottom
13:59:45 <rotaerk> because clearly this box isn't for ghcup, it's for haskell platform
13:59:50 <maerwald> I can add a horizontal line 
13:59:50 <rotaerk> except apparently not
13:59:53 <maerwald> does that help
14:00:09 <monochrom> Oh, that.
14:00:44 <monochrom> Well, half of the Windows uses are unhappy about this.
14:01:07 <monochrom> If you heed their advice, the opposite half's turn to be unhappy.
14:01:26 <merijn> Unhappiness all around! \o/
14:01:30 <maerwald> I don't care much about windows, so
14:01:54 <monochrom> It really doesn't help that Windows really encouraged this simple-minded culture.
14:01:56 <rotaerk> even if there was a line below "Haskell Platform", I would still think that the subject has been changed from ghcup to haskell platform, and that the only part relevant to ghcup is the very top of the page where it says "ghcup is an installer for the general purpose language Haskell"
14:02:09 <monochrom> That you don't have to read, you don't have to decide. Just click.
14:02:13 <sm[m]> be sure never to show them https://www.fpcomplete.com/haskell/get-started/, or they’ll be everywhere
14:02:20 <maerwald> rotaerk: what do you propose
14:02:36 <maerwald> I suck at html and css
14:03:08 <sm[m]> the above page is the one to beat, if you want to design an easy on boarding experience
14:04:18 <monochrom> Yeah, maybe don't bother to autodetect.
14:05:14 <maerwald> oops
14:05:26 <monochrom> Everything you do carries the message "I take this responsibility on me". Think twice before you really let that happen.
14:06:03 <monochrom> If you autodetect, people expect it to be perfect (which is almost telepathic)
14:06:04 <NieDzejkob> what's the easiest/best way of making stimes 0 work on my monoid
14:06:08 <maerwald> sm[m]: do you know the license of the fpcomplete page?
14:06:14 <monochrom> If you guess, people expect you to be telepathic.
14:06:25 <sm[m]> no
14:06:41 <rotaerk> well, the problem is that the big letters make it seem like that's what this thing entire block is for, and thus if you're not interested in that topic, you can skip reading the rest of the block; so the goal is to structure it to not give that impression ... so what I'd suggest is mention in bold letters at the top that this block is the instructions for windows (and provide a link if you want other instructions)
14:06:43 <merijn> NieDzejkob: By not using stimes? >.>
14:06:57 <merijn> NieDzejkob: Alternatively "mconcat . repeat 0"
14:07:00 <maerwald> sm[m]: well, then I'd rather not use any of it :)
14:07:12 <rotaerk> also in the actual Windows instructions, indicate that for windows, ghcup is installed via Haskell Platform
14:07:23 <rotaerk> otherwise I'll be like "but I thought this was the ghcup instructions"
14:07:33 <maerwald> I'm inclined to link to ghcups instead of haskell platform
14:07:41 <NieDzejkob> merijn: what's a good alternative? I want to use the double-and-add algorithm the standard library implements
14:07:41 <rotaerk> yeah was about to suggest that too
14:07:46 <maerwald> and take the risk of pissing someone off
14:07:48 <merijn> The gist is: The Windows experience won't get better until people who care about windows step up and make it better
14:07:55 <rotaerk> maybe link both?
14:07:59 <monochrom> Wait, Haskell Platform includes ghcup?!
14:08:07 <rotaerk> for ghcup, go to ghcups; alternatively, go to Haskell Platform
14:08:08 <merijn> Everyone wants the Windows story to be better, but no one wants to bother making it better
14:08:10 <maerwald> monochrom: no, it links to it
14:08:18 <maerwald> there is no haskell platform anymore
14:08:25 <maerwald> it's just a page
14:08:40 <merijn> NieDzejkob: Eh, "\n -> if n == 0 then const mempty else stimes n"?
14:08:40 <maerwald> for windows users it redirects to chocolatey
14:08:40 <monochrom> I have a feeling we have a cyclic thing here.
14:08:44 <maerwald> yes
14:08:50 <monochrom> haha
14:09:02 <rotaerk> i think the windows story should be better even if the majority of haskellers are on linux ... if only to improve adoption, because so many programmers are on windows
14:09:08 <monochrom> This is a mess beyond rationality.
14:09:11 <NieDzejkob> merijn: I guess... thanks
14:09:18 <maerwald> https://github.com/haskell-infra/www.haskell.org/issues/12
14:09:27 <merijn> rotaerk: It should be better, but you can't expect the *nix people to make it so for free
14:09:32 <rotaerk> yeah
14:09:43 <maerwald> and https://github.com/haskell-infra/www.haskell.org/pull/14
14:09:59 <NieDzejkob> oh, duh
14:10:00 <monochrom> My view is more stark. Everyone has an opposing idea of what "better" means in this case.
14:10:01 <dolio> I don't see a link to ghcup in the Windows section of the haskell platform page, either.
14:10:09 <NieDzejkob> ghci autocomplete pointed me to stimesMonoid
14:10:19 <sm[m]> it is a mess indeed. We should all be embarrassed at how long getting started with haskell has sucked
14:10:22 <merijn> monochrom: My view is "Step up, pay, or stop complaining"
14:10:57 <maerwald> we can link newcomers to nix documentation and see how that works out
14:11:18 <merijn> sm[m]: Counter-point: Saying volunteers should feel bad about not doing more is toxic nonsense that I wish I had the power to ban from open source >.>
14:11:18 <monochrom> I think it's better, on the ghcup website for example, "if WSL \n \t the curl command \n else \n \t chocolatey"
14:11:48 <monochrom> Especially the indentation to clearly show, no excuse, that it is a conditional, you have to make a choice.
14:12:03 <monochrom> But even more clearly, all of you disagree.
14:12:05 <dolio> In fact, the only mention of ghcup I see on the Haskell Platform page is in the Mac section.
14:12:32 <maerwald> dolio: no, also in generic linux
14:13:22 <sm[m]> merijn, feel free to go down that old road but it's not what I'm saying
14:14:24 <monochrom> May I tell you an Aesop fable again? :)
14:14:26 <maerwald> merijn: now that you mention it... I should set up my github sponsorship :p
14:15:27 <dolio> Oh, I had to click stuff to make it appear, I see.
14:15:28 <monochrom> But I thank maerwald because for a year now I have been able to point students to ghcup.
14:15:49 <sm[m]> obviously noone's obligated to do anything, and I say, just as a random IRC comment, the situation is by now embarrassing. Compared to say Rust.
14:15:55 <maerwald> I think I spent more time explaining mac users what the PATH variable is than coding :>
14:16:12 <monochrom> with a clear conscience regarding I am not making things hard for students.
14:16:23 <merijn> sm[m]: Rust has considerably more people getting paid to work on these things (i.e. non-zero people)
14:16:50 <sm[m]> yes, all the standard objections, it's still embarassing 
14:16:58 <monochrom> I may as well offer "where can I chip in $10 or something?"
14:17:08 <maerwald> sm[m]: both ghcup cli interface and ghcup website is basically stolen/inspired from rustup
14:17:12 <sm[m]> excuse me merijn, not blaming you
14:17:22 <sm[m]> yes
14:17:38 <sm[m]> it's a great effort merijn, more needed obviously
14:17:50 <sm[m]> how does someone find the ghcup page, I was wondering ?
14:18:05 <sm[m]> sorry - maerwald
14:18:07 <dolio> It seems like there is some overestimation of how confusing this actually is going on, to me.
14:19:17 <maerwald> sm[m]: I probably need some SEO here, bc ghcup doesn't show up when googling "install Haskell"
14:19:58 <merijn> sm[m]: I agree that it is *unfortunate*, but I think iexpecting a community has a some form of moral obligation to handle this as well as other communities that have people getting paid to work on them fulltime just doesn't sit well with me. Especially given how rampantly big tech is externalising much of their work and support to volunteers that get paid nothing for it
14:20:05 <monochrom> haskell.org/downloads/ does not offer ghcup, and this is not under your, mine, maerwald's merijn's control.
14:20:07 <sm[m]> maerwald: it has to at least be one click from haskell.org
14:20:14 <monochrom> This is part of why the mess.
14:20:30 <merijn> dolio: to be fair, I tried to help my girlfriend install GHC on windows and it was such a pain I just had her use stack instead, despite disliking stack a lot >.>
14:20:44 <maerwald> this is politics and I don't have time for it :p
14:20:45 <merijn> monochrom: Well, technically it might be under mine? >.>
14:20:45 <monochrom> There is strongly partisan things going on that perpetuals this.
14:20:56 <monochrom> Oh then please act! :)
14:20:57 <merijn> monochrom: I might still have access to haskell.org machines :p
14:21:43 <sm[m]> yes; those people who can not be named made a serious effort to improve this situation, and they succeeded, but half of us treat them as pariahs so it has had little impact ;(
14:21:46 <merijn> monochrom: I haven't been involved with the administration of those machines in a *long* time and I'm definitely not one of the people who *should* be touching them, since I don't know how things are set up
14:21:48 <monochrom> I am totally not embarrassed when strongly partisan people ruin it all because they should be the ashamed one.
14:21:56 <dolio> The Haskell platform page mentions stack.
14:22:27 <monochrom> And I already do my part in pointing my students and beginners here to ghcup.
14:22:41 <monochrom> I'm just waiting to pay now. :)
14:23:21 <monochrom> Haskell Platform used to be a no-brainer. There was that. It used to be unembarassing.
14:23:26 <merijn> monochrom: tbh, I think one of the problems is that it's hard to get people to pay you for maintenance if you don't have the time to work on it, but as long as you don't get paid it's hard to make time free for it
14:23:29 <maerwald> It's like a love drama... the haskell patient
14:24:02 <monochrom> Then people went partisan on even the technical but no big deal issue about "too many libraries in --global"
14:25:56 <maerwald> sm[m]: did you know that nix style local builds were planned/announced in cabal long before stack existed?
14:27:21 <sm[m]> no, and I'm not much interested
14:27:28 <monochrom> There was a bad timing, IMO it's bad luck, neither party/side was wrong.
14:28:06 <maerwald> sm[m]: the idea didn't come from stack. It just implemented it first.
14:28:07 <merijn> I dislike how things went down, but bring it up indefinitely only makes things worse, so people should just stop that.
14:28:16 <sm[m]> so ?
14:28:50 <sm[m]> execution is valuable, the stack folks cared about making getting started easier and contributed a lot to that
14:28:58 <monochrom> Haskell Platform's evolution coincide with the general internet programming students' transition from the python "batteries included" to the python (again) opposite "just lazily download dependencies"
14:28:58 <merijn> Even stack no agrees everyone should commit cabal files, so now we can all use whatever we like best and unite in scolding people who like hpack instead :p
14:29:11 <maerwald> sm[m]: nothing... just saying both problems and solutions were known already... it was merely a manpower problem
14:29:34 <sm[m]> even if cabal steals their ideas/code and becomes king again, it's valuable
14:29:51 <maerwald> stealing should be encouraged in open source
14:30:03 <maerwald> absolutely
14:30:45 <sm[m]> until there's a better alternative, we should not neglect to mention stack as an easy on ramp, especially for windows people
14:30:57 <maerwald> but tools like these are not cool codebases to work on, so they rot quickly, unless somehow company backed
14:30:57 <rotaerk> so, that ghcup page; is that something you personally maintain, or should I look into contributing a patch to it? (where is the source code for it anyway?)
14:31:27 <maerwald> rotaerk: https://gitlab.haskell.org/haskell/ghcup-hs/-/tree/master/www
14:31:50 <rotaerk> k ty
14:32:28 <monochrom> OK, I agree about pointing Windows non-WSL users to stack.
14:32:40 <monochrom> I can always stab stack some other day. This is not the day.
14:32:47 <rotaerk> not ghcups?
14:33:01 * rotaerk reads back.
14:33:02 <monochrom> Err OK I need to look into ghcups haha
14:33:09 <monochrom> I thought it was a typo!
14:33:18 <maerwald> sm[m]: honestly, by now these things are more or less the same in what you can do with them. Technlically. The only difference is the philosophy (e.g. unix). And it so happens that it's important for users. In a company setting, you don't really care
14:33:18 <rotaerk> it's ghcup + ps (powershell)
14:34:03 <monochrom> OK, normally I suggest chocolatey, but for ps reason people are shooting it down. I guess ghcups would not be immnue.
14:34:07 <sm[m]> maerwald: I don't think ghcup plus cabal are at the level of simplicity of stack for non power users yet
14:34:28 <glguy> stack slips in its complexity after getting GHC configured
14:34:30 <maerwald> sm[m]: yes, that's the difference of philosophy
14:34:38 <monochrom> Plus I have used neither so I really don't know.
14:34:43 <maerwald> unix tools you have to learn
14:34:52 <sm[m]> I don't think stack slips in any more complexity than cabal
14:35:04 <rotaerk> stack a multi-tool, doesn't really follow unix philosophy
14:35:17 <sm[m]> I'm speaking as someone who's been supporting new cabal and stack users since for a decade
14:35:26 <glguy> For most cases figuring out stack.yaml, resolvers, extra-deps is just extra work
14:36:01 <sm[m]> also I'm speaking mainly about "getting started with haskell". Common needs.
14:36:20 <rotaerk> the cabal user guide is pretty clear on what to do, step-by-step
14:36:38 <rotaerk> https://cabal.readthedocs.io/en/3.4/getting-started.html
14:36:46 <rotaerk> though the installation instructions could use some tweaks
14:36:47 <maerwald> after sm[m] made ppl clean up all the outdated cabal docs
14:36:50 <maerwald> :p
14:37:00 <maerwald> which were a lot
14:37:08 <sm[m]> rotaerk: not when you look at the big picture. Many versions of cabal. Multiple versions of commands within a cabal version. Wrong docs linked on the website. 
14:37:13 <sm[m]> etc.
14:37:21 <rotaerk> ah
14:37:30 <sm[m]> my cabal website PRs are still unmerged :(
14:37:32 <monochrom> rotaerk, maerwald: I think you should also steal one thing stack's website does. To point out that users will expect two programs, ghc and cabal, and why is that.
14:37:59 <sm[m]> stack's web presence, UX, and QA are still better overall
14:38:00 <rotaerk> yeah
14:38:11 <maerwald> yes and it's: person A has access to subpage 1, person B to subpage 2 and no one knows who is maintaining subpage 3... I feel that's haskell.org
14:38:54 <maerwald> and the few old-timers who did the work in the beginning are difficult to reach
14:39:01 <monochrom> stack's website state upfront "you will get: GHC (compiler); stack (xxx tool); a couple others (1-word purpose)".  Well, in ghcup's case you just have ghc and cabal, easy. :)
14:39:03 <sm[m]> I need to try mailing tibbe, I'll do that now
14:40:09 <monochrom> Oh hehe, thanks sm[m] for forcing updating cabal user's guide.
14:40:27 <rotaerk> what did that entail? a whip?
14:40:58 <monochrom> But "cabal version 3.5.0.0" is unthinkable :)
14:42:10 <sm[m]> tibbe mailed about the https://github.com/haskell/cabal-website/pulls , let's see if that gets a response
14:42:51 <monochrom> Does he even have time these days?
14:43:13 <sm[m]> I'm sure he doesn't, but "if you need something done, ask a busy person"...
14:43:22 <monochrom> haha
14:43:33 <monochrom> wouldn't work on me
14:44:08 <monochrom> I had like a 1-month backlog of assignment re-mark requests from students (and they were right) because I was busy.
14:44:41 <monochrom> Finally quickly processed a few days before their drop date. But totally had a backlog.
14:45:11 <monochrom> And only because there is such a thing as drop date that I felt responsible to process them in time.
14:45:13 <maerwald> back to reading conspiracy theories on r/haskell :p
14:45:22 <monochrom> In your case tibbe has no real deadline.
14:45:32 <monochrom> Oh, what conspiracy theory?
14:46:17 <monochrom> maybe I can just hop over there and see
14:46:44 <monochrom> why does reddit have this r/ prefix anyway?
14:46:57 <monochrom> haha "Hask Anything"
14:47:07 <merijn> monochrom: Because good URLs are hard
14:47:10 <Rembane> maerwald: This one? https://www.stephendiehl.com/posts/crypto.html
14:47:17 <dsal> r/ distinguishes from u/
14:47:24 <merijn> monochrom: More realistcally, to separate the user and subreddit urls
14:47:30 <maerwald> Rembane: :)
14:47:40 <monochrom> Oh, neat, that's smart.
14:49:26 <maerwald> Rembane: traditional currencies being properly regulated is... not really correct. That's where I already felt something is off
14:49:46 <maerwald> (see high-frequency trading)
14:51:13 <maerwald> but quite a big name-shoutout
14:51:19 <monochrom> Will someone please also write a similar article but s/cryptocurrency/machine learning/ :)
14:51:39 <Rembane> maerwald: I think currencies and how they work a big can of worms, Pandora sized, and I'm not sure I'm ready to open it. 
14:52:29 <monochrom> Pandora can of Medusa worms.
14:52:53 <monochrom> Pandora can of Medusa hydra worms.
14:53:10 <maerwald> Rembane: yes, there are different money systems possible. It starts with the fact that people don't know that "compound interest" is *not* something inherent to money, but to the *particular* money system we use
14:53:20 <monochrom> the hydra game :)  http://math.andrej.com/2008/02/02/the-hydra-game/#:~:text=A%20hydra%20is%20a%20finite,not%20grow%20any%20new%20heads.
14:53:39 <monochrom> hrm, or simply http://math.andrej.com/2008/02/02/the-hydra-game/
14:54:36 <maerwald> Rembane: and all of this reads so hugely oversimplified that I'm not sure you can even call it "wrong", because it doesn't talk about the problems properly in the first place
14:55:07 <Rembane> monochrom: I like the last Pandora can the most. 
14:55:09 <maerwald> and the name calling is a bit unfortunate
14:55:11 <Rembane> monochrom: Please don't open it! 
14:55:23 <monochrom> :)
14:55:26 <Rembane> maerwald: this = the thread on reddit or something else? 
14:55:34 <maerwald> the blog post
14:56:36 <monochrom> But also check out the hydra game, it's interesting ordinal / transfinite math.
14:56:53 <Rembane> maerwald: Got it. 
14:58:03 <maerwald> Rembane: and if your goal is fraud... why do you make all of your work open source and pay scientists to back everything up with peer-reviewed papers :p
14:59:08 <monochrom> I think cryptocurrency is a bubble, not a fraud.
14:59:46 <monochrom> I think if I say "fad" for bubble it's still right? Has been a long while last time I used/read the word "fad".
14:59:51 <Cale> It's both
15:00:08 <monochrom> I want to say that machine learning is in the same position, too.
15:01:02 <monochrom> A lot of people hear and think "it's cool, it's hot, let's all flock to doing it" and really only a few will succeed at the end.
15:01:05 <maerwald> Cale: you work on it too, no? :p
15:01:38 <Cale> Obsidian does, I'm not on any of those projects personally any more.
15:01:43 <merijn> monochrom: I think there's plenty of fraud too :p
15:02:04 <monochrom> yeah OK
15:02:10 <maerwald> fraud is wherever money is, doesn't matter which kind
15:02:22 <MarcelineVQ> the real horror of crypto is that once you understand it you see that fiat currency isn't any different
15:02:34 <monochrom> I bet a lot of grant proposal titled "xxx machine learning yyy" are frauds, too.
15:02:54 <monochrom> But both frauds are a consequence of bubble and fad.
15:02:55 <merijn> MarcelineVQ: It isn't any different, if we squint and ignore the huge systemic and cultural important, rules and enforcement we've built
15:02:59 <Cale> Well, fiat currency is different because it's backed by the fact that if you don't pay your taxes, the government will take things from you.
15:03:22 <merijn> "it's the same if we just ignore society exists!"
15:03:26 <monochrom> haha Cale
15:04:02 <monochrom> I think Cale nails it.
15:04:07 <Cale> Cryptocurrency doesn't have any real power keeping it valuable apart from breathless enthusiasm
15:04:29 <monochrom> Your home country concurrency is worth your trouble because you pay tax in it, you can't pay tax in bitcoin.
15:05:01 <monochrom> US dollar is worth your trouble because you buy crude oil with it, you can't pay in bitcoin or Canadian dollars.
15:05:08 <maerwald> can you even do tax evasion in cryptocurrency?
15:05:20 <maerwald> (if it was government crypto currency)
15:05:52 <Rembane> I wonder what would happen if you could buy crude oil with Bitcoin. 
15:06:01 <monochrom> Ah but cryptocurrency is worth the trouble for people who need that level of anonimity (for good or bad).
15:06:09 <merijn> monochrom: Eh
15:06:20 <merijn> monochrom: Most cryptocurrencies have zero anonymity...
15:06:24 <MarcelineVQ> Is it even anonymous? transactions are are public aren't they?
15:06:29 <merijn> Well, unless you buy them in cash offline
15:06:30 <Cale> Also, blockchain is a shitty database for almost any purpose.
15:06:50 <monochrom> Oh heh, well, this is why most people who enter a fad will lose, they don't even understand what it's about.
15:06:59 <merijn> But then you have to buy cryptocurrency in cash from the kind of people willing to accept large cash currency payments in real life for crypto
15:07:21 <monochrom> Ah, that, OK.
15:07:25 <merijn> Which seems like they'd be the kinda people to come to the meetup and leave with both the cash and the crypto
15:08:13 <monochrom> Well, my understanding of their thinking is they understand nothing is perfect, but they can always go through more steps to improve obfuscation.
15:08:20 <EvanR> dang... is this the right channel
15:08:30 <monochrom> OK!
15:08:32 <EvanR> 2009 called and want their bitcoins back
15:08:57 <Cale> EvanR: Everyone's talking about cryptocurrency stuff because of Stephen Diehl's post.
15:09:01 <EvanR> oh
15:09:36 <dsal> I didn't click that link.  Am I the last person who sees "crypto" and doesn't think we're talking about money?
15:09:46 <dolio> Does this one discredit the 'Haskell is too focused on correctness' post?
15:10:24 <monochrom> I think no.
15:11:03 <dolio> I mean, it was already obvious to me that that one didn't make sense.
15:11:33 <EvanR> "product not directly tied to economic activity" has anyone looked at wall street lately
15:12:17 <maerwald> nah... all properly regulated
15:12:17 <monochrom> This is why we all violently disagree with the article! :)
15:12:30 <EvanR> riiiight
15:13:56 <EvanR> also people set up and sell things an alien may find very questionable... WoW items, now D&D Beyond is selling designer virtual dice
15:14:10 <maerwald> what do you call it if the claims are not really wrong, but the narrative is really off? ...exactly... news!
15:18:04 <monochrom> onoes, "response from IOHK CEO"
15:18:18 <monochrom> now the real war begins
15:18:35 <EvanR> nice, yet another random thing linked to right wing extremism, that we must ban. Or else Haskell must be banned via a 3rd order link
15:19:04 <monochrom> What does nano mean by haskell syntax support? Does it mean I can finally recommend nano to my students?
15:19:06 <davean> cccccclknknvnheukffjktigbtcedbvgfhggefkdghji
15:19:40 <maerwald> davean: what's your cats name?
15:19:53 <monochrom> Hi davean is that your monocybercoin address? :)
15:22:17 <monochrom> onoes another "cabal install <library here>" problem
15:23:20 <maerwald> history repeats
15:24:20 <wz1000> Cryptocurrency solves a very important problem. I have $X of some very ill-gotten funds, what do I do with it? Why, just invent a new currency, award X of those tokens to me, and use my funds to prop up my new currency for as long as it takes, and magic...
15:26:21 <wz1000> If you're smart you might end up with $2X or even more
15:28:12 <EvanR> that's how ICOs work. Not "cryptocurrency"
15:32:23 <wz1000> ah yes, the crucial difference. "cryptocurrency" of course means all of the above, along with a fanatical quest to employ massive computing resources for the purposes of generating heat 
15:33:03 <maerwald> wz1000: that's PoW, not PoS
15:39:33 <HoolaBoola> I have this type class:
15:39:35 <HoolaBoola> class Price a where
15:39:38 <HoolaBoola>     price :: a -> Int
15:40:18 <HoolaBoola> Now, I want to apply that to a list of [Maybe a], where a is a type that has a default implementation for Price already
15:40:36 <HoolaBoola> I've tried this:
15:40:38 <HoolaBoola> instance Price [a] where
15:40:41 <HoolaBoola>     price (Nothing:xs) = price xs
15:40:43 <HoolaBoola>     price ((Just x):xs) = price x + price xs
15:40:44 <EvanR> also I could take the opportunity to say that there's like crystal domain boundary between the way "investors" work in "tech" and the way normal investors work. No serious investor I know would touch ICOs. I can totally imagine tech people throwing money at anything
15:40:56 <HoolaBoola> But the compiler doesn't like the "Just x"
15:41:13 <HoolaBoola> Anyone have any idea what I'm doing wrong?
15:41:20 <EvanR> so whatever is wrong with haskell is wrong with tech, I would bet
15:41:43 <Cale> HoolaBoola: Well, you're only writing the instance for lists, not lists of Maybes
15:42:00 <Cale> HoolaBoola: So perhaps you just want price xs = sum (map price xs)
15:42:02 <HoolaBoola> Hmm
15:42:32 <HoolaBoola> Should the instance definition be "instance Price [Maybe a] where"?
15:42:33 <Cale> HoolaBoola: and then perhaps  instance Price a => Price (Maybe a) where price Nothing = 0; price (Just x) = price x
15:42:57 <Cale> (you'll also want a "Price a =>" constraint on your instance for lists
15:42:58 <Cale> )
15:43:11 <HoolaBoola> Ah
15:44:19 <HoolaBoola> So I was just missing stuff?
15:45:15 <Cale> Your code looks like you expected to be writing  instance Price a => Price [Maybe a]
15:45:30 <Cale> which you could write, given the FlexibleInstances extension
15:45:39 <Cale> but it's probably easier just to do it in two steps
15:45:44 <HoolaBoola> Okay
15:46:10 <HoolaBoola> Yes, the compiler said something about flexible instances, but I think I won't touch those yet
15:46:41 <Cale> That's one of the least worrisome language extensions, but in this case, you only miss out on some potentially useful instances by turning it on
15:47:32 <HoolaBoola> Yes! got it, thanks Cale :)
16:10:14 <wz1000> haha the youtube comments on the IOHK response video are simply perfect
16:19:22 <dolio> I think the channel's probably had enough of that topic.
16:33:30 <zeta_0> i got ghcide lsp to load on a haskell file, but it's throwing this error: `no such file or directory`
16:33:39 <zeta_0> how do i troubleshoot this?
16:42:41 <hpc> is that the entire error?
16:44:05 <dsal> zeta_0: try 'touch such' or 'mkdir such'
16:44:23 <monochrom> aww
16:58:08 <zeta_0> ok i'm back, i got ghcide to work with ghc.nix(https://github.com/alpmestan/ghc.nix), when open a file the hie lsp gets activated, but ghcide returns: `no such file or directory`, so i'm not sure how to troubleshoot this.
16:58:44 <zeta_0> they told me i do not have to change the hie.yaml file, so i'm not sure what else to do.
18:01:04 <kraeXen> anyone know how I might append type `[ [ (String, X () ) ] ]` to `[ ( [Char], X () ) ]` (take [ [ a, b ], [ c, d] ] and add it to [ [ e, f ] ] so it becomes [ [ e, f ], [ a, b ], [ c, d ] ])?
18:02:49 <dsal> Those things don't mean the same thing.
18:03:20 <dsal> Or maybe they do and I'm just having a hard time reading.
18:03:32 <dsal> Do you just mean `:`?
18:03:54 <dsal> > 'x' : ['a', 'b', 'c']
18:03:56 <lambdabot>  "xabc"
18:04:43 <kraeXen> > ["ab", \x -> 0] : [ ["cd", \x -> 1] ]
18:04:45 <lambdabot>  error:
18:04:45 <lambdabot>      • Couldn't match expected type ‘[Char]’
18:04:45 <lambdabot>                    with actual type ‘p0 -> Integer’
18:04:49 <kraeXen> nope
18:04:53 <kraeXen> but similar
18:05:17 <kraeXen> really just take an array of items and add each to the specified array
18:05:47 <kraeXen> this is what I've made (doesn't work yet)
18:05:48 <kraeXen> `dynamicKeys modif first list = map (\x -> mkeys <> [(modif ++ "-" ++ first ++ " " ++ x ++ k, f) | (k,f) <- list ]) ["", modif ++ "-"]`
18:06:19 <kraeXen> and I call it like so:
18:06:19 <kraeXen> `[] ++ dynamicKeys blah`
18:06:58 <dsal> Oh, is this an array?
18:07:15 <dsal> It'd be easier if you abstracted the names a bit.
18:08:05 <kraeXen> an array of arrays that I need to add another array of arrays inside of
18:08:10 <dsal> The thing you had there before looked like `[[(a,b)]]` and `[(a,b)]` Which is `[a]` and `a`.  And you want to put the second one in front of the other.
18:08:23 <dsal> Are these arrays?  Are you using OverloadedLists?
18:08:30 <dsal> I don't recommend OverloadedLists -- it causes a lot of confusion.
18:09:46 <kraeXen> I don't think so
18:10:09 <dsal> Then those aren't arrays.
18:10:23 <kraeXen> well maybe, heck I'm new at this
18:11:16 <dsal> If you have `[a]` and `[a]` you can combine them with `<>`.  If you have `[a]` and `a`, you can combine the latter with `:`
18:13:53 <kraeXen> ah, that's what <>'s for, thanks
18:14:13 <kraeXen> but, I ended up using concat, that's what I needed
18:20:04 <Axman6> > [("ab", \x -> 0)] : [ ["cd", \x -> 1] ]  -- kraeXen did you mean this?
18:20:06 <lambdabot>  error:
18:20:06 <lambdabot>      • Couldn't match expected type ‘([Char], p -> p1)’
18:20:06 <lambdabot>                    with actual type ‘[Char]’
18:20:28 <Axman6> > [("ab", \x -> 0)] : [ [("cd", \x -> 1)] ]  -- kraeXen did you mean this? -- Axman6 did you mean this? :)
18:20:30 <lambdabot>  error:
18:20:31 <lambdabot>      • No instance for (Typeable p0)
18:20:31 <lambdabot>          arising from a use of ‘show_M774024300645989890232048’
18:21:44 <kraeXen> > [("ab", \x -> 0)] ++ concat [ [("cd", \x -> 1)] ]
18:21:45 <lambdabot>  error:
18:21:45 <lambdabot>      • No instance for (Typeable p0)
18:21:45 <lambdabot>          arising from a use of ‘show_M239579995288457041132072’
18:22:37 <kraeXen> > [ ("ab", 0) ] ++ (concat [ [ ("cd", 1) ] ])
18:22:39 <lambdabot>  [("ab",0),("cd",1)]
18:22:41 <kraeXen> that
18:22:51 <kraeXen> that's what I did
18:23:20 <Axman6> that's just  ("ab", 0) : concat [[("cd", 1)]]
18:23:32 <kraeXen> is it?
18:23:35 <kraeXen> > ("ab", 0) : concat [[("cd", 1)]]
18:23:38 <lambdabot>  [("ab",0),("cd",1)]
18:23:42 <kraeXen> huh, thx
18:23:47 <Axman6> yes, [x] ++ xs === x:xs
18:24:01 <Axman6> @src (++)
18:24:02 <lambdabot> []     ++ ys = ys
18:24:02 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
18:24:02 <lambdabot> -- OR
18:24:02 <lambdabot> xs ++ ys = foldr (:) ys xs
18:25:51 <kraeXen> > [("ab", \x->1)] : [[("cd",\x->2)]]
18:25:52 <lambdabot>  error:
18:25:53 <lambdabot>      • No instance for (Typeable p0)
18:25:53 <lambdabot>          arising from a use of ‘show_M878527760527072400032165’
18:26:02 <Axman6> :t (:)
18:26:03 <kraeXen> hm, yea that's not quite it
18:26:04 <lambdabot> a -> [a] -> [a]
18:26:05 <Axman6> :t (++)
18:26:06 <lambdabot> [a] -> [a] -> [a]
18:26:09 <kraeXen> but I got it
18:29:31 <kraeXen> what might be the reverse of ':'?
18:29:35 <kraeXen> as in
18:29:45 <kraeXen> [a] -> a -> [a]
18:30:52 <kraeXen> not quite reverse
18:31:03 <kraeXen> but close
18:31:11 <ChaiTRex> kraeXen: There's either `flip (:)` or `(\ xs x -> xs ++ [x])` depending on which end you want to put the `a` on.
18:32:05 <kraeXen> > "a" : ["c","d"]
18:32:07 <lambdabot>  ["a","c","d"]
18:32:43 <kraeXen> > ["a","b"] : "c"
18:32:44 <ChaiTRex> > flip (:) ["c", "d"] "a"
18:32:45 <lambdabot>  error:
18:32:45 <lambdabot>      • Couldn't match type ‘Char’ with ‘[[Char]]’
18:32:45 <lambdabot>        Expected type: [[[Char]]]
18:32:46 <lambdabot>  ["a","c","d"]
18:33:06 <kraeXen> ah, thx
18:33:09 <ChaiTRex> > (\ xs x -> xs ++ [x]) ["c", "d"] "a"
18:33:11 <lambdabot>  ["c","d","a"]
18:33:37 <kraeXen> :t (flip :)
18:33:39 <lambdabot> [(a -> b -> c) -> b -> a -> c] -> [(a -> b -> c) -> b -> a -> c]
18:33:51 <Axman6> :t flip (:)
18:33:52 <lambdabot> [a] -> a -> [a]
18:34:10 <Axman6> thyou almost certainly aren't after (flip :)
18:34:47 <kraeXen> hah, ya
19:29:53 <p0a> Hello 
19:30:02 <p0a> I am trying to follow the megaparsec tutorial 
19:30:35 <p0a> I am at the step where I am going to test the first combinator (satisfy), so I need to start ghci and import some modules
19:31:14 <p0a> I import the Megaparsec modules and then the tutorial also requires that I `import Data.Text (Text)', however I get the error that it is a hidden package of `text-1.2.4.0'
19:31:30 <p0a> Sorry, `a member of the hidden package text-1.2.4.0'
19:31:40 <sm[m]> hi p0a. How are you starting ghci ?
19:31:50 <p0a> sm[m]: `stack ghci' in the project directory
19:32:05 <sm[m]> do you have a package.yaml file ?
19:32:17 <p0a> Yeah I only added `- megaparsec' after base
19:32:33 <sm[m]> add - text as well
19:32:50 <p0a> wow! okay :)
19:33:17 <p0a> You are right sm[m], can you explain a bit about this?
19:33:35 <sm[m]> even though it might be installed on your machine, stack considers it hidden unless you've declared it explicitly as a dependency. (cabal too)
19:33:45 <sm[m]> this makes things more predictable and repeatable
19:34:13 <p0a> Thanks, for some reason I take these common modules for granted. That's why I didn't even realize I had to include text
19:34:21 <monochrom> If you import X then you need to tell stack which package X comes from. For namespace cleaniness stack won't expose a module otherwise.
19:34:27 <sm[m]> otherwise it'd work for you, then break for someone else
19:34:59 <sm[m]> yes unfortunately (?) a lot of common batteries you'll want require both extra imports and extra package dependencies
19:35:13 <sm[m]> unless you use a big batteries-included library like rio
19:36:56 <p0a> nice, thank you again. I'll read some more on the Megaparsec now
19:37:06 <p0a> (rio looks nice)
20:16:40 <hyiltiz> rio is considered big? 
20:17:11 <hyiltiz> Any of these https://guide.aelve.com/haskell/alternative-preludes-zr69k1hc that are not too big and still relevant?
20:18:19 <hyiltiz> When testing out ideas in GHCi, I usually have to import functions from Data.List, Control.Monad etc.
20:18:26 <hyiltiz> Applicative 
20:18:54 <hyiltiz> Quite a few of these alternative preludes (like rio, relude etc.) all seem to import these commonly used functions by default
20:19:57 <hyiltiz> I wonder why Prelude doesn't already include stuff like liftA2, liftM etc.
20:21:32 <sm[m]> it's old hyilitiz, some of these things weren't worked out yet
20:22:31 <sm[m]> oh, aelve is no longer growing
20:24:15 <p0a> what does `combinator' mean?
20:24:19 <MarcelineVQ> a .ghci file can do all your common imports for ghci play anyway
20:24:44 <sm[m]> ha MarcelineVQ , and quietly break your projects too
20:24:44 <dmj`> p0a: there's two definitions, one is more formal, the other is a way to combine functions to produce a new function
20:25:01 <dmj`> p0a: like "monadic parser combinators". 
20:25:25 <dmj`> p0a: a parser combinator can be made from other parser combinators, etc
20:25:34 <p0a> ah I see 
20:25:58 <sm[m]> and concretely here, it means function, often with a short or operator-style name
20:30:05 <hyiltiz> data %>% bind_columns(summarize(., m=mean(.$col1), summarize(., m=mean(.$col1))
20:30:20 <hyiltiz> The above is "psudocode" from R's tidyverse DSL
20:30:50 <hyiltiz> Data is "piped" thru, and still can be referred to with the dot . and can be referred to multiple times
20:31:55 <hyiltiz> can also be used in a style similar to the pointfree style like  `data %>% plot(x=x, y=x)` where . is transferred to plot() as its first input arg implicitly
20:32:30 <hyiltiz> This example looks like a pipe, while the first example (syntactically) looks like a branch
20:33:00 <hyiltiz> Is Arraws the closest and most straightforward way to use this notation/DSL in Haskell?
20:42:57 <sm[m]> reminder: https://haskell.love conference starts in a little over 3h
20:44:20 <sm[m]> day 1 is in EU time, day 2 is in US time. That's clever
20:47:01 <ddellacosta> wow I had no idea, that's neat
20:47:26 <ddellacosta> I had trouble with zurihac because of the time diff, although was cool I could join at all
20:48:49 <p0a> is the love conference just watching the speakers talk or also talking to others?
20:49:21 <ddellacosta> looks like a twitch stream, so I guess there's chat?
20:49:53 <p0a> so you need a twitch account?
20:50:20 <p0a> I was just locked out of my gmail when I travelled into Europe
20:50:30 <ddellacosta> oh and a slack too looks like. I dunno about twitch, never used it, but I'd assume so
20:50:42 <p0a> (somewhat irrelevant...)
20:50:52 <ddellacosta> that sucks
20:51:18 <p0a> well it's for a silly reason, they demand a phone # and I don't understand why I need to dish out the $ for one to operate an email 
21:07:14 <sm[m]> twitch, slack, and some spatial chat thing
21:07:47 <sm[m]> which is the "hallway track"
21:08:29 <p0a> sm[m]: in the registration it requires contact info and Haskell Friend (lover? something like that) contact info
21:08:37 <p0a> Is that the same in my case (just me?)
21:09:05 <sm[m]> yes that's you I assume
21:09:30 <sm[m]> you're not required to bring a lov-ah
21:10:57 * sm[m] flashbacks to https://www.youtube.com/watch?v=gqeQLV04kwU
21:56:13 <p0a> megaparsec seems to be a lot of fun 
21:56:28 <p0a> after I read the URI tutorial I will try to write some parsers for some toy languages I know
22:13:30 <p0a> thanks for your help 
22:27:52 <loop> ????w杙3sj?? D@? b????????]Yff?@c???????????????????PfN8;e3?v??2uA?yk?????EI?$hP<d6???4?+??????????g}?!??????CIG?P>?#?J??l?z???ۃ??Oz??C?&:?Ng?l"
22:27:54 <loop> o,??Ov???ަ?nm?^^?
22:27:58 <loop> Ocv???ɱ??ͱu?????tu??I?bc?aq]l??K{z????F??+~n???8??????4ȾN???\????M+yޫ?Wă-?K???E???HHL#;??L?)?????5???BSh֒
22:28:02 <loop> A6;??????&?ϱ???~?a/?on????1ͷzHpl-???׃???f??y???9?%???J?MO^???????9J???????8o???????{?=?@?Cdj`xksdE*(4????!?
22:28:04 <loop> ;͙
22:28:06 <loop> ??y>pŵN?GIv
22:28:16 <loop> }??????????3&*.? ????Ho?r??Ұlߛ~??QD?aY(e>:ύ??4??t???Cm{D:???&f/ۂ????=4?
22:28:22 <loop> p?%ˁ?????kO\) 9)p???_?7
22:28:24 <loop> ??03*/???Ph?F????'???g?l"
22:34:07 <hyiltiz> loop: your encoding seem to be wrong; all I see is question marks and unrepresentable glyphs
22:34:15 * Axman6 cat /dev/urandom > glirc2
22:34:16 <hyiltiz> fix ur client before u get banned
22:34:59 <hyiltiz>  cat /dev/urandom > glirc2
22:35:04 <hyiltiz> $ cat /dev/urandom > glirc2
22:35:09 <hyiltiz> % cat /dev/urandom > glirc2
22:35:10 <yahb> hyiltiz: ; <interactive>:1:6: error:; * Variable not in scope: dev :: [Doc] -> Doc; * Perhaps you meant `div' (imported from Prelude); <interactive>:1:10: error:; * Variable not in scope: urandom :: [Doc] -> Doc; * Perhaps you meant one of these: `random' (imported from System.Random), `randomR' (imported from System.Random), `randoms' (imported from System.Random); <interactive>:1:20: error: Va
22:35:19 <hyiltiz> not sure what u r suggesting Axman6
22:35:53 <Axman6> I'm suggesting that that was not not infact a human trying to communicate with us, but some random data accidentally sent to the channel
22:36:29 <hyiltiz> how du k?
22:36:38 <hyiltiz> it says no such nick for loop
22:36:53 <hyiltiz> Is it a special "device" bot for the channel?
22:37:05 <alehander92> morning
22:41:53 <Axman6> hyiltiz: their client quit immediately after the last message
22:42:08 <Axman6> afternoon alehander92
22:42:09 <loop> i apologize for the spam, my client was acting out.
22:42:42 <Axman6> loop: I was curious where that data came from - did you paste a binary into IRC? :P
22:43:03 <loop> it overflowed when i tried connecting to a server on the wrong port lol
22:43:58 <hyiltiz> how does WeeChat "overflow"?
22:44:39 <loop> no idea, it happened to all the open buffers.
23:04:42 <Arahael> loop: Did you report it to #weechat?
23:05:17 <loop> i did not
23:27:04 <laudecay1> hello! is there a way to define a type that is a certain defined number of bits long
23:27:07 <laudecay1> other than a tuple
23:27:18 <laudecay1> or is that something i need idris for
23:28:26 <dsal> You mean like an array?
23:28:52 <laudecay1> yeah
23:28:55 <laudecay1> like in rust
23:29:29 <laudecay1> im currently building a whole lot of boolean circuit functions that i need to hook together nicely
23:29:57 <laudecay1> and i was trying to lean on rust types for that and then i realized function types weren't as rich as they are in haskell
23:30:11 <laudecay1> and like polymorphism for that etc
23:30:34 <Orbstheorem> Hello o/ I've heard '<*>' been called ufo, is there a funny name for '<$>'? 
23:31:11 <Orbstheorem> laudecay1: Bounded? But there is no runtime check, so you still have to code that yourself. 
23:31:19 <laudecay1> oof
23:40:57 <MarcelineVQ> obfusk: anti-snake-ufo
23:41:02 <MarcelineVQ> *Orbstheorem
23:41:27 <MarcelineVQ> maybe Interstellar Worm Patrol Vehicle
23:45:02 <Orbstheorem> awesome xD
23:45:12 <MarcelineVQ> laudecay1: vector-sized provides vector(arrays) with type-enforced sizes, idk how easy they are to work with in haskell though, possibly not too bad if you never change the size
23:47:09 <MarcelineVQ> Says it keeps that size info at runtime though, so if that matters to you it's not going to cut it
23:48:19 * MarcelineVQ press f
