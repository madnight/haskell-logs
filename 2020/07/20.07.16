00:02:10 <f-a> I am correctly in saying Typeable works only for concrete types and not polymorphic ones?
00:02:15 <f-a> *Am I
01:14:30 <maerwald> glguy: gitlab link changed?
01:14:37 <maerwald> then it's busted
01:54:51 <Orbstheorem> Hi o/ I'm using persist. I have an entity vector (which contains the entity as retrieved by the DB and the target entity as updated by the app). I would like to emit an _UPDATE SET ...(data from the target entity) WHERE ...(data from the original entity)_.
01:56:19 <Orbstheorem> I would like to use `update` But all the Filter and Update functions take an EntityField, not an entity. I wonder if there's a better solution other than listing every field of my entities.
01:59:39 <Orbstheorem> The second result is just as enlightening.
01:59:48 <Orbstheorem> (Oups, wrong chat, sorry)
02:36:15 <phadej> f-a: that saying is very imprecise
02:36:31 <phadej> but yes, there is not Typeable (forall a. ..)
02:36:47 <f-a> I am all ears phadej 
02:36:49 <phadej> but there is forall a. Typeable a => Dict (Typeable (List a))
02:36:53 <f-a> oh
02:36:54 <f-a> ohhh
02:37:19 <nlhowell> I'm trying to use Data.Equivalence.STT (https://hackage.haskell.org/package/equivalence-0.3.5/docs/Data-Equivalence-STT.html), but I'm not quite sure how to select the type for the state space
02:37:58 <nlhowell> can someone provide guidance on how that works?
02:38:03 <phadej> if you know the type(rep) of the element, you know the type(rep) of the lists of that elements
02:39:11 <phadej> "concrete" is imprecise. I'd say monomorphic
02:39:25 <phadej> but I'm not sure whether that correct either
02:40:03 <phadej> and as Typeable is polykinded
02:40:11 <phadej> i.e. there is Typeable [] -- note, no element
02:40:17 <phadej> it's all somewhat complicated
02:41:55 <f-a> what is even `[]`
02:42:35 <phadej> type constructor
02:46:27 <f-a> why can there be `Typeable []` and not, say `-> a`
02:46:48 <f-a> `-> Int`, rather
02:55:33 <merijn> f-a: Because 'Typeable :: * -> Constraint', not '(* -> *) -> Constraint'
02:58:05 <f-a> thanks
02:59:47 <kuribas> > 1e23
02:59:49 <lambdabot>  9.999999999999999e22
02:59:59 <kuribas> !
03:00:11 <kuribas> the printer is wrong
03:00:47 <kuribas> in lisp: 1.0d23 => 1.0d23
03:01:37 <merijn> kuribas: No
03:01:45 <merijn> kuribas: You're just relying on wrong defaulting
03:01:55 <merijn> i.e. it defaults to Double
03:01:57 <kuribas> > 1e23 :: Double
03:01:59 <lambdabot>  9.999999999999999e22
03:02:04 <kuribas> merijn: I want double...
03:02:10 <Taneb> merijn: in recent bases, Typeable is polykinded, "k -> *"
03:02:16 <Taneb> I mean, "k -> Constraint"
03:02:17 <merijn> Taneb: Ah
03:02:27 <kuribas> merijn: the lisp also returns double
03:02:35 <merijn> kuribas: Does it, though?
03:02:40 <[exa]> > 1e23 :: Float
03:02:42 <lambdabot>  1.0e23
03:02:44 <merijn> It pretty prints a double in the same formatting as you wrote
03:02:46 <[exa]> less is more!
03:02:58 <merijn> Is it *actually* printing the value, though?
03:03:29 <kuribas> merijn: what else?
03:03:31 <Taneb> f-a: "-> Int" isn't really a thing you can talk about in isolation very well
03:03:42 <phadej> merijn: Typeable :: k -> Constraint
03:03:47 <kuribas> Flip (->) Int ?
03:03:49 <Taneb> There is an instance for "Int ->", or as it's actually written "(->) Int"
03:03:56 <merijn> kuribas: Almost every single programming language rounds its printing
03:04:02 <merijn> kuribas: (of doubles)
03:04:10 <Taneb> kuribas: if that's a type synonym it's an error, if it's a newtype it's a different type
03:04:10 <f-a> (->) Int, right
03:04:18 <kuribas> merijn: then you'd expect 1e23 right?
03:04:22 <merijn> kuribas: You cannot rely on printed decimal representation of Double to *actually* tell you the value
03:04:28 <Taneb> > typeRep (Proxy :: Proxy ((->) Int))
03:04:31 <lambdabot>  (->) 'LiftedRep 'LiftedRep Int
03:04:36 <merijn> kuribas: That depends, is 1e23 accurately representible by double?
03:04:39 <kuribas> merijn: you *should* rely on it.
03:04:44 <[exa]> > 1e23 == 9.999999999999999e22 -- kuribas
03:04:46 <lambdabot>  True
03:05:12 <kuribas> merijn: the *double float* 1e23 is not the same as the Integer 10^23
03:05:29 <kuribas> merijn: however 1e23 should be a single representable floating value
03:05:44 <Taneb> > typeRep (Proxy :: Proxy Functor)
03:05:46 <lambdabot>  Functor
03:05:50 <kuribas> [exa]: but why doesn't it print 1e23?
03:05:55 <merijn> kuribas: I'm not convinced
03:06:11 <[exa]> kuribas: because it prints precisely
03:06:23 <kuribas> [exa]: not really
03:06:38 <merijn> kuribas: On what basis do you say "1e23 should be a single representable floating value"?
03:06:42 <merijn> That's not obvious to me
03:06:42 <f-a> ok, so my intuition was quite wrong, excellent
03:06:48 <kuribas> merijn: on the IEE standard?
03:07:02 <[exa]> kuribas: in fact it should write something like "Yeah guys the value is something between 9.9999999999999e22 and 1.0000000000002e23"
03:07:44 <kuribas> [exa]: the printed floating point value isn't the mathematical value
03:07:49 <[exa]> kuribas: base cause is that multiples of primes other than 2 are not exactly representable in floats
03:08:07 <kuribas> [exa]: it's the closest float to that value
03:09:11 <merijn> kuribas: Based on what part of the IEEE standard, exactly?
03:09:13 <kuribas> [exa]: or it's what you get when you round the mathematical value to the float, using the default rounding mode.
03:09:32 <kuribas> merijn: I don't know
03:09:58 <[exa]> kuribas: well, the representation seems to be closer to 9.99999999999 than to 10
03:10:15 <kuribas> [exa]: which?
03:10:25 <merijn> kuribas: Right, because it doesn't guarantee anything about decimal representations of floats and the only guarantee provided by specs that I'm aware of is that the "decimal representation should be unique" (i.e. result in the same float when read back)
03:10:31 <merijn> > 1e23 == 9.999999999999999e22
03:10:33 <lambdabot>  True
03:10:43 <merijn> kuribas: And they certainly appear to match that criteria
03:11:15 <kuribas> merijn: the representation isn't specified?
03:11:30 <merijn> kuribas: The *binary* representation of a float is specified
03:11:37 <merijn> kuribas: The decimal rendering of it is not
03:11:42 <kuribas> merijn: so show . read != id ?
03:12:01 <merijn> Yes, no, maybe
03:12:05 <[exa]> >  [9.999999999999998e22,9.999999999999999e22,1.00000000000000016e23,1.00000000000000017e23] -- kuribas: illustration
03:12:06 <lambdabot>  [9.999999999999997e22,9.999999999999999e22,1.0000000000000001e23,1.000000000...
03:12:23 <[exa]> kuribas: long story short, do NOT rely on approximations when you do not want approximations
03:12:41 <merijn> kuribas: You cannot ever rely on that identity, no
03:13:06 <merijn> kuribas: If you need an *exact* string representation of floats, you need hexfloat representation (which was added for exactly that and is fully specified)
03:13:23 <merijn> Of course, then you're still hosed as there is currently no way to read hexfloats in GHC :p
03:15:21 <merijn> kuribas: Incidentally, the same problem exists in every language, there's just a bunch (like python and presumably your lisp) that do "extra" prettification when printing, hiding those problems in common cases
03:16:45 <[exa]> oh noes, python prints 9.999999999999999e22 as 1e+23
03:16:47 <kuribas> merijn: we need reproducability, that dividing an int by a float gives the same result.
03:17:13 <[exa]> kuribas: the result _is_ same
03:17:33 <kuribas> on different platforms, languages
03:17:42 <kuribas> as long as they implement IEEE standard
03:17:44 <[exa]> yes
03:18:41 <merijn> kuribas: You just can't rely on decimal printing of that result
03:19:07 <kuribas> merijn: we don't
03:19:17 <merijn> kuribas: The conversion from int to float is deterministic, as is the division by two floats*
03:19:36 * anhmv
03:19:42 <merijn> * - this requires you compile your C code with exact IEEE-754 semantics and not extended precision or your hosed
03:20:01 <merijn> I'm not sure whether GHC does extended precision too, you'd have to check
03:20:24 <kuribas> merijn: currently we're lisp and java though...
03:20:37 <merijn> kuribas: Then you need to check in those too
03:20:58 <merijn> A colleague of mine spend 3 weeks tracking down why a deterministic simulation wasn't
03:21:19 <merijn> The end result was "extended precision meant that context switching, intterupts and the scheduler changed the results"
03:21:54 <kuribas> merijn: I am thinking if a software implementation of our division isn't a good idea (using integers).
03:22:07 <kuribas> it will be deterministic for sure.
03:22:20 <merijn> kuribas: Incidentally, helpful: https://evanw.github.io/float-toy/
03:22:28 <merijn> kuribas: It'll also be slow as fuck, though ;)
03:23:17 <kuribas> merijn: maybe it can be sped up with lookup tables...
03:23:27 <kuribas> merijn: since we only divide by factors of ten
03:23:46 <[exa]> kuribas: what's the problem with replacing the floats by integers then?
03:24:18 <kuribas> [exa]: the output is floats
03:24:59 <[exa]> kuribas: you only do exact operations, require exact results, and throw an inexact floating grenade right under your foot, y tho? :]
03:25:38 <[exa]> chances are that with a bit of assembly the integer ops will be even faster than floats
03:43:12 <tdammers> kuribas: on modern hardware, lookup tables are often a great way to slow things down in horrible ways
03:43:33 <tdammers> they tend to ruin branch prediction and CPU cache performance
03:43:42 <[exa]> +1
03:49:43 <maerwald> tdammers: how you doin
04:18:54 <__monty__> Reading hexadecimal floating literals isn't in base (yet), the FloatingHex package does provide reading though iirc.
04:24:54 <__monty__> merijn: A Float-Toy that includes hexadecimal floating representation would be awesom.
04:35:02 <NewToHaskell> How do I invoke the debugger/debug function when I've imported it into my script? =)  
04:35:13 <NewToHaskell> in ghci
04:35:28 <NewToHaskell> simple-reflect one
04:37:33 <maier> Is there package with functions that let me check for running system processes (on a Linux host) by name and, if any are found, stop/kill them?
04:40:58 <merijn> @hackage unix
04:40:58 <lambdabot> https://hackage.haskell.org/package/unix
04:40:59 <merijn> ?
04:41:02 <merijn> Presumably
04:47:41 <maerwald> yes, it's awesome
04:47:48 <maerwald> including the pain
04:49:32 <NewToHaskell> Can I import something with functions that compare the compute times of my functions? =)  
04:50:18 <merijn> NewToHaskell: Comparing the compute time of code in ghci is kinda pointless, because it's not representative of compiled code
04:50:31 <merijn> NewToHaskell: ghci uses a bytecode interpreter, rather than the actual compiled code GHC produces
04:58:27 <maier> merijn: thanks, checking it out :)
05:02:26 <NewToHaskell> `:set +s` command in ghci will apparently show the time and space used for subsequent computations.
05:12:59 <JavaSucksMan> in ghci, is there a way to tell if an expression is in WHNF? Something like  :: (a -> IO Bool)
05:14:49 <[exa]> by expression, you mean a variable bound in let-binding?
05:19:25 <tdammers> maerwald: mighty fine
05:21:50 <JavaSucksMan> for example:  let units = repeat ()
05:21:57 <JavaSucksMan> take 3 units
05:22:56 * hackage ghc-lib-parser 8.8.4.20200716 - The GHC API, decoupled from GHC versions  https://hackage.haskell.org/package/ghc-lib-parser-8.8.4.20200716 (shayne_fletcher)
05:23:36 <JavaSucksMan> take 5 $ mapM isWHNF units
05:23:56 * hackage ghc-lib 8.8.4.20200716 - The GHC API, decoupled from GHC versions  https://hackage.haskell.org/package/ghc-lib-8.8.4.20200716 (shayne_fletcher)
05:23:57 <JavaSucksMan> [True, True, True, False, False]
05:24:16 <maier> phew, first time I'm doing some more stuff with concurrency in Haskell. I use `forkIO` to run something in the background. Now if I `error "foo"` in the "thread" that called `forkIO`, (how) can I ensure that everything I forked crashes "with me"?
05:24:36 <maier> sorry for being vague; that's the missing comprehension speaking :)
05:26:59 <phadej> use `async`
05:27:13 <phadej> then, when you wait for it, exception will propagate
05:27:38 <phadej> i.e. that is what you would implement manually anyway, so use library written by someone who knows what they are doing ;)
05:34:47 <Peter54> quick question - does the update (//) function in the Data.Vector package run in constant time when updating 1 element? The documentation seems to say that it runs in linear time, but I've just read an article which seems to say it runs in constant time
05:37:19 <mcctor> What's the best learning resource for Haskell currently?
05:40:25 * hackage ghc-lib-parser-ex 8.8.6.1 - Algorithms on GHC parse trees  https://hackage.haskell.org/package/ghc-lib-parser-ex-8.8.6.1 (shayne_fletcher)
05:41:16 <maier> phadej: ha, I see your name on the hackage page :D
05:42:31 <__monty__> mcctor: Depends a bit on your background. For absolute beginners Haskell From First Principles is often recommended, though from what I hear the Hutton book is really good. For less beginners CIS194 seems very popular. And for someone already pretty familiar with functional programming there's the Gentle Introduction. https://www.haskell.org/documentation/ has more.
05:42:32 <phadej> people on #haskell and people writing haskell (published on Hackage) are (surprisingly!!!) not disjoint sets
05:43:26 <maier> phadej: thanks! It's the other way round for me though: the thing I `forkIO` runs an endless loop (it's basically fire-and-forget except for the exception case here), and the main thread does as well. The main thread could crash and I'd like the other loop to die with it.
05:43:37 <JavaSucksMan> mcctor: I'd recommend "Learn You a Good Haskell" for lighter-weight, or "Real World Haskell" (I learned from Hutton)
05:44:31 <maier> I could probably use some `catch` variant one function higher-up and throw an exception to the forked loop (with `async` or without it) but I'm wondering if there's a better solution.
05:46:24 <phadej> maier: spawn two asyncs, and maybe one of https://hackage.haskell.org/package/async-2.2.2/docs/Control-Concurrent-Async.html#v:waitEither variants is waht you want re exceptions
05:46:44 <phadej> or rather `concurrently`
05:46:49 <phadej> https://hackage.haskell.org/package/async-2.2.2/docs/Control-Concurrent-Async.html#v:concurrently
05:46:57 <phadej> read through the docs
05:47:03 <phadej> don't try to do it yourself
05:47:21 <phadej> most likely there is a combinator
05:48:56 <maier> phadej: yeah, this looks great. I could also probably `link2` the Asyncs
05:49:06 <maier> it seems to do exactly what I want
05:51:18 <int-e> Hmm, it would be fun if one could write [a, b | ...] (which could translate to concat [[a, b] | ...])
05:54:57 <phadej> yeah, it's somewhat better than [ x | ..., x <- [a, b] ]
05:55:03 <phadej> but not that much
06:19:24 <fog> im reading about open recursion here; https://www.well-typed.com/blog/2018/03/oop-in-haskell/
06:19:35 <fog> the example they use is the factorial using fix
06:20:02 <fog> redefining a recursive function, to take replace its recursive call with a supplied function
06:20:12 <fog> however, i never define any recursive function
06:20:21 <fog> since higher order functions are used instead
06:20:41 <fog> how do we reconcile the power of fix, with that of patterns like fold and unfold?
06:21:27 <fog> are there cases when one should be used instead of the other? can both be used together?
06:23:30 <fog> i understand that use of fix, with open recursion, is used to "extend" a recursive functions implementation after it is written
06:23:49 <fog> how would that work with fold and unfold?
06:27:46 <fog> @let fac' i = foldr (*) 1 $ L.unfoldr (\n -> if n == 0 then Nothing else Just (n,n-1)) i
06:27:47 <lambdabot>  .L.hs:181:7: error:
06:27:47 <lambdabot>      Not in scope: ‘L.unfoldr’
06:27:47 <lambdabot>      Perhaps you meant one of these:
06:27:54 <fog> @let fac' i = foldr (*) 1 $ unfoldr (\n -> if n == 0 then Nothing else Just (n,n-1)) i
06:27:55 <lambdabot>  Defined.
06:28:02 <fog> > fac' 3
06:28:04 <lambdabot>  6
06:29:55 <fog> because instead of calling fac' again recursively within its own definition, unfoldr and foldr are used, to caputure the anamorphism and catamorphism respectively
06:30:19 <fog> then, there is nothing to apply fix to
06:30:31 <fog> so the definition cannot be changed after the fact
06:33:27 <siraben> Is GHC good enough to fuse the ana and cata in fac' into the regular recursive definition of factorial?
06:33:56 <siraben> I believe fac' n = product [1..n] gets deforested in a similar way
06:35:51 <fog> i was just expanding the product and the enumFromTo
06:35:58 <phadej> AndreasK law, "for each question of the form 'Whether GHC optimizer will do something?' the answer is No"
06:36:50 <fog> there could be a rewite rule or an Inline pragma which allows a fold to fuse into the unfold, but im not sure if thats what you mean
06:37:27 <fog> hmm, i might be thinking of traversals. its not as if the result of fold could be folded again
06:38:54 <fog> > hylo :: (a -> Maybe (Int, a)) -> (Maybe (Int, b) -> b) -> a -> b; hylo = (\f c -> let go = c . fmap @Maybe (fmap @((,) Int) go) . f in go)
06:38:55 <lambdabot>  <hint>:1:65: error: parse error on input ‘;’
06:39:02 <fog> @let hylo :: (a -> Maybe (Int, a)) -> (Maybe (Int, b) -> b) -> a -> b; hylo = (\f c -> let go = c . fmap @Maybe (fmap @((,) Int) go) . f in go)
06:39:02 <lambdabot>  Parse failed: Parse error in expression: fmap@Maybe
06:39:59 <AndreasK> phadej: :)
06:40:43 <fog> % hylo :: (a -> Maybe (c, a)) -> (Maybe (c, b) -> b) -> a -> b; hylo = (\f c -> let go = c . fmap (fmap go) . f in go)
06:40:44 <yahb> fog: 
06:42:13 <siraben> phadej:  https://wiki.haskell.org/Correctness_of_short_cut_fusion#foldr.2Fbuild
06:42:18 <siraben> foldr/build
06:43:21 <fog> % fac'' = hylo (\n -> if n == 0 then Nothing else Just (n,n-1)) (maybe 1 (\(c,b)->c*b))
06:43:21 <yahb> fog: 
06:43:36 <fog> % fac'' 3
06:43:36 <yahb> fog: 6
06:44:20 <phadej> siraben: foldr/build do fuse, but that shouldn't ever be relied upon
06:44:26 <phadej> its "nice have to" not "guaranteed"
06:44:33 <fog> build is like a partially applied fold, to which cons and the basecase [] are applied
06:45:09 <fog> you can then replace these with other functions using the rewite rule
06:45:20 <siraben> fog:  Yeah that's just ([ const 1, uncurry (*) ]) . [( (== 0) → const Nothing, cross id pred )] in the squiggol style of bird and merteens
06:45:42 <siraben> s/cross id pred/Just . cross id pred
06:45:53 <siraben> phadej:  Right
06:46:26 * hackage quickspec 2.1.3 - Equational laws for free!  https://hackage.haskell.org/package/quickspec-2.1.3 (NickSmallbone)
06:46:31 <fog> so that a list, that is produced by build, ie, folding something with (:) [], then, when this list is folded, its the same as folding the original thing but with the new folding function and basecase instead of the (:) [] that was used to produce the list
06:47:29 <fog> siraben: oh nice, they have something like a list comprehension for hylomorphisms?
06:48:29 <siraben> fog:  sort of, see page 75 of http://www4.di.uminho.pt/~jno/ps/pdbc.pdf
06:48:42 <siraben> I was wondering if GHC could do a similar calculation automatically
06:48:54 <fog> so, hylo is a regular recursively defined function, which captures this unfolding then folding
06:49:04 <fog> the central recursive functionis;
06:49:05 <fog> go = c . fmap (fmap go) . f
06:49:23 <fog> which i guess is then amenable to open recursion by means of fix
06:49:58 <siraben> Right.
06:50:14 <dminuoso> Mmm, I want to prove a list has been sorted by some property in the type system. What's a reasonable way of doing this?
06:50:46 <dminuoso> My instinct tells me I should just assume "sort by ord" and then `newtype SortedList a = SortedList [a]` with some `doSort :: Ord a => [a] -> SortedList`
06:51:25 <siraben> dminuoso:  could haskell's type system be powerful enough to emulate something like Coq's inductive predicates for sorted lists?
06:51:59 <fog> is doSort a smart constructor?
06:52:01 <dminuoso> That sounds a bit over my head to be honest.
06:52:41 <fog> the problem with that is the user being able to do apperations on it that could mess up sorting, such as if you provide a Functor instance
06:53:35 <siraben> dminuoso:  https://coq.inria.fr/library/Coq.Sorting.Sorted.html
06:53:37 <fog> siraben: what calculation do you mean? recovering the definition of fac from the implementation using hylo?
06:53:57 <siraben> See the inductive type LocallySorted, an empty and singleton list is sorted, if a:l is sorted and a R b, then a:b:l is sorted
06:54:08 <siraben> s/a R b/a `R` b
06:54:10 <fog> i guess internally it does rewrite it to something equivalent using similar steps.
06:54:23 <siraben> fog:  yeah
06:54:37 <siraben> Maybe too much magic to be done automatically
06:54:39 <fog> but do you want the user to have the derived implementation available to them in syntax? kind of like the pl and unpl bots?
06:55:30 <siraben> Imagine if @unpl could do that, wizardry.
06:55:34 <dminuoso> Well that's certainly interesting. I was rather thinking along the lines of `[(2,'a'), (1, 'b'), (3, 'c')] :: SortedList (Lens' [(Int, Char)] `
06:55:35 <fog> well, for hylo to recover the definition its just a few simple rewrite steps that are always the same, should be easy enough. 
06:55:44 <dminuoso> (This is a bit fictional of course)
06:55:50 <fog> the question is why you would want that?
06:56:02 <fog> since the definition in terms of hylo is equivalent
06:56:03 <siraben> dminuoso:  Dep types are a very large hammer but interesting for value-level properties like "sortedness"
06:56:05 <dminuoso> I dont necessarily need to prove the sorting was done correctly, that could be done via newtype/exports
06:56:07 <siraben> Right
06:56:19 <dminuoso> Sorry I missed a bit up there
06:56:26 <siraben> fog: Right.
06:56:36 <dminuoso> [(2,'a'), (1, 'b'), (3, 'c')] :: SortedList (Lens' [(Int, Char)] Char)
06:56:49 <siraben> How does the lens arise here?
06:57:01 <dminuoso> Well that would be a sort of singleton/promoted kind.
06:57:47 <fog> anyway, im not sure about the thing with hylo and the use of fix, because im not sure if my unfolds are always followed by folds, there are intermediate traversals and sometimes other ways of consuming other than folding
06:58:19 <fog> but anyway, both foldr and unfoldr have recursive implementations usually, though its slightly confusing that they are class functions
06:58:24 <siraben> I don't use fix much if at all, is that standard? Most Haskell code I've seen doesn't use fix.
06:58:25 <dminuoso> My thinking is that you could have some `f :: Is k A_Lens => SortedList k` 
06:58:34 <dminuoso> (well throw in some singleton constraints
06:58:49 <fog> if you assume the default implementation from Get and Set instances, then they are simply recursive, and could be extended over using fix
06:58:50 <siraben> It's clearer to write the recursion but usually you use higher order functions to capture the recursion pattern as you said
06:59:02 <fog> the point is to make it extensible
06:59:08 <fog> thats the idea of open recursion
06:59:15 <siraben> Right
06:59:24 <dminuoso> Such that you'd know "someone has sorted this list by viewing through that lens", but in a way that you can demote the type into a lens back again and gain access to that thing.
06:59:26 * hackage Rattus 0.1.1.0 - A modal FRP language  https://hackage.haskell.org/package/Rattus-0.1.1.0 (PatrickBahr)
06:59:33 <siraben> I like fixing base functors at the type level though
06:59:36 <dminuoso> I mean yeah, I suppose Im probably overthinking this
06:59:53 <siraben> dminuoso: Hmm, not familiar with singletons yet
06:59:55 <fog> so then, these would kind of be the higher order functions that are also extensible by fix
07:00:03 <siraben> Is that Haskell's way of doing some form of dep types?
07:00:07 <dminuoso> Could just do `data SortedList s a = SortedList { lens :: Lens' s a; payload :: [a]`
07:00:14 <dminuoso> siraben: Yeah
07:00:30 <siraben> Inte
07:00:32 <dminuoso> siraben: A singleton is essentially just a type with one inhabitant, such that you can go both ways
07:00:35 <siraben> Interesting*
07:00:44 <dminuoso> (that is, if you know its type you can go back to a value, and the other way around)
07:01:08 <dminuoso> then, we can sort of pretend that by applying some type level function to a singleton type we actually apply a value to a type
07:01:12 <dminuoso> *a type to a value
07:01:46 <dminuoso> I think that's sort of the connection, could just be confused though
07:02:14 <boxscape> that sounds right to me
07:11:02 <siraben> dminuoso:  So the type uniquely determines the value?
07:11:07 <dminuoso> Right.
07:11:35 <dmwit> Unpopular opinion: being a singleton is not the useful property of these types.
07:12:05 <dminuoso> dmwit: can you elaborate?
07:12:32 <dmwit> The useful property is that if you pattern match on the runtime data, you learn about the compile-time data.
07:12:51 <dmwit> It would be completely fine to have two or more runtime values that corresponded to a single compile-time value.
07:13:01 <dmwit> Which would make it not a singleton. But still fulfill the same role.
07:13:30 <dmwit> Being a singleton just makes it parsimonious. But the real property that you care about is that it faithfully reflects some compile-time information.
07:13:32 <dminuoso> So in effect, GADTs are largely useful for the same reason?
07:13:59 <dmwit> mmm
07:14:11 <dmwit> "GADT" is too weak, "singleton" is too strong ^_^
07:17:34 <boxscape> hm, if the values had additional information compared to the type (i.e. if they weren't singletons), then a function on these values could depend on this additional information rather than just on the type-level information. It seems like having a guarantee that that's impossible should be quite usseful
07:17:39 <boxscape> s/usseful/useful
07:19:01 <boxscape> ...hm though I guess the type level information that comes out still has to be the same regardless? Since the function that operate on singletons are coupled to type families that ensure this, IIRC
07:19:08 <boxscape> so maybe it wouldn't be that useful after all
07:34:44 <fog> do we have something like fix2?
07:35:03 <fog> i think i need to send it down two different branches in hylo, one for fold, one for unfold
07:35:55 <fog> and also, it doesnt seem like the full "altering the implementation at another part of a program" is completely captured by that
07:36:08 <fog> because only part of the data is involved in the recursive call
07:36:24 <fog> ie, the tail in the case of fold, and the carried state in the case of unfold
07:36:50 <fog> eg, i should be able to edit something defined in terms of fold, to take the tail of the tail, and basically skip values as it folds
07:36:56 <fog> as a modification by using fix
07:37:08 <fog> but i wouldnt be able to do anything with the head
07:37:21 <fog> hmm, i guess it makes a difference if its foldl or foldr then
07:38:37 <fog> foldl f z (x:xs) = foldl f (f z x) xs
07:38:47 <fog> foldr f z (x:xs) = x `f` foldr f z xs
07:39:53 <fog> so, dixing over foldr only lets the tail and the basecase to be modified differently 
07:40:00 <fog> fixing*
07:40:33 <fog> but fixing over foldl would allow the carry and the tail to modified
07:40:45 <fog> oh, and the function f in both cases too...
07:41:47 <fog> are they equivalent? like if you do something to the basecase at each stage, is that the same as doing something to the carry at each stage?
07:42:51 <fog> i guess only for order independent opperations, but they look about as expressive. im not sure if there is something you can only do by fixing over one of either foldl or foldr but not the other
07:44:44 <fog> i wonder how useful it is, to be able to swap the folding function, or opperate on the basecase or carry, or the tail
07:45:01 <fog> you could basically completely change the functionality of a program
07:45:26 <fog> eg, something written in terms of fold, like sum
07:45:52 <fog> and you could make it sum every other element by getting it to call tail on xs at each stage
07:46:18 <fog> or turn it into product by swapping the (+) for a (*)
07:46:50 <fog> but that it would be better than just writing product in terms of fold directly, because you would have access to the (+)
07:47:38 <fog> like, you could swap (\a b -> a + b) for (\a b -> a + b + b)
07:48:37 <fog> and use this same opperation over the fix fold version of product, so it would turn it from (\a b -> a * b) for (\a b -> a * b * b)
07:48:52 <fog> s/for/to
07:49:31 <fog> instead of just consting away the original folding function, using it as an argument to produce the new folding function
07:50:42 <fog> im sure this will have been done somewhere before.... does anyone know where i can find a version of fold written using fix
07:51:00 <fog> i could write my own, but if its in a library somewhere id like to see what other functions are in that library
07:52:48 <c_wraith> there's always recursion-schemes
07:55:38 <fog> oh?
07:56:00 <fog> isnt that a totally different interface?
07:58:09 <fog> i always find that library difficult to read;
07:58:10 <fog> https://hackage.haskell.org/package/recursion-schemes-5.1.3/docs/Data-Functor-Foldable.html
07:59:05 <fog> i cant see "fold written using fix" but i could be looking past it because of the overwhelming plethora of exotically named functions 
08:00:25 <fog> this is about as close as i can find to "fold" https://hackage.haskell.org/package/recursion-schemes-5.1.3/docs/src/Data.Functor.Foldable.html#cata
08:00:52 <phadej> https://hackage.haskell.org/package/recursion-schemes-5.1.3/docs/Data-Functor-Foldable.html#v:fold
08:01:10 <phadej> (which is alias for `cata`)
08:01:27 <fog> i cant even see where cata makes a recursive call...
08:01:35 <fog> it must be something to do with project
08:01:45 <boxscape> looking at the recursion-scheme hackage page might not be the best way to learn how to actually use it
08:02:02 <fog> im reading the source
08:02:45 <fog> i asked "where is fold implemented for use with fix" wanting that for open recursion, and was directed to recursion-schemes
08:03:07 <fog> i dont now want to "learn how to use recursion shcemes" if that isnt even where to find what i was looking for
08:03:15 <boxscape> fair enough
08:03:18 <phadej> I'm not understanding that question (fold implemented for use with fix)
08:03:33 <phadej> fix :: (a -> a) -> a, and fold, which fold?
08:03:52 <fog> either foldl or foldr
08:03:54 <c_wraith> recursion-schemes gives you a different way to work with open schemes
08:04:46 <fog> yeah, and i guess it could be doing something similar, and certainly it has cata and anamorphisms, but im just not sure about its ability to support open recursion
08:04:52 <phadej> I still don't understand, speaking about `fix` and `foldr` in the same sentence doesn't make sense, except to say that you can implement foldr using fix
08:05:19 <c_wraith> If you write your type as a fixed point, ie using Fix, you can trivially change the base functor to get a new recursive type
08:05:26 <phadej> and what's open recursion
08:05:32 <phadej> general ?
08:05:49 <c_wraith> And you can use Data.Functor.Compose to tie together any pair of base functors
08:05:57 <c_wraith> and it'll all just work out
08:06:28 <c_wraith> (because functors compose)
08:06:36 <phadej> I feel that when you'll be able to formulate your question better, you'll be very close to the finding the answer :)
08:06:42 <fog> maybe thats not the correct way to say it, if thats not what open recursion means
08:06:58 <phadej> don't invent terms
08:07:05 <c_wraith> it's an OO term, not an invented one
08:07:07 <phadej> fix is general recursion
08:07:22 <fog> but, if using fix, i can do something like turning fac into skim like here; https://www.well-typed.com/blog/2018/03/oop-in-haskell/
08:07:37 <fog> then basically there should be something similar for fold
08:07:48 <fog> though the type of the "fix" like thing might have to be different
08:08:00 <dwt> open recursion is the thing OO languages do where a method call defined in a superclass can result in a call, through this/self/whatever-you-call-it, to a method defined in a subclass
08:08:16 <c_wraith> fog: I've noticed you tend to do things that don't work very well in Haskell without having a use case or exploring alternatives that do work well in Haskell.
08:08:27 <dwt> the way I've usually rolled that in Haskell is with records of functions which take an explict "self" as the first argument
08:08:51 <dwt> but it's something I've used maybe once or twice in 5 years or more
08:09:13 <c_wraith> fog: so I'm pointing you at an alternative that does work well in Haskell - composing base functors a la the recursion-schemes library
08:09:34 <fog> but composing base functors is to get different shaped containers right?
08:09:36 <phadej> fog: `cata` (or `para`) allows you write `fac` without using `fix`
08:09:57 <c_wraith> why limit yourself to assuming functor = container?
08:10:11 <fog> thats not the same as trying to change the arguments to fold in a function written in terms of fold, like how fix is used in the "open recursion" example from that well-typed link
08:11:01 <fog> well, container = Foldable in this case, but yeah, i see what you mean
08:11:07 <phadej> I'm lost, sorry. I have no even less idea what you are trying to achieve
08:11:40 <c_wraith> the problem is that no use case is involved.  It's a dive into replicating OO techniques in haskell just because.
08:12:05 <c_wraith> When there usually are different approaches that work better.
08:12:19 <fog> phadej: right, but the point is to use the principle "self recursive definitions of a particular type can be written for use with fix, for the purpose of open recursion" and extend that to fold, which is defined recusively and so should allow for something similar
08:12:41 <c_wraith> fog: here's the thing.  fix is boring.  If you can write something with fix, you can write it without.
08:12:54 <pixeleet> I don't think this is a good article to even try to wrap your head around :) with a title "Object Oriented Programming in Haskell" I'm already discouraged. You should just not try to replicate what you know from OOP in FP imho. *Begginer here*
08:13:04 <phadej> c_wraith: that's true for `cata` too, doesn't really help.
08:13:20 <c_wraith> (fix s theoretically interesting, and in rare occasions can improve code, but it brings no new expressive power)
08:13:43 <fog> c_wraith, ski had a really good use of it the other day, and it motivated me to learn about how it can be used for effectively modifying the implementation details of a function by swapping its recursive call
08:14:08 <phadej> fix is useful mostly for codegolfing
08:14:28 <dolio> There are some nice uses.
08:14:30 <phadej> fix-like functions are sometimes useful
08:14:57 <fog> dolio: can you help me out here, they are trating me like a java programmer that has just wandered into a haskell chat room
08:14:57 <phadej> but fix itself hardly, there's often "less general" and better way to do it
08:15:26 <phadej> fog: I'm not understanding why you extending from `fix` to `fold`
08:15:26 <dolio> You can write anonymous loops using it in combination with `(?) = flip`
08:15:46 <phadej> it's more like one can shwo how to write stuff with foldr and even more stuff with fix
08:16:05 <dolio> `fix ? x0 ? y0 $ \rec x y -> <body>`
08:16:18 <phadej> 18:13  phadej fix is useful mostly for codegolfing
08:16:34 <dwt> fog, I think what people are getting as is that it's pretty easy to build open recursion in Haskell - I've used it to build something like the "visitor pattern" so that library users could get some useful default behaviors and customize certain pieces of a tree-walker...
08:16:42 <c_wraith> fog: ask your question in terms of goals rather than implementation, and you'll get more useful results.
08:16:56 <fog> phadej: i gave an example of modifying sum to take the sum over every other element
08:17:26 <c_wraith> that's not a type
08:17:35 <dwt> ... but that there's not really a culture of making heavy use of it, and there's not much written on combinators or general schemes for open recursion - I am not clever enough to know if that's due to lack of interest or deep technical reasons.
08:17:37 <fog> no its a goal
08:18:29 <phadej> fog: if I remember right, you can use `histo` for that
08:19:07 <fog> to modify an existing implementation of sum, thats for use with this version of fix thats supposed to work with the type of the recursive call for fold?
08:19:11 <phadej> aka, for various variants of recursion, there is (or waits to be written) a recursion schemes combinator
08:19:30 <c_wraith> fog: why are you so interested in *that specific approach*?
08:19:44 <c_wraith> fog: what if that's just a bad solution?
08:19:46 <phadej> fog: one way to think about this is to not think about lists
08:19:52 <phadej> lists are very very boring recursive type
08:20:22 <phadej> the "every second" value is harder to define in a binary tree, e.g.
08:20:24 <fog> this is supposed to be swapping the recursive call in the *implementation* of a recursion scheme, to allow for this modifiable-at-some-other-point style, which i thought was what open recursion meant
08:21:13 <fog> c_wraith: i can see how that kind of reasoning could be helpful
08:21:44 <fog> phadej: argh, your right, thats a list specific implementation
08:22:10 <fog> i guess the class function foldrOpen would have to have the correct type to allow for all the instances to use it 
08:23:16 <fog> :t fix
08:23:17 <lambdabot> (a -> a) -> a
08:23:38 <fog> i guess it would resemble fold more
08:24:19 <fog> c_wraith: what im most astonished by is that is seemingly a new consideration 
08:25:02 <fog> why do we only have fix for that type of recursive call?
08:25:32 <c_wraith> fix is general recursion.  Anything that can be done with explicit recursion can be done with fix instead
08:25:41 <c_wraith> So the question doesn't make sense.
08:26:06 <fog> hmm, i might have this all wrong. sorry
08:26:19 <boxscape> c_wraith not true for polymorphic recursion though, right? You'd need a different fix for that
08:26:38 <c_wraith> oh, that's true.  polymorphic recursion is a special case.
08:27:05 <fog> i think its because the type of foldr is not (a->a)
08:27:11 <c_wraith> so?
08:27:22 <fog> so i contenst that you should be able to write foldr using fix
08:27:32 <fog> or, for use with fix of this type
08:27:59 <drewolson> hey folks, i have a phoenix form that is creating a "profile" for my users. behind the scenes, the profile is actually just added fields to an existing user, but i want to treat it as a "create" from a REST perspective. i've manually provided the `method: :post` option, but i'm not seeing error rendered on the page when i have validations in the
08:27:59 <drewolson> changeset.
08:28:07 <drewolson> whoops wrong channel
08:30:39 <c_wraith> :t let f loop g z ls = case ls of {[] -> z ; (x:xs) -> g x (loop g z xs)} in fix f -- fog: this is totally boring
08:30:40 <lambdabot> (t1 -> t2 -> t2) -> t2 -> [t1] -> t2
08:31:39 <c_wraith> It's a completely mechanical transformation
08:32:03 <c_wraith> replace recursive calls with a call to an extra loop parameter.  fix.  done.
08:32:08 <fog> wait, just trying to grok this 
08:33:22 <fog> im concerned that it only acts on xs
08:33:34 <c_wraith> it's foldr
08:33:45 <c_wraith> it does exactly what foldr does
08:33:59 <fog> yeah, but if i want to do something with f
08:34:05 <dolio> boxscape: That's just a typing thing, though. If GHC allowed you to instantiate the variables correctly, you could do polymorphic recursion.
08:34:14 <boxscape> I see
08:34:18 <fog> oh, right, then it can match on the arguments to f and opperate on them to return a new f
08:34:38 <dolio> Which it might in the future.
08:34:39 <fog> oh thats perfect
08:34:49 <boxscape> dolio that sounds interesting
08:35:14 <fog> its not boring! now by using this instead of foldr, the fix can be delayed to an outer position
08:35:30 <c_wraith> fog: but there's nothing interesting about fix.  It's just a mechanical rewrite.
08:35:33 <fog> so anything that uses it can have the "fix passed in" 
08:35:55 <fog> i dont see how that makes what i just said invalid
08:36:39 <fog> you seem to be ignoring the entire idea behind open recursion as expounded by the well-typed article
08:36:46 <fog> such as turning fac into skim
08:36:51 <fog> https://www.well-typed.com/blog/2018/03/oop-in-haskell/
08:36:56 <fog> here again to save the scrollup
08:37:55 <fog> @let foldrOpen loop g z ls = case ls of {[] -> z ; (x:xs) -> g x (loop g z xs)} 
08:37:57 <lambdabot>  Defined.
08:38:05 <fog> :t foldrOpen
08:38:06 <lambdabot> ((t1 -> t2 -> t3) -> t3 -> [t1] -> t2) -> (t1 -> t2 -> t3) -> t3 -> [t1] -> t3
08:38:11 <fog> yikes!
08:38:42 <fog> > fix foldrOpen (+) 0 [1,2,3]
08:38:44 <sm[m]> hi phadej.. thanks for your work on the cabal docs. Re https://github.com/haskell/cabal/issues/6966, can I just confirm before sending a bunch of PRs: the https://cabal.readthedocs.io/en/stable url will no longer be supported, and https://cabal.readthedocs.io should be used instead ? Is that ok from a SEO point of view, eg it's now a redirect and I think previously it was not, will google indexing/ranking suffer ?
08:38:44 <lambdabot>  6
08:39:55 <phadej> sm[m]: stable is problematic as it seems impossible to make it a redirect
08:40:14 <phadej> so as long as no one complains, I'm not changing anything further. No guarantees.
08:40:24 <sm[m]> I thought it served the page directly as /stable before, perhaps I'm wrong
08:40:48 <phadej> yes, but it wasn't a redirect, and it wasn't obvious which absolute version "stable" is
08:40:55 <phadej> about which you complained
08:41:28 <sm[m]> I suggested removing it from the UI, but specifically recommended not to disturb the url :)
08:41:48 <phadej> the urls will die anyway
08:41:51 <phadej> as it's relative
08:41:59 <phadej> e.g .stable/foo might be gone with next release
08:42:11 <sm[m]> so I just want to be sure you like the current setup. Ok then I'll try to get links updated at https://github.com/haskell/cabal-website etc.
08:42:59 <phadej> please do
08:43:35 <phadej> also there is https://cabal.readthedocs.io/sitemap.xml so Google should figure things out
08:44:52 <phadej> it will be confused and return results for older versions (as it does with GHC docs), but there's a note on top of the page, which people might even read
08:45:48 <phadej> though it seems that /latest is favoured in that sitemap
08:46:00 <phadej> so probably the google links will go there anyway
08:47:09 <phadej> Read the Docs automatically generates a sitemap for each project that hosts to improve results when performing a search on these search engines. This allow us to prioritize results based on the version number, for example to show stable as the top result followed by latest and then all the project’s versions sorted following semantic versioning.
08:47:15 <phadej> cannot do better, sorry.
08:49:33 <sm[m]> phadej: thanks
08:50:14 <sm[m]> btw I'm not aware of all the repos and history - is it true to say you're the current most active committer/maintainer of cabal docs and software ?
09:37:05 <maerwald> sm[m]: are you the second documentation ambassador after Uniaika? :)
09:38:57 <frdg`> is there nicer syntax for nested case expressions? Too many case expressions can get pretty confusing to look at.
09:39:28 <dsal> I almost never have to do that.  Do you have some code we can improve?  :)
09:39:46 <dsal> Actually...  I don't think I've ever had to do that in haskell…
09:41:25 <frdg`> well I'm only three cases deep...I could put some of the code into seperate functions I guess.
09:41:26 <sm[m]> maerwald: trying not to be, but the cabal docs annoyed me enough I'm trying to help
09:42:39 <sm[m]> a decent user experience with cabal is kind of important for haskell 
09:42:48 <davean> frdg`: Why would you need to nest cases?
09:43:01 <davean> frdg`: I feel like you might not be fully using the case expression if you're nesting
09:43:48 <davean> (Infact, I don't think there can exist anything doable with nested case expressions that can't be done in a single top level one)
09:44:45 <dolio> That might be technically true, but it might not look any nicer.
09:44:56 <frdg`> ok so I can definetly fix this. I wasn't sure if it was a common problem with a known solution but I guess its just poor logic on my part.
09:45:32 <phadej> you can do `case foo of Just (x, [a,b,c]) -> ...`
09:45:47 <phadej> i.e. you don't need to do case foo of Just m -> case m of ...
09:45:56 <phadej> if that's what you were doing
09:45:57 <davean> dolio: well yes, I was talking technically true there, but I wanted to say it to get him to look at his code harder or share it.
09:46:19 <boxscape> what if you have `case foo of Just x -> case f x of (y:ys)`? I guess view patterns would work
09:46:21 <phadej> indeed, showing some piece of code helps to figure out what's the problem
09:46:31 <boxscape> but I can see why one might want to use nested cases in such a situation
09:46:35 <frdg`> phadej: I never thought of that. This will be perfect actually.
09:47:02 <davean> Thats EXACTLY what I thought you hadn't thought of :)
09:47:04 <dolio> Ah, well then. :)
09:47:14 <ChaiTRex> boxscape: case fmap f foo of ...
09:47:22 <phadej> boxscape: then one can do e.g. case fmap foo x of (y:ys) -> ...
09:47:27 <davean> boxscape: well, the cleaner way would be fmap, but view patterns, conditionals.
09:47:28 <phadej> ChaiTRex: +1
09:48:06 <boxscape> ah, yeah, I guess I meant that more as a specific example of a more general patterns that doesn't necessarily include functiors, but here fmap would work, true
09:48:14 <boxscape> s/patterns/pattern
09:48:16 <davean> dsal: I thought that technically true statement was probably more insightful than "you probably don't know all the things case can do"
09:48:28 <davean> er, dolio 
09:48:54 <davean> The debate on why we might not like it is a good one to have!
09:53:26 * hackage streaming-osm 1.0.2 - A hand-written streaming byte parser for OpenStreetMap Protobuf data.  https://hackage.haskell.org/package/streaming-osm-1.0.2 (fosskers)
10:11:40 <elgalloitaliano> /join #metalab
10:11:40 <elgalloitaliano>  
10:14:58 <ChaiTRex> elgalloitaliano: No, you can't make me.
10:25:26 * hackage ghc-exactprint 0.6.3.2 - ExactPrint for GHC  https://hackage.haskell.org/package/ghc-exactprint-0.6.3.2 (AlanZimmerman)
10:37:50 <Shiranai> Hello, is there any way to embed my haskell code on a webpage and be able to run it? Be it by interpretting haskell in js or if someone know some 3rd party app that allows this functionality.
10:39:02 <koala_man> you want it evaluated dynamically on the client side?
10:39:43 <Cale> Shiranai: you can compile Haskell to javascript using ghcjs
10:40:17 <Cale> One of the easiest ways to play with that is by grabbing reflex-platform and following along with its tutorial.
10:40:35 <Shiranai> Thanks but that is not what I need, I believe, as I want the user to create and evaluate new codde on the client side
10:40:44 <Shiranai> just like https://www.haskell.org/ allows in it's main page
10:40:50 <Cale> oh, you want to evaluate Haskell source code
10:41:25 <Shiranai> yep
10:41:36 <Cale> I think usually people end up doing that serverside
10:48:24 <Cale> Indeed, that's how they do it on the haskell.org main page -- it's sending your expression off to tryhaskell.org/eval and getting back a JSON response
10:49:55 <kuribas> Why do I solve this "out of scope variable x"?  https://gist.github.com/kuribas/43a1b93e83020d125f078461fd8fe576
10:50:14 <kuribas> x is needed by Rep a x
10:50:47 <Shiranai> Cale: alright thanks! I was hoping it was client sided but guess that is good enough.
10:51:07 <kuribas> or do I have to make of GRecordParam an existential?
10:51:21 <glguy> kuribas: All the variables in line 28 need to be bound on line 27
10:51:49 <glguy> kuribas: You might just fix x to be ()
10:52:15 <glguy> Unless you're using Generic1, that parameter doesn't do anything
10:52:44 <kuribas> ah I see
11:16:02 <quarters> hello. I'm new to haskell and was wondering if there's a recommended library for setting up a restful api
11:18:48 <kuribas> quarters: servant
11:19:14 <kuribas> quarters: though if you are new, something like spock will be easier
11:19:50 <kuribas> quarters: if you have someone to guide you, I'd use servant
11:20:24 <dsal> I just used warp last time.
11:20:27 <dsal> Much less fancy.
11:23:54 <quarters> thank you, kuribas and dsal 
11:24:19 <kuribas> yeah, better not start with servant
11:25:42 <dsal> specifically, I'm using scotty.
11:25:54 <dsal> quarters: do you have any particular background?
11:30:38 <kuribas> how do I get this to typecheck? https://gist.github.com/kuribas/43a1b93e83020d125f078461fd8fe576
11:32:41 <kuribas> it looks like I would need a forall b. in the constraint
11:36:58 <wjwh> quarters If you want an example of a (very) small microservice written with scotty there is an example on my blog at http://www.wjwh.eu/posts/2019-11-01-haskell-shorturls.html
11:39:31 <quarters> dsal: I'm mainly coming from c-style languages (js, python, java, c++, go)
11:39:56 <quarters> wjwh: excellent. ty. I'll check that out
11:40:18 <kuribas> quarters: welcome to functional programming!
11:40:52 <wjwh> Hope you can glean some insight from it :)
11:41:21 <wjwh> If anything is unclear don't hesitate to ask.
11:41:49 <quarters> kuribas: ty :) I hope I figure it out ok.
11:41:55 <quarters> wjwh: definitely. will do
11:42:23 <kuribas> quarters: just take it slowly, one step at a time, and all will be fine.
11:43:29 <monochrom> Bless ghcup, now it also knows GHC 8.8.4.
11:44:04 <monochrom> Wait a second! "recommended" is still 8.8.3 haha
11:46:16 <koz_> monochrom: Wait, there's been a new 8.8 release?
11:46:34 <koz_> Wow, I'm a bit slowpoke.
11:47:26 * hackage inline-java 0.9.0 - Java interop via inline Java code in Haskell modules.  https://hackage.haskell.org/package/inline-java-0.9.0 (FacundoDominguez)
11:48:26 * hackage jvm-streaming 0.3.2, jvm-batching 0.1.2, jvm 0.5.0, jni 0.7.0 (FacundoDominguez)
11:48:36 <monochrom> A couple of days ago. Bug fix for 8.8.*
11:50:40 <phadej> less than 24h ago...
11:51:03 <phadej> not to nitpick, but release happens only when it's announced ;)
11:51:19 <fog> here is what i have so far for this open recursion fold idea
11:51:20 <fog> https://pastebin.com/raw/L5uDjkiq
11:51:52 <fog> i cant get the last example to work
11:52:03 <monochrom> Yeah I misremembered. Reverse old mind phenomenon: "everything seems like happened 50 years ago".
11:52:08 <fog> it kind of partially applies some arguments and it messes everything up
11:52:59 <fog> monochrom: ha! youth nowerdays... back when I was a lad, everything seemed like it happened 150 years ago! 
11:53:21 <monochrom> It was uphill both ways, and it's all downhill from now.
11:55:43 <fog> is it clear the bug from the paste?
11:55:49 <fog> i cant get that to typecheck
11:58:06 <fog> i have this idea that if i just keep passing the "loop" parameter that succesive levels can be nested
11:58:18 <fog> but apparently every level has to have the same type as the inner level
11:58:29 <fog> by the (a -> a) -> a type of fix
11:58:47 <fog> the (a -.> a) here, has `a' as the whole type of foldr
11:59:10 <fog> and when i try and partially apply some arguments to it, it breaks
11:59:21 <fog> because then it no longer has that type
11:59:34 <fog> and i cant pass the loop parameter of the correct type in
11:59:54 <fog> like, if i wanted to call fix on;
11:59:55 <fog> sumOpen foldrOpenLoop xs = foldrOpen foldrOpenLoop (+) 0 xs
12:00:14 <fog> sumOpen :: Num b => ((b -> b -> b) -> b -> [b] -> b) -> [b] -> b
12:00:34 <fog> it is all the wrong type for supplying to fix
12:01:03 <fog> so i cant pass foldrOpen the correct loop type
12:01:26 <fog> and have fix kind of go into the implementation of sum and swap the fold that was used
12:02:15 <fog> i guess i should totally abandon this, since it doesnt seem to have any chance to work, or that anything useful will result
12:02:39 <monochrom> I got no type error.
12:02:56 <fog> ?
12:03:04 <monochrom> your paste.
12:03:38 <fog> you have to type at the ghci repl;
12:03:39 <fog> :t fix sumOpen
12:03:41 <lambdabot> error: Variable not in scope: sumOpen :: a -> a
12:05:21 <monochrom> sumOpen's type is not suitable for fix.
12:05:34 <fog> thats what im saying man!!
12:05:49 <ChaiTRex> :t sumOpen
12:05:50 <lambdabot> error: Variable not in scope: sumOpen
12:06:08 <fog> ChaiTRex: https://pastebin.com/raw/L5uDjkiq
12:06:22 <monochrom> Let's design it from desired end result, not from what you already have.
12:06:40 <monochrom> What would you like to be the type of "fix sumOpen"?
12:06:54 <fog> the same as the type of sum
12:07:01 <monochrom> @type sum
12:07:02 <lambdabot> (Foldable t, Num a) => t a -> a
12:07:10 <fog> but im not sure fix is going to be able to do that
12:07:12 <monochrom> I take it you merely mean [a] -> a
12:07:17 <fog> yes
12:07:18 <monochrom> err, Num a => [a] -> [a]
12:07:24 <fog> yes
12:07:37 <monochrom> So sumOpen :: Num a => ([a] -> a) -> [a] -> a
12:07:46 <fog> i dont think its going to work with fix
12:07:55 <fog> i wouldnt be able to use fold then
12:07:58 <dmwit> fix can return a value of *any* type.
12:07:59 <fog> i mean, foldOpen
12:08:12 <fog> dmwit: but it cant *take* any type
12:08:27 <monochrom> perhaps you can still use foldrOpen but cleverly, not naively.
12:08:31 <fog> it needs the loop argument to be the same type as the whole rest of the thing
12:09:19 <fog> monochrom: i dont see how i could use it at all, its loop argument needs to be the same type as it. but sums loop argument needs to be the same type as sum
12:09:41 <fog> foldrOpen that is
12:10:39 <fog> if i try and take the loop argument passed into sum, and make a new loop argument to supply to foldrOpen, idk what it will do!
12:11:09 <fog> passed into sumOpen*
12:12:04 <fog> fix would probably do something unexpected then. the examples i have seen do not modify the loop param as it descends throught the layers of functions to its use site
12:12:35 <dmwit> I'm confused. Why do you want sumOpen? sum is not traditionally implemented as a recursive definition in the first place.
12:12:55 <monochrom> I think I have a better design for foldrOpen so it is actually usable.
12:13:05 <dmwit> And when it is implemented as a recursive definition, it is not implemented in terms of foldr.
12:13:25 <dmwit> The two (manual recursion and foldr) just... don't have a reason to mix.
12:13:25 <fog> i want to be able to eg, swap the (+) into a (*), but have the (+) available, so it could be like (\a b -> a + b + b)
12:13:53 <dmwit> You won't get that from the type you proposed above of Num a => ([a] -> a) -> ([a] -> a).
12:13:57 <dmwit> That's a completely different goal.
12:14:02 <monochrom> foldrOpen :: (a -> b -> b) -> b    ->     ([a] -> b) -> [a] -> b     -- I use spaces to emphasize a separation I want you to notice.
12:14:47 <fog> dmwit: it was just a simple use of foldr
12:14:52 <monochrom> foldrOpen g z loop ls = ... the code here doesn't change, but I re-ordered parameters.
12:15:21 <monochrom> foldr' g z = fix (foldrOpen g z)  -- I want users to use foldrOpen this way
12:15:38 <monochrom> sumOpen = foldrOpen (+) 0
12:16:11 <fog> no thats no good, now you have "closed" it
12:16:21 <fog> so i cant change the definition from outside
12:16:29 <fog> its sum, its just not sumOpen
12:16:46 <monochrom> Does the computer agree with you?
12:16:52 <fog> hang on, what did you do, you missed the loop param?
12:17:02 <fog> or did you like shuffle it around or something
12:17:04 <monochrom> eta
12:17:04 <fog> im confused
12:17:10 <monochrom> I did eta.
12:17:13 <fog> !!
12:17:26 <monochrom> Even my students would understand.
12:17:46 <dmwit> I am very curious to see whether, once fog understands what you did, they agree that it meets their needs.
12:17:47 <EvanR> lowest common denominator!
12:17:52 <dmwit> Currently their needs appear contradictory.
12:17:55 <monochrom> But OK. I'm too lazy to write "foo x = bar (+) 0 x", so I write "foo = bar (+) 0"
12:17:58 <dmwit> So... it would kind of surprised if it did.
12:18:43 <monochrom> Well, the litmus test is can I still re-implement foldSkip based on my new method? I think I can.
12:18:56 <fog> you messed up foldrOpens type signature. you didnt just shuffle the parens, you are missing an (a -> b -> b)
12:19:45 <monochrom> OK fair, I forgot saying that clearly. But it is what I want, it is what I think is an improvement, there is no need to keep repeating g and z.
12:19:46 <fog> yeah you should be able to opperate on the basecase, the folding function, or the tail, at each step
12:20:43 <fog> they need to be kept "open", i think that means "there is ! a need to keep repeating g and z."
12:21:23 <monochrom> foldSkipOpen doesn't change g and z.
12:21:32 <fog> yeah, thats why it works!
12:21:37 <fog> it has the same type
12:21:59 <monochrom> and that's why I don't need to repeat g and z, only need to specify them once before any recursion begins.
12:22:11 <fog> im not sure i could construct something that could change those given they are supposed to over foralls
12:22:23 <fog> hmmm...
12:22:49 <monochrom> Oh ah, the code of foldrOpen has to change
12:22:56 <fog> so while i might want to change the tail at each step, redefining the functions can *only* happen outside of the open recursion
12:23:12 <fog> ie, the only thing that *can* be open is the operation on the tail?
12:23:32 <fog> i guess if it were foldMap if might be different
12:24:13 <fog> i could modify the basecase with mappend 
12:24:25 <fog> oh, no wait, its fixed for foldMap, nvm
12:24:33 <monochrom> Oh oops, my design cannot be done, I don't know how to do it.
12:25:27 <fog> why?
12:26:06 <monochrom> Or maybe I'm doing fine. Let's see...
12:26:43 <fog> um, ok, so, if its for sumOpen, then the type is already specified to Num a
12:27:07 <fog> so i should at least be able to do something like multiplying the basecase by 2 at each recursive stage
12:27:37 <fog> though i cant do something like dotting the folding function against itself unless a ~ b
12:29:15 <fendor> qwhereis manual
12:29:20 <fendor> @whereis manual
12:29:20 <lambdabot> Maybe you meant: where+ where
12:29:26 <fendor> @where manual
12:29:26 <lambdabot> I know nothing about manual.
12:29:29 <fendor> dammit
12:32:00 <monochrom> Could you try this and see if it does what you want?  http://dpaste.com/3Q8DB0F
12:33:28 <fog> monochrom: i think your right, its impossible...
12:34:19 <fog> monochrom: no, its not "open" in terms of the folding function or the basecase
12:34:40 <fog> by the time you have applied fix, it gives you back the type of sum
12:36:31 <fog> i think its open enough for a definition of sumSkip to be written using it though... which is something at least
12:37:34 <fog> whats happening seems to be that as soon as we partially apply an argument, it stopes being open in that argument
12:38:27 <fog> i guess it needs to take the same number of arguments
12:38:33 <fog> and they need to have the same type
12:38:47 <fog> and we can only do `a -> a' type opperations on them
12:39:03 <fog> like, for the basecase with is Num, multiplying it by something
12:39:20 <fog> or it its the tail, doing tail on it for skip
12:40:05 <fog> idk if you can do anything more elaborate than that
12:49:42 <fog> so i can do something like this;
12:49:43 <fog> https://pastebin.com/raw/cTPqLZr5
12:50:06 <fog> i cant partially apply any of the argument (well, i could, but that would close them, so they couldnt be changed after)
12:50:13 <fog> but i can do functions to them
12:50:32 <fog> like skip used tail on xs
12:51:28 <fog> i can "change the folding function" over and over, as long as thats just by operations on each of arguments at each recursive step
12:51:48 <fog> not actually providing what those arguments should be
12:51:53 <fog> which would close them
12:51:56 * hackage inline-java 0.9.1 - Java interop via inline Java code in Haskell modules.  https://hackage.haskell.org/package/inline-java-0.9.1 (FacundoDominguez)
12:54:59 <fog> basically this is because it "consts away the upper arguments"
12:55:28 <fog> like if i wrote instead of;
12:55:29 <fog> foldSkipOpen loop f b xs = foldrOpen loop f b (tail xs)
12:55:36 <fog> foldSkipOpen loop f b xs = foldrOpen loop (+) b (tail xs)
12:55:41 <fog> then it would be closed
12:56:15 <fog> since anything that tried to change that by providing a different f, that input would just be discarded
12:56:15 * dmwit proposes `sumOpen = foldrOpen`.
12:56:29 <dmwit> Then you can easily replace `+` by `*`, because it hasn't even mentioned + yet.
12:56:35 <fog> dmwit: seem like thats basically it, yeah
12:57:29 <fog> you can provide something, but it stops you from being able to edit that further up the "inheritence hierarchy" if we are still stealing OO language
12:57:39 <fog> or further down
12:57:48 <fog> whicheverway round it is...
12:59:04 <fog> i wonder if you could combine it with continuations to allow access to these deeper nested layers where things are otherwise closed
12:59:15 <travisgriggs> howdy haskell masters. I'm working my way through the learnyouahaskell book. I think it's a little dated now? I'm in the bytestrings section of chapter 9. But the Data.ByteString.Lazy type seems to output the same as teh Data.ByteString type I think (which is different than the book). is this something that's evolved in the last few years
13:00:08 <fog> are the imports qualified?
13:00:21 <fog> or is there a specific function that has changed its type signature?
13:01:12 <merijn> travisgriggs: Not, the types in Data.ByteString and Data.ByteString.Lazy just have the same name
13:01:31 <merijn> s/Not/No
13:02:39 <monochrom> They have always had the same name.
13:02:58 <monochrom> Sometimes you just import one and you don't care about the other anyway.
13:03:15 <monochrom> Other times you are supposed to use qualified imports in the first place.
13:11:07 <travisgriggs> i used the qualidfied imports like show in the chapter there. but i'm not sure i'm clear how the qualified import works in ghci.
13:36:15 <quarters> is the tl;dr for abstract classes vs interfaces 1) abstract class when sharing implementation of methods with some overrides 2) interface when only sharing API across classes?
13:36:20 <quarters> oop
13:36:21 <quarters> s
13:36:22 <quarters> sorry
13:36:26 <quarters> wrong channel
13:37:00 <dsal> quarters: Oh good.  We don't have those things.  heh
13:37:47 <quarters> yeah. sorry!
13:37:48 <dsal> haskell classes confuse people who have learned the word class from other languages.
13:42:32 <monochrom> Different communities use the same word for different meanings.
13:50:17 <dsal> Everything I've ever needed to know about culture, I learned from microbiologists.
13:50:34 <merijn> dsal: I just used yoghurt
13:51:11 <monochrom> Does your culture thrive on syntax sugar? :)
13:55:50 <travisgriggs> yeah, so what's confusing me, is that I open ghci, I set my prompt, then import qualified Data.ByteString.Lazy as B followed by B.pack [99, 97, 110] and I get "can" but the book says I should see Chunk "can" Empty
13:56:24 <travisgriggs> is the book (http://learnyouahaskell.com/input-and-output#bytestrings) showing its age?
13:56:37 <monochrom> The book's expected output notation is outdated.
13:57:04 <travisgriggs> ok, i'm cool with that then. just wanted to make sure i wasn't missing something fundamental. thank you monochrom 
13:57:14 <monochrom> lazy bytestring has enjoyed a new Show instance for a long time that doesn't tell you implementation details such as "Chunk".
13:58:25 <dsal> And isn't evil when combined with OverloadedStrings.
14:04:33 <c_wraith> monochrom: did anyone ever tell you why ghc monomorphizes types in a case? (it's about existentials)
14:05:11 <monochrom> ah, that would do it
14:10:47 <koz_> monochrom: I am always reminded that Haskell, ML, Prolog and C++ all use 'functor' to mean rather different things.
14:10:59 <koz_> (and I only remember the non-Prolog definitions)
14:12:57 <c_wraith> ML's means the same thing - just a very different expression of the idea. remember that category theory is a lot broader than Haskell's classes named after ideas from it 
14:13:03 <monochrom> darn I forgot the prolog kind of functors
14:13:41 <monochrom> well ML's functor is on a completely different category, it's different enough that I would call them different
14:14:11 <c_wraith> well. used totally differently, but still an expression of category theory functors 
14:15:14 <monochrom> I agree that haskell's and ml's are real functors, c++'s is an imposter.
14:15:17 <c_wraith> unlike C++ functors, which are more like "we heard someone say this once, this is probably what they meant"
14:17:19 <koz_> What is the Prolog functor again?
14:21:19 <edwardk> koz_: Are you referring to LogicT?
14:26:15 <koz_> edwardk: Nope. I'm asking for 'what does Prolog-the-language mean when referring to the term 'functor''.
14:26:24 <koz_> (there was a question mark somewhere there)
14:28:45 <jumper149> I want to use QuantifiedConstraints with Control.Monad.Trans.Control.MonadBaseControl but I can't seem to get it working: http://ix.io/2rP1
14:29:19 <jumper149> liftApplication (with an extra type class) and liftApplication' work fine. liftApplication'' doesnt
14:29:37 <gaussian> koz_: data constructors are called functors in prolog
14:29:46 <koz_> gaussian: Ah, thanks.
14:30:47 <jumper149> Should I need AllowAmbiguousTypes here?
14:43:33 <fog> i mentioned something in passing, which was wrong, when i called particle smoothing "rolling particle filtering"  
14:44:09 <fog> as motivation for the study of upwind schemes 
14:44:41 <fog> this document https://www.stats.ox.ac.uk/~doucet/doucet_johansen_tutorialPF2011.pdf says;
14:44:59 <fog> " Whereas filtering corresponds to estimating the distribution of the current state of an HMM based upon the observations received up until the current time, smoothing corresponds to estimating the distribution of the state at a particular time given all of the observations up to some later time"
14:45:23 <fog> "The trajectory estimates obtained by such methods, as a result of the additional information available, tend to be smoother than those obtained by filtering"
14:48:50 <hseg> just noticed a bad interaction between ViewPatterns and PatternSynonyms: \(f -> S x), even when the pattern S is complete on its own, is considered inexhaustive
14:49:15 <hseg> however, \(S (f' -> x)) is accepted as exhaustive
14:57:51 <monochrom> w00t, ghcup gets a TUI
14:58:00 <maerwald> has
14:58:23 <monochrom> is it new since 0.1.6?
14:58:27 <maerwald> yes
14:58:46 <monochrom> very nice
15:00:14 <maerwald> cli is growing a bit more complicated and since github actions now uses cli interface too, usability changes are harder
15:01:07 <maerwald> you'll end up with ghcup v2-install
15:01:23 <monochrom> hahaha
15:01:40 <merijn> hseg: Exhaustiveness checking is *really* hard
15:02:31 <maerwald> talking about hard... https://www.youtube.com/watch?v=t0mhvd3-60Y 30 minutes in and I already have a brain aneurism
15:03:29 <maerwald> but it's happening, so we cannot look away can we
15:05:40 <maerwald> polymorphic -> ...
15:06:52 <MarcelineVQ> aneurism?
15:08:08 <maerwald> aneurysm
15:08:18 <maerwald> you geh a grammar cookie
15:09:55 <monochrom> Wadler's old paper "linear types can change the world!" may or may not help
15:10:09 <monochrom> but at least it's Wadler-fun
15:11:08 <monochrom> do get some sweet lolipop to sweeten the deal
15:11:11 <MarcelineVQ> I mean what thing about it is giving you the aneurism
15:11:39 <maerwald> all
15:12:01 <maerwald> too much design space, too many implications
15:14:06 <maerwald> those are the things you take 3 weeks off for, move to a lake in Sweden and recover slowly
15:15:26 <maerwald> reading type sigs is really confusing
15:18:15 <fog> i have this document, as an LHS file, i think for use with lhs2tex; https://pastebin.com/raw/rHng1J3x
15:18:44 <fog> but i dont have latex installed, and its annoying to have to download it each time just to process into pdf
15:18:50 <fog> is there a pure haskell solution? 
15:29:52 <slack1256> no, sorry.
15:30:32 <slack1256> Even pandoc uses a tex engine to output pdf as it's a really complicated format.
15:33:11 <fog> fair enough.
15:33:23 <fog> is that pandoc more lightweight though?
15:33:32 <fog> and with different build steps?
15:34:04 <fog> or does it just use the like, several gigs of texworks or whatever version
15:34:22 <fog> like, does it use any version, or do you have to set up a specific version?
15:34:36 <fog> (im hoping it uses a lightweight alternative) 
15:35:27 <fog> and, how can i run pandoc to generate a pdf from existing projects?
15:35:49 <fog> i have a bunch that use lhs2tex to generate pdf writeups of source code
15:36:36 <fog> i think that sample above was output in such a way, but for searching over my references (thats the output of the search "kalman") 
15:39:46 <Entroacceptor> Well, there is https://hackage.haskell.org/package/HPDF
15:41:26 <fog> hmm, i guess i actually need Tex support, for backward compatibility with the existing tooling. mostly i need bibtex support
15:41:35 <fog> probably too much to ask for a pure solution
15:41:56 <fog> if pandoc uses tex i guess thats as close as im going to get
15:42:23 <fog> and if it integrates easier, like building using cabal install - that would be great
15:42:45 <fog> though i guess i would have to install tex separately, which makes me wonder what versions it supports 
15:43:54 <fog> aha, i find this; https://pandoc.org/MANUAL.html#option--pdf-engine
15:43:55 <Entroacceptor> Probably everything, TeX is a pretty slow moving target.
15:44:15 <Entroacceptor> Oh, there's this... thing https://wkhtmltopdf.org/. Just generate HTML and let a browser make a PDF.
15:45:05 <fog> yeah, but all my citations are in bibtex format
15:49:04 <fog> the outputs end up looking like this; https://www.docdroid.net/DZmLr0Z/2019-01-28-2019-03-01-pdf
15:49:55 <fog> but latex crashes randomly beyond about 400 citations
16:44:26 * hackage numhask 0.6.0.1 - numeric classes  https://hackage.haskell.org/package/numhask-0.6.0.1 (tonyday567)
16:54:26 * hackage numhask 0.6.0.2 - numeric classes  https://hackage.haskell.org/package/numhask-0.6.0.2 (tonyday567)
17:27:47 <slack1256> I have a gi-gtk program that does nothing but consumes 2.5% of cpu time. This is when it's compiled with profiling enabled. When compiled with optimizations it is around 0.3%. Does anyone else has that experience?
17:36:59 <slack1256> Nevermind, how %cpu is calculated in `ps` didn't match my expectations.
17:39:27 * hackage monad-control-identity 0.1.0.0 - Stronger classes than monad-control  https://hackage.haskell.org/package/monad-control-identity-0.1.0.0 (jumper149)
18:01:53 <jocosejan> Hi ! Can I ask a question about haskell language, please ?
18:09:23 <Axman6> I guess not
18:20:40 <liiae> what is this function? unembed :: Functor f => (forall b . (a -> b) -> f b) -> f a
18:20:55 <liiae> :t unembed
18:20:57 <lambdabot> error: Variable not in scope: unembed
18:22:34 <liiae> embed :: Functor f => f a -> (forall b . (a -> b) -> f b)
18:24:26 <ezzieyguywuf> hm, when should I call my function `parseThing` versus `lexThing`
18:27:00 <fog> lex is unfolding, parse is folding
18:27:40 <fog> liiae: i dont think you can do that
18:27:48 <fog> you would need a constraint over b
18:28:42 <fog> wait...
18:28:52 <fog> is that just a partially applied fmap?
18:29:35 <fog> :t \xs -> flip fmap xs
18:29:36 <lambdabot> Functor f => f a -> (a -> b) -> f b
18:29:47 <glguy> embed :: Functor f => f a -> (forall b. (a -> b) -> f b); embed x f = fmap f x
18:29:48 <glguy> unembed :: Functor f => (forall b . (a -> b) -> f b) -> f a; unembed f = f id
18:30:35 <fog> looks like build of build/fold fusion, but for functors
18:31:21 <fog> (embed does)
18:31:29 <fog> and unembed looks like a continuation 
18:31:39 <fog> :t ($ a)
18:31:41 <lambdabot> (Expr -> b) -> b
18:32:19 <glguy> liiae: Looks like http://hackage.haskell.org/package/kan-extensions-5.2/docs/Data-Functor-Yoneda.html liftYoneda and lowerYoneda
18:32:57 <fog> argh! not the dreaded yoneda
18:33:00 <fog> escape!
18:33:22 --- mode: ChanServ set +o glguy
18:33:22 --- mode: glguy set -q *!*@*/ip.109.249.184.248
18:33:24 <koz_> Suppose I have foo :: Prism' s a and bar :: Prism' s a. Can I compose them to give a Prism' s a which tries both, in that order, and misses if both miss?
18:33:51 --- mode: glguy set -o glguy
18:34:03 <koz_> I'll accept an AffineTraversal as a result of their composition happily.
18:34:09 <glguy> koz_: there's `failing`
18:35:02 <koz_> https://hackage.haskell.org/package/optics-core-0.3/docs/Optics-Fold.html#v:failing ?
18:36:30 <liiae> glguy: is it useful in real programming?
18:37:33 <glguy> I've seen it used to help GHC optimize uses of Lens, and it comes up in a small way in the way my configuration schema library is implemented, among other places
18:39:07 <koz_> glguy: I found 'without', which fits my criteria.
18:39:08 <liiae> glguy: does it require math backgroud to understand this?
18:39:33 <glguy> not really. You can understand it independently from the actual yoneda lemma
18:40:29 <liiae> glguy: I've seen some articles about yoneda lemma, but I still have no idea what it's about
18:41:32 <justsomeguy> I think it's a citrus flavored dessert, a jewish recipe.
18:41:45 <glguy> liiae: two things really, making it more efficient to repeatedly use fmap on something
18:41:48 <justsomeguy> ...just kidding
18:41:57 <glguy> and making it possible to use fmap on something at all when it isn't already a functor
18:43:27 <liiae> glguy: is it related to CPS?
18:54:31 <koz_> Also, is there an optic that can go from 'Either a a' to 'a'?
18:56:14 <glguy> > Right 'a' ^.. both
18:56:16 <lambdabot>  "a"
18:56:40 <koz_> How do you spell ^.. in non-symbol?
18:56:45 <glguy> toListOf
18:57:02 <koz_> And then I headOf I guess?
19:11:37 <infinisil> :t both
19:11:38 <lambdabot> (Data.Bitraversable.Bitraversable r, Applicative f) => (a -> f b) -> r a a -> f (r b b)
19:33:20 <Axman6> @tell liiae You might find these slides useful for understanding Yoneda and a few other similar ideas. Sadly it doesn't look like it was recorded. https://slides.yowconference.com/yowlambdajam2017/Humphries-ContinuationsAllTheWayDown.pdf?feature=oembed (talk info https://yowconference.com/talks/tim-humphries/yow-lambda-jam-2017/continuations-all-the-way-down-12518)
19:33:20 <lambdabot> Consider it noted.
20:01:26 * hackage pandoc-citeproc-preamble 1.5 - Insert a preamble before pandoc-citeproc's bibliography  https://hackage.haskell.org/package/pandoc-citeproc-preamble-1.5 (spwhitton)
20:11:17 <liiae> are there some exercise to help beginner to learn parsec?
20:41:08 <hololeap> liiae: i would say play around with parseTest
20:41:14 <hololeap> @hoogle parseTest
20:41:14 <lambdabot> Text.Parsec parseTest :: (Stream s Identity t, Show a) => Parsec s () a -> s -> IO ()
20:41:14 <lambdabot> Text.Parsec.Prim parseTest :: (Stream s Identity t, Show a) => Parsec s () a -> s -> IO ()
20:41:15 <lambdabot> Text.ParserCombinators.Parsec.Prim parseTest :: (Stream s Identity t, Show a) => Parsec s () a -> s -> IO ()
20:41:45 <hololeap> you give it a parser and a string and it prints the result to stdout
20:43:33 <hololeap> % import Text.Parsec
20:43:33 <yahb> hololeap: 
20:43:36 <hololeap> % import Text.Parsec.Char
20:43:36 <yahb> hololeap: 
20:44:48 <hololeap> % parseTest (string "hello" *> space *> string "world") "hello world"
20:44:48 <yahb> hololeap: ; <interactive>:29:30: error:; Ambiguous occurrence `space'; It could refer to; either `Text.Parsec.space', imported from `Text.Parsec' (and originally defined in `Text.Parsec.Char'); or `Text.PrettyPrint.HughesPJ.space', imported from `Text.PrettyPrint.HughesPJ'
20:44:59 <hololeap> haha
20:45:36 <hololeap> % import qualified Text.Parsec as P
20:45:36 <yahb> hololeap: 
20:45:42 <hololeap> % parseTest (string "hello" *> P.space *> string "world") "hello world"
20:45:42 <yahb> hololeap: "world"
20:46:23 <hololeap> liiae: it also helps to understand how Applicative works. parsec will help you develop a better intuition for Applicative/Alternative
20:48:48 <hololeap> % parseTest (string "hello" <* P.space <* string "world") "hello world"
20:48:48 <yahb> hololeap: "hello"
22:09:37 <koz_> How do you use @djinn?
22:10:43 <ja> @djinn a -> a
22:10:43 <lambdabot> f a = a
22:12:39 <ja> @djinn sel ? ((a,b),(c,d)) -> (b,c)
22:12:40 <lambdabot> Cannot parse command
22:12:45 <koz_> @djinn (Monoid a) => a -> a
22:12:45 <lambdabot> Error: Class not found: Monoid
22:12:48 <ja> @djinn ((a,b),(c,d)) -> (b,c)
22:12:48 <lambdabot> f ((_, a), (b, _)) = (a, b)
22:13:29 <ja> koz_: search for HTCon: https://github.com/augustss/djinn/blob/master/src/HTypes.hs
22:17:17 <ja> but why does Help.hs list types that are not implemented? https://github.com/augustss/djinn/blob/master/src/Help.hs#L38
22:20:31 <ja> koz_: oh wow, you can actually add types, i think! here's the real source (also explains the differences, i guess?) https://github.com/lambdabot/lambdabot/blob/master/lambdabot-haskell-plugins/src/Lambdabot/Plugin/Haskell/Djinn.hs
22:20:53 <ja> @djinn-names
22:20:53 <lambdabot> Either Left Right Maybe Nothing Just Bool False True Void Not Void Monad Eq Bool
22:23:30 <ja> @djinn-add class Monoid a where mempty :: a; mappend :: a -> a -> a; mconcat :: [a] -> a
22:23:33 <ja> @djinn-names
22:23:33 <lambdabot> Either Left Right Maybe Nothing Just Bool False True Void Not Void Monad Eq Bool Monoid
22:24:23 <ja> @djinn (Monoid a) => a -> a
22:24:24 <lambdabot> f = mappend mempty
22:31:41 <koz_> So basically 'id'. :P
22:35:05 <gaussian> @djinn (Monoid a) => (a, a) -> a
22:35:05 <lambdabot> f (a, b) = mappend a b
22:38:11 <ja> @djinn Not Bool -> Bool
22:38:12 <lambdabot> f a = void (a False)
22:38:18 <ja> what is this Not in djinn?
22:38:50 <c_wraith> type Not a = a -> Void
22:43:32 <ja> @djinn Bool -> Void -> Bool
22:43:32 <lambdabot> f _ a = void a
22:44:19 <c_wraith> @djinn (Bool -> Void) -> Bool
22:44:19 <lambdabot> f a = void (a False)
22:44:29 <ja> aaaah ok, gotcha
23:14:29 <Haskell-Newbie-o> Hi it seems stack works strangely on fedora.
23:14:43 <Haskell-Newbie-o> Excuse blob of text:
23:14:52 <Haskell-Newbie-o> $ stack upgradeCurrent Stack version: 2.1.3.1, available download version: 2.3.1Newer version detected, downloadingQuerying for archive location for platform: linux-x86_64-staticDownloading from: https://github.com/commercialhaskell/stack/releases/download/v2.3.1/stack-2.3.1-linux-x86_64-static.tar.gzDownload complete, testing executableVersion
23:14:52 <Haskell-Newbie-o> 2.3.1, Git revision de2a7b694f07de7e6cf17f8c92338c16286b2878 (8103 commits) x86_64 hpack-0.33.0New stack executable available at /home/a/.local/bin/stackAlso copying stack executable to /usr/bin/stackPermission error when trying to copy: /usr/bin: copyFile:atomicCopyFileContents:withReplacementFile:openBinaryTempFile: permission denied (Permission
23:14:53 <Haskell-Newbie-o> denied)Should I try to perform the file copy using sudo? This may failTry using sudo? (y/n) n
23:15:25 <Haskell-Newbie-o> $ which stack~/.local/bin/stack
23:16:00 <Haskell-Newbie-o> which stack
23:16:02 <Haskell-Newbie-o> ~/.local/bin/stack
23:16:37 <Haskell-Newbie-o> $ ~/.local/bin/stack --version
23:16:59 <Haskell-Newbie-o> Version 2.3.1, Git revision de2a7b694f07de7e6cf17f8c92338c16286b2878 (8103 commits) x86_64 hpack-0.33.0
23:17:39 <Haskell-Newbie-o> stack --version
23:18:05 <Haskell-Newbie-o> Version 2.1.3.1 x86_64Compiled with:
23:19:23 <Haskell-Newbie-o> Sorry the formatting not clear. Point is: which finds the new executable. Running with the path found by which gives the new executable. Running 'stack' somehow appears to run the old executable.
23:19:56 <ja> Haskell-Newbie-o: maybe you have an alias set?
23:20:07 <ja> Haskell-Newbie-o: try "alias stack" ?
23:20:57 <Haskell-Newbie-o> not found. Also checked alias output nothing relevent.
23:21:52 <ja> Haskell-Newbie-o: aren't you worried that the globally installed stack will interfere?
23:22:37 <ja> oh, maybe there is none, and stack just wants to install it per default?
23:22:44 <Haskell-Newbie-o> If my PATH is constructed so .local is found first, is that not enough? Or does Haskell Platform use hard
23:22:53 <Haskell-Newbie-o> coded paths internall?
23:22:58 <Haskell-Newbie-o> internally?
23:23:44 <ja> i don't know. but Haskell Platform is distinct from Stack, i think. so where does Haskell Platform come into the picture?
23:24:20 <Haskell-Newbie-o> https://www.haskell.org/platform/#linux-generic
23:24:56 <ja> aah ok, got it. you got stack with the platform
23:25:35 <Haskell-Newbie-o> It appeared to be the normal route. Not so?
23:26:04 <ja> last time i used stack i used this: https://docs.haskellstack.org/en/stable/README/#how-to-install
23:26:45 <ja> i guess the platform should work? i don't completely understand what the point is, since stack manages your haskell installations anyway
23:27:37 <Haskell-Newbie-o> I think you are saying is I can have the latest haskell without having the latest stack. Is that what you meant?
23:28:36 <ja> yes, stack can download multiple GHC's, and you can have them in parallel.
23:29:43 <Haskell-Newbie-o> Ah and now I have parallel stacks! I have attained parallel computing Nirvana.
23:29:55 <ja> with stack it is more simpler to think in terms of versions of the whole ecosystem, since they also version that. see https://docs.haskellstack.org/en/stable/README/#why-stack
23:30:27 <ja> Haskell-Newbie-o: hehe well i don't see much advantage in having multiple stacks, so i'd get it cleaned up somehow
23:31:33 <ja> i dunno where you got all your installations from, but maybe it'd be worth it to clean up properly after all the installations, and then install stack using stacks own installer? that at least should be able to update itself cleanly
23:32:41 <Haskell-Newbie-o> Initial install using 
23:32:44 <Haskell-Newbie-o> dnf install haskell-platform # Recommended by www.haskell.org/platform/
23:33:33 <ja> i wouldn't try to ask any tool to upgrade itself if you got it through a system package management system...
23:34:12 <Haskell-Newbie-o> stack upgrade  #Recommended by https://www.haskell.org/platform/#linux-generic
23:35:03 <Haskell-Newbie-o> @ja that's why I said 'no' to copying into the system /usr/bin/
23:35:03 <lambdabot> Sorry, look up one word at a time please.
23:35:41 <Haskell-Newbie-o> I have no idea what lambdabot is complaining about
23:36:21 <ja> Haskell-Newbie-o: right, i think maybe the documentation fails to note that you can't use 'upgrade' an installation to a different location
23:37:16 <ja> Haskell-Newbie-o: so, as said, in your situation i would remove stack with dnf, remove any configuration left, install stack with the curl|bash thingy and then enjoy a user-local installation that doesn't know anything about the distro package system
23:37:41 <ja> then you can upgrade it all your want
23:37:48 <Haskell-Newbie-o> If it's wrong to follow the installation directions on haskell.org, I don't know what to say. 
23:38:24 <ja> neither of them are plain wrong, they are just incompatible, i guess
23:39:48 <ja> given that system packages lag behind, i don't like using them for development
23:39:52 <Haskell-Newbie-o> I see the value of your suggestion. 
23:41:12 <ja> lambdabot was triggered by prefixing a message with an ampersand. my irc client hilights me if you use "ja: ", i think that is more common on irc
23:43:49 <Haskell-Newbie-o> Thank you. For beginner is there any reason not to use 
23:43:52 <Haskell-Newbie-o> The Glorious Glasgow Haskell Compilation System, version 8.6.5
23:45:43 <ja> it is reasonable version, i think it will work fine
23:46:30 <ja> but when you use stack, as mentioned previously, i think it is more useful to mind the stackage version, it implies the ghc version
23:47:27 <ja> like, stackage version lts-14.27 would imply ghc-8.6.5
23:47:53 <Haskell-Newbie-o> Please explain what you mean in practice.
23:49:15 <ja> if you only concentrate on the compiler version, you could get an issue if a package maintainer breaks a package's compatibility somehow, because you'd always be building the newest version
23:50:04 <ja> the stackage package set is built and tested together on a specific version, so you can commit the stackage version to version control, and you can be pretty sure that it will keep working, since the package set is pinned
23:51:12 <ja> and since stackage also has minor release versions, i believe you can pretty safely bump the minor version number there , you may get a new version of ghc, but it will only be a bugfixing upgrade, which is perfect for conservative users
23:51:25 <ja> anyway, this is all covered in the stack docs
23:51:41 <Haskell-Newbie-o> You mean just commit the version number of 'stackage' package?
23:52:09 <ja> if you build with stack, there is a file called stack.yaml that always contains the stackage version
23:52:28 <Haskell-Newbie-o> Or do I have to commit the executable stackage?
23:52:59 <ja> 'stackage' is not a haskell package, is it a whole set of most of the popular packages of haskell
23:53:50 <ja> Haskell-Newbie-o: no, don't commit any executables to version control
23:54:09 <ja> the stackage version implies the compiler version and the versions of the dependencies you use, so there is no need to do that
23:54:38 <ja> if you commit your stack.yaml to version control, the build environment can be easily recreated on another machine by the stack tool
23:55:59 <ja> https://docs.haskellstack.org/en/stable/GUIDE/#hello-world-example
23:56:57 <ja> ok my terminology may not have been 100% correct, you should read that link i just pasted
23:57:20 <Haskell-Newbie-o> "commit the stackage version to version control" means (1) commit the file stack.yaml? (2) commit something else?
23:58:05 <Haskell-Newbie-o> oh you answered, but transcript did not scroll
23:58:21 <Haskell-Newbie-o> Thank you!
23:59:09 <ja> good, i hope it works, i recommend the manual, it explains all
