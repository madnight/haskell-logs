00:00:33 <sicklork1n> I thought it would be an excellent puzzle but I thought 60s was way too short.
00:01:31 <int-e> yeah. maybe 5 minutes, but it could easily take longer.
00:03:02 <int-e> sicklork1n: but if you want to be mean, maybe provide bar by itself and ask for its type...
00:06:52 <sicklork1n> fix$(<$>)<$>(:)<*>((<$>((:[{-solvemeh -}])<$>))(=<<)<$>(*)<$>(*2))$1
00:09:04 <int-e> fmap fmap stuff tends to be hard to decipher
00:09:58 <int-e> Though half of those `<$>`-s will be `.`-s.
00:10:12 <int-e> @unpl fix$(<$>)<$>(:)<*>((<$>((:[])<$>))(=<<)<$>(*)<$>(*2))$1
00:10:12 <lambdabot> (fix ((((<$>) <$> ((:))) <*> ((((\ x y -> y >>= x) <$> \ a1 -> (\ a2 -> a2 : []) <$> a1) <$> (*)) <$> \ a0 -> a0 * 2)) 1))
00:10:41 <int-e> ah, @unpl doesn't really know the applicative stuff. too bad.
00:28:21 <liiae`> is there a way to check a list is increasing or not?
00:31:11 <koz_> liiae`: https://gist.github.com/kozross/5a13e32bc60e532c21f2e432e45a4b78
00:31:14 <koz_> Like that maybe?
00:31:38 <koz_> Depending on your definition of 'increasing', the <= might need to become a <.
00:31:41 <koz_> But same principle applies.
00:32:46 <Axman6> > let ascending = and . zipWith(<=)`ap`tail in ascending [1..10]
00:32:48 <lambdabot>  error:
00:32:48 <lambdabot>      Precedence parsing error
00:32:48 <lambdabot>          cannot mix ‘.’ [infixr 9] and ‘ap’ [infixl 9] in the same infix expr...
00:32:56 <Axman6> > let ascending = and . (zipWith(<=)`ap`tail) in ascending [1..10]
00:32:58 <lambdabot>  True
00:33:08 <koz_> Axman6: Lol, cute.
00:33:15 <Axman6> > let ascending = and . zipWith(<=)`ap`tail in ascending $ [1..10]++[10]
00:33:17 <lambdabot>  error:
00:33:17 <lambdabot>      Precedence parsing error
00:33:17 <lambdabot>          cannot mix ‘.’ [infixr 9] and ‘ap’ [infixl 9] in the same infix expr...
00:33:33 <Axman6> > let ascending = and . (zipWith(<=)`ap`tail) in ascending $ [1..10]++[9]
00:33:35 <koz_> Also, you can replace that `ap` with <*>.
00:33:35 <lambdabot>  False
00:33:49 <Axman6> @quote zip.ap.tail
00:33:49 <lambdabot> quicksilver says: zip`ap`tail the aztec god of consecutive numbers
00:33:56 <koz_> :t and . (zipWith (<=) <*> tail)
00:33:57 <lambdabot> Ord a => [a] -> Bool
00:34:29 <koz_> > and . (zipWith (<=) <*> tail) $ []
00:34:31 <lambdabot>  True
00:34:33 <koz_> > and . (zipWith (<=) <*> tail) $ [1]
00:34:35 <lambdabot>  True
00:34:38 <koz_> Wheeee.
00:35:16 <koz_> Three cheers for a pointless solution. :P
00:37:07 <koz_> :t mzip
00:37:08 <lambdabot> error:
00:37:09 <lambdabot>     • Variable not in scope: mzip
00:37:09 <lambdabot>     • Perhaps you meant one of these:
00:37:45 <koz_> % :t mzipWith
00:37:46 <yahb> koz_: ; <interactive>:1:1: error:; * Variable not in scope: mzipWith; * Perhaps you meant one of these: `Seq.zipWith' (imported from Data.Sequence), `BSL.zipWith' (imported from Data.ByteString.Lazy), `BS.zipWith' (imported from Data.ByteString)
00:38:02 <koz_> % import Control.Monad.Zip 
00:38:02 <yahb> koz_: 
00:38:29 <koz_> Ah, damn, can't get a generalized 'tail'.
00:39:00 <koz_> (MonadZip should totes be ApplicativeZip)
00:56:00 <int-e> Axman6: cute quote, but I'm not surprised that #haskell went down this path before :)
00:57:29 <Axman6> zip`ap`tail is one of the old gods of this channel, I remember being recommended it a decade ago
02:05:35 <liiae`> groupBy is not good enough
02:06:15 <liiae`> why it only groups two near by? what about three near by? or four?
02:06:46 <liiae`> it supposes to groups all the elements by the giving condition
02:07:47 <shachaf> > groupBy (==) [1,2,2,2,3,3,3,3,3]
02:07:49 <lambdabot>  [[1],[2,2,2],[3,3,3,3,3]]
02:09:04 <liiae`> > groupBy (<=) [1,2,2,3,1,2,0,4,5,2]
02:09:06 <lambdabot>  [[1,2,2,3,1,2],[0,4,5,2]]
02:09:21 <liiae`> it supposes to be [[1,2,2,3,1,2],[0,4,5,2]]
02:09:38 <liiae`> [[1,2,2,3],[1,2],[0,4,5],[2]]
02:10:16 <liiae`> fine, I found this https://hackage.haskell.org/package/groupBy
02:16:46 <MarkedOne> Hello! Why these [0..3], [0 .. 3], [LT .. GT] works but [LT..GT] doesnt?
02:17:06 <MarkedOne> Its like space is significant in ranges.
02:17:45 <Uniaika> MarkedOne: seems like alphabetical characters need an extra space
02:18:12 <Uniaika> and the error is fairly clear about it
02:18:12 <Uniaika>     Not in scope: ‘LT..’
02:18:12 <Uniaika>     No module named ‘LT’ is imported.
02:18:34 <Uniaika> alphabetical characters with a period get parsed as a module name
02:18:56 <MarkedOne> Oh okey.. so better always put space around .. right?
02:22:46 <Uniaika> if you cannot guarantee that you'll always have digits in your range expressions, yes, better always put spaces
02:24:44 <xerox_> > [(LT)..GT]
02:24:46 <lambdabot>  [LT,EQ,GT]
02:27:01 <MarkedOne> Hmmm nice
02:28:42 <MarkedOne> Another question why length [(0 :: Int) ..] does not terminate?  Int is bounded same as Bool or Ordering. Am I missing something?
02:33:24 <Uniaika> it does not terminate or you haven't reached maxBound yet? :P
02:36:25 <MarkedOne> Hmm..count to int max in loop should not take long I think xD
02:36:55 <dminuoso> MarkedOne: Consider how length is implemented.
02:37:12 <frobnicator> won't it overflow
02:37:13 <dminuoso>     length = foldl' (\c _ -> c+1) 0
02:38:03 <Uniaika> frobnicator: yeah pretty sure that you end up overflowing if you (+) ad infinitum 
02:39:48 <frobnicator> hmm, I don't think it will overflow
02:39:58 <frobnicator> the Enum instance for Int checks for overflow
02:40:02 <frobnicator> and will throw an error
02:40:24 <frobnicator> it does: succ x | x == maxBound = error ...; otherwise = x + 1
02:40:32 <MarkedOne> Hmm
02:40:47 <frobnicator> but it probably takes quite a while since Int's are probably 64 bit
02:41:51 <typetetris> Is there already a type like `Either` but strict?
02:41:53 <MarkedOne> Oh so we are on 64bit.. yeah.. then it can take a while... a longer while :D
02:42:26 <lortabac> if you do length [1..] it shouldn't overflow
02:43:10 <frobnicator> it will error out if you do length [1..]
02:43:16 <frobnicator> because succ from Enum checks for maxBound
02:43:48 <MarkedOne> I read that Integer is unbounded, and Int is ordinary int.. so I explicitly typed it to Int to see if it works
02:45:27 <lortabac> doesn't it stop at maxBound?
02:45:40 <maerwald> typetetris: https://hackage.haskell.org/package/strict-base-types-0.6.1/docs/Data-Either-Strict.html
02:45:46 <MarkedOne> (minBound, maxBound) :: (Int, Int)(-9223372036854775808,9223372036854775807)
02:45:52 <MarkedOne> So thats the problem :D
02:46:09 <maerwald> typetetris: note it cannot be a monad
02:46:19 <MarkedOne> I thing it will stop.. but it will take a long time.
02:47:40 <MarkedOne> I thought Int is 32bit...It seems it is 64bit on my machine (thats good indeed) I suppose it will terminate sometime xD
02:48:02 <typetetris> maerwald: Thanks!
02:50:56 <frobnicator> lortabac: it will throw an error
02:51:06 <lortabac> why?
02:51:12 <frobnicator> https://hackage.haskell.org/package/base-4.14.0.0/docs/src/GHC.Enum.html#local-6989586621679485735
02:51:22 <frobnicator> because it is defined to do so
02:52:02 <frobnicator> okay, it does not error out
02:52:13 <lortabac> I think it stops at maxBound
02:52:16 <frobnicator> yes it does
02:52:22 <frobnicator> [(maxBound :: Int) - 1 ..]
02:52:55 <lortabac> length [0..] overflows because it is maxBound + 1
02:53:04 <lortabac> but length [1..] should be ok
02:53:21 <absence> when generating a .hp file for profiling, all the names inside are shortened, like "catch.\/catch/try/dec...". how can i get longer names?
02:59:32 <absence> aha, -L
04:04:36 <bifunc2> hi all
04:05:17 <bifunc2> "stack sdist" does not automatically place package version bounds for my "build-depends" into the generated .cabal file.
04:05:27 <bifunc2> are such bounds actually needed for uploading to hackage?
04:05:34 <bifunc2> how important are they to add?
04:05:49 <bifunc2> (i'm mostly a stack user, not a direct cabal user)
04:06:11 <bifunc2> (who wants to add a package to hackage)
05:30:18 --- topic: 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: https://gist.github.com/ | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org'
05:30:18 --- topic: set by glguy on [Sat Jan 05 07:21:52 2019]
05:30:18 --- names: list (clog zincy__ chaosmasttter tom__ machinedgod shafox DavidEichmann __monty__ carlomagno1 random urodna rzmt taylskid joecordingley adam_wespiser solonarv mossplix petrus sgraf812[m] tromp cur8or Chucks John_Ivan Kamuela jneira Tourist sdx23 [exa] TommyC acertain wraithm duairc militia wayne jtobin jle` matheus23 infinisil Velpoman niko Wamanuz2 jzl chirpsalot mgaare_ mmaruseacph2 geal inimino CindyLinz reactormonk ezzieyguywuf atk lambdabot dh ArsenArsen cyphase)
05:30:18 --- names: list (MasseR darjeeling_ TMA otulp Bish klardotsh srhb ocharles rslima____ chalkmonster hiptobecubic kjak govg alexelcu texasmynsted evanjs raym codygman valdyn markus1199 pfurla nikka merijn maier Lord_of_Life alp kritzefitz dwt brown121407 acidjnk_new gekh1 lle-bout z0 ubert bennofs_ fweht Raito_Bezarius andreas303 oish juri_ thunderrd ClaudiusMaximus cosimone thc202 Tesseraction_r danso ggole mounty1 jose_zap Tuplanolla shutdown_-h_now MarcelineVQ fendor c6ristian)
05:30:18 --- names: list (geowiesnot aarvar xerox_ turion Tops21 John__ John20 ph88 vicfred valhalla _ht fresheyeball Foritus danvet greymalkin takuan m0rphism nineonine stepnem jlamothe Khisanth remexre fragamus grizwako[m] hyiltiz[m] solomon[m] jlorand[m] gcoakes[m] ethercrow[m] jhuizy[m] mikr[m] mathyouguy jojotastic777[m] Noughtmare[m] khorser[m] atopuzov[m] bolti[m] iffsid dyniec[m] utdemir[m] joshua[m]2 whu[m] alexfmpe michael[m]2 vaibhavsagar siraben psydruid kadoban unclechu)
05:30:18 --- names: list (io_r_us[m] fossegrim[m] Hatsue Poscat[m] kaychaks_riot roberth maralorn Elorm[m] supersven[m] quiet_laika[m] schum domenkozar[m] srid rednaZ[m] redviking[m] iinuwa denbrahe[m] ArtemZ reed[m] drozdziak1 sajith[m] boistordu camlriot42 FAUST|thejonny fgaz jojoz[m] lnxw37d4 michaelpj Ericson2314 jluttine[m] freeman42x[m] jkhaak[m] execat[m] hsiktas[m] sepp2k Fernando-Basso[m Axman6 day so howdoi rizary rellen[m] Shun131 sm[m] pent PoliticsII__ terrorjack nlofaro)
05:30:18 --- names: list (alunduil ^[_ NemesisD cross adamse affinespaces kip sclv jesyspa JSharp dsal PotatoGim coot teehemkay nh2 sethetter FMJz___ pasukon ajmcmiddlin Cir0X parisienne___ rann scav davetapley Firedancer carter jared-w eacameron Boarders heyj lally parsnip betawaffle drbrule elvishjerricco bitonic atraii cstrahan dmj` raoul peutri Athas int-e mawk lockshaw Nikotiini Madars Niamkik steell haveo michalrus obiwahn vin-ivar abuss doconthe1ocks thestr4ng3r noctux grumble)
05:30:18 --- names: list (obfusk stefan-_ eyenx xintron ambiso voidcontext kaol codedmart zv pyrho TakinOver tarpk agrif javran kozowu zariuq Fischmiep koala_man kav gentauro poljar1 orion Guest99472 Guest3835 nshepperd2 iomonad kloeri fiQ2 digia Paks coddinkn_ ephemera_ riatre centril bonz060 blackbart avn jfredett_ qz hackage abrar lnx jchia_ Ranhir ziman dysfigured ahf Drezil cjh` daGrevis Bunogi theorb robogoat oats robotmay aurieeeh auri_ thaumavorio justache xwvvvvwx jchia__)
05:30:18 --- names: list (AWizzArd revprez_anzio lep-delete roconnor fliife850 bendo_ sdrodge Cale whatisRT Chi1thangoo wei2912 lagothrix notzmv tsrt^ megaTherion abbe opqdonut @Sigyn xelxebar cantstanya denisse lassulus swater Geekingfrog mimi_vx kAworu cgfbee doublex connrs- aweinstock nurupo uwap laxask krjst DigitalKiwi Techcable Benzi-Junior tinwood bananagram sophronios zyeri stux|RC-only leah2 amiri infty dixie Squarism Maxdamantus tasuki_ mceier vk3wtf Mindless- le_jonge bsima)
05:30:18 --- names: list (PragCypher averell LambdaDuck pacak cow-orker styledash narendraj9 wagle nerdypepper sqrt2 L1Cafe tdammers towel Reiser9 lyxia fre mort Moyst polux2001 connrs quintasan xarian ski rotaerk Aleksejs loc _janne frobnicator Firedancer_ tms_ Cathy Arguggi srk hyperfekt stvc pharaun grazfather Guest6919 wowi42 aldum madnight Jonno_FTW M2tias enikar simplegauss Cerise coeus NinjaTrappeur fredcy- farn_ ring0` tanuki nopf_ m1dnight_ tumdedum Vq jjhoo @ChanServ dexterfoo)
05:30:18 --- names: list (suppi dredozubov thonkpod drdo ego suzu_ tristanC duckonomy sphalerite zymurgy Ekho drewolson Kaivo drewr aplainzetakind tstat Uma geyaeb Rudd0 sMuNiX tabemann seanparsons sw1nn leothrix livvy cmsmcq Nilgeist GyroW_ Alleria_ tomsmeding edwtjo revprez_stg tomboy64 taktoa[c] wpcarro buggymcbugfix d0liver integral parseval pepeiborra laghee__ mpickering idnar gluegadget jbetz tnks lightandlight jonrh alexknvl liquorice gregberns_ moobar chpatrick caasih starlord)
05:30:18 --- names: list (Adeon banjiewen natim87 totbwf amatecha__ higherorder conjunctive hamishmack liszt AndreasK koankeeper newhoggy cbarrett lexi-lambda ryjm verlet64_ badzergling rodlogic_ peel ShadorainPhone alx741 nick_h adius zot Argorok billstclair chessai koz_ ChaiTRex rembo10 incognito9999_ Hotbees mcfilib mankyKitty amosbird ViCi^ wz1000 Takumo kqr jb55 ystael_ acarrico phreedom gehmehgeh Jesin jonathan1 crobbins dopplerg- drbean_ ft hyiltiz efm whiteline infinity0 jsb)
05:30:18 --- names: list (s00pcan L29Ah tomku clynamen hololeap eyenx|m jackdk m-renaud graingert ghuntley agander_m milessabin Cthalupa dddddd catern mananamenos davean nisstyre sayak EvanR kosmikus dolio jinblack monochrom russruss dmiles unlink2 noan joehh1 m1cl samebchase puffnfresh byorgey anoe_ Arjan arianvp pta2002 bollu Katarushisu APic Cheery caubert is_null gawen electrostat jassob marble_visions Dykam mupf sim590 Nistur dan64 c-rog Bergle_2 dftxbs3e haasn otto_s_ theDon)
05:30:18 --- names: list (irclogger_com davl bobey dani- J_Arcane dave_uy2 cp- Profpatsch Solarion Neuromancer magbo petersen flebron solrize kini Flonk_ shachaf bcoppens_ jmsx samebchase- jtcs mjrosenb landonf mrus wrunt locallycompact bind ptrcmd freeside barrucadu Jello_Raptor epta add^_ quaestor Guest20621 absence comboy luigy lowryder sea-gull mikolaj_ asm89 j_klee thebnq Uniaika ekleog justanotheruser bandali heredoc acro andi- t36s_ liff SegFaultAX milkii hodapp xacktm mjuad)
05:30:18 --- names: list (hexagoxel phz vjoki canta nekomune grol nemesit|znc ivegotasthma esph pieguy128 mozzarella Kaeipi entel totte zebrag jetpack_joe Inoperable runde NieDzejkob ridcully ap5 tabaqui1 hc Neo-- amf aidecoe arw exarkun adamCS beka kipras`away Guest60204 andjjj23 bob_twinkles NGravity blackdog bcmiller DustyDingo shapr eldritch Ornedan unsupervised d3lxa sshine nitrix urdh zfnmxt phaul CitizenSnips pdxleif eagleflo Chobbes topos cods jchia1 sajith dilinger micro_)
05:30:18 --- names: list (jameekim2 rprosper- incertia saurik rdivacky glguy ashnur shadowdaemon vnz dale idupree2 zgrep noexcept rom1504 Ferdirand tolt bspar debugloop magog ggVGc silver_needles Forkk yushyin nikola2 ManiacTwister ByronJohnson mingc SolarAquarion joehillen cjay hongminhee oldsk00l dumptruckman mursu joshmeredith CurryWurst systemfault siers iphy enemeth79 whataday mudri jlpeters Tritlo simony benwr_ cinayakoshka bradparker metadave edmundnoble DocKlobi dgpratt)
05:30:18 --- names: list (stylewarning bgavran ProofTechnique aristid voyons_osti Noldorin Orbstheorem dqd elcaro_ copypasteque_ yahb mstruebing recon_- nek0 martin02 Guest2322 benschza ixian raoulb sivs Taneb q3k _flow_ interruptinuse lukelau Bigcheese cocreature a3f solarus twk- nshepperd1 operand spoonm xcin immae jackhill rawles Majiir miklcct xnyhps PigDude i7c teqwve tomjaguarpaw jorj hiredman arkeet Kneiva vancz RoguePointer bjs Nascha johs DTZUZU tscholak kptech feuerbach_)
05:30:18 --- names: list (Arahael _ashbreeze_ jonatan oak_ fissureman e2 Natch glamas cyberlard statusbot troydm {abby} haskell_enthusia maerwald stilgart mniip pounce chindy thecoffemaker malthe cohn dcoutts niklasb_ loli meck motherfsck jdt dustinm- msgctl dminuoso Hijiri gilbertw1_ ornxka_ gareth__ amx RusAlex magicman hwabyong_ Philonous ent cpape johnstein Zemyla piele w1gz electrocat Ankhers Someguy123 a3Dman_ ps-auxw pierrot Logio nyaomi anderson pie_ hrnz oleks mr_yogurt)
05:30:18 --- names: list (happycoder Unode mantovani deni djanatyn reyu Eliel vimto1 atomi mounty spion ebutleriv yogani rdivyanshu_ zabracks Zialus_PT rotty dxld sud0 SomeB sm jokester e carldd gvx lnostdal Rembane sujeet sagax tensorpudding ulidtko ryantrinkle proteusguy Benett nshepperd jrm kristjansson spiderbubble typetetris kyagrd__ ddellacosta frdg lpsmith joeytwiddle hpc nak ichimaru forell ericsagnes echoreply stiell gsingh93 energizer albel727 mud brisbin marek jakalx zaquest)
05:30:18 --- names: list (nckx furnost esg tureba ja tessier lucianp_ xe4 ben phadej uberj Sparadox mikolaj davve runawayfive Twey exferenceBot ycheng jkarni fiddlerwoaroof Deewiant_ bobbytables jvanbure lemald Patternmaster cynick heath gargawel supki Tspoon dyl_ lieven balbirs esotericalgo xff0x dexterlb bwe_ runeks wildsebastian gaze__ zzz PtxDK whald angerman PatrickRobotham_ dsturnbull sgraf cvlad- fiadliel grfn isacl___ luite benl23 ReinH thi alanz_ ullbeking edwardk ibloom)
05:30:18 --- names: list (tabaqui crtschin orcus noecho Seich pong raid PyroLagus TimWolla Iroha DwarfMaster mulderr HiRE `slikts p3n sepplesWoona Faye saidinwot1 Randy Klumben mystfox aib sarahzrf bgamari noCheese kkd cheers Blkt sis7 relrod sveit komasa beaky Jon bjobjo Adluc hexo vodkaInferno joeyh deu myme lortabac spamlessj atle_ chrpape PHO darthThorik nate48423 feepo SrPx gienah statusfailed giovani datajerk veverak stree glowcoil dcoutts_ dequbed noteness Guest603 fryguybo1)
05:30:18 --- names: list (seliopou_ rodgzilla artem Heffalump rednaZ2 xlei SupaYoshi LittleFox dibblego jcarpenter2 verement kmein tv mac10688 kraem dmwit efertone nil mp___ gabiruh jhuizy divVerent ab9rf hvr devalot hive-mind vqrs c_wraith turq [df] Clint gothos ammar2 helpplz dragestil apoc newsham SquidDev Entroacceptor Tene earthy gambpang PlasmaStar WzC_ carbolymer)
05:30:45 <merijn> absence: GHC.Stats only accounts for memory used by GHC or the RTS, obviously :)
05:31:24 <merijn> typetetris: What are you really asking?
05:32:24 <merijn> "Is something known about the performance?" 'sure...'
05:33:44 <typetetris> merijn: Will 8 getCurrentTime per Second per thread hurt a lot?
05:33:59 <typetetris> merijn: Sorry don't know how to be more precise.
05:38:08 <merijn> it depends on the platform, etc.
05:38:24 <merijn> I expect the real question is "how do I cheap timing of code?"
05:38:34 <merijn> Which has a much more straightforward answer
05:38:38 <merijn> @hackage clock
05:38:38 <lambdabot> https://hackage.haskell.org/package/clock
05:41:47 <Arahael> Out of curiosity, does Haskell work natively on Apple Silicon yet - where might I learn about progress there?
05:46:24 <dminuoso> Well luckily we dont need to care really.
05:46:31 <dminuoso> Since we compile to LLVM, its an LLVM problem really.
05:46:50 <dminuoso> (The object file format on macOS will still be MachO I guess)
05:47:03 <dminuoso> At least thats how I see it
05:47:10 <dminuoso> Could be wrong :)
05:47:15 <maralorn> Are Effect systems with typelevel lists completely imcompatible with final tagless style? I realize that it's hard to mix monad transformers and effect systems, but am I overlooking something when I dream of an instance Member (Reader a) r => MonadReader (Eff r) a?
05:47:30 <Arahael> dminuoso: Oh, of course.
06:05:00 <bifunc2> Is it necessary to have version bounds for all build-depends, for libraries I upload to hackage?
06:11:23 <dminuoso> bifunc2: Strongly recommended you adhere to PVP.
06:11:38 <dminuoso> You can use `cabal gen-bounds` to get the strictest bounds within PVP.
06:12:04 <dminuoso> (Unbounded will just lead to breakage later)
06:12:29 <michaelh> Hi! Haskell beginner here. I'm reading some existing code bases like pandoc to see how they work. I wonder, is there a simple way to find out where a type is defined? For instance there's an `Element` type in pandoc which I don't know how it works, so I'd like to see where it is defined (if it even is, I don't know if it is perhaps a dependency?).
06:12:29 <michaelh> Is there a quick way to find out? Just looking at imports at the top of the file isn't very telling to me as a beginner.
06:12:42 <bifunc2> dminuoso, ok i will do that but out of curiosity, would the package be rejected by hackage maintainers without the bounds?
06:16:31 <dminuoso> No, but chances are people wont be as keen to use your package.
06:16:58 <dminuoso> michaelh: I'd use the haddock page.
06:20:56 <michaelh> dminuoso: Is that https://hackage.haskell.org/package/pandoc ?
06:21:00 <maralorn> michael: When you navigate to the generated haddocks, e.g. on hackage you can find a "show source" feature. And there all types and values known to the documentation generator are links to their definition.
06:21:37 <maralorn> michaelh: Yes
06:23:37 <michaelh> maralorn: Ah I see. Neat! Seems like my particular type doesn't have a link though. See https://hackage.haskell.org/package/pandoc-2.10/docs/src/Text.Pandoc.Writers.Docx.html#otherElements
06:23:59 <michaelh> I want to know what `[Element]` refers to, but it isn't a link
06:33:18 <michaelh> Ah, I think it's from Text.XML.Light
06:38:30 <maralorn> michael: Yeah, that's a pitty. One of the reasons why I really dislike the fact that unqualified imports are the default in Haskell.
06:39:23 <maralorn> michael: What can often help in such situations is hoogle. e.g. https://hoogle.haskell.org/?hoogle=Element it's actually the first hit there.
06:39:49 <maralorn> Im highlighting the wrong person the whole time, I am so sorry …
06:39:56 <maralorn> @hoogle Element
06:39:57 <lambdabot> Text.XML.Light.Types data Element
06:39:57 <lambdabot> Text.XML.Light.Types Element :: QName -> [Attr] -> [Content] -> Maybe Line -> Element
06:39:57 <lambdabot> Text.XML.HXT.Arrow.Pickle.Schema Element :: Name -> Schema -> Schema
06:40:28 <bifunc2> dminuoso thanks for the info! highly useful
06:40:32 <maralorn> michaelh: Look at that.^ So easy.^^
06:52:27 <michaelh> maralorn: Cool! Thanks!
07:15:12 <petrus> @hackage lambdabot
07:15:12 <lambdabot> https://hackage.haskell.org/package/lambdabot
07:21:27 <typetetris> Are ThreadIds from forkIO unique or do they get reused in a shortly manner?
07:29:59 <tdammers> typetetris: "yes"
07:30:17 <tdammers> iow, they might be unique, but I don't think you can (or should) rely on it
07:36:07 <maralorn> typetetris: I don‘t know. But from experience I can say that it looks like its just a counter that gets increased by one when you launch a new thread.
07:36:18 <maralorn> i.e. the threadnumbers I have seen where in the low on or two digit region.
07:36:51 <maralorn> So, don‘t use them as crypto nonces ;-)
07:37:12 * hackage streamly-binary 1.0.0.0 - Integration of streamly and binary  https://hackage.haskell.org/package/streamly-binary-1.0.0.0 (geyaeb)
07:58:50 <solonarv> typetetris: the docs say: "Note: in GHC, if you have a ThreadId, you essentially have a pointer to the thread itself. This means the thread itself can't be garbage collected until you drop the ThreadId. This misfeature will hopefully be corrected at a later date."
08:00:53 <solonarv> so if you have x,y::ThreadId, either they refer to the same thread (so they must be equal) or they refer to different threads which are both still live (and so must live at different addresses in memory, meaning x /= y)
08:03:12 * hackage autoexporter 1.1.18 - Automatically re-export modules.  https://hackage.haskell.org/package/autoexporter-1.1.18 (fozworth)
08:07:11 <__monty__> Is the precision of the show instance for Float configurable?
08:09:12 <dminuoso> No.
08:09:49 <dminuoso> Something like Text.Printf or a custom pretty printer are more adequate then.
08:12:05 <__monty__> Ok, thanks.
08:14:02 <Magalame> hi everyone, I have a bit of a pickle. I'm trying to write the kernel described there: https://gist.github.com/nadavrot/5b35d44e8ba3dd718e595e40184d03f0 in the section "register blocking", and I came up with this: https://github.com/Magalame/lascive/blob/master/src/Lib.hs. I have two problems 1) the output asm uses the xmm registers while I've
08:14:03 <Magalame> enabled -mavx2, and 2) the output asm doesn't look nearly as nice as what they get in the reference
08:14:56 <dminuoso> Magalame: Vectorization in GHC is an ongoing topic that is not well supported.
08:16:04 <dminuoso> Can you share the resulting assembly?
08:16:14 <Magalame> oh :(  
08:16:18 <Magalame> sure, give me a second
08:17:48 <dminuoso> GHC itself for example will not do auto vectorization at all, let alone do vectorization-related optimizations whatsoever.
08:18:17 <dminuoso> So all you can get is the vectorized primops, intertweened with whatever code artifacts you get. Plus whatever LLVM can do to your code
08:19:09 <Magalame> here you go https://filebin.net/nxk7abcnk1jgzmws
08:19:21 <dminuoso> Magalame: Feel free to give it a try on the simd branch of ghc.
08:19:24 <Magalame> that's what I've been doing, using DoubleX4 and the like
08:19:41 <Magalame> oh there is a seperate branch for simd?
08:19:53 <dolio> Magalame: Usually it's not recommended to mark recursive functions as inline.
08:20:23 <Magalame> my bad
08:20:48 <dminuoso> Magalame: yeah, but I have absolutely no clue what state it is in.
08:21:00 <dminuoso> https://gitlab.haskell.org/ghc/ghc/-/wikis/simd/implementation/plan
08:21:51 <Magalame> thanks I'll give it a try
08:22:04 <dminuoso> https://gitlab.haskell.org/ghc/ghc/-/tree/wip/simd
08:23:17 <dminuoso> Magalame: If for some reason you rely on high performance SIMD code, do it in C/C++ and expose it as FFI to haskell.
08:23:25 <dminuoso> (That's the current way to do it)
08:24:03 <dminuoso> (Or any other language really, as long as you can expose a C FFI)
08:24:26 <Magalame> Hmm I see, I'll try the FFI route then, thanks!
09:00:29 <hololeap> i'm having a hard time understanding this error: http://dpaste.com/1RYC24P
09:03:43 <dminuoso> hololeap: fundep means that if you have a -> b, then a must uniquely identify b
09:03:51 <dminuoso> You have two A's with different B's.
09:04:14 <dminuoso> class (Functor f, Representable u) => Adjunction f u | f -> u, u -> f where 
09:04:27 <dminuoso> So essentially f uniquely identifies u and conversely
09:04:41 <hololeap> hmm... bummer
09:05:04 <dminuoso> u uniquely identifies f
09:05:58 <hololeap> i just wanted a newtype version of EnvT so that i could use DerivingVia on it
09:07:21 <hololeap> so if i had something like `newtype T a = T (E, a)` i could get all those instances for free by using `deriving via EnvT'`
09:07:41 <dminuoso> well if you newtype ReaderT you can do that...
09:08:26 <hololeap> oh, true. but the adjunction stuff was really just out of curiosity. probably not worth it to set up a newtype for ReaderT as well
09:08:36 <hololeap> anyway, thanks for explaining the error
09:29:16 <ks0n2> Is it possible to store Aeson Values as jsonb with postgresql-simple?
09:32:43 <ks0n2> When I try I get the error "column foo is of type jsonb but expression is of type text". To ToField instance for Values converts them to Text (toField = toField . JSON.encode)
09:43:42 * hackage opentelemetry 0.6.0 -   https://hackage.haskell.org/package/opentelemetry-0.6.0 (DmitryIvanov)
09:44:42 * hackage opentelemetry-lightstep 0.6.0, opentelemetry-wai 0.6.0, opentelemetry-extra 0.6.0 (DmitryIvanov)
09:57:52 <ks0n2> phadej: maybe you know? (as maintainer)
09:58:06 <ks0n2> or lpsmith ?
09:59:24 <phadej> ? :: jsonb
10:01:26 <ks0n2> https://www.postgresql.org/docs/current/datatype-json.html
10:01:34 <phadej> and similarly when selecting, `field :: text`
10:01:45 <ks0n2> oh! in the query?
10:01:56 <phadej> yes,
10:01:57 <phadej> SELECT '5'::json;
10:02:01 <phadej> kind of.
10:02:17 <phadej> postgresql-simple talks "text"
10:02:58 <phadej> it doesn't dictate whether you want to store json values as text, json or jsonb
10:03:28 <phadej> so you might need to add casts
10:06:01 <phadej> This is reasonable comprimise, SQL would be awful if one added a literal syntax for JSON values
10:06:10 <ks0n2> so let's say I have `execute_ c " insert into foo (bar) values (?) " (Only json)` 
10:06:48 <ks0n2> I'd instead say "insert into foo (bar) values (? :: jsonb)" ?
10:07:15 <phadej> try :)
10:08:28 <ks0n2> I'm just hoping there's another way since I'd have to break a couple layers of abstraction to pass the ":: jsonb" annotation to the query in this particular case
10:10:59 <phadej> you can write your own ToField for your type (i.e. not Value), look at e.g. how `ToField (In a)` is implemented
10:11:44 <ks0n2> Ok great, thanks
10:12:35 <phadej> though, I think you have something wrong elsewhere
10:12:36 <phadej> as
10:12:37 <phadej> phadej=# insert into testjson (foo) values ('1');
10:12:37 <phadej> INSERT 0 1
10:12:37 <phadej> phadej=# insert into testjson (foo) values ('1' :: text);
10:12:39 <phadej> ERROR:  column "foo" is of type jsonb but expression is of type text
10:12:42 <phadej> LINE 1: insert into testjson (foo) values ('1' :: text);
10:12:53 <phadej> i.e., if there is no annotation, postgres is smart enough to infer stuff
10:13:46 <phadej> e.g. if you do
10:13:47 <phadej> phadej=# insert into testjson (foo) values ('1' || '2');
10:13:47 <phadej> ERROR:  column "foo" is of type jsonb but expression is of type text
10:13:47 <phadej> LINE 1: insert into testjson (foo) values ('1' || '2');
10:14:02 <phadej> || returns text, and at that point cast isn't inserted
10:16:15 <phadej> so "insert into foo (bar) values (?)" should work, but it doesn't look like you do as simple thing
10:16:56 <ks0n2> yeah it's slightly more complicated - it's an array of jsonb.
10:17:44 <phadej> I guess then the casting doesn't work
10:20:07 <phadej> I get
10:20:07 <phadej> phadej=# insert into testjson (foo) values (ARRAY['1', '2'] );
10:20:08 <phadej> ERROR:  column "foo" is of type jsonb[] but expression is of type text[]
10:20:19 <phadej> but
10:20:19 <phadej> phadej=# insert into testjson (foo) values (ARRAY['1' :: jsonb, '2'] );
10:20:19 <phadej> INSERT 0 1
10:20:20 <phadej> works
10:20:49 <phadej> anyway, this doesn't seem to be postgresql-simple problem, but postgres ways of working in general. I hope this is enough so you can figure out the rest
10:21:13 <ks0n2> phadej: just got it working with an instance similar to the "In" instance. Thanks!
10:30:42 * hackage percent-encoder 0.0.0.0 - Percent encode/decode ByteStrings  https://hackage.haskell.org/package/percent-encoder-0.0.0.0 (dnmfarrell)
10:51:06 <travisgriggs> total n00b here. I'm on a journey to learn haskell. my hope is that i'll have an "aha" moment eventually, i'm patient. 
10:51:42 <hc> hello travisgriggs, good luck :)
10:54:16 <travisgriggs> i've been going through the "Learn You a Haskell" book. I have ghc installed via brew on my mbp. Things have been going swimmingly until i got to the Randomness section in chapter 9 (Input and Output). I'm thinking the brew installation of ghc does not include a System.Random module?
10:56:12 <c_wraith> brew, so you're on mac?  I recommend managing ghc installations with ghcup
10:56:44 <c_wraith> still, random *should* be there.  if you run `ghc-pkg list`, is some version of random in the output list?
10:56:46 <merijn> travisgriggs: I would recommend against using homebrew for ghc
10:56:49 <maerwald> brew is a good way to get into trouble :/
10:56:53 <maerwald> generally
10:56:59 <merijn> travisgriggs: Homebrew favours the bleeding edge too much
10:57:06 <merijn> travisgriggs: Operative word "bleeding" ;)
10:57:21 <merijn> Either ghcup or simply installing the binary distribution is the way to go, imo
10:58:38 <hc> stack works quite well on macosx, too
10:58:49 <basic> i might be stupid right now, but how do list comprehensions filter out things?
10:59:01 <basic> [x | x<- [1..], x > 2]
10:59:03 <hc> [ a <- [1, 2, 3], a >= 2]
10:59:10 <basic> i mean what is this desugared into?
10:59:13 <travisgriggs> yes, i saw stack references, but i think i need to limit my scope of confusion for the time being. 
10:59:24 <basic> hc: you a bot :o?
10:59:32 <c_wraith> stack is a lot of complexity for little gain over modern use of cabal
10:59:36 <basic> [x | x<- [1..], x > 2]
10:59:37 <maerwald> travisgriggs: good choice
10:59:43 <oats> basic: it's actually desugared to list monad operations :D
10:59:55 <hc> basic: [1..] >>= \x -> guard (x > 2) >> x   something like this
10:59:58 <basic> yeah i know.. but how do you return nothing
11:00:01 <maerwald> travisgriggs: fyi https://www.haskell.org/ghcup/
11:00:12 <basic> im pretty sure i know this, but just forgot
11:00:12 <oats> basic: what do you mean?
11:00:15 <hc> basic: yes, I'm a turing complete bot
11:00:16 <c_wraith> > guard False :: [Int] -- basic 
11:00:17 <lambdabot>  error:
11:00:17 <lambdabot>      • Couldn't match type ‘()’ with ‘Int’
11:00:18 <lambdabot>        Expected type: [Int]
11:00:25 <c_wraith> > guard False :: [()] -- basic 
11:00:25 <travisgriggs> are the "beware brew" comments for brew in general? or just for haskell use?
11:00:25 <basic> hc: sick, written in haskell?
11:00:27 <lambdabot>  []
11:00:48 <basic> c_wraith: can you elaborate, don't quite get it yet
11:00:51 <hc> basic: in something that's computationally exquivalently powerful, at least
11:00:52 <c_wraith> basic: it comes down to how (>>=) works for lists. 
11:01:05 <basic> hc: so whitespace it is
11:01:09 <maerwald> travisgriggs: when building haskell binaries on mac... brew generally causes trouble
11:01:12 <maerwald> ime
11:01:18 <basic> c_wraith: i do, but i can't remember how i would NOT add things to a list?
11:01:18 <c_wraith> > [1..5] >>= \x -> if even x then [] else [x, x]
11:01:20 <lambdabot>  [1,1,3,3,5,5]
11:01:26 <basic> oh.. that is it?
11:01:28 <maerwald> that is, if you want them to be portable
11:01:40 <maerwald> which is probably not your concern
11:01:45 <maerwald> but nonetheless
11:01:55 <travisgriggs> preferred pastebin for this channel?
11:02:20 <c_wraith> basic: yeah.  the trick is that it's an interaction between how a couple other things work.  The important part is that (>>=) can filter or add elements to a list, depending on what the second argument does
11:02:28 <oats> travisgriggs: gist is good
11:02:34 <basic> c_wraith: so i can't quite do that myself if i am doing do { x <- [1..2]; y <- [1..2]; return $ (x,y);}
11:02:34 <maerwald> @where pastebin
11:02:34 <lambdabot> http://rafb.net/paste
11:02:44 <maerwald> lol
11:02:48 <maerwald> that's down
11:03:02 <basic> c_wraith: i cannot add my own guaard in there? can i?
11:03:07 <c_wraith> http://paste.debian.net/ is a fine pastebin
11:03:19 <c_wraith> basic: you can!
11:03:27 <basic> by just saying "[]" ?
11:03:29 <sm[m]> hastebin and termbin are also handy
11:03:37 <c_wraith> > do { x <- [1..2]; y <- [1..2]; [] ; return $ (x,y);}
11:03:39 <lambdabot>  []
11:03:44 <travisgriggs> generally speaking, i had issues in the past with fink, port, brew. but when i got this new 16" mbp, i decided to give brew a chance again and go all in this time instead of piecewise. if i can do it with brew, i do. so far (fingers crossed) for the last 4 months things have been really good
11:03:45 <oats> basic: well, you would stick "guard False" in there
11:03:53 <oats> then you would end up with an empty list
11:04:04 <basic> c_wraith: uh? why is it ignoring the return
11:04:17 <c_wraith> basic: because return doesn't mean what it does in imperative languages
11:04:22 <basic> yeah no, i get it
11:04:35 <c_wraith> > [] >>= \x -> return x
11:04:36 <lambdabot>  []
11:04:38 <hc> isn't return "deprecated" since a while infavor of pure?
11:04:42 <c_wraith> not really
11:04:45 <basic> but i always figured it is the last expression of a do block
11:04:54 <oats> basic: is there some other larger problem that you're trying to solve, or is this just for learning?
11:04:56 <basic> hc: it should imho, as a new guy
11:05:03 <basic> oats: always learning
11:05:15 <basic> that do block should be
11:05:15 <hc> using return for what it is used is the humor of the haskell community, i guess :)
11:05:16 <c_wraith> > return 1 >> return 2 >> return 3 :: [Int]
11:05:18 <lambdabot>  [3]
11:05:21 <sm[m]> Hm, lots of shade for travisgriggs’ brew-installed ghc, but no evidence it’s causing any problem
11:05:33 <basic> c_wraith: yeah that doesn't explain why your last thingie is "preferring" the empty list
11:05:39 <hc> > const (return 1) <<= return 2
11:05:41 <lambdabot>  error:
11:05:41 <lambdabot>      • Variable not in scope:
11:05:41 <lambdabot>          (<<=) :: (b0 -> m0 Integer) -> m1 Integer -> t
11:05:48 <c_wraith> sm[m]: well, I did ask if `ghc-pkg list` showed a version of random.  that was just ignored.
11:05:53 <hc> > const (return 1) =<< return 2
11:05:55 <lambdabot>  error:
11:05:55 <lambdabot>      • Ambiguous type variable ‘m0’ arising from a use of ‘show_M512050530053...
11:05:55 <lambdabot>        prevents the constraint ‘(Show (m0 Integer))’ from being solved.
11:06:21 <hc> why does that stmt work on my ghci? :)
11:06:21 <hyperisco> > [a, b, c] >>= f
11:06:23 <lambdabot>  error:
11:06:23 <lambdabot>      • No instance for (FromExpr [()]) arising from a use of ‘e_1’
11:06:23 <lambdabot>      • In the expression: e_1
11:06:34 <c_wraith> hc: because ghc makes m into IO
11:06:38 <c_wraith> hc: lambdabot does not
11:06:41 * hackage ghc-plugs-out 1.0.0.0 - Type checker plugins without the type checking.  https://hackage.haskell.org/package/ghc-plugs-out-1.0.0.0 (philderbeast)
11:06:43 <travisgriggs> https://gist.github.com/travisgriggs/a22f40a721f6961c3130353561ef41f4 (ghc-pkg list)
11:06:49 <basic> [1,2] >>= (\x -> [1..2] >>= (\y -> [] >> (...something)))
11:06:51 <basic> right?
11:07:00 <basic> is that the problem that "[] >>" gets evaluated?
11:07:01 <hc> c_wraith: ah, makes sense
11:07:07 <travisgriggs> no evidence of any random stuff. or any system stuff really. but i don't know what Cabal is...
11:07:24 <hc> > const (return 1) =<< return 2 :: IO Int
11:07:26 <lambdabot>  <IO Int>
11:07:27 <hyperisco> > [a, b, c] >>= \x -> [x]
11:07:28 <lambdabot>  [a,b,c]
11:07:30 <hyperisco> > [a, b, c] >>= \x -> [x,x]
11:07:31 <c_wraith> travisgriggs: well, yep.  No version of random installed there.  that's unusual, as random usually comes with ghc.  I would, in fact, blame that on brew....
11:07:32 <lambdabot>  [a,a,b,b,c,c]
11:07:41 <hc> > const (return 1) =<< return 2 :: [Int]
11:07:43 <lambdabot>  [1]
11:07:45 <hc> finally! :)
11:07:57 <basic> > do { [] >> return 1 };
11:07:59 <lambdabot>  <hint>:1:22: error: parse error on input ‘;’
11:08:01 <basic> someone explain that please ;;
11:08:09 <basic> > do { [] >> return 1 }
11:08:11 <lambdabot>  []
11:08:33 <basic> i guess because >> does always return the thing that is put into it
11:08:37 <basic> ?
11:08:45 <basic> hm, no :/
11:08:58 <basic> i cam with questions and again i get even more questions!
11:09:13 <dsal> basic: >>= doesn't move forward from an empty list
11:09:27 <dsal> > do { [1] >> return 2 }
11:09:28 <lambdabot>  [2]
11:09:29 <hyperisco> basic, [a, b, c] >>= f  =  concat [f a, f b, f c]
11:09:29 <travisgriggs> so where is the system stuff at? Because I was able to use System.IO, System.Environment, and System.Directory in previous sections
11:09:34 <oats> basic: while doing list monadicky things, you can think of it as stringing together a list of operations that take in a single value and return a list
11:09:39 <basic> wait what.. why is >> acting like >>= there
11:09:53 <dsal> what else would it act like?
11:10:00 <basic> oats: i understand the list monad, but im confused about >> right now
11:10:06 <hyperisco> basic,  m >> n  =  m >>= \_ -> n
11:10:09 <c_wraith> It's a requirement that a >> b is equivalent to a >>= const b
11:10:16 <basic> dsal: uhm, i always figured do blocks "return" the last expression inside them
11:10:19 <oats> basic: if at any point in that pipeline, an empty list appears, that "chain" cannot produce any more non-empty lists
11:10:30 <hc> basic: return 1 >> 2   is equal to       return 1 >>= \_a -> return 2
11:10:35 <oats> because there's no more values in that list to work off of
11:10:41 <dsal> basic: Not at all.  It's super important that that they can effectively short-circuit like that.
11:11:11 <basic> so.. if a expression aboves "decides" that the remaaining things dont get evaluated, it simply doesn't
11:11:14 <basic> is that kindaa it?
11:11:14 <dsal> > do { a <- Just 1; b <- Just 2; pure (a + b) }
11:11:16 <lambdabot>  Just 3
11:11:20 <dsal> > do { a <- Nothing; b <- Just 2; pure (a + b) }
11:11:22 <lambdabot>  Nothing
11:11:32 <basic> dsal: yeah but that is kinda because
11:11:42 <basic> Nothing >>= (\x -> ...)  is always nothing, right?
11:11:50 <c_wraith> basic: it's all because >>= is concatMap.  If the input list is empty, there's nothing to run the function on, so there's no output.
11:11:53 <dsal> Right.  And   [] >>=  is always []
11:11:56 <basic> yeah i think i got it
11:11:58 <basic> thanks
11:12:29 <basic> do { x <- [1..2]; y <- [1..2]; [] ; return $ (x,y);}
11:12:33 <basic> but this still confuses me
11:12:46 <basic> the list doesn't >>=, right?
11:12:50 <dsal> Heh.  Turn on warnings.  :)
11:13:06 <sm[m]> travisgriggs: that System stuff is in base
11:13:08 <basic> what is "[]; return" desugared into?
11:13:08 <solonarv> of course it does. run that 'do' block through the desugaring rules!
11:13:10 <dsal> @undo do { x <- [1..2]; y <- [1..2]; [] ; return $ (x,y);}
11:13:10 <lambdabot> [1 .. 2] >>= \ x -> [1 .. 2] >>= \ y -> [] >> return $ (x, y)
11:13:20 <hyperisco> [1..2] >>= \x -> [1..2] >>= \y -> [] >>= \_ -> return (x, y)
11:13:25 <hyperisco> guess there is a tool for that now
11:13:26 <solonarv> yeah, lambdabot can desugar for us; handy!
11:13:31 <basic> oh. each line of a do block is always connected via >>
11:13:34 <basic> yeah.. i guess that maakes sense
11:13:34 <travisgriggs> @sm[m] 
11:13:34 <lambdabot> Unknown command, try @list
11:13:41 <basic> c_wraith: thanks for the lesson
11:13:47 <basic> i learned through that example
11:13:48 <solonarv> connected via >>= or >>, yes
11:13:57 <basic> solonarv: yeah >>= if i bind.. obviously
11:13:58 <hyperisco> sort of… do has some other quirks… like let
11:14:04 <travisgriggs> @sm[m] can I go root around in those directories/files somehwere? at least for my own education?
11:14:05 <lambdabot> Unknown command, try @list
11:14:10 <c_wraith> basic: you're welcome, and you picked that up faster than I did. :)
11:14:22 <basic> c_wraith: well.. no, i didn't i should already know this
11:14:27 <basic> it took me month to understand list monad
11:14:29 <oats> travisgriggs: "@" is not needed for mentioning people in IRC :)
11:14:35 <c_wraith> Meh.  no such thing as "should".  learning is learning.
11:14:44 <basic> months, plural
11:14:49 <travisgriggs> sorry, been a while since i did irc, and using a new client :/
11:15:00 <basic> but that is a good explaining trap
11:15:00 <dsal> I learn really basic things all the time.  Often more than once.
11:15:02 <oats> travisgriggs: normally you can type the first couple letters of a nick and press <TAB> to complete it!
11:15:26 <hyperisco> smart clients might autocomplete to the most recently active nick with that prefix too…
11:15:28 <basic> especially with oats  because he has no other o
11:15:31 <oats> basic: everybody starts climbing the ladder from the bottom rung :)
11:15:43 <basic> oats: s/ladder/the haskell pyramid
11:15:46 <sm[m]> travisgriggs: sure, try brew list | grep ghc  to see what packages you have
11:15:54 <dsal> I thought pyramid was a scheme thing?
11:15:57 <sm[m]> the brew list ghc [-v] to see the files
11:16:34 <sm[m]> I just tried that and see no random files in the package. I do have random installed in my user package db. Probably was installed cabal at some point.
11:16:40 <sm[m]> by cabal
11:16:48 <c_wraith> travisgriggs: hmm, sorry.  Looks like random does *not* come with ghc anymore.  Nothing wrong with what brew's doing.  I guess it's time to learn how to install and use packages. :(
11:17:12 <basic> dsal: wht pyramid are you talking about :D
11:17:17 <travisgriggs> thank you c_wraith
11:18:18 <travisgriggs> so in this case, part of the issue is that the book is just out of date
11:18:46 <dsal> basic: I try to aim for triple entendres where possible.  Though someone did actually make a language called "pyramid scheme" that targets ethereium
11:19:15 <sm[m]> travisgriggs: sounds likely
11:19:16 <travisgriggs> for now, i'm just going to set this issue aside, and learn what i can with the rest of the book and the ghc I *do* have, and then when I'm done with that, I'll figure out the whole package/stack/whatever stuff
11:19:22 <sm[m]> when was it last updated
11:19:39 <travisgriggs> BUT I did learn that haskell has a nice and helpful irc community. i miss this from days of yore
11:19:56 <travisgriggs> i'll be back with more questions
11:20:21 <sm[m]> good luck. To figure out stack and cabal, reading their user guides will be best
11:21:08 <basic> does anyone like the environment tools of haskell?
11:21:14 * basic never did
11:21:15 <travisgriggs> any irc reccomendations for macos btw? I used to use colloquy. Trying this irccloud thing, not that impressed
11:21:41 <sm[m]> travisgriggs: Riot (matrix client)
11:22:15 <dsal> basic: what's an environment tool?
11:22:33 <basic> things that create a virtual environment for your program to run in
11:22:37 <basic> cabal / npm u name it
11:22:46 <dsal> Oh.  I like stack, but I don't know that most people do.
11:22:56 <dsal> nix has made my life better in countless ways.  It helps with haskell, too.
11:23:10 <basic> well, i hate the way haskell does it, that's for sure
11:23:16 <sm[m]> stack and cabal do amazing things, but they solve complex problems without much funding and could be a lot better
11:23:24 <basic> good i can't do good things in haskell yet & my package manager has most important packages inside them
11:23:31 <sm[m]> but believe me, if you didn't have them you'd be sorry :)
11:23:32 <dsal> haskell itself doesn't do it.  stack does some stuff, cabal does some stuff.  nix does stuff beyond haskell.
11:23:40 <hyperisco> If Haskell ever had good tooling it would be too powerful. The forces of nature would become unbalanced and all of creation would violently end.
11:23:44 <basic> sm[m]: i always have collissions i don't understand
11:23:45 <basic> and get mad
11:24:00 <basic> no matter what package manager or whatever you call it i use
11:24:12 <dsal> Every package manager I've encountered has only made things worse.
11:24:16 <sm[m]> basic: let me ask you , have you read the tool's user guide ?
11:24:17 <dsal> basic: you've not used nix, I see.  :)
11:24:28 <basic> dsal: how does that program work differently in nix?
11:24:42 <sm[m]> I'm not saying it's easy, but not understanding how the tool works is a common way people suffer with cabal & stack
11:24:43 <dsal> You don't have collisions and conflicts and stuff in nix
11:24:55 <basic> dsal: well.. why?
11:25:07 <basic> nix is a distro, right?
11:25:18 <solonarv> no, it is a package manager
11:25:24 <basic> for what exactly?
11:25:25 <dsal> nixos is a linux distribution.  nix is a package manager that works on many systems.  (I'm using it on my mac right now)
11:25:43 <basic> well, i have a package manager and it does what it does well
11:25:47 <dsal> It won't make much sense before you try it, but basically, you can have every version of everything installed at the same time and never conflict.
11:26:02 <basic> dsal: well i am a gentoo user, i like to fiddle with things actually
11:26:09 <dsal> You can do a build on multiple different versions simultaneously.  You can run programs with complex dependencies without installing them.
11:26:09 <basic> and if my package manager has a haskell package.. it installs
11:26:29 <basic> cabal will act the same way on nix, than on my distro, doesn't it?
11:26:34 <basic> my package manager is just fine
11:26:34 <dsal> no
11:27:40 <basic> dsal: how does nix tell cabal to behave
11:28:16 <dsal> I don't use cabal directly very much, just stack.  The stack integration grabs pre-built binaries (and third-party dependencies) from nix packages when I do builds.
11:28:39 <dsal> I have a lot of haskell projects on a lot of different configurations with different ghc versions and different library and *binary* dependencies.
11:29:03 <basic> well my problem waas never to get it run on multiple systems :D
11:29:03 <sm[m]> dsal: how does that work ? You list nix: package: in stack.yaml ?
11:29:04 <basic> jsut one
11:29:09 <dsal> One of my projects requires some npm junk and an elm compiler.  I don't have node.js or any elm tools installed on my system, but stuff works fine when I do that.
11:29:35 <dsal> sm[m]: I turn on nix support and list package dependencies.  It builds in a nix-shell.
11:29:42 <basic> c_wraith: but... isn't "returning" a empty array counter-intuitive?
11:30:00 <basic> i mean, people don't do that , do they?
11:30:05 <sm[m]> dsal: do you have a public project I could look at ?
11:30:10 <dsal> basic: IMO, "return" should be removed.  It doesn't do what anyone thinks it does.
11:30:23 <basic> dsal: yeaah, i think so aswell, but i get the difference, no worries
11:30:33 <basic> that's why i put it in quotes
11:30:36 <dsal> sm[m]: https://github.com/dustin/mqttd/blob/master/stack.yaml <-- not very fancy.  nix integration is turned on at a system level.
11:30:42 <basic> and the function still returns it, doesn't it
11:30:52 <hyperisco> dsal, well how far do we play this game, because next to go is "class"
11:31:10 <dsal> return and class aren't similar.
11:31:21 <dsal> You ~never have to write "return" in any code.
11:31:37 <basic> yeah same thing really
11:31:41 <dsal> basic: "return" has no bearing on whether things return.
11:31:52 <sm[m]> dsal thanks. So stack will automatically use nix to ensure the zlib package is visible, right ? 
11:31:53 <basic> return isn't the mmost confusing thing about haskell
11:31:54 <basic> it's fune
11:31:55 <hyperisco> I contend they are similar in the sense that both are words found in other languages but have different meaning
11:32:07 <dsal> sm[m]: if you're using nix, it verifies the zlib packages is installed.  If you're not using nix, you're on your own.  :)
11:32:20 <dsal> hyperisco: oh, yes.  But you don't *need* return in any haskell program.
11:32:31 <basic> do { x <- [1..]; if x < 10 then return x else []}
11:32:37 <basic> none does that, right?
11:32:45 <hyperisco> I'll agree that the replacement for "return" is easier than the replacement for "class"
11:32:53 <dsal> basic: if you think 'return' has to anything to do with returning things, then that's the type of confusion I'm referring to.  :)
11:33:10 <basic> it does return the value wrapped in gift paper
11:33:13 <basic> to the outside world
11:33:15 <hyperisco> It might have to do with returning things in the semantics of a particular Monad :)
11:33:18 <basic> pure is confussing aswell
11:33:26 <dsal> pure is less confusing than return.
11:33:31 <basic> i even see return > pure
11:33:41 <basic> what does pure do? does it put pureness into things?
11:33:56 <dsal> No, put puts a pure value into the applicative.
11:34:02 <dsal> :t pure
11:34:03 <lambdabot> Applicative f => a -> f a
11:34:11 <hyperisco> this is an even more nuanced sense of "pure"
11:34:11 <basic> so the applicative isn't pure?
11:34:15 <dsal> If you have an `a`, now you have a `f a`
11:34:23 <dsal> :t return
11:34:24 <lambdabot> Monad m => a -> m a
11:34:28 <maerwald> basic: heh
11:34:29 <hyperisco> in this context, we say that  f  has effects
11:34:31 <dsal> If you have an `a`.  Now you have a `m a`
11:34:59 <hyperisco> but  f  could be  []  for example, so we say it has list effects
11:35:05 <basic> we should name it
11:35:08 <hyperisco> be confused as you will ;)
11:35:09 <basic> applicify
11:35:12 <dsal> > return 1 :: Maybe Int    -- return is just a function.  It does not return anything.
11:35:13 <lambdabot>  Just 1
11:35:21 <basic> :>
11:35:25 <dolio> The difference between `return` and `class` is that the former is specifically named so that it evokes intuition from those other languages.
11:35:27 <dsal> (well, does not cause anything to return)
11:35:30 <basic> or maybe try to make haskell hip
11:35:33 <basic> just name it yolo
11:35:35 <basic> in caps
11:35:57 <hyperisco> dolio, I don't know the etymology of "return" but I think it can be justified similarly
11:36:04 <basic> do { x <- [1..100]; if x < 10 then return x else [] } ⇐ none does this.. right?
11:36:17 <basic> is there a prettier way to do this other than list comprehension?
11:36:22 <maerwald> if `pack` wasn't already heavily used...
11:36:26 <dsal> filter?
11:36:49 <dolio> That wasn't a justification of return. It was an anti-justification.
11:36:54 <basic> dsal: hm, yeah but i'd like to do it inside the do block
11:37:07 <hyperisco> basic, in terms of effects,  pure  has the empty i.e. do-nothing effect
11:37:12 <basic> maerwald: the monad "packs" things never worked for me either
11:37:25 <basic> hyperisco: it has a effect :D it confuses newbies
11:37:33 <basic> s/a /an 
11:37:33 <dsal> > do { let x = return  1 in  succ <$> x } :: Maybe Int 
11:37:34 <lambdabot>  Just 2
11:37:37 <hyperisco> basic,   so the effects of  m <*> pure n  is just the effects of  m
11:37:54 <basic> and you have to mention that it doesn't have an effect?
11:37:57 <oats> I propose that both 'pure' and 'return' be deprecated in favor of 'yeet'
11:38:05 <basic> that doesn't make sense to me.. i mean the language is pure isn't it
11:38:12 <dsal> basic: Also, return has nothing to do with `do`
11:38:16 <hyperisco> basic, yes, it is too nuanced for an introductory explanation, but I am just offering where the choice of the word "pure" comes from
11:38:20 <merijn> basic: No *side* effects
11:38:40 <basic> yeah.. but i aassume someone that writes haskell knows what has sideeffects and what not
11:38:51 <basic> .oO(is the reaason for "return" that you "return" to pureness) ?
11:38:53 <dsal> return and pure just promote values (see my lambdabot example above)
11:39:07 <maerwald> basic: why
11:39:12 <hyperisco> I am assuming "return" did come intuitively from other languages, though the justification seems more fast and loose than "pure"
11:39:21 <oats> `do { x <- Just 5; y <- Just 4; yeet $ x + y }`
11:39:21 <basic> dsal: as i told you about 100 times now, i get what it does, but i can't see both words as being "bad"
11:39:21 <dsal> return == Just  or  Right  or  "put this in a list" or whatever.
11:39:30 <basic> oats: yeah, i'd like that
11:40:11 <basic> maerwald: why i assume haskell programmers now that? even if im wrong, why would "making the programmer remember it" by forcing him to "mark" pure code help
11:40:11 <dsal> basic: It's difficult to convince someone you understand something by just stating it.  You're saying a few conflicting things like you think it has anything to do with do blocks or values being returned.
11:40:31 <maerwald> basic: ?
11:40:34 <basic> i mean , if the programmer doesn't get what is different inside IO monad, it won't help him that he has to write "pure"
11:40:53 <basic> dsal: you can take that as a fact, i get what pure and return does
11:40:55 <dolio> dsal: It does have to do with do blocks. It's named to make them look like imperative function code.
11:41:18 <oats> I also don't think it's a great name, but I haven't yet seen anything better
11:41:20 <dsal> dolio: insidious
11:41:21 <basic> why was it named "return" tho?
11:41:35 <basic> because you return to pureness? was that the idea?
11:41:52 <dolio> It's named return to make do blocks look like imperative code.
11:41:55 <oats> basic: as was said, to try to invoke some intuition from imperative languages
11:41:56 <hyperisco> I am guessing literally because of do-notation, and it just lines up looking like an imperative program that way
11:42:01 <dsal> It's presenting a pure value as a value within the monad.
11:42:05 <monochrom> "return" has two orthogonal connotations. We used one of them (answer). We forgot that the other would hurt (control flow).
11:42:07 <basic> oats: lol that worked well
11:42:35 <oats> basic: welcome to haskell, some stuff sucks a bit, do your best to enjoy yourself
11:42:40 <hyperisco> do { x <- m; y <- n; return (x + y); }  it reads something like  x = readInt(); y = readInt(); return x + y;  but I don't know if this is the true reason
11:42:51 <basic> oats: well.. i think both suck, but i aslo have nothing better to offer
11:42:59 <basic> i would certainly named it something stupid
11:43:06 <hyperisco> the problem is that "return" has a meaning in structured programming that it does not have in Haskell, because Haskell is not a structured programming language
11:43:13 <maerwald> oats: heh
11:43:47 <basic> hyperisco: i mean i like the "return to pureness" interpretation
11:43:49 <dsal> I don't understand why `pure` is bad.  I have a pure value that I would like to offer a monad.
11:43:52 <basic> just works in io tho
11:43:56 <dsal> That's backwards, though.
11:43:59 <oats> but all that aside, learning and playing around with haskell has been some of the most fun I've had in my computer-using years
11:44:02 <dsal> It implies control flow, which is not what's happening.
11:44:04 <basic> dsal: how do you have a unpure value in haskell?
11:44:22 <hyperisco> basic, well I don't think that explanation is quite right, the people saying it returns pure values
11:44:29 <basic> abstracting impureness away is the thing that IO monad does
11:44:33 <basic> you never have unpure stuff
11:44:41 <monochrom> "return :: a -> M a" clearly injects pureness into effectful world. Totally not going back to pureness.
11:44:42 <basic> (correct me if im wrong)
11:44:57 <basic> monochrom: granted
11:45:02 <hyperisco> basic, pure means no effects, and that is exactly what  pure x  has, i.e. no effects… it isn't referring to the fact x is pure
11:45:16 <hyperisco> basic, but others may have alternative and also valid explanations
11:45:17 <oats> my head hurts from reading these conversations lol
11:45:21 * oats is going back to work
11:45:30 <basic> hyperisco: yeah but that goes for every thing that do in haskell?
11:45:39 <basic> and as monochrom just said.. if someone has a effect it's when u write pure :D
11:45:49 <monochrom> "pure :: a -> M a" is at least justifiable by "a short  moment of pure in the effectful world"
11:45:54 <basic> so you write pure to say that it has no effects.. exactly when you have effects?
11:46:10 <hyperisco> basic, there are two different conversations of "effects" to have here, that is why it may be confusing
11:46:28 <monochrom> That depends on M. For an interesting M, there are always other M-specific operations.
11:46:35 <basic> hyperisco: the prograam and the function u mean
11:46:48 <monochrom> For example if M=[], [1,2,3] :: [Int] is effectful.
11:47:41 <hyperisco> basic, Haskell is a pure language in the sense that there is no meaning to an expression other than what it reduces to, i.e. the process of evaluation does not have side effects i.e. does not alter anything outside what is being reduced
11:47:43 <dsal> If M is maybe, `return = Just`
11:47:53 <basic> hyperisco: everything u see in code is pur
11:48:02 <basic> you cannot have a unpure value in haskell. can you?
11:48:04 <hyperisco> basic, unlike other languages where I can write  function add(x, y) { console.log("hello world"); return x + y; }
11:48:25 <basic> it's always wrapped behind a monad, if you work on it, it's inside the second parameter of the (>>=) which is also a pure function?
11:48:27 <hyperisco> basic, and by doing addition I am also having an effect on the JavaScript console, for example
11:48:35 <dsal> I often do work with STM, mutable vectors, IO, etc...
11:48:37 <basic> so where is the unpureness that makes you have to write "pure"
11:49:12 <monochrom> If M=Maybe, Nothing :: [Int] is effectful.
11:49:15 <dmwit> basic: Do you believe that purity and effectfulness are mutually exclusive?
11:49:18 <hyperisco> basic, that said, we still want to leverage the concept of effects in Haskell, and one way of doing that is with Applicatives or Monads
11:49:48 <hyperisco> basic, so if we have  f a  and f is an Applicative, we say we have an  a  with  f  effects
11:50:18 <hyperisco> basic, in other words, to have the  a  we have to also have the  f  effects that go along with it
11:50:59 <hyperisco> basic, and we can do all this without violating purity in the other sense
11:51:03 <basic> dmwit: yes, they are :o, monads/applicative are just a trick to abstract that aaway fromm the programmer
11:51:11 <basic> aren't they?
11:51:12 <ddellacosta> gushys reverse the order 
11:51:40 <hyperisco> given  x :: a,  pure x :: f a  has no effect, or in other words every Applicative  f  has a no-effect effect and it is called "pure"
11:51:41 <ddellacosta> whoops nevermind sorry
11:51:43 <dsal> basic: If you have something that returns `Maybe Int`, and your function computes the value `3`, how does your function return that value?
11:52:29 <basic> dsal: well depends what monad you're in, doesn't it?
11:52:42 <dmwit> basic: Nope. A thing can be pure and effectful at the same time. Perhaps this is your core confusion.
11:52:45 <hyperisco> basic, if you read on "effect systems" this may become more salient. It is somewhat strange to think of Maybe effects or list effects given usual notions of effects (like opening files or writing to stdout), but they fall under the same framework.
11:53:00 <basic> dmwit: it has an effect, but the pure function itself doesn't have a effect.. you describe the effect
11:53:10 <basic> that is the trick, as far as i "understood" it
11:53:31 <dsal> basic: Well, no, it doesn't.  The function returns `Maybe Int` so Maybe is the monad.  So you could say `Just 3`  or you could say `pure 3` and your code would work for any applicative.
11:53:59 <basic> yes, that is the funny thing about typeclasses, but it doesn't have much to do with effect, does it?
11:54:08 <dsal> If you write `return 3` it will also work, but with fewer things than `pure 3`
11:54:12 <basic> especially when only working with maybe nothing is impure
11:54:12 <hyperisco> basic, it is perhaps more clear when thinking of examples like  State  which gives you a readable and writable state variable, i.e. it implements a mutable variable
11:54:21 <hyperisco> and we commonly think of mutability as a side effect
11:54:37 <basic> but it isn't it's just hidden
11:54:41 <dmwit> basic: There are many pure expressions which are effectful, not just pure.
11:55:08 <basic> dmwit: how is code with only a maybe monad effectful?
11:55:58 <basic> you describe the change for the "outside world" (which might need effects to be modified), but everything you write is pure
11:56:04 <basic> i always figured that is the trick behind monads
11:57:08 <dolio> That is the trick, but 'outside world' can be inside the language.
11:57:51 <Ashjkaell> basic: You could also look at the type definition for "binding" statements together (the type of >>=)
11:58:09 <basic> dolio: but it isn't in the case of haskell
11:58:20 <basic> Ashjkaell: yeah i see that i have pure functions as parameters and get a m a
11:58:21 <dolio> Yes it is.
11:58:26 <Ashjkaell> If you have something like `a -> b` then it's /pure/ but has no effects right?
11:58:27 <oats> basic: there the trick about monads are is that it's a nice interface that enables us to string together pure values that may eventually be interpreted as effects and run by the haskell runtime
11:58:30 <dolio> Except for IO.
11:58:36 <basic> dolio: how is the outside world inside the language?
11:58:40 <ddellacosta> basic consider `myEffects a b = a <* b`
11:58:47 <Ashjkaell> So the first idea might be so say that you build a datatype which has the "state" you want to modify
11:58:55 <basic> ddellacosta: i don't know <* :/
11:59:09 <basic> is it like >> for applicative?
11:59:09 <ddellacosta> if I call `myEffects (Just 1) (Just 2)` I get back `Just 1`, but if I call `myEffects (Just 1) Nothing` then I get Nothing
11:59:09 <oats> basic: backwards >>
11:59:19 <Ashjkaell> Call it "S a" (Stateful a).  Then your "binding" has type: S a -> S b
11:59:25 <ddellacosta> so you can see I'm effectively process my values distinctly from the _effects_
11:59:26 <basic> ddellacosta: yeah and the codes that handles that is pure.. isn't it?
11:59:36 <dmwit> basic: "how is code with only a maybe monad effectful?" The "effect" is early termination. `Nothing` is the canonical early-terminating effect of type `Maybe Foo`, which does no computation, terminating immediately and not producing a `Foo`.
11:59:40 <ddellacosta> it is pure. And it has effects
11:59:41 <Ashjkaell> This is OK but the problem is that you'll have to "always" care about the effects.
12:00:08 <dmwit> basic: It is also completely pure. You can evaluate it as many times as you want, in as many different environments as you want, and it will always be the same `Nothing` effect.
12:00:12 <Ashjkaell> The genius of monads is to "drop" the stateful on one side of the datatype to get "a -> S a" only
12:00:14 <basic> ddellacosta: exactly :D so why do i write "pure"
12:00:15 <Cale> Even in the case of IO, it's possible to imagine that there's a pure data type that represents the effects being described. We could do that, but the compiler would have a harder time optimising it, so it's not actually how GHC implements IO
12:00:31 <ddellacosta> basic: why do you think that pure is opposed to having effects is the question
12:00:33 <basic> dmwit: yeah i never argued it's not
12:00:37 <hyperisco> A trick is to take things at face value and not look under the hood.
12:00:46 <Ashjkaell> (An interesting, but non-relevant question for this discussion is to ask what happens if you drop the /other/ stateful ;-)
12:00:59 <basic> ddellacosta: i think so.. because a pure function doesn't have effects by definition.. every function in haskell is pure, isn't it?
12:01:18 <ddellacosta> basic: we're all going to keep going in this loop until you break out of that thinking :-D
12:01:23 <basic> what "does" the effect is the RTS when it injects the values from the dirty outside world into the graph
12:01:26 <dolio> basic: Because `Maybe` defines an extended language where failure is possible. So, in terms of the extended language `Maybe T` is 'an expression of type T that may fail', but other code may just treat it as a value.
12:01:53 <dolio> The code that treats it as a value is 'the outside'.
12:02:04 <Cale> basic: Maybe one thing which is important to distinguish is that execution of IO actions and the evaluation of the expressions which denote them are two mostly-separate processes.
12:02:21 <basic> maybe we're just having different terminology
12:02:39 <Cale> basic: Execution carries out the effects of IO actions, evaluation only makes your CPU warm without having externally-visible effects.
12:02:59 <Ashjkaell> basic: By the way, don't be afraid by the Haskell crows, bringing up side effects is like bringing a salt cube to a herd of goats ;-)
12:03:11 <Cale> Evaluation is the process of turning expressions into values so that something can pattern match on them.
12:03:12 <oats> haha
12:03:12 <Ashjkaell> crowds*
12:03:42 <hyperisco> personally I think the progression is 1) program with side effects ignorantly, 2) program without side effects ignorantly, 3) program with side effects competently
12:03:57 <Cale> It's a bit like how you can load /bin/ls into a hex editor without accidentally having a listing of the files in your home directory printed to the terminal.
12:04:12 <hyperisco> or in other words at (3) all you've really done is acquired a way to explain side effects without begging the question of side effects
12:04:21 <basic> Cale: i never doubted there are side effects, the code you write just doesn't do them
12:04:26 <basic> im just picking on that one
12:04:54 <hyperisco> then it is like, pure, impure, whatever, matter of perspective, can explain it either way
12:05:17 <basic> im just disturbed that you people don't think that way, i thought that's the whole beauty of haskell
12:05:20 <hyperisco> I defer to comedy like the explanation of how C is pure
12:05:23 <Cale> I tend to think of it as being that there are no *side* effects, because you have evaluation which is pure, and then execution, which is essentially all effects -- they're the main show then, not on the side. :)
12:05:26 <basic> that you cannot DO sideffects directly
12:05:37 <basic> (except for unsafeWhateverFunction)
12:05:52 <Cale> (yeah leaving unsafePerformIO etc. out of the picture)
12:06:01 * oats vomits
12:06:09 <basic> oats: eww
12:06:17 <oats> Cale: but yeah, I really really like your explanation of separating execution from evaluation
12:06:33 <oats> I'll have to remember that
12:06:38 <merijn> oats: Wait until you hear about accursedUnutterablePerformIO :p
12:06:55 <oats> merijn: fuck, don't let the spirits out!
12:07:07 <Cale> Part of the tricky thing about this discussion is that IO is an abstract data type, and you never ordinarily pattern match on it
12:07:07 <oats> someone get a goat
12:07:14 <Cale> so it's hard to talk about what evaluation of IO actions means
12:07:22 <basic> why do these things even exist?
12:07:34 <oats> Cale: I usually use the word "recipe" when talking about IO
12:07:36 <Cale> We can invent our own similar data type:
12:07:40 <oats> basic: FFI mostlyz
12:08:00 <Cale> data MyIO a = Done a | PutStr String (MyIO a) | GetLine (String -> MyIO a)
12:08:00 <basic> shouldn't you write those in C or whatever? i don't know much haskell internals
12:08:07 <oats> basic: sometimes you just need to swear on a necronomicon to ghc that your C code you're calling from haskell is pure
12:08:21 <dsal> FFI might be like IO, or FFI might be like ST.
12:08:39 <Cale> With this data type, it's easy to see how this is entirely pure and nonmagical
12:08:46 <basic> oats: why not the other way around? let C swear to cthulu that it's pure
12:08:59 <hyperisco> I wonder if this is like free will debates… some feel that if you give any deterministic explanation of free will that it is necessarily contradictory
12:09:07 <Cale> If we have some x of type MyIO a, then either x is Done v for some value v of type a
12:09:08 <basic> Cale: single point of failure though
12:09:14 <hyperisco> so if you give any pure explanation of side effects, is it necessarily contradictory? some feel yes
12:09:28 <Cale> or it starts with PutStr of some string, and some other MyIO a action to follow that up
12:09:49 <hyperisco> next up is the side effectful explanation of purity
12:09:59 <Cale> or it starts with GetLine and a function which, given a String result, will determine how to proceed with something of type MyIO a
12:10:22 <Cale> and we can imagine writing an execution function for this which interprets it in ordinary IO
12:10:28 <Cale> execute :: MyIO a -> IO a
12:10:33 <Cale> execute (Done v) = return v
12:10:49 <Cale> execute (PutStr s x) = do putStr s; execute x
12:11:04 <Cale> execute (GetLine f) = do s <- getLine; execute (f s)
12:11:04 <basic> aare there notable usages of haskell in embedded? just curious
12:11:12 <hyperisco> basic, #haskell-embedded
12:11:15 <Cale> Yeah, there's been some of that
12:11:32 <basic> the people that went that route.. are those still happy?
12:11:37 <Cale> Usually using Haskell as a metalanguage to do one-shot compilation of low-level code
12:11:44 <Cale> I believe so
12:11:58 <basic> Cale: what do you mean by "one-shot" compilation
12:12:00 <Cale> I did some of it as my first paid Haskell gig back in 2004 or so
12:12:10 <basic> Cale: oh wow, so far back
12:12:16 <Cale> I mean you write a Haskell program and it emits assembly code or LLVM or something
12:12:25 <basic> Cale: :o why would you do that
12:12:29 <oats> I think I once came across a really cool edsl library that generated safe C code
12:12:47 <dsal> basic: That's literally how everything works.
12:12:52 <oats> ivory, maybe?
12:12:53 <basic> so you .. translate a subset of haskell to C?
12:12:55 * oats can't remember
12:12:56 <basic> kinda?
12:13:00 <hyperisco> I know conal worked on a Haskell backend for compiling to circuits, but I don't think all the problems were worked out, and seemed to require dynamic memory management
12:13:02 <Cale> Because then you get to use a high level language with lots of abstractions in order to construct your low level program, and you can manually apply various optimisations by writing Haskell functions that manipulate the low level code
12:13:16 <basic> but the lowlevel thing is missing alot of things.. mmaybe mmmu even?
12:13:19 <basic> what is the benefit?
12:13:41 <dsal> Over writing machine code by hand?
12:13:48 <hyperisco> the edsl stuff I'm not sure is quite right to say it is _Haskell_
12:13:53 <Cale> I wrote a pipeline scheduler for PPC+Altivec assembly which simulated the sub-units of the CPU that the output code would eventually run on in order to brute-force search for good instruction schedules
12:14:12 <oats> I cannot think of any benefits to not writing C or assembly by hand :P
12:14:39 <basic> dsal: well, i never got the idea of doing that when i saw embedded things
12:14:43 <basic> but then again, i didn't do alot of them
12:14:45 <hyperisco> certain languages oats give you desirable static analyses
12:14:45 <Cale> We had some clever vectorised code for computing sine-cosine pairs that was around 42 instructions long as I recall, and my Haskell program found a way to fit that into 17 or 18 clock cycles
12:14:51 <basic> it *feels* more complicated to me, than just writing c
12:14:52 <merijn> hyperisco: Eh, Clash? :)
12:14:57 <dsal> oats: I did write some hand assembly for an AVR to do a particular task.  *significantly* smaller than the C version (both in code size and overall program size) and significantly faster.
12:15:04 <dsal> Profiled it with my oscilloscope. heh
12:15:06 <oats> sorry, I was being sarcastic
12:15:08 <Cale> and each time through the loop it computed 4 sines and 4 cosines
12:15:16 <Cale> for around about 2.5 clocks/float
12:15:23 <hyperisco> merijn, I fell out of that loop a couple years ago =\ I don't remember. I know one let you reason precisely about timing.
12:15:32 <merijn> That's clash
12:15:37 <Cale> by contrast, if you call GNU libm's cosine function, it'll take around 200 clocks
12:15:41 <merijn> Which compiles to VHDL or verilog
12:15:43 <hyperisco> At the cost of being incredibly restrictive on what you can do
12:16:17 <dsal> basic: this is just a weird channel to be asking why people would use compilers when they could just write low level machine code.  heh
12:16:25 <basic> okay homework stuff for you before i stop annoying you: how do i create all deltas for a move of a knight in chess?
12:16:36 <basic> [Position +2 +1, ...]
12:17:05 <hyperisco> you need to show your work first to be fair to yourself, otherwise we're just doing your homework
12:17:07 <basic> dsal: yeah, well, if i was asked the question in who wants to be a millionaire... i'd answered "none does that"
12:17:17 <basic> hyperisco: it's not my homework.. im 30
12:17:27 <Cale> There are only 8 of them, so you could just write them out, but if you want to be clever...
12:17:29 <hyperisco> why are you giving us homework then
12:17:41 <hyperisco> also some 30 year olds are in school :P
12:17:45 <basic> it's the reason i asked my list comprehension question.. because i tried to do all commbinations and check if the sum is 3
12:17:56 <basic> i can do it. it's just not pretty
12:18:20 <Cale> > [(s1*a, s2*b) | [a,b] <- [[1,2],[2,1]], s1 <- [-1,1], s2 <- [-1,1]]
12:18:22 <lambdabot>  [(-1,-2),(-1,2),(1,-2),(1,2),(-2,-1),(-2,1),(2,-1),(2,1)]
12:18:31 <basic> oh wow.. thats what i meant
12:18:36 <basic> yeah hm.. clever
12:18:39 <basic> im similiar
12:18:43 <basic>        op <- [(*1), (* (-1))]
12:18:47 <basic> butr didnt quite get there
12:19:36 <Cale> > [(s1*a, s2*b) | [a,b] <- permutations [1,2], [s1,s2] <- replicateM 2 [-1,1]]
12:19:38 <lambdabot>  [(-1,-2),(-1,2),(1,-2),(1,2),(-2,-1),(-2,1),(2,-1),(2,1)]
12:19:39 <Cale> lol
12:20:37 <Cale> > [zipWith (*) xs ys | xs <- permutations [1,2], ys <- replicateM 2 [-1,1]]
12:20:39 <lambdabot>  [[-1,-2],[-1,2],[1,-2],[1,2],[-2,-1],[-2,1],[2,-1],[2,1]]
12:20:40 <dsal> > [(x,y) | x <- [-2 .. 2], y <- [-2 .. 2], abs x + abs y == 3] -- the sum thing also works.
12:20:42 <lambdabot>  [(-2,-1),(-2,1),(-1,-2),(-1,2),(1,-2),(1,2),(2,-1),(2,1)]
12:21:06 <Cale> > [zipWith (*) xs ys | xs <- permutations [1,2,3], ys <- replicateM 3 [-1,1]] -- now we can generalise to higher dimensions
12:21:08 <lambdabot>  [[-1,-2,-3],[-1,-2,3],[-1,2,-3],[-1,2,3],[1,-2,-3],[1,-2,3],[1,2,-3],[1,2,3]...
12:21:31 <dsal> Cale: but can you play 4D chess?
12:21:40 <hyperisco> I want the version that enumerates all pairs of board positions and then filters to just those that are valid knights moves, then computes the difference from the pairs
12:22:33 <oats> dsal: but can you write a function that plays arbitrary-dimensional chess?
12:22:34 <hyperisco> dsal, with list comprehensions and a REPL I wouldn't challenge Cale to anything
12:24:38 <Cheery> I'm thinking of writing a book that uses haskell as a medium.
12:25:32 <Cheery> Grand objective: Know how to use CHL and logic as a design tool, and associate correctness&verifiability with readability.
12:27:17 <Cheery> grand because it doesn't necessarily happen with an one book.
12:28:13 <hyperisco> Cheery, a book about what? Haskell is used academically to explain ideas, interspersed with English paragraphs
12:29:26 <hyperisco> been feeling lately the restrictiveness/noise of computability but having it around can be pragmatic
12:32:04 <Cheery> hyperisco: It's up in the air still. But the objective would be to teach the reader those things, also assuming that the Haskell needs to be taught to be reader.
12:33:15 <dsal> Write a kids book.  That'd be cool.
12:34:05 <dsal> Jessica was pure and elegant.  She didn't believe in the RealWorld until one day…
12:34:34 * dsal sings IO, IO, it's off to work I go…
12:35:07 <basic> that is genuinely funny
12:35:19 * oats whistles in dwarf
12:36:05 <Cheery> mirror, mirror, who's the purest in the world?
12:36:23 <dsal> ...but it turned out, the mirror wasn't referentially transparent after all
12:36:38 <oats> lol
12:39:43 <basic> does jessica like curry?
12:43:05 <dsal> :t uncurry
12:43:06 <lambdabot> (a -> b -> c) -> (a, b) -> c
12:43:26 <dsal> TBH, uncurry and curry seem backwards to me.
12:43:39 <bitmapper> why?
12:43:54 <bitmapper> uncurry turns it from it's curried form to it's non curried form
12:44:10 <hc> s/it's/its/ *scnr*
12:50:37 <basic> great another pointless discussion *grabs popcorn*
12:50:46 <basic> yeah i always use the wrong one, too
12:50:48 <dsal> bitmapper: It depends on whether you're thinking about the tuple or the function.
12:51:06 <dsal> Which doesn't make a lot of sense, but it's how I'm thinking about it.
13:03:19 <Cheery> if the goal was to teach haskell while trying to teach how to use it, I think I'd introduce function types, then type classes/constraints, then parametric polymorphism.
13:06:40 <dsal> Why classes so early?
13:07:17 <c_wraith> probably so that error messages involving Show or Eq make sense
13:07:37 <hyperisco> and possibly numbers
13:07:58 <Cheery> if you use Haskell in wild, type classes and constraints hit you straight away.
13:08:02 <Rembane> And perhaps the whole confusing and way too generic parts of Data.List.
13:09:04 <hyperisco> is it ironic that uncurry is curried
13:09:27 <c_wraith> no, it's necessary. :P
13:09:50 <hyperisco> from what perspective?
13:10:05 <c_wraith> for making uncurry return a function
13:10:50 <merijn> I firmly believe that anyone writing text to teach Haskell that mentions the term "currying" should be publically shamed until they stop >.>\
13:11:43 <oats> > map (uncurry (+)) [(1, 2), (3, 4)]
13:11:45 <lambdabot>  [3,7]
13:12:22 <monochrom> So if I verbally teach "currying" in Haskell it's OK? :)
13:13:36 <merijn> monochrom: No >.<
13:13:59 <dsal> monochrom: Depends on whether you have notes.
13:14:00 <hyperisco> isn't going over the confusion of how many arguments Haskell functions take a rite of passage?
13:14:36 <dsal> hyperisco: I went through that decades ago in ocaml.
13:14:48 <hc> Hi, I'm looking for an efficient algorithm to convert an offset in a file to a line number
13:14:55 <Rembane> dsal: Does ocaml curry all its functions by default too? 
13:15:03 <hyperisco> can we use the primary ingredient of cumin as a proxy for curry discussions?
13:15:06 <Rembane> hc: Is the offset in characters?
13:15:10 <dsal> Rembane: Yeah, it was confusing.
13:15:10 <hc> Rembane: yes it is
13:15:15 <c_wraith> hc: there's really only one algorithm for that.  Count the number of newlines.
13:15:38 <oats> hc: do you want to support unicode?
13:15:39 <hc> c_wraith: what about binary search?
13:15:43 <dsal> There's a really efficient way to do that that isn't correct.
13:15:46 <c_wraith> hc: nope.  skips bytes.
13:15:48 <Rembane> dsal: Cool. 
13:15:55 <dsal> How do you binary search lines?
13:15:55 <merijn> hc: How does that work?
13:16:04 <dsal> Unless you store line numbers with the lines.
13:16:07 <merijn> hc: Unless you know ahead of time how long lines are
13:16:16 <dsal> Indexing can help a lot, sure.
13:16:39 <hyperisco> well you can binary search for all the newlines, it just is less efficient than a linear scan
13:17:30 <hyperisco> the reason to use binary search is when there is an opportunity to not search a half because you can determine what you are looking for isn't there
13:17:42 <dsal> Binary search is for finding a thing, though, not counting things.
13:18:14 <hyperisco> a newline can be anywhere, so nothing can be excluded, so you're just left with an elaborate order at which you look at bytes
13:18:31 <monochrom> merijn: What's wrong with "currying"?
13:18:45 <hc> merijn: no idea how that works; hence me asking here :)
13:18:47 <hyperisco> okay, "binary search" may be too loaded, lets say "divide and conquer"
13:18:51 <merijn> monochrom: Name one good reason to discuss it besides "it exists"
13:19:02 <hc> Oh, I'm not talking about counting; I'm willing to count. I mean after I count once, I would like fast lookups
13:19:30 <monochrom> OK, first, what do you think of teaching the concept, independent of name?
13:19:45 <merijn> monochrom: Which concept is that?
13:19:52 <oats> merijn: perhaps to understand why it's not an error to not provide all the arguments to a function call?
13:19:54 <hc> Like, process the text file once by linear search, then do 10.000 lookups
13:20:12 <c_wraith> hc: oh, then yeah, a binary search in an offset table works.  Though they're usually small enough that linear is just as fast.
13:20:18 <merijn> oats: No, because now you have *already* committed an unforgivable sin in teaching beginners
13:20:23 <monochrom> The concept that there are at least two ways to model/encode/represent/whatever a conceptually 2-parameter function.
13:20:28 <merijn> oats: You are talking about "the number of arguments of a function"
13:21:05 <merijn> oats: This is *why* I hate people talking about currying, they use it as a piss poor excuse not to cover the real, fundamental insight that "all functions have 1 argument" right away
13:21:13 <hc> c_wraith: okay, I guess I'll just have to build that routine myself :)
13:21:20 <hyperisco> merijn, is your argument that there is no reason to introduce currying in absence of any preconception of multiple argument functions?
13:21:20 <merijn> monochrom: That's fine if you're teaching abstract notions of programming
13:21:30 <merijn> monochrom: If you're teaching *haskell* that discussion is irrelevant
13:21:49 <monochrom> I am teaching both abstract notion of programming and realizing it in Haskell.
13:22:00 <merijn> hyperisco: My argument is that there is no reason to introduce it even if there *is* a preconception of multiple argument functions
13:22:04 <oats> well now I feel completely unmotivated to continue in *that* conversation
13:22:21 <hyperisco> oh, hm, not sure I agree then… seems relevant to relate the concepts
13:22:48 <hyperisco> why should an explanation of Haskell be in a vacuum
13:22:50 <merijn> oats: Basically, there's a really difficult, but crucial step in realising "all functions are 1 argument and *possibly* return new functions"
13:23:24 <hyperisco> is this just the "forget everything you know" mantra run to completion?
13:23:38 <merijn> oats: My experience in a decade of lurking here and several years of TAing functional languages is that the longer you allow any weird intuitions/preconceptions to exist about "multi-argument functions" the more confused people get and the more difficult to disentangle their confusion
13:23:39 <monochrom> I furthermore think that there is no "teach Haskell without relating back to abstract notion of programming"
13:24:17 <merijn> monochrom: Well, you can either teach the abstract notion first and then, sure talk about currying. And then later reflect on Haskell as one possible method of programming
13:24:30 <merijn> monochrom: Or you teach Haskell first and then later generalise. But you gotta pick one
13:24:39 <merijn> monochrom: To many people go back and forth without structure
13:24:41 <monochrom> Therefore you must discuss: In your conceptual language-agnostic design, you have a contour map from R^2 to R. Now how do people usually realize it in Haskell?
13:25:05 <c_wraith> hc: here's something I wrote and debugged a while back that might be inspirational:  https://gist.github.com/chowells79/ae906eac3d8804e06497ae56d4496a9c
13:25:36 <maerwald> merijn: as always, the student should pick how to start and the mentor has to adapt the story
13:25:39 <c_wraith> I don't think it applies directly to your case, but it's a fun demonstration of some tricks.
13:25:41 <hyperisco> merijn, it seems the premise is that exacerbating conflations is an ill
13:25:48 <maerwald> everything else is laziness
13:26:03 <merijn> oats: The intermediate step of "person knows multi-argument fuctions in language X" -> currying -> "1 argument functions" is much difficult to explain than just skipping the middle step
13:26:10 <hyperisco> merijn, I think though that conflations are inevitable, and working past them is a skill
13:26:15 <merijn> maerwald: That's fine and good if you're teaching 1 person
13:26:23 <maerwald> merijn: as it should be
13:26:42 <merijn> maerwald: Yeah, good luck reforming all universities globally using that philosophy :)
13:26:57 <maerwald> globally?
13:27:02 <hyperisco> merijn, and currying is a way in which to detangle the notions, even if it takes time to set in
13:27:04 <maerwald> -.-
13:27:16 <maerwald> I tried it locally and failed
13:27:23 <merijn> I'm not aware of any country that has universities that do 1 on 1 tutoring unless you're a millionaire, so yeah
13:27:29 <merijn> hyperisco: Is it?
13:27:47 <hyperisco> merijn, I think so, because it explains the way in which one is like the other
13:27:47 <hc> c_wraith: thanks
13:27:50 <maerwald> merijn: tutoring is not like teaching, it takes less time in fact
13:27:50 <merijn> hyperisco: I *still* get confused by exactly what currying is supposed to refer to
13:27:55 <oats> merijn: any uni with a large football program :P
13:28:05 <monochrom> I know. Use currying to amplify from local to global, "one parameter at a time" :)
13:28:38 <maerwald> merijn: you don't babble stuff in front of your student, you just show them the way and they have to approach you if they are stuck, have questions, need advise etc
13:28:55 <Cheery> For functions I think of taking the approach that it's a proposition that you can construct with a lambda form.
13:28:57 <maerwald> so I think it's less dramatic than it sounds
13:29:10 <Cheery> then you can examine it under different conditions by applying it to things.
13:29:13 <maerwald> you can still have lecturers
13:29:20 <maerwald> separately
13:29:38 <merijn> maerwald: Sadly, I cannot prevent other people from babbling random nonsense online :)
13:29:44 <maerwald> lol
13:30:08 * maerwald whistles
13:30:33 <hyperisco> I'm more displeased by explaining type classes as Java interfaces, for example, because the analogy doesn't run through
13:30:54 <oats> in my first couple years of undergrad when classes were still kinda huge, there would be the lecture 3 times a week, and "recitation" once or twice a week, with a much smaller class size, homework review, practice problems, and question asking. that was a pretty good format
13:31:12 <hyperisco> I don't observe that kind of inaccuracy with currying
13:32:02 <hyperisco> there may be a subtle undercurrent of first order versus higher order languages
13:32:39 <hyperisco> it is a one way analogy
13:34:28 <hyperisco> merijn, I don't question your experience on it though… perhaps then it something to cover later
13:35:41 <merijn> hyperisco: Their understanding of currying itself may not be incorrect, the problem is that they just get confused about function in general and start having weird intuitions about how "partial application" works as if its some special compiler magic, rather than just a straightforward result from having unary functions
13:35:56 <hyperisco> at some point questions of how do languages compare will arise, and they are good questions… but it seems you're saying playing into the safety of familiar concepts is ineffective for beginners
13:36:09 <Cheery> hyperisco: "forget everything you know" may be useful mantra with Haskell. There's this old quote about BASIC that I think applies.
13:37:09 <merijn> hyperisco: I'm saying that the safety of familiar concepts will make beginners warp their understanding to fit their preconceived notions, making it more difficult to see what's actually going on :)
13:37:40 <hyperisco> I suppose if you said if we teach currying in response to multi arg functions, why don't we teach function composition in response to decorators
13:37:56 <merijn> hyperisco: Like how many beginners treat do-notation as some kind of magic that "just does what they want" without understanding (which is why I usually tell them to use >> and >>= exclusively until they get comfortable with that)
13:37:56 <hyperisco> both are accurate analogies (I think, I am not as familiar with decorators)
13:38:08 <Cheery> https://www.cs.virginia.edu/~evans/cs655/readings/ewd498.html
13:38:08 <maerwald> what's a decorator? :>
13:38:35 <hyperisco> but somehow the idea of bringing up decorators in a conversation about function application seems absurd… maybe I am biased about currying merely because it was brought up to me early
13:38:43 <Cheery> "It is practically impossible to teach good programming to students that have had a prior exposure to BASIC: as potential programmers they are mentally mutilated beyond hope of regeneration."
13:38:45 <merijn> maerwald: Popular tool for committing atrocities in python
13:39:07 <maerwald> It seems I'm coding boring python
13:39:30 <ddellacosta> oh, poor Yoko, I'm sorry :-(
13:39:39 <ddellacosta> whoops, wrong window, lol
13:39:45 <hyperisco> Cheery, imagine reading that about yourself, wow
13:40:04 <Cheery> hyperisco: haha. that's actually what happened.
13:40:05 <Cheery> :)
13:40:21 * Cheery 's first language was visual basic
13:40:29 <MarcelineVQ> Cheery. hyperisco: Well, that explains my issues
13:40:30 <hyperisco> I suppose an element to my contention here is that no one knows a priori if they are embarking on the optimal understanding
13:40:57 <hyperisco> so where we can provide that foresight to newcomers, I guess that makes sense, but at some point you run out of teachers
13:41:21 <solonarv> maerwald: quick explanation: '@decorator; def func(args): ...' desugars to 'def func(args): ...; func = decorator(func)'
13:41:35 <hyperisco> so being equipped to handle unexplored territory, where you're liable to stumble on poor conceptualisations, becomes necessary
13:42:12 <hyperisco> I started with PHP and I think I have successfully escaped its way of thinking, and now that is a process I have experience of
13:43:50 <hyperisco> the ability to free yourself from the rut of familiarity is perhaps most powerful
13:44:00 <Cheery> recently wrote this http://boxbase.org/entries/2020/jul/6/how-to-read-code/
13:44:05 <solonarv> so I don't think decorators are a good analogy to function composition; they are higher-order functions
13:44:17 <Cheery> before reading the text, check out the source code, starting at line number 48
13:44:31 <Cheery> hyperisco: I'd like to know, what do you think about that one?
13:45:43 <Cheery> difficult or easy to read? good or ugly code?
13:47:43 <hyperisco> Cheery, I think you're doing fine. I'll go down to the aphids on the blades of grass in the weeds though
13:48:50 <hyperisco> Cheery, I like that, for example, you define what it means for a move to be valid, and what a player is
13:49:56 <hyperisco> Cheery, I think some concepts are not linked as strongly as they could be. The comment talks about "valid tic-tac-toe game", so what I really want to know is what a "tic-tac-toe game is" (what is the type G?) and what a valid game is (what is the function G -> Bool ?)
13:50:33 <hyperisco> I think you say a game is Run, but why not call it Game, and define the validity like done for other concepts
13:51:15 <hc> c_wraith: I opted for a linear search after all, for now -- let's see how it performs in practice :)
13:51:39 <ja> there are some values in that encoding of the game that are not mentioned ,no? like you stick to the standard library, and it is hard to extend beyond a 3x3 board
13:51:44 <Cheery> hyperisco: named after run of a game, steps taken in the game so far.
13:52:13 <ja> after seeing this code,  i am curious to see how it would look with SBV
13:52:28 <Cheery> SBV?
13:52:28 <hyperisco> Cheery, okay, well, I think it is still right to say a game is a Run, in your formalism
13:52:39 <ja> Cheery: https://www.cameronsworld.net/
13:52:41 <ja> ups
13:52:46 <ja> Cheery: https://hackage.haskell.org/package/sbv
13:52:47 <hyperisco> Cheery, just not that all Runs are games, and what it means for a Run to be a game is what it means for a game to be valid
13:52:55 <ja> (first paste is fun too, but not relevant :P )
13:53:21 <ja> i should get used to using lambdabot, and i wouldn't have these pasting problems...
13:53:30 <Cheery> I was looking at it and scratching my head.
13:53:33 <hyperisco> Cheery, just my two cents. I think relating an English explanation with a precise one (in Haskell) is effective, but I would expect the terminology to line up
13:53:45 <hyperisco> so if you introduce a noun then I want to know what that precisely means
13:54:27 <hyperisco> that is the effective design process, I think, and is your subject
13:59:53 <Rapeseeder> Eat my diarrhea
13:59:53 <Rapeseeder> Just...
13:59:53 <Rapeseeder> Just ate a burger at the sleazy joint
13:59:55 <hyperisco> Cheery, so our local government announced that coding will be taught as part of the math curriculum… your first claim seems to be true :P
13:59:56 <Cheery> ja: I've used idris before, but not SMT. I guess it'd be interesting though.
13:59:57 <Rapeseeder> Now I gotta take a shit, get to the point
13:59:57 <Rapeseeder> Sittin' on the toilet, my ass is a blast
13:59:59 <Rapeseeder> Runnin' smelly diarrhea outta my ass
14:00:01 <Rapeseeder> No f*ckin' paper
14:00:03 <Rapeseeder> Hey baby lick my ass 'til your face turns blue
14:00:05 <Rapeseeder> You're finished rimmin' me and you want some more
14:00:07 <Rapeseeder> Ya say ya don't flush but your out the door
14:00:09 <Rapeseeder> I'm back in the...with a cup
14:00:11 <Rapeseeder> Scoop it outta the toilet 'cause you wanna slurp it up
14:00:15 <Rapeseeder> Eat my diarrhea you're chuggin' it down
14:00:17 <Rapeseeder> You're suckin' my ass and your lips are all brown
14:00:19 <Rapeseeder> Since we've gone back to the hamburger place
14:00:21 <Rapeseeder> I'm gonna stick my ass right on your face
14:00:23 <Rapeseeder> I'm gonna shit in your mouth
14:00:26 <Rapeseeder> I'm gonna shit in your face, your mouth
14:00:27 <Rapeseeder> And I wanna shit on your mother
14:00:29 <Rapeseeder> I'm gonna shit on you and your mother
14:00:31 <Rapeseeder> Diarrhea
14:00:33 <Rapeseeder> I gotta take a shit
14:00:35 <Rapeseeder> Gotta bottle a Ex-Lax, gonna take it
14:00:37 <Rapeseeder> I'm gonna take me a lumpy shit
14:00:40 <Rapeseeder> Gonna throw it at you, I hope I hit you
14:00:42 <Rapeseeder> I hope it splats in your face there too
14:00:42 --- mode: ChanServ set +o dolio
14:00:43 --- mode: dolio set +b Rapeseeder!*@*
14:00:52 <hyperisco> Cheery, although it might be Python, don't know yet
14:01:43 --- kick: Rapeseeder was kicked by dolio (Rapeseeder)
14:01:50 --- mode: dolio set -o dolio
14:02:02 <ja> Cheery: it is just a tool of course. but failing to use an applicable tool could also be seen as a problem ;) that's why i started out saying that it is also useful to state right away what the core requirements/'values' are. 
14:03:12 <ja> an ocaml programmer of mine says that he appreciates the fact that ocaml compiles to "predictable" assembly. i don't know why he values that so much, but he does! so no wonder he isn't working with haskell :P
14:03:13 <Cheery> hyperisco: it's probably python because there's some justification for doing that which can be coinvincing.
14:03:30 <hyperisco> does that mean "to make vulnerable"?
14:07:16 <monochrom> "predictable assembly output" means source input is in imperative programming
14:07:18 <Cheery> If you think of programming as writing of recipes, python kind of seems making sense.
14:08:16 <maerwald> this is the big question: is programming actually maths?
14:08:17 <dolio> How much more predictable is it? My experience is that a lot of people don't bother learning the well-defined machine model for GHC stuff.
14:08:59 <EvanR> programming is philosophical engineering
14:09:08 <hyperisco> I think half my frustration with programming is getting past "everything is just Assembly" likewise
14:09:17 <hyperisco> and likewise
14:09:32 <maerwald> In maths, you don't really have a notion of "behavior", do you? So writing down crypto on paper and making sure it doesn't misBEHAVE on hardware... are two different things
14:09:49 <hyperisco> the layman understanding is "it is all 1's and 0's" right, and how wrong is that
14:10:13 <maerwald> and the problem is ...behavior does not compos well
14:10:16 <hyperisco> or rather than "wrong" maybe right in the wrong way :P
14:10:25 <EvanR> constructive math is more identifiably computing related
14:10:35 <dolio> That goes for general complaints about laziness, too, really. People treat it as something spooky, so they can blame things on it even if they aren't caused by laziness, and only remember the blame later on.
14:11:17 <Rembane> dolio: I think it's amazing to have something to blame. This is said with a lot of tongue in cheek.
14:11:45 <dolio> It's like when you refute some misconception, and people later only remember the misconception, not the refutation. :)
14:12:09 <maerwald> EvanR: yeah, but I know some programmers who argue that programming can be more like maths (with more expressiveness). I think it's a fallacy
14:12:49 <EvanR> mathematical thinking can help you with programming, programmer thinking might end up hurting in any field
14:12:53 <dolio> EvanR: There are computational interpretations of classical mathematics, too. You just have to systematically lie about what everything is computing. :)
14:13:29 <maerwald> Only a subset of what you do is well defined and composable, most of it is juggling desired behavior
14:13:32 <hyperisco> maerwald, is it reasonable to say programming got the rigors of syntax right?
14:13:49 <maerwald> functional or not, you always end up with behavior
14:14:14 <EvanR> sounds very knuthian
14:14:19 <Cheery> I haven't dug into it deep, but I think big thing about functional programming is that it can cover lots of targets where it can "evaluate".
14:14:23 <maerwald> and behavior is a plager to handle
14:14:34 <maerwald> *plague
14:14:55 <hyperisco> I think adding computability where it needn't belong isn't helping
14:15:33 <hyperisco> isn't it nice to talk about things without necessitating a computational explanation
14:15:44 <Cheery> python's just a fine interpreter for functional code, even if it's been meant for entirely something else.
14:15:49 <dolio> EvanR: Like, when a classical mathematician says `∃ x. ...` it doesn't mean they are computing the x. It means they are computing a way to win an argument against someone who says they don't know the x.
14:16:12 <hyperisco> it is like, I want to talk about what I want to eat, not recipes for how to make what I want to eat
14:16:28 <EvanR> yes that is what formal logic is
14:16:34 <EvanR> a symbolic game
14:18:31 <Cheery> programs are plans to "win" a game specified by some type.
14:19:34 <maerwald> in the end, you still have to execute code. Once you execute it, you're observing behavior, not reasoning about terms
14:20:01 <EvanR> in some language's Cheery is talking about, nobody runs anything!
14:20:51 <EvanR> is it still programming?
14:21:01 <hyperisco> McBride tweeted recently that programming is about interesting terms and logic is about interesting types
14:21:28 <hyperisco> in some context about dependently typed programming
14:22:00 <hyperisco> I haven't a tenth the perspective but it resonated with me
14:22:46 <monochrom> \∩/ game semantics
14:23:07 <monochrom> But not fond of using types for that.
14:23:41 <Cheery> it gets interesting with linear types because it no longer encloses behavior inside IO
14:23:44 <hyperisco> I think it is true descriptively even if not prescriptively
14:24:50 <monochrom> I agree with what McBride said there.
14:27:01 <hyperisco> I think it cuts deep into where we can go with programming, but he'd be better to speak on that elaboration
14:27:39 <monochrom> Yeah, well said, I couldn't have say it.
14:28:07 <dolio> Twitter isn't for elaboration.
14:28:25 <hyperisco> that's what Twitlonger is for -.-
14:28:28 <MarcelineVQ> That's a bit of a meme actually, that he tends to say interesting things then not explain them :>
14:28:47 <monochrom> I'm sure if he's interested in elaborating (even finds it worth elaborating) he will blog it.
14:29:02 <MarcelineVQ> But he's done enough other work I don't mind so much the random mysteriousness
14:29:13 <Uniaika> monochrom: thank you for reminding me that I need to update my blog…
14:29:54 <Cheery> actually should I troll python people by presenting python as an accidentally made haskell interpreter
14:30:19 <Rembane> Cheery: Please don't. :)
14:30:22 <Cheery> there's haskell library for python parser?
14:30:41 <monochrom> Do you already know the April Fool joke that haskell is an accidentally made python interpreter? :)
14:30:51 <Cheery> nope
14:31:07 <monochrom> more precisely, accidentally made python version 5 :)
14:31:30 <Cheery> https://hackage.haskell.org/package/language-python
14:31:31 <hyperisco> Cheery, you do that and we'll get some disgruntled Python programmer in here demanding we justify our shared interest in Haskell
14:31:38 <monochrom> https://www.reddit.com/r/haskell/comments/b81t7q/bubble_sort_in_python_5/
14:32:05 <Cheery> all the pieces seem to be prep for that.
14:32:46 <Cheery> did anybody embed python C API to haskell yet?
14:33:00 <Cheery> if it was, you could sort of make it "official" as well.
14:33:17 <EvanR> haskell reddit gives it away
14:33:35 <EvanR> i'll erase the evidence and send it to some python people
14:33:53 <monochrom> yeah you can easily just send the youtube url
14:34:35 <Cheery> https://hackage.haskell.org/package/cpython
14:39:04 <Cheery> JS is lot more interesting target though.
14:40:29 <Uniaika> EMBRACE LUA!!
14:41:31 <Cheery> glue them all together and then kind of make them work with each other
14:41:38 <Rembane> Uniaika: Does Lua need more hugs? 
14:41:51 <Uniaika> Rembane: I see what you did there.
14:42:29 <Cheery> depending on which semantics you pick, it's either katamari or programming language centipede.
14:43:26 <Rembane> Uniaika: ^^
14:44:05 <Uniaika> :')
14:44:09 <Rembane> Cheery: That reminds me that most languages have a C FFI, which makes it possible to connect almost all languages to each other.
14:44:27 <Uniaika> use Erlang's Java FFI!!
14:44:35 <justsomeguy> I'm trying hard to escape C. It's not working.
14:44:42 * hackage fused-effects-lens 1.2.0.1 - Monadic lens combinators for fused-effects.  https://hackage.haskell.org/package/fused-effects-lens-1.2.0.1 (robrix)
14:45:12 <Uniaika> justsomeguy: you really can't
14:45:16 <Rembane> +1
14:46:00 <Cheery> then you can still hook up LLVM on that monstrosity
14:46:19 <Cheery> got some functional code translated to C in middle.
14:50:07 <x0r-255> (XMonad) How might I identify a window based on part of its title? Similar to this (in python) `if "control" in title...` (but in haskell obv)?
14:51:00 <Cheery> do  you already know how to identify a window based on its title?
14:51:25 <koala_man> > "bar" `isInfixOf` "foobarbaz"
14:51:27 <lambdabot>  True
14:51:48 <x0r-255> yes, I just do `title =? "example"` assuming I have the title obtained already
14:52:12 <x0r-255> If more info is needed I can get a pastebin with more code on it
14:52:34 <Cheery> hm.. title :: Query String
14:53:29 <Henson> hi everyone, I'm trying to understand how to use Lens to read a record which is inside of a map which is inside of the StateT monad transformer.  I can modify the value using "modifying (chemicalMap . (at chemicalName) . _Just . amountAvailable) ((+) producedAmount)", but am having difficulty reading it. The "Maybe" that comes in to play from the "at" Lens is causing me problems that I can't...
14:53:31 <Henson> figure out.
14:53:34 <x0r-255> > myManageHook :: XMonad.Query (Data.Monoid.Endo WindowSet)
14:53:36 <x0r-255> > myManageHook = composeAll
14:53:36 <lambdabot>  error:
14:53:36 <lambdabot>      Not in scope: type constructor or class ‘XMonad.Query’
14:53:36 <lambdabot>      No module named ‘XMonad’ is imported.error:
14:53:37 <x0r-255> >  [ className =? "obs"     --> doShift ( "work" ) ]
14:53:37 <lambdabot>  <hint>:1:14: error: parse error on input ‘=’
14:53:39 <lambdabot>  error: Variable not in scope: classNameerror:
14:53:39 <lambdabot>      • Variable not in scope: (=?) :: t1 -> [Char] -> t0
14:53:40 <lambdabot>      • Perhaps you meant one of these:
14:53:54 <x0r-255> that's the type of thing I'm trying to do ^^
14:54:01 <Cheery> (=?) :: Eq a => Query a -> a -> Query Bool
14:54:04 <dminuoso> Henson: get ?
14:54:15 <Henson> this is for the Advent of Code day 2019 Day 14 problem, which is helping me a lot with learning new Haskell stuff
14:54:26 <dminuoso> Henson: oh hold on, how is the Maybe a problem?
14:54:34 <Cheery> x0r-255: these types reveal what you need to do.. lets still look into the type of query a bit. it's got few instances
14:55:01 <Henson> dminuoso: the "at" operation, which looks into a Map-like structure, causes a Maybe to be introduced because the key you look for may not be there.
14:55:13 <dminuoso> Yes. And your problem is?
14:55:18 <Cheery> x0r-255: https://hackage.haskell.org/package/xmonad-0.15/docs/XMonad-Core.html#t:Query
14:55:46 <Cheery> :t isInfixOf "foo"
14:55:47 <lambdabot> [Char] -> Bool
14:56:08 <Henson> dminuoso: this work "ReactionMapValue{..} <- fromJust <$> use (reactionMap . (at chemicalName))" when I'm trying to extract the entire data type.  But say I want to access a record within that type.
14:56:29 <Cheery> x0r-255: fmap (isInfixOf "foo") title
14:56:44 <Henson> dminuoso: this here "use (chemicalMap . (at chemicalName) . amountAvailable)" does not work.  Nor does it work when I put _Just in there, nor (re _Just).
14:57:06 <dminuoso> Henson: What are you trying to do?
14:57:11 <x0r-255> @cheery I'll try that
14:57:11 <lambdabot> Unknown command, try @list
14:58:09 <Cheery> x0r-255: it's important to understand how that works. "Query String" is sort of like a structure that describes something about an XMonad Window
14:58:36 <dminuoso> Henson: Oh I think I get it. So you can compose with _Just, but you no longer have a Lens, you rather have a Traversal in your hand. Rather than using `use`, I'd probably just explicitly use `get` and then `preview`
14:59:18 <Cheery> x0r-255: Query itself is a functor. it means that you can throw functions into the context and transform the thing inside Query
14:59:18 <Henson> dminuoso: just to get the value of amountAvailabe, which is inside of a Map (chemicalMap) at key chemicalName, from the StateT monad (where "use" comes in).
14:59:38 <Cheery> x0r-255: eg. you can go from Query a to Query b, with fmap
14:59:42 <Henson> dminuoso: don't I have to use "use" because I'm in the StateT monad?
14:59:44 <dminuoso>  Henson e.g. `do s <- get; let f = s ^? reactionMap.at chemicalName._Just.foo`
14:59:54 <dminuoso> Henson: Nah, `use` is just a convenience tool so you dont have to explicitly `get` :)
15:00:04 <dminuoso> use l = State.gets (view l)
15:00:16 <dminuoso> Henson: Note the use of `view` here, its wildly misleading
15:00:38 <Cheery> x0r-255: note title =? "foo" does that too. it sort of lifts (=="foo") with fmap
15:00:50 <dminuoso> Henson: Recall, if you compose a lens with a prism then you get an (affine) traversal. It makes you wonder how `view` could possibly work (and it only does if the value you're seeing is monoid so it can default to mempty)
15:00:59 <Cheery> :t fmap (=="foo")
15:01:00 <lambdabot> Functor f => f [Char] -> f Bool
15:01:00 <dminuoso> So really, just `get/gets` and use preview.
15:01:44 <Henson> dminuoso: yeah, Lens requires may more complex type understanding than I'm familiar with at the moment.
15:01:58 <dminuoso> Henson: if you like, you can use `optics` instead.
15:02:07 <x0r-255> What exactly is fmap? Why use this and not just map?
15:02:12 <Cheery> :t map
15:02:14 <lambdabot> (a -> b) -> [a] -> [b]
15:02:24 <dminuoso> It has newtypes and type families and hand curated error messages, making it much easier for beginners in my opinion
15:02:24 <Cheery> x0r-255: map is fmap, but only for lists.
15:02:26 <Henson> dminuoso: thanks for your help.  I gotta run for dinner
15:02:59 <Cheery> x0r-255: fmap might be map, but haskell has a history.
15:03:11 <x0r-255> So it wouldn't be able to be used on another iterable type I assume? Or by lists do you mean anything iterable?
15:03:24 <dminuoso> x0r-255: `fmap` is just a generalization of map. Rather, the real question is "why do we have map"
15:03:43 <x0r-255> map is shorthand syntax for a loop really
15:03:43 <dminuoso> `map` is just `fmap` limited to lists, it was thought that it would make it easier on beginners on their first few hours.
15:04:02 <x0r-255> a loop with data returned
15:04:03 <dminuoso> (Avoiding potential error messages involving the functor typeclass)
15:04:03 <EvanR> iterable is the wrong thing
15:04:20 <dminuoso> In hindsight, it was probably a bad decision and `map` should be what fmap is now.
15:04:23 <Cheery> x0r-255: it's good idea to examine fmap through its type.. it's nothing to do with lists, it's so general.
15:04:26 <dminuoso> But alas it is what it is.
15:04:26 <Cheery> :t fmap
15:04:27 <lambdabot> Functor f => (a -> b) -> f a -> f b
15:04:28 <EvanR> it's Mappable, though this begs the question
15:04:59 <x0r-255> EvanR: I'm new to haskell, I'm coming from JS and python so anything that can be enumerated over or iterated through is what I meant.
15:05:03 <x0r-255> like a string, or an array
15:05:09 <EvanR> ok, that's what i thought
15:05:15 <EvanR> that's not what fmap does
15:05:17 <dminuoso> x0r-255: "iterating" is something else for us :)
15:06:11 <dminuoso> For many things fmap is just "apply a function to a thing" but in such a way that it can change the underlying type. So for example with `fmap` you can turn [Int] into [Char] using a function `Int -> Char` that is applied to each element.
15:06:35 <Cheery> fmap (f.g) = fmap f . fmap g
15:06:45 <dminuoso> That is a good approximation for a beginner.
15:06:46 <x0r-255> Ah, so with regular map would you not be able to change types?
15:06:51 <dminuoso> x0r-255: No it would, still.
15:06:57 <dminuoso> x0r-255: It's just that `map` can only do that to lists.
15:07:01 <dminuoso> With `fmap` you could do that with trees too.
15:07:04 <dminuoso> Or other things.
15:07:33 <dminuoso> So say with `fmap` you can turn a `Tree Int` into a `Tree Char` using some `Int -> Char`
15:07:42 <x0r-255> Hm, so fmap converts it to a list before doing anything it sounds like?
15:07:45 <dminuoso> No.
15:08:02 <Cheery> x0r-255: fmap for list is map
15:08:17 <dminuoso> x0r-255: There is a typeclass that captures "being able to turn into a list" for what its worth, but that's a different one.
15:09:26 <dminuoso> x0r-255: Do you know what a typeclass is, in general?
15:09:34 <Cheery> x0r-255: the trick is in the type. Eg. say you got "Foo x" and we don't say what "Foo" is other than that it's type with a parameter.
15:09:56 <Cheery> now if you wanted to change 'x' inside Foo
15:09:58 <x0r-255> In general, yes, but not specifically to haskell.
15:10:04 <dminuoso> Then you probably dont. :)
15:10:12 <dminuoso> Our use of the word "class" is different from most other languages.
15:10:26 <EvanR> yo tell x0r-255 about some other examples of fmap than list
15:10:54 <EvanR> more concretely than how the types work
15:11:31 <Cheery> well you got the Query right there.
15:11:46 <dminuoso> It's closer to Java's traits. Other languages might call it "concepts" or "interfaces". Really, this is about some interface that types can conform to or not. We say that a type conforms to that interface if it has an "instance" of that typeclass.
15:13:15 <Cheery> well consider (Functor f) => f String -> f Bool
15:13:32 <dminuoso> Here's fmap specialized to Maybe: fmap :: a -> b -> Maybe a -> Maybe b
15:13:52 <dminuoso> This applies a function to a Maybe if its Just.
15:14:00 <dminuoso> Here's fmap specialized to []: fmap :: a -> b -> [a] -> [b]
15:14:10 <dminuoso> That applies a function to every element of the list
15:14:21 <dminuoso> Here's fmap specialized to Tree: fmap :: a -> b -> Tree a -> Tree b
15:14:23 <x0r-255> https://pastebin.com/q3ArSgzY take a look at this, this's what I'm trying to do, but it's not working (however, I got it to compile just fine)
15:14:26 <dminuoso> That oculd apply a functoin to every element in a tree
15:14:28 <Cheery> the (=>) should be read as "there's these things that limit what you can put into variables in the type"
15:14:34 <dminuoso> x0r-255: ^- do you see the common pattern here?
15:15:25 <x0r-255> I sort of do, but I'm mostly unfamiliar with haskell so I don't know how to work with that very well.
15:15:52 <Cheery> x0r-255: how does it fail now? it seems like it looks right.
15:17:13 <x0r-255> I run `st -n test` and when I xprop it it says that it's title is "test", but my desired action is not done. PS I have ensured that I recompiled & restarted xmonad properly.
15:17:39 <Cheery> > isInfixOf "test" "test"
15:17:41 <lambdabot>  True
15:18:01 <Cheery> mm.. did it do it with just =?
15:18:45 <x0r-255> Yes, but that's inadequet as `title =? "unicorns"` will fail if the title is "unicorns1"
15:19:21 <Cheery> > isInfixOf "test3" "test"
15:19:23 <lambdabot>  False
15:20:16 <Cheery> it's weird because I thought that'd do it.
15:20:47 <Cheery> unless..
15:21:23 <Cheery> well can't be precedence issue either
15:22:18 <x0r-255> If I remove the fmap and do it like this: `isInfixOf "1" title` it yells at me about the type, here let me get you the error
15:23:14 <x0r-255> Couldn't match expected type ‘Query Bool’ with actual type ‘Bool’
15:23:16 <x0r-255>     • In the first argument of ‘(-->)’, namely ‘isInfixOf "test" title’
15:23:19 <Cheery> yeah.
15:23:36 <x0r-255> Couldn't match expected type ‘[Char]’
15:23:38 <x0r-255>                   with actual type ‘Query String’
15:23:39 <x0r-255>     • In the second argument of ‘isInfixOf’, namely ‘title’
15:23:41 <x0r-255> and that
15:24:17 <x0r-255> so would I do `Bool <- isinfix...`?
15:25:46 <x0r-255> okay well no, that errors
15:26:02 <Cheery> the thing I presented should work, but I'm not sure why it doesn't.
15:27:53 <Cheery> also I just checked, somebody else is using the exact same thing in his config
15:28:38 <Cheery> https://gist.github.com/dln/8425108#file-xmonad-hs-L128
15:31:07 <ezzieyguywuf> if I have a module that I don't want to export, but I _do_ want to import in a different module, how would I go about that? should I just put it in the same directory?
15:31:34 <Cheery> x0r-255: getting to sleep, I think it's something else than the command not working, try "st -n firefox" maybe?
15:31:43 <dsal> ezzieyguywuf: symbols are exported or not.  Those are the options.
15:32:05 <x0r-255> hm, that doesn't work either
15:32:14 <x0r-255> but actually launching firefox does...
15:32:22 <dsal> ezzieyguywuf: You can do this sort of thing:  http://hackage.haskell.org/package/gopro-plus
15:32:27 <dsal> But it's still exported.
15:32:56 <ezzieyguywuf> dsal: you mean the Internal stuff?
15:33:06 <dsal> Yeah.  They aren't documented, but they're exported.
15:33:48 <ezzieyguywuf> hm, is that the typical approach?
15:33:55 <dsal> AFAICT.
15:34:07 <ezzieyguywuf> gotcha
15:34:14 <dsal> There's no only-sort-of-export as a feature.  Symbols not exported by a module aren't available to other modules
15:34:24 <ezzieyguywuf> on a separte note, I was thinking I should switch from i3 to xmonad, since I learned it's written in haskell :)
15:34:37 <dsal> I really like xmonad, but I never modify my configuration.  :/
15:36:26 <x0r-255> xmonad has been pretty nice so far for me...
15:36:36 <maerwald> I don't like code-as-config, so I stick to i3
15:36:55 <dsal> xmonad has a concept of physical display and virtual display and you can map things across them.  For the most part, xmonad for me is "when I login, I want these programs running in these places and if I launch this program, I want it to go here."
15:36:57 <x0r-255> I like code-as-config, because you're not limited
15:37:32 <x0r-255> I left KDE because I felt limited, and DT had been promoting xmonad so much I thought I might give it a spin
15:37:55 <dsal> Huh.  I didn't even know Trump had a computer.
15:37:55 <hpc> every configuration is code, just in an extremely limited DSL :P
15:38:19 <maerwald> you can run your own fork of a project (I do run an i3 fork), but still have a proper config language 
15:38:41 <aldum> maerwald: does it have config includes?
15:39:20 <maerwald> aldum: don't think so
15:40:00 <aldum> that's one reason why I'm back on xmonad :)
15:43:45 <ezzieyguywuf> how in "other-modules" different from "exposed-modules"?
15:43:59 <x0r-255> Cheery: the "~=?" thing worked, thank you! Also the first one works as well... I used the -t flag instead of -n for st and it works, however I think I'll go with "~=?" so that if I do it again it's less verbose
15:44:16 <x0r-255> Cheery++
15:44:55 <justsomeguy> ezzieyguywuf: exposed-modules are things you make available to consumers of your package. other-modules are tools or other things you may use internally, but your package doesn't depend on.
15:45:51 <AWizzArd> dsal: have you tried i3 too? Or just xmonad?
15:46:00 <dsal> Never tried i3, no
15:46:23 <AWizzArd> k
15:47:30 <ja> justsomeguy: how can you use something internally if you don't depend on it? :O
15:47:42 * hackage streamly-binary 1.0.0.1 - Integration of streamly and binary  https://hackage.haskell.org/package/streamly-binary-1.0.0.1 (geyaeb)
15:47:48 <dsal> Much of the stuff I use internally isn't dependable at all.
15:47:55 <monochrom> ezzieyguywuf: https://cabal.readthedocs.io/en/stable/developing-packages.html#pkg-field-other-modules
15:48:26 <x0r-255> ja: you can do that by compiling it, and including that dependency
15:48:30 <justsomeguy> ja: For example, you may have a tool that lints config files, but is only used during development, and doesn't ship with the final package. npm would call this a dev-dependency.
15:48:36 <x0r-255> it's done with most consumer programs
15:48:50 <x0r-255> bad for open source, and makes it harder to update, but it's done
15:52:03 <justsomeguy> ...actually, now I'm wondering if I got my explanation of other-modules wrong... maybe I shouldn't have said anything.
15:52:25 * justsomeguy checks the cabal user guide again
15:53:40 <monochrom> :)
15:53:50 <monochrom> For library, it's hidden modules alright.
15:58:15 <ezzieyguywuf> lol
16:01:20 <ezzieyguywuf> so with other-modules then I don't *have* to export every module then?
16:01:34 <ezzieyguywuf> at least publicly, which is what I meant originally
16:05:59 <monochrom> Right.
16:08:42 * hackage fused-effects-optics 0.1.0.0 - Bridge between the optics and fused-effects ecosystems.  https://hackage.haskell.org/package/fused-effects-optics-0.1.0.0 (patrick_thomson)
16:12:13 <Henson> dminuoso: that code you gave me works!
16:12:17 <dminuoso> So Im staring at some presentation by duncan, and he mentions a typeclass instance with associated GADT data types, which fails to mention any of the instance head type variables in the type.
16:12:47 <Henson> dminuoso: is there any way to make it work with "use" or something similar, that automatically works within the StateT monad, instead of having to get the state and then define a variable based on it?
16:13:15 <dminuoso> i.e. some `instance P T where data S st = ...` and this does not appear to be a mistake, because he's using `f :: S st -> ...` in a few plcaes.
16:13:45 <dminuoso> What might be going on here? Is there some extension that relaxes the need to mention a type/kind from the instance head in the associated data family?
16:14:27 <dminuoso> Henson: preuse l = gets (preview l)
16:15:35 <Henson> dminuoso: awesome!
16:16:40 <dminuoso> Henson: That shows how you can just use `gets` and `preview` yourself as well. :) i.e. you can also just do `v <- gets (preview l)`, or you just define this preuse combinator somewhere.
16:21:46 <Henson> dminuoso: thanks for helping me.  I must say the lens library seem quite complicated, powerful, and abstract.  I have difficulty understanding what the various combinators do.
16:22:22 <Henson> dminuoso: this advent of code stuff is my first use of the library, so hopefully after getting my feet wet, and trying out a bunch of things I don't understand, it'll start to make sense eventually :-)
16:22:26 <dminuoso> Henson: Personally I didn't grok much of it until I switched to `optics`. :)
16:24:05 <Henson> dminuoso: is optics a better way of approaching lenses?
16:24:53 <dsal> lens is a way of approaching optics
16:26:34 <dminuoso> Henson: `optics` is a separate implementation. So in `lens` for instance type Lens s t a b = forall f. Functor f => (a -> f b) -> s -> f t 
16:26:45 <dminuoso> And equivalently:
16:26:54 <dminuoso> type Prism s t a b = forall p f . (Choice p, Applicative f) => p a (f b) -> p s (f t)
16:27:03 <Henson> perhaps I should ask: what's a good way for me to understand the concepts in the lens library.  I tried watching Edward's youtube presentation, but after 10 slides felt somewhat bewildered by the generality of it.  I read a blog on how to use it, which gave me the basics of getting and setting.  But to understand how to do more complex stuff requires looking through 20 modules of very difficult...
16:27:29 <dsal> Henson: "optics by example" is pretty good
16:27:29 <Henson> to understand types and nomenclature, which leaves me feeling lost.
16:28:14 <dminuoso> Henson: Because these are type aliases, you constantly see the expanded version in type errors. When you compose two optics, their constraints get merged - you have to know the internals to understand what kind of resulting optic you get.
16:28:17 <dminuoso> You have no handholding.
16:28:42 <dminuoso> Or, if you miscompose two optics, lens will permit it - but it will break due to unsatisfiable constraints on usage sides, which are really cryptic errors.
16:31:39 <dminuoso> Also, `optics` has little unsafe/unexpected behaviors, like `lens` permits `view`ing through a traversal, `optics` does not allow it at all. You'd have to explicitly foldOf instead.
16:32:38 <dminuoso> Now I know there's arguments like "being confronted to the internals all the time forces you to learn it", but when you're already swamped with new things and just want to get things done, I think I'll just want to not know.
16:37:09 <Henson> dminuoso: yes, I'd like to learn "lens", not a bunch of abstract type-level prerequisite concepts to even being to understand how to use lens.  I quickly get burned out when confronted with a huge learning curve to even understand the words being used in the documentation.
16:38:35 <Henson> burned out -> turned off
16:39:01 <dminuoso> Henson: https://gist.github.com/dminuoso/097879d7422a02672b4749f417475c3d
16:39:16 <dminuoso> Here's some examples of what error diagnostics and type inference at the end look like.
16:40:26 <Henson> dminuoso: ok, so maybe using optics is a better first step into this arena than lens.
16:40:34 <dminuoso> It's up to you, really.
16:40:56 <dminuoso> Let me prepare the equivalent lens examples for you
16:45:36 <dminuoso> Henson: https://gist.github.com/dminuoso/88a41dd9551665b5601a1280f55b8f77
16:45:58 <dminuoso> Note that Im not saying lens is bad. I consider all of these to be ergonomical issues (that I know exist by design)
16:47:05 <dminuoso> But yes, I think optics is more beginner friendly.
16:51:20 <Henson> dminuoso: ok, thank you for pointing that out.  I'll take a look at it.
16:51:34 <Henson> dsal: and thanks for pointing out the "optics by example" book, I'll look into that, too.
17:01:59 <hyiltiz> Compared to most other languages, the almost non-existence of indexing (of arrays or structure fields) seem very cumbersome
17:02:42 <hyiltiz> but i bet it would be an eye opener experience typical of Haskell once I learn to use lens/optics to approach those problems
17:04:06 <xsperry> there's indexing, even for things that arguably shouldn't have it [lists]. there just isn't a fancy syntax for it
17:04:44 <hyiltiz> yup; I know there is indexing but it is not commonly used and usually there are better ways
17:06:12 <hyiltiz> and deeply nested structures (like an object parsed from JSON) usually begs for a syntax to represent them (so say, I can do site.user.<TAB> to see what I should type next)
17:07:02 <hyiltiz> i am not really saying fp style is bad; it is just different and i haven't dared to play with deeply nested stuff in Haskell thereof
17:07:36 <hyiltiz> and believe once I do, it might change how I view indexing/get/set operations in programming in general
17:12:41 <monochrom> Arrays and array indexes are overrated. 90% of usages in C, for example, are merely left-to-right streaming access. Haskell provides a way (even several ways) to do that, and exposes the fact that indexing is overkill.
17:14:14 <Chi1thangoo> what do you mean by streaming? looping over an array or smth?
17:14:32 <monochrom> This busting is also exactly Backus's critique in his "can programming be liberated from the von Neumann model" speech and article.
17:14:37 <monochrom> Yes.
17:15:28 <monochrom> Hell let me strengthen that to s/overkill/XY problem/
17:17:12 <xsperry> it seems that hyiltiz is talking about . syntax for accessing class/struct members, and autocompletion support from IDEs. but, technically, there's no reason why IDE couldn't list all fields and/or all the functions that accept the typed object, I'm just not sure that there's an IDE that supports that
17:17:55 <monochrom> hyiltiz began with array indexing.
17:18:10 <monochrom> I have no comment on deep records of records.
17:18:20 <dolio> I do. They're overrated. :P
17:18:54 <monochrom> I believe so too, but I haven't got a reason or evidence.
17:19:51 <dolio> My generous hypothesis is that I must be doing different stuff than most other people, because I don't have all my code organized into first-order functions that just access record fields all the time.
17:20:02 <dolio> I actually compose functions more.
17:20:16 <hyiltiz> i think by streaming he means fold or traverse
17:20:35 <monochrom> Weak evidence and just one case I know: When using aeson, you are supposed to write/generate FromJSON for marshalling to your carefully designed ADT, not using Value directly and the XY problem of "now how do I dive into Value? Oh, lens."
17:25:00 <hyiltiz> monochrom: thx for that example about marshalling to ADT rather than dumping first then lens
17:25:23 <dolio> .field syntax is nice for copattern matching, though, absent some left-hand infix syntax for functions.
17:26:50 <dolio> If you have to do copatterns like `p (q (r (f x y z))) = ...` it's a little heavy.
17:28:01 <monochrom> If your ADT, after design and consideration, is still a deep record of record, that's fair, lens is in order. But still, please don't do it directly on Value, because... do you know how Perl programmers do records?
17:28:20 <monochrom> Perl programmers' "record" is a hash map from strings (field names) to values.
17:28:39 <monochrom> If you use Value directly and lens on it, please leave and go back to Perl.
17:29:58 <yushyin> ^ guess they will join #perl
19:19:34 <c_wraith> There are plenty of times Value is the correct data type.
19:20:26 <c_wraith> like whenever you have "this record may add new fields at any point in the future, and they must be preserved to be passed on to the next step in the API"
19:23:57 <koz_> I'm trying to add Hashable instances for Which, based on the Generic instances here: http://hackage.haskell.org/package/data-diverse-4.7.0.0/docs/Data-Diverse-Which.html#t:Rep
19:24:30 <koz_> I can do the Which '[] and Which (x ': []) ones fine, but I can't phrase the Which (x ': x' ': xs) one in a way that keeps the type checker happy.
19:24:39 <koz_> What would be the right phrasing for it?
19:39:27 <koz_> Error I get looks like hence: https://gist.github.com/kozross/025a865b965a969c83d0b363f2c2c78a
19:49:42 * hackage earcut 0.1.0.3 - Binding to C++ earcut library.  https://hackage.haskell.org/package/earcut-0.1.0.3 (DavidHimmelstrup)
20:01:41 <wunderbrick> I'm currently working through Haskell Programming from First Principles so I haven't built any sizeable Haskell programs or done anything too complicated with State or stacks of monads or anything. I don't understand the get State operation. If I'm just getting a value out of a monad, why does get modify the state and the value? I understand how it works just not why it's designed that way. Can
20:01:43 <wunderbrick> someone please clarify this for me?
20:04:30 <c_wraith> It's not clear to me what your question is
20:05:01 <monochrom> get doesn't modify the state value.
20:05:33 <koz_> If you look at the type of get, it says 'get :: State s s'.
20:05:35 <monochrom> I generally distrust people when they say "I understand it but..."
20:05:37 <koz_> No modification is taking place.
20:05:53 <monochrom> Dunning-Kruger and stuff
20:06:46 <monochrom> Actually the type won't say whether the state value is changed or not.
20:07:37 <monochrom> "put 5 >> return ()" and "return ()" have the same type, different effect on the state value.
20:07:54 <koz_> monochrom: Yeah, you're right. I should have said something like 'Why do you think the value is being modified?'.
20:08:15 <monochrom> Ah, that's much better than everything I said. :)
20:08:51 <monochrom> Every scientist asks that. Every programmer should learn from scientists.
20:08:59 <koz_> Also, monochrom - any idea about my type error above?
20:09:08 <koz_> Like, I'm not sure what on earth it's not happy with.
20:09:10 <Cale> Though, there are few things of type  forall s. State s s -- you could change the state to bottom, or there are a couple possibilities like the whole computation could be bottom, but otherwise, you're forced to leave it alone.
20:09:19 <monochrom> No, I don't know Diverse.
20:10:08 <monochrom> Actually "put 5 >> return ()" is redundant. "put 5" alone already is State Integer ().
20:10:39 <monochrom> It was a long day, I keep goofy like this.
20:11:41 <monochrom> My sister bought home a bag of gummies, the bag is opague, doesn't show the gummies outside, just colour gummy picture.
20:11:56 <monochrom> colourful gummy picture
20:12:17 <monochrom> I mistook it for colourful mixed vegetables picture, therefore "this goes to the freezer too".
20:12:35 <monochrom> I think she still hates me for freezing her gummies.
20:21:32 <koz_> OK, let me try another question - what does K1 and R mean in the context of Generic?
20:32:38 <monochrom> the type "K1 R Int" has value "K1 (5 :: Int)" for example.  Suppose you have "data X = MkX Int". Then you will have "K1 5 :: K1 R Int" somewhere deep in the result of "from (MkX 5)". In general it has a field's type and value.
20:33:27 <monochrom> R no longer has significance because it is always "K1 R" not "K1 SomethingElse". (There used to be a SomethingElse.)
20:33:54 <monochrom> They now alias "type Rec0 = K1 R" and usually you see Rec0 in ghci :info etc
20:34:53 <monochrom> I have no idea why these things are named M1, S1, D1, K1, R, Rec0, ... apart from "obviously a pure mathematician wrote the paper that started this". :)
20:35:55 <koz_> Ah, I see. Well, thanks!
20:36:22 <koz_> (it certainly tells me something and delving into the innards of Hashable suggests that the issue is 'its Generics-based deriving mechanism wasn't designed for this')
20:48:37 <wunderbrick> Thanks for the response. I did not phrase that well. Mentioning the Dunning-Kruger effect isn't exactly friendly or welcoming though and probably isn't a good way to keep beginners in a space. 
21:09:28 <dfg> how do i make my irc client ignore request from people that are telling it to join channels
21:27:42 * hackage earcut 0.1.0.4 - Binding to C++ earcut library.  https://hackage.haskell.org/package/earcut-0.1.0.4 (DavidHimmelstrup)
21:58:12 * hackage uri-encoder 0.0.0.0 - A uri encoder to make your strings less readable  https://hackage.haskell.org/package/uri-encoder-0.0.0.0 (tonyo)
23:37:02 <typetetris> `Control.Exceptions` confuses me. The haddock says `try` and friends wouldn't have an implicit `mask` like `catch`. But they are implemented in terms of `catch`. How can't they have the implicit `mask` then?
23:37:32 <typetetris> `s/Control.Exceptions/Control.Exception/`
23:43:18 <nshepperd2> typetetris: what part gets masked?
23:44:09 <int-e> Do you mean this? "Note that try and friends do not have a similar default, because there is no exception handler in this case. Don't use try for recovering from an asynchronous exception."
23:44:17 <typetetris> nshepperd2: The exception handler, so for `try` that internal part converting any exception into `Left` ? 
23:44:32 <typetetris> Lol ok
23:44:34 <nshepperd2> yep
23:44:52 <int-e> I'm not quite sure, but I think this means you should not use `try` and then look at the result to check whether an exception happened.
23:46:46 <typetetris> int-e: If a asynchronous exception was fired within the tried action, shouldn't it also lead to a `Left` then? Why not use that? (I can blindly follow the rules, no problem here, but I would want to understand.)
23:46:54 <int-e> Not that there's no masking happening inside `try` (because that's certainly happening).
23:47:09 <int-e> typetetris: Yes, it would. But you can't reliably act on it.
23:47:45 <int-e> Because an asynchronous exception could also arrive at that point.
23:48:06 <typetetris> int-e: Thanks, didn't see that.
23:51:42 <typetetris> Does that: https://github.com/jhickner/smtp-mail/pull/32/files#diff-6f7fcda2cf632947adbfc01d69533b57 require an increase in A or B for PVP? (Sum type gets an additional data constructor).
23:52:27 <nshepperd2> it wouldn't make any difference for the handler inside try to be masked or not, given that any exception that was masked while packaging up the Either would be delivered before you can use it anyway
23:54:17 <typetetris> nshepperd2: Yeah, I see that now. Just need to memorize it, so I don't forget again :)
