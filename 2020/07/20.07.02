00:00:23 <jusss> I'd like to use stack, but stack put everything on AWS which is not available for my network, so I have to use cabal... you know cabal, there's cabal, cabal v2, cabal v3...
00:00:28 <Cale> 8.8.3 is already out, so I'd say the 8.8 series is stable enough to use at this point. There really shouldn't be all that much which doesn't work with it. Which packages are you attempting to use?
00:00:35 <MarcelineVQ> materiyolo: and you've chosen a stack resolver/snapshot for 8.8.3?
00:00:52 <materiyolo> lts-16.3 i believe MarcelineVQ 
00:01:50 <Cale> materiyolo: If you can give me a list of dependencies, I can tell you whether they ought to build on 8.8.x
00:02:05 <materiyolo> can i just pastebin the error message?
00:02:14 <MarcelineVQ> hmm that is fairly new but it's lts so it shouldn't be broken/shitty. So when you say install what do you mean exactly? What are you doing that this issue arises from? yes errors are good
00:04:17 <materiyolo> well i wanted to install brittany for code formatting but i got this https://paste.centos.org/view/2001bfa5
00:05:23 <Cale> building...
00:08:11 <Cale> brittany has a pretty large set of transitive deps...
00:10:06 <MarcelineVQ> It is in that resolver though, lts-16.3 , so if that's the resolver in scope it should be building properly, hmm
00:10:52 <MarcelineVQ> materiyolo: what do your ~/.stack/config.yaml  and  ~/.stack/global-project/stack.yaml look like?
00:11:29 <materiyolo> Here's the .stack/config.yaml https://paste.centos.org/view/6fa6c05f
00:11:52 <materiyolo> and this is the global-project https://paste.centos.org/view/39f70411
00:12:31 <MarcelineVQ> hmm, looks alright, what happens if you comment out that custom array choice?
00:12:41 <materiyolo> in the global project?
00:12:48 <MarcelineVQ> ye
00:13:36 <MarcelineVQ> array is pretty fundamental so that over-ride there could affect a lot
00:13:43 <materiyolo> oh
00:13:55 <materiyolo> array seems to be what's bothering everything
00:14:05 <materiyolo> i just had to comment it out and everything's normal again
00:14:10 <MarcelineVQ> nice
00:14:21 <materiyolo> thanks for the fix
00:14:25 <typetetris> What is the dance again, I have to do to read a handle strict?
00:14:35 <materiyolo> i still dont know much about managing stack since i'm still fairly new to haskell
00:14:38 <typetetris> There is the strict package, but it calls length on the input
00:15:02 <Cale> typetetris: Just use Data.ByteString or Data.Text.Strict
00:15:04 <kuribas> is there a library that can turn a Generic instance into something monomorphic?
00:15:26 <dminuoso> What is "something monomorphic" to you?
00:15:28 <dminuoso> Your question is not clear.
00:15:36 <Cale> typetetris: Convert to String if you must, but String is not a very efficient representation anyway
00:15:37 <dminuoso> Also, what do you mean by "the instance itself"?
00:15:43 <kuribas> dminuoso: a single monomorphic value
00:15:52 <dminuoso> kuribas: And what do you mean by instance? Do you wish to reify a dictionary?
00:15:53 <typetetris> Cale: I know.
00:16:15 <kuribas> dminuoso: let's say a function Generic a => a -> GenericInfo
00:16:29 <dminuoso> And what should GenericInfo contain?
00:16:43 <kuribas> dminuoso: constructor names, argument types (as string), ...
00:16:58 <Cale> kuribas: Isn't that what Generic is all about?
00:17:11 <dminuoso> kuribas: You can implement a GShow instance based on Generic like that.
00:17:24 <kuribas> GShow?
00:17:25 <dminuoso> Or typeclass, rather.
00:17:44 <kuribas> a single string?
00:17:48 <kuribas> that's not very useful
00:17:51 <dminuoso> Or some dictionary, if you like
00:18:16 <Cale> kuribas: Does it have to be the same type regardless of the instance?
00:18:55 <kuribas> Cale: no, generics is about translating a polymorphic type to another polymorphic type which is more generic (uses the same constructors).
00:19:25 <Cale> Well, Generic doesn't really apply to polytypes at all
00:19:32 <kuribas> Cale: it's hard to use because of the many data types involved and typeclass magick that is required.
00:19:46 <kuribas> Cale: indeed
00:19:59 <kuribas> But for some problems a simple ADT would suffice.
00:23:53 <dminuoso> Well syb has that
00:24:04 <dminuoso> https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Data.html#t:DataRep
00:24:12 <dminuoso> Or wait. Data.Data
00:24:50 <kuribas> ah nice
00:25:18 <kuribas> For example, I want to check for my REST api that some types are subsets of others.
00:25:53 <kuribas> the updatable fields of some resource would be a subset of all fields of that resource.
01:05:12 <John20> Hi All, I have a Row datatype that looks something like this - `data Row = Row{col1 :: String, col2 :: Int ...}` . I've also got a column datatype `data Column = Col1 | Col2...` I'd like to sort a list of rows based on a specified column . The best I can do so far is something like this `colsort c = case c of Col1 -> {sortOn col1} Col2 -> {sortOn col2}`. However it feels bad repeating the call to sortOn for each column. Is there a better way of doing this?
01:07:20 <John20> I'd like to do ``colsort c = sortOn $ case c of Col1 -> {col1} Col2 ->....`` but the compiler doesn't like it as col1 has a different return type to col2.
01:16:02 <merijn> John20: Oh! Time to teach you a cool trick
01:16:14 <merijn> Step 1:
01:16:17 <merijn> :t comparing
01:16:18 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
01:16:57 <merijn> Step 2: Realising that Ordering is a Monoid
01:17:11 <merijn> (it returns the left most non-EQ value)
01:17:16 <merijn> > LT <> EQ
01:17:17 <lambdabot>  LT
01:17:22 <merijn> > EQ<> GT
01:17:24 <lambdabot>  GT
01:18:05 <merijn> Step 3: Realising that "functions returning a Monoid are a Monoid" (i.e. "instance Monoid m => Monoid (r -> m)" and that this instance applies recursively
01:18:10 <merijn> :t comparing fst
01:18:11 <lambdabot> Ord a => (a, b) -> (a, b) -> Ordering
01:18:13 <merijn> :t comparing snd
01:18:15 <lambdabot> Ord a1 => (a2, a1) -> (a2, a1) -> Ordering
01:19:43 <merijn> > sortBy (comparing snd <> comparing fst) ((,) <$> [1..5] <*> [1..5])
01:19:45 <lambdabot>  [(1,1),(2,1),(3,1),(4,1),(5,1),(1,2),(2,2),(3,2),(4,2),(5,2),(1,3),(2,3),(3,...
01:20:03 <merijn> Sorts by snd first and breaks ties via fst :)
01:21:14 <merijn> Oh, I just realised the actual question is slightly different, but half the answer still applies ;)
01:21:45 <merijn> John20: If you return "comparing col1" instead of "col1" then all the columns will have matching types
01:22:43 <merijn> Of course you can combine 'function from Column to "comparing col1"' and the first trick to allow users to sort by arbitrary combinations of columns ;)
01:28:31 <justsomeguy> Does the syntax "import Data.List.NonEmpty (NonEmpty(..))" import all the functions related to the NonEmpty datatype? What does the "(..)" part mean?
01:29:57 <merijn> justsomeguy: The constructors
01:30:17 <justsomeguy> Ah, that makes sense. Thanks merijn
01:30:26 <merijn> justsomeguy: So for example "import Data.Maybe (Maybe)" imports *only* the type, Maybe, but not the constructors Just/Nothing
01:30:57 <merijn> justsomeguy: You can use "import Data.Maybe (Maybe(Nothing,Just))" or any subset you like (both for exports and imports) (..) is just short hand for "all of them"
01:57:42 <John20> Thanks merijn. That was super helpful. I knew about Ord, but not Ordering. I'm now off to go and play with Ordering and comparing!
01:58:41 * hackage nix-tree 0.1.0.0 - Interactively browse a Nix store paths dependencies  https://hackage.haskell.org/package/nix-tree-0.1.0.0 (utdemir)
02:00:30 <frase> Hello.  Question about FFI and bound threads: if I use unsafeInterleaveIO in a bound thread, will FFI calls in the (suspended) IO be executed on the bound thread, or is that guarantee forfeit?
02:01:18 <merijn> frase: wow...I'm honestly not sure anyone on the planet knows that answer xD
02:01:25 <int-e> frase: pretty sure it's the latter
02:01:55 <lortabac> int-e is not on this planet :P
02:02:38 <frase> merijn: how I got to asking this question is a whole series of conference talks :D
02:05:35 <int-e> frase: https://paste.debian.net/1154737/ looks pretty convincing (don't forget -threaded when compiling)
02:08:20 <int-e> frase: I also believe that if you happen to evaluate the interleaved thing in the original thread you should be fine. But usually you have no control over that.
02:09:42 * hackage rvar 0.2.0.6 - Random Variables  https://hackage.haskell.org/package/rvar-0.2.0.6 (DominicSteinitz)
02:10:43 * hackage random-fu 0.2.7.6, random-source 0.3.0.10 (DominicSteinitz): https://qbin.io/codes-twinks-vowo
02:11:36 <frase> thanks int-e, I think I'll need to do a more thorough investigation using forkOS and perhaps FFI calls to pthread to obtain (or not) evidence that the guarantees are lost
02:11:42 * hackage shakebook 0.8.1.0 - Shake-based technical documentation generator; HTML & PDF  https://hackage.haskell.org/package/shakebook-0.8.1.0 (locallycompact)
02:18:26 <reactormonk> What's the syntax for splicing a Q String, so I have String afterwards?
02:19:04 <c_wraith> you can't splice a Q String
02:19:16 <c_wraith> you could splice a Q Exp that happened to represent a string
02:19:19 <int-e> frase: Note that forkOS creates a bound thread with its own OS worker thread (with its own thread-local storage)... so you may actually need a dedicated worker thread that handles all the calls.
02:19:29 <dminuoso> reactormonk: Go through an Expr
02:19:42 <dminuoso> reactormonk: Say: Lit "foo"
02:19:54 <reactormonk> Or to be more explicit, I want https://www.stackage.org/haddock/lts-16.3/template-haskell-2.15.0.0/Language-Haskell-TH.html#v:location
02:19:55 <dminuoso> Err: Lit (StringL "foo"))
02:20:47 <int-e> . o O ( Let's have per thread global variables, what could possibly go wrong? )
02:20:50 <reactormonk> Or if there's a better way, I need the project root of the current project, some test files require men to laod external files
02:20:56 <dminuoso> f g h x = g x (h x)
02:21:01 <dminuoso> Is this a thing? This looks arrowy
02:21:10 <dminuoso> Or profunctory
02:21:11 <c_wraith> dminuoso: it's <*>
02:21:35 <c_wraith> (also known as the S combinator)
02:23:24 <c_wraith> > (f <*> g) x :: Expr
02:23:26 <lambdabot>  error:
02:23:27 <lambdabot>      â€¢ Ambiguous type variable â€˜a0â€™ arising from a use of â€˜fâ€™
02:23:27 <lambdabot>        prevents the constraint â€˜(Show a0)â€™ from being solved.
02:23:58 <c_wraith> Wait, is it just Exp?
02:24:05 <boxscape> % (<*>) @(-> _)
02:24:05 <yahb> boxscape: ; <interactive>:93:12: error: parse error on input `_'
02:24:15 <boxscape> % (<*>) @((->) _)
02:24:15 <yahb> boxscape: ; <interactive>:94:1: error:; * No instance for (Show ((_0 -> a0 -> b0) -> (_0 -> a0) -> _0 -> b0)) arising from a use of `print'; (maybe you haven't applied a function to enough arguments?); * In a stmt of an interactive GHCi command: print it
02:24:27 <boxscape> % :t (<*>) @((->) _) -- one more try
02:24:27 <c_wraith> ah, it's just too polymorphic
02:24:27 <yahb> boxscape: (_ -> a -> b) -> (_ -> a) -> _ -> b
02:24:45 <c_wraith> > (f <*> (g :: Expr -> Expr)) x :: Expr
02:24:47 <lambdabot>  f x (g x)
02:25:16 <frase> int-e: right, and I'm perfectly OK with that, if it does turn out that even suspended IO that originated in a bound thread does get executed back on the bound thread.
02:25:45 <frase> (which I am not hopeful for, but would love to know with certainty)
02:26:25 <dminuoso> c_wraith: Oh wow, I never made the connection between (<*>) and the S-combinator.
02:26:51 <c_wraith> Well, it's only S for the ((->) a) instance.
02:26:53 <c_wraith> But yeah
02:27:54 <boxscape> dminuoso which also means <*> and pure together are turing complete, which is kind of neat
02:28:10 <int-e> frase: What I mean is that the RTS won't do this for you, you have to do this yourself, making a worker thread with some communication channel (MVar or STM based), and turning any suspended action into a request to the worker.
02:30:10 <frase> int-e: thanks, I get you now.
02:30:18 <int-e> frase: Fundamentally, IO actions don't keep track of which thread created them. What happens wrt. FFI (and in particular bound threads) is determined by the thread that happens to execute the IO action.
02:31:19 <int-e> So once you detach creation from execution (which is one way to think about unsafeInterleaveIO) you lose all guarantees about thread identity.
02:31:52 <frase> yeah, that is what I suspected, thanks int-e 
02:32:08 <dminuoso> When your language primitives regularly have such deep relationship to mathematics and CS, it does make one think that Haskell is barking up the right tree with its abstractions.
02:37:44 <boxscape> though actually...
02:37:50 <boxscape> you're going to have trouble encoding the Y combinator
02:37:52 <boxscape> thanks to the type system
02:38:01 <boxscape> so not turing complete without adding fix
02:38:28 <dminuoso> boxscape: we can think of the newtypes as being just noise that we can squint over.
02:38:29 <boxscape> % :t (<*>)(<*>)pure((<*>)(pure((<*>)(<*>)((<*>)((<*>)(<*>)pure))))pure) -- (this is the Y combinator)
02:38:29 <yahb> boxscape: ; <interactive>:1:11: error:; * Occurs check: cannot construct the infinite type: a0 ~ (b -> b) -> a0 -> b; Expected type: ((b -> b) -> ((b -> b) -> a0 -> b) -> b) -> (b -> b) -> (b -> b) -> a0 -> b; Actual type: ((b -> b) -> a0 -> b) -> (b -> b) -> (b -> b) -> a0 -> b; * In the second argument of `(<*>)', namely `pure'; In the expression: (<*>) (<*>) pure ((<*>) (pure ((<*>)
02:38:36 <boxscape> dminuoso fair
02:44:46 <int-e> boxscape: newtype Y a = Y { unY :: Y a -> a }; fix f = let t = Y (\t -> f (unY t t)) in unY t t
02:46:17 <int-e> (don't do that in ghc, it'll cause the simplifier a lot of trouble)
02:47:05 <int-e> which is technically a bug, but not one anybody cares about enough to fix (hah).
02:48:02 <int-e> > fix error
02:48:04 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
02:49:06 <int-e> boxscape: note that with the attitude that newtypes are just noise, that definition becomes  fix f = let t = \t -> f (t t) in t t, which is essentially the Y combinator.
02:49:16 <boxscape> yeah, that makes sense
02:49:41 <int-e> (I should've renamed one of those t's)
02:51:14 <int-e> FWIW, the idea of packing up an otherwise infinite type in a newtype like that is actually occasionally useful.
02:52:50 <boxscape> for recursion schemes IIRC?
02:53:51 <c_wraith> lots of things.  It's part of the most common representation of Mealy and Moore machines, for instance
03:00:58 <boxscape> % s' = (<*>) @((->) _)
03:00:58 <yahb> boxscape: 
03:01:04 <boxscape> % k' = pure @((->) _)
03:01:05 <yahb> boxscape: 
03:01:13 <boxscape> % newtype Y a = Y { unY :: Y a -> a }; fix f = let t = Y ((s' (k' s') k') f ((s' (s' (k' (s' (k' s') k')) s') (k' k')) s' (s' k' k')) unY) in unY t t
03:01:13 <yahb> boxscape: 
03:01:19 <boxscape> int-e simplifier is fine with this one :)
03:01:43 <MarcelineVQ> shkashka
03:02:12 <int-e> boxscape: Have you tried to actually use it? As I recall it, the problem is that once you do that, the simplifier just keeps unrolling it forever. Maybe I misremember. Or maybe it only applies to the silly case `fix id`.
03:02:32 <boxscape> int-e, well, no, but the simplifier already complains during the definition of the regular version
03:02:39 <boxscape> % newtype Y a = Y { unY :: Y a -> a }; fix f = let t = Y (\t -> f (unY t t)) in unY t t
03:02:39 <yahb> boxscape: Simplifier ticks exhausted; When trying UnfoldingDone t_si2x; To increase the limit, use -fsimpl-tick-factor=N (default 100).; ; If you need to increase the limit substantially, please file a; bug report and indicate the factor you needed.; ; If GHC was unable to complete compilation even with a very large factor; (a thousand or more), please consult the "Known bugs or infelicities"; se
03:03:00 <boxscape> int-e certainly plausible that it still occurs later down the line :)
03:03:50 <int-e> boxscape: Anyway, even if the resulting code works, this kind of behavior can't be healthy for the compiler and its output... those simplifier ticks could've been useful elsewhere.
03:04:05 <boxscape> yeah that's true
03:07:43 <int-e> It's still a neat demonstration that datatypes alone add power to the simply typed lambda calculus. (Not a big surprise; the operations we have, case distinction and constructors, which in pure lambda calculus would correspond to a Scott encoding, which I think requires rank 2 types.)
03:10:16 <dminuoso> boxscape: You can address this by adding a NOINLINE pragma
03:10:27 <dminuoso> It's essentially just a GHC bug.
03:10:32 <boxscape> ah
03:11:00 <int-e> Hrm, actually that last part can't be right, because we've actually lost termination. I'll have to think about it.
03:15:56 <int-e> Right, rank 2 types just don't cover Scott encodings, because they actually need a type level fixed point.
03:24:09 <boxscape> int-e so to make a well-typed term-level fixed point we need a type-level fixed point?
03:27:23 <int-e> boxscape: Plausible, but I don't understand this well enough to confirm. I have enough trouble with the concrete example of the Y combinator :)
03:27:31 <boxscape> ok
04:07:11 * hackage ngx-export-tools-extra 0.5.0.0 - More extra tools for Nginx haskell module  https://hackage.haskell.org/package/ngx-export-tools-extra-0.5.0.0 (lyokha)
04:34:27 <pagnol> Is there a way to do `(a, Maybe b) -> Maybe (a, b)` without explicit pattern matching?
04:35:03 <merijn> Yes, but I always forget how :p
04:35:39 <boxscape> % sequence (4, Just 5)
04:35:39 <yahb> boxscape: Just (4,5)
04:35:42 <boxscape> ^ pagnol
04:35:47 <pagnol> aha
04:36:19 <pagnol> thanks
04:38:13 <kuribas> % _2 id (4, Just 5)
04:38:14 <yahb> kuribas: Just (4,5)
04:40:53 <justsomeguy> Is there a way to import a function so that it shadows an existing one in Prelude? Something like "import Data.List.NonEmpty (filter)", so that using it doesn't result in "Ambiguous occurrence of 'filter'".
04:41:39 <boxscape> justsomeguy you can use `import Prelude hiding (filter)`
04:42:09 <justsomeguy> Great, that would work.
04:42:38 <merijn> justsomeguy: THat's a bad idea though, just import qualified
04:43:07 <merijn> "import qualified Data.List.NonEmpty as NonEmpty" or something and then you just use NonEmpty.filter
04:44:09 <phadej> it even says so
04:44:10 <phadej> A NonEmpty list is one which always has at least one element, but is otherwise identical to the traditional list type in complexity and in terms of API. You will almost certainly want to import this module qualified.
04:44:20 <justsomeguy> Yes, it's definitely a bad idea. :^) I was just looking for an easier way to type these things when experimenting in the repl.
04:44:49 <phadej> i.e. import Data.List.NonEmpty (NonEmpty (..)) import qualified Data.List.NonEmpty as NE
04:45:01 <phadej> in repl you cannot IIRC hide the imports
04:45:24 <typetetris> Is it normal, that I have to issue `cabal build` multiple times once in a while?
04:47:13 <merijn> typetetris: Not really
04:47:35 <typetetris> Okay, next time I will store outputs.
04:47:45 <merijn> phadej: btw, do you know if with the Hackage update to Cabal 3.x does that mean hackage now supports multi-lib packages?
04:48:18 <boxscape> phadej you can hide them
04:51:29 <phadej> merijn: no, Hackage doesn't support htem
04:52:11 <phadej> boxscape: I know that you can unload module import, but I'm not sure about individual symbol
04:52:32 <boxscape> phadej I wasn't sure either, which is why I tried it before responding to you :)
04:53:09 <phadej> I'd still recommnd against, as it's tricky to see what's in scope
04:53:26 <boxscape> agreed
04:53:31 <phadej> in repl it's (IMO) fine to disambiguate with Prelude.filter
04:53:55 <justsomeguy> I'm a bit curious... why does Haskell choose not to shadow functions during import? Is there some reason for this design decision?
04:54:03 <phadej> and shorten import (i.e. import Data.ByteString as BS e.g.)
04:54:15 <merijn> justsomeguy: What if you multiple imports shadowing?
04:54:20 <boxscape> justsomeguy it would be confusing if the order of imports mattered
04:54:39 <merijn> justsomeguy: Do you use the last import? Because then you get the Scala craziness where reordering imports breaks code
04:54:40 <justsomeguy> merijn: The last import statement would win. Also, local definitions would win over imported ones.
04:55:07 <justsomeguy> Ah, ok, reordering statements could be a problem.
04:55:09 <merijn> justsomeguy: That kinda thinking seems like a great idea. Until you have a 10k SLOC codebase you need to refactor ;)
04:55:17 <phadej> justsomeguy: the local definitions over imported ones was discussed
04:55:26 <phadej> that proposal/idea just didn't go anywhere
04:55:33 <boxscape> a potentially better solution is type-directed overloading, which Idris has. But I'm not sure yet if I like it
04:55:57 <phadej> that would make compiler even slower ;)
04:56:04 <boxscape> yeah, that's true
04:56:25 <phadej> and couple renaming with type-checker, which is engineering challenge
04:56:29 <merijn> justsomeguy: It's like "explicit conversion between numeric types" it seems annoying until you work in another language that doesn't have it and you spend 2 weeks trying to identify a bug caused by the lack of explicitness :)
04:57:13 <kuribas> are all monomorphic types automatically instances of Typeable?
04:57:29 <kuribas> merijn: +1
04:57:40 <merijn> I hate "fromIntegral" everywhere
04:57:58 <kuribas> me too, but the alternative of implicit conversion is worse.
04:58:02 <merijn> But I once spend 3 weeks tracking down an implicit type conversion in C, so I just think off that every time I get annoyed ;)
04:58:10 <merijn> s/off/of
04:58:11 <boxscape> the main thing I dislike about Haskell's explicit conversion is that they chose such a long name for "fromIntegral" :)
04:58:17 <merijn> boxscape: Yeah
04:58:26 <merijn> "fI = fromIntegral" ;)
04:58:32 <boxscape> yeah I've done that
04:59:06 <dminuoso> The main thing I dislike about Haskells explicit conversion, is that it forces you to confront the reality of decades of bugs by implicit conversions doing the wrong thing.
04:59:21 <dminuoso> Wish I could have kept ignorant.
04:59:23 <merijn> dminuoso: Also the lack of support for actually doing it properly
04:59:25 <ezzieyguywuf> koz_: to answer your question from last night - no the set of types of data that can be fed in is not closed.
04:59:34 <dminuoso> merijn: Yeah. :(
05:00:11 <ezzieyguywuf> but really I think I'm approaching this from the wrong angle. The data being fed in is known by me at compile time. I suppose I can just hard code it. This will make growing the code base slightly more cumbersome, but I don't expect the set of data that I specifically want to provide to grow very larg
05:00:48 <dminuoso> Most of it in Haskell still does the wrong thing, since sprinkling your code with fromIntegral and realToFrac still gives you the same behavior.
05:00:52 <phadej> merijn: re Hackage, the Hackage codebase itself iirc is not ready for dealing with sublibs
05:01:15 <kuribas> dminuoso: that's true of all haskell.
05:01:16 <merijn> phadej: I recall that was the case, but I wasn't sure if it was just due to lack of cabal 3.x at the time
05:01:21 <kuribas> dminuoso: including Monads, etc...
05:01:26 <phadej> at the very least the revision checking (what's allowed and what's not) is not adapted properly
05:01:41 <phadej> I think it would allow you to add dependencies to sublibraries
05:01:46 <phadej> which is wrong
05:02:02 <boxscape> dminuoso is there a better design than providing realToFrac and fromIntegral?
05:03:11 <merijn> phadej: I currently have 4 packages that are, essentially, just 1 package + optional packages to support conduit/pipes/etc. and keeping everything in sync is kinda a pain, turning them into a single package would be ideal, so I'm just waiting to play guinea pig and test it :p
05:03:37 <merijn> boxscape: Something that properly deals with bounds
05:03:56 <boxscape> hm, okay
05:04:02 <dminuoso> boxscape: Explicit conversion functions with explicit flavours of different error behaviors (should it wraparound, cut off remaining bits, error out)?
05:04:09 <boxscape> I see
05:04:15 <dminuoso> I mean you can provide generic instances like realToFrac and fromIntegral if the conversion works without loss of information.
05:04:15 <merijn> boxscape: Just search GHC's commit log for my 3 commits where I get it wrong 3 times in a row, despite multiple reviewers signing off on my fix (meaning they didn't see it either) :p
05:04:18 <dminuoso> That is fine.
05:05:00 <merijn> boxscape: My final contribution has more comments justifying it's correctness than it has code! https://github.com/ghc/ghc/blob/24e05f48f3a3a1130ecd5a46e3089b76ee5a2304/libraries/base/GHC/Event/Poll.hsc#L105-L142
05:05:49 <phadej> merijn: sure case to smash all nix and stack users issues to "doesn't work with nixpkgs or stack"
05:06:03 <merijn> phadej: "Fuck you, pay me"
05:06:06 <boxscape> hm, interesting
05:06:23 <phadej> merijn: :)
05:06:36 <merijn> phadej: I will support other people's tool usage to the extent it doesn't inconvenience me.
05:06:52 <merijn> If you want extra features that inconvenience me, you can damn well pay me or cry me a river
05:07:26 <phadej> (nix usage should work in theory, but I suspect in practice some changes needed either there too)
05:07:54 <phadej> at least if you use nixpkgs managed global package db, but still want to use cabal v2-...
05:08:06 <justsomeguy> If someone implemented syntax for explicit shadowing like "import Data.List.NonEmpty (head) overriding Prelude (head)", would it horrify you?
05:08:13 <phadej> yes
05:08:34 <justsomeguy> lol, I probably should have kept that thought to myself.
05:08:50 <phadej> it's good idea to read through ghc-proposals repository
05:09:07 <phadej> there are many ideas what would be nice for import (and exports)
05:09:23 <phadej> "local" changes don't make many people very excited
05:09:53 <merijn> justsomeguy: The problem with "minor tweaks to syntax" is that it needlessly breaks *every* tool
05:10:05 <dminuoso> justsomeguy: It would horrify me because there appears to be no need for it. Adding `import Prelude hiding (head); import Data.List.NonEmpty (head)` is perfectly fine already.
05:10:07 <dminuoso> Or using qualified imports.
05:10:18 <merijn> justsomeguy: Lots of people enthusiastically propose "nice" syntax changes that would make things cleaner. And they're not wron
05:10:24 <dminuoso> The convenience gained likely affects only very few people, but the impact of changing syntax is great
05:10:39 <justsomeguy> All very good points.
05:10:40 <merijn> justsomeguy: But they don't take the time to think "is this 'ugliness' really so bad to justify breaking every tool out there?"
05:11:11 <int-e> the problem solved is not big enough to justify the pain
05:11:32 <merijn> Is the current import system a bit inconvenient? Yes. Are there a bunch of ways it could have been nicer? Yes. And if someone makes a new Haskell inspired language they should *definitely* change it
05:11:39 <dminuoso> justsomeguy: The general style is to just use qualified imports left and right. So `import qualified Data.List.NonEmpty as NE` and then using NE.head - that's how most projects appear to do it.
05:11:58 <dminuoso> I dont consider it a large inconvenience, since you very frequently end up with so many overlapping things, you need qualified imports anyway.
05:12:15 <int-e> (the problem I see that this solves is that you cannot hide imports incrementally... hide `head` because of NonEmpty, hide `map` because you want to use that for `fmap`...)
05:12:51 <merijn> For example, I think "import qualified Data.Map as Map (Map)" should import the parenthesised values *without* qualification so you don't have to write "import Data.Map (Map); import qualified Data.Map as Map", because that's a major gripe I have. But I think it's probably not worth it
05:12:58 <Rembane> IMO, Haskell's import system is strictly better than all other languages I've used except for PureScript. 
05:13:09 <dminuoso> And in my opinion, qualified imports are the cleanest solution to this already.
05:13:22 <dminuoso> Plenty of languages dont allow for it, and its super frustrating
05:13:34 <justsomeguy> Right. I don't really think Haskell should change it's import system. But learning Haskell has been like an exploration of programming language concepts for me. So when I seem something that sticks out, or is different from other languages I know, I've found that it's hard to resist the urge to ask "but what if I did it like this, instead?". The fact that haskell is so customizable makes it an especially tantalizing question.
05:13:38 <int-e> merijn: I just use M.Map because I resent it less than the extra unqualified import :P
05:13:46 <merijn> int-e: That's ugly as sin >.<
05:13:51 <ezzieyguywuf> dminuoso: you prefer `import qualified SomeModule as SM` to `import SomeModule (f1, f2)`?
05:13:58 <int-e> merijn: Not really :)
05:14:07 <dminuoso> ezzieyguywuf: If there's a likely chance of collision, yes.
05:14:10 <merijn> justsomeguy: Yes, I see that a lot :)
05:14:33 <ezzieyguywuf> I use `Map.Map`.....
05:14:38 <dminuoso> ezzieyguywuf: It usually becomes muscle memory. For example, modules from `containers` always get imported qualified (and always with the same qualifiers)
05:15:19 <dminuoso> S for Set, IM for IntMap, M for Map, BS for ByteString, BSL for Lazy.ByteString, etc
05:15:37 <merijn> dminuoso: LBS >.<
05:15:41 <merijn> dminuoso: Heretic!
05:15:45 <ezzieyguywuf> lol
05:16:02 <merijn> It's a "lazy bytestring" not a "bytestring lazy" >.<
05:16:21 <ezzieyguywuf> someone said in here yesterday something about how you can use your imports as a type of documentation. I thought that was a very good point
05:16:23 <dminuoso> merijn: The day I decided between BSL and LBS, I had some reason for the former.
05:16:30 <int-e> merijn: but the module name is Data.ByteString.Lazy
05:16:35 <dminuoso> Oh right, that's it!
05:16:37 <dminuoso> ^-
05:17:03 <merijn> ezzieyguywuf: I think all imports should be either qualified or explicitly listed, so that searching an identifier in a file always turns up where its from
05:17:29 <dminuoso> In general anyhow.
05:17:37 <merijn> ezzieyguywuf: Exceptions being Prelude and very rarely I'll make an exceptions for something like optparse-applicative/megaparsec where an entire module will be 90% imports from that package
05:17:38 <dminuoso> When I drag in servant, Im not gonna bother with either.
05:17:40 <ezzieyguywuf> merijn: I agree.
05:17:58 <merijn> But I try to not have implicit imports from more than 1 package per module
05:18:01 <boxscape> merijn how about lens?
05:18:02 <dminuoso> Because listing all the primitives you want from servant packages is going to be a real pain, and qualified is true annoyance.
05:18:05 <int-e> The real game-changer here would be qualified exports.
05:18:05 <merijn> dminuoso: ^^ simple compromise :)
05:18:06 <dminuoso> Or lens indeed!
05:18:11 <merijn> boxscape: I don't really use lens
05:18:13 <maerwald> boxscape: lel
05:18:15 <boxscape> fair enough
05:18:26 <dminuoso> merijn: I guess my only issue is your phrasing of "all imports" :)
05:18:34 <maerwald> that's gonna be a painful import list
05:18:43 <merijn> dminuoso: Compromise: max 1 external package is imported implicitly :)
05:19:07 <int-e> (I'm pretty sure there's at least one ghc proposal for that.)
05:19:15 <boxscape> int-e there is indeed
05:19:41 <merijn> qualified exports would be great
05:19:42 <dminuoso> Ultimately I think there's far more pressing matters in ghc-proposals than exports/imports.
05:19:45 <maerwald> I remember a company where you had to always export all identifiers and had to do ALL imports explicitly
05:19:50 <maerwald> It was awful
05:19:55 <dminuoso> Or things that need fixing.
05:20:07 <boxscape> https://github.com/michaelpj/ghc-proposals/blob/imp/first-class-modules/proposals/0000-first-class-modules.rst
05:20:13 <dminuoso> Like, a Text based Show class in base would be superb.
05:20:16 <boxscape> I think?
05:20:19 <boxscape> maybe it was another one
05:20:36 <dminuoso> Oh first class modules, that sounds like ML functors.
05:20:51 <boxscape> ah, no, it's this one, 1.3.2, Exporting qualified names
05:21:37 <reactormonk> How do FFI to C and C macros interact? Can I just FFI a macro, and rely on GHC to compile it as a C file, or does it expect an actual function call?
05:21:40 <int-e> boxscape: https://github.com/ghc-proposals/ghc-proposals/pull/283 is the one I remembered
05:22:02 <boxscape> ah, yeah
05:22:04 <dminuoso> reactormonk: A C macro is just preprocessor stuff.
05:22:46 <reactormonk> dminuoso, so if the description of a macro says "returns an int", and I can treat it like a call?
05:22:55 <dminuoso> reactormonk: No
05:23:21 <dminuoso> reactormonk: It's not a call because the macro is expanded by the preprocessor.
05:23:32 <dminuoso> It's sort like template haskell
05:23:35 <dminuoso> except much less powerful :)
05:23:45 <reactormonk> So make a .h file somewhere, name it a proper function, and call that from Haskell?
05:23:56 <reactormonk> ... except it might not work as expected
05:24:12 <dminuoso> Im not sure I understand what you are trying to figure out
05:24:54 <merijn> reactormonk: You wanna look at the CApiFFI extension in the GHC user guide
05:24:59 <reactormonk> I want to talk to valgrind from Haskell, and it's got a few macros I can use to talk to it. I wanna call these from Haskell: https://www.valgrind.org/docs/manual/manual-core-adv.html#manual-core-adv.clientreq
05:25:02 <merijn> reactormonk: Which does support interacting with C macros :)
05:25:21 <merijn> reactormonk: (by generating C files for you and compiling those)
05:25:40 <reactormonk> merijn, nice!
05:39:38 <quakoo> I am trying to use xmonad and when I go to refresh it I get this error: https://pastebin.com/ZcxwTcbn. I had messed around in Haskell some time ago so I already had it installed. Any ideas?
05:40:33 <merijn> quakoo: Can you run "ghc --numeric-version"?
05:40:54 <merijn> and pastebin the result of "ghc-pkg list"
05:42:32 <quakoo> https://pastebin.com/QLwNwu1y
05:42:38 <quakoo> version 8.8.3
05:43:59 <merijn> Right, so some clues
05:44:57 <merijn> At least xmonad and your system ghc agree which GHC to use, and ghc-pkg list says that, indeed, xmonad is not installed. I suspect this is due to cabal 3.0 being used and that doesn't install libraries into the regular package database
05:45:06 <merijn> quakoo: How did you initially install/build xmonad?
05:45:16 <merijn> "cabal install xmonad"?
05:45:32 <quakoo> merijn: no I used my package manager
05:45:39 <gentauro> I'm looking to find a specific pattern in a list. Given the following pattern `['a','b','c'], I would like to produce a list of lists with indexes of the elements. Input: "aeeeebffffcdddddaffbec" and Output: [[0,5,10],[16,19,20]]. Can this be done with a list comprehension?
05:45:48 <merijn> quakoo: ah...
05:45:51 <merijn> Which distro?
05:45:59 <quakoo> openSUSE
05:46:23 <merijn> ok, I have no clue how they handle things, but at least it's not Arch ;)
05:46:47 <merijn> quakoo: Ok, I recommend: uninstalling the openSUSE xmonad install, running "cabal v1-install xmonad" and then trying again
05:47:03 <quakoo> ok I will thanks very much
05:47:06 <merijn> (at least, I'm assuming they installed the cabal executable, maybe check that first)
06:06:33 <quakoo> merijn: It worked in case you are wondering :] 
06:23:29 <John20> qq. If I have 2 functions that write to 2 different files and I run them concurrently using mapConcurrently_ . Do I run the risk that data that should have been written to one of the files will end up in the other? e.g. if there is some sort of shared state behind the scenes for file writing that I might not know about.
06:24:11 * hackage exception-transformers 0.4.0.9 - Type classes and monads for unchecked extensible exceptions.  https://hackage.haskell.org/package/exception-transformers-0.4.0.9 (GeoffreyMainland)
06:24:44 <John20> Similarly for http calls using simpleHttp. Is there a chance that the data retrieved might end up in the wrong function?
06:28:22 <merijn> John20: No, that should be fine
06:29:22 <merijn> John20: Keep in mind that's there's almost no mutable variables in most Haskell, so how would that even go wrong :) It's theoretically possible if you got out of your way to risk breaking things, but I'd say >95% of Haskell package are threadsafe :)
06:33:12 <srk> mm, is there a Matrix protocol implementation?
06:35:29 <srk> some WIP stuff https://github.com/unclechu/hatrix https://github.com/unclechu/haskell-matrixmpp
06:37:02 <unclechu> srk: i'd say "abandoned" ðŸ™‚ i'm not sure when i'd have enough time to get back to those projects
06:37:48 <srk> unclechu: oO hello! is there a protocol part implementation somewhere?
06:38:20 <srk> unclechu: I'm thinking of fixing IRC bridge but that requires Haskell Matrix proto client first :)
06:38:27 <John20> Thanks merijn. That's what I though. Just wanted to make sure
06:38:42 <dminuoso> merijn: Until they are not.
06:38:51 <unclechu> srk: i don't remember seeing one written in haskell
06:39:02 <dminuoso> Especially software interfacing with POSIX routines can easily be non-threadsafe.
06:39:31 <srk> unclechu: no problem, do you know how complex it is / related to xmpp?
06:40:35 <John20> dminuoso, I don't think that I'm straying too far from "standard" haskell libraries. I've got a function that calls simpleHttp and writes the result to a file. I'd like to call it a few times concurrently (different urls and files).
06:40:54 <unclechu> srk: i think it's a lot simpler and straightforward, all you need is just HTTP and JSON
06:41:10 <srk> cool, will take a look
06:41:17 <unclechu> srk: https://matrix.org/docs/spec/ and here is swagger spec https://matrix.org/docs/api/client-server/
06:41:38 <dminuoso> John20: Honestly, consider software running on Apple. The second you have any dependency on name resolution, it's racy because the underlying Apple primitives are not reentrant.
06:41:56 <srk> unclechu: thanks! swagger makes it trivial I guess :)
06:41:58 <unclechu> you can do authentication with just curl
06:42:12 <dminuoso> so concretely, any haskell package relying on the system name resolver is not thread safe on macOS.
06:42:16 <dminuoso> Which is a large bunch.
06:42:18 <unclechu> srk: so, just take "servant" and "aeson" and go with it
06:43:20 <srk> unclechu: you mean avoiding swagger?
06:44:02 <unclechu> srk: not necessarily
06:44:35 <unclechu> i'm not sure if there's a tool that converts swagger spec into servant api spec
06:44:54 <srk> not sure if I need that for client
06:45:16 <srk> need to play with it and study matrix (bridges) a bit
06:46:22 <dminuoso> There was a tool that would modify the cabal file, setting PVP version constraints of all packages based on what the current build plan has.
06:46:25 <dminuoso> Which was that?
06:46:52 <John20> thanks dminuoso. Is there any way to ensure thread safety from haskell then?
06:47:22 <dminuoso> John20: Only if you dont use the system resolver, or ask Apple nicely to fix their software. I tried in vain.
06:47:55 <dminuoso> John20: My point is a different though: You could be transitively using primitives that are not threadsafe/reentrant without realizing it. The shared state can be outside the Haskell world.
06:48:00 <srk> dminuoso: cabal gen-bounds?
06:48:41 <dminuoso> srk: Ah must have been it, thanks. It didn't even occur to me that cabal was able to do this. :)
06:49:26 <srk> I've updated cabal-bounds to cabal3 recently which can modify specific bounds in .cabal files 
06:50:08 <dminuoso> Ah yes, I think I used that tool
06:50:09 <srk> one more thing it needs is to be able to do that without reformatting them 
06:50:20 <dminuoso> Does it use ^>= format as well?
06:50:46 <srk> don't know about that, might need another update :)
06:51:30 <srk> I want to try automagic with it - nix-build -> scan output for failed deps, try to bump bounds, repeat
06:52:29 <sm[m]> srk, "fixing the IRC bridge" eh, does that mean reimplementing matrix-appservice-irc in haskell ?
06:53:16 <dminuoso> srk: With ^>= you can just specify the exact version you are using, and cabal will automatically determine the correct PVP bounds from it. :)
06:54:02 <srk> sm[m]: yes. to be able to add stuff like rate-limiting edit notifications for long messages and deploy it easily..
06:56:02 <srk> dminuoso: neat! automagic could help until most of the ecosystem moves to that and PVP 
06:56:12 <sm[m]> good for you! I hope it matrix-freenode will switch to it
06:56:29 <hseg> ok, am reingeneering my polynomial code to be a specialization of a monoid algebra. Planning on implementing it as a Map m r -- recommendations for what should be strict?
06:57:02 <hseg> btw, is writing newtype MonoidAlgebra m r = Alg (Data.Map.Strict.Map !m !r) legal? recommended? 
06:57:37 <hseg> also, hashmap vs map?
06:57:50 <merijn> srk: "^>=" is short hand for "anything PVP compatible with this version and up" so "foo ^>= 1.5.2.3" or whatever will be equal to "foo >= 1.5.2.3 && < 1.6"
06:57:58 <hseg> _have_ noticed my Ord instance is expensive
06:58:39 <merijn> srk: It's actually slightly more subtle, because "^>=" signals "known to work with this PVP version" (i.e. the upperbound isn't known to be incompatible, just assumed to be per pvp)
06:59:03 <merijn> srk: The advantage is that you can then use "<" to be a hard upper bound (i.e. *known* to not work)
06:59:23 <srk> merijn: thanks! makes sense. gotta actually try it
06:59:24 <merijn> srk: And --allow-newer lets you then do things like "only relax ^>= based upper bounds"
06:59:58 <merijn> (else you have no way to know whether an upperbound is *known* broken or just not known to be compatible)
07:01:07 <srk> ah, cool
07:09:01 <L29Ah> ohh so ^>= turns into >= when followed by a <? nice
07:16:02 <L29Ah> ok it doesn't
07:16:16 <L29Ah> so ^>= deps are doomed to be changed to >=
07:18:43 <merijn> L29Ah: Not with the set notation :p
07:19:04 <merijn> L29Ah: Then you can do "foo ^>= {1.4, 1.5, 1.6}" to indicate supporting all those
07:20:06 <L29Ah> eww then i'll have to specify all the intermediate major releases!
07:22:19 <merijn> Proposals/discussion for better alternatives (and corresponding patches) welcome ;)
07:23:59 <dminuoso> I think the set notation is a decent middle groud.
07:29:56 <srk> so, how about eDSL instead of .cabal? :)
07:30:33 <merijn> No >.<
07:31:12 <srk> I'm not the first one who had that idea :D ..  https://breaks.for.alienz.org/blog/2012/12/17/cabal-a-haskell-edsl/ 
07:31:49 <hseg> recommendations for what fields to strictify in a map?
07:32:04 <merijn> srk: See, I think these discussion miss the point of .cabal files, tbh
07:32:04 <hseg> also hashmap vs map?
07:32:15 <L29Ah> map is a tree, hashmap is a hashmap
07:32:39 <hseg> ok. suppose tradeoff given by whether hash or ord is faster?
07:32:46 <L29Ah> memory vs speed tradeoff
07:32:49 <merijn> srk: Which is to be an *explicit* definition of what makes up a package. Implicit behaviour is *bad* for things that need to be distributed and robust
07:33:00 <merijn> hseg: The heuristic is "use Map by default"
07:33:02 <L29Ah> and yes
07:33:10 <hseg> k
07:33:10 <merijn> Unless your keys are Int, in which case, use IntMap by default
07:33:22 <hseg> keys are Vector n Int
07:33:24 <L29Ah> no point in hashing when your map contents can be traversed quickly
07:33:28 <merijn> L29Ah: It's not even a speed trade-off, tbh
07:33:41 <merijn> L29Ah: Hashmaps aren't magically faster than Map for all workloads
07:33:50 <L29Ah> sure
07:33:51 <merijn> And I wish people would stop pretending like they are
07:34:03 <L29Ah> hashmaps are for big N
07:34:07 <srk> merijn: how is eDSL which could possibly output .cabal file less explicit?
07:34:23 <hseg> k, will try both if necessary
07:34:30 <dminuoso> srk: .cabal has defined semantics
07:34:32 <merijn> srk: That's fine, in theory, but then you run into issues like "do you commit the .cabal file"
07:34:47 <merijn> srk: How do people cloning your code get it? Do they need to manually fetch all kinds of tools
07:34:47 <srk> yeah, kind-of similar to package.yaml
07:35:00 <dminuoso> srk: And once you get into eDSL territory, look at nix what an awful mess you can make out of "lets use a turing complete language to describe packages"
07:35:03 <merijn> srk: There's a reason why even Snoyman and FPComplete recommend against implict package.yaml now :)
07:35:20 <merijn> srk: Also, I think people overstate the difficulty of maintaining cabal file manually
07:35:25 <hseg> is it recommended to strictify keys? my code is convolution-heavy, so i'll have many <> in keys
07:35:58 <wavemode> Data.Map.Strict already forces your keys
07:36:02 <merijn> srk: Like the "now I need to explicitly list all major versions!" sure, that sounds annoying, but you can just do so "one at a time" as they're released and the effort to make that update is trivial, so it's really not that bad to keep up to date
07:36:04 <hseg> great!
07:36:08 <merijn> wavemode: eh, Strict is about values
07:36:11 <hseg> thought it was only spine-strict
07:36:13 <merijn> wavemode: Keys are *always* forced
07:36:18 <hseg> good
07:36:21 <merijn> hseg: Map is *always* spine strict
07:36:21 <wavemode> true
07:36:37 <merijn> hseg: strict vs lazy is about the values stored for each key
07:37:02 <hseg> ok. then should be able to get away with lazy afaict
07:37:28 <hseg> last q for now -- anyone written convolution for maps?
07:37:35 <merijn> srk: Same for the "I want to list other-modules as wildcard!" argument. Usually you add them one at a time, so it's trivial overhead. And that one time in your life you add a cabal file to a project with 100s of modules seems...rare enough to just suck it up
07:37:41 <srk> merijn: yup, I know and don't really find it difficult to maintain .cabal files - it's just automated adjustments would be easy (thanks to white space preserving Haskell parser that I can't remember the name of right now)
07:38:23 <merijn> srk: I don't object to tooling that helps update them, that's great, tbh
07:38:49 <hseg> i.e. (Eq k, Semigroup k, Semigroup u) => (v -> v -> u) -> Map k v -> Map k v -> Map k u
07:38:59 <merijn> srk: But I think the 15 million attempts to have "a minimal, all implicit, always correct" custom format are doomed to fail and just not worth it :)
07:39:10 <merijn> Because you can't have all 3 of those
07:39:16 <srk> I see :)
07:39:24 <merijn> And I'd always prefer "always correct" over the other two :)
07:39:30 <hseg> :) true that
07:40:07 <merijn> srk: Speaking of adjusting bounds, etc. did you know you can actually get an RSS feed of when your hackage bounds are too tight? :)
07:41:11 <hseg> only viable approach i see to writing convolutions is traversing one of the maps entry-by-entry, computing entry * other map, and folding the results
07:41:12 * hackage monad-dijkstra 0.1.1.3 - A monad transformer for weighted graph searches  https://hackage.haskell.org/package/monad-dijkstra-0.1.1.3 (ecramer)
07:41:37 <hseg> unless i'm missing something
07:41:52 <srk> merijn: via https://packdeps.haskellers.com/feed ?
07:41:57 <merijn> Yeah
07:42:17 <merijn> Underrated feature of the ecosystem :>
07:45:55 <hseg> iiuc, there's no performance difference between unioning m maps of size n and unioning n maps of size m?
07:48:14 <srk> merijn: yup, know about that one. pretty neat. where I'm aiming with this is something like recent dependabot effort but standalone built on top of nix, cabal-update, git / github
07:49:21 <hseg> http://ix.io/2qI1 checking my understanding of the containers API -- is this a good way of writing a convolution of maps?
07:49:40 <hseg> .. obvs that constraint should be Ord k
08:00:44 <dminuoso> Mmm, I wish postgresql-simple had an option to get binary format from postgresql instead. :(
08:01:31 <dminuoso> What kind of ergonomics would you prefer in postgresql-simple for this? libpq only allows binary/text for the entire query, not per field (contrary to the wire protocol, amusingly)
08:01:57 <hseg> heh. one thing my refactoring reveals: backpack bought me very little
08:02:29 <dminuoso> Some `queryBinary` with appropriate FromFieldBinary/FromRow typeclasses?
08:02:34 <dminuoso> *FromRowBinary
08:03:01 <nshepperd2> binary format of what?
08:03:13 <nshepperd2> ByteString fields?
08:03:58 <dminuoso> nshepperd2: Well you get a bytestring either way, but PQexec formats fields in a textual representation
08:04:12 <dminuoso> (Which is what postgresql-simple uses internally through postgresql-libpq)
08:04:31 <dminuoso> So for instance, if you have a cidr field, you get "10.1.1.1/24" rather than just 5 octets.
08:06:01 <dminuoso> (Or whatever the binary format postgres has for that)
08:07:00 <dminuoso> Sadly, if PGexecParams allowed specifying binary per-field, we could just have a Binary newtype wrapper.
08:07:09 <dminuoso> But it doesn't. :(
08:21:46 <hseg> hrm. given a newtype N k v = N (Map k v), why does ghc complain when i try to coerce :: (Map k v -> Map k v) -> (N k v -> N k v) without providing the types?
08:26:07 <comerijn> hseg: Well, without the types how is it supposed to know what the coercian is? :p
08:26:15 <hseg> :)
08:26:26 <hseg> forgot to note this is in a class method definition
08:26:40 <hseg> am defining fromNatural :: Natural -> N k v
08:27:18 <hseg> and context is fromNatural = coerce f . t where f :: Map k v -> Map k v, t :: Natural -> N k v
08:27:40 <hseg> would've thought that's enough for ghc to infer what types to apply coerce to
08:29:09 <Waldkauz> Does it really know the result type of t?
08:29:54 <hseg> why aren't type holes permitted in instance signatures?
08:30:02 <hseg> i'd think so, though
08:31:17 <hseg> ok, putting type hole on term worked, and yes ghc knows the output type
08:32:08 <hseg> so ghc has inferred (coerce f . t) :: A -> N k v, t is explicitly :: A -> Map k v, and f :: Map k v -> Map k v
08:32:38 <hseg> i'd've thought applying coerce @(Map k v -> Map k v) @(N k v -> N k v) would be the logical inference, no?
08:33:06 <hseg> but ghc complains Couldn't match representation of type â€˜v0â€™ with that of â€˜v1â€™
08:35:17 <hseg> in other annoyances, the fact that Map isn't applicative means I can't use traverseWithKey to define a convolution
08:38:01 <hseg> ok, need to go, be back in ~45m
08:45:45 <solonarv> hseg: well, it could also be coerce @(Map k v -> Map k v) @(N k1 v1 -> N k2 v2) for example
08:55:26 <dminuoso> hseg: Its MonoTraversable
09:02:54 <maerwald> who's on the iohk summit :>
09:03:40 <ja> where is that?
09:09:24 <frdg> has anyone here who uses haskell-mode in emacs run into the problem of constantly getting the error `The Haskell process 'projname' has died. Restart?`.  I have tried various things including explicitly adding the path to ghci to my `.emacs` and running `cabal install` from the emacs shell. 
09:13:39 <ddellacosta> frdg: I have had similar issues in the past and if I recall correctly it involved making sure I had set haskell-process-type correctly. Do your logs tell you anything more?
09:15:33 <ddellacosta> more on that here http://haskell.github.io/haskell-mode/manual/latest/Interactive-Haskell.html#GHCi-process-type
09:15:38 <ja> maerwald: it's actually the Cardano Summit, no? it's this one, right ? https://www.ubivent.com/register/cardanovirtualsummit
09:16:14 <ja> seems more business oriented as they don't mention the word 'haskell' at all, and they co-opt the term 'science'
09:16:56 <frdg> ddellacosta: https://pastebin.com/ddGUqaeT here is the log
09:18:39 <ja> how can redefining money (cryptocurrency) ever be science? it is about people's beliefs in the end, that is exactly what you can't use science for.
09:19:57 <ddellacosta> frdg: there is an issue here with a similar error message here, related? https://github.com/commercialhaskell/stack/issues/3590 also https://github.com/haskell/cabal/issues/5516
09:20:35 <ddellacosta> frdg: I'm going to guess something about your setup is provoking this message and preventing your repl from starting
09:20:53 <frdg> ok that link looks quite promising 
09:21:24 <ddellacosta> frdg: good luck--let us know what you figure out
09:26:58 <frdg> ddellacosta: Found the solution in one of your links. I had to set the `haskell-process-type` to `cabal-repl`. Im good to go now!
09:27:18 <maerwald> ja: no, there is a science track
09:28:52 <hseg> solonarv: fair. any way of making this less verbose?
09:29:05 <maerwald> Wadler is there too
09:30:40 <hseg> dminuoso: thanks. though i don't see an analogue of traverseWithKey for MonoTraversable 
09:33:05 <dminuoso> hseg: Ah mmm.
09:33:34 <hseg> i recall, i'm trying to make http://ix.io/2qIx work
09:33:50 <ddellacosta> frdg: awesome, glad to hear it!~
09:34:07 <hseg> though i'm not too excited about that approach, and if you have another idea i'd be glad to hear it
09:35:58 <amf> is there a way (on hackage or elsewhere) to see a list of a packages available type signatures for functions? looking to answer "is this typed used anywhere in the public api"
09:36:11 * hackage amqp-streamly 0.1.0 - A simple streamly wrapper for amqp  https://hackage.haskell.org/package/amqp-streamly-0.1.0 (gdifolco)
09:37:08 <ja> is henri tuhola of boxbase.org in here?
09:38:46 <hseg> suppose i could foldWithKey
09:38:59 <sheepfleece> Hello, say I have a value of type (Bool, [(Int, Bool)]), how can I write lens which would return [Int]?
09:39:37 <sheepfleece> I tried `each` and `traverse` but I only get scary error messages.
09:39:41 * hackage posplyu 0.1.0.1 - Sleep tracker for X11, using XScreenSaver extension and manual input.  https://hackage.haskell.org/package/posplyu-0.1.0.1 (SergeyAlirzaev)
09:39:45 <ja> sheepfleece: you can't, since the list could be empty, i think
09:40:01 <ddellacosta> [(1, True), (2, False)] ^.. (folded . _1)
09:40:08 <ddellacosta> sheepfleece ^ think that does it?
09:40:36 <hseg> ... q: is there some newtype wrapper for Map s.t. Semigroup v => Semigroup (Map k v) s.t. (<>) = unionWith (<>) ?
09:41:15 <ddellacosta> sheepfleece: oh sorry I missed the (Bool,  bit in the beginning, one sec
09:41:33 <ja> oh, i misread, i thought you wanted an Int and not an [Int]
09:42:28 <ddellacosta> sheepfleece: looks like this is one way, assuming I got your data structure right this time (Bool, [(1, True), (2, False)]) ^.. folded . folded . _1 
09:42:37 <ja> but i think my point about folds not being lenses still apply? https://hackage.haskell.org/package/lens-4.19.2/docs/Control-Lens-Fold.html#t:Fold "Unlike a Traversal a Fold is read-only. Since a Fold cannot be used to write back there are no Lens laws that apply."
09:43:02 <frdg> ddellacosta: Does haskell-mode have an ale like linter or is flycheck reccomended for this?
09:43:15 <ddellacosta> ja: oh, well, if we are being strict about terminology sure, I thought the question was more "how can I use the lens library to get an [Int] out of this"  
09:43:17 <ja> ^.. is short for toListOf, and toListOf is documented as working with Folds
09:43:46 <ddellacosta> frdg: I think I have flycheck wired up, but I'm not super knowledgeable about this, sorry!
09:43:56 <frdg> ok thanks
09:44:04 <ja> ddellacosta: yeah your answer is way more useful for sure :P but i think it is important to know the terminology, just to prevent all that time eventually wasted on people misunderstanding each other :P
09:44:19 <ddellacosta> ja, yeah definitely don't disagree
09:44:28 <sheepfleece> Ah, I see, thank you! I tried _2 . folded _1 and it didn't work.
09:44:40 <ddellacosta> sheepfleece: sure thing!
09:45:24 <sheepfleece> Is there a combinator which would transform lens into traversal?
09:45:42 <sheepfleece> So I could write (_2 . <combinator> _1)
09:45:47 <sheepfleece> and use (^.)?
09:46:10 <sheepfleece> Can I even use ^. with Traversals? I'm not sure.
09:46:18 <ddellacosta> sheepfleece: so to ja's point if we're talking terminology, lenses are valid traversals
09:46:37 <hseg> ok, monoidal-containers seems to do what i want here
09:46:43 <ddellacosta> traversals are not valid lenses however
09:48:17 <ddellacosta> I think there's ways to shoehorn them in with e.g. LensLike but we're getting out of my comfort zone with lens here
09:48:59 <ja> sheepfleece: there is a dedicated channel #haskell-lens too
09:49:59 <hseg> wtf does monoidal-containers need lens?
09:50:06 <ja> sheepfleece: i think this is the sin you are looking for http://hackage.haskell.org/package/lens-4.19.2/docs/Control-Lens-Traversal.html#v:partsOf
09:50:22 <hseg> well, at least dependency graph is somehow small
09:51:25 <ja> the optics book covers partsOf pretty well
09:52:05 <sheepfleece> Oh, it seems traverse . traverse == traverse
09:52:30 <hseg> mod newtypes
09:52:39 <hseg> ja: the optics book?
09:53:29 <ddellacosta> hseg: https://leanpub.com/optics-by-example
09:53:37 <hseg> ty
09:53:41 <ddellacosta> I also recommend it, has been very helpful to me 
09:53:51 <hseg> ooh, looks cool
09:54:24 <ddellacosta> I haven't even tackled much more than half of it but it's paying huge dividends. There's not a lot of Haskell books I recommend but this and Graham Hutton's are at the top of the list
09:55:33 <ddellacosta> also want to check out Sandy Maguire's type-level programming book one of these days, heard good things
09:56:27 <sheepfleece> I didn't really like it, it was terse and with almost no explanations.
09:56:36 <ddellacosta> sheepfleece: which, the type-level programming book?
09:56:38 <sheepfleece> Yes
09:56:45 <ddellacosta> I can imagine how that would be the case
09:56:52 <ddellacosta> seems like a really tricky thing to explain
09:58:47 <ja> sometimes i get the impression that type-level programming in haskell is just a giant hack and it'll be deprecated with dependent types anyway... and then other days i force myself to consider that haskells ecosystem is larger than idris'es and i should accept the pain
09:59:46 <ja> like being a teenager all over again! can't decide whether to grow up or not :P
10:00:12 <hseg> heh. and some days i try to get fancy with my pretend-dependent types and remember haskell only pretends to have dependent types
10:00:21 <ddellacosta> ja: yeah it seems like it kind of depends (ha) how you think about it. Like, if you think of Haskell's advanced type system features as augmentations and extensions of the core, it's kind of different than if you're looking for a comprehensive, designed-from-the-ground-up dependently typed language
10:00:39 <ddellacosta> that said, I'm not super familiar with type-level programming so ymmv 
10:01:55 <dolio> I think if you're thinking about 'type level programming,' you're probably doing something wrong.
10:02:30 <ddellacosta> dolio: why's that/how so?
10:05:42 <dolio> Because if you are, you're doing something too complex to be nice in GHC. I use plenty of the features, but they are for relatively small conveniences. By the time you start to think of what is going on at the type level as a full-fledged 'program', you have something that is generally difficult to use, brittle, etc.
10:05:51 <ameiners> isnt typelevel programming kind of the whole point of haskell?
10:06:05 <ddellacosta> dolio: gotcha, thanks
10:06:39 <hseg> ameiners: not really
10:07:13 <hseg> basic haskell is lambda calculus + patterns + typeclasses
10:07:19 <ja> this kinda sounds like the argument for/against tactics. if you want a robust proof, you'd argue for tactics. if you want a clear and concise proof with no 'magic', you wouldn't want tactics
10:07:27 <hseg> everything else is sugar
10:07:30 <ameiners> I'm pretty new so I'm probably completely misunderstanding but when you are talking about typelevel is that different than working with ADTs?
10:07:34 <hseg> + extensions
10:08:06 <ameiners> Or is typelevel programming more like template or metaprogramming?
10:08:11 <dolio> ameiners: Yes. It means doing non-trivial computation during type checking with various language extensions.
10:08:37 <ddellacosta> ameiners: I mean, I think one problem is that it's somewhat ambiguous, but if you look at the table of contents here it gives you a feel for what folks mean when they say "type-level programming:" https://thinkingwithtypes.com 
10:09:04 <ameiners> Ah. That makes things a lot different then! I'm still working my way through the Haskellbook so I've just started really exploring declaring my own custom types
10:09:58 <hseg> dolio: so you give up on doing type-level computation?
10:10:20 <ja> ameiners: i think your intuition is correct. types are propositions, your programs are proofs. it would be nice if your domain allows for simple propositions, but that is often not the case
10:10:51 <ja> dependent types allows you to talk about propositions in a more flexible manner, which can be harder to use
10:12:44 <ja> you can't do proper proofs very well if you don't have the expressive power, that is why people do proofs in coq and not in haskell
10:13:23 <ja> so to me, dolio's argument sounds like "proofs are complicated, let's not do that"
10:14:06 <dolio> hseg: It usually doesn't seem worth it to me to do anything that complicated, because it doesn't work well. And there are regularly people in here strugging with trying to use such things. For instance, you were the other day, with trying to `map` on an aribtrary number of constraints or something.
10:14:57 <hseg> yeah. the constraints thing could very well have been served with some other mechanism
10:14:57 <wavemode> it's not just about proofs being complicated, it's that they're unnecessary for the vast majority of real-world software
10:15:17 <hseg> more fundamental to my use case was the fact that i needed length-indexed vectors
10:15:31 <hseg> and the associated type-level nat machinery
10:15:52 <ja> but can you really assume that a haskell programmer is writing real world software? now we are back to that old discussion about whether haskell is really for research or not ;)
10:16:14 <dolio> I am writing real world software.
10:16:34 <ja> are people proving the four colour theorem writing real world software?
10:16:47 <dolio> No.
10:16:54 <dolio> They are doing mathematics.
10:16:55 <ddellacosta> so, at what point does a Haskell program become a proof? Early on learning I remember reading statements from folks where any given function was a proof, etc.
10:17:29 <wavemode> I view haskell itself as a research project, but it's a research project to create a general-purpose programming language
10:18:04 <wavemode> many decisions in haskell were made on the basis of elegance and ergonomics, for that reason
10:18:31 <dolio> Anyhow, proofs _are_ hard even in languages that are good for them, and GHC isn't really good for them. And it seems like people often try to do more complicated things in GHC than they actually do in e.g. Agda.
10:19:35 <dolio> Perhaps that is somewhat disguised, though, because the complicated things in GHC are complicated by virtue of it being bad for them.
10:21:46 <dolio> And I don't mean that as a knock on GHC. It's just wasn't designed for them like Agda/Idris is.
10:24:19 <ja> but it _was_ designed for correctness! it's just that people didn't know that it would have been a good idea to put totality in the type system
10:24:44 <ja> so now we have people asking questions like ddellacosta because haskell's type system only *almost* is suitable for doing proofs
10:25:11 <EvanR> i heard totality came up and was like "yeah... we have enough going on"
10:25:21 <dolio> It is not suitable.
10:25:39 <EvanR> back in the 80s
10:26:35 <ja> so do you want people to talk about haskell the way you thought it was meant to be? or do you want people to use haskell the way it actually is?
10:27:06 <ja> given that the language is pretty much officially going in the direction of dependent-types, how could anyone be faulted for trying to do "type-level programming"?
10:27:17 <ameiners> I'm learning Haskell to play around with as I'm a Software Engineer (working in Java for now) but I would enjoy using it professionally for real-world applications.
10:28:10 <ja> ameiners: and if your real world application hangs because of infinite recursion, isn't that a problem? ;)
10:28:14 <ameiners> Also know several people working with Haskell professionally as a BE component
10:28:14 <sm[m]> welcome ameiners, yes indeed :)
10:28:30 <dolio> It doesn't have dependent types, and the stuff it has isn't very good at faking dependent types, compared to actual languages with dependent types.
10:28:46 <EvanR> i suspect haskell in a work setting would be amazing
10:28:51 <ameiners> If an application hangs because of infinite recursion it seems like a programming error not a language flaw
10:29:24 <ja> ameiners: if you have totality in the type system, that programming error is less likely to happen
10:29:47 <EvanR> ja, have you worked on a serious piece of total software
10:30:00 <EvanR> in some language that supports it
10:30:20 <ja> EvanR: a function can be total even if the type system does not allow asserting it ;) so yes
10:30:32 <EvanR> so no
10:30:38 <ja> EvanR: i have also written constexpr, they are total, and enforced in the type system
10:31:32 <maerwald> that's like saying you can write pure functions in C
10:31:43 <maerwald> yes you can, but so what
10:31:47 <ja> i think when i worked with MySQL 3.23 it didn't have recursive functions yet, so that was total too
10:32:26 <EvanR> yeah SQL doesn't get enough respect. 
10:34:03 <ja> maerwald: how is constexpr not a lot better than C? it is compile-time enforced
10:34:31 <maerwald> You missed the point :p
10:37:19 <ja> maerwald: what is the point?
10:37:38 <ameiners> I've been writing recursive CTEs in MariaDB :(
10:39:30 <maerwald> "I can write total functions in language X" doesn't mean the language is total.
10:40:35 <maerwald> And that difference is important, otherwise there would also be no reason to fancy purity on language level
10:41:05 <ja> but most languages have languages embedded in them, it is common to speak about a subset. if you interpret "SQL" as "ANSI-SQL:2008" people will look at your weirdly. they expect to give you an answer that works in at least one of the big SQL implementations
10:43:10 <ja> if you use "let rec" in ocaml where "let" would do, people look at you weirdly
10:49:13 <ja> so how can you dismiss me when i saw that constexpr is total just because it is embedded in C? if i launch an total awk subprocess, do you consider that part of the calling program? every program is embedded in another program, so why can't constexpr be considered a language embedded in C++?
10:54:13 <ja> arbitrary distinctions: proofs/programs, propositions/types, languages/sublanguages, subprocesses/programs
10:54:48 <EvanR> we can use arbitrarily fancy abstractions in assembly language
10:54:50 <EvanR> totally works
10:55:58 <EvanR> but it provides no help. On the other hand, general purpose programming language with a framework to check your totality is a different beast i think
10:56:35 <EvanR> if you try to make sure every aspect of your application is total, i think you'll run into difficulty
10:57:13 <EvanR> a small DSL sublanguage is much easier
10:59:44 <ja> right, happy you agree with me that totality annotations make sense ;)
11:02:15 <EvanR> sure, but totality checkers aren't smart enough for general code
11:02:18 <EvanR> at this point
11:03:05 <monochrom> There is a whole spectrum. Some languages are a total lockdown. Some others don't lock down but designed to make easy the static analysis for "which part of your code satisfies the safety property" (type systems being the easiest extreme here). The rest are too flexible to the point even static analysis is too difficult.
11:03:07 <EvanR> on the other hand, annotation that says 'the function may crash or loop!' seems really weird
11:03:41 * hackage knit-haskell 0.8.0.0 - a minimal Rmarkdown sort-of-thing for haskell, by way of Pandoc  https://hackage.haskell.org/package/knit-haskell-0.8.0.0 (adamCS)
11:04:45 <monochrom> Haskell for example will soon have types assuring linearity, while not forcing linearity everywhere.
11:05:21 <monochrom> I could also say that of effectless, but maerwald would ruin it by reminding us of backdoors.
11:07:30 <ja> EvanR: so you think the keyword 'total' should be removed from Idris? http://docs.idris-lang.org/en/latest/reference/syntax-guide.html?highlight=total#totality don't you think that would make the proofs less useful?
11:07:41 <EvanR> backdoors, trapdoors, etc are cool. But it would be cool for the compiler to tell you when a body of code contains them or not
11:08:04 <monochrom> I also want to remind that a lot of safety properties we care about today are not readily susceptible to typing, at least not without 5-10 more years of research.
11:08:33 <monochrom> However! They are readily susceptible to static analyses.
11:08:43 <ja> EvanR: or if not 'total', then 'partial'?
11:09:11 <EvanR> idris's totality system is a good try, A for effort
11:09:55 <ja> how are you consistent now? you just said the annotation would "seem really weird"
11:10:38 <EvanR> an annotation that says "this code may crash, or loop" like, this is how you shipped it to the end user
11:13:26 <EvanR> while it may point out a political reality we all live with by default in all code, and serves as satire, is it technically useful
11:15:23 <ja> syntax is never useful, it is a means to an end
11:15:45 <monochrom> annotation for "possible X" is, on the flip side, also implied annotation for "necessary not X"
11:16:24 <ja> given the choice between functions that are partial per default, or functions that require you to be satirical, i would prefer the satirical ones
11:16:46 <monochrom> Your only choice in this complementarity is which one you say out loud, and therefore the other one you say out silently.
11:17:50 <EvanR> ok I see real functions designs to be crashy on purpose. The scientific functions for converting a rational to scientific, 'better not pass in 1/3'
11:18:25 <EvanR> it says in the docs, and we have no in language way to advertise it.
11:18:26 <monochrom> Culturally (and for no technical merit), we prefer saying out loud "necessary terminates", we don't feel like being silent on that and saying out loud instead "possible non-terminates", of course.  But know that the two styles are equivalent.
11:20:55 <EvanR> here's another weird one, code is not 'known' to always terminate, but some programmer somewhere does 'know' it always terminates but can't convince the computer of the fact, or convincing would take unreasonable resources
11:21:15 <EvanR> so if you put 'partial' or something, it would be misleading
11:22:14 <EvanR> and 'could crash or loop!' might even be wrong in an absolute sense
11:22:20 <ja> now you are talking syntax again. on the internet, nobody knows your a dog. in a collaborative software project, nobody can trust the code you committed is correct, unless you have proven it
11:22:40 <ja> 'partial' means: 'may not be total'
11:22:44 <EvanR> i haven't been talking about syntax at any point
11:23:21 <ja> yes, because we are taking about a keyword. keywords are syntax
11:23:31 <EvanR> heh, if you don't convince the computer of some fact, it's not necessarily true yet?
11:23:44 <EvanR> i'm talking about the meaning behind some english words
11:24:19 <ja> depends whether you are a constructivist or not, i guess ;) generally software people tend to become constructivists if pressed
11:24:22 <EvanR> 'could crash or loop!' is something you ought to have to prove too
11:24:31 <EvanR> which would require an example situation
11:24:41 <monochrom> That can be easily improved by modalities, in particular adding more modalities.  You can have levels of: "proved X", "<programmer name and signature here> asserted X but not proved", and "no one has worked on this at all".
11:24:56 * ski . o O ( s/could/might/ ? )
11:25:15 <EvanR> could means can, i don't know what might is
11:25:18 <monochrom> I think I actually heard of a system in use that has the "<name and sig> asserted X" level.
11:25:26 <EvanR> i like that idea monochrom 
11:25:28 <MarcelineVQ> partial, covering, total.   I dunno, looks okay, probably okay.
11:26:33 <monochrom> This is why programmers need to learn more about modal logic(s). Instead of spending so much time on Curry Howard.
11:27:11 <dolio> There is Curry-Howard for modal logics.
11:27:38 <MarcelineVQ> curry-howard-lambert-the-sheepish-lion
11:28:20 <phadej> modalities are often monads or comonads, you can use them already today in Haskell, (for the price of some inconvenience)
11:28:50 <monochrom> Because once you accept that most of your time is spent on considering what your software may do, should do, known to do, conjectured to do, (a few more levels of certainty), rather than writing the code, you see that by logical conclusion most of your time is spent using modal logic(s).
11:28:59 <ski> analyses commonly have a "we know X !" vs. "we don't know anything" dichotomy
11:29:28 <dolio> You don't get modal type theory just by using monads/comonads in Haskell.
11:31:21 <EvanR> yeah 'partial' effectively means 'we don't know anything' in idris
11:32:08 <monochrom> Dichotomies are the root cause of boolean blindness.
11:34:05 <ja> EvanR: let's say you prove a function divergent. what can you do with that proof? why would anybody spend their time on making these proofs instead of using their time for making proofs of totality? if you fail in making the proof of divergence, you don't know that the function is total. whatever the outcome of that endavour, it is fruitless!
11:34:53 <monochrom> I can learn from that proof how to prove some more programs divergent.
11:34:59 <phadej> dolio: depends on modalities, whether they can be modelled in Haskell (to some approximation).
11:36:24 <monochrom> And it is of use because when I am not sure whether a program converges or diverges or "depends on CH", but suppose I want to find out and be sure, it is best to try both proving convergence and proving divergence.
11:37:15 <monochrom> Especially true if you replace me by an automated verification algorithm.
11:38:07 <monochrom> Extra especially true if, when you cover divergence to be a bug, the proof of divergence helps narrow down the cause of the bug and help you fix the bug.
11:38:17 <monochrom> s/cover/consider/
11:40:13 <monochrom> Look at for example the model-checking people. They don't just verify for "we are certain this safety property holds", that's the easy part. All the ongoing research work is "if we aren't certain, how about a counterexample?".  It is the practical programmers themselves that demand the counterexamples, because how else are you going to debug this thing.
11:41:16 <monochrom> Recall that "counterexample" here now means proof of violation. So yes we very much are interested in proofs of divergence, this is totally useful not useless.
11:56:41 <hseg> how much overhead does mono-traversable add?
12:00:00 <hseg> nm, misread mono-traversable source -- looked like it was reimplementing some containers code
12:00:08 <hseg> but that's just for the default implementations
12:04:53 <Vasanpeine> Hi, does anyone know why the following code typechecks (without any language extensions) ?
12:04:56 <Vasanpeine> foo :: Intfoo = do  let x = 2  let y = 3  x + y
12:05:12 <Vasanpeine> foo :: Int
12:05:16 <Vasanpeine> foo = do
12:05:20 <Vasanpeine> let x = 2
12:05:23 <Vasanpeine> let y = 3
12:05:25 <Vasanpeine> x + y
12:06:01 <monochrom> the do-notation desugars to: let x=2 in let y=3 in x+y
12:06:03 <ski> @undo foo = do let {x = 2}; let {y = 3}; x + y
12:06:03 <lambdabot> foo = let { x = 2} in let { y = 3} in x + y
12:06:17 <Vasanpeine> But is this valid Haskell 2010 w.r.t to the Report?
12:06:27 <monochrom> even back to Haskell 98
12:06:51 <Vasanpeine> I understand the desugaring rules but presumed that A monad constraint is always needed for a do block
12:07:04 <wavemode> no, do notation is purely syntactic sugar
12:07:06 <monochrom> The Reports say no.
12:07:11 <Vasanpeine> ok, thx
12:07:15 <wavemode> in fact, do notation can mean whatever you want with RebindableSyntax
12:07:57 * ski . o O ( dynamic syntax bindings )
12:08:31 <rotaerk> https://gitlab.haskell.org/ghc/ghc/-/merge_requests/3436
12:19:43 <solonarv> Vasanpeine: generally, if you want to know whether/why a piece of syntax-sugar-using code typechecks, you can desugar it first and *then* typecheck
12:20:00 <solonarv> GHC actually typechecks before desugaring, but that's just for better error messages
12:23:08 <koz_> 'GHC actually typechecks before desugaring' <-- because the type checker deserves some sweet treats too!
12:23:54 <Vasanpeine> I was reading about the different algorithms for applicative do desugaring, and I always thought it works in the following way: GHC generates a constraint for a do-block (Monad or MonadFail) before desugaring, precisely because of error reporting. But apparently it is the other way around.
12:25:39 <monochrom> But I like desugared grape juice more.
12:27:43 <dolio> It does infer without desugaring (I think), but it infers the same type that you would get by desugaring first.
12:32:25 <solonarv> yep, that's what I was getting at
12:38:08 <Vasanpeine> Besides "Desugaring Haskellâ€™s do-notation Into Applicative Operations" and "A New Notation for Arrows", does anyone know any other references for trying to relate extensions of do notation to our typeclass hierarchy. For example, is there something for selective functors?
12:39:58 <Vasanpeine> Sorry, i meant "â€œType and Translation Rules for Arrow Notation in GHCâ€,"
12:44:02 <phadej> I don't recall there is any other extension to do-notation than ApplicativeDo
12:45:56 <Vasanpeine> For example this: http://downloads.haskell.org/~ghc/7.8.4/docs/html/users_guide/arrow-notation.html
12:46:14 <Vasanpeine> I haven't seen it used in the wild before, though
12:47:10 <phadej> this is arrow notation, not do-notation
12:47:25 <phadej> though there is `do` in arrow notation too
12:48:01 <Vasanpeine> I just wondered whether there is some more comprehensive overview of trying to relate classes of computational effects (Applicative, Monad, Arrow etc)  to do / arrow like notations.
12:48:39 <phadej> I don't understand what you mean by that
12:48:40 <Vasanpeine> Not necessarily implemented in GHC
12:49:59 <Rembane> Vasanpeine: Like the table here but more? https://en.wikibooks.org/wiki/Haskell/Understanding_arrows#Arrow_combinators_crop_up_in_unexpected_places
12:51:02 <Vasanpeine> Yes, that is something what I'm looking for. 
12:51:23 <adamCS> acowley: Have a sudden problem compiling frames (tried ghc 8.8.3 and 8.8.2 and frames-0.6.4, frames-0.6.3, frames-0.6.2).  Error msg: https://gist.github.com/adamConnerSax/bb4d319e24f2e5dd4ff6d3b73de6eb41
12:52:19 <adamCS> acowley:  Could very much be a problem on my end, but I tried just doing "cabal new-install frames" in an empty directory and I get that error.
12:52:58 <Vasanpeine> For example, has someone thought about extensions to do notation which correspond to Alternative or MonadPlus.
12:53:15 <Rembane> Vasanpeine: What would those extensions do?
12:53:47 <phadej> adamCS: it might be related to the newer `vinyl`
12:54:12 <Vasanpeine> Ideally, desugar to <|>, mplus etc :)
12:54:16 <adamCS> phadej: Ah.  That would fit it's onset being a "cabal new-update" (among other things).
12:54:34 <phadej> let me see if I can reproduce it
12:54:35 <adamCS> phadej: Do I just restrict vinyl back a version for now?
12:55:30 <phadej> yes, I think that http://hdiff.luite.com/cgit/vinyl/diff?id=0.12.3&id2=0.12.2 changes were actually breaking for many users
12:56:14 <phadej> so I'd say that vinyl-0.12.3  should have been 0.13
12:56:25 <adamCS> phadej: Should vinyl pull that version and..yeah that's what I was typing!
12:56:45 <adamCS> Yeah, now frames compiles.
12:58:09 <adamCS> phadej: Thanks!
12:58:15 <phadej> I guess I'll blacklist that release and inform the maintainer
12:58:20 <phadej> if it doesn't happen to be you?
12:58:31 <adamCS> phadej: nope!
13:00:29 <phadej> do you mind opening issue for Frames that it fails to compile with vinyl-0.12.3 (it's easier for me as Hackage Trustee to not be "primary reporter")
13:00:41 <adamCS> phadej: Sure!
13:01:02 <phadej> great, thanks
13:01:27 <frdg> I am trying to use ghcid. I run it by running `ghcid -c cabal v2-repl exe:myProject`. This only compiles one module though even though I have many modules specified in my `.cabal` file. From here it says `all good` but never updates even after I save a file that is part of the project.
13:03:50 <monochrom> I think you still need to say which file to watch.
13:04:20 <phadej> frdg: ghcid doesn't reload if you change modules in other component (say library)
13:04:23 <adamCS> phadej: Issue submitted. I think acowley is a maintainer/author of both vinyl and frames?  He is last uploader of both on hackage... 
13:04:38 <phadej> yes, looks so
13:09:48 <phadej> I made revision(s), will soon post on the issue
13:10:15 <frdg> phadej: I get it now. Thanks
13:17:08 <Aquza> hello i have a question about the argument parser https://github.com/pcapriotti/optparse-applicative. There is the option "option auto" where you can set a default double or int value. I was trying to make this possible with String but i couldnt make it run. Is there a way to do this?
13:17:40 <phadej> use option str or strOption
13:26:57 <Aquza> thanks phadej 
13:27:07 <phadej> np
13:32:11 * hackage dobutokO-effects 0.4.0.0 - A library to deal with SoX effects and possibilities  https://hackage.haskell.org/package/dobutokO-effects-0.4.0.0 (OleksandrZhabenko)
14:33:11 * hackage servant-quickcheck 0.0.9.0 - QuickCheck entire APIs  https://hackage.haskell.org/package/servant-quickcheck-0.0.9.0 (MatthiasFischmann)
14:42:17 <dminuoso> Im looking at profiling data, and one cost center is the newtype field https://hackage.haskell.org/package/optics-core-0.3/docs/Optics-Internal-Optic.html#v:getOptic
14:42:23 <dminuoso> There's nothing beneath that, why might that be?
14:42:42 * hackage servant-multipart 0.11.6 - multipart/form-data (e.g file upload) support for servant  https://hackage.haskell.org/package/servant-multipart-0.11.6 (MatthiasFischmann)
14:42:59 <dminuoso> Is that because of missing cost centers, and the real cost is running optics profunctor transformations?
14:43:25 <dminuoso> (Because I would like to think that a newtype field accessor cannot incur any cost)
14:45:12 <dolio> Seems likely.
14:48:39 <dminuoso> Why is there something to attach a cost center to at all?
14:51:31 <sm[m]> frdg: stack/cabal don't support this well, but you can look at the ghci command they run and modify it to include all your packages. make ghcid in the hledger project does this
14:52:24 <sm[m]> dangit you left. At least I can see that in Riot now.
15:04:57 <maerwald> dminuoso: might be a bug
15:05:53 <maerwald> https://gitlab.haskell.org/ghc/ghc/-/issues/18374
15:06:41 <maerwald> dminuoso: https://github.com/well-typed/optics/pull/325/files
15:42:11 * hackage servant-js 0.9.4.2 - Automatically derive javascript functions to query servant webservices.  https://hackage.haskell.org/package/servant-js-0.9.4.2 (MatthiasFischmann)
16:48:30 <DH27> Hi. Is this the correct place for assistance with ghcup/ghc?  
16:49:12 <Cale> DH27: yeah
16:50:29 <DH27> Ran ghcup to install 8.10.1 from 8.8.3 which was successful. However, running ghc yielded:> $ ghc> dyld: Library not loaded: @rpath/libHShaskeline-0.8.0.0-ghc8.10.1.dylib>   Referenced from: /usr/local/bin/ghc>   Reason: image not found> Abort trap: 6I had used ghcup awhile back to install 8.8.3 just fine. To be sure, I attempted: ```ghcup rm
16:50:29 <DH27> 8.10.1 && ghcup install 8.10.1 ```It reinstalled successfully but the issue remained. I don't know the compiler enough or how it links libraries in order to interpret the above message and resolve the issue.
16:50:48 <DH27> That is a mess. Let me send it in a different format. Sorry. 
16:51:20 <DH27> Ran ghcup to install 8.10.1 from 8.8.3 which was successful. When I ran ghc I got the following message:
16:51:33 <DH27> dyld: Library not loaded: @rpath/libHShaskeline-0.8.0.0-ghc8.10.1.dylib
16:51:39 <DH27> Reason: image not found
16:52:03 <DH27> I had used ghcup awhile back to install 8.8.3 just fine. I don't know the compiler enough or how it links libraries in order to interpret the above message and resolve the issue.
16:53:20 <Cale> hmm
16:53:39 <Cale> Personally, I'm not sure, but probably should post an issue here: https://gitlab.haskell.org/haskell/ghcup-hs/-/issues
16:54:43 <Cale> Presumably that haskeline dynamic library isn't being installed properly of course, but I don't know why it wouldn't be
16:56:28 <DH27> Seems like it. Ill open an issue.  
17:55:34 <crestfallen> hi
17:56:11 * hackage CouchDB 1.2.3 - CouchDB interface  https://hackage.haskell.org/package/CouchDB-1.2.3 (GaneshSittampalam)
18:12:52 <Grif> Heyo! Does this channel get used much?
18:13:25 <crestfallen> Grif very active
18:13:41 * hackage redis 0.14.2 - A driver for Redis key-value database  https://hackage.haskell.org/package/redis-0.14.2 (GaneshSittampalam)
18:15:47 <crestfallen> :{
18:16:06 <crestfallen> oops
18:16:32 <Grif> Neat! I'm looking to get more into the community and this looks like the right place to be
18:16:58 <crestfallen> people are quiet because I'm rather thick-headed :)
18:19:42 <Grif> it is odd to see ~1100 people this quiet
18:20:27 <Cale> It's been a little quiet today
18:21:06 <crestfallen> hi Cale   << Grif this person is a helpful genius
18:21:18 <Cale> hi
18:21:32 <Grif> Heyo!
18:22:01 <ChaiTRex> Grif: It's due to the time of day, I think. It was more active five to ten hours ago.
18:22:29 <Grif> Makes sense
18:23:10 <crestfallen> Cale I was going over the evaluation of filterMM et al
18:23:21 <crestfallen> it's rather tricky
18:23:45 <crestfallen> but some of your comments about 'trust' were interesting
18:24:17 <Cale> Ah, about trusting that a recursive function is going to work on smaller inputs?
18:25:19 <crestfallen> yeah, regardless of evaluation order
18:25:56 <crestfallen> the sections with concat were weird
18:26:13 <crestfallen> in the actual pasted evaluation
18:26:15 <Cale> Yeah, evaluation order doesn't really matter anyway unless you're trying to reason about performance. If all you care about is what value you get, you shouldn't need to worry about which order things are evaluated in
18:26:27 <Cale> Yeah, that was a bit of a leap that I took
18:26:46 <Cale> For the list monad, xs >>= f = concat (map f xs)
18:27:50 <crestfallen> but we can use join as well? wait, doesn't join - implicit in (>>=), cover the flattening?
18:28:10 <Cale> join is concat for the list monad also
18:29:33 <crestfallen> yeah I went through unification of join >>= id    .    that was excellent
18:30:08 <crestfallen> oh, incorrect
18:31:10 <crestfallen> no, correct
18:31:44 <crestfallen> eager to get your take on the State Monad Cale
18:33:45 <Cale> Ah, sure
18:34:27 <crestfallen> thanks ! this is the hutton code with some notes    http://ix.io/2qK2     http://ix.io/2qK3
18:36:55 <Cale> So, we want to represent computations which depend and act on a state value of type s before producing some result of type a. There are a bunch of different ways that we could approach that, but since we're in a functional programming language, representing such things using functions of type s -> (s,a), that is, functions which take an initial state of type s, and produce a pair of the final state and result, will end up being fairly 
18:36:55 <Cale> convenient.
18:37:31 <Cale> In order to be able to build up some abstraction around this though, we'll use a newtype:
18:37:47 <Cale> newtype State s a = S (s -> (s,a))
18:38:24 <Cale> and because of our choice of representation, the function to run such a thing on an initial state and get the final state and result will be super-easy:
18:38:33 <Cale> runState :: State s a -> s -> (s,a)
18:38:43 <Cale> runState (S f) s = f s
18:38:48 <Cale> or simply:
18:38:51 <Cale> runState (S f) = f
18:39:18 <crestfallen> thanks I'm comparing that to some other stuff I have
18:39:52 <Cale> We can also build that into the definition of the type, by making use of the fact that if we use record syntax, we automatically get functions which extract the fields:
18:40:04 <Cale> newtype State s a = S { runState :: s -> (s, a) }
18:41:07 <Cale> This will automatically define the field extractor function, which will take a value of type State s a, and extract the field of type s -> (s,a) from it
18:41:20 <Cale> i.e. runState :: State s a -> s -> (s,a) as before
18:42:11 <crestfallen> field extractor and record syntax, actually terms I'm new to..
18:42:23 <Cale> That part isn't essential
18:42:35 <crestfallen> I've seen newtype State s a = S { runState :: s -> (s, a) }  before
18:42:59 <Cale> Right, so that defines it as a record having one field called runState
18:43:21 <Cale> and as such, you automatically get a function called runState which will extract the field from the record
18:43:43 <Cale> Just as if you'd defined  data Employee = Empl { name :: String, salary :: Int }
18:43:55 <Cale> it'd automatically define  name :: Employee -> String
18:44:01 <Cale> and  salary :: Employee -> Int
18:44:38 <crestfallen> so yeah State is dawning on me over time, even with the dummy constructor and then defining app to rid us of the dummy constructor...     yes, those last posts are helpful
18:45:35 <crestfallen> so the field is the entire tuple , (s,a) correct?
18:45:47 <Cale> No, it's a function of type s -> (s,a)
18:47:53 <crestfallen> one moment please
18:48:08 <Cale> no problem
18:49:44 <crestfallen> so the note I have at the top of module StateMod, "Many things in haskell are just complicated ways to talk about state"
18:50:40 <crestfallen> I worked with s.ki on a ticker program, let me fetch it...
18:51:53 <crestfallen> http://ix.io/2qK5
18:53:20 <crestfallen> so I see how those functions work (tick, ticker, evenTick) however ...
18:54:03 <crestfallen> I don't quite understand the purpose of them, particularly ticker
18:54:24 <crestfallen> evenTick is straightforward..
18:58:39 <Cale> Well, all this is of limited usefulness, but eventually it'll be a building block for useful things
18:59:42 <crestfallen> ok, yeah , how ticker returns ([5,6,7],8) there is cool, but I'm not too clear on the purpose
18:59:56 <Cale> Our first goal will be to get away from having to use the S constructor by building up enough basic operations for reading and writing the state and chaining together actions of type State s a
19:00:17 <Cale> So, we might start with get and put
19:00:38 <crestfallen> ok, warning never used get and put :)
19:00:57 <Cale> get :: State s s  will be a computation which won't affect the current state (i.e. its final state will be the initial state), but will have that state as its result as well
19:01:06 <Cale> Want to try writing it?
19:01:46 <crestfallen> s -> (s,s)
19:02:02 <crestfallen> runState :: s -> (s,s)
19:02:23 <Cale> Uhh, that'll be the type of the runState field
19:04:12 <crestfallen> tick = S (\n -> (n,n))
19:04:33 <Cale> Or you mean  get = S (\n -> (n,n)) ?
19:04:43 <Cale> Yeah, that'll do it
19:05:03 <Cale> We don't have many ways yet to make values of type State s a apart from using S
19:05:12 <Cale> So, we might as well use it:
19:05:14 <Cale> get = S ...
19:05:15 <crestfallen> nontick :: ST Int; nonTick = S (\n -> (n,n))
19:05:37 <Cale> and then, in this case, its argument has type s -> (s,s), so it might as well be a lambda
19:05:41 <Cale> get = S (\s -> ...)
19:06:02 <Cale> and then we have a value s :: s, and we want to produce a pair of type (s,s), so there's one obvious thing to do
19:06:05 <Cale> get = S (\s -> (s,s))
19:07:45 <Cale> To go along with that, we'll want  put :: s -> State s ()
19:08:22 <crestfallen> So the () is that like unit?
19:08:44 <Cale> which, given a value of type s, will produce the State action that, no matter what value the initial state was, will set the current state to the given value
19:08:50 <Cale> (and produce an empty tuple)
19:11:05 <crestfallen> is that related to:    f = runState (return 'X') 1
19:11:15 <crestfallen> ('X',1)
19:11:30 <Cale> In what way?
19:13:29 <crestfallen> well, first of all, are we on (a,s) or (s,a)  ?
19:15:02 <crestfallen> sorry I don't know what's happening
19:15:35 <Cale> Well, I gave the definition newtype State s a = S (s -> (s,a))
19:16:16 <Cale> But obviously, it doesn't really matter which order the pairs are in, so long as we know which way around they go
19:18:11 <crestfallen> ok thanks, so far in the hutton code, what corresponds with get and put?
19:18:39 <Cale> I doubt Hutton calls them any differently
19:19:17 <crestfallen> in the section on applicatives/monads, I haven't come across get/put yet
19:19:37 <Cale> That's fine
19:19:39 <Cale> I'm introducing them
19:19:47 <crestfallen> ok
19:21:22 <Cale> Want me to write put?
19:21:36 <crestfallen> Cale re: your above comment " Our first goal will be to get away from having to use the S constructor by building up enough basic operations for reading and writing the state and chaining together actions of type State s a "
19:21:47 <Cale> yeah
19:21:51 <crestfallen> ok so..
19:22:05 <Cale> So, get will be a thing that "reads" the current state, and put will be a thing that "writes" it
19:22:26 <crestfallen> hutton is using a state transformer with this construction S the dummy constructor
19:22:54 <crestfallen> are we trying to not use the ST model?
19:23:06 <Cale> I introduced everything we need
19:23:10 <Cale> I'm not using his stuff
19:23:10 <crestfallen> ok
19:23:14 <crestfallen> ok
19:23:19 <Cale> It's very very similar though
19:23:51 <crestfallen> because many folks don't like the ST business, since it looks like other stuff
19:26:49 <crestfallen> btw I didn't mean "ok so" as in "so what".. I was continuing my train of thought..  :)
19:27:26 <Cale> Shall I write put, or do you want to try?
19:27:41 <crestfallen> one moment please..
19:35:59 <crestfallen> a hint please Cale, am I working on something similar to execState ?
19:36:30 <crestfallen> as in : State s a -> s -> s
19:37:34 <Cale> no
19:37:42 <Cale> put :: s -> State s ()
19:38:05 <Cale> and the goal is that after running  put v  the final state will be v, regardless of what the initial state was
19:41:39 <crestfallen> put val = S (\s -> (val,val))
19:41:55 <crestfallen> put s val = S (\s -> (val,val))
19:42:12 <Cale> The first one is close
19:42:29 <Cale> But remember that the result is supposed to have type State s ()
19:42:36 <Cale> So, the result has to be ()
19:42:52 <Cale> The new state indeed can be val like that
19:43:00 <Cale> and s, the initial state, is ignored
19:45:27 <crestfallen> put val = S (\s -> ((),val))
19:45:53 <crestfallen> :(
19:46:03 <Cale> That uses the opposite convention from the one I went with, but sure
19:46:32 <crestfallen> put val = S (\s -> (val, ()))
19:46:46 <Cale> yeah
19:46:50 <crestfallen> phew
19:47:17 <Cale> So, now, we also want a way to produce an action which "does nothing" except to have a given value as its result
19:47:24 <Cale> return :: a -> State s a
19:47:56 <Cale> will be the computation which does nothing to the current state (i.e. the final state will be the same as the initial state), but has the given value of type a as its result
19:49:41 * hackage vinyl 0.13.0 - Extensible Records  https://hackage.haskell.org/package/vinyl-0.13.0 (AnthonyCowley)
19:58:35 <crestfallen> give g = S (\s -> (g,s))   
19:59:09 <crestfallen> :(
20:03:00 <Cale> If you prefer the convention where the state is second, we can just use that
20:03:06 <Cale> But yeah
20:03:26 <Cale> So, now we have the more interesting part:
20:03:45 <crestfallen> very sorry no:
20:03:52 <crestfallen> give g = S (\s -> (s,g))   
20:03:55 <Cale> yeah
20:04:11 <crestfallen> appropriate name?
20:04:17 <Cale> It's reasonable
20:04:26 <crestfallen> phew thanks
20:04:41 <crestfallen> lord I find state very tough
20:04:44 <Cale> The reason I used the name 'return' is that is actually the name we end up using
20:05:01 <Cale> But if you want to define that, you'll have to write an instance of the Monad type class
20:05:04 <crestfallen> right I was going to use retuurn
20:05:12 <Cale> instance Monad (State s) where
20:05:17 <Cale>   return v = ...
20:05:25 <Cale>   x >>= f = ...
20:05:34 <Cale> We're about to do (>>=) now :)
20:06:01 <crestfallen> well it's the opposite of execState State s a -> s -> s
20:06:13 <crestfallen> I guess
20:06:17 <Cale> If you want, I'll just walk through that one step by step, since it's a little more challenging, or if you'd prefer, I can give you the type signature and English description again
20:06:35 <Cale> Well, I'll do that anyway
20:06:46 <Cale> (>>=) :: State s a -> (a -> State s b) -> State s b
20:07:44 <Cale> The idea is that x >>= f will be the State s b action which, when run, will first run x on the initial state, producing some intermediate state, and then if the result of that is v
20:08:09 <Cale> it will then run (f v) on the new intermediate state, producing some final state and result which will be its own final state and result
20:08:34 <Cale> So, it's like we run x, and get to use its result somehow to decide what to do next
20:08:49 <Cale> and f is the function which tells us what to do next based on the result of x
20:09:28 <Cale> Make sense?
20:09:35 <Cale> So, for example
20:09:53 <Cale> get >>= \n -> put (n+1)
20:10:14 <Cale> will be the action which increments the current state
20:10:17 <crestfallen> ok
20:10:42 <Cale> So, let's think through this step by step
20:10:49 <Cale> x >>= f = ...
20:11:12 <Cale> Well, we might as well use the S data constructor, since none of the things we've written so far look much like this :)
20:11:15 <Cale> x >>= f = S ...
20:11:38 <Cale> and that wants a function which takes the initial state, and is going to ultimately produce a pair of the final state and result
20:11:43 <Cale> x >>= f = S (\s -> ...)
20:12:20 <Cale> and now we said, we want to first run x :: State s a on the initial state. When we do that, we'll get some new state and result, so let's give those names:
20:12:36 <Cale> x >>= f = S (\s -> let (s', v) = runState x s; ...)
20:12:48 <Cale> So s' is our new state, and v is the result of running x
20:13:09 <Cale> and then we wanted to run (f v) on the new state, getting some final state and result
20:13:23 <Cale> x >>= f = S (\s -> let (s', v) = runState x s; (s'', w) = runState (f v) s' ...)
20:13:44 <Cale> So we get s'', the final state, and w, the result of running (f v)
20:14:00 <Cale> and then lastly, we produce those as our own final state and result:
20:14:09 <Cale> x >>= f = S (\s -> let (s', v) = runState x s; (s'', w) = runState (f v) s' in (s'', w))
20:14:44 <crestfallen> but with S, isn't this precisely like the ST technique?
20:15:03 <Cale> Yeah, this is the same stuff, the names are just different
20:15:25 <crestfallen> here's the thing, in     instance Monad ST where      ...
20:15:35 <crestfallen> in my code paste ..
20:15:42 <Cale> (oh, and we're parametric on s)
20:16:00 <crestfallen> app in written into the instance
20:16:51 <Cale> Yeah, I don't know why he called it app
20:16:59 <crestfallen> st >>= f = S (\s -> let (x,s') = app st s in app (f x) s')
20:17:04 <Cale> Maybe because he's thinking in terms of applying the function
20:17:24 <Cale> Yeah, that's the same thing as we just did, pretty much
20:18:01 <crestfallen> however app must be applied in the do notation version of mlabel (for the Tree structure)
20:18:52 <crestfallen> where at the bottom of the paste I have monadLab = app (mlabel tree) 4
20:19:24 <crestfallen> so that is causing me some confusion
20:21:47 <crestfallen> re: app, you said above "  he's thinking in terms of applying the function " .. which function are you referring to?
20:23:09 <jusss`> there's a list [1,2,[3,4],[3,[5,6,[7]]]], who to let every element in it plus 1?
20:23:26 <jusss`> make (+1) work on every elemement on this list?
20:23:34 <Cale> crestfallen: the contained function of type s -> (a,s) (or (s,a))
20:24:06 <Cale> jusss`: That's not a valid list, unless you have some way to interpret 6 as being of the same type as [7]
20:24:31 <Cale> (so you'd need a way to interpret numbers as lists, which I suppose you could have via a Num instance)
20:25:37 <crestfallen> I think some members didn't like the name st , is that truly a bad name? 
20:26:11 <crestfallen> I feel that I agree
20:26:24 <jusss`> Cale: err...
20:26:40 <jusss`> Cale: that is invalid in haskell?
20:26:53 <ChaiTRex> jusss`: Usually.
20:27:00 <jusss`> but that should be valid in dynamic languages like python
20:27:04 <Cale> crestfallen: It wouldn't be a terrible name except there's already something else called ST in Haskell, it's a similar but different thing
20:27:19 <Cale> jusss`: All the elements of a Haskell list must have the same type
20:27:39 <Cale> jusss`: If we want a tree, we'll use a tree data type
20:28:03 <jusss`> Cale: like that binary tree?
20:28:32 <jusss`> can this list turn to a tree, and how to solve it?
20:28:58 <Cale> For example,  data Tree a = Branch a [Tree a]
20:29:21 <Cale> Or perhaps we should go with something like
20:30:01 <Cale> data Tree a = Nil | Cons a (Tree a) | Subtree (Tree a) (Tree a)
20:30:18 <Cale> Then we can encode your nested thing like:
20:32:03 <Cale> Cons 1 (Cons 2 (Subtree (Cons 3 (Cons 4 Nil)) (Subtree (Cons 3 (Subtree (Cons 5 (Cons 6 (Subtree (Cons 7 Nil) Nil))) Nil)) Nil)))
20:32:19 <Cale> You can check the parens for me :P
20:32:36 <jusss`> right
20:32:41 <Cale> We can write a function which applies a function to all the elements of such a thing
20:32:41 * hackage Frames 0.7.0 - Data frames For working with tabular data files  https://hackage.haskell.org/package/Frames-0.7.0 (AnthonyCowley)
20:32:59 <Cale> and in fact, while we're at it, might as well make it a Functor instance :)
20:33:04 <Cale> instance Functor Tree where
20:33:13 <Cale>   fmap f = g
20:33:16 <Cale>     where
20:33:25 <Cale>       g Nil = Nil
20:33:40 <Cale>       g (Cons x t) = Cons (f x) (g t)
20:33:56 <Cale>       g (Subtree t t') = Subtree (g t) (g t')
20:34:16 <crestfallen> ok thanks, the way we did state with get, put and return, what distinguishes that from the ST approach?
20:34:49 <Cale> crestfallen: You mean the approach in Hutton's book?
20:34:59 <Cale> I believe Hutton eventually gets to get and put and return
20:35:05 <Cale> If not, that's really strange
20:35:22 <crestfallen> is it a subtlety, or is it how things are named that is the main difference?  yeah, in the hutton book
20:35:36 <Cale> How things are named is pretty much the only difference
20:35:46 <Cale> I didn't like his names, so my explanation doesn't use them
20:35:57 <Cale> (especially "app")
20:36:13 <crestfallen> yes thank you, the names I feel have been killing me. I just don't understand them
20:38:33 <crestfallen> thanks a lot Cale  ,  I'm getting there. I want to resolve the name issue and see if it gets more clear
20:40:00 <crestfallen> also I'm still staring at these two functions evalState and execState. they seem close to what we were doing with put and return   Cale
20:40:34 <crestfallen> evalState :: s a -> s -> a
20:40:57 <crestfallen> execState :: State s a -> s -> s
20:41:23 <crestfallen> did I get that right?
20:41:46 <Cale> evalState and execState are just the two halves of runState
20:41:47 <ChaiTRex> crestfallen: s a is probably an invalid type.
20:41:51 <Cale> runState produces a pair
20:41:58 <Cale> That as well
20:42:03 <Cale> That should be State s a
20:42:24 <crestfallen> yeah thanks.. the 2 halves of runState ?
20:42:44 <crestfallen> yeah ok copy that!
20:43:10 <crestfallen> thanks kindly Cale.. plenty to work on
20:43:12 <Cale> runState :: State s a -> s -> (s,a)
20:43:32 <Cale> evalState is just that, except that it takes the 'a' part of the pair
20:43:44 <Cale> and execState as well, but it gives you the 's' part of the pair
20:44:05 <crestfallen> excellent, glad to know that, thanks
20:44:12 <Cale> These things decompose State actions, while get, put and return either are or produce State actions
20:44:33 <crestfallen> very interesting
20:45:01 <crestfallen> so we are talking primarily about databases with this stuff I assume
20:45:12 <crestfallen> fields and such
20:51:23 <ChaiTRex> crestfallen: With the state monad?
20:53:02 <crestfallen> well not sure fields seems like database speak but I'm not a programmer
20:53:05 <crestfallen> ChaiTRex, 
20:56:17 <ChaiTRex> crestfallen: Oh, I didn't catch where Cale mentioned fields, so I'm not sure.
21:02:50 <crestfallen> me neither ChaiTRex ! could be a more general term [18:42:59]
21:03:09 <crestfallen> see timestamp ^
21:05:01 <ChaiTRex> crestfallen: Oh, record fields. Records are just a way to name the parts of a piece of data.
21:05:20 <ChaiTRex> crestfallen: Not referring to databases.
21:05:48 <ChaiTRex> crestfallen: Like `data T = T Int` has an Int, but it's not given a name.
21:07:02 <ChaiTRex> crestfallen: You can do something like `data T = T { countOfBats :: Int }` and now it's called `countOfBats`.
21:07:13 <ChaiTRex> crestfallen: The field is given a name.
21:10:07 <ChaiTRex> crestfallen: Field is just a name for data that's part of a bigger piece of data.
21:10:56 <ChaiTRex> crestfallen: Like the information about a cup in a game might have its contents as one field, its location as another field.
21:11:30 <ChaiTRex> crestfallen: So, the cup might be on the table (one field) halfway filled with coffee (another field).
21:12:29 <steven_> hi, with Parsec, is there a way to compose a stateful parser with stateless parsers? basically what I have is a component of my parsing needs state but I don't want to expose that state to everything that uses that subparser. And if I have to do it with an extra call to runParsec I feel like it will get kind of messy
21:12:49 <steven_> because then I need to figure out how much of the input is left and ensure that that's what's passed to the other parsers
21:14:40 <steven_> I guess that I probably do need to make another call to runParsec, but it seems like a big inconvenience. I wonder if there's a better way to design this
21:26:08 <crestfallen> sorry ChaiTRex one sec really appreciate it
21:28:58 <jackdk> steven_: use ParsecT over a state monad, and write all your other parsers over some unknown monad: replace `Parsec s u` with `Parsec s u m`. You will probably need to add `Monad m => ` also, but then they won't be able to know which monad is actually in use.
21:29:53 <jackdk> steven_: erm, just noticed that `u` was the user state type anyway. If you're using that, then the functions that don't look into the state can put a type variable there instead.
21:30:45 <steven_> ah yeah I think that's the solution, I just change all of my functions to work forall u instead of u = ()
21:31:05 <steven_> cool thanks jackdk 
21:40:19 <jackdk> steven_: np
21:45:55 <jackdk> it's also safer because you can't accidentally lean on the state
21:53:32 <steven_> hmmm now I wonder if there's a parsec equivalent to withState or local
21:55:18 <steven_> can't find it on hoogle but I don't need it anywayt
22:27:11 <typetetris> Is there something like the lens package but with fewer dependencies?
22:38:50 <EvanR> you could try optics, which seems to have more comprehensible docs
22:39:08 <EvanR> and fewer deps
22:39:35 <EvanR> the vocab seems to be consistent with lens
23:15:40 <typetetris> Do you know, why optics have been created and not lens reused?
23:18:00 <dolio> It's an attempt at a nicer (in some ways) design.
23:20:00 <ja> typetetris: i think one advantage is supposed to be error messages that are easier to understand because function composition is not used for optic composition?
23:21:30 <typetetris> Are there known performance trade offs?
23:21:34 <ja> monochrom: good point about the model checkers
23:22:10 <ja> typetetris: what do you mean? trade-offs sacrificing what for what?
23:23:01 <typetetris> ja: are lenses ore optics more performant? Or wasn't that researched?
23:24:01 <ja> i don't know
23:24:07 <c_wraith> it probably depends on a lot of factors.
23:51:41 * hackage backtracking 0.1.0 - A backtracking monad  https://hackage.haskell.org/package/backtracking-0.1.0 (SatoshiEgi)
