00:01:17 <liiae> Axman6: oh, if there's a -> Box a, and Box a -> a, then Box a and a are isomorphic?
00:01:26 <Axman6> yes
00:02:13 <kiwi_45> dmj`: Hello, I successfully managed to setup Auth with Servant-Auth and httpOnly :)  Thanks for your help!
00:02:36 <liiae> Axman6: but fromJust :: Maybe a -> a, and return :: a -> m a, why this Maybe a and a are not isomorphic?
00:02:46 <liiae> return could be a -> Maybe a
00:02:57 <Axman6> what a do I get back when I give fromJust a Nothing?
00:03:23 <Axman6> > fromJust Nothing :: String -- what;s my string lambdabot
00:03:26 <lambdabot>  "*Exception: Maybe.fromJust: Nothing
00:03:44 <Axman6> that isn't total, there is not a one to one mapping between Maybe a and a
00:04:22 <Axman6> this is because the number of values of Maybe a is the number of values of a plus one
00:05:34 <Axman6> There IS an isomorphism between Either a a and (Bool, a) - can you write the functions f :: Either a a -> (Bool, a) and g :: (Bool, a) -> Either a a, such that f . g = id and g . f = id?
00:05:37 <liiae> Axman6: could I say if F a and a are isomorphic, then there must be two functions f :: F a -> a and g :: a -> F a existed?
00:06:07 <dibblego> at least
00:06:24 <int-e> liiae: You also need that these maps are inverses of each other, which is why I brought up  box . unbox = id, unbox . box = id. And actually the first of those is not so easy to show.
00:06:30 <Axman6> well, more generally, a and b are isomorphis if there are functions f :: a -> b, g :: b -> a, such that f . g = id @b and g . f = id @a
00:06:48 <int-e> @free boxA :: (A -> b) -> b
00:06:48 <lambdabot> f . boxA = boxA . (.) f
00:06:57 <Axman6> isomorphic*
00:07:21 <liiae> Axman6: but Either a a could be Left a or Right a, so they can't be isomorphic?
00:07:37 <dibblego> Either a a is isomorphic to (a, Bool)
00:07:43 <Axman6> try writing those functions, see if you can come up with a way to use that Bool
00:07:52 <int-e> which if you apply `id` on both sides becomes f (boxA id) = boxA f, so that  box (unbox boxA) = \g -> g (boxA id) = \g -> boxA g = boxA.
00:08:04 <Axman6> f (Left a) = ???; f (Right a) = ???
00:08:18 <liiae> Axman6: aha, right
00:08:24 <Axman6> g (True, a) = ???; g (False, a) = ???
00:08:39 <int-e> It's always fun when an isomorphism relies on parametricity/free theorems like that.
00:09:05 <liiae> Axman6: so Maybe a and a can't be isomorphic, but Maybe a and String can be isomorphic
00:09:10 <liiae> right?
00:09:20 <Axman6> how?
00:09:27 <dibblego> Either Void a is isomorphic to a
00:09:36 <liiae> Maybe String -> String,   and   String -> Maybe String
00:09:43 <dibblego> Either () a is isomorphic to Maybe a
00:09:46 <int-e> Maybe [()] ~= [()] ignoring bottoms.
00:09:48 <dibblego> your homework: write them
00:09:48 <Axman6> how can I write the function f :: String -> Maybe a swuch that for every String, I can get a unique Maybe a?
00:10:17 <Axman6> liiae: try writing the functions
00:11:31 <int-e> Maybe String ~= String isn't that hard (but not pretty).
00:11:33 <Axman6> I think it's quite easy to write an isomorphism between String and Maybe String, but this is only possible because we know more about the types - we cannot write an isomorphism between a and Maybe a
00:12:29 <int-e> It generalizes to (Pointed a, Eq a) => Maybe [a] ~= [a]
00:12:36 <typetetris> What is the difference between mtl ReaderT and transformers ReaderT or can they be used interchangeably?
00:12:47 <int-e> (abusing notation. Pointed a is a class with method point :: a)
00:13:00 <Axman6> there's some nuances though, you have to make a decision abuut how you represent Nothing as a String, and it must be different to how you represent Just "" as a String, in the function g :: Maybe String -> String
00:13:24 <Axman6> typetetris: I'm pretty sure they are exactly the same, one uses the definition from the other
00:13:36 <typetetris> Axman6: Thanks
00:13:54 <int-e> Hilbert's hotel.
00:14:15 <Axman6> "We're never full!"
00:14:32 <int-e> "But our guests move around a lot."
00:14:47 <int-e> Hmm, too negative. "Have a new room every day!"
00:16:02 <MarcelineVQ> welcome to hotel IO, you can return, but you can't ever leave
00:25:53 <dmwit> int-e: Hm. I think you need more than Pointed.
00:27:06 <dmwit> The way that's obvious to me also requires a way to "increment" individual elements.
00:27:40 <dmwit> class Enumerable a where zero :: a; successor :: a -> Maybe a
00:27:43 <int-e> dmwit: Why? I'm mapping Nothing to [], Just [] to [point], Just [point] to Just [point,point]... I didn't consider infinite lists, but it turns out that those are fine as well if we think of this as appending a point at the end (so we can make it lazy).
00:28:19 <dmwit> I see! That's pretty clever.
00:28:49 * hackage hall-symbols 0.1.0.6 - Symmetry operations generater of Hall Symbols  https://hackage.haskell.org/package/hall-symbols-0.1.0.6 (narumij)
01:05:32 <liiae> Axman6: f :: Maybe String -> String; f Just a = a; f Nothing = "Nothing"; g :: String -> Maybe String; g "Nothing" = Nothing; g a = Just a
01:06:09 <liiae> dibblego: f2 :: Either () a -> Maybe a; f2 Left _ = Nothing; f2 Right _ = Just _; g2 :: Maybe a -> Either () a; g2 Nothing = Left (); g2 Just a = Right a
01:06:36 <liiae> so Maybe String and String are isomorphic? Either () a and Maybe a are isomorphic now?
01:07:49 * hackage symmetry-operations-symbols 0.0.1.4 - Derivation of symbols and coordinate triplets Library  https://hackage.haskell.org/package/symmetry-operations-symbols-0.0.1.4 (narumij)
01:07:55 <merijn> liiae: What does 'Just "Nothing"' turn into? :)
01:08:43 <merijn> liiae: There are two Maybe values that map to the String "Nothing", and zero String values that map to 'Just "Nothing"', so that's not an isomorphism
01:10:38 <liiae> merijn: you're right, how to fix it?
01:11:21 <liiae> merijn: Either () a and Maybe a are isomorphic, it's ok?
01:11:24 <merijn> You can't, because there is no isomorphism between "Maybe String" and "String" :)
01:11:36 <merijn> liiae: Yeah, "Either () a" and "Maybe a" are isomorphic
01:13:37 <liiae> merijn: it give me a feel like functions in math, different values in range could point to one value in domain, but you can't do the reverse
01:14:05 <liiae> sorry, if my concepts are wrong
01:16:17 <liiae> oh, it's called domain
01:17:45 <liiae> diffrent values in domain can point to same value in codomain? range?
01:18:34 <liiae> but you can't do the reverse, make values in codomain? range? point to values in domain?
01:27:37 <Axman6> if multiple values can map to the same value than a) you do not have a one to one correspondence, by definition, and b) you do not have f . g = id or g . f = id
01:30:35 <liiae> Axman6: so Maybe a could not be isomorphic to other types?
01:32:04 <liiae> is there a relation among id, reverse and (+1) on type level?
01:32:31 <liiae> id :: a -> a; reverse :: String -> String; (+1) :: Num a => a -> a
01:32:49 <liiae> they all are a -> a
01:39:19 * hackage hascard 0.1.2.0 - A TUI for reviewing notes using 'flashcards' written with markdown-like syntax.  https://hackage.haskell.org/package/hascard-0.1.2.0 (Yvee1)
01:39:21 <xsperry> is there a more forgiving TimeOfDay reader, or do I have to roll my own?
01:39:25 <xsperry> > read "03:00:00" :: TimeOfDay
01:39:27 <lambdabot>  error:
01:39:27 <lambdabot>      Not in scope: type constructor or class ‘TimeOfDay’
01:40:01 <xsperry> read "03:00:00" => 03:00:00       read "3:00:00" => error     read "03:00" => error
01:44:48 <phadej> if you want accept all three, then you have to do that yourself
01:45:25 <phadej> individual formats may be parseTimeMd
01:45:29 <phadej> % Data.Time.parseTimeM True Data.Time.defaultTimeLocale "%H:%M" "03:00" :: IO Data.Time.TimeOfDay
01:45:30 <yahb> phadej: 03:00:00
01:45:52 <phadej> but there is no format for hours without leading zero, nor optional "fields"
01:47:21 <phadej> % traverse (Data.Time.parseTimeM True Data.Time.defaultTimeLocale "%l:%M") ["3:00", "03:00"] :: IO [Data.Time.TimeOfDay]
01:47:21 <yahb> phadej: [03:00:00,03:00:00]
01:48:28 <phadej> anyway, this is something regex library would do for you
01:50:38 <xsperry> thanks, that's good enough, I don't really need seconds
02:31:23 <typetetris> Does cabal work in parallel out of the box, or does it need some flags for that?
02:32:49 * hackage b9 2.0.0 - A tool and library for building virtual machine images.  https://hackage.haskell.org/package/b9-2.0.0 (SvenHeyll)
02:37:32 <phadej> typetetris: it compiles multiple components concurrently, but doesn't pass `-j` to GHC
02:37:42 <phadej> i,.e. runs multiple single-threaded GHCs
02:41:49 <typetetris> hmm, must have made a sequential dependency structure then ...
02:53:19 * hackage cabal-edit 0.1.0.0 - Cabal utility  https://hackage.haskell.org/package/cabal-edit-0.1.0.0 (sdiehl)
02:53:27 <random> hey guys
02:54:03 <random> does anyone know if it's possible to define multiple packages using iohk's haskell nix infrastructure
02:54:05 <random> https://input-output-hk.github.io/haskell.nix/tutorials/getting-started/#scaffolding
02:54:19 <random> e.g. in the default.nix that they provide they have defined the haskell-nix-project package
02:54:30 <random> could you have multiple of those?
03:25:19 * hackage recommender-als 0.2.0.0 - Recommendations using alternating least squares algorithm  https://hackage.haskell.org/package/recommender-als-0.2.0.0 (kaol)
04:14:17 <gerogecosma> hey guys, i'm working with hedis and I need to introspect the response type (Redis a) in order to mock for testing. Can not find anything on how to do that.
04:36:03 <dmj`> gerogecosma: Redis is a monad, you can't really introspect it, but you can evaluate it to get the 'a' w/ runRedis
04:40:32 <gerogecosma> I was afraid of that. I wouldn't want to evaluate it since i'm trying to mock the responses (which is why I wanted introspection).
04:45:53 <dmj`> gerogecosma: I'd make a data type that has all the functions you want in it, then initialize one as a mock, and one as "live" with runRedis
04:46:39 <dmj`> you hide the implementation in the closure
04:49:46 <gerogecosma> very well, will look into it. Thank you
05:17:42 <mlugg> I have an IOUArray of Word16s, indexed by a 3-tuple (Word32,Word32,Word8). Is there a fast way to output all the stored values (in big endian) to a file? Using a 1920x1080x4 array (this is for image data), I've tried doing it by `freeze`ing to an Array, fmapping `word16BE` from ByteString.Builder over it, and `foldl'`ing that with mappend, then
05:17:42 <mlugg> using hPutBuilder on a file handle, but it takes about 7 seconds for the whole process, which isn't great. I've also tried a more "low-level" imperative approach, where I use Data.Ix `range`, and `foldM` a small function over it to construct a `Builder`, with the thought that this does not require the vector to be copied - but it was even slower.
05:17:43 <mlugg> Is there a nice way to do this quickly, or do I have to resort to low-level weirdness?
05:18:39 <merijn> mlugg: Have you benchmarked what part takes the most time?
05:18:58 <merijn> mlugg: Honestly, I don't think "being copied" is the slow part there
05:19:34 <mlugg> Yeah, I later realised it's not the main issue - it's not insignificant though, the freezing is about 3 seconds
05:19:58 <merijn> Some napkin math says that's 15MB, copying that shouldn't take that long, tbh
05:21:05 <merijn> hmm
05:21:19 <merijn> Hard to say what to do without some code or profiling info
05:21:52 <mlugg> Okay, I'll clean up the code a bit and profile it
05:22:15 <merijn> Also, are you compiling with -O or -O2?
05:24:07 <mlugg> I did a slight stupid and was just putting it straight into GHCi - if actually compiled it's around 4 seconds, same on -O and -O2
05:24:51 <merijn> mlugg: ghci is terrible for performance info
05:25:04 <merijn> mlugg: It uses a bytecode interpreter and a bunch of optimisations don't get done
05:25:18 <mlugg> Okay, noted, ty
05:26:37 <mlugg> Huh, when compiled my way slower one becomes way faster, go figure
05:36:40 <merijn> ;)
05:36:58 <merijn> Hence, never rely on ghci ;)
05:37:07 <merijn> Is it more reasonable now?
05:39:49 * hackage rocksdb-haskell-jprupp 2.0.0 - Haskell bindings for RocksDB  https://hackage.haskell.org/package/rocksdb-haskell-jprupp-2.0.0 (jprupp)
05:40:50 * hackage haskoin-node 0.15.0, rocksdb-query 0.4.0 (jprupp): https://qbin.io/apple-jose-rte5
05:43:18 * hackage haskoin-store-data 0.35.0 - Data for Haskoin Store  https://hackage.haskell.org/package/haskoin-store-data-0.35.0 (jprupp)
05:44:19 * hackage haskoin-store 0.35.0 - Storage and index for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-store-0.35.0 (jprupp)
05:47:23 <kuribas> does servant force errors to be text/plain?
05:47:32 <kuribas> what if I want application/json instead?
05:48:14 <kuribas> ah, I suppose I just need to set a Header...
06:11:12 <halogenandtoast> I was trying to test out random-1.2 with stack, but when I try to build I get the following: Dependency cycle detected in packages: [random,splitmix,random,seeder]
06:11:33 <halogenandtoast> Has anyone else encountered this and/or know how to fix it?
06:12:18 <merijn> seeder seems to be a nonexistent package?
06:12:22 <merijn> Is that your code?
06:12:59 <merijn> halogenandtoast: ah, I see the issue
06:13:19 <merijn> halogenandtoast: older versions of splitmix depend on random, while the newest random depends on splitmix
06:13:51 <halogenandtoast> So do I need to lock in splitmix at 0.1 ?
06:13:56 <merijn> halogenandtoast: So presumably stack is trying to use the new random with an old splitmix, ignoring the dependency bounds
06:13:59 <merijn> Yes
06:14:52 <halogenandtoast> merijn: okay that works
06:14:56 <halogenandtoast> Thank you
06:16:37 <ezzieyguywuf> isn't there a ghc flag that makes the build fail, or at least warn, if I have a case-statement that has a "hole"?
06:16:45 <ezzieyguywuf> and if so, how do I specify that in a stack config file?
06:16:49 <merijn> ezzieyguywuf: -Wall :p
06:17:23 <dminuoso> Also, is there a way to disable the behavior or underscored identifiers like _foo not provoking an error if they are not defined?
06:17:30 <dminuoso> This is seriously annoying when working with TH generated optics. :(
06:17:48 <merijn> dminuoso: No
06:17:59 <merijn> dminuoso: They should provoke an error, though
06:18:08 <merijn> Which GHC?
06:18:27 <merijn> Someone messed up and broke it in one of the late 7.x, early 8.x releases
06:18:31 <dminuoso> merijn: No the problem is Im getting the wrong error. :(
06:18:48 <dminuoso> Don't even get "did you mean" suggestions
06:18:53 <merijn> Wrong error how?
06:19:24 <dminuoso> merijn: Well say you have _foobar and you type _foobra instead. You get an error about a typed hole.
06:19:28 <ezzieyguywuf> so can I only specify the -Wall in the command line?
06:19:33 <ezzieyguywuf> or can I put it in stack.yaml?
06:19:33 <dminuoso> Rather than an undeclared identifier with did-you-mean suggestions
06:19:34 <merijn> dminuoso: That's the right error, though
06:19:53 <merijn> ezzieyguywuf: Presumably, but I don't use stack
06:19:53 <dminuoso> merijn: Depends on how you look at it. I dont use named typed holes - so for all I care it can consider them identifiers.
06:20:57 <merijn> dminuoso: There's no solution, besides "don't use _ as a leading character"
06:21:30 <merijn> (well, I guess there's one other solution, which is "make a PR to GHC to implement a flag to toggle this")
06:23:16 <phadej> -fmax-refinement-hole-fits=0 makes things less verbose
06:23:20 <phadej> (and faster)
06:23:29 <phadej> err.
06:23:30 <phadej> -fmax-valid-hole-fits
06:23:50 <merijn> phadej: His complaint was that he wasn't getting suggestions, though?
06:23:57 <ezzieyguywuf> hah, whoops, now I'm rebuliding my dependencies with the new flags. oh well.
06:24:08 <halogenandtoast> Is there a way with the new random package to generate (or let it generate) a seed, obtain that seed and print it out and store it to rerun the application with it?
06:24:30 <halogenandtoast> In the old one I could use the crappy show/read instance, but the new one does not seem to have a read instance
06:24:50 <phadej> merijn: yep, one needs for `-f` flags to modify GHC output
06:24:59 <merijn> halogenandtoast: That's what mkStdGen is
06:24:59 <phadej> ... or interactive errors
06:25:18 <merijn> halogenandtoast: Just generate a random int and serialise that
06:25:37 <halogenandtoast> merijn: okay
06:25:39 <halogenandtoast> thanks again
06:30:28 <ezzieyguywuf> hm, "A do-notation statement discarded a result of the type 'Char'. Suppress this warning by saying ‘_ <- char '.'’"
06:30:39 <ezzieyguywuf> but `char '.'` seems cleaner, and perfectly readable
06:30:53 <ezzieyguywuf> "check for this but discard the result"
06:31:01 <solonarv> yes, I don't like that warning either
06:31:25 <ezzieyguywuf> solonarv: how do you deal with it?
06:31:41 <merijn> ezzieyguywuf: Just disable that warning :)
06:31:56 <merijn> ezzieyguywuf: See: https://www.reddit.com/r/haskell/comments/hudg1o/practical_usefulness_of_wunuseddobind/
06:31:57 <solonarv> you can turn it off with -Wno-unused-do-bind
06:31:59 <phadej> :t void
06:31:59 <ezzieyguywuf> hm, but I want to know about _other_ unused-binds
06:32:00 <lambdabot> Functor f => f a -> f ()
06:32:07 <phadej> void (char '.')
06:32:11 <ezzieyguywuf> ah hah!
06:32:16 <merijn> ezzieyguywuf: Of all the -Wall warnings it's the least useful one
06:32:17 <solonarv> ah. in that case you need 'void' or '_ <-'
06:32:38 <phadej> don't use _ <-
06:32:42 <phadej> that would use >>=, and not >>
06:32:53 <phadej> it matters (not much, but it's different)
06:33:36 <solonarv> monad laws say m >> k = m >>= \_ -> k, so they should certainly be equivalent
06:33:47 <solonarv> do you mean performance/strictness might be different?
06:33:54 <merijn> solonarv: Performance, presumably
06:35:09 <kuribas> how do you set the encoding for readFile?
06:35:35 <dminuoso> kuribas: https://hackage.haskell.org/package/base-4.14.0.0/docs/System-IO.html#v:hSetEncoding
06:35:46 <kuribas> well Data.Text.IO.readFile
06:36:10 <dminuoso> kuribas: Use openFile yourself.
06:36:18 <kuribas> dminuoso: I cannot, it's hidden in dhall
06:36:22 <dminuoso> readFile name   =  openFile name ReadMode >>= hGetContents
06:36:26 <nlhowell1> I have a heterogeneous list, which by constructors can only contain certain types. How can I tell ghc about this?
06:36:27 <dminuoso> Oh. Then you're out of luck I guess
06:36:56 <kuribas> not so great that dhall is local sensitive
06:37:07 <dminuoso> Perhaps there's some other way to control it, perhaps via locale?
06:37:23 <merijn> dminuoso: Yes, you can set the global default
06:37:29 <merijn> readFile and co use that
06:37:56 <dminuoso> nlhowell1: What do you mean exactly?
06:38:23 <kuribas> https://hackage.haskell.org/package/setlocale ?
06:38:31 <merijn> https://hackage.haskell.org/package/base-4.14.0.0/docs/GHC-IO-Encoding.html#v:setLocaleEncoding
06:38:41 <merijn> And friends
06:38:58 <nlhowell1> I have a Nat-indexed type, and I want to have heterogeneous lists of them
06:39:09 <phadej> kuribas: complain in https://github.com/dhall-lang/dhall-haskell/issues/504
06:39:18 <kuribas> merijn: great, that's what I need :)
06:39:27 <nlhowell1> my list currently looks like data MyList (l :: [*]) where (:#) ...
06:39:30 <dminuoso> nlhowell1: Make an extential KnownNat ?
06:39:32 <merijn> It's literally mentioned in the hSetEncoding docs :p
06:39:45 <phadej> dhall just shouldn't use Data.Text.IO.readFile at all
06:39:45 <nlhowell1> I can do this for finitely many terms
06:39:47 <phadej> it doesn't make sense
06:39:53 <nlhowell1> but I can't do it explicitly if I don't know the length of the list
06:39:56 <phadej> parsing from bytestring would be faster
06:40:01 <dminuoso> nlhowell1: i.e. `data S = forall s. KnownNat s => S ...`
06:40:14 <dminuoso> mmm
06:40:30 <phadej> and given "Yes, the standard requires that the character encoding is UTF-8 "... there is no need to let user specify encoding in any way
06:40:37 <phadej> (i.e. using locale)
06:40:38 <nlhowell1> I would just use the HList you see everywhere, but I want to perform a fold
06:40:51 <nlhowell1> my types are Transducer (n :: Nat)
06:41:04 <nlhowell1> and I have a compose function for every two Transducers
06:41:14 <nlhowell1> I want to build a list of them, and foldl the compose
06:41:47 <kuribas> phadej: I see, so it already uses the right encoding?
06:41:53 <nlhowell1> so for MyList I have a cons which only cons's (KnownNat n) Transducer n into the list
06:42:05 <dminuoso> nlhowell1: Can you share your code?
06:42:16 <nlhowell1> yes, just a second
06:42:50 <nlhowell1> sorry, this is a bit messy, I've been toying around for awhile
06:42:55 <nlhowell1> https://dpaste.com/EBCGXFC2U
06:43:41 <nlhowell1> compose' is already implemented; signature is 
06:43:43 <nlhowell1> compose' :: forall (n :: Nat) (m :: Nat). (KnownNat n, KnownNat m) => Transducer' n -> Transducer' m -> Maybe (Transducer' (n+m))
06:44:07 <nlhowell1> sorry, my Transducers are actually Transducer', story is not very short
06:44:19 <phadej> kuribas: given the issue is closed in 2018, it is probably regressed
06:44:33 <merijn> phadej: Or his dhall file has the wrong encoding :p
06:44:34 <kuribas> phadej: could be that I am wrong though
06:44:48 <phadej> `file` should tell
06:45:01 <phadej> it's good at recognizing something not being UTF-8 text file
06:46:33 <dminuoso> nlhowell1: Out of my league. What's the nat for anyway? I dont see any uses of it
06:47:01 <nlhowell1> which nat?
06:47:05 <dminuoso> (That is, there does not appear to be type level arithmatic on it, nor are you demoting it with natval)
06:47:13 <nlhowell1> other files
06:47:54 <nlhowell1> e.g. for making sure that you don't attempt to union two transducers with different numbers of tapes
06:48:06 <nlhowell1> dminuoso: thanks for looking anyways :)
06:48:17 <kuribas> phadej: no, I looked at the source and I assumed from its use of readFile that it was local sensitive.  My bad.
06:48:33 <nlhowell1> I suspect I need to use some sort of All c for a constraint c
06:48:42 <dminuoso> nlhowell1: Im just curious why you incur KnownNat constraints if you dont even use natVal or sameNat
06:48:49 <dminuoso> in your composeX functions
06:49:00 <nlhowell1> compose takes n and m to n+m
06:49:15 <dminuoso> Arrgh! Side scrolling explains why everything was so weird!
06:49:26 <dminuoso> Sorry, was cut off to the side. Now I can see it >:)
06:49:26 <nlhowell1> dminuoso: ?
06:49:36 <nlhowell1> oh! i'm sorry, i should have formatted it before pasting :(
06:49:45 <nlhowell1> lol, now i understand why you were confused
06:50:06 <nlhowell1> yeah, i've been just hacking on this for a bit, haven't cleaned any of it up
06:50:59 <AndreasK> Does optparse-applicative offer a way to encode "if this flag is enabled, default argument foo to bar, unless foo is given explicitly"?
06:51:26 <dminuoso> AndreasK: Yes.
06:51:35 <dminuoso> AndreasK: f <|> pure 'foo'
06:51:40 <dminuoso> Argh. Well you get the idea.
06:52:12 <dminuoso> Or are you talking about a separate flag infuencing the default of another?
06:52:51 <AndreasK> Yes
06:53:08 <dminuoso> No, you'd need optparse-selective for that.
06:53:30 <dminuoso> Just do it in postprocessing
06:56:54 <AndreasK> There is no easy way to check if a flag has been given after the parser has run is there?
06:58:35 <dminuoso> AndreasK: Well you can just produce it as an artifact of your `Parser Opts`, where Opts could include a bool field denoting whether the said flag has been specified.
06:58:46 <merijn> dminuoso: Clearly your life's calling is to implement optparse-selective for us
06:59:25 <dminuoso> :)
07:03:19 <dminuoso> AndreasK: remember, being applicative based, you don't get monadic or selective power. That means, the result of one parser cant decide on the effect of another.
07:03:37 <dminuoso> (they are completely static)
07:05:02 <merijn> dminuoso: https://github.com/pcapriotti/optparse-applicative/issues/352
07:06:16 <dminuoso> merijn: My time is currently quite limited, sadly. :(
07:06:29 <merijn> dminuoso: Why do you think I haven't implemented it yet? :p
07:06:34 <dminuoso> ;)
07:06:55 <merijn> It would make my commandline parser so much easier/more convenient
07:14:32 <nil> is there a clever way to write Map.mapMaybe using (micro)lens?
07:15:36 <xerox_> :t Data.Map.mapMaybe
07:15:37 <lambdabot> (a -> Maybe b) -> M.Map k a -> M.Map k b
07:18:32 <solonarv> nil: I don't think so, n
07:18:35 <solonarv> * no
07:18:39 <nil> the way i understand it, the At instance gives the power to insert/delete elements, but it only works on a single key
07:18:40 <solonarv> not with microlens
07:18:47 <solonarv> yes, that's right
07:18:52 <nil> solonarv: ok, out of curiosity, is there a way with lens?
07:19:17 <solonarv> and the Each instance just gives you traverse/mapM which don't let you delete entries
07:20:31 <solonarv> looking through lens:Data.Map.Lens, the docs don't mention anything that could be used to cleverly build a mapMaybe
07:20:56 <solonarv> I can't be bothered to exhaustively scour the entire library to confirm, but I believe it isn't possible
07:21:11 <nil> thanks
07:32:17 <dminuoso> Axman6: You around?
07:39:49 <kuribas> solonarv: maybe at?  http://hackage.haskell.org/package/microlens-0.4.11.2/docs/Lens-Micro-Internal.html#v:at
07:42:22 <dminuoso> merijn: Sad panda though. ApplicativeDo makes for such pretty parsers.
07:42:27 <dminuoso> Perhaps we should explore SelectiveDo! 
07:42:48 <Uniaika> dminuoso: qualified do to the rescue!
07:43:01 <merijn> dminuoso: You clearly haven't seen my parsers ;)
07:43:11 <merijn> They're...about adequate, at best :p
07:43:12 <dminuoso> Uniaika: What's that?
07:43:44 <dminuoso> Are you talking about RebindableSyntax?
07:44:11 <Uniaika> dminuoso: better
07:44:11 <Uniaika> https://www.tweag.io/blog/2020-07-13-qualified-do-announcement/
07:44:49 <dminuoso> That looks like first-class quasisquoters :o
07:44:55 <dminuoso> Crazy
07:45:10 <dminuoso> Or at least something in between
07:45:18 <yushyin> yes crazy and the proposal is already merged 
07:45:32 <dminuoso> Oh. Which GHC does it ship with?
07:48:57 <solonarv> kuribas: At can only work on one element at a time
07:49:34 <kuribas> ah right
07:50:27 <solonarv> so, sure, you can do something like foldr (\k -> at k %~ f) (keys myMap) myMap
07:50:37 <solonarv> but I wouldn't exactly call that "clever"
07:51:23 <frdg> is there anyway to expose all records from a type by just exposing the type? I do not want to have to type out all of the records for City in `module PostgresSupport (queryCity, City) where` 
07:51:28 <Uniaika> dminuoso: it appears at https://gitlab.haskell.org/ghc/ghc/-/wikis/status/ghc-8.12.1
07:52:55 <solonarv> frdg: if 'data Foo = MkFoo { fields :: Fields }', then 'Foo(..)' in an export/import list means "Foo, and all its constructors, and all their fields" i.e. 'Foo(MkFoo, fields)'
07:53:09 <solonarv> does that answer your question?
07:53:23 <frdg> solonarv: yes this was my question thank you
08:04:54 <frdg> is there a way to see all the types of local variables in a function? 
08:05:29 <solonarv> yes, when reporting a hole GHC will tell you about the bindings that are in scope
08:06:31 <solonarv> e.g. 'f x y = _hole where { bindings }', GHC will tell you "found a hole '_hole :: Blah'; bindings in scope are: foo :: Foo, bar :: Bar"
08:08:27 <frdg> solonarv: I have been trying to do this but often do not get shown the relavent bindings. Here is an example: https://dpaste.org/arMt
08:15:35 <solonarv> frdg: ghcid cuts off some of the error text, so the bindings might be below what you see
08:20:50 <olle> yo
08:21:09 <olle> is there a (web) framework in haskell that make sure business logic is kept pure?
08:21:13 <olle> makes*
08:21:56 <frdg> solonarv: oh ok
08:22:57 <frdg> yes if I load into ghci I am shown the relevant bindings.
08:23:45 <olle> meaning, no IO monad in business logic
08:26:44 <dminuoso> olle: There's no framework necessary.
08:26:52 <dminuoso> olle: Just write your business logic without IO and you're done.
08:27:05 <dminuoso> It's a built-in feature of Haskell.
08:28:15 <hseg> ok, so investigating further, it seems Coercible isn't at fault for ghc rejecting my instance declaration
08:28:44 <hseg> since explicitly writing the instance i expected derivingvia to give me does work
08:28:45 <olle> dminuoso: NO
08:28:55 <olle> dminuoso: that assumes the coder has disciplin :D
08:29:01 <olle> discipline*
08:29:02 <olle> ?
08:29:27 <hseg> so i think it's just a matter of derivingvia bailing the moment it sees any general tyfam application
08:29:40 <hseg> checking a little more thoroughly...
08:29:59 <dminuoso> olle: Well, since web applications tend to need IO eventually in most cases, there's nothing sensible to tackle onto the "web development part"
08:30:37 <dminuoso> olle: So the best you're looking for "how do I ensure people dont sneakily do IO" and that's by using its type system. 
08:30:43 <dminuoso> (Assuming they dont unsafePerformIO)
08:30:46 <olle> dminuoso: yeah, but IO should be separate to make testing easier, was my thought
08:31:04 <dminuoso> olle: Sure, or you get into tagless final encodings.
08:31:14 <olle> dminuoso: link?
08:31:20 <olle> i might have seen it before
08:31:34 <dminuoso> http://okmij.org/ftp/tagless-final/index.html
08:31:44 <dminuoso> There's not much to it.
08:32:29 <olle> ah
08:32:30 <olle> oleg
08:32:40 <olle> it always comes back to oleg, doesn't it? :)
08:32:48 <phadej> one of them, yes.
08:34:37 <olle> uh, how is tagless different from making your own language inside haskell?
08:35:46 <phadej> it's one way to do latter.
08:42:05 <olle> ok thanks
08:47:18 <hseg> (for context re my complaint, cf https://gitlab.haskell.org/ghc/ghc/-/issues/18483)
09:12:19 * hackage haskoin-store-data 0.35.1 - Data for Haskoin Store  https://hackage.haskell.org/package/haskoin-store-data-0.35.1 (jprupp)
09:13:19 * hackage haskoin-store 0.35.1 - Storage and index for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-store-0.35.1 (jprupp)
11:16:08 <hyiltiz>  http://ircbrowse.net/browse/haskell domain is out. https://wiki.haskell.org/IRC_channel still points to it. Is there a new site for searching #haskell?
11:18:19 * hackage persistent-template 2.8.3.1 - Type-safe, non-relational, multi-backend persistence.  https://hackage.haskell.org/package/persistent-template-2.8.3.1 (parsonsmatt)
11:24:20 <hseg> look att the topic: http://tunes.org/~nef/logs/haskell/?C=M;O=D
11:28:19 * hackage BlogLiterately 0.8.7 - A tool for posting Haskelly articles to blogs  https://hackage.haskell.org/package/BlogLiterately-0.8.7 (BrentYorgey)
11:32:36 <hyiltiz> I see, but tunes.org doesn't provide a global search function? Aka something "as if" I download all logs and did a "grep -r . Monad"
11:33:11 <xe4> is it possible to extend these to more than 2 inputs?
11:34:19 * hackage free-algebras 0.0.8.2 - Free algebras  https://hackage.haskell.org/package/free-algebras-0.0.8.2 (coot)
11:35:27 <hseg> hyiltiz: not that i know of
11:35:55 <hseg> it's only ~200MB, you can def download and grep -r through it
11:37:01 <hyiltiz> yes, definitely; sysadmins generally frown upon scrapping their site (too much egress, server load etc.)
11:37:10 <hyiltiz> so thought I'd ask first
11:37:18 <hyiltiz> hseg++
11:37:39 <hseg> don't know the admin, valid concern
11:50:28 <ezzieyguywuf> hm, for some reason "stack exec -- ghcid --command="stack ghci MyModule:test:my-test"" does not reload when "MyLib" is changed. It does if I do "stack exec -- ghcid --command="stack ghci MyModule:lib MyModule:test:my-test"". The "my-test" executable does have a dependency of "MyLib". Is this expected behaviour, or am I doing something wrong (or am I just using ghcid in a weird way?)?
11:56:14 <d34df00d> Hi!
11:56:39 <d34df00d> I've come across a paper or a blog post some time ago that describes treating algebraic types literally as elements of an algebra and solving equations on them.
11:56:50 <d34df00d> But I can't find that easily now, google is irrelevant for me.
11:56:55 <d34df00d> Do you have any good pointers?
11:57:05 <merijn> d34df00d: There was a nice one, but it disappeared
11:57:52 <merijn> d34df00d: I think this is a mirror? https://gist.github.com/gregberns/5e9da0c95a9a8d2b6338afe69310b945
11:58:24 <d34df00d> Yep, I think that's what I've seen!
11:58:26 <d34df00d> Thanks!
12:01:56 <d34df00d> Soo, given that, is there a reasonable way to solve an equation like ξ = ξ → T for ξ?
12:02:18 <d34df00d> Or, rather, ξ = Пx : ξ. T, where T does mention x?
12:02:18 * hackage dobutokO-effects 0.12.0.0 - A library to deal with SoX effects and possibilities  https://hackage.haskell.org/package/dobutokO-effects-0.12.0.0 (OleksandrZhabenko)
12:02:46 <d34df00d> It feels like fixed points and stuff, by my math is lacking.
12:09:49 * hackage base32 0.2.0.0 - Fast RFC 4648-compliant Base32 encoding  https://hackage.haskell.org/package/base32-0.2.0.0 (topos)
12:14:50 <ezzieyguywuf> if I'm doing `(val, state') = runState modState state; (otheVal, state'') = runState otherModState state'; doSomething val otherVal; pure state''` (excuse syntax error), is there a more correct way of doing this?
12:15:09 <ezzieyguywuf> in other words: I need the intermediate values produces by two state changes, and want to output the final state.
12:16:27 <ezzieyguywuf> I can easily do `modState >>= otherModState` to get my final state, but this doesn't hep because `doSomething` needs the intermediate values
12:16:54 <Rembane> ezzieyguywuf: You can do that using do notation like: do; (val1, val2) <- runState s (do; val <- action1; val2 <- action2 val1; pure (val1, val2))
12:17:02 <Rembane> ezzieyguywuf: You can also desugar that 
12:17:54 <ezzieyguywuf> Rembane: ah hah - I had a feeling I could do it this way, but my brain stopped just short of figuring out `pure (val1, val2)`
12:17:57 <ezzieyguywuf> thanks for the help
12:18:24 <Rembane> ezzieyguywuf: No worries, good luck! ^^
12:28:25 <manta93> Hey guys, not sure if this is the right channel to ask but I'm starting my final year of BSc CS in September and I have to do a project which is worth 1/3 of my grade for the year; I'm really keen to use Haskell but I'm struggling to think of a task where it would make sense to use Haskell/Haskell would excel, would anyone be able to point me to
12:28:26 <manta93> problem domains where Haskell would be useful?
12:28:58 <manta93> My supervisor suggested a type checker for a dependently typed language but I think this might be too hard for me
12:29:56 <Rembane> manta93: There's a book about that, it's called The Little Typer and might be worth a look: https://mitpress.mit.edu/books/little-typer
12:32:33 <hyiltiz> manta93: There was a discussion about implementing probabilistic inference (could be as simple as bayes rule or more comprehensive as a markov net/blanket) with ADT and typeclass etc. Does that sound interesting to u?
12:33:19 * hackage telegram-bot-simple 0.3.1 - Easy to use library for building Telegram bots.  https://hackage.haskell.org/package/telegram-bot-simple-0.3.1 (swamp_agr)
12:33:21 <hyiltiz> Problems that have few points of contact with World (less "side effects" needed) should be perfect for Haskell
12:33:34 <Cale> manta93: I think Haskell can excel at most things that don't involve performance constraints which are too harsh (you'd only want to use it as a metalanguage for programming small embedded systems for example). Where I work, we mostly build web and mobile applications (both the frontend and backend) in Haskell using functional reactive programming.
12:34:05 <koz_> I was about to say 'just do something fun as a first concern'.
12:34:25 <younder> I use Mathematica (Wolfram i guess) for that kind of thing.
12:34:29 <koz_> Seriously, it's a _B_Sc, worrying about whether Haskell is a good fit strikes me as very misplaced concerns.
12:34:57 <Cale> But yeah, I think it's better to think first about what you'd like to program generally, and then look at whether there's good library support or if it looks like it'd be too much work treading new ground.
12:34:57 <koz_> Also, I wouldn't recommend The Little Typer as a guide for someone writing a dependent typechecker.
12:35:05 <Lycurgus> or anything that bump ups against a need to recompile, i.e. real time
12:35:07 <koz_> (or in general, but that's a different conversation)
12:36:05 <manta93> I think the type checker might be a bit to ambitious to be honest
12:36:32 <koz_> manta93: It's fiddly, but not that hard.
12:36:34 <Cale> Well, a typechecker or compiler of some sort could be a reasonable project.
12:36:54 <koz_> Like, if you're OK with fiddly or detail-oriented work, it's not too bad.
12:37:08 <koz_> I can link you to some starting materials which I found helpful.
12:41:02 <manta93> koz_ yeah that would be great thanks
12:41:16 <koz_> manta93: One moment, gonna have to do a bit of digging.
12:41:34 <manta93> cheers
12:42:38 <koz_> manta93: Start here: https://crypto.stanford.edu/~blynn/lambda/
12:43:07 <koz_> Read all those, carefully. Try work through the examples as well.
12:43:58 <manta93> koz_ Thank you
12:44:44 <koz_> This is also useful: http://www.cs.ru.nl/~wouters/Publications/Tutorial.pdf
12:45:29 <koz_> For _implementation_ specifically, you may find this useful: https://www.schoolofhaskell.com/user/edwardk/bound
12:46:27 <koz_> If you want a _super_ thorough work-over of the underlying moving parts, I cannot recommend 'Type Theory and Formal Proof' enough.
12:46:45 <koz_> Title sounds scary, but it's the most approachable book of its kind I have found, with no shortage of throughness.
12:48:12 <koz_> There's a few specific implementation-related and cool-idea-related things I can also link, but I think this'll be enough of a jumping-off point.
12:48:34 <ddellacosta> is there something simpler than brick out there for textual UIs? I'm talking the level of table-formatting of output kinda stuff, nothing fancy
12:49:04 <ddellacosta> probably more accurate to say I'm looking for text formatting vs. UI libs
12:49:47 <koz_> ddellacosta: http://hackage.haskell.org/package/prettyprinter
12:50:44 <ddellacosta> oh huh, didn't think of pretty-printing for some reason
12:50:55 <ddellacosta> thanks koz_ 
13:01:54 <frdg`> Is it ok to use printf or are there better alternatives? I am reading that this function is not type safe.
13:02:18 <koz_> frdg`: Depends on how sure you are of what you're getting or doing.
13:02:41 <koz_> I would say that if it's for a one-liner where your input's known, printf is fine.
13:02:47 <[exa]> frdg`: better alternatives for what purpose?
13:03:01 <koz_> If you're doing something more complicated, you might want something else.
13:03:45 <frdg`> Ok I am confident I will be able to control its use
13:05:03 <frdg`> [exa]: My purpose is for creating a not very complex table
13:05:13 <sm[m]> ddellacosta: there’s some libs specifically for tables, like tabular
13:07:03 <frdg`> sm[m]: looks very useful. Would you consider it easy to use?
13:07:12 <[exa]> +1 for tabular
13:07:33 <[exa]> ...and it has the nice (+====+) operator!
13:07:58 <[exa]> frdg`: the example in the docs is super straightforward
13:08:00 <sm[m]> yes, it’s old but quite easy
13:08:16 <sm[m]> hledger uses it
13:08:26 <frdg`> ok Im gonna try it out
13:08:56 <sm[m]> there is another..
13:09:05 <sm[m]> younger.. more impetuous..
13:09:37 <sm[m]> ..but I forgot it’s name. (End of movie)
13:15:22 <koz_> [exa]: I propose naming this operator 'tooth-gritting robot'.
13:17:35 <hseg> hrm. is there a way to monomorphise a typeclass to be :: Type -> Type -> Constraint despite PolyKinds?
13:17:46 <manta93> koz_ I've had a quick read of the Stanford Lambda page
13:18:13 <manta93> Looks interesting but still might be a bit much for me
13:18:53 <manta93> Another project my supervisor suggested was a web server, but that would just be the 'core' of the project, it would need something interesting to make it 'final year project worthy'
13:19:31 <hseg> for some reason, ghc fails to propagate the kinding information: http://ix.io/201d
13:22:43 <hseg> alternatively, have a class Inverts r n where inv' :: proxy n -> r, if there were some way of making it polykinded without PolyKinds that'd suffice
13:26:37 <[exa]> koz_: really adds some tension to the code!
13:40:21 <ezzieyguywuf> is there a way to lookup in a Data.Map by value rather than by key?
13:40:54 <hseg> any ideas how to fix the polykindedness here? http://ix.io/201d
13:42:06 <ezzieyguywuf> I guess I can use Data.List.Find on the Data.Map.assocs
13:42:41 <ezzieyguywuf> although this will return the (k,v) tuple rather than just the k that I'm interested in
13:44:12 <Rembane> ezzieyguywuf: The fastest way is to have two maps, one for each "direction"
13:45:55 <dsal> ezzieyguywuf: Do you want the key?
13:46:30 <dsal> Oh.  If you want the key, then yeah, you'll need to flip it and won't, in general, be able to guarantee that there's only one k for any given v.
13:47:28 <ezzieyguywuf> dsal: yes
13:47:32 <ezzieyguywuf> Rembane: I considered that actually
13:47:43 <Rembane> ezzieyguywuf: What made you change your mind? 
13:48:05 <ezzieyguywuf> Rembane: carrying around a second data structure just for the reverse lookup
13:49:31 <Rembane> ezzieyguywuf: It's only double the amount of memory, not too terrible, depending on the size of the data structures of course. How many elements do you expect there to be in them? 
13:50:44 <ezzieyguywuf> I think instead I'll just use Data.Map.filter, and have my function return a list of all keys that have a matching value
13:50:54 <ezzieyguywuf> this seems the most 'correct' for my application, at least for now
13:51:04 <ezzieyguywuf> software design is hard! lol
13:51:37 <Rembane> Then a lookup is O(n) instead of O(1), but maybe that's not a problem in your case?
13:52:40 <dsal> > let m = M.fromList [("k1", "v1"), ("k2", "v2"), ("k3", "v2")]; vald v = fmap fst . M.toList . M.filterWithKey (\_ v' -> v == v')   in   vald "v1" m
13:52:43 <lambdabot>  ["k1"]
13:52:46 <dsal> > let m = M.fromList [("k1", "v1"), ("k2", "v2"), ("k3", "v2")]; vald v = fmap fst . M.toList . M.filterWithKey (\_ v' -> v == v')   in   vald "v2" m
13:52:49 <lambdabot>  ["k2","k3"]
13:53:30 <ezzieyguywuf> Rembane: I don't think so, this isn't an operation that I expect to be executing all the time
13:53:34 <dsal> I like to use dumb algorithms to prove concepts and then realize they're fine and I don't have to worry about them anyway.
13:53:53 <Rembane> ezzieyguywuf: That's very good. :)
13:54:16 <dsal> wait, that was even dumb for a dumb algorithm.
13:54:40 <hseg> _weird_ ghc will propagate kinding information from the via type, but not the context nor the represented type
13:55:05 <dsal> > let m = M.fromList [("k1", "v1"), ("k2", "v2"), ("k3", "v2")]; vald v = M.keys . M.filterWithKey (\_ v' -> v == v')   in   vald "v2" m
13:55:07 <lambdabot>  ["k2","k3"]
13:55:22 <ezzieyguywuf> :)
13:55:34 <ezzieyguywuf> I think my haskell-fu is levelling up to, things are starting to make more sense
13:55:54 <dsal> > let m = M.fromList [("k1", "v1"), ("k2", "v2"), ("k3", "v2")]; vald v = M.keys . M.filterWithKey (const (== v))   in   vald "v2" m
13:55:56 <lambdabot>  ["k2","k3"]
13:57:24 <dsal> > let m = M.fromList [("k1", "v1"), ("k2", "v2"), ("k3", "v2")]; vald v = M.keys . M.filter (== v)   in   vald "v2" m   -- ooh, dumb.  You're not looking at the key.
13:57:26 <lambdabot>  ["k2","k3"]
13:58:26 <dsal> My brain does weird things sometime.  So, final answer:  `M.keys . M.filter (== v)`
13:59:25 <ezzieyguywuf> dsal: that's what I ended up with
13:59:38 <ezzieyguywuf> except I didn't get it all point-free or w/e it's called
14:01:02 <Boarders> I am trying to get a basic two column editor in brick but I am having trouble that before anything is entered the left column renders nothing and so the initial text on the right column is right aligned
14:01:07 <Boarders> is there a way to deal with that?
14:01:43 <dsal> > let flipMap = M.fromListWith (<>) . (fmap . fmap) (:[]) . fmap swap . M.toList   in   flipMap $ M.fromList [("k1", "v1"), ("k2", "v2"), ("k3", "v2")] -- ezzieyguywuf, you can flip the map around pretty easily, though
14:01:46 <lambdabot>  fromList [("v1",["k1"]),("v2",["k3","k2"])]
14:02:17 <dsal> Can do that with fewer fmaps, but that's kind of stream of consciousness.
14:02:54 <hseg> hrmph. in http://ix.io/202p, consider each the t parameter in each of the declarations. the only way to avoid the error is by constraining Tag's t parameter to be of kind Type
14:03:02 <hseg> why on earth is this the case?
14:04:13 <dsal> (flipMap narrows the allowable value types further, though)
14:29:08 <maerwald> does CPP in the function signature break haddock formatting?
14:34:27 <glguy> maerwald: I think haddock runs late enough in the pipeline now that it probably doesn't
14:34:53 <glguy> but I don't actually know the answer
14:35:36 <maerwald> the constraints are not line broken here, although they are very long
14:52:49 * hackage aura 3.1.6 - A secure package manager for Arch Linux and the AUR.  https://hackage.haskell.org/package/aura-3.1.6 (fosskers)
15:02:22 <koz_> :t bitraverse
15:02:23 <lambdabot> error:
15:02:23 <lambdabot>     • Variable not in scope: bitraverse
15:02:23 <lambdabot>     • Perhaps you meant one of these:
15:02:37 <ja> % :t bitraverse
15:02:38 <yahb> ja: ; <interactive>:1:1: error:; * Variable not in scope: bitraverse; * Perhaps you meant one of these: `itraverse' (imported from Control.Lens), `traverse' (imported from Prelude), `gtraverse' (imported from Data.Data.Lens)
15:04:36 <ski> @hoogle bitraverse
15:04:36 <lambdabot> Data.Bitraversable bitraverse :: (Bitraversable t, Applicative f) => (a -> f c) -> (b -> f d) -> t a b -> f (t c d)
15:04:36 <lambdabot> Relude.Foldable.Reexport bitraverse :: (Bitraversable t, Applicative f) => (a -> f c) -> (b -> f d) -> t a b -> f (t c d)
15:04:36 <lambdabot> Data.Text.PgpWordlist.Internal.AltList bitraverse :: Applicative f => (a -> f c) -> (b -> f d) -> AltList a b -> f (AltList c d)
15:14:43 <younder> It it is all applicable why not just write it in C?
15:19:14 <dsal> ?
15:19:37 <jle`> younder: are you asking about advantages of choosing to write something in Haskell over C?
15:20:03 <koz_> Hi jle`!
15:20:08 <koz_> Good to see you around.
15:20:14 <jle`> koz_: hi :) you too!
15:20:30 <jle`> how's it been going?
15:20:47 <koz_> It's been good, though I haven't had the energy to do more personal Haskell work lately.
15:20:58 * koz_ looks at finitary-derive still rotting.
15:21:00 <jle`> ah haha. i've felt the same over the past few months actually
15:21:04 <jle`> i guess that's just the 2020 blues
15:21:15 <koz_> Yeah, well, that is a contributor, yes.
15:21:47 <koz_> Also, LiftCardinality can't be written even with QuantifiedConstraints on.
15:21:53 <koz_> (GHC hard nopes)
15:22:08 <jle`> :(
15:22:17 <jle`> yeah i can't even get stack to work with ghc 8.10
15:22:22 <koz_> Although trying something like that uncovered a GHC bug.
15:22:25 <jle`> so that's somewhat stopping me from keeping up with the latest
15:22:32 <koz_> Aren't there 8.10 nightlies?
15:22:39 <jle`> yeah, none of them can build for me
15:22:44 <koz_> Weird.
15:22:58 <jle`> i run into some errors when stack tries to install ghc 8.10 itself, even though i have a system ghc 8.10 that works fine
15:23:02 <koz_> I haven't tried (work is on 8.8 thanks to me, and personally I just use cabal v2-*)
15:23:04 <jle`> maybe it's just time to switch to cabal-install
15:23:19 <jle`> we all knew this day would come
15:23:37 <koz_> Yup, that we did.
15:24:55 <jle`> i did find work writing haskell though so at least i still have haskell in my dayjob :) if not in my personal hobbying
15:25:10 <koz_> Oh? Who're you with?
15:26:10 <jle`> simspace :O 
15:26:37 <koz_> Intriguing.
15:26:51 <koz_> I'm technically with Juspay, although I'm a subcontractor.
15:27:04 <koz_> (or, as I prefer to word it, a sub)
15:27:08 <koz_> (:P)
15:27:13 <xsperry> Cale, you mentioned building web applications using functional reactive programming. what library do you use?
15:32:39 <dmj`> xsperry: reflex-dom
15:42:55 <Cale> xsperry: dmj` is correct :)
15:42:59 <Cale> xsperry: Also, Obelisk
15:43:21 <Cale> (which is our more general framework that includes some of the backend stuff)
15:45:24 <ash_b> I have some questions about hashmap space performance in Haskell and GHCJS. How good is the garbage collector about cleaning up deleted key-value pairs? I'll describe my desired use case in my next messages:
15:46:06 <Cale> It should be reasonably good?
15:46:31 <Cale> As long as you've *actually* lost the reference to the key and value
15:49:02 <ash_b> I'm designing a browser-based musical keyboard that can play multiple notes at a time through the Web Audio API synth oscillators. The program will need to maintain a map between keyboard notes and any oscillators corresponding to those notes that exist in the audio context. So most of the time map keys would be added and deleted fairly quickly, but if there's a sustained note being played, it's possible that one or two 
15:49:02 <ash_b> KV pairs would stick around for a while while others are added and deleted. I want to make sure the space allocated doesn't leak over time.
15:49:21 <Cale> Oh hey
15:49:33 <Cale> I was planning to do something very much related to that :D
15:49:56 <Cale> (though I would just use the MIDI API so that I can route everything through PianoTeq...)
15:49:57 <ash_b> Oh nice!
15:50:39 <Cale> I've been messing around with this horrible Javascript monstrosity which nevertheless produces nice hex-grid keyboards that can be played via my tablet
15:50:54 <Cale> https://cale.l5.ca/terpstrakeyboard/keys.htm
15:51:35 <ash_b> I don't plan to use MIDI because this is a microtonal keyboard, and I think having to deal with MIDI channels and pitchbends would make the code far more cumbersome and harder to understand & maintain.
15:51:38 <Cale> I hacked in MIDI and "MPE" support (multichannel output with pitch bends to tune notes)
15:51:45 <Cale> ah, haha
15:52:10 <Cale> It's not actually all *that* bad I've found.
15:52:12 <Cale> But yeah
15:52:37 <infinisil> ash_b: Regarding your question, it doesn't depend on GHC/GHCJS whether unneeded memory gets released, but rather on the code (namely whether it has memory leaks or not)
15:52:42 <Cale> One thing that caught me off guard about it, in case you ever try, is that it's important to assign notes to the least recently used channel
15:52:43 <ash_b> Oh hey I've used that before!
15:52:56 <Cale> You probably used the not-hacked-up version
15:53:03 <Cale> unless I linked it to you before
15:53:05 <ash_b> Yeah
15:53:11 <ash_b> The former
15:54:09 <ash_b> I'm working on a browser-based Tonal Plexus keyboard with a chord builder.
15:54:13 <Cale> I also added midi aftertouch signals, so that I can bend the notes if I want -- the aftertouch is proportional to the current distance from the most-central point you've reached in any hexagon
15:54:40 <ash_b> Thanks Silvan!
15:54:50 <Cale> oh, nice
15:56:56 <Cale> Well, you can't always 100% rely on GC happening in a timely fashion, it kind of depends on exactly what you need, but GHC's collector is pretty good at dealing with lots of short-lived garbage
15:57:40 <Cale> If you want to see how rapidly the collector runs, there's a really annoying RTS flag you can pass
15:58:29 <Cale> +RTS -B
15:59:07 <Cale> it'll beep at the start of each collection
15:59:08 <infinisil> ash_b: I'm surprised to be mentioned by real name :o
15:59:35 <ash_b> Fully-optimized low latency isn't a requirement - this is more of a compositional tool, so as long as it's not too bad some occasional lag is okay.
15:59:54 <Cale> You'll probably be fine, really
16:01:04 <infinisil> I'd just occasionally check memory usage and only investigate further when you discover an obvious leak
16:01:14 * ski was wondering who ash_b was referring to
16:01:29 <Cale> Oh yeah, I was going to say more about the least recently used channel thing -- the reason for that is that if you have a synth which is sustaining the notes, their tails can last quite a while after the midi-off event, but the pitch bends will still bend those tails unfortunately
16:02:33 <Cale> The effect is *very* noticeable if I go sweeping across a bunch of different key centres in 53-ed2 or something, when assigning notes to the first available channel
16:02:58 <Cale> But it becomes practically unnoticeable if you just put the channels into a queue
16:03:19 <ash_b> infinisil I'm using IRCCloud, which displays full names next to usernames if available - this is my first time using IRC, still working out the conventions!
16:04:08 <infinisil> Ah I see, yeah using nicknames is the way to go, this way people will also get pinged for replies :)
16:04:21 <ski> ash_b : yea, normally you're refer to people, using their nicknames
16:04:37 <ash_b> Gotcha
16:04:42 <Cale> (Most IRC clients don't make the real names as prominent as that)
16:04:49 <ash_b> Thanks all! I think I have enough to go on now.
16:04:58 <ash_b> And for the IRC tips!
16:05:30 <ski> (some people might consider it a bit rude to mention their legal name like that for no particular reason)
16:06:38 <ash_b> ski : Gotcha, thanks for the heads-up!
16:08:07 <ski> no worry
17:18:29 <maerwald> https://files.hasufell.de/jule/ghcup/GHCup.html -- this looks quite weird... can you not tell haddock to linebreak long lines? The argument docs are barely readable
17:22:38 <glguy> I don't know how to do that, but worst case you name that mess of constraints once and for all with ConstraintKinds so you don't have to repeat it everywhere
17:22:55 <glguy> and people can know without manually checking all the occurences that it actually repeats
17:24:19 <maerwald> mess of constraings -> yes hello mtl :p
17:24:23 <monochrom> Buy a 160:9 display :)
17:27:59 <maerwald> 160:9?
17:28:06 <maerwald> where the hell do you get that
17:30:11 <glguy> not exactly that ,but something for maerwald : https://www.dell.com/en-us/work/shop/dell-ultrasharp-49-curved-monitor-u4919dw/apd/210-arnw/monitors-monitor-accessories?gacd=9646510-1025-5761040-0-0&dgc=st&gclid=Cj0KCQjwpNr4BRDYARIsAADIx9wdgBpprY0Db10GSaHbd7dRXmaZrpWuuaYooF1tOS0LoErUCSVfglUaAr3DEALw_wcB&gclsrc=aw.ds
17:30:37 <maerwald> And I send the bill to the haddock maintainers? :)
17:31:01 <glguy> Yeah, can't hurt to try. worst case you just won't find an address to send to
17:32:06 <glguy> 5120 x 1440 at 60Hz
17:32:52 <maerwald> for that you need xmonad and write some rules to not expand every single window to the edges
17:32:53 <glguy> so basically the same pixel width as my 24" but stretched out over 49"
17:33:11 <glguy> err, maybe I have a 27"
17:35:21 <monochrom> I was just joking :)
17:38:39 <dansho> hi, does anyone know of a guide to developing haskell libraries on local machine (not hackage) on nixos?
17:39:20 <dansho> i have a development environment set up but i always get "[__1] unknown package: mylib (dependency of myexe)"
17:39:24 <dansho> https://hastebin.com/arinojamok
17:40:51 <Cale> dansho: That looks more like a cabal problem than a nix problem... what's your cabal file look like?
17:43:42 <dansho> Cale, https://hastebin.com/ginopehogi
17:44:21 <Cale> dansho: That depends on mylib, but it doesn't define it
17:45:34 <dansho> Cale, mylib.cabal is this https://hastebin.com/ocevekones
17:45:55 <Cale> ah, okay, does mylib build?
17:46:32 <dansho> yes
17:51:23 <Cale> So, you need to get into a shell which has it built I guess.
17:53:31 <dansho> i am in myexe/shell.nix which has this line: drv = variant (haskellPackages.callPackage f { mylib = ../mylib; });
17:53:33 <dansho> that doesn't build mylib?
17:53:57 <Cale> hmm
17:58:06 <Cale> try...
18:00:22 <Cale> Wait, how does that nix work at all?
18:00:36 <Cale> mylib is set to the path ../mylib
18:00:44 <Cale> i.e. not a derivation
18:01:01 <Cale> and then that's being set as one of the executableHaskellDepends
18:01:15 <dansho> mylib is a directory containing mylib/default.nix
18:01:24 <Cale> Shouldn't you at least have to import it?
18:02:10 <Cale> also, I'd usually use callCabal2nix rather than writing that stuff out
18:02:24 <crestfallen> Cale, hi
18:02:48 <crestfallen> just the person I was hoping to see
18:03:04 <dansho> well these were generated using cabal2nix
18:03:33 <Cale> yeah, unless you're going to customise it, might as well just let callCabal2nix run cabal2nix for you
18:06:17 <crestfallen>  Cale I have some questions on our earlier project, which compiled : https://termbin.com/14nx      if you have time
18:06:48 <Cale> sure
18:06:58 <crestfallen> wow what luck thanks!
18:07:48 <crestfallen> you see, I'm confused still because the instances I have with state are for the ST transformer a la mr. hutton
18:08:12 <crestfallen> so first of all I'm having trouble distinguishing the differences
18:08:31 <Cale> I don't think Hutton defines ST as a transformer, does he?
18:08:49 <crestfallen> idk , what does ST signify?
18:09:23 <Cale> How does he define ST?
18:09:34 <crestfallen> one moment please I'll paste it
18:09:51 <ja> @src ST
18:09:51 <lambdabot> newtype ST s a = ST (STRep s a)
18:10:04 <ddellacosta> sm[m]: thanks, checking out tabular now
18:10:15 <ja> wow, why is ST a newtype?
18:10:25 <ja> if it is exactly the same as the underlying?
18:10:48 <Cale> I think STRep is probably a type synonym there
18:10:58 <Cale> But this is a different ST we're talking about, unfortunately
18:11:24 <Cale> I seem to recall ST was just a particular State monad, without a polymorphic state type parameter
18:11:32 <crestfallen> hence my confusion, sorry, having a hard time. pasting now...
18:11:34 <Cale> But I forget
18:11:46 <crestfallen> https://termbin.com/emnt    < first module
18:12:13 <Cale> Also, ST in the Haskell standard library is not a monad transformer either, it's just a very different monad, which allows for imperative mutable references
18:12:55 <Cale> So yeah, what he's calling ST there is the same thing as  State Int  in your new code
18:13:09 <crestfallen> yeah all this is killing me frankly.  hopefully this will look familiar to you : https://termbin.com/u1dq
18:13:45 <Cale> sure
18:13:53 <Cale> That's a classic example
18:14:01 <crestfallen> that is hutton as best as I can render
18:14:10 <Cale> I think the documentation for Control.Monad.State even includes that one
18:15:41 <crestfallen> ok thanks, perhaps in the state monad you helped me with, down at the bottom I wrote your example into the function 'vv'
18:15:58 <crestfallen> ignore 'perhaps'
18:16:16 <crestfallen> in that first paste
18:16:23 <Cale> sure
18:16:41 <Cale> Perhaps a better name for that is 'increment'
18:16:52 <Cale> since it increments the current state
18:16:55 <crestfallen> so tbh I can't understand how that can be run with a simple state instance
18:17:06 <dansho> Cale, got some help from #nixos, this ended up working: https://hastebin.com/vuhigizela.nix
18:17:27 <crestfallen> (ok changing the name!)
18:17:53 <Cale> dansho: ah, okay, yeah, that looks saner. callPackage will import it and do some magic.
18:19:34 <Cale> (passing it arguments based on the names of its named parameters, which is just a gross thing that people do in the nix world)
18:20:57 <Cale> crestfallen: So, to run it, you can use runState on it, and then you'll get a function to which you can pass the initial state you want to use
18:21:09 <Cale> So like,  runState increment 5
18:21:17 <Cale> and you should expect to see (6,())
18:21:48 <Cale> the final state will be one more than the provided initial state, and the result will be () because the last action was a put, and put always produces () as its result
18:22:21 <crestfallen> ok thanks , trying that.   also I'm trying to see connection with hutton's 'fresh' function and our 'increment' function
18:23:59 <crestfallen> Cale, do you think I should disregard hutton's example for a time - and focus on the example you and I wrote?
18:29:02 <ski> heya crestfallen
18:29:08 <crestfallen> ski !
18:29:30 <crestfallen> just getting raked over the coals on state, still
18:30:31 <crestfallen> I understand the idea behind state, it's simple. but implementing everything...
18:31:11 <crestfallen> I don't want to quit learning haskell
18:31:39 <dsal> What part's confusing?
18:31:50 <dsal> It might be one of those things that's so simple you assume it's hard and don't get it.
18:32:16 <Cale> crestfallen: yes
18:32:28 <Cale> crestfallen: His example is the same as ours, but with more confusing names for things
18:32:39 <crestfallen> Cale excellent I'd be happy to :)
18:32:45 <xsperry> Cale, dmj`, thanks, I'll give that library a try next time I'm doing a web application
18:33:15 <dmj`> xsperry: check out https://haskell-miso.org as well :)
18:33:30 <crestfallen> dsal I can't explain it well or quickly. Ca.le is trying to help me sort it
18:33:36 <xsperry> ok!
18:34:02 <ski> crestfallen : your three pastes look okay, to me
18:34:13 <hyiltiz> How can I define f? It seem some kind of fixed point operator is needed
18:34:15 <hyiltiz> f t = g (t, snd $ g (t,_) h) h
18:34:24 <hyiltiz> that _ inside is just another repeat 
18:34:35 <dsal> hyiltiz: Usually you want to start with the type.  What do you want f to be?
18:34:51 <crestfallen> ski yeah thanks Ca.le just agreed I should drop the hu.tton version for now
18:34:56 <ski>   f t = x where x = g (t,snd $ x) h  -- ?
18:35:20 <hyiltiz> ski++
18:35:30 <hyiltiz> I feel like I am close to solving your homework ;D
18:35:30 <ski> crestfallen : you understand `reLabel' ?
18:36:11 <ski>   f t = fix (\x -> g (t,snd $ x) h) -- if you prefer
18:36:32 <hyiltiz> no wonder I felt I was looking at a YC
18:37:22 <crestfallen> ski one sec
18:40:37 <hyiltiz> snd $ x and x has different types; doesn't type check
18:40:51 <hyiltiz> https://termbin.com/hrwl
18:41:05 <hyiltiz> See Attempt 4, repMin'' definition through mapTree
18:41:53 <hyiltiz> Manually expanding it would be repMin'' t = mapTree (t, snd $ mapTree (t,snd $ mapTree (t, snd $ _)) min) min
18:42:01 <crestfallen> ski so yeah newtype State s a = S { runState :: s -> (s,a) }   that result is reversed, compared with the hutton declaration of ST: newtype ST a = S (State -> (a,State))       
18:42:03 <crestfallen> right?
18:43:04 <crestfallen> the dummy constructor, the Removal of the dummy constructor, the naming ST, it's all confusing me. 
18:46:15 <ski> hyiltiz : attempt 4 is getting closer
18:46:33 <hyiltiz> :D
18:47:03 <liiae> what is Functor compose?
18:48:34 <crestfallen> Cale, hi you still on?
18:49:31 <ski> crestfallen : yes, reversed
18:50:57 <crestfallen> ski thanks ok ..
18:51:12 <hyiltiz> repMin'' t = fst $ mapTree (t, x) min where x = snd $ mapTree (t, x) min
18:51:13 <Cale> crestfallen: Yeah, sorry, also got into a discussion on music theory on another channel :)
18:51:15 <ski> hyiltiz : anyway, you have some strange things going on
18:51:17 <hyiltiz> This went into recursion hell
18:51:47 <ski> hyiltiz : in the definition of `pr', i think you meant to use `rt', not `lt', right ?
18:52:15 <crestfallen> Cale,  really? I dropped haskell for a bit and have been learning spanish through colombian music
18:52:51 <hyiltiz> yes ski , thx! Just fixed
18:53:10 <hyiltiz> I am at a point where it is very close to blowing my mind and hurt a little
18:53:16 <crestfallen> so yeah I'd like to master the application we wrote together before looking at hutton's again Cale
18:53:17 <ski> hyiltiz : and in place of `fst' and `snd', i'd suggest matching on pairs
18:53:58 <crestfallen> and we have this function get , put , and give
18:54:08 <crestfallen> *these functions
18:54:22 <hyiltiz> When I read `(first,last) go last xs first` https://wiki.haskell.org/Tying_the_Knot#Migrated_from_the_old_wiki, it hurt a bit since `last` was't defined when first invoked; I tried going along with it thinking lazy evaluation but couldn't follow thru till the point it "ties the knot"
18:54:29 <ski> `give' looks like `pure'/`return'
18:54:43 <ski> (perhaps `give' is what Hutton called it, in that chapter)
18:55:04 <crestfallen> so it's all quite new. I am not in a position to see how this is similar to hutton's with 'fresh'.. as the increment function?
18:55:16 <hyiltiz> But `fst` `snd` are themselves defined thru pattern matching... not sure how that would clarify things
18:55:18 <hyiltiz> lemme try
18:55:27 <ski> crestfallen : s/function/action/
18:55:59 <crestfallen> ski no I named that without full comprehension. oh ok yeah action
18:57:03 <monochrom> (fst (f args), snd (f args)) has the tendency to re-compute "f args" for the 2nd time.
18:57:58 <hyiltiz> monochrom: thx
18:58:11 <ski> in this case they were applied to an identifier
18:58:59 <crestfallen> right yes so give is like return. so ski only the state is altered there?
18:59:10 <monochrom> fst var, snd var is OK
18:59:13 <crestfallen> or is neither altered?
18:59:26 <ski> rather, the state is not touched, by `return'/`pure'/`give'
18:59:59 <hyiltiz> Is there a some value/Nil/() that belongs to any type? Specifically, I want to write mapTree (Leaf v, ()) f = (Leaf x, v) as the edge condition for mapTree (Leaf v, x) f = (Leaf x, f v x)
19:00:13 <monochrom> But by the time you do "let var = f args in .... fst var ... snd var ..." you may as well use a pattern: "let (v1, v2) = f args in ... v1 ... v2 ..."
19:00:19 <ski> in this case, imho, it'd be more handy to give names to the two components of the pair, directly
19:00:41 <ski> yes, what monochrom said
19:01:00 <ezzieyguywuf> what is haskell'?
19:01:04 <monochrom> In this case of merely standard 2-tuple, it is not a big deal, sure.
19:01:07 <crestfallen> ski I think that would help me out
19:01:21 <ski> which ?
19:01:32 <hyiltiz> crestfallen: I thought monochrom was talking to me?
19:01:51 <monochrom> yes
19:01:55 <crestfallen> oh I think we are both working with a pair, sorry hyiltiz 
19:02:20 <crestfallen> I thought ski was suggesting I name a pair differently
19:02:41 <ski> hyiltiz : btw, i dunno why you're calling it `mapTree' .. doesn't seem like a "map" to me. but that's a minor point
19:02:43 <monochrom> "fst" and "snd" are short names. That 
19:02:53 <monochrom> 's a main factor for why it is not a big deal.
19:03:24 <ski> hyiltiz : anyway, should i go on, or would you maybe want to show the code you get, using pattern-matching on pairs, instead ?
19:03:35 <monochrom> But you will run into more complex types that have annoyingly lengthy selector names. Then your code goes on forever to the right side.
19:04:08 <ski>   let Node {rootLabel = r,subForest = ts} = ... in ..r..ts..
19:04:15 <hyiltiz> ski: pls wait a sec; I wanna try not using fst snd
19:04:21 <monochrom> Also if you have a 3-tuple, there are no standard selectors fst snd thrd.
19:04:35 <monochrom> unless you XY-problem it and lens the hell out of it.
19:04:39 <hyiltiz> isn't quite obvious to me how to do away with them; gotta think a bit...
19:04:47 <ski> in SML, tuples are records that have numeric field names
19:04:55 <hyiltiz> haskell is so humiliating/enlightening
19:05:09 <ski> it's wonderful
19:05:34 <monochrom> fst and snd are bad habits coming from pre-ADT Lisp design IMO
19:07:39 <liiae> :t flip ($)
19:07:40 <lambdabot> a -> (a -> c) -> c
19:07:49 <monochrom> Another angle is that "let (v1, v2) = f args in g v1 v2" requires fewer parentheses than "let v = f args in g (fst v) (snd v)"
19:08:13 <liiae> why (a->b) -> b is equi to a?
19:08:21 <monochrom> This difference doesn't show up in Lisp. is why the Lisp people don't see the problem.
19:09:03 <ski> liiae : rather `forall b. (a -> b) -> b'
19:09:44 <liiae> ski: why it's equivalent to a?
19:09:49 <solonarv> liiae: they are "equal" in the sense that you can losslessly convert from one to the other
19:10:32 <solonarv> if you have 'k :: forall b. (a -> b) -> b', what is the type of 'k id' ?
19:11:12 <liiae> solonarv: b only when a -> b is id
19:11:25 <liiae> or a?
19:11:49 <liiae> a only when a -> b is id
19:11:50 <ski> liiae : it's a function. functions boil down to lambdas. so assume the function can be written as having the shape `\k -> ..k..'. now, the type of `k' is `a -> b', while the type of `..k..' is `b'. and this function is polymorphic, it doesn't know which type `b' the caller will pick for it. so the only way it can compute a result `..k..' of type `b' is by calling `k' (with some value of type `a'). so `\k -> k x', where `x' is that value of type `a'
19:12:39 <liiae> so when x :: a, and k is id, then k x :: a
19:13:05 <ski> yes. but the function doesn't know that the caller picked `b' to be `a', when passing `id' for `k'
19:13:06 <liiae> but what's the meaning? 
19:13:13 <crestfallen> ski Cale I just plugged in give in this function 'purre' https://termbin.com/acuz    now what's it doing?
19:14:04 <Cale> Well, that's getting the current state and then, if the current state was n, it's returning (n+1)
19:14:08 <liiae> if k isn't id, then (a->b)->b couldn't be equivilent to a?
19:14:12 <Cale> give was your renaming of return
19:14:26 <Cale> You might want to actually define return in the instance
19:14:46 <Cale> Seems to be missing
19:14:46 <ski> crestfallen : `purre = fmap (+1) get'
19:14:53 <solonarv> liiae: "equivalent" means "if we have 'f :: forall b. (a -> b) -> b', we can recover an 'x :: a' somehow"
19:15:19 <crestfallen> phew I'm just in pain
19:15:53 <solonarv> (and also "if we have 'x :: a', we can somehow produce 'f :: forall b. (a -> b) -> b'"; but we are focusing on the first direction for now)
19:15:59 <liiae> solonarv: what CPS has to do with this?
19:16:11 <ski> crestfallen : generally, `ma >>= \a -> return (f a)' is equal to `fmap f ma'
19:17:26 <crestfallen> ok thanks. is using give in that purre function a good example? I just sort of plugged it in to see if it would compile.
19:17:45 <solonarv> liiae: CPS works because of this equivalency, that's all
19:18:06 <ski> it's good to play around a bit, to try to learn about how the pieces can fit together, and what they'll do
19:18:56 <crestfallen> what about Cale 's suggestion, to define return in the instance? not sure I get that
19:19:26 <Cale> crestfallen: Take the definition of "give", rename it "return" and put it in the Monad instance there
19:19:57 <Cale> crestfallen: Currently your Monad instance is missing a definition for return, even though the Applicative instance defines pure to be the same as whatever return is
19:20:06 <hyiltiz> https://termbin.com/vjnu Still dives into the abyss of infinite recursion
19:20:23 <Cale> I believe the default implementation in Monad will define return to be whatever pure is, so currently it'll just loop
19:20:29 <crestfallen> so that would be the last action before closing with the 'in' keyword?
19:20:43 <Cale> huh?
19:20:54 <Cale> I mean, alongside that definition of (>>=)
19:21:02 <Cale> There are two methods in Monad
19:21:04 <ski> hyiltiz : ok, good
19:21:07 <Cale> (>>=) and return
19:21:22 <hyiltiz> sorry if I made u frustrated with my incompetence
19:21:31 <ski> hyiltiz : now, you're mixing up the global min that you get as input, with the local min (of the current subtree) that you're computing
19:21:36 <crestfallen> ok the indentation is crucial there I believe
19:21:38 <ski> nah, is okay
19:21:58 <Cale> Yeah, it should be indented 2 spaces to line up with the x in "x >>= f = ..."
19:21:59 <ski> hyiltiz : here i think monochrom's suggestion is good
19:22:14 <Cale> because both definitions are part of the 'where' clause for the instance
19:22:38 <hyiltiz> yeah but how in the dear mother Earth and under the mighty father Sun can we traverse only once to both get a global property AND overwrite it at the same time?
19:22:51 <ski> <monochrom> hyiltiz: ski means Ord a => Tree a -> b -> (Tree b, a).
19:23:10 <ski> in your case, you take the two parameters in a pair. and you also added `min' as an extra explicit parameter
19:23:23 <monochrom> how do you pull up a yesterday quote so quickly? :)
19:23:33 <ski> note that the `b' input here is the global min, while the `a' output is the local min
19:23:52 <ski> monochrom : i had already looked it up, a little while ago ;)
19:23:58 <hyiltiz> ski: that is what overTree is doing, isn't it? It creates a new tree, overwriting it with a b value
19:24:22 <ski> yes, hyiltiz
19:24:49 <ski> now, can you adapt your `overTree' type signature to the idea of the signature given by monochrom ?
19:25:10 <hyiltiz> sure; should be simple to get rid of `f` there
19:25:49 <ski> (monochrom : in fact, even before you turned up presently, in this conversation)
19:26:54 <hyiltiz> btw that type sig. should in fact drop "Ord a=>" constraint right?
19:26:55 <ski> hyiltiz : note i only asked, so far, to adapt the type signature
19:27:09 <ski> yea, since you added the explicit `min' parameter
19:27:10 <hyiltiz> It doesn't care
19:27:14 <ski> you don't need the `Ord a
19:27:17 <ski> ' there, then
19:27:38 <hyiltiz> k gimme a s/sec/several minutes/
19:28:51 <crestfallen> thanks Cale, I have it like this now     https://termbin.com/e7by
19:30:20 <ski>   (match (f args) ((cons v0 v1) (g v1 v2)))
19:30:27 <ski> seems to require fewer brackets than
19:30:34 <ski>   (let ((v (f args))) (g (car v) (cdr v)))
19:30:35 <ski> btw
19:31:20 <crestfallen> but it seems like the purre function returns the incremented state in the second position of the tuple, so I'm a bit fuzzy Cale
19:31:29 <ski> (and using a `let1' or a `match-let' doesn't seem to change this)
19:31:55 <ski> good, crestfallen
19:32:51 <ski> crestfallen : the second position (for the definition of `State' you have there) is the "result value" (as opposed to the "output state")
19:33:22 <crestfallen> oh yeah the output state is unchanged ski
19:34:08 <ski> note that `put' replaces the state. discarding the input state, letting the output state be the explicit parameter of `put'
19:34:36 <ski> (and for `put', the "result value" is just `()', a "nothing interesting here" value)
19:35:26 <ski> while `return'/`pure' (you previous `give') keeps the state, using the input state as the output state. while using the explicit parameter of `return' as the "result value"
19:38:00 * ski idly wonders where the `purre' name came from
19:38:33 <hyiltiz> https://termbin.com/x09a
19:38:37 <hyiltiz> This seems to be working
19:39:07 <hyiltiz> Apparently it traverses only once, and line 79-80 "ties a knot"
19:39:12 <ski> oh, you changed back to `mapTree' ?
19:39:25 <hyiltiz> See Attempt 6
19:39:35 <hyiltiz> overwriteTree
19:39:36 <ski> oh, added more attempts
19:40:10 <ski> yes !
19:40:21 <hyiltiz> this is pure dark magic
19:40:24 <ski> you figured out you shouldn't pass the global min to `f'
19:40:38 <hyiltiz> Somehow I followed type signatures and wrote an algorithm I still do not believe is possible
19:40:52 <ski> also, instead of `minv = x', you can just rename `minv' to `x' (or vice versa, if you prefer), in `repMin6'
19:41:01 <hyiltiz> that global min is apparently to be "bootstrapped" in
19:41:08 <ski> (and, if you prefer, you could use `where' instead of `let')
19:41:25 <hyiltiz> I found that, but liked the explicit "tying" of the knot
19:41:42 <ski> even just
19:41:42 <hyiltiz> which started all these conv. that lasted over 24h
19:41:45 <ski>   repMin6 t0 = t
19:41:47 <ski>     where
19:41:57 <ski>     (t,minv) = overwriteTree t minv
19:42:07 <ski> would be an explicit tying-the-knot
19:42:23 <ski> (er, sorry. input to `overwriteTree' should be `t0' there, obviously)
19:42:29 <hyiltiz> well I do like where more than let in
19:42:57 <ski> the point is that we're passing back an output of the call, back as an input, of the same call
19:43:37 <ski> but, in the definition of the function, we make sure not to "look" at the "late input" `x', the global min, when computing the "early output", the local min
19:43:41 <ski> otherwise, this couldn't work
19:44:02 <ski> basically, we have something like
19:44:04 <crestfallen> ski one moment please
19:44:22 <ski>   foo :: EarlyInput -> LateInput -> (EarlyOutput,LateOutput)
19:45:10 <ski> and, the initial call to `foo' (your `overwriteTree', called initially from `repMin6'), computes the `LateInput' from the `EarlyOutput'
19:45:37 <hyiltiz> What about the first and the last outputs?
19:46:04 <hyiltiz> Where does the first "minv" comes from? (I can hear you'd say from its own output)
19:46:19 <hyiltiz> Where does the 2nd ... come from...
19:46:27 <hyiltiz> then where does the last one come from?
19:46:49 <ski> (in your case, you simply passed back the early output, the local min (which, since this was the initial call, passed the whole tree, is also the global min in the tree), as the global min parameter of that initial call)
19:46:49 <ski> (in your case, you had the early output and the late output in the opposite order, in the output pair)
19:47:12 <hyiltiz> the last two sentences seem unintelligible to me, sorry
19:47:21 <ski> the local minimum is computed bottom-up. the value in each leaf is the local minimum of that leaf
19:47:28 <hyiltiz> could u use more named variables and less pronouns pls?
19:47:44 <ski> then the local minimum of a branch is the minimum of the two local minima in the two direct subtrees
19:48:38 <hyiltiz> if that is how it worked, it would traverse once all the way down, and another time all the way back up?
19:49:15 <ski> in the `Leaf' case, `v' is the value. it is the local minimum of this tree (only consisting of a leaf). you pass it back as "early output" (in your case the second component of the output pair)
19:50:10 <ski> then, in the `Branch' case, you call recursively on the two direct subtrees, and get back (as second components of the resulting two pairs) the respective local minima of those two trees, and you called these local minima `lv' and `rv'
19:50:48 <ski> then you compute the minimum of these, `min lv rv', and present this as the "early output" in the `Branch' case (second component of output pair)
19:50:54 <ski> hyiltiz : is that clearer ?
19:51:16 <hyiltiz> yes, so far, it is clear
19:51:23 <ski> hyiltiz : "if that is how it worked, it would traverse once all the way down, and another time all the way back up?" recursion will walk the tree to the leaves, and back up again, yes
19:51:32 <ski> (a single traversal)
19:52:04 <ski> if you have
19:52:11 <ski>   sum [    ] = 0
19:52:23 <ski>   sum (n:ns) = n + sum ns
19:53:03 <ski> the same thing happens. you traverse the list til the end, then you back out of the recursion (performing the additions, in this case)
19:53:32 <ski>      sum (2:3:5:7:[])
19:53:40 <ski>   =  2 + sum (3:5:7:[])
19:53:47 <ski>   =  2 + (3 + sum (5:7:[]))
19:53:49 <hyiltiz> [1 .. n] ++ [n,n-1, .. 1] is surely traversing twice, a total of 2n, no?
19:53:55 <ski>   =  2 + (3 + (5 + sum (7:[])))
19:54:08 <ski>   =  2 + (3 + (5 + (7 + sum [])))
19:54:55 --- mode: ChanServ set +o ski_
19:56:04 <hyiltiz> Hmm, so we get accumulate local minimums *while* expanding/unpacking/traversing the tree, and once we reach of bottom/edge/leaf of the tree, we rewrite the whole tree/crete a new tree with the same shape but with that global minimum we just accumulated?
19:57:29 * ski sighs
19:58:34 <ski>   =  2 + (3 + (5 + (7 + 0)))
19:58:54 <ski>   =  2 + (3 + (5 + 7))
19:59:02 <crestfallen> ski thanks so much . I gotta go but that was very helpful!
19:59:03 <ski>   =  2 + (3 + 12)
19:59:10 <ski>   =  2 + 15
19:59:12 <ski>   =  17
19:59:35 <ski> note how the recursion first causes the context around the current call to grow, and then decrease again
19:59:43 <hyiltiz> -*- hyiltix thanks ski for his/her patience
20:00:00 <ski> crestfallen : have fun
20:00:08 <hyiltiz> yes?
20:00:12 <crestfallen> thanks
20:00:26 <ski> /me bows to hyiltiz
20:00:29 * ski bows to hyiltiz
20:00:39 * hyiltiz bows back to ski
20:00:42 <hyiltiz> :D
20:01:08 <ja> are we all doing yoga in here or what ? ;)
20:03:09 <hyiltiz> ski: but in our case, the context around the values first decrease (deeper branches) then grows, right?
20:04:02 <ski> hm, how do you mean ?
20:07:10 <hyiltiz> In the deeper stages of the call stack, the left output of overwriteTree has... oh I realize it has more context around it, not less 
20:07:11 <hyiltiz> gotcha
20:07:43 <hyiltiz> hmm, so it would be the same if I used a list for the excersise, repMin for a list, not a tree
20:09:11 <hyiltiz> Traverse the list while accumumulating the local mininums and keeping track of the shapes/context/length, then finally creating a new one of the same shape, using the global minimum, right?
20:10:31 <ja> so, i am working with these forests of perfect binary trees encoded in arrays where node 0 is the first leaf on the bottom row. i have functions to go up and down the tree, but of course they all take the height of the tree, since that is necessary to know how much to manipulate the index when going up/down.
20:11:07 <c_wraith> usually you put the root at 0.  then you don't have that issue
20:11:45 <c_wraith> The left child of index i is index 2i.  The right child is 2i+1
20:11:52 <ja> but the forests are manipulated, and it would involve a lot of copying then, no?
20:14:44 <ja> but anyway, the representations should be equivalent since the trees are perfect and i know the amount of rows 
20:15:58 <ja> the thing is, these are merkle trees, and the leaves matter a lot
20:16:11 <ski> hyiltiz : yes
20:16:18 <ja> the leaves of the second tree are stored right after the leaves of the first tree
20:16:44 <hyiltiz> great, was just waiting for your confirmation that I did understand this finally
20:16:58 <ski> c_wraith : itym `1'
20:17:31 <hyiltiz> let me stare at that cyclic list definition now with what I have learned; the connection doesn't seem so immediate still
20:17:53 <c_wraith> ski: Hmm, good point.  I think I do.
20:18:08 <ja> i think the leaves could be large, so by storing them consecutively, a forest with 15 leaves becomes a tree of 16 leaves without moving anything
20:18:14 <ski> (or else `2*i+1' and `2*i+2')
20:18:22 <ja> but how would that work with the root being at 0?
20:19:50 <hyiltiz> ski++
20:20:16 * ski winces
20:24:04 <ja> so my idea, for making it more type safe and avoid passing the rows number and height around, would be to have a datatype that encodes simply if going left/right from the root, and having it store the height of the tree it pertains to, so that it could be converted to the number i am working with now
20:24:49 <ja> and it could have a Num instance. but to give it a Num instance, where would the total tree height come from? it would have to be in the type
20:25:32 <ja> but isn't there some compromise where i can work with something typesafe without having to use type-level nats?
20:30:49 * hackage github-backup 1.20200721 - backs up everything github knows about a repository, to the repository  https://hackage.haskell.org/package/github-backup-1.20200721 (JoeyHess)
20:31:18 <ja> i guess i shouldn't insist on the Num instance, and just go with TreePosition Pos Height where Pos=Int and Height=Int
20:36:37 <ja> with the root being at 0, doing a batch addition would require accessing more pages, since a newly added branch to such a tree would be very far from the root, and the trees have different sizes, so all these newly added nodes would be offset by weird distances
20:37:56 <ja> in practice, the amount of leaves only grows
20:39:47 <liiae> solonarv: Peirce's law is of the form ((A→B)→A)→A,. that is, given (A→B)→A we could deduce A. is this related to (a->b)->b equivelent to a?
20:49:42 <dolio> liiae: Yes, it's related.
20:50:25 <liiae> dolio: how?
20:51:22 <liiae> this (a->b)->b is related to yoneda lemma, now peirce's law? what CPS has to do with those 
20:53:05 <dolio> If you assume Peirce's law for all types, then the double-negation version also holds, for one.
20:53:25 <dolio> In logic.
20:55:19 * hackage enummapset-th 0.6.2 - TH-generated EnumSet/EnumMap wrappers around IntSet/IntMap.  https://hackage.haskell.org/package/enummapset-th-0.6.2 (FumiakiKinoshita)
20:55:35 <dolio> And if the `((a -> b) -> b)` version holds, then Peirce's law holds, I believe. That direction is probably easier.
21:16:00 <hyiltiz> ??list
21:16:18 <hyiltiz> ??quote ja
21:16:45 <hyiltiz> ??preflex: quote ja
21:20:05 <Axman6> hyiltiz: can we help you?
21:28:32 <hyiltiz> Axman6: Reading https://wiki.haskell.org/IRC_channel#Principles, and trying to use the "karma", "quote" commands
21:29:34 <Axman6> I don't think preflex exists any more
21:29:54 <hyiltiz> ah ok; shall I go update the wiki?
21:30:08 <Axman6> yahb: text "Hello, I exist!"
21:30:18 <Axman6> % text "Hello, I exist!"
21:30:18 <yahb> Axman6: Hello, I exist!
21:31:45 <hyiltiz> % quote Axman6
21:31:46 <yahb> hyiltiz: ; <interactive>:130:1: error:; * Variable not in scope: quote :: t0 -> t; * Perhaps you meant one of these: `quot' (imported from Prelude), `quotes' (imported from Text.PrettyPrint.HughesPJ); <interactive>:130:7: error: Data constructor not in scope: Axman6
22:14:20 * hackage refined 0.6 - Refinement types with static and runtime checking  https://hackage.haskell.org/package/refined-0.6 (chessai)
23:04:19 * hackage what4 1.0 - Solver-agnostic symbolic values support for issuing queries  https://hackage.haskell.org/package/what4-1.0 (RobertDockins)
23:33:19 * hackage aws-lambda-haskell-runtime-wai 1.0.1 - Run wai applications on AWS Lambda  https://hackage.haskell.org/package/aws-lambda-haskell-runtime-wai-1.0.1 (dnikolovv)
23:34:00 <ja> hyiltiz: i removed the preflex section. the lambdabot section notes that you can prefix commands with @
23:49:21 <kuribas> I often have this pattern: maybe (throwError "myError") pure $ ...
23:49:28 <kuribas> is there an abstraction for it?
23:49:31 <kuribas> or combinator?
23:49:53 <Axman6> yes... one sec
23:50:23 <kuribas> in this case maybe <|>
23:50:59 <Axman6> https://hackage.haskell.org/package/hoist-error
23:51:36 <Axman6> your expression would become: ... <?> "myError"
23:51:48 <kuribas> ok, that looks interesting
23:52:45 <Axman6> it also has <!?> for the cases where you have something in monad m which returns a MAybe or an Either: https://hackage.haskell.org/package/hoist-error
23:52:46 <kuribas> it's like a Functor on the error type?
23:53:02 <Axman6> uh, copy and paste not working...
23:53:20 <Axman6> (<!?>) :: MonadError e m => m (Maybe a) -> e -> m a
23:53:55 <Axman6> so you can write myThingWhichReturnsMaybe someArg <!?> MyErrorWhenItsNothing
23:55:47 <kuribas> I don't like line noise operators.
23:56:00 <Axman6> the % variants allow you to pass in a wrapping function, so you can work in errors in one domaina dn convert them into errors in another
23:56:17 <Axman6> :\
23:56:54 <kuribas> I try to avoid most line noise operators in lens too.
23:56:59 <Axman6> having a concise way to say "Run this thing, and if it fails, throw this error" seems like a pretty nice way to do things, it means you reduce a lof of line noise
23:57:32 <kuribas> I can use hoisterror for that?
23:58:00 <kuribas> I don't need the operators no?
23:58:40 <kuribas> hoistError (const MyErrorWhenItsNothing) myThingWhichReturnsMaybe someArg 
23:58:52 <Axman6> no, but it will be significantly more noisy
23:59:31 <kuribas> ok, <?> looks fine.
23:59:40 <kuribas> but <%?> looks line-noisy
