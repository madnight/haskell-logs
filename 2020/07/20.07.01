01:07:58 <nate48423> the american government and denaro are getting my human brain they are able to have me not able to comprehend and change my taste of drinks and food at times( example mt dew tasting like water). can you please tell your world leaders to help me I am  nathan biernatt if you have questions you can message me
02:16:38 <JohnTitor> rip 🧠 
02:36:22 <kuribas> why doesn't These have a monoid instance?
02:37:37 <merijn> kuribas: What would mempty be?
02:38:03 <merijn> "This mempty", "That mempty" or "These mempty mempty"?
02:38:36 <merijn> And why do you need Monoid? Is Semigroup not enough?
02:38:43 <kuribas> foldMap?
02:39:25 <merijn> Wrap it in Maybe, done?
02:39:42 <kuribas> Maybe These?
02:39:51 <merijn> "Maybe (These a b)" is a Monoid
02:40:08 <kuribas> ah right :)
02:40:25 <merijn> Since Maybe turns any Semigroup in one :)
02:40:35 <kuribas> cool, I didn't think of that
02:42:01 <asheshambasta> Does a `Wai` `requestBody` stay empty for smaller requests? Or am I being stupid somehow: https://stackoverflow.com/questions/62673721/trouble-working-with-requestbody-or-getrequestbodychunk
02:44:02 <asheshambasta> I've checked pretty much all of my code, and I'm not using the `requestBody` anywhere else but this; and it seems to always yield an empty result. I /did/ have a request logger; which I've also removed. 
03:05:33 <phadej> asheshambasta: have you looked at https://hackage.haskell.org/package/wai-conduit
03:07:07 <phadej> asheshambasta: https://hackage.haskell.org/package/wai-conduit-3.0.0.4/docs/src/Network-Wai-Conduit.html#sourceRequestBody looks the same what you do
03:07:28 <phadej> though my conduit-fu is very limited
04:01:50 <maerwald> anyone good with spec-speak? I'm not sure what this means "Variable assignment values must be enclosed in double or single quotes if they include spaces, semicolons or other special characters outside of A–Z, a–z, 0–9." Does this mean that foo=1.2.3 is invalid?
04:04:20 <int-e> maerwald: sounds that way because '.' is not on that list
04:04:51 <maerwald> that would mean most of distros ship broken /etc/os-release files :
04:05:22 <int-e> well, it's just a specification ;)
04:05:51 <int-e> debian seems to play it safe: VERSION_ID="10"
04:06:08 <dminuoso> VERSION_ID="20.03.2262.2b417708c28"
04:06:11 <dminuoso> For nixos :)
04:07:25 <maerwald> fedora, alpine and red-hat at least are invalid
04:07:33 <int-e> (There are only two unquoted ones on that installation, ID=debian and VERSION_CODENAME=buster.)
04:08:27 <int-e> It's not surprise that fedora and red-hat are equally broken I guess.
04:08:48 <maerwald> I guess .-_ are ok to allow
04:14:06 <int-e> maerwald: It's funny that there's an example for VERSION_ID that contains a dot.
04:14:19 <int-e> I'd guess the intent was indeed to allow .-_ as well.
04:19:43 <dminuoso> maerwald: Haha. It took me quite a while to understand what you meant by "spec-speak"
04:19:49 <dminuoso> Was looking really hard on hackage for that one.
04:20:42 <int-e> dminuoso: the idea did cross my mind :)
04:47:07 <dminuoso> Okay Im really not sure what's going on here. I repeatedly get `cabal: The program 'c2hs' version >=0.15 is required but it could not be found.`
04:47:25 <dminuoso> My cabal file specifies:   build-tool-depends: c2hs:c2hs  >= 0.28.0 && < 0.29
04:47:54 <dminuoso> And contrary to what I assumed yesterday, cabal does not require ~/.cabal/bin to be in my PATH according to its documentation - but I tried it out anyway, in vain.
04:50:29 <asheshambasta> phadej: thanks, taking a look. I've found something weird in my case; using Web.Scotty.Trans.bodyReader yields a non-empty stream, but accessing the request direclty via `request` and then using `Wai.requestBody` yields an empty stream. 
05:20:39 <dminuoso> Oh, it turns out it was a mismatch between whats on hackage and whats on github. :)
05:20:41 <dminuoso> Strange things.
06:04:14 <oats> hah, that OOP post on /r/haskell is incredible
06:04:31 <oats> https://old.reddit.com/r/haskell/comments/hisc4m/modeling_object_oriented_programming_in_haskell/
06:04:50 <oats> so now we can say "Haskell is the world's finest object-oriented imperative programming language"
06:22:46 <dminuoso> Axman6: ping :)
06:30:54 <boxscape> hmm wikipedia still says that the next formal specification is planned for 2020
06:42:30 <maerwald> is there a more sophisticated way to build a permissiable parser other than parsing line by line?
06:42:55 <maerwald> basically a parser that may finish with warnings/errors
06:43:35 <maerwald> the easy way ofc is to do `runParser parser . lines` and then have a list of Either
06:44:14 <[exa]> by permissiable you mean "with reasonable error recovery" ?
06:44:27 <maerwald> I mean These instead of Eithe
06:44:48 <maerwald> @hoogle These
06:44:48 <lambdabot> module Data.Functor.These
06:44:49 <lambdabot> module Data.These
06:44:49 <lambdabot> Data.These data These a b
06:45:02 <dminuoso> withRecovery :: MonadParsec e s m => (ParseError s e -> m a) -> m a -> m a
06:45:20 <maerwald> I'm aware of the function
06:45:56 <infinisil> maerwald: https://github.com/tree-sitter/tree-sitter is about that, maybe you could look into how it works
06:46:23 <dminuoso> maerwald: You can write an instance MonadParsec for ChronicleT then.
06:46:33 <maerwald> hmm
06:46:39 <infinisil> (tree-sitter isn't haskell though..)
06:48:12 <maerwald> but runParser still only returns an either
06:48:27 <maerwald> I feel this would be a heavier patch
06:49:11 <dminuoso> I mean concretely, you'd then have something like `let f e | notFatal e = dictate e; f e | otherwise = parseError e; withRecovery f p`
06:50:13 <dminuoso> Or I guess, you'd rather need some `disclose` than `dictate` there
06:55:22 <maerwald> Is `parseAssignments :: MP.Parsec Void String [Either ParseError (String, String)]` weird?
07:19:28 <malc_> mupf: 
07:19:41 <malc_> sorry mistype
07:24:38 <hololeap> is there a newtype wrapper that gives a monoid instance somewhere for (Arrow a => a b b), like Endo for (a -> a)
07:25:13 <xxgamergirlxx> hello
07:27:12 <dminuoso> hololeap: well that'd be Semigroup rather than Monoid
07:27:29 <dminuoso> Or hold on, Category arr => Arrow arr right?
07:27:43 <Cale> Yeah, all you'd need is Category
07:27:52 <Cale> There should probably be a more general Endo
07:27:58 * hackage monad-logger 0.3.33 - A class of monads which can log messages.  https://hackage.haskell.org/package/monad-logger-0.3.33 (MichaelSnoyman)
07:29:35 <dminuoso> Base does not appear to have this
07:30:26 <Cale> http://hackage.haskell.org/package/category-0.2.5.0/docs/Data-Morphism-Endo.html
07:31:10 <Cale> Basically that (though I don't know that this is the best source for it)
07:32:10 <dminuoso> So what's the general protocol for writing instances. Is shipping orphan libraries that define useful instances a sensible thing?
07:32:41 <dminuoso> Im going through my dependencies and realize so much of it is unnecessary, dragging in aeson for no reason other than "some library has ToJSON instances"
07:33:14 <ph88> did anyone here do a comparison of packages implementing odbc ??
07:35:54 <Cale> dminuoso: Yeah, putting orphans in a separate package is reasonably common for reasons like that
07:37:37 <Cale> dminuoso: Then again, an extra dependency on Aeson isn't the worst thing in the world
07:37:59 <Cale> Most people are already going to incur that dependency one way or another, because of this very thing.
07:39:54 <dminuoso> Cale: Sure, but things add up really quickly though.
07:40:13 <dminuoso> And it bumps up compilation times.
07:40:33 <dminuoso> If I spend half my time building unused dependencies, its annoying
07:40:39 <dminuoso> And it makes auditing dependencies harder
07:40:48 <Cale> They're not cached?
07:40:57 <dolio> That would probably be the nicest thing to solve about Haskell, I think.
07:42:00 <dminuoso> well I dont want to be constructing reasons after reasons, the idea doesnt sit well with me.
07:42:26 <wavemode> frankly I hate when a package I want to use depends on aeson, when the functionality I actually need has nothing to do with json processing
07:42:40 <dminuoso> I mean there are reasons that start with 
07:42:47 <dolio> Allowing instances to be decoupled without completely throwing out their canonicity like most other systems do.
07:43:10 <dminuoso> dolio: That is actually solvable if people shipped classes in separate packages!
07:43:21 <dminuoso> (But that gets you further into orphan territory)
07:43:33 <wavemode> it's the most valid use case for orphan instances
07:43:38 <dolio> There's a reason people avoid orphan instances.
07:43:49 <hololeap> dminuoso, Cale, thanks
07:44:15 <dminuoso> dolio: Come to think of it, this is actually a dangerous use of orphans.
07:44:30 <hololeap> i just realized that it only needs a Category, not an Arrow per se
07:44:44 <dminuoso> Because this style of libraries makes it likely that one region pulls in the canonical instance, another pulls in some hand written instance, and then you've got an incoherent mess.
07:44:47 <hololeap> *i had just realized
07:45:10 <Cale> dminuoso: Yes
07:46:06 <dolio> Anyhow, it's not a trivial problem to solve well.
07:46:14 <Cale> It's possible that base should have some data type capable of representing JSON in it, just so that the encoders/decoders could be defined without anything further.
07:46:33 <Cale> It would also be nice if Aeson were designed in a way that made instances more optional-use.
07:46:39 <wavemode> the person who handwrote an instance is in the wrong there. the library should document that it has official instances in a separate package
07:46:54 <wavemode> i often see a direct link in the readme
07:46:57 <dminuoso> wavemode: You might not even know its in there.
07:52:29 * hackage haskoin-store-data 0.34.4 - Data for Haskoin Store  https://hackage.haskell.org/package/haskoin-store-data-0.34.4 (jprupp)
07:53:29 * hackage haskoin-store 0.34.4 - Storage and index for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-store-0.34.4 (jprupp)
08:07:00 <materiyolo> how can i uninstall older GHC versions from Stack
08:07:13 <materiyolo> like, i want to uninstall 8.6.5 because i installed 8.8.3
08:21:21 <ezzieyguywuf> materiyolo: https://www.reddit.com/r/haskell/comments/46reio/how_to_uninstall_snapshots_and_older_ghc_from/
08:21:44 <materiyolo> ezzieyguywuf: i just removed the ghc versions from ~/.stack/programs lol
08:22:10 <ezzieyguywuf> that does it
08:22:16 <ezzieyguywuf> more info: https://stackoverflow.com/questions/48627923/haskell-stack-commands-for-uninstall-clean-up
08:22:21 <ezzieyguywuf> *shrug*
08:23:03 <materiyolo> ;
08:24:33 <ezzieyguywuf> TIL about NonEmpty, that's dope
08:31:59 <fendor> is there an up-to-date blog or tutorial how to generate haskell bindings to c libs? Or even c++ libs?
08:35:36 <ddellacosta> does anyone have thoughts on working at an "FP-oriented" scala shop in particular as compared to writing Haskell day-to-day? 
08:39:08 <ezzieyguywuf> fendor: c++ is harder b/c of name mangling
08:39:42 <fendor> ezzieyguywuf, even if they have a c interface?
08:40:18 <ezzieyguywuf> fendor: that I dont' know.
08:40:38 <ezzieyguywuf> this looks like it was updated as recently as march 2020 https://wiki.haskell.org/Foreign_Function_Interface
08:41:16 <ezzieyguywuf> this seems a bit more practical, and updated back in 2018: https://wiki.haskell.org/GHC/Using_the_FFI
08:41:29 <ezzieyguywuf> note - I'm just looking at the change history, "updated" could mean someone fixed a typo
08:43:59 <fendor> I liked this blog post, but it seems a little old http://blog.ezyang.com/2010/06/setting-up-cabal-the-ffi-and-c2hs/
08:44:09 <fendor> I was wondering if there is something better nowadays
08:48:26 <fendor> I am wondering, whether it would be easier to generate bindings to the rust bindings of this lib (cryptominisat)
08:49:05 <fendor> since curryrs seems to be easy to use
09:00:43 <maerwald> you have a new fan of golden tests
09:04:03 <monochrom> Are you the new fan? What do you like about golden tests?
09:05:33 <maerwald> Fixing all tests permanently by just deleting the golden files (they will be created on next test run)
09:05:54 <maerwald> you can easily diff in git then before you commit
09:10:25 <maerwald> and it's just less code
09:12:28 <joels> Hello all
09:15:22 <maerwald> tests are like mushrooms... you don't want too many, but they are nice
09:15:35 <wavemode> interesting way of putting it
09:22:22 <hololeap> lolwut
09:24:08 <MarcelineVQ> tests are like mushrooms, you should cook them first but some will still kill you
09:25:18 <MarcelineVQ> tests are like mushrooms, if you leave them too long they kind of disintegrate and leave a weird goo that your instincts tell you to avoid
09:27:45 <Rembane> Tests are like mushrooms, they grow on trees and in circles and they like rain. 
09:28:21 <bcmiller> tests are like mushrooms, some taste good on salads but others make you see strange colors
09:29:12 <dsal> Some mushrooms make you really sick, but then you start feeling better and that's when you know it's too late.
09:30:02 <MarcelineVQ> tests are like mushrooms, some are buttons, some are steaks, all pair well with beef or tomates
09:30:31 <Rembane> Strange colours are from outer space and will make you mad. Just like legacy code bases. Legacy code bases are code bases without tests.
09:34:28 * hackage spork 0.4.0 - Catch errors from pure computations in a Maybe/Either  https://hackage.haskell.org/package/spork-0.4.0 (tycho01)
09:41:48 <sm[m]> I am tripping out
09:43:03 <sm[m]> everything in #haskell looks like a mushroom 🍄
09:43:52 <dsal> :t (🍄)
09:43:53 <lambdabot> error: Variable not in scope: 🍄
09:44:25 <dsal> Is 🍄 a letter or an operator?
09:46:02 <ski> > isLetter '�'
09:46:05 <lambdabot>  False
09:46:11 <infinisil> It's a giant mushroom! Maybe it's friendly!
09:56:43 <glguy> > Data.Char.generalCategory '🍄'
09:56:45 <lambdabot>  OtherSymbol
09:59:27 <malc_> hmm... and emacs tells me:   general-category: So (Symbol, Other)
09:59:27 <malc_>   decomposition: (127812) ('🍄')
09:59:27 <malc_>   
10:00:01 <wavemode> infinisil: ATLA?
10:00:17 <glguy> > let x 🍄 y = x ++ " mushroom " ++ y in "one" 🍄 "two"
10:00:19 <lambdabot>  "one mushroom two"
10:00:27 <monochrom> heh
10:00:46 <glguy> Agda, here we come
10:01:06 <monochrom> I think Agda took this inspiration from Haskell.
12:19:45 --- topic: 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: https://gist.github.com/ | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org'
12:19:45 --- topic: set by glguy on [Sat Jan 05 07:21:52 2019]
12:19:45 --- names: list (clog heatsink Jesin nate48423 conal gehmehgeh danvet chalkmonster cole-h acidjnk_new falafel_ merijn jules000 mossplix thunderrd Snuupy1 John20 xerox_ nub001 Wuzzy fendor dysfigured plazia L29Ah zv kleisli_ otto_s cur8or_ notzmv dexterlb bennofs_ george_____t lizzard obiwahn nikkal samiamsam vnz drewr knupfer justanotheruser MarcelineVQ jonathan3 Guest40908 Rudd0 mozzarella c-rog dan64 Firedancer Tritlo Nistur sim590 dopplergange mupf aidecoe clynamen Dykam)
12:19:45 --- names: list (kptech marble_visions seliopou jassob acowley hpc electrostat connrs_ perrier-jouet gawen ridcully xwvvvvwx Squarism ichimaru hiroaki quazimodo monochrom aweinstock laxask is_null _ashbreeze_ ClaudiusMaximus srnty sagax caubert Cheery kav APic Katarushisu carldd codygman sicklorkin _ht pfurla Amras bollu stepnem pta2002 LKoen dbmikus arianvp Lowl3v3l brisbin ph88 kqr adamCS stvc tensorpudding Frobozz_ glamas turion beka dolio cyberlard Foritus bsima statusbot)
12:19:45 --- names: list (DTZUZU urodna pharaun grazfather troydm Guest6919 carlomagno kipras`away Guest60204 {abby} haskell_enthusia maerwald jinblack Iroha andjjj23 jonathan__ DwarfMaster bob_twinkles puffnfresh Cthalupa wowi42 bandali NGravity Guest43547 fluxit aldum madnight Jonno_FTW Bish blackdog bcmiller DustyDingo shapr` M2tias zeromorphism andreas303 o1lo01ol1o jollygood2 hari_ John_Ivan_ khorser[m] sujeet raichoo tstodter Sheilong tzh mdunnio metadave joels quinn changj)
12:19:45 --- names: list (tsaka__ nfd9001 dme2 cantstanya dqd pera hexfive evanjs ddellacosta xiinotulp bobey mniip yahb __monty__ solonarv wavemode whiteline mimi_vx nuncanada ystael eldritch Codaraxis Ornedan unsupervised p8m Waldkauz polyphem wechselstrom xff0x qz markus1189 xintron DavidEichmann atk eyenx feuerbach poljar albel727 Kaivo slack1256 cr3 xelxebar livvy mulderr machinedgod samebchase eyenx|m drbean michalrus Maxdamantus haveo ezzieyguywuf nopf jfredett_ MindlessDrone)
12:19:45 --- names: list (kish pounce Chousuke phreedom_ enikar incognito9999 geyaeb_ rasay gentauro vikfret Neo-- Lord_of_Life chindy proteusguy Gurkenglas_ JesseL oxide Neuromancer whald Tuplanolla klntsky Aquazi texasmynsted supercoven thc202 dhouthoo CurryWurst m0rphism voyons_calice tromp fresheyeball jusss jneira[m] day zaquest dcoutts_ sw1nn theDon lagothrix Guest75114 Kaiepi alx741 heredoc dftxbs3e PragCypher javran seanparsons hc revprez_anzio rzmt parseval badzergling Hotbees)
12:19:45 --- names: list (vicfred averell jespada jneira shutdown_-h_now GyroW_ tomboy65 ChaiTRex avn justache acarrico valdyn Cale mirk0 sm[m] dale LittleFox zgrep haasn ulidtko stefan-__ jchia__ jrm @Sigyn HiRE NieDzejkob Takumo tsrt^ klardotsh justsomeguy statusfailed jlorand[m] michael[m]2 thejonny gcoakes[m] solomon[m]1 iffsid jhuizy[m] mikr[m] hyiltiz[m]1 atopuzov[m] joshua[m]2 whu[m] grizwako[m] jojoz[m] jojotastic777[m] utdemir[m] alexfmpe jkhaak[m] supersven[m] camlriot42)
12:19:45 --- names: list (ArtemZ sajith[m] unclechu srid freeman42x[m] schum rellen[m] ethercrow[m] roberth io_r_us[m] bolti[m] siraben drozdziak1 Fernando-Basso[m PotatoHatsue[m] michaelpj kaychaks_riot vaibhavsagar hsiktas[m] rednaZ[m] boistordu Elorm[m] domenkozar[m] execat[m] Poscat[m] sepp2k reed[m] redviking[m] Noughtmare[m] fossegrim[m] kadoban lnxw37d4 Ericson2314 c6ristian jluttine[m] quiet_laika[m] fgaz denbrahe[m] psydruid iinuwa maralorn nckx inkbottle Vq Fubar^ veverak)
12:19:45 --- names: list (revprez_stg artem leah2 steell Orbstheorem danso Arjan ullbeking orcus hackage rdivyanshu__ teej runeks betawaffle parsnip moobar pepeiborra jonrh caasih darthThorik wildsebastian jbetz amatecha__ liszt higherorder ibloom koankeeper jlpeters peel benwr_ AndreasK ebutleriv thecoffemaker Alleria_ d3lxa s00pcan fryguybob jjhoo whatisRT blackbart taylskid st8less bonz060 robogoat malthe sshine doublex amosbird darjeeling_ Chi1thangoo infinity0 cohn ericsagnes)
12:19:45 --- names: list (crobbins byorgey acro noexcept esx uwap gxt mounty koz_ dcoutts nitrix lep-delete LambdaDuck opqdonut niklasb_ cgfbee jb55 pieguy128 petersen tanuki Profpatsch dibblego hololeap nick_h jakalx hamishmack PatrickRobotham_ Cir0X otulp Niamkik loli @glguy amiri Nilgeist meck daGrevis atraii tomku pacak datajerk unlink_ thestr4ng3r CMCDragonkai2 angerman flebron whataday dwt lambdabot Thra11 solrize zzz niso_ sz0 Arahael rann tomsmeding alexelcu jcarpenter2 cyphase)
12:19:45 --- names: list (krjst rappet motherfsck lllppplll entel ryzokuken_ urdh `slikts tinwood furnost Guest1797 noecho andi- verement Tesseraction centril gienah shock- p3n dixie cow-orker simplegauss riatre rembo10 rom1504 t36s_ mstruebing sepplesWoona abbe armin ap5 Natch nshepperd xlei zfnmxt kmein denisse wpcarro esph Fischmiep tv mceier Khisanth recon_- Faye fraktor raid PyroLagus lassulus zyeri Axman6 m1cl Benett leothrix energizer nek0 phaul styledash devurandom gekh)
12:19:45 --- names: list (narendraj9 wagle jdt dustinm- blissful mac10688 systemfault abuss vk3wtf_ martin02 m4lvin ViCi liff hyiltiz russruss CitizenSnips Guest2322 ephemera_ aplainzetakind pdxleif nerdypepper benschza cp- eagleflo Chobbes msgctl oak_ kraem waskell_ nostrodamy sqrt2 bitonic drbrule alexknvl edwardk ProofTechnique L1Cafe ixian elcaro tabemann @ChanServ e megaTherion raoulb chpatrick dmwit dhananjay kjak sivs dave_uy2 magbo efertone spion dxld dmj` nil zot DocKlobi)
12:19:45 --- names: list (adius PoliticsII__ sethetter mpickering Argorok_ sgraf benl23 terrorjack gluegadget dsturnbull simony heyj affinespaces lexi-lambda ajmcmiddlin Taneb aristid mp___ Ekho srhb tdammers rodgzilla Madars Nikotiini jackdk luite dminuoso kini Hijiri gilbertw1_ Flonk_ shachaf kaol towel andromed1-galaxy tumdedum tasuki_ exarkun bcoppens_ kosmikus cjh`_ juri_ ornxka_ coddinkn_ jmsx Reiser9 m-renaud oats samebchase- codedmart_ starlord davl saidinwot1 Paks lyxia fre)
12:19:45 --- names: list (obfusk gareth__ joehh1 bwe amx RusAlex magicman gabiruh mort docontherocks mud lpsmith SegFaultAX cstrahan Nascha graingert rizary ^[_ Kamuela kip carter cbarrett nh2 Shun131 coot jesyspa alunduil eacameron tazjin NemesisD_ pasukon parisienne___ conjunctive teehemkay mudri Adeon koala_man thi integral scav lightandlight PotatoGim newhoggy chessai billstclair gaze__ buggymcbugfix mankyKitty edmundnoble tnks bgavran rodlogic_ elvishjerricco idnar grfn hyperfekt)
12:19:45 --- names: list (srk Arguggi Cathy tms_ Firedancer_ frobnicator Drezil atomi fr33domlover _janne EvanR loc Aleksejs sayak voidcontext davean rotaerk ski xarian quintasan connrs dani- kyagrd__ drewolson kozowu polux2001 Moyst infty AWizzArd fliife850 totte SrPx dsal natim87 ocharles jetpack_joe ahf Cerise JSharp pent Randy topos runde feepo stylewarning bjs johs RoguePointer vancz abrar Kneiva arkeet hiredman jorj tomjaguarpaw teqwve i7c PigDude xnyhps miklcct Majiir rawles)
12:19:45 --- names: list (echoreply jackhill immae xcin mcfilib isacl___ taktoa[c] spoonm ReinH operand_ agander_m nshepperd1 twk- solarus pong a3f fiadliel totbwf cocreature Bigcheese farn_ liquorice bradparker lukelau enemeth79 jared-w interruptinuse _flow_ dequbed ryjm q3k sud0 bendo oeblink nlofaro mursu dumptruckman oldsk00l hongminhee cjay joehillen SolarAquarion mingc ByronJohnson ManiacTwister nikola2 yushyin Forkk silver_needles nurupo ggVGc magog typetetris debugloop bspar)
12:19:45 --- names: list (tolt nisstyre Ferdirand theorbtwo lnx so nshepperd2 SupaYoshi iomonad drewbarbs_ kloeri fiQ2 digia jonge kAworu robotmay arw_ Techcable fredcy- NinjaTrappeur coeus d0liver lally davetapley dgpratt vimto1 Eliel reyu djanatyn deni mantovani Geekingfrog Unode happycoder mr_yogurt oleks hrnz pie_ ashnur anderson nyaomi Logio pierrot ps-auxw a3Dman_ Someguy123 Ankhers electrocat w1gz piele TMA Zemyla johnstein ring0` cpape ent matthew- Philonous stiell hwabyong_)
12:19:45 --- names: list (Benzi-Junior amf rotty vin-ivar TimWolla seveg idupree DigitalKiwi Zialus_PT wz1000 copypasteque carbolymer WzC_ PlasmaStar gambpang earthy dh Tene Entroacceptor SquidDev newsham apoc dragestil aurieeeh helpplz ammar2 gothos Clint joeytwiddle forell [df] turq c_wraith MasseR vqrs hive-mind fissureman milessabin glowcoil rslima____ laghee__ Rembane devalot grumble hvr ab9rf divVerent jhuizy tristanC noan suzu_ ego drdo ij thonkpod dredozubov sphalerite suppi)
12:19:45 --- names: list (J_Arcane duckonomy Bergle_2 dexterfoo PHO chrpape atle_ spamlessj lortabac irclogger_com myme deu tabaqui joeyh vodkaInferno hexo Adluc bjobjo Jon beaky komasa sveit agrif relrod PtxDK sis7 Blkt cheers kkd noCheese sclv bgamari crtschin_ sarahzrf banjiewen aib joshmeredith cinayakoshka alanz_ cvlad- Boarders FMJz___ adamse mystfox Klumben iphy zabracks verlet64_ raoul peutri anoe Heffalump e2 rednaZ2 noctux Athas dennisb int-e mawk net4all lockshaw Inoperable)
12:19:45 --- names: list (jokester gregberns_ sm sdrodge shadowdaemon SomeB stux|RC-only ivegotasthma nemesit|znc grol nekomune canta vjoki phaazon hexagoxel mjuad xacktm ghuntley hodapp bananagram milkii esotericalgo balbirs lieven dyl_ Tspoon edwtjo supki gargawel heath cynick Patternmaster lemald jvanbure ynyounuo bobbytables Deewiant_ fiddlerwoaroof jkarni stree ycheng auri_ greymalkin exferenceBot Twey runawayfive davve ft mikolaj Sparadox ambiso uberj rkrishnan phadej ben xe4)
12:19:45 --- names: list (lucianp_ tessier zymurgy ja edigiacomo tureba esg reactormonk CindyLinz Uma inimino geal mmaruseacph2 ArsenArsen mgaare_ chirpsalot jzl Wamanuz2 joko niko Velpoman infinisil matheus23 jle` jtobin wayne militia duairc wraithm acertain TommyC [exa] sdx23 Tourist cods jchia1 nonzen kristjansson dilinger micro_ jameekim2 rprosper- incertia saurik rdivacky catern jtcs mjrosenb pyrho cross jonatan landonf m1dnight_ mrus thaumavorio wrunt locallycompact Igloo bind)
12:19:45 --- names: list (ptrcmd freeside barrucadu Jello_Raptor epta add^_ quaestor Guest20621 swater gsingh93 Raito_Bezarius Putonlalla absence comboy luigy lowryder sea-gull mikolaj_ asm89 j_klee thebnq Uniaika ekleog)
12:20:06 <lexi-lambda> You can also think about it operationally: runNonDet is morally like running the computation over and over again, but each time, you take a different set of choices. And if runState is inside the runNonDet call, then the state would be “re-initialized” on each re-run. But if it lives outside of it, then the initialization doesn’t participate in the re-running.
12:20:54 <lexi-lambda> What eff doesn’t do is change the meaning of algebraic operations based on handler order. So for example you won’t get transactional state if you have runState inside runError, you always have global state.
12:21:34 <maralorn> lexi-lambda: Ah, okay. Good to know. Because in conversations a lot of people where confused about this point. Because yeah, the order does sometimes matter. And there was speculation that you achieve this by just making some semantics impossible.
12:22:40 <maralorn> lexi-lambda: Because it would not be doable with the underlying structure of eff? Or because you think only offering one option prevents confusion?
12:23:08 <lexi-lambda> Yes, I need to clean up the wording in the docs. The key point is that algebraicity is never lost, so you can always reason using the laws algebraic effects are supposed to provide.
12:24:00 <lexi-lambda> The other semantics is, in my opinion, somewhat arbitrary. It does what it does because it does. Ultimately, any choice of semantics is just a choice, but eff chooses to be consistently algebraic.
12:25:01 <lexi-lambda> In both models, there are certain behaviors you “rule out”; you can’t directly get eff’s semantics in mtl/fused-effects/polysemy and vice-versa. But there are sometimes ways to achieve the same thing by other means.
12:25:49 <Uniaika> lexi-lambda: I love how you made unicode tables in your mail! :o
12:26:04 <lexi-lambda> Personally, I think it’s much easier to explicitly opt-out of algebraicity in places you want it rather than try to gain it back in mtl/fused-effects/polysemy (to the point where polysemy doesn’t know how to fix some of its weird, deeply-unintuitive semantics).
12:27:10 <lexi-lambda> Every effect system is to some degree putting you “on rails,” where you’re constrained to the limits of what you can express. You have to be, since you’re trying to compose computational effects, and you need *some* restrictions for the composition to be automatic without being complete nonsense.
12:27:21 <maralorn> lexi-lambda: Ah, that sounds like a very plausible reasoning. Although I am not completely sure what "being algebraic" exactly means in this context. But that‘s probbly better explained in some documentation then on irc.
12:27:51 <maralorn> lexi-lambda: Thanks for the explanations! Really looking forward to working with eff.
12:29:57 <maralorn> Uniaika: My I ask on what list that mail was send? It sounds like I wanna subscribe to it.^^
12:30:27 <Uniaika> maralorn: ghc-devs
12:30:28 <lexi-lambda> The “algebraicity property” is indeed a little bit abstract and not super useful to most people, fwiw. But the basic idea is that if you have two operations that belong to two different effects, their handlers cannot “interfere” with their behavior.
12:30:57 <lexi-lambda> That is, effects are given meaning only by their handlers, not handlers for other effects.
12:31:31 <lexi-lambda> It’s basically a “these things can be ensured to compose nicely without messing one other up” property.
12:31:42 <lexi-lambda> *one another, rather
12:32:01 * dsal just remembered someone telling me about a really good lexi-lambda talk I'm supposed to watch
12:32:16 <maralorn> lexi-lambda: I am not afraid of abstraction.^^ Is there a way to phrase that in formulas/pseudo code?
12:33:42 <lexi-lambda> Well, the real definition of an “algebraic operation” is that for some operation op that takes computation arguments m1 through mn, then `op m1 ... mn >>= k` is equivalent to `op (m1 >>= k) ... (mn >>= k)`. It isn’t immediately obvious why that is equivalent to saying “these things compose nicely.”
12:33:47 <maralorn> dsal: You should! Let me help you: https://www.youtube.com/watch?v=0jI-AlWEwYI
12:34:20 <maerwald> where does mtl break algebraicity?
12:34:34 <dsal> maralorn: Thanks.  I'd already had it in my "Talks" list.  I just forget to look at that one.
12:34:46 <lexi-lambda> Many operations are trivially algebraic because they don’t accept any computations as arguments (or more precisely, in negative positions). So for example ask, get, put, and throw are all trivially algebraic.
12:35:37 <lexi-lambda> The <|> operation on the list monad is nontrivially algebraic (but note that <|> on other monads, like Either, is *not* algebraic). This is because `(m1 <|> m2) >>= k` is equivalent to `(m1 >>= k) <|> (m2 >>= k)`.
12:36:40 <lexi-lambda> Operations like catch, listen, and local are non-algebraic. `catch m f >>= k` is clearly not the same as `catch (m >>= k) (f >=> k)`.
12:37:05 <lexi-lambda> This historically has caused trouble for algebraic effects libraries because catch/listen/local are all incredibly useful.
12:37:34 <maralorn> lexi-lambda: I must say I am not sure how to typecheck `op m1 ... mn >>= k` and  `op (m1 >>= k) ... (mn >>= k)` at the same time.
12:37:58 <lexi-lambda> Look at the <|> @[] example I gave above for a concrete example.
12:38:33 <lexi-lambda> The point is that op must distribute over >>=, and that’s only relevant for arguments that are actually computations.
12:39:12 <lexi-lambda> For an operation like put, we don’t say `put x >>= k` must be equivalent to `put (x >>= k)` because clearly that is nonsense.
12:40:14 <maralorn> lexi-lambda: Okay, I think I get it.
12:40:23 <lexi-lambda> Great. Continuing: traditionally people encode catch/listen/local as effect handlers rather than effect operations. For example, catch can be thought of as an Error handler that locally handles throw.
12:40:30 <maralorn> lexi-lambda: But know how can we do something like catch algebraicley?
12:41:27 <lexi-lambda> But this is unsatisfying because it means you couple yourself to a particular implementation by using catch. For example, you might have two implementations of Error, one that returns Either and one that uses IO exceptions. If catch is a handler, then it must be coupled to one of those implementations or the other.
12:43:10 <lexi-lambda> In mtl, this issue is resolved by forcing every monad transformer to decide what catch means in that transformer. Sometimes you get confusing answers because of that: the StateT transformer doesn’t know what happened to the state if an error is raised, so in catch, it has to just use the only state is has lying around, namely the old state.
12:44:10 <lexi-lambda> This StateT pattern of “just discard the state on an early return” can be generalized to various other transformers, and MonadBaseControl is one example of a library that codifies it.
12:44:38 <lexi-lambda> Both polysemy and fused-effects implement other automatic ways of “packing up” handler state and threading it throw the computation, but they’re all doing fundamentally the same thing.
12:45:24 <lexi-lambda> eff takes a different approach. In eff, catch/listen/local *are* modeled as effect handlers, but they are sort of “sub-handlers” of the enclosing handler.
12:45:55 <lexi-lambda> So when you define a handler for Error, you get to choose which sub-handler to install whenever someone uses catch.
12:46:46 <lexi-lambda> Now you get the best of both worlds: the fundamental operation is just throw, which is algebraic, and catch is just a way of locally adjusting the operation of the current handler.
12:48:18 <lexi-lambda> Since eff doesn’t do all this “state-packing” that mtl/MonadBaseControl/fused-effects/polysemy do, state is never “lost” due to an early return. And because listen/catch/local are still algebraic(!) effect handlers, you still get to use all the reasoning that applies to purely algebraic systems.
12:48:32 <maralorn> Sounds cool!
12:48:32 <dolio> There's no reason 'catch' can't be algebraic, too. It's just a different algebra than the one with just throw.
12:49:10 <lexi-lambda> dolio: I’m using a very specific definition of “algebraic operation,” namely the one given by Plotkin and Power.
12:49:34 <lexi-lambda> Under that definition, it is not algebraic.
12:50:07 <lexi-lambda> (Or at least, any reasonable implementation of it is not algebraic!)
12:50:13 <maralorn> lexi-lambda: Uh, do you have a link to that?
12:51:09 <dolio> Plotkin and Power can have an algebra where catch is an operation. It is the operation for the generic effect with type `1 → 1 + e`, I think. Because `M^(1+e) → M^1 ≌ M → (e → M) → M`.
12:51:28 <lexi-lambda> maralorn: Sure, but I’ll warn you, it isn’t very readable. http://homepages.inf.ed.ac.uk/gdp/publications/Overview.pdf
12:51:35 <dolio> Just like <|> is the operation for generic effect `1 → 2`.
12:52:13 * maerwald squints
12:52:44 <lexi-lambda> dolio: Yes, I think that’s technically right. I was implicitly considering the “any reasonable implementation” caveat, but you can technically do it. But eff also supplies laws for catch that make it necessarily non-algebraic.
12:53:27 <maralorn> lexi-lambda: thx! Gotta go now, but I really apreciate the explanations!
12:53:44 <infandum> I'm trying to build a program with nix to support macOS. I'm getting an `Error: C stack usage  17587444683864 is too close to the limit`, (this all works on linux). This library depends on haskellR which says to use `-fno-ghci-sandbox`, but I'm not using ghci. Is there GHC sandboxing I can disable?
12:53:52 <lexi-lambda> maerwald: Did the above answer your question, by the way?
12:53:56 <infandum> https://tweag.github.io/HaskellR/docs/faq.html
12:54:30 <infandum> Also, the module it fails on is like 90% haskellR stuff, so it's probably the fault of that library, so how can I overcome this without ghci?
12:55:30 <maerwald> lexi-lambda: kinda, but I'm still meditating over `op m1 ... mn >>= k` == `op (m1 >>= k) ... (mn >>= k)`
12:55:56 <lexi-lambda> maerwald: Thinking about (<|>) @[] is really the best way to understand what’s going on there, I think.
12:56:45 <lexi-lambda> Honestly, I can’t think of any other algebraic operations off the top of my head where the distributivity is relevant!
12:59:00 * hackage pam 0.2.0.0 - Haskell binding for C PAM API  https://hackage.haskell.org/package/pam-0.2.0.0 (OscarH)
13:26:59 <ezzieyguywuf> i wonder why the 'scene graph' approach is so popular in 3d graphics - is it because oop is so prevalent/comfortable, or is it truly the best way to solve the problem?
13:30:34 <byorgey> ezzieyguywuf: I'm not sure I see what scene graphs have to do with OOP.  They really ought to be called 'scene trees', and seem pretty natural if you want to describe a scene hierarchically.
13:42:01 <wavemode> the point of a scene graph is that you can apply transformations (rotation, scale, translation, etc.) to an object and all its children will be transformed with it
13:42:36 <wavemode> it'd be annoying to get that kind of functionality with some other representation
14:00:38 <hseg> ok, so before i dive down this rabbit hole, any good libraries for multivariate polynomials?
14:01:11 <hseg> everything i've found is single-variable
14:01:42 <hseg> and my own code is so underperformant i suspect it'll take a major effort to fix it
14:02:21 <hseg> (for one, clearly my data representation of Poly n r = Map (Vector n (Sum Integer), r) is suboptimal
14:02:23 <hseg> )
14:05:40 <hseg> there is https://github.com/konn/computational-algebra, but it looks completely dissasociated from any numeric hierarchy i'm used to
14:08:50 <hseg> i guess i could use some single-variable implementation and just write type family Multi n r where { Multi 0 r = r; Multi 1 r = Poly r; Multi (n+1) r = Poly (Multi n r) }
14:08:58 <hseg> and write some code around that
14:09:06 <hseg> have no idea how performant that would be
14:10:25 <ski> (i suppose i would try to parameterize over a type of indeterminates, rather than a natural number)
14:11:12 <hseg> so basically build a monoid algebra?
14:11:19 <hseg> Monoid m => Map (m, r) ?
14:11:41 <hseg> and then instantiate that at m ~ UVector n Int ?
14:12:10 <ski> monoid ring over the free commutative monoid, yes
14:12:50 <hseg> ok, sure. that would give me some decoupling
14:12:51 <ski> no idea about performance considerations .. that's just what i was thinking about, last time i was thinking about this
14:13:39 <hseg> well, my implementation has a huge memory leak
14:13:46 <hseg> and i have no idea why
14:13:59 <hseg> i know i need to add strictness
14:14:04 <hseg> but again, no idea where
14:14:35 <hseg> profiling leeds me to suspect it's my convolution code that's at fault
14:14:51 <hseg> hrm.
14:15:29 <hseg> may have spotted an issue - am marshalling/unmarshalling Map
14:15:37 <hseg> no way that's performant
14:15:55 <hseg> is there a way to efficiently convolve maps?
14:16:59 <hseg> i.e. do the equivalent of fromList . collectVia @Sum $ [ (k <> l, x * y) | (k,x) <- toAscList f, (l, y) <- toAscList g]
14:17:27 <hseg> (where collectVia does the relevant groupWith thing)
14:24:53 <george_____t> Hi everyone. I'm getting some confusing behaviour involving Cabal revisions
14:25:08 <george_____t> I'm sure I'm not the first person to ever say that
14:25:29 <merijn> george_____t: What, exactly?
14:25:37 <george_____t> cabal-install doesn't seem to be recognising that a constraint was weakened in a revision
14:25:51 <merijn> george_____t: did you update the index?
14:26:03 <george_____t> So I'm told `rejecting: cabal-plan-0.7.0.0 (conflict: cabal-helper => cabal-plan<0.7&& >=0.5.0.0)`
14:26:06 <merijn> "cabal update"
14:26:12 <george_____t> Ha yes, I have done that
14:26:17 <merijn> (or v2-update, depending on version)
14:26:48 <george_____t> It can be seen [here](https://hackage.haskell.org/package/cabal-helper-1.1.0.0) that `cabal-plan` 0.7 should be allowed
14:27:04 <george_____t> Ah, whoops, no markdown here
14:27:12 <sm[m]> hseg: when "I have no idea", one way to make progress is to comment out code until the problem goes away
14:27:38 <hseg> too interdependent
14:27:41 <george_____t> This is when `trying: cabal-helper-1.1.0.0`
14:27:45 <sm[m]> extract it
14:27:51 <hseg> hrm
14:28:03 <hseg> could benchmark the polynomial multiplication on its own
14:28:05 <sm[m]> you need to reduce it to a simpler reproducing script you can debug
14:28:09 <hseg> ok
14:28:23 <merijn> george_____t: Do you have a cabal.project or freeze file lying around?
14:29:59 * hackage opentelemetry 0.5.0 -   https://hackage.haskell.org/package/opentelemetry-0.5.0 (DmitryIvanov)
14:30:53 <george_____t> merijn Argh, thanks. It was using `index-state`...
14:30:59 * hackage opentelemetry-lightstep 0.5.0, opentelemetry-wai 0.5.0, opentelemetry-extra 0.5.0 (DmitryIvanov)
14:31:14 <hseg> maybe i'm missing something, but is there a way to take a cartesian product of maps?
14:31:15 <george_____t> Should have thought of that
14:31:34 <hseg> only combinators i see on pairs of maps are union/intersection
14:31:36 <merijn> george_____t: :)
14:31:37 <hseg> and the like
14:32:12 <hseg> and difference
14:34:04 <hseg> hrm
14:36:47 <hseg> could do a fold or sth
14:36:54 <hseg> anyway, that's for tomorrow
14:36:55 <hseg> thanks!
14:59:59 * hackage bytestring 0.10.10.1 - Fast, compact, strict and lazy byte strings with a list interface  https://hackage.haskell.org/package/bytestring-0.10.10.1 (sjakobi)
15:00:11 <Uniaika> omg, new bytestring release!!
15:01:12 <Clint> gawrsh
16:03:35 <frdg> I just started using stack. I was wondering if this is a valid project.yaml build-depends: https://pastebin.com/7pxcPfu4
16:32:35 <sm[m]> That’s a negative
16:38:13 <dsal> Kind of a weird combination of syntax there.
16:39:04 <sm[m]> https://wadler.blogspot.com/2020/06/cardano-virtual-summit-2020.html tomorrow !
16:42:31 <crestfallen> sm[m], dang should I have not sold my ada coins ?
16:43:33 <ezzieyguywuf> byorgey: thanks for your respons. after reading more about scene graphs I would tend to agree with your comment.
16:44:02 <sm[m]> crestfallen: Id better let you make that call
16:45:15 <sm[m]> it’s a very very interesting project and the summit (tomorrow & Friday) will include some interesting talks (Wadler.. SPJ.. Cerf.. etc)
16:45:35 <sm[m]> And it’s free. Just FYI.
16:45:46 <Rembane> Will they be recorded? 
16:46:05 <sm[m]> good question
16:57:22 <wudis> lambdabot: @type liftM
16:57:23 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
16:59:17 <dsal> :t lift
16:59:18 <lambdabot> (MonadTrans t, Monad m) => m a -> t m a
16:59:37 <dsal> Oh weird.
17:00:00 <dsal> :t liftA -- there's also this
17:00:01 <lambdabot> Applicative f => (a -> b) -> f a -> f b
17:24:54 <ezzieyguywuf> hrm, how come gl is not in here: https://packdeps.haskellers.com/reverse
17:25:00 <ezzieyguywuf> is it because no packages depend on it?
17:27:24 <Clint> ezzieyguywuf: do you mean https://packdeps.haskellers.com/reverse/gl
17:28:02 <ezzieyguywuf> Clint: yes I do
17:28:04 <ezzieyguywuf> *facepalm*
17:28:28 <ezzieyguywuf> is the gl package and OpenGLRaw essentially the same?
17:37:09 <wudis> lambdabot: @type fmap
17:37:11 <lambdabot> Functor f => (a -> b) -> f a -> f b
17:40:28 <L29Ah> @type fail
17:40:29 <lambdabot> MonadFail m => String -> m a
17:57:37 <rand809809> What is a good parser combinator library? (project scope: toy compiler)
17:58:25 <MarcelineVQ> megaparsec is fairly popular and has tutorials
18:04:41 <rand809809> Also, what's the point of separating lexers and parsers? It seems to me like if I use parser combinators, then I'll be skipping the lex step
18:08:07 <L29Ah> probably to deal with various sorts of whitespace in a separate place? dunno, it doesn't seem like it's of much use with parsec-like parsers
18:12:57 <L29Ah> @tell rand809809 https://stackoverflow.com/a/15216204/4095104
18:12:57 <lambdabot> Consider it noted.
18:20:13 <NightPatrolman> Hello, Haskell beginner here. I'm trying to figure out this Haskell exercise at the end of a chapter in the purple Haskell book that made its rounds.
18:21:18 <NightPatrolman> I figured out the exercise before it where I have a function return the third letter in a given string, but the following one I'm stuck on has me editing what I have to take the xth character in a string.
18:21:50 <NightPatrolman> I'm not sure if I'm supposed to set what number from the string gets taken manually in the file or if I have the function ask which number in ghci once I compile and run it.
18:22:45 <L29Ah> just do both (:
18:24:51 <NightPatrolman> That's where I'm running into a problem. I tried to set it so that I can define the xth character in a string using the suggested function that they throw in, which I'm trying to fill myself
18:25:00 <NightPatrolman> letterIndex :: Int -> Char
18:25:04 <NightPatrolman> letterIndex x =
18:25:32 <NightPatrolman> I tried using "letterIndex = (!!) setPhrase x" where x is the number.
18:25:45 <NightPatrolman> setPhrase is also the string of characters.
18:26:33 <NightPatrolman> By that I mean it's a function that already has a set string, in this case "Curry is awesome!"
18:27:15 <NightPatrolman> I tried running what I have, but I get a compiling error, which is telling me I'm definitely missing something or doing something wrong.
18:27:55 <ski> hm, i think `letterIndex' takes the number as a parameter ?
18:28:27 <ski> `letterIndex = (!!) setPhrase x' probably doesn't work, since `x' is not defined / in scope
18:28:46 <ski> how about keeping the `x' in `letterIndex x = ...' ?
18:30:38 <NightPatrolman> I think my issue so far is in how I print it? At least according to the compiler.
18:30:58 <NightPatrolman> Unless I'm really missing something, but then again, it is telling me that x isn't in scope for that "putChar" line.
18:31:01 <ski> what is the compilation error you're getting ?
18:31:16 <NightPatrolman> xLetterFunction.hs:17:23: error: Variable not in scope: x
18:31:19 <ski> does the exercise tell you to print it ?
18:31:29 <NightPatrolman> 17 |   putChar letterIndex x
18:31:45 <ski> yea, that's what i suspected, hence my suggestion about keeping `x'
18:31:55 <NightPatrolman> I'm pretty sure I need to print it since I'm using the previous exercise to make it, and that printed the third character, in this case "r"
18:32:03 <ski> well, perhaps you meant `putChar (letterIndex x)', there ?
18:32:08 <ski> mhm
18:32:12 <NightPatrolman> Let me try that then
18:32:17 * ski hasn't seen this exercise
18:32:58 <ski> note that if you write `putChar letterIndex x', you're basically trying to pass two parameters to `putChar', namely `letterIndex', and also `x'
18:33:24 <ski> but, presumably, you wanted to call `letterIndex' with actual parameter `x', then pass the result of that to `putChar'
18:33:50 <NightPatrolman> I tried "letterIndex" on its own and got a bigger compiler error. I thought I had been close by changing it to "letterIndex x"
18:34:03 <ski> mhm
18:34:11 * hackage nixdu 0.1.0.0 - Interactively browse a Nix store paths dependencies  https://hackage.haskell.org/package/nixdu-0.1.0.0 (utdemir)
18:34:30 <ski> perhaps it'd help to get an overview of what you're trying, if you could paste your current code, for this exercise, at some paste site
18:36:04 <NightPatrolman> https://pastebin.com/EEw9agEk
18:36:36 <ski> ok
18:36:58 <ski> so, you need to pass some number to `letterIndex', when you're calling it from `main'
18:37:03 <ski> you could pass `3', e.g.
18:37:30 <ski> or, you could possibly ask the user of the program to type in some number, which you'll then pass
18:38:06 <ski> if you want to, you could define `x' to be `3', inside `main', with a command line like `let x = 3'
18:38:11 <sm[m]> I have a replicate call that quickly eats all memory if it accidentally receives an abnormally large argument. See eg https://termbin.com/1n49. I think it's just inherent to replicate, right ? What's an efficient/safe way to generate this indent, even when it's large ? https://github.com/simonmichael/hledger/issues/1275#L616 is the actual code
18:38:36 <ski> (that `x' would be a different `x' from the one in the definition of `letterIndex', just happening to have the same name)
18:40:30 <ezzieyguywuf> I'm struggling a bit with figuring out how to approach this: http://dpaste.com/0Y8TKZ3
18:40:31 <sm[m]> I guess I'm asking about how to keep it running in constant memory here, even if it runs forever 
18:41:22 <ezzieyguywuf> I want the function `consume :: [Value] -> Consumer -> IO ()` to match whatever `Value` the `Consumer` has, but this seems like maybe the wrong approach
18:42:08 <ezzieyguywuf> I'm wondering if there is some pattern or idiom that I'm not familiar with that may be useful
18:42:57 <NightPatrolman> I'm struggling to find a way to put "let x = 3" in main, because it didn't seem to work.
18:43:11 <ezzieyguywuf> NightPatrolman: you don't need `in` afterwards
18:43:33 <ski> put it after the `do', on the next line, above the `putChar' lines, indented the same amount as them
18:43:38 <sm[m]> also: why does Word wrap around to 0, eg (maxBound :: Word) + 1 == 0 ?
18:45:02 <sm[m]> damn.. biab
18:45:14 <ski> dunno what you want, ezzieyguywuf
18:45:18 <MarcelineVQ> sm[m]: probably writeFile demands the whole list at once so you'd [probably] need an incremental/streaming writer
18:45:36 <NightPatrolman> I put let "x = 3" just above the first putChar line and I'm still getting a compiling error about how letterIndex is applied to too few arguments.
18:46:10 <wavemode> you ought to put your code in a gist
18:46:22 <NightPatrolman> I tried changing "putChar letterIndex" to "putChar letterIndex x" and saw no difference either.
18:46:39 <ezzieyguywuf> ski: hrm, guess my example was not descriptive enough.
18:46:58 <MarcelineVQ> sm[m]: blind guess there though, there's nothing inherently explosive about [list] replicate that I can think of
18:47:10 <ski> NightPatrolman : yes, you still need to call `letterIndex' properly, e.g. like how i suggested
18:47:20 <solonarv> sm[m]: why not? modular arithmetic is perfectly sensible and well-defined, and it's cheaper to just let that happen rather than throwing some kind of error
18:52:43 <sm[m]> doh Word is unsigned. Thank you
19:02:43 <NightPatrolman> I'm still at it, but I'm more confused than ever right now. I'm not entirely sure how I'd begin to call letterIndex properly now.
19:03:21 <koz_> NightPatrolman: What's letterIndex' type?
19:04:05 <NightPatrolman> I believe it's supposed to bring back a character, so I'm thinking char, but the book wants me to handle it going from Int to Char
19:05:07 <NightPatrolman> It's explicitly telling me to use "letterIndex :: Int -> Char" and "letterIndex x = ..." where I'm guessing I fill in after the equal sign. I'm not sure if there's just a much easier way of doing this.
19:05:35 <koz_> NightPatrolman: What exactly is the task?
19:06:36 <NightPatrolman> The previous exercise had a task to take the third character in a given string of characters, set in the file as "Curry is awesome!" This exercise wants me to use the previous code and change it so that it takes the Xth character instead of just the third one.
19:07:49 <NightPatrolman> The description isn't too clear, but I'm guessing I either define X in ghci after loading it or have it set as a variable in the code. They don't really specify which.
19:08:19 <NightPatrolman> I'm thinking the former because what would be the point if I could just change one number in the previous program?
19:09:56 <ezzieyguywuf> ski: I guess the only way I can clarify is to be more specific - I'm working with openGL. In order to draw something, I have to compile a "shader" which is a program run on the gpu. The part I'm working on is trying to develop a data type (Consumer in my example) that can be used with a Shader to issue a "render" call to openGL.
19:11:07 <ezzieyguywuf> the hard part, though, is the  flexibility that openGL gives: it will allow for the Shader to accept any kind of data - it can be a single Float, two Float, one Float one (V3 Float) etc... This is specified at runtime, i.e. you tell openGL "this Shader expects data in this shape"
19:11:58 <ezzieyguywuf> then when you make a "render" call, you say "use this Shader, with this shape of data, and read this many data points" and it knows what to do
19:24:53 <NightPatrolman> I tried separating x as Int on its own and letterIndex as Char on its own, and I'm still not any closer. I can't seem to get x within scope for some reason, even when I set x to equal 3 before main and "let x = 3" in main, and one or the other on their own. No dice.
19:25:09 <NightPatrolman> I'm giving up for tonight and trying again tomorrow. Thanks to everyone who at least tried to help.
20:39:52 <koz_> ezzieyguywuf: Is the set of types of data that can be fed in closed?
20:47:06 <tzh> i'm not super familiar with the opengl package but this sounds the thing that gpipe uses type families to solve? they have a buffer format class with a host format type family https://hackage.haskell.org/package/GPipe-2.2.5/docs/Graphics-GPipe-Buffer.html#t:HostFormat
20:50:42 * hackage implicit-hie-cradle 0.1.0.0 - Auto generate hie-bios cradles  https://hackage.haskell.org/package/implicit-hie-cradle-0.1.0.0 (Avi_Dessauer)
21:00:46 <jusss> how to extend a typeclass? like make Functor to require a new function like 'fix'?
21:02:18 <wavemode> you can't. but you can make a typeclass which is a subclass of another, e.g. like how Applicative is a subclass of Functor
21:02:23 <jusss> typeclass as instance of another typeclass?
21:02:47 <wavemode> so any given Applicative type necessarily also has a definition for fmap
21:03:28 <jusss> should Functor be a subclass of Applicative?
21:03:41 <jusss> Applicative has what Function have,
21:03:53 <jusss> but Functor doesn't have what Applicative has
21:04:46 <wavemode> think of it like subset/superset. all Applicatives are Functors, thus Applicative types represent a SUBset of all Functor types.
21:05:21 <jusss> ok
21:36:23 <justsomeguy> Are generic types in other languages the same thing as paremeterized types in haskell?
21:37:30 <justsomeguy> Hmm... Wikipedia says yes.
21:45:50 <hyiltiz> tommd did u mean the Stan package for doing Bayes Networks?
21:51:12 * hackage wakame 0.1.0.0 - Functions to manipulate records  https://hackage.haskell.org/package/wakame-0.1.0.0 (kayhide)
22:25:42 * hackage pandoc-crossref 0.3.6.4 - Pandoc filter for cross-references  https://hackage.haskell.org/package/pandoc-crossref-0.3.6.4 (lierdakil)
22:32:43 <jusss> g :: (Functor f) => f Int -> f (Int -> String) -> f String
22:32:49 <jusss> how I implement this function?
22:34:32 <Cale> You need Applicative f if you want the sensible thing. You could also ignore the first argument and do something like g _ x = fmap ($ 0) x
22:34:50 <Cale> :t fmap
22:34:51 <lambdabot> Functor f => (a -> b) -> f a -> f b
22:35:11 <Cale> Functor doesn't let you do anything to combine values of f-typed things
22:35:16 <Cale> :t (<*>)
22:35:18 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
22:37:04 <jusss> that `f Int` is new to me, I never thought that I can change the type constructor
22:37:18 <Cale> hm?
22:37:19 <jusss> f Int, so I can use Maybe Int, [Int], Either a Int
22:37:26 <Cale> yeah
22:37:46 <jusss> we always use that `f a`, f and a here both can be replaced
22:37:51 <Cale> yeah
22:37:59 <Cale> It's polymorphic in a choice of functor f
22:38:00 <jusss> but the most time, we just replace that a,
22:38:20 <jusss> and we use type variables too much, 
22:39:02 <jusss> Cale: like that type constraints, can we constraint the `f` from `f a` ?
22:39:22 <dmwit> Yes, neither the `f` nor the `a` is particularly special.
22:39:32 <dmwit> Just about anything you can do to one, you can do to the other.
22:39:33 <jusss> Cale: like we can constraint types have *, can we constraint types have * -> *?
22:40:23 <Cale> jusss: There are examples of that just above
22:40:24 <dmwit> Yes. (I think. Maybe I don't understand the question. But if I do understand the question, then the answer is yes.)
22:40:29 <Cale> Functor f => ...
22:41:15 <Cale> I think you meant to say "constrain" (which is a verb) rather than "constraint" (which is a noun or adjective) though
22:41:25 <jusss> Cale: I see, if I just want Maybe and [], so I should make a new typeclass, and make Maybe and [] as its instances?
22:41:47 <jusss> then declare where I'd like to use with the new typeclass constraints
22:41:58 <dmwit> Right.
22:42:01 <jusss> sorry, my English is not good
22:42:26 <dmwit> No worries. We both will try our best to understand each other. ^_^
22:42:33 <jusss> n, adj, and verb, sometimes I may mix them
22:42:53 <Cale> jusss: Well, sure, that will work, but when you define a new type class, you should have operations in mind
22:43:20 <Cale> Functor is a good example of an existing type class for which Maybe and [] are instances
22:43:57 <jusss> actually I'm reading the arrow-kt library from kotlin, and they're doing something that I never thought in haskell
22:44:37 <jusss> some features that in haskell is too normal, but not normal for other languages
22:45:03 <jusss> s/is/are
22:45:27 <wudis> lambdabot: @type Float
22:45:28 <lambdabot> error:
22:45:29 <lambdabot>     • Data constructor not in scope: Float
22:45:29 <lambdabot>     • Perhaps you meant variable ‘float’ (imported from Text.PrettyPrint.HughesPJ)
22:46:18 <wudis> lambdabot: @type Double
22:46:19 <lambdabot> error:
22:46:19 <lambdabot>     • Data constructor not in scope: Double
22:46:19 <lambdabot>     • Perhaps you meant variable ‘double’ (imported from Text.PrettyPrint.HughesPJ)
22:46:35 <dmwit> jusss: Yes, higher-kinded polymorphism is rare. ("higher-kinded polymorphism" is the name for this, where `f` can stand for [] or Maybe.)
22:47:02 <jusss> typeclass can do type constraints, require specific function implements and function overloading, that OOP langauges don't have those at the same time
22:47:38 <jusss> they may have generics, interfaces and class extensions, but they're three stuff
22:48:21 <jusss> dmwit: so when I see kotlin's arrow code, it's really weird to me about higher-kinded polymorphism,
22:49:34 <jusss> they may concrete the `a` in `f a`, and replace that `f`, I never saw that in haskell
22:50:57 <jusss> like that `f Int` or `f String`
22:51:37 <jusss> `f Int` may be `Maybe Int` `[Int]` `Either a Int` ...
22:52:06 <jusss> but we may just use `f a`...
22:52:42 <jusss> or make a new typeclass for Int and String, then do type constraints on that `f a`
22:55:11 <jusss> those static type languages give me a feel that they want do something freely as dynamic languages, and with type system protection?
22:56:20 <dmwit> Hm. That could be one way to understand it. =)
22:56:52 <dmwit> I very rarely think "I wish this was a dynamic language".
22:57:00 <dmwit> So not everybody wants that.
22:57:55 <Cale> Type classes let you do things that would be essentially impossible in dynamically-typed settings
22:58:28 <materiyolo> hi
22:59:17 <jusss> dmwit: do you like that recursive type? function return function itself is normal in dyanmic languages which haskell doesn't support
22:59:24 <materiyolo> i installed ghc 8.8.3 and deleted 8.6.5 both from Stack
22:59:27 <Cale> The instance of a type class to be used can depend on the result type of the operation for example, which is usually something you can't easily do in a dynamically typed setting
22:59:31 <Cale> :t read
22:59:32 <lambdabot> Read a => String -> a
22:59:46 <materiyolo> now whenever i save a file in emacs i'm getting this line ``/home/thonkpad/.stack/programs/x86_64-linux/ghc-tinfo6-8.6.5/lib/ghc-8.6.5/settings: openFile: does not exist (No such file or directory)`
22:59:54 <Cale> Which parser to use to read the string depends on the type of value you want
23:00:05 <materiyolo> any way to fix this?
23:00:50 <jusss> Cale: but type is alive on run-time?
23:01:02 <Cale> jusss: hm?
23:01:12 <Cale> jusss: Types aren't around at runtime
23:01:16 <dmwit> jusss: I like recursive types. Haskell can have a function that returns a function (even recursively) with minimal fuss; at most some newtype nonsense.
23:01:20 <Cale> They're erased by compilation
23:01:39 <Cale> (at least in Haskell)
23:01:59 <dmwit> % newtype Weird a = Weird (a -> Weird a)
23:02:00 <yahb> dmwit: 
23:02:19 <dmwit> % f :: Weird a; f = Weird (\x -> f)
23:02:20 <yahb> dmwit: 
23:02:37 <dmwit> jusss: ^ no matter how many arguments you feed to `f`, it will still return yet another function.
23:03:12 <dmwit> % feed :: Weird a -> a -> Weird a; feed (Weird f) x = f x
23:03:13 <yahb> dmwit: 
23:03:40 <dmwit> % :t feed (feed f 3) 4
23:03:40 <yahb> dmwit: Num a => Weird a
23:03:44 <c_wraith> that's possible, but not very useful.  :P
23:04:01 <dmwit> Sure. But more useful things are possible with the same trick.
23:04:03 <c_wraith> variations of it are very useful, though
23:04:04 <dmwit> It is pedagogical.
23:04:18 <jusss> dmwit, aha, js: const f = _ => {console.log(_); return f}  how about to implement this  in haskell?
23:04:34 <c_wraith> don't forget the surprisingly useful newtype Hyper a b = Hyper (Hyper b a -> b)
23:04:42 <c_wraith> doesn't look useful.  actually is!
23:04:53 <dmwit> :t \f _ -> putStr "" >> return f -- jusss, this?
23:04:54 <lambdabot> b -> p -> IO b
23:05:08 <dmwit> I don't know js. So.
23:05:58 <dmwit> (`b` can be chosen to be the type of a function, no problem)
23:06:32 <dmwit> jusss: I am going to bed. Keep asking questions. Others here can also help you.
23:08:04 <jusss> c_wraith: do you know a little js?
23:08:23 <jusss> const f = _ => {console.log(_); return f}  could express in haslell?
23:08:31 <materiyolo> hm
23:08:38 <koz_> jusss: dmwit just gave it to you above.
23:08:39 <c_wraith> Pretty sure dmwit nailed it
23:09:09 <c_wraith> Oh, unless you actually wanted to log the second argument.
23:09:58 <c_wraith> which would end up like \a b -> print b >> return a
23:10:30 <jusss> f 3 should print 3, f 3 4 should print 3 and 4, f 3 4 5 should print 3 4 5
23:10:55 <jusss> in other languages, f(3), f(3)(4), f(3)(4)(5)
23:11:27 <jusss> if python support multiple lambdas, it should be `f = lambda x: print(x);return f`
23:12:02 <jusss> so f(3)(4)(5) and f(3) and f(3)(4) have the same return value, which is f itself
23:12:53 <Cale> jusss: Evaluation of a function can't usually print anything in Haskell
23:13:08 <jusss> koz_: c_wraith \f _ -> putStr "" >> return f is that?
23:14:08 <Cale> If it's allowed to produce an IO action which must be executed to give you the function, that's easier though.
23:14:30 <jusss> which is?
23:15:21 <Cale> You'll need a recursive newtype to make this work, since if you think about it, we'll need something like  Show a => a -> IO t  where t = a -> IO t
23:15:55 <jusss> code? :)
23:16:10 <Cale> So in order to make that happen, we can define  newtype Consumer a = C (a -> IO (Consumer a))
23:16:26 <Cale> runConsumer :: Consumer a -> a -> IO (Consumer a)
23:16:37 <Cale> runConsumer (C f) x = f x
23:17:23 <Cale> and then have  f :: Show a => Consumer a; f = C (\x -> do print x; return f)
23:18:24 <Cale> So, then you can write stuff like:
23:19:08 <Cale> do f' <- runConsumer f 3; f'' <- runConsumer f' 4; f''' <- runConsumer f'' 5; return f'''
23:19:34 <Cale> Of course, with this particular f, that's a little silly
23:20:07 <Cale> But if we had an f which was producing a different consumer in its result than itself, then chaining like this would be meaningful
23:21:42 <Cale> In Haskell, we don't have a type t for which t is *actually* equal to a -> IO t, but with this newtype, we get one for which t is isomorphic to a -> IO t
23:24:00 <jusss> Cale: f' <- runConsumer f 3;     f'' <- runConsumer f' 4;     f''' <- runConsumer f'' 5;  we couldn't have f <- runConsumer f 3?
23:24:20 <Cale> You could, but that would shadow the f which was in scope, which is just confusing
23:24:46 <jusss> Cale: how it could like be?
23:25:15 <jusss> I just wonder, of course this may not be meaningful
23:28:57 <Cale> Not sure I understand that question
23:29:20 <jusss> Cale: "You could, but that would shadow the f which was in scope, which is just confusing"
23:30:01 <Cale> Yeah, the code you wrote is valid, it's just not advisable, since you won't be able to refer to the old f any longer. Perhaps that's what you want, but shadowing like that is also confusing to readers usually.
23:30:27 <jusss> could you show me how?
23:31:03 <Cale> I don't know what you're asking me to show
23:31:12 <Cale> You wrote the code, I'm saying that's valid
23:31:39 <Cale> You could replace the occurrences of f' and f'' and f''' in the code I wrote with f
23:31:45 <Cale> and it would mean the exact same thing
23:31:58 <Cale> It's just a more confusing way to write the same code
23:32:50 <dminuoso> I think they're rather hoping for something like mdo
23:33:30 <jusss> Cale: I see
23:35:43 <Cale> dminuoso: mdo wouldn't make sense here, because then there's nothing to determine any part of f
23:36:04 <dminuoso> Oh I know Cale, it's just an educated guess based on the many previous conversations I've had with them.
23:36:31 <dminuoso> Consider their example of `const f = _ => {console.log(_); return f}`
23:37:22 <dminuoso> Im not saying it makes any particular sense, it's more probably jusss has some gaping confusion in their head. :)
23:37:47 <Cale> Well, we took a fixed point originally when defining f, sure
23:38:58 <jusss> dminuoso: I just wonder can we do something freely as dynamic languages
23:39:22 <dminuoso> With crutches and tricks we can mimic dynamic languages, yes.
23:39:27 <dminuoso> Is it a good idea? Most likely not.
23:39:50 <Cale> This kind of recursive continuation-y thing can be useful
23:40:15 <Cale> A lot of early arrowized FRP systems are based on a slightly more elaborate version of this trick
23:40:50 <Cale> You can get "local state" by having parts of the computation which replace themselves. I suppose a lot of the stream processing libraries like pipes and conduit also apply
23:44:09 <jusss> "recursive continuation-y" I wonder if there's "fixed-point continuation" and what it would be?
23:46:19 <Cale> In which particular case?
23:46:28 <Cale> Usually that's a reasonable way of expressing infinite loops
23:48:11 <jusss> I don't know yet
23:48:42 <jusss> just a random combine term
23:49:26 <jusss> goto = callCC \out -> fix out, that is interesting
23:51:12 <Cale> That's not really goto, but the thing which would make a label
23:51:40 <Cale> (and then you'd execute the label to jump back to there)
23:53:46 <jusss> it has take me a few days to learn Cont Monad and higher-kinded polymorphism in arrow-kt, and I'm still not clear about them,
23:54:21 <Cale> I don't know what arrow-kt is
23:54:36 <Cale> We don't really use the Cont monad a whole lot
23:54:37 <jusss> arrow library from kotlin
23:54:46 <Cale> Never really looked at kotlin
23:55:06 <Cale> Cont can clean up a very particular kind of mess, but it's one that doesn't show up too often
23:55:08 <jusss> I use kotlin in my work
23:56:31 <jusss> haskell jobs require too many skills and there's no haskell need in my place
23:56:56 <jusss> so I use kotlin, python and js sometimes in work
23:57:18 <materiyolo> hm is there any point in using a ghc version newer than 8.6.5?
23:57:41 <Cale> maybe
23:57:54 <Cale> But 8.6.5 is a decent version
23:58:03 <materiyolo> seems i cant install any packages from stack for ghc 8.8.3
23:58:14 <materiyolo> because of dependencies
23:58:55 <Cale> I haven't used stack, but a lot of packages may still need updating for 8.8
23:59:15 <jusss> Cale: you use cabal too?
23:59:19 <materiyolo> im guessing 8.8 in general isn't stable or something then lol
23:59:27 <Cale> I use mostly nix
