01:21:42 <jusss`> what does <|> do?
01:23:28 <f-a> > Just 8 <|> Nothing
01:23:31 <lambdabot>  Just 8
01:23:37 <f-a> > Nothing <|> Just 8
01:23:39 <lambdabot>  Just 8
01:23:46 <f-a> you often see it in parser combinators
01:24:25 <jusss`> f-a: for what?
01:24:40 <phadej> ja: the cabal doctest command even exist is a great example of thing which doesn't work
01:24:48 <phadej> (even it exists)
01:24:58 <jusss`> f-a: which parser is the simple? happy or parserc or lex?
01:25:21 <phadej> jackdk: check the above discussion, `build-type: Simply` and doctest in a test-suite eworks
01:25:27 <f-a> I think parsec is simpler to use
01:25:48 <phadej> about as long as you don't have half of Hackage in your global db, wich e.g. nix people do
01:25:53 <phadej> that solution doesn't scale
01:26:59 <phadej> (neither it works with v2-build, where global db doesn't have any dependencies)
01:27:51 <merijn> jusss`: It depends on the instance
01:28:04 <merijn> :t (<|>)
01:28:05 <lambdabot> Alternative f => f a -> f a -> f a
01:28:43 <merijn> jusss`: In parser combinators it's usually "take the left-most option that succeeds", but that's not a definition that works for all Alternative instances
01:34:40 <phadej> > "foo" <|> "bar"
01:34:42 <lambdabot>  "foobar"
01:34:53 <phadej> could be just "foo" though
01:35:47 <phadej> (it would still make sense even when you think of list as ND-monad)
01:45:37 <jusss`> > Just 8 <|> Just "8"
01:45:39 <lambdabot>  error:
01:45:39 <lambdabot>      ‚Ä¢ No instance for (Num [Char]) arising from the literal ‚Äò8‚Äô
01:45:39 <lambdabot>      ‚Ä¢ In the first argument of ‚ÄòJust‚Äô, namely ‚Äò8‚Äô
01:51:42 <jusss`> how to share variable in async?
01:52:42 <jusss`> Control.Concurrent.Async
01:54:29 <jusss`> l <- async $ f1 v1; m <- async $ f2 v2; how to share that v1 and v2 in both?
01:54:42 <jusss`> in f2 to visit that v1
02:00:51 <Waldkauz> What are f1 and f2? Can't you just use the same variable?
02:02:39 <jusss`> Waldkauz: f1 and f2 both are loop functions
02:03:19 <jusss`> Waldkauz: for example, f1 is that recv function about socket, it's a loop for recv something from internet
02:03:40 <jusss`> Waldkauz: and f2 is a send function, it needs that what f1 received data
02:04:32 <jusss`> so how I can get what f1 received in f2?
02:05:17 <jusss`> since f1 and f2 both are loop functions, so I don't think await to get the result is a good way
02:05:34 <Waldkauz> Hhm, I don't know then
02:07:00 <jusss`> or make f1 and f2 aren't loop functions, use `wait` to get what f1 received and pass it to f2, put f1 and f2 in one loop
04:26:21 <ADG1089> hi guys
04:27:33 <Axman6> Hello!
04:28:00 <Axman6> Congratulations on breaking nearly 2.5h of silence
04:28:53 <Uniaika> damnit, you ruined everything!!!! /s
05:25:24 <NewToHaskell> How can I name a function like this with apostrophe? `(!!!) :: [a] -> Int -> a
05:25:33 <NewToHaskell> like `(!!')`
05:26:14 <hpc> parens and backticks are syntax, and can't be part of identifiers
05:26:20 <merijn> NewToHaskell: You can't, ` is syntax for making prefix functions behave as infix
05:26:38 <merijn> NewToHaskell: !!! is already an operator, so the `` would be redundant anyway
05:26:45 <dminuoso> NewToHaskell: Flip on UnicodeSyntax and then use üòÅ ?
05:26:59 <dminuoso> </jokingly>
05:27:10 <dminuoso> That's the Agda way. >:)
05:27:41 <merijn> Oh, the apostrophe is a non-symbol character so can't be used in operators
05:27:52 <merijn> So !!' can never work
05:31:19 <NewToHaskell> merjin: Oh ok, thanks.
05:34:36 <hc> What happened to lpaste.net?
05:34:46 <merijn> hc: It's been gone for ages
05:35:04 <merijn> Chris didn't have time to run it anymore and no one suitable took over
05:35:52 <hc> Hmm, I live in germany, we have legislation that would make it very time consuming for me to run it ;/
05:36:26 * hackage niv 0.2.14 - Easy dependency management for Nix projects  https://hackage.haskell.org/package/niv-0.2.14 (nmattia)
05:36:52 <hc> Anyway, my actual question is this: Is there a way to make this program valid haskell syntax: https://paste.linuxlounge.net/Z5OQ
05:36:56 <hc> Preferably without using template haskell ;)
05:36:59 <merijn> "yes"
05:37:05 <hc> how? :)
05:37:23 <merijn> I mean in the sense that if you change enough any program can be made valid Haskell :p
05:37:41 <hc> haha, what about without chaning it?
05:37:41 <ptrcmd> hc: you mean GDPR?
05:38:01 <hc> ptrcmd: that, plus the requirement to proactively filter out "hate speech" and the likes
05:39:07 <merijn> hc: Anyway, this seems to already solve your problem: https://hackage.haskell.org/package/BASIC-0.1.5.0/docs/Language-BASIC.html :p
05:39:09 <ptrcmd> hc: huh, that wouldn't just be time consuming..you would also probably need a moderation team or something like that..
05:39:17 <merijn> ptrcmd: GDPR isn't time consuming at all for a paste site
05:39:26 <merijn> ptrcmd: All you really need is a way to delete pastes
05:39:33 <hc> thanks merijn  :)
05:40:00 <merijn> ptrcmd: The reason lpaste was time consuming to run was the need to moderate spam
05:40:06 <ptrcmd> ah
05:40:20 <hc> what about lpaste with an auto expiry of 7 days or so?
05:40:35 <merijn> hc: Knock yourself out ;)
05:40:48 <merijn> Let us know if you've got it running :)
05:41:02 <hc> merijn: deal, I'll do it this weekend :)
05:41:19 <dminuoso> If you run any paste service, accepting input from authenticated users, you're going to get into a lot of pain.
05:41:22 <dminuoso> *unauthenticated
05:41:31 <merijn> hc: Also, I find it hard to believe that German requires pro-active filtering of hate speech without some sort of "common carrier" protection, I though almost every country had something like that
05:42:00 <hc> merijn: sure, think I as a private individual count as a "common carrier"? ;)
05:42:36 <dminuoso> hc: I dont think a paste services fits. Afaik it only applies to social media.
05:42:40 <merijn> ptrcmd: tbh, contrary to all the FUD on the internet the GDPR is a fairly common sense law that requires reasonably little effort for "new code" (i.e. don't need to fix/change existing architecture"
05:43:13 <merijn> hc: "common carrier" usually applies to any service that accepts data from "the public"
05:43:40 <merijn> hc: i.e. if you host a forum you are not liable for stuff users post IFF you promptly remove illegal content when it is reported to you
05:44:18 <hc> merijn: Hmm, I could add a "delete" button that anyone in possession of the precise URL can use, and then add a 2 hour delay or so
05:44:31 <hc> merijn: but what about re-posts of such content? I'd also have to store hashes, probably
05:44:33 <ptrcmd> merijn: how's "the public" defined here?
05:44:44 <ptrcmd> merijn: usually
05:45:04 <merijn> ptrcmd: "people you didn't vet explicitly" (i.e. if any random person can register without affiliation with you)
05:45:10 <dminuoso> https://www.gesetze-im-internet.de/netzdg/BJNR335210017.html
05:45:21 <MarcelineVQ> however the lawyer who works for the guy that doesn't like you wants to define it
05:45:22 <dminuoso> (1) Dieses Gesetz gilt f√ºr Telemediendiensteanbieter, die mit Gewinnerzielungsabsicht Plattformen im Internet betreiben, die dazu bestimmt sind, dass Nutzer beliebige Inhalte mit anderen Nutzern teilen oder der √ñffentlichkeit zug√§nglich machen (soziale Netzwerke). Plattformen mit journalistisch-redaktionell gestalteten Angeboten, die vom Diensteanbieter selbst verantwortet werden, gelten nicht
05:45:24 <dminuoso> als soziale Netzwerke im Sinne dieses Gesetzes. Das Gleiche gilt f√ºr Plattformen, die zur Individualkommunikation oder zur Verbreitung spezifischer Inhalte bestimmt sind.
05:45:32 <dminuoso> I think it's quite clear that this would not apply to lpaste.
05:45:35 <ptrcmd> merijn: ah ok
05:45:48 <merijn> ptrcmd: Like, if you have a limited blog with only 5 contributors all manually invited by you then it doesn't apply, because you clearly preselected them
05:46:03 <ptrcmd> merijn: right
05:46:28 <NewToHaskell> Can somone explain why I get a parse error `Parse error in pattern: (x : _)` ? It's my first time defining an infix function, namely `(!!)`.
05:46:46 <NewToHaskell> `
05:46:51 <merijn> NewToHaskell: Not without you showing us the actual code :)
05:48:18 <maerwald> man, I'm stuck with not understanding why my logging thread doesn't consume the last line of stdout, when the process dies
05:48:43 <maerwald> shouldn't have used unix pipes and forkIO :p
05:56:11 <NewToHaskell> `(!!!) :: [a] -> Int -> a
05:56:24 <NewToHaskell> this appears to be working, fault was in the parentheses.
05:56:27 <maerwald> merijn: help :p
05:58:03 <tdammers> I think the crucial part there is the "Gewinnerzielungsabsicht" ("for profit")
05:59:48 <maerwald> well, what if you make profit, but it wasn't your intention
06:00:25 <ptrcmd> maerwald: is that related to flushing? (just some random guess)
06:00:53 <maerwald> ptrcmd: I am not sure at all
06:00:54 <merijn> maerwald: E_INSUFFICIENT_INFO
06:01:29 <merijn> maerwald: Are you talking about the logging thread in the dying process?
06:03:16 <tdammers> maerwald: matter of per-case interpretation, I'd guess
06:03:54 <tdammers> but I reckon if you're a registered nonprofit, you could reasonably argue that there was not a for-profit intention
06:04:05 <maerwald> merijn: https://git.io/JJs56 somewhere here
06:04:08 <maerwald> code is messy
06:04:32 <maerwald> but you usally cannot reproduce stuff like this with a minimal example
06:04:34 <tdammers> whereas if you are a GmbH, and the platform is the only thing you ever did, and you're running massive amounts of ads on it, then it'll be hard to argue that there was no profit intent
06:04:35 <merijn> maerwald: when the main thread exits all thread die immeidately
06:04:45 <merijn> maerwald: That's what I was getting at
06:05:04 <merijn> maerwald: So unless you keep the mainthread alive until the logging thread finishes, this is "working as intended"
06:05:12 <maerwald> I do
06:06:06 <maerwald> I create pipes, fork a subprocess, redirect stdout and stderr to the pipe, read from it in the logging thread (even after the subprocess dies)
06:07:00 <tdammers> also, the intention of that law is to keep companies in check that monetize user-generated content and personal information about their users
06:07:10 <merijn> maerwald: oh...you use fork
06:07:17 <merijn> maerwald: ha, good fucking luck to you
06:07:19 <maerwald> lol
06:07:26 <merijn> Seriously
06:07:27 * hackage numhask 0.6.0 - numeric classes  https://hackage.haskell.org/package/numhask-0.6.0 (tonyday567)
06:07:51 <merijn> I have become convinced that it is literally impossible to correctly use fork form Haskell
06:07:54 <merijn> Just can't be done
06:07:59 <merijn> There is 0 hope
06:09:17 <maerwald> sometimes it prints the last line, but cuts off some chars from the start of the bytestring
06:09:28 <merijn> maerwald: You don't have any control what other threads in the RTS are doing
06:10:17 <merijn> I recommend rewriting line 125-144 to use either posix_spawn or use the process library
06:10:49 <maerwald> I tried thread delay and even masking, to be sure the line-reader function isn't interrupted, but it doesn't help... it's as if stuff doesn't reach the pipe
06:10:57 <merijn> And I know you don't want to use process because you believe all "portable abstractions are broken nonsense", but tough shit, because your code is currently more broken nonsense than process ;)
06:11:20 <maerwald> nah, it works well
06:11:44 <maerwald> :p
06:11:48 <skep> Hi
06:11:51 <merijn> Right, that's why you were asking for help ;)
06:11:56 * hackage futhark 0.16.2 - An optimising compiler for a functional, array-oriented language.  https://hackage.haskell.org/package/futhark-0.16.2 (TroelsHenriksen)
06:12:21 <skep> Why should i learn Haskell
06:12:36 <merijn> skep: Why not?
06:12:38 <skep> I don't know the notion of oop
06:12:53 <skep> OOP
06:13:14 <skep> What Haskell do for me?
06:13:22 <maerwald> unix doesn't have posix_spawn though?
06:13:46 <maerwald> skep: messes with your mind
06:14:26 <skep> I like mess
06:14:37 <merijn> maerwald: That seems an oversight in unix, then
06:15:04 <maerwald> alright... PRs usually take a year to get reviewed and accepted
06:15:10 <maerwald> so that looks...
06:15:13 <skep> Why Haskell made for us?
06:16:05 <maerwald> Haskell is like blue berries.. a little mysterious, very sweet in the beginning... if you eat too much it tastes a little sour, but is still good for your blood pressure
06:16:29 <merijn> maerwald: you can FFI directly to it while it's not merged :p
06:17:01 <maralorn> > I'm surprised anyone " who codes Haskell professionally in a large team" uses layout or relies on it to read large codebases. (from https://github.com/ghc-proposals/ghc-proposals/pull/346, last comment)
06:17:01 <merijn> maerwald: Anyway, you like being pedantic about posix portability and fork has been deprecated in favour of posix_spawn for like two decades now, so ;)
06:17:03 <lambdabot>  error:
06:17:03 <lambdabot>      Data constructor not in scope:
06:17:03 <lambdabot>        I'm
06:17:07 <maerwald> merijn: my experince with FFI has been mixed... even more pitfalls
06:17:36 <maerwald> then suddenly it broke on darwin...
06:17:46 <maerwald> and everyone was like... hmm
06:17:49 <maralorn> I wonder how people can be surprised about that if none of haskell code formaters out there, support use { ; } syntax ‚Ä¶
06:18:09 <skep> Well I am happy with PHP
06:18:11 <maralorn> I mean they can parse it. But they don‚Äòt leave it, do they?
06:18:35 <skep> :) haskell is bit new and headshaking
06:18:54 <maerwald> php to haskell is a small leap
06:19:04 <merijn> maralorn: That person is weird and wrong :p
06:19:16 <skep> No man
06:19:28 <merijn> maralorn: That said, I'm thoroughly convinced that earlier arguments in that thread are right and that minor syntactic extensions are the devil
06:19:43 <merijn> BlockArguments in particular was a massively stupid idea
06:20:04 <maralorn> merijn: Well, I actually would love to have a formater which opts out of layout wherever it can.
06:20:11 <maerwald> type level lists also confuse the parser no?
06:20:30 <merijn> lambdacase and multiwayif are semi-justifiable in the sense that they're clearly illegal syntax without the extension
06:21:14 <maralorn> I don‚Äòt wan't to think about formating at all, when I code, I want the formater to always do it. But layout forces me to think about indentation far to often.
06:21:23 <skep> [18:48] (maerwald) php to haskell is a small leap okay I'll try
06:21:30 <merijn> maerwald: "then it stopped working on darwin" <- well, yes, that's why people like portable libraries like process so they can pool their bug detection/fixing efforts :p
06:21:47 <maralorn> I love it in rust. I just need to have the right number of parentheses, rust-fmt, does the rest.
06:22:22 <maerwald> merijn: sure, but then they build abstractions that have significantly diverging behavior across platforms and call it "good enough"
06:22:44 <maerwald> even something as simple as deleting a file needs special care on windows
06:23:34 <merijn> maralorn: Hot take: Auto-formatters are the devil and "I don't want to think about formatting" is lazy programming: https://twitter.com/comerijn/status/1257804634833420292
06:23:50 <merijn> (particularly the followups)
06:23:51 <dminuoso> skep: Whether or not Haskell is worth learning depends on you. Haskell can change how think about programming in general, how you engineer programs. So even if you dont end up using Haskell in production, I think it's a valuable learning experience for many
06:24:08 <maerwald> autoformatters seem to think many newlines make code more readable
06:24:19 <maerwald> the most common fallacy
06:24:49 <merijn> maerwald: process is in a fairly sweet spot, though in terms of the supported functionality. It doesn't do everything you may need, but it covers about 90% of usecases in a portable way (because most usecases aren't that hard)
06:25:27 <merijn> maerwald: Especially stuff like "create a process with redirects" is robust
06:25:48 <maralorn> merijn: I see your points. But at the end I don‚Äòt think I agree.
06:26:10 <merijn> maralorn: That's fine, I can't stop people from being wrong online :p
06:26:32 <maralorn> Your argument where valid if I had the feeling that the output of e.g. brittany would produce unreadable code. But that is nearly never the case.
06:26:51 <maerwald> https://github.com/axelf4/vim-haskell this one is nice (although oddly misnamed)
06:27:29 <maralorn> So yeah, I am lazy. Because there will always be more code to write, than I can write in my life. And I don‚Äòt want to spend it formatting stuff.
06:28:03 <maerwald> Yes, formatters allow you to spend more time with your family
06:28:30 <Uniaika> (note that you do need a family first)
06:28:39 <maralorn> But?
06:28:41 <merijn> Uniaika: Anyone can get a cat :p
06:29:06 <int-e> cat, the trivial code formatter :P
06:29:23 <Uniaika> ofienpofaiezjraozeirhjezorh, my cat says
06:29:36 <Uniaika> or rather, typed on my keyboard
06:29:42 <maralorn> And after a few lines we arrived at "people who dislike code formatters, do so because they have no social life" . That escalated quickly ‚Ä¶
06:29:48 <maerwald> half of your message was lost in a unix pipe
06:30:55 <maerwald> next week on r/science: ppl rejecting code formatters more likely to show autistic traits
06:31:02 <fog> if you had a really good code formatter, maybe it would be better than a cat, social life, and family put together 
06:31:04 <maerwald> (I'm joking ofc)
06:31:24 <merijn> I doubt it, cats are pretty cool
06:31:42 <fog> yeah, but you cant upload your consciousness into a cat
06:31:44 <merijn> Not great for productivity when working from home, but still!
06:32:34 <merijn> Worthless pairprogrammer: http://files.inconsistent.nl/uninterested-coworker.jpg
06:33:54 <MarcelineVQ> Any pair programmer that just wants you to touch their butt is going to be a time waster
06:34:01 <maerwald> lol
06:35:20 <fog> maybe if we worked together we could emulate a network of pair programmers 
06:36:22 <fog> you simulate my cat, ill scratch yours... 
06:36:31 <fog> *facepalm* 
06:36:39 <maerwald> errr
06:37:14 <maerwald> those are odd fantasies about pair programming
06:37:36 <MarcelineVQ> my pair programmer is amazing, he can play the guitar
06:37:50 <MarcelineVQ> he may not be an actor, but he's a logic superstar
06:38:48 <MarcelineVQ> I think I might only speak in references, maybe I'd be good at HR
06:39:30 <merijn> Mine is mostly great at sleeping, cuddling and begging for food :p
06:39:39 <MarcelineVQ> I also wonder if I could change all my uses of , to ; without changing semantics.
06:40:35 <MarcelineVQ> the reference https://www.youtube.com/watch?v=r6-ZccfRrIo
06:41:03 <dminuoso> MarcelineVQ: dunno about worthless. you can still rubbercat with that one.
06:41:40 <MarcelineVQ> I'm of the radical opinion that you should avoid rubbercatting as much as possible. People tend to start rumors.
06:42:03 <AWizzArd> Via    pkgs.haskellPackages.callPackage ./project0.nix { }   this file is used/called: https://github.com/Gabriel439/haskell-nix/blob/master/project0/project0.nix   - is there a manual that lists and explains all the attributes that I can use in a nix derivation? Keys such as pname or executableHaskellDepends.
06:44:43 <dminuoso> AWizzArd: of course not.
06:44:51 <dminuoso> This is nix we're talking about.
06:45:28 <AWizzArd> dminuoso: :)
06:46:08 <NewToHaskell> Can someone explain why
06:46:11 <AWizzArd> So I can find them in some random projects and over the time learn and remember some of them.
06:46:17 <NewToHaskell> while if I had Int -> Int, it doesn't
06:46:39 <dminuoso> AWizzArd: You are expected to look at pkgs/development/haskell-modules/generic-builder.nix
06:46:57 <dminuoso> And figure out how this large 670 lines of undocumented nix expression works.
06:47:00 <dminuoso> And what its semantics are.
06:47:12 <MarcelineVQ> NewToHaskell: It sometimes seems like messages you've sent are missing lines
06:47:20 <dminuoso> Note that Im being quite serious here.
06:48:05 <AWizzArd> dminuoso: Okay, it's just right now not the optimal user experience. We might get there in the 20ies.
06:48:25 <MarcelineVQ> NewToHaskell: e.g.  https://gist.github.com/MarcelineVQ/988053e2458a509d15739477b1a572e3  was all that was seen on my end
06:48:31 <dminuoso> "not optimal" is quite a way of putting it.
06:48:38 <dminuoso> To me its an undocumented mess.
06:48:56 <AWizzArd> dminuoso: I'm using diplomatic wording here.
06:49:15 <dminuoso> Nix has great semantics and piss poor discoverability/documentation.
06:50:07 <AWizzArd> NewToHaskell: to me it seems you joined and seconds later the first thing you said: Can someone explain why.   Is there maybe something else missing that you wrote before?
06:50:31 <AWizzArd> dminuoso: I see. Fortunately I am only doing the simple stuff for now.
06:50:40 <NewToHaskell> https://pastebin.com/duQBV0A0
06:50:54 <NewToHaskell> AWizzArd here it is. =)
06:51:29 <dminuoso> AWizzArd: Thing get progressively worse. You'll keep hitting dead ends, with the solution being some mysterious undocumented and mostly unused primitive out of some random attribute set that looks quite internal.
06:51:37 <dminuoso> If you can deal with that, nix is good for you.
06:52:11 <dminuoso> Heck, even quite *simple* things are hidden from you. For instance, the semantics of overlapping nixos configurations, what primitives you can use to control this, ec.
06:53:09 <MarcelineVQ> NewToHaskell: it's best to include your error. in this case I'm guessing it's complaining about not having an Eq instance?  Pattern matching a literal like 1 is translated to a guard that's basically   sumSq' x | x == 1 = ...   in other words == is being used on 1, which is from the Eq typeclass
06:53:49 <MarcelineVQ> Int is an instnace of Eq and Num already so it's fine.  but you haven't constrained 'a' to be Eq as well as Num
06:54:37 <AWizzArd> dminuoso: Okay, good to know. So I'll be expecting some fun there.
06:57:00 <NewToHaskell> MarcelineVQ oh i see, thanks!
07:05:21 <dminuoso> AWizzArd: If you hang around nixos for a while, the you'll notice that the standard trick to "figure out what something does" is "grep for it in nixpkgs repo"
07:05:33 <dminuoso> Use the source, luke.
07:10:36 <__monty__> AWizzArd: If you're looking at nix to setup your dev environment, take a look at haskell.nix.
07:13:10 <AWizzArd> __monty__: is that better documented?
07:15:38 <oats> __monty__: your nick is giving me python ptsd lol
07:27:10 <vaibhavsagar> AWizzArd: is there a concrete issue you would like help with?
07:33:33 <vaibhavsagar> other than 'nixpkgs is badly documented', which is true
07:34:54 <Orbstheorem> Hi o/ Why would `DeriveAnyClass` be restricted in hlint by default?
07:35:26 * hackage haskoin-store-data 0.34.7 - Data for Haskoin Store  https://hackage.haskell.org/package/haskoin-store-data-0.34.7 (jprupp)
07:36:26 * hackage haskoin-store 0.34.7 - Storage and index for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-store-0.34.7 (jprupp)
07:42:53 <merijn> Orbstheorem: Because hlint is super opinionated and you should probably not value it's opinion too much as universal gospel
07:52:13 <frdg> why can I not say `x = "hello" :: Text` without getting an error for `Couldn't match expected type ‚ÄòText‚Äô with actual type ‚Äò[Char]‚Äô`
07:52:18 <AWizzArd> vaibhavsagar: no thank you. I was just wondering if those Nix-specific attributes are explained somewhere.
07:52:34 <[exa]> frdg: because you need the "hello" overloadable to Text
07:52:42 <AWizzArd> For example if pname can be anything, or if it has to match the .cabal file name.
07:52:51 <[exa]> frdg: -XOverloadedStrings
07:53:29 <frdg> [exa]: oh I need to set that in the repl as well as in the file?
07:54:00 <[exa]> well strings that come in repl get the flags from repl; the compiled module is different
07:54:19 <frdg> [exa]: got it thanks
07:55:53 <fog> so, instead of taking multiple arguments of different type, these can be uncurried into a HList
07:55:59 <vaibhavsagar> AWizzArd: IIRC weird things happen when the pname doesn't match the package name in the .cabal file
07:56:52 <fog> but, if these are just going to be bound to named references by pattern matching at the function definition on the left of the = sign, maybe instead of a HList this can be abstracted over to anything indexed by names
07:58:13 <fog> then, instead of a type list parameter which is ordered, giving the types of the input arguments to a function, a type level Map can be used to associate Symbols to types
07:58:47 <__monty__> AWizzArd: Not much better documented but a nicer API for sure.
07:59:25 <fog> which would allow that arguments of the corresponding types can be supplied in any order, not needing to be pattern matched over, having already been asigned variable names 
08:01:24 <fog> not sure if this requires or is an alternative to the constraints machinery that can be used to package these into a composite dictionary, which can be lookuped over by these names 
08:03:03 <fog> so that the graph of the function implementation that does not refer to variables in wider scope, would have both types and names on the edges between functions at the nodes
08:18:04 <sm[m]> fog: if you scour hackage you'll probably find a couple of packages implementing this sort of idea, but they tend not to get adopted
08:20:25 <sm[m]> people have a limited budget for non-mainstream idioms which add complexity
08:20:41 <maerwald> sm[m]: hi
08:39:26 <tabaqui1> ecosystem related question: do we have mainstream text encoding library?
08:39:57 <dminuoso> What should that library be capable of?
08:40:07 <tabaqui1> I managed to find just two libraries which were update during last 12 months
08:40:35 <tabaqui1> dminuoso: UTF8, cp-*, and a bunch of other code pages suport
08:40:53 <c_wraith> text-icu is probably the main one.
08:41:35 <dminuoso> Indeed, text-icu.
08:42:01 <tabaqui1> ok, thanks
08:42:05 <dminuoso> For that it doesnt even matter that it wasnt updated recently, since they are just native bindings to icu.
08:43:12 <dminuoso> tabaqui1: Just to be sure, what exactly does the library need to do? Conversion? Collation? Breaking?
08:43:20 <dminuoso> Or searching?
08:43:37 <tabaqui1> it is present at stackage, which is a good sign
08:45:06 <tabaqui1> dminuoso: not sure what do you mean. I want api similar to python "str.encode()", like "‚àÄ‚Üñ".encode('utf32') -> b"\0x..."
08:45:22 <dminuoso> So conversion then
08:46:04 <dminuoso> Just wondering because "encoding" library is non-specific. There's a bunch of goals you could have, text-icu covers most of them though.
08:46:27 <dminuoso> Including conversion (the fact that python calls it "encode" is so ridiculously misleading)
08:47:05 <dminuoso> (unless .encode can only accept UTF-*)
08:47:20 <tabaqui1> I never heard "collation" and "breaking" in such context
08:47:27 <tabaqui1> .encode in python accept python string
08:47:48 <tabaqui1> it's some internal python representation (unicode, actually)
08:48:34 <tabaqui1> I guess, it's similar to Haskell Char type
08:53:36 <tabaqui1> It works, nice:)
09:01:18 <frdg> are there any major advantages that I am missing out on in using trifecta for parsing over other libraries?
09:02:06 <c_wraith> trifecta's main goal is to provide better error messages on parse failure than other libraries.  I have no idea how well it does that.
09:02:06 <ddellacosta> tabaqui1: if you're using Text, maybe https://hackage.haskell.org/package/text-1.2.4.0/docs/Data-Text-Encoding.html would suffice?
09:02:13 <maerwald> is there a way to tell if a thread is blocked on an ffi call?
09:03:27 <frdg> c_wraith: it does it pretty well
09:03:45 <frdg> I just don't quite know what I am sacrificing for those messages
09:04:12 <c_wraith> probably performance.  Which *usually* is meaningless in a parser, until you're in a use case where it's everything.
09:04:12 <tabaqui1> ddellacosta: nah, only UTF-* and Latin encodings
09:04:40 <dminuoso> frdg: One trick with trifecta is to implement a parser in say megaparsec *and* trifecta. If the megaparsec fails, you re-parse with trifecta for the diagnostic.
09:04:54 <dminuoso> (That way you get good performance on the happy path, and good diagnostics)
09:05:24 <frdg> ok that is good advice
09:05:30 <maerwald> merijn: the problem is actually just that the consuming thread is too slow to consume and between the subprocess exiting and the pipe being truly "depleted" there is a small window
09:05:42 <c_wraith> like, I've written code that's parsed stuff thousands of times, and I've cared about performance once.
09:06:38 <c_wraith> Usually parsing just isn't on the critical path.
09:07:50 <dminuoso> Well, if you're writing a compiler the parser performance could be important.
09:09:32 <solonarv> sure; how often do you write compilers?
09:09:43 <c_wraith> Sure, there are times it can come up.  It's just uncommon across the broader field of software development.  But there are some specialties where parser performance is important every time.
09:16:12 <dolio> Good diagnostics are *more* important in a compiler, though, if it's compiling stuff that a human works on.
09:23:07 <sm[m]> megaparsec can also give pretty good errors, no ?
09:23:50 <AWizzArd> Running `cabal update` and get:   Unexpected response 416 for http://objects-us-east-1.dream.io/hackage-mirror/01-index.tar.gz
09:23:54 <AWizzArd> Is it just me or everyone else?
09:45:31 <glguy> AWizzArd: That's perhaps resolved? It worked for me just now, at least.
09:46:50 <AWizzArd> Will retry.
09:47:28 <AWizzArd> glguy: okay, still doesn‚Äôt work. This will be some proxy settings then. Thx!
10:32:26 * hackage aura 3.1.5 - A secure package manager for Arch Linux and the AUR.  https://hackage.haskell.org/package/aura-3.1.5 (fosskers)
10:51:07 <kuribas> Great, servant doesn't export the Link type, so I cannot create one myself...
10:57:29 <kuribas> at least they could have made an internal module
11:03:04 <kuribas> hmm, I can probably use the QueryParams implementation...
11:27:38 <Uniaika> kuribas: you can always ask for that, you know?
11:27:56 <kuribas> Uniaika: yeah, but I found a way around
11:29:14 <kuribas> Uniaika: if I can avoid having to patch a library, or wait for bleeding edge, it's a good thing
11:39:26 * hackage ucd 0.0.1.4 - Unicode Character Database ‚Äî Predicates on characters specified by Unicode  https://hackage.haskell.org/package/ucd-0.0.1.4 (MatthewFarkasDyck)
12:11:27 <ap_> hi
12:12:23 <koz_> ap_: Sup?
12:12:43 <ap_> wondering what to do
12:12:49 <ap_> kinda bored
12:13:06 <koz_> ap_: I dunno lol. Depends on what you find fun.
12:13:09 <dsal> combine some applicatives
12:13:19 <ap_> have been watching some anime but taking a break
12:13:21 <hc> bind some combinators
12:13:25 <ap_> also played some video games today
12:13:35 <hc> any ones written in haskell
12:13:39 <ap_> was trying to solve project euler #518
12:13:40 <hc> ?
12:13:52 <ap_> but i am stuck so taking a break
12:14:04 <dsal> I got bored with Project Euler.  Seemed to be more math than programming.
12:14:11 <ap_> was looking into defining recursive types for mypy in python as json
12:14:25 <ap_> the pull request has been open since years
12:14:29 <ap_> no one wants to work on that
12:15:33 <ap_> and i sometimes get lonely without a s.o. ever
12:16:57 <ap_> hmm
12:19:26 * hackage vty 5.30 - A simple terminal UI library  https://hackage.haskell.org/package/vty-5.30 (JonathanDaugherty)
12:23:03 <ap_> what do you guys use haskell for, at job or just for fun?
12:24:27 <dsal> Whenever I need a computer to do a thing.
12:24:44 <ap_> sounds condenscending
12:25:02 <ja> ap_: i mainly dream about writing haskell, but it is very satisfying :P
12:25:28 <glguy> ap_: it's a general purpose programming language. People use it to write arbitrary programs; it doesn't have a specific application.
12:25:52 <ap_> yes i know that if that wasn't clear
12:26:09 <ap_> i was more interested in asking where do **you** guys use it
12:26:37 <ja> ap_: i am rewriting utreexo in haskell, i think it could be very elegant
12:26:49 <ap_> obviously it doesn't have such mainstream embrace
12:27:11 <ja> ap_: many business are focused on launching a product as quickly as possible
12:27:27 <ja> ap_: haskell gives you a lot of freedom to do things in a billion different ways, kinda like perl ;O hahaha
12:27:29 <ap_> even my manager wasnt us to use python instead of java
12:27:34 <ap_> he likes dynamic & duck typing
12:27:46 <glguy> ap_: I use Haskell to talk to you on IRC
12:28:15 <ap_> is there an irc client in haskell then..
12:28:35 <ja> ap_: yeah, because many bad managers don't know enough about how important code quality can be, so they see it working once, it that is deemed good enough
12:28:49 <glguy> ap_: Yeah
12:28:50 <ja> ap_: i believe glguy wrote his own, glirc?
12:29:08 <ap_> one of my mentors removed .gitlab_ci.yaml because he couldn;t fix flake8/mypy/pylint
12:29:20 <ap_> i asked him and he said there is no such business requirement
12:29:28 <ap_> sounds great glguy
12:29:40 <ap_> can i talk 1-1 using irc?
12:29:40 <glguy> ap_: I use hledger (written in Haskell) to manage the finances of a community organization I'm involved in
12:29:58 <ja> ap_: yes "/msg <username> hi"
12:30:18 <ap_> i would like to know more about utreexo so ...
12:31:56 <dsal> ap_: http://dustin.sallings.org/2020/04/29/gopro-plus.html <-- I manage my GoPro media in haskell.
12:32:01 <dsal> And most of my IoT things.
12:32:50 <koz_> I work on (several) Haskell codebases at my Real Job For Real Money.
12:32:57 <ap_> sounds amazing
12:33:06 <koz_> Not gonna lie, it is.
12:33:06 <ap_> i wonder if i could ever get a chance to do so
12:33:17 <koz_> ap_: It's totally doable.
12:33:19 <ap_> all i am doing these days is making apis
12:33:27 <ap_> and now it's all covid
12:33:32 <dsal> I process a lot of data in haskell at work.  It's a complicated process, but I don't know that it's super interesting.
12:33:47 <ja> ap_: this is another project i wanna get into, maybe you'd like it if you like graphics: https://gitlab.com/sheaf/fir/-/blob/master/getting_started.md#inlining
12:33:50 <dsal> Oh, I monitor/control my car with Haskell.
12:33:59 <koz_> Interesting is something that happens at Real Job.
12:34:16 <koz_> I got to search for inefficiencies in the guts of beam-core about a month ago?
12:35:06 <ap_> but usually the design is taken care of architects ?
12:35:29 <koz_> ap_: We're building plenty of new stuff?
12:35:44 <ap_> *of by
12:35:51 <dsal> Is "architects" still a thing?
12:36:03 <koz_> dsal: Maybe in some places?
12:36:05 <ap_> and the choice of language and stuff is usually dictated by managers isn't it
12:36:19 <koz_> ap_: Yeah, but that's in the job application.
12:36:21 <ap_> so how do you guys get to decide on it
12:36:30 <earthy> architecture at least is still a thing
12:36:31 <ja> dsal: what, how do you control your car with haskell? 
12:36:33 <koz_> ap_: I applied for a job which asked for Haskellers.
12:36:41 <dsal> Heh, people who decide what tools to use vs. people who use the tools?
12:37:06 * cjay can sadly confirm, architects are still a thing
12:37:10 <dsal> ja: http://hackage.haskell.org/package/tesla  https://github.com/dustin/tesladb -- I have an mqtt interface to various controls.
12:37:18 <earthy> dsal: that also
12:37:30 <ja> ooh, i was thinking like peaugeot 203 or something , since people told me it is easy to reverse-engineer
12:37:32 <ap_> which continent are you guys from?
12:37:44 <ja> ap_: america
12:37:46 <hololeap> i notice that there is an isomorphism between `(a -> c) -> (b -> c) -> r` and `(Either a b -> c) -> r`
12:37:47 <earthy> .eu
12:37:55 <hololeap> how can this be explained from a CT perspective?
12:38:02 <earthy> but managers don't architect and architects don't manage, in general
12:38:11 <ja> ap_: i used to be from eurasia
12:38:20 <ap_> great
12:38:32 <ap_> i am from a small place in asia
12:38:48 <ap_> i tried applying to some good colleges in usa for masters but got rejected from all
12:38:49 <ja> aah, i think i know that place! singapore?
12:38:59 <ap_> will try again for fall 2021
12:39:06 <ap_> no it's in india
12:39:24 <earthy> I could theoretically go start using haskell at the day job. that'd make it Entirely My Problem. which could be fun but is probably more like pain.
12:40:00 <ja> ap_: there is a indian channel on the zurihac (haskell conference) discord
12:40:02 <ap_> it would be difficult if your coworkers dont know haskell
12:40:51 <hc> earthy: i did just that in the past -- start a new project in haskell. eventually got a 2nd haskell developer into the company :)
12:41:12 <ja> hc: but were you the boss of the company to begin with?
12:41:22 <hc> far from it :)
12:41:27 <earthy> we have multiple people that know haskell well enough to teach it to others internally
12:41:32 <hc> I was probably the lowest ranking employee of that company
12:41:41 <ap_> then you were lucky to find him
12:41:46 <earthy> but we also have huge legacy code bases. ;)
12:41:57 <ja> ap_: there is a telegram channel for indian haskellers too: https://t.me/haskellindia
12:42:27 <chewb> why would i want to learn haskell?
12:42:41 <ja> earthy: you make legacy sound like adventure lol :D
12:42:53 <earthy> well... yes! :)
12:42:53 <ja> chewb: to feel superior to your peers
12:43:04 <ja> like everything you do in life ;P
12:43:17 <ap_> i had to deal with rewriting perl code from 1990s it was a total mess
12:43:22 <chewb> i dont feel superior to my peers,  i am unemployed
12:43:34 <ap_> it had even more problems than you could make at a theoretical level
12:43:42 <ja> chewb: yeah, that's why you need to find a niche and dominate it then! :P
12:44:02 <ap_> @chewb in my case it was based on pure interest to learn something new
12:44:02 <lambdabot>  <unknown>.hs:1:1:Parse error: in
12:44:41 <chewb> yes, something new, haskell seems to be different than any other langauge
12:44:50 <earthy> na
12:44:52 <chewb> is whitespace signifiant in haskell?
12:44:55 <ja> chewb: do side-effects not annoy you? haskell is one of the only languages where purity is in the type system
12:45:04 <ja> chewb: yes
12:45:48 <chewb> that bother me a bit
12:46:00 <hololeap> ha
12:46:06 <ja> now, foster that anger, make it bother you a lot
12:46:13 <ja> then you can motivate yourself to do haskell
12:47:27 <chewb> i meant whitespace significant
12:47:40 <chewb> ja, do you know a lot about machine learning?
12:48:06 <ja> chewb: no, i don't know much about it except what a support vector machine is and stuff like that. introductionary stuff from university
12:48:24 <ap_> how do you guys disconnect from irc for a while?
12:48:43 <ja> ap_: i have my friend run a server, i log in to that server and have irssi running in dtach
12:48:49 <chewb> ja are you able to implement LSTM from scratch?
12:49:03 <ja> ap_: i use mosh to connect to the server, so it reconnects when i open my laptop. 
12:49:37 <ja> chewb: if i wanted to, i think so? isn't it one of the more foundational things? there should be a bunch of literature
12:50:00 <hololeap> chewb: it's a general-purpose language. you are able to do anything that can be done in other languages.
12:50:12 <ja> chewb: sometimes a person called 'fog' comes here, i think he likes machine learning
12:50:22 <ja> s/he/they/
12:50:44 <hololeap> more like getting lost in the deep end...
12:50:58 <merijn> chewb: You can write Haskell with curly braces and semicolons if you prefer
12:51:18 <ja> yeah, i had fog on ignore for a couple of months, then i forget why, then i ignored, and now i am thinking about whether to ignore again :P
12:51:22 <merijn> chewb: Although, a solid 98% of the ecosystem does not use braces and semicolons, because they suck and that's dumb
12:51:43 <merijn> chewb: But that means you have no exucse ;)
12:51:55 * chewb is now playing: Deepchord Presents Echospace - In Echospace
12:52:41 <chewb> how is haskell better than common lisp or C++?
12:52:53 <ja> chewb: common lisp is not statically typed, i believe?
12:52:53 <chewb> isnt haskell slower than even python?
12:52:59 <merijn> What? No
12:53:09 <hololeap> chewb: if you haven't used a language like haskell before, it's difficult to explain what exactly makes it elegant. it "forces" you to change the way you think about problems.
12:53:11 <ja> chewb: python is interpreted, it will usually not run CPU bound stuff very fast
12:53:12 <merijn> Haskell is normally easily like 10x faster than python
12:53:30 <monochrom> Is that trolling?
12:53:44 <hololeap> and that change is for the better IMO. the adage that haskell makes you a better programmer is essentially true.
12:54:01 <ja> monochrom: it's hard to say, better assume good faith to avoid becoming bitter :O
12:54:08 <monochrom> "why should I learn haskell?"  the answer is, if you have to ask, the answer is "no, go away"
12:54:31 <monochrom> Adults don't need other people to tell them what's best to do.
12:54:45 <maerwald> but it's so convenient
12:54:48 <maerwald> and I can blame you
12:55:16 <hololeap> well, considering the time that needs to be invested in learning it, it might be helpful to have some inspiration
12:56:02 <monochrom> There is a difference between "why should I?" and "what are some benefits?"
12:56:23 <monochrom> Antipodal in attitudes behinds.
12:58:02 <monochrom> You can also see that the subsequent string of questions is on the confrontational side, not the curious side.
12:58:35 <hololeap> eh, i don't see it as trolling, but who knows
12:58:45 <monochrom> When mature adults use "why should I?" it's rhetorical not really asking.
12:59:15 <ja> monochrom: there are many dialects of english, i think that distinction is too small to be universal
12:59:35 <chewb> what to use for haskell programming? is visual studio code with some extension fine?
13:01:48 <hololeap> chewb: you'll probably need to start with the basics. a lot of concepts from other languages aren't easily "imported" to haskell. as far as IDEs go, i don't use one...
13:03:17 <merijn> ja: On the one hand I agree with you, on the other hand I have also seen a bazillion people coming here and *demand* we convince them to learn Haskell over the years as, I assume, has monochrom 
13:03:40 <merijn> ja: And at some point you have to draw a line on how much of the discussion here should be indulging that line of questioning
13:04:40 <ja> i wouldn't mind it it was forbidden! but why not make it explicit? is there already a quote in lambdabot that says "tools only exist to solve a problem. if you don't have a concrete problem to solve, why does pondering bring you? there is no 'best programming language'" ??
13:06:32 <ChaiTRex> The best programming language is machine code, which is why most compilers turn your lesser programming languages into it.
13:06:48 <hololeap> monochrom: "Adults don't need other people to tell them what's best to do." ... if only more people thought that way :(
13:06:58 <chewb> if i go get masters degree entrance exam may have haskell questions that what i hearcd
13:07:15 <monochrom> Well, they do think that way whenever you tell them, unsolicited, what to do.
13:07:53 <ja> every time i see "why should i learn Haskell" i am thinking of some 14 year old teenager that googled "best programming language" ... so what options are there? if there is a disproportionate amount of 14 year olds that think that there must be a "best" of everything , wouldn't it be sad if the channel had to alienate all those?
13:08:14 <chewb> is haskell similiar to javascript? javascript is functional too, right?
13:08:30 <hololeap> chewb: not even in the same universe as javascript :p
13:08:30 <dsal> javascript is dysfunctional
13:08:47 <Cheery> javascript is an interpreter for haskell
13:09:01 <koala_man> my default response to "what's the best linux distro?" is "if you have to ask, it's ubuntu"
13:09:10 <dsal> nixos by huge bounds
13:09:18 <maerwald> dsal: lol
13:09:27 <Cheery> it's shifting to be nixos
13:09:57 <ja> lol, this is the core issue! do you wanna give people an answer reflecting what you actually believe, or what you think they can realistically work with?
13:10:19 <hololeap> it depends on the question
13:10:23 <chewb> Cheery is it difficult to write haskell interpreter in javascript or llvmlite?
13:10:36 <dsal> I've run ubuntu for years.  I can't figure out how to work it reliably.  nixos has been far easier for me.
13:10:43 <Cheery> chewb: no, I mean that javascript is an interpreter meant to run haskell.
13:10:51 <Cheery> model of such
13:11:01 <dsal> You can compile haskell to javascript.
13:11:15 <chewb> haskell is close approximation of turing machine? thats what your mean?
13:11:30 <dsal> chewb: You should do a bit of an intro to haskell to get some idea of what you're talking about.
13:11:37 <monochrom> ja: OK, but you can use their follow-up questions to update your estimate of, e.g., how sincere they are, how much they worth your time.
13:11:43 <ChaiTRex> chewb: It's Turing complete, but it's not like a Turing machine.
13:11:44 <dsal> I used to write random letters on a thing and asked my mom what they spelled.
13:12:04 <Cheery> chewb: it's approximation of lambda calculus, but it's quite manspreading -thing if we go there.
13:12:15 <dsal> It was only years later that I figured out I was a genius and my mom couldn't read.
13:12:16 <hololeap> wait, is a turing machine that thing from Back to the Future?
13:12:38 <koala_man> dsal: yep. if you're not the kind of user who asks for "the best distro", then the answer is different
13:13:19 <monochrom> Also, "what you think they can realistically work with" is a full-time counselling job. For free advice, it's going to be personal preference.
13:13:54 <merijn> My programming coaching starts at $150 an hour, unless I like you
13:14:04 <Cheery> chewb: you can play there: https://repl.it/languages/haskell
13:14:07 <merijn> Spoiler: I don't like you, because I hate people :p
13:14:12 <monochrom> This is why "what should I do?" is unanswerable for free, even when the asker means it.
13:14:21 <maerwald> merijn: only cats?
13:14:28 <chewb> do i need to know category theory to learn haskell?
13:14:49 <hololeap> chewb: no, but it can help
13:14:56 <merijn> maerwald: I like most cats and dogs, but they don't ask stuff on the internet
13:15:07 <hololeap> but it isn't anywhere close to being a requirement
13:15:08 <merijn> maerwald: Which, honestly, might be related to me liking them
13:15:17 <Cheery> chewb: yup. Category is an abstract algebra and theory around it, representing function-like things.
13:15:26 <Cheery> category theory*
13:15:45 <merijn> In fact, I will go as far as stating that I like most non-human mammals that are not actively dangerous to me
13:15:53 <hololeap> i dipped my toes into CT _because_ of haskell
13:15:57 <chewb> ive read first few chapters of lang algebra i think
13:15:58 <dsal> merijn: can I get a negative discount for being extra unpleasant?
13:16:17 <merijn> dsal: Sure, there's no upperbound
13:16:33 <dsal> chewb: you need to try to learn haskell to learn haskell.  Learning about learning haskell won't get you very far.  :)
13:16:34 <hololeap> dsal: if you make them hate you enough, it will wrap around to the other side of the spectrum
13:16:45 <merijn> (Well, I guess, realistically there *is* an upperbound, which is "numbers my bank can handle"
13:16:48 <merijn> )
13:16:56 <dsal> hololeap: Yay two's complement!
13:17:38 <ja> would be 'fun' to have new users sent to either #haskell-intro-category-theory or #haskell-intro-lambda-calculus with gpt-2 talking to them. then you could measure engagement and derive the optimal haskell introduction ;)
13:18:05 <hololeap> lol
13:18:29 <chewb> are you folks employed haskell programmers? or are paid for writing different languages?
13:18:35 <dsal> CT always seemed somewhere between dumb/obvious and useless before writing enough haskell code to be able to see abstractions.
13:18:37 <monochrom> No, I think our past data already suffice. Just grep for "Cale" in the past 2 decades logs.
13:19:05 <Cheery> chewb: I'm a failing entrepreneur or something like that.
13:19:14 <hololeap> ^^^
13:19:22 <chewb> is haskell suitable for writing trading software?
13:19:32 <Cheery> sure
13:19:32 <dsal> chewb: If you're looking for a quick intro to a high paying job, talking about haskell won't get you there.  If you want to be a good programmer, learn haskell.
13:19:34 <chewb> is it suitable to writing networking tools?
13:19:44 <mniip> how do I tell stack to do what I want :(
13:19:45 <dsal> chewb: before you ask your next question:  "yes"
13:19:58 <Cheery> chewb: absolutely yes.
13:20:13 <chewb> Cheery what kind of software do you write?
13:20:24 <hololeap> chewb: it isn't suitable for writing tools on very limited hardware, like routers, or for real-time programming
13:20:30 <Cheery> compilers  and whatever I like.
13:20:32 <hololeap> because it has a garbage-collector
13:20:40 <dsal> hololeap: good thing time is an illusion
13:20:43 <Cheery> sometimes parsers as well.
13:20:49 <mniip> hololeap, chewb it is however suitable for writing tools that generate software for such platforms
13:21:15 <chewb> Cheery are you familiar with metatrader software? would you able to write compiler for mql like language?
13:21:28 <dsal> no / yes
13:21:30 <mniip> anyway
13:21:41 <chewb> is writing compilers in haskell simpler than writing compilers in python+llvmlite?
13:21:44 <merijn> Anyway, time to do something useful with my time :p
13:21:51 <ja> monochrom: the data is suffient for? training gpt-2? or deciding the optimal introduction?
13:22:12 <mniip> when I say "stack install --resolver <resolver> <package>" where does that go
13:22:15 <monochrom> I think the data is already the optimal introduction. :)
13:22:28 <dmj`> chewb: yea
13:22:29 <hololeap> chewb: "would you be able to write a compiler for X in haskell?": yes it excels at writing compilers for other languages
13:22:47 <chewb> i thought lisp is best for writing DSL
13:23:03 <hololeap> again with the "best" nonsense...
13:23:18 <Cheery> chewb: depends on the lisp in question.
13:23:52 <chewb> is haskell simpler than common lisp? CL is pretty huge
13:24:10 <hololeap> hard no from me, dog
13:24:16 <ja> anyway, for due credit, the gpt-2 idea is not mine, it is from gmaxwell in ##taproot-activation yesterday trying to predict bitcoin proposal opposition: https://0bin.net/paste/MMZZH2HDfPMKVF3P#E5BUUOVAiA1oAEecyrdlnPCVX3o7dzLMUzqAbJPsH91
13:24:26 * hackage named-servant 0.0.1 -   https://hackage.haskell.org/package/named-servant-0.0.1 (KristofBastiaensen)
13:24:48 <dsal> haskell is the easiest language I program in regularly.
13:25:20 <dsal> Part of the reason I find metaquestions a bit frustrating.  You'll never understand the experience of something by having someone tell you about it.  You have to do it.  It's easy.
13:25:36 <monochrom> The joke must be on Searle that we now use gpt-2 and gpt-3 (what Searle would call $lang rooms) for actual decisions.
13:26:35 <chewb> i want to implement LSTM in some programming language to understand how it works
13:26:40 <monochrom> or at least actual advices
13:26:51 <MarcelineVQ> I saw a concerningly useful application of gpt-3 just recently https://twitter.com/sharifshameem/status/1282676454690451457
13:27:25 <polyphem> Hi , i am newtype wrapping the ST Monad  and i get this error. How to procced ? Can somone please hint me ? https://gist.github.com/polyrod/f143515178b1b02526ec00d571c99465
13:28:25 * hackage named-servant-client 0.0.1 - client support for named-servant  https://hackage.haskell.org/package/named-servant-client-0.0.1 (KristofBastiaensen)
13:28:46 <Cheery> chewb: what kind of understanding you're looking for about it?
13:29:03 <Cale> monochrom: lol, I wonder what happens if you GPT3 some Haskell question like <someone> ...?  <Cale> 
13:29:15 <Cale> Automated answers
13:29:26 * hackage named-servant-server 0.0.1 - server support for named-servant  https://hackage.haskell.org/package/named-servant-server-0.0.1 (KristofBastiaensen)
13:29:28 <kuribas> chewb: common lisp is pretty small compared to modern languages
13:29:32 <hololeap> polyphem: the `s` type variable is existentially quantified, meaning you can't allow it to escape its context. you'll have to use something like `forall s. ReaderT () (ST s) a`
13:29:51 <kuribas> chewb: and to haskell as well
13:29:51 <BosonCollider> Question: is there a good pattern to follow when constructing adjacency list graphs in a pure functional language? Iteratively when you add a vertex, you pass the adjacent vertices to the constructor and add the new vertex to the adjacency list of all adjacent vertices
13:30:05 <chewb> kuribas is common lisp smaller than python?
13:30:15 <kuribas> chewb: I would say so
13:30:19 <BosonCollider> but functionally I'm not sure how to proceed, maybe using lenses?
13:30:23 <kuribas> just look at the python standard library
13:30:57 <chewb> i am not sure, there are lot of CL functions that are doing similiar things
13:31:04 <chewb> princ print prin1 prin2
13:31:26 <hololeap> polyphem: actually, i could be wrong here
13:31:42 <ja> Cale: would probably not be too dissimilar to these fake irc logs: https://0bin.net/paste/e0ZE4IrWjxGHkFtv#4LCaBJP93pEUh3va-rGgcjm54THuCct0gwHg/E6/zFR
13:31:57 <kuribas> chewb: it doesn't even have a proper string library
13:32:17 <hololeap> polyphem: what are you doing with this `ReaderT ()` thing?
13:32:51 <hololeap> ReaderT () m a ‚âÖ m a
13:33:17 <kuribas> chewb: however a lot of standard haskell functionality is actually in libraries.  Like containers, mtl, transformers, text, bytestring, ...
13:33:45 <kuribas> chewb: you could call them part of the language, even if technically they aren't.
13:34:25 <chewb> would you recommend haskell for webdev? someone said to me yesod is comfy, you can make applications very qiockly in it
13:34:30 <monochrom> hololeap, polyphem: I wonder if the "let" killed the forall s, unless you add a forall type sig
13:34:40 <kuribas> chewb: definitely
13:34:53 <kuribas> chewb: haskell is great for the web
13:35:06 <sm[m]> mniip: tools and libraries go somewhere under ~/.stack, executables go in ~/.local/bin
13:35:16 <hololeap> monochrom: i'm curious as to what the point of the newtype is when its wrapping around `ReaderT () (ST s) a`
13:35:36 <monochrom> I'm also pretty sure that () is placeholder for focusing on this issue, it will be an interesting type later.
13:35:48 <hololeap> oh, ok
13:35:48 <chewb> haskell is backend language then right? how does it communicate with javascript/ajax?
13:35:50 <mniip> why is stack asking me to specify a version of text?
13:36:02 <mniip> is that not part of specifying the resolver?
13:36:24 <mniip> why does stack build a new text when I tell it the exact version it has installed
13:36:49 <sm[m]> what‚Äôs the command and output and stack version ?
13:36:51 <monochrom> Are you being paid to use stack? :)
13:36:59 <MarcelineVQ> mniip: did you tell it the exact version with the sha or w/e to also affix the revision version?
13:36:59 <polyphem> by s escaping the context , do you mean s apearing on the left side of the data declaration ?
13:37:21 <MarcelineVQ> idk how to do that specifically, just wondering if that's why it's building its own
13:37:33 <Cheery> chewb: You can use Purescript to generate javascript from Haskell code.
13:37:49 <sm[m]> Build flags, optimization level, profiling, old stack version could be reasons for rebuilding
13:37:56 <Cheery> chewb: Glasgow haskell compiler can be used on the backend.
13:38:09 <mniip> MarcelineVQ, yup it still builds it
13:38:14 <polyphem> i removed all s type vars from the types and the signatures and inserted forall s. , still has this s \~ s0 thingie
13:38:15 <MarcelineVQ> mniip: I just recall extra-deps adding extra info when it stack adds them to choose a specific cabal file revision
13:38:34 <Cheery> chewb: the whole language overall, with variations can be compiled into about anything.
13:39:17 <Cheery> None of the libraries have been designed this way, but it's kind of still a thing.
13:40:30 <mniip> sm[m], stack is 2.1.1
13:41:13 <sm[m]> mniip I would definitely use the latest, via  ‚Äústack upgrade‚Äù or whatever
13:42:13 <mniip> I'm trying to build a package inside a docker container, and the container doesn't have network
13:43:01 <sm[m]> ok, well without knowing anything else that could be a factor, unnecessary rebuilding was improved at some point
13:43:56 * hackage extra 1.7.4 - Extra functions I use.  https://hackage.haskell.org/package/extra-1.7.4 (NeilMitchell)
13:45:29 <mniip> I have no idea what version is being used in the container
13:45:41 <mniip> but it's trying to rebuild too
13:47:04 <mniip> ...
13:47:17 <mniip> this only happens if I have multiple packages in my stack.yaml file
13:47:24 <mniip> what?
13:49:37 <sm[m]> if you really want help, show your file, command, output, stack version being actually used, etc..
13:50:26 * hackage dobutokO-effects 0.10.0.0 - A library to deal with SoX effects and possibilities  https://hackage.haskell.org/package/dobutokO-effects-0.10.0.0 (OleksandrZhabenko)
13:52:24 <maerwald> sm[m]: hi
13:53:00 * sm[m] hears nothing
13:53:29 <sm[m]> oh hello maerwald I didn‚Äôt see you there
13:54:45 <maerwald> I'm just across the street
13:55:03 <sm[m]> yes let me test your latest random mac binary on my machine :)
13:55:40 <maerwald> oh, we did that already
13:55:50 <maerwald> I got root access
13:57:13 <mniip> so there's a docker image with this https://github.com/icfpcontest2020/dockerfiles/blob/master/dockerfiles/haskell/Dockerfile.base
13:57:39 <mniip> and, my program depends on binary, so I made a local clone of the library
13:57:46 <mniip> and my stack.yaml is:  {resolver: lts-16.3, packages: [., binary]}
13:59:04 <sm[m]> mniip: text depends on binary, so it'll have to be rebuilt using your custom binary package
13:59:13 <mniip> wait what
13:59:40 <sm[m]> did you mean to list binary as a local package ?
14:00:24 <mniip> sorry what's a "local" package
14:00:42 <sm[m]> anything you put in the package: list in stack.yaml
14:00:50 <sm[m]> binary is not normally something you would put there
14:00:57 * hackage dobutokO-effects 0.10.1.0 - A library to deal with SoX effects and possibilities  https://hackage.haskell.org/package/dobutokO-effects-0.10.1.0 (OleksandrZhabenko)
14:01:09 <sm[m]> unless you're using a custom version of it
14:01:54 <mniip> I thought binary was an "independent enough" package that I'd need to bundle my own
14:02:33 <sm[m]> I would just try removing it and see what happens
14:03:43 <sm[m]> it's a common library, and in stackage; let stack use that one, then it won't have to rebuild text so much
14:03:56 <mniip> right
14:04:12 <mniip> the problem is that the fact that it's in stackage is not enough
14:04:15 <MarcelineVQ> if you do need a custom local 'binary' then I'd be putting the path to it in extra-deps instead of packages
14:04:24 <mniip> if it's not pulled in by that dockerfile.base, then I have to include it manually
14:04:56 <MarcelineVQ> *local 'binary' dependency
14:05:33 <sm[m]> mniip: I'm not too docker-aware.. how does text get built then ? 
14:06:31 <mniip> I know even less about docker than about stack
14:06:39 <sm[m]> great :)
14:07:05 <sm[m]> your docker image has all of the packages that get installed by the Dockerfile.base RUN command, I would guess ? That includes text and should include binary. What made you need to add it to packages exactly ?
14:08:23 <mniip> sm[m], because that's the only way I know of bundling an entire package inside your repository
14:08:55 <sm[m]> mniip: but what makes you feel that's necessary ? what goes wrong when you remove binary from packages: ?
14:09:34 <mniip> well, now - nothing
14:10:17 <sm[m]> you don't need it there, I'm sure
14:10:48 <mniip> I hate everything ops
14:10:53 <mniip> why I can't we just write code
14:13:13 <Cale> mniip: I guess that's the idea behind nix
14:13:22 <Cale> mniip: But nix is... well... nix
14:13:24 <mniip> but nix is *worse*
14:14:21 <hololeap> polyphem: i don't see a good way to do this. you could make an existential wrapper `newtype SomeST a = SomeST (forall s. ST s a)` but then you cannot get any Functor/Applicative/Monad instances for it AFAIK
14:14:42 <Cale> If only people used good functional programming practice with nix rather than doing this ridiculous "let's pass the entire universe as an argument to every function and take giant fixed points" thing, I think it could be a whole lot saner.
14:15:55 <sm[m]> nix's successor will be good!
14:15:57 * hackage servant-seo 0.1.2 - Generate Robots.txt and Sitemap.xml specification for your servant API.  https://hackage.haskell.org/package/servant-seo-0.1.2 (swamp_agr)
14:23:23 <hyiltiz> `[(1,2),(3,4)] ^. _2 . _1` why doesn't this work, aka how to get out the 3? Also, how to get [1,3] out using lens?
14:23:24 <infinisil> Cale: Are you talking about the pkgs fixed-point in nixpkgs?
14:23:24 <polyphem> hololeap: yea i reduced the example but either it dosnt compile with the runCyber func or it doesnt compile with the newKey func . I was inspired by this blog post from 2012 https://jaspervdj.be/posts/2012-04-12-st-io-dcpu-16.html . However the author doesnt even give an implementation for his run* function :(
14:23:59 <Cale> infinisil: Yeah
14:24:19 <polyphem> hololeap: Thanks however 
14:24:42 <infinisil> Cale: I'm not sure that's avoidable
14:24:50 <Cale> infinisil: and how there are all these places where we'll modify the stuff in the attrset generated by that fixed point and take another fixed point, and it just becomes really really hard to figure out the definition of anything
14:25:05 <Cale> Of course it's avoidable, by making all the dependencies explicit
14:25:18 <Cale> You would have to pass things the arguments they actually depend on
14:25:48 <Cale> and treat the whole thing as you would most other programs
14:26:05 <ja> hyiltiz: the optics books has examples for this
14:26:05 <infinisil> Cale: Do you have a prototype of how that would look?
14:26:22 <Cale> Imagine if a Haskell program did anything like this -- defining a gigantic record type containing all its definitions, and then passing an instance of that around everywhere
14:26:23 <ja> hyiltiz: you can use partsOf 
14:26:37 <hyiltiz> yes, but didnt want to just copy paste; I fooled around for half an hour without going anywhere :(
14:26:43 <Cale> I think anyone would be reasonably pissed off about that
14:26:52 <hololeap> polyphem: i would say keep the use of ST isolated and don't try to wrap any transformers around it
14:27:09 <ja> hyiltiz: actually i don't think you need partsOf
14:27:12 <hololeap> that `forall s.` in runST is hard to get around
14:27:19 <Cale> infinisil: The downside is that the code would have to contain an explicit topological sorting of the packages
14:27:22 <ja> hyiltiz: did you try using "traversed"?
14:27:26 <Cale> Well, kind of.
14:27:33 <infinisil> Cale: Yeah something like that
14:27:44 <infinisil> I can imagine this being awfully complex to do
14:28:02 <Cale> At least, you'd have a bunch of places where things got defined in terms of other things
14:28:13 <Cale> But those definitions are important!
14:28:32 <polyphem> i removed all transformers, still . it has to do , i think with the "STRef s" and the "ST s" ref beeing wrapped in two different newtypes , and runST cannot assert s0 ~ s
14:28:55 <Cale> The main advantage of functional programming is being able to reason about the meaning of the code equationally and locally
14:28:56 <hololeap> polyphem: or you could use stToIO which locks down the `s` to RealWorld
14:29:20 <Cale> You can't reason equationally if you can't actually find the definitions of things any more
14:29:44 <Cale> Or if they're spread out implicitly over dozens of files as overlays tweak little things
14:30:04 <Cale> and you have no tool better than grep for locating any of it
14:30:09 <hyiltiz>  [(1,2),(3,4)] ^. partsOf (traversed . _1) gives [1,3] :D
14:30:27 <hololeap> polyphem: again, keep your use of ST isolated to a function, don't make a newtype wrapper around it
14:30:37 <ja> hyiltiz: too complicated
14:30:40 <ja> > [(1,2),(3,4)] & traversed %~ fst
14:30:42 <lambdabot>  [1,3]
14:30:49 <infinisil> Cale: Hm but let's think of it this way: Nix doesn't have a concept of modules like Haskell. In Haskell you can import any module from any other module (without cycles), which actually is like a transparent giant global fixed-point. In Nix this needs to be explicit because it doesn't have modules
14:31:00 <Cale> Yeah, I think that's a big part of the problem
14:31:11 <xerox_> > fst <$> [(1,2),(3,4)]
14:31:13 <lambdabot>  [1,3]
14:31:25 <Cale> An explicit module system which was tied to the file system in some fashion would be hugely beneficial for being able to locate definitions of things
14:31:37 <Cale> Haskell isn't even the best at this
14:31:45 <hyiltiz> why not view aka .^ ?
14:31:59 <Cale> If I see that something is in Data.Text.Encoding I may or may not know that this module is in the text package
14:32:16 <Cale> but at least once I've discovered that much, I know where to find the definition
14:32:19 <polyphem> hololeap: https://gist.github.com/polyrod/f14351 latest version
14:32:21 <Cale> which file to look it
14:32:23 <Cale> in*
14:32:23 <hyiltiz> xerox_: I can hear What's wrong with XXX screaming in my head
14:32:28 <monochrom> dear polyphem and hololeap: Don't use pattern matching "runCyber (Cyber rt) =", it has a monomorphizing effect, it's why you lose the forall s and get a rigid typevar.  Define "unCyber (Cyber m) = m", "st = runReaderT (unCyber c) ()".  This gives a chance for let-generalization to give you back your forall.  It's also OK to inline unCyber there. Overall don't do pattern matching unless in a scope that enjoys let-generalization.
14:32:31 <ja> hyiltiz: sure, you can use it too. i prefer using less lens operators, and you can get far with %~ :P
14:32:51 <Cale> infinisil: It would also help if they just broke it up a little
14:33:10 <Cale> infinisil: There's no reason for basic library stuff to be mixed in with all the package definitions and to be part of the same fixed point
14:33:21 <Cale> (or even the same repo)
14:33:31 <infinisil> Cale: So you'd separate libraries from applications?
14:33:34 <Cale> yeah
14:33:44 <infinisil> What about libraries that also provide an application
14:34:01 <polyphem> monochrom: ok , i am digesting
14:34:08 <infinisil> (that's the problem with all categorizations)
14:34:26 <Cale> Well, in general, nix needs a much stronger standard library of data structures and things that have nothing directly to do with the production of derivations
14:34:36 <Cale> and nixpkgs should be broken up into more manageable pieces
14:34:39 <hyiltiz> ja: thx! Now back to getting _2 . _1 work
14:35:05 <infinisil> Cale: Wanna go to #nixos-chat to discuss this? I feel like we're a bit offtopic here
14:35:09 <Cale> sure
14:36:09 <hololeap> Dear monochrom: I read your letter as soon as it arrived. Unfortunately, it arrived too late as the compiler grew self-aware and found my errors to be signs of inferiority. I have released myself to the mercy of GHC and await my final verdict.
14:36:39 <monochrom> haha
14:37:01 <monochrom> (read: GHC is taking an hour to type-check this)
14:39:41 <hololeap> monochrom: would you mind showing an example? i was also stumped by this.
14:40:09 * hololeap dosn't have a very good understanding of working with forall's
14:40:13 <ski> hololeap : <http://www.lisperati.com/landoflisp/panel60.html>
14:41:14 <hololeap> ski: basically...
14:41:49 <monochrom> haha
14:43:25 <ski> hololeap : `newtype SomeST a = SomeST (forall s. ST s a)' is not an existential wrapper (should not be called `SomeST')
14:44:18 <ski> (and, from a quick glance over the conversation, it looks like you most likely didn't want an existential, either ?)
14:45:49 <monochrom> hololeap: http://dpaste.com/1TH5MVN
14:48:06 <dolio> 'SomeST' is actually the same as `Identity`.
14:49:16 <dolio> That is the secret behind ST.
15:00:31 <hololeap> monochrom: ok... what is going on here? why did you have unCyber as a seperate function instead of including it in the record syntax?
15:00:44 <monochrom> habit
15:00:57 <monochrom> that detail doesn't matter
15:01:02 <hololeap> and why does pattern matching on Cyber in runCyber instead of using unCyber muck it up?
15:01:36 * hololeap is curious as to where monochrom's habit came from
15:01:57 <monochrom> teaching students without spending time to explain record syntax
15:02:05 <polyphem> monochrom, hololeap : ok it compiles now even with the other functions :)
15:03:51 <hololeap> "it has a monomorphizing effect" ... i don't follow :(
15:04:28 <polyphem> so pattern matching "fixates" the unbound type vars , right
15:04:30 <polyphem> ?
15:04:45 <hololeap> unCyber pattern matches on Cyber, so what's the difference?
15:05:03 <koz_> That pattern matching has serious psychological issues.
15:05:21 <koz_> Those fixations on unbounded type vars can't be healthy.
15:05:56 <koz_> "Doctor, I see 'a' and CAN'T STOP THINKING ABOUT IT! I don't get this reaction from 'Int'."
15:11:47 <hololeap> this is confusing... it's like referential transparency doesn't apply here
15:13:32 <monochrom> I am not 100% sure about the theory behind. But start with "(\f -> (f True, f 10)) id" vs "let f=id in (f True, f 10)".
15:14:24 <monochrom> or even,  "(\f -> (f True, f 10)) id" vs "(id True, id 10)"
15:15:19 * ski . o O ( `instance Num Bool where ..' )
15:15:28 <hololeap> again, i would think those should be synonymous
15:15:39 <monochrom> HM says no.
15:15:54 <monochrom> Remember ski's reminder comics? >:)
15:16:05 * ski was just reminded of it ;)
15:16:23 <hololeap> HM?
15:16:29 <ski> Hindley-Milner
15:16:32 <monochrom> Hindley Milner type inference.
15:16:46 <ski> @where polymorphic-type-inference
15:16:46 <lambdabot> "Polymorphic Type Inference" by Michael I. Schwartzbach in 1995-03 at <https://cs.au.dk/~mis/typeinf.p(s|df)>,<http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.57.1493>
15:16:59 <polyphem> i infered HaskellManual ... oops
15:17:07 <monochrom> has a generalization step that inserts "forall" in some scopes but not in others.
15:17:45 <maerwald> are there funny side effects when creating a handle from a pipe fd?
15:18:13 <hololeap> is this lack of referential transparency just a nuance of this HM approach, or is there no way around it?
15:18:48 <superstar64> referential transparency and hindley milner have nothing to do with each other
15:18:56 <superstar64> you can have one without the other
15:19:17 <ski> ah, (first) link is broken, try <https://cs.au.dk/~amoeller/mis/typeinf.pdf>
15:19:43 <hololeap> ski: alrighty
15:20:16 <polyphem> so , forall wont get inserted on pattern matching, but when let bound ther will be forall , i.e no monomorphism
15:20:18 <fog> i have a mutually recursive set of functions, and i want to *add* to this... how can i do that? 
15:20:29 <fog> is it a monoid like concat?
15:21:09 <dolio> Once you're matching on the Cyber, the `s` must have already been instantiated to something, so it makes no sense to expect it to still be polymorphic from a scoping perspective.
15:21:12 <superstar64> if your already familiar with typing rules, the wikipedia article is a explanation of hindley milner https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system 
15:21:39 <hololeap> monochrom: also where are these "reminder comics"?
15:21:43 <superstar64> unification theory is the key component of it too, so that's worth looking into too
15:22:05 <monochrom> http://www.lisperati.com/landoflisp/panel60.html
15:22:28 * ski . o O ( <http://www.lisperati.com/landoflisp/panel57.html>,<http://www.lisperati.com/landoflisp/panel63.html> )
15:23:10 <fog> if say, x refers to y, and y refers to x, and i want to insert  z so that z refers to y instead of x referring to y, and x refers to z instead of y
15:23:20 <ski> fog : perhaps you want to look into "open recursion"
15:23:29 <fog> ooo, whats that?
15:24:34 <ski> also see `fix'
15:24:43 <maerwald> why merijn got no bouncer... poor students
15:25:33 * ski had a lecturer (algebra) who's say "reminder" instead of "remainder"
15:26:20 <fog> erg, i messed that up, above. maybe its easier to write it symbollically;
15:26:47 <hseg> just to confirm an assumption i'm making -- there's no such thing as a strict function field? i.e. data T = ... (a -> b) doesn't need a !
15:26:48 <fog> x <-- y, y <-- x would become, on "inserting" z; x <-- z, y <-- x, z <-- y
15:26:50 <hseg> ?
15:27:00 <frdg> if anyone has experience with Persistent I could use some insight on how to use the select functions for queries. https://dpaste.org/Pdp4
15:27:06 <dolio> hseg: You can do it.
15:27:17 <hseg> ... wat
15:27:42 <fog> ski: i get fix, i think, but how is that to do with "actions" adding to bunches of mutually recursive function implementations?
15:27:56 <hseg> whnf for functions is until they are of form \.. -> thunk ?
15:28:02 <monochrom> Yes.
15:28:19 <hseg> ok, i stand corrected
15:28:20 <frdg> https://dpaste.org/P8Xm sorry gave wrong version of test
15:28:32 <hseg> it's just that stan recommended what seemed like nonsense to me
15:28:36 <ski> fog : i got you, the first time
15:28:42 <monochrom> But recall when I give you a "function" I can always write "if <this expression takes 10 years to eval> then (\x -> x) else (\x -> x)"
15:29:37 <ski> fog : you can only add them, before you've tied the knot
15:29:39 <hseg> fair. so if i were strict there, i would incur that cost every time, even if i never used the function
15:29:52 <fog> if i could write that as.  [x,y] [y,x] getting turned into, on adding z; [x,y,z] [z,x,y]
15:29:58 <ski> fog : unless you add some indirection, where you can swap out what's indirected
15:30:24 <fog> ah, yeah, it needs some extra information, about cow to reconnect the things
15:31:14 <dolio> Yes, that's always the tradeoff with strictness.
15:31:47 <hseg> ok. but if i know i'm going to evaluate it completely anyway, might as well strictify it?
15:32:05 <monochrom> yes
15:32:17 <monochrom> also, no one is as naughty as me :)
15:32:24 <hseg> :)
15:32:31 <maerwald> hmmm
15:33:56 * hackage numhask-space 0.5.0 - numerical spaces  https://hackage.haskell.org/package/numhask-space-0.5.0 (tonyday567)
15:34:06 <hseg> hrm. so to clarify my intuition, if i have data T = ... (Map k v) that i'm only ever going to query at a couple of fixed values, the correct thing to do is use a lazy map but have the map field itself be strict?
15:34:40 <hseg> also, bad maerwald. no plotting evil bottom bombs
15:34:46 <maerwald> I'm not sure it's a good idea to convert a pipe fd to a handle... RTS might keep the write end open after the process exited I guess?
15:34:52 <monochrom> Oh that one is super tricky. Eventually you will learn that boolean blindness hurts understanding of strictness, too.
15:35:02 <hseg> ?
15:35:05 <EvanR> unfortunately a large map may take up a lot of space regardless of if it's lazy
15:35:12 <dmj`> hseg: I'd use a strict map
15:35:33 <EvanR> unless you can find a map data structure that is REALLY lazy
15:35:40 <dmj`> hseg: otherwise it can lead to space leaks
15:35:49 <hseg> even if the number of keys "stored" is *much* larger than the number of keys queried?
15:36:07 <EvanR> each value takes up space
15:36:08 <monochrom> Map is always strict on its BST structure, and strict enough for keys so it can and has finished all necessary comparisons to build the BST completely.
15:36:12 <EvanR> lazy or not
15:36:24 <monochrom> So called "lazy Map" vs "strict Map" is only lazy/strict on v.
15:36:45 <hseg> wait. you're saying i'm paying for all the keys?
15:36:51 <monochrom> If laziness on v saves you time, go ahead. But don't expect lazy tree structure or lazy on k.
15:36:56 <monochrom> YES
15:36:57 <hseg> hrm.
15:37:08 <EvanR> you pay for all keys and the values (either thunks or final values)
15:37:11 <hseg> maybe map isn't the right data structure here then
15:37:30 <monochrom> See why boolean blindness hurts? The world is not "strict vs lazy".  Strict on which part?
15:37:43 <hseg> basically what i'm doing is lookup k (product maps)
15:37:53 <hseg> where product is a convolution on the maps
15:38:01 <fog> here, like this; https://pastebin.com/raw/zQVCiJyx
15:38:12 <ski> > let new = fix; xyClass ~(x0,y0) = (x,y) where {x = 0:y0; y = 1:x0} in let (x,y) = new xyClass in (take 4 x,take 4 y)
15:38:12 <superstar64> choosing between laziness and strictness is the worst part of haskell imo
15:38:13 <lambdabot>  ([0,1,0,1],[1,0,1,0])
15:38:16 <ski> > let new = fix; xyClass ~(x0,y0) = (x,y) where {x = 0:y0; y = 1:x0}; xyzClass ~(x0,y0,z0) = (x,y,z) where {(x,y) = xyClass (x0,z0) ; z = 2:y0} in let (x,y,z) = new xyzClass in (take 4 x,take 4 y,take 4 z)
15:38:18 <lambdabot>  ([0,2,1,0],[1,0,2,1],[2,1,0,2])
15:38:20 <ski> fog ^
15:38:34 <fog> argh!
15:38:38 <dmj`> superstar64: lazy in the spine, strict in the leaves
15:38:38 <hseg> which has combinatorial blowup in the number of keys
15:38:40 <shapr> superstar64: I don't worry about it, does that mean I've already chosen laziness?!
15:38:56 <maerwald> dmj`: it's a dance move
15:39:01 <hseg> especially in the common case where the keys don't form an arithmetic progression
15:39:07 <dolio> If the performance matters, then you have to think about it.
15:39:26 <superstar64> i never make my code strict
15:39:27 * hackage box 0.5.0 - boxes  https://hackage.haskell.org/package/box-0.5.0 (tonyday567)
15:39:33 <superstar64> when i need performance i just use something else
15:39:49 <maerwald> I have StrictData and Strict enabled in my cabal files, lol
15:39:59 <dolio> You need to think about it in any language.
15:40:00 <EvanR> not making it strict in many cases is the difference between 'works' and 'freezes up / crashes'
15:40:01 <maerwald> living on the edghe
15:40:09 <EvanR> so not exactly performance
15:40:11 <hseg> would changing to a hashmap help here, or would it also make me pay for everything?
15:40:11 <shapr> which edge of the graph?
15:40:18 <dmj`> superstar64: you can hit space leaks if you don't though. IORef (Int,Int) is an example where you can have a long running thread build up a thunk that is never forced
15:40:20 <dolio> People just complain about it in Haskell for some reason.
15:40:26 * hackage numhask-array 0.7.0 - n-dimensional arrays  https://hackage.haskell.org/package/numhask-array-0.7.0 (tonyday567)
15:40:50 <dmj`> maerwald: StrictData sounds sane, Strict not so much
15:40:59 <EvanR> yes, having to choose is not bad at all. If you want the 'benefit' of the other languages just choose strict without thinking
15:41:00 <monochrom> Also in principle with a list of length n you can have at least n levels of strictness, i.e., strict to the first i nodes. (There is more for the elements themselves.)
15:41:05 <maerwald> dmj`: kazu uses it too
15:41:18 <monochrom> There is 50 shades of strictness.
15:41:27 <hseg> right. strictness is a dcpo iirc
15:42:00 <maerwald> I've found no interesting differences in the large, except you break your monadic combinators easily
15:42:17 <superstar64> are there any preludes that have everything strict by default?
15:42:26 <monochrom> 50 shades of lazy. 50 shades stricter. 50 shades evaluated.
15:42:26 <hololeap> what is the significance of this, especially from a CT perspective: Op r (Op c a, Op c b) ‚âÖ Op r (Op c (Either a b))
15:42:29 <maerwald> strictLude
15:43:05 <monochrom> no I have a better idea
15:43:14 <fog> here; https://pastebin.com/raw/YB8vk6zF
15:43:18 <hseg> i mean, even in a small case, i "have" ~60k keys out of which i only want to pay for ~4k
15:43:21 <monochrom> 50 shades of lazy. 50 shades stricter. 50 thunks freed.  <-- that last one works so much better :)
15:43:36 <fog> ski: i rewrote that above 
15:43:37 <hseg> >D
15:43:46 <fog> what are the ~ on the patterns?
15:44:11 <hseg> fog: irrefutable patterns. means it can match against bottom iirc
15:44:13 <dmj`> superstar64: probably not a good idea
15:44:21 <infinisil> hololeap: I'm no CT expert, but that looks wrong
15:44:30 <EvanR> considering lists have n levels of strictness, at least, we need better language to talk about the diff between lazy map and strict map. Or list and array
15:44:45 <EvanR> strict vs lazy apparently doesn't cut it
15:44:51 <dmj`> superstar64: take "foo x y = print y", then invoke it with "foo (sum [1..]) 3" w/ StrictData, it will hang forever
15:45:04 <hololeap> same as `(a -> c) -> (b -> c) -> r` ‚âÖ `(Either a b -> c) -> r`
15:45:16 <superstar64> like in other languages?
15:45:19 <monochrom> Likewise "conservative" vs "liberal".  False dichotomies are everywhere. It's in human nature.
15:45:30 <hseg> yup. easier to tag things that way
15:45:32 <dmj`> superstar64: you end up doing more work with strictness often
15:45:32 <infinisil> hololeap: Yeah that also looks wrong
15:45:46 <infinisil> Hm does it
15:45:51 <superstar64> i just feel strictness vs laziness is something the type system should help us with 
15:45:54 <hololeap> % :t \bigF f g -> bigF (either f g)
15:45:55 <yahb> hololeap: ((Either a b -> c) -> t) -> (a -> c) -> (b -> c) -> t
15:46:08 <dmj`> superstar64: yes. Outside-in evaluation might not be intuitive at first, but only when you approach performance issues do you need to think about it
15:46:15 <hololeap> % :t bigF f -> bigF (f . Left) (f . Right)
15:46:15 <yahb> hololeap: ; <interactive>:1:8: error: parse error on input `->'
15:46:18 <ski> fog : do you understand it ?
15:46:21 <hololeap> % :t \bigF f -> bigF (f . Left) (f . Right)
15:46:21 <yahb> hololeap: ((a -> c) -> (b -> c) -> t) -> (Either a b -> c) -> t
15:46:24 <fog> yeah
15:46:40 <fog> so you managed to do that pretty well with haskell syntax
15:46:51 <fog> i guess i just need to write some kind of abstraction around it
15:46:51 <superstar64> dmj`, i think it's sensible default if performance is a non issue
15:46:57 <hololeap> infinisil: see?
15:47:09 <superstar64> when i start caring about performance i think strict by default is the way to go
15:47:22 <fog> so that the "object" can be updated to kind of contain the where or let bound recursive block
15:47:36 <hseg> ok, so how do i make lookup k (product (ms :: [Map k v])) not blow up in allocation?
15:47:37 <dolio> It doesn't matter what the default is, you still need to put thought in.
15:48:03 <EvanR> freezing up or stack overflowing when you don't considering laziness or lack thereof isn't realy a performance thing. In the sense that "i ignore it and i can come back later and iterate for slight improvement"
15:48:26 <EvanR> ignore it and production server goes by by
15:48:28 <infinisil> hololeap: `(a -> c) -> (b -> c) -> r` ‚âÖ `(Either a b -> c) -> r` looks correct I agree
15:48:43 <fog> actually wait, no, i dont actually understand about how its using those irrefutable patterns 
15:48:48 <infinisil> hololeap: But `Op r (Op c a, Op c b) ‚âÖ Op r (Op c (Either a b))` doesn't specify what Op is
15:48:53 <EvanR> i.e. it's discontinuous performance
15:49:07 <hololeap> @hoogle Op
15:49:08 <lambdabot> Data.Functor.Contravariant newtype Op a b
15:49:08 <lambdabot> Data.Functor.Contravariant Op :: (b -> a) -> Op a b
15:49:08 <lambdabot> Language.Haskell.Exts.Syntax data Op l
15:49:17 <infinisil> Ahh didn't know about that Op
15:49:35 <infinisil> So `Op a b ~ b -> a`
15:49:51 <hololeap> yeah
15:49:53 <superstar64> how much of a pain is termination checking in total languages?
15:49:57 <infinisil> Then yeah, that Op isomorphism looks correct too
15:50:01 <superstar64> would it be worthwhile in haskell?
15:50:45 <MarcelineVQ> a pain for who?
15:50:58 <hseg> note the product constructs O(prod ni)~O(n^n) terms, but i only need ~O(n!) of them
15:50:58 <superstar64> the programmer?
15:51:02 <dolio> Framing performance as 'strict vs. lazy' is naive, too. If you want good performance, just being strict isn't enough. You need to understand the evaluation model and optimizations the compiler implements to do a really good job.
15:51:09 <monochrom> Wait, I thought termination checking was "always passes" in total languages. :)
15:51:14 <MarcelineVQ> somewhat of a pain
15:51:18 <hololeap> there's something about it that tickles my brain, since (,) is the product and Either is the coproduct. that's why i'm wondering if someone can explain the isomorphism in CT terms
15:51:25 <dmj`> superstar64: http://goto.ucsd.edu/~gridaphobe/liquid/haskell/blog/blog/2013/12/09/checking-termination.lhs/
15:51:28 <fog> superstar64: depends what the benefits would be
15:52:03 <superstar64> wouldn't it help with reasoning about laziness vs strictness?
15:52:05 <infinisil> hololeap: I see, (can't do that myself though)
15:52:06 <ski> fog : `new' (that is `fix') corresponds to instantiating an object from a class (in the OO) sense. you can't really splice in a new implementation (like `z' inbetween `x' and `y'), after you've already instantiated, can only do that on the class level
15:52:30 <superstar64> like, if something is total, then laziness vs strictness is just optimization at that point
15:52:49 <fog> superstar64: lazyness isnt only needed when otherwise it would force an infinite evaluation. you could have lazy "take" over a long finite list and it would still be useful
15:53:05 <monochrom> But using a less literal interpretation: IMO total languages are painful for both users and implementers.
15:53:45 <fog> what do you mean "only do that at class level" ?
15:54:09 <ski> hololeap : ‚åúHom(A‚ÇÄ,B) √ó Hom(A‚ÇÅ,B) ‚âÖ Hom(A‚ÇÄ + A‚ÇÅ,B)‚åù, where ‚åú+‚åù is coproduct in the category, and ‚åú√ó‚åù is cartesian product of sets (the Hom-sets, in this case)
15:54:24 <fog> i dont know OO, so i dont get why you called those functions ...Class
15:54:29 <monochrom> because unless you really aim at a degenerate trolling language, the implementer has to make better provers to allow interesting programs, and the user has to cope with more complicated how-to-get-approved rules, too.
15:55:01 <ski> hololeap : cf. ‚åúHom(A,B‚ÇÄ) √ó Hom(A,B‚ÇÅ) ‚âÖ Hom(A,B‚ÇÄ √ó B‚ÇÅ)‚åù, where the first ‚åú√ó‚åù is cartesian product of sets (as before), while the second is product in the category
15:55:12 <ski> hololeap : aka categorical coproduct and categorical product
15:55:42 <fog> also, though im not sure if it makes a difference, but x,y,z were types
15:55:59 <fog> and they were supposed to correspond to the types of the arguments to a function
15:55:59 <ski> in your explanation ?
15:56:03 <monochrom> "just optimization" is a big understatement, even in the restricted scope of choosing strictness assuming termination
15:56:08 <fog> ski: yeah
15:56:17 <hololeap> ski: can this be explained without hom-sets? something about the coproduct being the dual of the product?
15:57:11 <superstar64> are there any haskell clones that are lazy?
15:57:16 <superstar64> i know purescript and idris are strict
15:57:27 <maerwald> eta?
15:57:46 <superstar64> i'm not sure that counts as a clone
15:57:51 <fog> it was like "to calculate the output which has type x, an input of type y is needed" etc
15:57:56 <dolio> Academic stuff about totality and (co)data is pretty bad about conflating things, too. Like, usually it is assumed that all data should be strict, but there's no reason to assume that people always want a provably finite list to be fully realized in memory immediately.
15:58:08 <maerwald> superstar64: why
15:58:13 <MarcelineVQ> are there any haskell clones?
15:58:33 <superstar64> purescript and idris look like haskell but aren't, eta is modified ghc
15:59:02 <fog> '[(x, '[y]),(y, '[y,z])] would be like (y -> x,y z -> y) 
15:59:15 <fog> (y -> x,y -> z -> y) 
15:59:19 <ski> hololeap : you can internalize to get ‚åúB·¥¨‚Å∞‚Å∫·¥¨¬π‚Å∫ ‚âÖ B·¥¨‚Å∞ √ó B·¥¨¬π‚åù
15:59:50 <hololeap> ok, then it's just simple algebra :)
15:59:54 <fog> where its assumed these types are not reused
16:00:12 <fog> so from the type you know which variable it refers to
16:00:19 <ski> hololeap : to talk about duality, you're, at some level, talking about reversing arrows, which live in those Hom-sets
16:00:50 <fog> like, having all the let bound values having a type level Symbol also containing the values name 
16:01:35 <ski> Clean is lazy
16:01:44 <hololeap> ski: gotcha. but my mind was "pattern-matching" on something with that isomorphism and i think the "internalized" version is the closest
16:02:47 <hololeap> ski: btw, how did you do the sub/super-script in IRC?
16:02:56 <ski> copy&paste
16:03:08 <monochrom> I think it's just unicode.
16:03:11 <ski> yes
16:03:15 <hololeap> weird
16:03:19 <dolio> Get an IRC client that understands digraphs.
16:03:46 <hololeap> didn't know unicode had all that
16:03:50 <MarcelineVQ> confuse your friends and family when you write x^3
16:04:22 <MarcelineVQ> oh, actually that one works, foisted
16:04:23 <monochrom> downside of superscript: too small
16:05:19 <hololeap> just up your pixel density and lean in closer :)
16:07:16 <fog> how rude...
16:08:30 <monochrom> Aww why do people still want ISO-8859-1 in this the 21st century of our lord???!!!!
16:08:48 <hololeap> ·∞Ñ deal with it
16:10:24 <fog> is there a more systematic way to do time integration schemes than things like this?
16:10:25 <fog> https://hackage.haskell.org/package/learn-physics-0.4.3/docs/src/Physics-Learn-RungeKutta.html#rungeKutta4
16:10:46 <fog> i thought they could be derived
16:11:33 <fog> you would think it would be better to have it output arbitrary orders, solving for the weights
16:11:56 * hackage box-socket 0.0.1 - See readme.md  https://hackage.haskell.org/package/box-socket-0.0.1 (tonyday567)
16:12:56 * hackage box-csv 0.0.1 - See readme.md  https://hackage.haskell.org/package/box-csv-0.0.1 (tonyday567)
16:13:10 <shapr> what are those packages? box-socket doesn't really do anything
16:13:13 <shapr> why upload it?
16:15:20 <hololeap> it's a rite of passage to upload a pointless library to hackage
16:15:25 <maerwald> l miss the Ukrainian music uploads
16:15:39 <maerwald> they used to be frequent
16:17:09 <solonarv> @hackage box -- appears to be the "root" of this project hierarchy
16:17:10 <lambdabot> https://hackage.haskell.org/package/box -- appears to be the "root" of this project hierarchy
16:17:27 <hseg> q: any nice way of pruning .cabal of unnecessary deps?
16:18:07 <monochrom> the readme looks like a gpt-3 essay
16:18:14 <solonarv> it does!
16:18:23 <solonarv> well, gpt-3 doesn't have as many quotes
16:19:27 <monochrom> I watched too many spy movies, so my guess is this box family is an encrypted message between spies.
16:21:07 <dolio> Do spies communicate by quoting tired nerd memes?
16:21:34 <raehik> evening all. Trying to figure out what function I need to iterate over a list for every element, but each iteration includes the rest of the list after that element. must be simple but can't figure it out
16:21:35 <dolio> I thought they were cooler.
16:21:44 <fog> i read the blurb on that ukranian speech thing, it was actually a pretty cool idea - some kind of net you would train by putting on an accent and it would then take your regular speech and make it have the same accent 
16:21:45 <raehik> context is work in the list monad
16:21:46 <MarcelineVQ> commit is the dual of emit appearantly, but one can also just omit
16:23:23 <fog> maybe you could use it to deep fake trump speeches so he was like "ADVANCE FORWARDS COMRADES" 
16:27:37 <xsperry> raehik, see tails
16:27:40 <xsperry> > tails [1..5]
16:27:42 <lambdabot>  [[1,2,3,4,5],[2,3,4,5],[3,4,5],[4,5],[5],[]]
16:28:38 <fog> is that efficient? 
16:29:02 <ski> yes
16:29:04 <xsperry> it's the same list. tail is O(1)
16:30:32 <xsperry> and tails effectively calls length times
16:30:37 <hololeap> fog: it wasn't actually anything that complex, if you looked at it. it was just a wrapper around sox, presumably mashing together pre-recorded syllables into some kind of text-to-speech application
16:30:38 <xsperry> and tails effectively calls tail length times
16:31:32 <raehik> xsperry: thanks, perfect
16:32:09 <fog> > (\xs -> (scanl (\ a _ -> tail a)) xs (replicate (length xs) ())) [1,2,3]
16:32:11 <lambdabot>  [[1,2,3],[2,3],[3],[]]
16:33:10 <hololeap> wow, 7 different packages by that person: https://hackage.haskell.org/packages/search?terms=ukrainian
16:36:14 <fog> but like, it has to copy the values right?
16:37:08 <fog> > (map head . tails) [1,2,3]
16:37:09 <xsperry> tails? no
16:37:10 <lambdabot>  [1,2,3,*Exception: Prelude.head: empty list
16:37:58 <fog> > (map head . init . tails) [1,2,3]
16:37:58 <EvanR> to copy the values or not to copy the values that is the question
16:38:00 <lambdabot>  [1,2,3]
16:38:30 <EvanR> haskell doesn't copy any values by default
16:38:53 <hololeap> @src tails
16:38:53 <lambdabot> tails []         = [[]]
16:38:53 <lambdabot> tails xxs@(_:xs) = xxs : tails xs
16:39:33 <hololeap> are we sure that tails is O(n) ?
16:39:52 <EvanR> sure
16:40:51 <hololeap> wouldn't that imply some kind of memoization?
16:41:02 <EvanR> eh?
16:41:07 <xsperry> elements aren't copied, it just puts all the tails [pointer to each tail under the hood] in a list
16:41:12 <fog> > (take 3 .map head . init . tails) [1..]
16:41:15 <lambdabot>  [1,2,3]
16:42:31 <hololeap> on the first iteration, it returns the list plus `tail` of that list. on the second iteration, it returns the tail plus *its* tail, etc. so it isn't traversing the iteration's tail every time?
16:42:43 <EvanR> the list plus tails of the tail
16:42:45 <fog> what if to unfold the list you needed access to the previous values, like in an implicit scheme?
16:43:03 <EvanR> that's every iteration (except the last)
16:43:05 <hololeap> (sorry, it's hard to put it into simple english)
16:43:27 <EvanR> it never directly returns a tail
16:43:35 <EvanR> and never touches any elements
16:43:41 <hololeap> ah, true
16:44:03 <hololeap> ok, is `show . tails` O(n) ?
16:44:36 <EvanR> fog: you might want inits
16:44:46 <EvanR> which is not as efficient
16:44:53 <EvanR> or scanl
16:46:34 <EvanR> show . tails will show the whole list, then the whole list minus 1, whole list minus 2...
16:46:47 <EvanR> N^2 / 2 items
16:47:26 * hackage online 0.6.0 - See readme.md  https://hackage.haskell.org/package/online-0.6.0 (tonyday567)
16:47:28 <hololeap> that's what i thought
16:47:53 <EvanR> it won't be able to reuse any previous work
16:48:10 <EvanR> since the two functions aren't cooperating
16:49:04 <EvanR> you could implement something equivalent to show . tails that is more efficient
16:49:59 <monochrom> there is no way you can tell show that its input has a sharing structure
16:50:30 <monochrom> the same reason why you can't code up cycle detection, pointer equality, unless you use a backdoor.
16:53:23 <monochrom> The consolation is that tails doesn't create new data, but inits does.
16:55:15 <EvanR> I'm tired of haskells' asymmetry of lists. List should work the same forward and back. Like in perl!
16:55:25 <EvanR> make it so
16:56:18 <EvanR> (because haskell list is not actually a list, but a stack)
16:56:52 <monochrom> I forgot what really is perl's "list" but it is an abstraction, like python's "list", that makes one tradeoff behind your back and not tell you, so you don't actually know which assymetry it has chosen.
16:57:48 <monochrom> "so opague it is not obviously symmetric" vs "so transparent it is obviously not symmetric".
16:57:49 <EvanR> every language uses a different implementation and then doesn't talk about it. Which is why every language uses a different implementation
16:57:59 <monochrom> I would take transparency and honesty any day.
16:58:11 <fog> yeah, whats pearls list?
16:58:24 <fog> is it like a snoc and cons list like Seq?
16:59:17 <fog> i dont see how it could be lazy both ways
16:59:25 <EvanR> the opinion i kept running into was, for "numbers" "list" "map" etc we just want the best possible implementation.
16:59:38 <monochrom> You tell me "prepend takes linear time" and I will design my algorithm to avoid prepend.  You tell me "the API supports all list operations, all random access operations, all lookup operations" and it is too good to be true.
17:00:11 <dolio> You can use Seq and pay for the bad constant factors.
17:00:15 <monochrom> (Python "list" prepend takes linear time.)
17:00:22 <MarcelineVQ> just write it as supports*
17:01:05 <EvanR> one day well find the best number implementation that has good characteristics all the way down
17:01:42 <fog> isn't list snoc O(1) if the list is of bounded length?
17:01:53 <fog> with bad constant factors?
17:02:14 <EvanR> you make a good argument for big O being banned from consideration
17:02:21 <MarcelineVQ> which list, which snoc?
17:02:37 <monochrom> I would say "whose". :)
17:02:54 <MarcelineVQ> whomst'd'v'n't'd's list?
17:02:58 <fog> haskell list, and haskell snoc. but yeah, EvanR is right, im still reeling from Seq
17:03:00 <monochrom> Python wants to be anthropomorphized. :)
17:03:35 <EvanR> Data.Seq doesn't have O(1) reverse ( i don't think. unlike perl )
17:03:46 <monochrom> EvanR, what do you replace big O by?
17:03:58 <fog> what is this magical pearl list!?
17:04:26 <EvanR> it's implemented with arrays and pointers so you can just count backwards
17:04:48 <EvanR> because reversing is just that useful
17:04:58 <fog> i guess pointer decrement is linear complexity...
17:04:58 <monochrom> doubly linked list can also do that.
17:05:41 <monochrom> But seriously fog have you finished 1st year and 2nd year CS?
17:06:10 <fog> CS is never finished 
17:06:24 <monochrom> evasion
17:06:38 <monochrom> I only talk of 1st year and 2nd year CS, not all of CS.
17:06:56 * hackage readme-lhs 0.7.0 - See readme.md  https://hackage.haskell.org/package/readme-lhs-0.7.0 (tonyday567)
17:07:09 <fog> no, i switched to physics and maths after 1 year of CS
17:07:18 <monochrom> "Did you learn 1+2=3?"  "No, addition is a whole life-time philosophy."
17:07:35 <fog> i learned haskell in that year, and the other languages were supposed to be taught in the rest of the course. so i got stuck in GHC
17:07:54 <monochrom> I recommend you at least finish 1st & 2nd year CS.
17:08:32 <monochrom> Because you're speaking like you're deep into research-level machine learning and you don't even know what arrays are like.
17:08:44 <fog> but my prof wants me to learn Brauer group theory
17:08:54 <monochrom> This means at this rate you're only an armchair machine learning lunatic.
17:09:32 <fog> a MANIAC?
17:09:39 <monochrom> raving about great imagination of how machine learning could be done, and can implement absolutely nothing that works, because you can't even get arrays to work.
17:10:25 <fog> wowza!
17:10:48 <fog> to be fair, arrays are really annoying 
17:11:43 <sm[m]> True!
17:11:57 <fog> here was my most recent discovery https://arxiv.org/pdf/1905.12560.pdf
17:12:29 <monochrom> Oh hey, did anyone notice the irony in "readme-lhs 0.7.0 - See readme.md" :)
17:12:43 <monochrom> almost like googling for recursion
17:13:55 <fog> but i didnt learn about sigma algebras yet so i cant read it
17:17:24 <monochrom> oh w00t ghc 8.8.4
17:26:04 <ezzieyguywuf> working through the megaparsec tutorial again. For the definition of the Stream class, what does `type Token  s :: *` represent?
17:28:31 <monochrom> If you use [Int] for your stream, your token type is Int.
17:29:16 <ezzieyguywuf> the syntax is unfamiliar though, is this some language extension?
17:29:28 <monochrom> Oh, that. "type family".
17:29:39 <ski> associated type
17:29:42 <ezzieyguywuf> ah
17:29:46 <ezzieyguywuf> yup just found the wiki
17:29:51 <ezzieyguywuf> yikes seems above my pay grade :-P
17:30:03 <monochrom> this one is in a class, so "associated type family"
17:30:16 <ski> alternative to an extra type class parameter
17:30:34 <ezzieyguywuf> ski: ah, that makes sense.
17:30:39 <monochrom> It solves a natural problem/desire. You just have to understand that desire.
17:31:33 <fog> its for when you want polykinded type families or something right?
17:31:34 <ezzieyguywuf> yea, i'll worry about understanding if I ever end up needing to use it
17:31:46 <ezzieyguywuf> I guess if I end up with something like `data MyThing a b c d e f g`
17:32:05 <fog> something about matching at the class head instead of the type family head
17:32:28 <monochrom> For this extension and most extensions, the GHC user's guide is the best reading material. It tells you a toy problem that you understand and agree you may one day confront a real problem along the same line, and how the extension addresses it.
17:34:37 <fog> i guess like, you could have a type family that recursed to consume the tail of a hetrogenous type list, and then because that has information at kind level, it would need to match on that at the class head
17:39:22 <fog> im still trying to figure how to write an implicit scheme using tails
17:39:36 <fog> i dont think its the futumorphism or what ever its called
17:40:37 <fog> i guess it makes a difference if your referring to the upwind elements of the input list or of the list your calculating
17:41:07 <fog> like, with a fold, its easy to refer to the input list past, or the values calculated past
17:41:25 <fog> but tails can only refer to the input list yet to arrive
17:41:37 <fog> not the output list yet to be calculated
17:41:56 * hackage perf 0.7.0 - Low-level run time measurement.  https://hackage.haskell.org/package/perf-0.7.0 (tonyday567)
17:42:55 <fog> so it kind of only has half the functionality we are used to when working with carries 
17:44:01 <fog> there was something to do with nash equilibria on rolling particle filters...
17:44:26 * hackage web-rep 0.6.0 - representations of a web page  https://hackage.haskell.org/package/web-rep-0.6.0 (tonyday567)
17:44:42 <fog> basically, you have a time centered window like a gausian, and you do statistics over the signal past and the predicted short time future 
17:45:19 <fog> otherwise you always have to work with backwards difference schemes
17:46:16 <fog> you end up with a system of equations to solve
17:46:27 <fog> like matrix inversion for implicit fluid schemes
17:47:05 <fog> they typically have better stability regions 
17:47:36 <fog> and are good for hyperbolic equations that spread information over all space
17:48:22 <fog> since thats quite a large spatial stencil! and you might as well do the matrix inversion
17:49:25 <fog> cant think how a haskell interface for that would work though, with it *generating* systems of equations
17:51:17 <fog> i guess it would be like unfolding a double linked list with tying the knot or the "credit card, buy now pay later" style thing
17:51:49 <fog> so as long as you only read over finite future values you can do so lazily and end up with a tractable system of equations to solve
17:53:18 <fog> i always get confused about programming with shift and reset and if callCC and Cont and continuations are the same thing
17:53:37 <fog> but that might be an alternative way to bridge the cycles
17:54:59 <fog> not sure if its worth mentioning cyclic self referential graphs, because you probably wouldnt ever need an implicit fluid solver *on a graph*
17:55:49 <fog> i guess you get trees though if your studying bifurcations
18:16:50 <monochrom> hololeap: I am as unhappy as you now.  http://dpaste.com/2Z72Z01  as simple as "case m of n" can break it.
18:32:27 <monochrom> In the GHC user's guide, on rank-n types, there is an informat rule: "For a lambda-bound or case-bound variable, x, either the programmer provides an explicit polymorphic type for x, or GHC‚Äôs type inference will assume that x‚Äôs type has no foralls in it."
18:33:02 <monochrom> So I understand that in "case m of n -> ..." n is monomorphic.
18:33:36 <monochrom> The surprise for me is that I would love to use ScopedTypeVariables to give n its polymorphism back, but that's banned too.
18:37:14 <dolio> Why do you want GHC's type checking algorithm to be designed around pointless case statement usage?
18:37:32 <monochrom> No, I don't want that.
18:37:56 * hackage chart-svg 0.1.0 - Charts in SVG  https://hackage.haskell.org/package/chart-svg-0.1.0 (tonyday567)
18:38:17 <dolio> You do. You want `m` to maintain a quantified type so that you can give a quantified type to `n`.
18:38:30 <monochrom> I am learning what GHC thinks, and I am reducing my experiments to the barebone to learn its rules.
18:38:34 <dolio> Just to rename m to n.
18:39:23 <monochrom> Sigh
18:39:39 <monochrom> This was the original context: http://dpaste.com/1TH5MVN
18:40:04 <dolio> Okay, so when you said you were unhappy, you weren't actually unhappy with what GHC was doing.
18:40:19 <monochrom> I am learning the difference between "f (Ctor y) = ... y ..." and "f x = ... (case x of Ctor y -> y) ..."
18:41:26 <monochrom> I guess this is why scientists are unwelcome in the world.
18:43:31 <monochrom> The scientist finds the simplest most occam-razor experiment to show a law of nature, and people attack the experiment as of no practical value.
18:55:40 <fog> monochrom: you have;
18:55:43 <fog> fmap f m = m >>= return . f
18:55:57 <fog> you should write this;
18:56:19 <fog> fmap f m = return . f =<< m  
18:56:24 <fog> and then
18:56:42 <fog> fmap f m = f <$> m  
18:56:52 <monochrom> this is getting ridiculous. everyone is mansplaining to me.
19:03:28 <c_wraith> I could have answered his question, but now he'll never know.
19:05:37 <Clint> such is life
19:05:43 <dolio> What question?
19:06:19 <c_wraith> Why GHC monomorphizes type variables in polymorphic values that have been matched in a case
19:07:25 * slack1256 has always been annoyed that traverse_ lives in Data.Foldable and not Data.Traversable
19:07:38 <Clint> always is a long time
19:07:45 <c_wraith> slack1256: but that's exactly the difference between traverse_ and traverse.
19:08:21 <c_wraith> traverse_ doesn't need the full power of Traversable - Foldable is sufficient.
19:08:30 <slack1256> I know. Still bothers me.
19:08:55 <slack1256> By name I think it ought to live in Data.Traversable. Looking at the impl I know it has to live in Data.Foldable.
19:09:20 <c_wraith> you could always use mapM_ instead!
19:09:37 <slack1256> DUDE
19:09:40 <slack1256> WHY
19:09:52 <c_wraith> won't make you think of Traversable
19:10:09 <slack1256> WHY IS THIS EXPORTED SO CONVENIENTLY
19:10:32 * slack1256 friendship with traverse_ ended, now mapM_ is my best friend.
19:10:52 <Clint> lulz
19:10:54 <c_wraith> Note that mapM_ will sometimes fail you in places where traverse_ would work, due to their slightly different types
19:11:45 <slack1256> Yeah, I don't bother with ZipList ever nor have used Haxl.
19:11:49 <slack1256> I think I will be fine.
19:11:53 <slack1256> Thanks c_wraith
19:22:16 <Peter90> is anyone here able to give me some advice on the best way to convert a specific function that I've written to point free style? I've tried the point free calculator, but it gives a ridiculous result
19:22:43 <c_wraith> sometimes the best thing is to trust the ridiculousness and not do it
19:23:44 <Peter90> I can definitely see that that could be the case but if there is a better way of writing it I am interested in learning
19:24:05 <dolio> Point free isn't always better, though.
19:25:20 <dolio> Unless it's just some simple composition, it's probably not worth it.
19:25:56 <Peter90> right, the reason why I was suspecting that it could be better in this case is because all my function is doing is calling another function and then checking its result against a constant
19:26:40 <Peter90> and the parameters are 3 tuples, so I thought that it would look a bit better / distract the programmer less if I don't have to write it out with the arguments just to immediatelly pass those arguments to another function
19:28:23 <angerman> what's the ideomatic way of running a filter with lookahead and lookbehind over a list? zip the list with drop a few times? 
19:29:10 <slack1256> Yes
19:29:42 <slack1256> zipWith (\a b c -> (a, b, c)) xs (tail xs) (tail (tail xs))
19:29:59 <slack1256> Well, zip3 
19:31:12 <halogenandtoast> Is there any way to write a FromJSON instance for: data SomeIsScenario = forall a. (FromJSON a, ToJSON a, Show a, RunMessage a, IsScenario a) => SomeIsScenario a
19:31:36 <halogenandtoast> I tried   parseJSON a = SomeIsScenario <$> parseJSON a, but the `a0` type is ambiguous
19:41:06 <OmegaDoug> The Hackage docs provides ``splitWith (=='a') "aabbaca"`` as an example for splitWith for the ByteString package. This fails to compile because Char != Word8. It seems like I should be able to copy and run the examples provided to see how the functions work. Do I need to pack the Char first to run the example?
19:44:57 <glguy> OmegaDoug: Are you looking at examples in : Data.ByteString.Char8?
19:45:07 <glguy> If so, make sure that's the module you import
19:45:26 <OmegaDoug> glguy I'm looking at the example on the ByteString documentation: http://hackage.haskell.org/package/bytestring-0.10.10.1/docs/Data-ByteString.html
19:46:03 <glguy> OmegaDoug: OK, for that to work you'll need to be using Data.ByteString.Char8
19:46:53 <OmegaDoug> Yeah. I didn't import that. I'll do that and retry
19:47:06 <glguy> maerwald: Probably nothing to do now, but I tried to 'ghcup upgrade' on an old version and it replaced ghcup with "<a href="/haskell/ghcup/master/ghcup">Moved Permanently</a>." :)
19:50:14 <halogenandtoast> I take it what I was trying to do is impossible. I can't seem to find anything that is going to let me do that.
19:50:27 <OmegaDoug> glguy Your suggestion worked. Thanks
20:19:37 <halogenandtoast> I came up with a sort of solution to my issue.
20:23:56 * hackage chart-svg 0.1.1 - Charts in SVG  https://hackage.haskell.org/package/chart-svg-0.1.1 (tonyday567)
21:34:26 * hackage musicScroll 0.3.0.0 - Supply your tunes info without leaving your music player.  https://hackage.haskell.org/package/musicScroll-0.3.0.0 (RubenAstudillo)
21:35:47 <slack1256> Now `pipes` based :-)
