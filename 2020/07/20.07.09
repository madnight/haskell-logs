00:00:05 <dminuoso> Monoid a => Monoid (IO a)
00:00:49 <iqubic> I don't want that.
00:00:55 <iqubic> I don't lie that.
00:01:23 <iqubic> *like
00:05:27 <hololeap> it's the same as Ap IO
00:05:40 <maier> I need to start another binary from Haskell code as a separate process. Is the `process` package the way to go here or are there any better/higher-level abstractions out there you recommend?
00:06:25 <dminuoso> Hard to say without knowing a bit more.
00:06:28 <maier> Ideally, I'd like to "monitor" the process in some way as well. The bare minimum would be to be able to kill it, but if possible also to restart it when it crashes/is gone.
00:06:45 <hololeap> process is pretty good, should have everything you would need i think
00:10:48 <maerwald> I just use Unix and async
00:10:54 <dmj`> maier: SystemD is good too
00:11:07 <dmj`> why use haskell for process monitoring
00:11:28 <maier> I always get a bit queasy when I have to watch out for any "leaks" :D so if I get this right, I'd probably use `proc` to define my `CreateProcess`, then `spawnProcess` in conjunction with `waitForProcess`. Does that sound feasible?
00:11:50 <maerwald> too simple, add some swag
00:12:00 <dmj`> maerwald: swag?
00:12:16 <dmj`> maerwald: what do you think this is, some runway show
00:12:26 <hololeap> maier: spawnProcess doesn't take a CreateProcess
00:12:27 <maerwald> :D
00:14:08 <dmj`> maier: waitForProcess sounds right
00:15:15 <maier> hololeap: whoops, I botched that in my mind, thanks. What I meant was that `spawnProcess` probably suffices for my use case and then I could waitForProcess.
00:15:20 <maier> thanks you all!
00:15:46 <hololeap> in any case, you could probably stitch something together with that. you can use `bracket` to catch any errors and restart the process
00:17:23 <hololeap> https://hackage.haskell.org/package/base-4.14.0.0/docs/Control-Exception.html#v:bracket
00:17:53 <hololeap> maier: or look for a higher-level library that does that. i'm not saying there isn't one... just not one that i know of
00:21:49 <maier> hololeap: yeah I was planning to use `bracket` around this anyway. But maybe I could make do with process's `withCreateProcess`. (Or probably both, if starting the process fails for some other reason)
00:21:50 <maerwald> there is something emulating go routines
00:21:59 <maerwald> but I don't remember
00:23:26 <hololeap> using spawnProcess vs another function depends on your needs
00:24:06 <maier> yeah, I'll have to figure those out on the go :D
00:24:16 <maier> so far it's an idea
00:27:50 <dmj`> maier: what are you using this for
00:28:01 <hololeap> but you can use waitForProcess to force it to wait for the process to terminate or an error is thrown
00:42:09 <maier> dmj`: I don't really know how to put it. The main program is a server receiving requests to perform actions on this machine (it's a very slim docker container basically containing this program and the other process that should be started).
00:43:01 <maier> dmj`: so upon receiving a command, it needs to start the separate process with certain arguments, and terminate a previously running one (only one allowed at a time)
00:44:02 <maier> using a separate process instead of just doing whatever in the first binary might very well come in handy later, plus it's an experiment to learn about this stuff (go a bit more "low-level").
00:44:42 * hackage recommender-als 0.1.0.0 - Recommendations using alternating least squares algorithm  https://hackage.haskell.org/package/recommender-als-0.1.0.0 (kaol)
00:45:00 <dmj`> maier: sounds cool
00:51:13 <ph88> can i use a quickcheck run with a fixed seed use for my criterion benchmark ? or is this unheard of / bad idea ??
00:52:45 <dibblego> you can with hedgehog; I have also heard that quickcheck has also implemented it.
00:55:37 <ph88> dibblego, how you connect hedgehog to criterion ??
00:57:10 <dibblego> I've never done it
00:58:00 <ph88> o_O then i don't understand your advice
00:58:11 <dmj`> the critterhog package
00:58:27 <dminuoso> Wow curious. One of resource-pool/postgresql-simple/postgresql-lipq/libpq appears to have a bug. Closing a connection does not appear to work completely reliably with these parts fitted together.
00:58:44 <dminuoso> I'm constantly draining the max_connections of my postgres server, and I shouldn't be.
00:59:01 <dmj`> dminuoso: how are you using it
00:59:46 <dminuoso> initPgPool cfg = createPool open Pg.close 1 5 10 where open = Pg.connect (Pg.ConnectInfo (cf_cdb_host cfg) (cf_cdb_port cfg) (cf_cdb_user cfg) (cf_cdb_pass cfg) (cf_cdb_database cfg))
01:00:30 <dminuoso> And then it's just 2 uses of `withResource (env_pg_pool env) $ \conn -> stopSession conn name ses` and `withResource (env_pg_pool env) $ \conn -> startSession conn name ses`
01:00:32 <dminuoso> Nothing more.
01:00:55 <dminuoso> (I have 2 servers running with that, and that's enough to drain the max_connections dry)
01:01:12 <dminuoso> I dont ever pry into the pool anywhere else, or use `open` beyon that.
01:02:09 <dmj`> you should be calling withResource each time
01:02:16 <dmj`> you want to submit a query
01:02:18 <dminuoso> I am.
01:02:25 <dminuoso> These are the *only* places I ever interact with postgres.
01:02:46 <dminuoso> Which is why Im so stunned.
01:03:26 <dmj`> something else is going on
01:03:39 <dmj`> is env_pg_pool getting inlined?
01:03:47 <dmj`> we need more code
01:03:54 <dminuoso> Give me a second
01:04:28 <liiae`> > let anyTwoElemSum x x = if (length x == 2) then [head x + last x] else (fmap (\z -> (head x + z)) (tail y)) <> (anyTwoElemSum (tail x) (tail y)) in anyTwoElemSum [0,1,2,3] [0,1,2,3]
01:04:31 <lambdabot>  error:
01:04:31 <lambdabot>      • Conflicting definitions for ‘x’
01:04:31 <lambdabot>        Bound at: <interactive>:1:19
01:05:34 <liiae`> > let anyTwoElemSum x y = if (length x == 2) then [head x + last x] else (fmap (\z -> (head x + z)) (tail y)) <> (anyTwoElemSum (tail x) (tail y)) in anyTwoElemSum [0,1,2,3] [0,1,2,3]
01:05:36 <lambdabot>  [1,2,3,3,4,5]
01:33:55 <liiae`> f g x y = g x y
01:34:18 <liiae`> g maybe (,) or (+), what's g's type?
01:47:53 <TMA> liiae`: it looks like  g :: a -> b -> c
01:49:29 <liiae`> TMA: right
02:09:30 <liiae`> which function do [[[1,2,3],[2,3]],[[3,5]]] to [[1,2,3],[2,3],[3,5]]?
02:09:43 <liiae`> fmap join ?
02:10:07 <liiae`> foldl1 <> ?
02:11:10 <random> https://hoogle.haskell.org/?hoogle=%5B%5Ba%5D%5D%20-%3E%20%5Ba%5D
02:12:27 <liiae`> concat, right
02:16:02 <dmj`> join is concat for list
02:28:16 <absence> instead of "join $ f <$> a" one can write "f =<< a", but is there a similar way to express "join $ f <$> a <*> b"?
02:34:47 <liiae`> how to get the elements which are most in a list, [1,2,2,3,3,3,4,4,4] the 3 and 4 both show 3 times, get [3,4]
02:36:31 <liiae`> if it's [1,2,2,3,3,3,4,4,4,5,5,5,5] then get [5]
02:38:40 <dmj`> absence: join (liftA2 f a b)
02:40:37 <dmj`> > head $ sortBy (comparing Down) [1..5]
02:40:39 <lambdabot>  5
02:40:40 <dmj`> liiae`: ^
02:41:39 <dmj`> > maximum ([1..5] >>= \x -> [x,x])
02:41:41 <lambdabot>  5
02:41:46 <dmj`> liiae`: ^
02:42:55 <liiae`> dmj`: what about this [[[-1,0,1,2,3,4,5]],[[1,2,3,4,5],[22,23,24,25]],[[1,2,3,4,5],[10,11,12,13,14,15]],[[-1,0,1,2,3],[22,23,24,25]],[[-1,0,1,2,3],[10,11,12,13,14,15]],[[22,23,24,25],[10,11,12,13,14,15]]]? get [[22..25], [10..15]]
02:43:24 <liiae`> sort can't work on list
02:44:25 <dmj`> you're looking for the largest sum of a sublist ?
02:44:34 <liiae`> after concat, we can get [[1,2,3,4,5],[10,11,12,13,14,15],[-1,0,1,2,3,4,5],[1,2,3,4,5],[22,23,24,25],[10,11,12,13,14,15],[-1,0,1,2,3],[10,11,12,13,14,15],[22,23,24,25],[-1,0,1,2,3],[22,23,24,25]]
02:44:53 <dmj`> > maximumBy (compare `on` sum)  [[1,2,3,4,5],[10,11,12,13,14,15],[-1,0,1,2,3,4,5],[1,2,3,4,5],[22,23,24,25],[10,11,12,13,14,15],[-1,0,1,2,3],[10,11,12,13,14,15],[22,23,24,25],[-1,0,1,2,3],[22,23,24,25]]
02:44:55 <lambdabot>  [22,23,24,25]
02:45:07 <liiae`> dmj`: I'm looking the element who has the largest times in alist
02:45:21 <dmj`> > maximumBy (compare `on` product)  [[1,2,3,4,5],[10,11,12,13,14,15],[-1,0,1,2,3,4,5],[1,2,3,4,5],[22,23,24,25],[10,11,12,13,14,15],[-1,0,1,2,3],[10,11,12,13,14,15],[22,23,24,25],[-1,0,1,2,3],[22,23,24,25]]
02:45:23 <lambdabot>  [10,11,12,13,14,15]
02:46:12 <liiae`> in [[1,2,3,4,5],[10,11,12,13,14,15],[-1,0,1,2,3,4,5],[1,2,3,4,5],[22,23,24,25],[10,11,12,13,14,15],[-1,0,1,2,3],[10,11,12,13,14,15],[22,23,24,25],[-1,0,1,2,3],[22,23,24,25]],           [22..25] and [10..15] both show 3 times
02:46:26 <liiae`> others just show once or twice
02:46:49 <liiae`> [1..5] show twice
02:46:59 <liiae`> [10..15] show 3 times
02:47:08 <liiae`> [-1..5] show once
02:47:26 <MarcelineVQ> absence: sure, though it's a little funny looking   f <$> a >>= (b >>=)
02:47:29 <liiae`> [22..25] show 3 times
02:50:54 <liiae`> [[1..5], [10..15], [-1..5], [1..5], [22..25], [10..15], [-1..3], [10..15], [22..25], [-1..3], [22..25]]
02:51:47 <liiae`> can we group the same elements?
02:52:45 <dmj`> liiae`: what is this for?
02:52:53 <dmj`> liiae`: what shows twice?
02:53:13 <lortabac> > group [[1..5], [10..15], [-1..5], [1..5], [22..25], [10..15], [-1..3], [10..15], [22..25], [-1..3], [22..25]]
02:53:15 <lambdabot>  [[[1,2,3,4,5]],[[10,11,12,13,14,15]],[[-1,0,1,2,3,4,5]],[[1,2,3,4,5]],[[22,2...
02:53:35 <liiae`> dmj`: sorry, my English is not good, this [1..5] show twice in [[1..5], [10..15], [-1..5], [1..5], [22..25], [10..15], [-1..3], [10..15], [22..25], [-1..3], [22..25]]
02:53:52 <dmj`> > > fmap (maximumBy (compare `on` sum))  [[[-1,0,1,2,3,4,5]],[[1,2,3,4,5],[22,23,24,25]],[[1,2,3,4,5],[10,11,12,13,14,15]],[[-1,0,1,2,3],[22,23,24,25]],[[-1,0,1,2,3],[10,11,12,13,14,15]],[[22,23,24,25],[10,11,12,13,14,15]]]
02:53:54 <lambdabot>  <hint>:1:1: error: parse error on input ‘>’
02:53:56 <dmj`> > fmap (maximumBy (compare `on` sum))  [[[-1,0,1,2,3,4,5]],[[1,2,3,4,5],[22,23,24,25]],[[1,2,3,4,5],[10,11,12,13,14,15]],[[-1,0,1,2,3],[22,23,24,25]],[[-1,0,1,2,3],[10,11,12,13,14,15]],[[22,23,24,25],[10,11,12,13,14,15]]]
02:53:58 <lambdabot>  [[-1,0,1,2,3,4,5],[22,23,24,25],[10,11,12,13,14,15],[22,23,24,25],[10,11,12,...
02:54:03 <dmj`> > fmap (maximumBy (compare `on` product))  [[[-1,0,1,2,3,4,5]],[[1,2,3,4,5],[22,23,24,25]],[[1,2,3,4,5],[10,11,12,13,14,15]],[[-1,0,1,2,3],[22,23,24,25]],[[-1,0,1,2,3],[10,11,12,13,14,15]],[[22,23,24,25],[10,11,12,13,14,15]]]
02:54:05 <lambdabot>  [[-1,0,1,2,3,4,5],[22,23,24,25],[10,11,12,13,14,15],[22,23,24,25],[10,11,12,...
02:54:26 <dmj`> liiae`: is this for school?
02:55:13 <liiae`> dmj`: this is for a part of another question
02:55:33 <maerwald> which is for school? :p
02:56:02 <liiae`> yes
02:58:41 <dmj`> liiae`: well then its important you gain an intuition for how things work
02:58:42 * hackage souffle-haskell 1.0.0 - Souffle Datalog bindings for Haskell  https://hackage.haskell.org/package/souffle-haskell-1.0.0 (luc_tielen)
02:58:56 <dmj`> liiae`: we can ask you questions to help direct you to the solution
02:59:45 <dmj`> liiae`: which school in Beijing?
03:00:09 <liiae`> dmj`: just codewars, not really in school
03:00:27 <dmj`> liiae`: ok
03:01:48 <liiae`> dmj`: the original https://www.codewars.com/kata/52b7ed099cdc285c300001cd
03:02:53 <liiae`> dmj`: so far I got https://paste.ubuntu.com/p/GKnPcP7Hp2/
03:03:23 <liiae`> just one last step I can solve this question
03:03:51 <liiae`> I need those elements which show the most times in a list
03:05:53 <dmj`> > sum (concat [[1,3],[4,5]])
03:05:55 <lambdabot>  13
03:18:23 <dminuoso> dmj`: https://gist.github.com/dminuoso/80b7fbc8b25c7ffb89f8d3b069644ef2
03:19:03 <dminuoso> This is an extraction of the relevant code paths. There's no usages of unsafe* primitives, there's no multiple PG pools.
03:19:25 <dminuoso> And there's no threading *around* it, that is the pool is initialized once at the beginning in the main thread, and then the env is shared in threads.
03:20:42 <dminuoso> The situation that "triggered" the problem was that the SQL queries have been getting slower constantly because of lacking indices, so the connections were not placed back into the pool instantly.
03:20:52 <dminuoso> (it wasnt really the source of the problem, just what made it more apparent)
03:21:48 <dminuoso> Either there's a bug in resource-pool, or postgresql-simple is not closing a connection properly.
03:22:42 <dminuoso> I dont see how I could consume more than 20 connections (I have two servers for this).
03:23:34 <kiwi_45> anyone here would like to help me on how to work with cookies and servant-auth ? I was developing my web app in haskell in my free time, but now I again stuck at one point authentication with servant-auth , the program is compiling and I was able to follow the given tutorial but I’m finding my self unable to proceed i.e its not working with
03:23:34 <kiwi_45> browser when I try to access my endpoints I can’t, I also tested with curl on @masser’s advice, when I try to login it sets the cookie headers but next time when I try to access the content then nothing again. here is my code : 
03:23:35 <kiwi_45> https://github.com/DeepakKapiswe/Gyan-Lahari-Backend/blob/redisIntegration/src/Adapter/HTTP/Server.hs
03:23:35 <kiwi_45> can someone please help me out this ?
03:23:36 <kiwi_45> I don’t know what to do even what to look for !
03:23:36 <kiwi_45> I followed this : https://github.com/haskell-servant/servant-auth#readme
03:32:22 <dmj`> kiwi_45: are your cookie settings set to HttpOnly
03:32:35 <dmj`> liiae`:  sum $ map (\[x,y] -> y - x) $ foldl' (\([x,y]:xs) [a,b] -> if y > a then [x,b]:xs else [[x,y],[a,b]] ++ xs) [head (s xs)] (tail (s xs))
03:32:44 <dmj`> s = sortBy (compare `on` (!!0)
03:37:11 <kiwi_45> dmj`: thanks for responding, well I'm not sure from where to set but my looking says no ```cookieSettings = defaultCookieSettings {cookieIsSecure = NotSecure, cookieXsrfSetting = Nothing}```
03:38:18 <kiwi_45> dmj`: https://github.com/DeepakKapiswe/Gyan-Lahari-Backend/blob/9b6c5b5b96f3c39c998afc4cbf677107073d68a6/src/App.hs#L46
03:42:41 <kiwi_45> if possible for someone please look in to my issue
03:52:54 <MarcelineVQ> > last . groupBy ((==) `on` snd) . sortOn snd . M.toList . M.fromListWith (+) . flip zip [1,1..] $ [1,1,1,2,3,4,4,5,6,6,5,6,5] -- hmm
03:52:56 <lambdabot>  [(1,3),(5,3),(6,3)]
03:54:52 <kiwi_45> sorry I got disconnected  how can I see if someone has replied to my msgs while I was disconnected ? 
03:56:04 <MarcelineVQ> there's logs in the topic though I've not looked at them so dunno how quick they are. no one replied since you spoke with dmj`
03:56:32 <dmj`> kiwi_45: when you set a cookie, it becomes present on all subsequent requests
03:57:27 <dmj`> kiwi_45: I would not use JWTs
03:57:32 <kiwi_45> dmj`:  thats what I thought will happen but when I do subsequent curl request still I'm not able to access
03:57:45 <dmj`> kiwi_45: curl won't persist the cookie, the browser will
03:57:47 <kiwi_45> and how to use it with browser
03:58:03 <dmj`> kiwi_45: use the cookie package instead
03:58:05 <dmj`> @package cookie
03:58:06 <lambdabot> https://hackage.haskell.org/package/cookie
03:58:13 <kiwi_45> I copy manually and provide as a bearer token with curl
03:58:14 <dmj`> it has HttpOnly
03:59:01 <dmj`> kiwi_45: cookies are created moreso to be used in the browser, for cli tools I'd use a config file that has an API key
03:59:03 <kiwi_45> but I think I might be missing something, I understood things but I'm missing too 
03:59:21 <kiwi_45> I have to fetch the data to browser mainly
04:00:04 <kiwi_45> I used servant-auth on advice by guys here
04:00:12 <dmj`> kiwi_45: you should set 2 cookies, one that is hidden behind httpOnly and secure = true, a second cookie that the browser can check to see if the user is authenticated. Let the server remove the cookies to log the user out
04:00:46 <Marked> Hello! I have question I cannot find solution on web. I want to return value from main function. In C it would be
04:01:17 <dmj`> Marked: what value would you like to return?
04:01:18 <Marked> int main(int argc, char** argv) {return 5;}
04:01:27 <kiwi_45> dmj`: the tutorial mentions you have to use jwt to use cookie
04:01:33 <Marked> Just number in unix it is for error code
04:01:35 <dmj`> kiwi_45: that's a lie
04:01:59 <kiwi_45> dmj`: :)))))))))
04:02:09 <dmj`> Marked: https://hackage.haskell.org/package/base-4.14.0.0/docs/System-Exit.html#v:exitWith
04:02:15 <Marked> When you compile it in unix and run     ./program.out; echo $? will print 5
04:02:31 <kiwi_45> dmj`: what should I do now ?
04:02:55 <Marked> Oh thanks
04:03:24 <dmj`> kiwi_45: you do as I tell you, use the cookie package since servant auth lacks HttpOnly it seems
04:04:02 <dmj`> kiwi_45: you are going to need to make a session token that you store in the cookie, this can be a UUID for now or anything really, some people use JWTs for this, but meh. 
04:04:42 <dmj`> kiwi_45: Cookies with HttpOnly using Https (is secure), is a good first step
04:08:28 <frobnicator> where can I find the implementation of the generic machinery behind show, many GShow's show up when searching for gshow
04:09:39 <phadej> it's built in into compiler
04:10:09 <phadej> i.e. there isn't generic (as in GHC.Generic) machinery
04:10:42 * hackage pandoc-plot 0.7.2.1 - A Pandoc filter to include figures generated from code blocks using your plotting toolkit of choice.  https://hackage.haskell.org/package/pandoc-plot-0.7.2.1 (LaurentRDC)
04:11:19 <phadej> there is mimicing template haskell implementation in https://hackage.haskell.org/package/deriving-compat though
04:12:13 <frobnicator> why is this. Is the generic m achinery in ghc not powerful enough? or is the outcome not fast enough?
04:12:40 <Marked> I heard, haskell is able to produce .c code I would like to inspect. When I execute 'ghc -C main.hs' I got error 'the option -C is only available with an unregisterised GHC'. What to do now?
04:14:05 <dmj`> Marked: you'd need to build an unregistered ghc, compiling to C is deprecated and kept only for bootstrapping new GHCs
04:14:16 <dmj`> for bootstrapping GHC on new architectures*
04:14:24 <dminuoso> Mmm, there's no circular TBQueue around is there?
04:14:41 <dmj`> dminuoso: I'd look for a ring buffer package
04:14:42 * hackage these 1.1.1 - An either-or-both data type.  https://hackage.haskell.org/package/these-1.1.1 (phadej)
04:15:13 <dmj`> @package ring-buffer
04:15:13 <lambdabot> https://hackage.haskell.org/package/ring-buffer
04:15:37 <phadej> frobnicator: deriving Show is much older (in standard) than GHC.Generics
04:16:13 <frobnicator> phadej: thanks
04:17:41 <Marked> dmj` So I have to build ghc myself right? Why was it deprecated? Is compiling to C not optimal? Isn't it better to let GCC do compilation? I would like to use musl instead of glibc, also I would like to compile cross compile for other OS and archs.
04:18:26 <dminuoso> dmj`: Mmm ah that package looks sleek.
04:19:14 <dmj`> Marked: then you're better off using nix to build GHC, since it has cross compilation support setup out of the box, and a cached working musl toolchain
04:19:17 <dmj`> for GHC
04:19:20 <phadej> Marked: https://gitlab.haskell.org/ghc/ghc/-/wikis/building/unregisterised
04:19:34 <Athas> Marked: compiling to C is not optimal, because well-performing Haskell requires code patterns that cannot be expressed in C.
04:19:37 <Marked> phadej Thanks
04:20:10 <Athas> GHC used to do horrible things like generate C, compile that C to assembly, and then use a Perl script to improve the generated assembly.
04:21:24 <hc> OMG :)
04:22:00 <dminuoso> Athas: Oh boy, where/when can I find that perl script?
04:22:05 <dminuoso> I'd love to take a look at that dirt.
04:22:10 <hc> yeah please, I'd like a copy of that as well :)
04:23:03 <dmj`> I would not like a copy
04:24:09 <dminuoso> It'd be good as a cenotaph. A reminder for the next generation how to not do it.
04:25:20 <Athas> dminuoso: it was called the "Evil Mangler".
04:25:24 <Athas> It think you can find many references online.
04:25:41 <Athas> https://gitlab.haskell.org/ghc/ghc/-/wikis/commentary/evil-mangler?version_id=ec1a674f97d61bcc04040c53a2adb2a0b13a1e5c
04:25:54 <hc> thanks! :)
04:26:30 <Athas> It was pretty infamous, but removed many years ago.
04:27:39 <merijn> The evil mangler is from the C backend days
04:28:00 <merijn> I think it still exists, but only for unregisterised C based builds? i.e. when bootstrapping new architectures
04:28:08 <dmj`> was he truly evil or just misunderstood?
04:28:24 <Athas> It was badly written, even for Perl, and its purpose was unspeakably ugly.
04:28:25 <merijn> dmj`: Well, definitely "the utterly disgusting mangler"
04:28:31 <Athas> So it was nasty in both body and soul.
04:28:49 <dminuoso> Ah beautiful, Im looking at it now
04:29:06 <dmj`> but he served a noble purpose
04:29:31 <dminuoso> The mighty GHC authors wielded perl regexes as if they were grand masters.
04:29:35 <dminuoso> So many regexes here..
04:31:52 <phadej> https://gitlab.haskell.org/ghc/ghc/-/blob/6_10_branch_has_been_forked/driver/mangler/ghc-asm.lprl
04:32:15 <phadej> some version of it
04:33:21 <Athas> Always good when you see a Perl script with a comment like "HPPA specific notes".
04:36:42 * hackage readability 0.1.0.0 - Extracts text of main article from HTML document  https://hackage.haskell.org/package/readability-0.1.0.0 (geyaeb)
04:38:22 <f-a> I am getting this strange — for me — error while cabal building an executable http://www.ariis.it/link/t/paste2689-0
04:38:53 <merijn> f-a: Looks like a missing library
04:39:30 <merijn> f-a: Is nievo your package?
04:40:21 <f-a> yes, it has both a library part and an executable one (the one which I am building) http://www.ariis.it/link/t/nievo.cabal
04:41:10 <merijn> f-a: Try completely nuking dist-newstyle
04:41:36 <phadej> I'd guess that some module is no in exposed-modules
04:41:41 <merijn> ooh!
04:41:47 <merijn> That's a good catch
04:42:31 <merijn> phadej: Actually, I think I see what's going on
04:42:39 <dmj`> f-a: are you missing some modules in your cabal file?
04:42:43 <f-a> ah of course I forgot to add it. Let us see if this work…
04:42:43 <merijn> No hs-source-dir
04:43:00 <Marked> Thank you guyz.. for info about compiling to C...
04:43:17 <dmj`> Marked: yw
04:43:26 <merijn> f-a: You have the same directory with both the library AND executable sources, don't you?
04:43:56 <f-a> no merijn , the executable is a single file in ., library is in src/
04:44:02 <f-a> indeed I forgot to add a module
04:44:09 <f-a> thanks everyone for diagnosing
04:44:10 <merijn> ah, wait
04:44:18 <merijn> there was 2 hs-source-dir entries
04:44:26 <merijn> One commented out and one not :)
04:57:27 <absence> MarcelineVQ: that <$> >>= thing is interesting, thanks :)
05:00:57 <MarcelineVQ> it's not   f something a something b   anymore but you can also write  a >>= (b >>=) . f
05:01:51 <reactormonk> What's the equivalent of `#include <valgrind/valgrind.h>` in a cabal includes: statement?
05:02:47 <merijn> reactormonk: You're going to have to elaborate what you mean
05:04:57 <reactormonk> merijn, sure. My goal is to get this to run: foreign import capi "<valgrind/valgrind.h> RUNNING_ON_VALGRIND" rUNNING_ON_VALGRIND :: IO CInt -- but since I can't have <valgrind/valgrind.h> there (it automatically puts it into ""), I was looking for the way via cabal. I don't know the correct syntax via cabal though. For comparison, this file compiles in C: #include <valgrind/valgrind.h>; main = 0
05:04:59 <reactormonk> (just as a test)
05:05:28 <merijn> foreign imports contain the path to the .h file
05:05:34 <merijn> There's no need for < >
05:06:04 <reactormonk> Nice, thanks!
05:07:54 <reactormonk> https://gist.github.com/reactormonk/063ac2d2cc67099f4fe86e21b7c4b0fb Huh, tries to it. Isn't really a number. Can I ask GHC not to?
05:08:02 <reactormonk> Ehh, it's a number, not a function.
05:08:31 <kiwi_45> please help ! anyone here would like to help me on how to work with cookies and servant-auth ? I was developing my web app in haskell in my free time, but now I again stuck at one point authentication with servant-auth , the program is compiling and I was able to follow the given tutorial but I’m finding my self unable to proceed i.e its not
05:08:32 <kiwi_45> working with browser when I try to access my endpoints I can’t, I also tested with curl on @masser’s advice, when I try to login it sets the cookie headers but next time when I try to access the content then nothing again. here is my code : 
05:08:32 <kiwi_45> https://github.com/DeepakKapiswe/Gyan-Lahari-Backend/blob/redisIntegration/src/Adapter/HTTP/Server.hs
05:08:33 <kiwi_45> can someone please help me out this ?
05:08:33 <kiwi_45> I don’t know what to do even what to look for !
05:08:34 <kiwi_45> I followed this : https://github.com/haskell-servant/servant-auth#readme
05:09:41 <merijn> reactormonk: I recommend reading the user guide on the CApiFFI
05:10:06 <merijn> reactormonk: Because your import is wrong, you need "value" in there for importing macros as values
05:10:23 <boxscape> hm, is the whole "fmap preserves the structure of a container" thing a fact about Data.Functor rather than about functors in general? Since it seems like 1. You can make Set a lawful instance of Functor if you change the class a bit and 2. It doesn't seem to preserve the structure
05:10:29 <reactormonk> merijn, yup, thanks.
05:16:56 <boxscape> oh, but wait; I think the fmap (f . g) == fmap f . fmap g law implies that structures are preserved, so I guess that's can't actually be a lawful functor
05:17:43 <boxscape> hm, although actually I'm not entirely sure that's true
05:20:51 <merijn> boxscape: It's true *in haskell*
05:21:03 <boxscape> okay
05:21:21 <boxscape> (my reasoning why the second law would imply preservation of structure was flawed, incidentally)
05:21:23 <merijn> boxscape: You need both functor laws to guarantee this in category theory, but in Haskell specifically, you can derive each functor law from the other
05:22:01 <merijn> (due to the type system, see "Theorems for Free!")
05:22:52 <boxscape> merijn so, if you change the class to be able to have Set be a Functor (as in https://hackage.haskell.org/package/freelude-0.3.2.0/docs/Freelude.html#Functor ), you don't get that for free anymore - but does that mean you can't derive it either, for Set, since Set doesn't preserve structure? Since `fmap (f . g) == fmap f . fmap g` doesn't seem
05:22:52 <boxscape> obviously wrong to me in that casse
05:23:33 <boxscape> hm actually my link doesn't point to a definition of Functor
05:23:47 <boxscape> https://hackage.haskell.org/package/freelude-0.3.2.0/docs/Freelude-Impl-ExoFunctor.html
05:23:57 <absence> what should the rts option -N be set to when running in kubernetes and the default -N is something like 128 cores?
05:24:00 <merijn> I'm to fuzzy brained to look at anything with module names like that ;)
05:24:09 <boxscape> fair enough :)
05:25:20 <boxscape> oh actually this edkmett comment states what you need to have a lawful instance for Set https://dorchard.blog/2011/10/18/subcategories-in-haskell-exofunctors/#comment-142
05:26:01 <boxscape> namely x == y => f x == f y
05:27:32 <boxscape> (and possibly a couple more assumptions about Ord specifically)
05:34:24 <boxscape> I guess a law for preserving structure would be something like "forall a b c f (g :: forall e . f e -> c) (h :: a -> b) (fx :: f a) . g fx == g (fmap h fx)"
05:34:33 <boxscape> (g could be something like length, for example)
05:34:44 <boxscape> which I don't *think* is something that arises form the functor laws
05:34:58 <boxscape> (except if you use Data.Functor, probably)
05:35:15 <kiwi_45> no help :(
05:41:56 <boxscape> ah, it seems that the proper way to phrase this is that g has to be a natural transformation
05:42:08 <boxscape> which you get for free with usual Haskell Functors and polymorphic functions
05:46:35 <kiwi_45> okay I leave
05:49:04 <MarcelineVQ> oh, I wonder if he dc'd when dmj` was telling him what to do
06:22:42 <frdg> what is a Builder in reference to Blaze.ByteString.Builder.Char.Utf8?
06:23:18 <phadej> my guess it's Data.ByteString.Builder
06:24:30 <frdg> found it thanks
06:30:09 <demon_in_a_jar> is there any recursion scheme that can efficiently handle recurrences of the form: f(n) = f(n-1) + f(n/2) ?
06:31:31 <pong> memo it or something
06:32:04 <demon_in_a_jar> I know just wondering if it's possible to do the memoization by using a recursion scheme
06:32:22 <demon_in_a_jar> using histomorphisms is probably not powerful enough for this
06:36:00 <pong> doesn't a "histomorphism" give you all previous values so including n/2?
06:37:01 <demon_in_a_jar> yes but retrieving them requires a linear traversal
06:37:14 <demon_in_a_jar> so it works fine for the simple fibonacci example
06:37:26 <demon_in_a_jar> or even for the catalan numbers since they require all previous numbers anyway
06:37:48 <demon_in_a_jar> conveniently they are the only examples provided for histomorphisms
06:37:50 <amf> is there something like mapAccumL but has a Monad constraint?
06:38:12 <phadej> demon_in_a_jar: yes, you can write such scheme by hand
06:38:37 <phadej> :t mapAcccumL
06:38:38 <lambdabot> error:
06:38:39 <lambdabot>     • Variable not in scope: mapAcccumL
06:38:39 <lambdabot>     • Perhaps you meant one of these:
06:38:43 <phadej> :t Data.List.mapAcccumL
06:38:44 <lambdabot> error:
06:38:44 <lambdabot>     Not in scope: ‘Data.List.mapAcccumL’
06:38:44 <lambdabot>     Perhaps you meant one of these:
06:38:46 <phadej> :(
06:39:02 <phadej> amf: every Monad is Applicative, so you cn use mapAccumL with monads
06:39:11 * hackage haxr 3000.11.4.1 - XML-RPC client and server library.  https://hackage.haskell.org/package/haxr-3000.11.4.1 (BrentYorgey)
06:39:50 <amf> i know, but that isn't handled by `mapAccumL :: Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)` (unless i missed something)
06:42:09 <phadej> ah, that
06:42:15 <phadej> use WriterT
06:42:26 <phadej> err. StateT
06:42:34 <phadej> mapAccumL is traverse over State
06:42:36 <phadej> essentially
06:43:28 <amf> ah ha! thats the key i was missing, thanks phadej!
06:43:42 * hackage mr-env 0.1.0.4 - A simple way to read environment variables in Haskell  https://hackage.haskell.org/package/mr-env-0.1.0.4 (meowgorithm)
06:45:27 <demon_in_a_jar> hmm I think that the linear traversal can be amortized constant
06:55:45 <phadej> demon_in_a_jar: You can write a function, fibscheme :: a -> a -> (a -> a -> a) -> Natural -> a, using which fib = fibscheme 1 1 (+)
06:55:51 <phadej> and you can be smart implementing it
06:56:17 <phadej> but there usually aren't such ready made function for "exotic" recursion schemes (patterns)
07:37:20 <dmwit> demon_in_a_jar: Let me turn it around on you. Can you design a data structure for representing numbers such that `n-1` and `n/2` are both efficiently-reachable subterms of `n`?
07:37:35 <dmwit> (I don't see an obvious way, but then, there's an awful lot of ways of representing numbers.)
07:39:06 <phadej> data N = N0 | N1 | NN N N, with NN (NN x) y -> x == y "extra identity" requirement
07:39:21 <phadej> i.e. you cannot represent that in Haskell, but on paper that's fine.
07:39:25 <int-e> . o O ( data N = N { value :: Integer, predecessor :: N, half :: N } )
07:39:55 <dmwit> int-e: Sure, but then you actually want some kind of graph, not a tree, so that e.g. (n-1)/2 and n/2 are shared when n is odd.
07:40:13 <int-e> dmwit: sure. also I'm not quite serious, in case that wasn't obvious
07:40:16 <dmwit> Otherwise your recursion scheme will (have to) recompute f((n-1)/2).
07:40:48 <dmwit> phadej: I don't understand your reply.
07:41:00 <dmwit> In particular NN (NN x) y doesn't appear well-typed.
07:42:57 <dmwit> int-e: Although I think with a bit of library support, that could be made to work sensibly.
07:43:43 <dmwit> The in-memory representation of 100 (say) is kind of big though. ^_^
07:43:55 <shadow__> welp
07:44:16 <dmwit> Like multiple kilobytes instead of the 8 bytes storing a number traditionally takes...
07:45:10 <int-e> dmwit: Just imagine following the chain of predecessors... that makes it obvious that this is a terible idea. :)
07:46:50 <int-e> But of course in the case of such a recursion scheme where you have to visit all predecessors anyway this may not be so bad.
07:47:18 <random_> hey guys, does anyone know if you can get a ClaimsSet out of a JWT without having the secret using jose?
07:47:54 <dmwit> random_: mischan, maybe?
07:48:19 <random_> dmwit: what do you mean by mischan
07:48:25 <phadej> dmwit: you should permit some typos in conversations, you are human, not a machine ;) https://gist.github.com/phadej/6ce1b76b1cea1a1b87a80cb2db659b99
07:48:47 <dmwit> phadej: I correct what typos I can. When I cannot, I complain.
07:49:07 <phadej> NN (NN x _) y -> x == y
07:49:31 <dmwit> FWIW, just staring at the corrected requirement I almost certainly still would not have understood.
07:49:51 <dmwit> I won't take the time to boil it down to the smallest thing I don't understand, though, since now there's code to pore over anyway. ^_^
07:50:11 <Lycurgus> pour
07:50:20 <dmwit> phadej: Oh, I think you are the one who's misunderstood!
07:50:28 <dmwit> phadej: The goal is n-1 and n/2, not n-1 and n-2!
07:50:44 <phadej> well, it's "easy" to change to n-1 and n/2
07:50:57 <dmwit> Yes, and when you do you get to int-e's suggestion, and my comments about that still apply.
07:51:01 <Lycurgus> ha, wrong again
07:51:02 <dmwit> It was the first thing I thought of, too.
07:51:10 <demon_in_a_jar> @int-e basically the reason that catalans are a nice example when using histomorphisms
07:51:10 <lambdabot> Unknown command, try @list
07:51:20 <int-e> > let foo g f0 = fix (\xs -> f0 : g f0 f0 : go xs xs) where go (x:xs) (y:z:ys) = g x y : g x z : go xs ys in foo (+) 1
07:51:22 <lambdabot>  [1,2,2,3,4,5,6,7,9,10,13,14,18,19,24,25,31,32,40,41,50,51,63,64,77,78,95,96,...
07:52:18 <phadej> though n/2 is ill-defined
07:52:21 <int-e> > let foo g f0 = fix (\xs -> f0 : go xs xs) where go (x:xs) (y:z:ys) = g x y : g x z : go xs ys in foo (+) 1
07:52:24 <lambdabot>  [1*Exception: <<loop>>
07:52:27 <dmwit> phadej: never mind, so is n-1
07:52:38 <int-e> > let foo g f0 = fix (\xs -> f0 : go xs xs) where go (x:xs) (y: ~(z:ys)) = g x y : g x z : go xs ys in foo (+) 1 -- meh
07:52:39 <lambdabot>  [1,2,3,5,7,10,13,18,23,30,37,47,57,70,83,101,119,142,165,195,225,262,299,346...
07:53:14 <phadej> though n-1 already fixes the n, os I guess n/2 can be floored one
07:53:46 <dmwit> (Anyway the usual peano nats already have n-1 and n-2 as efficiently-reachable subterms, so that problem doesn't even need solving.)
07:54:39 <dmwit> One possibility would be `data Nat = Zero | Succ Nat | Twice Nat` with the invariant that `Succ` never appears twice in a row.
07:54:41 <int-e> > fix (\xs -> 1 : zipWith (+) xs (xs >>= replicate 2)) -- ah, this is how to do it properly
07:54:43 <lambdabot>  [1,2,3,5,7,10,13,18,23,30,37,47,57,70,83,101,119,142,165,195,225,262,299,346...
07:55:00 <demon_in_a_jar> that may work
07:55:34 <dmwit> int-e: beautiful!
07:55:47 <phadej> dmwit: that will have different scheme, you'll get (a {- n-1 -} -> a) -> (a {- n/2 -} -> a) -> .. not (a {- n-1 -} -> a {- n/2 -} -> a)
07:56:05 <dmwit> phadej: A histomorphism will give you the n-1 and n/2 answers efficiently.
07:56:22 <dmwit> phadej: The complaint about histomorphism+peano nat is that n/2 is reachable, but at linear cost.
07:56:25 <int-e> > fix (\xs -> 1 : zipWith (+) xs (tail $ xs >>= replicate 2)) -- or maybe this
07:56:28 <lambdabot>  [1,2,4,6,10,14,20,26,36,46,60,74,94,114,140,166,202,238,284,330,390,450,524,...
07:56:43 <dmwit> ah
07:56:49 <int-e> oh well, lots of nobs to tweak.
07:56:53 <dmwit> No, a histomorphism won't give you n-1 for even numbers with this representation.
07:56:56 <dmwit> Whoops.
07:57:49 <dmwit> ok ok, I have a cunning plan
07:58:55 <dmwit> ...my cunning plan has the same sharing problems as int-e's. oops
08:00:14 <int-e> Try a sequence of bits in run-length encoding.
08:01:04 <hseg> writing a testcase for some algebraic operations, want to title the case by the identity to be satisfied. but that leads to code like let x ⊕ y = x ++ op ++ y in "x" ⊕ "(y" ⊕ "z) == (x" ⊕ "y)" ⊕ "z)"
08:01:15 <hseg> is there a nicer way of writing this type of things?
08:01:18 <AWizzArd> How to translate a lazy Text into a strict one?
08:01:47 <ja> AWizzArd: http://hackage.haskell.org/package/bytestring-0.10.10.1/docs/Data-ByteString-Lazy.html#v:toStrict
08:01:54 <ja> oh wait, you said text, sorry
08:02:12 <int-e> (you can always decrement by looking at the least significant three runs of bits of a number, and divide by two looking at the last two runs)
08:02:20 <ja> https://hackage.haskell.org/package/text-1.2.4.0/docs/Data-Text-Lazy.html#v:toStrict
08:02:36 <ja> AWizzArd: there it is
08:02:41 <AWizzArd> Danke!
08:02:42 <hseg> crazy thought, use a free f-algebra on F a = Bin a a and do two evaluations of it
08:02:57 <hseg> with renderer also getting names
08:06:30 <demon_in_a_jar> maybe something corecursive like 
08:06:48 <demon_in_a_jar> data Nat0 = NZero | NDouble (Nat1)
08:06:50 <demon_in_a_jar> data Nat1 = NSucc Nat0
08:07:31 <demon_in_a_jar> nah that won't work
08:15:08 <dmwit> phadej, int-e, demon_in_a_jar: https://gist.github.com/dmwit/2b13d2d47b8ec6cef4beabe3cac36224 (but yeah, observable sharing needed for a sensible recursion scheme)
08:17:12 <phadej> succ makes even numbers from Zero or Twice?
08:17:50 <dmwit> All odd numbers start with Succ; as an invariant, the pattern Succ (Succ _) never matches.
08:18:37 <phadej> binary numbers, https://hackage.haskell.org/package/bin, are close, but they have different scheme
08:18:52 <phadej> you cannot get pred of B0 efficiently
08:19:01 <dmwit> Yes, the innovation of this type is efficient pred.
08:19:19 <dmwit> (half and pred both)
08:19:37 <dmwit> At the cost of less-efficient `twice`.
08:20:03 <phadej> though, pred for B0 is log2 n, so it's not inefficient
08:20:24 <phadej> https://hackage.haskell.org/package/bin-0.1/docs/src/Data.Bin.html#predP
08:20:42 <dmwit> phadej: The important thing is that pred gives a subterm. For the usual binary numbers, pred is a computed thing that is not necessarily a subterm.
08:21:22 <dmwit> It is slightly surprising that we can shift the log2 cost to twice and get that property.
08:21:44 <dmwit> (the important thing for using a recursion scheme, I mean)
08:22:10 <phadej> yes, but the invariant is ugly. No Twice Zero, nor Succ (Succ _)
08:22:14 <dolio> This conversation is an example of why you shouldn't bother trying to shoehorn things into 'recursion schemes'. :þ
08:22:57 <hseg> spooky. was just about to ask about recursion schemes
08:22:58 <phadej> I started this by saying that you **can** write a -> (a -> a -> a) -> Natural function
08:23:09 <phadej> whether it's recursion-scheme for some ADT is not important
08:23:13 <phadej> Natural -> a...
08:24:13 <hseg> q: i have a bunch of related recursive types i'd like to use with recursion-schemes. any way to avoid duplication?
08:24:21 <dmwit> (The invariant is even more complicated than that. Twice x y must have s x = twice y = Twice x y.)
08:24:39 <demon_in_a_jar> sure thing, this can probably be done much easier with some memoization, was just interested in the a pure way that can be generalized for other such problems
08:25:49 <phadej> writing functions us already quite general :)
08:26:11 <hseg> specifically, want the fixpoints of the functors corresponding to algebras of signatures (2),(0,2),(0,1,2),(0,0,2,2),(0,0,1,2,2) respectively
08:27:03 <phadej> hseg: have you looked at data types ala carte?
08:27:22 <hseg> sure, i guess i could use GHC.Generics
08:27:49 <phadej> i dont think you can improve on that a lot, even with using more recent fancyness in GHC
08:27:51 <hseg> and write sth like this http://ix.io/2rhc
08:28:03 <hseg> plus some patterns to make this sane
08:28:25 <phadej> trees that grow is another related pattern
08:28:27 <hseg> is this a good way of proceeding, or have i misunderstood sth?
08:29:13 <hseg> oh right
08:30:30 <hseg> think data a la carte works better here
08:33:29 <hseg> hrm. figuring out the patterns is annoying. especially in that in the design i shared above, pretty much no pattern can be shared
08:34:27 <hseg> hrm. what would this look like under trees that grow?
08:36:49 <hseg> sth like data Bin r = Bin r r; type SGpF' r t = Bin r :+: t, type MonF' r t = SGpF' r (() :+: t), type GrpF' r t = MonF' r (Id :+: t) ?
08:37:33 <hseg> and then type SGpF r = SGpF' r (), type MonF r = MonF' r (), ...
08:37:35 <hseg> ?
08:43:11 <hseg> heh. using the trees that grow approach, my patterns become peano-encoded indeces into the constructors
08:54:46 <hseg> q: given that i have the above tower, how do i define SRng r = Mon (SRng r) :+: Mon (SRng r), Rng r = Grp (Rng r) :+: Mon (Rng r) without too much boilerplate? 
08:56:03 <hseg> hrm. *could* view Mon->Grp and Srng->Rng as being extensions by Id:+:
08:59:24 <hseg> needs more thought 
09:16:33 <demon_in_a_jar> https://gist.github.com/liarokapisv/da16ae4fd5af7fe19c4c723d6c2b6a06
09:22:42 * hackage warp-systemd 0.1.1.0 - Socket activation and other systemd integration for the Warp web server (WAI)  https://hackage.haskell.org/package/warp-systemd-0.1.1.0 (RobertHensing)
09:36:54 <hseg> yeah, so basically looks like i want: OneOp r e1 = Bin r r | OneExt e1, TwoOp r e1 e2 = O1 (OneOp r e1) | O2 (OneOp r e2), ... and have a collection of extensions for OneOp 
09:38:05 <hseg> (note this is basically semi-dual to ttg -- i'm viewing my expression type as a sum of sums, and am trying to extend individual subsums
09:38:44 <hseg> in contrast, ttg sees expressions as sums of products, and extends them by adding factors/global terms)
09:53:39 <hseg> hrm. actually that can be made to work in the ttg paradigm by having empty payloads and having the entirety of each branch be given by extensions
10:03:59 <Shiranai> Hello, how can I make my program read the config from a .hs file? I know Xmonad does that but how does something like that even work?
10:04:24 <L29Ah> Shiranai: ghc --make
10:04:25 <Shiranai> If I compile my program, I can no longer link it to a .hs, and I know Xmonad isn't recompiling every single time
10:04:36 <L29Ah> Shiranai: xmonad is just installed as a library
10:04:49 <L29Ah> and a program that compiles your "config"
10:04:54 <L29Ah> that's in fact a regular haskell program
10:04:59 <L29Ah> so it just calls ghc
10:05:13 <dsal> Shiranai: xmonad is a program you write.
10:05:42 <dsal> Pretty clever how it makes it look like it's interpreting a config file.
10:06:33 <Shiranai> I am sorry but I am not understanding how it works. What does it mean that xmonad is installed as a library, it is not running a compiled version?
10:06:44 <L29Ah> libraries are compiled
10:07:13 <L29Ah> but they aren't runnable, they just export some functions for others to use
10:07:45 <Shiranai> so the 'config' is actually the program I write and use xmonad as a library?
10:07:50 <L29Ah> yes
10:08:02 <Shiranai> damn that's crazy as hell lol, pretty clever
10:08:16 <Shiranai> so I do have to recompile my config everytime?
10:08:22 <L29Ah> yes
10:08:32 <L29Ah> if it's changed
10:08:50 <Shiranai> aight thanks, hadn't use it before but read some good things about it, sadly stucked on WSL for now
10:09:18 <L29Ah> you can just grab xmonad's code for that, as it deals with compiled binary caching for you
10:11:55 <dsal> Shiranai: You don't recompile the config, you build an entirely new xmonad binary.
10:12:16 <Zemyla> I thought of two ways to semi-transparently turn a functor with a nominal parameter into a value with a representational parameter.
10:12:48 <Shiranai> dsal: isn't that slow as hell though?
10:13:08 <dsal> It only does it when you change configs.  Otherwise, it's just a program.
10:13:31 <L29Ah> Shiranai: takes a few seconds on my shitty laptop
10:13:49 <Zemyla> newtype RepYoneda f a = RepYoneda { unRepYoneda :: forall b. Coercible a b => f b }
10:13:49 <L29Ah> and my config is huge
10:14:34 <Zemyla> data RepCoYoneda f a where RepCoYoneda :: Coercible a b => f b -> RepCoYoneda f a
10:16:48 <Zemyla> The second one should also be doable as a newtype, though, because a Coercible dictionary is zero size.
10:19:02 <Shiranai> dasl: aight thanks, I'll try that approach for my software
10:20:08 <dsal> Shiranai: I've still never needed that much power.  Most of the time, I just make a quick language to express my things.  Furthest I've gone is dhall.
10:23:42 * hackage dobutokO-effects 0.7.0.0 - A library to deal with SoX effects and possibilities  https://hackage.haskell.org/package/dobutokO-effects-0.7.0.0 (OleksandrZhabenko)
10:24:28 <jumper149> Would you say it's correct to call a stack of ReaderT isomorphic to IdentityT?
10:26:04 <nil> jumper149: Reader r isn't isomorphic to Identity
10:26:44 <hseg> ok, so this is my wip ttg version of a free algebraic tower http://ix.io/2rhK -- any way i can unify E and E' ?
10:27:56 <nil> (well, it might be if r happens to have exactly one element, but not in general)
10:31:59 <hseg> :-/ stepping back, this goes completely against what i'm trying to do
10:54:20 <remexre> is there anything for ffi that just dumps everything it finds in a .h file as faithfully as possible? e.g. generates types with Storable instances, creates foreign imports for every function, etc
10:56:01 <c_wraith> there are attempts at doing so, but all of them require fixups of some sort
10:56:51 <remexre> yeah, I'm fine with fixups
10:57:03 <remexre> just don't wanna spend the next 3 days writing Storable instances lol
10:59:00 <c_wraith> there are things like https://github.com/jwiegley/bindings-dsl/wiki
11:00:56 <remexre> ah, c2hsc sounds like what I want
11:01:21 <c_wraith> that comes with ghc itself.  bindings-dsl adds a bunch of macros that help with common tasks
11:01:33 <c_wraith> err, sorry, that's wrong.
11:01:39 <c_wraith> hsc2hs comes with ghc
11:01:49 <c_wraith> c2hsc is built on top of that
11:02:12 * hackage dobutokO-effects 0.7.1.0 - A library to deal with SoX effects and possibilities  https://hackage.haskell.org/package/dobutokO-effects-0.7.1.0 (OleksandrZhabenko)
11:02:45 <remexre> yeah, that's the one I wanted, I already saw hsc2hs
11:10:07 <maerwald> anyone done DAML?
12:13:42 * hackage call-alloy 0.2.0.5 - A simple library to call Alloy given a specification  https://hackage.haskell.org/package/call-alloy-0.2.0.5 (marcellus)
12:22:55 <monochrom> w00t Alloy
12:43:43 <ja> is the Software Abstractions book good?
12:51:19 <LambdaDuck> Has anyone done research into using coverage to automatically run tests when any code involved in it has changed? I think jest for javascript has a similar feature. Would it be feasible to do so for haskell?
13:11:42 * hackage stan 0.0.1.0 - Haskell STatic ANalyser  https://hackage.haskell.org/package/stan-0.0.1.0 (shersh)
13:27:18 <shapr> LambdaDuck: I recently dug into that
13:27:55 <shapr> LambdaDuck: easiest approach is to use nix, since it runs the tests whenever you build, and will only build packages that have changed
13:28:50 <shapr> I found something for cabal/stack, but I've been sick the past few days and I don't remember
13:29:20 <shapr> LambdaDuck: a related idea I like is to run tests in LRF order, that is, run first the test the failed last, and continue
13:30:40 <shapr> LambdaDuck: oh wait, you're talking specifically about https://hackage.haskell.org/package/coverage  ?
13:31:28 <LambdaDuck> I found stack test --file-watch, which works decently if your tests aren't too slow. There was also https://hackage.haskell.org/package/tasty-rerun, which can prioritize failing tests first. I don't think there is anything with the kind of magic that allows it to determine which tests need to rerun depending on if the specific lines it ran has changed. I don't even know if that is possible in Haskell
13:32:06 <Zemyla> Oh, this is one of the things I want. https://gitlab.haskell.org/ghc/ghc/-/wikis/newtype-optimization-for-gadts
13:34:24 <shapr> LambdaDuck: if you have a bunch of small packages, you can do it without any extra work with nix
13:34:51 <LambdaDuck> I see. That's nice.
13:36:01 <cjay> hmm, automatically analyzing the impact of a single line change would certainly be useful
13:36:05 <LambdaDuck> I wasn't thinking about changes to dependencies. I was only thinking of internally within a package, but changes to dependencies are of course important too.
13:36:44 <cjay> it would need to consider extensions like RebindableSyntax
13:37:18 <LambdaDuck> On a completely unrelated note, I just found out about https://hackage.haskell.org/package/quickspec and it is really cool!
13:38:56 <LambdaDuck> cjay: Yes, stuff like that that changes lines indirectly does make it more difficult. I wonder if hpc considers such dependencies?
13:40:34 <cjay> no idea. and you might trigger rewrite rules differently :)
13:43:37 <cjay> the longer you think about it, the more difficult it becomes
13:43:59 <cjay> still, impact analysis is extremely important, you need it for code reviews in safety critical software
14:02:20 <dminuoso> Is there a tool that orders my build-depends on cabal?
14:02:37 <koz_> dminuoso: What do you mean?
14:04:49 <dminuoso> oh well haha
14:04:56 <dminuoso> `M-x sort-lines` is all I need
14:12:10 <koz_> dminuoso: I mean, cabal-fmt exists?
14:12:33 <koz_> Also, what's the advised go-to solution to 'I want row polymorphism in Haskell' these days?
14:13:18 <dminuoso> vinyl?
14:18:02 <koz_> Might have to finally learn it.
14:19:03 <dminuoso> koz_: Depending on your use case, classy lenses can get you far too.
14:19:19 <dminuoso> It's a poor mans row polymorphism. :)
14:19:21 <koz_> dminuoso: I never looked into those.
14:19:35 <koz_> Is that basically the problem they're designed to solve?
14:19:54 <dminuoso> Are you familiar with lens/optics?
14:20:01 <koz_> Enough to be dangerous.
14:21:03 <dminuoso> A classy lens is just some `class HasFoo a where foo :: Lens' a Foo; fooQ :: Lens' a Q` etc.
14:21:45 <dminuoso> Then you can just write your code polymorphic over say `g :: HasFoo t => t -> ...; g f = ... f ^. fooQ ....
14:22:07 <dminuoso> (It doesnt even have to be pregenerated classes, you can make custom ones as you like)
14:22:13 <dminuoso> Its nothing fancy, just very basic typeclass stuff.
14:22:29 <koz_> Ah, so similar to how labelled optics work?
14:23:55 <dminuoso> labelled optics?
14:24:13 <koz_> http://hackage.haskell.org/package/optics-core-0.3/docs/Optics-Label.html
14:24:22 <deech> Hi all, are there any resources on how to run stack and cabal at the same time?
14:24:32 <dminuoso> koz_: Mmm no
14:24:36 <deech> Same machine I mean.
14:24:48 <koz_> deech: Shouldn't be an issue.
14:25:02 <dminuoso> koz_: https://hackage.haskell.org/package/optics-th-0.3/docs/Optics-TH.html#v:makeClassy
14:25:02 <koz_> If you use a ghcupped cabal.
14:25:08 * koz_ does this.
14:25:11 <dminuoso> koz_: There's also an equivalent for prisms.
14:25:39 <deech> I thought the ghcup'ed GHC compiler clashed with the stack one.
14:25:50 <koz_> deech: Why would it?
14:25:53 <dminuoso> koz_: If you're already acquianted, classy lenses mimic row polymorphism well enough
14:26:03 <dminuoso> They are real simple to use
14:26:21 <koz_> dminuoso: I don't quite see the difference between classy lenses and labelled optics.
14:26:28 <deech> koz_: Not entirely sure, I've just had issues in the past building the same project with 'stack' and 'cabal'.
14:26:44 <koz_> deech: Was this before new-build?
14:27:04 <koz_> I basically cabal new-configure -w where/my/local/ghc/is
14:27:09 <koz_> And then have zero issues.
14:27:15 <dminuoso> koz_: the point of labelled optics is to have overloaded names
14:27:39 <dminuoso> But the point of classy is that you allow to write polymorphic code that works on *any* instance
14:27:49 <deech> Ok cool, I'll try it again. Thanks!
14:28:16 <koz_> deech: Let us know how you go.
14:29:12 <dminuoso> Consider some `class HasUser t where user :: Lens t User; userName :: Lens t Text; userAge t Int`, now you can write code like `assess :: HasUser t => t -> Rating`, and it would work for any type for which you can implement that typeclass.
14:29:41 <dminuoso> labelled optics, from what I can tell, are rather for being able to reuse `name` as *different* unrelated lenses.
14:29:52 <koz_> Ah, so the idea isn't that we're polymorphic over 'has a labelled optic #user'. It's 'we're polymorphic over anything that has a user in any way whatsoever'.
14:30:07 <dminuoso> Right
14:30:15 <sm[m]> deech, yes there should be no problem. stack uses ghc & tools hidden away in ~/.stack/programs, cabal uses the ones in $PATH (or specified with -w)
14:30:25 <koz_> I recommend _always_ -w-ing.
14:30:36 <koz_> That way, it's trivial to build your code with different local GHCs.
14:30:41 * koz_ does this all the time.
14:30:42 <dminuoso> koz_: now obviously, you can just drop the "user" part and say "if ou have these bunch of lenses"
14:30:56 <dminuoso> which could correspond to some fields
14:31:33 <dminuoso> class HasSomeFields t where fieldA :: Lens' t A; fieldB :: Lens' t B
14:31:56 <deech> Doing it!
14:31:58 <sm[m]> do y'all ever wish cabal installed executables to ~/.local/bin instead of ~/.cabal/bin ? would that be better or worse ?
14:32:14 <dminuoso> sm[m]: I think it would be worse.
14:32:19 <koz_> sm[m]: I mean... I don't really mind having an extra PATH entry.
14:32:32 <koz_> dminuoso: OK, I think I get it now. Thanks!
14:32:40 <sm[m]> why dminuoso ?
14:32:50 <deech> Worse. I've had issues where a Haskell and non-Haskell program have the same executable name. It was hard to figure out what was going on.
14:32:59 <dminuoso> ^-
14:33:08 <koz_> Yeah, that'd be... unfriendly.
14:33:19 <dminuoso> Shared mutable state is a greay way to have headaches.
14:33:21 <koz_> Another reason to use the most wordplay-ey names possible.
14:33:31 <dminuoso> Such "global" directories are just an invitation to issues.
14:33:35 <koz_> Minimize clashes with people writing software in other languages with more boring naming conventions. :P
14:33:56 * koz_ regrets not naming 'finitary' as 'volpin'.
14:35:36 <sm[m]> ~/.local/bin is a standard place to install your own stuff, probably with higher priority than /usr/local/bin, /usr/bin etc. Executables you install there will shadow exes of the same name. This is normal and expected, isn't it ?
14:35:46 <ja> koz_: i tried looking for the "-w" flag you mentioned but i can't figure out which command it is for
14:36:08 <koz_> ja: cabal new-* generally takes it.
14:36:13 <koz_> At minimum, new-configure, new-build.
14:36:22 <koz_> But if you do new-configure, new-build subsequently won't need it.
14:36:23 <sm[m]> if I have ~/.local/bin first in PATH and I stack install pandoc, I probably want to use that instead of debian's old pandoc
14:36:38 <deech> Hmmm ... this ghcup PATH instruction will mask executables in `~/.stack/bin` or vice versa. Have to watch out for that. 
14:36:51 <deech> https://gitlab.haskell.org/haskell/ghcup-hs#manual-install
14:37:50 <koz_> deech: Hmm, I've not encountered this, but it's possibly because I basically set the PATH up myself.
14:37:57 <koz_> (and judicious use of -w)
14:38:34 <sm[m]> what deech just said is the kind of hassle I feel is unnecessary.. if you switch between stack/cabal, you have to think about two bin dirs and which one is first. If cabal and stack installed to the same standard bin dir, it removes several hassles.
14:38:47 <Rembane> which -a <command> is a lifesaver
14:39:52 <sm[m]> type -a is even better (shows bash aliases & functions too)
14:40:29 <koz_> Rembane: TIL.
14:40:54 <koz_> (also, 'man which' is hilariously punny)
14:41:01 <koz_> (similar to 'man date')
14:41:07 <deech> A bash warning that showed if you were masking something in PATH would be fun.
14:41:51 <sm[m]> $ which which
14:41:51 <sm[m]> which is aliased to `type -a'
14:41:51 <sm[m]> which is /usr/bin/which
14:42:22 <sm[m]> heh, or even:
14:42:35 * sm[m] sent a long message:  < https://matrix.org/_matrix/media/r0/download/matrix.org/GCeruUlPBiQxcQOQMahFDMdQ >
14:42:58 <koz_> 'which which is which' ...
14:45:55 <ja> ooh, 'type -a' is very useful, looks strictly superior to which :O
14:46:22 <koz_> ja: Yeah, I'm learning useful non-Haskell things here.
14:49:52 <sm[m]> it has helped me escape many a head-scratching PATH/alias/function mess
14:50:19 <sm[m]> but of course fails when you find yourself in a strange shell..
14:50:36 <koz_> sm[m]: I would argue that at _that_ point you have bigger issues.
14:51:05 <sm[m]> well, you know, maybe you're helping someone with a new mac or..
14:52:15 <sm[m]> one of the many things that keeps me huddled in safe, clunky, boring bash
14:52:33 <koz_> sm[m]: I generally have a policy of only writing one-liners in Bash.
14:52:43 <koz_> If I need _anything_ more than that, I'll use an actual programming language. :P
14:52:58 <deech> The ghcup README ( https://gitlab.haskell.org/haskell/ghcup-hs#usage ) has issues. 'ghcup install ghc 8.10.1' fails with 'Invalid argument `8.10.1'. 'ghcup install 8.10.1' worked.
14:53:07 <sm[m]> zsh has "type" I see. But it doesn't support -a.
14:53:26 <koz_> maerwald: ^
14:53:27 <sm[m]> koz_: I think oil shell will save us eventually
14:53:50 <koz_> sm[m]: I honestly dunno. I keep seeing it stroll across my newsfeeds, but I haven't investigated enough to say anything sensible.
14:54:08 <sm[m]> he's very dedicated and making good progress AFAICT
14:54:26 <sm[m]> and building a following through excellent writing
14:55:19 <koz_> sm[m]: Well, I might consider it if I find my current solutions wanting.
14:57:45 <deech> Yeah the README's out of date, it tells you to do 'ghcup install cabal' but it's actually 'ghcup install-cabal' something must have changed recently. 
14:58:02 <ja> sm[m]: "type -a" behaves differently without "-a" for me in zsh, so i think it does support it?
14:59:20 <ja> "man zshbuiltins" also lists the a flag
15:02:30 <jumper149> Is there something like constraint synonyms?
15:02:50 <koz_> jumper149: 'type ReadShow a = (Read a, Show a)'
15:03:01 <koz_> (needs an extension or two I think)
15:03:02 <jumper149> so constraints are types?
15:03:11 <koz_> jumper149: _Everything_ is a type secretly. :P
15:03:30 <koz_> To be a bit more precise, fully saturated constraints have kind Constraint.
15:03:36 <koz_> So for instance, 'Show Int :: Constraint'.
15:03:45 <koz_> Otherwise, they behave much like higher-kinded types would.
15:03:51 <koz_> So 'Show :: Type -> Constraint'.
15:04:05 <koz_> Or 'Functor :: (Type -> Type) -> Constraint'.
15:04:41 <ja> is 'higher-kinded type' the same as saying "kind"?
15:04:58 <ja> if i have to use :k in ghci to avoid errors, does that mean it is a kind?
15:05:34 <koz_> ja: A kind is sort of 'a type of types'.
15:05:41 <koz_> For example, the kind of Int is Type.
15:05:57 <koz_> But the kind of something like 'Maybe' is Type -> Type.
15:06:15 <koz_> Because to 'complete' a Maybe, you have to give it a type.
15:06:27 <koz_> So if you take 'Maybe' and 'give it' an 'Int', you get 'Maybe Int'.
15:06:35 <koz_> (which, of course, has kind Type)
15:06:55 <ja> but "Maybe" alone is not a type, right? and "Show Int" is not a type either, right? cause i cannot prefix either of them with ':t'
15:07:05 <sm[m]> ja, ok, I failed to get it working at least
15:07:22 <jumper149> I guess you could say Maybe is a TypeTransformer :D
15:07:28 <koz_> ja: As far as _GHC_ is concerned, yes, they are all types.
15:07:37 <koz_> What I guess you are saying is 'they are not of kind Type'.
15:07:39 <koz_> Which is correct.
15:08:04 <dolio> ja: :k is what you use when you ask for the kind of a type, which means the argument is a type.
15:08:06 <koz_> Maybe is not of kind Type (it's of kind Type -> Type). Likewise, Show Int is of kind Constraint.
15:08:21 <dolio> Or something type-level.
15:09:37 <ja> ok, so there are two different notions of type in play here? what is the unambiguous term for what you can write after ":t"?
15:09:50 <koz_> 'A type of kind Type'.
15:10:07 <koz_> So, to whit:
15:10:11 <koz_> > :t Int
15:10:13 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
15:10:18 <koz_> :t Int
15:10:19 <lambdabot> error:
15:10:19 <lambdabot>     • Data constructor not in scope: Int
15:10:20 <lambdabot>     • Perhaps you meant one of these:
15:10:27 <koz_> Ah, sorry, my bad.
15:10:29 <dolio> "Higher kinds" are the ones involving arrows, because people are usually comparing them to situations where you don't have those.
15:10:39 <koz_> That's me being silly and getting confused.
15:10:45 <koz_> :t gives types of terms.
15:10:46 <lambdabot> error: parse error on input ‘of’
15:10:53 <koz_> You don't give _types_ to :t.
15:11:00 <koz_> You can do something like 
15:11:03 <koz_> :t 1
15:11:05 <lambdabot> Num p => p
15:11:09 <koz_> But not
15:11:11 <koz_> :t Int
15:11:13 <lambdabot> error:
15:11:13 <lambdabot>     • Data constructor not in scope: Int
15:11:13 <lambdabot>     • Perhaps you meant one of these:
15:11:20 <dolio> Although it might depend on the exact situation.
15:11:28 <koz_> :k Int
15:11:29 <lambdabot> *
15:11:35 <koz_> (* means 'Type')
15:11:37 <koz_> :k Maybe
15:11:39 <lambdabot> * -> *
15:11:45 <koz_> (so, Type -> Type)
15:11:48 <koz_> :k Show
15:11:49 <lambdabot> * -> Constraint
15:11:55 <koz_> (so Type -> Constraint)
15:11:58 <koz_> :k Show Int
15:11:59 <lambdabot> Constraint
15:12:36 <ja> ah right, ok, i was confused too of course. the value and the type namespaces are separate. but there is still that distinction between Constraints and not-Constraints, i think?
15:13:08 <koz_> ja: In what sense?
15:13:19 <koz_> In the sense that Constraint is a different kind from Type, you mean?
15:13:36 <ja> yes?
15:13:42 * hackage vty 5.29 - A simple terminal UI library  https://hackage.haskell.org/package/vty-5.29 (JonathanDaugherty)
15:13:45 <ja> they normally go before "=>", right?
15:13:56 <koz_> ja: Not necessarily.
15:14:05 <ja> but since they both go after ":k", does that mean they are both kinds? 
15:14:08 <koz_> You can, for example, construct GADTs which have constraints inside.
15:14:33 <koz_> Both Type and Constraint are kinds, I agree.
15:16:27 <ja> an example of a GADT with Constraints, would that be like MarkedList here? https://en.wikibooks.org/wiki/Haskell/GADT
15:16:39 <ja> with * -> * -> * explicitly written
15:17:06 <koz_> Nope. Note the statement of the kind of MarkedList.
15:17:14 <koz_> * -> * -> *, meaning 'Type -> Type -> Type'.
15:18:54 <koz_> It would be something like 'data ReifiedConstraint (k :: Constraint) where Reify :: ReifiedConstraint k'.
15:19:03 <koz_> Bonus question - what is the kind of ReifiedConstraint?
15:19:30 <ja> would it be * -> Constraint
15:19:53 <dolio> I think you want `k => ReifiedConstraint k`.
15:20:14 <koz_> dolio: Yeah, I could do that if I actually wanted to use that constraint anywhere. :P
15:20:18 <ja> hmmm wait, now i am unsure if it shouldn't be Constraint -> Constraint
15:20:22 <koz_> Nope.
15:20:33 <koz_> You're right about the left side of the arrow, but not the right.
15:20:57 <ja> aah so that means that something after :: doesn't necessarily need to be a Type
15:21:24 <koz_> More exactly, a :: k can mean different things in different contexts.
15:21:36 <koz_> It can mean 'term a is of type k'.
15:21:43 <koz_> But it can also mean 'type a is of kind k'.
15:21:49 <koz_> In the thing I gave above, it's the second meaning.
15:22:18 <ja> ooh sneaky
15:22:34 <koz_> I mean, ultimately I'm lying about all of this, because as far as GHC is concerned, Type :: Type.
15:22:41 <koz_> (which is why I said 'ultimately everything is a type really)
15:22:52 <koz_> However, I find it useful to keep the notion of type and kind separate.
15:23:11 <ja> the distinction makes sense as long as dependent types are not fully integrated?
15:23:24 <koz_> ja: It doesn't really depend on dependent types being integrated or not.
15:23:46 <koz_> You can have dependent types and Type :: Type, you can have dependent types _without_ Type :: Type, you can have no dependent types and Type :: Type, etc.
15:24:04 <ja> ok, orthogonal
15:24:14 <koz_> Dependent types is more about how terms and types can interact.
15:24:26 <koz_> Without getting super-technical, the lambda cube basically describes what can depend on what.
15:24:36 <koz_> Simplest situation is 'terms depend on terms' - that's lambda abstraction.
15:24:42 * hackage brick 0.55 - A declarative terminal user interface library  https://hackage.haskell.org/package/brick-0.55 (JonathanDaugherty)
15:24:48 <dolio> There are presentations of dependent types where the term and type levels are still separate.
15:24:54 <oats> is there a good introduction to the lambda cube anywhere, maybe for someone already basically familiar with lambda calculus?
15:24:57 <dolio> Syntactically.
15:25:27 <ja> it is just... idris seems so similar to haskell, but the book didn't ever use the term kind, i think
15:25:29 <koz_> oats: I am in favour of 'Type Theory and Formal Proof'.
15:25:32 <ja> why is that?
15:25:34 <koz_> Looks scary, but isn't really.
15:25:55 <koz_> ja: It's been a while since I looked at it. I believe it's a case of focus.
15:26:17 <dolio> ja: With dependent types, you usually wouldn't have kinds. You'd have universes internalizing some of the types as terms.
15:26:23 <koz_> ja: To continue my thought - 'dependent types' means that types can depend on terms.
15:26:49 <koz_> You also have 'types depending on types' and 'terms depending on types'.
15:27:00 <koz_> And where you are in the cube is determined by what combination of those four is permitted.
15:27:08 <koz_> STLC permits only 'terms-depend-on-terms'.
15:27:31 <koz_> So when you talk about 'dependent types', it's worth being careful about what you mean exactly.
15:27:56 <koz_> (and I will not specify what System F permits additionally because I _will_ get it wrong and _will_ look stupid)
15:27:59 <ja> dolio: so when you say Syntactically separate, that is like in haskell, right? because type constructors and data constructors are oblivious of each other, they can never touch?
15:28:08 <koz_> ja: That's not true either.
15:28:14 <koz_> Consider DataKinds, for instance.
15:29:26 <dolio> ja: I mean that types are a different syntactic class from terms. There is a judgment `A type` and a judgment `e : A`, where e is a term and A is a type. Terms can occur inside types, so they would 'touch' in that way.
15:29:47 <dolio> Types might occur inside terms, too, of course.
15:29:57 <koz_> To extend dolio's point - don't confuse syntax and semantics.
15:29:58 <dolio> But as things like annotations.
15:31:13 <dolio> And the universe is a type `U` and a family of types `El u` where `u : U`, and the values of `U` correspond to types, and `El` computes the type that `u` corresponds to.
15:31:37 <dolio> That lets you write 'higher kinds' as functions U -> U.
15:31:47 <dolio> And so on.
15:32:53 <dolio> Sometimes people present it such that (some) types are values of U, but you can keep the syntax completely separate 
15:33:24 <dolio> Like, put hats on all the constructors of U so that they're distinct symbols.
17:34:11 --- topic: 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: https://gist.github.com/ | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org'
17:34:11 --- topic: set by glguy on [Sat Jan 05 07:21:52 2019]
17:34:11 --- names: list (clog tscholak antalsz jedws inkbottle nikka mnrmnaugh xerox_ thegeekinside_ hyiltiz dansho efm wroathe tromp whatisRT mapf0ld TCZ justanotheruser mounty1 gentauro spion drbean Lord_of_Life DirefulSalt mossplix Jesin gehmehgeh NieDzejkob jared-w lnostdal xsperry shafox gienah tom__ whiteline conal dopplergange phreedom Amras0000 John_Ivan acarrico texasmynsted infinity0 hexfive ystael_ xff0x carlomagno kav Erutuon shaylew kptech Sgeo zocker jsb aarvar jb55 Kaiepi)
17:34:11 --- names: list (acidjnk_new jumper149 jlorand[m] hyiltiz[m] michael[m]2 joshua[m]2 dyniec[m] solomon[m] jojotastic777[m] alexfmpe gcoakes[m] whu[m] utdemir[m] bolti[m] khorser[m] io_r_us[m] mathyouguy grizwako[m] atopuzov[m] quiet_laika[m] Noughtmare[m] mikr[m] iffsid jhuizy[m] iinuwa Hatsue denbrahe[m] rellen[m] freeman42x[m] sajith[m] boistordu jluttine[m] schum sepp2k reed[m] rednaZ[m] roberth supersven[m] jojoz[m] Fernando-Basso[m michaelpj c6ristian maralorn redviking[m])
17:34:11 --- names: list (siraben Poscat[m] srid camlriot42 Elorm[m] ArtemZ jkhaak[m] lnxw37d4 fgaz drozdziak1 vaibhavsagar FAUST|thejonny hsiktas[m] psydruid kadoban ethercrow[m] unclechu kaychaks_riot fossegrim[m] execat[m] Ericson2314 domenkozar[m] Cale Rembane e sm[m] irclogger_com smitop Shun131 kqr dexterlb Takumo sdrodge jokester sm SomeB sud0 dxld rotty Zialus_PT zabracks scav_ adamse rdivyanshu_ alunduil FMJz___ lally yogani johs ajmcmiddlin elvishjerricco ebutleriv nineonine)
17:34:11 --- names: list (tsrt^ joshmeredith wz1000 scav statusfailed bendo_ bwe_ koala_man sujeet pera ViCi^ amosbird_ pasukon runeks mankyKitty wildsebastian gaze__ mcfilib Hotbees feuerbach_ incognito9999_ howdoi CurryWurst mounty Waldkauz s00pcan systemfault sagax machinedgod crobbins electricityZZZZ hseg Chi1thangoo ridcully L29Ah fragamus ap5 totte rembo10 davl tensorpudding zzz fliife850 alexelcu oxide albethere Fischmiep Sk01 tomku roconnor govg ulidtko tabaqui1 ryantrinkle)
17:34:11 --- names: list (polyphem siers stepnem urodna vicfred ChaiTRex kjak giovani koz_ PtxDK lep-delete zariuq Arahael bobey DavidEichmann proteusguy datajerk whald dsal chessai jetpack_joe billstclair iphy sclv ^[_ enemeth79 kip nlofaro liiae` veverak danso Argorok heyj dmj` zot adius PoliticsII__ nick_h terrorjack Firedancer shock_ MarcelineVQ day jneira otto_s theDon lagothrix Benett clynamen Guest99472 carldd whataday alx741 hiptobecubic _ashbreeze_ hololeap nshepperd jrm)
17:34:11 --- names: list (jlamothe chalkmonster atraii Shadorain peel rann teehemkay mudri rodlogic_ davetapley badzergling verlet64_ ryjm jlpeters lexi-lambda JSharp cbarrett jesyspa betawaffle newhoggy Tritlo koankeeper angerman carter PatrickRobotham_ AndreasK parsnip Boarders dsturnbull Nascha sgraf liszt cvlad- hamishmack NemesisD fiadliel grfn parisienne___ conjunctive higherorder revprez_anzio amatecha__ cstrahan totbwf natim87 bitonic banjiewen Adeon coot starlord caasih)
17:34:11 --- names: list (chpatrick moobar gregberns_ liquorice feepo drbrule alexknvl jonrh isacl___ luite benl23 simony pent benwr_ lightandlight cinayakoshka ReinH bjs tnks jbetz eyenx|m bradparker stree gluegadget eacameron idnar mpickering thi metadave Cir0X alanz_ avandolder_ edmundnoble ullbeking SrPx nh2 edwardk DocKlobi dgpratt jackdk laghee__ m-renaud pepeiborra runde rslima____ affinespaces stylewarning ocharles darthThorik sethetter dani- J_Arcane glowcoil kristjansson)
17:34:11 --- names: list (spiderbubble parseval integral graingert typetetris Kamuela ghuntley srhb d0liver agander_m buggymcbugfix rizary milessabin kyagrd__ wpcarro bgavran ProofTechnique ibloom aristid taktoa[c] PotatoGim entel kozowu AWizzArd Cthalupa emmanuel` dddddd ddellacosta klardotsh javran frdg Bish catern haasn tabaqui lpsmith crtschin agrif otulp dcoutts_ Tesseraction hc tomboy64 Neo-- bennofs jchia__ TMA orcus joeytwiddle darjeeling_ tarpk thunderrd mananamenos xwvvvvwx)
17:34:11 --- names: list (MasseR sicklork1n revprez_stg dave_uy2 voyons_osti noecho edwtjo hpc markus1199 nate48423 cyphase lle-bout justache thaumavorio DTZUZU nak tomsmeding Alleria_ GyroW_ Nilgeist ichimaru cmsmcq amf Noldorin forell dequbed poljar livvy ArsenArsen auri_ aurieeeh aidecoe dh jonatan oak_ robotmay leothrix ericsagnes sw1nn echoreply stiell TakinOver remexre gsingh93 energizer oats pyrho gekh1 robogoat zv Khisanth theorb seanparsons cp- tabemann sMuNiX glguy pieguy128)
17:34:11 --- names: list (Rudd0 albel727 geyaeb andreas303 mud davean Profpatsch brisbin marek noteness Uma tstat Lowl3v3l fissureman aplainzetakind Bunogi drewr Kaivo jakalx zaquest lambdabot Orbstheorem Seich drewolson atk ezzieyguywuf daGrevis Ekho cantstanya xelxebar @Sigyn opqdonut abbe megaTherion denisse lassulus swater Geekingfrog mimi_vx kAworu cgfbee doublex connrs- aweinstock nurupo uwap laxask krjst DigitalKiwi Techcable Benzi-Junior tinwood bananagram sophronios zyeri)
17:34:11 --- names: list (perrier-jouet stux|RC-only leah2 amiri infty dixie Squarism Maxdamantus tasuki_ mceier vk3wtf Mindless- le_jonge bsima PragCypher averell LambdaDuck pacak cow-orker styledash narendraj9 wagle nerdypepper sqrt2 L1Cafe tdammers towel Reiser9 lyxia fre mort Moyst polux2001 connrs quintasan xarian ski rotaerk Aleksejs loc _janne frobnicator Firedancer_ tms_ Cathy Arguggi srk hyperfekt sayak EvanR kosmikus dolio jinblack monochrom russruss dmiles unlink2 noan joehh1)
17:34:11 --- names: list (m1cl samebchase puffnfresh byorgey anoe_ Arjan arianvp pta2002 bollu Katarushisu APic Cheery caubert is_null gawen electrostat jassob marble_visions Dykam mupf sim590 Nistur dan64 c-rog dqd oeblink elcaro_ copypasteque_ yahb mstruebing recon_- nek0 martin02 Guest2322 benschza ixian raoulb sivs Taneb q3k _flow_ interruptinuse lukelau Bigcheese cocreature a3f solarus twk- nshepperd1 operand spoonm xcin immae jackhill rawles Majiir miklcct xnyhps PigDude i7c teqwve)
17:34:11 --- names: list (tomjaguarpaw jorj hiredman arkeet Kneiva vancz RoguePointer stvc pharaun grazfather Guest6919 wowi42 aldum madnight Jonno_FTW M2tias enikar simplegauss Cerise coeus NinjaTrappeur fredcy- farn_ vnz dale idupree2 zgrep noexcept rom1504 Ferdirand tolt bspar debugloop magog ggVGc silver_needles Forkk yushyin nikola2 ManiacTwister ByronJohnson mingc SolarAquarion joehillen cjay hongminhee oldsk00l dumptruckman mursu nisstyre Natch glamas cyberlard statusbot troydm)
17:34:11 --- names: list ({abby} haskell_enthusia maerwald stilgart mniip pounce chindy valdyn thecoffemaker malthe cohn dcoutts niklasb_ loli meck motherfsck jdt dustinm- msgctl dminuoso Hijiri gilbertw1_ ornxka_ gareth__ amx RusAlex magicman hwabyong_ Philonous ent cpape johnstein Zemyla piele w1gz electrocat Ankhers Someguy123 a3Dman_ ps-auxw pierrot Logio nyaomi anderson pie_ hrnz oleks mr_yogurt happycoder Unode mantovani deni djanatyn reyu Eliel vimto1 ring0` tanuki Guest603)
17:34:11 --- names: list (fryguybo1 seliopou_ rodgzilla artem Heffalump rednaZ2 xlei SupaYoshi LittleFox dibblego jcarpenter2 verement kmein tv mac10688 kraem dmwit efertone nil mp___ gabiruh jhuizy divVerent ab9rf hvr devalot hive-mind vqrs c_wraith turq [df] Clint gothos ammar2 helpplz dragestil apoc newsham SquidDev Entroacceptor Tene earthy gambpang PlasmaStar WzC_ carbolymer nopf_ e2 shadowdaemon cjh` juri_ Drezil ahf dysfigured ziman Ranhir jchia_ lnx abrar hackage qz jfredett_ avn)
17:34:11 --- names: list (blackbart bonz060 centril riatre ephemera_ coddinkn_ Paks digia fiQ2 kloeri iomonad nshepperd2 Solarion Neuromancer notzmv magbo rzmt petersen flebron solrize kini Flonk_ shachaf andromed1-galaxy bcoppens_ jmsx samebchase- jtcs mjrosenb landonf mrus wrunt locallycompact Igloo bind ptrcmd freeside barrucadu Jello_Raptor epta add^_ quaestor Guest20621 absence comboy luigy lowryder sea-gull mikolaj_ asm89 j_klee thebnq Uniaika ekleog bandali heredoc acro andi-)
17:34:11 --- names: list (t36s_ liff SegFaultAX milkii hodapp xacktm mjuad hexagoxel phz vjoki canta nekomune grol nemesit|znc ivegotasthma ashnur m1dnight_ arw exarkun adamCS beka kipras`away Guest60204 andjjj23 bob_twinkles NGravity blackdog bcmiller DustyDingo shapr eldritch Ornedan unsupervised d3lxa sshine nitrix dwt urdh zfnmxt phaul CitizenSnips pdxleif eagleflo Chobbes topos cods jchia1 sajith dilinger micro_ jameekim2 rprosper- incertia saurik rdivacky tumdedum reactormonk)
17:34:11 --- names: list (CindyLinz inimino geal mmaruseacph2 mgaare_ chirpsalot jzl Wamanuz2 niko Velpoman infinisil matheus23 jle` jtobin wayne militia duairc wraithm acertain TommyC [exa] sdx23 Tourist dftxbs3e pong raid PyroLagus TimWolla Iroha DwarfMaster mulderr HiRE `slikts p3n sepplesWoona Faye saidinwot1 Randy Klumben mystfox aib sarahzrf bgamari noCheese kkd cheers Blkt sis7 relrod sveit komasa beaky Jon bjobjo Adluc hexo vodkaInferno joeyh deu myme lortabac spamlessj atle_)
17:34:11 --- names: list (chrpape PHO Vq jjhoo @ChanServ dexterfoo suppi dredozubov thonkpod drdo ego suzu_ tristanC duckonomy nckx furnost esg tureba ja tessier lucianp_ xe4 ben phadej uberj Sparadox mikolaj ft davve runawayfive Twey exferenceBot greymalkin ycheng jkarni fiddlerwoaroof Deewiant_ bobbytables jvanbure lemald Patternmaster cynick heath gargawel supki Tspoon dyl_ lieven balbirs esotericalgo cross sphalerite zymurgy Guest14132 so esph codedmart atomi kaol voidcontext ambiso)
17:34:11 --- names: list (xintron eyenx stefan-_ obfusk grumble evanjs noctux thestr4ng3r doconthe1ocks abuss vin-ivar obiwahn mozzarella michalrus haveo steell Niamkik Madars Nikotiini Inoperable lockshaw mawk int-e Athas peutri raoul)
17:36:05 <hseg> hrm. is there any way to unwrap a newtype in a pattern synonym?
17:36:55 <hseg> eg i want to write pattern E = Fix U1, pattern Z = Fix (L1 (unfix E))
17:37:19 <hseg> so that i end up with pattern Z = Fix (L1 U1)
17:37:28 <hseg> but ghc dislikes this
17:41:17 <hseg> right, because rhs must be a pattern
17:56:20 <hseg> ok, gtg. will take this up again tomorrow 
17:56:26 <hseg> thanks everyone!
18:26:34 <orion> Hi. I am trying to build cabal-install from source with GHC 8.8.3, and I am encountering an issue bootstrapping. The script is trying to build HTTP-4000.3.12, but that depends on base <4.13. I've tried 3.0.1.0-rc4 and 3.2.0.0.
18:31:08 <glguy> cabal-install-3.2.0.0 doesn't appear to support being built with 8.8.3 independent of HTTP
18:31:34 <orion> I mean, I *could* just bump the version in the bootstrap script, but that feels like a dark road.
18:34:27 <monochrom> Is it important to build from source?
18:36:17 <orion> Yes. I want to understand how the metaphorical sausage is made.
18:39:14 <glguy> You might enjoy http://www.linuxfromscratch.org/
18:39:52 <orion> That's a great resource! I also enjoy FreeBSD.
18:46:11 <gushys> If i have a function with signature f :: Int -> Double -> [Double]
18:46:40 <gushys> f n m = map (\x -> x * n) [1..m]
18:46:58 <gushys> oops
18:47:02 <gushys> f m n *
18:47:10 <gushys> errors on m being an int
18:49:30 <gushys> m is an int as it should be and n is a double so why does that error on a list of doubles
18:50:01 <gushys> i guess i can map a list of doubles to a list of ints
18:55:01 <infinisil> gushys: You're multiplying an int by a double in the lambda
18:55:30 <infinisil> You probably want to fromIntegral the int first
18:55:52 <infinisil> :t (*)
18:55:53 <lambdabot> Num a => a -> a -> a
18:55:55 <infinisil> :t fromIntegral
18:55:56 <lambdabot> (Integral a, Num b) => a -> b
18:57:53 <gushys> so fromIntegral will convert the Double to an int?
18:59:53 <emmanuel`> Hello therea
18:59:55 <emmanuel`> Hello there
19:00:18 <ja> hello here
19:04:04 <gushys> :infinisil Thanks for the help, it worked
19:09:46 <dmwit> gushys: No, fromIntegral will convert the Int to a Double.
19:09:51 <infinisil> ^
19:09:53 <dmwit> (...as its name implies.)
19:16:51 <dmj`> gushys: you have to round to go the other way
19:17:07 <monochrom> @quote monochrom fromIntegral
19:17:07 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
19:17:35 <monochrom> It will be hit again when the new Ghostbuster movie comes out.
19:17:56 <dolio> Another one?
19:17:58 <monochrom> Damn the coronovirus delaying everything.
19:18:27 <monochrom> Yeah, the one with kids, kids being descendents of the original characters. "Who was your grandfather?!"
19:19:02 <dolio> Oh right.
19:19:52 <koz_> How would I parse a LocalTime from a Text in the ISO 8601:2004(E) format?
19:20:03 <koz_> (Maybe LocalTime as a return is acceptable)
19:20:22 <monochrom> I don't about the format, but I think you will be unpacking to String first, if anything.
19:20:31 <koz_> monochrom: Sure, I figured as much.
19:20:48 <koz_> I tried looking at some of the parsing functions in time, but I'm not quite sure what some of the arguments mean.
19:21:34 <koz_> https://hackage.haskell.org/package/time-1.10/docs/Data-Time-Format.html#v:parseTimeM This seems the closest, but what time locale am I in?
19:23:06 <sicklork1n> @koz_ localtime won't work. maybe you want ZonedTime instead?
19:23:06 <lambdabot> Unknown command, try @list
19:23:32 <koz_> The format is yyyy-mm-ddThh:mm:ss.
19:23:40 <koz_> I'll accept whatever type that can be pulled into.
19:25:38 <koz_> sicklork1n: Also, suirely this would work? https://hackage.haskell.org/package/time-1.10/docs/Data-Time-Format-ISO8601.html#t:ISO8601
19:25:58 <koz_> Also lol... right under that is the function I seek.
19:26:00 <sicklork1n> I thought you wanted locale info
19:26:15 <koz_> sicklork1n: Never mind, I think I'm sorted.
19:26:22 <sicklork1n> What version of time are you using?
19:26:42 <koz_> 1.9.3
19:27:26 <sicklork1n> Okay, if you're sorted great.. if not lmk, cause I have no issues parsing localtime from ISO8601
19:27:42 <koz_> sicklork1n: I was looking at the wrong set of functions I think.
19:30:24 <Shadorain> ollo
19:32:52 <koz_> Shadorain: Wazzup?
19:33:03 <Shadorain> nm dog hbu?
19:36:33 <Shadorain> actually i came to chill but could use some help:
19:37:17 <Shadorain> im trying to Type declare something that i just cannot figure out how to do, it never gave me issues before but now for some reason its flagging me every time i restart xmonad
19:37:41 <Shadorain> this isnt really an xmonad question tho so ill ask it here since its more haskell
19:38:15 <Shadorain> `addOverline = noFrillsDeco shrinkText overLineTheme` im trying to type declare this: 
19:38:50 <Shadorain> noFrillsdeco is from a module and so is shrinkText, the overLineTheme is just custom with colors and stff, nothing outta the ordinary
19:39:16 <Shadorain> http://hackage.haskell.org/package/xmonad-contrib-0.16/docs/XMonad-Layout-NoFrillsDecoration.html here is that library
19:41:23 <dmwit> Is there still a question coming?
19:41:53 <Shadorain> oh sorry yes i dont know what the issue is when it shouldnt be erroring out
19:42:19 <Shadorain> what its telling me is that its of ambiguous type which means i need to declare it but nothing i try works
19:42:56 <MarcelineVQ> that's a good start, so next people need to see the code you actually have and the full error you get with it
19:43:13 <Shadorain> https://i.imgur.com/yIKIBpT.png
19:43:22 <Shadorain> thats the error, lemme get a pastebin for code
19:44:40 <dmwit> {-# LANGUAGE NoMonomorphismRestriction #-}
19:45:41 <Shadorain> welp u figured that one out fast :joy:
19:45:47 <Shadorain> that fixed it right up
19:46:03 <sicklork1n> dmwit: did you find that in the documentation?\
19:46:11 <Shadorain> before i even could get u my code, yeh idk how u got that so fast?
19:46:29 <dmwit> I've solved a shitload of Haskell problems.
19:47:18 <Shadorain> speedy brain man, that was crazy fast
19:47:47 <Shadorain> im still having that other bar issue, dmwit, but this isnt the xmonad channel
19:48:21 <dmwit> When you find a way to observe the bytes coming into the bar that cause the problem I'll be interested in helping further. But I can't really do much without debugging data.
19:49:12 <Shadorain> id agree, im quite sure it isnt from the loghook but that is whats breakign so ill keep trying to get that
19:50:17 <Shadorain> im using dbus, so if i can get a way to handle that (a way id know :facepalm:)
20:48:12 * hackage mutable 0.2.2.0 - Automatic piecewise-mutable references for your types  https://hackage.haskell.org/package/mutable-0.2.2.0 (jle)
20:48:47 <Shadorain> dmwit, i really cant find a way to get this sent to xxd, ive tried a keybinding, messing with diff things in the logHook, checking the dbus processes, monitoring them to no avail
20:52:51 <ullbeking> i looked on the hs wiki and there are SO MANY IRC CHANNELS!!!  unfortunately many of them are very empty.  where is the best channel to discuss web development using Haskell?
20:57:53 <ja> ullbeking: what about #yesod ?
21:15:26 --- mode: verne.freenode.net set +o ChanServ
21:17:13 --- mode: verne.freenode.net set +o Sigyn
21:21:28 <sm[m]> also IHP has a gitter  channel
22:44:38 <liiae`> [1,2,3,5,6] how I can group this to [[1,2,3],[5,6]]?  group by nth - (nth-1) = 1
22:45:01 <liiae`> filter need an unary, not binary
23:03:09 <gust> hello!
23:03:45 <sicklork1n> liiae`: chunkOn?
23:05:38 <liiae`> sicklork1n: where `chunkOn` is?
23:05:46 <liiae`> there's chunksOf
23:07:30 <sicklork1n> lol that's the one.. in Data.Text
23:08:35 <liiae`> sicklork1n: I can't find chunkOn in Data.Text
23:08:45 <liiae`> @hoogle chunkOn
23:08:45 <lambdabot> No results found
23:08:46 <sicklork1n> chunksOf
23:09:08 <liiae`> @hoogle chunksOf
23:09:08 <lambdabot> Data.Sequence chunksOf :: Int -> Seq a -> Seq (Seq a)
23:09:09 <lambdabot> Data.Sequence.Internal chunksOf :: Int -> Seq a -> Seq (Seq a)
23:09:09 <lambdabot> Data.Text chunksOf :: Int -> Text -> [Text]
23:09:37 <liiae`> chunksOf need an Int, but I need a binary 
23:09:50 <dmwit> What is a binary?
23:10:14 <liiae`> a binary function
23:10:36 <liiae`> dmwit: [1,2,5,7,8,9] should be [[1,2], [5], [7,8,9]]
23:11:04 <dmwit> What is a binary function?
23:11:06 <liiae`> dmwit: I tried groupBy (\a b -> (b - a) /= 1) [1,2,5,7,8,9]
23:11:37 <liiae`> dmwit: a binary function is a function take two arguments
23:11:41 <liiae`> ok?
23:11:56 <liiae`> an unary function is a function take one argument
23:12:03 <liiae`> :t (+)
23:12:05 <lambdabot> Num a => a -> a -> a
23:12:10 <liiae`> :t (+1)
23:12:11 <lambdabot> Num a => a -> a
23:12:23 <liiae`> (+) is a binary function, (+1) is an unary function
23:12:24 <sicklork1n> why dno't groupBy work?
23:13:04 <liiae`> > groupBy (\a b -> (b-a) /= 1) [1,2,3,5,6,7,11,12]
23:13:06 <lambdabot>  [[1],[2],[3,5,6,7,11,12]]
23:13:15 <dmwit> Because groupBy assumes you give it an equivalence relation.
23:13:19 <dmwit> And so it pulls a nasty trick.
23:13:30 <dmwit> Which does not work if the argument you give it is not an equivalence relation.
23:13:33 <int-e> always comparing to the first element isn't exactly nasty
23:13:50 <dmwit> It's not what most people expect. It's not what I expect.
23:13:54 <dmwit> Surprise is nasty.
23:14:14 <sicklork1n> ahh. right
23:14:21 <int-e> > groupBy (\a b -> b-a == 1) [1,2,5,6,6,6,6,7]
23:14:23 <lambdabot>  [[1,2],[5,6,6,6,6],[7]]
23:14:57 <liiae`> groupBy (\a b -> (b-a) == 1) [1,2,3,5,6,7,11,12]
23:15:17 <liiae`> > groupBy (\a b -> (b-a) == 1) [1,2,3,5,6,7,11,12]
23:15:18 <lambdabot>  [[1,2],[3],[5,6],[7],[11,12]]
23:15:42 <liiae`> it should be [[1,2,3],[5,6,7],[11,12]]
23:15:53 <edwardk> i do kind of wish it returned a list of NonEmptys or pairs of a head element and the rest of the list, because then the 'specialness' of the first element in each equivalence class would be a little more called out
23:16:08 <int-e> note the 5,6,6,6,6 part I put in my example, which should make fairly clear how groupBy compares stuff
23:16:23 <edwardk> liiae`: you need to write a different function that may have the same type signature as groupBy to get those semantics
23:16:44 <int-e> . o O ( chainOn )
23:17:18 <int-e> That's also bad terminology, sadly.
23:17:50 <dmwit> liiae`: Anyway, there's no good way. Everybody who needs this codes it up themselves.
23:18:31 <int-e> > zipWith (-) [1,2,3,5,6,7,11,12] [0..]
23:18:33 <lambdabot>  [1,1,1,2,2,2,5,5]
23:19:14 <edwardk> you want to zip it with its tail and subtract no?
23:19:26 <edwardk> after checking to make sure it isn't empty
23:19:42 <edwardk> and then you have to carve up the resulting list on that predicate
23:20:17 <edwardk> oh, you use that to group by
23:20:20 <edwardk> i see
23:20:22 <edwardk> cute
23:21:40 <int-e> > map (map snd) . groupBy ((==) `on` fst) . zipWith (\d x -> (x-d, x)) [0..] $ [1,2,3,5,6,7,11,12]
23:21:45 <lambdabot>  [[1,2,3],[5,6,7],[11,12]]
23:22:27 <liiae`> > groupBy (\a b -> (b-a) == 1) [1,2,3,5,6,7,8,11,12]
23:22:28 <edwardk> > fmap (fmap snd) $ groupBy ((==) `on` fst) $ zipWith (\a b -> (a-b, a)) [1,2,3,5,6,7,11,12] [0..]
23:22:29 <lambdabot>  [[1,2],[3],[5,6],[7,8],[11,12]]
23:22:29 <edwardk> yeah
23:22:30 <lambdabot>  [[1,2,3],[5,6,7],[11,12]]
23:22:37 <edwardk> you beat me to it
23:23:37 <liiae`> I think we can do another group on [[1,2],[3],[5,6],[7,8],[11,12]]
23:25:55 <liiae`> groupBy (\x y -> (last x) - (head y) == -1) [[1,2],[3],[5,6],[7,8],[11,12]]
23:27:36 <int-e> liiae`: but it doesn't stop there
23:27:51 <liiae`> > fmap concat $ groupBy (\x y -> (last x) - (head y) == -1) $ groupBy (\a b -> (b-a) == 1) [1,2,3,5,6,7,8,11,12]
23:27:53 <lambdabot>  [[1,2,3],[5,6,7,8],[11,12]]
23:28:24 <int-e> liiae`: [1..5] will be spit into two parts
23:28:53 <liiae`> int-e: why?
23:29:23 <liiae`> your're right
23:30:21 <int-e> > fmap concat $ groupBy (\x y -> (last x) - (head y) == -1) $ groupBy (\a b -> (b-a) == 1) [1,2,2,3,4,3,4,4]
23:30:24 <lambdabot>  [[1,2,2,3,4,3,4,4]]
23:32:43 <liiae`> int-e: I forget to add a condition, there's no dumplicate elements
23:32:51 <int-e> groupBy just isn't useful for this task, except for the above ad-hoc trick that really only works fomr the successor relation.
23:33:06 <int-e> the lack of duplicates doesn't really change that much
23:33:57 <sicklork1n> i'm surprise that Data.List.Split doesn't have anuything useful for this use case either.  I remember runnign into this when I wanted to split ACamelCaseString into it's parts.
23:35:30 <liiae`> sicklork1n: Data.List lacks a lot
23:35:58 <liiae`> this is a simple task, I thought that I can use Data.List to do it
23:37:52 <liiae`> int-e: when the list isn't continuous, my code work
23:38:42 <liiae`> is a function to check a list if it's continuous?
23:38:47 <liiae`> is there
23:41:49 <ja> what does continous mean? isn't it in opposition to discrete?
23:42:16 <int-e> liiae` wants runs of consecutive integers
23:43:18 <ja> aah like strict monotonic but not skipping anything
23:43:48 <liiae`> ja consecutive 
23:44:17 <gust> Is it possible to pattern match a named function (i.e. (a->a)) in another function?
23:44:38 <Cale> no
23:44:48 <Cale> You can only match against data constructors
23:45:02 <Cale> Well, you can match a function against a variable pattern of course
23:45:06 <Cale> or against a wildcard
23:45:19 <Cale> but it's not possible to distinguish that the argument is a particular function at runtime
23:45:31 <gust> variable pattern?
23:46:49 <Cale> foo f = f 5
23:47:09 <Cale>     ^-- this thing
23:47:15 <gust> ah yes
23:48:15 <gust> I wanted a function to take another function as a parameter, and do something something else only when this function turns out to be `f` (as opposed to any other function that could fit the typing)
23:48:19 <int-e> > let bar f = map (map fst) . groupBy (const (uncurry (flip f))) . ap zip (undefined :) in bar (<) [1,2,4,2,5,6,3,1]
23:48:21 <lambdabot>  [[1,2,4],[2,5,6],[3],[1]]
23:48:34 <int-e> (another way to abuse `groupBy`)
23:48:41 <frobnicator> gust: this is problematic for purity
23:49:24 <frobnicator> fun f i = if (isG f) then 42 else f i
23:49:32 <frobnicator> g i = i
23:49:35 <int-e> > let bar f = map (map fst) . groupBy (const (uncurry (flip f))) . ap zip (undefined :) in bar (\a b -> a + 1 == b) [1,2,3,5,7,8,9,10,11]
23:49:36 <Cale> We usually want it to be the case that whenever f x = g x for all x, then f = g
23:49:36 <gust> something like that yeah
23:49:37 <lambdabot>  [[1,2,3],[5],[7,8,9,10,11]]
23:49:47 <frobnicator> then fun (\x->x) 5 would have a different outcome than fun g 5
23:50:08 <gust> hmpppph i see what you mean. that makes sense
23:50:17 <Cale> i.e. if two functions produce the same results for every element of their domain, then they are equal, and you can substitute one with the other freely anywhere without changing what the program does
23:50:25 <ja> gust: you could just also wrap the f param in a new datatype?
23:50:28 <Cale> (though it may affect efficiency of course)
23:50:39 <ja> then you can match on that
23:51:09 <Cale> Usually the thing to do is to make a datatype which reflects the special cases, yeah
23:52:03 <int-e> (hmm, does anybody use `ap` as the S combinator unironically?)
23:52:26 <frobnicator> i have seen trickery like this though (not in haskell but clean)  comp3
23:52:31 <frobnicator> https://cloogle.org/src/#StdEnv/StdGeneric;icl;line=41
23:52:35 <int-e> I've come close but so far I've always thought that nobody would be able to read the resulting code :)
23:52:39 <gust> well thank you all for suggestions
23:52:48 <frobnicator> where it checks whether it is `id` so to optimize for an extra function call or something
23:53:05 <int-e> So I limit this to pointless exercises with lambdabot.
23:54:03 <sicklork1n> int-e: I'm going to use that first `bar` you wrote as a opening interview question.. How much time do you think someone needs to figure out what the output would be? 60s? 
23:54:51 <int-e> sicklork1n: uhm. I'm not sure I'd figure it out that quickly without context.
23:55:05 <int-e> this stuff is easier to write than read
23:55:08 <int-e> *to read
23:56:23 <sicklork1n> int-e: :P perhaps my sarcasm was unnoticed
23:56:32 <int-e> sicklork1n: ah, yes it was.
23:58:31 <int-e> sicklork1n: it's not a totally unreasonable puzzle but only if you do it to test things like decomposing the function into its three parts (because its a function composition) and analyzing each part separately. And the `ap` is really quite obscure and, more importantly, useless in practice.
