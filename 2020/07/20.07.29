00:47:16 * dminuoso wishes some way to amend an export list in TH :(
00:47:53 <dminuoso> So far, it seems like if you want to generate exportable identifiers in TH in bulk, you better move that into a separate module and not specify an export list.. that's a bit sad.
00:48:04 <dminuoso> (e.g. exporting generated lenses/prisms)
00:56:55 <mniip> dminuoso, yup that hurts
00:59:47 <typetetris> Are there some general recommodations, how to tune the GC if using `-threaded` ?
01:06:57 <terribleArtist> bit of an odd question, but can someone try installing pontarius-xmpp? mines saying it has the wrong version of lens-family and i dont konw if its something im doing or just nixos
01:07:27 <dminuoso> terribleArtist: installing how
01:07:59 <terribleArtist> i was doing it with nix, but I guess with your manager of choice?
01:08:18 <dminuoso> terribleArtist: What command did you invoke exactly, and whats the full error message?
01:08:45 <dminuoso> Looking at at pontarius-xmpp.cabal the dependency to lens-family is unbounded, so I'm not quite sure what kind of error you are getting
01:11:19 <terribleArtist> https://gist.github.com/techieAgnostic/7f891440a89928396392f5bba777c097
01:11:30 <terribleArtist> im running nix-shell --pure with that shell.nix and getting that result
01:14:32 <dminuoso> terribleArtist: nixpkgs has lens-family 2.0.0, only
01:14:36 <dminuoso> (well and 2.1)
01:15:08 <dminuoso> So pontarius-xmpp at version 0.5.6.3 requires lens-family < 1.3
01:16:08 <fendor> can I specify in cabal.project a flag based on compile version?
01:16:11 <fendor> *compiler
01:17:55 <dminuoso> terribleArtist: You could try overriding lens-family with callHackage
01:19:09 <dminuoso> overrides = { "lens-family" = pkgs.haskellPackages.callHackage "lens-family" "1.2.3" {}; };
01:19:58 <dminuoso> (The bound was introduced later, which is why I think pontarius-xmpp is incompatible with the newer versions of lens-family)
01:23:30 <dminuoso> Also, file a bug report with nixpkgs :)
01:23:36 <dminuoso> Perhaps even with a PR to fix this?
02:42:44 <dexterfoo> I am using cabal to build a Haskell exe that links to a .a library. when i update my .a library file and run "cabal build" then it doesn't detect the change and does nothing. how do i force cabal to relink?
02:43:53 <phadej> use cabal-install-3.4.0.0 https://mail.haskell.org/pipermail/cabal-devel/2020-July/010484.html and add your .a file to extra-source-files (I assume you have somehow manually/externally produced the .a archive)
02:44:39 <phadej> I'm not sure it will make GHC relink though. Maybe.
02:58:02 <dexterfoo> thank you
03:16:08 <whataday> Reader f >>= g = \a -> g (f a) a
03:16:24 <whataday> Cont f >>= g = \ar -> f (\a -> g a ar)
03:17:04 <whataday> f :: e-> a; g :: a -> (e-> b); f >>= g :: e-> b
03:17:39 <whataday> f :: (e->a)->a; g :: a -> (e->b) -> b; f >>= g :: (e->b)->b right?
03:18:31 <whataday> Reader (e->) is monad, Cont (e->a)-> is monad?
03:31:54 <whataday> can we just use functions to express them without structures like Reader r a or Cont r a?
03:32:27 <whataday> :t runReaderT
03:32:28 <lambdabot> ReaderT r m a -> r -> m a
03:32:50 <whataday> :t runContT
03:32:51 <lambdabot> forall k (r :: k) (m :: k -> *) a. ContT r m a -> (a -> m r) -> m r
04:12:18 <solonarv> whataday: sure, you can; but it's much less convenient
04:13:49 <whataday> solonarv so we can implement bindCont bindReader bindWriter in function form in any other languages?
04:16:03 <solonarv> well, you might have some trouble giving them the right types
04:16:07 <solonarv> but in principle, yes
04:21:30 <joncol> :q
04:21:31 <joncol> :q
04:21:46 <int-e> not-vi
04:28:46 <jonathanx> is there an easy way to check if all code in a project is formatted with ormolu? (I guess I can hack sth together with bash, but I'm not too comfortable with it)
04:37:16 <typetetris> Is it possible to get a stack trace with something like `HasCallStack` for a `blocked in stm transaction` exception?
04:37:49 <solonarv> if you compile with profiling and enable RTS options, you can tell the RTS to print a stack trace whenever an exception is thrown
04:40:06 <thblt> typetetris: the ormolu doc suggests ormolu --mode inplace $(find . -name '*.hs') but I have no idea how it behaves on invalid input.
04:40:35 <thblt> jonathanx: ^ sorry wrong nick
04:41:28 <thblt> If you just want to check: --mode check
04:43:02 <jonathanx> thblt: thanks!
04:46:06 <L29Ah> how do i check whether a lazy bytestring is at least N bytes long w/o forcing its whole tail?
04:49:12 <solonarv> L29Ah: how about Data.ByteString.Lazy.null (Data.ByteString.take n input) ?
04:52:07 <L29Ah> sounds expensive, but okay
04:52:08 <L29Ah> thanks
04:52:31 <L29Ah> // seems like the safe indexing function is still in the pull requests for bytestring :/
04:52:43 <solonarv> it's not particularly expensive
04:53:04 <solonarv> 'Data.ByteString.Lazy.take' is properly lazy
04:53:13 <solonarv> (and that's the function I actually meant, I made a typo)
04:53:34 <L29Ah> you meant drop in fact
04:53:42 <solonarv> oh oops
04:53:49 <solonarv> well, you get the idea, hopefully
05:11:18 <Orbstheorem> How can I derive some methods using newtype, but manually specify the others ?
05:15:04 <L29Ah> call the method for the wrapped value?
05:19:34 <solonarv> step 1: make GHC write the derived instance and pass -ddump-deriv to GHC (that will output the generated instance)
05:20:07 <solonarv> step 2: copy-paste output into your source file and remove 'deriving' clause
05:20:15 <solonarv> step 3: modify as you see fit
05:21:06 <solonarv> (step 2.5: enable a bunch of language extensions, GHC will probably tell you which ones)
05:36:33 <Cheery> [6~
05:40:21 <Orbstheorem> I ended up manually unwrapping and calling the wrapped functions.
05:40:36 <Cheery> Orbstheorem: where?
05:41:11 <Cheery> it sounds like a problem where I could help actually.
05:42:10 <Orbstheorem> https://paste.gnugen.ch/raw/wZrH
05:43:11 <typetetris> Can I get stack traces of all haskell threads by the RTS somehow?
05:43:23 <typetetris> Not just, where an exeception originated.
06:10:02 <Axman6> typetetris: catch the exception, rethrow to ALL of them, mwahahaha
06:14:09 <Cheery> Orbstheorem: well there it seems like I'm not able to help. I thought you had problem with manual wrapping/unwrapping things.
06:24:34 <Orbstheorem> It's alright, thanks anyways ^^
06:27:19 <merijn> Orbstheorem: "fooMethod (Foo x) = Foo (fooMethod x)" is easy enough without any fancy nonsense :p
06:27:37 <merijn> Like, that's basically what generalised newtype deriving does :p
06:30:28 <Orbstheorem> Yeah, it's fine... it's alright... 
06:32:28 <L29Ah> what would be a simple way to pass a list of numbers from C into Haskell?
06:32:46 <merijn> As an array
06:33:21 <merijn> Which is really the only way
06:33:26 <L29Ah> array has a fixed size, while the knowledge of the length of the numbers is only becoming available at the C side in the runtime
06:33:53 <merijn> That's what malloc exists for
06:34:05 <L29Ah> should i malloc in c and free in haskell?
06:34:17 <merijn> That, or malloc in Haskell and free in Haskell
06:55:54 <typetetris> profiling and `-xc` sooo nice
06:56:22 <typetetris> profiling and `-xc` sooo nice
06:56:29 <typetetris> oops sorry
07:14:18 <ezzieyguywuf> infinisil: Axman6: thanks for your thoughts on NonEmpty yesterday.
07:24:00 <jchia_> Does GHC have the equivalent of GCC's -march and -mtune?
07:24:54 <jchia_> If not, what microarchitecture target for x86-64?
07:25:35 <dminuoso> jchia_: -optlc and -optlo perhaps?
07:25:49 <dminuoso> (Im not familiar with llvm, so you'll have to dig up equivalents for them)
07:27:31 <jchia_> dminuoso: Do you mean after selecting the LLVM backend? What about with the regular backend?
07:28:38 <dminuoso> jchia_: No idea.
07:29:01 <dminuoso> Chances are, if you want to control performance anyway, the llvm backend might give you better performance characteristics.
07:34:33 <jchia_> I'm wondering how much performance I can get from building GHC from source using LLVM backend and microarchitecture-specific optimization.
07:37:49 <dminuoso> jchia_: LLVM itself can give a large boost to some numeric libraries. I dont think I've heard stories about poorer performance, it's just slower (and incurs an extra dependency)
07:38:06 <dminuoso> And you can pass march and mcpu to LLVM through the above flags probably.
07:38:16 <dminuoso> Give it a try and tell me how it went?
07:38:17 <jchia_> diminuoso: I mean how much more performance
07:38:20 <jchia_> i'm trying to make ghc faster
07:38:27 <jchia_> i'm about to
07:38:39 <dminuoso> jchia_: That is impossible to predict.
07:41:11 <merijn> jchia: "probably not a lot"
07:41:25 <merijn> The LLVM backend is generally slower than the native backend for non-numerical code
07:42:19 <jchia_> merijn: Are you talking about the build process or resulting binary?
07:42:37 <merijn> the resulting binary
08:12:22 <jumper149> Where can I find a list of all major GHC releases? I want to set up Travis CI for my project.
08:12:47 <merijn> jumper149: Define "all"
08:13:15 <jumper149> I found some wiki page saying ghc-x.y.1 with y even is a major release
08:13:24 <phadej> https://matrix.hackage.haskell.org/#/package/echo
08:13:27 <phadej> is good start
08:13:38 <phadej> 8.8.3 -> 8.8.4 is recent update which is not yet on matrix
08:13:46 <merijn> jumper149: odd numbers of y are reserved for development versions, yes
08:14:47 <jumper149> Is there still active development for 8.8.x? Even though 8.10.1 is already out?
08:15:01 <merijn> Not really
08:15:14 <phadej> apt-cache search '^ghc-' works well if you use https://launchpad.net/~hvr/+archive/ubuntu/ghc
08:15:20 <merijn> Sometimes there's minor bugfix releases, but those aren't very frequent and only for really bad bugs/issues
08:15:23 <jumper149> So it's just a Hackage thing?
08:15:50 <merijn> jumper149: I generally test my stuff against 8.0 through 8.10 atm
08:15:52 <phadej> if you want to test with *all* ghc versions, you should care about 8.8.4 being released few weeks ago
08:16:06 <merijn> And for each version on the latest minor version
08:16:40 <merijn> I wouldn't bother with anything pre 8.0 or testing each bugfix version
08:17:12 <jumper149> merijn: Thanks, I will use >=8.0 for now
08:17:32 <phadej> googling "ghc-8.0.1 released" tells *when* it's released
08:17:40 <phadej> which is released 21st May 2016
08:17:43 <jumper149> Btw, are there any better alternatives to Travis regarding Haskell?
08:17:53 <merijn> You could go even newer >=8.4, but supporting 8.0 through 8.10 is usually pretty easy
08:17:59 <phadej> so you could set some time intereval for yourself and stick to thata
08:18:06 <merijn> jumper149: https://github.com/haskell-CI/haskell-ci
08:18:10 <jumper149> Building nix with Travis is really nice, but cabal seems a little more error prone
08:18:33 <merijn> jumper149: Auto generate your travis config from the cabal file ;)
08:18:34 <phadej> 8.0 is now 4 years old, so yeah. It's old-ish
08:18:51 <phadej> if it doesn't pose big problems supporting it is fine.
08:19:05 <phadej> but hopefully not many will bite you for not supporting 8.0
08:19:20 <phadej> 8.4 otoh is just two years old
08:19:25 <phadej> and that's a bit on the edge
08:19:38 <phadej> but it's in the latest stable debian
08:20:19 <jumper149> It would be nice to call haskell-ci on the fly while running the travis job, so that you wouldn't have to keep the autogenerated .travis.yml in your version control.
08:20:41 <merijn> jumper149: That can't be done with travis though, tbh
08:21:32 <Orbstheorem> Hello, I'm trying to print the String representation of a type. I'm able to use `KnownSymbol` for type-level strings, but I don't know how to constraint a kind '*' into a Symbol.
08:22:13 <phadej> Typeable :)
08:25:00 <Orbstheorem> Thanks <3
08:27:47 <sm[m]> jumper149: I find GitHub ci much nicer nowadays - simpler
08:29:02 <aquaDog> Hi, is this a good place to ask a beginner question about cabal 
08:29:41 <monochrom> yes
08:30:14 <phadej> sm[m]: github ci has a terrible flaw. You cannot restart individual jobs.
08:30:17 <aquaDog> So, I've been trying to get a basic cabal setup working, following the docs here -> https://cabal.readthedocs.io/en/latest/getting-started.html#creating-a-new-application
08:30:40 <aquaDog> It works fine if I run `cabal run` with just 'base'
08:31:09 <merijn> aquaDog: Which version of cabal-install do you have?
08:31:43 <aquaDog> But as soon as I add `haskell-say` like it's shown there, cabal run just exits with nonzero exit code
08:31:56 <sm[m]> phadej: noted, for me it hasnâ€™t been a problem
08:32:08 <aquaDog> cabal -v gives me `cabal-install version 3.0.0.0compiled using version 3.0.1.0 of the Cabal library`
08:32:53 <phadej> sm[m]: it's annoying when jobs fail because of network problems and such
08:32:56 <merijn> aquaDog: Can yoou pastebin the entire cabal file?
08:33:02 <phadej> and you have large test matrices
08:33:11 <ph88> when running  `stack text`  how to pass options to RTS of test program ?
08:33:17 <sm[m]> phadej: Iâ€™m sure
08:33:41 <sm[m]> Can you split it up into multiple workflows ?
08:35:45 <aquaDog> merijn:https://pastebin.com/Cvh1KESz
08:36:16 <aquaDog> I haven't changed anything tbh, I've just added 'haskell-say' like the cabal docs say 
08:36:24 <phadej> sm[m]: yes, but then you cannot have intrajobs dependencies
08:36:29 <sm[m]> ph88: stack test â€”ghc-options=â€˜+RTS ... -RTSâ€™ ... ? Just a guess, could be wrong
08:36:33 <phadej> sm[m]: which is one feature I miss from travis
08:36:42 <phadej> e.g. have one job "if this fails, it's pointless to run the rest"
08:37:03 <sm[m]> phadej: yes. Maybe they have and issue open and are working on it
08:37:16 <phadej> sm[m]: yes, there is issue, nope, they are not working on it
08:37:36 <ph88> sm[m], --ghc-options is for the compiler.. i think i just found it for the RTS you can pass --test-arguments
08:37:37 <phadej> https://github.community/t/ability-to-rerun-just-a-single-job-in-a-workflow/17234
08:37:55 <sm[m]> ph88: +1
08:38:12 <aquaDog> merijn: https://pastebin.com/Cvh1KESz
08:38:13 <phadej> https://github.community/t/re-run-jobs/16145/5 another one
08:39:41 <phadej> I only use github actions because its' free and offers somewhat sane macos and windows options
08:40:09 <phadej> but for haskell libraries, appveyor + travis feels to be better option when it's enough.
08:40:17 <merijn> aquaDog: ah, you should be getting an error because you didn't specify the --cabal-version=2.4 flag when you ran init
08:40:38 <sm[m]> the demand seems clear, hopefully it wonâ€™t be much longer
08:40:40 <phadej> given that haskell-ci exists and produces .travis.yml)
08:40:43 <merijn> aquaDog: The file lists cabal version 1.10, but you're using the ^>= syntax from the docs, which is not valid in 1.10
08:41:06 <aquaDog> merijn: But why would `cabal run` run fine before I made any changes. 
08:41:07 <aquaDog> Ah
08:41:26 <merijn> aquaDog: Because it was valid before you added the ^>= ;)
08:41:26 <sm[m]> phadej, for normal basic ci GitHub just means fewer moving parts for most people
08:42:11 <phadej> sm[m]: copying workflow files? :)
08:42:15 <merijn> sm[m]: More importantly, github actions can build binaries and make them available *and* is considerably faster than travis
08:42:30 <phadej> anyway, haskell-ci will support github actions when they implement job restart
08:42:40 <phadej> as generating N files is not really an option
08:43:06 <sm[m]> merijn, indeed
08:44:30 <phadej> travis offers arm builders ;)
08:45:03 <sm[m]> advantage travis! Not for too long though
08:45:22 <phadej> anyway, soon github will be only option, like facebook, but for code
08:45:31 * phadej dislikes
08:45:59 <sm[m]> I hear that
08:47:08 <merijn> I'm sure Pijul Nest will be done any moment now ;)
08:47:15 <phadej> merijn: lol
08:47:34 <sm[m]> but as long as they keep making my life simpler without too much lock-in or anti user behaviour, Iâ€™m happy
08:48:06 <merijn> phadej: I prefer Github to many other "free" websites, because at least I understand their business model and how it makes sense
08:48:50 <phadej> I understand the business model behind provider running oleg.fi, I pay them real money!
08:48:56 <merijn> They're business model obviously being "integrate deeply with Azure and upsell you enterprise github/azure offerings, allowing all the free open source leeches as loss leader for when they work in the real world where people have money"
08:49:01 <aquaDog> merijn: Thanks!, finally works. I've been trying all sorts of tweaks to the cabal file for an hour now. 
08:49:11 <merijn> aquaDog: np
08:49:20 <sm[m]> merijn: uh.. what is it, again ?
08:49:36 <merijn> aquaDog: Are you sure you don't get an error message?
08:49:42 <sm[m]> Ah
08:50:27 <aquaDog> merijn: Nope, it works fine if I do cabal init with --cabal-version=2.4
08:50:37 <merijn> sm[m]: Let's face it, open source/students/hobby coders will never pay for stuff and if you get them all on board they won't wanna use anything else when they move into the real world. It's a pretty sensible and solid strategy
08:51:02 <merijn> aquaDog: That's weird, I'm sure I get an error about incompatible cabal versions on my machine, then again I'm on 3.2, so maybe that's when that warning was added
08:51:08 <merijn> phadej: Do you know?
08:51:14 <ocharles> I am very confused, but I have `{-# OPTIONS_GHC -ddump-simpl -dsuppress-all #-}` in one of my modules and when I build I get core (expected), but nothing is suppressed (I see loads of junk like [GblId[DataConWrapper])
08:51:25 <ocharles> What am I missing? Is this just broken in GHC 8.10 or something? I swear this used to work
08:51:36 <srk> I'm working on https://github.com/sorki/git-post-receive/ to be able to run my own git hooks .. and a CI
08:53:02 <aquaDog> merin: Yeah, `cabal -V` says `3.0.0.0`, but the cabal file has `cabal-version: 2.4` and it seems to work fine. Should it not?
08:53:14 <phadej> merijn: the strategy is fine, it's just sad there aren't really an option
08:53:27 <merijn> phadej: I meant the lack of cabal warning :)
08:53:50 <merijn> phadej: I recall seeing warnings when using ^>= with older cabal-version specifiers, but apparently aquadoc is not?
08:54:01 <monochrom> Beginners usually ignore error messages and don't tell you they got error messages.
08:54:19 <merijn> monochrom: Well, I did explicitly ask and was told "no" :)
08:54:24 <phadej> I'm not giving cabal troubleshooting, if the code is not posted somewhere with precise cabal-versions and outputs
08:54:32 <phadej> I'm tired of guessing people's problems
08:54:45 <monochrom> That's what I did too.
08:55:00 <phadej> s/cabal-versions/tool versions/
08:55:08 <merijn> aquaDog: Anyway, the "cabal-version:" field is just to specify the format used by the file, the executable is backwards compatible with all versions
08:55:27 <alehander92> do people use nix a lot
08:56:13 <alehander92> i am preparing a small project for a job candidacy, and I wonder if people use nix *instead* of stack/cabal, or additionally
08:56:19 <phadej> nix is way of life
08:56:29 <ph88> I have a quickcheck test that is running out of memory. When i pass the -hd flag for profiling and then pass the output to hd2pretty i see a lot of memory is allocated by :    (colon),  how do i see data constructor names instead ?
08:56:45 <phadej> : is data constructor name :)
08:56:51 <phadej> of a list
08:57:08 <merijn> alehander92: *some* people use nix a lot
08:57:18 <Taneb> alehander92: I use it additionally
08:57:19 <merijn> alehander92: It's probably far from the majority here, though
08:57:29 <merijn> alehander92: I'm happy with just v2-build
08:57:56 <ddellacosta> alehander92: I'm actually not sure how you'd use nix without stack or cabal to work on a haskell project, at least
08:58:02 <alehander92> and also, can one run unit (example-based) tests with quickcheck
08:58:05 <ddellacosta> assuming I understand your question
08:58:07 <merijn> aquaDog: Out of curiosity, if you do "cabal build" (no arguments) instead of cabal run, what happens with the wrong file?
08:58:19 <alehander92> or do I need to use both HUnit and quickcheck if I want both example and property tests
08:58:31 <sm[m]> some channels, eg #postfix, use their bot very effectively to steer support conversations, eg for gathering standard info. You lose the human touch though..
08:58:40 <aquaDog> merijn: I'm experimenting the same thing for a bit.. trying out the combinations 
08:58:59 <alehander92> merijn: it makes sense, I'd still use it probably
08:59:14 <merijn> alehander92: There's several test frameworks that other libraries can hook into
08:59:40 <alehander92> ddellacosta: makes sense, so stack or cabal is more .. idiomatic?
08:59:45 <monochrom> merijn: I think my reproduction gives a 10-line wall of error message.
08:59:51 <merijn> alehander92: For example tasty, which takes care of grouping tests, reporting output, etc. and then there's plugins/handlers for quickcheck, hunit, etc. that hook into tasty
09:00:25 <alehander92> ok, so I define my tests in hunit, quickcheck and tasty makes running/output more cohesive?
09:00:37 <ddellacosta> alehander92: no what I'm saying is, the reason folks use nix in haskell-land at least is that it provides benefits above and beyond just stack or cabal. You can easily control your ghc version for example, can include other non-Haskell dependencies in a predictable fashion, etc.
09:00:49 <ddellacosta> I mean I guess that overlaps with stack
09:01:01 <merijn> alehander92: You have tasty-quickcheck and tasty-hunit that provide the necessary glue code
09:01:04 <alehander92> yes: that's why I need to use it, I wondered if basing my nix setup on cabal or stack was smarter
09:01:05 <aquaDog> merijn: Well, when `cabal-version` is 1.10 with the `^>=` syntax, every command just exits with exitcode 1, I don't see any errors at all. 
09:01:12 <ddellacosta> (I'm not super familiar with stack, others can probably state what benefits nix gives above and beyond what is default there)
09:01:29 <alehander92> the reproducability is usually what people like
09:01:39 <sm[m]> you can use stack with just a little nix mixed in (the nix support in stack.yaml). Or go full nix.
09:01:45 <aquaDog> That's why I has no idea where to look, I was fiddling with the file thinking cabal couldn't parse it, maybe I missed a command or something 
09:02:00 <monochrom> ocharles: I can't reproduce the problem, versions 8.6-8.10. the -dsuppress-all was effective, I didn't get junk.
09:02:02 <jumper149> alehander92: I have used nix and cabal a lot lately and never felt the need for stack.
09:02:10 <ocharles> monochrom: man, weird
09:02:18 <alehander92> merijn : thanks. and do people bother writing example-based tests if they have good quickcheck tests? 
09:02:38 <merijn> alehander92: It Depends (TM)
09:02:45 <ddellacosta> alehander92: yeah to echo what jumper149 says I feel like cabal is a more natural complement to nix considering what stack provides, but I also have a buddy who uses stack and nix by default and loves the combo
09:02:47 <maerwald> jumper149: the main difference is nix can handle system libraries... but honestly... it's not difficult to install them without it :p
09:03:07 <merijn> aquaDog: With 3.2 and your cabal file I get this when I run "cabal build": https://paste.debian.net/1158196/
09:03:10 <ocharles> Something is definitely up. If I move `-dsuppress-all` to my Cabal ghc-options it's good. I gueuss I'll go with that for now
09:03:26 <alehander92> i see, and if i want linux/windows support, does cabal or stack have any problems with that
09:03:35 <merijn> aquaDog: Which, presumably, would've saved you a lot of time :)
09:03:57 <ddellacosta> alehander92: linux definitely is great to work with. Haskell and Windows has other problems, from what I hear, but I am not a Windows user so dunno really
09:03:57 <sm[m]> alehander92: stack is especially good at windows support
09:04:02 <merijn> aquaDog: You can try updating your cabal-install to 3.2 and see if it works then
09:04:07 <merijn> (the error, I mean)
09:04:16 <aquaDog> merijn: I didn't install cabal seperately though, it just came with the haskell-platform 
09:04:54 <merijn> anyhoo, gotta run
09:05:04 <alehander92> ddellacosta sm[m] : thanks! I'd probably just try stack + nix for now
09:05:07 <aquaDog> merijn: Thanks for the help, I should probably update it
09:05:24 <ddellacosta> alehander92: good luck!
09:07:33 <alehander92> merijn : ok, last one, is HSpec or HUnit more well received?
09:07:38 <monochrom> 3.0 gave the same error message.
09:07:48 <ph88> phadej, can i break down the graph by where  : is called ?
09:08:51 <phadej> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/profiling.html#rts-options-for-heap-profiling
09:09:15 <ph88> yes i read that, i was already planning to try call site
09:09:44 <ddellacosta> folks random basic question about file handles and hGetContents--is it bad practice to call re-open on a handle after calling hGetContents, which puts it in a semi-closed state apparently? Is there a more appropriate approach? I have to read and then write to a file handle and I'm ending up opening it multiple times, which seems to work but feels gross
09:10:29 <davean> ddellacosta: why are you closing it?
09:10:37 <ph88> phadej, i think -fprof-auto-calls to put it on callsites and then -hd to break down by data constructor, is that right ?
09:10:43 <ddellacosta> davean: hGetContents is what is closing it
09:10:54 <ddellacosta> I mean, maybe I need to not use hGetContents
09:10:54 <davean> ddellacosta: why are you using hGetContents though?
09:10:55 <monochrom> hGetContents semi-closes it (and eventually closes it when EOF)
09:11:09 <ddellacosta> davean: er...so I can easily get the contents from the file?
09:11:12 <davean> If you want it open, why use a function that closes it?
09:11:16 <davean> ddellacosta: ypi
09:11:23 <davean> ddellacosta: you're going to write to that file though, right?
09:12:12 <mniip> use a custom loop
09:12:35 <ddellacosta> mniip: gotcha, so folks tend to loop through vs. using hGetContents, is that right?? 
09:12:47 <davean> ddellacosta: How do you know what your'e going to read if you're hGetContentsing?
09:13:17 <mniip> folks usually don't write to the same file they've read from
09:13:27 <davean> Right, and theres an ordering issue here
09:13:36 <monochrom> unless the handle is a socket
09:13:45 <monochrom> or front of a socket
09:13:50 <mniip> that's almost two files :)
09:13:52 <davean> You've said nothing that makes me think you know what you're reading
09:14:19 <ddellacosta> Yeah I'm reading a data structure from a file, then my goal is to essentially completely replace that with an updated version. Sounds like folks would do that some other way: what is that other way?
09:14:20 <monochrom> still, hGetContents will semi-close it and not care
09:14:59 <davean> ddellacosta: well, I want to point out your system *might not work at all* never mind there being a better way
09:15:07 <mniip> ddellacosta, is it important that this is done with a single filehandle?
09:15:20 <davean> But safety would say you want to atomicly replace the file
09:15:31 <davean> which one does via rename on most systems
09:15:37 <ph88> phadej, i tried these options, but i don't get the split by call site line ..
09:15:38 <ddellacosta> mniip: not necessarily, and I'm using two separate filehandles now actually. It just seems messy in particular because I want the first open in ReadWriteMode to trigger creation if the file doesn't exist
09:16:18 <davean> oh, so your'e nto rewriting the file, just creating it if it doesn't exist?
09:16:23 <davean> thats much less troubling.
09:18:25 <mniip> hmm, C can do O_CREAT|O_RDONLY, guess haskell can't
09:18:44 <davean> mniip: it can via the "unix" package
09:18:59 <ddellacosta> alright well, sounds like the way I'm doing it now (opening the file handle twice, once for my initial read and default creation, once again to overwrite the contents) is probably the way to do it, barring any other better ideas. Thanks
09:19:05 <mniip> right, makes sense that this is platform dependent
09:19:09 <davean> ddellacosta: no no
09:19:17 <davean> if you're overwriting it you're potentially back to the problem I keep saying
09:19:27 <ph88> does anyone know how to get the call site with profiling ? i don't get line numbers
09:20:12 <ddellacosta> davean: if you have something useful to share go for it. Otherwise I'll I'm hearing from you is "you're doing it wrong"
09:20:28 <davean> ddellacosta: I keep saying how do you know what you're reading?
09:20:48 <ddellacosta> davean: how do you think I know what I'm reading, and why does it even matter?
09:20:49 <davean> "16:13:05 davean Right, and theres an ordering issue here"
09:21:01 <davean> ddellacosta: Because you're writing to it.
09:21:10 <davean> ddellacosta: how much of the read is before, and how much after the write?
09:21:17 <davean> How do you make sure you're done reading before the write happens?
09:21:33 <ddellacosta> I open the file, read from it, update a cache, overwrite the file with the updated cache, close it. What's the ordering problem?
09:21:46 <davean> Haskell is a lazy language
09:21:49 <ddellacosta> granted, I'm opening/reading/closing/opening/writing/closing right now
09:21:50 <davean> Prelude System.IO> h <- openFile "/dev/mem" ReadMode
09:21:50 <mniip> are you using a lazy IO function?
09:21:53 <davean> Prelude System.IO> c <- hGetContents h
09:21:59 <davean> I didn't just read my entire system's memory
09:22:11 <davean> hGetContents is lazy
09:22:25 <davean> Thats *why* its semi-closed
09:22:46 <davean> That is the nature of its semiclosedness
09:23:01 <ddellacosta> right and the value I need is read and dealt with before I close the file. I know this
09:23:15 <davean> If you're sure it ACTUALLY is dealth with
09:23:45 <ddellacosta> lol
09:24:00 <davean> You can DEFINATELY start writing the cache out before you're done updating the cache in many many situations
09:24:12 <ddellacosta> anyways, I appreciate the attempt at help. Will keep poking at it and try some different approaches
09:25:17 <whataday> IO a can not be isomorphic to any type, right? 'cause there's no IO a -> a
09:25:24 <alehander92> how do people solve those ordering problems
09:25:41 <alehander92> isn't there a way to express "this is evaluated before that"
09:25:52 <davean> alehander92: Theres ways to explicitely force data, or doing rename like writing files safely needs anyway, or ...
09:26:12 <davean> alehander92: 'deepseq' forces, if they're the right types
09:26:43 <alehander92> ok, so the laziness isn't a big issue for IO/networking correctness
09:26:47 <alehander92> i hope
09:27:06 <davean> alehander92: Hum, not sure what you mean
09:27:12 <mniip> step 1: don't use lazy IO
09:27:37 <davean> I mean lazy IO is fine for a number of cases. memmap is basicly lazy IO for C
09:27:39 <mniip> lazy IO is a quick "default" solution
09:27:56 <davean> You just have to know that its lazy and fence everyt\hing
09:28:06 <davean> same as with multithreaded programming
09:28:14 <davean> Its almost exactly the same problem
09:28:21 <mniip> if you're making something big then you have to make an informed choice about how your IO works
09:28:24 <alehander92> i see, but the point is that i want the language to make it hard for me to make some bugs
09:28:31 <alehander92> same with multithreading
09:28:42 <davean> alehander92: So don't use lazy IO options
09:28:52 <mniip> also String IO bad
09:29:11 <davean> alehander92: this isn't a language issue, its a library one
09:29:19 <mniip> it's all one issue
09:29:30 <alehander92> do most people really use Text instead of String
09:29:37 <mniip> there needs to be a "quick and dirty" "default" solution suitable for prototyping 
09:29:47 <mniip> alehander92, you're reading from a file, the file contains bytes
09:30:00 <mniip> make an informed decision about how you're encoding/decoding it
09:30:10 <davean> alehander92: EVERYONE
09:30:16 <davean> alehander92: No one I know of uses String
09:30:18 <alehander92> yeah, of course: I am talking about more indirect usage
09:30:38 <davean> String is cancer
09:30:40 <alehander92> ok, that's good to know
09:31:08 <davean> String is good for teaching programming, maybe
09:31:18 <davean> its conceptually fitting, but not very sensible.
09:31:20 <mniip> davean, does anything use non-String filenames though?
09:31:24 <davean> mniip: yes
09:31:28 <mniip> oh?
09:31:48 <davean> mniip: Correct POSIX filenames are ByteString based and I use that everywhere
09:32:10 <mniip> ah, RawFilePath from unix
09:32:14 <davean> 'base' lacks correct filename handling, but its available
09:32:15 <alehander92> thanks, I'll start working on my stuff today
09:32:36 <alehander92> and I'll see how this all goes
09:32:49 <davean> mniip: its annoying
09:33:00 <davean> Thats probably the weakest part of the Haskell ecosystem I've encountered
09:33:18 <mniip> davean, it's not so black and white though
09:33:31 <mniip> "quick and dirty" defaults have their use
09:33:39 <davean> Yah
09:33:50 <davean> I just wish we had a system that allowed one to use what was appropriate
09:34:10 <davean> Of course ALL those functions would have to have been typeclassed for that ...
09:34:34 <mniip> ah but not all of them have the same interface
09:34:39 <davean> Right
09:34:51 <davean> and we don't have auto-type-conversion
09:34:56 <davean> well, we do, but very limitedly
09:35:15 <davean> We don't have a general transparent type class conversion story
09:35:27 <davean> Probably don't want oen
09:35:41 <mniip> probably not. it's messy
09:35:59 <mniip> homotopy people are still struggling with it
09:36:05 <davean> But it leaves us not having a clean way to fix "easy" solutions when they don't work
09:37:11 <davean> Mind you I don't think thats all bad. It just leaves a valley between "quick easy scripts" and "production grade" programs where they look very dissimilar
09:37:14 <dminuoso> Can someone help me understand how to understand this fundep diagnostic? https://gist.github.com/dminuoso/2cded078d48e48b63fd5f63307987c5f
09:37:39 <dminuoso> I understand what I did wrong, but I cant for my life figure out how I could have arrived at that knowledge from this error message.
09:38:16 <davean> â€˜MonadReader (CompEnv Stg1Env) (Comp (CompEnv Stg1Env))â€™
09:38:47 <davean> class Monad m => MonadReader r m | m -> r where
09:39:26 <davean> MonadReader (CompEnv e) (Comp e)
09:39:31 <davean> See how these parts don't match up?
09:41:07 <davean> Try applying something from the first to the 'e' in the second
09:41:12 <davean> It can't match
09:41:18 <dminuoso> davean: I think there's a slight misunderstanding.
09:41:36 <davean> oh?
09:42:17 <dminuoso> So, I pretty much instantly realized, that I incorrectly type annotated the whole of it. I just dont quite understand what GHC is telling me with `arising from a functional dependency between`
09:42:29 <davean> Right, and I'm talking about that
09:42:38 <dminuoso> Mmm
09:42:46 <davean> I'm going through and deriving that you claimed CompEnv Stg1Env == Stg1Env
09:42:50 <davean> and it showed that
09:43:43 <davean> Do you know what a fucntional dependency *is*?
09:43:49 <davean> That might explain the problem if you don't
09:43:54 <dminuoso> Maybe the word `between` is confusing me. I thought a functional dependency was between two types in a constraint. But GHC suggests there's a dependency between a constraint and some instance.
09:44:07 <dminuoso> Let me explain what Im seeing
09:44:10 <davean> dminuoso: "between" means they're in conflict (and derive a contradiction)
09:44:14 <dolio> Homotopy stuff has nothing to do with different operating systems having subtly different file path semantics.
09:44:26 <dminuoso>  arising from a functional dependency between:
09:44:27 <davean> the constraint and the instance are in conflict
09:44:29 <sm[m]> I think davean had an extra cup of coffee this morning :)
09:44:29 <dminuoso> 1) constraint ...
09:44:35 <dminuoso> 2) instance ...
09:44:42 <dminuoso> davean: Am I making sense here?
09:44:51 <davean> dminuoso: Right, and they're in conflict
09:45:02 <davean> the constraint makes a claim about *all* instances
09:45:12 <dminuoso> Ohh.
09:45:20 <davean> "for every instance there will only ever be one e for an m"
09:45:34 <davean> Thats what "functional" is here
09:45:43 <davean> it is a function of m
09:45:47 <davean> sm[m]: too fast?
09:46:06 <sm[m]> "String is cancer!" and all the rest :)
09:48:02 <sm[m]> dare I say I don't always use Text, sometimes there's no performance benefit and the ergonomics of String are what you want
09:48:36 <davean> sm[m]: There can be perforance benefits of String even
09:48:42 <davean> Its still a cancer
09:49:00 <davean> the ergonomics of Text can be the same
09:49:24 <sm[m]> but in practice they aren't 
09:50:23 <sm[m]> but you mentioned teaching programming etc, so we somewhat agree
09:50:32 <dminuoso> 18:33:29         davean | I just wish we had a system that allowed one to use what was appropriate
09:50:41 <dminuoso> Isn't that backpack though?
09:51:05 <dminuoso> Also, thank you for your explanation. Ill have to go through it, it seems I need a different intuition for fundeps for the diagnostic to make sense.
09:51:36 <dminuoso> I fully understand how fundeps work from a user perspective, but I fear that the diagnostic is as with many GHC diagnostics closer to their implementation.
09:52:08 <davean> dminuoso: I'd say closer to the type theory
09:52:19 <dminuoso> Or that, yeah.
09:52:21 <davean> dminuoso: and no, it isn't really backpack, though that does help? Maybe
09:52:38 <davean> dminuoso: So lets walk throguh it
09:53:21 <davean> dminuoso: So from the class, we have "MonadReader r m | m -> r"
09:53:34 <davean> From the instance we have "MonadReader (CompEnv e) (Comp e)"
09:53:49 <davean> Thus we must have that (Comp e) -> (CompEnv e)
09:53:51 <davean> right?
09:54:05 <dminuoso> Yes.
09:54:46 <davean> So if we apply e = Stg1Env we get "(Comp Stg1Env) -> (CompEnv Stg1Env)"
09:55:02 <davean> but we have "(Comp (CompEnv Stg1Env)) -> (CompEnv Stg1Env)"
09:55:25 <davean> Thus, we have "(CompEnv Stg1Env) -> (CompEnv (CompEnv Stg1Env))"
09:55:27 <sshine> can anyone tell me what the point is with https://input-output-hk.github.io/ouroboros-network/goblins/ ? is this for auto-generating Hedgehog generators for types by seeding it with a TypeRepMap?
09:55:47 <davean> And (CompEnv (CompEnv Stg1Env)) is not equal to (CompEnv Stg1Env)
09:55:59 <dminuoso> davean: And since it knows CompEnv to be injective (its a type constructor after all), it boils down to `CompEnv Stg1Env /~ Stg1Env` right?
09:56:20 <davean> dminuoso: we don't even need that
09:56:32 <davean> -> is a functional dependency, so it must ALWAYS have a unique result
09:56:40 <dminuoso> Ah. Right.
09:56:59 <davean> I mean you're also right, but lets not take something we don't need for our proof!
09:57:12 <dminuoso> Yup, fair enough. Carry on.
09:57:18 <davean> We're done :)
09:57:22 <davean> Its found a contradiction
09:57:33 <davean> Thus it disproved your program
09:58:20 <davean> From the top line we even know exactly how, "Couldn't match type â€˜CompEnv Stg1Envâ€™ with â€˜Stg1Envâ€™"
09:58:29 <dminuoso> davean: Is it possible, that the wording is ill-phrase and GHC should have rather said `a constradiction, arising from a functional dependency, between: some instance AND some constriant?
09:58:32 <davean> we know theres an extra CompEnv, or almost definately is
09:58:57 <dminuoso> (really, all my troubles boil down to this word "between" here)
09:59:01 <davean> dminuoso: possibly, but I don't see a difference in its wording and yours
09:59:20 <dminuoso> davean: well GHC suggests that the functional dependency is not betwene types, but a constraint and an instance. And that seems weird to me.
09:59:24 <davean> dminuoso: It created a list of where the contradictions were between
09:59:35 <dminuoso> If it told me
09:59:47 <davean> dminuoso: I mean, type level functions?
09:59:52 <dminuoso> "the functional dependency arises from this instance, and here in this constraint its violated" that would make sense to me
10:00:13 <dminuoso> but instead it tells me "the functional dependnecy between this constraint and that instance..."
10:00:19 <dminuoso> and that confuses the hell out of me
10:00:28 <davean> dminuoso: But we could put *anything* in for 'e'
10:00:48 <davean> I'nm confused by what you think is different in the wordings
10:00:50 <davean> I'm not following
10:01:07 <davean> "not betwene types"
10:01:25 <davean> but it isn't between types? Its between what you can derive from the type level functiosn you've used?
10:01:32 <davean> also your message doesn't mention types
10:01:33 <dminuoso> Let me try and visualize my thought.
10:02:00 <davean> Perhaps you didn't notice the ":" in the message creating a list of things that are in conflict?
10:02:09 <davean> I'll point out you can have any number of things in conflict
10:02:15 <davean> well, more than 1 :)
10:02:28 <davean> I suppose one thing can be in conflict with its self
10:04:03 <dminuoso> Do note, that it's not that Im disagreeing with GHC at all. Just for clarity.
10:04:08 <davean> I udnerstand
10:04:36 <davean> I just don't even understand what you think is different about your version other than you limited it to two cases, and removed the details about how rules got introduced into the context.
10:04:57 <davean> Because your version looks like a madlibbed shortened version to me with the same but less information.
10:05:15 <dminuoso> So when you say "arising from a ... <relationship> between", then I expect the sentence to follow with two things (because of the word between). I then expect that there exists a relationship between the two items listed.
10:05:25 <dminuoso> Does that, so far, make sense?
10:05:48 <x0r-255> how might one choose a random element from a type `[ [Char] ]`?
10:05:49 <davean> Yes, but two things, first of all that *is* what followes, and second between can be between >= 2 things.
10:06:04 <x0r-255> I've tried `randomColor l g = fst (randomR (0, length l) g)` to no avail
10:06:56 <davean> x0r-255: http://hackage.haskell.org/package/random-fu-0.2.7.6/docs/Data-Random-List.html#v:randomElement
10:08:18 <davean> dminuoso: a == b, b == c, c /= a, thats 3 things theres a conflict between.
10:08:54 <dminuoso> davean: Yes, but GHC is not saying "there is a conflict between these three things"
10:09:04 <dminuoso> davean: But rather "there's a functional dependency betewen"
10:09:35 <davean> dminuoso: ah and here I think I see your confusion because it *is* saying there is a conflict
10:09:43 <davean> Its just explaining WHY theres a conflict also
10:09:52 <dminuoso> davean: https://sketch.io/render/sk-82be4ff050a4daa48188009f9435c3c3.jpeg
10:09:59 <dminuoso> I hope this image conveys it better
10:10:10 <x0r-255> davean: `Could not find module â€˜Data.Random.Listâ€™`?
10:10:21 <davean> x0r-255: add the package to your project
10:10:30 <sm[m]> seems so, sshine
10:10:54 <dminuoso> Maybe it's really just a language problem, English is not my native tongue.
10:11:25 <davean> dminuoso: "Couldn't match type â€˜CompEnv Stg1Envâ€™ with â€˜Stg1Envâ€™" means "â€˜CompEnv Stg1Envâ€™ /= â€˜Stg1Envâ€™"
10:11:55 <davean> "arising from a functional dependency between:" means "because there is a functional dependency constraining the relation of the following"
10:12:40 <dminuoso> davean: Gotcha! Can you understand why I understand it the way I understand it though?
10:12:40 <davean> dminuoso: No, a lot of people have issues with them, but I don't personally think its the wording - they almsot always suggest something directly equivilent for the wording.
10:12:57 <dminuoso> That is, does my picture illustrate it?
10:14:04 <sm[m]> sshine: I see some examples at https://github.com/input-output-hk/goblins/blob/master/test/Test/Goblin/Properties.hs . Are the generated examples better somehow than random ? GUess so
10:14:21 <davean> dminuoso: Instead I think people aren't comfortable with the vocabulary and expect it to say how to fix it, but it can't because it doesn't know their intent, so they try to read it first as directions and then they can generate text once the words are primed but thats because they know what *they* mean, it wouldn't mean anything more to them if they saw it fresh later. 
10:14:29 <sm[m]> there's also https://github.com/input-output-hk/goblins-sts-breeder which "trains goblins"
10:14:39 <davean> dminuoso: Somewhat! But I'd say that that picture isn't incorrect either!
10:14:47 <davean> dminuoso: That is also whats happening!
10:14:59 <davean> And error messages are all about there *being* an ambiguity
10:15:05 <davean> so of course they're ambiguous
10:15:13 <sm[m]> ..or perhaps IOHK's real mission is to win a game of dwarf fortress.
10:15:19 <davean> They can say how, not why they occured.
10:16:12 <dminuoso> davean: You say that picture isnt incorrect either. In what sense?
10:16:20 <davean> dminuoso: I'd say this comes up a LOT with people and language - they think what they say is completely clear because tehy generated it
10:16:27 <dminuoso> Because if GHC is actually being honest from some type theory point of view, then that's the truth Im after. :)
10:16:30 <davean> dminuoso: That picture is one of the things that is happening
10:16:49 <davean> dminuoso: either the constraint needs to go, or the types need to change
10:17:07 <davean> dminuoso: So really one way to look at this is that there are 4 things in conflict with each other!
10:17:20 <dminuoso> davean: Then I stick with my opinion that the wording is off. The word `between` needs to drop.
10:18:00 <davean> dminuoso: is "amongst" better for you?
10:18:40 <davean> Its said "I've shown that these two things can't both be true", hence "between"
10:18:51 <dminuoso> davean: Yes! Amongst seems much clearer actually. :)
10:18:51 <davean> it said two things above that it used to show that
10:19:02 <davean> dminuoso: Interesting because I can't figure out the difference!
10:19:06 <dminuoso> Heh
10:19:25 <davean> dminuoso: They mean basicly identical things to me here.
10:19:28 <dminuoso> davean: Or perhaps we just need a comma after functional dependency?
10:19:47 <dminuoso> Because the "between" rather refers to a conflict, than the fundep itself.
10:20:12 <dminuoso> I need to dig up literateure on fundeps in type theory perhaps
10:21:14 <davean> dminuoso: So, one thing that might be happening here is that you've seen one piece of the conflict and decided its the only one, and thats why my saying "your image is also correct" seems in conflict with your understanding, the other is also that the comma might help.
10:22:07 <davean> I can't generate a valid parsing that isn't the one the comma makes explicite, but that doesn't mean it doesn't exist.
10:22:14 <dminuoso> davean: To me, it seems that the things listed after `between` is just items from GHCs knowledge database that is related here.
10:22:16 <davean> or that making it implicite doesn't make it harder to read
10:22:23 <dminuoso> rather than items that are related by the functional dependency declaration in the class
10:22:26 <dminuoso> does that make sense?
10:22:46 <davean> huh
10:22:49 <davean> ok, I see
10:23:06 <davean> Yah, so I can't make that parse because thats gramatically incorrect given what a fundep is
10:23:11 <davean> but thats because I *know* what a fundep is
10:23:19 <davean> if I didn't, I'd need the comma
10:23:27 <davean> that helps a lot!
10:24:32 <davean> Hum, that comma is super awkward linguisticly though there has to be a better wording
10:25:01 <davean> I don't like this at all :)
10:25:20 <davean> You've made me deeply uncomfortable in my linguistic centers, thanks.
10:25:23 <dolio> I wouldn't be surprised if the fundep-related stuff is just being pasted into an error that got rewritten in some other context.
10:25:41 <dolio> And no one looked at how it changed the fundep message.
10:26:42 <x0r-255> davean: I run `cabal install random-fu` and I get the error: `Could not find module â€˜Data.Bitsâ€™` `There are files missing in the â€˜base-4.14.0.0â€™ package,`
10:26:49 <x0r-255> how the heck do I fix this
10:27:01 <x0r-255> I tried reinstalling haskell-base
10:27:46 <glguy> x0r-255: Your base installation comes from installing GHC. If you're corrupted that package you'll need to reinstall GHC
10:27:49 <dolio> Like, '%s between: ...'.
10:28:30 <glguy> x0r-255: If it's a missing profiling file and you installed ghc from your distro, you might need to install more subpackages from your distro
10:29:03 <sm[m]> it's Arch, isn't it
10:29:31 <davean> dminuoso: so the problem with a comma comes from a thing about language - we say things in an attempt to communicate.
10:30:27 <davean> dolio: Quite probably. I mean almost assuredly
10:30:52 <dminuoso> davean: Is it possible, that you're thinking of a fundep as some sort of "constraint", call it FunC, between various items that are knowable. And that if you see `a constraint C1 here` and `that instance there`, then FunC is sort of violated?
10:31:18 <davean> dminuoso: yes
10:31:23 <dminuoso> I see
10:32:40 <dminuoso> Maybe I just tend to visualize the fundep as that arrow in the typeclass declaration, rather than say some inference rules arising from it. :p
10:32:48 <davean> which, BTW, it is
10:33:00 <davean> dminuoso: It is an axiom!
10:33:06 <dminuoso> So when I say `class C s t | s -> t` I think of the fundep as "relating s and t"
10:33:11 <dminuoso> (and nothing more)
10:33:26 <dminuoso> what do you mean by axiom here?
10:33:34 <dolio> davean: Apparently it's not that, because 'a functional dependency between' appears in 7.10. I'm not sure what the rest of the message looked like then, though.
10:33:58 <davean> dminuoso: A mathematical law that is taken as a given
10:34:17 <dminuoso> davean: Sure I understand axiom, just not what you were referring to when you said "it is an axiom"
10:34:29 <dminuoso> Oh. You mean the fundep itself becomes an axiom?
10:34:32 <davean> yes
10:34:35 <dminuoso> Oh.
10:36:00 <dminuoso> davean: Interesting, Im beginnig to understand everything you've been saying. One particular thought that came to mind, is that GHC cant even know whether the constraint was wrong.
10:36:02 <davean> and I think we fairly completely know why and how we read the message differently now.
10:36:03 <dminuoso> Perhaps the instance was!
10:36:14 <davean> dminuoso: Yep! I said that before! :)
10:36:18 <dminuoso> And rather than just guessing, it just lists all the things it knew, and tells me "go figure it out"
10:36:19 <dminuoso> Right.
10:36:23 <dminuoso> It just didnt click then. :)
10:36:36 <davean> Thats what I meant by ambiguous!
10:36:48 <dminuoso> Yeah indeed, it makes sense now.
10:37:58 <davean> dminuoso: this is what I meant about people reading the messages expecting to be told how to fix it instead of being told what the problem is
10:38:19 <davean> and that GHC *can't know* what the problem is
10:38:26 <dminuoso> davean: Sure, I absolutely understand that part.
10:38:44 <davean> I know, now I'm just saying it for the recap :)
10:38:54 <dminuoso> This is a pretty wide "issue" with GHC, where it rather tells you about "here, in your proposed logic there's an inconsistency"
10:39:11 <davean> Thats what its error messages basicly always are
10:39:20 <davean> They can't be correct and anything else.
10:39:27 <davean> though they could be helpful and sometimes wrong.
10:41:01 <davean> This kinda a proposes a "helpful but wrong" error messages mode.
10:41:18 <dminuoso> With what I know now, Im afraid Im not so sure anymore whether changing it *is* necessary. otoh if gaining an intimate understanding of GHCs perspective is necessary to decipher the diagnostic, that's not a good indicator.
10:41:33 <dminuoso> or rather, that is a good indicator
10:41:38 <davean> I mean thats true of all communication
10:41:42 <dminuoso> Yeah
10:42:03 <davean> thats acually the specific reason human language is so dense - we have a presumption of information content and derive information under that assumption. 
10:42:10 <davean> We're just practiced at it with people.
10:42:22 <davean> well, the people we usually talk to
10:42:32 <davean> if you talk to a scientist in their field you'll get the same problem.
10:42:39 <ski> it would be nice if GHC had type error slicing
10:42:51 <davean> ski: yah
10:43:00 <davean> ski: Don't think it would help as much as people think, but it would help.
10:43:07 <x0r-255> glguy: I've just installed a lot of things, but am still getting similar errors, is there a list somewhere that I can just feed yay?
10:43:10 <dminuoso> ski: Ive seen you mention type error slicing for a while now. Do you have some good reading material on this?
10:43:12 <x0r-255> manjaro btw
10:43:40 <ski> so that it'd not just report the sole location in which it found an inconsistency, but all (and only) the locations which contributed to the inconsistency, such that at least one of them must be changed to resolve it
10:43:45 <davean> dminuoso: anyway, I hope this deep dive into a single error message was educational. It certainly helped me understand how people read GHC.
10:43:59 <dminuoso> davean: At times I wonder whether GHC should have multiple diagnostics modes, such that the GHC team doesn't have to strike a balance between "tell you the truth about how GHC views things", "use correct terminology" and "not confuse beginners"
10:44:24 <davean> dminuoso: 17:40:39 davean This kinda a proposes a "helpful but wrong" error messages mode.
10:44:25 <yushyin> x0r-255: just use ghcup instead of the manjaro packages
10:44:29 <ski> dminuoso : "Skalpel: A Type Error Slicer for SML" <https://www.macs.hw.ac.uk/ultra/skalpel/>
10:44:38 <davean> dminuoso: The marketing team might want to revisit my naming ;)
10:44:39 <dminuoso> And thank you, you helped me a lot understanding a) how difficult inter-person communication can be, b) gain a broader perspective on fundeps, and have an enjoyable conversation. :)
10:45:05 <dminuoso> Ah, was the diagnostic from you?
10:45:15 <davean> No
10:45:31 <davean> Naming the GHC mode for noobies "helpful but wrong"
10:45:35 <dminuoso> Ah I see.
10:45:37 <davean> thats what the marketing team would want to revisit
10:45:51 <dminuoso> I've reached to that idea multiple times. :)
10:46:02 <dminuoso> ski: Cheers.
10:51:28 <sshine> sm[m], thanks :) you mean, are they better than uniformly random? yeah, I don't really know why they would be unless their generation is somehow guided by feedback.
10:52:04 <x0r-255> yushyin: I just did that, but still to no avail... "files missing in the â€˜syb-0.7.1â€™ package, â€˜primitive-0.7.1.0â€™ package," and a million deprecation warnings... Where do I go from here? (I've reinstalled both already)
10:55:23 <davean> x0r-255: How is your GHC setup? Are you using a cabal project file?
10:55:31 <davean> is it a system install?
10:55:34 <davean> user?
10:55:44 <davean> I'm very confused by the errors you're reporting
10:57:40 <x0r-255> I installed xmonad, then xmonad-contrib, later ghc, ghc-static, haskell-base, cabal, so It's a xmonad config, all I'm shooting for is a randomElement choosing and Data.Random.List doesn't exist, and the errors are coming from `cabal install random-fu`
10:58:48 <x0r-255> I've fixed some of the errors by reinstalling things, but primitive and syb don't want to work for me
10:58:51 <davean> Ok, so you're doing a system level install of everything but random-fu, which is user level
10:59:01 <x0r-255> yes
10:59:23 <davean> Oh man thats a weird setup, sorry, I've no idea. I've never split an install like that.
10:59:46 <x0r-255> how'd you do it on an arch based system then? I'm fine with reinstalling if it'll work...
10:59:55 <davean> Oh shit this is arch?
10:59:59 <x0r-255> yes
11:00:00 <davean> I know what your problem is I think
11:00:04 <x0r-255> manjaro technically
11:00:06 <davean> And the answer is "I'd definately not use arch"
11:00:12 <davean> arch fucks with Haskell
11:00:13 <davean> specificly
11:00:22 <davean> They force dynamic linking
11:00:29 <davean> This is an arch problem
11:00:49 <x0r-255> so this: https://www.reddit.com/r/archlinux/comments/7hanz7/whats_the_current_state_of_haskell_on_arch/ would be a reasonable setup?
11:00:59 <x0r-255> top comment*
11:01:20 <davean> I mean you could use ghcup, etc
11:01:29 <davean> I'd do ghcup and cabal but whatever  you want.
11:01:30 <x0r-255> I just installed and ran ghcup
11:01:40 <x0r-255> but it didn't fix everything
11:01:49 <davean> well, you still ahve the system stuff?
11:01:56 <davean> so it's probably trying to use it, even though its broken
11:02:11 <x0r-255> so uninstall ghc and haskell, then reinstall via ghcup?
11:02:12 <yushyin> You also have to build xmonad with the ghc and cabal from ghcup
11:02:18 <davean> Yah
11:02:31 <davean> Sorry, I have no idea why arch breaks Haskell specificly.
11:03:48 <davean> Maybe someone knows arch specificly.
11:04:37 <monochrom> It's this: https://wiki.archlinux.org/index.php/Haskell#Problems_with_linking
11:06:46 <monochrom> My short understanding is that arch migrated to purely dynamic linking, then they blew it when doing it to ghc.
11:08:25 <davean> monochrom: so it was a case of "Do $X even if $X doesn't mean what you think it means in a given context" or something?
11:08:40 <monochrom> I would have reservation before saying "arch breaks haskell". This only breaks ghc, not hugs. :)
11:08:53 <davean> monochrom: They don't have hugs though, right?
11:09:03 <maerwald> No, it means arch packaging is low quality. In general.
11:09:17 <maerwald> And I'm confident to say this.
11:09:25 <monochrom> I think no, they just didn't know or bother to change GHC default.
11:09:55 <yushyin> There is no default to change at compile time
11:10:12 <monochrom> You can tell GHC to do dynamic linking. I think you can even change source code or config files to make it default. They didn't care.
11:10:21 <yushyin> You need to patch ghc
11:11:20 <yushyin> Afaik at least there is no easy compile time --flag 
11:11:25 <monochrom> And what maerwald said. It is standard practice for every linux distro to slightly patch source for this and similar purposes.
11:11:59 <davean> What is arch's selling point?
11:12:07 <monochrom> The real question is of will, not of technical feasibility.
11:13:06 <monochrom> wiki.archlinux.org I think :)
11:13:07 <EvanR> arch has a cult following
11:13:53 <dolio> The usual selling point is that their turnaround from upstream releases to getting it to users is fast.
11:13:57 <maerwald> davean: fire and forget mentality
11:14:24 <x0r-255> okay so when I run `yay -R ghc` it says oh haskell-blah depends on that, not so fast, how can I remove everything underneath this as there's too much for me to manually type out?
11:14:30 <maerwald> dolio: gentoo is sometimes significantly faster, depending on maintainers and they have real QA
11:14:31 <monochrom> Like, if you have hardware driver issues or strangeness, regardless of distro, high chance arch wiki has the solution and not-watered-down explanation.
11:15:04 <davean> I certainly like not-watered-down explanations
11:15:09 <dolio> maerwald: Yeah, but I guess the other selling point is that arch uses binaries. :)
11:15:13 <maerwald> monochrom: the solution without an explanation usually ;)
11:15:42 <maerwald> dolio: gentoo can as well, it's just there is no official repo for it
11:15:45 <monochrom> Heh OK! maybe my bar is low.
11:15:47 <x0r-255> davean: arch's selling point is pure customization, if anything is going to run on your system it's because you very explicitly said for it to.
11:15:52 <x0r-255> and minimalism
11:15:57 <x0r-255> lightweight too
11:16:10 <davean> x0r-255: Hum, but it uses packages, not something like gentoo or nixos?
11:16:28 <davean> x0r-255: so just tell it to staticly link GHC 
11:16:32 <maerwald> x0r-255: not really lightweight, since it doesn't have a concept of package configuration
11:16:38 <x0r-255> it uses packages yes, but pacman is a really nice and minimal package manager
11:16:48 <davean> x0r-255: If its configurable, why not just change the dynamic setting?
11:18:21 <davean> That seems the best and easiest solution
11:18:43 <monochrom> I have general distrust of human rationality. I may believe that people can choose a distro based on just mascot.
11:18:55 <davean> Hum, actually I could change a setting like that on debian too pretty easily.
11:19:17 <davean> not as easily as nixos or gentoo mind you
11:20:01 <x0r-255> heck idk man
11:20:03 <davean> nixos or gentoo is probably a 5 minute thing, I bet it would take me a full hour on Debian :/
11:20:18 <davean> so never mind, lets discount debian actually, that sounds super annoying.
11:20:47 <maerwald> It's the same with anything else in tech. There are 3 things that define a good distro: 1. manpower, 2. competence, 3. attitude.
11:21:04 <maerwald> arch has 1
11:21:35 <davean> one of thsoe, or #1?
11:21:38 <[exa]> reminds me the famous "choose two" diagrams
11:21:48 <maerwald> debian at least has 1 and 3
11:22:00 <davean> debian's amount of 2 is highly varied
11:22:10 <maerwald> gentoo has 1 and 2
11:22:55 <davean> I can never tell with RH if they're have 2 and are just trying specificly to fuck me over, or none of 2 at all.
11:23:03 <davean> I suspect the former
11:23:14 <srk> lots of 1
11:23:32 <monochrom> haha, it is always malice, never incompetence? >:)
11:24:08 <srk> 2 as well, but foundations (rpm) are weird
11:24:14 <[exa]> monochrom: highly depends on the amount of money around :]
11:24:15 <monochrom> I do have a feeling of malicious incompetence regarding some of my students, mind you.
11:25:07 <monochrom> They maliciously read every "explanation" on the internet except my explanation, and go on to blow it.
11:25:51 <maerwald> my distro only has 2... and it's quite annoying
11:26:11 <davean> maerwald: You aren't manpower and you dislike your own attitude?
11:26:22 <monochrom> My assignment handout opens with "you will practice using fread and fwrite on binary files". I have a student who used fgets.
11:26:42 <maerwald> davean: the lack of attitude made me stop contributing and I'm basically writing all packages I need myself, yes
11:26:53 <davean> monochrom: so they get an instant zero and you can save some time :)
11:27:01 <monochrom> Before the assignment I even had a worth-1% weekly exercise on fread and fwrite for a simpler task.
11:30:09 <monochrom> On the midterm test I posed "how to detect that stdin is empty".
11:30:41 <davean> monochrom: I'm not even clear on what that means
11:30:58 <davean> nothing currently avaialble to read?
11:31:00 <monochrom> This being pandemic everyone-stays-home online test, it had to be open book. Learning stuff from the internet on the fly is fine, just know the line between learning and copying.
11:31:19 <monochrom> OK maybe it helps to say this course is on Unix and C.
11:31:30 <monochrom> empty is end-of-file.
11:32:00 <monochrom> A whole bunch of students copied the solution from stackoverflow.
11:32:19 <davean> That does help a bit. Though "closed" and "nothing currently available" both are different types of empty to me for stdin
11:32:21 <monochrom> The stackoverflow solution is wrong: fseek to end, then ftell, see if ftell says 0.
11:32:43 <monochrom> This is what I call maliciously incompetent.
11:32:59 <davean> Thats ...
11:33:01 <davean> thats ...
11:33:09 <monochrom> The malice of just fishing for answers, and the the incompetence of believing the wrong answer.
11:33:13 <davean> uh, so we're talking stdin ...
11:33:32 <davean> But an answer that doesn't even make conceptual sense for stdin most of the time
11:33:37 <monochrom> stdin could be file, terminal, pipe, socket, anything. fseek can be illegal. Usually illegal actually.
11:33:43 <davean> (sure I mean someone could have rebound it to an actual file)
11:33:55 <davean> yah
11:34:03 <monochrom> yeah if file redirection, sure. But I didn't guarantee that.
11:34:04 <davean> Thats exactly why I'm unclear on what empty means
11:34:08 <sm[m]> sshine: maybe you saw this in the "breeder" package: Executable to train goblin mutators over `cardano-ledger-specs` STS transition generators, such that the modified generators will trigger `PredicateFailure`s
11:34:34 <davean> I don't really consider a streamign source "empty" if I've just read all teh data and we haven't waited for more.
11:34:43 <davean> its just the buffer is currently depleated
11:35:03 <monochrom> You know what's even more incompetent? This being an online stay-home exam, and I am not doing any online big-brother-watching-you proctoring, they could have easily tested it.
11:35:51 <x0r-255> alright I just uninstalled ghc and everything depending on it, as well as cabal
11:35:59 <x0r-255> installed the latest ghc from ghcup
11:36:00 <davean> x0r-255: so sorry :(
11:36:01 <x0r-255> now what
11:36:20 <davean> x0r-255: You have path setup nicely so you have ghc and cabal in your path?
11:37:02 <davean> Well that didn't go well.
11:37:14 <sm[m]> in a BreedingPit. (The metaphor is strong with this one.)
11:37:15 <sm[m]> it cunningly breeds goblins that are extra good at breaking things
11:37:57 <monochrom> Why do I feel that "the metaphor is strong" means "the pun is strong"? :)
11:39:11 <Tuplanolla> Next time someone claims Haskell has simple syntax, ask them to explain Taylor Fausak's program `x# ::_=id @(_::_)mdo if|let?_=(0x0.0,'(),)->[0b_0^0e0| !_<-[]|_<-[],then\case]`.
11:39:25 <[exa]> monochrom: btw, people here are now thinking to stop teaching python in the basic courses, because stackoverflow coverage of python causes no one ever really learn, just copy
11:39:37 <davean> Tuplanolla: Thats got a pile of extensions in it
11:39:45 <monochrom> [exa]: \âˆ©/
11:39:53 <davean> Tuplanolla: And thats why extensions are bad if they don't buy you actual benefits :-p
11:39:56 <[exa]> monochrom: many teachers going "Oh wow this is why pascal was good!"
11:40:34 <monochrom> We still use python for the 1st-term course, but now C for the 2nd-term course to make things really interesting and force students to face a more real model early.
11:40:39 <maerwald> Tuplanolla: I was gonna reply in that thread "if anyone wonderd why ppl think haskellers are weird ivory tower academics... this is it"
11:40:52 <monochrom> Ah yes I did suggest Pascal.
11:40:59 <[exa]> monochrom: I guess that's almost good. I kindof intend to replace python by scheme
11:41:10 <[exa]> but that's not realistically going through ever
11:41:17 <maerwald> but then I realized C has obfuscation contests that are much much more scary than that
11:41:19 <monochrom> I was always like "so why not Pascal?"
11:41:24 <davean> [exa]: why not?
11:41:31 <[exa]> davean: t e n s i o n
11:41:37 <Tuplanolla> The cycle goes from "We need to switch away from Scheme, because nobody uses it." to "We need to switch back to Scheme, because nobody uses it." and repeats.
11:41:37 <davean> [exa]: ?
11:41:48 <davean> [exa]: Could you please elaborate?
11:41:55 <[exa]> I can't handle 500 students myself, so the decision is not mine only
11:42:11 <ddellacosta> can't help but think of https://chrisdone.com/posts/dijkstra-haskell-java/ reading this convo
11:42:48 <Tuplanolla> Don't worry. I'll make a language that's nobody uses and is already maximally obfuscated.
11:43:12 <x0r-255> so sorry, my laptop died, I'm back now
11:43:25 <x0r-255> davean: this is the last I saw `<davean> x0r-255: You have path setup nicely so you have ghc and cabal in your path?`
11:43:33 <monochrom> More honestly, one side of me says "C is too brutal this early, Pascal is less steep with the same benefit", another side says "brutal is good, these students need a boot camp". :)
11:43:48 <[exa]> monochrom: about pascal, I like it
11:43:54 <x0r-255> but no, I don't have ghc in my path, nor do I have cabal installed
11:44:05 <[exa]> the earlier the students hit the lowlevel wall, the better
11:44:07 <maerwald> x0r-255: how did you install ghcup
11:44:23 <x0r-255> yay ghcup (then chose first option ghcup-hs)
11:44:37 <ski> @remember Tuplanolla The cycle goes from "We need to switch away from Scheme, because nobody uses it." to "We need to switch back to Scheme, because nobody uses it." and repeats.
11:44:37 <lambdabot> It is forever etched in my memory.
11:44:54 <xerox_> Tuplanolla++
11:45:00 <[exa]> great truths
11:45:07 <maerwald> x0r-255: add ~/.ghcup/bin to your path
11:46:01 <Cheery> I'd actually prefer scheme in place of javascript
11:46:11 <yushyin> maerwald: and also ~/.cabal/bin, right?
11:46:42 <maerwald> yushyin: it's a good idea for a default setup yeah
11:47:31 <[exa]> <me:> javascripts and pythons are scheme. <students:> haha lol good joke dude, oldschool in 30's. <karma:> strikes back at compilers course
11:48:09 <Cheery> oh, then you prefer it too
11:48:23 <Cheery> was thinking of compilers when saying that
11:48:45 <dolio> They're pretty clearly not scheme.
11:48:57 <[exa]> well no, the parentheses are missed
11:49:03 <monochrom> haha
11:49:22 <dolio> Scheme has all sorts of great macro features and such, and JS and python don't.
11:49:52 <[exa]> I added extra karma last year at haskell course (python-style significant-whitespace parser)
11:49:55 <[exa]> that was good
11:50:21 <dolio> Also proper support for recursion.
11:50:27 <x0r-255> lol, never actually had to manually change my path before, but I got it.
11:50:36 <[exa]> dolio: the point is that for almost any of the modern interpreted languages there's a lisp or scheme dialect that had the same "new cool features" in 1983
11:51:14 <[exa]> dolio: _almost_ the same holds for compiled languages and ML's
11:51:48 <x0r-255> it still wants me to install ghc when I try to install xmonad...
11:52:13 <monochrom> If it's arch's xmonad then it will want arch's ghc, yeah.
11:52:20 <[exa]> x0r-255: you are trying to install xmonad using what?
11:52:25 <x0r-255> yay
11:52:27 <x0r-255> pacman
11:52:34 <[exa]> oh, why not manually?
11:52:40 <x0r-255> it's nicer that way
11:52:59 <x0r-255> yay is a real life saver
11:53:10 <monochrom> At this rate I have very low confidence that arch's xmonad will work at all.
11:53:30 <x0r-255> well I've been running it for the last 2 weeks...
11:53:32 <x0r-255> lol
11:53:40 <monochrom> OK fine.
11:54:15 <x0r-255> installing it using cabal now
11:55:26 <maerwald> I was considering to switch to xmonad from i3, because i3 mantainers lack attitude and I lack the time to hack on that convoluted pieco of C code
11:55:54 <x0r-255> if you do switch take a look at DT's config, quite nice
11:55:58 <maerwald> but then I'm afraid xmonad will become a time sink
11:55:59 <x0r-255> that's what I based mine on
11:56:01 <monochrom> Now you want to hack on that convoluted piece of Haskell code. :)
11:56:23 <maerwald> monochrom: yeah, but I'm used to that
11:56:27 <monochrom> OK!
11:56:30 <x0r-255> haskell is easier for configs then c
11:56:32 <x0r-255> much easier
11:56:34 <x0r-255> imo
11:56:41 <monochrom> Yes there is that.
11:56:41 <maerwald> i3 has a real config format
11:56:58 <x0r-255> but same-lang config allows for waaaaay more flexibility
11:57:06 <maerwald> I dislike that in general
11:57:19 <maerwald> config shouldn't be turing complete
11:57:32 <x0r-255> once I decided to cancel a cabal install... it was a nightmare
11:57:47 <maerwald> one does not simply cancel cabal
11:57:49 <x0r-255> yay/pacman can be cancelled no consequences
11:57:54 <x0r-255> oh ik now
11:57:58 <x0r-255> but sheesh
11:58:01 <x0r-255> no failsafe?
11:58:12 <maerwald> use --jobs=1
11:58:22 <maerwald> who needs more than one job anyway?
11:58:35 <monochrom> People with 1024 cores.
11:58:37 <[exa]> x0r-255: you know, there's no operating system being held together by cabal, so what... :]
11:58:48 <sm[m]> why can't you cancel cabal install ?
11:59:05 <x0r-255> [exa]: well pip for python can be cancelled no consequences
11:59:16 <maerwald> sm[m]: with multiple jobs/threads it sometimes behaves funny
11:59:30 <x0r-255> all it takes is a revert, a IM closing DONT KILL ME MORE BRUTALLY msg, then nice cleanup
11:59:30 * sm[m] never had a problem.. huh
11:59:44 <monochrom> I think I also cancelled with no consequence.
11:59:54 <sm[m]> bad behaviour if so
12:00:00 <x0r-255> I must've gotten extremelly unlucky then
12:00:01 <x0r-255> hm
12:00:09 <x0r-255> whole ghc install got screwed
12:00:17 <maerwald> sm[m]: same problem as shake
12:00:19 <maerwald> nothing new
12:00:23 <x0r-255> couldn't even uninstall them
12:00:34 <sm[m]> even more bad then
12:00:35 <x0r-255> ghc/cabal wouldn't even uninstall
12:00:42 <maerwald> this is one of the instances of bad signal handling due to cross platform code I think
12:00:44 <x0r-255> super bad nightmare
12:00:56 <x0r-255> but it's over... so I'm ok
12:01:07 <sm[m]> x0r-255: why couldn't you uninstall ?
12:01:15 <x0r-255> it kept on erroring out
12:01:19 <x0r-255> not sure the exact error
12:01:29 <x0r-255> it was a few weeks ago
12:02:00 <sm[m]> ok, that would be interesting because that should not be considered normal 
12:02:35 <sm[m]> well, except you're on arch which I'm not going to get into, but interesting for someone :)
12:02:36 <sm[m]> #haskell-arch 
12:02:42 <x0r-255> had to wipe my build files for pacman, lots of other things
12:02:44 <x0r-255> lol
12:03:07 <x0r-255> Could not load module â€˜XMonadâ€™
12:03:09 <x0r-255>     It is a member of the hidden package â€˜xmonad-0.15â€™.
12:03:10 <x0r-255>     You can run â€˜:set -package xmonadâ€™ to expose it.
12:03:11 <x0r-255> where might I run that?
12:09:32 <x0r-255> now that I have cabal and ghcup do I need to setup a build file for xmonad?
12:09:48 <x0r-255> because it can't find the package XMonad
12:10:00 <maerwald> can't you just clone the repo and build there?
12:10:32 <x0r-255> I have it installed (cabal install xmonad) however look a few messages up, I keep getting that error
12:11:10 <maerwald> `which ghc`?
12:11:16 <x0r-255> and xmonad has the option for a custom build file (~/.xmonad/build), I'm just wondering if I need to make a build file for that
12:11:18 <x0r-255> 8.10.1
12:11:21 <maerwald> no
12:11:29 <maerwald> `which ghc`
12:11:46 <x0r-255> the only one on my system now located at .ghcup/bin
12:12:06 <maerwald> is that what `which ghc` reports?
12:12:23 <maerwald> I don't remember it being that verbose
12:12:26 <x0r-255> yes "/home/uid0/.ghcup/bin/ghc"
12:12:58 <maerwald> did you delete the old store?
12:13:06 <dmwit> Under normal circumstances, I would expect to see the message you pasted only in ghci.
12:13:21 <dmwit> If you were in ghci, then "in ghci" is the answer to "where might I run that?".
12:13:30 <dmwit> If you were not, then we need some details about exactly what command you ran.
12:15:14 <Orbstheorem> Is there a better way to opaquely encode an Integer as a bytestring and get it back other than building with integerDec and reading it back?
12:15:22 <Orbstheorem> s/better way/more efficient/
12:15:32 <x0r-255> dmwit: https://pastebin.com/SRVy0xRg
12:16:23 <maerwald> x0r-255: did you delete the old store?
12:16:45 <maerwald> ~/.cabal/store/ghc-8.10.1/
12:16:46 <Orbstheorem> I want to store a Bounded Integer Newtype as a Sql Numeric using Persistant, but I have to encode it as a DbSpecific Bytestring :(
12:17:17 <x0r-255> would that just be rm -rf? or does cabal have a command for that?
12:17:31 <maerwald> rm should be ok
12:17:50 <zeta_0> is the haskell language server usable yet, or should i just stick with ghcide for now?
12:18:42 <zeta_0> i heard that they'd have the hls ready by the end of this year.
12:19:07 <alehander92> is sublime good for haskell?
12:19:21 <x0r-255> maerwald: I have to reinstall xmonad now, lets hope this works
12:19:42 <x0r-255> via cabal*
12:20:35 <zeta_0> alehander92: i'd recommend emacs, vscodium is also very good.
12:21:13 <x0r-255> vscodium is pure evil (I'm only saying that because MS started it and it's electron (ew))
12:21:41 <alehander92> it is good, even if electron 
12:21:41 <Orbstheorem> alehander92: Been using neovim + ALE for quite some time now -> <3
12:21:46 <x0r-255> maerwald: that didn't fix it
12:21:48 <alehander92> electron is also ok
12:22:01 <alehander92> zeta_0 thanks .. i don't want to there for now
12:22:03 <x0r-255> electron is just a waste of performance
12:22:08 <alehander92> yeah yeah 
12:22:12 <typetetris> neovim + coc + ghcide here. It is a dream. but vscode + ghcide seems even better.
12:22:33 <Orbstheorem> typetetris: Have you tried hie?
12:23:04 <typetetris> Orbstheorem: yes used that before ghcide. ghcide is much faster subjectively
12:23:05 <zeta_0> emacs+ghcide+ghcid, works great for haskell development.
12:23:26 <maerwald> wasn't ghcide and hie suppoesd to merge efforts in hls, but now ghcide is still under active development?
12:23:48 <Orbstheorem> typetetris: Is your config public? o:-)
12:23:51 <alehander92> it is wasteful: but we should make a competitive framework, which is at least barely similar in ease/targetability/features
12:23:56 <zeta_0> maerwald: yes, it's just a matter of time until hls is read, i hope soon
12:24:05 <zeta_0> ready
12:24:17 <srk> when does stackage move to new ghc?
12:24:35 <srk> when nightly is good enough?
12:25:10 <typetetris> Orbstheorem: not yet. Maybe I extract some parts, when I have time. It is nix based though. 
12:25:37 <Orbstheorem> Running NixOS here o/
12:27:42 <srk> 1 2 or 3?
12:27:57 <zeta_0> i'm a nix user as well
12:28:49 <typetetris> Orbstheorem: lol it is, I forgot about that : https://github.com/typetetris/ghcide-nixpkgs-20.03/
12:28:52 <x0r-255> ah `cabal install xmonad --lib` works, I was missing the lib flag
12:28:53 <x0r-255> got it
12:28:55 <x0r-255> finally
12:29:30 <Orbstheorem> xD
12:29:35 <Orbstheorem> Thanks ^^
12:29:36 <zeta_0> i was reading on reddit that there's 2 study groups, one for the practical haskell book, and the other for the book of monads group. are these haskell study groups worth it?
12:29:51 <typetetris> Orbstheorem: And usage is in https://github.com/typetetris/smtp-mail/blob/a6ae02864e003bfd675172ba386421541b91bf8d/nix-integration-test/shell.nix#L1-L9
12:30:04 <x0r-255> I've heard good things about nixos, how good is it actually?
12:30:16 <x0r-255> would it be worth the switch from an arch-based distro?
12:30:25 <srk> yes :)
12:30:36 <srk> start with a vm
12:30:40 <x0r-255> like how's the package situation, the AUR is really nice what does nixos have?
12:30:51 <Orbstheorem> x0r-255: How good is it actually => Yes.
12:30:57 <srk> this
12:31:01 <x0r-255> :facepalm:
12:31:02 <x0r-255> lol
12:31:11 <HoolaBoola> I get that joke!
12:31:15 <zeta_0> yes nixos is amazing, nix is designed in a way to avoid many errors(like dependency hell)
12:31:46 <x0r-255> zeta_0: arch can get around that with pactree and yay
12:32:18 <koz_> Is there a way, given an AffineTraversal' s a and an AffineTraversal' s b, to mash them together to get an AffineTraversal' s (a,b)?
12:32:52 <HoolaBoola> Is NixOS as "hands-on" as Arch?
12:32:52 <Orbstheorem> x0r-255: there's not really an AUR (NUR is very different). The awesome part about Nix is that it's kind of as pure as haskell is (if it evaluates there's a very very good chance it will work). The awesome part about NixOS is that you be declarative about your system configuration.
12:33:04 <yushyin> x0r-255: just try it out and see for yourself?
12:33:09 <x0r-255> okay...
12:33:24 <hololeap> why are there all these nixos questions in here all of a sudden?
12:33:26 <x0r-255> now that my ghc install is better we come around to the original question: how do I choose a random element from a [ [Char] ]?
12:33:44 <Orbstheorem> hololeap: x0r-255 started it!
12:33:52 <zeta_0> x0r-255: there's also generations, so if something breaks, or the system crashes, all you have to do is reboot, and select a previous configuration to go back to, since nix is pure(solves the state problem), you can do that.
12:33:53 * Orbstheorem conceals his great exitement for NixOS :D
12:34:07 <typetetris> guys take it to #nixos, will ye?
12:34:11 <Orbstheorem> ^^
12:34:17 <x0r-255> huh...
12:34:17 <Orbstheorem> Haskell: Any ideas for my Integer <-> Bytestring issue? :(
12:35:08 <HoolaBoola> By the way, I'm not sure if this counts as advertising, but I'm currently doing a course in Haskell that's still in beta, and which I've found quite good
12:35:27 <Orbstheorem> HoolaBoola: Is it FOSS ?
12:35:37 <HoolaBoola> Anyway, encountered the language that way and have fallen in love a bit
12:36:15 <Orbstheorem> I remember falling in love with haskell when I learned about fmap and monads <3
12:36:21 <HoolaBoola> Orbstheorem: it's a MOOC course (Massive, Online, Open Course) made by University of Helsinki, so once it's out anyone can do the course
12:36:28 <Orbstheorem> I stayed for the Type Programming ^^
12:36:35 <Orbstheorem> HoolaBoola: Oh, share the link, please!
12:36:41 <HoolaBoola> Okay ^_^
12:36:44 <typetetris> x0r-255: someting like `let s = ["a", "b","c"] in (randomRIO (0, length s - 1) >>= return (s !!))` or something, is in `IO` obviously.
12:36:58 <HoolaBoola> https://haskell.mooc.fi/
12:37:39 <Orbstheorem> x0r-255: <random> if you're writing quickcheck instances you should use `choose`.
12:38:01 <HoolaBoola> But anyway, I find this language very refreshing compared to Java, C++ and all those types of languages
12:38:20 <Orbstheorem> What do you mean by refreshing?
12:38:27 <typetetris> x0r-255: But if its for test data, I would use QuickCheck `generate (elements ["a", "b", "c"])`.
12:38:33 <HoolaBoola> I mean it's the first functional language I've tried
12:38:43 <HoolaBoola> "Pure" functional
12:38:50 <Orbstheorem> Right
12:39:03 <x0r-255> typetris: would that work for http://en.wikipedia.org/wiki/Special:Search?go=Go&search=Char too? (what you gave is [Char])
12:39:08 <x0r-255> ok wtf
12:39:12 <x0r-255> [ [Char] ]***
12:39:22 <Orbstheorem> HoolaBoola: When you get some time you should try Scala: So you can split your optics between Ad-hoc and Inheritance polymorphism.
12:39:52 <HoolaBoola> I've realised trying wildly different languages forces you to think in different ways, which can help you improve with your previously mastered technologies as well
12:40:02 <EvanR> if java, c++ is like walking through glass, haskell is like walking on perfect diamonds :)
12:40:09 <EvanR> very refreshing
12:40:13 <HoolaBoola> Like Rust forces me to think about ownership and stuff like that
12:40:16 <koz_> Is there a way, given an AffineTraversal' s a and an AffineTraversal' s b, to mash them together to get an AffineTraversal' s (a,b)?
12:40:31 <hololeap> Orbstheorem: have you tried Data.Binary? (my backlog got cleared so i can't see your original question)
12:40:32 <dolio> koz_: I don't think so.
12:40:40 <koz_> dolio: That's a bit sadface.
12:40:51 <typetetris> > let s = ["a", "b","c"] in (randomRIO (0, length s - 1) >>= return (s !!))
12:40:51 <Orbstheorem> HoolaBoola: Spoilers: Rust linear types sneak into Linear haskell :D
12:40:53 <lambdabot>  error:
12:40:53 <lambdabot>      â€¢ Couldn't match type â€˜Int -> [Char]â€™ with â€˜IO bâ€™
12:40:53 <lambdabot>        Expected type: Int -> IO b
12:40:58 <zeta_0> could some explain the differences between haskell and lisp? is haskell a lisp dialect with a type system?
12:41:10 <koz_> zeta_0: First-off, define 'lisp'.
12:41:13 <HoolaBoola> Orbstheorem: In fact I almost did a course on Scala, would have had I went to a different university where Scala is the standard language
12:41:25 <typetetris> > let s = ["a", "b","c"] in do { ind <- randomRIO (0, length s - 1); return (s !! ind); }
12:41:27 <lambdabot>  <IO [Char]>
12:41:30 <monochrom> zeta_0: I thought you knew the answer.
12:41:33 <Orbstheorem> hololeap: My original question:
12:41:34 <Orbstheorem> >Is there a better way to opaquely encode an Integer as a bytestring and get it back other than building with integerDec and reading it back?
12:41:38 <zeta_0> i don't know, that's why i'm asking.
12:42:09 <HoolaBoola> Orbstheorem: :D I have noticed certain similarities with Haskell and Rust, mostly stuff that I greatly appreciate (like strong typing, but only when compiler can't 100% infer the correct one)
12:42:12 <Orbstheorem> Data.Binary requires me to make my BigInt a [Int*] somehow :(
12:42:15 <monochrom> It's a long answer and I'm too lazy.
12:42:15 <koz_> zeta_0: Given that 'lisp' refers to a whole family of languages, while Haskell to (an admittedly somewhat large) one, that question isn't answerable.
12:42:20 <typetetris> x0r-255: It is `[[Char]]` because `[Char]` would be `['a','b','c']` but I gave `["a","b","c"]`.
12:42:35 <x0r-255> okay, I see
12:42:42 <koz_> The most literal answer is 'we don't expect people to write ASTs'.
12:42:43 <Orbstheorem> HoolaBoola: One of my friends is doing his PhD is scala at EPFL, so I get to ask him tons of questions :D
12:42:57 <koz_> But I somehow doubt that this is a) informative or b) what you were after anyway.
12:43:21 <monochrom> But Haskell doesn't have first-class continuation, doesn't have "same name two bindings (var vs func)", doesn't have lisp-style macro system, etc etc so I wouldn't even start with the "dialect" perspective.
12:43:28 <hololeap> Orbstheorem: there's a Binary Integer instance; Integer has unbounded size
12:43:30 <HoolaBoola> Nice, I wonder if I ever end up going the PhD route
12:43:35 <Orbstheorem> HoolaBoola: https://www.youtube.com/watch?v=t0mhvd3-60Y
12:43:37 <monochrom> btw I hate that same name two bindings thing.
12:43:43 <koz_> monochrom: Common Lisp lacks first-class continuations IIRC.
12:43:55 <koz_> Scheme also doesn't have two namespaces like you described.
12:43:59 <zeta_0> oh, elisp(for emacs) is the only lisp i've used, but it's very different from haskell
12:44:05 <koz_> Scheme and Common Lisp have _very_ different macro systems.
12:44:07 <Cheery> monochrom: um... the continuations are a transformation of type a to (a -> r) -> r
12:44:13 <koz_> ELisp is basically ... very different.
12:44:34 <HoolaBoola> Orbstheorem: huh, certainly very science-y title ^_^
12:44:40 <monochrom> Cheery, I said first-class.
12:44:57 <Orbstheorem> HoolaBoola: It's not that scary once you dive in :P
12:45:12 <Orbstheorem> SPJ is very good at explaining from the videos I've seen of him.
12:45:20 <HoolaBoola> Yeah, scientists are just bad at titleing stuff :D
12:45:46 <monochrom> Well, GHC will soon have first-class (or close enough) continuation to help with efficient effect systems, so the end is near!
12:45:55 <koz_> mono
12:46:01 <koz_> monochrom: Wait, that got accepted?
12:46:08 <koz_> I thought it was still under review.
12:46:23 <monochrom> I don't know. I'm using a broad "soon".
12:46:33 <Orbstheorem> monochrom: D0 effect systems try to explain IO?
12:46:41 <dolio> I don't see what's bad about the title.
12:46:42 <Orbstheorem> s/D0/Do/
12:46:43 <x0r-255> typetetris: sorry, that works fine for what I asked for, however I mis-asked, I want it to return a [Char] from a [ [Char] ]
12:46:49 <monochrom> I'm also showing my subjective Bayesian high probability that it will come.
12:47:04 <x0r-255> as in get an element from ["blah","blah"]
12:47:06 <monochrom> I don't know.
12:47:32 <Orbstheorem> hololeap: Binary has encode, thanks!
12:48:05 <hololeap> yeah, and decode . encode == id
12:49:50 <Orbstheorem> hololeap: Euh, almost xD
12:50:00 <Orbstheorem> It's partial iso over Maybe x)
12:50:26 <Orbstheorem> But yeah, for my purposes, I'm find with using fromJust
12:52:55 <hololeap> Orbstheorem: not sure what you mean, it even says in the docs that this is a property that instances should satisfy
12:53:10 <Orbstheorem> > :t decode
12:53:12 <lambdabot>  <hint>:1:1: error: parse error on input â€˜:â€™
12:53:28 <Orbstheorem> > decode (encode (1 :: Integer))
12:53:30 <lambdabot>  error: Variable not in scope: decode :: t0 -> terror:
12:53:31 <lambdabot>      Variable not in scope: encode :: Integer -> t0
12:53:36 <Orbstheorem> > import Data.Binary
12:53:38 <lambdabot>  <hint>:1:1: error: parse error on input â€˜importâ€™
12:53:42 <hololeap> % import qualified Data.Binary as B
12:53:42 <yahb> hololeap: 
12:53:47 <hololeap> % :t B.encode
12:53:47 <yahb> hololeap: B.Binary a => a -> BSL.ByteString
12:53:49 <Orbstheorem> % decode (encode (1 :: Integer))
12:53:49 <yahb> Orbstheorem: ; <interactive>:29:1: error:; * Variable not in scope: decode :: t0 -> t; * Perhaps you meant one of these: `B.decode' (imported from Data.Binary), `B.encode' (imported from Data.Binary); <interactive>:29:9: error:; * Variable not in scope: encode :: Integer -> t0; * Perhaps you meant one of these: `B.encode' (imported from Data.Binary), `B.decode' (imported from Data.Binary)
12:53:51 <hololeap> % :t B.decode
12:53:52 <yahb> hololeap: B.Binary a => BSL.ByteString -> a
12:54:18 <Orbstheorem> Oh
12:54:22 <Orbstheorem> Don't mind me ><"
12:54:31 <Orbstheorem> I was using the JSON instances of encode and decode.
12:54:35 <HoolaBoola> As someone quite new to Haskell, I'm not a good judge on this so I want to ask: how helpful are Haskell error messages generally?
12:54:53 <Orbstheorem> HoolaBoola: Horrible unless you're used to them.
12:54:56 <hololeap> very helpful, if you can understand them
12:55:31 <HoolaBoola> Yeah they seem quite hard to understand and find where the problem lies
12:55:51 <Cheery> want to know how to not have that problem?
12:55:56 <HoolaBoola> I just wish there would be a tool that automatically makes perfect error messages
12:56:04 <HoolaBoola> Cheery: write perfect code?
12:56:46 <Orbstheorem> Cheery: Wild guess: Write type signature __everywhere__?
12:57:10 <hololeap> a helpful technique is to write your code incrementally, filling in the unfinished parts with `undefined`, and recompiling (or :r in GHCi) whenever you make a change
12:57:22 <Cheery> if you take type theory stance, then types are propositions to be proved.
12:57:25 <Orbstheorem> `stack build --file-watch` <3
12:57:44 <HoolaBoola> Wait you can just fill stuff with 'undefined'?
12:57:48 <Cheery> and likely you'd like to write a proposition for what you're going to prove, before the proof.
12:57:53 <x0r-255> anyone know how to convert an `RVar [Char]` to a [Char]?
12:57:57 <Orbstheorem> HoolaBoola: Yes, it will make a runtime exception.
12:58:03 <Orbstheorem> % undefined (22)
12:58:03 <yahb> Orbstheorem: *** Exception: Prelude.undefined; CallStack (from HasCallStack):; error, called at libraries/base/GHC/Err.hs:79:14 in base:GHC.Err; undefined, called at <interactive>:31:1 in interactive:Ghci16
12:58:09 <HoolaBoola> Ah
12:58:10 <Orbstheorem> HoolaBoola: ^^
12:58:14 <HoolaBoola> Thanks
12:58:49 <Orbstheorem> HoolaBoola: you can also write type signatures and use `_` if you don't know the type. The compiler will tell you what it thinks it should go there.
12:59:08 <hololeap> HoolaBoola: but it will still type-check. the first goal is to finish your program without the type checker getting angry. the second goal is making sure it actually behaves the way you want it to
12:59:28 <HoolaBoola> Yeah, _ I already knew
12:59:51 <hololeap> blowing up when it hits an `undefined` is probably not the behavior you want :p
12:59:55 <Cheery> there's a book written for idris
12:59:57 <jumper149> Can I have a constraint as the type of a TypeFamily within in a class?
13:00:16 <Cheery> https://www.manning.com/books/type-driven-development-with-idris
13:00:20 <dminuoso> jumper149: Yes.
13:00:25 <dminuoso> jumper149: Enable ConstraintKinds
13:00:50 <jumper149> dminuoso: Alright! Lets try this :)
13:01:01 <Orbstheorem> jumper149: You can also use FlexibleSontexts to put them as class constraints.
13:01:18 <Orbstheorem> s/FlexibleSontexts/FlexibleContexts/
13:02:23 <ddellacosta> what do folks think of this response in terms of problems/good or bad practice, etc.? https://stackoverflow.com/a/31342939
13:03:04 <Cheery> HoolaBoola: basically, learn to associate semantics to types, this has another benefit that you can then write programs such that types remind you from what they're solving.
13:03:19 <Cheery> not needing to read the programs as much, opening you to use point-free style more often.
13:03:26 <sshine> sm[m], ah, excellent. thanks for guiding me. :)
13:04:58 <sm[m]> np
13:07:26 <Orbstheorem> HoolaBoola: Oh, also asking pl reductions to lambdabot is useful ^^
13:07:30 <monochrom> ddellacosta: hGetContents' probably takes linear space.
13:07:41 <Orbstheorem> ?pl (\(a, b) -> (f a, g b)) <$> arr
13:07:41 <lambdabot> (f *** g) <$> arr
13:07:44 <monochrom> Note: hGetContents doesn't
13:08:22 <ddellacosta> monochrom: huh so just to be sure I'm clear, you're saying it's worse than O(n) somehow? Because of laziness?
13:09:14 <monochrom> hGetContents is lazy by a backdoor, hGetContents' isn't lazy. But I guess you can add the same backdoor, it's unsafeInterleaveIO.
13:09:57 <monochrom> Still, why it's linear space is quite a bit more than non-laziness.
13:10:51 <monochrom> For IO, fmap f xxx takes Î©(1) space.
13:11:35 <dolio> The only way to avoid linear space usage for the example is to take advantage of the fact that it's overwriting the file on a one-to-one character basis.
13:11:54 <dolio> Which is not really possible with something as generic as hGetContents.
13:11:58 <monochrom> In IO, without backdoors like unsafeInterleaveIO, you can pretty much use C cost models, "call stack" and "non-tail calls" are meaningful and the reality again.
13:12:22 <dolio> I suppose it might actually be possible, but it'd be at least convoluted.
13:12:52 <ddellacosta> yeah, I think some of the problems I'm having here is that I was trying to write quick hacky script, and I've never really done much file IO in haskell, so it wasn't clear to me what to reach for. I'm getting the sense that folks tend to not do what I'm doing or otherwise are using far more scalable/modular solutions to file IO in prod apps
13:13:28 <ddellacosta> sorry that's a bit of a digression. dolio and monochrom thanks, I'm still absorbing what you just wrote
13:13:41 <monochrom> Per-character destructive update is a simple loop of getchar, seek back by 1, putchar.
13:15:21 <ddellacosta> monochrom: the fmap f in IO being constant is just about some under-the-covers optimization unique to IO's fmap?
13:15:21 <dolio> I think all the earlier warnings you got about lazy I/O were unfounded. The real problem is that interleaving reading and writing the same file requires careful thought, regardless of how you do it.
13:15:29 <dolio> But people take any opportunity to complain about lazy I/O.
13:15:59 <ddellacosta> dolio: yeah that makes a lot of sense
13:16:00 <monochrom> No, it's about IO cost model being the same as all imperative cost models such as C's.
13:16:49 <monochrom> If you see C "xs = recursive call (); return (x : xs)" you know it has the same cost as all imperative non-tail recursion.
13:17:07 <monochrom> fmap f (recursive call) does the same for IO.
13:17:21 <ddellacosta> okay, thanks
13:18:37 <monochrom> under-the-cover lack of optimization I guess
13:19:06 <ddellacosta> interesting
13:19:26 <ddellacosta> definitely there's a bunch there I don't understand yet but you've given me clues as to where to investigate. Thanks monochrom 
13:24:05 <x0r-255> I'm doing `randColor l = (l !!) <$> randomRIO (0, length l - 1)` and I'm looking for it to return type [Char] but it's returning [ [Char ] ] how can I fix this?
13:26:48 <enikar> use join?
13:27:10 <xerox_> :t concat
13:27:12 <lambdabot> Foldable t => t [a] -> [a]
13:28:37 <dminuoso> xerox_: Use =<< rather than <$>
13:29:21 <hololeap> :t (!!)
13:29:23 <lambdabot> [a] -> Int -> a
13:29:26 <dminuoso> oh
13:30:36 <hololeap> % import qualified System.Random as Random
13:30:36 <yahb> hololeap: 
13:30:56 <hololeap> % :t \l -> (l !!) <$> randomRIO (0, length l - 1)
13:30:56 <yahb> hololeap: ; <interactive>:1:32: error:; Ambiguous occurrence `length'; It could refer to; either `Data.Text.length', imported from `Data.Text'; or `Prelude.length', imported from `Prelude' (and originally defined in `Data.Foldable')
13:31:05 <hololeap> % :t \l -> (l !!) <$> randomRIO (0, Prelude.length l - 1)
13:31:05 <yahb> hololeap: [a] -> IO a
13:31:19 <hololeap> i'm not seeing how this would return [[Char]]
13:32:04 <hololeap> if you give the function a `[[Char]]`, it will return `IO [Char]`
13:32:17 <x0r-255> not what ghc says /shrug
13:33:24 <hololeap> ghc(i) just said so ^^ above ^^
13:33:38 <jumper149> Is there also a value of kinda :: Constraint, that represents no constraints at all?
13:33:55 <hololeap> jumper149: () :: Constraint
13:34:08 <jumper149> hololeap: ty :)
13:35:46 <x0r-255> I've tried using head and concat for this, but nothing is working, ugh
13:36:55 <hololeap> x0r-255: your randColor function you gave is of type `[a] -> IO a`
13:37:15 <hololeap> e.g. `[[Char]] -> IO [Char]`
13:37:21 <hololeap> there's no ambiguity here
13:37:25 <maerwald> What's the best data structure to stream into in a sorted fashion, without causing too much GC (bc streaming).
13:37:50 <maerwald> (so the stream is unsorted, but the structure should sort on insert)
13:38:08 <Cale> Data.Set?
13:38:11 <phadej> discrimation
13:38:16 <hololeap> maerwald: not sure about the GC issue, but Set does this
13:38:20 <phadej> deepends!
13:38:21 <jumper149> Its awesome that constraints are types :)))
13:38:28 <maerwald> Cale: but is that really efficient with streaming?
13:38:52 <maerwald> e.g. after 10k elements
13:38:59 <Cale> maerwald: I mean, you're going to be accumulating *something* regardless... Data.Set isn't too bad about trying to share subtrees
13:39:23 <Cale> There's probably something more optimal out there
13:39:45 <Cale> But it probably involves tricky mutable pointer shenanigans.
13:40:18 <ystael> maerwald: do you need it to be pure-pure or can you do effectful things to amortize the sort cost over inserts on access etc?
13:40:20 <MarcelineVQ> maerwald: I've gained a recent interest in patricia trees, so check those out (IntSet) :>  http://ittc.ku.edu/~andygill/papers/IntMap98.pdf appearantly they (big endiant patricia trees) keep fair cache locality if you're accessing sequentially
13:41:03 <Cale> I wouldn't be too afraid to *try* Data.Set and then see if it needs replacing
13:42:35 <x0r-255> hololeap: https://pastebin.com/WHXZ2StL <- this is what I'm trying to do, but I can't get it to work for the life of me
13:43:17 <maerwald> discrimination looks like an edward package with little docs :)
13:43:25 <hololeap> x0r-255: first of all, your type signature for randColor is incorrect
13:43:37 <hololeap> it is `[[Char]] -> IO [Char]`
13:43:42 <maerwald> ystael: doesn't matter
13:44:55 <x0r-255> okay, after that it wants [Char] and not IO [Char] how do I convert that?
13:46:30 <hololeap> `colors` would need to be `a -> Bool -> IO (String, String)`  (i'm not sure what this X type is)
13:47:23 <x0r-255> hololeap: It's the function type that xmonad uses
13:47:52 <x0r-255> is there no reasonable way to take an IO [char] and make it a regular [char]?
13:48:23 <hololeap> Oh, i would assume that this `X' has a MonadIO instance
13:49:08 <x0r-255> I'm new to haskell and have no idea what that means
13:49:33 <hololeap> x0r-255: try this: https://dpaste.com/CX2XK8XHV
13:50:31 <hololeap> you may need to import Control.Monad.IO.Class
13:51:42 <x0r-255> ah, finally, thank you so much...
13:53:11 <Orbstheorem> Why is `id` missing from protolude? :o
13:53:33 <Orbstheorem> Oh, it's called identity...
13:53:53 <hololeap> x0r-255: as to your last question, no... once something is inside IO, you can't (reasonably) get it out. luckily this X type is an instance of MonadIO, which says "i'm actually using the IO monad somewhere, and you are free to access it"
13:54:39 <ddellacosta> yeah and x0r-255 it's so common to ask that question that there was just a recent blog post on it: https://www.reddit.com/r/haskell/comments/hvf6j9/how_to_get_the_value_out_of_the_monad/
13:54:50 <ddellacosta> it's definitely a shift in thinking when you're getting familiar with Haskell
13:56:06 <monochrom> "get it out" is a pervasive subconscious XY problem.
13:56:28 <x0r-255> hm, well I'm glad ~~I~~ you finally got it working...
13:57:27 <monochrom> You get it out, only to give it away to a consumer. So why not just connect the producer with the consumer, and you stay out of it all?  This is >>=
13:58:50 <ddellacosta> I feel like this is a way in which do notation is kind of bad to introduce folks to right away, as it obscures what's going on in reality with `>>=`, which, if most people figured that out first, maybe would make some of these questions go away
13:59:00 <ddellacosta> but, who knows
13:59:07 <x0r-255> now I have a random color changing gridselect! sad that it needed so much effort... dang all it took was a monadIO type and using <- instead of while...
13:59:09 <monochrom> I know.
14:00:09 <monochrom> I haven't taught do-notation to my students for a year. I only tell them about >>= and show them how I use >>=. The students are doing much better than previous years with do-notation.
14:00:30 <ddellacosta> x0r-255: that is a feeling all of us know I think, so don't feel bad :-D
14:00:38 <ddellacosta> monochrom: interesting!
14:00:51 <monochrom> It helps that I phrase it as callback-based programming. Everyone understands callbacks.  producer >>= consumer_callback.
14:01:53 <monochrom> I guess we have javascript node.js etc to thank. People wouldn't take any callback story for granted otherwis.
14:02:15 <monochrom> Yes, recall 10-20 years ago when people were confused about callbacks.
14:02:16 <ddellacosta> I feel...conflicted about that. lol
14:02:19 <x0r-255> how might I dynamically repeat something in a list? say `{- def repeat... -} repeat 5 3 -> [5, 5, 5]`
14:02:51 <ddellacosta> take 3 $ repeat 5
14:03:05 <hololeap> :t replicate
14:03:07 <lambdabot> Int -> a -> [a]
14:03:07 <monochrom> When, like, there were in Java land as many SAX tutorials as we have monad tutorials. Because SAX's callback model was just as mind-bending.
14:03:23 <hololeap> % replicate 3 "foo"
14:03:23 <yahb> hololeap: ; <interactive>:35:1: error:; Ambiguous occurrence `replicate'; It could refer to; either `Data.Text.replicate', imported from `Data.Text'; or `Prelude.replicate', imported from `Prelude' (and originally defined in `GHC.List')
14:03:30 <hololeap> > replicate 3 "foo"
14:03:32 <lambdabot>  ["foo","foo","foo"]
14:03:38 * ddellacosta flashes back to SAX and all the stuff around XML back in the day in Javaland and shivers
14:03:39 <x0r-255> replicate ,thx
14:04:20 <monochrom> Let other language tutorials do the hard work. We in Haskell just reap the benefits!
14:05:50 <monochrom> Right? Suppose there is a concept you hate, and two languages L1 and L2 require you to learn it. Whichever one you learn first, you blame it; whichever one you learn after, you praise it.
14:06:19 <ddellacosta> haha I suppose you're right
14:06:43 <ddellacosta> Haskell's secret sweet spot: very few folks learn it as their first language, so it comes off looking good in comparison?
14:06:52 <monochrom> Yeah.
14:07:19 <monochrom> "Like node.js but we have no race condition"
14:08:59 <x0r-255> how might I take [1,2,3] and convert it to [1,1,1,2,2,3]? (probably using replicate map and !! but I'm not sure how
14:09:30 <monochrom> Why is it [1,1,1,2,2,3], rather than, say, [1, 2,2, 3,3,3]?
14:10:20 <x0r-255> I'm using foreground color specification, and I want the earliest items to have highest probability in the random element chooser
14:10:54 <monochrom> OK, but why is it not [1,1,1,1,1,2,2,2,3]?
14:11:25 <x0r-255> length of list I suppose
14:13:59 <x0r-255> could I use list comprehension for this?
14:14:17 <x0r-255> is there a way to get index via that?
14:14:47 <monochrom> I'm pretty sure the answers are all "yes can be done somehow" without saying how.
14:15:14 <ddellacosta> x0r-255: list comprehension sounds like a promising approach. I always reach for folds for whatever reason, here's a janky answer: snd $ foldl' (\(n, acc) m -> (pred n, (acc <> (take n $ repeat m)))) (3,[]) [1,2,3]
14:15:17 <monochrom> And impossible to say how because no one bloody knows why 1 appears 3 times rather than 10 times.
14:15:28 <ddellacosta> lol
14:15:54 <ddellacosta> yeah to monochrom's point I just did very literally what you wanted as far as output. no idea if it solves the general problem you're trying to solve
14:16:02 <monochrom> I mean we know 1 needs to appear more times than other elements. That's still like infinitely ambiguous.
14:16:24 <MarcelineVQ> ddellacosta: snd . mapAccumR (\n x -> (n+1,replicate n x))
14:16:25 <x0r-255> the amount of times it appears is length - index
14:16:31 <ddellacosta> MarcelineVQ: much better!
14:17:26 <monochrom> <W> I need a raise.  <B> Sure, how much?  <W> Any amount, just more.  <B> OK so raise by $1?  <W> No, you have to guess what I want.
14:17:56 <x0r-255> sorry for my lack of specificity
14:21:30 <MarcelineVQ> ddellacosta: snd . mapAccumR (flip (liftA2 (,) (+1) . flip replicate))  if you hate variable names, appearantly. I don't :>
14:21:53 <ddellacosta> hahaha yeah this always turns into golfing competitions
14:22:44 <ddellacosta> well, I guess your previous answer was more concise. Depends on what our golfing ideals are I suppose
14:22:51 <monochrom> Anyone want to be an accomplice with me on this project?  Make a language, it's like Haskell in all other aspects, but variables are replaced by de Bruijn numbering.
14:23:27 <glguy> That's a bit how it feels to use Factor
14:23:55 <monochrom> Hey! I think now I understand what people were thinking when they demand this syntax: (#1 + #2*#1) means (\x y -> x + y*x)
14:25:05 <monochrom> OK, cool, nothing to do then.
14:32:42 <x0r-255> monochrom how exactly does your solution work? I'm trying to modify it but am having some difficulty
14:33:06 <monochrom> I didn't give any solution.
14:33:15 <x0r-255> oh, sorry, ddellacosta
14:33:18 <x0r-255> my bad
14:39:42 <hololeap> x0r-255: you would have to break it down piece by piece. exercise for the reader :p
14:40:26 <hololeap> it's easier just to type [1,1,1,2,2,3] instead of trying to create something that generates it
14:41:11 <yushyin> monochrom: raku has this for blocks (sorted by unicode codepoints oO)
14:41:26 <x0r-255> yes, but I want to be able to add/remove colors and it'll follow (atm I have 6 and that'd be a little bit ugly(
14:41:27 <vfaronov> Hi. Is there a common typeclass that would represent a strategy for "adding" values to a "container"? Like this: https://paste.ubuntu.com/p/Pmgrpqk7fB/ -- not a semigroup because I don't have two "containers" to be "joined" together
14:41:35 <ddellacosta> x0r-255: sorry just saw your response. Can you tell me what you're having trouble with? I'd be happy to break it down for you
14:41:45 <hololeap> vfaronov: Alternative?
14:42:18 <x0r-255> how is n being modified?
14:42:50 <hololeap> no
14:43:31 <x0r-255> oh, I see -1 
14:43:58 <ddellacosta> x0r-255: ah so the n value gets passed as the first value in the tuple, and `pred` is just -- or (- 1) or whatever makes sense to you
14:44:00 <ddellacosta> yeah
14:44:02 <x0r-255> what's the acc part?
14:44:12 <x0r-255> where the values accumulate?
14:44:23 <ddellacosta> x0r-255: yeah, I use that when I'm being lazy about naming
14:44:44 <ddellacosta> so that just collects the lists and appends them with `<>`. Not super efficient
14:45:10 <x0r-255> better then what I'd come up with in haskell :D
14:45:17 <ddellacosta> but probably doesn't matter for small values like this
14:45:23 <hololeap> vfaronov: i don't think what you mean by "adding a value" is well defined
14:45:30 <ddellacosta> x0r-255: you should check out MarcelineVQ 's solutions above too
14:45:32 <x0r-255> what about snd?
14:45:48 <hololeap> vfaronov: what would the instance for Identity look like? if there isn't one, explain why
14:45:50 <MarcelineVQ> idk man, sure looks like semigroup to me, for example if your container can have a singleton, e.g.  (x : [])  then you can always have two containers to join
14:45:51 <ddellacosta> x0r-255: that takes the second value of the tuple, which is all we care about once we've folded that list
14:46:17 <x0r-255> folded the list as in? (index,item)?
14:46:50 <ddellacosta> x0r-255: sorry I just mean, after we're done with our fold, we're left with a tuple of (0, [1,1,1,2,2,3]) and all we want is that list
14:46:59 <x0r-255> ddellacosta - I looked at it and attempted to integrate it, however my type is [char] and couldn't figure out the mapAccumR stuff
14:47:00 <ddellacosta> so the snd grabs that for us
14:47:03 <x0r-255> I see
14:47:15 <MarcelineVQ> the issue with classes for things like insert is that it's really hard to be both general and useful/easy-to-use, insert for list and insert for Set have quite different requirements
14:47:30 <MarcelineVQ> *An issue with
14:48:40 <MarcelineVQ> pardon me I should have said Map when I said quite different, though Set is different enough given the Ord constraint
14:49:36 <hololeap> % feed f t x = t <> f x
14:49:37 <yahb> hololeap: 
14:49:48 <hololeap> % :t feed Product
14:49:48 <yahb> hololeap: Num a => Product a -> a -> Product a
14:49:57 <hololeap> % :t feed Sum
14:49:57 <yahb> hololeap: Num a => Sum a -> a -> Sum a
14:49:59 <vfaronov> sure it's not well defined, that's why I put it in scare quotes
14:50:00 <hololeap> % :t feed pure
14:50:00 <yahb> hololeap: (Semigroup (f a), Applicative f) => f a -> a -> f a
14:50:24 <hololeap> vfaronov: that's the closest thing to a pattern that i recognize
14:51:09 <hololeap> % :t feed
14:51:09 <yahb> hololeap: Semigroup a => (t -> a) -> a -> t -> a
14:55:09 <x0r-255> ddellacosta: why use `take n $ repeat m` over `replicate n m`? When I do the latter it always chooses item 0 of the list...
14:56:21 <vfaronov> hololeap: this helps, thanks!
14:57:05 <hololeap> no problem
14:57:18 <x0r-255> never mind about the always chooses 0 part, I sorted that
14:57:45 <ddellacosta> x0r-255: oh no real reason, just what I tend to reach for. I guess I like composing smaller functions for whatever reason. I think replicate is totally logical here though
14:58:05 <hololeap> % :t feed Identity
14:58:05 <yahb> hololeap: Semigroup (Identity a) => Identity a -> a -> Identity a
14:58:15 <hololeap> heh... what do ya know
14:58:24 <x0r-255> alright, cool
14:59:24 <ddellacosta> x0r-255: also, take a look at the implementation :-D https://hackage.haskell.org/package/base-4.14.0.0/docs/src/GHC.List.html#replicate
15:00:24 <x0r-255> hah!
15:08:17 <ddellacosta> x0r-255: I played around with MarcelineVQ 's first solution above--I had to concat at the end to get it produce what you want:
15:08:20 <ddellacosta> > concat $ snd (L.mapAccumR (\n x -> (n+1, replicate n x)) 1 [1,2,3])
15:08:22 <lambdabot>  error:
15:08:22 <lambdabot>      Not in scope: â€˜L.mapAccumRâ€™
15:08:22 <lambdabot>      Perhaps you meant one of these:
15:08:25 <ddellacosta> whoops
15:08:37 <ddellacosta> > concat $ snd (Data.List.mapAccumR (\n x -> (n+1, replicate n x)) 1 [1,2,3])
15:08:39 <lambdabot>  [1,1,1,2,2,3]
15:09:00 <ddellacosta> but that's kinda nice I think
15:10:45 <hololeap> % :t L.mapAccumR
15:10:46 <yahb> hololeap: ; <interactive>:1:1: error:; Not in scope: `L.mapAccumR'; Perhaps you meant one of these: `T.mapAccumR' (imported from Data.Traversable), `T.mapAccumL' (imported from Data.Traversable), `BS.mapAccumR' (imported from Data.ByteString); No module named `L' is imported.
15:10:55 <hololeap> % :t T.mapAccumR
15:10:55 <yahb> hololeap: Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)
15:11:08 <ddellacosta> oh maybe I'm using the wrong one
15:11:15 <hololeap> % :t T.mapAccumR (\n x -> (n+1, replicate n x))
15:11:15 <yahb> hololeap: ; <interactive>:1:28: error:; Ambiguous occurrence `replicate'; It could refer to; either `Data.Text.replicate', imported from `Data.Text'; or `Prelude.replicate', imported from `Prelude' (and originally defined in `GHC.List')
15:11:28 * hololeap grumbles
15:11:42 <hololeap> % :t T.mapAccumR (\n x -> (n+1, Prelude.replicate n x))
15:11:43 <yahb> hololeap: Traversable t => Int -> t a -> (Int, t [a])
15:12:44 <ddellacosta> no I guess not
15:12:51 <ddellacosta> but
15:13:42 <x0r-255> % :t let l = ["a", "b", "c"]; concat $ snd (T.mapAccumR (\n x -> (n-1, Prelude.replicate n x)) (length l) l)
15:13:42 <yahb> x0r-255: ; <interactive>:1:104: error: parse error (possibly incorrect indentation or mismatched brackets)
15:13:55 <ddellacosta> _xor:
15:14:05 <ddellacosta> x0r-255: if you want to execute use `>`
15:14:24 <ddellacosta> and sorry to the other person
15:14:28 <x0r-255> > :t let l = ["a", "b", "c"]; concat $ snd (T.mapAccumR (\n x -> (n-1, Prelude.replicate n x)) (length l) l)
15:14:30 <lambdabot>  <hint>:1:1: error: parse error on input â€˜:â€™
15:14:30 <MarcelineVQ> â€‹% is fine, it's for the yahb ghci bot
15:14:39 <ddellacosta> ah, okay, I didn't know that
15:14:41 <MarcelineVQ> it's more like ghci than lambdabot is
15:14:46 <x0r-255> > let l = ["a", "b", "c"] in concat $ snd (T.mapAccumR (\n x -> (n-1, Prelude.replicate n x)) (length l) l)
15:14:48 <MarcelineVQ> In that it's literally ghci :>
15:14:48 <lambdabot>  ["a","b","b","c","c","c"]
15:14:54 <ddellacosta> gotcha! Good to know
15:15:14 <x0r-255> > let l = ["a", "b", "c"] in concat $ snd (T.mapAccumR (\n x -> (n+1, Prelude.replicate n x)) (1) l)
15:15:16 <lambdabot>  ["a","a","a","b","b","c"]
15:15:19 <x0r-255> ah!
15:15:29 <ddellacosta> nice
15:15:34 <x0r-255> thanks MarcelineVQ & ddellacosta
15:15:40 <ddellacosta> sure thing
15:16:15 <MarcelineVQ> conceptually, in   mapAccumR f acc xs   as you go from left to right in  xs  your (acc)umulator is going from (R)ight to left
15:17:30 <ddellacosta> it's neat, I didn't know of its existence until you used that
15:18:05 <ddellacosta> I'm lazy and just use "vanilla" folds for everything
15:20:33 <hololeap> % foo l = join $ zipWith replicate [length l, length l - 1 .. 1] l
15:20:33 <yahb> hololeap: ; <interactive>:47:16: error:; Ambiguous occurrence `zipWith'; It could refer to; either `Data.Text.zipWith', imported from `Data.Text'; or `Prelude.zipWith', imported from `Prelude' (and originally defined in `GHC.List'); <interactive>:47:24: error:; Ambiguous occurrence `replicate'; It could refer to; either `Data.Text.replicate', imported from `Data.Text'; 
15:20:44 <hololeap> gosh that's annoying :/
15:20:52 <hololeap> > foo l = join $ zipWith replicate [length l, length l - 1 .. 1] l
15:20:54 <lambdabot>  <hint>:1:7: error: parse error on input â€˜=â€™
15:21:02 <hololeap> > let foo l = join $ zipWith replicate [length l, length l - 1 .. 1] l
15:21:04 <lambdabot>  <no location info>: error:
15:21:04 <lambdabot>      not an expression: â€˜let foo l = join $ zipWith replicate [length l, leng...
15:22:30 <hololeap> > let foo = \l -> join $ zipWith replicate [length l, length l - 1 .. 1] l
15:22:32 <lambdabot>  <no location info>: error:
15:22:32 <lambdabot>      not an expression: â€˜let foo = \l -> join $ zipWith replicate [length l, ...
15:22:41 <hololeap> wtf
15:22:52 <x0r-255> > let l = ["a", "b", "c"] in join $ zipWith replicate [length l, length l - 1 .. 1] l
15:22:54 <lambdabot>  ["a","a","a","b","b","c"]
15:22:57 <x0r-255> ay
15:22:59 <x0r-255> nice
15:23:20 <x0r-255> and I kind of understand this one
15:24:43 <hololeap> % :t P.zipWith
15:24:44 <yahb> hololeap: ; <interactive>:1:1: error:; Not in scope: `P.zipWith'; Perhaps you meant `BS.zipWith' (imported from Data.ByteString); No module named `P' is imported.
15:24:53 <hololeap> % :t L.zipWith
15:24:53 <yahb> hololeap: ; <interactive>:1:1: error:; Not in scope: `L.zipWith'; Perhaps you meant one of these: `BS.zipWith' (imported from Data.ByteString), `BSL.zipWith' (imported from Data.ByteString.Lazy); No module named `L' is imported.
15:25:27 <x0r-255> % :t zipWith
15:25:27 <yahb> x0r-255: ; <interactive>:1:1: error:; Ambiguous occurrence `zipWith'; It could refer to; either `Data.Text.zipWith', imported from `Data.Text'; or `Prelude.zipWith', imported from `Prelude' (and originally defined in `GHC.List')
15:25:35 <x0r-255> % :t Prelude.zipWith
15:25:35 <yahb> x0r-255: (a -> b -> c) -> [a] -> [b] -> [c]
15:25:40 <x0r-255> ^
15:26:17 <hololeap> i know... it just seems unnecessarily verbose just to refer to a function from Prelude
15:26:28 <x0r-255> indeed
15:36:25 <HoolaBoola> Hey, can anyone confirm if I'm right? I'm wondering whether something like this would start further recursion if the first condition is false:
15:36:27 <HoolaBoola> f :: (a -> Bool) -> Tree a
15:36:30 <HoolaBoola> f _ Empty = True
15:36:32 <HoolaBoola> f condition (Node a b) = condition a && f condition b
15:37:06 <HoolaBoola> (And the function signature should have -> Bool at the end...)
15:37:12 <glguy> ?src &&
15:37:12 <lambdabot> True  && x = x
15:37:12 <lambdabot> False && _ = False
15:37:33 <HoolaBoola> Oh, thanks
15:37:33 <glguy> If the first argument to && is False, then the second argument is not evaluated
15:37:46 <HoolaBoola> That was quite simple
15:38:04 <HoolaBoola> But yeah, thanks for clearing it up ^_^
15:38:53 <dminuoso> HoolaBoola: In functions, arguments are evaluated left-to-right (multiple arguments), then top-to-bottom (multiple definitions). :)
15:39:02 <HoolaBoola> Ah, of course! && is a function as good as any other, so this is clear
15:40:03 <HoolaBoola> dminuoso: thanks ^_^
15:46:18 <hpc> is left-to-right actually guaranteed?
15:46:48 <c_wraith> yes
15:47:07 <c_wraith> things like zipWith depend on that.
15:47:24 <dminuoso> hpc: Yes, by the haskell report.
15:47:26 <x0r-255> can cabal uninstall things?
15:47:31 <monochrom> No.
15:47:41 <c_wraith> or rather, common idioms depend on it 
15:47:48 <x0r-255> rm -rf is the only option then?
15:47:55 <dminuoso> hpc: in fact, you couldn't sensibly write a many tricks involving lazyness without it
15:48:18 <x0r-255> ltr evaluation is quite nice
15:49:10 <dminuoso> hpc: Or even, pattern matching wouldnt be predictable.
15:49:44 <dminuoso> I think?
15:49:52 <dminuoso> Ignore me, Im just tired.
15:50:09 <monochrom> Don't doubt yourself. Haskell Report makes it left-to-right alright.
15:50:46 <hpc> ah, i may have been confusing it with seq
15:51:15 <hpc> i don't really think about pattern matching that much, i just write stuff and it works :P
15:51:16 <fvc> how can I cast a double to an int?
15:51:27 <hpc> fvc: there's no casting in haskell, you have to round it in some way
15:51:27 <dminuoso> monochrom: I just cant put it together why it was a good thing.
15:51:28 <hpc> :t round
15:51:30 <lambdabot> (RealFrac a, Integral b) => a -> b
15:51:32 <hpc> :t ceil
15:51:33 <lambdabot> error: Variable not in scope: ceil
15:51:39 <hpc> :t ceiling -- er
15:51:40 <lambdabot> (RealFrac a, Integral b) => a -> b
15:51:44 <hpc> fvc: etc etc
15:51:53 <fvc> ok thank you
15:52:01 <monochrom> Perhaps they really mean cast, you know. Both are 64 bits.
15:52:15 <monochrom> We need to take people more literally.
15:53:01 <hpc> it could be a 32-bit system :P
16:03:49 <x0r-255> okay, so I have an xmobar config, and it's worked fine until now, when I decided to install xmobar via cabal from ghcup. But now it's not working at all, the only thing that seems to work is running it with the default config, any idea why? https://pastebin.com/WQi5HWVC
16:04:46 <dminuoso> monochrom: unsafeCoerce can't hurt, now can it?
16:05:03 <dminuoso> A little bit of coercing here and there..
16:07:48 <monochrom> @quote monochrom coerce
16:07:48 <lambdabot> monochrom says: isTrue = (unsafeCoerce :: Either a b -> Bool) . (unsafeCoerce :: Maybe c -> Either a b) . (unsafeCoerce :: Bool -> Maybe c)
16:07:59 <monochrom> totally correct use :)
16:09:26 <hpc> i once wrote a sorting algorithm where one of the subexpressions was (isn't unsafeCoerce)
17:18:41 <haskell_noob> hello why do they say haskell functions are right associative ie a -> b -> c is (a -> (b -> c))??
17:19:46 <haskell_noob> doesn't make sense to me considering f :: a -> b -> c and f 1 would return b -> c
17:20:12 <dolio> It does.
17:21:04 <haskell_noob> right associative means (b -> c) evaluated first in my mind somehow
17:21:24 <monochrom> left in the term level, right in the type level, and the two are consistent with each other.
17:21:42 <dolio> The associativity has nothing to do with evaluation.
17:22:00 <haskell_noob> I must be stupid because I can't see how it is right assoc
17:22:27 <dolio> It just means that the consecutive arrows get parenthesized to the right like you wrote.
17:22:42 <dolio> (a -> (b -> c)) instead of ((a -> b) -> c)
17:22:54 <monochrom> Perhaps always write explicit parentheses until you see why.
17:23:03 <haskell_noob> but (1 + (1+1)) is (1+1) first
17:23:16 <haskell_noob> then 1 + 2
17:23:54 <dolio> (+) is left associative, though.
17:24:05 <dolio> (I think.)
17:24:21 <haskell_noob> yes but parenth make that eq right associative
17:24:26 <dolio> Which means that `a + b + c` parses as `(a + b) + c`
17:24:35 <dolio> And has nothing to do with evaluation.
17:24:39 <infinisil> % :i (+)
17:24:39 <yahb> infinisil: type Num :: * -> Constraint; class Num a where; (+) :: a -> a -> a; ...; -- Defined in `GHC.Num'; infixl 6 +
17:25:48 <haskell_noob> if you take (a -> (b -> c)) in my mind b -> c is first
17:26:03 <dolio> First what?
17:26:15 <monochrom> No, it is only grouping and parsing, not "first" or "last".
17:26:33 <Axman6> haskell_noob: if f :: a -> b -> d -> d, then that means thatf :: a -> (b -> (c -> d)) and f x y z = ((f x) y) z
17:26:44 <Axman6> not f (x (y z))
17:27:11 <Axman6> so the arrow at the type level associates to the right, and function application associates to the left
17:28:09 <Axman6> f :: a -> (b -> (c -> d)) means: f is a function which accepts an a and returns (a function which accepts a b and returns (a function which accepts a c and returns a d))
17:28:23 <monochrom> Last ditch effort: If f :: Bool -> (Char -> Int), then f True :: Char -> Int, (f True) 'x' :: Int.  They go hand in hand.  Working it out symbolically is more reliable than arguing with words.
17:28:35 <Axman6> to return the things which are returned, the argument must be passed in first
17:28:50 <haskell_noob> why call it right associative then why not just say function currying is equivelent to blah blah blah
17:29:07 <Axman6> because (->) is right associative
17:29:09 <haskell_noob> and operator -> does blah
17:29:27 <haskell_noob> but its not evaluating anything
17:29:39 <Axman6> no, this has nothing to do with evaluation
17:29:41 <dolio> Why don't you just accept that 'right associative' has to do with parsing, not evaluation?
17:29:45 <monochrom> That's what dolio was saying.
17:29:54 <Axman6> it has to do with what AST is built from the syntax
17:30:10 <monochrom> When did types ever evaluate anything anyway?
17:31:15 <haskell_noob> I get it now but bad description of it imho
17:31:24 <monochrom> sour grape
17:31:29 <haskell_noob> lol
17:32:13 <Axman6> it's the same description that anyone with any background in parsing would give you, because it is precise and acxurate
17:32:38 <Axman6> your misunderstanding of something does not make that something poorly described :)
17:33:27 <monochrom> My students are able to come up with the wording "right associative" themselves.
17:33:28 <haskell_noob> I think your right when you mentioned AST it made sense but I was thinking mathematically
17:34:04 <Axman6> association is all about the AST, it has nothing to do with evaluation
17:34:08 <monochrom> I told them "X->Y->Z means X->(Y->Z)" without any suggestive English wording, they are able to say "ah so it's right associative".
17:34:15 <Axman6> the same is true in mathematics
17:34:18 <monochrom> I say this as evidence that people understand this wording.
17:35:48 <haskell_noob> guess your students are really smart compared to me
17:36:09 <monochrom> I don't believe that.
17:36:22 <monochrom> Stubborn and self-centred, sure.
17:37:10 <monochrom> I don't even believe that you believe that. You're saying it to be sarcastic.
17:37:38 <haskell_noob> lol
17:39:05 <haskell_noob> you know I hated haskell when going to uni now here I am learning it for fun :)
17:41:03 <haskell_noob> can haskell expressions be evaluated here?
17:41:50 <haskell_noob> I mean is there a bot in this channel
17:41:54 <haskell_noob> ?
17:42:05 <DigitalKiwi> yes
17:42:18 <DigitalKiwi> there is lambdabot
17:42:37 <DigitalKiwi> and yahb
17:42:55 <DigitalKiwi> did multibot used to be here too
17:42:59 <haskell_noob> lambdabot 2 +2
17:43:19 <DigitalKiwi> > 2+2
17:43:21 <lambdabot>  4
17:43:34 <DigitalKiwi> % 2+2
17:43:34 <yahb> DigitalKiwi: 4
17:43:35 <haskell_noob> > :t (2+)
17:43:36 <lambdabot>  <hint>:1:1: error: parse error on input â€˜:â€™
17:43:53 <haskell_noob> :t (2+)
17:43:54 <lambdabot> Num a => a -> a
17:44:07 <haskell_noob> :t (+2)
17:44:09 <lambdabot> Num a => a -> a
17:44:15 <haskell_noob> ok cool
17:46:22 <haskell_noob> anyone working on anything commercial in haskell here?
17:50:29 <Axman6> Technicaslly I'm working in DAMl. which is Haskell++
17:52:13 <Axman6> but have been using Haskell commercially for the past 5 years. there's plenty of others here doing the same thing, and many more who aren't here
17:57:38 <Axman6> haskell_noob: we're working on https://www.asx.com.au/services/chess-replacement.htm, it's a pretty awesome project
18:02:09 <haskell_noob> Asman6 that's awesome
18:02:15 <haskell_noob> Azman6*
18:02:21 <haskell_noob> Axman6*
18:02:24 <haskell_noob> :(
18:05:13 <Axman6> ax<tab> is enough :)
18:10:21 <x0r-255> is there a more optimized way to get a range of chars from type [char] then \x->[x !! 0, x !! 1, x !! 2 etc]?
18:10:35 <x0r-255> optimized and practical*
18:11:14 <koala_man> what? do you want the first N elements of a list?
18:11:23 <x0r-255> that'll work
18:11:31 <koala_man> :t take
18:11:32 <lambdabot> Int -> [a] -> [a]
18:12:31 <x0r-255> > take 2 "abcd"
18:12:33 <lambdabot>  "ab"
18:24:30 <jumper149> I found that one can access the version in the cabal file with Paths_name.version, when Paths_name is in other-modules. But how can I see everything that gets exported from Paths_name?
18:47:19 <Axman6> jumper149: possibly using :browse in ghci?
18:50:52 <MarcelineVQ> Axman6: This isn't a new version of chess at all, I don't even see a king. I've been cheated and wish to be unsubscribed to your newsletter.
18:51:36 <ezzieyguywuf> hm, if I have a two lists, [In 1, In 2] and [Out 2, Out 3], how might I go about processing these to create a third list [In 1, InOut 2, Out 3]?
18:52:56 <ezzieyguywuf> the lists can't be expected to be in any particular order, or necessarily the same length either
18:53:42 <ezzieyguywuf> and, `data Direction = In Int | Out Int | InOut Int`
18:56:18 <MarcelineVQ> start by writing your type signaure :>
18:58:31 <ezzieyguywuf> well, using the simplified data types shown here, `getAdjacencies :: Int -> SomeState [Direction]` where the `Int` is an index to the data in SomeState
18:59:58 <MarcelineVQ> The literal description of your problem as a type would look to me like   combineFoo :: [Direction] -> [Direction] -> [Direction]
19:00:33 <ezzieyguywuf> ah, I see what you mean. I was trying to encode this within `getAdjacencies`, but you're right, the actualy problem statemest is as you've outlined
19:00:38 <ezzieyguywuf> *statement
19:17:51 <ezzieyguywuf> maybe I make Direction into a functor or something...
19:21:52 <hololeap> ezzieyguywuf: look into the "these" and "align" package s
20:03:49 <hyiltiz> Is there a better way to rewrite this? wholePiePower n = head  . sort . take n . map (\x -> let (a,b) = properFraction  (pi^^x) in (b,a,x) ) $ [1..]
20:04:26 <hyiltiz> It is looking for pi^n that is closest to an integer. Also, it easily overflows...
20:07:08 <hyiltiz> I didn't need to sort; just had to take the `min`, but `min` has no instance for [(a,b)] types. Also, keeping around n inside the tuple seem redundant; it is the index in the list after all.
20:07:24 <Cale> minimum should work on pairs
20:07:36 <Cale> :t minimum
20:07:38 <lambdabot> (Foldable t, Ord a) => t a -> a
20:07:40 <Cale> :t min
20:07:41 <lambdabot> Ord a => a -> a -> a
20:07:44 <hyiltiz> but not sure how to rewrite it, still concisely, using min and not using x
20:08:58 <hyiltiz> thx minimum works; as far as ghci is concerned no difference in space or speed usage tho
20:09:00 <Cale> (but sorting is pretty much fine, since if you only take the head of the sorted list, you only pay slightly more than computing the minimum)
20:10:25 <glguy> I'm out of the loop on optics vs lens now. Anyone switched any code over?
20:10:29 <Cale> https://hackage.haskell.org/package/rounded might be useful
20:11:02 <Cale> tsk, marked as broken in nix
20:11:15 <Cale> There are a bunch of others of that sort
20:11:47 * nshepperd is happy with lens
20:12:40 <Cale> I use neither most of the time, but when I lens, I use lens
20:13:07 <Cale> I think the time for lenses is when you want to abstract over the choice of a lens
20:13:18 <Cale> at least, *a* time for lenses is that
20:14:40 <hyiltiz> https://wiki.haskell.org/Applications_and_libraries/Mathematics#Arbitrary_precision lists too many options none of which seem concise ;(
20:15:40 <jumper149> Axman6: Thank you :) That worked perfectly!
20:15:44 <Cale> hyiltiz: Basically all you need is something which has a Floating instance
20:16:02 <Cale> If you have a type that supports Floating and does the higher precision stuff, you're good :)
20:16:02 <hyiltiz> hmm in fact I only care about the remainder and the exponent, not the integer at all so the output is enough to be Double
20:16:13 <hyiltiz> Internal representations need high precision tho
20:17:45 <hyiltiz> So it is more like: minimum . take 1000 . map (\x -> let (_,b) = properFraction  (pi^^x) in (b,x) ) $ [1..]
20:19:09 <glguy> I started converting my IRC client over from lens to optics the other day and its more fussy types pointed out a bunch of places where I was being clever with lens.
20:19:47 <dolio> I think there's a better strategy for finding the answer if you know about modular arithmetic.
20:21:13 <dolio> Hmm, perhaps not.
20:23:02 <hyiltiz> dolio: u mean maybe using the generating sequence mod integers?
20:29:07 <infinisil> glguy: And that's good or bad?
20:29:30 <glguy> I hadn't decided :) probably good to be less clever
20:32:56 <hyiltiz> Or maybe the formalism of Optics wasn't as rich as lens (as is also described in their doc)
20:43:40 <glguy> lens isn't so much richer as looser
20:48:48 <glguy> Though there were some helper functions that were just missing
21:23:14 <dhananjay> Does deriving via support orphan instances? i.e can I write something like instance Foo FancyText derive via Text?
21:23:35 <glguy> dhananjay: You'd use StandaloneDeriving
21:24:40 <glguy> see https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#deriving-strategies
21:25:17 <glguy> and the last line of https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#deriving-via
21:28:55 <x0r-255> I have cabal installed atm but am planning to change linux distros soon, should I hop over to stack instead? I've heard it's easier than cabal to use and maintain.
21:29:44 <dhananjay> glguy: v.cool, thanks
21:30:27 <glguy> x0r-255: With the updated "v2-build" stuff in cabal now it's easiest to use ghcup to install versions of GHC an to use cabal for building
21:32:02 <glguy> stack and cabal don't have exactly the same features, so if you find you need something specific one does in the future you can switch. They both use the same package file format
21:32:11 <x0r-255> I don't do too much building, atm only xmonad stuff, but I've had quite a bad time with cabal so far, isn't stack able to uninstall stuff too?
21:32:13 <x0r-255> oh, huh
21:32:51 <glguy> no, stack doesn't add uninstall
21:32:54 <x0r-255> I'm on an arch-based system btw (why cabal suucks for me)
21:33:47 <glguy> yeah, arch makes things hard, but you can use a standalone GHC without using arch's
21:34:31 <x0r-255> that's what I had to do, I couldn't install packages without doing that
21:34:39 <x0r-255> it was a whole thing earlier
21:36:07 <sm[m]> x0r-255: why not try ? stack makes ghc management a non issue
21:36:24 <sm[m]> itâ€™s good to know both a little
21:36:48 <x0r-255> I just don't want to fall into a hellhole like I did when trying to install stuff earlier
21:38:46 <sm[m]> I donâ€™t use arch, but I believe lots of arch users just installed stack and got on with their life
21:40:27 <x0r-255> welp, when I get my new install I'll give it a shot and if it goes awry then I'll just do what I did for cabal, lets hope it doesn't come to that
21:41:00 <sm[m]> I guess itâ€™s good to have two tools handy - when one is a nightmare thereâ€™s a chance the other will just work and you wonâ€™t have to think too hard about it
21:41:20 <sm[m]> like wifi routers
22:38:55 <hyiltiz> Which of https://wiki.haskell.org/Debugging is commonly used in a project of at least an IRC-bot size?
22:41:42 <suzu_> lots of Debug.Trace
23:15:48 <glguy> Trace is hard to use on a bot, I find. I'd recommend building your bot to write to a logger that can be toggled at runtime and make your bot state record something easy to write to file to inspect
23:20:31 <hyiltiz> Oh, I was only using IRC-bot as a measure of project size (it is fairly simple but not too trivial)
23:20:50 <hyiltiz> thx!
23:25:31 <hyiltiz> Hood.observer seems quite useful, isn't it?
