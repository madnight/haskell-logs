00:35:42 * hackage zre 0.1.3.0 - ZRE protocol implementation  https://hackage.haskell.org/package/zre-0.1.3.0 (srk)
00:39:37 <rredpoppy> shachaf I saw natural stransformation implementations, the one I use is from kmett, so I am guessing he knows his stuff
00:40:11 <shachaf> I mean, I understand why it's written the way it is.
00:42:39 <rredpoppy> schachaff Is till don't understand why flip "flipped" the constraints, but tested and it works now. I needed to replace nodes with empty values for some additional properties with their filled counterpart
00:43:10 <shachaf> It didn't flip any constraints.
00:43:11 <rredpoppy> I flipped hoistFree just to get the lambda expr in the last position
00:43:35 <shachaf> :t let f :: (forall a. Maybe a) -> (forall a. Maybe a) in f
00:43:37 <lambdabot> error:
00:43:37 <lambdabot>     The type signature for ‘f’ lacks an accompanying binding
00:43:37 <lambdabot> error:
00:43:41 <rredpoppy> schachaf just trying to do wordplay :) I don't understand why flip 
00:43:47 <shachaf> :t let f :: (forall a. Maybe a) -> (forall a. Maybe a); f x = x in f
00:43:48 <lambdabot> (forall a1. Maybe a1) -> Maybe a
00:43:50 <shachaf> :t let f :: (forall a. Maybe a) -> (forall a. Maybe a); f x = x in id f
00:43:51 <lambdabot> error:
00:43:51 <lambdabot>     • Couldn't match expected type ‘a’
00:43:51 <lambdabot>                   with actual type ‘(forall a2. Maybe a2) -> Maybe a1’
00:45:18 <rredpoppy> so I have fillWith :: Vals -> MyTree a -> MyTree a
00:46:09 <rredpoppy> fillWith vals = hoistFree $ \ lambda that uses vals to convert functor 
00:46:56 <rredpoppy> when doing fillWith vals ast = flip hoistFree ast $ \lambda .. I get the error 
00:47:12 <rredpoppy> :t flip
00:47:13 <lambdabot> (a -> b -> c) -> b -> a -> c
00:47:37 <rredpoppy> :t hoistFree
00:47:38 <lambdabot> Functor g => (forall a. f a -> g a) -> Free f b -> Free g b
00:48:29 <rredpoppy> so interpreting b from hoistFree pins down the type for a in fillWith?
00:48:45 <rredpoppy> because it changed the order of args?
00:50:14 <rredpoppy> did I understand it correctly, schachaf ?
00:51:52 <shachaf> Hmm, I don't know the exact answer for why this happens with higher-rank types.
01:02:06 <rredpoppy> shachaf thank you very much again
01:08:07 <int-e> The proper explanation probably involves https://wiki.haskell.org/Impredicative_types (the type checker perspective from https://gitlab.haskell.org/ghc/ghc/-/wikis/impredicative-polymorphism may be more informative actually)
01:12:17 <int-e> :t let id :: forall a. a -> a; id = id id in id
01:12:18 <lambdabot> a -> a
01:13:36 <int-e> :t let id :: (forall a. a) -> (forall a. a); id = id id in id
01:13:37 <lambdabot> error:
01:13:37 <lambdabot>     • Cannot instantiate unification variable ‘a0’
01:13:37 <lambdabot>       with a type involving foralls: (forall a3. a3) -> a2
01:14:11 <int-e> err that last one made no sense
02:18:09 <NewToHaskell> Hi, could someone verify if I am thinking correctly? `mutiList = foldr (*) 1 [2,3,4,5]` is doing `2 * (3 * (4 * (5 * 1)))` right?
02:21:20 <phadej> yes
02:24:58 <int-e> > foldr (*) a [1,2,3,4,5]
02:25:00 <lambdabot>  1 * (2 * (3 * (4 * (5 * a))))
02:25:12 * hackage tracing-control 0.0.6 - Distributed tracing  https://hackage.haskell.org/package/tracing-control-0.0.6 (AlejandroSerrano)
02:25:48 <int-e> > foldr (*) (1 :: Expr) [1,2,3,4,5]
02:25:51 <lambdabot>  1 * (2 * (3 * (4 * (5 * 1))))
02:26:35 <int-e> Oh, sorry, I added an extra 1.
02:26:44 <NewToHaskell> That's cool, can I type something in ghci to get the same result lambdabot is typing out?
02:27:08 <int-e> You can, with the simple-reflect package https://hackage.haskell.org/package/simple-reflect
02:27:13 <int-e> (lambdabot uses that as well)
02:31:32 <NewToHaskell> int-e, so I unzipped the .tar file now what do I do? =)  
02:35:43 <int-e> Ah. The best way to install haskell packages is to use one of the build tools... cabal-install or stack. The manual way is:  ghc --make Setup.hs; ./Setup configure; ./Setup build; ./Setup install? I have not done that in ages... (and never on any platform other than Linux)
02:37:07 <int-e> (simple-reflect is nice in that it has no dependencies other than base... usually the manual way involves chasing down dependencies and installing those as well)
02:38:37 <int-e> With cabal-install it's just `cabal update` to fetch the package database, and `cabal install simple-reflect`, stack should be similar. I'm sure there are decent tutorials for this out there but I'm afraid I don't know any.
02:41:13 <NewToHaskell> int-e, now with `cabal install simple-reflect` complete, how do I invoke the bot in ghci? =)  
02:43:02 <int-e> NewToHaskell: I'd hope that  import Debug.SimpleReflect  now works in ghci
02:43:27 <int-e> NewToHaskell: and then you can write expressions like  foldr (*) (1 :: Expr) [1,2,3,4,5]
02:43:43 <int-e> (it's not a bot, it's pure Haskell)
02:44:03 <NewToHaskell> oh it works, cheers! =)  
03:05:32 <NewToHaskell> Can I use the debug on this? `let fibs = take 10 $ 0 : 1 : zipWith (+) fibs (tail fibs)` like I did with `mutiList = foldr (*) 1 [2,3,4,5]` to get `2 * (3 * (4 * (5 * 1)))`
03:10:13 <AWizzArd> Does Hackage check if a module compiles before I can upload it? I am looking at the  https://hackage.haskell.org/package/HaskellNet-SSL  package.
03:10:16 <AWizzArd> See the import of PortNumber https://github.com/dpwright/HaskellNet-SSL/blob/master/src/Network/HaskellNet/SSL.hs#L6 which is NOT exported by https://github.com/dpwright/HaskellNet-SSL/blob/master/src/Network/HaskellNet/SSL/Internal.hs
03:10:19 <NewToHaskell> `let fibs = take 10 $ (0 :: Expr) : (1 :: Expr) : zipWith (+) fibs (tail fibs)` seems to work.
03:10:29 <AWizzArd> Shouldn’t that fail to compile?
03:20:31 <merijn> AWizzArd: Why?
03:22:29 <mniip> I see
03:23:07 <merijn> AWizzArd: Hackage doesn't check anything except the cabal/sdist file
03:23:43 <merijn> AWizzArd: Ah, you were referring to the SSL things with "shouldn't that fail to compile" :)
03:29:03 <rredpoppy> int-e thanks
03:29:22 <mniip> so the bug with hackagebot was because if someone edits the package synopsis while it's in the recent.rss table, the bot had had a hard time matching up the last remembered list with the new list
03:30:07 <mniip> looking at you topos
03:31:59 <AWizzArd> merijn: Yes, it seems that when the author of that lib would try to compile it – it should fail. Do you agree?
03:32:02 <maralorn> Apparently hackage is down?
03:32:41 <merijn> maralorn: It's just really slow here
03:32:51 <merijn> AWizzArd: Probably, yes
03:33:16 <AWizzArd> merijn: But good to know that there is no check. This explains why the package landed on Hackage.
03:33:19 <merijn> AWizzArd: Then again, the github repo has tests running against GHC 7.1 and 7.8 and hasn't seen activity in a year, so...I'd lower expectations appropriately
03:33:45 <maralorn> merijn: Hm, I got `Error 503 Backend unavailable, connection timeout` thrice in a row.
03:33:54 <AWizzArd> merijn: how could one deal with this best? Cloning the repo, fix it quickly and compile against that local stuff instead of the version on Hackage?
03:34:21 <merijn> AWizzArd: In this case I'd say "by not using this highly questionable package" :)
03:35:24 <AWizzArd> merijn: I am using an older version, which compiles and works fine. Now trying to upgrade to lts-16.5 and GHC 8.8 with this.
03:35:59 <AWizzArd> merijn: The nice thing is that it supports sending mails via tls.
03:36:30 <merijn> AWizzArd: In this case since it doesn't compile I'd make 1) an issue with the repo, 2) make a trustees issue to mark this version as unbuildable so cabal doesn't select it for build plans, 3) fork it and work against the fork for now
03:37:29 <vaibhavsagar> silly question: why aren't unboxed vectors foldable?
03:37:37 <merijn> vaibhavsagar: Unbox constraint
03:37:51 <merijn> oh wait, I guess that doesn't apply for Foldable
03:38:01 <AWizzArd> merijn: thx for mentioning suggestion 2. I haven’t seen this before. Good.
03:38:02 <merijn> Historical oversight?
03:38:06 <vaibhavsagar> hmm
03:38:08 <merijn> AWizzArd: THose weren't alternatives
03:38:11 <merijn> AWizzArd: Those were steps
03:38:25 <AWizzArd> Yes. I just haven’t heard/read about this trustees thing before.
03:38:46 <vaibhavsagar> what trustees thing?
03:38:49 <merijn> vaibhavsagar: That said, the master has a bunch of updates to add missing pieces of the API, but it's unreleased as of yet
03:38:50 <vaibhavsagar> I'm a trustee
03:39:03 <vaibhavsagar> (assuming you mean hackage trustee)
03:39:03 <AWizzArd> vaibhavsagar: I guess this one: https://wiki.haskell.org/Hackage_trustees
03:39:17 <merijn> vaibhavsagar: Unbuildable package upload that probably needs to be marked as unbuildable
03:39:24 <vaibhavsagar> oh yeah
03:40:03 <vaibhavsagar> you'll probably want to make an issue here: https://github.com/haskell-infra/hackage-trustees
03:40:08 <merijn> AWizzArd: You could also try to take over the package if the maintainer(s) don't respond and you rely on it
03:40:09 <vaibhavsagar> if you haven't already
03:40:14 <AWizzArd> vaibhavsagar: oki, thanks
03:40:54 <vaibhavsagar> and the process takes a certain amount of time, so if you are in a hurry you will want to clone locally and make changes for now
03:40:54 <AWizzArd> merijn: do you know about another package that can send tls-encrypted mails via the AWS smtp servers?
03:41:15 <AWizzArd> vaibhavsagar: yes, will try a local clone for now.
03:41:39 <AWizzArd> bbl
03:43:14 <vaibhavsagar> merijn: it turns out you suggested Foldable for unboxed vectors some time ago https://github.com/haskell/vector/issues/263
03:43:42 <merijn> vaibhavsagar: ha, I wasn't sure whether I complained about just the API, but also Foldable :p
03:44:07 <vaibhavsagar> at the very least you complained about the inconsistent API
03:48:15 <vaibhavsagar> also I'm not seeing an obvious way to go from unboxed to boxed vectors
03:48:16 <vaibhavsagar> seems jank
03:48:22 <merijn> There is
03:48:30 <merijn> Vector.Generic has "convert"
03:48:39 <vaibhavsagar> oh interesting
03:48:59 <merijn> Oh, it's in Data.Vector too
03:49:47 <vaibhavsagar> ah, thanks for the pointer
03:50:21 <vaibhavsagar> I'm running into this stuff because I found this cool paper that I'm trying to implement in Haskell: https://arxiv.org/abs/1702.03154
03:51:49 <vaibhavsagar> and I'm trying to use bv-little, which seems to work pretty well but only works with Foldables so I can't make a a bitvector from an unboxed vector of bools
03:52:59 <vaibhavsagar> even though I could copy the implementation, remove the Foldable constraint, and expect it to work
04:10:57 * hackage tree-sitter-ql 0.1.0.4 - Tree-sitter grammar/parser for QL  https://hackage.haskell.org/package/tree-sitter-ql-0.1.0.4 (robrix)
04:37:46 <gentauro> does `System-F` do a converstion to/from `deBruijn-indexes`?
04:38:39 <gentauro> if yes, why don't we have `semantic versioning` in Haskell :) (`foo = 1 : map (+) foo` should be semantically equivalent to `bar = 1 : map (+) bar`)
04:41:08 <int-e> gentauro: wtf?
04:45:42 <int-e> System F is a typed lambda calculus, which is agnostic to how variables are represented. How this relates to names under which you can access constants and types across modules is unclear; those are a source language phenomenon, which, in the case of Haskell, uses names as identifiers.
04:47:30 <merijn> gentauro: We don't have semantic versioning because intensional equality of code is boring and not very useful and extensional equality is never ending rabbit hole we don't know how to do in a general useful way
04:49:03 <AWizzArd> Can I do a reverse-search on Hackage and see for a given package P what other packages are depending on P?
04:49:19 <merijn> AWizzArd: https://packdeps.haskellers.com/reverse
04:49:27 <merijn> hmm
04:49:31 <merijn> except that's down now :p
04:49:53 <AWizzArd> An exception! Not a compile time error (:
04:50:36 <int-e> But `foo = 1 : map (+) foo` is not even equivalent to `bar = 1 : map (+) bar` on the top level if exported, because the name is part of the module interface.
04:51:51 <xsperry> how would I represent states, cities, and boroughs in haskell? ideally it should be statically checked that location is valid
04:53:24 <int-e> Hmm, I feel that I'm missing a meaning of "semantic versioning" that goes beyond the promise (by the developer) of a preserved API.
04:53:29 <int-e> (or not)
04:53:54 <int-e> that is, https://semver.org/
04:56:41 <merijn> int-e: I think he meant semantic versioning as in "versioning semantics of code" rather than "having semantics for our versioning" (as semver pretends to have)
04:57:22 <merijn> int-e: His "foo" and "bar" examples are intensionally equivalent modulo alpha renaming and thus have the same semantics
04:57:55 <merijn> So like Dhall's semantic hashes
05:04:11 <int-e> so... I guess it does partial evaluation to a kind of symbolic normal form... I wonder at what level of complexity this will stop working.
05:04:27 <int-e> (after all, solving the halting problem is hard)
05:05:13 <merijn> int-e: Dhall isn't Turing complete, so problem solved :p
05:05:23 <merijn> It can just evaluate to normal form
05:05:30 <int-e> that would help
05:05:55 <gentauro> int-e: hmmmm
05:05:57 <int-e> reverse . replicate k = replicate k
05:05:57 <merijn> int-e: You should check it out, Dhall is super cool!
05:06:25 <merijn> https://dhall-lang.org/
05:07:13 <NewToHaskell> Could someone show me how nub was implemented if it isn't too complex? I made my own           
05:07:13 <NewToHaskell> nub' []  = []
05:07:29 <NewToHaskell> while real nub keeps the first duplicate, like this `[3,4,2,1]`
05:07:36 <gentauro> int-e: but it should be possible to do something similar to what `unison` is doing right?
05:08:18 <merijn> gentauro: That's really hard to do and basically an unsolved issue
05:09:42 <gentauro> merijn: perhaps it's not solved, but I think it is do-able
05:10:06 <gentauro> personally, I think it's the coolest feature `unison` has
05:10:08 <merijn> gentauro: You should look into the rabbit hole of "intensional equality" in dependent types :p
05:10:21 <merijn> Conor McBride has a bunch of stuff about that, I think
05:11:19 <gentauro> merijn: thx, will look into it :)
05:11:30 <int-e> Okay, reverse looks like a builtin?
05:11:31 <merijn> gentauro: eh, wait
05:11:35 <merijn> extensional equality, I mean
05:11:45 <gentauro> merijn: Google already told me that ;)
05:11:49 <int-e> if I'm reading https://prelude.dhall-lang.org/List/reverse correctly
05:11:53 <dmj`> @src nub
05:11:53 <lambdabot> nub = nubBy (==)
05:11:53 <lambdabot> --OR
05:11:53 <lambdabot> nub l = go l []
05:11:53 <lambdabot>   where go []     _       = []
05:11:53 <lambdabot>         go (x:xs) ls
05:11:55 <lambdabot>             | x `elem` ls = go xs ls
05:11:57 <lambdabot>             | otherwise   = x : go xs (x:ls)
05:12:12 <int-e> So I guess it can have builtin reduction rules including simplifying reverse . replicate
05:13:07 <gentauro> 13:53 < int-e> that is, https://semver.org/
05:13:37 <gentauro> should actually be called `synver.org` cos what they aim for is `syntactic versioning` (if the API changes, then do stuff)
05:14:24 <gentauro> what my def og `semantic versioning` stands for is actually if the `content` of a function changes, then we should do a major/minor change
05:14:58 <gentauro> but if the content is semantically equivalent, then it should be a patch (for example renaming a variable or adding comments)
05:15:59 <merijn> gentauro: Right, but deciding if something is "semantically equivalent" is (in most languages) undecidable :)
05:16:13 <merijn> And in the ones where it *isn't* undecidable it's still an unsolved problem :p
05:16:14 <gentauro> this notion resulted in the following .NET tool -> https://github.com/fsprojects/SyntacticVersioning#maintainers
05:16:39 <int-e> gentauro: X/Y problem. You're asking about semantic versioning, but you seem to want to do it automatically which requires detecting semantic changes, for which "semantic hashing" is the better keyword.
05:17:22 <gentauro> merijn: true that, which is why I like the approach of `unison` where they just `normalize` code and if the `hash` differes, well then it's not semantically the same ;)
05:17:30 <gentauro> so they can rename and do some `basic` stuff
05:17:37 <int-e> I find  let map = https://prelude.dhall-lang.org/List/map  cringy btw.
05:17:50 <gentauro> int-e: yes, automation. That's why we have computers ;)
05:18:06 <merijn> int-e: Why?
05:18:26 * hackage vulkan 3.6.1 - Bindings to the Vulkan graphics API.  https://hackage.haskell.org/package/vulkan-3.6.1 (jophish)
05:18:43 <int-e> merijn: Syntax aside, what does it imply? does that mean I can't compile stuff when I'm offline?
05:18:49 <int-e> Or run, whatever.
05:19:01 <merijn> int-e: You can just download the file and use that
05:19:26 * hackage VulkanMemoryAllocator 0.3.5 - Bindings to the VulkanMemoryAllocator library  https://hackage.haskell.org/package/VulkanMemoryAllocator-0.3.5 (jophish)
05:19:55 <AWizzArd> Error message:  ‘fail’ is not a (visible) method of class ‘Monad’
05:20:08 <AWizzArd> Is this something that might have changed between GHC 8.2 and 8.8?
05:20:13 <merijn> AWizzArd: Yes
05:20:18 <merijn> AWizzArd: MonadFail is now in force
05:20:29 <AWizzArd> Oki, thx.
05:20:51 <merijn> AWizzArd: Partial pattern matches in do notation (and manual uses of fail) incur a MonadFail constraint (instead of just Monad)
05:22:30 <merijn> int-e: Essentially there's no module system/cabal/whatever, you can just import directly from files (and URLs) instead so you don't need extra tooling
05:25:59 <int-e> Meh, modern software. We really go out of our way to add new points of failure everywhere... :-/
05:26:31 <merijn> int-e: It's a config file format, you're supposed to generate a final static config and use that
05:27:01 <int-e> Sure, and then you wait a year, something breaks, you want to update your configuration, and...
05:27:10 <merijn> int-e: In a company setting it can be quite convenient to have servers/services host their "config format"
05:27:45 <merijn> int-e: That's why you host stuff yourself. The prelude stuff on their website is just for convenience for demos and stuff
05:27:52 <merijn> If you depend on that hosting your an idiot
05:28:00 <int-e> (sure, this can happen with traditional package systems too. but they make it easier and more obvious to store source tarballs)
05:28:28 <int-e> merijn: but all their examples use it, so I'd bet it also happens in produyction.
05:29:13 <int-e> and it'll go unnoticed for their prelude because github is largely stable
05:29:13 <merijn> Stupid people will be stupid regardless of what you do
05:29:55 <int-e> you don't have to make it easy
05:30:45 <merijn> The alternative is shipping your prelude with every library/binding for dhall and keeping those in sync across different languages and platforms...
05:41:04 * ski . o O ( <https://gbracha.blogspot.com/2009/06/ban-on-imports.html>,<https://gbracha.blogspot.com/2007/12/some-months-ago-i-wrote-couple-of-posts.html> )
05:56:38 <frdg> I am using yesod and have finally been able to secure a connection with my database. If someone here is familiar with yesod I could use an explanation of what the output of running main means. https://dpaste.org/vFWL
05:59:56 <kiwi_45> hello all, if servant-auth server only supports httpOnly ? I'm able to set cookie headers with servant-auth but I'm not able to access those cookie headers from frontend React JS
06:02:47 <frdg> ok nevermind I see that the issue was that the database entry was stored in the x variable and what I was printing was the backendKey
06:11:45 <kiwi_45> ?
06:36:24 <irchaskellnopron> Hello
06:39:14 <NewToHaskell> So I found this task on youtube for beginners: create a function hasPath that determines if a path from one node to another exists within a directed graph, GRAPH; https://imgur.com/a/XCoSsIA.
06:39:35 <NewToHaskell> I cannot get my function to work, can someone help me? =) 
06:39:45 <NewToHaskell> `hasPath :: [(Int, Int)] -> Int -> Int -> Bool
06:39:46 <NewToHaskell> | (snd $ (nodes !! (startNode - 1) == endNode)   = True
06:39:58 <dmj`> NewToHaskell: can you use pastebin or a gist
06:40:38 <NewToHaskell> Yes sorry, I am new to programming.
06:41:17 <NewToHaskell> https://pastebin.com/VPn0phFv
06:41:23 <NewToHaskell> Is this correct? =)
06:43:00 <NewToHaskell> https://imgur.com/a/XCoSsIA
06:43:09 <NewToHaskell> That is the node graph. =)
06:44:43 <kiwi_45> dmj`: can you please again say I missed your advice and I don't know how to look back in history , I have asked my question above
06:45:27 <dmj`> kiwi_45: HttpOnly means javascript is unable to access document.cookie
06:45:55 <kiwi_45> dmj`: is servant-auth is for httpOnly ?
06:46:29 <dmj`> kiwi_45: no, HttpOnly is part of the Cookie spec in HTTP
06:46:45 <dmj`> kiwi_45: open up the chrome console and call document.cookie
06:47:11 <dmj`> kiwi_45: I'd recommend asking on a react channel, as this doesn't particularly pertain to Haskell
06:47:14 <kiwi_45> I did, and I can't access my headers which I can see with browser itself
06:47:26 <kiwi_45> I asked there
06:47:31 <dmj`> kiwi_45: that is because you are using HttpOnly
06:48:06 <kiwi_45> is setting NotSecure will remove this restriction ?
06:48:15 <dmj`> HttpOnly means the cookie is accessible *only* over HTTP, not JS
06:48:27 <dmj`> kiwi_45: removing HttpOnly will remove that restriction
06:50:09 <kiwi_45> dmj`: I'm not sure how I can remove that ? where actually 
06:50:19 <ski> NewToHaskell : what is the format of the list of type `[(Int,Int)]' ?
06:50:22 <dmj`> kiwi_45: where did you set HttpOnly
06:50:46 <kiwi_45> dmj`: I haven't set anything fancy like this
06:51:40 <dmj`> kiwi_45: "I'm able to set cookie headers with servant-auth but I'm not able to access those cookie headers from frontend React JS"
06:51:50 <dmj`> kiwi_45: you said you set them ?
06:52:11 <NewToHaskell> ski : nodes = `[(1,2), (2,3), (3,2), (4,3), (4,5)]`  graph here; https://imgur.com/a/XCoSsIA
06:53:07 <dmj`> kiwi_45: I recommend you read up on the basics of what cookies are. This conversation isn't productive otherwise.
06:53:07 <ski> NewToHaskell : ok, so the order of the pairs (the edges) doesn't seem to matter
06:53:35 <ski> NewToHaskell : so attempting to index this list, using `!!', will not be very helpful. try using `lookup', instead ?
06:53:37 <kiwi_45> dmj`: yeah I set but actually servant-auth is doing that
06:54:22 <ski> hm
06:54:39 <kiwi_45> now I'm almost to do it anyhow, after that I can read and understand of all basics of cookies and cors both
06:54:42 <ski> > lookup 3 [(1,2),(2,3),(3,2),(4,3),(4,5)]
06:54:44 <lambdabot>  Just 2
06:54:48 <ski> > lookup 4 [(1,2),(2,3),(3,2),(4,3),(4,5)]
06:54:50 <lambdabot>  Just 3
06:54:52 <ski> > lookup 5 [(1,2),(2,3),(3,2),(4,3),(4,5)]
06:54:54 <lambdabot>  Nothing
06:55:11 <NewToHaskell> oh thats cool
06:55:12 <ski> for `4', we'd probably want to get both of the nodes it's connected to
06:55:45 <frdg> you will need to import Data.Map to use the lookup function
06:56:10 <dmj`> kiwi_45: If you don't know what servant-auth is doing, I recommend you don't use it.
06:56:21 <ski> > let edges = [(1,2),(2,3),(3,2),(4,3),(4,5)]; myNode = 4 in [dest | (src,dest) <- edges,src == myNode]
06:56:22 <fog> so, i have a newtype wrapper around my Monadic List, so that I can write Functor instances for it, where otherwise the synonym would have to be partially applied. but its making the lazy evaluation break unexpectedly 
06:56:23 <lambdabot>  [3,5]
06:56:56 * hackage termonad 4.0.0.0 - Terminal emulator configurable in Haskell  https://hackage.haskell.org/package/termonad-4.0.0.0 (cdepillabout)
06:56:57 <dmj`> fog: how do you know its breaking lazy evaluation
06:57:08 <fog> im going to write it up properly to show whats happening, but is there anything obvious about the behaviour of datatype constructors that could be forcing it to be strict
06:57:12 --- mode: ChanServ set +o ski_
06:58:19 <fog> dmj' i should write an example, but basically, i could fmapM over the underlying synonym lazily, but the version for the ListT constructor wrapping it broke
07:01:06 <dmj`> fog: what does "broke" mean
07:01:25 <fog> ok, ill write the example, hang on
07:01:49 <fog> it was some bizzare kind of corner case where i could use my implementation of fmapM fine in most cases 
07:02:10 <fog> and then it just didnt work in some strange case
07:02:19 <fog> id kind of like to understand what was happening
07:02:22 <dmj`> what does "didn't work" look like
07:02:43 <fog> well, fmapM working lazily allows it to be folded over despite being infinite
07:03:03 <fog> so, i have a "display" function which folds over the monadic list and prints it to the screen
07:03:16 <fog> when it "breaks" then it just freezes and prints nothing to the screen
07:03:25 <fog> this shows its trying to evaluate the whole list
07:03:31 <fog> ie, its not being lazy
07:03:43 <fog> it was just strange that it was lazy *in some cases*
07:04:25 <fog> its based on this code; https://github.com/fog-hs/clock-scanner
07:04:42 <fog> ill get a paste to show the exact error momentarily 
07:16:39 <dmj`> fog: A minimal example would be elucidating
07:19:30 <fog> i have that now!
07:20:26 <fog> dmj' here; https://pastebin.com/raw/w4VFP85X
07:22:29 <fog> the original (broken) fmapMDefault is here https://github.com/fog-hs/clock-scanner/blob/master/StackM.hs#L36
07:22:52 <fog> and rewriting it, to map through the newtype wrapper properly, stops it being broken
07:28:41 <kiwi_45> dmj` : I agree with your point, I should know the tool I'm using but incrementaly I 'm knowing it slowly and with time I'm pretty sure I'll master it, can you please help me directly how can I overcome my current problem ?
07:35:56 * hackage cobot-io 0.1.3.6 - Biological data file formats and IO  https://hackage.haskell.org/package/cobot-io-0.1.3.6 (ozzzzz)
07:38:01 <kiwi_45> dmj` : ?
07:39:56 * hackage azimuth-hs 0.1.0 - Interact with Azimuth from Haskell  https://hackage.haskell.org/package/azimuth-hs-0.1.0 (JaredTobin)
07:40:37 <fog> so, basically its still a problem because while the paste shows how fmapM can be implemented for ListT, it has to bypass getM and setM to do so
07:40:46 <dmj`> kiwi_45: I'd recommend you learn the basics of Haskell and the web first. Otherwise, people will tell you what to do, but you won't understand why, and you'll be forever stuck, continually relying on people to do the work for you.
07:41:26 <dmj`> fog: how is setM implemented
07:41:35 <fog> this means its not a valid implementation of fmapMDefault, which is supposed to allow fmapM to be implemented from the availablility of SetM and GetM
07:42:21 <kiwi_45> dmj`: okay David, Thanks a lot :)  
07:42:24 <fog> dmj` its implementation for ListT is here; https://github.com/fog-hs/clock-scanner/blob/master/ListT.hs#L42
07:44:07 <fog> it has to rewrap the tail in the newtype wrapper. im not sure if this means it is forcing it to be strict somehow 
07:50:46 <fog> in;
07:50:47 <fog> fmapMDefaultHelper :: forall a b m. (Monad m) => (a -> m b) -> MList m a -> (MList m b)
07:50:54 <fog> where
07:51:13 <fog> type MList m a  = m (ML m a)
07:51:19 <fog> data ML m a = MEmpty | a `MCons` MList m a
07:51:38 <fog> MList being a synonym means it cant have SetM and GetM defined over it
07:52:27 <fog> so that while this has a type that looks like fmapM, its cant be of FunctorM, which is over something of kind * -> *
07:52:57 <fog> and `MList m' cant have an instance written for it, as it is a partially applied type synonym 
07:53:16 <fog> which was the whole point of having the ListT newtype wrapper
07:54:00 <fog> if this newtype breaks the lazyness as it seems to (which i cant really understand) then it seems like the whole approach fails
07:54:38 <fog> that is, having a FunctorM default for instances of GetM and SetM
08:02:26 * hackage relational-query-postgresql-pure 0.1.0.0 - The connector of relational-record and postgresql-pure.  https://hackage.haskell.org/package/relational-query-postgresql-pure-0.1.0.0 (kakkun61)
08:17:43 <AWizzArd> What package offers a bounded queue with limited capacity that throws the oldest entry away when a new one gets inserted?
08:28:02 <fog> here is a rewrite that is self contained;
08:28:03 <fog> https://pastebin.com/raw/3ZEv13xz
08:34:30 <fog> urgh, seems like that was a total wild goose chase 
08:34:37 <fog> but i have it working now!
08:34:59 <fog> https://pastebin.com/raw/TErcXmWr
08:35:19 <fog> so, there is nothing about newtype wrappers being strict or anything, which is good
08:35:29 <fog> i just had it implemented badly...
08:35:32 <fog> sorry!
08:38:58 <dmj`> AWizzArd: https://gist.github.com/5929b27fed2d0a3f47f782ea8acd6b9d
08:42:31 <AWizzArd> dmj`: that will probably work, just isn’t generally efficient. For very short lists this works.
08:42:57 <AWizzArd> I thought that there might be already an efficient tree-based structure for this job.
08:51:43 <dmj`> AWizzArd: you can use a Seq instead
08:52:04 <AWizzArd> dmj`: okay yes, that sounds good.
09:00:24 <dmj`> AWizzArd: https://gist.github.com/621ca9af691d09a95896f7dcccf897ba
09:01:58 <AWizzArd> dmj`: excellent, thanks!
09:02:24 <dmj`> AWizzArd: np :)
09:13:56 <moet> does anyone know how cabal locates ghc's package.conf.d?
09:16:01 <moet> i guess it's this https://github.com/haskell/cabal/blob/3d4fdec4b8ba053811c1fecff2d04726174f7e89/Cabal/Distribution/Simple/GHC.hs#L384-L403
09:25:38 <sm[m]> dmj`++ !
09:33:35 <hyiltiz> I am trying to run the Glassery (https://gist.github.com/phadej/c32503efd3274e83196d549eaae28a1a); it suggests using --resolver, but I'd rather use my system's ghci 8.6.5 (already installed libghc-markdown-unlit-dev package). ghci --ghci-options='markdown-unlit' didn't recognize the option. Any ideas how?
09:44:36 <fog> now i have the same problem for scanners and traverse
09:44:39 <fog> :(
09:44:48 <dmj`> sm[m]: :) thanks
09:45:22 <fog> and, where somehow moving the position of setM made the fmapM version work, i cant seem to do the same thing for scanner or traversable
09:45:27 <dmj`> AWizzArd: If we enqueue over the bound, we can return the element that was subject to overflow
09:46:24 <dmj`> AWizzArd: this will also change the type signature so enqueue and dequeue will both return (Maybe a, BQueue a) 
09:47:23 <merijn> hyiltiz: Well, one problem would be the fact that there is no --ghci-options flag afaik :p
09:50:27 * hackage amqp-streamly 0.2.0 - A simple streamly wrapper for amqp  https://hackage.haskell.org/package/amqp-streamly-0.2.0 (gdifolco)
09:51:32 <dmj`> AWizzArd: https://gist.github.com/8cd4072cb873831f85e8c4a988a58ee1
09:52:03 <fog> here is the code of the error; https://pastebin.com/raw/tH28gg7p
09:52:28 <dmj`> AWizzArd: this implementation has a nicer state monad interface and returns the overflow element
09:54:11 <fog> and i still dont get why the version of fmapM before just magically started working 
09:54:26 <fog> and why it didnt work in this corner case
09:54:42 <fog> it was good and lazy except when writing something like;
09:54:51 <hyiltiz> merijn: been a year since I last dealed with GHC; I guess I'll have to man ghc now
09:55:41 <fog> @let loop = 0 : map (+1) loop
09:55:42 <lambdabot>  .L.hs:173:22: error:
09:55:42 <lambdabot>      Ambiguous occurrence ‘loop’
09:55:42 <lambdabot>      It could refer to
09:55:49 <fog> @let loop' = 0 : map (+1) loop'
09:55:51 <lambdabot>  Defined.
09:55:57 <fog> > loop'
09:55:59 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
09:56:32 <fog> this recursive definition in terms of itself, now works with fmapM, but not for scanners
09:56:56 <fog> and, why would they be lazy in cases other than this self recursive value!?
09:57:27 <fog> its some bizzare corner case that breaks things in a way i cant understand
09:57:46 <fog> the scanners are good and lazy in other situations
09:58:06 <merijn> hyiltiz: I'm assuming --ghci-options is a stack option
09:58:17 <fog> which is the exact same problem that I just solved for fmapM 
09:58:23 <hyiltiz> that is a very valid assumption
09:58:34 <fog> except, i cant figure out how to do something similar for scanner
10:00:39 <rembo10> :tabn
10:00:46 <rembo10> oops sorry aha
10:00:56 * hackage proto3-suite 0.4.0.2 - A low level library for writing out data in the Protocol Buffers wire format  https://hackage.haskell.org/package/proto3-suite-0.4.0.2 (rashad1030)
10:05:47 <dolio> ls
10:05:51 <dolio> Whoops.
10:31:23 <dmj`> AWizzArd: I guess there already is a bounded-queue package on hackage, realized this when attempting to upload to hackage
10:31:35 <dmj`> @package bounded-queue
10:31:35 <lambdabot> https://hackage.haskell.org/package/bounded-queue
10:34:39 <dmj`> I'm biased towards my implementation since it returns an item in case of overflow, and can be monad-state-itized very easily
10:39:28 <fog> ok! solved that for scanners;
10:39:29 <fog> https://pastebin.com/raw/Y6AQQJWz
10:41:31 <fog> dmj` how does Seq work? cow can it provide O(1) update?
10:41:45 <fog> does it use direct memory addresses like Vector?
10:42:31 <dmj`> fog: Seq is a finger tree http://www.staff.city.ac.uk/~ross/papers/FingerTree.html
10:42:58 <fog> doesnt that imply it still has some complexity proportional to length?
10:43:39 <nshepperd2> depends what you're doing with it
10:43:48 <dmj`> fog: The asymptotics are similar to vector when inspecting the ends of the sequence, but arbitrary indexing will be logarithmic at best
10:44:03 <fog> that makes more sense
10:44:29 <fog> so it can do this buffering que thing without having to do any of that?
10:46:11 <fog> like, it says it has O(1) length, but wouldnt that again be logarithmic from having to descend over branches?
10:47:08 <fog> like, it implies fold for Seq is O(1)
10:47:20 <fog> i cant see how that could be possible
10:47:26 <solonarv> well, Seq has faster cons/snoc, because vector has to copy the entire vector for those
10:47:36 <nshepperd2> anything can have O(1) length, just by keeping track of the length in a separate variable
10:48:09 <fog> well the O(1) length claim is placed next to the Foldable instances, which uses that of the underlying Seq
10:48:41 <fog> solonarv: yeah, i guess only MVector actually uses memory addresses in a way that gives O(1) update
10:48:53 <nshepperd2> isn't length a member of the Foldable typeclass now
10:49:02 <nshepperd2> you can just provide a specialized implementation
10:51:25 <fog> ah, its here;
10:51:26 <fog> https://hackage.haskell.org/package/containers-0.6.2.1/docs/src/Data.Sequence.Internal.html#FingerTree
10:51:43 <fog> there is some Sized thing where it does just store the size
10:52:36 <sm[m]> what is best/standard for controlling color in the terminal: --color & --no-color ? --color=always|never|auto ? --color=yes|no|auto ?
10:53:37 <nshepperd2> yeah, storing the size is actually necessary for the O(log) indexing it has
10:53:40 <sm[m]> cf https://github.com/simonmichael/hledger/issues/1296
10:53:49 <sm[m]> oops, wrong channel
10:53:53 <fog> i guess thats a different issue to how it actually does the buffering
10:54:44 <fog> so, i get that cons is apparently be fast for this tree structure, though i dont really get how its faster than for list
10:54:59 <fog> but how does it do the discarding of the last value
10:55:13 <fog> wouldnt it kind of have to shuffle around the distribution of values over the branches?
10:55:19 <fog> and wouldnt that take time
10:56:10 <fog> it says cons is O(1) but wouldnt it be logrithmic again from having to do some operations on the branches?
10:56:24 <fog> as cons is where this discarding the overflow occurs
10:57:20 <MarcelineVQ> list cons is O(1) too fwiw
10:57:39 <fog> yeah, but that doesnt have to discard overflow at the last position
10:58:03 <fog> is it doing something special by storing the bounds and just guarding against access there?
10:58:19 <fog> and that somehow the garbage collector can then delete those references?
10:59:01 <fog> i just cant see how it having branches somehow magically allows it to discard the last with no performance hit
11:00:00 <nshepperd2> fog: finger trees store both the start and end of the sequence at the root node, basically
11:00:03 <fog> since when there is branches, unless your doing operations on the head, then you expect to see some logarithmic complexity
11:00:32 <fog> nshepperd2: that sounds impossible!
11:00:39 <nshepperd2> it sure does
11:00:45 <nshepperd2> https://en.wikipedia.org/wiki/Finger_tree
11:02:02 <fog> argh, that animation is intense 
11:02:48 <fog> ok, so it stores the "more central" values deeper in the tree 
11:02:55 <fog> awesome!
11:03:14 <fog> but yeah, there must be some performance hit for shuffling round the branches
11:03:31 <fog> i guess the claim is that this is not dependent on the length of the whole tree
11:03:48 <frdg`> Could anyone point me in the right direction on how I could incorporate the results of running formPosts in yesod into making database queries. I have the functions all set up but I can't figure out how to compose them. https://dpaste.org/53FZ#L7
11:04:30 <fog> ok, so it just permutes one of the nested layers up a level, regardless of the length
11:07:02 <nshepperd2> fog: the original paper is well worth reading imo, it explains it quite well http://www.staff.city.ac.uk/~ross/papers/FingerTree.html
11:08:23 <dmj`> Ross Patterson is Olegesque
11:10:21 <fog> hmm, actually it must do more than one opperation
11:10:41 <fog> it has to permute up or down the internal layers also
11:10:51 <fog> so it *must* get more complex as length increases
11:11:03 <fog> im still not convinced of this O(1) claim
11:11:18 <nshepperd2> fog: it's amortized O(1)
11:11:31 <fog> whats that?
11:11:44 <fog> so logrithmic its basically O(1) ?
11:12:45 <fog> like, there is also the logritmicness because only some of the conses cause these internal permutations
11:13:05 <fog> so averaging over all opperations, the more expensive updates are less likely
11:13:06 <nshepperd2> fog: it means that when do n push/pop operations it costs O(n) time even though some operations might take longer than others
11:13:16 <nshepperd2> yes
11:13:23 <fog> still, that seems like a lazy way to measure complexity
11:13:53 <fog> there should be a quantifiable measure for how unlikely those more expensive updates are
11:14:25 <fog> it seems "very logarithmic" which i guess is probably as lazy as calling it armortized.. 
11:14:51 <xsperry> fog it is amortized O(1) the same way that appending to the end of dynamically allocated is amortized O(1), even though appending an element occasionally involves copying all the elements
11:14:59 <xsperry> array*
11:15:54 <nshepperd2> well, basically every 1/2^n times you push, you might need to do an operation that costs n (traversing n levels down the tree)
11:16:04 <fog> so its something like, you can make the 1 of O(1) larger, so the least costly updates appear *cheaper* than the average, and so cancel out the more expensive ones
11:17:10 <fog> but then i guess you could always do that, and it would be better to give the actual complexity. 
11:18:31 <fog> but, i think its disingenuous to abbreviate "amortized O(1)" to just "O(1)"
11:18:34 <nshepperd2> in a lazy language, amortized complexity is pretty much all that matters anyway, because you can't guarantee when things will be evaluated
11:19:33 <fog> sure, but if your supposed to read O(1) as actually amortized O(1) which is actually some uncalculated log complexity...
11:19:56 <fog> i normally read O(1) as "constant" with no dependence on length
11:19:58 <nshepperd2> it's not that
11:20:02 <nil> amortized O(1) doesn't mean logarithmic
11:20:07 <nshepperd2> it doesn't depend on the length
11:20:36 <fog> sure, it gets deeper if its longer, and you have to permute it down more layers on consing
11:21:03 <fog> right?
11:21:46 <nshepperd2> the length sets an upper bound on how many layers you can possibly traverse, but that doesn't make any difference to the O(1) claim
11:22:11 <fog> nil: but it also doesnt mean O(1), and the library authors have claimed O(1) complexity *not* amortized O(1) complexity
11:22:44 <mac10688> question. I'm working in a c# application that tries to be as functional as possible. I have a co-worker who pushes back on if .. else.. statements and prefers them wrapped in lambdas to be more functional. Do you guys agree or is if..else.. plenty functional?
11:23:25 <dsal> I don't like if/else in general, but I don't know C#.  Most of my programming lately has been haskell.
11:23:52 <mac10688> you prefer pattern matching on booleans?
11:23:57 <fog> if then else seems like a valid higher order function with special syntax, i would advocate for it
11:24:08 <nshepperd2> why are you asking about c# in the haskell room
11:24:18 <dwt> the more "functional" way to write if/else would be as a conditional expression x ? y : z
11:24:22 <dsal> I prefer not having booleans to pattern match on.  I suspect my haskell designs are different from your C# designs.
11:24:24 <mac10688> sorry, it's more about is if else considered functional
11:24:31 <oats> mac10688: yikes, trying to swap out if/else sounds fishy
11:24:38 <dwt> but ... C# is not really a functional language, and I'd do whatever seems idiomatic
11:24:38 <dsal> Depends on what you mean by "functional"
11:24:39 <oats> maybe y'all would like F#
11:24:43 <xsperry> C#'s if/then/else differs from haskells. in haskell if/then/else return a value, instead of executing a statement
11:25:49 <xsperry> > if True then 10 else 20
11:25:51 <lambdabot>  10
11:25:57 <fog> i guess the advantage of wrapping it into a function would be to pass it as an argument
11:26:08 <dsal> If you're concerned about "being functional", using a functional language is probably the best start.
11:26:17 <dsal> > bool 20 10 True
11:26:18 <lambdabot>  10
11:26:37 <fog> :t bool
11:26:38 <lambdabot> a -> a -> Bool -> a
11:26:42 * dsal used `bool` once
11:26:52 <mac10688> yeah I wish we could change it. Thanks everyone! I'm getting back to work
11:27:22 <fog> :t fmap (uncurry bool)
11:27:23 <lambdabot> Functor f => f (a, a) -> f (Bool -> a)
11:30:30 <mac10688> nshepperd2: sorry, I wanted the opinion of people that truly knew what functional programming was.
11:36:58 <hyperisco> mac10688, in Haskell we program with expressions, not structured programming, so in that regard if/else is not functional
11:37:43 <hyperisco> mac10688, as mentioned by dwt, the expression version of  if _ then _ else _  is  _ ? _ : _
11:39:42 <hyperisco> My experience of using a functional style in C# suggests that avoiding if/else is unnecessary
11:40:24 <enikar>  weird thing, i feel, because we can write let x = if some_cond then expr1 else expr2 (but i don't know C#).
11:41:15 <hyperisco> function (x) { if p(x) return m(x); else return n(x); }  is no different than  function (x) { return p(x) ? m(x) : n(x); }  for example
11:41:26 * hackage these 1.1.1.1 - An either-or-both data type.  https://hackage.haskell.org/package/these-1.1.1.1 (phadej)
11:41:58 <hyperisco> enikar, in C# you can write  var x = some_cond ? expr1 : expr2;
11:42:02 <enikar> In C#, it's like in C.
11:42:26 * hackage semialign 1.1.0.1, these-lens 1.0.0.1 (phadej): https://qbin.io/shoe-pb-h1bg
12:00:17 <Uniaika> /4/22
12:00:21 <Uniaika> (woops)
12:44:11 <fog> ok, i have modified the clock demo for lazy monadic scanners
12:44:13 <fog> https://github.com/fog-hs/System
12:44:32 <fog> now, with them being properly lazy, they can be used in mutually recursive definitions
12:44:40 <fog> this is something like a recurrent net
12:44:51 <fog> initial conditions are input on the cyclic edges
12:45:34 <fog> basically, you can think of it as a circle with scanners around the edge, and a stream of data flowing through them
12:54:56 * hackage containers 0.6.3.1 - Assorted concrete container types  https://hackage.haskell.org/package/containers-0.6.3.1 (dfeuer)
13:13:41 <frdg`> https://dpaste.org/9n1k question related to IO and case expressions
13:14:59 <ski>   FormSuccess loc -> do
13:15:11 <ski>     city <- liftIO $ queryCity "I want to base this arg on a field of loc"
13:15:24 <ski>     defaultLayout [whamlet|<p>#{show loc} <p>#{getCity loc}|]
13:15:28 <ski> frdg` ^
13:15:56 <frdg`> oh ok that makes perfect sense
13:16:36 <ski> frdg` : also, if `FormSuccess loc' is the only possible form of `result', you can instead replace `result' in the pattern with `FormSuccess loc', eliding the `case'
13:18:02 <frdg`> ski: I believe result has three possibilites
13:18:16 <ski> ok
13:18:28 <ski> (your paste only showed one branch, so that wasn't cleaR)
13:19:03 <frdg`> thanks though I had been wrestling with this for a while
13:20:14 <ski> np
14:12:14 <moet> i seem to be consistently observing cabal ignoring the `--package-db=` flag
14:12:35 <moet> wheres ghc-pkg with the same flag behaves correctly
14:14:40 <moet> with cabal 3
14:16:41 <moet> is this the right channel to seek help on this issue?
14:18:22 <moet> `ghc-pkg list --package-db=foo` correctly lists packages from foo/, but `cabal v2-build --package-db=foo` cannot locate required dependencies which are present in foo/
14:23:41 <phadej> --package-db flag doesn't do anything with v2-build
14:23:53 <phadej> unfortunately v2- commands accept plenty of flags which do nothing
14:25:17 <moet> phadej: .. thank you, i've been trawling through source on github for hours unable to connect A to Z .. 
14:25:39 <phadej> but to more on topic, if you think you need you need --package-db flag with v2-build, I wonder what's the X in this XY-problem-like situation
14:26:15 <moet> phadej: i'm trying to run cabal in a nix build container to spit out a ghc-environment file to unbreak a doctest suite 
14:26:34 <phadej> oh, nix. Don't use v2-build.
14:26:43 <phadej> or cabal for that matter
14:26:50 <moet> is there another way to generate a ghc-environment file?
14:27:20 <phadej> maybe someone have written some bash script, the .ghc.environment files are quite simple format
14:27:38 <phadej> if you can generate --package-db=... --package-id flags, that's essentially all you need for .ghc.environment file
14:27:39 <moet> so, parse the output from ghc-list
14:27:57 <moet> `ghc-pkg dump` 
14:28:08 <phadej> ghc-pkg list --simple-output should be fine
14:28:28 <phadej> or just give --package-db to the doctest runner
14:28:41 <phadej> and don't specify --hide-all-packages or anything like that
14:29:13 <phadej> anyway, don't involve cabal if it isn't involved in building
14:29:22 <moet> understood, thanks
14:30:28 <moet> i'll try passing package-db to the doctest runner directly and if i can't figure that out i'll go back to trying to produce a .ghc.environment file
14:34:49 <phadej> doctest executable accepts ~all the GHC flags
14:35:15 <phadej> (and it's somewhat silly to use anything else in nix environment)
14:36:00 <phadej> I should be more precise: in nixpkgs-based setup
14:36:27 <phadej> there are some other baroque nix setups out there :)
14:48:44 <moet> this is a pretty standard use of nix.. it's also a standard use of doctest (following https://github.com/sol/doctest#cabal-integration)
14:49:06 <moet> but some of the dependencies override names like Prelude .. which has been fun to deal with 
14:55:48 <phadej> the https://github.com/sol/doctest#cabal-integration is unfortunately quite wrong way to do it
14:56:09 <phadej> as indeed, it assumes that the global package-db has exactly the right packages, and nothing more
14:56:15 <phadej> and e.g. no duplicate methods
14:56:24 <phadej> duplicate modules
14:56:42 <phadej> tl;dr it works in simple cases, but it doesn't scale
15:16:16 <moet> phadej: ah.. can you point me at the _right_ way to do it then? 
15:16:23 <moet> should i just be using the `doctest` executable?
15:16:42 <phadej> there is no right way, unfortunately
15:17:54 <phadej> where by right I mean without clear drawbacks
15:18:26 <moet> i see .. i wish this discussion were part of the readme over there, hah
15:20:09 <moet> it makes me wonder if a template-haskell reimplementation of doctest would be valuable, where the examples could be collected at compile time when their proper dependencies are already in the environment
15:20:27 <phadej> nope
15:20:48 <phadej> doctests could (and do) use also external packages the library have no dependencies upon
15:21:04 <moet> huh
15:21:22 <moet> QuickCheck being one example i guess
15:21:27 <phadej> yes
15:21:51 <phadej> or e.g. if package defines some lensy stuff, without depending upon on `lens`
15:22:02 <moet> ah..
15:22:04 <phadej> but uses `lens` to write doctest (i.e. actually use that stuff)
15:22:31 <phadej> it's not common, but "the solution" shouldn't close that off
15:23:01 <phadej> doctests are really an own kind of test-suite
15:23:14 <phadej> with similarities to other test-suites, but then they are also quite different
15:23:35 <phadej> (I do know too much about that)
15:29:59 <moet> wow, i don't know what i'm doing here.. i managed to get doctest to run in nix-build with `${haskellPackages.doctest}/bin/doctest lib/ -package-db=/build/package.conf.d` and because some of my dependencies define things like `Prelude` i'm getting an `Ambiguous module name` errors from the `autogen/Paths_mypackage.hs`
15:30:24 <phadej> yep
15:30:42 <phadej> you have to figure out the right dependencies... from a thin air!
15:31:29 <moet> how is Setup.hs doing it? .. it's run in the same minimal environment and compiled the project without any `Ambiguous module name` errors
15:32:23 <moet> wow, uh, changing it to `${haskellPackages.doctest}/bin/doctest -i./lib/ -package-db=/build/package.conf.d` fixed the errors
15:32:34 <phadej> the .cabal file has definitions of dependencies, which Setup uses
15:32:39 <phadej> there are no for doctest :)
15:33:40 <moet> ahhhhhh
15:39:28 <moet> ok, so currently we have `test-suite name ... type: exitcode-stdio-1.0` .. is this a case where perhaps doctest could be come a new `type:` of `test-suite`? and definitionally, any dependencies it needs would be defined as the `build-depends:` in that stanza?
15:44:46 <phadej> yes. but you also need other stuff, like `doctest-options` (with whatever that means), way to specify `doctest` version, and which components (recall, packages may have multiple libraries/executables/... which all could have doctests)
15:45:42 <phadej> but then some component options don't make much sense for doctest
15:46:04 <phadej> as it's not compiling anything
15:46:16 <phadej> but intepreting
15:47:44 <phadej> but maybe `other-modules` still make sense, as providing some extra utiltities you could use in doctests
15:48:54 <NewToHaskell> Can someone help me where I should put the type annotation to get my code to work? I get this error `Probable fix: use a type annotation to specify what a0' should be.`
15:49:02 <NewToHaskell> `isPrimeNum :: (RealFrac a, Integral a) => a -> Bool
15:49:06 <NewToHaskell> my prime function.
15:50:38 <jackdk> NewToHaskell: that's not enough information for us to help. Can you please put your code and full error message into a pastebin somewhere?
15:50:41 <jackdk> @where paste
15:50:41 <lambdabot> https://gist.github.com
15:51:02 <monochrom> Yeah I think it's the nth time.
15:51:50 <monochrom> http://www.vex.net/~trebla/humour/tautologies.html #4
15:51:57 * hackage ghc-gc-tune 0.3.2 - Graph performance of Haskell programs with different GC flags  https://hackage.haskell.org/package/ghc-gc-tune-0.3.2 (ArtemPelenitsyn)
16:43:50 <_xor> What's package.cache when using cabal?
16:43:53 * _xor is a newbie
17:02:56 * hackage tini 0.1.0.0 - Tiny INI file and configuration library with a minimal dependency footprint.  https://hackage.haskell.org/package/tini-0.1.0.0 (AntonEkblad)
17:27:12 <sm[m]> beats me _xor , where do you see it ?
17:30:42 <etherealemb> Does anyone here know whether Google is running any production systems on Haskell? I know FB used Haskell for their spam filtering system
17:37:22 <hpc> google has a very short list of approved languages, and haskell's not on it
17:44:12 <moet> phadej: i'm trying cabal-doctest
17:53:36 <koz_> :t foldM
17:53:37 <lambdabot> (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m b
18:00:13 <sm[m]> I've seen at least one mention of haskell running something at google on HN
18:00:34 <sm[m]> but nothing really visible
18:27:58 <dmj`> I'd say no, google is not running any Haskell in production, but they have open source Haskell projects
18:29:37 <fog> how does the haskell language combine lambda functions with values passed explicitly as arguments, and values drawn from the "scope" ?
18:30:27 <fog> and, how does it do that thing where it copies values? like, multiple references to the same value does not result in it being recomputed 
18:31:47 <fog> for an application where a program is mapped onto a "scaffold" or graphical representation with interconnection corresponding to function evaluation from arguments,
18:32:19 <fog> it can handle edges as references to bound variables easily, but "scope" considerations less easily
18:33:32 <fog> and, if edges correspond to where the bound variables end up being used, then there is no notion of garbage collection having to try and discover when a value will no longer be referenced 
18:34:43 <fog> with values passed to functions not via the scope, but directly along edges, then there is also the need to specifically copy the variables to have them referenced at multiple locations
18:35:36 <fog> so none of this memoisation and evaluation to normal form - but that when a scope is incorporated, these things become a required consideration
18:36:08 <EvanR> the implementation of laziness has a lot to do with it
18:37:03 <fog> there is also something to do with reification and local constraint continuations meaning that variables can be supplied to a function by local instances resolved from local scope using constraints, to provide functions with values in a way that is order independent, but thats probably too complicated for now
18:37:28 <fog> EvanR: what, like, maybe it will never be referenced at all?
18:37:34 <EvanR> when you need to scrutinize something and it turns out to be a thunk, evaluate it and overwrite the pointer in the box to the result
18:37:51 <EvanR> then anything refering to that value will not recompute it
18:38:04 <fog> thats normal form right?
18:38:09 <fog> or weak head normal form?
18:38:15 <EvanR> doesn't matter if this is an argument or a closure referenced value
18:38:36 <fog> whats a closure referenced value? is that what im calling something from the scope?
18:38:42 <EvanR> WHNF is only relevant here in that "evaluate it" means evaluate only up to WHNF
18:38:56 <EvanR> yes
18:39:03 <fog> ah, so normal form would be strict?
18:39:19 <fog> so we need WHNF for laziness?
18:39:42 <EvanR> normal form has all subexpressions evaluated
18:40:04 <fog> does that force tail recursion strictly? and does WHNF not?
18:41:04 <EvanR> if the value is recursive, then there's no normal form
18:41:24 <EvanR> attempting to compute it would freeze the computer
18:42:20 <fog> so, the thing is with these edges, is that values end up somewhere, and cant be "closure referenced". maybe something similar would be a scope where using a value from it stopped it from being used elsewhere, ie it kind of consumes it from the scope. thinking of trying to make something like function arguments like with the edges, except that is
18:42:20 <fog> argument order agnostic
18:42:57 <EvanR> what edges?
18:42:59 <fog> EvanR: thanks, i think i understand how WHNF is needed for lazyness
18:43:18 <fog> if i write;
18:43:38 <fog> f x = let y = (x,x) in y
18:43:50 <fog> then im certain that y is not used elsewhere
18:44:17 <EvanR> em... the variable y or the heap object
18:44:37 <fog> i would count that as an "edge" from the "vertex" or "node" which "emits" it - to where it is consumed
18:44:59 <fog> the point is that it does not escape into scope, and that the edge shows where it is formed, to where it is used
18:45:03 <EvanR> i'm not familiar with this edge, vertex, node, and emitter model of haskell
18:45:33 <fog> i would think of functions as having edges going into them, corresponding to each argument, if it were not for the fact these could instead be drawn from the scope
18:45:36 <EvanR> there's the syntax, there's the runtime heap
18:45:50 <fog> where the reusability means there is not a good notion of edges
18:45:59 <EvanR> they're kind of difficulty to connect to each other
18:46:40 <fog> the idea of the "scaffold" representation of a functions implementation, about how the types match up over the edges (thinking of each edge having a type annotating it)
18:46:52 <EvanR> are you familiar with the transformation which removes closures by adding extra arguments
18:47:22 <fog> is not conducive with the notion of a scope. as everywhere a value is consumed must be specified by the user creating the scaffold
18:47:45 <fog> as a way of writing an implementation in some kind of graph based functional language
18:48:00 <fog> i just cant understand how to reconcile the notion of a scope with the notion of edges
18:48:14 <fog> and moreover, how to get argument order agnostic functions
18:48:38 <EvanR> well haskell side steps that because there's only 1 argument per function
18:48:56 <fog> basically, if i use names instead of ints of which number argument it is, which is pattern matched into anyway to asign a name in the function definition
18:49:13 <EvanR> every lambda takes 1 arg
18:50:04 <fog> right, thats how we end up with specifically ordered arguments, and then we pattern match with nice haskell syntax
18:50:11 <fog> like; f a b = ...
18:50:21 <fog> it "names" the first and second argument
18:50:51 <fog> but if i have instead, constraints, then i can access the values defined in those classes, in an order agnostic way
18:50:57 <fog> as if they were from the scope
18:51:14 <fog> EvanR "are you familiar with the transformation which removes closures by adding extra arguments"
18:51:15 <fog> no
18:51:21 <fog> how does that work?
18:51:49 <fog> is it basically like making the function take as many arguments as there are things in scope?
18:51:58 <EvanR> add an extra argument for each closed over variable, pass that value in when the function is defined
18:52:01 <fog> (sorry, overlooked your comment about heap objects)
18:52:44 <fog> well, i guess thats the approach that would *have* to be taken, were there not the support for scopes, or closed over values
18:52:51 <EvanR> do it enough times and nothing uses closures anymore. But since you have to have partial application work, it shows they are the same thing
18:53:08 <kiwi_45> If anyone here would like to help me with servant-auth ? I have setup but I’m missing some bits my code here https://github.com/DeepakKapiswe/Gyan-Lahari-Backend/blob/redisIntegration/src/App.hs
18:53:19 <EvanR> they end up implemented in the same way
18:53:28 <fog> hmmm
18:53:59 <EvanR> a lambda is really a pointer to the code packaged with zero or more arguments
18:54:07 <fog> well, if i had my function implementation in terms of a scaffold, i would not have a scope, and no multiple references to one value, having to copy it explicitly for every place it was used
18:54:39 <fog> but if i want order agnosticism over the function arguments, then it seems like i would need to use a scope
18:55:07 <fog> like, skipping the pattern matching step, and just calling them by their "name" to begin with
18:55:57 <EvanR> i think i was confused from the beginning because you're calling some heap object a scope
18:55:59 <fog> instead of it being like "this was the nth argument, and it was named xn on the lhs of the = in the function implementation" 
18:56:25 <fog> ok, i think i should try to understand what is this heap object
18:57:21 <fog> hmm, i soon found this; http://lambda-the-ultimate.org/node/4512
18:57:41 <fog> a heapless functional programming language. Primarily, this means there is no need for a garbage collector
18:57:46 <EvanR> as opposed to scope, the thing that tells you what a variable (in syntax) ultimately refers to
18:58:29 <fog> how is it confusing to call that a scope?
18:58:49 <fog> or something thats in scope
18:58:53 <EvanR> "i would need to use a scope"
18:59:09 <EvanR> sounds like a runtime thing
18:59:16 <fog> its where the heap objects are?
18:59:37 <EvanR> just saying a lot of these words sound nonstandard
18:59:44 <fog> i imagine it as just a list of names and the things they are bound to refer to
18:59:49 <EvanR> so people might not know wth you're talking about
19:00:21 <fog> well, eg, let bound variables have a scope, and within this scope the let bound variable can be referenced
19:00:30 <fog> i think thats a normal idea of a scope...
19:01:16 <fog> when i say "i would have to use a scope", that is, to avoid having to pass all values into a function as arguments
19:02:08 <EvanR> so you're writing some kind of interpreter for a language
19:02:22 <fog> it seems like in the terminology you used, that these are the heap objects closed over, the bound values in scope 
19:02:34 <EvanR> using literal variable names as keys into a heap
19:03:17 <fog> well that idea is sort of from (i cant remember the name of the language extension) where you can have local classes using a ? constraint
19:03:35 <EvanR> i'd call your table of variable names to values or "things" an environment rather than a scope
19:04:02 <fog> so instead of the constraint being with an instance for some class, it just uses the name of the values that normally a class would consist of
19:04:23 <fog> ok, an environment is ok
19:04:29 <fog> so whats a scope?
19:04:41 <fog> a kind of, limited environment?
19:04:51 <fog> to do with the interpretation of the language?
19:04:58 <EvanR> a variable has a certain kind of scope, local scope, global scope, lexical scope, etc
19:05:23 <fog> but thats what i meant...
19:05:24 <EvanR> like range of validity
19:05:40 <EvanR> in the code
19:06:18 <fog> hmm, ok, well if environment distinguishes it from the way the code is interpreted i guess its a better name
19:06:33 <EvanR> dunno what you meant, an environment is a piece of data your compiler is working with
19:06:37 <EvanR> or interpreter
19:06:46 <fog> thought scope does have the intuition of it being limited over certain regions which is desired
19:06:54 <kiwi_45> ?
19:07:48 <fog> well, suppose i was passing the result of one function evaluation to another. i would "bind it into scope" eg, with a let or where clause
19:07:52 <EvanR> what you're calling "a scope" is usually called an environment
19:08:30 <EvanR> bind it into scope sounds like code level, adding it to an environment runtime level
19:08:36 <fog> could i say "the scope of an environment" to refer to where in the code that environment was accessible?
19:08:57 <EvanR> scope is code level, environments exist at runtime (if at all)
19:09:13 <EvanR> at runtime there may not be any code
19:09:15 <fog> strangely, thats very confusing
19:09:29 <fog> im not sure where my graph thing exists
19:09:36 <EvanR> haskell's runtime is famous for having no semblance of code
19:10:37 <fog> so the most simple version does not use names, it just has regular edge vertex definition of a graph, it has no heap, no closure, no environment, no scope
19:10:56 <fog> ie, its just Ints specifying which argument is used
19:10:57 <EvanR> in a graph machine that sounds right
19:11:32 <EvanR> the runtime consists of a mutable graph
19:11:37 <fog> but, in haskell, the first thing we do is binding each argument to its name, within the local scope of the rest of the function implementation
19:12:27 <EvanR> have you read the haskell report?
19:12:32 <fog> ah, i found the language extension i had forgotten
19:12:32 <fog> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-ImplicitParams
19:12:47 <EvanR> it might clear up the separation between language and implementation
19:13:37 <fog> the point i was trying to make is that these are also ways of introducing named references, but that by appearing in constraints, they are order agnostic, as if they were bound at global scope
19:14:35 <fog> almost as if they were "local instances" which we can use reflection/reification for. but ImlicitParams is almost an easier way to talk about it
19:15:33 <EvanR> are you implementing a new language? 
19:17:04 <fog> its for the scanners thing here; https://github.com/fog-hs/System/blob/master/System.hs
19:17:29 <fog> so this sets up streaming data that naturally can be thought of as going over edges, between scanners
19:18:16 <fog> the most simple being a "clock" https://github.com/fog-hs/System/blob/master/Clock.hs#L15
19:18:21 <EvanR> sorry I'm lost, don't worry about it
19:18:27 <fog> which is just some monadic stream of ()
19:18:52 <fog> the example in the first link (System.hs) has 2 scanners in a mutually recursive thing
19:19:12 <fog> which on a graph is like they are 2 nodes on a circle 
19:19:31 <fog> the clock as an ingoing edge regulates the dataflow...
19:19:48 <fog> something "pushing the data through the system"
19:20:22 <fog> so, basically, i have a graph, and edges and nodes, and streaming data going through the graph
19:20:47 <fog> but i want a nicer way than writing the mutually recursive functions to define this structure
19:21:14 <viuphiet> Hi everyone, I'm currently working on a problem where I have this huge state machine, and a transaction log on this state machine. I basically want to be able to programmatically generate efficient ways of analyzing the "stream" of states that it takes on
19:21:24 <fog> with like, operations for adding nodes (scanners) and edges (the streams the scanners operate over) to the graph
19:21:25 <viuphiet> I was wondering if ya'll know of any existing work on this topic
19:22:07 <EvanR> fog: a recursive let block is effectively a labeled graph
19:22:16 <fog> right!
19:22:41 <fog> viuphiet: there are several approaches. i think conduit is the most developed
19:23:46 <fog> but if i constructed the graph explicitly, then i could ensure that it was type safe
19:23:57 <fog> well, the typechecker does that with the let block too...
19:24:05 <EvanR> or you write a type checker for your new language
19:24:23 <fog> the point is i shouldnt need to, i just use haskells
19:24:29 <EvanR> (config files should come with type systems more often)
19:25:04 <EvanR> well a let block literally in haskell doesn't convenient translate to a graph data structure you can use
19:25:07 <fog> i was using a "scaffold" to do bounds checking for composing nets or tensors together, to check the dimensions of the edges matches up
19:25:13 <EvanR> that's not how haskell's semantics works
19:25:23 <fog> but thats just a restriction of arbitrary type checking
19:26:00 <fog> the scaffold thing used smart constructors to ensure the user couldnt supply things that wouldnt type check
19:26:03 <EvanR> basically haskell's syntax is compiled one way, when many times we'd like it compiled another way (labeled graph structure)
19:26:09 <EvanR> (or many other things)
19:26:42 <fog> think of dot producting together two lengthed lists, if the lengths dont match, then it throws a type error
19:26:45 <EvanR> as an example of the difficulty of using it as is, there's no guarantee you get sharing of heap objects
19:26:51 <fog> there is no "writing a new language" 
19:28:02 <EvanR> and basic transformations of the data will result in unnecessary duplication
19:28:55 <fog> ok, this is the real issue. 
19:29:03 <fog> about the sharing of heap objects
19:30:02 <fog> if all thats needed is permutation invarient ingoing edges - then the environment is "consumed". ie, when a value is used, it cant be used elsewhere
19:30:12 <fog> unlike being let bound, where it could then be used anywhere
19:30:19 <fog> well, anywhere in scope
19:30:28 <kiwi_45> :t liftIO
19:30:29 <lambdabot> MonadIO m => IO a -> m a
19:30:41 <kiwi_45> :i liftIO
19:30:58 <kiwi_45> :info liftIO
19:31:01 <EvanR> % :i liftIO
19:31:02 <yahb> EvanR: type MonadIO :: (* -> *) -> Constraint; class Monad m => MonadIO m where; liftIO :: IO a -> m a; -- Defined in `Control.Monad.IO.Class'
19:31:25 <kiwi_45> thanks EvanR
19:32:14 <fog> if i write; let f x = id $ (\y -> y x) id
19:32:34 <fog> then the lambda is not let bound and cant be used anywhere else
19:32:46 <fog> which is the closest i can get to the idea of an edge
19:33:36 <fog> it gets evalueated to `x' and this is passed strait into the id on the left of the $
19:33:39 <EvanR> is that haskell?
19:33:44 <fog> yes
19:33:50 <EvanR> so it's in a do block
19:34:09 <fog> @let f x = id $ (\y -> y x) id 
19:34:10 <lambdabot>  .L.hs:179:7: error:
19:34:10 <lambdabot>      • Couldn't match expected type ‘[Char]’ with actual type ‘Color’
19:34:10 <lambdabot>      • In the expression: id $ (\ y -> y x) id
19:34:29 <fog> !@
19:34:44 <fog> % let f x = id $ (\y -> y x) id 
19:34:45 <yahb> fog: 
19:34:50 <fog> % :t f
19:34:50 <yahb> fog: a -> a
19:35:26 <fog> ah, i see what you mean
19:35:29 <EvanR> otherwise, let blocks need an 'in'
19:35:51 <fog> no it was kind of yahb syntax. in a .hs file i would just write f x = ... at top level
19:36:04 <fog> sorry..
19:36:33 <fog> but yes, even if it were in a do block, the lambda would still not bind any variable names
19:36:42 <fog> its just used there and then
19:37:04 <EvanR> a bunch of top level definitions in a module could be considered a labeled graph... too bad ghc doesn't compile it that way, in a convenient form
19:37:17 <fog> it doesnt "write to the environment" and its not binding anything to be "visible in any scope".. if thats the right way to put it
19:38:03 <fog> the point is just to say that lambdas seem to allow functions to exist in exactly one place in the code
19:38:27 <fog> and so seem to correspond to edges on the graph
19:38:28 <moet> is the order of the packages in a .ghc.environment* file important?
19:38:50 <fog> if i implemented my function using nothing from scope, just using lambdas, then it should correspond to a graph
19:38:55 <moet> ok, it appears not
19:39:08 <fog> where each of the arguments supplied to each of the lambdas would be like an input edge
19:39:45 <fog> so, were it not for things being in scope, function implementations would have a corresponding graph 
19:41:05 <kiwi_45> % :i WriterT
19:41:06 <yahb> kiwi_45: type role WriterT nominal representational nominal; type WriterT :: * -> (* -> *) -> * -> *; newtype WriterT w m a = WriterT {runWriterT :: m (a, w)}; -- Defined in `Control.Monad.Trans.Writer.Lazy'; instance [safe] (Monoid w, Alternative m) => Alternative (WriterT w m) -- Defined in `Control.Monad.Trans.Writer.Lazy'; instance [safe] (Monoid w, Applicative m) => Applicative (WriterT w m) -- Defined 
19:41:14 <fog> but i dont want to use lambdas, to bind the variable names after the \ before the ->
19:41:38 <fog> but instead to use something like ImplicitParams to have them be argument order agnostic 
19:42:09 <fog> allowing that the nodes of the graph can be permuted without changing the implementation
19:42:50 <fog> like, swapping the order of the arguments, but also swapping the order of the names bound at the lambda - would do
19:43:11 <fog> like how - ... - would do
19:44:02 <fog> argh, EvanR didnt respond in a while. i better go before monochrom descends 
19:44:56 <fog> thanks though for the help with semantics/syntax 
19:46:24 <kiwi_45> If anyone here would like to help me with servant-auth ? I have setup but I’m missing some bits my code here https://github.com/DeepakKapiswe/Gyan-Lahari-Backend/blob/redisIntegration/src/App.hs
20:30:27 * hackage refined 0.5.1 - Refinement types with static and runtime checking  https://hackage.haskell.org/package/refined-0.5.1 (chessai)
20:50:19 <ja> ooooh rejoice! yahb is back to life! Search Results
20:50:19 <ja> Web results
20:50:31 <ja> ups :O
20:51:28 <ja> would it ever make sense to use 'children' from Control.Lens.Plated if i am working with a binary tree? i think not, because it works on lists?
20:52:20 <c_wraith> it doesn't work on lists, it extracts a list
20:52:43 <c_wraith> It probably isn't very useful, but it would give you the children
20:53:09 <c_wraith> honestly, I've used a lot of stuff in that module, and never wanted children
20:53:18 <c_wraith> It feels present for completeness more than anything else
20:54:30 <ja> i am trying to swap the children, and i am trying something like "downward both %~ Data.Tuple.swap". it isn't working yet, but i think there is hope that it will? (the downward is from kmett's zippers)
21:10:50 <ja> one thing that confuses me about "Zipper h i s" is that i don't know what the types mean? do these letters have common meanings? https://hackage.haskell.org/package/zippers-0.3/docs/Control-Zipper.html#t:Zipper
21:14:02 <c_wraith> h is the route to the focused point, in terms of types.  i is the zipper index type.  s is the type being focused on
21:15:50 <hyiltiz> https://imgur.com/3ZolgF3
21:15:59 <hyiltiz> See last line; is that supposed to be a joke?
21:16:48 <c_wraith> Probably not.  I think it's an exaggeration.  A lot of things reduce nicely, but there are patterns that don't.
21:17:18 <hyiltiz> But less than a line? That is strictly 0 or negative lines
21:17:46 <c_wraith> It could just mean "half of the contents of a line are the data manipulation"
21:18:02 <glguy> You're probably supposed to read it as "less than a full line"
21:18:34 <jchia> probably not to be taken literally
21:19:17 <jchia> but i would change it to "takes a single line of code" if i were him
21:20:03 <jchia> there's a feedback form for the book you can use to send feedback
21:22:45 <c_wraith> ja: if you want to swap the subtrees of a binary tree that is an instance of Plated, you can use partsOf plate %~ reverse
21:23:58 <ja> my tree is not yet instance of plated, i thought it would be better to avoid it because it doesn't assume binary trees, but works with any number of children
21:25:46 <ja> maybe i should just give up and use plated... hmm
21:26:29 <ja> does it make sense to have the h parameter of Zipper be another Zipper?
21:26:38 <c_wraith> Not likely.
21:26:48 <c_wraith> The h parameter is what makes zippers a lot less useful than I'd like
21:26:56 <c_wraith> They change types when going up or down a level
21:33:48 <ja> does that mean that i cannot change anything except the root if i use the 'zipper' function?
21:34:08 <c_wraith> no, it just means the type of the zipper changes when you use up or down
21:34:24 <c_wraith> Which is the part that makes it very hard to use generically.
21:40:33 <phadej> moet: cabal-doctest works, but I wouldn't recommend using it
21:40:41 <phadej> build-type: Custom is not worth it
21:54:32 <jackdk> what does it actually do? I have written things that doctest using build-type: Simple and called doctest in a test-suite.
22:27:50 <ja> phadej: https://hackage.haskell.org/package/cabal-doctest which seems to require Setup.hs (custom?) links to a closed cabal issue about the missing "cabal doctest". so is Custom really still needed?
22:30:06 <remexre> is there a more general / canonical version of https://paste.sr.ht/~remexre/b2700ad9083a237d81f423f1d1ba93c8a2a55859 ?
22:31:45 <dsal> @hoogle filterM
22:31:46 <lambdabot> Control.Monad filterM :: Applicative m => (a -> m Bool) -> [a] -> m [a]
22:31:46 <lambdabot> Data.Vector filterM :: Monad m => (a -> m Bool) -> Vector a -> m (Vector a)
22:31:46 <lambdabot> Data.Vector.Fusion.Bundle filterM :: Monad m => (a -> m Bool) -> Bundle v a -> Bundle m v a
22:32:16 <remexre> yeah, this is more general than those
22:32:58 <dsal> Oh, because of the list?
22:33:15 <remexre> yeah; this works on [], Seq, Vector, Maybe, etc
22:35:55 <dsal> The monad in yours is kind of odd.
22:36:36 <dsal> I'd expect something more like     (Applicative m, Foldable t) => (a -> m Bool) -> t a -> m (t a)
22:37:10 <dminuoso> remexre: wither might be of interest as well.
22:37:13 <remexre> yeah, I'm trying to puzzle out how to loosen Monad to Applicative
22:37:52 <dminuoso> (It's essentially a bit of a generalization of filterM)
22:38:45 <remexre> oh, yeah, filterA in particular
22:39:18 <dminuoso> sure.   filterA f = wither $ \a -> (\b -> if b then Just a else Nothing) <$> f a
22:39:43 <dminuoso> Witherable is and remains my favourite non-base typeclass. :)
22:41:01 <dminuoso> https://hackage.haskell.org/package/witherable-class-0/docs/src/Data.Witherable.Class.html#line-168
22:43:09 <dminuoso> You can mechanically derive a filterA based on this.
23:59:47 <ja> c_wraith: yahoooo! i finally figured it out! i can swap two children in my binary tree!!!! thank you for your help
