00:03:59 <nshepperd2> i think rules as written you'd have to increase A or B since you're changing the definition of a datatype there
00:04:53 <typetetris> nshepperd2: Thanks, also think so, will do.
01:35:51 <zincy__> Is there a good way of writing math documents with Haskell?
01:38:11 <Guest60204> literally starting haskell for the first time, ran cabal init and added a package from hackage into the build-depends section. but after i ran `cabal run` and it downlodaed the dependency and all that, it tells me that the module can't be found
01:38:19 <Guest60204> is there a step that i missed?
01:39:27 <sclv_> did you try to `cabal run` an executable in the package or?
01:39:39 <sclv_> are you trying to bring up a ghci repl with the package in it?
01:40:00 <Guest60204> yep, it's an executable that i'm trying to run; worked perfectly until i put an import statement referencing the dependency
01:40:26 <Guest60204> let me try using the repl
01:40:50 <Guest60204> no dice with the repl either
01:41:29 <sclv_> ok so the build-depends section includes package `foo` but `cabal repl` doesn't have Foo.Module in scope?
01:42:08 <Guest60204> yea
01:42:37 <sclv_> what package is it, and what version are you using?
01:43:03 <Guest60204> servant 0.17
01:43:40 <sclv_> wait, did you add the package to the build-depends of the library, of the executable, or both?
01:43:57 <sclv_> or if you did a `cabal init` maybe you only have an executable stanza?
01:44:13 <Guest60204> yeah, the latter; my .cabal file only has an executable stanza
01:44:35 <sclv_> and what version of cabal are you using?
01:45:06 <Guest60204> 3.2.0.0, just installed it through ghcup today
01:45:19 <sclv_> ok, i'm stumped. thanks for bearing with me
01:45:58 <Guest60204> well, thanks for trying :/ guess i'll poke around at this a bit more
01:46:13 <sclv_> one last question -- what module are you importing?
01:46:25 <Guest60204> import Servant
01:46:34 <sclv_> ok yeah, there's your problem
01:46:46 <Guest60204> wait is that not the module exported by the library
01:46:46 <sclv_> there's no module named Servant!
01:47:05 <sclv_> that library, like most, exports a bunch of hierarchical modules
01:47:06 <sclv_> https://hackage.haskell.org/package/servant
01:47:17 <sclv_> you need to explicitly import e.g. Servant.API or something
01:47:20 <Guest60204> so i have to import one of the submodules then
01:47:21 <Guest60204> ok
01:47:26 <sclv_> right, there's no top level module
01:47:42 <Guest60204> gotcha, that makes sense
01:48:00 <Guest60204> looks like servant-server is the package that actually exposes the Servant module
02:26:12 * hackage pandoc-crossref 0.3.7.0 - Pandoc filter for cross-references  https://hackage.haskell.org/package/pandoc-crossref-0.3.7.0 (lierdakil)
04:18:36 <f-a> I am getting my feet wet with alex
04:18:45 <f-a> (specifically, planning to use it with megaparsec)
04:19:43 <f-a> in the documentation for mp https://markkarpov.com/tutorial/megaparsec.html#working-with-custom-input-streams the suggested token type (which is usable with megaparsec) is WithPos a
04:20:01 <f-a> which has initial/end position, tokenLength and token value
04:20:31 <f-a> so, is there an example or codebase which produces {init/end position, length, value} for alex?
04:20:54 <f-a> tokenLength is the one which I am most puzzled with
04:21:05 <typetetris> if I have two functions calling each other in tail positions, will that be optimized? Otherwise the stack frames would collect and there was a stack space leak?
04:21:27 <merijn> typetetris: Mu
04:21:38 <merijn> typetetris: There are no stack frames and tail calls are meaningless
04:21:46 <merijn> (in ghc haskell, anyway)
04:22:31 <merijn> typetetris: The way GHC compiles Haskell there is no function call stack, and therefore no function call stack frames
04:22:46 <merijn> So you can't overflow the "call stack" with recursion, because it doesn't exist
04:22:58 <typetetris> merijn: Okay, so I have to get another intuition about that stuff.
04:23:36 <merijn> typetetris: The STG paper is a pretty good intro to the low level how and why
04:23:39 <merijn> @where stg
04:23:39 <lambdabot> http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.53.3729
04:24:10 <merijn> typetetris: It doesn't require much prerequisite knowledge besides "super basic haskell" and maybe a bit of basic C/CPU understanding
04:25:10 <typetetris> merijn: Will take a look into it. Perhaps for now: When I recurse and the call to the recursive function isn't in "tail position", then thunks should start collecting for this last operation that will need to be done on the result of the recursive call. Is that a valid intuition?
04:37:14 <dmj`> f-a: you should check out alex-tools
04:48:14 <f-a> thanks dmj` , documentation is a bit sparse (no README, 1-line description) but it will do
04:53:31 <dmj`> f-a: https://github.com/dmjio/graphql-meta/blob/master/src/GraphQL/Lexer.x
04:53:51 <f-a> excellent, many thanks
04:54:30 <dmj`> f-a: also https://github.com/glguy/config-value/blob/master/src/Config/Lexer.x
04:54:37 <dmj`> glguy makes great lexers
04:55:19 <dmj`> @package AlexTools
04:55:19 <lambdabot> https://hackage.haskell.org/package/AlexTools
04:55:35 <dmj`> @package alex-tools
04:55:35 <lambdabot> https://hackage.haskell.org/package/alex-tools
04:56:11 <f-a> I suppose stuff likee `$digit = [0-9]` is redefined for clarity, right?
04:56:54 <f-a> (in e.g. glguy’s lexer)
04:57:33 <dmj`> I don't think $digit is defined for you, iirc
04:58:15 <dmj`> f-a: I wouldn't use any of the alex "wrappers" if its your first time, they kind of obfuscate what is going on
04:58:24 <dmj`> f-a: but what I would do is read the source of the wrappers
04:59:05 <f-a> that’s sensible
05:00:01 <dmj`> f-a: what language are you parsing? If it's a CFG I'd recommend happy too
05:00:51 <dmj`> f-a: this file is very helpful for understanding how the recommended wrappers work, https://github.com/simonmar/alex/blob/11042dbcc45382c57216eecb1438b625e1cca350/templates/wrappers.hs
05:00:53 <f-a> a personal project dmj` a small language to write interactive fiction — hopefully less frustrating I7 —
05:01:28 <dmj`> f-a: very cool
05:01:47 <f-a> hopefully I have something working before IfComp starts
05:02:26 <dmj`> f-a: does your language have a spec?
05:03:21 <f-a> At the moment, only in a notebook!
05:11:05 <dmj`> f-a: that works :) 
05:12:45 <f-a> examples from alex manual contains tab, really another era
05:30:48 <dmj`> f-a: it was the best of times, it was the worst of times
05:31:09 <f-a> haha, appropriate
05:37:09 <gentauro> is there a way to `emit` derived code as instances? An example: `data Foo = Foo deriving (Read, Show)` => `instance Read Foo where …` and `instance Show Foo where …`
05:38:55 <f-a> gentauro: if it is for only for inspection, iirc -ddump-deriv
05:40:26 <f-a> (it writes then on stdout)
05:50:13 <nij> First time here.. is it possible to read chat history?
05:51:03 <typetetris> nij: In the channel topic there is a link to the archives.
05:51:03 <f-a> nij: check /topic
05:57:45 <gentauro> f-a: I will it a try :)
06:00:22 <nij> Wow wonderful! Thank you :)
06:05:52 <gentauro> f-a: it worked :)
06:06:00 <f-a> gentauro: exellent
06:06:18 <gentauro> https://downloads.haskell.org/~ghc/8.6.5/docs/html/users_guide/debugging.html <- I like the disclaimer xD `HACKER TERRITORY. HACKER TERRITORY. (You were warned.)`
06:06:21 <gentauro> xD
06:06:43 <f-a> hehe
06:29:59 <nij> I wonder if people here have experienced haskell at real work? One thing I'm concerned with is that while haskell is elegant and much easier to error-check, it's hard to get it fast. Not saying it's a slow language, but there are lots of caveats if you want it to be fast. See many examples in Bird's new book "algorithm design in haskell": implementing concat by foldr and foldl lead to drastically different 
06:30:05 <nij> asymptotic speed!
06:30:36 <nij> Now, given it takes so much hard work to make it fast, how does that feel in the real job (or say industry)?
06:31:36 <nij> People told me haskell code is easy to modify and extend. I agree totally. But if you want to scale your code, and efficiency is really a concern, how would you do that?
06:31:59 <maerwald> debugging
06:33:12 <nij> It's not just about debugging I believe.. it boils down to knowing all definitions of the functions you use. And by that, I really mean you have to dig into the rabbit hole..
06:33:40 <nij> As a concrete example,
06:33:58 <nij> concat1 = foldr (:) []
06:34:02 <nij> concat2 = foldl (:) []
06:34:23 <nij> The first takes linear time, while the second takes quadratic time! 
06:34:39 <nij> Both at the end does the same thing, but the performance is quite different.
06:35:07 <nij> Worse, if you only care about (length . concat), you should be aware/clever enough to choose the second one instead of the first..
06:35:34 <nij> There are tons and tons of examples in the book, which intimated me a bit..
06:35:39 <nij> And that's why I'm here :O
06:35:53 <maerwald> concat2 does not compile
06:38:37 <nij> Sorry, to correct, it's:
06:38:46 <nij> concat1 = foldr (++) []
06:38:51 <nij> concat2 = foldl (++) []
06:39:02 <xsperry> now concat1 does not compile
06:39:13 <xsperry> nor concat2 :)
06:39:13 <nij> Example: concat1 [[1,2],[3]] ==> [1,2,3]
06:39:55 <nij> It compiled for me..
06:40:20 <xsperry> yeah, I misread
06:41:34 <nij> But that's just examples.. this is the first few examples in the book, and sure it's quite easy to analyze. But I'd imagine that's not the case while you work on real life projects.
06:42:48 <maerwald> it mostly boils down to evaluation and laziness
06:42:57 <maerwald> sometimes inlining problems
06:43:52 <maerwald> IME, most of the time, no one has any idea what is going on, even after looking at heap profiles
06:44:14 <maerwald> unless someone understands GHC very well
06:44:56 <nij> That's my impression too, and also a potential huge concern..
06:45:04 <maerwald> yes it is
06:45:57 <nij> There are still few people write fast codes in it, but I believe that *did take much* hard work.. much harder than in other usual languages.
06:46:47 <maerwald> I worked for a company doing event sourcing with in-memory database using ixset-typed... we had significant performance issues that increased logarithmically over time. Even a consultant could not figure it out
06:47:21 <maerwald> until someone joined the team who knew a lot about GHC and fixed in over a single weekend
06:48:14 <maerwald> we called him a wizard and moved on with our lives
06:49:33 <MarcelineVQ> 'not because of the ghc thing, but he told me tales and he drank my wine'
06:50:53 <maerwald> you need to invest a lot of time thinking about performance in haskell to get any good at it... it doesn't come as a side effect
06:52:25 <maerwald> a good indicator to know whether a language makes it easy to write fast code is to look at the compiler imo
06:52:50 <maerwald> but not all compilers do the same amount of work ofc
06:53:57 <maerwald> ghc is certainly not slow, but not fast either
07:04:29 <nij> or rather, hard to make fast
07:04:38 <nij> maerwald, thanks for your experience!
07:22:20 <MarcelineVQ> "we'll compare these functional algorithms with their imperative versions and comment on complexity ... we also assume op1 and op2 are O(1) even though that may not be true for some implementations" bruh
07:31:59 <dmj`> nij: the FFI also helps with performance concerns greatly
07:33:03 <dmj`> nij: GHC's big problem is inefficient representation, lots of pointer indirections. There's a lot of emphasis on unboxing and using unlifted types to reduce this.
07:37:06 <sheepfleece> Hihihi, am I right to understand that the only difference between small- and big-step semantics is that the last one factors in recursion? 
07:39:19 <sheepfleece> And in this sence when having different evaluators using these two "strategies" we need to repeatedly apply small-step evaluator until we get to NF, whereas big-step one must be called exactly once and it will evaluate itself to NF.
07:39:52 <sheepfleece> Or did I get it wrong? 
07:49:58 <dolio> It's something like that. I think some of the forms that rules come in with big step would probably not be suitable for realistic evaluation.
07:50:57 <maerwald> dmj`: you can't ffi into an effects system :p
07:52:45 <dolio> Like, you might have rules defined inductively, like `F ~> (λ x. E) and X ~> X' ==> F X ~> E[x := X]` or something.
07:55:46 <dolio> Possibly with machine before/after states attached. However, this isn't a realistic machine model, because the machine state is not accounting for the storage of X while F is a being evaluated. Whereas a small step rule would have to step to a machine state that has X stored somewhere and is evaluating F, because there is no way to hide that sort of thing in the inductive definition of the reduction relation.
07:56:44 <dolio> It's possibly I'm off base, though, because I'm not an expert on all the flavors of operational semantics.
07:58:14 <dmj`> maerwald: free monads will probably double if not triple your runtime representation size, including lots of additional gc to stop your program from running. Any effect system that advocates for them would be counter intuitive imo.
08:14:34 <maerwald> can you do strike-through style with vty?
08:16:05 <hc>  n̶o̶
08:16:54 <maerwald> meh
08:55:08 <dminuoso> TIL. An associated data type can be written `class F s where data T (k :: s)` - this is incredibly handy. :)
09:12:56 <dminuoso> Mmm, is there some equivalent of replicateM for comonads?
09:13:55 <dminuoso> Since comonads capture "contextful calculations" in some sense, I dont think it even makes sense, does it?
09:14:20 <dminuoso> (At least that's what all comonad instances seem to be about)
09:15:22 <c_wraith> Like, what sort of type are you looking for?
09:15:31 <dminuoso> Not quite sure, honestly
09:15:46 <dminuoso> Just exploring how many dual variants of monadic things I can find.
09:16:03 <c_wraith> Because there are boring things like  \n -> map extract . replicate n
09:16:11 * hackage language-dickinson 0.1.2.0 - A language for generative literature  https://hackage.haskell.org/package/language-dickinson-0.1.2.0 (vmchale)
09:16:24 <c_wraith> And that's about as interesting as you can get from a list of comonadic values
09:18:44 <dminuoso> Well Im just so surprised there's very few comonadic functions. Like, it seems the only combinators you can get out of them is cokleisli composition (i.e. Comonad w => (w b -> c) -> (w a -> b) -> w a -> c) and comonadic fix point `Comonad w => (w a -> a) -> w a `
09:19:50 <dminuoso> And that's it, compare that to the incredibly rich and wealthy universe of monadic functions like replicateM, traverse_ (there's no ComonadApply equivalent either)
09:20:28 <EvanR> yeah comonads don't really have much of a generic API
09:21:31 <EvanR> in practice you really need to know the details of w to get anything done
09:24:51 <dminuoso> Mmm there's some talk in https://www.reddit.com/r/haskell/comments/9nche5/why_monad_is_so_much_more_used_useful_than_comonad/ that is related here.
09:24:56 <dminuoso> Love this line: `Because all the coalgebras in a cartesian monoidal category are trivial.`
09:25:28 <MarcelineVQ> dminuoso: it is obvious to everyone
09:26:06 <maerwald> merging of attributes in brick is really weird
09:26:38 <dminuoso> though that thread only argues why there's fewer instances, not why there's fewer combinators.
09:27:02 <maerwald> MarcelineVQ: why even mention it, right?
09:28:55 <dolio> What does 'trivial' mean?
09:29:43 <MarcelineVQ> It means it could appear on a card in a game where the prizes are pizza slices.
09:30:11 <maerwald> that makes a lot of sense
09:30:13 <MarcelineVQ> And if that's too obscure then I've filkeld my quota for the day
09:30:22 <MarcelineVQ> also filled, also filkeld
09:35:01 <EvanR> filkeld is cromulent
09:36:31 <MarcelineVQ> einhorn is finkle, finkle is einhorn
09:38:41 <dolio> I don't really understand what some of the people in that thread are saying. Below the 'trivial' remark, there are people going on about how you need different structure to have 'interesting' comonads. What makes all of the comonads you can define in Haskell 'uninteresting'?
09:39:47 <dminuoso> dolio: Well really, without interesting comonoids you dont get interesting comonads.
09:39:55 <isovector1> is anyone familiar with "context passing style" (not continuation)?
09:40:18 <isovector1> i'm trying to reverse engineer one of john hughes' papers that uses the approach, but can't find any other references to the idea
09:40:29 <dminuoso> If we think of `duplicate` as `duplicate :: m ~> m :.: m`, then there's very little comonoidal actions in the haskell world.
09:40:39 <dminuoso> otoh monoids are rich and diverse
09:40:56 <dminuoso> which is why `join  :: m :.: m ~> m` can have many different meanings
09:41:52 <dminuoso> I mean in the value world, all you could get from a comonoid is `split :: s -> (s, s)` right?
09:41:56 <dminuoso> That can possibly only duplicate things
09:42:11 <dminuoso> They are rather blant
09:42:33 <EvanR> s -> (s,s) isn't boring if you're using linear types!
09:42:38 <dminuoso> And equivalently:: `destroy :: s -> ()` doesnt do anything useful either
09:42:43 <MarcelineVQ> isn't is expecially boring then?
09:42:44 <dminuoso> It just throws away a value
09:42:47 <MarcelineVQ> isovector1: which paper?
09:43:58 <EvanR> if duplicating is normally not allowed then uses of s -> (s,s) (and s -> ()) is something the compiler can grab on to
09:49:43 <Cheery> isovector1: can you link to the paper ?
09:53:12 <x0r-255> I am trying to apply a custom "GSConfig Window" to the function spawnSelected https://www.stackage.org/haddock/lts-16.4/xmonad-contrib-0.16/src/XMonad.Actions.GridSelect.html origianally here, but modded to look like this:
09:53:14 <x0r-255> spawnSelected' :: [(String, String)] -> X ()
09:53:16 <x0r-255> spawnSelected' lst = gridselect conf lst >>= flip whenJust spawn
09:53:17 <x0r-255>  where
09:53:19 <x0r-255>   conf = def
09:53:20 <x0r-255>    mygridConfig
09:53:26 <x0r-255> but it's not working!
09:53:32 <Cheery> hi x0r-255 
09:53:39 <x0r-255> hello again Cheery
09:56:25 <Cheery> gridselect :: GSConfig a -> [(String, a)] -> X (Maybe a)
09:56:31 <Cheery> http://hackage.haskell.org/package/xmonad-contrib-0.16/docs/XMonad-Actions-GridSelect.html
09:57:31 <x0r-255> Cheery: What's a (as in [String, a])?
09:57:52 <x0r-255> action? no... normally that's X () right?
09:58:38 <dolio> dminuoso: That doesn't make any sense.
09:58:56 <Cheery> x0r-255: haskell shortens the type declarations, the full type declaration looks like this:
09:59:04 <Cheery> gridselect :: forall a. GSConfig a -> [(String, a)] -> X (Maybe a)
09:59:21 <dolio> What does "interesting" mean. It seems like a vague value judgment masquerading as something precise.
10:00:32 <Cheery> x0r-255: it's a type variable, bit like in a function \x -> y, 'x' can appear inside 'y'
10:01:03 <Cheery> you can pass whatever you want to the 'a'.
10:01:13 <x0r-255> hm
10:01:29 <Cheery> in your program you appear to pass String to that function.
10:01:36 <dolio> Realizability toposes are obviously Cartesian monoidal categories. There's a comonad # that takes any object to the object of computable values of the original object. It's a modality, even, because it's idempotent. Coalgebras of that comonad are the objects whose values are already computable. Why is all that 'trivial' and 'uninteresting'?
10:02:28 <Cheery> x0r-255: is the 'conf' good? that 'mygridConfig' is a GSConfig for strings?
10:03:01 <x0r-255> It's type is: mygridConfig :: p -> GSConfig Window
10:03:19 <x0r-255> here, https://pastebin.com/PAskXAvE <-- more specificity
10:04:48 <x0r-255> that's what I just tried based on your feedback
10:04:53 <x0r-255> no luck
10:05:01 <x0r-255> at least in the way that I tried
10:05:51 <x0r-255> ignore the mycolorizer typo, fixing that does nothing
10:08:04 <Cheery> gridselect def [("nope", False), ("yes", True)] >>= \result -> pure ()
10:09:48 <Cheery> or if you wanted to run something..
10:10:10 <Cheery> gridselect def [("nope", "xterm"), ("yes", "xterm")] >>= spawn
10:10:34 <x0r-255> xterm xD
10:11:03 <x0r-255> alriht that errors out, but it seems like we're getting closer
10:11:07 <x0r-255> alright*
10:11:56 <x0r-255>  Couldn't match type ‘Maybe String’ with ‘[Char]’
10:11:58 <x0r-255>       Expected type: Maybe String -> X ()
10:11:59 <x0r-255>         Actual type: String -> X ()
10:12:28 <Cheery> hmm.. right. I didn't notice that
10:13:33 <Cheery> gridselect def [("nope", "xterm"), ("yes", "xterm")] >>= maybe (pure ()) spawn
10:15:20 <Cheery> comonads not interesting?
10:15:38 <x0r-255> compiled...
10:15:40 <x0r-255> lets try it
10:16:11 <x0r-255> okay, well that worked, but now comes the issue of my config throwing errors when I put it in
10:18:05 <Cheery> x0r-255: it looks for GSConfig and your config is different.
10:18:44 <x0r-255> it works nicely with gotoSelected & bringSelected
10:19:23 <x0r-255> it takes GSConfig Window -> X ()
10:19:23 <NewToHaskell> Hi, could someone explain why this doesn't work? `sum . takeWhile (<10000) . filter odd . map (^2) [1..10]`
10:19:40 <NewToHaskell> equivalent `sum (takeWhile (<10000) (filter odd (map (^2) [1..]))) `
10:20:08 <NewToHaskell> did I put a dot wrong somewhere?
10:20:26 <dsal> NewToHaskell: precedence.
10:20:30 <shapr> NewToHaskell: You could write it point-ful and then use the pointless plugin in lambdabot
10:20:47 <dsal> > sum . takeWhile (<10000) . filter odd . map (^2) $ [1..10]
10:20:49 <lambdabot>  165
10:21:19 <Cheery> x0r-255: you need GSConfig String
10:23:06 <Cheery> NewToHaskell: you're doing it wrong.
10:23:15 <x0r-255> darn, I can't find how to do that
10:23:25 <Cheery> f (g x) = (f.g) x
10:24:06 <Cheery> x0r-255: maybe your config is overspecialized? what you've written into it?
10:25:16 <x0r-255> here - 
10:25:18 <x0r-255> myColorizer :: Window -> Bool -> X (String, String)
10:25:19 <x0r-255> myColorizer =
10:25:21 <x0r-255>  colorRangeFromClassName
10:25:22 <x0r-255>   (0x11,0x22,0x33) -- lowest inactive bg
10:25:24 <x0r-255>   (0x15,0x27,0x38) -- highest inactive bg
10:25:25 <x0r-255>   (0x66,0xff,0xcc) -- active bg
10:25:27 <x0r-255>   (0x66,0xff,0xcc) -- inactive fg
10:25:28 <x0r-255>   (0x11,0x22,0x33) -- active fg
10:25:30 <x0r-255> --  ("11", "22", "33")
10:25:31 <x0r-255> -- gridSelect menu layout
10:25:33 <x0r-255> mygridConfig :: p -> GSConfig Window
10:25:34 <x0r-255> mygridConfig colorizer =
10:25:36 <x0r-255>  (buildDefaultGSConfig myColorizer)
10:25:37 <x0r-255>   { gs_cellheight   = 50
10:25:39 <x0r-255>   , gs_cellwidth    = 75
10:25:40 <x0r-255>   , gs_cellpadding  = 7
10:25:42 <x0r-255>   , gs_originFractX = 0.5
10:25:43 <x0r-255>   , gs_originFractY = 0
10:25:44 <juri_> ugh.
10:25:45 <x0r-255>   , gs_font         = myFont
10:25:46 <x0r-255>   }
10:25:55 <juri_> use a pastebin next time.
10:26:01 <Cheery> or gists
10:26:03 <x0r-255> ok
10:26:11 <hyiltiz> what happened to pastebins 
10:26:25 <Cale> Nothing, they still exist
10:26:39 <Cheery> mygridConfig :: p -> GSConfig Window um....
10:26:41 <Cale> http://dpaste.com/ is decent
10:26:48 <x0r-255> figured it'd be a bit faster this way, but lesson learned I guess
10:27:34 <Cheery> x0r-255: try change that type to GSConfig a
10:28:21 <x0r-255> Couldn't match type ‘a’ with ‘Window’
10:28:52 <dminuoso> dolio: So on the value level we'd have `class Comonoid m where destroy :: m -> (); split :: m -> (m, m)` - we dont even have any interesting comonoids. Think of the destroy case in particular.
10:28:58 <dminuoso> Comonoids are just totally blant for us.
10:29:52 <x0r-255> Cheery: doing that causes errors everywhere
10:30:01 <Cheery> x0r-255: it's the myColorizer that is using the Window to colorize.
10:30:25 <dolio> Yes, I know there is a unique comonoid structure on every object of a Cartesian monoidal category.
10:30:44 <dolio> How does that imply that comonads and their coalgebras are 'not interesting'?
10:31:36 <dolio> The usual point of that example is that comonads aren't like comonoids in that respect.
10:32:00 <Cheery> x0r-255: make a separate colorizer for strings
10:32:12 <dolio> Because the category of endofunctors is not Cartesian monoidal.
10:33:03 <x0r-255> would I just use hex values? or what
10:33:13 <x0r-255> can't find where colorizer is defined
10:34:22 <Cheery> there seem to be stringColorizer :: String -> Bool -> X (String, String)
10:34:56 <Cheery> mygridConfig :: (a -> Bool -> X (String, String)) -> GSConfig a
10:35:08 <Cheery> then wire your 'myColorizer' through the parameter.
10:35:33 <gentauro> x0r-255: how did you get away posting that wall of code?
10:35:35 <Cheery> and pass that stringColorizer into the mygridConfig
10:35:40 <gentauro> last time I posted 12 lines I got banned
10:35:40 <x0r-255> idk
10:35:41 <gentauro> XD
10:36:09 <x0r-255> perhaps they loosened the rules?
10:36:12 <OmegaDoug> Is it possible for Stack to reference a local stack project as a dependency? I can't find that use case listed in the docs.
10:36:14 <gentauro> x0r-255: my fav pastebin for the time being -> https://pastebin.ubuntu.com/
10:36:26 <gentauro> x0r-255: I hope not
10:36:45 <OmegaDoug> So my main app would reference a local library, both Stack projects,
10:37:04 <gentauro> OmegaDoug: I would love to know how to do that
10:37:05 <gentauro> :)
10:38:21 <OmegaDoug> gentauro I did it in the D language with DUB and it was really convenient. Was hoping Stack has a similar feature.
10:39:31 <c_wraith> referencing a local stack project is the wrong level of abstraction.  you want to reference a local package.
10:39:48 <gentauro> OmegaDoug: I recently moved away from package.yaml to .cabal files in the hope of being able to do something like that
10:39:53 <gentauro> but never got it working :|
10:41:03 <monochrom> I think people conflate project and package all the time, since they have only done 1-1 correspondences between projects and packages.
10:41:27 <monochrom> When someone says "project" you can't take it literally.
10:41:45 <Cheery> x0r-255: did you get it?
10:41:51 <x0r-255> no
10:41:53 <OmegaDoug> I could be off with my terminology. I'm talking about a library that will be used as a dependency in an application.
10:42:09 <c_wraith> My point was more that it's irrelevant what tools you develop the other package with.  As long as it's a proper package, you can refer to it in the filesystem
10:42:19 <gentauro> OmegaDoug: be careful with rephrasing it like that
10:42:28 <OmegaDoug> ??
10:42:35 <gentauro> cos you are gonna get some answers that aren't usefull
10:42:36 <gentauro> ;)
10:42:59 <gentauro> I would rather call them `artefacts`
10:43:11 <gentauro> `artefact A` needs `artefact B`
10:43:12 * hackage req 3.4.0 - Easy-to-use, type-safe, expandable, high-level HTTP client library  https://hackage.haskell.org/package/req-3.4.0 (mrkkrp)
10:43:29 <gentauro> where both artefacts have nothing in common
10:43:49 <x0r-255> Cheery: I do -- strColorizer = stringColorizer myColorizer and this happens:
10:43:52 <x0r-255>  Couldn't match type ‘Window -> Bool -> X (String, String)’
10:43:53 <x0r-255>                      with ‘[Char]’
10:43:58 <gentauro> if you don't state it like this, they will tell you to make `a lib` and `an executable` in the same .cabal file
10:44:28 <OmegaDoug> I don't want to get hung up on terminology. ;)  I'd much rather see if there's a way to stack code in folder A to make use of stack code in folder B while doing everything locally on my laptop
10:44:29 <gentauro> which, in my case, it's not what I'm aiming for
10:45:01 <gentauro> OmegaDoug: I `totally` understand what you are saying. I'm looking for that answer as well ;)
10:45:45 <gentauro> but you could end up with this answer -> https://github.com/joshcough/HaskellStarter/blob/master/haskell-starter.cabal#L18-L37
10:45:59 <Cheery> x0r-255: you need to look at the types, and understand what they mean.
10:46:09 <gentauro> and that is not what I really want ;) 
10:46:24 <x0r-255> OmegaDoug: is there a way to do local imports?
10:46:26 <c_wraith> I don't understand stack at all
10:46:29 <x0r-255> that'd solve your problem
10:46:50 <c_wraith> this is easy to do with cabal, but incredibly hard to find if it's even possible with stack
10:47:39 <gentauro> 19:46 < x0r-255> OmegaDoug: is there a way to do local imports?
10:47:51 <gentauro> bingo, the question we have all been asking !!!
10:48:01 <tomsmeding> if you want the downstream package to use stack, can't you add an `extra-deps` clause to its stack.yaml?
10:48:05 <x0r-255> http://stackoverflow.com/questions/1438446/ddg#1438482 ??
10:48:05 <OmegaDoug> I'm not sure. I'm trying to lookup the package.yaml docs now. I can't find them.
10:48:07 <tomsmeding> those can be local paths
10:48:10 <Cheery> x0r-255: hey, lets first fix one half of this thing.. we can do that by plugging a term with 'undefined' for short moment.
10:48:29 <Cheery> mygridConfig :: (a -> Bool -> X (String, String)) -> GSConfig a
10:48:35 <Cheery> mygridConfig colorizer = undefined
10:48:51 <x0r-255> k
10:49:20 <Cheery> now you'd have to fix each mygridConfig in your script
10:49:33 <x0r-255> for the time being I'll just comment them out
10:49:41 <x0r-255> stringColorizer doesn't work like you said
10:49:43 <x0r-255> at least when doing
10:49:47 <x0r-255> strColorizer = stringColorizer myColorizer
10:49:47 <Cheery> you have myColorizer, so just do (mygridConfig myColorizer)
10:50:08 <Cheery> and for the one that expects GSConfig String, do (mygridConfig stringColorizer)
10:50:42 <x0r-255> no, it errors on the creationn of strColorizer
10:51:41 <Cheery> yeah, you try to apply your colorizer as argument to stringColorizer
10:52:05 <Cheery> but if you look at the stringColorizer's type, it's String -> Bool -> X (String, String)
10:52:23 <Cheery> so you try to give a function as a string.
10:52:45 <x0r-255> okay, a simple hex color shuts it up for now
10:53:05 <Cheery> don't run it yet because you got undefined there, once it compiles, fix the mygridConfig and then run it.
10:53:39 <c_wraith> OmegaDoug: what you want to do is easy with cabal.  I have no idea how to do it with stack.
10:53:52 <x0r-255> now I get this on the `gridselect (mygridconfig...` part
10:53:54 <x0r-255> Couldn't match type ‘[Char]’ with ‘GHC.Word.Word64’
10:53:56 <x0r-255>       Expected type: [(String, Window)]
10:53:57 <x0r-255>         Actual type: [(String, String)]
10:54:00 <c_wraith> It's probably easy, but it's not clearly documented
10:54:26 <tomsmeding> c_wraith: isn't it extra-deps in stack.yaml?
10:54:28 <OmegaDoug> c_wraith Do you happen to know where it's documented for Cabal? I can take a look. Since Stack generates a .cabal file it should be east to verify
10:54:28 <Cheery> x0r-255: yup, use stringColoriser instead of myColorizer on that one.
10:54:31 <tomsmeding> or doesn't that suit the purpose
10:54:42 <OmegaDoug> https://docs.haskellstack.org/en/stable/yaml_configuration/
10:54:59 <c_wraith> OmegaDoug: it's not in the .cabal file.  It's in the cabal.project file
10:55:32 <OmegaDoug> Ok, then that's different I suppose. My project has a {projectName}.cabal file
10:55:52 <c_wraith> looks like you can do it with extra-deps, but they're really cagey on actually documenting it
10:56:12 <OmegaDoug> It looks like it the code all has to share the same root folder
10:56:15 <c_wraith> oh.  no.  extra-deps only works with tarballs or zip files
10:56:24 <c_wraith> Or git or mercurial repos
10:56:26 <tomsmeding> wait what?
10:56:27 <c_wraith> what sort of madness is that?
10:56:43 <c_wraith> tomsmeding: https://docs.haskellstack.org/en/stable/yaml_configuration/#extra-deps
10:56:45 <OmegaDoug> That's lame
10:56:56 <tomsmeding> I have something like `extra-deps:\n- ../other-package1\n- ../other-package2` in my stack.yaml, and that works fine
10:57:01 <monochrom> Perhaps extra-deps is not for this.
10:57:02 <tomsmeding> both are normal stack projects
10:57:10 <x0r-255> Cheery: that's not the issue, here's more detail - https://pastebin.com/jc8dqdZ3
10:57:12 <OmegaDoug> I like the sounds of that
10:57:13 <monochrom> err nevermind
10:57:34 <c_wraith> tomsmeding: then why don't they document it?
10:57:44 <monochrom> cabal.project is explained in https://cabal.readthedocs.io/en/stable/nix-local-build.html#configuring-builds-with-cabal-project
10:58:01 <x0r-255> * myApps :: [(String, String)]
10:58:15 <tomsmeding> c_wraith: I have absolutely no idea
10:58:19 <monochrom> and this is where "project" consists of multiple "packages"
10:58:30 <tomsmeding> OmegaDoug: does extra-deps work for you in the way I mentioned?
10:58:45 <tomsmeding> ignoring for a moment that it's undocumented apparently...?
10:59:05 <OmegaDoug> tomsmeding I'm going to try it out now and see
10:59:05 <ja> i need a binary tree type, and i was wondering if there is a better choice than this one? https://hackage.haskell.org/package/type-indexed-queues-0.2.0.0/docs/Data-BinaryTree.html
10:59:07 <monochrom> yeah please don't get mad :)
10:59:12 <Cheery> x0r-255: replace strColorizer with stringColorizer
10:59:27 <Cheery> in the location of the first error.
10:59:31 <c_wraith> ja: why do you need a binary tree type?
11:00:03 <x0r-255> strColorizer is a reference to `stringColorizer "#fb8"`
11:00:08 <x0r-255> strColorizer is a reference to `stringColorizer "#fb8"
11:00:15 <ja> c_wraith: "the accumulator is a forest of perfect binary hash trees" https://eprint.iacr.org/2019/611.pdf
11:00:21 <monochrom> (don't get mad, get even.  one way to get even: every time you see a beginner using stack, "teach them cabal, and you will be happy for life" :) )
11:00:33 <tomsmeding> c_wraith: it is documented!
11:00:39 <Cheery> x0r-255: yup, it doesn't work that way. I think stringColorizer is a default routine that you then replace with something of your own.
11:01:01 <tomsmeding> they say "For the local file path case, the same relative path rules as apply to packages apply." -- and if you then go to the docs for `packages`, which is right above, they say that you can put local paths there
11:01:27 <x0r-255> welp, that fixed it
11:01:27 <tomsmeding> though it's really unclear
11:01:31 <c_wraith> ja: from the paper - "As the trees in the forest are always perfect, they hold 2^h leaves"
11:01:42 <x0r-255> now to fix my config as it's currently undefined
11:02:04 <c_wraith> ja: you don't want an arbitrary binary tree.  You want some sort of perfect binary tree.
11:02:07 <monochrom> aww binary tree coded directly is a poor implementation for heaps, even binary heaps.
11:02:25 <x0r-255> okay the position and everything works now
11:02:30 <x0r-255> but the colors are still lacking
11:02:36 <ja> monochrom: who said anything about heaps ? :O
11:02:37 <x0r-255> how do I integrate that?
11:03:04 <monochrom> "A simple binary tree for use in some of the heaps."
11:03:07 <Cheery> x0r-255: I don't know because types don't tell. But likely the manual does..
11:03:17 <Cheery> x0r-255: so you'd need to replace stringColorizer with your own.
11:03:43 <monochrom> The package you ran into is a "type-indexed-queues" and it means priority queues.
11:03:55 <Cheery> myStringColorizer :: String -> Bool -> X (String, String)
11:04:01 <ja> ah yeah, but the tree type seems general-purpose
11:04:22 <ja> c_wraith: do you think it would be a good idea to encode the tree height in type level heights? that way i can enforce perfectness
11:04:43 <ja> like with type level nats
11:04:46 <monochrom> Yes, but you would rather copy those two lines of code than bring in the whole package. Also, c_wraith is right, it may actually be better to customize your own.
11:05:07 <c_wraith> Meh. I don't know if doing that is a good idea without reading the paper to see how they're used.
11:05:29 <monochrom> That is wisdom.
11:05:39 <ja> i know how they are used, i already ported the whole thing from go to imperative haskell
11:05:50 <monochrom> 90% of the time the name of the data structure is not enough.
11:05:50 <ja> now i wanna make it ideomatic... trying out the zippers package
11:06:26 <dolio> You don't need type-level nats to encode perfect binary trees.
11:06:29 <c_wraith> putting stuff like that in the type level can help reduce errors, but it can also introduce a lot of unnecessary bookkeeping
11:07:13 <ja> dolio: what would you suggest? it is not obvious to me how to enforce that child tree 1 has the same height as child tree 2
11:07:36 <Cheery> x0r-255: the form seem to be simple.
11:08:03 <Cheery> the (String, String), left side is hexadecimal string, right side is name of that color.
11:08:04 <dolio> Nested types can do it.
11:08:05 <c_wraith> ja: among other things, you can do something like this:   data Perfect a = Leaf a | Perfect (a, a)
11:08:15 <x0r-255> I just have no clue where to input my colors
11:08:38 <Cheery> myStringColorizer _ _ = pure ("#fb8", "orange")
11:08:38 <ja> c_wraith: how does that type encode anything about the perfectness?
11:08:48 <ja> just looks like a regular binary tree to me?
11:08:56 <c_wraith> err. data Perfect a = Leaf a | Node (Perfect (a, a))
11:09:28 <tomsmeding> that's a horrible data type to use in practice I think
11:09:34 <c_wraith> it is.
11:09:36 <tomsmeding> even though it technically encodes a perfect binary tree
11:09:44 <c_wraith> all irregular data types are painful :)
11:10:11 <monochrom> but when compared to type-level tricks?
11:11:02 <Cheery> x0r-255: I don't know what the boolean parameter does, and I guess the String is the string given as a parameter, you can use that to select the color.
11:11:06 <dolio> Depending on the access pattern there might be some other better encoding, too.
11:11:15 <tomsmeding> data Z ; data S a; data Perfect h a where { Leaf :: a -> Perfect Z a ; Node :: Perfect h a -> Perfect h a -> Perfect (S h) a }
11:11:27 <tomsmeding> I believe that encodes a perfect binary tree, and it'll be a _lot_ easier to use :p
11:11:52 <tomsmeding> probably can use type-level Nat's for this, but I don't know the definitions by heart
11:12:18 <c_wraith> Sometimes you end up need an existential wrapper around the height when using those though, which is annoying.
11:12:21 <Cheery> x0r-255: going to bath, hopefully that helped enough. Just remember to read types and think of what they mean.
11:12:33 <ja> in go they encode it as an array with leaves first, then nodes on the level above, and so on. and then there is a map that maps node values to positions in the array. so they keep maintaining both of those
11:12:35 <x0r-255> k
11:12:39 <tomsmeding> c_wraith: fair point
11:12:59 <c_wraith> hence...  it depends on usage.
11:13:09 <tomsmeding> ja: sounds like the classical imperative way to maintain a tree in an array in an imperative language
11:13:25 <tomsmeding> though I'd expect the top node to come first, then go down the tree, instead of leaves first then upwards
11:13:34 <ja> it is perforant , but the algorithm to swap subtrees is like 30 lines, i thought i would focus on elegance, but isn't there a way to keep it half-way perfomant?
11:13:34 <monochrom> yeah perhaps use an array
11:13:36 <c_wraith> a perfect tree is very nice to encode in an array.
11:13:40 <tomsmeding> then you have the neat trick where the index of the children are 2*i and 2*i+1
11:14:04 <ja> with zippers, i can do that trick in one line
11:14:48 <ja> but a path down a tree is isomorphic to an integer index, isn't there a way to take advantage of that?
11:15:14 <OmegaDoug> tomsmeding I just tested it and it works exactly as expected. I was able to provide an absolute path to the dependency and I was able to invoke a function from it
11:15:46 <OmegaDoug> That'll really help improve my workflow. 
11:15:58 <tomsmeding> OmegaDoug: cool! nice that it works on more than 1 setup :p
11:16:09 <tomsmeding> I'm not sure how I found it in the first place a while ago
11:16:40 <OmegaDoug> gentauro FYI, the solution put forward by tomsmeding worked
11:16:54 <halogenandtoast> Can someone help confirm whether or not this is impossible (hint, I think it is). I want to have a type class RunMessage which allows me to pattern match on messages and dispatch behavior. I have a generic record for that, let's call it Animal, that handles a bunch of messages. I would like to specialize this animal though so I can override some of the pattern matching, but allow it to fall
11:16:56 <halogenandtoast> through if the "superclass" doesn't define the behavior. So I was considering using a newtype wrapper, then deriving instances of the RunMessage class that would pattarn match as far as it could and then unwrap the newtype wrapper and continue the pattern matching, but...
11:17:17 <OmegaDoug> Just add extra-deps: \n  - /home/doug/dev/wireyard2 to stack.yaml
11:17:30 <halogenandtoast> I want to store these animals in a HashMap and behavior starts getting weird when I want to do (HashMap AnimalId (IsAnimal a))
11:17:42 <halogenandtoast> IsAnimal is a constraint obviously, just putting there for brevity
11:17:47 <OmegaDoug> tomsmeding I'm glad you did because I may not have figured out that from the documentation alone.
11:18:10 * tomsmeding believes that OmegaDoug meant to put no spaces around the \n
11:19:24 <tomsmeding> halogenandtoast: half-baked thought: I guess you can create a newtype wrapper with an existential type :p
11:19:31 <halogenandtoast> I have another record type which holds this HashMap, but I ended up some weird places when I tried to do `forall a. IsAnimal a => HashMap AnimalId a`
11:19:39 <halogenandtoast> >  Game must not have exotic unlifted or polymorphic arguments
11:19:41 <lambdabot>  error:
11:19:41 <lambdabot>      Data constructor not in scope:
11:19:41 <lambdabot>        Game
11:19:44 <tomsmeding> as in: newtype SomeIsAnimal a = forall animal. IsAnimal animal => animal a
11:19:46 <halogenandtoast> sorry lambdabot
11:20:06 <tomsmeding> oh crap
11:20:12 <tomsmeding> newtype SomeIsAnimal a = forall animal. IsAnimal animal => SomeIsAnimal (animal a)
11:20:14 <tomsmeding> of course
11:20:34 <halogenandtoast> I'll try `Some`thing like that
11:20:37 <tomsmeding> may need some language extensions for that though :p
11:20:43 <halogenandtoast> I have a lot at this point
11:21:05 <tomsmeding> not saying this might be the most ergonomic solution, but eh
11:21:12 <sm[m]> OmegaDoug: I haven’t read the whole chat but yes there’s a few easy ways to do that, such as adding the local package directory to your stack.yaml packages: list
11:21:40 <tomsmeding> sm[m]: if you add it to `extra-deps` instead of `packages`, you can also set flags on those dependencies
11:21:58 <tomsmeding> in my experience stack has a bug where setting flags on a package in `packages` does nothing -- it just ignores it
11:24:50 <halogenandtoast> tomsmeding: I'm a little confused by that definition, animal seems like it need to need a higher kind? Expected kind ‘k0 -> *’, but ‘investigator’ has kind ‘*’
11:24:56 <halogenandtoast> investigator is animal here, sorry
11:25:17 <halogenandtoast> I used animal in chat because I feel like it would be easier to rationalize
11:25:32 <tomsmeding> oh wait your animals don't take arguments
11:25:42 <sm[m]> tomsmeding: thanks. I see packages: has been simplified recently, at https://docs.haskellstack.org/en/stable/yaml_configuration/#packages
11:25:55 <tomsmeding> well then: newtype SomeIsAnimal = forall animal. IsAnimal animal => SomeIsAnimal animal
11:25:57 <halogenandtoast> tomsmeding: I'll paste some non-working code
11:26:03 <ja> c_wraith: using your definition, what is the difference between Node (Leaf (1,1)) and Leaf (1,1) ? i am trying to imagine the trees graphically
11:26:43 <ja> they are both complete trees, right? since even a leaf is a tree. what does the Node wrapper encode?
11:26:48 <tomsmeding> ja: the first is a tree of type Int with one level, the second is a tree of type (Int, Int) with zero levels
11:26:52 <c_wraith> ja: the former is of type Perfect Int.  The latter is of type Perfect (Int, Int)
11:26:57 <tomsmeding> that
11:27:00 <ja> aaah ok
11:27:09 <halogenandtoast> tomsmeding: A newtype constructor cannot have a context in its type, can't find a language extension that would allow that tierh.
11:27:19 <halogenandtoast> *either
11:27:40 <tomsmeding> oh that's right, should be `data`
11:27:56 <halogenandtoast> time for some GADTs
11:27:57 <monochrom> ExistentialQuantification, and change "newtype" to "data".
11:28:07 <c_wraith> ja: it's absolutely awkward to work with, and if you think it's not worth it, you're probably right. :)
11:28:26 <tomsmeding> halogenandtoast: sorry for pushing a trial-and-error development style on you for a minute :p
11:28:46 <ja> but i think it would be easier to work with using 'zippers'? so i don't know why it is so bad?
11:29:09 <ja> i mean, i am playing with Data.Tree a bit, and it is all right, i just don't like the fact that i have binary trees but they encode the children as a list
11:30:21 <ja> so it should be a strict improvement on that, i think
11:30:55 <tomsmeding> sure, but `data BinaryTree a = Node (BinaryTree a) (BinaryTree a) | Leaf a` is also an improvement on that :p
11:31:17 <tomsmeding> my GADT is the next step up I think, and enforces perfectness on the type level
11:31:24 <tomsmeding> (barring `undefined`)
11:31:49 <halogenandtoast> tomsmeding: no worries, I'd rather have some direction than no direction
11:32:15 <ja> tomsmeding: ah so you're saying that the wraith-tree is only cumbersome because it enforces the invariant in the types, and if i use your BinaryTree type (non perfect), it's a good compromise?
11:32:36 <tomsmeding> ja: did you see my GADT thing couple screens back?
11:33:03 <ja> ooh sorry, i missed it! will play with that
11:33:29 <tomsmeding> as said you may want to nice'ify the Z and S stuff to proper Nat's, perhaps with DataKinds, but that's the idea :p
11:33:50 <ja> hmm ok let's see, thanks
11:33:51 <halogenandtoast> The next confusing part would be how to use runMessage with it? instance RunMessage SomeIsAnimal where runMessage msg (SomeIsAnimal internal) = runMessage msg internal, gives Couldn't match type ‘animal’ with ‘SomeIsAnimal’
11:34:19 <tomsmeding> s/runMessage msg internal/runMessage msg (SomeIsAnimal internal)/ ?
11:34:37 <tomsmeding> if runMessage takes a wrapped animal, and you have an unwrapped one of an unknown type, just wrap it
11:35:15 <tomsmeding> it's actually sort-of similar to object-oriented programming, where you upcast a derived class pointer to a superclass pointer because the function you're calling expects that
11:35:25 <tomsmeding> but not really
11:35:28 <halogenandtoast> eh? class RunMessage a where runMessage :: (MonadIO m) => Message -> a -> ReaderT GameInternal m a
11:35:49 <tomsmeding> I think at this point I'd like some code :p
11:35:59 <tomsmeding> not sure what Message is
11:36:17 <halogenandtoast> alright one moment
11:36:46 <halogenandtoast> tomsmeding: https://gist.github.com/halogenandtoast/2d4d7981d2e33bfdd5fac90ba0f4e7a8
11:37:04 <tomsmeding> you say you have a lot of language extensions? 8 is nothing
11:37:05 <halogenandtoast> That's the full app currently
11:37:46 <tomsmeding> RolandBanks
11:37:56 <tomsmeding> ah there's my existential type
11:39:29 <halogenandtoast> also feel free to tell me the way I am writing this is completely terrible and I should just give up
11:39:40 <tomsmeding> um okay my compiler does not like that code in general
11:39:48 <tomsmeding> also where does Show come from :p
11:40:19 <halogenandtoast> Text.Show exports the instance
11:40:24 <tomsmeding> but you import it qualified!
11:40:29 <tomsmeding> so the Show class is not in scope
11:40:51 <tomsmeding> ah it comes from Relude
11:40:53 <tomsmeding> probably
11:40:53 <halogenandtoast> It is for me... (this is how relude said to do it, which also did not make sense to me, but it compiled and wors)
11:40:55 <halogenandtoast> *works
11:41:08 <tomsmeding> okay how many packages do I need :p
11:41:14 <halogenandtoast> let me update that code to show what I wanted to do
11:41:20 <halogenandtoast> I'll add the package.yaml as well
11:42:14 <halogenandtoast> Oh I have an idea what you were saying to do
11:44:19 <halogenandtoast> tomsmeding: updated the gist, it does not compile yet because of SomeIsInvestigator but here it is again: https://gist.github.com/halogenandtoast/2d4d7981d2e33bfdd5fac90ba0f4e7a8
11:44:37 <halogenandtoast> Lines 222-237 show what I am trying to go for
11:45:14 <tomsmeding> y u old ghc
11:46:57 <tomsmeding> oh that's apparently stack default if there's no stack.yaml
11:47:53 <halogenandtoast> yeah I am using resolver: lts-16.4
11:48:41 <tomsmeding> there we go ghcide eats it
11:51:32 <tomsmeding> halogenandtoast: where's `i` supposed to come from in `instance RunMessage RolandBanks`?
11:51:54 <tomsmeding> should that be `rolandBanks` by any chance?
11:52:15 <halogenandtoast> tomsmeding: yes, I updated the gist for that too
11:52:27 <halogenandtoast> to a compiling version that doesn't get to use RolandBanks
11:54:33 <tomsmeding> um, I literally add `data SomeIsInvestigator = forall inv. IsInvestigator inv => SomeIsInvestigator inv` to the latest version and it compiles for me
11:56:00 <halogenandtoast> tomsmeding: hmm I got > No instance for (Show SomeIsInvestigator)
11:56:09 <halogenandtoast> and then that lead down a rabbit hole
11:56:21 <tomsmeding> oh right you removed the code that triggered that error in your latest commit
11:56:21 <tomsmeding> :p
11:56:47 <halogenandtoast> Yeah, I wanted you to see roughtly what I was trying to accomplish
11:56:51 <halogenandtoast> *roughly
11:57:16 <tomsmeding> are all investigators Show?
11:57:45 <tomsmeding> in this code it seems that's true
11:57:59 <halogenandtoast> They will be yes
11:58:00 <tomsmeding> `data SomeIsInvestigator = forall inv. (Show inv, IsInvestigator inv) => SomeIsInvestigator inv ; deriving instance Show SomeIsInvestigator`
11:58:05 <tomsmeding> with LANGUAGE StandaloneDeriving
11:59:49 <ezzieyguywuf> if my package requires a resource, i.e. "SomeResource.ext", I understand how to add it to the cabal config, but how do I "find" it in my program? i.e. do I just use a relative path? how does this work when the package is ultimately installed?
12:03:17 <sm[m]> There’s a function in the Cabal library you call to get the path
12:03:17 <halogenandtoast> tomsmeding: I think I got it compiling... about to see if it works correctly
12:05:28 <halogenandtoast> tomsmeding: It does indeed work. Thanks for all your help.
12:05:31 <sm[m]> actually not in the library, in a special module that’s generated for you. https://cabal.readthedocs.io/en/latest/cabal-package.html#accessing-data-files-from-package-code
12:05:36 <tomsmeding> halogenandtoast: :D
12:05:47 <halogenandtoast> tomsmeding: That is such a weird pattern though
12:05:54 <halogenandtoast> :p
12:06:38 <halogenandtoast> I mean I chose the pattern. I'm just now having second thoughts
12:07:07 <halogenandtoast> I'm going to have probably around 1000+ newtype wrappers each with their own instances of RunMessage.
12:07:09 * tomsmeding . o O ( nobody said it was easy... 🎶 )
12:07:09 <sm[m]> ezzieyguywuf: this will work when your package is installed with cabal or stack, not if you’re shipping binaries
12:09:20 <tomsmeding> halogenandtoast: I dunno, maybe that's what you get for trying to do OOP in Haskell? Perhaps I've always given up before this point :p
12:09:48 <sm[m]> (For example, pandoc relies on this and can breaks if you clean out your .cabal files)
12:10:13 <halogenandtoast> tomsmeding: I'd prefer not to do OOP I guess, but I am trying to implement a card game, and most cards of the same type have the same core behaviors, but they all usually have something unique
12:10:37 <tomsmeding> halogenandtoast: recently I've been working on Accelerate, where you have beauties like this file and I've been forced to learn these type tricks :p https://github.com/AccelerateHS/accelerate/blob/master/src/Data/Array/Accelerate/AST.hs
12:11:20 <justsomeguy> halogenandtoast: Maybe you should make a Card type class?
12:12:23 <halogenandtoast> justsomeguy: maybe, but the internal structure of cards are all the same, only the behavior is different
12:12:31 <halogenandtoast> *cards of the same type that is.
12:13:00 <halogenandtoast> tomsmeding: I have no idea what the goal of that code is, and definitely can not tell by reading it.
12:13:01 <EvanR> behaviors that can be collected, mixed and matched, replaced at runtime... first class functions
12:13:18 <tomsmeding> halogenandtoast: that was the point :p
12:13:33 <EvanR> record-of-functions style OOP
12:13:37 <halogenandtoast> EvanR: yeah but the behaviors are responding to events, which it needs to pattern match against
12:14:00 <EvanR> event handler oriented programming, yeah now you changed gears
12:14:01 <halogenandtoast> Before I tried to do this with events I had the record of functions approach
12:14:14 <EvanR> OOP doesn't react well to that either
12:14:35 <EvanR> you can design a DSL for event selection
12:15:58 <ezzieyguywuf> sm[m]: thanks for the helo. is there a way to do this when shipping binaries?
12:16:27 <halogenandtoast> I mean I'd be happy to use the most functionally-functastic-functional version of this possible, I just don't know what that is
12:16:43 <sm[m]> ezzieyguywuf: I think one good way is to embed the files with file-embed
12:16:47 <halogenandtoast> Also just for conformation EvanR, you aren't the Evan R. I know right?
12:16:52 <halogenandtoast> *confirmation
12:16:56 <EvanR> um
12:17:17 <halogenandtoast> Are you in with the pig?
12:17:30 <ezzieyguywuf> sm[m]: i'll check out file-embed thanks again
12:17:39 <EvanR> o_O guess you got the wrong guy
12:18:14 <halogenandtoast> Fairly likely. Just thought I'd ask.
12:18:33 <halogenandtoast> I can only imagine there are so many Evan R.'s in the Haskell world.
12:18:36 <EvanR> a very basic data type to support event filtering is... wait for it... Maybe e, where e is the payload type in question
12:19:06 <tomsmeding> too basic too few language extensions
12:19:17 <EvanR> lol
12:19:39 <halogenandtoast> I can't unwind my brain far enough to see what you mean by that
12:19:43 <ezzieyguywuf> hrm, file-embed wouldn't work so great for, say, png files would it?
12:19:52 <EvanR> if multiple events may happen simultaneously, [e]
12:20:01 <halogenandtoast> They may not
12:20:10 <halogenandtoast> There are no threads, and I need to persist between HTTP calls
12:20:48 <halogenandtoast> But yeah [e] to sequentially queue events
12:21:43 <EvanR> em, well you said events can't happen simultaneously. So at any given time, nothing is happening or something is happening
12:21:44 <halogenandtoast> This is getting hyperspecific, but I need events to allow for interrupts in processing the list of events, wait for user input, and then resume
12:21:45 <sm[m]> ezzieyguywuf: why not
12:22:12 * hackage clash-prelude 1.2.3 - CAES Language for Synchronous Hardware - Prelude library  https://hackage.haskell.org/package/clash-prelude-1.2.3 (QBayLogic)
12:22:16 <EvanR> ok yeah now it's jumped the shark, and whiz bang reactive java won't even make that simple
12:22:44 <sm[m]> it’s a hassle if you have to pass the file to something that can only read from the filesystem. Then you might have to write it as a temp file
12:22:45 <halogenandtoast> EvanR: I guess that's good? I wouldn't have Java'd this even if it did.
12:23:01 <EvanR> interrupting a process to get user input then resume, are you sure you don't want threads
12:23:12 * hackage clash-ghc 1.2.3, clash-lib 1.2.3 (QBayLogic): https://qbin.io/steel-gross-p0q8
12:23:18 <halogenandtoast> EvanR: It's going over HTTP, so I need it to be stateless
12:23:29 <halogenandtoast> which means I need to be able to persist the whole "state" into a database
12:23:35 <halogenandtoast> and re-saturate it on the next request
12:23:47 <tomsmeding> you've got some stringent requirements there
12:23:57 <EvanR> the plot thickens
12:24:10 <tomsmeding> resumable computation is something you can model, by storing where you are in what computation, but it's annoying in almost every language
12:24:37 <tomsmeding> basically, if you need user input, you do the dump thing and store in your state (database?) that you're currently in that operation and waiting for user input
12:24:43 <tomsmeding> s/dump/dumb/
12:24:44 <koz_> It's not also easy to database up.
12:24:56 <koz_> Like, not impossible, but I wouldn't really wanna try it. :P
12:25:02 <halogenandtoast> Here is a gif of what I am doing... https://i.imgur.com/27NFCik.gif
12:25:43 <tomsmeding> few people have said that in a haskell discussion
12:26:31 <EvanR> the interactivity and responsiveness of HTTP+database with the purity and statelessness of a video game. Should work
12:26:39 <ezzieyguywuf> sm[m]: yea i see, it wouldbimport the bytestring or w/e
12:26:57 <ezzieyguywuf> i though templatehaskell was to be avkided
12:26:59 <tomsmeding> well you basically want a finite state machine for resumable computation
12:27:01 <ezzieyguywuf> *avoided
12:27:10 <halogenandtoast> that gif is from the entirely not-event-based approach I started with, but interactions are going to get a lot more complex
12:27:51 <dsal> ezzieyguywuf: template haskell can't be avoided.
12:27:54 <halogenandtoast> The code I posted actually demonstrates interrupting the event queue process
12:28:04 <EvanR> i've seen a similar effect. I start an interactive responsive haskell app, and it works to an extent, then you see a tidal wave of complexity approaching when things get serious
12:28:20 <sm[m]> ezzieyguywuf: blanket rules are to be avoided :)
12:28:32 <dsal> ezzieyguywuf: (it can, but going out of your way to avoid TH is just going to make things harder -- sometimes it's the best tool for the job)
12:28:52 <halogenandtoast> https://gist.github.com/halogenandtoast/2d4d7981d2e33bfdd5fac90ba0f4e7a8#file-app-hs-L296-L300 has me converting the game to an external format, running the interaction, and converting back to an internal format
12:29:22 <ezzieyguywuf> hrm, fair enough
12:29:27 <halogenandtoast> The non console version would just need to create the IORef on each request
12:30:35 <halogenandtoast> which is what `toInternalGame` instead of `toInternalGame'` would do
12:30:51 <EvanR> web makes simple programs hard
12:31:21 <halogenandtoast> EvanR: yeah
12:31:28 <sm[m]> yesod provides special support for this also, ezzieyguywuf
12:32:03 <ezzieyguywuf> isn't yesod for like web stuff?
12:32:18 <halogenandtoast> EvanR: I spent a lot of time thinking, this is the solution to X, and there is plenty of tools in Haskell that will let me do this (looking at you Continuation Monad), and then realizing I had no way to persist that to a db
12:34:15 <EvanR> correct
12:35:04 <EvanR> you can implement a resumable free monad thing, but you can't persist functions
12:35:31 <EvanR> you can implement a new programming language and make it fast using abstract higher order syntax
12:35:42 <EvanR> but seriously... for this?
12:35:57 <sm[m]> ezzieyguywuf: yes, and you might be shipping a yesod app as a binary. Just thought I’d mention it in case you were
12:36:25 <ezzieyguywuf> sm[m]: thabks for the tip
12:36:54 <halogenandtoast> EvanR: so I can do a non event based approach which means every core type has to have a record-of-functions for every possible interaction
12:36:56 <EvanR> LambdaMOO which had persistent server, and the ability for code to wait for a user's response, did it by storing compiled code in it's database
12:37:12 <halogenandtoast> and then I have to make sure to check everything in the game against that interaction
12:37:14 <ezzieyguywuf> file-embed seems very thorough and well thought out
12:37:32 <ezzieyguywuf> light on dependencies too
12:37:42 <halogenandtoast> Which is what I do currently.
12:37:43 <sm[m]> https://github.com/simonmichael/hledger/blob/master/hledger/Hledger/Cli/DocFiles.hs#L36 an example
12:38:19 <EvanR> if the player can "interact" with all these objects it totally makes sense to give all the objects implementations for the interactions
12:38:21 <halogenandtoast> I was just concerned it would balloon out of control very quickly (once I got more than a few cards implemented) and I wanted to consider any other ways of handling it
12:39:09 <EvanR> nod
12:39:59 <EvanR> that ballooning is why visual basic was invented. Someone identified repetitative boilerplate as being the biggest time waster and the easiest to optimize
12:40:35 <halogenandtoast> It's sort of different than that, an example would be like this: You are at a location in the game that has a clue, you are also engaged with an enemy, it is the enemy phase, the enemy attacks you, the flow has to be interrupted for you to decide what to do with the damage, you decide to place damage on a card you control which lets you do one damage back to the enemy which kills it, your
12:40:37 <halogenandtoast> character has a response ability that says when you defeat an enemy you can get a clue from your location, so you have to interrupt again to ask the player if they want to do this.
12:40:39 <EvanR> but it all amounted to doing boilerplate for you
12:40:46 <EvanR> and this is still how android etc work
12:41:26 <halogenandtoast> Once they've responded, you continue with the rest of the enemy phase.
12:41:54 <EvanR> well your player plays by making moves. Players can make moves at any point, even if it's not their turn, because they could for example quit entirely. The fact that sometimes it's "their turn" and waiting for their move isn't a special interruption, in my opinion
12:42:21 <EvanR> The game is always in some state, only sometimes a particular player's "move" will have an effect
12:42:55 <EvanR> it may require breaking your game down further and doing less in each handler
12:43:09 <EvanR> but then you can persist the state
12:58:42 <maerwald> ok, so how do I depend on a newer text version again?
13:03:25 <maerwald> this is confusing... text-1.2.3.2 builds with ghc-8.10.1, but text-1.2.4.0 does not
13:03:36 <maerwald> someone messed up
13:04:12 <tomsmeding> was that not a thing with the recent ghc release, where the ghc maintainers decided to publish a new text version?
13:04:19 <tomsmeding> or was that another time
13:05:08 <koz_> maerwald: Yeah, known problem.
13:05:12 <koz_> Silly, I agree.
13:05:27 <tomsmeding> https://hackage.haskell.org/package/text-1.2.3.2/changelog
13:05:29 <koz_> (I actually had to help someone with this very thing in recent memory)
13:10:25 <ezzieyguywuf> sm[m]: mthanks for the example. incidentally I've been meaning to check out hledger vs beancount, you know, since I'm a haskeller now
13:11:38 <sm[m]> patches welcome ezzieyguywuf !
13:11:57 <maerwald> koz_: yeah... I don't think this is how PVP works
13:12:15 <koz_> maerwald: No, but that's what happens when things are done 'by convention'.
13:12:25 <koz_> (aka 'no compiler to yell at you until you do it properly')
13:12:42 <ezzieyguywuf> sm[m]: I'll keep that in mind!
13:13:00 <ezzieyguywuf> does hledger have something like fava (for beancount): i.e., i nice web interface that shows pretyt graphs?
13:13:08 <maerwald> most upper bounds are trash, I'm using allow-newer all over the place
13:13:54 <sm[m]> hledger-web, or convert with ledger2beancount this
13:15:55 <sm[m]> s/this/to fava/
13:16:19 <ezzieyguywuf> i see.
13:31:59 <dminuoso> dcoutts: ping
13:44:12 * hackage servant-seo 0.1.0 - Generate Robots.txt and Sitemap.xml specification for your servant API.  https://hackage.haskell.org/package/servant-seo-0.1.0 (swamp_agr)
13:52:41 * hackage dobutokO-effects 0.8.0.0 - A library to deal with SoX effects and possibilities  https://hackage.haskell.org/package/dobutokO-effects-0.8.0.0 (OleksandrZhabenko)
15:50:42 * hackage interval-functor 0.0.0.0 - Intervals of functors.  https://hackage.haskell.org/package/interval-functor-0.0.0.0 (robrix)
16:15:34 <slack1256> How would you guys proceed to test the integration of a haskell app with dbus?
16:16:28 <slack1256> I have tested by hand that my module produces good results, but I have no idea on how to translate that to a test. HUnit helps? Should I launch a private DBus instance for the test separated by linux namespaces?
16:19:28 <slack1256> The setup for reproducibility is killing me.
17:12:12 * hackage monadic-recursion-schemes 0.1.12.0 - Recursion Schemes for Monadic version.  https://hackage.haskell.org/package/monadic-recursion-schemes-0.1.12.0 (KatsutoshiItoh)
17:36:52 <fog> i have a large computation, and it keeps crashing because it runs out of memory
17:37:20 <fog> its iterative, and each iteration takes the same amount of time to compute 
17:38:18 <fog> it prints an output to the screen at each iteration, and proceeds smoothly, occasionally slowing down for some reason
17:38:48 <fog> sometimes it slows down so much at some iteration that it crashes
17:39:31 <fog> why would it be doing this? is it possibly the garbage collector kicking in that causes the occasional jamming?
17:40:12 * hackage aop-prelude 0.4.0.0 - prelude for Algebra of Programming  https://hackage.haskell.org/package/aop-prelude-0.4.0.0 (KatsutoshiItoh)
17:40:24 <fog> after it crashes i have to restart it, and then it runs smoothly for a while, until crashing again
17:40:32 <gentauro> I'm having some issue defining the `instance` of a `Foldable Tree List` -> https://pastebin.ubuntu.com/p/JKcyK96TGY/
17:41:58 <fog> gentaro: shouldnt undefined be a recursive call?
17:42:29 <fog> like, you could use foldMap (foldMap f)
17:42:57 <fog> :t \f -> foldMap (foldMap f)
17:42:58 <lambdabot> (Monoid m, Foldable t1, Foldable t2) => (a -> m) -> t1 (t2 a) -> m
17:43:00 <gentauro> fog: I tried that
17:43:15 <gentauro> but, I didn't add enough parenthesis, aparently
17:43:19 <gentauro> thx for the help
17:43:35 <fog> no worries!
17:43:37 * gentauro when it's 02:43, code seem not to work as expected
17:44:16 <sm[m]> fog: have you tried: adding a load of trace statements ? That can give insight about where it’s taking long
17:44:40 <gentauro> fog: my assumption was that cos `[]` (Data.List has an instance of foldable)
17:44:57 <gentauro> but apparently parenthesis needs to be added (long live the LISP syntax)
17:44:58 <gentauro> :)
17:45:03 <fog> wouldnt they only show if there was an actual uneven computational burden?
17:45:16 <fog> each itteration certainly takes the same amount of time
17:45:18 <monochrom> "occasionally slow down" looks like GC
17:45:19 <sm[m]> secondly you could profile it, that might show you something being called too many times or taking too much resource
17:45:20 <fog> less than a secon
17:46:03 <monochrom> Then again, if you already know that space grows wild, slow GC is expected
17:46:05 <fog> there is no difference which could lead to a longer computation time, and certainly nothing that could make it crash
17:46:22 <fog> monochrom: GC seems like the only explanation
17:46:53 <fog> i dont mind it having to slow down to do GC, but it running out of memory, crashing, and requiering a restart, is not ok for production code
17:47:10 <fog> is there any way i can get it to do the GC after each iteration? 
17:47:29 <fog> there are no reference to the computation after its result is written to a file
17:47:49 <fog> i guess there is somewhere it should be strict
17:49:17 <fog> its using this; https://pastebin.com/raw/FQQ8nb0Q
17:49:26 <fog> foldIO :: Monad m => (t -> m ()) -> [t] -> m ()
17:49:49 <monochrom> Hunting down unwanted space growth and fixing it is a full-time paid job.
17:49:58 <fog> the [t] is very quick to compute since its just and enumFromTo which isnt too long
17:50:40 <fog> and the t -> m (), also, is very cheap, and has a encodeFile writing the results to binary 
17:51:27 <fog> does this seem like it could be doing something lazy? like trying to fuse through the enumFromTo or something?
17:51:56 <fog> im not to sure about adding strictness ! annotations in the patterns
17:53:13 <fog> is there a way to change the definition of foldIO to do that?
17:53:51 <fog> and would that cause the garbage collector to occur at each itteration?
17:54:07 <fog> i figure that would save it from waiting some random length of time before it kicks in
17:54:20 <fog> and ending up with so much work to do that causes it to crash
17:56:05 <fog> i guess i need some way of telling it that the values from the list, and the computations over it, are not referenced again
17:56:24 <fog> but it seems to be able to determine that, or it wouldnt GC at all...
17:56:51 <fog> and it clearly does, since it stops for a while every now and then, but manages to continue most of the time until it finally crashes
17:57:41 <fog> monochrom: its not a complex piece of code at all, its not like there is much that could be happening 
17:58:31 <fog> maybe its the use of >> in; foldIO f (x:xs) = f x >> foldIO f xs
17:58:49 <Float> kiosa
17:59:09 <sm[m]> profile or trace it
17:59:35 <fog> i dont know how, and i dont understand why that would help
18:00:09 <sm[m]> Or, simpler yet, eliminate code until it stops doing that, and try to understand why
18:00:41 <fog> am i wrong in thinking that it could only tell me if there was a computation that gets expensive for some reason, and i already know that isnt happening
18:01:09 <sm[m]> Well if you’d like to learn how to do any of those things, we can help. Sorry, got to go right now though
18:01:59 <fog> from what i understand, those are not the way to tackle this. i thought that strictness and GC was the problem, and i would like to learn enough about those to fix this problem
18:02:23 <fog> sm[m] thanks for the suggestion though
18:03:38 <fog> at some point im sure i should learn enough about those techniques to understand if they can be useful for debuging certain problems, like if a computation hangs from hitting a convergence loop or something
18:04:37 <fog> but since these computations all take the same amount of time for certain, and this is about 1/10th of a second, im sure thats not why its crashing
18:16:36 <fog> hmm, actually you could be right
18:16:54 <fog> https://pastebin.com/raw/LdDDeaeB
18:17:10 <fog> that code, i thought would reproduce the error, but it runs smoothly without crashing
18:18:33 <fog> so, how do i "profile or trace it" ?
18:19:23 <fog> and would this be able to tell where was something that should be strictly evaluated?
18:19:41 <fog> and, is that strict evaluation likely to solve the problem as described?
18:30:40 <fog> aha!
18:30:45 <fog> i have reproduced the error
18:31:06 <fog> https://pastebin.com/raw/gfL3ikQx
18:32:18 <fog> any ideas?
18:32:24 <sm[m]> fog, tracing is the easier. import Debug.Trace, and insert trace "1", trace "2" before things
18:34:30 <fog> sm[m] that just intersperses the output with "1"
18:34:50 <fog> how could that be helpful?
18:35:30 <sm[m]> fog, sometimes it reveals which things are expensive, which can be surprising. It may not help in this particular case
18:36:14 <sm[m]> next easy thing is compile it, with a smaller limit such as 2^8 so it'll complete, and run it with +RTS -s
18:36:58 <fog> hmm, with this; https://pastebin.com/raw/tj4G3yDq
18:37:11 <fog> it hangs with "1" displayed, but not "2"
18:37:50 <fog> sm[m] the whole point of using such a large number was to reproduce the hanging
18:38:12 <fog> its just an example to show that each of those calculations should take the same amount of time
18:38:12 <sm[m]> that will show some summary statistics which can give clues
18:38:32 <sm[m]> ironically running and killing your script a few times gave me a runaway ghc that brought my machine to its knees
18:39:04 <fog> to be clear, it runs many itterations, printing "1" and "2" to the screen very many times before hanging occasionally, and eventually crashing
18:39:36 <fog> yes, you would have to close and reopen ghc
18:39:59 <fog> and then, probably, restart your machine after too many attempts to do what the interrupted gc cant. i guess...
18:40:00 <sm[m]> so when I run it to 256, it allocates 5G and is only 37% productive. So clearly whatever it's doing, it's doing it inefficiently :)
18:40:25 <sm[m]> are you compiling it, or running it in GHCI ?
18:40:38 <fog> ghci
18:41:01 <sm[m]> ok, that's important, the runtime characteristics can be very different
18:41:16 <fog> yeah, i meant you would have to close the ghci session
18:41:23 <fog> i dont mind if it runs slow
18:41:29 <fog> i just mind that it crashes 
18:41:57 <fog> the first attempt i pasted runs smoothly
18:42:10 <fog> there must be some reason this version crashes 
18:42:44 <fog> comparing; https://pastebin.com/raw/LdDDeaeB to https://pastebin.com/raw/tj4G3yDq
18:42:55 <sm[m]> using the elimination technique, it's quickly apparent that g is causing the slowdown
18:43:57 <fog> oh right, so it hits the trace "1" before trying to compute g
18:44:09 <fog> still, that should always take the same length of time
18:44:27 <fog> and it manages fine for many itterations, and there should be nothing that makes any itteration different
18:45:44 <sm[m]> it seems GHCI is really bad at losing track of ghc processes here, I keep having to kill them manually
18:47:23 <fog> do you think it could be that as it runs out of RAM, that it then struggles to compute g
18:48:11 <fog> i think the solution would be to force GC to occur after each stage - which i think might prevent this RAM usage 
18:49:02 <sm[m]> so (at least in the paste I'm working with) for each natural number, you're replicating 60m of them, taking the first 60k of those, and calling encodeFile which lazily serialises them to a file
18:49:39 <fog> here, use this version instead; https://pastebin.com/raw/L9FPakYw
18:49:53 <sm[m]> I'm sure someone will look at this and say immediately it's building up a bunch of thunks here and here. Try doing things more strictly
18:50:04 <fog> it takes allmost all the replications, and only writes the length to the binary file, and it crashes just the same
18:50:36 <sm[m]> take (2^16) . replicate (2^26)  <- it's taking 60k of 60 million
18:50:55 <fog> right, that was just arbitrary
18:50:56 <sm[m]> and a little experimentation will show reducing that 2^26 helps
18:51:09 <fog> the paste above shows differently
18:51:23 <fog> reducing it to 2^16+1 does not help
18:52:25 <fog> so, for each of the input list, it does a large but similar computation. the only thing that seems like it could be happening due to lazyness, is that until the GC kicks in, it stores all of the previous computations, which fills up the RAM
18:55:02 <sm[m]> yes, that's the kind of thing
18:55:24 <sm[m]> it's not the best time of day, but someone will come along sooner or later and explain this much better than I
18:55:32 <sm[m]> got to go.. good luck!
18:55:56 <fog> damn
18:55:59 <fog> its not that...
18:56:00 <fog> https://pastebin.com/raw/Q3aZdcXH
18:56:12 <fog> sm[m] thanks!
18:56:31 <sm[m]> watching it with htop or similar tool you can see it eating all memory
18:57:03 <fog> now it just keeps printing 256
18:57:28 <fog> :-/
18:57:39 <fog> until it crashes!!
19:11:51 <fog> ok, pretty sure this is a least sufficient reproduction of the problem;
19:11:52 <fog> https://pastebin.com/raw/U4XU4VFE
19:12:51 <fog> is there any way to get that to run smoothly?
19:13:08 <fog> with each iteration taking the same length of time in ghci
19:13:30 <MarcelineVQ> the word lazy is the alarm word when it comes to IO, commenting out   encodeFile (p ++ "\\" ++ show q) a  is sufficient to eliminate the problem, which means one should then be suspicious of it
19:13:52 <MarcelineVQ> making it more strict is also enough to reduce the exponential memory use  !_ <- encodeFile (p ++ "\\" ++ show q) a
19:14:14 <MarcelineVQ> ! is a BangPattern
19:15:07 <fog> yay! it works
19:15:08 <fog> https://pastebin.com/raw/fAuQ3Q47
19:15:15 <fog> thanks MarcelineVQ!
19:15:29 <MarcelineVQ> To clarify the alarm word lazy is found here   https://hackage.haskell.org/package/binary-0.10.0.0/docs/Data-Binary.html#v:encodeFile 
19:15:34 <MarcelineVQ> 'Lazily serialise a value to a file.'
19:16:12 <fog> i dont even know how that would be helpful!
19:16:50 <fog> well, this is good to know.
19:17:16 <fog> whenever using encodeFile, to use a bang pattern to force its evaluation
19:26:51 <fog> hmm, in my larger piece of code, it also needed a bang pattern in foldIO
19:27:39 <fog> ok! ciao
19:29:21 <dolio> That explanation doesn't really make any sense.
19:34:42 <dolio> 'Lazy output' basically has no meaning that requires 'alarm'. For instance, `writeFile` is using `withBinaryFile` internally, so if it were really waiting for you to force the unit value to actually write the file or something, the file would already be closed.
19:41:37 <dolio> The thing that's potentially lazy about that writing function is that it doesn't have to create the entire serialized form in memory before starting to write the file, which is presumably what is desired.
20:16:42 * hackage webkit2gtk3-javascriptcore 0.14.4.1 - JavaScriptCore FFI from webkitgtk  https://hackage.haskell.org/package/webkit2gtk3-javascriptcore-0.14.4.1 (HamishMackenzie)
20:25:01 <MarcelineVQ> I'd be happy to agree with that position except that the given code was eating all system memory then dying and making it stricter at encodeFile prevented that.
20:26:42 * hackage base16 0.3.0.0 - Fast RFC 4648-compliant Base16 encoding  https://hackage.haskell.org/package/base16-0.3.0.0 (topos)
20:39:45 <dolio> Okay, I just tested it myself. There's no difference in memory usage.
20:42:39 <MarcelineVQ> which it?
20:42:48 <dolio> https://pastebin.com/raw/U4XU4VFE
20:45:23 <MarcelineVQ> how odd. I can say that for that code (in ghci)    encodeFile "leak" (replicate (2^22) n)   will eat up all my system memory and   !_ <- encodeFile "leak" (replicate (2^22) n)  will not
20:45:59 <c_wraith> ghci doesn't mean much
21:17:05 <monochrom> Does encodeFile return something? Because "encodeFile ..." means "it <- encodeFile ...".
21:17:33 <monochrom> err nevermind
21:51:15 <int-e> monochrom: good point though
22:22:42 * hackage stable-marriage 0.2.0.0 - algorithms around stable marriage  https://hackage.haskell.org/package/stable-marriage-0.2.0.0 (KatsutoshiItoh)
22:26:03 <bewakes> Hi all, where is `ParseError` type Constructor found? I imported `Control.Monad.Except` but it still gives error.
22:27:34 <Waldkauz> parsec has that type
22:28:42 * hackage birds-of-paradise 0.2.0.0 - Birds of Paradise  https://hackage.haskell.org/package/birds-of-paradise-0.2.0.0 (KatsutoshiItoh)
22:29:20 <bewakes> Waldkauz: thanks!
22:32:22 <Graypup_> Hi! I'm updating a Yesod web project and along the way I found a bunch of instances of "missing MonadFail" errors indicating lack of error handling for pattern match failures, but one I have not figured out how to handle is one where there isn't even a pattern match!
22:33:25 <c_wraith> surprising things can be pattern matches.
22:33:38 <Graypup_> it's of the form `do f`
22:33:59 <Graypup_> how could that ever have a pattern match in it? I'm so confused
22:34:57 <c_wraith> > do { Just x <- pure "hello" ; return x } :: [String]
22:34:59 <lambdabot>  error:
22:34:59 <lambdabot>      • Couldn't match expected type ‘[Char]’
22:34:59 <lambdabot>                    with actual type ‘Maybe String’
22:35:12 * hackage magma 0.6.0.0 - magma is an algebraic structure.  https://hackage.haskell.org/package/magma-0.6.0.0 (KatsutoshiItoh)
22:35:39 <c_wraith> > do { Just x <- ["hello", "world"] ; return x }
22:35:41 <lambdabot>  error:
22:35:41 <lambdabot>      • Couldn't match expected type ‘[Char]’ with actual type ‘Maybe b’
22:35:41 <lambdabot>      • In the pattern: Just x
22:35:51 <c_wraith> well, you know.  it's a pattern match.  that happens to be wrong.
22:36:25 <c_wraith> > do { Just x <- [Nothing] ; return "hi" }
22:36:27 <lambdabot>  []
22:36:38 <c_wraith> there's an example of the MonadFail instance being used
22:37:55 <ja> Graypup_: is it literally just "do f"? :O
22:38:34 <Graypup_> ja,         do (checkCourseOwnership coursename) :: _
22:38:54 <Graypup_> where _ is `HandlerFor App ()'
22:39:34 <Graypup_> and ghc is giving me     * No instance for (Control.Monad.Fail.MonadFail (HandlerFor App))
22:39:34 <Graypup_>         arising from a use of `checkCourseOwnership'
22:39:50 <ja> Graypup_: maybe it would help if you put the error on http://dpaste.com or something?
22:41:51 <ja> ghc surely has a reason for thinking the fail is necessary? shouldn't that also be in the error message?
22:43:07 <Graypup_> ja, well, here's the source files (they're GPL) and the error: https://gist.github.com/lf-/45954a9659a310d88396502693bcc5cb
22:44:42 * hackage refined 0.5 - Refinement types with static and runtime checking  https://hackage.haskell.org/package/refined-0.5 (chessai)
22:45:21 <ja> Graypup_: you don't have any type annotation on your top level definition checkCourseOwnership
22:45:44 <ja> if you added them, maybe you'd probably get an error if you don't put MonadFail there
22:45:56 <ja> then you'd understand where it comes from
22:46:10 <Graypup_> that is true! I'm going to roll out the "it compiled before" defense :P but true! I should fix that, it was causing warnings [not my codebase so I didn't go do that stuff yet]
22:48:23 <ja> things were expected to break with MFP ;) i dunno what 'it compiled before' is supposed to mean, you can say that any time a backwards incompatible change is made
23:48:14 <Graypup_> back to my MonadFail refactoring! I have something like [a,b,c,d] <- someFunction. I am not in a monad which has MonadFail, so I need to handle this destructuring failing explicitly. How would I do that?
23:49:10 <ja> if you just wanna make the code compile with a new haskell, why not make it explicitly MonadFail?
23:49:28 <Graypup_> the monad is Yesod's, and also I fixed the rest of them :P
23:50:02 <Graypup_> oh wait I could just match it >_>
23:50:07 <Graypup_> with case
23:50:09 <Graypup_> and a default
23:50:16 <Graypup_> brain is tired clearly
23:51:25 <ja> but if you're just gonna do some default fail action everywhere that fails, maybe it'd be better to have a function for it so you don't need a billion case statements...
23:52:02 <ja> but in the end, you're just doing what MonadFail does no? you can write things without monad fail, or you can just use MonadFail for things that can fail, which is the idea
23:52:42 <ja> yesod is a general web framework, maybe some monad isn't monadfail anymore, but i am sure there must be some ergonomic way...
23:54:34 <ja> the naïve introduction of case on every single match that can fail doesn't seem like it has any advantages?
23:54:59 <ja> you'd need to indent the rest of the function too, right?
23:56:21 <FindTeh> Where would i go for wifi hacking tips? and questions?
23:57:59 <ja> FindTeh: maybe try #kismet?
23:58:18 <FindTeh> thanks
23:58:33 <FindTeh> * #kismet :Cannot send to nick/channel
23:59:12 <FindTeh> that sucks :/
