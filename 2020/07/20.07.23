01:09:39 <liiae> what if I say monad is a action? that would be proper?
01:10:27 <liiae> some functions can lift a function into an action, and extract a function from an action?
01:11:36 <Axman6> In DAML, the Monad class is called Action, but I don't agree it's a particularly good name. is list an action? Identity? what about Proxy?
01:13:31 <dminuoso> liiae: monad is an interface.
01:14:30 <Uniaika> Axman6: regarding "is list an action", I think I'd phrase it as "What is the Action associated with list"
01:14:39 <Uniaika> and this Action is list comprehension
01:14:55 <Uniaika> What is the Action associated with Identity -> well, I guess that one's easy :P
01:15:56 <int-e> a list represents a choice, which is an action
01:16:04 <int-e> identity represents a very limited choice ;)
01:16:13 <liiae> oh, monad is not an action, an action contain monad
01:16:24 <int-e> if you twist your mind enough, monad values are actions.
01:16:25 <liiae> Just 3 is an action, Maybe is the monad
01:16:36 <liiae> monadic value is action
01:17:16 <liiae> dminuoso: what it suppose to mean "interface"? interface in Java?
01:17:23 <dminuoso> liiae: Yes.
01:17:40 <dminuoso> Precisely that.
01:18:04 <dminuoso> Typeclasses are somewhat equivalent to interfaces in java, They form abstract methods that types can chose to implement/satisfy.
01:18:12 <int-e> Now, should the class of types whose values are actions be called Action? I don't have a strong opinion.
01:18:17 <dminuoso> Monad is precisely such an interface consisting of two methods.
01:18:44 <dminuoso> "a monad T" is just a handwaving way of saying "T conforms to the interface of Monad"
01:20:40 <liiae> dminuoso: interface in Java can't do generics constraint...
01:21:18 <dminuoso> liiae: Java's interface mechanism is less powerful, but you can compare them equally in terms of "what they are for"
01:21:21 <liiae> dminuoso: we can make an typeclass IS, and make Int and String as its instance, but how to do that in Java?
01:21:39 <liiae> enum class is not a good choice
01:22:34 <dminuoso> liiae: Like I said. It's less powerful in Java, for a custom MyString you can just write `public Class MyString implements IsString { ... }`
01:22:49 <liiae> I think ad-hoc polymorphism is the most need
01:23:02 <dminuoso> Well, you can write interface polymorphic code in Java.
01:23:17 <liiae> sometimes, I need declair a value has type X, which X only can be Int or String, not others
01:23:54 <liiae> dminuoso: how I could make Int and String as implement of an interface in Java?
01:24:12 <liiae> Int and String can inherite other class in Java
01:24:15 <liiae> can't
01:24:25 <[exa]> liiae: `Either String Int` ?
01:24:34 <liiae> [exa]: then it's enum class
01:24:50 <liiae> union, enum, sealed whatever you call it
01:24:57 <liiae> [exa]: Sum type?
01:25:07 <int-e> liiae: you'd have to go back to the definitions of Int and String, which you can't for builtin types. But that doesn't hurt the analogy between type classes and interfaces all that much.
01:25:09 <liiae> Java doesn't have Sum type also
01:25:22 <dminuoso> liiae: You cant because you can only implement an interface at its definition site.
01:25:29 <jtm> Hello, I'm trying to understand how most people internalize the recursion on more complex code. Here is the code: https://gist.github.com/jtm732/0fd37fcd10192740cd5356da96d8f5d2
01:25:36 <dminuoso> liiae: Like I said, its less powerful in Java - but you can consider it an ergonomic problem.
01:25:57 <dminuoso> (Dont focus too much about how to do all the haskell things exactly in some other language)
01:26:26 <dminuoso> Becuase eventually you'll notice you cant or its not a good idea. This is why languages have different properties, to allow you to do something you otherwise couldn't (as eloquently, or at all)
01:26:33 <liiae> dminuoso: what about higher kind? Java doesn't have that too, and Monad is a higher kind
01:26:41 <dminuoso> Indeed, Java cant do that either.
01:27:31 <liiae> dminuoso: so I wonder how to express Fix f in Java...
01:27:40 <liiae> or it can't
01:27:52 <dminuoso> Its beyond me how you keep nagging about Fix f in Java.
01:27:57 <dminuoso> Or why.
01:28:17 <int-e> jtm: well, match the equations with the specification... worry about termination separately.
01:29:02 <liiae> dminuoso: sorry, that do X in Y interest me...
01:29:14 <int-e> jtm: or, given such a definition without specification, imagine what it'll do for small inputs (here: lists up to length 2 or 3) to get an idea of what the semantics may be.
01:30:05 <liiae> dminuoso: I like haskell, but I can't use haskell in my work, I could learn something from haskell, and tranform it in other languages
01:31:02 <jtm> int-e: Using the input [1,2,3,4], I can see the output, I even can internalize how to get the first tuple in the list, but I can't seem to get beyond that without going too deep into the recursion, and even when I back up from the base case, I get lost on how things are being formed, I think mostly due to the usage in a list comprehension.
01:31:04 <int-e> jtm: And then there's pattern matching. This is a close variant of foo :: [a] -> ([a],[a]); foo [] = [([],[])]; foo (x:xs) = ([],xs) : [(x:ys, zs) | (ys, zs) <- foo xs)], or bar :: [a] -> [(a,[a])]; bar [] = []; bar (x:xs) = (x,xs) : [(y, x:zs) | (y,zs) <- bar xs].
01:31:49 <int-e> jtm: Well you need a better description of the output that isn't recursive.
01:32:43 <int-e> The name "split" is also highly suggestive byw.
01:32:43 <int-e> jtm: The idea being that with such a description, you know what `split xs` will return without worrying about the recursion.
01:33:00 <int-e> By which I mean the `split xs` inside the split (x:xs) case.
01:33:04 <jtm> int-e: It's from Hutton's book.
01:33:44 <jtm> Programming in Haskell
01:33:58 <int-e> Hmm that seems... irrelevant.
01:34:27 <jtm> I understand what it does, I see the output, but I can't seem to follow how he gets the output without getting lost.
01:34:48 <jtm> I only mention it because there are other nearby examples that I had trouble with in the book.
01:35:33 <int-e> jtm: so split [] = split [a] = [], split [a,b] = [([a],[b])], split [a,b,c] = [([a],[b,c]),([a,b],[c])]... what could split be doing, in words?
01:36:18 <jtm> One function has a map over a recursive call, which is even more complicated than doing it inside a list comprehension.
01:36:37 <jtm> Splitting the list into sublists?
01:37:01 <int-e> That's part of it.
01:38:05 <int-e> It's two sublists, but with that specification I'd expect  split [] = [([],[])], so there's another part missing.
01:38:57 <jtm> That's the entire code for that function.
01:39:58 <int-e> jtm: I'm not talking about the code, I'm talking about "ways to split the given list into two sublists", which is lacking one more word
01:40:40 <jtm> Uniqueness?
01:40:58 <int-e> The lists are non-empty.
01:41:18 <jtm> Yes, they are non-empty.
01:41:24 <int-e> So I'd think about the last equation (approximately) as <ways split (x:xs) into two nonempty sublists, as a list> = ([x], xs) : [(x:ls,rs) | (ls,rs) <- <ways to split split xs into two nonempty sublists, as a list>]
01:41:59 <int-e> Where xs is known to be non-empty, because of the other two cases in the function definition.
01:42:53 <jtm> Understood.
01:43:57 <int-e> Note that it's no longer recursive, so it's much easier to reason about. But at this point, it's a conjecture... if the equation turns out to be false, then the semantics must be different.
01:44:21 <jtm> I think I'm just having trouble with the list comprehension recursively calling the function and those recursive calls resulting into other list comprehensions that are cons with a tuple.
01:44:26 <int-e> It's also glossing over details like the order of the resulting list elements, or the uniqueness you mentioned.
01:44:28 <[exa]> regarding the recursive reasoning, what about combining tails and inits?
01:47:48 <int-e> jtm: this is hard to do abstractly... each function is different, and some functions may just be incomprehensible (that is, their semantics doesn't condense down to a few words) and then things get really hard... or you may be looking at a bug. Context usually helps... you can see the name of the function and how it is used to get an idea of what its semantics should be.
01:47:53 <jtm> With (ls,rs) <- <ways to split split xs into two empty sublists, as a list> I'm trying to understand how it "accumulates" into the list that it can grab the tuples from.
01:50:29 <jtm> It seems that even tuples like ([2], [3,4]) are even created, but because they are taken out via the list comprehension they get the x cons to the fst of the tuple.
01:50:50 <int-e> Hmm, two ideas that may help... 1) [(x:ls, rs) | (ls, rs) <- split xs)] is sugar for map (\(ls, rs) -> (x:ls, rs)) (split xs). So if you understand `map`, you can also figure out the list comprehension. 2) You can /read/ list comprehensions like set comprehensions. [(x:ls, rs) | (ls, rs) <- split xs] is the list of all (x:ls, rs) such that (ls, rs) is an element of split xs.
01:52:17 <int-e> I simplified 1) quite a bit... desugaring list comprehensions is somewhat tricky in general.
01:53:21 <jtm> I understand, and yes it helps to do that. I think my issue tends to be going backwards from the base case, as we are dealing with propagating cons in this case.
01:55:03 <jtm> Key feature is to notice that the x:ls is pretty much added to the next level of recursions' ([x], xs) result.
01:56:19 <int-e> One thing to note is that [x] equals x : [], so cannot be written as x:ls where ls is nonempty.
01:56:52 <int-e> so that's why ([x],xs) ends up being a separate case.
01:57:25 <jtm> So if you have the input [1,2,3,4] there will be a tuple at some point that is: ([2], [3,4]) that gets handed up to a list comprehension (with other tuples) and it eventually has the 1 cons to the fst of the tuple.
01:58:03 <jtm> Yeah, it needs to always be non-empty.
01:59:59 <jtm> Each of those ([x], xs) get modified by all higher level list comprehensions with the deepest ones getting modified n times where n is the list length.
02:00:13 <jtm> Or n-1 times rather
02:01:40 <jtm> I think I understand, I just was having trouble with the whole propagation of the tuples up through the all the recursion and how their states looked, but just looking one depth in I can generalize it somewhat.
02:01:51 <jtm> Thank you :)
02:03:21 <jtm> I'll try to reword recursion more into English.
02:08:49 * hackage haskoin-store-data 0.36.0 - Data for Haskoin Store  https://hackage.haskell.org/package/haskoin-store-data-0.36.0 (jprupp)
02:09:48 * hackage haskoin-store 0.36.0 - Storage and index for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-store-0.36.0 (jprupp)
02:37:49 * hackage hascard 0.1.4.0 - A TUI for reviewing notes using 'flashcards' written with markdown-like syntax.  https://hackage.haskell.org/package/hascard-0.1.4.0 (Yvee1)
02:48:39 <dminuoso> 10:29:43       liiae | dminuoso: I like haskell, but I can't use haskell in my work, I could learn something from haskell, and tranform it in other languages
02:49:03 <dminuoso> liiae: In my opinion, try to learn Haskell the Haskell way properly, and dont think too much about "porting ideas to other languages" until later.
02:49:24 <merijn> dminuoso: Because it leads to depression? ;)
02:49:26 <dminuoso> liiae: Many of the valuable things are not about "how do I copy feature XYZ" but rather how Haskell trains you to approach code differently. :)
02:49:37 <dminuoso> merijn: Yes, that too.
02:50:05 <dminuoso> merijn: We're back to writing some JavaScript code, and we're dealing with large nested data that we need to deal with in a non-mutable fashion.
02:50:23 <dminuoso> partial.lenses is great, but gosh the experience is downright horrid without a functioning type system
02:50:59 <dminuoso> (Im quite glad I at least have partial.lenses, it's beyond me how JavaScript developers get by without using drugs)
02:51:44 <phadej> quite fine ;)
02:54:19 * hackage locators 0.3.0.2 - Human exchangable identifiers and locators  https://hackage.haskell.org/package/locators-0.3.0.2 (AndrewCowie)
02:56:50 * hackage chronologique 0.3.1.3 - Time to manipulate time  https://hackage.haskell.org/package/chronologique-0.3.1.3 (AndrewCowie)
03:06:11 <AWizzArd> Let’s say you want to load timeseries data from an sql db. You need to data for specific timezones today, because a day in Hamburg has a different utc time than a day in New York. Now you also want to compute a moving average over some data. What will you do? Solve all of this in pure SQL? Or do some processing in Haskell?
03:06:45 <merijn> AWizzArd: Future dates too or just past?
03:06:58 <AWizzArd> Let’s say just timestamps in the past.
03:07:25 <merijn> Then I'd probably just do a conversion to UTC inside the query and do any ordering on that
03:07:54 <merijn> AWizzArd: tbh, SQL is super underrated and people who like pure FP should love it more than they seem too :)
03:08:21 <AWizzArd> merijn: when I ask this in #postgres then everybody suggests doing this in sql.
03:09:03 <AWizzArd> But what about a moving average?
03:09:18 <merijn> AWizzArd: That's trivial in SQL
03:09:38 <merijn> AWizzArd: Have you not heard of our lord and saviour, the window function?
03:11:06 <AWizzArd> merijn: sure, wf ftw.
03:11:46 <merijn> AWizzArd: Should be easy to do moving average with those
03:18:47 <typetetris> With the `time` package, how do I get a timezone from a timezone string like 'CET' ?
03:20:32 <Arahael> typetetris: You might have some luck with a tz database.
03:20:58 <Arahael> typetetris: But generally, something like "CET" isn't enough for a specific timezone offset.
03:21:19 <typetetris> I just noticed, I have to handle summer time myself ... 
03:21:22 <typetetris> Urgs
03:21:47 <merijn> typetetris: There's a parser
03:22:02 <typetetris> merijn: Thanks.
03:22:04 <Arahael> Yes. Definitely avoid dealing with that yourself.
03:22:13 <merijn> typetetris: https://hackage.haskell.org/package/time-1.10/docs/Data-Time-Format.html
03:22:27 <merijn> parseTimeM and friends
03:22:33 <typetetris> I would prefer a library knowing about summer time and respecting it.
03:22:54 <Arahael> typetetris: What if summer time keeps changing?
03:23:02 <merijn> Arahael: CET *is* specific for a timezone *offset*
03:23:24 <merijn> Arahael: It is, however, not a timezone, which are geographically specified
03:23:34 <Arahael> merijn: Ah, I figured CET was just an example!  Good to know in the specific case of CET, though.
03:23:39 <merijn> I'm not sure if time supports geographic specification
03:23:51 <Arahael> Well, I tend to use AEST, myself.
03:24:07 <merijn> Arahael: You have CET and CEST which are separate offsets that occur at different times in the same timezone
03:24:32 <merijn> Also, since we're talking timezones, let us all repeat the mantra of dates and times
03:24:40 <merijn> "I will never store future dates as UTC"
03:25:01 <typetetris> I will never store future dates as UTC
03:25:03 <typetetris> :)
03:25:25 <typetetris> Still need to convert a given point in local time (might be a summer time) to utc ..
03:25:36 <Arahael> merijn: I never thought of that, but that does sound like a very sensible mantra.  I tried doing that for some calendars, and realised that I just didn't have the neccessary data for the conversion.
03:26:20 <merijn> typetetris: Comparing different timezone datetime requires going through UTC, but you should delay the UTC conversion until the check, since you cannot store future dates/times as UTC
03:26:43 <merijn> Arahael: No one ever thinks of that, tbh :p
03:26:57 <merijn> Arahael: That's why so many people do dumb things like "always store dates/times as UTC"
03:28:15 <typetetris> okay, correct term is daylight saving time.
03:28:51 <merijn> anyway, lunch!
03:29:24 <typetetris> keck, the dst varies depending on the year ... oh nmy
03:30:54 <Arahael> merijn: What I struggle with, is telling testers that no, they can't simply change the phone's clock to test future time events when testing the application.
03:31:39 <Arahael> merijn: I tend to have to explicitly state that I don't support time travellers using my applications :(
03:31:46 <Arahael> (Nobody ever seems to understand)
03:32:57 <merijn> typetetris: It's much worse than that
03:33:01 <maerwald> That's not inclusive
03:33:16 <merijn> typetetris: One year, Libya decided to skip DST 2 days before it was supposed to start
03:33:27 <Arahael> Pfft. That's only 2 days.
03:33:40 <merijn> typetetris: Some countries have skipped days (gone from December 29 to December 31)
03:33:49 <Arahael> Australia decided to have DST like, several weeks early, during the last olympics or somethig like that.
04:10:45 <timCF> Hi guys! Any `http-client` library users there? I have a question about this function https://hackage.haskell.org/package/http-client-0.7.1/docs/Network-HTTP-Client.html#v:newManager - in docs they are saying that `Manager` is supposed to be reused. Does it mean that it's good to create just one Manager for all application? Or it's still better to
04:10:46 <timCF> create new Manager per request to be more pure?
04:11:50 <fog> how do i abstract over "type level boundaries" ?
04:12:22 <hpc> timCF: the docs make it sound like it's for performance reasons
04:12:23 <fog> normally when several alternative equivalent implementations are available, the class system can be used 
04:12:53 <fog> but when there are several different versions of type level parametrisations 
04:13:03 <fog> how can this be expressed?
04:13:05 <hpc> unless you need different settings for different requests, just reuse it
04:13:23 <timCF> hpc cool, thanks!
04:14:51 <Arahael> I assume that reusing the same manager might also reuse the same connection.
04:15:00 <Arahael> Which makes things *much* faster, in the usual case.
04:15:19 * hackage haskoin-store-data 0.36.2 - Data for Haskoin Store  https://hackage.haskell.org/package/haskoin-store-data-0.36.2 (jprupp)
04:16:19 * hackage haskoin-store 0.36.2 - Storage and index for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-store-0.36.2 (jprupp)
04:16:39 <fog> for example, there could be many implementations of matricies
04:16:54 <fog> but, there should be a common "IsSquare" type family
04:17:09 <fog> which can operate over these various different versions
04:17:40 <fog> but really, you would want that type family to be associated to a class with an IsMatrix constraint 
04:17:51 <lortabac> fog: can you give an example of two implementations you want to abstract over?
04:18:26 <fog> http://hackage.haskell.org/package/tensor-safe https://hackage.haskell.org/package/tensors https://hackage.haskell.org/package/tensor https://hackage.haskell.org/package/easytensor
04:18:52 <fog> they all have the same concept of "matching up edge lengths"
04:19:25 <fog> to make type safe matrix-vector multiplication, and more generally, tensor index summation/contraction 
04:19:35 <lortabac> what exactly you want to abstract over?
04:19:45 <fog> type level things
04:19:54 <fog> like, the shape of the tensors
04:20:06 <fog> i get how to do it at value level, using classes
04:20:30 <lortabac> can you try to come up with a concrete example?
04:20:58 <fog> but i think its not as easy to do it at type level, so instead of reasonable abstractions we end up with a myriad of what really should just be different instances, but that cannot fit into a common representation, despite all doing the same thing
04:21:17 <fog> lortabac: how is tensor edge length matching not concrete? 
04:21:48 <lortabac> "tensor edge length matching" is not Haskell
04:21:52 <fog> the libraries that allow for type safe tensor composition will all satisfy this abstraction
04:22:49 <fog> im not able to complete the square of the difference between "a concrete example" and "its not haskell"
04:23:31 <fog> i dont care about being nudged towards something by statements that are plainly unhelpful. ill try again later
04:24:07 <lortabac> I'm just trying to understand
04:24:46 <lortabac> it would be easier with an example of two signatures you would like to abstract over
04:25:24 <lortabac> oh nvm they quit
04:41:30 <fog> but the question isnt, "what does this abstraction consist of", its "how can such an abstraction be expressed in syntax" 
04:41:49 <fog> actually, its even worse, as neither is clear
04:42:09 <fog> its not even as if i would know what properties tensors *should* satisfy
04:42:11 <Cale> Write the repetitive code, it'll be clearer to everyone what to do about it once that exists.
04:42:24 <fog> im explaining why i cant
04:42:56 <fog> i have a double problem, i cant write type level classes, and i wouldnt know what i was trying to use them to express either
04:43:19 <fog> actually, if anything, the syntax question is less problematic, i think you just use type families with extra parameters for the kinds
04:43:49 <Cale> You're writing a program to compute something, right? Surely there's a way to compute it which involves no abstractions at all, or at least none which you don't already understand how to apply.
04:43:58 <fog> so, maybe i asked the wrong half of that twofold question, and then got confused about the response. i appologise
04:44:33 <Cale> So start by writing that program, and then figure out what made it tedious or error prone to write, and then you'll have a good handle on what to abstract.
04:44:53 <fog> basically "how do i write type safe tensors" and then, "no, not just one implementation, what abstraction should they all satisfy" and thats more confusing because its almost a type level class, which is i guess, why such an abstraction doesnt exist
04:45:44 <fog> i think im actually struggling more to think about the abstraction itself, about what properties it should consist of, because im not really very adept with this type-level-classes style using kind parametrised type families
04:46:26 <fog> Cale: the problem is, by the time i had done that, there would be no question left. i cant do that, and im asking for help
04:46:47 <Cale> I don't understand why not?
04:46:48 <fog> its as if the answer is "you can do that, go on"
04:47:11 <fog> Cale: me neither! but iv given my best guess 
04:48:31 <fog> if i *could* write 2 type-safe-tensor implementations, in order to abstract over them, or even one, i would have had to have understood what properties it should safisfy to begin with, and i would have the "class". so it seems circular to surgest to just, "do that"
04:48:52 <Cale> If the code for the thing you're trying to write is too hard, maybe start with a smaller goal for which you do know how to write the concrete running code. Abstractions are for when you have n of something already and you're getting tired of writing the same things over and over.
04:49:10 <Cale> Maybe start with not-type-safe tensors
04:49:18 <Cale> Those are pretty easy to deal with
04:49:37 <fog> i can think of many things which are not type-safe-tensors
04:49:51 <fog> im not sure thats the best approach either...
04:50:09 <fog> the closest thing i could think of was "this is a square matrix"
04:50:22 <fog> any implementation should be able to support that
04:50:38 <Cale> I mean a tensor implementation which doesn't worry about compatibility of tensors at compile time
04:50:41 <fog> its not an exhaustive set of qualities that would ensure the functionality desired of tensors
04:50:52 <Cale> You can just use arrays and do size checks at runtime
04:51:22 <fog> Cale: again, thats just not a good idea. whatever runtime checks were to be performed, would make the type level version obvious
04:51:33 <Cale> Or, well, figure out the actual sizes of tensors you use and make types for those specific sizes
04:51:33 <fog> its not changing the problem
04:51:51 <Cale> It wouldn't make the type level version obvious though
04:51:59 <Cale> Not necessarily
04:52:09 <fog> Cale: right, like using tuples or lengthed lists for 3vecs or something - then there would be 2 sort-of implementations
04:52:15 <Cale> Putting that kind of information at the type level isn't something I even recommend in Haskell
04:52:34 <Cale> If you put numbers at the type level, it won't be long before you want arithmetic, and then things start becoming painful
04:52:38 <fog> its essential to get the type errors
04:52:58 <Arahael> Peano numbers, you mean?
04:53:04 <fog> arithmetic at type level is easy. classes over type level classes isnt
04:53:05 <merijn> fog: Sounds like you want "not Haskell"
04:53:07 <Cale> Haskell can do a little type level arithmetic, but it's pretty bad at it, and proving theorems to get things to typecheck is obnoxious.
04:53:18 <merijn> fog: It's easy, if you don't care about it working
04:53:28 <merijn> Arahael: There's a Nat kind, has been for years
04:53:39 <fog> these are irrelevancies  
04:53:39 <merijn> % :k 5
04:53:40 <yahb> merijn: GHC.Types.Nat
04:53:47 <Arahael> Ah, ok.  I thought most people use Coq or Adga if they wanted this?
04:53:53 <Cale> fog: It's not going to save you as much trouble as it causes, let's put it that way.
04:53:54 <fog> i thought so too
04:53:54 <merijn> Arahael: They do, because it sucks
04:54:01 <merijn> (in Haskell)
04:54:08 <merijn> There's a reason there's a Hasochism paper
04:54:20 <fog> why are you saying these things?
04:54:24 <merijn> And I'm honestly fairly skeptical about Dependent Haskell ever becoming a thing
04:54:37 <fog> oh, someone used a type family, lets attack them
04:54:42 <merijn> At least, "a thing that people will want to use outside of research"
04:55:03 <fog> i have linked several working implementations!
04:55:29 <HaskellStudents> Hey, is asking questions allowed here?
04:55:36 <fog> apparently not!
04:55:39 <merijn> HaskellStudents: Sure
04:55:46 <Cale> HaskellStudents: Yes, that's what the channel is for
04:56:06 <[exa]> HaskellStudents: feed us questions!!
04:56:08 <merijn> Cale: I thought the channel was for lowering my productivity and stopping me from taking over the world
04:56:11 <Cale> hah
04:56:52 <Athas> merijn: I can't decide whether I'm most skeptical about Dependent Haskell or Linear Haskell!
04:57:21 <HaskellStudents> I'm having trouble understanding this expression           zipWith (<=) <*> tail. I know what it does. <*> has the type f(a->b)-> f a -> f b. So what would f be in the mentioned case?
04:57:39 <Athas> HaskellStudents: f is the list monad here.
04:57:48 <Athas> So [a->b] -> [a] -> [b]
04:58:01 <hpc> not quite, i think f is (e ->) here
04:58:05 <merijn> Athas: We'll make our own Haskell! With checked exceptions, finer-grained low level control, and GPU support!
04:58:14 <hpc> tail's taking the spot of (f a) in that use of (<*>)
04:58:15 <merijn> In fact, forget the low level stuff and GPU support!
04:58:16 <Athas> Ah, you're right, I assumed 'tail' would be applied to something.
04:58:16 <hpc> :t tail
04:58:17 <lambdabot> [a] -> [a]
04:58:22 <HaskellStudents> but that does not make sence since zipWith (<=) is [Int] -> [Int] -> [Bool] not [Int -> Int->Bool]
04:58:23 <hpc> and the root of its type is (->)
04:58:48 <merijn> Isn't that example just an instance of the Aztec god of list recursion?
04:58:51 <merijn> @quote aztec
04:58:51 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
04:59:17 <HaskellStudents> hpc what does (e ->) mean? Can you link me to some documentation? or name it i guess
04:59:28 <Cale> HaskellStudents: Where did you see this expression?
04:59:37 <HaskellStudents> 1haskell a day
04:59:48 <Cale> It's a bit needlessly obfuscated, but we can go over how it works
04:59:53 <HaskellStudents> This just verified if a list is sorted
05:00:12 <Athas> merijn: I don't really think I want finer-grained low level control in a functional language.
05:00:34 <Cale> There's an instance of Applicative for functions (from a fixed type), i.e. where f a is the type e -> a
05:00:36 <hpc> HaskellStudents: it's (->), applied to some type variable 'e'
05:00:56 <hpc> or as a section, (e ->), because (->) is infix
05:01:00 <Cale> So, in that instance, (<*>) :: (e -> (a -> b)) -> (e -> a) -> (e -> b)
05:01:00 <merijn> Athas: I want a Haskell that's adequate for bare metal, and GHC is several crucial primitives short of that
05:01:07 <hpc> like how (2 *) is a section for multiplying by two
05:01:10 <merijn> Athas: Something like Habit's Area kind would be cool
05:01:43 <[exa]> HaskellStudents: with the evaluated <*> your expression should behave as `\x -> zipWith (<=) x $ tail x`
05:01:45 <Cale> and it's  (f <*> g) e = f e (g e)
05:01:50 <Athas> I would prefer to just have different languages for different purposes, with decent interop.
05:02:17 <Athas> I think some of the things that make Haskell nice to write are hard to integrate with fine-grained control, unless you add a really nastily complex type system.
05:02:21 <merijn> Athas: What? Are you implying the C ABI isn't good enough for everything? :p
05:02:42 <Cale> There are LLVM bindings for Haskell, just use that :)
05:02:55 <merijn> Cale: To do what?
05:03:08 <Cale> To write one-shot compilers to build your low level programs :)
05:03:18 <HaskellStudents> Cale Yes thats what the expression is doing. Does this instance of applicative have a name? or is it just (->)
05:03:33 <Cale> (->) e
05:03:43 <Cale> I usually just say "the instance of Applicative for functions"
05:04:03 <HaskellStudents> is it this  Applicative ((->) r :: Type -> Type)?
05:04:11 <HaskellStudents> found on https://hackage.haskell.org/package/base-4.14.0.0/docs/Control-Applicative.html#v:-60--42--62-
05:04:12 <Cale> yeah
05:04:20 <HaskellStudents> Thank you!
05:04:35 <Cale> https://hackage.haskell.org/package/base-4.14.0.0/docs/src/GHC.Base.html#line-973
05:05:00 <Cale> See also the Functor instance just above and the Monad instance below
05:05:04 <fog> ok, i can think of an example, where i have 2 different datatypes that are the same as HList, except one of them uses nonempty for the parameters
05:06:16 <fog> hmm, that doesnt work for vectors, which would have all the entries having the same type. but i guess both type level lists and type level nonempty-lists could have instances allowing them to use Replicate to build up the vectors
05:06:31 <fog> then, you might want to dot product them, and check the lengths are the same
05:06:55 <fog> then, it would have to kind of say "oh, on the second parameter, which is where the types list should go, how long is that"
05:07:10 <fog> and it should be able to take length over both list and nonempty list
05:09:44 <Cale> .oO(Yeah, because omg I'm so tired of not being able to use the same type-level programs for dealing with lists and nonempty lists and that's a real problem that anyone who actually writes software has...)
05:11:36 <Arahael> What do you mean, there?
05:11:54 <Cale> (I'm joking about fog's line of questioning)
05:12:08 <HaskellStudents> Cale++
05:14:16 <Cale> Somehow it's never clear to me what fog's actual motivations are. They're always working on abstractions of abstractions of abstractions, and never actual code which does a thing. The questions asked don't even make sense, because they're things which have never arisen in the course of writing an actual real program which does something.
05:15:42 <merijn> "not starting a blog" is the main motivation, it seems :p
05:16:19 <Cale> At least if they type it all into IRC, it's ephemeral
05:17:48 <mastarija> Hi guys, can anyone tell me what I'm doing wrong with my simple chat client / server? I'm going mad.
05:17:56 <mastarija> Here's the code : https://pastebin.com/u8TyMtDC
05:17:57 <Cale> maybe
05:18:15 <mastarija> Basically I get warnings like Network.Socket.recvBuf: invalid argument (Invalid argument)
05:18:24 <mastarija> When I try to send something from my client
05:18:43 <Arahael> My new year's resolution is usualyl to "start a blog", it never really happens.
05:19:17 <mastarija> Arahael, I feel you :D
05:20:22 <mastarija> Cale, I'm not sure what I'm doing wrong. When I just send a number between the server and the client and increment it on the server it works, but when ever I try to send some serialized data I get an error.
05:20:58 <mastarija> The way I'm serializing is to convert my data to BS and then calculate BS length, after that I encode that length into bs and send it first, then I send the data.
05:21:18 <mastarija> This way I first read one byte on the server side to determine how long the actual message is
05:21:38 <mastarija> then I read that amount of bytes to get the actual data
05:22:46 <mastarija> anyone :(
05:22:51 <[exa]> mastarija: is the socket really open?
05:23:01 <Cale> hmm, that "invalid argument" error usually happens when the socket is closed
05:23:01 <mastarija> it's supposed to be
05:23:07 <[exa]> I don't see many other reasons for recv to throw EINVAL
05:23:44 <mastarija> Hm... as I said, when I try doing this with just a simple number it works
05:24:01 <[exa]> mastarija: you are reading from the listening socket?
05:24:13 <mastarija> [exa], no
05:24:23 <mastarija> I listen on a listening socket to get the connection socket
05:24:33 <[exa]> oh no I see
05:24:34 <mastarija> then I just read from it
05:25:02 <[exa]> what do you use to connect to that?
05:25:19 <merijn> Wait, what
05:25:28 <merijn> mastarija: I think I see the mistake
05:25:28 <Cale> [exa]: I think both the server and client are here
05:25:42 <merijn> You are using encode to encode the length
05:25:49 <merijn> And then reading one byte on the remote
05:25:56 <merijn> Which assumes your length is one byte
05:26:05 <mastarija> Yes
05:26:15 <Cale> ah, yeah
05:26:17 <mastarija> I mean, it is.
05:26:18 <merijn> I'm pretty sure your lengths are more than 1 byte causing your decode of the length to always fail
05:26:21 <merijn> mastarija: No
05:26:32 <mastarija> really?
05:26:32 <merijn> mastarija: You've fallen for the classic mistake
05:26:43 <mastarija> Hm...
05:26:46 <[exa]> merijn: would decode failure cause EINVAL ?
05:26:54 <merijn> mastarija: *Never* use the Serialize class if you care about the actual data encoding
05:27:06 <merijn> mastarija: Serialize inserts it's own padding/encoding data
05:27:19 <Cale> Well, the instance for Word8 really does use getWord8/putWord8
05:27:24 <mastarija> ok, so I guess I should just convert Word8 to BS?
05:27:28 <merijn> [exa]: If the receiver fails, errors out and disconnects, then yes
05:27:45 <[exa]> uh yeah the inval can be the 0 from `size`
05:27:50 <merijn> mastarija: For Word8 specifically you can use "BS.pack :: [Word8] -> ByteString"
05:28:07 <merijn> mastarija: More realistically the *real* answer is "You're going about this wrong"
05:28:25 <mastarija> merijn, how should I approach this then?
05:28:45 <merijn> mastarija: Instead of treating recv as "packets", you should probably treat TCP like a byte stream (which it is) and use a streaming library like conduit to do a "stream decode" into concrete packets
05:28:58 <[exa]> mastarija: btw, try connecting with netcat/telnet to see what it really transfers
05:29:19 <merijn> mastarija: With binary/cereal you can easily write a parser for a packet (even if it's just "read a length, followed by N bytes"
05:29:56 <merijn> mastarija: Conduit has tools for "given a parser" (binary/parsec/whatever) keep streaming in bytes until we have a full parse, then yield a parsed datatype
05:30:32 <mastarija> merijn, would conduit be a good fit for game server?
05:30:49 <merijn> "maybe"
05:30:53 <merijn> Depends on the kinda game
05:31:14 <mastarija> merijn, 2D realtime shooter
05:31:17 <mastarija> >D
05:31:32 <merijn> Honestly, then TCP is probably not the way to go at all
05:31:44 <mastarija> merijn, it's a simple game :D
05:31:48 <merijn> TCP is not good for real time applications
05:32:14 <merijn> mastarija: Honestly, real-time network games are...intimidatingly hard
05:32:15 <mastarija> I've read conflicting information on that topic so I'm investigating right now 
05:32:41 <merijn> To the point that it's the main reason I haven't made any yet :)
05:32:47 <mastarija> hehe
05:33:03 <mastarija> Well, it's for my master's degree so I have to make it
05:33:36 <[exa]> mastarija: this is a very practical read https://www.jfedor.org/quake3/
05:33:48 <merijn> mastarija: So, the problem with TCP is that it guarantees delivery and will thus keep resending data until it arrives (blocking any newer data from arriving) which can cause big latency spikes
05:34:11 <merijn> mastarija: Yeah, read [exa]'s link I was just trying to find that one :)
05:34:18 <day> mastarija: you could check out teeworlds, which is a 2d quake style shooter
05:34:36 <mastarija> day, played it :D
05:34:44 <day> mastarija: nice :D
05:34:45 <mastarija> awesome game
05:35:02 <day> what was your ingame nick?
05:35:12 <mastarija> reygoch or mastarija
05:35:27 <day> hm i guess we played on different servers
05:35:29 <merijn> mastarija: Anyway, for something like games the conduit approach probably isn't great
05:35:35 <merijn> So forget that bit
05:35:50 <day> anyhow, i believe TW uses udp with lots of client sided prediction
05:36:05 <mastarija> I'm mainly worried about the recv not always reading specified ammount of bytes
05:36:05 <fog> i have some proprietary code for "realization", does anyone want to see it?
05:36:29 <merijn> mastarija: Anyway, for both binary and cereal you want to use the .Get and .Put models directly, rather than the typeclass if you want to control exactly how your data comes out in bytes
05:36:30 <mastarija> what is "realization"?
05:36:47 <fog> its proprietary! 
05:37:09 <merijn> mastarija: Like, putWord8 will create (as you expect) a ByteString with exactly 1 byte. Encode/decode may (and do) insert their own tagging/padding stuff
05:37:30 <mastarija> merijn: I'm gonna try now with just packing message size instead of encoding it
05:37:36 <fog> sorry, thats probably too abstract. maybe i could link a blog post
05:38:19 * hackage sized 0.6.0.0 - Sized sequence data-types  https://hackage.haskell.org/package/sized-0.6.0.0 (HiromiIshii)
05:38:33 <merijn> mastarija: Also, you probably wanna use the async library so you can have some way to shutdown/kill threads after you spawn them (which your current code doesn't really do)
05:39:11 <mastarija> I had that in previous version
05:39:21 <mastarija> But decided to nuke it and start over
05:40:04 <fog> Cale: its actually a real problem, not being able to abstract over parametric types in the way i describe, and i dont want to be chastised for raising the issue. i gave a concrete example, as i was cajoled into doing, only to be demeaned in commentary. what a horrible culture 
05:41:16 <lortabac> fog: the 'sized' package just mentioned in a notification looks similar to what you are talking about
05:42:21 <fog> it most certainly does not
05:43:47 <[exa]> fog: perhaps everyone failed to really understand your problem?
05:44:33 <fog> how?
05:45:53 <[exa]> no idea, people are here for fun, not for understanding the unfathomable
05:46:26 <fog> lortabac: i can see how you could be mistaken, as lengthed lists are "sized" in a way, but this package actually just has numbers, not types parametrised over by lengths
05:46:27 <lortabac> fog: oh, then I think I didn't understand your idea
05:46:49 <fog> could you articulate which aspect?
05:48:33 <Cale> fog: Why don't you just post the code which you're trying to improve, it might make it clearer what the problem is?
05:48:38 <fog> [exa] you seem to be suggesting that the "reason" that people dont "understand the unfathomable" is because they are "having fun" and that this somehow pertains to the current situation somehow
05:49:05 <fog> Cale: what was wrong with the examples i gave?
05:49:21 <Cale> I didn't see any actual examples of running code anywhere.
05:49:32 <Cale> Maybe I just missed it
05:50:09 <fog> you clearly understood it enough to wax lyrical as to how other worldly it was, and to be beyond the realms of people actually having to do more than take the piss of
05:51:23 <Cale> Well, the whole type-level type classes to abstract over type families thing was a bit funny
05:53:04 <fog7> i gave an example, meant to be a least sufficient demonstration, and you just said "well thats not realistic"  
05:53:20 <Cale> What example?
05:53:26 <Cale> Did you link a pastebin?
05:53:50 <fog7> type parameters to a HList in a list or a nonempty list, both being able to support a length function
05:54:38 <fog7> HList and HNonempty, belong to a class with an associated type family to take the langth
05:54:44 <fog7> "hilarious!"
05:55:01 <Cale> That is kinda hilarious, because I can't imagine why you need to abstract over that
05:55:08 <fog7> i dont!
05:55:12 <Cale> Exactly.
05:55:12 <lortabac> fog7: something like this? https://hackage.haskell.org/package/singletons-2.7/docs/Data-Singletons-Prelude-Foldable.html
05:55:45 <fog7> Cale: no! the thing i was trying to do was with tensors, and you asked me to think of something more simple, and when i did, you were like, thats absurd 
05:56:40 <Cale> I'm presuming that you're trying to actually use tensors to compute something
05:57:06 <Cale> This HList thing doesn't sound like it is any kind of a step toward your actual goal if that's the case
05:57:09 <fog7> lortabac: yes, so that can take the length of the parameter to the type. and the idea was about the type to which the parameter is supplied being an instance of some class
05:57:13 <sm[m]> fog is more of a mathematician methinks
05:57:31 <fog7> (sm[m] just googled realization)
05:57:43 <sm[m]> they like to think rather than code
05:58:05 <fog7> *sings, trying to make you realize* 
05:58:27 <fog7> *they are going to make you realize* 
05:58:34 <[exa]> that's quite a problem when faced with a reality of a practical programming language
05:58:50 <sm[m]> both practical and abstract thinkers hang out here, often there’s a tension
05:59:19 <fog7> type safe tension networks
06:00:03 <fog7> "damnit, you perturbed my matricies!"
06:00:38 <Cale> sm[m]: There's "theoretical" and then there's "nobody even has the merest inkling of how this could be put to use"
06:00:52 <fog7> its to do with disentangling correlated stochastic variables in a block diagonalization proceadure 
06:01:24 <sm[m]> when someone types a lot without engaging others so there is some two way understanding, we start getting antsy
06:01:40 <fog7> its actually pretty much like a multivariate "lazyness" concept
06:02:03 <mastarija> So, I think I'm maybe having some basic IO issues with my chat client. I've added some prints to help debugg the thing, and it seems like there's some issue with readLn?
06:02:06 <merijn> sm[m]: Usually the abstract thinkers don't feel like they're writing GPT-2 output, though :)
06:02:15 <fog7> if you have to do a matrix multiplication where all but the blocks on the diagonal are zero, then decoupling that into sperate calculations reduces the complexity
06:02:28 <sm[m]> that’s when #haskell-abstract might be handy
06:02:30 <fog7> then you get "matrix product states" 
06:03:00 <mastarija> Are there some possible issues if I wait for client input in one thread and use putStrLn in other?
06:03:24 <merijn> mastarija: no
06:03:37 <mastarija> merijn, well somethings wrong there.
06:03:48 <mastarija> I've put some prints in the code to help debug
06:03:50 <mastarija> https://pastebin.com/G8BVxf70
06:03:53 <merijn> mastarija: also, there's lots of issues with readLn, it's a terrible thing that's only useful for super hacky prototypes :)
06:03:59 <fog7> oh so its fine for you to say "when do you ever need type safe tensor networks" and then when justification is given as to a huge computational saving, based on haskell-like concepts, its just "thinking" and should be discouraged
06:04:11 <mastarija> merijn, well that's what I'm trying to do >D
06:04:21 <mastarija> a super hacky prototype
06:04:34 <mastarija> I have a feeling it's somehow interfeering with my socket communication
06:04:41 <ezzieyguywuf> why is the type of `runMaybeT (getData 0)` = `State MyData (Maybe (Maybe Text)`? Why the nested Maybe? https://dpaste.com/E4JJF85TD
06:04:45 <merijn> mastarija: What's the actual issue?
06:05:06 <mastarija> in the clientForward function
06:05:10 <mastarija> I read the line
06:05:19 <mastarija> and then I use forward function to send it over the socket
06:05:20 <merijn> ezzieyguywuf: Because of the (Maybe Text) ?
06:05:23 <merijn> :t MaybeT
06:05:25 <lambdabot> error:
06:05:25 <lambdabot>     • Data constructor not in scope: MaybeT
06:05:25 <lambdabot>     • Perhaps you meant variable ‘maybe’ (imported from Data.Maybe)
06:05:44 <dminuoso> % :t runMaybeT
06:05:44 <yahb> dminuoso: ; <interactive>:1:1: error: Variable not in scope: runMaybeT
06:05:47 <Cale> ezzieyguywuf: Because runMaybeT :: MaybeT m a -> m (Maybe a)
06:05:50 <merijn> ezzieyguywuf: "MaybeT m a" -> "m (Maybe a)"
06:05:51 <fog7> and im faced with like, 6 different implementations, and no hope in hell of standardizing the approach, and when i try to apply the normal mechanism of the haskell type system, im being "too much of a mathematician" - because i bothered to rase a question i havent yet got the code which soleves it!?
06:05:57 <mastarija> merijn, this forward never reaches the send
06:06:07 <merijn> ezzieyguywuf: So "MaybeT m (Maybe a)" -> "m (Maybe (Maybe a))"
06:06:35 <dminuoso> merijn: If `getData` is part of the public interface  you probably shouldn't wrap it with MaybeT. :)
06:06:42 <dminuoso> Err, ezzieyguywuf.
06:06:45 <dminuoso> Sorry, tab mistake.
06:07:03 <ezzieyguywuf> hrm
06:07:08 <ezzieyguywuf> I was actually going to make it internal
06:07:26 <ezzieyguywuf> slash also just trying to wrap my head around how this thing is working
06:07:36 <merijn> mastarija: What *does* it reach?
06:07:43 <mastarija> hmm... oh
06:07:48 <[exa]> fog7: that's getting confusing, so do you have the 6 implementations or not?
06:08:05 <mastarija> merijn, I just realized I was using readLn instead of getLine
06:08:06 <fog7> i linked the various type safe tensor network implemenations from hackage before
06:08:24 <ezzieyguywuf> merijn: so am I misusing MaybeT or is this just to be expected?
06:08:43 <[exa]> fog7: and this huge saving of comutational power works at least with 1 of those?
06:08:51 <fog7> [exa] the reason i want to get at the abstraction is because i want more general abstractions over parametric types
06:08:57 <merijn> ezzieyguywuf: That requires more thinking than I can be arsed with. But most likely having a MaybeT returning a Maybe is misusing it, yes
06:09:08 <ezzieyguywuf> lol, merijn thanks.
06:09:20 <fog7> because i want to extend from tensors which match up on the edges, to function nets that do the same
06:10:01 <fog7> [exa] i should imagine thats the problem all tensor networks are attempting to solve. 
06:10:14 <fog7> block factorisation 
06:10:16 <mastarija> merijn, omg it's working! I was such an idiot. Using readLn instead of getLine (facepalm)
06:11:21 <fog7> if i could diagonalise, i would have "solved" the system. and can exponentiate the diagonal eigenvalues, to give trivial long time evolution
06:11:46 <fog7> however, if the most diagonal thing i can get is block diagonal, then i have been unable to "disentangle" the states
06:12:33 <fog7> but the matrix exponentiation that is the nth power of the time evolution operator,  is still faster to do on block diagonals than the full matrix
06:13:31 <[exa]> fog7: yeah we've been through that, still that's a numeric problem on data, not on types
06:13:49 <fog7> thats MPS of mps and mera, where mera also allows for "compression" to renormalize or simplify the entangled system
06:14:28 <fog7> [exa] well like i say, im just trying to steal their "matching up on the edges" for function nets
06:14:35 <fog7> and thats a type level opperation
06:15:06 <fog7> if i can get the abstraction which all the tensor net implementations can instantiate, then i can generalise over that 
06:15:25 <fog7> and get this parametric subtype safety 
06:15:33 <fog7> or whatever you would call it
06:15:49 <fog7> with streams over edges instead of tensor contraction
06:15:57 <fog7> which is just some monoid thing anyway
06:16:34 <[exa]> fog7: suggest modeling the function nets as with lenses, there's quite a bit of tooling for that already, and you will get at least some controllable notion of invertibility that you probably want
06:16:38 <fog7> the halfway point is "nets as neurons" where the tensor multiplication is abstracted over to feeding outputs of one net to inputs of another 
06:17:12 <fog7> [exa] im not sure that would allow for the type level stuff, lenses just deal with the data no?
06:18:07 <[exa]> fog7: no
06:18:19 <fog7> if you would use the lenses to abstract over how the data was accessed, i would reccon this would just be for how the monoid action similar to tensor multiplication would work
06:18:37 <fog7> not sure if its a monoid since there are more than one input
06:18:41 <fog7> more than 2
06:18:50 <fog7> its kind of like an n-monoid
06:19:13 <fog7> but all the type level dimensions and lengths have to match up
06:19:34 <fog7> its like gluing together the faces of high dimensional polytopes  
06:20:15 <[exa]> there's even a library for doing this with normal arrows
06:20:26 <fog7> really!?
06:20:51 <[exa]> like, it doesn't materialize the magical typelevel lists, but for good practical reasons
06:20:53 <fog7> maybe i could write the more simple thing in that
06:21:05 <[exa]> generally, you don't want typelevel lists
06:21:20 <fog7> well i cant much else see how im going to get type safety
06:21:45 <fog7> you must not be able to glue together faces that have different sapes and sizes
06:21:58 <fog7> that should throw a type error
06:22:00 <[exa]> that's quite normal
06:22:14 <fog7> right, all the type safe tensor net libs do that
06:22:44 <[exa]> it's complicated for tensors because they have the dimensions in there, which are not easily processed by normal typechecking
06:22:58 <[exa]> your usecase might be simpler, no need to materialize the stuff explicitly
06:22:59 <fog7> so i should be able to get the type family kind class thing which they instantiate 
06:23:11 <[exa]> oh man
06:23:19 <[exa]> don't bring in unnecessary complexity when you don't need it
06:23:21 <fog7> well whts it called!?
06:23:37 <[exa]> alternatively, try it in Agda
06:23:48 <fog7> type family (k :: Type) (a :: k) :: Constraint
06:23:56 <fog7> whats that called!?
06:24:12 <fog7> "type family kind class" ?
06:24:13 <Cale> A Constraint-valued type family?
06:24:35 <fog7> its unique because of its ability to match on the kind
06:24:41 <fog7> and be polymorphic in the kind
06:24:42 <[exa]> fog7: suggest browsing through the arrow libraries
06:24:51 <Cale> type families can do that
06:25:01 <fog7> you mean classes?
06:25:11 <Cale> also classes
06:25:16 <Cale> but this is just a type family
06:25:44 <fog7> i cant remember which is more expressive 
06:25:56 <fog7> i think if its an associated type its better
06:26:19 <Cale> (your type family will need a name, btw)
06:26:21 <fog7> because you can have superclass constraints then
06:26:44 <fog7> "all the type level parameters have the same length"
06:27:05 <fog7> probably needs a better name
06:27:32 <fog7> type parametric n-monoid 
06:27:45 <[exa]> wtf is n-monoid?
06:27:56 <fog7> idk!!
06:27:57 <Cale> I think if you have an associated type class for a constraint, it's probably better off just reworking it so that the constraint becomes the constraint on the instances of a slightly different class.
06:28:07 <Cale> If possible
06:28:19 <fog7> like, how you have multiple tensors contracting against different faces
06:28:30 <[exa]> fog7: these are arrows
06:28:33 <fog7> and they appear as ingoing edges to a node in a tensor net
06:28:37 <Cale> It might not be possible in some convoluted cases, but it's been possible to remove that kind of shenanigans in the only case I've ever needed anything like it
06:29:06 <fog7> it doesnt seem to be a monoid... actually maybe it is, because i can contract them one at a time
06:29:35 <fog7> Cale: how else would you keep track of the changing siz of the tensor as it gets contracted
06:30:07 <fog7> "parametric monoids" seems pretty eloquent 
06:30:22 <Cale> Depends. I might just represent particular fixed types of tensors and only implement the contractions that I need.
06:30:31 <fog7> and they just need to satisfy constraints between the parameters 
06:30:36 <Cale> as completely separate and unrelated functions
06:31:01 <fog7> right, but then you are limeted to finite numbers of ingoing edges
06:31:07 <Cale> At least, that's what I'd do in Haskell like... almost all of the time
06:31:25 <fog7> what, not represent tensor networks?
06:31:49 <fog7> i spend all day doing that normally! today is an unwelcome exception 
06:31:52 <Cale> If I were going to use Idris or Agda or Coq or something, I'd feel a bit more comfortable with the dependently typed programming that's involved
06:32:09 <fog7> how are you not happy with the haskell type system!?
06:32:31 <fog7> what is it lacking that you feel you need to suggest these alternative languages each time?
06:32:37 <Cale> Haskell's type system is really good as long as you don't end up needing singletons
06:32:52 <fog7> im not sure you do in this case
06:32:54 <Cale> and this is exactly the kind of thing which is going to take you into singleton territory
06:33:10 <fog7> the lengths are not used at value level
06:33:45 <fog7> anyway, singletons is no bother at all
06:34:08 <Cale> It might be that if you're really careful, some lists of type level Nats are really all you need, and you never do any arithmetic on them
06:34:23 <fog7> any saving available in another language just based on singletons being easier is pretty much not a justification of discouraging it in haskell, especially if its just because its conceptually difficult
06:35:12 <fog7> it feels like a polite way of saying fuck off
06:35:25 <Cale> But eh, I'd be willing to just start with defining the specific tensor types which came up and implementing the operations on them as I needed them to start with. I'd tolerate a fair amount of that
06:35:49 <Cale> Or! Just pushing it all to runtime
06:36:09 <Cale> You only need to represent stuff at the type level if you want it checked statically
06:36:39 <fog7> the problem with the runtime approach is then i cant abstract to type nets with more elaborate type equality matching on the edges 
06:36:52 <fog7> like, not just zipWith ~ over Nats
06:37:04 <Cale> I'm not sure I understand what the limitation is here
06:37:15 <fog7> well i want to use the typechecker
06:37:33 <Cale> You can do whatever -- you might not be able to have a type class pick implementations for you, but you can write all the functions that the instance resolver was going to pick from anyway
06:37:56 <fog7> then, the "unlengthed tensors" that are only checked at runtime, becomes, untypechecked programs when extending from Nats to Types
06:38:04 <hyperisco> on one hand I like inductive data
06:38:25 <Cale> It might be a little more tedious at the term level than what you wanted, but it saves *so* much type level hackery that 99% of the time, it'll end up being easier that way.
06:38:50 <fog7> at the cost of type safety, no chance
06:39:52 <fog7> with type safetly, representing my streaming networks on a grpah comes at no cost - its an equivalently as good an implementation environemtn. if i lose type safetly, just because of not being able to match over edges, then the whole thing becomes basically useless
06:40:08 <hyperisco> on the other hand, you can use memory sharing and paths and stuff… or you can throw it out and just indirect through a map of unique node identifiers
06:40:09 <Cale> Sure, but on the other hand, how long are you going to spend fucking around with the typechecker if you're doing such crazy type hackery vs. debugging mismatched tensor sizes?
06:40:41 <hyperisco> which is more noisy in some sense but seems much simpler in others
06:40:55 <xsperry> T
06:40:56 <fog7> but does that also apply to functional programs?
06:42:12 <fog7> Cale: my development curve starts by stealing the tensor networks approach to type safety over "faces" and extends this to match on Types instead of Nats as the lengths in each "dimension"
06:42:34 <Cale> fog7: There's always a continuum of how much information you're going to bother to put at the type level. In the extreme case with dependent types, you're just programming your whole program twice -- once as a type level specification, and then once as the only term-level thing which could possibly fit that extremely specific type
06:42:46 <hyperisco> am I making any sense
06:43:02 <Cale> On the other extreme, you have a unityped program where you don't reflect anything statically.
06:43:17 <fog7> so since the target application is to do with eg, matching up neural nets, or functional programs on streaming threads, then saying "tensors are easy with no type safety" is basically a criticism you cant extend through that development trajectory
06:43:47 <fog7> hyperisco: yes, but, doesnt that also apply to functional programs?
06:43:58 <fog7> im observing an isomorphism 
06:44:19 <hyperisco> well I'm in #haskell talking about functional programs, so yes
06:44:36 <Cale> hyperisco: I think I know what you're referring to
06:44:53 <fog7> you were talking about graphs as implemented by lookup tables?
06:45:16 <hyperisco> well graph libraries have a similar contention, though there they are also bound by the generality of graphs
06:45:26 <Cale> hyperisco: One point at which it becomes a really good idea to indirect through a Map is when you start having cycles and want to do transformations to your graph after its initial construction
06:45:34 <hyperisco> I am saying even with something that is a tree, the contention can still exist
06:45:48 <fog7> and im saying that it should work for functional prgrams implemented on graphs, by that same logic, but that isnt how we do it. we use the typechecker!
06:45:52 <Cale> sure
06:46:06 <Cale> (the tree thing)
06:46:18 <hyperisco> or look at DOM and element ids
06:46:21 <hyperisco> they're playing both games
06:46:41 <fog7> i have seen something like enumerating typeclass instances
06:46:49 <fog7> and other things we would normally have the typechecker do
06:46:55 <fog7> im just saying id rather avoid that
06:47:15 <fog7> the type safe tensors dont use lookup tables for edges
06:47:32 <fog7> its just a type safe monoidal opperation for composing them together into networks
06:47:39 <fog7> "connecting edges"
06:48:08 <fog7> as a function taking 2 arguments, that are nodes, and giving you back something which is effectively a node
06:48:16 <fog7> (nets as neurons)
06:48:23 <fog7> by Monadicity 
06:48:45 <hyperisco> editing the indirect version seems more straightforward
06:48:53 <fog7> they are type safe by construction, and you dont need to keep track of the edges in a lookup table
06:49:16 <fog7> its not though, because then you cant just use function composition to get it to go via the typechecker
06:50:29 <hyperisco> also the common subexpression problem comes up
06:50:38 <fog7> go on
06:50:53 <hyperisco> well because moving and deleting then adding look the same
06:51:24 <fog7> is that a problem for the algebraic graph library?
06:51:55 <fog7> i thought common subexpressions is that you wanted reusable subgraph components
06:52:32 <fog7> multiple reference to the same bound variable
06:52:43 <fog7> i think you would need copying for that
06:58:48 * hackage lifted-async 0.10.1.2 - Run lifted IO operations asynchronously and wait for their results  https://hackage.haskell.org/package/lifted-async-0.10.1.2 (MitsutoshiAoe)
07:02:22 <merijn> I have the impression that optparse internals are more complex than they need to be :\
07:02:40 <dminuoso> merijn: Haha, did you too ponder about how to make selective a thing?
07:02:49 <merijn> dminuoso: Yeah
07:02:55 <dminuoso> I lost a few hairs last night as well. :)
07:02:57 <merijn> And also a bunch of other stuff
07:03:31 <merijn> Like more flexible/powerful help rendering and validation that there's no conflicting option names (although the latter sounds like the kinda thing you want Selective for)
07:04:53 <merijn> dminuoso: What doesn't help is that everything is exported publically and there's no markers for in which version which function was added, so it's near impossible to refactor the internals without majorly overhauling the public API too
07:05:46 <merijn> There's much more cruft in there anyway, like the hard ties to ansi-wl-pprint
07:06:18 <merijn> Which has been an open ticket for years now, but there's a sort of circular dependency between things like criterion and optparse
07:07:31 <merijn> So any major overhaul would be backwards incompatible, which means it's probably unlikely to get merged, which leads to "maybe this should just be a fork/new package", but then you have to reimplement *all* of it, which is also a pain :p
07:08:40 <refried_> Should I be able to compose a Prism' with a Lens' with  p . l  ?
07:09:34 <dminuoso> merijn: argh Im seeing selective everywhere now. :(
07:09:59 <dminuoso> does attoparsec have some `branch` primitive Im not seeing?
07:10:06 <merijn> Alternative?
07:11:06 <hyperisco> I think one major sticking point is whether or not substructure paths are invariant under structure edit
07:11:08 <merijn> dminuoso: Also "SelectM"
07:11:31 <hyperisco> so what do I mean… if you have a list of strings, and you remove the 5th string, the the path (the index) to the 6th string and onward changes
07:11:49 <hyperisco> with the indirect approach they do not
07:13:43 <hyperisco> if you have a  Map Int String  then you can remove the 5th and the paths do not change, even in the direct version
07:14:30 <Orbstheorem> Does anybody know if there's an OpenAPI 3.0-servant validator ?
07:14:48 <hyperisco> I guess what has to be asked is if unique identifiers are convenient to come up with, because those themselves can be a headache
07:14:54 <hyperisco> just look at the headache of generating fresh variables
07:15:30 <hyperisco> in my situation, yes, they are easy, they are ordained… so perhaps I ought to make use of them
07:15:35 <refried_> Is it that Prism + Lens != Prism?
07:16:16 <merijn> dminuoso: I'm increasingly tempted to build my own option parser, with blackjack and hookers!
07:16:29 <Orbstheorem> merijn: xD
07:16:38 <hyperisco> I am just uncomfortable with how far this assumption has to reach… like, if you wanted to build a multi use library, I don't know how you offer both variants simultaneously
07:16:45 <Orbstheorem> merijn: What are you looking for in a parser?
07:17:13 <merijn> Orbstheorem: optparse-applicative, but + selective and prettyprinter support
07:17:20 <merijn> And more control over help lay-out
07:17:40 <hyperisco> DOM implicitly relies on unique identifiers throughout, because it relies on object identity, so I don't think that is a solution
07:18:14 <merijn> Orbstheorem: The latter should be somewhat doable to add to optparse-applicative, but I fear that prettyprinter/selective support just won't happen
07:18:37 <halogenandtoast> Does anyone know how to set the optimization (or other) flags when running stack run?
07:19:13 <halogenandtoast> I can only see RTS options
07:21:25 <sm[m]> merijn: could you make it like docopt? That’s really handy when it works
07:21:42 <John20> Hi All, if I have a typclass - `MyClass` with a function `myfunc` and a record with property `myfunc`, is there a concise way of making my record an instance of MyClass without having to duplicate or rename the definition of myfunc for the record?
07:22:09 <merijn> sm[m]: At first glance I don't see what docopt does that optparse doesn't?
07:22:26 <hyperisco> John20, is the problem that you have a name conflict? You can import the class qualified
07:22:29 <merijn> John20: 1) no, 2) that's probably a bad idea anyway
07:22:33 <John20> e.g. can I do something like : `data MyRecord = MyRecord{myfunc :: String} deriving MyClass
07:22:51 <sm[m]> you write the cli help you want to see, and it figures out the rest
07:23:06 <merijn> sm[m]: Oh, I'm super anti that, so no
07:23:54 <merijn> sm[m]: In fact, now that you've pointed out that that's what it does, I am super mad about it existing
07:24:13 <sm[m]> I won’t try to change your mind then :)
07:24:20 <John20> hyperisco, no I don't have name conflicts, I've just got a few typeclasses that essentially indicate that the type has a certain property e.g. HasName, Has.... That means that I can have a function that just takes an instance of the typeclass. Hopefully that will lead to less duplicate code
07:24:26 <John20> Is there a better way of doing this?
07:24:59 <delYsid> I am failing to use bits-extra with the bmi2 flag enabled in a stack project.  What do I need to do to get fastPextEnabled to return True?
07:25:04 <merijn> dminuoso: So...should we make like megaoptparse-applicative? ;)
07:25:32 <hyperisco> John20, sounds like TemplateHaskell
07:25:49 <delYsid> I tried stack build --flag bits-extra:bmi2 -- no success.  I tried adding flags: to stack.yaml.  No success.  Whats going on there?
07:26:35 <John20> ah. I've noticed that in cassava you can just do `instance FromJSON MyDataType ` and I'd like to do something similar (if it's easy and straightforward)
07:29:25 <sm[m]> merijn: whatever you do please drop the -applicative suffix, it makes it a pain to discuss
07:29:58 <merijn> dminuoso: Actually, it kinda looks like I already build half of such a thing in my phd thesis to more easily specify commands/groups :p
07:30:01 <delYsid> I also tried specifying bits-extra-0.0.2.0 as an extra-dep in stack.yaml in case the flag is only used if it isn't a memeber of the package set..... but no, also no success.
07:30:06 <sm[m]> Getting that vote in right now. :)
07:30:27 <jumper149> I want to use the FFI to call C functions with GHC-8.10. It tells me, that {-# INCLUDE... pragmas are deprecated. I couldnt really find any resource on how to to foreign function calls. Where can I read up on it?
07:30:45 <merijn> jumper149: Where did you get that INCLUDE pragma from?
07:30:53 <sm[m]> delYsid: you should probably show the details
07:30:55 <merijn> jumper149: I do quite a lot of FFI calls and I've never seen it
07:31:02 <jumper149> https://wiki.haskell.org/FFI_Introduction
07:31:31 <merijn> jumper149: You can specify the header file directly in the foreign import nowadays
07:31:43 <merijn> nowadays being, since *at least* 10 years ago :p
07:32:01 <jumper149> merijn: haha ok? Still I'm not sure what you mean by that^^
07:32:07 <merijn> jumper149: I recommend giving chapter 8 of the Haskell Report a read (it describes the Report)
07:32:17 <merijn> And the ghc user guide also has a ton of of stuff
07:32:21 <merijn> @where report
07:32:21 <lambdabot> http://www.haskell.org/onlinereport/haskell2010/ (more: http://www.haskell.org/haskellwiki/Definition)
07:32:24 <merijn> @where userguide
07:32:24 <lambdabot> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/
07:33:01 <merijn> jumper149: I mean like: https://github.com/merijn/Belewitte/blob/master/benchmark-analysis/src/SQLiteExts.hs#L139-L143
07:33:19 <jumper149> ghc user guide is where I usually look stuff up, but this time I didn't find what I was looking for
07:33:39 <merijn> jumper149: Yeah, the user guide glosses over some stuff covered by the FFI chapter in the report
07:35:02 <jumper149> merijn: ty, the haskell report looks good :)
07:35:14 <dmwit> FWIW, I found the official FFI documentation quite light for somebody like me who doesn't really understand how object files and linkers actually work. Left a lot of stuff to the imagination.
07:35:18 <xsperry> is anyone using selenium in haskell? how do I call addScriptToEvaluateOnNewDocument method or equivalent? https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-addScriptToEvaluateOnNewDocument
07:35:26 <dmwit> I'm still not really sure I understand when the "dynamic" stuff is needed and when not.
07:35:41 <dmwit> So I can commiserate with you, jumper149. ^_^
07:35:46 <merijn> dmwit: Fair enough, they do kinda assume you know linking stuff
07:35:52 <merijn> dmwit: Which dynamic stuff?
07:36:22 <dmwit> I can't recall the details now; I think there was something about exporting Haskell stuff to the C side where sometimes you need a "dynamic wrapper" (WTF is that?) or something?
07:36:34 <merijn> dmwit: Oh, right
07:36:44 <merijn> dmwit: That's for exporting arbitrary runtime functions
07:36:58 <merijn> dmwit: (because those include lambda captures and could be GCed)
07:37:24 <merijn> dmwit: So you only need them for exporting non-top level functions to C
07:38:17 <ezzieyguywuf> is it "ok" to use fromJust in a unit-test?
07:38:41 <merijn> dmwit: Like, if you have "Foo -> Bar -> Baz" and you wanna let C call it, how would that possibly work for any arbitrary runtime function? The "wrapper" stuff turns that arbitrary closure into a function pointer which you can then pass to C
07:38:59 <merijn> dmwit: for exporting top-level (and thus static) Haskell functions it's not needed at all
07:40:34 <dmwit> Thanks for the explanation.
07:41:13 <Cale> xsperry: Is the Chrome DevTools protocol part of Selenium?
07:41:22 <Cale> There's a lot of stuff here I don't really recognise
07:45:52 <delYsid> sm[m]: The details of setting a flag for a single dependency?  I fail to understand what I should show.
07:46:48 <delYsid> sm[m]: bits-extra has a bmi2 flag which actually enables intrinsic instructions for the pext function.  However, I cant figure out how to depend on bits-extra *and* enable the bmi2 flag.
07:47:26 <Cale> xsperry: I think this DevTools stuff is Chrome specific, while the WebDriver stuff works across a bunch of different browsers, but isn't as detailed. WebDriver can pretty much do what a user could.
07:47:27 <delYsid> Stack always builds a version with bmi2 disabled.
07:48:06 <sm[m]> we don’t know what you’ve got in stack.yaml/package.yaml/foo.cabal, what commands you’re running, what output you’re seeing. It saves time to ask for those rather than try to guess
07:48:09 <Cale> https://hackage.haskell.org/package/webdriver-0.9.0.1/docs/Test-WebDriver-Commands.html#v:executeJS -- there is this
07:51:28 <emmanuel`> Is it foldlM or foldrM that short circuits?
07:51:39 <delYsid> sm[m]: I tried stack build --flag bits-extra:bmi2 and putting a flags section in stack.yaml.  Both attempts are ignored.  I dont get any error.  The output I have from a small test program that prints the result of fastPextEnabled (a runtime check from bits-extra) always prints False.
07:52:21 <sm[m]> ok, thanks
07:53:47 <delYsid> The CPU I am working with has BMI2, I verified this by manually copying the relevant code from bits-extra.  So I can actually use the intrinsics here.  But for some reason, I cant depend on a version of bits-extra that has the bmi2 flag enabled...
07:54:20 <lyxia> emmanuel`: foldlM is the one implemented with foldr, that's the one that can short-circuit
07:58:48 <lyxia> emmanuel`: that's for one definition of short-circuit (may be lazy in a suffix of the list); there's another definition for which both foldlM and foldrM may short-circuit depending on the particular monad and step function
08:00:10 <sm[m]> delYsid: I confirm that stack build bits-extra --flag bits-extra:bmi2 --cabal-verbose does enable the ghc flags
08:00:31 <sm[m]> maybe check your build command the same way
08:00:47 <sm[m]> (with --cabal-verbose)
08:06:03 <emmanuel`> lyxia: I think I'm wanting the first definition of lazy. The monad in question isn't lazy (it is something like Monad IO m => ReaderT m blah blah blah)
08:12:16 <lyxia> sounds fair
08:13:40 <emmanuel`> Thanks for the help!
08:22:46 <dminuoso> merijn: Also, Alternative is not exactly the same since attoparsec backtracks.
08:23:39 <dminuoso> But your point regarding SelectM is right
08:23:42 <dminuoso> I did not consider that
08:25:10 <delYsid> sm[m]: Thanks.  Seems to be a caching issue.  When I invoke that command, it turns without any action being done.  After deleting ~/.stack, it builds bits-extra.  And when I *then* build my program, it apparently links against the bmi2 enabled bits-extra.
08:26:03 <dminuoso> delYsid: Mind my asking, how's your accessibility experience in general with CLI tooling? Say cabal, ghc, stack, or even general linux tools?
08:26:14 <dminuoso> It's something that I've been thinking about for a while now.
08:26:40 <merijn> dminuoso: Actually, now I'm once again considering the same thing I considered for my other code base where my my validation logic is all monadic/IO so I need up with a lot of "Parser (SqlM Foo)" in my argument parser and I'm again considering some parser that makes that easier to work with. "Compose Parser SqlM" works, but not quite if your monadic validation requires previous values. You could of course 
08:26:41 <sm[m]> I thought stack usually knows to rebuild on a flag change but maybe not
08:26:46 <merijn> only return primitive types without validation from your CLI parser, but that's also quite obnoxious
08:27:12 <merijn> dminuoso: So now I
08:27:39 <merijn> I'm thinking again how I could combine some sort of monadic/compound validation with just an applicative/selective parser >.>
08:27:59 <Lycurgus> end up
08:28:32 <Lycurgus> (i presume)
08:28:54 <delYsid> dminuoso: There are no accessibility issues with CLI tooling.  That is why I use it.
08:29:48 <merijn> dminuoso: The main problem is that you'd like to write the compound validation monadic style, but it's not obvious how that'd work without making your parser monadic
08:36:41 <dminuoso> merijn: well it works with applicative, but I dont see how you can make it work with selective.
08:36:46 <dminuoso> (i.e. ApplicativeDo)
08:36:56 <ezzieyguywuf> I'm trying to refactor addEdge using MaybeT: https://gitlab.com/ezzieyguywuf/mycad/-/blob/drawEntity/Entity/src/Entity.hs#L139 . Here's what I have so far, but I am doing something wrong as the compiler is telling me my return type is Maybe (Maybe Topo.Edge). Does anyone know where I have erred? https://dpaste.com/CTHVZFNYR
08:37:40 <dminuoso> merijn: I suppose in a lot of ways `branch` is *exactly* that feature, even ergonomics wise. `do` lets you either do arbitary (or no) branching, and a 2-function argument has that static 2-way branch.
08:38:03 <dminuoso> It feels very much like there's no in between.
08:38:28 <merijn> dminuoso: You can get the semantics with Selective, but I feel like the API would be super cumbersome
08:38:45 <ezzieyguywuf> "I drove by the fork in the road and went straight" - Jay-Z.
08:38:59 <ezzieyguywuf> dminuoso: ^ Jay-Z says there _is_ an in-between 🤣
08:39:13 <dminuoso> delYsid: Interesting, do you have any way to "visualize" (whatever that means for you) CLI drawing like say progress bars? Does your braille display accept some ANSI escape sequences?
08:39:38 <dminuoso> delYsid: Like, could you actually display a progress bar in a way that's meaningful?
08:40:33 <ezzieyguywuf> I think my error must be on my last line, `pure edge`. I thought `lift (pure edge)` was the solution that this is not the case
08:42:02 <dminuoso> ezzieyguywuf: can you share the full error message?
08:42:58 <ezzieyguywuf> dminuoso: sure
08:45:01 <ezzieyguywuf> dminuoso: https://dpaste.com/8XYDWJWP8
08:46:05 <ezzieyguywuf> oh wait! I think I see it
08:46:31 <ezzieyguywuf> MaybeT . pure
08:46:34 <ezzieyguywuf> *facepalm*
08:46:59 <ezzieyguywuf> I forgot that I created that `addData` function before when we were doing this last night
08:48:08 <dminuoso> ezzieyguywuf: That's some mighty fine misleading inference. :)
08:48:25 <ezzieyguywuf> er, getData
08:48:28 <dminuoso> ezzieyguywuf: Next time you get a puzzle like this, start annotating everything with types.
08:48:36 <dminuoso> Even if you think you know its type, annotate it anyway.
08:48:46 <ezzieyguywuf> dminuoso: indeed. I was THIS close to doing that
08:48:58 <ezzieyguywuf> part of my issue is that the relevant error wasn't showing in ghcid
08:49:13 <ezzieyguywuf> it wasn't until I bailed out and ran `stack test` that I actually saw it (when you requested the full error)
08:49:42 <ezzieyguywuf> wasn't showing *because it was off-screen
08:49:57 <ezzieyguywuf> dminuoso: what do you mean 'misleading inference'?
08:51:00 <dminuoso> ezzieyguywuf: Roughly, you could think it makes a bunch of equations and solves them. However, it cant know beforehand which equations are wrong.
08:51:46 <dminuoso> So when it cant solve for it, it's stuck *somewhere*, and GHC only tells you where it got stuck - but it cant know which  "equation" (i.e. inferred types) was the incorrect one.
08:51:51 <ezzieyguywuf> "it" being the compiler?
08:51:53 <dminuoso> Right
08:52:12 <ezzieyguywuf> ah. yes, this is why I try as much as possible to be explicit about my types
08:52:44 <dminuoso> So this for instance:     p2 <- MaybeT (Map.lookup v2 vmap)
08:52:53 <ezzieyguywuf> thus I thisk I'll add `getPoint :: Topo.Vertex -> EntityState a (Maybe Geo.Point)`, similar to the `getData` function I used previously when we were doing tihs with a simple Map
08:53:10 <ezzieyguywuf> s/thisk/think/
08:54:21 <dminuoso> ezzieyguywuf: So the combination of that and `runMaybeT` let it to assume that the monad you're in was `MaybeT Maybe`. The fact that this is in conflict with all the other do-statements is not discovered because GHC bailed out once it checked against the outer type signature.
08:54:27 <ezzieyguywuf> the only downside to this approach is that I'll be unwrapping the EntityState more times than I need to, but I'll worry about this if it becomes a performance problem in the future.
08:54:48 <ezzieyguywuf> dminuoso: ah hah, I see.
08:56:30 <dminuoso> ezzieyguywuf: GHC has a set of inference rules. Consider a simple case of `f :: Int -> Char`, now if you have `f x`, it can infer that `x :: Int`. Whether this is actually true will turn out eventually anyway.
08:56:43 <casexof> Is there a better way to write something like: https://pastebin.com/JXgP5HYC
08:56:45 <dminuoso> But if you go on with that assumption, it's possible you'll create distant errors.
08:57:04 <dminuoso> because it will use that knowledge to keep on inferring more things
08:57:39 <dminuoso> casexof: foldMap Alt 
08:58:42 <dminuoso> casexof: well, sprinkle some over it of course
08:58:43 <dminuoso> readTChan
08:59:16 <dminuoso> % :t getAlt . foldMap (Alt . readTChan)
08:59:16 <yahb> dminuoso: Foldable t => t (TChan a) -> STM a
09:13:49 * hackage rocksdb-haskell-jprupp 2.1.0 - Haskell bindings for RocksDB  https://hackage.haskell.org/package/rocksdb-haskell-jprupp-2.1.0 (jprupp)
09:17:19 * hackage secp256k1-haskell 0.4.0 - Bindings for secp256k1  https://hackage.haskell.org/package/secp256k1-haskell-0.4.0 (jprupp)
09:19:27 <ja> how do FunctorWithIndex, FoldableWithIndex and TraversibleWithIndex interact, if i am writing an instance?
09:19:47 <ja> i saw that that the default keyword is being used: https://hackage.haskell.org/package/lens-4.16/docs/src/Control-Lens-Indexed.html#itraverse
09:20:17 <ja> does that mean that i only need to define TraversibleWithIndex and Monoid, and the others can be inferred?
09:21:16 <ja> no, i guess it doesn't, since TraversableWithIndex requires the others
09:22:18 <L29Ah> huh, i've just hit `cabal install --lib`, it installed the package, but i still don't see it in `ghc-pkg list`
09:22:34 <L29Ah> do i need to do any extra calls to make ghc aware of it?
09:22:58 <ja> L29Ah: if it is v2 installed, it wouldn't be globally installed right? 
09:23:30 <ja> L29Ah: what's the motivation for messing with ghc-pkg?
09:23:45 <L29Ah> ja: i expect to use the library with `ghc --make`
09:24:05 <L29Ah> and bare ghci
09:25:44 <ja> L29Ah: i guess you can v1-install it and see if it is globally available, maybe?
09:25:49 * hackage haskoin-core 0.15.0 - Bitcoin & Bitcoin Cash library for Haskell  https://hackage.haskell.org/package/haskoin-core-0.15.0 (jprupp)
09:26:51 <L29Ah> v1-install works, but i remember some threats about v1-stuff getting removed eventually
09:30:20 <dsal> "globally installed" sounds like a bad idea.  Why do you want that?
09:31:34 <ja> ok i will redirect my lens question to #haskell-lens
09:33:56 <L29Ah> dsal: to use ghc --make and ghci?
09:33:59 <ezzieyguywuf> hrm, any fgl users here?
09:34:47 <dsal> L29Ah: I don't find such things particularly useful.  I generally use stack, but cabal has similar facilities to interact with the specific sets of libraries and stuff that you need in a particular project.
09:35:05 <ezzieyguywuf> from what I understand, it's supposed to be one of "the" graph libraries to use, but it does some silly/unexpected things, i.e. if I call insEdge with two Node that are not in the graph, it just goes ahead and adds them (in an unpredictable way). I'd expect insEdge to return a Maybe to account for the case where the Node is not in the graph
09:35:25 <ezzieyguywuf> are there other graph libraries out there that are robust/trustworthy? or am I stuck writing small wrapper functions around the fgl stuff?
09:36:17 <L29Ah> i do find those thing useful, and i don't use stack; i work on a lot of projects and don't want to mess with lots of ghci's utilizing different sets of libraries, since my library set is consistent
09:36:51 <L29Ah> also i don't want to write metadata for single use chunks of code to build into tools
09:37:04 <L29Ah> s/build/be built/
09:38:43 <ezzieyguywuf> hrm, maybe Data.Graph, which is simply an Array...
09:40:39 <ja> L29Ah: but the nix-style packaging doesn't break your use case. it fixes things for people who have multiple versions of libraries. but why is it so important for you to avoid that fix?
09:41:06 <ja> if you have a consistent set of libraries, that just means nix-style storage will only actually store one version. what have you lost?
09:41:19 <L29Ah> so how do i use `ghc --make` and `ghci` with nix-style packaging?
09:43:26 <ja> you can use ghci by using "cabal repl"
09:44:14 <ja> cabal calls 'ghc --make' when you build ;) i know that is not the answer you want, but i still don't understand why you want to avoid building with cabal...
09:44:51 <L29Ah> 19:43:05]<ja> you can use ghci by using "cabal repl"
09:44:52 <L29Ah> nope, it doesn't include the library i've installed with v2-install
09:45:03 <L29Ah> 19:43:53]<ja> cabal calls 'ghc --make' when you build ;) i know that is not the answer you want, but i still don't understand why you want to avoid building with cabal...
09:45:04 <L29Ah> 19:36:29]<L29Ah> also i don't want to write metadata for single use chunks of code to build into tools
09:45:29 <ja> aah sorry, i missed that last one
09:45:44 <ja> i guess that is what people use those stack shebangs for
09:46:00 <ja> but yeah ok, i give up, dunno how to help you further
09:47:01 <dsal> The reason it's not easy is because you're doing it the hard way.  You could just do it an easier way.  *shrug*.  If you have a dump truck environment, you could make it a project.  If you don't like updating a local file to include a library, you could write a tool that adds it for you.
09:47:19 <dsal> I've got a ton of projects and have some common libraries, but I just have my stack default template load a bunch of those up.
09:47:56 <L29Ah> what
09:48:06 <L29Ah> v1-install is easy
09:48:30 <ja> global is always easy... in the beginning ;)
09:48:34 <dsal> Easy is kind of relative.
09:49:23 <L29Ah> ja: i'm poking into haskell for over 15 years, and it's still easy enough (;
09:51:09 <ja> L29Ah: even if you don't have a project, there is a -b flag for cabal repl for adding an ad-hoc dependency, that may work for you
09:51:53 <L29Ah> so it's an extra hassle of remembering the library set and adding new ones every time
09:53:23 <dsal> Related:  That's also the advantage of not installing globally.
09:54:28 <dsal> One of my project requires some stupid node.js toolchain thing for a package to do some javascript mangling from the output of the elm compiler it also requires.  Instead of remembering how to do that on the different machines with different operating systems I build for, I wrote a small nix file and it magically just works on fresh computer since also one of my machines died after starting that.
09:55:31 <ja> nix is a killing machine now? oh, the calamity :O
09:55:44 <dsal> Haha.  It was more the poorly designed mac keyboard.
09:56:00 <dsal> The machine still *worked*, but it was getting harder to type with fewer working buttons.
09:56:11 <L29Ah> it was supposed to be "docker" in that phrase, but "nix" was so much easier to type
09:57:19 <sm[m]> L29Ah: I don't know the trick with cabal, but with stack I get that simple global environment if I ln -s `stack exec -- which ghc` /usr/local/bin/ghc (and the same for ghc-pkg). 
09:58:38 <sm[m]> I agree that you should be able to (try to) have a simple global environment if you want to
10:00:10 <dsal> I used to use the stack global project, but i kept making it bigger and it kept confusing me.  :)
10:03:50 <mmaruseacph2> yeah, never use global
10:04:03 * mmaruseacph2 had to delete 80GB of global snapshots
10:06:42 * ezzieyguywuf ponders using haskell-igraph over fgl...
10:07:54 <sm[m]> ncdu ~/.stack is your friend!
10:08:44 <sm[m]> lame that we have to do that, I know
10:08:57 <ja> oh cool, that is like an upgraded 'du -sh * .??* | sort -h'
10:09:40 <ja> so many useful unix tips from you sm! :D
10:10:16 <maerwald> he must be an old greybeard :p
10:12:10 <sm[m]> urgh.. getting there..
10:13:08 <sm[m]> here's another: httping, I only yesterday realized it's Cool (add -YK)
10:15:32 <sm[m]> nice to have cli and tui in the same executable. ghcup has that, right maerwald ?
10:15:40 <maerwald> yeah
10:16:22 <sm[m]> +1. Let's hope the new ghc windows IO system will eventually lead to being able to do this on windows as well
10:16:24 <maerwald> it also allows to share the global cli config
10:16:34 <jle`> is there a popular 'free profunctor' in any library? i'm thinking something like Coyoneda but with both sides
10:16:51 <maerwald> e.g. ghcup --cache --verbose --downloader=wget tui
10:16:59 <jle`> data FreeProfunctor p a b = forall x y. FP (a -> x) (y -> b) (p x y)
10:17:51 <ja> sm[m]: but does it really make sense to have tui on windows? i mean in comparison with gui. windows people use gui's even for remote management, no?
10:19:52 <sm[m]> windows users are more diverse than that, ja. Also it simplifies development if you can ship the same thing for all platforms, whether it's used much or not
10:19:58 <maerwald> if I knew how to do windows... I might do it, but I don't :p
10:20:09 <glguy> We need a VB GUI!
10:20:37 <ja> glguy: vb.net or vb6? ;)
10:20:49 <ja> or maybe even ASP classic ? ;P hahahahaha
10:20:53 <L29Ah> VisualHaskell
10:20:54 <sm[m]> whatever you mean, I agree!
10:21:02 <glguy> ja: They don't specify https://youtu.be/60sE0w_n2Vs
10:22:08 <ja> windows is such a rabbit hole... if you wanted to integrate fully you'd have to offer some RMI service that people could control ghcup remotely using generic powershell commands , right ? :P hahahaha oh my, sounds like 10 years of work
10:23:01 <sm[m]> phyx has made a big contribution to move haskell's windows support forward
10:23:15 <jumper149> Is it possible to get rid of this warning: Warning: The package has an extraneous version range for a dependency on an internal library: my-package -any && ==0.1.0.0. This version range includes the current package but isn't needed as the current package's library will always be used.
10:23:42 <jumper149> I'm using cabal-version: >= 1.10
10:23:49 <sm[m]> jumper149: I think not, there's an open bug
10:30:50 <dmwit> jumper149: What does your .cabal file look like?
10:32:43 <jumper149> dmwit: https://github.com/jumper149/blumon/blob/master/blumon.cabal
10:41:01 <dsal> sm[m]: whatever ncdu is, it makes my computer very unhappy
10:43:20 <sm[m]> I guess you're scanning a lot of data ? maybe try on a smaller subset first. I think its about as quick as anything at doing this
10:44:39 <mmaruseacph2> wow, ncdu is awesome
10:44:51 <ja> regarding ghcup on windows: looks like ghcup uses brick for tui, brick uses vty, vty does not support windows: https://github.com/jtdaugherty/vty/blob/c97c03718d46ba84c299c6d046d6981523f9a178/README.md#windows
10:44:56 <sm[m]> and I've used it only on SSDs
10:45:45 <sm[m]> correct
10:49:24 <sm[m]> mmaruseacph2: you made me check out the website, and wow! colour! \o/ :)
10:54:23 <dsal> I was doing ~/.stack -- it's kind of big.
10:55:02 <dsal> 122k files.  Doesn't seem like it'd require *all* my RAM.
10:57:27 <ja> does it make sense to put instance type sigs in comments or should i just use InstanceSigs?
10:59:19 * hackage rocksdb-haskell-jprupp 2.1.1 - Haskell bindings for RocksDB  https://hackage.haskell.org/package/rocksdb-haskell-jprupp-2.1.1 (jprupp)
11:00:19 <ja> doesn't seem like InstanceSigs has any disadvantages
11:00:34 <hyiltiz> About ~/.stack, is it ok to remove the *-index.tar files but only leave the *.tar.gz? My 0{0,1}-index.tar are each 648.3MiB, while the compressed ones are merely 86MiB
11:00:37 <sm[m]> dsal: no it doesn't.. I haven't noticed it using much ram. (I'm a haskeller after all..) I see some small memory fixes at https://dev.yorhel.nl/ncdu/changes
11:01:22 <dsal> warning: dumping very large path (> 256 MiB); this may run out of memory  <-- That's what it says when I launch it.
11:01:23 <sm[m]> hyiltiz: if it's not, the tool will just replace them
11:01:35 <sm[m]> ouch, dsal
11:01:45 <sm[m]> at least it's kind enough to warn you 
11:02:09 <ja> dsal: could it be infinite path recursion?
11:02:26 <ja> maybe it would be easy to see with "ls -R"
11:02:27 <dsal> I don't know.  du works OK.  It's just ~/.stack
11:03:02 <ja> ls -R prints on-the-fly right, so if it keeps printing self-similar output, it could be infinite recursion
11:03:13 <ja> where is the pwd of a process stored? in kernel memory?
11:04:18 <davean> ja: PWD is a kernel thing
11:05:06 <ja> so it is feasible that some processes would be able to handle infinite path recursion without running out of memory, but some wouldn't
11:05:31 <davean> ja: Why do you think PWD is related to anything here?
11:06:47 <ja> davean: because i want to know if, suppose  that you descend into an infinite recursive directory tree, will you necessarily run out of memory or not? descending into that tree, the only thing that necessarily needs to change is your PWD, right?
11:07:37 <ja> if the kernel knows it is infinite, the kernel could make sure it doesn't consume linear memory though
11:07:49 <davean> Why would you use your PWD?
11:08:10 <ja> use it for?
11:08:14 <davean> Thats a very weird way to explore a disk
11:08:33 <dmwit> jumper149: probably a bug then
11:09:43 <ja> davean: if you don't use PWD, and you want platform independence, you'd have to know the details of bind mounts and symlinks for every platform, if you want to avoid linear memory usage, no?
11:10:59 <sm[m]> dsal if you ever find which file triggers that, I'd be curious
11:11:49 * hackage rocksdb-query 0.4.1 - RocksDB database querying library for Haskell  https://hackage.haskell.org/package/rocksdb-query-0.4.1 (jprupp)
11:11:58 <davean> ja: no you just move via reference.
11:15:43 <ja> davean: can you do in a platform independent way? there are no inodes on windows
11:15:46 <hyiltiz> Just deleted the *.tar files; let's hope nothing broke
11:17:05 <hyiltiz> Welp, it fails: /usr/bin/stack install relude
11:17:05 <hyiltiz> /home/hyiltiz/.stack/indices/Hackage/01-index.tar: openBinaryFile: does not exist (No such file or directory)
11:18:27 <sm[m]> doh. stack update ?
11:18:29 <mmaruseacph2> you might need to update stack
11:18:40 <mmaruseacph2> what is `/usr/bin/stack --version`?
11:19:18 <sm[m]> just an update should do
11:19:20 <mmaruseacph2> also, stack installs the updated one in ~, not in /usr
11:19:24 <dsal> sm[m]: The answer is:  I'm not very good at nix-shell.
11:19:51 <sm[m]> (but mmaruseacph2++)
11:20:15 <sm[m]> dsal ha! it's always a nix problem :)
11:20:40 <dsal> heh.  `--command ncdu ~/.stack` does not do what I thought it did.  I'm not quite sure what it does other than use all the resources.
11:20:50 <hyiltiz> stack update did fix it, and did NOT reintroduce the unpacked *.tar;
11:20:59 <hyiltiz> version 2.3.1
11:21:13 <davean> ja: which you'd never use - you'd use a file descripter or a handle
11:22:22 <sm[m]> hyiltiz: this is something that's nice in ~/.cabal: all the space hogging haskell deps are grouped by ghc version, I believe. In .stack you have to dig for them
11:23:08 <hyiltiz> yeah, the haskell toolchain is such a space hog I've stopped complaining and just accepted as facts :(
11:23:16 <hyiltiz> We are worse than even python here
11:23:56 <sm[m]> yes, but periodic garbage collection helps, as with nix, brew & all
11:24:42 <sm[m]> it's bad that the tools don't provide that yet
11:24:54 <sm[m]> just a matter of somebody getting annoyed enough, eh
11:24:59 <xsperry> any selenium users? what is Page.addScriptToEvaluateOnNewDocument equivalent? https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-addScriptToEvaluateOnNewDocument
11:25:34 <glguy> sm[m]: My GC cycle is: when a new version of GHC comes out I delete the previous ~/.cabal/store/ directory for the old one :)
11:25:54 <monochrom> The devs who has the suitable expertise to implement it are also devs who use company-paid 1PB disk workstations, naturally they don't feel the need.
11:26:52 <monochrom> Recall how they love cabal and stack to default to "jobs: $ncpu", too. Because they have company-paid 1TB RAM workstations.
11:27:06 <dolio> You can get a terabyte ssd for $50. You don't need to work for some huge company.
11:27:25 <sm[m]> not on a mac, dolio
11:27:47 <glguy> If you're buying a mac you're not exactly focused on thrift, though
11:28:07 <tdammers> I paid ~€100, but I must admit I didn't do a lot of market research and just bought the first one that looked reasonable and had 24h shipping
11:28:58 <glguy> dolio: Do you have to get a used one to get down to that price?
11:29:06 <monochrom> Well, then, therefore no one feels the need to GC the disk space used! Right?
11:29:09 <tdammers> I also have a hex-core CPU that cost less than €300 including mobo and RAM and a smalled ssd
11:29:15 <tdammers> smaller*
11:29:34 <sm[m]> regular joe mac users like me do, we're all disk-constrained
11:29:49 <dolio> Maybe I'm a little off. But even if it's $100, you don't need to work for some huge company.
11:30:01 <dolio> Huge companies pinch pennies on that type of stuff anyway.
11:30:03 <sm[m]> (and apparently a lot of haskellers do, because disk hogging is a frequent complaint)
11:30:16 <dsal> "How Accursed and Unutterable is accursedUnutterablePerformIO? by Ziyang Liu"
11:32:49 * hackage rocksdb-query 0.4.2 - RocksDB database querying library for Haskell  https://hackage.haskell.org/package/rocksdb-query-0.4.2 (jprupp)
11:34:15 <gentauro> I'm trying to use `aeson` to parse the result which can either be `{ value: […] }` or `{ error: ""}` I have created a separate `newtype` for each of the result types and I'm trying to parse eith with `Either` as `type Result a = Either Error (Value a)`. When I try to make an instance for my type alias, I get this error: "Overlapping instances instance (FromJSON a, FromJSON b) => FromJSON (Either a b)"
11:35:55 <int-e> dsal: it should've cited this (from bytestring): {-# DEPRECATED inlinePerformIO "If you think you know what you are doing, use 'unsafePerformIO'. If you are sure you know what you are doing, use 'unsafeDupablePerformIO'. If you enjoy sharing an address space with a malevolent agent of chaos, try 'accursedUnutterablePerformIO'." #-}
11:37:07 <dsal> Knowing is half the battle.  I guess realizing that you never actually knew is the other half.
11:37:45 <int-e> bytestring contains an astonishing 45(-ish) uses of that function. But I believe they're all morally pure: accessing the contents of a bytestring (which requires dereferencing the underlying foreign pointer)
11:37:54 <gentauro> so it seems that `aeson` supports `Either` out-of-the-box. My question is, how do I specify it's either one of my types. I found this on SO -> https://stackoverflow.com/questions/10339462/how-do-i-write-a-tojson-fromjson-instance-for-a-datatype-with-multiple-construct but it doesn't seem correct
11:38:16 <monochrom> My experience with some student is that knowing they are wrong is 90% of the battle.
11:38:31 * gentauro I would have expected some `… <|> …` but how can I defined this if I get "overlapping instances instance …"?
11:38:46 <int-e> The bytestring developers learned this the hard way... early bytestring had quite a few bugs like two bytestring allocations sharing the same space, all thanks to inlinePerformIO.
11:38:50 <sm[m]> int-e: ack, now I imagine tentacled horrors lurking under everything..
11:39:08 <dsal> monochrom: "half" is just a colloquialism that means 90%, I believe.
11:39:16 <monochrom> heh
11:39:30 <int-e> (and by that I mean two *different* bytestrings sharing the same space... it didn't go well :-) )
11:50:15 <ja> gentauro: what do you mean by "specify it's either one of my types"? why not try using aeson to deserialize into a type that is annotated, and it should complain about a missing instance? if the either instance in aeson has no tagging of the type (as i guess it can't have, otherwise it would not be general), it should fit your use case, no?
11:51:42 <monochrom> Depending on why you need it, perhaps don't use Either, use your own extra sum type.
11:53:06 <monochrom> In this case (I am not generalizing (why should I need to say this?)), overlapping instances is a symptom of not fully accepting the meaning of parametric polymorphism or type variables.
11:55:58 <ja> the meaning being that there should only be one canonical instance?
11:58:03 <monochrom> No. When you have "f :: Bounded a => a" for example, the user of f says which type they will get. The implementer has no choice.
11:58:26 <monochrom> This easily extends to "p :: Bounded a => Parser a" for example.
12:00:59 <monochrom> If you think p's type allows p to do this: "based in the input string, if it looks like a number, I return Int; if it looks like a letter, I return Char. Both are instances of Bounded, right? RIGHT?", then you haven't accepted that.
12:01:12 <monochrom> s/based in/based on/
12:01:54 <gentauro> monochrom: was your answer with regard of my question? I can see that I lost "internet for a few messages" :)
12:02:10 <monochrom> Yes.
12:02:29 <ja> gentauro: everything is already in logs: http://tunes.org/~nef/logs/haskell/20.07.23
12:02:40 <monochrom> I think you got all of mine, you just missed ja's.
12:02:48 <monochrom> <ja> gentauro: what do you mean by "specify it's either one of my types"? why not try using aeson to deserialize into a type that is annotated, and it should complain about a missing instance? if the either instance in aeson has no tagging of the type (as i guess it can't have, otherwise it would not be general), it should fit your use case, no?
12:03:19 * hackage rocksdb-haskell-jprupp 2.1.2 - Haskell bindings for RocksDB  https://hackage.haskell.org/package/rocksdb-haskell-jprupp-2.1.2 (jprupp)
12:03:41 <gentauro> but isn't this a case for the Either type?
12:03:48 <monochrom> Yes.
12:03:52 <gentauro> in the sense that there can be two outcomes
12:04:07 <int-e> monochrom: what would a good UI for garbage collection look like though? You have to identify roots... probably by interrogating the user, but you shouldn't ask too many questions.
12:04:22 <monochrom> Except aeson has already hijacked Either, so the json format isn't going to be the format you want.
12:04:29 <gentauro> so I find it a bit redundant that now I need to create a sum type `data FooBar = Foo Value | Bar Error` to handle what Either should be handling
12:04:41 <int-e> (In the cabal/stack context. Does nix deal with this in a nice way?)
12:04:43 <gentauro> monochrom: Oh, I see
12:05:15 <monochrom> So you have to define your own sum type just so you have fresh control of its json format.
12:05:17 <gentauro> I will go with the sum type then
12:06:19 * hackage haskoin-node 0.16.0 - P2P library for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-node-0.16.0 (jprupp)
12:06:32 <monochrom> int-e: I think command line arguments enumerating the root projects.
12:06:46 <monochrom> or root packages
12:08:13 <frdg> How can I render a table in a yesod handler? I have made a table using tabular, which is really just a fancy string. The problem though is that the table only formats correctly when I use it with putStrLn. I am not sure how I can perform a straight up side effect in a handler.
12:09:10 <sm[m]> int-e: good question. v0.1: require the user to run a gc/cleanup command manually, which fires up ncdu 
12:10:05 <sm[m]> v0.2, print a ghcup-style list of installed ghc versions and their sizes and allow deletions. Deleting a ghc would also delete the deps built for it
12:10:11 <monochrom> err what is ncdu? :)
12:10:23 <ja> monochrom: so aeson sacrificed generality for convenience? this is what you mean by 'hijacked'? they gave you an instance that doesn't work for all cases
12:10:32 <sm[m]> monochrom: we had a whole chat about it an hour ago, how could you miss it :)
12:13:26 <dolio> The aeson instance works for treating Either as a tagged union serialized to JSON.
12:13:50 <monochrom> I thought an hour ago was like PWD
12:13:52 <dolio> If you expect it to try parsing each of the types in turn, with no tagging, then that isn't what it does.
12:17:13 <ja> dolio: but the definition of Either has no law saying that the encoding of its parts should be distinguishable, how is this a safe assumption to make? this is what 'hijacking' is, no? taking a type, assuming extra things about it. like all partial functions
12:17:13 <monochrom> ja, in this case, it's convenience and letting other people choose the format.
12:17:49 * hackage cut-the-crap 1.1.0 - Cuts out uninteresting parts of videos by detecting silences.  https://hackage.haskell.org/package/cut-the-crap-1.1.0 (Jappie)
12:18:24 <koz_> Lol, what a refreshingly literal package name.
12:18:32 <monochrom> it "works" to the extent of "there exists some json format that has a good correpondence to Either x y, even regardless of x and y (so it's general, too)". but someone else, not you, chose that "some" format.
12:18:59 <dolio> I think the aeson instance for Either is the sensible one to have, and the other thing should be accomplished a different way.
12:19:02 <monochrom> In particular, aeson has already chosen for you the field name and the possible field values for the tag. And there will be a tag.
12:20:08 <dolio> If you want to try to parse one of two possible things without tagging, you get that by using (<|>) in the parser. It would not be normal to just expect Either to be used for that.
12:22:15 <ezzieyguywuf> hm, if I have `initialState :: MyState (a, a)` and `useVals :: a -> a -> MyState ()`, I can do `initialState >>= uncurry useVals`. How can i use a similar concept to swap the two a's?
12:23:16 <monochrom> How much would cut-the-crap cut away from A Quiet Place? >:)
12:24:05 <int-e> or 4'33'
12:24:06 <dolio> It seems like the entire motivation is for said backtracking parser to be named fromJSON, which is unnecessary.
12:24:17 <int-e> err, missing a '
12:25:04 <ja> is it correct to say "without tagging"? i feel that they are already tagged, the problem is that aeson doesn't know how. the instance could be "instance (FromJson a, FromJson b, Tagged a, Tagged b) => FromJson (Either a b)"
12:25:34 <dolio> What if a = b?
12:25:40 <dolio> Which case is it?
12:26:23 <ja> ;) oh right, needs :~:     :P damn
12:26:40 <int-e> monochrom: tbh I don't think it'll work. The crap (intros etc) tends to have a soundtrack (mostly annoying music).
12:26:44 <dolio> No, you just need to not be thinking in terms of set theory or something.
12:28:32 <sm[m]> koz_: I think it'd be a better name if it cut out crap speech :)
12:28:54 <sm[m]> or ads 
12:29:37 <dolio> If tagging can be accomplished by having different field names or something for a particular case, then a custom sum type with that format can be used, but it doesn't seem reasonable to me to expect the generic Either behavior to be that, or to leave out an Either instance so people can define orphans for that purpose.
12:30:18 * hackage cut-the-crap 1.2.0 - Cuts out uninteresting parts of videos by detecting silences.  https://hackage.haskell.org/package/cut-the-crap-1.2.0 (Jappie)
12:30:24 <dolio> Especially since it isn't really that much work to just write the disjunction parser.
12:32:46 <ezzieyguywuf> hm, I guess `initialSteat >>= (uncurry useVals) . swap` does what i want
12:35:53 <gentauro> I made some hacker FP logos so they can match my blog -> https://imgur.com/a/srbmqKz (feedback) xD
12:36:19 * gentauro Remark: I'm colourblind (so it's all based on `hex` values) xD
12:36:43 <Athas> What's that first one?
12:36:52 <Athas> Implication and less-than-or-equal?
12:36:56 <gentauro> Athas: they told me it's Futhark
12:37:21 <monochrom> That looks very close to the logos of many public transit/train systems. :)
12:38:22 <gentauro> monochrom: link? :)
12:40:27 <monochrom> https://en.wikipedia.org/wiki/Kowloon%E2%80%93Canton_Railway
12:40:42 <frdg> is the equivalent of spaghetti code in haskell imports that are all over the place? For example say I have three modules, m1, m2, and m3. Is it bad to have m1 import m2 and m3, while also having m2 import m3?
12:40:48 <ja> gentauro: or this one https://www.google.com/search?q=uk+rail+symbol&tbm=isch
12:41:59 <merijn> gentauro: If it was the Futhark logo I'm sure Athas would've recognised it :p
12:42:22 <gentauro> frdg: I would say it's the right way to do it (or at least is the way I do it)
12:42:36 <merijn> frdg: Yes, no, maybe
12:42:52 <gentauro> you place common logic in separate modules, which can be cosumed by several other modules
12:43:05 <sm[m]> frdg: it's pretty common, not the end of the world
12:43:05 <Athas> frdg: imports can be confusing, but I would say that the Haskell equivalent to spaghetti code is a mess of mutually recursive functions.
12:43:10 <gentauro> I think I see a lot of modules that import and then share
12:43:26 <merijn> gentauro: This one among others: https://en.wikipedia.org/wiki/Nederlandse_Spoorwegen :p
12:43:38 <gentauro> merijn: I'm aware of that ;) 
12:44:03 <Athas> I suggest the Henning Thielemann approach to library design, as this will focus all your defects into a single large super-defect (incomprehensible Haddocks).
12:44:13 <merijn> lol
12:44:20 <merijn> Please don't
12:44:26 <merijn> I swear I will hunt you down and hurt you
12:44:27 <gentauro> monochrom: merijn: I didn't knew that. Pretty crazy that PS logo is so alike to many train logos
12:44:30 <gentauro> :|
12:44:34 <frdg> gentauro: So you are saying that my module example is not poor practice?
12:44:46 <merijn> frdg: It's not *necessarily* poor practice
12:44:58 <merijn> frdg: It might be, it all depends
12:45:02 <gentauro> frdg: from my experience no, but it's an opinion
12:45:38 <Athas> frdg: I do that kind of stuff all the time.
12:46:13 <gentauro> frdg: I guess the conclusion you can read is that we all do it ;)
12:46:16 <Athas> Consider this: Say that you have some module Foo that uses Data.Set for some internal things.  Then you have a module Bar that uses both Foo and also Data.Set for its own set purposes.  Is that really bad design?
12:46:22 <Athas> It's hard to see any other way of doing it.
12:47:06 <polyphem> frdg: check out this talk ; it addresses pest practices in haskell project design . https://skillsmatter.com/skillscasts/10832-how-to-architect-medium-to-large-scale-haskell-applications
12:47:22 <frdg> Thanks for the insight. I have been very congnizent to keep common logic in seperate modules. I am trying extremely hard to keep things from getting complicated in the future.
12:47:35 <frdg> polyphem: thanks
12:48:01 <polyphem> frdg: it is really enlightening i find
13:32:40 <jgt> is there a way to get a filename of some file at compile time? Basically I have a file like /some/path/index.s0m3hash.js and I don't know the s0m3hash string ahead of time, but I need it at compile time so I want to match on a glob like index.*.js
13:36:02 <monochrom> plugin or TH
13:36:43 <monochrom> I am not sure if cabal has a feature for that
13:36:49 <jgt> monochrom: yeah I would have thought TH, just not sure exactly how. Will have to do a bunch of exploration
13:37:17 <jgt> cabal has the paths API, but I'm not sure if that would help me in this case
13:37:28 <jgt> I think that's just if I know the file name but I don't know the full path
13:38:30 <dsal> side-effects in the compiler is super haskell
13:39:27 <jgt> I'm a super neophyte
13:39:32 <monochrom> In the TH Q monad, you can do arbitrary I/O, you can try looking for filenames.
13:41:26 <archaephyrryx> anyone know of streaming parser-combinators that can achieve higher performance than attoparsec?
13:42:01 <jgt> monochrom: oh… does that mean I could use System.Directory.getDirectoryContents inside a TH Q qq?
13:42:18 <monochrom> Yes.
13:42:34 <jgt> Cool! That sounds like a path forward. Thanks!
13:56:58 <ezzieyguywuf> is there a way here to use `runState` rather than `evalState` and `execState` separately? https://gitlab.com/ezzieyguywuf/mycad/-/blob/drawEntity/Entity/src/Entity.hs#L175
13:57:29 <ezzieyguywuf> (If you can't tell, I'm quite fond of this runMaybeT pattern that has been shared with me recently ^_^)
14:01:53 <c_wraith> you can pattern-match the output of runState and then bind edge using one of those components.
14:02:26 <ezzieyguywuf> c_wraith: what do you mean "bind edge"
14:02:29 <ezzieyguywuf> oh, "<-"
14:02:38 <c_wraith> yep
14:03:12 <ezzieyguywuf> well, I need both the value and the state
14:03:20 <ezzieyguywuf> but I think I follow, I see how that looks
14:03:26 <ezzieyguywuf> though it seems pretty legible as-is
14:04:19 <dsal> I never realized <- is basically a knife.  Nice.  That makes sense now.
14:04:36 <ezzieyguywuf> a knife?!
14:09:28 <archaephyrryx> anyone know of streaming parser-combinators that can achieve higher performance than attoparsec?
14:13:49 * hackage azimuth-hs 0.1.1 - Interact with Azimuth from Haskell  https://hackage.haskell.org/package/azimuth-hs-0.1.1 (JaredTobin)
14:22:15 <rand809809> Hi I have a container f and a bunch of operations which I can do on the container. The issue is that these operations produce a Maybe f. So, I'm having trouble composing these operations
14:22:40 <rand809809> cause I'm having to extract the f from the maybes to do another operation
14:22:43 <rand809809> Any solutions?
14:23:46 <koz_> rand809809: You can work entirely in the Maybe monad - that can sometimes help.
14:24:04 <rand809809> So, make all of the operations take a Maybe f and not an f?
14:24:19 <koz_> So you basically write something like 'maybe [some default] $ do [all your operations in Maybe monad]', say.
14:24:35 <koz_> It would help if you described what you're trying to do.
14:25:54 <rand809809> I was trying to implement the variable elimination algorithm
14:25:54 <rand809809> https://gist.github.com/bananabrick/08144fad41a80f089d85eee769b4c99b
14:29:15 <rand809809> An example of an operation is `multiply`
14:31:51 <monochrom> This is very long. What should I focus on?
14:32:04 <monochrom> Oh, multiply, sorry
14:32:18 <rand809809> Honestly, I don't think the code is relevant.
14:32:35 <rand809809> and I think doing all my operations in Maybe monad using do
14:32:36 <rand809809> makes sense
14:32:43 <rand809809> so I'll do that
14:32:44 <monochrom> Yes
14:32:46 <dsal> I'd get rid of validMultiply as well.
14:33:04 <rand809809> Why?
14:33:40 <dsal> Well, as a thing that takes two things and returns a bool..
14:34:08 <rand809809> ?
14:34:13 <rand809809> Not sure what you mean
14:34:24 <monochrom> OK, keepBest can be helped by >>=.
14:34:27 <dsal> You could use it a lot more easily by having  a guard, *or* you could have it return a `Maybe (Figure -> Figure)` or something.
14:35:19 <monochrom> varFromName varName vars >>= \var -> pure (Figure newVars finalRows)
14:35:41 <monochrom> to be sure, mine is pseudocode. In reality it's more like:
14:36:11 <monochrom> varFromName varName vars >>= \var -> let { here be definitions of newVars, finalRows, etc, based on var } in pure (Figure newVars finalRows)
14:36:26 <monochrom> there is also a do-notation form
14:37:24 <rand809809> oh true
14:37:36 <rand809809> I didn't have to write those `cases` by myself
14:38:07 <monochrom> Whenever you write "Nothing -> Nothing; Just x -> ..." it's >>=
14:38:34 <monochrom> If you like, you can further cut down the special case "Nothing -> Nothing; Just x -> Just (f x)" to fmap f. >:)
14:39:13 <monochrom> I think "restrict" can't be done with fmap, you really need >>= there.
14:39:25 <monochrom> but keepBest looks like fmap.
14:40:05 <monochrom> But you don't always have to "simplify to fmap as much as possible". You can have some personal style and preference here.
14:41:45 <rand809809> Not sure how keepBest would work with fmap
14:41:54 <rand809809> I need to use the result of varFromName
14:43:08 <hyiltiz> Is there a simple way to *trick* lazy evalution? I.e. can we implement f :: Int -> (a->b) -> (a->b) s.t. f 9 g returns g' that runs g 9 times while in fact only one of the computation result is needed/used? 
14:43:16 <hyiltiz> without using seq etc.
14:44:58 <phadej> what would be the point of running g 9 times, it would return the same result nor cause side-effects
14:45:07 <hyiltiz> yes
14:45:42 <dolio> What does it mean to run g nine times? Do you mean that `g' x` evaluates `g x` 9 times?
14:45:45 <hyiltiz> it is *pointless* in the sense that is doesn't accomplish anything; it is pointful in the sense that we learn how to *circumvent* lazy evaluation
14:46:40 <hyiltiz> dolio: `f 9 g $ x` would evaluate `g x` 9 times but only one computation is needed
14:48:31 <hyiltiz> Specified less awkwardly but more vaguely, how do we make a lazy evaluating compiler like GHC do more things than needed in functionally pure manner?
14:48:58 <dolio> Without seq I don't think you can do anything like that polymorphically, but for more structured types you can use case analysis to accomplish the same thing as seq.
14:50:59 <hyiltiz> Thx! Is that a (mathematically) proven result ("Without seq I don't think you can do anything like that polymorphically")?
14:51:11 <hyiltiz> Not sure what the second clause of your response means ;(
14:51:26 <hyiltiz> could u elaborate a bit/point me somewhere to learn?
14:53:29 <dolio> It means that if b is instead (c,d), then you can do things like `case g x of (_,_) -> ...`.
14:55:07 <hyiltiz> oh right stuff between case and of is *always* evaluated, right?
14:55:18 <dolio> But if b is completely abstract, there are no constructions that tie evaluation of something to evaluation of values of `b` that are not essentially seq.
14:55:33 <dolio> No, it is not always evaluated.
14:55:47 <dolio> `case g x of _ -> ...` is the same as `...`
14:57:21 <hyiltiz> Is there some mathematical theory that guarantees only seq (or our own implementation of seq) can do this? Aka how many variants of seq are there?
14:59:35 <hyiltiz> What would happen if I create [g, g, .., g] with 9 elements, fmap x over them and take heads unti lI reach the end and return the last result? Would it be discovered by GHC and simplified out?
15:00:51 <dsal> I don't think ghc looks at runtime data to make compiler optimizations.
15:00:53 <archaephyrryx> that gets into list fusion and compiler optimization and rewrite rules
15:00:54 <dolio> You need to read somewhere about how lazy evaluation works. It's not inspecting symbolic code or something.
15:01:19 * hackage hal 0.4.2 - A runtime environment for Haskell applications running on AWS Lambda.  https://hackage.haskell.org/package/hal-0.4.2 (nikeoss)
15:02:30 <dolio> There is just no language construct that can demand the evaluation of a completely abstract type other than seq, or things that are ultimately defined in terms of seq.
15:04:48 <ezzieyguywuf> c_wraith: pretty sure this is what you were describing https://dpaste.com/988PDLBWJ
15:04:56 <dolio> If you do the thing with the list, you will have 9 unshared values, but no way to evaluate the other 8 just because the 9th is evaluated.
15:05:08 <ezzieyguywuf> i think it was more legible before though, honestly. Though it's a shame to access/unwrap the State twice
15:06:05 <c_wraith> nah, I just meant let (topology', edge') = runState ... ; edge <- ... edge'
15:07:30 <ezzieyguywuf> c_wraith: ah
15:09:08 <ezzieyguywuf> hah, nope still don't see it. does one of the ellipses include a case?
15:09:35 <ezzieyguywuf> I guess I could do `case edge of`
15:09:38 <archaephyrryx> anyone know of efficient streaming parser-combinators other than attoparsec
15:09:53 <c_wraith> no case.
15:10:18 <dsal> archaephyrryx: any reason you don't like attoparsec?  I've used it in that case and I don't know what to complain about.  :)
15:10:26 <dolio> There could be a language that lets you do other things with values of completely abstract types, which might induce evaluation, but Haskell doesn't have that.
15:10:29 <c_wraith> ezzieguywuf: edge <- MaybeT $ pure edge'
15:10:43 <archaephyrryx> it's what I am currently using and I am trying to squeeze more performance out of my code
15:10:56 <hyiltiz> hmm, can we introduce a seemingly dependency between them (chain them) s.t. it would seem a chain but in fact just independent 9 expressions, by embedding arbitrary things like busy beaver function etc.?
15:11:24 <hyiltiz> i read about Core; where can i read on lazy evaluation? any recommendation?
15:11:31 <ezzieyguywuf> c_wraith: a hah! I like that, thanks so much.
15:12:50 <hyiltiz> dolio: not sure what "that" in ur last sentence meant
15:13:24 <c_wraith> it's exactly the same code you had before, just using runState to avoid calling evalState and execState separately. you know, what you asked about. :P
15:13:43 <dolio> "That" is the hypothetical thing you can do on values of abstract type.
15:13:49 * hackage hal 0.3.1 - A runtime environment for Haskell applications running on AWS Lambda.  https://hackage.haskell.org/package/hal-0.3.1 (nikeoss)
15:14:12 <ezzieyguywuf> c_wraith: lol, sometimes can't see the forest for the trees
15:14:53 <ezzieyguywuf> i still have an itch, watching to get rid of that `gets` and/or using '>>=' somehow, but now I think I'm just code golfing for no reason
15:14:55 <dolio> Java lets you get a hash code of any value, regardless of type.
15:14:57 <hyiltiz> Would you please kindly give an example of such a thing u can do with an abstract type that *will* induce evaluation? (except say an eval function)
15:15:38 <koala_man> non-primitive type
15:16:17 <dolio> Yeah. In something more like Haskell the primitives just wouldn't exist. Just the boxings.
15:17:19 * hackage GPipe-GLFW 1.4.1.3 - GLFW OpenGL context creation for GPipe  https://hackage.haskell.org/package/GPipe-GLFW-1.4.1.3 (plredmond)
15:18:24 <hyiltiz> What can you then use the hash code for? I am thinking of code pages and pointers
15:18:50 <dolio> They use it for hash tables, for instance.
15:19:22 <dolio> I don't see what difference it makes. If you get a hash code, you can presumably inspect the hash code further.
15:19:34 <dolio> Because hash codes are a known type with operations.
15:19:41 <archaephyrryx> dsal: attoparsec isn't bad I just want to see if I can do better performance-wise with a different parser-combinator
15:21:20 <hyiltiz> Somehow I thought this would relate to the halting problem; it doesn't seem directly relevant then
15:22:17 <dsal> archaephyrryx: yeah, not sure.  My stuff is fast enough that I've not even bothered profiling.
15:22:19 <monochrom> archaephyrryx: There is yoctoparsec, but I don't know how fast it is, or other things.
15:23:24 <monochrom> Perhaps it's just trying to be small.
15:24:14 <dsal> I assume it's just trying to appeal to executives.
15:24:52 <monochrom> Interesting, it let's you choose between Maybe, [], StateT Maybe, etc.
15:25:34 <dolio> I don't think it has anything to do with the halting problem.
15:26:56 <crestfallen> hi please see the last line of this paste. https://termbin.com/k5to A member pointed out that equality yesterday. I've been trying to write a similar equality for the increment function, using the minimal instances of the functors, to get more insight to what is going on.
15:27:09 <monochrom> Yeah yoctoparsec just means to be barebone. You will have to re-invent a lot of wheels to use it for real.
15:27:44 <crestfallen> but haven't been able to write it
15:27:50 <archaephyrryx> writing an abstract API around an arbitrary monadic parser would be necessary anyway if I wanted most of my codebase to remain relevant after changing parsers
15:28:48 <archaephyrryx> so it's not like using yocto would be more work than I would have to do anyway, provided I can work out the right typing
15:29:16 <monochrom> I think "FreeT ((->) t) b a" is not a recipe for performance.
15:29:19 * hackage commonmark 0.1.0.1 - Pure Haskell commonmark parser.  https://hackage.haskell.org/package/commonmark-0.1.0.1 (JohnMacFarlane)
15:29:45 <dolio> Doesn't seem like it.
15:30:41 <crestfallen> sorry error in that line of paste. correcting...
15:31:41 <crestfallen> correction : https://termbin.com/z37t
15:32:18 <archaephyrryx> it's certainly small, but I agree that it probably can't be that fast
15:32:30 <hyiltiz> dolio: ++
15:34:29 <hyiltiz> Learned a few things trying to "hack" lazy evaluation, thanks!
15:34:43 <hyiltiz> Any recommended readings on this (except wikipedia etc.)?
15:37:14 <dolio> No, I don't know.
15:42:35 <crestfallen> hi if anyone would like to look at the last line, commented out on this paste. my question is above in the chat  https://termbin.com/z37t
15:43:25 <crestfallen> I'd like to write a similar equality for the function 'increment'
15:52:30 <archaephyrryx> crestfallen: the functor definition only applies to the `a` type of `State s a` so no functor methods can directly access the `s` type
15:53:15 <crestfallen> thanks archaephyrryx processing that...
15:55:37 <archaephyrryx> crestfallen: the first equivalence emerges because `return` is equivalent to `pure` and `fmap` is really `ap . pure` 
15:57:14 <crestfallen> so in the instances of Functor/Applicative we have (State s) where ...  archaephyrryx ok so since put :: s -> State s () , there is no 'a' type, so we cannot write anything that applies to the 'a'
15:58:43 <archaephyrryx> crestfallen: at the very least you should try to inline the expression and reduce it according to method definitions
15:59:27 <crestfallen> sorry please elaborate archaephyrryx not following this well..
16:00:50 <crestfallen> also if you could verify my post above beginning "So in the instances..."
16:01:19 <archaephyrryx> crestfallen: `increment = S (\s -> let (s', v) = runState get s in runState (put (v+1)) s')`
16:01:50 <archaephyrryx> crestfallen: btw you don't actually need the second term in the let statement for bind since you use the LHS wholesale in the next line
16:02:54 <archaephyrryx> crestfallen: `increment = S (\s -> runState (put (s+1)) s)`
16:04:14 <archaephyrryx> crestfallen: `increment = S (\s -> runState (S (\s -> (s+1, ())) s)`
16:04:33 <archaephyrryx> crestfallen: `increment = S (\s -> (s+1, ()))`
16:05:34 <archaephyrryx> crestfallen: if you substitute in definitions and perform reductions you eventually arrive at that equivalence
16:06:36 <crestfallen> archaephyrryx, that's interesting .. I'll be working on that for a bit .. thanks kindly
16:07:11 <hseg> am getting spurious -Wunused-packages errors. curiously, if i turn on -fkeep-going they go away. wtf?
16:16:54 <crestfallen> archaephyrryx, just to mention, the second term in the let statement would not be considered redundant, if the bind was written for purposes of instruction, right? but I do see what you mean, and you pointing that out is helpful
16:19:22 <crestfallen> no sorry, we do need that right? because we are renaming the values s'' and w, as results of running State on the new s'   archaephyrryx 
16:20:12 <archaephyrryx>  x >>= f = S (\s -> let (s', v)  = runState x s in runState (f v) s' 
16:20:54 <archaephyrryx> you use s'' and w immediately on the next line without any rearrangement
16:22:19 <crestfallen> man, that is a can of worms! thanks I need to work on that.
16:24:48 <archaephyrryx> to be clear it isn't actually an issue but it is redundant to bind to an LHS you use immediately as the RHS of the overall expression
16:31:39 <crestfallen> archaephyrryx, please take a look, I'm getting parse error (indentation/mismatched brackets) with this: https://termbin.com/ely8
16:36:55 <MarcelineVQ> correct, you're missing a bracket as you claim, you can count the ( and ) one at a time to determine which is missing
16:37:36 <crestfallen> sorry yeah thanks MarcelineVQ 
16:39:31 <hseg> am getting spurious -Wunused-packages errors. curiously, if i turn on -fkeep-going they go away. wtf?
16:56:15 <hseg> ... even weirder, cabal picks up the --ghc-options=-fkeep-going from the command line but not from .cabal or cabal.project.local
17:02:00 <mniip> does dependency closure of lens have an implementation of natural transformations somewhere
17:02:26 <crestfallen> MarcelineVQ, there's a lot to understand on that paste. I want to really nail it. I'm not clear on the minimal definitions .. I've never seen 'ap' , but today was a good session. thanks
17:03:02 <mniip> I see the right kan extension but maybe there is a more direct encoding
17:03:49 * hackage neuron 0.6.0.0 - Future-proof system for plain-text notes.  https://hackage.haskell.org/package/neuron-0.6.0.0 (sridca)
17:09:19 * hackage hal 0.2.2 - A runtime environment for Haskell applications running on AWS Lambda.  https://hackage.haskell.org/package/hal-0.2.2 (nikeoss)
17:12:58 <mniip> I'm looking for a tau type btw
17:20:01 <superstar64> are there any examples of type safe embedding of other languages in haskell on hackage?
17:23:08 <ja> superstar64: what about squeal?
17:23:21 <ja> (postgresql)
17:24:16 <superstar64> something like what's discussed in oleg's tagless final paper
17:25:20 * hackage hal 0.1.4 - A runtime environment for Haskell applications running on AWS Lambda.  https://hackage.haskell.org/package/hal-0.1.4 (nikeoss)
17:33:34 <mniip> ah hmm I could codensity encode it
17:35:17 <Axman6> superstar64: there's https://hackage.haskell.org/package/inline-r
17:35:52 <Axman6> https://hackage.haskell.org/package/inline-c too
17:38:44 <ezzieyguywuf> anyone here ever messed around with agda?
17:40:01 <Axman6> agda messes with you
17:40:10 <ezzieyguywuf> lol, in what way?
17:42:50 <ezzieyguywuf> oh boy, "At the time of writing, it is only really feasible to edit Agda code using Emacs"
17:42:54 <ezzieyguywuf> that's probably a hard stop for me.
17:43:19 <dolio> Why?
17:43:25 <sm[m]> hah, Agda's not for the likes of you!
17:43:54 <ezzieyguywuf> sm[m]: lol indeed.
17:44:04 <ezzieyguywuf> dolio: b/c I use vim..🙄
17:44:17 <dolio> evil is good enough for doing agda.
17:44:47 <ezzieyguywuf> meh, I'll consider it in the future, when I'm further along my haskell journey
17:45:25 <dolio> There's a vim mode, too, but it isn't nearly as good.
17:45:28 <sm[m]> what's easier to learn: haskell or agda ? serious question. Maybe agda has less confusing tools & stuff ?
17:45:29 <MarcelineVQ> I used atom just fine for agda
17:45:52 <dolio> Atom is probably way worse if you want vim.
17:45:56 <ezzieyguywuf> I can say this: coming from python/c++, moving to haskell has been quite illuminating. It's highlighted for me ideas/concepts that were previously hidden behind a cloud of pre-ordained design patterns and whatnot. haskell's extra explicitness has helped me to get a better understanding of how programming "works" and of how to make the computer do what I want
17:45:57 <MarcelineVQ> sm[m]: depends on who you have access to to ask questions imo
17:46:17 <ezzieyguywuf> I imagine moving towards agda may result in more similar such revelations, i.e. it seems to not even ship with a number
17:46:18 <sm[m]> doesn't agda have good docs ?
17:46:23 <MarcelineVQ> I was able to pick up agda because I knew haskell, but even moreso because I had people to ask
17:46:44 * sm[m] imagines life with no cabal, stack, ghc, hackage...
17:46:58 <MarcelineVQ> It has docs, good depends on what corner you ran into where the docs suddenly stop :>
17:47:14 <sm[m]> what do they have left to talk about ?
17:48:19 <sm[m]> agdaish things I couldn't possibly understand no doubt
17:48:37 <MarcelineVQ> I don't understand the question :X
17:49:12 <dolio> They still talk about cabal, because they can't read the error messages when installing Agda.
17:49:27 <sm[m]> I'm just blathering MarcelineVQ. I wondered what they talk about without all the tooling issues that occupy haskellers
18:47:01 <christo> hi, having errors installing ghcup on mac
18:47:37 <christo> "_eghcup --cache install ghc recommended" failed!
18:49:08 <fog> as far as i can tell, criticisms of haskell as inferior to dependent languages, based on haskells treatment of singletons
18:49:19 <fog> then lead to a consideration of system F
18:49:36 <fog> is it better to be able to express singletons *within* the language
18:49:44 <fog> or as a part of its construction
18:50:10 <fog> then, is it that a more expressive language *is required* to handle singletons as haskell does
18:50:32 <fog> so then making it superior by necessity of this mechanism for expressing singletons
18:50:48 <fog> than a language which had them "baked in" from the beginning 
18:51:36 <fog> would system F collapse down, if the singletons mechanism was placed there, and the other rules required for its implementation *within* haskell syntax, were ommited
18:59:51 <monochrom> sm[m]: Consider hugs. https://www.haskell.org/hugs/  >:)
19:00:48 <monochrom> Simpler error messages like "type X doesn't match type Y" (so none of those "inferred" "expected" business).
19:02:16 <monochrom> Old cabal-install knows hugs. (Not sure about new, or even mediumly old.) But probably you don't even need it. hugs is a bloody interpreter. Just unpack source somewhere and adjust search paths.
19:03:31 <monochrom> small memory footprint and disk footprint
19:05:16 <monochrom> Completely discourages brute-forcing PE questions "hi I'm brute-forcing PE#42 to learn haskell [sic] how do I hand-micro-optimize my code to reduce from 2 hours down to 0.2 seconds"
19:05:45 <monochrom> "if I add strictness annotation will that make my code 100000x faster?"
19:10:41 <koz_> Strictness annotations clearly make you a 10000x developer. :P
19:12:36 <wroathe> monochrom: I tend to assume the the best compiler in any ecosystem is the one with the most active contributor-base. Where does Hugs fall short of GHC?
19:12:53 <wroathe> monochrom: It can't be just as simple as GHC + awesomesauce. There's a cost to everything.
19:12:55 <glguy> One way is that it's not a compiler
19:13:14 <wroathe> Oh, I thought Hugs was another Haskell implementation?
19:13:21 <solonarv> yes, it is
19:13:26 <solonarv> it is an interpreter
19:13:33 <wroathe> Ah
19:15:14 <solonarv> to answer your other question: they have different language extensions (mostly, GHC has more, but I think Hugs has some sort of record system)
19:15:23 <solonarv> and then you have the usual compiler vs. interpreter tradeoffs
19:15:30 <monochrom> hugs converts type errors to runtime errors without needing -fdefer-type-errors >:)
19:15:53 <monochrom> hugs has an extensible record system that rivals OO
19:16:00 <monochrom> TREX
19:16:50 <glguy> better fundep support
19:17:01 <monochrom> but you're right, no one updates hugs. It may become harder to build or install today.
19:17:19 <koz_> monochrom: Is there a writeup of TRex somewhere I can read?
19:17:26 <koz_> (as in, how it works, not how it's implemented)
19:17:34 <monochrom> I forgot. There was.
19:17:49 <solonarv> surely Hugs has some sort of manual or documentation explaining its features?
19:18:17 <monochrom> https://www.haskell.org/hugs/pages/hugsman/exts.html#sect7.2
19:18:19 <glguy> Same for Windows for Workgroups 3.11
19:18:51 <monochrom> Hey I still have those floppies!
19:19:56 <monochrom> No, I don't have those floppies. I saved the floppy images on a USB flash stick and threw away the physical floppies.
19:20:26 <monochrom> The idea being it makes no difference if I install it in virtualbox.
19:21:21 <MarcelineVQ> calling 3.5"'s floppies never made sense to me anyway
19:21:45 <c_wraith> it would if you took one apart
19:21:59 <sm[m]> It’s kind of surprising no one has picked up at least minimal hugs maintenance, it sounds interesting
19:22:43 <MarcelineVQ> is a shellfish still a shellfish if you take out of its shell? it's not even a fish at that point!
19:23:01 <c_wraith> a hard disk is still hard if you take it apart.
19:23:11 <c_wraith> that's a significant difference
19:23:25 <MarcelineVQ> what if i take it apart using formic acid
19:23:43 <c_wraith> anyway, it's a floppy *disk*, not a floppy *disk and protective shell*
19:23:49 * hackage recursion-schemes 5.2 - Representing common recursion patterns as higher-order functions  https://hackage.haskell.org/package/recursion-schemes-5.2 (gelisam)
19:23:51 <glguy> Maybe the hard disk is software until you break the case; the air exposure causes it to become rigid :nod:
19:24:09 <monochrom> haha
19:24:27 <hyiltiz> Given Haskell 98 and 2010 reports, is it possible that there may be another coming sometime soonish?
19:24:47 <monochrom> Schrödinger's disk.
19:24:57 <solonarv> monochrom: thanks for that link: Trex does indeed look quite nice
19:25:05 <glguy> hyiltiz: Probably not
19:25:39 <monochrom> Yes every year someone says "probably next year".  Now use co-induction.
19:27:31 <hyiltiz> Hmm reminds me of GRRM
19:30:59 <monochrom> shellfish is not called floppy invertibrates though :)
19:35:16 <glguy> But they do call it a "Fisherman's Platter"
19:35:19 * hackage shake-ats 1.10.4.2 - Utilities for building ATS projects with shake  https://hackage.haskell.org/package/shake-ats-1.10.4.2 (vmchale)
19:35:27 <monochrom> hahaha nice
19:55:35 <sureyeaah> Where can I read about the underlying theory behind Haskell? I guess the type system (?), I'm not sure. I recently went through "SPJ's Implementing functional languages: a tutorial" and am not sure what the next step should be.
19:56:44 <superstar64> sureyeaah, which parts? there's a ton of papers on it
19:59:12 <sureyeaah> superstar64: hmm i'm not sure but I'm interested to know where things like typeclasses, gadts, etc arise from.
19:59:54 <koz_> sureyeaah: There's a lot going on there. Type classes and GADTs (just to use those examples) are based on very different principles.
20:00:04 <koz_> For type classes, I think you want the Wadler paper.
20:00:16 <koz_> For GADTs, there's a few different ones, since there's a bunch going on.
20:00:22 <koz_> (I dunno the original one though)
20:01:37 <koz_> The paper on type classes you wanna start with is here: https://homepages.inf.ed.ac.uk/wadler/topics/type-classes.html
20:01:42 <koz_> (there's a bunch more)
20:02:03 <koz_> If you want some background, Hindley-Damas-Milner-style type inference is good to know.
20:02:28 <koz_> Have you looked at Type Theory and Formal Proof?
20:02:28 <superstar64> learn some unification theory if you not already familiar with
20:02:36 <koz_> It's a good introduction to the necessary machinery.
20:02:58 <koz_> And YES to knowing about unification.
20:03:07 <koz_> It's sort of a theme that runs through a lot of type checking and inference.
20:03:20 <koz_> (I believe TAPL has a whole chapter on that connection)
20:03:33 <koz_> (I dunno if that chapter also explains HDM, it's been a while)
20:03:58 <superstar64> read the first few sections of this https://www.cs.bu.edu/fac/snyder/publications/UnifChapter.pdf
20:04:44 <koz_> For GADTs, the Johann and Ghani paper is probably _a_ starting point.
20:04:48 <ski> sureyeaah : perhaps "Polymorphic Type Inference" by Michael I. Schwartzbach in 1995-03 at <https://cs.au.dk/~amoeller/mis/typeinf.p(s|df)> could be interesting to check out
20:05:12 <koz_> There's also the Middelkoop, Dijkstra and Swiestra paper, but that one's a little heavier if you're not used to type judgment notation.
20:06:24 <superstar64> is anyone familiar with what this is? https://old.reddit.com/r/ProgrammingLanguages/comments/gwx8ch/unification_with_predicates/
20:06:38 <superstar64> it's how i'm implementing typeclasses in my compiler but i can't find any papers on this
20:07:58 <koz_> Are you familiar with the constraint solving extension to Micro-Kanren?
20:08:04 <koz_> You might wanna check out what they do.
20:08:12 <koz_> Since it _definitely_ looks similar.
20:08:28 <koz_> Or just constraint solving in general - the literature around it should give you enough to go on.
20:08:48 <sureyeaah> koz_: thanks, these seem like good points to start exploring from.
20:09:24 <koz_> If you run into some difficulties while digging into those, it'll at least give you more specific directions to go in.
20:10:10 <koz_> The best part is that (most of) these papers and chapters have examples in Haskell, or something close to it.
20:10:21 <koz_> Which means you can actually try it out, or even implement it yourself if you like.
20:10:49 <koz_> Most of my big 'aha!' moments came from trying to hack something together and seeing the puzzle pieces move into place.
20:10:50 <superstar64> koz_ i don't even know that micro-kanren is
20:10:59 <koz_> superstar64: Look into it - it's pretty cool.
20:11:12 <dolio> Your second notation is pretty odd at least.
20:11:36 <sureyeaah> koz_: yepp makes sense.
20:11:38 <koz_> (example: the whole Cofree talk I gave you stemmed from just seeing the moving parts of Medea and relating it back to a bunch of streaming libraries)
20:11:46 <koz_> (no seriously)
20:12:52 <dolio> For instance `b = Ord c => c` suggests `[b]` is the same as `[Ord c => c]`, which is not really typical.
20:13:16 <sureyeaah> koz_: that's pretty cool. I would not have guessed that :P
20:14:08 <koz_> sureyeaah: Well, now you know. :P
20:14:26 <koz_> Actually writing Haskell full-time _definitely_ helped me understand a lot of stuff that wasn't nearly as clear to me before.
20:14:38 <dolio> If you're generating and solving constraints, I think it is more typical for qualifiers to just be kept track of as another constraint somehow.
20:16:20 <superstar64> how does ghc do it?
20:16:58 <koz_> superstar64: Check the Wadler paper I mentioned. :P
20:17:10 <superstar64> the typeclasses paper?
20:17:24 <dolio> GHC has all sorts of constraints that can even be talked about within the language, not just implementation details in the type checker.
20:18:01 <superstar64> https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.53.3952&rep=rep1&type=pdf does this still describe how ghc does constraint solving or is it outdated?
20:18:16 <dolio> That's way too old.
20:18:29 <superstar64> koz_ which paper exactly?
20:18:51 <superstar64> irr the typeclasses paper doesn't talk about unification 
20:18:58 <koz_> superstar64: Type Classes In Haskell, which is on that page I linked. It shows how type class stuff can be reduced to HDM I believe.
20:19:20 <koz_> dolio: Did something change when we got ConstraintKinds or something?
20:19:34 <koz_> Or did GHC use something different even before that?
20:20:12 <dolio> Well, that paper is from 1993, so I think the approach has changed multiple times since then.
20:20:27 <dolio> I don't think constraint kinds really matter that much.
20:21:52 <dolio> I think OutsideIn(X) is reasonably current, although even it is 9 years old now.
20:22:00 <dolio> Before that it was HM(X).
20:22:15 <dolio> The (X) is parameterization by arbitrary constraint solvers, I believe.
20:22:47 <koz_> And I think we're now heading to something new again for impredicative stuff, although I think it was phrased as an extension to OutsideIn?
20:23:04 <dolio> Yes, it's somewhat minor.
20:25:22 <dolio> Oh, there are constraint changes since OutsideIn, though. They added quantified and implication constraints somewhat recently.
20:25:49 <dolio> But that's a difference in the (X) part, I think. At least that's the idea.
20:26:02 <koz_> dolio: Implication constraints?
20:26:44 <dolio> Yes, you can say things like `instance (forall a. Show a => Show (f a)) => Show (Fix f)` now.
20:27:42 <koz_> Is that not a quantified constraint though?
20:27:52 <koz_> Or am I confusing it with the QuantifiedConstraints extension?
20:27:57 <dolio> The forall part is, and the `Show a => Show f a` is an implication.
20:28:11 <koz_> Ah.
20:28:28 <dolio> I think they're both turned on by that extension probably.
20:28:41 <koz_> I believe so, yeah.
20:29:08 <superstar64> is it worth implementing MLF in my language?
20:29:30 <koz_> MLF?
20:29:32 <superstar64> what does haskell use for type inference of rank n types?
20:29:55 <superstar64> https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.79.3945&rep=rep1&type=pdf
20:30:20 <koz_> superstar64: I dunno if that SPJ paper got implemented, but I believe auto-inference assumes rank 1 at most.
20:30:40 <koz_> (SPJ talked about a way to infer more, but even that needs explicit annotations and only goes to like, rank 3 I think?)
20:30:47 <koz_> (I may be misremembering)
20:30:48 <dolio> MLF is pretty cool. I've never used an implementation, though.
20:31:23 <superstar64> well, if haskell had MLF then the impredicative instantiation problem wouldn't be a problem
20:31:28 <superstar64> so i don't think it's that
20:31:51 <gjv> Not sure if this belongs here but does anyone use haskell-mode on emacs? I am running into a lot of lag when I use that major mode. Every keystroke is being delayed by a few seconds forcing me to default to text-mode.
20:32:06 <dolio> The thing about MLF is that you manually make all your types rank-3 in a way.
20:32:25 <superstar64> how so?
20:33:20 <dolio> Because instead of writing the higher rank types, you pull the occurrences out into a constraint at the front.
20:33:21 <ski> koz_ : rank 2, iirc
20:33:36 <koz_> ski: Ah.
20:33:48 <koz_> I knew it was limited to rank-[single digit number which is low].
20:33:54 <koz_> But I forgot which.
20:33:58 <dolio> Like, instead of writing `[forall a. a -> a]`, you write `forall (b >= forall a. a -> a). [b]`
20:34:06 <dolio> Or something of the sort.
20:34:06 <superstar64> yea i know that
20:34:17 <superstar64> i skimmed though the paper
20:34:50 <superstar64> i'm still not sure on the relation between equality, sharing, and instantiation
20:34:58 <dolio> It is kind of like using the Yoneda lemma to reduce the rank of everything.
20:35:14 <superstar64> what's the yoneda lemma?
20:36:19 <dolio> It says, e.g. that `[forall a. a -> a]` is an equivalent type to `forall r. ((forall a. a -> a) -> r) -> [r]`
20:36:37 <superstar64> so scott encoding?
20:36:53 <superstar64> wait, it's a bit different
20:38:23 <ski>   newtype Yoneda f a = MkYoneda (forall b. (a -> b) -> f b)
20:39:27 <ski> if `f' is a (covariant) functor, then `f a' is equivalent to `Yoneda f a'. note that the latter type is `Yoneda [] (forall a. a -> a)'
20:40:30 <koz_> I believe it is also the case that Yoneda f is a Functor, no matter what f is.
20:40:45 <superstar64> i'm not too keen on category theory, but isn't a covariant functor just a regular functor?
20:40:49 <ski> (also there's `data CoYoneda f b = forall a. MkCoYoneda (a -> b) (f a)', so `CoYoneda f b' expresses `exists f. (a -> b,f a)'. if `f' is a (covariant) functor, then this is also equivalent to just `f b')
20:40:55 <ski> koz_ : yes
20:41:02 <ski> yes, superstar64
20:41:39 <superstar64> does the rabbit hole of functional programming ever end?
20:41:49 <ski> (e.g. `CoYoneda IORef' is a functor, it's a type of read-only references)
20:42:17 <koz_> ski: I know that Codensity m is a Monad for any m. Is there something like Foo m such that Foo is an Applicative for any m, but not (necessarily) a Monad?
20:42:28 <koz_> s/Foo is/Foo m is/
20:43:37 <ski> i don't recall, but i wouldn't be surprised
20:43:41 <glguy> http://hackage.haskell.org/package/free-5.1.3/docs/Control-Applicative-Free.html
20:45:15 <koz_> glguy: Huh. It isn't constructed the same way as Yoneda or Codensity though (no inner forall), but I guess it's a GADT.
20:45:44 <glguy> koz_: How about: http://hackage.haskell.org/package/free-5.1.3/docs/Control-Applicative-Free-Final.html
20:45:57 <dolio> Anyhow, in that respect, you have MLF sort of turning arbitrary rank types into ones where foralls only occur underneath two arrows, so it's at most rank 3.
20:46:24 <koz_> glguy: Lol, ya got me in a literal sense.
20:46:25 <dolio> At least, I think.
20:46:56 <glguy> koz_: Same goes for Yoneda: http://hackage.haskell.org/package/kan-extensions-5.2/docs/Data-Functor-Coyoneda.html
20:46:57 <superstar64> MLF abstracts the foralls into variable that appear into type schemes
20:47:01 <dolio> The arrows are a little disguised, because they look like bounded quantifiers.
20:47:25 <superstar64> i don't think there's any sort of skolemization 
21:07:16 <ktor> hi
21:17:14 <Axman6> Hello!
21:47:19 * hackage pandoc 2.10.1 - Conversion between markup formats  https://hackage.haskell.org/package/pandoc-2.10.1 (JohnMacFarlane)
22:33:39 <jtm> With this function: https://pastebin.com/AyxfbLSe if I do: subs [1,2]  why isn't the result [[], [2], [2], [1,2]] ?
22:34:48 <jtm> it is [[], [2], [1], [1,2]] but I don't know why [1] is index 2 on the list. Why isn't it [2]? Where is this [1] actually coming from?
22:36:45 <jtm> From what we see, the last resulting yss = subs xs should be [2], which then would be added to the overall list, and x would be 1 which is cons to the [2] resulting in [1,2]
22:42:02 <Axman6> subs [1,2] -> subs [2] ++ map (1:) (subs [2]) -> (subs [] ++ map (2:) (subs [])) ++ map (1:) (subs [] ++ map (2:) (subs [])) -> ([[]] ++ map (2:) [[]]) ++ map (1:) ([[]] ++ map (2:) [[]]) -> [[],[2]] ++ map (1:) [[],[2]] -> [[],[2],[1],[1,2]]
22:43:18 <Axman6> (Maybe copy that out and replace -> with new lines too see the substitutions I did)
22:43:41 <jtm> ok will do
22:44:06 <Axman6> all I did was replace yss with its definitions and then expanded
22:44:33 <jtm> oh I see because of the map over the []
22:45:03 <jtm> I forgot it was in there
22:45:40 <jtm> I kept treating it as a single element (one sublist) being returned rather than the entire list of lists
22:46:49 <jtm> Thank you! :)
22:46:56 <jtm> I'll use that technique moving forward
22:47:11 <jtm> It can get relatively messy but doing it in my head obviously is failing me
22:49:15 <Axman6> it's much easier if you do it in a text editor, and then copy the previous line and replace something with its definition
22:49:26 <jtm> yeah I did it and I expanded it out
22:49:36 <jtm> Adding new lines etc
22:50:20 <jtm> One thing to note, but not too important is that the recursion is performed only once per call
22:50:35 <jtm> I don't know if CAN make a difference, probably not but maybe
22:50:53 <Axman6> yes, but it's easier to step through if you just expand the definition of yss into subs xs
22:50:53 <jtm> because it's bounded by the where yss = subs xs
22:51:08 <jtm> yeah, I was a little afraid to treat them equally in this case
22:51:20 <Axman6> you'll get sharing which is nice, having the where statement will use less memory
22:51:21 <jtm> but I guess it is fine :)
22:51:49 <jtm> yeah, it's an optimization in that you don't need to recurse twice
22:52:07 <jtm> Thank you though, I'm going to expand another function
22:52:14 <jtm> and see if it works out, using your method
22:52:40 <jtm> I was trying to think of a good way to expand this, and I don't have a pen and paper and I was going to write out all the variables and keep all the states in some notepad
22:52:51 <jtm> but it seemed very tedious and hard to see the pattern that way
23:01:11 <jtm> Axman6: Using your technique I did this successfully: https://pastebin.com/gc1sAArw
23:02:37 <Axman6> beautiful
23:03:43 <jtm> Generally, I shouldn't need to do this, but I really wanted to get a deep understanding of what exactly was the reason why the result was becoming what it was, because everytime I went down the rabbit hole I got lost.
23:04:09 <jtm> I think I won't get as lost moving forward however.
23:05:11 <jtm> I'll build from deepest recursion upwards to the most shallow level while combining and reducing
23:05:24 <jtm> Base case up
23:05:46 <jtm> Which I usually did, but I wasn't sure exactly how everything was working I guess
23:07:07 <jtm> Mainly how map was handled within the scope of recursion
23:14:15 <typetetris> If I upload to hackage, do I need to do something special to get the haddocks? My package candidate doesn't seem to have em.
23:22:52 <unclechu> hey, can i enter "cabal repl" to a specific module and build only its dependencies, ignoring errors in other packages?
23:34:49 <jtm> Axman6: Another one I did, this one was probably the hardest because it used a recursive function to map over another recursive function, I didn't break down the interleave though: https://pastebin.com/zRb8tFw6
23:52:35 <dminuoso> typetetris: You need to upload the haddock separately.
23:52:55 <dminuoso> typetetris: hackage *attempts* to build the haddoc, but it can fail.
23:53:03 <dminuoso> Also, you get no control over what haddoc and how its invoked
23:53:12 <dminuoso> https://hackage.haskell.org/upload at the bottom has example commands you can use
23:59:02 <typetetris> dminuoso: Thanks.
