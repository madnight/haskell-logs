00:00:10 <dminuoso> So if we have some expression `f x :: Maybe Int`, and we somehow demand it's value, then replace `f` and `x` by their respective definitions (recursively!)
00:00:31 <dminuoso> And evaluate what you have until you have either a `Nothing` or a `Just x` in your hand. If you have the second, the `x` may not be evaluated yet.
00:01:14 <dminuoso> You will notice that by doing this, all internal lambdas will disappear in that "substitution process"
00:01:31 <dminuoso> And it doesn't matter in what order you do it. Any order you can is fine
00:01:45 <jtm> Yeah in this case x would be evaluated because we would be calling eval with an expression like  (Div (Val 1) (Val 5)) which will result in the Val 1 and Val 5 to eventually go to Just 1 and Just 5 respectively.
00:01:51 <dminuoso> (And in fact, GHC is free to do it in any order in the absence of very special primitives)
00:02:40 <dminuoso> jtm: My point is just, think of evaluation perhaps as "replacing things by their definition", as opposed to "first go there, then to do that, then call that"
00:02:52 <jtm> The Just 1 and Just 5 would have their 1 and 5 passed into both n and m at different levels of recursion which both are used inside safediv as safediv 1 5
00:03:18 <jtm> You mean like  eval x becomes   Expr -> Maybe Int
00:03:39 * Lycurgus thinks of evaluation as replacing a definition by its value at a point
00:04:14 <dminuoso> r = eval x >>= (\n -> eval y >>= (\m -> savediv n m))
00:04:32 <dminuoso> r :: Maybe Int
00:04:33 <jtm> If we have (Div (Val 1) (Val 5)) then eval x becomes  eval (Val 1) which becomes   Just 1
00:04:34 <dminuoso> Right?
00:04:56 <jtm> yeah
00:04:58 <dminuoso> jtm: ^- take the entire expression. Replace >>= with its respective definition (via type inference, pick the Maybe implementation of >>=)
00:05:07 <dminuoso> Replace eval with its definition
00:05:10 <dminuoso> replace savediv with its definition
00:05:24 <dminuoso> You can reduce things as you go in any place and order you like, really
00:05:45 <dminuoso> (For the discussion)
00:07:44 <dminuoso> jtm: https://gist.github.com/dminuoso/38a320f8e656f71c77d6c42028ebddd6
00:07:48 <jtm> Yeah I think I did that here, but I guess I wasn't clear. You mean like eval x becomes Just 1 (assuming Expr =  (Div (Val 1) (Val 5)) ) which then go to f x inside Maybe monad which gives (\n -> eval y >>= (\m -> savediv n m)) 1,  which leads to   (eval y >>= (\m -> savediv 1 m)) which brings us to eval y becoming Just 5 which is passed into the
00:07:49 <jtm> Monad...
00:08:13 <dminuoso> jtm: ^- does that make sense to you?
00:08:19 <jtm> giving (\m -> safe 1 m) 5  which gives safe 1 5
00:08:21 <jtm> Checking
00:09:09 <jtm> Yes
00:09:50 <jtm> They pretty much do that in the book actually, using a case with another case for eval y on Just n
00:10:08 <jtm> It's literally almost exactly what you wrote
00:10:20 <jtm> Almost as if you knew.... :)
00:10:32 <dminuoso> jtm: That's the definition of >>= for maybe. :)
00:10:50 * hackage bytestring 0.10.12.0 - Fast, compact, strict and lazy byte strings with a list interface  https://hackage.haskell.org/package/bytestring-0.10.12.0 (sjakobi)
00:10:54 <dminuoso> jtm: https://hackage.haskell.org/package/base-4.14.0.0/docs/src/GHC.Base.html#line-1005
00:10:54 <jtm> I mean the eval
00:12:37 <jtm> It's interesting it doesn't use a case like my book does
00:12:42 <jtm> But rather pattern matching
00:12:58 <dminuoso> jtm: They are the same thing.
00:13:11 <jtm> I prefer the pattern matching way, easier to read.
00:13:19 <dminuoso> `f (Just x) = ...; f Nothing = ...` gets desugared into `f t = case t of Just x -> ...; Nothing -> ...
00:13:31 <Dracule> does freenode have a dark mode?
00:13:48 <Dracule> found it!
00:13:53 <jtm> I think they did it with case because their first example used a case.
00:13:59 <jtm> I'm going to write it really fast
00:14:22 <dminuoso> jtm: at the end, case-of is the only user tool to scrutinize a value. :)
00:15:19 <jtm> https://pastebin.com/f8Avy9v7
00:15:50 <jtm> It's pretty much exactly what you did before
00:17:32 <dminuoso> jtm: If we desugared that, you'd have: https://gist.github.com/dminuoso/9ad206d80f8a35439edeb4c7e11466cb
00:17:51 <dminuoso> This desugaring can be useful, if you want to expand some usage of `eval foo` in some other place.
00:18:14 <dminuoso> It allows you to do this replace things by their definition in a very mechanical fashion
00:18:25 <jtm> Isn't that the exact code I just gave you?
00:18:42 <dminuoso> In desugared form, yes.
00:19:02 <jtm> I'm confused
00:19:16 <dminuoso> huh hold on
00:19:19 <dminuoso> That looks *wrong*
00:19:26 <dminuoso> I see!
00:19:41 <dminuoso> No its right, all fine
00:19:43 <jtm> oh you mean for the pattern matching
00:19:51 <dminuoso> Yeah, just on the argument
00:20:03 <dminuoso> Say you have some `eval foo` in some code.
00:20:07 <dminuoso> And you want to know how it evaluates.
00:20:13 <dminuoso> You could then take my version, and mechanically replace it
00:20:28 <dminuoso> With the sugared version with multiple definitions you couldn't.
00:21:03 <dminuoso> (i.e. manually inlining everything)
00:21:16 <jtm> ah ok
00:22:53 <jtm> So you convert the definitions into a case
00:23:37 <dminuoso> jtm: Im just desugaring the function into a single definition. Once you have a single definition, you can expand function application with that single definition.
00:23:45 <dminuoso> i.e.
00:23:52 <jtm> What you did in foo.hs
00:23:59 <dminuoso> https://gist.github.com/dminuoso/9ad206d80f8a35439edeb4c7e11466cb in this
00:24:18 <dminuoso> Take `eval (Div (Val 1) (Val 5))` for instance. you can just statically replace things
00:25:04 <jtm> e = (Div (Val 1) (Val 5))
00:25:30 <jtm> Div x y forces  x to be (Val 1) and y to be (Val 5)
00:25:59 <jtm> case eval (Val 1) of....
00:26:15 <jtm> eval (Val 1)  becomes Just 1
00:26:53 <jtm> Just 1 makes n = 1 per the case at the highest level of recursion (depth = 0)
00:27:13 <jtm> then we do eval y which becomes  Just 5
00:27:26 <jtm> Just m case makes  m = 5
00:27:48 <jtm> then we do safediv 1 5 as our return value
00:28:00 <jtm> which is a Maybe Int
00:28:35 <jtm> (I was using your f.hs)
00:29:25 <dminuoso> jtm: Perfect, now replace safediv with its definition as well
00:30:00 <jtm> Just (1 `div` 5) which is Just ( 0 ) or Just 0
00:31:40 <dminuoso> jtm: Hold on, that's not the *definition* of savediv :)
00:31:47 <dminuoso> Im asking you to do this mechanically, step by step.
00:31:51 <jtm> Oh
00:32:00 <dminuoso> Rather than waving your hand and skipping to the end :)
00:32:29 <jtm> case n of ...
00:33:52 <jtm> Hmm I'm not sure how exactly we create a case matching all ints,  I'm guessing  n ->   would be good enough?
00:34:44 <jtm> n -> case m of 0 -> Nothing  m -> Just (n `div` m)
00:38:35 <tomjaguarpaw> c
01:00:37 <Orbstheorem> DigitalKiwi: Yes, haskell is awesome for refactoring ^^
01:01:31 <DigitalKiwi> Orbstheorem: i added dpaste.com and a few features as well
01:02:12 <DigitalKiwi> Orbstheorem: and now i have a ~3000 diff >.>
01:02:28 <Orbstheorem> Hope you have individual commits :)
01:02:40 <DigitalKiwi> nooooo
01:03:18 <Orbstheorem> :(
01:13:47 <Orbstheorem> Is there an easy way to convert an hs to an lhs?
01:16:21 <livvy> Orbstheorem: Theoretically you can just use something like sed
01:18:18 <Orbstheorem> Doesn't it get finicky with pragmas?
01:18:24 <Orbstheorem> Oh well...
01:20:06 <livvy> Maybe start it after the pragmas?
01:23:12 <livvy> https://github.com/jeffreyrosenbluth/Literate ? 
01:24:38 <livvy> looks like that hadles pragmas and comments
01:24:42 <livvy> *handles
01:27:44 <Orbstheorem> Looks good ^^
01:32:55 <cdan> Hello, everyone.
01:46:34 <[exa]> hello cdan!
02:51:36 <Orbstheorem> How can I verify if a type proposition is true? (e.g. Given a typeclass A a1 a2 and some instances, the compiler can build an instance for A Foo Bar.)
03:08:49 * hackage testcontainers 0.1.0.0 - Docker containers for your integration tests.  https://hackage.haskell.org/package/testcontainers-0.1.0.0 (alexbiehl)
03:10:41 <tomsmeding> Orbstheorem: I guess you can create a new function (or class instance) with your proposition as class context, then try to call it
03:10:59 <tomsmeding> may need FlexibleContexts or related
03:28:35 <Orbstheorem> tomsmeding: That was my first idea, but then I couldn't think of an implementation.
03:28:41 <Orbstheorem> But now that you mention it, const x)
03:29:11 <Orbstheorem> But I still believe there should be a more ergonomic way of doing so x)
03:36:24 <tomsmeding> sure :p
03:50:03 <remexre> is there anything of kind * -> * which is neither a Functor nor Contravariant?
03:50:29 <dminuoso> Sure, plenty.
03:51:07 <dminuoso> % data F a = F (a -> a)
03:51:07 <yahb> dminuoso: 
03:51:14 <remexre> ah, sure
03:51:44 <remexre> ok, thanks!
03:51:47 <dminuoso> Then there's GADTs of course
03:53:23 <dminuoso> Or you can use TyFams in the data definition
03:54:29 <dminuoso> remexre: Another interesting bit is things like Set.
03:54:38 <dminuoso> They cant form lawful Functor instances
03:55:26 <remexre> hm, because of the Eq/Ord constraint?
03:55:32 <dminuoso> Indeed
04:16:48 <maralorn> I have the diffuse feeling that the huge number of type level constraints is somewhat redundant? Like for a given type level problem you can probably solve it via fundeps, typefamilies or a gadt trick. Is that justified or are they really all necessary in the respect to feature completeness?
04:16:49 <maralorn> s/constraints/extensions/
04:17:20 <merijn> maralorn: Nobody knows! \o/
04:17:34 <dminuoso> maralorn: well at least fundeps are redundant in the presence of tyfams I think.
04:17:40 <merijn> Also, while you're at it, please define "feature completeness"
04:18:10 <maralorn> merijn: That's why I started my sentence with "diffuse feeling"' ;-)
04:18:59 <[exa]> maralorn: a bit of redundancy can nicely fight undecidability
04:18:59 <maralorn> Is it a reasonable hope, that this can be simplified once DependendendHaskell lands?
04:19:00 <maralorn> -end?
04:19:18 <merijn> "no"
04:19:20 <maralorn> [exa]: Can you explain that?
04:19:37 <merijn> maralorn: I wouldn't put my hopes in DependentHaskell
04:19:56 <merijn> In fact, I advice healthy dosis of skepticism
04:20:32 <maralorn> merijn: That it arrives or that it will be helpful?
04:20:37 <merijn> Both
04:20:59 <merijn> Well, arrives is more likely, given how many people are invested into it wrt their research career
04:21:05 <[exa]> maralorn: oh my, I didn't read the s/constraints/extensions part :D
04:21:29 <merijn> I wouldn't expect it to be pleasant or all the usable at first, if ever
04:21:39 <maralorn> [exa]: ;-)
04:22:28 <[exa]> maralorn: OTOH it still kindof applies. You need some way to guide the compiler to dodge undecidable/complicated stuff, and these are fuzzy by nature and admit lots of different encodings into the language.
04:22:55 <maralorn> merijn: Is your skepicism primarily based on a usability perspective or do you have doubts of the theoretical feasibality?
04:23:25 <maralorn> Also can someone point me to where I can watch the haskell.love videos?
04:24:03 <merijn> maralorn: Oh, I'm sure someone can make it work
04:24:09 <merijn> maralorn: But I've also seen Jurassic Park...
04:25:11 <[exa]> I'm starting to wish that the type metalanguage of haskell would finally materialize into a separate prolog-like language for proofs that gets embedded to code, where encoding total bijective functions would be easier
04:28:03 <merijn> maralorn: i.e. "your scientists were so busy seeing if they could, they forgot to think whether they should" ;)
04:28:50 <merijn> maralorn: The main "nice" part of dependent language having a consistent and uniform interface at the term and type level, but you can never achieve that in Haskell without breaking a bunch of stuff, since it wasn't designed for that
04:31:51 <dminuoso> Im slowly starting to doubt myself. How can my uses of foldrM and foldr not agree? https://gist.github.com/dminuoso/76379464f14eea061592cc185f03048c 
04:31:58 <dminuoso> Am I misusing alterF is some subtle way?
04:32:13 <dminuoso> (Concretely, Im observing m1 and m2 to contain different values)
04:33:37 <dminuoso> Oh..
04:35:39 <dminuoso> Rubber ducking on IRC works so great after an hour long brainfart. :)
04:39:22 <maralorn> merijn: I have moderate hope, that dependent haskell won't convert computers into sentient beings. So I think we are fine from an ethical standpoint.
04:42:44 <maralorn> Also, we can just not put it into haskell 2030 if it doesn't work out. 😁
04:43:05 <merijn> Oh, that's *never* making it into the Haskell Report
04:43:31 <merijn> People can't even figure out how to standardise the way GADTs (should) interact with the language
04:48:14 <[exa]> hm, say I want to build a user-customizable lexer in haskell, preferably the user specifies regexes and the tokens get parsed... What's the easiest regex library for that?
04:49:13 <[exa]> (bonus: ability to run on memory-mapped data)
04:55:06 <nij> It's technically not a haskell question.. but I give it a try anyway..
04:55:26 <nij> I'm forced to write codes in python.. and it's so uncomfortable..
04:55:45 <nij> I hope to compose functions like in haskell `f . g . h`.. 
04:56:02 <nij> But the best I found in python is the function `compose`.. which only takes two arguments at a time
04:56:29 <nij> Worse.. `compose` is too long, much longer than `.`. I cannot even make it into an infix operator either :(
04:56:44 <[exa]> reimagine python as scheme, write `lambda x:f(g(h(x)))` ?
04:56:56 <mniip> usually in python you'd write a variable argument function
04:57:23 <tomsmeding> if you really want an operator, you could conceivable make something like F(f) | g | h work, I think
04:57:38 <tomsmeding> where you need the F (or whatever) to create an object on which you can overload an operator
04:57:49 <mniip> def compose(*fs): { def f(x): { for f in fs: { x = f(x) } return x } return f }
04:58:10 <tomsmeding> well, for f in fs.reverse()
04:58:16 <mniip> that
04:59:11 <Arahael> [exa]: Unlike scheme, python doesn't have tail recursion.
05:00:36 <dibblego> sure it does! https://github.com/qfpl/hpython/blob/develop/example/OptimizeTailRecursion.hs
05:00:51 <dminuoso> Arahael: Python already incurs a 100x slowdown in many areas. Why not waste a little stack memory while you're on it.
05:01:09 <dminuoso> dibblego: haha touche
05:01:31 <Arahael> dibblego: Unlike Scheme, Python doesn't require it for the language implementation! ;)
05:03:16 <nij> seems there's no hope to defined `.` as in haskell?
05:03:36 <day> nij: at the risk of getting witch hunted. why not write python code like normal python code? you wouldnt write haskell in a python way either :|
05:03:58 <tomsmeding> python only supports operator overloading on custom classes, and then only for existing operators; and '.' is not a Python operator
05:04:10 <tomsmeding> day: yes I think that's the elephant in the room :p
05:04:22 <Arahael> tomsmeding: __getattr__.
05:04:24 <tomsmeding> though intellectual curiosity demands finding a way to do this
05:04:45 <Arahael> tomsmeding: Or __get_attribute__, depending.
05:04:50 <tomsmeding> Arahael: you suggest F(f) . "g" . "h" ?
05:05:02 <tomsmeding> oh I'm dumb
05:05:09 <Arahael> tomsmeding: I suggest F(f).g.h
05:05:50 <day> tomsmeding: if i finds a way then, I know whos going to be disliked in the company next week. and im also sure the python mob will have the number advantage :D
05:06:55 <day> but true a dot operator would look much nicer then nested function calls :|
05:07:00 <day> than*
05:14:32 <nij> Yeah.. writing in python way is fine.. I'm just wondering if it's possible to use `.`
05:14:43 <nij> that would make my life much easier
05:14:47 <mniip> . no
05:15:42 <Arahael> Well, you could make a python quasi-quoter? ;)
05:16:09 <Arahael> I mean, python has an api that lets you emit python AST for the interpreter, which you can inject into the running process...
05:16:13 <Arahael> And it has multiline strings.
05:16:33 <Arahael> So... You could. Ergo, "if it's possible to use...", is TRUE.
05:16:34 <Arahael> :)
05:16:44 <mniip> x.y in python means x.__getattribute__("y"), so the "y" loses lexical scoping
05:17:09 <Arahael> mniip: Python barely has lexical scoping, anyway.
05:17:18 <mniip> you know what I mean
05:17:32 * Arahael nods, sadly.
05:17:39 <nij> mniip: can I use something like `,,` that avoids confluence?
05:17:55 <nij> `f ,, g ,, h` seems better too
05:17:59 <mniip> you also can't define custom operator names!
05:18:19 <Arahael> But you can do funkery with repeated operator names, such as * *
05:18:25 <Arahael> (Pretty sure...)
05:18:35 <nij> or how about this..
05:18:49 <nij> can I define ,, as |compose|
05:19:59 <nij> ?
05:20:30 <Arahael> In python?
05:20:43 <mniip> you could use a few hacks to override __or__ on functions
05:21:59 <sshine> I think the ,, operator should be called "the fang operator".
05:22:34 <nij> Arahael: yes
05:23:15 <Arahael> nij: Comma, in python, is typically hardwired to the tuple syntax, and you can't override it.
05:23:37 <nij> Arahael: :(
05:27:09 <mniip> odd
05:27:46 <siraben> @unmtl MaybeT (State Int) Bool
05:27:46 <lambdabot> Int -> (Maybe Bool, Int)
05:27:59 <siraben> @unmtl StateT (Maybe Int) Bool
05:27:59 <lambdabot> err: `StateT (Maybe Int) Bool' is not applied to enough arguments, giving `/\A. Maybe Int -> Bool (A, Maybe Int)'
05:28:01 <siraben> Oops
05:28:32 <siraben> @unmtl StateT Int Maybe Bool
05:28:32 <lambdabot> Int -> Maybe (Bool, Int)
05:31:56 <tomsmeding> Arahael: nij: this implements that . syntax for top-level functions https://gist.github.com/e2e25b5aa27ea9920b815ce44df1740e
05:32:16 <tomsmeding> the sadist in me had to try it
05:32:35 <Arahael> Its possible to walk the stack, too.
05:32:36 <tomsmeding> please do not try at home
05:32:50 <tomsmeding> and get locals?
05:32:53 <Arahael> Yeah, that warning is sensible, but also it's NSFW.
05:33:15 <tomsmeding> which for many people is mostly the same nowadays, but that's a different story
05:34:40 <nij> tomsmeding: Wow
05:38:41 <Arahael> tomsmeding: I didn't know that many people walk around in the nude at work. :)
05:39:49 <mniip> tomsmeding, I tried changing functions' __or__ but it didn't work for some reason
05:40:03 <mniip> like it would work with f.__or__(g) but not f|g
05:40:15 <tomsmeding> interesting
05:42:06 <nij> Arahael: I dorn't really understand why this works.. it seems like magic
05:42:15 <nij> where did you redefine `.`?
05:42:25 <tomsmeding> __getattr__
05:42:54 <tomsmeding> thanks to the suggestion that one can "walk the stack, too", I almost have a version that also works with local functions o.O
05:43:17 <tomsmeding> TIL python has introspection like that
05:44:32 <alehander92> `__getattr__` redefines `.` 
05:44:42 <alehander92> you also have `__getitem__` iirc etc
05:44:45 <tomsmeding> hm the traceback api seems to give you locals if you massage it enough, but only in repr() form
05:44:54 <mniip> ...
05:44:56 <mniip> locals()
05:45:18 <tomsmeding> I want the parent scope ;)
05:45:20 * hackage stack 2.3.3 - The Haskell Tool Stack  https://hackage.haskell.org/package/stack-2.3.3 (borsboom)
05:45:29 <mniip> ah hmm
05:45:32 <tomsmeding> relevant hackage release
05:45:40 <mniip> there's definitely a way to get it
05:45:51 <tomsmeding> traceback.StackSummary.extract(traceback.walk_stack(None), capture_locals=True)[-2].locals
05:45:55 <tomsmeding> that gives you repr()'d locals
05:45:57 <tomsmeding> for some reason
05:46:14 <alehander92> from SO it seems `inspect`should do it
05:46:26 <alehander92> but it's maybe cpython specific 
05:47:30 <mniip> sys._getframe
05:47:42 <tomsmeding> I almost hope it's cpython-specific
05:48:08 <tomsmeding> mniip: "This function should be used for internal and specialized purposes only."
05:48:09 <tomsmeding> <3
05:49:13 <tomsmeding> that works
05:49:26 <tomsmeding> amazing
05:49:51 <mniip> caveat though
05:50:33 <mniip> going up the call stack != going up the lexical scope stack
05:51:13 <tomsmeding> right
05:51:24 <tomsmeding> unimportant corner case
05:51:28 <tomsmeding> :p
05:51:48 <tomsmeding> okay barring macro's this is not going to work perfectly
05:52:16 <tomsmeding> it looks impressive though https://gist.github.com/tomsmeding/e2e25b5aa27ea9920b815ce44df1740e
05:55:20 <tomsmeding> using a variable in a scope brings it into that scope's locals list?
05:55:43 <mniip> that's possible
05:55:56 <mniip> I was just looking at sys._getframe().f_code.co_freevars
05:56:16 <mniip> unfortunately x.y doesn't count as a use of y
05:56:49 <tomsmeding> (which makes sense, because it doesn't refer to a variable named 'y')
06:11:20 * hackage strict 0.4 - Strict data types and String IO.  https://hackage.haskell.org/package/strict-0.4 (infinity0)
07:10:21 <aldessa> hello, how can I write a cross platform iOS/Android app with Haskell or some similar language? I do not want to point a browser to a site and do a website instead.
07:25:47 <Uniaika> aldessa: if you want to entirely do it in Haskell that is impossible
07:26:14 <Uniaika> you will have to create some sort of framework in the supported languages of those platforms and delegate business logic to Haskell
07:26:23 <Uniaika> lots of bindings will have to be written too
07:31:56 <dminuoso> aldessa: I recall a framework being talked about last year at a private discussion at Haskell exchange.
07:32:03 <dminuoso> IIRC it was some absurd Haskell<>Java bridge
07:32:17 <aldessa> eta?
07:35:29 <phadej> aldessa: check reflex-platform / obelisk
07:35:39 <phadej> they claim you can write ios and android apps
07:35:54 <hyperisco> aldessa, it is difficult to write a cross platform app without confounding constraints like having to use a specific language
07:36:02 <phadej> (it doesn't involve java on android)
07:36:28 <phadej> or at least application writer doesn't need to care about that
07:36:50 <phadej> https://github.com/obsidiansystems/obelisk#mobile
07:37:05 <aldessa> hyperisco uniaika I just want something with higher kinded types, functors, monads not necessarily Haskell
07:37:31 <aldessa> i just really want to avoid OOP if I can because I find it confusing, maybe that's a pipe dream
07:37:38 <phadej> current haskell ecosystem (packages on Hackage) is valuable resource
07:37:38 <hyperisco> aldessa, in my opinion it isn't worth it for anything near the UI or system…
07:37:54 <dminuoso> aldessa: Depending on what kind of well principled you're looking for, also consider scala..
07:38:12 <hyperisco> aldessa, Xamarin is reasonable, which gives you .NET, so long as you stay away from the Xamarin Forms or whatever they call it now
07:38:15 <phadej> but indeed, if the app is very thin, mostly UI, it might not be worth writing it in anything then Native
07:38:29 <hyperisco> aldessa, and .NET has F#, if you are so inclined
07:38:37 <hyperisco> not sure if there is an option for Scala, but I am guessing there is
07:39:02 <aldessa> what is 'Native'?
07:39:05 <hyperisco> there are xplatform solutions that try to unify the UI and system APIs, and they are nightmares, in my experience
07:39:29 <phadej> aldessa: kotlin or swift
07:39:34 <aldessa> ooh as in native
07:39:39 <dminuoso> The closest "half way good solution" is "ship a browser" ala electron. :<
07:39:53 <dminuoso> But that binds you to the evil JavaScript world.
07:40:04 <dminuoso> Perhaps a GHCJS compiled electron app is a possibility?
07:40:13 <phadej> dminuoso: not on mobile
07:40:23 <phadej> don't digress
07:40:41 <phadej> save the battery!
07:41:19 <phadej> f# btw doesn't have HKD, iirc
07:41:19 <aldessa> Qt is good on the desktop, has anyone tried it for mobile?
07:41:27 <phadej> nor scala
07:41:39 <phadej> as easily
07:41:46 <dminuoso> aldessa: Qt is great for mobile. :)
07:42:01 <dminuoso> Well. fsvo grea.t
07:42:18 <dminuoso> phadej: Yeah its a real bummer how much of a battery drainer electron is. :(
07:42:21 <int-e> hmpf, why does hackage allow uploading a new candidate for an existing release
07:42:26 <hyperisco> you may be able to compile Haskell to native for each platform, but you're still going to have disparate UI and system APIs to deal with
07:42:29 <bitmapper> god i just did something dumb
07:42:31 <phadej> int-e: "why not" :)
07:42:52 <dminuoso> bitmapper: `C-x reverse-dumb` ?
07:42:54 <int-e> phadej: well it's pointless, you'll never be able to replace the existing version
07:42:57 <bitmapper> i thought this was fine for getting some old software working
07:42:59 <bitmapper> it was like 4am
07:43:00 <dminuoso> Err, M-x even!
07:43:01 <bitmapper> {-# LANGUAGE FlexibleInstances, UndecidableInstances #-}
07:43:01 <bitmapper> instance Monad a => MonadFail a where
07:43:01 <bitmapper>   fail = error "haha no"
07:43:15 <dminuoso> heh
07:43:23 <int-e> phadej: no big deal, just... ugly (I don't think I'll be able to get rid of it) and it feels wrong.
07:43:46 <phadej> oh, I don't delete candidates ever
07:43:55 <phadej> let the hackage admins worry about them
07:44:23 <phadej> (neither I "publish" from web UI, I just reupload the tarball)
07:44:24 <int-e> cabal upload */dist/*z <-- this may have been a bad idea ;-)
07:44:42 <int-e> So I'll take some part of the blame.
07:44:53 <phadej> bad idea is to have credentials saved, then yes, you have made mistake already then
07:45:27 <int-e> phadej: I don't?
07:45:50 <int-e> It only prompts once, not once per tarball.
07:45:54 <phadej> hmm. cabal could do better checks on upload then, maybe
07:46:08 <phadej> oh!
07:46:31 <phadej> maybe we should change cabal upload to allow only single tarball upload at once :)
07:46:40 <phadej> amazonka maintainer would hate me for that though
07:47:03 <phadej> ls */dist/*z | xargs cabal upload
07:47:50 * hackage random-fu 0.2.7.7 - Random number generation  https://hackage.haskell.org/package/random-fu-0.2.7.7 (BertramFelgenhauer)
07:48:50 * hackage random-source 0.3.0.11 - Generic basis for random number generators  https://hackage.haskell.org/package/random-source-0.3.0.11 (BertramFelgenhauer)
07:50:38 <aldessa> Thanks everyone, I'll try Obelisk and come back if I need help.
07:52:22 <phadej> oh, I don't think there's many people who know obelisk enough that might help :)
07:52:37 <phadej> e.g. I only know it exists :)
07:53:13 <dminuoso> phadej: Do you think you could quickly merge https://github.com/phadej/postgresql-simple/pull/45 ?
07:53:43 <phadej> I'm on "holiday", so no.
07:54:03 <phadej> in fact, I try to not do anything before GHC-9.0 is closer to release
07:54:48 <dminuoso> Fair enough. Is GHC 9.0 something to be excited about?
07:55:48 <int-e> phadej: oh would you look at that... there's an issue for that, by me, 2 years ago... https://github.com/haskell/hackage-server/issues/768
07:56:50 * hackage quickcheck-instances 0.3.24 - Common quickcheck instances  https://hackage.haskell.org/package/quickcheck-instances-0.3.24 (phadej)
07:57:46 <phadej> int-e: hah, no-one cares enough
07:58:20 <int-e> Yeah I can understand that.
07:58:25 <phadej> dminuoso: https://ghc.gitlab.haskell.org/ghc/doc/users_guide/8.12.1-notes.html
07:59:17 <int-e> phadej: Evidently I didn't care enough to do something about it either.
08:08:36 <merijn> int-e: tbh, I regularly overwrite candidates
08:08:50 <merijn> So I'm not even sure that's necessarily a win
08:09:41 <merijn> or did you mean if a released version already exists?
08:15:03 <int-e> merijn: sure, but overwriting candidates of packages that are already released?
08:15:20 <int-e> merijn: Oh, you realised... yes that's what I meant.
08:15:37 <merijn> But yeah, that seems minor enough for no one to care to implement it ;)
08:15:41 <int-e> Obviously it's very useful to be able to overwrite them before the release.
08:16:29 <int-e> merijn: I guess I just like complaining... and I was surprised.
08:16:52 <merijn> I like complaining too ;)
08:16:59 <merijn> It's much less work than implementing stuff!
08:17:11 <int-e> I know :)
09:07:37 <statusfailed> I"m trying to use blas-hs with openblas, but when I cabal-build my project, I get "undefined reference to 'cblas_sgemv'". I have libblas, libcblas, and libopenblas installed so I definitely have the libraries - how do I make ld see them?
09:08:57 <statusfailed> (I also checked cblas_sgemv is really a symbol in cblas, and it is)
09:10:20 * hackage strict-lens 0.4 - Lenses for types in strict package  https://hackage.haskell.org/package/strict-lens-0.4 (phadej)
09:11:20 * hackage strict-optics 0.4 - Optics for types in strict package  https://hackage.haskell.org/package/strict-optics-0.4 (phadej)
09:11:48 <statusfailed> also I tried adding ld-options: -L/usr/lib/libcblas.so to my cabal file
09:11:53 <statusfailed> this also doesn't work, presumably because I have no idea what I'm doing
09:14:05 <statusfailed> oh got it, I need to use -lcblas
09:15:05 <Entroacceptor> Jo, hab auch mal einen nicht-null-Wert generieren können.
09:15:06 <Lycurgus> BLAS as in the linear alg pkg?
09:15:09 <Entroacceptor> sorry
09:15:29 <Lycurgus> vielen hier konnen verstehn
09:16:23 <Lycurgus> didn sound like hs though
09:16:26 <statusfailed> Lycurgus: yea
09:17:13 <Lycurgus> i mentioned it once here and got poo pooed for it being old and outdated
09:18:16 <Lycurgus> if it's basically unchanged since b4 you were born I guess it's gotta be worthless code
09:40:26 <nerdypepper> https://termbin.com/devt is this a good way to write tests using quickcheck?
09:40:29 <nerdypepper> feels a little clunky
09:48:27 <sm[m]> do you ever wish that GHC error messages began with the first "In the..." line ? And/or the highlighted line ? Ie, first where should I be looking, not the innermost point of disagreement
09:53:19 * hackage mock-httpd 0.0.0.0 - A HTTP server for testing HTTP clients  https://hackage.haskell.org/package/mock-httpd-0.0.0.0 (PeterJones)
09:54:59 <fendor> it seems like patches from head.hackage are not applied, do I have to do more than to call `head.hackage.sh init-local && cabal v2-update && cabal v2-build`?
09:55:49 * hackage aws-lambda-haskell-runtime 3.0.3 - Haskell runtime for AWS Lambda  https://hackage.haskell.org/package/aws-lambda-haskell-runtime-3.0.3 (NickSeagull)
10:37:46 <iqubic> So, where do we land on the infinite vector thing?
10:43:49 <dmwit> E_TOOVAGUE
10:46:11 <iqubic> I want to create an infinite vector full of all the factorials.
10:49:10 <hyperisco> iqubic, depends on what you mean by "vector", but lets say it is characterised by indexing, so then  type InfiniteVector a = Nat -> a
10:49:38 <sm[m]> when you have a function defined for Monad m => ..., and you want to write a type signature for an inner helper function using the same monad, how do you satisfy GHC that the m in both type signatures is the same ?
10:49:48 <hyperisco> so then you might as well use the factorial function
10:49:58 <[exa]> iqubic: well, given arrays are basically modelled as functions from integer indexes to whatever they contain, you can probably write `factorials :: Integer -> whatever`
10:50:06 <iqubic> When I say Vector, I mean some data structure with O(1) indexing.
10:50:56 <iqubic> Yes, but I want to store the results of the factorial function, as I'll need those quite a bit in my code.
10:50:56 <dsal> Isn't that what the factorials function is?
10:51:05 <hyperisco> iqubic, well, now we're in weird territory, because space and time are real
10:51:24 <dolio> sm[m]: Scoped type variables and explicitly quantify the `m` on the top signature.
10:51:37 <[exa]> iqubic: why would you do that btw?
10:51:48 <iqubic> Why would I do what?
10:51:49 <hyperisco> iqubic, there is no real computer with infinite space, so you can only approximate such an infinite vector
10:52:01 <iqubic> Sure.
10:52:20 <hyperisco> alright, then choose a vector of satisfactory finite size and continue
10:52:31 <iqubic> Yeah, I'll do that.
10:52:36 <sm[m]> dolio: thank you.. explicitly quantify means add a forall m. , is that right ?
10:52:42 <dolio> Yeah.
10:53:33 <hyperisco> if you wanted O(1) in principle then you just need a hypothetical computer with infinite space
10:53:36 <hyperisco> like… a Turing machine
10:53:54 <dolio> Turing machines can't do O(1) infinite vector access.
10:53:55 <sm[m]> nifty
10:54:09 <hyperisco> why not? it lacks a jump instruction?
10:55:25 <[exa]> hyperisco: turing machines have the "tape". there are RAM machines that have the addressing "hardware"p
10:55:38 <[exa]> otoh vector access isn't O(1) even on real hardware
10:55:50 <hyperisco> could be
10:56:11 <iqubic> Now, is there a goodd way to count the number of bits set in the binary repersentation of N?
10:56:12 <dolio> I don't think you can even really get an infinite vector in a Turing machine. They usually only start with a finite amount of stuff written on the tape.
10:56:28 <hyperisco> iqubic, yes, check out Hacker's Delight
10:56:44 <solonarv> iqubic: this is called 'popcount', should help with searching
10:56:48 <hyperisco> you can do it in logn steps
10:56:59 <iqubic> Solo
10:57:02 <hyperisco> well, assuming you have a register big enough :)
10:57:11 <iqubic> solonarv: It's also called the Hamming Weight
10:58:26 <monochrom> The RAM model is the one that assumes O(1)-time arbitrary memory access.
10:59:22 <iqubic> Does Data.Bits have a popcount function?
10:59:34 <monochrom> Have you looked?
10:59:48 <monochrom> It has very well-defined docs.
11:01:19 <monochrom> Also I think average people throw around "infinite" too sloppily.
11:02:17 <monochrom> You don't say "infinite" when it's clearly finite, just without an a priori upper bound. You say "unbounded" for that.
11:02:57 <iqubic> alright, so I don't want an infinite vector, but rather, an unbounded vector.
11:03:15 <hyperisco> amortised O(1) is easy
11:03:37 <MarcelineVQ> Why do you want a vector of factorials?
11:03:58 <hyperisco> if you just want unbounded, this is the typical vector in many standard libraries… it resizes on an exponential growth to accommodate more elements
11:05:58 <shane_of_the_ape> what advantages does haskell have over other programming languages?
11:06:43 <dsal> shane_of_the_ape: Mostly that it's better.
11:06:46 <monochrom> functional and static typing and algebraic data types and higher-kinded polymorphism.
11:07:07 <monochrom> there are a few more I'm too lazy to enumerate
11:07:13 <dsal> Yes, laziness.
11:07:35 <iqubic> Referential Transparency.
11:07:41 <dsal> It's hard to answer a question like this without a) knowing what languages you're comparing against and b) knowing what you value.
11:07:59 <shane_of_the_ape> ty
11:08:11 <monochrom> heh perhaps they trash static typing and functional and lazy evaluation
11:08:18 <ezzieyguywuf> I have three separate packages, each with their own `./test` folder and test spec. I just created a new "Test" package, that pulls in all three so I can easily use ghcid to test them all at the same time - is this considered poor form, i.e. the duplication? if/when I upload the three separate packages to hackage, does the test stuff go along with it?
11:08:41 <monochrom> "Hi what are some advantages of PHP?" "It is error-prone."
11:09:03 <dsal> PHP is very gracious in what it accepts as input.
11:10:07 <hyperisco> ++dsal
11:10:08 <monochrom> In the Star Trek universe, the Ferengis have a lot of rules or code of conduct or something. One rule says "war is good for business". Another one "peace is good for business".
11:10:27 <MarcelineVQ> this guy, thinking we don't know the Rules of Aquisition
11:12:43 <lembot> hello all, is there any library to interface with libsensors? I can't find any
11:14:14 <hyperisco> I am fond of instructional lists… we should have more of them
11:15:10 <ezzieyguywuf> MarcelineVQ: how did you italicize that?
11:15:21 <monochrom> Lazy evaluation is good for performance. Eager evaluation is good for performance.  There!
11:15:30 <MarcelineVQ> ezzieyguywuf: I'm a wizard lizard vizier'd
11:15:46 <ezzieyguywuf> /italics/
11:15:47 <ezzieyguywuf> dang, nope.
11:15:50 <MarcelineVQ> lembot: Nothing I see at just a glance on hackage
11:16:05 <monochrom> Which key to press depends on the client.
11:16:33 <monochrom> But I can find out what byte the client sends.
11:17:18 <MarcelineVQ> monochrom:  0x1D
11:17:54 <monochrom> that
11:17:59 <MarcelineVQ> lembot: I'm super pleb and usually just go  watch -n1 sensors  ^^;
11:18:32 <ezzieyguywuf> weird, b/c this says that /italics/ *should* be it (if anyting) for my client, ad yet that didn't dot. https://irssi.org/documentation/settings/#emphasis_italics
11:18:38 <ezzieyguywuf> I think MarcelineVQ IS a wizard lizard
11:19:22 <hyperisco> are lizard wizards the same class as wizard lizards?
11:19:47 <MarcelineVQ> Not even the same family
11:20:04 <monochrom> monadic functor and functorial monad
11:20:25 <MarcelineVQ> lizard wizards are wizards who look like lizards, possible curse or personal choice reasons, wizard lizards are lizards which are wizard, a term meaning smart and cool
11:20:36 <dsal> Is a functorial monad the asum of two earlier monadic states?
11:21:01 <lembot> MarcelineVQ: Yeah, but I was thinking if a weel defined API will be usefull. Just the first page of google shows 3 rust options.
11:21:11 <hseg> for some reason, cabal doesn't pass -fkeep-going when it's in a .cabal file, but does when it's given as --ghc-options
11:21:17 <hseg> can anyone reproduce?
11:29:29 <dsal> lembot: I've never heard of libsensors, but perhaps you have an opportunity to make and publish an awesome API.
11:36:27 <lembot> dsa1: I think that's my calling, jej. libsensors is a very standard library for monitoring temp, voltage, fan speed, etc...
11:40:01 <dsal> lembot: Neat.  I'll use your library.  I tend to dump a bunch of that sort of thing into mqtt and such.
11:48:09 <merijn> hseg: Doesn't pass or doesn't rebuild at all?
11:48:21 <hseg> doesn't pass it
11:48:28 <hseg> afaict
11:48:42 <merijn> then it's impossible to say without seeing a cabal file and/or output
11:49:01 <hseg> ie even with -fkeep-going in .cabal, cabal build & cabal build --ghc-options=-fkeep-going differ in behaviour
11:49:18 <merijn> Also, which version of cabal-install
11:49:21 <hseg> am currently minimizing my mwe, will show when done
11:49:28 <hseg> 3.2.0.0
12:11:46 <emmanuel_erc> Hey there is there a way to find out where an exception is being thrown (source code line)
12:15:42 <phadej> yes, no.
12:16:00 <phadej> https://github.com/ghc-proposals/ghc-proposals/pull/330
12:17:49 <emmanuel_erc> interesting... unfortunately, that doesn't help me solve my current issue at hand. But I'm happy that this proposal exists.
12:20:07 <phadej> you can put CallStack into your exception (if you control it)
12:20:09 <phadej> like in throwIOWithCallStack :: (HasCallStack, Exception e) => e -> IO a
12:20:10 <phadej> throwIOWithCallStack exc = addBacktrace (toException exc) >>= throwIO
12:20:49 <phadej> see https://hackage.haskell.org/package/base-4.14.0.0/docs/Prelude.html#v:error for example
12:25:17 <emmanuel_erc> some context here: I'm using this code (https://github.com/obsidiansystems/rhyolite/blob/kiln/backend/Rhyolite/Backend/WebSocket.hs#L15)
12:25:30 <emmanuel_erc> So I don't think I'm controlling any exceptions here.
12:27:54 <phadej> then you are out of luck
12:27:55 <merijn> emmanuel_erc: If you compile with profiling enabled you can run the code with "+RTS -xc" to get callstacks
12:28:10 <merijn> phadej: Not if he just uses profiling mode...
12:28:22 <emmanuel_erc> I'll try that
12:28:39 <merijn> emmanuel_erc: See the GHC user's guide for details
12:28:44 <merijn> @where userguide
12:28:44 <lambdabot> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/
12:28:56 <phadej> merijn: is it "the cost-centre profiler (accessible from Haskell with GHC.Stack.CCS.getCurrentCCS) can provide cost-center stacks" ?
12:29:26 <merijn> phadej: -xc works regardless of what you do in code
12:29:39 <merijn> phadej: It just prints stack traces to stdout
12:29:47 <merijn> phadej: But yes, I think it uses the same stuff
12:35:59 <bifunc2> If   some_c_library.h   defines a #define BOOM 123
12:35:59 <bifunc2> how can I do #if BOOM 123 within my  .hs files?
12:36:23 <bifunc2> my  .hs files don't seem to be aware of constants within C header files by default
12:36:37 <merijn> bifunc2: "Very difficultly"
12:36:51 <merijn> To the point where I would strongly recommend *not* doing that
12:37:33 <bifunc2> merijn, my goal is that say if new C library version defines a  new function,  I want my Haskell wrapper only to include the Haskell function if the new C library  version is installed
12:37:41 <bifunc2> but skip the function for older versions of the C lib
12:37:49 * hackage splitmix 0.1.0.1 - Fast Splittable PRNG  https://hackage.haskell.org/package/splitmix-0.1.0.1 (phadej)
12:37:57 <merijn> bifunc2: Ok, now I would even *more* strongly advice not doing that
12:38:30 <dminuoso> I want to do some ioctl, and the necessary structs are already described in linux headers. What's the right tool to generate haskell data matching structs in those headers?
12:38:31 <merijn> Having a single package version with different APIs depending on which C library happens to be on the system is a *terrible* idea
12:38:45 <merijn> dminuoso: c2hs or c2hsc or some such
12:39:02 <bifunc2> merijn hehe, good to  know
12:39:07 <bifunc2> but why is it so bad?
12:39:17 <phadej> or hsc2hs
12:39:52 <phadej> (hsc2hs works "better", as it's bundled / maintained along GHC)
12:39:52 <merijn> bifunc2: Because now someone writes "your-package == 2.1.0" as a dependency and it suddenly breaks because the machine a user builds on has a different version of the C library installed
12:40:03 <merijn> bifunc2: You'll turn dependency management into a nightmare
12:40:07 <bifunc2> lol good point
12:40:14 <bifunc2> rofl i was headed for a disaster
12:40:19 <bifunc2> thank you
12:41:10 <dminuoso> Ah, Ill try out hsc2hs to start off with then, cheers.
12:41:49 * hackage provenience 0.1.0.2 - Computations that automatically track data dependencies  https://hackage.haskell.org/package/provenience-0.1.0.2 (olf)
12:42:05 <phadej> i understood that c2hs can do more, but imo that's the case where less is more
12:42:33 <merijn> c2hs basically auto generates c2hsc style pragma's from C files
12:42:45 <merijn> or hsc or whatever
12:44:05 <phadej> based on bug-reports in Cabal issue-tracker, c2hs is not that simple ;)
12:44:37 <merijn> It's not really intended to be a fully automated tool, more to get a 1st draft version of hsc files that you then manually tweak
12:44:47 <dminuoso> https://i.stack.imgur.com/hIn2a.png is apparently how ezyang thinks of it..
12:44:51 <merijn> But of course that doesn't really stop people from trying
12:45:07 <merijn> dminuoso: That blogpost is ancient, though :p
12:45:12 <merijn> Like, does anyone still use greencard?
12:45:35 <merijn> Hell, did anyone use greencard back in, like, 2010 when I started?
12:46:16 <phadej> people should learn to read the dates of blogposts (and not blogs which don't have published dates)
12:46:54 <dminuoso> Well, Im debating whether to use a preprocessor at all. the way ioctl works, I need to peek and poke my way through this manually either way
12:47:34 <phadej> you really want to do use hsc2hs for that
12:47:44 <phadej> its too easy to make mistake in Storable instance
12:49:39 <merijn> Manual Storable instance are great, I can get the feeling of writing C without writing C and without the pesky strict aliasing rule :p
12:56:10 <phadej> whatever gives you kicks :)
12:57:28 <emmanuel_erc> merijn: So, I'm actually building this haskell code with nix
12:57:37 <emmanuel_erc> can I specify runtime options in the cabal file?
12:58:00 <merijn> I don't use Nix, so who knows
12:59:41 <emmanuel_erc> ok
13:00:09 <phadej> runtime options of what?
13:00:58 <phadej> maybe you are looking for https://cabal.readthedocs.io/en/3.4/cabal-package.html?highlight=conditional#conditional-blocks
14:02:46 <monochrom> Haha, my wish comes true!
14:03:38 <monochrom> Here is my wish: "how do I extract IO from IO String?"
14:04:21 <monochrom> Here is wish come true: "Extracting IO": https://www.taezos.dev/posts/2020-07-30-extracting-io.html  (from today's Haskell Weekly News)
14:05:04 <dminuoso> getIO :: IO String -> Proxy IO; getIO _ = Proxy
14:05:08 <dminuoso> Does that count, monochrom?
14:05:14 <monochrom> hehe!
14:05:55 <monochrom> tl;dr it's dependency injection
14:07:54 <Uniaika> (don't forget to use sterile syringes before injecting dependencies)
14:08:11 <monochrom> haha
14:09:47 <plam4u> hey guys, I'm new here and I'm reading a book about haskell. I have trouble understanding some basic stuff :(  
14:09:58 <plam4u> myNum = 1 :: Integer
14:10:04 <plam4u> myVal :: Num a => a -> a; myVal f = f + myNum
14:10:15 <plam4u> doing this would trigger an error
14:10:25 <hyperisco> monochrom, you are summoned
14:10:25 <plam4u> Couldn't match expected type ‘a’ with actual type ‘Integer’
14:10:44 <hpc> plam4u: when you add numbers, they have to be of the same type
14:11:07 <hpc> you're saying f can be any numeric type, but then adding an Integer to it
14:11:07 <monochrom> Haha I see what hyperisco means
14:11:08 <plam4u> you mean exactly the same type? Num is a typeclass and Integer is a more specific type, right?
14:11:42 <monochrom> But this is not even that.
14:11:52 <hpc> plam4u: more or less, yes
14:12:31 <monochrom> This is thinking in Java, mistaking Num to be a "parent" and Integer "a child of Num".
14:12:41 <monochrom> No, there is no such thing in Haskell.
14:12:52 <plam4u> I saw in several places to think of type classes kind of like interfaces in OOP languages. If I have for example an interface that says "this type provides adition" then I would expect a more specific type that has adittion and more, to satisfy the requirements
14:13:14 <monochrom> "kind of like" is misleading. I say unlike.
14:13:39 <plam4u> so, in this case, when it is specified Num typeclass it should be Num and nothing else?
14:13:49 <hpc> plam4u: in OOP languages you can treat interfaces like types, in haskell you can't
14:14:02 <monochrom> And my reason is as stated. In Java, for example List is a parent of LinkedList. This is different from Haskell.
14:14:15 <dminuoso> hpc: well.. I can treat constraints as types... :>
14:14:17 <hpc> when it says "Num a" there, it means whatever type 'a' ends up evaluating to needs to satisfy the "Num a" constraint
14:14:19 <dminuoso> Does that cout?
14:14:28 <hpc> by there existing an instance Num whateverAWas
14:14:51 <hpc> dminuoso: :P
14:15:14 <plam4u> hpc, passing Integer should be satisfying the Num requirement, no?
14:15:33 <plam4u> Integer has instance of Num
14:15:39 <lyxia> How is this possible, my optimized Core is not the same if I depend on a package from Hackage as if I depend on a local clone of it
14:15:41 <hpc> yes, but that's not quite what you're doing here
14:15:57 <hpc> you're saying myVal has to work for /all/ 'a's
14:16:03 <hpc> but the implementation only works for Integer
14:16:23 <monochrom> In particular, users of myVal, not you, decide what "a" becomes.
14:16:46 <monochrom> Your code says you want "a" to be Integer, without permission from users.
14:17:02 <monochrom> You have no such permission.
14:17:17 <monochrom> My Freedom Is Your Slavery.
14:18:01 <plam4u> I think I get. If somebody else applies myVal to Float for example, it wouldn't work because the implementation is using Integer which implicitly requires users to use Integer as well
14:18:09 <monochrom> Right.
14:18:37 <monochrom> Better ditch OOP mindset because it does the opposite.
14:18:42 <plam4u> thanks for the support guys :)  It really takes me time to wrap my head around these stuff
14:19:03 <plam4u> I try to, but I've been programming in OOP 10+ years and that's all I know :(  
14:19:33 <monochrom> An easy way is to discard any tutorial/blog/tweet that claims analogies between Haskell and OOP.
14:19:34 <hpc> (it's pretty entertaining how accurate "does the opposite" is, once you get more into how type systems work)
14:19:48 <plam4u> :D  
14:20:11 <plam4u> I'm reading "Haskell Programming from First Principles"
14:20:25 <plam4u> it is supposed to be for beginners
14:21:01 <monochrom> Hey it's because I really studied this from the POV of logic.  Haskell's is "for all", OOP's is "there exists". It's precise.
14:21:38 <plam4u> no idea what you're talking about…
14:22:01 <plam4u> I've seen "for all" in some type signatures when poking around in the GHC
14:22:13 <plam4u> but not sure what it stands for (what concepts are behind)
14:22:31 <hpc> plam4u: so, whenever a type variable appears in a type there's an implicit forall
14:22:41 <hpc> so id :: a -> a is really id :: forall a. a -> a
14:23:03 <hpc> forall basically means "for all values of a, this thing is valid"
14:23:05 <plam4u> but this is not a type class, right?
14:23:11 <monochrom> There are two schools of teaching. One school draws analogy with what you already know because it's more comfortable. The other school (I joined them, maybe I'm the only one) quite frankly recognize that learning must be uncomfortable, must challenge what you already know.
14:23:20 <hpc> exists means "there exists a value of a for which this thing is valid"
14:23:56 <plam4u> since "there exists" is like "partial application" it is error prone…, right?
14:24:30 <hpc> it's hard to give an example of exists in haskell, but it's not quite like partial application
14:25:13 <hpc> basically, you don't get to do the same things with a type variable defined with exists as you would with forall
14:25:15 <monochrom> My http://www.vex.net/~trebla/weblog/any-all-some.html is a good introduction of what I mean by for all and exists.
14:26:09 <plam4u> I'll read it, thank you very much :)  
14:26:19 <plam4u> sorry, I didn't mean "partial application" but rather "Partial functions"
14:26:40 <monochrom> Also guess why I named the characters Demi and Ange! :)
14:27:09 <frdg> is there syntax for reffering to an argument you pattern matched on as a whole? `f :: a -> MyType; f (MyType name phoneNum) = (MyType with both args)`
14:27:24 <magicman> Any conduit-users here? I get `Either a b` from upstream, but both sides need to go into a different sink.
14:27:35 <yushyin> frdg: @-pattern
14:28:05 <frdg> ok
14:28:12 <magicman> They also need some different processing. I'd also be happy with `ConduitT a c m () -> ConduitT b d m () -> ConduitT (Either a b) (Either c d) m ()`.
14:28:25 <yushyin> frdg: foo@(Foo a b)
14:29:41 <frdg> yushyin: I still have to mention the variables? I have 7 variables that came from a pattern match so it looks ugly to list them all out.
14:31:05 <magicman> Using `awaitForever >>= either (\a -> yield a .| sinkForLeft .| map Left) (\b -> yield b .| sinkForRight .| map Right)` doesn't work for me, as it re-starts the sinkForLeft and sinkForRight for every element, while I want to, for example, add up all the Left elements, and multiply all the Right elements. Or something like that.
14:31:35 <monochrom> The alternative to bound variables is de Bruijn numbering.
14:32:25 <monochrom> When people find an approach unsatisfactory, they often forget "compared to what?". The other pasture is seldom greener.
14:33:06 <monochrom> s/find/feel/   # really, don't give credit to subjective judgment
14:33:21 <dolio> If you use record syntax you don't have to talk about all the fields.
14:35:54 <monochrom> As a reader, I would rather read 7 ugly identifier bindings than 7 beautiful de Bruijn indexes. Because I cannot be counted on to count correctly by the time there are 7 of them.
14:36:24 <monochrom> darn, s/cannot/can't/  to make it sound funny!
14:37:36 <frdg> ok ill just appreciate what I have 
14:38:55 <monochrom> I guess I forgot there is a third way. Because I disdain it so much it's out of the question.
14:39:34 <monochrom> "f r@(Ctor x y z) = ...x...y...z...r..." vs "f r = ...getX r...getY r...getZ r...r..."
14:40:40 <dolio> Well, that's not the only way to use record syntax.
14:40:53 <monochrom> But you're trading 7 identifiers for 6 selectors.
14:41:24 <magicman> I'd personally go for `f r@Ctor{..} = ...fieldX...fieldY...fieldZ...r...`. If I'm going to use many fields, may as well use RecordWildCards (though when using only a single field, that's overkill).
14:41:43 <monochrom> Yeah, I like that one.
14:42:34 <monochrom> But it doesn't help "f :: MyRecordType -> MyRecordType -> ..."
14:42:44 <magicman> Nope :-/
14:42:57 <monochrom> Nothing helps. All is lost.
14:44:02 <dminuoso> Mmm, it seems hsc2hs cant generate data types with matching storable instances. At first glance, c2hs does not have a "data hook" either. Am I missing something? What other options do I have?
14:44:03 <magicman> Writing Semigroup instances for record types, where every field is pretty much "Use <> on the values of that field", ugh.
14:44:14 <monochrom> Why can't the computer just read my mind!
14:44:44 <magicman> (though I feel like that particular case could be automated? It's very mechanical...)
14:44:59 <monochrom> I think GHC.Generics helps that one.
14:45:24 <solonarv> yes, and generic-data
14:45:34 <magicman> (then again, I prefer my fields to have type "Maybe Text", and not "First Text" or "Last Text". The combination strategy is an implementation detail to most consumers of the datatype...)
14:45:40 <monochrom> In the sense that you write some ugly code but you write just one version (and it is not too long).
14:45:54 <solonarv> magicman: I think generic-data can even deal with that!
14:46:25 <magicman> Not to mention Maps, which can be union'ed, or unionWith (<>)'ed, both of which make sense in various contexts.
14:46:40 <monochrom> haha generic-data has already done Semigroup and Monoid for you!
14:46:56 <magicman> Oooooh, gonna look at generic-data, then. Sounds promising!
14:47:12 <monochrom> And Eq and Ord etc etc
14:47:37 <magicman> Right, but those work fine with deriving stock (Eq, Ord).
14:47:46 <monochrom> Can I do "deriving Generics" on a GADT?
14:48:54 <dminuoso> monochrom: https://ryanglscott.github.io/2018/02/11/how-to-derive-generic-for-some-gadts/
14:48:58 <monochrom> I guess I can just try.
14:52:43 <magicman> Hrm. My understanding is that I should `deriving (Semigroup, Monoid) via (First Text, Last Text, LeftBiasedUnionMap k a, LiftedMappendMap k a)`, or something.
14:53:10 <magicman> Would have to newtype-wrap LeftBiasedUnionMap (and RightBiased... and any other variants), but that still beats manually writing those instances <_<
14:53:53 <magicman> Err, `via Generically (really, long, tuple, type)`.
14:58:51 <solonarv> magicman: no, you have to say 'Generically MyType'
14:59:43 <magicman> Hrm. Then how do I specify that the first field is Maybe Text, but should be combined as if it was First, the second field is Maybe Text, but should be combined as if it was Last, etc.?
15:00:21 <magicman> I mean, I could make those fields First Text and Last Text to begin with, but that introduces a bunch of jank in the rest of the codebase for a detail that's only really necessary in the Semigroup instance.
15:00:28 <solonarv> it appears that generic-data actually can't do this
15:00:36 <solonarv> generic-lens or generic-data-surgery might be able to
15:00:45 <magicman> The search continues.
15:04:27 <hseg> Do note that Data.Monoid.First /~ Data.Semigroup.First -- only the first is coercible to/from Maybe
15:05:19 <hseg> and that one is slightly annoying for semigroup stuff
15:05:43 <magicman> ... because obviously.
15:05:50 <plam4u> @monochrom I've checked this article https://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types and it is much more clear now to me. I just waanted to thank you for the help :) 
15:05:50 <lambdabot> Unknown command, try @list
15:05:57 <plam4u> @monochrom++
15:05:57 <lambdabot> Unknown command, try @list
15:06:19 <hseg> i mean, you you don't need First Nothing for the Semigroup instance, so why have it pollute the newtype?
15:06:46 <magicman> Oh, but I think just regular `deriving via (really, long, tuple, type)` should work, as almost any reasonable tuple size is already an instance of Semigroup and Monoid?
15:06:52 <monochrom> thanks
15:07:15 <magicman> Wait, no, record types are not coercible to tuple types.
15:07:33 <hseg> sure. that reduces your problem to ensuring your tuple components have instances
15:08:26 <magicman> Yeah, that's what I was looking for. "I hate writing Semigroup and Monoid instances for record types where the implementation is just some flavour of <> on individual fields".
15:09:37 <magicman> But if record types were coercible to tuple types, then `deriving ... via (First This, Last That)` would work. Or perhaps (Maybe (First This), Maybe (First That)). Have to look into that Semigroup.First VS Monoid.First stuff...
15:10:01 <magicman> ... module inconsistent naming, but you get the idea <_<
15:10:24 <hseg> newtype Monoid.First = First { getFirst :: Maybe a}, newtype Sgp.First = First { .. :: a }
15:10:42 <hseg> basically a question of whether you need to wrap stuff in Just or not
15:11:22 <hseg> So for the usual record case, you probably want the Monoid version
15:12:42 <magicman> *nodnod*.
15:13:15 <hseg> seems that for the record-as-tuple thing you want deriving via (Surgery Derecordify ..)
15:15:28 <hseg> https://hackage.haskell.org/package/generic-data-0.9.0.0/docs/Generic-Data-Microsurgery.html seems to be your friend here
15:15:43 <hseg> looks *awesome*, especially for derivingvia stuff
15:19:43 <magicman> Ooooooh. I'm looking at the CopyRep example, and that looks related.
15:22:30 <hseg> yup
15:22:38 <hseg> enjoy!
15:23:20 * hackage hextra 1.0.0.0 - Generic and niche utility functions and more for Haskell.  https://hackage.haskell.org/package/hextra-1.0.0.0 (anselmschueler)
16:29:32 <hseg> ... http://ix.io/2tsX wtf
16:29:43 <hseg> clearly i don't understand how to backpack
16:31:59 <hseg> sorry, forgot to post log as well http://ix.io/2tt0
16:40:29 <hseg> ... it's late, will ask again tomorrow
16:42:34 <koz_> I'm using inline-c to try and grab the value of a C string literal. What would this type as in Haskell?
16:45:15 <dsal> Some kind of ByteString?
16:46:47 <koz_> "Pointers and arrays get converted to Ptr."
16:46:54 <int-e> probably this: type CString = GHC.Ptr.Ptr CChar (from Foreign.C).
16:47:07 <koz_> Ah, nice! Thanks int-e.
17:12:26 <jackdk> Does this exist anywhere? An operator to give me a singleton map-like-thing using combinators from lens: https://www.irccloud.com/pastebin/DiwZvHrs/MapSingleton.hs
17:12:58 <jackdk> Maybe `(==>)` is a better name for similarity with stuff from the dependent-{sum,map} universe
17:14:54 <magicman> Aight, found a solution to my earlier conduit-related problem. You can mess about with ZipConduits, and (C.concatMap getLeft .| sinkForLeft) and (C.concatMap getRight .| sinkForRight), and that won't reset the state in sinkForLeft and sinkForRight.
17:15:21 <plam4u2> :q
17:16:25 <magicman> ... conduit doesn't export an identity-Conduit, does it... now I need a version of C.null that passes through its upstream, and I can only think of `C.null <* someIdentityConduit`.
17:16:40 <magicman> `awaitForever yield` should do the trick... let's hope it inlines properly >_>
17:19:05 <Axman6> jackdk: I feel like I've seen that in ... something dibblego wrote, or something similar at least. possibly in the java classfile thing. Or maybe it was the jose package's use of the Cons class for base64 encoding/decoding things
17:19:30 <jackdk> Axman6: seriously considering just PRing Control.Lens.At.
17:19:48 <Axman6> go for it
17:20:11 <Axman6> seems pretty useful. I await the operator name bikeshedding (==> seems good to me)
17:21:16 <magicman> Current goal is to write something of type `(r -> ConduitT i o m r) -> r -> ConduitT i o m ()` that runs the source over and over (with updated values for 'r'), until at some point a single run produces no more output downstream.
17:26:53 <Axman6> I believe in you, you can do it!
17:32:04 <jackdk> Axman6: well I've got a nix-shell cooking, hopefully this doesn't take too long
17:35:53 * Axman6 Narrator: It would take too long
17:52:33 <magicman> Whoop, it works. `C.null <* awaitForever yield` still feels a bit janky, but I'll have to live with that.
17:53:07 <Axman6> I feel like awaitForever yield has another name already
17:53:31 <jackdk> Axman6: are you still making nix jokes? in any case I got the PR up: https://github.com/ekmett/lens/pull/937
17:54:31 <magicman> Yeah, it should function as identity-Conduit, but I couldn't find anything with the right type through Hoogle.
17:55:06 <Axman6> jackdk: yes, yes I am :)
17:55:19 * hackage matrix-as-xyz 0.1.2.0 - Read and Display Jones-Faithfull notation for spacegroup and planegroup  https://hackage.haskell.org/package/matrix-as-xyz-0.1.2.0 (narumij)
18:21:20 * hackage matrix-as-xyz 0.1.2.1 - Read and Display Jones-Faithful notation for spacegroup and planegroup  https://hackage.haskell.org/package/matrix-as-xyz-0.1.2.1 (narumij)
18:53:38 <iqubic> Hmm. I'm having trouble representing the type I want to. I'd like to write "data GenericVectorPair v a =..." which holds two generic vectors of type v with elements of type a. I'm not sure how to do that.
18:57:37 <monochrom> = Ctor (v a) (v a)  ?
19:00:54 <ddellacosta> in the section with bullets comparing it to mtl, right above the example, it says "capabilites are discharged with deriving-via combinators and generic-lens..." what does "discharged" mean here? https://github.com/tweag/capability/
19:04:26 <iqubic> monochrom: I was doing that, but I want to constran v to being a vector. I don't want to be able to construct an instance of this datatype with v ~ Maybe.
19:11:37 <ski> ddellacosta : i think they mean how the `HasReader ..',`HasState ..' constraints are satisfied (removing/discharging them from being unresolved constraints)
19:42:02 <hololeap> iqubic: i think that generally you don't want to have any constraints on how to construct a data type, but rather you have the constraints you need on functions that use it
19:42:40 <iqubic> Ah. I see.
19:48:08 <iqubic> Wait, why is that?
19:53:20 * hackage uuid-bytes 0.1.2.0 - UUID parsing using byteverse packages  https://hackage.haskell.org/package/uuid-bytes-0.1.2.0 (goolord)
20:32:35 <Axman6> iqubic: because those constraints infect all functions which operate on that type, show Show's instance would like instrance (Show (v a), Vector v) => Show (GenericVector v a) where ... whereas it should be instrance Show (v a) => Show (GenericVector v a) where 
20:33:47 <Axman6> so every function which touches a GenericVector v a would need a Vector v constraint even if it uses nothing from the Vector class
20:41:48 <ski> "I don't want to be able to construct an instance of this datatype with v ~ Maybe." -- why not ?
21:12:43 <iqubic> ski: Well, because 90% of the time I'll be using this datatype as a pair of Vectors
21:13:15 <iqubic> I can't think of any other type I'd want to instantiate v to be
21:22:37 <Axman6> maybe your users are more imaginative than you :)
21:31:39 * ski . o O ( argument by lack of imagination ? )
21:40:17 <Axman6> I have proved this code correct by not being able to think of a way it could go wrong - every developer everywhere
21:45:39 <lemmih> Is there a pretty-printer for cabal files?
22:30:16 <sm[m]> I seem to remember a cabal-format
22:58:28 <maier> With cabal, is there a way to run multiple executable simultaneously? I'm trying to create a Makefile target that starts up a couple of executables from packages in our project that we need running when testing a client.
22:59:21 <maier> I tried doing `cabal run exe:foo & cabal run exe:bar & ..`, but then the cabal processes start simultaneously and disturb each other.
23:02:06 <Axman6> whu do you need cabal to run the processes?
23:02:20 <Axman6> why*
23:03:08 <maier> Axman6: what would be the alternative? I could maybe build and use the executables, but wouldn't I need to specify the paths myself then?
23:03:51 <maier> Perhaps I'm overlooking a simple alternative :) In reality, all this needs to be started inside a pure nix-shell as well btw, as e.g. cabal is guaranteed to be available there.
23:04:53 <Axman6> I think cabal can tell you what the paths are
23:06:13 <jackdk> pretty sure the paths are predictable under dist-newstyle somewhere
23:09:07 <maier> jackdk: predictable yes, but I think OS-dependent in some way.
23:09:19 <Axman6> you could also use cabal v2-install foo:exe --install-method=copy --installdir=./foo a la https://cabal.readthedocs.io/en/3.4/cabal-commands.html#cabal-v2-install
23:09:34 <maier> Axman6: good point, I'll check that out!
23:10:01 <Axman6> that also gives you a known path which you can use to have make rebuild things when needed if you want
23:10:16 <Axman6> you probably don't though
23:11:20 <maier> Axman6: yeah, it's actually quite perfect, thanks! I'll point to a git-ignored folder inside the project that I clean via make. That should suffice for the few times people need this.
23:12:20 <maier> It's a "feature" for a customer who wishes to have the dev setup running on his computer, to test the bleeding-edge build. That's the easiest way to give him a "start everything" command.
23:13:27 <Axman6> ./nike.doit
23:27:33 <asheshambasta> are there any references for building (and importing) a haskell project with multiple cabal sublibs? 
23:28:06 <asheshambasta> eg. I have a .cabal file with `foo-core`, `foo-interface` etc. and I'd like to use `foo-interface` as a dependency elsewhere
23:28:12 <asheshambasta> (I'm using nix)
23:28:56 <Axman6> sounds like you want a cabal.project file maybe?
23:29:19 <asheshambasta> is that the only way about this?
23:29:26 <Axman6> I don't know
23:29:45 <asheshambasta> from what I can see; parsing cabal project files in nix seems a little ad-hoc
23:31:15 <asheshambasta> I've so far found this https://gist.github.com/codebje/000df013a2a4b7c10d6014d8bf7bccf3
23:37:05 <maier> asheshambasta: we split our project into multiple cabal files, with each being included in a haskellPackages overlay. This way, they can cross-reference/use each other. For development, you can have one shell.nix that uses `shellFor` to give you a dev environment for all your packages. Then having a cabal.project file is no hassle and inside the nix shell, you can just use cabal.
23:37:21 <maier> Maybe I'm blind, but how can I find out my IP address from Haskell?
23:38:14 <asheshambasta> anyway; from what I can gather from cabal sublibs is that they're mainly only meant to be used internally within the same package. Only the default library is exposed under the name of the package. And earlier than cabal 3.0 and ghc 8.8 there's no way to depend on sublibs and make them publicly visible.
23:38:31 <asheshambasta> https://fgaz.me/posts/2019-11-14-cabal-multiple-libraries/#how
23:39:52 <asheshambasta> maier: thanks; yeah that is what I was thinking about; more like having the nixexprs hardcoded rather than using some ad-hoc parsing.
23:43:40 <fgaz> "asheshambasta" (https://matrix.to/#/@freenode_asheshambasta:matrix.org) cabal-install 3.4 backports the multilibs feature to older ghcs :)
23:45:43 <asheshambasta> aha; I believe that could work
