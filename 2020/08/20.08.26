00:00:39 <Graypup_> actually the main thing that got me off stack was that they don't support ghcjs, and Nix also lets us ship binary builds of our stuff and dependencies, which is really sweet for ghcjs as it's really slow
00:01:26 <Graypup_> previously there was a 2GB docker container being slung around to get an actually working version of ghcjs, which seemed a bit absurd
00:08:59 <maerwald> Graypup_: at least you know how to fix it :)
00:09:17 <Graypup_> bleh stack at it again with its locale crash :(
00:09:22 <Graypup_> they say they fixed it!
00:09:29 <Graypup_> but i believe that was a falsehood
00:09:35 <Graypup_> another reason I'm on nix lol
00:13:19 * hackage template-haskell-compat-v0208 0.1.3 - A backwards compatibility layer for Template Haskell newer than 2.8  https://hackage.haskell.org/package/template-haskell-compat-v0208-0.1.3 (NikitaVolkov)
00:58:04 <Graypup_> i am so tired
00:58:08 <Graypup_> stack does not work
00:58:37 <Graypup_> it is trying to build shakespeare and it is failing with no error message other than ghc returning ExitFailure (-11)
01:01:02 <Graypup_> i continue to be tired as stack is failing due to bloody locale issues AGAIN
01:01:13 <Graypup_> separately to not building shakespeare for no reason
01:06:20 <Graypup_> so because stack is broken I can't figure out if my yesod issue is my fault
01:14:19 * hackage jsop 0.2.0.0 - Cherry picking in JSON objects  https://hackage.haskell.org/package/jsop-0.2.0.0 (PaoloVeronelli)
01:17:12 <maerwald> Graypup_: tried stack2cabal and then just use cabal?
01:25:25 <Orbstheorem> How would I go about testing a function that sends an email and performs a POST request (user callback)?
01:26:20 <c_wraith> depends.  Are you testing your email sending library and http client, or just that you queue those actions up correctly?
01:26:49 * hackage jsop 0.2.0.1 - Cherry picking in JSON objects  https://hackage.haskell.org/package/jsop-0.2.0.1 (PaoloVeronelli)
01:28:24 <Orbstheorem> I'm testing that such actions are queued correctly.
01:29:55 <Orbstheorem> I thought about putting both actions in a class `Notify` and running different monads on test and prod; with the prod one being a thin as possible (and not tested).
01:31:02 <Graypup_> maerwald, no, but that sounds like a good idea
01:35:14 <Graypup_> lol it's broken in nixpkgs
01:35:16 <Graypup_> time to pass away
01:35:42 <Turmfalke> .oO(irccloud.com is the new matrix.org, it seems)
02:24:37 <fog> expressing function implementations on a graph seems natural, and observes the monadic nature of implementations
02:25:20 <fog> because trees (and by extension, graphs, as cyclic trees) are monads, because trees of trees are trees
02:26:44 <fog> so then the tree-like nature of function implementations realises the fact that function implementations, functions consisting of functions - function implementations built on trees of function references, are monads
02:27:18 <fog> functions take lists lists of arguments, bound to the outputs of functions, just as trees have lists of branches 
02:27:55 <fog> then, it is essentially the list monad that lies at the heart of this, as lists of lists can be concatenated into lists 
02:28:27 <fog> just as function implementation in terms of let bound variables, can have the referencing replaced by inline rewrites of the functions they reference
02:28:54 <fog> but, this is just part of what monads offer. this is observing join, and we should consider what we get from bind
02:29:07 <fog> :t (>>=)
02:29:08 <lambdabot> Monad m => m a -> (a -> m b) -> m b
02:29:41 <fog> bind is basically, fmapping something with the same type as return, and then joining the result 
02:29:44 <fog> :t return
02:29:45 <lambdabot> Monad m => a -> m a
02:30:41 <fog> then, the advantage we get from representing functions explicitly as trees or graphs, is that we can operate on implementations - stringing these opperations together with bind
02:31:35 <fog> also, when we have the implementation of a function as a tree (and this is a separate point) we no longer *have* to do let bound referencing
02:31:56 <fog> in haskell, we pattern match variables at the function head, at the left hand side of the equals sign
02:32:31 <fog> whereas, representing functions on a tree or graph, we can bind the destination or use site, using the edges of the graph
02:33:08 <fog> this basically allows the destination to be specified (notionally), at the production site, instead of the use site
02:33:46 <fog> functions taking lists of arguments, can produce lists of outputs, and send these along the edges of the graph to different parts of the overall implementation
02:34:21 <fog> this fits perfectly with the concept of linear types - as we can have variables that we know exactly where they will be used
02:36:07 <fog> so by this alternative to let binding of variable references, to be decided at the production site, choosing where they will be used, this approach serves to achieve linear types, and gets the benefits of knowing where a variable is used, for alleviating the need for garbage collection  
02:36:42 <fog> not only do we have type safety, but also structural guaranties about variable usage  
02:37:28 <fog> combined with the earlier point about being able to operate on function implementations monadically 
02:38:35 <fog> essentially this can serve instead of template haskell, and we can have programs that modify function implementations extensibly, while preserving type safety and type linearity 
02:41:02 <fog> being able to pass functions as arguments over the edges of the graphical "net" allows that these functions themselves, with implementation built on the graph with explicit edges, can operate over function implementation passed through the net, meaning not only that the function implementations typecheck, and can be evaluated without the need for
02:41:02 <fog> garbage collection 
02:42:26 <fog> but also, that *the programming itself* has guaranties about type safety. meaning our algorithmic program generation preserves well typedness, and variable usage guaranties based on type linearity 
02:42:50 <maerwald> ok
02:43:34 <maerwald> and quitting right after :)
02:44:17 <fog> im here
02:50:23 <fog> i think basically, that as a programmer, i can change a functions implementation that will not typecheck. but that somehow by representing this program transformation itself as a typechecking function on function implementations, that only valid alterations to a function implementation can be structured onto a graphical function implementation that
02:50:24 <fog> itself typechecks
02:52:07 <fog> maybe this could be thought of as "deriving programs" programmatically, and "programs which derive other programs"
02:52:43 <fog> i like how this is something that seems to follow naturally from function nets
03:14:19 * hackage template-haskell-compat-v0208 0.1.4 - A backwards compatibility layer for Template Haskell newer than 2.8  https://hackage.haskell.org/package/template-haskell-compat-v0208-0.1.4 (NikitaVolkov)
03:25:49 * hackage contravariant-extras 0.3.5.2 - Extras for the "contravariant" package  https://hackage.haskell.org/package/contravariant-extras-0.3.5.2 (NikitaVolkov)
03:26:02 <ph88> What is a good number to give as first argument to https://hackage.haskell.org/package/math-functions-0.3.0.1/docs/Numeric-MathFunctions-Comparison.html#v:within ??
03:28:19 * hackage cuda 0.10.2.0 - FFI binding to the CUDA interface for programming NVIDIA GPUs  https://hackage.haskell.org/package/cuda-0.10.2.0 (TrevorMcDonell)
03:29:49 * hackage nvvm 0.10.0.0 - FFI bindings to NVVM  https://hackage.haskell.org/package/nvvm-0.10.0.0 (TrevorMcDonell)
03:30:17 <kuribas> ph88: 42
03:30:30 <ph88> why ?
03:30:48 * hackage cublas 0.6.0.0 - FFI bindings to the CUDA BLAS library  https://hackage.haskell.org/package/cublas-0.6.0.0 (TrevorMcDonell)
03:30:54 <kuribas> it's a good number :)
03:31:00 <kuribas> it's the answer to everything
03:31:49 <asheshambasta> https://gist.github.com/asheshambasta/6daf65e73a4a34b3fd2e580363f40dad I was wondering if Continuation passing style (if at all) could help with the design of this. 
03:31:49 * hackage cusparse 0.3.0.0, cufft 0.10.0.0 (TrevorMcDonell): https://qbin.io/food-wales-9dzs
03:32:49 * hackage cusolver 0.3.0.0 - FFI bindings to CUDA Solver, a LAPACK-like library  https://hackage.haskell.org/package/cusolver-0.3.0.0 (TrevorMcDonell)
03:33:12 <asheshambasta> With my current operators; it starts becoming ungainly quite fast: https://gist.github.com/asheshambasta/6daf65e73a4a34b3fd2e580363f40dad#file-user-hs
03:35:11 <Axman6> what would you like to write?
03:36:26 <asheshambasta> Axman6: I think instead of using specialised operators (:< & :<<);  a do block. 
03:37:52 <Axman6> it almost feels like there's some kind of contravariant functor there over the h's
03:38:48 <Axman6> like (\tableContent -> (Html.table tableContent) `Html.styledWith1` UsFrom) could become just Html.table >$< (`Html.styledWith1` UsFrom)
03:39:14 <Axman6> I reckon changing the order of the arguments to StyledWith gets you a lot already
03:39:20 <Axman6> :t (>$<)
03:39:22 <lambdabot> error:
03:39:22 <lambdabot>     • Variable not in scope: >$<
03:39:22 <lambdabot>     • Perhaps you meant one of these:
03:39:26 <Axman6> @:t (>$<)
03:39:26 <lambdabot> Maybe you meant: wn v rc pl let id do bf @ ? .
03:39:30 <Axman6> @ :t (>$<)
03:39:35 <Axman6> % :t (>$<)
03:39:36 <yahb> Axman6: ; <interactive>:1:1: error:; * Variable not in scope: >$<; * Perhaps you meant one of these: `>$' (imported from Control.Lens), `Q.><' (imported from Test.QuickCheck), `Seq.><' (imported from Data.Sequence)
03:39:43 <Axman6> :(
03:40:33 <asheshambasta> :()
03:41:25 <asheshambasta> Axman6: yeah; my argument order is out of whack.
03:41:48 <kuribas> asheshambasta: are you creating youre own DSL?
03:41:52 <kuribas> for html?
03:41:57 <kuribas> why not use blaze or something?
03:42:14 <asheshambasta> I mainly went for that considering how nicely `someHtml `StyledWith` Foo` read. 
03:42:37 <asheshambasta> kuribas: I am using blaze, but I want to expose a simpler DSL for email templating in one of our email services. 
03:42:54 <kuribas> right
03:43:32 <asheshambasta> and have types represent styles etc. We have rather complex styling stuff going on inside emails sent to clients, sadly.
03:47:33 <kuribas> asheshambasta: you can simplify toMarkup
03:47:40 <kuribas> by removing the let
03:49:02 <asheshambasta> correct, I've not cleaned this up yet. 
03:51:37 <kuribas> that undefined is also going away?
03:51:55 <asheshambasta> yeah
03:52:01 <kuribas> it looks pretty clean to me
03:52:34 <asheshambasta> you mean with the "dsl" as is? 
03:53:26 <kuribas> well, I don't know how this DSL fits in the whole...
03:54:30 <asheshambasta> kuribas: pretty much like in User.hs; with some additional type(s) & the HasStyle instance(s)
03:54:35 <kuribas> for example, do you really need a typeclass here.
03:54:57 <asheshambasta> Which one? :-P 
03:55:03 <kuribas> or could you make IsContent a datatype instead
03:57:45 <kuribas> Unstyled and Styled can be merged into H.ToMarkup h => h -> [] -> Content c
03:58:05 <kuribas> though you may have a reason to do it like this...
03:59:49 * hackage recommender-als 0.2.1.1 - Recommendations using alternating least squares algorithm  https://hackage.haskell.org/package/recommender-als-0.2.1.1 (kaol)
04:11:49 * hackage autoapply 0.4.1 - Template Haskell to automatically pass values to functions  https://hackage.haskell.org/package/autoapply-0.4.1 (jophish)
04:13:16 <ryba> hi. im trying to build ghc from sources, and have following errors:
04:13:16 <merijn> hmm
04:13:45 <ryba> damn, how do i paste...
04:13:54 <maerwald> not into the channel :)
04:13:59 <ryba> /home/ryba/ghc/compiler/stage1/build/libHSghc-9.0.0.20200821.a(Plugins.o)(.text+0x245c): error: undefined reference to 'ghc_GHCziCoreziOptziMonad_zdfxMonadCoreM_closure'
04:14:02 <merijn> I have a Map with Int keys starting from 0 to N, with some gaps. Anyone know what the easiest way to condense them would be? Just convert to a list and zip with [0..]?
04:14:11 <ryba> /home/ryba/ghc/compiler/stage1/build/libHSghc-9.0.0.20200821.a(Plugins.o):function ghc_GHCziDriverziPlugins_defaultPluginzux_info: error: undefined reference to 'ghc_GHCziCoreziOptziMonad_zdfxMonadCoreM_closure'
04:14:16 <ryba> is this some known error?
04:15:11 <maerwald> ryba: I think this is very ghc specific, there's a #ghc channel, where the devs hang out too
04:15:35 <ryba> thx
04:15:45 <maerwald> I haven't seen it, but it seems you're bulding head or something
04:16:01 <maerwald> you should also provide some platform info
04:18:23 <kuribas> merijn: bitvector?
04:18:36 <merijn> kuribas: hmm?
04:18:38 <kuribas> merijn: depends on how sparse it is I suppose
04:19:00 <kuribas> merijn: why do you need to condense it?
04:19:03 <merijn> kuribas: No, I just wanna make sure all of my indices are dense from 0 to N
04:19:20 <kuribas> what do you mean?
04:20:02 <merijn> I have 0 through M with gaps, I want renumber to 0 through N with no gaps
04:20:09 <kuribas> ah right
04:20:22 <lortabac> merijn: since you are going to discard the initial indices anyway, can't you work on a list directly?
04:20:23 <kuribas> I did that before...
04:21:28 <lortabac> anyway, I can't think of an easier way than converting to list and zipping
04:25:05 <kuribas> merijn: if you don't care about the remapping, that would be easiest
04:35:19 <olligobber> merijn, reminds me of my ReLabel class https://github.com/olligobber/DirectProof/blob/master/ReLabel.hs
04:36:39 <asheshambasta> kuribas: yeah; I considered using just a list, but I feel its clearer from the reader's perspective; and perhaps more convenient to do `Unstyled h` instead of `StyledWith h []` ]
04:36:51 <olligobber> not really the same, the easiest way is probably just to get a list of values and zip with [0..]
04:37:08 <merijn> kuribas: Just trying to some sanity check some date easily
04:37:21 <merijn> ugh
04:38:25 <merijn> Apparently I didn't nicely update all the dates in my repo when fixing history issues >.>
04:38:41 <merijn> There's a bunch of time travel >.>
04:56:54 <Xnuk> How can I make this work?: type Const a b = a; type Apply f a = f a; type Foo = Apply (Const Int) String
04:58:35 <Xnuk> Why can't I get * -> * from type `Const Int`?
05:03:41 <tomsmeding> Xnuk: check out the LiberalTypeSynonyms extension
05:06:49 * hackage universum 1.7.1 - Custom prelude used in Serokell  https://hackage.haskell.org/package/universum-1.7.1 (gromak)
05:07:02 <merijn> Xnuk: You can't "partially apply" type synonyms
05:08:22 <tomsmeding> (in standard Haskell)
05:10:49 <Xnuk> Thanks
05:19:53 <p0a> Hello, suppose I have written a program (version 1). Then I decide to change some things. Does a 'cascading effect' ever occur because I've changed the type of something and now I have to change everything `below' it (that is being used by some function, for example?)
05:20:18 <p0a> Or can that be avoided if proper care is taken?
05:20:44 <merijn> p0a: "It Depends"
05:21:08 <merijn> You can limit it a bit, but sometimes things need to change
05:21:14 <merijn> But that's the same in any language
05:22:06 <kuribas> asheshambasta: type Unstyled h = StyledWith h []  :-)
05:22:22 <p0a> merijn: and you limit it how? 
05:22:37 <p0a> I know I'm not asking a concrete question but it's something I've been wondering about
05:22:58 <kuribas> p0a: it's usually logarithmic on the size of the project IMO
05:23:23 <merijn> p0a: You only need to update usage when 1) the type something has changes or 2) you add constructors to a datatype
05:23:38 <kuribas> p0a: like, changing things to the root usually doesn't mean changing the whole program.
05:23:38 <merijn> p0a: But option 2 only affects code actually looking at the constructors
05:24:16 <merijn> p0a: So if all code working on type Foo is in module Bar and the rest of the program just calls functions from module Bar on values of type Foo, then any changes to Foo don't really affect much else
05:24:28 <kuribas> p0a: also, the more you decouple your code, the less "cascading" you have.
05:24:48 <p0a> kuribas: decoupling as in what merijn just said with the module Bar?
05:25:01 <kuribas> p0a: that's one way yes.
05:25:07 <kuribas> p0a: but not just on module level.
05:25:43 <kuribas> keeping dependencies to a minimum, prefering local state to global state, 
05:26:32 <kuribas> extracting functionality which is general.
05:26:46 <kuribas> (for example logging)
05:26:53 <p0a> got it, thank you. It sounds reasonable, I'll just have to get a feeling for it
05:27:20 <merijn> p0a: The only way to learn is "just do"
05:41:26 <p0a> How is [] a type constructor?
05:41:40 <ph88> when i have a list like ['a', 'b', 'c'] and another list with an ordering like [3, 1, 2] is there a function that can give me the first list ordered by the second list? output should be ['c', 'a', 'b']
05:41:41 <p0a> nevemrind, I tried :info []
05:44:44 <kuribas> p0a: it has kind (* -> *)
05:45:49 <kuribas> > map snd $ sortBy fst $ zip [3, 1, 2] ['a', 'b', 'c']
05:45:51 <lambdabot>  error:
05:45:51 <lambdabot>      • Couldn't match type ‘Integer’ with ‘(Integer, Char) -> Ordering’
05:45:52 <lambdabot>        Expected type: (Integer, Char) -> (Integer, Char) -> Ordering
05:46:54 <kuribas> > map snd $ sortOn fst $ zip [3, 1, 2] ['a', 'b', 'c']
05:46:55 <lambdabot>  "bca"
05:47:07 <ph88> thanks kuribas 
05:47:15 <p0a> kuribas: so [] is both a type constructor and a value right?
05:47:31 <kuribas> p0a: the syntax is overloaded, yes
05:47:40 <kuribas> p0a: but unambiguous
05:47:42 <p0a> It's the first time I realize [] is a type constructor :P
05:49:13 <sshine> :k []
05:49:15 <lambdabot> * -> *
05:49:36 <sshine> :t []
05:49:37 <lambdabot> [a]
05:49:51 <sshine> so the [] value has type [a], and the [] type has kind * -> * :)
05:50:21 <p0a> but why do we write f : a -> [a] instead of f : a -> [] a?
05:50:34 <sshine> convenience
05:50:39 <sshine> [] a would be more consistent
05:50:45 <p0a> how is that defined in the language?
05:51:13 <sshine> the [] type constructor has special convenience syntax for allowing you to write [Int] rather than [] Int.
05:51:23 <kuribas> p0a: [a] is builtin syntax
05:51:38 <p0a> okay so it's no-go for the programmer
05:53:19 <kuribas> p0a: you can write "[] a" as well
05:53:19 <sshine> p0a, 
05:53:24 <sshine> oops :) p0a, yeah you can't make up arbitrary syntax here.
05:58:39 <justsomeguy> I want to automate some examples of inspecting types from ghci in the book I'm reading. Is there a function that will let me query the type information of an expression like the ":type" ghci command, but without using the repl, and log it somehow?
05:59:34 <lortabac> justsomeguy: do you know the Type.Reflection module? it should be a good starting point
06:00:27 <lortabac> however it doesn't work with polymorphic types
06:07:13 <justsomeguy> The "typeOf" function seems to do what I want for the simple case. Thanks for letting me know that module exists. (This makes me thing that I should just go through all of base and find out what modules are in there and find out what they do so I know what I can reach for in the future.)
06:07:24 <justsomeguy> s/thing/think/
06:33:06 <Xnuk> :k (->)
06:33:07 <lambdabot> * -> * -> *
06:33:54 <sshine> what does this mean? "Unrecognized field in ProjectAndConfigMonoid: image" when running 'stack build'. it seems that stack.yaml has an 'image' field that even Stack 2.3.3 does not recognize??
06:34:37 <merijn> Well, presumably that there is something wrong with your stack.yaml and it has an unknown field? :)
06:48:52 <merijn> So, I've got a sample size 1 visualisation for Haskell being more productive than C++ python :p
06:50:39 <merijn> I've been doing some code archeology on my own repos to see how things evolved over time and how many commits were happening
06:51:08 <p0a> C++ is great but not fun and python is so bad it's not even fun
06:51:11 <merijn> See if you can spot where I decided to just do "everything" in Haskell: http://files.inconsistent.nl/sloc-time.png :p
06:54:33 <justsomeguy> Yeesh, people on this channel seem to hate python.
06:54:43 <merijn> justsomeguy: PTSD :)
06:54:52 <merijn> Also, yes.
06:58:36 <yushyin> it is not hatred but a healthy aversion
07:00:06 <yushyin> merijn: that's a nice little graph
07:00:21 <maerwald> justsomeguy: I don't
07:00:35 <maerwald> I think python surpasses haskell in some areas and does very clearly so
07:00:54 <merijn> yushyin: I'm kinda disappointed I don't have the date from before that start anymore
07:01:48 <merijn> yushyin: But at some point I squashed a bunch of stuff, so that can't be recovered
07:02:19 * hackage zenacy-html 2.0.2 - A standard compliant HTML parsing library  https://hackage.haskell.org/package/zenacy-html-2.0.2 (mlcfp)
07:02:32 <justsomeguy> I feel like the value proposition of Python is that it's approachable, and has a lot of libraries. For me, the deficiencies as a language (maintainability issues) are counter-balanced by how easy it is to use. Once I'm productive in Haskell, I wonder if I'll be comfortable using it for the same things (talking to AWS, file wrangling, sending http requests).
07:03:12 <maerwald> justsomeguy: that's the point. AWS support in haskell is not first class like in python.
07:05:46 <maerwald> and everyone who uses amazonka in production has likely hit https://github.com/brendanhay/amazonka/issues/546 in production
07:05:53 <maerwald> which has a pretty bad taste to it
07:06:06 <merijn> justsomeguy: It's not just maintainability, but also that a lot of even the very big libraries have incredibly bad documentation making it incredibly frustrating to work with. Those 2 big drops in python SLOC are because of a mix of python performance issues and the libraries just being awful. There's still some bit of python left in the code, because I don't wanna reimplement that one package
07:06:28 <merijn> justsomeguy: But if I could drop that package I'd do so in a heartbeat >.>
07:06:33 <maerwald> justsomeguy: I don't care about the types if the behavior is broken :)
07:06:46 <Wizek> Hello. (How) is it possible to treat `"string literals"` as Data.Text in hs somehow rather than String?
07:06:58 <maerwald> and if your' downstream, you don't control the behavior
07:07:28 <merijn> Wizek: -XOverloadedStrings
07:07:35 <Wizek> oh, and I know that they can be made mpolymorphic
07:07:38 <Wizek> yes, with that
07:07:50 <Wizek> but I wonder if I can make them monomorphically Data.Text
07:08:09 <merijn> Wizek: Why do you want that?
07:08:10 <p0a> use :: ?
07:08:48 <Wizek> because polymorphic errors are worse to decipher than monomorphic type errors
07:09:00 <Wizek> I am thinking it could be simpler
07:09:04 <Wizek> that way
07:09:06 <merijn> Wizek: Then what p0a says, just add a type signature
07:09:25 <merijn> Wizek: GHC doesn't know about Text, so it has no way of magically converting literals to Text
07:10:37 <Wizek> can that be made default somehow? IIRC you can overwrite some other compiler behaviour e.g. what `;`/`>>=`/`bind` does, and I think even more
07:11:01 <Wizek> the extension is something like RedefinableX, lemme look for it
07:11:11 <merijn> Possibly, sounds like a terrible idea, though
07:11:34 <Wizek> why would it be terrible if I know that I don't want any Strings or ByteStrings, only Text?
07:11:37 <Orbstheorem> Wizek: RebindableSyntax?
07:11:48 <Wizek> Orbstheorem: I think that's the one!
07:11:58 <Orbstheorem> Yeah, sounds like a bad idea xD
07:12:03 <merijn> Wizek: Because it will make your code super confusing for anyone else reading it
07:12:36 <Wizek> this is a small text processing tool, not intended for wide consumption
07:12:58 <merijn> "anyone else" includes "you 6 months in the future" :)
07:13:00 <Orbstheorem> Maybe for hacking a WM configuration file x)
07:13:14 <Orbstheorem> But yeah, definitely not something I'd check in ^^
07:13:22 <Wizek> also, I can include the magic incatation {- BEWARE, ALL IS DATA.TEXT -} if that's the price of this feature
07:14:14 <dmwit> I say go for it. Screw these other guys, find out whether it's awesome or a train wreck yourself through experience.
07:14:27 <Wizek> dmwit: That's the spirit!
07:14:41 <merijn> dmwit: I mean, I'm not stopping anyone. Just don't come crying to me after I warn you :)
07:15:05 <Orbstheorem> If nobody's code-reviewing x)
07:15:27 <merijn> pfft, code review and tests, who needs those :p
07:16:39 <kuribas> justsomeguy: "easy to use" if very tricky.  If you mean easy to get started with, then "maybe".
07:17:05 <kuribas> justsomeguy: if you mean, easy to make something maintainable, architecturally sound, without much surprise, then no on all three accounts.
07:17:47 <p0a> kuribas: how about this notion of easy: The professor can talk about tic-tac-toe without mentioning functors? :P
07:18:02 <Orbstheorem> Easy to get started is the power behind _prototyping_ ^^
07:18:38 <merijn> p0a: Easy :)
07:18:41 <kuribas> p0a: Functors aren't that hard.
07:18:46 <Axman6> @let t :: Text -> Text; t = id
07:18:47 <lambdabot>  .L.hs:196:6: error:
07:18:47 <lambdabot>      • Expecting one more argument to ‘Text’
07:18:47 <lambdabot>        Expected a type, but ‘Text’ has kind ‘Symbol -> ErrorMessage’
07:19:00 <merijn> p0a: Just you use Array (Int, Int) and loop over game state via recursing
07:19:02 <kuribas> p0a: and programming in other systems/language, also involves a lot of side-knowledge.
07:19:16 <Axman6> @let t :: Data.Text.Text -> Data.Text.Text; t = id
07:19:18 <lambdabot>  .L.hs:196:6: error:
07:19:18 <lambdabot>      Not in scope: type constructor or class ‘Data.Text.Text’
07:19:18 <lambdabot>      Perhaps you meant ‘Data.Set.Set’ (imported from Data.Set)
07:19:20 <p0a> merijn: I was saying something in jest, but of course you had to go all technical on me :P
07:19:36 <maerwald> kuribas: maintainable is a fallacy... you *don't* want to write maintainable software, because that usually means you change stuff at random, which always ends up in a mess, even if it's an ordered mess :)
07:19:47 <maerwald> Never tell anyone you can write maintainable software in haskell
07:19:51 <maerwald> no one should know.
07:20:08 <kuribas> maerwald: we have guidelines you know
07:20:16 <maerwald> doesn't matter
07:20:36 <kuribas> I'd say our code is always better after refactoring
07:20:38 <maerwald> once you've added enough ideas to a codebase, your architecture is ad absurdum
07:20:43 <merijn> p0a: People just exaggerate how hard things are :p I've been teaching my girlfriend Haskell as her first language and it's fine :)
07:20:56 <maerwald> kuribas: refactoring is also a fallacy
07:21:05 <Orbstheorem> maerwald: I think one of the streghts of Haskell over other languages is how easy it is to refactor code.
07:21:12 <justsomeguy> Maintainability to me means that components are easy to replace, which means they must be easy to understand in isolation.
07:21:17 <merijn> kuribas: Man, why are you arguing with maerwald, his opinions are like immovable objects
07:21:31 <maerwald> Because to do things proper, you sometimes have to *redo* the thing. Refactoring always assumes a current state
07:21:39 <kuribas> merijn: pinned objects?  :-O
07:21:52 <Orbstheorem> merijn: Fixed points in the universe? :D
07:21:54 <merijn> kuribas: Pinned objects get let go off at some point :p
07:21:58 <maerwald> and often times you cannot see what you would have done if that current state didn'd exist
07:22:03 <Orbstheorem> (ref to Dr. who)
07:22:28 <maerwald> so refactoring gives you the feeling of control, while you've already lost it
07:22:47 <kuribas> maerwald: that's the right feeling :) letting go of control :)
07:22:54 <Orbstheorem> I'd argue __tests__ give you the feeling of control.
07:22:55 <maerwald> you never go back to your base assumptions and question them
07:23:02 <p0a> in `data F x = F x' the first is the type constructor and the second is the data constructor
07:23:07 <Wizek> Orbstheorem: RebindableSyntax did it! `{-# LANGUAGE RebindableSyntax, OverloadedStrings #-}` `fromString :: String -> T.Text` `fromString = T.pack`
07:23:12 <Wizek> cool :) 
07:23:17 <kuribas> maerwald: you go with the flow, you don't inpose your will.
07:23:19 <p0a> But what is `x'? In the left, I'd say a type, and in the right, the variable holding a value?
07:23:30 <maerwald> so refacotring is just the continuous fight againts technical debt, which you can never win in the first place
07:23:31 <Orbstheorem> Wizek: Good, but I never want to code such code xD
07:23:33 <merijn> p0a: It's just a place holder
07:23:40 <kuribas> p0a: a type variable
07:23:59 <Wizek> Orbstheorem: Are you saying you love String and prefer it over Text and ByteString?! *gasp*
07:24:02 <merijn> p0a: I've always thought it was a mistake not to allow GADTSyntax, it's much more predictable for people
07:24:13 <merijn> p0a: Let's take "data Maybe a = Nothing | Just a"
07:24:47 <merijn> p0a: If we rewrote that using GADT syntax you'd get: "data Maybe a where { Nothing :: Maybe a; Just :: a -> Maybe a }"
07:24:48 <Orbstheorem> <Strings & Text> I like to use strings for as long as I can, and Text when Text is due.
07:24:52 <p0a> merijn: ah, go tit
07:24:55 <p0a> merijn: thank you 
07:25:33 <p0a> there's also this article https://typeclasses.com/ghc/gadt-syntax
07:25:49 <merijn> p0a: So the types (variable or not) after a constructor are just specifying the type of that position (there's no real point in naming them, since you pattern match anyway)
07:25:57 <Orbstheorem> merijn: I kind of remember you lose something when you go full GADTs vs Associated types? Does GADTsyntax imply GADTs?
07:26:05 <merijn> Orbstheorem: No
07:26:17 <merijn> GADTSyntax just lets you write non-GADT datatypes using GADT syntax
07:26:27 <Orbstheorem> Right
07:26:50 <merijn> Orbstheorem: I'm not really sure what "lose something" means, there
07:27:04 <merijn> I don't see much of a link between type families and GADTs, tbh
07:27:29 <Orbstheorem> I'm trying to remember the reason why I reverted an injective GADT type to an associated data type.
07:29:10 <Orbstheorem> It was something along there are properties you can't no longer assume with a GADT, I think I discussed it here.
07:29:22 <Orbstheorem> Meh...
07:31:29 <ski> p0a : .. i guess you've not seen BNF ?
07:33:20 <p0a> ski: no I have not
07:34:12 <ski> ok. the traditional `data' syntax is intended to resemble BNF (a bit)
07:34:21 <ph88> i have a bit of problem thinking of a type class hierarchy could someone have a look at what i have so far ?  https://bpa.st/P5DA 
07:36:25 <dolio> Why is the second thing a class?
07:37:00 <ph88> not for any particular reason, maybe it shouldnt be
07:37:43 <dolio> Well, definitely functions being part of a class should not be the default choice, without reasons.
07:37:58 <ski> p0a : `DatatypeContexts' is deprecated
07:38:18 <sshine> if I bump a dependency constraint, what version bump is expected? at least the same level of version bump? e.g. bumping these <1.1 to these <1.2 (latest is 1.1.1.1) would imply the version bump 0.6.0.1 -> 0.7.0.0?
07:38:38 <sshine> or is bumping the upper bound upwards only worthy of 0.6.0.1 -> 0.6.1.0?
07:39:34 <sshine> I guess increasing the upper bound only adds search space to the resolver, it doesn't render previous resolutions invalid; although I assume it may break resolvers under some circumstances...
07:39:35 <ski> p0a : did you mean `getStart,getStop :: a -> UTCTime' ?
07:40:09 <dolio> Changing the version range on a dependency doesn't require any change of you package's version unless it affects your package's API in some way.
07:41:07 <ski> p0a : maybe, you want `instance Event a => Event (Block a) where getStart (Block a _ _) = getStart a; getStop (Block a _ _) = getStop a' ?
07:41:16 <dolio> ski: Wrong person. :)
07:41:27 <ski> oh ..
07:41:33 <ski> sorry, p0a :/
07:41:40 <ski> ph88 ^
07:43:17 <dolio> Yeah, that seems like what may be wanted.
07:43:27 <sshine> here it appears that 0.6 was pushed to 0.6.0.1 because of an upper bound increase: https://github.com/bgamari/monoidal-containers/commit/450acec61b2a7f75b6290e69fa7d88cb1e14854d -- what's the justification?
07:44:24 <sshine> dolio, well, if you release a new version that people can then depend on, I suppose it is necessary to increase the version number so that they can refer to the right node in the dependency graph?
07:44:40 <dolio> I'm not sure. That commit only has changelog/cabal changes, but there might have been other commits that changed other things.
07:44:57 <sshine> dolio, also, if you bump your dependency on something that has a minor/major API change, you'll have to reason if that minor/major API change affects your package.
07:45:08 <bgamari> sshine, https://github.com/bgamari/monoidal-containers/commit/d1117858d7f0bc3c4061ba4a699d7dc875c84231
07:45:11 <dolio> If there are other changes necessary, some version has to be increased.
07:45:22 <sshine> dolio, yes there was. https://github.com/bgamari/monoidal-containers/commit/d1117858d7f0bc3c4061ba4a699d7dc875c84231 contains the actual change. :)
07:45:24 <dolio> Because you can't release different code under the same version.
07:45:26 <sshine> dolio, it's just one bump.
07:45:28 <bgamari> sshine, there were also source changes in that release
07:45:34 <sshine> bgamari, oh ok!
07:46:10 <dolio> sshine: What I meant was that there is no e.g. 'major' version bump required by supporting a wider version range.
07:46:11 <sshine> well my point is, if you don't know exactly what changed in an API and you just see a version bump, aren't you complied to make a similar bump in your package or make an assessment that it's unnecessary?
07:46:19 <sshine> dolio, ok thanks :) makes sense.
07:46:46 <dolio> That is why hackage allows modifying the bounds if a wider version range just works with the same code.
07:47:05 <sshine> ok. :)
07:49:09 <dolio> So, really, you don't even need to upload/release a new version at all to support wider ranges, unless doing so requires you to change some code.
07:49:40 <sshine> dolio, good to know! this seriously reduces the overhead of propagating changes in the dependency graph.
07:49:58 <p0a> can I have several executables built in a stack projecT?
07:50:03 <sshine> p0a, yes.
07:51:12 <p0a> I see, I have to modify the *.cabal file to include more of them. Thank you 
07:51:22 <sshine> I started a project yesterday that involves a REST client and server built as separate executables with the same library.
08:13:34 <merijn> sshine: My process is that I have an RSS feed for when my dependency get newer versions, then I read the changelog and if nothing dramatic changed and my tests pass I simply make a revision to loosen the bounds
08:17:49 * hackage supernova 0.0.1 - Apache Pulsar client for Haskell  https://hackage.haskell.org/package/supernova-0.0.1 (gvolpe)
09:28:46 <sooch> Hoping someone can help out a noob. I have a data record lets say: TeamStats {..}. I want to encode whether this team is Home or Away. I also have another type Game {home :: TeamStats, away :: TeamStats ..} whats the best way to get home to acknowledge or typecheck that TeamStats is always of Home type?
09:31:03 <dolio> It seems like TeamStats is not inherently home or away. The information is encoded by Game.
09:33:14 <sooch> well inside TeamStats is a field for Maybe TeamType. Certain cases don't require a type. My original idea was to have some Phantom Type at construction that would encode whether its Home or Away
09:33:37 <merijn> sooch: Let's rewind. Why?
09:34:12 <dolio> Why does the TeamStats have an optional TeamType field?
09:34:56 <dolio> It doesn't seem like a property of the team in itself, but of a larger context.
09:35:10 <sooch> Sorry ignore that it shouldn't be a Maybe at all.
09:35:58 <sooch> It will always be created in a context that requires the team to have an Away or Home type.
09:36:43 <dolio> Why is it stored in the TeamStats and not in the representation of the context, like Game?
09:38:05 <sooch> I would like it to be in the Game context, but I'm not sure how to do that. 
09:39:25 <dolio> Having game have `home :: TeamStats` and `away :: TeamStats` as fields already has the information. The TeamType is unnecessary.
09:40:01 <dolio> The stats for the home team are the ones in the home field.
09:40:44 <sooch> right but I want to enforce that the home team is actually the home team and vice versa
09:41:07 <sooch> I guess it would work as: data HomeTeam = Home TeamStats...
09:41:26 <dolio> I don't understand why these need to be different types.
09:41:28 <merijn> sooch: That seems like a lot of work for no real reason
09:41:45 <dolio> The home team stats are by definition the ones in the home field. They don't need a different type.
09:42:27 <sooch> You are raising a good point lol
09:42:49 * hackage lingo 0.4.0.0 - File extension based programming language detection  https://hackage.haskell.org/package/lingo-0.4.0.0 (rewinfrey)
09:43:04 <dolio> The only reason there can be a mismatch is because of redundantly stored information.
09:43:43 <maerwald> does stack completely ignore bounds in foo.cabal files? What does it do if a cabal file pins a dependency and the resolver has a different one?
09:44:28 <sooch> Right. You make a good point, I was just building out my types for this toy project. And I tried to be clever for my own good.
09:47:27 <merijn> maerwald: Sounds like time for...SCIENCE!
09:47:56 <merijn> maerwald: I suspect conflicting bounds would just lead to build failure, but I haven't tried
09:48:09 <sm[m]> maerwald: it uses stackage versions where it can, and pulls from hackage when it must
09:48:41 <maerwald> sm[m]: so it may pull two different versions of the same package into one resolution?
09:49:28 <sm[m]> no, of course not
09:49:44 <sm[m]> stack build --dry-run will show what it's doing
09:51:00 <dolio> sooch: 'Don't try to be too clever' is an important lesson to learn. :)
09:51:39 <sm[m]> http://wiki.c2.com/?DoTheSimplestThingThatCouldPossiblyWork
09:52:27 <hololeap> could it really be this simple? https://dpaste.com/8RB2GB57W
09:53:23 <merijn> hololeap: What exactly would the goal of such a class be?
09:53:46 <hololeap> to do it all mtl style
09:53:58 <hololeap> all of it
09:54:03 <merijn> That's not really a goal, tbh
09:54:11 <merijn> That's a description of what you're doing
09:54:40 <p0a> so my stack project has some resources (in particular, my app/Main.hs wants to open "foo.txt"). Where should foo.txt be placed?
09:54:59 <p0a> do I make a direcory called `resources' for example?
09:55:31 <hololeap> merijn: isn't that question analogous to "what's the goal of MonadIO"
09:55:42 <merijn> p0a: https://cabal.readthedocs.io/en/latest/cabal-package.html#accessing-data-files-from-package-code
09:59:45 <p0a> merijn: ok so I need to configure the cabal file to have a data-files record where I explain what my resource directory is, and then I need to call getDataFileName from my program? 
10:00:19 * hackage data-validation 0.1.0.0 - A library for creating type safe validations.  https://hackage.haskell.org/package/data-validation-0.1.0.0 (DevinLyons)
10:01:51 <sm[m]> yes, or you use file-embed
10:02:18 * hackage shake-dhall 0.1.1.3 - Dhall dependencies  https://hackage.haskell.org/package/shake-dhall-0.1.1.3 (vmchale)
10:06:56 <p0a> `[the cabal file] was modified manually. Ignoring [package.yaml] in favor of the cabal file.'
10:07:10 <p0a> Is there another way to add these records to the cabal file using stack? Inside package.yaml?
10:09:45 <hololeap> merijn: but really, it's just to have a level of convenience when using a monad transformer stack with STM at the base
10:10:44 <hololeap> but it looks like somebody beat me to it
10:10:46 <hololeap> https://hackage.haskell.org/package/concurrency-1.11.0.0/docs/Control-Monad-STM-Class.html#t:MonadSTM
10:11:10 <hololeap> although they don't have an ExceptT instance, which is lame
10:13:02 <hololeap> what was the reason for frowning at orphaned instances again?
10:13:59 <hololeap> possibility of a clash if you import two of the same orphaned instance?
10:15:18 <p0a> looks like the question I am asking is in general an annoying question 
10:16:58 <p0a> For example I'm reading this and only half-understanding it: https://github.com/commercialhaskell/stack/issues/548#issuecomment-121320827
10:17:26 <p0a> in particular I am not sure how to replace Cabal with a `real package installer'. Like `apt'?
10:17:54 <p0a> This is not important for me so if the answer is too lengthy don't bother :P Just curious 
10:27:01 <hololeap> p0a, i don't really see what this has to do with stack. once your executable is compiled, it just needs to know where foo.txt is
10:33:56 <justsomeguy> p0a: The "extra-source-files", "extra-doc-files", and "data-files" sections of package.yaml seem worth experimenting with. (The last example here uses "extra-source-files".)
10:34:04 <justsomeguy> https://github.com/sol/hpack/blob/master/README.md#examples
10:34:51 <justsomeguy> I'm not really sure why stack needs that, either, though.
10:36:56 <hololeap> more of a git/packaging issue really
10:36:59 <justsomeguy> Maybe it will only include files for distribution in the project directory if they are explicitly listed in the cabal/yaml files?
10:41:50 <p0a> yeah I guess I see the difference between distributing a binary + resources versus a stack project (with source)
10:41:53 <p0a> I sort of get it now
10:42:19 <justsomeguy> What if your resource is just a text file, though?
10:44:06 * justsomeguy kind of wishes he hadn't first learned stack, but started with cabal instead, since it feels like he's just learning the idiosyncrasies of cabal by proxy.
10:46:20 <justsomeguy> Hmm, "data-files" looks appropriate for text files.
10:46:56 <dolio> Yeah, there are sections for just moving files as part of a build.
10:52:47 <sm[m]> p0a: the files are configured in your project's .cabal file. If you use a package.yaml file instead, as stack users often do, you must configure them there instead, and the .cabal file will be updated automatically. The limitation of this approach is that the files are only installed in the right place if someone installs your software with cabal or stack, or if someone makes a OS-specific system package for your software. The
10:52:47 <sm[m]> file-embed approach avoids those issues since the files are part of your executable, and is sometimes more useful
11:00:13 <p0a> sm[m]: for binary distributions what I have to do is use a package manager to package my binary with my resources
11:00:16 <p0a> I /just/ realized this. 
11:00:22 * p0a learns things every day
11:00:53 <sm[m]> I ship binaries with data files embedded, so the package manager is optional
11:02:30 <justsomeguy> Packaging is too complex.
11:04:43 <hololeap> what? how is it too complex?
11:04:56 <hololeap> it's a glorified zip file
11:06:38 <hololeap> i think that if you have a large amount of assets, embedding them in the binary seems like a clunky option, but i could be wrong since i've never tried it
11:06:55 <justsomeguy> Yeah, I shouldn't have said that in an unqualified way. It's too complex for me. I enjoy doing things on Linux, and have to interact with four or five different packaging systems with their own edge cases and mental models.
11:07:03 <davean> hololeap: It varies.
11:07:19 <davean> hololeap: for a large amount of assests it sure is ruinous. For a moderate amount though it works well.
11:07:28 <sm[m]> it may be clunky, but it sidesteps a whole lot of installation snafus and support toil
11:07:49 <sm[m]> hence "sometimes more useful"
11:08:32 <davean> The problem is then you can't access those seperately so often you'd want the cost of dealing with them anyway - man pages for example. Then you might as well not.
11:08:52 <hololeap> what's wrong with the filesystem scheme of "packagename/bin" "packagename/assets", etc
11:09:02 <davean> Its "easier" not even "as good as", but if your main goal is avoiding support and you ahve few assets? Do it.
11:09:21 <sm[m]> I installed some "enterprise" software recently (Bitdefender Security for Mail Server) and it used the same approach; the trial is one giant shell script that self unpacks to a large file tree
11:09:37 <davean> sm[m]: thats different
11:10:00 <hololeap> it makes it easy to distribute binaries that aren't likely to be installed as root (and it's easy to make it so they are if you put them in /opt)
11:10:03 <davean> Thats an old thing thats usually actually just a far with a shell header.
11:10:18 <sm[m]> if you need actual files on the filesystem, you can still embed but write them out as temporary files at runtime
11:10:21 <davean> it leaves everything spread out still
11:14:07 <davean> self-extracting shell tars ... is? ... was? the distribution standard of choice outside packaging systems. 
11:15:39 <mniip> curling an unknown shell script and feeding it directly into the interpreter always made me feel iffy
11:15:53 <sm[m]> yes, it felt horribly insecure by modern standards
11:16:08 <sm[m]> I didn't curl it, downloaded it from their official site, but even so
11:16:08 <mniip> I mean cloning a random git repo and running configure is no different
11:16:58 * sm[m] thinks.. actually I did curl it. Just had a look at it before running it.
11:17:13 <p0a> mniip: yeah it's annoying since the configure scripts are always so big, like 1000 lines
11:17:28 <p0a> mniip: isn't the solution to that to use cmake or such?
11:17:32 <mniip> configure scripts are usually generated as well
11:17:47 <mniip> the iffiness is in the fact that I'm running random code off a website
11:17:53 <mniip> I can't describe it well
11:18:58 * justsomeguy at least tries to verify the public key for a signed checksum and use that to check the files hash.
11:19:29 <justsomeguy> ...but usually I can't, since the public key isn't distributed in a sane way.
11:19:35 <justsomeguy> depends
11:20:43 <sm[m]> usually it's there on the same page you downloaded from, right
11:21:00 <monochrom> I can describe well mniip's sentiment.
11:21:12 <monochrom> In the old days it was worse.
11:21:18 <monochrom> It was always snowing.
11:21:44 <sm[m]> better! we had better snow then!
11:21:49 <monochrom> And people emailed each other bloody Windows exe binaries and expected the receivers to run them naked.
11:21:57 <mniip> the old days were better cause I wasn't there
11:22:23 <hololeap> i miss having groovy music play when i installed a totally-not-sketchy program
11:22:35 <wavemode> that's still a thing
11:22:45 <mniip> monochrom, do you like, undress before your computer?
11:22:46 <monochrom> Every Christmas, a "e greet card" meant a Windows exe in email.
11:23:02 <davean> wavemode: Yes but now everyone is naked in their own homes and its normal because no one goes out anymore.
11:23:07 <hololeap> things that should never be a .exe: 1) ...
11:23:18 <davean> wavemode: back then people were in offices which amde running things naked much weirder
11:23:23 <monochrom> You were supposed to run it and get merely a picture with a bit of snow animation. (See? It was always snowing.)
11:23:44 <p0a> davean: what people don't realize is that under our naked bodies we're actually wearing clothes
11:23:47 <monochrom> Compared to that, a URL to Hallmark's Flash page was infinitely better.
11:23:50 <hololeap> people found things eerie if there wasn't a snow overlay on every video
11:24:05 <hololeap> "it just doesn't feel real, somehow"
11:24:07 <monochrom> Oh and here is the really sickening social expectation part.
11:24:08 <davean> p0a: I'm a donute, if I eat the clothes  they surround me from the inside.
11:24:24 <p0a> lol
11:24:35 <monochrom> If you refuse to run the exe that your friend sent you, your friend freaked out like "what do you mean you don't trust me???!!!"
11:24:55 <monochrom> Like, dude, I trust your honesty, I just don't trust your computer literacy.
11:25:05 <davean> monochrom: Lets be honest, my friends don't expect me to trust them
11:25:58 <monochrom> Try to understand how Norton Anti-virus and McAfee Anti-virus etc grew and boomed in that context, in that by-gone era.
11:26:46 <mniip> hmm I have a GHC RTS question
11:26:59 <monochrom> Anyway, you kids merely receive a shell bloody script? You have it easy. At least it is only 100 lines and you can audit it.
11:27:03 <wavemode> antivirus software is itself the worst malware I've ever had
11:27:35 <monochrom> In my days it was 100KB machine, try auditing that.
11:27:41 <monochrom> err, 100KB machine code
11:28:02 <mniip> if a closure is an array of pointers and an array of non-pointers, does that mean that closures are different sizes? cause I don't think there's an indirection?
11:28:09 <davean> monochrom: I can read all of it, that seems easier
11:28:11 <mniip> how does updating a closure work then...
11:28:17 <maerwald> wavemode: I've had an actual virus once in my lifetime and the first thing it did was destroying the antivirus executable
11:28:36 <p0a> mniip: why is configure.sh worse than running the binary? or do you mean that you want to just build the binary and configure.sh gets in the way of 'security'?
11:28:50 <maerwald> to me, that was good engineering, so I wasn't mad
11:29:03 <mniip> p0a, no I was saying that the sentiment is finicky to define because configure is fine but it's essentialy the same thing
11:29:14 <maerwald> at least *something* works, even if it's just a virus
11:29:18 <p0a> mniip: right, thanks
11:29:43 <davean> maerwald: Uh, your virus didn't rewrite the BIOS? I liked early 90s viruses. They directly infected the firmware
11:29:56 * sm[m] is trying to set up antivirus scanning in the mail server. Block it before they click
11:30:12 <mniip> last time I had a virus it came with my laptop when I bought it :(
11:30:31 <p0a> sm[m]: isn't phishing a worse threat anyway? :)
11:30:34 <justsomeguy> A windows laptop, huh?
11:30:39 <maerwald> haha 
11:30:48 <mniip> they don't sell blank versions of the more expensive laptops
11:31:06 <sm[m]> phishing/trojan mails is what we're getting
11:33:01 <monochrom> mniip: I think I don't understand about a closure being an array of pointers and an array of non-pointers.
11:33:35 <monochrom> Or maybe I understand, just not thinking straight.
11:33:43 <mniip> https://gitlab.haskell.org/ghc/ghc/-/wikis/commentary/rts/storage/heap-objects#pointers-first-layout
11:34:01 <monochrom> OK, what needs updating?
11:34:33 <mniip> updating as in overwriting a thunk with a constructor when we're done evaluating
11:35:23 <hololeap> mniip: coming pre-installed with ubuntu == blank version
11:35:32 <monochrom> OK, the new value is written over the closure. It's vanilla overwriting.
11:35:37 <mniip> hololeap, that's often not an option either
11:35:46 <mniip> monochrom, what if the new closure is larger
11:35:58 <monochrom> wasted space, that's all
11:35:58 <hololeap> the dell xps series had it at one point, at least, not sure about now
11:36:10 <dolio> mniip: I think updates write an indirection that is eventually removed by the garbage collector.
11:36:18 <monochrom> Come next GC round, the wasted space will be reusable again.
11:36:20 <mniip> ah huh
11:36:24 <mniip> I see
11:36:54 <monochrom> So yes fragmentation until next GC round.
11:37:31 <monochrom> Err I misread, you said the new closure is larger, I misread "old".
11:37:38 <monochrom> I think it doesn't happen.
11:37:42 <mniip> it can
11:37:46 <mniip> but dolio answered that
11:37:47 <monochrom> sorry, it happens all the time.
11:37:54 <monochrom> Yeah, that.
11:38:29 <dolio> You may go through many update frames, even, and if you overwrote all of them with data, you would be duplicating the data.
11:39:13 <mniip> writing an implementation of a functional language and I totally forgot GCs are a thing
11:39:21 <dolio> So the indirections also allow the reference paths to be compressed.
11:39:32 <monochrom> jhc certainly forgot GCs are a thing. :)
11:39:47 <dolio> Well, it had a plan (that didn't work) at least. :)
11:40:59 <monochrom> mniip: Have you known of https://github.com/takenobu-hs/haskell-ghc-illustrated ?
11:41:04 <davean> I haven't thoguht about jhc in ages - I forget what its plan was
11:41:11 <mniip> yes
11:41:39 <monochrom> "thunk and update" has the story.
11:41:56 <mniip> ah huh
11:42:00 <monochrom> :)
11:42:04 <mniip> that pdf contains endless knowledge... I always keep finding more
11:42:27 <monochrom> another Zeno paradox :)
11:43:54 <hololeap> what
11:44:30 <monochrom> If you got into my mind, you would overhear: "I wanted to write a tutorial on a GHC RTS model. Then I found https://github.com/takenobu-hs/haskell-ghc-illustrated on haskell-cafe"
11:44:47 <hololeap> that's awesome
11:46:05 <monochrom> @quote monochrom downloaded
11:46:05 <lambdabot> monochrom says: I was trying to design a sensible language... then I downloaded ghc.
11:46:16 <dolio> davean: It was trying to have everything attributed to regions, and infer all the regions.
11:46:33 <hololeap> that's the kind of talk you don't see very often, describing the basics in detail instead of some crazy new thing
11:46:35 <dolio> Then you free when you leave a region.
11:47:33 <davean> dolio: oh right that thing - I'd kinda forgotten about it because it doesn't jib with laziness for me
11:47:35 <dolio> But my understanding is that it's basically impossible to do good region inference, and most stuff just ends up being live forever.
11:47:53 <davean> and laziness is how you get good Haskell programs
11:48:25 <dolio> Yeah, laziness may have been a contributing factor.
11:48:27 <sm[m]> @remember dmwit I say go for it. Screw these other guys, find out whether it's awesome or a train wreck yourself through experience.
11:48:27 <lambdabot> Good to know.
11:48:45 <monochrom> Yeah you pessimize very quickly and 90% of your objects are in the "need traditional GC" pleb region.
11:49:25 <hololeap> @quote dmwit screw
11:49:25 <lambdabot> dmwit says: I say go for it. Screw these other guys, find out whether it's awesome or a train wreck yourself through experience.
11:49:35 <hololeap> @quote dmwit "train wreck"
11:49:35 <lambdabot> No quotes match. My pet ferret can type better than you!
11:50:05 <monochrom> The code optimization community (and even some static analysis people) once tried pretty hard on "escape analysis" in the Java context.  Didn't go very far AFAIK.
11:50:50 <dolio> Well, I think in Java it's pretty good. But it was a ton of work.
11:51:04 <monochrom> It would be close to what jhc dreamed of. There are certain mallocs you know won't live beyond the function's lifetime so you could/should just put it on call stack.
11:51:11 <davean> Its just not as good as people think it'll be, doesn't mean it isn't good.
11:51:24 <monochrom> Ah OK.
11:51:30 <dolio> And it's doing it with runtime information, probably.
11:51:47 <monochrom> Well yeah a lazy language is going to ruin that quite a bit. Lifetimes are a mess here.
11:52:04 <davean> monochrom: right.
11:52:09 <monochrom> The whole reason I had trouble learning Rust.
11:52:13 <davean> Laziness gives us composability and efficiency
11:52:24 <davean> huge loss to try to do regions.
11:52:41 <monochrom> I made the mistake of "let me learn Rust by implementing cons lists and binary trees"...
11:54:43 <monochrom> Both lifetimes and ownerships escape left right and centre. My exercise degenerated to just using Box and defeat the point of Rust.
11:55:42 <dolio> Yeah, I briefly started to learn Rust a while back and immediately came to the conclusion that trying to learn it by doing what I'd normally do in Haskell wasn't going to be worth while.
11:55:43 <mniip> monochrom, you should've heard of my ICFPC adventures
11:56:04 <mniip> the task was to implement a bug ridden pooly specified version of half of GHC
11:56:06 <mniip> so I used GHC
11:56:40 <dolio> Because it's just much worse for doing anything Haskell-like.
11:57:10 <dolio> So you need something to work on that is much different than what I normally do. :)
12:01:34 <merijn> Rust is great if you want something with ADTs, but can't afford a GC
12:01:52 <hololeap> it makes sense that the higher-level the language, the more it would depend on "limitless" resources
12:01:53 <merijn> Fortunately, I can almost always afford a GC, so Rust is useless to me :p
12:03:28 <mniip> hololeap, and here I am contemplating dedicating 2 bits of space to the GC because that's a significant amount of memory for my purposes
12:04:11 <hololeap> i'm not saying that certain subsets of the terrain wouldn't be resource efficient
12:04:22 <hololeap> or need to be
12:04:41 <maerwald> merijn: it's nice if you want to be able to reason about performance in general... like... at all :)
12:05:05 <hololeap> but "high-level language" means closer to the language of thought and intellect, and farther from the bare-metal
12:05:24 <merijn> hololeap: Disagree
12:05:27 <maerwald> well, I don't know... rust seems to make a great effort to acommodate both
12:05:38 <mniip> hololeap, I mean, kinds are calling conventions
12:05:48 <merijn> hololeap: The entire assumed continuum from "close to hardware" and "high and abstract" is bogus
12:05:54 <merijn> hololeap: They are two orthogonal axis
12:06:01 <davean> maerwald: Hum, you think one can't reason about Haskell performance?
12:06:03 <mniip> merijn, high corelation to be fair
12:06:13 <merijn> mniip: Sure, but mostly due to historical accident
12:06:16 <maerwald> davean: most can't and I'm not too good at it either
12:06:27 <merijn> mniip: Actually, no, not even high correlation
12:06:38 <merijn> mniip: Like, name a language that's close to the hardware
12:06:47 <maerwald> davean: it's obvious... the more the compiler does for you... the harder it's to understand what it actually does for you
12:06:49 <mniip> assembly
12:07:00 <davean> mniip: yah but GHC does almost nothing for us 
12:07:02 <davean> er, maerwald 
12:07:03 <merijn> mniip: ok, fine, I'll give you that one :p
12:07:12 <davean> maerwald: The translation from Haskell to assembly is pretty straight forward
12:07:15 <mniip> I mean modern assemblers have macros so you have a point there
12:07:30 <maerwald> davean: err
12:07:31 <hololeap> davean: a lot of 'm' names in here, to be fair :)
12:07:31 <merijn> mniip: But everyone who's claiming C and C++ are close to the hardware deserves to be swatted on the nose with a newspaper
12:07:36 <mniip> davean, it's more of a П shape
12:08:02 <maerwald> davean: I mean reasoning about an actual program and its laziness properties... good luck finding that in the assembly
12:08:13 <davean> maerwald: GHC does almost nothing code level for us, it basicly only searches and replaced based on types.
12:08:16 <mniip> you make a large turn when desugaring, and then another large turn in a different direction when stg2cmm
12:08:31 <maerwald> davean: I don't think we're talking about the same thing
12:08:32 <merijn> hololeap: Like, I agree that C and C++ are classified as "low level" (as opposite of "high level" and "abstract"), but they're not really close to the hardware and everyone who tells you otherwise has lived under a rock for 2 decades :)
12:08:45 <davean> maerwald: But you can - its just an atomic bit in a closure.
12:08:55 <davean> and laziness has really easy rules - just read Okasaki
12:09:00 <maerwald> davean: no
12:09:04 <maerwald> it isn't easy
12:09:07 <hololeap> maerwald: exactly, there is a large amount of mind-level reasoning that can be brought down 1:1 to hardware through maths, but not all of it, in my estimation. that could change as the body of knowledge and educations progress
12:09:15 <wavemode> tbh, when the term "high level" language was coined, it was used to refer to C
12:09:29 <merijn> wavemode: It was a misnomer even then
12:09:35 <monochrom> Ahem, easy translation to assembly doesn't help you if the assembly simply goes "malloc" all day and "oh, call GC if malloc fails" all day.
12:09:44 <merijn> wavemode: ALGOL-68 predates C and is much higher level than C
12:09:49 <mniip> tbh, I've programmed in languages with structs or local variables for an extensive time, and C felt very high level
12:09:55 <davean> monochrom: eh, we know the rate stuff allocates at.
12:10:09 <mniip> without*
12:10:19 * [exa] makes a wish for a macroassembler with typeclasses
12:10:20 <hololeap> merijn: where would you consider pure math to be on this x,y axis if we pretended it was a programming language?
12:10:35 <wavemode> well the key point isn't what predates what. the key point is that it was architecture-independent, as opposed to assembly languages which were architecture specific
12:10:40 <merijn> hololeap: math is way too ill-specified to ever be a language :)
12:10:56 <mniip> <insert proof assistant name> would like to talk
12:10:59 <merijn> wavemode: So were pascal, fortran, and algol :p
12:11:14 <wavemode> right, and all those were classified as high level as well
12:11:18 <mniip> algol was way ahead of its time
12:11:26 <mniip> why did we downgrade to C
12:11:30 <merijn> mniip: As if any math paper is as consistent in notation as theorem provers :p
12:11:36 <davean> maerwald: I'd say Haskell kinda lacks a type system for its compilation - if I want to make sure everything is the way I intend in assembly I ahve to check it myself - but if I check my work I know exactly what the code will be
12:11:42 <merijn> mniip: Did you ever read the "Go vs Brand X language" blogpost?
12:11:44 <monochrom> You know what, asm is not that close to hardware either.  Closer than C is, sure.
12:11:46 <[exa]> mniip: better operating system behind
12:11:53 <mniip> theorem provers have dynamic locally redefinable notations
12:11:56 <mniip> just like math papers
12:12:01 <[exa]> monochrom: man what's close enough then? :D
12:12:09 <davean> monochrom: varies by the microarch
12:12:15 <monochrom> Just recall why people freak out about "memory barrier", why it is even a thing.
12:12:18 <davean> [exa]: microcode
12:12:28 <maerwald> davean: I can only tell you about my experince with a real life codebase that had a memory leak for 3+ years and many smart haskellers couldn't find it. A consultant was about to migrate the entire architecture to something else
12:12:29 <monochrom> Yeah, microcode at the very least.
12:12:58 <[exa]> do you have architectures where microcode programming is possible?
12:13:00 <davean> monochrom: I'd say auditing Haskell for performance is hard because theres no assistances so you have to read it all.
12:13:02 <davean> er, maerwald 
12:13:04 <monochrom> Right? Intel is a CISC fantasy sitting on a RISC reality
12:13:07 <davean> Damn I keep being off a line
12:13:35 <zugz_> If I put a package which requires a C library as a build-depends conditioned on a flag which defaults to True, the cabal backtracker never tries setting the flag to False if the C library doesn't exist. Is there a workaround, i.e. a way (without going the full autoconf route) to have a feature which depends on a package using a C library enabled iff the library is already installed at compile-time?
12:13:38 <maerwald> until a guy who knew a LOT about GHC found it
12:13:47 <davean> maerwald: There aren't affordances for it, but each case is easy. Doing performance from the start is easy - doing it after is hard. BUt thats always how it is
12:13:54 <monochrom> Yeah I agree that auditing Haskell is hard.
12:14:02 <maerwald> davean: no, it depends on the language
12:14:03 <davean> you can't optimize something after you've decided on its form
12:14:20 <davean> performance comes from from
12:14:27 <merijn> zugz_: Don't make packages like that
12:14:47 <davean> we can use something like RULES to change out the form behind your back
12:14:51 <davean> but only in tiny cases
12:14:56 <davean> which really are uninteresting
12:15:03 <hololeap> merijn: i would say that C and C++ were designed by those who were thinking in terms of hardware, and thus at least _feel_ low-level
12:15:10 <davean> since the code performance is decided by what you do, not how you do it.
12:15:11 <monochrom> I agree that you don't have access to microcode anyway. But I am just pointing out that reading asm code you can still miss out performance issues due to re-ordering, speculative execution, etc.
12:15:17 <maerwald> most ppl don't even know the rules when something can inline, wheat blocks stuff from inlining etc and how drastically it changes performance
12:15:18 <merijn> zugz_: You will make everyone's life worse. Just unconditionally require the C library (you can move that functionality into a separate library that wraps your original if you wanna be able to use it without C)
12:15:23 <hololeap> so again, the issue is the definition of low vs. high level
12:15:31 <maerwald> look at the lexi lambda talk about eff and performance
12:15:38 <maerwald> if any of that you consider easy... I don't know
12:16:08 <maerwald> then you're probably among the 5% who know haskell performance well
12:17:04 <wavemode> my typical procedure is to sacrifice a ram to the ghc gods and pray they decide to inline my function
12:17:23 <davean> I'm actually really disapointed by GHC's lack of optimizations.
12:17:25 <zugz_> merijn: could you expand on that parenthetical suggestion?
12:17:35 <hololeap> wavemode: lol... nice double entendre with "ram" :)
12:17:52 <davean> Its the stupidest direct translation of code that could possibly work I feel.
12:17:58 <monochrom> Yeah perhaps you bought that ram from amazon and downloaded it.
12:18:30 <davean> we don't even peephole really.
12:18:33 <maerwald> haskell performance is usually: lemme code for a while and as long as the heap profile looks normal, idc what any of this stuff does
12:18:52 <maerwald> so it's inherenlty debug driven
12:18:57 <davean> If you look at the code GHC spits out it'll repeat an instruction or do an instruction and its inverse
12:19:27 <merijn> zugz_: A fairly common pattern is to have a core package parameterised over some abstract interface that can be implement by external packages
12:19:38 <maerwald> idk how you would find memory leaks by looking at the asm code even
12:19:57 <maerwald> probably not in the bag of tricks of most haskellers :p
12:20:00 <merijn> zugz_: So you have "persistent" which doesn't really specify anything about implementation and separate "persistent-postgres", "persistent-sqlite", etc. libraries that "extend" persistent
12:20:07 <merijn> zugz_: Similar for things like Selda
12:20:14 * hololeap didn't mean it in the lewd sense
12:20:20 <zugz_> merijn: I see what you mean
12:20:32 <merijn> zugz_: I do a similar thing for my broadcast-chan package where I have a bunch of convenient stuff for conduit and pipes in separate packages
12:21:27 <merijn> zugz_: the problem with conditional features is that 1) the cabal solver for buildplans can't really do much with them and 2) it makes maintenance/deployment a hell of "this magically works on machine A, but not on machine B" and then you find out a C library was missing and the features invisibly changed
12:21:53 <merijn> zugz_: Best to make these thing unconditional and just use multiple packages if you want the ability to "not have" a certain dependency
12:22:00 <zugz_> merijn: but in this case, it's a matter of some small non-crucial additional functionality which could be added by a c library (libmagic)... I don't really want to break people's build attempts just because they don't have the library installed, but on the other hand I'd rather not have them have to explicitly enable a flag to get the extra functionality. But I suppose the latter isn't so bad.
12:22:23 <zugz_> merijn: right...
12:22:32 <merijn> zugz_: libmagic so to lookup filetypes?
12:22:37 <zugz_> y
12:23:28 <merijn> zugz_: So, consider this: Why not have your function take "(FilePath -> IO FileType)" (or whatever) as argument, then you can write a simple naive extension based function and a more intelligent version that use libmagic separately
12:23:43 <merijn> zugz_: Hell, that even lets you/others come up with other alternative solutions
12:24:20 <monochrom> Ah yes, "dependency injection" in #haskell means "just take one more parameter".
12:24:25 <hololeap> zugz_: sounds like gentoo, tbh
12:24:27 <merijn> (if someone invents a pure haskell libmagic or something, in fact, I think I saw something like that get put on hackage today)
12:24:28 <hololeap> use flags
12:24:47 <merijn> monochrom: I appreciate that as a solution more and more
12:25:06 <zugz_> merijn: yes, I'm doing that with an #ifdef MAGIC to decide between the two
12:25:07 <monochrom> But you can always over-engineer it by going backpack instead. :)
12:25:11 <merijn> monochrom: It's so incredibly simple, so maintainble and it scales well :)
12:25:27 <zugz_> and a flag to decide whether to define MAGIC
12:25:46 <monochrom> Haha let me prepare a talk "dependency injection using backpack" for the next April 1st.
12:26:14 <merijn> monochrom: Sounds like you've got your SIGBOVIK submission sorted :p
12:26:39 <maerwald> monochrom: backpack... this thing that everyone wanted, but no one wants to use
12:26:57 <merijn> It's because ezyang got poached by tensorflow :p
12:27:16 <monochrom> I had a roast in my lecture notes.  "SML, Caml, OCaml.   A module can take other modules as parameters. Real Template Methods."
12:27:16 <merijn> (that's what he was doing, I think?)
12:27:49 <monochrom> I think it's because backpack came too late.
12:28:13 <dolio> monochrom: I've already been to a talk about how dependency injection is Reader. :P
12:28:29 <monochrom> Nice
12:29:12 <monochrom> Also associated data and type families came right after.
12:29:12 <zugz_> merijn: I guess you mean https://hackage.haskell.org/package/lingo, but that's only for source files
12:29:18 <merijn> ah
12:29:33 <merijn> I don't read beyond the IRC blurb :p
12:29:34 <dolio> Backpack is probably more accurate.
12:29:53 <zugz_> oh well, so it sounds like I'm not missing some easy trick. Thanks!
12:30:41 <sm[m]> I didn't want it
12:30:54 <sm[m]> but noone cares what I think <sniff>
12:31:06 <p0a> so I'm following the learnyouahaskell book and doing the `todo list program' by myself before looking at their solution. If anyone wants to take a stab at it: https://termbin.com/wd51 (warning: no documentation and bad code)
12:31:18 <maerwald> sm[m]: I'll always care for you
12:31:29 * sm[m] cheers up
12:31:46 <merijn> p0a: Insert a newline after the case of so you don't have to indent so damn much :p
12:31:51 <sm[m]> maerwald how did that story turn out, was your app saved ?
12:31:52 <p0a> I'll also care you helped me a lot sm[m] :D
12:32:00 <sm[m]> \o/
12:32:07 <maerwald> sm[m]: which story? :>
12:32:08 <davean> My baseless oppinion is that backpack shores up an area Haskell already had a lot of good solutions. It covers a few cases but we already had most of it.
12:32:12 <p0a> merijn: good suggestion, thank you 
12:32:25 <sm[m]> the leaking codebase that noone could save for three years
12:32:33 <sm[m]> and evil consultant was about to rewrite
12:32:35 <merijn> p0a: "intercalate '\n'" is just unlines :)
12:32:37 <merijn> :t unlines
12:32:38 <lambdabot> [String] -> String
12:32:44 <davean> and using it is hard due to build tool ...
12:32:54 <maerwald> sm[m]: yes, a guy single handedly fixed it over a weekend, lol
12:33:08 <p0a> merijn: ah yes! thank you 
12:33:11 <maerwald> you can't imagine our faces the next monday
12:33:26 <sm[m]> and now all is well in the kingdom ? or haskell is still viewed with suspicion by management ?
12:33:55 <maerwald> sm[m]: well, the point is, he's a very smart and performance knowledgable guy
12:33:57 <merijn> I just don't tell management what I write stuff in, problem solved... >.>
12:34:24 <monochrom> The Leaky Cauldron : Harry Potter world :: The Leaking Codebase : Haskell community
12:34:29 <merijn> I mean, we've probably already to north of 20 languages in various projects, what's one more :p
12:34:55 <p0a> merijn: what I really like about the learnyouahaskell solution is that they abstract a lot of things away and their code appears to be on first glance, a much better solution 
12:34:57 <merijn> Actually, now I'm curious how many languages we have
12:34:58 <maerwald> sm[m]: I'm still bugging him to write a tech blog post about it, because it's an interesting case
12:35:24 <sm[m]> I'd definitely like to watch/read that story
12:35:31 <merijn> p0a: It takes practice to get good at seeing how to abstract things :)
12:37:48 <hololeap> you gotta be very smart to use haskell. management just questions your intelligence
12:38:19 <dolio> davean: Yeah, there are a lot of things people use modules for that are addressed as well or better with other things in Haskell/GHC.
12:38:28 <mniip> we are a haskell-only company >.>
12:39:07 <hololeap> LYAH should have a IQ test as an entry exam
12:39:21 <mniip> (though github will tell you our repo is 59.3% PLpgSQL)
12:39:24 <monochrom> Everything should have that.
12:39:26 <p0a> :-( IQ tests are lame 
12:39:58 <merijn> IQ tests are super gameable too
12:39:59 * hololeap is being sarcastic
12:40:02 <monochrom> Use my IQ tests then. They're better.
12:40:25 <mniip> if there's an intelligence quotient, is there an intelligence remainder too
12:40:44 <monochrom> Question 1: A beginner comes into #haskell and ask "I got an error message. How do I fix it?". No further information, Why is this bad?
12:40:54 <davean> dolio: I mean they aren't complete. Backpack isn't useless. But people looking in probably wanted it more than people who where already here.
12:41:05 <merijn> monochrom: "Sense of humor is correlated with intelligence. Intelligence is correlated with academic success. So we can just test if they get jokes." -- Ehud Lamm
12:41:13 <dolio> Yeah.
12:41:14 <monochrom> Question 2: A beginner comes to #haskell and post a URL to a PNG screenshot of their code. Why is that bad?
12:41:27 <merijn> @quote Cale beginners
12:41:27 <lambdabot> Cale says: Beginners are confusing to beginners. I move that we remove them from the language altogether.
12:41:51 <hololeap> my error message looks like a sigil from a cthulu cult...
12:41:53 <dolio> davean: Also, some major things that backpack would be useful for don't support it, I think.
12:42:07 <mniip> monochrom, depending on the code it might not be bad
12:42:08 <monochrom> Question 3: A homework question states that the input is an integer. A student asks "is 0 a possible input?".  Why is that bad?
12:42:11 <dolio> Because they were all written before backpack.
12:42:16 <merijn> dolio: Be the change you wanna see in the world! ;)
12:42:29 <monochrom> Anyway those are what my IQ tests look like.
12:42:47 <monochrom> Hrm the name Ehud Lamm sounds familiar.
12:43:09 <hololeap> i don't really blame haskell beginners for having a wtf moment when it comes to error messages, since that's generally what you look up in other languages
12:43:15 <[exa]> hm, I might have already asked, but is there any implementation of the O(n)-space diff algorithm in haskell?
12:43:20 <merijn> monochrom: It's from my quotes file which is considerable parts (90%) #haskell, so..
12:43:28 <monochrom> Ah OK heh
12:43:53 <monochrom> Oh you also need to see my definition of IQ I made years ago.
12:44:26 <monochrom> 100 / (average number of times you need other people to repeat a sentence to you)
12:44:40 <hololeap> monochrom: that could just be bad hearing
12:45:13 <monochrom> Note that >100 is possible. When you're so smart, people just have to say the first half of the sentence, you already know the second half.
12:45:28 <monochrom> Or bad reading? Consider IRC>
12:45:45 <maerwald> monochrom: add a social empathy question to your IQ test 
12:45:52 <hololeap> i guess arrogant jerks just have a really high iq
12:46:05 <maerwald> hololeap: depends on the definition
12:46:24 <maerwald> IQ is poorly defined. It measures only what it measures
12:46:34 <hyperisco> so does a ruler
12:46:37 <maerwald> yeah
12:46:52 <mniip> should we use rulers for this then?
12:47:01 <hololeap> anyone who just cuts me off mid sentence is clearly processing things twice as quickly as me
12:47:11 <hyperisco> biologists approximate intelligence by brain size, so perhaps :P
12:47:49 <monochrom> Well nothing says you should cut off people mid sentence. Not even when you already know the rest. You can keep your peace too, you know?
12:47:51 <dolio> hololeap: Cutting you off mid-sentence isn't the same as understanding your sentence half-way through. :)
12:48:16 <maerwald> even the "academic IQ" can shift dramatically depending on how strong the stimulus to your brain is
12:48:24 <monochrom> Conversely, nothing says just because they cut off you it means they actually know. Consider Dunning-Kruger.
12:48:36 <hyperisco> wait so is a Markov chain fairly intelligent? :P
12:50:47 <hololeap> maerwald: it also seems likely that doing a lot of mental training for that kind of IQ would help.
12:50:58 <maerwald> definitely
12:52:23 <maerwald> and new brain research suggests that some assumptions about how the brain works are simply wrong: e.g. there are highly intelligent ppl, who cannot visualize anything (called Aphantasia)
12:53:24 <hololeap> yeah, the breadth of cognitive function seems incredibly complex
12:53:58 <maerwald> yeah, so I question that we have a useful test for any of this
12:54:32 <hyperisco> as long as you can identify an elephant and count backwards from 100 by seven you're solid
12:54:45 <maerwald> lol
12:59:17 <hololeap> reminds me of the blind men and the elephant parable
12:59:28 <hyperisco> IQ tests I have seen are time dependent
13:00:56 <hyperisco> if someone could answer any reasonable question given enough time, are they less intelligent than someone who could answer fewer reasonable questions but quicker?
13:01:14 <maerwald> hyperisco: imagine you got adhd and during half of the test you're thinking about actual elephants :p
13:01:24 <hyperisco> and how do those two people compare to someone who can give approximate answers faster still?
13:01:43 <maerwald> "focus" is another thing that blurs this
13:02:15 <maerwald> and it's highly dependent on the stimulus and the brain "chemistry"
13:05:06 <ixlun> Is it possible to do an 'or' when pattern matching?  e.g. say I've got 'data Foo = Bar | Baz | Tan | ...' can I write a case rule like: 'Bar | Tan -> ...'?
13:05:13 <hyperisco> did you know a computer only uses 10% of its circuits?
13:06:16 <hyperisco> ixlun, if you rule out all other cases then what is left must be Bar or Tan
13:06:31 <wavemode> the sherlock holmes tactic
13:06:44 <p0a> hyperisco: you may have X|Y and Z|W as cases
13:06:56 <hyperisco> that sounds like a McBridism
13:07:09 <p0a> and therefore a better solution is needed, and afaik you can't do that in `case' but there may be an extension? I don't know
13:07:50 <p0a> does Bar -> Tan -> work?
13:07:58 <p0a> No that wouldn't work 
13:08:10 <p0a> that's a C trick :P
13:08:34 <hyperisco> case m of X -> a; Y -> a; Z -> b; W -> b  is what I would try
13:09:17 <maerwald> case x of Bar | boolExpr -> -- is valid, but doesn't do what you want
13:09:30 <ixlun> I've got a data type that has about 12 different constructors, I only want to do something different on two of them.
13:09:36 <maerwald> it's an && rather
13:09:51 <p0a> ixlun: consider writing another type and a conversion?
13:10:02 <p0a> ixlun: 12constructors -> 3constructors
13:10:40 <p0a> Also since only two have different behavior can't you use case for two and the default for the others? Or those two have the same behavior?
13:11:13 <hololeap> ixlun: case foo of; Bar -> f; Tan -> f; where f = ...
13:11:15 <maerwald> https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-460003.13
13:12:13 <hyperisco> never knew let was allowed in guards
13:12:22 <hyperisco> this doesn't change my life at all
13:12:56 <p0a> you could probably write the solution of hololeap in a macro
13:13:00 <p0a> and thus extend case 
13:13:30 <maerwald> this might be a good introduction in learning about how to write GHC extensions?
13:13:37 <p0a> something like myCase expr of A|B -> etc; C|D -> stuff;
13:13:51 <hyperisco> executes a billion instructions a second and you people always want more… can't put in a few bytes of effort
13:14:09 <ixlun> p0a those two have the same behaviour, and I didn't want to duplicate code if I can avoid it
13:14:34 <p0a> ixlun: yeah so you can avoid the duplication with what hololeap wrote, which did not occur to me 
13:15:01 <ixlun> Ahh I see, define f as the common code, nice
13:15:08 <ixlun> thanks all! :)
13:15:49 <p0a> It'd be a nice feature to have by default but there may be a reason why it's not there 
13:16:11 <maerwald> p0a: probably because | is already reserved
13:16:23 <maerwald> what syntax would it have
13:16:59 <maerwald> and you don't really want to introduce something new just for this case
13:17:17 <p0a> I'll be honest I think the `where' solution is just fine
13:17:30 <maerwald> yeah, that's why no one bothers
13:17:39 <p0a> right
13:17:48 <ixlun> Agreed, `where' worked perfectly
13:18:45 <hololeap> the problem with making a syntactic sugar for it is that each of the constructors grouped together has to have the same parity... or would that be a problem?
13:19:56 <dolio> If the constructors bind variables, it's a little more dicey.
13:20:12 <dolio> They could easily work for nullary patterns, though.
13:20:33 <hekkaidekapus> The feauture is usually labelled as “Or-patterns” there is an abandonned GHC proposal & discussion that summarise what would be needed to bring it into existence.
13:20:34 <hololeap> more than just parity, actually, they'd have to be isomorphic
13:20:52 <hololeap> actually... more than that XD
13:20:54 <monochrom> If two constructors take the same fields, it's reasonable to wish for an "or". Some languages support it.
13:21:05 <dolio> They need to bind the same variable with the same types.
13:21:12 <hololeap> dolio: in the same order
13:21:30 <dolio> The order doesn't matter.
13:21:38 <maerwald> monochrom: in bash it's |
13:21:47 <monochrom> What if two constructors take the same fields, but the type is defined with record syntax, and the two constructors take the same fields but with incompatible field names? This debate will never end.
13:22:42 <hekkaidekapus> https://github.com/ghc-proposals/ghc-proposals/pull/43
13:22:51 <monochrom> Sometimes, it is not a good sign that a solution exists.
13:23:10 <monochrom> It is a bad sign when multiple competing solutions exist.
13:23:14 <maerwald> I think this might be unambigous syntax: case x of | Foo, Bar, Baz -> 
13:23:49 * hackage lz4-hs 0.1.5.0 - lz4 bindings for Haskell  https://hackage.haskell.org/package/lz4-hs-0.1.5.0 (vmchale)
13:23:56 <merijn> monochrom: Ocaml managed to figure it out...
13:24:49 <monochrom> I gathered they are much nicer people who debate less.
13:25:07 <merijn> monochrom: Yeah, they just do what Jane Street says ;)
13:25:31 <monochrom> Unfortunately, I would debate them forever on some choices they made, such as their parameter order for fold_left and fold_right.
13:25:52 <merijn> monochrom: What? Not about +. ? :p
13:26:22 <monochrom> Oh that one can't be helped. They don't have type classes. Unfair to require them to accept type classes.
13:26:43 <monochrom> Besides, that one can be solved by Backpack, and they have Real Backpack.
13:27:01 <hololeap> pattern matching on part of a constructor could be nice, so that `data Foo X Y Z` could be pattern matched with something like `Foo -> f`,  where f :: X -> Y -> Z -> r
13:27:19 <p0a> Right so part of the reason why this feature is not there is because of the complexity of pattern matching already in place
13:29:38 <p0a> that's my nontechnical summary coming from a nontechnical person
13:29:59 <monochrom> That sounds like a very technical explanation.
13:30:16 <monochrom> As opposed to accepting social, cultural, preferential choices as an explanation.
13:30:35 <monochrom> Tehcnically it is do-able. It is always do-able.
13:30:57 <monochrom> But how many people want it? Want it desperately enough? Do they have other priorities?
13:30:57 <merijn> The trick is getting people to agree on how
13:31:04 <maerwald> yes, but if you do everything you end up like C++
13:31:19 <monochrom> Right? Let me go to a very drastic extreme.
13:31:39 <monochrom> Suppose someone who loves Java comes here and ask "can Haskell be made more Java-like?"
13:31:44 <monochrom> Yes I know how.
13:31:58 <monochrom> I can hire a black-hat hacker to hack into GHC gitlab tonight.
13:32:03 <p0a> lol
13:32:15 <monochrom> Replace the whole GHC source tree by the whole openjdk source tree.
13:32:24 <monochrom> Now GHC is compatible with Java.
13:32:37 <monochrom> It can be technically done. At just takes an evening.
13:32:44 <monochrom> DO YOU WANT IT?
13:32:44 <hekkaidekapus> p0a: The authors here: <https://icfp20.sigplan.org/details/icfp-2020-papers/17/Lower-Your-Guards-A-Compositional-Pattern-Match-Coverage-Checker> reduce the complexity to only 3 constructs.
13:32:59 <p0a> Are you like those villains on TV that explain their evil masterplan prior to executing it?
13:33:49 <hololeap> nobody is making a monologue against them, so i'd say no
13:34:37 <hololeap> unless it's one of those villains that is never taken seriously and hates every second of it, fuelling their evil
13:34:48 <p0a> hekkaidekapus: oh wow, the publication is available 
13:35:32 <merijn> Every publication is available if you know how to use Google Scholar and/or Scihub :p
13:35:52 <hekkaidekapus> Yes, and there is an implementation in GHC’s merge requests.
13:36:26 <hekkaidekapus> Which, by the way, already caught many lurking bugs.
13:36:27 <dolio> Yeah, I don't think it's because pattern matching is complex.
13:36:38 <monochrom> Wait, Russian paper pirating site in the Taiwan TLD?
13:37:01 <hololeap> dolio: i agree, it's just hard to make something ergonomically superior to what's in place
13:37:02 <dolio> There's about one question for or patterns, which is: how much are the or-ed patterns allowed to disagree with respect to the variables they bind.
13:37:08 <p0a> hekkaidekapus: so it seems that they convert the haskell syntax into a guard tree
13:37:30 <p0a> hekkaidekapus: whatever a guard tree may be; and they propose to analyze guard trees instead?
13:37:40 <dolio> E.G. records are just one way of getting that problem.
13:38:28 <p0a> hekkaidekapus: I have to say, I am not up to stuff with this notation or this line of research
13:38:35 <dolio> But there are simple answers to that question (don't bind any variables, must all bind exactly the same variables with the same types), and there are more ad-hoc but maybe more convenient answers.
13:39:04 <merijn> monochrom: It keeps jumping TLD to avoid the various copyright enfrocing agencies
13:39:29 <merijn> monochrom: It's like the pirate bay, except you get to feel zero guilt using it, because fucking academic publishers
13:39:43 <monochrom> I agree.
13:39:46 <merijn> s/fucking/fuck/ (or really, both)
13:39:55 <p0a> hekkaidekapus: I don't see what you mean though. Just because you can desugar into a guard tree (simplify), it doesn't mean that Or-patterns are now easier
13:40:01 <hekkaidekapus> p0a: They have a meta-language they desugar source Haskell into.
13:40:03 <hololeap> it's just really easy to fix the problem with a helper function
13:40:07 <hololeap> data Foo = Foo A B | Bar C D | Baz A B; withFoo :: (A -> B -> a) -> (C -> D -> b) -> Foo -> Either a b
13:40:17 <p0a> hekkaidekapus: unless the Or-patterns corespond to 'clean' and 'visible' operations on guard trees
13:40:36 <hekkaidekapus> p0a: No, this is not about or patterns.
13:41:04 <p0a> I was thinking about Or-patterns because of the previous discussion and when I said pattern-matching is complex it was in the context of implementing Or-patterns 
13:42:06 <p0a> so I am trying to understand whether you just addressed that part of my statement (answering with: pattern-matching can be simplified) or in the context of Or-patterns. I guess the former is true then...
13:42:49 <hekkaidekapus> p0a: Ah, ok. The referenced paper was an evidence that pattern-matching, even with so many feautures in GHC, is not inherently complex.
13:43:15 <p0a> Got it, thank you
13:44:54 <hekkaidekapus> p0a: Sorry if I confused you.
13:46:21 <dolio> hololeap: This is really missing features of patterns. They can be composed in arbitrary ways that aren't based on the data type structure.
13:46:49 <dolio> `Just (Just _) | Nothing -> ...`
13:48:09 <hololeap> dolio, i agree, but the original question was about pattens where certain constructors share the same code
13:48:23 <dolio> Or `Branch (Branch l x r) y Leaf | Branch Leaf x (Branch l y r)`
13:49:40 <hololeap> dolio: your first one translates to `() -> ...`
13:50:50 <hololeap> your second one doesn't seem to have any possible shared functions between the two type's you're ORing
13:51:06 <dolio> () doesn't have type `Maybe (Maybe a)`
13:51:34 <hololeap> i see your point
13:52:04 <hololeap> Just (Just _) | Nothing wouldnt match on Just (Nothing)
13:52:26 <dolio> Right.
13:52:42 <hololeap> although Just Nothing is isomorphic to ()
13:53:38 <dolio> Just Nothing isn't a type.
13:53:52 <hololeap> right, i mean the value ()
13:54:05 <hololeap> sorry, you're right i'm just rambling
13:54:07 <dolio> Well then, I don't know what you mean by 'isomorphic'.
13:54:17 <dolio> It can't be the usual meaning.
13:54:26 <hololeap> Just Nothing is a value, () is a value
13:55:05 <hololeap> f (Just Nothing) = (); g () = Just Nothing
13:55:50 <hololeap> yeah i guess it's not isomorphic because f is partial
13:56:45 <hololeap> nvm, not sure what i was thinking
13:57:46 <hololeap> somehow i was thinking that isomorphisms apply to values
13:59:08 <hololeap> cat-0 :)
14:05:47 <p0a> hekkaidekapus: not at all, your answer was interesting!
14:25:49 * hackage logict 0.7.0.3 - A backtracking logic-programming monad.  https://hackage.haskell.org/package/logict-0.7.0.3 (Bodigrim)
15:30:51 <L29Ah> how do i hGetContents w/o closing the Handle?
15:31:54 <monochrom> You just do.
15:32:16 <kraeXen> does anyone recommend `nixpkgs.cabal2nix`?
15:32:31 <monochrom> Err unless you mean you don't want hGetContents to semi-close behind your back.
15:32:39 <monochrom> Then you just can't.
15:34:39 <alar> Simplest lib to make HTTP GET ? Is it still Network.HTTP or is there something easier? I'm trying to replace some shell scripting
15:41:52 <merijn> http-conduit was pretty easy last I used it
15:44:40 <phadej> bare http-client is even easier, with `httpLbs`
15:45:18 <phadej> (depends if you want to download big file, or just read some resource)
15:45:44 <phadej> for first one, I'd might just call `curl` with process:)
15:50:31 <alar> curl is the first thing I thought of
16:26:49 <remexre> how do people typically do errors in large applications (where there's a huge number of them)
16:27:00 <remexre> I'm using fused-effects for effect management, if it matters
16:36:25 <hpc> remexre: the same way i handle any other element of its logic, by making the context for any particular error as small as possible
16:37:34 <remexre> hpc: er, I mean like, if I have 100 possible errors, do I really wanna define a type for each? or just constructors on one big one
16:37:35 <neutronstar> Hi all, I'm trying to learn how to use Text.Read to write my own instances and I'm not sure where to start. I've written very basic parsers in elm before but I'm confused about what these ReadPrec, ReadP, ReadS types are, and how to deal with precedence. Can anyone recommend a place to start reading?
16:37:54 <neutronstar> No pun intended
16:38:38 <hpc> ah, i would be more concerned that there's so many sorts of failures that are so significant they require so much attention
16:38:57 <ddellacosta> remexre: here's one take if you're up for a talk by Matt Parsons https://www.youtube.com/watch?v=A5c9kgDYXr8
16:39:25 <ddellacosta> he talks about using lots of small constructors, if I understand your question correctly
16:39:40 <remexre> ddellacosta: I'll give that a watch
16:39:53 <ddellacosta> remexre: hope it's useful! I liked it and learned a lot 
16:41:41 <Chobbes> Is mueval the status quo for safely executing untrusted Haskell snippets?
16:50:15 <ddellacosta> neutronstar: I'm not sure exactly what you're trying to do but you may get further with megaparsec in terms of learning resources. That said I haven't used Text.Read much. https://markkarpov.com/tutorial/megaparsec.html
16:52:21 <ddellacosta> looks like you'd probably rather be using the newer-style ReadPrec in any case
16:53:18 * hackage graphql-client 1.0.0 - A client for Haskell programs to query a GraphQL API  https://hackage.haskell.org/package/graphql-client-1.0.0 (leapyear)
16:54:49 * hackage semantic-source 0.1.0.1 - Types and functionality for working with source code  https://hackage.haskell.org/package/semantic-source-0.1.0.1 (rewinfrey)
17:01:19 <kelanu> Does Haskell have a built in value for the speed  of light in a vacuum, similiar to how it has one for pi?
17:01:54 <dolio> No.
17:03:38 <monochrom> Yes.
17:03:43 <monochrom> It's called 1.
17:03:53 <monochrom> It uses a normalized unit.
17:07:53 <Chobbes> I guess it makes sense. 0 is no speed, 1 is full speed.
17:14:15 <kelanu_> makes sense, setting the speed of light to 1 is the natural thing to do
17:15:15 <monochrom> General Principle of Relativity: Relativize the problem so the solution is unity.
17:16:14 <monochrom> Strong Anthropic Principle of General Relativity haha
17:21:32 <p0a> Hello I am reading Learn you a Haskell and I notice that there's examples where `let' is used without `in'. Is that correct? 
17:21:46 <p0a> I'm a bit confused because I thought that a `let' is always followed by `in'
17:22:00 <Chobbes> p0a: is this in "do" notation?
17:22:12 <p0a> Chobbes: yaeh
17:22:14 <Chobbes> You don't need the "in" in do notation.
17:22:28 <p0a> Okay, but how come?
17:22:40 <Chobbes> It defines the variable for the rest of the do block.
17:22:59 <Chobbes> It's convenience mostly :).
17:23:30 <p0a> thank you 
17:23:53 <p0a> I guess I'm just a bit confused, is this special syntax?
17:24:01 <monochrom> Yes.
17:24:04 <monochrom> It's all syntax.
17:24:22 <p0a> monochrom: so if I desugar `do' with such a `let' it will be incorrect?
17:24:36 <dolio> It's part of do syntx.
17:24:48 <monochrom> You can desugar correctly or you can desugar incorrectly.
17:24:49 <p0a> ah, got it. thank you 
17:25:20 <dolio> `do { let x = e ; m }` = `let x = e in do { m }`
17:25:22 <monochrom> Have you learned Chess?
17:25:54 <monochrom> Because after you have learned Chess you know to not ask "why" you only ask "are there other rules I haven't found out".
17:26:24 <p0a> the board game?
17:26:37 <monochrom> It is not "confusing" that a pawn's first move can be 1 or 2 squares forward, but after that, only 1 step forward.
17:26:57 <monochrom> It is also not "confusing" that if a pawn hits the other end, it gains special power.
17:27:25 <monochrom> It is not "confusing" that "do" has one "let" format and outside "do" there is a different "let" format.
17:27:58 <p0a> lol
17:28:42 <monochrom> It is not "confusing" that if the king and a rook have never moved yet, and if there is no other piece between them, then there is a special move that moves both.
17:28:51 <monochrom> And it counts as one move, not two.
17:31:54 <dibblego> and is not passing through check
17:32:21 <kelanu_> Not sure how helpful this is, but here's the way I see let notation inside do blocks
17:32:54 <kelanu_> generally if you want to do some sort of assignment that's not directly appart of an IO action you can put it in a let
17:34:19 * hackage libarchive 3.0.0.0 - Haskell interface to libarchive  https://hackage.haskell.org/package/libarchive-3.0.0.0 (vmchale)
17:35:00 <p0a> well the learn you a haskell program even has a bug :D mine didn't but I do run into those file locks due to lazy io
17:35:21 <p0a> I noticed that their `remove' function can remove the wrong item from the list (http://learnyouahaskell.com/input-and-output)
17:35:57 <p0a> that happens in case there's duplicate lines, say 1 - a, 2 - b, 3 - a. Then you choose to delete 3; but the contents you will obtain are b\na, not a\nb.
17:36:31 <dibblego> what bug?
17:37:16 <p0a> The one I just described. A bug in behavior, that is. It does not actually delete item 3; it deletes the first line that matches "a"
17:37:29 <dibblego> show code
17:37:37 <p0a> It's in the link I gave
17:37:42 <dibblego> which code in link
17:38:01 <p0a> the remove function, look up "and finally, we're"
17:39:02 <p0a> the culprit line is `newTodoItems = delete (todoTasks !! number) todoTasks'
17:39:16 <p0a> (also, the naming of these variables is ... suspect)
17:41:19 * hackage archive-libarchive 1.0.0.1 - Common interface using libarchive  https://hackage.haskell.org/package/archive-libarchive-1.0.0.1 (vmchale)
17:43:44 <dibblego> works for me https://i.imgur.com/W8DyBAg.png
17:45:01 <p0a> try "a\nb\na\n" and remove "2"
17:51:43 <Graypup_> can I like, trace the output of a template haskell splice?
17:51:55 <Graypup_> I need to diff something
17:52:06 <Graypup_> namely it's hosed on ghc8.8 and fine on ghc8.6.5
17:52:17 <Graypup_> so i want to see what it's doing
17:53:26 <monochrom> I think it's -ddump-splices or something along that line
17:53:55 <Graypup_> can I do that in ghci?
17:54:31 <monochrom> Do you already know two ways of giving ghc options/flags to ghci?
17:54:45 <Graypup_> isn't it :set
17:54:52 <monochrom> Yes that's one way
17:54:56 <Graypup_> and then you can give it on the command line also
17:55:02 <monochrom> Yes
17:55:14 <Graypup_> cool I just wasn't sure if 100% of ghc options were supported in ghci
17:55:55 <monochrom> There are certain things you should really ask before trying. Such as "what happens if I set my finger on fire".
17:56:23 <Graypup_> you could have just said 'yes' and it would have been easier lol
17:56:25 <monochrom> And there are certain other things it takes only 1 second to test and it's safe either way.
17:56:52 <monochrom> Short term easier, long term PITA
17:57:19 <monochrom> I witnessed the long term effect in real life on large scale.
17:58:14 <monochrom> You try to be generous and "helpful" and give quick answers to quick questions students ask, quick questions that they themselves could have settled just by trying or reading.
17:58:45 <monochrom> Soon you find that a class of 200 students stop doing their due diligence and just spam you with stupid questions all day long.
17:58:52 <monochrom> YES STUPID QUESTIONS EXIST.
17:59:12 <monochrom> I'm done with "there is no such thing as dumb questions"
17:59:33 <Graypup_> I'm used to other languages where the interpreter *is* actually limited and does different things than the compiler and didn't know if haskell was like them ;-;
17:59:41 <hyiltiz> Care to list a few of those long term effects in real life in larger scale?
17:59:49 <monochrom> I just did.
17:59:56 <monochrom> See? Another dumb question right there.
18:00:01 <hyiltiz> You listed one.
18:00:26 <monochrom> OK here is the second one.
18:00:34 <Plazma> monochrom: that's rude
18:00:37 <hyiltiz> I asked "a few"
18:00:48 <hyiltiz> :D ok 
18:00:54 <monochrom> The course is a 2nd year data structure course, and it's called "design and analysis of data structures"
18:01:25 <monochrom> No Plazma I'm done with endorsing accusations of "rude". I call you oversensitive.
18:01:29 <hyiltiz> Plazma: no worries it is raining today
18:01:51 <hyiltiz> Let him finish on data structure
18:02:02 <monochrom> The final exam has a question that goes "Design/Give a data structure for the following purpose blah blah"
18:02:13 <monochrom> A student asked for clarification. "What is data structure?"
18:02:21 <hyiltiz> Omlmfao
18:02:29 <Plazma> monochrom: that's fine but you're still being rude right now
18:03:30 <monochrom> Anyway even the "one single" consequence of getting spammed with mindless questions is huge enough, a time-sink enough, that we don't really need another consequence, do we?
18:04:41 <monochrom> I put up a 12-page explanation of AVL trees as part of "required" reading material, as in "the textbook is required", but the textbook doesn't cover AVL tree, so I thought it would be helpful to include AVL reading material.
18:04:55 <monochrom> Or rather, it would be responsible to.
18:04:55 <hyiltiz> Now I'm intrigued to find a question that is not mindless but has only one consequence
18:05:20 <monochrom> A student asked "Do we really have to read this? It's like 12 pages".  As one of that spam of mindless questions.
18:05:28 <Plazma> monochrom: you teaching high school?
18:05:45 <hyiltiz> Lol high schoolers don't do avl tho
18:05:48 <monochrom> Just to give you a sample of that "one single" consequence
18:05:55 <p0a> monochrom: when I was teaching I was accused of being too cold and unsympathetic in my reviews
18:06:01 <monochrom> 2nd bloody year university CS
18:06:18 <monochrom> Students acted like 5yos
18:06:20 <Plazma> monochrom: ahh, you full time prof? 
18:06:24 <monochrom> No.
18:06:39 <Plazma> monochrom: i misspoke earlier i suppose, i can uunderstand your frustrations
18:06:49 <int-e> p0a: aka blunt and objective?
18:06:58 <hyiltiz> Oh are we guessing who is monochrom  game now?
18:06:59 <Plazma> damn int-e and p0a hang in here too.. 
18:07:03 <hyiltiz> Are you female?
18:07:36 <Plazma> everyone on the internet is 
18:07:42 <p0a> int-e: I'm not entirely sure :) I am still working out on how to 'fix' that. Not sure if everything needs to be fixed though. Maybe not everyone can be pleased.
18:10:24 <int-e> p0a: I'm reminded of http://www.us.lspace.org/books/apf/words-from-the-master.html "I always listen to advice. It's polite. If I *heeded* all the advice [...]"
18:11:00 <hyiltiz> Meanwhile can I ask a Haskell question? Do people usually autogenerate lens with TH? Is autogenerated lens worth inducing TH into Hask?
18:12:20 <int-e> "worth inducing TH into Hask" wrecked my parser.
18:13:32 <p0a> int-e: hehe. To add to the joke, I've read a discworld book that everyone says is bad, but I liked it.
18:13:36 <int-e> But I suspect the answer is yes (people usually use the TH mechanism for lenses) and it's likely worth it because it replaces a significant amount of boilerplate by a single line.
18:13:42 <Axman6> you could always use generic-lens and avoid the TH
18:13:58 <hyiltiz> s/inducing/introducing
18:14:22 <hyiltiz> You have a semantic parser?! 
18:14:34 <int-e> hyiltiz: Apparently.
18:15:11 <hyiltiz> How did you implement it, pray do tell
18:15:12 <Axman6> The new Typed TH stuff can't be used for generating top level definitions right?
18:16:31 <int-e> hyiltiz: I trained a neural network for several decades.
18:16:44 <Axman6> must've cost you a fortune!
18:17:09 <hyiltiz> Care to elaborate the architecture and share the training data online under GPL?
18:17:37 <Axman6> it's called HOMOSAIPEN-2
18:17:54 <hyiltiz> Überman
18:18:01 <int-e> Axman6: I'm not keeping track :P Also a large part of that cost was born by my parents.
18:18:33 <int-e> err, borne.
18:18:41 <Axman6> both work :)
18:19:00 <hyiltiz> Bad lexical parser  it seems :D
18:19:22 <Axman6> it's a neural network, close enough is food enough
18:19:30 <int-e> hyiltiz: This is pretty printer territory ;)
18:20:19 <hyiltiz> Oh just the output later on misbehaving given context it seems ;P
18:20:34 <monochrom> Um please don't take brain as food.
18:20:50 <hyiltiz> Unlike Dr Letter?
18:20:55 <hyiltiz> Lectrr
18:20:58 <hyiltiz> Lecter
18:21:18 <hyiltiz> Well apparently listen to monochrom ...
18:22:58 <hyiltiz> https://en.m.wikipedia.org/wiki/Brain_(food)
18:29:07 <triteraflops> So, in reality , how much of Haskell is done outside the IO monad?
18:29:45 <triteraflops> Because you could just put everything in IO and get java lol
18:31:46 <triteraflops> well, not really, but you know what I mean hopefully. If not, you can ask for clarification lol
18:34:00 <monochrom> 80% of Haskell code in my course are outside the IO monad.
18:36:31 <triteraflops> You're a teacher?
18:36:49 <monochrom> yes
18:37:07 <ezzieyguywuf> so, I'm using the Graph data type from fgl to store adjacency information. I'm interested in creating a graph such that there are different types of nodes: some nodes can have only one "incoming" and one "outgoing" connections, where others can have multiples.
18:37:36 <triteraflops> well, 80% in teaching code, that's an upper bound, anyway
18:37:42 <ezzieyguywuf> is there a graph library that includes this sort of thing? or would I be better off rolling my own? or is fgl "feature complete" enough that I'm probably trying to fit a square peg in a round hole and ought to rethink my approach?
18:37:43 <triteraflops> pretty good, really
18:38:45 <p0a> ezzieyguywuf: I don't know about fgl at all, but I had some experience with https://hackage.haskell.org/package/algebraic-graphs
18:38:56 <monochrom> The IO part is only because I use HUnit to test student code.
18:39:10 <ezzieyguywuf> p0a: I'll take a look thank you.
18:40:01 <hyiltiz> Is it easy to plot those algebraic graphs?
18:40:39 <triteraflops> also, pretty unrelated, but I heard (from #haskell a few years back, actually lol) that haskell can do instance migration between hosts?!
18:41:07 <triteraflops> so I could write a program for a single host and run it in parallel on many?
18:41:11 <ezzieyguywuf> p0a: hrm, "This is an experimental library and the API is expected to remain unstable until version 1.0.0."
18:41:57 <p0a> ezzieyguywuf: it's a simple enough library, I think what that means is that functions may change, but I don't think there's going to be significant changes, since it all revolves around a central idea (graphs being algebraic)
18:42:24 <p0a> It's up to you :) but I had a good experience with it and what you want is possible with it
18:44:06 <ezzieyguywuf> p0a: 👍 thanks again for the recommendation, and the endorsement. I'll definitely give it a shot.
18:50:06 <hyiltiz> Any recommendations for a good SAT solver? Something at least as "good" as libsolv, ieally with a good DSL and even better with support for various solver algorithms for a problem specified in that DSL
18:51:07 <kupi> why the signature of the >> function is not this? a -> b -> b
18:51:27 <triteraflops> kupi: it's for monads
18:51:41 <monochrom> How would you implement >> ?
18:51:41 <ezzieyguywuf> what does "E ⊆ V × V " mean?
18:52:10 <triteraflops> It means E is a subset of the cartesian product of V with itself
18:52:24 <ezzieyguywuf> triteraflops: thanks! I'll look up "cartesian product"
18:52:25 <kupi> nvm i am stupid
18:52:25 <monochrom> Suppose V = {1,2,3}.
18:52:28 <triteraflops> or every element of E is a pair of elements from V
18:52:30 <p0a> ezzieyguywuf: i.e. that an edge is (u,v) where u,v are vertices.
18:52:53 <monochrom> One example of E is { (1,2), (3,1), (1,3) }.  There are other examples.
18:53:19 <triteraflops> graphs!
18:53:23 <ezzieyguywuf> graphs!
18:53:36 <triteraflops> :D
18:55:38 <ezzieyguywuf> monochrom: found this in wikipedia, makes sense to me "A x B = {(a,b)|a∈A and b∈B}"
19:06:40 <ezzieyguywuf> lol, "Do you see why alga is an implementation of an algebra of graphs? There is a lot of maths here! No please don’t run away like you have seen a zombie in a graveyard! Don’t worry, this is not-so-difficult math."
19:19:01 <cheater> hi, has anyone got any tips on running a multithreaded ghc program as part of an existing C program?
21:19:49 * hackage yhseq 0.3.0.0 - Calculation of YH sequence system  https://hackage.haskell.org/package/yhseq-0.3.0.0 (Hexirp)
22:05:17 <enderdragon> Hi, I'm super new to haskell, I'm trying to find what operators such as (^.) and (^?) mean, like what's the significance of caret? Couldn't find anything in docs/books/internet. Help appreciated, thanks!
22:06:03 <dolio> They are operators defined in lens.
22:06:10 <c_wraith> they're library-defined stuff.  You'd have to look them up in the library that they're from.
22:06:16 <c_wraith> Which is almost certainly lens, yes.
22:06:16 <wavemode> do you know anything about lenses?
22:07:28 <enderdragon> Not really, but I'll look into lenses, I saw the usage of that in code. Thanks for the direction.
22:07:49 <wavemode> there is a handy tutorial: https://hackage.haskell.org/package/lens-tutorial-1.0.4/docs/Control-Lens-Tutorial.html
22:10:58 <dminuoso> I'd really like some mnemonics guide on lens operators.
22:11:15 <dminuoso> I think ^ indicates "getting something out" judging from all the operators starting with ^
22:11:40 <c_wraith> the lens operators all follow patterns, yes
22:12:07 <dminuoso> Is there a document describing these patterns?
22:12:16 <dminuoso> Or is that just in edwards head? :<
22:12:24 <c_wraith> someone wrote it down somewhere.
22:13:50 <dolio> The original reason was that (^.) looks like record dot access, but (.) is taken. Then other things riff on that.
22:14:39 <dminuoso> Ah. I kept imagining ^. was a face with one eye, and you'd put a monocle (i.e. lens) in the free spot.
22:14:48 <dolio> ? is optional, ?! is a partial function version of the optional thing.
22:14:55 <dminuoso> Such that the face could *view* through the monocle. :<
22:15:13 <dminuoso> Yours sounds a bit more believable
22:16:21 <dminuoso> Presumably ~ is about modifications of some kind, and = about modifications in MonadState?
22:16:41 <dolio> And then in the setters, = is for assignments in state monads, and ~ is the pure updater version.
22:17:46 <dolio> Since ~ gets used for equality in other places, I guess.
22:18:23 <dminuoso> Ohh, you mean similarly how we use ~ in the type level as we use = in maths or the haskell value level?
22:18:52 <dolio> Yeah, ~ is the type equality constraint for instance.
22:19:07 <dminuoso> right
22:20:12 <dminuoso> And @ indicates zipping with the index for indexed optics I guess
22:21:11 <dolio> I guess. I'm not sure where the % comes from, either. I guess you need something because you can't use (=) or (==).
22:21:28 <dolio> So, similar to the caret.
22:22:54 <dolio> I haven't really used anything that goes beyond that. There are tons of strings of symbols that I imagine almost never see any use.
22:28:11 <dolio> I'm pretty skeptical that code with heavy use of 5-symbol lens operators would be good by any measure.
22:29:28 <wavemode> pfft. haskell code isn't supposed to be _good_. it's supposed to make the author look smart
22:30:00 <dolio> They won't look very smart when they can't explain what it does 2 months later.
22:31:28 <wavemode> that's what the paper is for!
22:45:30 <Axman6> I once found a reasonable use for a crazy lens operator, a friend had some code that ran in MonadState which extracted something from the state using a lans, applied a function to it, updated the state with the new value and returned the old. IIRC that's nicely represented by <<%=
22:45:59 <Axman6> : (<<%=)
22:46:05 <Axman6> :t (<<%=)
22:46:06 <lambdabot> (Data.Profunctor.Strong.Strong p, MonadState s m) => Over p ((,) a) s s a b -> p a b -> m a
23:16:04 <jchia> I'm trying to understand why I'm not getting a Biplate instance in my code. I believe my types match the constraints for getting the instance but it's not work. Can I get some help understanding what's happening?
23:16:07 <jchia> https://gist.github.com/jchia/c50b638fa9ee8f6b4e7d51aef5771c0f
23:22:03 <dminuoso> Axman6: Mmm, what is Over for? What kind of optics does this work with?
23:24:31 <dminuoso> jchia: Just an odd thought, but is the version of uniplate you're looking at in haddock the same that you're using?
23:24:47 <jchia> dminuoso: yes
23:27:27 <dminuoso> jchia: Mmm, perhaps its an orphan instance that haddock somehow picked up?
23:27:34 <jchia> I'm even getting "No instance for (Uniplate Char) arising from a use of ‘dbg3’"
23:27:36 <dminuoso> https://github.com/ndmitchell/uniplate/blob/master/Data/Generics/Uniplate/Internal/OperationsInc.hs
23:27:37 <jchia> That's a more root cause
23:27:42 <dminuoso> It's definitely orphan instances
23:29:08 <dminuoso> Ah yes
23:29:18 <dminuoso> jchia: add an import for Data/Generics/Uniplate/Data.hs
23:29:27 <dminuoso> Then the instance will be in scope
23:30:50 <dminuoso> That is, Data.Generics.Uniplate.Data
23:31:19 <jchia> dminuoso: Adding the import works. Let me go look at what really went wrong.
23:35:06 <jchia> diminuoso: Is the following what's happening? That OperationsInc.hs you linked does not define the instance, so the instances must be from somewhere else despite haddock showing them for Data.Generics.Uniplate.Operations and it turns out that Data.Generics.Uniplate.Data has the instance. So, ultimately a haddock problem.
23:36:05 <jchia> dminuoso
23:39:22 <jchia> thanks, i had been scratching my head for an hour
23:42:38 <kuribas> Can someone tell me what's the point of "proving" things using liquidhaskell, when the proves are broken?
23:42:42 <kuribas> proofs
23:43:06 <kuribas> taking this example: https://ucsd-progsys.github.io/liquidhaskell-blog/2020/08/20/lh-as-a-ghc-plugin.lhs/
23:43:21 <kuribas> the constraint is wrong, since:
23:43:28 <kuribas> > (maxBound :: Int) > 0
23:43:30 <lambdabot>  True
23:43:55 <dminuoso> jchia: Right. Presumably haddock collects all instances it finds. Note, this is why you shouldn't create orphan instances, because it can lead to situations where you create two overlapping instances, invisible to GHC.
23:44:19 <kuribas> > let incr :: Int -> Int; incr x | x > 0 = x + 1 | otherwise = 0 in incr maxBound > 0
23:44:21 <dminuoso> Then depending on how you import stuff, it would select a different instance leading to incoherent code
23:44:21 <lambdabot>  False
23:46:34 <kuribas> If I am going to use some proof system to make my code even more robust, at least I'd like to know it is actually consistent.
23:48:56 <dminuoso> jchia: To be fair, this is not a haddock problem. Technically, you didn't read the module description of http://hackage.haskell.org/package/uniplate-1.6.12/docs/Data-Generics-Uniplate-Operations.html
23:49:38 <dminuoso> It's perfectly valid for haddock to just scan all available instances and merge them together because of the open world assumption.
23:49:56 <dminuoso> The fact that GHC does not is a technical limitation perhaps.
23:50:59 <kuribas> I don't get why we still cannot put class instances in an export list.
23:52:08 <dminuoso> kuribas: You shouldn't get to *not* export an instance to begin with.
23:53:09 <dminuoso> It would just lead to situations with incoherent code without GHC knowing about it.
23:53:20 <dminuoso> Just like with orphan instances
23:54:38 <jchia> dminuoso: I only glossed over the text docs at the beginning of Data.Generics.Uniplate.Operations.
23:57:07 <dminuoso> This is the reason orphan instances are bad. If you don't have orphan instances, then importing either the typeclass *or* the data type ensures that all instances in the world are in scope. You can't have incoherent instances this way.
23:57:21 <jchia> Another uniplate question: Let's say my data structure contains Text, which has no Data instance and hence Typeable instance. So I can't use the Biplate stuff. If it were String instead of Text, then there would be no such problem. What should I do in this case? If I define a Data instance for Text, it would be an orphaned instance. I should wrap the Text in my own newtype, right? That's a hassle, so maybe I'll just use String.
23:57:22 <dminuoso> If you have the ability hide instances, then this wont work
