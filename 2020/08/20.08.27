00:03:42 <dibblego> or use lens
00:06:30 <jchia> I was wrong about the absence of a Data instance for Text. There is one.
00:07:55 <kenran> This is a long shot, but: I've built Haskell binaries running inside a Docker container (the container is built via nix, don't know if this matters) and everything's running fine on my macBook, another 3 linux machines, and a windows machine, but I get "line 5:    10 Illegal instruction     (core dumped) /nix/store/qz279kp6ij83g3skcqcwkbgdbgc26kxk-model-backend-0.2.0.0/bin/model-backend", where the line 5 
00:08:01 <kenran> is in the shell script that starts this binary
00:08:35 <kenran> Any ideas or tips on how I can find out what's wrong? Could it be that the new-ish GHC 8.8.x outputs instructions that are incompatible with this particular hardware?
00:09:51 <dminuoso> kenran: Run it with gdb/lldb?
00:10:15 <kenran> dminuoso: that would be a first for me, but ok, if it comes down to this.. :) thanks
00:10:24 <dminuoso> Not much of a choice, really.
00:10:44 <dminuoso> The core dump could be helpful as well
00:11:09 <kenran> I'd probably try to find out if I can produce the same error without the Docker layer first. I could get the project up and running there via cabal too I guess
00:12:44 <kenran> I don't know if it's likely that the error occurs when running the project through cabal though
00:23:49 <dredozubov> Is anyone aware of the state of asterius? I'm slighly concerned about the ghcjs future, but afaik it's not possible to build reflex-dom with asterius yet.
00:39:16 <phadej> dredozubov: IOHK seems to support development of both. e.g. https://iohk.io/en/blog/posts/2020/07/28/improving-haskells-big-numbers-support/  To reach that goal, we take part in the development of the Glasgow Haskell Compiler (GHC), GHCJS (Haskell to JavaScript compiler) and Asterius (Haskell to WebAssembly compiler).
00:40:30 <phadej> my wild guess is that, when IOHK loses interest in either or both, that/those project/s will be (again?) on the shoulders of community :)
00:52:44 <kuribas> or when the blockchain bubble bursts?
00:53:50 <phadej> impossible to predict which happens first 
00:54:19 <phadej> IOHK could lose interest in Haskell and rewrite everything in Rust :)
00:54:32 <kuribas> yeah
00:54:50 <kuribas> I mean, haskell isn't that great for numerical or low level stuff, is it?
00:55:00 <kuribas> it's good for write abstractions over it
00:55:07 <dminuoso> Why would it be bad for low level stuff?
00:55:10 <maerwald> use the ffi
00:55:12 <phadej> that isn't what IOHK does (low level / numeric stuff)
00:55:17 <kuribas> dminuoso: I didn't say it's bad?
00:55:42 <kuribas> dminuoso: I said it's not great, meaning there is no significant advantage when using haskell
00:56:15 <maerwald> kuribas: haskell is ok for network stuff
00:56:35 <maerwald> blockchain is a network :>
00:56:56 <phadej> ... and smart contracts are written in a programming language...
00:57:18 <phadej> haven't seen many posts about writing those in Rust ;)
00:57:46 <maerwald> yeah, plutus is written in haskell
01:08:19 <gnumonik> Is it possible to write a function that is polymorphic over lenses (or setters, I guess) for a datatype? E.g. what I tried here with updateFoo: https://gist.github.com/gnumonik/66df9d7f7949021a402032fbb08bee56 (ignore the use of read) 
01:11:09 <phadej> change a2s to a2, a3, a4
01:13:36 <phadej> write a function which does just `set aLens (read valStr) myFoo`, its type should guide you forward
01:14:59 <gnumonik> Thanks! Was worried I was trying something impossible. I'll work down that path. 
02:05:22 <Philonous> Whenever I write a json API I'm annoyed by all the boilerplate I have to write to (de-)serialize data (define (often many closely related) data type with overly long field names because of Haskell's namespace issues, sprinkle in deriving clauses and template haskell for aeson and lenses to make working it with bearable). So I wrote a library that builds on top of vinly that makes the process much less painful 
02:05:29 <Philonous> However, now I'm wondering if I'm reinventing the wheel 
02:05:49 * hackage hie-bios 0.7.0 - Set up a GHC API session  https://hackage.haskell.org/package/hie-bios-0.7.0 (fendor)
02:06:28 <Philonous> Is there a library that lets me use JSON structure ad-hoc, but in a strongly typed manner? 
02:08:56 <Philonous> Basically, I can just write Â»Struct '[ "email" ::: Text, "password" ::: Text ]Â« and it's automatically Show ToJSON FromJSON, has lenses etc. 
02:13:01 <lortabac> Philonous: if you want to avoid fancy extensibile records, you can try this technique to reduce boilerplate https://www.parsonsmatt.org/2020/02/04/mirror_mirror.html
02:21:31 <kuribas> if you use stack, can you use cabal then?
02:22:31 <kuribas> for a newbee, is it better to use stack, or haskell-platform?  (on windows)
02:22:35 <kuribas> or something else?
02:25:19 <kuribas> if possible restricted to ghc-8.6.5
02:27:56 * tomsmeding wonders why you'd want to restrict yourself to ghc-8.6.5
02:28:19 <dminuoso> tomsmeding: Because you want to use the static-haskell-nix overlays! :P
02:28:20 <Philonous> lortabac, This basically just gives me another way of deriving ToJSON/FromJSON instead of using TH. The point of my approach is that I don't have to define data types at all, I just write them in-line
02:28:45 <dminuoso> And those currently only produce good results on 8.6.5
02:34:06 <kuribas> tomsmeding: because it's not cutting edge, and it's supported by vscode 
02:38:11 <kuribas> does chocolatey support older version of ghc?
02:38:20 <kuribas> it doesn't look like it from the UI
02:38:52 <maerwald> dminuoso: nix works on windows?
02:39:37 <lortabac> Philonous: alternatively, it should be quite simple to define something like 'decodeGeneric :: Generic a => ByteString -> Either String a' by using aeson's generic facilities
02:41:36 <kuribas> oh, there is a --version param
02:44:03 <lortabac> Philonous: if you name your fields without suffixes, the default options are probably ok in most cases, so there is zero boilerplate
02:44:19 * hackage quickjs-hs 0.1 - Wrapper for the QuickJS Javascript Engine  https://hackage.haskell.org/package/quickjs-hs-0.1 (goodlyrottenapple)
02:44:23 <Philonous> lortabac, Sure, but then I still need to define a new data type for each JSON structure I want to parse/create
02:46:45 <lortabac> Philonous: ok, it looks like extensible records are what you are looking for
02:49:26 <Philonous> Yes, pretty much, I was wondering if there was a library that implemented them specifically for use in JSON APIs 
02:49:49 <Philonous> Otherwise I might publish my own
03:03:24 <avn> Philonous: you can try use json-sop (in theory)
03:11:45 <nij> Seems that many packages break after moving to base-4.14 :( I copied my old code to do some chart plotting.. it doesn't work as expected..
03:12:04 <fog> if i have a instance bound value, will it be recalculated each time it is referenced?
03:12:07 <nij> could someone take a look at this error message? 
03:12:15 <nij> https://dpaste.com/9U9D8FAX2
03:12:57 <fog> nij: what are you doing to get that error?
03:13:30 <fog> did you run ghci in a way that it removes the path?
03:14:17 <nij> I use cabal so I don't really know how to
03:14:33 <fog> so you typed cabal build or something?
03:15:01 <fog> it would be helpful to have the way to reproduce the error
03:15:14 <fog> its not imidiately clear for example, why it cant resolve Prelude
03:15:55 <nij> Ah `cabal repl` lemme try again
03:15:55 <nij> Ok.. `cabal repl` doesn't load, and spit out similar complaints as well
03:15:55 <nij> My build-depends in my .cabal are base(>=4.13 && <4.15), Chart, Chart-cairo
03:16:28 <fog> so you think it could be to do with cabal failing to resolve these dependencies...
03:19:24 <nij> yes, i tried `cabal build` and `cabal run`
03:19:35 <fog> perhaps someone more experienced with cabal could step in at this point 
03:22:36 <fog> <maerwald> dminuoso: nix works on windows?
03:22:37 <fog> no
03:22:44 <fog> you need to use WSL
03:23:17 <fog> something about it not having the right line endings...
03:23:42 <merijn> nij: Oh, oh, is it Arch?
03:23:44 <fog> i think its a cross compilation issue the devs havent contended with
03:25:14 <fog> <kuribas> for a newbee, is it better to use stack, or haskell-platform?  (on windows)
03:25:51 <kuribas> fog: idk, I don't use windows
03:25:51 <fog> im not sure why the GHC devs have not gotten the haskell platform distributing binaries as usual for the windows deployment
03:26:01 <merijn> kuribas: I had my girlfriend use stack, despite me not liking it, just so I didn't have to deal with chocolatey
03:26:16 <kuribas> merijn: is chocolatey so bad?
03:26:24 <fog> i think there was some recent advance with chocolatey
03:26:45 <merijn> kuribas: I dunno, I haven't used it, but it was like 3 more pages and install and whatever I just couldn't be arsed with
03:27:01 <fog> fwiu its been used by the ghc team internally and they were seeing if the comunity could wrangle it - incase that would save them having to deploy binaries
03:27:21 <fog> while this allows for less work for them - it certainly is *not* good for newbies 
03:27:32 <maerwald> I find chocolatey easy, but I'm not really a regular windows user
03:27:45 <maerwald> it seems those aren't really into it
03:27:47 <fog> i think possibly they will release binaries some time after after the chocolatey release 
03:28:23 <fog> maerwald: compared to double clicking a windows installer, its a much more offputting interface for new users
03:28:53 <maerwald> It's also not really a package manager
03:29:02 <maerwald> it invokes other installers and whatnot
03:29:32 <fog> one of the best things about introducing someone to haskell was showing them some list calculations like map in ghic, and then saying, "do you want one of these strange looking calculators on your own computer? its as simple as a few clicks on the haskell platform"
03:30:20 <fog> if thats a impactful barrier to addoption, i would encourage the shipping of binary distributions still
03:31:08 <maerwald> I don't think windows support is an adoption barrier at all, but that's just my opinion
03:31:16 <fog> why?
03:31:19 * hackage quickjs-hs 0.1.1 - Wrapper for the QuickJS Javascript Engine  https://hackage.haskell.org/package/quickjs-hs-0.1.1 (goodlyrottenapple)
03:31:41 <maerwald> I don't think any industry that uses haskell cares much about windows
03:31:52 <fog> for teaching and learning
03:32:00 <maerwald> that's not a big industry
03:32:04 <fog> many people new to programming use windows
03:32:35 <fog> adoption by humans, as opposed to adoption by companies 
03:32:45 <maerwald> and in university, you have to learn linux anyway, one way or another
03:32:56 <Rembane> fog: You can use repl.it instead of Windows https://repl.it/
03:32:58 <fog> a first language is a serious mental framework
03:33:26 <fog> Rembane: that does not give ghci on the machine
03:33:46 <fog> and so the new user cannot write to has .hs script and simply click on it to open it in ghci
03:34:20 <Rembane> fog: It does
03:35:03 <fog> i thought it was a browser based prompt, as opposed to a native OS based exe
03:35:41 <fog> do you just tell windows to open .hs scripts in the browser or something?
03:36:05 <Rembane> fog: You can write the code in the browser instead, and run it there. 
03:36:12 <fog> right, so it doesnt
03:36:15 <fog> ...
03:36:18 <fog> i had a question
03:36:20 <fog> if i have a instance bound value, will it be recalculated each time it is referenced?
03:38:11 <fog> Rembane: by "having ghci on the machine" i meant the ghci exe
03:38:45 <fog> so that in windows you can use "Open With" to make it launch ghci by double clicking the .hs file
03:39:33 <fog> like how windows users are used to using things. eg, a .doc file would open with open office or microsoft word or something, just by clicking it
03:40:07 <fog> all very important barriers to lower for the sake of ease for the new user 
03:40:26 <fog> instead of having to wrangle with chocolatey and cabal
03:40:31 <fog> like, thats what ghci is for
03:40:32 <Rembane> fog: It's almost as easy to open something in repl.it, but nevermind.
03:40:49 <fog> it just doesnt *feel* the same
03:41:09 <fog> like you have turned your computer into an enhanced beast
03:41:34 <fog> idk, maybe for zoomers it is better to do everything in the cloud
03:42:05 <fog> maybe there is an instagram based solution that bypasses the windows OS altogether 
03:42:44 <maerwald> :D
03:46:27 <fog> so, if i had a top level value, i would expect it to be memoised after it had been evaluated
03:46:45 <fog> but i dont know if i can also expect this from things bound as instances
03:47:33 <fog> i guess because they are of multiple types, it would only be one memoisation per type, but does that happen?
03:48:43 <fog> can i use a class over Symbol to bind one type level "name" to a memoised instance bound variable 
03:49:38 <fog> i want to be able to reference it from several parts of the program, and not have it be recalculated each time, since it should be the same
03:49:41 <fog> i think...
03:49:45 <fog> should it be the same?
03:49:49 <fog> i think so...
03:50:23 <fog> well, it should because the instance should not be overlapping
03:50:40 <fog> does anyone know if that how haskell works?
03:50:43 <fog> how could i check?
03:52:00 <maerwald> with unsafePerformIO?
03:52:36 <maerwald>  /trace
03:53:20 <fog> what?
03:53:31 <maerwald> yes
03:54:00 <fog> your saying it could "break" ?
03:54:29 <maerwald> with `trace` you can see how often something gets evaluated
03:55:15 <maerwald> e.g. whether it's inlined or not (that's why you give NOINLINE to top-level IORefs, which use unafePerformIO)
03:56:03 <maerwald> unsafePerformIO perfoms IO during *evaluation*, when the thing is forced, so you can use it to debug evaluation
03:57:08 <xsperry> no reason to use unsafePerformIO directly, there's debug package for that
03:57:15 <maerwald> yes, trace
03:57:46 <fog> https://pastebin.com/raw/e0GPfYSU
03:57:47 <xsperry> :t traceShow
03:57:48 <lambdabot> error: Variable not in scope: traceShow
03:58:02 <xsperry> Debug.Trace. it is in base
03:58:35 <fog> so i should be able to write (test,test)
03:58:45 <fog> i guess i should make it do an actual calculation though
03:59:58 <dminuoso> Today I finally understood, how x `seq` y not guaranteeing ordering is not just the Haskell report. GHC itself *does* actually reorder in some cases. 
04:01:41 <fog> https://pastebin.com/raw/3CirHvPb
04:01:52 <dminuoso> Mmm, cant find the example anymore. :(
04:10:05 <fog82> it works! https://gist.github.com/fog-hs/9108307d7fae62d32d89fa1a1083efab
04:10:15 <fog82> unless i did something wrong...
04:10:28 <fog82> does that seem to prove the instance bound variables are memoised?
04:10:35 <fog82> or is it just a fluke?
04:12:28 <fog82> ah, this is perfect!
04:12:39 <fog82> so now, i can have branches that are *reused*
04:12:50 <fog82> except, i cant write them into a gadt
04:13:00 <fog82> i have to use the class instances instead of gadt constructors
04:13:12 <fog82> but still, to have memoised branches, that seems worth it
04:14:04 <fog82> i guess i just need to put the *names* at the constructors, and then they should be resolved in a way that does memoisation
04:14:32 <[exa]> fog82: I guess this can be, after much desugaring, derived from the rule that each let binding spawns only one thunk
04:15:07 <fog82> so your saying that instances somehow wrap up a let binding somewhere under the hood?
04:15:11 <fog82> now that i did not knpw
04:15:18 <[exa]> (on each entry of the scope, and many other statement precision improvements)
04:15:52 <fog82> hmmm...
04:16:13 <[exa]> fog82: I am not sure really but the instances get (very roughly) desugared to dictionary functions which are defined using fairly normal let-bindings
04:16:42 <fog82> oh man, that sounds complicated
04:16:44 <[exa]> fog82: try running that through the desugaring and see (IIRC -ddump-core)
04:16:49 <fog82> how am i supposed to do that!?
04:17:25 <fog82> not -ddump-core
04:17:43 <fog82> im not doing that now, i think the use case seems good enough
04:17:47 <fog82> i cant read core anyway
04:18:06 <fog82> but i mean, how am i supposed to "desugare to dictionary functions" !?
04:18:09 <[exa]> Core is almost haskell, but drowned in explicit type applications and annotations... :]
04:18:22 <[exa]> fog82: ghc does that for you internally
04:18:49 <fog82> erm, maybe im not explaining well - my tree binds variables
04:18:50 <[exa]> so your instances becore fairly normal bindings, and normal memoization rules apply
04:19:00 <dminuoso> "dictionary functions" is a bit confusing. I'd rather say "dictionaries"
04:19:03 <fog82> if i want them to be polymorphic, now i have to "desugar dictionaries" !?
04:19:06 <fog82> how does that work?
04:20:07 <fog82> if its "overloading variable names" dont i just have to have some way of having the "Bound" class in the example mention the type at the instance head instead of in the associated type?
04:20:09 <[exa]> fog82: no, you don't desugar anything
04:20:23 <fog82> oh, i was calling it Let
04:20:31 <fog82> class Let (s :: Symbol) where
04:20:32 <fog82>  type TypeOf s 
04:20:32 <fog82>  resolve :: TypeOf s
04:21:00 <fog82> so if i want that to be polymorphic, i have to "overload the variable name", right?
04:21:01 <dminuoso> fog82: it's not desugaring, it's part of the implementation in core.
04:21:06 <[exa]> fog82: actually that doesn't have anything to do with the memoization, in your code the magic happens on line 24 which can get memoized easily, and done.
04:21:46 <fog82> well, the most important thing is that all references to that variable use the first calculation of it
04:21:54 <[exa]> yes
04:22:05 <fog82> it seems not to do the calculation again, so it works as desired
04:22:27 <fog82> dminuoso: i have functions implemented on a tree
04:22:31 <fog82> now i want classes
04:22:59 <fog82> so far all i can do is variable binding and referencing 
04:23:44 <fog82> which is good! except, my AST-like thing is giving some kind of very limited DSL, and i want polymorphism  
04:23:52 <fog82> i think i can get that with something like;
04:25:05 <fog82> class Let (name :: Symbol) (typeOf :: *) where
04:25:05 <fog82>  resolve :: typeOf 
04:25:57 <fog82> though i lose the ability to resolve the type using the associated type, where before it was unique to the name
04:26:27 <fog82> this as a constraint forces that an "instance" is given, instead of just a "let bound" variable
04:27:11 <fog82> so, before i had a way to do this memoisation
04:27:42 <fog82> i thought i would have to fold up the tree (the "implementation") and carry an explicit environment, of variables bound into scope
04:28:09 <fog82> then it would check to see if it had been evaluated already. if not, it would do so and add it to the environment
04:28:26 <fog82> and i guess this "dictionary passing" would be something similar but with instances
04:28:38 <fog82> though its strange since all the instances seem "local"
04:29:00 <fog82> and that then basically, variable binding is just the same as a *unique* local instance...
04:45:10 <dminuoso> Mmm, Im on nixos, and `cabal v2-build --ghc-options=-fno-code` fails on every dependency with errors like 
04:45:18 <dminuoso> /nix/store/hrkc2sf2883l16d5yq3zg0y339kfw4xv-binutils-2.31.1/bin/ar: dist/build/Basement/Imports.o: No such file or directory
04:48:00 <dminuoso> Ohh haha! Of course, that's to be expected I suppose
04:48:03 <dminuoso> Mmm
05:01:19 * hackage libfuse3 0.1.0.0 - A Haskell binding for libfuse-3.x  https://hackage.haskell.org/package/libfuse3-0.1.0.0 (yohashi)
05:12:40 <p0a> Hello 
05:13:17 <p0a> I am trying to follow LearnYouAHaskell and it's the part where it explains Exceptions. I imported System.IO.Error but `catch' is not defined.
05:14:11 <fog82> its kind of an old book, i guess catch is somewhere else now
05:14:22 <fog82> you can find it using hoogle probably, or just regulr google
05:14:24 <dminuoso> p0a: Use Control.Exception
05:14:28 <p0a> oh okay, that is the case then. Control.Exception
05:14:29 <p0a> Got it, thank you 
05:37:02 <blashyrk> Hi, is it possible to write the following:
05:37:04 <blashyrk> lower :: Parser Char lower = sat (\c -> c `elem` ['a'..'z'])
05:37:08 <blashyrk> shorthand somehow
05:37:29 <blashyrk> I tried: `lower == sat(elem ['a'..'z'])` but that doesn't work
05:38:05 <[exa]> basically say `sat $ flip elem ['a'..'z']` or something
05:38:19 <[exa]> but you really want to use isLower from Data.Char
05:38:39 <hpc> sat (`elem` ['a'..'z'])
05:38:48 <[exa]> even better
05:38:54 <hpc> sections of letter-y identifiers need backticks
05:39:32 <hpc> to make it operator-y
05:39:35 <blashyrk> hpc: Thanks! This works becuase wrapping it in backticks like that turns it into an infix func, meaning that the partial func expects the first param, not the second, right?
05:40:36 <[exa]> blashyrk: yeah, easiest way for avoiding flip
05:41:18 <[exa]> :t (<&&>)
05:41:19 <lambdabot> error:
05:41:19 <lambdabot>     â€¢ Variable not in scope: <&&>
05:41:19 <lambdabot>     â€¢ Perhaps you meant one of these:
05:41:32 <merijn> But yeah isLower is much better, because the example breaks on everything non ascii, tbh
05:42:22 <merijn> > 'Ä³' `elem` ['a'..'z']
05:42:24 <lambdabot>  False
05:42:27 <merijn> > isLower 'Ä³'
05:42:29 <lambdabot>  True
05:43:03 <blashyrk> Thanks everyone
05:43:35 <[exa]> I originally wanted to avoid traversing 26 letters the list before saying 'no', but this is even better reason :]
05:45:06 <p0a> I tried using hoogle for the first time and I got this error: https://termbin.com/xkrj
05:45:06 <p0a>  
05:45:10 <monochrom> This is why in old DOS games when I look into their exes with a hex editor they always have ABCD...Z and abce...z
05:45:46 <[exa]> monochrom: btw try hexdumping a .doc file
05:46:11 <tomsmeding> p0a: https://hoogle.haskell.org/
05:47:12 <merijn> tomsmeding: That's not really a replacement for local hoogle, though :p
05:48:12 <tomsmeding> fair; then we'd need the stack.yaml to be able to say anything sensible about that error :p
05:48:38 <p0a> Suppose I want to know which exceptions readFile throws. How can I find that out?
05:49:00 <p0a> tomsmeding: okay, got it. I did not realize that hoogle was part of my project
05:49:16 <p0a> (but it is part of stack so that makes sense)
05:50:07 <p0a> right now the only exception I catch is isDoesNotExistError
05:50:24 <tomsmeding> regarding knowing what exceptions an existing function throws: there's no way to know except digging through the base source code
05:50:35 <tomsmeding> (if it's not documented, which in this case it doesn't seem to be)
05:51:01 <monochrom> The doc of readFile is the best place to look. If it doesn't tell, maybe you dig into source code, but that's it.
05:51:30 <p0a> Ok I guess I'm used to C where all the IO errors are documented 
05:51:42 <merijn> p0a: hah
05:51:43 <p0a> but in any case I suppose these functions are for newbs and not really used in production 
05:51:44 <tomsmeding> except when they aren't
05:51:46 <merijn> I wish >.>
05:51:48 <monochrom> However, for System.IO stuff, it's kind of common knowledge that you anticipate IOError.
05:51:52 <merijn> p0a: hah
05:51:58 <merijn> p0a: You wish ;)
05:52:04 <p0a> lol
05:52:12 <tomsmeding> $ man 2 read [...] "Other errors may occur, depending on the object connected to fd."
05:52:26 <kuribas> Is it just me, or is cassava a pretty bad library?  Like why does it return a vector, instead of a list?
05:52:50 <merijn> p0a: More realistically, either it's an error you know to handle or it isn't, and in the latter case you need a "graceful" handler anyway, so it's fine
05:52:50 <hyperisco> wouldn't it be wild if there were standards for production code
05:53:07 <merijn> hyperisco: Who'd replace the existing infrastructure? :p
05:53:09 <kuribas> decode :: FromRecord a => HasHeader -> ByteString -> Either String (Vector a)
05:53:10 <monochrom> cassava is a good library. I think I can make it return a list.
05:53:23 <monochrom> Err oh, that.
05:53:35 <merijn> kuribas: Because lists are bad for returning long sequences?
05:53:39 <hyperisco> merijn, the truckers I guess. It is a new jobs program!
05:53:47 <kuribas> merijn: are you being ironic?
05:53:50 <merijn> kuribas: No
05:54:08 <merijn> kuribas: There's CSV files with thousands of columns out there
05:54:19 <merijn> kuribas: Indexing them (which is very common) would be super bad with lists
05:54:27 <monochrom> Well this one is rows but yeah
05:54:36 <kuribas> merijn: ah, for indexing then...
05:54:46 <monochrom> Also list takes more space
05:55:02 <maerwald> monochrom: tapioca is better
05:55:03 <monochrom> n elements takes 24n bytes and that's just the cons cells.
05:55:03 <kuribas> monochrom: but to read it, it first has to make a list right?
05:55:13 <merijn> kuribas: Why?
05:55:31 <kuribas> merijn: it has to parse the input...
05:55:42 <merijn> kuribas: What does that have to do with lists?
05:55:44 <kuribas> and the list could even be eliminated by fusion
05:56:04 <monochrom> thanks maerwald
05:56:07 <kuribas> merijn: it needs to parse the whole thing to know the length of the vector
05:56:18 <monochrom> You lost me.
05:56:20 <merijn> kuribas: Which part of that involves lists, though?
05:56:20 <p0a> tomsmeding: not familiar with low-level programming. I have read once an article about the intricacies of IO in critical software. Perhaps the only way to be sure is to 'dig in' the source code, and in that case it would mean to be familiar with the OS/kernel used
05:56:39 <merijn> kuribas: Also, why? You can just append to vectors if you misjudge the size
05:56:52 <tomsmeding> p0a: from your claim that in C all IO errors are documented, I assumed you were talking about low-level IO functions :p
05:57:00 <merijn> p0a: Yeah, people write all sorts of stuff :p
05:57:09 <tomsmeding> though they are generally more documented in C than in haskell, I guess
05:57:50 <monochrom> I can't say yes, I can't say no, but do you know this from reading cassava source code or even attoparsec source code? Or did you speculate?
05:58:02 <merijn> p0a: But then you get a real job and the 3rd party company running digital gift cards for your store (and 3 other national chains) has their database server crash and loses 2 weeks worth of gift card data since apparently "backing up production database storing finances" isn't something people do :)
05:58:07 <kuribas> merijn: return $! V.fromList vals
05:58:13 <kuribas> merijn: (from the source)
05:58:29 <Orbstheorem> Hi, can I call a default class method from an instance?
05:58:48 <dminuoso> tomsmeding: Exceptions suffer from extremely poor documentation. Partially because of lazyness, and partially because people rarely catch exceptions sensibly.
05:58:48 <monochrom> How is val constructed?
05:58:53 <dminuoso> Orbstheorem: Sure.
05:59:05 <Orbstheorem> dminuoso: do I use the same symbol name?
05:59:07 <merijn> Orbstheorem: You mean the default implementation in the class from your instance?
05:59:12 <Orbstheorem> Yes
05:59:12 <dminuoso> Orbstheorem: Yes. 
05:59:22 <dminuoso> Orbstheorem: Use it as if you had defined it yourself with that definition.
05:59:25 <monochrom> List fusion may happen.
05:59:27 <Orbstheorem> Hum, I thought it'd do an infinite loop...
05:59:40 <merijn> Orbstheorem: If the default method calls the method you're implementing, then yes
05:59:49 <kuribas> monochrom: it has also a problem with simply crashing with an error on bad input
05:59:52 <merijn> Orbstheorem: See, for example, the default implementation of == and /= in Eq
05:59:53 <monochrom> But even if not, random access is a good enough reason
05:59:55 <Orbstheorem> merijn: The other way around. The default method is bottom.
06:00:09 <kuribas> monochrom: not using an error monad, or a custom exception.
06:00:12 * dminuoso wonders why you'd default to bottom
06:00:26 <monochrom> I never got that. I got Left.
06:00:29 <dminuoso> That sounds like a counter example for a default implementation.
06:00:32 <Orbstheorem> Not that bottom, I mean, the real implementation ><"
06:00:38 <p0a> tomsmeding: I meant C99, but POSIX is fine too. https://pubs.opengroup.org/onlinepubs/009695399/functions/read.html seems to describe all errors
06:00:41 <dminuoso> Orbstheorem: ah. the order is irrelevant.
06:00:51 <maralorn> dminuoso: It's interesting how so many Haskell problems come down to lazyness â€¦
06:00:58 <Orbstheorem> My instance method is just providing context the default method requires.
06:01:01 <dminuoso> maralorn: I dont see lazyness as a problem at all.
06:01:02 <merijn> p0a: And no OS has ever added extra errors on top of that...*looks angrily at linux*
06:01:18 <tomsmeding> p0a: fair point, the standards are better-specified than the implementations
06:01:33 <merijn> maralorn: This is orthogonal to laziness
06:01:35 <p0a> merijn: yeah I agree, which is why I am asserting my noobness and unfamiliarity with the subject 
06:01:48 <merijn> I'm 100% convinced we can have proper, checked exceptions *and* laziness just fine
06:02:02 <merijn> But so far, no one will pay me to make a prototype, so :p
06:02:09 <dminuoso> Ohh
06:02:11 <dminuoso> 15:00:29      maralorn | dminuoso: It's interesting how so many Haskell problems come down to lazyness â€¦
06:02:14 <dminuoso> Haha
06:02:18 <dminuoso> Okay, I see what you did there.
06:02:22 <maralorn> dminuoso: merijn: You said "Exceptions suffer from extremely poor documentation. Partially because of lazyness."
06:02:24 <dminuoso> Yeah
06:02:30 <dminuoso> Took me just a moment to get the joke
06:02:42 <dminuoso> It was a bad timing since we were just talking about circular definitions, it seemed to be related
06:02:52 <nij> Could someone familiar with cabal help me out?
06:02:55 <monochrom> I guess every problem can be attributed to laziness.
06:02:58 <p0a> merijn: also, wow @ the comment about not backing up crucial databases
06:03:15 <maralorn> But I mean, it kinda makes sense to write documentation lazily and only do the work when someone forces that chunk?^^
06:03:31 <merijn> p0a: You have no idea how much infrastructure of the world is like that :p
06:03:36 <monochrom> Usually I force my own chunks.
06:03:42 <dminuoso> Anyhow. Invisible exceptions are one of my major annoyances with Haskell. Every now and then I have odd failures because I get exceptions I didn't know about.
06:03:42 <tomsmeding> nij: don't ask to ask, just ask, in general :)
06:03:46 <monochrom> I like to read my own writing.
06:04:04 <monochrom> Marvel at my beautiful explanation.
06:04:17 <monochrom> Narcissim cures laziness.
06:04:41 <merijn> monochrom: Clearly it doesn't
06:04:42 <kuribas> foldMap associates to the right, no?
06:04:47 <merijn> I still don't write docs
06:04:47 <nij> tomsmeding: thanks.. 
06:04:54 <merijn> kuribas: Mu
06:04:56 <nij> I'm building something by editting my older code
06:05:00 <maralorn> Dunno, I feel like I have a lot of both.^^
06:05:12 <nij> But seems that base has upgraded and my cabal system didn't response well. Error here :( https://dpaste.com/F9L69LNS8
06:05:18 <tomsmeding> kuribas: it should not matter right, because Monoids should be associative?
06:05:19 <dminuoso> p0a: The larger your datacenter is, the less you tend to backup. Honestly, most idealistic people seem to come from academica or they just take pleasure in writing fun code but don't have to ever deploy it.
06:05:19 <nij> Even Prelude was not correctly loaded.
06:05:31 <kuribas> tomsmeding: right, but it matters for performance
06:05:44 <dminuoso> Doing a deployment right tends to be incredibly time consuming in so many ways
06:05:46 <merijn> dminuoso: lol, academia and good code
06:05:53 <kuribas> tomsmeding: and also because a monoid instance could be not lawful
06:06:02 <merijn> nij: Do you use Nix?
06:06:05 <dminuoso> merijn: I did not put those together!
06:06:08 <merijn> nij: Eh, arch, I meant
06:06:18 * tomsmeding was already typing the arch question
06:06:19 <kuribas> > foldMap (:[]) [a, b, c, d]
06:06:21 <lambdabot>  [a,b,c,d]
06:06:26 <nij> merijn: I'm on archlinux yes.
06:06:39 <tomsmeding> have you installed ghc via pacman? if so, don't :p
06:06:42 <merijn> nij: ANd you probably installed GHC using the arch package manager?
06:06:48 <merijn> tomsmeding: It's always arch
06:06:50 <p0a> dminuoso: depends who we're talking about. Doesn't google backup?
06:06:52 <nij> tomsmeding: No, I didn't do that
06:07:13 <nij> I did `cabal build` in my cabal project
06:07:16 <tomsmeding> $ pacman -Qi ghc
06:07:16 <dminuoso> p0a: Google. A company with nearly a million servers, tens of thousands of services..
06:07:18 <tomsmeding> does that give anything?
06:07:21 <p0a> dminuoso: or maybe google takes the extra step to ensure that there is no need for backup in the first place? I don't know.
06:07:23 <merijn> nij: How did you install GHC?
06:07:34 <nij> merijn: I have two versions of GHC on my computer
06:07:42 <nij> one is called by ghc directly
06:07:54 <nij> so whereis ghc gives /usr/bin/ghc
06:07:56 <merijn> nij: $20 says one of them is from pacman, and that that one is the one you're using
06:08:00 <dminuoso> p0a: Well google has grown to a size that they have developed entire eco systems to manage their inefficient fleet of badly written software.
06:08:08 <merijn> nij: Because pacman installs a broken GHC
06:08:24 <tomsmeding> (at least, we at #haskell consider it broken, and we're not alone)
06:08:27 <nij> merijn: I think soo.. but I think when I use `cabal build`, it refers to another GHC
06:08:32 <merijn> tomsmeding: Every sensible person does
06:08:36 <dminuoso> p0a: (Im talking about Kubernetes here)
06:09:05 <merijn> tomsmeding: If you install software that fails with cryptic errors in its default use, then you're installing broken software
06:09:06 <p0a> dminuoso: the point being that I don't believe you when you say that size alone dictates whether one backups or not
06:09:18 <nij> so whereis cabal gives: ~/.ghcup/bin/cabal
06:09:29 <tomsmeding> what does 'pacman -Qi ghc' give?
06:09:32 <merijn> nij: cabal just uses whichever ghc is on your path
06:09:34 <dminuoso> p0a: Im just saying, the larger you become, the more effort it takes you properly back up your services and deployments.
06:09:36 <monochrom> nij: https://wiki.archlinux.org/index.php/Haskell#Problems_with_linking
06:09:43 <merijn> nij: If /usr/bin/ghc is on your path, it will use that
06:10:08 <dminuoso> p0a: Especially because you cant afford to just "make it someone elses problem" by stuffing into say AWS.
06:10:14 <maerwald> they're on archlinux, so: don't use system GHC
06:10:25 <nij> pacman -Qi ghc does give something
06:10:26 <nij> oh
06:10:30 <nij> lemme remove it
06:10:36 <kuribas> merijn, tomsmeding: it looks like foldMap uses a right fold, but it's strange the documentation doesn't mention it.
06:10:45 <nij> oh I see why it breaks
06:10:46 <tomsmeding> kuribas: agreed
06:10:50 <nij> I installed xmonad yesterday
06:10:55 <nij> and that grabs ghc automatically
06:10:58 <nij> what should I do now
06:10:58 <p0a> dminuoso: and like any other business decision you weight the pros and cons, if 2 weeks worth of data is less than the cost of regular backups :P...
06:11:01 <nij> I <3 xmonad
06:11:05 <merijn> kuribas: It's instance specific
06:11:09 <yushyin> nij: check your PATH and make sure that the ~/.ghcup/bin is before the system path
06:11:11 <nij> If I remove ghc xmonad will cry
06:11:14 <merijn> kuribas: So the documentation can't really say
06:11:22 <dminuoso> p0a: Backups are not that easy. 
06:11:24 <nij> yushyin: nice idea
06:11:25 <tomsmeding> RT yushyin 
06:11:30 <kuribas> merijn: ah right, it can be overloaded
06:12:06 <yushyin> nij: you will also need to install a ghc via ghcup of course
06:12:07 <merijn> containers, for example, guarantees that Foldable/Traversable are in key (or element, for sets) order
06:12:13 <dminuoso> p0a: For instance: How do you even backup your data? Can you do block-based backup? File-based? Maybe you need to snapshot data? How do you do that atomically? What about consistency across multiple systems? And how do you even get backups back into your system?
06:12:30 <dminuoso> How do you sensibly manage it? And how do you separate the backup *properly* so a rampaging `rm -rf /` doesnt take backups with it?
06:12:44 <p0a> so for example, in https://hackage.haskell.org/package/base-4.14.0.0/docs/src/GHC.IO.Handle.Text.html#lazyRead what are the exceptions to handle?
06:12:44 <dminuoso> How do you do retention? How can you still comply with GPDR with backups?
06:12:50 <dminuoso> It's a real hell to do backups
06:12:50 <merijn> a backup on the same machine (or even same building) is not a backup
06:12:58 <p0a> do I correctly read here that IllegalOperation can occur for more than one reason, for example?
06:13:22 <merijn> p0a: Well, can you recover from errors?
06:13:42 <dminuoso> Backup as a general concept is easy. Once it's a requirement, it's really tough to do right in a way that it's valuable
06:13:47 <merijn> like, if read fails can your code even do anything?
06:14:05 <p0a> merijn: no I'm just trying to get a sense of exceptions
06:14:10 <p0a> it's test code 
06:14:12 <nij> OK guys lemme re-log in my account and see if anything changes after my PATH is changed
06:14:16 <nij> Thank you :) ttyl
06:15:01 <merijn> p0a: Right, so the usual solution is to just let any unknown exception crash and write your code in such a way that it's always safe to crash (by, for example, using bracket for resource allocation/deallocation)
06:15:33 <p0a> dminuoso: my backups, I typically rescue ~/ and then save it in a backup-[date]. :P
06:15:45 <p0a> dminuoso: I have a few of those directories... :P it's a mess but it works 
06:15:55 <dminuoso> Oh you're just talking about your personal laptop?
06:16:02 <p0a> Don't even bother telling me why that is not a solution for a business :P 
06:16:18 <p0a> merijn: alright
06:16:52 <dminuoso> Heh, I have a thumbdrive and some cloud storage with my /etc/nixos/configuration.nix + imports on it, and that's enough!
06:17:01 <dminuoso> Can recreate my developer machine with just a simple `nixos-rebuild switch` :p
06:17:09 <merijn> p0a: Are you familiar with C++'s RAII?
06:17:13 <nij> It seems building! Thank you guys :D
06:17:33 <nij> So pacman's ghc is broken. What if I need xmonad and pandoc.. etc?
06:17:41 <nij> If I want to be fully on cabal, what should I do?
06:17:57 <Philonous> merijn, I don't think you can sensibly make blanket statements like "a backup that's not isolated by at least X is not a backup". It really depends on your risk model. If the most likely threat is data corruption because your WAL implementation is broken then having a backup on the same machine is valuable. (Obviously it won't protect you against the machine catching fire, but that's not what it was designed to do)
06:18:08 <p0a> merijn: okay
06:18:11 <maerwald> nij: pandoc and xmonad should be buildable from their respective git repositories even
06:18:19 <p0a> merijn: I mean, yes, I am
06:18:37 <dminuoso> Philonous: Indeed. A backup is always against a risk model, that's a valuable point you're making.
06:18:46 <nij> maerwald: would you suggest that I avoid any pacman packages that are haskell-related?
06:18:50 <merijn> p0a: bracket kinda encodes that pattern
06:18:50 <maerwald> yes
06:18:52 <merijn> :t bracket
06:18:53 <lambdabot> IO a -> (a -> IO b) -> (a -> IO c) -> IO c
06:18:57 <dminuoso> We have same-machine backups, same-storage backups, cross-datacenter backups, and off-site backups.
06:19:13 <tomsmeding> nij: $ cabal install xmonad  # and then have a coffee/drink/etc
06:19:14 <maerwald> this might be difficult with pandoc, since it can be a dependency by another package
06:19:16 <blashyrk> Did anyone get Hoogle to work with intellij-haskell? I've updated build tools and ran Haskell->(Re)Build Hoogle Database finishes successfully, but I still just get `No documentation available as Hoogle (database) isn't available`
06:19:18 <dminuoso> off-site we'd put only the most crucial data of all that we need to operate our core network between our data centers 
06:19:29 <merijn> p0a: First action allocates a resource, second action frees it, third actually does something. Bracket then guarantees that the cleanup gets called even if there is an exception
06:19:31 <tomsmeding> and also perhaps buy an additional harddrive
06:19:49 <p0a> merijn: nice, thank you 
06:20:14 <dminuoso> p0a: By the way, resource cleanup is a subtly complicated topic in Haskell because of the presence of asynchronous exceptions.
06:20:42 <nij> tomsmeding: will that pollute my pacman system?
06:20:59 <tomsmeding> nij: given that it will only install stuff in ~/.cabal, no it won't
06:21:03 <dminuoso> So at any point in time, even when you don't expect it, an async exception can be triggered. It's best to design your code such that it safely releases resources in that assumption.
06:21:19 <nij> tomsmeding: neat
06:21:39 <tomsmeding> though if you build a program that way, say pandoc, that other packages depend on, they now suddenly use your compiled version of pandoc instead of the one from the repositories
06:21:39 <nij> tomsmeding: what if more and more pacman packages start relying on haskell dependencies one day
06:21:48 <tomsmeding> that may or may not break if the versions are different
06:21:50 <nij> tahat day might not come .. but just being curious
06:21:54 <dminuoso> And then you have hidden land mines like, even if async exceptions are masked you can *still* get interrupted when calling interrutable code.
06:21:56 <tomsmeding> Â¯\_(ãƒ„)_/Â¯
06:22:07 <nij> oh :(
06:22:18 <tomsmeding> perhaps other people have better ideas about that
06:22:20 <nij> Why is ghc in pacman so broken :((
06:22:30 <nij> tomsmeding: maybe move to nixoS ;) ?
06:22:40 <phadej> because arch maintainers are stubborn :)
06:22:45 <monochrom> Humans are broken.
06:22:45 <merijn> nij: Because Arch maintainers are stubborn and broke it on purpose
06:22:46 <tomsmeding> because arch decided to dynamic-link everything relating to haskell, whereas the haskell ecosystem generally expects static linking
06:22:56 <phadej> merijn... and clearly ar not on this channel
06:23:05 <merijn> phadej: They know
06:23:11 <nij> monochrom: xD
06:23:22 <tomsmeding> technically you could make stuff work with arch's model, if you recompile everything when you upgrade ghc, and if you add -dynamic to everything everywhere
06:23:23 <phadej> merijn: the topic is however recurrent on this channel
06:23:28 <nij> tomsmeding: that makes the outcomes skinnier
06:23:31 <tomsmeding> that flag is the killer because cabal nor stack do that
06:23:37 <tomsmeding> it does
06:23:37 <nij> may be they know a way to work around 
06:23:47 <dminuoso> merijn: to be fair, its no different from their perspective. stubborn haskellers who insist on static linking!
06:23:47 <merijn> phadej: There was a thread on the arch reddit about "what do you hate most about arch?" and there were 100s/1000s of non-haskell users complaining about Arch's haskell packaging
06:23:53 <p0a> dminuoso: I'll read about asynchronous exceptions
06:24:01 <phadej> merijn: oh
06:24:09 <phadej> merijn: that's quite stubborn on arch side
06:24:20 <merijn> phadej: Pandoc has >150 pacman dependencies
06:24:27 <merijn> phadej: That all update each time
06:24:31 <monochrom> I respect taking a stance on which linking to prefer.
06:24:47 <monochrom> What I disrespect is inconsistency and incompletion.
06:24:53 <merijn> monochrom: Then they should patch ghc/cabal/etc. to default to the linking type
06:24:59 <tomsmeding> arch has a package 'ghc-static' which is supposed to fix things, but in reality stuff still doesn't really work well
06:25:16 <monochrom> Yes, merijn.
06:25:28 <dminuoso> Speaking of static linking, fully statically linked binaries with ghc cant be produced on many machines, since most run on glibc.
06:25:33 <phadej> yes, IMO arch maintainers should participate in fixing things in cabal/ghc... if it doesn't work in the way they want it work
06:25:46 <phadej> dminuoso: don't mix linking of c and hs dependencies
06:25:51 <tomsmeding> dminuoso: pain all the way down
06:25:55 <monochrom> Every other linux distros patch upstream source code and config files to fit its mantra.
06:26:17 <dminuoso> phadej: I know. Im just saying that the haskell mindmodel is usually "statically link hs, dynamically link c"
06:26:21 <maerwald> phadej: that would be actual work :)
06:26:28 <monochrom> debian patches GHC to find its package database in /var. (upstream is /usr)
06:26:37 <merijn> nij: in a nutshell, Arch maintainers think everything should be linked dynamically (debatable, but lets accept that for now), so they *only* install the dynamic libs of GHC/base/etc. however, the default link mode of GHC/cabal/etc. is static, so unless you change the default things fail if the static libs are not installed
06:26:44 <monochrom> This is not rocket science. This is not even heresy.
06:27:21 <nij> merijn: :(
06:27:28 <phadej> with GHC dynamic hs linkage is so space wasteful
06:27:32 <maerwald> now the work is on the users to pick up the pieces... so someone writes an archwiki article about how to work around this mess and no one cares anymore
06:27:49 <phadej> I wouldn't be surprised if pandoc + dependencies is close to gigabyte of object size
06:27:51 <merijn> nij: Which is what your error was saying "I can't find this module in package base!" (which is because the package is installed, but the static version it's looking for isn't)
06:28:21 <nij> "the dynamic version it's looking for" you mean?
06:28:42 <merijn> nij: No, cabal/ghc look for static by default, but arch only installs dynamic
06:28:48 <nij> I see
06:28:55 <dminuoso> p0a: https://www.fpcomplete.com/haskell/tutorial/exceptions/ <- this is decent read
06:29:04 <merijn> phadej: Who cares about pragmatic benefits when you can have ideological purity instead?
06:29:18 <phadej> merijn: not nix people ;)
06:29:40 <merijn> Nix makes me sad
06:29:40 <phadej> or some Haskellers too
06:29:46 <phadej> not uncommon stance
06:29:48 <monochrom> Any ideology that is not removed from reality by X is not an ideology. >:)
06:29:53 <merijn> It sounds like such a great idea *on paper*
06:30:04 <dminuoso> p0a: It also outlines how base comes with mechanisms fpco considers not well designed in the presence of async exceptions. (I always use unliftio's exception facilities for that reason)
06:30:04 <merijn> The execution is just so...meh
06:30:28 <merijn> the lack of checked exceptions is a travesty
06:30:31 <phadej> it (nixpkgs) is now simply too big
06:30:53 <dminuoso> There's this established practice of "you should never recover from an async exception"
06:30:56 <phadej> kind-a "too large to fail"
06:31:35 <p0a> dminuoso: but I suppose you are against that practice, right? If I follow correctly 
06:31:39 <justsomeguy> merijn: What makes nix meh?
06:32:13 <monochrom> merijn means archlinux dynamic linking, not nix.
06:32:32 <justsomeguy> Oh, my mistake.
06:32:59 <dminuoso> p0a: No, I share that practice. Usually async exceptions occur because someone wants our thread to be shut down, so exception primitives should, by design, not allow you to recover from async exceptions.
06:33:18 <dminuoso> p0a: Or to rephrase it: primitives that recover from exceptions should ignore async exceptions.
06:33:21 <merijn> monochrom: I meant nix was meh 
06:33:29 <monochrom> Oops sorry
06:33:49 <merijn> justsomeguy: Shitty ill-specified DSL (without types, even!) and incredibly poor documentation.
06:34:03 <dminuoso> You can still do it if you want, if there's some need for it. But the default behavior should be "never recover from async exceptions"
06:34:03 <phadej> rolling update linux distribution can be considered "meh" as well
06:34:06 * monochrom now tries to design a cryptographic function that maps "nix" to "meh".
06:34:13 <merijn> justsomeguy: Everyone is super helpful, but answering questions with "here's cryptic code solving your problem" is not...helpful
06:34:30 <merijn> phadej: linux in general can be considered meh ;)
06:34:36 <dminuoso> (And sadly Control.Exception will recover from async exceptions unless you explicitly write code not to)
06:34:44 <merijn> monochrom: I have stronger opinions than "meh"  about arch :p
06:34:59 <phadej> merijn: linux comes in many flavors
06:35:01 <Philonous> I like nix-the-system. Nix-the-language on the other hand is pretty bad. It gives you too much power to abstract with too little in terms of formal methods to keep the abstractions under controll. The result is a huge tangly pile of spaghetti.
06:35:16 <p0a> dminuoso: got it. I will read the article, it already mentions what you said 
06:35:19 <phadej> I do believe that not nixpkgs nix-thing could be great. It just don't exist
06:35:28 <monochrom> Programmers like to hack around.
06:35:47 <merijn> monochrom: I move that we ban programmers from programming >.>
06:35:52 <monochrom> You have a solid solution, they call it academic.
06:36:14 <merijn> monochrom: No admittance to programming tools until you've made a compiler and bought into formal methods and theory!
06:36:16 <Chousuke> Arch worked decently for me, but what drove me away was their kernel package not being upgradable without an immediate reboot. Many things would just break because your running kernel no longer had its modules on the system after an upgrade. :P
06:36:18 <phadej> debian stuff is "dynamic" as well, it's all own formats and python
06:36:20 <phadej> works ok.
06:38:38 <Philonous> merijn, I pose that programmers with insufficient understanding of formal methods writing their own compilers is the root of many evils. That's how Nix (the language) was born. And PHP. 
06:39:17 <dminuoso> Philonous: Weirdly, I think the main problems with nix are just of documentation nature and lack of a type system. The more I work with nix, the more Im fine with most of the stuff, it's just incredibly frustrating to constantly read through half a dozen nix files to get an idea what facilities are availalbe, and what they do.. and what they expect in terms of arguments.
06:39:46 <monochrom> PHP inventor was proud of not having learned language design. In the same way people are proud to say "I suck at math".
06:39:52 <monochrom> And it shows.
06:40:17 <dminuoso> monochrom: wasn't it that the php inventor actually told people not to use his language because he had no language design background?
06:40:26 <monochrom> And the networking effect shows, too. Contributed libraries are full of semantic inconsistencies.
06:40:36 <dminuoso> Think it was just some invention for him to display his CV?
06:40:37 <phadej> I'm quite sure that Eelco Dolstra knows the formal methods
06:40:50 <hc> dminuoso: exactly my experience with nix :)
06:40:56 <phadej> it's rude to compare him with "I suck at math" people
06:41:15 <monochrom> No I am not talking about Eelco Dolstra
06:41:39 <justsomeguy> How could I go about learning formal methods, anyways? I'm interested in it, but don't even really understand what it entails. Would a CS degree program introduce me to that stuff in a computability/theory class?
06:41:50 <dminuoso> justsomeguy: read books and papers?
06:41:52 <monochrom> Rasmus Lerdorf
06:42:14 <merijn> justsomeguy: Lucky you!
06:42:25 <monochrom> He said PHP is practical because he didn't learn language design academia stuff.
06:42:29 <maerwald> wasn't the goal of PHP to have a language for non-programmers? And didn't it quite succeed? *chuckle*
06:42:32 <merijn> justsomeguy: Some people wrote an entire multi-book course on formal methods for software design and made it free :)
06:42:35 <merijn> justsomeguy: https://softwarefoundations.cis.upenn.edu/
06:43:05 <phadej> monochrom: I was referring to Philonous' comment
06:43:09 <monochrom> He's a great sysadmin at my university. I respect that part. But for the PHP part, I stand by comparing with "I such at math".
06:43:19 <monochrom> Oh OK sorry!
06:43:57 <merijn> maerwald: No, the goal of PHP was "Rasmus Lerdorf wanted to make writing his own websites (and for clients) easier"
06:44:11 <merijn> maerwald: There was no external design/goal beyond "what makes things easier for me"
06:44:11 <maerwald> Philonous: could you elaborate on the nix part? I'm not sure I can follow why it's bad due to lack of formal methods design. I believed it to be "just" an ergonomics issue
06:44:16 <phadej> "personal home pages" :)
06:44:22 <Philonous> phadej, I didn't make that comparison. My point was that nix lacks formal methods (static types, or anything else) to keep the abstraction under control. 
06:44:27 <dminuoso> phadej: If I recall, his thesis was actually the first moment nix things started to make some sense to me. Perhaps it's important to realize that nix doesn't cater to the kind of formalism that Haskellers appreciate, because nix is about a different set of problems.
06:44:56 <maerwald> Philonous: wasn't that a design choice?
06:45:30 <phadej> ... and designing a type system which is convenient enough to be useful for nixpkgs-like usage and scale is worth another PhD too
06:46:09 <phadej> first there were lisp and only later ML
06:46:29 <Chousuke> This discussion is making me want to rant about Ansible and YAML-derived programming languages. :P
06:46:46 <phadej> yes, those are terrible
06:46:55 <phadej> people use what they know about
06:46:57 <dminuoso> Ansible is just Python in YAML syntax for maximum discomfort. Fight me.
06:47:02 <monochrom> Oh I think both PHP and Perl (look at all those languages from sysadmins) are very successful at bringing programming to non-programmers.
06:47:24 <Chousuke> dminuoso: pretty much. I wish it had even some basic lints though.
06:47:25 <monochrom> In the sense that we don't consider their users programmers anymore.
06:47:27 <maralorn> I love misassociating messages here: "Humanes are broken ... and clearly are not on this channel"
06:47:53 <maralorn> Ah, that might not be as funny as I thought, since it came from ancient backlog â€¦
06:48:06 <Chousuke> dminuoso: I die a bit inside every time I run a large playbook and it explodes after doing half of what it's supposed to a typoed variable.
06:48:44 <phadej> nix can explode due typoed variable as well :)
06:48:52 <maerwald> dminuoso: deployment is a boring and unreliable thing... nixops doesn't solve it, because the main issues lie elsewhere (puppet kinda gets it), ansible isn't that bad though
06:48:55 <phadej> it however recovers a lot better :)
06:49:14 <Chousuke> these are things that have been solved for a long time, and still we keep using tools that suck :(
06:50:07 <phadej> Aren't people just create AWS AMIs with some(tm) method and spawn machines based on that (to run some docker containers...)
06:50:20 <monochrom> I am now proud that when I designed my toy language for my students to write an interpreter for...
06:50:51 <Chousuke> oh, containers! Today I had to debug a container that didn't let me start it because it was already running, but I couldn't delete it either because it didn't exist.
06:50:53 <monochrom> I had the choice of "take it easy, if a var is uninit before use, default it to 0 or something"
06:51:23 <monochrom> vs "if a var is uninit, it is uninit, reading it is an error. this is going to be inconvenient and more work"
06:51:35 <Chousuke> in the end it turned out that an apache reverse-proxy was keeping its overlay mount alive somehow (no idea how) and after restarting apache I could restart my container
06:51:55 <Chousuke> said mount of course was invisible in another mount namespace. I found it by grepping proc
06:51:57 <monochrom> I'm now proud I took the harder, proper way, after hearing from you about how a typoed var explodes.
06:52:23 <dminuoso> phadej: nix just gives me infinite recursion with illegible stack traces every day or so. :p
06:52:39 <dminuoso> so Im not convinced about "recover a lot better"
06:52:40 <Rembane> monochrom: Your design decision makes me happy. 
06:53:01 <phadej> dminuoso: if it fails to build something it doesn't leave the system state in a dirty state
06:53:10 <dminuoso> oh yeah that's fair
06:53:53 <phadej> and fwiw, using mfix in Haskell can lead to the very samilar "no idea what went wrong" errors / non-termination
06:54:07 <monochrom> If it goes into infinite recursion, does that count as failing to build?
06:54:17 <Chousuke> monochrom: I don't really mind if you could opt-in to undefined variables by defining a default value or something, but in ansible they're actually opt-out. You get some kind of safety if you use {{ variable | mandatory }} ...
06:54:32 <monochrom> Or does that count as doesn't leave system in dirty state, because the system is in no state at all? >:)
06:54:35 <phadej> its just that mfix isn't used that much in Haskell (especially for at as long distance as in nixpkgs)
06:54:58 <jophish> What's the process of taking over an abandoned package on Hackage?
06:54:59 <phadej> maybe there is better way to add local modifications
06:55:15 <jophish> Is it still to send an email to carter? :)
06:55:24 <phadej> jophish: https://wiki.haskell.org/Taking_over_a_package
06:55:27 <dminuoso> Are you comparing mfix to the (over)usage of overlays?
06:55:53 <phadej> dminuoso: to using `rec` in Nix-language
06:55:56 <carter> jophish: me?
06:56:18 <jophish> carter https://mail.haskell.org/pipermail/haskell-cafe/2014-January/112471.html :D
06:57:04 <jophish> phadej: thanks, I guess I better make a post
06:57:26 <jophish> The problem is I don't *really* want to maintain this package (language-c). I just have a stack of PRs against it which fix some important bugs
06:57:28 <maralorn> dminuoso: I think the overusage of overlays is kinda negiigable to the fact the nixpkgs itself is calculating on giant fix point.
06:57:30 <dminuoso> phadej: wouldn't fix be better to compare to then?
06:57:43 <jophish> emailed the maintainer in May, but no response
06:58:04 <phadej> dminuoso: nix is kind-a in some explicit magic monad, which allows you to define derivations.
06:58:12 <maralorn> But it's morally the same issue.
06:58:24 <dminuoso> Mmm. That's an interesting perspective, hadn't considered that
06:59:16 <maralorn> phadej: dminuoso : The is an implementation of something like multiplayer tetris via using this monad for IPC â€¦
06:59:31 <maralorn> I think it was tetris, might be a slightly simpler game.
06:59:52 <dminuoso> Some people just have too much spare time on their hands.
06:59:58 <phadej> jophish: heh, that's the problem with OSS "I want my patches in, but then forget about them, and leave the thing for some else to maintain"
07:00:15 <maralorn> But the nix processes communicate by creating or not creating store paths.
07:00:29 <jophish> well, FWIW I'd be willing to maintain my patches :)
07:01:13 <jophish> phadej: It's also the success of OSS that strangers are happy to make drive-by fixes to one's code 
07:01:36 <phadej> but https://github.com/visq has no activity this year, so I don't think there is an option else then taking over
07:01:55 <phadej> either way (taking over or no) one will suffer
07:03:12 <phadej> jophish: I have mixing feelings about *non-trivial* drive-by contributions
07:03:24 <phadej> fixing typos in documentation is very nice
07:03:38 <phadej> rewriting half of a library, ... tricky
07:08:26 <merijn> jophish: tbh, if it's already abandonned "maintaining" could just be "make sure you bump the version every now and then and maybe comment on PRs" not necessarily "actively develop this further"
07:08:40 <merijn> jophish: Which sounds like something you'd wanna do anyway if you actually use/rely on this
07:09:01 <phadej> indeed
07:09:09 <phadej> maintenance /= active development
07:10:14 <dminuoso> Plus, you can always put up a header that you're looking for someone to take over active maintenance.
07:10:36 <dminuoso> Some low effort maintenance is surely better than none. :)
07:12:29 <jophish> yeah, probably worthwhile then :)
07:13:39 <carter> Is language c the repo I helped migrate from Darcs to git ?
07:16:55 <dminuoso> Mmm, is there a way to have `cabal v2-build` give me some indicator how many packages are left to build? 
07:17:33 <phadej> no
07:18:22 <phadej> I'm not sure cabal-install even know internally that exactly
07:18:57 <phadej> or whether it's implicit "when everything is built, everything is built"
07:19:33 <kuribas> @hoogle Alternative f => [f a] -> f a
07:19:33 <lambdabot> Data.Attoparsec.ByteString choice :: Alternative f => [f a] -> f a
07:19:33 <lambdabot> Data.Attoparsec.ByteString.Char8 choice :: Alternative f => [f a] -> f a
07:19:33 <lambdabot> Data.Attoparsec.ByteString.Lazy choice :: Alternative f => [f a] -> f a
07:19:56 <dminuoso> kuribas: asum ?
07:20:01 <kuribas> @hoogle Alternative f => (x -> f a) -> x -> f a
07:20:02 <lambdabot> Control.Monad.Prospect given :: Alternative f => (a -> f b) -> a -> f b
07:20:02 <lambdabot> Control.Monad.Prospect proceed :: (Alternative f, NFData a) => (a -> f b) -> a -> f b
07:20:02 <lambdabot> Control.Monad.Memo memol0 :: (MonadCache k v m, Monad m) => (k -> m v) -> k -> m v
07:20:10 <kuribas> dminuoso: right
07:20:47 <jophish> carter: oh yeah, I hadn't noticed. That's a coincidence 
07:20:56 <dminuoso> phadej: mmm fair enough.
07:21:07 <kuribas> dminuoso: and asum . map f ?
07:21:20 <carter> jophish: or is it?
07:21:24 <carter> Hehe
07:21:42 <dminuoso> kuribas: getAlt . foldMap (Alt . f)
07:22:00 <dminuoso> Not sure that is better...
07:22:09 <carter> jophish: before doing takeover, ask if the authors would be ok with a supervised nmu ?
07:22:14 <kuribas> dminuoso: indeed
07:22:19 * dminuoso just likes foldMap
07:22:29 <phadej> :t alaf Alt foldMap
07:22:30 <lambdabot> forall k1 (t :: * -> *) (g :: k1 -> *) (b :: k1) a. (Foldable t, Monoid (Alt g b)) => (a -> g b) -> t a -> g b
07:22:32 <carter> Like, rolll all the fixes up into a new branch and ground the dicusssion there
07:22:49 <phadej> no
07:22:55 <phadej> NMU is for simple patches
07:23:08 <phadej> either you take responsibility, or you don't
07:23:11 <phadej> no free cheese
07:24:03 <jophish> either way doesn't work. I've not been able to contact the maintainer
07:24:36 <phadej> https://github.com/haskell-infra/hackage-trustees/blob/master/policy.md#3-source-changes-simple-patches
07:24:44 <phadej> """ For example a package that is not updated for a long period may block all packages that depend on it from working with a newer compiler or base library release.
07:25:14 <kuribas> @hoogle [a] -> (a -> b) -> [b]
07:25:15 <lambdabot> Data.List.Extra for :: [a] -> (a -> b) -> [b]
07:25:15 <lambdabot> Extra for :: [a] -> (a -> b) -> [b]
07:25:15 <lambdabot> Miso.Util withFoldable :: Foldable t => t a -> (a -> b) -> [b]
07:25:21 <phadej> :t <&>
07:25:22 <lambdabot> error: parse error on input â€˜<&>â€™
07:25:25 <phadej> :t (<&>)
07:25:26 <lambdabot> Functor f => f a -> (a -> b) -> f b
07:26:16 <phadej> and btw.
07:26:21 <phadej> :t Data.Traversable.for
07:26:23 <lambdabot> (Traversable t, Applicative f) => t a -> (a -> f b) -> f (t b)
07:26:30 <phadej> which clashes with extra version
07:33:51 <merijn> phadej: I think carter was not suggesting NMUs via trustees, but just asking the maintainer to make you a maintainer just for merging/releasing some stuff
07:35:43 <dminuoso> Mmm, in what code style is <&> useful for?
07:36:23 <maerwald> golfing
07:36:55 <dolio> something <&> \v -> <relatively complicated stuff that uses v>
07:37:17 <dminuoso> Ah, so the same motivation for for then.
07:37:24 <dolio> Yes.
07:38:30 * dminuoso has an idea - why not implement `flip` as part of the language. Just type the identifier in reverse, and you get it in flipped version.
07:38:41 <maerwald> lol
07:38:41 <p0a> lol
07:38:50 <p0a> but what about palindromes? bug!
07:38:58 <maerwald> inference
07:39:07 <carter> Yeah.
07:39:15 <carter> What merijn said.
07:39:31 <carter> And show em a branch thatâ€™s a good
07:39:37 <oxide>  /buflist disable 
07:39:39 <oxide> oops
07:39:57 <dminuoso> p0a: clearly palindromes are for commutative things.
07:40:44 <p0a> dminuoso: perfect 
07:41:04 <dminuoso> esrevart [1,2,3] $ \n -> ...
07:41:37 <p0a> indeed, both * and + are palindromes, so it checks out
07:43:00 <kuribas> :t catMaybes
07:43:01 <lambdabot> [Maybe a] -> [a]
07:43:03 <kuribas> :t saum
07:43:04 <lambdabot> error:
07:43:05 <lambdabot>     â€¢ Variable not in scope: saum
07:43:05 <lambdabot>     â€¢ Perhaps you meant one of these:
07:43:07 <kuribas> :t asum
07:43:08 <lambdabot> (Foldable t, Alternative f) => t (f a) -> f a
07:43:42 <dminuoso> p0a: (*) is not guaranteed to commute if we thing of Num as Ring.
07:43:49 <dminuoso> There goes my perfect plan.
07:43:49 * hackage functor-combinators 0.3.6.0 - Tools for functor combinator-based program design  https://hackage.haskell.org/package/functor-combinators-0.3.6.0 (jle)
07:44:43 <dminuoso> Or, we just kick out as many instances to turn it into a Field.
07:46:37 <boxscape> I was thinking for half a minute about how to manage this for <$> before realizing that that is not, in fact, a palindrome
07:47:48 * dminuoso pokes ski
07:47:57 <dminuoso> Do you know of any obscure language that features this?
07:48:46 <dolio> Why would a language actually make this decision?
07:49:16 <merijn> dolio: Unlambda, brainfuck, Piet, and whitespace are a thing :p
07:49:36 <dminuoso> I was going to say "academic curiosity". But merijn's answer works too ;)
07:50:09 <dolio> So, it would be a language designed around making a huge sacrifice for a not very useful feature?
07:50:11 <dminuoso> Honestly though, I think a system in which a manipulation of the lexical structure has meaning could be of interest?
07:50:14 <phadej> :t flip foldr
07:50:15 <lambdabot> Foldable t => b -> (a -> b -> b) -> t a -> b
07:50:27 <dminuoso> Granted, this particular form seems a bit silly
07:51:00 <phadej> really a function name should have the length of arity
07:51:05 <boxscape> dminuoso do you mean similar to natural language, conjugate identifiers?
07:51:08 <phadej> and permutation of letters is permutation of argument
07:51:10 <phadej> s
07:51:34 <phadej> palindromes -> commutative (binary) things
07:51:44 <phadej> if the length is 2
07:51:48 <dminuoso> phadej: That seems like a saner version than the # holes we talked about yesterday!
07:52:13 <dminuoso> boxscape: yeah.
07:52:25 <phadej> designing of standard library sounds like a nice puzzle
07:53:12 <phadej> maybe having "syllables" separated by something would make that a bit more useful
07:53:19 <phadej> err
07:53:25 <phadej> s/useful/easier/
07:53:31 <phadej> f-map
07:53:32 <phadej> map-f
07:54:34 <phadej> (btw partial application of mixfix operators in Agda is a puzzle on its own)
07:55:19 * hackage reanimate 0.4.2.0 - Animation library based on SVGs.  https://hackage.haskell.org/package/reanimate-0.4.2.0 (DavidHimmelstrup)
07:56:25 <boxscape> something like "if # then a else b" seems like a pretty straightforward solution, with # being a placeholder
07:56:58 <boxscape> asssuming we're only talking about a syntactic puzzle
07:57:08 <phadej> like: https://gist.github.com/phadej/a29f31b71fd8ad379f3ae4063e4bd4fc
07:57:09 <dolio> That's not how it's done.
07:57:28 <boxscape> right, I didn't expect that to actually be in agda in this way
07:57:57 <boxscape> phadej is that a potential solution or actually in the language?
07:58:03 <phadej> boxscape: that works
07:58:12 <boxscape> hm, nice
07:58:13 <dminuoso> Uhh, what's that if_then? What is its semantics?
07:58:27 <dolio> The operator name is if_then_else_
07:58:47 <dminuoso> That much I get
07:58:56 <dolio> Leaving underscores in is how you section.
07:59:32 <phadej> _+_ : Nat -> Nat -> Nat;  5 +_ {- or  -} _+ 7
07:59:50 <dminuoso> Yeah but..
08:00:03 <phadej> everything can be used for evil
08:00:23 <phadej> (and the fact you can, doesn't mean you should)
08:00:44 <dminuoso> Is that behavior documented somewhere on agda.readthedocs.io?
08:01:12 <dminuoso> Ah it is here https://agda.readthedocs.io/en/v2.6.1/language/mixfix-operators.html
08:01:15 <dolio> Yes.
08:01:24 <dminuoso> Was looking at an older version
08:18:27 <kuribas> monochrom: now cassava is choking on a csv that libreoffice calc accepts...
08:18:47 <phadej> separator?
08:18:50 <merijn> kuribas: oh, oh
08:18:59 <merijn> Is this CSV file from excel?
08:19:10 <kuribas> merijn: no, I edited in emacs, hehe :)
08:19:37 <monochrom> I simply never had those errors and can't relate.
08:19:44 <merijn> Excel (and some others) insist on including the heresy that is "the utf-8 byte order mark" in CSV files
08:19:53 <merijn> Cassava, doesn't handle that and chokes
08:19:53 <monochrom> Oh, that one.
08:20:05 <monochrom> I'll share with you my workaround.
08:20:54 <kuribas> merijn: it could at least gracefully handle it, no?
08:21:10 <merijn> no, because cassava commits the same grave sin as aeson
08:21:37 <monochrom> https://hastebin.com/wuxajiweba.js
08:21:41 <merijn> Of having an API operating on ByteStrings, while being used with data that isn't, thereby encoding all sorts of wrong assumptions in the code
08:22:12 <merijn> monochrom: It should've just accepted Text, like aeson should
08:22:22 <dminuoso> I thought aeson had support for varous unicode encodings
08:22:34 <phadej> it doesn't, and shouldn't.
08:22:36 <merijn> Although, at least cassava has the excuse that CSV isn't standardised
08:22:39 <merijn> phadej: It should
08:22:55 <merijn> phadej: the JSON spec is *explicitly* specified in terms of unicode text
08:22:59 <monochrom> Isn't JSON specifically specified as UTF-8?
08:23:03 <merijn> monochrom: No
08:23:08 <monochrom> Ah OK
08:23:16 <merijn> monochrom: It's specifically specified as unicode of unspecified encoding
08:23:26 <phadej> https://tools.ietf.org/html/rfc8259 JSON text exchanged between systems that are not part of a closed ecosystem MUST be encoded using UTF-8 [RFC3629].
08:23:28 <merijn> So accepting ByteString and only doing utf-8 is just objectively wrong
08:23:37 <phadej> case closed.
08:23:42 <dminuoso> monochrom: it specifically says UTF-8, 16 or 32, and then just say "the default (whatever that means) is UTF-8"
08:23:54 <dminuoso> Ah
08:24:12 <dminuoso> I was looking at an old RFC it seems.
08:24:15 <merijn> phadej: So, one can never use aeson for JSON in a closed system, then?
08:24:42 <monochrom> Haha what counts as a closed ecosystem, let's game that.
08:24:47 <phadej> merijn: yes. The additional complexity in library is not worth *your* closed system concerns
08:24:49 <merijn> monochrom: That too
08:25:07 <monochrom> Our whole bloody biosphere is a closed ecosystem. Done.
08:25:09 <merijn> phadej: What additional complexity? s/ByteString/Text in your functions?
08:25:30 <phadej> and additional unnecessary conversions / checks
08:25:40 <monochrom> Both flatearthers and roundglobers agree: JSON is in UTF-8.
08:25:48 <phadej> it was you who talked about pragmatism and "purity", weren't you?
08:26:00 <dmwit> Toroidal-Earther checking in: JSON is EBCDIC
08:26:01 <phadej> bytestring is pragmatic choice
08:26:04 <monochrom> Hell, both creationists and evolutionists agree, too.
08:26:44 <merijn> phadej: Which unnecessary checks does Text incur? Also operating on ByteString requires you validate that the ByteString is, in fact, proper utf-8
08:28:49 <phadej> I'm more worried about conversions to whatever text's internal representation is
08:29:15 <phadej> especially when document is of non-trivial size
08:29:23 <phadej> (i.e. megabytes)
08:30:40 <c_wraith> megabytes aren't non-trivial in size.
08:31:34 <dminuoso> c_wraith: as a core library that likely ends up being used as a dependency in every third package, I think it's fair to demand no unnecessary overhead.
08:32:07 <dminuoso> With that in mind, megabytes are non-trivial
08:32:17 <dminuoso> We dont know what low latency demands users might have in mind
08:33:49 * hackage quickjs-hs 0.1.2 - Wrapper for the QuickJS Javascript Engine  https://hackage.haskell.org/package/quickjs-hs-0.1.2 (goodlyrottenapple)
08:34:30 <c_wraith> You also don't know what functionality demands users might have in mind.
08:35:15 <c_wraith> Text chose to go with efficiently interacting with native libraries for text-handling, which seem to have settled on UTF-16 for some reason.
08:35:52 <c_wraith> (libraries like icu, in particular)
08:36:22 <merijn> there was a utf8 port, but it ended up being slower in benchmarks
08:36:41 <c_wraith> admittedly, that's because the benchmarks involved a lot of interaction with icu
08:37:20 <monochrom> Ah, so that's really why.
08:37:55 <kuribas> merijn: Word
08:38:02 <monochrom> Not a statistic on how many people and how much of the corpus step outside iso-8859-1
08:38:33 <monochrom> Instead a statistics on what ICU uses. :)
08:39:29 <dolio> How much faster was it actually for non-icu uses?
08:42:48 <monochrom> s/iso-8859-1/ascii/
08:53:32 <p0a> do language pragmas come before or after module declaration
08:53:35 <buggymcbugfix> Any idea what is going on here? I am using head.hackage since I'm working with GHC HEAD https://www.irccloud.com/pastebin/SNUERtbJ/
08:53:38 <p0a>  i.e. module Main where ...
08:53:45 <buggymcbugfix> p0a before
08:53:49 <p0a> thank you buggymcbugfix 
08:57:51 <monochrom> aeson-1.5.3.0.tar.gz looks like 298200 bytes from my side, not 298907 bytes.
08:59:13 <p0a> I was recommended UnliftIO.Exception for exceptions before 
08:59:25 <p0a> but I can't use UnliftIO.Exception with stuff from Base, like readFile, right? or can I?
08:59:30 <p0a> (or is the idea to switch to rio?)
09:00:14 <monochrom> I have a feeling you need a "cabal update". And if that doesn't help, something between your computer and hackage has an issue.
09:04:14 <buggymcbugfix> monochrom: spot-on, thanks :)
09:15:49 * hackage quickjs-hs 0.1.2.1 - Wrapper for the QuickJS Javascript Engine  https://hackage.haskell.org/package/quickjs-hs-0.1.2.1 (goodlyrottenapple)
09:40:18 <Saten-san> Am I allowed to ask for support here?
09:41:07 <ddellacosta> Saten-san: probably best to just ask your question and see who may be able to help
09:41:26 <Saten-san> I have a piece of code that I found in a book which doesn't work: https://pastebin.com/j8Qpw5rr
09:41:49 <Saten-san> I've been trying to debug for the past 30 minutes but I have a hard time understanding Haskell.
09:42:26 <ddellacosta> Saten-san: what is the error(s) you're getting? Can you paste it into the pastebin along with the code?
09:43:37 <Saten-san> ddellcosta: `Name' with `[Char]', is that obvious enough?
09:44:20 <Saten-san> Basically I declared an ADT `data Name = Name String` but a String is a list of characters so I don't know why it's complaining.
09:44:32 <ddellacosta> yeah that's enough (and I also just tried running it myself locally). That said,  in general it's really helpful, when you're asking for help, to include as much error output as possible too
09:45:05 <ddellacosta> so String != Name String
09:45:09 <ddellacosta> if you want an alias use type
09:45:35 <ddellacosta> what you are doing is creating a `Name` datatype in that case, which is not the same as a String
09:46:18 <Saten-san> Sorry for not sending the entire output, will do it next time :/
09:46:19 * hackage json5hs 0.1.3.0 - Serialising to and from JSON5  https://hackage.haskell.org/package/json5hs-0.1.3.0 (sakamitz)
09:46:36 <ddellacosta> Saten-san: no it's not problem, just trying to give you tips for success in getting help! Not trying to make you feel bad
09:46:41 <ddellacosta> *a problem
09:46:43 <Saten-san> So how do I fix this problem? I have no idea how ADTs work
09:47:16 <Saten-san> Ah okay thank you :)
09:47:48 <ddellacosta> so if you want an alias, use type like `type Data = String`
09:48:02 <Saten-san> Will try that.
09:48:51 <ddellacosta> if you do want to actually make sure you can't return a `Name` for a `Id` or whatever though, then you'll have to rethink that function a bit, so it returns something other than a String in the type sig
09:49:08 <boxscape> Saten-san is this example taken from a book as is?
09:49:10 <ddellacosta> er, sorry I guess Resp is a better example since Id is an int
09:50:02 <Saten-san> Wait, I'm going to copy and paste it to see if I made a typo.
09:50:19 <ddellacosta> Saten-san: sorry I meant `type Name = String` in my example above, not sure why I wrote `Data`, was a mistake
09:51:00 <Saten-san> The book only containted the function clientName, it supposes that you're smart enough to figure out how to use ADTs after giving one example.
09:51:26 <Saten-san> Pretty harsh way of teaching but I suppose that this forces you to solve the problem yourself.
09:51:36 <boxscape> Ah
09:51:56 <boxscape> have they introduced pattern matching at all yet?
09:52:05 <Saten-san> This chapter is about pattern matching
09:52:23 <Saten-san> The previous one went over defining ADT
09:52:26 <Saten-san> s
09:52:26 <ddellacosta> Saten-san: so you were given the Client type and the clientName function, is that right? Or just the latter?
09:52:40 <Saten-san> 100% right.
09:53:18 <Saten-san> The Data Types inside Client are written by myself though.
09:53:26 <Saten-san> Otherwise it wouldn't compile.
09:53:33 <ddellacosta> I see
09:53:56 <Saten-san> So that's prob what I did wrong. Will Google some additional information about ADTs.
09:54:39 <boxscape> Saten-san so you can either do what ddellacosta said, with "type Name = String", or you can do what you had with "data Name = Name String" - that means you're creating a new type that *contains* a String, and you can use pattern matching to get that string out again
09:55:10 <boxscape> like if you have a function "nameToString :: Name -> String" you can write it like "nameToString (Name str) = str"
09:55:24 <boxscape> where the (Name str) part here is pattern matching
09:56:26 <Saten-san> boxscape: Will use the latter because that's closer to the original.
09:56:35 <boxscape> oxay
09:56:40 <boxscape> okay*
09:58:21 <boxscape> Saten-san Oh I should mention - I used pattern matching in a function declaration in that example, but you can also use it in a case expression like you have in your example
09:58:39 <hyiltiz> clientName smells record syntax 
09:58:52 <boxscape> in fact, you're doing that already - "Person fNm lNm gender" is pattern matching on the Person constructor
09:59:16 <boxscape> you can then pattern match fNm and lNm on the Name constructor inside that pattern match
09:59:19 <Saten-san> it works, but why >:( ?
09:59:31 <boxscape> I'm not sure about what exactly you're asking why it works
09:59:33 <Saten-san> Why didn't my code compile then?
09:59:42 <boxscape> ah, well
09:59:54 <Saten-san> I'm wondering why I wasted 50 dollars on a book that contains code that doesn't work.
10:00:09 <hyiltiz> ^
10:00:16 <boxscape> from what you said it didn't contain the code to clientName?
10:00:20 <boxscape> only the type?
10:00:24 <boxscape> I think?
10:00:28 <Saten-san> It's Practical Haskell from Allesandro Foo (forgot his last name) so I'm prob gonna hit him up with an e-mail.
10:00:32 <hyiltiz> Are you worrying about that or why your code works?
10:00:37 <boxscape> or I might have misunderstood
10:00:45 <ddellacosta> so all you'd have to do to make it work is define your Client differently Saten-san 
10:01:05 <Saten-san> define my Client differently ... will give it a try ...
10:01:22 <ddellacosta> Saten-san: you made all the values of the predefined ADTS types you had to define yourself. If you just made them String/Int etc. you wouldn't have to bother
10:01:30 <ddellacosta> and that function would type-check as-is
10:01:47 <ddellacosta> *ADT types
10:02:20 <ddellacosta> (at least, that's what I understand based on what you wrote above)
10:02:59 <Saten-san> I see what I did wrong. There was a definition of Client a few pages earlier.
10:03:07 <hyiltiz> Haxl seems awfully documented. Anyone outside Facebook actually uses/used it in practice, over everything else Haskell had to offer for concurrency?
10:03:13 <Saten-san> I feel really stupid now.
10:03:22 <ddellacosta> Saten-san: so e.g. GovOrg String, Company String Int String String, etc. Not necessarily good practice but maybe what the book meant
10:03:27 <phadej> hyiltiz: yes
10:03:32 <phadej> successfully
10:03:34 <Saten-san> Well, at least I understand what went wrong now. Thanks.
10:03:45 <ddellacosta> Saten-san: don't feel stupid! Or at least, keep in mind most all of us have also felt stupid learning Haskell (and still do constantly, lol)
10:03:51 <phadej> hyiltiz: look for simon marlow videos (Haskell Exchange from some year)
10:04:06 <merijn> hyiltiz: I don't think the point of Hasl is concurrency, but "batching complex queries compound queries"
10:04:32 <merijn> hyiltiz: And I don't think there really is an alternative for that in Haskell
10:04:41 <hyiltiz> I did; the video sold it well but the documentation is quite lacking as well as the tutorials linked there.
10:04:44 <merijn> Most of the concurrency stuff is for concurrency within one process
10:05:44 <phadej> hyiltiz: I didn't find writing own datasources tricky, it's "just" implementing asked interfaces (type-class instances)
10:06:03 <phadej> and then you program in Haxl monad as you would in IO (and try to use as much Applicative as possible)
10:06:53 <phadej> merijn: it's not concurrency, but it does batch/reorder sequantial program 
10:06:57 <hyiltiz> Agreed; I don't mind implementing them. But there seems to be a overview level guide to exactly what's expected from the data sources. 
10:07:18 <phadej> Some simon's talk did walk through implementing one
10:07:25 <phadej> maybe older haxl version though
10:07:37 <phadej> but the difference wasn't big
10:07:40 <hyiltiz> Ok I'll dig up some more vids
10:08:05 <hyiltiz> There was another implementation of haxl mentioned in his vid
10:08:14 <hyiltiz> Faxl(?)
10:08:43 <hyiltiz> Are those still maintained/relevant?
10:08:58 <phadej> Faxl is not haskell library
10:09:06 <phadej> IIRC it was somethign facebook had previously
10:09:06 <triteraflops> Does anybody know whether ghc supports running haskell programs on clusters without modification?
10:09:11 <triteraflops> I heard one time that was a thing
10:09:13 <phadej> watch / listen more carefully :)
10:09:24 <merijn> triteraflops: Define "on clusters" and "support"
10:09:58 <triteraflops> multiple hosts, and um perhaps with some switches or something, 
10:10:29 <merijn> triteraflops: How do you imagine it being different from running any other program on a cluster?
10:10:48 <hyiltiz> Oh it was called "fraxl"
10:10:52 <triteraflops> support as in, with little or no modification of the Haskell code itself, have the code run in parallel on a cluster
10:11:19 <triteraflops> As I understand it is not generally possible to run programs in most languages in parallel on multiple hosts
10:11:37 <merijn> triteraflops: There are almost no languages that do anything like that
10:11:43 <merijn> triteraflops: I guess maybe Chapel?
10:11:54 <merijn> But basically no one uses Chapel, so it might as well not exist
10:12:09 <triteraflops> well, erlang kinda does, but you do need to do the parallel bit up front with actors
10:12:16 <merijn> triteraflops: 99% of all code running in parallel on clusters is just "regular programs communicating vs libraries"
10:12:25 <merijn> s/vs/via
10:12:27 <lucky> Hi folks.  I'm writing a little assembler as a first task in Haskell, and I've got a Parser data type I pass to a function which of course returns a new Parser.  Am I right in thinking this "function with attached Parser environment" is what a monad would be for?  To sort of encapsulate that for me?  
10:12:30 <merijn> Stuff like MPI, etc.
10:12:58 <triteraflops> yeah I knew about MPI
10:13:01 <merijn> triteraflops: You can do that just fine from Haskell, not sure if anyone did the implementation work of binding MPI for you, but it seems fairly straightforward
10:13:22 <merijn> triteraflops: MPI is just a C library, so wrapping it in Haskell is about as difficult as wrapping any C library, i.e. not very
10:13:29 <triteraflops> there is cloud haskell, which kinda does the erlang thing
10:14:16 <buggymcbugfix> Anyone at haskellerz watching Don's talk?
10:14:32 <buggymcbugfix> Oh damn... if you are, then you probs aren't on IRC right now... bah
10:14:37 <triteraflops> for some reason, I thought there was already some kind of parallel support in haskell for this...
10:14:41 <monochrom> dons has a talk?!
10:15:05 <merijn> triteraflops: Not really, cloud haskell does some stuff, but it's also mostly just a bunch of libraries
10:15:22 <monochrom> I thought dons was imprisoned in a financial gig since 10 years ago. Has he been released yet? Even retired heh.
10:15:28 <merijn> triteraflops: There is no automatic cluster parallelisation in any language, because there's really almost no way to do it sensibly
10:15:41 <merijn> monochrom: No, he was just preoccupied taking pictures of skylines
10:15:58 <monochrom> I thought he even stopped posting skylines 8 years ago.
10:16:26 <triteraflops> hm. I thought there were features in haskell like pure functions and objects without identity that made it easier
10:16:38 <triteraflops> *immutable objects without identity
10:16:39 <monochrom> Imagine Chartered Bank saying "you're a senior dev, you don't need views, I'm moving your office to the basement"
10:16:39 <ph88> how can i replace a break statement from procedural programming to something functional ?
10:17:00 <srk> triteraflops: I wrote ZRE protocol implementation (https://github.com/sorki/haskell-zre) for distributed systems, I wanted to add it as a backend for distributed-process using network-transport but cloud haskell is kind-of unmatained
10:17:01 <triteraflops> ph88: are you doing IO actions?
10:17:04 <srk> *maintained
10:17:10 <ph88> triteraflops, no
10:17:10 <monochrom> Oh did you know my great pun concerning his employment the Chartered Bank? hehehe
10:17:23 <merijn> triteraflops: Sure, it's easier, but you can't do it automatically
10:17:34 <sm[m]> monochrom: yes, he's back to haskelling, he blogged recently
10:17:40 <monochrom> nice
10:17:42 <merijn> triteraflops: I've seen like 8 projects on auto-parallelisation and distributed computing
10:17:47 <merijn> triteraflops: It never works
10:17:52 <lucky> ph88: only conditionally execute the part that would be after the break based on the condition 
10:17:55 <merijn> Well, maybe for entirely trivial workflows
10:18:03 <ph88> merijn, which did you see ?? do you have a list ??
10:18:05 <merijn> triteraflops: Like map reduce
10:18:52 <triteraflops> ph88: so break is for while loops and for loops. Neither of which are possible except in some kind of Monad context.
10:18:55 <triteraflops> ...right?
10:18:58 <merijn> ph88: Just scan through the conference proceedings of, like, EuroPar, HiPEAC, SuperComputing, etc.
10:19:30 <triteraflops> ph88: are you already doing some kind of recursion?
10:19:30 <ph88> triteraflops, fold is loop primitive
10:19:34 <monochrom> ph88: I need you to think in the opposite direction. You have "break" because you have a loop. Suppose you only have recursion. Then "break" just means don't recurse, and possibly don't continue the rest either.
10:19:37 <merijn> "We just make a language that can automatically detect parallelism and exploit it!"
10:19:46 <merijn> The problem is that you need a cost model for that
10:19:51 <merijn> And cost models are hard
10:20:02 <triteraflops> ph88: so you want to halt a fold reduction part way through?
10:20:05 <ph88> monochrom, ah ye i suppose i could use recursion instead of fold
10:20:23 <triteraflops> that, I don't think you can do
10:20:29 <monochrom> foldr can also accomodate that. foldl can't.
10:20:46 <ph88> i don't necessarily want a fold
10:20:50 <monochrom> foldr (\x r -> use r or don't use r based on condition)
10:21:15 <monochrom> That's equivalent to "break".
10:21:25 <triteraflops> so ph88, are you consuming a list?
10:21:40 <ph88> but the most idomatic way would be recursion ?
10:21:50 <triteraflops> I don't think there is only one way
10:22:00 <triteraflops> or even a most idiomatic way
10:22:04 <ph88> algorithm is here in C# and javascript, you can look there where the break statement is   https://stackoverflow.com/questions/11311410/visualization-of-calendar-events-algorithm-to-layout-events-with-maximum-width 
10:22:55 <triteraflops> I guess it always comes down to a conditional of some kind though
10:23:16 <triteraflops> like if <bool> then <short easy thing> else <long hard thing>
10:23:25 <triteraflops> or any other kind of conditional
10:23:41 <Saten-san> ddellacosta: Thanks :)
10:24:10 <monochrom> merijn: I thought that line of research died 20 years ago.
10:25:06 <monochrom> I underestimate how the halting problem implies perpetual employment.
10:25:12 <merijn> monochrom: I still worked on it in 2013 and then saw people still falling in that deadly trap as recently as 2015
10:25:23 <monochrom> yikes
10:25:26 <merijn> monochrom: But it seems so easy at first glance!
10:25:31 <monochrom> oh well at least you're almost done
10:25:33 <triteraflops> you guys still talking about auto parallelisation?
10:25:41 <merijn> monochrom: You "just" need to define a cost model!
10:25:56 <monochrom> I have the blessing that it seems impossible to me so I don't even try.
10:25:59 <Saten-san> Is Cabal's internal reorganization done?
10:26:02 <merijn> monochrom: I'm sure we can...build a statistical model...do machine learning...infer from historic date...etc. something that works
10:26:13 <merijn> Saten-san: There was an internal reorganisation of Cabal?
10:26:41 <dolio> Oh, something that works. That's where everyone previously was following the wrong track.
10:26:51 <monochrom> Generally every endeavour based on "come up with a non-obvious heuristic that improves most of the time".
10:27:24 <monochrom> code optimization, finding parallelism opportunites, circuit optimization, looking for trends in stock market, ...
10:27:33 <monochrom> I can't do them.
10:27:39 <Saten-san> merijn: Yes, in 2018 I suppose.
10:27:42 <monochrom> Turns out it's a blessing.
10:27:51 <Saten-san> Are you Dutch by any chance? Greetings.
10:28:09 <merijn> Saten-san: Never heard of this restructuring, are you maybe thinking of the cabal-install work on v2-build?
10:28:23 <merijn> monochrom: People keep falling for those things every time :)
10:29:56 <Saten-san> at the moment of writing, Cabal is undergoing an internal reorganization. For that reason, it 
10:29:58 <Saten-san> keeps two sets of commands: those starting with the new- prefix (like new-build), and the 
10:30:09 <Saten-san> merijn: Quoted directly from the book I'm reading.
10:30:20 <merijn> Sloppy writing in the book, then
10:30:28 <Saten-san> Why?
10:30:37 <Saten-san> Why does new-build exist?
10:30:46 <merijn> Saten-san: That refers to cabal-install (i.e. the executable "cabal") not the library Cabal.
10:31:00 <Saten-san> Oh.
10:31:11 <merijn> Saten-san: Anyway, it's done in the sense that, as of cabal-install 3.0 the new-* commands are the default
10:31:28 <monochrom> Wait, I thought you were saying the Chicago Cabal is reorganzing.
10:31:40 <monochrom> But our cabal, that's old news. It's finished.
10:31:58 <monochrom> like last year or even before
10:32:13 <Saten-san> I'm confused hahaha. I only know that there's a Glasgow and an Utrecht compiler.
10:32:34 <monochrom> cabal is not a compiler
10:32:50 <merijn> Saten-san: Technically correct, but in reality there's really only GHC, unless you have class in Utrecht >.>
10:33:03 <hyperisco> triteraflops, I like the name. What is your response about branching given Church encodings?
10:34:48 <triteraflops> you mean church numerals?
10:34:55 <triteraflops> didn't think anybody actually used them
10:40:49 * hackage data-validation 0.1.0.1 - A library for creating type safe validations.  https://hackage.haskell.org/package/data-validation-0.1.0.1 (DevinLyons)
10:44:22 <merijn> triteraflops: Define "anybody", "actually", and "use"
10:44:24 <hyperisco> the idea of conditional branching is there is something to inspect and make a decision about, but if you already know what you have then you can already make the decision
10:44:39 <hyperisco> so just deliver the decision rather than the something
10:45:51 <triteraflops> well, use for anything other than proving things mathematically. Actually representing numbers on a computer with church numerals
10:46:16 <hyperisco> Church lists aren't bad if you want to both cons and snoc
10:46:54 <triteraflops> don't they require O(N) space instead of O(log N), where N is the size of the largest number?
10:47:11 <merijn> triteraflops: Why are you talking about church numerals, though?
10:47:19 <Saten-san> Why does Cabal keep complaining about an unrecognised target?
10:47:22 <merijn> triteraflops: hyperisco is talking about Church encodings in general
10:47:27 <triteraflops> is church encoding different?
10:47:33 <Saten-san> Man VSCode can piss me off sometimes.
10:47:44 <merijn> triteraflops: Church numerals are the Church-encoding of, well, numerals
10:48:02 <merijn> triteraflops: Church-encoding is a general technique for representing arbitrary ADTs in lambda calculus
10:48:07 <hyperisco> I am just questioning the idea that "it always comes down to a conditional"
10:53:03 <merijn> hyperisco: Here's an alternate formulation: "it always comes down to something isomorphic to a conditional" :p
10:54:37 <sm[m]> Saten-san: it's "done" in the sense that it's the default behaviour for the most common commands, but I think not yet "Done" for all
10:58:19 <monochrom> Should I inflict uhc on my students next time so they can't use vscode? :)
11:00:05 <maerwald> I'll add uhc to ghcup, easy
11:00:18 <monochrom> And yeah why strawman to church numerals when all hyperisco was saying is just church booleans?
11:00:53 <monochrom> Why do programmers so bloody over-generalize and over-broaden?
11:01:13 <monochrom> I totally feel that that joke about "design a toaster" is right after all.
11:02:32 <triteraflops> oh, I didn't know church encoding was more general than church numerals
11:17:26 <ixlun> What library do people use for writing a parser in Haskell these days?
11:17:43 <ixlun> I'm thinking of looking at Parsec?
11:17:52 <dminuoso> ixlun: megaparsec is a safe default
11:18:37 <dminuoso> There's a good assortment of other more specialized libraries if megaparsec is not ideal, but you can't go wrong with it.
11:18:42 <merijn> ixlun: megaparsec and/or attoparsec
11:19:09 <merijn> Megaparsec if it's human-written input (aka needs to generate useful errors)
11:20:06 <ixlun> cool, will take a look at megaparsec... I'm guessing that it's a successor to parsec?
11:20:53 <dminuoso> ixlun: It was originally a fork of Parsec.
11:21:19 * hackage polysemy-http 0.1.0.0 - Polysemy effect for http-client  https://hackage.haskell.org/package/polysemy-http-0.1.0.0 (tek)
11:21:19 <dminuoso> (I suppose it still is, since that's a matter of shared history)
11:22:45 <sshine> I have a big data type representing an instruction set, and I have two functions, ppHex :: Opcode -> ByteString, and readOpcode :: ByteString -> Maybe Opcode. I'd like to save space pattern-matching once in each function, but the only way I can think of is to have a Data.Map which won't warn if I forget one or have duplicates. is my best option to just stick to two large pattern matches?
11:24:11 <ixlun> Huh, looks like I need to read up on monad transformers first!
11:24:21 <sshine> ixlun, in order to use Megaparsec? should not be necessary.
11:24:39 <Saten-san> I need help ... again ... sigh. I decided to post on Stackoverflow because explaining it here would be too much of a hassle: https://stackoverflow.com/questions/63622099/couldnt-match-expected-type-in-haskell-during-pattern-matching
11:24:39 <monochrom> You can go back to parsec version 2 and just have monads.
11:24:42 <dminuoso> sshine: What number of opcodes do you have?
11:24:48 <dminuoso> Roughly?
11:25:52 <sshine> dminuoso, roughly 80, some taking uint parameters.
11:26:27 <sshine> ixlun, type Parser a = Parsec Void Text a
11:26:36 <monochrom> Saten-san: (Individual (Person "Jack" "Smith" Male)) False
11:27:11 <dminuoso> sshine: Well if you insist on maps and want safety, you could use something like justified-containers.
11:27:52 <Saten-san> monochrom: I swear there is a syntax error in the book. I'm going to send the writer an e-mail about it right now.
11:28:00 <dminuoso> For that number, I might still go with just pattern matching. Or, perhaps if I want some assurances that read/ppHex line up, maybe generate the code with TH.
11:28:23 <sshine> dminuoso, wow, nice to know! considering the footprint I'll live with it this time, but I'll definitely bookmark that for later. :)
11:28:30 <Saten-san> Wait no. It didn't work. Did you test it?
11:28:36 <monochrom> No.
11:28:42 <dminuoso> You can also dump a TH splice manually, avoiding a permanent TH dependency.
11:29:00 <dminuoso> (e.g. with dump-splices, or maybe you use haskell-src-exts)
11:29:37 <monochrom> clientName ( (Individual (Person "Jack" "Smith" Male)) False )
11:29:41 <monochrom> That one is fine.
11:29:42 <dminuoso> Im writing a complete RADIUS library at the moment, where I generate all the boilerplate of serializatoin/deserialization code with haskell-src-exts for that reason.
11:29:50 <monochrom> Also some redundant parentheses.
11:29:53 <dminuoso> Then you could use a map as well, if you wanted to.
11:30:07 <dminuoso> Since the TH would give you assurance about the shape. Heck, you could even do unsafe access
11:32:39 <Saten-san> What???
11:33:10 <Saten-san> monochrom: Why does that work but my solution doesn't? Are there seriously rules on how you're supposed to space the parentheses?
11:33:26 <monochrom> TBH I don't fully know your solution.
11:33:47 <monochrom> But from the partial information I've seen, [] vs ()
11:34:00 <dolio> Parenthesis spacing doesn't matter, though.
11:34:44 <monochrom> "I fed x y to f" is not complete information.
11:34:48 <Saten-san> No ... it truly doesn't.
11:35:06 <monochrom> Complete information is either "f (x y)" or "f x y".  That I can debug.
11:35:36 <Saten-san> monochrom: can you link me a good tutorial on pattern matching?
11:35:46 <monochrom> Your book?
11:36:04 <monochrom> I bet it has a damn good explanation of pattern matching.
11:37:09 <monochrom> And I have very little confidence that your current issue is pattern matching.
11:40:32 <fizbin> When I try to get a heap profile out of my (large, proprietary) haskell program, at some point it fails with a segmentation fault. (If I don't add heap profiling, it fails at some point with the error that it's run out of heap) Any ideas how to debug further?
11:41:23 <monochrom> Maybe give the program a smaller input so it has a better chance of finishing successfully.
11:42:16 <monochrom> If it goes out of hand, hire a consultant who signs an NDA.
11:42:36 <monochrom> Remote debugging works as well as long distance relationships.
11:42:57 <monochrom> Remote debugging works as well as astronomy.
11:44:39 <monochrom> Learn lazy evaluation deeply.
11:44:48 <monochrom> I did that and never needed profiling again.
11:45:05 <dminuoso> fizbin: Run it with gdb?
11:45:12 <dminuoso> And/or valgrind?
11:45:19 <monochrom> I was also partly motivated by having seen an unlucky instance of profiling not being faithful.
11:45:43 <fizbin> Hrm. I suppose I could try a binary search on the input size to get the largest, most complicated input that just barely succeeds and get a heap profile of that.
11:46:26 <monochrom> It's your experiment, but my belief is understand the simpler before attempting the more complex.
11:46:33 <monochrom> Too many moving parts.
11:47:15 <monochrom> You should even look for a cusp point that jumps from constant space to linear space, for example. Now that point is going to be very enlightening.
11:47:28 <tomsmeding> monochrom: profiling not being faithful? how is one supposed to effectively optimise a program if profiling is not to be trusted?
11:47:48 <dolio> Do you need the absolute largest test case to determine which parts of the program take a lot of memory?
11:48:06 <tomsmeding> I have been conditioned with the mantra that one shalt not optimise without first profiling
11:48:31 <monochrom> s/profiling/measuring/ I agree
11:48:45 <tomsmeding> right
11:49:20 <monochrom> If profiling is faithful, I will use that. For now, I just watch htop.
11:49:24 <tomsmeding> though, \lim_{grain -> fine} measuring = profiling
11:49:56 <monochrom> Sometimes I still give profiling a try. Haven't needed more than htop for a while, though.
11:50:11 <fizbin> Well, I don't fully trust the profiler at the moment either, because it's telling me I'm spending 48% of my time in a function that I know (thanks to trace calls) is finished and never called again after 2 minutes into a 8 minute run. 
11:50:26 <monochrom> The thing is I have learned lazy evaluation deeper than average, and learned to read core and cmm and asm.
11:50:32 <tomsmeding> I guess as long as one has a good inkling of where the time is spent, checking your work with measuring can be enough :)
11:50:59 <tomsmeding> being able to read the compilation products certainly helps
11:50:59 <monochrom> Yeah, that.
11:51:15 <tomsmeding> at which point, I guess, one could use a lower-level profiler that annotates the assembly (e.g. perf)
11:54:25 <monochrom> Oh, I can talk about an exam question I gave to my students now.
11:54:37 <monochrom> the exam happened several hours ago.
11:55:23 <monochrom> I asked the student why does evaluating "scanl (+) 1 (generator of huge list) !! (large index)" takes a lot of space.
11:56:06 <monochrom> Don't worry, I don't ask that cold. I first had "part (a) work out the lazy evaluation steps for short list, small but informative index"
11:56:22 <monochrom> That's my idea of learning and troubleshooting.
11:56:47 <monochrom> You nail, ace the basics like a scientist does, first.
11:57:05 <monochrom> Then maybe you can start talking about semi-toy semi-real engineering.
11:57:54 <monochrom> My students would not need profiling to troubleshoot the huge-list huge-index case.
11:58:03 <maerwald> what's there to work out.. it uses foldl, which is a space leak in its own right
11:58:12 <monochrom> A little bit of toying with the "toy" example goes a long way.
11:58:44 <dolio> You did the profiling step for them.
11:58:45 <monochrom> OK well in the context of learning you could dig deeper and go "why/how foldl does this".
11:58:52 <tomsmeding> dolio: precisely
11:58:56 <maerwald> next question!
11:58:59 <dolio> You told them that scanl was causing a lot of memory use.
11:59:11 <tomsmeding> the point is finding that the vicinity of the code where this scanl lives, is a performance issue
11:59:37 * monochrom frowns. Finding?!
11:59:47 <monochrom> Like you didn't know you wrote "scanl"?
12:00:00 <tomsmeding> fair point
12:00:10 <tomsmeding> scanl is a bad word in the first place
12:00:30 <maerwald> the problem is that reasoning in real world doesn't work that way and in courses you're doomed to come up with clinical examples and exercises
12:00:46 <monochrom> See this is my gripe. I wish I'm wrong, but...
12:01:15 <fizbin> I think a more interesting question might be "what are places where it's totally legitimate, in terms of memory and performance uses, to use scanl"
12:01:50 <monochrom> My impression of how you engineer your software is you writing 10000 lines of code cold, zero testing zero measuring during that time.  Then now you test it and it surprises you and you don't know where to start because you never did any intermediate tests.
12:02:09 <maerwald> that's all fine
12:02:38 <maerwald> the moment when you broke the backend with scanl will be a memorable moment and much better learning experience than a test
12:02:46 <maerwald> >:)
12:03:11 <maerwald> dopamine or fear, both work
12:03:21 <monochrom> Here is one scenerio my scanl takes constant space.  print (scanl (+) 0 (huge list generator))
12:03:26 <maerwald> but with an experience attached
12:03:37 <monochrom> even print (scanl (+) 0 [1..])
12:03:50 <monochrom> I think I even wrote a short explanation on the haskell wiki somewhere
12:04:55 <maerwald> University tries to be non-memorable, which is the problem. It's too mechanical. Now next time someone sees scanl, they'll think: ah, that was the test question I messed up... what was the quesion back then?
12:04:57 <monochrom> I do have my share of facepalm doh moments.
12:05:21 <monochrom> But I don't use this to blame "not enough profiling tools, debugging tools".
12:05:47 <monochrom> I blame myself "next time more tests and measurements every time I add one character to my code".
12:06:07 <dolio> You're fired.
12:06:11 <dolio> You never get anything done.
12:07:22 <monochrom> I got something done and I am still not fired.
12:08:51 <monochrom> There is also a snowballing critical-mass effect on my skill.
12:09:26 <monochrom> Past some point, one can reliably tell "this chunk of code cannot be the cause, go worry some other chunk"
12:09:57 <monochrom> But to reach that critical mass, first you have to do it my "slow" way and train yourself well on the basics.
12:10:43 <monochrom> also reliably tell "inefficiency code smell" such as "hey, foldl, scanl, pay attention here, are you sure you want to do this"
12:11:46 <maerwald> that's teaching... don't teach, mentor instead
12:12:43 <monochrom> No, my most recent sentences were talking about self-guided learning.
12:12:50 <monochrom> I'm not going to teach you.
12:13:31 <monochrom> But only because you haven't paid me to.
12:13:45 <maerwald> You never know how someone learns best... it's all derived from yourself.
12:14:36 <monochrom> Should that stop us from sharing how we each learn?
12:14:39 <maerwald> I like structured... others don't. When I come up with material, it's too verbose and overloading of context. Others hate it.
12:15:08 <Saten-san> monochrom: I've been outside for a while to lower my stress, and I've been wondering, why did my specific function require parentheses? I thought Haskell was known for not needing them?
12:15:13 <maerwald> I dunno, I'd just close all universities and give away free degrees
12:15:55 <maerwald> most ppl I've worked with (programmers) have never seen a CS class from inside
12:16:24 <monochrom> Saten-san, Haskell is not known for that.
12:16:29 <merijn> maerwald: And you don't think that selection bias may have *any* impact on your perception of the world, compared to, say, people who teach at universities?
12:16:40 <monochrom> I think you have vastly oversimplified syntactic design.
12:16:43 <maerwald> merijn: that was anecdotal
12:16:49 <monochrom> false-dichotomized
12:16:49 <Saten-san> monochrom: I'm reading a very bad book then. Will check Haskell Wiki for a new one.
12:16:56 <fog> i have a mind boggling type error; https://pastebin.com/raw/3k9kG6sc
12:17:10 <maerwald> merijn: I wouldn't actually close universities :p
12:18:27 <maerwald> but there's a fair share of ppl from electrical engineering, physics and similar who end up in programming
12:18:29 <Saten-san> Luckily there's also this playlist which is still updated every week: https://www.youtube.com/watch?v=Vgu82wiiZ90&list=PLe7Ei6viL6jGp1Rfu0dil1JH1SHk9bgDV
12:18:55 <Saten-san> Is this the official IRC channel of Haskell Wiki by the way?
12:18:57 <fog> can anyone read that?
12:19:13 <fog> Saten-san; this is the official haskell irc
12:19:34 <hyiltiz> fog I can read
12:19:51 <fog> this i mean; https://pastebin.com/raw/3k9kG6sc
12:20:30 <hyiltiz> Yeah I did; it is a loooong paste tho
12:20:44 <Saten-san> fog: but is the Haskell Wiki related to it's developers? What is "official"?
12:20:51 <dminuoso> So. Why cant I have a cross-machine cross-language STM? :(
12:20:55 <tomsmeding> fog: because GHC can't figure out what tail0 is, it refuses to reduce the type family
12:21:08 <fog> yeah, but i cant figure out why it cant
12:21:08 <dminuoso> It would be really awesome to have atomic transactions between this haskell app and that remote python.
12:21:34 <davean> dminuoso: I mean you can't REALLY have distributed STM at all
12:21:38 <merijn> dminuoso: That's called "a database"
12:21:51 <fog> Saten-san: yes, the contributors to the haskell wiki include those contributors to haskell language and libraries 
12:21:52 <dminuoso> davean: Why can't I? I dont see a fundamental reason.
12:21:59 <davean> dminuoso: Because of FLP
12:21:59 <fog> you can find them here
12:22:04 <Saten-san> What book do you guys recommend?
12:22:05 <tomsmeding> fog: where do you think you fix tail0?
12:22:13 <monochrom> dminuoso: First, finish cross-machine cross-language any atomicity or consistency at all.
12:22:16 <Saten-san> fog: Ah, okay.
12:22:21 <dminuoso> davean: flp?
12:22:21 <davean> dminuoso: you can have something close enough though.
12:22:37 <fog> tomsmedling: i cant even understand why it thinks its ambiguous...
12:22:59 <tomsmeding> okay, so can you explain why you think it should _not_ think it's ambiguous? :p
12:22:59 <dminuoso> merijn: databases lack the `retry` with its blocking semantics that makes STM so exciting and fun to use.
12:23:02 <monochrom> err actually, finish cross-machine any atomicity or consistency at all. Doesn't even have to be cross-language for now.
12:23:10 <tomsmeding> because if there's nothing forcing it, then, well, it's ambiguous :p
12:23:18 <monochrom> I mean we all "know" how. But implementations are lacking.
12:23:26 <tomsmeding> I feel kind of daunted going through all that code
12:23:28 <fog> tomsmeding: the miso version works...
12:23:39 <monochrom> One day I may have to roll my own.
12:23:39 <fog> it must be something to do with the difference between the two
12:24:12 <fog> tomsmeding: yeah, thats why i figured i would ask if it was actually legible to anyone first...
12:24:56 <dminuoso> Maybe the current state-of-the-art solution to this problem domain is inventing a robust protocol.
12:24:56 <maerwald> monochrom: do you do trainings?
12:25:00 <davean> dminuoso: Basicly FLP is the proof that you can't have any reliable distributed system (Given constraints that basicly are the ones the world has) so what you have to do is focus on failures. Its something of a long discussion ub Haskell's clean STM semantics would be incorrect in a distributed system. You might be ok with "ok, but that never happens" and thats fine.
12:25:04 <dminuoso> (Because in a way, protocols implement multi-machine state machines)
12:25:05 <monochrom> No.
12:25:09 <fog> most of its pretty straitforwards, and when you understand what the implementations are doing, the tree-like structure seems reasonable
12:25:19 <davean> dminuoso: there *can't* exist a robust protocol.
12:25:20 <hyiltiz> Oh you were asking legibility not accessibility
12:25:48 <fog> when i say "implementations" i mean, data MisoTree and data MimoTree
12:26:15 <fog> hyiltiz: yeah, like, does your brain just completely reject the code
12:26:16 <dminuoso> davean: Mmm I see.
12:26:40 <dminuoso> By I see I mean I have a rough understanding of what you're saying, the details seem like it would take the better part of an afternoon skimming that proof and papers.
12:27:01 <fog> basically they hold the function, and the inputs, in a tree...
12:27:11 <hyiltiz> I didn't read any ten continuous lines though I went over the whole thing so...
12:27:13 <davean> dminuoso: yes, which is why I don't want to get into it. In reality we're now entering "How good do you ACTUALLY want it to be?"
12:27:21 <davean> dminuoso: so it won't be STM
12:27:32 <davean> but you might like it anyway.
12:27:53 <davean> dminuoso: honestly I like the Common Knowlege paper better for it
12:27:55 <dminuoso> davean: Hold on though. But even single machine STM cant be perfect the moment I have more than one thread though, right?
12:28:09 <davean> they both prove the same thing, Common Knowlege is just a more general, more enlightening take IMO
12:28:09 <dminuoso> Shouldn't I have the same consensus problem?
12:28:20 <davean> dminuoso: incorrect - they share a clock.
12:28:34 <davean> This is why common knowlege is a better take on it
12:28:36 <dminuoso> A clock?
12:28:39 <davean> yep
12:28:49 <fog> well i guess if you can skim over it, and kind of go, "ah, HLists, thats ok" and then, "hmm, some kind of tree that holds the implementation of a function as a GADT..." and then "i guess those funny types manage to hold the type info somehow"
12:28:55 <davean> dminuoso: have you evr seen the blue eyes problem?
12:28:57 <dminuoso> Huh? Which clock are you referring to?
12:29:02 <fog> and then scroll to the bottom and go, "wtf is that type error?"
12:29:07 <fog> then you can read it...
12:29:47 <fog> the real problem is how to figure out why it doesnt compile
12:29:56 <davean> dminuoso: a shared clocks let you know when they'll know something is the real trick
12:30:06 <monochrom> dminuoso: When 2 or more computers are involved, first take a look at the "byzantine general problem" and feel very sad.  Then, after you accept to lower your bar, "distributed voting majority algorithms" will give you back some hope, but certainly not to your original optimistic level.  And yeah, clocks, that's going to be another let-down.
12:30:25 <davean> monochrom: the byzantine generals problem is actually different!
12:30:35 <davean> very different
12:30:38 <monochrom> But let me relate a really fun fact about the profs who taught the distributed computing course I took. (grad course.)
12:31:26 <davean> which is in its self super interestign!
12:31:36 <monochrom> The two profs, one is from Greece, another is from France but ethnically Egyptian.  Both migrated permanently to Canada.
12:31:39 <dminuoso> davean: Ah yes, Im familiar with the blue eyes problem
12:31:51 * Rembane shakes fist at time 
12:31:59 <monochrom> So, the course opened with the Two Byzantine General problem, as usual.
12:32:02 <davean> dminuoso: ok, so the thing about the blue eyes problem is that the assumption is that they all know the others know what the father said.
12:32:17 <davean> dminuoso: that is "Common knowlege"
12:32:36 <monochrom> 5 YEARS LATER, I realize the irony.  One prof from Greece, the other from Egypt.  Two Byzantine generals, did you say?
12:32:39 <davean> dminuoso: what a fixed, shared clock buys you is eventual common knowlege.
12:33:00 <davean> dminuoso: distibuted systems are where you cross clock domains!
12:33:36 <merijn> monochrom: Byzantine was actually picked to avoid any racial issues, I think the original name was Chinese or something, but they wanted to avoid offending anyone, so figured that no one (except a few nerds fetishising the (eastern) roman empire) would object to Byzantine :p
12:33:42 <davean> The days in blue eyes are a shared clock. If you actually take it as them not sharing that perfectly they never leave.
12:33:43 <fog> something about prime time in different time zones... and polynomial time...
12:34:09 <fog> my prof bursts in and claims forthrightly "its polynomial time!"
12:34:24 <dminuoso> davean: Ah, because without a shared clock, they could never follow their assumptions and leave on the nth day for n people on the island?
12:34:41 <tomsmeding> fog: in your instance Value (MimoTree ...), you require outputs ~ GetMimoOutputs lookups tail, where 'tail' is not used anywhere else
12:34:51 <davean> dminuoso: because if they had *any* disagreement at all about time, they'd not know if the other WAS going to leave at that timestep or not at any given hard time
12:35:00 <tomsmeding> outputs and lookups are known types, but tail is not; how is GHC supposed to figure out what tail should be?
12:35:04 <fog> tomsmeding! horay
12:35:04 <davean> dminuoso: it becomes reasoning about how sure you are they've made a time based decision
12:35:07 <dminuoso> Right that makes sense, intuitively
12:35:07 <fog> thanks
12:35:15 <hyiltiz> But the Byzantine problem can't fully block implementation based on probabilitic interference though?
12:35:15 <davean> dminuoso: I'm giving you the intuitive
12:35:21 <davean> dminuoso: Theres really nice formalisms though.
12:35:56 <merijn> hyiltiz: You can avoid Byzantine issues if you're willing to accept partitioning
12:36:10 <merijn> But then you need to figure out how to handle those :p
12:36:22 <fog> yay! replacing tail with x ': xs makes it compile, you saved me
12:37:08 <davean> dminuoso: its a super interesting area, seriously. But the short answer is distributed systems are *never* correct, they're about how reliable they are and how close to correct, and how fast they make progress under what conditions, along with what extra oracles you can bring in.
12:37:26 <tomsmeding> fog: \o/
12:38:08 <davean> dminuoso: like spanner bounds time skew to get a performance boost and thats an entire studied area of distributed systems but it also gets back to Common Knowlege and it doesn't actually "fix" anything strongly just optimizes average cases basicly.
12:38:27 <davean> I'm being unfairly simplifying here, but I want to express ideas in less than a week.
12:38:50 <fog> woop woop; https://pastebin.com/raw/WsENEHF1
12:39:10 <monochrom> Yikes, FLP stands for 3 persons, Fischer, Lynch, Paterson.
12:39:16 <davean> monochrom: yes, why?
12:39:53 <monochrom> Because I was wondering what's FLP and tried to look up, and I was hoping it was an acronym.
12:40:07 <monochrom> But I <3 Lynch and her I/O automata.
12:40:21 <davean> Oh sadly no. But all 3 are very significant researchers in the area.
12:40:33 <davean> Lynch is damn good
12:40:34 <monochrom> Every time some says "what is a semantics of Haskell IO" I answer "Lynch's I/O automata"
12:40:39 <fog> so, this is the first working example i have of function nets!
12:40:48 <monochrom> Another universally denied truth from me
12:41:11 <fog> i have to do something with the Let and Class instances to allow the memoisation of the branches for variable re-use though
12:41:26 <fog> so this is probably about as legible as its going to be for now
12:41:37 <dminuoso> monochrom: I just recall conals remarks about "The IO monad is not even wrong, because IO has no denotation" every time I think about the semantics of IO.
12:42:06 <davean> dminuoso: anyway, enjoy the next year of your life let me know how un-mind-fucking your brain goes after learning about distributed systems ;)
12:42:12 <monochrom> Don't expect a denotational semantics. At least not until "denotational" is broadened.
12:42:17 <dminuoso> davean: Yeah thanks, I think Ill need to dive deeper than this short skim when I have some time.
12:42:32 <fog> what about session types?
12:42:40 <monochrom> The narrow sense of "denotational" doesn't even fit any I/O, nevermind Haskell's.
12:43:29 <fog> Types for Dyadic Interaction; http://www.kurims.kyoto-u.ac.jp/~kyodo/kokyuroku/contents/pdf/0851-05.pdf
12:43:37 <monochrom> Hoare and a few others once joined to propose a mildly relaxed sense. It's "set of traces" and still has the spirit of denoational. It was not well accepted.
12:43:44 <fog> LANGUAGE PRIMITIVES AND TYPE DISCIPLINE FOR STRUCTURED COMMUNICATION-BASED PROGRAMMING; https://www.di.fc.ul.pt/~vv/papers/honda.vasconcelos.kubo_language-primitives.pdf
12:43:53 <tomsmeding> sm[m]: opinions on pastebin rate limiting? at most 5 per minute?
12:43:53 <dminuoso> Well Im only starting to get an idea of what denotational semantics are about when applied to Haskell. It's very informal and handwaving.
12:44:40 <tomsmeding> hyiltiz: perhaps also your opinion on ^
12:44:55 <fog> is that conals idea of denotational design?
12:46:36 <sm[m]> tomsmeding: sounds a bit arbitrary
12:46:42 <hyiltiz> 10/min and 100/h? I can imagine someone posting multiple files.
12:46:43 <tomsmeding> of course it is
12:47:14 <tomsmeding> hyiltiz: makes sense
12:47:22 <sm[m]> I'd have a clear goal in mind first. "Needs to use < X resources in each Y minute period"
12:47:51 <hyiltiz> And you block an IP once it tried to paste over 1k/day
12:48:04 <sm[m]> also I'd ask myself if it's needed yet
12:48:19 <tomsmeding> perhaps yes
12:48:23 <hyiltiz> Lazy evaluation for software design lol
12:48:27 <sm[m]> in the spirit of http://wiki.c2.com/?YouArentGonnaNeedIt, http://wiki.c2.com/?DoTheSimplestThingThatCouldPossiblyWork
12:48:33 <tomsmeding> true
12:48:47 <tomsmeding> well I've already built a simplistic engine, so then perhaps I'll just set the limits high
12:48:52 <tomsmeding> can always lower them later
12:49:12 <sm[m]> I'd set an overall app limit with ulimit or something, just for peace of mind
12:50:22 <tomsmeding> I have a maximum size on the sqlite database file
12:51:09 <hyiltiz> Maybe also set up something like oomd?
12:53:15 <sim590> tomsmeding: https://github.com/sim590/dpaste/. May be you'd like this once the 64KiB barrier has been breached (see #17). Of course, #19 would also be nice. If a high number of users would start adopting this approach (like pastebin users on IRC for starters), there would be more felxibility regarding rate limiting I think.
12:55:06 <sim590> However, you would not be able to use this without others using it of course... There's no HTTP (or any universal centralized) protocol in play here that would let people fetch your pastes without installing dpaste..
12:55:23 <sm[m]> nice sim590, but yes we're wanting a web UI so it can be a general pastebin
12:56:00 <sim590> What do you mean by "general"? 
12:56:07 <sm[m]> ie, usable by any #haskell visitor
12:56:17 <sm[m]> such as windows/GUI-only folks
12:56:22 <tomsmeding> sim590: looks cool; is that DHT reliable, as in: if I paste something, how long does it take for someone else to be able to view the content?
12:56:41 <sim590> tomsmeding: it doesn't take more than a few seconds.
12:57:04 <tomsmeding> that's significantly better than a previous experience I had with this kind of distributed thing :p
12:57:51 <sim590> sm[m]: Yeah. That's the disadvantage. However, there are some efforts by developers of libp2p and IPFS to push for restructuring the web using decentralized software. May be one day, our browsers will support those protocols.
12:58:10 <sm[m]> just FYI the readme didn't immediately make clear what's cool about this say compared to termbin.com or ix.io.. maybe OpenDHT distributed hash table needs a link ?
12:59:15 <sim590> tomsmeding: It's designed to be a DHT that supports only small values so in general it's pretty fast. However, the network is still small last time I checked.
12:59:20 <hyiltiz> Does anything think hiding the site behind a candy looking CSS cloak would give new users better UX?
12:59:39 <tomsmeding> hyiltiz: yes
12:59:41 <sim590> sm[m]: You're right. I could add a link.
12:59:49 <tomsmeding> it definitely needs some css :p
13:01:12 <sim590> sm[m]: But OpenDHT does compile on Windows. I haven't made sure dpaste can, but it surely could with not much work.
13:01:31 <hyiltiz> Do you think pasting multiple files at once and getting a single URL showing them all would be a worthwhile feature to have?
13:01:55 <hyiltiz> Eg to paste stack cabal main lib and Data
13:02:06 <hyiltiz> Stuff like that
13:02:11 <tomsmeding> hyiltiz: yes that would certainly be nice, especially given the purpose of the custom pastebin service :p
13:02:39 <hyiltiz> Would it be as easy as just putting a few fmap in front of stuff?
13:02:57 <sim590> OpenDHT is actually used by a multiplatform communication software called GNU/Jami (formerly called GNU/Ring) that's developped by a company which has made this project its big R&D section. So there is reliable support. I'm not saying they don't have issues however. They could benefit more developers on the project.
13:03:53 <tomsmeding> hyiltiz: I guess? it shouldn't be too complicated at least
13:03:53 <fizbin> Hey, quick check of my understanding: say I have `assignMap :: Ord a => [a] -> Map a Int` given by `assignMap lst = M.fromList $ zip (nubOrd lst) [0..]`, where nubOrd is from Data.List.Extra. Is that O(n log n) ?
13:05:42 <hyiltiz> Seems depends on nubOrd
13:06:26 <tomsmeding> nubOrd is n log n according to docs, to save someone some hoogling
13:06:49 <tomsmeding> well then yes, it's nubOrd (n log n) + zip (n) + M.fromList (n log n) -> n log n :)
13:08:13 <tomsmeding> tangential: why on earth does nubOrd in Data.List.Extra use a custom-coded red-black tree instead of Data.Set
13:08:53 <hyiltiz> tomsmeding: I think the simplest interface may be: show single paste box with two buttons one to post another to "add another paste" which shows another paste box.
13:09:19 <Guest_9> Hi! I'm trying to install ghcup on MacOS 10.15 (Catalina) and I'm getting this error on Terminal Error: DigestError "b40bd38d29302212142cfa200cbd22ef8bcece52f87cb4f70345bf64b8640923" "e80a789e9d8cfb41dd87f3284b75432427c4461c1731d220d04ead8733ccdb5e"
13:09:30 <tomsmeding> hyiltiz: sounds good :) You up for some web coding, or should I? :p
13:10:09 <hyiltiz> I haven't even read Snap docs
13:10:28 <tomsmeding> I'll do the server end :p
13:10:48 <tomsmeding> mostly asking about the css
13:10:56 <hyiltiz> So I can stick in the paths in HTML?
13:10:57 <tomsmeding> I'm quite bad at website design :p
13:11:18 <hyiltiz> Ah I'm being treated as a front end developer
13:11:18 <tomsmeding> just do whatever when you're ready to submit to server in the client html page
13:11:27 <tomsmeding> you are :p
13:11:31 <tomsmeding> you happy?
13:11:42 <fizbin> tomsmeding: Yeah, that's a good question. Don't some trees have worse-than-n-log-n behavior when constructing them from a sorted list, or a list sorted in reverse?
13:11:54 <hyiltiz> I wonder anyone here would be happy as a front end developer but I'll bite
13:12:00 <tomsmeding> hyiltiz: very good point
13:12:03 <tomsmeding> you can refuse :p
13:12:31 <maerwald> Guest_9: which ghc version?
13:12:38 <hyiltiz> Yeah I'll try but no promises as FS goes
13:12:39 <tomsmeding> fizbin: Data.Set.insert is explicitly documented as O(log n) ;)
13:12:43 <ClaudiusMaximus> tomsmeding: i'm guesssing so it can start outputting before the thing is fully constructed (which (Set.toList . Set.fromList) can't)
13:12:46 <tomsmeding> it would be outrageous if it wasn't
13:13:53 <fizbin> ClaudiusMaximus: Sure, but you can build nubOrd that can do that perfectly fine on the back of standard Data.Set:
13:13:57 <tomsmeding> ClaudiusMaximus: nubOrd doesn't do toList on the tree it's building, it yields an item in the result list whenever the new item is not in the set it's building
13:14:30 <tomsmeding> so I don't think switching to Data.Set would prevent it from producing results early
13:14:30 <ClaudiusMaximus> oh, i see
13:14:52 <tomsmeding> (also, a red-black tree is a simple binary search tree, and those in general can't toList before fromList is done :p )
13:15:23 <tomsmeding> in fact I think s/RB/Data.Set.Set/g in Data.List.Extra would work fine :')
13:15:27 <fizbin> e.g. nub = go S.empty where { go _ [] = []; go s (a:as) | a `S.member` s = go s as; go s (a:as) = a : go (S.insert a s) as }
13:15:35 <tomsmeding> (doing the obvious in removing 'data RB' etc)
13:15:37 <maerwald> Guest_9: I think your download might be corrupted
13:15:46 <tomsmeding> fizbin: precisely
13:16:14 <Guest_9> tomsmeding: Well that's unfortunate haha. Do I just delete and redownload?
13:16:28 <tomsmeding> (wrong mention :p)
13:16:30 <sm[m]>                                                                                                                                                                                                                                                                                                             
13:16:35 <tomsmeding> but yes, probably
13:16:36 <maerwald> Guest_9: make sure ~/.ghcup/cache is empty
13:16:44 <Guest_9> Whoops, sorry!! tomsmeding
13:16:44 <maerwald> then try again
13:16:59 <tomsmeding> sm[m]: what happened there?
13:17:30 <sm[m]> what! where?
13:17:42 * sm[m] looks around wildly
13:17:55 <hyiltiz> I don't see weong mention either
13:18:29 <tomsmeding> hyiltiz: Guest_9 mentioned me but intended maerwald
13:18:51 <tomsmeding> sm[m]: you sent a long empty message, I think? weechat is not forthcoming with exactly what bytes it's filled with
13:19:10 <hyiltiz> You are taking too loud in the bar others joined the table :D
13:19:18 <tomsmeding> ah yes it's spaces
13:19:36 <tomsmeding> 300 of them
13:20:33 <sm[m]> tomsmeding: ah, I see it. No idea, my apologies. Maybe I fat-fingered
13:21:02 <monochrom> a ton of spaces is not empty, but ok
13:21:06 <sm[m]> incidentally, maybe you like snap but I'll just mention that the new shiny IHP has a cool reloading hsx DSL that might attract front end developers
13:21:15 <tomsmeding> I'm actually more curious how it's exactly 300
13:21:24 <tomsmeding> sm[m]: âœ¨
13:21:26 <monochrom> I am sensitive to that because another instance of my students not thinking straight.
13:21:44 <tomsmeding> monochrom: sorry for the sloppy use of language :p
13:22:03 <tomsmeding> "long empty message" is indeed an interesting paradox
13:22:29 <monochrom> there is a string, dynamically determined, that a TCP server has to maintain, and send to clients upon request.
13:23:02 <monochrom> there is a guaranteed upper bound "75 bytes" for that string. But it's only an upper bound.
13:23:30 <monochrom> The string has clearly a dynamically determined length, not always 75.
13:23:43 <monochrom> But students decided to always send 75 bytes regardless.
13:23:54 <tomsmeding> padded with spaces?
13:24:22 <monochrom> They also nul-pad their internal storage, so they never saw the trailing junk when manual testing with nc.
13:24:43 <monochrom> they call it "it's easy to fix, give me back my marks"
13:25:04 <monochrom> WHO GAVE YOU LICENSE TO SEND 75 BYTES
13:25:53 <tomsmeding> that's an example of students not thinking like a programmer; I've seen more of those instances
13:26:38 <tomsmeding> it's in a similar vein to how people first learning programming don't really get how important it can be to strictly conform to an output format
13:27:02 <tomsmeding> also I recall how another TA once told me how they had a student that didn't really get variables
13:27:39 <tomsmeding> the task was to write some sort of quiz program, and the student refused to store certain internal values long-term
13:28:04 <tomsmeding> so they wrote something like "Please remember this value: %d" to standard output, and expected the user to enter that value back in later in the program's execution
13:28:27 <monochrom> haha that's great
13:29:00 <tomsmeding> we more experienced programmers innately understand the concept of a program that conforms to a certain I/O specification
13:29:12 <tomsmeding> that is a learned thing, and I forget that sometimes
13:34:19 <hyiltiz> tomsmeding: LOL that is epic
13:35:48 <monochrom> I think the student solved the halting problem.
13:36:13 <dminuoso> I wish people would stop referring to it as a "halting problem"
13:36:22 <dminuoso> It's not a problem. It's an undeciability!
13:36:31 <monochrom> Because there was a recent proof that Interactive Proof solves the halting problem, and Interactive Proof makes fewer assumptions than the student did.
13:37:13 <hyiltiz> what are interactive proof assumptions, may I ask?
13:37:18 <hyiltiz> or a link to the paper
13:37:24 <tomsmeding> does it? External memory (which is essentially what the student used) doesn't sound like something that gives you much leverage in a proof context
13:37:31 <monochrom> Yeah I'll try to find some link
13:37:55 <dminuoso> monochrom: https://arxiv.org/pdf/2002.10490.pdf this?
13:38:01 <monochrom> If I turn out to be wrong, consider it a joke. :)
13:38:23 <dminuoso> My google scholar skills are limited
13:38:25 <monochrom> Yeah I think so. Henry Yuen from Toronto is the right person.
13:40:32 <monochrom> my favourite popsci version is https://www.quantamagazine.org/landmark-computer-science-proof-cascades-through-physics-and-math-20200304/
13:40:57 <hyiltiz> typ dminuoso monochrom for the link 
13:40:59 <monochrom> I think it has a link to the paper as well
13:41:37 <monochrom> generally my favourite popsci is quanta magazine, because it is not too pop/low
13:41:38 <tomsmeding> monochrom: that animation at the top of the article was already worth clicking the link
13:41:51 <monochrom> haha
13:45:40 <hyiltiz> the anim is nice that it is not totally ordered/orchestrated/organized, things are wonky and random
13:52:37 <hyiltiz> â€œIt gives more leverage to the verifier. You interrogate, ask related questions, cross-check the answers,â€ Vidick said. If the suspects are telling the truth, their responses should align most of the time. If theyâ€™re lying, the answers will conflict more often.
13:53:14 <hyiltiz> The article has this sentence in it; is singularity and existence of truth a given/axion? Epistomological question 
13:54:32 <monochrom> It's an analogy.
13:55:11 <monochrom> or some kind of intuition for those of us who don't have to time study the proof
13:55:23 <dolio> That's why I don't like reading pop articles, even if they're the best pop articles.
13:55:36 <monochrom> or a motivation that suggest "worth trying to prove carefully"
13:56:18 <monochrom> Well yeah, when I read them I have to filter a bit too, take with a grain of salt etc.
13:58:59 <dolio> I imagine the raised objection is not really an issue, though, because it's talking about verifying proofs in some fixed mathematical system, right?
13:59:19 <dolio> It's not like asking someone about a murder.
14:00:08 <monochrom> Yes.
14:00:53 <hyiltiz> dolio: are you suggested that  in some fixed mathematical system any given statemetn is a) either provable or non-provable; b) provably True or provably False? (I am betting you are saying a)
14:01:17 <monochrom> It might not even be what a mathematician or type theorist call proving.
14:01:21 <tomsmeding> (b) would be quite a statement :p
14:01:32 <hyiltiz> if a), what about statements whose proofs are undecidable, like most paradoxes
14:02:08 <monochrom> Instead, there is a decision problem, there is an input, there is an allegedly certificate that concludes "yes", and you're checking that certificate.
14:02:18 <hyiltiz> tomsmeding: for the most part of human history, b was in everyone's mind; I am pretty sure 99.99% of people out there still believes so
14:03:32 <monochrom> or not a certificate, rather one or two oracles that answers queries. (and then you wonder if their answers make sense)
14:03:53 <dolio> hyiltiz: The answers to those would depend on the system to some degree.
14:04:02 <monochrom> the "zero-knowledge proof" kind of proof
14:06:31 <dolio> Anyhow, my assumption is that you're trying to figure out if they're lying about having proved or disproved something.
14:08:07 <monochrom> Yes.
14:11:00 <dolio> If you have two people, one of which claims to have proved something, and one which claims to have disproved it, and both cases are 'true for them', then you have a problem generally.
14:11:16 <dolio> Most systems are designed for that to not happen.
14:12:31 <nij> Hello.. I have a time series and want to simply plot it.. what's a better practice? I notice there are lots of TIME package out there.
14:13:06 <nij> The time format is "YYYY-mm-dd HH:MM:SS".. probably I need to change it to seconds since epoch?
14:13:42 <nij> I did successfully plot diagrams if I can convert my data in to data of type [(Double, Double)]..
14:24:58 <hyiltiz> nij: so u r not asking about plotting but really about reading formatted date strings into numbers
14:25:33 <nij> hyiltiz: Most of it yes. Though I'm also wondering is there better practice.
14:25:58 <nij> Translating time string to epoch integer, plot, and then transform it back seems a bit dirty.
14:26:43 <tomsmeding> hyiltiz: latest github version of paste thing is online, now with sqlite storage and """spam protection"""
14:28:40 <ixlun> I'm wondering if someone could maybe help with finding a more elegant way of doing this: http://ix.io/2vrf  , i.e. the case of a character determines the Colour of the piece and the character itself determines the kind of piece that should be returned.
14:29:27 <ixlun> I'm thinking, mayybe some kind of partial application of Piece?
14:31:19 <tomsmeding> ixlun: nitpick: the (parentheses) are unnecessary :)
14:31:37 <tomsmeding> other than that, looks pretty fine to me /shrug/
14:32:46 <ixlun> problem is, there are 4 other piece kinds to implement which means that list is getting a little too big for my taste
14:32:51 <tomsmeding> ah ok
14:36:00 <tomsmeding> ixlun: https://paste.tomsmeding.com/Rt4m1lDe (warning: untested, just typed it right into the textbox)
14:36:05 <tomsmeding> is that better?
14:36:25 <tomsmeding> oh crap that's wrong
14:36:45 <tomsmeding> should be this https://paste.tomsmeding.com/zscQ2h6N
14:39:24 <tomsmeding> (I'm off to bed)
14:41:19 * hackage http-link-header 1.1.1 - A parser and writer for the HTTP Link header per RFC 5988  https://hackage.haskell.org/package/http-link-header-1.1.1 (SShuck)
14:41:31 <ixlun> Great, thanks tomsmeding, I'll take a look at that :-)
15:16:32 <itai33[m]> what do you guys think about using an alternative prelude like relude for a first real world haskell project? 
15:16:47 <itai33[m]> are there better options than relude? is it a bad idea?
15:18:33 <koz_> Is there some combination of type class constraints which effectively says "I am a signed, fixed-width, number"?
15:20:59 <triteraflops> itai33[m]: I'm looking at relude right now. Seems like a good idea
15:22:17 <monochrom> koz_: I think int-cast is, mentioned a few days ago
15:23:19 <monochrom> Actually Data.Bits.FiniteBits should also do
15:26:13 <triteraflops> I'm reading http://hackage.haskell.org/package/relude. What does "IO actions are lifted to MonadIO" mean?
15:29:30 <triteraflops> relude doesn't look too popular compared to, say, text.
15:29:48 <triteraflops> Are there more popular and still just as sane prelude alternatives?
15:30:58 <koz_> monochrom: Data.Bits.FiniteBits together with like, Num, I guess?
15:31:27 <monochrom> Oh, I forgot the "signed" part.
15:32:19 <itai33[m]> <triteraflops "Are there more popular and still"> I know that there is such a thing as ClassyPrelude but that is about it
15:32:35 <amf> triteraflops: I use relude and very happy with it, if you are just learning it's a good way to enforce good habits
15:33:10 <amf> triteraflops: lifted into MonadIO means it abstracts away the `f :: IO a` part to `f :: MonadIO m => m a` so you aren't forced into the IO monad for the computation
15:33:26 <triteraflops> http://hackage.haskell.org/packages/tag/prelude
15:33:41 <triteraflops> looks like it's the 5th most popular, so itai33[m] maybe check out the other top 5
15:34:00 <triteraflops> just sort by #DLs
15:34:02 <sm[m]> itai33: rio might also be worth a look
15:34:07 <triteraflops> or maybe by rating
15:34:38 <triteraflops> and mind Last U/L
15:34:39 <itai33[m]> in all honesty I was more interested in the question of whether or not this is a good idea
15:34:49 <sm[m]> "it depends" :)
15:34:59 <itai33[m]> cause like idk maybe there is some value in using the normal prelude
15:35:10 <triteraflops> I think it is a good idea iff the alt prelude will be supported into the future
15:35:18 <triteraflops> otherwise, a good idea
15:35:25 <itai33[m]> I am writing an application, not a library if that matters
15:35:43 <triteraflops> enforcing NonEpty and using Text instead of String are very good ideas
15:35:58 <triteraflops> regardless whether it's a library or application
15:36:03 <triteraflops> *NonEmpty
15:36:14 <sm[m]> yeah if you're learning haskell your instinct to use base may be right. On the other hand, there's so much missing from it that you might save time just learning a good alternative, if the app is "real world"/big
15:36:37 <sm[m]> less imports & packages to slow you down
15:36:58 <sm[m]> and more architectural guidance
15:37:22 <itai33[m]> The plan is to essentially recreate ncmpcpp in haskell
15:37:23 <triteraflops> amf: re lifting, good to know
15:37:36 <itai33[m]> I don't know if that's big or not I've never really written an app before
15:37:54 <triteraflops> suppatime over here
15:37:59 * triteraflops supps
15:38:36 <sm[m]> try two parallel versions and hopefully you'll prefer one of them pretty quickly ?
15:38:53 <itai33[m]> maybe
15:39:13 <itai33[m]> I think I'll just look over the prelude options and choose the one that seems best
15:39:22 <itai33[m]> cause I do want to use Text everywhere anyway
15:39:33 <itai33[m]> and hey we do have one vote for relude from amf
15:39:54 <itai33[m]> I do have a bit of a general quesiton though
15:40:53 <sm[m]> amf: are relude and rio similar do you think ?
15:41:32 <itai33[m]> I know that in general, once something has been "wrapped" in a monad it is highly nontrivail to get it out, but If I have an `Either Maybe a` that I know for a fact is a `Right Just x` is there a way to extract the `x` in order to have an easier time iteratively write the program?  
15:42:12 <itai33[m]> this feels like one of the times where I'm not getting something about the whole monad vibe of haskell, because this is the type of thing that would be easy to do in procedural programming
15:42:26 <dolio> Worrying about what's in a prelude module doesn't really seem like a 'real world' concern to me.
15:42:53 <sm[m]> itai33: sure, for that you can use either a case pattern or the fromRight function. This will be partial code, so it would cause an error if the assumption is ever false
15:42:57 <itai33[m]> I mean from reading the docs on relude it mainly seems like a way to get a bunch of good functions all in one place
15:43:08 <dolio> And rio and relude don't look like "preludes". They're a bunch of libraries in one package.
15:43:33 <itai33[m]> @sm
15:43:33 * lambdabot pokes  in the eye
15:43:34 <itai33[m]> shit
15:43:53 <itai33[m]> sm: is there a similar way to extract something from a Maybe?
15:44:01 <sm[m]> case or fromMaybe
15:44:08 <itai33[m]> dolio: is this not what prelude is
15:44:08 <sm[m]> fromJust, I mean
15:44:27 <sm[m]> we know dolio, we're using it in the sense of stdlib/batteries
15:44:41 <monochrom> Which procedural programming language has Either or Maybe for you to worry about to begin with?
15:45:01 <sm[m]> most of the packages are named ..*lude..
15:45:02 <monochrom> Apart from Rust, but Rust would give you the same hurdles.
15:45:47 <itai33[m]> ah I see the issue was that I didn't import `Data.Maybe` so the function didn't show up in ghci
15:45:52 <monochrom> Right? You don't "have to" catch exceptions in C because C has none.
15:45:53 <dolio> itai33[m]: Prelude is the module imported by default in Haskell.
15:46:38 <monochrom> So do people going from C to C++ complain about how exceptions get into the way? Or maybe they do, too.
15:47:19 <itai33[m]> monochrom: I feel like in an imperative language you wouldn't wrap everything like this in the first place, you would just either have the correct value or error out. But this might not be how you write procedural code in the first place, I only really know haskell and elisp and not much of those
15:47:55 <monochrom> Erroring out is very crude for most purposes.
15:47:57 <itai33[m]> dolio: well yeah it's just all the stuff that is available by default, relude just has different defaults
15:49:41 <koz_> @unmtl ReaderT r (Either e a)
15:49:41 <lambdabot> err: `ReaderT r (Either e a)' is not applied to enough arguments, giving `/\A. r -> Either e a A'
15:49:48 <koz_> @unmtl ReaderT r (Either e) a
15:49:48 <lambdabot> r -> Either e a
15:49:57 <koz_> @unmtl ErrorT e (Reader r) a
15:49:58 <lambdabot> r -> Either e a
15:50:07 <monochrom> See this is the irony that bothers me. People call me academic, toy, because I only teach in a university, I don't write 10000 lines of code, I write maybe 100 lines.
15:50:08 <koz_> Lol, yeah yeah isomorphism.
15:50:21 <monochrom> OK I get that, no excuse.
15:50:47 <sm[m]> protolude is used more perhaps it includes a few more important packages (directory, filepath, process, async..)
15:50:51 <monochrom> Then I hear you "real world" people claiming "I know it's a Just so I am looking for fromJust".
15:50:57 <sm[m]> (itai33)
15:51:09 <monochrom> In the real world you almost never "know".
15:51:33 <monochrom> It sounds like your programs are more toys than mine. Errors never happen. Users always give you good inputs.
15:52:19 <monochrom> malloc always succeeds
15:52:27 <monochrom> read() never returns -1
15:52:45 <koz_> Signals never interrupt you in racy ways.
15:53:21 <itai33[m]> monochrom: to be fair, I'm just using this as a way to debug the code, I'd never use this in the end product like why bother writing haskell if you are gonna do that. I'm using "Real World haskell" in the sense that this is the first project that I'm working on in haskell that isn't some structured exercise, is that not what it means? 
15:54:35 <sm[m]> itai33: yes it can certainly mean that, among other things
15:55:07 <sm[m]> another thing you'll need is a command line parser. optparse-applicative or cmdargs are the two full-featured ones
15:55:19 <sshine> is there a way to intercalate a Vector Text without converting to [Text]? is there any point?
15:56:02 <itai33[m]> sm: what's the difference?
15:56:16 <sm[m]> #haskell folks like optparse-applicative, I like cmdargs 
15:56:21 <itai33[m]> lol
15:56:22 <guest-10> Hi! I think this is a Haskell-related issue. Trying to run the interpreter on Aquamacs, but it says that there is "No such file or directory, hugs." Tried googling that to figure out what it means, not much. Do I need to edit my Haskell Preferences?
15:56:27 <itai33[m]> why do you like it better?
15:56:30 <sm[m]> keeping it short for ya :)
15:56:43 <sm[m]> back in the day it was much better documented. Not sure about now.
15:56:55 <sm[m]> also, it accepts abbreviated flags
15:57:32 <sshine> guest-10, sounds like your Aquamacs assumes 'hugs' as the Haskell compiler. nowadays 'ghc' is favored. maybe you should think about bootstrapping your editor with newer defaults. :)
16:00:54 <guest-10> sshine I installed with ghcup today so aren't I working with ghc? (just installed Haskell today so new to this :)  )
16:01:41 <sm[m]> guest-10: it's something to be changed in your Aquamacs settings
16:05:26 <guest-10> sm[m] thanks! Just searched through Aquamacs settings and it said there were no options relating to "compiler"
16:06:00 <sm[m]> it's more of a question for #emacs guest-10, but what are you doing in aquamacs to get that error ?
16:06:35 <nij> Hello.. why doesn't `cabal install timeplot` install a binary to my `~/.cabal/bin`, while `cabal install ghcid` seemed to have done that?
16:06:56 <guest-10> sm[m] run the compiler. It was under the Haskell tab so I figured this was the place to go lol
16:07:10 <sm[m]> how are you running the compiler ?
16:07:20 <sm[m]> selecting a menu option ?
16:07:28 <sm[m]> I see
16:07:37 <guest-10> First tried C-c and C-b and then tried the menu option sm[m]
16:07:53 <sm[m]> I'd try M-x customize-apropos haskell
16:08:19 <sm[m]> or M-x customize-group haskell<complete>
16:08:53 <sm[m]> probably it's in the haskell-mode group
16:09:48 <sm[m]> nij: are you sure ? the executable is named tplot
16:11:43 <nij> sm[m]: Hmm.. based on wiki.haskell.org/Timeplot, it told me to use
16:11:48 <nij> `cabal install timeplot`
16:11:53 <guest-10> How do I run a M-x? sm[m]
16:11:57 <nij> I didn't find `tplot` installed either.
16:12:19 <nij> guest-10: M-x means `Alt-x`
16:12:26 <sm[m]> nij, yes, and if that succeeded it would (normally) install the tplot executable. But maybe it doesn't work with modern cabal
16:12:33 <nij> :(
16:12:36 <sm[m]> there might be an extra flag needed, try --help
16:12:52 <nij> timeplot --help?
16:14:39 <guest-10> sm[m] both of those had no match. Could I have maybe done something wrong with installation?
16:14:50 <sm[m]> no, cabal install --help. I see two related flags near the end, --overwrite-policy and --install-method, but it does sound like it should install a ~/.cabal/bin/tplot one way or another
16:15:13 <nij> sm[m]: tried again.. now it's installed
16:15:18 <sm[m]> when you ran cabal install, if it succeeded it would normally tell you it's installing at the end
16:15:18 <nij> weird :O
16:15:22 <nij> thanks .. 
16:15:32 <nij> it might have some problem the first time
16:15:34 <nij> :/
16:15:47 * sm[m] casts disperse magical assist
16:17:42 <sm[m]> guest-10, sorry I don't have aquamacs here. Did you install it a long time ago ? 
16:17:59 <guest-10> sm[m] no, today
16:18:11 <sm[m]> with brew ?
16:20:35 <guest-10> No, just regular installation on Mac
16:20:44 <sm[m]> or a download from http://aquamacs.org.. I see
16:21:54 <guest-10> yep
16:26:07 <sm[m]> tried to install it, crashed my mac..
16:26:35 <guest-10> oh no!! I'm so sorry, thank you for doing that though
16:30:40 <itai33[m]> I have to say that it is incredibly stupid that I have to either use `Lens` or `Relude` to use the `(??)` function, it's such a no brainer
16:31:24 <itai33[m]> (for the lazy, it's like a reverse fmap, apply e.g. list of functions to element and get list of results)
16:33:58 <solonarv> you can just write 'fmap ($ x) fs'
16:34:18 <solonarv> :t \x fs -> fmap ($ x) fs
16:34:20 <lambdabot> Functor f => a -> f (a -> b) -> f b
16:36:17 <sshine>     Pattern synonym with no type signature:
16:36:17 <sshine>       pattern OpDelegatecall :: forall a. AbstractOpcode a
16:36:18 <sshine>     |
16:36:18 <sshine> 216 | pattern OpDelegatecall = DELEGATECALL       :: forall a. AbstractOpcode a
16:36:27 <sshine> how's that not a type signature?
16:38:49 <dolio> That's not how you give a type signature to a pattern alias.
16:39:18 <dolio> That's probably a pattern with a type signature inside it.
16:40:02 <sm[m]> not your fault guest-10. Wow it was really not happy, two reboots required
16:40:10 <dolio> Assuming the 216 thing is the actual line in the file.
16:41:35 <guest-10> sm[m] So I'm thinking this isn't a Aquamacs issue. I tried reinstalling Haskell using https://www.haskell.org/ghcup/ but then when I tried running ghci on the Terminal, it said the command was not found (and I think it had done that before)
16:43:05 <itai33[m]> solonarv: huh, true
16:45:07 <monochrom> Hey, fmap ($ x) fs = pure ($ x) <*> fs.  pure ($ x) <*> fs is featured in one of the applicative laws!
16:47:30 <sm[m]> guest-10, I think that's another issue, also a good one to fix
16:48:18 <sm[m]> I got aquamacs running. You should go to Haskell -> Customize, and search down for hugs. It's (at least) the Haskell Program Name setting. That's a very outdated default setting provided by Aquamacs, worth a bug report
16:48:44 <monochrom> That's very nostalgic.
16:48:56 <sm[m]> maerwald may be here to help with ghcup
16:49:35 <sm[m]> if not, check the ghcup's output, maybe it said where it installed things
16:49:48 <sm[m]> good luck.. afk o/
17:23:28 <Axman6> solonarv, monochrom: that'
17:23:47 <Axman6> that's just fs <*> pure x right?
17:23:53 <monochrom> Yeah!
17:24:29 <Axman6> was that the point you were making?
17:25:00 <monochrom> I like that law. That's all.
17:26:07 <monochrom> http://files.inconsistent.nl/computer-science.jpg
17:27:07 <monochrom> merijn gave me that link this morning
17:33:53 <itai33[m]> I want to define a bunch of functions that all have the same definition except for one variable in the definition (that isn't an input). what is the best way to define all of them without repeating myself?
17:34:10 <itai33[m]> it kind of feels like I would want a macro
17:34:11 <dsal> itai33[m]: example?
17:34:50 <triteraflops> itai33[m]: how do you choose which function you want?
17:35:21 <dsal> (because the obvious thing to me sounds like input)
17:35:27 <itai33[m]> myAdd = someFunc . (+) . otherFunc
17:35:35 <itai33[m]> myMul = someFunc . (*) . otherFunc
17:35:37 <itai33[m]> ege
17:35:39 <itai33[m]> e.g.
17:35:50 <dsal> myOp o = someFunc . o . otherFunc
17:36:08 <dsal> myAdd = myOp (+); myMul = myOp (*)
17:36:18 <itai33[m]> triteraflops: I essentially have a one to one correspondnce that I know ahead of time between the original values and the output
17:36:34 <Axman6> monochrom: love it
17:36:58 <itai33[m]> dsal: I didn't want have them as input because I have some special cases I need to take care of, but I guess I van just take care of that with pattern matching
17:37:19 <itai33[m]> maybe having a bunch of renamed functions was a bad design choice I got hung up on
17:37:33 <dsal> I can only cover the cases I see.
17:38:07 <itai33[m]> yeah sorry it's like 3am here I don't think I'm phrasing myself well
17:38:08 <Axman6> [mpAdd, myMul] = map myOp [(+),(*)]
17:40:04 <itai33[m]> Axman6: yeah that's kind of what i was reaching for and failing
17:40:24 <itai33[m]> let me see if it works
17:41:19 <Axman6> doing that is a good way to mess up the definitions though if you're not careful, I wouldn't really recommend it
17:41:37 <itai33[m]> but it's so clean looking
17:41:53 <dsal> Heh, it's all out of context.  That may also not be what you want.
17:43:18 <itai33[m]> basically, I have a Map of values, lets call the keys A B C etc. I want to have a funciton a, that extracts the value A and does a bunch of stuff to it that I want to do with all of the values
17:43:27 <itai33[m]> and have a special case for c/C
17:43:32 <itai33[m]> dsal: 
17:44:11 <itai33[m]> your proposal essentailly solves that but i'd like to not have a block of `x= MyOp X` because that's kind of ugly
17:44:26 <itai33[m]> that's why i was aiming for writing something like @Axm
17:44:36 <itai33[m]> Axman6: 's suggestion
17:44:51 <itai33[m]> cause then I only need to write myOP once
17:44:54 <Axman6> [ myAdd, myMul] =
17:44:54 <Axman6>  [(+)  , (*)  ] <&> myOp
17:48:06 <itai33[m]> neat this works
17:48:09 <itai33[m]> thanks dudes
18:00:17 <itai33[m]> is there a way to rename a specific function when importing a module?
18:02:02 <monochrom> No. I want that too.
18:11:22 <itai33[m]> :(
18:11:32 <itai33[m]> sounds like someone should write a GHC extension for that or something
18:13:42 <Axman6> yeah Scala has that, it's the one thing that I've found so far in scala I want
18:14:15 <Axman6> import Data.Foo.Bar as Bar; newName = Bar.oldName
18:17:19 * hackage VulkanMemoryAllocator 0.3.7 - Bindings to the VulkanMemoryAllocator library  https://hackage.haskell.org/package/VulkanMemoryAllocator-0.3.7 (jophish)
18:18:19 * hackage vulkan 3.6.6 - Bindings to the Vulkan graphics API.  https://hackage.haskell.org/package/vulkan-3.6.6 (jophish)
18:20:53 <itai33[m]> any clue why I get a parse error on = on the following function definition?
18:20:59 <itai33[m]> `w = fmap (\tag ->(T.intercalate "," <$>) . (MPD.toText <<$>>) . Map.lookup tag . MPD.sgTags ) [MPD.Artist]`
18:21:06 <itai33[m]> like it's all on line
18:22:39 <itai33[m]> nevermind, I have given incomplete information and the solution was a s mysterious as the problem
18:30:50 <c_wraith> You get a parse error on = if the definition isn't a context that definitions are expected.  This is often the result of messed up indentation earlier.
18:43:21 <triteraflops> I kept on getting tripped up by the while. It was only later I learned that it only works with an =, and not as a standalone expression
18:43:28 <triteraflops> I still don't really understand why lol
18:43:38 <triteraflops> but let ... in ... still works, so whatever lol
18:43:51 <triteraflops> *where, not while
20:47:19 * hackage yhseq 0.3.0.1 - Calculation of YH sequence system  https://hackage.haskell.org/package/yhseq-0.3.0.1 (Hexirp)
20:56:17 <hyiltiz_> How do LISP languages deal with "type errors"? Do they simply become runtime errors? Aka since they do not have types, the class of errors that could've been caught by a type system becomes runtime errors? Also, it is easier to accidentally write general recursive programs that wouldn't have type checked in Hask?
20:56:52 <hyiltiz_> I am reading https://web.stanford.edu/~ngoodman/papers/ConceptsChapter-final.pdf and wondering what if they used a typed lambda calculus as their "model of thought"
20:57:03 <Cale> Haskell supports general recursion, but all the other stuff you said is the case.
20:57:18 <hyiltiz_> wait something is off with my handle 
20:58:06 <Cale> Of course, there is the occasional Lisp-like language which also has a static type system
20:58:12 <Cale> But most of them are dynamically typed
20:59:39 <ggole> Type errors are somewhat different between Lisp and Haskell/ML, they are not just the same thing happening at different stages
20:59:42 <hyiltiz_> Yes Haskell supports general recursive; I was trying to refer to some additional type level (un)wrapping to define things like YC.
21:00:40 <Cale> Yeah, you can define the Y combinator using lambda directly in untyped lisps. You can also make it typecheck in Haskell by defining an appropriate newtype and doing the appropriate wrapping and unwrapping.
21:01:19 <hyiltiz_> pls hold 1 min lemme disconnect and reconnect something wrong with that hyiltiz_ handle
21:01:21 <Cale> (though it's not really a great idea, since the inliner will often choke on it if you're not careful)
21:03:11 <Cale> ggole: Yeah, that's a good point -- a fair number of things which would have been type errors just become incorrect behaviour, rather than runtime exceptions. For example, maybe you accidentally put some elements of the wrong type into a list, and they just get misinterpreted by the remainder of the computation rather than actually causing an exception.
21:03:19 * hackage network-uri-json 0.4.0.0 - FromJSON and ToJSON Instances for Network.URI  https://hackage.haskell.org/package/network-uri-json-0.4.0.0 (alunduil)
21:03:54 <hyiltiz> back
21:04:31 <Cale> There's nothing more frustrating than trying to track down a subtle bug for a few hours, finally figuring it out and realising that even a very basic static type system would have caught it.
21:05:55 <hyiltiz> Cale: could u come up with a simple/trivial example? I am guessing you are talking about coersed types
21:08:07 <dolio> Javascript lets you refer to fields of an object that don't exist, and gives you a value 'undefined' that will only maybe blow up later down the line if you use it the wrong way, without telling you how your program got in that state necessarily.
21:08:24 <dolio> That is easily ruled out by having types that describe which fields actually exist.
21:09:58 <ddellacosta> yeah Clojure is what I use every day, and you can easily find yourself returning a nil value if you are careless and having that, say, populate a vector, which then corrupts some data pipeline or whatever, etc. etc. Easily caught by a static type system, but for some reason people fetishize nil in Clojure (Lisp in general?) it feels like
21:10:14 <ggole> That is somewhat at odds with some of Lisp's interesting features like redefinition or updating classes
21:10:45 <ddellacosta> which/what is?
21:11:12 <ggole> Static typing of the fields of objects/records
21:11:16 <ddellacosta> ah
21:11:56 <ggole> I should point out that I'm not against static typing, I hack in OCaml often. I'm just pointing out there are some consequences to that design.
21:11:59 <ddellacosta> yeah I've been meaning to check out shen in more depth, see what it does there
21:12:13 <ddellacosta> oh yeah, no doubt
23:52:41 <typetetris> What do people use for making https request, you try to avoid cryptonite?
23:53:05 <typetetris> Referring to https://mail.haskell.org/pipermail/libraries/2020-August/030671.html
23:54:58 <Cale> Yeah, that's a painful dependency of http-conduit
23:55:25 <Cale> I'm not sure what I'd do if I really had to care a whole lot.
23:55:55 <Cale> I generally would avoid cryptonite whenever I can, but I'm not super-ultra-religious about it if it's inconvenient.
23:57:04 <typetetris> Isn't there a package, which just uses openssl, polarssl and wraps it up for use?
23:57:19 <Axman6> I feel like a fork of cryptonite is probably warranted. I like the library, but the author's responses to several actual security issues have been far from ideal. The discussion on random number generation irked me, there's not really a good reason IMO to trust a single source of randomness, but when shown trhat there are pretty well known ways to do things better the idea was outright rejected
23:57:44 <Cale> http://hackage.haskell.org/packages/search?terms=openssl
23:58:07 <Cale> HsOpenSSL probably has most of the stuff you'd need
23:58:17 <typetetris> Nice, thanks
23:58:30 <Cale> http://hackage.haskell.org/package/http-client-openssl -- oh nice
23:58:53 <Cale> That's really good to know about
23:58:57 <Cale> I should make sure we're using that
23:59:39 <Axman6> I know carter was at some point working on a libtls binding package, not sure what happened with that
