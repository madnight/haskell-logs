00:11:18 * hackage numhask-space 0.6.0 - numerical spaces  https://hackage.haskell.org/package/numhask-space-0.6.0 (tonyday567)
00:44:49 <koz_> Axman6: wow, such lift
00:50:52 <[exa]> interesting how the type of repeated fmaps develops
00:50:56 <[exa]> :t fmap fmap fmap fmap fmap
00:50:58 <lambdabot> Functor f => (a1 -> b) -> (a2 -> a1) -> f a2 -> f b
00:51:19 * hackage hs-functors 0.1.7.1 - Functors from products of Haskell and its dual to Haskell  https://hackage.haskell.org/package/hs-functors-0.1.7.1 (MatthewFarkasDyck)
01:00:42 <sureyeaah> :t fmap fmap
01:00:43 <lambdabot> (Functor f1, Functor f2) => f1 (a -> b) -> f1 (f2 a -> f2 b)
01:00:50 <sureyeaah> :t fmap fmap fmap
01:00:51 <lambdabot> (Functor f1, Functor f2) => (a -> b) -> f1 (f2 a) -> f1 (f2 b)
01:01:21 <sureyeaah> :t fmap fmap fmap fmap
01:01:22 <lambdabot> (Functor f1, Functor f2, Functor f3) => f1 (f2 (a -> b)) -> f1 (f2 (f3 a -> f3 b))
01:02:19 <[exa]> fmap yeah
01:29:42 <koz_> :t fmap . fmap
01:29:43 <lambdabot> (Functor f1, Functor f2) => (a -> b) -> f1 (f2 a) -> f1 (f2 b)
01:29:48 <koz_> ^ even more interesting
01:36:19 * hackage icfpc2020-galaxy 0.2.0.0 - A strange message received at the Pegovka observatory  https://hackage.haskell.org/package/icfpc2020-galaxy-0.2.0.0 (mniip)
01:54:54 <dminuoso> koz_: why is that even more interesting?
01:55:10 <koz_> dminuoso: Due to a certain Edward talk I'm sure you're aware of.
01:55:25 <dminuoso> Mmm, what talk is that?
01:55:45 <koz_> Something about lenses.
01:55:49 <koz_> I forget the exact one.
01:56:08 <dminuoso> Yeah, that helps narrow it down. There aren't many talks about lenses from edward.
01:56:23 <koz_> Lol.
01:59:13 <dminuoso> Are you talking about their meaning as semantic editor combinators?
01:59:39 <koz_> Yeah, those were the words I remember Edward using in said talk.
01:59:48 <koz_> Along with 'traverse . traverse . traverse'
02:14:01 <Marked> Hello ppl... are all data structures implemented in haskell itself or in C like in python? My question is.. is GHC doing all the job and standard libs are writen in haskell.. or they use kind of trick like native in java?
02:16:01 <tdammers> it depends
02:16:19 <tdammers> some data structures, like lists or trees, can be written in native Haskell without any tricks
02:16:42 <davve> I thought it used C--
02:16:48 <[exa]> Marked: the data structures (lists, maps, sets, vectors) are defined in haskell, except for the very basic ones (RTS specifies the low-level thunks and boxes, and I believe there's some minor support for arrays)
02:17:03 <koz_> davve: C-- is generated as part of compilation.
02:17:07 <tdammers> some others require a bit of trickery, such as vectors and bytestrings, but even those are generally implemented in terms of (sometimes GHC-specific) native Haskell APIs
02:17:13 <koz_> We don't actually write it.
02:17:14 <[exa]> Marked: from the java point of view it would basically mean they'd be "implemented in java"
02:17:22 <davve> ok
02:17:24 <tdammers> C-- is an implementation detail, you don't normally write code in it
02:17:51 <tdammers> there is a C FFI, and it can be used to implement data structures, but it is rarely necessary, and AFAIK the "base" library does not use it
02:18:31 <tdammers> people mostly use the C FFI to wrap existing C libraries so that they can be used in Haskell
02:18:46 <tdammers> but when you're writing the code from scratch, the go-to approach is to keep it in Haskell.
02:19:21 <Marked> So standard library does not use c FFI... its is for calling C bindings from haskell.. got it... its like JNI in Java
02:20:10 <Marked> So all things can be expressed with RTS specifies the low-level thunks and boxes, and I believe there's some minor support for arrays) ?
02:20:46 <tdammers> it's not really minor, just a bit of a minefield to use correctly
02:21:20 <tdammers> that is, GHC exposes a lot of functionality that provides approximately C levels of safety (i.e., almost none), and if you use those, you forfeit most of the type checker safeguards
02:21:38 <Marked> I guess if data structure has to be fast and immutable in same time.. there has to be some 'magic' under hood. 
02:21:48 <tdammers> so for example you can do manual memory management, but of course that puts the responsibility with yuo
02:22:14 <Marked> Oooh got it.
02:22:21 <[exa]> Marked: there's a lot of research into high-performance functional data structures, you may start googling zipper lists and finger trees
02:22:32 <Marked> THank you
02:22:38 <tdammers> the magic is that those data structures use what we sometimes call "moral purity" - they have a pure API that is advertised as such, but behind the scenes, they use destructive operations to (massively) speed things up
02:23:04 <tdammers> the bytestring library, for example, makes heavy use of this approach
02:24:19 * hackage chart-svg 0.1.2 - Charts in SVG  https://hackage.haskell.org/package/chart-svg-0.1.2 (tonyday567)
02:26:42 <Marked> Oh you should not have told me.. now I am tempted to implement my own datastructure... I am still not even beginer with haskell...:D
02:27:09 <Marked> I must  forget my procedural habits....
02:27:47 <Marked> thank you all...
02:29:16 <tdammers> implementing a couple simple data structures yourself is a good way of learning Haskell
02:29:38 <tdammers> lists, Maybe, trees, those are all straightforward
02:29:56 <tdammers> and implementing them yourself, and some operations to boot, will teach you a lot about Haskell
02:32:44 <kuribas> and implementing Monad/Functor instances
02:34:00 <tdammers> Functor, Applicative, Monad, Alternative, Monoid, Semigroup, you name it
02:34:21 <tdammers> I'd recommend starting with just Monoid/Semigroup and Functor though
02:35:15 <gentauro> tdammers: what about a Monad instance for let say a `Map`?
02:35:18 <gentauro> xD
02:35:39 * gentauro read `Map` as a `Dictionary`
02:36:25 <Marked> Thank you... I am not yet near enough monads (heard about them a lot) Just learning haskell after years of programing in asm, c, python, js, java.... And I have to say I really fell in love with haskell.
02:36:42 <gentauro> Marked: that's good to hear :)
02:37:40 <phadej> I really wonder what it is like to learn Haskell in 2020
02:38:37 <Marked> I am following http://learnyouahaskell.com/ right now..Its good.
02:38:39 <phadej> (my first Haskell experiences are before "social media" -era)
02:40:42 <Marked> I heard haskell has just few good sources.
02:41:18 <phadej> you only need few, if they are good!
02:41:46 <Marked> Community is not so big. On one hand few sources for learning.. on the other hand look how many ppl program in JS and what a mordor it is.
02:41:54 <[exa]> Marked: learnyouahaskell doesn't have much exercises, but if you've done some programming you can easily make up your own. otherwise it's great (the pictureS!!)
02:41:59 <Marked> phadej agree
02:42:02 <gentauro> Marked: I would highly suggest that you try to implement a "hobby project", that you normally would do in another language, in Haskell. And force yourself with a deadline or it will just end like this :) https://www.commitstrip.com/en/2014/11/25/west-side-project-story/
02:42:52 <gentauro> Marked: this is my recent "hobby project" almost written entirily in Haskell (80%) https://gitlab.com/spisemisu/pcx-utils
02:43:35 <gentauro> Marked: for the hole project, I just needed this single `Monad` instance -> https://gitlab.com/spisemisu/pcx-utils/-/blob/master/src/Data/PCx/Byte/Parser.hs#L126-131
02:43:37 <[exa]> Marked: oh and for starting -- the first thing I throw at the haskell students is Gloss, you can paint wild animated stuff in there without much effort.. See https://hackage.haskell.org/package/gloss-1.13.1.2/docs/Graphics-Gloss.html
02:43:38 <gentauro> ;)
02:44:09 <gentauro> 11:38 < Marked> I am following http://learnyouahaskell.com/ right now..Its good.
02:44:12 <gentauro> I agree
02:46:08 <orcus> I have an AST and want to do a bunch of operations on it, say checking if we ever have an App as the left child of an App.
02:46:38 <orcus> All of these are easy to code up by hand, but rather tedious. Any library recomendations to make it slicker?
02:47:53 <gentauro> orcus: could you provide a sample of the AST? (https://pastebin.ubuntu.com/ is really good)
02:48:27 <Marked> THank you all... :)  gonna try fiddling with haskell little more...Dont worry I will be right back with some stupid question. xD
02:49:05 <[exa]> Marked: people here usually love to help, many of us are in fact teaching this :D
02:49:26 <orcus> Sure, but it doesn't matter too much I expect. Eventually I'll have a bunch of different ones I expect, for lambda calculus and arithmetic etc. I'll pastebin something also.
02:51:38 <Marked> [exa] so you are teacher... In university i guess? Is it common to teach functional programming in west?
02:51:52 <Marked> A lot of assumptions.. sorry.
02:53:50 <mniip> can confirm, gloss is an absolute godsend
02:54:30 <mniip> I can't express how easy it is to make a visualization for something compared to literally any other graphics library I've worked with
02:54:47 <Marked> Will try it today.
02:55:24 <gentauro> Marked: as some person, working at Microsoft Cambridge told me: "If you want to get FP adoption for regular people, try to stay away from Universities". As a person who organizer FP events in Denmark (Copenhagen) once we did an F# event at a Technical University (DTU). I had invited a lot of people which I knew was dealing with basic "JSON/XML" daily task. 
02:55:32 <orcus> @gentauro: https://pastebin.ubuntu.com/p/GBXh96Gv9y/
02:55:32 <lambdabot> Unknown command, try @list
02:55:47 <orcus> gentauro: https://pastebin.ubuntu.com/p/GBXh96Gv9y/
02:56:00 <gentauro> the profesor had one of his PhD student make some tasks for us. The first one was something about how you "reduce a polynomial".
02:56:29 <gentauro> I mean, many of the people dealing with "XML/JSON" on a regular basis didn't knew jack-sh*t about that topic.
02:57:00 <mniip> reducing a polynomial sounds very familiar
02:57:13 <mniip> that's a canonical example I use for demonstrating conciseness of haskell
02:57:16 <Marked> gentauro :D  
02:57:28 <gentauro> and they were kind of `p*ssed` cos they wasted a afternoon so some (young) PhD could laugh at their faces (that's not how you get FP into end user adoption)
02:58:34 <gentauro> Marked: so my best advice is try to go for a (non-trivial) "hobby project" (network, dealing with data as JSON, â€¦)
02:59:02 <mniip> gentauro, YMMV
02:59:05 <gentauro> and understand the reason why `Monads` and other constructions are needed
02:59:23 <mniip> different things work for different people
02:59:48 <kuribas> mniip: most of the guys here know math well, and like it
03:00:13 <mniip> yeah that's what I'm saying
03:00:15 <gentauro> Marked: if you choose to use `aeson` for JSON, you will easily learn to distinguish when to use `Applicative` and when to use `Monad` (I got tips from this channel btw)
03:00:18 <gentauro> :)
03:00:37 <kuribas> and haskell is not that great for numerical computing anyway.
03:00:39 <gentauro> mniip: I went to uni and have a degree in cs with minors in math
03:01:03 <mniip> kuribas, there's a ton of math that's not related to numerical computing
03:01:15 <gentauro> kuribas: and while studying, there were always these two guys that instead of solving the task, they just wanted to "show how much they knew"
03:01:17 <kuribas> it's not great for symbolic computing either
03:01:33 <gentauro> they always ended up missing the point
03:01:39 <gentauro> xD
03:01:41 <mniip> not all math is centered around formulas
03:01:42 <kuribas> it could be great, given a good library like sympy, but that doesn't exist
03:02:37 <gentauro> Marked: out of curiosity? Do you use `do-notation` or `â€¦ >>= â€¦`?
03:02:47 <kuribas> well, I should clarify, haskell could be great for numerical and symbolic computing, but currently it isn't
03:02:51 <mniip> one of my first haskell projects was a computational logic tool
03:02:56 <gentauro> I think this will also have an impact on how to learn Haskell
03:03:35 <mniip> well, among decently sized projects at least
03:04:25 <gentauro> 11:46 < orcus> All of these are easy to code up by hand, but rather tedious. Any library recomendations to make it slicker?
03:04:41 <mniip> bottom line is, haskell is a general purpose language. Do a hobby project in whatever area you are familiar with/interested in
03:05:06 <gentauro> orcus: my bad, I don't know any libs 
03:05:51 <gentauro> kuribas: Haskell can be used for everything
03:06:00 <gentauro> it's just a matter of `pace`
03:06:05 <kuribas> gentauro: wouldn't it be better to show a Servant application, how you can do many interesting things with the API as a type?
03:06:10 <orcus> gentauro: np. I'm sure there must be some fancy generic stuff - I'll keep looking!
03:06:16 <mniip> interesting to whom
03:06:23 <mniip> different people find different things interesting
03:06:29 <kuribas> mniip: people who program backend services?
03:06:50 <mniip> I program backend services (in servant) for a living and it's extremely mediocre
03:07:20 <kuribas> mniip: but is there a better alternative?
03:07:27 <Marked> gentauro I am not advanced enough to use  `do-notation` or `â€¦ >>= â€¦`
03:07:39 <mniip> an alternative to servant/API as types?
03:07:43 <Marked> I am at modules chapter right now.. after function composition
03:07:47 <mniip> I don't know but also that's not what I'm arguing
03:07:47 <kuribas> mniip: yes
03:07:56 <mniip> I'm arguing about whether that's interesting
03:08:00 <dminuoso> Marked: I think you are perfectly advanced enough to use either at any level. :)
03:08:22 <kuribas> mniip: we're doing an API in clojure right, and I would love seeing it in Servant.
03:08:26 <gentauro> 12:05 < kuribas> gentauro: wouldn't it be better to show a Servant application, how you can do many interesting things with the API as a type?
03:08:56 <gentauro> kuribas: my point of showing my own "hobby project" was just to minimize how much effort you need to put into `Monads` ;)
03:09:09 <kuribas> gentauro: making sure docs are up to date with the API, validating the API, etc...
03:09:56 <kuribas> mniip: I mean, it's mediocre compared to what?
03:10:20 <gentauro> mniip: to be fair, I would rather do stuff with Servant than with clojure ;)
03:10:22 <mniip> I find more theoretical applications of haskell interesting
03:10:54 <gentauro> we get som Clojure talks once in a while at MF#K and gosh, it mostly look like Perl :|
03:11:00 <mniip> did you know you can manage C++ style RAII with CodensityT?
03:11:26 <gentauro> 12:07 < Marked> gentauro I am not advanced enough to use  `do-notation` or `â€¦ >>= â€¦`
03:11:34 <gentauro> don't worry, you will get there at some point ;)
03:12:11 <kuribas> mniip: I am not arguing that servant could be improved, but I just wonder what I am missing out, when you say it's mediocre.
03:12:43 <kuribas> mniip: because for a pure JSON REST API, servant looks a lot more convenient than the other approaches (scotty, spock, etc...)
03:13:06 <kuribas> mniip: not that I know them all very well of course...
03:13:08 <mniip> maybe I should've used a better word
03:13:14 <mniip> "mundane"
03:13:45 <kuribas> mundane if you're used to it maybe?
03:13:59 <kuribas> I take a lot of haskell for granted, but when I do clojure, I see how much I miss.
03:14:15 <kuribas> (or python)
03:15:07 <oxide> gloss
03:15:48 <oxide> uh sorry, i was trying to search that instead of sending it into chat
03:19:36 <kuribas> a lot of the "exciting stuff" in haskell becomes just normal after a while, just like work.
03:19:50 <kuribas> it's only when you program in another language you realise how nice it is.
03:30:05 <kuribas> that's not to say it can't be improved of course :)
03:34:09 <sshine> a friend of mine implemented crude algebraic data types in Perl. ;-)
03:36:00 <sshine> first step towards saner Perl: Maybe($value)->map(sub { ... })->$* ;-P
03:41:08 <int-e> This ("saner Perl") may be one of those premises that don't get you anywhere.
03:41:32 <gentauro> sshine: `Maybe($value)->map(sub { ... })->$* ;-P` what does `;-P` mean in Perl?
03:42:06 <kuribas> To be fair, haskell can look like linenoise as well
03:42:50 <kuribas> gentauro: a comment to make the perl interpreter happy?
03:42:58 <gentauro> sshine: and while we are at it: `->$*` ???
03:43:34 <int-e> kuribas: Oh yes. https://wiki.haskell.org/Obfuscation
03:44:10 <gentauro> int-e: you just need to transform you code to debrujn indexes and then back again ;)
03:44:19 <gentauro> that should obfuscate it for most people ;)
03:44:48 <kuribas> int-e: it should have included unicode :)
03:44:50 <int-e> there's a term for this: alpha-conversion.
03:44:55 <int-e> :P
03:45:23 <int-e> kuribas: it's just possible that that particular entry predates proper (reliable) unicode support
03:48:42 <miguel_clean> hmmm, is there no function in the standard libraries that does: "something f a b = if f a then a else b" ?
03:54:00 <gentauro> miguel_clean: have you tried on Hoogle?
03:54:19 * hackage either-result 0.2.0.0 - â€˜Result aâ€™ is a wrapper of â€˜Either String aâ€™.  https://hackage.haskell.org/package/either-result-0.2.0.0 (kakkun61)
03:54:22 <gentauro> https://hoogle.haskell.org/
03:54:50 <miguel_clean> gentauro: Tried this: "(a->Bool)->a->a->a" without luck...
03:55:26 <miguel_clean> which makes me wonder, since this seems like a quite common pattern to me
03:55:57 <gentauro> miguel_clean: you should look for `(a -> Bool) -> a -> b -> Either a b`, that's at least what your function states
03:56:55 <miguel_clean> my function implies that the params "a" and "b" are of the same type I believe... 
03:57:25 <gentauro> oh, my bad `a` and `b` are of thE same type
03:58:31 <miguel_clean> :t (\f a b -> if f a then a else b)
03:58:33 <lambdabot> (p -> Bool) -> p -> p -> p
03:59:13 <miguel_clean> yep
04:00:44 <gentauro> miguel_clean: https://hackage.haskell.org/package/binary-search-1.0.0.3/docs/Numeric-Search-Range.html#v:searchFromTo
04:00:47 <gentauro> ?
04:00:59 <gentauro> but it returns a maybe though
04:01:45 <sureyeaah> Nothing in standard libraries but you could use guarded to get ` fromMaybe b . guarded f $ a`
04:03:17 <orcus> miguel_clean: There is a function `bool::Bool -> a -> a -> a`, which may help (compose it with f)
04:04:03 <orcus> (or even `bool :: a -> a -> Bool -> a`)
04:05:53 <miguel_clean> ok thanks, guess this is the closest what I can get... guarded uses bool underneath in fact
04:11:49 * hackage either-result 0.2.0.0 - â€˜MonadFailâ€™ instance for a wrapper of â€˜ExceptT String m aâ€™.  https://hackage.haskell.org/package/either-result-0.2.0.0 (kakkun61)
04:28:36 <jacks2> is there an extension that will automatically initialize uninitialized Maybe fields to Nothing?
04:32:56 <Axman6> jacks2: no
04:54:13 <Marked> :t Data.Map.fromList
04:54:15 <lambdabot> Ord k => [(k, a)] -> M.Map k a
04:54:38 <Marked> Why it has Ord type class? Isnt Eq enough? And in the end.. Map dont have ordering.
04:54:56 <merijn> eh
04:55:01 <merijn> Map's *do* have ordering
04:55:08 <merijn> else their performance would be god awful
04:55:32 <Arahael> It's just that that ordering isn't neccessarily defined or specified.
04:55:39 <Marked> Yeah... thats possible but that is implementation detail imho.
04:55:44 <merijn> Marked: No
04:55:51 <merijn> Marked: It's explicitly guaranteed part of the interface
04:56:33 <merijn> Arahael: eh, Map's are even an instance of Ord, so for all possible interpretations of "Maps are ordered" is true ;)
04:56:41 <Marked> Yeah.. because it is in interface...hmm.. maybe it is lesser evil.
04:56:46 <Arahael> Ah, nice.  Haskell's awesome :)
04:56:57 <merijn> Marked: How would you build a map without ordering?
04:57:06 * Arahael forgot the channel he was in.
04:57:11 <bitmapper> computers don't like disorder haha
04:57:11 <merijn> Arahael: "instance (Ord k, Ord v) => Ord (Map k v)" :p
04:57:28 <Marked> with hash function that will map to int that have ordering
04:57:42 <Arahael> merijn: Yeah, to be honest, I forgot I was in #haskell, and thought I was in #programming. :)
04:58:32 <merijn> Marked: That just means you need a Hashable constraint instead of Ord
04:58:39 <merijn> Marked: Which, in fact, exists
04:58:56 <merijn> https://hackage.haskell.org/package/unordered-containers-0.2.11.0/docs/Data-HashMap-Lazy.html
04:59:27 <merijn> fromList :: (Eq k, Hashable k) => [(k, v)] -> HashMap k v
05:03:06 <Marked> Hmmm I see
05:03:09 <Marked> THank you
05:05:20 <alehander92> so, do people use `(name arg arg)` a lot?
05:05:38 <alehander92> i find i use parens more than I expected, and my code sometimes look a bit lisp-y
05:05:54 <merijn> alehander92: not really, except in ambiguous contexts
05:05:57 <merijn> Which are pretty rare
05:06:06 <merijn> alehander92: Do you have an example?
05:06:19 <merijn> Maybe you're missing a cleaner way of writing it
05:08:39 <Arahael> The trouble with '( ... )' is you have to put a symbol on *both* sides.  Easier to just to a let, or a where, or to use $, or to use, well, other things.
05:12:56 <kuribas> alehander92: nope, I always remove unnecessary parentheses
05:13:14 <kuribas> alehander92: the only case where I might use them is if fixity isn't clear
05:13:49 <kuribas> especially with a combination of (<$>), (>>=), (<*>)
05:13:57 <dminuoso> merijn: Btw, you're a heavy prettyprint user iirc. Do you use Writer a lot with it?
05:16:15 <dminuoso> In particular, ive started with this style of `Writer [Doc ann]` in a lot of places.
05:16:42 <dminuoso> (I frequently consume those with some `vsepWriter = vsep . runWriter`)
05:16:56 <dminuoso> Just curious what your thoughts on this are.
05:17:24 <dminuoso> It makes things like: whenJust :: Applicative f => Maybe a -> (a -> f ()) -> f ()
05:17:35 <dminuoso> *it enables
05:17:57 <merijn> I'd say I'm a moderate prettyprint user at best :p
05:18:02 <dminuoso> heh fair enough :)
05:18:16 <dminuoso> (I should add, that I generate machine config with prettyprinter)
05:18:21 <merijn> A Writer with list of Docs seems weird
05:18:26 <dminuoso> Very few of my uses are user-facing. 
05:18:29 <merijn> Like, why the list
05:18:39 <dminuoso> Haha, that's a longer story
05:19:00 <dminuoso> I used to have `tellLine :: Doc ann -> Writer (Doc ann)`
05:23:27 <dminuoso> The list of docs is because I needed to keep output compatibility to old versions. So I collapse that list with different functions in different places, inserting additional whitespace noise to do just that.
05:24:23 <dminuoso> We didn't have the time to test whether the change of whitespace noise had some unintended side effect back then. It was faster to just switch to list of docs, since we had to deploy the very same night.
05:25:48 <dminuoso> Like any engineering feat, nothing lasts as long as a stopgap.
05:35:08 <kuribas> logging-effect also uses Doc
05:35:38 <kuribas> though logs don't need to be pretty, do they?
05:35:45 <kuribas> they should be greppable
05:35:47 <dminuoso> Sure they do.
05:35:57 <dminuoso> dont assume what happens wit the logs
05:36:08 <dminuoso> maybe you want to display them, say via stdout?
05:36:24 <dminuoso> Like, consider what ghc outputs in terms of warnings perhaps as a log?
05:37:17 <kuribas> that's different
05:37:36 <kuribas> because compiler errors are expected :)
05:38:00 <kuribas> I am more thinking about services running as deamons.
05:38:44 <dminuoso> There's plenty of logging things that make sense to log with formatting.
05:39:30 <dminuoso> Think of some networking service that has debug levels, and at each debug level it would maybe prettyprint a different protocol level of the communication.
05:39:53 <dminuoso> Not all things emit single-line log entries. :)
05:40:51 <sm[m]> +1, I rely on pretty printed debug output
05:41:46 <sm[m]> though I'm not logging it. But, General Agreement
06:01:14 <jacks2> @hoogle &
06:01:15 <lambdabot> Data.Function (&) :: a -> (a -> b) -> b
06:01:15 <lambdabot> Control.Lens.Lens (&) :: () => a -> (a -> b) -> b
06:01:15 <lambdabot> Control.Lens.Operators (&) :: () => a -> (a -> b) -> b
06:01:48 <jacks2> @hoogle <&>
06:01:49 <lambdabot> Data.Functor (<&>) :: Functor f => f a -> (a -> b) -> f b
06:01:49 <lambdabot> Control.Lens.Lens (<&>) :: Functor f => f a -> (a -> b) -> f b
06:01:49 <lambdabot> Control.Lens.Operators (<&>) :: Functor f => f a -> (a -> b) -> f b
06:02:01 <jacks2> I don't have either function 
06:02:05 <jacks2> when were they introduced?
06:02:31 <jacks2> actually I have &
06:09:11 <tomsmeding> jacks2: it says <&> is since base 4.11.0.0 https://hackage.haskell.org/package/base-4.14.0.0/docs/Data-Functor.html#v:-60--38--62-
06:19:14 <alehander92> kuribas merijn thanks
06:19:25 <alehander92> well nothing in particular, i was just wondering if it's a code smell
06:19:43 <alehander92> you're right that I can probably use `$` and `.` more
06:22:00 <jacks2> tomsmeding thanks, I didn't know hackage included that information
06:25:32 <tomsmeding> jacks2: sometimes libraries do that, in particular I know that 'base' does that often for newer things
06:37:49 * hackage hascard 0.2.1.0 - A TUI for reviewing notes using 'flashcards' written with markdown-like syntax.  https://hackage.haskell.org/package/hascard-0.2.1.0 (Yvee1)
07:17:05 <Marked> Guyz is there performance difference between (a . b . c) d and between a $ b $ c d?
07:17:41 <merijn> Marked: Yes, no, maybe
07:18:01 <merijn> Not anything significant to care about
07:18:12 <Marked> thx
07:18:21 <tdammers> in an ideal world, both would optimize down to the same code
07:18:56 <tdammers> however, in practice, depending on what a, b, c, and d are, they might not, because the compiler might apply optimizations in a different order and get different results from various heuristics
07:19:43 <phadej> unluckily
07:19:51 <phadej> inlining (.) would probably happen quite early
07:20:23 <phadej> "merijn Not anything significant to care about"
07:20:57 <Marked> yeah.. thanks
07:21:14 <tdammers> under normal circumstances it won't make a big difference, it's just something to remember for those rare cases when it does
07:22:16 <xsperry> audiofile, off the top of my head, haskell allows that. but I'm sure there are many others languages 
07:22:42 <Cheery> It's sort of frustrating to write about something that you know doesn't do anything because you're poking ego or identities of people.
07:23:34 <Cheery> then you know that, write it to the first line of the post, and avot, it's true.
07:24:14 <Marked> In imperative programing there exist tight loops, 3 times nested when Its not feasible e.g. join strings with + operator. Better to use StringBuilder. Just example.
07:24:19 <MarcelineVQ> idk what that means but just write what you want to write
07:25:34 <Marked> Yeah we do not have loops here.. hmm..
07:25:57 <merijn> Sure we do, loops, recursion, it's all the same if you squint
07:26:39 <phadej> Marked: same applies to haskell, don't concatenate `ByteString`s, use `Builder` (or Strings vs. ShowS)
07:26:49 <phadej> but caring about (.) vs ($) is on the level of style
07:26:55 <Marked> Ah I see.. 
07:27:00 <Marked> Yeah I got it..
07:28:13 <maralorn> Is there a NonEmpty analogon for Seq?
07:28:39 <maralorn> Apparently yes 
07:30:11 <phadej> `Seq` could be made into non-empty, (i.e. otherwise then by consing one element as in https://hackage.haskell.org/package/non-empty-sequence-0.2.0.4/docs/Data-Sequence-NonEmpty.html)
07:30:54 <phadej> or maybe it's not
07:30:59 <phadej> https://github.com/haskell/containers/issues/608#issuecomment-478402070
07:38:50 <MarcelineVQ> That's an interesting idea, factoring out Bin
07:39:33 <MarcelineVQ> or whicever your branch/node constructor is
07:42:48 * hackage egison-pattern-src 0.2.1.1 - Manipulating Egison patterns: abstract syntax, parser, and pretty-printer  https://hackage.haskell.org/package/egison-pattern-src-0.2.1.1 (coord_e)
07:43:48 * hackage egison-pattern-src-th-mode 0.2.1.1, egison-pattern-src-haskell-mode 0.2.1.1 (coord_e): https://qbin.io/poly-aol-dxim
07:50:49 * hackage rpmbuild-order 0.4.2 - Order RPM packages by dependencies  https://hackage.haskell.org/package/rpmbuild-order-0.4.2 (JensPetersen)
07:59:08 <ezzieyguywuf> hah, turns out my glfw issue yesterday was purely self-inflicted. I was trying to use it on a windows VM, but I didn't have a graphics card enabled that supported 3d.
08:04:38 <[exa]> ezzieyguywuf: why windows VM though? :]
08:22:11 <ezzieyguywuf> [exa]: lol, because it's easier? lol
08:22:18 * hackage either-result 0.3.0.0 - â€˜MonadFailâ€™ instance for a wrapper of â€˜ExceptT String m aâ€™.  https://hackage.haskell.org/package/either-result-0.3.0.0 (kakkun61)
08:32:48 <sm[m]> ezzieyguywuf: good one :)
08:33:36 <ezzieyguywuf> sm[m]: srsly!
08:33:56 <sm[m]> I'm still curious, how did it manifest ? What did you see that told you things weren't working ?
08:35:37 <ezzieyguywuf> sm[m]: https://hackage.haskell.org/package/GLFW-b-3.3.0.0/docs/Graphics-UI-GLFW.html#v:createWindow this returned Nothing
08:36:13 <ezzieyguywuf> well, it was either that or https://hackage.haskell.org/package/GLFW-b-3.3.0.0/docs/Graphics-UI-GLFW.html#v:init, I return the same error message in both cases (I could probably improve that in my code...)
08:37:12 <sm[m]> aha. Not a very informative api there, it would be nice if it returned an error code
08:37:54 <ezzieyguywuf> sm[m]: yes, this is true. The glfw library itself seems to return more error information
08:40:05 <ezzieyguywuf> sm[m]: although I have a feeling some if not most of the potential error values in the c-library are type-checked in the haskell wrapper, so maybe that's why the author of the wrapper decided to keep it as a Maybe
09:13:06 <polux2001> Hi, is there a traversal for focusing on many Data.Map keys at once? something like "at" that would take a list of keys
09:28:08 <phadej> :t indices
09:28:09 <lambdabot> Ix i => Array i e -> [i]
09:28:12 <phadej> nope
09:28:41 <phadej> this one, https://hackage.haskell.org/package/lens-4.19.2/docs/Control-Lens-Indexed.html#v:indices
09:30:52 <polux2001> phadej: thanks, I've thought of using this but it will iterate over the whole Map instead of just looking up the indices I'm interested in
09:32:33 <phadej> > Data.Map.fromList [('x', 1),('y',2),('z',3)] ^@.. itraversed . Control.Lens.indices (`elem` "yz")
09:32:35 <lambdabot>  [('y',2),('z',3)]
09:33:17 <phadej> polux2001: I think `Data.Map` API doesn't provide anything better anyway
09:34:33 <phadej> I vaguely remember there were some discussion on having such functionality in containers on its (github) issue tracker
09:34:38 <phadej> you should check there
09:39:37 <polux2001> phadej: about  I think `Data.Map` API doesn't provide anything better anyway", it is still faster to call insert n times successively on a map than to iterate n times over the whole Map
09:40:03 <phadej> polux2001: traverse will iterate only once
09:40:13 <polux2001> yeah sorry
09:40:16 <polux2001> I got that wrong
09:40:22 <polux2001> but if the map is huge
09:40:44 <phadej> yes, but there is no right answer. What if your element set is half of the map keys
09:40:49 <polux2001> it will be faster to insert n times than going over a Map of size m when m >> n
09:40:55 <phadej> or worse, huge, so only few elements are in the map
09:41:00 <phadej> it depends
09:41:05 <polux2001> good point
09:41:20 <phadej> no *single* right answer.
09:41:43 <jle`> is there a way to get the same list of instasnces for a typeclass in ghci that Haddocks has?
09:41:53 <jle`> it looks like :info only give instances for types that are in scope
09:42:05 <jle`> but haddocks somehow is able to get all instances defined/known to the documentation
09:42:46 <jkaye[m]> I think ghci only knows about things in scope
09:43:03 <jkaye[m]> Haddock does that by deep searching all "linked" packages docs eaglery
09:43:07 <phadej> yea, import Control.Lens and you'll get more instances :)
09:43:15 <jle`> haha
09:43:18 <jle`> hm, makes sense
09:44:06 <jle`> i thought haddock used the ghc api or something to get the list directly
09:44:15 <jle`> but it might be doing its own manual search
09:54:59 <ezzieyguywuf> is there a 'typical' approach to throwing errors in haskell? I know there's the ExceptT, but I'm thinking more like `data MyError = ParseError | ValueError | InvalidInput` etc. If I have three different modules in three different packages that could each throw an error, would I define a fourth module/package called Error and have each of the other three depend on the Error module? Is that overkill?
09:56:59 <phadej> jle`: it uses GHC api, but it might be more eager to load them from dependencies' interface files
09:57:25 <ezzieyguywuf> hm, I guess my real question is: is it typical to use `Either String a` or `Either MyError a`
09:57:33 <phadej> both
09:57:53 <ezzieyguywuf> my gut tells me that using a String directly may be difficult to manage long-term, but I have no concrete evidence of why this may be
09:58:00 <glguy> ezzieyguywuf: Depending on what the code is doing it's also common to document what exceptions an IO action can throw
09:58:14 <jle`> ezzieyguywuf: this is basically structured errors vs unstructured errors
09:58:23 <jle`> which is a debate in a lot of languages
09:58:55 <jle`> the nice thing about Haskell is that it arguably makes structured errors a lot easier to work with, with native support for sum types and stuff like that
09:59:03 <jle`> so the value proposition shifts a bit compared to other languages
09:59:15 <ezzieyguywuf> glguy: you mean like `-- | This can throw ValueError or RuntimeError; myFunc :: ....`
09:59:16 <jle`> but the overall questions/tradeoffs you'll ahve to answer are the same
09:59:23 <glguy> ezzieyguywuf: yeah
09:59:34 <glguy> ezzieyguywuf: http://hackage.haskell.org/package/hookup-0.4/docs/Hookup.html#v:connect
09:59:44 <ezzieyguywuf> jle`: ah, that gives me a good starting point for googling/research thanks
09:59:53 <jle`> it loooks like ezzieyguywuf is just talking about pure errors, and not actually exceptions
10:00:42 <glguy> jle`: The question is about "typical approach to throwing errors"
10:00:49 <glguy> I think throwIO is more common than ExceptT
10:01:26 <ezzieyguywuf> hrm, I think jle` has the right of it actually
10:01:26 <jle`> yeah, from that initial phrasing i'd be inclined to say the same
10:01:36 <ezzieyguywuf> ðŸ˜‚
10:01:50 <jle`> just wanted to be careful about moving 'pure' exceptions into IO if there wasn't any IO in the first place
10:02:01 <ezzieyguywuf> why is throwIO more comman than ExceptT?
10:02:31 <dsal> It's more fundamental and has fewer requirements.
10:02:34 <jle`> ExceptT IO at least is considered somewhat of an antipattern
10:02:44 <jle`> but ExceptT over other non-io monads can be useful
10:02:46 <glguy> I wouldn't expect to see ExceptT being used by a library
10:02:51 <glguy> except internally hidden by a newtype wrapper
10:03:11 <glguy> libraries that expose complicated monad interfaces tend to be hard to compose together
10:03:37 <jle`> ah yeah, i wouldn't expect a library to expose ExceptT anything as the type of some exported value
10:03:40 <ezzieyguywuf> hrm. if I have `somePureFunction :: a -> b`, it seems odd to add IO to he mix for error handling
10:03:41 <glguy> but the application you're building using libraries might well use ExceptT
10:03:55 <jle`> ezzieyguywuf: right, if you are just dealing with 'pure' errors, there isn't any need to involve IO
10:03:55 <glguy> Then you're just use Either
10:04:11 <ezzieyguywuf> hm, I see.
10:04:24 <dsal> ezzieyguywuf: If you have exceptions, you've made a partial function.  I'd recommend not doing that.  :)
10:04:29 <jle`> typically i would probably try to use structured errors as possible until the point where it becomes too inconvenient
10:04:40 <ezzieyguywuf> and then whoever uses the library that exports `somePureFunction` _may_ use ExceptT internally to handle the possibility of errors in multiple places
10:04:53 <jle`> just because Haskell makes it so much easier, it feels like a waste to not take advantage of it :)
10:05:03 <glguy> You might use "imprecise exceptions" with 'throw' from pure code where the error simply means the code was used incorrectly 
10:05:08 <ezzieyguywuf> but would ultimately be something like `usesSomePureFunction :: a -> Either b c` r `usesSomePureFunction :: a -> IO ()`
10:05:23 <glguy> and it's not a situation that merits regular and immediate handling
10:05:52 <ezzieyguywuf> `throw` crashes the program, right? like `head []`?
10:06:00 <ezzieyguywuf> > head []
10:06:02 <lambdabot>  *Exception: Prelude.head: empty list
10:06:13 <glguy> it can crash like any exception you don't catch
10:06:37 <glguy> but sometimes it doesn't make sense to handle the exception immediately as it means your program is wrong
10:07:00 <glguy> so there's not much to do about the mistake locally
10:07:12 <ezzieyguywuf> hm. I think my main question has turned into "how can I best structure my library's API in order to communicate that a function may return an error", and it sounds like the answer to that is "use Either (or Maybe)"
10:07:30 <ezzieyguywuf> i.e. it seems like poor form to instead expose or return some sort of ExceptT
10:07:32 <glguy> yeah, that's a good choice for a library
10:07:37 <ezzieyguywuf> let the library consumer worry about that
10:07:59 <jle`> ExceptT is just a newtype wrapper over m (Either a b).  so a library that returns m (Either a b) should rather return that, instead of pre-wrapping it in ExceptT
10:08:07 <jle`> so a user who wants to use ExceptT would just wrap it themselves
10:08:54 <jle`> returning ExceptT m a b instead of m (Either a b) is sort of 'committing' to a specific interface
10:09:15 <jle`> whereas there are a lot of different ways to work with an m (Either a b) that a library might rather use
10:09:18 <jle`> *that a user
10:09:27 * ezzieyguywuf nods
10:09:38 <ezzieyguywuf> yes this makes sense
10:10:17 <ezzieyguywuf> what about State? I have my library doing stuff like `changeState :: Input -> State MyStuff a`
10:10:22 <ezzieyguywuf> i that also considered 'poor form'?
10:10:47 <ezzieyguywuf> though, I have `type MyState = State MyStuff`, so the signature is actually `changeState :: Input -> MyState a`
10:12:25 <jle`> i'd probablt rather see it as Input -> MyStuff -> (a, MyStuff), yeah
10:13:11 <jle`> the exception is if there are a lot of other cases in the library that expect to use changeState in the form of State MyStuff
10:13:21 <jle`> in which case committing to a specific interface is a deliberate choice
10:13:57 <jle`> but if it's something that i'm just going to use directly, without touching anything else from the library, probably MyStuff -> (a, MyStuff) makes more sense
10:14:41 <ezzieyguywuf> jle`: yes that's the case. i.e. `addVertex :: MyState Vertex`, `addEdge :: Vertex -> Vertex -> MyState Edge`, `removeVertex :: Vertex -> MyState ()` etc.
10:15:20 <jle`> yeah. although if you use that in enough places sometimes like like to wrap it in a newtype wrapper to indicate that it's a special library-specific interface
10:16:03 <jle`> *sometimes people like to
10:16:31 <ezzieyguywuf> jle`: which part would be wrapped?
10:16:47 <jle`> like, "you're not meant to use this as a MyState -> (a, MyState), just pretend it's an opaque type taht functions in this library will sequence"
10:16:52 <dsal> ezzieyguywuf: Instead of trying to think about how your API might return an error, just think about what it returns for every possible input.
10:16:53 <ezzieyguywuf> oh, `newtype MyState a = MyState (MyData a)`?
10:17:15 <jle`> newtype ShapeMaker a = ShapeMaker (State MyStuff a) deriving (Functor, Applicative, Monad)
10:17:28 <solonarv> rather than fixing '... -> State MyStuff a', you could also generalize to 'Monad m => ... -> StateT MyStuff m a' or even 'MonadState MyStuff m => ... -> m a'
10:17:29 <ezzieyguywuf> jle`: yes I see.
10:17:50 <ezzieyguywuf> solonarv: yes, this ties into the conversatio earlier regarding ExceptT I think
10:17:58 <jle`> but this isn't like a hard rule, just letting you know different styles that iv'e seen used
10:18:06 <ezzieyguywuf> jle`: yea I appreciate that
10:18:10 <ezzieyguywuf> gives me something to chew over
10:18:17 <solonarv> and perhaps you could even generalize that to 'newtype ShapeMakerT m a = ShapeMakerT (StateT MyStuff m a)'
10:19:10 <jle`> adding new types always has some overhead so it's something to just play around with
10:19:29 <ezzieyguywuf> solonarv: I've considered these generalizations, but this makes things more difficult for me to understand/develop, because I have to consider more possible use-cases
10:53:04 <Guest58924> Hey, anybody know anything about HOpenGL and where I can learn it?
10:53:19 <Guest58924> The official page on Wikipedia has 2 brief examples, and nothing else.
10:53:26 <Guest58924> The documentation seems almost nonexistant.
10:53:45 <ezzieyguywuf> Guest58924: what are you trying to do?
10:54:14 <Guest58924> Basic OpenGL stuff. Calls to create shaders, etc
10:54:35 <ezzieyguywuf> Guest58924: Are you still learning openGL, or you already know it and you want to use it in haskell?
10:55:05 <Guest58924> Totally versed in OpenGL, just trying to find out what using it with Haskell looks like
10:55:58 <ezzieyguywuf> Guest58924: gotcha.
10:56:16 <ezzieyguywuf> Guest58924: I've had success using glfw-b, which is a wrapper to the lightweight glfw library.
10:56:24 <ezzieyguywuf> this gives you an opengl context and you can go from there.
10:56:43 <Guest58924> Alright, I'll look into it. ty
10:56:49 <ezzieyguywuf> I'm unamiliar with HOpenGL, so I can't really speak to it. If you're already familiar with openGL, though, then glfw-b should get you going
10:57:07 <ezzieyguywuf> there's other wrappers for, say, SDL if you're used to that for getting an openGL context
10:57:13 <Guest58924> The premise of OpenGL and Haskell together almost seems like a joke, one of the first things you hear about OpenGL is that it's a "state machine"
10:57:31 <Guest58924> There's a very good chance that I might just bootstrap it with C and then call it with Haskell
10:59:46 <hyiltiz> The monad instance `Reader g >>= f = Reader (\e -> f (g e) e)` where `newtype Reader e a = Reader (e -> a)` is complaining about types
11:00:32 <MarcelineVQ> what is the type of f
11:01:29 <hyiltiz> a -> e -> b
11:01:38 <edmundnoble> I doubt i t
11:01:39 <hyiltiz> (a -> (e->b))
11:01:48 <edmundnoble> Not `a -> Reader e b`?
11:02:04 <hyiltiz> hmm? f should be `a -> m b` so
11:02:24 <hyiltiz> Oh! I need to unpack that Reader out huh
11:04:39 <ezzieyguywuf> Guest58924: I thought the same, but using glfw-b has been rather painless.
11:15:53 <sm[m]> Guest58924: haskell handles state very well
11:18:44 <hyiltiz> So this works: Reader g >>= f = Reader (\e -> runReader (f (g e)) e)
11:20:01 <hyiltiz> Is it posisble to define it without the explicit lambda for e, and maybe also without the runReader (this I can only do with pattern matching for f)
11:24:24 <phadej> :t let bind :: forall r a b. Reader r a -> (a -> Reader r b) -> Reader r b; bind = Data.Coerce.coerce ((>>=) :: (r -> a) -> (a -> r -> b) -> (r -> b)) in bind
11:24:25 <lambdabot> Reader r a -> (a -> Reader r b) -> Reader r b
11:24:45 <phadej> cheating :)
11:25:10 <phadej> works for Reader, but not for ReaderT
11:25:37 <ezzieyguywuf> hyiltiz: what are you using Reader for? like configuration settings or something?
11:28:50 <hyiltiz> just practicing with exercises in https://wiki.haskell.org/Typeclassopedia
11:29:30 <ezzieyguywuf> ah.
11:29:38 <ezzieyguywuf> I've been curious about Reader in the wild
11:29:46 <ezzieyguywuf> I see it used is haskeline for configurations
11:37:16 <phadej> :t let bind :: forall r a b. Reader r a -> (a -> Reader r b) -> Reader r b; bind = Data.Coerce.coerce ((\m k r -> k (m r) r) :: (r -> a) -> (a -> r -> b) -> (r -> b)) in bind
11:37:17 <lambdabot> Reader r a -> (a -> Reader r b) -> Reader r b
11:37:23 <phadej> is more serious
11:37:42 <phadej> with coerce, you can avoid writing wrappers (sometimes)
11:37:48 <Marked> Guyz.. I have installed haskell platform. Now I am wondering if  I should install Stack
11:42:27 <ezzieyguywuf> Marked: you used ghcup? you should only need one not both
11:47:23 <Marked> No I did apt-get install haskell-platform
11:48:02 <dsal> Anything that starts with `apt-get` usually ends with sadness.
11:48:22 <enikar> :D
11:48:31 <Marked> Sorry.. gotta go.. gn guyz
11:48:33 <dsal> If you just get the `stack` tool, it'll do the right things.  Or you could take the ghcup approach (I'm not familiar with it, but people seem to like it).
11:56:05 <phadej> marked left, but on ubuntu hvr-ppa is good, on debian https://downloads.haskell.org/debian/
11:57:15 <phadej> and in these cases commands starting with apt-get ends quite well
11:57:50 <phadej> (at least if you don't want the latest stuff, focal is not there yet :( )
11:58:13 <davean> I mean, "latest stuff" is the only issue I've ever known apt-get to have
11:59:09 <phadej> ppa's and then debian/ repository are relatively up to date
11:59:45 <phadej> but official distro package repositories are indeed sad in Haskell regard
12:00:16 <phadej> though, Ubuntu 18.04 has python 3.6
12:00:18 <phadej> it's fine
12:01:12 <phadej> it's hard to keep up with GHC release pace :)
12:14:45 <maerwald> more problematic is that many distros only provide one ghc version (eg alpine)
12:15:30 <hyiltiz> well for minimal distros it is probably sensible/economic
12:15:31 <davean> Yah, thats always annoying.
12:15:47 <davean> hyiltiz: why would you think that?
12:16:25 <dminuoso> hyiltiz: For most distributions it's tough anyway. Supporting the ability to have multiple concurrent pieces of software leads to all kinds of quirks and issues.
12:16:36 <hyiltiz> I am assuming minimal distros have much less manpower compared to major distros like Debian
12:16:40 <dminuoso> You inevitably end up building something like nix if you want it done right.
12:17:35 <dminuoso> Or you just give up and declare there can only be one version of anything, and then talk about different versions as separate packages if at all.
12:18:44 <dminuoso> But that increases maintenance overhead and makes it hard to sensibly depend on packages (since you can depend only on one version)
12:19:00 <dminuoso> Leading you back to "one package, one version"
12:19:19 * hackage pantry 0.4.0.2 - Content addressable Haskell package management  https://hackage.haskell.org/package/pantry-0.4.0.2 (borsboom)
12:19:34 <dminuoso> I dont think its as much a "manpower problem" as it is a "package/library/dependency management is really complicated" problem
12:21:03 <hyiltiz> yeah but unless u go along with a marvelous solution for a complicated problem, you'll need a lot of manpower to do the legwork
12:22:41 <maerwald> dminuoso: what quirks?
12:23:11 <maerwald> it's very easy to package multiple versions of GHC properly
12:23:38 <maerwald> things only become problematic if you want to package libraries, which you don't need
12:24:21 <davean> maerwald: some might consider the default selection system for Debian to be a "quirk"
12:25:27 <davean> (Though for many purpose's I'd consider nix to be the one with problematic "quirks")
12:25:47 <dminuoso> Well, if we talk about GHC in isolation its manageable. But once you look into the ecosystem of a distribution, then where do you draw the line? Do you create separate packages for each major version? For each minor version? Distribution maintainers likely don't want an influx of "10 GHC packages" just so you can have ghc 8.2, 8.4, 8.6, etc.. And this is not just GHC.
12:26:03 <dminuoso> Furthermore, what if the package exposes dynamic libraries?
12:26:54 <dminuoso> The one thing that nix solves right, is the ability for many versions in different flavors to co-exist perfectly.
12:27:08 <phadej> users don't care if pandoc is compiled with GHC-8.4 or GHC-8.6 (to some approximation)
12:27:39 <phadej> there is a line to which extend distributions should try to provide development packages
12:27:48 <davean> dminuoso: I haven't really thought that nix solved that well
12:27:51 <phadej> imo haskell libraries are not worth it
12:28:06 <davean> it solves it "ok"
12:28:25 <davean> It solvse it well when you want a single version at a time
12:28:31 <davean> not when you actually want all the versions together.
12:28:32 <phadej> nixpkgs aren't exhaustively built
12:28:36 <phadej> you cannot trust it
12:28:43 <davean> phadej: very very true
12:28:45 <dminuoso> davean: Im not talking about the ergonomics of it, just the fact that it works.
12:29:06 <davean> dminuoso: I've had more issues with nix for that than Debian though for example!
12:29:20 <davean> nix is more fixabnl
12:29:26 <davean> I can eventually get what I want
12:30:13 <dminuoso> davean: Im not saying nix is great, just that the "co-existence of packages" portion is served well. :)
12:30:18 <dminuoso> *solved
12:30:22 <maerwald> I don't even understand what nix has to do with GHC packaging issues
12:30:47 <maerwald> and, you obviously want to package every x.y.z version
12:30:50 <phadej> dminuoso: is it
12:31:08 <phadej> I don't feel that nixpkgs is that compositional
12:31:13 <davean> dminuoso: I'm saying thats specificly something I've had a bad experence with with nix
12:31:19 <phadej> try to get a nix-shell with GHC-8.4 and GHC-8.6 for example
12:31:25 <phadej> I have no idea where to start
12:31:41 <phadej> but I gree, it's nice when you don't ask too much :)
12:31:42 <davean> dminuoso: I find myself disatisfied with co-existance specificly
12:31:59 <maerwald> gentoo for example *can* package GHC properly, but they went down the wrong path also packaging libraries (as dependencies of GHC even), which makes everything a mess
12:32:00 <davean> the way phadej is describing (and that I mentioned above)
12:32:11 <davean> that has worked MUCH better for me on debian than nixos
12:32:24 <davean> I believe that nix *specificly* is substandard in this area
12:34:02 <phadej> you can package stuff better with nix, but nixpkgs is just a way to package stuff
12:34:31 <phadej> but reinventing package repositories is not fun
12:34:49 <phadej> so you are stuck with whatever design was chosen
12:35:01 <maerwald> ergonmics is important for *configuration* ...and nix as a configuration system has negative ergonomics
12:35:28 <maerwald> for *packaging* semantics is more important
12:36:04 <maerwald> so they conflated both, basically, which is shitty design
12:51:41 <hyiltiz> I wonder if it would make things easier to just package GHC-8 then another package for addons, assuming GHC-8.x and GHC-8.y is basically the same except some extensions
12:52:34 <hyiltiz> So anything "Haskell 98 or Haskell 2010" will be supported by GHC-7 or GHC-8 package, and you can install GHC-extentions-8.6 package that provides the additional features
12:52:45 <davean> hyiltiz: uh
12:52:50 <davean> hyiltiz: thats not at all how GHC works.
12:53:15 <hyiltiz> I know that is not how it works; I am *wondering* if it could possibly work that way
12:53:46 <davean> No
12:53:48 <davean> Thats not how GHC works
12:54:03 <davean> it would be completely impossible. It doesn't even make conceptual sense.
12:54:10 <davean> The second number in GHC is not features in any sense
12:54:21 <davean> and they are in no way "add ons"
12:54:51 <davean> Each GHC version is primarily composed of global changes, including code generation and RTS veriations
12:54:57 <davean> You can not pick and choose at all.
12:55:47 <hyiltiz> i.e. GHC Core is the same; differences in its optimizers and parts that turns Core to binary shouldn't matter much to what a particular .hs file should look like
12:55:54 <davean> Incorrect.
12:56:01 <davean> GHC Core is not the same
12:56:10 <hyiltiz> ok thx for the elaboration
12:56:16 <hyiltiz> I'll stop wondering that way then :D
12:56:51 <davean> It doesn't change much
12:56:57 <davean> but it can change
12:57:07 <hyiltiz> But how does GHC Core differs across versions? I thought it was just a minimal language that implements lambda calculus and not much more
12:58:08 <davean> I can't say because it varies with the GHC changes
12:59:23 <davean> even if it didn'
12:59:26 <davean> t though that wouldn't save you
12:59:27 <hyiltiz> I still get surprised that GHC is a 1Gb compiler
13:00:02 <hyiltiz> and every minor version (*.x) update downloads and writes 1GB
13:00:13 <dminuoso> Why do you say its a 1Gb compiler?
13:00:19 <hyiltiz> Yes, disks are cheap, and GHC is smarter than most compilers
13:00:54 <hyiltiz> Installing GHC downloads and installs about 1GB stuff, while most compilers for other languages aren't?
13:00:57 <dminuoso> hyiltiz: https://stackoverflow.com/a/4867236
13:01:03 <dminuoso> Best to let simon himself explain the sie. :)
13:01:17 <maerwald> GHC unpacked and installed is 2GB :)
13:03:15 <hyiltiz> Hmm didn't know I was installing 5 times GHC for each GHC version, so I pretty much have about 20 GHCs...
13:16:03 <solonarv> "7" isn't a GHC version, "7.10" is
13:16:18 <solonarv> GHC uses the PVP, not SemVer
13:16:36 <solonarv> the first *two* digit groups, *together*, are the major version
13:27:57 <maerwald> solonarv: I'm not sure it is PVP
13:28:06 <maerwald> does it say anywhere it is?
13:28:51 <Uniaika> is that so
13:29:33 <maerwald> *technically* it is https://hackage.haskell.org/package/base-4.14.0.0/docs/Data-Version.html#t:Version
13:29:52 <davean> GHC's version numbering predates PVP, but PVP at least generally gives the right idea for GHC - I don't know of any official decision on the version standard for GHC though.
13:30:37 <Uniaika> I am reading that a PVP version scheme must be of the form A.B.C and optionally have a .D component
13:30:54 <maerwald> Uniaika: any number of additional
13:31:07 <maerwald> also, PVP does not have tags
13:31:20 <maerwald> which is why I like SemVer more
13:37:59 <Uniaika> well, alpha and beta tags are pretty neat indeed
13:38:05 <Uniaika> (and rc
13:38:05 <Uniaika> )
13:46:35 <davean> GHC definately gets RC tags :)
13:46:37 <davean> a lot
13:55:12 <Uniaika> oh yeah but isn't that common knowledge that GHC does not follow PVP?
13:56:27 <Rembane> I would say that it's between uncommon and common knowledge. 
14:02:05 <monochrom> The really interesting question is does GHC follow SemVer? :)
14:03:22 <monochrom> because from 8.8.3 to 8.8.4, for example, is bug fix point release not backward-compatible addition.
14:06:48 <Uniaika> oh I would not venture into pretending it is following anything else than the needs of the releng team
14:07:53 <monochrom> wise :)
14:11:13 <Rembane> Does anything really follow SemVer? 
14:11:39 <int-e> just go from 0.1 to 0.2 to 0.3 to 0.4 ...
14:12:00 <monochrom> Does SemVer have version numbers? :)
14:12:02 <int-e> (PVP's notion of a major release)
14:13:13 <int-e> Rembane: it hardly seems practical unless you get all you code right the first time you write it.
14:13:38 <int-e> (The idea here is that any bugfix is an observable API change that requires a major version bump.)
14:15:23 <int-e> monochrom: I learned recently that the term "semantic versioning" is overloaded. But I think we're discussing the PVP kind which attaches version number bumps to different kinds of API changes (optimizations, extensions, changes)
14:16:08 <monochrom> Yes.
14:16:36 <monochrom> My understanding is that SemVer and PVP does the same thing with different syntaxes.
14:16:44 <monochrom> s/does/do/
14:17:22 <int-e> I'm ignoring the difference I'm aware of (namely, how many components the major version has).
14:17:41 <monochrom> Yeah and that's the only syntactic difference, even.
14:17:53 <Rembane> int-e: Or maybe you need to increase the major version numbers all the time.
14:18:09 <monochrom> But you don't say "I'm writing in haskell" if you're writing liskell :)
14:18:54 <int-e> Rembane: Sure but then you end up like base where almost everybody requires base <5, and the upper bound would probably be omitted if cabal didn't warn about it.
14:20:11 <int-e> (The main problem with base may be that it's too big. As I understand it, every major ghc release updates *something* in the GHC.* hierarchy and that requires a major version bump, even though it does not affect 99% of the consumers.)
14:22:54 <Rembane> int-e: I agree. 
14:37:11 <koz_> What happens to the Handle argument to this function if an exception is thrown? http://hackage.haskell.org/package/bytestring-0.10.10.1/docs/Data-ByteString-Lazy.html#v:hGetContents
14:37:19 <koz_> I _assume_ it stays open.
14:37:39 <dminuoso> hGetContentsN k h = lazyRead -- TODO close on exceptions
14:37:41 <dminuoso> Haha :)
14:37:47 <koz_> OH FFS
14:37:56 <koz_> OK, good to know.
14:39:23 <koz_> Uniaika: You could also send this ^
14:39:26 <dminuoso> Now Im curious why its not implemented.
14:39:41 <int-e> It should still be closed when it's garbage collected.
14:39:56 <Uniaika> got damnit
14:40:11 <koz_> int-e: Yeah, but what if you're a good Haskell citizen and set up a catch?
14:40:12 <int-e> (Far from ideal. But then again you *are* using lazy I/O...)
14:40:22 <koz_> You'd kinda like to know what state the Handle's in.
14:40:33 <glguy> If you're using lazy getcontents functions you've already declared that you don't care about prompt resource cleanup
14:42:19 <ezzieyguywuf> how might I go about cleaning up the nested case statements here? I know I can use MaybeT, but this would not allow me to show a different error message depending on what has failed https://dpaste.com/CTY7RDD8C
14:42:44 <dminuoso> ezzieyguywuf: ExceptT 
14:42:45 <monochrom> I believe that the fundamental unanswerable question is "statically where do you add your code to detect the exception?"
14:43:51 <monochrom> err nevermind, it's answerable.
14:44:08 <Uniaika> glguy: I'm not fundamentally against that line of thinking, but I think that advertising that kind of stuff can do more good than harm
14:44:31 <ezzieyguywuf> dminuoso: I started down that path, but I couldn't figure out how to go from a Maybe to an Either
14:44:52 <ezzieyguywuf> I'm wondering if the `getVal` design is fundamentally flawed against this type of use-case, or if I'm just missing soething else
14:45:44 <dminuoso> ezzieyguywuf: This is tough to answer without seeing the larger scope of it.
14:46:15 <dminuoso> ezzieyguywuf: In some projects I like to use an idiom of `note :: MonadError e m => m (Maybe a) -> e -> m a`
14:46:19 <dminuoso> Then I can just say:
14:46:26 <int-e> koz_: What's the right thing to do upon receiving an exception? The result of hGetContents might be shared between threads, and killing one of them should not invalidate the contents for the other one.
14:46:37 <dminuoso> do { x <- getVal foo `note` "could not get value for x"; ... }
14:47:12 <dminuoso> Well the type signature is slightly off for my version because I copied it straight out of some other context.
14:47:15 <koz_> int-e: I'm not saying that hGetContents is doing the wrong thing. I'm saying it should say what state it leaves the Handle in.
14:47:37 <ezzieyguywuf> dminuoso: https://gitlab.com/ezzieyguywuf/mycad/-/blob/master/MyCAD/app/TUI/CommandRunner.hs#L59 , rather than failing outright whenever a "Nothing" is returned, I'd like to refactor the 'runAdd' function to return an error message specific to what went wrong
14:47:42 <koz_> This is a documentation problem.
14:48:00 <int-e> koz_: So I think leaving the closing (apart from the case of reaching EOF) to the garbage collector is the only sane thing to do for hGetContents.
14:48:08 <dminuoso> ezzieyguywuf: Well Id say the `note` pattern would work for you
14:48:23 <dminuoso> The correct type in your case would be: note :: MonadError e m => e -> Maybe a -> m a
14:48:25 <koz_> int-e: And I am not disagreeing with you there. I'd just prefer that to be spelled out in the docs.
14:48:28 <dminuoso> Or maybe with the arguments flipped, depending on how you like it
14:48:42 <ezzieyguywuf> dminuoso: great thanks, I'll take some time to play around with this.
14:48:43 <int-e> koz_: Ah. Well, it doesn't close. And it doesn't seem to mimic the standard hGetContents' semiclosed state (maybe that's too hard, I don't know)
14:48:52 <dminuoso> (You can think of `note` as rewriting Nothing to whatever error you like)
14:48:59 <koz_> int-e: What's the 'semiclosed' state you refer to?
14:49:06 <ezzieyguywuf> dminuoso: does MonadError come from mtl, or is it in Base?
14:49:11 <dminuoso> ezzieyguywuf: Yeah, mtl
14:49:22 <dolio> It's the state described in the hGetContents documentation you're allegedly talking about.
14:49:53 <ezzieyguywuf> dminuoso: in your `do { x <- getVal foo `note`....} what is the return type of the do-statement?
14:50:13 <dminuoso> ezzieyguywuf: whatever you like
14:50:20 <int-e> dolio: Nah, koz_ is talking about the documentation in bytestring.
14:50:24 <koz_> dolio: This one? http://hackage.haskell.org/package/bytestring-0.10.10.1/docs/Data-ByteString-Lazy.html#v:hGetContents
14:50:24 <int-e> koz_: https://hackage.haskell.org/package/base-4.10.1.0/docs/System-IO.html#v:hGetContents
14:50:38 <dminuoso> ezzieyguywuf: Let me give you an insight into my thought process:
14:50:41 <ezzieyguywuf> dminuoso: hrm, ok like I said I think I need to play around with this to understand it better, thanks for pointing me in this direction though.
14:50:46 <ezzieyguywuf> dminuoso: sure!
14:50:50 <koz_> (thanks for the link int-e - will read)
14:51:08 <glguy> Uniaika: I don't know what you mean
14:51:24 <dolio> Oh, I see. It's the bytestring docs that are bad.
14:51:50 <koz_> dolio: Yeah, or rather, they're omissive.
14:52:07 <dminuoso> ezzieyguywuf: I use `note` to just rewrite each occurence of Nothing into an arbitrary error I like. All I need to do now, is decide what MonadError instance I want.
14:52:13 <monochrom> Procrastinating like me. :)
14:52:36 <dminuoso> Maybe I want something short circuiting like ExceptT over my existing monad stack, so I can analyze everything at the end
14:52:40 <dminuoso> So you could do:
14:53:27 <dminuoso> runExceptT $ do { x <- note "missing an X" maybeX; y <- note "missing an Y" maybeY; ... } 
14:53:32 <Uniaika> glguy: it's alright
14:53:39 <dminuoso> Then at the end you get an `Either String Whatever`
14:53:54 <dminuoso> The string is automatically inferred by what you pass to `note` here
14:55:19 * hackage box 0.6.0 - boxes  https://hackage.haskell.org/package/box-0.6.0 (tonyday567)
14:55:36 <ezzieyguywuf> dminuoso: so in this example, your `note :: MonadError e m => e -> Maybe a -> m a` expands out to `note :: String -> Maybe a -> Either String a`?
14:56:21 <Uniaika> koz_: care to enlight me about how openBinaryFile closes the handle? https://hackage.haskell.org/package/base-4.14.0.0/docs/src/GHC.IO.Handle.FD.html#openBinaryFile
14:57:07 <Uniaika> *enlighten
14:57:23 <koz_> Uniaika: Huh, I guess I misread when I saw the handler.
14:57:29 <koz_> So it doesn't, huh.
14:58:17 <koz_> In the context of this function: http://hackage.haskell.org/package/bytestring-0.10.10.1/docs/Data-ByteString-Lazy.html#v:readFile that seems like an issue.
14:58:28 <dminuoso> In some of my other code, I have a variant of note that uses MonadThrow instead, that lets me propagate some invariant violations directly as say IO exceptions. So I'd do `do { x <- note (SymmetryViolation "blabla") someMaybe; ... }` then
14:58:28 <dminuoso> ezzieyguywuf: do you have some monad already or not?
14:58:28 <dminuoso> If not, then it'd rather be `note :: String -> Maybe a -> Except String a`
14:58:29 <dminuoso> If yes, it'd be some `note :: String -> Maybe a -> ExceptT YourMonad String a`
14:59:13 <ezzieyguywuf> dminuoso: yea, I have a State
14:59:19 <Uniaika> koz_: alright, thanks for confirming my suspicions (read that on the air of "losing my religion")
15:04:40 <int-e> koz_: What are you worried about? The file is either closed by readFile or by a finalizer when the Handle is collected.
15:05:49 * hackage box-csv 0.0.2 - See readme.md  https://hackage.haskell.org/package/box-csv-0.0.2 (tonyday567)
15:05:56 <koz_> int-e: Where does this close the file? http://hackage.haskell.org/package/bytestring-0.10.10.1/docs/Data-ByteString-Lazy.html#v:readFile
15:06:20 <int-e> koz_: in hGetContents, once EOF is reached.
15:06:22 <dminuoso> Err, *ExceptT String YourMonad `
15:06:23 <dminuoso> ezzieyguywuf: Then it'd monomorphize into `note :: String -> Maybe a -> ExceptT (EntityState p) String a`
15:06:23 <dminuoso> for some value of p
15:06:23 <dminuoso> heh. type. :)
15:06:37 <int-e> koz_: not immediately (obviously).
15:06:39 <koz_> int-e: And if it throws before that happens?
15:06:49 * hackage box-socket 0.0.2 - See readme.md  https://hackage.haskell.org/package/box-socket-0.0.2 (tonyday567)
15:07:00 <koz_> I guess that's the GC's job then?
15:07:10 <int-e> koz_: Yes.
15:07:17 <koz_> OK, that makes sense.
15:07:32 <Uniaika> so, to make a quick recap
15:07:39 <int-e> I suppose it could handle synchronous exceptions like read errors and actively close the handle then.
15:07:53 <Uniaika> should a function relying on lazy hGetContents raise, its file handler will get GC'd?
15:08:10 <int-e> But as I tried to explain above it can't do anything about asynchronous exceptions.
15:08:28 <int-e> Uniaika: if the result isn't shared with another thread...
15:08:49 <int-e> That possibility is the main issue here, I think.
15:09:30 <Uniaika> int-e: I'm just trying to document the possibility of dangerous behaviours of this function
15:09:34 <Uniaika> tell me more about this 
15:09:47 <int-e> I'd call lazy IO a terrible idea... except that it's remarkably convenient.
15:10:33 <Uniaika> glguy's point about giving up on prompt resource management is imo a good addition to the documentation
15:10:35 <int-e> So I'm rather torn on the issue. I also tend to write one-off programs that just aren't worth proper error handling.
15:10:48 <int-e> Yes, it should definitely be documented.
15:10:54 <Uniaika> int-e: yeah but you were saying something about sharing with another thread
15:11:14 <Uniaika> since it's not a scenario I'm familiar with, could you expand a bit on that? :)
15:11:52 <int-e> readFile should point to hGetContents, and hGetContents should say that the file handle is closed at EOF if all the file is read, and by the garbage collector otherwise.
15:13:38 <int-e> And maybe point out that this means that if if you partially read many files using hGetContents you may easily run out of FDs before that happens. Hmm. Except if you hClose the handle yourself once you're sure that you've read everything you needed... hmm. It's tricky.
15:15:35 <ezzieyguywuf> dminuoso: lol. ok I think I get the main gist. i'm just going to have to kick the tires on MonadError a bit to get a feel for it
15:16:47 <int-e> Uniaika: "sharing with another thread" is really just  xs <- readFile "foo"; forkIO $ <something using xs>. I'm not sure this belongs in the documentation as such, but it's the reason why relying on GC for closing FDs is to some extent necessary.
15:17:41 <dolio> I don't think it's really necessary to mention threads.
15:17:46 <int-e> Actually. No, we have to rely on GC for this anyway... even a single thread can lose the last reference to the hGetContents result at an unpredictable point in time.
15:17:53 <dolio> The GC can only collect something if there are no references to it.
15:18:07 <int-e> The additional thread is why you can't close the FD on receiving an asynchronous exception.
15:18:32 <int-e> But these are all rationales and don't really belong into the API documentation.
15:20:47 <dolio> You could run into that trouble in a single thread, even.
15:21:00 <dolio> By catching the relevant asynchronous exception.
15:43:20 <Uniaika> int-e: got any github handle I can ping in the PR for bytestring?
15:44:11 <int-e> Uniaika: yes, same as the IRC one
15:45:27 <dminuoso> Uniaika: what pr is that?
15:46:21 <Uniaika> dminuoso: I can ping you too if you want :P
15:46:30 <Uniaika> you'll have the surprise!
15:53:49 <Uniaika> int-e, koz_, dminuoso I invite you to comment on that PR for other stuff that ought to be added
15:53:52 <Uniaika> cheerios
15:54:07 <koz_> Uniaika: Thanks!
17:57:42 --- topic: 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: https://gist.github.com/ | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org'
17:57:42 --- topic: set by glguy on [Sat Jan 05 07:21:52 2019]
17:57:42 --- names: list (clog shatriff crobbins maier heatsink gentauro nicholaslyang jedws hexfive carlomagno devdsp niklasb_ howdoi amiri _ashbreeze_ sleblanc machinedgod Gurkenglas__ mangoicedtea wroathe conal justanotheruser jonathan3 comerijn gmt dolio vicfred xelxebar_ justsomeguy blase jespada nckx GyroW vimto1 Eliel reyu djanatyn deni mantovani Unode oleks hrnz pie_ anderson pierrot ps-auxw Someguy123 electrocat w1gz piele Zemyla johnstein Philonous hwabyong_ magicman amx)
17:57:42 --- names: list (gareth__ gilbertw1_ Hijiri dminuoso msgctl malthe chindy haskell_enthusia statusbot cyberlard e2 Squarism avn Nistur bollu davean samebchase byorgey add^_ pacak yahb dh brisbin stree_ alexelcu _xor jhuizy Kneiva quintasan ambiso Rotfuchs wallacer3 ktor DTZUZU urdh tomboy65 dftxbs3e wavemode_ infinity0 wowi42_ Cale thunderrd Kaeipi danso pera Amras0000 phreedom xsperry shock_ sheddow acidjnk_new johnw Sgeo DirefulSalt Kaivo whiteline jneira_ xff0x_ TimWolla)
17:57:42 --- names: list (polyphem tsaka__ Monoid evanjs livvy Guest58924 jamm rwe Alleria_ texasmynsted jrm ixian Thra11_ Lord_of_Life tzh Nilgeist jb55 unlink2 lucasb ystael incentive revprez_anzio s00pcan nshepperd spew seanparsons urodna lnostdal auri_ ArsenArsen aurieeeh miguel_clean l8star__ PlasmaStar coeus bsima dequbed betrion[m] jlamothe Forkk day lemmih Foritus zaquest theDon sepples lagothrix gabiruh codygman dan64- shutdown_-h_now kav drbean alx741 xerox_ dcoutts__ vjacob)
17:57:42 --- names: list (hiroaki Jesin tv sdrodge jkaye[m] crazyLikeAFox95 dexterlb motherfsck tromp zgrep dwt Guest86335 Batoeh cohn revprez_stg bitmapper aenesidemus oldsk00l haasn acarrico MarcelineVQ glguy obihann sagax gienah enikar stepnem jameekim Orbstheorem CurryWurst Tene orion klardotsh remexre nonickname coddinkn poljar1 cjh` greymalkin bonz060 petersen haveo mawk raoul nshepperd2 markus1199 atk mimi_vx zopsi russruss8 tomku niso verement Noughtmare[m] mp___ grumble ogkloo)
17:57:42 --- names: list (DustyDingo dddddd raoulb Logio ent jophish balbirs liff p8m_ xwvvvvwx valdyn drewr pounce Lowl3v3l janne Cthalupa JSharp iphy alunduil teehemkay adamse sclv_ enemeth79 ajmcmiddlin_ yogani mnrmnaugh javran incognito9999_ doublex brown121407 `slikts madog andreas303 zebrag aldum ben_m2 roconnor cyphase p3n thaumavorio artem zariuq infinisil Bergle_1 wildsebastian dpl- koz_ tabemann Digit strangeglyph Graypup_ mounty NieDzejkob jneira theduke ekleog gehmehgeh)
17:57:42 --- names: list (beaky phaul Ishutin efertone lambdabot e zfnmxt Inoperable vqrs duairc m1dnight_ Brian[m]8 ttc whataday jakalx {abby} sm2n fissureman nerdypepper ft maerwald pieguy128 lep-delete oak entel fryguybob polux2001 atraii Putonlalla phaazon dmiles ulidtko Arahael mozzarella nek0 mr_yogurt mjrosenb sqrt2 Bunogi jtcs Moyst HoolaBoola bastelfreak justache sajith karolus obiwahn andi- alehander92 johnnyboy[m] c6ristian kjak wildtrees[m] voppe[m] utdemir[m] slack1256[m])
17:57:42 --- names: list (mikr[m] sgraf812[m] IngvarLynn[m] ixaxaar[m] joeo[m] iffsid io_r_us[m] dyniec[m] alexfmpe Hatsue[m] PotatoHatsue[Q] vaibhavsagar unclechu supersven[m] thejonny stites[m] srid siraben sureyeaah reed[m] rednaZ[m] psydruid michaelpj maralorn lnxw37d4 kaychaks_riot kadoban iinuwa hnOsmium0001[m] hsiktas[m] GuillaumeChrel[m gaussian[m] freeman42x[m] fgaz ethercrow[m] drozdziak1 domenkozar[m] camlriot42 boistordu PotatoHatsue alvinsj[m] Fernando-Basso[m Ericson2314)
17:57:42 --- names: list (sm[m] terrorjack frim[m] cross ullbeking tsrt^ Kamuela opqdonut uwap laxask bananagram dixie tasuki_ d0liver liquorice starlord banjiewen nick_h Hotbees mcfilib Shun131 cow-orker ski Velpoman higherorder grfn amatecha__ Boarders pasukon dgpratt darthThorik parisienne___ runde kristjansson billstclair thi johs cstrahan PatrickRobotham_ bjs feepo ^[_ dmj` Ekho DigitalKiwi ridcully_ Rembane connrs_ Madars incertia Rudd0 ChaiTRex pong styledash Vq jluttine)
17:57:42 --- names: list (albethere hvr Tordek tabaqui peltre PoliticsII__ tnks chpatrick graingert SrPx angerman parseval sgraf mceier Chobbes ezzieyguywuf connrs feuerbach a3Dman saurik Cheery ByronJohnson centril lortabac Randy vnz chosenone benschza hive-mind heredoc jackhill joeyh_ i7c nkly sw1nn clynamen dmwit wei nitrix Nascha PotatoGim elvishjerricco parsnip liszt rann bitonic rizary stylewarning mudri gaze__ betawaffle mankyKitty_ conjunctive jetpack_joe hamishmack dani-)
17:57:42 --- names: list (carter eacameron sujeet affinespaces kip hyperfekt srk Arguggi Cathy Firedancer_ loc rotaerk mort fre Reiser L1Cafe drewolson tstat tomsmeding edwtjo ViCi^ kqr dopplerg- rzmt MasseR PragCypher Uma miklcct jinblack xarian tdammers epta BIG_JIMMY_D averell drbrule pent kozowu cbarrett ornxka nlofaro newhoggy dsal NemesisD ocharles ring0` chessai edwardk atomi marek aweinstock chrpape atle_ spamlessj myme deu hexo Adluc bjobjo Jon komasa relrod cheers kkd bgamari)
17:57:42 --- names: list (sarahzrf aib Klumben saidinwot1 Faye HiRE mulderr DwarfMaster Iroha PyroLagus raid crtschin ibloom alanz_ ReinH benl23 luite fiadliel cvlad- dsturnbull PtxDK zzz runeks bwe_ Raito_Bezarius pepeiborra lally ggVGc twk- sphalerite wpcarro J_Arcane m-renaud leah2 thonkpod noteness laghee__ krjst a3f aplainzetakind sethetter_ LambdaDuck elcaro nh2 idnar nopf 32NAAO7HX Igloo esotericalgo lieven Tspoon supki gargawel heath cynick lemald jvanbure bobbytables Deewiant_)
17:57:42 --- names: list (fiddlerwoaroof jkarni exferenceBot Twey runawayfive mikolaj Sparadox uberj phadej xe4 tessier tureba esg furnost joeytwiddle lpsmith tensorpudding Guest81866 davl theorbtwo rembo10 esph rkrishnan forell SquidDev stiell TommyC puffnfresh_ gekh12 digia Dykam_ seliopou Benett tmciver dredozubov Axman6 heyj Adeon iomonad kloeri fiQ2 jfredett_ qz abrar lnx Ranhir ahf Drezil robogoat oats fliife850 MindlessDrone gawen ephemera_ duckonomy Katarushisu electrostat)
17:57:42 --- names: list (CitizenS- arianvp energizer jvsg andyo tristanC suzu_ ego drdo suppi dexterfoo @ChanServ jjhoo cgfbee mpickering verlet64_ Clint Taneb TMA wagle stilgart aidecoe rdivacky dibblego helpplz meck noan sim590 anoe sayak1 jassob1 narendraj9 RusAlex micro Natch mud datajerk bendo Wamanuz armin fredcy- NinjaTrappeur Cerise M2tias Jonno_FTW madnight Guest6919 pharaun stvc zymurgy AndreasK Geekingfrog peutri Athas int-e lockshaw Nikotiini Niamkik steell michalrus)
17:57:42 --- names: list (vin-ivar abuss doconthe1ocks noctux obfusk stefan-_ xintron voidcontext kaol codedmart agrif koala_man so azahi hackage ichimaru otulp Techcable davve Khisanth Neuromancer echoreply APic stux|RC-only jokester sm SomeB sud0 dxld zabracks rdivyanshu_ ebutleriv Argorok dysfigured nisstyre vk3wtf tumdedum ap5 swater xts hpc noecho thecoffemaker Paks hyiltiz monochrom mac10688 tinwood dqd Maxdamantus nurupo flux Arjan orcus Profpatsch juri_ dave_uy2 quaestor mupf)
17:57:42 --- names: list (bind sea-gull freeside jchia lassulus immae hyiltiz-M1 simplegauss sveit Majiir natim87 dustinm jdt acowley c-rog ericsagnes c_wraith daGrevis pta2002 niko catern EvanR kosmikus marble_visions_ Blkt troydm Ferdirand glamas SupaYoshi agander_m srhb jackdk taktoa[c] typetetris kyagrd__ milessabin rslima____ lyxia ghuntley glowcoil Chousuke cmsmcq Tourist sdx23 [exa] acertain wraithm wayne jle` matheus23 jzl chirpsalot geal inimino CindyLinz reactormonk)
17:57:42 --- names: list (hongminhee mmaruseacph2 mniip eyenx towel milkii geirha Ankhers mstruebing rawles jcarpenter2 leothrix cjay IceMichael adius vodkaInferno buggymcbugfix bcmiller jonge cpape PHO nh Benzi-Junior sis7 fr33domlover glowpelt morbeus gluegadget jbetz zyeri Cir0X moobar_ integral koankeeper LittleFox riatre lightandlight ryjm FMJz___ davetapley Firedancer jared-w carbolymer WzC_ gambpang earthy Entroacceptor newsham ammar2 gothos [df] turq divVerent nil kraem kmein)
17:57:42 --- names: list (xlei rednaZ2 rodgzilla veverak statusfailed RoguePointer vancz arkeet hiredman jorj tomjaguarpaw teqwve PigDude xnyhps xcin spoonm operand nshepperd1 solarus cocreature Bigcheese lukelau interruptinuse _flow_ sivs martin02 recon_- copypasteque_ aristid ProofTechnique bgavran DocKlobi edmundnoble metadave bradparker cinayakoshka benwr_ simony Tritlo jlpeters siers systemfault joshmeredith mursu dumptruckman joehillen SolarAquarion mingc ManiacTwister nikola2)
17:57:42 --- names: list (yushyin silver_needles magog debugloop bspar tolt rom1504 noexcept idupree2 dale shadowdaemon ashnur rprosper- dilinger cods topos eagleflo pdxleif sshine d3lxa eldritch shapr blackdog NGravity bob_twinkles andjjj23 Guest60204 kipras`away beka adamCS exarkun arw hc totte ivegotasthma nemesit|znc grol nekomune canta vjoki hexagoxel mjuad xacktm hodapp SegFaultAX t36s_ acro bandali megaTherion abbe @Sigyn sophronios infty farn_ jonrh alexknvl gregberns_ caasih)
17:57:42 --- names: list (totbwf lexi-lambda badzergling rodlogic_ peel amosbird wz1000 Takumo irclogger_com Solarion magbo flebron kini Flonk_ shachaf bcoppens_ jmsx samebchase- landonf mrus wrunt ptrcmd barrucadu Jello_Raptor Guest20621 absence comboy luigy lowryder mikolaj_ asm89 thebnq Uniaika)
18:20:41 <sm[m]> what combines a sequence of eithers to get the first Left or all the Rights ? [Either a b] -> Either a [b]. For some reason I'm not finding it in hoogle
18:20:57 <Axman6> sequence
18:21:13 <sm[m]> that gets only the last right, I believe
18:21:19 <Axman6> % :t sequence @(Either String)
18:21:19 <yahb> Axman6: Monad m => Either String (m a) -> m (Either String a)
18:21:31 <sm[m]> no, I'm wrong ?
18:21:39 <koz_> Axman6: traverse
18:21:44 <koz_> It's always traverse.
18:21:57 <Axman6> uh, wrong type above
18:22:09 <koz_> Oh wait, yeah, sequence.
18:22:15 <sm[m]> thanks!
18:22:22 <Axman6> > sequence [Right 1, Right 2, Right 3] :: Either Bool [Int]
18:22:24 <lambdabot>  Right [1,2,3]
18:22:34 <Axman6> > sequence [Right 1, Right 2, Left False, Right 3] :: Either Bool [Int]
18:22:36 <sm[m]> darn, had it, but messed myself up
18:22:37 <lambdabot>  Left False
18:37:49 * hackage caerbannog 0.6.0.3 - That rabbit's got a vicious streak a mile wide!  https://hackage.haskell.org/package/caerbannog-0.6.0.3 (fozworth)
19:36:19 * hackage medea 1.2.0 - A schema language for JSON.  https://hackage.haskell.org/package/medea-1.2.0 (koz_ross)
20:37:18 * hackage rio 0.1.18.0 - A standard library for Haskell  https://hackage.haskell.org/package/rio-0.1.18.0 (MichaelSnoyman)
20:43:48 * hackage rio-prettyprint 0.1.1.0 - Pretty-printing for RIO  https://hackage.haskell.org/package/rio-prettyprint-0.1.1.0 (MichaelSnoyman)
21:19:03 <hyiltiz> What would the automatic derived fmap would be for `data P a = P a a`?
21:19:26 <hyiltiz> Or better, how can I check the derived fmap?
21:19:37 <lyxia> fmap f (P a a) = P (f a) (f a)
21:19:45 <lyxia> compile with the flag -ddump-deriv
21:19:49 <Axman6> there is only one lawful definition of fmap for that type
21:20:32 <hyiltiz> `fmap f (Bipair x y)= Bipair (f x) (f y)` ?
21:20:50 <hyiltiz> How would   fmap f (Bipair x y)= Bipair (x) (f y) break the law?
21:20:52 <lyxia> oh yeah that
21:20:59 <lyxia> it doesn't type check
21:21:29 <hyiltiz> hmm right
21:21:44 <hyiltiz> so a /= b?
21:23:36 <hyiltiz> since they are arbitrary, they have to be strictly not equal as in "forall a, b, a==b" is false?
21:28:55 <Axman6> basically, the definition says that the two fields will be the same type, so if you apply a function :: a -> b to one, you also need to somehow change the other, and the only way you know how to do that is by using f
21:30:46 <Axman6> fmap f (Bipair a b) = let a' = f a in Bipair a' a' type checks, but does not satisfy the laws, since fmap id x /= id x
21:33:08 <hyiltiz> hmm right; thx!!!
21:48:19 * hackage vulkan 3.6.3 - Bindings to the Vulkan graphics API.  https://hackage.haskell.org/package/vulkan-3.6.3 (jophish)
21:49:49 * hackage VulkanMemoryAllocator 0.3.6 - Bindings to the VulkanMemoryAllocator library  https://hackage.haskell.org/package/VulkanMemoryAllocator-0.3.6 (jophish)
21:52:18 * hackage nonempty-containers 0.3.4.0 - Non-empty variants of containers data types, with full API  https://hackage.haskell.org/package/nonempty-containers-0.3.4.0 (jle)
22:49:19 * hackage bugzilla-redhat 0.3.0 - A Haskell interface to the Bugzilla native REST API  https://hackage.haskell.org/package/bugzilla-redhat-0.3.0 (JensPetersen)
22:51:16 <hyiltiz> Is https://github.com/haskell/haskell-ide-engine the most featureful/convenient emacs workflow? Seems pretty complicated to set up
23:25:48 <sm[m]> depends what you mean by "convenient" I guess...
23:26:30 <sm[m]> haskell-mode & ghcid & ghci is a safer bet
