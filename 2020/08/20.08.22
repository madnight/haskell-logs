01:23:19 <Graypup_> for Nix reasons I am having to mess with flags to Setup. I want to disable a flag defined in the cabal file
01:23:25 <Graypup_> I assume this is the right place to mess with it?
01:37:45 <Graypup_> oh, it's just -f flag
01:38:33 <dps910> what does this `<+>` mean here, very new to haskell and xmonad `manageHook = myManageHook <+> manageHook defaultConfig`
01:39:08 <dps910> also hi :)
01:47:24 <tomsmeding> dps910: no good answer, but at least here's the docs as far as they go: https://hackage.haskell.org/package/xmonad-0.15/docs/XMonad-ManageHook.html#v:-60--43--62-
01:48:57 <dps910> oh nice, thanks! I think that it is :D
01:51:01 <tomsmeding> from glancing around the docs, it seems that here, <+> is just adding myManageHook to whatever hooks are already in the expression 'manageHook defaultConfig'
01:51:25 <tomsmeding> in particular, adding them _after_ those in 'manageHook defaultConfig', since myManageHook is on the left
01:51:39 <tomsmeding> does that make sense in context?
01:53:44 <tomsmeding> (if it doesn't, perhaps paste your code here: https://paste.tomsmeding.com)
01:54:32 <dps910> Yes, that makes sense thanks :)
03:06:38 <dps910> how can I find out what all this means, I am following a tutorial to make key bindings `keys conf@(XConfig {XMonad.modMask = modMask}) = M.fromList $`
03:06:47 <dps910> how can I find out what this means, I am following a tutorial to make key bindings `keys conf@(XConfig {XMonad.modMask = modMask}) = M.fromList $`
03:07:03 <dps910> sry idk how to delete first message
03:08:50 <tomsmeding> (you can't delete, nor edit, messages on irc :) )
03:10:29 <tomsmeding> dps910: can you paste the context of that code? I can explain what that particular line means, but that probably doesn't help you a lot
03:11:44 <tomsmeding> though to answer your general question "how can I find out what this means" -- follow a Haskell tutorial :)
03:12:13 <tomsmeding> that's most likely to give you a more complete understanding than isolated questions; what previous programming experience do you have?
03:44:51 <ggVGc> is there any way I can write something like this? (ValFromTo minVal maxVal) <- copySrcRange (slider, tag)
03:45:05 <ggVGc> or do I need to use a let binding?
03:51:01 <merijn> ggVGc: Eh, that depends on the type of copySrcRange?
03:53:00 <ggVGc> merijn: it's a pattern match that can fail
03:53:11 <ggVGc> and I want it to fail if it doesn't match
03:53:18 <merijn> ggVGc: Then you need MonadFail
04:13:13 <merijn> ah, a Haskell post on HN. I'm sure all the comments will be enligtening and insightful!
04:14:04 <ggVGc> :|
04:14:28 <ggVGc> I never really actively read HN
04:14:31 <ggVGc> except when I get links
04:15:36 <ski> ggVGc : `copySrcRange (slider,tag) >>= \case ValFromTo minVal maxVal -> ..minVal..maxVal..; ...' is an alternative, if you want to specify something more involved for remaining cases
04:16:14 <ggVGc> ski: yeayh... but that's no different from range <- copySrcRange, let (ValFromTo ...) = range
04:16:19 <ggVGc> and then I prefer the latter
04:17:27 <ski> it's different. there you name the intermediate value, and also you're failure semantics is different (no explicit handling of extra cases .. also no use of `MonadFail', of course)
04:17:37 <ggVGc> for my purposes I actually want failing pattern matches when unexpected things happen, because this is a DSL that generates other code, so pattern match failure is basically a compiler error
04:18:19 <ski> mhm
04:19:18 <merijn> ggVGc: Partial patterns in <- are fine, as long as you (can) implement a MonadFail instance :)
04:20:24 <ggVGc> yeah, I think I get it. But in this instance I think I prefer just goiing with the two bindings
04:20:45 <ggVGc> the older I get the less clever I have the patience to be
04:21:09 <ggVGc> I still use Haskell like a toddler
04:22:05 <__monty__> Quote about writing clever code and debugging...
04:22:07 <juri_> ggVGc: you're not alone. :)
04:23:31 <merijn> ggVGc: You mean, you use it productively ;)
04:23:42 <ggVGc> I am patiently waiting for the day I have a clear use of type families
04:24:24 <merijn> ggVGc: https://twitter.com/k0001/status/1295846402648682496 :p
04:25:03 <juri_> i suspect i have a use for them... but there is just so much code to write...
04:27:03 <ggVGc> merijn: yep, agree
04:27:53 <ggVGc> I do still like PureScript in many ways though, specifically because of the extensible records
04:28:00 <ggVGc> think it suits my programming style better
04:28:08 <ggVGc> I always liked extensible records
04:28:20 <ggVGc> but I use haskell because it has better overall support
04:28:24 <VerybadatHaskell> Hi guys. So, i've been tasked to program a function (plu: [Int] -> Int -> [Int]).
04:28:48 <VerybadatHaskell> Never mind that, more is to come, heh..
04:31:21 <merijn> ggVGc: tbh, I think a lot of the advanced stuff people feel guilty about not using is a trap. I see loads of beginners get stuck in a morass of overcomplicated type hackery in their code that's mostly "because they can" than it is because it's practical.
04:32:22 <VerybadatHaskell> Hi guys. So, i've been tasked to program a function (plu: [Int] -> Int -> [Int]) with the input being a list k consisting of integers as well as an integer n. In the output each element e from the list k is replaced by e + n. An example might be: plu [1,2,3] 5 = [5, 7, 8]. Do any of you have any idea how I could create such a function?
04:32:23 <merijn> That's not to say that TypeFamilies/GADTs/etc. aren't useful, they certainly are. But 1) a little goes a long way and 2) until you get experiences it can be hard to judge whether the imposed boilerplate/compile time/pain in refactoring/etc. is actually worth the added safety
04:32:48 <merijn> VerybadatHaskell: Presumably that answer should have '6' as first element? ;)
04:32:52 <jollygood2> hi. I am parsing a ad webpage, and table with the information has too many fields [that vary depending on the type of ad it is] to make data. does  data Ad { {- common fields for all adds -}; adRest :: [(Text, Text)] } seem reasonable?
04:32:55 <jollygood2> an*
04:33:43 <merijn> jollygood2: Sound like adRest wants to be a "Map Text", tbh :p
04:33:45 <VerybadatHaskell> That is indeed true .. goes to show just how bad I am it this, doesn't it
04:34:04 <__monty__> VerybadatHaskell: Have you written a list length function? If not try doing that, it'll inform what to do for this task.
04:34:27 <jollygood2> merijn, yeah. I'm just wondering if it is reasonable to implement this as a map from text to text, regardless of how it is implemented
04:34:29 <ggVGc> merijn: yep, defintely happened to me. Nowadays I barely use type classes
04:34:43 <merijn> VerybadatHaskell: There's 2 ways to create such a function, depending on what your instructor intends. Either 1) manually recurse over the list to generate the answer or 2) use higher-order functions to manipulate the list
04:35:10 <merijn> jollygood2: It does not seem *unreasonable* without further context :)
04:37:09 <jollygood2> merijn I just have to display most ads. some specific ads I need to manipulate further, and I was thinking I could have something like this: adToApartment :: Ad -> Apartment
04:38:14 <tomsmeding> VerybadatHaskell: "goes to show just how bad I am it this, doesn't it"  -- no, it goes to show that you make as many typos as I do :p
04:39:15 <tomsmeding> luck be on you that Haskell is reasonably good at catching typos (at least as compared to other popular languages) ;)
05:01:58 <ggVGc> merijn: the main reason I stopped trying to use almost all of haskel is because everything became too rigid and as you said harder to refactor and rethink (even if it was easy to do because of guidance by types=
05:02:10 <ggVGc> but too much in amount of actual work I needed to do
05:05:17 <maerwald> that's why I don't use haskell for prototyping
05:07:19 <jkaye[m]> That's a bit surprising to me, I actually feel like prototyping in Haskell in nicer than most other languages I've used. It takes a little longer to be sure, but the end result is way closer to what I would actually want in the longer term. Never exactly what I'd want, but compared to the horrors that you can whip together in 45 minutes in Python...
05:07:49 <maerwald> python is magnitudes better in prototyping
05:08:01 <tomsmeding> depends on what kind of thing you're prototyping, I guess
05:08:03 <merijn> Hard disagree ;)
05:08:14 <merijn> and yeah, what your prototyping matters :p
05:08:31 <jollygood2> python is better at shitty, one off scripts. that's about it
05:08:34 <maerwald> if you use your prototype later, it's not a prototype
05:08:44 <maerwald> jollygood2: depends on your proficiency
05:10:05 <maerwald> tomsmeding: doesn't really depend, since python can do anything and usually has an ecosystem for everything (including data science, number crunching, GUI, web servers, ...)
05:10:50 <maerwald> prototyping isn't about how elegant the language is
05:11:00 <xsperry> prototyping often involves making major changes to the existing code. if you don't write tests (and who does when prototyping?) lack of types in dynamically typed languages make things such changes more difficult and error prone. but it depends on the project size
05:11:18 <maerwald> xsperry: use types then
05:11:53 <jkaye[m]> Yes... types in Python... then setup a mypy system for your "throwaway prototype that can never be used again"
05:11:59 <jkaye[m]> Arguing against yourself a little here my friend
05:12:11 <maerwald> why?
05:12:13 <jkaye[m]> It's all nuanced, but prototype does not mean 100% trash code
05:12:24 <jkaye[m]> At least not to me
05:12:32 <maerwald> opt-in types are a strong argument for a good prototyping language
05:13:20 <jkaye[m]> Except that Python's optional types don't do anything without a bunch of config files and build steps
05:13:23 <maerwald> an alternative is lax structural typing, like typescript
05:13:28 <jkaye[m]> Gradual typing like in TS would be better
05:13:30 <maerwald> which is also great for prototyping
05:13:41 <jkaye[m]> Yeah agree with that
05:14:08 <maerwald> jkaye[m]: haskell surely does not require a bunch of config files and build steps?
05:14:56 <jkaye[m]> I'm talking beyond what you'd need to run a system normally. Both will need requirements files etc, of course
05:15:10 <jkaye[m]> Even for a prototype you should keep track of those things, regardless of language
05:16:19 <maerwald> I don't see the problem
05:16:54 <jkaye[m]> Have you ever tried to get mypy to work with a third party dependency in python 3?
05:17:32 <jkaye[m]> If not, I can understand why it's not clear
05:18:09 <maerwald> what is a third party dependency
05:18:19 <jkaye[m]> Anything that you pip install
05:18:26 <maerwald> sure I have
05:19:04 <jkaye[m]> Okay... then you should see the problem with saying "just use types" for Python prototyping
05:19:07 <jkaye[m]> It's not that simple at all
05:19:32 <maerwald> it works well enough for a prototype
05:20:21 <maerwald> the more interesting thing is that mypy isn't exhaustive in a lot of corner cases, but that also barely matters
05:20:56 <maerwald> prototyping isn't about changing your mind all the time
05:21:17 <maerwald> that's what hakellers tend to do (look at how often APIs break)
05:21:30 <VerybadatHaskell> I have the function plu :: Int -> [Int] -> Intplu v [] = vplu v (x:xs) = plu (v+x) xswhich yields the result of my chosen number and list as a number. However, I want to reverse this so that I still add the number to the row, but get another row as a result, so that plu :: [Int] -> Int -> [Int]. Does anyone know what I have to do to the initial
05:21:30 <maerwald> a prototype is about proof of concept
05:21:30 <VerybadatHaskell> code to make this happen?
05:22:02 <jkaye[m]> I think we're just talking about different things. If you're willing to completely throw away what you build, I agree, Python is good for that. If you'd like to poc something and evolve it into something better if it works, in my experience, it's very easy to hamstring yourself from the beginning 
05:22:22 <merijn> lol, people throwing away prototypes
05:22:26 <jkaye[m]> I have learned that I never want to build something that must be entirely thrown away, regardless of how quickly I could do it. But that's just me
05:22:33 <maerwald> jkaye[m]: yes, that's not prototyping
05:22:35 <merijn> Give my regards to the king of fantasy land ;)
05:22:43 <maerwald> merijn: git
05:22:52 <jkaye[m]> Except, it is, you're just applying your narrow definition to everyone
05:22:59 <jkaye[m]> So, this won't be a productive conversation
05:23:00 <maerwald> merijn: ghcup :p
05:23:17 <merijn> maerwald: Sure, we can pedantically insist that a word means something other than how it's commonly used, but that's not very constructive for communication
05:23:30 <maerwald> bash, python, TS... those are the languages I'd use for prototypes
05:23:43 <maerwald> merijn: it is
05:23:56 <mniip> haskell is very suitable for rapid prototyping
05:24:10 <tomsmeding> VerybadatHaskell: if you start with the type signature you want ([Int] -> Int -> [Int]), and do case analysis on the list argument just as you did in the example you gave, where do you get stuck in filling in the right-hand sides?
05:24:20 <maerwald> not in my experience, because you commit to heavy ideas
05:24:34 <merijn> maerwald: Depends on how you write Haskell
05:24:39 <maerwald> streaming lib is already a heavy concept and you can barely go back
05:25:06 <maerwald> every library has types that don't work well with other libraries
05:25:11 <maerwald> you buy into ideas all the time
05:25:25 <maerwald> that's bad for prototyping
05:25:26 <merijn> Anyway, I gotta get back to writing
05:26:01 <xsperry> VerybadatHaskell, shouldn't your function's type be Int -> [Int] -> [Int]?
05:27:07 <turion> How do I pass cabal flags to dependencies, when launching a cabal repl? I'm trying to run a gloss application and I need to pass +glfw -glut to gloss. When I write that in cabal.project.local, it works with cabal run, but not with cabal repl.
05:27:57 <xsperry> VerybadatHaskell, nm, I didn't read your entire message0
05:34:11 <maerwald> turion: did you try `cabal repl -fglfw -f-glut`?
05:34:33 <xsperry> VerybadatHaskell, maybe this will help:
05:34:40 <xsperry> @src map
05:34:40 <lambdabot> map _ []     = []
05:34:40 <lambdabot> map f (x:xs) = f x : map f xs
05:34:46 <maerwald> or `cabal repl --flags="glfw -glut"`"
05:37:58 <tomsmeding> xsperry: the person you're speaking to is probably at a stage where 'map' is not the right thing to talk about
05:38:15 <tomsmeding> also am helping them in a DM, just fyi :)
05:38:29 <tomsmeding> though TIL @src for lambdabot
05:39:14 <xsperry> I'm not sure I'd agree, map is introduced in first chapters of many books. why not help in here? there are likely other newcomers watching
05:42:21 <turion> maerwald: Yes, we tried the first one. We could still try `cabal repl --flags="glfw -glut"`
05:43:19 * hackage opaleye 0.7.0.0 - An SQL-generating DSL targeting PostgreSQL  https://hackage.haskell.org/package/opaleye-0.7.0.0 (tomjaguarpaw)
05:44:34 <maerwald> turion: if you know the exact packages with those flags you can also try `cabal repl --constraint="package -flag"`
05:45:23 <turion> Oh I will try that!
05:45:54 <turion> My problem is just that I don't have a mac. The issue only occurs on a mac.
05:46:10 <turion> Hmm or maybe someone knows how to find out in gloss which backend is selected...
05:48:40 <turion> Are cabal flags always case insensitive?
05:52:46 <maerwald> turion: it is possible that it doesn't find a build play for GLFW
05:53:07 <turion> maerwald: Everything seems to work when doing cabal run, though
05:53:20 <maerwald> well, no idea...  I don't have a mac either
05:54:26 <turion> What do you mean by "doesn't find a build play"?
05:54:55 <maerwald> build plan
05:55:00 <maerwald> flags are not constraints
05:55:35 <turion> Oh and then it just silently drops the effects of the flag?
05:55:38 <maerwald> set the constraint and it should error out
05:57:32 <maerwald> turion: I think flags can be ignored: https://github.com/haskell/cabal/issues/4271#issuecomment-598172694
05:59:04 <turion> maerwald: Ok, that's important
05:59:52 <turion> But still, now I have "constraints: gloss +glfw -glut" in my cabal.project.local and it still uses GLUT
06:04:46 <turion> Also cabal repl --constraint="gloss +GLFW -GLUT" doesn't make GLFW start
06:15:30 <jollygood2> VerybadatHaskell, have you figured it out?
08:50:13 <cheater> hello
08:50:25 <cheater> can you use phantom types together with promoted values?
08:50:39 <cheater> have the promoted value inside the phantom type
08:51:06 <cheater> eg if i have multiple users using a program at the same time, so that the resources of a certain user are only available to that user.
08:51:42 <JalpPlis> hi there
08:52:09 <JalpPlis> i am having some trouble playing a simple wav in haskell using IO
08:52:31 <JalpPlis> I tryied to use SDL but it stops all execution until the wav file is done playing
08:52:43 <JalpPlis> (even though is in another thread)
08:53:05 <JalpPlis> is there any easy-to-use starightforward library to play a wav file asynchronously?
08:53:10 <hc> hmm, try replacing forkIO with forkOS and see if it changes anything? (I've never used SDL with haskell before)
08:53:28 <JalpPlis> i'll try that, i am using forkIO
08:53:30 <JalpPlis> let me see}
08:53:51 <MarcelineVQ> Does anyone know why https://hackage.haskell.org/package/megaparsec-8.0.0/docs/Text-Megaparsec.html#t:MonadParsec requires MonadPlus and not Alternative?
08:54:20 <hc> JalpPlis: normally it shouldn't make a difference in this case; however, if the SDL bindings are done improperly, that may well work around the issue
08:54:56 <MarcelineVQ> JalpPlis: what sdl lib are you using?
08:55:08 <MarcelineVQ> *haskell sdl lib
08:55:18 <JalpPlis> SDL.Mixer
08:55:34 <JalpPlis> it worked! the delay dissapeared, i have some artifacts in the sound now
08:55:40 <JalpPlis> :P  }
08:55:55 <hc> sounds like you wanna use another library;p
08:56:21 <JalpPlis> i just need to play a sound, i doesnt have to be wav
08:56:48 <JalpPlis> tryied to use Honk to use the speaker but it requires root privileges in linux systems haha
08:56:57 <hc> sdl is a very nice library imho; just needs a nice wrapper
08:57:04 <JalpPlis> yes
08:57:13 <JalpPlis> i am working on a chip8 emu
08:57:24 <hc> root to play a sound? you mean through the piezo speaker that is on board?
08:57:26 <JalpPlis> the graphics works flawlessly (they are not very complicated thoug)
08:57:32 <JalpPlis> yes
08:57:44 <hc> makes sense that you need root for doing something that annoying :)
08:57:57 <JalpPlis> hahaha
08:58:31 <hc> ah btw, I've done that in the past. you usually need real time priority if you want this to sound ok
08:58:39 <monochrom> MarcelineVQ: If it requires MonadPlus, then Alternative is also required. If I'm implementing "p :: MonadParsec ... m => m T", I have freedom to use either mplus or <|>.
08:59:28 <monochrom> and also >>=
08:59:59 <JalpPlis> what do you mean by real time priority?
09:00:38 <MarcelineVQ> But what is MonadPlus gaining me? Just the implicit Monad constraint?
09:02:12 <hc> JalpPlis: the sound card usually has a buffer and doesn't need the processor to react as quickly as the amplitude needs to change. the piezo speaker doesn't, afaik
09:02:13 <MarcelineVQ> that is to ask,  are class (Stream s, MonadPlus m) => ...     and   class (Stream s, Alternative m, Monad m) => ...     equivalent given the default defintion for MonadPlus is empty and <|>?
09:02:44 <hc> since the piezo can only play a single frequency at a time, the cpu needs to react the moment that frequency needs to change -> realtime priority needed
09:02:52 <monochrom> What if I'm old school and want to use mzero and mplus?
09:04:29 <JalpPlis> oh
09:05:28 <JalpPlis> so if i were to play a beeping of a single freq i wouldn't need real time priority?
09:07:19 <MarcelineVQ> monochrom: ehe yes that's a reason, I guess I'm looking for gotchas here, if I want to define the class the latter way am I losing anything other than my broader choice of operation names?
09:07:30 <hc> JalpPlis: in this case, no
09:07:52 <monochrom> No.
09:10:15 <MarcelineVQ> I wonder if MonadPlus has potentially more efficient operations due to being able to use >>=, though I can't think of particular case for that
09:11:05 <monochrom> Usually >>= and <|> are doing opposite things and cannot reuse each other.
09:11:46 <MarcelineVQ> yeah hmm, thank you
09:13:09 <hekkaidekapus> The MonadPlus constraint was added for backward compatibility reasons, per https://github.com/mrkkrp/megaparsec/commit/5a68665a906e3b97a2d2bdb6c9d285ee68acd2d3
09:14:13 <monochrom> MonadPlus sitting on top of Monad, Alternative sitting on top of Applicative, MonadIO sitting on top of Monad... These all happen for two reasons:
09:14:31 <monochrom> One is in practice you won't use liftIO without also using >>=
09:15:26 <monochrom> Another is you have a place to write down laws of how liftIO interacts with >>=, <|> interacts with <*>
09:16:11 <c_wraith> not that MonadPlus actually describes how mplus interacts with >>=
09:27:57 <hekkaidekapus> c_wraith: But, it does, doesn’t it? Did you mean “note that…”?
09:29:57 <MarcelineVQ> hekkaidekapus: nice link
09:30:01 <c_wraith> it describes how mzero interacts with >>=.  but not mplus
09:30:19 <maerwald> type classes considered harmful
09:30:34 <maerwald> do you know how (<|>) really behaves?
09:31:02 <maerwald> (e.g. in MonadThrow specialised to IO)
09:31:08 <tchoutri> Hello everyone!
09:31:37 <tchoutri> I have some issues adapting the venerable "Write Yourself a Scheme in 48 hours" to use Megaparsec
09:32:20 <tchoutri> And especially some Parsec expressions that *seem* fairly straightforward, like this one: `symbol = oneOf "!#$%&|*+-/:<=>?@^_~"`
09:32:48 <hekkaidekapus> c_wraith: You’re right, of course.
09:33:23 <c_wraith> hekkaidekapus: heh.  "of course" is pushing it.  I make lots of vocal mistakes. :)
09:33:55 <tchoutri> pretty basic, yet the typechecker is unhappy and says "Ambiguous type variable ‘f0’ arising from a use of ‘oneOf prevents the constraint ‘(Foldable f0)’ from being solved."
09:34:27 <hekkaidekapus> c_wraith: I was just failing to … parse some sentence. By the way, MonadPlus is strange, does it have laws?
09:34:31 <c_wraith> tchoutri: do you have OverloadedStrings enabled?
09:34:42 <tchoutri> (the thing is, I don't have any type variable `f0` in my type signature, the expression is simple `Parser Char`, where Parser is `type Parser = Parsec Void Text`)
09:34:52 <tchoutri> c_wraith: I should!
09:35:03 <tchoutri> I have it in my cabal file
09:35:05 <c_wraith> tchoutri: the f it's talking about is in oneOf - https://hackage.haskell.org/package/megaparsec-8.0.0/docs/Text-Megaparsec.html#v:oneOf
09:35:22 <hekkaidekapus> MarcelineVQ: Maybe a pull request to root out MonadPlus since megaparsec is nowadays `tested-with:          GHC==8.4.4, GHC==8.6.5, GHC==8.8.1`?
09:35:23 <c_wraith> tchoutri: it doesn't know what type your string literal is
09:35:53 <c_wraith> tchoutri: in that case, you want it to actually be String
09:35:54 <tchoutri> c_wraith: so… should the type signature be `symbol :: Parser [Token Char]` instead?
09:36:12 <tchoutri> ah, String? hmm. Is there a way to cheat and get back some `Text` instead?
09:36:16 <c_wraith> tchoutri: no, just specify the type.  oneOf ("whatever" :: String)
09:36:17 <tchoutri> I don't really need a linked list
09:36:21 <tchoutri> oh okay, perfect!
09:36:51 <c_wraith> tchoutri: this is why I really don't like OverloadedStrings.  Breaks type inference all over.
09:37:40 <tchoutri> I see
09:38:55 <tchoutri> Thank you very much c_wraith :)
09:39:29 <c_wraith> In this case String is fine because you're really just using it as a container to pass in a bunch of Char values.  Since it uses the Foldable interface, it obviously doesn't keep it in the input form.
09:40:08 <tchoutri> Yeah, I just realised ^^
09:40:53 <c_wraith> well, carry on!  I never went through that project, but it always looked like a fun one.
09:41:50 <tchoutri> Yeah I've always wanted an up-to-date version of this tutorial, so… it seems like a good project to undertake!
09:42:07 <tchoutri> I can ping you once it's published, if you want
09:45:34 <c_wraith> Eh, throw it on reddit's r/haskell and I'll catch it there :)
09:47:19 * hackage xmobar 0.36 - A Minimalistic Text Based Status Bar  https://hackage.haskell.org/package/xmobar-0.36 (JoseAntonioOrtegaRuiz)
09:49:20 <tchoutri> Fair enough :P
09:56:41 <hekkaidekapus> maerwald: If you want to go off, here is another one (staying with megaparsec): https://github.com/mrkkrp/megaparsec/issues/412
09:57:54 <maerwald> :)
10:07:46 <JalpPlis> well hc, i ended up using another lib :P
10:08:02 <JalpPlis> proteaaudio
10:08:12 <JalpPlis> thanks for the feedback and help
10:08:39 <JalpPlis> i would buy you a beer if i we were close geographically (?)
10:23:27 <maerwald> even then it might not be a good idea these times :p
10:44:49 * hackage pandoc-plot 0.9.2.0 - A Pandoc filter to include figures generated from code blocks using your plotting toolkit of choice.  https://hackage.haskell.org/package/pandoc-plot-0.9.2.0 (LaurentRDC)
10:55:29 <pounce> will haskell ide engine work for literate haskell? (preferably the TeX version)
11:06:48 <maralorn> haskell ide engine or haskell language server?
11:06:48 <maralorn> pounce: ^
11:06:48 <maralorn> If the former I am not sure if the future tense is applicable, if the later, if you give me a simple example file I can test it out for your.
11:19:49 * hackage nonempty-containers 0.3.4.1 - Non-empty variants of containers data types, with full API  https://hackage.haskell.org/package/nonempty-containers-0.3.4.1 (jle)
11:35:11 <slack1256> Is the `penny``package a fork of `hledger`?
11:35:30 <sm[m]> no
11:43:14 <pounce> maralorn: ah ok, i think i'll just test it out myself
11:43:42 <pounce> I use haskell ide engine though
11:48:32 <maerwald> sm[m]: sup
11:49:31 <sm[m]> hey hey
12:40:16 <dminuoso> Imagine you're given a very thin wrapper around a C library. So some enums/define sets are mapped into a sum type of nullary data constructors, which has some CEnum instance (similar to Enum, but with MonadFail on fromCEnum).
12:40:50 <dminuoso> Now, at times there are bitmasks. Would you expect the library to decompose a bitmask into say [Foo], or maybe rather a Word32 that you compose/decompose yourself?
12:42:34 <dminuoso> Im finding it rather difficult to decide where to draw the line here in the library. How do I even decide here?
12:44:02 <xerox_> dminuoso: maybe just another sum with a monoid instance
12:45:03 <dminuoso> A sum of what?
12:45:53 <xerox_> another sym type I mean
12:45:56 <xerox_> *sum
12:46:08 <dminuoso> I mean the closest representation I have is maybe some `newtype CEnumSet a = CEnumSet { unCEnumSet :: Set (EnumTy a) }`, where EnumTy is an associated tyfam from CEnum that produces the underlying type
12:47:30 <dminuoso> And then I'd expose the common set functionalities appropriately, so I could do something like `CEnumSet.fromList [Quux, Bar]` - and CEnum could then have some `fromBitmask :: MonadFail m => EnumTy a -> m (CEnumSet a); toBitmask :: CEnumSet -> EnumTy a`
13:07:42 <sureyeaah> what's the simple way to deliberately crash ghci?
13:07:55 <sureyeaah> s/the/a
13:08:46 <dminuoso> sureyeaah: unsafeCoerce?
13:09:18 <koz_> sureyeaah: head undefined
13:09:48 <sureyeaah> koz_: that just gives an exception
13:09:56 <koz_> Ah.
13:09:58 <dminuoso> sureyeaah: unsafeCoerce "a" :: IO ()
13:11:04 <dminuoso> % import Unsafe.Coerce
13:11:05 <yahb> dminuoso: 
13:11:09 <dminuoso> % unsafeCoerce () :: IO ()
13:11:09 <yahb> dminuoso: 
13:11:16 <dminuoso> % unsafeCoerce "a" :: IO ()
13:11:16 <yahb> dminuoso: <interactive>: internal error: stg_ap_v_ret; (GHC version 8.10.1 for x86_64_unknown_linux); Please report this as a GHC bug: https://www.haskell.org/ghc/reportabug; [Aborted]
13:11:18 <dminuoso> There. :)
13:11:41 <dminuoso> (You can also do this with unsafePerformIO, it's just slightly more elaborate)
13:12:35 <sureyeaah> dminuoso: thanks!
13:12:56 <sureyeaah> Why does that specifically cause a crash and not an exception?
13:13:19 <dminuoso> % :t unsafeCoerce
13:13:20 <yahb> dminuoso: a -> b
13:13:24 <dminuoso> sureyeaah: ^- can you see why?
13:15:13 <dminuoso> In the above code, Im explicitly saying "here's some thing, *trust* me what Im giving you is *really* an IO action.
13:15:32 <dminuoso> GHC will not check, it will just trust you.
13:16:31 <sureyeaah> dminuoso: yeah I can see that we're messing with the types which should cause a crash. I guess I'm curious for example division by 0 or a koz_ suggested `head undefined` would stop at an exception instead of a crash
13:16:59 <sureyeaah> s/for example/for example why
13:17:01 <dminuoso> sureyeaah: The implementation for division by zero contains code that generates an exception.
13:17:20 <dminuoso> The key difference to understand, is that the internal object layout wont match what is expected with unsafeCoerce.
13:19:26 <sureyeaah> dminuoso: aaha. And I guess same goes for undefined - there is an exception for undefined.
13:19:55 <int-e> dminuoso: I'm always amazed by this "Please report this as a GHC bug"... because it's so easy to trigger.
13:20:17 <dminuoso> @src undefined
13:20:17 <lambdabot> undefined = error "Prelude.undefined"
13:20:19 <dminuoso> sureyeaah: ^-
13:20:54 <int-e> But somehow, people seem to realize (most of the time) when it's their own fault :P
13:21:26 <dminuoso> int-e: heh. Reminds me of how accursedUnutterablePerformIO creates numerous GHC bug reports, but the cause was just bugs in bytestring.
13:21:39 <dminuoso> Or, created rather. I dont think there's been a recent bug with it.
13:22:13 <int-e> Good old times.
13:22:31 <int-e> dminuoso: It was called inlinePerformIO at the time :P
13:22:38 <dminuoso> heh
13:22:44 <dminuoso> Sounds quite encouraging
13:23:03 <sureyeaah> dminuoso: how can I do a crash using unsafePerformIO?
13:23:14 <int-e> And dons and dcoutts knew what they were doing. Almost. Kind of. Maybe not. Curses!
13:23:22 <dminuoso> sureyeaah: You can implement unsafeCoerce with unsafePerformIO
13:23:23 <int-e> (I'm probably forgetting somebody.)
13:23:43 <c_wraith> sureyeaah: the docs for unsafePerformIO even tell you how to use it as unsafeCoerce
13:24:19 <sureyeaah> Interesting, I will have a look at it.
13:24:35 <dminuoso> int-e: Amusingly, I managed trip into the exact same bugs that "inlinePerformIO" did but with unsafePerformIO on IORefs.
13:25:02 <dminuoso> It took me quite a while to understand some highly bizarre effects, when I had a bunch of objects with IORefs, all evidently using a shared buffer.
13:25:18 <dminuoso> That was the last time I ever used unsafePerformIO - it really is unsafe. :-)
13:25:27 <int-e> runST + unsafeCoerce = unsafePerformIO. (The runST is awkward but it's hard to find a function that applies a function to a Void# argument)
13:26:47 <dminuoso> (Concretely, the code path did something along the lines of `map (\x -> ... Thing { buf = unsafePerformIO (newIORef Nothing) })`
13:27:01 <dminuoso> Looked so reasonable at the time..
13:27:36 <int-e> Ah, *creating* IORefs with unsafePerformIO? Ouch.
13:28:16 <dminuoso> Yeah. GHC floated that outwards into a let binding. 
13:28:24 <dminuoso> Which is definitely not what I wanted. :)
13:29:04 <dminuoso> The annoying part why I didnt find it right away, is that a later code modification triggered that optimization. So git bisect kept pointing me at the wrong commit
13:31:46 <ixlun> Suppose I have a function: Array -> index -> something.  Then when I access the Array at the index I get a Maybe value.  Is there a way to get to the Just value inside the function (inside a where clause or something)?  The only way I've found to do it at the moment is to define a new function that also includes the value at the index, something like:  Array -> index -> Maybe val -> something 
13:32:18 <ixlun> I'm just wondering if there is a way that I could do that without having to define a new function
13:32:58 <dminuoso> ixlun: What is your Array type?
13:33:09 <dminuoso> ixlun: Anyhow, the answer is just pattern matching.
13:33:28 <dminuoso> f a i = case lookup a i of Nothing -> ...; Just x -> ...;
13:33:42 <int-e> :t maybe
13:33:43 <lambdabot> b -> (a -> b) -> Maybe a -> b
13:34:06 <ixlun> dminuoso: Data.Array
13:34:17 <ixlun> Just using (!) to lookup
13:34:35 <int-e> I don't understand the relevance of arrays to the question.
13:34:56 <dminuoso> Heh, maybe is one of those bits I cant get used to.
13:35:01 <dminuoso> Pattern matching feels a bit cleaner and readable
13:35:22 <int-e> There's no single occurrence of "Maybe" in https://hackage.haskell.org/package/array-0.5.1.0/docs/Data-Array.html
13:36:22 <ixlun> but my element type 'e' is a Maybe
13:36:24 <int-e> :t fromJust {- *if* you're certain that "Nothing" will never occur or if you don't mind having errors that are hard to track down -}
13:36:25 <lambdabot> Maybe a -> a
13:37:03 <int-e> > let Just x = return 1 in x
13:37:05 <lambdabot>  1
13:38:35 <ixlun> int-e: I think what I was asking is how to match a pattern after doing an array access, but I can just use: case array ! idx of
13:39:19 <ixlun> I didn't think of using a case to match the result of the array access  
13:40:45 <hekkaidekapus> ixlun: You could also use the richer APIs in vector, say `Data.Vector.!?`.
13:42:28 <ixlun> Yeah, I've only recently found out about Vector, which AFAICS are basically the same as Data.Array just with a richer API?
13:43:01 <hekkaidekapus> Yep, something along those lines.
13:43:36 <ixlun> nice, thanks hekkaidekapus.  I'll do some reading :-)
13:44:25 <hekkaidekapus> \o/
13:45:53 <ixlun> Although the only thing that puts me off is that, it looks as though you can only use Int as an index?  Can you have Vectors that use Ix as an index? 
13:46:40 <dolio> No.
13:47:20 <dolio> Ix introduces extra overhead on every access, and vector is trying to avoid that sort of thing.
13:54:33 <Cale> You can of course use Ix on its own to compute indices for you
13:54:50 <hyiltiz> @where paste3
13:54:50 <lambdabot> tomsmeding's proof that programming > discussing: https://paste.tomsmeding.com/
13:56:07 <hyiltiz> https://paste.tomsmeding.com/paste/qdEtchAr Given the binary tree and its fold, what's the identity for the tree data constructors using fold? id=foldr (:) [] for lists
13:56:25 <xsperry> instead of fromJust, why not fromMaybe (error "functionName: this should not have happened"), or similar.  then at least you know where it happened
13:56:43 <comerijn> hyiltiz: Who says their is one?
13:56:52 <comerijn> eh
13:56:55 <comerijn> s/their/there
13:57:00 <hyiltiz> If none, how would one go about proving that statement?
13:57:04 <Cale> Better still, (\(Just x) -> x), because that will include a nice source location for you in the message
13:57:08 <Cale> (and it's shorter)
13:57:36 <comerijn> hyiltiz: ha, now there's a tricky question :p
13:57:49 <xsperry> Cale nice. that works with default ghc/ghci arguments?
13:57:53 <Cale> yeah
13:58:09 <Cale> > (\(Just x) -> x) Nothing
13:58:11 <lambdabot>  *Exception: <interactive>:3:2-15: Non-exhaustive patterns in lambda
13:58:22 <comerijn> hyiltiz: The reason why foldr has an identiy for lists is because foldr happens to match the Church encoding of lists
13:58:34 <hyiltiz> If the fold's traversal implementation has an isomorphism to the tree construction procedure, then simply plugging in the constructors at appropriate places should give the identity.
13:58:40 <Cale> That <interactive>:3:2-15 will in general be the module name, and the line number/column numbers
13:59:15 <hyiltiz> Can one implement a tree fold based on Church encoding then?
13:59:46 <xsperry> Cale, my version includes line number as well, but yeah, yours is shorter
14:00:14 <comerijn> hyiltiz: The Church encoding of a tree looks very different from a fold, though. You can implement a fold on the Church encoding of a tree, but then you lose the ability to reconstruct it again
14:00:50 <comerijn> hyiltiz: fold over a tree picks one of many traversal orders, but that order isn't visible in the fold output, so you cannot reconstruct the original order
14:01:46 <xsperry> actually, in lambdabot, it doesn't include line number. so maybe it is one of the dozen options I have set
14:01:55 <xsperry> > fromMaybe (error "myFunc: this should not have happened") Nothing
14:01:57 <lambdabot>  *Exception: myFunc: this should not have happened
14:03:22 <comerijn> hyiltiz: But proving that is beyond what I can be arsed to do it 23:00 (assuming I could prove it even when I'm fresh)
14:05:22 <dolio> I don't understand. The Church encoding of a tree looks exactly like a fold.
14:05:38 <dolio> It just doesn't look like one of the functions in Foldable or something.
14:05:42 <comerijn> dolio: Not the Foldable fold
14:06:00 <dolio> Or, it does. Just not identical to one.
14:06:33 <comerijn> dolio: It looks like a fold if folds look like "elimination rules" to you (which, admittedly they do to me, sorta)
14:07:11 <comerijn> dolio: Also, this depends on what your tree looks like too ;)
14:07:49 <dolio> People have been referring to elimination rules as 'folds' for a long time.
14:08:41 <dolio> Longer than Foldable has existed, I think.
14:08:47 <comerijn> dolio: theoretical computer scientists, sure. Random people on the internet learning programming languages probably have a rather different mental image than Foldable
14:09:20 <comerijn> So then the question is, for which groups perspective do you answer questions here
14:09:26 <comerijn> s/for/from
14:11:54 <MarcelineVQ> wasn't the question 'what does the fold(cata) look like for my tree?'
14:11:56 <hyiltiz> hmm, if the Chuch encoding of (which/what) trees "look exactly like a fold", then we can have the identify after all
14:12:16 <hyiltiz> I am fine with going for a slightly different binary tree
14:12:48 <dolio> hyiltiz: The fold for your tree is `(a -> r) -> (r -> r -> r) -> T a -> r
14:13:04 <hyiltiz> I was doing data T a=L a|B (T a) (T a), but we can do data TT a=E|BB (TT a) a (TT a) as well
14:13:37 <dolio> Then `fold L B = id`
14:14:50 <hyiltiz> Ok so a more "natural" fold for that T tree is `(a -> r) -> (r -> r -> r) -> T a -> r` rather than `(a -> b -> b) -> b -> T a -> b`
14:15:01 <dolio> The type of the fold of this sort depends on the structure of the data type.
14:15:26 <comerijn> hyiltiz: The fold of Foldable is basically "toList"
14:15:49 <comerijn> hyiltiz: So the only structure recoverable via Foldable is "structures that can be recovered from lists"
14:16:23 <comerijn> hyiltiz: You can also view "fold" as the more generalised "elimination rule" and then you get folds like the one dolio suggests (i.e. the Church encoding)
14:16:43 <hyiltiz> Like a tree that has elements only on left branch and right always branches off?
14:16:50 <dolio> The distracting thing is that the fold for this type has almost the same type as `foldMap`, but that is because it's basically a list of `a` values that have some chosen association.
14:17:04 <comerijn> hyiltiz: Right
14:17:13 <comerijn> hyiltiz: So that can't possibly do "all" trees
14:17:20 <hyiltiz> But that tree is just a fancy looking list
14:17:37 <hyiltiz> no different than []|a:[]
14:17:39 <comerijn> hyiltiz: But as dolio demonstrates it's trivial to get the identity from a Church encoding
14:29:31 <frdg> the process taking up the most memory on my computer is `~/.stack/programs/x86_64-linux/ghc-tinfo6-8.8.3/lib/ghc-8.8.3/bin/GHC -B /......` is this ghcid?
14:31:13 <sm[m]> frdg: quite possibly, I think it sometimes loses track of processes
14:32:06 <hyiltiz> Got it: https://paste.tomsmeding.com/paste/yQ3GgtMv Thx dolio comerijn MarcelineVQ :D
14:32:46 <frdg> sm[m]: ok. I don't think anything else related to stack would be using lots of memory but I am not sure.
14:42:32 <sm[m]> frdg: it should be safe to kill such hogs, worst case you'll see a ghci[d] session or a build die and have to restart it
14:49:46 <byorgey> how would you write code to efficiently find the length of the longest common prefix of two ByteStrings?
14:50:16 <byorgey> i.e. without generating any intermediate lists
14:50:54 <comerijn> byorgey: looping by index?
14:52:03 <dminuoso> Well, at the very least you should do it word-wise probably
14:52:24 <dminuoso> And by word I mean whatever is the native size on your architecture
14:52:38 <hyiltiz> Do BSs have Alternative instance?
14:52:50 <dminuoso> hyiltiz: What is the kind of Alternative?
14:52:58 <dminuoso> And the kind of ByteString? :)
14:53:37 <byorgey> comerijn: true, I could just explicitly loop and test each index.  I wonder if there's a higher-level way to do it.
14:53:52 <byorgey> dminuoso: I don't think I understand what you mean when you say to do it word-wise
14:54:38 <dminuoso> byorgey: well rather than comparing the internal char buffer per byte, compare it per 64 bit chunk. Once you find the longest prefix on that, you check on that per byte. It depends on what your expectancy of the prefix length is.
14:56:06 <byorgey> dminuoso: I'm still not sure I understand.  Is comparing two 64 bit chunks directly really faster than comparing them byte by byte?
14:57:59 <byorgey> oh, never mind, I think I understand what you're saying now.  I was thinking of '64 bit chunk' in terms of a 64-bit index.  But you mean literally each chunk of 64 bits which encodes 8 bytes.
14:58:06 <dminuoso> Right.
14:58:45 <dolio> Yeah, it's 8x faster in most cases.
14:58:53 <dolio> Well, successful cases.
14:59:22 <dolio> And a little more work for the unsuccessful case maybe.
14:59:50 <byorgey> makes sense.  And am I correct that you can't do that using only the normal public ByteString API?
14:59:58 <dminuoso> byorgey: The memory access will work out nicely, since on most modern architectures the cache lines are 64 bytes. So you'll have 64 bytes in L1 cache anyhow.
15:00:09 <dminuoso> Might as well test as large as you can.
15:00:17 <dolio> I don't remember it having a word interface.
15:00:19 <byorgey> right
15:00:42 <byorgey> Maybe for starters I'll go look and see how 'isPrefixOf' is implemented.
15:01:03 <dolio> I think there's a vector type with the same representation as bytestrings, though.
15:01:17 <AhMybad> Can anyone please explain to be why my code doesn't work? (Keep in mind, I am just getting started with programming as a whole): pali :: [a] -> Boolpali xs = xs == (reverse xs)
15:01:21 <comerijn> You can trivially coerce bytestrings to storable vectors
15:01:39 <dminuoso> AhMybad: Can you explain further? What do you expect it to do? What does it do instead?
15:01:46 <dminuoso> If you've gotten an error, what is the error?
15:01:47 <comerijn> See https://github.com/merijn/Belewitte/blob/master/benchmark-analysis/src/Utils/Vector.hs
15:02:17 <comerijn> dminuoso: He's lacking an Eq constraint :p
15:02:23 <dminuoso> comerijn: Im well aware. 
15:02:32 <dminuoso> ;)
15:02:55 <AhMybad> Ah, so I do in fact need the constaint?
15:02:57 <dminuoso> Right.
15:03:02 <sureyeaah> AhMybad: are you familiar with constraints in haskell?
15:03:10 <dminuoso> AhMybad: We can't test arbitrary types for equality, since we don't know what that means in general.
15:03:48 * hackage essence-of-live-coding 0.2.3 - General purpose live coding framework  https://hackage.haskell.org/package/essence-of-live-coding-0.2.3 (turion)
15:04:49 * hackage essence-of-live-coding-warp 0.2.3, essence-of-live-coding-quickcheck 0.2.3, essence-of-live-coding-pulse-example 0.2.3, essence-of-live-coding-pulse 0.2.3, essence-of-live-coding-gloss-example 0.2.3, essence-of-live-coding-gloss 0.2.3 (turion)
15:04:54 <AhMybad> pali :: (Eq a) => [a] -> Bool, I mean, I reckon that should be the initial code, I was just confused as the assignment only contained information "program a function pali: [a] -> Bool
15:05:35 <AhMybad> I guess this means I do in fact need the constaint on a after all, regardless of how the assignment was phrased
15:06:15 <dminuoso> Indeed. The assignment is faulty.
15:07:28 <AhMybad> Ah, cheers mate, was getting a massive headache trying to figure out how to leave the constraint out of it
15:07:30 <byorgey> TIL: the implementation of isPrefixOf for ByteString involves 'accursedUnutterablePerformIO' and 'memcmp'
15:08:40 <hyiltiz> dminuoso: all kinds of BS of anyone's choosing :D
15:08:57 <dminuoso> hyiltiz: No by kind I mean the kind system.
15:09:12 <dminuoso> Types are to values, as kinds are to types.
15:09:21 <hyiltiz> (OIC) I thought you were just going for the pun
15:10:09 <sureyeaah> lambdabot accursedUnutterablePerformIO
15:10:20 <dminuoso> byorgey: I think that's as performant as it can get.
15:10:34 <sureyeaah> lambdabot @hoogle accursedUnutterablePerformIO
15:10:52 <dminuoso> sureyeaah: It's a highly unsafe variant of unsafePerformIO used in bytestring.
15:10:53 <sureyeaah> @hoogle accursedUnutterablePerformIO
15:10:53 <lambdabot> No results found
15:11:03 <hyiltiz> It seemed byorgey's question could be answered with <*> and <|>
15:11:05 <dminuoso> An internal
15:11:36 <sureyeaah> dminuoso: yeah, just saw its documentation and I'm amused and scared
15:13:29 <hyiltiz> http://ix.io/2uX1 deduces from function composition that "computation is inherently hierarchical"; that seems too large a gap, if not just by (misguided) faith?
15:13:35 <comerijn> unsafeDupablePerformIO is the unsafe version of unsafePerformIO and accursed is the unsafe version of unsafeDupable ;)
15:14:16 <hyiltiz> The whole book mentions "recurs*" only three times and Alonzo Church once; but given it is a "psychology" book, you'd have to forgive
15:15:24 <sureyeaah> hyiltiz: source?
15:15:41 <dminuoso> hyiltiz: Re Alternative: It doesn't make much sense. bytestring is of kind *, Alternative is for things of kind * -> *
15:16:03 <dminuoso> Also, his question does not seem related to either Alternative nor Applicative at all. ;)
15:18:38 <hyiltiz> Keeping an accumulator while performing comparison of a pair (Applicative) until a failure (Alternative) seemed like it to my noob eyes; apoloiges for overthinking
15:19:28 <dminuoso> Ah I see what you're getting at
15:22:05 <hyiltiz> Hmm ok; now I am thinking about somehow constructing a "natural" transformation for * kinded BS to make then *->* kinded; but I guess that is too dedactic and useless in practice
15:22:17 <hyiltiz> I'll go look up the source for that book
15:22:52 <dminuoso> hyiltiz: The cat you're chasing at is up another hill.
15:23:35 <dminuoso> Rather than trying to figure out "how to make bytestring kinded * -> *, the general solution is in mono-traversable rather.
15:24:00 <dminuoso> And there's no MonoApplicative for obvious reasons, though one could make a MonoMonad at least if so desired.
15:24:16 <hyiltiz> Gallister & King (2010), Memory and the Computational Brain, p. 48
15:24:20 <dminuoso> But anyway, neither of these solutions is going to be helpful for variety of reasons.
15:25:40 <hyiltiz> Re: Mono* and kinds: gotcha
15:26:59 <dminuoso> In addition, Im confident byorgey was not looking "how to do failure in Haskell", but rather for hints how to hack efficiently around the internals of bytestring.
15:27:12 <dminuoso> They've done a bit or two in Haskell. ;)
15:27:30 <ADG1089> >:t fmap
15:27:40 <dolio> Just :t
15:27:41 <ADG1089> :t fmap
15:27:42 <lambdabot> Functor f => (a -> b) -> f a -> f b
15:28:49 <ADG1089> :t (->)
15:28:50 <lambdabot> error: parse error on input ‘->’
15:29:11 <ADG1089> > isinstance (->) Functor
15:29:13 <lambdabot>  <hint>:1:13: error: parse error on input ‘->’
15:30:31 <dminuoso> ADG1089: You can use a private message with lambdabot to experiment with it
15:30:43 <ADG1089> thanks!
15:30:53 <dminuoso> ADG1089: By the way, there exists an `instance Functor ((->) a)` that you probably are looking for.
15:31:32 <ADG1089> I wanted to use (->) as a writer monad but I will need mtl
15:32:02 <dminuoso> Mmm, I dont think that'll work out.
15:32:27 <dminuoso> Also, what does it even mean to "use (->) as a writer monad"?
15:34:50 <ADG1089> data GenLocated l e = L l e deriving (Eq, Ord, Data, Functor, Foldable, Traversable)
15:35:29 <ADG1089> then I want [GenLocated l e] -> GenLocated l e combining es using mappend
15:35:46 <dminuoso> % :t fold
15:35:46 <yahb> dminuoso: (Foldable t, Monoid m) => t m -> m
15:40:49 * hackage nix-tree 0.1.1.0 - Interactively browse a Nix store paths dependencies  https://hackage.haskell.org/package/nix-tree-0.1.1.0 (utdemir)
16:13:19 * hackage shake-plus 0.3.3.0 - Re-export of Shake using well-typed paths and ReaderT.  https://hackage.haskell.org/package/shake-plus-0.3.3.0 (locallycompact)
16:38:49 * hackage generic-functor 0.1.0.0 - Deriving generalized functors with GHC.Generics  https://hackage.haskell.org/package/generic-functor-0.1.0.0 (lyxia)
17:22:02 <byorgey> re: finding the longest common prefix of bytestrings, it turns out that just comparing index-by-index was fast enough for what I needed, and didn't require poking around in the internals of bytestring.
17:23:23 <byorgey> still might be kind of fun to figure out how to do it a word at a time though.  Could you just get a ForeignPtr Word8  and unsafely cast it to ForeignPtr Word64?  Or is that going to break something?
17:24:13 <byorgey> In case anyone is curious, I was solving https://open.kattis.com/problems/rimstyrka
18:47:23 <infinisil> byorgey: After thinking about that problem, I believe I've got an idea for an optimal solution, only processing each character once
18:47:41 <infinisil> Not sure if I wanna spoil it though :P
18:49:09 <sim590> I'm printing some characters on the screen (using NCurses library) and I'm getting some inverted characters. What I'm printing are unicode emojis. Here's an example of what I'm getting: https://i.imgur.com/rdxukMG.png while I should be getting the following: 1) ʕ •́؈•̀)     2) ʘ‿ʘ
18:49:46 <sim590> So you see that the character 2 has been inverted with this part of the emoji: ؈•̀).
18:50:12 <sim590> I'm asking myself if I'm misusing Text or IO functions
18:51:49 <sim590> You can see the data file where I'm getting my characters: https://github.com/sim590/emo/blob/master/data/emo.csv.
18:52:24 <sim590> The emojis I tried in my example are on line respectively 71 and 1.
18:53:16 <sim590> I'm recovering characters from the CSV file with functions of this module https://github.com/sim590/emo/blob/master/src/Csv.hs.
18:53:43 <sim590> I'm writing the characters here: https://github.com/sim590/emo/blob/master/src/Display.hs#L142-L156.
18:54:20 <sim590> The bytes are first read here: https://github.com/sim590/emo/blob/master/src/Main.hs#L57 though with the `readFile` function which returns an IO String.
19:04:08 <sim590> Any idea if my issue is about encoding in general and not due to my usage of Haskell data types or not?
19:10:09 <hyiltiz> Is it typical of a commercial real world application to be over 10k+ LOC, like Wire-server (about 90k LOC) http://ix.io/2uXN https://github.com/wireapp/wire-server
19:11:43 <hyiltiz> While Signal-Server is about 30k LOC of Java
19:12:33 <indian_yogi> hello every1
19:12:45 <indian_yogi> can i ask general career in computer science questions here?
19:14:05 <hyiltiz> Wait looking inside, Signal-Server has mostly its own stuff while Wire-Server has even rope wai ssl-util cassandra sodium etc.
19:14:18 <hyiltiz> indian_yogi: dont ask to ask just ask
19:14:34 <hyiltiz> worst case u dont get an answer if ur question is not proper
19:26:46 <indian_yogi> i am 30 year old from India did my bachelors in 2012 passout, did not work in the industry, now thinking of getting admission into masters programme in India, i'm from cse background, is it a good step to take?
19:29:24 <Lycurgus> passout?
19:30:07 <Lycurgus> ah graduate
19:31:34 <Lycurgus> an no, ur too old now
19:32:27 <hyiltiz> indian_yogi: how is it relevant to this channel?
19:32:49 <mmaruseacph2>  
19:33:13 <Lycurgus> duh, knowitalls R us
19:34:15 <mmaruseacph2> sorry, typo due to network loss
19:50:16 <indian_yogi> really no chance?
19:51:09 <indian_yogi> hmm, i think i'm mentally sick now
19:51:29 <indian_yogi> think, have a failed life
19:51:43 <wavemode> indian_yogi, you're more likely to get career advice on #programming. this channel is specifically for discussion of the haskell language
19:51:45 <indian_yogi> don't know what to do
19:51:59 <indian_yogi> ok
20:17:25 <Guest60473> hi
20:29:43 <root____2> join #i3
21:09:16 <hololeap> would foldM using `WriterT (Maybe (First r)) m a` break out of the loop once `tell (Just (First x))` is used?
21:10:50 <hololeap> or will it continue reading from the Foldable until the end?
21:11:25 <pounce> does `concat` avoid the painter's problem of using multiple appends
21:19:10 <Turmfalke> Is there some clever short combinator for `\f cs -> if null cs then [] else f cs`?
21:20:56 <Cale> pounce: painter's problem? concat associates to the right, as it should in order to be linear cost in the total number of items.
21:20:57 <hololeap> Turmfalke: depends on what `f` is
21:21:16 <Turmfalke> An arbitrary function
21:21:42 <hololeap> then no, at least not that i'm aware of
21:22:18 <hololeap> it looks like the answer to my question is: no, it does not break out of the loop
21:23:01 <Turmfalke> Okay
21:23:15 <Cale> hololeap: Yeah, it can't, because the effects from the rest of the list still need to happen.
21:23:40 <Cale> You'd need to write something that was more particular to that monad in order to get an early break
21:24:11 <hololeap> maybe mapAccumR would work
21:25:20 <hololeap> eh, not quiet
21:25:25 <hololeap> *quite
21:25:52 <ski> > (runIdentity . execWriterT . forever) (tell (First (Just "x")))
21:25:54 <lambdabot>  First {getFirst = Just "x"}
21:25:56 <ski> > ((`execState` ()) . execWriterT . forever) (tell (First (Just "x")))
21:26:02 <lambdabot>  mueval-core: Time limit exceeded
21:27:17 <ski> hololeap : depends on `m'
21:27:25 <hololeap> so it only works if the "inner" monad is Identity or what?
21:27:45 <ski> > ((`runReader` ()) . execWriterT . forever) (tell (First (Just "x")))
21:27:47 <lambdabot>  First {getFirst = Just "x"}
21:28:07 <hololeap> m is STM in this case
21:28:21 <hololeap> although that's now how i tested it
21:28:29 <hololeap> (tested my question, that is)
21:28:41 <ski> (itym s/now/not/)
21:29:03 <hololeap> right
21:30:22 <hololeap> findDelete :: (a -> Maybe r) -> DelayQueue a -> STM (DelayQueue a, Maybe r)
21:30:33 <ski> it'd not expect it to short-circuit the loop, with `STM', no
21:30:46 <hololeap> newtype DelayQueue = DelayQueue (Seq (TVar (Item a)))
21:30:56 <ski> could you use `ExceptT r STM' ?
21:32:04 <hololeap> i'm traversing the Seq and rebuilding it with any (TVar ItemDeleted) values removed, and stopping as soon as (a -> Maybe r) returns a (Just r)
21:32:29 <hololeap> ExceptT might be what i'm looking for here
21:32:37 <Cale> I'd just write it using recursion, but it'd be possible to use ExceptT or ContT
21:33:01 <ski> hm, so removing stuff from the `Seq', rather that just mutating the state the `TVar' refers to ?
21:33:42 <ski> `ContT' sounds like overkill, afaics
21:34:12 <Cale> A little bit -- it'd be a single callCC :P
21:34:19 <hololeap> another thread mutates the TVar Item to ItemDeleted when it is no longer needed, and this is just to remove it from the Seq when i'm searching for an item
21:34:34 <ski> mhm
21:36:38 * ski . o O ( `(a -> Maybe r) -> ExceptT r (StateT (DelayQueue a) STM) ()' )
21:37:54 <hololeap> @unmtl ExceptT r (StateT s m) ()
21:37:54 <lambdabot> ExceptT r (StateT s m) ()
21:38:23 <ski> `unmtl' doesn't understand `ExceptT', it's too new for it. say `ErrorT' instead
21:39:18 <hololeap> @unmtl ErrorT r (StateT s m) ()
21:39:18 <lambdabot> s -> m (Either r (), s)
21:39:35 <hololeap> yeah, that looks good
21:40:23 <ski> depends
21:40:39 <hololeap> although, couldn't we use `WriterT (Seq a)` since Seq is a Monoid?
21:40:56 <ski> would you have any use for expressing it in terms of `StateT', in the implementation of `findDelete' ?
21:41:14 <hololeap> (i'm replacing DelayQueue with Seq here since it's just a newtype)
21:41:22 <ski> would you have any use for expressing it in terms of `StateT', in the caller(s) of `findDelete' ?
21:42:23 <hololeap> i would extract it out of the StateT/WriterT within findDelete. this is just to save me the headache of threading everything around manually
21:43:34 <ski> mhm, so the callers would appreciate `StateT' and `WriterT' being used ?
21:44:34 <hololeap> i'm not sure what you mean. i would use `runStateT` (for instance) within the findDelete function to convert it back to the type i gave earlier
21:45:37 <ski> hm, i guessing you mean `StateT' (the data constructor), not `runStateT'
21:45:58 <hololeap> findDelete :: (a -> Maybe r) -> DelayQueue a -> STM (DelayQueue a, Maybe r)
21:46:40 <ski> oh. the the threading to be avoided was in the implementation of `findDelete', then
21:46:51 <hololeap> correct
21:46:54 <ski> (or s/threading/plumbing/, in general)
21:47:04 <hololeap> right, not threading in the concurrency sense
21:47:50 <ski> yea (it just sounds weird to use "threading" for `WriterT', but it's often used for `StateT')
21:49:36 <hololeap> foldM seemed to be the right tool for the job, but i wasn't sure which `m` to use
21:50:28 <hololeap> findDelete :: (a -> Maybe r) -> Seq (TVar (Item a)) -> STM (Seq (Tvar (Item a)), Maybe r)
21:50:56 <hololeap> that's just removing the newtype wrapping
21:53:13 <ski> with `foldM' you'll be traversing the whole collection, unless the monad aborts
21:53:49 <hololeap> so i need a monad that can abort
21:54:07 <hololeap> and ExceptT makes sense
21:55:10 <hololeap> whether to use StateT or WriterT inside of ExceptT might be a matter of taste... i'm not sure
21:55:35 <hololeap> although either would work since i'm rebulding a Seq, which happens to be a Monoid
21:56:51 <ski> hm
21:57:12 <ski> if you get any `r', which `Seq' do you want ?
21:57:43 <hololeap> the same seq that was given as input, with any ItemDeleted items removed
21:57:53 <ski> presumably you don't just want a partial traversal of the input `Seq' ?
21:58:35 <hololeap> oh, that's a good point. the remainder would need to be there as well
21:59:17 <hololeap> maybe this can't be wired together just using mtl monads
21:59:26 <ski> so either you'd remove all `ItemDeleted' anyway. or you'd need to make sure to fill in the rest, unprocessed, when you abort
21:59:46 <hololeap> yes, anything past the point of abortion is not a concern
22:00:01 <hololeap> it will get scanned at some point
22:00:36 <hololeap> this is just a dual-feature function: search for an item and delete any ItemDeleted items that it happens to pass
22:00:56 <ski> yea
22:01:54 <hololeap> so anything that is past the item that returns (Just ...) is unmodified
22:05:03 <redmp> @let type family IsTypeError t where IsTypeError (TypeError _) = 'True; IsTypeError _ = 'False
22:05:04 <lambdabot>  .L.hs:180:22: error:
22:05:04 <lambdabot>      • Expected kind ‘k0 -> k1’, but ‘TypeError’ has kind ‘*’
22:05:04 <lambdabot>      • In the first argument of ‘IsTypeError’, namely ‘(TypeError _)’
22:05:36 <redmp> is it possible to write this type-function to detect a type error at compile time?
22:06:09 <redmp> oops, that message isn't correct. it's supposed to be using GHC.TypeLits
22:06:17 <redmp> @let import GHC.TypeLits as TL
22:06:18 <lambdabot>  Defined.
22:06:35 <redmp> @let type family IsTypeError t where IsTypeError (TL.TypeError _) = 'True; IsTypeError _ = 'False
22:06:36 <lambdabot>  .L.hs:181:9: error:
22:06:36 <lambdabot>      • Illegal type synonym family application ‘(TypeError ...)’ in instance:
22:06:36 <lambdabot>          IsTypeError (TypeError ...)
22:07:00 <MarcelineVQ> better to use yahb via % for modern stuff
22:07:04 <MarcelineVQ> % "foo"
22:07:04 <yahb> MarcelineVQ: "foo"
22:07:45 <jle`> redmp: aren't all type errors detected at compile time?
22:08:18 <redmp> jle`: yes, but i want to be able to detect my own type errors .. rather than checking for a condition, it would be easier to check for an error specified as TL.TypeError
22:08:26 <redmp> in a type..
22:09:07 <redmp> it's kind of like doing a try...catch in a type function
22:10:00 <redmp> this is more of a "how do i use the GHC infra to do this" question than a "is this possible" question
22:12:01 <jle`> can you give a specific example of something you'd want to catch?
22:12:33 <redmp> @ TL.TypeError (TL.Text "oops, some invariant was violated")
22:12:44 <redmp> @let TL.TypeError (TL.Text "oops, some invariant was violated")
22:12:45 <lambdabot>  Parse failed: TemplateHaskell language extension is not enabled. Please add ...
22:12:55 <redmp> @let type Oops = TL.TypeError (TL.Text "oops, some invariant was violated")
22:12:56 <lambdabot>  .L.hs:180:1: error:
22:12:56 <lambdabot>      • oops, some invariant was violated
22:12:56 <lambdabot>      • In the type synonym declaration for ‘Oops’
22:13:28 <redmp> if you return one of these from a type family, i'd like to detect it with `IsTypeError`
22:14:35 <jle`> hm, i don't know if there's a way to do that. it's essentially like undefined
22:15:03 <jle`> you also can't quite match on (TL.TypeError _) becuase you can only pattern match on constructors
22:15:29 <jle`> i don't think it's something catchable
22:16:09 <redmp> I just figured out a way
22:16:16 <redmp> one sec; let me flesh it out
22:22:11 <slack1256> Is there a package that provides a class for ST-like monads? In the same vein as MTL does with transformers' Monads.
22:23:37 <dolio> primitive
22:25:57 <slack1256> Oh, I thought that package was for something else, nice. Thanks dolio.
22:26:47 <redmp> k, no, it doesn't actually work.. it seems like it would, but i guess GHC sees the TypeError and stops the normal process
22:27:31 <redmp> the idea was to skip over the TypeError family and match directly on the constructors of ErrorMessage ..
22:28:51 <redmp> @let type family IsTypeError t where IsTypeError (_ (TL.Text _)) = 'True; IsTypeError (_ (TL.ShowType _)) = 'True; IsTypeError (_ (_ :<>: _)) = 'True; IsTypeError (_ (_ :$$: _)) = 'True; IsTypeError _ = 'False
22:28:52 <lambdabot>  Defined.
22:29:11 <redmp> @kind! IsTypeError Int
22:29:12 <lambdabot> Bool
22:29:17 <redmp> @:kind! IsTypeError Int
22:29:18 <lambdabot> Bool
22:29:23 <redmp> uhhh .. how do i make that strict
22:29:41 <redmp> @:kind! IsTypeError (TL.Text "oops")
22:29:42 <lambdabot> Bool
22:30:03 <redmp> cool, well, GHC treats these two cases differently and doesn't actually give back the Bool.. unfortunately
22:30:22 <redmp> or maybe i'm still misunderstanding things; i'll keep trying
22:40:37 <redmp> ok, easy solution is to return a sentinel type instead of a TypeError and then use that to decide what to do based on context
23:27:42 <hololeap> ski: this is the best i've come up with: https://dpaste.com/BDTVYPXBP
23:37:29 <ski> ok
