00:22:17 <random> hey guys, quick question about prisms
00:22:39 <random> if I have a type data Something = SomethingA Something1 Something2 | SomethingB Something3
00:22:51 <random> is there a way to prism it into something like
00:23:00 <random> Maybe (Something1, Something2) and Maybe Something3
00:23:30 <Axman6> sounds like preview _SomethingA and preview _SomethingB
00:24:18 <Axman6> : preview _Left
00:24:21 <random> oh..
00:24:22 <Axman6> :t preview _Left
00:24:23 <lambdabot> MonadReader (Either b c) m => m (Maybe b)
00:24:23 <random> thanks man!
00:24:27 <random> yeah that's it
00:25:24 <Axman6> a.k.a foo ^? _SomethingA
00:25:57 <random> aha!
00:26:01 <random> that's what I was trying to remember
00:47:34 <dminuoso> servant question, say I have a dozen QueryParams that could be specified. Is there a way to specify some kind of `QueryParamsAggr "search" Search` where Search contains multiple fields populated from multiple QueryParam/QueryParams?
00:51:48 <dminuoso> Or, alternatively, can I force servant to turn some `QueryParam "Foo" Text` into `Tagged "Foo" Text`?
00:52:55 <dminuoso> Idea being, that I want some guarantee I dont mismatch the fields with the API without newtyping Text 12 times.
01:01:42 <ph88> is there a type in aeson that implements FromJSON that doesn't specify the structure of the JSON ? a value of which you can pull out parts of the json later without specifying a type for that part
01:02:24 <opqdonut> JSONValue? (or whatever it was called)
01:02:39 <ph88> oh ok thanks donut
01:02:54 <opqdonut> Value
01:03:08 <opqdonut> Data.Aeson.Value is just a JSON object represented as a Haskell ADT
01:08:11 <ph88> which library can i use to ask users questions on the command line?
01:09:22 <dminuoso> haskeline
01:10:07 <dminuoso> or just getLine perhaps? Depends on what your needs are
01:11:16 <ph88> thx
01:11:49 <ph88> why can't i show this value ?  https://bpa.st/57SQ 
01:11:59 <ph88> https://hackage.haskell.org/package/req-3.5.0/docs/Network-HTTP-Req.html#t:JsonResponse
01:12:10 <ph88> https://hackage.haskell.org/package/aeson-1.5.3.0/docs/Data-Aeson.html#t:Value
01:12:16 <ph88> instances are there for Show i think
01:12:19 * hackage elynx-markov 0.3.3 - Simulate molecular sequences along trees  https://hackage.haskell.org/package/elynx-markov-0.3.3 (dschrempf)
01:12:48 <__monty__> No, those are instance for Show Value, not Show (JSONResponse Value)
01:13:23 * hackage elynx 0.3.3, tlynx 0.3.3, slynx 0.3.3, elynx-tree 0.3.3, elynx-tools 0.3.3, elynx-seq 0.3.3, elynx-nexus 0.3.3 (dschrempf)
01:14:03 <ph88> __monty__, i see instance   Show a => Show (JsonResponse a)
01:14:17 <davve> whats going on?
01:14:30 <ph88> so if i can proof that  Value has instance Show, it should show  JsonReponse Value   right ??
01:14:35 <ph88> hi davve 
01:15:08 <__monty__> Yes, but I don't see the instance you mention.
01:16:41 <ph88> it's on the other documentation page, the first page i linked
01:16:53 <__monty__> Oh, missed the second url. Hmm, if both instances are in scope that does look like it should work.
01:18:23 <ph88> here is my full program https://bpa.st/UMFQ 
01:20:44 <__monty__> Hmm, maybe check the version of the deps you're using, could be missing an instance?
01:21:11 <__monty__> Don't see why it wouldn't work though.
01:22:04 <ph88> i use all latest versions
01:23:50 <ph88> o_O confused
01:27:54 <c_wraith> ph88: can you append the full error message to the source?
01:30:04 <dminuoso> Mmm, how safe is it to execute an stm transaction while exceptions are masked?
01:30:53 <ph88> c_wraith, https://bpa.st/D5HQ
01:35:45 <dminuoso> Ah. Based on Simons answer on https://gitlab.haskell.org/ghc/ghc/-/issues/7104 I suppose that atomically is not interruptible.
01:36:44 <c_wraith> ph88: well, that's definitely odd.  I'd try looking into it to see if ghci can see the instances and so on.  Can't do that myself, as I'm currently without a build env
01:37:32 <dminuoso> Does the rts use async exceptions at all to implement stm?
01:37:58 <dminuoso> Or how are awaiting transactions notified about modified transaction logs?
01:38:19 <ph88> how can i see instances in ghci ?
01:38:37 <c_wraith> use :info on the type or the class to see instances currently imported
01:38:41 <ph88> oki
01:41:20 <__monty__> Fwiw, it seems to work fine on my end. Get an http exception about authorization. But the code typechecks fine.
01:42:19 <__monty__> So I think the code's fine and the problem is with your deps. Is Network.HTTP.Req coming from "req?" And Data.Aeson from "aeson?" Check the versions in your stackage snapshot.
01:43:42 <__monty__> ph88: Yeah, the version on stackage seems to be missing the instance: https://www.stackage.org/haddock/lts-16.10/req-3.2.0/Network-HTTP-Req.html#t:JsonResponse
01:43:51 <__monty__> (Latest LTS)
01:50:13 <ph88> thanks __monty__ !! i will have a look
02:21:51 * hackage symantic-base 0.0.1.20200708 - Basic symantics for writing Embedded Domain-Specific Languages (EDSL).  https://hackage.haskell.org/package/symantic-base-0.0.1.20200708 (julm)
03:06:29 <ph88> Could someone help with this type error ?  https://bpa.st/HLUQ 
03:09:38 <dminuoso> ph88: (/:) :: Url scheme -> Text -> Url scheme
03:10:51 <ph88> so i can't split the url building into two different functions with /:  because i don't have Url scheme in main function ??
03:12:23 <dminuoso> ph88: Try `renderUrl` perhaps?
03:12:37 <dminuoso> That is, jira (renderUrl (... /: .. /: ...))
03:13:20 * hackage symantic-base 0.0.2.20200708 - Basic symantics for writing Embedded Domain-Specific Languages (EDSL).  https://hackage.haskell.org/package/symantic-base-0.0.2.20200708 (julm)
03:13:27 <ph88> renderUrl needs as parameter Url scheme   which i don't have in main
03:13:33 <dminuoso> You do.
03:13:39 <ph88> oh ?
03:13:40 <dminuoso>  /: is what builds up an Url.
03:13:47 <dminuoso> Read the error message you got.
03:13:59 <dminuoso>     • Couldn't match expected type ‘Text’                  with actual type ‘Url scheme0’    • In the second argument of ‘($)’, namely
03:14:14 <dminuoso> The second argument of ($) was *expected* to be Text, but you gave it `Url scheme0` 
03:14:19 * hackage fmlist 0.9.4 - FoldMap lists  https://hackage.haskell.org/package/fmlist-0.9.4 (SjoerdVisscher)
03:14:43 <ph88> i think when you do     https /: "jira.mydomain.com   that   https :: Url scheme    and  "jira.mydomain.com" :: Text.   And https is located inside the jira function
03:15:34 <ph88> ok i will try it dminuoso 
03:16:19 * hackage logging-effect 1.3.11 - A mtl-style monad transformer for general purpose & compositional logging  https://hackage.haskell.org/package/logging-effect-1.3.11 (OliverCharles)
03:22:33 <ph88> dminuoso, i tried your suggestion, i get this now  https://bpa.st/QVZQ 
03:30:03 <__monty__> ph88: You need to look at the type for (/:) again. You can't concatenate Texts.
03:31:02 <ph88> ye i see it's not working this way :|
03:34:18 <__monty__> ph88: You could pass a lambda as path. `\url -> "rest" /: "api"...` then apply it to `https "jira.mydomain.com" /: "jira"`.
03:35:17 <__monty__> I'm not sure there's a reason not to pass "rest/api/2/project" as the path. URL encoding?
03:35:26 <ph88> aah that's an excellent idea, i'll do that
03:36:00 <ph88> https://hackage.haskell.org/package/req-3.5.0/docs/Network-HTTP-Req.html#t:Url   so using (/~) and (/:) is the only way to have forward slashes between path segments
03:42:16 <ph88> __monty__, when i pass the lambda i get this  Found type wildcard ‘_’ standing for ‘Url 'Network.HTTP.Req.Https -> Url 'Network.HTTP.Req.Https’  
03:42:25 <ph88> not sure how to write out this type in my source code
03:42:33 <__monty__> ph88: You could combine the lambda with (&) :: a -> (a -> b) -> b so you don't have to swap the order around btw.
03:42:40 <ph88> what is that ' quote in front of the type ? is it a symbol ?
03:43:14 <__monty__> Looks like a type promoted to a kind?
03:43:25 <__monty__> Or a value promoted to a type rather.
03:43:34 <ph88> ye i'm not so familiar with that
03:43:43 <__monty__> Can you paste the error?
03:44:08 <__monty__> And code, more convenient to see the actual code.
03:44:19 <ph88> https://bpa.st/FE7Q
03:45:31 <ph88> https://bpa.st/SD3Q
03:45:38 <__monty__> Maybe an annotation on the lambda helps? `:: Url a -> Url a`
03:46:23 <__monty__> Though, your type should work?
03:47:18 <ph88> sorry i paste the wrong code it should be this https://bpa.st/763Q  line 12 is different
03:48:17 <__monty__> Yeah but does the other one work?
03:49:54 <ph88> no because Https is a data constructor of some other type, it's not that value that got promoted to type
03:50:58 <ph88> When i put this  (Url 'Network.HTTP.Req.Https -> Url 'Network.HTTP.Req.Https)   i get  Not in scope: data constructor ‘Network.HTTP.Req.Https’
03:51:11 <ph88> not sure how to write string type literal in function signature
03:54:27 <ph88> When i have  (Url a -> Url a) i get    Couldn't match type ‘a’ with ‘'Network.HTTP.Req.Https’
04:08:10 <__monty__> Well, either don't specify the type or enable DataKinds so you can specify Url 'Https.
04:08:19 <__monty__> Don't think there's other options.
04:14:51 * hackage uniqueness-periods 0.2.0.0 - Can be used to produce the 'uniquenessPeriods' function and related functionality.  https://hackage.haskell.org/package/uniqueness-periods-0.2.0.0 (OleksandrZhabenko)
04:15:49 * hackage uniqueness-periods-general 0.2.0.0 - Can be used to produce the similar to 'String.Ukrainian.UniquenessPeriods' functions.  https://hackage.haskell.org/package/uniqueness-periods-general-0.2.0.0 (OleksandrZhabenko)
04:16:49 * hackage cabal2spec 2.6.2 - Convert Cabal files into rpm spec files  https://hackage.haskell.org/package/cabal2spec-2.6.2 (PeterSimons)
04:20:49 * hackage dobutokO-poetry 0.15.0.0 - Helps to order the 7 or less Ukrainian words to obtain somewhat suitable for poetry or music text  https://hackage.haskell.org/package/dobutokO-poetry-0.15.0.0 (OleksandrZhabenko)
04:21:44 <AlexM100> @help
04:21:44 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
04:21:59 <AlexM100> help pl
04:22:03 <AlexM100> @help pl
04:22:03 <lambdabot> pointless <expr>. Play with pointfree code.
04:22:19 * hackage dobutokO-poetry-general-languages 0.2.0.0 - Helps to order the 7 or less words to obtain somewhat suitable for poetry or music text  https://hackage.haskell.org/package/dobutokO-poetry-general-languages-0.2.0.0 (OleksandrZhabenko)
04:22:34 <AlexM100> @pl sieveSundaram n = ([1,2] ++ ) . map toOddPrime . filter (`notElem` numbers) $ [1..n]
04:22:34 <lambdabot> sieveSundaram = ([1, 2] ++) . map toOddPrime . filter (`notElem` numbers) . enumFromTo 1
04:25:09 <AlexM100> @pl sieveSundaram = ([1,2] ++ ) . map toOddPrime . filter (`notElem` numbers) $ [1..n]    where numbers = [(\(x,y) -> x + y + 2 * x * y) (x,y) | x <- [1..n], y <- [x..n]]          toOddPrime = (+ 1) . (* 2)
04:25:09 <lambdabot> (line 1, column 102):
04:25:09 <lambdabot> unexpected " "
04:25:09 <lambdabot> expecting operator
04:25:56 <AlexM100> @pl sieveSundaram = ([1,2] ++ ) . map toOddPrime . filter (`notElem` numbers) $ [1..n] where numbers = [(\(x,y) -> x + y + 2 * x * y) (x,y) | x <- [1..n], y <- [x..n]] toOddPrime = (+ 1) . (* 2)
04:25:56 <lambdabot> (line 1, column 99):
04:25:56 <lambdabot> unexpected " "
04:25:56 <lambdabot> expecting operator
04:26:15 <AlexM100> @pl sieveSundaram = ([1,2] ++ ) . map toOddPrime . filter (`notElem` numbers) $ [1..n]    where numbers = [(\(x,y) -> x + y + 2 * x * y) (x,y) | x <- [1..n], y <- [x..n]]               toOddPrime = (+ 1) . (* 2)
04:26:15 <lambdabot> (line 1, column 102):
04:26:15 <lambdabot> unexpected " "
04:26:15 <lambdabot> expecting operator
04:29:19 * hackage binaryen 0.0.3.0 - Haskell bindings to binaryen  https://hackage.haskell.org/package/binaryen-0.0.3.0 (terrorjack)
04:45:40 <AlexM100> @pl sieveSundaram = ([1,2] ++ ) . map toOddPrime . filter (`notElem` [(\(x,y) -> x + y + 2 * x * y) (x,y) | x <- [1..n], y <- [x..n]]) $ [1..n]
04:45:40 <lambdabot> sieveSundaram = [1, 2] ++ map toOddPrime (filter (`notElem` [(x + y + 2 * x * y) | x <- [1..n], y <- [x..n]]) [1..n])
04:47:50 * hackage burrito 1.2.0.0 - Parse and render URI templates.  https://hackage.haskell.org/package/burrito-1.2.0.0 (fozworth)
04:49:31 <jollygood2> hi. I need to have multiple version of a parser, because the data I'm parsing changes in time. any suggestions how to express this in haskell?
04:57:32 <dminuoso> jollygood2: Yes. Dont use typeclasss for that?
04:58:40 <dminuoso> Then it becomes as simple as `parserV1 = ...; parserV2 = ...; parser = do { v <- getVersion; case v of 1 -> parserV1; 2 -> parserV2; _ -> fail ("unsupported version " <> show v) }`
04:59:22 <jollygood2> I was thinking of something similar. data ParserVersion = V1 | V1 ..  parserV1 = ...   then M.fromList [(V1, parserV1), (V2, parserV2)]
05:00:23 <jollygood2> I am parsing html, so maybe embed current parser version in html, first commented line? or build a time to version map?
05:02:55 <jollygood2> or, I guess, getVersion could look up the date of the file, and return a version, as an Int
05:05:43 <dminuoso> That was the idea.
05:06:13 <dminuoso> You somehow inspect the data, then you use some identifying part of it to decide which version it is.
05:06:16 <dminuoso> Then you carry out the parser
05:06:38 <dminuoso> The modification time is probably a bad idea since that can change over time.
05:06:55 <dminuoso> (You wouldn't want someone using `touch foo` to suddenly change how the file is parsed, would you?)
05:07:27 <jollygood2> html comment including the parser version in the first line, then?
05:09:42 <dminuoso> That would be one way, sure.
05:09:58 <jollygood2> I'm storing all the html pages I successfully parsed, in case I want to extract additional information, and online version should work with latest version of the parser
05:10:00 <dminuoso> In general, it's a good idea to include "format versions" in all serialized data.
05:11:36 <dminuoso> Because sooner or later you will change the format, and you might be tempted into thinking "well this is a backwards compatible change", but your old software might not be forwards compatible
05:15:59 <jollygood2> how about this? data Parser { parserGetVersion :: FilePath -> IO Int, parserParsers :: [(Int, Parser Data)] }
05:20:07 <aldessa> Is it better to have my AST use String rather than Text if megaparsec would be parsing each character into a list of characters?
05:23:07 <dminuoso> aldessa: megaparsec can operate on chunks called Tokens
05:25:13 <dminuoso> Specifically, I think megaparsec doesn't actually unpack Text and repack again.
05:25:19 <dminuoso> (If it did, you'd be right)
05:28:43 <aldessa> dminuoso is there some sort of optimisation if you cast a [Char] to String, I'd like to use many lowerchar but it is of type Parser [Char] not Parser [Text]
05:28:47 <aldessa> I mean Parser Text*
05:28:53 <aldessa> to Text*
05:29:21 <aldessa> dammit, a lot of typos. just i'm confused how i can combine character parsers to make a text parser efficiently
05:35:54 <merijn> aldessa: Which parser library?
05:36:13 <aldessa> merijn megaparsec
05:36:52 <merijn> aldessa: There should be something like "takeWhile :: (Char -> Bool) -> Parser Text" or something along those lines
05:38:01 <merijn> https://hackage.haskell.org/package/megaparsec-8.0.0/docs/Text-Megaparsec.html#v:takeWhileP
05:39:56 <aldessa> ahh wonderful though ironically I think I'll go for String since I prefer to use the presupplied combinators :)
05:40:06 <aldessa> it is good to understand though
06:34:57 <olle> are haskellers making up new ways to deal with effects? wouldn't that create a pretty inconcistent code-base in the community?
06:35:11 <olle> free monad, freer monad, ...
06:43:05 <olle> transformers
06:43:07 <olle> etc
06:45:17 <efm> good morning. I am a happy user of cocalc.com, which is updating to Ubuntu20.04 this week. They could not get haskell to install, and asked for community help:  https://doc.cocalc.com/news/ubuntu-2004.html
06:48:55 <ph88> Hows that called when there is a ' in front of a type ?
06:49:48 <ph88> efm, ye nice, did you try yet on ubuntu 20.04 ? we can help if you are stuck on a specific step
06:53:50 * hackage termonad 4.0.0.1 - Terminal emulator configurable in Haskell  https://hackage.haskell.org/package/termonad-4.0.0.1 (cdepillabout)
07:10:02 <maerwald> can you upcast SomeException or recover the original type?
07:10:41 <maerwald> efm: ghcup works on ubuntu
07:10:54 <maerwald> efm: https://www.haskell.org/ghcup/
07:11:09 <maerwald> or https://launchpad.net/~hvr/+archive/ubuntu/ghc
07:12:27 <kuribas> olle: I think you mean fragmented?  It doesn't become inconsistent.
07:13:01 <kuribas> olle: not really actually, because most code still uses mtl style.
07:15:39 <olle> kuribas: yeah, fragmented
07:15:53 <olle> kuribas: yeah? so mtl is the "idiomatic" choice?
07:16:23 <kuribas> olle: it's more established
07:16:30 <olle> hm
07:16:35 <kuribas> free and variants are more experimental IMO
07:16:44 <olle> ok, good info
07:17:03 <kuribas> and I find that mtl works well enough
07:17:16 <olle> +1
07:17:27 <olle> kuribas: what about mtl and mocking?
07:17:30 <olle> unit test mocking*
07:17:45 <kuribas> olle: I don't do mocking :)
07:17:50 <olle> lol why?
07:18:00 <kuribas> I prefer a clean separation between business logic and side effects.
07:18:20 <kuribas> Then I can test the business logic without mocking.
07:18:35 <kuribas> perhaps in some projects it's necessary
07:19:02 <hyiltiz> efm: try ghcup if haven't already
07:19:05 <olle> kuribas: what about the cases where they entangle?
07:19:14 <kuribas> olle: usually that's a code smell
07:19:24 <olle> logging?
07:19:50 <kuribas> do you need to proof your logging library correct?
07:20:22 <kuribas> I also prefer to not do logging at low level functions.
07:20:45 <kuribas> better return some (Either Err ...) then log it at a higher level.
07:20:47 <olle> kuribas: yes, e.g. if you're doing economical transactions
07:20:58 <olle> "The function saves a resource to a cloud store, with logging and error handling."
07:21:01 <olle> https://degoes.net/articles/modern-fp
07:21:20 <olle> That guy breaks up a function using free monad, I think?
07:21:54 <kuribas> olle: I prefer doing decoupling with just pure functions, instead of type classes, free, etc.
07:22:28 <olle> sure
07:22:48 * hackage unicode-transforms 0.3.7 - Unicode normalization  https://hackage.haskell.org/package/unicode-transforms-0.3.7 (harendra)
07:22:49 <olle> just a good example of a function where it might not be so easy to separate side-effects from business logic
07:23:12 <hyiltiz> That modern fp link is  strongly opinionated
07:23:59 <hyiltiz> To me personally it just sounds misguided/misguiding
07:24:21 <olle> hyiltiz: yes, but as I said, it's an example of a function with side-effects :)
07:24:36 <olle> 16:20 < olle> "The function saves a resource to a cloud store, with logging and error handling."
07:25:17 <olle> another use-case might be installing a web app on a server (unzipping package, create and populate database, send email, ...)
07:25:32 <hyiltiz> Sounds like just another monad stack no?
07:25:50 <olle> that's why I think making business logic 100% pure (no IO monad) might not always be a viable solution.
07:25:53 <olle> hyiltiz: sure
07:26:06 <olle> hyiltiz: just an example for kuribas to consider :D
07:26:46 <hyiltiz> I think most people use something else for deployment not beat Haskell to do things 
07:26:52 <kuribas> olle: I'd prefer to have a function that saves a resource to a cloud source, and returns IO (Either Err a), with Err being all the possible things that go wrong.
07:27:03 <kuribas> olle: then you log the Err if you want.
07:27:06 <olle> hyiltiz: not beat?
07:27:07 <kuribas> olle: better decoupling
07:27:49 <hyiltiz> Rather than best
07:27:56 <hyiltiz> Rather than beat
07:28:05 <olle> D:
07:28:12 <hyiltiz> Uhh large thumbs and bad autocorrect
07:28:15 <kuribas> olle: installing a web-app would be more a case for ansible, no?
07:28:22 <olle> Well, I did such a script in PHP and mocking it was awkward to say the least
07:29:18 <olle> kuribas: maybe
07:32:21 <kuribas> olle: or bash ;-)
07:32:29 <olle> :O
07:32:40 <olle> parts of it is bash, in fact
07:45:59 <L29Ah> what's haskell analog of uint_fast16_t?
07:50:56 <kuribas> Word16?
07:51:12 <kuribas> > 1 :: Word16
07:51:14 <lambdabot>  1
07:58:17 <devl> wer kennt eine haskell usergroup oder sowas in Bonn oder Koeln ? 
08:04:49 <devl> ok, till next time &bye 
08:04:58 <dmwit> What's the difference between uint16_t and uint_fast16_t?
08:05:09 <dmwit> I agree that Word16 is probably the analog of uint16_t.
08:05:50 <dmwit> Googling suggests that uint_fast16_t guarantees at least 16 bits, but selects the fastest size. Haskell has no analog.
08:05:54 <dminuoso> dmwit: uint16_t might have padding
08:06:12 <dminuoso> uint_fast16_t is whatever the fastest thing the implementation has to with 16 bits
08:06:33 <wavemode> in practice, on a modern system that type is often not the fastest
08:06:33 <solonarv> ah, so uint_fast16_t might actually be (say) a 32-bit uint on some platforms?
08:06:44 <dmwit> solonarv: That's my read of the Google results, yes.
08:06:55 <dminuoso> solonarv: sure
08:07:24 <hyiltiz> Then 64 bit is fastest?
08:07:38 <hyiltiz> Due to less overhead
08:07:49 <dmwit> L29Ah: At a guess, Word will be at least as fast as Word16. It is not guaranteed to have at least 16 bits, but I struggle to believe GHC could be ported to a system where the natural choice for Word would have less than 16 bits.
08:08:57 <dolio> It is guaranteed to have 16 bits.
08:09:31 <wavemode> hyiltiz: on a 64 bit system it usually is. the issue isn't overhead, the issue is that the CPU is specifically optimized to perform 32- and 64-bit arithmetic
08:09:34 <dmwit> Ah, interesting. The documentation does say it has the same size as Int, which is guaranteed at least 29 bits.
08:09:38 <dmwit> So I stand corrected.
08:10:32 <dminuoso> Fun fact, `int` is actually the legacy version of int_fast16_t
08:10:52 <dminuoso> With the difference that the old C standard was more suggestive of the fact that `int` was supposed to be the fastest native size.
08:10:59 <dminuoso> With int_fast16_t it's an actual requirement
08:11:11 <dmwit> what
08:11:18 <dmwit> How could you possibly write that requirement sanely?
08:11:26 <dminuoso> dmwit: Let me dig it up for you
08:11:27 <dmwit> What if one type makes + faster, and another makes * faster, e.g.?
08:12:37 <dminuoso> It was some non-normative line stating something along the lines of "It's recommended that an implementation uses the native word size for this"
08:12:48 <dminuoso> It was removed in later standards, so Ill have to figure out when exactly
08:13:13 <dminuoso> dmwit: Or did you ask about int_fast16_t?
08:13:56 <dolio> Seemed like it was about that. There might not be a fastest type.
08:15:04 <wavemode> the prevailing wisdom is to just use int unless benchmarks or the requirements of your application tell you otherwise
08:15:07 <dminuoso> 7.20.1.3  Fastest minimum-width integer types
08:15:09 <dminuoso> Each of the following types designates an integer type that is usually fastest255)to operatewith among all integer types that have at least the specified width.
08:15:16 <dminuoso> 255) The designated type is not guaranteed to be fastest for all purposes; if the implementation has no cleargrounds  for  choosing  one  type  over  another,  it  will  simply  pick  some  integer  type  satisfying  thesignedness and width requirements
08:15:51 <dminuoso> And in case of `int` it was even weaker, where it was just a non-normative suggestion the implementation chose the native word of the CPU beneath.
08:15:59 <dminuoso> Just cant find it.
08:16:56 <dminuoso> Ah here we go:
08:16:58 <dminuoso>   A‘‘plain’’intobject  has  the  natural  size  suggested  by  thearchitecture of the execution environment (large enough to contain anyvalue in the rangeINT_MINtoINT_MAXas defined in the header<limits.h>)
08:18:30 <justsomeguy> Anyone here interested in tutoring once a week via video chat? I'm about half way through haskellbook.com, but keep on getting blocked. My thought was that checking in for a weekly code review would be helpful.
08:18:44 <justsomeguy> I can pay a decent hourly rate.
08:22:25 <dmwit> dminuoso: Yeah, okay, so I take issue with your characterization "with int_fast16_t it's an actual requirement". =P
08:22:32 <hyiltiz> Is there an automatic code reformatter than concerts from monadic do notation to applicative functor style?
08:23:08 <dminuoso> heh
08:23:27 <merijn> Yes
08:23:31 <dminuoso> hyiltiz: Mmm, is ApplicativeDo an option as well?
08:23:32 <merijn> -XApplicativeDo ;)
08:24:05 <dminuoso> You just dont have a guarantee of that kicking in. And if your type has Monad, you might not notice.
08:24:28 <dminuoso> But if the code is trivial, or you dont mind the odd binding resulting to Monad, then ApplicativeDo is great
08:31:27 <hyiltiz> Hmm is Applicative comprehension a thing?
08:31:45 <hyperisco> yes, ApplicativeDo
08:32:19 * hackage optparse-simple 0.1.1.3 - Simple interface to optparse-applicative  https://hackage.haskell.org/package/optparse-simple-0.1.1.3 (MichaelSnoyman)
08:32:44 <hyperisco> not sure how that interacts with MonadComprehensions but insofar as a comprehension is syntactic sugar, "yes" either way :)
08:33:27 <monochrom> A simple test would reveal that.
08:44:05 <hyiltiz> Oh right, the Haxl paper; I read that a year ago
08:44:26 <hyiltiz> I guess reading is less useful than practice
08:46:19 <kuribas> hyiltiz: no, both are necessary.
08:46:50 <hyiltiz> I wonder if haskell is the only programming community to hold that view :D
08:46:50 <hyperisco> don't say that because a motived person may interpret that as "there is no reason to read if you practice instead"
08:47:13 <kuribas> hyiltiz: if you practice without reading, you're skills hit a ceiling that you cannot pass.  If you read with practice you don't really get to the essence of what you read.
08:47:44 <hyiltiz> if you practice without reading, you're skills hit a ceiling that you cannot pass.  If you read withOUT practice you don't really get to the essence of what you read.
08:47:45 <kuribas> hyiltiz: if that's true that's quite sad.  But I do recognize the attitude.
08:47:49 <monochrom> I say that reading is less useful than practice.
08:47:57 <hyiltiz> did u just test my reading and practice? :p
08:48:07 <hyperisco> reading is like filling a glass and practice is like drinking
08:48:12 <monochrom> But anyone who stretches that to "don't read at all" is a moron.
08:48:19 <kuribas> hyiltiz: good your reading skills are I see :)
08:48:31 <ystael> clearly reading is like making a burrito and practice is like eating a burrito
08:48:34 <kuribas> hyperisco: that's a nice one.
08:48:47 <hyiltiz> lmfao into burito
08:49:34 <monochrom> Reading is like watching a cup of coffee over a Zoom meeting. Practice is drinking that coffee in-person.
08:50:02 <monochrom> I just wrote an exam question that begins with "The Grande Online Only Cafe wants to hold a lucky draw".
08:50:05 <kuribas> hyiltiz: there are many people who consider reading waste of time that can be spend programming.  But those same people then spend most of their time in trying fix up code that is incomprehensible.
08:51:16 <monochrom> I was going to end the question with "The prizes are invitation to a Zoom meeting in which the customers watch the barista make coffee and taste it and describe how it tastes. It the Grande Online Only Cafe!"
08:51:18 <hyiltiz> I have a CSV with n rows and a LaTeX template. I am writing genDocs :: CSV -> LaTeX template -> [PDF] via pandoc but using glue language instead of pandoc the library.
08:51:27 <kuribas> monochrom: but in order to learn what you know, you had to read it first no?
08:51:34 <MarcelineVQ> kuribas: was that subtly ironic? :>
08:51:36 <monochrom> Yes.
08:51:57 <monochrom> No.
08:52:27 <monochrom> A bit of reading speeds up a lot of practicing. Maybe necessary too in some cases.
08:52:33 <kuribas> MarcelineVQ: I thought it wasn't subtle at all...
08:52:37 <hyiltiz> Would directly using the pandoc library or somehow calling it over the template a better way to do? Currectly, I am using R to read in CSV and string interpolate per row and create a LaTeX file based on a fixed template, then syscall pandoc on each.
08:52:44 <dolio> You can learn things on your own.
08:52:53 <monochrom> But there are a lot of things you don't need and you can still find out by testing.
08:53:15 <monochrom> And there are a lot of things wrongly documented so reading deviates from reality.
08:54:10 <monochrom> And there are even more cases the documenting is right but you read it all wrong.
08:54:34 <kuribas> yeah, reading doesn't mean agreeing
08:56:04 <monochrom> You go into any STEM subfields and if you here them say "this is not a spectator sport" you know they mean practicing is more important than reading.
08:56:13 <hyperisco> I think almost everything I know I didn't read, and that isn't saying I haven't read a lot… it is just that the information content from a paper or book doesn't intuitively seem to hold a candle to practice
08:56:15 <monochrom> s/here/hear/
08:57:11 <hyperisco> but it is steering
08:57:22 <monochrom> yes
08:57:50 <monochrom> But you look at time spent reading vs time spend practicing, even simply testing what you've just read.
08:58:15 <monochrom> Practicing time is definitely the lion's share if you look at successful people.
08:59:06 <monochrom> And losers, definitely reading time dominates. Just look at my students. They say they "study hard". I believe them, they read and watch so many blogs and videos.
09:00:05 <merijn> "if you look at successful people" <- survivorship bias much ;)
09:00:06 <monochrom> And never lift a finger to even code up "let me print out argv[0] to argv[argc-1] to see how they corresponds to command line arguments I give"
09:00:29 <monochrom> No I've got losers covered too.
09:01:48 <hyperisco> 3 PhDs later
09:01:51 <monochrom> A student asked an easy question "does this function foo do bar?" about a function foo I was discussing in class.
09:02:13 <kuribas> monochrom: reading irc is indeed mostly a waste of time :)
09:02:17 <monochrom> I suggested "you can test it!" and the student reply was "oh, good idea".
09:02:26 <monochrom> Meaning? IT NEVER OCCURED TO THEM.
09:02:55 <monochrom> I don't know why I have so many students whose idea of settling a question is only to read something or ask an expert.
09:02:59 <hyperisco> so their mode of operation is to get answers from other people
09:03:39 <hyperisco> there was a time in high school I realised that teachers don't have all the answers, so I might have to think for myself XD
09:11:09 <monochrom> I have one more facepalming example but I'll continue in #haskell-offtopic
09:16:01 <maerwald> merijn: that's a thing in USA
09:17:04 <maerwald> for Europeans it's weird that ppl listen to the public opinion of successful business men, I guess
09:18:06 * maerwald goes watching Gary on tiktok
09:27:51 <hc> maerwald: is it? i like listening to businessmen, they often have a very positive way of seeing things :)
09:28:41 <wavemode> "we're still making money so everything is ok!"
09:28:44 <maerwald> I dunno, german view on business men is: they're all evil and did bad things to become successful. I find that to be a realistic view :p
09:31:06 <dolio> monochrom missed the lesson in their own example. The student didn't have the idea to test the function for themself. Now they do, because they asked a question and received an answer.
09:32:18 <wavemode> I dislike the view when a society makes someone rich (by, e.g., buying his product like it's crack) then turns around and blames him for it
09:32:41 <maerwald> that's basically what we do, yeah
09:32:47 <maerwald> and we feel good about it :D
09:39:02 <sm[m]> there are many ethical businesspeople
09:40:39 <dolio> This sounds like a conversation for some other channel.
09:40:58 <maerwald> sm[m]: I just wound shelltestrunner o/
09:41:00 <int-e> sm[m]: ...those poor people...
09:41:03 <maerwald> *found
09:41:27 <sm[m]> maerwald: hope you like it!
09:42:08 <maerwald> sm[m]: I think it's better than invoking an executable in spec tests (hspec)
09:42:37 <maerwald> because I alwasy felt spec test binary should be self-contained
09:51:34 <sm[m]> maerwald: ok, you force me to do some maintenance
09:56:43 <hyiltiz> Eq instance for Num a=>a->a huh? So where is the catch? https://youtu.be/VxINoKFm-S4?t=894
10:00:13 <kuribas> hyiltiz: judgemental equality
10:01:09 <kuribas> hyiltiz: it can tell if two things are (judgementally) equal, but not if they are unequal.
10:01:33 <dolio> That doesn't say what you wrote, even.
10:01:34 <kuribas> so no Num instance
10:03:00 <kuribas> to have a num instance you must be able to decide if they are unequal.
10:03:18 <kuribas> I believe that's undecidable
10:03:19 * hackage http-query 0.1.0 - Simple http queries  https://hackage.haskell.org/package/http-query-0.1.0 (JensPetersen)
10:04:06 <kuribas> hyiltiz: read the book, it's a nice one :)
10:04:22 <hyiltiz> hmm sounds bizarre; u can decide if equal but /cannot/ decide if unequal? 
10:05:02 <hyiltiz> the book sounds really fun and am already hooked
10:05:04 <hyiltiz> i am quickly accumulating reading list taller than my height
10:05:40 <kuribas> hyiltiz: because judgementally not equal doesn't mean not equal.
10:06:32 <kuribas> in other words, they may look different, but are the same function.
10:08:04 <hyiltiz> https://ncatlab.org/nlab/show/judgmental+equality and https://stackoverflow.com/questions/50897020/judgemental-equality not useful enough
10:08:47 <hyiltiz> so essentially you have a base language with atomic elements; if two given function can be reduced to the same expression they are judgementally the same?
10:09:09 <kuribas> yes
10:09:10 <hyiltiz> I think it is possible to "knot up" a program s.t. it doesn't reduce
10:09:14 <dolio> That is over-simplified.
10:09:46 <hyiltiz> while another one "without a knot" reduces, although considering their input and output they can be identical
10:10:21 * hyiltiz is trying to think of such a "knotted" function example
10:11:43 <dolio> A simple example is that `\n -> n+1` and `\n -> 1+n` denote equal functions, but are not judgmentally equal in many type theories.
10:12:28 <hyiltiz> hmm really!? they dont combinatorially check all program symmetries?
10:12:49 <hyiltiz> while impractical, it should be theoretically possible?
10:13:24 <kuribas> that's why incorporating an smt solver makes proving things less tedious.
10:13:36 <kuribas> as the smt solver can solve these automatically
10:15:34 <hyiltiz> hmm sounds fun
10:17:35 <dolio> I'm not convinced it's even theoretically possible to check "all program symmetries".
10:18:39 <mmaruseacph2> especially with floats
10:18:47 <mmaruseacph2> a + b + c is not the same as c + b + a
10:19:35 <dolio> But I think "theoretically possible" is also not a very good bar to have to clear.
10:20:35 <hyiltiz> Wait; let's assume math (expressions) not turing machines (64-bi floats)
10:20:42 <dolio> No.
10:20:48 <hyiltiz> LOL ok
10:22:40 <monochrom> Nothing in Turing machine preordains 64-bit floats.
10:23:13 <monochrom> Gödel and Turing already showed how to do general math on Turing machines.
10:23:27 <monochrom> Not to say it's practice, but.
10:23:39 <monochrom> s/practice/practical/
10:26:43 <hyiltiz> so considering unbounded but finite numbers, all symmetries of all analytical functions are deducible, no?
10:27:55 <monochrom> I don't understand the question.
10:28:26 <monochrom> I don't understand any question.
10:29:43 <ystael> hyiltiz: It's easy to incorporate a question to which the answer is not known. For instance, define (<+>): Int -> Int -> Int to be a <+> b = a + b if a <= b; if a > b then a <+> b = a + b + K where K is the least positive counterexample to the Collatz conjecture, or 0 if there is none.
10:29:44 <hyiltiz> I was trying to say: all algebraic symmetries of an analytical function is/can be known.
10:29:51 <ystael> Is (<+>) symmetric? We don't know.
10:30:16 <hyiltiz> ystael: thx for the counterexample
10:31:32 <ystael> You could say, we don't have an effective algorithm for computing (<+>), which is true; but it is a well defined function, unless the Collatz conjecture turns out to be independent of the standard axioms of set theory, or something strange like that.
10:32:15 <hyiltiz> but we don't lose anything by assuming any unproved symmetry is no symmetry tho; those expressions won't reduce, just because we didn't solve Collatz conj. yet
10:32:34 <hyiltiz> it is just a power we haven't unlocked yet so don't hurt to not use it
10:33:51 <hyiltiz> all those programs using <+> can be reduced the moment Collatz conj. is (dis)proven; until then, we are left with a smaller set of symmetries to compose and test.
10:34:08 <ystael> yes, it's always safe for an optimizer to underestimate the available rewritings of the program
10:34:53 <monochrom> I prefer: Since we don't know, let's assume we don't know.
10:34:59 <dolio> Maybe you should study type theory for longer than half of an 'intro to dependent types' talk.
10:35:23 <dolio> Some of the answers to these questions might become more clear then.
10:35:29 <maerwald> dolio: who's gonna pay for that... otherwise, I'm in
10:36:19 <monochrom> I pay for ghcup so you can study type theory. Is that good enough? :)
10:36:33 <maerwald> uff
10:36:50 <monochrom> Or does your accounting department disapproves, "wrong department" :)
10:38:08 <hyperisco> I feel like if you could prove general function equality then you could solve the halting problem
10:38:34 <hyperisco> s/could prove/could decide/
10:38:51 <monochrom> Yeah.
10:39:00 <maerwald> I think this is a bug in our concept of economy/employment. Any advanced training (e.g. half a year full-time) won't be supported, even if that raises your value for the economy as a whole.
10:39:57 <maerwald> bc you already got a job... why you not satisfied? :p
10:40:14 <monochrom> The bug used to not exist. My father's employer paid for my father to take engineering courses, exams, and certification.
10:40:50 <maerwald> like... you go to university once in life... isn't that rather odd?
10:41:22 <monochrom> At some point of time, employers became selfish and shrewd, thinking only in term of "what if you leave right after?"
10:41:37 <maerwald> yes, but what if they do :p
10:41:46 <monochrom> Now they use open source to trick you into pre-training yourself even before your first job application.
10:41:50 <merijn> monochrom: And then when you don't invest in raises or education people also leave... *surprise pikachu*
10:44:14 <hyiltiz> dolio: agreed; I'd benefit much more studying type theory 
10:45:13 <maerwald> I think the system is generally optimised for ppl who learn *fast*, not *well*. Because fast learners have a better input/output ratio? Or do they?
10:49:06 <monochrom> I don't draw a clear hard line between the two.
10:49:23 <monochrom> So to speak, figure of speech: They are distinguishable at low energies only.
10:49:32 <monochrom> They unify at high energies.
10:49:55 <MarcelineVQ> like care bears
10:52:07 <monochrom> A sign that you can't cleanly separate them: "fast" vs "slow" can only be classified after you have a classification of "well enough" vs "not well enough".
10:53:58 <monochrom> I think the system is optimized for gaming the system.
11:06:29 <maerwald> monochrom: I don't see why they would unify, no.
11:06:38 <maerwald> actually the opposite
11:07:27 <maerwald> you fall way out of line when you're high energy non-fast learner, bc that usually leads to over-achieving in specific tasks that excite you
11:08:37 <maerwald> even university is breadth-first approach
11:08:47 <maerwald> you can't escape it
11:11:55 <zincy_> Yes, university for non-research focused courses are purely breadth first.
11:12:16 <merijn> eh, depends a lot on the university, course, etc.
11:12:40 <zincy_> I would conjecture that they tend towards breadth
11:13:54 <maerwald> yes, because the reputation is on the line, a breadth-first approach has a lower chance of a whole year of students entering industry and being underprepared for the nonsense that's awaiting them
11:15:00 <maerwald> "some of this is hopefully useful"
11:15:32 <zincy_> Being good at a job in programming seems to be mostly people pleasing
11:15:56 <zincy_> Actually job.
11:16:03 <MarcelineVQ> money flows from humans so every job is just people pleasing
11:16:57 <zincy_> Was there not a survey which found most people would be happy with a robot/algorithmic boss?
11:18:47 <maerwald> zincy_: I failed an interview once, because I tend to eta expand the first argument to fmap. It didn't please the interviewer :p
11:19:05 <MarcelineVQ> I wouldn't put too much stock into survey results, it's like jury duty: you're being judged by 12 people too stupid to get out of jury duty.
11:19:16 <zincy_> maerwald: A interview for a Haskell job?
11:19:20 <maerwald> yeah
11:19:37 <maerwald> So much for ppl pleasing
11:19:59 <zincy_> maerwald: I failed an interview for Haskell because I used a float instead of an int
11:20:17 <zincy_> I guess thats worse but still
11:20:35 <zincy_> If someone doesn't like you then they will find something
11:20:39 <MarcelineVQ> "Would a robot boss be cool?" "I guess? kinda cool":   100% of people interviewed said a robot boss is preferrable
11:21:07 <merijn> MarcelineVQ: Get outta here with your logic :p
11:21:49 <zincy_> It was the question in the survey which was interesting not the result
11:22:06 <zincy_> Do we really care about a random selection of opinions?
11:23:05 <MarcelineVQ> I don't, but survey makers and the people who pay them seem to
11:23:35 <zincy_> Anyway I am procrastinating from my study of complex numbers, which is part of my escape plan from the slow death that is web app development
11:23:44 <MarcelineVQ> If for no other reason than you can say, well our survey shows 'x'
11:23:55 <zincy_> Meta-survey
11:24:38 <maerwald> A survey found most regular IRC users are procrastinators :p
11:25:04 <merijn> I'm kinda happy that Chris stopped maintaining ircbrowse
11:25:09 * maerwald pretends to be busy
11:25:12 <merijn> My stats in #haskell were depressing :p
11:25:27 <fendor> there are irc stats?
11:25:36 <merijn> fendor: Not anymore :p
11:25:45 <fendor> :O
11:28:28 <dgpratt> Normally I don't bother applying for Haskell-based jobs because it seems like it's a buyer's market. I just can't compete with your average Haskeller, at least in terms of Haskell smarts. But there was that one time that a "Haskell" company was looking for a JS coder, no Haskell chops required. So I applied, and was given a task to complete in JS. They said "Hey, we really like your JS code, but...we've decided to go 
11:28:28 <dgpratt> with someone with more Haskell programming skills." Ironically, I don't recall them asking me anything about my own Haskell skills.
11:29:08 <zincy_> dgpratt: haha
11:29:16 <zincy_> Yes it is a buyer's market
11:29:18 <maerwald> maybe you didn't ask for enough money :p
11:29:24 <merijn> It's not really a buyers market
11:29:28 <zincy_> You will make more money just doing React, or python
11:29:39 <zincy_> Or heck AWS
11:29:48 <merijn> It's just that the community and employers skew heavily to senior and elite skills
11:30:06 <dgpratt> yeah, I almost certainly would have had to accept a pay cut, but I was considering it
11:30:10 <merijn> Which means it can be hard for beginners to find a job
11:30:30 <zincy_> merijn: Yeah but they don't pay those elite coders that well right
11:30:34 <maerwald> merijn: I actually wonder why
11:30:41 <merijn> (even intermediate/advanced haskellers, unless they *also* have lots of other/non haskell skills)
11:30:45 <maerwald> bc they end up with less maintainable code...
11:31:12 <merijn> maerwald: Because only people with hard problems see any value in a language like Haskell
11:31:19 <merijn> maerwald: How so?
11:31:30 <maerwald> merijn: experience :p
11:31:43 <merijn> When I say highly skilled I don't mean "type wankery"
11:32:04 <maerwald> isn't that what is expected precisely of haskell seniors?
11:32:06 <merijn> I mean people like Simon Marlow, who besides being Haskeller and GHC experts are *also* experts in concurrent systems, the RTS and HPC...
11:32:29 <maerwald> yeah, easy competiton...
11:32:38 <merijn> maerwald: There's quite a number senior Haskell people with lots of HPC background and lots of experience with concurrency/threading
11:33:07 <dolio> It seems to me like it's beginners here who immediately jump into over-complicated type stuff.
11:33:13 <merijn> dolio: Yes
11:33:17 <merijn> Always
11:33:26 <merijn> "Hi guys, I'm just learning Haskell!"
11:33:31 <maerwald> well, it's more elitist
11:33:38 <maerwald> so sure appealing to students
11:33:58 <merijn> Three weeks later "Hey, so I encoded my entire API in the type system using DataKinds, GADTs and TypeFamilies and now my code is hard to understand and refactor"
11:34:25 <maerwald> merijn: and servant was born
11:34:53 * maerwald claps
11:36:38 <maerwald> every language has this thing that makes you look smart. In java it's design patterns, in python meta-programming
11:37:37 <Uniaika> in Haskell it's both
11:38:45 <hyperisco> maerwald, hm I guess you're right… so in C# it is reflection, I guess
11:39:22 <justsomeguy> Does category theory count as design patterns?
11:39:49 <maerwald> abstraction patterns, rather
11:40:38 <__monty__> In APL it's knowing APL.
11:40:58 <hyperisco> I feel like that comedy article needs to be resurfaced right here
11:42:17 <__monty__> There's a factor that skews it for haskell though, because it's a bit "out there" as a language it attracts a fair share of people learning it *just* for the learning. Nothing wrong with seeing how far you can take the type system as a learning experience.
11:42:43 <hyperisco> the one that escalates from beginner to postdoc, programming with morphisms, and wraps around at professor
11:43:14 <mmaruseacph2> this? https://willamette.edu/~fruehr/haskell/evolution.html
11:44:37 <hyperisco> yay thanks
11:46:14 <hyperisco> in JavaScript it is using fashionable libraries
11:47:27 <maerwald> js has libraries? I always felt there are only functions and frameworks
11:47:28 <hyperisco> me, I aspire to be a McBride type and grouchily inform everyone that they can barely think straight
11:48:12 <comerijn> hyperisco: How many shakespear puns have been in your papers?
11:48:24 <hyperisco> how far I have to go
11:54:20 <Sonolin> first time using haskell for work and wow it can be fast
11:54:30 <Sonolin> cut my event store replay from 300 minutes down to 2m 30s
11:55:06 <justsomeguy> Out of curiosity, would you say it's in the same ballpark as Go and Java, subjectively?
11:55:25 <Sonolin> feels faster than Java to me, and way better memory management wise, but no idea about Go
11:55:42 <Sonolin> but language-wise way different than those languages
11:55:50 <justsomeguy> Oh yeah, completely.
11:56:04 <Sonolin> it feels like I'm cheating lol
11:56:21 <Sonolin> well the client should be happy >:D
11:56:59 <justsomeguy> As a newbie, my reactions alternate between "how can it be that simple?" to "what are these strange alien symbols on my monitor right now and why is the room spinning?"
12:00:23 <maerwald> I think it's hard to outperform Go's GC though, isn't it?
12:01:10 <efm> thanks for your help, I've passed the suggestion to use ghcup along
12:01:27 <comerijn> maerwald: It Depends
12:01:30 <efm> maerwald and hyiltiz
12:01:36 <comerijn> maerwald: GC design is 100% trade-offs
12:01:38 <maerwald> efm: did it work?
12:01:54 <comerijn> maerwald: GHC makes different trade-offs than Go, but that doesn't make either design *better*
12:02:01 <comerijn> it just makes some workloads better
12:02:08 <efm> maerwald: I don't know I'll report back
12:05:26 <Sonolin> I do kinda wish haskell had some option for manual memory management/GC, I know that's a holdup for the game dev side of things
12:06:09 <comerijn> Sonolin: I mean, you can just malloc stuff if you really want :p
12:06:18 <hyperisco> I think hypothesising it as an "option" understates the difficulty
12:06:40 <comerijn> I'm not even sure what "optional GC" would mean, indeed :)
12:06:41 <Sonolin> haha funny... really though I was thinking something like how Rust does things, or at least a way to manage the GC pauses
12:06:57 <solonarv> you can manually allocate as much memory as you want, and you can manually trigger the GC as well
12:07:10 <comerijn> Sonolin: There's another GC with more predictable pauses, although still not at game latency
12:07:17 <hyperisco> I was reading some papers on region-based memory management in functional languages
12:07:21 <solonarv> but that won't stop the runtime from allocating more, or running the GC at other times
12:07:22 <comerijn> Sonolin: otoh, people write games in python, lua, and ruby all the time
12:07:26 <Sonolin> ah interesting
12:07:30 <comerijn> Without any problems
12:07:46 <hyperisco> I understood it as far to see it wasn't so straightforward
12:07:46 <comerijn> Sure, probably don't write a twitch-y FPS in haskell, but for many games it'll be just fine
12:07:56 <Sonolin> I mean, that's writing haskell a little short IMO
12:07:57 <maerwald> yeah, "game" isn't "game"
12:08:11 <maerwald> AAA engine surely won't be written in haskell
12:08:14 <Sonolin> it can do performant stuff very well, there's also LambdaCube which has been around for a while
12:08:22 <hyperisco> just having control over the pauses isn't enough
12:08:31 <comerijn> maerwald: I mean, most triple A game code isn't C++ either
12:08:40 <Sonolin> John Carmack re-wrote a lot of his early stuff in haskell and had lots of great things to say about it
12:08:43 <comerijn> It's written in Unreal Blueprint or some other high level language
12:08:53 <maerwald> comerijn: I think C# is much more common yeah
12:09:03 <hyperisco> you still have to collect at least in pace with what you're freeing
12:09:11 <comerijn> Sonolin: https://www.st.cs.uni-saarland.de//edu/seminare/2005/advanced-fp/docs/sweeny.pdf
12:09:24 <hyperisco> and you probably want that whole job as cheap as possible so you can spend resources elsewhere
12:09:31 <comerijn> maerwald: I meant that most logic is written in even higher level stuff than C#
12:10:09 <hyperisco> which is all to say you don't just care about the pauses, you also care about allocations and you care about the manner in which memory management is performed
12:10:17 <dminuoso> 21:07:00        comerijn | Sonolin: otoh, people write games in python, lua, and ruby all the time
12:11:03 <dminuoso> EVE Online is even written in a python flavor. So if you can cook up the server code for MMORPGs supporting many thousands of players on a single shard, then that's something to be said about the performance requirements of many game related pieces.
12:11:19 <comerijn> dminuoso: To be fair, Stackless Python behaves very little like python :p
12:11:39 <maerwald> dminuoso: have you ever joined a 500 men fleet fight in eve online?
12:11:49 <dminuoso> maerwald: Yes.
12:11:53 <maerwald> me too
12:12:04 <maerwald> I think I had 2 frames in 30minutes
12:12:09 <hyperisco> not one woman
12:12:18 <Sonolin> lol
12:12:56 <dminuoso> comerijn: The performance implications of the code itself, as well as garbage collector implications, should be the same though, no?
12:13:13 <dminuoso> (I mean the main reason for stackless seems to be to have access to cheap green threads)
12:14:51 <dminuoso> Oh, micro threads is something different apparently.
12:15:21 <maerwald> hyperisco: the term 'men' in military terms includes any gender fyi :)
12:15:37 <hyperisco> so does "seamen" but look where that got us (Canada)
12:15:50 <hyperisco> but anyways, about Haskell
12:16:29 <maerwald> oh, Canadian, lol
12:16:42 <maerwald> that's why it makes you nervous
12:46:34 <ollehar> dminuoso: source for EVE?
12:47:27 <jollygood2> what haskell web scraping libraries are used by most today?
12:47:35 <maerwald> ollehar: wikipedia
12:47:37 <comerijn> ollehar: It's pretty widely established that EVE uses stackless python
12:48:12 <maerwald> https://en.wikipedia.org/wiki/Eve_Online#Development
12:48:14 <dminuoso> ollehar: It's public knowledge. It was shared numerous times on the public forums by CCP employees.
12:48:19 <dminuoso> Or on talks
12:48:39 <ollehar> ok, on server side, that is?
12:48:57 <dminuoso> Right.
12:49:07 <dminuoso> The client I dont know actually, but I think it's filled with Python as well
12:49:17 <comerijn> probably
12:49:19 <maerwald> I can only say... the experience has never been smooth :p
12:49:20 <dminuoso> Have some vague memories about it
12:49:49 <ollehar> "Both the server and the client software for Eve Online are developed in Stackless Python"
12:49:51 <comerijn> I mean, most of WoW's interface was Lua, so it's not the first MMO with lots of client side dynamic scripting language :p
12:49:52 <ollehar> Well
12:50:00 <ollehar> Then how many libs are in C, C++, C#?
12:50:15 <dminuoso> ollehar: Ask them? :)
12:50:18 <ollehar> ^^
12:58:50 * hackage boolector 0.0.0.12 - Haskell bindings for the Boolector SMT solver  https://hackage.haskell.org/package/boolector-0.0.0.12 (DeianStefan)
12:59:56 <hololeap> ffda
13:00:22 <hololeap> f
13:00:41 <MarcelineVQ> I feel you
13:06:38 <hololeap> hello everyone. i'm looking for a little theory
13:06:38 <hololeap> i have collection of: data Item a = Item { key :: Int, minTime :: Int, val :: a }
13:06:38 <hololeap> given a value, t :: Int, i want to look up the Item with the minimum key, but only considering those whose (minTime <= t)
13:06:38 <hololeap> what data structure could allow this lookup in O(1) time, or is this even possible?
13:09:09 <dminuoso> O(1)?
13:09:30 <dminuoso> An oracle.
13:13:09 <maerwald> sounds enterprise
13:13:13 <MarcelineVQ> IntMap is the best I can suggest, maybe someone has a version of an interval map that could help you, dunno
13:13:27 <MarcelineVQ> IntMap is kind of crazy good as far as a general container goes :X
13:13:30 <hololeap> if i used `IntMap Key (MinTime, a)`, i could find the minimum key in O(1) time. if it was `IntMap MinTime (Key, a)`, i could find all the pairs (Key, a) that satisfy (MinTime <= t) in O(1) time
13:14:11 <hololeap> (and i understand that it isn't `IntMap k a`, but writing it that way makes my intention a little more clear, i think)
13:14:35 <chorhizo> Hey guys. I haven't used free monads in anger yet but just read https://joa.sh/posts/2015-09-13-free-monad-steps.html followed by https://markkarpov.com/post/free-monad-considered-harmful.html. 
13:15:05 <chorhizo> is the choice between type classes and free monads just, finger in the air, whatever feels right after using them for an extended period of time?
13:15:44 <hololeap> but i can't think of a way to satisfy both conditions in O(1) time, and i was wondering if this has been proven not to be possible
13:16:02 <chorhizo> or is it the ability to use different interpreters for entire bodies of computation the killer feature of `Free`
13:17:27 <jollygood2> hololeap, if you don't mind space-time tradeoff, have both maps
13:18:35 <hseg> Hi. Is there a way to "merge" modules using Cabal? ie given M exporting f, N exporting g, i'd like in cabal to say "let O export M.f, N.g"
13:18:52 <hseg> seems reexported-modules/mixins should help here
13:19:03 <hololeap> jollygood2: i don't mind that tradeoff at all, but i still don't see how to make it work
13:19:45 <jollygood2> hololeap, when you add a new element, add it to both `IntMap Key (MinTime, a)' and IntMap MinTime (Key, a)
13:20:05 <jollygood2> abstract that details away in a new type, and some convenience functions for adding/looking up elements
13:20:19 <hololeap> right, but how would you do a lookup that meets my conditions in O(1) time using that?
13:20:47 <jollygood2> 2xO(1) is O(1)
13:25:32 <xsperry> if I change resolver in stack, that requires new ghc vesion, and I conclude it is not worth upgrading, is there a straightforward way to free up all the space caused by that attempt to upgrade (by deleting ghc, newly downloaded packages, and anything else that was installed)
13:26:21 <hseg> hrm. seems my naive attempts fail
13:27:00 <hseg> basically what i'm trying to do is move some conditional compilation to Cabal
13:27:03 <maerwald> xsperry: check out ~/.stack/snapshots but the directory names aren't that intuitive
13:27:07 <hseg> instead of CPPifying my source
13:27:39 <hseg> All is well when it comes to choosing one of several implementations of the same module signature
13:28:07 <hseg> but now i have the "guard instance provision behind a flag" problem
13:29:09 <hseg> which i was hoping to avoid by only exposing the relevant module if the flag is set, and bundling all exposed modules into one big index module
13:29:54 <hseg> was hoping the index module could be virtual, generated by cabal by merging all the implementation modules
13:30:28 <hseg> unfortunately, this is not the case. at least can restrict the CPP to the index module only
13:31:24 <hseg> btw, now that i've stumbled on this gap, is anyone else interested in it?
13:31:54 <hseg> i.e. being able to say mixins: foo (M as O, N as O) where the export lists of M,N are disjoint
13:32:14 <hseg> and getting a virtual module O that exports the union of M,N's exports
13:33:27 <hololeap> jollygood2: how would you complete the lookupMinWithTime function? https://dpaste.com/H7DLYA6AD
13:37:45 <hololeap> i'm pretty sure the best that can be done with this data structure is O(n) time, but i would love to be proven wrong
13:38:56 <jollygood2> hololeap, oh, I see what you mean.
13:59:45 <hexagoxel> ezzieyguywuf: oh, you might need RankNType magic, i.e. replace `(a -> Adjacency a -> Maybe a)` with `(forall a . Eq a => a -> Adjancency a -> Maybe a)` in your traverseWire signature.
14:22:19 <koz_> How do I create a set of aeson Options where, for a no-arg constructor FooBar, I get a JSON string "FOO_BAR", assuming I'm encoding a sum?
14:22:40 <koz_> I can do the upcasing fine, but am unsure about the underscore separation.
14:36:43 <solonarv> koz_: IIRC you can pass an arbitrary 'String -> String' function to aeson there, so just figure out how to do that string transformation I guess?
14:37:02 <koz_> solonarv: I could do that, but it seems common enough that it might have built-in support.
14:37:26 <koz_> Plus, this sounds exactly like the sort of thing that leads to weird bugs when self-rolling.
14:40:39 <Uniaika> koz_: congratulations, a new PR to Aeson is underway :P
14:40:49 <koz_> Uniaika: Lol?
14:41:13 <monochrom> "This recompiles everything again."
14:42:14 <monochrom> That was first said by someone here a long time ago when a new GHC version came out, and it was just a few months after Apple's iPhone ad "This changes everything. Again." of that time.
14:43:00 <monochrom> Now with stack and cabal's auto-rebuild, it's perpetually true.
14:46:18 <Uniaika> monochrom: lies, we're supposed to have incremental rebuilds now
14:54:19 * hackage hextra 1.1.0.0 - Generic and niche utility functions and more for Haskell.  https://hackage.haskell.org/package/hextra-1.1.0.0 (anselmschueler)
14:58:07 <dolio> If it's at the root of the tree, rebuilding everything is as incremental as you get.
15:13:50 * hackage hextra 1.1.0.1 - Generic and niche utility functions and more for Haskell.  https://hackage.haskell.org/package/hextra-1.1.0.1 (anselmschueler)
15:23:20 <koz_> @pl \i -> fmap (i,) foo
15:23:20 <lambdabot> (line 1, column 14):
15:23:20 <lambdabot> unexpected ","
15:23:20 <lambdabot> expecting letter or digit, variable, "(", operator or ")"
15:23:47 <koz_> @pl \i -> (,) <$> pure i <*> foo
15:23:47 <lambdabot> ((,) <$>) . (<*> foo) . pure
15:23:53 <koz_> Umm, yeah nope.
15:25:19 <MarcelineVQ> :t fmap . (,)
15:25:20 <lambdabot> Functor f => a1 -> f a2 -> f (a1, a2)
15:25:56 <koz_> Is there a package with an Arbitrary instance for IntMap?
15:26:31 <koz_> Lol, it's built-in, never mind. :P
15:28:56 <MarcelineVQ> (<$> foo) . (,)
15:29:22 <xiu2> I have a dependency that's failing to compile, looks like it's because of my OpenSSL being newer than it should be. Is there a way to get it to use an older openSSL that I install somewhere?
15:29:38 <xiu2> here's a gist of the error output: https://gist.github.com/appestat/a402ee612af68527297db21e84d1eea2
16:37:04 <avn> Hello! Silly question about ghc plugins -- are possible to figure out in what package/module `HsType GhcPs` and `FieldOcc GhcPs` originally defined?
16:39:42 <mniip> GHC.Hs.Types GHC.Hs.Extension
17:21:00 <koz_> @pl \(i, mt) -> (i,) <$> mt
17:21:00 <lambdabot> (line 1, column 15):
17:21:00 <lambdabot> unexpected ","
17:21:00 <lambdabot> expecting letter or digit, variable, "(", operator or ")"
17:23:10 <koz_> > sequenceA (1, Just "foo")
17:23:12 <lambdabot>  Just (1,"foo")
17:23:22 <koz_> > sequenceA (1, Nothing)
17:23:23 <lambdabot>  Nothing
17:24:41 <koz_> (A form of) traverse does everything!
17:25:51 <xsperry> > sequence (1, Just "foo", Just 3)
17:25:51 <jle`> wishing we had bisequence
17:25:53 <lambdabot>  error:
17:25:53 <lambdabot>      • No instance for (Traversable ((,,) Integer (Maybe [Char])))
17:25:53 <lambdabot>          arising from a use of ‘e_113’
17:26:14 <xsperry> oh, I get it
17:26:15 <jle`> xsperry: for some reason ghc decided not to write an instance for thruples
17:26:22 <koz_> jle`: [insert joke about how being bi makes everything better that I am not smart enough to construct]
17:26:32 <jle`> @let deriving instance Traversable ((,,) a b)
17:26:34 <lambdabot>  .L.hs:165:1: error:
17:26:34 <lambdabot>      • No instance for (Foldable ((,,) a b))
17:26:34 <lambdabot>          arising from the superclasses of an instance declaration
17:26:42 <jle`> @let deriving instance Foldable ((,,) a b)
17:26:43 <lambdabot>  Defined.
17:26:44 <koz_> In fact, I should have gone with a joke about non-constructive proofs there too.
17:26:46 <jle`> @let deriving instance Traversable ((,,) a b)
17:26:47 <lambdabot>  Defined.
17:26:56 <jle`> > sequence (1, Just "foo", Just 3)
17:26:57 <lambdabot>  Just (1,Just "foo",3)
17:27:05 <mirrorbird> @foldl1 + [1,2,3]
17:27:05 <lambdabot> Sorry, look up one word at a time please.
17:27:05 <xsperry> > sequence (1, Nothing, Just 3)
17:27:07 <lambdabot>  Just (1,Nothing,3)
17:27:16 <mirrorbird> > + [1,2,3]
17:27:17 <lambdabot>  <hint>:1:1: error: parse error on input ‘+’
17:27:21 <mirrorbird> > foldl1 + [1,2,3]
17:27:22 <lambdabot>  error:
17:27:22 <lambdabot>      • Couldn't match expected type ‘(a -> a -> a) -> t a -> a’
17:27:22 <lambdabot>                    with actual type ‘[Integer]’
17:27:37 <jle`> mirrorbird: to use + as a function, the syntax is (+)
17:27:46 <jle`> using it as + treats it as an operator, like you're adding foldl1 and [1,2,3] together
17:27:51 <jle`> > foldl1 (+) [1,2,3]
17:27:53 <lambdabot>  6
17:28:12 <mirrorbird> so (+) implicitly creates \x y -> x+y ?
17:28:29 <jle`> not quite
17:28:35 <jle`> \x y  -> x + y is sugar for \x y -> (+) x y
17:28:37 <jle`> (+) is the actual thing
17:28:41 <jle`> + as an operator is sugar
17:28:44 <mirrorbird> oh
17:28:55 <jle`> so you could say x + y 'implicitly' becomes (+) x y
17:29:09 <xsperry> > map (*10) [1..5]
17:29:11 <lambdabot>  [10,20,30,40,50]
17:29:32 <mirrorbird> i was just reading learnyouahaskell again to brush up. wondering why they don't use PN/ treat operators as any other function
17:29:51 <jle`> yeah, (+) as a value is the addition function
17:30:00 <jle`> operator notation is special syntactical sugar
17:30:10 <jle`> so you can do fancy things like imitate mathemeticians
17:30:19 <mniip> :t let (+) = () in (+)
17:30:20 <lambdabot> ()
17:31:04 <jle`> mirrorbird: so we technically do have PN by default with (+), but some syntactical sugar to make working with PN less of a headache in some situations
17:31:16 <jle`> although some would argue that using operator syntax makes things worse more often than it helps
17:31:41 <mirrorbird> can't believe i aced the introductory FP course + schemed a lot in the past and never bothered to read even learnyouahaskell
17:31:55 <mirrorbird> there were some parts of haskell i didn't quite grasp because i didn't bother reading a few chapters first
17:32:10 <mirrorbird> (not this operator stuff)
17:32:13 <jle`> that's not too surprising i think :) a lot of FP as is understood by most of the world is more scheme/lisp style FP
17:32:42 <mirrorbird> well when i last did an assignment i didn't even remember what $ and . were doing so i avoided them and my code looked like Schemy
17:33:03 <mirrorbird> that also included flipping characters between ., $ and ( to see what happened. lol
17:34:05 <mirrorbird> actually i do think using that special operator syntax makes it worse, less easy to read for the uninitiated
17:34:35 <jle`> yeah, but if you don't have it then people will complain about why they can't write 1 + 3
17:34:51 <jle`> so there's no way to make everyone happy :(
17:34:57 <xsperry> . composes two functions. and $ is:
17:35:01 <xsperry> @src ($)
17:35:01 <lambdabot> f $ x = f x
17:35:15 <xsperry> (with lowest priority)
17:35:17 <mirrorbird>  well.
17:35:36 <mirrorbird> yes i know what they do, now
17:35:51 <xsperry> ah ok, sorry
17:38:01 <jollygood2> what haskell web scraping packages are popular these days?
17:42:07 <mirrorbird> jollygood2, i am a neophyte, but i googled and found Scalpel
17:46:37 <koz_> jollygood2: What're you planning to scrape?
18:46:28 <libertyprime> Does anyone here know of any example-oriented languages?
18:46:43 <libertyprime> where every function is essentially [String]->String
18:46:50 <monochrom> English.
18:47:03 <monochrom> tcl
18:47:13 <libertyprime> tcl is close
18:47:48 <monochrom> Multi-tape Turing machines.
18:49:26 <libertyprime> I'd like a language for representing NLP tasks
18:49:56 <libertyprime> where an example is used for one-shot learning
18:50:53 <libertyprime> but where the transformations are represented in the type system somehow
18:50:58 <libertyprime> like a lazy type system
18:55:49 <hyiltiz> awk has no type system but does its job fine, no?
19:04:19 * hackage language-dickinson 1.2.0.0 - A language for generative literature  https://hackage.haskell.org/package/language-dickinson-1.2.0.0 (vmchale)
19:36:53 <Axman6> jle`: in https://blog.jle.im/entry/enhancing-functor-structures-step-by-step-1.html, what's [^xvar] supposed to be? Looks a reference? in the paragraph beginning with "So schemaDoc will take the name of our type and a schema,"
19:49:02 <Graypup_> I am *absolutely* not qualified to be writing the code I am currently writing, but it seems like there are very few options for acceptable CSPRNGs on hackage? I mean, realistically who is going to mount an RNG manipulation attack on a website session system? but still!!
19:49:27 <Graypup_> the one, `random` does not claim to be cryptographically secure
19:51:17 <Axman6> have you looked at cryptonite? it at least uses the hardware crypto instructions to generate randomness. but I guess you really need PRNGs?
19:51:23 <Graypup_> which seems not ideal? anyway what I am doing is generating nonces and csrf tokens for an OpenID Connect implementation. neither of which are likely *that* attackable? idk it feels icky
19:51:27 <Axman6> there' is probably some in cryptonite too
19:51:43 <Graypup_> yeah I think cryptonite is the one option
19:54:38 <Graypup_> oh no......... > Initialize SMGen using system time.
19:54:43 <Graypup_> well I am obligated to use cryptonite
19:54:52 <Graypup_> because that is probably bad
19:55:18 <Axman6> I'm sure there's other ways to initialise it
19:56:09 <Graypup_> probably, but yesod-auth-oauth2 is doing exactly that because it is using the StdGen interface to `random`
20:11:25 <jle`> Axman6: ah thanks, must be a broken footnote
20:12:35 <jle`> it is a footnote i removed :)
20:16:57 <Axman6> jle`: might also want to fix "Finally, to wrap bring it all together" -> "Finally, to bring it all together"
20:21:30 <libertyprime> this is the basics of the example-based DSL id like to have: http://ix.io/2uAt/org  if anyone can think of something *like* this that exists already, please let me know
20:22:19 * hackage discord-haskell 1.8.0 - Write bots for Discord in Haskell  https://hackage.haskell.org/package/discord-haskell-1.8.0 (Aquarial)
20:29:14 <triteraflops> So. Suppose I have a calculation with many inputs and I update just one.
20:29:29 <triteraflops> Can GHC automatically reuse the previous calculation?
20:29:46 <triteraflops> I would consider it fairly miraculous, but I thought I'd ask
20:30:09 <triteraflops> Not the whole previous calculation. Just the part that didn't depend on the inputs that didn't change.
20:30:25 <c_wraith> not unless you explicitly write the code to work that way.
20:30:40 <jle`> Axman6: thank you :)
20:30:46 <c_wraith> general memoization tends to use so much memory it's slower than not doing so
20:31:53 <triteraflops> That's kinda what I figured
20:32:06 <triteraflops> except you don't have to store all previous values, only the previous one
20:32:31 <triteraflops> and it's just conceivable that ghc would be able to figure that out.
20:33:44 <triteraflops> so, OK next question, consider f x y = 2*x - y
20:34:02 <triteraflops> ghc could conceivably do the 2*x upon partial application
20:34:27 <triteraflops> like f 6 = \y -> 12 - y
20:34:32 <c_wraith> ok, ghc has some rules that Haskell doesn't here.
20:34:54 <c_wraith> so, *specifically in ghc*, it will save the partial work if you name it outside a lambda.
20:35:13 <c_wraith> so...  f x = let z = 2 * x in \y -> z - y
20:36:24 <triteraflops> It makes sense that there would be freedom here. You can't really print a function object anyway. A partially applied function is pretty opaque on the inside.
20:37:17 <c_wraith> but that's getting into the specific things GHC does that aren't required by the spec.  It might at some point change them, if there's a good reason
20:37:34 <triteraflops> Anyway, this is a simple example where if you only update y, you do not need to repeat the 2*x
20:37:45 <c_wraith> and notice that I had to rewrite it for that. :)
20:38:25 <triteraflops> and traditionally, in order to make this optimisation, you have to have separate state for the 2*x and stuff
20:38:32 <c_wraith> yep
20:38:43 <triteraflops> Not a big deal when there's only one input, but if there are dozens, that gets pretty funky
20:39:11 <c_wraith> when there are that many, you might want to chunk them with additional data types.
20:40:00 <triteraflops> Yeah, that's one decent solution, but seems to me, it should be possible to write the function in such a way that intermediary results are automatically saved as state.
20:40:43 <triteraflops> You shouldn't need to store any intermediate state explicitly. If you write the function differently, you could figure out where the intermediate state is automatically.
20:41:27 <triteraflops> Like, writing it as an AST, or something
20:42:48 <c_wraith> that's getting into arbitrary partial evaluation - which is *very* difficult in general
20:43:18 <triteraflops> even in pure functions?
20:43:32 <c_wraith> yes.  they're still turing complete
20:43:57 <triteraflops> ah, what if you require a DAG?
20:44:20 <triteraflops> so your calculation has a maximum depth that is easy to determine, basically
20:44:22 <c_wraith> That might be enough to make it tractable.  But now you're writing a whole library for runtime partial evaluation.
20:44:33 <triteraflops> yes, I would be lol
20:44:37 <triteraflops> does such a library exist?
20:44:48 <c_wraith> I'm not aware of one, but that isn't a strong signal.
20:45:37 <triteraflops> well, you've still been very helpful.
20:46:11 <triteraflops> The motivation on my side is model->view rendering optimisation
20:46:24 <triteraflops> many model->view maps could be dags
20:46:48 <c_wraith> also of note - you don't need to be perfect to get decent improvements
21:03:06 <hololeap> i'm curious about the vinyl library, but i don't know what the "records problem" in haskell actually is. can anyone give some examples?
21:24:37 <lyxia> hololeap: it's just the polite way of saying that "records suck in Haskell" https://nikita-volkov.github.io/record/
21:26:30 <Cale> The only problem I agree with on that page is #2
21:26:49 <Cale> #1 and #3 are not problems, and #4 has well-known solutions
21:27:34 <Cale> Record syntax probably should not be allowed for sum types at all
21:27:51 <Cale> But if it is, it should probably only be allowed in the case that all constructors have exactly the same fields.
21:29:48 <mirrorbird> eval: (map toUpper "hello")
21:35:32 <jackdk> % map toUpper "hello" --mirrorbird
21:35:32 <yahb> jackdk: "HELLO"
21:37:42 <mirrorbird> oh. i was trying map . toUpper . "hello" and all variations with $ and .
21:37:47 <mirrorbird> that really works?!
21:38:05 <mirrorbird> % map (\x -> x+99) [1,2,3]
21:38:05 <yahb> mirrorbird: [100,101,102]
21:45:44 <jackdk> mirrorbird: yeah, just take it one step at a time with :t
21:45:48 <jackdk> % :t map
21:45:48 <yahb> jackdk: (a -> b) -> [a] -> [b]
21:45:52 <jackdk> % :t map toUpper
21:45:52 <yahb> jackdk: [Char] -> [Char]
21:46:00 <jackdk> % :t map toUpper "Hello"
21:46:00 <yahb> jackdk: [Char]
21:46:39 <Graypup_> in Yesod, how can I get the full URL to a route?
21:51:12 <noguchitan> want to get into FP, mostly for the learning benefits
21:51:26 <noguchitan> should I go with haskell or go with something older like lisp?
21:51:40 <noguchitan> i dont think ill ever develop anything with these, just want to learn more
21:51:54 <c_wraith> Haskell forces you to learn the most, but that means it's a pretty steep wall to scale at the start
21:52:41 <mirrorbird> noguchitan, any of then will teach you the fundamental concepts. i started with scheme, picking up haskell/others was easier after that, and started using FP stuff in other langs
21:53:21 <mirrorbird> noguchitan, how are you with fp concepts so far?
21:53:22 <Graypup_> I halfway learned F#, got good at Rust and then now am doing work in Haskell for pay
21:53:38 <wavemode> lisp is a cool language to play with, but it's dynamically typed. from the perspective of wanting to learn functional programming, you would miss out on a lot of the point/benefits
21:53:38 <Graypup_> which I did not expect to be doing ever
21:54:05 <mirrorbird> c_wraith basically hit the nail on the head. you could write functional code in c++ but, you won't be forced to
21:58:07 <Axman6> noguchitan: my personal opinion is that working with a language with strong types gives you an excellent mental model to help you structure programs, and gives you a lot more help from the compiler. Haskell is just about the best language there is in this regard until you start getting into really esoteric languages with even more powerful type systems. The combination of a powerful type system and good support for sum types makes for a reall
21:58:07 <Axman6> y principled approach to working through problems
21:58:43 <Axman6> but, Haskell has been my primary language for over a decade, and has been paying my bills for the last 6-7 years, so I may be somewhat biased
21:59:08 <Axman6> Graypup_: mind if I ask where you're doing that work?
21:59:24 <Graypup_> Axman6, university, working on an online logic textbook, Carnap
21:59:33 <Axman6> fun
21:59:45 <Graypup_> yeah except i am nose deep in an auth spec
21:59:47 <Graypup_> :/
21:59:58 <Graypup_> that part not so fun
22:00:07 <mirrorbird> which spec?
22:01:05 <Graypup_> LTI 1.3!
22:01:11 <Graypup_> there are no haskell implementations so I am writing one
22:02:48 <mirrorbird> noguchitan, tell us what you pick ;)
22:03:30 <Axman6> if you can implement it in a way that doesn't rely on any specific web framework that would be excellent - would be nice if it were equally useful from yesod and servant
22:04:00 <Graypup_> Axman6, well, that part is already done actually! I am writing a yesod front end at the moment
22:04:15 <Graypup_> and bashing my head against not knowing what i am doing with monad types lol
22:04:35 <mirrorbird> wait lemme get 50 tutorials
22:04:49 <Axman6> "I don;t know what I'm doing" and "let's implement an auth framework!" inspires a lot of confidence :P
22:05:03 <Axman6> (Feel free to ask questions here though)
22:05:08 <Graypup_> Axman6, well, that is indeed my feeling as well
22:05:29 <Axman6> if you want, you can pay me and I'll do it :P
22:05:40 * mirrorbird has logged in as Graypup_
22:05:48 <Graypup_> lmao
22:06:33 <Graypup_> but at the same time it doesn't seem like the other people writing auth frameworks know 100% what they're doing either
22:06:41 <Graypup_> i am just not good at haskell yet
22:10:25 <Axman6> well we're here to help with exactly that problem
22:18:51 <koz_> Yep, we can definitely assist with the 'not good at Haskell' thing.
22:19:20 <mniip> hmm
22:20:53 <jackdk> so if you got good at rust, then you'll have a much smoother road through algebraic data types and type classes (which are similar to traits, I've been told) than many imperative programmers coming from older languages
22:21:08 <mniip> is there a good library for radix trees
22:21:11 <Graypup_> yeah definitely!
22:21:27 <Graypup_> I got a lot less confused with Haskell now than I would have 6 months ago
22:21:31 <mniip> I've written my own several times
22:21:36 <mniip> maybe I should write a library for them
22:22:57 <koz_> mniip: This.
22:25:32 <mniip> though, I'm working on a problem right now that has a very peculiar operation
22:27:14 <mniip> :t \k -> S.map (`setBit` k) . S.filter (not . (`testBit` k))
22:27:15 <lambdabot> (Ord b, Bits b) => Int -> S.Set b -> S.Set b
22:27:44 <mniip> if we implement the set by the means of a binary tree this admits a *very* efficient implementation
22:28:40 <opqdonut> hmm, at the kth level, replace every right child with the left child?
22:28:50 <opqdonut> (and empty the left child)
22:30:30 <mniip> yes
22:30:40 <mniip> (and maintain a few additional invariants)
22:38:35 <mniip> http://tcp.st/6e4a7.png
22:39:25 <mniip> except I'm actually using base-4 trees for even more performance http://tcp.st/80x7g.png
22:39:28 <Graypup_> i am building myself into a corner with type parameters lol i am so not smart
22:53:46 <Graypup_> i am swearing at the computer way too much, time to quit for the day lol
22:54:42 <mirrorbird> Graypup_, hang in there buddy
22:55:03 <Graypup_> type signatures are hard :(
22:59:56 <jchia> Are there examples of how to use the hkd package? It looks quite abstract, more so than lens.
23:02:39 <opqdonut> mniip: heh, what are the chances of not making a typo in the base-4 case? did you generate that code?
23:03:07 <opqdonut> I wonder if it would be possible to express the algorithms in base-2 and still run them efficiently on base4 trees
23:03:41 <opqdonut> something that inlines away
23:06:04 <mniip> it's half-generated
23:06:11 <mniip> though doing it with TH is one idea
23:06:26 <mniip> it was basically a bunch of s/// in vim
23:15:27 <Graypup_> well I fixed all the holes i dug myself into lol
23:15:34 <Graypup_> deleted two wrong type constraints
23:34:05 <mniip> koz_, maybe I should undertake this affair
23:34:11 <mniip> could learn a thing or two about perf testing
23:38:05 <jchia> dhall question: Does Dhall allow expressing a valid range for some value when I input it from Dhall language to a Haskell record? Or, can I only do the range check myself after importing? My record has Word8 but the is only a FromDhall instance for Integer, not Word8.
