00:14:34 <kleisli> is there a standard way to download an image from a url over https?
00:24:43 <koz_> Axman6: Was about to ask lol.
00:24:54 <koz_> toLazyList = id
00:36:35 <bahamas> anyone knows where I can find `where` documented in the haskell report?
00:37:23 <bahamas> used in the context of a function declaration
00:39:41 <[exa]> bahamas: wild guess: somewhere near parsing as a syntactic sugar for `let`?
00:43:56 <mniip> bahamas, 4.4.3
00:45:41 <bahamas> thanks
00:46:01 <mniip> 3.17.3 tackles the where-clauses on 'case' in detail, and 4.4.3 talks about where-clauses on definitions by equations
01:29:25 <dminuoso> Mmm, rebuilding a component with `cabal v2-build --enable-split-sections ...` happens almost instantly. Shouldn't that recompile all my dependencies?
01:31:35 <dminuoso> Adding it to my ~/.cabal/config helps, but that seems a little overkill.
02:17:34 <merijn> dminuoso: Why? I did :p
02:17:49 <dminuoso>  heh
02:18:26 <dminuoso> The difference is crazy though. Merely just enabling that reduces binary size by 70-75%, even without stripping!
02:18:36 <dminuoso> Why is this not enabled by default?
02:19:34 <merijn> Hysterical raisins?
02:19:42 <merijn> It's fairly new too
02:19:49 * hackage vulkan 3.6.5 - Bindings to the Vulkan graphics API.  https://hackage.haskell.org/package/vulkan-3.6.5 (jophish)
02:32:31 <dansho> is there a mutable 2d array type somewhere? or should i build my own from MVector or something?
02:33:39 <fendor_> dansho, depending on your use-case, massiv is cool
02:34:59 <merijn> Array has arbitrary indices, so can be 2D
02:35:05 <merijn> And then there's hmatrix
02:35:18 <merijn> (I"m not sure hmatrix supports a mutable API, though?)
02:36:12 <dansho> already using hmatrix, it is kind of limited by the types that implement Element, which is required for most operations
02:39:00 <ph88> how can i run a webserver and a "cron process" (http request that runs every X minutes) in the same process? can i do some async programming somehow ?
02:39:38 <dminuoso> You can use forkIO (or better yet the `async` package)
02:40:05 <ph88> which webserver works well together with the async package ?
02:40:11 <dminuoso> Any, they are unrelated.
02:40:31 <dminuoso> async is essentially a thin but useful wrapper around forkIO and related tools.
02:40:41 <ph88> ah i see
02:41:16 <dminuoso> Also, if there's any communication between those threads, you'll probably need MVar or `stm`
02:47:15 <ph88> dminuoso, i was thinking to do communication through the database
02:47:21 <ph88> how can i make one thread that writes to SQLite and multiple thread for reading ?
02:48:31 <ph88> https://www.sqlite.org/faq.html#q5
02:48:46 <ph88> ye not sure if i use async how i can use sqlite from different threads
02:49:49 <iko> I suspect that if you `forkIO` and access SQLite from different threads, from the point of view of SQLite it is indistinguishable from truly separate processes 
02:52:15 <merijn> eh, no
02:52:27 <opqdonut> iko: no, forkIO makes OS threads, which mean that they share the sqlite c library, which needs to be re-entrant
02:52:29 <merijn> You wanna make sure SQLite is running in the highest thread safety mode
02:52:45 <opqdonut> yeah, seee question 6 in that faq
02:53:12 <merijn> You want SQLite with threading mode Serialized
02:53:24 <merijn> https://www.sqlite.org/threadsafe.html
02:54:06 <dminuoso> ph88: Do you have an sqlite database regardless?
02:54:15 <dminuoso> Or would you use it for communication between those threads only?
02:55:24 <ph88> i need the sqlite database for storage too
02:56:03 <ph88> how can i make only 1 OS thread that does everything with sqlite. and then the other threads send the queries to the one thread with a queue ?? this seems to be much safer and less headache
02:56:22 <dminuoso> ph88: Use stm.
02:56:46 <dminuoso> Though, actually in that case it wont work.
02:56:48 <dminuoso> Unless you use forkOS
02:57:07 <ph88> so use stm + forkOS ?
02:57:44 <dminuoso> Well, you'll have the problem regardless if your webserver is threaded
02:58:18 <dminuoso> Ah wait, no forkOS wont help either
03:03:42 <ph88> o_O
03:03:53 <ph88> can i work with sqlite and async at all ??
03:04:17 <ph88> no matter which way .. just that it's safe and i can use async for other stuff. Don't care if sqlite is threaded or not
03:11:38 <merijn> ph88: The SQLite threading mode doesn't make *sqlite* threaded it controls in which situations SQLite can be used thread-safely
03:11:54 <merijn> ph88: the serialised mode means you can use sqlite concurrently from any thread at any time
03:12:13 <ph88> only for reading ?
03:12:19 <merijn> For everything
03:17:52 <Arahael> merijn: Remind me - is it row locking or table locking?
03:18:42 <merijn> Arahael: table locking for writes, concurrent writers isn't something SQLite supports very well
03:18:48 <merijn> (in terms of performance)
03:19:02 <merijn> But if you don't have highly contended writes it's fine
03:19:03 <Arahael> merijn: I think that's a perfectly reasonable decision by sqlite.
03:19:50 * hackage prettyprinter-lucid 0.1.0.0 - A prettyprinter backend for lucid  https://hackage.haskell.org/package/prettyprinter-lucid-0.1.0.0 (GeorgeThomas)
03:21:11 <dminuoso> merijn: Well to be fair, concurrent writes is part of what makes scalable databases hard to implement. :)
03:22:53 <merijn> dminuoso: atomicity and good query planning is hard too
03:23:40 <dminuoso> Right. And then you want streaming replication.. and then you're pretty much at postgresql. :)
03:24:23 <merijn> That's how the database selection flowchart goes
03:24:49 <merijn> SQLite? - Yes? -> Done. - No? -> Postgres, done.
03:25:07 <dminuoso> heh
03:32:23 <Arahael> sqlite also has practicaly zero I/O overheads, too, though. :)
03:32:44 <Arahael> (Comparatively speaking.  The IO "between" the app and the database is effectively zero)
03:49:49 * hackage symantic-xml 2.0.0.20200523 - Library for reading, validating and writing XML.  https://hackage.haskell.org/package/symantic-xml-2.0.0.20200523 (julm)
03:50:07 <dminuoso> Mmm, why doesn't ghc strip unneeded symbols for executables?
03:50:38 <dminuoso> This default behavior of producing binaries that are 10x as large as needed seems a bit weird, and it just adds fuel to critics..
03:53:25 <merijn> dminuoso: most C compilers don't strip either
03:53:34 <merijn> dminuoso: Because it makes debugging easier
03:53:40 <merijn> That's why you need explicit release builds
03:53:48 <merijn> People are just more used to doing that with C stuff
03:54:06 <dminuoso> Ahh mmm.
03:54:27 <dminuoso> merijn: Mind my asking, how does keeping unneeded symbols help with debugging?
03:55:13 <dminuoso> I mean Im consideirng something like `--only-keep-debug`
03:55:13 <merijn> dminuoso: strip removes DWARF symbols too
03:55:18 * hackage symantic-base 0.0.0.20200708 - Basic symantics for writing Embedded Domain-Specific Languages (EDSL).  https://hackage.haskell.org/package/symantic-base-0.0.0.20200708 (julm)
03:55:20 <dminuoso> Sure, but if you specify --only-keep-debug ?
03:55:33 <merijn> Never heard of --only-keep-debug
03:55:54 <dminuoso> Check strip(1) then
03:56:19 * hackage symantic-atom 0.0.0.20200523 - Library for reading and writing Atom.  https://hackage.haskell.org/package/symantic-atom-0.0.0.20200523 (julm)
03:56:25 <dminuoso> You get to strip away at least all unnused library stuff
03:56:57 <merijn> dminuoso: Well, there you go
03:57:03 <merijn> dminuoso: Doesn't exist on macOS :p
03:57:21 <merijn> So, the lack of a portable strip would be one reason for GHC not too :p
03:57:27 <dminuoso> Why not?
03:57:32 <dminuoso> I mean cabal doesnt care either
03:57:37 <dminuoso> It just "doesnt do anything"
03:57:49 <dminuoso> stripping unnused non-debugging symbols from a GHC as a best effort sounds very reasonable
03:58:21 * hackage prettyprinter-lucid 0.1.0.1 - A prettyprinter backend for lucid  https://hackage.haskell.org/package/prettyprinter-lucid-0.1.0.1 (GeorgeThomas)
03:59:23 <dminuoso> *from an executable
04:04:51 * hackage Rattus 0.3.1 - A modal FRP language  https://hackage.haskell.org/package/Rattus-0.3.1 (PatrickBahr)
04:09:49 * hackage groups 0.5 - Groups  https://hackage.haskell.org/package/groups-0.5 (NathanVanDoorn)
04:34:31 <maerwald> is there a trick on how to derive a Show instance of a sum type that has an existential type (which has a Show constraint)?
04:43:00 <dyniec[m]> StandaloneDeriving seems to work
04:43:48 <dyniec[m]> Nevermind, I missed the sum part
04:44:47 <dminuoso> maerwald: can you share the exact ADT definition you have?
04:48:06 <maerwald> dminuoso: https://git.io/JJF6i
04:50:26 <dminuoso> maerwald: Ah I see. Such a thing is not possible.
04:51:00 <dminuoso> The reason is that the Haskell Report demands that a deriving generated Show instance would produce an appropriate haskell expression that yields the value in place.
04:51:01 <maerwald> not even with some generic magic?
04:51:18 <dminuoso> (So while it could generate *some* show instance, it couldn't comply with the haskell report)
04:51:41 <dminuoso> At least that's my take on it
04:52:47 <merijn> Man...whenever I need to make changes to this code I'm so happy I rewrote it all in Haskell :>
04:53:31 <Arahael> True words.
04:53:32 <maerwald> merijn: why you making changes? Fix your project management!
04:53:34 <dminuoso> "The result of show is a syntactically correct Haskell expression containing only constants, given the fixity declarations in force at the point where the type is declared. It contains only the constructor names defined in the data type, parentheses, and spaces."
04:53:53 <dminuoso> (Keep in mind that this rule applies to deriving Show only)
04:53:57 <merijn> maerwald: lol, project management :p
04:54:11 <maerwald> yes, I believe in it
04:54:20 <maerwald> until then, using haskell
04:54:50 <merijn> maerwald: Project management is for people in the real world, not academics >.>
04:55:01 <timCF> Hello guys! I need to generate cryptographically secure random ByteString, any suggestions which library better to use?
04:55:54 <maerwald> timCF: https://hackage.haskell.org/package/HsOpenSSL-0.11.4.18/docs/OpenSSL-Random.html
04:55:54 <merijn> timCF: Reading from /dev/urandom :p
04:56:10 <dminuoso> maerwald: So, if this was *only* Show in the existential, one could cook up something special here, where it'd just put in the showed string. But the additional existential means it couldn't.
04:56:13 <merijn> Man, I would definitely trust urandom over a Haskell openssl port with no auditing
04:56:14 <dminuoso> Does tha tmake sense?
04:56:23 <dminuoso> *the additional constraint
04:56:47 <AWizzArd> timCF: alternatively: http://hackage.haskell.org/package/cryptonite-0.18/docs/Crypto-Number-Generate.html
04:56:52 <dminuoso> Or mmm.
04:56:59 <timCF> thanks!
04:57:22 <dminuoso> maerwald: Yeah ultimately the problem is that the above requirement is limited to deriving only. A Show instance is not guaranteed to produce a valid haskell expression. 
04:58:22 <dminuoso> So if you held some DeserialiseError in your hand, you wouldn't know whether the contained thing showed into a valid haskell expression
05:20:59 <typetetris> How can I handle non nullable auto increment fields correctly with persistent? (No need to specify them on insert, getting them on select (or similar) without a Maybe.)
05:24:48 <merijn> In all likelihood "you don't"
05:24:58 <merijn> Or "you patch it manually as a custom field type"
05:28:24 <AWizzArd> I want to generate an sql query with a varible number of columns in its select. My current plan is to specify my function returning Aeson’s `Value`. Does that make sense?
05:32:27 <merijn> Yes, no, maybe
05:33:36 <hc> which type is that? ;p
05:33:50 <hc> data Undecided d = Yes | No | Maybe d
05:35:20 <typetetris> What alternatives to persistent exist? Is there a listing somewhere?
05:35:38 <hc> I have used esqueletto in the past
05:35:49 <hc> it's an extension to persistent that allows you to safely write sql queries
05:35:59 <Arahael> Lately I tend to prefer raw SQL. :(
05:36:18 <merijn> typetetris: sqlite-simple/postgres-simple
05:37:15 <typetetris> I remember, there was something type programming heavy, you could define your schema in haskell with, but sadly I don't remember its name ...
05:37:33 <merijn> BEAM?
05:37:55 <merijn> Also, that's probably even worse than persistent :p
05:38:28 <hc> beam? isn't that the name of erlang's bytecode? ;)
05:39:04 <Uniaika> Beam ≠ .beam ≠ BEAM
05:40:11 <typetetris> yes! this beast https://github.com/haskell-beam/beam
05:41:09 <hc> oh, fascinating :)
05:41:25 <merijn> beam seems like a great library if you want to spend 95% of your time fucking around with horrific type errors and 5% off your time making progress on your problem :)
05:41:39 <kuribas> and write a lot of boilerplate
05:41:50 <hc> merijn: what about esqueletto? in comparison to bean?
05:41:54 <hc> beam*
05:42:14 <merijn> hc: That uses persistent and I don't think I'd use that again either :p
05:42:31 <kuribas> it's time I ported my mysql db library to hdbc, and promote it here :)
05:42:59 <hc> merijn: sidenote -- i'm currently using rust's diesel a lot and persistent feels superior to that
05:43:16 <merijn> hc: I'm currently using persistent :p
05:43:22 <hc> =)
05:43:27 <merijn> Because migrating away now is too much work
05:43:36 <merijn> But next time I'm just writing SQL by hand
05:43:45 <hc> still, better being stuck with some free software than some cloud api ;p
05:44:56 <typetetris> Writing SQL by hand ... maybe I have to resort to that, but I really would like to have some typesafety.
05:45:31 <kuribas> writing SQL by hand is the best, then you know it will be performant.
05:45:43 <kuribas> any layer between just add complexity.
05:46:08 <merijn> My main complaint isn't performance, but the intermediate layers hamstringing functionality
05:46:33 <merijn> I've had to patch multiple things in persistent to expose features I needed, and I'm still missing some
05:46:36 <hc> there's some truth in that: the more of the sql featureset you use, the more of a burden these frameworks become
05:46:58 <kuribas> merijn: my library is basically a fancy bytestring builder, so you can do whatever you need :)
05:47:20 <merijn> kuribas: yeah, yeah, you keep bragging about it but I don't see any package on Hackage :p
05:48:38 <typetetris> Its a bit off topic here, but you guys are so knowledgable: I have a bunch of people telling me, I should never ever use Serializable with postgresql (and deal with the 40001), but I think, thats bs, because some invariants you can only protect with Serializable. Am I wrong? What do you think?
05:49:29 <merijn> EINSUFFICIENTDATA
05:52:36 <hc> typetetris: have you got some more background information?
05:53:00 <typetetris> Simple example: See if row is present, skip work then, otherwise do work and insert row. It is an error if row is present twice. (Could use a unique constraint and try to catch the uniqe constraint error to suffocate the error and continue gracefully. But then you probably do to much work.)
05:59:37 <NewToHaskjell> `generate :: Gen a -> IO a`, Run a generator. The size passed to the generator is always 30; if you want another size then you should explicitly use resize.
05:59:51 <NewToHaskjell> What do they mean with `The size passed to the generator is always 30`
06:00:52 <typetetris> NewToHaskjell: There are generators, which use a size parameter. They are sizable. For example random lists, size sets the distribution of their random length and iirc the size maximum.
06:00:52 <opqdonut> quickcheck generators are parameterized by a "size"
06:01:03 <opqdonut> it can control the length of the list generated, or the size of the number, etc
06:02:38 <NewToHaskjell> opqdonut: `it can control the length of the list generated` okey, how come we can create a list with length greater than 30 with this 
06:02:43 <NewToHaskjell> `randomNumbers n = generate (vectorOf n (choose (1,n)))`
06:02:56 <NewToHaskjell> code taken from one of my course slides.
06:03:24 <opqdonut> well in this case there's an explicit length (`n`), so the size won't affect anything
06:07:37 <NewToHaskjell> Would make more sense if `generate` cut of our list at length 30
06:07:46 <NewToHaskjell> Guess ill read more about it, thanks.
06:08:00 <NewToHaskjell> off*
06:08:19 * hackage wreq-helper 0.1.0.0 - Wreq response process  https://hackage.haskell.org/package/wreq-helper-0.1.0.0 (Lupino)
06:09:31 <typetetris> But it seams both beam and persistent get all columns of a entity every time it is selected? Is there a way to just select specific columns?
06:09:54 <merijn> typetetris: Not with persistent
06:10:14 <AWizzArd> merijn: So, what return type would you specify, if you don't know how many columns and what their types will be?
06:12:42 <typetetris> AWizzArd: Is it really dynamic or is each call site known at compile time? If the second one, maybe you could calculate the return type at compile time?
06:13:45 <L29Ah> is there an IntMap with Word64 as keys?
06:16:24 <merijn> no
06:16:48 <merijn> You could newtype it and do conversion in all the lookups, I suppose
06:18:35 <L29Ah> no i can't as it would drop the bits i need to keep
06:18:47 <merijn> How so?
06:19:16 <polyphem> L29Ah: IntMap of IntMaps ?
06:19:40 <L29Ah> > 444444444444444444444 :: Int
06:19:42 <lambdabot>  1722586675415205660
06:19:45 <L29Ah> > 444444444444444444444 :: Word64
06:19:47 <lambdabot>  1722586675415205660
06:19:54 <L29Ah> :O
06:19:54 <merijn> L29Ah: Owned :p
06:20:03 <merijn> Int is 64bit in GHC
06:20:12 <L29Ah> > (2^64 - 1) :: Word64
06:20:14 <lambdabot>  18446744073709551615
06:20:18 <L29Ah> > (2^64 - 1) :: Int
06:20:20 <lambdabot>  -1
06:20:31 <merijn> > fromIntegral -1 :: Word64
06:20:34 <lambdabot>  error:
06:20:34 <lambdabot>      • Couldn't match expected type ‘Word64’
06:20:34 <lambdabot>                    with actual type ‘Integer -> Integer’
06:20:39 <L29Ah> 16:19:42]<merijn> Int is 64bit in GHC
06:20:40 <L29Ah> that's pure coincidence, as it says "at least 30 bits"
06:20:57 <merijn> L29Ah: Sure, if you care about a hypothetical non-GHC haskell compiler
06:21:02 <L29Ah> ;)
06:21:02 <merijn> But in reality no one uses UHC
06:25:13 <Uniaika> b-b-but what about Intel's? :o
06:26:21 * hackage hasqly-mysql 0.0.1 - composable SQL generation  https://hackage.haskell.org/package/hasqly-mysql-0.0.1 (KristofBastiaensen)
06:26:28 <kuribas> merijn: here you go :-)
06:27:12 <L29Ah> > (fromIntegral (-1 :: Int)) :: Word64
06:27:13 <lambdabot>  18446744073709551615
06:27:31 <L29Ah> ok great
06:28:48 <kuribas> maxBound :: Word64
06:28:57 <kuribas> > maxBound :: Word64
06:28:58 <lambdabot>  18446744073709551615
06:30:32 <kuribas> > maxBound :: Int
06:30:35 <lambdabot>  9223372036854775807
06:30:58 <kuribas> > maxBound :: Int64
06:31:00 <lambdabot>  9223372036854775807
06:31:13 <kuribas> this bound isn't garanteed on Int though
06:36:00 <merijn> Define "guaranteed"
06:36:16 <merijn> By Haskell2010? No, but then again who actually writes Haskell2010?
06:36:33 <merijn> By GHC? Yes, for all reasonable version ranges of GHC.
06:43:30 <dolio> Well, it won't be 64-bit on 32-bit GHC.
06:43:43 <dolio> If anyone still uses that.
06:44:06 <NewToHaskjell> When checking for equality, `threeOrSeven n = n == 3 || n == 7` is it possible to be able to do this somehow `n == 3, 7` or deduce it somehow?
06:44:13 <merijn> dolio: It's 2020, worrying about people using 32bit GHC is like worrying about migration patterns of woolly mammoths
06:44:23 <NewToHaskjell> `elem n [3,7]` is possible but if that isnt the case
06:44:37 <merijn> NewToHaskjell: Not really, no
06:44:38 <dolio> I did check that it's still on the download page.
06:44:45 <merijn> dolio: Yes, but it won't be soon
06:45:35 <merijn> dolio: Ben was asking about "do we really need to put in this effort? some companies keep asking about it, but no one seems to use it and it's constantly broken" and I think I managed to convince him that it should be dropped and if anyone cares they can bloody well pay for it themselves :p
06:45:50 <dolio> Ah, I see.
06:45:53 <merijn> dolio: Also note that that 32bit GHC on windows has been nearly constantly broken and unusable
06:46:12 <dolio> Yeah, the download is only for Linux on the latest version.
06:46:28 <Arahael> Even more pointless, that.
06:46:37 <merijn> dolio: When it's missing people ask about it, then Ben builds it, then it turns out to be broken and no one noticed it for months
06:46:53 <Arahael> merijn: Must've been an enterprise customer.
06:46:53 <merijn> dolio: Which says something about how many people are actually using it :p
06:47:13 <merijn> Arahael: fuck 'em, enterprise is money, they can pay someone to build it for them :p
06:47:21 <Arahael> merijn: Heh - right :)
06:47:39 <merijn> Arahael: Also, if they were using it, they would notice it being broken repeatedly :p
06:48:56 <Arahael> merijn: Unless, it's something in the standup meeting: Hmm, this week we need to build this product in Haskell, for such and such an obscure system.  Estimates?  100 story points!? You nuts!?!?  Lets time box this...  blah blah blah.  Ok, 4 hours.  Sounds good, everybody happy with their COMMITMENTS?"
06:49:16 <Arahael> merijn: Then some poor sap goes and asks for the 32-bit version. :)
07:06:39 <L29Ah> is GHC's Int 64bit on 32bit architectures too?
07:07:11 <dolio> No, that was why I mentioned 32-bit GHC above.
07:07:21 <merijn> Are there even any 32bit architectures still being produced besides embedded ARM chips? :p
07:07:27 <dolio> But there's basically none of those left.
07:08:04 <L29Ah> 16:43:52]<merijn> dolio: It's 2020, worrying about people using 32bit GHC is like worrying about migration patterns of woolly mammoths
07:08:05 <L29Ah> do you have a $0.5 64bit microcontroller on sight?
07:08:07 <kuribas> there's a GHC for arm
07:08:41 <merijn> L29Ah: No, but then again, I think the notion of getting GHC code to run on a 50 cent microcontroller is unrealistic anyway
07:08:41 <dolio> Which microcontrollers run GHC?
07:08:44 <L29Ah> 17:07:00]<merijn> Are there even any 32bit architectures still being produced besides embedded ARM chips? :p
07:08:45 <L29Ah> every intel cpu has one, called Intel ME
07:08:50 * merijn high fives dolio
07:08:59 <L29Ah> 17:08:19]<merijn> L29Ah: No, but then again, I think the notion of getting GHC code to run on a 50 cent microcontroller is unrealistic anyway
07:08:59 <L29Ah> but it runs
07:09:08 <merijn> L29Ah: Does it?
07:09:20 <merijn> L29Ah: I've never seen anyone running GHC compiled code on such a device
07:09:29 <L29Ah> there were a few demos of ghc-compiled code running on stm32 a few years ago
07:09:35 <merijn> And I find it unlikely that you will manage to
07:09:54 <merijn> L29Ah: That's never been a tier 1 platform (hell, not even tier 2 or 3, I think?)
07:10:56 <merijn> Like, we can nitpick about one-of forks someone made from GHC years ago that no one has ever used, but that doesn't seem a realistic or pragmatic way to decide anything about your code :)
07:12:09 <L29Ah> x86 is a tier 1 platform
07:12:43 <L29Ah> // i just don't want to produce incompatible code w/o really good reasons
07:12:57 <merijn> See aforementioned discussion that it will stop being one as of next release and realistically hasn't been used for years :p
07:13:49 <merijn> L29Ah: Use TemplateHaskell + finiteBitSize (https://hackage.haskell.org/package/base-4.14.0.0/docs/Data-Bits.html#v:finiteBitSize) to produce a compile time error if Int is less than 64bit :p
07:13:49 <L29Ah> i've realistically wrote haskell for 32bit windows xp a year ago commercially
07:14:39 <L29Ah> and i won't be surprised if i would encounter x86 systems in 2030 requiring my programming attention
07:14:59 <merijn> sure
07:15:23 <merijn> But if you're writing stuff for yourself, I suggest telling everyone with x86 to either pay or get fucked :p
07:17:25 <typetetris> NewToHaskjell: If you want to obfuscate your code: pointfree.io `liftM2 (||) (3 ==) (7 ==)`
07:17:26 <L29Ah> fair enough
07:17:49 <L29Ah> @unpl liftM2 (||) (3 ==) (7 ==)
07:17:50 <lambdabot> (\ b0 -> return ((3 == b0) || (7 == b0)) b0)
07:18:47 <merijn> L29Ah: Bending over backwards doing unpaid work for hypothetical users that probably don't exist and won't pay/be grateful if they do exists is a good way to get burned out on open source :)
07:19:57 <AWizzArd> typetetris: I generate the sql query at runtime. So the number of columns and their types is only known at runtime.
07:23:18 * hackage elynx-markov 0.3.2 - Simulate molecular sequences along trees  https://hackage.haskell.org/package/elynx-markov-0.3.2 (dschrempf)
07:24:19 * hackage elynx 0.3.2, tlynx 0.3.2, slynx 0.3.2, elynx-tree 0.3.2, elynx-tools 0.3.2, elynx-seq 0.3.2, elynx-nexus 0.3.2 (dschrempf)
07:27:42 <dminuoso> AWizzArd: I think I finally found the proper library.
07:27:45 <dminuoso> https://hackage.haskell.org/package/HaskRel
07:28:14 <dminuoso> :p
07:28:29 <dminuoso> Truth be told, I think what you need is a runtime only HaskRel without the type stuff.
07:28:56 <dminuoso> At least if you want it done right.
07:30:35 <dminuoso> There appear to be some libaries exploring this direction like relational-query
07:36:18 <AWizzArd> dminuoso: will have a look
07:39:20 * hackage mcmc 0.2.2 - Sample from a posterior using Markov chain Monte Carlo  https://hackage.haskell.org/package/mcmc-0.2.2 (dschrempf)
07:42:44 <maerwald> dminuoso: standalone deriving works with existential types.
07:44:00 <dminuoso> maerwald: mmm, interesting. In that case I'd file a bug report, it's perhaps just an oversight?
07:44:22 <maerwald> you mean file a bug report that will break my code? xD
07:44:22 <dminuoso> It could be argued that since ExistentialQuantification is an extension anyway, adherence to the Haskell report with regards to what deriving Show must do does not apply
07:44:35 <dminuoso> Well, Id say deriving Show should just work.
07:46:33 <L29Ah> if i just want forkIO propagating exceptions to the parent thread, should i grab async?
07:46:39 <dminuoso> L29Ah: Yeah.
07:57:33 <merijn> If you don't want to go crazy, yes ;)
07:58:37 <dminuoso> Ive went as far as saying "if I just want forkIO" I use async.
08:03:19 * hackage aws-lambda-haskell-runtime 3.0.4 - Haskell runtime for AWS Lambda  https://hackage.haskell.org/package/aws-lambda-haskell-runtime-3.0.4 (NickSeagull)
08:11:16 <kamek> I found myself using a few `exceptToMaybeT $ ExceptT (thing that returns IO (Either e a))`
08:11:33 <kamek> is that weird ? or awkward, or even an anti pattern somehow
08:27:24 <sol32> Hey guys!
08:27:35 <jumper149> kamek: I personally would prefer something like `eitherToMaybe <$> (thing that returns IO (Either e a))` and define that function myself.
08:32:05 <maerwald> https://hackage.haskell.org/package/errors-2.3.0/docs/Control-Error-Util.html#v:-63--63-
08:32:26 <maerwald> or hushT
08:33:13 <sol65> The Haskell quasiquoter apparently uses static or dynamic scoping for referenced names, depending on whether a referenced name is in scope at the definition site or not (in scope -> static scoping, dynamic scoping otherwise).
08:34:03 <sol65> Does anybody know if there is a way to ensure static scoping?
08:36:36 <L29Ah> lol how do i exit
08:36:46 <L29Ah> https://dpaste.com/6GZ4MQSJP this code doesn't
08:40:58 <glguy> L29Ah: Do you see a Gtk.mainQuit somewhere?
08:42:18 <L29Ah> glguy: i already tried that but it didn't quit, mumbling about gtk_main_quit: assertion 'main_loops != NULL' failed
08:42:46 <glguy> IIRC GTK stuff has to be run on a bound thread
08:43:25 <glguy> I'd wonder if you can use GTK stuff from async-controlled threads
08:43:59 <glguy> I was just looking at how I quit my GTK app : https://github.com/glguy/CookieCalculator/blob/master/gui/Main.hs#L79
08:45:30 <L29Ah> damn exiting on a random exception from another thread turned out to be trickier than i expected
08:46:03 <c_wraith> sol65: are you talking about capturing names from surrounding scopes?
08:55:51 <L29Ah> yay i did it
08:55:54 <L29Ah> (idleAdd (mainQuit >> pure False) priorityHigh) >> exitFailure
09:01:56 <monochrom> I thought postSync and postAsync existed for requesting gtk operations from arbitrary threads.
09:04:10 <monochrom> postGUIAsync and not sure the exact name of the sync one.
09:09:00 <L29Ah> oh yup, postGUIAsync works
09:09:16 <ADG1089_> how to generate .hs-boot file?
09:14:17 <merijn> ADG1089_: One of life's great mysteries
09:14:43 <ADG1089_> *slow claps*
09:19:14 <dminuoso> sol65: Hold on, when is dynamic scoping used?
09:22:13 <monochrom> I thought one hand-writes .hs-boot files.
09:22:37 <monochrom> "generate" is the one that warrants *slow claps*
09:23:53 <merijn> Theoretically you hand write them, yes
09:24:01 <merijn> Although I've never managed to create a correct one
09:24:05 <maerwald> I have
09:24:23 <maerwald> you mechanically follow the GHC user guide
09:28:07 <monochrom> Yikes, it also requires adding a few {-# SOURCE #-} to some *.hs files
09:28:19 * hackage hocker 1.0.6 - Interact with the docker registry and generate nix build instructions  https://hackage.haskell.org/package/hocker-1.0.6 (ParnellSpringmeyer)
09:29:50 <monochrom> Also X.lhs-boot if X.lhs
09:36:04 <ADG1089_> would be easier to extract definitions from .hs -> .hs-boot and then weed the un-needed ones
09:36:12 <monochrom> The GHC user guide doesn't tell you mechanically how. It tells you mechanically when you must write one and what's allowed inside. So I mean for example it doesn't tell you mechanically the minimum you have to put inside the X.hs-boot files.
09:36:19 <ADG1089_> [type definitions]
09:37:07 <monochrom> But I guess if you don't go for minimum, you can use the rules about what's allowed to mechanically trim out what's not allowed and call it a day.
09:38:07 <monochrom> Yes, would be easier if someone else has implemented that tool.
09:38:18 <monochrom> May I tell you an Aesop fable?
09:39:13 <ADG1089_> yes would be easier to regexp match on type definition from CFG specification
09:40:35 <ADG1089_> something like '\w+\s*::\s*(\((\w+ \w+,?)+\)\s*=>)?\w+(->\w+)*'
09:41:06 <ADG1089_> s/\w+/[A-Z][a-z0-9A-Z]*/
10:00:11 <maerwald> monochrom: after I did something correctly once, I keept it in my "did it correctly once"-memory. That's usually empty anyway, so
10:00:36 <maerwald> either because I forgot what I did or because yeah...
10:01:00 <maerwald> https://github.com/hasufell/hsfm/blob/master/src/HSFM/GUI/Gtk/Callbacks.hs-boot#L25
10:01:36 <monochrom> Achievement unlocked: M.hs-boot accepted by compiler. :)
10:02:24 <maerwald> https://github.com/hasufell/hsfm/blob/master/src/HSFM/GUI/Gtk/MyView.hs#L60
10:02:30 <maerwald> and the caller uses SOURCE 
10:02:33 <maerwald> not much more
10:03:02 <ph88> does someone have an example of how to use Web.Authenticate.OAuth ?
10:03:15 <monochrom> Oh, yours was minimum alright.
10:03:27 <ph88> i'm not sure how i can specify the server address
10:03:47 <sol65> c_wraith: yes, say e.g. [|foo|] will be dynamically scoped, depending on whether `foo` is in scope or not
10:04:16 <sol65> dminuoso: ^ like so
10:04:18 <maerwald> it's basically like inlining no?
10:08:01 <maerwald> the boot file marks what's to be written to the interface files, and the SOURCE pulls it in from there (at least I guess that's what happens)
10:10:09 <c_wraith> sol65: I think calling that "dynamic scoping" is a bit misleading, though I do see where that's coming from.
10:10:35 <sol65> Huh?
10:11:04 <c_wraith> it's generating statically scoped code.   it's just using a unbound name.
10:11:20 <sol65> Well, yes, of course.
10:12:07 <sol65> The name in the TH splice is dynamically scoped.
10:12:11 <c_wraith> anyway, I presume you ran into a case where something was unbound and accidentally captured a name in scope where it was spliced leading to something that compiled but was totally wrong?
10:13:08 <sol65> I'm not concerned about what happened to me.
10:14:19 <c_wraith> i am
10:14:54 <c_wraith> because the answer to your original question is "no, you can't turn that off"
10:15:28 <c_wraith> so the new question is "what other potential solutions are there for the problem you ran into?"
10:15:40 <sol65> I don't think there are any
10:15:43 <monochrom> "dynamic" is a bit of a poor wording, since this is all compile time. The Scheme people thought up "hygienic" vs not hygenic for this.
10:16:12 <c_wraith> I mean, we can't tell unless you tell us what the actual problem is
10:16:21 <sol65> Except for not using the Haskell qq and constructing the TH manually, I guess.
10:17:02 <c_wraith> what about a filter that rejects any generated TH with an UnboundVar constructor in it?
10:17:07 <sol65> Ok, here is the problem.  You write some TH code.  It uses some Prelude function that is not inscope at the TH definition site.
10:17:17 <sol65> Now, the TH will still work for most people
10:17:27 <sol65> But it is technically broken
10:17:32 <c_wraith> err, UnboundVarE?
10:17:35 <sol65> E.g. if you use a custom Prelude
10:18:38 <c_wraith> that seems easier than generating Q Exp values from constructors alone.
10:19:04 <sol65> What exactly do you mean?
10:21:07 * ski . o O ( "Dirty Looking Hygiene" by Eli Barzilay in 2008-02-23 at <https://blog.racket-lang.org/2008/02/dirty-looking-hygiene.html> )
10:21:14 <c_wraith> something like a function Q Exp -> Q Exp that throws a compile error if the generated Exp contains any unbound variables, then generate a compile error. otherwise pass it along. add that filter to the start of your splice generating functions.
10:22:07 <c_wraith> heh, lost track in the middle of that sentence but at least I only got redundant
10:22:24 <sol65> That could actually work
10:23:01 <c_wraith> see what we can do when asked about the actual problem? :P
10:24:35 <monochrom> ski: Nice, I forgot that "capture" is a standard word for this.
10:25:28 <sol65> c_wraith: One issue is, if you unquote and explicitly splice in a "capturable name" (using the terminology used in the docs), the it will still fail at compile time.
10:25:41 <monochrom> Perhaps dynamic scoping is a special case of variable capture.
10:26:22 <sol65> It's common to have a mix of "capturable" and "statically bound" names
10:27:32 <sol65> I would still argue that "capture" is the exception, unless you treat TH as a sort of macro expansion system.
10:27:52 <sol65> What I mean is that you want to have strict control over when capturing happens
10:28:18 <sol65> Controlling it through the import list is not particularly explicit.
10:28:31 <c_wraith> sol65: does that not generate UnboundVarE constructors? I didn't mean apply it only to quotes. I mean applying it to the whole generated value 
10:29:14 <monochrom> I am still not entirely happy with the standard wordings: dynamic, static, capture, hygienic.  Because in the process of explaining these to students, I found that the point comes down to: the name refers to what's known at definition site vs at use site.
10:29:43 <monochrom> So I view it as def-site-scope vs use-site-scope.
10:30:43 <sol65> c_wraith: That is how I understood you.  That would prevent any capturing, no?
10:31:14 <sol65> Say as an example [|foo $(reifySomeVars)|].
10:32:03 <sol65> ^ here I would want to ensure that `foo` is not "capturable" while `reifySomeVars` might contain free variables
10:32:51 <sol65> ^ dynamically scoped variables (not sure if free variables is a good way to put it neither)
10:33:37 <sol65> monochrom: I think def-site-scope vs use-site-scope makes sense
10:33:41 <ph88> which library can i use to ask users questions on the command line?
10:34:12 <sol65> monochrom: This is how I tend to use "static" and "dynamic" scoping.
10:41:09 <frdg> Lately I have realized that ?every? list processing function can be written as a foldr. I love folding.
10:41:23 <monochrom> A lot can be.
10:42:17 <monochrom> A lot more are just one step away, e.g., a helper that adds one simple field is a foldr.
10:43:17 <frdg> ya its simple and concise.
10:44:00 <monochrom> See Ralf Hinze's "adjoint folds and unfolds" for a large class like that, tldr an adjoint functor away from foldr.
10:45:08 <frdg> I will
10:45:21 <monochrom> For the utmost generality, for every function there exists an intermediate data type such that the function equals (extensional) unfold to that intermediate data type and then fold that.
10:46:34 <monochrom> Also utmost useless haha. The proof is has nonconstructive parts for the existence of that unknown intermediate data type, it doesn't tell you how to design it.
10:46:52 <frdg> `for every function`. thats gotta be a useful concept.
10:47:03 <frdg> oh
10:55:01 <dgpratt> I know next to nothing about such things as proofs, so I guess it's not surprising that I can't really understand how one can prove the existence of something without explaining how to construct it or where to find it.
11:00:11 <merijn> dgpratt: "there are infinitely many primes" OR "there are finitely many primes", proof that the second cannot be true, conclude that the former must be, without having an actual way to construct those infinitely many primes
11:00:29 <c_wraith> sol65: oh, I see. well, you could pass in a list of names to allow to be unbound, I suppose. that's less friendly, but still usable.
11:00:32 <merijn> dgpratt: Construct logic says "nuh-uh, not good enough, show me a way to actually generate infinitely many"
11:01:43 <dgpratt> interesting, thanks merijn
11:01:56 <merijn> sol65: There's a TH method for generating unique unbound names (although I don't remember which)
11:07:05 <sol65> c_wraith: That won't work, in my case the list of of variables that is allowed to be unbound is unknown.
11:07:08 <dolio> I don't think it's very difficult to give a constructive proof, given the setting allows you to unfold and fold the same data type.
11:07:18 <dolio> You can just use list.
11:07:20 <zincy_> Anyone here interested in differentiable programming?
11:07:51 <sol65> merijn: How would that help with that specific problem?
11:16:41 <alm59> Is there any idiomatic typeclass to express higher-arity folds?
11:17:23 <alm59> For example, one could fold over a binary tree with a function like `foldTree :: (a -> b -> b -> b) -> b -> Tree a -> b`
11:18:23 <alm59> This doesn't fit neatly into `Foldable`, but I'm sure that this pattern occurs a lot
11:23:37 <L29Ah> % data A = A {a::Int}
11:23:38 <yahb> L29Ah: 
11:23:47 <L29Ah> % data B = B {a::Int}
11:23:48 <yahb> L29Ah: 
11:23:54 <L29Ah> % instance Eq A where; (==) = on (==) a
11:23:55 <yahb> L29Ah: ; <interactive>:3:29: error:; * Couldn't match type `A' with `B'; Expected type: A -> A -> Bool; Actual type: B -> B -> Bool; * In the expression: on (==) a; In an equation for `==': (==) = on (==) a; In the instance declaration for `Eq A'
11:23:58 <hyperisco> alm59, maybe recursion schemes
11:24:02 <L29Ah> what am i doing wrong?
11:24:39 <jle`> L29Ah: 'a :: B -> Int'
11:24:51 <hyperisco> what happens to  a :: A -> Int
11:24:51 <jle`> the second time you define 'a', it shadows the original time
11:24:58 <jle`> it is shadowed
11:25:03 <jle`> % mything = 3
11:25:03 <yahb> jle`: 
11:25:05 <jle`> % mything = 10
11:25:05 <yahb> jle`: 
11:25:07 <jle`> % mything
11:25:07 <yahb> jle`: 10
11:25:11 <L29Ah> % :set -XDuplicateRecordFields
11:25:11 <yahb> L29Ah: 
11:25:11 <hyperisco> there is a GHC extension to make it ambiguous right?
11:25:18 <L29Ah> % data A = A {a::Int}
11:25:19 <yahb> L29Ah: 
11:25:21 <L29Ah> % data B = B {a::Int}
11:25:22 <yahb> L29Ah: 
11:25:25 <L29Ah> % :t a
11:25:25 <yahb> L29Ah: ; <interactive>:1:1: error:; Ambiguous occurrence `a'; It could refer to; either `interactive:Ghci5.a', defined at <interactive>:2:13; or the field `a', defined at <interactive>:8:13; or the field `a', defined at <interactive>:9:13
11:25:30 <L29Ah> great
11:25:34 <jle`> there ya go
11:25:34 <L29Ah> % instance Eq A where; (==) = on (==) a
11:25:35 <yahb> L29Ah: ; <interactive>:11:37: error:; Ambiguous occurrence `a'; It could refer to; either `interactive:Ghci5.a', defined at <interactive>:2:13; or the field `a', defined at <interactive>:8:13; or the field `a', defined at <interactive>:9:13
11:25:39 <L29Ah> not so great
11:25:46 <hyperisco> you have to annotate it with the type you want
11:25:48 <L29Ah> why doesn't it infer it correctly?
11:25:52 <hyperisco> it doesn't do inference
11:25:53 <L29Ah> hyperisco: it is annotated
11:25:59 <hyperisco> you have to annotate  a
11:26:00 <jle`> i don't think that is how type inference works
11:26:03 <L29Ah> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#record-field-disambiguation tells me that it does
11:26:07 <jle`> :O
11:26:19 <hyperisco> well my knowledge may be a few years old
11:26:23 <jle`> oh, it only works in record syntax
11:26:32 <jle`> remember type inference really only does concrete types or typeclasses
11:26:43 <jle`> here you are using it as a value (function)
11:26:49 <jle`> so it is under the mercy of type inference
11:27:11 <jle`> in the documentation it is being used strictly as record syntax
11:27:26 <L29Ah> ok so there's no way to have two types with the same record name w/o having to forego using such record fields as functions, amirite?
11:27:27 <jle`> remember that in `MyType { myField = ... }`, myField is not a function
11:27:29 <hyperisco> I think that it is saying, L29Ah, is it can only infer the type in specific contexts
11:27:38 <hyperisco> L29Ah, one of the is if you just annotate it
11:27:42 <jle`> it never does any actual 'inferrence'
11:27:48 <L29Ah> hyperisco: what do you mean "annotate"?
11:27:56 <hyperisco> (a :: A -> Int)
11:28:00 <jle`> yeah, it can never do any inference on functions, even with annotations
11:28:07 <L29Ah> but it can figure it out by itself
11:28:15 <jle`> L29Ah: right, if you have duplicate record fields, you have duplicate 'record fields', not duplicate accessor functions
11:28:26 <hyperisco> % instance Eq A where; (==) = on (==) (a :: A -> Int)
11:28:26 <yahb> hyperisco: 
11:28:29 <L29Ah> % instance Eq A where; (==) = on (==) (a :: A -> Int)
11:28:29 <yahb> L29Ah: 
11:28:32 <jle`> oh :O
11:28:34 <jle`> i do'nt know anything
11:28:47 <L29Ah> dumb ghc :(
11:28:50 <jle`> ah i was looking at -XAmbiguousRecordFields
11:28:55 * L29Ah is sold to rust fanbois
11:29:00 <hyperisco> L29Ah, it is on the roadmap
11:29:13 <jle`> this is very unsettling to me
11:29:21 <hyperisco> records in Haskell are a disasterscape, no worries
11:30:08 <jle`> it feels like an ad-hoc syntax thing that is outside of normal type annotations/type signatures that direct type inference
11:30:22 <hyperisco> % :set -XDisambiguateRecordFields
11:30:22 <yahb> hyperisco: 
11:30:28 <hyperisco> % instance Eq A where; (==) = on (==) a
11:30:28 <yahb> hyperisco: ; <interactive>:15:37: error:; Ambiguous occurrence `a'; It could refer to; either `interactive:Ghci5.a', defined at <interactive>:2:13; or the field `a', defined at <interactive>:8:13; or the field `a', defined at <interactive>:9:13
11:30:47 <hyperisco> still not smart enough, oh well… last I looked it was being planned
11:31:12 <L29Ah> can you link to the issue tracker or smth?
11:31:19 <hyperisco> no I don't have it on me, sorry
11:31:36 <c_wraith> eh. if you're willing to use libraries and a bit of extra syntax, I find -XDuplicateRecordFields and generic-lens to be a fine way to handle records 
11:32:06 <L29Ah> c_wraith: can you show us how lens handle the Eq example?
11:32:20 * hackage musicw 0.3.5.1 - Sound synthesis library, to be used with GHCJS and Web Audio API  https://hackage.haskell.org/package/musicw-0.3.5.1 (dktr0)
11:32:53 <jle`> i like duplicate record fields and generic-lens for using dupliate record fields
11:33:00 <hyperisco> L29Ah, personally I put every type in its own module (and one module per file) and import it qualified
11:33:13 <hyperisco> L29Ah, that way I can say  A.a  and  B.a  unambiguously
11:33:16 <jle`> but it's just using them as record functions that seems a bit odd
11:33:29 <jle`> L29Ah: yeah, generic-lens gives you things like myType ^. #a
11:33:35 <jle`> and that would work for both A and B
11:33:38 <jle`> * myValue
11:33:54 <jle`> instance Eq a where (==) = (==) `on` view #a
11:34:06 <hyperisco> I wonder what the compile time inflation on that is lol
11:34:17 <jle`> so basically you'd replace the act of using the record accessing fuction with `view #a`, or `view #myrecord`
11:34:20 <jle`> * #myfield
11:34:49 <c_wraith> hyperisco: less than using TH
11:35:50 <jle`> and i think using `view #a`, etc, is a pretty principled way to do it.  because 'a' doesn't come from a function binding itself, it's just a stringy label, so there's no inherent "home" type
11:35:51 <hyperisco> if  a  is still a duplicate record field, how does lens change the problem
11:36:04 <jle`> hyperisco: view #a
11:36:07 <L29Ah> https://gitlab.haskell.org/ghc/ghc/-/wikis/records/overloaded-record-fields/overloaded-labels wow what a kludge
11:36:16 <hyperisco> I am assuming here  #  is a function as is  view
11:36:25 <jle`> no, it's -XOverloadedLabels
11:36:28 <c_wraith> nope. # is syntax
11:36:32 <jle`> it's the #a label
11:36:39 <hyperisco> that is a new one for me
11:36:54 <jle`> you can kind of think of it like :mysymbol if you're familiar with ruby, kinda
11:37:09 <jle`> syntax for a special type of string
11:37:15 <jle`> literal
11:37:36 <L29Ah> now https://gitlab.haskell.org/ghc/ghc/-/wikis/records/overloaded-record-fields seems like it was tailored for lens and is not supposed to be used w/o them :/
11:38:01 <c_wraith> it's actually really awkward to use with lens.
11:38:10 <c_wraith> overloaded labels are way more convenient
11:38:18 <hyperisco> who has the responsibility for generating the meta data for the record type? I am presuming there is some type class machinery for projecting the  a  field, which would necessitate knowing the names of fields on records
11:38:20 <L29Ah> overloaded labels is a part of it
11:38:25 <jle`> hyperisco: GHC Generics
11:38:42 <hyperisco> okay, gotcha
11:38:44 <jle`> data A = { a :: Int} deriving Generic
11:39:00 <hyperisco> so you're paying for generics and instance resolution but not the end of the world
11:39:18 <c_wraith> like I said, cheaper than TH
11:39:18 <hyperisco> times a few thousand over a program I dunno though… someone can find out ^.^
11:39:33 <merijn> c_wraith: Define cheaper :p
11:39:44 <c_wraith> less added compilation time.
11:39:49 <merijn> TH is costly in compile time, but zero overhead at runtime
11:40:23 <hyperisco> yeah I am only talking about compile time but I could imagine this lens approach may obscure some optimisations… maybe not
11:40:58 <hyperisco> not sure how aggressively GHC specialises classes
11:41:12 <c_wraith> lenses pretty much compile away when all the parts are statically known.
11:41:45 <c_wraith> at least in the simple cases that would compile well without them.
11:43:11 <L29Ah> % instance Eq A where; (==) = on (==) (a @A)
11:43:11 <yahb> L29Ah: ; <interactive>:16:38: error:; Ambiguous occurrence `a'; It could refer to; either `interactive:Ghci5.a', defined at <interactive>:2:13; or the field `a', defined at <interactive>:8:13; or the field `a', defined at <interactive>:9:13
11:43:17 <L29Ah> stupid, stupid ghc
11:43:28 <jle`> yeah you have to pretty much treat any usage of a as a function as special syntax
11:43:36 <jle`> it doesn't have a type signature
11:43:44 <jle`> so it doesn't make sense to apply @A to it
11:44:24 <jle`> in order for type applications to work, it has to actually have a type signature ;)
11:44:25 <dolio> Is it really necessary to keep spamming the channel with random test cases?
11:44:46 <jle`> er, s/type signature/type
11:46:48 <hyperisco> if the type system had unions then  a :: A | B -> Int  right
11:47:29 <jle`> i don't think you could really say that's the type, because that would mean its type is different in every module you use it in
11:47:33 <jle`> depending on what records were in scope
11:47:50 <dolio> Also it is a coincidence that the return types are the same.
11:48:14 <hyperisco> same as  (A -> Int) & (B -> Int)
11:49:29 <hyperisco> jle`, I suppose that is strange but I don't think wrong?
11:49:52 <jle`> it doesn't have a well defined type, the same way other values have types in haskell
11:50:28 <jle`> the same thing shouldn't have different types depending on what module you're using it in D:
11:51:15 <hyperisco> how are you determining "the same thing"
11:51:31 <jle`> for example if i import 'return' in two different modules
11:51:37 <jle`> it will always have the type return :: Monad m => a -> m a
11:52:10 <jle`> but your proposed type for 'a' depends on what other records are in scope
11:52:20 <jle`> in another module you could have defined data C = { a :: Int }, and so the type would change
11:52:22 <hyperisco> Control.Monad.return or whatever always has the same type, this only applies to unqualified names
11:53:09 <jle`> hm, on that level then i guess you could say that the identifier 'a' doesn't correspond to any value
11:53:21 <jle`> and so because it doesn't correspond to a value, it doesn't have a type
11:53:38 <jle`> since types are things that are associated with values
11:53:40 <hyperisco> that is more like the current dilemma isn't it?
11:53:53 <jle`> i am trying to describe the current dilemma
11:53:57 <hyperisco> I am saying it is a value and what the type is, and yes it is scope dependent
11:54:18 <jle`> i'm trying to explain why 'a @A' wouldn't work
11:54:39 <jle`> because type applications would only work on things that have types, but since a doesn't correspond to any value, it doesn't have a type
11:54:41 <hyperisco> and one could argue that is a good or bad thing, but that is what we're talking about wanting ultimately if we don't like telling GHC which  a  we mean, so explicitly
11:54:54 <jle`> ah, i am only talking from a descriptive perspective
11:55:19 <jle`> i don't have any strong opinions on how things should be
11:57:41 <hyperisco> I am not overly fond of the idea
12:13:19 <dminuoso> Why is -split-sections useful at all? I'd assume that if I ran `strip --strip-unneeded` over the resulting binary, I'd get the same effect.
12:25:27 <merijn> dminuoso: Because whether strip-unneeded can actually do anything at all is rather dependent on the executable format, linker, etc.
12:26:37 <merijn> dminuoso: Also, strip-unneeded only works on fully linked executables, not on libraries
12:27:41 <merijn> dminuoso: I don't understand why you would even consider the two interchangeable as they do entirely different things
12:28:19 * hackage byte-count-reader 0.10.1.1 - Read strings describing a number of bytes like 2Kb and 0.5 MiB  https://hackage.haskell.org/package/byte-count-reader-0.10.1.1 (danielrolls)
12:28:41 <merijn> dminuoso: It's like asking "why does cp exist when I can just do "cat oldfile >newfile"
12:29:01 <dminuoso> merijn: If my question was "how do I get my files smaller", why does -split-sections help?
12:29:13 <maerwald> cat lacks recursive copy :p
12:29:51 <monochrom> cp also has link-don't-copy modes
12:29:57 <maerwald> hmm, might be fun implementing that with cat and only POSIX sh
12:30:00 <dminuoso> Now, the answer to that question would be "add -split-sections and strip the resulting binary".
12:30:12 <dminuoso> I think it's fair to ask "why do I need split sections" at all?
12:30:42 <monochrom> cp has -i "do you really want to overwrite existing file?".
12:30:45 <dminuoso> They cant do entirely different things, if both result in smaller binaries.
12:30:49 <maerwald> dminuoso: I don't think you get the same effect with strip
12:31:08 <merijn> dminuoso: If you have just an executable than the answer is "you might not need split-sections", but even then it probably helps, transitively
12:31:12 <Chousuke> maerwald: but can you get cp to do recursion such that it starts catting copying the start of the output onto the end of the output :-)
12:31:13 <dminuoso> You get a smaller file with both. Both seem to have an effect of "excluding unneeded stuff".
12:31:38 <Chousuke> you can do that with shell redirects by accident
12:31:46 <monochrom> split-sections helps but you have to use it when building the libraries that your exe will eventually transitively depend on
12:31:51 <merijn> dminuoso: -split-sections puts every symbol into it's own section, letting the linker only link "what's necessary" from your Haskell dependencies, resulting in smaller build files, yes
12:32:04 <merijn> dminuoso: More importantly, that reduction is transitive as it happens in every intermediate step
12:32:11 <dolio> If GHC puts everything in a single section, can strip remove anything?
12:32:15 <dminuoso> merijn: Oh Im fairly sure I do. Without any treatment my executable is about 57MiB large. Stripping brings it down to about 25MiB. Only split-sections to about 10MiB. Combined I get an executable at about 3MiB.
12:32:16 <monochrom> If you say "turn on split-sections for building the exe" the ship has sailed.
12:32:37 <merijn> monochrom: I meant transitively, of course
12:32:48 <merijn> monochrom: Which is what cabal does, afaik
12:32:48 <monochrom> OK cool we're on the same page.
12:33:03 <dminuoso> monochrom: sure I understand that part. Im setting it globally as a cabal setting.
12:33:07 <monochrom> Then again I guess cabal v2 rebuilds everything anyway.
12:33:12 <dminuoso> it does not
12:33:19 <merijn> It does if the config changes
12:33:19 <dminuoso> well, you have to set it as a global cabal option
12:33:27 <merijn> Which includes setting split sections :p
12:33:33 <dminuoso> sadly passing `--enable-split-sections` doesnt apply to dependnecies
12:33:35 <dminuoso> sadly
12:33:39 <dminuoso> (is this a bug?)
12:33:41 <monochrom> I have it in $HOME/.cabal/config too.
12:33:49 <merijn> dminuoso: It does if you set it in your cabal.project :p
12:33:51 <merijn> monochrom: Same
12:33:51 <monochrom> Are you use we aren't the same person? :)
12:34:19 <dminuoso> merijn: Uh. Is it possible the cabal.project is functionally equivalent to the global config?
12:34:31 <merijn> dminuoso: -split-sections produces more fine-grained sections, letting the linker link less, and thus reduce space
12:34:36 <dminuoso> mmm
12:34:49 <monochrom> I think it's global config + cabal.project + cabal.project.local with some appropriate precedence rules.
12:34:58 <dminuoso> okay that makes sense
12:35:01 <merijn> dminuoso: strip carves out unused/unlinked or finished relocations, which also reduces the size, yes
12:35:40 <merijn> dminuoso: The difference is that you can't really sensibly strip, say, a .so
12:35:56 <monochrom> split-objs is older and compatible with both unix and windows. split-sections is newer and linux only or unix only
12:35:59 <merijn> dminuoso: Whereas using split-sections *can* shrink the .so size by simply not including stuff
12:36:08 <dminuoso> Sure, but if you take the final executable, naively I'd say "you can see what symbols are needed and which one can not"
12:36:24 <monochrom> For some weird reason split-sections gives linkers an easier time with pretty much same outcome
12:36:31 <dminuoso> That is, how can there be unneeded stuff that strip-unneeded cant spot?
12:36:49 <merijn> dminuoso: Right, but if one of the so you link has a massive section, due to not having split-sections, strip can't necessarily get rid of that section and also can't rip out the unused bits
12:36:56 <monochrom> But really savvy people used to turn on split-objs and let the linker work harder
12:37:15 <merijn> dminuoso: strip works at the symbol level, if you have symbols the cover bloated sections, strip can't strip them (because they're used)
12:37:33 <dminuoso> What is a bloated section?
12:37:59 <merijn> dminuoso: lots of code that your application doesn't end up using, but is transitively included
12:38:23 <merijn> Anyway, I'm only half sure, because the ELF format is a complicated freaking mess :p
12:39:30 <maerwald> understanding linkers is THE autism test
12:47:32 <hyperisco> isn't it something that should really be rather simple
12:47:42 <merijn> hyperisco: What? ELF?
12:47:43 <dminuoso> You mean like build systems? ;)
12:47:48 <merijn> hyperisco: ahahahahahahahahaha
12:47:49 <hyperisco> linking
12:48:06 <merijn> hyperisco: Clearly you have never looked into the Lovecraftian horror that is linkers
12:48:12 <merijn> Or binary formats
12:48:18 <hyperisco> you're right
12:48:31 <merijn> Enough to drive a grown man insane and mumbling to himself :p
12:48:32 <hyperisco> but I am saying *should*
12:48:41 <merijn> hyperisco: Sure, in theory
12:48:51 <merijn> hyperisco: But then programmers gotta ruin everything again, like always
12:48:58 <merijn> Damn those programmers *shakes fist*
12:49:25 <Chousuke> linking sounds like one of those things that's probably simple at first, and then you hit all the corner cases, and then you gotta make it fast too
12:49:32 <merijn> maerwald: I'm really sad, I've become the person that people at work go to when they have linker issues...I never wanted to be that person :(
12:49:42 <merijn> Chousuke: And people want LTO
12:50:47 <Chousuke> merijn: so it literally has to make it fast :P
12:52:02 <hyperisco> I like to think programmers are helpless corner-finders
12:52:10 <hyperisco> I mean look at how they draw circles
12:52:50 * hackage katip 0.8.5.0 - A structured logging framework.  https://hackage.haskell.org/package/katip-0.8.5.0 (MichaelXavier)
12:52:52 <hekkaidekapus> merijn: Recently, Fedora enabled LTO for the whole distro (rawhide), there were failures everywhere, and a SINGLE person took on himself to fix hundreds of packages. Other packagers were like: “Hey Jeff, I have a failure too.” And Jeff: “Sure, will fix it.” It was amazing and sad at the same time.
12:54:26 <maerwald> merijn: I'll call you rainman from now on...
12:59:43 <maerwald> hekkaidekapus: lol, I've been there when LibreSSL was added to gentoo... good way to get both burnout and flamewar at the same time for trying to help :D
13:00:14 <maerwald> never work on distros
13:01:09 <hekkaidekapus> maerwald: Being the local expert distro-wise is really a thing of beauty and a nightmare.
13:01:32 <hekkaidekapus> Are you still the LibreSSL go-to-guy?
13:02:02 <maerwald> I don't use gentoo anymore, lolo
13:02:54 <maerwald> and in haskell, they're selling you nix anyway
13:02:54 <hekkaidekapus> hah, what the evolution path from an ex-gentoo-ist? Linux from scratch?
13:03:07 <maerwald> hekkaidekapus: exherbo
13:03:27 <hekkaidekapus> heh!
13:03:35 <monochrom> I am the goto person when my colleagues need help with C types like  (int (*)(double)) (*fptr)(int (*)(double))
13:04:08 <merijn> monochrom: Pretty sure that's not legal :p
13:04:22 <merijn> oh wait
13:04:25 <monochrom> haha
13:04:29 <merijn> I stand corrected
13:04:29 <dolio> Do you tell them to not use C? :þ
13:04:41 <hekkaidekapus> monochrom: That type has an ATS vibe.
13:04:50 <merijn> monochrom: I mispared the parentheses :p
13:04:57 <monochrom> Yes, but they like performance and low level.
13:05:06 <maerwald> it looks like clojure
13:05:21 <maerwald> it might actually compile in clojure!
13:05:25 <merijn> monochrom: THat doesn't sound like C :p
13:05:37 <merijn> monochrom: If they *actually* liked performance they'd be using FORTRAN
13:05:38 <monochrom> This probably shows that in the limit you need a Haskell person to keep calm and CFG the hell out of the nested structure to see what C can really do.
13:05:57 <monochrom> I and a FORTRAN-loving colleague told them too!
13:06:16 <dolio> They like to lie to themselves. :)
13:06:42 <monochrom> I don't argue. You like what you like.
13:07:01 <monochrom> What I can do is I trump you right in what you like.
13:07:03 <dminuoso> merijn: here's another of these ioctl crazy. variable length struct (with empty array at the end and a length field) and a subcmd field. To figure out the length, you send the respective subcmd but set the length field to 0. On return, a negative length indicates how large the kernel expects the field to be. If the kernel overwrites the subcmd field to 0, it's an error. You then have to resend the
13:07:06 <dminuoso> same ioctl, but setting the length to the inverted length you have gotten back.
13:07:23 <dminuoso> And if you try to be smart and just "specify the max length the struct could possibly have", the ioctl will just error out.
13:07:29 <monochrom> If I like Haskell more but I can still beat you at C, that's more triumphant.
13:07:32 <dminuoso> It forces you into this idiotic pattern with full force.
13:07:59 <merijn> Simple rule of thumb: If it's an ioctl, it's dumb. If it's a linux only ioctl you can assume it's even dumber
13:08:20 <monochrom> w00t I loved that char extensions[0] trick too!
13:08:21 <dminuoso> The weird thing is, ioctl dont have to be bad...
13:08:39 <dminuoso> It's like only a select few people designed them, and they were hired straight out of the zoo.
13:09:33 <hekkaidekapus> maerwald: By the way, one day I will come on the ghcup bug tracker and pester you about Dhall. There was some contributor who made an attempt but gave up. That 1k lines of YAML with gazillion repetitions need some refactor.
13:10:10 <maerwald> hekkaidekapus: you need a very strong argument
13:10:39 <hekkaidekapus> Yeah, I’m shaping up my dialectics :P
13:11:11 <maerwald> that file is not there to look pretty or concise, but have minimal entry barrier... you just need to know how to operate an editor and so search-replace
13:11:19 <maerwald> sometimes elegance is a waste of time
13:13:02 <hekkaidekapus> Small .dhall files stored in directories like 8.10.1/linux.dhall or freebsd/8.8.3.dhall do not seem to be a barrier.
13:13:22 <maerwald> now you have to learn dhall, just to add a version to ghcup
13:13:24 <maerwald> why
13:13:26 <hekkaidekapus> But I’m not up to snuff, argument-wise. It will wait.
13:14:16 <hekkaidekapus> maerwald: Naaa, today is not the day. I will just shut up.
13:14:27 <maerwald> I'm interested in arguments :p
13:15:11 <hekkaidekapus> Yeah, I took a cursory look, I haven’t had time to look at the rest of ghcup code.
13:15:25 <maerwald> an evolving format would be a reason to switch to something more expressive... bet it isn't really evolving much
13:15:42 <hekkaidekapus> Just cheers and chill!
13:15:55 <ezzieyguywuf> I could use some advice: I've been struggling with this for a few days and can't figure out a good approach. I'd like to update "wireEdges" to call both "forwardWire" _and_ "backwardWire", where the only difference between the two is line 217, which would contain `In a'` for "backwardWire". I tried to refactor things around such that "forwardWire" could be, say, "traverseWire :: (a -> Adjacency a -> 
13:16:01 <ezzieyguywuf> Maybe a)", but I couldn't find a way to make the compiler happy with this approach. https://gitlab.com/ezzieyguywuf/mycad/-/blob/makeFace/Topology/src/Topology.hs#L211
13:16:14 <ezzieyguywuf> hrm, if that's too dense/broad I can try to find a way to distill this into a simpler problem.
13:18:46 <hseg> Suggestions for improvement on http://ix.io/2usT ?
13:21:10 <ph88> hseg, make it more descriptive
13:21:33 <hseg> http://ix.io/2usW ?
13:23:28 <maerwald> hseg: make the top level function pointfree (at least th y) so it inlines better
13:24:14 <hseg> ok, so replace it with go . ((,) 0) ?
13:24:31 <maerwald> or TupleSections
13:24:36 <hseg> sure
13:25:22 <hseg> will the fact that the recursion happens under a maybe break the tail recursion?
13:25:33 <koz_> hseg: It doesn't matter in Haskell.
13:25:40 <hseg> oh?
13:25:43 <monochrom> I'm looking up dhall and seeing "think of as JSON+functions+types+imports".  I thought typescript already existed for that.
13:25:49 <koz_> Laziness something-something.
13:26:08 <maerwald> also, I'd force the accumulator
13:26:13 <koz_> monochrom: Truthfully, I have never understood Dhall. Every time I tried to use it, it seemed ... I dunno, not the right kind of expressive?
13:26:17 <hseg> yeah, just realized i need that
13:26:48 <maerwald> monochrom: it isn't turing complete I think
13:27:11 <maerwald> that's the main point
13:27:15 <monochrom> Ah OK!
13:27:18 <hseg> so this will do the equivalent of a C while (s != Nothing) { divide ... } ? 
13:27:36 <hseg> or will it do a bunch of jumps?
13:27:47 <hseg> s/a bunch of jumps/a bunch of funcalls/
13:27:56 <maerwald> hseg: maybe look at the core/asm
13:28:15 <monochrom> Yeah looks like functions can only do string interpolations like "hardcoded part ${variable part}"
13:29:19 <hexagoxel> ezzieyguywuf: on a glance that sounds like the right approach. what exactly did you try, and what did the compiler complain about?
13:29:19 <merijn> monochrom: dhall is like "what if json, but invented by a Haskeller who likes programming language theory?" ;)
13:29:56 <koz_> merijn: Something something never has the question been asked something something.
13:30:21 <maerwald> config formats should be foremost accessible, imo, and then correct
13:31:07 <maerwald> I don't really mind if my wm config crashes during start of the wm or when it's transpiled to something else
13:31:31 <maerwald> I just want it to crash eventually
13:32:38 <merijn> maerwald: It depends, for end user programs sure, but look at the convoluted yaml messes that CI, cloud services, etc. produce
13:32:54 <merijn> maerwald: Something more systematic and correct is rather helpful there
13:33:05 <monochrom> I have met dhall for just 2 minutes so my opinion below may be flawed. A lot of real config files in the unix world already contains string interpolations, even require you to use string interpolations in practice. So I think dhall isn't adding that, it's cleaning up that.
13:33:14 <maerwald> also, for my use case... dhall will never have enough expressivity to test all the properties I care about. I will need a linter either way
13:33:40 <merijn> monochrom: One of the coolest things is the semantic hashing
13:34:02 <merijn> monochrom: So if you change the functions/logic/layout/whatever the hash remains the same iff the behaviour remains the same :>
13:34:11 <hekkaidekapus> Yep, semantic hashing is great!
13:34:26 <koz_> Huh, TIL about the hashing being _semantic_.
13:34:33 <koz_> I guess being strongly normalizing has its uses.
13:34:39 <merijn> koz_: That's the entire point :)
13:34:51 <koz_> merijn: I guess I should learn to read better.
13:34:52 <hekkaidekapus> Also, if you ever followed what Gabriel did with Morte, Dhall will be the obvious successor.
13:34:58 <monochrom> With less power comes more analyses!
13:35:01 <merijn> koz_: You can tag your imports with a semantic hash, so you can still/update and refactor them IFF the behaviour is unchanged
13:36:11 <hseg> hrm. judging by core, inner loop is unnecessarily polymorphic, plus funcalls aren't inlined
13:39:27 <koz_> Functional languages are great. We have FUNcalls, not the boring-calls other languages insist on.
13:40:10 <monochrom> But procedural language are more professional, they have PROcalls. >:)
13:40:16 <hseg> :)
13:40:29 <koz_> monochrom: As opposed to the NOOBcalls OO languages insist upon? :P
13:40:58 <monochrom> as opposed to playful calls euphemized as fun calls.  BITE ME
13:41:46 <hseg> sure, but this code should be the equivalent of while(divides(x,m)){ k++; m=div(m,x); }. Instead, it's funcalling all over the place
13:41:56 <monochrom> But OK! We are a united front against the OO noobs.
13:58:08 <Sonolin> weird
13:58:14 <Sonolin> I'm getting ResponseTimeoutDefault for all stack HTTPS requests atm
13:58:22 <Sonolin> curl processes the same request just fine, any ideas? 
13:58:38 <Sonolin> I've tried removing ~/.stack and starting a new one from scratch, no dice... even `stack new PROJECT` fails
13:59:10 <monochrom> yikes. yeah that's strange.
14:04:18 <Sonolin> yea... just tried a fresh installation of stack and its doing the same thing
14:08:56 <hseg> oh well. don't have anything clever to write instead. besides, only really starts becoming relevant at very large inputs (even divDecomp 2 2^(2^20) doesn't pose much issue)
14:09:15 <hseg> indeed, my naive attempt at outsmarting ghc doubled the execution time!
14:15:24 <Sonolin> well putting an IP for s3.amazonaws.com in my hosts file seems to get past that issue, idk why though... does stack use its own DNS cache or something that I can clear?
14:17:50 * hackage myxine-client 0.0.1.2 - A Haskell client for the Myxine GUI server  https://hackage.haskell.org/package/myxine-client-0.0.1.2 (kwf)
14:27:49 * hackage registry 0.1.9.3 - data structure for assembling components  https://hackage.haskell.org/package/registry-0.1.9.3 (etorreborre)
14:34:26 <dminuoso> hsc2hs question, given #{ const FOO } where `#define FOO (1 << 31)`, how could this possibly produce `-2147483648`?
14:35:31 <dminuoso> Oh gah. Stupid. C.
14:37:14 <monochrom> Not C per se. 2's complement.
14:37:39 <dminuoso> Mmm, how can I massage hsc2hs into doing the right thing then?
14:37:49 <dolio> What is the right thing?
14:37:50 <monochrom> What is the right thing?
14:37:56 <dolio> Jinx.
14:37:56 <hyiltiz> 𝒞(C, A × B) ≅ 𝒞(C, A) × 𝒞(C, B) ignores functions from C->B that also depends on A, like C->A->B = (C,A)->B; are those assumed to not exist based on the diagram here https://youtu.be/gui_SE8rJUM?t=1038, or those A can somehow be "marganilized" out?
14:38:05 <merijn> DWIM ;)
14:38:24 <dminuoso> Well, I want to produce a valid literal to fit into a Word64
14:38:48 <solonarv> are you able to modify the C header where that #define is located?
14:38:52 <monochrom> 1UL << 31
14:39:01 <dminuoso> solonarv: no
14:39:04 <monochrom> Because 1's type is int
14:39:30 <monochrom> BTW 'x's type is also int
14:40:03 <monochrom> At school we have great fun failing students by asking sizeof('x') = ?  and watch them answer 1 and burn.
14:40:06 <dolio> hyiltiz: Hom(C, A×B) is like `C -> (A, B)` in Haskell.
14:40:08 <merijn> monochrom: oh
14:40:16 <merijn> monochrom: Do you want my undergrad torture program?
14:40:26 <monochrom> Heh what does it do?
14:40:33 <solonarv> in that case I think you are screwed, because the #define is equivalent to (-2147483648) ?
14:40:47 <hyiltiz> dolio:  Yes, I see what the notation means
14:41:02 <hyiltiz> oh wait i answered my own question
14:41:05 <merijn> monochrom: https://gist.github.com/merijn/0392ae239b9a091986ae Question 1) is this code standard defined, implementation defined, or undefined behavior? Question 2) What does it do?
14:41:08 <monochrom> Can you modify your C compiler? Modify it so sizeof(int) = 8? >:)
14:41:25 <merijn> monochrom: I've toyed with the idea of a maximally malicious C compiler :p
14:41:33 <hyiltiz> that seems so plain and also so deeply revealing at the same time
14:41:38 <merijn> monochrom: (i.e. standard compliant, but making the evillest possible choice everywhere)
14:42:26 <hyiltiz> Is there a notation for something like X(C,B) ≅ Hom(C, AxB)/Hom(C,A)?
14:42:30 <dminuoso> solonarv: Mmm, the code stuffs that into an u64.
14:42:30 <monochrom> Please have no stack overflow whatsoever in your C compiler!
14:42:36 <monochrom> In fact no stack at all.
14:42:46 <dminuoso> Guess that starts the usual "what magic coercion rules happen now" quiz
14:43:19 <monochrom> To eliminate stack, one way (there may be others) is to CPS-transform the hell out of it. :)
14:43:26 <monochrom> trade stack for heap
14:43:37 <dminuoso> merijn: Im gonna say its undefined behavior because it's lacking a newline at the end!
14:44:37 <hyiltiz> I am also wondering how P(A,B|C)=P(B,A|C)=P(A|B,C) P(B|C) aka Bayes relates to 𝒞(C, A × B) ≅ 𝒞(C, A) × 𝒞(C, B)
14:44:37 <monochrom> That brings in GC but it's OK, you only GC the machine-generated continuations you produce, no worries about user mallocs.
14:44:46 <monochrom> So yes please have no stack but have GC in your C compiler! :)
14:44:50 <monochrom> I mean >:)
14:45:08 <monochrom> Actually why don't you make it an interpreter, too?
14:45:10 <hyiltiz> Tho that Bayes is a statement about Hom(AxB, C) 
14:45:24 <merijn> dminuoso: I blame github for that
14:45:55 <monochrom> Defying every conventional wisdom and vocab people associate with C.
14:46:44 <monochrom> The interpreter is written in Haskell with 7 levels of StateT. To kill performance. ("performance" is another vocab people associate with C)
14:46:58 <dminuoso> solonarv: This is some mighty fine stupid C behavior. :(
14:46:59 <merijn> monochrom: So, do you see my devillish misdirection? ;)
14:47:15 <merijn> dminuoso: What? This behaviour is one of the least stupid things in C
14:47:18 <monochrom> I think sizeof(0) is implementation defined.
14:47:29 <merijn> monochrom: Hah, you've fallen for my cunning trap
14:47:31 <monochrom> The rest is pretty standard.
14:47:59 <hseg> hyiltiz: https://arxiv.org/abs/1601.02593 seems relevant
14:48:13 <merijn> monochrom: It is, in fact, fully standard defined :)
14:48:21 <dminuoso> merijn: perhaps you're right. Perhaps it's just the fault of the linux developer defining `#define FOO (1 << 31)` then.
14:48:40 <dminuoso> Postgres is a pleasant C source base to work with. Linux is not.
14:48:45 <maerwald> isn't it sizeof("ABCDEFGHIJKLMNOPQRSTUWVXYZ"[0])
14:48:58 <merijn> dminuoso: I mean, the fact that integer literals have a specific type is pretty reasonable, the shift is also well defined
14:48:58 <hyiltiz> The category theoretic diagram I drew for Bayes looks weird 
14:49:17 <monochrom> Aaaaaiiiiieeeee I was supposed to know how to parse this properly!  The whole reason why &a[i] works...
14:49:18 <maerwald> I don't remember why those are equivalent though
14:49:47 <merijn> maerwald: Because the standard literally defines "a[n]" as "*(a + n)"
14:49:58 <merijn> so a[n] and n[a] are interchangeable
14:50:49 <merijn> monochrom: The real finnicky bit is the fact that everyone always writes "sizeof(x)" which is a terrible habit, demonstrated by this example :)
14:50:54 <monochrom> Don't you love how some infix and mixfix operators have higher precedence than unary prefix operators? :)
14:51:46 <monochrom> Well I never write "sizeof term" or "sizeof(term)" it's always "sizeof(type)" for me because the term version is fragile.
14:51:57 <merijn> monochrom: That's even worse
14:52:17 <monochrom> and the type version compulsorizes parentheses. I resent that. I think it should be the other way round.
14:52:23 <merijn> I posit that any time you write "sizeof(type)" in a C program you have a bug waiting to happen
14:53:55 <monochrom> What is a reason such that the reason doesn't apply to "sizeof term"?
14:53:56 <merijn> Because it only takes one refactor for "type" to not match the actual declaration and then everything is broken
14:54:41 <merijn> monochrom: "float *foo; /* insert many lines here */ foo = malloc(10 * sizeof(float));"
14:54:56 <merijn> monochrom: Now, 3 years later someone changes the declaration into "double *foo" and you're hosed
14:55:11 <merijn> "malloc(10 * (sizeof *foo));" has no such problems
14:55:12 <monochrom> I can play the same game to the term version.
14:55:47 <monochrom> float foo[10];  ... sizeof(foo).  Then change "foo[10]" to "*foo".
14:56:01 <koz_> > filter (> 1) [0, 1, 2, 3]
14:56:03 <lambdabot>  [2,3]
14:56:19 * hackage hobbits 1.3 - A library for canonically representing terms with binding  https://hackage.haskell.org/package/hobbits-1.3 (EddyWestbrook)
14:58:05 <monochrom> At the end of the day, I think C professionals just say "just use valgrind".
14:59:17 <monochrom> C lint may catch some of those too, I think?
14:59:44 <hyiltiz> hseg: thx for the paper! I was drawing something like this http://ix.io/2utq
14:59:49 * hackage dobutokO-poetry-general-languages 0.1.0.0 - Helps to order the 7 or less words to obtain somewhat suitable for poetry or music text  https://hackage.haskell.org/package/dobutokO-poetry-general-languages-0.1.0.0 (OleksandrZhabenko)
14:59:54 <hyiltiz> which didn't seem useful at all
15:00:21 <solonarv> "just use valgrind" - yes, that's how I survived my C++ course last semester :|
15:00:30 <merijn> C++ is fine
15:00:40 <merijn> Barely need valgrind for that if you get to do C++11
15:03:29 <maerwald> life is too short for doing C... and life is too beautiful for doing C++
15:04:03 <juri_> hands are too valuable to write java.
15:04:12 <merijn> Somewhere, deep inside C++20 is an elegant an nice language struggling to get out
15:04:23 <maerwald> and it lacks a correct parser
15:04:49 <merijn> It lacks an unambiguous grammar :p
15:07:08 <maerwald> it doesn't lack any features though
15:07:18 <maerwald> so whatever you can think of you want to do... you probably can
15:07:24 <merijn> maerwald: It does :p
15:07:31 <merijn> maerwald: Understandable template errors ;)
15:08:14 <maerwald> sticking to C++ can only be overcommitment and stockholm syndrome
15:11:25 <maerwald> In any language I'm amazed if code does anything remotely what I was intending. In C++ I'm amazed, bc it never does.
15:17:16 <merijn> Really? I find C++ to be the language most like Haskell in that if it builds without errors (granted, considerably harder than in Haskell) it mostly does what I want
15:19:42 * MarcelineVQ puts on a detective cap and places a circle next to merijn's name on the list of people contributing to newbies thinking haskell's motto is 'if it buids it's correct'
15:20:01 <merijn> If *my* code builds, it's correct :p
15:20:15 <maerwald> dangerous attitude!
15:20:17 <merijn> The fact that other people are less amazing than me is not my problem ;)
15:20:19 <maerwald> (even if it's true)
15:20:20 <MarcelineVQ> *list of suspected people
15:20:54 <mmaruseacph2> when C++ compiles it mostly does what I want. Modulo segfaults, UB and security holes
15:20:57 <maerwald> remember... you never know when your working memory fails you
15:21:03 <Cale> merijn: That, or it's your only problem
15:21:17 <merijn> Cale: Actually, you're right >.>
15:25:23 <maerwald> smart ppl don't write less bugs, just smarter bugs :)
15:25:36 <dolio> Video game programmers seem really good at getting C++ to compile and not work.
15:27:37 <monochrom> If my code passes my test cases, it is correct. :)
15:27:55 <merijn> One of my professors introduced the term "videogame programmer" to mean "someone who treats programming as a videogame", i.e. randomly permute the code and hill climb towards code that meets the spec :p
15:28:25 <solonarv> wait, people play games that way? :p
15:28:42 <merijn> solonarv: Yes, they're called rogue-likes ;)
15:28:50 <merijn> solonarv: And also grand strategy :p
15:29:14 <maerwald> monochrom: that reminds me of a property test for a complicated financial function written by a long gone CTO that would fail every 2nd week in a month with a loan period starting in 1886
15:29:26 <hseg> doesn't that specialize to type tetris?
15:29:32 <maerwald> after investigating for half a year, it was removed :p
15:29:35 <maerwald> (the test)
15:29:43 <monochrom> haha
15:31:14 <monochrom> I hijack "evolution vs intelligent design" for that.
15:32:23 <int-e> merijn: where "meets the spec" = "passes the testsuite"?
15:32:41 <monochrom> But this term I'm greatly humbled (sarcastic) by learning a 3rd way of programming from my students.  Anti-intelligent design.
15:32:49 * hackage headroom 0.3.1.0 - License Header Manager  https://hackage.haskell.org/package/headroom-0.3.1.0 (xwinus)
15:33:45 <merijn> int-e: "does the right thing on some ad hoc things we tried"
15:34:16 <maerwald> == program verification
15:34:42 <int-e> merijn: I guess that's one step up from "can be demoed on one example"
15:42:48 <countvaj`> hi there, I'm not too familiar with haskell, but was wondering whether haskell (or another functional language) has a standard name for a function that evalutes to one of its arguments, by position? e.g. (arg 2) 1 2 3 4 -- => 3
15:43:07 <monochrom> No.
15:43:59 <dminuoso> countvaj`: well its a constant function.
15:44:10 <merijn> Well, lisp does if you count it as functional :p
15:44:38 <countvaj`> a constant function eh? but it depends on the value of the argument
15:44:43 <dminuoso> oh
15:44:47 <countvaj`> merijn: what is it called in lisp?
15:44:55 <dminuoso> You mean you pass what argument want as an argument yourself?
15:44:59 <monochrom> BTW my usual gripe about how everyone refuses to use "=" for "equal".
15:45:29 <countvaj`> dminuoso: right, the function might receive some set of arguments, and it should always return, say, the second one
15:45:31 <monochrom> and use "=" for everything except "equal".
15:45:47 <monochrom> Like everyone knows what's right, and then adds a not-gate.
15:46:32 <dminuoso> countvaj`: Curious, in what kind of code style is this useful?
15:48:50 <countvaj`> dminuoso: not sure if it's endemic to a style, but at moment i'm interested in doing a standard transformation of regex matches in some text, so that the transformed version is always one of the values returned by the regex parser
15:49:19 <DigitalKiwi> monochrom: all of my code is correct for i do not write tests
15:49:28 <glguy> Sounds like you'd use it in the same places as: [x,y,z ...] !! i
15:50:00 <countvaj`> I could just write a lambda that returns one of the arguments, but it felt like a general enough operation that there might be a standard name for it
15:50:03 <countvaj`> this is in Racket btw
15:50:34 <monochrom> Racket is the opposite of Haskell in this regard.
15:51:19 <countvaj`> monochrom: how do you mean?
15:51:54 <monochrom> Can you write down the type of arg? No, therefore not in Haskell.
15:52:18 <monochrom> Does Racket care about writing down types? No, therefore it can exist in Racket.
15:52:42 <countvaj`> monochrom: makes sense
15:53:25 <monochrom> Consider Racket's (+), (+ 3), (+ 3 1), (+ 3 1 4), (+ 3 1 4 5 6).  You can't do all of them in Haskell.
15:53:51 <countvaj`> all excepting the first?
15:54:09 <monochrom> arg can use the same trick as +'s trick in Racket.
15:54:47 <monochrom> You can choose exactly one of them and do it in Haskell. Once you have committed, it doesn't do any others.
15:54:50 <countvaj`> I assume +'s trick in racket is using the additive identity and assuming integers?
15:55:16 <countvaj`> oh i see
15:55:18 <monochrom> Prelude chose (+ 3 1). But nothing says you can't choose (+ 3 1 4 5) if you give up (+ 3 1).
15:55:45 <monochrom> No, +'s trick is Racket's varargs feature.
15:58:03 <countvaj`> i guess this is related to haskell not having a notion of "apply" then?
15:58:30 <ClaudiusMaximus> :t _3
15:58:32 <lambdabot> (Field3 s t a b, Functor f) => (a -> f b) -> s -> f t
15:58:38 <dminuoso> ClaudiusMaximus: what do you mean?
15:58:49 <dminuoso> Err countvaj`.
15:59:40 <countvaj`> well, again i'm not too familiar, but i seem to recall that haskell can't "apply" a function to a list of args, which in Racket I see as a way to "lift" the literal arguments to a list
15:59:53 <countvaj`> but in haskell it sounds like that might be problematic due to typing issues?
16:00:46 <countvaj`> which is why maybe + only accepts 2 args as monochrom was saying, as a decision about the type of + made in Prelude
16:01:36 <countvaj`> rather than treating + as something that could lift arbitrary args to a list and sum them
16:01:59 <countvaj`> seems related to the ability/inability to "apply"
16:02:46 <dminuoso> countvaj`: You can apply a function to a list of args just fine.
16:02:58 <dminuoso> % map (+1) [1,2,3,4]
16:02:58 <yahb> dminuoso: [2,3,4,5]
16:03:04 <dminuoso> Or, if its an effectful one
16:03:19 <dminuoso> % traverse_ putStr ["foo", "bar"]
16:03:19 <yahb> dminuoso: foobar
16:03:33 <monochrom> (apply f '(x y z)) = (f x y z).  This works for all list lengths in place of my hardcoded '(x y z).  This is deeply disturbing deep magic.
16:03:56 <dminuoso> Or, if the function needs to take some variable arguments, just have the function take a list of things as an arguments?
16:04:07 <monochrom> In reality of course you only use it as (apply f xs) where xs is a dynamically determined list of unknown length.
16:04:34 <monochrom> Taking a list in Haskell is still under the limitation of heterogenous list.
16:04:48 <monochrom> Consider the prinf problem for example.
16:05:22 <monochrom> err homogenous list!
16:06:19 <dolio> The important part is that it is an insignificant limitation.
16:09:46 <countvaj`> monochrom: yes that's the sense of apply i meant (rather than mapping a function over a list)
16:09:51 <countvaj`> what's the prinf problem?
16:10:55 <monochrom> printf("hi"), printf("hi %d", i), printf("hi %d %s", i, str), printf("hi %d %s %f", i, str, pi), ...
16:11:22 <hyiltiz> I found this so hilarious I wish it was listed in Haskell Wiki http://ix.io/2utS
16:12:02 <countvaj`> ah ok
16:12:17 <hseg> it's impossible to satisfy a hole :: (a -> b -> Maybe c) -> IO a -> IO b -> Maybe (IO c), right?
16:12:47 <hseg> well, nontrivially
16:12:56 <countvaj`> do you mean that such a printf cannot exist in haskell?
16:13:01 <countvaj`> monochrom:
16:13:03 <monochrom> Right, IO (Maybe c) is much more doable and natural.
16:13:09 <monochrom> Yes.
16:13:21 <countvaj`> got it
16:13:59 <hseg> right. was trying to write the maximal number of specializations of my function, then realized it only makes sense when substituting IO by some Traversable
16:14:14 <hseg> and IO isn't Traversable for this exact reason
16:15:04 <dminuoso> countvaj`: That being said, printf can be done once you start flipping on language extensions in GHC haskell.
16:15:30 <dminuoso> But it may not be educational to study this at the beginning.
16:16:27 <countvaj`> dminuoso: good to know :)
16:16:28 <monochrom> You get to say, "printf :: String -> [X] -> ...", with "data X = I Int | D Double | S String".
16:16:48 <monochrom> But that's acknowledging, not denying, the limitation of homogenous list.
16:16:58 <monochrom> nor defying
16:17:00 <dminuoso> % printf "%s, %d, %.4f" "hello" 123 pi -- countvaj` 
16:17:00 <yahb> dminuoso: hello, 123, 3.1416
16:17:50 <monochrom> As usual, it is not a big deal. Until it is.
16:18:57 <hyiltiz> %info printf
16:19:07 <hyiltiz> %:info printf
16:19:22 <dminuoso> % :i printf
16:19:22 <yahb> dminuoso: printf :: PrintfType r => String -> r -- Defined in `Text.Printf'
16:19:24 <dminuoso> hyiltiz: https://hackage.haskell.org/package/base-4.14.0.0/docs/Text-Printf.html#v:printf
16:19:31 <dminuoso> It's in base, even.
16:19:59 <dminuoso> countvaj`: Actually... this is done without language extensions. :)
16:22:54 <hyiltiz> For sprintf, cannot find PrintType t => t -> String in hoogle tho
16:23:00 <countvaj`> monochrom: dminuoso: cool, all this makes sense! and neato live interpreter bot thing too
16:23:16 <hyiltiz> So it must be done via IO or some monad?
16:23:43 <dminuoso> countvaj`: yahb is actually just GHCi bolted onto IRC. :)
16:24:19 <countvaj`> yeah I figured, cool stuff :)
16:24:25 <dolio> Scheme does the same thing, though. It has homogeneous lists containing values of the single type that classifies everything.
16:25:00 <dminuoso> countvaj`: Generally, you can implement a lot of stuff you are used in dynamic languages in Haskell, even if it looks impossible at the beginning. Sometimes you can mimic it. Question is whether it's usually worth the effort.
16:25:26 <hyiltiz> i.e. can we do string interpolation / quasiquotation in Haskell (without TH or other "deep" stuff)
16:25:29 <dminuoso> I think most of such tricks are not that important, and they sometimes lead to more brittle code.
16:34:10 <countvaj`> dminuoso: will keep in mind~!
16:38:44 <solonarv> for example: printf is unsafe (it can cause a crash at runtime!)
16:39:17 <solonarv> this is because the format string you pass it may not match the other arguments you pass
16:39:32 <solonarv> since the string can only be inspected at runtime, the error can't be detected any earlier
16:44:10 <monochrom> hyiltiz: printf can be -> String or -> IO (). You nail the type and it will do the appropriate thing.
16:44:50 <Graypup_> say I want to put a Yesod app in examples/, how would I get it to build?
16:45:16 <hyiltiz> oh I was doing printf "%s, %d, %.4f" "hello" 123 pi :: PrintfType String instead of just printf "%s, %d, %.4f" "hello" 123 pi :: String
16:45:18 <hyiltiz> Thx!!!
16:45:41 <Graypup_> it appears that examples/yesod/app/main.hs:2:1: error:
16:45:41 <Graypup_>  Could not find module 'Application' is happening
16:45:43 <monochrom> For this overloading reason there is no need to introduce a 2nd name "sprintf".  Well, unless you argue that a 2nd name is clearer than nailing types. I won't counter-argue.
16:46:13 <Graypup_> which implies that there is some special handling of import searching if the thing is the default library
16:46:16 <Graypup_> (in the cabal file)
16:48:07 <monochrom> That's right, search only hs-source-dirs in this context.
16:49:00 <Graypup_> so if I want to have only one cabal file and the main `library` is the library I'm writing, am I SOL?
16:49:04 <monochrom> I don't know what's the right thing to do for examples directories.
16:49:11 <Graypup_> yeah
16:49:46 <Graypup_> typically people seem to put them behind a flag and conditionally compile the example executables, but I'm kinda hosed for yesod I think?
16:49:56 <Graypup_> unless I just, hmm
16:50:50 <hyiltiz> Is there a straightforward way to extend list comprehension syntax over other monads, like [x | x <- Just 1]
16:51:18 <monochrom> MonadComprehension
16:51:25 <Graypup_> bleh nope that does not work :(
16:51:38 <Graypup_> i tried just making an executable target with both app/ and src/ in it
16:52:16 <Graypup_> but that does not work because of TH code that does stuff relative to the current dir :(
16:59:49 <Graypup_> wat ok that is surprising
16:59:56 <Graypup_> maybe my cabal file was wrong
17:04:26 <monochrom> I think this works:  1. in the toplevel directory (where you have your *.cabal), "cabal repl".
17:04:41 <monochrom> 2. Inside there, :load examples/foo.hs
17:07:09 <Graypup_> the thing that is really annoying is that I genuinely do actually have to build an entire yesod app as an example, which is nontrivial :(
17:07:43 <monochrom> OK yeah my experiment was very simple.
17:08:00 <Graypup_> aha the trick is to not use the yesod scaffold 
17:08:14 <Graypup_> lol
17:58:02 <ezzieyguywuf> hexagoxel: here's what I tried (https://dpaste.com/42TWJ8GKN), and here's the output I got (https://dpaste.com/74PFWLCD4)
18:01:22 <redmp> @import Data.Kind
18:01:22 <lambdabot> Unknown command, try @list
18:01:25 <redmp> @list
18:01:25 <lambdabot> What module?  Try @listmodules for some ideas.
18:01:34 <redmp> @let import Data.Kind
18:01:36 <lambdabot>  Defined.
18:02:30 <redmp> @let type family Foo a :: Constraint where Foo Int = ()
18:02:31 <lambdabot>  Defined.
18:02:47 <redmp> > 3 :: Foo Char => Int
18:02:50 <lambdabot>  error:
18:02:50 <lambdabot>      Could not deduce: Foo Char
18:02:50 <lambdabot>        arising from an expression type signature
18:03:05 <redmp> > 3 :: Foo Int => Int
18:03:08 <lambdabot>  3
18:03:20 <redmp> What is (() :: Constraint) ?
18:03:34 <Axman6> it;s the empty constraint
18:03:35 <redmp> From the above, it seems it's the way to say a constraint is satisfied?
18:03:55 <redmp> are empty constraints automatically satisfied?
18:04:08 <Axman6> it is the constraint which is trivially true. but there is no constraint at all for Foo Char
18:04:09 <Axman6> no
18:04:37 <Axman6> Foo Char is like Void
18:05:25 <redmp> a logically uninhabited s/type/constraint/g ?
18:05:34 <Axman6> yes
18:06:11 <redmp> so if i define a TF which leads resolves to (() :: Constraint) it will typecheck, and if i don't have a route to (() :: Constraint) it will fail to typecheck?
18:06:59 <Axman6> yes, if you don't produce a constraint then the constraint you didn't produce cannot be satisified
18:12:18 * hackage signature 0.1.0.0 - Hmac sha256 signature json and http payload  https://hackage.haskell.org/package/signature-0.1.0.0 (Lupino)
18:22:38 <Graypup_> how can I view my own package on hoogle?
18:23:04 <Graypup_> (environment: a nix-shell in my package, so all the deps are available, but presumably I have to manually run haddock or smth?)
18:30:52 <redmp> Axman6: thank you
18:34:55 <jackdk> Graypup_: https://stackoverflow.com/a/34258218/429232 may help?
18:35:35 <jackdk> can anyone recommend a good library for interactive subprocess handling? I want to run a subprocess, let it have stdin, and I don't really care about anything it does except for the exit code
18:37:34 <glguy> jackdk: process?
18:39:02 <jackdk> glguy: huh, I thought I looked there, but System.Process.callProcess is basically what I want
18:39:23 <jackdk> I thnk
18:42:49 * hackage signature 0.1.1.0 - Hmac sha256 signature json and http payload  https://hackage.haskell.org/package/signature-0.1.1.0 (Lupino)
19:28:19 * hackage network-run 0.2.4 - Simple network runner library  https://hackage.haskell.org/package/network-run-0.2.4 (KazuYamamoto)
19:54:59 <Axman6> jackdk: https://hackage.haskell.org/package/conduit-extra-1.3.5/docs/Data-Conduit-Process.html is also quite useful if you want to handle streaming date into and out of the process
19:55:22 <jackdk> Axman6: appreciate the link but I'm just gluing programs together for now
19:56:13 <Axman6> One day I'll make a shell based on that package
20:44:27 <la-jesystani> hello, im having a problem with yesod, is this the place to ask?
20:44:58 <koz_> la-jesystani: Ask away.
20:45:23 <dmwit> Yep, this channel is an appropriate place for yesod questions.
20:46:54 <la-jesystani> im working through the oreilly book, and im at the part about logging. ive got `instance Yesod App where shouldLog etc etc etc` and im getting the error that shouldLog isnt a visible method of Yesod, although the docs online and the book are telling me it should work
20:47:13 <la-jesystani> im just wondering whether theres something basic Im missing to be able to override shouldLog
20:50:59 <la-jesystani> heres my code if it helps: https://pastebin.com/raw/EHm8V7Wf
21:08:34 <la-jesystani> im working through the oreilly book, and im at the part about logging. ive got `instance Yesod App where shouldLog etc etc etc` and im getting the error that shouldLog isnt a visible method of Yesod, although the docs online and the book are telling me it should work
21:08:39 <la-jesystani> im just wondering whether theres something basic Im missing to be able to override shouldLog
21:08:45 <la-jesystani> heres my code if it helps: https://pastebin.com/raw/EHm8V7Wf
21:19:32 <Axman6> la-jesystani: according to the docs for the current release of Yesod, shouldLog is in fact not a member of that class. but shouldLogIO is: https://hackage.haskell.org/package/yesod-core-1.6.18/docs/Yesod-Core.html
21:21:34 <la-jesystani> Axman6: ah i see, thank you, guess Ill go try and find out how to use that hha
21:22:00 <Axman6> it's very likely the book is out of date, so you should check the docs for the version of the library you're using going forwards
22:02:17 <redmp> la-jesystani: if you open ghci, you can probe imports by typing a prefix and hitting <tab> twice to see what names match
22:10:23 <Axman6> or use :info and :browse
22:10:41 <Axman6> :info Yesod would have shown the function wasn't there
22:36:24 <fog87> i have a problem where my GADT needs a kind of shared enviromental variable
22:36:41 <fog87> i dont think i can write something like this in haskell, as i can only specify the types
22:37:12 <fog87> but i was thinking that when the GADT which specifies an AST, is "evaluated" it could write to an environment
22:37:37 <fog87> but then i get some performance problems with having to check if the branches being referenced have already been evaluated
22:38:12 <fog87> i need to store and lookup from all the nodes that then are named and must be unique
22:38:40 <fog87> so if the branches are not already in the environement, then it evaluates the function at the node over the values on the branches
22:39:06 <fog87> and if it *is* in the environemnte, having already been calculated down a previous branch, then it can just be reused
22:39:36 <fog87> this seems like a total pain however, and i would much prefer if somehow the language could specify at type level that the branches had to be the same
22:40:20 <fog87> currently, i have to say where the tuple of outputs, so i can copy any duplicate results (they are "linear types" so if i want to use it in several places, i have to make several copies)
22:40:35 <fog87> say where they are used*
22:41:00 <fog87> and then, i can delete them from the carried environment after each of the output fields has been delivered
22:41:08 <fog87> but again, this all seems quite expensive
22:41:26 <fog87> and i would expect all this, deciding where things end up, to be a calcualtion performed at compile time
23:16:02 <alm20> I'm reading about recursion schemes, and trying to figure out which one I need to express something like `scanl` / `scanl1` / `scanr` / scanr1` from `Data.List`
23:17:06 <alm20> I know that I can implement `scanl` as a `fold` using `:`, but I'm interested if there is a way to express a scan generally
23:18:04 <alm20> In other words, I want to build a structure from the intermediate results of a catamorphism, where the resulting structure is the same as the initial structure
23:20:55 <jle`> sounds like you're thinking about traversals/Traversable ?
23:21:15 <jle`> though not necessarily linked to recursion schemes and fixed points
23:21:20 <c_wraith> I think scanr is the simplest option to describe with recursion schemes
23:22:04 <jle`> i believe if the base functor admits Traversable then the fixed point will be traversable too, and you can scanl it
23:23:19 <c_wraith> all the l options aren't really recursion schemes.  they are inherently linear, where recursion schemes aren't
23:24:41 <alm20> Yeah, I don't want to use `Foldable`/`Traversable` here. I'm specifically looking for a scan analagous to a catamorphism, not necessarily a fold.
23:25:33 <alm20> For example, I might want to get a tree composed of the intermediate results of a tree catamorphism
23:26:06 <alm20> how can you do `scanr` with recursion schemes?
23:26:08 <hyiltiz> https://ncatlab.org/nlab/show/catamorphism 404
23:29:11 <hyiltiz> From https://en.wikipedia.org/wiki/Catamorphism doesn't seem quite useful? I probably didn't quite understand
23:30:31 <alm20> You can't implement a recursion scheme for scans in terms of catamorphisms
23:30:42 <c_wraith> I feel like you replace the arbitrary list with Cofree, which suggests that futumorphism might be right.
23:31:28 <alm20> You can implement a particular scan as a catamorphism, but you can't do it generally. If you're using a catamorphism, you need to use constructors for a specific datatype
23:32:58 <c_wraith> but when recursion-schemes starts using Free and Cofree, it gets a bit too big to fit in my head
23:33:03 <alm20> Thanks c_wraith!
23:33:30 <alm20> Do you have any recommendations for how I can get some intuition about using futumorphisms?
23:33:35 <c_wraith> nope
23:33:40 <c_wraith> I'm just looking at types
23:34:11 <c_wraith> hmm, wait.  I wanted Cofree.  *sigh*
23:34:20 <L29Ah> https://github.com/ndmitchell/record-dot-preprocessor dis is great
23:34:27 <c_wraith> I'm not sure, but either histo or futu seem likely
23:34:32 <L29Ah> works with duplicated record fields also
