00:08:15 <sim590> I have this snippet here: http://sprunge.us/sA0UeY where I'm creating a new data structure `thisNewPad` and recovering another one from the state monad (using Lenses with `use`). Right after, I'm using the `fromMaybe` function with `thisNewPad` and `mOldPad`. Once I have called once this function, the state has stored the pad (with `helpPad .= Just ...`). Then, the second time (and the third and
00:08:17 <sim590> so on) that I call this function, will Haskell actually execute the `newPad` function to create `thisNewPad` or will the lazy aspect of haskell realize that with `fromMaybe` it will never use it so it won't bother even calling the function `newPad`?
00:09:07 <sim590> I'm asking since `newPad` actually hides memory allocations and if I don't call `closePad`, then it will never be unallocated.
00:20:53 <ski> sim590 : `newPad pHeight pWidth' will still be executed
00:22:00 <ski> i guess you probably only want it executed, in case `mOldPad' is `Nothing'
00:36:00 <dminuoso> If I want to generate entire Haskell modules with some pretty printing, is haskell-src-exts my best bet?
00:36:25 <dminuoso> (TH sadly lacks the ability to talk about pragmas or modules)
00:38:00 <dminuoso> It does not seem to have utilities for name generation though
00:38:52 <dminuoso> I mean Language.Haskell.Exts.Build.name doesn't give me the same power as mkName vs newName does
00:50:56 <sim590> ski: Yeah. That's what I want.
01:03:52 <sim590> Aight, so I'm gonna use a `case` then.
02:00:14 <fendor> why is the hackage index search sooo slow? Every keyboard press lags visibly
02:02:17 <L29Ah> worksforme, if you mean the inputbox at https://hackage.haskell.org/
02:06:16 <fendor> I actually mean the QuickJump feature in the package overview
02:26:41 <dansho> i don't see it, what package?
02:29:57 <fendor> ghc
02:30:48 <dansho> yeah its slow for me too
03:05:49 * hackage hslua 1.2.0 - Bindings to Lua, an embeddable scripting language  https://hackage.haskell.org/package/hslua-1.2.0 (tarleb)
03:06:49 * hackage tasty-lua 0.2.3 - Write tests in Lua, integrate into tasty.  https://hackage.haskell.org/package/tasty-lua-0.2.3 (tarleb)
03:20:18 * hackage hslua-module-text 0.3.0 - Lua module for text  https://hackage.haskell.org/package/hslua-module-text-0.3.0 (tarleb)
04:11:19 * hackage hslua-aeson 1.0.3 - Allow aeson data types to be used with lua.  https://hackage.haskell.org/package/hslua-aeson-1.0.3 (tarleb)
04:45:19 * hackage hslua-module-system 0.2.2 - Lua module wrapper around Haskell's System module.  https://hackage.haskell.org/package/hslua-module-system-0.2.2 (tarleb)
05:00:19 * hackage opaleye 0.6.7006.0 - An SQL-generating DSL targeting PostgreSQL  https://hackage.haskell.org/package/opaleye-0.6.7006.0 (tomjaguarpaw)
05:09:06 <pie_> any interesting new haskell books in the past few months?
05:27:14 <Uniaika> Haskell in Depth is getting updated, at Manning
05:30:14 <Uniaika> other than that, I don't think new books have appeared
05:46:23 <frdg> I am trying to run my program with `ghc --make -threaded -O2 Main.hs`. I have only ever ran programs with stack run. I am getting import errors for external modules that I normally just specify in my .cabal file. Where do I need to specify the imports in this case?
05:48:48 <sm[m]> frdg: ghc's -package option
05:49:29 <frdg> alright thanks
05:49:49 * hackage morpheus-graphql-core 0.14.0 - Morpheus GraphQL Core  https://hackage.haskell.org/package/morpheus-graphql-core-0.14.0 (nalchevanidze)
05:50:50 * hackage morpheus-graphql 0.14.0, morpheus-graphql-client 0.14.0 (nalchevanidze): https://qbin.io/bread-na-1i8e
05:56:00 <merijn> Note that --make has been the default (and thus redundant) for well over a decade now...
05:56:08 <merijn> I wonder why people still pass that flag
05:57:04 <merijn> frdg: Any specific reason for using ghc directly?
06:00:32 <frdg> merijn: the examples I am going off of are using ghc. I would rather not as I cannot get `parallel` to compile and am generally having a painful experience :)
06:01:01 <merijn> Which examples are those? >.>
06:01:11 <frdg> though all the other libraries I have gotten to compile.
06:01:43 <merijn> Because I don't think anyone has seriously advocated for using GHC directly in a decade, except maybe if they have their own custom Shake based setup :p
06:01:59 <merijn> (In which case, they're technically still not advocating that :p)
06:02:24 <frdg> from stack overflow posts and `parallel and concurrent programming in Haskell`. And yes these stack overflow posts are around 10 years old. 
06:02:59 <frdg> basically I just want to run this simple program in parallel and look at stats compared to if I did not run it in parallel
06:04:58 <merijn> frdg: Can easily achieve the same using a cabal file and stack or cabal-install ;)
06:05:34 <merijn> frdg: You just add "ghc-options: -threaded -O2" to your executable in your .cabal file
06:06:06 <frdg> oh wow thats easy
06:06:47 <merijn> Almost as if cabal files were designed for that ;)
06:11:34 <kuribas> what would [(forall a. Num a => a)] mean?
06:12:03 <kuribas> if it a list of numbers that can be cast to any Num type?
06:12:44 <merijn> kuribas: It's a list of values all of whom are Num instances and that's all you know
06:13:07 <kuribas> merijn: but that doesn't make much sense.
06:13:09 <kuribas> :t head
06:13:11 <lambdabot> [a] -> a
06:13:33 <kuribas> head (x :: [(forall a. Num a => a)]) :: (forall a. Num a => a)
06:13:47 <kuribas> :t 1
06:13:48 <lambdabot> Num p => p
06:13:52 <merijn> kuribas: Ah, no I think your observation is right, but I was thinking of the existentially wrapped version of this
06:14:30 <merijn> kuribas: The real answer (currently) is that the it means whatever you want, because it's not valid Haskell so you must be talking about some fictional language you came up with :p
06:14:47 <kuribas> merijn: I am just trying to follow the rules of types...
06:15:31 <kuribas> merijn: extrapolate from the haskell type system if you will...
06:15:36 <merijn> kuribas: There are no universal rules of types, so you need to specify *which* rules. Which would (normally) implicitly be Haskell, except then the answer is just "that's not legal"
06:16:01 <kuribas> if it were legal, would it be consistent?
06:16:18 <merijn> that depends how you define "haskell + that"
06:16:39 <merijn> I think 9.2 will have some new stuff using impredicative types, which might answer your question
06:19:20 <kuribas> If I write: data SomeInt = forall a . Num a => SomeInt [a]
06:19:42 <kuribas> so that means there is an a, but it's hidden right?
06:19:49 <kuribas> that would be different from (forall a. Num a => a)
06:19:50 <merijn> yes
06:29:19 <triteraflops> hm, so quite impossible to use trex in ghc, then?
06:29:23 <triteraflops> anything to be done?
06:42:22 <merijn> triteraflops: Well it'd help to explain what trex is, probably? :p
06:44:08 <cinimod> How should I install the haskell executable blogliterately? Neither cabal install nor stack install seem to do anything useful.
06:46:55 <cinimod> cabal v1-install BlogLiterately seems to do something
06:47:43 <cinimod> uh-oh cabal: Missing dependency on a foreign library: * Missing (or bad) header file: zlib.h * Missing (or bad) C library: z
06:48:30 <c_wraith> if you're on a debian-derived system, you probably need to install a -dev package
06:49:06 <cinimod> c_wraith: sadly I am not on debian-derived - I tried nix but BlogLiteraly is marked as broken
06:49:18 <cinimod> BlotLiterately
06:50:09 <cinimod> BlogLiterately - sihg
06:50:11 <cinimod> sigh
06:50:36 <cinimod> Life is a vale of tears
06:51:12 <Olaf4711> ...---...
07:04:17 <triteraflops> merijn: It's this thing: https://www.haskell.org/hugs/pages/hugsman/exts.html#sect7.2
07:04:32 <merijn> cinimod: I've never heard that name and google doesn't point at anything, so isn't that fairly obscure?
07:05:44 <cinimod> This? https://hackage.haskell.org/package/BlogLiterately
07:05:56 <cinimod> merijn: ^
07:30:49 <mmaruseacph2> cinimod: I think you need to install the development headers for zlib
07:30:54 <mmaruseacph2> what distro are you in?
07:32:06 <cinimod> mmaruseacph2: I suspect using cabal-v1 is wrong but it was worth a try
07:32:52 <cinimod> mmaruseacph2: I am on macos but usually I set up my environment via nix
07:33:18 <cinimod> mmaruseacph2: But I just want an executable to format something I am working on
07:33:58 <cinimod> I could try lhs2tex I suppose
07:42:44 <mmaruseacph2> cinimod: it's not cabal/stack at fault
07:43:05 <mmaruseacph2> in order to compile the haskell code your operating system must provide a C library's header
07:43:17 <mmaruseacph2> so you need to install it outside of cabal/stack
07:43:38 <mmaruseacph2> again, what distro are you on? Fedora?
07:43:42 <cinimod> mmaruseacph2: macos
07:43:58 <mmaruseacph2> brew install zlib-devel
07:44:26 <mmaruseacph2> if that does not work, try xcode-select --install first
07:44:29 <cinimod> mmaruseacph2: I can put in it my nix deriviation
07:44:57 <mmaruseacph2> oh, it's nix
07:45:06 <cinimod> mmaruseacph2: but I don't think I should be using old cabal (v1)
07:45:17 <mmaruseacph2> https://github.com/NixOS/nixpkgs/issues/44144
07:45:20 <cinimod> I don't know how to install a haskell executable
07:45:31 <mmaruseacph2> I don't think it's an issue with stack/cabal
07:45:52 <mmaruseacph2> the issue seems to suggest nix-build -A zlib.dev ~/nixpkgs
07:46:18 <cinimod> mmaruseacph2: I am not complaing about stack/cabal
07:46:48 <cinimod> I am asking for help on how to install a haskell executable
07:46:51 <mmaruseacph2> I am just saying that the error you are getting is orthogonal to whether you're using stack/cabal v1/cabal v2
07:47:00 <cinimod> The answer seems to be use your package manager
07:47:11 <cinimod> But BlogLiterately is marked as broken in nixpkgs
07:47:26 <cinimod> So I thought I could use cabal (like in the old days)
07:47:32 <cinimod> Maybe I can't
07:48:50 <davean> cinimod: zlib is seperate. Your system needs the things the Haskell stuff you want depends on your system for
07:49:34 <cinimod> davean: I know it's separate - that wasn't my question
07:49:36 <davean> You can use cabal once you have an enviroment, but nix makes that hard, its still doable but you'd be fighting the system with nix
07:59:27 <cinimod> I have installed lhs2tex - maybe I will try and fix BlogLiterately but not today
08:01:21 <tomsmeding> cinimod: cabal v1 is generally not the right choice now that v2 is the default
08:01:28 <tomsmeding> though there is no particular reason why it shouldn't work
08:02:15 <tomsmeding> if cabal complains that it's missing zlib.h, that means you're missing the zlib development headeres
08:02:31 <tomsmeding> you're not going to be able to install that via haskell tools, as that's a C library, not a haskell library
08:02:55 <tomsmeding> one way to do that on macos is using brew, but it's not the only way
08:03:30 <tomsmeding> though I don't use nix, mmaruseacph2 suggests above that it is also able to give you development headers for zlib
08:03:50 <tomsmeding> can one of those ways work for you, or do you need something different?
08:04:15 <disconsis> Is there a way to bake in the path of the source file into an executable (without hardcoding, of course)
08:04:44 <MarcelineVQ> tomsmeding: iiurc v1 is the right choice for pairing with nix, but I've not double-checked that
08:05:27 <tomsmeding> thanks, as I said, I don't use nix :)
08:11:55 <disconsis> Is there a way to bake in the path of the source file into an executable (without hardcoding, of course)? I'm considering template haskell for this but I'm not too familiar with it
08:12:10 <disconsis> As I understand it, that's what's used for constexprs
08:12:28 <disconsis> Which this kind of is, I guess, although it's in IO
08:14:44 <solonarv> TH is probably the way, CPP might also be able to do it
08:15:27 <cinimod> tomsmeding: I really appreciate everyone's help and I may try just adding zlib to my nix derivation but for the moment I am able to format my literate haskell with lhs2tex
08:15:48 <disconsis> solonarv: cool, thanks
08:16:04 <tomsmeding> cinimod: cool :)
08:16:07 <cinimod> thanks merijn davean and mmaruseacph2
08:28:20 <monochrom> CPP is least work. If you find it ulgy (you should), you can still limit its pollution by separating out one trivial module that only defines your constant string, and it is then the only module that turns on CPP.
08:29:08 <monochrom> Actually s/least work/simplest/
08:29:33 <monochrom> This one turns out to be both least work and simplest. But everyone should always go for simplest.
08:29:33 <redmp> i can't seem to get a copy of this line to compile in my own file.. it just keeps saying "expected a type but path has kind Symbol" .. it's supposed to be a symbol ... what extension is required for a typeclass instead head to include a symbol? https://hackage.haskell.org/package/servant-server-0.18/docs/src/Servant.Server.Internal.html#line-691 
08:29:56 <monochrom> TH is too much complexity and overkill for just one string.
08:32:22 <monochrom> Perhaps DataKinds
08:33:05 <redmp> paste: https://termbin.com/xka1
08:33:17 <redmp> monochrom: it's got datakinds
08:33:39 <redmp> i copied the instance head and all the extensions from the servant code
08:34:01 <monochrom> The class itself doesn't say "non-default kinds"
08:34:19 <AndreasK> I got a shake question. Is there a good way for information to flow from a rule to rules it depends on?
08:34:40 <redmp> monochrom: neither does the original.. https://termbin.com/xka1
08:34:45 <redmp> ** https://hackage.haskell.org/package/servant-server-0.18/docs/Servant-Server.html#t:HasServer
08:34:51 <AndreasK> In particular I parse some file to find depenencies to compile, which also involves figuring out a few flags and so on.  Then in the rule that compiles these flags currently i essentially have to figure out parts of that information again
08:35:02 <monochrom> click "source"?
08:35:14 <redmp> monochrom: i linked you to the source..
08:35:34 <redmp> original source: `class HasServer api context where`
08:36:27 <redmp> oops, was looking at it on my screen but sent you the wrong link, twice: https://hackage.haskell.org/package/servant-server-0.18/docs/src/Servant.Server.Internal.html#HasServer
08:37:30 <redmp> point is HasServer doesn't specify anything like "types in instance head can be polykinded"
08:39:33 <redmp> PolyKinds is on, but that doesn't seem to be enough in my repro
08:40:06 <wata> are parametric polylmorphic types in functions usually(always?) limited to operations on data structures? IE: length :: [a] -> Int    or something like fst and snd?
08:40:32 <monochrom> OK, then I don't know.
08:40:44 <redmp> wata: i'm not sure i understand your question exactly, but no..? ... `id` doesn't operate on any particular data structure
08:40:57 <c_wraith> :t const -- wata 
08:40:58 <lambdabot> a -> b -> a
08:41:03 <merijn> wata: No, they work on everything
08:41:09 <redmp> monochrom: thanks for taking a look
08:41:13 <redmp> this has me stumped
08:41:34 <merijn> :t GHC.OldList.foldr
08:41:35 <lambdabot> (a -> b -> b) -> b -> [a] -> b
08:41:55 <merijn> wata: Note that a lot of the parametricity there is the function and zero element
08:42:26 <wata> ahhh
08:42:33 <NickSeagull> Wait, what's OldList?
08:43:06 <merijn> NickSeagull: The module with the old monomorphic functions on lists
08:43:10 <c_wraith> the thing that was Data.List before FTP
08:43:10 <merijn> :t foldr
08:43:12 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
08:43:20 <redmp> monochrom: oh, wow, uh, nevermind.. the error was about the constructor :> expecting types of kind *, not about the typeclass
08:43:24 <solonarv> :t foldr @[]
08:43:25 <lambdabot> error:
08:43:26 <lambdabot>     Pattern syntax in expression context: foldr@[]
08:43:26 <lambdabot>     Did you mean to enable TypeApplications?
08:43:26 <NickSeagull> Aaah, I see now merijn thanks
08:43:26 <wata> what i meant in my question is that by not restricting the type (other than it being the same type in other places?) it was hard for me to think of functions that could accept things of any type
08:43:28 <solonarv> aw man
08:43:35 <wata> foldr example makes sense, thank you
08:43:37 <merijn> NickSeagull: The foldr in prelude is now typeclass polymorphic in Foldable, but that can make things confusing :)
08:43:52 <solonarv> % :t foldr @[] -- the polymorphic foldr, specialized to lists again
08:43:53 <yahb> solonarv: (a -> b -> b) -> b -> [a] -> b
08:44:27 <merijn> wata: The most useful examples of that (which don't involve data structures) are going to be things that take multiple functions where the types line up
08:44:31 <merijn> wata: oh, actually
08:44:34 <merijn> :t (.)
08:44:35 <lambdabot> (b -> c) -> (a -> b) -> a -> c
08:44:41 <merijn> That's probably the simplest example :)
08:44:50 <redmp> :t uncurry
08:44:51 <lambdabot> (a -> b -> c) -> (a, b) -> c
08:45:03 <redmp> well, there's a data structure there
08:45:03 <wata> merijin, yes the function type lining up example is something that also makes sense to me
08:45:35 <merijn> wata: Are you familiar with the idea of "dependency injection" in other languages?
08:46:02 <wata> i'm afraid not. reading wiki now
08:47:01 <merijn> wata: it's basically the idea of "injecting" the actual implementation of logic you wanna use later. Honestly it's kinda overcomplicating things for no reason, imo :p
08:48:00 <wata> reading the explanation I think I get why you asked about it though
08:48:42 <merijn> wata: You allow the user of your boilerplate to pass as argument (in Haskell) the actual logic to use and then your boilerplate code hooks the bits and pieces together
08:49:51 <merijn> wata: And then you end up with cryptic things like: https://hackage.haskell.org/package/broadcast-chan-0.2.1.1/docs/BroadcastChan-Extra.html#v:runParallelWith :p
08:49:56 <wata> I think I get it. Allows for loosely coupled designs?
08:51:10 <merijn> wata: You can sorta capture some uses of OO inheritance with this. You specify some abstract interface (using parametric types) and then leave filling in the actual implementation to the user
08:52:27 <merijn> For a brain-breaking example you can also consider the continuation monad (Cont) and the functor/monad instances
08:52:37 <wata> Thank you. Understand more now than I thought I would. First time joining IRC for my haskell studies, I can see how this could help me understand things from a variety of perspectives/experiences that I wasn't considering before. Thank you very much.
08:52:41 <monochrom> I have second-hand testimonial evidence that it's Template Method with a new name.
08:53:17 <monochrom> That testimony further admits "a different name because applied to a different purpose".
08:53:32 <merijn> wata: (A feeling of your brains leaking out of your ears is a natural side-effect of first exposure to the continuation monad. Actually that's probably just a side-effect of any exposure to it, first or not...)
08:53:49 <monochrom> I think eventually I'm repelled because I thought design patterns were supposed to describe solutions, not problems or purposes.
08:53:59 <merijn> @quote design.patterns
08:53:59 <lambdabot> jcreigh says: So you're saying design patterns are a template for the general concept of excessive verbosity?
08:54:03 <merijn> ah, bah
08:54:04 <merijn> wrong one
08:54:18 <monochrom> The one about language deficiency?
08:54:28 <merijn> @quote emu design.patterns
08:54:29 <lambdabot> emu says: design patterns are what you choose for wallpaper and carpets
08:54:42 <merijn> monochrom: Naah, that's not nearly condescending enough ;)
08:54:59 <monochrom> haha ok
08:55:38 <merijn> wata: Actually, if you go back to the foldr example, also consider the fact that the result type 'b' can (for example) be a function too
08:55:40 <wata> (i have two grad degrees in architecture. buildings! they also look down on interior designers though. hah)
08:55:48 <merijn> :t GHC.OldList.foldr
08:55:49 <lambdabot> (a -> b -> b) -> b -> [a] -> b
08:56:21 <merijn> wata: That wasn't a dig on interior designers, it was a dig on "the Gang of Four" and their design pattern book about programming :p
08:56:56 <wata> implicit types are dangerous?
08:57:03 <wata> ^an example of
08:57:40 <merijn> :t GHC.OldList.foldr `asAppliedTo` (undefined :: a -> (a -> a -> Bool) -> (a -> a -> Bool))
08:57:41 <lambdabot> (a -> (a -> a -> Bool) -> a -> a -> Bool) -> (a -> a -> Bool) -> [a] -> a -> a -> Bool
08:58:21 <merijn> (note that the final result is now a function 'a -> a -> Bool' that refers to the 'a' type inside the list)
08:59:44 <monochrom> For describing common things popping out in problems, I refer you to Jackson's Problem Frames.
09:00:47 <monochrom> I don't always stab at design patterns, but they're on the soluution side.
09:01:22 <monochrom> As usual, programmers have trouble distinguishing solutions from problems.
09:15:45 <triteraflops> infinisil: yo, you still here?
09:15:53 <infinisil> o/
09:16:17 <triteraflops> lol, I like that emoticon
09:16:32 <triteraflops> so yeah, no chance of t-rexes in ghc?
09:16:50 <infinisil> Oh I wasn't too involved in that discussion
09:17:02 * triteraflops reads history again
09:17:50 <triteraflops> oh yeah, it was monochrom
09:17:59 <triteraflops> monochrom: ^^^
09:21:38 <nschoe> Hi everyone :-)
09:21:38 <nschoe> I have a quick question: in my application I have a "main loop" and several threads. I'm usign an MVar to share data between them.
09:21:38 <nschoe> The main loop is the only producer of data (so periodically update the content of the MVar) and the threads must only consume the data (with readMVar, not takeMVar).
09:21:38 <nschoe> Is there a way I can have the threads not able to modify / empty the MVar by design?
09:21:53 <nschoe> Something like an MVar with two "handles": one for read/write and one for read-only?
09:23:24 <c_wraith> there are libraries that provide that, but it's just a pair of opaque newtypes with limited sets of functions
09:24:24 <nschoe> c_wraith: thanks. Well yeah that's what I had in mind.
09:24:52 <nschoe> c_wraith: d you have a library name in mind?
09:25:12 <c_wraith> I don't.  I recall seeing it, but it was a long time ago
09:25:29 <ClaudiusMaximus> why not pass (readMVar myVar) to the threads?
09:26:04 <ClaudiusMaximus> i think i've seen this termed as samplevar before
09:26:16 <nschoe> ClaudiusMaximus: because the threads are long-running, they are loop. They will read teh MVar several times.
09:26:27 <c_wraith> so?
09:26:29 <ClaudiusMaximus> sure, they can call the action many times
09:26:44 <c_wraith> readMVar myVar is an IO action
09:26:58 <nschoe> Oh yeah, that's clever.
09:27:00 <nschoe> (Sorry it is for me ^^)
09:27:24 <c_wraith> it's a good solution for the simple cases.
09:27:33 <c_wraith> and it's good to start simple :)
09:27:36 <nschoe> Yeah, it's an IO action of course. So that's smart: I don't pass the MVar, I pass teh IO action that reads the MVar.
09:27:36 <nschoe> This way the thread doesn't see the MVar and thus canno modify it. Awesome :)
09:27:42 <nschoe> c_wraith: could not agree more.
09:28:42 <nschoe> Thanks!
09:38:37 <monochrom> triteraflops: I think no chance.
09:54:20 * hackage pandoc-plot 0.9.1.0 - A Pandoc filter to include figures generated from code blocks using your plotting toolkit of choice.  https://hackage.haskell.org/package/pandoc-plot-0.9.1.0 (LaurentRDC)
10:16:54 <dminuoso> Are there ffi primitives for poking a String into a c string?
10:17:27 <dminuoso> Ohh. Nevermind just spotted it.
10:17:44 <monochrom> Yeah, Foreign.C.String
10:18:44 <dminuoso> monochrom: actually Im still not spotting a poking function directly
10:19:46 <monochrom> one of the "new___" things or "with___" things depending on whether you want to manually free.
10:20:26 <monochrom> ___ is in { CString, CStringLen, CAString, CAStringLen }
10:21:09 <dminuoso> All of those require an additional memcpy
10:21:22 <dminuoso> but..
10:21:29 <dminuoso> Mmm.
10:21:42 <monochrom> Yes. But be reminded that only the CAStringLen case makes sense for "I already have space"
10:22:04 <dminuoso> well the thing is, Im implementing a Storable for some `struct foo { char blah[16]; }`
10:22:09 <dminuoso> Where blah is assumed to be null terminated.
10:22:56 <dminuoso> So I want to write `poke p d = pokeCString (#{ ptr struct foo, bla } p) (blah d)`
10:23:31 <dminuoso> By construction, I will guarantee that the field `blah` already fits
10:24:56 <dminuoso> But I suppose i can just copy the implementation of withCAString, and remove the continuation and allocation bits.
10:25:01 <monochrom> Likely Foreign.Marshal.Array suffices
10:25:40 <c_wraith> pokeArray0 seems tailor-made
10:26:16 <c_wraith> oh, that requires an additional Char -> Word8 pass
10:26:22 <c_wraith> But that's probably a lot safer
10:26:39 <sm[m]> TIL: if you specify no --package options in a stack script, it infers them from your imports
10:27:37 <dminuoso> c_wraith, monochrom: Doh. I was looking for the wrong bit. :)
10:27:41 <dminuoso> Cheers.
10:28:10 <c_wraith> don't forget to convert to Word8.  Char's Storable instance is for 32-bit chunks! :P
10:29:33 <monochrom> Foreign.C.String has Char -> CChar.
10:29:34 <dminuoso> castCharToChar seems great
10:29:41 <monochrom> Yeah, that
10:31:16 <dminuoso> c_wraith: Haha. That explains precisely the bug I triggered then. :)
10:31:33 <c_wraith> I knew it'd happen.  :P
10:31:45 <monochrom> oh haha
10:32:17 <dminuoso> monochrom: Curious, does that mean it's forced into UTF-32?
10:32:30 <dminuoso> Or is it variable length UTF-8?
10:32:35 <dminuoso> Or, c_wraith I guess?
10:32:59 <c_wraith> UCS-32 is more accurate, I think
10:33:13 <c_wraith> but basically, yes
10:33:15 <monochrom> sizeOf 'a' = 4
10:35:12 <c_wraith> err.  UCS-4
10:39:24 <dminuoso> c_wraith: Haha indeed. Alright, gotta fix a bunch of storable instances now. :)
10:39:35 <dminuoso> Works great now
10:39:52 <dminuoso> pokeCString ptr = pokeArray0 0 (castPtr ptr) . fmap castCharToCChar
10:43:19 * hackage opaleye 0.6.7006.1 - An SQL-generating DSL targeting PostgreSQL  https://hackage.haskell.org/package/opaleye-0.6.7006.1 (tomjaguarpaw)
11:00:50 * hackage gitlab-haskell 0.2.2 - A Haskell library for the GitLab web API  https://hackage.haskell.org/package/gitlab-haskell-0.2.2 (RobStewart)
11:12:01 <jamestmartin> when should I use a proxy vs type applications? Proxy gives you exact control over which types are specified, whereas type applications you can't control as well and it's not as clear what you need to specify based on the type signature (especially with type class functions where all the stuff in the head of the class is prepended to it). However, Proxy is also extremely verbose; compare `f @_ @_ @a @b x` and `f (Proxy :: Proxy a) (Proxy :: Proxy b) x`. In 
11:12:01 <jamestmartin> my case I'm using them to resolve ambiguous types so they'd both always be necessary.
11:15:37 <glguy> When possible I prefer using (Tagged x) to (proxy a -> x); you can still unwrap the Tagged newtype with a proxy value and you don't get an unnecessary function abstraction at runtime
11:15:49 * hackage reactive-banana-automation 0.5.4 - home (etc) automation using reactive-banana  https://hackage.haskell.org/package/reactive-banana-automation-0.5.4 (JoeyHess)
11:16:09 <merijn> jamestmartin: Simple, always proxy never type applications
11:16:10 <glguy> *Tagged a x
11:16:57 <merijn> jamestmartin: Also, don't use "Proxy a -> Foo" when you use Proxy, use "proxy a -> Foo" (so that you can use Maybe, [], etc. instead of Proxy too)
11:17:18 <glguy> or even better: Tagged a Foo
11:17:42 <merijn> glguy: Whether that's better depends
11:18:09 <jamestmartin> merijn: yeah, I forgot that was a thing. though in this case my type is a `k -> Constraint` so using anything other than Proxy is probably unlikely
11:18:23 <dminuoso> jamestmartin: still, there's no reason not to restrict it any further
11:18:41 <jamestmartin> yeah, I still will
11:18:43 <dminuoso> You dont gain anything by constraining it to `Proxy a`. Just make it `proxy a`.
11:19:43 <jamestmartin> merijn: why never proxy though? it seems extremely verbose in comparison
11:20:06 <dminuoso> If the user already holds a `x :: Maybe Int` in their hands, its easier to just pass `f x` that instead of `f (Proxy :: Proxy Int)` :)
11:20:08 <merijn> jamestmartin: TypeApplications is great! If you wanna make your application more brittle and never be able to rely on the PVP!
11:20:43 <c_wraith> or you know, if people start obeying the PVP
11:20:48 <merijn> jamestmartin: You're making the order in which type variables appear semantically relevant when you use type applications. Essentially 0% of Hackage treats them as such
11:20:50 <glguy> PVP isn't a problem if you're using type applications on your own stuff
11:21:10 <c_wraith> it was pointed out that the extension made the PVP count changing type variable ordering a major update in the PVP
11:21:17 <merijn> c_wraith: Even then it's an issue, because if GHC changes it's algorithm for what order they're inferred, your code breaks!
11:21:18 <jamestmartin> glguy: so Tagged behaves basically like proxy but it performs better? or is there more to it?
11:21:30 <merijn> c_wraith: Then the PVP needs to include for GHC version too
11:21:31 <glguy> That's about it
11:21:45 <dminuoso> jamestmartin: Also, much of it is non obvious. Consider this example: `fmap :: Functor f => a -> b -> (f a -> f b)` - intuitively, what does `fmap @t` do?
11:21:46 <jamestmartin> though it seems like you'd lose the advantage of passing the same proxy value to other functions
11:21:54 <glguy> jamestmartin: No, you don't lose that
11:22:05 <merijn> c_wraith: You can't write PVP compliant versioning for TypeApplications even if you update the PVP, because it can never account for GHC
11:22:13 <c_wraith> Funny, I've got errors from using TypeApplications with functions where the type variable ordering isn't specified.
11:22:15 <glguy> You can still unwrap Tagged values with proxy values
11:22:57 <merijn> c_wraith: This isn't even a hypothetical, GHC has literally already broken this :)
11:23:04 <dminuoso> Also, Proxy doesn't force a language extension onto your users. That's another big plus.
11:23:10 <dminuoso> And likely increases adoption
11:23:29 <jamestmartin> merijn: oh yeah, it can be really confusing. I also have found that GHCI :t gives a different type than what it actually is in my code when I use `stack build`. I guess that explains why.
11:23:40 <dminuoso> Though, in your case you already have ConstraintKinds on. The users of that wouldn't be scared off by TypeApplications presumably
11:23:42 <jamestmartin> so I basically have to guess what order the type parameters are in
11:24:06 <jamestmartin> I already have like, half the language extensions enabled, and this project is just for messing around so I'm not at all concerned by more extensions
11:24:18 <glguy> Even better is writing code that doesn't need so much help figuring out the types
11:25:29 <dolio> Are 'users' relevant here? Not everyone is writing some tentpole library.
11:25:50 <merijn> dolio: You are still a user :p
11:25:59 <merijn> dolio: And it's something to be aware
11:26:16 <merijn> Like no one here can stop you from writing whatever you want, but they're free to tell you what they think is bad
11:26:23 <dminuoso> c_wraith: By the way, Im heavily debating whether to just use ByteString instead of String, and make it a user problem to encode whatever textual data they have.
11:26:31 <dolio> That response makes no sense given the context.
11:26:35 <dminuoso> (re the earlier cstring topic)
11:26:39 <jamestmartin> users aren't relevant here. I'm just doing ridiculous category stuff purely for fun, and god forbid anyone wants to use any of it in an actual codebase.
11:26:44 <c_wraith> dminuoso: that makes sense to me
11:27:21 <glguy> dolio: could you be more specific? I don't understand the question exactly.
11:27:41 <dminuoso> jamestmartin: If it's just play stuff, go with whatever you enjoy. If you want to use TypeApplications then, go for it. Just know it's probably best to use forall explicitly to control type variable ordering.
11:28:02 <dminuoso> There's no argument either way. Proxy is probably less hassle in the long run, since it composes much more nicely
11:28:43 <dminuoso> But most arguments that were raised affects libraries that end up on hackage.
11:29:08 <jamestmartin> glguy: ooh, yeah, you can convert tags to proxy or fmap them. good point.
11:29:15 <dolio> glguy: 'You're forcing your users (which is just yourself) to use the TypeApplications extension by using the TypeApplications extension.'
11:29:19 <dminuoso> Also, you can use Proxy with TypeApplications by the way. `f (Proxy @Int)` is what I tend to do :)
11:29:45 <jamestmartin> dminuoso: it didn't occur to me that you could do that. it does look a lot more ergonomic.
11:29:48 <c_wraith> that's the thing.  I end up using TypeApplications even with proxy because it's less verbose in the cases it comes up in my code.
11:34:20 <jamestmartin> anyway, I guess the answer is to use `proxy` or `Tagged` in the type signatures, in conjunction with e.g. `Proxy @a` to make calling them easier
11:34:55 <jamestmartin> and to never depend on ambiguous types and type applications
11:35:25 <dminuoso> jamestmartin: I wouldnt say never. For internal use or play they can be nice.
11:36:15 <dminuoso> Like I said. The main reasons against them are only relevant if you upload your package to hackage or share it in general
11:36:39 <dminuoso> If you don't and you're a big fan of TyApps, go for it?
11:37:46 <dminuoso> c_wraith: Btw, I wish there was some peekCStringMaxLen from GHC now. It occured to me that I cant trust network driver vendors to write bug free code. 
11:38:05 <jamestmartin> dminuoso: so far they've proven to be a pain even for internal use because they're difficult to predict, inconsistent across even the GHCs I have installed on my system, and defining functions which use them for my purposes requires AllowAmbiguousTypes module-wide... so at least for my purposes, definitely one of the other two options
11:38:06 <c_wraith> paranoia levels: justified
11:38:28 <dminuoso> jamestmartin: If you forall everything, I think the order is pretty stable?
11:38:31 <dolio> If you're going to use them, you should probably explicitly quantify all your types.
11:38:42 <dolio> Is there a warning for that?
11:39:07 <dminuoso> With UnicodeSyntax it's not so bad, and I suppose a case could be made that forall should always be explicit :p
11:39:37 <jamestmartin> oh yeah, you'd definitely have to. but my type classes themselves *already* have complex heads so type signatures would end up a mile long
11:40:20 <merijn> Sounds like you should just be writing Idris or Agda :p
11:40:51 <dminuoso> merijn: That's a bit of a stretch. :)
11:41:48 <jamestmartin> dminuoso: not really.
11:42:05 <merijn> Ha!
11:42:08 <dminuoso> Heh.
11:43:32 <jamestmartin> actually, Agda would be pretty much objectively better at this if my goal were to make something actually usable, but as-is I'm just trying to see how far I can push Haskell
11:45:16 <monochrom> I think you push it over the edge if the outcome is doable but crazy.
11:47:47 <monochrom> Before Copernicus, people kept pushing Ptolemy's epicycle method and everything still worked fine.
11:48:13 <dminuoso> monochrom: And as it turns out, the method can describe any pattern.. :p
11:48:14 <jamestmartin> maybe, but seeing `class (Category (Endofunctor cat), Monoid (Endofunctor cat) m) => Monad cat m` makes it all worth it in the end
11:49:26 <dminuoso> Referring to https://santi75.files.wordpress.com/2008/07/deferentes-epiciclos-y-adaptaciones.pdf of course
11:49:44 <monochrom> Yeah, it's like Fourier series.
11:51:27 <dminuoso> Btw Haskell question. How can I use functions with __STDC_WANT_LIB_EXT1__ ?
11:51:50 <merijn> dminuoso: EDOESNOTCOMPUTE
11:52:13 <monochrom> What the hell is that? haha
11:52:15 <merijn> dminuoso: Or "does not parse", I guess
11:52:46 <dminuoso> foreign import ccall unsafe "string.h strnlen_s" c_strnlen_s :: CString -> CInt -> IO CSize
11:52:49 <dminuoso> I want to do that.
11:52:56 <dminuoso> But strlen_s requires __STDC_WANT_LIB_EXT1__
11:53:07 <dminuoso> (So the above try would just give me a linker error)
11:53:26 <merijn> dminuoso: You use a C wrapper and call that
11:54:14 <dminuoso> Okay fine! Ill use memchr then instead. :p
11:54:50 <jamestmartin> monochrom: what the hell is that re: who?
11:55:20 <dminuoso> Me in all likelihood
11:57:03 <monochrom> I am wondering if https://stackoverflow.com/questions/18809986/undefined-reference-to-strnlen-s-strncpy-s-strncat-s/18810075 is relevant
12:03:51 * hackage functor-combinators 0.3.4.2 - Tools for functor combinator-based program design  https://hackage.haskell.org/package/functor-combinators-0.3.4.2 (jle)
12:06:40 <isovector1> are there any tricks for type-applying multiple type parameters simultaneously, without changing any definition?
12:12:24 <lyxia> what do you mean
12:12:48 <isovector1> i have a type `Foo i k r` with many constructors, many of which are polymorphic in multiple of those type args
12:13:22 <isovector1> when writing property tests for these constructors the types are ambiguous for most of the tests i want to write
12:13:35 <isovector1> so i have to fill in three type parameters for every test
12:13:52 <isovector1> which is annoying and would be nice if i could get around that boilerplate
12:14:08 <isovector1> (there are >200 tests that are ambiguous, currently)
12:16:16 <c_wraith> create less-polymorphic functions that call the constructors?
12:16:54 <isovector1> so the answer is "no, there are no tricks?" ;)
12:17:29 <c_wraith> nothing that's less verbose than that
12:17:49 <isovector1> maybe a CPP macro :)
12:17:58 <c_wraith> that doesn't sound less verbose
12:18:17 <isovector1> #define ARGS @Foo @Bar @Baz?
12:18:27 <isovector1> the types are quite big
12:20:46 <isovector1> okay, thanks
12:54:18 <archaephyrryx> anyone here familiar with the `streaming` library?
12:54:42 <archaephyrryx> having a couple of issues that are hard to understand without deeper knowledge
12:58:48 <dminuoso> Best just ask your question
13:01:45 <ixlun> Hi all, does anyone know how I can do a foldr with a Maybe as the accumlator value?  And ideally the fold to fail if at any point the accumulator becomes Nothing?
13:02:06 <dminuoso> ixlun: You probably want to use foldrM instead.
13:02:18 <dminuoso> % :t foldrM
13:02:18 <yahb> dminuoso: (Foldable t, Monad m) => (a -> b -> m b) -> b -> t a -> m b
13:02:49 * hackage dobutokO-poetry 0.11.0.0 - Helps to order the 7 or less Ukrainian words to obtain somewhat suitable for poetry or music text  https://hackage.haskell.org/package/dobutokO-poetry-0.11.0.0 (OleksandrZhabenko)
13:03:29 <ixlun> Aha, that's what I was looking for!, thanks dminuoso 
13:03:30 <dminuoso> % foldrM (\x y -> if x > 10 then Nothing else pure (x + y)) 0 [1,2,3,4]
13:03:30 <yahb> dminuoso: Just 10
13:03:33 <dminuoso> % foldrM (\x y -> if x > 10 then Nothing else pure (x + y)) 0 [11,2,3,4]
13:03:33 <yahb> dminuoso: Nothing
13:03:56 <dminuoso> ixlun: Note you can do the same with foldr directly, but this is just tons more expressive. :)
13:05:18 <ixlun> I've only been studying Haskell for about a week but I must admit I'm blown away by it
13:05:42 <ixlun> the learning curve is *very* steep I think, but I'm persevering
13:07:09 <pounce> Do people use Monad.Memo?
13:07:55 <dminuoso> The download frequency suggests that some do.
13:11:08 <c_wraith> ixlun: it might be the hardest time I had learning a new language in 20 years - mostly because it was actually different from everything I'd learned over those previous 20 years.  But it really does make sense as its own thing when you get through it all.
13:35:53 <ixlun> c_wraith: absolutely agree that it's like no other language that I've looked at before.  I am quite a fan of Lisp and I thought it was quite novel.  Hoever Haskell is like nothing else!
13:36:18 <ixlun> However*
13:39:54 <sm[m]> ixlun: note the terrain can be very steep, but there are less steep ways up. It's not uniform cone. :)
13:45:14 <ixlun> sm[m]: Think I'll have to employ ∇ to find the shallowest gradient :-)
13:47:47 <dminuoso> Is there an idiomatic way to turn a bitmask into a list of things other than this? https://gist.github.com/dminuoso/eda25d7a33a37bdccd68d5e041b0e422
13:48:17 <dminuoso> My data types enum maps to (1 << 1), (1 << 2), (1 << 3) .. etc..
13:48:23 <xerox_> :t (divMod,unfoldr)
13:48:24 <lambdabot> Integral a1 => (a1 -> a1 -> (a1, a1), (b -> Maybe (a2, b)) -> b -> [a2])
13:49:58 <dminuoso> xerox_: Mmm, since there gaps, Ill have to handwire `succ` in Enum and write another Bounded instance to use that.
13:50:14 <dminuoso> Maybe this is the simplest solution afterall
14:29:50 <hyiltiz> http://ix.io/2ui0 About proposition as types, since Probabilistic Inference (Bayes theorem etc.) can be viewed as an extention of formal logic (e.g. see Terry Tao, Ch. 6.9 of Compactness and contradiction), what kind of programs/types would correspond to probabislic inference (according to category theory)?
14:53:35 <ixlun> Does anyone know how I can map an array of Data.Array indexes to the values? 
14:54:06 <ixlun> I was thinking (!) <$> indexes <*> array 
14:54:18 <glguy> map (a !)
14:58:00 <ixlun> glguy: think that worked, I'm not shure how though!
14:58:03 <ixlun> thanks
14:58:18 <glguy> You should ask some questions until you understand
14:59:35 <xsperry> > map (*10) [1..5] -- do you understand why this works?
14:59:37 <lambdabot>  [10,20,30,40,50]
15:00:07 <ixlun> Yes, 
15:00:39 <maerwald> sm[m]: I think we can make haskell mainstream without making interpreters, effects systems and advanced lenses :)
15:01:02 <maerwald> but I wasn't surprised that this is a common opinion
15:01:03 <ixlun> I think I'm confused since (!) expects the array as the first parameter, but woudln't map (!) indexes fail?
15:01:16 <sm[m]> eh what what
15:01:22 <maerwald> sm[m]: the reddit thread
15:01:30 <xsperry> that's why a is on the left side of !, and not right
15:01:30 <ixlun> ohhh wait, (a !) partially applies the array right?
15:01:36 <sm[m]> about the marketing video ? /me catches up
15:01:39 <xsperry> yep
15:01:58 <maerwald> sm[m]: yep... I agree with the analysis, but the conclusion is a fallacy imo
15:02:03 <glguy> ixlun: it "partially" applies (!)
15:02:12 <ixlun> ahh, right, it's function currying
15:02:24 <Rembane> ixlun: Look at the type of (a !) in ghci 
15:02:35 <sm[m]> yes his choice doesn't resonate with everyone but I think the analysis and concepts are much more important
15:03:20 <sm[m]> I was in the "no, finance!" camp naturally :)
15:03:43 <maerwald> you don't win pragmatists by making the language more esoteric and owning a niche use case
15:03:55 <sm[m]> I actually think it'll be cardano that does it
15:04:41 <maerwald> that'll depend on non-tech factors I think
15:04:58 <maerwald> how well the product is going to be perceived in the crypto world etc
15:05:38 <maerwald> before pragmatists are going to bother noticing it
15:06:18 <sm[m]> I think cardano will bring it faster, but even without that I suspect general web & line of business apps might do it eventually.. but rather slowly
15:07:21 <maerwald> I think android app market and microservices are undervalued markets if you care about penetrating one. And haskell can be very well used for both.
15:08:08 <sm[m]> in principle, later, you mean ? or today ?
15:08:32 <sm[m]> I though mobile apps still requires a lot of native programming (java)
15:08:33 <maerwald> today, maybe not as well as the leading techs yet
15:09:45 <maerwald> can't obelisk deploy as app? https://github.com/obsidiansystems/obelisk#android
15:10:11 * sm[m] & maerwald are referencing the great talk being discussed at https://www.reddit.com/r/haskell/comments/i9h54g/how_to_market_haskell_to_a_mainstream_programmer/
15:11:49 <maerwald> I think a major thing that still makes pragmatists sigh and look away is that we still haven't demonstrated sufficiently that we can use intellectual complexity wisely/sparingly.
15:12:05 <sm[m]> "microservices" is hard for me to see as a market segment, like "dsls"
15:13:57 <sm[m]> I guess I roll it in to my vague "line of business apps"
15:14:10 <Uniaika> hmm.
15:14:22 <Uniaika> isn't liftM made a bit redundant by fmap, nowadays?
15:14:45 <Uniaika> or are there ways to use it where fmap can't replace it?
15:14:54 <sm[m]> "complex software made reliably and cheaply"
15:20:29 <dolio> Uniaika: You could use it as a default implementation of fmap.
15:30:04 <Uniaika> dolio: well it feel unnecessarily restricted, since Monads abide by Functor laws
15:31:24 <koz_> Uniaika: It's the same idea as using ap as a default for <*>.
15:31:36 <koz_> It means you just define one, and then define the other one in terms of it.
15:32:02 <koz_> So in this case, you just need >>=, and then can write 'fmap = liftM`.
15:35:48 <Uniaika> oic
15:36:07 <koz_> fmap is perhaps not as worth it as <*>, but the same reasoning applies.
15:36:32 <koz_> But if you already have an implementation of (>>=), then it just saves some effort.
15:37:15 <dolio> There's also essentially no benefit to removing it, and doing so would break some stuff.
15:39:44 <jle`> Uniaika: liftM is still useful these days
15:40:08 <jle`> if you write a MOnad instance for a type, but are too lazy to write a Functor instance for your type
15:40:21 <jle`> oh, koz_ already described this
15:40:37 <koz_> jle`: Lol.
15:40:43 <jle`> i should read better :)
15:40:47 <koz_> You owe me a soda five minutes ago.
15:41:03 <dolio> hyiltiz: There may be work on such a thing, but the two things you mentioned have at least superficial friction. For instance, the probability part is based on the idea that all propositions have probability 0 or probability 1. However, this view is only valid for classical logic. Constructive logic, which is often what propositions as types is getting you, can have propositions that aren't true or false.
15:41:14 <Uniaika> dolio: oh I wasn't implying we should get rid of it
15:41:22 <Uniaika> < jle`> if you write a MOnad instance for a type, but are too lazy to write a Functor instance for your type // Bad jle`, bad!!
15:41:36 <dolio> And I at least haven't seen a constructive logic analogue of probability.
15:41:45 <jle`> ah hah, i meant if you're too lazy to write 'fmap'
15:41:54 <jle`> instance Monad MyType where ....
15:42:05 <jle`> so you spent all your energy writing the implementation for >>=
15:42:11 <jle`> and you want to call it in for the day
15:42:21 <jle`> but GHC says you have to also define Applicative/Functor instances for it
15:42:31 <jle`> so you can write:
15:42:38 <jle`> insatnce Applicative MyType where pure = return; (<*>) = ap
15:42:42 <jle`> instance Functor MyType where fmap = liftM
15:42:45 <jle`> and now everything works properly :)
15:42:53 <jle`> no need to invest any time in writing fmap from scratch
15:43:16 <jle`> Functor As A Service
15:43:27 <dolio> You can just derive Functor for almost everything these days, so it's probably a moot point.
15:44:20 <koz_> Yeah, it's not much worth it.
15:44:32 <koz_> The ap-<*> situation however still is IMHO.
15:44:34 <Uniaika> I see your point jle` 
15:44:36 <koz_> (at least sometimes)
15:44:56 <Uniaika> koz_: Tagless Final looks awesome, btw
15:45:09 <koz_> Uniaika: What, the Oleg Kiselyov thing?
15:45:15 <Uniaika> ye
15:45:20 <koz_> Or is it getting yet another incarnation I'm not aware of?
15:45:23 <Uniaika> I'm reading his paper 
15:45:25 <koz_> Yeah, it's used _a lot_.
15:45:33 <koz_> Like, it shows up in all sorts of places.
15:45:43 <Uniaika> I thought it was mainly a Scala thing
15:45:46 <Uniaika> but in fact not
15:46:33 <Rembane> Uniaika: Have you checked out the mtl library? 
15:47:04 <Uniaika> Rembane: oh yeah of course
15:47:19 <Uniaika> well I haven't read its source code, but I can use it yeah
15:47:37 <Rembane> Uniaika: mtl is written in tagless final style. 
15:48:24 <Uniaika> oooooh
15:48:41 <Uniaika> :D
15:49:23 <Rembane> Yes! :D
15:49:51 <dolio> So, you're saying that it predates the paper about it?
15:52:07 <Uniaika> yeah I was like "how *old* is this paper??"
15:52:12 <Uniaika> Rembane: the people has questions
15:52:55 <Rembane> dolio: Which paper is it you are refering to? 
15:55:20 <dolio> The paper that coined the 'finally tagless' stuff.
15:55:24 <dolio> mtl is way older.
15:57:24 <Rembane> Can't mtl exist way before the term tagless final and still be written in that style? 
15:57:37 <dolio> It can. That was my question.
15:57:42 <hyiltiz> > :m Data.Complex
15:57:44 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
15:58:10 <ski> > 2 :+ 3
15:58:12 <lambdabot>  2 :+ 3
15:58:15 <Rembane> Oh, I'm a bit tired and thus stupid, which probably is why I didn't understand your question. :)
15:58:35 <hyiltiz> > zeta s n = sum $ take n $ zipWith (\x y->x/y**s) [1,1..] [1,2..]
15:58:37 <lambdabot>  <hint>:1:10: error: parse error on input ‘=’
15:59:50 <hyiltiz> I was trying to use that definition (a more succint/elegant def. are welcome) over complex s; it is complaining about types
16:01:19 <dolio> I mean, it was kind of a rhetorical question. :)
16:01:36 <Rembane> You need to mark them as rhetorical in the future. :)
16:02:18 <Rembane> ...or maybe not, but then this conversation will show up again. :)
16:06:13 <ski> @type let zeta s n = sum (take n (zipWith (\x y->x / y**s) [1,1 ..] [1,2 ..])) in zeta
16:06:14 <lambdabot> (Floating a, Enum a) => a -> Int -> a
16:06:36 <dolio> I guess my point was to clarify that it would be ahistorical to say that mtl was designed based on 'finally tagless', even though one can recognize that it is an example of it in retrospect.
16:07:16 <ski> @type let zeta s n = sum (take n (map (\y -> recip y ** s) [1,2 ..])) in zeta
16:07:17 <lambdabot> (Floating a, Enum a) => a -> Int -> a
16:07:31 <ski> @let zeta s n = sum (take n (map (\y -> recip y ** s) [1,2 ..]))
16:07:33 <lambdabot>  Defined.
16:09:08 <dolio> It does tie in nicely with recognizing that mtl is essentially a 'finally tagless' implementation of an effect system that everyone was excited about, even though they didn't realize they were already using one. :)
16:10:29 <MarcelineVQ> That explains why I feel so affected
16:14:31 <dolio> Even before that craze there were people talking about 'Lawvere theories instead of monads,' but mtl was doing it since 1995. :)
16:15:01 <dolio> Just unrecognized by everyone.
16:25:36 <dminuoso> 01:24:25          Rembane | [22:47:15] Uniaika: mtl is written in tagless final style.
16:25:45 <dminuoso> Im beginning to understand that mtl is kind of not
16:25:59 <Rembane> How isn't it? 
16:27:10 <dminuoso> Mmm, Im just thinking that it's too broad and limiting with the fundeps.
16:27:40 <Rembane> I haven't thought of that. 
16:39:02 <dminuoso> The thing is, the oleg papers seem to be focusing really heavily on interpreters
16:39:04 <monochrom> An important component of finally tagless is having a class like "class X t where <operations centering around t>"
16:39:30 <monochrom> In more elementary terms: programming to an interface.
16:39:41 <monochrom> or s/to/against/
16:40:04 <dminuoso> And Im wondering whether "tagless final" as a particular and extensible solution to writing AST interpreters is just frequently misunderstood, which Oleg seems to mean, is conflated with the implementation style.
16:40:32 <monochrom> mtl has a whole bunch of "class MonadState s m  | m -> s where ..." and a lot of users program against that interface, not against StateT.
16:41:21 <monochrom> But finally tagless also has other aspects that you don't find in mtl. So this will be a perpetual debate.
16:42:24 <monochrom> At some point you need to grow out of being a full-time taxonomer and stop drawing "clear lines" between FP and OOP, between finally tagless and algebraic, etc etc.
16:42:26 <dminuoso> Right. I mean the novel finding of Oleg was not "Hey, writing typeclass polymorphic stuff is awesome"
16:43:03 <dminuoso> (I mean just take the 
16:44:23 <dminuoso> ```The so-called ``tagless-final'' style is a method of embedding domain-specific languages (DSLs) in a typed functional host language such as Haskell, OCaml, Scala or Coq. It is an alternative to the more familiar embedding as a (generalized) algebraic data type. It is centered around interpreters: Evaluator, compiler, partial evaluator, pretty-printer, multi-pass optimizer are all interpreters
16:44:25 <dminuoso> of DSL expressions. Doing a tagless-final embedding is literally writing a denotational semantics for the DSL -- in a host programming language rather than on paper. ```
16:44:41 <dminuoso> I dont think it's about being a full-time taxonomer here. mtl definitely does not fit that at all.
16:45:32 <dolio> Yes, it does.
16:47:36 <monochrom> Perhaps my DSL is really "put" and "get" and that's it.
16:47:56 <monochrom> Then it's the MonadState finally tagless DSL.
16:48:13 <monochrom> Honest to God.
16:48:15 <dolio> mtl is for various embedded DSLs, and the data type analogues are the free monads that people sometimes go wild about.
16:48:27 <dolio> At least, the free monads encoded as data types.
16:48:36 <monochrom> Trivial and no real DSL is trivial like that but meh.
16:49:51 <monochrom> What counts as DSL and what doesn't? >:)
16:50:57 <monochrom> Having too strong opinion on this is equivalent to having too strong opinion on what counts as FP, what counts as OOP.
16:52:08 <dolio> mtl even does the a la carte part where you use many classes to describe your DSL instead of a single one.
16:52:37 <dolio> MonadState s and MonadError e.
16:53:37 <monochrom> But then it goes on to diverge from a la carte by saying that composition of two concretizations is "StateT Writer" rather than "State :+: Writer".
16:54:26 <monochrom> "State :+: Writer" is closer to Oleg's later proposals for effects.
16:54:35 <dolio> The classes are the 'finally tagless' part.
16:55:15 <dolio> The monad transformers are just pre-canned interpreters.
16:55:23 <monochrom> As soon as you have learned that there are horses and there are donkeys and the world is that simple
16:55:37 <monochrom> Someone is going to cross-breed a mule to confuse the hell out of you.
16:57:22 <dminuoso> dolio: which "a la carte" definition are you using here?
16:58:19 <dolio> There are 'finally tagless' papers where they involve multiple classes, so that you can have extensible DSLs.
16:59:00 <dolio> There's `forall f. C f => f a` and `forall f. (C f, D f) => f a` where the latter is the extended one.
16:59:18 <dminuoso> If I skim `data types a la carte` by Wouter Swiersta, then Im given the impression that this is about solving the expression problem by using generic coproducts like :+:
16:59:47 <dminuoso> So Im wondering whether I misunderstand your summary "the a la carte part where you use many classes"
17:00:56 <dminuoso> Ah, I think I can see what you mean
17:00:58 <dolio> Having an extensible DSL is the same problem as having open 'a la carte' data types.
17:01:20 <dolio> One is the 'initial algebraic' version, and the other is the 'tagless final' version.
17:02:51 <cole> how does haskell resolve the following shift/reduce conflict: \x -> y z (can be parsed as (\x -> y) z or \x -> (y z))? i've tried reading ghc's Parser.y and it is kind of opaque to me.
17:03:33 <cole> trying to write a parser of my own and getting a shift/reduce conflict which i believe is due to this. it's ambiguous, right?
17:03:40 <monochrom> (\x -> y z)
17:04:30 <monochrom> The Haskell Report has a stated-in-English rule requiring this.
17:04:30 <cole> monochrom: i mean to ask how does the parser prefer that interpretation
17:04:36 <hyiltiz> > zeta (2 :+ 1) 5
17:04:37 <lambdabot>  error:
17:04:37 <lambdabot>      • No instance for (Enum (Complex Double))
17:04:37 <lambdabot>          arising from a use of ‘e_1215’
17:05:02 <monochrom> I don't know how to write a shfit/reduce parser so I don't know how to write it to do that.
17:05:21 <hyiltiz> @let zeta s n = sum (take n (map (\y -> recip y ** s) [1,2 ..]))
17:05:21 <monochrom> I know how to write a recursive descent parser to do that.
17:05:22 <lambdabot>  .L.hs:174:1: error: [-Woverlapping-patterns, -Werror=overlapping-patterns]
17:05:22 <lambdabot>      Pattern match is redundant
17:05:22 <lambdabot>      In an equation for ‘zeta’: zeta s n = ...
17:05:23 <dolio> Maybe you can look at GHC's grammar.
17:05:35 <hyiltiz> > recip (1 :+ 1)
17:05:37 <lambdabot>  0.5 :+ (-0.5)
17:05:38 <dolio> Happy is LR something, right?
17:05:54 <hyiltiz> > recip (1 :+ 1) ** 2
17:05:56 <lambdabot>  3.0616169978683836e-17 :+ (-0.5000000000000001)
17:08:54 <cole> dolio: yeah, i think i get it now after looking at parser.y some more. thanks.
17:13:57 <dminuoso> cole: By the way, happy's documentation of shift/reduce conflicts takes a related case and explains how they addressed it: https://www.haskell.org/happy/doc/html/sec-conflict-tips.html
17:14:06 <dminuoso> The example seems just very much out of date.
17:15:57 <dminuoso> Well it's only suggested, it doesn't actually state that this is how GHC does it.
17:31:49 * hackage functor-combinators 0.3.5.0 - Tools for functor combinator-based program design  https://hackage.haskell.org/package/functor-combinators-0.3.5.0 (jle)
18:17:51 <maralorn> Regarding the tagless final style discussion above: I always wonder: It would be possible to write a handler for a tagless final language via a free monad right? It would just not make much sense because you would be stacking to abstractions that are commonly each used alone to achieve similar goals. right?
18:18:12 <maralorn> s/to abstractions/two abstractions/
18:38:55 <dolio> You could do it that way, but any instance is like a handler in a way.
18:43:20 <maralorn> Completely different question of the four(?) haskell formaters that we have. Does one have them have an option to disable use of layout sensitive syntax or at least preserve { and ; when they are used?
19:08:38 <cheater> with cabal, is it possible to run a test suite not from within cabal, but the binary itself? i have an issue where a test suite is not returning output to stdout when i do cabal test foo, but if i go to the actual binary that's in the build artefacts, and run that, output works well.
19:10:39 <dolio> I think `cabal test` only prints the output if there's a failure.
19:10:47 <dolio> Maybe there's a flag to change it.
19:11:22 <dolio> If you just make it an executable and `cabal run` it, it will print the output.
19:15:27 <cheater> i mean i cooouuullld
19:15:32 <cheater> but it's so much work
19:18:34 <dolio> It is? I was working on something that had an `executable tests` and I changed it to a test suite by changing like two lines.
19:20:40 <cheater> i mean you're right, i'm just lazy + haven't used haskell in a short while so i don't know the syntax off the top of my head (which is where being lazy comes in)
19:21:02 <cheater> i'll just stop complaining for now :)
19:21:24 <cheater> btw, are there any good ways of making plugins for a haskell program that someone could write?
19:21:32 <cheater> without access to the source for the main program
19:21:45 <cheater> like creating .so's or whatever..
19:27:26 <wavemode> cheater: the unix package provides dlopen, dlsym etc. to call functions from a shared object
19:27:57 <wavemode> there's an example on rosettacode - https://rosettacode.org/wiki/Call_a_function_in_a_shared_library#Haskell
19:28:11 <cheater> hmm... i was thinking under windows though...
19:28:47 <cheater> also i wanted to stay within haskell, i.e. type safety etc
19:30:17 <wavemode> FFI is type-safe as long as you declare the functions correctly. if you don't... boom!
19:39:05 <hyiltiz> @unlet zeta
19:39:05 <lambdabot>  Parse failed: TemplateHaskell language extension is not enabled. Please add ...
19:39:35 <hyiltiz> @let zeta s n = sum . take n $ (\x->recip (x:+0)**s) <$> [1..]
19:39:36 <lambdabot>  .L.hs:174:1: error: [-Woverlapping-patterns, -Werror=overlapping-patterns]
19:39:36 <lambdabot>      Pattern match is redundant
19:39:36 <lambdabot>      In an equation for ‘zeta’: zeta s n = ...
19:40:57 <hyiltiz> @undef zet
19:40:57 <lambdabot> There's currently no way to undefine just one thing.  Say @undefine (with no extra words) to undefine everything.
19:41:01 <hyiltiz> @undef zeta
19:41:01 <lambdabot> There's currently no way to undefine just one thing.  Say @undefine (with no extra words) to undefine everything.
19:41:39 <hyiltiz> @let zeta' s n = sum . take n $ (\x->recip (x:+0)**s) <$> [1..]
19:41:40 <lambdabot>  Defined.
19:41:49 <hyiltiz> > zeta' (-0.5) 100
19:41:51 <lambdabot>  671.4629471031477 :+ 0.0
19:42:00 <hyiltiz> not -1/12   :(
19:42:06 <hyiltiz> > zeta' (-0.5) 10000
19:42:08 <lambdabot>  666716.4591971083 :+ 0.0
19:43:00 <hyiltiz> > sqrt $ (6*) $ (zeta 2 10000)
19:43:02 <lambdabot>  3.1414971639472147
19:46:44 <ddellacosta> this reddit post makes me irrationally angry https://www.reddit.com/r/haskell/comments/iajutp/printing_stuff_to_console/
19:47:47 <hyiltiz> the first sentence "I have solved it in JavaScript, so I know my approach works. My solution in Haskell is not working..." smells fume and smoke
19:50:57 <hyiltiz> ddellacosta: I hope my comment in that post isn't too intrigueing
19:56:07 <ddellacosta> hyiltiz: no that's great I think. I was torn between some passive aggressive link to the Haskell wikibooks article on simple IO, and chiding them for barely seeming to care about Haskell, but I like what you wrote
19:56:49 <ddellacosta> I just don't really understand why they are bothering to use Haskell
19:56:50 <hyiltiz> Added a sentence about printing to console, so it is less of a bite back and more helpful
19:57:18 <ddellacosta> you are nice
19:57:25 <wavemode> it's appropriate to put roughly as much effort into your response as the person put into the question. in this case, that amount seems near zero
19:57:39 <ddellacosta> seriously
19:58:04 <hyiltiz> well I literally opened a new buffer, wrote down those two lines I sent, and tested with my GHCi (just in case)
19:58:17 <hyiltiz> guess I've done more than zero stuff
19:58:42 <hyiltiz> well, now, why is my zeta function above doesn't return -1/12= sum [1..] ?
20:13:36 <sm[m]> cheater: certainly you can run tests from the main executable, and I'm a fan of it. See hledger for an example
20:15:52 <sm[m]> running tasty tests: https://github.com/simonmichael/hledger/blob/master/hledger/Hledger/Cli/Commands.hs#L272
20:35:49 * hackage functor-combinators 0.3.5.1 - Tools for functor combinator-based program design  https://hackage.haskell.org/package/functor-combinators-0.3.5.1 (jle)
20:45:10 <fog70> so, there is something to do with scanners and "objects". somehow the streaming situation resembles another environment for functions to exist in, where they can also contain changing values 
20:46:20 <fog70> placing functions on a scaffold, like an AST, and then extending them to be state-like, having something like values defined in local scope, that change between subsequent evaluations of a function
20:47:18 <fog70> so that these scanner-nets resemble an impure functional programming paradigm  
20:47:56 <fog70> and by existing within a pure functional language, also carrying over some of the properties like type-safety 
20:48:41 <cheater> sm[m]: the other way around
20:48:56 <cheater> i want to run a test suite as a normal executable.
20:48:58 <fog70> basically giving rise to composable state-like functions, to build larger state-like functions
20:49:14 <cheater> but anyways it doesn't matter i just found the binary in the build artefacts :p
20:49:46 <fog70> by the monadicity of the tree being something like "monadic implementations", akin to "nets as neurons" 
20:50:10 <fog70> where recursive functions are like recurrent nets
20:50:59 <fog70> i wonder what other properties of the pure language these "functional objects" can posses 
20:51:57 <fog70> but i just like how, by sitting over a stream of data, the functions have some place to exist other than at top level, which gives an ordering to the subsequent internal values
21:05:46 <sm[m]> Ok great !
21:06:16 <sm[m]> Testing any which we can
21:06:29 <sm[m]> any which way we can
22:09:12 <hyiltiz> Finally built Agda and got excited; found out its repl, and typed `1+1`; it is not in scope
22:10:43 <hyiltiz> well it is definitely not haskell; nothing works (guess gotta be a good boy and go read its docs first)
22:23:55 <glguy> You have to use space to break up identifiers in Agda
22:24:12 <glguy> 1+1 without spaces is a single identifier
22:24:36 <glguy> Spaces or parentheses, etc
22:26:28 <shachaf> Funny that parentheses are built in instead of just being a mixfix operator (_)
22:26:49 <justsomeguy> I don't know Agda, but it has one of the coolest language features: mixfix functions. https://agda.readthedocs.io/en/v2.5.2/language/mixfix-operators.html :)
22:28:51 <dolio> Parentheses being mixfix would be super annoying.
22:30:18 <shachaf> Other operators needing spaces also seems annoying.
22:30:51 <dolio> Yes, but parentheses would be the most commonly used operator.
22:31:36 <shachaf> It would be interesting if a mixfix parser let you specify lexing for operators such that spaces weren't necessary.
22:32:50 <dolio> Yeah, something along those lines would be nice.
22:34:34 <shachaf> Agda mixfix also allows some amount of ambiguity, right?
22:34:58 <shachaf> I should figure out exactly what they allow.
22:35:10 <dolio> What do you mean?
22:36:05 <shachaf> I think an example was both if_then_else_ and if_then_
22:37:08 <dolio> Oh. Yeah, those are two different operators, and you can define both. Sometimes it can't figure out how to parse things if you do too much of that, though.
22:38:43 <shachaf> I was thinking about how to do precedence parsing in an unrelated context and I realized that mixfix would actually be very easy to implement, not complicated like I'd previously thought.
22:39:05 <shachaf> Well... Maybe. I don't know whether Agda lets you declare operators after use, the way Haskell does. That would make it trickier.
22:40:39 <shachaf> Now I'm looking at the Agda documentation. Does it let you declare left/right associativity for mixfix operators?
22:40:53 <shachaf> It doesn't specify it but it seems like you would need it.
22:41:09 <dolio> Yes, you can.
23:01:41 <redmp> i have a seemingly simple thing that i'm trying to, but i'm totally failing
23:02:21 <redmp> i'm trying to apply elements of a "tuple list" to a function, in a general way .. ie.. apply :: function -> tuple_list -> function_result
23:02:44 <redmp> so one example might be the index function
23:02:46 <redmp> :t (!!)
23:02:48 <lambdabot> [a] -> Int -> a
23:03:46 <redmp> use with a tuple-list like so: `apply (!!) ("hello", (1, ()))` .. and you'd expect the result 'e'
23:05:47 <redmp> i've tried defining a typeclass for it, to generalize the pattern, and it doesn't work.. https://termbin.com/zzap
23:06:27 <redmp> in the paste is four examples of the pattern, and a typeclass + associated-type-family which _i think_ represent that pattern.. but i can't get it to "work rigt"
23:11:48 <ski> @let class Apply f as b | f as -> b , as b -> f where apply :: f -> as -> b
23:11:49 <lambdabot>  Defined.
23:12:01 <ski> @let instance Apply a () a where apply x () = x
23:12:02 <lambdabot>  Defined.
23:12:05 <ski> @let instance Apply f as b => Apply (a -> f) (a,as) b where apply f (a,as) = apply (f a) as
23:12:06 <lambdabot>  Defined.
23:12:10 <ski> @type \f () -> apply f ()
23:12:11 <lambdabot> f -> () -> f
23:12:16 <ski> @type \f (a,()) -> apply f (a,())
23:12:17 <lambdabot> (a -> f) -> (a, ()) -> f
23:12:19 <ski> @type \f (a,(b,())) -> apply f (a,(b,()))
23:12:21 <lambdabot> (a1 -> a2 -> f) -> (a1, (a2, ())) -> f
23:12:30 <ski> redmp ^ ?
23:16:03 <redmp> @type apply (!!) ("hello", (1, ()))
23:16:04 <lambdabot> Char
23:16:08 <redmp> wow
23:16:11 <ski> (hm, just read your `class' and `instance' declarations in detail .. looks basically the same as what i did (except no back FD) .. what error did you get ?)
23:16:45 <tintint> hi. In template haskell, is.there a way to identify like a scope. Some fileA.hs and fileB.hs will have different scopes. For example, I may want to use a Name from fileA and not fileB
23:17:05 <redmp> ski: yeah, i used a type family and one fewer types in the head..
23:17:22 <redmp> ski: i really don't understand how your FDs are solving the problem here
23:18:07 <ski> well, i'm not sure what your problem was (you forgot to paste an error message)
23:18:58 <ski> oh, seems i need `UndecidableInstances'
23:19:04 <redmp> ski: ATLRet is non-injective
23:19:11 <redmp> ambiguous types, blah balh
23:19:19 <ski> ah, yes
23:19:22 <redmp> .. oh, yeah, the file i posted is incomplete
23:19:29 <redmp> here's the actual error https://termbin.com/4f3b
23:19:32 <ski> right. i declared my corresponding parameter to be "injective"
23:19:48 * redmp googles injectivity _again_
23:20:30 <ski> but let me ponder the reason for the `UndecidableInstances' (which seems to be triggered by the "forward" FD)
23:21:16 <ski> (only if you have an associated `data' family will it automatically be injective)
23:24:03 <redmp> why is the one that i wrote non-injective? "distinct elements of domain to distinct elements of codomain" .. like, lots of different functions could return Char.. `ATLRet Char ()` and `ATLRet (Int -> Char) (42, ())` both are type Char, so.. that's non-injective?
23:24:15 <ski> hm, it seems to me that if `f' and `as' determines `b', then `a -> f' and `(a,as)' ought to determine `b'
23:25:12 <redmp> why... i don't understand FDs, i guess
23:26:31 <ski> redmp : it (as in the ambiguity error you got) is not about whether it "is" injective (in the sense of the instances given satisfying injectivity or the corresponding FD in my case). it's about whether injectivity (or the FD) is declared (and therefore enforced)
23:26:37 <ski> hmm
23:26:37 <redmp> in my mind, f and as determines b, yes, because b depends on the number of arguments taken by f and the length of as and on f taking the same types that are contained in as ..
23:27:13 <redmp> ski: ohh, that explanation of the error message is really helpful
23:27:28 <ski> hm
23:27:36 <redmp> so i need to understand how to tell haskell when something is meant to be injective, so it can enforce that and reduce ambiguity
23:27:48 <ski> sorry i got momentarily confused
23:27:49 <redmp> (are FDs the only tool for saying "this is injective"?)
23:28:37 <ski> my FD `f as -> b' corresponds to your `ATLRet' being a type family. it automatically determines output, given inputs
23:29:00 <redmp> right... i see that
23:29:47 <redmp> additionally you had the FD as b -> f
23:29:48 <ski> but then i added a "backward" FD as well, since it seemed reasonable
23:30:28 <ski> i'm not quite sure which version (so to speak) of injectivity it refers to, when saying "NB: ‘ATLRet’ is a non-injective type family"
23:31:46 <redmp> can you explain your reasoning behind the FD as b -> f ?
23:31:57 <ski> hm, looking at what it thinks is ambiguous, i think it'd like to know the FD `b -> f', on `ATLRet f as = b'. (or, alternatively the FD `ATLRet f as -> f', on `ApplyTupleList_ f as', if you want to express it that way)
23:32:26 <ski> but obviously `b -> f' makes no sense, considering what you're trying to do
23:33:36 <ski> (knowing only the "final result type", there's no way you could uniquely determine (at most one set of) argument types (and also arity))
23:34:43 <ski> but considering `as b -> f', if you know argument types (including arity), and result type, you should be able to reconstruct a curried style function type from those
23:35:10 <redmp> ah, ok, yeah, that totally makes sense
23:35:20 <ski> (note that i didn't had `f -> as b'. from a curried style function type, you can not determine argument types and result type, since arity is ambiguous)
23:36:21 <redmp> right, because your function's result could be a function
23:36:32 <ski> (in `Int -> [a] -> [a]' you don't know whether to treat this as arity two, with result type `[a]', or as arity one, with result type `[a] -> [a]' .. or as arity zero, with result type `Int -> [a] -> [a]')
23:36:54 <redmp> right, the length of the tuple list disambiguates that
23:37:08 <ski> anyway, i got unsure for a while whether my FDs are sensible for your situation
23:37:26 <redmp> i removed both of your FDs and now i get ambiguity errors :)
23:37:50 <redmp> i guess the next step is for me to read about FDs and understand why/how they resolve this situation
23:37:54 <ski> what if you only removes one of them ?
23:39:17 <ski> thinking about it again, both FDs seem reasonable, to me .. and i'm not sure if there's ny other reasonable FDs one could add, either
23:40:09 <ski> one might argue for `f b -> as', because there's no cyclic types. but i'm not sure whether it could check this
23:42:33 <ski> "are FDs the only tool for saying "this is injective" -- you can also add FDs on families ..
23:43:01 <redmp> wouldn't it just be 'f -> as' because `f` has to be at least as "long" as `as`, and the types in the prefix of `f` must match those in the prefix of `as`?
23:46:18 <redmp> ok, i think i need to go now but this is a good start for me.. i need to understand fundeps better i guess
23:48:03 <redmp> this says some stuff, but doesn't really clear up for me how i decide when to reach for FDs https://wiki.haskell.org/GHC/Type_families#Comparing_type_families_and_functional_dependencies
23:50:30 <redmp> then there's this page that says a bunch of stuff but doesn't really explain why https://gitlab.haskell.org/ghc/ghc/-/wikis/tf-vs-fd
23:50:59 <ski>   type ATLRet f a = r | a r -> f  -- what if you try with this `TypeFamilyDependencies', redmp ?
23:52:01 <ski> redmp : no, `f -> as' would not be sensible (see the parenthetical example with the type of `take'/`drop')
23:53:44 <redmp> ski: this is a problem of me not understanding the precise meaning of an FD
23:53:59 <ski> redmp : anyway, thinking about the coverage condition, i think this use of `UndecidableInstances' (as a way to get around apparently the recursive instance not satisfying the coverage condition) is okay
23:55:04 <ski> i'm actually a bit surprised that it didn't think it satisfied the coverage condition. it seems to me it doesn't consult the FDs associated with the instance constraints, when checking the coverage condition, although, at least on first sight, it appears to me it would be reasonable to do so
23:55:17 <ski> maybe it's an oversight, or maybe i'm just overlooking some problem
23:55:54 <redmp> i don't understand the coverage condition either, lol
23:56:06 <ski> anyway, consider `MonadReader
23:56:07 <ski> '
23:56:26 <ski> it's `class Monad m => MonadReader r m | m -> r where ...'
23:56:47 <ski> the FD says that `m' "(functionally) determines" `r'
23:57:14 <ski> or, for each `m' there can be at most one `r' (such that `MonadReader r m' holds)
23:57:41 <ski> formally, one might write this as `forall m. unique r. MonadReader r m'
23:58:10 <ski> another variant of saying this is that `m' uniquely determines `r', considering the "context" of `MonadReader r m'
23:58:25 <ski> there doesn't have to be an `r' for every possibly `m'
23:58:40 <ski> (e.g. if `m' is `IORef', then there is no `r'. there is no such instance)
23:58:46 <redmp> it sounds like it's saying there's "only one r for a given m" which seems wrong
23:58:47 <ski> but there can't be more than one `r'
23:59:29 <ski> logically, we can elaborate `forall m. unique r. MonadReader r m' as `forall m r0 r1. (MonadReader r0 m,MonadReader r1 m) => r0 = r1'
