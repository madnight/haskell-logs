00:02:31 <Axman6> kenran: regarding your earlier question, why not define a TestM which is also an instance of HasDB? then when testing you can run your application with your mock database implementation
00:03:44 <kenran> Axman6: yes I meant "there is a test suite" :) I am currently trying to define the TestM, but I need to refactor my actual code so that I can more easily switch out the monad for the tests. I've create a smaller playground project that I can link to in case I run into more problems :) thanks!
00:04:58 <Axman6> yeah to run those tests properly, your app needs to be written in terms of HasDB
00:17:08 <kenran> Axman6: Yeah it is. The handler functions are as well, and I use `hoistServer` to transform my AppM into Handler and run that. That's what I need to be doing for a TestM, too. But I used the actual `Application` in the tests, which in turn uses `AppM`. But I think after having defined `TestM` with the correct instances, I can just define a different `Application` that uses that. That's the part where I 
00:17:14 <kenran> need to introduce another, more polymorphic function :) thanks for the input!
00:18:00 <kenran> All in all, this is quite exciting. I think I've finally managed to understand how I can even test anything effectful in Haskell, that is, how I can utilize finally tagless style to accomplish that!
00:18:16 <kenran> The next thing to try would then probably be `polysemy` or some such.
00:19:03 <dminuoso> At some point you gotta wonder, how much energy and refactoring we spend on testing for the purpose of testing..
00:19:35 <dminuoso> It seems a little crazy to go overboard and restructure your entire program with free monads, just to gain that little bit of separate testability.
00:22:23 <dminuoso> How much value do you really get from this?
00:23:45 <dminuoso> Just consider something like HasDB with a mock database behind it. It essentially forces you to reimplement a database purely.
00:28:06 <lortabac> there is probably a higher chance of bugs in the mocking machinery than in the tested code :)
00:28:19 * hackage X11 1.9.2 - A binding to the X11 graphics library  https://hackage.haskell.org/package/X11-1.9.2 (PeterSimons)
00:28:59 <timCF> mocks are lie 😀
00:29:15 <dminuoso> I mean if the point of tagless final is just to be explicit what program paths can do, then that's great and fine!
00:29:39 <dminuoso> Then HasDB is just a way of declaring Im gonna give you a postgresql connection and you can have its IO
00:31:46 <dminuoso> otoh, if all your servant handlers need the database anyway, that becomes pretty moot
00:32:25 <dminuoso> And just a dependency on Pg.Connection will communicate whether or not there's a dependency on the database.
00:32:28 <dminuoso> Am I making any sense here?
00:32:49 * hackage liquid-prelude 0.8.10.2 - General utility modules for LiquidHaskell  https://hackage.haskell.org/package/liquid-prelude-0.8.10.2 (AlfredoDiNapoli)
00:33:54 <Unhammer> now I remember what library I used for io-streams in the past: io-streams. That one seems to be even lighter on deps
00:34:00 <Unhammer> than streamly
00:34:07 <Unhammer> though streamly does look nice
00:34:19 * hackage liquid-platform 0.8.10.2 - A battery-included platform for LiquidHaskell  https://hackage.haskell.org/package/liquid-platform-0.8.10.2 (AlfredoDiNapoli)
00:55:32 <timCF> Hi guys! Want to ask question about logging. I'm using Katip and really like it. But everytime I'm writing some library where logging is done with Katip I'm thinking - what if other guys don't want logging, or want different logging? And the second thing is that KatipContext monad constraint is propagated everywhere (you can't call library
00:55:33 <timCF> functions from normal IO). Just want to ask how you usually are dealing with similar problems, guys! Thanks!
00:56:09 <dminuoso> timCF: Welcome to MonadLogger/LoggingT :)
00:57:04 <timCF> But it's just Katip alternative? How it solves issue in general? That I want logging to be abstracted and let user to choose it
00:57:23 <dminuoso> Oh
00:57:38 <dminuoso> timCF: well MonadLogger/LoggingT is that pretty much.
00:57:57 <dminuoso> LoggingT solves it by being essentially some `ReaderT LoggerFun` transformer
00:58:12 <dminuoso> So running the stack requires you to supply some LoggerFun, whatever that is
00:58:21 <dminuoso> So then you can decide on the implementation
00:59:02 <timCF> hmm, I'm not sure, but it seems not enough, give me a sec, I'll provide the code
00:59:12 <dminuoso> Ah, katip is the same
00:59:27 <dminuoso> KatipT newtype KatipT m a = KatipT { unKatipT :: ReaderT LogEnv m a }
01:02:24 <timCF> The problematic place is here. I like this functionality where it's possible to add hierarchical metadata for blocks of code, like there https://github.com/coingaming/lnd-client/blob/d8be2338ffb8d9a2a14af81b81ed0b942ea207b7/src/LndClient/RPC.hs#L464 and there
01:02:24 <timCF> https://github.com/coingaming/lnd-client/blob/d8be2338ffb8d9a2a14af81b81ed0b942ea207b7/src/LndClient/RPC.hs#L491
01:03:42 <timCF> Not sure I explained correctly, but I kinda don't know how to abstract this and let user use other logging system or no logging at all, keeping this hierarchical metadata
01:05:25 <timCF> I have couple of ideas how to solve it, but they are looking not perfect https://github.com/coingaming/lnd-client/issues/52
01:12:05 <Turmfalke> Woah, whitespace handling in Parsec is a nightmare :S
01:13:01 <merijn> Turmfalke: How so?
01:14:48 <Turmfalke> Because you have to be extremely careful where to put it and sprinkle random try's everywhere
01:15:02 <merijn> Don't sprinkle random tries
01:15:23 <Turmfalke> (at least when using the standard combinators)
01:15:26 <merijn> I recommend "sitting down and thinking really hard" as the superior strategy
01:15:50 <hc> you can use a lexer with parsec, then that problem is simplified
01:15:56 <merijn> In fact, you should only use try if you've first thought really hard whether you need try
01:16:33 <Turmfalke> hc: Yeah, I usually do that for larger grammars, but this one is pretty small, so I thought it might not be necessary
01:27:22 <jchia> How can i get started with product-profunctors? I see a bunch of abstract types in the package but very few complete code examples.
01:28:08 <jchia> I'm particularly interested in using Data.Profunctor.Product to fmap different parts of my multi-param record type.
01:31:12 <Turmfalke> merijn: e.g. `between (symbol "{") (symbol "}") (sepBy (char 'a') $ try (symbol ",") <|> try (symbol ";") <|> whitespace)` parses `{ a , a ; a  a}` correctly, but if I put whitespace after the last `a`, it fails. Even after thinking hard, I don't know how to solve that :p
01:31:43 <merijn> Turmfalke: THose tries are bad, tbh
01:32:16 <merijn> Turmfalke: http://blog.ezyang.com/2014/05/parsec-try-a-or-b-considered-harmful/
01:33:19 <Turmfalke> I know they make the parser less performant
01:33:25 <merijn> Not just that
01:33:37 <merijn> They also just make your errors rubbish, which in turn makes debugging a nightmare
01:34:18 <merijn> Which is what that blogpost explains
01:35:27 <Turmfalke> Actually the parser is not my main concern, as it's just a proof-of-concept project, so I just want to make it work to concentrate on the AST processing parts
01:38:22 <merijn> Turmfalke: Incidentally, I do agree with hc that I'm increasingly convinced that for non-rigid (i.e. human programming languages, rather than machine output) you really wanna do two steps, one tokenisation and one parsing these higher level tokens, because things are a mess otherwise
01:39:14 <merijn> Turmfalke: Anyway, the trivial solution for your parsing problem with a whitespace before the } is to either 1) expand the close parser for between to swallow whitespace before the symbol, or 2) add a whitespace gobbling parser after sepBy
01:42:22 <Turmfalke> merijn: symbol should already swallow whitespace: symbol s = try whitespace *> string s <* whitespace
01:44:14 <merijn> oh, ha
01:44:52 <merijn> Your parser specification is ambiguous
01:45:18 <merijn> Your separator parser succeeds on the whitespace
01:45:32 <merijn> Because of the final "<|> whitespace" character
01:45:38 <merijn> So it tries to parse another 'a'
01:45:45 <merijn> Which fails, because there isn't one
01:47:10 <Turmfalke> Yes, I thought I could add another try somewhere to give that whitespace back to symbol '}' :D
01:48:20 <[exa]> lexeme = (whitespace*>)   -- avoid parsing after-token whitespace at all cost
01:48:49 <Turmfalke> Maybe I should rewrite that completely without using between/sepBy
01:52:16 <Turmfalke> [exa]: Why avoid it *after* the token? Shouldn't parsing a token with whitespace already stripped before it cause less wrong parses?
01:53:31 <[exa]> it causes too much ambiguity; in particular, eating input without actually producing output is rather "unguided"
01:53:52 <[exa]> Turmfalke: in your case you'd probably want to separate to tokens first, and then parse without whitespace problems
01:55:32 <Turmfalke> I'd prefer getting the parser done ASAP, and perhaps rewrite it to a better version later on :S
01:59:41 <[exa]> Turmfalke: in fact doing that is quite fast, you can copy some stuff from here https://gist.github.com/exaexa/dd5522fb2695da501705900e72205988
01:59:52 <[exa]> the worst part is making a Stream instance for your token list
02:00:30 <[exa]> that code ^ is from some kind of assignment (not sure anymore), showing how ugly it is to parse significant whitespace manually
02:00:48 <[exa]> simplistic on purpose though
02:03:29 <Turmfalke> Oh, you're using Parser for the tokenzer too
02:03:44 <Turmfalke> *Parsec
02:04:31 <[exa]> Turmfalke: yeah why not.. :D the main point there is that in token stream, you can be sure that if you have two tokens 'a' and 'a', they had to be separated by something originally, because 'aa' would tokenize just as 'aa'
02:05:18 <[exa]> which allows you to dodge the ugly&long implicit encoding of "not preceded by non-whitespace" into the parser
02:06:19 <Turmfalke> I've always used a fully rolled out, State based tokenzier in the past, like haskell-src-exts does
02:08:12 <Turmfalke> Thanks, I think I will give that a try. Doesn't look to complicated
02:08:36 <[exa]> like, it would deserve some care, it's too list-ish
02:08:47 <[exa]> but should work generally
02:09:10 <[exa]> also bytestrings/text...
02:09:26 <[exa]> infinite ways for improvement unfold
02:11:08 <kiwi_45> Servant Authorization : Hello Guys, I need to implement Authorization based access in my web app powered by Servant, How do you do it ?  I’m using servant-auth for authentication.
02:14:10 <[exa]> kiwi_45: that's a broad question; you started right with servant-auth though
02:16:03 <kiwi_45> [exa]: Authentication part is working perfectly but now I need to implement Authorization
02:17:00 <dminuoso> kiwi_45: afaik servant has no primitives for this. You gotta write your own combinators.
02:17:21 <dminuoso> Given that you're getting a jwt passed, it's probably going to be some kind of variant on `guard`
02:18:10 <kiwi_45> dminuoso: `guard` ? can you give an idea please
02:18:26 <merijn> :t guard
02:18:27 <lambdabot> Alternative f => Bool -> f ()
02:19:04 <kiwi_45> I mean how to use guard in this context 
02:19:32 <dminuoso> handler jwt ... = do guard (isAllowedToDance jwt); ...
02:30:28 <Orbstheorem> The GHC user guide states that OverlappingInstances is deprecated. Why?/In favor of what?
02:30:42 <merijn> Orbstheorem: Individual overlapping pragmas on instances
02:30:46 <dminuoso> Orbstheorem: The Overlappable/Overlapping pragmas
02:30:56 <dminuoso> OverlappingInstances is quite a hammer
02:32:59 <Orbstheorem> Right ^^
02:34:16 <Orbstheorem> Any chance I could also get rid of undecidable instances with an instance pragma? x)
02:35:02 <merijn> Orbstheorem: No, because that's not local
02:35:15 <merijn> Orbstheorem: Also, overlapping is much more dangerous than UndecidableInstances
02:39:56 <kiwi_45> dminuoso: are you pointing me to something like this : https://github.com/haskell-servant/servant-auth/issues/73#issuecomment-349737003 ?
02:41:10 <dminuoso> No, but the comment seems useful.
02:43:47 <dminuoso> Is there a way to specify enable-executable-stripping in a package somehow? The manual reveals no option.
02:51:14 <kiwi_45> can you please explain your way little bit more ?
02:58:53 <kiwi_45> sorry I lost my connection 
03:01:25 <merijn> dminuoso: Doubt it
03:27:34 <theduke> Can someone recommend a good introduction to the paralellism and concurrency options available in Haskell?
03:29:05 <Taneb> theduke: Parallel and Concurrent Programming in Haskell by Simon Marlowe is a pretty comprehensive option
03:29:09 <dminuoso> theduke: Simon Marlows book for sure
03:36:12 <theduke> Taneb,dminuoso: thanks
03:45:02 <merijn> Also, just browsing throught the user guide and the Control.Concurrent part of base
04:09:19 * hackage prolog 0.3.1 - A Prolog interpreter written in Haskell.  https://hackage.haskell.org/package/prolog-0.3.1 (MarcelFourne)
04:09:46 <hololeap> parallel and async libraries
04:11:04 <hololeap> both of which are authored by Marlow
04:11:08 <hololeap> (and others)
04:11:37 <snb322> Hi, newbie here. I need some help on `digestive-functors`
04:11:57 <snb322> How do you run validation that depends on another field?
04:12:01 <snb322> For example `data Foo = Foo { a :: Int, b ::Int }` and I want to validate that a < b.
04:19:56 <dminuoso> snb322: See #haskell-beginners 
04:20:16 <dminuoso> oh
04:22:40 <hc> hmm, what's the canonical way to transform (a, (b, (c, d))) to (((a, b), c), d)?
04:27:17 <hc> nvm, got it :)
04:27:53 <hc> (background: I'm writing a parser that for efficiency parses a-b-c-d to a-(b-(c-(d))) but I need actually (((a-b)-c)-d) )
04:38:25 <dminuoso> hc: Curious, what is the canonical way?
04:39:21 <dminuoso> Just `assoc (a, (b, (c, d))) = (((a, b), c), d)` ?
04:46:20 <ski> hc : if you want to do it in terms of basic associativity (of three), there's two ways
04:46:30 <ski> (see "Pentagonal law", if curious)
04:47:19 <ski> hc : anyway .. you may be able to use left-recursion-elimination .. show code ?
04:48:58 <hc> dminuoso: et al: tbh I'm using rust for this, not haskell. Just needed some inspiration and remembered there was something. This something was "reverse' xs = foldl (\acc x-> x : acc) [] xs" and I had to adapt that to my problem
04:49:27 <dminuoso> I see.
04:49:40 <hc> It was more boring then I'd remembere dit
04:49:40 <dminuoso> ski: Curious, what pentagonal law are you referring to?
04:49:43 <hc> sorry to disappoint ;)
04:51:20 <ski> hc : you're doing some kind of recursive-descent parsing, yes ?
04:54:16 <hc> ski: yes, writing a parser for $language with rust's nom (much like parsec)
04:56:19 <hc> and that language supports a syntax like lisp: a-b-c
04:58:39 <ski> dminuoso : start with a (natural) iso ⌜α_(A,B,C) : (A ⊗ B) ⊗ C → A ⊗ (B ⊗ C)⌝, that rotates two nodes in a tree. now consider all five binary trees with three nodes, write them out basically in a circle, connect them via (contextual) instances of ⌜α⌝ into a pentagon (or better, pentagram). "Pentagonal law" is expressing that this commutes
05:00:34 <ski> dminuoso : for four nodes, you get fourteen trees, that are connected in a <https://en.wikipedia.org/wiki/Associahedron>, consisting of six pentagons (or pentagrams), and three squares/rhombuses
05:01:03 <ski> hc : yea, so you know about left-recursion, right ?
05:07:14 <tochicool> what is the best FRP library in lts-16.11 in terms of documentation?
05:10:22 <merijn> tochicool: Are there even multiple FRP libraries in stack's resolver? :p
05:10:53 <hc> ski: yeah; tried that, and the overall performance was reduced significantly
05:11:03 <ski> you tried what ?
05:11:06 <hc> yes, I have
05:11:11 <hc> ah nvm
05:11:33 <hc> I tried to implement it "the proper way" so the structure I get when parsing matches what I want
05:11:39 <merijn> Was there an easy way to add a package to the global default environment in v2-build? (Actually, I know there is, but I can never remember how...)
05:11:42 <hc> however, that reduced performance because of syntax ambiguities
05:11:52 <ski> did you use left-recursion-elimination ?
05:12:13 <dminuoso> merijn: "global" environment?
05:12:33 <merijn> dminuoso: The default one
05:12:34 <dminuoso> Do you mean like v2-install?
05:12:59 <merijn> dminuoso: I'm talking about libraries, but yeah
05:13:25 <dminuoso> merijn: use `v2-install --lib Foo`
05:13:31 <dminuoso> If you want, you can specify a custom --package-env
05:13:50 <dminuoso> I found this to be strangely buggy, leading very quickly to unresolvable build plans
05:14:10 <tochicool> merijn: many.. netwire, dunai, rhine and midair to name a few
05:14:21 <dminuoso> tochicool: reflex would be at the top off my list
05:14:33 <merijn> netwire was already deprecated when ertez was still alive
05:14:47 <merijn> So I'd ignore that one
05:14:50 <hc> ski: I had a grammar like this: Term = Identifier | Term '-' Identifier
05:14:57 <merijn> never heard of dunai, rhine or midair
05:14:58 <ski> yes
05:15:10 <dminuoso> tochicool: It has decent haddock documentation, and some random community bits and pieces
05:16:18 <ski> hc : and you tried something like :
05:16:31 <ski>   term = do t0 <- term
05:16:32 <hc> ski: so my 1st attempt was ugly, I shall not even mention it here *g*. Then I thought what is the easiest to do. Which was to write it like this: Term = Identifier | Identifier '-' Term
05:16:41 <ski>             minus
05:16:53 <ski>             t1 <- ident
05:17:00 <hc> yeah, basically that's what I did, which doesn't work for obvious reasons
05:17:03 <ski>             return (Sub t0 t1)
05:17:12 <ski>      <|> do ident
05:17:33 <tochicool> dminuoso: ok thanks.. i'll have another look at reflex
05:17:53 <ski> yea. what i'm wondering about is whether you've tried the usual left-recursion elimination of this, which gives something like
05:18:07 <tochicool> merijn: yh i had heard about netwire
05:18:11 <ski>   term = do t <- ident
05:18:18 <ski>             return' t
05:18:24 <ski>     where
05:18:34 <ski>     return' t0 = do minus
05:18:49 <ski>                     t1 <- ident
05:19:01 <ski>                     return' (Sub t0 t1)
05:19:09 <ski>              <|> do return t0
05:19:28 <ski> (in Haskell terms, of course)
05:19:36 <hc> I didn't try that; let me think
05:20:35 <ski> (it can be adapted, to more complicated grammars, with left-recursion, as well. i just formulated it as clearly i could, for your grammar. hopefully you can see the general idea)
05:20:45 <hc> thanks! I can
05:21:24 <ski> (also,  return'  was just named like that, for suggestivity. you could call it something like  termRest  if you prefer)
05:23:10 <hc> ski: so if I were to parse a-b-c I'd get Sub ('a' 'b') if I read it correctly?
05:24:05 <ski> you put all the non-left-recursive alternatives in the main grammar category (or factored out into a helper of it), then parse a "remainder" after each of them. in the "remainder" category/nonterminal, you put the left-recursive alternatives (removing the first, left-recursive, nonterminal), adding a "remainder" after each case. also, you adjoin the empty (successful) alternative
05:24:52 <ski> hc : overall, you'd get  Sub (Sub 'a' 'b') 'c'
05:25:16 <hc> okay, thanks! that's exactly what I need :)
05:25:28 <ski> you're welcome :)
05:25:48 * hackage happy 1.20.0 - Happy is a parser generator for Haskell  https://hackage.haskell.org/package/happy-1.20.0 (int_index)
05:28:05 <ski> in terms of your original grammar, what you're doing is `Term = Base Rest',`Base = Identifier',`Rest = Step Rest | epsilon',`Step = '-' Identifier'. .. except that when building the AST, you're passing on the current AST into `Rest', so it can incorporate it into the tree it builds, rather than having to post-adjust the tree
05:30:26 <p0a> Hello I am trying to set up haskell-interactive-mode. Is #haskell a good channel to ask about or ##emacs?
05:31:19 * hackage MapWith 0.2.0.0 - mapWith: like fmap, but with additional parameters (isFirst, isLast, etc).  https://hackage.haskell.org/package/MapWith-0.2.0.0 (davtjames)
05:33:05 <ski> dminuoso : i once made a paper model of an associahedra, in a stellated form (i've not seen that done/described before). six intersecting five-pointed stars, and three rhombuses
05:33:51 <ski> (the reason for using pentagram rather than pentagon was to better exhibit geometrically/spatially the symmetries of the situation)
05:35:25 <ski> p0a : you're welcome to ask about it in here
05:36:15 <ski> (also, i think you probably intended #emacs, not ##emacs ?)
05:36:56 <p0a> Thank you, it seems that I have installed it successfully and and I added some lines to my .emacs to require it and haskell-process, and added a hook to haskell-mode. (@ski, #emacs whoops). But when I type for example `import Control.' I don't see anything autocompleting 
05:37:01 <p0a> do I need tags for that?
05:37:56 <ski> (you may have to wait for someone to be able to offer help to notice, though)
05:38:54 <hc> ski: thanks again! I'll try and implement that with rust/nom and compare the performance to what I'm doing right now. :)
05:38:55 <ski> (if you want to, you could ask in both channels)
05:40:03 <ski> hc : have fun :)
05:43:05 <hololeap> would the ($!) here force the whole expression to be strict?
05:43:08 <hololeap> lift (readTVar tvar) >>= f >>= lift . (\r -> writeTVar tvar $! r)
05:44:10 <ski> not sure what you mean by "force the whole expression to be strict"
05:44:42 <ski> it would make sure `r' is eventually forced
05:44:55 <ski> (most probably forced before being written)
05:45:41 <hololeap> i'm trying to write something like modifyTVar' (the strict version), but with the type `(MonadTrans t, Monad (t STM)) => (a -> t STM a) -> TVar a -> t STM ()`
05:46:02 <hololeap> my understanding of lazy vs strict evaluation is really shaky
05:47:18 <ski> i think it looks okay
05:47:35 <ski> what's the `t' you have in mind ?
05:47:44 <hololeap> ExceptT
05:48:10 <ski> ok, so `f' can abort / short-circuit
05:48:51 <ski> is there any particular worry or issue you're thinking/wondering about ?
05:49:59 <ski> if forcing `r' yields bottom, then executing the whole action will be bottom (assuming `f' didn't abort, of course, since if it did, there is no `r')
05:50:31 <hololeap> it just makes sense for the tvar to be written immediately and not have the computation hanging around to be evaluated later
05:51:03 <ski> (and ditto for other `t's that could cause execution to not get to the `writeTVar tvar $! r'. e.g. `ContT o')
05:51:13 <ski> yea
05:51:32 <hololeap> i don't have any place where r could yield bottom
05:52:30 <ski> yea. it's just that phrasing it in terms of bottoms is an easy way to express what will be forced
05:53:17 <hololeap> i have a lot of functions like `deleteItem :: MonadError DeleteException m => Item a -> m (Item a)` which just pattern match on every Item constructor
05:53:26 <ski> similarly, to test whether a list-processing function will be incremental (like not demand to see the whole, possibly long, list, before producing output), simply pass it an infinite list
05:54:30 <ski> (the run-time (normally) doesn't know whether something will bottom out or not. so it making sure a computation is non-bottom means that it's being forced)
05:55:00 <ski> ok, hololeap
05:56:45 <hololeap> anyway, would that expression in my original question make sure that the tvar is written as soon as possible?
05:57:17 <hololeap> and not have the computation hanging in a thunk?
05:59:05 <hololeap> and if not, what would i have to do to make it behave like this?
05:59:09 <ski> not make sure, but i think normally GHC would do the forcing expressed by `seq' immediately, unless it saw a reason not to
06:00:30 <ski> (in fact, i don't know if it ever delays it. but it's allowed to. if you're using `pseq' instead, it's not allowed to delay. also, strictness analysis might mean that it will force it earlier (and therefore possibly elide the forcing at this spot))
06:01:19 <hololeap> ok, i guess that's the "correct" behavior i have in mind. after all, it doesn't need to evaluate `r' if ExceptT short-circuits
06:01:22 <ski> i'd say, stick with `seq'/`$!', unless you can notice a problem with that
06:01:55 <ski> (`pseq' is intended to be used with parallel sparks, to make sure, for performance reasons, that one spark is forced before another)
06:02:52 <ski> (well, you could also use `evaluate' (might be slightly better) .. in case you were in `IO', that is. but you're in `STM'. maybe there should be a `MonadEval' class ?)
06:06:34 <ski> hololeap : well .. it can't, since there's no `r' in that case
06:08:10 <hololeap> another question: i have a place in my code where i have two possible exceptions that can be thrown in the same `ExceptT e STM` block, which eventually get passed to throwIO. right now i have it as `ExceptT (Either e1 e2) STM` and some helper functions to assist with this.
06:08:11 <ski> (and even if there were, the compiler wouldn't go around prematurely forcing it, in case that would give different semantics. that'd be a compiler bug)
06:08:35 <hololeap> is there any advantage to doing it this way or should i just wrap them in SomeException?
06:09:11 <ski> yea .. fine-grained effects is a bit of a mess, with `transformers' :/
06:09:40 <Orbstheorem> How can I write the signature of a function that takes functions with signature `:: forall c. Foo c => Maybe Bool`?
06:10:04 <merijn> Orbstheorem: That's not a function
06:10:12 <ski> it's also ambiguous
06:10:27 <Orbstheorem> Fine, a collection of functions x)
06:10:36 <ski> also, are you sure you want to have a polymorphic argument ?
06:10:49 <merijn> hololeap: You can do subclassed exceptions :p
06:10:54 <ski> if you are, then you need `RankNTypes'
06:10:55 <Orbstheorem> Yes, I want to test multiple implementations of the same thing.
06:11:06 <merijn> hololeap: Everyone always skips over that bit
06:11:44 <Orbstheorem> ski: My problem is that since my argument is not a function, I cannot type-apply it.
06:11:53 <ski> Orbstheorem : and you'll need either `TypeApplications', or else change that to take a proxy
06:12:02 <Orbstheorem> I already have both.
06:12:04 <merijn> Orbstheorem: The solution is to change your argument into something that is a function
06:12:15 <Orbstheorem> And scopedtypevariables too.
06:12:25 <hololeap> merijn: i actually have that for e1 and e2
06:12:35 <ski> what is the error you're getting, when you try `TypeApplications' ?
06:12:48 <Orbstheorem> Actually, the objective of the function i'm writing, is to apply the same test in all implementations (via a type-application).
06:13:07 <ski> hololeap : btw, are you analyzing thrown exceptions ? or just printing them out ?
06:13:26 <hololeap> ski: i'm not 100% sure at this point. right now, just printing them
06:13:56 <merijn> hololeap: You can just use your subclass instead of SomeException
06:14:08 <merijn> That seems much nicer
06:14:11 <Orbstheorem> I could change every test to take in an associated type that get's translated into a type and have the test type-apply to the specific instance, but I'd have to list all instances somewhere in all tests, which defeats the purpose.
06:14:39 <Orbstheorem> s/associated type/associated data type as value/
06:15:20 <hololeap> ski, merijn: would any information be lost if i wrapped them in the subclass? would this affect my ability analyze them later?
06:15:53 <merijn> hololeap: no, the entire point of the whole "subclassing" design of SomeException & co is that you can later project back to the original types
06:15:55 <hololeap> i don't have much experience with writing my own exception heirarchies in haskell
06:16:07 <merijn> hololeap: Did you read the extensible exceptions paper?
06:16:21 <merijn> If not, I highly recommend you do, it should be cited in the Control.Exception docs
06:16:35 <ski> % let foo :: (forall a. Floating a => a) -> (Float,Double); foo n = (n @Float,n @Double) in foo pi  -- Orbstheorem, something like this doesn't work for you ?
06:16:35 <yahb> ski: (3.1415927,3.141592653589793)
06:16:39 <hololeap> merijn: i've heard of it but i also thought there were several competing schools of thought in that area
06:17:20 <hololeap> merijn: sorry, i read "extensible effects" :p
06:17:25 <hololeap> in your message
06:17:29 <merijn> :)
06:17:51 <merijn> "An Extensible Dynamically-Typed Hierarchy of Exceptions, by Simon Marlow, in Haskell '06."
06:17:59 <hololeap> ok, i will take a look
06:18:05 <merijn> hololeap: That goes into how it's implemented and how you can use it
06:19:27 <ski> % let foo :: (forall a. Floating a => String) -> [String]; foo n = [n @Float,n @Double]; pi' :: Floating a => String; pi' = show pi in foo pi'  -- with `AllowAmbiguousTypes'
06:19:27 <yahb> ski: ["3.141592653589793","3.141592653589793"]
06:19:35 <hololeap> thank you ski, merijn. i always get such high-quality answers in #haskell :)
06:20:45 <Orbstheorem> ski: The problem is that in my tests, the type parameter is not present in the return type.
06:21:04 <Orbstheorem> I think I could bring it into scope with proxy though.
06:21:17 <ski> i'm not sure i see your problem
06:21:31 <ski> np, hololeap
06:23:34 <Orbstheorem> ski: `forall c. Foo c => Maybe Bool`. `c` does not appear to the right of the context.
06:26:29 <ski> Orbstheorem : and you've enabled `AllowAmbiguousTypes' ?
06:27:08 <p0a> How do I know which modules are in the standard library?
06:27:12 * ski idly wonders what's wrong with the last yahb example
06:27:14 <p0a> I see https://downloads.haskell.org/~ghc/latest/docs/html/libraries/ but is that it? 
06:27:31 <merijn> p0a: Define "the standard library"
06:27:39 <merijn> p0a: I would not even count those as part of it
06:27:49 <merijn> p0a: I think most people would define "base" as the standard library
06:27:50 <p0a> merijn: I don't know, it's what learn you a haskell says
06:27:57 <merijn> Which you can just look up on hackage
06:27:59 <merijn> @hackage base
06:27:59 <lambdabot> https://hackage.haskell.org/package/base
06:28:28 <p0a> merijn: got it. And your point is that even /that/ can be overridden, right?
06:28:36 <p0a> (as in, not imported)
06:28:42 <merijn> Sure
06:28:48 <p0a> okay, thank you 
06:29:03 <merijn> p0a: Only the Prelude module of "base" is implicitly imported
06:29:13 <merijn> p0a: Everything else you need to import explicitly
06:29:33 <merijn> p0a: You can disable even the Prelude by using -XNoImplicitPrelude in which case you need to import even that
06:31:09 <Orbstheorem> ski: AllowAmbiguousTypes gets rid of one error, but pops another xD
06:31:20 <ski> % let foo :: (forall a. (Show a,Floating a) => String) -> (String,String); foo n = (n @Float,n @Float); pi' :: forall a. (Show a,Floating a) => String; pi' = show (pi @a) in pi' @Float
06:31:20 <yahb> ski: "3.1415927"
06:31:24 <ski> % let foo :: (forall a. (Show a,Floating a) => String) -> (String,String); foo n = (n @Float,n @Float); pi' :: forall a. (Show a,Floating a) => String; pi' = show (pi @a) in foo pi'
06:31:24 <yahb> ski: ("3.141592653589793","3.141592653589793")
06:31:27 <Orbstheorem> I'll turn them to functions taking proxy and see if it works.
06:31:28 <ski> curious
06:31:32 <ski> Orbstheorem : what error ?
06:34:46 <Orbstheorem> works with proxy ^^ 
06:35:39 <ski> it's possible that the error you got could be avoided .. but you didn't give enough information for us to have a chance to be able to tell
06:36:04 <Orbstheorem> yes, I'm working on a minimal example ^^
06:36:13 <ski> ok
06:36:49 * hackage prolog 0.3.2 - A Prolog interpreter written in Haskell.  https://hackage.haskell.org/package/prolog-0.3.2 (MarcelFourne)
06:40:44 <ski> hmm, i think i see what's happening
06:41:54 <ski> for some reason, it's not passing the polymorphic  pi'  to  foo  -- but rather specializing it (defaulting) at `Double', then generalizing this again, before passing
06:41:59 <lyxia> who first called algebraic data types algebraic?
06:42:59 <Orbstheorem> ski: https://paste.gnugen.ch/raw/OWon
06:43:18 <ski> lyxia : hm. if augustss were around, he'd probably either know, or know who to ask
06:44:48 <ski> Orbstheorem : and error ?
06:45:03 <p0a> lyxia: probably one of the references of https://dl.acm.org/doi/10.1145/1238844.1238856
06:45:39 <ski> merijn : any insight into the above issue (see yahb example), which presumably happens because of `AllowAmbiguousTypes' ?
06:45:58 <lyxia> that one does't say :) it does say that the idea of the thing came from the HOPE language, but that's not what they called it.
06:46:52 <merijn> ski: No, because I consider AllowAmbiguousTypes and TypeApplications the devil, so I never run into those :p
06:46:55 <p0a> lyxia: what was it called?
06:47:16 <ski> merijn : "know your enemy" ? :)
06:47:41 <Orbstheorem> ski: I've added the error message: https://paste.gnugen.ch/raw/Uuv1
06:49:33 <p0a> In Maybe a = Nothing | Just a, how is `Maybe' different than `Just' (their type)?
06:49:51 <p0a> I know I'm getting confused here, but which of the two is * -> *?
06:50:30 <p0a> Oh nevermind, I think I get it. `Just :: Int -> Just Int' is in fact different than * -> *
06:50:48 <p0a> I should've said, `Just :: Int -> Maybe Int'.
06:50:52 <lyxia> p0a: that language didn't call it anything in particular, the idea of user-defined data types with exhaustive case analysis was spectacular enough, probably.
06:50:54 <merijn> p0a: "* -> *" talks about types
06:51:39 <p0a> lyxia: maybe read on HOPE then. Somebody who looked at HOPE must've called it something ...
06:51:55 <ski> Orbstheorem : ok. there's something i don't understand happening, due to `AllowAmbiguousTypes' i think (see yahb examples above). i'd suggest to use a proxy
06:53:01 <Orbstheorem> It works with proxy.
06:53:55 <ski> Orbstheorem : i think it's not passing a polymorphic `fn1', but rather attempting to monomorphize it, but not completely sure. i'm not sure about the reason it's doing that, if it's a bug or current limitation or if it's running into an inherent issue with `AllowAmbiguousTypes'
06:54:50 <lyxia> p0a: yeah that's the plan. I was just taking a chance if someone had easy answers.
07:00:05 <ski> lyxia : not an answer to your question, but i tend to associate the term "algebraic data type" with two ideas :
07:00:24 <ski> (a) there's an "algebra" of types (a rig / semiring, and then more stuff), like `Maybe a = 1 + a',`[a] = 1 + a * [a]',&c.
07:01:50 <ski> (b) `F'-algebras (where `F' is a functor). e.g. a value of type `F a -> a' (together with the type `a') is an `F'-algebra, and `cata :: Functor f => (f r -> r) -> (Mu f -> r)' expresses the unique morphism from the initial `f'-algebra `(Mu f,In)' to any `f'-algebra `(r,phi)', where `In :: f (Mu f) -> Mu f' and `phi :: f r -> r'
07:02:56 <ski> (`cata phi :: Mu f -> r' would be the initial morphism)
07:02:57 <lyxia> ski: yeah that's also what I associate that to, and I was somehow getting bothered with the prominence of (a) because I somehow remember reading that (b) or something else is the actual origin.
07:03:49 <ski> i don't know whence the term originated, and which, if any, of those they had in mind
07:03:50 <lyxia> Note I asked that via mailing list a few weeks ago, I'm kinda surprised at the lack of answers. https://mail.haskell.org/pipermail/haskell-cafe/2020-August/132588.html
07:04:14 <p0a> lyxia: it shouldn't be too hard to track it down
07:04:18 <p0a> if you have access to journals 
07:04:45 <p0a> pick up a random article that mentions algebraic data types, see if it references the term (for example https://repository.upenn.edu/cgi/viewcontent.cgi?article=1774&context=cis_papers does) and then go down the rabbit hole
07:05:19 * hackage ipython-kernel 0.10.2.1 - A library for creating kernels for IPython frontends  https://hackage.haskell.org/package/ipython-kernel-0.10.2.1 (VaibhavSagar)
07:05:19 <p0a> lyxia: note that the above paper says `algebraic data types or regular types'
07:05:39 <p0a> if all else fails you can e-mail some of the authors of these papers and ask them if they know :P
07:06:19 * hackage ihaskell 0.10.1.2 - A Haskell backend kernel for the IPython project.  https://hackage.haskell.org/package/ihaskell-0.10.1.2 (VaibhavSagar)
07:06:53 <ski> examples of irregular data types would be `data SkipList a b = Nil | Cons a (SkipList b a)' and `data PerfectlyBalancedBinaryTree a = Values a | Double (PerfectlyBalancedBinaryTree (a,a))'
07:08:23 <p0a> lyxia: I should also note that your e-mail asks not just about the origin of the name, but also the meaning of the name. The second question may have a partial answer here, https://stackoverflow.com/questions/16770/haskells-algebraic-data-types
07:08:32 <lyxia> p0a: well I did do that for a couple but all point back to HOPE and don't discuss etymology. at best, they use one of the interpretations ski mentioned above but don't say whether it's their own or where they learned it from.
07:09:26 <lyxia> At the moment the direction David Duke pointed me to in that mailing list thread is the one I haven't gotten around to explore yet.
07:10:43 <p0a> Well they must've learned it from research papers, at some point. So if you can track down someone who has participated in related reserach you can e-mail them
07:10:52 <lyxia> p0a: I would expect that whoever first called it that also explained why they did so I think the questions are kind aequivalent.
07:14:03 <lyxia> anyway if you want to make more suggestions, let's move to -offtopic
07:15:05 <ski> p0a : i see some people confusing "ADT" as standing for "Algebraic Data Types", with it standing for "Abstract Data Types", on that SO post
07:17:34 <p0a> Oh yeah indeed. lol
07:20:51 <sm[m]> AbsDT vs AlgDT
07:56:45 <ADG1089> does this company look good for jobs: https://www.glassdoor.co.in/Overview/Working-at-Xoken-Labs-EI_IE2321503.11,21.htm
08:34:33 <merijn> hmm, why doesn't containers have traverseWithKey_
08:35:22 <merijn> I guess it's easier to just to toList and then traverse the resulting list
08:45:51 <AWizzArd> Trying to send email securly via AWS smtp. Works well when I set `sslDisableCertificateValidation = True`. With cert validation turned on however I get a  HandshakeFailed (Error_Protocol ("certificate has unknown CA",True,UnknownCa))
08:45:58 <AWizzArd> Using HaskellNet-SSL.
08:46:37 <merijn> AWizzArd: Presumably you need to specify which CAs/roots are trusted
08:46:42 <AWizzArd> Could this be due to an older GHC (8.6.4 from May 2019 I think)?
08:47:14 <merijn> AWizzArd: Short answer: No
08:47:14 <glguy> I'd agree with merijn, but that doesn't appear to be an exposed possibility in that library
08:47:47 <AWizzArd> Under the hood HaskellNet-SSL is using the packages  connection, network and tls.   Are you aware if the certs can be trusted with any of these?
08:47:48 <merijn> HaskellNet-SSL is...not something I would rely on anyway
08:48:12 <AWizzArd> merijn: which lib would you use to send secure mail via smtp?
08:49:19 <monochrom> That is a bit open-ended because there are several incompatible ways.
08:49:35 <merijn> Well, first I would just entirely abandon the notion of "secure" and "email" and in all honesty I would probably use some service like mailchimp to handle mass emails, because trying to get your own email delivered reliably is...a neverending journey of pain
08:50:24 <merijn> Which is probably not what you wanted to hear, but yeah...
08:50:35 <AWizzArd> glguy: my best guess is that the `tls` package might support this. I agree that HaskellNet-SSL directly doesn't have obvious support for this.
08:51:22 <monochrom> One way is smtp over TLS. Another is called STARTTLS which looks like without TLS for the initial handshaking and then suddenly it becomes TLS upon client command.
08:52:14 <monochrom> The latter seems to be more common. All my mail providers do that.
08:52:57 <glguy> AWizzArd: I think setting up the CAs is done in the connection package automatically. If it's not working then the default location the connection package finds certificates might not be populated on your system (a guess). What OS are you on?
08:53:17 <glguy> I avoid uses of the `tls` and `connection` package
08:53:51 <nshepperd2> i personally would use the command line sendmail program, instead of a library
08:53:54 <merijn> monochrom: Yeah, but getting your mail to actually arrive takes so many more steps :)
08:54:26 <merijn> nshepperd2: That has the same issues, of "most major mail providers don't just randomly accept all email from anybody"
08:54:29 <monochrom> As usual, "we assume" that some library already covers the smtp part.
08:54:45 <monochrom> Yeah that's wise too.
08:55:02 <monochrom> But Windows.
08:55:10 <merijn> monochrom: No, I meant in the sense of all the anti-spam measures you need to be aware of so your email doesn't just get dropped/junked/etc.
08:55:19 <AWizzArd> glguy: I'm running this in a docker image.
08:55:21 <monochrom> Oh, that.
08:55:33 <nshepperd2> well, sendmail can at least be configured to make it work
08:55:35 <glguy> AWizzArd: Oh, then you probably just need to install the CA certificates package in the image
08:55:48 <AWizzArd> glguy: sounds reasonable, I will have a look
08:55:56 <merijn> nshepperd2: Anything can be, but my experience when I was indeed doing that myself is that you don't want too :p
08:56:10 <monochrom> I think there is nothing a sending client can do.
08:56:12 <nshepperd2> eg. you can configure it to relay emails through your gmail account
08:57:24 <monochrom> OK I'm living is a spoiled world where my client talks to my school server or ISP server. Those  servers do the real sending, and they add the signatures etc for anti-spam.
08:57:40 <monochrom> And their sysadmins try to stay off blacklists.
08:57:56 <merijn> monochrom: Yeah, hence my recommendation of "just pay someone to deal with that shit" :p
08:58:28 <merijn> monochrom: Plenty of bulk emailing services that presumably have convenient APIs to talk too
09:00:34 <gentauro> Starting at 18:00 «Sixten: Unboxed Functional Programming. Talk by Olle Fredriksson» https://meet.jit.si/mfk :)
09:17:02 <efm> Hello. The IHaskell ghc version is far behind the Ubuntu 20 ghc version. This is a blocker for getting cocalc juypter notebook support working. The IHaskell project is at https://github.com/gibiansky/IHaskell
09:18:15 <efm> thank you in advance for your help and attention. The toil of packaging is often not seen as glamourous as new developement, but it is very valuable, because it makes it possible for people to use all the tools.
09:24:13 <testtesttest> @help
09:24:13 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
09:24:22 <monochrom> You may need to email the IHaskell people. I don't think they're here.
09:25:09 <testtesttest2> @help
09:25:09 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
09:25:18 * ski looks at testtesttest and testtesttest2
09:27:50 <sm[m]> are you working on updating the packaging efm ? Anything specific you're stuck on ?
09:29:40 <merijn> Is anyone aware of an attoparsec parser for date formats?
09:32:16 <efm> sm[m]: I'm not working on updating the packaging, but getting IHaskell to the same version as ghc would make the ecology work.
09:33:14 <efm> sm[m]: the Ubuntu system version is just so much newer than the IHaskell version, that they really can't be installed together without a lot of skill on the part of the user.
09:42:19 <AWizzArd> glguy: I will test this. Indeed, I see that /usr/share/ca-certificates does not exist in the Docker image. So that certainly sounds like a plausible cause.
09:42:22 <sm[m]> efm: yes indeed. I guess you're trying to motivate someone to work on it
09:42:30 <AWizzArd> glguy: good idea, thx!
09:57:08 <efm> sm[m]: yes. For someone familiar with GHC it is likely a small task. That the notebook and the system have different ghc's is a 'trip hazard'.
09:57:59 <efm> sm[m]: the solutions recommended on the IHaskell github (remove your system ghc) are not available for users who do not have root.
09:58:15 <dolio> It seems like it'd be more appropriate to bring this up on the github page where people are actively working on it.
09:58:32 <efm> dolio: they are not, from what I can tell, working on it
09:58:36 <monochrom> Yeah, like I said, I think the IHaskell people are not here.
09:58:44 <dolio> efm: There was a commit 3 hours ago.
09:59:19 <dolio> This is just a chat room for people to talk about Haskell.
09:59:21 <monochrom> Do you know because you posted an issue on github a month ago and no reaction?
09:59:48 <sm[m]> efm: it seems not a lot of ihaskell users hang out here, so you're not having much luck. Have you though of posting a bounty 
10:00:18 <monochrom> Meanwhile, I wonder if playing with PATH is a simple workaround.
10:00:20 <efm> dolio: that commit was a minor version number update. I'm not saying IHaskell is defunct, I'm suggesting they may have run into issues with updating ghc and may need help.
10:01:38 <sm[m]> essentially, nobody here has time to help ihaskell except ihaskell users. Probably if more of us could install ihaskell easily, there'd be more users here. So yes it's chicken and egg
10:03:01 <monochrom> or bounty hunters
10:13:32 <sm[m]> PS I doubt it's really a "small task". You are quite right that packaging is both valuable, and toil.
10:15:31 <sm[m]> if not a bounty, you could learn to do it yourself, because one thing this channel does have lots of time for is helping folks who are rolling up their sleeves :)
10:16:10 <monochrom> and folks who are not.
10:17:32 <sm[m]> yep, both. We'd rather spend weeks teaching someone to fish than a day catching a fish for them
10:17:55 <sm[m]> I'm not sure it makes sense but there it is
10:19:34 <ski> @remember sm[m] <sm[m]> [..] We'd rather spend weeks teaching someone to fish than a day catching a fish for them  <sm[m]> I'm not sure it makes sense but there it is
10:19:34 <lambdabot> It is forever etched in my memory.
10:20:14 <argent0> Hi, is there a function for the pattern `case someList of; [] -> foo; (x:xs) -> bar` ?
10:21:12 <monochrom> No.
10:21:24 <monochrom> Apart from foldr but foldr has restrictions on bar.
10:21:40 <argent0> monochrom: ok, thanks
10:22:48 <monochrom> I think a cause is most list functions walk the whole list, and most of them are already composable from Data.List functions.
10:23:16 <monochrom> where "most" is weighted by actual writing and actual use
10:24:54 <dolio> Also, how much better is a function going to be than that case statement?
10:25:44 <argent0> monochrom, dolio: I'll show the actual code in a bit, but the last statement ends up being `bar -> bar`
10:27:13 <monochrom> In that case may I entice you with listToMaybe combined with maybe so it's a bit of an XY problem but it can be pointfree? :)
10:28:18 <argent0> https://gist.github.com/argent0/36ceafbdaf1ad57ab76ebdd44b382e30
10:29:21 <argent0> Yeh, I though that ther might be a haskell-idiomatic way to do it and wanted to ask.
10:29:30 <dolio> What's the problem with this?
10:29:38 <argent0> s/ther/there/
11:03:44 <tomsmeding> efm: there was arguably non-trivial activity on IHaskell only two weeks ago: https://github.com/gibiansky/IHaskell/commit/ff3872b532d20084e2de991b8b576d3ef8cd8b52
11:04:44 <tomsmeding> I do suggest reaching out to the project in question, and asking for help regarding building with GHC 8.10; someone might have tried this before :)
11:11:47 <merijn> So...attoparsec date parsers...anyone got any pointers?
11:11:53 <tomsmeding> hyiltiz: to produce the ChangeLog.md file in pastebin-haskell I just copied a clean version from 'cabal new' in a random directory; this copying was slightly too literal apparently https://github.com/tomsmeding/pastebin-haskell/commit/85f88eb5a59b9f1b48c88709ae37520c65e9b57a
11:13:00 <merijn> Kind of a cheesy mistake...
11:13:04 <merijn> *rimshot*
11:13:23 <MarcelineVQ> you, killed him
11:13:42 <tomsmeding> okay so maybe "random" was not all that random
11:13:45 <tomsmeding> (:
11:18:57 <efm> tomsmeding: yes, but I don't see any activity on IHaskell regarding the more recent ghc
11:33:18 <hc> hi all, looks like i'm going to start a new commercial project in haskell soon; looking for a bit of sustainability/longliving package releases. what'd you recommend? stack? nix? cabal? :)
11:38:27 <juri_> hc: we're stack based at $dayjob, butt most of our employees are nix based at night.
11:42:08 <hc> juri_: any reasons (logical, political or otherwise) why you're on stack and not something else? ;)
11:42:47 <juri_> probably just inertia.
11:42:49 * hackage proto-lens-jsonpb 0.2.0.2 - JSON protobuf encoding for proto-lens  https://hackage.haskell.org/package/proto-lens-jsonpb-0.2.0.2 (rewinfrey)
11:43:12 <hc> juri_: you mean if you had to start over, you'd use nix instead?
11:43:40 <juri_> I'd probably use cabal, but i like living dangerously. :)
11:45:00 <hc> hmm, okay :) I'd prefer to code once, forget forever ;p
11:46:53 <hyperisco> hc, amen
11:52:18 <hyiltiz> Do some channels actively disconnect you if you just join but not talk for a long time?
11:52:49 * hackage hercules-ci-agent 0.7.4 - Runs Continuous Integration tasks on your machines  https://hackage.haskell.org/package/hercules-ci-agent-0.7.4 (RobertHensing)
11:52:53 <glguy> hyiltiz: #haskell certainly doesn't
11:53:25 <hyiltiz> yeah but I've been disconnected by a bunch of those and am wondering if that is a setting open to channel OPs
11:53:29 <glguy> nope
11:54:20 <monochrom> Of the dozens of intermediate hops between your computer and #haskell, you put too much weight on #haskell.
11:54:21 <hyiltiz> Hmm; I got DCed from #emacs, #debian, ##electronics and #python too often...
11:54:53 <glguy> hyiltiz: Your ping timeouts are likely due to instability of your ISP, router, computer, etc.
11:58:45 <hc> hyiltiz: against DCC you can set user modes +g and/or +R; some channels use bots to kick idle users, but i've never seen it on freenode
11:59:07 <hc> oh, wait, you said DC. what does DCed mean?
11:59:32 <hyiltiz> DisConnect
11:59:47 <hc> ah. disconnected, probaly. hmm. you don't get disconnected from individual channels, but from the irc network as a whole. this does not happen you idle on a channel. perhaps your irc client doesn't respond to PING requests?
12:00:31 <hc> (all standard ones do)
12:00:35 <hyiltiz> not sure; I am using quasselcore running in a VPS and I am connecting via QuasselClient from my laptop and phone
12:01:49 <hc> according to the backlog, i'd say you've (had?) simply got an unstable connection between your VPS and the freenode servers; I wouldn't worry about it too much unless you disconnect dozens of times per day
12:09:31 <hyiltiz> Ok; I was getting disconnected a few times a day on those channels specifically (e.g. never from #haskell, #latex or #kde) I just turned off a few systemd services that might have been overloading CPU
12:10:02 <hyiltiz> tomboy65: https://paste.tomsmeding.com/fITrO3pU <-- Do folks think this is now ready for official adoption?
12:14:24 <hyiltiz> tomsmeding: should've been this tom* boy sorry
12:18:57 <tomsmeding> I think it's stable enough? hosting it on my domain is questionable though :p
12:19:46 <tomsmeding> also currently it doesn't keep more than ~128MB of pastes available, beyond that it just forgets stuff; that is not necessarily the model an official paste service may want
12:20:09 <tomsmeding> but not having such a cutoff poses disk space issues, and in particular for my server that is a problem :p
12:22:05 <tomsmeding> hyiltiz: does your irc client not choose the nick that spoke last when autocompleting? :p
12:23:09 <hyiltiz> I simply did tom<TAB>; no idea how the autocomplete got that idea; pretting tom<TAB> now gives tomsmeding though
12:23:58 <hyiltiz> did someone mention he'd be willing to host if someone else implements? :P
12:25:21 <tomsmeding> I seem to remember someone 🤔
12:27:16 <sm[m]> ha ha I was just catching up with intent to reply :)
12:28:49 * hackage twirp 0.2.0.1 - Haskell twirp foundations  https://hackage.haskell.org/package/twirp-0.2.0.1 (rewinfrey)
12:31:00 <dminuoso> nh2: By the way, getting my project to build with static-haskell-nix is somewhat of an adventure. It's sadly not some "flip a switch and everything works out" solution.
12:31:02 <sm[m]> tomsmeding: this isn't a very compelling production-ready pastebin yet, that I would use myself, but it does have the great strength of being owned by a responsive #haskeller and likely to improve. Based on our previous chat I'll host it for some period of time if you want. But, wouldn't you consider continuing to host yourself as you've already begun ? The shorter path between developer and operator is also a great help I
12:31:03 <sm[m]> find
12:31:04 <dminuoso> And that's quite sad. :(
12:31:11 <dminuoso> I really want static compilation with GHC to be simple.
12:31:44 <maerwald> dminuoso: ha-ha
12:31:58 <maerwald> the complication might be that you use nim
12:32:02 <maerwald> *nix
12:32:07 <maerwald> while it's a lot simpler
12:32:26 <nh2> dminuoso: the ghc part is quite simple, the key issue is that you need system library .a files provided
12:33:03 <nh2> dminuoso: what are your dependencies, which parts are not smooth?
12:33:57 <maerwald> dminuoso: https://github.com/actions/setup-haskell/issues/31#issuecomment-676001831
12:34:16 <tomsmeding> sm[m]: re:shorter path: that's true
12:34:55 <tomsmeding> mostly the reason why I was asking for someone else to host it is the disk space thing
12:35:12 <tomsmeding> I have only a few GB's of free space on this VPS :p
12:35:28 <sm[m]> tomsmeding: whoever hosts, I think an important next thing to work on could be discoverability/url
12:35:53 <sm[m]> you could limit it to small pastes ? No reason to host massive files
12:36:39 <tomsmeding> sure I could limit it to small pastes (in fact I do limit paste size at the moment, but the limit is fairly high), but basically my point is: what's to prevent someone from spamming the thing :p
12:36:46 <tomsmeding> though that's hard to solve with more disk space
12:37:07 <sm[m]> that's part of building a pastebin ;)
12:37:12 <tomsmeding> hehe fair point
12:37:36 <tomsmeding> with "url", do you mean a domain name that's better than it currently is?
12:37:40 <sm[m]> Well, what could be a cheap solution. Pastes auto expire in 24h ?
12:37:50 <sm[m]> yup
12:38:06 <sm[m]> what's the current one, again ?
12:38:06 <tomsmeding> domain names aren't free :p
12:38:12 <tomsmeding> @where paste3
12:38:12 <lambdabot> tomsmeding's proof that programming > discussing: https://paste.tomsmeding.com/
12:38:13 <tomsmeding> iirc
12:38:45 <tomsmeding> I mean I can do limiting per source IP, that would probably help
12:38:59 <dminuoso> maerwald: Thanks, we may experiment with that.
12:39:27 <sm[m]> that's a pretty good one for now maybe
12:39:33 <maerwald> I mean, alpine is a boring distro... but it's not hard to debug/fix.
12:39:50 <maerwald> nix is hard to fix :)
12:42:41 <tomsmeding> sm[m]: what's a reasonable paste size limit, 64k?
12:43:44 <sm[m]> how long is a piece of string.. sure that'd be plenty 97% of the time
12:45:27 <sm[m]> you could leave high limits until the problem actually arises. Plus overall OS enforced limits for the app, as a backstop
12:47:39 <dminuoso> nh2: Im not even sure. For some reason libgmp has unresolved symbols against ssp symbols, I suppose my main problem is that Im just poking in the dark.
12:48:06 <tomsmeding> dminuoso: I randomly know that gmp is very well buildable to a static library, because I've done so in the past
12:48:53 <dminuoso> Well, actually there's tons of such errors.
12:55:14 <nh2> dminuoso: could you post me the errors on the issue tracker?
13:13:57 <ixlun> If I'm doing a filter like this: filter (predicate a b) list, how do I 'not' the predicate?
13:14:25 <koala_man> not . predicate a b
13:14:27 <ixlun> doing filter (not $ predicate a b) list dosen't work
13:15:19 * hackage extra 1.7.7 - Extra functions I use.  https://hackage.haskell.org/package/extra-1.7.7 (NeilMitchell)
13:16:12 <ixlun> Huh, yeah 'not .' worked.  I think I need to study the difference between '.' and '$'
13:16:42 <merijn> :t (.)
13:16:43 <lambdabot> (b -> c) -> (a -> b) -> a -> c
13:16:44 <merijn> :t ($)
13:16:45 <lambdabot> (a -> b) -> a -> b
13:17:08 <merijn> :t (.) `asAppliedTo` not
13:17:09 <lambdabot> (Bool -> Bool) -> (a -> Bool) -> a -> Bool
13:17:14 <merijn> :t ($) `asAppliedTo` not
13:17:15 <lambdabot> (Bool -> Bool) -> Bool -> Bool
13:17:42 <merijn> wait, I guess I should've just used
13:17:47 <merijn> :t ($) not
13:17:47 <lambdabot> Bool -> Bool
13:17:51 <merijn> :t (.) not
13:17:52 <lambdabot> (a -> Bool) -> a -> Bool
13:19:05 <ixlun> Right, so $ expects another Bool and it will flip that.  However, '.' wil then take a function that produces a Bool and flips the result
13:21:20 <monochrom> Apples and oranges. That's the difference.
13:22:08 <monochrom> But the best way to understand is to put back the parentheses.
13:23:25 <monochrom> "(f . g . h) $ x" vs "f $ (g $ (h $ x)" will focus you on what . really means and what $ really means.
13:23:58 <monochrom> The road to "how do I get rid of parentheses?" begins with respecting parentheses.
13:24:48 <dminuoso> nh2: My problems are essentially: "How do I even?" - I have a .cabal file, and I depend on libargon2 (via libsodium) and postgresql. How do I make a static blob?
13:25:08 <dminuoso> The more I progress, I just find random bits on the issue tracker with quite convoluted nix expressions
13:31:51 <ixlun> Thanks for the info monochrom, I'll at what you've written and see if I can grok it
13:33:31 <hekkaidekapus> merijn: Did you find something for your quest as of 18:11 UTC?
13:33:37 <merijn> hekkaidekapus: Not yet
13:33:56 <merijn> Admittedly, because I haven't looked very hard since then :p
13:33:58 <hekkaidekapus> attoparsec-iso8601?
13:34:24 <merijn> hah, perfect
13:34:39 <hekkaidekapus> o/
13:54:09 <L29Ah> yay i deserialized my messagepack with generics-sop! https://github.com/l29ah/hyborg/blob/master/Types/Generics.hs#L33
13:57:35 <glguy> L29Ah: Have you already tried just using normal generics?
13:57:53 <L29Ah> yes
13:58:58 <L29Ah> their tree-like structure of a type representation is a pain to deal with
14:01:15 <glguy> the result usually ends up more understandable though
14:02:49 * hackage shake-plus-extended 0.4.0.0 - Experimental extensions to shake-plus  https://hackage.haskell.org/package/shake-plus-extended-0.4.0.0 (locallycompact)
14:13:18 <dminuoso> maerwald: Ah I think I know the solution. My hate was with docker for building the static haskell images.
14:13:38 <dminuoso> But, I dont need that. I can just spool up a vm running alpine and put a gitlab-ci runner on it.
14:14:03 <dminuoso> That would address caching issues as well, since I can just run v2-build in my build jobs
14:14:14 <dminuoso> It would be fast, and avoid all kinds of docker issues
14:14:21 <monochrom> :)
14:14:33 <monochrom> My TA made me use docker.
14:14:34 <maerwald> now you have gitlab-ci issues, yay
14:14:44 <dminuoso> Well, we have gitlab-ci either way.
14:14:50 <dminuoso> And gitlab-ci is not so bad
14:15:25 <maerwald> software = shit1 <|> shit2
14:15:30 <dminuoso> heh
14:16:06 <dminuoso> Gonna be funny, as soon we'll have nixos build nodes, centos and alpine..
14:18:04 <monochrom> My context: Running student code for test-based marking. I think my TA chose docker for some kind containment. Personally I am more sledgehammer and use a wholesome virtualbox when I want containment.
14:19:12 <monochrom> Is my 1st-order approximation OK?  docker = chroot jail + other features and setups
14:19:24 <maerwald> I've found so far one use case in haskell industry for nix: a proprietary embedded system with parts of haskell, where the customer needs a way to precisely reproduce the entire build. Except... it didn't even use nix, but some other tool that does the same
14:19:30 <maerwald> (and had better support)
14:20:11 <dminuoso> maerwald: no
14:20:15 <dminuoso> Err monochrom: no
14:20:47 <monochrom> Ah, what does containerd do? Is it the workhorse behind docker?
14:20:49 <dminuoso> monochrom: the isolation happens with namespaces.
14:20:55 <dminuoso> containerd oh! thats another horse.
14:21:12 * monochrom cries. What's "namespace" doing on unix?
14:21:25 <dminuoso> monochrom: essentially kernel virtualization
14:21:39 <merijn> monochrom: linux' attempt at reinventing jails/solaris zones
14:21:40 <dminuoso> (e.g. namespaces lets you isolate pids)
14:21:59 <merijn> monochrom: But like always whenever they crib from BSD and Solaris they fuck it up and make it messier and more confusing
14:22:07 <dminuoso> monochrom: furthermore, docker uses cgroups for resource allocation
14:22:08 <monochrom> Interesting. My old mental model is broken. :)
14:22:26 <maerwald> merijn: how can one make BSD messier, I'm confused
14:22:45 <merijn> maerwald: BSD's engineering is order of magnitude better than linux
14:22:52 <merijn> maerwald: So, easily, apparently
14:22:58 <dminuoso> monochrom: https://medium.com/@BeNitinAgarwal/understanding-the-docker-internals-7ccb052ce9fe
14:23:04 <dminuoso> Apparently good medium articles exist.
14:23:14 <dminuoso> This is a good sketch of what docker is built with
14:24:25 <monochrom> Ah I think my TA is using the NET namespacing part. The assignment is a TCP socket assignment.
14:26:18 <glguy> L29Ah: You get something like this: https://gist.github.com/glguy/537913c20e62dfa7dbb10cdc8418a1f1
14:29:54 <L29Ah> glguy: yeah, it's not that bad when you don't also need to account for the position of the field in the type declaration, like in
14:29:55 <L29Ah> https://github.com/TokTok/hs-msgpack-types/pull/34/files
14:29:56 <L29Ah> where i had to bring StateT
14:31:10 <L29Ah> after that i decided to look into generics-sop
14:31:27 <nh2> dminuoso: Yes, I think I understand your "How do I even?" feeling quite well, I went through a lot of it when working on that stuff. Now that I understand a lot more about it, I try to remove as much of that as possible, but there are still some issues that make it less smooth than should be. For example with postgres, where the pkg-dependencies are not propagated fully automatically.
14:31:29 <L29Ah> hopefully all this type-level meddling made me a better haskell programmer (:
14:31:57 <glguy> generics-sop usually feels write-only to me, too many special combinators to have to know/understand
14:32:24 <nh2> dminuoso: is your project open-source btw? I had a quick look and libargon2 already has .a files available, so that by itself should not be a blocker. (I'm not sure I've seen the gmp errors though that you spoke of.)
14:32:36 <L29Ah> yeah, i tried to write explicit recursion and failed miserably
14:32:37 <glguy> with generics I only have to remember the names that correspond to ADT structures
14:32:45 <nh2> dminuoso: If it is open-source I might give a quick shot at building it myself
14:34:00 <phadej> glguy: you can pattern match on NS and NP explicitly too
14:34:20 <phadej> glguy: if you like "manual plumbing approach" (GHC.Generics doesn't really give you a choice)
14:34:41 <glguy> phadej: what's the payoff then?
14:35:53 <glguy> I guess the answer is that you wouldn't have to fit things into a typeclass
14:35:56 <argent0> Hi, is Data.Scientific dense?
14:36:15 <phadej> glguy: if you need a constructor's index (whether it's 1st or 2nd...) it will be a 2 line function (for Z and S cases), with GHC.Generics you need a much more boilerplate
14:36:29 <hyiltiz> I love haskell. Why?
14:36:37 <hyiltiz> % length (2,3)
14:36:37 <yahb> hyiltiz: 1
14:36:38 <phadej> argent0: don't use Data.Scientific for calculations
14:36:47 <argent0> as in is it good for money values? (I'm aware of safe-money)
14:36:56 <phadej> No
14:37:12 <argent0> jesh, thanks
14:37:18 <L29Ah> hyiltiz: because Traversable instance for tuples is garbage
14:37:33 <glguy> phadej: the indexes are easy enough to access, but I definitely see the benefit of not needing to use a typeclass to guide computation, the minor downside is you need a bunch more machinery to get all the class constraints around
14:38:21 <tomsmeding> % let 2 + 2 = 5 in 2 + 2  -- hyiltiz
14:38:21 <yahb> tomsmeding: 5
14:38:22 <hyiltiz> length 2, length (2), length (2,3,4) all fails
14:38:54 <merijn> hyiltiz: It follow from Foldable
14:38:55 <hyiltiz> tomsmeding: oh I didnt know that trick LOLOLOL
14:39:05 <merijn> L29Ah: Hard disagree
14:39:15 <hyiltiz> why there isnt foldable instances for (,,) and more?
14:39:18 <merijn> Arguably making length a part of Foldable is garbage
14:39:21 <hyiltiz> if there is one for (,)
14:39:32 <merijn> hyiltiz: heretical unbelievers like L29Ah objecting to them :p
14:39:47 <nh2> argent0: for money values: https://cs-syd.eu/posts/2020-07-28-how-to-deal-with-money-in-software
14:39:51 <phadej> glguy: yes, with GHC.Generics it is cool that you can ask for things when you need them, and not up front.
14:39:51 <tomsmeding> well first you'd need to choose a tuple element to consider "special"
14:40:02 <tomsmeding> choosing the second element of a pair is already questionable, but sort-of fine
14:40:10 <merijn> tomsmeding: You don't have to, it follows directly from the types
14:40:14 <phadej> but otoh, https://www.kosmikus.org/StagedSOP/staged-sop-paper.pdf is elegant with generics-sop, and would be very ugly with GHC.Generics-like approach
14:40:16 <hyiltiz> feel like a case where u either invite em all in or drive em all out; all tuples are created equal.
14:40:17 <merijn> tomsmeding: In fact, you can't even choose :p
14:40:19 <argent0> nh2: thanks, i'll check that out
14:40:20 <L29Ah> yeah it's Foldable indeed
14:40:24 <tomsmeding> oh heh
14:40:28 <tomsmeding> of course
14:40:40 <tomsmeding> okay that makes it less bad
14:40:46 <merijn> argent0: Sounds you wanna learn about Data.Fixed :p
14:41:08 <merijn> argent0: Which gives you exact fixed precision
14:41:23 <merijn> > 0.3 + 0.3 :: Fixed Deci
14:41:24 <lambdabot>  error:
14:41:24 <lambdabot>      Ambiguous occurrence ‘Fixed’
14:41:25 <lambdabot>      It could refer to
14:41:28 <phadej> money, time, filepath, human names, unicode
14:41:31 <argent0> my _real_ issue is that I have json: { amount : 1212312412421341.12 } and Data.Aeson uses Data.Scientific and I'm worried about data loss
14:41:32 <merijn> Or is it just Deci?
14:41:37 <phadej> like, everything in computing is difficult :(
14:41:38 <merijn> > 0.3 + 0.3 :: Deci
14:41:40 <lambdabot>  0.6
14:41:43 <merijn> There we go
14:41:46 <argent0> merijn: I'll check that out too
14:41:47 <merijn> > 0.3 + 0.3 :: Centi
14:41:49 <lambdabot>  0.60
14:41:55 <tomsmeding> hyiltiz: all tuples are certainly not created equal https://hackage.haskell.org/package/base-4.14.0.0/docs/src/GHC.Show.html#line-242
14:42:16 <dolio> Data.Scientific appears to be base 10 floating point.
14:42:54 <phadej> argent0: as long as your money values are finitely representatble as base 10 decimal numbers, conversion to and from Scientific will be lossless
14:43:05 <phadej> otherwise you'll get runtime exception
14:43:10 <hyiltiz> Still reading StagedSoap paper; nice colors but too long and too dense to skim thru for me to do follow up comments about it (was it even about foldable tuples?)
14:43:10 <phadej> % 1/3 :: Scientific
14:43:10 <yahb> phadej: ; <interactive>:136:8: error: Not in scope: type constructor or class `Scientific'
14:43:16 <phadej> % 1/3 :: Data.Scientific.Scientific
14:43:16 <nh2> argent0: the library recommended at the end of the blog post, `safe-decimal`, is like Data.Fixed but with additional type-level and runtime-level safety features
14:43:16 <yahb> phadej: ; <interactive>:137:8: error:; Not in scope: type constructor or class `Data.Scientific.Scientific'; No module named `Data.Scientific' is imported.
14:43:29 <phadej> % import qualified Data.Scientific
14:43:29 <yahb> phadej: ; <no location info>: error:; Could not find module `Data.Scientific'; It is not a module in the current program, or in any known package.
14:43:31 <phadej> :(
14:43:40 <phadej> well, try that (1/3 :: Scientific)
14:44:09 <phadej> TL;DR Scientific is data representation type (like `Value` in aeson), not a type you do business logic with
14:44:14 <argent0> nh2, phadej: Thanks very much
14:45:04 <phadej> data as on the wire
14:45:21 <phadej> but otoh, JSON for money is a red flag to me as well
14:45:43 <hyiltiz> https://hackage.haskell.org/package/base-4.14.0.0/docs/src/GHC.Show.html#line-242 says nothing about tuple rights
14:46:03 <hyiltiz> from that it seems like all tuples indeed are equal tho
14:46:12 <dminuoso> nh2: Asked differently, what is the general protocol for building XYZ statically with static-haskell-nix?
14:46:36 <L29Ah> phadej: do real™ professionals use XML for money?
14:46:37 <dminuoso> Do I need to add my package to survey? Can I somehow inject my package into it via overrides? 
14:47:29 <phadej> L29Ah: I'd bet Nubank uses EDN :)
14:47:39 <phadej> e.g. whatever floats your boat
14:48:04 <phadej> JSON numbers are Doubles in many libraries, and Doubles for money are no-no
14:48:14 <phadej> so I'd encode them as strings
14:48:33 <phadej> with whatever lossless textual representation library (safe-decimal, e.g.) offers
14:49:22 <justsomeguy> (I think JSON (the spec) also supports integer, but JS doesn't, and who knows what the libraries support.)
14:50:16 <dminuoso> justsomeguy: the spec is actually very vague
14:50:44 <phadej> the spec grammar supports arbitrary precision number
14:50:49 <phadej> but 99% of libraries are crap
14:50:56 <dminuoso> "The representation of numbers is similar to that used in mostprogramming languages.  A number is represented in base 10 usingdecimal digits.  It contains an integer component that may beprefixed with an optional minus sign, which may be followed by afraction part and/or an exponent part.  Leading zeros are notallowed."
14:51:18 <phadej> so if you are not controlling all the systems producing and consuming your format built on top of JSON, I'd be very careful with using anything beyound what fits into IEEE754
14:51:19 <dminuoso> The phrasing is incredibly open to interpretation.
14:52:08 <justsomeguy> When they say number in that quote, they probably mean the "number" type, particularly.
14:52:17 <dminuoso> justsomeguy: JSON has nothing else.
14:52:51 <phadej> I understand that quote as 
14:52:52 <glguy> phadej: I don't know how to get the NP _ _ values yet, but the manually written version does come out nice side-by-side: https://gist.github.com/glguy/537913c20e62dfa7dbb10cdc8418a1f1#file-sop-hs
14:52:55 <phadej> The textual represnetation
14:53:17 <dminuoso> Yup, and JSON makes specifiction about what that even means.
14:53:20 <dminuoso> *no
14:53:31 <phadej> glguy:  https://hackage.haskell.org/package/generics-sop-0.5.1.0/docs/Generics-SOP-Universe.html#v:productTypeFrom
14:53:34 <dolio> You can write any number you want textually, but if it passes through JavaScript it's going to get stored in a Double. :)
14:53:52 <dminuoso> Essentially, when you have two systems exchanging numbers, they might interpret the data differently. And that's perfectly fine!
14:54:14 <phadej> yes, but so you can write any number in source code on virtually any language and it will be not necessarily be losslessly represented
14:54:19 <phadej> > 1111111111111111111111111111111111111 :: Int
14:54:21 <lambdabot>  -8190915148855348793
14:54:47 <phadej> JSON is just a grammar
14:54:49 <koala_man> in Go you can write a constant mathematical expression and get a different result than if the same expression was computed at runtime
14:54:50 <phadej> it doesn't have sematnics
14:55:10 <yushyin> koala_man: how so?
14:55:31 <nh2> dminuoso: You do not need to add it to survey. Survey contains nixpkgs overlays, one for each task of "replace glibc by musl", "add .a files to packages that don't have them", "fix Haskell libs that have issues with static linking", "make all known Haskell binaries static". They are applied one after another (with `.extend()`), returning a nixpkgs (`pkgs`) that has all those changes in.
14:55:31 <nh2> If the thing you desire to build is already covered by that, you can source it directly from it (e.g. `nix-build survey/default.nix -A pkgs.pandoc` gives you static pandoc).
14:55:31 <nh2> If it isn't, you can apply further overlays of your own that do things like adding Haskell packages or native libs.
14:55:32 <nh2> How familiar are you with nixpkgs overlays? Based on that I will explain further.
14:56:17 <glguy> phadej: What's the typeclass for things that have fields?
14:56:20 <justsomeguy> dminuoso: Doesn't it have "integer"? ... https://json-schema.org/understanding-json-schema/reference/numeric.html
14:56:26 <dminuoso> justsomeguy: No
14:56:40 <dminuoso> No idea what "JSON schema" is
14:56:51 <dminuoso> justsomeguy: https://tools.ietf.org/html/rfc7159#section-6
14:57:13 <phadej> glguy: it's still a Generic, but restricted to particular shapes of Code
14:57:14 <dminuoso> nh2: I understand the self/super style of an overlay and how it works
14:58:15 <glguy> phadej: Is there no compile time way to express that field selectors are required? Does it become a dynamic case on the ConstructorInfo then?
14:59:30 <koala_man> yushyin: Go defines numerical constants has having higher precision than the corresponding runtime operations
14:59:40 <justsomeguy> I get confused sometimes since I mostly interact with JSON through YAML, which has additional datatypes on top of JSON (it's a superset).
15:00:05 <phadej> glguy: there is lifted version: https://hackage.haskell.org/package/generics-sop-0.5.1.0/docs/Generics-SOP-Universe.html#t:DatatypeInfoOf
15:00:12 <phadej> but then you are in "singletons" realms
15:00:27 <dminuoso> justsomeguy: Essentially, if you want robust communicatable numbers, use IEEE754 interchange formats, put it into string, and then send it on the wire.
15:00:34 <phadej> I don't know if kosmikus wrote any helper type families to deal with those
15:00:47 <merijn> dminuoso: Except you can't parse that in haskell yet :p
15:00:53 <dminuoso> merijn: heh!
15:00:56 <yushyin> koala_man: ah, thanks
15:01:19 <merijn> dminuoso: I know, because I filed a bug report for GHC and I think the MR fixing it is just slowly trickling through
15:01:56 <dminuoso> justsomeguy: Here's my rephrasing of the JSON rfc regarding numbers: we vaguely define what numbers by saying: numbers are just like in any other programming language. the obvious thing!"
15:02:38 <justsomeguy> :D
15:02:59 <justsomeguy> "whatever visually looks like a number is a number, maannn"
15:03:06 <dolio> They define a textual notation for numbers at least. What any of the notation means seems to be undefined.
15:04:08 <dminuoso> Right.
15:04:17 <dolio> The notation is given precisely enough. :)
15:04:36 <phadej> that what I said, "JSON is a grammar, semantics are undefined"
15:06:54 <dminuoso> Presumably, a morally correct JSON parser would just hand you some `Number { hasMinus :: Bool, integerComponent :: Integer, fractionComponent :: Maybe Integer, exponent :: Maybe Integer }`?
15:07:09 <dminuoso> And then let you figure out what that means?
15:07:19 * hackage dobutokO-poetry 0.16.3.0 - Helps to order the 7 or less Ukrainian words to obtain somewhat suitable for poetry or music text  https://hackage.haskell.org/package/dobutokO-poetry-0.16.3.0 (OleksandrZhabenko)
15:07:40 <nh2> dminuoso: OK great. Let's claim for now that `type Overlay = Nixpkgs -> Nixpkgs` (glossing over the fact that an overlay really gets 2 arguments, self and super). `survey/default.nix` contains multiple such overlays (let's say `f`, `g`, `h`), for different tasks as mentioned above. It then provides `pkgs = (h . g  . f) normalPkgs`.
15:07:41 <nh2> Now, if you want to change the returned nixpkgs (say with your own overlay `o`), you have essentially 2 choices:
15:07:41 <nh2> 1) You could apply it at the very end, like `yournixpkgs = o surveysReturnedPkgs`.
15:07:41 <nh2> 2) You could apply it at the very beginning like `o normalNixpkgs` around the normal nixpkgs provided to survey.
15:07:41 <nh2> In nix terms, we could write this like:
15:07:41 <nh2> 1) `let normalPkgs = (import <nixpkgs> {}); in (import ./survey { normalPkgs = normalPkgs }).extend(o)`
15:07:41 <nh2> 2) `let normalPkgs = (import <nixpkgs> {}); in (import ./survey { normalPkgs = normalPkgs.extend(o })`
15:07:42 <nh2> Makes sense so far?
15:07:49 <yushyin> wow
15:08:27 <dminuoso> nh2: Yes
15:12:33 <phadej> dminuoso: what you wrote (the `Number`) is essentially what Scientific is
15:12:56 <dminuoso> phadej: Oh! And that's why aeson opts to use Scientific then?
15:13:02 <phadej> yes
15:13:07 <dminuoso> I see
15:13:13 <phadej> Scientific does forget some information, as in
15:13:32 <phadej> 1e2 and 100 are same Scientific (even unnormalised)
15:13:57 <phadej> or maybe not
15:14:13 <phadej> 1e-2 and 0.01 are probably the same
15:14:47 <phadej> but if someone want to have semantics differentiating these, that feels like very wrong thing to do
15:15:16 <phadej> (differentiating 1e2 and 100 makes sense though, latter can be understand as having 3 meaningful digits)
15:15:34 <phadej> err. significant digits
15:18:08 <phadej> fun fact, JSON forbids prefix zeros, but allows trailing ones (in decimals)
15:18:09 <phadej> Prelude Data.Aeson> map decode ["00100", "0.1000"] :: [Maybe Double]
15:18:09 <phadej> [Nothing,Just 0.1]
15:18:32 <phadej> it makes sense, as 0100 is often interpreted as octal
15:18:54 <phadej> but some poor services represent zipcodes as JSON numbers :facepalm:
15:19:24 <ystael> phadej: obviously the +4 goes after the decimal point!
15:20:18 <dminuoso> phadej: re zipcodes, that's amusing. We do encode zipcodes as integer types in our database, but in our country that's a valid thing to do, and we will never need to support other countries.
15:20:30 <dminuoso> Chances are, that's just what *they* thought.
15:21:11 <nh2> dminuoso: static-haskell-nix users use one of, or even both methods in conjunction, depending on what they want to achieve. Which one should you choose?
15:21:11 <nh2> If you want to add your own package and "statify" it, then you use (1) to add it into nixpkgs before survey's overlays do their work over all Haskell packages inside (one can think of it as a `map statify` over all Haskell packages contained within).
15:21:11 <nh2> If you to further modify the result (for example pass some extra linker flags to some package at the very end), then you use (2).
15:21:11 <nh2> A small example of a typical use case is given by Gabriel in https://github.com/nh2/static-haskell-nix/issues/29#issue-462257748. Here you see nixpkgs pinned, static-haskell-nix pinned, and then survey's overlays being applied to the pinned nixpkgs.
15:21:11 <nh2> You could inject your own packages with an overlay like `normalPkgs = pkgsLinux.extend(o);` in there.
15:21:37 <phadej> but then your JSON can have zip code written as 1e2 :) (center of helsinki, finland has zipcode 00100)
15:22:14 <phadej> grepping dumps becomes tricky
15:22:22 <nh2> dminuoso: the `static-stack2nix-builder` does the same; it generates such a file for you, and makes `o` an overlay that adds all packages from your used Stackage snapshot into nixpkgs.
15:25:06 <phadej> fwiw, 5 bytes (for 00100 like zipcodes) is not much overhead to 4 or 8 byte words in DB 
15:27:19 <nh2> dminuoso: What I described so far was an example of (1), passing in a modified nixpkgs. For an example of (2), modifying the result futher, see this example: https://github.com/nh2/static-haskell-nix/issues/57#issuecomment-544211259
15:27:19 <nh2> Here we override `static_package` at the very end (`static_package` is just `(survey { normalPkgs = overrideToAddYourStackageVersions nixpkgs; }).pkgs.haskellPackages.nameOfYourPackage`) to add some nasty linker flags with pkg-config that apps linking against postgres currently require.
15:32:20 <kosmikus> phadej, glguy: haven't read up on all the context, but IsRecord from records-sop is a compile-time constraint that a type is a single-constructor record type with labels. this should perhaps be in generics-sop.
15:35:25 <kosmikus> phadej: FWIW, I think staged GHC.Generics is entirely doable.
15:36:03 <phadej> kosmikus: yes, it is doable, but I don't think it will be "nice"
15:36:13 <phadej> K -> Code
15:36:14 <dminuoso> nh2: Im processing your information at the moment.
15:36:26 <phadej> err. K1 -> Code
15:37:18 <kosmikus> yes, well, it's about as nice as GHC.Generics is in the first place
15:37:23 <nh2> dminuoso: Because static-haskell-nix is essentially a set of overlays that you can compose at will, it allows you to inject stuff at any step, and most importantly, modify things that don't work yet inside nixpkgs or static-haskell-nix _from outside_ using an overlay, without having to change static-haskell-nix's or nixpkgs' code.
15:37:24 <nh2> This is the main difference vs Alpine, where if a package needs some modification, you essentially need to fix/modify it in Alpine proper, and if your modification isn't easily upstreamable, it'll be tough.
15:37:24 <nh2> Of course this "I compose myself a package environment using library-like functions" is more complex than "run it in a distro like Alpine that has everything already pre-composed", but the tradeoff is the added flexibility that a library style approach gives.
15:38:38 <dminuoso> nh2: Do I need to overrideCabal and inject all the ghc options like fPIC, -optl-static, -optl-pthread, and so on?
15:38:48 <dminuoso> Because my guts say I do
15:39:34 <kosmikus> phadej: presumably (although I haven't tried this), if GHC could generate a staged GHC.Generics representation, one could derive the staged generics-sop operation in the same way we currently can, still producing the same run-time code.
15:39:49 <kosmikus> s/operation/representation/
15:40:06 <phadej> kosmikus: that would be ugly, one would nede to have `StagedRep` with different leafs
15:40:14 <phadej> vs. staged-sop where Description is shared
15:40:41 <kosmikus> sure, the advantage of doing this for generics-sop is that a lot of the machinery just remains in place
15:40:52 <kosmikus> (NS, NP, nearly all the operations)
15:41:10 <phadej> as we talked with glguy, "GHC.Generics doesn't really have machinery"
15:41:13 <phadej> :)
15:41:18 <kosmikus> yes
15:41:23 <kosmikus> it's all rather unstructured
15:41:29 <nh2> dminuoso: No, this is what one of the overlays inside survey does. The `staticHaskellBinariesOverlay` passes `--enable-executable-static` to all Haskell executables in the package set, and this Cabal flag will result in those low-level flags like `-optl-static` being used by GHC.
15:41:29 <nh2> Code:
15:41:30 <nh2> https://github.com/nh2/static-haskell-nix/blob/dbce18f4808d27f6a51ce31585078b49c86bd2b5/survey/default.nix#L1237-L1238
15:41:30 <nh2> https://github.com/nh2/static-haskell-nix/blob/dbce18f4808d27f6a51ce31585078b49c86bd2b5/survey/default.nix#L1250
15:42:04 <kosmikus> anyway, there'll perhaps be a point where we'd like GHC to generate a staged representation for a type automatically
15:42:21 <kosmikus> and currently, it seems more likely this will be a GHC.Generics-like representation than a generics-sop-like one.
15:42:34 <kosmikus> I'd certainly be willing to compromise there :)
15:42:48 <dminuoso> nh2: And the comment about: requires `useFixedCabal` ? :)
15:43:19 <phadej> kosmikus: yes, it makes sense. GHC.StagedGenericsUglyModuleNameDontUseDirectly -- would do it
15:43:30 <dminuoso> nh2: Keep in mind, Im making notes here. I might cook this into some brief user manual. So hopefully you don't have to re-explain to anyone else.
15:43:31 <phadej> have to ask Duncan for naming ideas
15:43:48 <dcoutts> uh oh :-)
15:44:39 <nh2> dminuoso: Originally, I did pass those low-level flags directly, but later I upstreamed them into Cabal (I implemented the `--enable-executable-static` flag). Before my PR was merged, I had this functionality packaged up in the `useFixedCabal` function, which is still applied by survey if your package set uses a Cabal that's too old to have the PR merged.
15:45:24 <dminuoso> nh2: btw, regarding your comments earlier (apply at the end/beginning), I think you mixed up 1) and 2) - is that right?
15:45:37 <dminuoso> Ahh I see
15:46:34 <dminuoso> nh2: https://gist.github.com/dminuoso/913030e552a67c7afbb81e4e64e6c867 does this roughly look good then?
15:47:03 <dminuoso> (For some bizarre reason, Im getting an missing attribute freyja at the end, as if the overlay is not applied correctly)
15:50:10 <nh2> dminuoso: That is great, and I would very appreciate it; static-haskell-nix could do with a lot more user documentation and explanations; I haven't done much of that yet, because so far I feel I should spend most of my time on the project on implementing the "hard" linker convincing parts (and avid nix users will figure it out eventially even without docs, they are used to that, hehe).
15:50:10 <nh2> I've documented the static-stack2nix-builder parts a bit more so far because that's a very user-facing tool which even normal Nix-Haskell-users may not be familiar with.
15:50:10 <nh2> Overall my hope is to build a community of users that increasingly understand how it works, work together on moving it into nixpkgs, and then document it well.
15:50:31 <nh2> dminuoso: Can you quote where you think I mixed up 1 and 2? Because I cannot spot it
15:51:08 <dminuoso> 00:07:19              nh2 | 1) You could apply it at the very end, like `yournixpkgs = o surveysReturnedPkgs`.
15:51:11 <dminuoso> 00:07:19              nh2 | 2) You could apply it at the very beginning like `o normalNixpkgs` around the normal nixpkgs provided to survey.
15:51:28 <dminuoso> "If you want to add your own package and "statify" it, then you use (1) to add it into nixpkgs before survey's overlays do their work"
15:51:35 <dminuoso> "If you to further modify the result (for example pass some extra linker flags to some package at the very end), then you use (2)."
15:52:04 <nh2> dminuoso: oh yes, you are right, in the last 2 lines, (1) and (2) should be swapped.
15:53:38 <koz_> If I have a ByteString, how do I turn it into a (String ideally, but Text will do) representation of it in hex?
15:54:24 <nh2> dminuoso: yes, your gist looks pretty legit to me
15:55:26 <dminuoso> nh2: Mmm. Do your overlays filter out some stuff possibly?
15:55:47 <dminuoso> Because my freyja is just not popping up in static-pkgs.haskellPackages.freyja
15:57:24 <koz_> dminuoso: Are you the Duke? Missing your dear Freyja? :P
15:57:57 <nh2> dminuoso: the main issue you will likely hit is that the `nixpkgs-unstable` you use is a moving target, and musl-based stuff breaks a lot because `pkgsMusl` is not currently CI'd. That's why in `static-haskell-nix` I pin a nixpkgs version, and I CI it with all Stackage packages. I would usually recommend to use my pinned nixpkgs for that reason. You can import it using e.g. `import (static-haskell-nix + "/nixpkgs.nix`) 
15:57:57 <nh2> {}`.
15:59:58 <dminuoso> nh2: Ah, presumably you filter out anything with broken deps?
16:02:03 <dminuoso> Mmm, its still missing, even with that
16:02:49 <nh2> dminuoso: The most likely reason for packages missing is that your overlay is adding your package to the wrong Haskell package set. There are multiple ones in nixpkgs: `pkgs.haskell.packages.ghc865`, `pkgs.haskell.packages.ghc882`, and so on, one for each GHC version supported in nixpkgs. `pkgs.haskellPackages` is just an alias for one of them. If you're using `nixpkgs-unstable`, then it's probably a very new one.
16:02:49 <nh2> So you may be adding yoru package to `pkgs.haskell.packages.ghc882`, but survey gives you back `pkgs.haskell.packages.ghc865` (because you use `compiler = "ghc865"`).
16:03:39 <nh2> dminuoso: so your overlay should better use `pkgs.haskell.packages.${compiler}.extend(...)` instead of `super.haskellPackages.extend(...)`
16:04:35 <dminuoso> Does static-haskell-nix care at all which GHC version I pick?
16:07:42 <nh2> dminuoso: a little bit. Technically it supports the ones written in here https://github.com/nh2/static-haskell-nix/blob/dbce18f4808d27f6a51ce31585078b49c86bd2b5/survey/default.nix#L38-L47, but currently `ghc865` is the default and what the CI runs, so that is the one currently best-supported.
16:07:43 <nh2> Similarly, while nixpkgs provides multiple ghcs and their package sets, usually one is the "main" one that gets built by CI, so that  is usually the one that works best and for which issues are most easily discovered.
16:12:58 <nh2> dminuoso: if you want to switch GHCs, I'd certainly recommend to switch the default in `survey/default.nix` and build `-A working -A workingStackageExecutables` (and such stuff that the CI builds), so that you can see whether it works well.
16:12:58 <nh2> That should be relatively easy to do, because the main "meat" of static-haskell-nix is to convince non-Haskell libs to make `.a` files and those of course are the same for all GHC versions.
16:12:58 <nh2> But it's still nicer to find a build break in e.g. dhall or pandoc first than in your own build, because it's easier bug-reportable.
16:14:49 * hackage composite-base 0.7.4.0 - Shared utilities for composite-* packages.  https://hackage.haskell.org/package/composite-base-0.7.4.0 (dridus)
16:15:49 * hackage composite-opaleye 0.7.4.0, composite-hashable 0.7.4.0, composite-ekg 0.7.4.0, composite-binary 0.7.4.0, composite-aeson-refined 0.7.4.0, composite-aeson-path 0.7.4.0, composite-aeson 0.7.4.0 (dridus)
16:16:49 * hackage composite-swagger 0.7.4.0 - Swagger for Vinyl records  https://hackage.haskell.org/package/composite-swagger-0.7.4.0 (dridus)
16:17:23 <nh2> dminuoso: btw, if you have some time, you may also want to read `survey/default.nix` top-to-bottom. It has 1300 lines but much of it is petty overrides for individual packages that can be scrolled over easily, and I tried to comment the non-obvious things reasonably well; you may find that it can speed up getting to your end goal a lot if you know what's happening inside.
16:17:41 <koz_> > (Sum 4, Product 4) <> (Sum 4, Product 4)
16:17:43 <lambdabot>  (Sum {getSum = 8},Product {getProduct = 16})
16:17:50 <koz_> Thought so.
16:18:35 <dminuoso> nh2: Alright cheers. Somehow Im stuck at extending the package set for 865, it's not as obvious.
16:19:43 <dminuoso> Trying to do something like: self: super: { haskell.packages.${compiler} = super.haskell.packages.${compiler}.extend ...; } trips some errors, I think I understand why, not sure how to fix this.
16:19:48 <dminuoso> Never even tried to do this before 
16:19:56 <dminuoso> As I'd usually go with haskellPackages
16:20:27 <dminuoso> Ill definitely go through the source of it, I think with what you've explained it'll make more sense
16:29:54 <hekkaidekapus> koz_: For hex as in RFC 4648, see @hackage base16
16:30:07 <koz_> hekkaidekapus: Thanks!
16:30:30 <hekkaidekapus> You’re welcome.
16:32:06 <nh2> dminuoso: I'll also try to build a small example that shows your exact use case. Probably another day though as it's late here. I noticed though that your gist currently doesn't use the `compiler` variable; you probably want to pass it to survey (even though that's the default, for explicitness).
16:37:45 <nh2> dminuoso: Making an overlay to change haskell packages is currently a ghastly 3-line incantation (but luckily easily copy-pastable): https://github.com/nh2/static-haskell-nix/blob/dbce18f4808d27f6a51ce31585078b49c86bd2b5/survey/default.nix#L1237-L1240
16:38:40 <nh2> dminuoso: if you search for `composeExtensions` you find that this is used in every overlay that changes Haskell packages, and you'll also find this to be "the standard way" of how to override Haskell packages in nixpkgs (though everybody agrees it should be simpler, but that is technically challenging)
16:45:08 <sm[m]> love that ghastly overlay :)  (great info)
16:45:22 <sm[m]> ghastly incantation
16:46:33 <monochrom> Interesting, base32 is A-Z2-7, base32hex is 0-9A-V.
16:46:59 <monochrom> All your base are belong to RFC 4648
16:56:31 <hekkaidekapus> heh… Reading the RFC and looking at some implementations in the wild, it seems specification-abiding code is hard.
17:12:26 <hekkaidekapus> monochrom: All your base are Hellenist (triacontakaidecimal) :)
17:20:19 <monochrom> haha nice
17:54:19 * hackage spars 0.1.0.0 - A sparse set-based parsing library for Haskell.  https://hackage.haskell.org/package/spars-0.1.0.0 (anselmschueler)
18:31:06 <kiwi_45> hello all
18:32:50 <kiwi_45> I need help with authorization(RBAC) implementation using servant, can someone look at this https://github.com/haskell-servant/servant-auth/issues/172 ?
19:15:34 <kiwi_45> ??
19:26:49 * hackage haskeline 0.8.0.1 - A command-line interface for user input, written in Haskell.  https://hackage.haskell.org/package/haskeline-0.8.0.1 (JudahJacobson)
19:45:18 * hackage haskeline 0.8.1.0 - A command-line interface for user input, written in Haskell.  https://hackage.haskell.org/package/haskeline-0.8.1.0 (JudahJacobson)
21:36:51 <sillybooties> Hi all! New to Haskell/FP. Is there a standardized code formatter in the Haskell community like gofmt?
21:41:20 <wavemode> sillybooties: there's stylish-haskell as well as ormolu
21:41:52 <solonarv> there's also hindent and brittany
21:42:00 <solonarv> I think those are the main four?
21:42:13 <solonarv> so, there isn't really a single "blessed" choice that the whole community converged on
21:45:19 * hackage recommender-als 0.2.1.0 - Recommendations using alternating least squares algorithm  https://hackage.haskell.org/package/recommender-als-0.2.1.0 (kaol)
21:48:13 <Graypup_> (_:x:xs) on a String discards first char, putting the second in x and rest in xs?
21:48:21 <koz_> I personally prefer ormolu, but as solonarv said, there's some options.
21:48:43 <koz_> Graypup_: More precisely, it binds 'x' to 'the second Char', and 'xs' to 'whatever's left'.
21:49:04 <Graypup_> k cool, just making sure I understood it right before i go rewrite it with Text
21:50:41 <dminuoso> nh2: Sad, so apparently your overlay is tripping me into infinite recursion. :(
22:03:29 <Graypup_>           contentOf x = dropWhile (== ' ') . dropWhile (/= ' ') $  x
22:03:46 <Graypup_> correct me if I'm wrong but this deletes everything in the x String??
22:04:03 <Graypup_> since it is dropping everything that is not ' ' and also everything that is ' '
22:04:53 <wavemode> not really
22:04:56 <Graypup_> aha no it is not
22:05:02 <Graypup_> i fucked around with it in ghci
22:05:16 <Graypup_> it eats the first space delimited field
22:06:27 <dminuoso> Graypup_: `filter` would behave that way.
22:07:01 <dminuoso> `filter (not p) . filter p = const []` for finite lists
22:08:32 <Graypup_> hm, so how would I write this efficiently using Data.Text?
22:08:57 <Graypup_> really, I just need to find the first space and construct a slice from that position to the end, no?
22:10:47 <dminuoso> Graypup_: You could use break
22:35:35 <hyiltiz> Voigtländer's "Bidirectionalization for Free!(Pearl)" seem awfully relevant to the topics of optics and lenses but it barely mentions them
22:35:56 <hyiltiz> How are the two related? I am guessing it is the same theory?
22:44:22 <la-jesystani> howdy, is this somewhere i can ask questions about nix? one of my libraries is failing to build
22:45:02 <c_wraith> this is only a good place if it's about nix and haskell libraries interacting.  Otherwise, and maybe even in that case, #nixos is a better choice.
22:45:53 <la-jesystani> ah probably better there then, thanks anyway
22:52:17 <kiwi_45> hello all
22:53:24 <kiwi_45> Role Based Access Control With servant 
22:55:23 <kiwi_45> there is this comment by alpmestan https://github.com/haskell-servant/servant-auth/issues/73#issuecomment-349737003 I need help on how can I implement his 2nd approach, can someone please help me ?
23:04:12 <c_wraith> hyiltiz: It's an interesting idea, but it doesn't strike me as especially efficient (nor do the charts at the end make it look efficient) or applicable to non-polymorphic cases.
23:05:38 <c_wraith> hyiltiz: I think you could do something composition-oriented like lens/optics with it, but that'd compound the performance issues
23:19:34 <c_wraith> anyone got experience getting borders to merge in Brick?  I can't seem to figure out how it wants things set up
23:21:22 <dminuoso> c_wraith: Are you looking for Brick.Widgets.Core.joinBorders ?
23:21:46 <c_wraith> no, I'm wondering what it actually *does*, because it doesn't seem to join neighboring borders the way I'd think
23:24:07 <dminuoso> c_wraith: Mmm, ctxDynBordersL is sadly not even documented. (
23:26:37 <c_wraith> oh, I see.  it only applies to individual border segments meeting up with perpendicular border segments
23:27:57 <jophish> It's a shame one can't share values between multiple splices, like: foo=();splice1 foo;splice2 foo
23:28:20 <c_wraith> that's got a bit of a time-travel problem
23:28:46 <c_wraith> given that splices exist at compile time, but foo exists at run time
23:28:46 <jophish> instead I end up with the ugly: do{let foo=();d1<-splice1 foo; d2<-splice2 foo; pure (d1<>d2>)}
23:29:01 <jophish> yeah, I understand why it's not possible in general :)
23:29:09 <jophish> but in this case there's a very mechanical transformation
23:30:02 <jophish> perhaps one could steal the illegal top-level: `let foo = ()` syntax to implement this
23:38:32 <solonarv> someone should PR a Semigroup/Monoid instance for Q
23:38:50 <solonarv> then you could just write: let foo = () in splice1 foo <> splice2 foo
23:39:09 <wavemode> "someone" is a funny way of spelling "I"
23:42:13 <jophish> https://gitlab.haskell.org/ghc/ghc/-/commit/5f621a78217237a4bdfb299b68827da6cc8f357e
23:44:07 <jophish> thanks int-index!
23:52:47 <Graypup_> don't you love when some wacky template haskell thing screws up after a dependency update
23:52:55 <Graypup_> and it is opaque
23:53:03 <Graypup_> that's how my life is going right now
23:53:42 <Graypup_> suddenly Yesod seems to have stopped generating CoInstructorId as a type from my config/models after updating to ghc-8.8 and a new version of persistent
23:54:27 <c_wraith> template-haskell can change in the details pretty significantly between versions of ghc
23:54:59 <c_wraith> given that it's yesod, you should only change ghc versions by change stack resolvers
23:55:09 <Graypup_> I'm on Nix
23:55:24 <c_wraith> that'll make sure you get a version of yesod that works with the chosen version of ghc
23:55:38 <c_wraith> Yesod is not designed to work without stack
23:55:59 <Graypup_> I do realize they have those opinions, yes
23:56:12 <c_wraith> if it was, it'd have correct dependency version bounds
23:56:49 <Graypup_> Nix provides a significant value proposition for deployment and such and I've had trouble using it with Stack, so I'm using their package repo
23:57:20 <Graypup_> now, I *could* try out a newer stack resolver and see if it reproduces the issue and check version differences
23:58:01 <c_wraith> you probably don't need to install it.  Just check the package list for the latest LTS resolver that uses ghc 8.8
23:58:14 <c_wraith> and make sure to set your dependencies to those versions
23:58:34 <Graypup_> well, I don't know if the bug is that, and I *do* actually have stack build infrastructure in parallel for this project, so it would be feasible
23:58:59 <c_wraith> ah.  Well if you have that, might as well check to see if solves it.
23:59:31 <Graypup_> waste some disk space and time but it would be less work :)
23:59:45 <c_wraith> start it before you go to lunch :)
