00:16:36 <Axman6> mniip: I wrote a package years ago called TernaryTrees which sounds somewhat related. It got cited in a paper surprisingly :)
00:17:49 * hackage ixset-typed-conversions 0.1.1.0 - Conversions from ixset-typed to other containers.  https://hackage.haskell.org/package/ixset-typed-conversions-0.1.1.0 (locallycompact)
00:30:53 <dminuoso> What alternatives to stylish-haskell do I have that work with hsc? I only care about pragmas and import list cleanup.
00:31:38 <xiu2> anyone here know about Servant? I'm trying to get openid working, but I can't figure out how I would go about redirecting to the provider
00:32:48 <dminuoso> There appears to be documentation on https://docs.servant.dev/en/stable/cookbook/open-id-connect/OpenIdConnect.html
00:33:04 <dminuoso> Do you have a more concrete question, or were you just missing the above documentation?
00:33:42 <xiu2> that's openID connect, which is a different (I think?) workflow, right?
00:33:57 <dminuoso> Oh
00:35:09 <xiu2> I'll see if what info I can get from there though, thanks
00:38:39 <dminuoso> Ohh re alignment, I suppose I can just use haskell-mode facilities.
00:46:28 <Axman6> jle`: is there a lensy/prismy thing which makes working with invariant functors even nicer? a version of swerve which takes in _CPerson and _CBusiness seems like the obvious next step
00:47:08 <ph88> does someone know of some "ask" function where it asked user input until a valid input has been given ? maybe there is a library which can help with this
00:47:34 <Axman6> feels like it'd only be about three lines of code
00:48:05 <dminuoso> ph88: Write a simple loop for it...
00:48:32 <dminuoso> loop = do r <- someMechanism; if valid r then proceed r else loop
00:48:41 <dminuoso> Surely you don't need a library for that? :)
00:48:55 <maerwald> you've been asking about user ask functions since days now :p
00:49:44 <dminuoso> But hey, maybe for self proliferation I should make some validating-loop package containing the above thing. I'd have one downloadee.
00:49:53 <maerwald> could have written a library by now
00:49:53 <dminuoso> </s>
00:50:00 <xiu2> haskeline might even already have it
00:50:09 <dminuoso> xiu2: Which I pointed out to them yesterday already. :)
00:50:09 <Axman6> ask :: (String -> Bool) -> IO String; ask p = getLine >>= \x -> if p x then pure x else ask p
00:50:39 <Axman6> like, it almost reads like the description of what it's supposed to do
00:50:40 <dminuoso> Axman6: mmm that looks suspicious monad-loopsy
00:51:05 <dminuoso> iterateWhile :: Monad m => (a -> Bool) -> m a -> m a
00:51:07 <Axman6> @hoogle (a -> Bool) -> m a -> m a
00:51:08 <lambdabot> Control.Monad.HT until :: (Monad m) => (a -> Bool) -> m a -> m a
00:51:08 <lambdabot> Control.Monad.HT untilM :: (Monad m) => (a -> Bool) -> m a -> m a
00:51:08 <lambdabot> Control.Monad.Loops iterateWhile :: Monad m => (a -> Bool) -> m a -> m a
00:51:34 <dminuoso> But really, this is not a library problem.
00:51:57 <dminuoso> Sometimes I think people are too eager to look for a library instead of writing the logic they have in mind out directly.
00:52:14 <Axman6> #javascript
00:54:49 <ph88> dminuoso, i made this now https://bpa.st/F3RA  (untested)
00:56:07 <dminuoso> ph88: Looks good enough to start with. Go for it?
00:56:14 <ph88> ya thank you
00:56:16 <xiu2> looks like you want >> instead of >>= on line 9?
00:58:32 <Orbstheorem> Hello o/ How can I debug what context a monad is missing? I'm rewriting some of my Persistent code in Esqueleto and I'm getting `Couldn't match type ‘m’ with ‘ReaderT backend0 m0’`
01:00:11 <Orbstheorem> I'm running the db in my own monadT (alias). Fun thing: `Database.Persist.Class.selectList` has the same return type (ReaderT backend m a) as `Database.Esqueleto.select` (SqlReadT m a); so I'd guess it's an aliasing problem?
01:18:59 <hekkaidekapus> jchia: You might have found a solution by now. If you didn’t, check out the `Natural` type and the `enumerate` function.
01:22:52 <jchia> hekkaidekapus: Could you please elaborate? Is 'enumerate' from Haskell or Dhall? I ended up doing the conversion from Integer to Word8 and checking in Haskell.
01:26:13 <hekkaidekapus> jchia: Dhall’s Natural is the closest to Haskell’s WordX. You could use `enumerate` on Dhall side (but it starts from 0) and rely on the `FromDhall Natural` instance in Haskell.
01:27:00 <jchia> hekkaidekapus: How do I check that the value is in range (between 0 & 255)?
01:27:35 <hekkaidekapus> enumerate?
01:28:14 <hekkaidekapus> jchia: https://github.com/dhall-lang/dhall-lang/blob/v17.1.0/Prelude/Natural/enumerate.dhall
01:45:54 <dminuoso> Orbstheorem: Can you shar ethe entire diagnostic?
01:47:01 <hekkaidekapus> jchia: Am I to elliptic? Here we go: let xs = enumerate 255; let val = 7 : Natural; … and (greaterThanEqual val (listMin xs) : lessThanEqual val (listMax xs)
01:49:13 <Uniaika> morgen
01:50:16 <hekkaidekapus> Uniaika: hi, a unit of measureent?
01:50:28 <hekkaidekapus> *measurement
01:50:30 <Uniaika> nope, morning in german!
01:50:43 <hekkaidekapus> Ah, guten…
01:51:13 <Uniaika> gluten morgen? :P
01:51:31 <hekkaidekapus> Data Free gluen
01:51:55 <hekkaidekapus> *gluten (I need some coffee)
01:55:55 <fendor> Mahlzeit!
01:56:44 <hekkaidekapus> fendor: enjoy
01:56:59 <Orbstheorem> dminuoso: https://paste.gnugen.ch/raw/qE8D 
01:57:07 <Orbstheorem> Sorry I couldn't build a minimal example.
01:57:35 * Orbstheorem wants to spend time cleaning this mess.
01:57:46 <dminuoso> Orbstheorem: I meant, share the entire error message?
01:57:56 <dminuoso> Also, that website wont display the data.
01:57:59 <Orbstheorem> dminuoso: Yes, it's in the second part of the script.
01:58:18 <dminuoso> Not seeing it.
01:58:59 <Orbstheorem> Pasted the wrong buffer ><"
01:59:02 <Orbstheorem> One sec
01:59:26 <dminuoso> Orbstheorem: Please use a different website. :)
01:59:46 <dminuoso> I find an application/octet-stream as a pasting service offensive.
02:00:05 <Orbstheorem> I send the content-type when I push
02:01:01 <dminuoso> Oh.
02:01:12 <Orbstheorem> https://paste.gnugen.ch/raw/zSzr
02:01:33 <Orbstheorem> It's just that I hitted '*' instead of '+' x)
02:01:46 <dminuoso> Orbstheorem: have you enabled ScopedTypeVariables?
02:02:56 <Orbstheorem> Right, the insane amount of extensions enabled: https://paste.gnugen.ch/raw/6w4h
02:04:15 <dminuoso> Orbstheorem: Are you sure its active for the module? Try putting it in a pragma ontop just for an experiment.
02:04:35 <dminuoso> Ohh hold on
02:04:41 <dminuoso> Orbstheorem: You forgot the forall in the top level signature.
02:05:16 <Orbstheorem> where am I type-applying?
02:05:29 <dminuoso> Orbstheorem: You are not. You are attempting to use a type variable in a nested context.
02:05:43 <dminuoso> That doesnt work unless you have both a) ScopedTypeVariables enabled and explicitly introduce the type variable via forall
02:05:47 <Orbstheorem> Oh, I thought that was out of the box.
02:05:48 <dminuoso> (Counter intuitively)
02:05:56 <Orbstheorem> Oh well.
02:06:16 <dminuoso> Orbstheorem: the indicator here for you, is the way GHC phrases the diagnostic
02:06:19 <dminuoso> two parts:
02:06:24 <dminuoso> well, one really:
02:06:29 <dminuoso> See how it got alpha renamed?
02:06:36 <Orbstheorem> Same error after adding the forall and `{-# LANGUAGE ScopedTypeVariables #-}`.
02:06:45 <dminuoso> Orbstheorem: is the forall on pollPaymentUpdates?
02:06:51 <dminuoso> Or on openEthPayments?
02:07:19 <dminuoso> Essentially, a type variable can only be captured, if its introduced via forall.
02:07:19 <Orbstheorem> pollPaymentUpdates
02:07:32 <dminuoso> are you sure its the same error?
02:07:42 <dminuoso> Did you perhaps forget to save your buffer?
02:07:45 <Orbstheorem> The m in the error didn't get rename (Couldn't match type ‘m’ with ‘ReaderT backend0 m0’)
02:07:54 <dminuoso> Orbstheorem: Look closer
02:08:04 <dminuoso> Ah that's a different diagnostic then
02:08:10 <dminuoso> Share it again, please?
02:08:36 <dminuoso> (The one you gave me said `• Couldn't match type ‘m1’ with ‘ReaderT backend0 m0’ ‘m1’ is a rigid type variable bound by the type signature for:  openEthPayments :: forall (m1 :: * -> *). ...`
02:10:42 <Orbstheorem> https://paste.gnugen.ch/raw/ZQvF
02:11:02 <Orbstheorem> Oh, sorry. You're right.
02:12:39 <dminuoso> Presumably `select` is fixed on ReaderT
02:12:52 <Orbstheorem> Yes: https://hackage.haskell.org/package/esqueleto-3.3.3.0/docs/Database-Esqueleto.html#v:select
02:13:16 <dminuoso> There you go then
02:13:22 <Orbstheorem> But I'm utterly confused since the same context worked when using selectList (https://hackage.haskell.org/package/persistent-2.8.2/docs/Database-Persist-Class.html)
02:13:56 <dminuoso> "same context"?
02:14:21 <dminuoso> Mmm interesting
02:14:31 <Orbstheorem> by context I mean everything to the left of (=>) in pollPaymentUpdates.
02:14:33 <dminuoso> type SqlReadT (m :: Type -> Type) a = forall backend. SqlBackendCanRead backend => ReaderT backend m a 
02:15:29 <Orbstheorem> It was a 40-lines long do block doing multiple persistent queries. I replaced it with a single join using esqueleto.
02:15:40 * Orbstheorem was expecting it to be plug and play :(
02:16:35 <dminuoso> What did your usage of selectList look like?
02:18:01 <Orbstheorem> tons of lines like so: `selectList [AccountEntityAccountEth ==. Just (entityKey account)] []`
02:18:20 <kindaro> I uploaded a package candidate on Hackage, and Haddock documentation does not appear. I waited overnight. What should I do?  https://hackage.haskell.org/package/mime-mail-ses-0.4.2/candidate
02:18:43 <kindaro> Note that the reports appear to be an empty list.  https://hackage.haskell.org/package/mime-mail-ses-0.4.2/candidate/reports/
02:18:49 <merijn> kindaro: I'm not sure docs are build for candidates
02:19:01 <merijn> kindaro: Are you using cabal-install?
02:19:22 <kindaro> Yes, I am using cabal-install.
02:20:03 <merijn> kindaro: "cabal haddock --haddock-for-hackage" to build a tar ball of docs locally you can upload :)
02:20:20 <merijn> You can use "cabal upload -d" to upload the docs
02:20:21 <Orbstheorem> dminuoso: ttps://paste.gnugen.ch/raw/dstt
02:20:40 <merijn> kindaro: I'm impatient so I always build docs locally anyway
02:22:10 <Orbstheorem> dminuoso: Do you think I should look into writing a natural transformation from `SqlPersistT IO a` to `(DatabaseOp m) => m a`? (Which I'm not sure it's not even possible.)
02:22:34 <kindaro> merijn: That requires first building haddocks for all the dependencies though, does it not?
02:24:03 <merijn> kindaro: Possibly. I just have "documentation: True" in my ~/.cabal/config so it always builds those
02:24:39 <merijn> Orbstheorem: tbh, I would just consider writing the SQL by hand :p
02:24:42 <Orbstheorem> Why is `select` returning a concrete transformer anyways?
02:24:49 <Orbstheorem> merijn: Crossed my mind :P
02:25:26 <merijn> Orbstheorem: I think about 90% of the database stuff in my code now is just a thin wrapper aryound persistent's rawQuery
02:26:24 <Orbstheorem> merijn: My experience with ORMs is that eventually I'll end up sniffing its conversation with the db and cursing the ORM for lying...
02:26:27 <Orbstheorem> Oh well
02:26:31 * Orbstheorem goes to write sql
02:29:44 * tomjaguarpaw recommends Opaleye. It actually has a denotational semantics.  (But caveat emptor:
02:29:49 * tomjaguarpaw also wrote Opaleye)
02:30:49 * hackage juicy-gcode 0.1.0.10 - SVG to G-Code converter  https://hackage.haskell.org/package/juicy-gcode-0.1.0.10 (dlacko)
02:32:46 <merijn> tomjaguarpaw: opaleye also only works on postgres :p
02:34:57 <typetetris> Somehow cabal is broken for me. If I have an error in a module for an executable and If I fix this error by changing the lib in the package and the module for the executable, the lib doesn't recompiled and changes in the lib aren't visibale while it tries recompiling the euecutable. Have to delete dist-newstyle, when that happens. Version: 3.0.0.0 Is this known?
02:36:10 <typetetris> Oh my, shouldn't have looked into the issues on github .. there are many.
02:37:47 <merijn> typetetris: Try upgrading to 3.4 and see if that fixes it? >.>
02:39:00 <typetetris> merijn: I will try.
02:43:40 <Orbstheorem> merijn: How do I collect a conduit? I'm trying to collect the results of a rawQuery.
02:43:45 <Orbstheorem> (I don't know conduits)
02:43:49 <hyiltiz> Does anyone use Yi editor?
02:44:44 <merijn> Orbstheorem: Conduit is for streaming data, so you can process a row at a time, rather than loading the entire resulset into memory, so usually better for big resultsets
02:45:13 <merijn> Orbstheorem: But if you really want to collect them in memory you could just use one of the folds in conduit to collect them in a data structure
02:45:47 <Orbstheorem> I see the interes to using conduit... eventually. But before refactoring everything consumming me, I want to first get the same interface working
02:45:52 <merijn> Orbstheorem: Something like https://hackage.haskell.org/package/conduit-1.3.2/docs/Data-Conduit-Combinators.html#v:sinkList
02:46:20 <merijn> runConduit (rawQuery foo .| sinkList)
02:46:26 <Orbstheorem> Thank you ^^
02:46:56 <merijn> Orbstheorem: If you need inspiration: https://github.com/merijn/Belewitte/blob/master/benchmark-analysis/src/Query.hs
02:47:04 <dminuoso> Orbstheorem: Are you sure it worked with selectList? Can you use git to restore the exact code at that point and share it?
02:47:09 <merijn> Orbstheorem: I build my own interface on top of it
02:47:43 <dminuoso> Orbstheorem: Judging from the persistent documentation and the diagnostic, I think you did some more.
02:47:50 <merijn> I would like to state that, retroactively speaking, adding a Functor instance for Query was freaking brilliant and has saved me years :>
02:47:51 <Orbstheorem> merijn: Thanks ^^
02:48:00 <dminuoso> Did you perhaps transform pollPaymentUpdates into tagless final alongside?
02:48:18 <tomjaguarpaw> merijn: Sad but true
02:48:50 <tomjaguarpaw> There's also a really old version for sqlite. 
02:49:03 <Orbstheorem> dminuoso: I can pull it from git, but this module is so badly structured that it's unreadable. 
02:49:03 <merijn> tomjaguarpaw: Yeah, I know, I looked into reviving it at some point
02:49:14 <Orbstheorem> dminuoso: What do you mean by 'tagless final' ?
02:49:28 <merijn> tomjaguarpaw: But real life got in the way and it was less work to patch persistent to support what I needed than it was to make opaleye-sqlite work :)
02:49:40 <dminuoso> Orbstheorem: Im just saying, if you replaced the select with selectList, it should produce similar errors.
02:49:54 <dminuoso> So Im thinking you did *more* than just switch from selectList to select
02:50:05 <tomjaguarpaw> merijn: Ah yes, I remember that from the distant past!
02:50:18 <Orbstheorem> I don't think so, that's the first thing I checked ^^
02:50:55 <Orbstheorem> I may get back at it, but I want to explore conduits rn.
02:52:10 <dminuoso> Orbstheorem: the reason is quite simple: At the top you return something *polymorphic* over the monad. But if openEtyPayments uses `select` *or* `selectList` finally, you produce a ReaderT concrete thing (not sure why this is not just MonadReader).
02:52:52 <dminuoso> Orbstheorem: The definition then goes to say `openEthPayments >>= f`. That's in conflict with the type signature. Either its polymorphic over any monad, or you're locked into ReaderT.
02:52:58 <dminuoso> Cant have both
02:59:49 * hackage mime-mail-ses 0.4.2 - Send mime-mail messages via Amazon SES  https://hackage.haskell.org/package/mime-mail-ses-0.4.2 (kindaro)
03:10:08 <typetetris> When I need postgres executables installed for my test suite, how could I describe that in the cabal file? (build-tool-depends is only for haskell executables, is there something different for system executables?)
03:10:20 <merijn> typetetris: Not really
03:16:23 <dminuoso> You could reimplement postgres in haskell, upload it to hackage, and then use build-tool-depends?
03:16:27 <dminuoso> Sounds easy enough.
03:17:30 <Orbstheorem> dminuoso: Actually I just realized the old code was using this: https://hackage.haskell.org/package/monad-persist-0.0.3.0/docs/Control-Monad-Persist.html#v:selectList
03:17:59 <dminuoso> ;)
03:18:18 <dminuoso> Boy what am I glad to manually write out sql.
03:18:48 <dminuoso> The only thing I sometimes wish, was that I had a simple relational algebra for constructing search queries with.
03:19:10 <dminuoso> (In some cases they need to be dynamically constructed)
03:19:50 <Orbstheorem> Holly.... :D
03:19:54 <Orbstheorem> <3 raw SQL
03:20:00 <Orbstheorem> Also, first try xD
03:20:08 <Orbstheorem> Though it's not typesafe :(
03:20:10 <dminuoso> sql is honestly a wonderful language
03:20:19 <Orbstheorem> I like SQL for handling data.
03:20:21 <Orbstheorem> That's it.
03:20:22 <dminuoso> Purely functional programmers should appreciate it
03:20:50 <Orbstheorem> I wouldn't want to code a parser in SQL or a ML engine in it x)
03:21:00 <M2tias> the "no where clause means everything" is a bit scary though
03:21:08 * mniip cries in PL/pgSQL procedures
03:21:47 <dminuoso> M2tias: If you take the relational algebra perspective, much of sql makes more sense.
03:22:21 <M2tias> it makes sense, but I've written deletes to a production database. it's scary :D
03:22:38 <Orbstheorem> M2tias: tests? :D
03:23:00 <dminuoso> mniip: It's a pretty horrid experience indeed. :(
03:23:03 <M2tias> what is this "test"? I'm not familiar with that word
03:23:17 <Orbstheorem> If you're connected to a production database with a REPL you deserve everything that comes at you
03:23:23 <Orbstheorem> And a lightning strike.
03:23:34 <mniip> M2tias, I heard you take tests in school
03:23:38 <mniip> probably a highly academical thing
03:23:52 <M2tias> mniip: ah, no wonder, I'm on #haskell
03:24:01 <dminuoso> Well, a cli into production is sensible and good. Question is rather, why do you use a user that has *write* access?
03:24:20 <mniip> if you use a REPL to production, at least do it in a transaction
03:25:00 <Orbstheorem> a cli into production implies that such cli was tested and considers the user is a tired sysadmin who's missing 72h or sleep.
03:25:19 <merijn> Orbstheorem: Of course you like SQL
03:25:30 <Orbstheorem> :D
03:25:31 <merijn> Orbstheorem: It's basically a functional language
03:25:35 <Orbstheorem> xD
03:25:40 <Orbstheorem> Hey, I don't like VHDL xD
03:25:44 <__monty__> Missing 72h of sleep? That's nine days straight o.O
03:25:54 <dminuoso> Orbstheorem: You can program circuitry with clash if you prefer Haskell.
03:25:55 <Orbstheorem> Well, I mean, I do kind of like it, but it's not very ergonomic xD
03:25:55 <M2tias> well, the company still used AS/400 terminal emulators regularly 4 years ago
03:25:56 <merijn> Orbstheorem: Have you heard of our lord and saviour, Clash?
03:26:02 <M2tias> they were a bit old fashioned
03:26:13 <__monty__> Why has #haskell turned into #haskell-offtopic recently?
03:26:29 <merijn> __monty__: It hasn't
03:26:33 <dminuoso> merijn: By the way, do you know of any professor with spare PhD candidates? We have just the thing and could perhaps even sponsor it!
03:26:39 <dminuoso> A Haskell to P4 compiler.
03:26:45 <dminuoso> That field needs research
03:26:58 <Orbstheorem> I know about clash. While I like embedded & fpgas, I had to do VHDL in school (and couldn't render it since code review) and nowdays I don't have the time anymore :(
03:27:06 <Orbstheorem> __monty__: How come?
03:27:06 <merijn> P4 is networking, right?
03:27:08 <dminuoso> Right
03:27:22 <dminuoso> Think of it like VHDL for programmable switching asics.
03:27:34 <__monty__> Last haskell talk is over half of my screen ago...
03:27:49 <merijn> dminuoso: Well, normally the issue is funding
03:27:54 * Orbstheorem wonders what APGAs would look in haskell x)
03:28:08 <M2tias> __monty__: shh, don't break the haskell talk
03:28:12 <Orbstheorem> (or rather how similar would it be to quantumm programming)
03:28:25 <merijn> dminuoso: All (well, >95%)  phds here are funded on external money, so the only bound on available phd candidates is funds
03:28:38 <dminuoso> merijn: Mmm. Funding shouldn't be an issue.
03:28:49 <merijn> dminuoso: You met Clemens at NL-FP, right?
03:29:02 <dminuoso> Who was Clemens?
03:29:17 <merijn> dminuoso: https://staff.fnwi.uva.nl/c.u.grelck/
03:29:24 <dminuoso> Ah yes, I recall.
03:30:40 <dminuoso> That looks exactly like the person to talk to.
03:30:44 <dminuoso> Cheers
03:30:47 <merijn> dminuoso: Right, so his background is in compilers, but the CS group he's in at UvA is mostly focussed on networking (lots of SDN, etc.), so something like that would probably be a good fit
03:30:57 <dminuoso> Yeah
03:31:14 <alm48> k
03:31:19 <alm48> oops
03:31:34 <merijn> dminuoso: Man, you should've said that 6 years ago, that sounds like a much more fun phd :p
03:31:41 <alm48> I'm having some trouble writing a rank2 polymorphic function
03:32:00 <dminuoso> merijn: heh
03:32:04 <alm48> `fxx :: (forall a b. c (d a b) (e a b) -> c (f a b) (g a b) -> h a b) -> (forall a b. c a b) -> (forall a b. h a b)`
03:32:24 <merijn> __monty__: programming problems/projects in the context of "within my Haskell project" are still on topic for #haskell :p
03:32:28 <alm48> `fxx = \f x -> f x x`
03:32:47 <merijn> alm48: c is not in scope in the first argument
03:32:48 <alm48> Ghc accepts this definition no problem
03:32:52 <M2tias> merijn: I went on a tangent tbh
03:33:12 <alm48> my issue arises if I try something like
03:33:26 <merijn> or wait, does it still implicit forall with RankN?
03:33:32 <mniip> it does
03:33:33 <merijn> hmm, now I'm confused :)
03:33:40 <alm48> `import Control.Applicative ((<|>))`
03:34:18 <alm48> `foo = fxx (<|>) Nothing`
03:34:44 <mniip> what
03:35:02 <merijn> alm48: Well, that doesn't type check in the second argument
03:35:15 <alm48> The types work out with the correct choices for `c, d, e, f, g, h`, so I'm wondering why it doesn't type check
03:35:32 <merijn> alm48: "Maybe :: * -> *"
03:35:32 <mniip> how do you fit Nothing into (forall a b. c a b)
03:35:43 <merijn> alm48: So passing nothing as second arguments can never fit "c a b"
03:35:58 <alm48> mniip choose `c a b = Maybe a`
03:36:05 <merijn> alm48: You can't
03:36:10 <alm48> why?
03:36:12 <merijn> alm48: That's not valid Haskell
03:36:33 <alm48> why? I can define `type C a b = Maybe a` no problem
03:36:34 <mniip> alm48, but what's c?
03:36:39 <dminuoso> I think they meant ~ instead of = above, mniip.
03:36:41 <dminuoso> Err merijn.
03:36:51 <mniip> alm48, a type synonym is not a type constructor
03:37:07 <alm48> Is there any reason that it has to be a type constructor?
03:37:09 <merijn> alm48: And GHC would infer your hypothetical type why?
03:37:26 <alm48> I don't need GHC to infer this, but I can't even annotate it
03:37:28 <merijn> alm48: GHC just sees "c a b" and "Maybe z" (the type of Nothing)
03:37:31 <mniip> higher kinder parameters in polymorphic functions can be substituted for type constructors, and not arbitrary type functions
03:37:42 <mniip> because type inference in presence of arbitrary type functions is undecidable
03:37:44 <dminuoso> alm48: GHC has no inference rule allowing to unify `c a b ~ Maybe a`. Consider why, if we set `c ~ Maybe`, then suddenly it's applied to two (!) type things
03:37:54 <dminuoso> It knows that c :: * -> * -> *
03:38:11 <merijn> alm48: Wen unifying it fails, because Maybe can't unify with 'c' due to wrong kind
03:38:13 <dminuoso> But Maybe :: * -> *
03:38:22 <alm48> mniip is it possible to let type inference become undecidable here?
03:38:31 <alm48> and unify the types manually?
03:38:31 <mniip> not with GHC
03:39:04 <dminuoso> alm48: You can if you use a newtype.
03:39:13 <mniip> you can create a custom type constructor, of course
03:39:42 <dminuoso> % newtype TaggedMaybe t a = TaggedMaybe (Maybe a)
03:39:42 <yahb> dminuoso: 
03:39:47 <dminuoso> That you can use
03:40:18 <dminuoso> Or, I suppose, `Tagged :.: Maybe`
03:40:22 <mniip> there's probably something in profunctors for this
03:40:24 <dminuoso> No, wrong way arond
03:40:27 <dminuoso> Maybe :.: Tagged
03:41:00 <mniip> Joker Maybe
03:41:44 <dminuoso> mniip: Ah that's neat. :)
03:42:03 <mniip> if you're wondering, there's a also a Clown
03:43:56 <merijn> mniip: Sounds like I need to blame McBride :p
03:44:22 <merijn> That paper seems very cool and interesting at the start and then I get utterly lost within 2 pages :p
03:49:31 <alm48> hmm this doesn't seem to work even with newtype
03:49:48 <alm48> `import Control.Applicative (Const)`
03:50:13 <alm48> ` newtype CM a b = CM {unCM :: Maybe a}`
03:50:36 <alm48> `fxx :: (forall a b. CM (Const a b) (Const a b) -> CM (Const a b) (Const a b) -> CM a b) -> (forall a b. CM a b) -> (forall a b. CM a b)`
03:50:57 <alm48> ^ this fails with `Occurs check: cannot construct the infinite type: a2 ~ f0 a2 b2`
03:58:28 <typetetris> Hmm, what is the difference between `.o` and `.p_o` files cabal is producing?
03:58:47 <merijn> typetetris: .p_o are probably profiled object files
03:59:13 <typetetris> strange ... didn't enable profiling ..
03:59:26 <typetetris> I was just annoyed it compiled everything twice.
03:59:30 <merijn> I'm just guessing :p
04:00:01 <merijn> But if it's building everythin twice, that sounds a lot like you did enable profiling somehow or at least at some point in time :p
04:00:19 <alm48> Never mind, I had a duplicate definition of `Const` in my context. newtypes solved it :)  
04:00:20 <typetetris> Hmm :-/
04:17:52 <tomsmeding> typetetris: or perhaps some other module is being compiled with profiling, and that module depends on your code?
04:18:02 <tomsmeding> a test or something
04:19:04 <typetetris> Seems like nix turns on library profiling by default.
04:21:49 * hackage hevm 0.41.0 - Ethereum virtual machine evaluator  https://hackage.haskell.org/package/hevm-0.41.0 (MrChico)
04:31:02 <cr0ssw1nd> hey folks
04:36:00 <sshine> hi folk
05:09:50 * hackage amqp-utils 0.4.4.1 - AMQP toolset for the command line  https://hackage.haskell.org/package/amqp-utils-0.4.4.1 (woffs)
05:13:19 * hackage github-release 1.3.5 - Upload files to GitHub releases.  https://hackage.haskell.org/package/github-release-1.3.5 (fozworth)
05:22:27 <ADG1089> anyone looking for junior devs? I can pitch myself...
05:35:32 <sshine> interesting. I haven't seen #haskell being used like that before. :)
05:38:20 * hackage yaml 0.11.5.0 - Support for parsing and rendering YAML documents.  https://hackage.haskell.org/package/yaml-0.11.5.0 (MichaelSnoyman)
05:39:28 <merijn> sshine: People have advertised job openings here before :p
05:42:46 <sshine> I've been approached a few times. but I haven't seen anyone ask for open junior positions. :) it's positive.
05:45:26 <__monty__> ADG1089: The subreddit has occasional job openings.
05:45:53 <ADG1089> i saw one at typeable and applied
05:46:25 <ADG1089> haven't heard from them, they wanted someone who has worked on codebase with 10k loc and has knowledge of lenses, mtl, transformers, etc. etc.
05:46:42 <__monty__> Welcome to haskell job offers.
05:47:06 <ADG1089> so with me not having any real haskell experience apart from my hobby one, it is a bummer, the expectations are too high
05:47:10 <sshine> ADG1089, "junior" ;)
05:47:13 <ADG1089> should be some place for newcomers to apply
05:47:14 <merijn> tbh, there are not a lot of beginner openings for Haskell
05:47:34 <ADG1089> so you magically become senior overnight it seems :)
05:47:34 <merijn> ADG1089: Also, note that you should *always* (not just for Haskell) consider job "requirements" as wishlists
05:48:05 <sshine> I've seen "5 years of experience with 3-year-old technology" when I looked for jobs earlier this year.
05:48:18 <merijn> ADG1089: You have to realise that before the current popularity boom (sure, it's still niche, but orders of magnitude more popular than in the past) everyone in Haskell was already a senior in one or more other languages
05:48:21 <ADG1089> that's a prevalent meme with docker experience
05:48:50 <merijn> ADG1089: And a lot of Haskell job openings/companies are trying to hire from *that* pool of people, rather than just "anyone who knows haskell"
05:48:59 <ADG1089> hmm
05:49:19 <ADG1089> i am bored of making python flask apis at my current job, this is the fourth project, it gets mundane
05:49:31 <merijn> that said, there's certainly more junior openings iff you're willing to relocate
05:49:38 <[exa]> ADG1089: write a haskell generator for the APIs
05:49:53 <ADG1089> relocation won't be a problem
05:50:17 <ADG1089> it's mostly crud operations
05:50:20 <merijn> I think Standard Chartered regularly hires juniors for their Hong Kong/Singapore office (although, it's 2020 so who knows how things are now :p)
05:50:59 <ADG1089> this is me entering job market for first time after 1 yr of college placement so meh...
05:51:06 <ADG1089> it has just started
05:51:15 <ADG1089> will probably have to apply to lots of places
05:51:24 <merijn> ADG1089: Also, consider looking for Haskell "adjacent" jobs, companies using Ocaml/Erlang/F#/etc. will generally look positively on Haskell experience
05:51:54 <ADG1089> for the time being i started on ghc newcomer issues
05:52:06 <sshine> ADG1089, I know of someone who ran servers for a law firm and just took the liberty to do any programming-related stuff in Haskell. :) that's one entry-level path to real-world experience.
05:52:22 <ADG1089> did some refactoring but compiler performance regressed due to some inlining issues
05:53:01 <merijn> tbh, "real world experience" is overrated, networking is key. Although, admittedly, covid is making networking rather harder :p
05:57:24 <sshine> merijn, I've socialized more with Haskellers during covid because of the various video meetups like Berlin and Copenhagen FP groups. :)
05:58:06 <merijn> sshine: It's not the same
05:59:21 <dminuoso> merijn: what can I say. covid is making networking the business like christmas! 
05:59:58 <dminuoso> The amount of business fiber we've been sellig is amazing. :)
06:00:06 <sshine> dminuoso, how do I interpret that sentence?
06:00:15 <dminuoso> sshine: Oh we're an ISP.
06:00:31 <sshine> I mean the "networking the business like christmas" part :) I can't disambiguate.
06:00:45 <sshine> information service provider? ;-)
06:00:48 <dminuoso> Well we're getting business customers as presents constantly.
06:00:55 <dminuoso> You know, like gifts.
06:01:01 <ezzieyguywuf> hexagoxel: I'm unfamiliar with RankNType, but I'll do some research and try what you've posted, thanks for taking a look.
06:01:24 <dminuoso> ezzieyguywuf: Curious, why do you think you need RankNType?
06:01:32 <dminuoso> If I recall, you're still a beginner right?
06:02:34 <merijn> RankN isn't so hard
06:02:40 <sshine> ezzieyguywuf, tl;dr: normally when you have 'foo :: a -> a' you have an implicit 'foo :: forall a. a -> a', i.e. an implicit rank-1 type. a rank-2 type is when you have a 'forall' inside a parenthesis. I've once needed rank-2 types. often you don't, and you rarely need rank-N for N > 2 unless you really like types. :)
06:02:43 <merijn> I ran into them fairly early on my Haskell career
06:03:22 <merijn> ezzieyguywuf: See this small example: https://gist.github.com/merijn/77e3fa9757658e59b01d
06:04:49 <dminuoso> merijn: Ive used them early as well, but later on realized that it was better reengineering code for other reasons anyway. Then most rankntypes needs disappeare.
06:05:00 <dminuoso> Merely curious how beginners stumble onto them. What use cases they have
06:05:06 <dminuoso> (Or think they have)
06:05:56 <ezzieyguywuf> dminuoso: yes, very much a beginner
06:06:19 <ezzieyguywuf> dminuoso: I was trying to avoid some code duplication
06:06:51 <sshine> dminuoso, my use-case was pretty much exactly like merijn's example: inside a compiler, I had some helper function that processed binary operators where different parts of the AST had 'Int' or 'String'. the 'compileBinOp' function took a parameter being operator-specific.
06:07:03 <ezzieyguywuf> dminuoso: here's what I tried (https://dpaste.com/42TWJ8GKN), and here's the output I got (https://dpaste.com/74PFWLCD4). hexagoxel was suggesting the RankNType stuff
06:07:38 <ezzieyguywuf> merijn: I'll take a look thank you.
06:07:44 <dminuoso> ezzieyguywuf: That's a suspiciously German name. Where do you live?
06:07:50 <sshine> "avoiding code duplication" was my justification for learning rank-2 types somewhat early. (this was in SML which doesn't have rank-N types, so I had to port the compiler to Haskell.)
06:08:17 <ezzieyguywuf> dminuoso: I do have a german name, but I'm not german ^_^ I live in the US, but my family hails from South America
06:09:11 <dminuoso> Ah that explains the last name then I suppose
06:10:53 <ezzieyguywuf> lol does it? I don't even understand my last name ^_^
06:12:16 <ph88> how do i run MonadFail ?
06:12:31 <ph88> not sure how to use this function https://hackage.haskell.org/package/time-1.10/docs/Data-Time-Format-ISO8601.html#v:iso8601ParseM 
06:13:41 <ezzieyguywuf> merijn: in your small example, I think you've duplicated the issue I have. so the RankNType thing should resolve this?
06:15:15 <dminuoso> ph88: The same way you use anything that is polymorphic.
06:15:20 <dminuoso> You pick a type you like.
06:15:27 <dminuoso> Which MonadFail do you want
06:15:47 <ph88> i don't want any monad to be honest .. but seems i got one with that funciont o_O
06:15:51 <merijn> ezzieyguywuf: Yeah
06:16:24 <dminuoso> ph88: Perhaps Maybe? :)
06:16:28 <merijn> ezzieyguywuf: Essentially Rank2 types are way to *make* someone give you a polymorphic function
06:16:34 <dminuoso> Or. `Either String` ?
06:16:44 <merijn> ph88: Maybe is a MonadFail instance
06:16:54 <merijn> ph88: You can just use a type signature to get a Maybe
06:17:18 <ph88> Can i make it so that my program will just crash with an exception ?
06:17:28 <dminuoso> Sure. Use IO then! :)
06:17:45 <dminuoso> But really, use Maybe and do proper error handling
06:17:57 <dminuoso> It seems tiring at first, but it leads to writing stable code
06:18:08 <dminuoso> (Or `Either String` perhaps if you wan the error message)
06:20:04 <hc> hi all, designing a rest api with servant. Users can login, then use the API, then logout. It's self-contained. What do you say, using X-Auth-Token header? Or is another method preferred?
06:20:42 <dminuoso> hc: Look into servant-auth
06:20:42 <[exa]> hc: I just used Authorization:
06:20:53 <dminuoso> It takes care of the grinny details for you
06:21:54 <hc> [exa]: ah, okay. Just wondering if X-Auth-Token is too non-standard and may break things even when using TLS
06:22:54 <hc> dminuoso: looks like servant-auth is using cookies by default, which is something i'd like to avoid if at all possible :)
06:23:37 <dminuoso> hc: Mind my asking, why?
06:24:00 <hc> dminuoso: because it complicates some client APIs. You need ot set up a "cookie jar" or the likes
06:24:16 <dminuoso> You can also use jwt, which hides it in Authorization
06:24:42 <dminuoso> servant-auth supports cookie, jwt (embedded in Authorization) and basicauth
06:25:22 <hc> ok, thanks
06:27:04 <hc> a friend remarks cookies are out of the question because the EU requires popups when using them ;p
06:27:26 <Orbstheorem> hc: That's great :D
06:28:25 <dminuoso> hc: that's not quite right
06:28:44 <dminuoso> hc: cookies that are deemed strictly necessary are permittable without consent.
06:29:00 <Guest_15> how do i install haskell platform? i have tried to follow the link for mac os but i only get this: "_eghcup --cache install ghc recommended" failed!
06:30:01 <dminuoso> but anyway, you dont have to use cookies when using servant-auth
06:30:25 <Orbstheorem> dminuoso: I haven't read the whole log, but “strictly necessary” sounds very weak to me: Unless you can prove you cannot provide your service without recognising the user, it's kind of a moth argument, isn't it?
06:32:06 <dminuoso> Orbstheorem: https://gdpr.eu/cookies/ gives a rough summary.
06:32:45 <Orbstheorem> Thanks
06:35:10 <ezzieyguywuf> merijn: what I don't understand is *why* the RankN thing is needed - the code snippet you provided to me seems perfectly polymorphic
06:35:13 <ezzieyguywuf> to me.
06:36:10 <dminuoso> ezzieyguywuf: So a polymorphic binding is something where the caller/user/consumer decides on what the type is.
06:36:33 <dminuoso> The callee/implementor/provider cant know what that choice is going to be. It has to assume that some choice is made, but it cant know which.
06:37:25 <Orbstheorem> Is there any way to express the bottom of a stack in MTL-style signatures?
06:38:09 <ezzieyguywuf> dminuoso: so in merijn's example, you're saying `mangle` doesn't know ahead of time the return type of `f`?
06:38:18 <ezzieyguywuf> it seems like it's implicit based on the definition of `Foo`
06:38:45 <dminuoso> ezzieyguywuf: Conceptually its similar to how function arguments work. The function body cant decide what its argument is.
06:39:10 <dminuoso> say `\f -> {here}` in the spot of here, you cant decide what `f` is going to be. You cant decide it, your code has to work with any choice of `f`
06:39:20 <dminuoso> otoh the caller *has* to provide you with some cohice
06:40:29 <dminuoso> With polymorphic things it the same, except its about a type. When you take `id :: a -> a`, the *implementor* of `id` cant assume what type its called at. The type `a` is some unknown type from its perspective. The caller otoh *must* decide what type thats going to be.
06:40:47 <merijn> ezzieyguywuf: The initial version says "I work with any function "a -> a" IFF 'a' is an instance of NUM
06:40:50 <dminuoso> So we could think that calling id implicitly requires you telling the type. say `id @Int 10`
06:41:01 <dminuoso> The consumer/caller of id has that choice. The implementor hsa not.
06:41:06 <dminuoso> ezzieyguywuf: Does that so far make sense?
06:41:12 <merijn> ezzieyguywuf: So you give it "Int -> Int" and that typechecks, because Int is an instance of Num, but why that doesn't work should be clear
06:42:23 <dminuoso> ezzieyguywuf: So if we take a more complicated scenario of: `f :: (a -> a) -> a -> a`, still the *caller* of f decides what a is going to be. From the perspective of the implementation of f, the type `a` is some concrete but unknown type.
06:48:28 <ezzieyguywuf> lol, no I'm lost between callee/caller/implementor/provider
06:48:38 <ezzieyguywuf> but perhaps this stuff is out of my league for now...
06:49:01 <ezzieyguywuf> the code duplication in question would be liek 10-15 lines, maybe I jsut deal with that until I know better :)
06:49:30 <dminuoso> ezzieyguywuf: Okay, lets make an analogy.
06:49:39 <dminuoso> I give you a function, call it `f :: Int -> Int`
06:49:44 <ezzieyguywuf> I think I feel better knowing, though, that I'm not necessarily doing anything "wrong" (at least, I would have expected someone to have commented as such), and rather that I've just run into a weird problem domain that requires this higher level understanding
06:49:47 <dminuoso> I implemented it. You can call that function right?
06:49:50 <ezzieyguywuf> yes
06:50:00 <dminuoso> Okay, so you're the caller, Im the implementor.
06:50:15 <ezzieyguywuf> ok, I'm following
06:50:17 <dminuoso> So me, as the implementor, can I decide what the argument is going to be?
06:50:25 <dminuoso> Or is that *your* choice?
06:50:27 <ezzieyguywuf> no you cannot
06:50:31 <ezzieyguywuf> it must work with any Int
06:50:33 <dminuoso> Great!
06:50:36 <ezzieyguywuf> it is the caller's choice
06:50:45 <dminuoso> Its not just your choice, its your OBLIGATION to give me one
06:50:54 <ezzieyguywuf> indeed
06:50:58 <dminuoso> Even if the number, that you pass, itself is unknown to you. Either way
06:51:00 <dminuoso> You must pass something.
06:51:02 <dminuoso> Right
06:51:04 <dminuoso> ?
06:51:08 <ezzieyguywuf> correct
06:51:16 <ezzieyguywuf> that is the contract between the caller and the implementor
06:51:23 <dminuoso> So if you yourself implement a function taking an int, you cant decide on that int. But you could call me with that int.
06:51:28 <dminuoso> Does that make sense too?
06:51:49 <ezzieyguywuf> dminuoso: "you yourself" being the caller of `f`?
06:51:58 <[exa]> hm, any best way to patternmatch a prefixed Text in a Just? as in:  case x of {Just ("prefix_" ??? rest) -> ...}
06:52:01 <dminuoso> Yes. You're still the caller of f.
06:52:21 <ezzieyguywuf> [exa]: fmap and Text.prefix or some such?
06:52:28 <dminuoso> [exa]: use stripPrefix with ViewPatterns
06:53:30 <[exa]> wow okay, thanks!
06:54:05 <ezzieyguywuf> dminuoso: so yes, I still follow
06:54:09 <dminuoso> ViewPatterns also works with case-of, though its not as well documented
06:54:20 <dminuoso> ezzieyguywuf: Great! So lets look at what other things we have.
06:54:26 <dminuoso> Assume, I dont just implement a function
06:54:44 <dminuoso> but a higher order function. namely `f :: (Int -> Char) -> Char`
06:54:47 <dminuoso> You're the caller of `f`
06:54:51 <dminuoso> Who gets to decide on what Int is?
06:55:11 <ezzieyguywuf> hm...
06:55:18 <dminuoso> Consider how you'd be calling `f`.
06:55:19 <ezzieyguywuf> it sounds like `f`
06:55:30 <ezzieyguywuf> because `f` is the caller of `(Int -> Char)`
06:55:33 <dminuoso> Right!
06:55:34 <ezzieyguywuf> supposedly
06:55:40 <dminuoso> And more to the point
06:55:47 <dminuoso> I could call that function multiple times, with different ints, right?
06:55:55 <dminuoso> But you yourself have absolutely no control over it.
06:55:55 <ezzieyguywuf> absolutely
06:55:59 <Orbstheorem> dminuoso merijn (flashback to this morning questions): Any guess at why there's no MTL-style package for Database.Persist.Sql?
06:56:54 <dminuoso> ezzieyguywuf: If we did that again, and said Im th eimplementor of something function `h :: ((Int -> Char) -> Bool) -> String`
06:56:55 <merijn> Orbstheorem: Because it's a terrible idea
06:57:08 <merijn> Orbstheorem: The ReaderT effectively forms the duration of a transaction
06:57:12 <dminuoso> ezzieyguywuf: Who has the obligation/freedom to decide on the Int?
06:57:24 <merijn> Orbstheorem: If you use MonadReader or something your transactions become "the entire program length"
06:57:38 <ezzieyguywuf> dminuoso: doesn't seem like you can know for sure.
06:57:42 <merijn> Orbstheorem: This isn't very well documented, tbh, and I think tons of persistent code is wrong
06:57:49 <dminuoso> Well if its not me, who then?
06:57:50 <maerwald> oh boy
06:57:51 <ezzieyguywuf> dminuoso: because `h` may pass the function on somewhere else
06:57:52 <dminuoso> There's only us two :)
06:57:55 <Orbstheorem> merijn: Wow, I hadn't realised that.
06:58:02 <merijn> Orbstheorem: Nobody does, I think
06:58:25 <merijn> Orbstheorem: I've only realised this after weeks of staring at persistent implementation code while patching things to do what I want :p
06:58:26 <dminuoso> ezzieyguywuf: Imagine how you'd call my h.
06:58:34 <ezzieyguywuf> dminuoso: in that case, I'm guessing it's `h`, but this is getting pretty meta :-P
06:58:35 <maerwald> merijn: but at least you got fancy types...
06:58:43 <Orbstheorem> I was literally convincing myself that writing a transformer that launders my current transformer into UnliftMonad using a Natural transformation.
06:58:47 <merijn> maerwald: persistent doesn't even have fancy types
06:58:53 <maerwald> not cool
06:58:57 <dminuoso> ezzieyguywuf: What do you mean by h?
06:59:07 <ezzieyguywuf> dminuoso: `h` decides what the Int is
06:59:08 <dminuoso> ezzieyguywuf: Im the the implementor of h, you're the caller. Who picks the Int now?
06:59:18 <ezzieyguywuf> dminuoso: implementor of `h`
06:59:22 <dminuoso> ezzieyguywuf: are you sure?
06:59:27 <Orbstheorem> s/that/about
06:59:36 <merijn> Orbstheorem: tbh, I think persistent is secretly quite hard to use, but you don't notice because "wrong" usage seems to work
06:59:50 <merijn> dminuoso: I think your explanation might be kinda confusing ;)
06:59:52 <ezzieyguywuf> dminuoso: no 😂
06:59:56 <merijn> ezzieyguywuf: Alternate explanation attempt
07:00:07 <dminuoso> ezzieyguywuf: ah well, lets actually just stop right here. The previous bits was enough.
07:00:29 <merijn> ezzieyguywuf: So, first off, referring to my mangle example: I assume that it's clear why the function you pass to mangle must be polymorphic, right?
07:00:31 <dminuoso> ezzieyguywuf: The point is, polymorphic things work exactly the same way. Except, we're not passing Ints but types themselves.
07:00:49 * hackage mcmc 0.2.3 - Sample from a posterior using Markov chain Monte Carlo  https://hackage.haskell.org/package/mcmc-0.2.3 (dschrempf)
07:01:03 <ezzieyguywuf> merijn: yes, because `Foo` can have either an Int or a Double
07:01:14 <merijn> ezzieyguywuf: Right
07:02:26 <merijn> ezzieyguywuf: So, if we have the first version with "mangle :: Num a => (a -> a) -> Foo -> Foo" then this doesn't work, because I can pass "Int -> Int" to mangle (since it accepts anything that unifies with "a -> a")
07:02:55 <merijn> ezzieyguywuf: So the problem we're faced with is: How do I enforce that an argument function *must* be polymorphic
07:03:16 <ezzieyguywuf> ah hah!
07:03:19 <merijn> ezzieyguywuf: This is what the RankN types encodes
07:03:28 <ezzieyguywuf> dminuoso: you're walkthrough helped me understand merijn's example :)
07:03:49 <ezzieyguywuf> thanks to you both!
07:03:54 <merijn> ezzieyguywuf: (forall a . a -> a) *forces* you to give me a function that is polymorphic (i.e. it works for, well, all 'a')
07:03:59 <ezzieyguywuf> also, I imagine RankN is some language extension
07:04:35 <dminuoso> It is.
07:04:36 <merijn> ezzieyguywuf: Now, a function that works for all 'a' is kinda boring (only 'id' does), hence the "Num a =>" constraint which says "the function must work for all 'a' that also happen to be Num instances"
07:04:45 <dminuoso> Anything you enable via {-# LANGUAGE ... #-} is a language extension
07:04:48 <ezzieyguywuf> merijn: beautiful, I perfectly understand (forall a . a -> a) now
07:05:03 <merijn> ezzieyguywuf: Rank2Types and RankNTypes are a language extension allowing you to write Rank2 (and RankN) types
07:05:23 <ezzieyguywuf> merijn: do I need to understand the distinction betwoon Rank2 and RankN?
07:05:35 <merijn> ezzieyguywuf: No, because currently there isn't one in GHC :p
07:06:06 <ezzieyguywuf> 😂 there isnt Rank2 or RankN?
07:06:17 <merijn> ezzieyguywuf: Rank3 is just "what if I force something to accept a polymorphic Rank2 function?", and then that generalises to any rank
07:06:40 <merijn> ezzieyguywuf: The distinction is that *in theory* type inference is possible (although not currently implemented in GHC) for rank 2 types
07:06:54 <merijn> Type inference for rank 3+ is proven to be impossible
07:07:14 <merijn> So, in theory, Rank2Types could be a separate extension still supporting type inference
07:07:26 <merijn> In reality Rank2Types just enables the RankNTypes extension in GHC :p
07:08:31 <ezzieyguywuf> so I need Rank2Types
07:09:31 <merijn> ezzieyguywuf: In the underlying theory used by GHC every function has explicit foralls (which GHC implicitly adds for you), so when you write "id :: a -> a" then what GHC turns that into is "id :: forall a . a -> a" (that'd be Rank 1), so "foo :: (forall a . a -> a) -> b ->b" is rank 2, because that turns into "foo :: forall b . (forall a . a -> a) -> b -> b" (note: 2 levels of forall nesting, thus rank 2)
07:09:57 <dminuoso> ezzieyguywuf: https://gist.github.com/dminuoso/052b01e143d2180eb927f7ea3e9135e6
07:10:09 <dminuoso> ezzieyguywuf: This is a cleaned up version of what I was trying to explain. :)
07:10:36 <ezzieyguywuf> merijn: ah, i see
07:10:50 <merijn> ezzieyguywuf: So, actually what might make things even clearer is that in the underlying theory the type argument represented by "forall" are actual argument to the function that you must pass
07:11:14 <dolio> I haven't read about it, but I suspect the rank-2 inference would be pretty gnarly. I don't think it has principal types, so it probably involves backtracking or something.
07:11:26 <merijn> ezzieyguywuf: So internally GHC turns "id True" into "id @Bool True"
07:11:30 <merijn> dolio: It is horrific
07:11:37 <merijn> dolio: Which is why it's not in GHC :p
07:11:48 * hackage essence-of-live-coding-warp 0.2.1 - General purpose live coding framework  https://hackage.haskell.org/package/essence-of-live-coding-warp-0.2.1 (turion)
07:11:54 <merijn> ezzieyguywuf: Which actually makes sense with the Rank2 "mangle"
07:12:27 <merijn> ezzieyguywuf: Because "(forall a . Num a => a -> a) -> Foo -> Foo" means that "mangle" still has to (internally) pass a type to it's argument function to call it
07:13:06 <merijn> ezzieyguywuf: So you'd get "mangle f (Foo i) = Foo (f @Int i); mangle f (Bar d) = Bar (f @Double d)"
07:14:40 <merijn> (this is all pretty much how GHC treats things internally)
07:16:05 <ezzieyguywuf> merijn: I'll say I followed 90% of that last part, which I think is good
07:16:16 <ezzieyguywuf> merijn: "It is horrific", refering to the implementation of Rank2 extension?
07:16:30 <dminuoso> ezzieyguywuf: No.
07:16:42 <dminuoso> ezzieyguywuf: Essentially with higher ranked types type inference becomes undecidable
07:16:53 <dminuoso> with rank-2 I think its decidable, but tough to implement
07:16:59 <dminuoso> so we have no type inference at that point anymore
07:17:10 <merijn> ezzieyguywuf: horrific is referring to the *type inference* of rank2 types
07:17:31 <ezzieyguywuf> that sort of suggests that maybe I shouldn't use it...
07:17:34 <dminuoso> no
07:17:46 <dminuoso> ezzieyguywuf: It just means haskell cannot automatically infer something to be of a higher ranked type on its own.
07:17:49 <merijn> ezzieyguywuf: You should, you just *have* to write down a type signature
07:17:54 <dminuoso> You must explicitly write a type annotation
07:18:08 <dminuoso> (Which you probably should be doing *anyway*)
07:18:18 <ezzieyguywuf> ah. that's cool, I was already trying to solve my problem with type annotations
07:18:24 <ezzieyguywuf> I was just missing the `forall`
07:18:25 <merijn> ezzieyguywuf: rank2 and rankN are fine, they are probably the least controversial extensions in GHC
07:18:34 <monochrom> Do the right thing. Use rank-2 iff rank-2 is appropriate.
07:18:38 <ezzieyguywuf> well, I use type annotations on *all* my functions
07:18:53 <dminuoso> monochrom: Bah. I flip on RankNTypes whenever I feel like adding an explicit forall!
07:18:54 <merijn> ezzieyguywuf: Right, which is why its a non-issue that rank2 can't be inferred ;)
07:18:59 <dminuoso> Because why not.
07:19:08 <dminuoso> Less extensions to remember >:)
07:19:16 <monochrom> But there is ExplicitForall and ScopedTypeVariables
07:19:55 <monochrom> I think ScopedTypeVariables is a good extension to flip on permanently.
07:20:06 <merijn> monochrom: meh...
07:20:15 <merijn> monochrom: There's only 26 letters in the alphabet
07:20:16 <monochrom> This allows you to both write rank-1 foralls and SML style functions.
07:20:26 <merijn> monochrom: I'd run out of type variables for my where blocks
07:20:38 <dminuoso> monochrom: and then, type variables should be capturable whether or not introduced via forall :p
07:20:54 <dminuoso> merijn: ScopedTypeVariables enabled by default does not mean all tyvars are capturable
07:21:01 <dminuoso> unless you have a habit of writing explicit forall everywhere
07:21:06 <monochrom> Consider using a letter followed by a digit.
07:21:17 <merijn> monochrom: Heresy
07:21:19 <dminuoso> Also, tyvars can have more than one letter.
07:21:28 <merijn> @quote first.26
07:21:29 <lambdabot> alexbagel says: i find that my first 26 variables are always easy to name. after that it becomes a bit harder.
07:22:06 <dolio> Seems like this is probably an indication of some other problem.
07:24:09 <monochrom> dminuoso: I think there is no conflict between enabling RankNTypes and not actually writing rank-2, rank-3 etc types.
07:25:02 <dminuoso> monochrom: I wonder why those are separate anyway. Is that possibly to accomodate implementations where rank-2 is simpler to implement than arbitrary rank-n?
07:25:24 <monochrom> Historically that was the consideration.
07:25:40 <merijn> No, they were in at the same time, afaik
07:25:57 <merijn> AFAIK the distinction is to leave open the possibility of GHC at some point getting Rank2 inference
07:27:07 <monochrom> They have closed that door because they have long declared synonym.
07:27:54 <merijn> possibly
07:28:09 <merijn> I think the algorithm was a convoluted 148 page atrocity anyway
07:28:16 <merijn> No one cares about inference that much too bother
07:29:13 <edwardk> i'd be really sad if we picked up rank 2 inference. most of the time the types it'll spit out are garbage, so it'll prevent you from realizing real type errors and supply some heinous types
07:29:52 <edwardk> iirc the other reason why rank 2 was distinguished form rank n was hugs supported the former, but not the latter, no?
07:29:57 <edwardk> (not an expert)
07:30:17 <merijn> oh, maybe?
07:32:22 <monochrom> I forgot what hugs did. But when we had ghc, hugs, jhc, hbc, and the prospect that more future haskell implementations might come, it was realistic to have Rank2Types and RankNTypes and allow different compilers to choose different degrees of support.
07:32:34 <monochrom> That dream died quickly.
07:34:04 <merijn> monochrom: And you're just going to ignore UHC? :O
07:34:17 <merijn> The only compiler that actually still lives besides GHC :p
07:34:27 <monochrom> I forgot uhc
07:34:34 <merijn> Everyone does :p
07:34:49 <monochrom> I knew there is another ?hc besides jhc
07:34:53 <ezzieyguywuf> WHOOT! RankNTypes _does_ in fact fix my problem
07:34:58 <dminuoso> @remember edwardk (not an expert)
07:34:58 <lambdabot> Done.
07:35:18 <monochrom> haha
07:35:36 <dolio> There was also yhc and nhc98.
07:35:46 <merijn> Man, I used to be so witty...
07:35:58 <merijn> (I was just inspecting the quotes lambdabot had of me)
07:36:07 <olle> Isn't Haskell IO monad automatically concurrent?
07:36:20 <monochrom> No.
07:36:21 <merijn> olle: Define "automatically" and "concurrent"
07:36:31 <merijn> But probably "no" :p
07:36:34 <monochrom> What merijn said is better.
07:36:47 <monochrom> I just like to say no.
07:37:01 <merijn> monochrom: You're like a compiler of a strongly typed language :p
07:37:04 <monochrom> Crush people's wishful thinking and fantastic expectations.
07:37:21 <merijn> monochrom: Meanwhile, I'm more of compiler as dreamt about in McBride's thesis and epigram ;)
07:37:47 <olle> hm, no good search results, only papers and books :|
07:38:22 <dminuoso> Yes, wouldn't it be wonderful if IO ran things in any order it could like according to dependencies? (>>) will never be the same again!
07:38:35 <merijn> @quote merijn RankNTypes
07:38:36 <lambdabot> merijn says: It starts with "RankNTypes is nice" and ends with "the first 10 lines of my file are language pragmas" :)
07:38:43 <merijn> No clue what that was about
07:38:54 <merijn> Also, 10 lines of pragmas seems awfully quaint now
07:38:58 <merijn> Gotta update that to 30 :p
07:39:40 <olle> dminuoso: no, but adding a simple keyword to make concurrency happen
07:39:53 <olle> in PHP concurrent libs you can yield a list to make them concurrent
07:40:01 <merijn> olle: Define "concurrency" and define "happen"
07:40:08 <olle> non-blocking IO
07:40:25 <merijn> Right, so what you *really* wanted was mapConcurrently from async
07:40:43 <dminuoso> olle: Look Haxl perhaps?
07:41:03 <dminuoso> Or just async. Depends a bit on what you need.
07:41:36 <olle> merijn: maybe. :) time to order a book, perhaps!
07:41:39 <olle> or two!
07:41:54 * olle should be studying german instead of comp sci...
07:48:26 <dolio> Seems like the pragme explosion could be tamed a lot by accepting some reasonable ones into the defaults.
07:48:36 <merijn> dolio: hah
07:48:48 <dolio> Like, do you really need to be able to separately toggle deriving Functor, Foldable and Traversable?
07:48:51 <merijn> dolio: And thus began many ill-fated quests to revive Haskell Prime ;)
07:49:27 <dolio> Do they need to be able to be turned off at all?
07:49:47 <asheshambasta> what's the recommended way to debug inf. recursions etc. in Haskell?
07:49:55 <merijn> dolio: GHC (mostly) defaulting to the report is good, imo
07:50:02 <merijn> @quote refreshing.desert
07:50:02 <lambdabot> chromatic says: My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency.
07:50:06 <merijn> asheshambasta: ^^
07:50:24 <merijn> So, Debug.Trace :p
07:51:01 <asheshambasta> merijn: I've been using that; but with a codebase containing multiple dependenices etc. it is a real pain to debug with adding trace calls and rebuilding the root project
07:51:36 <merijn> asheshambasta: There's a debugger in ghci
08:05:40 <ph88> does anyone have a good example with aeson to grab some value deeper in the json ? i find myself having to use withObject and .: a lot and it's getting complicated
08:06:18 <lortabac> @hackage lens-aeson
08:06:18 <lambdabot> https://hackage.haskell.org/package/lens-aeson
08:06:36 <lortabac> ph88: this might be useful ^
08:06:53 <lortabac> or overkill, depending on the actual need
08:07:14 <siraben> lenses are always the answer for deeply nested records
08:07:14 <ph88> does it come with an explanation somewhere ?
08:07:56 <lortabac> there should be at least some examples
08:11:52 <kuribas> asheshambasta: those are a pain.  I had them a few times when updating a variable, like let x1 = ... x, but writing let x = ... x instead.
08:12:00 <kuribas> makes me wish haskell was total
08:12:27 <kuribas> asheshambasta: I would just use trace statements and binary search to the spot :)
08:12:42 <kuribas> not the most sofisticated approach...
08:12:54 <rotaerk> is a "total" language viable for general purpose programming?
08:12:58 <merijn> rotaerk: Sure
08:13:02 <merijn> rotaerk: Why not?
08:14:09 <rotaerk> how do you handle desirably-infinite loops?
08:14:32 <dolio> Coinduction.
08:14:42 <merijn> rotaerk: So, first of all, I'd say the number of desirable infinite loops is basically just 1 which is "the main server loop"
08:14:47 <kuribas> rotaerk: infinte loops are not desirable
08:14:57 <merijn> Which can be done via coinduction, indeed
08:15:19 <rotaerk> interesting; I'll have to read up on that concept
08:15:29 <merijn> Or via a Partial monad-like trick like Haskell uses for IO
08:15:58 <asheshambasta> yeah; I've been plagued with these quite often too; and it probably makes me more prone to these issues due to style 
08:16:07 <merijn> Which I think is basically a different way of saying coinduction
08:16:30 <asheshambasta> But these are impossibly hard to drill down in a non-trivial codebase 
08:16:59 <merijn> rotaerk: Basically, you define like "Partial a" which is a datatype that in a finite number of steps returns either 'a' or a continuation that returns 'Partial a' and then you have the RTS loop that
08:17:21 <rotaerk> I see...
08:17:26 <kuribas> asheshambasta: maybe you need finer grained tests then?
08:19:03 <asheshambasta> kuribas: yeah, probably. But I still struggle to write tests that are dealing with state. Especially with services that I need to talk to, it is cumbersome to write mock apis etc. 
08:20:35 <kuribas> asheshambasta: you may find this article useful: https://www.parsonsmatt.org/2017/07/27/inverted_mocking.html
08:20:54 <kuribas> basically, avoid mocking if you can, but isolating business logic in pure code.
08:22:59 <kuribas> For example, you can collect the data from the services you talk with in a data structure, than use a pure function to update it.
08:25:09 <kuribas> then instead of mocking the service, you fill in the data structure with test data.
08:25:23 <kuribas> fake data, or real data from the service.
08:26:21 <asheshambasta> hm yeah.
08:26:45 <asheshambasta> this will not work if the source-service's schema changes though
08:27:19 <kuribas> no, but you can make another test for that.
08:27:28 <kuribas> where you don't need mocking
08:28:19 <asheshambasta> also, with tests and these inf. recursive issues, you will /know/ there is an issue, but not where. You're still going to have to rely on the same methods to find where the issue is. In this case, my suspicion points to an mtl stack that implements some instances wrongly. 
08:30:32 <kuribas> a library mtl stack?
08:31:10 <kuribas> My mtl stacks usually are nothing more than GeneralizedNewtypeDeriving standard monads.
08:31:29 <asheshambasta> kuribas: no something I handrolled
08:33:05 <kuribas> why not use GeneralizedNewtypeDeriving?
08:36:09 <hololeap> i agree, it's pretty hard to come up with a new monad transformer that isn't just a combination of what's in mtl
08:36:39 <kuribas> some libraries use cps for performance, like megaparsec.
08:37:07 <monochrom> I thought that "doWorkAbstract :: Monad m => m Query -> (Query -> m [User]) -> ... -> m ()" was already mock-testing.
08:37:50 <monochrom> Or rather opening up for mock-testing. The actual mock-testing is right after, the doWorkScribe version.
08:38:51 <lortabac> asheshambasta: did you try profiling the application? if you let it run enough time, the place where infinite recursion happens should climb to the top
08:39:11 <lortabac> unless inlining interferes
08:39:35 <asheshambasta> lortabac: I've not tried that no
08:39:52 <kuribas> wasn't there a way to make ghc show source lines?
08:40:01 <kuribas> then you send it a signal, it it shows where it is.
08:40:24 <monochrom> I am thinking this is not so much "there are better ways than mock-testing" but rather more "there are better scopes and targets for mock-testing".
08:40:56 <solonarv> you can tell the RTS to print out a stack trace (which includes source lines, IIRC) when an exception is thrown, and (some) signals cause an exception to be thrown in the active thread
08:41:51 <kuribas> maybe this: http://www.well-typed.com/blog/2020/04/dwarf-1/
08:42:34 <monochrom> Ah but I'm afraid ghcup doesn't choose a build that supports DWARF :)
08:43:31 <merijn>  kuribas: as in stack traces? or what?
08:44:02 <kuribas> > Dumping runtime call stacks to the console using the SIGQUIT signal; this is particularly useful in production
08:44:03 <lambdabot>  <hint>:1:68: error: parse error on input ‘;’
08:44:10 <kuribas> shutup
08:44:24 <monochrom> :(
08:44:39 <kuribas> that was a quote :)
08:44:52 <dolio> Use quotation marks.
08:47:17 <kuribas> 〞Dumping runtime call stacks to the console using the SIGQUIT signal; this is particularly useful in production〟
08:47:17 <kuribas>  
08:47:50 <merijn> kuribas: If you have a DWARF enabled RTS, yes
08:50:27 <hekkaidekapus> monochrom: ghcup compile ghc --help
08:50:31 <MarcelineVQ> mniip: are you aware of WordMap? https://github.com/gereeter/bounded-intmap  it's an interesting read, not sure how useful to you. an extension to patricia trees, it explains those too if you're unfamiliar
08:51:27 <monochrom> That doesn't count.
08:51:39 <hekkaidekapus> lol
08:51:49 <hekkaidekapus> It is ghcup, still.
08:52:20 <monochrom> Yes I think my students behave like that.
08:52:35 <monochrom> They usually only see 20% of what I write.
08:52:40 <hekkaidekapus> (I know you meant bindist.)
08:53:36 <monochrom> I gave this assignment: http://www.cs.utoronto.ca/~trebla/CSCB09-2020-Summer/a3/task.html
08:53:47 <MarcelineVQ> monochrom: "Why does this professor repeat himself so much?" "For the students who don't notice that."
08:54:03 <monochrom> I had a whole bunch of students who handed in the equiv of "prog2 args | prog1" in C.
08:54:32 <monochrom> That means the central 50% of the assignment handout was completely invisible to them.
08:54:58 <monochrom> "It is pipes, still" would be what they would say.
08:55:12 <monochrom> what they would say about their flawed solutions
08:55:55 <hekkaidekapus> I’d really love to attend to your lectures, say for a week.
08:58:22 <merijn> MarcelineVQ: Because they didn't read the fucking syllabus, that's why >.>
08:58:55 <monochrom> They read and watch everything on the Internet except my stuff.
08:59:46 <monochrom> I had short exam questions whose answers would be straight copying from a lecture slide.
09:00:03 <monochrom> They would rather copy a wrong answer from stackoverflow than my lecture slide.
09:00:28 <monochrom> I no longer know what it means when they say "we study very hard, many hours"
09:03:37 <maerwald> you can install dwarf bindists too if they exist
09:06:10 <hekkaidekapus> Seems they do, https://downloads.haskell.org/~ghc/8.10.2/
09:06:38 <maerwald> yeah, sec
09:07:20 <hekkaidekapus> So, how does one toggle a DWARF bindist? Do I need to RFM?
09:07:41 <maerwald> it's kind of underdocumented
09:07:55 <maerwald> ghcup -c -n install ghc -u '{"dlHash": "", "dlSubdir": { "RegexDir": "ghc-.*"}, "dlUri": "https://downloads.haskell.org/~ghc/8.10.2/ghc-8.10.2-x86_64-deb10-linux-dwarf.tar.xz" }' 8.10.2-dwarf
09:08:39 <hekkaidekapus> Thanks
09:09:10 <maerwald> the binaries will be `ghc-8.10.2-dwarf`
10:18:08 <tomsmeding> urlse
10:18:16 <tomsmeding> (sorry)
10:32:30 <AWizzArd> Will GHC 9.0.1 ship with linear types?
10:40:01 <monochrom> I heard yes.
10:40:16 <monochrom> But channel logs are more reliable than my memory.
10:40:42 <yushyin> https://gitlab.haskell.org/ghc/ghc/-/wikis/status/ghc-9.0.1
10:42:43 <AWizzArd> The status mentions it as planned, I see.
10:42:52 <monochrom> Is the "!" in "!852 (closed)" some linear type notation? :)
10:43:04 <AWizzArd> monochrom: (:
10:43:38 * monochrom always looks for puns
10:44:45 <yushyin> I also do like the migration guide wiki pages, very useful.
10:45:03 <ph88> is there a version of elem that works with a predicate ? i need to inspect a field of a record in a list
10:46:34 <tomsmeding> ph88: `isJust . find predicate` ?
10:47:34 <solonarv> even better: 'any'
10:47:53 <tomsmeding> far better
10:51:53 <tomsmeding> above the implementation for 'and', 'or', 'any', 'all', the base source code says "These use foldr rather than foldMap to avoid repeated concatenation."
10:51:56 <tomsmeding> https://hackage.haskell.org/package/base-4.14.0.0/docs/src/Data.Foldable.html#line-642
10:52:03 <tomsmeding> followed by four functions defined in terms of foldMap
10:53:04 <solonarv> perhaps that statement is about functions defined *above* the comment?
10:53:32 <solonarv> yep, looks like it
10:54:39 <ph88> any is exactly what i needed, thanks guys !
11:05:58 <mrvoid> I do not know haskell and have been strugglin to get xmonad to work. I installed it from my package manager and got the devel packages. I got my default config from the haskell site.  When I  start xmonad I get this error: kjhttps://pastebin.com/8c2KcBjm
11:07:45 <mrvoid> https://pastebin.com/8c2KcBjm
11:17:22 <sm[m]> there's an #xmonad, mrvoid
11:36:54 <tomsmeding> (they left)
11:43:08 <Uniaika> (but what was their Right type?)
11:44:56 <tomsmeding> ('Maybe, clearly)
11:58:02 <Uniaika> tomsmeding: I would have said Void
11:58:03 <Uniaika> :P
12:18:42 <nate48423> denaro and the american government is getting my human brain and i go through things like no sleep, not comprehending, changing taste of food. please tell your world leaders i dont want amaerica to get my human brain and its serious terrorism going on in the country with denaro chips inside of people
12:20:32 --- mode: ChanServ set +o monochrom
12:20:38 --- mode: monochrom set +b *!*@50-36-180-21.alma.mi.frontiernet.net
12:20:38 --- kick: nate48423 was kicked by monochrom (nate48423)
12:20:42 --- mode: monochrom set -o monochrom
12:21:22 <Uniaika> well first of all it's "crisps".
12:21:48 <maerwald> "my world leader"?
12:22:04 <maerwald> call SPJ?
12:22:45 <Uniaika> the leader of world, captain of my heart, comodore of my soul…
12:22:51 <Uniaika> Joe Armstrong
12:22:55 <int-e> maerwald: https://en.wikipedia.org/wiki/Society_of_Professional_Journalists ;)
12:23:00 <Uniaika> who smiles upon me from the Heavens
12:24:29 <monochrom> I am your world leader and I command you to stop being offtopice :)
12:24:40 * Clint squints.
12:24:41 <int-e> There aren't enough thee letter acronyms to satisfy all the demands we make of them.
12:24:52 <int-e> *three
12:25:10 <ph88> how can i write an alias for a constraint ?
12:25:23 <monochrom> But apparently 3-letter function names and unix commands are doing OK
12:25:26 <Uniaika> aye aye captain monochrom 
12:25:39 <int-e> monochrom: it does work in limited scopes.
12:25:45 <Uniaika> ph88: I went through that phase too
12:25:55 <ph88> what phase ?
12:25:56 <Uniaika> ph88: unless it's a really ugly constraint, it's usually useless
12:26:00 <int-e> (And indeed I had no trouble figuring out who "SPJ" refers to.)
12:26:05 <monochrom> "type C a = (Show a, Read a)" is probably good under enough extensions
12:26:17 <ph88> thanks monochrom 
12:26:23 <Uniaika> ph88: beware, though
12:26:33 <Uniaika> you'll be giving the user a set of constraints
12:26:50 <Uniaika> but the compiler will show you the unaliased, true constraints, in error messages
12:27:38 <ph88> oki
12:47:07 <ph88> i never used ReaderT before, could someone tell me why it's not working together with req ?  https://bpa.st/XU5Q 
12:47:28 <ph88> maybe i should  <- ask   before runReq ?
12:48:22 <ph88> hhmm ye that seems to work .. just i like to know if it's possible to combine the reader and req monad
12:51:08 <int-e> ph88: you'd have to extend the Req type inside the req package to add reader capability, so no.
12:51:21 <ph88> oh ok
12:51:25 <int-e> ph88: I guess you can do the lifting dance...
12:51:33 <ph88> how does the lifting dance work ?
12:51:46 <int-e> ask >>= \r -> runReq $ runReaderT action r
12:52:12 <ph88> uhu
12:52:14 <int-e> where action :: ReaderT r Req a
12:52:27 <ph88> that doesn't look so simple
12:52:33 <int-e> It's not.
12:57:52 <hyperisco> ah yes the App Monad
12:58:16 <hyperisco> the admittance of defeat and the return to procedural programming
12:58:33 <hyperisco> (I'm a fan)
12:59:30 <monochrom> The alternative is FRP
13:01:31 <otulp> ... the alternative to a giant App Monad is FRP? I don't get it.
13:01:52 <hyperisco> I feel like we still have a leg up because you can design your App, and when you're feeling more motivated and inspired you don't even have to use it
13:01:53 <monochrom> procedural, I/O-heavy programming
13:02:19 <monochrom> especially the high-interaction kind
13:04:12 <otulp> Well, in a way using any onad at all is "procedural".
13:04:41 <otulp> Dang it. I've been on Slack too long.
13:06:10 <hyperisco> sometimes you're able to consider a domain carefully and devise a language for beautifully declarative expressions
13:06:23 <hyperisco> other times you just want to say do this then do that and go home
13:15:55 <ph88> how can i ask the user for a password so it doesn't show .. like with the sudo command
13:18:14 <ph88> and how can i put some text like   "username: "  and then have the user type something immediately after that ?
13:19:21 <ph88> hhmm maybe i should use System.Console.Haskeline after all
13:19:34 <otulp> I think you could use haskeline for that. It even has a "getPassword".
13:19:56 <dolio> Are mathematicians doing procedural programming when they use monads to talk about groups?
13:22:38 <otulp> Was expecting something like that :)
13:23:28 <otulp> So, I'm going to say "yes" and then just hum loudly with fingers in ears.
13:24:05 <dolio> When you have a syntax tree parameterized by free variable type, is using `(>>=) :: Stx a -> (a -> Stx b) -> Stx b` to do substitution procedural?
13:24:58 <otulp> For real, though, in Haskell at least I usually end up using Monad for doing "something involving a sequence of steps"-ish.
13:25:49 <otulp> Hopefully, the missing "m" in my erroneous statement might serve as a hint that I didn't really mean to push that line out into the terminal. I was writing it, then changed my mind, then screwed up.
13:25:59 <dminuoso> What is considered a Char in a String? A unicode codepoint? Grapheme clusters?
13:26:32 <otulp> So in a way, I guess I can keep claiming that onads are for procedural programming.
13:26:54 <dminuoso> otulp: monads dont have a specific purpose other than capturing a reoccuring theme.
13:27:24 <dminuoso> That is, monadic things exist whether you want it or not. We just happen to capture it in a typeclass when it happens.
13:28:20 * hackage matterhorn 50200.10.1 - Terminal client for the Mattermost chat system  https://hackage.haskell.org/package/matterhorn-50200.10.1 (JonathanDaugherty)
13:28:48 <otulp> Well far be it from me to deny any monadic thing its existence.
13:31:08 <dminuoso> otulp: It's better to say it the other way around: sequencing of effects in procedural programming is monadic, but not all monads are about sequencing. :)
13:32:13 <dminuoso> Consider some stranger monads like Tardis, or Concurrently, Prob, []/Logic..
13:33:38 <otulp> Sure, agreed.
13:33:53 <dminuoso> hyperisco: re beautiful declarative expressions: Every time I watch a talk from conal, I have some vague understanding about "denotational semantics are the thing you want", but I dont really get what that means or how you achieve that. :<
13:34:34 <hyperisco> dminuoso, I somewhat do
13:35:25 <hyperisco> and for me I think the confusion was trying to go in the wrong direction
13:35:53 <hyperisco> trying to put the toothpaste back in the tube (to borrow from McBride)
13:36:14 <Capri64> Hi!
13:36:41 <Capri64> How do I compile a haskell file depending on a c-library?
13:37:01 <hyperisco> you should think primarily from the semantics, fitting syntax to it
13:37:17 <hyperisco> not the other way around, trying to retrospectively explain your syntax
13:37:18 <dminuoso> hyperisco: Yeah, this starts off rather vague again. ;)
13:37:37 <hyperisco> dminuoso, I'll give you a quick example then… lets talk about sets
13:37:48 <dminuoso> sets I know
13:38:07 <monochrom> ph88: System.IO.hSetEcho can help.
13:38:26 <Capri64> ghc -O --make my-main-file.hs   doesnt generate an executable. I have a foreign import call on a c-lib that's not compiled
13:38:33 <hyperisco> a set is the meaning we want to have, ie we want to talk about sets, but how might we represent sets? ie what is the syntax
13:39:25 <hololeap> Capri64: does my-main-file have a `main` function?
13:40:28 <Capri64> @hololeap but I just noticed it had the wrong signature... sorry to bother you, thanks!
13:40:28 <lambdabot> Unknown command, try @list
13:40:31 <monochrom> Better yet, ask for complete actual code.
13:40:48 <hyperisco> dminuoso, can you think of some possibilities?
13:41:00 <monochrom> If you trust beginner's diagnosis, you don't understand what "beginner" means.
13:42:54 <dminuoso> hyperisco: Im not quite sure I understand the question.
13:42:55 <monochrom> At the very least demand exact verbatim complete unabridged unbutchered error messages.
13:43:10 <dminuoso> Presumably, this is not a Haskell question, right?
13:43:28 <hyperisco> I don't think denotational design is that OT
13:43:47 <dminuoso> No Im just clarifying how I should respond. :)
13:44:02 <monochrom> I was in an math IRC channel full of math homework questions. We learned to insist on the exact verbatim complete unabridged original honest-to-God-given-by-teacher-pristine homework question, not the student's artistic impression.
13:44:03 <hyperisco> oh, yes, I am asking for Haskell syntax, we want to use Haskell to talk about sets
13:44:32 <monochrom> Because every time you trust a beginner you have an XY problem. Always. No exception.
13:45:12 <dminuoso> Well, there's the obvious way of just saying `data Set a = Elem e (Set a) | Nil`
13:45:37 <dminuoso> But that doesn't carry the meaning of what a set is
13:46:06 <hyperisco> the meaning of  Set a  is a set of  a
13:46:37 <dminuoso> Is this a trick question, or is `newtype Set a = Set [a]` the correct answer? :)
13:46:37 <hyperisco> we are defining the meaning by starting with the meaning and finding syntax
13:46:40 <__monty__> monochrom: I usually try answering their question then go "Are you sure this isn't an XY problem?" and give them a link. Usually that's more of a learning experience than just asking for the full code/error, which somehow goes in one ear and out the other.
13:46:47 <dminuoso> mm
13:46:53 <hyperisco> dminuoso, there is no correct answer here, there are just choices
13:47:03 <hyperisco> dminuoso, another choice might be  type Set a = a -> Bool
13:47:12 <hyperisco> dminuoso, another choice might be a tree structure like  Data.Set  uses
13:47:33 <hyperisco> dminuoso, another choice might be a hybrid of the two (which I experimented with)
13:47:35 <monochrom> An explanation of XY problem doesn't cover misguided diagnoses.
13:47:39 <dminuoso> I see, I was debating whether to go with the type Set a = a -> Bool route
13:47:55 <monochrom> Well, it does to those of us in the know.
13:47:56 <hyperisco> dminuoso, so, we have a an idea that we can represent sets as lists
13:47:58 <monochrom> But beginner.
13:48:09 <hyperisco> dminuoso, now, we know lots of things about mathematical sets, like the union of sets is a set
13:48:29 <monochrom> You're fighting egotistic Dunning-Kruger. The beginner insists "this doesn't apply to me".
13:48:58 <monochrom> You know this when they begin saying "I understand ____ BUT"
13:49:00 <hyperisco> dminuoso, so how can we define  union :: Set a -> Set a -> Set a  such that the meaning of  union a b  is the meaning of  a  union the meaning of  b  ?
13:49:14 <monochrom> after the BUT you know they don't understand _____
13:49:17 <hyperisco> dminuoso, in other words, how can we implement set union given this representation of sets?
13:49:38 <maerwald> hmm, anyone done brick multithreaded?
13:50:05 <dminuoso> Well in case of `newtype Set a = Set { a -> Bool }` we can just mappend them together through And
13:50:13 <monochrom> But if you demand actual code, and you see the only problem is their line 5 has wrong indentation, then you have a chance to burst their bubble.
13:50:21 <hyperisco> dminuoso, boolean && yes, what about for lists?
13:50:29 <hyperisco> dminuoso, I mean || :P
13:50:34 <dminuoso> concat and nub
13:50:51 <dminuoso> and I dont know how to do it with the tree representation since Im not deeply familiar with it
13:50:54 <hyperisco> maybe nub maybe not
13:51:55 <dminuoso> 22:48:38     hyperisco | dminuoso, so how can we define  union :: Set a -> Set a -> Set a  such that the meaning of  union a b  is the meaning of  a  union the meaning of  b  ?
13:51:57 <hyperisco> dminuoso, does this example help you appreciate the sort of thinking that is going on with denotational design?
13:51:59 <dminuoso> Im still kind of stuck on this one.
13:52:06 <hyperisco> okay, what about it?
13:52:24 <monochrom> But I don't argue against another approach: You play along with their wrong narrative, so that after 5 hours, even 5 days, they finally see they have been wasting time.
13:52:38 <dminuoso> Maybe there's some subtlety about the word "meaning" here. But what do you mean by `the meaning of a <union> the meaning of b`? What is the union of meaning?
13:52:50 <monochrom> On sadistic days I like that, even do that.
13:53:29 <hyperisco> the meaning of  union a b  is the (meaning of  a) union the (meaning of b)
13:53:30 <solonarv> the meaning of  a  is a set (in the mathematical sense), as is the meaning of  b  .
13:53:46 <solonarv> and their union is another set
13:53:50 <dminuoso> ohh.
13:53:59 <dminuoso> 22:45:45     hyperisco | the meaning of  Set a  is a set of  a
13:54:04 <dolio> This seems like a really odd explanation of using denotational semantics for design.
13:54:37 <dminuoso> So you're saying that the meaning of the Haskell type `Set a` is a mathematical set of a? 
13:54:58 <hyperisco> well I should have said it about values with the type  Set a
13:55:24 <hyperisco> we don't necessarily have a meaning for types here
13:55:24 <dminuoso> Right, I assumed as much
13:55:52 <hyperisco> though we could say the meaning of  Set a  is the class of sets of  a
13:56:17 <hyperisco> I am not sure what we get out of that in the mathematical domain but it is conceivable to give meanings to the types as well
13:57:10 <hyperisco> the reason we're designing this way is because this frees us up to think outside a particular language like Haskell
13:57:50 * hackage proto-lens-jsonpb 0.2.0.1 - JSON protobuf encoding for proto-lens  https://hackage.haskell.org/package/proto-lens-jsonpb-0.2.0.1 (tclem)
13:57:59 <hyperisco> a realistic issue though is when you try to notate something in a programming language you'll find there is a computational issue
13:58:06 <hyperisco> like, not computable, or not efficient
13:58:42 <hyperisco> for example, with  type Set a = [a]  how would you implement complement?
13:58:43 <dminuoso> So that sounds like "the implementation should be catered around the behavior of some mathematical object"
13:59:01 <hyperisco> yes!
13:59:12 <dminuoso> Where you'd just try and transport the mathematical properties and behaviors into Haskell
13:59:20 <dminuoso> or operations
13:59:21 <hyperisco> and then when we want to explain our program we just have to explain the meaning
13:59:28 <hyperisco> which is what we started with in the first place, so we have that ready
13:59:58 <dminuoso> In the sense of "The meaning of monoids in Haskell is just monoids in algebra"?
14:00:11 <dminuoso> Giving me a free pass in having to explain what monoid really is?
14:00:16 <dminuoso> Or *Monoid rather
14:00:22 <hyperisco> yes
14:00:30 <dolio> These don't seem like good examples.
14:00:43 <dminuoso> dolio: do you have better?
14:00:52 <hyperisco> please, share your knowledge on this dolio
14:01:14 <pounce> So I was thinking... I want to do some branch/bound search in haskell. Would it be good to use the list monad for this? for generating combinations and searching through them lazily
14:01:30 <dolio> Well, the FRP example is that displays are functions from the real numbers to pictures.
14:01:55 <dolio> And then you can discover operations that make sense on such functions.
14:02:07 <ph88^> can i make with optparse-applicative that i can do  --dummy   or   --dummy=value   ?
14:02:48 <dolio> 'Monoids mean monoids' doesn't seem like the same spirit, exactly.
14:02:52 <hyperisco> it sounds like this is all taking place in the semantics
14:03:36 <hyperisco> a significant part of the work is mulling over the semantics and reworking them, to explore what it is you mean
14:04:11 <hyperisco> so for FRP you might have started thinking about time and things that change over time
14:05:04 <jollygood2> I still have no clue what functional reactive programming is
14:05:20 <jollygood2> quick summary?
14:05:25 <hyperisco> and after some pacing you might have come up with a distinction of continuous functions over time (behaviours) and events (instants of time)
14:05:51 <hyperisco> we're still all in semantics
14:06:46 <hyperisco> but after we feel like we have the semantics fleshed out well enough that we can give formal definitions to what we mean, then we can start figuring out Haskell syntax for it (or any other language)
14:07:35 <hyperisco> the advantage is that our thoughts are not anchored to algorithms at every step
14:08:36 <hyperisco> and also, in the end, you don't just have a program and must declare "it is what it is"
14:09:03 <dolio> Like, monoids are an algebraic structure that makes as much sense to base on types as they do to base on sets.
14:09:44 <monochrom> Is this like platonism vs formalism?
14:10:07 <hyperisco> the choice of Monoid as a type class it is is not a unique choice
14:10:10 <dolio> And there are many examples of monoids. Many monoid structures on a single type even.
14:11:39 <monochrom> That reminds me of a useless theorem I just proved the other day. :)
14:14:20 <hyperisco> it is fine to say "think of  ([], concat)  as a monoid" as much as it is to say of instances of Monoid
14:14:21 <dolio> I mean, what I would expect for 'denotational design' is that you pick one example of how to implement sets, and then discover operations on sets from them.
14:14:42 <dolio> Like, you pick that sets are listings of elements. Then you discover that by appending lists you can union sets.
14:15:39 <hyperisco> you could learn things from both sides, sure, I just described the direction of knowing we want to talk about set union and then figuring out how to compute the union of sets given the representation chosen
14:15:40 <dolio> Mathematical sets are already a primitive, abstract structure defined axiomatically by the operations they're expected to have.
14:16:11 <monochrom> What is the purpose of this discussion again?
14:16:23 <hyperisco> I think it is generally the more useful way to go about it
14:16:27 <merijn> monochrom: Passing time on the internet ;)
14:16:39 <hyperisco> monochrom, "what is denotational design"
14:16:40 <monochrom> heh
14:16:53 <hyperisco> subtitled "as butchered by hyperisco"
14:17:00 <monochrom> I don't think anyone denotationally designs sets.
14:17:36 <monochrom> or anyone would care to
14:17:36 <dolio> The "they're predicates on something" definition leads to discovering a different set of operations.
14:17:53 <edwardk> hyperisco: afaict it is 'anything written by conal'
14:18:14 <monochrom> OK, maybe model theorists are doing something close.
14:18:35 <hyperisco> what is written by conal is a subset of denotational design, but we seek a definition for the whole enchilada
14:19:12 <hyiltiz> It seems Bifunctor can pretty much replace Arrow stuff (https://en.wikibooks.org/wiki/Haskell/Understanding_arrows); is it normally the case tho?
14:19:17 <hyperisco> and I am only intuiting the methodology from half a book I read on semantics, some of conal's work and talks, and my own personal experience of what has been effective
14:19:51 <dolio> hyperisco: Bifunctor only replaces people using Arrow stuff for convenient functions.
14:20:03 <dolio> Oops, wrong h person.
14:20:04 <dolio> Sorry.
14:21:03 <dolio> That is probably 90% of actual Arrow usage, though.
14:21:14 <dolio> Being generous.
14:21:50 <merijn> hyperisco: Arrow has been pretty much obsolete for years
14:21:54 <merijn> dammit
14:22:00 <merijn> same mistake as dolio
14:22:17 <merijn> dolio: The remanining usages have been obsoleted by a mix of Applicative, Category, and Profunctor ;)
14:23:01 <hyperisco> hyperisco, I feel Arrow loses the plot specifically with  arr  (figure I should do it too)
14:24:04 <hyperisco> also since both of these are fresh on the stack, conal's concat is probably a better concept for what Arrow might have been used for
14:26:02 <hyperisco> dolio, an example of learning through the syntax is  filter
14:26:20 <conal> hyperisco: have you read http://conal.net/papers/type-class-morphisms/ ? that paper was my first attempt to describe denotational design. i'd summarize by saying that DD is specifying (and often calculating) implementations via a semantic function (from representation to meaning) and requiring this semantic function to be homomorphic for (distribute over / preserve) the vocabulary defined for that representation.
14:26:38 <hyperisco> dolio, which made me realise  filter  was the intersection of two different set representations
14:27:12 <conal> Latest example: https://www.youtube.com/watch?v=wvQbpS6wBa0 (calculating a compiler).
14:27:32 <hyperisco> so then I spun off and made a new unified set representation that uses both, and then discovered I can define complement, and so a Heyting algebra
14:32:46 <hyperisco> conal, yes thanks! I should refresh myself on it too. I was trying to give a sense of it without going heavy on formalisms.
14:33:50 <conal> hyperisco: cool. then i'd say that DD is design by "precise analogy", i.e., homomorphism.
14:34:11 <conal> that recent compiler talk frames DD in this way.
14:34:12 <hyperisco> fair :)
14:34:43 <hyperisco> I tried to give an example of that in my set union example
14:35:30 <dolio> This is similar to what category theory actually gets used for in mathematics, which I wish Haskell folks knew more when they talk about category theory.
14:35:46 <monochrom> OK I think here are why your explanation inspired the wrong messages, hyperisco.
14:35:59 <hyperisco> alright, shoot
14:36:22 <dolio> Like, 'it took longer to use the definition of an adjunction to figure out the definition of this function than just thinking about it directly,' is not really representative.
14:36:46 <monochrom> Firstly if you say "the 'set' data structure" people will think much closer to what you have in mind.
14:37:04 <hyperisco> as opposed to saying "representation"?
14:37:17 <hyperisco> is  a -> Bool  a data structure?
14:37:56 <monochrom> Secondly (after I saw conal's preserve-operations), you have to put the desired operations on the foreground. The carrier "set" should be only a supporting role.
14:39:24 <conal> hyperisco: your list/set example is right on. it just needs a semantic function to make it explicit.
14:40:07 <hyperisco> I haven't done something as specific as calculating a compiler, so I guess in my mind monochrom that precision didn't need to be leading… but I imagine my appreciation will change as I learn
14:40:27 <dolio> Rather, the folks on the CT zulip are doing things like: here's a definition of the category of Petri nets. Figure out if it is a topos, so that we can talk about constructions on petri nets using set/type theoretic language.
14:40:36 <monochrom> OK, "abstract data structure" won't preclude a->Bool as an internal detail
14:41:19 <hyperisco> I haven't read that paper for two or three years so maybe now if I read it again my eyes will open
14:41:51 <hyperisco> I've just been working on the brain exercise of thinking outside the terms of a particular language, like Haskell
14:41:52 <topos> is it a me? topos?
14:41:57 <monochrom> Here is the thing. If you say "set" unqualified, people just think ZFC set, not "let's represent set".
14:42:26 <hyperisco> it isn't the easiest thing when most of your background is the syntax and operational semantics of programming languages :P
14:43:08 <dolio> topos: You knew what you were getting into. :þ
14:44:08 <conal> if you want to use lists to represent sets, then talk about the mathematical notion of set, not any kind of computable representation.
14:44:29 <hyperisco> the default mode for programmers (or at least my ilk of programmers) is to think in terms of the PLs they know… so everything must be mapped to familiarities in PLs and code libraries and operational semantics
14:44:32 <conal> hyperisco: from your remarks, i think you really do get it.
14:45:05 <hyperisco> I'm ecstatic! I'll work on my wording
14:45:25 <monochrom> OK I think I see now.
14:45:45 <conal> DD is terribly simple in itself. It's mainly the habit of operational thinking that interferes.
14:46:03 <monochrom> You wanted to say "MyRepOfSet -> ZFCSet" (or replace ZFCSet by any real/platonic set you have in minad).
14:46:12 <monochrom> s/minad/mind/  # not monad haha
14:46:18 <topos> dolio i suffer in silence
14:46:20 <conal> The most fundamental thing in a design is the semantics, which needn't at all be computable.
14:46:26 <monochrom> We ended up thinking we heard "ZFCSet -> ???"
14:46:42 <hyperisco> monochrom, as the type of my semantic function? yes
14:47:40 <hyperisco> ah okay well that's my bad… I was purposefully trying to advise starting from the perspective of meanings and working towards the syntax, but I guess that made the direction of the semantic function confusing
14:49:36 <monochrom> I can now see why we care about the direction MyRepOfSet->ZFCSet, and even why the opposite direction is basically irrelevant. But it is still a very subtle, non-obvious point.
14:49:45 <dolio> Well, that wasn't my confusion.
14:50:23 <dolio> I just think sets are a weird example, because mathematical sets are just primitive abstract things with a list of operations satisfying rules.
14:50:46 <dolio> So you can just apply those rules to your data structure. Someone's already figured out the design for you.
14:51:47 <conal> dolio: Indeed you've just described the ideal situation. Someone else (mathematicians) have already figured out the design for us.
14:52:16 <conal> Whenever the semantics itself feels novel, I'm suspicious.
14:53:20 <conal> For instance, I didn't invent functions of time or space but rather noticed their usefulness for behavior and imagery.
14:56:17 <conal> DD is largely about minimizing invention. Make one or two simple but crucial choices, and then notice the consequences.
14:59:12 <hyperisco> exciting chat, I'm headed out for tonight though. thanks!
14:59:26 <hyperisco> also I haven't seen that new talk yet conal. looks great!
14:59:32 <monochrom> Yes you need a drink. :)
14:59:51 <conal> hyperisco: take care!
15:00:52 <monochrom> "Computer science has just become a bit too technical, let's go for a drink."  -- Jay Misra
15:10:18 <Narinas> Hello!
15:12:11 <Narinas> I'd like to start in Haskell, but right now I only have an android tablet with termux. Has anyone managed to get ghc running on this kind of setup?
15:13:01 <Uniaika> Narinas: you're in luck, repl.it has a Haskell environment!
15:13:03 <Uniaika> damnit!
15:13:04 <Uniaika> :(
15:13:23 <sm[m]> wow you gotta be fast
15:15:25 <hpc> /topic Welcome to #speed-haskell
15:16:07 <Rembane> Speedskell
15:16:09 <edwardk> conal: the way i think of your denotational design idea is kind of like the idea of a walking adjunction. https://twitter.com/johncarlosbaez/status/1296131453130964999
15:17:35 <edwardk> https://twitter.com/johncarlosbaez/status/1296152889706999810 is probably the more illuminating tweet in that series
15:19:05 <hyiltiz> dolio merijn hyperisco Thx for the comments on Arrow. I'll stop reading more into them.
15:19:37 <hyiltiz> Two hy* people... Autocomplete is sad
15:19:52 <edwardk> hyiltiz: eventually they are worth back-filling in, but they aren't terribly central to anything interesting.
15:24:23 <sm[m]> Narinas: did you see that ? Uniaika> Narinas: you're in luck, repl.it has a Haskell environment!
15:25:09 <Narinas> sm[m]: Sorry, I didn't see it. Thank you very much!
15:31:09 <Uniaika> \o/
15:31:12 <Uniaika> my mission here is done
15:54:49 * hackage language-dickinson 1.3.0.0 - A language for generative literature  https://hackage.haskell.org/package/language-dickinson-1.3.0.0 (vmchale)
18:33:53 <jchia> I have a type "data Foo a b = Foo { x1 :: a, x2 :: a, y1 :: b, y2 ::b, z :: Int }". How can I have a function "(a1 -> a2) -> Foo a1 b -> Foo a2 b" and another function "(b1 -> b2) -> Foo a b1 -> Foo a b2" without manual boilerplate? Within Foo can be many fields with types a & b.
18:35:19 <jchia> If it's just "data Foo a = Foo { x1 :: a, x2 :: a, z :: Int }", I can use DeriveFunctor, but the actual record type I have has 2 parameters, not 1.
19:00:03 <jle`> Axman6: yeah, you could work with swerve (view myIso) (review myIso), but essentially you'd need an isomorphism
19:00:22 <jle`> maybe a hypothetical typeclass would be defined in terms of an isomorphism rather than with the functions directly
20:11:59 <fog67> i have been trying to find references for the implementation of "a dynamic systems approach to learning" where a maximim principle, or optimal control law from the hamilton jaccobi bellman equations is used to optimise the learning trajectory
20:12:18 <fog67> do we have tools that can be used for this in haskell?
20:12:49 <fog67> maybe something like symbolic algebra, or other approaches to maximising Hamiltonians to given reward policies 
20:14:49 <fog67> the idea follows from Amaris "information geometry of learning trajectories" and uses a forcing term to modify stochastic updates of MCMC using convergence approximation as indirect gradient observation to implement varience reduction, or bias to higher moments
20:15:40 <fog67> most of the references cite; Weinan E. A proposal on machine learning via dynamical systems
20:17:07 <fog67> i am aware that MonadRandom has means to sample from probability distributions, but there are other tools which could be useful such as computing analytic integrals 
20:17:35 <fog67> or working with group representations of polynomial equations approximating the pdf 
20:18:27 <fog67> the indirect observations of convergence use local moving averages based on higher moments to the central limit theorem at sub-infinite N
20:19:31 <fog67> i want to connect these higher moments and their rates of decay approaching the large N limit as a surrogate for direct gradient observations normally conducted via expensive backpropegation
20:19:55 <fog67> and connect these to varience reduction in higher moments of the distribution of proposed update steps
20:22:58 <fog67> i thought the approach could use some of the categorical ideas of adjunctions based on the Pontryagin maximum principle - which calls the control variable a "co-state"
20:23:25 <fog67> and probably some yonedas
20:42:28 <hyiltiz> While Haskell can definitely do it, why not Python/R/Lua/Octave, something where there are better supported libraries for those things?
21:10:45 <pagnol> Does it make sense to use an Array as a bitmap? 
21:14:12 <hyiltiz> Haven't tried myself but from reading about it, it seems quite good; also check out https://hackage.haskell.org/package/bitwise
21:15:45 <hyiltiz> https://hackage.haskell.org/package/gloss-1.9.4.1/docs/Graphics-Gloss-Data-Bitmap.html#t:BitmapData
23:26:19 * hackage vector-sized 1.4.2 - Size tagged vectors  https://hackage.haskell.org/package/vector-sized-1.4.2 (jophish)
