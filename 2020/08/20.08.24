00:03:53 <mniip> phadej, you can do that with a little bit of GHC magic
00:06:28 <mniip> % pp!x=compose_3pba unpackClosure#x(\p b a->let t=W#(indexWord32OffAddr#p 2#);s=I#(sizeofByteArray#b)`div`8-1;u=I#(sizeofArray#a);c=foldl(\z(I#i)->z++' ':show(I#(indexIntArray#b(i+#1#)))++"#")(foldl(\z(I#i)->z++' ':composei1_(indexArray#a)i pp)(if t<8 then unpackCString#(plusAddr#(plusAddr#p 16#)(indexInt32OffAddr#p-2#))else"closure_"++show t)[0..u-1])[0..s-1];in if s+u>0 then '(':c++")"else c)
00:06:29 <yahb> mniip: ; <interactive>:43:256: error:; * Variable not in scope: unpackCString# :: Addr# -> [Char]; * Perhaps you meant `BS.packCString' (imported from Data.ByteString)
00:07:09 <mniip> % import GHC.CString
00:07:09 <yahb> mniip: 
00:07:10 <mniip> % pp!x=compose_3pba unpackClosure#x(\p b a->let t=W#(indexWord32OffAddr#p 2#);s=I#(sizeofByteArray#b)`div`8-1;u=I#(sizeofArray#a);c=foldl(\z(I#i)->z++' ':show(I#(indexIntArray#b(i+#1#)))++"#")(foldl(\z(I#i)->z++' ':composei1_(indexArray#a)i pp)(if t<8 then unpackCString#(plusAddr#(plusAddr#p 16#)(indexInt32OffAddr#p-2#))else"closure_"++show t)[0..u-1])[0..s-1];in if s+u>0 then '(':c++")"else c)
00:07:11 <yahb> mniip: 
00:07:29 <mniip> % pp (Just (False, "foo"))
00:07:29 <yahb> mniip: "(base:GHC.Maybe.Just (ghc-prim:GHC.Tuple.(,) (ghc-prim:GHC.Types.False 139834470632896#) (ghc-prim:GHC.Types.: (ghc-prim:GHC.Types.C# 102#) (ghc-prim:GHC.Types.: (ghc-prim:GHC.Types.C# 111#) (ghc-prim:GHC.Types.: (ghc-prim:GHC.Types.C# 111#) (ghc-prim:GHC.Types.[] 139834470631208#) 139834460618313# 139834460618280#) 139834427796697# 139834427796664#) 139834431847593# 139834431847560#) 13983447152
00:08:39 <sshine> using Stack I'm trying to create a project with two executables in 'app/' and one library in 'src/'. when I put "module Main where ..." in those, it complains that they're not properly named after their module, and when I put "module App1 where ...", it complains that they're not properly named "Main".
00:09:08 <sshine> I think it has to do with the .hs files being in the same directory, so when building the one executable, the other executable's file is getting compiled with, and then it bugs out.
00:20:46 <redmp> sshine: sshine: here's a minimal example showing how to have mulitple executables in the same directory: https://termbin.com/dh1h
00:20:47 <boxscape> does producing bottom make a function impure?
00:21:56 <redmp> % :type error
00:21:56 <yahb> redmp: [Char] -> a
00:22:04 <sshine> boxscape, no, just not terminal.
00:22:16 <boxscape> terminal?
00:22:48 <sshine> er. I don't know.
00:22:54 <boxscape> did you mean total?
00:24:14 <mniip> boxscape, in a way
00:24:15 <sshine> I didn't, but I also don't really know the precise definition of 'pure' :)
00:24:19 <mniip> errors are an effect
00:24:22 <boxscape> hm, okay
00:24:33 <mniip> but they are treated similarly to nontermination in haskell
00:25:10 <mniip> I'd consider an error that you can't catch pure
00:25:41 <mniip> (and indeed, "error" errors can only be caught in IO)
00:25:53 <sshine> one definition is "a function where the return value is only determined by its input values". since there is no return value, that definition falls apart.
00:26:11 <boxscape> sshine one could argue that the return value is bottom
00:26:12 <mniip> right
00:26:18 <mniip> but that's not a value
00:26:57 <sshine> boxscape, it depends on how you think of bottom; another way would be an effect. but then that kind of changes what you mean by pure, I guess?
00:27:06 <redmp> % :type (try $ error "oops")
00:27:06 <yahb> redmp: Exception e => IO (Either e a)
00:27:21 <mniip> that wouldn't actually catch the error
00:27:28 <boxscape> % (try $ error "oops")
00:27:28 <yahb> boxscape: ; <interactive>:49:1: error:; * No instance for (Show (IO (Either e0 a0))) arising from a use of `print'; * In the first argument of `print', namely `it'; In a stmt of an interactive GHCi command: print it
00:27:44 <redmp> because i left the error type ambiguous
00:27:50 <mniip> that's not the problem
00:28:02 <mniip> % try @SomeException (error "oops")
00:28:02 <yahb> mniip: Left oops; CallStack (from HasCallStack):; error, called at <interactive>:50:21 in interactive:Ghci16
00:28:06 <mniip> oh huh
00:28:25 <redmp> can you view the bottom as being a value then?
00:28:29 <mniip> oh no wait
00:28:33 <mniip> % :t try
00:28:34 <yahb> mniip: Exception e => IO a -> IO (Either e a)
00:28:36 <mniip> of course
00:28:48 <mniip> I was thinking try (return (error _))
00:29:30 <mniip> when we talk about bottoms we don't usually talk about values in isolation anymore
00:29:41 <mniip> rather we talk about particular partially ordered sets
00:29:51 <mniip> ordered by "definedness"
00:30:24 <sshine> redmp, thanks for the minimal example. the trick turned out to be to remove the 'source-dirs' and instead have 'main: app/Foo.hs'.
00:31:51 <alm63> Is there a way to constrain a type family instance?
00:32:01 <alm63> ie. If I have
00:32:52 <alm63> `type family Foo t :: *`
00:33:37 <alm63> `type instance Foo [a] = Maybe a`
00:34:25 <alm63> Is it possible to write a constraint in a signature that `Foo t` must be a functor `f` applied to something?
00:34:30 <mniip> no
00:34:33 <alm63> ie. something like
00:34:56 <mniip> your best bet is an auxiliary class
00:35:03 <mniip> where Foo is an associated family
00:35:06 <alm63> `(Functor f, Foo t ~ f a) => ...`
00:35:31 <alm63> Do you have an example for such an auxiliary class?
00:35:40 <alm63> I'm having trouble picturing what it would look like
00:35:57 <mniip> class (Functor (FooF t)) => C t where { type FooF t :: * -> *; type FooX t :: * }
00:36:15 <mniip> type family Foo (t :: *) :: *) where Foo t = FooF t (FooX t)
00:40:02 <redmp> sshine: yeah, that's how i've started doing it now; source-dirs is usually only required for the library component
00:44:35 <alm63> I can't redefine `Foo` in this case
01:01:48 * hackage liquid-fixpoint 0.8.10.2 - Predicate Abstraction-based Horn-Clause/Implication Constraint Solver  https://hackage.haskell.org/package/liquid-fixpoint-0.8.10.2 (AlfredoDiNapoli)
01:02:49 * hackage liquid-base 4.14.1.0, liquidhaskell 0.8.10.2 (AlfredoDiNapoli): https://qbin.io/thy-parent-aro3
03:14:19 * hackage ktx-codec 0.0.1.1 - Khronos texture format  https://hackage.haskell.org/package/ktx-codec-0.0.1.1 (AlexanderBondarenko)
03:25:12 <tomsmeding> hyiltiz: https://paste.tomsmeding.com/ is up to date with the new stuff, and I can now also reload the html pages with a unix signal so I don't have to restart the server when only changing the html :)
04:18:20 * hackage generic-match 0.2.0.2 - First class pattern matching  https://hackage.haskell.org/package/generic-match-0.2.0.2 (sgschlesinger)
04:21:35 <kuribas> (,) w is isomorphic to Writer w, right?
04:21:51 <kuribas> like (->) a is isomorphic to Reader a
04:22:40 <boxscape> @unmtl Writer w a
04:22:40 <lambdabot> (a, w)
04:22:55 <kuribas> isn't it good design to use "Writer w" for pure business logic that can write log output?
04:23:19 * hackage dom-lt 0.2.2 - The Lengauer-Tarjan graph dominators algorithm.  https://hackage.haskell.org/package/dom-lt-0.2.2 (AndreasK)
04:23:20 <kuribas> instead of IO
04:27:46 <dminuoso> kuribas: Depends on what you mean by "log output"
04:27:53 <dminuoso> I might prefer LoggingT/MonadLogger.
04:28:26 <merijn> kuribas: Writer's performance is notoriously bad :p
04:29:47 <dminuoso> Depends on which Writer you use.
04:30:03 <dminuoso> If you default to Control.Monad.Trans.Writer.CPS it's probably not as bad?
04:30:35 <kuribas> merijn: doesn't matter for logging does it?  As long as mappend is constant time.
04:30:58 <merijn> kuribas: It does
04:31:08 <merijn> kuribas: the mappend builds up a massive thunk
04:31:11 <kuribas> so?
04:31:43 <dminuoso> merijn: There's a CPS version of it that does not.
04:31:43 <merijn> kuribas: When you have a 5 GB thunk running alongside your application performance tends to degrade :p
04:32:29 <kuribas> merijn: but you pass the log output to the logger in your app-monad, then you never get a 5 GB thunk :)
04:33:53 <merijn> Then why bother with Writer at all? Just do that immediately
04:34:34 <kuribas> because I don't want to write everything in the app monad.
04:34:38 <kuribas> especially not business logic
04:35:04 <phadej> capabilities/effects/mtl-classes/pick your way to "DI"
04:35:11 <kuribas> I want clean separation of concerns.
04:35:17 <phadej> that is
04:36:04 <phadej> using Writer is "programming against concrete implementation", against MonadWriter (or MonadLog) is programming against interface
04:36:34 <kuribas> I feel that's still to heavy compared to simply "a -> Writer MyLogData b"
04:36:46 <kuribas> or a -> (MyLogData, b)
04:36:55 <phadej> having App monad is already quite heavy
04:36:57 <phadej> :)
04:37:56 <kuribas> phadej: that's why I don't write everything in it :)
04:38:01 <dminuoso> kuribas: If you want clean separation with pluggable implementations, `MonadLogger m => A -> m B` will give you everything you want
04:38:24 <kuribas> I don't like the typeclassitis
04:38:49 <phadej> :: Free (LogF :+: r) a B
04:38:59 <phadej> s/a//
04:39:29 <phadej> these all solve the same "problem", slighly differently
04:40:27 <phadej> fwiw, Writer is *too strong* for logging, as it naturally has `listen`
04:41:08 <dminuoso> or `censor`
04:41:09 <phadej> "but I won't call listen" - "but your collaborator might!"
04:44:08 <kuribas> hmm pure logging: http://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-Writer-Lazy.html
04:44:29 <kuribas> no, this one: https://hackage.haskell.org/package/logging-effect-1.3.11/docs/Control-Monad-Log.html#t:PureLoggingT
04:44:31 <dminuoso> kuribas: Bringing merijn's original concern back. 
04:46:55 <kuribas> hmm, but it isn't pure, it has an m
04:51:13 <kuribas> phadej: newtype PureLogger w a = PureLogger (w, a) deriving (Functor, Monad, Applicative); pureLog = PureLogger tell
04:52:49 * hackage juicy-gcode 0.2.0.1 - SVG to G-Code converter  https://hackage.haskell.org/package/juicy-gcode-0.2.0.1 (dlacko)
04:53:52 <kuribas> phadej: better newtype PureLogger w a = PureLogger (DList w, a) deriving (Functor, Monad, Applicative); pureLog = PureLogger . tell . DList.singleton
04:54:26 <phadej> not much
04:54:50 <phadej> but you made your mind, so I won't comment on that :)
05:00:34 <kuribas> my idea is to have a separation of concerns, meaning functions should be as independent as possible, not tied to an app monad.  They also do just one thing, and do it well.  Adding lots of constraints defeats that purpose.  
05:01:07 <maerwald> that sounds like *functional* programming...
05:01:17 <maerwald> it isn't very popular these days :)
05:04:18 <phadej> weHaven'tYetMentionedPassingImplementationAsArgument :: Logger m -> Input -> m Output
05:04:35 <phadej> ... which is IMHO still better than using Writer
05:07:34 <maerwald> phadej: that can also get out of hand sometimes (especially since closures swallow arguments you can't retrieve anymore)
05:08:04 <maerwald> (which may be on purpose, but refactoring isn't fun)
05:08:33 <kuribas> maerwald: I like it
05:10:01 <kuribas> maerwald: I like taking a mess and cleaning it up in well structured, easy to understand code.
05:10:54 <kuribas> maerwald: I may have missed your context though
05:11:26 <merijn> refactoring is great fun
05:11:36 <merijn> Writing new code sucks :p
05:12:42 <mirrorbird> maybe perl is your thing
05:18:17 <maerwald> no one refactors perl code
05:26:23 <kuribas> merijn: I like designing new code, solving the hard parts, making architecture, but not the coding itself
05:26:54 <kuribas> at least not the plumbing part of code
05:27:33 <merijn> kuribas: Word
05:27:52 <kuribas> Word?
05:28:30 <maerwald> Word64
05:29:03 <kuribas> Word2020
05:29:20 <merijn> kuribas: https://www.urbandictionary.com/define.php?term=Word see meanings 1 and 2 :p
05:29:47 <kuribas> ah :)
05:30:27 <maerwald> also, what's plumbing... I thougt here we COMPOSE, heh
05:31:59 <maerwald> (everything breaks down at one or another level of abstraction)
05:32:59 <kuribas> maerwald: true, because of composition, you have less plumbing
05:33:03 <kuribas> that's what I like about haskell
05:34:13 <maerwald> but libraries compose less well in haskell :)
05:36:38 <merijn> Some libraries do, some don't, it all depends
05:38:11 <frdg> How do I deal with parsing json that has capitalized fields with aeson? This causes a syntax error in Haskell. I usually just define a type and use the decode function. Here is the type I need: https://dpaste.org/S9AU
05:39:35 <maerwald> merijn: there's a general trend though
05:39:58 <merijn> maerwald: In some corners of the ecosystem, sure
05:40:08 <maerwald> merijn: in most
05:40:13 <merijn> Like, don't expect composability if you pick Yesod :p
05:41:04 <maerwald> e.g. library A picks a streaming lib S and exposes the type in its API... so. Now you're locked in
05:41:19 <maerwald> (which happens to be the case for amazonka)
05:41:37 <maerwald> and have to write plumbing code if you want to use it with something else
05:42:02 <maerwald> part of that is expressive types
05:42:24 <maerwald> if you only have loose types (e.g. lazy ByteStrint), then you don't have those problems
05:42:30 <maerwald> but then you have loose types
05:42:35 <maerwald> you can't have both
05:44:22 <lortabac> frdg: the default parseJSON implementation is 'genericParseJSON defaultOptions', you can override it with different options (for example lowercasing the first letter of each field)
05:45:01 <frdg> lortabac: alright thank you
05:45:11 <lortabac> frdg: or alternatively, write your own decoder instead of using the generic one
05:47:41 <kuribas> frdg: https://hackage.haskell.org/package/aeson-1.5.3.0/docs/Data-Aeson.html#v:fieldLabelModifier
06:00:01 <frdg> kuribas: oh I see how this works now
06:00:06 <Unhammer> what's a simple (few dependencies) way of just writing a large file to stdout? (that I can use as 'putFile :: FilePath -> IO()') that avoids deadlocking due to lazy io or pipe buffers or whatnot
06:00:30 <Unhammer> and doesn't require reading the whole file in memory
06:01:29 <maerwald> Unhammer: https://hackage.haskell.org/package/hpath-directory-0.14.0/docs/System-Posix-RawFilePath-Directory.html#v:readFileStream
06:01:50 <maerwald> and then just compos that with a print function, which will operate on the chunks
06:02:06 <maerwald> but then you have to look a bit into streamly
06:02:08 <kuribas> Unhammer: deadlocking due to lazy IO?
06:02:17 <kuribas> Unhammer: what's wrong with lazy IO
06:02:34 <phadej> "what's wrong with lazy IO" "it's not even wrong"
06:02:36 <Uniaika> kuribas: everything
06:02:55 <Unhammer> thanks maerwald, will check out streamly :)
06:03:33 <maerwald> don't go into a rabbit hole... there might be easier ways, but I'd argue it's a safe way, because it's actual streaming
06:05:21 <Unhammer> well, it only took five seconds to install so that checks my boxes =P
06:06:15 <maerwald> you must have a good rig then
06:06:23 <maerwald> it's ~75 modules or so
06:06:41 <maerwald> (streamly)
06:08:07 <kuribas> Uniaika: just writing a file to standard output is a good use of lazy IO
06:08:22 <kuribas> unless you are concurrently modifying the file handle or so...
06:08:40 <kuribas> but then you'll be in trouble even without lazy IO
06:11:10 <Uniaika> kuribas: this is has to be the only usage of Lazy IO that I find reasonable
06:11:11 <Uniaika> :P
06:11:39 <Unhammer> maerwald oh, haha probably because my ~/.stack is pretty full from other projects already :-S
06:11:57 <Uniaika> because if you're trying to write a file that you previously opened, the file handle might not be closed yet when the write operation happens :>
06:12:53 <kuribas> Unhammer: what's wrong with: hGetContents filename >>= putStr ?
06:13:30 <dminuoso> phadej: Can you explain why lazy IO is not even wrong?
06:14:53 <Unhammer> kuribas,  I don't know :-) that's kind of why I asked. I've been bitten by lazy io gobbling my memory or doing things out of order before, but if that's safe and will finish before I try closing handles etc then I'd prefer to just do that
06:15:10 <dminuoso> I get the usual criticsm about lazy IO, but the "not even wrong" remark I find curious.
06:16:31 <kuribas> Unhammer: to be safe you can do: withFile filename iomode (hGetContents >=> putStr) 
06:17:07 <kuribas> Unhammer: that will make sure the handle to the file will be closed.
06:18:00 <kuribas> even better, use: https://hackage.haskell.org/package/text-1.2.4.0/docs/Data-Text-IO.html
06:18:07 <dminuoso> kuribas: lazy IO seems good in only the most trivial cases. You don't have guaranteed constant memory usage with it, and because resource cleanup is managed by the garbage collector, you have additional pitfalls.
06:18:18 <dminuoso> Furthermore, you cant control chunk sizes
06:18:21 <kuribas> that's true
06:18:55 <Unhammer> kuribas,  what does T.IO help with in this case?
06:19:12 <Unhammer> (the case of simply writing a file out to terminal, not actually parsing anything)
06:19:23 <kuribas> Unhammer: String is rather inefficient, as it boxes each character.  Text is more efficient.
06:19:53 <dminuoso> Unhammer: Btw, you can also look at other solutions like `conduit` or `streaming`. There's quite a few libraries out there with varying degrees of expressiveness, tooling and pre-existing compatibility with other libraries.
06:19:59 <dminuoso> (as opposed to streamly)
06:21:02 <dminuoso> streamly might be a bit of a nuclear option, if `streaming` or `conduit` suffices.
06:33:05 <phadej> dminuoso: it's just too fragile mechanism. `IO Lazy.ByteString` may or may not hold resourses, there is no hints.
06:33:36 <dminuoso> phadej: Oh I see. Thought you meant something else.
06:46:57 <carter> Anyone watching icfp keynote today?
06:47:55 <nek0> Hi folks, is there a way to express a Tuple in a single type variable and not as a tuple of type variables?
06:47:56 <merijn> Presumably ;)
06:48:14 <merijn> nek0: Insufficient context
06:48:21 <merijn> Also, "probably not"
06:49:01 <boxscape> my first instinct would have been "probably yes", but I guess that speaks to how there is insufficient context
06:49:08 <dminuoso> nek0: Sure there is. newtype Pair a = Pair a a
06:49:11 <nek0> merijn: I have a function (fromDatabase :: a -> b), where a is a Tuple
06:49:37 <nek0> or I want a to be a tuple
06:49:59 <boxscape> does fromDatabase use the fact that `a` is a tuple?
06:50:18 <nek0> yes
06:50:43 <nek0> fromDatabase (id_, name, c1, c2, c3, c4, c5, c6, c7, c8, c9, c10) = ...
06:51:25 <boxscape> then it would have to be something like (a, ....) -> b, though consider using a custom type instead of a tuple with 12 elements
06:51:29 <ski> (s/newtype/data/)
06:52:01 <carter> merijn: ;(
06:54:16 <nek0> to put a bit more context into it: I am using opaleye to communicate with my database and it provides me with thos tuples as data from the database. I wanted to construct a typeclass to convert these tuples to my custom datatypes.
06:55:31 <boxscape> so fromDatabase would be a method of your typeclass?
06:55:53 <nek0> yes
06:56:55 <boxscape> in that case you *could* represent it with a single variable because the actual type of fromDatabase would be "YourTypeclass a => a -> b" or something similar, though it seems like you could run into trouble with this if two tables require the same type
06:57:02 <boxscape> but I haven't used opaleye
06:57:58 <dminuoso> ski: Oh. In that case `newtype Pair a = Pair (a, a)`. Presumably this could behave more nicely than a data type.
06:58:14 <dminuoso> not sure how much specialization tuples receive
06:58:54 <boxscape> (or actually `YourTypeclass a b => a -> b`, probably? In which case, the same type for two tables should be fine, but you might need more type annotations than would be ideal)
06:59:56 <boxscape> or, well, as long as you have a functional dependency  b -> a I think that shouldn't be a problem either
07:00:35 <nek0> I tried to make it liek this: FromDatabase a where fromDatabase :: b -> a
07:00:50 <nek0> but that threw me errors
07:01:15 <boxscape> I think it should be `class FromDatabase a b | a -> b where fromDatabase :: b -> a`
07:01:46 <nek0> so a multi param typeclass
07:01:47 * dminuoso has started to replace his occurences of fundeps with tyfams
07:01:58 * dminuoso has not regretted it
07:02:01 <boxscape> what are the advantages dminuoso?
07:02:36 <dminuoso> boxscape: Oh you dont need to come up with a constraint explicitly just to get the mapped type.
07:02:45 <dminuoso> You can just say `Foo a` assuming `a` is in scope somehow
07:02:58 <boxscape> okay
07:03:50 <dminuoso> Say you're writing something like `f (x :: a) = ... (t :: Foo a)` and it just works
07:04:25 <boxscape> so nek0, either what I wrote above, or `class FromDatabase a where type Tuple; fromDatabase :: a -> Tuple`, if you follow dminuoso's convention, I believe
07:04:43 <nek0> Thanks so far. I'll go on tinkering.
07:05:21 <boxscape> (er, fromDatabase :: Tuple -> a, rather)
07:05:49 <nek0> it't Tuple a :: * afair
07:07:10 <boxscape> I'm not entirely sure what you mean, though to be clear, when I wrote "Tuple", I was using it as a new name for the associated type, not referring to an existing type
07:07:23 <dminuoso>  class FromDatabase a where type Into a :: *; fromDatabase :: a -> Into a;
07:07:25 <dminuoso> % class FromDatabase a where type Into a :: *; fromDatabase :: a -> Into a;
07:07:25 <yahb> dminuoso: 
07:07:32 <boxscape> oh wait
07:07:51 <boxscape> that makes sense
07:14:12 <boxscape> or well, it makes sense that the type family needs a parameter
07:14:56 <boxscape> but I do think it makes more sense to parameterize the class by the output type rather than the input type, dminuoso, since the input type could be the same for two different tables, I think
07:15:22 <dminuoso> boxscape: Sure. Or you make the tyfam injective
07:15:26 <dminuoso> Depends on what your goal is
07:15:31 <boxscape> right, that's fair
07:19:19 * hackage morley 1.6.0 - Developer tools for the Michelson Language  https://hackage.haskell.org/package/morley-1.6.0 (gromak)
07:20:20 * hackage indigo 0.2.0, lorentz 0.6.0 (gromak): https://qbin.io/bar-pp-g2ig
07:39:13 <Orbstheorem> How can I compose MonadReaders? I have two transformer stacks that include ReaderT Foo and ReaderT Bar. However, I'm unable to stack them because of the functionnal dependency :(
07:40:15 <dminuoso> Orbstheorem: Write some hoist function
07:40:36 <merijn> Orbstheorem: "Don't do that, then" :)
07:40:46 <dminuoso> Alternatively, you can switch from MonadReader to implicit params.
07:41:50 <Orbstheorem> merijn: One is coming from my own RPCT transformer stack and the other from Persistence's `ReaderT SqlBackend`. I don't see much choice
07:42:01 * Orbstheorem checks what hoisting is
07:42:16 <merijn> Orbstheorem: Use a custom newtype for your application type
07:43:35 <merijn> Orbstheorem: I would argue that having one of the mtl typeclasses as your "external" API is always a design mistake (for exactly this reason)
07:44:01 <Orbstheorem> <use custom newtype> And not derive a MonadReader, but use another function to unwrap instead?
07:44:24 <merijn> Orbstheorem: Right, or even a custom "MonadApplicationLogic" typeclass exposing that
07:44:54 <Orbstheorem> I don't like the idea of having a “centralized” class :( I like each component having their own life.
07:45:04 <merijn> Orbstheorem: I didn't say a *single* class
07:45:19 <Orbstheorem> Right
07:45:35 <merijn> Orbstheorem: I have several classes MonadSql, MonadInput, etc. each dealing with some application specific aspect
07:45:51 <merijn> Orbstheorem: The core of each is just a newtype over some existing transformers
07:46:22 <merijn> Orbstheorem: Having the typeclass lets you use the application aspect in multiple contexts
07:47:03 <merijn> Orbstheorem: See for example: https://github.com/merijn/Belewitte/blob/master/benchmark-analysis/src/Core.hs#L107-L149
07:47:59 <merijn> Orbstheorem: And relatedly https://github.com/merijn/Belewitte/blob/master/benchmark-analysis/src/InteractiveInput.hs#L60-L73
08:00:49 * hackage dobutokO-poetry 0.16.0.0 - Helps to order the 7 or less Ukrainian words to obtain somewhat suitable for poetry or music text  https://hackage.haskell.org/package/dobutokO-poetry-0.16.0.0 (OleksandrZhabenko)
08:02:36 <kindaro> Is there a library for fixed size sets or unordered arrays? I want to have an un-ordered tuple of numbers.
08:03:29 <kindaro> So for example that ⟨1; 2⟩ ≡ ⟨2; 1⟩ is one value of such a type.
08:03:53 <dminuoso> kindaro: Check out Data.Set from `containers`
08:04:03 <dminuoso> (And equivalently IntSet)
08:04:39 <merijn> Those aren't fixed size, though :p
08:04:40 <kindaro> dminuoso, the problem is that it must have exactly 2 elements.
08:04:58 <dminuoso> ah
08:04:58 <merijn> kindaro: Seems easily solved with a newtype?
08:05:34 <merijn> kindaro: Context? What do you need them for?
08:05:39 <dminuoso> kindaro: Do you only need length 2?
08:05:42 <dminuoso> Or various lengths
08:07:25 <kindaro> dminuoso, only 2 so far.
08:07:33 <merijn> I wonder if a pattern synonym + smart constructor could solve this
08:07:47 <merijn> Have the pattern synonym project to a consist order each time
08:07:50 <kindaro> merijn, what sort of pattern do you have in mind?
08:07:54 <merijn> But whether that's useful depends on the usage
08:09:26 <kindaro> I think the right way to call the thing is _«interval»_.
08:09:42 <dminuoso> kindaro: If its forseerable that it will remain at two, Id probably create `data UnorderedPair a = UnorderedPair a a` with a custom Eq instance.
08:09:48 <merijn> kindaro: Wait, do you actually want intervals?
08:10:10 <kindaro> merijn, the difference between an interval and an un-ordered tuple eludes me!
08:10:26 <merijn> kindaro: There are libaries with actual interval types and querying
08:10:28 <tomsmeding> kindaro: an un-ordered tuple does not necessarily contain numbers :)
08:11:12 <merijn> kindaro: And even map/set types for those
08:11:43 <dolio> The notation for intervals isn't even unordered.
08:11:46 <merijn> kindaro: So depending on how you plan to use those intervals, you might be reinventing the wheel :)
08:12:55 <dolio> And it is just notation, the actual meaning is far different than a pair in most cases.
08:22:14 <sim590> Data.Text.length gives the number of characters, but what about the number of bytes (for multi byte characters)? Am I forced to convert to Bytestring to know that?
08:23:08 <merijn> sim590: Yes, no, maybe
08:23:23 <merijn> Also, you're wrong and it doesn't give length in characters
08:23:37 <merijn> The real answer is "oh god, the horrors"
08:24:13 <sim590> Hmmmmmmm. :(
08:24:13 <merijn> sim590: Anyway, Text is *unicode*, there is no such thing as a "multi-byte character" in unicode
08:24:39 <merijn> So that immediately rules out any notion of "how many bytes is a unicode string?" since it doesn't have an answer
08:25:05 <merijn> A *specific encoding* of a unicode string has a fixed number of bytes, but that number depends on, well, the encoding
08:26:19 <merijn> So it depends on why you wanna know
08:26:19 <sim590> "UTF-8 is capable of encoding all 1,112,064[nb 1] valid character code points in Unicode using one to four one-byte (8-bit) code units. " from Wikipedia. When I read "one to four one-byte code units", I read multi-byte characters.
08:26:41 <merijn> sim590: UTF-8 is an encoding of unicode codepoints as bytes, yes.
08:26:50 <dolio> Text isn't represented in UTF-8 internally.
08:27:04 <merijn> sim590: The number of bytes is *not* an inherent property of unicode
08:27:27 <merijn> sim590: unicode text can be encoded as utf-8, utf-16, and utf-32 and the number of bytes will differ for all of those
08:27:46 <merijn> You can even encode unicode to some funky weird other encodings and get yet again different byte sizes
08:28:47 <merijn> sim590: The fact that utf-8 *specifically* has a byte size for unicode codepoints is true. But Text is an API for working with unicode codepoints (and not encodings of it)
08:28:50 <sim590> I'm having this issue here: https://i.imgur.com/EC2ZL2o.png where some characters are inverted. I think that it is due to me writing on part of some multi-byte characters.
08:31:09 <sim590> I'M writing with NCurses on the screen. It gives me the number of bytes usable on the screen (terminal). I thought that when I'd compare that to the output of Data.Text.length, I did not get the actual good comparison since some of the characters I'm manipulating are more than one byte. Isn't it right? 
08:32:30 <merijn> sim590: Is this macos by any chance?
08:32:41 <sim590> Nope. Linux
08:32:45 <sim590> Why?
08:33:12 <merijn> sim590: This is almost certainly not related to bytes
08:33:24 <tomsmeding> sim590: ncurses gives you the number of single-width characters, not the number of bytes, right?
08:33:29 <merijn> sim590: What this is related to is probably "how wide is this character"
08:33:32 <tomsmeding> and also the width of a particular unicode character varies by terminal :)
08:33:44 <merijn> tomsmeding: No, ncurses is aware of multi-cell characters
08:33:45 <tomsmeding> because not all terminals know all wide unicode characters
08:33:47 <boxscape> No idea if this is an issue, but I could imagine that you're running into trouble with combining characters
08:33:59 <sim590> tomsmeding: yeah, that's what I'm thinking.
08:34:10 <merijn> But the database specifying multi-cell character widths isn't always right
08:34:23 <merijn> Notably I know several instances where the macOS database is broken
08:34:24 <sim590> merijn: i sn't it the same thing in practice?
08:34:47 <merijn> sim590: No, in fact it's almost never the same thing
08:34:49 <sim590> number of bytes vs width of the characters.
08:35:05 <merijn> Most characters that are multi-byte (like Chinese/Japanese) are not multi-cell
08:35:26 <tomsmeding> well, most CJK characters _are_ multi-cell, right?
08:35:30 <tomsmeding> but certainly not all two bytes
08:35:58 <merijn> sim590: In all likelihood your locale database and/or wcwidth implementation on your system is broken
08:36:02 <sim590> Here is the code that I'm thinking is causing the issue: https://github.com/sim590/emo/commit/320b8cf191a73675707ede6ede9f775130c42b53. The function writeChoices. It's that I'm positionning the cursor manually based on a computation of width of Text that I did.
08:36:17 <merijn> sim590: wcwidth is how ncurses determines the width of stuff it renders on screen
08:36:50 <tomsmeding> right so isn't this a question of "how many cells does this string take on my terminal"?
08:36:55 <tomsmeding> which is indeed wcwidth
08:37:47 <sim590> So, I'd have to use the function wcwidth for getting the number of "cells" right?
08:38:13 <tomsmeding> wcwidth is a libc function for determining the number of cells in a single unicode codepoint, I think
08:38:18 <merijn> Well, I'd probably try and find a more direct haskell way of computing wcwidth of Text
08:38:22 <merijn> tomsmeding: Right
08:38:30 <dolio> Every character is multi-byte in UTF-16.
08:38:35 <merijn> So using it on entire text is gonna be a pain
08:38:43 <tomsmeding> emphasis on codepoint, so watch out for combining things :p
08:39:02 <merijn> wcswidth does an entire string in one go
08:39:04 <tomsmeding> merijn: well in C there is wcswidth for a string
08:39:14 <merijn> tomsmeding: jinx ;)
08:39:18 <tomsmeding> (:
08:39:53 <merijn> Of course, then you still need a correct way of calling wcswidth on a Text, which most likely would involve using an encoding to ByteString
08:40:38 <merijn> sim590: Are you using ncurses directly?
08:40:53 <sim590> Yes. Well, I'm using the NCurses haskell library.
08:41:23 <merijn> ah...
08:41:38 <merijn> I wouldn't have, but that's not very helpful I suppose
08:41:49 <sim590> https://hackage.haskell.org/package/ncurses-0.2.16/docs/UI-NCurses.html
08:41:53 <merijn> ncurses is a notoriously shitty API in C and the haskell bindings are not much better
08:42:17 <merijn> vty does, indeed, have a function for computing the length of Text (afaict)
08:42:32 <merijn> And I would probably recommend using vty and/or vty-ui/brick anyway
08:43:09 <merijn> but that might be too much work to port
08:43:32 <sim590> But I will have to transform to String it seems. https://hackage.haskell.org/package/vty-5.30/docs/Graphics-Text-Width.html#v:wcswidth.
08:43:55 <merijn> sim590: Right below is one for Text :p
08:43:55 <dmwit> sim590: Have you considered using brick instead?
08:44:04 <sim590> ohhh :D
08:44:13 <sim590> dmwit: No, but I'm all ears.
08:44:23 <dmwit> It's got a pretty nice API. And they've done a lot of work to deal with terminal character widths, even on systems with broken tinfo (!).
08:44:31 <merijn> sim590: vty is basically "less sucky, native haskell alternative to ncurses"
08:44:41 <merijn> sim590: brick is a higher level UI library on top of vty
08:44:59 <merijn> sim590: It already implements lots of high level terminal "widgets" you can use
08:45:06 <merijn> (like buttons, text boxes, etc.)
08:45:12 <sim590> Oh, so instead of using ncurses? Well.. It would imply a big rewrite of pretty much 95% of the code heh.
08:45:25 <merijn> sim590: Hence why I said it might be too much work :)
08:45:33 <sim590> Yeah :D
08:45:47 <sim590> But I didn't know about brick and vty. That's good to know.
08:46:05 <merijn> sim590: But you should probably give brick a look anyway
08:46:18 <sim590> I guess the simple fix is to use wctwidth.
08:46:27 <merijn> sim590: Because you might decide that rewriting it now will make all your future work easier too ;)
08:47:06 <dmwit> https://github.com/jtdaugherty/vty/issues/175 has a (very long!) discussion about this exact problem
08:47:44 <sim590> merijn: Yeah, but it's a simple emoji menu. This whole project is a pretext for playing around with NCurses (I didn't know about brick/vty), Lens and other stuff.  ;)
08:48:21 <sim590> dmwit: thanks. I'll check that out
08:49:01 <dmwit> Anyway. The short version is that brick offers widgets for showing Text that transparently handles all of this nonsense for you.
08:50:09 <dmwit> If you just want a way to throw a bunch of Text objects up on screen, and have them line up, you can just wrap all your Text's in a widget with a map, and hcat/vcat to line them up next to each other or above each other, and you're off to the races.
08:50:17 <sim590> That would have been better starting with this. That's true. May be I'll port it to brick in the future.
08:50:19 <dmwit> So, so pleasant compared to manually computing positioning information.
08:50:49 <sim590> yeah :D
08:51:40 <sim590> I just had this idea that NCurses was still standard for writing terminal applications, but I guess that's not true :p
08:54:58 <tomsmeding> in the C world :)
09:02:04 <molossus_spondee> absurd :: Void -> a
09:02:05 <molossus_spondee> absurd x = case x of {}
09:02:21 <molossus_spondee> Haskell has precisely one continuation y/n?
09:02:44 <molossus_spondee> aside from bottom, undefined and error
09:02:49 * hackage log-elasticsearch 0.11.0.0 - Structured logging solution (Elasticsearch back end)  https://hackage.haskell.org/package/log-elasticsearch-0.11.0.0 (arybczak)
09:08:31 <monochrom> False dichotomy. Please add this 3rd choice: The question is moot.
09:39:31 <dolio> Are you sure the third choice isn't, "huh?"
09:48:56 <Uniaika> ski & monochrom, may I ask one of you a favour? I need a self-contained example usage of showsPrec for https://gitlab.haskell.org/ghc/ghc/-/merge_requests/3909
09:49:06 <monochrom> "huh?" is better, yeah.
09:49:33 <Uniaika> (your names will be written in marble and praised until the end of times)
09:49:35 <Uniaika> (of course)
09:49:40 <monochrom> haha
09:50:14 <maerwald> I prefer Menhir
09:50:33 <Uniaika> ah, a celt of culture
09:50:41 <Uniaika> fair enough, maerwald enters the ring!
09:51:05 <dolio> The Show docs already have example code for showsPrec.
09:52:43 <monochrom> Yeah.
09:52:59 <Uniaika> dolio: you are right, but it does not shows different outputs with different values of 'd'
09:53:16 <dolio> It does use different values of d.
09:53:40 <monochrom> But if you want a bigger example (I have two infix data constructors in mind), I can still do it.
09:53:43 <Uniaika> … are we talking about the same thing? I'm reading the instance right under the sentence "the derived instance of Show is equivalent to"
09:53:54 <Uniaika> monochrom: that would be fantastic
09:54:12 <monochrom> No, there is a "data Tree a =  Leaf a  |  Tree a :^: Tree a" example
09:54:16 <dolio> Yes. The first case uses `app_prec = 10` and the second case uses `up_prec = 5`.
09:54:59 <Uniaika> bloody hell my eyes betrayed me
09:55:04 <Uniaika> **again.**
09:55:15 <Uniaika> thank your for the working eyeballs dolio 
09:55:27 <Uniaika> (I might need those later, how much do you take? :P)
09:58:16 <dolio> I already mentioned this when people were last talking about this here.
10:00:42 <Uniaika> and I most certainly missed it
10:04:48 <monochrom> @where paste
10:04:48 <lambdabot> Help us help you: at https://hastebin.com please paste full code, input, and output.
10:06:58 <monochrom> https://hastebin.com/oniwuvimef.rb
10:07:55 <monochrom> Actually, may need...
10:07:58 <monochrom> Uniaika: https://hastebin.com/oniwuvimef.rb
10:08:37 <dmwit> molossus_spondee: I'm confused. Your code snippet doesn't appear to be related to continuations to me, at least in an obvious way. It's also not nearly all of Haskell, so using it to support a claim like "Haskell has restriction X" seems weird. Can you say more clearly what you're asking?
10:09:40 <molossus_spondee> A value is () -> a, dually a continuation is a -> Void
10:09:59 <molossus_spondee> Many languages are said not to feature continuations
10:10:17 <molossus_spondee> But most should contain the trivial continuation
10:10:25 <molossus_spondee> Void -> Void
10:10:47 <molossus_spondee> Which is necessary for handling the empty case Void + a -> a
10:10:50 <merijn> molossus_spondee: I think you have quite a lot of unstated assumptions in those comments
10:10:55 <tomsmeding> a continuation is a function that cannot be invoked?
10:10:59 <monochrom> I say crackpot.
10:11:09 <merijn> Several of which are not nearly as universal as you seem to think
10:13:44 <molossus_spondee> Ok so say like in Java
10:13:55 <molossus_spondee> You can throw an exception in any context
10:14:10 <molossus_spondee> A function that only throws an exception can return any result
10:14:51 <Uniaika> monochrom: <3
10:14:54 <molossus_spondee> interface DoesNotReturn { <A> A doStuff(); }
10:15:33 <molossus_spondee> But most programming languages have the trivial identity case
10:16:14 <molossus_spondee> So it's technically wrong to say Haskell lacks pure continuations. It just has only the trivial one (aside from the impure error and such,)
10:16:40 <merijn> molossus_spondee: Define continuation
10:16:41 <dolio> Continuations aren't functions `a -> Void`.
10:17:53 <molossus_spondee> That is literally the signature of callCC
10:17:56 <molossus_spondee> callCC :: ((a -> m b) -> m a) -> m a 
10:18:07 <molossus_spondee> Just replace b with Void
10:18:21 <molossus_spondee> Then callCC gives you a -> m Void
10:18:36 <merijn> That's now how this works, that's not how any of this works.jpg
10:21:07 <tomsmeding> the fact that 'id :: a -> a' does not mean that the identity function is a function of type Int -> Int (just replace a with Int) -- 'a' can be _instantiated_ with Int, producing a function Int -> Int, but 'id' is certainly more general than that
10:21:56 <tomsmeding> similarly, supposing a continuation always has type a -> m b, that does not mean that all continuations are a -> Void; indeed, they could also be a -> m ComplexType :)
10:22:03 <dolio> Well, that isn't even the logic in play.
10:22:20 <tomsmeding> or am I joining the rambling club now
10:22:24 <dolio> There's an additional step of: since id :: Int -> Int is a valid instantiation, all Int -> Int functions are identity functions.
10:23:29 <tomsmeding> the 'absurd' function given has type Void -> a, not a -> Void, so I do not see how molossus_spondee implied that absurd _is_ a continuation by virtue of its type
10:23:37 <maerwald> Is there a good haskell IDE for android/tablet?
10:24:11 <tomsmeding> (also, is there not the empty functor where 'm Void' is not necessarily isomorphic to Void?)
10:24:19 <monochrom> I think we're still struggle on PC :)
10:24:26 <monochrom> s/struggle/struggling/
10:24:47 <maerwald> sometimes, good things come first on android
10:24:48 <glguy> There's a lot going on now; What's the actual question?
10:24:49 * hackage dobutokO-poetry 0.16.1.0 - Helps to order the 7 or less Ukrainian words to obtain somewhat suitable for poetry or music text  https://hackage.haskell.org/package/dobutokO-poetry-0.16.1.0 (OleksandrZhabenko)
10:25:38 <maerwald> Was just thinking of at least having a repl with optionally some libraries to tinker with while reading a haskell book.
10:25:53 <tomsmeding> ssh to a server where you install ghc?
10:25:59 <monochrom> ghci and please go back to cabal v1 :)
10:26:41 <maerwald> tomsmeding: I don't think I'll ever put any of my server passwords into a phone/tablet :)
10:26:52 <monochrom> I may still once again recommend emacs and haskell-mode.
10:27:09 <tomsmeding> maerwald: who said of a non-nobody user
10:28:06 <monochrom> Is this for your niece, nephew, something? :)
10:28:46 <maerwald> "a repl ... to tinker with while reading a haskell book"
10:29:22 <maerwald> I know there are some repl websites, but their mobile experience has been terrible so far
10:29:44 <monochrom> Is repl.it terrible on phone?
10:29:59 <monochrom> (I haven't tried, really don't know.)
10:31:00 <ClaudiusMaximus> i think you can install ghc(i) in Debian on UserLAnd from FDroid on Android...
10:31:56 <monochrom> I now realize "ghci" is easier said than done. Sorry.
10:32:19 <monochrom> I wrongly had "ARM and you have linux" in mind.
10:33:49 <maerwald> monochrom: I broke it on my pc in under 30s https://files.hasufell.de/jule/repl.it.png
10:33:50 <monochrom> repl.it should be OK on a tablet.
10:34:38 <monochrom> Well yeah, I put very little weight on that.
10:35:34 <monochrom> Because in a normal workflow of following a haskell book and doing exercises, you don't do that. Not even remotely 10%-close.
10:36:51 <monochrom> Show me "I'm doing Hutton's Chapter 5 exercises and a crash happens during exercise 2" and I will respect that.
10:37:11 <maerwald> I don't even know what I did
10:37:21 <maerwald> I just clicked start and it all crashed
10:37:43 <monochrom> Err, then sorry!
10:37:53 <monochrom> Also I misread "30s" as "30min".
10:37:59 <monochrom> Terribly sorry!
10:38:25 <monochrom> Perhaps repl.it is just having a bad day.  It has been working fine previously.
10:38:36 <maerwald> Also, sometimes the "start" button leads to 404, sometimes to a crash
10:38:53 <monochrom> Perhaps another javascript retract-code-from-public-library fiasco has happened. :)
10:40:10 <maerwald> Maybe there was so much feature pressure that their JS devs started making "take shortcut" the default workflow and now everything works half of the time
10:43:12 <monochrom> I have a perverted thought. Is it OK to distort your question to "explore haskell but I mean explore the generated asm code"?
10:43:19 <monochrom> Because https://haskell.godbolt.org/ :)
10:43:38 <maerwald> Now I tried on phone and when I enter `1 + 1` and press enter, then it expands to `1 + 1 +` and spits a parse error
10:44:23 <monochrom> I get 2 but it's pretty slow.
10:45:06 <monochrom> I can't refute "works half of the time".
10:45:21 <maerwald> well, you got 2, so there is hope
10:45:25 <monochrom> I think I am the working half of the time, you are the breaking half of the time. :)
10:45:27 <maerwald> imagine it printed 3
10:46:00 <monochrom> I have this gift of fixing things just by presence.
10:46:17 <maerwald> I break things by presence
10:46:58 <maerwald> I should switch to QA
10:47:05 <monochrom> My gift of breaking things is in finding counterexamples to mathematical statements that look true but are false.
10:47:51 <merijn> monochrom: I find counterexamples to programming assumptions by naively trying to use existing software :p
10:49:53 <monochrom> I can extend my breaking gift to that, if somone (me or someone else) first comes up with a detailed specification of the software, so that I turn the scenerio into a mathematical statement.
10:50:51 <monochrom> So for example I have great talent in being an author and judge in programming contests --- those judged by auto-testing.
10:53:55 <merijn> monochrom: Oh, I meant that I do that without even trying to
10:54:16 <merijn> monochrom: I've broken so many, even big, software projects without effort I call myself the walking edge case generator
10:54:20 <maerwald> but repl.it has cabal support
10:54:22 <maerwald> hmm
10:54:26 <monochrom> Well yeah, I still have to think and try.
10:54:43 <merijn> monochrom: I have so far found bugs in GHC's bindist configure script 4 times, all of which apparently affected only me :p
10:55:12 <maerwald> bc you run stuff from broken uni library rigs
10:55:36 <monochrom> Wait, how does repl.it have cabal support?
10:55:43 <merijn> maerwald: No, that ws on macOS
10:55:50 <maerwald> dunno, but you can open a real shell
10:55:54 <monochrom> Actually I should try the obvious before I ask.  ("cabal script")
10:55:58 <maerwald> https://repl.it/repls/HollowLongMicrobsd#README.md
10:56:00 <monochrom> Oh haha
10:56:17 <merijn> maerwald: I was apparently the only person to ever run the macOS bindist on a machine with nvidia's CUDA compiler installed >.>
10:57:01 <monochrom> Oh well I gues :! exists
10:57:15 <maerwald> monochrom: no, press ctrl-k
10:57:45 <maerwald> as I thought: it's feature overloaded
10:58:10 <maerwald> and the main thing (the repl) is awfully slow :)
10:58:17 <monochrom> I'm curious about how did people find out ctrl-k
10:58:33 <monochrom> To be fair, it's on someone else's computer.
10:58:35 <maerwald> Because the readme told me
10:59:24 <maerwald> (also, it works ish since I switched to chrome)
10:59:37 <maerwald> Mozilla is dying anyway
10:59:54 <monochrom> Oh! I'm using Chrome alright.
11:00:22 <maerwald> Right and cookies are too boring for tracking me, chrome makes that much more efficient.
11:02:46 <maerwald> I guess that's as good as it gets
11:25:45 <jcowan> If it were possible to start over from scratch, what would be a good single convention for distinguishing between the names of parametric polymorphic functions like map, and type-class-driven ad hoc polymorphic functions like fmap?
11:26:16 <merijn> jcowan: Well, fmap is both...
11:26:29 <dolio> I would name `fmap` map, like it was in Haskell 1.4.
11:26:53 <merijn> dolio: That seems a completely orthogonal issue? Unless I misunderstood the question
11:27:11 <jcowan> Presumably calling map is slightly more efficient, at least when the compiler cannot monomorphize.
11:27:42 <merijn> actually, yeah I think I misunderstood :p
11:27:43 <jcowan> I mean functions are *merely* parametrically polymorphic (do not accept a method dictionary under the covers).
11:27:51 <jcowan> s/are/that are
11:28:27 <jcowan> Of course you'd need a different convention for operator-style names
11:28:30 <dolio> If you can call the current map, then the relevant type must be statically known, so the fmap can be specialized.
11:28:49 <solonarv> jcowan: that makes no sense, if the compiler can't monomorphize then there is no way calling the monomorphic 'map' would typecheck
11:30:59 <jcowan> Here's what I mean.  A function like fmap, which works on many unrelated types, is implemented by calling it with a method dictionary that maps calls on methods of Functor onto the type-specific version.  However, if the compiler knows that the context is monomorphic (e.g. this call of fmap is only ever made on a list) then the method dictionary can be left out and map can be called directly.
11:31:21 <merijn> jcowan: eh
11:31:32 <merijn> jcowan: GHC already optimises the dictionary away in those cases
11:31:39 <jcowan> Exactly.
11:32:08 <TheCommieDuck> I dunno if there's a better channel for this, but: in ghcide, is there a way to make it so that my own haddock docs are displayed in the hover-over? it's fine displaying e.g. Show or Int, but it won't display Foo, even if I write haddock markup for Foo.
11:33:28 <jcowan> So back to my question: What universal naming convention would work well for distinguishing between ordinary parametric polymorphic functions like map, and functions that provide ad hoc polymorphism like fmap?
11:33:58 <jcowan> dolio: If fmap were called map, would map as we know it be abolished, or would it have some other name?  If so, what name?
11:34:21 <dolio> Yes, Haskell 1.4 didn't have a list specific map, I think.
11:35:40 <wz1000> TheCommieDuck: this issue is fixed in haskell-language-server, see https://github.com/digital-asset/ghcide/pull/691
11:35:47 <dolio> I don't think hoping for a universal naming convention for everything to adhere to really makes sense.
11:39:04 <TheCommieDuck> ahhh, ty
11:39:18 <jcowan> Doesn't make sense, or isn't achievable?  I agree that it isn't achievable because hysterical raisins.
11:40:06 <dolio> The former.
11:40:15 <jcowan> Can you explain further?
11:40:57 <merijn> Well, what problem is this intended to solve?
11:41:30 <dolio> Well, `fmap` got its name chosen because it has to do with Functors. Why would some universal 'uses a type class' vs. 'doesn't use a type class' naming convention be appropriate for everything?
11:44:11 <monochrom> Use :type to find out how polymorphic a term is.
11:45:04 <phadej> I have heard that the name `fmap` was chosen because people wanted to have list-specific `map` in Prelude
11:45:13 <phadej> c.f. we have <> and ++ now there too
11:45:13 <monochrom> There is always pressure to add a naming convention to duplicate a tiny slither of what you can find out from :type
11:45:35 <dolio> If it were me, and monomorphizations of map were insisted upon, I would probably suggest putting them in a module that gets imported qualified. Then the qualification is the naming convention.
11:45:45 <monochrom> There was a convention of writing "iFoo" if foo :: Int.
11:45:55 <phadej> dolio: that's what we are arriving in 202x
11:46:01 <phadej> Data.List will have monomorphic List functions
11:46:07 <monochrom> There was a convenction of writing "@foo" if foo :: [X]
11:46:09 <phadej> (e.g. foldr)
11:46:17 <phadej> and foldr in Prelude would be using Foldable
11:46:38 <phadej> and fwiw, <$> is quite non-type-class named "name" ;)
11:46:43 <monochrom> Now there is a desired convention of writing a special annotation if foo :: (Some class constraint here) => ...
11:46:56 <monochrom> RESIST THIS PRESSURE. USE :type
11:47:24 <phadej> :t throwIO
11:47:25 <dolio> Yeah, I don't see the value of putting it in the name when you can ask the computer the type.
11:47:25 <lambdabot> Exception e => e -> IO a
11:47:26 <phadej> :t throw
11:47:27 <lambdabot> Exception e => e -> a
11:47:29 <monochrom> Either that, or propose the full logical conclusion: The name must fully duplicate the type.
11:47:30 <phadej> :)
11:47:57 <phadej> (throwIO is *not* a specialization of throw)
11:48:01 <monochrom> Don't just half-ass duplicate "it involves Int", "it involves list", "it involves a class".
11:48:06 <merijn> monochrom: pfft! don't blame hungarian notation for the dumbness of system's Hungarian that most people adopted
11:48:21 <monochrom> No, I am not blaming the original Hungarian notation.
11:48:32 <merijn> App's Hungarian was quite a great idea, tbh
11:48:42 <merijn> Although Haskell has newtype, kinda obsoleting it
11:48:50 <monochrom> But I am blaming the dumbass watering-down that most people adopted.
11:49:00 <monochrom> I didn't call out "hungarian", did I?
11:49:15 <monochrom> I only called out exactly "write iFoo for int variable".
11:49:36 <phadej> (original) hungarian is not about types, but about intent
11:49:38 <merijn> monochrom: Well, you did iFoo and I doubt many people know that there is even a sensible Hungarian notation other than system's hungarian ;)
11:49:53 <merijn> phadej: Well, kinda about types. Just not the types of the variables :p
11:50:34 <phadej> I'd say that `equal lhs rhs = ...` is "hungarian notation"
11:50:37 <monochrom> Hell let me point out that the full logical conclusion has already been implemented.
11:50:42 <monochrom> And in real-world use.
11:50:48 <monochrom> It's called "C++ name mangling"
11:51:03 <merijn> monochrom: I thought you were going to call out Thielemann :p
11:51:09 <monochrom> haha
11:51:37 <monochrom> There was a time GHC performed an equivalent name mangling too.
11:51:49 <monochrom> Back in the days when GHC compiled Haskell to C.
11:52:17 <monochrom> MANGLE OR GO HOME
11:54:06 <monochrom> I am surprised, at this rate, that no one has proposed "type family name should follow a special convention so you know it is not a real polymorphic type"
11:57:20 <dolio> merijn: So, the real problem is that what people actually adopted was the `i++; // increment i` version of Hungarian notation?
11:57:30 <merijn> dolio: Yes
11:58:18 <merijn> dolio: Basically, it originated in the application division of Microsoft where in, for example they used stuff like "pxHeight" "rowHeight", etc. to distinguish the "units" of variables
11:58:36 <merijn> dolio: Where the units/types where logical units relevant to the application (pixels, rows, cells, etc.)
11:58:39 <dolio> Ah, now that makes sense.
11:59:15 <merijn> dolio: It got adopted by the system/OS teams which just prefixed the variables with their actualy types (int, double, etc.) and that version got popularised in the wider world sometimes
11:59:24 <merijn> Which is, of course, dumb as shit
12:00:48 <monochrom> I wonder if in the context of kernel code, it may actually help.
12:01:06 <merijn> If it did they should've made their compiler less bad ;)
12:01:30 <monochrom> Easy to say and even do today in the year 2020 of our Lord.
12:01:44 <monochrom> This was like 1980s. What less-bad compiler?
12:02:01 <maerwald> merijn: hey, you could write a static analyzer that checks the type of your variable against the variable name!
12:02:05 <maerwald> extra safety
12:02:56 <merijn> monochrom: Well, MS wrote their own Visual Studio compiler that they used, right? :p
12:03:10 <merijn> monochrom: If it was a problem, they could've just put more people on improving their own compiler :p
12:03:12 <monochrom> I guess
12:04:03 <monochrom> I did have witness (worked as intern) testified that the internal VS was like 5 years ahead of the published one.
12:16:10 <jcowan> merijn: The introduction of typeclasses into a language (Scheme) with many existing monomorphic procedures.
12:16:37 <merijn> "use a module system"?
12:18:22 <monochrom> Is this still about rationalizing special naming conventions?
12:18:29 <jcowan> There is a module system, but you have to make sure that each and every module imports fmap as map, otherwise things blow up.
12:18:33 <jcowan> monochrom: For me it is.
12:18:52 <monochrom> Because by God I swear in the Scheme case the priority is a special naming convention for special forms.
12:19:27 <monochrom> Because with the status quo you look at (f x y z) and (g x y z) and they don't tell you f is call-by-eval, g is a macro.
12:19:49 <jcowan> True, but that's a local issue.  If you want to call if $if, just import-with-renaming.
12:19:55 <monochrom> That is a 100x times much bigger issue than merely "how polymorphic is f?"
12:20:32 <monochrom> OK why doesn't your answer apply to ad-hoc functions too?
12:22:01 <jcowan> Suppose that a module has already been compiled using the monomorphic map (on lists), and you import it into your code which uses the ad hoc polymorphic map.  Then you pass some non-list to one of the functions of the module, expecting it to Just Work, and boom.
12:22:16 <jcowan> (in a dynamically typed language, that is)
12:22:40 <merijn> So? If you can rename function on import then "just make users do that"
12:22:57 <merijn> Seems like problem solved
12:23:24 <merijn> oh, now we're discussing "how do you deal with lack of types/type checking"
12:23:39 <merijn> And the answer in Scheme to that is "ha, that's the users problem"
12:23:40 <monochrom> For all I care you can go propose this to the Scheme community
12:23:57 <jcowan> I am a part of that community.
12:24:30 <merijn> Right, but I don't see why the Haskell community, which doesn't have this issue because of a typechecker, would have a solution for you
12:24:44 <monochrom> OK please explain to me why a Scheme proposal appears in #haskell.
12:24:50 <merijn> It's like asking deaf people how they deal with overwhelmingly loud sounds
12:24:54 <jcowan> Because this is the hope of typeclasses.
12:24:56 <jcowan> s/hope/home
12:25:14 <jcowan> If you ask Scheme people about typeclasses, they reply "Huh?"
12:25:38 <monochrom> I say crackpot.
12:27:39 <jcowan> well, anyhow, thanks for the help.
12:28:53 <monochrom> I guess I was wrong, not crackpot.
12:29:00 <monochrom> More like a solution looking for a problem.
12:29:49 <monochrom> Scheme doesn't even have type classes, so the point is moot. Haskell doesn't have the can't-static-check problem, so the point is also moot.
12:30:26 <ixlun> Hi all, I'm was just wondering if it's possible to have guards inside a case of expression?
12:31:03 <monochrom> Yes abolutely. Just use -> instead of =
12:31:26 <monochrom> case ... of   x:xs | x>0 -> "w00t head is positive"
12:31:52 <dolio> You have to type check things to have type classes to begin with.
12:33:16 <merijn> dolio: Racket has types, right?
12:33:40 <dolio> I guess. There is typed racket.
12:35:52 <dolio> I haven't followed it much, but it's kind of the opposite of the philosophy needed for type classes, last I checked.
12:36:10 <ixlun> Brilliant, thanks monochrom.  I just want to make sure I've understood this correctly in that case: https://pastebin.com/zjVSPLPY  I can then assert that if line 5 has been executed that c == nc?
12:36:28 <ixlun> i.e. line 4 will be checked before line 5?
12:36:38 <dolio> I.E. we have a bunch of untyped code. How can we layer types on top that describe it and check some stuff about it. Curry style.
12:36:59 <monochrom> Right.
12:37:03 <dolio> Type classes are Church style: code only makes sense in the context of types.
12:37:35 <ixlun> great, thanks monochrom :-)
12:39:57 <dolio> E.G. `\x -> x + 1` means something different depending on whether it gets ascribed the type `Num a => a -> a` or `Int -> Int` or `Double -> Double`.
12:40:32 <dminuoso> 21:38:47            dolio | Type classes are Church style: code only makes sense in the context of types.
12:40:41 <dminuoso> Can you elaborate on what you mean by church style exactly?
12:42:25 <dolio> It means what I said there. Code/terms only have well defined meaning together with the type ascribed to it. Curry style has meaning attributed to code/terms independent of/prior to any types being ascribed to it.
12:58:57 <fog> has anyone seen; Geoffrey Hintons idea of Capsule Networks ?
12:59:18 <fog> they seem isomorphic to a restricted typed lambda calculus 
13:00:22 <fog> http://papers.nips.cc/paper/6975-dynamic-routing-between-capsules.pdf
13:00:47 <fog> the idea seems to be replacing neurons with arbitrary classifiers, aka functions. 
13:15:03 <pounce> is there any better way to do `if b then do { ... } else pure ()` in a do block
13:15:28 <dolio> when b $ do ...
13:16:16 <pounce> dolio: thank you
13:16:28 <dminuoso> Or, enable BlockArguments
13:16:33 <dminuoso> Then you can do `when b do ...`
13:16:57 <monochrom> "when" is in Control.Monad.  Even though now it just needs Applicative. :)
13:17:34 <dminuoso> monochrom: See, I like that. otoh traverse_ is *not* re-exported in Data.Traversable
13:17:44 <dminuoso> Trips me up every time..
13:17:58 <monochrom> yikes
13:25:01 <pounce> hm, i got my search working i think
13:25:15 <pounce> i can't tell if it's slow because i did something wrong or if it's slow just because the problem's exponential
13:25:49 * hackage dobutokO-poetry 0.16.2.0 - Helps to order the 7 or less Ukrainian words to obtain somewhat suitable for poetry or music text  https://hackage.haskell.org/package/dobutokO-poetry-0.16.2.0 (OleksandrZhabenko)
13:27:24 <pounce> can anybody look over my code and see if i'm doing something terribly wrong
13:27:27 <Rembane> pounce: Could be both, what problem are you solving? 
13:27:41 <Rembane> pounce: Paste a link to your code here and I can take a look.
13:28:00 <pounce> Rembane: the "addition chains" problem using branch& bound using the LogicT (State ..) monad
13:29:07 <pounce> Rembane: https://paste.sr.ht/~pounce/4aaa52816c8b59a885d0553e41175b3ff4f214ef
13:29:24 <pounce> could all of the superfluous `mzero`s at the end be causing some slowdown? 
13:30:28 <Rembane> pounce: For how big numbers does it become slow? 
13:31:06 <pounce> so 50 works fine, 100 i stopped after 1m30. I want to go up to 200
13:33:43 <Rembane> pounce: All combinations of the chain, is that n! or n^m number of combinations? 
13:34:25 <pounce> Rembane: should be n^2, no? since I'm only taking two numbers from each chain
13:37:02 <pounce> these chains are also not _that_ long, the largest heuristic is 12 for 199
13:37:15 <pounce> err, 13 for a different one but still
13:37:47 <Rembane> pounce: It should be n^2, I just failed at reading code. :) 
13:38:08 <pounce> no worries!
13:38:17 <Rembane> pounce: That's not much, the complexity shouldn't be too terrible. 
13:39:10 <pounce> i mean, n^2 branches at each iteration is quite large, but i was hoping the pruning would take care of that.... however it does not
13:39:27 <pounce> perhaps this is just dealing with the NP hard nature of the problem,,, but I think it should still be able to handle 100
13:39:59 <ixlun> Is it possible to run a function when constructing a tuple?  I've got a Lambda: (\(f, t, s) -> (f,t, perft' n - 1 s)) but it has type: (Locus, Locus, GameState -> Int)
13:40:33 <pounce> ixlun: what's the type of perft'
13:41:11 <Rembane> pounce: I have no idea how LogicT works, which makes it trickier to give good advice, but maybe someone else here knows that.
13:41:29 <pounce> I'm thinking you want to do `perft' (n-1) s`
13:41:41 <ixlun> https://pastebin.com/40pGxUA4
13:41:43 <pounce> Rembane: ah, I'm reading the LogicT paper now but I still haven't gotten through it
13:41:56 <ixlun> that's the code :-)
13:42:35 <pounce> ixlun:  14:41 <pounce> I'm thinking you want to do `perft' (n-1) s`
13:42:38 <Rembane> pounce: Got it, my only advice so far is to rewrite the code in the simplest possible way and then implement it using LogicT.
13:42:39 <pounce> ^^ does this work?
13:43:28 <pounce> ah.. I was thinking about backtracking on my own using recursion, but I wanted to try to do it with a backtracking monad first because I thought it would help
13:43:54 <ixlun> pounce: Yep, that worked!
13:44:10 <ixlun> Just trying to figure out why
13:44:32 <Rembane> pounce: It does sound fun too. 
13:46:05 <Rembane> ixlun: It's because of precedence rules, perft' is applied to n first, and then 1 is subtracted from that result and then s ... 
13:46:27 <pounce> ixlun: so `-` is an infix function so it has "higher priority" than an ordinary function. So your code parses to something like `\(f, t, s) -> (f,t,(perft' n) - (1 s))` I think
13:46:34 <pounce> ah yes, Rembane said it better
13:47:24 <ixlun> Ahh I see, hence the strange type that results.  Thanks pounce 
13:53:49 <pounce> ahh I know what I did wrong.
13:54:26 <pounce> I'm generating the chains wrong. I should always be adding a number to the chain that's bigger than all of the existing ones, otherwise i'm emulating the same chains multiple times
13:55:55 <Rembane> I thought you did that, but maybe you generate unique numbers instead of larger numbers?
13:57:09 <pounce> Rembane: yes... but I would generate the same "unique" numbers in multiple paths
13:57:51 <pounce> so chain1=[4,2,1], chain2=[3,2,1] are both states i could have. However, each could generate the other
13:57:55 <pounce> with the previous code
13:58:09 <pounce> err, each could generate [4,3,2,1]
13:58:36 <pounce> while if I only allow numbers to grow only the right branch would be able to generate [4,3,2,1]
13:59:02 <Rembane> pounce: Oh, this reminds me of Fibonacci numbers, do they have anything in common? And does this imply that you can use memoization and/or dynamic programming to only generate every previous state once?
13:59:29 <pounce> Rembane: no. Unfortunately there is no optimal substructure so dp would not work
14:00:02 <pounce> the bigger the numbers get the longer the chains get. This means you get "more information" for which to build your chains. So larger chains cannot reduce to shorter chains
14:00:29 <Rembane> pounce: Got it, that makes this much more exciting. 
14:00:29 <pounce> (i.e. there are cases where l(2n) <= l(n), so you could not use the obvious l(2n)=l(n)+1)
14:00:36 <pounce> Rembane: indeed :)
14:02:28 <pounce> ok! now 50 is happening instantly instead of taking 23s. 100 is still lagging behind....
14:04:44 <pounce> perhaps i should just solve P=NP so my code would run quickly
14:04:49 <d34df00d> Hi!
14:05:10 <d34df00d> I'm going through the Snoyman's post on ReaderT design pattern, and I'm curious what happens here: main = execStateT (concurrently (modify (+1)) (modify (+2))) 4 >>= print
14:05:15 <d34df00d> Why only one effect of `modify` is visible?
14:05:26 <d34df00d> Here `concurrently` comes from Control.Concurrent.Async.Lifted
14:05:36 <monochrom> That has nothing to do with ReaderT
14:06:00 <d34df00d> Yes, I understand that, that's just for the reference where I'm getting that.
14:06:12 <d34df00d> He shows this as a motivation to keep state in iorefs etc.
14:06:19 <monochrom> Ah right, yes.
14:06:37 <monochrom> Could you remind me the type of concurrently?
14:06:41 <dmwit> I'm willing to bet that you do not reliably see only one effect of `modify`.
14:06:56 <d34df00d> concurrently :: MonadBaseControl IO m => m a -> m b -> m (a, b)
14:07:12 <dmwit> I'm also willing to bet that the reason you sometimes see only one effect is that the interleaving goes: both threads read; then one writes; then the other writes.
14:07:36 <d34df00d> So, do I understand correctly I'm observing such behaviour because http://hackage.haskell.org/package/lifted-async-0.3.0/docs/src/Control-Concurrent-Async-Lifted.html#waitBoth is defined so that `rb <- restoreM sb` happens last, where sb is the second action.
14:07:37 <d34df00d> ?
14:08:07 <d34df00d> dmwit: if I add `>> liftIO (print "done")` to both actions, then I see they both finish before the `print` — which makes sense, `concurrently` waits for results.
14:08:17 <monochrom> OK so StateT S IO () = S -> IO ((), S)
14:08:23 <dmwit> d34df00d: I don't believe I ever claimed anything which contradicts that.
14:08:34 <Rembane> pounce: Trivial! :D
14:08:49 <d34df00d> dmwit: I'm quite reliably seeing `6` as the result.
14:09:12 <dmwit> d34df00d: Therefore, if you believe I claimed something that contradicts that, you should 1. reread it, then 2. explain to me why you think so.
14:09:40 <d34df00d> Actually, let's put it the other way.
14:09:42 <dmwit> d34df00d: How reliable is "quite reliable"? Did you test it 1 time? 10 times? 100 times? 1e9 times?
14:09:47 <d34df00d> dmwit: does that imply that the State is shared between two threads?
14:10:02 <d34df00d> dmwit: actually 10000 times and made sure I only have 6 in the output.
14:10:34 <dmwit> I don't know. I haven't read any of your code yet. I'm making informed guesses based on the English you've posted here only (and therefore take with an appropriate amount of salt, please!).
14:11:10 <d34df00d> Or, by "interleaving", did you mean that implementation detail of `waitBoth` (that's used by `concurrently`) that I linked above?
14:11:42 <d34df00d> dmwit: my code amounts to the `main = …` above plus corresponding imports. I was just curious to take an example from somebody else's post.
14:12:51 <dminuoso> d34df00d: welcome to MonadUnliftIO.
14:13:22 <dmwit> Okay. I have read some code now. The correct answer is that `concurrently` enforces the order of `StateT` effects.
14:13:49 <dminuoso> dmwit: Does it?
14:14:05 <dmwit> Specifically: `concurrently left right` performs the StateT effects of `left` and `right` starting from the same state, throws away the outcome of the effects of `left`, and keeps the effects of `right`.
14:14:10 <d34df00d> dminuoso: yeah, that's my favourite thing for quite some time now.
14:14:22 <dminuoso> Oh right
14:14:22 <d34df00d> dmwit: but what in the implementation fixes this order?
14:14:25 <dminuoso> https://hackage.haskell.org/package/lifted-async-0.10.1.2/docs/src/Control.Concurrent.Async.Lifted.html#waitBoth
14:14:28 <dminuoso> d34df00d: ^-
14:14:33 <dminuoso> That's the relevant bit
14:14:44 <d34df00d> Yeah, that was part of my original question.
14:15:01 <d34df00d> rb <- restoreM sb being the second one and so on.
14:15:07 <d34df00d> So that's nice, thanks!
14:15:11 <dmwit> I do not believe `waitBoth` is the relevant bit. I believe the relevant bit is the source of `concurrently`+`withAsync`.
14:15:22 <dminuoso> dmwit: The waitBoth is, transitively
14:15:51 <dminuoso> concurrently left right = withAsync left $ \a -> withAsync right $ \b -> waitBoth a b
14:16:10 <dminuoso> It's the waitBoth that does the liftBase and restoreM
14:16:15 <dmwit> Okay, you are right. The implementation of `waitBoth` matters.
14:16:56 <dmwit> withAsync and waitBoth must work together. Both implementations matter.
14:17:02 <dminuoso> d34df00d: Personally I found I got tripped up too many times by when state is restored and how. Im part of the MonadUnliftIO resistance now. :)
14:17:21 <d34df00d> That's totally understandable!
14:17:23 <dminuoso> Ah yeah you
14:17:26 <dminuoso> you're right dmwit
14:17:43 <d34df00d> I'm resisting any IO whatsoever just in case.
14:17:51 <d34df00d> Thanks for clarifying things!
14:18:16 <dminuoso> dmwit: Though, I dont see withAsync really mattering in the grand scheme of things.
14:18:50 <dminuoso> because at the end its just waitBoth that imposes the ordering of restoreM
14:19:52 <dmwit> withAsync also calls restore. And its restore matters more, because it is the one that calls the continuation that uses waitBoth.
14:20:05 <dminuoso> dmwit: haha I got tripped up by that as well.
14:20:09 <dminuoso> look closer what the restore is :)
14:20:42 <dminuoso> That's just the restore from mask
14:20:54 <dmwit> oh my glob
14:21:06 <dmwit> Ok!
14:42:01 <ski> Uniaika : "containing infix constructors" is a bit too specific. consider `showsPrec _  Nothing  = showString "Nothing"; showsPrec p (Just x) = showsParen (p > 10) $ showString "Just " . showsPrec 11 x'. no infix constructor for `Maybe', but it's still important to both define `showsPrec', and use it on `x'
14:45:08 <ski> (one could get away with not inspecting `p', if one always bracketted in the `Just' case. and i suppose one could always bracket `x' as well ..)
14:51:53 <ski> btw, note that if one wanted to take the right-associativity (`infixr') into account, one'd go
14:52:09 <ski>   showsPrec d (u :^: v) = showParen (d > up_prec)
14:52:23 <ski>                         $ showsPrec (up_prec+1) u
14:52:37 <ski>                         . showString " :^: "
14:52:52 <ski>                         . showPrec  up_prec    v
14:53:03 <ski>     where
14:53:08 <ski>     up_prec = 5
14:54:14 <ski> (for `infixl', one'd instead refrain from incrementing in the `u' case. for `infix', neither (i.e. always increment for both))
14:54:23 <dolio> You can imagine this being the way constructors with multiple fields work, too.
14:55:55 <dolio> `C x y z` has the parentheses omitted from `((C x) y) z because the infix operation of function application gives 10 to the left and 11 to the right.
14:55:55 <ski> yea, application is left-associative, so right operand, the component (like `x' in `Just x') show be displayed as `showsPrec (app_prec+1) x' (where `app_prec = 10')
14:56:03 <ski> yes
14:56:17 <ski> s/show be/should be/
14:56:19 <dolio> Although no one does it that way for Show, of course. It works when pretty printing something with Haskell-like syntax.
14:56:59 <ski> hm, what do you mean ?
14:57:27 <ski> oh
14:58:03 <dolio> I mean you're never going to do `showsPrec d (C x y z) = <stuff that handles x y and z according to application's precedence>`
14:59:11 <dolio> But if you're printing a representation of a language like `pretty d (App f x) = ...` you can use precedence to get `f x y z`.
15:00:23 <ski> you mean if one would pretty-print something like `data Term = Var Ident | Lit Literal | Term :@: Term | Infix Term Op Term; infixl 9 :@:', defining say `prettyPrec :: Int -> Term -> ShowS'
15:00:53 <dolio> I guess maybe with enough hacks you could have something where `f x y z` was actually Haskell source code for `App (App (App ...) ...) ...`, and you could convince yourself that the Show instance should take advantage of that.
15:00:56 <dolio> But it's a stretch.
15:01:28 <dolio> > f x y z
15:01:30 <lambdabot>  error:
15:01:30 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M455677179719...
15:01:30 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
15:01:36 <dolio> Oh well.
15:02:39 <jollygood2> are there laws from Show/Read, such as that they must be valid haskell expressions, or at least that show output fed to read must return original value?
15:02:55 <jollygood2> from=for
15:03:29 <ski> so one could have `prettyPrec p (t :@: t0) = showParen (p > app_prec) $ prettyPrec app_prec t . showChar ' ' . prettyPrec (app_prec+1) t0 where app_prec = 9'
15:04:54 <ski> you're handling them, by calling `showsPrec 11' on them
15:06:02 <dolio> Yeah, I just mean you get all your values at once with a constructor, so you're never in a situation where you're working out the parentheses of application for them with precedence numbers.
15:07:11 <dolio> jollygood2: I don't think the docs explicitly say it must be valid Haskell source for the values, and some instances violate that. But deriving always produces Haskell source, and a lot of people are of the opinion that that is the way Show should behave.
15:07:35 <dolio> Being a rough inverse to read is in the docs.
15:07:49 <ski> jollygood2 : perhaps not laws, but i'd argue strong expectations
15:08:15 <ski> (for law relating `Show' and `Read' one'd need a common subclass of them, anyway)
15:09:06 <ski> jollygood2 : in any case, i'd say it's misguided to attempt to make a `Show' instance do some kind of custom pretty-printing format
15:09:21 <ski> > f x y z :: Expr
15:09:22 <lambdabot>  f x y z
15:11:11 <ski> dolio : ah, now i see what you mean. but still, conceptually, you're handing application as "just another infix operator", which explains why you're passing `11' to `showsPrec' on the (non-infix) constructor components
15:11:26 <hekkaidekapus> The closest a normative text wrt laws would be The Haskell Report 2010 — Section 11.4: “That is, readsPrec should be able to parse the string produced by showsPrec, and should deliver the value that showsPrec started with.”
15:11:30 <ski> (i know you know this, just clarifying to any onlookers)
15:11:40 <dolio> Right, that's what I mean.
15:13:21 <ski> jollygood2 : note that `Show' instances are made to work with each other, so if you're doing some non-Haskell custom pretty-printing in a `Show' instance, you will get a mixture of Haskell and non-Haskell syntax, when showing some values ..
15:13:33 <ski> (and ditto for `Read' instances, of course)
15:14:11 <dolio> I think it's completely reasonable to require Show and Read instances to do something good if a type implements them both even without a common class relating them.
15:16:15 <ski> e.g. if you do a custom non-Haskell syntax for `instance Show Foo', then this will e.g. be combined with `instance Show a => Show (Maybe a)' (and ditto for other parameterized types), to generate an instance for `Show (Maybe Foo)' (mixing Haskell syntax for the `Maybe' part with the non-Haskell syntax for the `Foo' part)
15:16:54 <dminuoso> hekkaidekapus: That's out of context.
15:17:05 <dminuoso> hekkaidekapus: If you read closer, you'll notice that this applies to only deriving generated Show instances.
15:17:12 <dminuoso> Rather than to any Show instance
15:17:29 <ski> > MkPair DivideByZero DivideByZero
15:17:32 <lambdabot>  MkPair divide by zero divide by zero
15:17:32 <ski> > MkPair (mkStdGen 1234) (mkStdGen 5678)
15:17:35 <lambdabot>  MkPair 1235 1 5679 1
15:17:41 <dolio> Or if you have two different 'pretty' Show instances written by two different people, maybe they'll combine into something that makes absolutely no sense. :)
15:18:33 <ski> (imho, the `Show' instances for `ArithException' (and many other exception types ..), and for `StdGen', are broken. but apparently the last one is fixed, now)
15:18:53 <ski> yea .. possibly even worse :)
15:20:40 <ski> (btw, that example uses `data Pair a = MkPair a a deriving Show' .. i didn't find a suitable (parametric) data type, to use in place of `Pair', that was already defined in one of the modules lambdabot had imported)
15:21:48 <hekkaidekapus> dminuoso: Yes, it’s the section’s title even. I was following-up dolio’s explanation above (But deriving always produces Haskell source, and a lot of people are of the opinion that that is the way Show should behave.)
15:21:55 <kraeXen> Is there a cleaner way to do this?
15:21:55 <kraeXen> > let valid = valid = ['+'..'.'] ++ ['0'..':'] ++ ['?'..'z'] ++ ['0'..':'] ++ ['"' .. ')'] ++ ['+'..'.']; x = "abc/defghi blah" reverse (takeWhile (`elem` valid) $ reverse takeWhile (/= ' ') x)
15:21:57 <lambdabot>  <hint>:1:19: error: parse error on input ‘=’
15:22:09 <kraeXen> > let valid = ['+'..'.'] ++ ['0'..':'] ++ ['?'..'z'] ++ ['0'..':'] ++ ['"' .. ')'] ++ ['+'..'.']; x = "abc/defghi blah" reverse (takeWhile (`elem` valid) $ reverse takeWhile (/= ' ') x)
15:22:11 <lambdabot>  <no location info>: error:
15:22:11 <lambdabot>      not an expression: ‘let valid = ['+'..'.'] ++ ['0'..':'] ++ ['?'..'z'] +...
15:22:30 <kraeXen> > let valid = ['+'..'.'] ++ ['0'..':'] ++ ['?'..'z'] ++ ['0'..':'] ++ ['"' .. ')'] ++ ['+'..'.']; x = "abc/defghi blah" in reverse (takeWhile (`elem` valid) $ reverse takeWhile (/= ' ') x)
15:22:32 <lambdabot>  error:
15:22:32 <lambdabot>      • Couldn't match expected type ‘(Char -> Bool) -> [Char] -> [Char]’
15:22:32 <lambdabot>                    with actual type ‘[a1]’
15:22:38 <dminuoso> kraeXen: Perhaps try it out in a private query
15:22:40 <kraeXen> okay, well that's embarrasing...
15:23:51 <ski> dolio : "it's completely reasonable to require Show and Read instances to do something good" -- yes, of course. but if you're doing `foo :: (Show a,Read a) => ..a..', then there need not be a single place in the code that has the responsibility for checking the coherence. normally the instances would be given in the same package (or even same module, usually) as the one defining the type
15:24:38 <kraeXen> okay, this: let valid = concat [['+'..'.'], ['0'..':'], ['?'..'z'], ['0'..':'], ['"' .. ')'], ['+'..'.']]; x = "abc/defghi blah" in reverse (takeWhile (`elem` valid) $ reverse (takeWhile (/= ' ') x))
15:24:41 <kraeXen> any cleaner way?
15:26:02 <dminuoso> kraeXen: can you describe the desired semantics in words perhaps?
15:26:09 <kraeXen> sure:
15:26:13 <c_wraith> is there any particular reason there are a bunch of duplicates in valid?
15:27:31 <dolio> It's also reasonable for people to not publish instances of Show/Read for types they don't maintain. And if it's just something you're writing for yourself, then any conventions put forward by other people don't really matter.
15:27:44 <xsperry> I would create digits, lowers, uppers, validPunctuations strings, and then use those to build valid string
15:28:08 <dolio> I don't think having a common sub-class would even rule out that case.
15:29:35 <dminuoso> It seems to me, generally, that you want to extract a string delimited by two `Predicate Char` 
15:29:46 <dminuoso> That is somewhere in an infix position
15:29:50 <ski> kraeXen : you want to avoid `!',`*',`/',`{',`|',`}',`~' in the extracted part ?
15:29:52 <dminuoso> kraeXen: Is that about right?
15:31:24 <kraeXen> I want to take "path/to/stuff and arguments" and filter out the arguments, and keep just the last path item
15:31:33 <kraeXen> so that would return "stuff"
15:31:41 * ski . o O ( `remberUptoLast' )
15:31:53 <dminuoso> Oh!
15:31:59 <kraeXen> and c_wraith: that was a typo
15:32:08 <dminuoso> kraeXen: Is that possibly a shell command, then?
15:32:13 <dminuoso> Or just command + args?
15:32:22 <kraeXen> shell command, yes
15:33:22 <ski> dolio : it's reasonable to expect, yes
15:33:25 <kraeXen> ski: I would just blacklist characters, but in shell commands some strange characters can be used, and I just want to limit it to simple things
15:33:44 <kraeXen> so A-Z a-z and some other valid chars
15:34:06 <dminuoso> kraeXen: You will in all likelihood need a proper parser.
15:34:25 <kraeXen> dminuoso, what I have works, but I'm looking for a cleaner way to do it
15:34:30 <ski> > ['!' .. 'z'] \\ "!*/"
15:34:32 <lambdabot>  "\"#$%&'()+,-.0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijkl...
15:35:01 <dminuoso> If this was just "command + args" Id recommend `words` + System.FilePath.Posix.splitFileName
15:35:16 <ski> kraeXen : if that ^ is what you intend, then probably it's clearer to use `\\' like that, yes ?
15:35:23 <kraeXen> much cleaner
15:35:47 <kraeXen> is there something like takeWhile that takes stuff from the end of the list?
15:35:52 <kraeXen> that's why I'm using reverse
15:36:13 <ski> kraeXen : btw, what about backslash-escaped characters in the path, like e.g. spaces ?
15:36:58 <kraeXen> I thought about that, yes, and I can't avoid that, however, for my use case it works (pgrep)
15:37:11 <dminuoso> kraeXen: Anyway, you can just do this:
15:37:12 <ski> hm. i guess one could define `spanLast',`breakLast'
15:37:15 <dminuoso> % breakEnd p = spanEnd (not . p)
15:37:15 <yahb> dminuoso: ; <interactive>:98:14: error:; * Variable not in scope: spanEnd :: (a -> Bool) -> t; * Perhaps you meant one of these: `BSC.spanEnd' (imported from Data.ByteString.Char8), `BS.spanEnd' (imported from Data.ByteString)
15:37:25 <dminuoso> % spanEnd p xs = (dropWhileEnd p xs, takeWhileEnd p xs)
15:37:25 <yahb> dminuoso: ; <interactive>:99:36: error:; * Variable not in scope: takeWhileEnd :: (a -> Bool) -> [a] -> b; * Perhaps you meant one of these: `BSLC.takeWhile' (imported from Data.ByteString.Lazy.Char8), `BSC.takeWhile' (imported from Data.ByteString.Char8), `takeWhile' (imported from Prelude)
15:37:26 <dminuoso> Gah
15:37:35 <dminuoso> https://github.com/haskell/filepath/blob/master/System/FilePath/Internal.hs#L1022-L1035
15:37:43 <ski> @index takeWhileEnd
15:37:43 <lambdabot> bzzt
15:37:43 <dminuoso> Or, you know, just use filepath directly. :P
15:41:43 <jollygood2> > takeBaseName "/foo/bar/baz"
15:41:45 <lambdabot>  error:
15:41:45 <lambdabot>      Variable not in scope: takeBaseName :: [Char] -> t
15:42:22 <jollygood2> % takeBaseName "/foo/bar/baz"
15:42:22 <yahb> jollygood2: ; <interactive>:100:1: error: Variable not in scope: takeBaseName :: [Char] -> t
15:43:03 <ski> @botsmack
15:43:03 <lambdabot> :)
15:44:19 * hackage persistent-redis 2.5.2.5 - Backend for persistent library using Redis.  https://hackage.haskell.org/package/persistent-redis-2.5.2.5 (MaxGabriel)
15:45:18 * hackage persistent-test 2.0.3.2 - Tests for Persistent  https://hackage.haskell.org/package/persistent-test-2.0.3.2 (MaxGabriel)
15:46:49 <koz_> I keep running into the pattern 'join <$> traverse f x'. Is there some kind of combinator for this?
15:48:07 <ski> it's been called `concatMapM'
15:48:28 <ski> (in the list case, at least)
15:48:47 <koz_> Yah, but it's more general.
15:49:05 <koz_> :t \f -> fmap join . traverse f
15:49:06 <lambdabot> (Monad m, Traversable m, Applicative f) => (a1 -> f (m a2)) -> m a1 -> f (m a2)
15:49:32 <koz_> traverseM lol.
15:49:43 <ski> apparently `Streamly.Prelude.concatMapM :: (IsStream t, Monad m) => (a -> m (t m b)) -> t m a -> t m b', e.g.
15:51:14 <ski> (oh, i guess that's not quite the same, since it's not `m (t m b)' in the end)
15:55:44 <koz_> I'm seriously writing something like ($> x) <$> (f y >>= g), modulo naming.
15:56:23 <dolio> We called in `mangle` in the Haskell ermine implementation. :)
15:56:46 <koz_> dolio: Maybe 'joinverse'. :P
15:57:16 <ski> concatraverse
15:57:42 <koz_> ski: 'catverse' for short.
15:57:52 <Uniaika> thanks ski
15:58:01 <Uniaika> (for your 23:41 CEST message)
15:58:06 <ski> Uniaika : you saw the following discussion, too ?
15:58:13 <Uniaika> nope, just came home
15:58:17 <Uniaika> let me read the backlog
16:00:30 <dolio> Those aren't really in the same league as `triverse` and `transverse`.
16:02:47 <koz_> dolio: 'transverse' would need to involve MonadTrans somehow.
16:03:36 <ski> koz_ : `const x . g =<< f y' ?
16:03:56 <koz_> ski: Yeah, that's less APLy.
16:04:16 <ski> er, sorry. not quite that
16:04:52 <ski> `(x <$) . g =<< f y', i guess
16:04:54 <dolio> No, `transverse :: (Functor f, Functor g) => (forall a. f a -> g a) -> t f -> t g` or similar.
16:05:39 <dolio> You could get rid of one of the Functor constraints if you want.
16:05:52 <ski> which ? :)
16:06:06 * ski . o O ( Buridan's ass )
16:07:06 <triteraf1ops> are there any reasons in the backend for the way haskell functions are?
16:07:24 <dolio> ski: You can choose depending on how you implement it. But only one of them.
16:07:33 <triteraf1ops> I've only ever found it annoying.
16:07:48 <triteraf1ops> And there are much more flexible and elegant ways of doing partial application
16:08:18 <ski> are you thinking of something specific, triteraf1ops ?
16:08:33 <triteraf1ops> mathematica's hash notation for instance
16:08:37 <ski> ("the way haskell functions are" is a bit vague ..)
16:08:44 <ski> i'm not familiar with that
16:09:05 <triteraf1ops> oh, well, specifically, how there may only be one argument.
16:10:07 <ski> it's a simplification that removes an unnecessary complication
16:10:22 <triteraf1ops> in the backend?
16:10:23 <ski> math tends to do the same thing
16:10:30 <triteraf1ops> not really...
16:10:46 <ski> no, not in the backend. i'm talking about the conceptual model of the language
16:11:00 <triteraf1ops> when you do that in math, you break a lot of function composition. Same thing happens in haskell
16:11:20 <ski> "do that" being ? any example of what you mean ?
16:11:36 <triteraf1ops> When you insist on all functions having only one input
16:11:57 <ski> what is the breakage you're thinking of ?
16:12:10 <triteraf1ops> composition involving functions with two inputs gets brplen
16:12:40 <triteraf1ops> if f :: Int -> Int -> Int and g :: Int -> Int, g.f gets broken
16:13:00 <ski> huh ?
16:13:15 <ski> there is no "functions with two inputs" .. so how can it get broken ?
16:13:53 <triteraf1ops> If more than one input were allowed, f would be a Int x Int->Int
16:14:05 <triteraf1ops> and g.f wouldn't type error, like it would in the above example
16:14:20 <ski> you can do `f :: (Int,Int) -> Int; g :: Int -> Int', and then `g . f' works just fine
16:14:39 <triteraf1ops> well, you can't do both
16:14:56 <ski> or, you could have `f :: Int -> Int -> Int; g :: (Int -> Int) -> Int', and then `g . f' also works
16:14:58 <triteraf1ops> there's now a distinction that serves no purpose except to make one kind of currying easier.
16:15:18 <ski> what is this distinction ?
16:15:31 <triteraf1ops> (Int,Int) and Int->Int
16:15:40 <dminuoso> triteraf1ops: Id say the reason haskell functions are the way they are, is academic curiosity perhaps?
16:15:45 <triteraf1ops> and you can only choose if you're defining f
16:16:02 <ski> higher-order functions serve no purpose ? tuples serve no purpose ?
16:16:32 <dminuoso> Also, I think function compose much more nicely if they are already curried in many scenarios.
16:16:56 <triteraf1ops> Well, they can only compose if there is only one input
16:17:05 <triteraf1ops> in haskell anyway
16:17:17 <triteraf1ops> without changing the functions, which you can't always do
16:18:08 <dminuoso> 01:12:19     triteraf1ops | if f :: Int -> Int -> Int and g :: Int -> Int, g.f gets broken
16:18:08 <dolio> Oh wait, I flubbed the type above. It's supposed to involve an Applicative, too.
16:18:16 <jollygood2> triteraf1ops, same distinction exists in other languages with tuple type
16:18:20 <dminuoso> If I understand you right, we can still compose.
16:18:21 <ski> triteraf1ops : i think you're talking, not so much about Haskell (the language), but about common conventions for coding in the language ?
16:18:42 <dminuoso> triteraf1ops: If you have `f :: Int -> Char -> Bool` and `g :: Float -> Char`, we can still compose them.
16:18:56 <triteraf1ops> jollygood2: while that's true, you wouldn't need a tuple in that position with languages that support more than one input in its functions
16:19:04 <dminuoso> let (.:) = (.) . (.) in f .: g
16:19:41 <triteraf1ops> well, it can be done, but is it legible? Is there a reason?
16:19:43 <dminuoso> Anyhow, the "multiple argument" vs "composition" argument sounds a bit confused.
16:19:56 <triteraf1ops> Wouldn't it be easier if functions had more than one input?
16:20:03 <dolio> Otherwise it's just the transformation version of map.
16:20:05 <dminuoso> What would be easier, exactly?
16:20:05 <jollygood2> as far as your original question, benefit of functions in haskell being curried is very light partial application syntax. function, space, argument.
16:20:21 <dminuoso> We can encode suppying multiple arguments with tuples
16:20:22 <triteraf1ops> compositions, currying, evrything really
16:20:40 <dminuoso> That's not even not right, it's not even wrong.
16:20:41 <triteraf1ops> optional arguments, named arguments
16:21:26 <dminuoso> triteraf1ops: How exactly do you get better compositionality with multiple argument functions?
16:21:33 <triteraf1ops> partial application only works if the args are already in the right order
16:21:55 <dminuoso> partial application doesn't work for multiple-argument functions at all.
16:21:58 <triteraf1ops> the first example I gave would just work without any tuples or anything
16:22:09 <triteraf1ops> dminuoso: not with that attitude lol
16:22:15 <triteraf1ops> but seriously, it's not hard to do
16:22:20 <triteraf1ops> you just need good notation for it
16:22:29 <triteraf1ops> Like I said before, mathematica's hash notation
16:22:51 <triteraf1ops> You put hashes in the arguments that aren't being filled in
16:23:08 <triteraf1ops> so f # y would equal \x->f x y
16:23:14 <dminuoso> I see
16:23:38 <ski> triteraf1ops : i don't understand "you wouldn't need a tuple in that position with languages that support more than one input in its functions"
16:24:04 <triteraf1ops> for composition
16:24:20 <ski> triteraf1ops : i would not want anything like that in Haskell
16:24:23 <wroathe> maybe there's a technical reason this can't or shouldn't be done buried somewhere in the GHC source?
16:24:25 <triteraf1ops> if f has two inputs and g has 1, g.f would just work without requiring tuples
16:24:34 <triteraf1ops> right, that's what I'm asking
16:25:02 <ski> it doesn't support equational reasoning properly
16:25:15 <triteraf1ops> ski: well, I would bet you'd say the opposite if it were already like this. There is a bias favouring the status quo.
16:25:28 <wroathe> triteraf1ops: Sounds like you should put together a proposal for the fine folks maintaining GHC. Even if it doesn't get accepted, we all might learn a thing or two
16:25:32 <triteraf1ops> equational reasoning?
16:25:44 <dolio> There are a bunch of problems with that kind of syntax.
16:25:46 <ski> if `f x y = g x (h y x)', then one'd expect `f # y' to be equal to `g # (h y #)' .. but it isn't
16:25:53 <dolio> For instance, the example is actually incorrect.
16:26:07 <ski> similarly, `f x #' would not be equal to `g x (h # x)'
16:26:19 <dolio> At least, it's usually incorrect when you actually get around to thinking the whole thing through.
16:26:19 <dminuoso> I wonder what such a syntax would do to type inference
16:27:21 <triteraf1ops> ski: yes that's true
16:27:34 <triteraf1ops> # is meant to make partial application of just one function easier
16:27:39 <triteraf1ops> lambda is for all other cases
16:28:04 <wroathe> does mathematica support equational reasoning with this syntax?
16:28:18 <triteraf1ops> It's just a different kind of reasoning
16:28:20 <ski> imho, the (reasoning) cost would higher than the utility in conciseness
16:28:22 <dminuoso> ski: Maybe Im just too tired, but why are these not equal?
16:28:37 <triteraf1ops> It is only meant for cases much like f x, given a function f x y
16:29:00 <triteraf1ops> In haskell too, when it's more complicated than f x, you need a lambda
16:29:13 <jollygood2> triteraf1ops, so you can't do something like this: map (map (*10)) xs  ?
16:29:14 <dminuoso> ohh haha
16:29:14 <ski> dminuoso : `g # (h y #)' would presumably be `\x -> g x (\x -> h y x)', while `g x (h # x)' would be `g x (\y -> h y x)'
16:29:17 <dminuoso> I already tripped into it, yeah
16:29:32 <triteraf1ops> jollygood2: no, that's still possible
16:29:44 <jollygood2> triteraf1ops, show
16:29:55 <triteraf1ops> It would just look the same as what you typed
16:30:06 <triteraf1ops> operator partial application is alraedy special cased in haskell
16:30:12 <dminuoso> triteraf1ops: Turn it into a GHC proposal, and see what the authors think. You'll have a proper audience equipped with why they designed the language the way it is. :)
16:30:15 <jollygood2> how can it look the same with # syntax
16:30:44 <triteraf1ops> dminuoso: yeah I was on my way there. I just needed to know whether I missed something obvious
16:30:52 <dminuoso> Overall, I dont think there exists a real problem to warrant this kind of syntax.
16:31:00 <triteraf1ops> jollygood2: why shouldn't it be the same?
16:31:07 <wroathe> It's quite possible there's already a proposal with some discussion around it that was rejected for some reason
16:31:18 <triteraf1ops> dminuoso: I have a feeling haskellers are just used to the status quo
16:31:25 <jollygood2> both the inner map and * are partially applied. I'm wondering how this would look in mathematica, or your proposed alternative haskell syntax
16:31:29 <triteraf1ops> people have been saying that about fucking C after all
16:31:36 <dminuoso> triteraf1ops: I rarely partially apply in the middle
16:31:44 <dminuoso> It strangely just doesnt happen often
16:31:47 <glguy> with # you need to define the scope of the #, in mathematica you use & for that
16:31:56 <triteraf1ops> You might if you could lol
16:32:01 <dminuoso> It's not like I find myself making lambdas just to partially apply in the middle, because I tend to consider parameter order
16:32:10 <dminuoso> Mmm, perhaps
16:32:10 <triteraf1ops> but actually this isn't even the best thing you can do with a different notation
16:32:20 <triteraf1ops> it would properly support named optional arguments
16:32:26 <jollygood2> triteraf1ops both the inner map and * are partially applied. I'm wondering how this would look in mathematica, or your proposed alternative haskell syntax
16:32:31 <wroathe> It would actually be fascinating to see SPJ's take on this
16:32:32 <glguy> so it would be more like: (g # (h y #)&)& -- or something like that
16:32:47 <jollygood2> glguy, I thought so.. I prefer what we already have
16:32:51 <triteraf1ops> jollygood2: whooops, I missed that
16:32:52 <glguy> I don't actually how that nesting works in Mathematica
16:33:03 <triteraf1ops> jollygood2: the inner map needs a #
16:33:15 <triteraf1ops> map (map (*10) #) xs
16:33:22 <glguy> and they let you use numbered arguments like: #1 #2 #3...
16:33:32 <triteraf1ops> It can't nest
16:33:36 <triteraf1ops> It's not supposed to
16:33:40 <glguy> so something like:  (f # #)& would have been: \x -> f x x
16:33:42 <triteraf1ops> it has to be at a leaf
16:34:08 <glguy> https://reference.wolfram.com/language/tutorial/FunctionalOperations.html#17469
16:34:43 <dminuoso> Another thing that comes to mind, is that # actually can subtly change the evaluation order of parameters.
16:34:49 <dminuoso> for instance:
16:34:50 <triteraf1ops> glguy: yeah I don't think you actually do need to define scope for #
16:34:58 <triteraf1ops> just as long as it's at a leaf
16:35:18 <wroathe> win 3
16:35:19 <triteraf1ops> evaluation order? I thought that didn't matter in haskell...
16:35:23 <jollygood2> triteraf1ops, if it can't nest, then I don't see how *10 would work. if you mean that sections would still exist, well then map (map (f 10)) wouldn't work
16:35:45 <triteraf1ops> yeah it would
16:35:51 <triteraf1ops> oh no that wouldn't 
16:35:55 <dminuoso> let f 1 _ = () in () `pseq` f undefined -- triteraf1ops 
16:35:55 <triteraf1ops> it needs modification
16:35:58 <triteraf1ops> I already modified it
16:35:59 <dminuoso> err
16:36:02 <dminuoso> let f 1 _ = () in () `pseq` f undefined # -- triteraf1ops 
16:36:06 <dminuoso> Should that error out?
16:36:08 <glguy> triteraf1ops: You'd need to be able to disambiguate:   (map (* #))& from map ( (* #)& )
16:36:18 <glguy> The & is important
16:36:30 <dminuoso> triteraf1ops: Because this will not: () `pseq` f undefined`
16:36:53 <dminuoso> That is the kind of edge case I'd really not like.
16:37:19 <triteraf1ops> you just crossed a level in the hierarchy though
16:37:38 <triteraf1ops> It doesn't need to work in cases like that. Just use a lambda if things get more complicated than that
16:37:52 <dminuoso> triteraf1ops: So the tool only applies to some of haskell?
16:38:11 <dminuoso> It either applies to all of haskell, and better respect the semantics of the rest of the language, or it can create confusion
16:38:19 <monochrom> The best of both worlds is de Bruijn numbering.
16:38:29 <triteraf1ops> so first of all, all argument have to be specified
16:38:35 <triteraf1ops> or else there would be ambiguity
16:38:51 <triteraf1ops> and any arguments that you don't want filled could get replaced with #
16:39:14 <triteraf1ops> It's not any part of an expression that can be replaced with #
16:39:20 <glguy> xx is pretty close to #; you can just write: \xx-> f xx xx, or \xx-> map (xx*)   :)
16:39:20 <triteraf1ops> only arguments of the function being curried
16:39:42 <triteraf1ops> well, that /is/ a lambda lol
16:39:43 <monochrom> Call me a right-wing WASP conservative, but I am skeptical of every ambiguous "do what I mean" syntax.
16:39:58 <dminuoso> triteraf1ops: The next annoying bit, is that without named positional arguments, this becomes a bit annoying to wield
16:40:03 <monochrom> If you're tired of naming parameters, use de Bruijn numbering.
16:40:08 <dminuoso> f # # 1 # # 'c' #
16:40:10 <dminuoso> Did I use it right?
16:40:13 <dminuoso> I dont know
16:40:25 <triteraf1ops> so that's if f has 7 args?
16:40:34 <triteraf1ops> yeah, and after, it has 5
16:41:06 <triteraf1ops> monochrom: you should be skeptical generally, but I had put some thought into this lol
16:41:30 <dminuoso> triteraf1ops: The thing is, up to 2 arguments we dont have the problem. And if you go 3+ arguments, then having these unnamed holes is annoying.
16:42:04 <dolio> I've used both sorts of syntax and Haskell is better.
16:42:11 <dminuoso> Next up I'd ask for those # holes to be namable, so you could write say `f #foo` (ignoring problems with IsLabel or MagicHash for now)
16:42:18 <triteraf1ops> interesting point, but with that many arguments, they should be named anyway
16:42:22 <dminuoso> And at that point, I might as well just write `\foo -> f foo`
16:42:42 <triteraf1ops> and remember composition is still broken
16:42:59 <triteraf1ops> fixing the number of arguments allows for their naming
16:43:10 <triteraf1ops> and rearranging for that matter, once they're named
16:43:20 <dminuoso> triteraf1ops: composition with up to two arguments works flawlessly. And with more, you tend to write functions in such a way, that the argument you need composition on is in the right spot.
16:43:42 <triteraf1ops> then how do I compose f and g as intended?
16:43:42 <glguy> Yeah, I've used this in Mathematica and just found it messy. To know how many arguments a function had I had to scan for # signs to see how big the numbers go
16:43:52 <glguy> being unnamed made the code harder to read
16:44:12 <glguy> There were just too many ways to define a pure function and no reason to pick between them
16:44:22 <triteraf1ops> when you curry in haskell, the missing parameters are also unnamed.
16:44:23 <monochrom> Or when the hamming distance between 2 names is too small.
16:44:39 <triteraf1ops> if you have f x y and you do f x, y is unnamed
16:44:56 <monochrom> actually make it (hamming distance)/(length)
16:45:14 <dminuoso> triteraf1ops: the point is, all things I *do* have to specify are named.
16:45:22 <dminuoso> f color length weight
16:45:30 <wroathe> monochrom: I'm getting this image of you grumbling to yourself in the corner while an argument rages on the other side of the room :)
16:45:30 <triteraf1ops> dminuoso: same is still true
16:45:39 <dminuoso> triteraf1ops: no because you *have* to name those # bits
16:45:42 <dminuoso> but those are unnamed
16:45:44 <monochrom> e.g., "a" and "b" are extremely distinguishable, "llIll" and "lllll" not.
16:46:01 <triteraf1ops> why do I have to name the # bits?
16:46:19 <monochrom> Yes. The other debate is pointless. :)
16:47:03 <dminuoso> triteraf1ops: The same reason you name arguments? ;)
16:47:26 <triteraf1ops> hang on, what are you trying to do exactly?
16:47:30 <dminuoso> triteraf1ops: To know what goes there. If you have a lot of unnamed argument, it gets annoying because you dont know at what argument you are.
16:47:47 <triteraf1ops> so if you have a function with 4 args and you do f x,
16:47:48 <triteraf1ops> ...
16:47:52 <dminuoso> Say assume both `f # # # 1 #` and f # # 1 # #` type check. Which one is right?
16:47:53 <triteraf1ops> the other 3 are unnamed
16:48:12 <dminuoso> If there's many unnamed holes, Ill have to start *counting* 
16:48:21 <dminuoso> And then *count* again on the function definition of f
16:48:22 <triteraf1ops> You'd have to count in any case
16:48:30 <triteraf1ops> the arguments are determined positionally
16:49:00 <dminuoso> Sure, but you'd usually name the variables you place in there accordingly
16:49:00 <triteraf1ops> to fix that, you could use named arguments, but only if you lift the restriction of only one argument allowed per function
16:49:05 <monochrom> Have you implemented an interpreter that uses your syntax?
16:49:09 <dminuoso> f wgt col len 1 Blue
16:49:13 <triteraf1ops> dminuoso: not if you just do f 1
16:49:19 <triteraf1ops> the last three are unnamed
16:49:47 <triteraf1ops> monochrom: well, I wasn't going to bother if there were a simple reason why it wouldn't work.
16:50:10 <dminuoso> triteraf1ops: You might also want to try haskell cafe perhaps beforehand.
16:50:14 <triteraf1ops> or an internal reason, that makes it easier for GHC to optimise or something if there were only one argument per function
16:50:29 <triteraf1ops> haskell café? What's that?
16:50:29 <dminuoso> Could save you from effort before making a clean and written out proposal
16:50:50 <wroathe> what's a haskell cafe? and where do I get one?
16:51:10 <triteraf1ops> yeah sounds tasty
16:51:11 <monochrom> The latter you can be assured the lambda calculus theoretical stance gets in the way. GHC totally counts arity like we humans do.
16:51:32 <jollygood2> I'm not sure this is a proposal, more like a wish that haskell was different, that functions aren't curried, and that we have this special syntax, that sometimes work, as a replacement for partial application that we get for free
16:52:17 <dminuoso> monochrom: not just ghc, the haskell report actually has a concept of multi argument functions. :)
16:52:22 <triteraf1ops> well, it only replaces the kind of partial application aided by haskell's one argument approach
16:52:26 <int-e> maybe the real problem here is having a 5 argument function in the first place
16:52:31 <triteraf1ops> but it does it well
16:52:39 <triteraf1ops> and there is more than one reason to do it
16:52:42 <int-e> (yes, it does happen easily... but it's still unfortunate)
16:52:46 <monochrom> IMO my anti-ambiguity, anti-DWIM is simple enough and reason enough to reject the deal. Plus I'll say again de Bruijn numbering exists and is better.
16:53:00 <dminuoso> It's buried deep inside the semantics of pattern matching, but `f = \pat1 -> \pat2 -> ...` and `g pat1 pat2 = ...` can be differentiated 
16:53:09 <triteraf1ops> k, so what's de bruijn numbering then?
16:53:59 <triteraf1ops> isn't every proposal a wish that haskell is different?
16:54:31 <monochrom> (\x -> f (\y -> g x y)) becomes (\ -> f (\ -> g #2 #1)) for example.  But I may be wrong about which one is #2 which one is #1.
16:54:41 <triteraf1ops> int-e: it is natural for functions to have a crazy number of arguments when it's properly supported. Just look at python
16:54:54 <triteraf1ops> like http.get()
16:55:10 <triteraf1ops> er no, requests.get()
16:56:05 <dminuoso> triteraf1ops: Different features can be represented though. If you take an option adt in which optional settings are wrapped with Maybe, then you can get away with `f defOptions{thing = Just 10}`
16:56:06 <xsperry> I prefer function taking an object instead of crazy number of arguments
16:56:15 <monochrom> "natural" as in human nature, as in bad human nature.
16:56:22 <dminuoso> This has quite a few benefits, since suddenly this large option object is a first class citizen
16:56:27 <monochrom> It is natural to be egotistic, too.
16:56:36 <dminuoso> And is not just some bizarre artifact of special semantics
16:57:15 <int-e> triteraf1ops: I was talking about Haskell though.
16:57:22 <triteraf1ops> and monochrom this arity counting thing, you're saying this is a GHC thing that aids optimisation and would be broken if functions had more than one argument?
16:57:49 <triteraf1ops> int-e: in haskell and a good many other languages, you're left with no choice for lack of the features that allow python to get a way with it
16:57:50 <int-e> triteraf1ops: Where the usual way to deal with situations where you want keyword arguments is to make a record out of them.
16:58:04 <triteraf1ops> yeah that's awful
16:58:13 <jollygood2> triteraf1ops, change it too radical to make it a practical proposal. it would turn haskell into a completely different language
16:58:14 <dminuoso> Is it
16:58:17 <triteraf1ops> a haskell record for every function it ridiculous
16:58:18 <int-e> "awful"
16:58:30 <int-e> it's an inconvenience
16:58:36 <triteraf1ops> yeah exactly, awful
16:58:36 <int-e> it's not the end of the world
16:58:44 <triteraf1ops> one inconvenience per function requiring defaults?
16:58:48 <dminuoso> I'd trade that inconvenience for Haskells type system any day of the week.
16:58:51 <triteraf1ops> that's a lot of inconveniences
16:58:55 <int-e> triteraf1ops: you might want to soften your language a bit if you want to convince people.
16:59:05 <dminuoso> My time is not gated by typing, so writing extra data types is not limiting my ability to write large programs.
16:59:16 <monochrom> The opposite. Optimization happens only when you recognize that "\x -> \y -> Ctor x y" has 2 arguments and "(\x -> \y -> Ctor x y)) 4 1" is a saturated application so that you don't bother generated the intermediate "(\y -> Ctor 4 y) 1".
16:59:21 <dminuoso> Being able to reason about my program *is* a limiting factor however.
16:59:59 <triteraf1ops> monochrom: oh, so ... um, that means this change would actually make GHC's job easier?
17:00:08 <xsperry> triteraf1ops, hopefully most of your functions aren't taking a crazy amount of arguments.. although seeing some python libraries..
17:00:29 <monochrom> I agree with "a haskell record for every function would be ridiculous".  But clearly no one is proposing a haskell record for every function.
17:00:33 <triteraf1ops> xsperry: it takes getting used to, but it makes sense. Just as long as there are sane defaults
17:00:59 <triteraf1ops> monochrom: If you're going to quote me...
17:01:13 <monochrom> No, it is trivial for GHC to count arity and recognize saturated applications.
17:01:17 <triteraf1ops> "00:01 < triteraf1ops> one inconvenience per function requiring defaults?"
17:01:35 <monochrom> Instead, even in C and Pascal, I would reject the cavalier syntax.
17:02:04 <triteraf1ops> well, that's a low bar
17:02:12 <triteraf1ops> I wouldn't advocate for any new syntax in C
17:02:17 <triteraf1ops> it should be burned to the ground
17:02:42 <monochrom> or Scheme.
17:03:12 <triteraf1ops> oh well, that's hardly a comparable circumstance. Scheme very explicitly eschews syntactic sugar
17:03:16 <jollygood2> triteraf1ops with records, you can have more than one set of options, and they can be stored, loaded, serialized, etc. so while the syntax is heavier, it offers more flexibility
17:03:27 <monochrom> Python community's reckless abuse of crazy number of default parameters can go shoot themselves.
17:03:53 <monochrom> You look at that and you wish CS school teaches cohesion again.
17:04:00 <xsperry> named arguments kind of encourage such functions
17:04:19 <triteraf1ops> monochrom: well, that's a little extreme. Python has its problems, but you shouldn't be so quick to dismiss their ideas
17:04:24 <triteraf1ops> well, at least some of them
17:04:33 <triteraf1ops> I mean yeah in balance, python is kinda bad lol
17:04:42 <monochrom> Because those crazy number of parameters with defaults are people who are fighting over a cool function name.
17:04:43 <triteraf1ops> in a lot of important ways
17:04:49 <redmp> % class Foo a where fooImpl :: Proxy a -> ()
17:04:49 <yahb> redmp: 
17:05:03 <monochrom> Everyone agrees that "get" is a cool function name. Everyone disagrees what it should do.
17:05:12 <redmp> % foo :: Foo f => f -> ()
17:05:12 <yahb> redmp: ; <interactive>:102:1: error:; * Variable not in scope: foo :: f1 -> (); * Perhaps you meant one of these: data constructor `Ghci5.Foo' (imported from Ghci5), data constructor `Ghci6.Foo' (imported from Ghci6), data constructor `Foo' (line 87)
17:05:22 <redmp> foo _ = fooImpl (Proxy :: Proxy f)
17:05:26 <redmp> % foo _ = fooImpl (Proxy :: Proxy f)
17:05:26 <yahb> redmp: ; <interactive>:103:9: error:; * No instance for (Foo a0) arising from a use of `fooImpl'; * In the expression: fooImpl (Proxy :: Proxy f); In an equation for `foo': foo _ = fooImpl (Proxy :: Proxy f)
17:05:45 <triteraf1ops> jollygood2: just as long as I can fix the namespacing issue. But there are extensions for that
17:05:48 <triteraf1ops> I know that
17:05:57 <triteraf1ops> It's not just optional arguments though.
17:05:58 <monochrom> The grosteque accord is "why not use parameters to branch out what it does so it does everything everyone wants, you just use parameters to choose?"
17:06:01 <triteraf1ops> It's composition
17:06:03 * int-e idly wonders how widely used # is as an infix operator.
17:06:21 <triteraf1ops> well, it doesn't have to be #
17:06:32 <triteraf1ops> I mean that's low hanging
17:06:44 <dminuoso> triteraf1ops: Even if the feature is considered welcome, finding a good letter is going to be problematic.
17:06:44 <triteraf1ops> also, this will definitely break existing code so yeah
17:06:56 <int-e> We don't really have any unused single character ASCII symbols left.
17:06:59 <dminuoso> # is used by MagicHash, its used by IsLabel
17:07:03 <redmp> i'd like to provide a convenience function for a class (like Foo above) which requires a proxy argument.. the convenience function should create the appropriate proxy from an example (like the foo function above)
17:07:12 <MarcelineVQ> I kinda lost the thread, what is the desired feature in the convo?
17:07:33 <triteraf1ops> allowing haskell functions to have a certain number of arguments
17:07:36 <monochrom> that "# + 2 * #" = \x y -> x + 2 * y
17:07:47 <triteraf1ops> to fix composition and some other things
17:07:58 <triteraf1ops> to allow for naming of arguments
17:08:02 <int-e> monochrom: hmm, is it that or \x -> x + (\y -> 2* y)?
17:08:06 <triteraf1ops> and optional arguments
17:08:12 <triteraf1ops> without requiring records 
17:08:33 <dolio> The feature is completely redesigning the whole syntax of Haskell and all libraries.
17:08:41 <monochrom> The compiler is telepathy so it will pick my version!
17:08:42 <triteraf1ops> not /really/
17:08:46 <triteraf1ops> just functions
17:08:51 <int-e> Honestly I don't see this making code any more readable.
17:09:09 <monochrom> It's like Perl. It makes code more writable
17:09:31 <dminuoso> int-e: the point is not readability, but being able to massage functions into the right shape for partial application. You know, sort of half-point-free.
17:09:34 <triteraf1ops> well, it fixes composition and allows for better syntax for functions with more arguments or optional arguments
17:09:44 <triteraf1ops> seems like that would aid readability and writability
17:09:51 <monochrom> As usual, programming is a dialectic class struggle between the writer and the reader.
17:09:59 <triteraf1ops> lol
17:09:59 <monochrom> My freedom is your slavery.
17:10:16 <monochrom> My convenience is your problem.
17:10:18 <int-e> dminuoso: Sounds like something to experiment with in a new language.
17:11:07 <justsomeguy> Ada strikes me a language that takes a particular idea of "readability at expense of the programmer convince" too far.
17:11:23 <int-e> Since presumably the whole ecosystem would either move to embrace this feature or not.
17:11:29 <triteraf1ops> named arguments make code hella readable just sayin
17:11:55 <dolio> A new language isn't needed. Ones that make this choice already exist.
17:12:02 <hyiltiz> Any idea how to draw this tree using fold? https://paste.tomsmeding.com/paste/FiMG7wRu
17:12:08 <dolio> Like Scala.
17:12:09 <triteraf1ops> with lazy evaluation and guarantees of purity?
17:12:16 <hyiltiz> It is just a trivial binary tree
17:12:17 <triteraf1ops> scala doesn't guarantee purity
17:12:40 <triteraf1ops> and I'm pretty sure it's not lazy
17:13:08 <hyiltiz> sorry one dash missing in the first line of the ASCII drawing
17:14:06 <triteraf1ops> not to mention maturity 
17:14:29 <triteraf1ops> I can't find any other language that is mature, guarantees purity, and is lazy
17:15:44 <triteraf1ops> erlang doesn't guarantee purity for instance
17:18:28 <triteraf1ops> also, monochrom, I wouldn't support "# + 2*#" = \x y -> x + 2*y"
17:18:40 <triteraf1ops> that really would be ambiguous as hell
17:19:09 <triteraf1ops> That would just type error as soon as you tried putting 2*# into +
17:19:31 <triteraf1ops> I would only support # as an argument to a function
17:19:41 <triteraf1ops> not to be placed anywhere in an expression
17:19:56 <monochrom> \# # -> # + 2 * # ^ #
17:20:07 <triteraf1ops> what? why?
17:20:11 <triteraf1ops> why would I ever do that?
17:20:14 <triteraf1ops> ohhhh
17:20:15 <triteraf1ops> lol
17:20:22 <triteraf1ops> no I mean as arguments to function application
17:20:27 <triteraf1ops> so ... an on
17:20:29 <triteraf1ops> *hang on
17:20:44 <triteraf1ops> (\x y -> x + 2*y) # #
17:20:45 <monochrom> Just using the scientific method to test my hypothesis.
17:20:54 <triteraf1ops> (\x y -> x + 2*y) # y
17:21:02 <triteraf1ops> ic
17:21:20 <triteraf1ops> so the example I just wrote would work
17:21:29 <triteraf1ops> but it's just an artificial example
17:21:33 <monochrom> But I had "\x y -> x + 2 * y ^ x" in mind.
17:21:33 <triteraf1ops> that's not the intention of the notation
17:21:58 <monochrom> Do you have a compiler that rejects and calls out artificial examples?
17:21:59 <triteraf1ops> oh I had assumed you just rewrote the same function
17:22:23 <triteraf1ops> ok, so 1. # must be an argument to function application
17:22:31 <int-e> has anybody mentioned implicit parameters yet?
17:22:40 <monochrom> +, *, ^ are functions
17:22:44 <triteraf1ops> 2. all arguments to a function must be specified
17:22:56 <monochrom> "\# #" has specified that.
17:22:56 <int-e> (which is a related feature that, as far as I'm aware, is hardly used)
17:23:14 <triteraf1ops> 3. # creates an argument in the new function, and all are ordered the same way
17:23:31 <triteraf1ops> \# # isn't function application
17:23:37 <monochrom> I guess I'm toasted if I want to use x twice.
17:23:50 <int-e> Related to keyword arguemnts, that is, which have come up in this discussion.
17:23:51 <monochrom> But since every argument is used exactly once...
17:23:53 <triteraf1ops> you mean \x -> f x x?
17:23:54 <triteraf1ops> yes
17:23:57 <triteraf1ops> yes you would be
17:23:58 <monochrom> Have you talked to the linear typing people?
17:24:03 <triteraf1ops> that wasn't what it was meant to replace
17:24:12 <triteraf1ops> linear typing?
17:24:18 <monochrom> Yes,
17:24:25 <triteraf1ops> no I haven't
17:24:36 <monochrom> "linear types" for the plural noun for the types.
17:25:18 <monochrom> They are enthusiastic about every argument being used exactly once. Or at most once. I forgot.
17:25:31 <triteraf1ops> oh interesting
17:25:37 <monochrom> Sounds like you have a syntax cut out for them.
17:25:48 <triteraf1ops> that would forbid data copying
17:26:03 <triteraf1ops> except like ... explicitly or something
17:26:12 <triteraf1ops> but really I am only replacing one use case
17:26:23 <triteraf1ops> all others are still supportable by lambda exactly as they are now
17:26:33 <triteraf1ops> the case I'm replacing is f x, given f x y
17:26:45 <triteraf1ops> which would look like f x #
17:26:48 <triteraf1ops> or f # y
17:27:15 <triteraf1ops> and the point of this change would be to fix composition and to allow named optional arguments
17:27:27 <monochrom> I think the general Haskell public would be thrilled if you could join force with the Linear Haskell supporters and they adopted your syntax instead of theirs.
17:27:47 <triteraf1ops> as a way of getting rid of me or as a way of ruining them?
17:27:51 <triteraf1ops> or both?
17:28:00 <monochrom> Yes.
17:28:44 <triteraf1ops> well, I'll have a look at linear haskell, but for some reason I doubt they're what I'm looking for
17:29:07 <triteraf1ops> just to make sure I understand the situation around composition though
17:29:20 <triteraf1ops> suppose f :: Int -> Int -> Int and g :: Int -> Int
17:29:37 <triteraf1ops> and I want \x y -> g (f x y)
17:30:05 <triteraf1ops> that is mathematically a composition, but only if f : Z^2 -> Z
17:30:30 <triteraf1ops> is there something I'm not understanding about composition that would allow it to work with this function?
17:31:00 <monochrom> I think when I want that composition desperately enough, I uncurry f and honour my real intention of Z^2 -> Z.
17:31:29 <triteraf1ops> you mean like what I just wrote?
17:31:29 <monochrom> But most of the time I am happy enough with that explicit "\x y -> g (f x y)".
17:31:43 <monochrom> Sometimes I can even give it a good name.
17:32:06 <redmp> how can i constructa proxy as a convenience method to call into a class requiring a proxy argument? .. i've got an example here but it doesn't typecheck https://termbin.com/0aiu
17:32:24 <monochrom> And some other times I don't even have that function. I inline it where it is actually used. It's a simple "g (f 4 3)".
17:32:58 <monochrom> and in that case sometimes I have a good name for "f 4 3" so I write "... where coolname = f 4 3"
17:33:41 <dolio> redmp: Those `a` types aren't the same in `foo`.
17:33:52 <dolio> You need ScopedTypeVariables for that.
17:33:58 <dolio> Oh, and to quantify the a.
17:34:12 <monochrom> ScopedTypeVariables and "foo :: forall a. Foo a => a -> ()"
17:34:19 <triteraf1ops> monochrom: well, we're obviously not talking about such a circumstance lol. Otherwise, of course I would just fill in the args
17:34:20 <dolio> Since you do have ScopedTypeVariables.
17:34:30 <monochrom> otherwise the different "a"s are independent as dolio said.
17:35:12 <triteraf1ops> anyway, looks like there's nothing obvious getting in the way of this idea
17:35:23 <triteraf1ops> that's what I was really checking
17:35:49 <monochrom> Oh haha, I guess you just forgot to add "forall".
17:35:54 <redmp> dolio: yeah, scopedy type variables are already there
17:36:10 <redmp> buuuut.. i thought there was alread an implicit forall a. on the function?
17:36:16 <monochrom> Add "forall" but don't do it after midnight.
17:36:34 <monochrom> Yes but different.
17:36:49 <redmp> oh.. yeah, adding that fixed it .. why?
17:36:54 <monochrom> Here is what your current code looks like to Haskell's eyes.
17:37:08 <dolio> Because read the docs on ScopedTypeVariables. :)
17:37:17 <redmp> ok, i'll go do that 
17:37:19 <monochrom> foo :: forall a. Foo a => a -> ();   foo _ = fooImpl (Proxy :: forall a. Proxy a)
17:37:25 <redmp> ahh........
17:38:16 <dolio> The extension is kind of conservative like a lot of GHC's extensions. It only kicks in if you do something that wouldn't have been legal without the extension.
17:38:22 <monochrom> or rather s/forall/IAddForallForYouButItsDifferent/
17:38:50 <monochrom> actually s/that/implicitforall/
17:38:58 <triteraf1ops> It has just occurred to me that (.) would not have a well-defined type, if I used my method...
17:39:27 <triteraf1ops> maybe the thing to do is effectively force the inputs to be in a tuple
17:39:27 <redmp> ok, that makes sense; and i've got the docs so i'll read through.. quick question though: it seems you can do a similar trick to construct a proxy in a typeclass instance without needing to add the explicit forall ... maybe this is explained in the docs
17:39:45 <ski> triteraf1ops : "It is only meant for cases much like f x, given a function f x y" -- yes. iow, it doesn't scale, doesn't compose properly. i'd rather be without it
17:39:52 <ski> "with # you need to define the scope of the #" -- yes, exactly
17:39:55 <triteraf1ops> so that any function input type signature could be referred to as a single variable
17:40:02 <ski> "It can't nest","It's not supposed to","it has to be at a leaf" -- then i don't want it. i want compositionality, equational reasoning
17:40:12 <ski> "It either applies to all of haskell, and better respect the semantics of the rest of the language, or it can create confusion" -- yes
17:40:20 <ski> "well, it fixes composition and allows for better syntax for functions with more arguments or optional arguments" -- i disagree that there's anything to fix, and disagree that it would be better. imho, it'd be worse
17:40:44 <hyiltiz> Now with my non-fold implementation but still looking for a fold one: https://paste.tomsmeding.com/paste/pvXHfeID
17:40:45 <ski> (and yes, this topic has come up, several times, in the past)
17:40:55 <int-e> ski++
17:41:24 <monochrom> Because you transit from n to n+1, you don't have a direct foldr.
17:41:41 * ski twiches
17:41:56 <triteraf1ops> so you think named optional arguments just exist for no reason as a popular language feature?
17:42:16 <ski> Ocaml has named optional parameters
17:42:20 <hyiltiz> I could accumulate that `blank` implicitly as part of the fold result (maybe part of a tuple)?
17:42:27 <int-e> > let f = ?x in let ?x = 42 in f
17:42:29 <lambdabot>  error:
17:42:29 <lambdabot>      • Couldn't match expected type ‘p’
17:42:29 <lambdabot>                    with actual type ‘forall t. (?x::t) => t’
17:42:37 <triteraf1ops> ski: is it lazy? purely functional?
17:42:39 <ski> something like its design might work, in Haskell too, if one really wanted to
17:42:39 <triteraf1ops> no, and no
17:42:59 <monochrom> Yes, you can always make a foldr but the list is different from the original
17:43:04 <int-e> > let f = ?x ::Int in let ?x = 42 in f
17:43:06 <lambdabot>  42
17:43:07 <ski> i don't really see how non-strictness, or purity, factors in here
17:43:21 <triteraf1ops> I've seen implementations of named optional args in native haskell. They're pretty awful, really.
17:43:34 <ski> (maybe purity could, with eta-conversion, lambda-lifting, &c.)
17:43:34 <triteraf1ops> and it still doesn't fix the composition problem
17:43:56 <triteraf1ops> there is no enforcement
17:44:05 <triteraf1ops> with no enforcement, there are no guarantees
17:44:16 <triteraf1ops> mutation can happen at any time
17:44:21 <ski> and yes, i'd agree that having lightweight records (meaning record types that you don't have to declare, like for tuple types) could be nice
17:44:26 <hyiltiz> monochrom: so are you suggesting something like making a ZipList instance then folding over that?
17:44:47 <ski> (you can play around with TRex in Hugs, if you'd like)
17:44:59 <monochrom> Just zip. You don't need ZipList.
17:45:00 <triteraf1ops> yeah I had a look at it
17:45:09 <triteraf1ops> if GHC can't do it, it doesn't exist to me
17:45:40 <hyiltiz> or zip, sure. The holes to fill with that zip probably is gonna be ugly compared to this direct implementation without zip or foldr tho it feels like 
17:45:43 <hyiltiz> anyway lemme try
17:45:54 <triteraf1ops> ski: purity has nothing to do with this particular language feature. It's just that haskell is the only language I've seen that has both
17:45:55 <ski> the existing record syntax in Haskell has always striked me as being ugly
17:46:33 <triteraf1ops> I might use a different language except that haskell has these features, which I value greatly
17:46:36 <ski> triteraf1ops : my point was not "go use OCaml". my point was that if you want named optional parameters, perhaps check out how OCaml did it
17:46:39 <redmp> dolio: monochrom: ok, i read the docs on the ScopedTypeVariables extension, but it doesn't state that the scope is different for functions vs typeclasses/instances
17:46:46 <triteraf1ops> ski: ohhh lol
17:46:57 <triteraf1ops> yeah that's not how most people mean it when they say something like that
17:47:12 <triteraf1ops> but it still doesn't fix composition
17:47:21 <triteraf1ops> I mean having lightweight records
17:47:21 <dolio> I don't think ScopedTypeVariables has anything to do with type classes.
17:47:23 <ski> i fail to see what needs to be fixed
17:47:28 <triteraf1ops> thought that would be an enormous improvement
17:47:40 <triteraf1ops> the example I gave above with f and g
17:47:40 <redmp> dolio: hold on, i'll make a repro
17:47:50 <triteraf1ops> if you want \x y -> g (f x y)
17:48:18 <triteraf1ops> that's a composition mathematically
17:48:22 <triteraf1ops> but g.f fails
17:48:25 <triteraf1ops> type error
17:48:36 <triteraf1ops> because haskell thinks you're jamming a function into g
17:48:40 <triteraf1ops> which you are really lol
17:48:49 <ski> i don't understand what you mean by "that's a composition mathematically"
17:49:05 <ski> you'd run into exactly the same issue, in math
17:49:12 <triteraf1ops> as in mathematically it works, when f's inputs are grouped
17:49:27 <ski> mathematically, it doesn't work
17:49:32 <triteraf1ops> you'd absolutely never define f in math as Z->Z->Z
17:49:40 <triteraf1ops> it would be Z^@->Z
17:49:42 <triteraf1ops> oops
17:49:45 <triteraf1ops> Z^2->Z
17:49:58 <redmp> dolio: here's an example which does the same thing as my previous example, but calls the target class method from another class's instance https://termbin.com/3m32
17:50:18 <Axman6> @pl \x y -> g (f x y)
17:50:18 <lambdabot> (g .) . f
17:50:25 <Axman6> clear as mud
17:50:30 <redmp> so it seems you need the explicit forall in a top level function, but you don't need the explict forall in a typeclass method
17:50:30 <triteraf1ops> oh, there is a way to do it
17:50:35 <dolio> redmp: That's because `a` scopes over the whole body of the instance, even without ScopedTypeVariables, I think.
17:50:41 <int-e> math doesn't have an extra bottom value in Z^2 either that may mess things up
17:50:59 <dolio> That's probably Haskell2010 behavior.
17:51:17 <triteraf1ops> still, Axman6 hard to read
17:51:26 <ski> ⌜x ↦ (y ↦ g(f(x)(y)))⌝ is not ⌜g ∘ f⌝, given ⌜f : ℤ → ℤ^ℤ⌝ and ⌜g : ℤ → ℤ⌝
17:51:42 <redmp> dolio: if i removed the scoped type variables extension form the example it no longer typechecks
17:51:50 <dolio> Hmm, interesting.
17:51:54 <triteraf1ops> wth, f isn't a Z-> Z^Z
17:51:58 <redmp> dolio: it gives an error indicating that the type variables are distinct
17:52:04 <ski> "you'd absolutely never define f in math as Z->Z->Z" -- false
17:52:08 <Axman6> I'm pretty sure there's a library which defines a muhc of composition operators, I remember there being (.:) :: (c -> d) -> (a -> b -> d) -> a -> b -> d, (.:.) :: ...  etc
17:52:16 <dolio> Well, you can't put a forall in the instance head, so that'd have to be a separate case.
17:52:36 <ski> you're talking about common conventions, triteraf1ops. not about what is expressible
17:52:37 <triteraf1ops> ski: I've been doing math in an academic setting for years and haven't come across such a function
17:52:44 <redmp> dolio: oh.. hmm. ok
17:52:45 <triteraf1ops> yeah exactly
17:52:47 <dolio> I mean, there's another extension that allows you to put foralls in, but I don't think you can get it to mean what that instance does.
17:52:48 <triteraf1ops> common conventions
17:52:56 <triteraf1ops> what you think they don't count?
17:52:56 <Axman6> https://hackage.haskell.org/package/composition-1.0.2.1/docs/Data-Composition.html
17:53:39 <ski> of course they count. but you can't only consider what's in the mainstream conventions
17:53:56 <triteraf1ops> yes I definitely can
17:54:17 <Axman6> how unprogressive
17:54:24 <triteraf1ops> at least when it comes to what should be easy to express and what should be difficult
17:54:31 <int-e> "There are just two kinds of programming languages: the ones everybody complains about and the ones nobody uses." - Stroustrup, apparently, of all people.
17:54:47 <Axman6> ha
17:54:53 <Axman6> pretty sure C++ is both
17:54:54 <ski> Axman6 : you probably mean `(.::)' for the latter
17:55:00 <triteraf1ops> and he uses that idea to justify some truly horrendous shit, so thanks for the support int-e lol
17:55:09 <int-e> In context, I'm sure everyone of us has a pet peeve about Haskell that we grudgingly accept because overall it's a pretty good language.
17:55:19 <triteraf1ops> it could be better
17:55:23 <Axman6> ski: hmm?
17:55:42 <ski> (in place of `(.:.)')
17:55:44 <monochrom> int-e: I wouldn't say that's wrong. I still use Haskell, and I still complain a bit about it. :)
17:56:10 <monochrom> I also complain about Dependent Haskell and refuse to use it. There! :)
17:56:20 <triteraf1ops> lol, nice
17:56:21 <Axman6> ski: I just menat the pattern continues with (.::) :: (d -> e) -> (a -> a1 -> b -> c -> d) -> a -> a1 -> b -> c -> e 
17:56:40 <ski> that'd be `(.:::)', Axman6
17:56:41 <Axman6> monochrom: it'll have to learn to live on its own one day!
17:56:48 <Axman6> ski: https://hackage.haskell.org/package/composition-1.0.2.1/docs/Data-Composition.html
17:56:57 <int-e> triteraf1ops: But it's an established language with a large number of users. Changing it comes with a cost. You have to demonstrate that that cost is outweighed by the improvement, not just in your own personal view, but for most of the users.
17:57:11 <ski> (i invented the names `(.:)',`(.::)',`(.:::)' long ago ..)
17:57:21 <triteraf1ops> well, you'd never get approval to change a language from established users
17:57:27 <triteraf1ops> only from new users
17:57:29 <Graypup_> how can I get a canonicalized URL for a Yesod route? e.g. I have some thingyR and I want to get http://localhost:3000/thingy
17:57:30 <ski> i see, Axman6
17:57:47 <triteraf1ops> and it doesn't have to apply to all of haskell, necessarily
17:57:53 <triteraf1ops> if there
17:58:12 <triteraf1ops> s a simple conversion, then you could have it as an alternative syntax, for which there are precedents
17:58:43 <Axman6> triteraf1ops: what are you proposing we change? it sounds like you want to break our very well designed and understood type system just for some syntactic nicities which would break a lot of other thigns
17:58:46 <monochrom> I complain about implicit forall in Haskell.
17:58:50 <redmp> dolio: monochrom: i've summarized what you explained here: https://termbin.com/87ba thanks for your help
17:59:20 <triteraf1ops> Axman6: well, if change == break then yes break lol
17:59:31 <triteraf1ops> I pity the person for whom change == break
17:59:36 <ski> Axman6 : the idea was that in e.g. `(.::) = (.) . (.) . (.)', there's the same number of dots, on both sides. and the length of `.::' tells you how many parameters are "forwarded"
17:59:39 <Axman6> why should we change it just for you?
17:59:52 <triteraf1ops> because that "you" is a plural
17:59:55 <monochrom> No, triteraf1ops, I disagree with the person who conflate different == better.
17:59:57 <Axman6> is it?
18:00:09 <Axman6> who else is there?
18:00:24 <ski> Axman6 : the same discussion has come up, several timmes, in the past, in here
18:00:26 <triteraf1ops> people who have come to greatly value certain conveniences available in many langauges and absent in haskell, thus passing it over
18:00:34 <monochrom> So yes we've got an impasse. I'm a conservative.
18:00:35 <ski> (maybe three times, or so, that i can recall)
18:00:45 <triteraf1ops> The fact this keeps coming up proves my point
18:00:48 <monochrom> The two of us are now sworn enemies.
18:00:50 <int-e> monochrom: I quoted that because I remembered the quote and largely agree with it.
18:00:53 <triteraf1ops> lol
18:00:59 <monochrom> I call you rebel, you call be reactionary.
18:01:05 <int-e> monochrom: I didn't remember who said it. :P
18:01:25 <triteraf1ops> anyway, axman
18:01:43 <triteraf1ops> what I want, Axman6, is a way to fix composition and add named optional arguments
18:02:01 <triteraf1ops> both of which can be fixed by allowing haskell functions to have more than one argument
18:02:02 <c_wraith> you lose so many good properties of Haskell by doing that
18:02:12 <hyiltiz> https://paste.tomsmeding.com/paste/15W1dlWJ How do I translate `concat . map` into a foldr?
18:02:17 <triteraf1ops> well, I can think of one, for which I already found a fix
18:02:21 <hyiltiz> Seems awfully like foldMap vs. foldr stuff
18:02:22 <triteraf1ops> partial application
18:02:27 <triteraf1ops> that's pretty much it
18:02:34 <c_wraith> nah, principle typing is really important
18:02:41 <triteraf1ops> principle typing?
18:02:48 <int-e> > fix error
18:02:50 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
18:02:57 <int-e> (overuse of "fix" detected)
18:03:00 <triteraf1ops> so, functions that should be equivalent are equivalent?
18:03:18 <dolio> How is changing things to be more like Python's syntax not the conservative position?
18:04:03 <triteraf1ops> like if you force functions to have only one argument, there can't be a difference between a->b->c and axb->c, more or less
18:04:06 <triteraf1ops> ?
18:04:08 <redmp> triteraf1ops: can you explain your feature idea? it's been partially explained since i logged in, but i don't really follow .. "< triteraf1> (\x y -> x + 2*y) # #" what would this syntax mean?
18:04:27 <c_wraith> principle typing is the idea that every definition has a single most-general type.  GHC does break that sometimes, like with RankNTypes, but it's an important part of the inference algorithm (and why higher-rank types aren't inferred)
18:04:43 <triteraf1ops> right so first of all, 0. all arguments of a function must be filled in application
18:04:44 <Axman6> those two are isomorphic, but not the same, and the difference matters
18:04:56 <triteraf1ops> 1. some function arguments can be filled with #, leaving them unapplied
18:05:07 <triteraf1ops> 2. the resulting function is a function in the #s, in order
18:05:08 <ski> triteraf1ops : anyway, relevant to the perceived issue is that Haskell (and many treatments of math) doesn't have a concept of "multiple-argument function". but even with that, i don't think it'd be better. (i guess one could try de Bruijn ..)
18:05:18 <Axman6> so you want _ syntax from other languages
18:05:23 <redmp> triteraf1ops: this syntax exists in the language clojure
18:05:47 <triteraf1ops> well, good there's a precedent
18:05:49 <Axman6> I quite like Swift's lambda syntax
18:06:05 <ski> redmp : and in a Scheme library
18:06:05 <triteraf1ops> but clojure doesn't have guarantees of purity and lazy evaluation
18:06:13 <triteraf1ops> in fact, no other language does
18:06:14 <Axman6> but we don't have it because we already have a very lightweight lambda syntax
18:06:28 <triteraf1ops> that lambda syntax is pretty good
18:06:31 <Axman6> "No other language does" is definitely not true
18:06:36 <triteraf1ops> and it would work by itself
18:06:37 <jollygood2> the more interesting part of triteraf1ops proposal, is that instead of `\x y -> g (f x y)'  g . f would work
18:06:47 * ski . o O ( Clean )
18:06:59 <triteraf1ops> but I wanted something of comparably simplicity to something like f x, given f x y z
18:07:04 <redmp> triteraf1ops: i think you should try to implement this syntax using template haskell, if possible
18:07:14 <ski> jollygood2 : i still don't understand how triteraf1ops meant for that to work
18:07:29 <Axman6> what is the type of (.) if we allow that?
18:07:33 <int-e> jollygood2: But g . f already stands for \x -> g (f x).
18:07:45 <int-e> jollygood2: That part is a pipe dream, it can't happen.
18:07:49 <Axman6> it's got to have two types now
18:07:52 <jollygood2> it would work in current haskell, if all functions took tuples
18:07:55 <jollygood2> as far as I can see
18:08:00 <jollygood2> but then we lose partial application
18:08:03 <Axman6> I'm sure it can probably be done with type classes, a la printf
18:08:08 <triteraf1ops> Axman6: yeah, that's a problem
18:08:08 <triteraf1ops> lol
18:08:18 <redmp> yeah, but infererence around it would make using it a pain
18:08:31 <int-e> Axman6: Not without a lot of pain.
18:08:32 <triteraf1ops> I think the easiest thing to do is force tuples in the input of functions, logically
18:08:35 <ski> jollygood2 : .. although, i suspect they didn't mean for it to work, it only being a part of the frustration what would presumably be, at least partially, addressed in another way, with the proposed new syntax
18:08:40 <redmp> i prefer the idea that people expressed above for explicit arities in a family of composition operators
18:08:48 <Axman6> triteraf1ops: the most problematic thing with what you're proposing is that that it requires a change to the language, when it definitely doesn't, it can be implemented in the language
18:09:11 <redmp> ^
18:09:46 <ski> triteraf1ops : you can't force people to think and express themselves in a particular way, without restricting the language to forbid that expression
18:09:51 <triteraf1ops> I mean really, you can just forget the # notation if you think lambdas are good enough
18:09:58 <int-e> redmp: the ., .:, .:: thing that some people like basically does that... encode the arity in the operator
18:10:45 <triteraf1ops> the type sig of (.) is one thing to think about
18:10:57 <triteraf1ops> figuring out how that would still work
18:10:58 <Axman6> what should it be?
18:11:04 <int-e> triteraf1ops: That's only true until I want to read somebody else's code who disagrees.
18:11:07 <triteraf1ops> yeah that's waht I have to think about
18:11:22 <redmp> int-e: yeah, that's what i was thinking about .. triteraf1ops take a look at https://hoogle.haskell.org/?hoogle=%28c+-%3E+d%29+-%3E+%28a-%3E+b+-%3E+c%29+-%3E+a+-%3E+b+-%3E+d&scope=set%3Astackage
18:11:34 <ski> i'm not sure i've ever used `.::', in real code ..
18:11:38 <ski> (.. and i invented it)
18:11:42 <Axman6> there _is_ an answer to that by the way, you can come up with a type for (.) that allows arbitrary arity functions as the second argument
18:11:58 <redmp> ski: really? hah.
18:12:37 <triteraf1ops> anyway, I have to think about this later.
18:12:40 <redmp> Axman6: problem is that you only ever need this at the end of a long string of compositions.. so it seems like a silly extension.. 
18:12:45 <triteraf1ops> This is a good start
18:12:46 <ski> redmp : i've never bothered to make a package for those operators. just mentioned them, now and then, on here
18:12:53 <triteraf1ops> I wasn't banned, so that's a really good start
18:12:53 <triteraf1ops> lol
18:13:11 <Axman6> why would we ban you? you were in need of education ;)
18:13:27 <redmp> ski: somebody made a package https://hackage.haskell.org/package/composition-1.0.2.1/docs/Data-Composition.html
18:13:31 <redmp> the hoogle link has more
18:13:38 <triteraf1ops> Axman6: don't patronise me srsly
18:13:39 <int-e> and on topic and polite... even if you're wrong ;-)
18:13:42 <ski> redmp : i've seen some of them defined, in several packages, over the years
18:13:51 <Axman6> I've linked to that package twice in this conversation already ;)
18:13:55 <triteraf1ops> I'm not wrong about the facts
18:14:05 <ski> redmp : .. and apparently the author of that one package got the naming convention wrong (or, i guess decided to change it)
18:14:07 <triteraf1ops> what, data-composition?
18:14:12 <triteraf1ops> yeah that way lies madness
18:14:19 <redmp> Axman6: lol, sorry, i was focused on solving my own problem and didn't pay attention until just a minute ago
18:14:52 <Axman6> triteraf1ops: you're patronising us by assuming you know the language we use daily better than we do, you've shown you don't have the basic background to make the argument for what you want
18:14:55 <redmp> ski: chaotic neutral
18:15:23 <Axman6> so yes, you are in need of education
18:15:31 <triteraf1ops> I'm not making any assumptions about your knowledge of the language
18:15:35 <redmp> we are all in need of an education :)
18:15:38 <triteraf1ops> if anything, I assume the opposite
18:15:48 <ski> redmp : heh ? :)
18:15:56 <triteraf1ops> if I didn't think I'd learn anythin from you, I would hardly have shown up here.
18:16:51 <Axman6> "We should change the language because FACTS that I learnt while doing MATHS" isn't exactly an inviting way to have a conversation
18:17:27 <triteraf1ops> I don't recall speaking those words lol
18:17:50 <triteraf1ops> this strawmanning is a little ridiculous
18:17:51 <hyiltiz> Got it: https://paste.tomsmeding.com/paste/pBJ0Zmt7 BTW thx everyone for ignoring my noob question and continue the heated discussion about python vs haskell aka variable function argument with defaults vs. record syntax (that is what it seemed like on a glance anyways)
18:18:17 <ski> redmp : may have been back in 2004 or something. i don't recall
18:18:49 <redmp> it's probably still on hackage somewhere
18:18:55 <hyiltiz> Oh this https://paste.tomsmeding.com/paste/4VLzNFlw
18:19:05 <ski> what's, redmp ?
18:19:26 <Axman6> hyiltiz: nice work - type holes can be super helpful for solving those problems - if you know the type, you can just say concatMap :: (a -> [b]) -> [a] -> [b]; concatMap f xs = foldr _f _z xs and start filling in the blanks
18:19:50 <redmp> err.. i thought you referring to: and apparently the author of that one package got the naming convention wrong (or, i guess decided to change it)
18:20:23 <ski> redmp : er, sorry. i meant when i invented those operators
18:21:10 <redmp> oh, lol..
18:21:43 <triteraf1ops> Also, and this is important, it is your familiarity with the language that allows you to make concessions newcomers would never make
18:21:59 <Axman6> absolutely
18:22:53 <redmp> at the same time, the driving force behind me learning haskell and PL is because i want to make a _better_ language some day (though, as a newb, i must admit that day may never come)
18:23:05 <Axman6> I'm pretty unfamilliar with Scala, and it bites me every time I use it. I just start out by saying we should change the language, I start out by asking if there's a way to do what I want (in scala the answer is often no and I cry)
18:23:23 <Axman6> I don't start out*
18:24:05 <ski> redmp : it'll probably better make you (as in all of us) understand concepts, and tradeoffs, anyway
18:24:21 <triteraf1ops> yeah I already know there isn't a way to get something like named optional arguments without changing the way haskell's functions are built. At least the full solution
18:24:24 <Axman6> I definitely don't start out by saying "Hey I know lots of maths, so we should change things so things are more familliar to me, with my limited knowlkedge of some maths, which isn't the maths you use when designing features of the language". Like, Haskell without currying? 
18:24:36 <triteraf1ops> a partial solution, which I think is pretty good, is allowing anonymous records
18:25:00 <triteraf1ops> It doesn't fix composition
18:25:31 <triteraf1ops> also, haskell is the only language I know of that has functions like it does
18:25:39 <triteraf1ops> It's pretty clear to me it's not a requirement
18:25:40 <triteraf1ops> lol
18:25:54 <Axman6> I just had this argument on reddit with someone who insisted that no one _actually_ uses currying in haskell, like what a ridiculous thing to claim. Also apparently Haskell isn't a _real_ language because we don't have primitive types for UI widgets and movie assets. it was quite a hilarious discussion
18:25:57 <redmp> ski: yeah, what i'm realizing slowly is that the depth of GHC's typesystem is not something i'm prepared to tackle up front, and if i were to make something the novelty must be in choice of foundational features; i can't compete on the type-system level
18:26:11 <triteraf1ops> ok yeah that's bad lol
18:26:15 <Axman6> triteraf1ops: then you don't know many languages
18:26:19 <ski> hyiltiz : `map (\(x,y) -> ..x..y..) (zip xs ys)' is `zipWith (\x y -> ..x..y..) xs ys'
18:26:54 <Axman6> there are plenty of languages that support currying, several have it as the conventional way to define them
18:26:55 <notzmv> Axman6: what other languages do this? (geniunely curious)
18:27:03 <triteraf1ops> There might be others, but that's not the point
18:27:07 <ski> triteraf1ops : again, you seem to more be talking about Haskell conventions, rather than the Haskell language
18:27:08 <triteraf1ops> It's clearly not a requirement
18:27:14 <Graypup_> currying? f# nix ml, the list goes on
18:27:24 <triteraf1ops> the brokenness of composition is not a convention
18:27:32 <int-e> it's not broken
18:27:33 <Graypup_> smh y'
18:27:38 <triteraf1ops> not currying
18:27:39 <ski> (but yea, light-weight records might be quite nice)
18:27:42 <Axman6> it's not broken, it's very well, mathematically, defined
18:27:44 <triteraf1ops> functions with only one argument
18:27:46 <notzmv> thought so, imagined it was a common ML family trait, thanks :)
18:27:55 <triteraf1ops> and I wouldn't want to get rid of currying
18:27:58 <triteraf1ops> it is useful
18:28:00 <Graypup_> I didn't think haskell was an ML
18:28:10 <Axman6> ML inspired in many ways
18:28:12 <redmp> i thought it was a lisp that ditched parens
18:28:17 <Graypup_> lmao
18:28:21 <notzmv> Graypup_: I didn't mean that it is :p
18:28:26 <Graypup_> but lisps are usually not statically typed
18:28:42 <ski> redmp : well, keep struggling, keep learning, and keep having fun ! :)
18:28:50 <redmp> ski: thank you
18:28:52 <Axman6> triteraf1ops: we don't have broken composition, we have a very powerful tool for not needing to bake something more into the language: functions
18:29:19 <triteraf1ops> Well, not generally broken under all circumstances, and I don't mean unusable
18:29:27 <triteraf1ops> but broken under some circumstances, definitely
18:29:50 <Axman6> all languages are broken under some circumstances. where's my currying in C?
18:30:12 <triteraf1ops> yeah we're not putting currying in C
18:30:22 <triteraf1ops> we're putting named optional arguments in haskell
18:30:27 <Graypup_> I will say, as someone from other languages, it is annoying (and I am almost certain I am missing something) that the purity means that it's a lot harder to do dependency injection since if you need something in a higher monad you're basically hosed unless you write it to be generic?
18:30:28 <triteraf1ops> I know enough not to bother changing C
18:30:29 <Axman6> where's my higher order abstractions in... basically any language?
18:30:39 <triteraf1ops> This is actually still a small issue
18:30:45 <ski> universal and existential quantification could be nice, in C
18:30:48 <triteraf1ops> haskell is much larger than this issue
18:30:58 <triteraf1ops> and almost all of it is pretty fucking awesome
18:31:01 <dolio> The proposal isn't even mathematical in origin.
18:31:01 <triteraf1ops> C is a car fire
18:31:13 <triteraf1ops> I would not improve it without changing the entire thing fundamentally
18:31:28 <ski> (but i guess that's Rust .. although, last i checked, they don't have full existentials, just the "OO" thing (cf. ADTs))
18:31:29 <Graypup_> anyway, do I have to reverse engineer yesod to figure out how to get an approot relative path or does anyone know how to get one without doing that
18:31:40 <Axman6> records can be used to give you named optional arguments in Haskell, we define services with a single arugment which is a record of its dependencies so we can update just the changes we need form the defaults
18:31:41 <Graypup_> ski, i think you are correct
18:32:20 <triteraf1ops> Axman6: man, it's really not great, though. Anonymous records, trex style would be so much nicer
18:32:32 <triteraf1ops> that would be a pretty good fix for named optional args
18:32:38 <triteraf1ops> wouldn't fix composition though
18:32:39 <Axman6> (Technically this is in DAML, but that's just Haskell++ (and optimisations-- currently)
18:32:41 <Graypup_> triteraf1ops, in no other language can I write shellcode that has inline assembly that needs to steal variables out of the caller's stack frame and be confident it will work ^^
18:32:41 <ski> Graypup_ : yes, it can certainly be annoying. istr Peter van Roy talking a little bit about that, in CTM
18:32:55 <Axman6> )
18:33:20 <Graypup_> I write my non-malicious code in rust though
18:33:21 <Graypup_> lol
18:33:43 <triteraf1ops> Graypup_: you talking about C?
18:33:46 <Graypup_> yeah
18:33:54 <Axman6> I don't have an issue with anonymous records, we have several implementations of those. default arguments is another issue, it would break things substantially I think
18:33:56 <Graypup_> just last weekend I did the thing described
18:34:03 <triteraf1ops> I'm pretty sure you can do such fuckery with rust
18:34:06 <tabemann> there is one other language you can do that - Forth
18:34:22 <Graypup_> yeah I have less confidence about the compiler not messing it up since it is **definitely** UB
18:34:44 <triteraf1ops> well, there are calling convention decorators, aren't there?
18:34:55 <Graypup_> although it would be really fun to write that kinda thing in rust, maybe I should figure out how to hook up my linker script. but that's very OT
18:35:12 <triteraf1ops> lol yeah ...
18:35:25 <ski> yea. i'm not convinced about default/optional parameters. named parameters (as opposed to just a light-weight record) could be okay
18:35:32 <tabemann> of course Forth is basically the love child of assembly and Lisp
18:36:02 <Graypup_> also, something that annoys me about haskell (or maybe moreso haddock) which is that it doesn't show parameter names so I often have to read the source
18:36:18 <triteraf1ops> ski: well, look at python's http requests library for a good example of named optional arguments
18:36:23 <Graypup_> and to be clear I know why that is, which is that people write stuff in a style omitting some of their parameter names, but it's still annoying that those which are there aren't shown
18:36:24 <triteraf1ops> that library is very awesome to use
18:36:30 <triteraf1ops> It does the obvious thing
18:36:37 <triteraf1ops> It just does it. It's so great.
18:36:55 <triteraf1ops> The reviews are pretty funny too
18:37:00 <Axman6> https://hackage.haskell.org/package/wreq-0.5.3.2/docs/Network-Wreq.html
18:37:12 <triteraf1ops> One guy said he'd find a way to tattoo the entire thing on himself. Somehow.
18:37:34 <dolio> You don't need to know the parameter names used by the function definition to call the function.
18:37:36 <triteraf1ops> ah, ok, this is actually a good example
18:37:38 <tabemann> I remember the days when people were tattooing the source code of DeCSS on themselves
18:37:39 <ski> Graypup_ : yea :/ .. i guess named parameters might help, there
18:37:41 <triteraf1ops> we'll see how haskell does this thing
18:38:58 <Axman6> wreq is not my library of choice for HTTP requests, but it is good for quick and dirty stuff like you'd do in python
18:39:24 <triteraf1ops> lol, for real though, python is excellent for the quick and the dirty
18:39:37 <Axman6> servant and servant-client are so much nicer to use (at least with sane APIs, I've come across some pretty bonkers ones)
18:39:53 <triteraf1ops> but this particular pattern, of requests.get(), I don't see how that couldn't be applied in more important code
18:40:34 * ski . o O ( <https://www.netmeister.org/blog/images/dijkstra-quick-n-dirty.jpg> )
18:40:48 <triteraf1ops> dolio: I would not call a function without knowing its parameter names
18:40:49 <Graypup_> dolio, ok, what does getUser :: Bool -> Text -> IO User take as its first parameter
18:41:06 <Graypup_> like the second one is the ID or username or smth, but what the heck is the bool? who knows
18:41:21 <monochrom> wroathe: I hope you see now my grumbling is at least less counterproductive than the other debate, and at least I know when to stop. :)
18:41:28 <Graypup_> sure you can put it in the haddock but nobody does, it seems like the documentation culture in haskell land is not great
18:41:44 <dolio> Graypup_: Haddock lets you document the purpose of each argument to the function.
18:41:56 <ski> monochrom : your grumbling is welcome :)
18:42:10 <monochrom> I have to make an exam question.
18:42:11 <Graypup_> dolio, but, again, it's not often done
18:42:44 <monochrom> You'll enjoy my grumbling again when I have to mark the answers!
18:43:05 <tabemann> I'm personally a Forth fan, but I still turn to Python when I need to hack together a script to do something quickly
18:43:23 <Graypup_> same, python is just so quick, especially with ipython
18:43:49 <ski> monochrom : "Problem : Design a syntax extension to fix composition of multiple-arity functions in Haskell. Argue for how your extension is a fix."
18:44:57 <dolio> Then it seems like the problem is that people aren't documenting their functions, not that the documentation doesn't include the alpha-renamable argument names.
18:45:19 * hackage language-dickinson 1.3.0.1 - A language for generative literature  https://hackage.haskell.org/package/language-dickinson-1.3.0.1 (vmchale)
18:45:24 <Graypup_> dolio, that does not fix the problem? including the function names if present would help in the community of today
18:45:57 <tabemann> it's just that languages with named arguments force the programmer to provide a minute amount of documentation, but not as much as if they actually documented every argument descriptively
18:46:26 <Graypup_> tabemann, yeah, then the same programmers go to Haskell and do the same thing and our documentation tools don't list em lmao
18:47:07 <dolio> Okay, the names are `b` and `t`.
18:47:13 <tabemann> lol
18:47:31 <tabemann> I love Haskell argument names :D
18:47:46 <Graypup_> dolio, typical, which is what I have to deal with when I am reverse engineering yesod code because it's easier than figuring out the docs (smh)
18:48:36 <triteraf1ops> you know, b and t are at least something lol
18:48:45 <monochrom> A more special-purpose function warrants more specific argument names. A more general-purpose function warrants more blanket argument names.
18:49:00 <triteraf1ops> there's less chance for confusion if you had to specify b= and t= in the function application
18:49:16 <triteraf1ops> assuming they were the same type and might get mixed
18:49:20 <monochrom> People from elsewhere complain about our single-letter math argument names because they have never seen parametric polymorphic functions before.
18:49:38 <Graypup_> or ... perhaps because it is actually confusing lmao
18:49:44 <triteraf1ops> Sometimes, I've thought about what would happen if all arguments had to be named
18:49:55 <dolio> Well, it's great to say that, but I don't have confidence that the people who can't write haddock explaining the function arguments are going to be super dedicated about clear variable names.
18:50:00 <triteraf1ops> 'cause man, I've been bitten by some /bad/ argument swapping bugs
18:50:06 <triteraf1ops> mostly source and dest
18:50:20 <triteraf1ops> which get switched all the time in the god damned C standard library
18:50:21 <Graypup_> you could also ... newtype your swappable args
18:50:27 <triteraf1ops> like memcpy(dst, src)
18:50:28 <Graypup_> just sayin
18:50:31 <triteraf1ops> my brain
18:50:51 <Graypup_> memcpy + strcpy is dest = src order ;p
18:50:59 <triteraf1ops> newtype would be cool, if I could scope it to the function
18:51:00 <Graypup_> or mov dest, src
18:51:09 <monochrom> You recall "dst := src" and you understand "memcpy(dst, src)"
18:51:31 <triteraf1ops> yeah but then you have to remember which functions are dst src and which are src dst
18:51:32 <monochrom> You recall "Intel is wrong" and you understand "mov src dst"
18:51:35 <triteraf1ops> because there are definitely both
18:51:40 <tabemann> argument swapping
18:51:43 <tabemann> tell me about it
18:51:55 <monochrom> You recall "Motorola is right" and you understand "move dst src"
18:52:06 <tabemann> I work on a project where there are two different functions
18:52:10 <tabemann> called copyProperties
18:52:13 <monochrom> Generally you recall "the victor is wrong" and you will be OK.
18:52:18 <tabemann> they are identical
18:52:24 <triteraf1ops> If I could scope record definitions and new type definitions to a function that might fix a few things really
18:52:25 <tabemann> except the source and destination are switched
18:52:37 <tabemann> furthermore
18:52:39 <Graypup_> intel is right lol and their assembly syntax is better but that's very OT again
18:52:41 <monochrom> haha now that's golden
18:52:51 <tabemann> they're both in classes named BeanUtils
18:52:52 <triteraf1ops> like... if the arguments of a function had their own scope into which you could put random stuff
18:52:58 <triteraf1ops> like f is a function
18:53:06 <triteraf1ops> and x and y are variables
18:53:15 <triteraf1ops> but only underneath an f invocation
18:53:23 <triteraf1ops> so it's like x -> name error
18:53:31 <triteraf1ops> f x -> oh, that thing
18:54:51 <monochrom> Well I think linear typing helps with dst and src, too.
18:54:58 <triteraf1ops> That would be very useful under all circumstances where there's a symbol that is only relevant within the invocation of a certain function
18:55:00 <tabemann> damn you Apache Commons and Spring Framework!
18:55:16 <monochrom> Because src is being consumed, dst is being produced. Linear typing disallows mixing them up.
18:55:39 <triteraf1ops> Is that a thing anywhere? variable scopes within the /invocation/ of functions?
18:55:46 <monochrom> If you misremember and swap them, the compiler will notice.
18:56:14 <tabemann> the thing is, who uses linear types other than Clean and Mercury - and who uses them?
18:56:28 <infinisil> Idris!
18:56:31 <monochrom> We'll see. Linear Haskell is being realized.
18:56:33 <infinisil> Idris 2 to be exact
18:56:42 <tabemann> cool
19:00:59 <ski> Graypup_ : it's `move src,dest', in some assemblers :)
19:01:15 <monochrom> such as Intel
19:01:31 <ski> tabemann : there are no linear types in Clean and Mercury. they use uniqueness, not linearity
19:01:32 <tabemann> I've had to get used to mov dst, src in Thumb-2 assembly
19:02:15 <tabemann> ski: just offhand, what's the difference
19:02:40 <ski> with uniqueness, you haven't duplicated yet, in the past
19:02:53 <ski> with linearity, you're promising to not duplicate, in the future
19:03:08 <monochrom> Would you like this alternative?  In 6502 and a few others, they have "lda" (load accumulator) and "sta" (store accumulator).
19:03:14 <dolio> You also must use it.
19:03:21 <ski> yea
19:03:35 <monochrom> One means from elsewhere to accumulator, the other from accumulator to elsewhere. I forgot which is which.
19:03:37 <tabemann> oh one thing about Thumb-2 assembly
19:03:41 <tabemann> STR reverse the order
19:03:48 <tabemann> STR is src, [dst]
19:03:59 <monochrom> YOU KIDS HAVE IT EASY. AT LEAST YOU ONLY HAVE ONE "MOVE" TO WORRY ABOUT
19:04:08 <tabemann> whereas LDR is dst, [src]
19:04:18 <ski> monochrom : and then also `tax',`txa',`tay',`tya',`txs',`tsx', but no transfer between other pairs of registers :)
19:04:24 <monochrom> In my time it was always snowing and it was uphill both ways.
19:04:25 <Graypup_> ski, lol I'm aware, but the intel one that does that also sucks so,
19:04:35 <monochrom> And it is all downhill now.
19:05:12 <ski> monochrom : "load" is to the register. "store" is from the register
19:05:13 <cheater> hello
19:05:25 <cheater> how can i strip ghc compiled binaries on windows? they're pretty big.
19:06:18 <ski> @remember monochrom <monochrom> In my time it was always snowing and it was uphill both ways.  <monochrom> And it is all downhill now.
19:06:18 <lambdabot> It is stored.
19:06:56 <monochrom> If you can get at the mingw prompt, you probably have the standard unix "strip" command.
19:07:44 <monochrom> If it is too inconvenient, there is a setting for cabal to turn on exe stripping, it's just off by default (it used to be on by default a long time ago, I was caught surprised)
19:08:17 <cheater> monochrom: thanks, let me try that
19:08:28 <monochrom> I don't know how to say $HOME/.cabal/config in Windows, but add "executable-stripping: True"
19:08:37 <cheater> monochrom: i didn't realize that ghc symbols were the same as gnu
19:08:49 <cheater> monochrom: can't i just put it in my .cabal?
19:08:51 <monochrom> OR! If you want to turn it on for just a project, put it in cabal.project or cabal.project.local
19:09:18 <monochrom> No it's the wrong kind of options to put in *.cabal
19:09:34 <monochrom> Because supposed the user, not the author, makes that call.
19:09:52 <cheater> oh, i didn't realize
19:09:59 <cheater> so just put it on its own line in cabal.project?
19:10:10 <monochrom> Yeah
19:10:11 <ski> triteraf1ops : locally declared types would be nice (i've wanted it, sometimes). i've pondered a little, being able to access locally declared variables in definitions, from the interactor
19:10:19 <cheater> thanks, appreciated
19:10:26 <monochrom> cabal.project is a good middle-ground for this.
19:10:32 <cheater> i see here https://cabal.readthedocs.io/en/3.4/cabal-project.html#cfg-field-executable-stripping
19:10:41 <monochrom> yeah, that
19:10:49 <cheater> thank you
19:11:10 <monochrom> This new version manual is really nice.
19:11:42 <cheater> it's pretty good yeah
19:11:54 <cheater> but i wish it had more examples inline
19:12:09 <cheater> and i wish if code goes inside a specific file, i wish that code block had a file name at the top
19:15:31 <cheater> monochrom: i also had to add packages: *.cabal to the cabal.project file
19:15:40 <cheater> monochrom: but after re-building, the exe is still the same size
19:15:55 <monochrom> Ah yeah
19:16:06 <monochrom> Oh darn.
19:16:29 <monochrom> Then I don't know.
19:16:50 <monochrom> It is possible I am wrong and there is no stripping on Windows.
19:18:14 <ski> tabemann : hmm. so `LDR' is ergative–absolutive, while `STR' is nominative–accusative ?
19:18:29 <cheater> i tried mingw32 but it says it doesn't have strip installed
19:18:31 <cheater> which is weird
19:19:04 <cheater> as in "strip: command not found"
19:19:17 <monochrom> Haha new pessimism from me.
19:19:23 <tabemann> ski: yeah
19:19:43 <tabemann> the STR family of instructions are the only ones that reverse the usual order
19:19:46 <cheater> i mean, this does mention strip https://stackoverflow.com/a/5751229/389169
19:19:48 <monochrom> "If you have not seen AVL trees before, but red-black trees instead, don't despair. Both have the same nightmare of single rotations and double rotations; they just differ in the nightmare of under what conditions you do which.
19:19:57 <monochrom> So, do despair. >:)
19:20:54 <ski> i remember some (Casio ?) pocket calculator that wrote assignment as `<expr> -> <loc>'
19:21:48 <glguy> ski: I just checked and my Ti-89 is like that
19:21:59 <tabemann> then there's the Forth pattern where the value traditionally comes before the addres when storing a value
19:22:09 <tabemann> <value> <addr> !
19:22:18 <cheater> monochrom: i think strip comes with gcc, not with mingw32, could that be true?
19:22:27 <monochrom> I don't know.
19:22:56 <monochrom> I have only used GHC on Windows a long time ago for just toy examples.
19:23:29 <monochrom> I made an exe, but didn't ask how to strip it.
19:23:36 <ski> tabemann : do you know of any particular reason for that ?
19:24:20 <ski> glguy : hm. i thought that some TI calculator i used briefly had `<loc> := <expr>'. i might misremember
19:24:41 <tabemann> generally because it makes it so less stack-shuffling is needed in most cases
19:24:51 * ski . o O ( HP )
19:24:51 <tabemann> because let's say your address is a VARIABLE
19:24:55 <monochrom> Perhaps compare with subtraction in Forth.  If I desire 5-3, is it "5 3 minus" or is it "3 5 minus"?
19:25:18 <tabemann> subtraction is the usual pattern: 5 3 -
19:25:25 <monochrom> Then again blah, conventions are arbitrary.
19:26:00 <tabemann> with ! the convention is useful because it allows you to say <my calculation> <my variable> !
19:26:07 <monochrom> A dst<-src person would support "dst src !", the other person would support "src dst !". You can't win.
19:26:19 <monochrom> Ah yeah that's nice.
19:26:25 <ski> i was pondering `augend + addend' vs. `addend + augend' (and similarly for multiplication), the other day
19:26:50 <monochrom> Just look at our own "runState (.... 1000 characters later ...) initial_value"
19:26:51 <tabemann> whereas if you reversed it around you'd have to plan to put <my variable> underneath the <my calculation>, or shuffle the stack around to rearrange things
19:27:08 <ski> tabemann : yea, i can get the latter. but i wasn't seeing the less stack-shuffling part
19:27:40 <ski> (it'd make sense, for it to factor in. just not seeing it, either way)
19:28:12 <cheater> monochrom: oh, i think i know what's up, haskell platform installed msys2, which looks like mingw, but it's actually not mingw, it's smaller, so it doesn't include gcc
19:28:36 <monochrom> Ah, I misremembered, it's msys2 not mingw.
19:28:52 <cheater> well, yeah, but it's mingw that has strip
19:28:58 <cheater> (i think. installing it now)
19:29:30 <monochrom> I am very afraid of having to choose between msys2, mingw, cygwin. If possible I don't want to know.
19:29:35 <cheater> it's really bad btw that the haskell package for chocolatey doesn't allow changing the install dir. it's super bad
19:29:38 <cheater> same
19:29:59 <cheater> yeah, mingw has strip.exe
19:30:06 <monochrom> Life was so simple when on DOS I just had to ask for djgpp. And on OS/2, it's just emx.
19:30:49 <tabemann> of course there's the easiest solution - don't use windows
19:30:57 <tabemann> of course then
19:31:01 <cheater> yeah, applying strip.exe manually reduces the file from 15 mb to 2.7 mb
19:31:03 <tabemann> you're faced with the tough choice
19:31:10 <tabemann> of choosing between Linux or one of the BSDs
19:31:12 <monochrom> Well yeah that's why I went with OS/2 even before Windows 95 was a thing.
19:31:51 <ski> (i think i concluded that `addend + augend' is better. and possibly `subtract subtrahend minuend',`multiplier * multiplicand')
19:32:05 <monochrom> Did you hear my OS roast? I thought it up a long time ago.
19:32:24 * cheater hands tabemann a Baby Einstein Take Along Tunes Musical toy to keep him busy
19:32:25 <monochrom> Actually most of it I learned from other people. I just added one.
19:32:51 <ski> tabemann : ah, ok. so the "stack shuffling" simply deferred back to the proximity and relative size argument
19:32:54 <monochrom> Winblows, Linsucks, Slowaris (these 3 are from other people; now my invention:) FragmentedBSD
19:32:59 <cheater> monochrom: so it looks like stripping is broken on windows.
19:33:46 <tabemann> winblows is old hat - I remember that one from ages ago
19:34:00 <monochrom> ski: A decade ago in Taiwan and Hong Kong some primary school math teacher got famous by making a big fuss about the following nothingness.
19:34:40 <monochrom> He would ask you "5 pencils per box, I have 3 such boxes, how many pencils in total? show your steps".
19:35:06 <tabemann> "show your steps" is the key part
19:35:07 <monochrom> You would sometimes answer "5*3", sometimes "3*5", depending on your mood.
19:35:28 <monochrom> He would then say one of them is wrong. I forgot which. But the reason is total BS.
19:35:30 <c_wraith> 1) dump all pencils out.  2) count to 15.
19:36:00 <ski> following what i was thinking above. the correct way would be `3 * 5'
19:36:04 <tabemann> c_wraith, that's exactly what I was thinking
19:36:11 <monochrom> Perhaps "3*5" because "box * (pencils per box)", not "(pencils per box) * box".
19:36:33 <monochrom> Some kind of manufactured reason along that line.
19:36:35 <tabemann> but but but multiplication is commutative!
19:37:08 <monochrom> Right! It is extremely unhealthy to split hair like that for a commutative operator.
19:37:25 <ski> if you have a group, with a normal subgroup, and a corresponding factor/"quotient" group, then the normal subgroup is the multiplicand, and the factor group (it's not a quotient ! :) is the multiplier
19:37:33 <MarcelineVQ> monochrom: so you're saying common core was inspired by a hong kong teacher
19:38:00 <monochrom> It was a Taiwan teacher. But the news went to Hong Kong too.
19:38:17 <c_wraith> why does common core get such a bad rap?  The concepts are all perfectly fine.
19:38:24 <ski> tabemann : except when it isn't :)
19:38:25 <monochrom> Or perhaps that teacher was inspired by common core? I don't know common core and I don't know the timing.
19:39:00 <dolio> No, obviously inspired by Edward Nelson's predicative arithmetic.
19:39:08 <ski> haha :)
19:39:15 <dolio> You need to prove that 3 and 5 are commutative-multipliable numbers.
19:39:40 <monochrom> haha
19:39:55 <tabemann> ski: what, in some floating point implementations?
19:40:19 <ski> tabemann : nah. see the group theory example
19:41:16 * ski idly recalls recently watching a vid in which kmett mentioned using semi-direct products, in programming
19:45:28 <solonarv> the most common form of non-commutative multiplication is probably matrix multiplication 
19:45:53 <triteraf1ops> with quaternions a very distant runner up lol
19:46:02 <taktoa[c]> quaternions are a matrix group
19:46:16 <triteraf1ops> isomorphic, yeah, I suppose
19:47:47 <triteraf1ops> usually they're not represented with matrices though
19:48:35 <taktoa[c]> I don't know off the top of my head of a nonabelian group that's not isomorphic to a matrix group, maybe the metaplectic group?
19:49:08 <ski> (i think it was <https://www.youtube.com/watch?v=Txf7swrcLYs#t=28m59s> and <https://www.youtube.com/watch?v=HGi5AxmQUwU#t=41m15s>)
19:50:03 <taktoa[c]> actually metaplectic is the classic counterexample for not having a faithful representation
19:50:11 <ski> solonarv : yea, but neither it, nor quaternions, have the parameter rôle distinction that i was getting at
19:50:12 <triteraflops> point being, quaternion multiplication is not usually thought of as matrix multiplication
19:50:14 <taktoa[c]> but isomorphism is maybe stronger
19:50:48 <dolio> Is the free group on a set isomorphic to a matrix group?
19:50:57 <dolio> (Always)
19:53:02 <taktoa[c]> every group is isomorphic to a permutation group, and if that group is finite, then the permutation group can be represented by finite-dimensional permutation matrices
19:53:12 <taktoa[c]> so yes, if the set is finite...
19:53:41 <taktoa[c]> if it's infinite, then I guess you might run into situations where it needs to be infinite dimensional like the metaplectic group
19:53:55 <ski> (`multiplier * multiplicand' corresponds to the usual lexicographic ordering)
19:54:03 <Graypup_> how can I get data into an `instance` declaration?
19:54:29 <Graypup_> I have an `instance YesodAuthX App` which needs to store some data in an IORef somehow
19:54:38 <ski> free group is infinite, apart from on the empty set
19:55:15 <taktoa[c]> oh yeah, it's finitely generated (if S is finite), but not finite
19:55:15 <ski> (or did you mean something like "finitely presentable", by "finite" ?)
19:56:57 <ski> Graypup_ : i dunno .. maybe something like `reflection' ?
19:56:58 <Graypup_> (smh I am the one defining App, so I can just put it in there lol)
19:57:11 <Graypup_> i am not very smart
19:57:24 <taktoa[c]> I think what I said might be true if you replace finite by finitely generated, but I can't prove it off the top of my head
19:57:33 * ski 's not familiar with `YesodAuthX'
19:58:30 <taktoa[c]> I don't really know very much group theory or representation theory
19:58:40 <ski> taktoa[c] : it's perhaps not always that clear what "finite" should mean, from a categorical perspective. i have some sympathy for people calling "finitely generated/presented", "finite"
19:59:18 <Graypup_> wait, I can put it in App, but how can I get my *own* App from within the instance?
20:00:46 <ski> (iirc Paul Taylor, in "Practical Foundations for Mathematics" has three alternative definitions of "finite". <https://www.paultaylor.eu/~pt/prafm/html/s66.html>)
20:01:03 <ski> (s/for/of/)
20:53:05 <cheater> i'm using `catch` to handle an IOError exception. how can i do something when no exception has been thrown?
20:53:25 <glguy> cheater: Add it as the last line inside your catch
20:53:34 <glguy> or 
20:53:38 <cheater> last line on the left of `catch`?
20:53:53 <glguy> return a Boolean inside the catch and outside so you know if you used the handler
20:54:07 <cheater> i'm in IO, i want to print something
20:54:23 <glguy> Either:  (thing you were going to do >> print something) `catch` h
20:54:40 <cheater> yeah, that's what i did. thanks
20:56:14 <dmwit> Some precision is required. Do you want to do something when no exception is thrown, or when no IOError exception is caught?
20:56:20 <dmwit> Those are not quite the same thing in all cases.
20:56:31 <cheater> good question. i don't know
20:56:43 <cheater> i would say both of them would mean i shouldn't be printing "success."
20:57:18 <dmwit> You should not print "success." when no exception is thrown?
20:57:35 * dmwit squints
20:57:42 <dmwit> There are many negatives here.
20:57:45 <cheater> i want to print "success." when what i did was successful. if it wasn't, then no printing.
20:58:02 <cheater> and i said that either type of exception probably means i shouldn't be printing
20:58:31 <dmwit> Okay. Then probably printing inside the catch, as you did and glguy recommended, is the right thing. Great!
20:58:58 <cheater> when would it make a difference?
20:59:13 <cheater> glguy: you said "either", were you going to say something else too? :)
21:02:25 <glguy> Either return the boolean to indicate if an exception was handled , or do the first thing
21:03:36 <cheater> oh, right, yeah
21:05:05 <dmwit> It would make a difference when your action could throw non-IOError exceptions.
21:05:24 <Graypup_> how can I find the actual type of a local? I have let cfg = makeThing a, and if I put (makeThing a) :: _, I still get `TheType m` but not what m is
21:05:33 <Graypup_> there is also no `m` in the function's signature
21:05:36 <Graypup_> so, wat
21:06:49 <dmwit> You can write `let cfg :: _; cfg = makeThing a` and -XPartialTypeSignatures to ask GHC what type it things `cfg` has.
21:07:13 <dmwit> But it is in general a bit tricky to ask about the types of subexpressions, yes.
21:07:52 <dmwit> GHC can also on occasion tell you a type that you can't write down yourself (because it allows itself extensions that you haven't turned on yet). =P
21:08:50 <cheater> dmwit: what sort of exception could i get that wouldn't be an error in the thing that threw it?
21:08:53 <Graypup_> wat https://i.imgur.com/GX5ycwH.png I still can't tell what ghc thinks it is
21:09:32 <cheater> try AuthFlowConfig _
21:09:57 <Graypup_> m :: * -> * well thanks ghc lmao
21:10:12 <glguy> Incidentally catch is for when you need async exceptions masked in the handler and try is for when you don't
21:10:59 <cheater> not sure which i want
21:11:04 <cheater> do i want them masked or not masked?
21:11:13 <cheater> i'm not looking to handle async exceptions here
21:11:32 <cheater> the right side of my `catch` just prints out the error message from the IOException.
21:12:13 <monochrom> Then "try" is better.
21:12:28 <monochrom> Get a Left of Right, then you can act accordingly.
21:12:38 <monochrom> err, Get a Left or Right
21:12:44 <monochrom> I can't type today.
21:12:59 <dmwit> cheater: There are lots of exceptions that aren't IOErrors. Check out the instance list here for some examples, but anybody can make a new instance, too: https://hackage.haskell.org/package/base-4.14.0.0/docs/Control-Exception.html#t:Exception
21:13:10 <monochrom> My typos today are like at the token level, not letter level.
21:13:28 <cheater> i mean sure, but can you describe like a typical situation?
21:14:02 <cheater> a situation where i would still be printing "success." even though some other exception got thrown from launchRockets?
21:14:39 <dmwit> One situation would be you want to print "successfully opened file" even if parsing the file led to a division by zero.
21:16:06 <dmwit> Graypup_: I agree that's a little puzzling; what is AuthHandler? Naively, it doesn't seem as though the type signature `Text -> RequestParams -> AuthHandler master TypedContent` could bind the name `m` unless one of those things is a type synonym for a polymorphic type.
21:16:23 <dmwit> (And AuthHandler seems like the most likely suspect to be that.)
21:17:27 <Graypup_> dmwit, it's some Yesod nonsense that I don't know enough Haskell to understand lol
21:19:06 <dmwit> Okay. I encourage you to take it slow and understand what you can. If you are feeling rushed, perhaps take a second and try to work out why. Slow is smooth and smooth is fast.
21:19:42 <Graypup_> I'm naturally hurried by needing to get this project done and this being the last thing I need to implement
21:20:54 <dmwit> It is common for a little bit of time invested now in understanding to pay off greatly in the future in reduced time spent dealing with not understanding.
21:22:24 <dmwit> If the pressure is coming from your desire to finish quickly, then perhaps you can trade off your desire to learn and become expert. If the pressure is coming from external expectations, perhaps you can discuss this tradeoff with them.
21:25:05 <cheater> dmwit: that's a pretty good example with "successfully opened file", thanks, but why would i print that only after starting to /parse/ the file?
21:25:49 <cheater> i mean i could see someone doing openAndParse; putStrLn "successfuly opened file", but wouldn't that be pretty bad design?
21:26:26 <dmwit> I don't know what you want. That is why I asked a clarifying question about what you want.
21:28:03 <cheater> right now i want to figure out a situation where you could have an exception thrown at you from within an action and still report that action was successful
21:28:34 <dmwit> I believe the question is predicated on a false assumption.
21:29:01 <dmwit> In particular: it is predicated on the false assumption that at the time I asked you to be precise about what you wanted, that I knew that the action you wanted to do was report success.
21:29:31 <cheater> oh, ok
21:29:52 <Graypup_> dmwit, well I got it working, but it is a refactoring target
21:31:49 <cheater> dmwit: thanks
22:05:49 * hackage llvm-pretty 0.11.0 - A pretty printing library inspired by the llvm binding.  https://hackage.haskell.org/package/llvm-pretty-0.11.0 (TrevorElliott)
22:26:25 <hyiltiz> How can I search for all data types isomorphic to say, Maybe or Either? Is there something like hoogle?
22:37:37 <Graypup_> almost owned myself with a two argument function taking Text for both lmao
22:37:52 <Graypup_> rewrote: checkCSRFToken (State state) name
22:58:02 <kenran> I want to test a servant application where I use a custom type class for the database, say: server :: HasDB m => ServerT Routes m. To actually run this, there's an AppM monad that has as HasDB instance and and I use `hoistServer` to use AppM as the `m` in `server`.
22:59:21 <kenran> Now I found out/read about servant-client that can be used to test the server. Now I'd like to test with a running server, but not need to have an actual PostgreSQL DB running in the background. Is this possible with `hoistClient`? I don't really see it yet.
23:08:21 <kenran> I think my problem is that in order to use `Warp.withTestApplication`, I need to put in the "real" Application, i.e. using AppM. Maybe I can change this to still be polymorphic in the test and plug in another monad... phew, this is hard to wrap my head around.
23:11:57 <Graypup_> oh noooooooo
23:12:18 <Graypup_> I have a Maybe.fromJust: Nothing error and I have absolutely no idea how to find its cause ;-;
23:12:52 <Graypup_> being pointed to https://github.com/yesodweb/yesod/blob/yesod-core-1.6.18/yesod-core/src/Yesod/Core/Class/Yesod.hs#L688 for the log source but I have no idea where the upstream source is
23:14:46 <Graypup_> well I found the cause by grepping my source base, but I have no idea how I'd have found it otherwise
23:35:25 <Axman6> hyiltiz: I don't know a way to do that, but in theory you could use the Generic instance of types to find ones which are isomorphic
23:44:37 <rando59> Hello everyone 👋 I came across an interesting draft paper dealing with a variant of datalog with recursion, deletion, negation, and self reference/interpretation.Seemed like an interesting theory, potential leading to an advanced automated theorem prover,discussion scaling, and collaborative programming. “To deal with the paradoxes of
23:44:38 <rando59> self-reference, TML is designed having in mind the three laws of laws. They are characterizations of a formal logic of law, for as mentioned above the Tau process is akin to legislation. The three laws, decidability, closure under Boolean operations, and self-interpretation, furnish the coexistence of decidability and unrestricted recursion -- two
23:44:38 <rando59> highly desired properties in the process of legislation. They also point at specific logics that adhere to the three laws.”https://github.com/IDNI/TMLhttps://www.idni.org/whitepaper_community_draft.pdf
23:45:43 <Axman6> ... did we just get academia spammed?
23:46:08 <Axman6> I'm not even mad, that's amazing
23:48:55 <kenran> Does anyone by chance have an example handy of a "real" servant application where the actual application is being tested? I might to see how others use this. The tutorial isn't really enough for me to handle the real-world case unfortunately.
23:49:28 <Axman6> what problems are you having?
23:50:04 <Axman6> and do you mean "is being tested" as "there is a test suite testing the web application"?
