00:20:39 <tomsmeding> dintenk: is your Hashable instance sensible?
00:20:55 <dintenk> I am using Text for the key!
00:21:00 <dintenk> Data.Text
00:22:32 <tomsmeding> let's indeed assume that Text has a sensible Hashable instance :p
00:23:05 <dintenk> very strange
00:23:36 <tomsmeding> how do you observe this duplicate record?
00:24:00 <tomsmeding> a record remains after you delete one of them, or something else?
00:24:27 <dintenk> printing the list and also getting the size of the hashmap where it should contain only 8 there is the 9th
00:25:09 <dintenk> at the time of the update, i tried atomically deleting and inserting for the same key, still duplicates happen
00:25:24 <tomsmeding> interesting
00:25:29 <tomsmeding> do you have a small repro?
00:26:10 <dintenk> I dont have it unfortunately.. I am thinking of moving away from it, and using a Data.Map.Strict map within a TVar 
00:26:22 <dintenk> what do you recommend I do?
00:26:26 <tomsmeding> Â¯\_(ãƒ„)_/Â¯
00:26:31 <tomsmeding> let me see if I can whip up a repro
00:26:42 <dintenk> that would be great!
00:26:43 <tomsmeding> how intensive is your parallel access
00:26:50 <dintenk> pretty intensive
00:27:02 <dintenk> its part of a highly concurrent applicaiton
00:27:12 <tomsmeding> well you could at least benchmark whether using TVar (Data.Map.Strict) is significantly slower :p
00:27:16 <dintenk> but its reproducing very easily
00:27:20 <tomsmeding> if is isn't, that sounds like a good way forward
00:27:33 <dintenk> sure, thank you!
00:27:52 <tomsmeding> would be a good case study anyhow into the usefulness of stm-containers, I guess :p
00:27:53 <dintenk> appreciate if you can share your findings with the stm-containers map
00:28:02 <dintenk> yep!
00:28:04 <tomsmeding> never worked with it before, so let's have a look :p
00:28:12 <dintenk> :)
00:28:17 <tomsmeding> it looks cool at first glance
00:28:21 <tomsmeding> also undocumented
00:28:33 <dintenk> yeah its mutable
00:30:19 * hackage symmetry-operations-symbols 0.0.2.0 - Derivation of symbols and coordinate triplets Library  https://hackage.haskell.org/package/symmetry-operations-symbols-0.0.2.0 (narumij)
00:52:05 <Polesch> Anyone done haskell exercises on exercism before?
00:52:35 <Polesch> I don't understand how the test cases are to be read
01:00:49 * hackage periodic-server 1.1.7.1 - Periodic task system haskell server  https://hackage.haskell.org/package/periodic-server-1.1.7.1 (Lupino)
01:08:28 <Taneb> @quickcheck \xs ys -> concat ((xs :: [Int]) ++ ys) == concat xs ++ concat ys
01:08:29 <lambdabot> Unknown command, try @list
01:08:35 <Taneb> @check \xs ys -> concat ((xs :: [Int]) ++ ys) == concat xs ++ concat ys
01:08:37 <lambdabot>  error:
01:08:37 <lambdabot>  â€¢ Couldn't match type â€˜Intâ€™ with â€˜[()]â€™ Expected type: [[()]] Actual type: [...
01:08:46 <Taneb> @check \xs ys -> concat ((xs :: [[Int]]) ++ ys) == concat xs ++ concat ys
01:08:48 <lambdabot>  +++ OK, passed 100 tests.
01:08:52 <Taneb> OK, cool
01:17:15 <tomsmeding> Polesch: with which exercise are you having difficulty?
01:17:36 <tomsmeding> don't the instructions say something like to export a function with a particular name from the module?
01:17:43 <Polesch> It's not a difficult, I'm just a beginner and don't know how to handle the input
01:18:38 <Polesch> I found some information, will read.
01:19:25 <tomsmeding> dintenk: if I perform parallel insertions in an stm map with only 4 threads, there seems to already be so much congestion that almost nothing is getting done
01:20:03 <dintenk> :tomsmending really?!
01:20:12 <tomsmeding> or, well, better nuanced: the inserts are happening fine, but I'm polling a correctness check once in a while on a separate haskell thread
01:20:32 <tomsmeding> and that checker thread never can barely complete a `listT` in 10 seconds or so :p
01:21:01 <tomsmeding> I do manage many inserts per second, so that looks fine
01:21:04 <dintenk> maybe you should give a tiny sleep
01:21:06 <tomsmeding> but no correctness issues spotted yet
01:21:30 <tomsmeding> where many = ~2 million per thread per second
01:22:09 <dintenk> well, that is not easy to explain 
01:22:30 <tomsmeding> dintenk: https://gist.github.com/tomsmeding/14eb95fa5c32bd8e40f64e14e9ece038
01:24:06 <tomsmeding> whole program takes ~55 seconds on my machine; the correctness checker fires exactly twice :p
01:24:36 <Polesch> What is the likely error if I get "parse error (possibly incorrect indentation or mismatched brackets) main = do"
01:25:16 <tomsmeding> missing ) somewhere before that?
01:25:41 <tomsmeding> or missing 'where' on the 'module' line
01:26:46 <dintenk> :tomsmending could you try updating with a different value?
01:27:00 <dintenk> ramdomized..
01:28:49 <ski> Polesch : show code ?
01:29:27 <DigitalKiwi> ski: you don't like guessing games?
01:29:31 <Polesch> That's too embarrassing, but yes - missing parenthesis somewhere, commented some of it and it's working
01:30:50 <tomsmeding> dintenk: if I change pairSequence to read 'zip (cycle keyList) [1..]' (thus inserting a different value each time), still everything looks fine
01:31:25 <ski> DigitalKiwi : i do, but the relevant guesses already seem to have been depleted
01:32:21 <DigitalKiwi> hmm yes that is a problem
01:35:10 <tomsmeding> Polesch: don't worry about code being embarrassing while you're learning :p
01:35:33 <tomsmeding> I've seen some significantly crappy haskell code, so yours can't be that bad :p
01:35:34 <Polesch> Coming from python and R this is a steep learning curve :P
01:35:48 <tomsmeding> sure is
01:44:11 <tomsmeding> dintenk: I checked that the threads do actually perform some interleaved inserts -- it's not just thread 1 doing all its work, then 2, etc.
01:44:33 <tomsmeding> so I'm afraid I'm having difficulty reproducing your issue :p (which does not mean that it's not there)
02:06:45 <Chousuke> I don't think you can do programming without seeing significant amounts of crap code. Usually it's your own :P
02:08:58 <asheshambasta> Is there a type level way to write a constraint such that I can establish one type level list is a subset of another?
02:11:58 <maerwald> asheshambasta: I've seen something like that
02:12:00 <maerwald> sec
02:12:24 <maerwald> https://hackage.haskell.org/package/haskus-utils-variant-3.0/docs/Haskus-Utils-Variant.html
02:12:28 <maerwald> somewhere there
02:12:43 <asheshambasta> thanks!
02:13:17 <maerwald> https://hackage.haskell.org/package/haskus-utils-variant-3.0/docs/Haskus-Utils-Variant.html#t::-60--60-
02:13:42 <asheshambasta> yeah; that should solve it
02:26:45 <plam4u> Chousuke: why do you say that about the crap code? 
02:30:20 <asheshambasta> As a follow up question; how does one now implement https://pastebin.com/B6b43vxv
02:46:31 <asheshambasta> My line of thought there is to get some index of the type (I don't know how); which will be a `Nat` (I think) which can be then looked up using pattern matching.
02:46:47 <asheshambasta> but I'm too much of a type-level noob to figure that out.
02:51:49 * hackage matrix-as-xyz 0.1.2.2 - Read and Display Jones-Faithful notation for spacegroup and planegroup  https://hackage.haskell.org/package/matrix-as-xyz-0.1.2.2 (narumij)
03:14:20 * hackage periodic-client-exe 1.1.7.1 - Periodic task system haskell client executables  https://hackage.haskell.org/package/periodic-client-exe-1.1.7.1 (Lupino)
03:19:52 <plam4u> ?src ($)
03:19:52 <lambdabot> f $ x = f x
03:21:36 <Chousuke> plam4u: mostly just because of my own experience. Generally the worst facepalm moments have been me looking at code written by me 5 years ago :-)
03:22:01 <Chousuke> and it's hard to go from 1 to 10 straight, when learning things
03:22:06 <Chousuke> so it'll just happen
03:22:49 <Chousuke> and I have this view that the best code is one you don't have to write anyway.
03:23:14 <plam4u> got it. I agree. Also, even if you write perfect codeâ€¦ the definition of "perfect" is just in the context of your current mindsetâ€¦ when you learn more things and shift your point of view, "perfect" also shiftsâ€¦ and the code from before now looks more crappy I guess :) 
03:23:21 <Rembane> The next best code is the code you can delete. 
03:23:41 <Chousuke> that's what I try to write
03:24:10 <Chousuke> I want to write stuff so that I can easily delete it when it inevitably becomes crap and replace it with something else
03:25:17 <Chousuke> it's the worst feeling when you have to deal with code that's bad and you can't touch it because it's so intertwined with everything that modifying it is difficult
03:25:40 <Chousuke> though that applies to any system, not just code.
03:26:31 <Rembane> Totally. 
03:28:57 <plam4u> I guess that's something you learn from experience. I don't have degree in CS so I'm not sure if it is something you're thought to deal with and design better systemsâ€¦
03:30:50 <Chousuke> it's definitely experience. It's difficult to teach because in the "real world", those systems can get very large and involve much more than just code.
03:31:15 <Chousuke> you can teach principles and ideas but then there's the social problem of getting people to actually stick to those principles, etc.
03:31:46 <Chousuke> and sometimes they do get in the way and you really need to take that ugly shortcut
03:31:50 <Rembane> I think it's Conway's law that says that code bases have a tendency to reflect the organisation that developed it. 
03:32:38 <Chousuke> the way I see it, it's perfectly fine to hack around stuff, you just need to stop before it gets out of hand
03:33:00 <Chousuke> and recognizing when to do that is a skill that you get with experience
03:34:09 <plam4u> no shortcuts to developing this gut feeling :P 
03:34:28 <Chousuke> paying attention helps, I guess.
03:35:15 <Chousuke> I notice that sometimes people (myself included) just do things without much consideration as to why
03:35:50 <plam4u> yeah, the brain automates as much as possibleâ€¦ otherwise you would burn energy all the time and not be as productiveâ€¦ I guess
03:36:10 <Chousuke> or you get stuck with this one idea you have and try to hammer it through when there's another you could've had if you'd thought about it for a bit more. :)
03:36:11 <plam4u> Rembane: I didn't know about Conway's lawâ€¦ and it makes a lot of sense :) 
03:36:48 <plam4u> Chousuke: to get unstuck, I guess you need to keep an open mind and hungry for new ideas/approaches
03:36:53 <Rembane> plam4u: doesn't it? :) 
03:36:53 <Chousuke> I never trust my first idea
03:36:57 <Chousuke> it's usually bad
03:37:50 <Chousuke> I guess you can get stuck trying to come up with good enough ideas though
03:38:02 <plam4u> analysis paralysis?
03:38:07 <Chousuke> something like that.
03:38:19 <plam4u> that's one of my biggest problems :D
03:38:27 <Chousuke> avoiding that is another skill that's hard to obtain
03:38:30 <plam4u> in fact, now I started learning haskell because of that
03:39:01 <plam4u> I want to apply functional programming to swift and to truly understand what it means "functional" I decided that I should learn haskell
03:39:24 <Chousuke> "learn haskell" is a bit of a nebulous goal though
03:39:43 <plam4u> yeah, my goal is "read book X and practice while learning"
03:39:55 <plam4u> with this I would at least know the concepts and some terms
03:40:09 <plam4u> also I would like to apply it to some smaller projects or scripting 
03:40:20 <plam4u> while I read, I write manually all the example code and exercises
03:40:54 <plam4u> so far, the mind shift is huge and I got lost many times alreadyâ€¦ and it is just the beginning :(
03:41:09 <plam4u> the book is 2000 pages long and I'm only at 100th page
03:41:10 <Chousuke> Learning the functional approach to programming certainly changed the way I approach problems
03:41:52 <plam4u> so far, the biggest revelation is how cool is to separate data from operations
03:42:04 <plam4u> I always thought in objects and methods related to the data these objects represent
03:42:16 <Chousuke> I find it very natural to reason about data flow in terms of transformations on data rather than what a program "does"
03:42:57 <Chousuke> which coincidentally also makes me a huge fan of SQL :P
03:43:03 <plam4u> yeah, I guess because you focus on something specific and don't think about the complexity of the program
03:43:35 <Chousuke> I can spend a lot of time figuring out SQL queries just so I don't have to write code to process the data.
03:44:07 <plam4u> sounds like a good approach and probably it is more efficient as well
03:44:18 <Chousuke> it's very satisfying
03:44:19 * hackage symmetry-operations-symbols 0.0.2.1 - Derivation of symbols and coordinate triplets Library  https://hackage.haskell.org/package/symmetry-operations-symbols-0.0.2.1 (narumij)
03:46:03 <Chousuke> relational databases are really capable, and just using them to select * from whatever is a sad waste.
03:46:33 <Chousuke> but I've actually been straight told that it's "easier" to write code to process a simple query because SQL is hard.
03:49:19 <plam4u> "easy" is very subjective and it depends who says that. If you don't spend time learning SQL, then writing some code to process data would always seem easier
03:50:20 <phadej> processing in code is fine, if you select the working set with a single query :)
03:50:43 <phadej> you are still transactional then
03:50:59 <phadej> interleaving processing and querying correctly is non-trivial
03:53:50 <phadej> That said, dozens long SQL queries are *simply* unreadable, and you cannot make that better as the language does barely have any abstraction mechanism
03:53:53 <phadej> e.g. `let`
03:54:03 <phadej> dozens line long
03:54:28 <Chousuke> I abuse CTEs to help with that :P
03:55:07 <phadej> true, that's kind of let
03:56:05 <Chousuke> but yeah, sometimes it does get repetitive
03:56:51 <phadej> especially sharing codes between different queries is somewhat impossible :)
03:57:12 <Chousuke> well, you can write database functions
03:57:16 <phadej> ... and stored procedures is not a solution
03:57:42 <phadej> (as they are own pain to maintain and *evolve*)
03:58:08 <Chousuke> there's just so much power to make things easy. :P
03:59:50 * hackage assoc 1.0.2 - swap and assoc: Symmetric and Semigroupy Bifunctors  https://hackage.haskell.org/package/assoc-1.0.2 (phadej)
03:59:55 <Chousuke> At work I wrote a thing to make our CMDB easier to query with SQL, because it has a really clunky and slow rest API (it returns a *ton* of redundant data). The problem is that it's schema is dynamic and the database is an Entity-Attribute-Value thing with a schema that's... not the easiest thing to query.
04:00:16 <Chousuke> So I wrote a bunch of functions that "discover" the schema and generate views from it
04:00:25 <Chousuke> and then told the database to materialize those views
04:00:40 <phadej> in that case EAV is something which probably not going ever to change
04:00:50 <phadej> so yeah, then it works
04:00:50 <Chousuke> yeah
04:01:30 <Chousuke> the generation and materialization took like 5 seconds and it got *so* much easier to query
04:01:33 <phadej> but then, EAV storage on top of SQL is underutilizing RDBMS :)
04:01:56 <phadej> (I know why it might be neat)
04:02:23 <Chousuke> well, the thing allows you to create your own schema so I guess I can see why they'd make it that way
04:02:41 <Chousuke> but querying it directly from the database was horrible.
04:02:56 <phadej> I'm pretty sure it wasn't meant to be queried directly
04:03:26 <Chousuke> might be, but that was the only way to get responses quickly enough for me to not lose sanity :P
04:03:26 <phadej> (e.g. datomic is eav storage, but I hope no-one queries its backends directly)
04:04:04 <Chousuke> and fortunately it'll not be that difficult to fix if the schema breaks
04:06:33 <Chousuke> it's theoretically an ugly hack because I'm bypassing the official API, but the official API is so slow and difficult to query efficiently that the ugly hacks accumulate elsewhere
04:07:29 <Chousuke> there was one thing that just did a daily dump of all the things in the API and used that.
04:07:38 <Chousuke> in the CMDB* I mean
04:10:33 <phadej> In past I have to deal with slow API which took many hour run to query megabytes worth of raw data. Had to that nightly, as API was unusable as is. Been there done that.
04:10:41 <phadej> Sadly there are APIs made for the sake "to have API"
04:11:01 <phadej> but hopefully people are getting better at making actully usable interfaces :)
04:17:37 <Chousuke> with data like that, it's the lack of joins that usually gets me
04:18:18 <Chousuke> no-one seems to implement joins in their APIs
04:19:53 <Chousuke> so you end up querying n objects and then m attributes or related objects and possibly even more, and each takes a roundtrip
04:20:05 <Chousuke> for something that would be trivial for any RDBMS
04:22:19 <phadej> yes, hardly any API has even bundler queries (i.e. query attributes of N different objects)
04:23:05 <phadej> graphql APIs are better in that sense, but I still feel they are new clothes for the same "relational" thing.
04:23:54 <phadej> (i.e. allowing arbitrary graphql queries in public apis is close to allowing arbitrary SQL queries)
04:25:04 <phadej> hardly any REST* API
04:56:49 * hackage seitz-symbol 0.1.0.0 - Read and Display Seitz Symbol  https://hackage.haskell.org/package/seitz-symbol-0.1.0.0 (narumij)
05:11:31 <hexagoxel> gah, my nix/haskell setup is bootstrapping ghc-8.4 again. Trying to bring sanity and stability into package maintenance chores with nix still seems like the right approach, but for the last few week(end)s waiting-on-compiler dominated my haskell experience and stalled any actual programming..
05:12:22 <hexagoxel> and I just discovered that the latest nix expression does not even contain 8.10.2 yet :(
05:17:24 <hexagoxel> and then some people wield some morality hammer against those that seem to be contributing the most to the build-tooling ecosystem atm.
05:23:32 <maerwald> are you talking about elephants?
05:25:31 <hexagoxel> don't know what you mean
05:26:30 <phadej> 8.10.2 just, err, 2 days old?
05:26:51 <phadej> correction, a day old
05:28:14 <phadej> (and with a release popping almost ouf of nowhere, how would you anticipated it?)
05:29:28 <phadej> expecting things to happen the same or next day is really turning off me from current OSS
05:30:07 <hexagoxel> true
05:31:02 <hexagoxel> but there already _is_ a branch on haskell-nix for ghc-8.10.2; hamish is busy on a sunday
05:33:21 <hexagoxel> it is probably unrelated to bootstrapping ghc-8.4 anyway. Hopefully.
05:35:01 <phadej> does haskell.nix work with GHC-8.4? I think the elephant company isn't using 8.4 anymore (i.e. moved to 8.6)
05:36:54 <niso> phadej: ghc-8.4.x or ghc-8.8.4 ?
05:37:06 <phadej> niso: 8.4
05:37:44 <hexagoxel> the nix expressions for ghc-8.4 work, just nothing is cached.
05:38:53 <phadej> makes sense
05:39:48 <phadej> I guess their nix cache is byproduct of their production code CI runs.
05:40:07 <phadej> (or development)
05:40:28 <hexagoxel> yeah, I think so
05:43:43 <hexagoxel> I would not mind about the libraries, just the compiler is annoying to bootstrap. And its derivation unfortunately changes somewhat regularly. which you _can_ avoid by just not updating haskell-nix, but I was forced to due to other issues/hackage index stuff.
05:44:26 <hexagoxel> Hopefully I can freeze it once I have set up fully working nix-expressions and not touch the tooling derivations for the next few months.
05:45:37 <hexagoxel> (and it did finish bootstrapping by now.. progress! :)
05:48:58 <niso> newbie question: by chance someone can tell me how to fix this type error?  https://hastebin.com/iqamutotum.rb
05:52:13 <ski> niso : who defines `prot' ? apparently you need to pass a `Token' to it
05:52:38 <niso> ski: prot is defined in line 73 of the paste
05:53:41 <solonarv> niso: no, it is not. line 73 binds 'prot1' and 'prot2', it does not bind 'prot'
05:53:55 <ski> if you mean
05:53:55 <solonarv> oh I see, line 72
05:53:56 <ski>   prot1 :<|> prot2 = prot
05:54:04 <ski> then that's attempting to use `prot
05:54:08 <ski> ', not define it
05:54:27 <solonarv> line 72 defines prot, however
05:54:40 <niso> there is some type magic going on
05:54:45 <niso> (lang extension)
05:54:51 <ski> mhm
05:55:20 <ski> you need to conjure up some `Token', and pass to it, it seems like
05:55:30 <Cheery> how could I do this? class Monad (m s) => MuscularMonad m
05:55:47 <niso> solonarv: oh, so line 72 defines it? "unprot :<|> prot = client api"
05:55:54 <solonarv> niso: correct
05:55:56 <ski> Cheery : what's `s' ?
05:56:00 <phadej> the problem is having api like UnprotectedAPI :<|> (Auth.Auth auths JwtSessionData :> AuthenticatedAPI)
05:56:16 <Cheery> ski: it's part of ST s
05:56:29 <ski> Cheery : is it mentioned in methods ?
05:56:44 <phadej> do `: kind! ClientM (API SomeConcreteAuths)` to see the problem
05:56:46 <Cheery> ski: yes
05:56:51 <Cheery> liftST :: ST s a -> m s a
05:56:58 <solonarv> Cheery: what sort of methods does this typeclass have? and what instances do you want it to have?
05:57:16 <ski> Cheery : perhaps add it as another parameter of your type class, then ?
05:57:45 <ski> Cheery : or, maybe, do `class (forall s. Monad (m s)) => MuscularMonad m where ...'
05:58:22 <solonarv> oh, this already exists actually
05:58:47 <phadej> https://hackage.haskell.org/package/monad-st-0.2.4.1/docs/Control-Monad-ST-Class.html
05:59:10 <solonarv> it's PrimMonad from primitive, too
05:59:24 <phadej> or that
05:59:26 <solonarv> that's the one I've seen more widely used
05:59:28 <phadej> (PrimMonad is better)
05:59:34 <Cheery> solonarv:     memoize :: (SimpleType s -> SimpleType s -> m s ()) -> SimpleType s -> SimpleType s -> m s ()
05:59:54 <Cheery> solonarv: err :: Error s -> m s z
06:00:27 <solonarv> I don't know how you wanted to use this exactly, but your liftST is stToPrim from primitive
06:00:50 <Cheery> solonarv: I'm not sure how I implement it exactly.
06:01:10 <Cheery> the SimpleType -thing there is annoying
06:01:22 <solonarv> oh, I see
06:02:26 <solonarv> translated into primitive's language this would look like: memoize :: PrimMonad m => (SimpleType (PrimState m) -> SimpleType (PrimState m) -> m ()) -> SimpleType (PrimState m) -> SimpleType (PrimState m) -> m ()
06:02:33 <Cheery> I'm trying to implemnet the "Simple Essence of Subtyping" in Haskell.
06:02:51 <solonarv> I don't know what that is
06:03:04 <Cheery> https://infoscience.epfl.ch/record/278576
06:03:11 <niso> phadej: where's the problem? ClientM (Auth.Auth '[JWT] JwtSessionData :> AuthenticatedAPI ) :: * = ClientM (Auth '[JWT] JwtSessionData :> AuthenticatedAPI)
06:04:03 * phadej takes a note to not try to help people with servant issues
06:04:53 <niso> phadej: why? was the question too bad/
06:04:59 <phadej> I explicitly said :kind! (note the bang), if the result is still headed with ClientM, there's something wrong
06:05:24 <niso> phadej: i used the bang
06:05:46 <niso> phadej: however, i skipped the space between ": kind!"
06:09:31 <niso> phadej: ah, something wrong because you expected * -> * due to auths?
06:09:46 <phadej> let me compile servant to try...
06:10:53 <niso> phadej: thanks :) i'm on day 3 now trying to fix this bug.
06:11:30 <niso> s/bug/error
06:14:04 <phadej> well, no, not trying.  https://github.com/haskell/network/issues/474
06:14:05 <dominik> Hi, I'm tring to `cabal install sqlite-simple` into my user's package directory. And after learning that I should run `cabal install --lib `sqlite-simple` this command executes successfully. However, I don't see sqlite installed in my user's package database; e.g. running `ghc-pkg list` doesn't show that the package is installed and also GHCi cannot find it.
06:14:05 <phadej> sorry
06:14:11 <dominik> does anyone know what I'm doing wrong?
06:15:02 <niso> phadej: if you want i can upload my nix expression
06:15:31 <phadej> niso: sorry, the "it will take only 5min to figure that out" run out
06:16:25 <niso> phadej: alright, thanks though :)
06:16:45 <dminuoso> niso: The problem looks very familiar. It's just a matter of "if you move this Auth combinator up", then it wont distribute the function argument containing the authentication info into the handlers.
06:16:48 <dminuoso> Perhaps?
06:17:53 <dminuoso> Consider: `unprot :<|> prot = client api` and ask yourself, what's the type of `prot`? Hint: GHC is already telling you this!
06:19:37 <dminuoso> I had the same annoyance with servant-client with BasicAuth.
06:22:34 <niso> dminuoso: if i understood you correctly, you are implying that it should be something like: `unprot :<|> Token -> prot = client api`?
06:24:09 <dminuoso> You seem to be thinking the right thing but expressing it wrong.
06:25:10 <dminuoso> Ah, even worse. I think there's not even examples in the README here.
06:26:00 <niso> dminuoso: exactly, there is no example in the docs / most example projects on github are without tests, couldn't find a blogpost either
06:26:49 <dminuoso> niso: So my rough guess is this: As the client, you must be supplying that bearer token somehow.
06:27:34 <alp> dminuoso, I did write a bit of prose to help with figuring out the result types of calls to 'client' etc: https://docs.servant.dev/en/stable/cookbook/structuring-apis/StructuringApis.html
06:27:43 <alp> perhaps it should be augmented with more explanations/example/...
06:29:19 <alp> something that spells out the "rules" more explicitly, perhaps. the rules dictated by the type families involved ('Client', 'ServerT', ...)
06:29:26 <dminuoso> niso: Imagine the api had just a single proteted endpoint, then the way to obtain a client is, presumably, something like `endpointClient = client api bearerToken`, or if its multiple ones, `endpointA :<|> endpointB = client api bearerToken` - I think that's the expected way.
06:32:40 <dminuoso> The ergonomics of this is terrible, since you cant have top level bindings for those endpoint clients anymore. :(
06:33:10 <niso> dminuoso: makes sense! i tried that before and was wondering how i can get bearerToken into the scope, as it turns out, i just have to make it a function! (sorry haskell newbie here)
06:35:08 <niso> dminuoso: does this mean i'd have a function there, returning a valid token (if authenticated), or an empty one if not?
06:35:51 <dminuoso> Yeah, that's your own business. It does not appear that servant-auth-client has any sort of automation for this.
06:37:36 <dminuoso> niso: If `client` would distribute the Auth down into the endpoints, you could pattern match as usual and then obtain some `Token -> ... -> ClientM ...` for each endpoint.
06:37:46 <dminuoso> But sadly it doesnt. Perhaps alp knows of a way to force distribution?
06:39:20 <dminuoso> Alternatively, you could just move `Auth` down to each endpoint yourself. That just increases testing burden to ensure you didn't forget it on any endpoint.
06:42:38 <niso> dminuoso: guess i'll try both, however at the moment i'm leaning towards not moving Auth down to the endpoints, since this would get rather complex with bigger apis
06:43:10 <dminuoso> You will have complexity burden either way. Then generating clients will become an annoyance.
06:45:19 <niso> dminuoso: alright, thanks for your help!
06:45:49 <dminuoso> One way I approached (I ended up with something far more elaborate for some reasons), is having some `data Endpoints = Endpoints { endpointA ::  ... ClientM ...; endpointB :: ... ClientM ... }`, then some `getEndpoints :: Token -> Endpoints`, then to run some individual endpoint client you'd:
06:45:59 <dminuoso> endpointA (getEndpoints someToken) ... argsForEndpointA ...
06:46:18 <dminuoso> But then you'll have to manually construct that Endpoints dictionary.
06:46:22 <niso> dminuoso: ah, that looks similair to the cachix client
06:48:51 <dminuoso> niso: Yeah, they appear to be using fromservant
06:49:01 <dminuoso> *fromServant which does that above translation through generics
06:50:18 <dminuoso> Im not familiar with how that works or the ergonomics of it, so I cant help you with that.
06:50:59 <dminuoso> But it seems it would be the tool you need.
06:52:01 <niso> dminuoso: uhm fromservant?
06:52:14 <dminuoso> *fromServant
06:52:22 <dminuoso> https://hackage.haskell.org/package/servant-0.18/docs/Servant-API-Generic.html#v:fromServant
06:52:42 <dminuoso> It's either that, or distributing Auth into the endpoints. :P
06:53:02 <dminuoso> (Or some other custom solution to the above problem)
06:53:38 <niso> dminuoso: if i'd use fromServant it would mean that i'd need some kind of multi-starge buil process for tests right? (vs calling servant-client directly)
06:54:36 <dminuoso> Huh?
06:54:55 <niso> dminuoso: just noticed all the typos, sorry
06:55:25 <dminuoso> https://docs.servant.dev/en/stable/cookbook/generic/Generic.html
06:55:36 <dminuoso> Contains some very short sketches how generics servants is used.
06:56:22 <dminuoso> Once you use fromServant, you can use genericClient or genericClientHoist
06:56:43 <dminuoso> How many endpoints do you plan on having?
06:57:58 <niso> right now i'm only working on a dummy project ~10 endpoints, however if everthing works out i'd like to base a couple of microservices on it
06:58:36 <niso> which will variy in size
06:58:44 <niso> dminuoso: ^
06:59:08 * niso is assuming that he'll get compftable with haskell
07:08:56 <maerwald> microservices via HTTP?
07:10:18 <niso> maerwald: yes (to keep the initial cost of moving the stack low), at a later point i'll migrate to a message bus system (if required)
07:11:11 <maerwald> well, don't commit to a stack you can't migrate later
07:12:34 <niso> maerwald: i won't, but the service will need http interfaces anyways, thus i picked http as a starting point
07:16:50 <nij> Hello.. I have a question related to haskell, but not completely.
07:17:24 <nij> I'm using emacs/org-mode/org-babel with haskell, but the behavior are different from native haskell.
07:17:37 * Clint squints.
07:17:44 <nij> I hope I can get some luck here.. anyways, here is the code and the result:
07:17:48 <nij> https://dpaste.com/38QJZAKJ4
07:18:10 <nij> As you can see in the results, the function `calories` failed to be parsed.
07:18:31 <nij> However, putting this into a `.hs` file and run by `ghci` render the result well.
07:18:58 <nij> Are there some potential errors that `ghci` is smart enough to dodge? Did I miss anything?
07:20:21 <GreeboSnabble> > myPlus 2 2
07:20:23 <lambdabot>  7
07:21:52 <merijn> nij: Possibly emacs is messing up if you mix tabs and spaces?
07:22:22 <c_wraith> yeah, that's very likely an indentation problem of some sort
07:22:26 <nij> merijn: lemme check..
07:22:57 <nij> AH! I see... emacs parse this directly into ghci.
07:23:21 <nij> and in fact, if I type this into ghci directly, same error occur, b/c there're multiple-line definitions
07:23:26 <nij> to fix it I need to put
07:23:27 <nij> :{
07:23:28 <nij> ...
07:23:28 <nij> :}
07:37:27 <asheshambasta> A whole sunday of struggling with type level programming. 
07:37:56 <asheshambasta> Interesting; but I find myself questioning how much of it is really advantageous and how much of it is just playing around. 
07:39:09 <asheshambasta> anyway; apologies for the rant.
07:43:53 <merijn> Honestly, most of it is playing around
07:44:17 <merijn> asheshambasta: At least, going by your questions in the past :p
07:45:06 <asheshambasta> yeah; again; sorry about that. I have quite a limited understanding of type-level stuff in haskell.
07:46:11 <merijn> asheshambasta: My point was more that "type level stuff" is like salt, a little bit goes a long way and I see too many people going overboard in trying to do everything via types and it just leads to sadness and code that is hell to refactor :p
07:47:07 <asheshambasta> I completely agree. Every single time I've tried to go in a bit deep I've deeply regretted it (pun unintented)
07:47:50 <asheshambasta> but then again, like Servant; but when I read type-level code, a lot of it starts looking like duct-tape code just to make GHC happy and somehow let the code pass. 
07:48:22 <asheshambasta> (I like Servant**)
07:49:52 <asheshambasta> I must shut up now.
07:52:02 <dmj`> asheshambasta: servant makes more sense when you think of it as generic programming
07:52:19 <phadej> good way to think about it
08:05:26 <frdg> question about how to add a token header in an http request using http-conduit. https://dpaste.org/4aJ4
08:07:56 <frdg> the api I am trying to use: https://www.ncdc.noaa.gov/cdo-web/webservices/v2#gettingStarted
08:09:52 <dmj`> frdg: hAuthorization should be "token"
08:10:38 <frdg> wow it works!
08:16:24 <dmj`> frdg: \o/
09:21:01 <sheepfleece> Hello, can somebody point out paoers or litrature I should read to understand, at least on high-level, what delimited continuations are about.
09:22:18 <dminuoso> sheepfleece: Did you read https://wiki.haskell.org/Library/CC-delcont?
09:22:31 <dminuoso> It contains a good throrough description, as well as a good literature list at the end
09:22:48 <sheepfleece> I didn't, thank you.
09:35:02 <dminuoso> I have a sum of nullary constructors `data Cm = A | B | C ...`. Now, I want to associate each constructor to a type in such a way, that I could do `f :: Cm -> IO (Ty Cm)`. Is singletons my only bet here?
09:35:20 * hackage yesod 1.6.1.0 - Creation of type-safe, RESTful web applications.  https://hackage.haskell.org/package/yesod-1.6.1.0 (MichaelSnoyman)
09:35:41 <dminuoso> (The signature is pseudo only, of course)
09:42:19 * hackage hedis 0.12.14 - Client library for the Redis datastore: supports full command set,pipelining.  https://hackage.haskell.org/package/hedis-0.12.14 (k_bx)
09:46:06 <monochrom> Not sure why the IO, but both "Cm -> IO ???" and "Cm -> ???" requires ??? to have kind *
09:46:55 <monochrom> "Cm ->" means that whether it's A or B or C is statically unknown.
09:47:34 <monochrom> So if anything, ??? has to represent some form of dynamic typing.
09:48:41 <monochrom> Combined with ??? :: *, ??? uses values to represent types.
09:49:32 <monochrom> singleton sounds like having one value corresponding to one type.  However, ??? admits 3 values corresponding to 3 types.
09:49:41 <monochrom> So, threesometon? :)
09:55:30 <monochrom> Perhaps "Cm ->" is the pseudocode? :)
09:56:48 <monochrom> Because "Proxy Cm -> ..." frees you from the consequences I said about "Cm ->", and is probably more relevant to the mention of singleton.
09:57:19 <monochrom> ??? may be a type family?
09:57:36 <monochrom> But this is getting insane. :)
11:35:02 <Polesch> I'm a complete beginner at Haskell and just trying to get the syntax right, what I am doing wrong here? https://pastebin.com/NxybGGDE
11:35:28 <merijn> Polesch: You don't have an "= " and definition after otherwise
11:35:42 <merijn> Polesch: Presumably you meant "otherwise = False"
11:35:48 <Polesch> Yes
11:36:06 <Polesch> I thought it would output false by defauly
11:36:21 <Polesch> But now it worked, yeah
11:36:31 <merijn> How is the compiler supposed to guess it "should" output false?
11:37:36 <Polesch> I just had that impression from a tutorial, probably misunderstood.
11:37:45 <merijn> What tutorial is that?
11:43:36 <Polesch> I don't remember, but it's obviously nonsensical if I think about it.
11:46:35 <ski> Polesch : it's better to connect your conditions by boolean operators, rather than have the result in branches be explicit booleans like `False' and `True'
11:47:24 <Polesch> Maybe I will know how to do that soon
11:48:14 <ski> Polesch : when will `isLeapYear n' be `True' ? can you briefly explain that, in words ?
11:48:47 <Polesch> If the integer is divisible by 4 but not 100, unless it's also divisible by 400
11:49:26 <ski> could you replace "unless" by another ("more logic") word ?
11:51:20 <Polesch> Except? If not?
11:52:03 <enikar> Polesch: think about logical operand.
11:52:04 <Polesch> Thinking about if-then-else?
11:52:30 <ski> not directly thinking about that, no
11:52:32 <Polesch> and instead of &&?
11:52:43 <ski> (although it would be possible to do a detour via that)
11:53:24 <enikar> yes, && and another simple logical binary operator.
11:53:49 <Polesch> or?
11:54:12 <ski> try it, and see whether it sounds reasonable ?
11:55:03 <ski> (remember that logical "or" is almost always an inclusive one, that permits both operands to be `True')
11:55:20 <monochrom> The available logical operators are && and ||
11:55:26 <monochrom> also "not"
11:55:40 <enikar> that's right.
11:55:50 <Polesch> Right
11:55:59 <monochrom> If you know these three are available, I'm sure you can figure it out.
11:56:20 <Polesch> indeed, will give it a shot
11:58:02 <ski> sometimes it can be useful to use logical implication, to express conditions like this
12:00:58 <monochrom> Implication is a red herring in this particular exercise, despite the "natural" use of the word "unless".
12:01:35 <monochrom> "true if cond1" and "true unless cond2" are spurrious implications.
12:02:41 <Polesch> Anyone happen to know how to run the test cases for Exercism?
12:38:29 <dsal> Polesch: I've not tried it in a while, but last time I did, it was just `stack test`
12:38:51 <Polesch> I figured it out eventually
12:46:24 <ddellacosta> a Monad.Control.guard variant like Applicative f => Bool -> a -> f a is something I want
12:46:35 <ddellacosta> I guess it's in protolude?
12:50:23 <merijn> :t guard
12:50:26 <lambdabot> Alternative f => Bool -> f ()
12:50:35 <merijn> ddellacosta: Sounds like you just want, well, guard :p
12:50:44 <merijn> Since that only requires Alternative
12:51:14 <merijn> ddellacosta: Applicative as a class doesn't make a lot of sense with that signature
12:55:52 <ddellacosta> merijn: well I'm trying to use this with Maybe basically, and I want to return a pure value when my calc. succeeds and Nothing otherwise
12:56:09 <ddellacosta> basically mucking about because I don't want to write out a `case` or `if` lol
12:56:48 <ddellacosta> but yeah I guess applicative doesn't make much sense there
12:57:00 <merijn> ddellacosta: Right, so Alternative ;)
12:57:11 <merijn> > 5 <$ guard False
12:57:13 <lambdabot>  error:
12:57:13 <lambdabot>      â€¢ Ambiguous type variable â€˜f0â€™ arising from a use of â€˜show_M288693775018...
12:57:13 <lambdabot>        prevents the constraint â€˜(Show (f0 Integer))â€™ from being solved.
12:57:20 <merijn> > 5 <$ guard False :: Maybe Int
12:57:22 <lambdabot>  Nothing
12:57:27 <merijn> > 5 <$ guard True :: Maybe Int
12:57:29 <lambdabot>  Just 5
12:57:48 <ddellacosta> huh
12:57:58 * ddellacosta goes back and re-reads the type sig for guard
12:58:14 <merijn> It's Alternative
12:58:27 <merijn> Anyway, it's still irrelevant because Maybe is a Monad and MonadPlus too ;)
12:58:34 <ddellacosta> yeah no that was meant more as, I'm confused about something and I have to go back and figure out what that is
12:59:11 <ddellacosta> thanks though, you helped me realize I was confused!
13:00:05 <ddellacosta> ah nevermind it's the (<$) that snuck up on me. Anyways thanks merijn , this is exactly what I was looking for!
13:01:21 <merijn> :)
13:05:34 <murphy_> Good afternoon - this may be a stupid question, but is it possible to send commands to be interpreted by a running GHCI repl over a socket instead of by pasting text ? 
13:06:29 <merijn> murphy_: No, not unless you implement that yourself
13:06:43 <merijn> murphy_: But depending on what you're trying to do, you might not need that
13:06:56 <murphy_> I'd be happy to implement something like that myself - do you know of any libraries that would give me a jumping off point to start doing it / 
13:06:58 <murphy_> ?
13:07:16 <merijn> murphy_: Well, why do you want to do it over a socket?
13:08:35 <murphy_> long story, but there is a process that I've been working with called Tidal (it's a pattern sequencing language for music) that communicates with another process called Supercollider
13:08:58 <merijn> murphy_: ok
13:09:02 <murphy_> it sends messages to Supercollider via OSC and Supercollider interprets the messages and playes them back - 
13:09:16 <merijn> murphy_: But do you just wanna talk to ghci on the same machine?
13:09:20 <murphy_> what I want to be able to do is generate code (both haskell and within the DSL) to send back to the REPL that Tidal is running in
13:09:28 <murphy_> yes, on the same machine
13:09:32 <merijn> Because then you can just spawn ghci as a subprocess and talk over stdin...
13:09:37 <merijn> No need for sockets or anything
13:09:46 <murphy_> I'm trying to avoid using stdin
13:10:01 <merijn> Why?
13:11:09 <murphy_> because ultimately I want to have this pretty automated and have code bouncing back and forth between the two processes, and copy/pasting text seems somewhat clunky to me
13:11:38 <merijn> murphy_: It's gonna be text regardless
13:11:43 <merijn> ghci only understands text
13:11:58 <merijn> So you can do "text over a socket" or "text over stdin" and the latter of those is much less work :p
13:12:11 <murphy_> yeah, I can already do that now hah
13:12:32 <murphy_> it just seems like a really strange way to do things to me
13:13:12 <merijn> Why?
13:13:21 <merijn> Like, what else could you possibly do?
13:13:35 <dolio> Why is it weird to use a file handle and not weird to use a socket?
13:14:08 <murphy_> generally when I'm doing interprocess communication, I'm doing it via something like shared memory, or message packets, or something else, not via text. 
13:14:27 <merijn> murphy_: Sure, but what do you expect ghci to understand besides text?
13:14:35 <merijn> It's a program made for textual interaction with people
13:14:43 <murphy_> I don't know, that's why I'm asking the question
13:15:07 <murphy_> I may also be framing the question wrong
13:15:24 <murphy_> and there may be another way to think about it - i.e. having some other sort of listener that takes in text and interprets it
13:15:26 <merijn> Very possibly :p
13:16:07 <murphy_> another part of it is that I don't want to have this be specific to my vim environment, and writing vimscript is an exercise in frustration
13:17:29 <murphy_> so, let's assume that I'm asking the question wrong - is there any library for listening for text or, barring that, any library that takes text and evaluates it as if it were code ? 
13:18:14 <murphy_> The process *does* have an inbound OSC listener, so I could theoretically package the code as text within there, but would need some way to evaluate it
13:19:10 <murphy_> probably this? http://hackage.haskell.org/package/plugins-1.6.0/docs/System-Eval-Haskell.html
14:24:28 <dminuoso> Is there a pokeByteString Im not seeing in bytestring, with something like `ByteString -> Ptr a -> IO ()`? I mean I can trivially just pattern match on ByteString and withForeignPtr + memcpy, but Im hoping for some API to do this
14:26:36 <phadej> useAsCString(Len)
14:26:51 <phadej> and its unsafe variant
14:27:11 <phadej> https://hackage.haskell.org/package/bytestring-0.10.12.0/docs/Data-ByteString.html#g:25
14:27:44 <dminuoso> phadej: useAsCString would do an additional memcpy though. I cant reasonably expect GHC to get rid of that, can I?
14:27:59 <phadej> "and its unsafe variant"
14:28:19 <phadej> hit key `s` in haddocks to open search box!
14:29:09 <dminuoso> Oh, learn something new every day. :)
14:29:54 <dminuoso> unsafeUseAsCStringLen seems exactly what I was needing
14:31:01 <dminuoso> phadej: I love the `s` key shortcut. This is damn handy! :)
14:43:06 <frdg> can anyone reccomend a reading about bytestrings and lazy bytestrings?
14:43:49 * hackage aeson-with 0.1.2.0 - withXField combinators for aeson  https://hackage.haskell.org/package/aeson-with-0.1.2.0 (locallycompact)
14:45:49 * hackage ixset-typed-conversions 0.1.0.1 - Conversions from ixset-typed to other containers.  https://hackage.haskell.org/package/ixset-typed-conversions-0.1.0.1 (locallycompact)
14:49:14 <sm[m]> frdg: how's bytestring's own docs ?
14:51:58 <frdg> I was looking more for a paper
14:53:27 <wavemode_> lol you don't hear that often
14:55:17 <wavemode_> usually people complain that there's no docs and just a paper
14:56:03 <jumper149> I think I just wrote a monad-transformer-transformer x)
14:56:12 <MarcelineVQ> a (strict) ByteString is an immutable chuck of memory, literally a string of raw bytes managed by ghc's gc. a lazy bytestring is a list of strict bytestrings you can consume as you need
14:56:56 <Rembane> frdg: Like this? https://link.springer.com/chapter/10.1007/978-3-540-69611-7_3
14:57:34 <MarcelineVQ> I learned a fair bit about them reimplementing some of the bytestring lib myself, that could be instructive, or not at all, depending on how you like to use your time :>
15:00:09 <dolio> Last I checked, bytestring doesn't actually do any fusion, so some of that paper is going to be misleading.
15:01:02 <MarcelineVQ> ye, but the paper that is from is full of interesting things
15:02:03 <MarcelineVQ> https://link.springer.com/book/10.1007/978-3-540-69611-7 that is
15:02:22 <c_wraith> ]
15:02:34 <phadej> oh thank god bytestring doesn't have fusion
15:02:39 <phadej> even the paper mention that
15:02:40 <MarcelineVQ> we have Builders instead of fusion for lazy lists
15:03:26 <MarcelineVQ> *lazy lists of bytestrings
15:04:49 * hackage jukebox 0.5.2 - A first-order reasoning toolbox  https://hackage.haskell.org/package/jukebox-0.5.2 (NickSmallbone)
15:05:22 <Rembane> phadej: Why thank god because lack of fusion? <- just add grammar to my question and it will make sense
15:06:08 <phadej> Because it would made performance unpredicatable, in places where you'd really rather prefer deterministic slowness
15:06:26 <MarcelineVQ> for me: fusion rules are notoriously finnicky so having them for bytestring could make it hard to readon about their peformance, which isn't what you want for such a simple tool
15:06:47 <MarcelineVQ> gosh you type fast :>
15:06:57 <phadej> I practice every day!
15:06:58 <Rembane> phadej: That's really clear when you say it. 
15:08:09 <dolio> The paper is mostly about fusion in the context of bytestring.
15:11:08 <c_wraith> I don't understand that viewpoint
15:11:16 <c_wraith> list fusion doesn't make lists perform worse.
15:11:22 <c_wraith> Sometimes it just makes them perform better.
15:11:37 <c_wraith> If you plan for the worst case, sometimes you get a nice surprise.
15:11:45 <phadej> yes, that's the point.
15:11:56 <c_wraith> If you do the same thing with bytestring, worst case the performance would be the same as it is now
15:11:57 <phadej> if you are handling bytestrings you are writing low-level code anyway
15:12:36 <phadej> also, fusion rules are not free  (compilation time, complexity of the library...)
15:19:21 <MarcelineVQ> RULES sidesteps some (written)code complexity at least. I've been using a bit of case-based fusion lately and it for sure adds some complexity, e.g.  data List a = Nil | Cons a (List a) | Build (forall b. (a -> b -> b) -> b -> b)
15:20:03 <frdg> Rembane: thanks for that link
15:20:08 <Rembane> frdg: np 
15:20:40 <MarcelineVQ> Having to use foldr everywhere I can and also handle the Build case everywhere adds a fair bit of cognitive overhead. Sure works though
15:21:19 <Rembane> MarcelineVQ: What does the Build case help you with? 
15:22:02 <c_wraith> makes fusion explicit
15:22:39 <c_wraith> if foldr encounters a build constructor, it reduces to a non-recursive function application
15:22:50 <Rembane> That's cunning. 
15:23:59 <MarcelineVQ> what I like about it is that it's applicable to any algebraic datatype
15:24:09 <MarcelineVQ> that and the language I'm using doesn't have RULES
15:29:04 <MarcelineVQ> Rembane: that forall b is pretty cunning too, it keeps you honest when constructing a Build, since it must work for any choice of b you're not allowed to make assumptions or otherwise choose what b is. This ensures you're not breaking any laws about the relation of foldr build. If you're interested I could try and find the paper I saw this stuff
15:30:00 <Rembane> MarcelineVQ: That's really nice, please try to find the paper. 
15:30:02 <MarcelineVQ> And it is really frequent that I've wanted that b to be something else for some particular function, so it's a good thing it can't be
15:32:20 <c_wraith> I mean, it's basically the core idea from the foldr/build fusion paper, except exposed to the user
15:33:46 <ski> MarcelineVQ : hm, did you figure out that `zipWith' using `foldr' ?
15:34:32 <MarcelineVQ> ski: Not in a way I liked, I haven't really looked at it since that convo though
15:34:45 * ski nods
15:34:57 <c_wraith> it's not that hard to get a zipWith that uses foldr over *one* argument.  There's no way to write it so that it uses foldr over both.
15:35:11 <ski> yes there is
15:35:17 <MarcelineVQ> Rembane: https://www.semanticscholar.org/paper/Monadic-Augment-and-Generalized-Short-Cut-Fusion-By-Ghani-Johann/773539939f7825d0431e587e000e2bc1d524ba21 is where I saw these idea first, but I'm still trying to nail down where I saw that it can be used in data Constuctor instead of as rules
15:37:09 <ddellacosta> c_wraith: is this the paper you were talking about? https://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.149.3108
15:37:26 <Rembane> MarcelineVQ: Thank you! 
15:39:25 <MarcelineVQ> hey http://theses.gla.ac.uk/4817/1/1996gillphd.pdf is pretty neato
15:39:29 <MarcelineVQ> quite thorough
15:40:20 <c_wraith> that's one of the main papers, yes
15:40:28 <MarcelineVQ> it even has a addressing of zip
15:46:01 <ski> c_wraith : i figured a way to do it, some thirteen years ago. then i noticed Oleg had also done so
15:50:59 <ddellacosta> thanks
15:52:52 <dolio> ski: Your solution isn't modeled by ZFC, though, so we have to throw it out. :)
15:54:03 <ski> it's not strictly positive, but it's positive
15:55:04 <dolio> Right.
16:02:05 <cheater> hi
16:02:13 <cheater> i have a question about the code for Warp here https://wiki.haskell.org/Web/Servers
16:02:36 <cheater> why does the code do this? mconcat $ map copyByteString [ "yay" ]
16:03:08 <cheater> i don't understand the point of copyByteString, and I don't know why you'd do the whole thing where you wrap a single value in a list, map over that list, then unwrap it from a list again.
16:04:18 <solonarv> consistency with the other example ('index') where there are actually two values to mconcat together, I guess
16:04:25 <solonarv> still seems pretty pointless to me though
16:05:15 <cheater> what about copyByteString?
16:06:42 <solonarv> that has a type like 'ByteString -> Builder' so it's actually doing something
16:06:45 * ski . o O ( `foldMap copyByteString [ "yay" ]' )
16:07:00 <solonarv> although I suspect you could've just written "yay" in place of that whole mess
16:07:38 <solonarv> ah, apparently not
16:08:05 <cheater> why not?
16:08:37 <solonarv> there's no IsString instance for Builder
16:08:42 <solonarv> which is actually a reasonable choice tbh
16:09:29 <cheater> not sure why that matters
16:16:56 <cheater> solonarv: can you explain?
16:28:20 * hackage summer 0.1.0.0 - An implementation of extensible products and sums  https://hackage.haskell.org/package/summer-0.1.0.0 (sgschlesinger)
16:28:25 <frdg> why isnt HUGS really talked about anymore? It seems that in the past it was very important to Haskell.
16:29:00 <cheater> it's never really been that important and no one has been developing it for over a decade
16:29:31 <cheater> it was mostly just a compiler some people kept around out of some sort of purity argument
16:29:47 <cheater> it's never been useful or popular
16:31:06 <frdg> oh ok
16:31:15 <wavemode_> it was _fast_
16:31:32 <wavemode_> but never particularly useful besides that fact
16:31:38 <cheater> was it really
16:31:54 <int-e> cheater: ndm was a big fan.
16:32:02 <cheater> i'll go out on a limb and guess most larger projects weren't supported by it
16:32:13 <cheater> int-e: people are fans of obscure things for many reasons
16:32:30 <int-e> cheater: winhugs in particular. I think the reason was very quick loading/type checking, that is, it was a fast way to catch errors.
16:32:46 * ski was just thinking of WinHugs and WinGHCi
16:41:04 <dolio> Oh, I guess constructor classes were no big deal. Should have been left out of Haskell 1.3 and subsequent versions.
16:45:02 <iqubic> @unpl ((<*>) .) . fmap
16:45:02 <lambdabot> (\ x x0 -> (<*>) (fmap x x0))
16:48:23 <iqubic> Wait... that's just liftA2
16:50:02 <dolio> Yes.
18:59:59 <hololeap> % :t (\ x x0 -> (<*>) (fmap x x0))
18:59:59 <yahb> hololeap: Applicative f => (a1 -> a2 -> b) -> f a1 -> f a2 -> f b
19:00:43 <hololeap> Oh...
19:02:06 <hololeap> (\f x -> (<*>) (fmap f x)) === (\f x y -> (f <$> x <*> y))
19:43:55 <hololeap> speaking of... someone shared a tip in here a while back about ways to use (<$) (<$>) (<*) and (<*>) where it would discard certain arguments
19:46:39 <hololeap> for instance you could rewrite `liftA3 (\x _ z -> mappend x z)` using just those "operators"
19:47:00 <hololeap> anyone have any idea what i'm talking about?
19:47:53 <c_wraith> mappend <$> thing1 <* thing2 <*> thing3
19:48:23 <hololeap> c_wraith: right. so what are the rules to this pattern in general?
19:48:50 <c_wraith> leave out the > to "ignore" the next parameter.
19:49:00 <hololeap> ok. that's simple
19:49:34 <c_wraith> take a look at how they associate to get a handle on how that works
19:50:12 <jle`> any associative bifunctors with potentially more than one item per type?
19:50:32 <hololeap> % :i (<$>)
19:50:32 <yahb> hololeap: (<$>) :: Functor f => (a -> b) -> f a -> f b -- Defined in `Data.Functor'; infixl 4 <$>
19:50:37 <jle`> the only ones i've seen are (,), Either, These, and those all really only have at most 1 item of a given type in the type parameter
19:51:11 <c_wraith> hololeap: they're all infixl 4
19:51:14 <hololeap> :t \f x y z -> (((f <$> x) <* y) <*> z)
19:51:15 <lambdabot> Applicative f => (a1 -> a2 -> b1) -> f a1 -> f b2 -> f a2 -> f b1
19:51:33 <hololeap> yeah i get it now
19:52:21 <hololeap> it makes complete sense why `(f <$> x) <* y` would return `f <$> x`
19:52:25 <hololeap> ish...
19:52:42 <hololeap> and evaluating y's action
19:52:44 <jle`> well, it wouldn't return the same thing, just something of the same type
19:52:55 <jle`> and the same result (if they exist)
19:54:40 <hololeap> interesting. that actually frames it differently than `liftA3 $ \x _ z`
19:54:50 * hackage summer 0.1.1.0 - An implementation of extensible products and sums  https://hackage.haskell.org/package/summer-0.1.1.0 (sgschlesinger)
19:54:59 <c_wraith> > (+ 1) <$> [1..5] <* []
19:55:01 <lambdabot>  []
19:55:38 <hololeap> now, instead of looking like it takes three arguments lifted inside an `f', it looks like it takes two and runs an arbitrary "action" in between each
19:56:05 <hololeap> (just thinking/observing out loud)
19:58:15 <hololeap> % :i ZipList
19:58:16 <yahb> hololeap: type ZipList :: * -> *; newtype ZipList a = ZipList {getZipList :: [a]}; -- Defined in `Control.Applicative'; instance Alternative ZipList -- Defined in `Control.Applicative'; instance Applicative ZipList -- Defined in `Control.Applicative'; instance Eq a => Eq (ZipList a) -- Defined in `Control.Applicative'; instance Functor ZipList -- Defined in `Control.Applicative'; instance Ord a => Ord (ZipList 
19:58:43 <hololeap> :% (+1) <$> ZipList [1..5] <* ZipList [6..10]
19:58:53 <hololeap> % (+1) <$> ZipList [1..5] <* ZipList [6..10]
19:58:54 <yahb> hololeap: ZipList {getZipList = [2,3,4,5,6]}
19:59:39 <hololeap> % (+) <$> ZipList [1..5] <* ZipList [6..10] <*> ZipList [10,20..50]
19:59:39 <yahb> hololeap: ZipList {getZipList = [11,22,33,44,55]}
20:01:02 <hololeap> interesting how ZipList's applicative instance is "additive" compared to regular list's applicative instance which is "multiplicative"
20:02:29 <hololeap> % (+) <$> [1..5] <* [6..10] <*> [10,20..50]
20:02:29 <yahb> hololeap: [11,21,31,41,51,11,21,31,41,51,11,21,31,41,51,11,21,31,41,51,11,21,31,41,51,12,22,32,42,52,12,22,32,42,52,12,22,32,42,52,12,22,32,42,52,12,22,32,42,52,13,23,33,43,53,13,23,33,43,53,13,23,33,43,53,13,23,33,43,53,13,23,33,43,53,14,24,34,44,54,14,24,34,44,54,14,24,34,44,54,14,24,34,44,54,14,24,34,44,54,15,25,35,45,55,15,25,35,45,55,15,25,35,45,55,15,25,35,45,55,15,25,35,45,55]
20:03:25 <hololeap> % (+) <$> [1..5] <* [undefined] <*> [10,20..50]
20:03:25 <yahb> hololeap: [11,21,31,41,51,12,22,32,42,52,13,23,33,43,53,14,24,34,44,54,15,25,35,45,55]
20:03:43 <hololeap> % (+) <$> [1..5] <* [] <*> [10,20..50]
20:03:43 <yahb> hololeap: []
20:10:11 <hololeap> nvm, ZipList isn't really additive
20:10:33 <hololeap> it behaves more like `min` wrt lengths of lists
20:19:20 <ski> hololeap : it's like "additive" in the sense of linear logic
20:20:36 <ski> (also cf. "pointwise"/"coordinatewise")
20:31:36 <haskell_not_pasc> hello, is there some place where i could learn about writing optimized haskell
20:34:05 <Axman6> that was quick, I guess they figured it out!
20:35:11 <jamestmartin> Given `newtype Compose (f :: j -> *) (g :: i -> j) (a :: i) = Compose { getCompose :: f (g a) }`, is it possible to get a function `Compose f (Compose g h) a -> Compose (Compose f g) h a`?
20:36:40 <Axman6> it probably needs com constraints on f, g and h
20:37:21 <Axman6> @djinn Compose f (Compose g h) a -> Compose (Compose f g) h a
20:37:21 <lambdabot> Error: Undefined type Compose
20:37:24 <Axman6> :(
20:37:55 <jamestmartin> com constraints?
20:37:58 <c_wraith> both of those types have the same unwrapped representation.  worst case, coerce should do it.
20:38:00 <Axman6> the simple answer is coerce though =)
20:38:31 <Axman6> uh, com = some, no idea how that happened
20:38:51 <Axman6> thinking ahead to the code I was about to write
20:39:32 <jamestmartin> Data.Coerce.coerce rejects it;  Couldn't match representation of type â€˜f (g (h a))â€™ with that of â€˜f (Compose g h a)â€™
20:40:03 <jamestmartin> if unsafeCoerce would be safe in this case, then that's good enough for me too
20:40:17 <jamestmartin> though if there's a way to do it without it that would be cool
20:43:44 <ski> @djinn-add data Compose f g a = MkCompose (f (g a))
20:43:53 <ski> @djinn Compose (Compose f g) h a -> Compose f (Compose g h) a
20:43:53 <lambdabot> Error: kind error: (KStar,KVar 4)
20:46:18 <ski> @type Compose . Compose . fmap getCompose . getCompose
20:46:19 <lambdabot> forall k k2 (f :: * -> *) (g1 :: k -> *) (g2 :: k2 -> k) (a :: k2). Functor f => Compose f (Compose g1 g2) a -> Compose (Compose f g1) g2 a
20:46:31 <ski> @type Compose . fmap Compose . getCompose . getCompose
20:46:33 <lambdabot> forall k2 k3 (f1 :: * -> *) (f2 :: k2 -> *) (g :: k3 -> k2) (a :: k3). Functor f1 => Compose (Compose f1 f2) g a -> Compose f1 (Compose f2 g) a
20:47:29 <ski> jamestmartin ^
20:49:21 <jamestmartin> ski: sure, but why should I require that f1 be a functor if they should be representationally identical?
20:49:55 <jamestmartin> and if it's impossible to do safely without the functor constraint, would unsafeCoerce be safe?
20:52:21 <ski> jamestmartin : what if `f' is a GADT, or a type family ?
20:54:23 <ski> say `data F :: * -> * where C :: f (g a) -> F (Compose f g a)'
20:56:25 <ski> so `Compose (C [Nothing,Just False])' has type `Compose F (Compose [] Maybe) Bool', but `Compose (Compose F []) Maybe Bool' in uninhabited, since `Compose F [] (Maybe Bool)' is
21:01:52 <jamestmartin> wow, what an awful data type. but also fair enough? so the functor constraint *is* strictly necessary?
21:05:03 <ski> (i suppose i ought to have also expanded the latter one there as `F [Maybe Bool]', for completeness. to show more clearly that it's uninhabited ..)
21:05:21 <ski> it seems to, to me ?
21:07:59 <jamestmartin> okay, thank you
21:11:27 <ski> hm, i wonder whether one could say that GADTs and type families add intensionality
21:12:02 <ski> (in the sense of referentially opaque contexts in modal logic)
21:13:12 <dansho> what's the way to index a list in ClassyPrelude?
21:23:20 <dansho> found it: unsafeIndex
21:27:14 <hololeap> % :t Compose . Compose . fmap getCompose . getCompose :: Functor f => Compose f (Compose g h) a -> Compose (Compose f g) h a
21:27:14 <yahb> hololeap: ; <interactive>:1:66: error: Not in scope: type constructor or class `Compose'; <interactive>:1:77: error: Not in scope: type constructor or class `Compose'; <interactive>:1:95: error: Not in scope: type constructor or class `Compose'; <interactive>:1:104: error: Not in scope: type constructor or class `Compose'
21:27:38 <ski> % :m + Data.Functor.Compose
21:27:38 <yahb> ski: 
21:27:47 <hololeap> % :t Compose . Compose . fmap getCompose . getCompose :: Functor f => Compose f (Compose g h) a -> Compose (Compose f g) h a
21:27:47 <yahb> hololeap: forall k k1 (f :: * -> *) (g :: k -> *) (h :: k1 -> k) (a :: k1). Functor f => Compose f (Compose g h) a -> Compose (Compose f g) h a
21:28:09 <hololeap> ski beat me to it
21:31:02 <ski> @let onCompose :: (f0 (g0 a0) -> f1 (g1 a1)) -> (Compose f0 g0 a0 -> Compose f1 g1 a1); onCompose f = Compose . f . getCompose
21:31:04 <lambdabot>  Defined.
21:31:55 <ski> @type onCompose (Compose . fmap getCompose)
21:31:56 <lambdabot> forall k4 k3 (f :: * -> *) (g :: k4 -> *) (g1 :: k3 -> k4) (a1 :: k3). Functor f => Compose f (Compose g g1) a1 -> Compose (Compose f g) g1 a1
22:04:49 <jamestmartin> I'm looking forward to the day there's a GHC extension that lets me write `type Compose f g = \ x -> f (g x)`
22:07:13 <jle`> jamestmartin: btw that function is assoc in functor-combinators https://hackage.haskell.org/package/functor-combinators-0.3.1.0/docs/Data-HBifunctor-Associative.html#v:assoc
22:08:04 <jle`> hehe
22:12:33 <jle`> and there is a sneaky way of defining it so that it doesn't require Functor f. but it fixes the kind of f to * -> *, unfortunately
22:15:35 <jamestmartin> your library looks like it might be the sort of thing I want to do
22:15:44 <jamestmartin> and what's the way to do that?
22:16:40 <jle`> er wait, let me make sure that's correct first heh
22:19:37 <jle`> nvm, i think it's not possible
22:19:45 <jle`> which makes sense because that sounds like it would be a bit too magical
22:21:49 <jle`> hm, you could get away with only only requiring Functor g
22:23:35 <jle`> hm, yeah you can get away with no Functor at all actually.  but both of these tricks are kind of silly because they basically just defer Functor f / Functor g until the point where you extract out the f (g a)
22:49:16 <mniip> 1597035867 [08:04:27] <jamestmartin> I'm looking forward to the day there's a GHC extension that lets me write `type Compose f g = \ x -> f (g x)`
22:49:27 <mniip> typechecking is hell in presence of type lambdas
22:49:45 <mniip> without heavy restrictions (c.f. what type families do right now) you very quickly descend into undecidable land
23:03:24 <iqubic> I want type lambdas?
23:05:14 <dminuoso> mniip: Is there a concrete reason why typechecking is hell in the presence of type lambdas?
23:05:28 <dminuoso> Or it just something that appears to hold?
23:06:17 <jamestmartin> dminuoso: I'm pretty sure typechecking becomes undecidable. `type O = \x -> x x` `O O`
23:06:46 <jamestmartin> oh right, that wouldn't kind check for obvious reasons. but that sort of thing is probably possible in principle.
23:06:47 <dminuoso> That in itself seems not problematic. I mean if you force the type checker into a loop, that seems fine by me.
23:06:52 <mniip> dminuoso, type equality in presence of beta reduction
23:07:19 <dminuoso> Ah
23:07:27 <mniip> you can encode an arbitrary turing machine using lambda calculus and ask whether it terminates successfully
23:07:33 <dolio> It's because higher-order unification is undecidable. And it's pretty easy to come up with examples where e.g. type classes for an arbitrary function don't behave well.
