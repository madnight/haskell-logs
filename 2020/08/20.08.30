00:11:03 <HurrDerp> \>
00:17:51 <Graypup_> am I going nuts or is there no way to getCreds in yesod-auth?
00:17:58 <Graypup_> seems odd
00:20:21 <Graypup_> hm, it all gets stuffed into the session. weird
00:27:55 <blub> REGISTER huntelar markpl@gmx.de
00:36:09 <Graypup_> also! how can I document someone else's type? my haddock is sad because it's missing docs from one of my reexports
00:36:50 <c_wraith> that's a thing haddock currently lacks.  re-exports across packages don't get docs where they're re-exported
00:43:42 <maerwald> c_wraith: it would also be nice to link documentation of another identifier and have it inserted
00:43:54 <c_wraith> yes, it would
00:49:43 <typetetris> In lens we have `...` what is the equivalent in optics?
00:50:51 <c_wraith> optics doesn't appear to have any equivalent to the plated stuff at all
01:49:41 <lordgrenville> Hi, I find that dividing 2 large numbers seems to give an inaccurate result
01:49:54 <lordgrenville> ghci> 1000000 / 31536000
01:50:09 <lordgrenville> yields 3.1709791983764585e-2
01:50:29 <[exa]> lordgrenville: Doubles are inaccurate by design; if you want accurate division, use rational types
01:50:35 <lordgrenville> expected result is 3.168808781e-2
01:50:57 <lordgrenville> [exa] as in Float?
01:51:12 <[exa]> hm but this inaccuracy is say too big even for doubles
01:51:31 <[exa]> how did you get to the 3.1688... ?
01:52:15 <[exa]> (notably, 3.168808781e-2 * 31536000 = 999315.53717616, which sounds way off)
01:52:52 <c_wraith> bc gives the result .03170979198376458650
01:52:58 <c_wraith> I think your expectation is wrong
01:53:02 <lordgrenville> ok, this might be on me
01:53:09 <lordgrenville> I'm trying to convert seconds to years
01:53:30 <[exa]> oh. "what definition of years" :]
01:53:32 <lordgrenville> my desired result comes from searching DuckDuckGo for "convert seconds to years" and using the calculator it provides
01:53:46 <lordgrenville> I assumed it was just dividing by (60*60*24*365)
01:53:54 <lordgrenville> but maybe that's incorrect
01:53:57 <[exa]> an average year has 365.24 days
01:53:58 <tomsmeding> the number of days in a year is not excactly 365 ;)
01:54:09 <tomsmeding> I seem to remember .2425 actually, but let me check
01:54:31 <MarcelineVQ> tomsmeding: something like that, given that leap years are a 1 day difference
01:54:32 <[exa]> which seems closer to what duck probably had in mind
01:54:32 <lordgrenville> ah, that's true...I was thining calendric years, and just taking the modal 365
01:54:37 <lordgrenville> thinking*
01:55:03 <[exa]> leap years, extra non-leap years, leap seconds, ...
01:55:56 <tomsmeding> yep 356.2425 if you factor in the full definition of leap years; this ignores leap seconds, however
01:56:01 <tomsmeding> * 365.2425
01:56:02 <[exa]> anyway, giving 3-decimal-digit precision for year count is probably pointless so I guess that a slight approximation will be okay
01:56:02 <lordgrenville> yeah, it's a lot of complexity. 365.25 seems to be good enough for now
01:56:21 <lordgrenville> excellent, thank you!
01:57:01 <MarcelineVQ> time is a nightmare, did you know it's the leading cause of all bad things?
01:57:08 <lordgrenville> a bit foolish of me to assume haskell was bad at division rather than a simpler mistake
01:57:24 <tomsmeding> the compiler is always right /s
01:57:29 <[exa]> there are whole libraries to compute this very exactly (e.g. try to look at gnu `date` internals)
01:58:09 <[exa]> lordgrenville: actually such problems happen sometimes, I originally thought you are referring to Double (im)precision, which would be valid
01:59:04 <[exa]> > toRational 0.1   -- a common example
01:59:06 <lambdabot>  3602879701896397 % 36028797018963968
01:59:49 <MarcelineVQ> that's fun :/
01:59:56 <lordgrenville> that's crazy
02:44:59 <maralorn> sm: From the backlog I get the feeling that I need to mention one more point. As far as I can tell (which is not very far) fragnix does not use nix at all. I think they just call it *nix to appeal to the fact that it is a hash addressed build system. 
02:49:05 <merijn> maralorn: oh, that actually makes it sound *more* promising :p
02:51:16 <maralorn> merijn: That is true. And my gut feeling is that a fragnix2nix tool would be pretty easy and much easier to use than cabal2nix. (Which is still great in my opinion but has some conceptual overhead we can't get rid of.) 
02:54:08 <maralorn> My main issue with fragnix (apart from the point, that you need a lot of good ui to make it useful). Is that I am very afraid of frequent version mismatches between different transitive dependencies of the same type. 
02:55:06 <maralorn> I.e. stack and cabal both have a story to unify dependencies. Fragnix has a story to spread them, it feels. 
02:58:13 <merijn> I haven't really looked at it, it's just that I like "Nix-in-theory", but don't like "Nix-in-practice", so think that more attempts at reifying "Nix-in-theory" into non-sucky practice are good :p
03:01:47 <maralorn> merijn: Reasonable.^^
05:30:42 --- topic: 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: https://gist.github.com/ | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org'
05:30:42 --- topic: set by glguy on [Sat Jan 05 07:21:52 2019]
05:30:42 --- names: list (clog oish galagora notzmv mangoicedtea cosimone untseac petersen drbrule kyagrd__ milessabin dani- gregberns_ pent alexknvl thi jackdk adamse iphy tiru taktoa[c] joshmeredith luite Firedancer peel cvlad- gluegadget m-renaud Hotbees moobar dmj` beka gareth__ Hijiri abuss qzo sveit dequbed klardotsh [exa] jchia_1 Argorok jchia__1 JackTheEngineer kozowu coot obihann kadobanana evanjs albel727 alter2000 ap5 alehander92 glowcoil GyroW xff0x_ Thra11 lagothrix mawk)
05:30:42 --- names: list (jtcs quaestor Sarma suppi p8m acarrico ViCi amiri mpickering byorgey leothrix Unhammer tsrt^ cyphase Gurkenglas furnost polux2001 _ashbreeze_ lowryder fendor Unode Cheery cbarrett Guest86335 tessier sethetter__ nh2 clynamen hamishmack jb55 ReinH zebrag rizary Kaiepi idnar FMJz____ natim87_ peltre conjunctive NemesisD grfn ^[_ fiadliel Adeon andyo feepo mankyKitty lexi-lambda dsal chessai PatrickRobotham_ affinespaces Boarders cstrahan metadave stylewarning)
05:30:42 --- names: list (verlet64_ dgpratt pasukon zabracks d0liver jetpack_joe benwr__ rdivyanshu_ rodlogic_ Nascha dsturnbull mudri newhoggy nick_h billstclair xyggos mcfilib bradparker jvsg bitonic heyj Uniaika bob teqwve saurik Logio lockshaw connrs mrusme jameekim1 monochrom mmaruseacph2 averell pierrot logicmoo Bergle_1 dcoutts_ Rudd0 Alleria_ mpereira zaquest oxide revprez_stg merijn onealmond drewr o1lo01ol1o lpyfist mirrorbird Tops2 Dara lemmih xsperry gxt Tuplanolla)
05:30:42 --- names: list (aplainzetakind frett27_ ggole danvet nineonin_ takuan Orbstheorem dirediresalt Lord_of_Life day abhixec vicfred arahael darjeeling_ tchouri olligobber theDon mokulus wei2912 chalkmonster Lowl3v3l jakalx zugz Jesin pacak noecho unlink_ nut shailangsa idnc_sk bennofs__ sMuNiX mnrmnaugh SupaYoshi alx741 tochicool themsay[m] Neuromancer jrm tromp pfurla sw1nn vnz elcaro_ leah2 alanz_ jiribenes1 nullifidian lally kjak LittleFox94 darthThorik Maxdamantus aristid)
05:30:42 --- names: list (graingert noexcept ocharles jophish jared-w_ thonkpod_ terrorjack ghuntley Chi1thangoo_ zargoertzel _flow_ benschza AWizzArd gentauro riatre B-J ulidtko revprez_anzio murphy_ ystael Benett DataComputist fissureman ChaiTRex HiRE_ Reiser wspthr forell whiteline_ hvr_ Ammonia gabiruh mstruebing dddddd brisbin bsima roconnor dibblego ishutin_ wz1000 justache kenran nshepperd pounce hyiltiz m0rphism bjobjo denisse jjhoo MarcelineVQ wrunt lep-delete shutdown_-h_now)
05:30:42 --- names: list (aidecoe urdh tabemann balbirs ephemera_ xelxebar drewolson dan64 mozzarella kori xlei SlackIntegration jrqc dexterlb cgfbee Katarushisu nkly __Joker tomboy65 glamas obfusk nyaomi Nik05 Philonous rembo10 enikar stiell rzmt TMA recon_- noteness tomku zfnmxt madnight texasmynsted NieDzejkob macerbi seanparsons daGrevis davetapley Cir0X systemfault totbwf SrPx banjiewen AndreasK ryjm wpcarro liquorice carldd Xnuk andreas303 WzC jluttine earthy theorbtwo hive-mind)
05:30:42 --- names: list (bgamari polyphem Tritlo rann adius sgraf martin02 pieguy128 Plazma heredoc benl23 puffnfresh PoliticsII___ simony macerbi[m] glguy kristjansson rslima____ typetetris J_Arcane Hatsue[m] otulp oldsk00l runawayfive dolio twk- marek avp Uma chosenone koz_ mp___ tmciver Iroha centril emmanuel_erc i7c robin[m]3 duckonomy nerdypepper farn__ megaTherion Takumo totte aweinstock atomi liff noCheese amosbird rawles milkii iinuwa drozdziak1 sureyeaah michaelpj iffsid)
05:30:42 --- names: list (glowpelt uwap laxask bananagram dixie cow-orker ski Velpoman nh opqdonut kaychaks_riot Ericson2314 psydruid sm[m] irclogger_com kini bcoppens landonf barrucadu Guest20621 absence comboy luigy mikolaj_ asm89 thebnq acro t36s_ SegFaultAX hodapp xacktm mjuad hexagoxel vjoki nekomune grol nemesit|znc andjjj23 bob_twinkles pdxleif dilinger rprosper- ashnur shadowdaemon idupree2 rom1504 tolt bspar magog nikola2 ManiacTwister mingc SolarAquarion joehillen mursu siers)
05:30:42 --- names: list (edmundnoble bgavran copypasteque_ sivs interruptinuse lukelau Bigcheese cocreature solarus nshepperd1 operand spoonm xcin xnyhps PigDude tomjaguarpaw jorj hiredman arkeet vancz statusfailed rodgzilla rednaZ2 kmein nf divVerent turq [df] gothos ammar2 newsham gambpang carbolymer lightandlight integral fr33domlover cpape jonge bcmiller vodkaInferno IceMichael cjay Ankhers Chousuke Blkt marble_visions_ kosmikus catern c_wraith Majiir Profpatsch nurupo tinwood)
05:30:42 --- names: list (dysfigured sud0 sm Khisanth davve Techcable hackage azahi so koala_man agrif codedmart kaol voidcontext vin-ivar michalrus Niamkik peutri Geekingfrog stvc pharaun Jonno_FTW M2tias Cerise NinjaTrappeur bendo datajerk sayak1 sim590 rdivacky @ChanServ dexterfoo drdo ego suzu_ tristanC energizer arianvp CitizenS- electrostat MindlessDrone fliife850 oats Drezil ahf lnx abrar qz jfredett_ fiQ2 kloeri Axman6 dredozubov digia gekh12 puffnfresh_ esph davl lpsmith)
05:30:42 --- names: list (joeytwiddle esg tureba xe4 phadej uberj Sparadox mikolaj exferenceBot jkarni fiddlerwoaroof Deewiant bobbytables jvanbure lemald cynick heath gargawel supki Tspoon lieven esotericalgo nopf a3f ggVGc bwe_ zzz crtschin DwarfMaster Faye saidinwot1 Klumben aib sarahzrf cheers relrod komasa Jon Adluc hexo deu spamlessj atle_ chrpape ring0` nlofaro ornxka kip carter gaze__ PotatoGim nitrix wei jackhill ByronJohnson a3Dman feuerbach mceier parseval chpatrick tnks)
05:30:42 --- names: list (tabaqui Vq styledash pong Rembane Ekho cross karolus sajith bastelfreak HoolaBoola sqrt2 mr_yogurt phaazon Putonlalla m1dnight_ duairc beaky ekleog madog yogani ajmcmiddlin_ enemeth79 sclv alunduil janne ent raoulb verement zopsi nshepperd2 haveo Tene haasn cohn Foritus aurieeeh auri_ TimWolla infinity0 niklasb_ dumptruckman Someguy123 dale bandali sdrodge dmwit amf devalot EvanR PyroLagus raid hongminhee m4lvin epta sea-gull myme JSharp lucianp zyeri zymurgy)
05:30:42 --- names: list (fredcy Clint aldum incertia wallacer3 Moyst scav wagle jlamothe ben_m Taneb jamestmartin dhananjay mjrosenb_ jmsx flux chindy MasseR incognito9999 Igloo dopplergange alexelcu_ davean johnstein xwvvvvwx quicksilver LambdaDuck sujeet obiwahn krjst dxld albethere dqd noan DigitalKiwi Randy infty_ PHO_ sis7 stefan-_ doconthe1ocks RoguePointer Athas ixian jtobin joeyh PlasmaStar phaul eagleflo tomsmeding Arguggi xsarnik0 Ranhir BIG_JIMMY_D xarian kqr edwtjo loc)
05:30:42 --- names: list (Firedancer_ Cathy srk hyperfekt shachaf jinblack- Patternmaster raoul jdt Jello_Raptor Dykam anoe quintasan Kneiva jhuizy dh add^_ samebchase bollu Squarism cyberlard statusbot haskell_enthusia malthe msgctl dminuoso gilbertw1_ amx hwabyong_ Zemyla piele w1gz electrocat anderson pie_ oleks deni djanatyn reyu Eliel vimto1 mort Madars efertone atraii strangeglyph Graypup_ Entroacceptor valdyn ptrcmd Inoperable typedfern yumh Jajik ps-auxw immae doublex)
05:30:42 --- names: list (Raito_Bezarius ezzieyguywuf int-e lambdabot zgrep javran Nikotiini dftxbs3e mac10688 coeus jzl meck Cale avn infinisil tstat dave_uy seveg greymalkin itai33[m] Noughtmare[m] maralorn vaibhavsagar fgaz GuillaumeChrel[m domenkozar[m] PotatoHatsue Poscat[m] johnnyboy[m] dominicusin[m] unclechu reed[m] hsiktas[m] siraben hnOsmium0001[m] boistordu stites[m] lnxw37d4 Fernando-Basso[m ttc rednaZ[m] betrion[m] io_r_us[m] dyniec[m] jkaye[m] mikr[m] hawnzug[m] elorm[m])
05:30:42 --- names: list (srid ethercrow[m] jlv vk3wtf dpl wowi42 mniip debugloop brnzhg[m] _xor Ferdirand kav sphalerite rotaerk tv dustinm- connrs- morbeus sshine Guest60204 e2 eldritch yahb topos kipras`away NGravity d3lxa shapr xts cods grumble lortabac APic adamCS canta lyxia hc ArsenArsen niko eedgit2 jchia jassob vqrs_ bonz060 `slikts veverak teehemkay Flonk agander_m srhb @Sigyn jonatan lambdaclan motherfsck zmagii acowley thaumavorio arw magicman cantstanya echoreply simplegauss)
05:30:42 --- names: list (ichimaru mupf ambiso c-rog ridcully_ tdammers mantovani DTZUZU PragCypher coddinkn cjh` mimi_vx DustyDingo stux|RC-only nisstyre swater orcus freeside lassulus blackdog samebchase- towel eyenx reactormonk CindyLinz jle` wayne wraithm acertain sdx23 Tourist bind micro camlriot42 jol TommyC7 tanuki geal cp- e nckx Nilgeist wildsebastian koankeeper ibloom jonrh pepeiborra betawaffle ProofTechnique edwardk jlpeters russruss8 buggymcbugfix peterhil yushyin ericsagnes)
05:30:42 --- names: list ({abby} SquidDev fre iomonad robogoat ft Cthalupa cinayakoshka ebutleriv troydm remy^ p3n tms_ stilgart remexre tumdedum Chobbes chirpsalot proteusguy atk miklcct seliopou jbetz ullbeking liszt higherorder amatecha__ hyiltiz-M kkd maerwald andi- gawen triteraflops bjs nek0 angerman parsnip runeks noctux caasih xintron tasuki eacameron johs elvishjerricco gienah tensorpudding Shun131 Forkk alexfmpe theduke)
05:32:18 <maerwald> merijn: yes, I figured out that I don't miss functional *that* much when I did rust... because it has them
05:32:48 <maerwald> bc now data isn't just about expressing data, but also logic and control flow
05:33:15 <merijn> maerwald: Well, Rust moving to "default const" is also a major factor
05:33:48 <merijn> (in feeling functional-y)
05:36:23 <untseac> In my point of view I do miss functional a lot. Everytime I see crap code I think "if this was functional either you would do it right or it wouldn't exist". It filters patched hacky code.
05:36:38 <untseac> That's also the reason why I kind of gave up on Scala
05:36:57 <untseac> Scala has too many things going around and allows to produce crap Javaish code
05:37:23 <untseac> while in Haskell it invites you to do proper code
05:37:42 <untseac> Just my 2 cents
05:38:20 <untseac> but Haskell tools oh god
05:38:33 <untseac> Sorry guys they're terrible compared to what Java world has
05:38:42 <maerwald> True
05:39:04 <aldum> kind of sounds like Scala might have a point after all :P
05:39:41 <maerwald> But Java is way more prevalent in conservative industry 
05:40:03 <untseac> I had to fight Stack and Cabal a lot
05:40:07 <merijn> untseac: For editor plugins, sure, I agree
05:40:27 <merijn> But cabal is orders of magnitude better than maven or anything in the python/ruby/js world
05:41:08 <merijn> untseac: IMO, 90-95% of all the problems people blame on cabal/stack are really "I'm using broken unmaintained dependencies" problems, rather than actual tool problems
05:41:26 <maerwald> Cabal has a lot of counterintuitive behavior, if you don't know internal representations
05:41:31 <merijn> (assuming you're using a semi-recent cabal-install and v2-build)
05:41:36 <merijn> maerwald: Like?
05:41:38 <untseac> merijn, I guess. It did get a lot better over time. I don«t like that it compiles everything but that's just my opinion.
05:41:56 <merijn> untseac: Well, what else would you like it to do?
05:42:02 <untseac> binaries
05:42:04 <untseac> like java does
05:42:08 <untseac> it's just faster
05:42:22 <merijn> untseac: Distributing binaries is hard, someone needs to build those
05:42:26 <untseac> yeah
05:42:29 <Chousuke> does cabal have any way to verify its sources? That's my main beef with most language-specific package management tools.
05:42:29 <untseac> and it's fixable
05:42:39 <merijn> untseac: Which means someone needs to pay for and work on the infrastructure
05:42:47 <Chousuke> they all just download random crap from the internet and don't even check if they got the right thing...
05:43:00 <merijn> Chousuke: It verifies the sources from Hackage
05:43:05 <untseac> also haskell language server is god sent plugin
05:43:07 <untseac> it just works
05:43:11 <maerwald> merijn: local packages and the fact that test dependencies are taken for them, which then also goes for source-repository package in cabal.project, forcing you to turn it off manually
05:43:12 <merijn> Chousuke: But of course, that doesn't protect against malicious Hackage uploads
05:43:35 <merijn> Chousuke: There's lots of discussion on how to do, like, proper maintainer signing
05:43:39 <untseac> I use vscode because I'm still noobish but vim/emacs work just as well
05:43:45 <merijn> Chousuke: But it's hard and there's not much bandwidth
05:43:53 <untseac> but before that oh god, it was awful
05:44:03 <merijn> Chousuke: So until someone stands up and champions that problem, progress will be slow
05:44:29 <merijn> So, uh, patches welcome? ;)
05:44:41 <maerwald> merijn: and then cabal install doing an sdist of the project before installing, throwing away the project file and its configuration 
05:44:52 <maerwald> And many more
05:44:52 <Chousuke> I suppose with Haskell it might be a bit more difficult to slip in a typo-squatted package that pretends to be the real thing but has some "added value" 
05:44:55 <untseac> anyway those are the two criticisms I have. other than that I think haskell is the way to go.
05:46:28 <merijn> Chousuke: Anyway, all tarballs are signed and verified against the index (which is signed by hackage and validated), so that part is fine. But yeah, a safer way to manage signing and auditing would be good
05:46:51 <Chousuke> I just get this uncomfortable feeling whenever I run bundle install or something to set up a development environment and it downloads ~200 packages that could do who knows what, and somehow we live in a world where that's normal
05:47:33 <merijn> Chousuke: In the real world you probably wanna run your own hackage-server within a company and have it contain only an audited subset of Hackage anyway
05:47:52 <Chousuke> yeah, that's the way you'd do it if you really cared, I suppose
05:47:59 <Chousuke> I have never seen anyone actually do that though.
05:48:12 <merijn> I know there's several people doing that
05:48:21 <merijn> but there's not much point in advertising it
05:49:08 <merijn> Chousuke: Anyway, if you care and have free time, I'm sure there's some issues on github discussing this with things people could jump in with to work on :)
05:50:12 <untseac> it looks like there are actual jobs in haskell now so might as well learn it properly
05:52:02 <Chousuke> merijn: In practice for me personally it applies more to Ruby and Python software. It's just a general complaint I have about what I've seen in deployments. :P
05:53:49 <Chousuke> if you manage to somehow slip a backdoor into a popular ruby dependency I'm pretty sure that'd nearly instantly net you a botnet of several thousand hosts at least. :/
05:54:05 <Chousuke> dunno how practical it would be though
05:54:11 <Chousuke> compared to alternatives
05:57:37 <dcoutts_> Chousuke: with hackage the distribution path is at least partially protected: you'd need to compromise the upload since the download path is protected via the hackage-security impl of TUF
06:00:37 <merijn> dcoutts_: Yeah, but that's also the easiest path, you just have to find someone's password via spearphising :p
06:09:12 <Chousuke> I wonder if you could have a system where uploads can only be done over SSH and the upload server would include a bit of metadata that contains the uploader's public key. You could then specify a list of trusted public keys to avoid accidentally downloading packages by authors you don't trust, or do TOFU.
06:10:17 <Chousuke> An uploader's ssh key might still leak somehow, but that's less likely to happen than a password getting phished
06:10:59 <phadej> that's essentially the same as any other author signing scheme
06:11:17 <Chousuke> pretty much, but everyone already uses SSH
06:11:35 <phadej> cabal upload could sign stuff on upload
06:11:44 <phadej> the tooling is not a problem
06:12:20 <dcoutts_> The hackage-security impl only covered half the TUF design. The other half of TUF is about author signing. That's the approach I'd take, to complete the impl of the whole design.
06:12:58 <phadej> indeed
06:13:04 <dcoutts_> i.e. don't implement something ad-hoc, but reuse the existing TUF system design
06:13:19 <phadej> and there are even notes how it would fit in Hackage settings
06:13:28 <phadej> (with multiple maintainers, revisions etc)
06:13:32 <phadej> not complete though, IIRC
06:14:22 <dcoutts_> funding at the time covered implementation of the first phase of the TUF design
06:15:03 <Chousuke> the problem with signing things usually is that getting people to use GPG is a pain. I sometimes think I should use it but I don't because managing it is terrible. :P
06:15:16 <phadej> Chousuke: signing doesn't mean GPG
06:15:36 <Chousuke> but if I could use my SSH keys to sign things I'd be on board.
06:16:23 <Chousuke> phadej: it doesn't have to, but that's what it usually ends up being.
06:16:40 <phadej> having `cabal gen-maintainer-key`, and making `cabal` use it transparently is all you need from the UX side
06:17:49 * hackage uniqueness-periods-vector 0.1.0.0 - Generalization of the uniqueness-periods and uniqueness-periods-general packages functionality.  https://hackage.haskell.org/package/uniqueness-periods-vector-0.1.0.0 (OleksandrZhabenko)
06:18:04 <phadej> fwiw one of the critique of GPG is using long-lived signing keys. using SSH keys doesn't solve that problem at all
06:18:17 <[exa]> Chousuke: using auth keys for making public signatures is, by design, not a very good idea
06:18:35 <phadej> [exa]: even if one generated a ssh key only for that purpose
06:19:37 <[exa]> yeah
06:19:49 <merijn> I thought the main critique of GPG the UX makes it essentially impossible for most users (including savvy ones) to use it correctly :p
06:20:06 <[exa]> anyway, what's the problem with gpg? setting that up is honestly even easier than setting up SSH keying
06:20:22 <[exa]> merijn: /me very interested in that
06:20:28 <Chousuke> how's gpg easier than ssh keys?
06:22:03 <merijn> [exa]: Look term key management is hard, verification of keys near impossible (web of trust is flawed because trust isn't transitive and directly signing keys means you need out-of-band manual verification of each key), most common uses of GPG make user error easy
06:22:34 <merijn> [exa]: Like, consider GPG encrypted email. It's super easy for someone to mess up and reply/forward an email to a 3rd party (encrypted or not) and leak the entire conversation
06:22:53 <phadej> merijn: that's a bad argument, but also a good one
06:22:56 <merijn> [exa]: Using GPG for signing code is slightly less error prone, but still introduces problem of managing key lifetimes and verifying keys
06:23:00 <phadej> GPG is swiss-knife of cryptography
06:23:09 <[exa]> yeah gpg+mail is a major pita, but thats almost everything with mail
06:23:12 <phadej> encryption and signing are different things
06:23:36 <phadej> there's critique about gpg for encryption, which shouldn't be mixed with gpg for signing
06:23:42 <phadej> yet, people mess up stuff as its all "gpg"
06:23:52 <merijn> phadej: Sure, the last bit was a bit encryption specific, but lifetime and trust are still problems :)
06:23:53 <phadej> on the other hand, there is dozen "String" types in Haskell
06:24:06 <Chousuke> Last time I had to work with gnupg for signing, I found out that it actually requires the agent now with gnupg2, somehow?
06:24:10 <merijn> Clearly we need types in English ;)
06:24:22 <phadej> merijn: yes, there is "debian exception makes all rules about GPG valid" as only known party who succeed in building actual network of trust
06:24:54 <phadej> Chousuke: it doesn't, but agent is handy if you don't want to type passphrases all the time :)
06:25:09 <Chousuke> phadej: I couldn't figure out how to make the agent not start
06:25:42 <[exa]> how's debian an exception?
06:25:44 <Chousuke>  I had to fight with it quite a bit because said signing had to be done automatically and the agent was quite the pain compared to simply pointing it at a private key :/
06:26:21 <phadej> Chousuke: agent is only caching the passphrases
06:26:27 <phadej> it doesn't infere wit key selection
06:26:34 <phadej> at least I'm not aware of how it would do that
06:26:59 <Chousuke> phadej: right, but apparently it has to start the agent for me to be able to even give it a passphrase to work with
06:27:08 <Chousuke> even though the whole process was completely automated
06:27:14 <Chousuke> and the agent did nothing useful
06:27:26 <phadej> Chousuke: no, gpg2 will ask a passphrase if agent is not running
06:27:47 <Chousuke> yes, but it'll start the agent.
06:27:50 <phadej> the problem is that you using automated process with passphrased key
06:28:03 <phadej> that just doesn't work in general
06:28:12 <phadej> "asking for a password in a middle of something"
06:28:47 <albestro> hey all! can someone point me in the right direction? I'm learning haskell, and I'd like to have something like a "binary" fmap. I implemented my version, but I'm struggling trying find if there is something in the standard library that can be used? thanks in advance
06:29:00 <[exa]> :t bimap
06:29:01 <lambdabot> Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d
06:29:22 <Chousuke> phadej: there are ways to give the passphrase non-interactively. Though I suppose it's no different from having a key without a passphrase
06:29:40 <Chousuke> depending on how you delived the passphrase
06:29:44 <Chousuke> deliver*
06:29:45 <[exa]> albestro: first guess is bimap there ^^, if that's not it, please specify how you meant "binary" :]
06:29:57 <phadej> [exa]: I don't really think Haskell community would be able to build network of trust, the fact debian succeed it just proves the point. "we are not debian"
06:30:19 <phadej> people copying lists of keys from random blogs is probably worse than not having anything
06:30:29 <albestro> thanks @exa! I'll give a look! what I implemented is "maybeApply :: (a -> a -> a) -> Maybe a -> Maybe a -> Maybe a"
06:30:52 <phadej> "false sense of security"
06:31:00 <merijn> albestro: That seems to just be the Applicative instance of Maybe :)
06:31:02 <[exa]> albestro: uh that might be just Applicative (bimap is for 2-parameter types)
06:31:07 <merijn> :t liftA2
06:31:08 <[exa]> albestro: check out <*> operator
06:31:09 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
06:31:26 <merijn> > (+) <$> Just 3 <*> Just 5
06:31:28 <lambdabot>  Just 8
06:31:31 <merijn> > (+) <$> Just 3 <*> Nothing
06:31:33 <lambdabot>  Nothing
06:31:39 <albestro> aha! thanks a lot!
06:31:55 <merijn> albestro: I recommend pondering the following two types
06:32:04 <merijn> :t fmap (+) Nothing
06:32:06 <lambdabot> Num a => Maybe (a -> a)
06:32:11 <merijn> :t (<*>)
06:32:13 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
06:32:24 <merijn> (pretend the 'f' there is Maybe)
06:33:04 <merijn> albestro: In general you can think of Applicative as "how can we generalise Functors to work with function with more than one argument?"
06:33:06 <[exa]> phadej: like, it needs a stable maintainer base and some reasonable key distribution system, but I guess haskell community can create that very easily
06:33:17 <merijn> [exa]: I doubt it, tbh
06:33:46 <[exa]> on the second thought I agree that gpg mentality and debian mentality are very compatible
06:33:48 <merijn> [exa]: The debian solution to all these sorts of issues is "throwing 1000s of volunteer hours at it until the problem goes away"
06:34:00 <merijn> The Haskell community isn't big enough to throw so much volunteer time at problems
06:34:06 <[exa]> really?
06:34:21 <merijn> If it was we'd have more maintainers contributing to cabal-install and tools instead of just a handful
06:34:35 <albestro> merijn: thanks for the tip!
06:34:40 <[exa]> as far as I know the core gpg stuff in debian is surprisingly simple
06:34:44 <sm[m]> maralorn: interesting! Thanks. Confusing at first but I guess there's a much older *nix naming precedent
06:35:01 <merijn> [exa]: It also has lots of manual intervention to resolve problems and validate things other people do
06:35:26 <[exa]> otoh it might be simple because they just distribute their own platform below that
06:35:41 <[exa]> I'm not even remotely sure how I'd make gpg stuff work on windows
06:37:34 <phadej> heh, don't ask how cabal downloads stuff over https on windows ;)
06:38:07 <merijn> phadej: It opens an Internet Explorer subprocess? :p
06:38:09 <phadej> (a short answer, is that it doesn't use http for hackage, as it's not needed due TUF; but if you ask for https...)
06:38:13 <phadej> merijn: almost
06:38:34 <merijn> Whoo!
06:38:45 <merijn> This is how I know I'm an industry expert ;)
06:39:09 <[exa]> (what does TUF stand for? just to be sure)
06:39:10 <merijn> The ability to predict the kinds of horrible hacks people (have to) deploy in the real world ;)
06:39:51 <phadej> merijn: "Set a transport for http(s) requests. Accepts 'curl', 'wget', 'powershell', and 'plain-http'. (default: 'curl')"
06:40:04 <merijn> :p
06:40:04 <phadej> [exa]: "The Update Framework"
06:40:07 <[exa]> merijn: ...like OLE32
06:41:44 <merijn> On a completely unrelated note, since everyone here is fairly academic :p
06:42:23 <merijn> Would you say that "empirical computer science" (as in, referring to CS focussed on experiment/performance based research) is a widely understood term?
06:42:23 <[exa]> phadej: oh this, cool
06:43:02 <phadej> merijn: I'd use theoretical/experimental (c.f. physics)
06:43:13 <[exa]> merijn: do you mean more like biology, or more like the sotware-benchmarking conferences from CS?
06:43:22 <merijn> [exa]: the latter
06:44:01 <merijn> Stuff like supercomputing and "look how our implementation is 10x faster than the rest on this hardware"
06:44:07 <phadej> "theory says this should perform good/bad, the experiments confirm/refute that claim"
06:44:58 <merijn> phadej: I don't think that split is quite as natural as in physics, as often times there is no corresponding theory 
06:45:56 <phadej> sometimes physics has experiments first, and there is no theory yet explaining the results
06:46:17 <phadej> e.g. relativity :)
06:51:45 <[exa]> merijn: there's certainly "empirical software engineering", I guess you may likely find good names at pop conference sites, like https://conf.researchr.org/track/icse-2021/icse-2021-Journal-First-Papers#Call-for-Contributions
06:52:57 <merijn> "Empirical software engineering" is just an alternate name for "whoo! look at us committing several billion sins of experimental design to support our bias!" >.>
06:56:05 <[exa]> merijn: so you meant rigorous benchmarking? (ie. ideally without this kind of stuff that I also cannot name well without sounding condescending)
06:56:43 <[exa]> 'observational' might be appropriate
06:58:26 <merijn> I saw a few ACM papers/articles referencing empirical, so I guess I'll keep it until a reviewer complains :p
07:39:18 * hackage cut-the-crap 1.4.1 - Cuts out uninteresting parts of videos by detecting silences.  https://hackage.haskell.org/package/cut-the-crap-1.4.1 (Jappie)
08:36:51 <halogenandtoast> Does anyone have any suggestion on how they would clean up something like this? https://gist.github.com/halogenandtoast/dded9812a8b254478c54c22622b470d8
08:39:23 <merijn> halogenandtoast: By not having one module for each card? :p
08:39:57 <halogenandtoast> merijn: each card has its own behavior
08:40:37 <halogenandtoast> here is an example card: https://gist.github.com/halogenandtoast/4b1eb9a1bf573c4acf53d3aacddf2434
08:40:50 <[exa]> halogenandtoast: can you write a minilanguage that generates this whole description from some more concise DSL?
08:41:11 <merijn> This is why I gave up on the notion of digitising board games
08:41:17 <merijn> So many nasty corner cases :p
08:41:32 <[exa]> halogenandtoast: btw, seriously recommend reading nethack source code
08:41:34 <merijn> halogenandtoast: You could easily have all those cards in one module, though
08:41:47 <merijn> halogenandtoast: It's be a huge module, sure, but meh, who cares
08:41:49 * hackage typesafe-precure 0.7.8.1 - Type-safe transformations and purifications of PreCures (Japanese Battle Heroine)  https://hackage.haskell.org/package/typesafe-precure-0.7.8.1 (igrep)
08:41:51 <halogenandtoast> It would just be a multi-thousand large file
08:42:14 <halogenandtoast> Is there some benefit that provides?
08:42:19 <halogenandtoast> Fast compilation?
08:42:48 * hackage bv-sized 1.0.2 - a bitvector datatype that is parameterized by the vector width  https://hackage.haskell.org/package/bv-sized-1.0.2 (benselfridge)
08:42:49 <[exa]> quite likely, in this case
08:43:02 <halogenandtoast> [exa]: I spent a lot of time reading nethack source, I started an online book about it along time ago: https://gumroad.com/l/write-yourself-a-roguelike
08:43:38 <halogenandtoast> ^^ that project is dead though, the company didn't give me adequate time and I switched jobs
08:43:41 <merijn> halogenandtoast: It'd avoid having 50 lines of imports :p
08:43:59 <merijn> Which I assumed was the problem :p
08:44:24 <halogenandtoast> Ah no the imports are whatever, I just dislike having to pattern match everything every time I want to do something.
08:44:41 <[exa]> halogenandtoast: anyway, the game description _is_ data and should be treated as such, I really recommend storing it in a datafile that anyone can edit/fix/validate (say json? dhall?) and just generate the internal haskell data from that
08:45:42 <halogenandtoast> [exa]: I might not be following what you are saying, but the issue is that this game is too complex for a DSL to encompass what needs to happen without every interaction being its own DSL keyword.
08:46:03 <halogenandtoast> Any card can modify any part of the game, including how you even play the game (as in the case of scenarios)
08:46:42 <halogenandtoast> i.e. once scenario your player is replaced with a different character, who doesn't even get a deck (only a hand of cards) and the rules are heavily modified based on this.
08:46:48 <[exa]> yeah you'd need to have either source code embedded in there, or have a gazillion of hooks everywhere...
08:46:49 <halogenandtoast> You can't just turn that into data
08:47:19 <halogenandtoast> Yeah I have a system that works currently, just looking to clean it up
08:47:33 <[exa]> well you can, scheme source is nice kind of data
08:49:31 <halogenandtoast> I've tried a few iterations of pure data implementations and they just go way too arduous
08:49:40 <halogenandtoast> as you lose interesting ways to compose
08:49:45 <[exa]> not that it would be a practical advice at this point, but the complexity of this thing can easily justify a custom virtual machine
08:49:59 <halogenandtoast> [exa]: that is sort of what I have lol
08:50:33 <halogenandtoast> the core game type has this: giMessages :: IORef [Message]
08:50:48 <halogenandtoast> And I have a bunch of queue operations on that list
08:51:14 <halogenandtoast> The game then processes them one at a time and traverses the game structure for each entity that can handle the message
08:52:03 <halogenandtoast> There are about 260 different messages currently
08:52:28 <halogenandtoast> (that data constructor is fun, and that file takes forever to compile)
08:53:13 <[exa]> you have all the messages in a single sum type?
08:53:25 <halogenandtoast> Yes because any entity can handle any message
08:54:09 <halogenandtoast> They're have some recursion or specifiers to make them more generic
08:54:11 <[exa]> ok perhaps a bit of boilerplate scrapping could help
08:54:46 <halogenandtoast> i.e. DidReceiveDamage Target Source or Will Message
08:55:49 <halogenandtoast> also for reference, because this has been a constant headache, but this is a web app
08:56:14 <halogenandtoast> Data gets persisted into a DB per request, can be loaded and resumed at a later date, and needs to be converted between JSON
08:56:58 <halogenandtoast> So none of my entities can store functions, nor can I reasonable use something like ContT
08:57:37 <halogenandtoast> (I could if I actually store the game as every modification from a base case and pass that back and forth, but it's extremely inconvenient)
08:58:12 <halogenandtoast> But I may end up doing something like that eventually anyways, as some cards can undo entire actions
09:00:28 <halogenandtoast> I tried using singletons to clean things up and that worked great until... FromJSON instances were needed
09:01:04 <halogenandtoast> FromJSON and existential quantification just don't mesh well together
09:01:30 <[exa]> yeah :]
09:01:44 <halogenandtoast> I've been considering template haskell, but that's a whole can of worms
09:03:57 <halogenandtoast> Anyways, what I have right now is probably the best (that I am capable of writing/understanding), so while arduous, it's pretty easy to implement new functionality
09:04:09 <halogenandtoast> if 22k lines of haskell is easy
09:04:43 <monochrom> I think this looks like a use case of GHC.Generics
09:05:15 <halogenandtoast> Generics is probably a better starting point than TemplateHaskell lol
09:06:18 <halogenandtoast> It might be worth noting that every Investigator constructor wraps a newtype of one of two formats
09:06:26 <halogenandtoast> newtype RolandBanks = RolandBanks Attrs
09:06:28 <halogenandtoast> or
09:06:39 <halogenandtoast> newtype DaisyWalker = DaisyWalker (Attrs `With` DaisyWalkerMetadata)
09:10:13 <[exa]> halogenandtoast: why the "double" wrapping? (btw if you have this, migrating to some generics-derived system could be pretty easy)
09:11:19 <halogenandtoast> [exa]: the reason for the double wrapping is this, when a message is dispatched we first want to dispatch it to the card specific behaviors, that can then decide to either handle the message, delegate to the shared behavior (Attrs), or some combination of both
09:12:07 <halogenandtoast> i.e. (When you take damage, you can do x) means I want the default damage behavior to occur and enhance it with the card specific behavior
09:12:42 <halogenandtoast> There is a ton of shared behavior between types of cards, but we have to let the card specific behavour occur first
09:14:33 <halogenandtoast> the With is just data With a b = With a b
09:14:45 <halogenandtoast> and it's because some cards have completely unique state that needs to be tracked
09:14:56 <halogenandtoast> related to their unique behavior
09:16:13 <Jeanne-Kamikaze> Lazy evaluation irl: https://www.sciencealert.com/a-new-quantum-paradox-throws-the-foundations-of-observed-reality-into-question
09:16:25 <halogenandtoast> I could have just added a bunch of Maybe-likes to base Attrs, but that did not seem fun.
09:17:39 <halogenandtoast> I guess I'll need to read up on Generics again, my previous forays have ended poorly.
09:18:34 <halogenandtoast> But I was trying to generate custom json responses and it went pretty deep
09:19:12 <halogenandtoast> It convinced me to just use the base generic{To,From,Parse}JSON and to change my API to use that.
09:19:45 <halogenandtoast> ** generic{To,Parse}JSON and genericToEncoding
09:22:28 <[exa]> halogenandtoast: you might want to separate the base attributes completely and just use something like syb/uniplate/... to provide a reasonable way to "act upon a bunch of whatever"
09:22:59 <[exa]> halogenandtoast: otoh I'm completely unsure how complicated the game mechanics is, and if this even makes sense
09:25:41 <halogenandtoast> [exa]: The game mechanics are extremely complicated. I find this game to probably be 4-5x worse than magic the gathering
09:26:17 <merijn> [exa]: I see Arkham, so...super complicated :p
09:26:28 <merijn> halogenandtoast: That's...not remotely close to true :)
09:26:40 <merijn> MtG is so, so, *so* much worse
09:27:03 <halogenandtoast> merijn: there are locations in this game that are connected based on specific game rules
09:27:09 <merijn> I would actually propose a reversal from the uniplate appraoch
09:27:15 <halogenandtoast> you are required to determine farthest/closest from you and/or the group
09:27:15 * [exa] misses the simple games... rocket goes whizzz boom
09:27:22 <halogenandtoast> magic did not require any sort of BFS
09:27:29 <merijn> halogenandtoast: Oh, I know, I've played quite a lot of Arkham Horror and Eldritch Horror :)
09:27:38 <halogenandtoast> Arkham Horror the card game
09:27:40 <halogenandtoast> not Arkham Horror
09:27:48 <halogenandtoast> Arkham Horror would be so much easier
09:28:09 <merijn> halogenandtoast: You should have a look at the mtg "layering rules" before you decide it's easier :p
09:28:12 <merijn> Anyway
09:28:22 <halogenandtoast> merijn: this has that too lol
09:28:24 <merijn> If you have cards with shared attributes I would actually invert the relation
09:28:59 <halogenandtoast> There are a bunch of interrupt like effects and you have a whole Would, When, and After windows
09:29:03 <merijn> Like, defining "data Card a = Card { sharedAttr1 :: Attribute, sharedAtter2 :: Attribute, ..., cardSpecific :: a }"
09:29:25 <halogenandtoast> And card effects are LIFO like
09:29:41 <merijn> But anyway, digitising board/card games is hell :p
09:29:48 <halogenandtoast> Oh I love it
09:30:01 <halogenandtoast> I have it working for the entire core set
09:30:10 <halogenandtoast> It's been a blast playing with friends
09:30:14 <halogenandtoast> especially stuck at home
09:31:39 <halogenandtoast> I started this back in March though
09:31:48 <halogenandtoast> this is probably the 5th rewrite
09:32:22 <halogenandtoast> But I wanted a version that enforced all the rules
09:32:26 <halogenandtoast> and that is touch
09:32:28 <halogenandtoast> *tough
09:33:20 <halogenandtoast> Haskell has been an amazing technical choice though, as refactoring has been extremely simple compared to my old language of choice, Ruby.
09:34:45 <halogenandtoast> merijn: Also I've been playing MtG since December of '93, so I have a good frame of reference :D
09:36:16 <sm[m]> halogenandtoast: these are card games you and friends knew well pre covid, and now you're implementing them online, is that right ?
09:37:18 <halogenandtoast> sm[m]: I used to play weekly with one of my friends. We switched to playing over hangouts with both of us running a physical copy of the game. So I decided to make a digital version to make that easier.
09:37:43 <sm[m]> sounds fun, and educational !
09:38:10 <sm[m]> What do you do for UI.
09:38:15 <sm[m]> ?
09:38:25 <halogenandtoast> I'll make a gif one moment
09:39:48 <sm[m]> for the internals, would something like apecs have any value ?
09:41:11 <halogenandtoast> https://imgur.com/sLM5LsN
09:41:43 <halogenandtoast> sm[m]: nope, unfortunately not, entities all update linearly so it's a lot of overhead for a system like this.
09:44:18 <halogenandtoast> the project is library (called core) that handles all game logic, an api written in Yesod, a cli, and a frontend written with Vue/TypeScript.
09:44:44 <halogenandtoast> Websockets are used for live updating while playing
09:44:49 <sm[m]> Cool. The ui looks quite nifty. I guess the game art is available
09:45:07 <halogenandtoast> Yeah arkhamdb.com has images for all the cards.
09:47:34 <halogenandtoast> My next goal will be to add a game log and displays what has happened, my plan is to just add a new entity that listens to events and generates the logs from that.
10:12:11 <chewb_> you make game in haskell halogenandtoast?
10:12:19 <chewb_> on your own game engine?
10:24:06 <albestro> key bind meta2-5^ /buffer +
10:44:57 <halogenandtoast> chewb_: yes and yes
10:45:38 <chewb_> 3d engine? can you show source?
10:45:48 <halogenandtoast> no not 3d it's a board game.
10:46:25 <halogenandtoast> So probably not that interesting.
10:46:34 <merijn> People have made 3d games in Haskell before, though
10:46:41 <halogenandtoast> I'd check out https://github.com/ocharles/zero-to-quake-3
10:46:42 <merijn> John Carmack was working on one at one point
10:47:04 <merijn> There is also Frag: https://wiki.haskell.org/Frag
10:47:32 <halogenandtoast> My interests are all boardgame related, so that's the area where I focus on
10:47:40 <chewb_> but he gave up because haskell is too slow
10:47:58 <chewb_> he wanted to rewrite doom in haskell and failed
10:48:09 <Saten-san> ghc-mod doesn't want to install, any ideas? I'm on Gentoo GNU/Linux.
10:48:09 <merijn> chewb_: iirc he mostly got distracted by other real life obligations (like, his job :p)
10:48:17 <merijn> Saten-san: ghc-mod is deprecated
10:48:28 <merijn> chewb_: But yeah, Haskell is not ideal for twitchy FPS games
10:48:45 <halogenandtoast> At least not yet
10:48:57 <merijn> chewb_: Not because it's too slow, though. The real problem is that the current GHC garbage collector just isn't optimised for low latency realtime code
10:49:00 <Saten-san> merijn: I knew that something was wrong because the guide was written 4 years ago :P
10:49:06 <Saten-san> What do I need instead?
10:49:19 <monochrom> Really, you don't need any IDE.
10:49:28 <Saten-san> I'm using Vim ...
10:49:34 <chewb_> is it possible to write such code in any language with GC included?
10:49:41 <merijn> Saten-san: I assume you want some sort of editor integration, in which case ghcide or haskell-language-server are your best bets
10:49:45 <merijn> chewb_: Sure
10:49:46 <Saten-san> The last time I used VSCode my PC crashed because I used up all my RAM lol.
10:50:01 <Saten-san> merijn: Thanks :)
10:50:10 <merijn> chewb_: The problem is GHC uses a "stop the world" collector which has to pause all execution while it does GC
10:50:25 <merijn> chewb_: Obviously, that doesn't combine well with stable computation times to hit 60 FPS
10:51:02 <merijn> chewb_: Haskell doesn't fundamentally require a stop the world collector, but that's what we have now (and it's really quite amazing if you care about *throughput*, rather than latency)
10:51:24 <merijn> chewb_: But FPS games really care about latency
10:52:08 <phadej> merijn: ghc-8.10 has non-moving collector as well
10:52:11 <monochrom> The trick is to make a strategy game rather than an FPS game.
10:52:12 <merijn> Saten-san: Note that both of those are under, eh, very active development and the installation process may not be very polished
10:52:14 <chewb_> what are some examples of games like FPS written in garbage collected language?
10:52:22 <merijn> phadej: Yeah, but it's still not low latency
10:52:32 <chewb_> except frag
10:52:35 <merijn> phadej: iirc the non-moving collector tries to keep pauses below 20ms?
10:52:49 <merijn> chewb_: Unity is C#, iirc?
10:52:59 <merijn> chewb_: So, eh, "most unity games"? :)
10:53:08 <chewb_> i see
10:53:15 <maerwald> merijn: the runtime is C++
10:53:50 <phadej> merijn:  https://www.smart-cactus.org/~ben/posts/2020-05-13-paper-ismm2020.html
10:54:20 <merijn> phadej: Low latency to what we have now, sure, but not in FPS terms :p
10:54:41 <merijn> phadej: I recall a 20ms upperbound on the new collector? (I might misremember, though!)
10:54:48 <merijn> phadej: You've only got 16.6ms for a frame
10:54:53 <merijn> phadej: So that's not good enough
10:55:28 <kindaro> How do I call a pointed container that I can throw the focused element out of?
10:56:04 <phadej> merijn: in games you usually have very small dynamic live sets
10:56:08 <merijn> phadej: Yeah, the preprint mentions 20ms worst case latency
10:56:21 <phadej> merijn: most of the data can be in compact region
10:56:34 <merijn> phadej: I'm not saying it's *impossible*, I just said it still wasn't ideal for games :)
10:56:35 <phadej> I *would* not discourage people making gmaes in haskell
10:56:48 <phadej> if no one is making games, haskell will not get better for games
10:56:51 <phadej> it's that simple
10:56:56 <merijn> That's true
10:57:52 <phadej> for game logic Haskell is imho perfect
10:57:58 <phadej> the rendering engine can be something else
10:58:08 <phadej> and in modern games these pieces do use different languages
10:58:16 <phadej> (something scriptable and C++, I guess)
11:00:15 <Saten-san> what could be a possible reason for all my builds to fail with ./setup "$@" || die "setup build failed" ?
11:00:47 <monochrom> bad sector
11:00:54 <Saten-san> bad sector?
11:01:02 <monochrom> bad sector
11:01:13 <Saten-san> What does that mean
11:01:18 <monochrom> ask an informationless question, get an informationless answer
11:01:19 <sm[m]> phadej++!
11:02:04 <JavaSucksMan> I wrote a few real time video games in Smalltalk... one was 3D.  they weren't to complicated, but the GC was not an issue
11:02:18 <sm[m]> Saten-san: on a paste site, share an example of the command and full output ?
11:03:31 <sm[m]> there's "games", and there's the (small) subset of "games that may never drop a frame while running at 60fps", right ?
11:04:36 <Saten-san> sm[m]: let me try to update my system first and refresh the repository.
11:04:52 <kindaro> What I mean is, for an operation `lookup ∷ Container a → Index Container → a` the Comonad _(≡ pointed container)_ type class provides safety by making sure the index, being baked in, is valid at all times. It seems that for `delete ∷ Container → Index → Container` a pointed container can provide safety in the same way.
11:05:14 <Saten-san> monochrom: Sorry, I know that that that isn't  enough information to help with my problem
11:05:16 <merijn> phadej: Oh, sure
11:05:17 <maerwald> Haskell needs a lot of work to be competitive in performance critical applications. Mainly because there's not much you can draw your knowledge from, except knowing GHC very well or through painful experience.
11:05:36 <merijn> phadej: I'm seriously considering playing with Unreal Engine and using Haskell for most game logic
11:05:49 <merijn> phadej: But, otoh, I wouldn't really recommend that to complete beginners :)
11:07:55 <sm[m]> we often hear happy reports of the performance of real-world haskell projects nevertheless (maerwald)
11:08:07 <maerwald> sm[m]: like?
11:08:44 <sm[m]> I don't have a list handy, but I pretty often hear it. Facebook's spam checker, but that's an outlier of course
11:10:02 <kindaro> Performance averaged over a sizable time interval is one thing, being real time is another.
11:10:03 <sm[m]> "we reimplemented our X in haskell, and it uses less memory, is much faster and has had no downtime", sort of thing
11:10:29 <maerwald> sm[m]: I don't hear that often 
11:10:51 <sm[m]> look out for it, then I bet you will :)
11:10:58 <maerwald> I hear often that it's more maintainable, but it usually takes *more* memory
11:10:59 <glguy> My IRC client outperforms most console clients, but not because it's in Haskell and just because I buffer updates more carefully than other console clients
11:11:08 <glguy> But it's still Haskell winning, so it counts!
11:11:13 <monochrom> Even "performance" is broad and you have to split into "how much throughput? how low latency?" for example.
11:11:36 <sm[m]> of course, I'm just pushing back on maerwald's blanket statement a little
11:11:45 <monochrom> Facebook's use case just needs fairly good throughput. Also, only compared with previous Python/PHP attempts.
11:12:07 <maerwald> optimizing memory isn't easy, GHC has problems with it, cabal, stack (with parallel builds), hie/hls/intero have it
11:12:24 <halogenandtoast> So don't fight on that battlefield
11:12:31 <monochrom> In addition in Facebook's use case they can just throw more hardware to it.
11:12:55 <monochrom> Apparently they enjoy saving programmer's time with Haskell or Haxl.
11:13:02 <maerwald> from all the praises ppl say about haskell... "low memory" is really something I've *never* heard :)
11:13:22 <sm[m]> agreed, I look forward to the day that changes
11:13:23 <phadej> merijn: making "big" games is not really beginner friendly to begin with
11:14:00 <sm[m]> actually I did hear something like that recently and I think it was haskell. Hmm how was it done
11:14:10 <maerwald> though I know there are companies doing high-performance networking in haskell (in telecommunication protocols)
11:14:11 <phadej> (e.g. I consider most mobile games to be small)
11:14:35 <maerwald> but that's all probably streaming
11:15:27 <phadej> at least GHC gives you some tools to affect memory layouts
11:15:41 <phadej> it is unusual for so high level language
11:16:27 <merijn> maerwald: tbh, my data analysis tools is honestly surprising low memory
11:16:53 <merijn> I think it rarely goes about 5-8 MB resident while churning through a few 100k data points
11:16:59 <merijn> s/about/above
11:17:13 <halogenandtoast> Most of my programs take 8GB just to compile
11:17:15 <halogenandtoast> ;)
11:17:28 <maerwald> merijn: ghcup had a memory leak due to the `tar` package (which I'll never use again), which spiked memory to 800mb or something :>
11:17:47 <sm[m]> oh.. I see I'm being inconsistent about hearing of "lower memory". Perhaps what I hear is more often "requires less hardware"
11:17:50 <merijn> You should ask Vanessa, she seems to be a connoisseur of obscure tar implementations :p
11:18:04 <maerwald> merijn: yes, I use her libarchive now
11:18:16 <merijn> You know, when she's not shitposting about programming languages... :p
11:18:18 * hackage cabal-fmt 0.1.4 - Format .cabal files  https://hackage.haskell.org/package/cabal-fmt-0.1.4 (phadej)
11:18:24 <MarcelineVQ> who would do that?
11:18:40 <maerwald> merijn: I actually added static build to libarchive, because of that
11:19:11 <merijn> phadej: tbh, I'd like even more memory layout tools, though
11:19:26 <sm[m]> halogenandtoast: ghc and ld are certainly not low-memory programs. :) But you can write pretty economic programs. Streaming tools using conduit, eg
11:19:29 <merijn> GHC should steal more from the Habit Language Report!
11:19:30 <phadej> merijn: be the change you want to see
11:20:07 <merijn> phadej: I already have a huge list of things like that which are all categorised as "I'll consider it when my thesis is done"
11:20:19 <sm[m]> much like games, haskell gets better for writing memory-efficient programs to the degree we try to do that
11:20:19 <phadej> ah, you have that "blocker"
11:20:46 <merijn> phadej: That's also the main reason I haven't made any further attempts to fix thigns that annoy me in cabal-install :p
11:21:09 <maerwald> sm[m]: I think it's more of a knowledge problem... the rest will solve itself with it. There aren't many *in-depth* resources about it (other than...well, GHC)
11:21:16 <phadej> merijn: cabal is beyoond repair ;)
11:21:30 <sm[m]> yes, if we had a low-memory tsar/curator, gathering the tools and knowledge, it would help
11:21:42 <merijn> phadej: I'm doing a phd, clearly I am stubborn beyond reason
11:22:42 <halogenandtoast> I really want to find the intersection between Haskellers and boardgamers so I can talk non-stop about architectural patterns for implementing board games in Haskell
11:23:05 <kindaro> halogenandtoast: Oh hi!
11:23:09 <maerwald> board games sounds like somethin I'd use python for :p
11:23:11 <merijn> halogenandtoast: Remind me after my thesis ;)
11:23:41 <maerwald> https://github.com/shlomif/PySolFC
11:23:56 <halogenandtoast> maerwald: that sounds like a nightmare, one of the benefits I've had in Haskell is that when I decide an implementation is no good, I can easily refactor my 22k line program
11:24:03 <halogenandtoast> usually in less than an hour or two
11:24:11 <maerwald> 22k for a board game?
11:24:15 <merijn> halogenandtoast: Plenty of inspiration for boardgame implementations in mobile
11:24:29 <merijn> maerwald: THat sounds far from unreasonable
11:24:31 <maerwald> 22k is more than your average proprietary financial platform
11:24:40 <halogenandtoast> maerwald: It's a card game, where every card can change anything about the game.
11:24:50 <dcoutts_> maerwald: do you know what the problem was? The tar package can certainly operate in constant space.
11:24:54 <merijn> maerwald: You clearly play simpler boardgames than I do :p
11:25:03 <maerwald> dcoutts_: unpacking
11:25:12 <maerwald> not sure which part exactly
11:25:22 <maerwald> I could reproduce though
11:25:28 <halogenandtoast> And I'm doing a full rules implementation of the card game, so every card automatically does what it says
11:25:52 <merijn> halogenandtoast: Asmodee Digital has been putting out some fairly great digitisation of various boardgames
11:25:54 <dcoutts_> the demo that comes with the tar package does unpacking I think. It just requires that you use the list linearly, so you don't retain everything.
11:26:23 <halogenandtoast> merijn: I'd be curious to see what development actually looks like for them
11:26:33 <maerwald> I think I tried to look at the heap profile, but I can't make senes of it 
11:26:40 <halogenandtoast> The game I'm making is by FFG which is a subsidiary of Asmodee
11:26:43 <maerwald> I can try again
11:26:50 <halogenandtoast> (as are most companies it seems)
11:27:01 <merijn> halogenandtoast: Asmodee Digital has been handling games for several competitors too
11:27:22 <merijn> halogenandtoast: Anyway, this might becoming a discussion for #haskell-offtopic :p
11:27:24 <halogenandtoast> I'm going to go on a limb and say they are probably unity based
11:27:46 <sm[m]> halogenandtoast: probably #haskell-game is a good place ?
11:28:28 <halogenandtoast> I feel like computer games tend to have different architectures than boardgame simulations
11:28:32 <chewb_> mearwald "22k is more than your average proprietary financial platform" what is "financial platform"?
11:28:39 <halogenandtoast> and that the discussion probably overlaps fairly little
11:28:57 <merijn> Also, my phd thesis has nearly 20k LOC just to benchmark some stuff :p
11:28:58 <halogenandtoast> that 22k is also because there is a lot of boiler plate
11:29:27 <halogenandtoast> There are two files that are around 1000 lines, but most of the rest are between 30 lines to 100 lines
11:29:29 <merijn> So I doubt 22k LOC is an accurate guesstimate for the "average proprietary financial platform"
11:30:01 <sm[m]> also, for general interest: the lambdahack/allureofthestars roguelike author has a dev chat, on gitter/discord/matrix (#lambdahack:mozilla.org on matrix)
11:30:31 <halogenandtoast> line counts for reference: https://gist.github.com/halogenandtoast/0ab9a7690a79b5a5be1489b58e897bc8
11:30:33 <maerwald> merijn: in my experience... for the backend only
11:30:53 <merijn> maerwald: I don't even have a frontend, just commandline programs >.>
11:31:09 <merijn> halogenandtoast: Use sloccount for better SLOC numbers :)
11:31:41 <halogenandtoast> merijn: are the flags the same?
11:32:06 <halogenandtoast> I'd be interested to see what it produces
11:32:06 <sm[m]> isn't cloc better than sloccount ? I forget
11:32:09 <merijn> halogenandtoast: sloccount is automatically recursive, so you just do "sloccount ."
11:32:28 <merijn> sm[m]: possibly?
11:32:51 <merijn> Either is better than "wc -l" in terms of soundness :p
11:33:20 <Saten-san> Can somebody help me? https://dpaste.com/ESJ5PNFAF
11:33:49 * hackage timezone-detect 0.2.0.0 - Haskell bindings for the zone-detect C library; plus tz-aware utils.  https://hackage.haskell.org/package/timezone-detect-0.2.0.0 (lfborjas)
11:33:54 <Saten-san> I don't use Emacs but for some reason it's pulling it in as a dependency ...
11:34:24 <halogenandtoast> I mean I just needed a rough estimate
11:34:39 <halogenandtoast> haskell:      19507 (100.00%)
11:34:41 <halogenandtoast> close enough
11:34:59 <[exa]> ◔.◔
11:35:03 <Saten-san> ◔.◔
11:35:20 <halogenandtoast> lol Total Estimated Cost to Develop                           = $ 611,423
11:35:22 <halogenandtoast> I wish
11:35:31 <sm[m]> Saten-san: it looks like the hfmt gentoo package (whatever you call it) is out of date. You could file a bug with the maintainer. And as a workaround you could install hfmt using stack or cabal instead
11:35:38 <merijn> halogenandtoast: How many man years is it estimating?
11:35:55 <merijn> halogenandtoast: My phd project comes out to an estimate 5.2 years which is...remarkably accurate, tbh
11:36:08 <halogenandtoast> Development Effort Estimate, Person-Years (Person-Months) = 4.53 (54.31)
11:36:10 <halogenandtoast>  (Basic COCOMO model, Person-Months = 2.4 * (KSLOC**1.05))
11:36:12 <halogenandtoast> Schedule Estimate, Years (Months)                         = 0.95 (11.41)
11:36:14 <halogenandtoast>  (Basic COCOMO model, Months = 2.5 * (person-months**0.38))
11:36:36 <halogenandtoast> I started in March so :shrug:
11:36:57 <sm[m]> hledger: 50k lines, 13.6 person years. That's also quite accurate
11:37:10 <sm[m]> though I think it's assuming full time work
11:37:32 <halogenandtoast> Yeah I just do this as a hobby in the evenings and on weekends
11:37:52 <halogenandtoast> And I've got a wife and a kid I interact with
11:38:00 <Saten-san> sm[m]: Installing packages with Cabal and my local package manager will end up in a mess. Just going to try to live without it and file a bug.
11:38:08 <halogenandtoast> But I have written some ruby code to generate a bunch of Haskell code for me based on templates.
11:38:25 <merijn> Don't mix linux package managers and cabal, that way lie tears
11:38:39 <sm[m]> maybe Saten-san . I know it's easy with stack. But contacting the maintainer seems a good start
11:38:41 <merijn> halogenandtoast: I figured, looking at the code ;)
11:38:56 <halogenandtoast> merijn: not sure how to take that lol
11:38:59 <merijn> halogenandtoast: I artisanally handcrafted all of them :)
11:39:09 <merijn> halogenandtoast: THat it looked painfully repetitive to write :p
11:39:28 <halogenandtoast> Oh it is
11:39:36 <halogenandtoast> Especially when I decide to mass change something
11:39:49 <halogenandtoast> I used to treat some cards as just functions rather than entities.
11:39:56 <halogenandtoast> That required 2 large refactorings
11:40:09 <halogenandtoast> There was a lot of sed-based programming going on with that
11:40:41 <sm[m]> halogenandtoast: when the haskell IDE arrives, you'll be happier 
11:40:47 <halogenandtoast> will I though?
11:41:15 <sm[m]> sure, some things you do now will be a lot easier
11:41:34 <halogenandtoast> I use vim so I try not to get my hopes up
11:41:46 <sm[m]> that day of rapture is coming for all of us, we've got to believe
11:41:57 <halogenandtoast> I believe it for the vscoders
11:41:58 <merijn> This seems like the kinda problem where OO Haskell might be really suited, tbh
11:42:31 <halogenandtoast> merijn: I don't know what that means in this context
11:42:43 <halogenandtoast> If you mean a record of functions I've been down that road
11:43:27 <merijn> halogenandtoast: Where did it break down?
11:43:52 <halogenandtoast> merijn: Since this is web-based I need to be able to persist the entire game state to a database, as well as convert to and from json
11:44:07 <halogenandtoast> functions are bad at all of those things
11:44:34 <halogenandtoast> I can just make the whole project public if you want to take a peek
11:44:37 <chewb_> whats "financial platform"?
11:45:06 <halogenandtoast> chewb_: it could be any number of things, but in general it's going to manage transactions involving money in some capacity
11:45:17 <merijn> halogenandtoast: Well, usually the trick is to have an IORef/MVar/TVar captured by closure for the functions in an "object" and then persisting the object is a matter of persisting this state + the object's "type", not the functions
11:45:18 * hackage pandoc-emphasize-code 0.3.0 - A Pandoc filter for emphasizing code in fenced blocks  https://hackage.haskell.org/package/pandoc-emphasize-code-0.3.0 (owickstrom)
11:45:32 <merijn> chewb_: Probably alluding to a fair number of banks and fin-tech companies using Haskell :0
11:45:42 <merijn> chewb_: And also come cryptocurrencies lately
11:45:45 <chewb_> is trading bot with embedded language for writing strategies "financial platform"?
11:46:00 <halogenandtoast> merijn: have an IORef/MVar/TVar captured by closure for the functions in an "object" -- interesting I wonder what that means
11:46:10 <chewb_> i want to make something like that, but i started with python andit would be hard to rewrite
11:46:22 <merijn> halogenandtoast: you have "makeObject :: ObjectState -> IO Object"
11:46:45 <sm[m]> go for it chewb_. It's a lot easier to port something working to haskell than write from scratch
11:46:55 <merijn> "makeObject st = do { mvar <- newMVar st; return Object { .. } }"
11:47:17 <merijn> halogenandtoast: Each function of the object has a (hidden) "MVar ObjectState" as first argument that you partially apply
11:47:30 <chewb_> its using tkinter for GUI
11:47:37 <sm[m]> consider it a reference implementation to compare with your python app (at first, hehe)
11:47:39 <chewb_> matplotlib for plots
11:48:17 <chewb_> is there pandas for haskell?
11:48:19 * hackage timezone-detect 0.2.1.0 - Haskell bindings for the zone-detect C library; plus tz-aware utils.  https://hackage.haskell.org/package/timezone-detect-0.2.1.0 (lfborjas)
11:48:21 <merijn> halogenandtoast: Then Object has a bunch of member functions like "tweakState :: Object -> Tweak -> IO ()" which is really just a "MVar ObjectState -> Tweak -> IO ()" partially applied and stuff into an object
11:48:52 <merijn> halogenandtoast: Persisting is just a matter of "persistObject :: MVar ObjecState -> IO ByteString " or whatever serialisation you want
11:49:29 <merijn> halogenandtoast: You can do pretty much anything you'd do in classical OO that way
11:49:49 * hackage filtrable 0.1.6.0 - Class of filtrable containers  https://hackage.haskell.org/package/filtrable-0.1.6.0 (MatthewFarkasDyck)
11:50:03 <halogenandtoast> merijn: Serialization is JSON because of reasons
11:50:11 <merijn> halogenandtoast: Which would let you define a uniform API for all cards and simply give them custom implementations depending on some card specific state
11:50:52 <merijn> halogenandtoast: But the inherent state of each objects is just "whatever is in the MVar", rather than function, so you can serialise just fine
11:50:52 <dcoutts_> depending on what you're doing, you might not need MVars at all. You can do a lot of OO style stuff without needing mutable state.
11:50:59 <merijn> dcoutts_: Sure
11:51:19 <merijn> dcoutts_: But if you need multiple references to the same game entity that might be easier
11:52:00 <halogenandtoast> merijn: sounds interesting, trying to think this out so here are some of the pitfalls I ran into before and I'd be interested to know if this can mitigate them
11:52:27 <halogenandtoast> 1) Objects can affect any other object in the system (this originally lead me to module import cycle hell)
11:53:44 <halogenandtoast> 2) There are layers of decision making as to how behavior gets handled, a lot of things have a default behavior that either gets enhanced before, or after the basic call, but other times we want to forgo the basic call all together
11:54:24 <halogenandtoast> 3) Some cards have their own independent state that would not make sense in context of any other card so unifying their storage makes this more annoying (lots of Maybe-like's in the base ObjectState)
11:55:17 <halogenandtoast> right now most behaviors runs through this
11:55:19 <halogenandtoast> class (HasQueue env) => RunMessage env a where
11:55:21 <halogenandtoast>   runMessage :: (MonadIO m, MonadReader env m) => Message -> a -> m a
11:55:42 <halogenandtoast> So each entity can modify the queue of messages and itself
11:55:48 <merijn> halogenandtoast: Well, the idea is that different cards can have different ObjectState
11:56:07 <merijn> halogenandtoast: Notice how ObjectState is *not* visible in the returned type *or* it's functions
11:56:25 <merijn> halogenandtoast: It's hidden by the partially applied argument
11:56:43 <halogenandtoast> merijn: that's true, so the interface becomes monomorphic for storage in something like Deck,Hand,Discard, etc.
11:56:47 <halogenandtoast> ?
11:57:03 <merijn> halogenandtoast: "MVar Foo -> Stuff -> IO ()" and "MVar Bar -> Stuff -> IO ()" can be partially applied and stuffed inside "Object" without any visible distinction that their internal state is different
11:57:31 <merijn> halogenandtoast: (this does mean you need to somehow encode the "type" of each object when serialising so you can properly recover this, but that should be straighforward)
11:57:56 <halogenandtoast> ** this difficult part is left as an excercise for the reader
11:57:57 <halogenandtoast> :p
11:58:20 <merijn> halogenandtoast: It just means you need a Map for each different "type" of object and call the corresponding "makeObject" version
11:58:31 <halogenandtoast> so 1000s
11:58:52 <merijn> halogenandtoast: The idea would be that you have "makeInvestigator :: InvestigatorState -> IO Card" and "makeOtherCard :: CardState -> IO Card" and as long as you can implement the same API it's fine
11:59:12 <halogenandtoast> ah but different investigators can have their own independent state
11:59:35 <merijn> halogenandtoast: Yeah, then you need a different "make" function for each of them, but they can all map to a single API
12:00:25 <merijn> halogenandtoast: I mean, you already have a unique "creation" for each anyway, this doesn't affect that in any way. The difference is that you return a single consistent API from each of them now
12:00:42 <Saten-san> who @ me?
12:00:44 <sm[m]> merijn: are there some existing apps based on this approach ?
12:00:45 <merijn> Anyway, I'm not 100% sure this will improve or help
12:00:59 <merijn> sm[m]: I used it in some unpublished code I never finished years ago
12:01:05 <merijn> sm[m]: It worked incredibly well, though
12:01:06 <halogenandtoast> merijn: Yeah I'll spike it out, I'd at least be interested to see what it might look like
12:01:30 <merijn> sm[m]: If you find yourself wanting Java style interfaces, it works really well
12:02:01 <sm[m]> merijn: that's pretty interesting, I haven't seen it described this way before and I'm quite curious to know if it has been used in the wild yet
12:02:09 <merijn> I'm sure it has
12:02:19 <merijn> I mostly ripped this off from a discussion with Cale years ago
12:02:46 <merijn> At some point he had a webpage showcasing it, but I lost that in the mists of tume
12:02:49 <merijn> s/tume/time
12:02:53 <halogenandtoast> merijn: just for clarification how does the mvar become visible to the function in Object
12:03:13 <sm[m]> so much knowledge of architecting haskell software still to be discovered/spread
12:03:23 <halogenandtoast>  > > makeObject st = do { mvar <- newMVar st; return Object { .. } }
12:03:50 <halogenandtoast> are the function inside object lambdas?
12:04:25 <maerwald> dcoutts_: this is with tar https://git.io/JUtbm (~400mb) this with libarchive https://git.io/JUtbu (constant space, around 20-40mb)
12:04:27 <halogenandtoast> Object { m1 = \stuff -> var <- readMVar; doThing }
12:04:59 <merijn> halogenandtoast: You take functions that see the MVar and partially apply them (which gives you a function without the MVar visible in any type) then you put this partially applied function in the object
12:05:17 <merijn> halogenandtoast: Could be lambda's, could be named functions in some module
12:05:57 <merijn> halogenandtoast: "Object { m1 = investigatorJakeM1 mvar, ... }" works just fine :)
12:06:05 <halogenandtoast> right okay
12:06:42 <merijn> halogenandtoast: Which means that if most investigators share the same logic for a method (except 1 or 2) then the rest can simply share that logic (maybe with some wrapper?)
12:06:51 <halogenandtoast> Thanks, I have to jet for now, but if I try it out and it works, I'll be sure to let you know
12:06:53 <merijn> halogenandtoast: I mean, you're not really limited to 1 MVar either
12:07:10 <merijn> halogenandtoast: You can allocate arbitrarily many different ones for different functions to :p
12:07:27 <merijn> But then serialisation becomes a bit messier
12:07:39 <halogenandtoast> serialization will be a real problem
12:07:47 <halogenandtoast> as it is pretty persistent
12:07:51 <halogenandtoast> but :shrug:
12:07:57 <halogenandtoast> I'll mess around and see what I get
12:08:00 <halogenandtoast> Thanks again!
12:09:36 <merijn> halogenandtoast: I mean, conceptually you can just get "serialise :: Object -> JsonValue" and "deserialise :: Parser Object"
12:09:51 <merijn> halogenandtoast: Then you can simply <|> each individual parser :p
12:11:18 * hackage ally-invest 0.1.0.0 - Ally Invest integration library  https://hackage.haskell.org/package/ally-invest-0.1.0.0 (VladLevenfeld)
12:12:58 <fog> hi, im having difficulty understanding a cyclic function https://github.com/fog-hs/System/blob/master/System.hs
12:13:36 <fog> i cant tell if it streams values in a loop, or if it just recursively evaluates the values
12:13:53 <fog> hmm, that isnt said well...
12:14:03 <fog> do you know what i mean?
12:14:54 <maerwald> dcoutts_: the cost is in ARR_WORDS... I really don't know how to debug that more
12:15:23 <fog> i cant tell if the mutually recursive definition bypasses the "streaming loop" -- i think is what i mean
12:16:19 <fog> if it does, i dont know how to write the streaming loop idea properly. the code was supposed to demonstrate it, but i think it might be wrong
12:17:27 <fog> basically, if you can imagine a bunch of scanners at differnt places along a linear stream, with the stream going through them all, then i want to wrap the stream back round so it goes in at the start again
12:18:18 * hackage esqueleto 3.3.3.3 - Type-safe EDSL for SQL queries on persistent backends.  https://hackage.haskell.org/package/esqueleto-3.3.3.3 (parsonsmatt)
12:19:11 <fog> but i get the feeling that the recursive definitions will just keep calling each other instead of consuming the stream
12:22:57 <Uniaika> int-e: heya, can I PM you?
12:22:58 <fog> i could just keep it as a linear stream instead of trying to loop it round, and just alternate which things are traversing over it, as if it were going through the same group again, but then it wouldnt have the accumulated carries because a new version would be used each time
12:23:08 <[exa]> fog: mutual recursion is quite normal; with laziness you only need to ensure that you produce at least some output before recursing
12:23:45 <fog> the problem is that it seems to override the way the stream is supposed to be fed back round
12:23:57 <fog> or i didnt write it correctly to do that
12:24:03 <fog> but then i guess im not sure how to
12:25:14 <fog> like, this is a 2 interacting system, but if it was just one, you could think of just traversing over and over with the same mapAccumL
12:25:26 <fog> but here its supposed to share the same carry!
12:26:32 <fog> and yeah, there isnt really an input stream to begin with, its just an initial value, and the next is supposed to be the output from the application of the system of scanners
12:26:46 <[exa]> fog: so by "feeding back" you actually mean that the first consumer has 2 inputs?
12:26:53 <fog> so it goes right through the system and is fed back in to the start again
12:27:12 <fog> um, it *does* have 2 inputs, but one of those is just a clock
12:27:25 <fog> and thats discarded
12:27:38 <[exa]> so it has output connected to input (via some other boxes)
12:27:48 <fog> yeah
12:28:03 <[exa]> and your code cycles infinitely?
12:28:41 <fog> i guess i could have a maybe somewhere to make it terminate, but its for live streaming web data on a server, so its just supposed to keep running
12:28:56 <fog> its emulating client server interaction
12:29:35 <fog> i thought by streaming over IO lists, that i could capture this functionality in one program, instead of actually having to set up 2 interacting servers to simulate
12:29:39 <[exa]> uh, the point was "what output does it have", I guess it produces some kind of IO actions?
12:29:57 <fog> oh, yeah, i guess i should probably be branching one of them
12:30:22 <fog> ie it would produce 2 output streams, one to be fed back round, and the other to be output to a sink
12:30:43 <fog> the sink could do something like print to screen or dump data to a file in IO
12:31:13 <[exa]> fog: you can add "print cd" to your service function and see if that prints stuff
12:31:13 <fog> i could of course not do this, and have all the IO just done at the nodes, but i wanted it to have an output type
12:31:52 <fog> well, it produces an output, like, its nice and lazy because of how the scanners work, so it does print the output to the screen as its produced
12:32:03 <fog> go = display $ runSystem clock egSystem
12:32:09 <[exa]> ok cool
12:32:10 <fog> thats what display is doing there
12:33:01 <fog> except, i think what its printing is the result of the functions recursively calling each other, instead of the output of the stream being cycled round the system
12:34:03 <fog> see how clientStream and serviceStream are defined in terms of each other
12:34:04 <fog> https://github.com/fog-hs/System/blob/master/System.hs
12:34:29 <[exa]> yeah
12:34:39 <fog> i thought it was working when i wrote it, but i just moved onto another part of the project and now i need this part i dont think its working at all how i meant it too
12:34:54 <fog> and i cant remember how i thought it would be possible to set up this cyclic system
12:35:00 <[exa]> well, try a simpler test that dissects it?
12:35:50 <fog> hmm, i think i can see from the code that it cant possibly be doing the right thing
12:36:03 <fog> oh wait.. maybe not... 
12:36:07 <fog> i cant tell...
12:36:18 <dminuoso> tomsmeding: In case you're curious, Ive decided to with the `data EthAddr = EthAddr Word8 Word8 Word8 Word8 Word8 Word8` route because this library is never going to be at the root of memory issues. So being a bit wasteful of memory is fine, and the memory indirection is acceptable as well.
12:37:00 <maerwald> dcoutts_: also notable... it doesn't happen with 01-index.tar, but with GHC bindist
12:37:04 <fog> i think the way it is working now is the recusive calls make in infinitly deep set of scanners... it then seems surprising that anything is emitted at all...
12:37:20 <fog> and i guess the problem is that they wouldnt have the same carry, not being the same scanner
12:37:47 <fog> [exa] can you see what i mean from the code?
12:38:28 <fog> ahh, there is a setM there which i wasnt reading, i guess thats how it manages to do whatever its doing
12:38:43 <fog> still not sure if thats what it should be doing...
12:38:46 <tomsmeding> dminuoso: not even some ! ?
12:40:19 * hackage supernova 0.0.2 - Apache Pulsar client for Haskell  https://hackage.haskell.org/package/supernova-0.0.2 (gvolpe)
12:41:02 <fog> ah, no, it is consing on new *initial* data each time its called. which is why it can return something
12:41:06 <fog> so its certainly wrong
12:41:23 <dminuoso> tomsmeding: Oh I guess I could add those.
12:41:29 <fog> i have no clue how im supposed to get it to cycle round in the way i want it too...
12:42:01 <tomsmeding> dminuoso: but I guess good choice to avoid premature optimisation where it isn't worth :)
12:43:34 <[exa]> fog: you need to split off one initial function call for each of the functions; the first iteration is special because it takes data from a different source
12:43:50 <fog> i wonder if there is a simple 2 player deterministic system i could have it modeling to see if whenever i figure how to do it it works or not
12:44:05 <fog> [exa] hmm ok
12:44:36 <fog> and then the rest of them would presumably be recursive somehow 
12:44:47 <[exa]> fog: the other way (more concise) is to define the stream begins manually, roughly like: clientStream = clientInitialData : serviceStream
12:45:16 <[exa]> (more precisely, clStream = clInit : clProcessData servStream )
12:45:36 <fog> there is no client initial data
12:45:41 <fog> just an intial client state
12:45:55 <fog> the server emits data to set the process going
12:46:03 <merijn> maerwald: https://github.com/NLeSC-AAA2/etherpacket/blob/master/src/Ethernet.hs#L38 ;)
12:46:04 <fog> (as if the client was calling it)
12:46:06 <merijn> eh
12:46:11 <merijn> s/maerwald/dminuoso
12:46:22 <merijn> I blame a faulty d key :p
12:47:03 <fog> then depending on how the client interacts with the server, the servers state is updated and it emits new data, and the client responds again etc
12:47:10 <maerwald> merijn: I've been mistyping for weeks since I switched to workman, don't worry :p
12:47:13 <[exa]> fog: btw why ListT?
12:47:30 <fog> conventional name i guess
12:47:36 <fog> i rewrote it so its good
12:47:43 <[exa]> oh so that's not the standard ListT?
12:47:59 <fog> https://github.com/fog-hs/System/blob/master/ListT.hs
12:47:59 <[exa]> good
12:48:11 <dminuoso> merijn: What a good idea. vector-size is very thin on its transitive dependencies.
12:48:41 <fog> yeah, it has a "Linear" instance, including having a scanner over it, which is like mapAccumL done lazy, i couldnt get traverse to be lazy
12:48:49 <dminuoso> It only brings it adjunctions :p
12:49:09 <fog> something to do with not being able to commute the Applicative through the lists monad
12:51:40 <fog> the instances all have defaults so you just need to write get and set and the other instances follow. 
12:52:05 <fog> eg scanner is written just using getM and setM
12:52:29 <fog> line 28 here; https://github.com/fog-hs/System/blob/master/LinearM.hs
12:53:12 <fog> oops, that just references line 113 here; https://github.com/fog-hs/System/blob/master/StackM.hs
12:53:30 <merijn> dminuoso: Yeah, vector-sized is quite neat
12:53:44 <itai33[m]> if a library implements a type, and I want to add another record to it but keep all the previous functions defined on this type, is there any way to do that without copy pasting all the old function definitions?
12:54:11 <maerwald> in typescript yes xP
12:54:14 <merijn> itai33[m]: Just define a wrapper?
12:54:28 <itai33[m]> do all the old functions work on thw wrapper?
12:54:28 <maerwald> in haskell no
12:54:39 <merijn> itai33[m]: "data MyType a = MyType { myField :: a, oldType :: OriginalType }"
12:54:54 <merijn> itai33[m]: No, although you could get that sorta thing via lens
12:55:04 <fog> do you not just want a HList?
12:55:12 <fog> or do you need the record names?
12:55:21 <merijn> fog: The answer to "Do you want HList?" is almost always "no"
12:55:25 <dminuoso> merijn: Ive started a practice of being more careful about what I depend on these days. So sadly vector-size is not going to be an option here :(
12:55:28 <fog> HList is at least trivially extensible 
12:55:28 <itai33[m]> what is an HList
12:55:32 <dminuoso> Especially as this is for some low level library
12:55:36 <fog> hetrogenously typed list
12:55:40 <merijn> itai33[m]: Something you should really not bother with >.>
12:56:12 <fog> it has a type level list as a parameter that stores all the types of each element 
12:56:38 <itai33[m]> merijn: yeah, but I feel that since the type and it's functions are not that complicated having an internal reimplementation would be easier overall than having a wrapper and lensing all the time
12:56:40 <fog> this gets consed onto with a new type each time you cons onto the HList with a new value of some type
12:56:56 <merijn> dminuoso: Fair enough
12:57:15 <merijn> dminuoso: My code has more of a "once my thesis is done it's someone else's problem" approach ;)
12:57:20 <dminuoso> Heh
12:57:41 <merijn> dminuoso: Although, it's actually fairly decent quality given the time constraints
12:57:48 <monochrom> That's why every feature added to Haskell or GHC by a PhD thesis bitrots.
12:58:19 * hackage uniqueness-periods-vector-common 0.1.0.0 - Generalization of the dobutokO-poetry-general package functionality  https://hackage.haskell.org/package/uniqueness-periods-vector-common-0.1.0.0 (OleksandrZhabenko)
12:58:26 <maerwald> shots fired
12:58:27 <merijn> monochrom: It's almost as if sustainable maintenance for research output should somehow become important
12:58:35 <fog> data HList (xs :: [k]) where
12:58:36 <fog>  HEmpty :: HList '[]
12:58:36 <fog>  HCons  :: x -> HList xs -> HList (x ': xs)
12:58:53 <monochrom> The good news is that "dependent haskell" is of that genre.
12:59:02 <merijn> monochrom: Optimist ;)
12:59:46 <fog> itai33[m] do you see how that works?
13:00:39 <itai33[m]> fog: yeah, this seems cool but is not really relevant to my usecase because I would still have to reimpliment all the functions, so I'm just adding representational complexity
13:00:41 <fog> i think they are much simpler than other approaches to extensible records
13:01:08 <fog> ah right, you want to be able to lookup by name
13:01:44 <itai33[m]> well actually I could just have `onFirst` as a higher order function, but still, that just makes the representation worse
13:01:57 <fog> then you would write something like HList that "zips" the types with the Symbolic names
13:02:07 <itai33[m]> luckily for me the thing I want to reimpliment and it's functions are not very long or complicated so I can just do that
13:02:14 <fog> and lookup using type applications
13:03:17 <fog> the only reason thats so simple, compared with proper extensible records, is because it assumes its a product, not a sum type, and that its flat, (not nested)
13:03:50 <fog> the other suggestion above resulted in it being nested more, with a pair with the extra added field
13:04:13 <itai33[m]> fog: yeah to be honest I haven't yet looked up extendible records even though that does sound like what I should have looked up, but I didn't know the name
13:04:45 <fog> i think the best library i have seen is vinyl, but its completely insane  
13:04:57 <itai33[m]> <fog "the other suggestion above resul"> that makes sense but merijn seemed to think that it was something I should never use
13:05:11 <itai33[m]> does tagging things like this work in IRC i'm not sure
13:05:12 <fog> probably was easier to write than it seems to be to use 
13:05:51 <itai33[m]> fog: I do remember someone proclaiming that they have solved the record problem in like 2015 but the accompanying library (record) seems to be abandoned 
13:05:52 <fog> no he said that *my* way was too complicated, and advocated;
13:05:53 <fog> itai33[m]: "data MyType a = MyType { myField :: a, oldType :: OriginalType }"
13:06:16 <itai33[m]> what's insane about vinyl?
13:06:33 <itai33[m]> he also said I should not bother with HList
13:06:44 <fog> attempting to use or understand its interface or implementation
13:07:53 <fog> i think zipping Symbolic names to HLists and lookuping them with type applications on these names is actually very simple  
13:08:14 <fog> and if all you want is an extensible flat product type, thats exactly what it is
13:08:15 <itai33[m]> merijn: why did you say that I shouldn't bother with HLists?
13:08:38 <fog> "because agda exists" 
13:09:02 <itai33[m]> lol
13:09:28 <fog> dependent haskell, or even using the available mechanisms to properly handle types programmatically is deemed beyond the pale 
13:10:12 <fog> i think it was only possible since closed type families 
13:10:18 <dminuoso> merijn: Im thinking, I could do `Tagged 32 ShortByteString` maybe!
13:10:25 <itai33[m]> when I want to define custom versions of things that essentially exist as part of a separate library (in this case, a brick widget), should I define it in a `Brick.Widget.MyThing` inside my module structure? or in `$App.Something`?
13:10:30 <fog> i think it should be more and more normal and accessible to beginners 
13:10:39 <dminuoso> This idea doesnt seem too terrible.
13:10:45 <itai33[m]> I feel like I need to lookup a good style guide or something
13:11:07 <dminuoso> (Or well, Tagged 6 ShortByteString in case of an ethernet address)
13:11:07 <itai33[m]> fog: what should be more accessable?
13:11:10 <itai33[m]> dependent haskell?
13:11:14 <fog> things like HList
13:11:31 <fog> no, just, wrangling type level parameters to GADTs 
13:11:48 <fog> i think not many people have seen it used well and so there is a kind of mental barrier 
13:12:09 <itai33[m]> ah yes GADTs, I need to understand what those are at some point
13:12:15 <fog> lol
13:12:20 <itai33[m]> like i'm sure it's not that hard I just haven't gotten around to it yet
13:12:23 <fog> that would be a good place to start yes
13:12:47 <itai33[m]> fog: do you have any thoughts on this:
13:12:47 <fog> the thing you were doing the other day seemed like it was better suited to a datatype
13:12:55 <itai33[m]> when I want to define custom versions of things that essentially exist as part of a separate library (in this case, a brick widget), should I define it in a Brick.Widget.MyThing inside my module structure? or in $App.Something?
13:13:06 <fog> i have no idea what that is supposed to mean
13:13:09 <fog> sorry...
13:13:22 <fog> something about brick widgets!? thats a thing?
13:14:10 <fog> what is $App !?
13:14:19 <fog> :t ($)
13:14:20 <lambdabot> (a -> b) -> a -> b
13:14:37 <sm[m]> itai33: either works. If you think you might merge it upstream later, using the upstream module hierarchy may be better, and vice versa
13:14:37 <fog> you cant use that at type level... or in module names
13:14:40 <itai33[m]> essentially the brick library allows you to define specific instances of a general thing (brick widgets are an abstraction that lets you create tui's), so my question is when I create local specific instances of things in an external library where do I put them
13:14:52 <itai33[m]> fog: $App is just the name of the app i'm writing
13:15:13 <itai33[m]> like you know slang stemming from env variables
13:15:29 <itai33[m]> sm: thanks
13:15:43 <fog> ah
13:16:25 <itai33[m]> fog: what is a datatype tho, is it something in GADTs? google isn't really leading me anywhere
13:16:32 <sm[m]> relatedly, whether it's generally useful outside your app, or specific to it
13:16:43 <itai33[m]> or do you just mean the thing that goes after `data`
13:16:49 <merijn> itai33[m]: HList is  not something that will make code easier or simpler, it will just make everything harder and more painful :p
13:16:58 <fog> GADTs have a where clause, and then you specify the types of the constructors instead of the normal record way with curly braces
13:17:36 <itai33[m]> sm: it would be useful outside of it but I don't think that it would fit upstream as it is trivial to write yourself given the upstream refrence example
13:17:42 <fog> like the HList above. notice there are no record names...
13:18:23 <itai33[m]> I see
13:18:29 <dminuoso> In retrospect, every time I wanted to use HList, it was just because that's what I'd do in plain old traditional untyped language. Often, restructuring problems of algorithms lets me avoid it in the first place. :)
13:18:39 <dminuoso> *or algorithms
13:19:03 <fog> i think records must be for a different style of programming, like porting FFI APIs etc, or writing game logic
13:19:18 <merijn> There are some problems where HList is nice
13:19:45 <fog> its more like the "style" of HList that i think is important
13:19:51 <merijn> None of those involve "people that are trying to get something productive done who aren't already experts at type level hacking"
13:20:24 <dminuoso> Right. In most common uses, just cook up a sum type and make a list of that is an easy solution that has less implications than HList.
13:20:36 <dolio> 'I just started using Haskell after using Ruby/Python/JS/...' is a common reason people reach for them, though.
13:20:39 <fog> i have written HFree, HCofree and various zipped versions, and now im using the more general things like HFree less and less and just making a new GADT that has the corresponding structure mirrored at type level to store the type params
13:21:23 <fog> there is actually a "bug" in ghci which basically forces this
13:22:07 <merijn> fog: Have you actually ever finished any of that code?
13:22:13 <fog> https://pastebin.com/raw/d1U8KSje
13:22:22 <fog> the "bug" ^
13:22:31 <fog> merijn: which thing?
13:23:40 <merijn> fog: Anything
13:23:57 <fog> the scanners work good
13:23:59 <merijn> fog: Also, that paste is not a bug in ghci, your code is wrong
13:24:00 <dolio> It probably doesn't help much that people show up here and ask, "how do I have a heterogeneous list like in Python?" And one of the answers they hear is, "you could do really complicated HList type hacking."
13:24:16 <fog> its a bug! it cant lift the general `f'
13:24:26 <fog> it makes you write a different GADT for each f
13:24:40 <fog> thats GHCs fault, not mine
13:24:55 <merijn> "doesn't do what I want" isn't automatically a bug
13:25:00 <dminuoso> dolio: True. In particular, it could give the impression that Haskell has severe limitations, and that it requires complicated tricks to solve seemingly trivial problems.
13:25:08 <merijn> I can't do "1 + True" either
13:25:14 <merijn> But that's not a bug in GHC
13:25:24 <fog> ok its not a *bug* thats why i used inverted commas
13:25:35 <dolio> dminuoso: Yeah, I think a better answer is, "you've never actually used a heterogeneous list in Python, because it only has one type."
13:26:13 <merijn> HList is the wrong way to do python lists anyway
13:26:16 <fog> well anyway, because of *limitations of GHC* you have to make a new GADT for each `f' 
13:26:20 <merijn> Clearly the correct answer is [Dynamic]
13:26:35 <dolio> Although the right lesson to learn is not needing heterogenous lists all over the place, because they're rarely essential to newbie stuff people want to do.
13:27:01 <dolio> Like, even [Dynamic] is probably not something you need.
13:27:35 <dolio> It's just baggage from old ways of thinking.
13:27:44 <dminuoso> dolio: Pretend Im that user. Heterougenous lists in Ruby elegantly let me do an adhoc solution to an problem without reengineering my code. I'd say they are essential!
13:27:53 <phadej> tuple?
13:27:57 <sm[m]> isn't [CustomADT] the right answer for most folks ?
13:28:12 <phadej> ruby doesn't have `data`
13:28:18 <phadej> it *has* to use lists
13:28:31 <monochrom> Yeah, some are really tuples, some other are [CustomADT]. You never really had list of "arbitrary, sky is the limit" elements.
13:28:33 <dolio> No, I don't want to argue with some argumentative newcomer who doesn't want to learn anything.
13:28:39 <dolio> Even if it's just pretend.
13:28:50 <dminuoso> I suppose that's a fair point.
13:29:22 <monochrom> I wouldn't argue either. I would just ban. :)
13:29:24 <dolio> If someone wants to use Ruby, they should use Ruby.
13:30:42 <phadej> it would been so much nicer if GitLab were made with Haskell...
13:30:58 <phadej> like, one could actually consider contributing to it
13:31:08 <sm[m]> monochrom: good point, sometimes people want it for a mixed tuple. So we should advise to either use a tuple, or a list of CustomADT.
13:31:33 <dolio> I think I saw a book someone had written once where the pitch was like, 'how to use Haskell to write things exactly the way you would in a mainstream scripting language you already know.' And I couldn't understand why anyone would want that.
13:32:01 <sm[m]> it's one way to tackle a huge new subject, isn't it
13:32:05 <monochrom> A whole book, that's exterme.
13:32:13 <sm[m]> limit scope of what you're learning at one time
13:32:38 <phadej> what would you learn, syntax and dozen of anti-patterns?
13:32:40 <phadej> is it really worth it
13:32:53 <dminuoso> I might be interested for amusement
13:33:17 <phadej> follow jesper on twitter, he has good haskell related jokes...
13:33:50 <phadej> sorry, jasper
13:34:28 <dolio> It seems like that would be designed for allowing you to put Haskell on your resume, or something.
13:34:55 <dolio> Except I'm not sure it would teach you to the right things to pass anyone trying to check it in an interview.
13:36:48 <merijn> https://aphyr.com/posts/342-typing-the-technical-interview ;)
13:37:25 <merijn> Work of art
13:42:43 <yushyin> Indeed
13:43:58 <maerwald> merijn: some ppl think it's proof that haskell is dynamically typed
13:44:57 <phadej> really?
13:45:19 <koz_> Does anyone know how to get Stylish-Haskell to align \case branches like case branches?
13:45:28 <merijn> Some people think 5G gives you covid, so you know, take the opinion of people with a grain of salt :p
13:46:11 <monochrom> Every "dynamically typed" language is trivially statically typed, by the uni-type argument.
13:46:20 <maerwald> phadej: yes, this was linked in #python a few times with that claim
13:46:41 <monochrom> Every "statically typed" language is trivially dynamically typed, by the always-checks-out argument. The circle is complete.
13:47:00 <merijn> #python is filled with people who...are not nearly as good at programming as they think and even worse at computer science :)
13:48:45 <monochrom> #haskell is degrading too.  We now have more beginners who can't tell array from list.
13:48:51 <monochrom> Thanks to Python anyway.
13:49:16 <dolio> Arrays are how you implement lists, right?
13:49:34 <dolio> I learned that in Java.
13:49:57 <Rembane> Definitely
13:49:57 <phadej> dolio: you mean https://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html ? yes :)
13:50:42 <monochrom> It goes very much deeper than how I sloppily just said "list".
13:51:00 <Rembane> Which turtle in the turtle stack did it?
13:51:23 <monochrom> Because you show them "data X a = Nil | Node a (X a)" and they still just think random access just because there is syntax sugar "[1,2,3]".
13:51:45 <monochrom> s/random access/O(1) random access/
13:52:40 <monochrom> There was a programming contest team who chose the team name to be: [hip, hip]
13:53:06 <monochrom> It's funny and correct if the context is Python.
13:53:45 <Rembane> Hm... maybe syntax matters, but wrong language for that. 
13:54:02 <Rembane> The APL family is better for having syntax that matters. 
13:57:29 <merijn> We should all just give up on syntax and do Forth
13:59:02 <Tops2> How come there is no instance (Bounded a, Bounded b) => Bounded (Either a b) where minBound = Left minBound and maxBound = Right maxBound?
13:59:49 * hackage timezone-detect 0.2.2.0 - Haskell bindings for the zone-detect C library; plus tz-aware utils.  https://hackage.haskell.org/package/timezone-detect-0.2.2.0 (lfborjas)
13:59:52 <maerwald> dcoutts_: for your convenience https://github.com/haskell/tar/issues/57
14:01:26 <monochrom> maerwald, sometimes I don't trust profiling. Do you still have a similar space growth with don't-build-for-profiling?
14:01:33 <maerwald> yes
14:01:41 <maerwald> that's why I removed it from ghcup
14:01:47 <monochrom> Ah OK then this profiling can be trusted.
14:01:54 <merijn> Tops2: because it's debatable whether that's the right instance?
14:02:29 <maerwald> monochrom: also, the PINNED isn't really useful
14:02:30 <merijn> and/or no one thought of it before
14:02:45 <maerwald> are ByteStrings that bad with debugging?
14:02:57 <monochrom> yeah once again sounds like a lot of bytestrings being Stockholm-syndromed.
14:03:27 <monochrom> shouldn't be that bad with debugging. but I don't know.
14:05:49 <phadej> Tops2: some non-conclusive answers in https://www.reddit.com/r/haskell/comments/4jkicx/why_dont_we_have_more_standard_instance_of/
14:05:57 <monochrom> I have been scaremongering about profiling too much. Here is the criterion I use to decide when to trust profiling, which is basically what I said above. If you get similar space growth with or without profiling, then you can trust profiling.
14:07:41 <monochrom> I guess it's why few people have noticed or worked on the cases when profiling is unfaithful. You don't turn on profiling for the kick of it when the unprofiled version runs in O(1) space, ja? >:)  Well that's what I did and how it went wrong.
14:08:36 <maerwald> monochrom: I noticed, because there was a double space leak... one bc of bad file reading and one because of tar, so memory consumption was >1gb
14:08:57 <monochrom> Yikes
14:09:00 <maerwald> for unpacking ghc... lol
14:10:27 <phadej> lol, building few pandoc-citeprocs ate 20G of space
14:10:42 <maerwald> sm[m]: ^ :D
14:10:54 <maerwald> (as for haskell being low in memory)
14:10:59 <monochrom> You people are scaring me. Do I need a new laptop?
14:11:12 <monochrom> I only have 8G RAM
14:11:22 <phadej> monochrom: build artifacts, not ram
14:11:32 <phadej> though it's all on tmpfs
14:11:35 <phadej> so ...
14:11:39 <monochrom> 8G on my laptop. I have 12GB on my desktop, if it comes down to it.
14:12:06 <maerwald> do we have a distcc alternative?
14:12:16 <phadej> I don't want to destroy my SSD by this "build everything" hackage-trusteeing
14:12:51 <monochrom> Yeah I disabled swap completely.
14:13:17 <maerwald> monochrom: good, because with swap, the OOM killer sometimes needs 15 minutes to get triggered
14:13:26 <monochrom> Wait a second, I failed to disable swap. haha
14:14:09 <maerwald> HDD + swap + ghc is not a good choice
14:14:14 <monochrom> I disabled swap in all virtualboxed boxes but I forgot for the real laptop, or I decided I'd let it live.
14:14:25 <maerwald> with SSD you might *just* get away with it
14:14:35 <monochrom> Yeah my laptop is on purely SSD
14:14:55 <monochrom> But the virtualboxed ones, there's really no point either way.
14:16:07 <sm[m]> I didn't say "haskell is low memory" :)
14:16:20 <maerwald> you said other ppl say :p
14:16:47 <phadej> well, the GHCs are actually not using that much RAM
14:17:14 <maerwald> in this instance, I believe... that it's actually not lack of strictness, but lack of laziness, because tar doesn't use a streaming library, but clever laziness and lazy bytestrings
14:17:15 <merijn> Try compiling any significant C++ codebase with clang++ >.>
14:17:16 <phadej> it's just pandoc-citeproc .o and .his seems to take quite considerable amount of space, when you build a big enough matrix few times
14:17:37 <merijn> phadej: citeproc is terrible and has been for years
14:17:56 <sm[m]> I said I quite often see people say "we rewrote our X in haskell and it's faster / using less memory", which is different. (And then I tried to correct myself with s/memory/hardware/ to be safe)
14:18:21 <merijn> monochrom: People who disable swap hate virtual memory
14:18:32 <phadej> I don't even know what pandoc-citeproc does
14:18:42 <phadej> only that it's a dependency of hakyll which broke my build
14:18:43 <merijn> Virtual memory is one of the best inventions in modern computers, breaking it is stupid >.<
14:18:50 <maerwald> sm[m]: I remember running a haskell backend on a 64GB amazon instance, bc we couldn't find the memory leak xD
14:19:07 <sm[m]> yup, I believe it
14:19:09 <merijn> phadej: I think it has datatypes for bibtex, the datatypes are quite big (as in many constructors) and GHC doesn't handle it very well
14:19:25 <phadej> merijn: it still doesn't explain why codeobjects are big
14:19:28 <maerwald> (tbf... it was weird event sourcing)
14:19:33 <merijn> iirc
14:19:40 <merijn> phadej: ah
14:19:42 <sm[m]> ..and I don't think that equates to "haskell is no good for performance"
14:19:52 <maerwald> sm[m]: but challenging
14:20:09 <c_wraith> not most of the time.
14:20:23 <Tops2> phadej: In that link RyanGlScott says Bounded has no relationship with Ord. But I read the documentation of Bounded differently o.0
14:20:23 <c_wraith> Most of the time it's just "don't do slow things"
14:20:29 <Tops2> "Ord is not a superclass of Bounded since types that are not totally ordered may also have upper and lower bounds."
14:20:31 <maerwald> my argument here usually is: doing performance optimisation in C doesn't necessarily require
14:20:37 <maerwald> knowledge of gcc
14:20:37 <Tops2> I read that as "Hey, Bounded should respect the ordering by Ord if there is an Ord instance, but nontotal orders admit a Bounded instance too."
14:20:45 <c_wraith> maerwald: that's completely untrue
14:20:48 <merijn> maerwald: eh, hard disagree
14:21:01 <phadej> Tops2: note, that comment is 4 years old
14:21:03 <maerwald> you can do pretty good naive optimisations
14:21:06 <phadej> maybe documentation have changed since
14:21:13 <phadej> i.e. be careful
14:21:33 <phadej> but IMO Enum and Bounded are broken classes
14:21:49 <phadej> use `universe` or `enumerable`
14:22:00 <maerwald> c_wraith: well, I managed to do so :)
14:22:25 <phadej> usr: 12755.930s   sys: 1278.310s   cpu: 2230.610%   time: 629.166s
14:22:29 <c_wraith> maerwald: almost certainly you were counting on the generosity of gcc to not "technically correct" your code into a nonworking state
14:22:45 <phadej> "we can use a build farm to figure out bounds", "good luck paying electricity bills"
14:22:56 <merijn> phadej: Oh!
14:23:02 <merijn> phadej: I have a brilliant idea
14:23:23 <sm[m]> maerwald: sometimes, perhaps often, I agree. I will say that (quoting from my limited experience as usual) I started hledger without much attention to performance and it got pretty fast without much knowledge or effort on my part (I'm ignoring memory footprint here)
14:23:33 <merijn> phadej: We replace all Haskell cryptocurrency companies proof-of-work code to do bounds tests!
14:23:47 <merijn> phadej: Let the blockchain fund our boundschecking!
14:23:53 <maerwald> c_wraith: that sounds like a wild guess, I can link you the code
14:23:57 <sm[m]> I think it's relatively easy to make haskell apps run fast, relatively hard to make them use low memory
14:23:58 <merijn> Where's my Nobel price?
14:23:59 <phadej> merijn: on #ghc we discussed that maybe running folding@home would be better for the humanity
14:24:33 <c_wraith> maerwald: if you've managed to write a non-trivial C program that doesn't use undefined behavior, you are the first person in history.
14:24:40 <maerwald> c_wraith: later I tried to implement the same in haskell with the same memory footprint... a few times over the years. I always failed
14:25:17 <merijn> c_wraith: Are we including *potential* UB (i.e. that may be triggered but hasn't been in operation so far)?
14:25:33 <c_wraith> If there's nothing guarding against it, yes.
14:25:49 <maerwald> c_wraith: then I don't see your point
14:25:50 <merijn> c_wraith: That's the great thing about C, your code doesn't have to be correct, because no one is capable of ruling out problems anyway :p
14:25:53 <phadej> ok, maybe pandoc-citeproc-0.15 is enough for today: https://hackage.haskell.org/packages/recent/revisions.html
14:27:59 <phadej> poor matrix.hho will rebuild all that stuff
14:28:00 <maerwald> c_wraith: optimising your allocations for example is more transparent in C
14:28:10 <maerwald> in haskell, it's implicit
14:28:42 <maerwald> no need to go into the hardcore stuff, there are low hanging fruits
14:28:43 <c_wraith> in most programs, that doesn't matter.  I mean, people write software in python and ruby
14:29:12 <c_wraith> All you need to do for Haskell to perform better than those is not do the really terrible things
15:08:02 <halogenandtoast> merijn: I've tried to implement your suggestion, but I don't have the vision to see how it works. In the currentl system everything has a runMessage interface Msg -> a -> m a, that modifies the state, how would you adjust this to fit the mvar model with independent behavior?
15:08:39 <halogenandtoast> Somewhere I have to know what that MVar is which I can do at construction or have partially applied functions but I can't follow the inversion all the way in my head
15:09:09 <halogenandtoast> I guess there should be some base constructor for generic behavior and then override?
15:13:06 <merijn> halogenandtoast: Generally you have to write a new implementation for each unique behaviour yeah, although you can of course have a sort of "generic" behaviour that you call to implement it
15:15:42 <SpottedLamp> Hey! Is this the right place to ask beginner questions?
15:15:53 <c_wraith> it's a fine place
15:16:02 <c_wraith> Not the only one, but it works
15:16:10 <SpottedLamp> Thanks :)
15:17:12 <SpottedLamp> λ> div2 x = [x / 2]
15:17:31 <SpottedLamp> ugh sorry don't use irc much, let me put together a pastebin
15:17:45 <c_wraith> appreciated!
15:18:20 <halogenandtoast> merijn: alright working through that concept again
15:22:07 <SpottedLamp> If you wouldn't mind taking a look https://pastebin.com/3N2ayuas
15:23:20 <c_wraith> the extra nesting is from mapM itself.
15:23:22 <c_wraith> :t mapM
15:23:24 <lambdabot> (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
15:23:37 <c_wraith> well.  specialize t and m to [], anyway :)
15:23:47 <c_wraith> the end result is [[b]]
15:24:30 <c_wraith> I suspect you might want [1..3] >>= div2
15:24:55 <halogenandtoast> merijn: how far off am I with something like this (let's say the investigator always takes 1 less damage): https://gist.github.com/halogenandtoast/57083a3073d1dc183a769efd099373bc
15:26:46 <halogenandtoast> I assume I'd potentially want some method to get the state back as well
15:30:07 <halogenandtoast> updated gist: https://gist.github.com/halogenandtoast/57083a3073d1dc183a769efd099373bc
15:31:05 <SpottedLamp> ok, please correct me if I get this wrong, still very new. So (a -> m b) is the div2 function and t a is my number list, so m (t b) is [[nums ...]]
15:31:15 <c_wraith> that's correct
15:31:38 <SpottedLamp> What I dont get is why m is represented as a list
15:32:01 <c_wraith> It's required by unifying (a -> m b) with the type of div2
15:32:23 <halogenandtoast> div2 returns [x / 2]
15:32:23 <c_wraith> :t \x -> [ x / 2 ]
15:32:24 <lambdabot> Fractional a => a -> [a]
15:32:25 <halogenandtoast> which is a list
15:34:16 <c_wraith> When unification proceeds, it notices the (a1 -> m1 b1) (variables renamed for clarity) in the type of mapM must be the same as the (a2 -> [a2]) that it has found for div2
15:34:42 <SpottedLamp> but doesn't that wrap it twice then? my understanding of monads is that they return the same functor that they receive. So unwrap x times -> act on values + extra wrap -> rewrap n -1 times
15:35:00 <c_wraith> so...  a1 is the same as a2 (often written a1 ~ m2), b1 ~ a2, and m1 ~ []
15:35:21 <c_wraith> remember, you're working with mapM.  that's more complicated.
15:36:26 <monochrom> "m (t b)" with m=[], t=[], becomes "[] [] b" aka "[[b]]".
15:36:43 <SpottedLamp> ok, carefully reading
15:36:55 <c_wraith> You might get a better intuition for mapM by thinking about it as two separate operations
15:37:03 <c_wraith> First it maps the function, then it sequences the result
15:37:06 <c_wraith> :t sequence
15:37:07 <lambdabot> (Traversable t, Monad m) => t (m a) -> m (t a)
15:38:03 <c_wraith> sequence over lists of lists is a kind of combinatorial explosion
15:38:20 <c_wraith> > sequence [[1,2,3], [4,5], [6,7]]
15:38:22 <lambdabot>  [[1,4,6],[1,4,7],[1,5,6],[1,5,7],[2,4,6],[2,4,7],[2,5,6],[2,5,7],[3,4,6],[3,...
15:38:46 <SpottedLamp> Gotcha, I get that it's matching the type of the input function
15:38:51 <c_wraith> But in your case, the map is generating something like [[0.5], [1], [1.5]]
15:39:02 <c_wraith> And there's no combinatorial explosion there, as every inner list has length 1
15:40:34 <SpottedLamp> ok, so mapM is doing that for the case where the input function does act combinatorially on the child lists, and in my case it's just superfluous? 
15:40:59 <c_wraith> with these specific types, that's how mapM works out, anyway
15:41:38 <c_wraith> the understanding of why that's what happens with these types can take a bit longer.  It's sort of subtle.
15:43:01 <SpottedLamp> Gotcha, is there a place I can read about the rational behind the type unification process?
15:43:55 <merijn> halogenandtoast: It's late here, I'll see if I have time to give it a look tomorrow :)
15:46:30 <SpottedLamp> Or is that part of the definition of a monad and I just don't understand the use of monads well?
15:46:40 <c_wraith> I can't think of anything that describes Haskell unification as a focus.  That's an unfortunate lack.
15:46:54 <c_wraith> Nah, it's just a general part of the type system.  Nothing to do with monads.
15:48:21 <SpottedLamp> Ok gotcha, is the right path to gaining a deeper understanding just continuing to learn about the type system and using it? Just one of those things?
15:48:52 <c_wraith> This might be surprising, depending on where you've heard about Haskell in the past but...  Monads really aren't all that important.  They're a useful pattern for sharing code, but that's about the end of it.
15:49:19 <c_wraith> Yeah - practice, and ask questions when something confuses you
15:51:09 <SpottedLamp> A bit surprising yeah, but part of the reason haskell is so exciting to me are the beautiful abstractions. Will do, I really appreciate help. Thank you.
15:55:06 <triteraflops> so, when everything goes wrong, I can normally resort to print(), even in realtime systems that can't be stepped in with a debugger.
15:55:19 <triteraflops> You see where this is going.
15:57:26 <c_wraith> there's the Debug.Trace module
15:57:33 <c_wraith> sometimes it's just what you need
15:57:53 <triteraflops> it's usable without tainting the entire stack with IO?
15:58:09 <triteraflops> I mean without having to edit all functions in the stack
15:58:12 <c_wraith> yep.  it reveals dirty internal secrets that are supposed to be unknown.
15:58:20 <triteraflops> that's cool
15:58:40 <c_wraith> Please only use it for debugging. Those internal details are allowed to change between GHC versions. :)
15:58:47 <triteraflops> and do they make sure it will not block on a busy stdout?
15:59:25 <c_wraith> eh.  I think they work the same as putStrLn underneath.
16:00:36 <tabemann> so they're just \x -> unsafePerformIO (putStrLn x)?
16:00:36 <sm[m]> That's one I haven't heard of/thought about..  ie can lots of trace output slow your app if printing to a slow console, like an emacs shell
16:00:51 <sm[m]> I think it can
16:00:53 <c_wraith> tabemann: more or less
16:01:26 <c_wraith> huh, no, they aren't putStrLn
16:01:37 <c_wraith> they have a unique IO function for writing to stdout
16:01:49 <c_wraith> see https://hackage.haskell.org/package/base-4.14.0.0/docs/src/Debug.Trace.html#trace and https://hackage.haskell.org/package/base-4.14.0.0/docs/src/Debug.Trace.html#traceIO
16:03:02 <tabemann> debugBelch
16:04:18 <c_wraith> I don't know anything about debugBelch, but I will note that the form of the functions means it's not writing a character at a time, so messages won't interleave.
16:04:18 <tabemann> is this to minimize interference with the Haskell application by involving everything resulting from normal terminal IO under it (e.g. contention for the MVar protecting stdout)?
16:05:28 <monochrom> Also, stderr, not stdout
16:05:39 <triteraflops> stdout can block for reasons other than lots of output
16:05:46 <triteraflops> and stderr for that matter
16:05:55 <triteraflops> if you forward it to less, for instance
16:06:19 <triteraflops> It would block almost immediately, even with relatively low output
16:06:59 <monochrom> So many questions, so few answers.
16:07:17 <monochrom> Someone should find the source code of debugBelch, but I'm too lazy to be that person.
16:08:37 <tabemann> I bet it's just a magical call to fprintf(stderr, "%s", my_msg) underneath it all
16:08:54 <tabemann> hence the issue with nulls
16:10:10 <sim590> Is there a way to make `cabal new-haddock` generate documentation for modules and bindings that are not exposed publicly?
16:11:43 <sim590> I tried --haddock-all, but it doesn't give me the signatures in modules I listed in `other-modules:` in my cabal file.
16:15:12 <sim590> I think that it's `--haddock-options '--show-all'`. But, it seems like it's generating also documentation for dependencies.
16:15:29 <sim590> I'm not sure. It's pulling and compiling lots for stuff.
16:17:49 * hackage aeson 1.5.4.0 - Fast JSON parsing and encoding  https://hackage.haskell.org/package/aeson-1.5.4.0 (AdamBergmark)
16:20:05 <triteraflops> I looked at linear haskell.
16:20:20 <monochrom> Oh, right, that kind of flags given on the cabal command line tends to mean "apply to the whole dependency graph"
16:20:44 <sim590> Well, actually it only documented my stuff, but I don't know why it pulled new packages and compiled them for this compared to when I just asked for `cabal new-hadkkock mypackage`...
16:20:48 <monochrom> To apply to just a few select packages, for example just your own, you have to write a cabal.project.local
16:21:02 <triteraflops> It's a cool idea. A way of making sure large data structures don't get copied in functional code, without having to do the usual copy on write stuff
16:21:21 <monochrom> cabal.project.local has syntax for both "apply to the whole graph" and "apply to just these packages I name".
16:22:16 <triteraflops> Though I don't see why it's functions and not types that are marked linear in linear haskell.
16:22:27 <monochrom> cabal is conservative and rebuilds things whenever you add a flag you didn't specify before.
16:23:10 <monochrom> I just ran into that yesterday with --ghc-option=-ferror-spans --ghc-option=-fdefer-type-errors
16:24:25 <monochrom> I had a manual "cabal build/repl" without them.  Then I fired up emacs haskell-mode and I forgot that I added those flags in my haskell-mode settings. This built everything, again.
16:25:05 <monochrom> Someone chastised me "But you asked for it".
16:25:40 <monochrom> I raised that to the metalevel and said "well yeah I asked for v2, I deserve this"
16:26:00 <monochrom> The real issue is that no one knows this syntax asks for this semantics.
16:35:02 <dolio> I said it because it's what you say to people here routinely. It did what they said instead of what they meant. You also figured out what it does by 'scientific investigation' which you seem to enjoy.
16:35:03 <sm[m]> in the root directory of a multipackage project, containing a cabal.project file which specifies the subfolders containing the .cabal files, how do you cabal install all ? I thought just "cabal install" worked
16:35:30 <dolio> I'm skeptical that there's no way to accomplish the actual goal. It just isn't that way.
17:12:46 <monochrom> sm[m]: cabal install all:exes
17:13:40 <sm[m]> thanks!
17:15:19 * monochrom cries
17:15:42 <sm[m]> not intuitive
17:16:26 <sm[m]> and I see cabal ./pkg1 ./pkg2 ./pkg3 has stopped working, if one of the packages provides no executables
17:16:31 <monochrom> If I pack up the packages as *.tar.gz, not unpacked as directories, all:exes gives me "...none of the packages contain any executables. Check the .cabal files ..."
17:16:49 <monochrom> Oh, that.
17:18:32 <monochrom> Hrm, that doesn't fail for me.
17:18:36 <sim590> I have these functions https://i.imgur.com/g6wQJPh.png which I called ?Map, but they're not really maps. What would be a better name?
17:19:08 <sim590> They're not maps because they don't return the same structure with different elements inside.
17:19:19 <ammar2> flat map?
17:19:38 <monochrom> There is also "cabal install all" in case it matters. (It still focuses on exes because no --lib. But maybe you need some of the no-exe packages because they support the has-exe packages.)
17:19:58 <sm[m]> monochrom: "Cannot build the executables in the package hledger-lib because it does not contain any executables ..." here
17:20:00 <jackdk> sim590: what if you return the lists of internal nodes and leaves directly, and leave the mapping to the caller? having map-and-return feels like it's below the Fairbairn threshold
17:20:00 <sim590> OK. So the word "map" is not too frightning there, I take it.
17:20:09 <sm[m]> this is.. cabal 3.2.0.0
17:20:31 <sm[m]> cabal install all gives the same error, only cabal install all:exes works
17:20:56 <monochrom> Hrm OK, I have been using "cabal build all:exes" as a proxy.
17:21:35 <sim590> jackdk: the issue with that is that it is making the overall process take an additionnal pass over the list, so I get an overall complexity of 3N instead of 2N (where N is there number of leaves or internal nodes). There are always around the same number of internal nodes and leaves.
17:24:14 <jackdk> sim590: isn't not having that happen one of the main benefits of using a lazy language?
17:24:55 <jackdk> You may produce/consume additional cons cells, and they may even be fused away
17:25:09 <jackdk> (performance stuff is near the fringe of my knowledge though)
17:25:45 <jackdk> oh, and be aware that `lmap` is a method name on the `Profunctor` typeclass
17:26:32 <monochrom> sm[m]: Ahhh OK I misread something you said. We are all on the same page and getting the same successes and failures.
17:26:51 <monochrom> all:exes is the one to go for.
17:26:55 <sim590> jackdk: You're making me doubt here. So may be I could use this `leaves` function that I wrote in combination with `map`...
17:27:46 <sim590> So, haskell wouldn't wait for the list to be completely created before mapping the function on the elements. I think you're right.
17:28:20 <Axman6> map f . leaves I would guess would produce almost exactly the same code as a custom function that does both
17:28:31 <jackdk> that's not to say the function definitely should not exist (consider `sequence = traverse id` and `traverse f = sequence . map f`)
17:28:47 <Axman6> (also leaves . fmap f should do the same thing, and no more expensively)
17:36:46 <koz_> :t runReaderT
17:36:48 <lambdabot> ReaderT r m a -> r -> m a
17:38:31 <triteraflops> can I forbid all IO in some body of code except to and from a certain handle?
17:38:45 <sim590> jackdk: I'm sure I'm getting your point about sequence and traverse. :/
17:39:28 <jackdk> sim590: both functions exist, even though each has a trivial implementation in terms of the other
17:40:19 * hackage plot 0.2.3.11 - A plotting library, exportable as eps/pdf/svg/png or renderable with gtk  https://hackage.haskell.org/package/plot-0.2.3.11 (VivianMcPhail)
17:44:31 <remexre> does https://gitlab.haskell.org/ghc/ghc/-/wikis/explicit-call-stack/implicit-locations work, or should I use GHC.ExecutionStack.getStackTrace, or something else?
17:45:24 <sim590> jackdk: Yes. But they are important parts of fundamental and different concepts so it's more sensible that both exist. In my case, if the complexity is the same, I guess that the extra bindings is just a nuisance.
17:53:33 <triteraflops> For instance, is there some pre-established monad implementing just two actions, read and write, which are mapped to arbitrary IO actions on the execution side?
17:55:42 <monochrom> No. But if you are also OK with restricting the operations, we have an idea.
17:56:12 <triteraflops> If RW is that monad type, execution would look like this: exec :: RW -> (a -> IO ()) -> IO b -> IO ()
17:56:52 <triteraflops> exec m writef readm 
17:57:04 <monochrom> The restricted algorithm is a function "algo :: Monad m => (m String) -> (String -> m ()) -> m Whatever"
17:57:41 <c_wraith> I'd think you'd want something like RW i o a -> (o -> IO ()) -> IO i -> IO a
17:57:42 <monochrom> Suppose your handle is h.  Then you call algo like: "algo (hGetLine h) (hPutStrLn h)"
17:57:44 <triteraflops> string? huh, why string...
17:57:54 <monochrom> It's an example.
17:58:02 <monochrom> Your question doesn't say it is not string.
17:58:13 <triteraflops> oh, I thought you were referring to an existing function
17:58:21 <triteraflops> c_wraith: yeah, actually that's better
17:58:39 <monochrom> I would avoid IO until at the use site.
17:58:59 <triteraflops> monochrom: so some combination of yours and c_wraith 's 
17:59:20 <monochrom> If you go "algo :: ... -> IO Whatever" you are still allowed stdin, stdout, and even opening more files.
17:59:39 <c_wraith> monochrom: the point is that inside RW you aren't allowed to do those
17:59:47 <triteraflops> exactly
18:00:03 <triteraflops> unless you mean within exec
18:00:10 <triteraflops> but there's only one of those and it's easy to read
18:00:11 <triteraflops> still
18:00:22 <triteraflops> IO should probably be lifted in this exec
18:00:37 <monochrom> OK your RW is my Monad m => (m String) -> (String -> m ()) -> m Whatever
18:01:00 <triteraflops> My RW is your ... um actually you don't have an RW
18:01:16 <monochrom> There is no need to give it a name.
18:01:18 <triteraflops> I have two different monad types, RW and IO
18:01:40 <monochrom> Well yeah but I think I have not seen RW defined.
18:01:45 <triteraflops> RW is a restricted monad
18:02:14 <triteraflops> yeah um I was kind of implying some kind of common sense definition based on the form of its execution
18:02:27 <triteraflops> but if it's not clear enough...
18:02:29 <jesystani> howdy, what would people reccomend for database migrations? im using beam but ive heard its migration library isnt great in pratice?
18:02:56 <Cale> triteraflops: You could implement a monad like you're suggesting using a ReaderT to carry around the pair of functions
18:03:21 <triteraflops> I'd need to look at what ReaderT is.
18:03:30 <triteraflops> That's an "I don't know" lol
18:03:45 <triteraflops> oh I read that as a question
18:03:50 <triteraflops> that's a statement.
18:04:03 <Cale> yeah
18:04:06 <triteraflops> OK, either way, I'll look at ReaderT
18:05:03 <triteraflops> so "pair of functions"
18:05:04 <Cale> You could put a newtype around ReaderT (o -> IO (), IO i) IO a, and don't implement MonadTrans for it, so that arbitrary IO actions aren't really available
18:05:35 <Cale> But instead, export some operations which use "ask" to get the pair
18:05:55 <Cale> and then do the obvious thing with either the output function or input action
18:05:57 <Cale> like
18:06:19 <triteraflops> oh boy
18:06:21 <Cale> output o = do (out, _) <- ask; liftIO (out o)
18:06:29 <triteraflops> k, I really can't comment until after I've read about ReaderT
18:06:32 <Cale> input = do (_, in) <- ask; liftIO in
18:06:35 <triteraflops> but I'll look into it
18:06:45 <Cale> But then newtyped :)
18:06:52 <Cale> So, it'll look like
18:07:23 <Cale> newtype RW i o a = MkRW (ReaderT (o -> IO (), IO i) IO a)
18:08:02 <Cale> runRW :: IO i -> (o -> IO ()) -> RW i o a -> IO a
18:08:41 <Cale> runRW in out (MkRW x) = runReaderT x (out, in)
18:09:01 <Cale> input :: i -> RW i o ()
18:09:21 <Cale> oops, that's backward, lol
18:09:27 <Cale> input :: RW i o i
18:09:32 <Cale> input = MkRW $ do (_, in) <- ask; liftIO in
18:09:40 <Cale> output :: o -> RW i o ()
18:09:54 <Cale> output o = MkRW $ do (out, _) <- ask; liftIO (out o)
18:38:00 <justsomeguy> Why do tests require their own name within package.yaml files? Are they sub-packages? https://termbin.com/2i9s
18:38:55 <sm[m]> it's the data model specified by Cabal. A package may have 0, 1, or multiple named test suites
18:39:18 <jackdk> tests are distinct targets, just like libraries and executables. You could have one test target that's your doctests, one that's your main test suite, whatever
19:03:05 <int-e> Uniaika: If it's lambdabot related, by all means PM me; if not, you can still PM me but I may not even reply if I think it should've been asked publicly.
19:03:35 <int-e> sm[m]: I saw your PR, will hopefully act on it today.
19:29:19 * hackage modular-arithmetic 2.0.0.1 - A type for integers modulo some constant.  https://hackage.haskell.org/package/modular-arithmetic-2.0.0.1 (TikhonJelvis)
20:03:26 <remexre> is there something like cabal haddock --haddock-for-hackage that also bundles the documentation of dependencies in the tarball?
20:30:57 <danso> is there any standard typeclass for types with a method of type `t a -> a` for simple getting? 
20:31:11 <danso> i'm thinking of any newtype definition, mostly
20:33:35 <Axman6> :t _Wrapped
20:33:36 <lambdabot> (Rewrapped s t, Rewrapped t s, Profunctor p, Functor f) => p (Unwrapped s) (f (Unwrapped t)) -> p s (f t)
20:33:46 <Axman6> :t view _Wrapped
20:33:48 <lambdabot> (MonadReader s m, Rewrapped s s) => m (Unwrapped s)
20:34:28 <Axman6> that is _an_ answer to your question, if you're talking specifically about newtypes. there's also coerce
20:34:38 <Axman6> :t coerce (Identity True)
20:34:39 <lambdabot> error:
20:34:39 <lambdabot>     • Variable not in scope: coerce :: Identity Bool -> t
20:34:39 <lambdabot>     • Perhaps you meant ‘coerced’ (imported from Control.Lens)
20:34:45 <Axman6> % :t coerce (Identity True)
20:34:46 <yahb> Axman6: Coercible b Bool => b
20:36:43 <danso> i should have asked a smarter question. 
20:37:06 <danso> i'm trying to use smart constructors for newtypes, but i also want the convenience of pattern-matching to unpack those newtypes 
20:37:09 <danso> is that possible? 
20:37:41 <danso> if not, i was hoping there was a class for newtypes that would make the unpacking more ergonomic than having a special "unpack" function for every newtype i use
20:41:36 <c_wraith> I mean...  coerce is an automatic wrap/unwrap function for newtypes, as long as it's safe
20:41:51 <c_wraith> though it often has a flexible enough type to cause inference problems
20:42:05 <Axman6> that's what Wrapped gives you
20:42:09 <glguy> You could do a unidirectional pattern-synonym, perhaps:
20:42:10 <glguy> Prelude> newtype N = MkN Int
20:42:10 <glguy> Prelude> pattern P x <- MkN x
20:42:42 * Axman6 is uncomfortable that the constructor there isn't called N
20:43:09 <glguy> one of them is, at least :)
20:43:40 <danso> coerce looks pretty useful, i will keep it in my mind
20:44:05 <Axman6> it's worth reading the paper on coerce, it's much more useful than it initially looks imo
20:44:10 <glguy> To use coerce you'll have to expose the constructor anyway
20:44:23 <glguy> it solves a different problem
20:44:30 <Axman6> % :info Wrapped
20:44:30 <yahb> Axman6: pattern Wrapped :: Rewrapped s s => Unwrapped s -> s -- Defined in `Control.Lens.Wrapped'; type Wrapped :: * -> Constraint; class Wrapped s where; type Unwrapped :: * -> *; type family Unwrapped s; Default: Control.Lens.Wrapped.GUnwrapped (GHC.Generics.Rep s); _Wrapped' :: Iso' s (Unwrapped s); default _Wrapped' :: (GHC.Generics.Generic s, GHC.Generics.D1 d (GHC.Generics.C1 c (GHC.Generics.
20:44:48 <Axman6> % :info Unwrapped
20:44:49 <yahb> Axman6: pattern Unwrapped :: Rewrapped t t => t -> Unwrapped t -- Defined in `Control.Lens.Wrapped'; type Wrapped :: * -> Constraint; class Wrapped s where; type Unwrapped :: * -> *; type family Unwrapped s; Default: Control.Lens.Wrapped.GUnwrapped (GHC.Generics.Rep s); ...; -- Defined in `Control.Lens.Wrapped'; type instance Unwrapped CompactionFailed = String -- Defined in `Control.Lens.Wrapped'
20:44:53 <Axman6> -_-
20:45:07 <MarcelineVQ> https://hackage.haskell.org/package/newtype is fairly straightforward, enough to know if it's a fit for you fairl quickly
20:45:33 <danso> yes, i am trying to hide the constructor for building my newtype, but still get the advantages of using it in pattern-matching
20:45:49 <danso> which i guess is not possible in haskell
20:46:17 <glguy> danso: Why not doing the thing I said?
20:46:25 <glguy> -ing
20:46:25 <danso> glguy, i'm not sure what you meant 
20:46:36 <danso> the code as writting does not run in ghci
20:46:42 <danso> as written, sorry
20:46:55 <Axman6> you need the PatternSynomyms extension (IIRC)
20:47:05 <glguy> :set -XPatternSynonyms
20:47:06 <danso> ah, i was not aware of this
20:47:14 <MarcelineVQ> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#pattern-synonyms
20:48:26 <Axman6> We used to just respond in stereo in this channel, now we respond in 3.1 surround with Dolby Atmos
20:51:03 <danso> the pattern synonym looks like a solution to my issue here
20:51:10 <danso> thanks for the help everyone
20:51:17 <danso> this channel is so friendly! :^D 
20:52:18 <danso> just looking at the newtype package now, that also would do it 
21:43:18 * hackage pandora 0.3.0 - A box of patterns and paradigms  https://hackage.haskell.org/package/pandora-0.3.0 (iokasimovmt)
22:21:18 <remexre> can someone who groks fused-effects look over https://git.sr.ht/~remexre/lemonbot/tree/69a85fda/src/Control/Carrier/SQLite.hs ? specifically the WithTransaction bit; it type-checks, but I'm not sure that I'm not doing something naughty
22:52:23 <Orbstheorem> Hello! Is there an alternative to Control.Concurrent.Chan that I can check if it's empty?
22:53:09 <Orbstheorem> I'm using Chans to test whether my application sent an email notification. I would like to check when no notifications are sent.
22:54:48 * hackage skylighting-core 0.10 - syntax highlighting library  https://hackage.haskell.org/package/skylighting-core-0.10 (JohnMacFarlane)
22:55:48 * hackage skylighting 0.10 - syntax highlighting library  https://hackage.haskell.org/package/skylighting-0.10 (JohnMacFarlane)
22:59:10 <Axman6> Orbstheorem: http://hackage.haskell.org/package/stm-2.5.0.0/docs/Control-Concurrent-STM-TChan.html
22:59:37 <Axman6> tryReadTChan will return Nothing if the channel is empty
23:00:07 <Orbstheorem> Perfect, thanks!
23:00:45 <Axman6> it's not generally safe to ask if a Chan is empty, because by the time you get the answer saying it is, it could have been filled again. STM gives you stronger guarantees so you can make an atomic transaction which makes decisions on whether the channel is empty or not
23:01:55 <c_wraith> on the other hand, a tryRead would be perfectly safe.
23:02:06 <Orbstheorem> Yes. In my case I control the execution of the other process, but that's a good remark.
23:19:53 <int-e> Axman6: that scenario isn't the problematic one... the real problem (I think) is that another reader could be stealing items from you when you thought it was non-empty.
23:24:25 <int-e> (The reason I think it's unproblematic is that you will have a hard time distinguishing between acting on the information that the channel was empty when checked before the next message arrives or later; so I find it hard to imagine that one of those cases is safe and the other one is somehow unsafe)
23:40:07 <random> hey guys, is there some prism that can get the first field of a data type
23:40:08 <c_wraith> I mean...  you can 100% safely set up an extra thread to read from the Chan and write to an MVar, and then consumers could use tryTakeMVar.  I sincerely doubt there are any cases that get *safer* when you add an extra thread.
23:40:20 <random> e.g. Data A = B C | D E | F G
23:40:39 <random> and have something like Maybe A -> Maybe C
23:41:27 <c_wraith> using lens?
23:41:35 <random> hopefully
23:43:14 <c_wraith> I mean, makePrisms should give you a prism   _B :: Prism' A C
23:43:27 <c_wraith> that seems like all you need to assemble that
23:43:37 <random> oh I'm a dumb fuck
23:43:47 <random> I thought it would be _B :: Prism' A A
23:43:49 <random> lol
23:44:04 <random> thanks man
23:44:34 <c_wraith> you're welcome
23:46:49 * hackage algebra-driven-design 0.1.1.0 - Companion library for the book Algebra-Driven Design by Sandy Maguire  https://hackage.haskell.org/package/algebra-driven-design-0.1.1.0 (isovector)
23:49:19 * hackage micro-gateway 1.1.0.0 - A Micro service gateway.  https://hackage.haskell.org/package/micro-gateway-1.1.0.0 (Lupino)
