00:00:07 <fog> what, mine are a nice scaffolding for hetrogenous types
00:00:18 <fog> where else are you going to store that type information?
00:00:44 <fog> i have HTrees, and i can send data up the tree to some use-site
00:00:55 <fog> branching the various outputs
00:01:07 <fog> like returning tuples and sending the outputs to different nodes
00:01:17 <fog> HList xs -> HList ys
00:01:46 <ski> fog : "how would you like them displayed?" : in the same way you wrote the source for your `test1' and `test2' examples : with explicit `FEmpty' and `FCons' data constructors
00:02:07 <fog> and some type bounded accessors to lookup Let bound instances, that says the Symbolic name is unique, for the type labelled node data
00:02:33 <fog> ski: you want them unfolded!?
00:02:41 <fog> then i need evolving types!
00:02:43 <fog> argh!
00:02:52 <ski> dunno what you mean by unfolded
00:02:57 <ski> i'd like :
00:03:18 <ski> *Main> show [test1,test1]
00:03:25 <ski> "[HFree (FCons (HPure False) (FCons (HFree (FCons (HFree (FCons (HPure 1) (FCons (HPure "hello") FEmpty))) (FCons (HPure 3) FEmpty))) FEmpty)),HFree (FCons (HPure False) (FCons (HFree (FCons (HFree (FCons (HPure 1) (FCons (HPure "hello") FEmpty))) (FCons (HPure 3) FEmpty))) FEmpty))]"
00:03:36 <fog> oh, you said *with*
00:03:50 <ski> (well, perhaps also with escaping of the double quotes in the strings :)
00:04:04 <fog> without writing those i would have to unfold it, i thought you mean for the implementations of the test1 value
00:04:35 <fog> yeah, but then i have to match on the brackets and copy the list implementation from somewhere
00:04:52 <fog> though i guess it could be good to read them...
00:05:08 <fog> then i could save them to files and read them
00:05:13 <fog> but... thats not much good
00:05:20 <fog> since i already would have had to write it
00:05:26 <fog> unless it was unfolded...
00:06:15 <fog> probably would be better to serialise them to binary
00:06:27 <fog> not sure if i can derive generic on GADT's though
00:06:45 <fog> oh yeah, its infered by the typechecker
00:07:02 <fog> but really, it would be better to generate them at runtime
00:07:14 <fog> and all the types seem like they would have to be fixed at compile time
00:07:46 <fog> replicate is pretty easy to write at type level
00:07:53 <fog> but not repeat... that wouldnt halt
00:08:04 <fog> so i cant generate long types at runtime...
00:08:26 <fog> oh dear, long compile times for these function nets if they unroll into big implementations
00:08:38 <fog> its a shame that would have to be determined at compile time
00:08:54 <fog> my normal recusions can be of varying depth determined at runtime
00:09:20 <fog> i think i end up having to unroll the recursion using instances, ie naming each of the nodes
00:10:09 <fog> i guess i get provably finite programs as a result though, not sure if thats something of any worth
00:10:21 <fog> well, if they finish compiling that is
00:10:41 <fog> no runtime loops!? thats awesome...
00:11:35 <fog> but that seems basically like it would have to do the whole computation at compile time
00:11:44 <fog> which is horrible
00:11:59 <fog> i think i need a better way to handle recusion
00:12:42 <fog> the graphs are supposed to be cyclic though so i just guess i shouldnt try to unroll them
00:13:06 <fog> i just cant see how i would stop the typechecker from doing so
00:16:46 <fog> eg i could easily unroll a program that did a type level nats worth of computations that changed a type deterministically, like, adding one to the bounds of an int at each itteration
00:17:20 <fog> then i unroll a program, which shows that the calculation of the types is not the calculation at runtime 
00:18:15 <fog> but that the computation can still be kept finite
00:18:29 <fog> as long as its length depends only on parameters available at compile time
00:18:53 <fog> so its length cant depend on runtime information still though... so no dynamically changing lengthed computations
00:19:07 <fog> which i guess makes sense as a way to ensure it terminates!
00:20:21 <fog> i think being able to change the size at runtime would be better though
00:20:33 <fog> but this wouldnt be able to typecheck in advance
00:20:41 <fog> since the runtime information is unavailable
00:21:58 <fog> ah, so if you had a read instance, or rather, just used the show instance to write to a module
00:22:26 <fog> then you could halt the computation are rerun it with updated types!
00:22:55 <fog> "saving the runtime types"
00:23:31 <fog> so just like if you showed the type that was unfolded, this would "save" it, coding it into a module, so possibly reducing compile time, not having to calculate it again
00:23:37 <fog> (big source code!)
00:23:48 <hyiltiz> http://0x0.st/iYco.png
00:23:49 <fog> and that you could do this at runtime aswell!
00:24:19 <fog> so that while you cant typecheck the runtime code during runtime, you can output code that can be typechecked at the next run
00:24:52 <fog> typechecking also doing computations like the unfolding, so you could output runtime programs, just if you could show the runtime types
00:26:07 <fog> or am i totally wrong because there is no way to affect the types from runtime data anyway...
00:26:56 <hyiltiz> Finally succeeded in setting up the dev stack: Emacs+Spacemacs+haskell layer+lsp layer+hls+stack+emacs lsp-mode+lsp-ui+lsp-haskell for an eye candy with bells and whistles http://0x0.st/iYco.png. Setting up for neovim using VimPlug was much easier. I bet VSCode probably is even easier. Recommend anyone using Emacs to just stick to haskell-mode for syntax and linting, and rely on ghcid for help from GHC. 
00:27:08 <ski> hyiltiz : use `InstanceSigs' ?
00:27:12 <hyiltiz> Good night; finally can sleep well now
00:27:49 <iqubic> What are instance sigs?
00:28:10 <ski> you can write signatures for the methods in your `instance' declaration
00:28:13 <ski> like
00:28:22 <ski>   instance Functor Bipair
00:28:23 <ski>     where
00:28:36 <ski>     fmap :: (a -> b) -> (Bipair a -> Bipair b)
00:28:47 <ski>     fmap f (Bipair x y) = ..x..y..
00:28:48 <iqubic> Ah.
00:29:09 <ski> (instead of writing those signatures in comments ..)
00:29:25 <iqubic> Right.
00:29:44 <hyiltiz> Yeah; that was just a file I was playing around alongside Typeclasopedia. It imported almost nothing so used it for testing the setup
00:29:51 <dansho> why is that a language pragma anyway?
00:29:57 <hyiltiz> with a few obvious errors and places to optimize here and there
00:30:16 <iqubic> Also that fmap for bipair, doesn't look right.
00:30:31 <hyiltiz> lanuage pragma?
00:30:34 <fog> so now i have HCofree i can put Symbol names on the nodes that are scanning functions
00:30:55 <iqubic> It should really be "fmap f (Bipair x y) = Bipair (f x) (f y)"
00:31:05 <hyiltiz> yeah i know; it has a few bugs buried so the hls could, if working, find out, and maybe even suggest fixes that could be applied with a button click 
00:31:57 <iqubic> What editor are you using?
00:32:40 <iqubic> hyiltiz: What editor are you using?
00:32:46 <tomsmeding> emacs, they said
00:32:52 <tomsmeding> with \infty plugins
00:33:26 <iqubic> What is the color scheme there?
00:34:15 <fog> red
00:34:44 <tomsmeding> hyiltiz: that unknown unicode character in the right-bottom of your screenshot, is that 01F080 üÇÄ or 01f680 üöÄ ?
00:34:55 <hyiltiz> Color scheme: doom
00:35:08 <hyiltiz> No idea
00:35:30 <iqubic> O1F080 shows up as a domino with 4 pips on top and 1 on bottom for me.
00:35:32 <hyiltiz> Decided not to bother apparently all-the-icons didn't recognize
00:35:45 <iqubic> 0F680 doesn't show up for me.
00:35:52 <tomsmeding> rocket emoji :p
00:36:27 <iqubic> Ah. I see.
00:36:42 <hyiltiz> Hmm it doesn't build so why did I deserve a rocket
00:37:08 <iqubic> You don't.
00:37:54 <tomsmeding> I really cannot anything else than 01F080, which would mean a domino tile :')
00:37:58 <hyiltiz> Bet that is why it didn't render property
00:37:58 <tomsmeding> unlikely
00:39:20 <ski> dansho : for some reason, it was not included in Haskell 98 (nor Haskell 2010)
00:40:38 <hyiltiz> Is it in the proposal for 2020?
00:40:48 <iqubic> We need Haskell 2020.
00:42:53 <iqubic> What is the purpose of creating a typeclass in Haskell? Why not just use a record of functions?
00:43:07 <tomsmeding> typeclasses _become_ records in the compilation process
00:43:22 <tomsmeding> ghc calls them "dictionaries"
00:43:52 <justsomeguy> The idea is to overload the function names, so that they have different behavior for each type. Can you do that with records?
00:43:55 <ski> not Haskell 2022 ?
00:44:01 <hyiltiz> iqubic: you'd enjoy hacking Lua
00:44:08 <koz_> iqubic: Edward Kmett had a good take on this: https://stackoverflow.com/a/25880674/2629787
00:44:24 <iqubic> Lua is crap because it starts counting at 1.
00:44:32 <ski> iqubic : type classes also gives uniqueness of instance
00:44:49 <ski> `Map' and `Set' wouldn't work without that
00:45:28 <iqubic> Really? You can't create Map as a type and a corresponding record of functions?
00:46:52 <hyiltiz> iqubic you can tell Lua to count from 0 if that means so much
00:47:01 <iqubic> It actually does.
00:47:36 <pragma-> lol
00:47:45 <ski> iqubic : you'd need to use existentials. or give up on merge-operations
00:47:52 <iqubic> Really?
00:48:36 <ski> if you have a `Map String Blah', you want to know that when you're looking up a key, you're using the same ordering as was used, when inserting keys
00:48:59 <tomsmeding> that's just saving the dictionary in the Map, isn't it?
00:49:08 <ski> you don't want to inconsistently use different orderings, when accessing and modifying the same map
00:49:23 <ski> yes, but then you can't have merge-operations, tomsmeding
00:50:46 <tomsmeding> doesn't the whole thing where ghc compiles to dictionary passing immediately answer "yes" to the question whether we could replace typeclasses with function records?
00:50:55 <ski> you can solve this, by existentials. you basically have `makeMapOps :: (k -> k -> Ordering) -> exists m. (m,k -> v -> m -> m,k -> m -> Maybe v,...)'
00:51:09 <ski> iow, you're simulating ML-style module functors, with existentials
00:51:17 <tomsmeding> where "replacing" means replacing while maintaining semantic equality, not necessarily maintainability, readability, static checks, or performance :)
00:52:07 <ski> plain dictionary-passing doesn't ensure uniqueness
00:52:29 <tomsmeding> > not necessarily [...] static checks
00:52:31 <lambdabot>  <hint>:1:21: error: parse error on input ‚Äò]‚Äô
00:53:20 <ski> how're you going to determine whether two `k -> k -> Ordering's are the same ?
00:53:34 <alehander92> is there
00:53:43 <alehander92> a way to expand monads : to see what do they expand to
00:53:45 <tomsmeding> ski: you're not, and that's what I meant :p
00:54:50 <iqubic> Alright, I see why typeclasses are cool.
00:55:25 <iqubic> "Mechanical translation of the code to more complex manually passed dictionaries loses the uniqueness of such a dictionary at a given type." -- Edward Kmett on StackOverflow.
00:56:05 <iqubic> It's the same concept as Ski saying: "how're you going to determine whether two `k -> k -> Ordering`'s are the same ?"
00:57:07 <iqubic> ski: Edward Kmett uses explanation as you.
00:58:46 <iqubic> Basically, image that instead of relying on a typeclass, each Set just stored it's ordering function as well as it's elements. Now, when you try to union two of these sets, you have to pick which ordering function the new set will use. And it's impossible to make a logical choice here.
00:59:06 <hyiltiz> Is there a function that is uniquely determined by it's type signature? (Weird implementations as counterexamples are allowed)
00:59:48 <hyiltiz> I'm thinking map or composition .
01:00:02 <iqubic> I can give you a very simple example.
01:00:13 <iqubic> f :: x -> x
01:00:18 <hyiltiz> But they don't seem to be the only functions for their type 
01:00:42 <iqubic> There's only one way I know of to create a function with the signature "x -> x"
01:00:43 <hyiltiz> Hmm lemme come up with a weird function
01:00:56 <tomsmeding> in fact, that's the whole point of parametricity :)
01:01:20 <tomsmeding> see also: Theorems for free! by Philip Wadler: https://ecee.colorado.edu/ecen5533/fall11/reading/free.pdf
01:01:27 <iqubic> If I tell you that f has type "x -> x" you can be 100% certain that f does the same thing as id.
01:01:44 <hyiltiz> Num x=> x->x would have many obvious counterexamples
01:01:53 <tomsmeding> yes, but now you changed the type :)
01:01:59 <iqubic> hyiltiz: Correct. But that's a different type.
01:02:03 <hyiltiz> Yeah I know
01:02:39 <hyiltiz> id.id
01:02:46 <iqubic> the function composition operator (.) is the only such possible function with that type.
01:02:57 <hyiltiz> But that is obviously cheating
01:03:06 <iqubic> What is cheating?
01:03:17 <hyiltiz> Although we may not be able to prove in general functional equivalence
01:04:11 <iqubic> If I tell you that I have a function with type "(b -> c) -> (a -> b) -> a -> c" you can be 100% sure that it's going to do the same thing as (.) does.
01:04:13 <hyiltiz> id.id for x->x can be regarded cheating
01:04:23 <iqubic> :t id . id
01:04:25 <lambdabot> c -> c
01:04:56 <iqubic> That's still the same exact function.
01:05:08 <iqubic> It's still doing the same exact thing.
01:05:50 <hyiltiz> iqubic: is there theorems that guarantee this for id and . categorically?
01:05:50 <iqubic> If I give the same input to both "id" and "id.id", I'm going to get the same output both times.
01:06:49 <iqubic> Yes, there are. But I don't know them.
01:06:49 <tomsmeding> hyiltiz: see Theorems for Free! ;)
01:06:54 <hyiltiz> I know; but we'd be hard pressed to prove so if they were black boxes; we'd have to put everything in the universe in there to test and it won't seriously be enough
01:07:50 <iqubic> @free f :: (a -> b) -> [a] -> [b]
01:07:50 <lambdabot> h . k = p . g => $map h . f k = f p . $map g
01:07:51 <shachaf> I don't even know how many inhabitants ((b -> c) -> (a -> b) -> a -> c) has in Haskell, but it's a lot.
01:08:06 <iqubic> shachaf:
01:08:15 <iqubic> Are you sure about that?
01:08:31 <shachaf> I don't even really know a systematic way to count these.
01:08:34 <hyiltiz> I did read theorems for free; but can't we build a weird universe with weird hairy categories where id doesn't have the property? 
01:08:47 <shachaf> There's at least undefined, \_ -> undefined, \_ _ -> undefined, \_ _ _ -> undefined
01:08:57 <iqubic> I mean, even if there are multiple inhabitants, surely they're all isomorphic.
01:09:14 <shachaf> What does isomorphism of inhabitants mean?
01:09:18 <tomsmeding> shachaf: okay fair :p
01:09:30 <tomsmeding> if you exclude bottoms, there is only one
01:10:11 <iqubic> shachaf: if you include bottom/undefined, then I can give you two inhabitants of "x -> x": "id" and "const undefined"
01:10:16 <tomsmeding> shachaf: I guess two inhabitants of a type can be usefully named "isomorphic" if for all inputs, they give the same output (possibly including behaviour in the presence of bottoms)
01:10:21 <hyiltiz> E.h. Banach Tarski allows x->(x,x) using only id
01:10:28 <tomsmeding> iqubic: and another one: "undefined"
01:10:32 <shachaf> There are three inhabitants of (forall a. a -> a).
01:10:38 <iqubic> tomsmeding: Sure.
01:10:52 <shachaf> tomsmeding: Why is that called isomorphic?
01:11:00 <tomsmeding> I don't know, I just invented that term :)
01:11:03 <shachaf> Is it isomorphism in some category or something?
01:11:04 <tomsmeding> it sounds useful
01:11:19 <shachaf> I would call it (extensional) equality (for function types).
01:11:34 <tomsmeding> probably better
01:12:49 <hyiltiz> :t id undefined
01:12:51 <lambdabot> a
01:13:17 <hyiltiz> :t id $! undefined
01:13:18 <lambdabot> b
01:13:51 <hyiltiz> :t id !$ undefined
01:13:51 <iqubic> I'd claim that the Banach-Tarski paradox requires more than just "id". It requires the ability to cut up your input, rearrange it, then fuse it back together. But in haskell, if you have a function of type "a -> a" you cannot cut up the input. You can't even inspect it at all. You can do nothing with the input besides returning it exactly as it is.
01:13:52 <lambdabot> error:
01:13:52 <lambdabot>     ‚Ä¢ Variable not in scope: (!$) :: (a0 -> a0) -> t0 -> t
01:13:52 <lambdabot>     ‚Ä¢ Perhaps you meant one of these:
01:14:44 <iqubic> hyiltiz: What are you trying to do there?
01:14:49 <hyiltiz> Hmm right; 
01:15:18 <hyiltiz> NVM that seems like a meaningless experiment
01:16:03 <hyiltiz> So in any category algebra x->x is always id?
01:16:11 <iqubic> Yes.
01:16:23 <hyiltiz> Is there really no counter example?
01:16:42 <iqubic> There really are no counter examples.
01:17:23 <hyiltiz> Or, if God could bully us what would He need to do so that no longer uniquely corresponds to id?
01:17:54 <hyiltiz> s/could/wanted to/
01:19:26 <hyiltiz> If the answer is nothing, is that a proof for atheists since such a simple power doesn't exist?
01:20:18 <koz_> Are we in category theology again?
01:20:49 <siraben> hyiltiz:  due to parametricity, the only function that inhabits forall a. a ‚Üí a is id
01:21:06 <iqubic> I feel like this comes down to a matter of semantics. A function of type "a -> a" can only do one thing: take the input and return it unchanged. This happens to be the very thing we call "id".
01:21:10 <siraben> similarly, there are unique functions for forall a b. a ‚Üí b ‚Üí a, etc.
01:21:25 <koz_> siraben: That's const, right?
01:21:31 <siraben> koz_:  Yes.
01:21:41 <siraben> s/unique functions/a unique function
01:21:45 <iqubic> All of this assumes you ignore bottom/unique
01:21:55 <ski> iqubic : we've talked about it before, in here
01:22:01 <siraben> Right. Get rid of bottoms!
01:22:09 <iqubic> ski: Talked about what?
01:22:26 <ski> iqubic : the utility of uniqueness of type class instances
01:22:46 <siraben> ski:  What was your conclusion from that discussion?
01:23:17 <hyiltiz> http://hackage.haskell.org/package/free-theorems-counterexamples
01:23:25 <hyiltiz> I wonder what's in there
01:24:07 <iqubic> What's in there almost certainly mathematically incorrect.
01:25:25 <siraben> iqubic:  in thet package?
01:25:25 <ski> which one, siraben ?
01:25:34 <iqubic> siraben: Yes.
01:25:44 <siraben> ski:  The one you had about "the utility of uniqueness of type class instances"
01:26:07 <ski> oh. that was years ago
01:26:21 <ski> (quite possibly more than ten or fifteen)
01:26:32 <siraben> Oh wow.
01:26:46 <siraben> What's a good way to learn about free theorems, Wadler's Theorems for Free paper?
01:26:57 <siraben> And I'm assuming his follow-up paper, Theorems for Free for Free.
01:27:01 <ski> (at least five, i'd say. anyway, the topic has come up, many times, in here)
01:28:28 <tomsmeding> hyiltiz: that free-theorems-counterexamples package certainly does stuff with bottoms
01:28:35 <hyiltiz> I always took it granted; of course x->x only means id. Now I'm deeply puzzled by the power of that statement
01:28:44 <tomsmeding> search for "test1 =" in https://hackage.haskell.org/package/free-theorems-counterexamples-0.3.1.0/src/Language/Haskell/FreeTheorems/Variations/CounterExamples/Test/TestItExt.hs
01:28:55 <hyiltiz> I wouldn't want anyone's bottoms though
01:29:09 <hyiltiz> Wouldn't make an interesting discussion
01:29:18 <tomsmeding> it gives a term of type 'forall a. a' by using a bottom
01:29:20 <siraben> hyiltiz:  you could view it categorically, if there was any other function that satisfied x ‚Üí x it _must_ be id
01:29:44 <ski> naturality
01:30:12 <siraben> Universal properties, IIRC
01:30:13 <hyiltiz> Yes! Let's say there were two: id and di that both satisfy 
01:30:30 <hyiltiz> Can we now prove they are isomorphic?
01:30:48 <siraben> functional extensionality, maybe?
01:31:08 <hyiltiz> id.di==di.id
01:31:15 <hyiltiz> Something like that?
01:31:25 <siraben> Nah, equational reasoning will do: id = id . di = di
01:31:27 <siraben> Right
01:31:49 <tomsmeding> how do you derive that 'id = id . di'
01:31:50 <hyiltiz> Where == requires stuff less complicated that busy braver?
01:32:05 <siraben> tomsmeding: Yeah, I'm unsettled by the fact that we assumed di acted as a unit of composition. How do we know that?
01:32:16 <tomsmeding> we don't, that's the entire thing we're trying to prove :p
01:32:21 <hyiltiz> ‚àÜ
01:32:32 <ski> (`=', not `==')
01:32:34 <tomsmeding> I think you have to let the language of expression enter the discussion
01:32:36 <siraben> Looks like you wouldn't be able to prove it within the system
01:33:05 <hyiltiz> Please don't tell me we are entering Godel
01:33:06 <siraben> I asked about proving parametricity in #coq before, and the people there said that it wasn't possible to do so.
01:33:11 <iqubic> Here's a good example of paramatricity: Let's say you are writting a functor instance. You'll want to make sure it satisfies the functor laws. Any functors that satisfies "fmap (f . g)  ==  fmap f . fmap g" will always, 100% of the time the other law: "fmap id = id"
01:33:14 <siraben> Within Coq.
01:33:53 <siraben> iqubic:  Ok, so where does parametricity come in?
01:34:09 <kuribas> is it possible to use ghc as a JIT compiler, using core as backend?
01:34:15 <iqubic> No clue.
01:34:20 <ski> iqubic : `fmap _ _ = Nothing' ?
01:34:22 <hyiltiz> I've seen those enough and it's explanations enough to feel it is seconds nature. But now I'm questioning the universe I'm living in.
01:34:28 <siraben> Dammit, WK is a stub. https://en.wikipedia.org/wiki/Parametricity
01:34:45 <tomsmeding> kuribas: how do you define a JIT compiler in this sense? what compiler can you _not_ use as a JIT compiler?
01:35:38 <iqubic> ski: Does "fmap _ _ = Nothing" satisfy, "fmap (f . g)  ==  fmap f . fmap g"?
01:35:45 <hyiltiz> Can id===di be proven with formal lambda calculus alone? I doubt it
01:35:59 <tomsmeding> iqubic: can you give a counterexample? :)
01:36:04 <iqubic> No.
01:36:08 <kuribas> tomsmeding: JIT compilation means compiling functions on the fly, instead of the whole program at a single time.
01:36:26 <tomsmeding> ah, then no idea :)
01:36:46 <siraben> hyiltiz:  Going back to proving that there is only one unique identity, we just use the categorical definition of id.
01:36:52 <tomsmeding> wouldn't be surprised if the answer is no, or not easily, because the ghc api is not nice
01:37:28 <siraben> Let id and di take an object X to object X for all X, so for a given Y, di Y = di (id Y) = id Y
01:38:22 <hyiltiz> No it needs to take types not objects
01:38:44 <ski>   fmap (f . g)  =  \_ -> Nothing  =  \x -> fmap f (fmap g x)  =  fmap f . fmap g
01:38:58 <iqubic> hyiltiz: In category theory, types can be objects.
01:39:07 <siraben> hyiltiz:  The objects of the category of types are types.
01:39:18 <siraben> We don't speak of the "value level"
01:39:35 <hyiltiz> Ok
01:39:48 <hyiltiz> I don't understand the seconds equality
01:40:06 <siraben> We said that di takes X to X for all X, so it must take id Y to id Y.
01:40:29 <ski> there is no values, categorically speaking
01:40:39 <ski> or, if you want, values are morphisms
01:40:40 <siraben> it's better to express in pointfree, let id . f = f . id = f for all f, and di . f = f . di = f for all f
01:40:48 <siraben> Then id = id . di = di
01:41:14 <hyiltiz> Ok so f x=g x reduces to f=g for all x?
01:41:15 <siraben> Because they satisfy the universal property of id
01:41:29 <ski> you're talking about uniqueness of neutral element, siraben, though. not about uniqueness of `f :: forall a. a -> a'
01:41:41 <siraben> Hm, right.
01:41:55 <ski> hyiltiz : that sounds confused ?
01:42:32 <siraben> "For example, we showed that parametricity ensures that all functionsof type‚àÄùõº.ùõº ‚Üí ùõºare the identity function"
01:42:34 <siraben> https://www.cl.cam.ac.uk/teaching/1516/L28/parametricity.pdf
01:42:36 <siraben> Page 9
01:42:39 <hyiltiz> No I'm not confused; I'm thinking what if that x is the output of a busy braver
01:43:19 <hyiltiz> I.e. functional equivalence should also depend on its arguments even if it is forall 
01:43:20 <iqubic> 1. It's busy beaver, and 2. we're not talking about values here.
01:43:58 <hyiltiz> Busy beaver is within forall though
01:44:05 <hyiltiz> And it is not bottom
01:44:30 <ski> what's `x', hyiltiz ?
01:44:45 <hyiltiz> We could parametrize BB n as a type 
01:45:18 <siraben> hyiltiz:  I think you're confusing several things together
01:45:23 <iqubic> No, actually, you can't.
01:45:30 <hyiltiz> x is any type object including BB 
01:45:38 <siraben> We're talking about how the type (forall a. a ‚Üí a) induces a unique function that we know as id.
01:45:44 <hyiltiz> Oh ok I'll shut up and listen
01:47:14 <hyiltiz> [04:38] <458588siraben> Let id and di take an object X to object X for all X, so for a given Y, di Y = di (id Y) = id Y
01:47:52 <hyiltiz> I liked this proof but not sure if the omitted last step that reduces out x is universally valid 
01:48:13 <hyiltiz> Sorry it is reducing Y
01:48:31 <iqubic> There is no omitted step there. That's the entire proof.
01:49:03 <hyiltiz> But it only proceed di Y=id Y forall Y
01:49:15 <hyiltiz> Not di=id
01:49:26 <iqubic> Those are the same statements.
01:49:28 <ski> function extensionality says `forall f,g. (forall x. f x = g x) => f = g'
01:49:59 <hyiltiz> I understand the majority believes those statements are equivalent. I'm staying doubtful
01:50:24 <ski> (functions which "behave the same", that is give equal outputs, for all possible (equal) inputs, are to be considered as equal functions)
01:50:27 <iqubic> Alright, in that case you can ue ski's function extensionality argument.
01:50:33 <hyiltiz> Is function extensionally an axiom?
01:50:52 <ski> you can prove it, using eta (or vice versa)
01:51:24 <hyiltiz> Yeah but all inputs surely include BB type stuff which we can't observe
01:51:51 <hyiltiz> Oh I'll try that eta reduction
01:52:18 <iqubic> hyiltiz: again, we aren't talking about values, but types.
01:54:05 <hyiltiz> Yes but that extentionality axiom requires observing inputs and outputs of id hence values, no?
01:54:31 <siraben> hyiltiz:  https://en.wikipedia.org/wiki/Axiom_of_extensionality
01:54:47 <hyiltiz> Just skimmed it
01:55:25 <hyiltiz> Do they weren't thinking about BBs at all when formulating that axiom
01:55:39 <hyiltiz> s/Do/So
01:55:42 <siraben> What's your fixation on busy beavers? That's from computability theory.
01:56:05 <hyiltiz> Yes. How is that irrelevant?
01:56:22 <hyiltiz> It is a class of interesting functions
01:56:42 <ski> <ski> there is no values, categorically speaking
01:56:57 <ski> do you want to reason categorically, here ?
01:57:08 <hyiltiz> Yes please
01:57:15 <ski> then forget about values
01:57:19 <hyiltiz> Ok
01:57:33 <iqubic> Busy Beaver only exists at the value level.
01:57:42 <ski> or, define then as morphisms from some particular object. commonly the terminal object
01:58:03 <hyiltiz> What's a terminal object?
01:58:24 <Graypup_> ski, I put my head down and coded for a bit and figured it out, I just have to constrain the parameters properly, which I figured out more about from reading a pile of source code :)
01:58:25 <ski> an object such that there's a unique morphism to it, from any object in the category
01:58:40 <Graypup_> and also redesigned my API lol
01:59:23 <ski> Graypup_ : mm, i was trying to determine that context, by inquiring about how you wanted to use your types
01:59:45 <Graypup_> anyway the reason I am back here is that I am wondering about whether I can make an alias for the union of Monad, MonadIO, MonadThrow because it's cluttering up my signature hehe
01:59:56 <ski> hyiltiz : exercise : what's a terminal object in `Set' ?
02:00:03 <iqubic> Graypup_:
02:00:09 <hyiltiz> {}
02:00:14 <ski> no
02:00:21 <hyiltiz> I was thinking the terminal watermelon
02:00:32 <iqubic> Graypup_:  Just use a type synonym.
02:00:37 <ski> there is no morphism at all from e.g. `{0}' to `{}'
02:01:00 <siraben> It is the singleton set, for every other set S, there is exactly one way to get from S to {*}
02:01:15 <ski> spoilsport
02:01:19 <siraben> In the category of types, it is Unit ()
02:01:27 <siraben> ski:  :P
02:01:34 <Graypup_> iqubic, so like type MyMonad m = (MonadThrow m, MonadIO m, Monad m) or?
02:02:06 <iqubic> Oh, I see. You want a synonym for the constraint. I'm not sure if that's possible.
02:02:06 <ski> hyiltiz : what's a terminal object in `Rel' (the category of sets as objects, and binary relations between them as morphisms) ?
02:02:56 <ski> Graypup_ : you can just drop `Monad m' from there, since it's implied by `MonadIO m' (the latter having the former as superclass)
02:03:20 <ski> iqubic : yes, it's possible
02:03:42 <iqubic> Does every category have a terminal object?
02:04:01 <hyiltiz> I read that five times. Still thinking about binary relations between sets
02:04:03 <ski> you need to turn on the `ConstraintKinds' language extension, though
02:04:04 <ski> iqubic : no
02:04:30 <ski> iqubic : but if it has any, then all of them are isomorphic. so, "upto isomorphism", there's at most one
02:04:47 <iqubic> Right. Sure.
02:05:09 <ski> example of a category without a terminal object : natural numbers, with the usual (additive/arithmetic) ordering
02:05:24 <iqubic> Sure.
02:05:28 <dminuoso> Or any discrete category
02:05:48 <ski> "at most one, upto isomorphism" holds for all categorical constructions, specified via a universal (mapping) property
02:05:53 <iqubic> Does Rel have a terminal object?
02:05:54 <Taneb> dminuoso: assuming it has not precisely one object
02:06:01 <dminuoso> Taneb: Ah right.
02:06:07 <ski> dminuoso : what Taneb said :)
02:06:07 <hyiltiz> So the terminal object is like the end of a string/manifold?
02:06:39 <ski> thinking of it as the "end" or the "last object" is a good rough picture
02:06:51 <ski> (or "the greatest")
02:07:13 <Taneb> iqubic: hmm, possibly the empty set?
02:07:52 <hyiltiz> The Power set is the terminal for Real?
02:07:55 <ski> iqubic : does it have an initial object ?
02:07:58 <hyiltiz> Rel
02:08:08 <ski> (btw, "terminal" is also sometimes called "final")
02:08:26 <Taneb> From any set X there is only one relation X R {}, which is the empty relation
02:08:30 <ski> power set of what, hyiltiz ?
02:08:52 <hyiltiz> Any two sets in Set
02:08:57 * ski thinks Taneb's mixing types and values
02:09:18 <ski> power set is a construction that only takes one set, not two sets
02:09:26 <iqubic> ski: You posed the question "what is the terminal object for Rel?" I'm questioning if this set even has a terminal object.
02:09:30 <siraben> Category theory has a lot of one-liners "universal properties", for terminal objects it is an object T such that for any X there exists precisely one morphism X ‚Üí T
02:09:36 <ski> s/this set/this category/
02:09:54 <Taneb> iqubic: Wikipedia page for "Initial and terminal objects" says Rel does have a terminal object
02:10:14 <siraben> In Rel, IIRC the terminal and initial objects coincide
02:10:17 <siraben> {}
02:10:22 <Taneb> In Grp also!
02:10:22 <ski> yes
02:10:27 <siraben> Ooh
02:10:39 <hyiltiz> Why it's it {}?
02:10:42 <Taneb> (the category of groups, the trivial group is both initial and terminal)
02:11:12 <ski> hyiltiz : consider `R : X <-> {}'. `R' can only be the empty relation
02:11:16 <hyiltiz> How is that related to binary relations tho
02:11:50 <hyiltiz> WTF is the empty relation?
02:12:03 <Taneb> hyiltiz: can you define a binary relation for me
02:12:27 <hyiltiz> f x y=x+y
02:12:35 <Taneb> That's a binary operator
02:12:35 <hyiltiz> For numbers though
02:12:41 <siraben> Taneb:  A relation between R two sets A and B can be thought of as a subset of AxB
02:13:05 <Taneb> siraben: I wanted to see the definition hyiltiz was using
02:13:16 <ski> or as a function from that cartesian product, to the set of truth-values
02:13:19 <siraben> This subset encodes the relation. For instance, the ‚â§ relation on N has (0,0) (1,1) (2,2) ... and others in it
02:13:20 <siraben> Ah, ok.
02:13:22 <Taneb> Because it didn't seem to match what I was expecting
02:13:32 <siraben> Right, if you're inclined to use valuations, hehe.
02:14:18 <hyiltiz> we are going towards functional extentions right?
02:14:30 <ski> ?
02:14:42 <iqubic> h
02:14:52 <hyiltiz> From these discussions about terminal objects
02:15:03 <Taneb> hyiltiz: what you were calling a binary relation isn't what the rest of us were calling binary relations, hence the confusion
02:15:32 <hyiltiz> Functional extensionality to be precise
02:15:39 <ski> you said you wanted to reason categorically, hyiltiz. atm we're reviewing some categorical concepts
02:15:52 <hyiltiz> Yes I'm still listening
02:16:19 <hyiltiz> Shall I try to give an binary relations example for Set now?
02:16:40 <ski> not `Rel' ?
02:16:50 <hyiltiz> Oh Rel 
02:17:52 <ski> if you have a binary relation between two finite sets, then you can think of the relation as a matrix, with truth-values as scalars
02:18:21 <ski> then composition of binary relations becomes matrix multiplication
02:19:05 <hyiltiz> A function that returns the Cartesian product with maximum cardinality 
02:19:26 <hyiltiz> Would that be a binary relation?
02:23:41 <siraben> hyiltiz:  Yes, it relates everything in A to everything in B.
02:24:31 <iqubic> But how can that be a morphism? How does that let you turn a given Set a into a different set b?
02:25:36 <hyiltiz> No it doesn't
02:25:39 <ski> (truth-values don't form a field (no division), though, so this isn't a category of vector spaces. they don't even form a ring (no subtraction) (which would make it a category of modules), but they do form a rig / semiring)
02:26:41 <ski> morphisms don't "turn things into other things"
02:26:51 <ski> they start somewhere, and they end somewhere
02:27:27 <iqubic> So how does a binary relation start a one set, and end at a different one?
02:28:10 <ski> if two morphisms both start in the same place, and both end in the same place, you can ask whether they're equal
02:28:25 <iqubic> Sure.
02:29:04 <maralorn> ski: You can still make morphism composition work by applying the map 0 -> 0, _ -> 1 to every entry after the multiplication.
02:29:32 <ski> to talk about a morphism, you must already have decided what source/domain and what target/codomain objects you're considering
02:29:54 <ski> maralorn : multiplication ?
02:30:45 <maralorn> ski: I was talking about "composition of binary relations becomes matrix multiplication"
02:30:59 <ski> so, if you have picked two sets, `A' and `B', you can now consider morphisms in `Rel' from `A' to `B'. they are (using the above definition) the subsets of `A * B'
02:32:09 <iqubic> But then a morphisim from `A' to `B' would be the same as a morphism from `B' to `A'
02:32:15 <ski> maralorn : what wouldn't work, without requiring that ?
02:32:27 <ski> no, iqubic
02:32:54 <iqubic> What's wrong with my statement?
02:33:20 <iqubic> Isn't `A * B' the same set as `B * A'?
02:33:21 <hyiltiz> Every 2 As gets mapped to one B; seems fine
02:33:27 <ski> you're not allowed to ask whether two morphisms are equal, when their domains, or their codomains (or both), are not known to be equal
02:33:44 <ski> if `f : A >---> B' and `g : A >---> B', then you can ask whether `f = g'
02:33:55 <iqubic> Right.
02:34:19 <ski> iqubic : and no, in general, `A * B' is not the same as `B * A', even in set theory
02:34:44 <iqubic> But I can't compare f : A >---> B with g : B >---> A, because those have different domains and different codomains.
02:34:53 <ski> right
02:34:58 <iqubic> It's like comparing apples to oranges.
02:35:17 <maralorn> ski: If I read the matrix as "a 1 at i,j if there is a path from i to j" then after the matrix multiplication you could have multiple paths from one element to another one. So the matrix after the multiplication could contain naturals bigger than one.
02:35:20 <hyiltiz> Wait how do we know domain equality? 
02:35:21 <ski> (even if one of `A' and `B' is the empty set)
02:35:31 <hyiltiz> That domain is gonna contain my BBs
02:35:52 <iqubic> Again, we're still not talking about values.
02:36:03 <ski> we normally don't test equality of objects
02:36:30 <hyiltiz> Sure but you just said as long as the domains and codomains are equal
02:36:42 <hyiltiz> How's that equality defined?
02:36:48 <ski> maralorn : only if you use the usual `+', rather than `or' on truth-values
02:36:54 <hyiltiz> Symbolicallly?
02:37:35 <ski> there's a difference between a propositional equality, and an equality test/check
02:37:47 <hyiltiz> Agreed.
02:37:47 <iqubic> I think it's mostly just that two domains are equal if the domains are the object.
02:38:00 <iqubic> *same object
02:38:18 <maralorn> ski: Ah, that didn‚Äòt come to my mind, probably because of the "it's not a field" issues you mentioned.
02:38:24 <hyiltiz> using SAME when defining = huh
02:38:47 <ski> (i did mention it was a rig)
02:39:12 <ski> hyiltiz : "same" on meta-level, vs. on object-level
02:39:47 <maralorn> If you do normal CT there is a thing as equality.
02:40:32 <hyiltiz> That begs the question: that meta level are themselves objects of a metameta level?
02:40:51 <maralorn> The objects form a set (or rather a class). And you can meaningfully ask if two elements of a class are the same.
02:41:37 <hyiltiz> Sure
02:41:49 <ski> (equality can be described in terms of an adjoint involving the diagonal ‚åúŒî : A ‚Üí A √ó A‚åù, which duplicates a name ‚åúx‚åù into two copies ‚åú(x,x)‚åù)
02:41:50 * hackage ffunctor 1.2.1 - FFunctor typeclass  https://hackage.haskell.org/package/ffunctor-1.2.1 (fommil)
02:42:38 * ski . o O ( œâ-categories )
02:42:52 <maralorn> But equality is a finnicky concept and in most categories you regard elements "the same" if they fulfill some equivalence relation.
02:43:20 <ski> usually you're more interested in isomorphism than "equality on the nose"
02:43:47 <ski> (univalence in HoTT generalizes "equality" to include "isomorphism", though)
02:44:16 <hyiltiz> I'm wondering how that definition aligns with 1+1=2 but I kinda see that is beyond the point
02:44:39 <hyiltiz> It is just values and successor function defining 2
02:44:57 <siraben> A ‚â° B ‚â° A ‚âÖ B
02:45:59 <ski> @quote makes.my.brain
02:45:59 <lambdabot> Adamant says: Haskell makes my brain taste like burning
02:46:03 <hyiltiz> Hmm I see now how it comes back to functional extensionality
02:46:05 <ski> ah
02:46:07 <ski> @quote makes.my.brain
02:46:07 <lambdabot> wedens says: HoTT makes my brain hot
02:46:19 <ski> you do, hyiltiz ?
02:46:31 <hyiltiz> HoTT is what?
02:46:40 <ski> Homotopy Type Theory
02:46:46 <ski> @where HoTT
02:46:46 <lambdabot> http://homotopytypetheory.org/book/
02:46:48 <maralorn> ski: I don‚Äòt even know what a rig is. My job deals with matrices with complex entries all day. Everything else feels like intentionally making structures less usefull.^^ (kidding of course)
02:46:59 <ski> maralorn : a ring without negation
02:47:16 <ski> > "ring" \\ "n"
02:47:17 <lambdabot>  "rig"
02:47:57 <Graypup_> say I want to leave half a type uninitialized because I am not using half a library and the unused fields have no meaning (and it would be preferable to crash if I forgot some). I have made a binding using data constructor syntax, but the compiler is (entirely reasonably) throwing a warning at me for it. suppress the warning, or is there syntax to say "yes this is deliberate"?
02:48:01 <hyiltiz> I thought I did: I was insisting on test based computational equality in all values; you are showing isomorphism don't require values
02:48:06 <maralorn> ski: I didn‚Äòt know rings have negation. Is that the ring from my algebra course?
02:49:22 <ski> maralorn : "Objects of Categories as Complex Numbers" by Marcelo Fiore,Tom Leinster in 2002-12-30 at <https://arxiv.org/abs/math/0212377> might be fun to take a glance at ?
02:50:08 <ski> hyiltiz : we were pointing out that categorical language doesn't refer to values
02:50:31 <hyiltiz> Yeah and that is magically weird
02:50:55 <ski> it uses morphisms, in place of values
02:51:11 <hyiltiz> Feels kinda like physicists insist on forces/fields not particles/matter
02:51:45 <hyiltiz> Though it is not a good analogy 
02:51:48 <iqubic> It's not magic, it's just a diffent way of looking at things.
02:51:58 <maralorn> Graypup_: If the datatype is strict in its fields you are out of luck. But if it's not you could define all other fields as error "Don't use this field" ore something similar. Of course that can introduce runtime bugs.
02:52:26 <hyiltiz> So going back to the God who'd like to bully us
02:53:15 <hyiltiz> What knob can He turn in CT s.t. x->x doesn't uniquely specify id?
02:53:44 <hyiltiz> Surely he can redefine a completely different way of looking at things
02:54:09 <ski> instead of `f x : B', where `x : A' and `f : A -> B', you have ‚åúf ‚àò x : T ‚Üí B‚åù where ‚åúx : T ‚Üí A‚åù and ‚åúf : A ‚Üí B‚åù
02:54:12 <maralorn> hyiltiz: The reason is, that CT is so general, that there are a lot of categorys don‚Äòt have a meaningful notion of values i.e. elements of objects. And that's why we can‚Äòt a priori have a notion of talking about them (even if they exist in some special category.)
02:54:37 <ski> in ‚åúSet‚åù, ‚åúT‚åù here could be terminal
02:55:45 <ski> hyiltiz : what do you mean by `x->x' ?
02:56:04 <Graypup_> maralorn, yeah I've just set them all to undefined, and it will crash if I messed up ;-)
02:56:11 <hyiltiz> Type signature
02:56:17 <ski> what is `x' ?
02:57:03 <hyiltiz> For all category/type X, X -> X
02:57:34 <ski> note that all morphisms in a category are "monomorphic"
02:57:50 <maralorn> ski: Don't talk about the terminal object of set, I'm traumatized. My austrian professor pronounced "ein" (one) as "n" (n). And it took me have an hour to understand why he said that the terminal object in set is the set with n elements.
02:57:52 <maralorn> s/have/half/
02:58:29 <iqubic> ski: That's a dreaded restriction.
02:58:34 <ski> aww, that sounds confusing, maralorn
02:58:51 <hyiltiz> ski: didn't understand the msg with a few equations
02:59:19 <ski> signatures, not equations, no ?
02:59:30 <ski> (unless you're referring to some old message)
02:59:42 <hyiltiz> [05:55] <b8bb26ski> instead of `f x : B', where `x : A' and `f : A -> B', you have ‚åúf ‚àò x : T ‚Üí B‚åù where ‚åúx : T ‚Üí A‚åù and ‚åúf : A ‚Üí B‚åù
02:59:46 <ski> yes
03:00:34 <hyiltiz> Oh wait I think I do now
03:00:50 <hyiltiz> Not values just morphisms from that terminal
03:00:59 <hyiltiz> Sneaky
03:01:35 <ski> instead of talking of values/elements/inhabitants of a set ‚åúA‚åù (object in the category ‚åúSet‚åù) (so, values ‚åúx : A‚åù), you can talk about morphisms ‚åúx : T ‚Üí A‚åù, where you can take ‚åúT‚åù as a terminal object
03:01:42 <hyiltiz> Wait so what was the definition for isomorphism again?
03:02:09 <hyiltiz> Now that we encoded values into morphisms
03:02:39 <ski> note that there is a bijection between values ‚åúx : A‚åù and functions ‚åúf : 1 ‚Üí A‚åù, if we use ‚åú1‚åù to stand for some particular terminal object (e.g. the type `()', in Haskell terms)
03:03:29 <ski> given ‚åúx : A‚åù, you can define a corresponding ‚åúf : 1 ‚Üí A‚åù as ‚åúf () = x‚åù. and given ‚åúf : 1 ‚Üí A‚åù, you can define a corresponding ‚åúx : A‚åù as ‚åúx = f ()‚åù
03:03:49 <hyiltiz> Yes
03:03:54 <ski> (and morover, going forward and back here, you get back the thing you started with, so that this is a bijection)
03:04:34 <ski> so, instead of talking about values ‚åúx : A‚åù, we can (in ‚åúSet‚åù) elect to talk about morphisms ‚åúx : 1 ‚Üí A‚åù from the terminal object
03:04:51 <hyiltiz> Sure
03:05:36 <ski> and instead of function application ‚åúf x : B‚åù, we simply get morphism composition ‚åúf ‚àò x : 1 ‚Üí B‚åù, given some ‚åúf : A ‚Üí B‚åù
03:05:50 <ski> also, note that the definition of composition, namely
03:06:07 <ski>   (g ‚àò f) x = f (g x)
03:06:11 <ski> now becomes just
03:06:20 <ski>   (g ‚àò f) ‚àò x = f ‚àò (g ‚àò x)
03:06:44 <ski> iow, associativity of composition (in the case that the "first" morphism starts at the terminal object)
03:07:28 <hyiltiz> Oh nice
03:08:18 <hyiltiz> Now isomorphism requires same domain (both T, check) and codomain (A, B) and something else
03:08:20 <ski> however, instead of just talking about "global points" of ‚åúA‚åù, being morphisms ‚åúf : 1 ‚Üí A‚åù, it's also useful to talk about "generalized points" ‚åúf : T ‚Üí A‚åù, where ‚åúT‚åù is allowed to be any object
03:08:43 <maralorn> (Of course that only works in categories with a terminal object. And there are categories where there are more values in A than morphisms T -> A.)
03:09:12 <ski> hyiltiz : usually we wouldn't talk about isomorphic morphisms ..
03:10:13 <hyiltiz> But that is the rug where = now got swept under
03:10:56 <ski> an isomorphism is a morphism between two objects, satisfying some particular property
03:11:16 <ski> two objects are isomorphic, if there's some isomorphism between them
03:11:20 <hyiltiz> objects or categories?
03:11:32 <ski> objects
03:12:16 <hyiltiz> Didn't we accidentally circle back with a lot more fancy vocabulary?
03:12:41 <ski> do you see why "Now isomorphism requires same domain (both T, check) and codomain (A, B) and something else" sounds possibly confused ?
03:12:46 <hyiltiz> Apparently it is not but for a noob like myself it seems so
03:13:58 <hyiltiz> Yes, isomorphism isn't defined for morphisms
03:14:00 <ski> "same domain" suggests that you're talking about two morphisms. which suggests that you're talking about when two morphisms are "isomorphic". but usually, we talk about two objects being isomorphic
03:14:55 <hyiltiz> Yes. But we encoded the objects into morphisms. Now the interesting equality is between morphisms not objects.
03:14:59 <ski> (in a 2-category, you can talk about two isomorphic morphisms .. but that's not usual categories)
03:15:38 <ski> "we encoded the objects into morphisms" -- no. we encoded values/elements/points as morphisms
03:16:10 <hyiltiz> Hmm
03:16:55 <hyiltiz> Aren't objects like a set S in Set?
03:17:12 <hyiltiz> Hence like values/points?
03:17:15 <ski> (please forget the notion of "object" from computing science or programming. "object" in category theory means something else)
03:17:30 <ski> a set is not the same as its values/points
03:17:37 <ski> a container is not the same as its contents
03:17:39 <hyiltiz> Yeah not thinking OO at all
03:18:02 <ski> the empty set exists, but there's no contents, no points in it
03:18:23 <ski> (medieval scholastics confused these things with each other)
03:18:41 * hyiltiz grins and nods
03:19:30 <maralorn> I agree that the empty set is irrelevant, no point in it ‚Ä¶
03:19:31 <ski> (while in India (also Mayas), they invented the zero digit. possibly because they were contemplating sunyata, emptiness)
03:19:58 <ski> you mean, "no point to it", maralorn ?
03:20:11 <ski> (that is, no morphisms ‚åúf : 1 ‚Üí 0‚åù)
03:20:19 * hackage keera-hails-i18n 0.7.0 - Rapid Gtk Application Development - I18N  https://hackage.haskell.org/package/keera-hails-i18n-0.7.0 (keera_studios_ci)
03:21:11 <hyiltiz> [06:21] <ski> (that is, no morphisms ‚åúf : 1 ‚Üí 0‚åù)
03:21:17 <hyiltiz> REALLY!?
03:21:19 * hackage keera-hails-reactive-yampa 0.7.0, keera-hails-reactivevalues 0.7.0, keera-hails-reactive-wx 0.7.0, keera-hails-reactive-network 0.7.0, keera-hails-reactive-htmldom 0.7.0, keera-hails-reactive-gtk 0.7.0, keera-hails-reactive-cbmvar 0.7.0, keera-hails-mvc-model-protectedmodel 0.7.0, keera-hails-mvc-model-lightmodel 0.7.0, keera-hails-mvc-environment-gtk 0.7.0, keera-hails-mvc-controller 0.7.0 (keera_studios_ci)
03:21:23 <maralorn> ski: oh, yeah. (A non-typo english mistake, apparently I still do those ‚Ä¶)
03:21:46 <ski> maralorn : clarification, that was a joke :)
03:21:55 <hyiltiz> Nothing can eat something up into nothingness?
03:22:40 <hyiltiz> Surely e=mc2 turned any matter to no matter
03:23:03 <ski> (i think one can say both "no point in it" and "no point to it", in english)
03:23:14 <maralorn> Interestingg: https://english.stackexchange.com/questions/62244/no-point-in-vs-no-point-of-vs-no-point-to
03:23:45 <maralorn> ski: Also, I laughed. ;-)
03:24:19 <ski> hyiltiz : doesn't matter ?
03:24:40 <maralorn> krrrkrrkrkr
03:24:45 <hyiltiz> CT manages to be so astonishing and astonishingly boring at the same time
03:26:01 <hyiltiz> no matter what you threw at Einstein...
03:26:06 <maralorn> hyiltiz: Don‚Äòt do it if you don‚Äòt care. I still believe that you can be an excellent programer without knowing about most of this.
03:26:11 <ski> to a large extent, it's a language, with its own notion of aesthetics, and certain dogma, built-in
03:26:38 <ski> yes, maralorn
03:26:47 <hyiltiz> Dogma like what?
03:27:14 <hyiltiz> No it sounds more like a better metaphysics 
03:27:35 <hyiltiz> I wonder if it can say anything about ethics and epistemology
03:28:07 <ski> every relevant notion of structure, ought to come with an associated notion of structure-preserving morphism
03:28:26 <hyiltiz> After adding some minimal domain specific assumptions/axions 
03:28:34 <ski> universal properties, and adjunctions, are beautiful
03:28:50 <ski> distinguishing isomorphic things is evil
03:29:23 <maralorn> <hyiltiz "I wonder if it can say anything "> No, it can't, it shouldn't, don't go there.
03:29:47 <ski> well, there was a philosophical paper which tried to relate category theory to Plato's theory of forms ?
03:30:23 <hyiltiz> I was having existential crisis lately and was wondering if I was just greedy evaluating my life instead of ...
03:30:28 <maralorn> Okay, that sounds thinkable. 
03:31:02 <hyiltiz> Lazy evaluation send to give the meaning of life question a break
03:31:03 * ski . o O ( "Category Theory and Concrete Universals" by David P. Ellerman in 1998-05 at <http://www.ellerman.org/wp-content/uploads/2012/12/Erkenntnis-Concrete-Universals.CV_.pdf> )
03:31:10 <hyiltiz> Whatever that means
03:31:48 * ski . o O ( <https://ncatlab.org/nlab/show/evil> )
03:31:58 <maralorn> I am just a bit fed up right now with people misunderstanding mathematics and deriving philosophical claims from it.
03:33:04 <hyiltiz> Well I'm glad people are willing to (mis)place their faith in math than many other things out there
03:33:31 <kuribas> aren't mathematics and philosophy direct opposites?  Mathematic makes rigorous claims, while philosophy tries to find connections that cannot be proven.
03:34:02 <maralorn> Of course I also sometimes fall into the trap of applying mathematical structures to real life concepts. But normally I quickly see the error of my ways and flee back into my tower.
03:34:27 <maralorn> <hyiltiz "Well I'm glad people are willing"> That is a good point.
03:35:07 <maralorn> <kuribas "aren't mathematics and philosoph"> I don't think that's a fair characterization d of philosophy.
03:35:55 <kuribas> maralorn: if you prove something, it isn't philosophy, it's fact.
03:35:59 <hyiltiz> Thx for the discussions all
03:36:42 <hyiltiz> The sun is up and I need sleep. I'll dream about terminal objects.
03:36:59 <ski> hyiltiz : "Unity and Identity of Opposites" <https://ncatlab.org/nlab/show/adjoint+modality>
03:37:19 <ski> er, sorry, that was meant for kuribas
03:39:37 <hyiltiz> Oh that page is fun (to the extent I can understand)
03:39:38 * ski . o O ( "Do adjoints dream of existential properties?" )
03:39:44 <maralorn> kuribas: I think both mathematics and philosophy have the intention to talk about facts. The difference is that mathematics leans to facts you can proof where philosophy leans towards facts that matter.
03:39:46 <ski> (film at eleven)
03:42:10 <maralorn> But that doesn't mean that mathematics doesn't occasionally stumble over something useful or philosophy over something right.
04:18:20 <karel-de-macil> hi all i'm trying to compile GHC and force the build to keep the .hc file but whatever i do the build won't keep it ... any advice ?
04:19:13 <karel-de-macil> have allready tried to add a build.mk file with the line :SRC_HC_OPTS     = -H64m -O -fasm -Rghc-timing -keep-hc-files
04:19:22 <karel-de-macil> in it with no success
04:22:40 <merijn> karel-de-macil: Might wanna try #ghc :)
04:23:29 <karel-de-macil> oki thanks, i reroll there 
04:29:37 <maerwald> kuribas: no. You usually prove something under certain conditions/assumptions/axioms.
04:32:13 <ADG1089_> was looking for a new job, all i see is requirement for frontend and senior developers
04:32:53 <maerwald> ADG1089_: mozilla just fired servo devs and a lot others. Not a particularly good time
04:33:14 <maerwald> When even big corps are cutting, they won't be looking for juniors
04:33:33 <ADG1089_> hmm
05:13:28 <kuribas> what a bullshit, there is always demand for good programmers.
05:19:27 <hc> companies are looking for people with 12 yrs of kubernetes experience (kubernetes exists for ~6 years) ;-)
05:24:31 <nij> Hello.. I've recently noticed that what are presented in haskell to beginners might not be the best (not even good..) practices to use.
05:25:06 <nij> For example, List is very slow and should not be used (except for educational purposes).
05:25:09 <merijn> nij: Yes, no, maybe
05:25:25 <merijn> nij: "lists are slow" is a meaningless statement
05:25:35 <nij> I wonder what are some other caveats that I should pay attention to.
05:25:44 <merijn> lists are terrible for random access, they're perfectly fine a million other things
05:26:05 <nij> merijn: Oh! 
05:26:12 <opqdonut> with list fusion many list operations compile into tight loops without allocations
05:26:38 <nij> opqdonut: that's a good thing about lists?
05:26:42 <opqdonut> yes
05:27:05 <merijn> nij: Lists are linked lists, like you can find in many other languages. They're good at the same things as in other languages (like, prepending data and looping over). They're bad at random access as accessing element N means iterating over everything from the beginning to index N
05:27:27 <merijn> (well, I guess linked lists being "good" for looping depends on how you define good...)
05:27:27 <nij> opqdonut: thanks for pointing that out!
05:27:33 <opqdonut> arguably lists are bad for looping... yeah
05:27:42 <nij> I see.
05:28:03 <nij> So I should alter my question a bit, and just focus on what should I look into to "level up".
05:28:07 <merijn> nij: If you need to do random access into sequence there are better data structures than list (the vector package is a good starting point)
05:28:12 <opqdonut> what I and merijn are referring to is the fact that linked lists that are spread randomly in memory are bad in terms of cache behaviour
05:28:21 <opqdonut> for iterating through
05:28:32 <opqdonut> compared to a packed array (e.g. unboxed Vector)
05:28:44 <nij> how about stream? is that something similar?
05:28:55 <merijn> Vector is more like C-style arrays and C++'s std::vector
05:29:03 <hc> Well, it *is* true that the default String type is a list of chars, which is not the best suited implementation in many (most?) cases
05:29:15 <hc> -> use Text instead -> Why isn't Text the default?
05:29:23 <merijn> nij: stream in what notion?
05:29:40 <nij> merijn: I don't really understand that..
05:29:48 <nij> Just watched O'Sullivan's talk.
05:29:58 <nij> It's quite advance to me, so I came here for help.
05:30:00 <merijn> nij: You said "how about stream?" I'm not sure what you're referring too :)
05:30:22 <nij> I should be more specific! I thought that's a well-defined and well-spreaded type
05:30:30 <nij> I will ask next time when it's clearer :)
05:31:15 <nij> hc: I think O'Sullivan pointed out a problem with Text and why people moved on to "Stream" in that talk
05:31:28 <nij> But as you can see I'm heavily confused so dont take my words seriously
05:31:43 <merijn> nij: Anyway, most data structure intuition is pretty much the same in Haskell and other languages, one of the few catches is that languges like Python, Ruby, and JS use the term "list" to refer to things that behave more like arrays than linked lists
05:31:52 <nij> hc: The last 15 minutes: https://www.youtube.com/watch?v=kGa78HQv_LQ
05:32:11 <nij> merijn: I see!
05:32:27 <hc> thanks! text was deprecated in favor of stream? never heard of that, nee dto check it :)
05:32:28 <merijn> nij: But, arguably, Python/Ruby/JS are to blame for that as lists commonly refer to linked lists when you're using C/C++
05:32:59 <nij> I've also read the first two chapters of Bird's new book. There are several other replacements.. each for different purposes.
05:33:04 <nij> What a zoo.
05:33:09 <merijn> nij: And, for example, provides both LinkedList and ArrayList implementations for their list interface. So maybe "list" is just a confusing and messya bstraction :)
05:33:19 <nij> hc: I'm confused! If you can point where I'm wrong I will be very grateful :)
05:33:22 <merijn> eh, there's a "Java" missing in that sentence
05:33:26 <frdg> I am trying to install threadscope and having problems that I believe are related to `cairo`. I believe I have installed everything neccessary for installing cairo but I get this error https://dpaste.org/Gj3s. I installed gtk2-buildtools and have confirmed that gtk2 is on my system.
05:33:46 <merijn> nij, hc: I'm pretty sure bos was referring to lazy Text vs something like Conduit
05:33:51 <dminuoso> nij: If you understand lists are a (lazy) control flow structure, they are quite neat. :)
05:34:04 <dminuoso> oh. scrolling down is good.
05:34:05 <merijn> nij, hc: lazy Text lets you "stream" data from disk, but it has a bunch of problems with resource management
05:34:16 <hc> ooh, okay :)
05:34:25 <hc> yeah, lazy streams have been deprecated loong ago I think :)
05:34:45 <dminuoso> That's certainly not true.
05:34:51 <merijn> There are several stream processing abstraction (conduit, pipes, iteratees, machines, streamly) that let you do stream processing without the problems that lazy Text has.
05:35:08 <dminuoso> There's no de-facto solution for streaming. There's many different competing solutions.
05:35:24 <nij> so what is stream..
05:35:30 <hc> well, at least pure lazy lists don't mix very well with possibly err'ing io code
05:35:37 <dminuoso> nij: Do you understand how to write shell scripts with pipes?
05:35:44 <nij> dminuoso: yes
05:35:47 <dminuoso> nij: That's streaming! :)
05:35:52 <nij> that's my first language
05:36:08 <nij> (and haskell is my second language. this explains why im still at noob stage
05:36:11 <nij> ???
05:36:24 <nij> what does that have to do with Text?
05:36:36 <merijn> nij: Well, suppose you have a 10 GB text file that you wanna do stuff with
05:36:50 <merijn> nij: You (probably) don't want to load the entire 10 GB of data into RAM
05:37:09 <merijn> nij: You'd like to "stream" the data from disk into your processing logic bit by bit
05:37:54 <merijn> nij: Consider something simple like "count the number lines in a file" you don't actually need the whole file in memory, you could easily load 4 KB of text, count the lines, get rid and get the next 4KB
05:38:13 <merijn> nij: Streaming libraries provide nicer/easier abstractions for writing code like that
05:38:22 <dminuoso> But obviously in a way that you abstract over this "bit by bit" detail. Some expressive way to talk about "pipes" that process data that you can just connect to each other. shell scripting with pipes have *all* of that built in already. You can `cat` a large file into say `grep`, and then pipe the output of that further. And it will sort of "stream the data through your pipes"
05:42:54 <nij> Ohh I see
05:42:59 <nij> (I got pinged out)
05:43:06 <nij> Thank you :) That makes more sense.
05:43:22 <nij> I thought Stream is a abstracted type and that's why I couldn't understand materials out there.
05:45:20 <frdg> I am trying to install threadscope and am having issues. Here is a more detailed synopsis of the problem then the one I gave earlier. https://dpaste.org/Xdaa. I have confirmed that I have gtk2 on my system.
05:45:29 <dminuoso> Streaming is just an idea.
05:48:00 <merijn> Well, sometimes people do define a Stream datatype for talks :p
05:48:06 <merijn> Usually ones involving codata :p
05:48:54 <merijn> Since an infinite stream is the simplest codata example :p
05:49:15 <dminuoso> nij: I've extracted some (possibly pseudo?) code from what I just wrote earlier: https://gist.github.com/dminuoso/2dc7a32ab42b0de4b003c17349ef0f5f
05:49:34 <dminuoso> Disclaimer: I've reduced this to the relevant bits. The real code is more elaborate and does careful resource cleanup (which this does not do!)
05:50:01 <dminuoso> Updated for some typos. :)
05:50:45 <dminuoso> Note that this .| is, conceptually, the same thing as | in shell scripting.
05:53:28 <nij> hmm
05:54:14 <nij> Uhh..
05:56:51 <nij> What is DriverOpts? Cant find it on google nor hoogle
05:57:03 <nij> DriverOpts {...}
05:57:07 <vaibhavsagar> why would I be unable to import `Language.Haskell.TH` if `template-haskell` is in my build-depends?
05:58:02 <vaibhavsagar> oh, because I have it in the wrong place
05:58:09 <vaibhavsagar> of course it would be the silliest possible reason
06:01:53 <dminuoso> nij: runDriver is a thing here in my app that invokes a compiler :)
06:02:12 <dminuoso> (I've rewritten all the identifiers to be a bit more readable)
06:02:20 <dminuoso> But it's an internal tool, you wouldn't find it on hackage
06:03:15 <frdg> are there downsides to having some packages installed through stack and some through cabal? Do I need to pick one and stick with it?
06:03:19 <nij> I see
06:03:30 <dminuoso> Concretely what happened, is that we wrote a particular compiler as a command line tool, but modular in a way that we could run the compiler from some haskell program as well.
06:03:49 <dminuoso> So if we run it from haskell code, we provide it with some handle which the compiler will write its warnings and errors to
06:04:08 <dminuoso> (It could have been far more modular, but this fits our needs exactly)
06:04:27 <dminuoso> We wanted the compiler to stream its output into a websocket.
06:06:58 <nij> :(
06:07:01 <merijn> frdg: Depends, do you worry about disk space?
06:07:07 <nij> fail to compile it in my brain
06:07:09 <dminuoso> So strictly speaking there's two separate streaming mechanisms. One is provided by createPipe, which essentially is just pipe(2), and the other is provided by conduit. With these tools, I can essentially tackle the compiler output *directly* to a websocket. :)
06:07:33 <frdg> merijn: disk space is not a concern
06:08:20 <merijn> frdg: stack and cabal have completely independent install paths, so they're not gonna affect each other at all, but you might end up having the same library installed with stack and cabal (although, tbh, you can already end up with multiple installs of a library just with stack or cabal, so that's hardly a difference)
06:08:43 <nij> Handle -----conduit----> WebSocket?
06:08:48 <dminuoso> Right! :)
06:09:01 <dminuoso> And that Handle is just part of a pipe as well!
06:09:15 <merijn> ok, wish me luck, I'm gonna see if no IRC will help my writing productivity :p
06:09:41 <frdg> ok this is good to know. Stack and Cabal generally cause me lots of confusion :)
06:09:57 <nij> dminuoso: How would you use this to solve the 10GB streaming problem?
06:10:06 <dminuoso> Say oyu want to stream 10GB into a websocket.
06:10:12 <dminuoso> From a file
06:10:20 <nij> Say the user might want to look at a 1Kb segmant in each period of time
06:10:58 <dminuoso> What you could do, is this (there's more direct ways, but this is using tools Ive mentioned)
06:11:14 <dminuoso> open the 10gb file, now you have a handle in your hand.
06:11:26 <dminuoso> open the websocket, now you have a connection in your hand
06:12:11 <nij> ok
06:12:18 <dminuoso> runConduit (sourceHandle handle .| mapM_C (WB.sendBinaryData connection))
06:12:20 <dminuoso> Done!
06:13:09 <nij> What happens when you "stream 10GB into a websocket"?
06:13:24 <nij> 10GB data really goes into websocket?
06:13:39 <dminuoso> The conduit will read chunk by chunk from the handle, feed it to the next conduit. That next conduit will then punt what it has into the socket
06:13:43 <nij> Or it's just that abstractly the websocket can now get access to the data?
06:13:52 <dminuoso> The 10GB data now really goes into the websocket.
06:14:03 <dminuoso> But piece by piece.
06:14:14 <nij> Hm.. why is this better than say reading that into a List?
06:14:53 <dminuoso> Constant memory usage, resource management.
06:15:18 <dminuoso> Lists are great for simple situations, but for non-trivial things you're better off with a proper streaming library.
06:15:27 <nij> I see :)
06:16:00 <nij> That's very helpful!
06:16:13 <dminuoso> And, you can do *effects* along the way
06:16:39 <dminuoso> Which you couldn't with lists unless you started using primitives like unsafeInterleaveIO. This is precisely how lazy IO works.
06:16:53 <dminuoso> But that opens a large can of works.
06:17:16 <nij> Do people avoid lazyIO b/c of this?
06:18:12 <dminuoso> nij: People avoid lazy IO so they can have proper resource management, memory usage, visibility of effects, etc..
06:18:23 <dminuoso> (Things that lazy IO does not have)
06:18:46 <dminuoso> Consider, if I have a stream that does processing. And perhaps I just want to debug some intermediate step.
06:19:04 <dminuoso> Then I can just do `source .| transform .| iterM_C print .| transformMore .| sink`
06:19:23 <dminuoso> And that `iterM_C print` will just print chunks as they go through that conduit
06:19:56 <nij> Urgh.. tbh this is beyond my head
06:20:03 <nij> The last example is fine
06:20:20 <nij> oh wait
06:20:35 <nij> iterM_C stands for?
06:20:52 <dminuoso> *iterMC sorry
06:20:59 <nij> What does MC stand for
06:21:12 <dminuoso> The M is for monadic and the C for conduit presumably?
06:21:43 <nij> üòÇ
06:21:49 <dminuoso> nij: When compared to shell scripting, you could imagine `iterM` as being something like `tee`. :)
06:22:00 <nij> ah ha that's much better
06:22:34 <nij> That sounds super neat
06:22:44 <nij> and is what we really wnat
06:22:50 <dminuoso> Except, it doesnt ust write to a file, but executes arbitrary things with it
06:23:26 <nij> If I use List
06:23:32 <dminuoso> So imagine some pseudo shell code: cat /foo/bar | grep "quux" | tee -cmd "echo #chunk" | grep "baz"
06:23:40 <nij> then each "pipe" will create a new LARGE big 10GB?
06:23:53 <nij> and each transformation will be painful
06:24:15 <nij> Would this streaming approach solve that problem?
06:24:55 <dminuoso> Well with lists your first problem is, you cant do effects with it.
06:25:38 <dehun> hey there, I am trying to get some nice setup for haskell in emacs and a bit stuck. Any suggestions for working goto-definition and company-mode?
06:26:08 <nij> dminuoso: why not? 
06:26:15 <nij> Well oh technically no
06:26:31 <nij> We "do effect" by making a new one
06:26:34 <nij> and that's not efficient
06:26:43 <dminuoso> No what I mean is
06:27:23 <dminuoso> Say you're producing a list, and then you have a bunch of list functions like `producer :: [Int]; f :: [Int] -> [Char]; g :: [Char] -> [Bool]
06:27:24 <dehun> intero mode looks a bit abandoned, and lsp-haskell under active development. Any other alternatives?
06:28:04 <nij> dminuoso: yeah
06:28:04 <dminuoso> So you could compose `g . f :: [Int] -> [Bool]` of course, but you cant insert effects in between like "print each intermediate Char"
06:28:28 <nij> Oh
06:29:27 <nij> print :: [Char] -> (IO [Char], [Char]) ?
06:29:34 <nij> cant I use this
06:29:48 <nij> print it, and use some monadic trick to pipe the snd into g?
06:29:55 <dminuoso> Sure, but that becomes non-composable
06:30:13 <dminuoso> If you follow this, you'll eventually end up with a solution called a list monad transfomer.
06:30:24 <nij> g . snd . print . f
06:30:25 <dminuoso> And then you're in streaming territory :)
06:30:55 <nij> sounds less terrifying now!
06:31:18 <nij> I should really start reading "What I wish I Knew.."
06:31:27 <frdg> what is the difference between `~/.local/bin/stack` and `/usr/local/bin/stack`?
06:31:27 <frdg>  
06:31:31 <nij> it seems to have more stuff in it
06:32:41 <dminuoso> 15:30:02            nij | g . snd . print . f
06:32:45 <dminuoso> No I meant, what if you have something like
06:33:04 <dminuoso> f .| iterMC print .| g .| iterMC print .| h
06:33:38 <nij> (.|) = (.)
06:33:52 <nij> interMC_print = snd . print
06:34:02 <dminuoso> And that's the end of your composition :)
06:34:18 <dminuoso> If you want to compose *more* processing after that you cant
06:34:18 <nij> what's the problem with my def of .| and interMC_print?
06:35:03 <nij> well I just have to change my print :: [Char] -> (..) to [a] -> (IO [a], [a])
06:35:43 <dminuoso> nij: It wont work out
06:35:45 <dminuoso> % (.|) = snd . print
06:35:45 <yahb> dminuoso: ; <interactive>:174:14: error:; * Couldn't match type `IO ()' with `(a0, c)'; Expected type: a -> (a0, c); Actual type: a -> IO (); * In the second argument of `(.)', namely `print'; In the expression: snd . print; In an equation for `.|': (.|) = snd . print; * Relevant bindings include (.|) :: a -> c (bound at <interactive>:174:1)
06:35:59 <dminuoso> % :t print
06:35:59 <yahb> dminuoso: Show a => a -> IO ()
06:37:12 <nij> I see
06:37:28 <nij> let conduit do the magic !
06:51:27 <ezzieyguywuf> so, I want to recursively call this function until either an empty list is returned OR a list containing the original Node is returned. This is (surprisingly) my first time dealing with recursion in haskell and recursion in general for at least 10 years. Can anyone provide some pointers on how to go about this? https://hackage.haskell.org/package/fgl-5.7.0.3/docs/Data-Graph-Inductive-Graph.html#v:pre
06:56:46 <oats> ezzieyguywuf: are you trying to determine if the graph is cyclic?
06:58:48 <ezzieyguywuf> oats: not exactly. I want to collect the list of consecutive nodes, including a possibly cyclic list
06:59:02 <ezzieyguywuf> but the starting node may or may not be the "first" one, so I have to go backwards first
06:59:39 <ezzieyguywuf> It's ok to assum that any given Node has at most 1 suc and/or pre, as this is enforced by the API
07:00:12 <dminuoso> ezzieyguywuf: Do want this as depth first or breadth first?
07:00:29 <ezzieyguywuf> dminuoso: I don't understand the question
07:00:42 <dminuoso> ezzieyguywuf: Also, are you sure you dont just want to use `subgraph` ? :)
07:01:12 <dminuoso> Ah, no. 
07:01:14 <ezzieyguywuf> dminuoso: I need to know ahead-of-time the list of connected Nodes for sub-graph to work
07:01:43 <dminuoso> Right
07:01:53 <ezzieyguywuf> I have "Node1‚ÜíNode2‚ÜíNode3‚Üí....‚ÜíNodeN" where NodeN may or may not be Node1
07:02:05 <ezzieyguywuf> so given any node, how to return the full chain
07:03:18 <dminuoso> ezzieyguywuf: The obvious solution is to just keep a list of all visited nodes.
07:03:30 <dminuoso> (Stick them in a set!)
07:03:45 <ezzieyguywuf> dminuoso: the return value of my getter here is a set!
07:03:51 <oats> wait, is this graph also just a (possibly) cyclical linked list? :P
07:04:06 <ezzieyguywuf> oats: correct (I think)
07:04:09 <oats> you said each node has at *most* 1 suc and/or pre
07:04:39 <oats> and you want to go from this graph representation to a regular list one? do I understand correctly?
07:04:55 <ezzieyguywuf> dminuoso: My thoughts were (1) recursively call `suc` until the return value is [] OR the return value has already been visited, (2) if [], then recursively call pre until the return vaue is []"
07:05:06 <ezzieyguywuf> but I can't really think how to implement that
07:05:15 <ezzieyguywuf> oats: correct.
07:08:45 <dminuoso> ezzieyguywuf: that seems like a simple application of ufold, no?
07:09:08 <ezzieyguywuf> dminuoso: I'm unfamiliar with ufold, so I dunno! let me check :)
07:09:20 <dminuoso> Im not very familiar with fgl though, but my first instinct suggests that could be the right one?
07:09:30 <ezzieyguywuf> ah, I should have thought to look in this section of the library
07:10:12 <ezzieyguywuf> dminuoso: I dunno if ufold is the one, but I think you're on the right track. In fact, my understanding is that the very point of fgl is to make these sorts of things "easy" to do
07:10:24 <ezzieyguywuf> so I just need to spend some time looking through what's offered and find one that works
07:10:53 <oats> dminuoso: good eye, I bet that there was a function in there to make this easier
07:12:11 <oats> try ufold (:) []
07:12:59 <ezzieyguywuf> üëç I'll give it a whirl, thanks for the help all
07:14:37 <ezzieyguywuf> hm, the thing is, the graph may contain any number of these "chains", i.e. "aN1‚ÜíaN2‚Üí...‚ÜíaN3", "bN1‚ÜíbN2‚Üí...‚ÜíbN3" etc...
07:14:47 <ezzieyguywuf> so I still think I need to find a way to select a single one of these chains
07:15:02 <ezzieyguywuf> starting from an arbitrary node within the chain
07:36:29 <seanparsons> infinisil: Yeah, I was passing a ghc package set which did exist to that derivation. Here's a reference to the source for that package: https://github.com/seanparsons/podcast-chooser/blob/master/default.nix
07:36:57 <infinisil> seanparsons: (wrong channel)
07:37:07 <seanparsons> Curses.
07:40:49 * hackage niv 0.2.15 - Easy dependency management for Nix projects  https://hackage.haskell.org/package/niv-0.2.15 (nmattia)
07:43:26 <nij> Has anyone had luck getting cabal+tidal work :D?
07:47:10 <ezzieyguywuf> tidal the music service?
07:48:33 <nij> Yep!
07:48:58 <nij> Seems that all tutorials teach me how to use that with an IDE.
07:49:12 <nij> As an emacs user.. it doesn't work. But I don't know how to fix it.
07:49:27 <nij> I hope someone can teach how to make it work simplify from a ghci with tidal imported.
07:49:45 <dminuoso> nij: builds just fine for me.
07:50:12 <nij> dminuoso: How did you do that?!
07:50:41 <nij> On github someone even suggested that maybe purging cabal could help..
07:50:53 <nij> Oh you built it.. but did you get the sound?
07:51:20 * hackage optparse-applicative 0.16.0.0 - Utilities and combinators for parsing command line options  https://hackage.haskell.org/package/optparse-applicative-0.16.0.0 (huw)
07:51:48 <dminuoso> I have no idea? I just punched `cabal v2-build` and it builds?
07:52:38 <nij> Yeah it builds for me too. But I cannot get it working :(
07:58:29 <absence> is it possible to derive async exceptions somehow (maybe DerivingVia?) instead of writing manual Exception instances using asyncExceptionToException and asyncExceptionFromException?
08:07:26 <ezzieyguywuf> üòÇ nij I thought you meant https://tidal.com/
08:09:34 <board_control> I've been enjoying learning about security lately like the OWASP top 10. Are there many resources for security in Haskell or is it more tooling with security as the endgoal like what Galois might produce?
09:30:11 <sm[m]> nij: which of tidal's docs are you following ?
09:44:41 <maralorn> I am gonna say something blasphemic here. Why don‚Äòt we add stackage support into cabal (and ideally stop confusing users with having two build systems)?
09:45:37 <mmaruseacph2> what do you mean? stackage offers 1 thing only: a global set of packages that are know to build at the same time
09:45:59 <mmaruseacph2> compared to hackage where you have all versions of a package and you need to rely on a solver to install via cabal
09:46:24 <mmaruseacph2> multi-porject build? multiple GHC? cabal (the tool) can support them too
09:46:32 <mmaruseacph2> (afaik)
09:48:01 <yushyin> want the set of packages to use with cabal? download the cabal file https://www.stackage.org/lts-16.9/cabal.config
09:48:59 <MarcelineVQ> hey neat
09:49:07 <yushyin> (I don't see why you should, but you can)
09:49:48 <mmaruseacph2> wow, interesting
09:49:52 <mmaruseacph2> didn't know about that
09:52:14 <monochrom> Conflated build system with package source.
09:52:50 <monochrom> As long as two separate programs exist (stack, cabal), you will have two build systems.
09:53:10 <maralorn> I meant what yushyin answered.
09:53:28 <maralorn> Although I am not sure if I am happy with the answer.
09:54:00 <monochrom> You should not, because it endorses having two separate package repos, rather than unifying.
09:54:47 <maralorn> monochrom: I see stackage more like an addition to hackage instead of an alternative.
09:54:52 <yushyin> to make myself clear, I don't use that. I'm very happy with ghcup+cabal (v2) :)
09:54:55 <monochrom> If you're going for unifying, then consider: stackage is a subset of hackage, so do you want "unify" to mean: intersection? union?
09:55:09 <Lycurgus> because it's too weak of an idea for anybody to be arsed?
09:55:28 <Lycurgus> *sufficiently arsed
09:57:44 <maralorn> I think for application developers having the possibility to just specify a stackage-lts version seems quite appealing. Also nixpkgs depends heavily on stackage.
09:58:22 <maralorn> I was just musing about the fact, that that alone shouldn‚Äòt be an excuse to two programs.
09:58:36 <maralorn> to have two programs.
09:58:38 <hseg> hi. baby's first template haskell -- how do i write http://ix.io/2u4l in TH?
10:00:32 <glguy> hseg: Where is Semiring defined?
10:00:37 <maralorn> monochrom: I guess I mean take the stackage version if contained do normal package resolution otherwise?
10:01:05 <hseg> from package 'semirings'. writing a patch for it. TH should be at definition site of Semiring
10:02:06 <monochrom> Look into the [d| ...] thing.  It is for declarations such as "instance ..."
10:02:54 <monochrom> To a large extent your code goes into the "..." verbatim.  The meta-parameter ty is the one needing special notation.
10:03:14 <hseg> ok. where do i find docs for the quasiquoters?
10:03:16 <monochrom> However! I am not sure about the INLINE pragmas.
10:04:03 <monochrom> Start with GHC user's guide. It has a further link to a haskellwiki page.
10:04:22 <hseg> kthx
10:04:32 <fog> so im not sure, but i think that i have a model for "coeffects" using scanners replacing functions in a scaffolded implementation
10:05:55 <fog> that the "carried" state (thinking of it as the changing basecase to fold but stored at each location in encounters in folding over a stream)
10:06:19 <yushyin> maralorn: I don't know if I have a need for stackage-lts. With cabal v2-install, cabal has never failed me to find a build plan yet. and if I really want my colleagues to use the same package versions I can still generate a freeze file.
10:06:43 <fog> by acting like a state, which when modified is representing "effects" and then when these states are used in the state update or output production, that these are coeffects
10:06:46 <glguy> hseg: check out https://gist.github.com/glguy/0651d4b0b8fb2ab98683788c9b2c39c0
10:07:01 <fog> basically, all of the functions in the implementation now have their own private memory store for values!
10:07:09 <glguy> hseg: You'd want to make it complete and pretty, but that's the idea
10:07:36 <hseg> nice. thanks. was wondering whether invocation syntax would be different for types
10:08:01 <monochrom> maralorn: To a large extent, if one sticks to stack, one can already do everything you said, including taking an exception to pull in a few non-stackage package from hackage but otherwise largely a chosen stack resolver. One can make the case that unification means just use stack.
10:08:45 <fog> glguy: whats that TH doing?
10:08:51 <monochrom> For this plus other reasons (mostly auto-install ghc), I find that I cannot argue against sm[m] about being easier to get beginners started with stack.
10:09:26 <monochrom> And sm[m] has empirical experience to justify it.
10:09:29 <mmaruseacph2> when teaching I also recommend stack for getting started
10:09:47 <mmaruseacph2> especially since it's so easy to install and use on Windows too
10:09:50 <monochrom> However, I enjoy the cabal workflow much more, and I also distrust the idea of auto-install ghc.
10:09:56 <glguy> hseg: Another option if you're in the market for options is to use the DerivingVia machinery
10:10:01 <hseg> ... wait - does this mean that if you're willing to pay for TH, you have dependent types?
10:10:21 <hseg> glguy: Sure, except I don't know whether upstream will pay for it.
10:10:31 <monochrom> No, TH doesn't get you dependent types.
10:10:32 <maralorn> yushyin: Okay, freeze files are a good point. Then I see only one reason: Reuse of dependency trees. That's especially important for nixpkgs, where the buildservers try to build all of hackage and that would be completely crazy if every package would pick dependency versions at will.
10:10:37 <glguy> hseg: No, you don't get dependent types because of staging
10:10:40 <monochrom> TH just helps you copy-paste.
10:11:03 <hseg> hrm. pointers on how staging helps here?
10:11:34 <glguy> It hurts here. None of your TH defintions can depend on runtime paramters
10:12:13 <hseg> ah. so can you get static dependent types?
10:12:16 <fog> what are "linear types" ?
10:12:21 <hseg> ie no runtime stuff?
10:12:22 <glguy> fog: It generates an instance definition for a given type using some default implementations
10:12:31 <fog> ah ok
10:12:37 <monochrom> maralorn: Lastly, co-existence of stack and cabal was social-historical, not technical.  stack happened at a historical moment when the idea of today's cabal v2-xxx was conceived but the cabal team didn't get around to implemeent it, FP Complete getting impatient and decided to roll their own.
10:12:48 <dolio> No, it's just not dependent types.
10:12:51 <fog> why not just write the instance?
10:12:58 <monochrom> (And my interpretation of that history could be wrong, too.)
10:13:01 <yushyin> maralorn: yes I can understand the argument with nixpkgs in mind.
10:13:05 <glguy> hseg: Still no, the "ty" parameter there isn't a type, it's syntax for a type that will be used to generate some code that the compiler will compile in a future pass
10:13:30 <mmaruseacph2> monochrom: that's my view of history too
10:13:57 <monochrom> (But definitely social-historial origin, not technical. We all know how to code it up either way, both ways, whatever. But what did people actually do?  Look at the word "people".)
10:13:58 <maralorn> monochrom: Well, I was more looking for the idea of having both built options in one tool. (And since I have never used stack (much), I‚Äòd prefer that to be cabal.)
10:14:02 <maralorn> Did stackage exist before stack?
10:14:33 <monochrom> I think no.
10:14:36 <mmaruseacph2> they came at the same time
10:14:53 <maralorn> Not surprising.
10:14:58 <dolio> I think it might have, actually.
10:15:10 <hseg> ah ok
10:15:28 <monochrom> FPComplete did add the extra idea of curating-nailing package versions, the resolver idea. As you rightly said, a real addition.
10:15:46 <hseg> gtg, thanks!
10:16:00 <maralorn> Still I think stackage is a nice thing. Just don‚Äòt think that it's worth duplicating executables, config, etc. (and I know the historical context, I was just thinking if at least technically we can do better.)
10:16:06 <monochrom> err I guess s/real//
10:16:19 <dolio> It's too late. The 'duplicate' code is already written.
10:16:39 <monochrom> To technically do better, first invent a time machine.
10:16:57 <maralorn> ^^
10:17:07 <monochrom> Or, ironically, last. (Think of it!)
10:17:13 <monochrom> err, (Think about it!)
10:17:43 <monochrom> Err, second last! You still have to build it haha.
10:17:59 <fog> the hell are you talking about?
10:18:20 <MarcelineVQ> If you want to bake an apple pie from scratch, do it before the other guy.
10:18:43 <monochrom> No, fog, you, the hell are you talking about?
10:18:44 <yushyin> that's what I like to ask every time a fog-monolog is running along
10:18:45 <maralorn> It's just a bit annoying, that people who use stack are unsatisfied when a developer had cabal in mind and vis-a-vis. I am annoyed when I want to help people with something but just don‚Äòt know the correct stack command. etc. ‚Ä¶
10:19:14 <fog> haha, the mods become the modserated
10:19:23 <dolio> You could learn to use stack. Then you'd know.
10:19:53 <fog> thats what all bosses should tell their employees 
10:19:55 <glguy> dolio: Would that be cheating?
10:20:20 <maralorn> dolio: That would be more effort for me! Why can‚Äòt the whole ecosystem just change so that it's easier for me?
10:20:35 <fog> except to refer to mumford stacks...
10:20:43 --- mode: ChanServ set +o monochrom
10:20:48 --- mode: monochrom set +b *!*@gateway/web/cgi-irc/kiwiirc.com/ip.82.1.242.183
10:20:48 --- kick: fog was kicked by monochrom (fog)
10:20:54 --- mode: monochrom set -o monochrom
10:22:14 <sm[m]> maralorn: it's interesting to think about such things. Eg what could a blend of the best of stack and cabal look like ? Currently stack can't do cabal's unconstrained build plan solving, you could imagine that being added to stack.
10:22:51 <sm[m]> a challenge is how to keep tools clear enough that users don't get confused
10:22:52 <monochrom> backpack. :)
10:23:58 <monochrom> Yesterday I took out my backpack learning example and ran "cabal build/run/repl" and it still worked :)
10:24:06 <monochrom> Actually it worked better.
10:24:14 <dolio> What is the point exactly? If one of the tools becomes some agglomeration of both so that they support to completely different workflows that different people use, why is that better than two tools for it?
10:24:30 <sm[m]> also +1 to what dolio said earlier, anyone making recommendations for cabal and stack should at least know them both
10:24:30 <yushyin> ah yes, I also had problems with mixins in stack repl, it just didn't work
10:24:40 <maralorn> I mean, stack uses the Cabal library internally, too, right? I am pretty sure that it wouldn‚Äòt be to hard to merge both into one tool that supports most of it.
10:24:52 <dolio> If you're only familiar with the cabal-like workflow, will you know how to help people with the stack-like workflow just because it has the same executable name?
10:25:12 <monochrom> Because if I have the "signatures:" field or the "mixins:" field, I am also supposed to declare "cabal-version: 2.0 (or later)", I didn't, and old cabal-install did not enforce that either, today's cabal-install does.  I had to fix my *.cabal file.
10:25:36 <sm[m]> dolio, in an ideal world you'd think one blessed tool that does it all could simplify life for a lot of users and speed haskell adoption
10:25:48 <maralorn> dolio: It was my impression that nowadays stack and cabal agree in more points than they are different?
10:27:22 <maralorn> I think from a user perspective just running "stack-cabal install" and then the config file tells the tool which resolution to do, would be quite convenient.
10:27:47 <sm[m]> for easier typing: staball
10:28:03 <MarcelineVQ> nickal
10:28:24 <glguy> I'm pretty sure that having 3 executables floating around isn't the solution to the problem of having 2
10:28:41 <maralorn> I guess I am also thinking about this because I follow the chat in #haskell-ide-engine and see how much work they have there to support projects with both tools. (which includes sometimes even upstream contribution against both projects)
10:29:03 <monochrom> That one is the eternal philosophy conflict of "5 programs for 5 purposes" vs "1 program for 5 purposes upon a switch".
10:29:18 <sm[m]> aside: speaking of install tools, could anyone tell me what https://github.com/phischu/fragnix does ? the readme did not help much
10:29:26 <maralorn> https://xkcd.com/927/
10:29:31 <monochrom> It is not resolvable (pun!) when the 5 purposes are sufficiently related.
10:30:48 <monochrom> It's also probably how Perl happened amidst a traditional unix culture.
10:30:55 <dolio> maralorn: How is the effort going to be less if they have to make it work two different ways with a single tool?
10:30:59 <maralorn> simonmic: I think it trys to make one nix-expression per Module, so that you can use nix to do incremental compilation.
10:31:18 <maralorn> dolio: I really don‚Äòt think they would.
10:31:34 <sm[m]> maralorn: thanks.. does it sniff the imports to choose packages ?
10:31:49 <dolio> It has to work for people who want all packages to be pinned to some version, and people who want flexible version solving.
10:32:10 <dolio> Which is apparently in a config file for the build tool.
10:32:14 <maralorn> dolio: A problem is e.g. that cabal repl and stack repl behave slightly differently. But I don‚Äòt think that difference has anything to do with dependency solution.
10:33:52 <maralorn> Dependency solution is not a huge part of a build tool. I really think that creating a build plan can be modularized quite well and the rest of Code/Interface could be shared.
10:35:31 <sm[m]> maralorn: agreed that complexity is a problem for tool builders right now.. even with only one of cabal/stack it still would be. I think things may improve a bit, given time
10:36:22 <maralorn> I think the merge of hie and ghcide sets a really nice example.
10:37:04 <sm[m]> uh.. I think it will when the dust settles
10:37:41 <sm[m]> oh did we have this chat yesterday ? I'm one of those burned-too-often waiting-for-it-to-just-work fogeys
10:37:46 <maralorn> Of course I don‚Äòt claim to know the tools better than the authors, and maybe things are much more comlicated. But my (mostly irrelevant) opinion is, that a merge/unification would be awesome.
10:38:01 <monochrom> IDE merger is probably incomparable with stack and cabal
10:38:11 <iqubic> what is IDE merger?
10:38:28 <monochrom> see context
10:39:01 <sm[m]> the architecture of GHC/modules/packages is kind of at the root of all these, isn't it
10:39:18 <monochrom> 5 different IDEs are only different in internal implementation tricks. User-facing feature set, workflow, even philosophy are compatible.
10:39:58 <monochrom> stack and cabal have differences in encouraged workflow and even conservative-vs-liberal ideology.
10:40:05 <maralorn> simonmic: But you put your hopes into hls too, right?
10:40:26 <sm[m]> I assume hls will be the winner yes
10:40:48 <maralorn> monochrom: Uh, interesting. Can you elaborate on the ideology thing?
10:40:54 <iqubic> I assume that too, but it's too early to tell.
10:40:59 <sm[m]> it's taking longer than I expected, watching #haskell-ide-engine gives an idea of what it involves
10:41:37 <sm[m]> in the end, what ships and works, wins
10:41:53 <monochrom> It's reflected in stack's LTS resolver and auto-install ghc for you, and cabal giving you more freedom and responsibility, to the point it looks like wild wild west when it comes to package versions.
10:41:57 <maralorn> simonmic: When I joint that room in february they told me they aim for a first public release in autumn.
10:42:24 <sm[m]> cool
10:43:00 <int-e> maralorn: . o O ( which year? )
10:43:22 <monochrom> stack emphasizes reproducible build, cabal emphasizes trying latest versions.
10:43:44 <maralorn> And it looks like they are still on track at least to me.
10:44:58 <monochrom> I am a liberal on this topic. (Oh don't worry, I'm a conservative on others.) To me the consequences of reproducible build is walled garden, jail, in the same sense some people jailbreak their iPhones because the walled garden is jail to them.
10:45:30 <sm[m]> as an outsider, you might wonder why couldn't a more limited but still useful release happen sooner ? Are they trying to solve all the problems before release ?
10:47:07 <tanner_> ok, I have a beginner level question
10:47:48 <tanner_> What is the "type structure" of (=) in haskell
10:48:08 <monochrom> It has none.
10:48:22 <monochrom> Why do you ask? What do you have in mind?
10:48:30 <dolio> I'm not clear what the question means. :)
10:48:51 <maralorn> simonmic: Well they have releases. I use it. I like it. But ‚Ä¶ seeing the history of Haskell build tools that you obviously are familier with, they are afraid of releasing a to rough product, because they are afraid to miss their adoption window.
10:48:54 <tanner_> everything in haskell is an expression right? so shouldn't a = 5 have a type associated with it?
10:49:06 <monochrom> No, everything is not an expression.
10:49:30 <dolio> You mean, not everything is an expression. :)
10:49:39 <maralorn> tanner_: It's a binding. Not an expression.
10:49:49 <tanner_> Ok, I actually did think everything was an expression
10:49:50 <monochrom> "everything is a declaration" would be right, but "declaration" is so diverse, that sentence is informationless.
10:50:02 <monochrom> as informationless as "every line of code is a line of code"
10:50:20 <tanner_> so is a binding a thing that takes a pattern on the left and a value on the right?
10:50:36 <monochrom> an expression on the right
10:51:01 <monochrom> now you can get to expressions
10:51:24 <maralorn> tanner_: People here often recommend the Haskell report. So last week even I went and had a look of it. It's actually nicely written and at the beginning it explains the structure of a Haskell program. Defining words like expression and binding. It's quite informative to see it explained so clearly.
10:51:29 <sm[m]> maralorn: that makes sense, they're right not to loudly release something that's not really solid. But in the end I think only that big high profile release will force it to become really solid. But I'm just armchair opining here, and by"they" I mean our dear esteemed volunteer and paid tool builders and benefactors to whom I am most grateful
10:51:55 <tanner_> ok, so on the right of `=` there is always and expression. What about the left of `=`, is that always a pattern?
10:52:08 <monochrom> Yes
10:52:18 <tanner_> And I will go check out the Haskell Report now. 
10:52:35 <monochrom> err there is another possibility on the left
10:52:53 <sm[m]> maralorn: do you know if multi-package projects, CPP, extensions and template haskell are handled yet ?
10:53:15 <monochrom> "f x = x+1" the LHS is "functionname pattern". This is for function binding so you don't have to always write "f = \x -> x+1"
10:53:41 <tanner_> Ok, so there are different kinds of patterns?
10:53:57 <monochrom> Yes, but "f x" is not even a pattern.
10:54:02 <maralorn> simonmic: I use it one a project that uses all of that (apart from CPP, but I am fairly sure CPP works). So I can tell you: Yes, I guess, yes and not quite.
10:54:19 <sm[m]> thanks, good to know
10:54:22 <monochrom> There is a "pattern = expr" binding, and there is a "fname pattern = expr" binding.
10:54:56 <monochrom> DO NOT EXPECT THIS TO BE SIMPLE
10:55:05 <sm[m]> maralorn: and how is memory usage & responsiveness for you ? do they stay good over time ?
10:55:07 <maralorn> simonmic: I sadly have a bug with template Haskell. But that worked before and is probably not very hard to fix. But the person assigned to it shifted priorities because they don‚Äòt use TH.
10:55:23 <tanner_> Ahhhh, ok that makes sense. Are there any other kinds of bindings. Or is it just those two?
10:56:33 <monochrom> I forgot. Is it important to build a complete taxonomy right now?
10:56:45 <tanner_> No. Thanks for your help.
10:57:38 <maralorn> simonmic: Memory consumption is significant (and probably leaking a bit) but I don‚Äòt need to restart it more often than every few days? Responsiveness is (and I think stays) great, only startup is a bit slow yet.
10:58:40 <monochrom> The underlying GHC API is leaking. This is somewhat well-known and also no solution any time soon.
10:58:53 <sm[m]> and (excuse me picking your brain) - install & setup was.. I remember, "super easy" right ? possibly because you're a nix wizard ?
10:59:14 <monochrom> OK, I can't say the IDE engine isn't leaking but I'm just giving a lower bound :)
11:02:01 <maralorn> simonmic: I (co-)maintain ghcide and hls in nixpkgs. So yeah, I might be based. But yeah, I think it is easy. But I don‚Äòt think that using nix is the easiest way to install it. You should in my opinion use nix to install hls iff you installed ghc via nix.
11:02:28 <sm[m]> cool. Thanks for doing that by the way
11:02:57 <maralorn> As you said yesterday, the easiest way is likely the vscode plugin?
11:03:28 <maralorn> Or maybe using ghcup?
11:03:58 <sm[m]> seems so. I'm an intellij man but I would give the vscode plugin a try one of these weeks. Except for the memory issue, on an 8G macbook I just can't afford it
11:04:50 <hekkaidekapus> At the plumbing level, there might be another duplication/improvement brewing: ghcide is a heavy Shake consumer. I wonder if it may evolve in a situation like GHC having two build systems.
11:06:06 <sm[m]> I think we're already living in that alternate reality hekkaidekapus :)
11:06:12 <hekkaidekapus> The set becoming {cabal, stack, shake-like} for more build tool puzzles.
11:07:02 <maralorn> simonmic: Hm, I think you should be fine if you can spare 2 to 3 GB? :-/
11:07:04 <hekkaidekapus> sm[m]: hehehe‚Ä¶
11:07:37 <sm[m]> maralorn: that's crazy talk :)
11:07:40 <maralorn> hekkaidekapus: I don‚Äòt think that ghcide will move away from being buildable with cabal.
11:07:46 <hekkaidekapus> So, nowdays, is the duplication social, historical, technical or what?
11:08:03 <hekkaidekapus> *nowadays
11:08:27 * sm[m] has many firefox tabs, usually a ghci & ghcid running, other essential apps and that's all that fits
11:09:15 <sm[m]> hekkaidekapus: you know that GHC has had two build systems for a few years now ?
11:09:20 <maralorn> Yeah, when I bought this notebook I didn‚Äòt expect to run into problems with 16G, still I often do ‚Ä¶
11:09:39 <maralorn> What's the second build system? I thought ghc uses hadrian.
11:10:04 <sm[m]> I think it's just one of the two, still. Seems like both systems still get discussed in #ghc
11:10:16 <hekkaidekapus> sm[m]: yeah, and it is apparently a pain to maintain hadrian and make together.
11:10:49 <hseg> btw, for those wondering re: TH supporting pragmas: https://hackage.haskell.org/package/template-haskell-2.16.0.0/docs/Language-Haskell-TH-Syntax.html#t:Dec
11:10:49 * hackage math-functions 0.3.4.1 - Collection of tools for numeric computations  https://hackage.haskell.org/package/math-functions-0.3.4.1 (AlexeyKhudyakov)
11:10:54 <sm[m]> complexity, our adversary!
11:11:12 <sm[m]> we make it, then we fight it :)
11:11:28 <hekkaidekapus> The plan was to decomission make circa June 2020, but that did not happen.
11:12:36 <hekkaidekapus> maralorn: gchide may not move away, but it may grow multiple build systems in the same repo.
11:14:49 * hackage azimuth-hs 0.2.0 - Interact with Azimuth from Haskell  https://hackage.haskell.org/package/azimuth-hs-0.2.0 (JaredTobin)
11:15:21 <wz1000> hekkaidekapus: ghcide doesn't use shake as build system, it uses it more like a framework
11:16:09 <wz1000> What you say is possible, but just not in the way you think it is. See https://mpickering.github.io/posts/2020-03-16-ghcide-reflex.html
11:17:47 <hekkaidekapus> wz1000: okay, thanks for the clarification.
11:26:54 <axgq> is Haskell a strong language for writing software that is compatible across systems and across scenarios because Haskell makes it easy for expressing ideas generally? This is just an idea I came up with.
11:30:01 <monochrom> "compatible across systems" is a function of compilers/interpreters, not a function of the language.
11:30:39 <maerwald> if you care about running on lots of systems, probably not
11:30:59 <maerwald> expressing ideas? like?
11:31:27 <dolio> Expressing ideas generally might make it very difficult to run on certain systems (with tight resource constraints), too.
11:31:43 <monochrom> Dijkstra has a Guarded Command Language that's applicable across scenerios because of the language, and incompatible across systems because no compiler or interpreter exists at all.
11:32:44 <int-e> monochrom: logicallly... that sounds like perfect compatibility to me
11:32:47 <monochrom> As an antipole, BF is inapplicable to any scenerio, but compatible across all systems.
11:32:57 <int-e> (runs equally well on all systems)
11:33:07 <axgq> reality isnt so simple I guess
11:33:40 <monochrom> but most people's "compatible" includes "runs on at least one system" in addition to "compare over two systems"
11:34:10 <monochrom> Oh this one doesn't even require considering reality.
11:34:24 <monochrom> Logic alone dictates that all extreme points exist.
11:34:51 <monochrom> It's just so nice that someones in reality have actually got them all done.
11:35:36 <monochrom> It's Murphy's Law and also law of large numbers.
11:36:05 <monochrom> If something is logical possible, you can bet that of the billions of people in the world, someone will make it happen.
11:36:32 <monochrom> This is why intuition is flawed.
11:36:55 <maerwald> that also applies to users... whenever you think "no one in their right mind would do this"...
11:37:12 <monochrom> Intuition forbids you from thinking up logical corner cases.
11:37:38 <axgq> intuition is flawed because were not smart enough?
11:37:55 <monochrom> Intuition is so sickeningly moral-burdened that it obliges you to only think of morally honorable cases.
11:38:00 <maerwald> you can get intuition for things you don't understand
11:38:10 <maerwald> how do you think ppl learn language
11:38:53 <monochrom> Like my current unix course assignment is to get my students implement a server that serves clients through sockets.
11:39:44 <monochrom> My students' clarification questions reflect that they still think that clients will only act morally, honorably, non-trollingly.
11:40:21 <axgq> nothing immoral about code that can run generally
11:40:44 <monochrom> For the tamest example, my protocol says "legal message at most 76 bytes, ends with newline".
11:41:09 <int-e> monochrom: This moral idea runs deep indeed. Just think on the term "exploit"...
11:41:15 <monochrom> Students ask "what if the client sends 80 bytes then newline?"
11:41:30 <sm[m]> I think there's something to what axgq said there.. we know there are issues, but if you look at a high level haskell does a pretty good job abstracting away platforms, compared to most languages ?
11:42:01 <monochrom> This question assumes that clients have "well intention" and is just goofy up the length, never trying to send you 100PB without any newline coming soon.
11:43:12 <axgq> what would it mean about the student always expecting to get screwed?
11:43:46 <monochrom> There are deeper examples such as students assuming that a client after connecting will send its message immediately, not just sit back and chill out and watch the server crash and burn.
11:44:17 <monochrom> It would mean the student finally attains mathematical maturity.
11:45:05 <maralorn> axgq: I think compiling Haskell to resource constraint systems. But of course writing high level code makes less assumptions about architecture so in priniciple it might be easier to support it on multiple platforms.
11:45:57 <maerwald> sm[m]: does it? Windows is still poorly supported
11:46:03 <maerwald> FreeBSD as well
11:46:13 <maerwald> arm not too well either
11:46:22 <axgq> in the end it probably still comes down to ghc though?
11:46:26 <maerwald> yes
11:46:33 <maerwald> need more devs
11:47:17 <maerwald> at least no one fired the core devs in haskell :)
11:47:30 <maerwald> (looking at the mozilla burn)
11:48:29 <axgq> I love mozilla. Firefox makes me pretty happy.
11:48:42 <sm[m]> maerwald: I've been shipping haskell apps that just work on windows for years. The build procedure is the same as on linux and mac. I'm not sure I could have achieved this with another language. Maybe java.
11:48:58 <sm[m]> obviously if we're talking low-level things YMMV
11:49:24 <maerwald> "works most of the time"? :p
11:49:50 <monochrom> int-e: The really sickening part is that the morality oversteps its rightful boundary and starts making moral judgment against 0 as a natural number, the empty string as a string, etc.
11:49:56 <axgq> its never been the thing to ruin my day
11:50:38 <dolio> Some mathematicians don't consider 0 a natural number.
11:51:08 <dolio> Or the empty simplex to be a simplex.
11:51:16 <monochrom> I.e., if you tell students to input a string and output to-upper-case conversion, the students show real dissent when told to also accept the empty string. As though any user giving this input were a pervert.
11:51:20 <int-e> dolio: Well, they're *wrong*, they're on the wrong side of the barricades, they'll be the first up against the wall when the revolution comes.
11:51:54 <monochrom> Despite the obvious fact that if your code makes no such judgment, it's actually simpler and the coder has an easier job.
11:51:57 <int-e> (There's no finder's fee for any irony or sarcasm found in that sentence.)
11:53:00 <monochrom> Isn't it clearly more code to write if you have one more "erroneous" case to treat as special and write more "error handling" code?
11:54:56 <axgq> handling erroneous special cases will be the death of me.
11:55:07 <monochrom> Damn right.
11:55:11 <int-e> monochrom: So many people want a non-empty list type, to which I have only one thing to say: Off with their heads! <-- find the pun
11:55:18 <monochrom> The solution is to not consider any input "invalid".
11:55:38 <monochrom> hahaha
11:56:14 <monochrom> Next April 1 let's publish a package for list-of-length-at-least-2
11:57:00 <monochrom> The ancient Greek counting numbers were at least 2. 0 was not a number. 1 was not a number either.
11:57:50 <int-e> monochrom: how many people do you need to make a crowd?
11:57:51 <maerwald> That reminds me of these obsessive "total preludes" that fix head, but still throw arbitrary undocumented and unchecked exceptions in IO
11:58:17 <dolio> I think the empty simplex not being a simplex is probably the more useful decision, given usual applications.
11:58:24 <dolio> Contrary to your simplistic logic here.
11:58:39 <monochrom> No, dolio, I am fine with that actually.
11:59:22 <int-e> dolio: "useful" is a key word here, really.
11:59:32 <monochrom> I am only critiquing my students and mediocre programmers. The mathematicians are doing the right thing.
11:59:34 <dolio> Non-empty lists are also a useful type.
11:59:37 <dolio> Just like lists.
12:00:04 <dolio> It's not necessary to only use lists or non-empty lists.
12:00:30 <int-e> In math, definitions are usually picked for convenience. (And this partly explains the contetion about 0 being a natural number.) In programming it's a difficult tradeoff between ease of use and ease of producing bugs.
12:00:48 <monochrom> In analysis, you need a word to mean "integers at least 1" because next you're going to "consider the sequence {1/n}, n in <that word>"
12:01:12 <int-e> "positive integer" is a well established phrase
12:01:27 <monochrom> If they feel like picking "natural" for that word, it's OK, as good as any word, may as well.
12:01:52 <maerwald> most problems in programming are mediocre... and you want mediocre programmers for that. I think attitude matters more
12:02:05 <xsarnik0> Hi, I cannot seem to install third party libraries (i.e. those not included in my Haskell Platform installation) using cabal. I use Windows and I have just completely removed any trace of Haskell Platform and installed it anew, because I had broken installation (lots of broken packages). The problem is, I want to install lens (globally), so I tried
12:02:05 <xsarnik0> "cabal new-install lens", it went through without any errors, just warning me to use cabal update and --lib. OK, I ran it again after updating and with --lib and again it was fine. The problem is, GHC says it cannot find Control.Lens and neither cabal list --installed nor ghc-pkg list shows it. But if I run the installation again, it just says "Up
12:02:06 <xsarnik0> to date.". I have always had problems with Haskell on Windows (tried multiple machines and multiple OS versions), so I would be very glad if someone could tell me what I'm doing wrong...
12:02:16 <monochrom> Yeah but good luck convincing Terrence Tao to s/natural/positive integer/ in all past and future writings of his :)
12:02:44 <monochrom> Not to mention s/Bbb{N}/Bbb{Z}^+/
12:03:18 <int-e> monochrom: oh well, part of math education is to always check whether "natural number" includes 0 or not in any new context.
12:03:29 <int-e> it's a nuisance but people cope
12:05:49 <axgq> 1/0 is an  erroneous special case you can't totally just ignore.
12:07:24 <hseg> i wonder how much of this is due to our built-in tdnr. any occurrence of 1/n and "n is a natural number" in the same sentence pretty clearly means "positive integer"
12:07:44 <koz_> xsarnik0: You don't normally install libraries that way.
12:07:47 <hseg> and the fact that people are usually relatively consistent helps here
12:07:57 <koz_> You make a project, have a Cabal file in there, and spell your deps.
12:08:06 <koz_> Then you use 'cabal new-build' and it pulls them down.
12:08:22 <koz_> 'cabal new-install' is for executables.
12:08:53 <hseg> would be nice if there were some tooling for math to help mitigate this though
12:09:30 <hseg> at the low-tech end, we have the status quo of listing all conventions you are aware of making near the start of your work
12:09:37 <axgq> xsarnik0: There is a section of the cabal file called build-depends. Might want to look there.
12:10:08 <hseg> at the utopic high-tech pipe dream end, there's fully tagged semantic structure on the text, with auto-conversion to your preferred convention
12:21:39 <koz_> I have a unidirectional pattern like 'pattern Foo x <- Bar (Baz x)'. However, I want the pattern to 'expose' (f x), rather than x. How do I spell that?
12:25:01 <xsarnik0> koz_: I was hoping I would be able to install the package globally (like mtl, containers and other packages that came with the installation). But I will try this approach, hopefully I'll fare better than with stack (which fails with access violation when building the basic unchanged project)
12:25:27 <hseg> koz_: view patterns?
12:25:45 <koz_> hseg: https://gitlab.haskell.org/ghc/ghc/-/wikis/pattern-synonyms#uni-directional-pattern-only-synonyms
12:25:59 <hseg> no, meant that as a suggestion
12:26:09 <maerwald> xsarnik0: what library do you want to test?
12:26:20 <koz_> Uhh, are you saying that I should look up the ViewPatterns docs?
12:26:48 <koz_> Ah, I see, write a helper.
12:27:06 <hseg> i'm saying that possibly sth like pattern Foo x <- Bar (Baz (f -> x)) could work 
12:27:07 <hexagoxel> pattern Foo x <- Bar (Baz (f -> x))
12:27:12 <hseg> sniped
12:27:16 <hexagoxel> :)
12:28:03 <koz_> I am reaching LANGUAGE pragma Zen. :P
12:28:06 <koz_> (one with everything)
12:28:08 <hseg> :D
12:28:08 <xsarnik0> maerwald: What do you mean by ‚Äútest‚Äù? I just wanted to install lens...
12:28:21 <maerwald> and then?
12:28:30 <koz_> xsarnik0: You don't really 'install' libraries in the Cabal model. You depend on them.
12:28:42 <koz_> What's the exact goal of this exercise?
12:29:32 <xsarnik0> Then use it in a small homework that is mainly about the state monad but we were encouraged to use lens, too
12:29:54 <maerwald> make them pay and use optics instead
12:29:57 <koz_> xsarnik0: So create a project for said small homework, give it a Cabal file, add lens as a dep.
12:30:06 <maerwald> yep
12:32:37 <xsarnik0> I will give it a try. But is there no way of installing a library globally so that it is accessible from any project and any instance of ghc(i)?
12:32:44 <hexagoxel> I thought ghc-env files would expose lens to even plain ghc after `cabal install --lib lens`, but maybe that does not work on windows?
12:34:53 <hexagoxel> ehh I hate that feature anyway, too much magic. So I won't test. I am pretty sure it is _supposed_ to work with the steps that you took, but probably there is some bug.
12:36:08 <hyiltiz> A saner build test and package management toolset would cut at least half the traffic here...
12:37:20 <hexagoxel> ... and double the traffic on #nixos? :)
12:38:54 <koz_> If you enable OverloadedRecordFields, do we get HasField instances for existing records?
12:48:45 <hseg> q: if i have a function f marked as {-# INLINE #-} and I pass it to a TH splice to be placed at the RHS of a declaration, will it still be inlined?
12:49:07 <hseg> or do I manually need to quote/unquote it?
12:50:05 <hseg> (so iiuc, i'd have mkDecl f = [d| lhs = f rhs |]; $(mkDecl [|foo|]) ?)
12:50:40 <hekkaidekapus> koz_: Did you mean DuplicateRecordFields?
12:51:21 <hseg> (or alternatively, $(mkDecl 'foo), or even mkDecl 'foo at top-level)
12:51:23 <koz_> hekkaidekapus: Lol, pays to read more carefully.
12:51:25 <koz_> https://gitlab.haskell.org/ghc/ghc/-/wikis/records/overloaded-record-fields
12:51:38 <koz_> I meant this, but I misunderstood that as a single extension.
12:51:39 <koz_> Ignore me.
12:52:59 <sm[m]> "fails with access violation" sounds like a known bug with GHC 8.8.3 on windows ? You could tell stack to use a different version
12:53:30 <hekkaidekapus> Ah, I was intrigued with the ‚Äúenable‚Äù. As of your question, see section 9.5.6.1 in the GHC user‚Äôs guide (8.10); koz_ 
12:53:53 <sm[m]> (xsarnik0: ^)
12:54:00 <hekkaidekapus> *Intrigued by
12:55:14 <maerwald> hexagoxel: they said *saner*
12:56:10 <hexagoxel> it's a low bar
12:56:15 <maerwald> heh
13:05:04 <xsarnik0> sm[m]: Yes, it seems that is the problem. I was just unsure whether it would work at all and thus elected to try cabal without stack
13:05:08 <koz_> hekkaidekapus: Is this in 8.10 only? Or more recent?
13:05:28 <koz_> s/more/less/
13:06:25 <xsarnik0> So, it seems lens is importable when I used that project approach. However, how do I run ghci within that project? Cabal repl kinda works, but it first spews out dozens of lines about invalid paths...
13:06:59 <ixlun> Hi all, I'm wondering if somone could help with importFile from this package: https://hackage.haskell.org/package/HCodecs-0.5.2/docs/Codec-Wav.html 
13:07:44 <ixlun> After calling the funciton in a do block and passing a FilePath, I'm getting an error that a0 is ambiguous, but I don't know what exactly is ambiguous?
13:07:58 <ixlun> Do I need to provide the sample format, Int16 in my case?
13:08:06 <sm[m]> xsarnik0: I have been working around by using --resolver lts-15.3 (GHC 8.8.2)
13:10:04 <hekkaidekapus> koz_: It‚Äôs there for a long time, the version is there to make sure you get the right section number.
13:10:23 <koz_> hekkaidekapus: I found it. Thank you, you're an excellent and attractive human being.
13:10:33 <hekkaidekapus> lol
13:10:43 <hekkaidekapus> thanks
13:12:33 <ixlun> Think I've got it, I had to specify the type: wavData <- importFile inputFile :: IO (Either String (Audio Int16))
13:12:36 <hseg> have an import cycle where there is a default implementation of some class methods by a subclass. guidance?
13:12:50 <xsarnik0> (It seems I had some strange path in cabal config file)
13:13:11 <hseg> (ie module A defines class C, module B defines subclass S, C has a default impl for a method in terms of S)
13:13:13 <ixlun> Is there a less verbose way of doing the above?  Or do I have to print the full type to resolve the type variable?
13:14:11 <xsarnik0> So it seems to work now with cabal. Thanks for all your help. I will also consider using stack with a different resolver, but for now, cabal projects seem to work fine.
13:17:00 <hseg> ok, reading up on hs-boot, seems it suffices to drop a B.hs-boot that just declares the existence of S with its method signatures, then import {-# SOURCE #-} B in A
13:17:30 <xsarnik0> By the way, where does cabal put the packages it has automatically downloaded for a project?
13:20:19 <hseg> somewhere in dist-newstyle, i think
13:21:10 <hseg> though there is a cache in ~/.cabal/packages iirc
13:22:01 <xsarnik0> I see, thanks
13:22:22 <hseg> ffs. TH is more of a pain than i'd thought
13:22:49 <hseg> esp with the restrictions on what can be used where
13:24:31 <hseg> case in point, have module A defining class C, want to cut down on tedium of writing instances in a way that's backwards-compatible beyond 8.6, so i turn to TH, but that forces me to write derivation code in a different module, and now how will I export those instances from A?
13:24:35 <hseg> *deep breath*
13:26:01 <hseg> ... i guess i could add *another* module cycle, having a module A.TH importing A for its class, and having module A import A.TH for its splicer
13:26:19 <solonarv> the TH doesn't actually need to have the class in scope
13:26:21 <sm[m]> xsarnik0: under ~/.cabal, except for packages that are defined by your project, I'd think
13:26:29 <hseg> wait, what?
13:26:47 <solonarv> it's convenient to have it in scope, because you can just refer ro 'MyClass and call reify on things etc
13:27:48 <hseg> just as a reminder, we're discussing http://ix.io/2u5r here
13:28:11 <solonarv> yeah, you need Semiring in scope for that to work
13:28:19 <hseg> so i'm sol
13:28:37 <hseg> unless i overcomplicate things
13:28:52 <solonarv> however if you hand-write everything using the AST constructors directly, you shouldn't need anything in scope
13:29:33 <hseg> yeah, but i want to $(deriveSemiring 'divIntegral ''Int) etc
13:29:49 <hseg> ... wait, what AST constructors?
13:30:02 <solonarv> all the stuff in Language.Haskell.TH.Syntax
13:30:12 <hseg> no way
13:30:16 <hseg> nope
13:30:29 <hseg> all i wanted was a more principled version of http://ix.io/2u4l
13:30:58 <hseg> guess i'll just cargo-cult that and edit it appropriately for the versions i need
13:31:14 <solonarv> yeah it's not exactly worth the effort
13:31:26 <solonarv> cyclic import might actually be the cleanest solution?
13:33:22 <hseg> :-/ what the hell, worst case my patch will be rejected
13:36:39 <zenzike> Hello! I'm wondering if there's a haskell reddit moderator here?
13:37:45 <solonarv> oh, a third option: typeclass defined in A.Internal, template haskell functions defined in A.TH (which imports A.Internal), A reexports the typeclass and has TH-defined instances
13:40:24 <hseg> no way that gets accepted
13:43:36 <solonarv> ah right, this is for a patch
13:46:23 <hseg> yeah, if it were for my own use i'd just DerivingVia my way out
13:47:47 <hseg> hrm. annoyingly, this is heavy on the consumer side as well
13:47:54 <hseg> meh
13:50:51 <hseg> hrm. any maps (a -> b) -> (Name -> Q Exp) ?
13:52:41 <hseg> basically, you'll note that my template instance definition is parametrised by the rhs of divide
13:53:21 <hseg> ... then again, considering they're for internal use only, might as well just quote them at definition
13:57:36 <hseg> hrm. am getting staging errors http://ix.io/2u5z, think i'm misexpressing the idea that divide x y = div x y 
13:58:14 <ixlun> Does anyone know how I can do `head` on a UArray?
13:58:38 <hseg> hrm. nm re the typing, seems it's useless in my case
14:02:37 <L29Ah> ixlun: index by `head . indices`?
14:02:55 <L29Ah> or just `head . elems`
14:04:10 <monochrom> "head on UArray" sounds like you don't want the benefits of UArray
14:06:01 <ixlun> Ahh sorry I think I get it now, an Array is an indexed (presumably fixed-size) where as [] is a linked list that can grow dynamically?
14:07:17 <hyiltiz> Just read http://www.vex.net/~trebla/haskell/lazy.xhtml
14:07:22 <hyiltiz> On an android phone
14:07:34 <monochrom> I wouldn't emphasize dynamic growth because we also know how to wrap a growable interface outside an array.
14:08:03 <hyiltiz> Now opening it in a computer browser, all those god-awful tiny arrows and miniscule circular dots were just due to poor rendering in the phone...
14:08:07 <monochrom> Instead, [] is singly linked list and best for sequential access, array is best for random access.
14:08:28 <hyiltiz> They were pretty large and clear in my computer; now I regret reading it over phone
14:08:36 <monochrom> Actually I tested it on a phone and it's great.
14:09:18 <hyiltiz> Hmm~ I viewed an a latest Android using jQuarks browser
14:09:33 <monochrom> OK, I didn't test an Android phone.
14:09:54 <monochrom> also I guess "great" is subjective
14:10:15 <monochrom> A lot of movies are below 50% on rotten tomatoes but I think great
14:10:37 <monochrom> The opposite is also true of some movies
14:10:51 <monochrom> 90% on rotten tomato but meh for me
14:10:55 <monochrom> BITE ME
14:11:23 <hyiltiz> Hmm uploading pics via Quasseldroid is awkward; wait a sec
14:13:26 <auf92k> I'm seeing an issue where when I "cabal v1-install" a package it says "rejecting: ghc-8.6.5/installed-8.6... (package is broken)". GHC 8.6.5 is indeed my GHC version, and the package shows up as blue when I "ghc-pkg list"
14:13:48 <ixlun> monochrom: ahh okay now I see.  Thanks for the info
14:14:17 <hyiltiz> https://photos.app.goo.gl/Bq8xGvSi9uKSGP6m7
14:15:52 <monochrom> How many people here did not finish 1st-year CS?  Or finished 1st-year CS but doesn't really count because it's exclusively python which actively mars and confuses the issues?
14:16:20 <hyiltiz> Better link: http://0x0.st/iYBc.jpg
14:16:23 <monochrom> Because "array vs linked list" is standard 1st-year CS knowledge apart from Python keeping you dumb on this.
14:17:01 <hyiltiz> Welp I learned thru C
14:17:28 <monochrom> and like 20%-40% of questions here are answerable just by knowing that.
14:17:41 <hyiltiz> The prof. kept mentioning knowing C will guarantee a job for us
14:18:28 <hseg> antiquated education system was supposed to teach me C, taught me C++ instead
14:18:39 <hseg> was lucky they'd upgraded standards from Pascal
14:18:56 <hyiltiz> At one point I wondered how exactly linking, parsing and compiling would work, so I asked (not a good question, sure): how long would it take for you to write an IDE for C, say Code::Blocks
14:19:13 <hyiltiz> Thinking GCC surely is included as part of developing CB
14:19:24 <hyiltiz> He said, "well, maybe just a week"
14:19:55 <monochrom> Yeah that's a very poor question.
14:20:13 <hyiltiz> Apparently he assumed GCC, and graphics library and everything else is given
14:20:22 <monochrom> Wondering what organs are inside a human you start with "what's the average human height?"
14:20:23 <hyiltiz> So he just had to put together the pieces to get a "IDE"
14:20:50 <hyiltiz> Well, I were at a point where I couldn't cleanly tell apart an IDE from GCC
14:21:06 <hyiltiz> Just like how M$ would let us believe computers and microsoft and windows all mean the same thing
14:21:12 <hyiltiz> or they used to
14:21:26 <monochrom> But you could directly say what you meant: "what's inside an IDE"
14:21:30 <hyiltiz> and that OS doesn't exist; computer is just a windows.
14:21:43 <monochrom> as opposed to a pretty irrelevant metric like time
14:22:22 <hyiltiz> He was in a hurry and ran away before I could follow up much. I recall asking how was that possible to do within a week, and he said well "there are graphics libraries editor libraries etc."
14:23:13 <hyiltiz> I guess I was meaning to ask how much technical expertise and effort is required to build a C hello world program, purely out of scratch on a given hardware.
14:23:27 <hseg> hrm. don't understand enough about TH to know how I should write def f = [d|foo x y = $(f x y)]
14:23:38 <hyiltiz> But I thought asking about IDE is the same question...
14:25:33 <hseg> (ghc complains of staging restrictions)
14:26:00 <hseg> ... am I supposed to be writing $(f (reify 'x) (reify 'y)) instead?
14:30:47 <hseg> ok, so http://ix.io/2u5I works
14:30:55 <hseg> recommendations for improvement?
14:33:36 <monochrom> Oh, you intend the user to use $(deriveSemiring divideIntegral ...) or $(deriveSemiring divideField ...). Interesting.
14:33:41 <hseg> yep
14:33:59 <hseg> because DerivingVia is too young to be my only option
14:34:04 <hseg> and CPP is ugly af
14:37:11 <hseg> "module Data.Semiring cannot be linked; it is only available as a boot module" ?
14:43:44 <solonarv> hmm, let me write up a gist
14:44:06 <int-e> hseg: did you make a Data/Semiring.hs-boot file?
14:44:12 <hseg> yes
14:44:31 <hseg> in order to break the cycle between that and the TH module
14:44:36 <int-e> hseg: You can't have template haskell in the loop, I think, because in order to run template haskell code, all the modules have to be fully compiled
14:44:37 <glguy> hseg: Are you trying to use the TH, export it for others, or both?
14:44:51 <int-e> loop -> cycle
14:45:12 <int-e> hs-boot files only describe an interface, they don't have any runnable code
14:45:13 <hseg> (Data.Semiring defines the Semiring class, TH defines a derivation mechanism, Data.Semiring uses it to define Prelude instances)
14:45:24 <hseg> int-e: oh?
14:45:45 <hseg> didn't get ghc shouting about the cycle though
14:45:49 <int-e> hs-boot files allow other modules to be type-checked and thus compiled, before the module itself  is compiled.
14:45:57 <hseg> right
14:46:06 <glguy> hseg: If you're just using TH to generate the prelude instances then it is pretty easy
14:46:15 <int-e> hseg: this is its way of saying that the Semiring.hs file has not yet been compiled at the point where it's required (through template haskell)
14:46:18 <glguy> you define your TH code in a let expression as its being used
14:46:18 <int-e> I think./
14:46:27 <glguy> like I showed in my original paste
14:46:31 <solonarv> hseg: https://gist.github.com/Solonarv/b424059d55d3b85e3b182db93e62ad38
14:46:55 <solonarv> with this the user can write: $(deriveSemiring 'divideIntegral [t| MyType |] )
14:47:03 <hseg> glguy: staging restriction. you can't splice TH in the defining module
14:47:04 <solonarv> (and the surrounding $( ) is actually optional)
14:47:10 <glguy> hseg: Right, you do what I said
14:47:55 <hseg> solonarv: how does your solution improve on mine?
14:48:08 <glguy> hseg: you should understand what I said because it allows you to do what you asked
14:48:40 <solonarv> hseg: a little easier for user to specify which divide function they want
14:48:55 <solonarv> (you can't just take the function as an argument unfortunately)
14:49:15 <hseg> hrm... have ~55 instances i want to derive. inlining the TH in all of them is a little excessive
14:49:22 <glguy> hseg: nope
14:49:26 <glguy> you do them all in one TH expression
14:49:28 <int-e> glguy: AIUI, solonarv wants to define a class and use template haskell to make instances for that class, all in one module (perhaps to avoid orphan instances?).
14:49:35 <glguy> int-e: Yeah, that's fine
14:49:53 <hseg> int-e: you mean me?
14:50:01 <hseg> int-e: and yes
14:50:07 <int-e> hseg: err, yes.
14:50:13 <hseg> but that gave me staging restrictions
14:50:19 <hseg> so i pulled out the TH
14:50:23 <glguy> https://gist.github.com/glguy/0651d4b0b8fb2ab98683788c9b2c39c0#file-multipleinstances-hs
14:50:26 <hseg> which gave me cyclic dependencies
14:50:32 <hseg> so i wrote .hs-boot
14:50:44 <hseg> which is now complaining the main file can't compile
14:50:48 <glguy> hseg: ^
14:51:12 <int-e> hseg: well I think the hs-boot cannot help
14:51:38 <hseg> glguy: ok, that looks like it might work
14:51:55 <int-e> maybe in theory (because the TH code does not acutally *us* any *code* from the semiring module), but not in practice as ghc implements it
14:52:01 <int-e> *use*
14:52:08 <monochrom> Oh hrm, interesting, glguy.
14:52:42 <monochrom> But you need to import something for "Word" to make sense, no? :)
14:52:50 <glguy> Word is Prelude these days
14:52:56 <monochrom> Darn
14:53:02 <monochrom> Is Natural also in Prelude yet?
14:53:11 <hseg> not afaik
14:53:16 <monochrom> I mean s/Darn/Great!/
14:53:41 <auf92k> Has anyone seen the above "rejecting: ghc-8.6.5/installed-8.6... (package is broken)" error with a seemingly non-broken ghc packaage before?
14:53:43 <monochrom> OK next time I'll use more Word than Int in front of students when I intend no negative numbers!
14:54:11 <monochrom> ho hum already in 8.6, I totally missed that
14:54:59 <monochrom> Anyone wanna petition for length to give Word instead of Int? :)
14:55:26 <int-e> monochrom: no
14:55:41 <hseg> int-e: why not?
14:55:47 <monochrom> OK! I know it's too revolutionary.
14:56:06 <glguy> I'm sure someone does, but Int is a better default for thing you do arithmetic on than Word
14:56:31 <hseg> monochrom: heh. was thinking this morning that we might want some IntLike interface to tell ghc to guess the appropriate Int type, idem with NatLike
14:56:37 <int-e> monochrom: you'll get a debate between people who want to preserve backward compatibility and people who want Natural citing silly examples like length [0..2^65]
14:57:01 <int-e> (or less silly examples involving Data.Seq, which may be drawn into this discussion as well)
14:57:02 <hseg> glguy: you mean cpus optimize ints better?
14:57:07 <glguy> hseg: No
14:57:20 <hseg> yeah, that made no sense to me either
14:57:24 <hseg> ok, then what?
14:57:30 <glguy> I mean that most values are small and people like + and - and so on on the results of length
14:57:40 <monochrom> I think glguy means a group is better than a monoid.
14:57:41 <glguy> and going into negative numbers is better than overflowing to huge ones with mistakes
14:58:28 <int-e> > drop 62 $ map Seq.length $ iterate (\x -> x <> x) (Seq.singleton ())
14:58:30 <lambdabot>  [4611686018427387904,-9223372036854775808,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
14:59:44 <glguy> It similar to how I wouldn't advocate someone to use a new "even number type" for lengths of a particular list that happened to always be even lengthed; it's too likely you want to do more than be proud that it is even with that number
14:59:52 <int-e> (that's what I meant by "less silly example")
15:01:31 <int-e> Also expressions like (length as - length bs) seem perfectly reasonable to me.
15:02:40 <int-e> And by using Word those would require a cast. Defensible in a new design of the libraries I suppose, but not something you change after 30-ish years.
15:03:27 <int-e> Ah, right, as glguy said.
15:03:27 <hseg> right. except i was lured to haskell under the promise that with expressive enough types you can avoid most errors
15:03:30 <dolio> monochrom: They're both groups, though. :)
15:03:40 <monochrom> haha
15:03:54 <hseg> then again, if i wanted that i should have gone full dependent
15:04:02 <glguy> If you want static guarantees capturing the ranges of function results I'd say look more to what Liquid Haskell offers with its system
15:04:42 <glguy> hseg: It 1) helps avoid some errors 2) enables different abstractions
15:04:51 <glguy> but it doesn't eliminate most errors
15:05:05 <hseg> k
15:05:17 <hseg> sth to look into later
15:07:19 * hackage hapistrano 0.4.1.1 - A deployment library for Haskell applications  https://hackage.haskell.org/package/hapistrano-0.4.1.1 (juanpaucar)
15:10:55 <dolio> Oh, there's already something for the Natural people, though.
15:11:01 <hyiltiz> Any recommended watches for the haskell.love videos?
15:13:32 <hyiltiz> Ideally about abstractions, or mindsets that is general to FP not just haskell
15:15:02 <hyiltiz> I have now Co-programs, Dava vs Control and Replacing Data with Functions
15:31:43 <hseg> glguy: it seems to be working. am held up by other errors, but they don't seem related
15:34:05 <Graypup_> so I tried to represent validation state with a newtype, but it looks like Aeson can just run right through it and give the validated newtype even if it is invalid
15:34:18 <Graypup_> can I ... stop that happening?
15:34:39 <monochrom> Vague.
15:34:51 <Graypup_> oh lol actually I just messed up
15:35:10 <Graypup_> forgot to rename the instance FromJSON when I renamed the type
16:10:41 <iiiiiiii> hi
16:10:45 <iiiiiiii> where is cardano 
16:10:47 <iiiiiiii> chan
16:13:19 * hackage mattermost-api 50200.7.0 - Client API for Mattermost chat system  https://hackage.haskell.org/package/mattermost-api-50200.7.0 (JonathanDaugherty)
16:14:20 * hackage mattermost-api-qc 50200.7.0 - QuickCheck instances for the Mattermost client API library  https://hackage.haskell.org/package/mattermost-api-qc-50200.7.0 (JonathanDaugherty)
16:15:20 * hackage matterhorn 50200.10.0 - Terminal client for the Mattermost chat system  https://hackage.haskell.org/package/matterhorn-50200.10.0 (JonathanDaugherty)
16:36:36 <koz_> What is more onerous: being an Applicative, or being a Traversable?
16:38:02 <monochrom> They are fairly orthogonal
16:38:19 <monochrom> But I guess let me look up what onerous means first haha
16:38:50 <solonarv> "expensive", "difficult"
16:38:56 <monochrom> Oh, so the assignments I give to my students are onerous!
16:39:01 <koz_> monochrom: LOL
16:39:15 <solonarv> according to your students, yes, of course! :p
16:39:16 <koz_> I meant it in the 'difficult' sense.
16:40:05 <monochrom> I think they're similarly easy/difficult.
16:40:36 <solonarv> I guess you could try seeing how many functors have an instance of Traversable / Applicative / both ?
16:40:58 <solonarv> representable functors are automatically both, so that's not very enlightening
16:41:27 <koz_> What's a Traversable that's not also an Applicative?
16:41:38 <infinisil> I'd say Applicative is more difficult
16:41:49 <infinisil> Just because it's harder to understand what it does
16:42:14 <solonarv> intuitively it seems like you should be able to sort of hack together a <*> using traverse, but I don't know how you'd get yourself a pure
16:42:17 <solonarv> I just realized I am too sleepy to discuss this, though
16:44:34 <glguy> data T a = T1 a | T2 a
16:44:55 <glguy> That's traversable, but I don't think it can be applicative
16:44:59 <koz_> glguy: So basically Either a a?
16:45:35 <glguy> Oh, no it can probably be applicative where you just use T2 if you ever see one and pure is T1
16:46:35 * glguy hasn't tried to think of an example before, making it up along the way
16:46:59 <monochrom> Binary tree with data at internal nodes, "data B a = Nil | Node a (B a) (B a)". I don't know how it's Applicative.
16:47:08 <glguy> There's probably some variation on data T a = T1 a a | T2 a a a that doesn't admit an applicative instance
16:48:02 <koz_> monochrom: Does <*> kill you because the structure of the result is unclear?
16:48:08 <koz_> (assuming two non-Nils)
16:48:09 <monochrom> Actually "data Triple a = T3 a a a" may have problems.
16:48:20 <monochrom> Right.
16:48:29 <glguy> Triple is easy
16:48:47 <monochrom> Oh, zip it.
16:48:49 <glguy> pure x = T3 x x x; T3 f g h <*> T3 x y z = T3 (f x) (g y) (h z)
16:49:01 <koz_> Yeah, Triple a is just Vector 3 a.
16:49:17 <koz_> And that's basically a ZipList in typelevel clothing.
16:49:42 <koz_> The binary tree one is indeed a tricky one.
16:49:43 <monochrom> ZipList but the length is always 3.
16:50:55 <glguy> monochrom: Your data B example is probably: pure x = Node x (pure x) (pure x)
16:51:22 <glguy> and B f f1 f2 <*> B x x1 x2 = B (f x) (f1 <*> x1) (f2 <*> x2); _ <*> _ = Nil
16:51:38 <monochrom> ZipBinaryTree and just truncate like ZipList.
16:52:20 <glguy> T1 a a | T2 a a a probably works too, you just truncate off the last 'a' in T2 if you ever find a T1 somewhere
16:52:24 <glguy> pure x = T2 x x x
16:58:51 <monochrom> May be easier to start with non-Applicative Functor.
17:00:03 <glguy> The easiest way to make one of those is with ((->) a), but then you're not Traversable
17:01:35 <glguy> could be something like adding in some extra data: data Tx a = C Int a -- but some type that doesn't admit a monoid instance instead of Int
17:04:05 <koz_> glguy: So Writer w a for non-Monoid w?
17:06:42 <monochrom> Math is too hard.
17:07:12 <glguy> Finding a non-monoid w is a simpler to define problem than find a non-applicative traversable, but I don't know that we'll find it easier to do
17:07:59 <olligobber> Never is not a monoid
17:08:33 <monochrom> Sorry, what is Never?
17:08:39 <olligobber> the empty type
17:08:49 <olligobber> `data Never'
17:08:49 <glguy> oh yeah, there we go: data No a; This is traversable and not an applicative
17:09:24 <monochrom> This is anticlimatic.
17:09:31 <glguy> We did it!
17:09:42 <monochrom> Also on the technicality of "can't pure".
17:10:03 <monochrom> because <*> is still as doable as traverse
17:10:04 <glguy> it was always going to be a technicality :)
17:10:22 <monochrom> Math is too cheesy.
17:10:34 <olligobber> Char doesn't have a monoid instance right?
17:10:45 <glguy> OK, so we have to fall back to http://hackage.haskell.org/package/semigroupoids-5.3.4/docs/Data-Functor-Apply.html#t:Apply
17:10:50 * hackage language-ats 1.7.10.2 - Parser and pretty-printer for ATS.  https://hackage.haskell.org/package/language-ats-1.7.10.2 (vmchale)
17:11:10 <glguy> olligobber: It could be
17:11:23 <monochrom> "doesn't have a monoid instance" is too weak.  We need "cannot be given".
17:11:34 <olligobber> yeah I guess it could have one
17:11:53 <olligobber> any non-empty type can have a monoid instance
17:12:13 <monochrom> Because for example "data C a = C Char a" when I make C applicative I can hardcode my favourite <> for Char.
17:13:16 <monochrom> which is bitwise xor, haha!
17:13:22 <olligobber> a<>b=' ', mempty=' '
17:13:42 <olligobber> I love bitwise xor
17:14:02 <glguy> a<>b=' ', mempty=' '; this isn't a valid Monoid instance through
17:14:13 <olligobber> oh yeah it isn't
17:14:13 <glguy> 'a'<>mempty /= 'a'
17:15:02 <olligobber> pretty sure every non-empty type can have a monoid instance though
17:15:23 <glguy> 'x'<>y=y;x<>_=x; mempty='x' -- dumb monoid instance
17:15:55 <olligobber> pretty sure that fails something
17:16:03 <glguy> bring it on!
17:16:12 <glguy> :)
17:16:51 <olligobber> ah, maybe it's fine
17:16:53 <iqubic> No. Actually, that looks fine.
17:17:07 <olligobber> ok, so every non-empty type can have a monoid instance
17:17:18 <monochrom> On the flip side, "every non-empty set is a carrier of some monoid" is probably on the order (pun! read on!) of "every non-empty set is a carrier of a total order". I believe them, but need axiom of choice.
17:17:21 <dolio> olligobber: Prove it.
17:17:43 <olligobber> cbb
17:18:08 <glguy> given my example we'll need a type where we can't compare for equality of elements
17:18:13 <dolio> If you need the axiom of choice, you shouldn't believe it.
17:18:27 <monochrom> Oh haha, didn't I just write the solution right there.
17:19:22 <olligobber> I believe there is a total order on cardinalities, hence I believe the axiom of choice
17:19:25 <iqubic> glguy: Just use "Data Endo a = Endo { unEndo :: a -> a }"
17:19:37 <iqubic> Try comparing that for equality.
17:19:40 <glguy> That's a Monoid already
17:19:56 <iqubic> It is?
17:20:02 <glguy> and because of instance Monoid b => Monoid (a -> b)
17:20:03 <iqubic> Oh, right.
17:20:08 <glguy> we can't really lean on functions to help at all
17:20:13 <iqubic> Damn it.
17:20:24 <monochrom> The set is non-empty, so pick one element, declare it mempty.  For the rest, total-order them, then use max for <>.
17:20:53 <iqubic> So, what other data types exist that we can't compare for equality?
17:21:04 <iqubic> Do we need something existential?
17:21:16 <glguy> monochrom: a total order is a stronger requirement than testing for equality, right?
17:21:45 <monochrom> Yes, but I have an excuse.
17:21:51 <dolio> Comparing for equality isn't necessary for something to be equipable with a monoid structure, but it is necessary for that sort of example.
17:22:13 <glguy> dolio: No, I'm just saying that it's sufficient so we need an example that doesn't admit equality
17:22:18 <monochrom> Even for a monad law like "return a >>= k = k a" we use mathematical equality there, not Haskell computable ==
17:22:30 <dolio> glguy: I know you are. I was just trying to make it clear.
17:22:34 <glguy> thanks
17:23:16 <glguy> one way to dispatch equality is to have infinite structures making some equality non-terminating
17:24:06 <dolio> iqubic: Real numbers are an example of a type without decidable equality, but you can still equip them with a monoid structure.
17:25:13 <monochrom> I love math.
17:25:20 <olligobber> ooh, what about `data InfList a = Cons a (InfList a)', since it only has infinite lists equality cannot be computed
17:25:46 <olligobber> oh but it still has a monoid instance
17:25:53 <olligobber> it's basically the same as Natural -> a
17:26:49 <monochrom> glguy, perhaps you can try "newtype D = MkD (D -> D)" to make me question my faith.
17:27:13 <glguy> That's your non-monoid candidate?
17:27:42 <glguy> mempty = D id; D f <> D g = D (f . g)
17:27:50 <monochrom> Because if you merely have X -> SomeADT, then SomeADT is easily eligible for "deriving Ord" and also to pick a global min.
17:28:12 <monochrom> Oh OK. That steels my faith, haha.
17:28:34 <glguy> the X -> SomeADT comment is related to pasting instance Monoid b => Monoid (a -> b) above
17:28:44 <monochrom> Yeah
17:29:39 <koz_> How do you add a type sig to a let-binding?
17:29:47 <monochrom> Please don't bring up computable equality test. We are proving math laws, math laws use math equality.
17:30:03 <glguy> let f :: typesig; f = definition in use f
17:30:14 <koz_> glguy: Thanks!
17:30:19 <monochrom> Worse, we are proving that a certain candidate math law is unprovable.
17:32:23 <monochrom> Bah windows restart to finish updates, can't play games, stuck here doing impossible math with you.
17:32:29 <glguy> OK, and it's not that we have to have arbitrary decidable equality, just decidable equality to mempty
17:32:41 <monochrom> But the silver lining is I got a chance to throw around choice!
17:32:58 <glguy> for that particular class of solutions
17:33:57 <glguy> anyway, all this not finding a solution has made me hungry
17:33:58 <glguy> o/
17:34:20 <monochrom> I recommend curry burrito.
17:49:20 * hackage rescue 0.2.1 - More understandable exceptions  https://hackage.haskell.org/package/rescue-0.2.1 (expede)
17:58:06 <kraeXen> lol, uses windows xD
17:58:09 <kraeXen> anyway, 
17:59:32 <kraeXen> is there anything like P.head for arbitrary arrays of mixed types?
17:59:38 <kraeXen> and tail as well
18:01:05 <monochrom> No.
18:01:47 <kraeXen> that's unfortunate
18:02:09 <kraeXen> stuck using list comprehension then
18:03:19 * hackage base64-bytestring 1.2.0.0 - Fast base64 encoding and decoding for ByteStrings  https://hackage.haskell.org/package/base64-bytestring-1.2.0.0 (topos)
18:18:33 <dminuoso> kraeXen: What module is P referring to in P.head?
18:18:46 <kraeXen> prelude
18:18:54 <kraeXen> > head "abc"
18:18:56 <lambdabot>  'a'
18:19:17 <kraeXen> but for [unknown, unknown and probably different, and I don't know how long it goes on for]
18:19:58 <dminuoso> kraeXen: strictly speaking, head works on anything that is Foldable.
18:20:14 <kraeXen> > head [1,2,3,"abc"]
18:20:16 <lambdabot>  error:
18:20:16 <lambdabot>      ‚Ä¢ No instance for (Num [Char]) arising from the literal ‚Äò1‚Äô
18:20:16 <lambdabot>      ‚Ä¢ In the expression: 1
18:20:33 * kraeXen shrugs
18:20:55 <dminuoso> kraeXen: Well we can't have such a list to begin with
18:20:57 <kraeXen> I can use list comprehension here, but any time that the list length needs to change, I need to modify the list comprehension too
18:21:10 <dminuoso> What do you mean? How can you use a list comprehension in this case?
18:22:28 <kraeXen> I do control the list (errr, tuple) length, but I intend for this to be modded by the end user (I'm making a themable xmonad config)
18:22:37 <kraeXen> and really, I just want something general
18:23:01 <dminuoso> kraeXen: Hold on, do you mean something like `head (1,2,3,4,"abc")` ?
18:23:07 <kraeXen> yes
18:23:36 <dminuoso> Oh we can do that
18:23:39 <dminuoso> hold on
18:24:03 <kraeXen> looks like my python background held me back here...
18:24:25 <kraeXen> in python the only difference between a list and tuple is one is constant and the other is mutable
18:25:33 <dminuoso> % (1,2,3,4,"abc") ^? _1
18:25:33 <yahb> dminuoso: Just 1
18:25:51 <dminuoso> Well actually
18:25:53 <dminuoso> % (1,2,3,4,"abc") ^. _1
18:25:53 <yahb> dminuoso: 1
18:26:03 <kraeXen> why '_'?
18:26:12 <dminuoso> kraeXen: _1 is an binding
18:26:17 <dminuoso> % :t _1
18:26:17 <yahb> dminuoso: (Field1 s t a b, Functor f) => (a -> f b) -> s -> f t
18:26:41 <kraeXen> any binding for all except _1 (tail equivalent)
18:27:08 <dminuoso> I mean this is a very elaborate way of just using typeclasses for the essence of it
18:27:31 <dminuoso> lens, the library in question, has instances for Field1 up to Field19, giving rise of _1 through _19
18:29:28 <dminuoso> kraeXen: But yeah, tuples and lists are very much different things in haskell.
18:35:43 <kraeXen> couldn't find anything similar to tail in lens...
18:37:43 <kraeXen> ah well
18:39:08 <kraeXen> funny that I got better help for xmonad stuff inside the haskell channel then inside the xmonad one
18:39:13 <kraeXen> it's dead silent over there
18:39:34 <dminuoso> Well, xmonad is just a haskell library. :)
18:56:45 <dansho> does random-fu work with System.Random generators or naw?
19:00:21 <dminuoso> dansho: https://hackage.haskell.org/package/random-fu check its dependencies
19:03:47 <dansho> dminuoso, ok well there is a dependency on random but s <- Data.Random.sample Data.Random.StdNormal System.Random.randomIO :: IO [Double] doesnt work and i can't find any example of how to use it
19:05:05 <dminuoso> dansho: How many arguments does sample take?
19:07:34 <dansho> oh duh =D
19:09:59 <dminuoso> dansho: Anyhow. random-fu can work with any random number generator you like.
19:11:42 <dminuoso> For IO, it comes with a default implementation using System.Random,getStdRandom
19:11:52 <dminuoso> https://hackage.haskell.org/package/random-source-0.3.0.11/docs/src/Data.Random.Source.IO.html#line-14
19:12:09 <dminuoso> (well it depends on the OS)
19:12:42 <dminuoso> on windows it appears to pick devurandom..
19:13:04 <dminuoso> Err hah. On linux
19:13:55 <dminuoso> dansho: There's that. So if you want a safe entropy source for just IO, you have to newtype IO and provide your own instance.
20:00:21 <dansho_> how do i get a list of samples from sampleState?
20:01:24 <Axman6> what is sampleState?
20:01:47 * Axman6 scrolls up
20:02:32 <dansho_> https://hackage.haskell.org/package/random-fu-0.2.7.7/docs/Data-Random.html#v:sampleState
20:03:23 <dansho_> i got this but its kind of ugly: https://hastebin.com/usoyaxilac.hs
20:05:06 <dminuoso> dansho_: runState (replicateM 10 (State (sampleState d)) i ?
20:07:35 <dminuoso> haha actually
20:07:40 <dminuoso> that's double treachery
20:08:01 <dminuoso> dansho_: Just do: runState (replicate 10 (sample d))
20:08:20 <dminuoso> err replicateM
20:18:47 <dansho_> what library is runState from?
20:19:02 <dminuoso> transformers
20:23:50 * hackage sak 0.1.3.0 - Compression command-line tool  https://hackage.haskell.org/package/sak-0.1.3.0 (vmchale)
20:28:04 <dansho_> nice ;) let (sample', _) = runState (replicateM 10 (sample StdNormal)) gen :: ([Double], StdGen)
20:28:10 <dansho_> now to figure out how it works
20:28:23 <dminuoso> Oh if you dont want th enew state
20:28:25 <dminuoso> you can also use
20:28:33 <dminuoso> execState
20:28:38 <dminuoso> Saves you the pattern matching on the tuple :)
20:28:58 <dminuoso> no wait heh evalState
20:29:01 <dminuoso> Keep mixing them up :)
21:09:30 <kraeXen> dminuoso: what exactly does the backtick symbol in haskell mean?
21:09:47 <kraeXen> I've seen it used a few times before, but I'm generally confused about it's meaning
21:09:53 <dminuoso> It allows you to use a function as an infix operator
21:10:19 <dminuoso> c.f. wrapping an operator in parens allows you to use it in infix position
21:10:41 <dminuoso> % 1 `add` 2
21:10:41 <yahb> dminuoso: 3
21:10:45 <dminuoso> % ((+)) 1 2
21:10:45 <yahb> dminuoso: 3
21:10:50 <dminuoso> % 1 + 2
21:10:50 <yahb> dminuoso: 3
21:10:53 <dminuoso> % add 1 2
21:10:54 <yahb> dminuoso: 3
21:13:00 <kraeXen> so what you did there with "abc" `isInfixOf` lay ... was essentially isInfixOf "abc" (lay ...)?
21:13:04 <dminuoso> Right
21:13:15 <dminuoso> I have a tendency to always use some operators in infix position for readability.
21:13:21 <kraeXen> for sure
21:13:21 <dminuoso> isInfixOf is one of these
21:15:36 <kraeXen> that sort of converts an function into an operator, right?
21:15:59 <glguy> more specifically a variable into one
21:16:37 <glguy> in case you see it in the wild note that the ` doesn't have to touch the variable it's modifying
21:16:43 <glguy> > 10 ` div  ` 5
21:16:45 <lambdabot>  2
21:17:16 <kraeXen> wow, haskell is a really weird, but also really neat language
21:17:24 <glguy> but it doesn't work on an arbitrary function expression; you can't write: 10 `f x` 5
21:17:53 <kraeXen> it has to have 2 arguments, like operators I'm assuming
21:18:48 <glguy> Yes, unless you enable the PostfixOperators extension
21:18:55 <glguy> % :set -XPostfixOperators
21:18:56 <yahb> glguy: 
21:19:07 <glguy> % let inc x = x + 1 in (10 `inc`)
21:19:07 <yahb> glguy: 11
21:19:09 <dminuoso> kraeXen: No, it does not.
21:19:14 <dminuoso>  f :: Int -> Int -> Int -> Int; f = undefined
21:19:17 <dminuoso> % :t 3 `f` 3
21:19:17 <yahb> dminuoso: Int -> Int
21:19:28 <glguy> yeah, 2 /or more/ usually, unless the extension
21:20:03 <dminuoso> Lets see what the haskell report has to say on backticks
21:20:50 <glguy> Syntactically you can have fewer arguments, but then you'll get a type error next
21:21:35 <dminuoso> Ah well anyhow
21:21:48 <dminuoso> kraeXen: Strictly speaking, every function in Haskell takes only one argument.
21:22:36 <kraeXen> then what would "eg a b c = a * b * c" be called?
21:22:41 <dminuoso> With that notion, it's easy to pretend that `f` takes any of 1, 2 or 3 arguments. :)
21:23:13 <dminuoso> kraeXen: You can think of that meaning `eq = \a -> \b -> \c -> a * b * c`
21:23:18 <glguy> kraeXen: That would be a "function definition" defining the variable eg to have type Num a => a -> a -> a -> a
21:23:47 <dminuoso> kraeXen: The important bit here is to understand how -> associates
21:23:57 <dminuoso> f :: Int -> (Int -> (Int -> Int))
21:24:04 <dminuoso> This makes it more obvious. The parens are completely redundant
21:24:15 <dminuoso> But that's how it associates
21:24:17 <kraeXen> hm
21:24:59 <kraeXen> seems like that's to allow for more complex actions to be taken with less syntactical sugar
21:25:06 <dminuoso> And equivalently, functoin application associates the other way around. Such that `f 1 2 3` actually means `(((f 1) 2) 3`, there by "applying to one argument at a time, get the resulting function, then apply it again, get the resulting function, then apply it to the third argument"
21:25:31 <dminuoso> Which is why "not applying all arguments" gives you a function taking the remaining arguments. :)
21:26:10 <kraeXen> OH
21:26:12 <kraeXen> brilliant
21:26:20 <kraeXen> > (add 1) 2
21:26:21 <lambdabot>  error:
21:26:22 <lambdabot>      ‚Ä¢ Variable not in scope: add :: Integer -> Integer -> t
21:26:22 <lambdabot>      ‚Ä¢ Perhaps you meant one of these:
21:26:24 <kraeXen> frick
21:26:35 <dminuoso> % add x y = x + y
21:26:35 <yahb> dminuoso: 
21:26:40 <dminuoso> % (add 1) 2
21:26:40 <yahb> dminuoso: 3
21:27:01 <kraeXen> okay, user error, here, like the concept though!
21:27:18 <kraeXen> that could make for some very neat things
21:28:12 <dminuoso> With that in mind, we can think of `add` as taking 2 arguments conceptually, or as taking one argument and returning another function. The latter is strictly more correct, but the first is often more helpful to think of
21:28:27 <dminuoso> It's best to get used to switching between these mind models depending on your need. :)
21:47:20 <iqubic> I think currying is a very fundamental concept in Haskell.
21:54:12 <asdnksndkjasndyu> @hoogle [a] -> [a]
21:54:13 <lambdabot> Prelude tail :: [a] -> [a]
21:54:13 <lambdabot> Prelude init :: [a] -> [a]
21:54:13 <lambdabot> Prelude reverse :: [a] -> [a]
21:54:35 <asdnksndkjasndyu> @pl \xs n -> take n xs ==> flip take
21:54:35 <lambdabot> flip flip (flip take) . ((==>) .) . flip take
21:55:02 <asdnksndkjasndyu> @pl \xs n -> take n xs
21:55:02 <lambdabot> flip take
22:58:39 <dminuoso> iqubic: Haskell has no currying.
22:58:47 <iqubic> Really?
22:58:59 <dminuoso> The notion of "currying" only makes sense when you have multi argument functions to begin with.
22:59:06 <dminuoso> But we don't, in Haskell.
22:59:26 <iqubic> I see.
22:59:26 <dminuoso> It's a convention
23:00:26 <iqubic> :t curry
23:00:28 <lambdabot> ((a, b) -> c) -> a -> b -> c
23:00:33 <iqubic> :t uncurry
23:00:34 <dminuoso> That thing is misleadingly named.
23:00:34 <lambdabot> (a -> b -> c) -> (a, b) -> c
23:00:44 <dminuoso> `f (v, c) = ...` takes precisely one argument
23:00:54 <iqubic> I know.
23:01:14 <dminuoso> In the grand scheme of things, its not terribly relevant, but `curry` does not curry a function. :)
23:02:01 <dminuoso> Unless, we consider currying the general act of turning an n-arity function into a chain of function returning functions, then turning a 1-arity function into a 1-arity function could be considered trivial currying.
23:02:17 <dminuoso> But I dont think this leads anywhere useful.
23:27:20 * hackage wai-app-static 3.1.7.2 - WAI application for static serving  https://hackage.haskell.org/package/wai-app-static-3.1.7.2 (MichaelSnoyman)
23:43:47 <hyiltiz> My ~/.ghci http://ix.io/2u7c is fully loaded (:pretty is defined) when I start ghci at ~, ~/Documents/ etc. (directories not managed by stack), but under ~/haskell-project/, :pretty is undefined even tho ghci says it loaded ~/.ghci file. Did I have to define the imports used in ~/.ghci in a project config file as well?
23:53:37 <newhoggy> I'm looking for a way to write property tests that ensure `show` instances produces legitimate Haskell code.
23:54:56 <newhoggy> I tried using `hint`, which boots up an interpreter.  Aside from being slow, it is a fairly brittle approach because some build systems like `nix` mangle the paths so much that the interpreter can't find the source code anymore.
23:57:54 <newhoggy> I'm interested in this because sometimes `Show` instances are hand written and `read . show === id` is insufficient to ensure correctness because the `Read` instance may also be wrong.  Also sometimes people use `deriving Show` for types where they have chosen to not export constructor, so code produced by the `Show` instance actually doesn't work.
