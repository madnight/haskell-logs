00:04:40 <hyiltiz> Wanna to learn a straming library; pipes, conduit, streaming, streamly etc. Any idea which one to learn?
00:05:10 <hyiltiz> I guess the answer might be: depends on what u wanna do; if so, could u specify the `case depends of`?
00:05:34 <hyiltiz> I see streamly is concurrent
00:05:38 <MarcelineVQ> pipes or coniduit are fine options with many tutorials
00:06:17 <MarcelineVQ> streamly is cool and comes with a good tutorials streaming is cool and powerful but might take a bit to wrap your (my) head around
00:07:02 <MarcelineVQ> *tutorials.
00:18:31 <hyiltiz> streamly's impressive benchmarks and marketing-like remarks is really attracting me
00:18:50 <hyiltiz> But I've lived mostly in [a] so far
00:20:33 <hyiltiz> Why does https://github.com/composewell/streaming-benchmarks memory benchmark omits "streaming" lib.?
01:26:25 <dminuoso> hyiltiz: streamly gives you the biggest bang for bucks.
01:38:59 <dminuoso> Given `data Foo f = Foo { f1 :: Int, f2 :: f Char }`, is there a way to have a deriving generated Show instance (with some `Show1 f` constraint of course)?
01:50:32 <dibblego> dminuoso: like this? deriving instance Show1 f => Show (Foo f)
01:51:00 <dibblego> https://wiki.haskell.org/GHC/Stand-alone_deriving_declarations
02:01:18 <hyiltiz> dminuoso: read thru conduit pipes and dtreamly main page documentation and (official) tutorials (yeah they are quite long). Didn't like the high pitched marketing tone of streamly as it feels like they are selling fake drugs. Conduit seem quite simple. Liked Pipes. For small [a] (less than 10,000) I might still just use [a]. 
02:02:57 <hyiltiz> Also didn't live Streamly wrap IO in their Serial type; do we really need a monad bigger than IO?!
02:03:17 <hyiltiz> s/live/like
02:04:31 <tomsmeding> hyiltiz: what timezone are you even in
02:06:05 <merijn> hyiltiz: I find conduit's API simpler than Streamly too, tbh
02:06:09 <hyiltiz> A timeline where I should've been in bed 8h ago...
02:06:18 <hyiltiz> timezone
02:06:38 <merijn> hyiltiz: For all the benchmark wankery about streamly being faster, it doesn't actually matter if your stream is IO bound anyway :p
02:06:51 <tomsmeding> that explains :p
02:07:00 <merijn> Like, 95% of the time I'm streaming data from: 1) a disk, 2) a socket, or 3) a database
02:07:04 <hyiltiz> Streamly seems hacked while conduit and pipes seem designed. Didn't read streaming so can't say
02:07:20 <merijn> In all cases the IO overhead is so high that the "overhead" of conduit is just measurement noise
02:08:05 <merijn> Like, conduit doesn't even take up more than 0.1% of my runtime profiling. So suppose streamly is 10x faster or something, it's literally not going to matter
02:08:39 <hyiltiz> Hmm thx that really puts into perspective
02:09:04 <hyiltiz> What software are you taking about as "my"?
02:11:19 <hyiltiz> Oh I did read streaming first; it's type signature threw me off; conduit has much better types
02:13:59 <merijn> hyiltiz: the biggest thing I'm using it for is a pipeline where I do a bunch of aggregation on rows streamed from an SQLite database. Of the 20-30s it takes to run, something like 80% is just the database and for the remainder basically everything is my code that's called from conduit
02:21:38 <hyiltiz> Can conduit be recurrent, either natively (direct support from the library) it via things like  STM? I'd suppose it may speed up the SQLite reads?
02:21:58 <hyiltiz> Or diskIO read is the bottleneck 
02:22:57 <merijn> The real bottleneck is my shitty schema, tbh :p
02:24:37 <merijn> Bad schema design and complicated joins on tables with 16 million rows does not make for high performance :p
02:27:32 <hyiltiz> Lol sure; thx for the story
02:28:27 <hyiltiz> I'll tuck away streamly  for at least 2y and focus on pipes or conduit; they both seem quite nice. Can't make up my mind.
02:28:41 <merijn> hyiltiz: conduit and pipes are really more for sequential pipelines, so you can't really parallelise them, but you can easily just run the same conduit in multiple threads if you have independent jobs
02:29:08 <merijn> hyiltiz: Conduit is probably the most practical of the two, on account of having more libraries/packages using it/supporting it
02:43:30 <hyiltiz> Thx; I did notice pretty much anything I install grubs conduit as well
02:45:39 <hyiltiz> The two different quite a lot in still it seems so it may not be very convenient to migrate midway. Better just go with the flow or better test POC with both first it seems
02:45:57 <hyiltiz> different/differed
03:03:58 <tomsmeding> hyiltiz: early morning sunrise?
04:08:49 * hackage servant-lucid 0.9.0.2 - Servant support for lucid  https://hackage.haskell.org/package/servant-lucid-0.9.0.2 (DavidJohnson)
04:41:25 <mananamenos> hi, what does `!` mean in here `envLog :: !(String -> IO ())`?
04:43:35 <int-e> mananamenos: is that a (strict) record field?
04:47:24 <int-e> If you have  data Foo = Foo { unFoo :: !Bar } then when you construct a Foo value, the unFoo field will be forced (the data constructor is strict in the corresponding argument); for example, Foo { unFoo = undefined } will be bottom.
04:47:30 <mananamenos> int-e, i dont know. It's from this blog post, https://www.fpcomplete.com/blog/2017/06/readert-design-pattern/
04:48:06 <mananamenos> the snippet only has {-# LANGUAGE FlexibleContexts #-} enabled so i dont know how to search for this `!` and what it could mean in that snippet
04:48:10 <int-e> mananamenos: data Env = Env { envLog :: ..., ... } declares a record.
04:48:41 <int-e> So yes, this is a strict record field.
04:49:24 <mananamenos> thank, i'll look to read about that then
04:49:42 <int-e> The flexible contexts are irrelevant. I don't even see where in the code they're needed, but maybe they pop up in an inferred type.
04:53:20 <int-e> This is standard Haskell 2010 btw. https://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-680004.2 (note the optional exclamation marks) It's called a strictness flag there.
04:55:02 <int-e> And Haskell98 as well. I wasn't sure.
05:39:19 * hackage hie-bios 0.6.3 - Set up a GHC API session  https://hackage.haskell.org/package/hie-bios-0.6.3 (fendor)
06:47:18 * hackage http-client 0.7.2.1 - An HTTP client engine  https://hackage.haskell.org/package/http-client-0.7.2.1 (MichaelSnoyman)
06:53:19 * hackage safe-exceptions 0.1.7.1 - Safe, consistent, and easy exception handling  https://hackage.haskell.org/package/safe-exceptions-0.1.7.1 (MichaelSnoyman)
07:00:19 * hackage pantry 0.5.1.2 - Content addressable Haskell package management  https://hackage.haskell.org/package/pantry-0.5.1.2 (MichaelSnoyman)
07:01:43 <nitrix> Is there an ML language that doesn't use garbage collection?
07:06:15 <justsomeguy> nitrix: http://www.ats-lang.org , but it's a rather weird language
07:07:28 <justsomeguy> This video is a nice overview ... https://www.youtube.com/watch?v=zt0OQb1DBko
07:09:39 <dminuoso> hyiltiz: If you like list like, then streaming might also be of interest to you.
07:09:46 <dminuoso> It has a beautifully simple interface.
07:11:58 <merijn> justsomeguy: ATS isn't an ML language, is it?
07:12:53 <justsomeguy> merijn: It's based off of dependent ML. It's kind of a strange mix between an ML and an imperative language with very strong typing. At least that's my impression of it.
07:14:19 <dminuoso> hyiltiz: That is, the actual package called `streaming`
07:16:45 <dminuoso> dibblego: That doesn't really help, by the way. 
07:16:54 <dminuoso> % data Foo f = Foo { field :: f Int }
07:16:54 <yahb> dminuoso: 
07:16:59 <dminuoso> % deriving instance Show1 f => Show (Foo f)
07:16:59 <yahb> dminuoso: ; <interactive>:10:1: error:; * Could not deduce (Show (f Int)) arising from a use of `showsPrec'; from the context: Show1 f bound by the instance declaration at <interactive>:10:1-41; * In the first argument of `(.)', namely `(showsPrec 0 b1)'; In the second argument of `(.)', namely `((.) (showsPrec 0 b1) (showString "}"))'; In the second argument of `(.)', namely `((.) (show
07:17:12 <dminuoso> The deriving Show mechanism doesn't know about Show1. :(
07:21:36 <dminuoso> Mmm, there ought to be some hackery way of turning `Show1 f` into `Show (f Int)` using constraints magic.
07:29:10 <chisui> hey, I'm searching for a video from a Haskell usergroup (I think) where bounded meet semilatices (or something along these lines) are used to create a system of equations that automatically recalculate when one variable changes. Does anyone by chance have a link to it? I think is was on youtube and was linked to on r/haskell in the last year.
07:33:27 <dminuoso> chisui: Try haskell cafe for sure. 
07:34:27 <dolio> chisui: https://www.youtube.com/watch?v=DyPzPeOPgUE
07:34:32 <dolio> Was it that?
07:36:01 <chisui> @dolio It wasn't that exact video but propagators is the thing I was searching for. The video wasn't by Edward. Thanks, I think I'll manage from here.
07:36:02 <lambdabot> Unknown command, try @list
07:36:14 <dolio> Okay. Good luck.
07:48:32 <ang_> hello
07:48:34 <ang_> https://gist.github.com/angvillar/b0ae47a49c7b4f2a7d4e1d3ea14b6bbb
07:48:54 <ang_> why i not get [15,3]
07:49:09 <ang_> i got []
07:49:19 * hackage souffle-haskell 2.0.0 - Souffle Datalog bindings for Haskell  https://hackage.haskell.org/package/souffle-haskell-2.0.0 (luc_tielen)
07:54:30 <monochrom> "twoNumberSum _ (x:[]) _ = []" is chosen.
07:54:47 <monochrom> err sorry, no
07:55:03 <ang_> dont know if this is the best way to do this
07:58:14 <nut> test
07:58:36 <monochrom> Oh I guess I was right afterall. That line I said is chosen near the end.
07:59:19 * hackage servant-reflex 0.3.5 - servant API generator for reflex apps  https://hackage.haskell.org/package/servant-reflex-0.3.5 (imalsogreg)
07:59:55 <ang_> oh yes you right
08:02:26 <mniip> new saying
08:02:40 <mniip> an indexed monad is just a category enriched over endofunctors
08:02:57 <monochrom> haha
08:03:50 <ang_> so i must delete
08:03:51 <ang_> twoNumberSum _ (x:[]) _ = []
08:04:00 <ang_> seems to work now
08:05:26 <mniip> this is true because you have a morphism of endofunctors id_I : 1 -> M I I, and a morphism of endofunctors (.)_IJK : M I J (x) M J K -> M I K
08:11:36 <cheater> hi
08:11:57 <cheater> is there a quick way to derive Show for an ADT but make it not try to derive it for functions, just show something like <function> ?
08:48:07 <sm[m]> I think you'll have to write the instance cheater
08:48:36 <sm[m]> unless instance Show (a -> a) where show = const "<function>" works..
08:49:45 <cheater> i want the other fields to be shown normally though
08:50:04 <cheater> the ADT contains multiple fields, one of them is a function
08:50:45 <sm[m]> yes, if you write the instance you'd just "show" each of the other fields
08:51:24 <ski> rather `showsPrec' than `show'
08:52:13 <sm[m]> and yes, you can make a Show instance for functions using FlexibleInstances
08:53:16 <ski> (why `FlexibleInstances' ?)
08:53:35 <sm[m]> ski, well because GHCI told me to ?
08:53:58 <sm[m]> "Illegal instance declaration for ‘Show (a -> a)’  (All instance types must be of the form (T a1 ... an) blah blah"
08:54:33 <monochrom> Consider a->b instead :)
08:54:43 <sm[m]> oops yes
08:55:13 <sm[m]> that works better
08:55:33 <sm[m]> I was messing with showsPrec yesterday. That stuff totally confuses me
08:55:54 <sm[m]> eg why is there a magic precedence 10 involved in the showing ?
08:56:05 <ski> the precedence parameter tells the precedence of the surrounding context
08:56:25 <monochrom> 10 is the artificial level for function application
08:56:38 <sm[m]> why are both of those things helpful ?
08:56:45 <ski> you use it like `showsPrec p (...) = showParen (p > 5) $ ...' e.g., if `5' is the precedence of the construct you're showing
08:57:05 <ski> which both ?
08:57:23 <monochrom> You need precedence because there are infix data constructors. data Complex a = a :+ a
08:57:34 <sm[m]> knowing the precedence of the surrounding context. I guess that helps you know whether to show things parenthesised
08:57:48 <monochrom> That ruins everything. Now you have to worry when to add parentheses and when not to.
08:58:26 <ski> also if you're showing numbers, you should commonly use `showsPrec', in order to show properly, in case it's negative
08:58:43 <sm[m]> if only the doc, like, explained some of this in plain language
08:58:48 <ski> you want to display `Just (-5)' as that, not as `Just -5'
08:58:54 <monochrom> A good learning experience is to try redesigning the Show class your way and see how well you accomodate these infix and parenthesizing issues.
08:59:23 <ski> so you have `showsPrec p (Just x) = showsPrec (p > 10) $ showString "Just " . showsPrec 11 x'
08:59:33 <sm[m]> I'm certain it's very well designed.. just needs a little more explanation for users
08:59:54 <monochrom> I think the doc is already in plain language. What you need is sample code.
09:00:48 <c_wraith> doesn't it already have sample code, too?
09:01:02 <sm[m]> at https://hackage.haskell.org/package/base-4.14.0.0/docs/Prelude.html#v:showsPrec , it doesn't explain why precedence is useful, I think
09:01:21 * sm[m] reads harder
09:01:38 <monochrom> No, it doesn't.
09:02:24 <monochrom> Because it's common knowledge that Just -5 and x :*: y :+: z have issues.
09:03:17 <sm[m]> https://hackage.haskell.org/package/base-4.14.0.0/docs/Prelude.html#t:Show kind of does, but it's in detailed technical language that an outsider will not grok at all easily. Needs an end-user summary
09:03:39 <c_wraith> that's what I use as a template whenever I have to write a Show instance by hand.
09:05:32 * sm[m] lights the Uniaika bat signal and hopes for the best
09:06:09 <Uniaika> 'TIS I!
09:06:36 <Uniaika> The caretake of the forsaken scrolls of Haskell
09:07:44 <sm[m]> hooray!
09:08:53 <ski> i think i read old `Show' and `Read' instances, in Hugs, long ago, to get a better feel for how it worked
09:09:05 <Uniaika> sm[m]: if you have the bandwidth, can you open an issue on GHC's gitlab? Otherwise I can do it but I'll have to interrogat you to precisely get what needs to be written and solved
09:10:17 <sm[m]> I don't, but would this be enough: add to showsPrec haddock, "This helps decide whether to show the value in parentheses."
09:11:18 <sm[m]> I mean: add to haddock for showsPrec's Int argument: "This helps decide whether to show the value in parentheses."
09:11:36 <ski> "the representation will be enclosed in parentheses if the precedence of the top-level constructor in x is less than d (associativity is ignored). Thus, if d is 0 then the result is never surrounded in parentheses; if d is 11 it is always surrounded in parentheses, unless it is an atomic expression."
09:12:17 <dolio> Copy all the text from Show into showsPrec, because people can't scroll up.
09:13:02 <monochrom> dolio++
09:13:12 <monochrom> At some point it becomes spoon-feeding.
09:13:30 <monochrom> This is a reference manual, not a textbook.
09:14:23 <sm[m]> I'm an example of someone who's bounced off this doc for years, I'm sure I'm not alone. Which means it could be better
09:14:55 <Uniaika> (Honestly I'm quite relieved we're having this discussion because showsPrec was always mysterious to me)
09:15:01 <sm[m]> there's no other place where showsPrec will be explained, this is it
09:16:48 * ski commonly attempts to enlighten people regarding it, when seeing `Show' misused ..
09:17:48 <monochrom> The Haskell School of Expression explains it in detail.
09:18:45 <sm[m]> which function actually adds parentheses ? showsPrec, or some other ?
09:18:48 <Uniaika> sm[m]: care to remind me your nickname on the GHC gitlab?
09:19:31 <Uniaika> sm[m]: it's showParen
09:19:48 <Uniaika> on line 353
09:19:51 <ski> you compare the precedence parameter to the precedence of the construct you're showing -- if former is greater than latter, you add brackets. for arbitrary parts that you show, you pass the construct precedence as parameter, incremented by one ..
09:20:08 <monochrom> And The Haskell School of Expression book probably stole it from A Gentle Introduction to Haskell. Probably because same author.
09:20:17 <sm[m]> thanks. Is adding parentheses the only use of this parameter, or are there others ?
09:20:24 <monochrom> https://www.haskell.org/tutorial/stdclasses.html
09:20:33 <ski> .. except that for `infixl' you don't need to increment the context precedence of the left operand, and for `infixr' you don't need to increment it for the right operand
09:20:40 <sm[m]> Uniaika: simonmic I think
09:20:59 <Uniaika> perfect
09:21:02 <ski> sm[m] : and for `readsPrec', you use `readParen' simialarly
09:22:18 <monochrom> Frankly I was lost about showsPrec too when I was beginning, but I understood it and went on to write my own after the Gentle Introduction explanation.
09:22:27 <sm[m]> monochrom: good find, there's a much easier to read doc in there. Uniaika is it common/acceptable for haddocks to include links to such external docs ?
09:22:46 <ski> sm[m] : only one, afaiaao
09:23:01 <monochrom> People now disown the Gentle Introduction. This is a disease.
09:23:01 <sm[m]> "The showsPrec and readsPrec methods are parameterized versions of shows and reads. The extra parameter is a precedence level, used to properly parenthesize expressions containing infix constructors. For types such as Tree, the precedence can be ignored."
09:24:17 <ski> ah, i consider that a bad `Show' instance :)
09:26:06 <ski> (if it said "If you always bracket (non-atomic) inputs, the precedence can be ignored.", that would be fine)
09:26:07 <dolio> That's actually wrong. You can't ignore it unless all your constructors are atomic
09:26:39 <ski> you can, if you use `showParen True $ ...', or equivalent
09:26:53 <dolio> Yeah, I guess you could put parentheses around everything.
09:27:43 <dolio> That has nothing to do with the form of the data type, though.
09:28:35 <ski> well, the gentle intro is referring to the specific `Show' instance they did before, for `Tree'
09:29:04 <ski> and it does always bracket (non-leaf) trees
09:29:46 <dolio> The quoted text says, "types such as Tree".
09:30:19 <ski> yea. at least that's how i interpret the intension behind that statement
09:30:47 <ski> (otherwise i don't see how it'd make any sense at all)
09:30:53 <dolio> It's only referring to types whose show instances were given previously in the book?
09:31:09 <Uniaika> Uniaika is it common/acceptable for haddocks to include links to such external docs ? // no :/
09:31:12 <Uniaika> sm[m]: ^
09:31:25 <Uniaika> one reason is that the docs pretty much live forever
09:31:52 <ski> (my beef with it is that it's not emitting valid Haskell .. and, separately, that it's not properly bracketing the arbitrary values that could be in the leaves, i suppose)
09:32:13 <Uniaika> A pattern I'd rather make more official would be to redirect to the Haskell, where edition cycles are more frequent and where we can allow ourselves to occasionally have dead links
09:32:41 <Uniaika> but this requires the Haskell Wiki Top Sikrit Organisation to achieve their plans to have a better Wiki
09:32:46 <sm[m]> I suppose inlining a bit of text is better then.
09:33:11 <Uniaika> sm[m]: did you see the MR, btw?
09:33:19 <dolio> The text in the current docs already has a Tree type that has an infix constructor to demonstrate using precedence.
09:35:33 <sm[m]> Uniaika: not yet, I will look later. Thanks for doing that
09:37:17 <ski> dolio : (just read most of the preceding text, on showing.) it still, seems to me the intension of "types such as Tree" was, types whose shown representation is chosen to be atomic. maybe there could be another reasonable interpretation. any suggestion ?
09:39:40 * ski misses hawiki
09:40:29 <dolio> I would imagine it means types with only prefix constructors. That is a property of the type (declaration) not a property of how you choose to write the Show instance.
09:42:03 <ski> but then it still only holds if you choose to always bracket (non-atomic) values
09:42:17 <dolio> Yeah, I agreed the text was wrong. :)
09:42:55 <Uniaika> sm[m]: I live to serve. 
09:43:18 <Uniaika> and also, now that the MR is open, you can move the discussion to https://gitlab.haskell.org/ghc/ghc/-/merge_requests/3909
09:43:21 <Uniaika> <3 <3
09:43:34 <ski> (the "always bracket" leading back to what i said. but perhaps this is simply an oversight, the author not thinking about it enough)
09:44:16 <dolio> Oh, I guess it's worse than that. Maybe it means types where you have some automatically bracketed nonsense notation for the Show instance. :)
09:44:31 <dolio> Now that I'm actually reading the showsTree function.
09:45:06 <ski> (see "my beef with it .." :)
09:45:21 <dolio> Yeah, I don't think the docs should link to this at all.
09:46:02 <dolio> It would just encourage the tendency to try to do pretty printing in Show instances.
09:46:27 <dolio> Which is the opposite of how it's described in the current docs.
09:46:32 <ski> yea :(
09:46:49 <monochrom> Ah damn.
09:46:58 <c_wraith> I wonder if there's room for some additional showsPrec helpers to simplify some of the patterns.  Probably not room in the Prelude namespace.
09:47:37 <ski> i'd really prefer it, if things like `StdGen', and the exception types, didn't abuse `Show', in this way, either
09:47:55 <dolio> StdGen complies now, I think.
09:48:07 <ski> > mkStdGen 1234
09:48:09 <lambdabot>  1235 1
09:48:36 <c_wraith> eh.  Show is debugging output.  I don't care when it isn't Haskell code, because I don't use it for anything other than debugging.
09:48:43 <ski> dolio : hm, news to me. happy to hear that
09:48:45 <monochrom> I think that only "showParenLMCIFY m n x = if m<n then showParen x else x" is missing.
09:48:56 <dolio> Yeah lambdabot's version is old.
09:50:01 <ski> `Show' instances are meant to work together
09:50:28 <dolio> I guess the compliant one might only be a couple months old.
09:50:36 <ski> it's confusing, imho, to get a mixture of Haskell and non-Haskell output
09:55:14 <ski> > MkPair DivideByZero DivideByZero
09:55:16 <lambdabot>  MkPair divide by zero divide by zero
10:03:35 <dolio> Yeah, I work on something that has some custom written partially 'pretty' instances, and it just makes debugging output harder to read.
10:13:30 <tomsmeding> in the past I sometimes made "pretty" Show instances too, and I came to regret it
10:14:04 <tomsmeding> now I just use standard Show instances, or at least ones that play wel with surrounding Show's, and delegate prettiness to a custom Pretty class á la Show
10:14:34 <tomsmeding> with some boilerplate (instance Pretty Int where pretty = show, etc.) it works fine
10:15:19 * hackage HsOpenSSL-x509-system 0.1.0.4 - Use the system's native CA certificate store with HsOpenSSL  https://hackage.haskell.org/package/HsOpenSSL-x509-system-0.1.0.4 (MariosTitas)
10:15:37 <ski> there are reasonable cases in which to define one's own `Show' (and `Read') instances
10:15:52 <ski> e.g. abstract data types
10:17:16 <ski> > listArray ((2,2),(3,3)) [i ^ j | (i,j) <- range ((2,2),(3,3))]
10:17:18 <lambdabot>  array ((2,2),(3,3)) [((2,2),4),((2,3),8),((3,2),9),((3,3),27)]
10:18:44 <dolio> Yeah, the custom written part isn't the problem, it's the 'pretty' part.
10:19:02 <dolio> At least, if the custom part is correctly written.
10:39:19 * hackage haskell-src-match 0.0.0.1 - Testing code generators piece by piece.  https://hackage.haskell.org/package/haskell-src-match-0.0.0.1 (MichalGajda)
10:57:59 <Uniaika> sm[m]: <3
11:13:31 <dminuoso> 18:23:55             ski | ah, i consider that a bad `Show' instance :)
11:13:44 <cheater> hi
11:13:51 <dminuoso> Sadly there's no clear guidance, ski.
11:14:19 <cheater> can someone tell me what cabal v2-exec is for? the manual page isn't very useful on that
11:14:21 <ski> yea. only indirect
11:14:22 <dminuoso> Aside from deriving generated Show instances, the Haskell Report has very little to say about whether or not a given Show instance is right or wrong, good or bad..
11:14:41 <ski> yes
11:14:52 <dminuoso> cheater: consider: `cp $(cabal v2-exec -- which yourExec) ...`
11:14:57 <maerwald> cheater: it adds stuff to PATH
11:15:20 <dminuoso> That's a way of extracing build artifacts. Lately I've switched to cabal-plan though for some reasons.
11:17:00 <cheater> you'll have to start a bit earlier on for me, i don't understand either answer :-)
11:18:07 <dminuoso> Lets say you want to extract the binary to ship it to another machine.
11:18:35 <dminuoso> `cabal v2-build` does not place the build artifacts into the current directory, they are kept somewhere deep inside the dist-newstyle/ directory instead.
11:19:08 <maerwald> just read `cabal v2-exec --help`
11:35:36 <[rg]> do haskell programmers care about design by contract? or does one work it out with types?
11:36:33 <ski> preconditions and postconditions have their place
11:36:36 <cheater> dminuoso: that's part of the context i needed. thanks.
11:36:42 <cheater> maerwald: will do, i forgot that's a thing
11:37:21 <dminuoso> [rg]: Well, types can give rise to contracts.
11:37:34 <[rg]> can I get an example?
11:38:39 <cheater> [rg]: for me, type classes are contracts.
11:38:45 <dminuoso> [rg]: As a simple example, you can use phantom types
11:39:07 <dminuoso> Then you have automated proofs (executed by the compiler) that the contracts are satisfied.
11:39:17 <[rg]> makes sense
11:39:41 <[rg]> only missing part is documentation I guess
11:40:01 <sm[m]> some contracts can be expressed with types, others can be noted in the haddock, LiquidHaskell is a GHC alternative that checks more powerful contracts
11:40:08 <cheater> yeah make sure to include some
11:40:12 <dminuoso> I think mostly, design by contract is especially popular in mutation heavy code.
11:40:26 <dminuoso> Seems to be a more imperative thing
11:41:13 * ski . o O ( dependent Haskell )
11:41:45 <[rg]> wow liquid haskell looks cool
11:41:59 <Uniaika> [rg]: it is!
11:42:39 <dminuoso> [rg]: But indeed like ski pointed out, dependent types open up a universe of automatically verified contracts.
11:43:00 <dminuoso> Consider the trivial case of `Vec n a`, denoting a vector of some values a of some length n.
11:43:58 <dminuoso> If I had some kind of `map :: (Vec n a -> Vec n b) -> ...` then the caller could not possibly resize the vector. That's a provable contract.
11:50:24 <sm[m]> s/GHC alternative/GHC plugin/
11:55:45 <maerwald> liquid haskell is cool, because it's opt-in and can be completely ignored if you want
11:56:14 <maerwald> (and as such... doesn't really change API)
11:56:35 <maerwald> (which cannot be said about dependent types)
12:04:39 <dminuoso> Illegal nested constraint ‘Show (CEnumTy a)’ (Use UndecidableInstances to permit this)
12:04:45 <dminuoso> CEnumTy is a tyfam, why am I getting this error?
12:09:05 <glguy> dminuoso: That error indicates that you violated the conservative safeguards that ensure resolving constraints will terminate. You can turn off that check with the given extension
12:10:49 * hackage dataflower 0.2.3.0 - A Pure-Haskell Timely Dataflow System  https://hackage.haskell.org/package/dataflower-0.2.3.0 (jessekempf)
12:11:22 <dminuoso> glguy: If CEnumTy was a type constructor I'd understand. Or is the point that the tyfam could produce something "larger" than `Show (CBitmask a)`?
12:16:41 <glguy> It could produce something larger, yes
12:18:41 <glguy> Turning off the check if you promising that it won't
12:19:04 <glguy> With a sledgehammer since it's for the whole module
12:19:30 <dminuoso> I suppose I cant get around that for my use csae
12:19:43 <dminuoso> Unless I intend to write out all the possible instances manually
12:44:21 <frdg> > foldr (<>) ["foo","bar","baz"] mempty
12:44:23 <lambdabot>  ["foo","bar","baz"]
12:44:45 <frdg> why does this not return "foobarbaz"?
12:44:58 <merijn> frdg: because you messed up the argument order
12:45:10 <merijn> frdg: You are using the list as zero element and the empty list as input
12:45:21 <merijn> > foldr (<>) True mempty
12:45:23 <lambdabot>  error:
12:45:23 <lambdabot>      • No instance for (Semigroup Bool) arising from a use of ‘<>’
12:45:23 <lambdabot>      • In the first argument of ‘foldr’, namely ‘(<>)’
12:45:25 <frdg> ohh ok
12:45:29 <merijn> > foldr (||) True mempty
12:45:31 <lambdabot>  True
12:46:31 <frdg> yes I see. I wouldnt have even considered that you could do this. could be useful.
12:49:36 <frdg> I see why the arguments would be in that order for partial application.
12:52:19 <sleblanc> :t foldr
12:52:20 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
12:57:13 <ADG1089> pointfree concatMap
12:57:38 <ADG1089> @pl concatMap
12:57:38 <lambdabot> (=<<)
12:57:55 <ADG1089> @pl concatMap (unLoc . snd) $ mapMaybe (ideclHiding . unLoc) decls 
12:57:55 <lambdabot> unLoc . snd =<< mapMaybe (ideclHiding . unLoc) decls
12:58:02 <ADG1089> hmmm
13:01:01 <coot> frdg: the first argument of `foldr` corresponds to `:` construtor and the second one to `[]` (when folding a list).
13:11:48 * hackage generic-match 0.1.0.0 - For when first class pattern matches are needed  https://hackage.haskell.org/package/generic-match-0.1.0.0 (sgschlesinger)
13:16:02 <koz_> 'UndecidableInstances' is a bit of a scary name.
13:16:32 <merijn>  koz_: Despite being fairly harmless :p
13:16:56 <koz_> merijn: Yeah, the Paterson conditions are _very_ conservative.
13:23:31 <JackTheEngineer> hello, i am trying to compile gtk3 with stack, and and with gi-pango i get the error https://pastebin.com/amneTPGi . I don't understand the gobject binding generation in such a detail, as to be able to tweak it. I have tried searching for the code for gi-pango, but it's just a call to generate bindings. What seems to me the most weird is the '--' (double hyphen only) which should be a comment, follwed by a type declaration ? W
13:23:31 <JackTheEngineer> an autogenerated code throw parse error ? 
13:25:38 <maerwald> JackTheEngineer: what's the project
13:26:27 <JackTheEngineer> would you like to clone it from github ? It's currently locally on my machine :) 
13:33:11 <pounce> why is `MonadPlus` the nondeterminism monad? because <|> could just "choose" one or the other?
13:33:35 <c_wraith> MonadPlus is an interface to a lot of different things.
13:33:48 <c_wraith> There's no guarantee it's nondeterminism
13:35:21 <dminuoso> Will newAlignedPinnedByteArray# (the primitive behind alloca) give me a guaranteed zero'd memory? Or do I have to memset it to 0 myself?
13:38:18 <JackTheEngineer> maerwald: https://github.com/JackTheEngineer/BaseStation That's the project
13:39:53 <tomsmeding> JackTheEngineer: /urlselect 
13:40:01 <tomsmeding> (sorry that's the umpteenth time)
13:40:08 <JackTheEngineer> https://github.com/JackTheEngineer/BaseStation
13:40:26 <tomsmeding> (no you did nothing wrong I failed)
13:41:14 <JackTheEngineer> maerwald: one commit earlier, and with version stackage lts-14.(27?) the haskell gi-code worked.
13:41:21 <maerwald> JackTheEngineer: I'll give it a try
13:41:34 <JackTheEngineer> That's very kind of you, thank you !
13:42:45 <JackTheEngineer> for correctness, its stackage lts-14.17
14:19:57 <maerwald> JackTheEngineer: https://github.com/JackTheEngineer/BaseStation/pull/1/files
14:20:02 <maerwald> works here :p
14:21:19 * hackage gltf-codec 0.1.0.1 - glTF scene loader  https://hackage.haskell.org/package/gltf-codec-0.1.0.1 (AlexanderBondarenko)
14:25:16 <JackTheEngineer> shoot... what could be the reason for a parse error ?
14:25:48 <maerwald> parse error?
14:25:59 <JackTheEngineer> maerwald: thank you for cross checking ! 
14:26:13 <JackTheEngineer> So it seems to be something on my machine ..
14:26:36 <maerwald> I don't know what you are doing
14:26:49 * hackage ktx-codec 0.0.1.0 - Khronos texture format  https://hackage.haskell.org/package/ktx-codec-0.0.1.0 (AlexanderBondarenko)
14:27:05 <JackTheEngineer> running 'stack build' in the commandline
14:27:30 <maerwald> JackTheEngineer: so you merged the PR without trying it? :p
14:27:41 <JackTheEngineer> with stack Version 2.3.3, Git revision cb44d51bed48b723a5deb08c3348c0b3ccfc437e x86_64 hpack-0.33.0
14:28:37 <maerwald> JackTheEngineer: well... what I did is this: 1. remove stack, 2. switch to cabal, 3. freeze index state to make build reproducible, 4. fix plot: https://github.com/amcphail/plot/pull/21
14:28:38 <JackTheEngineer> eeh, yeah. :D It's not the 'professional' way. What would be the right procedure to test your branch ?
14:29:42 <maerwald> I remember that gi-gtk had issues with stack, so I didn't bother trying to fix that
14:32:04 <JackTheEngineer> It's good to know that stack has issues with gi-gtk. Thank you for that. 
14:33:20 <JackTheEngineer> In terms of professional procedure for testing your branch: would it be correct to clone your repo first, test wether it's working, and then merge the pull request into my branch ? ( and then locally delete your repo, to not trash fill my disk )
14:33:57 <maerwald> 1. merge, 2. ship, 3. wait for bug reports 
14:33:59 <maerwald> :p
14:34:25 <JackTheEngineer> xD
14:34:54 <maerwald> I opened the PR as a discussion... but if you want to give cabal a shot, then yeah
14:36:58 <JackTheEngineer> Allright.
14:36:58 <JackTheEngineer>  
14:38:26 <maerwald> But it works
14:42:34 <JackTheEngineer> maerwald : how did you "fix the index state" to make the build reproducible ?
14:44:06 <JackTheEngineer> maerwald: and I assume that it's not necessary to remove stack from my system, and that i just can keep on working in the same stack project, without the need to remove anything. 
14:50:05 <cheater> JackTheEngineer: he said freeze. i don't know how to use it, but try googling for cabal freeze.
15:07:45 <hyiltiz> I'd like to write Xonix (the game) for the 80x80 terminal (ideally with a single small compiled binary in the end which can be invoked within emacs and the like)
15:07:53 <hyiltiz> Which libraries should I look into?
15:10:06 <hyiltiz> The Debian package Xonix (written in C) claims to be able to run in text mode too, but its C macros were too complicated I never managed to compile it without its X11 dependencies
15:13:47 <hyiltiz> cat xonic.h xonix.c = http://ix.io/2v3a
15:23:09 <hyiltiz> So may as well practice some haskell with it
15:26:00 <Rembane> hyiltiz: Brick is a library for interfacing with ncurses, it's quite good for that kind of things. 
15:30:45 <hyiltiz> Nice! Saw a few games/apps using it; seem pretty nice, thx!
15:36:18 * hackage persistent-mongoDB 2.10.0.1 - Backend for the persistent library using mongoDB.  https://hackage.haskell.org/package/persistent-mongoDB-2.10.0.1 (MaxGabriel)
15:45:23 <TheCommieDuck> Hey. I have a phantom type data Foo a = Foo Int. I can box it, data Boxed where Box :: Foo a -> Boxed..but can I not somehow construct an unboxing function unbox :: Boxed -> ???? a -> Maybe (Foo a)?
15:47:08 <c_wraith> You cannot recover the original type that was put in.
15:47:19 <c_wraith> The Box constructor just doesn't store it anywhere.
15:47:48 <koz_> TheCommieDuck: That's why it's called a 'phantom type parameter'.
15:47:55 <koz_> There's no 'real' value of said type.
15:48:26 <TheCommieDuck> yeah, that makes sense. I was just hoping for some way to have a list where I can ignore the phantom type parameter when needed but also query for it. 
15:48:46 <TheCommieDuck> but given type erasure I guess no.
15:48:57 <cheater> no, you're looking for (a, b)
15:49:03 <koz_> TheCommieDuck: You wanna ask for the _type_? Or a value of said type?
15:49:10 <koz_> Those are slightly different requests.
15:49:18 <TheCommieDuck> the type, I think.
15:49:28 <koz_> TheCommieDuck: What do you plan to do with it?
15:50:08 <pounce> oh hm, so if i want backtracking and _global_ state, I need a backtracking transformer applied to the state monad, right?
15:50:31 <koz_> pounce: The other way around is also possible.
15:50:35 <koz_> They mean different things.
15:50:43 <pounce> I tried doing something like `stateT S []` but this only gave me "local state"
15:50:51 <koz_> (namely, are you nondeterministic in _both_ the state and the result, or only the result?)
15:50:55 <c_wraith> Do you mean "modified by branches that have been backtracked out of" by "global"?
15:51:02 <TheCommieDuck> specifically I have data Foo (a :: [k]) and a type-level Contains type family, so I can get compile time typeknowledge like knownType :: (Contains' k Text ~ True) => Foo k, and I know that 'Text \in k.
15:51:02 <pounce> c_wraith: yes
15:51:51 <pounce> koz_: yes this, I want to be nondeterministic in the result, but not in the state. every time I backtrack I want the state to continue to be sequenced though
15:52:19 <koz_> @unmtl StateT s Vector a
15:52:19 <lambdabot> s -> Vector (a, s)
15:52:27 <koz_> @unmtl ListT (State s) a
15:52:27 <lambdabot> s -> ([] a, s)
15:52:37 <koz_> @unmtl StateT s [] a
15:52:37 <lambdabot> s -> [] (a, s)
15:52:46 <koz_> See the difference?
15:52:50 <koz_> (ignore the first one)
15:52:51 <pounce> I read that ListT is not really a monad transformer though
15:52:59 <koz_> pounce: It's not a good idea.
15:53:12 <koz_> If you want nondeterminism and backtracking, LogicT is a better choice by far.
15:53:21 <koz_> But the idea is the same.
15:53:28 <pounce> I'm writing my own right now with difference lists + CPS, but I'm still thinking about how to make it into a transformer
15:53:40 <koz_> pounce: LogicT not to your liking?
15:53:55 <pounce> mostly trying to learn :) let me look at LogicT some more
15:54:10 <pounce> this is not for anything "professional" just a coding challenge and I wanted to figure out how to make it myself
15:54:15 <koz_> Basically, if you have {List,Logic}T on the outside, you're nondeterministic in results, but not states. If you have StateT on the outside, you're nondeterministic in _both_.
15:54:42 <koz_> Those mean rather different things.
15:54:56 <pounce> yes definitely
15:56:08 <koz_> I'd recommend reading the LogicT paper honestly - it explains how to write CPSed nondeterminism quite well.
15:57:04 <pounce> oh! do you have a link to that somewhere?
15:57:09 <pounce> I might just drop the difference lists if so
15:57:23 <koz_> http://okmij.org/ftp/papers/LogicT.pdf
15:58:58 <pounce> thank you I will read this... and perhaps not implement it myself :P
16:00:23 <koz_> It's not super difficult - it has a few tricky details - but if you need a canned solution, LogicT is the way.
16:01:36 <pounce> I was really just hoping to write myself a branch&bound search, using some backtracking for branch and global state to hold bounds.. I think that would work for it
16:02:07 <koz_> Yeah, just use LogicT and State.
16:02:32 <koz_> It's a pretty straightforward stack to work in, and does what you want.
16:26:49 * hackage aura 3.1.8 - A secure package manager for Arch Linux and the AUR.  https://hackage.haskell.org/package/aura-3.1.8 (fosskers)
16:55:48 <hyiltiz> `g xs y f = f y : xs` can I rewrite g as a recursive function (it would be pedantic or dumb way to do it)?
16:57:20 <hyiltiz> I was trying to make an argument saying every / most(?) functions can be turned into a (maybe trivial / degenerative) recursive function, but not the other way around.
17:00:10 <ski>   g xs y f = fst (f y : xs,g xs y f)
17:00:52 <ski> (fairly useless, yes)
17:03:12 <ski> pounce : perhaps "Monads, a Field Guide" by dpiponi in 2006-10-21 at <http://blog.sigfpe.com/2006/10/monads-field-guide.html> could be fun/useful
17:04:20 <hyiltiz> thx
17:04:27 <monochrom> A rectangle does not require width/=height; a square is a rectangle too.
17:04:44 <d34df00d> Hi!
17:05:16 <monochrom> A circle does not require radius>0; a point is a circle too.
17:05:56 <monochrom> Likewise, we can say "recursive function" even when the function doesn't call anything.
17:06:52 <hyiltiz> I used "likewise" in my argument, using the analogy that positive integers can represent (countably infinitely) many things but they cannot represent real numbers, but real numbers can represent positive integers.
17:07:20 <hyiltiz> They called my "analogy" a bluff as it doesn't apply to functions and learning that happens "in the real world" and "in the brain"
17:07:27 * ski . o O ( people being siblings doesn't require them being distinct )
17:07:36 <monochrom> But I am not sure that it is productive to argue either way.
17:07:44 <monochrom> Actually, I am sure it is not productive.
17:08:10 <monochrom> Instead, it is more useful to express every function in terms of fix.  fix f = f (fix f)
17:08:17 <triteraflops> What is there in the way of coroutines in haskell?
17:08:22 <hyiltiz> monochrom reminds hyiltiz of the argument clinic
17:09:12 <ski> triteraflops : what kind of coroutines do you want ?
17:09:16 <hyiltiz> I was thinking of Y too, but I am sure they'd shake it off saying it is just a computer scientist's (ehm, mathematicians) construct
17:10:32 <triteraflops> ski: If I were to design them, it would be a Monad resembling IO, but with a concrete type. Actions would be like channel reading and writing, and sleeping
17:11:11 <triteraflops> When the action is passed to an event loop, it is executed.
17:11:11 <ski> hm, so you want to do I/O, on the side, while communicating back and forth ?
17:12:10 <triteraflops> It's just what I happen to need, but really, any pausable action should work
17:12:45 <triteraflops> channels seem like a general enough way of implementing pausable actions
17:13:40 <dolio> Real numbers don't support all the operataions that integers do, so they're a pretty bad representation.
17:13:55 <triteraflops> In regular programming terms, it's just a way of maintaining several execution stacks and allowing parallel waiting
17:14:16 <Guest_57> Hi I need help downloading haskell 
17:14:28 <triteraflops> The several execution stacks argument is a little tenuous in haskell, but the parallel waiting still applies
17:15:12 * ski . o O ( "A Poor Man's Concurrency Monad" (Functional Pearl) by Koen Claessen in 1999-01 at <http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.39.8039> )
17:16:04 <monochrom> I simply use threads.
17:16:28 <triteraflops> There may be thousands of these paused functions
17:17:02 <monochrom> In practice, thousands of threads are still fine.
17:17:35 <triteraflops> What about context switching delay?
17:17:44 <monochrom> This is because, by default, GHC compiles threads to cooroutines, not OS threads.
17:18:03 <triteraflops> oh, well, that's good to know lol
17:18:20 <monochrom> Err, more accurate to say: GHC runtime system runs threads as cooroutines.
17:18:42 <triteraflops> Does it keep a thread pool proportional to the number of processors?
17:19:00 <monochrom> For 99% of algorithms, coding as thread is infinitely more comprehensible than handcoding event loop and cooroutines.
17:19:07 <triteraflops> I'm expecting pretty extreme performance constraints. 
17:19:15 <monochrom> Yes.
17:19:31 <triteraflops> Well, that was easy lol
17:19:59 <xsperry> triteraflops see this https://stackoverflow.com/questions/5847642/haskell-lightweight-threads-overhead-and-use-on-multicores
17:21:25 <triteraflops> wth is a spark...
17:24:23 <monochrom> Err s/infinitely/10-100 times/ in the case of Haskell, or generally if the language has first-class continuations or first-class higher-order functions (so you can CPS).
17:25:10 <monochrom> Still, 99% of the time, threading style is 10-100 times more comprehensible than continuation style.
17:25:29 <monochrom> If the language is C, it's truely infinitely.
17:26:04 <monochrom> It is also why Hoare invented CSP and called it CSP.
17:26:32 <triteraflops> so I see CPS and CSP. Which is it?
17:26:47 <dolio> They are two different things.
17:27:15 <triteraflops> oh. Usually when that happens it's a typo lol
17:27:32 <monochrom> Communicating sequential processes.  You want concurrency, but you only want a limited form.  You still want sequential programming.
17:27:59 <monochrom> It is very telling that this model of concurrency has no "concurrent" wording in it.
17:28:06 <monochrom> Only sequential and communicating.
17:29:25 <monochrom> You have a few thread. Which thread is sequential because the logic is most straightforward that way. And then you let these threads run concurrently, and once in a while they exchange messages or they synchronize --- communicating.
17:29:26 <ski> (CPS is Continuation-Passing Style)
17:30:51 <monochrom> darn, too many typos.
17:31:01 <monochrom> s/a few thread/a few threads/
17:31:08 <monochrom> s/Which thread/Each thread/
19:34:48 * hackage generic-match 0.2.0.0 - First class pattern matching  https://hackage.haskell.org/package/generic-match-0.2.0.0 (sgschlesinger)
20:19:19 <AdrianoII> Hello, could someone, please, help me understand this fold: foldr (\ x acc -> [x] : (map ((:) x) acc)) []
20:19:24 <AdrianoII> I started to studying haskell recently and I am having problems to visualize how this fold work's
20:19:35 <AdrianoII> It is a fold to generate a list of prefixes
20:21:19 * hackage generic-match 0.2.0.1 - First class pattern matching  https://hackage.haskell.org/package/generic-match-0.2.0.1 (sgschlesinger)
20:21:20 <hyiltiz> % foldr (\ x acc -> [x] : (map ((:) x) acc)) [] ("Hello" :: [Char])
20:21:21 <yahb> hyiltiz: ["H","He","Hel","Hell","Hello"]
20:23:34 <hyiltiz> :t (\ x acc -> [x] : (map ((:) x) acc))
20:23:35 <lambdabot> a -> [[a]] -> [[a]]
20:23:37 <hyiltiz> :t foldr
20:23:38 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
20:24:18 <hyiltiz> t a is [a], b is [[a]]
20:24:41 <hyiltiz> So u just have to understand that lambda to understand that foldr
20:25:07 <int-e> > let foo (x:xs) = let acc = foo xs in [x] : (map ((:) x) acc); foo [] = [] in foo "Hello"
20:25:09 <lambdabot>  ["H","He","Hel","Hell","Hello"]
20:25:28 <int-e> (that's the same thing without foldr)
20:27:42 <AdrianoII> I am trying to do a step by step evaluation, but i think i need to read more about
20:28:15 <AdrianoII> I don't see how the map part works
20:30:01 <hyiltiz> % ((:) 'H') "ello"
20:30:01 <yahb> hyiltiz: "Hello"
20:30:07 <hyiltiz> map ((:) 'H') ["ello"]
20:30:12 <hyiltiz> % map ((:) 'H') ["ello"]
20:30:12 <yahb> hyiltiz: ["Hello"]
20:31:11 <hyiltiz> and foldr does the resursive traversing using that lambda
20:32:28 <AdrianoII> % map ((:) 1) [2,3]
20:32:29 <yahb> AdrianoII: ; <interactive>:17:1: error:; * No instance for (Num [Integer]) arising from a use of `it'; * In the first argument of `print', namely `it'; In a stmt of an interactive GHCi command: print it
20:34:20 <hyiltiz> % map ((:) 1) [[2,3]]
20:34:20 <yahb> hyiltiz: [[1,2,3]]
20:34:55 <AdrianoII> Ohhhhhh, i get it now
20:35:07 <hyiltiz> :t \x acc -> (map ((:) x) acc)
20:35:07 <AdrianoII> Thanks :D
20:35:08 <lambdabot> a -> [[a]] -> [[a]]
20:36:05 <hyiltiz> in vague terms, foldr folds over a list of elements that are themselves lists that map gets to map (:) over
20:39:53 <la-jesystani> howdy, whats good practice for authentication on a json api? im using yesod
20:40:31 <hyiltiz> int-e: how did u translate foldr into a nested let expressions? Do you use some code formatter other than your grey matter?
20:43:57 <hyiltiz> I am guessing you extract from the Core...
20:46:23 <ski> @type map . (:)
20:46:25 <lambdabot> a -> [[a]] -> [[a]]
20:48:39 <int-e> hyiltiz: I did it manually
20:50:10 <int-e> hyiltiz: the inner let is just a good way to preserve the 'acc' name for the result of the recursive call.
21:22:43 <redmp> closed type families are a lot easier to work with than assotiated type families...
21:24:08 <dibblego> hyiltiz: https://www.youtube.com/watch?v=GPwtT31zKRY
21:25:46 <hyiltiz> thx! but did u meant to call Adrianoll?
21:26:04 <dibblego> er yes, sorry
21:42:48 * hackage lz4-frame-conduit 0.1.0.0 - Conduit implementing the official LZ4 frame streaming format  https://hackage.haskell.org/package/lz4-frame-conduit-0.1.0.0 (NiklasHambuechen)
22:03:26 <hyiltiz> Oh my I love this sentence: equivalence is equivalent to equality
22:07:42 <hyiltiz> Does https://arxiv.org/abs/0903.0340 relevant to Langlands program to anyone? (I just read David Frenkel's Math&Love; dont know the actual topic except in that pop sci book)
22:23:54 <redmp> what's it called when you define a closed-type-family that doesn't cover all the cases?
22:24:52 <redmp> @let type family Head xs where Head (a:as) = a
22:24:54 <lambdabot>  Defined.
22:25:51 <redmp> this "works" in a way that the value-level wont.. the value-level will crash your program, but at the type level you just get a weird type
22:27:06 <redmp> @:type Head ["foo", "bar"]
22:27:07 <lambdabot> error:
22:27:07 <lambdabot>     • Data constructor not in scope: Head :: [[Char]] -> t
22:27:07 <lambdabot>     • Perhaps you meant one of these:
22:27:19 <redmp> @:kind Head ["foo", "bar"]
22:27:20 <lambdabot> Symbol
22:27:36 <redmp> >:kind! Head ["foo", "bar"]
22:28:04 <redmp> ok, i give up .. anyway, at the value level this is just a partial function but at the type level it does something else and i'm trying to learn more about that
22:52:18 <Axman6> @kind Head ["foo", "bar"]
22:52:19 <lambdabot> Symbol
22:52:25 <Axman6> @kind! Head ["foo", "bar"]
22:52:26 <lambdabot> Symbol
22:52:41 <Axman6> @kind Head []
22:52:42 <lambdabot> error:
22:52:42 <lambdabot>     • Expecting one more argument to ‘[]’
22:52:42 <lambdabot>       Expected kind ‘[k0]’, but ‘[]’ has kind ‘* -> *’
22:52:49 <Axman6> @kind Head '[]
22:52:50 <lambdabot> k
22:58:42 <koz_> Yes, Head '[] has a kind. :P
22:59:06 <koz_> @kind! Head '[]
22:59:08 <lambdabot> k
22:59:11 <koz_> :(
23:01:59 <redmp> yeah, we found out yesterday that lambdabot doesn't seem to understand :kind! the same way as ghci
23:02:37 <redmp> (i tried again today because i'm an idiot)
23:05:16 <phadej> % :kind! 2 + 2
23:05:16 <yahb> phadej: ; <interactive>:1:3: error: Not in scope: type constructor or class `+'
23:05:20 <phadej> % :kind! []
23:05:20 <yahb> phadej: * -> *; = []
23:05:30 <phadej> use yahb
23:05:45 <phadej> lambdabot is not GHCi
23:06:37 <redmp> % type family Head xs where Head (a:as) = a
23:06:37 <MarcelineVQ> it has PolyKinds enabled I expect, if you see that again sometime then you have it enabled too :>
23:06:37 <yahb> redmp: 
23:07:11 <redmp> % :kind! Head '["symA", "symB"]
23:07:11 <yahb> redmp: GHC.Types.Symbol; = "symA"
23:07:17 <redmp> % :kind! Head '[]
23:07:17 <yahb> redmp: k; = Head '[]
23:07:27 <redmp> cool,ok, that's the behavior i'm talking about^
23:07:52 <redmp> it just returns an unevaluated type function, instead of a type error or something
23:08:15 <redmp> does that behavior have a name? is this something that's required for a type system? it seems very odd
23:09:12 <redmp> oh, interestingly, the thing returned "Head '[]" is of polymorphic kind
23:09:49 * hackage dataflower 0.3.0.0 - A Pure-Haskell Timely Dataflow System  https://hackage.haskell.org/package/dataflower-0.3.0.0 (jessekempf)
23:12:29 <phadej> if you want type-error, you should define it (with TypeError from GHC.TypeLits)
23:13:10 <redmp> phadej: no, i'm actually just interested in the the behavior itself; i want to understand how i can use it
23:13:50 <redmp> ie. if I define a partial-type-function and then assert type-equality to an expected result, i can effectively rule out the not-defined cases simply because the result is non-equal
23:14:15 <phadej> you cannot
23:14:34 <phadej> I mean, Head '[] is not equal to Int
23:14:54 <redmp> sorry, i meant: i can effectively rule out the defined cases because the result is non equal
23:15:15 <redmp> because Head '[]' is not equal to Int
23:15:55 <phadej> the problem is that you cannot "check" for type equality :)
23:16:24 <redmp> Data.Type.Equality defines a couple of ways.. and Data.Type.Bool defines an If that uses Equality.==
23:17:00 <redmp> % :kind! If (Head ["foo"] == "foo") Int Char
23:17:00 <yahb> redmp: ; <interactive>:1:1: error:; Not in scope: type constructor or class `If'; Perhaps you meant one of these: `IO' (imported from Prelude), `Ix' (imported from Data.Array); <interactive>:1:18: error: Not in scope: type constructor or class `=='
23:17:10 <phadej> % :kind! Data.Type.Bool.If (Head '[] Data.Type.Equality.== Int) "foo" "bar"
23:17:11 <yahb> phadej: GHC.Types.Symbol; = Data.Type.Bool.If (Head '[] Data.Type.Equality.== Int) "foo" "bar"
23:17:14 <phadej> it's stuck
23:17:23 <phadej> bacause if-scrutinee is stuck
23:17:32 <redmp> OH cool
23:17:43 <phadej> one could argue that should work if Head is closed type family
23:17:50 <phadej> but it definitely cannot work if Head is open type family
23:18:02 <phadej> (because someone might add Head '[] = ... equation)
23:18:04 <redmp> Sooooo, if you have one of these incomplete type-evaluations, you can't examine it?
23:18:20 <redmp> % :kind (Head '[]) == Int
23:18:20 <yahb> redmp: ; <interactive>:1:12: error: Not in scope: type constructor or class `=='
23:18:25 <phadej> https://kcsongor.github.io/report-stuck-families/
23:18:27 <redmp> % :kind (Head '[]) Data.Type.Equality.== Int
23:18:27 <yahb> redmp: Bool
23:18:32 <redmp> % :kind! (Head '[]) Data.Type.Equality.== Int
23:18:32 <yahb> redmp: Bool; = Head '[] Data.Type.Equality.== Int
23:18:42 <redmp> oh weird
23:19:03 <phadej> i.e. not really.
23:19:22 <phadej> there's difference between "equality" and "decidable equality"
23:21:10 <mniip> the story with haskell is even more complicated
23:21:17 <mniip> cause types might have type variables in them
23:21:30 <mniip> you're actually equating presheaves over a context
23:22:13 <Putonlalla> Should I feel bad for not knowing what presheaves are?
23:22:24 <mniip> no
23:22:33 <Putonlalla> I'm going to feel bad anyway.
23:22:44 <mniip> I hardly know what presheaves are
23:26:08 <redmp> % :kind! (Head a) Data.Type.Equality.== (Head a)
23:26:08 <yahb> redmp: ; <interactive>:1:7: error: Not in scope: type variable `a'; <interactive>:1:38: error: Not in scope: type variable `a'
23:26:24 <redmp> % type Foo a = (Head a) Data.Type.Equality.== (Head a)
23:26:24 <yahb> redmp: 
23:26:38 <redmp> % :kind! Foo a
23:26:39 <yahb> redmp: ; <interactive>:1:5: error: Not in scope: type variable `a'
23:27:37 <redmp> in the case where type variables are present, it makes sense that it's not decidable
23:28:09 <mniip> oh but it is decidable
23:28:14 <mniip> but not by a type family
23:28:40 <mniip> though hmmm, maybe by a type family too
23:28:43 <mniip> hmm
23:29:18 <redmp> if you have a type `a == b` you can't say whether it's `'True` or `'False` .. right?
23:29:37 <mniip> right because the answer depends on the instantiations of a and b
23:29:53 <redmp> isn't that "not decidable"? or am i conflating terms
23:29:53 <mniip> and "don't know whether True or False" is a valid answer for this question that can be decided by an algorithm
23:30:00 <redmp> ah, ok.
23:30:27 <mniip> the GHC typechecker has a notion of apartness for example
23:31:02 <mniip> if you ask it to unify two terms, it will tell you that either: they unify, yielding a subtitution; they are known to be non-unifiable; or there's not enough info to conclude either
23:31:22 <mniip> in some cases you only care about whether things unify
23:31:29 <mniip> in other cases you only care about whether things are apart
23:32:57 <mniip> right so there's no way to make a type family that would have both (a == b ~ True) => (a ~ b), and (a == a ~ True)
23:40:39 <phadej> some people call that "semi-decision"
23:40:53 <phadej> it's like politicians, answer to "yes/no" question with "maybe"
23:41:40 <redmp> yeah, it's helpful to know that it's a thing .. i still kind of wish that the "stuck" types were comparable
23:41:59 <redmp> anyway, learning that they're not is helpful for me as i try to make this thing work!
23:43:21 <phadej> one way to write type-level programs (type-families) is to write cases as you feed it new examples and see where they are stuck
23:43:34 <phadej> sometimes I wish that would be possible on term level
23:44:07 <redmp> well yeah, i've actually had no proble with closed-type-families .. i'm able to write down pretty much everything i need to
23:44:11 <phadej> i.e. instead of "non-exhaustive pattern match" exception one would get a bit more descriptive "what exactly you try to evaluate" exception
23:44:24 <phadej> and without relying on Show
23:44:27 <redmp> the problems i'm running into related to translating the closed-type-families to type-classes which can do things simultaneously on the value level
23:44:58 <redmp> phadej: you can avoid that problem altogether with -Wall :)
23:45:37 <phadej> redmp: not that. I know that a function I'm writing is partial atm, but I don't yet know what the missing cases should be
23:46:05 <redmp> phadej:  i think -Wall tells you the missing cases
23:46:06 <phadej> thus I would feed it (or rather some other function using helper function I'm working on) inputs 
23:46:21 <phadej> and then figure out what exactyl the missing cases should be
23:47:36 <phadej> foo 'x' = 1; foo catchall = error $ "stuck: foo " ++ show catchall -- but without Show (so works with function arguments, ...)
23:48:05 <phadej> programs which text representation you know are quite boring
23:48:19 <phadej> you know *already* before writing them
