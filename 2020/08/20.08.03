00:01:03 <Axman6> hyiltiz: after looking at the package Cale mentions, you should also benchmark to see if it does actually help
01:15:15 <alehander92> are hash maps popular in haskell?
01:15:46 <alehander92> they do seem very useful in languages like clojure
01:15:51 <alehander92> which are still functional
01:19:38 <dibblego> _awkward_
01:29:11 <dminuoso> alehander92: I'd say they are in extremely widely use. Transitively you can find unordered-containers in most packages dependency tree.
01:29:17 <Arahael> alehander92: Maps are common, yes. I can't remember if they're *hash* maps, though, but why wouldn't they be "popular"?
01:30:02 <alehander92> yeah i am not sure
01:30:10 <alehander92> it seems that mostly tree-based maps are popuilar tho
01:30:18 <alehander92> which don't have the same time complexity
01:30:32 <dminuoso> Like I said. unordered-containers is to be found in every dependency tree. :)
01:30:34 <alehander92> but as I read, it seems this is rarely a problem, because of bigger log base 
01:30:53 <alehander92> and .. because people often don't really use so many elements 
01:32:59 <dminuoso> alehander92: The way containers works, it requires an Ord instance at least. You may not have one for various reasons.
01:33:41 <[exa]> dminuoso: anything hashable has a trivial Ord instance, right?
01:34:21 <dminuoso> [exa]: Sure, but at that point you've paid the hashing price already. Not sure how `containers` fares then.
01:34:40 <[exa]> hash computation isn't really atomic, is it?
01:34:54 <dminuoso> I suppose you have a point, though.
01:35:50 <[exa]> I meant, you can easily take the hash computation and derive an Ord that just finds the first difference
01:36:20 <[exa]> anyway
01:36:25 <dminuoso> http://blog.johantibell.com/2012/03/announcing-unordered-containers-02.html
01:36:34 <dminuoso> For alehander92 :)
01:37:16 <alehander92> awesome, thanks
01:37:24 <alehander92> tho..i need to use also some ordered maps
01:37:38 <dminuoso> Mm, thats comparing against an old version though I think.
01:37:40 <alehander92> but those are good starting points for sure 
01:37:44 <dminuoso> That makes it less useful for tihs discussion
01:38:07 <[exa]> alehander92: I'm usually forcing students to rigorously prove the actual big-O complexity of hashmap operations when they try to use them; most of them are either theoretically impenetrable, or yield something like O(log n / loglog n), which usually comes as a surprise to the student (also look at the huge constant!)
01:38:22 <alehander92> ah, interesting
01:38:34 <alehander92> also, i got another "type design" problem
01:38:40 <alehander92> it's not really haskell-only
01:39:04 <[exa]> alehander92: OTOH if your container doesn't get updated every now and then, the stuff is probably okay. From all these hash structures I really love using bloom filters tbh.
01:40:33 <alehander92> it's a bit more general: basically e.g. in UI i try to separate my model data from the UI data in separate types. Cleaner and this way I can use different layers in my UI theoretically
01:40:33 <alehander92> However this makes it hard to enforce e.g. that I have value for the same key / index in both types etc : i need to somehow make them type-safe together , but i dont want to merge them into one data structure which would make it easier
01:40:48 <dminuoso> alehander92: https://www.slideshare.net/tibbe/faster-persistent-data-structures-through-hashing
01:41:07 <dminuoso> Here's the slides from the author of `unordered-containers` going into the motivations behind hash based maps.
01:41:24 <[exa]> alehander92: it might not solve your problem but did you see immediate-mode GUIs?
01:41:35 <dminuoso> (Note, that this is old. the current unordered-containers uses HAMT I think)
01:41:44 <alehander92> yeah, it's kinda .. similar-ish as I just use Elm in the browser
01:42:51 <alehander92> but i am talking more about : I have `Model` and I want my own `Presentation` which includes e.g. ui info mappable to `Model` elements 
01:43:19 <[exa]> alehander92: store lenses instead of data?
01:43:33 <alehander92> but i want to make that more type-safe : in other languages I'd just sprinkle checks like "is this in Model, is that in Model"
01:44:40 <dminuoso> alehander92: Dont use the same types then.
01:45:28 <dminuoso> i.e. if you have something Int indexed, you could newtype Int twice. This is essentially a provenance problem
01:46:24 <alehander92> dminuoso : what do you mean? `Model` and `Presentation` are different types
01:46:35 <dminuoso> Maybe I dont understand then. This is too handwavy
01:46:38 <alehander92> e.g. Presentation has a color for each value in a list in Model
01:46:52 <alehander92> as a simple non-exactly-real example
01:47:11 <[exa]> alehander92: if I get it correctly, can I reimagine the problem basically as syncing 2 databases?
01:47:24 <alehander92> so Model is a record with elements: [OtherType], and Presentation has elementColors: [String]
01:47:51 <alehander92> [exa]: maybe? like the only thing is I'd just expect to manually write stuff like
01:48:03 <alehander92> `does elements have the same length as elementColors` or
01:48:08 <alehander92> if they are maps
01:48:23 <dminuoso> alehander92: Id try encoding the problem much differently
01:48:32 <alehander92> `does elementColors have a key for this key in elements`
01:48:41 <alehander92> which seems a bit too runtime-y
01:48:43 <[exa]> alehander92: btw can't you pull the UI data right into the Model?
01:49:00 <[exa]> (which is what reactive stuff should do)
01:49:27 <alehander92> [exa]: that's the thing. I can! and this seems simpler .. but it mixes it all up :( and this way what if I decide to add a different kind of UI with different assumptions?
01:49:50 <[exa]> like, with careful stuff like "hasColorInUI :: Maybe Color" or "uiInfo :: Maybe UIInfo" or so
01:49:52 <alehander92> and this way i need to add UI types inside my server data structures
01:50:13 <dminuoso> alehander92: Why would you have to add UI types? It could be just *functions* that calcualte UI things based on data things
01:50:38 <[exa]> alehander92: technically you can add a type parameter that you just declare empty on the server
01:51:16 <alehander92> dminuoso hm. but I want to preserve the UI data inside the data structures : so it's not just pure mappings
01:51:22 <[exa]> dminuoso: the UIs usually store a tiny bit of extra state, like window positions, highlight colors that should not flicker ie be persistent, etc
01:51:25 <alehander92> e.g. i want to preserve if an element is clicked on
01:51:35 <[exa]> dminuoso: which I guess is the main problem
01:51:43 <alehander92> exactly
01:51:50 <dminuoso> [exa]: Well, frp. :)
01:51:58 <[exa]> :]
01:52:29 <[exa]> alehander92: honestly not many people can really claim to solve this sufficiently :]
01:52:54 <[exa]> alehander92: ImGui makes this state "magically saved in background", just as does React and pals
01:53:03 <alehander92> ok, I wanted to know if I am just doing stuff in a very unsafe way :P
01:53:26 <alehander92> yeah, reactive programming is cool
01:53:35 <dminuoso> alehander92: Well, for the immediate problem you are facing, there's type tricks you can do.
01:54:04 <dminuoso> e.g. justified-containers is a package to look at
01:55:36 <alehander92> dminuoso thanks!
01:55:39 <[exa]> alehander92: "fixing" the model and parametrizing it by something that can store UI state is probably simplest way to go (esp. in Elm where I wouldn't expect justified containers to work)
01:56:27 <alehander92> yeah something like "flow typing" from other languages seems similar to me: e.g. maybe i can do a single runtime check that all keys from A == keys from B and later use B based on this prooved
01:56:59 <dminuoso> alehander92: I suppose a problem with your approach is that it's anti-compositional. You start accumulating a global state store that not only contains domain state, but also UI state.
01:57:17 <dminuoso> And then you end up mimicing whatever `react` does, for instance.
01:57:18 <alehander92> but my wish is the opposite: i want to separate both
01:57:40 <alehander92> to just have the domains state in one place and the UI state separate but "sync" some type facts
01:57:51 <alehander92> [exa]: yeah this maybe makes sense
01:58:04 <[exa]> are the facts really "type" facts?
01:58:10 <[exa]> (hint: no)
01:58:41 <alehander92> well, stuff like "those dicts in Domain and Interface have the same keys because Interface keys are constructed from Domain"
01:58:55 <alehander92> something like encoding correct by construction maybe
01:59:09 <alehander92> maps*
01:59:25 <[exa]> anyway "syncing" is really what this is, you have basically a replicated database of keys and properties that you are trying to keep in a consistent state
01:59:51 <[exa]> which brings us to react :]
01:59:57 <alehander92> yes, but I construct each "diff/update" from the first one (which is what you're saying anyway)
02:00:45 <alehander92> yes, and I think this is type-checkable on theory 
02:01:25 <[exa]> so you want to typecheck that, say, the same key operations are getting done on both containers
02:02:22 <alehander92> [exa]: yeah
02:04:15 <[exa]> can you restrict yourself to using a small subset of functions that you can verify manually, which manipulate the state "right"?
02:04:48 <alehander92> probably!
02:04:56 <[exa]> (this is the OOPstyle approach, construct a wrap and add an unbreakable interface)
02:05:01 <alehander92> but in the future I guess this might become harder
02:05:18 <[exa]> yeah OOPstyle approaches don't extend very well... :D
02:06:21 <alehander92> well it works
02:06:31 <alehander92> but i wonder if i can prove that
02:06:45 <alehander92> something more general
02:08:10 <alehander92> that Interface is always "reconstructed" from Domain on each Interface change
02:08:28 <alehander92> and no other calls happen between those two events
02:09:20 <alehander92> if this is theoretically possible, one can assume easily that you can just zip / iterate / etc through both without worry
02:10:59 <alehander92> but maybe just having type parameters and calling manually the logic that manages changes there is good enough
02:11:03 <alehander92> as you said
02:17:46 <alehander92> i realized that all those checks are not really less type safe.. because after all they do prove only valid key combinations work, but they just might leave some more dead code : and dead code might be confusing to read
02:17:59 <alehander92> i wonder if people see dead code as a "bug" in haskell, or not 
02:18:43 <maerwald> that's not a language specific question
02:19:37 <alehander92> well, some languages do report some dead code cases as bugs: and I genuinely don't know if it's considered bad or just ok-ish to have dead code in haskell
02:19:50 <alehander92> errors*(not bugs)
02:20:23 <maerwald> which languages do that?
02:20:46 <alehander92> e.g. in nim if you write `return` and code after (or `break`) it's an error
02:20:59 <Arahael> alehander92: What if it's a whole function that doesn't get used?
02:21:02 <maerwald> that doesn't sound like actual deat code analysis
02:21:03 <alehander92> obviously a very simple case but illustrates the idea that dead code might be undesirable
02:21:08 <Arahael> alehander92: And what if you have that function in order to type check an api?
02:21:23 <alehander92> arahael that's often a warning in other languages
02:21:29 <alehander92> well .. then it is used
02:21:34 <alehander92> it depends on how you define used
02:21:35 <sshine> I'm trying to build a project with cabal in a Dockerfile, and after ~20-25 minutes the build fails. re-running the Dockerfile, the build phase's cache is wiped. so I'd like to split the 'cabal build' into sub-parts so that the initial workload is cached. one step could be 'cabal build --dependencies-only'. another part could be downloading the package dependencies from git. how do I do the last part?
02:21:56 <alehander92> if it's "being part of type checking process" then it is used, if it's "being called" not
02:22:13 <Arahael> alehander92: What's the difference?
02:22:49 <alehander92> arahael your example is the difference: a function might be defined just so a type conforms to some constraint
02:23:33 <Arahael> alehander92: That's... Not how functions work in haskell.
02:23:41 <maerwald> sshine: did you try cabal build --only-configure
02:24:09 <alehander92> arahael eh .. one can define a `>>=` without actually calling it ever
02:24:11 <alehander92> right?
02:25:10 <dminuoso> alehander92: The type checker will type check things whether you use them or not.
02:25:12 <dminuoso> Here's a simple example:
02:25:26 <alehander92> I know: I am talking about something completely different
02:25:27 <dminuoso> % let a :: (); a = 1; in 10
02:25:27 <yahb> dminuoso: ; <interactive>:6:18: error:; * Could not deduce (Num ()) arising from the literal `1'; from the context: Num p bound by the inferred type of it :: Num p => p at <interactive>:6:1-25; * In the expression: 1; In an equation for `a': a = 1; In the expression:; let; a :: (); a = 1; in 10
02:25:37 <dminuoso> Did not use `a`, the type checker complained regardless.
02:26:47 <alehander92> look, my point is about using a function type for typechecking *a different* function 
02:27:00 <alehander92> e.g. you use the fact that there is `>>=` for `A`
02:27:16 <alehander92> in other function that expects an `A` to be a monad
02:28:16 <alehander92> but this is handwavy: sorry for the offtopic, see ya later , thanks !
02:28:22 <sshine> maerwald, I didn't try that, thanks. :)
03:13:50 <typetetris> In Hspec is a spec-item an `it`-thing or a `describe`-thing regarding `before_` and stuff.
03:15:03 <typetetris> ah its a `it`-thing 
03:21:16 <Marked> Hello
03:21:56 <Marked> Is there a way how to use funcion composition and not lambda in this expression? let values = [-4.3, -2.4, -1.2, 0.4, 2.3, 5.9, 10.5, 29.1, 5.3, -2.4, -14.5, 2.9, 2.3] in groupBy (\x y -> (x > 0) == (y > 0)) values
03:22:33 <Marked> Or is lambda cleanest way how to write it?
03:22:41 <phadej> latter
03:22:48 <xsperry> @pl (\x y -> (x > 0) == (y > 0))
03:22:48 <lambdabot> (. (> 0)) . (==) . (> 0)
03:22:49 <solonarv> you can write it without a lambda, but the lambda seems quite clear to me
03:22:50 <MarcelineVQ> defintely the clearest way
03:23:21 <solonarv> cleanest point-free way would be ((==) `on` (>0))
03:23:51 <Marked> Thank you all..
03:24:07 <dminuoso> Marked: If you wait a while, you'll see elobrate tricks pop up.
03:24:26 <solonarv> but I would recommend just keeping the lambda
03:25:05 <phadej> there is 
03:25:07 <phadej> :t comparing
03:25:08 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
03:25:13 <phadej> ought to be equating
03:25:25 <phadej> but that one isn't in base
03:25:37 <phadej> so that would be `equating (> 0)`
03:25:43 <solonarv> oh! another thing you could try is : (\x y -> signum x == signum y)
03:26:02 <solonarv> which behaves a little differently (it will distinguish negative numbers from 0, yours does not)
03:26:05 <phadej> > map signum [-1,0,1]
03:26:07 <lambdabot>  [-1,0,1]
03:26:16 <solonarv> > map signum [-3 .. 3]
03:26:17 <lambdabot>  [-1,-1,-1,0,1,1,1]
03:27:09 <phadej> (also groupBy collects consequtive numbers, which you may noticed, my experience is that is often not what you want to do)
03:27:48 <solonarv> (yes, perhaps you want to sort first)
03:28:01 <solonarv> we are just guessing here, as we don't know what you need this for
03:28:47 <Guest_3> after i copied the link to install Haskell to the terminal, it asked for a password- what am i supposed to do
03:29:27 <xerox_> contact your system administrator
03:30:35 <solonarv> hm, it shouldn't need sudo
03:31:51 <solonarv> quick check: no 'su' or 'sudo' in the script that gets downloaded
04:22:57 <Taio> hello, can someone explain how Haskell processes generic numbers internally?
04:23:17 <Taio> a = 123 is typed as 'a :: Num p => p'
04:23:27 <Taio> How can you explain that? Is the number literal just converted to a whole or floating point number if necessary?
04:23:33 <Taio> e.g.: 'a (2.5 :: Double) →' 125.5 ' as ' Double'
04:23:58 <phadej> :t fromInteger
04:23:59 <lambdabot> Num a => Integer -> a
04:24:18 <phadej> so when you write 123, it means fromInteger 123#
04:24:25 <phadej> where 123# is made up syntax for "raw integers"
04:26:44 <phadej> (there isn't surface syntax for concrete `Integer`s, you have to break abstraction to write them)
04:30:21 <Taio> ok, so whole number literals are automatically put into a "generic" by using fromInteger, in the hope that the integer then fits in double?
04:39:51 <maerwald> solonarv: that can only be the stack installer script, which does invoke sudo
04:41:59 <phadej> > 1111111111111111111111111111111111111111111111111111 :: Float
04:42:01 <lambdabot>  Infinity
04:42:05 <phadej> it always "fits"
04:42:16 <phadej> but yes, fromInteger is often partial
04:42:42 <phadej> > (-1) :: Natural
04:42:44 <lambdabot>  *Exception: Natural: (-)
04:43:12 <phadej> it's a wrat without "everyone satisfying" solution atm
05:09:19 <gentauro> anybody has the link to the comparison of `gmp` (Haskell Integers) between different languages? IIRC, Haskells implemenation did very well
05:15:10 <maerwald> I don't think it did well, at least not ingeter-simple
05:16:09 <gentauro> maerwald: no, it's the wrapper I'm looking for
05:16:28 <gentauro> it was a nice blog post where it compared Haskell "wrapper" to all other languages. It did pretty well :)
05:16:54 <merijn> gentauro: google something like "fastest bigint in the west" :)
05:17:05 <merijn> maerwald: It was comparing the libgmp backend
05:17:22 <merijn> gentauro: http://www.wilfred.me.uk/blog/2014/10/20/the-fastest-bigint-in-the-west/
05:19:23 <gentauro> merijn: that was the link I was looking for :)
05:20:41 * gentauro bookmarking it this time ;)
06:08:49 * hackage unbeliever 0.10.0.6, core-program 0.2.4.4, core-data 0.2.1.7, locators 0.3.0.3, core-text 0.2.3.6, core-program 0.2.4.5, core-data 0.2.1.8 (AndrewCowie)
06:42:04 <phadej> 2014...
07:19:06 <dminuoso> Mmm, ghci in some particular environment fails to load because ghc8.6.5.so complains aboug an undefined symbol: base_DataziTypeableziInternal_sameTypeRep_info
07:19:52 <dminuoso> (Hashes removed for brevity:) <command line>: can't load .so/.DLL for: /home/dminuoso/.cabal/store/ghc-8.6.5/unix-2.7.2.2-.../lib/libHSunix-2.7.2.2-...-ghc8.6.5.so (/home/dminuoso/.cabal/store/ghc-8.6.5/unix-2.7.2.2-.../lib/libHSunix-2.7.2.2-...-ghc8.6.5.so: undefined symbol: base_DataziTypeableziInternal_sameTypeRep_info)
07:44:19 * hackage language-dickinson 1.1.0.2 - A language for generative literature  https://hackage.haskell.org/package/language-dickinson-1.1.0.2 (vmchale)
07:46:30 <Ericson2314> tomjaguarpaw: to continue asking your question for me on the layout ghc proposal, https://github.com/ghc-proposals/ghc-proposals/pull/351 is the most -XNo-iest  proposal I've written yet
07:49:14 <ezzieyguywuf> I have a haskell project that uses the glfw bindings. I can make this compile and run just fine locally, but I tried to do the same in a windows vm and it doesn't appear to be able to find teh glfw dll, even when I place it in the top-level directory of my project. I know I'm doing something wrong, but I don't know what - can anybody point me in the right direction?
07:49:36 <ezzieyguywuf> on a related note: how might I go about packaging a precompiled executable of my program, say as an exe?
07:51:45 <merijn> ezzieyguywuf: What os is "locally?"
07:52:04 <ezzieyguywuf> gentoo linux
07:52:15 <ezzieyguywuf> on which I have the glfw library installed using the gentoo package manager
07:52:36 <merijn> ezzieyguywuf: WeWhich glfw (haskell) package are you using?
07:52:48 <ezzieyguywuf> although, I was able to compile my project *without* the glfw library present, it just failed at runtime
07:52:54 <ezzieyguywuf> glfw-b
07:52:59 <ezzieyguywuf> merijn: ^
07:55:20 <merijn> ezzieyguywuf: ok, so bindings-GLFW (which is used by glfw-b) depends on opengl32 and Gdi32 on windows, but has no way to install them, so presumably one of these two libraries is not installed on Windows
07:57:59 <ezzieyguywuf> merijn: I will check and see if I can find installers for these
07:58:17 <ezzieyguywuf> merijn: how did you determine these library dependencies?
07:59:16 <merijn> Go on hackage, skim the haskell dependencies, click on bindings-GLFW, read through cabal file
07:59:42 <ezzieyguywuf> hrm, I see
07:59:55 <ezzieyguywuf> is this the typical process for finding necessary external library dependencies?
08:00:21 <solonarv> on linux/mac you can also just ask ldd
08:00:29 <solonarv> I don't know if there is a windows equivalent
08:01:22 <sm[m]> Isn't there windows install notes ?
08:01:33 <ezzieyguywuf> solonarv: I just did ldd on my (working) executable in linux, and don't even see glfw listed 😮
08:01:42 <merijn> ezzieyguywuf: cabal should (I think) report missing libraries in the error
08:01:55 <merijn> ezzieyguywuf: Although it might show up simply as missing dependencies or a linker error
08:01:56 <ezzieyguywuf> I *do* see libGL
08:02:14 <ezzieyguywuf> merijn: I did not get any build errors, that's why I'm confused
08:02:29 <merijn> ezzieyguywuf: bindings-glfw seem to build it's own copy of GLFW in some cases
08:02:35 <ezzieyguywuf> it built and linked, and even ran, it just could not initialize glfw (for obvious reasons)
08:02:42 <merijn> ezzieyguywuf: But that glfw will still depend on openGL, obviously
08:02:58 <ezzieyguywuf> merijn: ah hah, nice catch.
08:08:07 <ezzieyguywuf> hrm...does my cabal need to include a similar `extra-libraries` information to bindings-GLFW?
08:08:27 <ezzieyguywuf> or does the implicit dependency on bindings-GLFW take care of this?
08:12:23 <tomjaguarpaw> Ericson2314: thanks!
08:12:50 <ezzieyguywuf> sm[m]: windows install notes...of what
08:12:52 <ezzieyguywuf> ?
08:13:31 <merijn> ezzieyguywuf: Linking is global
08:13:41 <sm[m]> For the packages you're having trouble with
08:14:02 <merijn> ezzieyguywuf: Linkers don't care about dependencies, where things are from, they just deal in "symbols" which are either missing or defined
08:14:28 <merijn> You match up every missing symbol with a defined one, then you're done! (Oversimplification of the day!)
08:14:42 <dminuoso> ghc: can't find a package database at /home/dminuoso/.cabal/store/ghc-8.6.5/package.db
08:14:45 * dminuoso rages at ghc
08:14:53 <dminuoso> Oh
08:14:59 <merijn> dminuoso: Time to nuke ~/.cabal/store :p
08:15:07 <ezzieyguywuf> womp womp
08:15:16 <dminuoso> merijn: No actually, time to nuke ~/.ghc/.../environments/default
08:15:57 <dminuoso> That above error was the result of nuking ~/.cabal/store :p
08:16:03 <dminuoso> Oh yes! All is well now
08:16:12 <dminuoso> Time to learn reflex
08:21:19 * hackage dhall-docs 1.0.0 - Generate HTML docs from a dhall package  https://hackage.haskell.org/package/dhall-docs-1.0.0 (GabrielGonzalez)
08:25:39 <Uniaika> nice package
08:27:22 <dminuoso> Uniaika: And nix people tell me to not raise my hopes of ever getting this for nix..
08:27:24 <dminuoso> It's sad.
08:28:07 <Uniaika> it's a fairly bad mentality yeah
08:28:15 <Uniaika> (but I might be biased :P)
08:53:08 <s4ch1n> hi
08:53:16 <Cheery> hellol
08:53:39 <Cheery> What's the best tool for writing web servers in haskell?
08:53:52 <s4ch1n> actually i don't know 
08:54:20 <s4ch1n> i just started to learn haskell 
08:54:24 <monochrom> "best" is a red herring
08:54:37 <s4ch1n> haskell in 2020 ?
08:54:56 <s4ch1n> anyways I decided to learn 
08:56:04 <Cheery> that was great outcoming.
08:59:36 <Uniaika> Cheery: the one that suits you best ;)
08:59:46 <Uniaika> try Spock, Servant, and Yesod
08:59:56 <Uniaika> and come back to tell us why you picked one over the other
09:04:51 <dminuoso> Cheery: Web servers is an incredibly generic topic.
09:05:32 <dminuoso> Cheery: What kind of tool do you intend to build? Some kind of http api? Maybe an api with both a server and a matching client? Maybe some web server for browser content?
09:05:43 <dminuoso> Furthermore, what kind of features are important to you?
09:06:39 <Cheery> for start, HTTP protocol implementation
09:07:18 <dminuoso> Cheery: The http protocol implementation is, usually, an implementation detail of the web server itself.
09:07:34 <dminuoso> In Haskell WAI is the common protocol for writing web server applications, and warp is a WAI-compatible web server.
09:07:37 <dminuoso> Is that what you are after?
09:08:03 <Cheery> yup.
09:09:03 <Cheery> it branches from there then though. But mainly I guess it becomes a matter of building some sort of query system on top of that.
09:09:06 <dminuoso> Cheery: So what are you looking for exactly then?
09:09:30 <Cheery> REST
09:09:31 <dminuoso> Please check my first question.
09:09:38 <alehander92> is snap good?
09:10:41 <Cheery> Well I can look and see.
09:18:54 <dolio> I don't think snap is for writing web servers.
09:23:02 <[exa]> is Spock the new scotty?
09:32:21 <lyxia> I'm wondering about adding a superclass constraint to Functor, the constraint (forall a b. Coercible a b => Coercible (f a) (f b)); besides all the other reasons why it's a bad idea, is there a practical counterexample of a Functor that can't be coerced?
09:38:19 <int-e> newtype F a = F a; type role F nominal
09:38:50 <int-e> Sure, you'll always be able to do  fmap coerce  so this is a bit silly.
09:41:33 <int-e> And I don't think you can *actually* change the representation based on the type for something that has a fully fledged Functor instance, as much as that seems to be possible in principle.
09:41:54 <tomsmeding> i
09:42:04 <tomsmeding> (sorry wrong channel)
09:44:37 <int-e> data Foo a where Base :: Foo Int; Mapped :: (a -> b) -> Foo a -> Foo b -- maybe with slightly lawless functor instances...
09:49:22 <int-e> lyxia: The idea with Foo is that fmap f (Mapped g x) = Mapped (f . g) x; fmap f x = Mapped f x. It doesn't satisfy fmap id = id, but with the right semantics for `Mapped`, it's morally valid. And you can't do  fmap coerce = coerce  because it might change the type of a Base constructor.
09:50:04 <lyxia> yes I get the idea, but I feel conflicted about whether it's really a good counterexample.
09:50:16 <lyxia> that's why I said "practical"
09:51:35 <lyxia> but now that you make me reconsider it I think it makes sense
09:55:08 <justaskingaquest> I'm starting to learn FP + haskell and was wondering if someone could break down what's happening behind the scenes when we execute `map (*) [0..]`?  
09:55:36 <dsal> :t map (*) [0..]
09:55:37 <lambdabot> (Num a, Enum a) => [a -> a]
09:56:06 <dsal> justaskingaquest: I'm a bit confused as to what you're asking.  Do you want to know what `[a -> a]` means?
09:56:06 <[exa]> justaskingaquest: how much behind the scenes do you want to get?
09:56:35 <justaskingaquest> Good question - relatively deep? I'm jsut trying to grok it a little better
09:56:45 <dsal> justaskingaquest: What do you understand so far?
09:57:22 <justaskingaquest> I think I understand the idea of mapping and the infinite list
09:57:33 <[exa]> justaskingaquest: well in particular, the value it returns is not "executable" (it's just a value) and if you don't specify how it's going to be used, probably nothing is gonna happen due to laziness
09:57:36 <justaskingaquest> It's the infix (*) that I would like some clarification on
09:57:46 <justaskingaquest> especially in the context of being applied to the list
09:57:59 <dsal> :t (*)
09:58:00 <lambdabot> Num a => a -> a -> a
09:58:22 <justaskingaquest> @[exa] it's part of a book I'm reading, it isn't being used in a codebase
09:58:22 <lambdabot> Unknown command, try @list
09:58:26 <dsal> `(*)` is a function that takes two values of a type and returns a third value of the type (colloquially).
09:58:29 <[exa]> justaskingaquest: anyway (*) is a "function of 2 arguments" which means that it takes 1 argument and returns another function (to take the second one and return the result). `map` adds the first arguments, and you get a list of the functions waiting for the second argument
09:58:59 <justaskingaquest> I see
09:59:18 <[exa]> justaskingaquest: oh so, good :] anyway this process (curried functions) is mildly confusing to beginners, but pretty easy to get used to
09:59:24 <justaskingaquest> So I have [1*, 2*, 3*..], and can then pass them arguments to evaluate those functions
09:59:50 <justaskingaquest> I'm reading about curried functions right now and want to make sure I don't skim over it
09:59:57 <justaskingaquest> I'd like to take my time with the fundamentals
10:00:30 <[exa]> justaskingaquest: yes you'd need to somehow zip it with the argument list (or a single argument) to get a list of results
10:00:42 <justaskingaquest> How would zipping it with a single arg look
10:00:56 <justaskingaquest> i.e. if I wanted the multiplier to be 2 for the items in that list
10:01:03 <[exa]> say, `map (\fn -> fn 5) yourList`   applies the functions to 5, so you should get 0*5, 1*5, ...
10:01:06 <justaskingaquest> returning [2,4,6,...]
10:01:14 <justaskingaquest> I see
10:01:20 <dsal> > zipWith ($) (map (*) [0..]) [0..]
10:01:23 <lambdabot>  [0,1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,4...
10:01:29 <[exa]> you might have seen the ... yeah exactly what dsal is showing. :D
10:01:42 <justaskingaquest> Is a lambda with `\fn -> fn 5` the way to go?
10:01:58 <dsal> That's not "zipping with a single arg" since that doesn't quite make sense.  I don't quite understand what you mean there.
10:02:18 <[exa]> justaskingaquest: it works (people here try to free binding-free code, so you might write the lambda as `($ 5)`  (read: apply to 5)
10:02:22 <dsal> > map (* 11) [0..] -- but you can just give one of the arguments initially
10:02:24 <lambdabot>  [0,11,22,33,44,55,66,77,88,99,110,121,132,143,154,165,176,187,198,209,220,23...
10:02:30 <[exa]> *try to write
10:02:37 <justaskingaquest> Let me try again- say I have this map (*) that we've defined over [1,2...]
10:02:46 <justaskingaquest> Let's say that's some variable a
10:03:03 <justaskingaquest> if i want to evaluate a with a number such as 2 applied to it
10:03:10 <justaskingaquest> which would return [0,2,4,6...]
10:03:15 <justaskingaquest> What would that look like
10:03:25 <[exa]> `map ($ 2) a`
10:03:37 <[exa]> (or the same with the lambda, `map (\fn -> fn 2) a`
10:03:52 <justaskingaquest> Cool
10:03:59 <justaskingaquest> I haven't encountered `$`
10:04:02 <justaskingaquest> yet
10:04:04 <[exa]> you might have seen $ being used to "avoid parentheses" like putStrLn $ show $ 1+3
10:04:29 <glguy> > 2 * do 3 + 4
10:04:31 <justaskingaquest> Oh that's interesting
10:04:31 <lambdabot>  14
10:04:39 <[exa]> it's an useful idiom, the above code is equivalent to `putStrLn ( show (1+3) )`
10:04:52 <dsal> There's a bit going on in `($ 2)`, but it's all bits you'll need to know everywhere.
10:04:56 <justaskingaquest> I will keep that in mind
10:05:09 <justaskingaquest> :t map (*) [0..]
10:05:10 <lambdabot> (Num a, Enum a) => [a -> a]
10:05:28 <[exa]> glguy: oh wow awesome
10:05:57 <justaskingaquest> I thought I understood how to read these but I'm a little confused
10:06:02 <justaskingaquest> we've got num a, enum a
10:06:16 <justaskingaquest> and it returns a list of [a- > a]?
10:06:34 <dsal> No, we have `a`.  `a` is constrained as having both `Num` and `Enum` instances.
10:06:49 <justaskingaquest> Oh
10:06:53 <dsal> The `a` is the same throughout the whole thing, but the constraints narrow what it can be by defining requirements it must have.
10:06:57 <justaskingaquest> So a has typeclasses Num, Enum?
10:07:04 <dsal> Yeah.
10:07:07 <justaskingaquest> Thank you
10:07:16 <dsal> And then you get a list of functions from `a` to `a`
10:07:24 <[exa]> justaskingaquest: you can read `Num a => a` roughly as a "For any numeric `a`, this can have type `a`"
10:07:35 <justaskingaquest> Could you break that down a little? dsal
10:07:46 <justaskingaquest> from a to a that is
10:08:16 <[exa]> justaskingaquest: your `(Num a, Enum a) => [a -> a]` reads "A list of functions from `a` to `a`, with the condition that `a` is numeric and can be enumerated"
10:08:30 <dsal> justaskingaquest: A function takes a value of one type and returns a value of another type.
10:08:56 <[exa]> justaskingaquest: similarity of => and -> is sometimes also newbie-unfriendly but they are _completely_ different for our purposes now
10:09:13 <justaskingaquest> Yeah I figured, thank you
10:09:22 <dsal> Your `a` can be any type as long as it has both a Num and Enum instance.
10:10:08 <justaskingaquest> > reads "A list of functions from `a` to `a`, with the condition that `a` is numeric and can be enumerated"
10:10:10 <lambdabot>  []
10:10:28 <justaskingaquest> How do we know it's a list of functions?
10:10:32 <[exa]> justaskingaquest: btw if you know C++, you can very vaguely imagine `a` as a templated type, but the template magically only works with numeric, enumerable `a`
10:10:34 <justaskingaquest> the -> in the middle?
10:10:45 <dsal> Yeah.
10:10:47 <jacks2> lambda bot tried to send that string to reads :)
10:10:49 <justaskingaquest> Thanks
10:11:05 <justaskingaquest> I should check out the wiki.
10:11:26 <orcus> What libraries are recomended these days for doing generic local things at each node in a tree. E.g. "does the pattern `Node (Node _ _) _` match anywhere inside my tree". Maybe SYB/uniplate? But I don't know the current landscape here.
10:11:52 <[exa]> justaskingaquest: btw try using `map` to produce a function of type "Num a => [a] -> [a]"
10:12:06 <justaskingaquest> That's a list to list func?
10:12:22 <[exa]> yes
10:12:26 <justaskingaquest> One moment
10:13:00 <dsal> justaskingaquest: What material are you currently going through?
10:13:14 <justaskingaquest> learnyouahaskell.com
10:14:04 <justaskingaquest> exa = map (+)
10:14:05 <dsal> Ah.  That one isn't the most highly rated.  You might like haskellbook.com since it walks you slowly through the fundamentals and builds a world from the ground up -- I don't know what the new hotness of learning is.
10:14:16 <justaskingaquest> :t map (+)
10:14:18 <lambdabot> Num a => [a] -> [a -> a]
10:14:32 <justaskingaquest> I think that's an example?
10:14:46 <dsal> justaskingaquest: `a` /= `a -> a`
10:15:05 <justaskingaquest> Oh whoops
10:15:09 <justaskingaquest> Youa re right
10:15:30 <justaskingaquest> dsal: I will take a look. My FP knowledge is minimal
10:16:02 <dsal> To a degree, the less you know, the easier it is to learn.
10:16:28 <justaskingaquest> So it takes a Num a and returns a function from a to a list of functions from a to a?
10:16:43 <dsal> Your example does, yes.
10:17:33 <dsal> Starting a bit lower is easier.  Once you understand basic stuff, applying basic stuff to functors is nearly obvious.  Right now, you're trying to do both at the same time.
10:17:46 <justaskingaquest> Looks like it
10:18:13 <justaskingaquest> I've been slowly working through that tutorial and had a few moments where I realized I needed some clarification
10:18:25 <[exa]> justaskingaquest: you'll need to feed one argument to (+)
10:18:27 <dsal> It's not rated super high.
10:18:48 <dsal> Operators are kind of weird.
10:19:23 <dsal> They're easy to use, but they're functions that produce functions and are placed after their first argument.
10:19:28 <justaskingaquest> Oh yeah
10:19:36 <justaskingaquest> Functions actually only take 1 argument, right
10:19:49 <justaskingaquest> And generate a function to take on the remaining args?
10:20:27 <justaskingaquest> [exa]: I'm trying to see how map would create a function where [a] -> [a]
10:20:47 <dsal> In the case of (+), yeah.  Things can get far weirder.
10:20:48 <dsal> :t fix
10:20:49 <dsal> e.g.
10:20:49 <lambdabot> (a -> a) -> a
10:20:50 <ezzieyguywuf> the cabal documentation mentions using information in "MyPackage.cabal" to create a "sysem" package, i.e. I'm assume a deb or rpm or what-have-you
10:21:10 <ezzieyguywuf> is cabal itself used to make this translation or are there other third-party tools that are necessary?
10:21:26 <dsal> ezzieyguywuf: we've all moved onto nixos.
10:21:48 <justaskingaquest> In which cases do the signatures need explicit brackets and nesting?
10:21:51 <justaskingaquest> like with
10:21:53 <justaskingaquest> :t fix
10:21:55 <lambdabot> (a -> a) -> a
10:22:15 <dsal> fix takes a function that takes an `a` and returns an `a` and then returns an `a`.
10:22:40 <dsal> If you don't see parens, it's  `a -> (a -> a)`
10:23:04 <dmwit> justaskingaquest: I think the better question is: in which cases may parentheses be omitted from type signatures?
10:23:08 <dmwit> That one is much more answerable.
10:23:33 <dmwit> The answer there is that (->) is right-associative, and binds less tightly than type-level (prefix) application.
10:24:00 <justaskingaquest> I see
10:24:16 <justaskingaquest> I'll skim the outline of haskellbook
10:24:30 <justaskingaquest> I'd rather learn the fundamentals comprehensively
10:24:38 <dsal> It's a great book for that.
10:24:48 <dsal> Lists aren't for like... a long way into the book.
10:26:26 <justaskingaquest> Wow, that's a big book
10:26:26 <justaskingaquest> ahaha
10:26:48 <ezzieyguywuf> dsal: so does that mean that the cabal file can be used to create a nixos-package, and that's it?
10:26:51 <dsal> It is.  And it's fairly slow.
10:27:05 <ezzieyguywuf> also, when you said "we've all moved on to nixos" you mean that you're all using the nixos linux operating system?
10:27:22 <ezzieyguywuf> (I get confused about the nix conversation because i've heard it discussed in relation to cabal in the past)
10:27:28 <dsal> ezzieyguywuf: I've tried hard to avoid building OS packages.
10:27:45 <dsal> I'm not serious about everyone moving to nixos.  Nothing that solves problems well ever catches on.
10:27:53 <justaskingaquest> lol
10:28:05 <ezzieyguywuf> dsal: you're saying that nixos "solves problems well" then?
10:28:28 <dsal> ezzieyguywuf: It does for me, at least.  All of the pain I've ever had with packages is gone.  :)
10:28:32 <ezzieyguywuf> that's the one with, like, snapshots before/after system updates, right, making it "easy" to roll back if something gets borked up?
10:28:44 <dsal> Yeah, you can rollback a complete system upgrade.
10:28:49 * hackage haskoin-store-data 0.37.5 - Data for Haskoin Store  https://hackage.haskell.org/package/haskoin-store-data-0.37.5 (jprupp)
10:29:44 <ezzieyguywuf> hrm. i'm happy with gentoo, no real pains with packages
10:29:49 * hackage haskoin-store 0.37.5 - Storage and index for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-store-0.37.5 (jprupp)
10:30:30 <dsal> ezzieyguywuf: you can run nix on gentoo to get a feel, but my OS system definition for my Chromebook is one file, so if I screw up or something, I can rebuild this machine by just putting that one file back in place and telling it to fix all the things.  :)
10:30:33 <dsal> I use nix on my mac, thogh.
10:30:59 <ezzieyguywuf> as I'm redaing through the cabal documentation, it sounds like the "nix-style local builds" stuff does a lot of (if not all?) of the things that stack was meant to do
10:31:18 <ezzieyguywuf> dsal: interesting
10:31:47 <dsal> Maybe... I use stack+nix stuff.  It makes sure the build environment has the right packages installed to build all the things.  Haskell packages, compilers, linkers, c libraries, standalone programs, etc...
10:31:48 <dmwit> Yes, stack predates nix-style builds and most likely would not have been built if nix-style builds had been implemented sooner.
10:32:42 <dmwit> (Not to say stack doesn't serve a role that people now find valuable independently of nix-style builds. Just that it took a lot of effort, and probably the folks involved would  have been satisficed by nix-style local builds if they had existed sooner.)
10:33:15 <dsal> I've still failed to successfully convert projects from stack to cabal.  It's a bit of a pleasant prison, I guess.
10:34:54 <dmwit> (...and, not to rewrite history: I suspect the work on nix-style local builds would basically not have happened without the push from stack showing how much better things could be if you put in some work.)
10:35:00 <ezzieyguywuf> dsal: "pleasant prison" seems like a good way to summarize it. I was discussing this in this channel last week (I forget who was involved in the conversation) and it seems like if I take the effort to update my cabal files properly (namely adding version information to dependencies) that the conversion away from stack should be rather painless
10:35:25 <ezzieyguywuf> I took the time to transition away from hpack earlier today, that wasn't so hard
10:37:13 <dsal> Not using hpack *sounds* horrific to me.  I can't remember the hurdle I ran into last time.  There was a common stack thing I wanted to do that just wasn't available in cabal.  I should take better notes and/or try again.
10:38:24 <ezzieyguywuf> I learned about the "common" stanza for cabal files today. I haven't used it yet but I think this will resolve one of my main reasons for moving away from cabal in the first place (though admittedly this was in my first or second week of learning haskell at all, and stack was just easier)
10:38:36 <MarcelineVQ> it's only real advantage is automatically adding/finding modules of your project
10:38:51 <MarcelineVQ> To people who consider that an advantage :>
10:39:23 <dsal> It's a pretty big deal for me.  I don't want to say things twice in two different places every time I want to add, remove, or rename files.
10:39:54 <dsal> Does cabal have a `--file-watch` test concept?
10:40:20 <dmwit> ghcid?
10:40:32 <glguy> <3 ghcid
10:41:28 <dsal> Ah.  It's an additional tool.  That makes sense.  That may have been what my latest hangup was.  I need to try again.
10:43:22 <niso> dsal: how are you managing your projects in nixos? with haskell.nix?
10:43:49 * [exa] eyes ghcid
10:45:55 <dsal> niso: just stack.  I like nixos as a system, but I don't go super hard in verticals.  I also develop on my mac.
10:46:02 <dsal> (which has nix, so that's a bad argument)
10:48:02 <niso> dsal: i see, thanks
10:49:00 <ezzieyguywuf> yas ghcid
10:49:28 <ezzieyguywuf> honestly i'm surprised there's anyone in here _not_ using ghcid
10:50:17 <dsal> I don't quite know what I'm missing.
10:50:26 <niso> dsal: haskell.nix
10:53:10 <dsal> niso: I'll see what that does.   I've got enough projects that I can surely try something.  I have a couple different ARM targets I don't have nix for.
10:54:53 <niso> dsal: it parses your stack/cabal file and generates you a nix environment (with things like hoogle/hie/etc on a per-project-basis (allowing e.g. multiple ghc versions))
10:55:16 <niso> dsal: crosscompilation should also be possible - however i don't have experience with that yet
10:59:04 <dsal> niso: super helpful.   I don't cross compile, though.  If I could get that going, it'd probably make some things easier, but I just build on ARM environments when I need bins.
11:06:52 <justanotherquest> What would use cases for `flip` be? Any examples work :)
11:07:02 <turion> When I do cabal build --ghc-options="-fno-code", it rebuilds all dependencies as well. How can I make it only check my local project without code generation, and reuse the existing dependencies?
11:07:33 <turion> justanotherquest: I use flip often together with runReader. E.g. flip runReader r $ do .......
11:08:35 <tomsmeding> justanotherquest: flip map list $ \element -> something something element
11:10:23 <monochrom> turion: I believe the rebuild is precisely because the previous build did not have --ghc-options=-fno-code. cabal is very conservative in reusing builds, and rightfully so, any slight change in setting is just cause for distrust and requires new builds.
11:11:36 <tomsmeding> justanotherquest: also `foldl (flip Map.insert) initmap items`, which is sometimes useful as a replacement of `foldr Map.insert initmap items` if you want later items to get precedence
11:12:02 <justanotherquest> Thanks everyone
11:14:18 <ezzieyguywuf> can't you just use infix style or most of the flip-use cases though? i.e. `foldl (`Map.insert` initmap) items`?
11:14:19 <dsal> justanotherquest: hslint will often tell you that flip can be easier to read with sections.  It depends.  There are many similar tools such that they look weird at first, but then one day you're like, "hmm...  I wish I had a way to..."
11:14:26 <sm[m]> Cheery, I think you were asking about how to build web applications. To the names mentioned earlier, add IHP (the newest)
11:15:00 <dsal> ezzieyguywuf: the runReader case would probably be awkward.
11:15:12 <monochrom> ezzieyguywuf: yes, until section syntax is inapplicable, e.g., flip (f x) (h y)
11:16:15 <sm[m]> Cheery: also miso
11:16:22 <monochrom> there is no syntax provision for (`f x` z)
11:17:07 <monochrom> Some of us would like that syntax actually.
11:17:46 <lpyfist> sorry
11:17:47 <ezzieyguywuf> i see.
11:17:55 <sm[m]> Cheery: also postgrest
11:19:48 * hackage pandoc-plot 0.9.0.0 - A Pandoc filter to include figures generated from code blocks using your plotting toolkit of choice.  https://hackage.haskell.org/package/pandoc-plot-0.9.0.0 (LaurentRDC)
11:22:56 <sm[m]> dsal, no cabal doesn't have --file-watch yet. (ghcid watches haskell source files, --file-watch also watches yaml/cabal files and maybe others)
11:30:14 <ezzieyguywuf> sm[m]: ghcid can watch any arbitrary file
11:31:06 <ezzieyguywuf> ghcid --reload will reload ghcid when the given file changes, ghcid --restart will restart ghcid when the given file changes
11:31:26 <sm[m]> ezzieyguywuf: good point, though not as convenient as automatically watching just the right files
11:31:32 <ezzieyguywuf> indeed
11:32:07 <ezzieyguywuf> you can set it to a directory though, so a brute-force approach would be "ghcid --reload=."
11:32:17 <ezzieyguywuf> though that's probably not the desired behaviour
11:32:17 <sm[m]> on the other hand, much faster than --file-watch since it doesn't link
11:32:25 <ski>   f x `flip` z
11:33:36 <ezzieyguywuf> ski: still uses flip though
11:34:02 <ezzieyguywuf> I'm confused about the return types of (f x) and (h y) in `flip (f x) (h y)`
11:34:36 <int-e> :t flip
11:34:38 <lambdabot> (a -> b -> c) -> b -> a -> c
11:35:49 <ezzieyguywuf> int-e: well, i knew that, lol.
11:35:52 <ski> say `x :: a' and `y :: b'. and then e.g. `h :: b -> d', so `h y :: d'. `flip' applied to `f x' means the latter takes two additional arguments, the latter of which will be `h y'
11:36:49 <ski> so say `f x :: c -> d -> e', iow `f :: a -> c -> d -> e', do `flip (f x) :: d -> c -> e' and `flip (f x) (h y) :: c -> e'
11:36:57 <ezzieyguywuf> ah, I"m still getting a hang for the parens, so it's like `(flip (f x)) (h y)` then?
11:37:04 <ski> yes
11:37:13 <ski> function application associates to the left
11:38:08 <ezzieyguywuf> hrm, still confused, because isn't `flip (f x) :: b -> a -> c` ? is `flip (f x) (h y) :: a -> c` then?
11:38:38 <ski> i named the type variables differently
11:39:00 <ezzieyguywuf> yea, my last statement there was non-sensical
11:39:03 <ezzieyguywuf> as x and y are values not types
11:39:10 <ezzieyguywuf> but, er..."you get the idea right?"
11:39:14 <ski> your `a' is my `c', your `b' is my `d', your `c' is my `e'
11:40:04 <ezzieyguywuf> yea i see
11:40:46 <ski> (but taking that into account, what you said just above is correct)
11:41:12 <ezzieyguywuf> I also see now what was originall meant by "section syntax"
11:42:33 <ski> i'd probably write  flip map list $ \element -> something something element  as  (`map` list) $ \element -> something something element
11:42:56 <ski> (and with `BlockArguments', i could also get rid of the `$')
11:44:00 <tomsmeding> :t \f x h y -> flip (f x) (h y)
11:44:02 <lambdabot> (t1 -> a -> b -> c) -> t1 -> (t2 -> b) -> t2 -> a -> c
11:44:23 <tomsmeding> ezzieyguywuf: ghci can usually tell you what the types of the constituent variables are in those cases :)
11:44:46 <ratzes> i have a gadt ast like "AST o" with constructors like UnaryExpression :: AST o1 -> AST o, I think I know how to do equality on types, but is there a way to do an Eq instance with values as well?
11:45:16 <tomsmeding> ratzes: does that UnaryExpression constructor have any kind of constraint on o1 and o?
11:45:32 <tomsmeding> if it doesn't, I'm not sure how useful the GADT is
11:45:42 * ski was thinking the same thing
11:45:50 <ratzes> tomsmeding yeah, quite a few
11:46:16 <tomsmeding> or do you mean that you have stuff like `Not :: AST Bool -> AST Bool`? In which case, okay :p
11:46:33 <tomsmeding> but for an Eq instance, could you just write it manually?
11:46:41 <tomsmeding> usually those kind of instances work out fine I think
11:47:07 <tomsmeding> and if this one doesn't, I'd be curious where you get stuck
11:47:14 <ezzieyguywuf> tomsmeding: I tried that, but didn't think to do it using a lamba like you did, nice trick.
11:47:20 <ski> or maybe you could try `StandaloneDeriving' ?
11:47:49 <ski> (using a lambda ?)
11:48:12 <tomsmeding> @pl \f x h y -> flip (f x) (h y)
11:48:12 <lambdabot> (((.) . flip) .)
11:48:13 <ratzes> tomsmeding hmm, so since the o1 and o are different types, im not sure how to write it
11:48:14 <tomsmeding> ezzieyguywuf: for more fun
11:48:53 <ski> @pl \x y -> f x `flip` h y
11:48:54 <lambdabot> (. h) . flip . f
11:49:06 <int-e> :t fmap (fmap fmap flip)
11:49:08 <lambdabot> (Functor f1, Functor f2) => f1 (a1 -> a2 -> c) -> f1 (f2 a2 -> f2 (a1 -> c))
11:49:22 <sedeki> main = do { fmap putStrLn ["Test", "Test2"] } .. this is a [IO ()] not an IO ()
11:49:26 <ski> ratzes : it's hard to say much, without the full type of the data constructor
11:49:27 * dsal kind of wishes `fmap` were named `smurf`
11:49:28 <tomsmeding> ratzes: well you'd start with `instance Eq (AST o) where`, and then start writing out all the cases with the same constructor left and right of `==`
11:49:44 <tomsmeding> @let smurf = fmap
11:49:45 <lambdabot>  Defined.
11:49:53 <dsal> :t smurf (smurf smurf flip)
11:49:54 <lambdabot> (Functor f1, Functor f2) => f1 (a1 -> a2 -> c) -> f1 (f2 a2 -> f2 (a1 -> c))
11:49:59 <sedeki> do I need to fold over it?
11:50:03 <ski> sedeki : use `mapM_', not `fmap'
11:50:25 <tomsmeding> sedeki: or put  sequence  before the thing
11:50:35 <ski> (or `sequence_')
11:50:42 <tomsmeding> fair point
11:52:16 <ratzes> ski tomsmeding here's a gist https://gist.github.com/fabricatedmath/24101d37a051a012ded8cbf7e4b714e7
11:53:11 <ratzes> im compiling this ast down to c code eventually
11:53:26 <tomsmeding> ratzes: I see in UnaryExpression you're not linking the function name to the types o1 and o in any way
11:53:34 <tomsmeding> doesn't that kind of defeat the purpose of using a GADT?
11:54:21 <tomsmeding> but anyhow, even if you want the type to look exactly like this for some reason, I'd think you can write `instance HasAST o => Eq (AST o) where` without too much trouble
11:54:58 <tomsmeding> (also, it's usually "ternary" and "quaternary" in general, I believe)
11:55:09 <ski> tomsmeding : it's a synonym, they'd need to make separate instances for each individual type class
11:55:28 <ratzes> tomsmeding when i build the ast the text represents a c call, with the o1,o2 being the args and o being the return type
11:55:33 <ski> oh, sorry .. i misread what you said
11:55:45 <ratzes> lol, ill change the names, good point
11:55:51 <tomsmeding> ski: you can... just do this, right? :p
11:56:04 <ski> yes, it should work
11:56:20 <tomsmeding> ratzes: and you don't know the names of the C functions in your compiler yet?
11:56:32 <tomsmeding> i.e. they can be defined later at runtime?
11:57:05 <ski> ratzes : i might try to abstract the function names with the types of arguments and result
11:57:22 <ratzes> there might be hundreds of them i think
11:57:39 <ratzes> ski wait are you saying an Eq instance should just work?
11:57:41 <tomsmeding> well that's not really an obstacle
11:58:36 <dminuoso> What kind of literature can I read to gain an understanding of what constraints/contrained types are, in a type theory sense?
11:58:50 <ski> ratzes : you'd need some way to recover the type indices, for that to work. e.g. `Typeable' (which you have in `HasAST')
11:59:08 <tomsmeding> basically what I'm concerned about is most clearly described using your 'Call :: UniqueId -> Text -> AST o' constructor: I could create a Call to the same function with literally any type for 'o', and GHC would accept it. Why, exactly, is it still a GADT then?
11:59:12 <ski> @type cast
11:59:13 <lambdabot> (Typeable a, Typeable b) => a -> Maybe b
11:59:30 <ski> ratzes : try using that, and then call recursively
11:59:39 <ratzes> @ski oh, thats what thats used for, holy s***
11:59:40 <lambdabot> Maybe you meant: wiki src ask
12:01:21 <ratzes> tomsmeding so that c_type class gives me the c representation of the type like "unsigned long" and i have a parser which creates a haskell file that looks like https://gist.github.com/fabricatedmath/7d3c25a3cf05b500a94ef6efdf594605, which encodes all of those types 
12:01:59 <ratzes> and this is running a stack based language with an embedding to build the ast
12:02:04 <tomsmeding> sure
12:02:34 <tomsmeding> and indeed to write that Eq instance for this GADT you need the 'cast' function that ski gave
12:02:38 <ratzes> tomsmeding do i still not need a GADT?
12:02:43 <tomsmeding> but why is this a GADT in the first place?
12:02:52 <tomsmeding> do you _use_ the GADT-ness anywhere?
12:03:29 <ratzes> i thought the whole point of the GADT was to let the types float around. is there a way to not use it?
12:03:39 <ski> it could just be using `ExistentialQuantification'
12:03:56 <tomsmeding> exactly that
12:04:03 <ski> "let the types float around" is a bit vague
12:04:38 <dolio> More than a bit. :)
12:05:01 <ski> (but it's not too clear to me whether those existentials are really used for anything, either)
12:05:17 <ratzes> haha yeah, im quite an F in meyers briggs
12:05:24 <monochrom> To the point of wishing that type variables and polymorphism are the magical Sorting Hat.
12:05:38 <ski> what's the magical Sorting Hat ?
12:06:21 <tomsmeding> ratzes: something like: data AST = Accessor UniqueId Text AST | Call UniqueId Text AST | forall o. HasAST o => Literal UniqueId o | ...
12:06:24 <monochrom> You don't know what kind of life you want (e.g., in the Harry Potter stories, which house to join at school), but you hope that a magical Sorting Hat knows.
12:06:28 <tomsmeding> is there a reason it could not be that?
12:06:28 <ratzes> so does this just entail changing to UnaryExpression :: forall o1. HasAST o1 ...'?
12:07:17 <monochrom> And a pun, given the close relation (even synonymity) between "sort" and "type". >:)
12:07:17 <ratzes> tomsmeding maybe, but how would i recover the type of the return on the calls?
12:07:19 * hackage postgresql-tx 0.1.0.0 - A safe transaction monad for use with various PostgreSQL Haskell libraries.  https://hackage.haskell.org/package/postgresql-tx-0.1.0.0 (jship)
12:07:51 <tomsmeding> you'd need to have some kind of runtime representation of that type, and add it to the constructor
12:08:06 <ratzes> oh i see
12:08:10 <tomsmeding> what's the definition of your C_Type class? it sounds relevant
12:08:19 * hackage postgresql-tx-squeal 0.1.0.0, postgresql-tx-simple 0.1.0.0, postgresql-tx-query 0.1.0.0, postgresql-tx-monad-logger 0.1.0.0 (jship): https://qbin.io/kathy-rolled-cago
12:08:57 <ratzes> tomsmeding https://gist.github.com/fabricatedmath/32ec990af200671dc016bdcc8fed46f7
12:10:28 <tomsmeding> right
12:10:46 <tomsmeding> so then you'd have something like ... | forall t. C_Type t => Call UniqueId Text t AST | ...
12:10:47 <tomsmeding> I suppose
12:11:24 <ski> % unsort [2,3,5,7]
12:11:24 <yahb> ski: [2,3,5,7]
12:11:27 <ski> % reverse (unsort [2,3,5,7])
12:11:27 <yahb> ski: [2,3,5,7]
12:11:44 <tomsmeding> useful 'reverse' function you have there
12:12:09 <ski> % let xs = unsort [2,3,5,7]; x = last xs in (x,xs)
12:12:09 <yahb> ski: (2,[2,3,5,7])
12:13:06 <tomsmeding> % :t unsort
12:13:06 <yahb> tomsmeding: Ord a => [a] -> [a]
12:15:40 <monochrom> this... referential... what is going on? haha
12:15:49 <ratzes> tomsmeding ski thanks, i think i have some good stuff to think about
12:16:31 <dolio> Rewriting a data type in ExistentialQuantification syntax just because it's 'not a GADT' is not really necessary or better.
12:17:37 <ski> yes
12:19:31 <tomsmeding> ratzes: also potentially useful: if you're staying with a GADT and are comparing runtime representations of types, then you probably want to write not an Eq instance but a GEq instance, from https://hackage.haskell.org/package/some-1.0.1/docs/Data-GADT-Compare.html
12:19:48 * hackage rpmbuild-order 0.4.1 - Order RPM packages by dependencies  https://hackage.haskell.org/package/rpmbuild-order-0.4.1 (JensPetersen)
12:20:19 <tomsmeding> if you don't already know what :~: is, though, that might be kind of a rabbit hole :p
12:21:01 <ski> % let xs :: [Integer]; xs = unsort [2,3,5,7]; x = last xs in (x,xs)
12:21:01 <yahb> ski: (2,[3,5,7,2])
12:21:29 <tomsmeding> well, correction: you might want to write _both_ a GEq _and_ an Eq instance, because Data.GADT.Compare.defaultEq is really useless
12:21:53 <ratzes> @dolio i think thats why i got confused thinking that ExistentialQuantification and GADTs are the same thing
12:21:53 <lambdabot> Unknown command, try @list
12:22:23 <ratzes> tomsmeding i was prototyping that up and its not easy lol. I got the type equality working, just didnt know how I could do value equality also
12:22:25 <tomsmeding> (ratzes: you don't generally need to use the '@' symbol when mentioning someone on irc :) )
12:22:47 <ratzes> just type name? im a noob
12:22:48 <ski> (you generally shouldn't)
12:22:57 <ski> yes
12:22:59 <tomsmeding> ratzes: if you pattern match on the Refl from the type equality, then GHC knows (in that pattern match arm) that the types are equal, allowing you to perform the value equality check
12:23:21 <ski> @hoogle typeName
12:23:21 <lambdabot> Database.PostgreSQL.Simple.FromField typename :: Field -> Conversion ByteString
12:23:22 <lambdabot> Data.SafeCopy.Internal typeName :: Type -> String
12:23:22 <lambdabot> GI.GObject.Functions typeName :: (HasCallStack, MonadIO m) => GType -> m Text
12:23:35 <ratzes> tomsmeding: and you do that with the cast in Data.Typeable?
12:23:47 <tomsmeding> can do that with a 'case' statement on the Refl, which is probably most instructive; for a more compact way of writing, you may want to use so-called pattern bindings on Refl
12:24:05 <tomsmeding> I'm here advocating a solution that doesn't need Typeable at all
12:24:14 <tomsmeding> well
12:24:23 <tomsmeding> that would require your C_Type class to give you more information
12:24:39 <tomsmeding> since it doesn't you need typeable I guess
12:26:57 <tomsmeding> if you want to value-compare x :: AST o1 and y :: AST o2, then you could do 'maybe False (== y) (cast x)'
12:26:58 <tomsmeding> I think
12:27:50 <tomsmeding> that does require that AST is also Typeable
12:28:17 <c_wraith> everything is an instance of Typeable now
12:28:32 <c_wraith> Has been since like ghc 7.10
12:28:43 <tomsmeding> ah! nice TIL
12:28:59 <tomsmeding> don't work with Typeable often, fortunately :p
12:29:47 <c_wraith> I did a bunch of work with dynamic code loading around that time, and that relies on Typeable for safety.
12:29:52 <ratzes> tomsmeding ill give it a try, im already using typeOf and typeRep all over in my show instances
12:30:14 <c_wraith> It was a huge relief to have instances automatically, especially since there were a bunch of things that GHC didn't derive Typeable for before that.
12:31:07 <ratzes> tomsmeding wait, so with all i said, is it dumb i'm formatting my AST this way?
12:31:12 <c_wraith> writing Typeable instances by hand was unpleasant and easy to get wrong.  fun combination!
12:32:11 <tomsmeding> ratzes: with the information I have now, my opinion would be that this AST is better written using ExistentialQuantification -- but as was mentioned earlier, a half-GADT is equivalent in some sense to ExistentialQuantification
12:32:31 <tomsmeding> I don't have an _objective_ reason for my opinion :p
12:33:15 <tomsmeding> if I see a GADT, my brain immediately thinks "hey, a type-safe AST" -- but this isn't, hence my initial reaction :)
12:34:29 <ratzes> haha ok, good to know
12:35:29 <tomsmeding> (earlier I used the words "pattern binding"; replace that by "pattern guard" please)
12:52:47 <Orbstheorem> Hello o/ Can I have a Polymorphic function with a "default" type?
12:53:35 <Orbstheorem> As in , `foo :: forall a. a -> a`, and if I write `foo` it is interpreted as `foo @Text`, but I can always use a different type (e.g. `foo @Integer`).
12:54:04 <monochrom> No.
12:56:17 <dminuoso> well.. yes you can..
12:56:45 <nitrix> A specialization presumably, but the question is ill-phrased. foo_text :: Text -> Text, foo_text = foo
12:57:37 <dminuoso> There are defaulting rules..
12:57:43 * dminuoso hides
12:57:46 <dsal> I don't quite understand the question.  If you use it as Text, then it's Text.
12:58:07 <monochrom> forall a. a->a enjoys no defaulting rules.
12:58:12 <dsal> Is this about reasonable defaulting?
12:58:18 <nitrix> Default rules requires typeclasses afaik.
12:58:34 <Orbstheorem> I wrote a function that takes two Data.Aeson.Value and compares if a given member matches. "By default", I constrait such members to be strings (`eitherDecode @Text`), but I would also like to support some Ints.
12:58:44 <dminuoso> monochrom: Oh well, I was assuming they were free to add a class constraint.
12:58:52 <Orbstheorem> Though, to be fair, Implicits often bring problems.
12:59:31 <dminuoso> Orbstheorem: Why not simply write some `eitherDecodeT = eitherDecodeT @Text` ?
13:00:01 * tomsmeding thinks that should be `eitherDecodeT = eitherDecode @Text`
13:00:04 <Orbstheorem> That's a good idea.
13:01:18 * hackage hspec-golden 0.1.0.3 - Golden tests for hspec  https://hackage.haskell.org/package/hspec-golden-0.1.0.3 (stackbuilders)
13:07:31 <boxscape> is there a divMod for doubles? Or do I have to do that manually?
13:09:01 <monochrom> Data.Fixed has a divMod' :: (Real a, Integral b) => a -> a -> (b, a)
13:09:54 <glguy> > Data.Fixed.mod' 10 pi
13:09:56 <lambdabot>  0.5752220392306207
13:10:04 <glguy> > Data.Fixed.divMod' 10 pi
13:10:06 <lambdabot>  (3,0.5752220392306207)
13:11:14 <boxscape> ah, thanks
13:14:34 <Orbstheorem> Hum, what is the kind of a scoped type variable if it does not appear in the function signature?
13:16:34 <Orbstheorem> I have this code https://paste.gnugen.ch/raw/p9Ua, and I get this error message: https://paste.gnugen.ch/raw/FrCI
13:19:02 <f-a> Orbstheorem: the error message is pretty garbled
13:19:50 <Orbstheorem> f-a: Encoding problem maybe? It's encoded using unicode.
13:20:17 <Orbstheorem> Error as an image: https://paste.gnugen.ch/raw/2u6m
13:20:20 <tomsmeding> f-a: set your browser to unicode
13:20:23 <Orbstheorem> (Though, that is sad xD)
13:20:27 <f-a> oh, indeed downloading solved it
13:20:53 <tomsmeding> I think GHC doesn't like a forall-declared type variable that's not actually used in that type signature
13:20:55 <f-a> Firefox detects: windows-1252
13:21:12 <tomsmeding> f-a: did the same for me, apparently it fails
13:21:14 <Orbstheorem> f-a: I think that's just default.
13:21:35 <f-a> well I didn’t want to divert attention from the interesting question
13:21:39 <tomsmeding> Orbstheorem: I think you need an explicitly proxy argument here, e.g. from Data.Proxy
13:21:45 <boxscape> Orbstheorem looks like it just says that the kind is polymorphic
13:22:02 <Orbstheorem> tomsmeding: That sounds like a solution, a sad one, but a solution.
13:22:08 <tomsmeding> indeed, because it's not used anywhere in the type it's declared in, and thus not constrained to a particular kind
13:22:15 <tomsmeding> maybe you can give it a kind signature?
13:22:24 <boxscape> yeah I think kind signature should be enough
13:22:24 <Orbstheorem> boxscape: A sort? xD Sorry, I don't understand what you mean by polymorphic kind x(
13:22:44 <boxscape> (i.e. forall (typ :: Type)
13:22:45 <boxscape> )
13:23:19 <Orbstheorem> Great that works ^^
13:23:21 <boxscape> Orbstheorem just like there are type variables that can match any type, there are kind variables that can match any kind
13:23:51 <tomsmeding> oh the :: Type annotation actually works?
13:23:53 <tomsmeding> nice!
13:24:16 <boxscape> one might argue that using typ in a position where it has to be a Type should let ghc infer that it's not polymorphic, but I guess that might be difficult to do
13:24:30 <Orbstheorem> boxscape: Thanks, that's what I though, but for some reason, it feels odd to reason about kind polymorphism in haskell x)
13:24:44 <tomsmeding> I suppose GHC only infers kinds of a forall-declared type variable in the same type as it's declared in
13:24:49 <tomsmeding> it would make some kind of sense
13:24:54 <boxscape> yeah seems like it
13:25:11 <boxscape> Orbstheorem do you have PolyKinds enabled?
13:25:27 <Orbstheorem> boxscape: Yes
13:25:50 <boxscape> Orbstheorem that's why kind variables are possible in your program to begin with
13:25:58 <boxscape> turning that off should also fix it, but maybe you need it for something
13:26:08 <boxscape> (and adding the kind annotation certainly shouldn't hurt)
13:27:00 <Orbstheorem> I think I need PolyKinds to work with DataKinds?
13:27:07 <Orbstheorem> (I'm using DataKinds)
13:27:30 <boxscape> Maybe, depends on what you're doing. It's certainly possible to use DataKinds without PolyKinds, but it can come in handy.
13:27:53 <Orbstheorem> Meh, `:: Type` did the job ^^
13:27:57 <boxscape> yeah :)
13:31:35 <nemron> Hi. Anyone an idea how to parse an XML file avoiding those "empty" nodes, resulting from newlines and spaces between tags? E.g. parsing an XML file like `<a>\n   <b/>\n<a/>` yields 4 nodes. One for `a`, one for `\n   `, one for `b`, one for `\n`. I used Xeno as well as xml-conduit. I thought a pre-processing via regex might help. Any suggestions?
13:34:18 <tomsmeding> obligatory don't parse xml using regex
13:34:42 <suzu_> but you can maybe 'clean up' markup with a regex
13:35:08 <suzu_> that parse looks correct to me though
13:41:52 <nemron> I'm not parsing XML using regex. I thinking of using a regex to clean-up the XML in advance. 
13:42:05 <dsal> nemron: That's just the correct parse.  You can do a second pass to eliminate whitespace in particular nodes and possibly remove them.
13:43:18 <dsal> It's very rare that I find regex to be a good idea when I have any other tools lying around.
13:43:53 <nemron> dsal: Thx. Just thought I could avoid the second pass and apply this little trick to remove those newlines.
13:45:43 <dsal> You might be able to avoid a second pass for specific cases and you might be able to avoid writing bugs into that first pass.  But the second pass will be more accurate and can do further transforms (e.g., maybe you can remove whole trees if structure just existed for a space somewhere)
13:45:46 <nemron> just out of curiosity... what regex lib is to recommended? 
13:46:15 <dsal> I've used a regex once in haskell and it was a terrible experience so I removed it in favor of parsec and had a significant improvement in code quality and reliability.  :)
13:46:45 <glguy> I'm using http://hackage.haskell.org/package/regex-tdfa
13:46:51 <nemron> dsal: Yeah... Haskell & Regex are no good friends ;-)
13:47:33 <dsal> Well, regex in general... but this was a pcre wrapper which had really bad handling of bad user input.
13:48:16 <glguy> I think the time to use regex is when you're taking them as user-input
13:48:41 <nemron> OK. Thx everyone. Guess I've to go for a second pass :-(
13:48:55 <dsal> That makes sense.  I wasn't using them that way, but the actual string going over the regex was bad user input and caused async exceptions.
13:49:43 <dsal> nemron: It's a good thing, though.  You just have an "optimize" function where if the text containers that only contain whitespace are removed, and possibly containers of text containers that only contain whitespace if you're into that sort of thing.
13:50:11 <dsal> It's probably a lens one-liner.  heh
13:52:48 <nemron> dsal "lens one-liner" ;-)
13:54:07 <dsal> Your optimize function could look something like this:   `optimize children = map optimize (filter nonEmpty children)` -- I'm not sure what the API you're using looks like.
13:57:12 <nemron> dsal Thx! I use xml-conduit
13:57:40 <dsal> You could probably do it directly in a conduit pipeline.  But I've not done much with xml lately.
13:58:27 <dsal> A reasonable SAX API should let you omit the uninteresting parts as you're encountering them.
14:00:58 <nemron> dsal Thx for your suggestions. SAX API sounds good. Not used conduit pipelines (yet). Guess my first try will be bloody simple like your first suggestion. 
14:01:26 <dsal> Dumb and simple gets me very far.
14:01:37 <nemron> dsal :-D
14:02:14 <nemron> Anyway... I'll call it day... thx again and have a good night
14:02:17 <dsal> Then I build things that work and decide to remove the shameful bit only to find that it wasn't that hard.
14:02:26 <dsal> nemron: 'night
14:22:06 <d34df00d> Wait, what's wrong with parsing xml with regexes?
14:22:20 <d34df00d> I do it all the time, works flawlessly, provides job security.
14:22:48 * hackage xlsx 0.8.1 - Simple and incomplete Excel file parser/writer  https://hackage.haskell.org/package/xlsx-0.8.1 (KirillZaborsky)
14:22:48 <monochrom> I know what "works flawlessly" exactly means.
14:24:02 <monochrom> We have truckloads of 1st-year students who say "my code works flawlessly, why does it not pass your test cases?"
14:27:51 <d34df00d> monochrom: did you try changing the test cases so that the codes works?
14:27:53 <int-e> monochrom: surely your tests must be broken, it's the only explanation
14:28:26 <monochrom> No, but we tried rebooting.
14:28:28 <int-e> you probably test corner cases, who does that?
15:15:49 * hackage cabal-debian 5.1 - Create a Debianization for a Cabal package  https://hackage.haskell.org/package/cabal-debian-5.1 (ClintAdams)
15:57:48 <hyiltiz> Trying to define the Monad instance for ((,) a). GHC compains that GHC.Base already defines it. I wanted to use newtype to give it another name, but couldn't quite figure out how either
16:01:29 <d34df00d> hyiltiz: what about newtype MyPair a b = MyPair (a, b) ; instance Monad (MyPair a) where ... ?
16:01:39 <d34df00d> Writing that off the top of my head, might not even typecheck.
16:04:36 <hyiltiz> The constructor of a newtype must have exactly one field but ‘Pair’ has two • In the definition of data constructor ‘Pair’ In the newtype declaration for ‘Pair’
16:07:26 <d34df00d> Have you written it as above or as `MyPair a b`?
16:12:40 <hyiltiz> Nvm; I omitted the (,) on the right earlier; thx
16:38:33 <dsal> hyiltiz: will your monad instance be different from (,)  ?
16:38:43 <hyiltiz> no
16:38:49 * hackage scalpel-search 0.1.0.0 - scalpel scrapers for search engines  https://hackage.haskell.org/package/scalpel-search-0.1.0.0 (fffaaa)
16:42:31 <hyiltiz> Was just doing the exercises in https://wiki.haskell.org/Typeclassopedia
16:46:08 <hyiltiz> Is there a repository showing the exercises results? One can dig up standard implementations but they are usually a few links away, and may be overly complicated for an exercise
16:47:01 <crazyLikeAFox95> can GHC add type annotations automatically? where do I read about that?
16:48:56 <monochrom> It won't edit your source code file, if that's what you mean.
16:49:14 <crazyLikeAFox95> yes that's what I mean, thank you
16:49:33 <dsal> If you have warnings enabled, it'll tell you what you left out.  Or you can use holes.
16:57:36 <crazyLikeAFox95> what's a hole?
16:59:25 <c_wraith> Give something the type _ and you'll get an error message telling you what the actual type is
17:00:14 <crazyLikeAFox95> thanks
17:03:36 <hyiltiz> I just found that `fmap fmap ... fmap` forms a group as long as the number of fmaps are above 5, and with cycle 4. https://termbin.com/lhrw
17:04:23 <Axman6> that's because fmap = (.) so you can compose fmaps as much as you eant
17:04:25 <hyiltiz> I hope something is seriously wrong with this, as I wouldn't expect fmap to ever form a cycle
17:04:30 <Axman6> :t fmap . fmap . fmap
17:04:31 <lambdabot> (Functor f1, Functor f2, Functor f3) => (a -> b) -> f1 (f2 (f3 a)) -> f1 (f2 (f3 b))
17:04:47 <hyiltiz> no but why cycle?
17:04:51 <Axman6> :t fmap  fmap  fmap fmap fmap -- this is equivalent
17:04:53 <lambdabot> Functor f => (a1 -> b) -> (a2 -> a1) -> f a2 -> f b
17:04:58 <hyiltiz> and why cycle after 5?
17:06:08 <nshepperd2> it's not equivalent to composing fmaps
17:06:08 <Axman6> try sitting down and figuring out what the types of each of the fmaps is
17:06:33 <hyiltiz> type of each fmap is in that link above
17:06:56 <Axman6> that's the type of the expression, not of each fmaps in the expression
17:07:05 <Axman6> fmap*
17:08:18 <Axman6> :t (\fmp -> fmp fmap fmap) `asAppliedTo` fmap
17:08:19 <lambdabot> (Functor f1, Functor f2) => (((f2 a -> f2 b) -> f1 (f2 a) -> f1 (f2 b)) -> ((a -> b) -> f2 a -> f2 b) -> (a -> b) -> f1 (f2 a) -> f1 (f2 b)) -> (a -> b) -> f1 (f2 a) -> f1 (f2 b)
17:10:01 <nshepperd2> :t fmap  `fmap` fmap `fmap` fmap -- this would be the same as fmap.fmap.fmap
17:10:02 <lambdabot> (Functor f1, Functor f2, Functor f3) => (a -> b) -> f1 (f2 (f3 a)) -> f1 (f2 (f3 b))
17:10:10 <nshepperd2> but it's not that
17:10:16 <ski> hyiltiz : so .. a monoid ?
17:10:41 <Axman6> :t (\fmp -> fmap `fmp` fmap `fmp` fmap) `asAppliedTo` fmap
17:10:43 <lambdabot> error:
17:10:43 <lambdabot>     • Occurs check: cannot construct the infinite type: b ~ f b
17:10:43 <lambdabot>       Expected type: ((f a -> f b) -> f1 (f a) -> f1 (f b))
17:11:53 <ski> (polymorphic usage)
17:19:35 <nshepperd2> the monoid formed by juxtaposition of formal strings of repeated 'fmap', where strings with the same type are identified
17:22:57 <nshepperd2> alternatively the monoid generated by repeated application of a rewrite rule to '(a -> b) -> f a -> f b'
17:25:00 <Axman6> :t fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap
17:25:02 <lambdabot> (Functor f1, Functor f2, Functor f3) => f1 (a -> b) -> f1 (f2 (f3 a) -> f2 (f3 b))
17:25:08 <Axman6> :t fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap
17:25:09 <lambdabot> (Functor f1, Functor f2, Functor f3) => (a -> b) -> f1 (f2 (f3 a)) -> f1 (f2 (f3 b))
17:25:15 <nshepperd2> i wonder if the cycle of length 4 has anything to with there being 3 levels of functor in '(a -> b) -> f a -> f b'
17:30:11 <koz_> I've been doing a bit of reading about GHC, and I was curious - why do we lower STG to Cmm first, and then generate assembly? Why not go straight from STG to assembly?
17:39:33 <hyiltiz> I understand the first fmap has different type than the whole expression, but I am still puzzled how the expression can even "evolve" into cyclic group once its lengths goes past 5
17:40:00 <hyiltiz> maybe it is relevant to what nshepperd2 said above about monoids 
17:41:26 <hyiltiz> but not all monoids give rise to a cyclic group 
17:46:49 * ski . o O ( ⌜k + ℕ ∕ (m⋅ℕ)⌝ )
18:21:48 * hackage caerbannog 0.6.0.2 - Bit parsing/writing on top of binary.  https://hackage.haskell.org/package/caerbannog-0.6.0.2 (fozworth)
18:45:49 * hackage mealy 0.0.1 - See readme.md  https://hackage.haskell.org/package/mealy-0.0.1 (tonyday567)
18:49:48 * hackage hs-ix 0.2.0.0 - Indexed applicative functors and monads  https://hackage.haskell.org/package/hs-ix-0.2.0.0 (MatthewFarkasDyck)
19:31:48 * hackage stratosphere 0.57.0 - EDSL for AWS CloudFormation  https://hackage.haskell.org/package/stratosphere-0.57.0 (jdreaver)
19:59:37 <koz_> Would it make sense to have a corresponding concept to this, but with a Contravariant f? http://hackage.haskell.org/package/witherable-0.3.5/docs/Data-Witherable.html#t:Filterable
20:40:19 * hackage hal 0.1.5 - A runtime environment for Haskell applications running on AWS Lambda.  https://hackage.haskell.org/package/hal-0.1.5 (nikeoss)
20:51:08 <lemmih> I'm trying to generate HPC reports for my library which has more than a hundred small test programs. Is there an easy way to find the HPC directory used by Cabal?
20:52:34 <justsomeguy> What is contravariance?
20:54:28 <lemmih> Manually running 'hpc report --hpcdir=./dist-newstyle/build/... tix_file' works but I don't know a good way of finding the HPC dir.
21:23:48 * hackage hal 0.2.3 - A runtime environment for Haskell applications running on AWS Lambda.  https://hackage.haskell.org/package/hal-0.2.3 (nikeoss)
21:45:49 * hackage hal 0.3.3 - A runtime environment for Haskell applications running on AWS Lambda.  https://hackage.haskell.org/package/hal-0.3.3 (nikeoss)
22:06:19 * hackage hal 0.4.4 - A runtime environment for Haskell applications running on AWS Lambda.  https://hackage.haskell.org/package/hal-0.4.4 (nikeoss)
23:17:05 <Axman6> :t fmap fmap fmap `asTypeOf` id
23:17:07 <lambdabot> error:
23:17:07 <lambdabot>     • Occurs check: cannot construct the infinite type: b ~ f (f1 b)
23:17:07 <lambdabot>       Expected type: (a -> b) -> f (f1 a) -> f (f1 b)
