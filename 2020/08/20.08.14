00:30:29 <dminuoso> newhoggy: Take note that there is no such requirement.
00:30:37 <hyiltiz> It seems :load is overwriting the modules Text.Show.Pretty loaded in ~/.ghci; is there a sane workaround for persistently doing :set -interactive-print Text.show.Pretty.pPrint?
00:30:49 <dminuoso> The law that `show` produces legitimate Haskell code is limited to GHC derived Show instances by the Haskell report.
00:30:55 <dminuoso> The Haskell report does not demand this for any Show instance.
00:32:02 <maerwald> show is not for serializing data
00:32:17 <dminuoso> hyiltiz: https://downloads.haskell.org/~ghc/8.4.2/docs/html/users_guide/ghci.html#the-ghci-files ?
00:32:49 * hackage dobutokO-poetry 0.10.0.0 - Helps to order the 7 or less Ukrainian words to obtain somewhat suitable for poetry or music text  https://hackage.haskell.org/package/dobutokO-poetry-0.10.0.0 (OleksandrZhabenko)
00:33:47 <newhoggy> The reason for wanting this is makes property testing not pleasant.  Currently our show instance produces code that doesn't compile so property tests spit out strings that are not that useful.
00:40:34 <hyiltiz> dminuoso: so usually people would use ghci somefile.hs to load a module, then :source .ghci right after to bring back the configs?
00:43:49 * hackage niv 0.2.16 - Easy dependency management for Nix projects  https://hackage.haskell.org/package/niv-0.2.16 (nmattia)
00:56:31 <[exa]> Lens question: Having `x::Either String Int`, can I make setters a,b such that `set x a 5` == `Right 5`  and  `set x b "s"` == `Left "s"`
00:58:39 <[exa]> (imho it doesn't break lens laws, does it?)
00:59:55 <dminuoso> [exa]: That's build from prism (the first function)
01:03:08 <[exa]> dminuoso: hm I see.. any chance to make it work with just `set` ?
01:04:28 <dminuoso> [exa]: Well you are trying really hard to discover how prisms are different from lenses, arent you? :)
01:05:06 <dminuoso> [exa]: A prism _Left *contains* that setter
01:05:15 <[exa]> ideally I'd like to use it lens-ish, as if the Either would be nested in some structure... say (set (_1.a) x 5) -> `(Right 5,...)`
01:05:47 <[exa]> seems like I'm missing something very fundamental about prisms
01:06:57 <dminuoso> That is, we could think that: data Lens s t a b = Lens { view :: s -> a, over :: s -> b -> t }, and dually: data Prism s t a b = Prism { build :: s -> a; match :: s -> Either t a; }
01:07:23 <dminuoso> If I do a bit more shuffling, for cuteness:
01:07:36 <dminuoso> data Lens s t a b = Lens { view :: s -> a, over :: (s, b) -> t }
01:07:44 <dminuoso> data Prism s t a b = Prism { build :: s -> a; match :: s -> Either t a; }
01:07:50 <dminuoso> Oops! Wow
01:07:56 <[exa]> shouldn't `build` be :: b->t ?
01:07:57 <dminuoso> data Prism s t a b = Prism { build :: b -> t; match :: s -> Either t a; }
01:07:59 <dminuoso> yes!
01:08:02 <dminuoso> Good catch
01:08:19 <dminuoso> If you line up with lens I hope you can see that this is a real dual.
01:08:29 <dminuoso> Even the product (,) turned into a co-product Either :)
01:10:11 <[exa]> okkkkkkkkay, so now my problem is that I want to magically combine build and set
01:10:49 <[exa]> which should be doable if I generalize my `a` to distinct lens&prism parts
01:11:25 <dminuoso> What do you meanby "magically combine build and set" ?
01:13:07 <[exa]> my original problem was: having `x=((1,Right 1),1)` I want to fill the gap in `set ??? x 'a' == ((1,Left 'a'),1)`
01:13:37 <[exa]> do I get correctly that `set` itself is not sufficient?
01:14:19 <dminuoso> Oh. Then that's just lens stuff after all?
01:17:09 <[exa]> uh I messed up the `set` parameter order, should be `set ??? 'a' x`
01:47:07 <dminuoso> [exa]: I see, so you'd expect the following:
01:47:09 <dminuoso>  % ((1,Right 1),1) & _1 . _2 . _Left .~ 'a'
01:47:11 <dminuoso> % ((1,Right 1),1) & _1 . _2 . _Left .~ 'a'
01:47:11 <yahb> dminuoso: ((1,Right 1),1)
01:47:20 <dminuoso> To produce ((1,Left 'a'),1) ?
01:47:26 <dminuoso> (Or rather, a solution thereof that would do this?)
01:56:19 * hackage hasql-optparse-applicative 0.3.0.6 - "optparse-applicative" parsers for "hasql"  https://hackage.haskell.org/package/hasql-optparse-applicative-0.3.0.6 (NikitaVolkov)
01:59:49 * hackage optima 0.4.0.1 - Simple command line interface arguments parser  https://hackage.haskell.org/package/optima-0.4.0.1 (NikitaVolkov)
02:08:06 <dminuoso> [exa]: I dont think its possible at all.
02:08:20 <dminuoso> The reason is, if you compose these two together, you get an (affine) traversal. 
02:08:42 <dminuoso> The same we'd get if we composed it the other way around. 
02:08:49 <dminuoso> Consider: _Left . _1
02:09:14 <dminuoso> In case of just a raw prism, we can do review
02:09:23 <dminuoso> % review _Left 'a'
02:09:23 <yahb> dminuoso: Left 'a'
02:09:57 <dminuoso> And you can only review Prism, ReversedLens or Iso
02:10:33 <dminuoso> (Or well, a Review)
02:11:11 <dminuoso> In case of lens its Review, Prism, Iso and Equality I guess?
02:11:56 <dminuoso> but the illustrating example why we cant do this in a general case should be `_Left . _1`
02:13:36 <dminuoso> Consider what should `magicSet 'a' (_Left . _1) (Right ())` even do? We can't just manufacture a random tuple knowing just the left side.
02:13:44 <dminuoso> (Im assuming _1 limited to a 2-tuple)
02:15:38 <dminuoso> You could just make a larger prism though. :)
02:33:31 <[exa]> dminuoso: ok that sounds reasonable, the main difficulty was that I didn't find an immediate problem from the lens laws with that construction
02:34:08 <dminuoso> [exa]: Then understand that both `f . g` ahd `g . f` yield the same optic, then that should be enough
02:34:14 <dminuoso> (that is, the same optic type)
02:34:32 <[exa]> basically I wanted some descriptive part of how to set and build at once, now I basically have a=(_1._2, Left) and done. :D
02:35:57 <[exa]> anyway the composability argument with _Left._1 is what I needed, thanks a lot!
02:40:35 <alehander92> is it common to write your own lexer
02:40:37 <dminuoso> [exa]: An alternate way to reason about it, is that in lens the composition is a traversal. How do you `build` with that? P)
02:40:47 <alehander92> i plan on writing a simple recursive function
02:40:59 <alehander92> but i wonder if it's better to preserve "state" in a monad
02:41:03 <alehander92> i think i overthink the monad stuff
02:41:14 <dminuoso> alehander92: So a lexer is just a kind of parser. And writing parsers is common.
02:41:28 <alehander92> yeah, i actually prefered writing parsers
02:41:29 <alehander92> directly
02:41:49 <alehander92> but i do see that having a separate lexer can be ok
02:42:02 <alehander92> i love parser generators
02:42:03 <dminuoso> Sure absolutely. :)
02:42:14 <alehander92> but i want custom error messages, and to showcase a handwritten one anyway
02:42:46 <alehander92> but i am afraid quickly
02:42:54 <alehander92> i'll try to write my own dsl for lexing / parsing
02:43:03 <alehander92> which would be .. less amazing than all the great ones
02:44:49 <[exa]> dminuoso: yeah certainly that's nonsense. :]
02:45:33 <[exa]> alehander92: btw what kind of language are you lexing/parsing?
02:53:48 <alehander92> C :)
02:54:05 <alehander92> but i plan on eventually doing it for others (but i'll probably use a parser gen then)
03:03:25 <bifunc2> My +RTS -p profile is not showing lines of code from 3rd party libraries.
03:03:33 <bifunc2> Is there a way to do this in stack?
03:03:43 <bifunc2> I'd like to see bottlenecks in those libraries.
03:09:32 <[exa]> alehander92: btw there's a working parser already, Language.C... but getting a relatively sane parser for C shouldn't be a problem from scratch
03:13:42 <alehander92> wow.
03:14:55 <alehander92> however i do want to write my own one
03:15:21 <alehander92> to practice for future stuff
03:15:26 <alehander92> and to showcase in resume
03:15:52 <alehander92> but thanks : i'd probably support only a small C-like subset
03:15:57 <juri_> alehander92: the project i run uses a lot of C syntax in it's DSL. you might want to take a peek. https://github.com/colah/ImplicitCAD/tree/master/Graphics/Implicit/ExtOpenScad
03:16:00 <alehander92> so it's an useful resource
03:18:14 <alehander92> juri_ this is an awesome idea: text,code-based cad
03:20:30 <zenzike> hello! I discovered yesterday that was banned from discussion on the reddit channel a couple years ago (perhaps by some overzealous mods), and I'm wondering if anyone here can help unban me? 
03:20:50 <bifunc2> zenzike why bother? just create new accnt
03:21:19 <zenzike> I've had my account for 10 years!
03:23:34 <juri_> alehander92: thanks. there's a few of them nowadays. mine is just the haskell one. :)
03:26:21 <dminuoso> zenzike: https://www.reddit.com/r/haskell/about/moderators/
03:26:27 <dminuoso> Send a direct message to any of those
03:32:36 <alehander92> <3 juri_ thanks 
03:32:50 <alehander92> i wont use parsec immediately, but it's good to see how its structured
03:32:55 <[exa]> alehander92: btw the standard C has a "catch", the grammar is not really context-free because it needs to remember which identifiers are types (or something) because it has an effect on the parsing result of some weirder constructions
03:33:00 <alehander92> because i can do it similarly for my lexer
03:33:09 <alehander92> is it easy to maintain that in production?
03:33:28 <[exa]> alehander92: btw certainly start with megaparsec (it's just better than parsec) or attoparsec (it's a bit simpler and fast af)
03:33:41 <alehander92> exa : i'll start with manual parsec :P
03:33:50 <[exa]> ok :]
03:33:50 <alehander92> i really want to try elm-like messages
03:34:19 <alehander92> and probably i can combine that with a DSL, but i want to start simple first
03:34:45 <alehander92> otherwise this might be true yeah, they lived in different namespaces? or something
03:35:23 <alehander92> the header thing is also interesting: i basically have to interpret them on compile time to expand
03:54:45 <juri_> alehander92: I've had a few issues over the years, but attempts to move to megaparsec or attoparsec have slowed down my parsing.
03:55:05 <juri_> maybe i'm just doing it wrong. :)
03:57:05 <xsperry> compared to original parsec?
03:57:35 <juri_> yep.
04:00:21 <alehander92> hmm
04:09:15 <snbr> how do i deal with switching ghcide between projects with different ghc version?
04:09:27 <snbr> do i have to resintall ghcide every time?
04:10:25 <snbr> or should i keep it inside sandbox of each project?
04:10:51 <dminuoso> direnv?
04:10:55 <[exa]> juri_: too many backtrack points?
04:11:21 <dminuoso> Together with ghcup you can manage this trivially I guess
04:11:31 <snbr> ok thanks
04:17:33 <juri_> [exa]: *shrugs*
04:30:50 * hackage darcs 2.16.1 - a distributed, interactive, smart revision control system  https://hackage.haskell.org/package/darcs-2.16.1 (bfrk)
04:52:57 <justsomeguy> What is the default precedence of function definitions?
04:53:08 <dminuoso> precedence?
04:53:15 <dminuoso> definitions are not expressions
04:53:21 <dminuoso> Does that answer your question?
04:54:44 <justsomeguy> No. You can define a function and give it a fixity declaration, which determines the precedence and associativity. I'm trying to figure out what the default precedence is.
04:55:08 <justsomeguy> For functions that users define themselves.
04:56:33 <justsomeguy> So, phrasing it differently, when you use a function after defining it, without adding a fixity declaration, what would the precedence be?
04:56:47 <dminuoso> infixl 9
04:56:58 <dminuoso> (that holds true for backticked functions as well sa operators)
04:57:16 <dminuoso> Note, you can asign fixity for non-operator as well (even constructors!  this is a useful thing
04:57:40 <dminuoso> There we go, 3.2.2 of the Haskell report
04:57:42 <dminuoso>  If no fixity declaration is given for a particular operator, it defaults to infixl 9. (See §4.4.2 for a detailed definition of the associativity rules.)
04:58:59 <justsomeguy> Thank you dminuoso. :) I was looking for it in the report earlier but couldn't find it.
05:14:19 * hackage essence-of-live-coding 0.2.1 - General purpose live coding framework  https://hackage.haskell.org/package/essence-of-live-coding-0.2.1 (turion)
05:15:19 * hackage essence-of-live-coding-quickcheck 0.2.1, essence-of-live-coding-pulse-example 0.2.1, essence-of-live-coding-pulse 0.2.1, essence-of-live-coding-gloss-example 0.2.1, essence-of-live-coding-gloss 0.2.1 (turion)
05:47:50 * hackage dotenv 0.8.0.6 - Loads environment variables from dotenv files  https://hackage.haskell.org/package/dotenv-0.8.0.6 (stackbuilders)
05:55:35 <maralorn> Is there a cross package way to search for all types that have an instance for a certain class?
05:55:36 <maralorn> I.e. can I search for instances with hoogle?
05:57:56 <maralorn> I am especially wondering (although I am not optimistic) if there are Lift instances for some Parser type. It would be cool since most Parsers one uses are statically known at compile time.
05:59:21 <polux2001> maralorn: maybe try https://haskell-code-explorer.mfix.io/
05:59:30 <polux2001> it's a cross-package code navigation thing
05:59:53 <maralorn> snbr: haskell-language-server has a haskell-language-server-wrapper that automatically starts the correct "haskell-language-server-ghc-(8.8.3|8.6.5)" based on the project you launch it in.
06:03:30 <maralorn> Of course it's not limited to those two ghc versions.
06:03:51 <maralorn> polux2001: Nice, thx. Although it doesn‘t seem to solve my problem.
06:04:52 <polux2001> maralorn: did you mean Lift from template haskell?
06:05:01 <maralorn> I take that back. It works.
06:05:16 <maralorn> polux2001: Yes.
06:05:37 <polux2001> unfortunately for that Lift there doesn't seem to be any parsing-related package
06:06:08 <polux2001> (according to that tool)
06:06:29 <maralorn> Nice, Aeson Value has a Lift instance. That means one can have precompiled JSON in there.
06:10:02 <maralorn> polux2001: That's just stackage right? There is reason to be suspicious. The haskell.love talk mentioned a package which provides Lift instances for everything in containers.
06:10:28 <polux2001> yes it's just stackage, and just LTS 15.4 looks like
06:11:21 <polux2001> maralorn: what talk is it btw? I'm interested
06:11:50 <maralorn> polux2001: Let me look for it.
06:11:55 <polux2001> is it https://www.youtube.com/watch?v=2uD6bCbL1-A?
06:12:26 <polux2001> yeah it must be
06:13:16 <polux2001> du you know about meta-ocaml or hackett ? they both offer something similar in a more native way
06:14:16 <maralorn> polux2001: Yeah, that talk it is.
06:14:16 <maralorn> No, I don‘t know about them.
06:14:42 <polux2001> they are pretty cool, also scheme which is where it is the most used I think, but it is untyped
06:17:50 <ezzieyguywuf> if I have a `myFunc :: Int -> Either String Int`, is there a way to recursively call myFunc with the Right output of the previous call, until a Left is hit?
06:18:12 <ezzieyguywuf> seems almost like scanl
06:18:51 <ezzieyguywuf> hrm, I guess not really
06:20:12 <polux2001> ezzieyguywuf: I think you want iterateM
06:20:38 <polux2001> (not sure from which package)
06:23:31 <polux2001> ezzieyguywuf: there are also many variants of monadic loops in https://hackage.haskell.org/package/monad-loops-0.4.3/docs/Control-Monad-Loops.html
06:25:12 <MarcelineVQ> ezzieyguywuf: you can also write it yourself :D
06:26:01 <maralorn> ezzieyguywuf: It's a oneliner I needed myself a few days back. You can have it from monad-loops or just write it yourself.
06:26:12 <polux2001> ezzieyguywuf: actually monad-loops has iterateM_
06:26:15 <polux2001> which does what you want
06:26:17 <ezzieyguywuf> polux2001: maralorn: maralorn: thanks, I'll look at these
06:26:26 <ezzieyguywuf> 👍
06:28:06 <MarcelineVQ> maralorn: it's kind of an interesting looking one liner too
06:33:10 <maralorn> iterate action input = iterate =<< action input
06:33:52 <maralorn> Thats one I used.
06:36:08 <ezzieyguywuf> maralorn: I'll have to spend some time wrapping my head around that...
06:36:13 <ezzieyguywuf> and reading up on =<<, lol
06:36:58 <maralorn> ezzieyguywuf: I most admit I am not even sure that it does what you need …
06:37:38 <ezzieyguywuf> maralorn: 😂
06:37:50 <maralorn> But I think it could have the type "Either String Void" so it aught to be doing what you want.
06:39:32 <justsomeguy> I just found "Haskell for Imperative Programmers" on YouTube and it's amazing :D
06:41:56 <MarcelineVQ> ah mine was less general  bif :: (a -> Either b a) -> a -> Either b a; bif f n = either Left (bif f) (f n)   and I thought the bif f  f n looked kinda neat
06:42:23 <maralorn> ezzieyguywuf: I made a small mistake. It needs to be "iterate action input = iterate action =<< action input". But that works.
06:43:27 <fendor_> isn't it actually basically iterateM?
06:43:33 <fendor_> @type iterateM
06:43:35 <lambdabot> error:
06:43:35 <lambdabot>     • Variable not in scope: iterateM
06:43:35 <lambdabot>     • Perhaps you meant one of these:
06:44:12 <ezzieyguywuf> maralorn: I was wondering, b/c the number of arguments didn't match up
06:44:14 <fendor_> ah, what I was thinking of was iterateN, iterateM does not seem to exist.
06:44:20 <maralorn> fendor_: Yeah, it is. But I didn‘t want to import monad-loops
06:44:40 <fendor_> makes sense
06:44:47 <fendor_> or monad-extras
06:46:03 <ezzieyguywuf> MarcelineVQ: what does bif mean? lol.
06:46:39 <ezzieyguywuf> also I didn't mention I wanted to collect the results along the way, but this sets me in the right direction I think I have the tools needed to solve the problem
06:46:41 <MarcelineVQ> Nothing beyond being a name for that definition
06:48:15 <ezzieyguywuf> probably something like whileM from monad-loop
06:49:58 <maralorn> ezzieyguywuf: You want to get [Int] when the first Left occurs?
06:51:41 <ezzieyguywuf> maralorn: yea. in fact, I have a slightly more complex predicate I'd like to change: bail out when Left OR a duplicate value occurs
06:51:58 <ezzieyguywuf> urm, s/change/use/
06:52:15 <ezzieyguywuf> but again,  I think I have the building blocks here, just need to put them together
06:52:30 <maralorn> Yeah. Have fun!
06:52:57 <polux2001> looks like you want something like the monadic version of findFixedPoint if that exists somewhere :)
06:53:34 <ezzieyguywuf> polux2001: I'll look at findFixedPoint for inspiration
06:53:45 <polux2001> I made up the name
06:53:50 <polux2001> but that's what it does
06:53:52 <ezzieyguywuf> lol, just realized that
06:53:52 <polux2001> seems like
06:54:31 <maralorn> polux2001: But it's true. I actually first looked at "fix" from base and then looked for "fixM".
07:05:19 * hackage hapistrano 0.4.1.2 - A deployment library for Haskell applications  https://hackage.haskell.org/package/hapistrano-0.4.1.2 (juanpaucar)
07:06:19 * hackage azimuth-hs 0.2.1 - Interact with Azimuth from Haskell  https://hackage.haskell.org/package/azimuth-hs-0.2.1 (JaredTobin)
07:17:39 <frdg``> I have the function: `func :: Int -> [Foo] -> [Bar] -> [Foo]; func n foos | n > tooMany = do; whatever`. I have never seen a pattern match statement that looks like this with the `|` symbol. What does this mean?
07:21:22 <glguy> frdg``: | starts a "guard"
07:22:04 <frdg``> ohh. I understand.
07:22:04 <glguy> There are boolean guards, pattern guards, and let guards
07:23:11 <frdg``> I am not familiar with pattern guards and let guards.
07:24:30 <glguy> Boolean guards let you check for a True
07:24:41 <glguy> pattern guards let you check for matching against any pattern
07:24:58 <glguy> f x | Just y <- readMaybe x = y + 1 | otherwise = 0
07:25:33 <glguy> putting in fake parentheses thats: f x | {{Just y <- readMaybe x}} = y + 1 | otherwise = 0
07:25:50 <glguy> the {{}} part is  readMaybe x being matched against the pattern Just y
07:26:01 <glguy> if that matches then the y + 1 definition is used
07:26:10 <frdg``> glguy: is this what is used in list comprehensions?
07:26:40 <glguy> Yeah. List comprehensions had that before it was added to the guard syntax of definitions
07:27:31 <frdg``> I understand. What about let guards?
07:27:58 <glguy> those don't guard anything, they just allow you to define some new identifiers for use in further guards
07:28:19 <glguy> f x | let x2 = x * 2, even x2 = "stuff"
07:28:29 <glguy> again like you can do in list comprehensions
07:28:41 <frdg``> thats crazy
07:29:20 <frdg``> Thats a whole other way you can think. I never knew about this.
07:32:13 <polux2001> It's a bit like having on if (or a case of) in the right-hand side of the equal sign, except it lets you fall back to the second clause of the equation set, which lets you avoid nesting and also lets you factorize some pattern matching. For instance f (P1 ...) y | (P2 ...) <- y = a | (P3 ..) <- y = b
07:32:22 <polux2001> saves you repeating the (P1 ...) part
07:32:51 <polux2001> although wait, that would be true with a case .. of on the rhs
07:32:57 <polux2001> so really what it avoids is nesting
07:33:57 <MarcelineVQ> glguy: you can do that? :X
07:34:55 <MarcelineVQ> wait till the bigwigs on the board hear about this
07:35:22 <frdg``> If I had known about this a week ago I would have done something a lot different.
07:36:14 <polux2001> :)
07:55:49 * hackage kubernetes-webhook-haskell 0.2.0.3 - Create Kubernetes Admission Webhooks in Haskell  https://hackage.haskell.org/package/kubernetes-webhook-haskell-0.2.0.3 (amarrella)
08:06:55 <tomjaguarpaw> Does anyone know what to do about "hLock: invalid argument" from cabal with GHC 8.10 on WSL?
08:09:08 <maerwald> tomjaguarpaw: https://github.com/haskell/cabal/issues/6551
08:09:11 <maerwald> ?
08:10:09 <maerwald> sm: those are the reasons I don't consider windows properly supported :p
08:10:58 <tomjaguarpaw> Hmm, could be, but mine definitely says hLock.
08:11:13 <tomjaguarpaw> Still, this is a problem that comes and goes on WSL.
08:11:34 <tomjaguarpaw> Using GHC 8.8.4 seems to be fine, so I don't think it's a cabal problem.
08:32:45 <sm[m]> maerwald: indeed, but I think my point still stands: I was able to ship cross platform apps with consistent easy build procedure, which I don't know how to achieve with other languages, and it seems to me haskell does reasonably well on this compared to other languages 
08:33:54 <maerwald> sm[m]: well, what are the competitors? Java (better), C# (better), C++ (not "cross" in the traditional sense, but works anywhere)
08:34:40 <sm[m]> yes I assume java and C# can do it. Maybe go ? But I hear they just punt on a lot of things
08:35:54 <sm[m]> even with java and c#, I wouldn't be surprised if the steps are more complicated than 1. download stack, 2. stack install ...  (how do I get the right java runtime installed..)
08:36:13 <maerwald> and then stack installs an outdated msys2 and things go haywire
08:36:50 <maerwald> then someone points them to chocolatey and users get confused
08:36:53 <maerwald> :p
08:45:08 <sm[m]> maerwald: I think you're reaching for problems here. I'm just saying, you can make software that will install and run well in a simple way. 
08:45:31 <maerwald> sm[m]: the outdated msys2 was one of the reasons they created chocolatey packages
08:45:58 <sm[m]> I've never heard of this problem, so I don't think it affects my users or my point
08:46:54 <maerwald> that's a "works for me" argument
08:47:26 <maerwald> I'm not sure that's enough when evaluating cross platform quality of an ecosystem
08:48:32 <sm[m]> I've tried to carefully speak about a specific limited scope: installing and running a piece of software, and a specific limited claim: it's relatively quite good
08:48:32 <ezzieyguywuf> TIL about pattern guards.
08:48:49 <sm[m]> that's my experience, so otherwise we'll just have to agree to disagree
08:49:24 <maerwald> sm[m]: it's good to consider different experiences
08:49:51 <maerwald> I don't have any on windows, I just see what ppl report
08:52:22 <sm[m]> Yup. Your users must be doing something different than mine!
08:53:10 <maerwald> Like... using GHC? How many version are non-broken on windows? :p
08:53:43 <maerwald> I don't even know, but I know some are not to be used on windows
08:54:06 <sm[m]> maerwald, I'm speaking of people using stack. Maybe that's the difference
08:54:31 <maerwald> so stack does not include any such version that is semi-broken in windows?
08:55:24 <dolio> Wasn't there just someone in here a couple days ago that had that exact problem?
08:59:33 <merijn> ezzieyguywuf: Most underappreciated feature of Haskell2010 :p
09:00:54 <ezzieyguywuf> merijn: I think it's really neat!
09:01:26 <sm[m]> maerwald: yes eg GHC 8.8.3 is broken on windows, but I can still give a simple command that works for windows users (--resolver lts-15.3). Still a pretty good experience compared to a lot of languages IMHO
09:02:07 <sm[m]> or what I actually do, provide a windows binary
09:02:23 <maerwald> merijn: I think many ppl don't know that they can use it in case expression
09:03:00 <maerwald> at least I see it rarely, even if it would be valid
09:03:23 <yushyin> yup that surprised me at first
09:05:33 <maerwald> sm[m]: not an installer?
09:06:06 <sm[m]> I provide one of those too
09:06:31 <maerwald> GHC devs need someone to maintain an installer for GHC :p
09:08:02 <ezzieyguywuf> maerwald: isn't that what ghcup does?
09:08:26 <monochrom> No. ghcups and chocolatey, but not ghcup.
09:08:38 <maerwald> ezzieyguywuf: it has no windows support atm
09:09:46 <sm[m]> but.. by installer I mean a bash script (based on stack's install script). Not a windows installer. (No need for one!)
09:10:02 <maerwald> and I think windows users expectations are a little different, so I'm not sure it makes a lot of sense for them
09:11:26 <monochrom> The only disease of chocolatey is, on the instruction page you can easily find, "step 1: subscribe to my mailing list".
09:11:28 <ezzieyguywuf> I somehow got stack setup in windows the other day very painlessly
09:11:32 <ezzieyguywuf> and then let it set up ghc
09:11:50 <monochrom> Yes that works too.
09:14:08 <itai33[m]> does anyone here have experience using the cursor package? are there real benefits to using that model over a list and a pointer?
09:14:13 <ezzieyguywuf> is there a way to use fmap on a list that sometimes drops a value? i.e. kind of like catMaybes, but with `data MyData = A Int | B Int` where I only want the A's
09:15:31 <monochrom> I don't know cursor, but I guess a big differenece is cursor actually exists, "pointer" doesn't.
09:15:49 <itai33[m]> @mono
09:15:49 <lambdabot> Maybe you meant: todo more
09:15:50 <itai33[m]> shit
09:16:00 <solonarv> ezzieyguywuf: are you looking for mapMaybe?
09:16:24 <itai33[m]> monochrom: i'm not sure what you mean about the cursor not existing, do you mean the type safety of not having a pointer point at a position that doesn't exist?
09:16:35 <itai33[m]> pointer*
09:16:40 <solonarv> mapMaybe (\case A x -> Just x; _ -> Nothing) :: [MyData] -> [Int]
09:16:58 <monochrom> OK, show me Haskell code that uses "pointer".
09:17:19 <ezzieyguywuf> solonarv: I don't think so. catMaybe is implemented as "catMaybes ls = [x | Just x <- ls]", I think I want "[x | A x <- as]"
09:17:31 <solonarv> then just write that!
09:17:40 <ezzieyguywuf> solonarv: I'll just spend some time desugaring that list comprehension to make sure I understand what's going on...
09:17:41 <solonarv> but also, I said mapMaybe, nto catMaybes
09:18:27 <ezzieyguywuf> solonarv: ah, I see. I could define my predicate to return Just when A, or Nothing otherwise
09:18:47 <solonarv> yes, exactly
09:18:50 <itai33[m]> monochrom: like a `Data ListPointer a = LP [a] Int` where the Int refers to a position on the list
09:18:58 <solonarv> (which is what I did in my example)
09:19:27 <ezzieyguywuf> solonarv: got it. I think I'd prefer that, the catMaybe approach seems to rely (I think) on `fail`, which my gut tells me is somewhat unsafe
09:19:52 <solonarv> it's perfectly safe
09:19:57 <ezzieyguywuf> i.e. when `do Just x <- ls` doesn't match, I guess the monad bails out somehow right? but I haven't seen this approach used very often
09:20:07 <itai33[m]> the issue with that is that if the `Int` is something outside of the list you start to have issues and need to fix it everywhere, while in cursor you just have `Data Cursor = Cursor [a] a [a]`
09:20:12 <solonarv> yes, it bails out somehow (depending on the monad)
09:20:12 <itai33[m]> (for nonempty lists anyway)
09:20:33 <solonarv> since GHC 8.6, the desugaring uses the 'fail' in the MonadFail typeclass
09:20:36 <ezzieyguywuf> solonarv: and that results in a runtime error doesn't it? i.e. like `head []`
09:20:50 <itai33[m]> so you by definition can't reprisent illegal states  but now repositioning the focus seems much more expensive for larger lists
09:20:51 <solonarv> no, that typeclass only has instances for monads that have a sensible notion of failure
09:20:55 <glguy> ezzieyguywuf: What happened when you tried?
09:20:57 <itai33[m]> monochrom: 
09:20:58 <monochrom> So firstly that confesses that you acknowledge that there is no pointer, you're making your own new convention to emulate it.
09:21:08 <itai33[m]> oh yeah
09:21:23 <ezzieyguywuf> glguy: you caught me, haven't tried it yet. just trying to logic my way through it.
09:21:23 <solonarv> (it used to be the way you are describing, but it isn't anymore)
09:21:24 <itai33[m]> sorry for using the wrong terminology I say people refering to it like that online
09:21:31 <monochrom> Secondly xs!!n take Ω(n) time. That's not what pointers do.
09:21:45 <ezzieyguywuf> ahhh. I've been seeing MonadFail sprinkled around and haven't taken the time to read up on it.
09:21:59 <solonarv> > fail "boom" :: [Int]
09:22:01 <lambdabot>  []
09:22:12 <ezzieyguywuf> 😍
09:22:30 <itai33[m]> but repositioning the ""pointer"" now takes O(n) time instead of O(1)
09:22:34 <solonarv> (note that this was always the case, even before the MFP (MonadFail proposal) changed things)
09:22:56 <solonarv> the problem before MFP wasn't that 'fail' was always unsafe, but that it was defined for *all* monads, even though it shouldn't have been
09:24:43 <solonarv> > runReader (fail "boom") 42
09:24:45 <lambdabot>  error:
09:24:45 <lambdabot>      • No instance for (MonadFail Identity) arising from a use of ‘fail’
09:24:45 <lambdabot>      • In the first argument of ‘runReader’, namely ‘(fail "boom")’
09:24:59 <solonarv> behold a type error! as it should be!
09:25:07 <itai33[m]> monochrom:  honestly my other concern might be a bit more relevant, which is that the cursor package has like no documentation which worries me about it's usability in practice
09:25:27 <itai33[m]> I'd imagine O(n) vs O(1) doesn't matter all that much if your lists are under 1000 elements
09:25:49 <solonarv> yeah, that's a good rule of thumb
09:26:26 <itai33[m]> however now that I think about it I might have to deal with much larger lists as well, so it might not be worth it to use the more "type safe" option
09:26:35 <ezzieyguywuf> solonarv: yes, I'm reading through the MonadFail proposal, this makes much sense!
09:27:40 <itai33[m]> like the reason i'm asking all this is because I want to make a brick tui app where you have your cursor on a list, and that list will usually be short but might sometimes be rather long
09:27:56 <dolio> itai33[m]: Did you read the series of blog posts explaining cursors that is linked from the cursor package?
09:28:03 <itai33[m]> yes
09:29:16 <itai33[m]> dolio: did they have a section about performence? I must have missed that
09:31:16 <itai33[m]> like the blog posts do a great job explaining the concept, but the library itself has a bunch more stuff and seemingly no documentation
09:33:12 <dolio> Well, anothing keyword you can look for is 'zipper', which is essentially the same thing, but has been around as a concept for much longer.
09:33:12 <nshepperd2> itai33[m]: do you need to modify the list frequently? if not, you might be better off with an array and an Int
09:33:23 <dolio> Another, even.
09:33:33 <itai33[m]> even?
09:33:47 <dolio> I meant "another" not "anothing".
09:34:07 <itai33[m]> yeah I still don't really understand the meaning
09:34:30 <dolio> https://www.st.cs.uni-saarland.de/edu/seminare/2005/advanced-fp/docs/huet-zipper.pdf
09:34:36 <dolio> That is the original zipper paper, I believe.
09:34:42 <itai33[m]> nshepperd2: in some cases yes, in other cases the main thing I modify is the position on the list, is using an array still relevant there?
09:36:20 <itai33[m]> @dolio
09:36:20 <lambdabot> Unknown command, try @list
09:36:21 <itai33[m]> shit
09:36:36 <itai33[m]> dolio: thanks!
09:37:21 <nshepperd2> itai33[m]: if you're mostly just moving around the list and reading whatever is at the "current" position, an immutable array is probably ideal 
09:37:47 <itai33[m]> nshepperd2: when you say array, do you mean a list or an array?
09:37:55 <itai33[m]> cause there is such a thing as an array in haskell I think
09:37:56 <nshepperd2> i mean https://hackage.haskell.org/package/vector
09:38:05 <itai33[m]> gotcha
09:38:08 <tomsmeding> or https://hackage.haskell.org/package/array
09:38:52 <tomsmeding> or https://hackage.haskell.org/package/massiv :)
09:38:59 <tomsmeding> though that's overkill here
09:39:07 <dolio> Yes, the presumption with zippers is that you are incrementally moving around and editing the structure.
09:39:18 <itai33[m]> what what's the difference between Vector and Array
09:44:12 <tomsmeding> honestly not sure, but from reading a bit here and there, it seems 'vector' is newer and higher-level, and should be easier to use
09:44:40 <itai33[m]> yeah honestly after asking I realized I should probably just google it and google seems to say the same thing
09:44:41 <tomsmeding> and thus preferable over 'array' unless you need something specific that only 'array' offers (unlikely)
09:45:10 <itai33[m]> also are these types of questions welcome here or should I ask them at haskell-beginners? I'm unsure where the line is drawn
09:47:54 <nshepperd2> yeah i think vector is easier to use. the main advantage of array is it supports different indexing systems (multiple dimensions, 1-based indexing, etc)
09:48:00 <nshepperd2> also vector's docs are better :)
09:48:13 <itai33[m]> I do love having good docs
09:48:27 <itai33[m]> and I don't need the fancier array stuff so vector it is I think
09:48:50 <solonarv> vector also just has a bigger API, there are functions 'vector' has where 'array' lacks the pendant
09:49:17 <solonarv> of course you can always improvise it or implement it yourself, but that's still an inconvenience!
09:49:41 <solonarv> itai33[m]: btw, beginner questions are totally fine here
09:49:48 <itai33[m]> neat
09:50:00 <itai33[m]> so why does haskell-beginners exist
09:50:14 <itai33[m]> so questions don't get lost in the wind?
09:50:23 <glguy> Primarily because someone wanted to sell a book with it, but now it's just a lower bandwidth channel
09:50:29 <solonarv> I think it was originally made to promote some book or course? but yes, that's mostly its point now
09:51:03 <solonarv> if you ask a beginner question there it's less likely to be drowned out by discussion of zygohistomorphic prepromorphisms or whatever :p
09:51:13 <itai33[m]> I think that would be haskell from first principles
09:51:25 <MarcelineVQ> idk if that's really the case, but it is a quieter room, both in the sense that questions can be seen but also that questions aren't answered by as many people at once
09:51:47 <MarcelineVQ> 'that' being the 'started to sell a book'
09:52:18 <MarcelineVQ> Which is a benefit because you're not getting told 2 truth and 5 analogies at once
09:52:21 <itai33[m]> honestly if you don't want to see discussions of zygohistomorphic prepromorphisms why even bother learning haskell
09:54:19 <solonarv> oh hey the channel topic in #haskell-beginners even reflects that now
09:54:26 <solonarv> (not that anyone reads those :p )
09:54:52 <itai33[m]> (i do!)
09:55:39 <monochrom> I believe for at least 5 years now every literal mention of "zygohistomorphic prepromorphisms" have been only this kind of jokes.
09:55:55 <itai33[m]> wait are those a real thing
09:56:07 <itai33[m]> I thought it was just made up techonobabble
09:56:49 <monochrom> No one has seriously discussed it for that long. Instead, two actual examples of advanced discussions are optics and dependent typing.
09:57:49 <glguy> They are real, made-up technobabble
09:58:03 <itai33[m]> the best kind
09:58:23 <monochrom> I propose this new joke: drowned out by discussion of type-level profunctors.
09:58:52 <itai33[m]> wait it seems that Data.Sequence also provide sublinear time for access to inner elements, are they worse than Vector for some reason?
09:59:25 <monochrom> Seq is still lg time for a few things that Vector is constant time.
09:59:35 <itai33[m]> like what?
09:59:48 <itai33[m]> wait does vector have constant time acess to elements?
09:59:50 <monochrom> Also, even where Seq is constant time, it's a big constant, unusually big compared to other constants.
09:59:57 <monochrom> a!n
10:00:08 <monochrom> clearly
10:00:16 <monochrom> Have you finished 1st-year CS?
10:00:32 <kuribas> I've rarely found a need for sequence.
10:00:46 <glguy> In theory asymptotic complexity matters, in practice constant factors do
10:00:50 <itai33[m]> I'm a graduate math/physics student all my CS knowledge is informal
10:00:53 <monochrom> Because "array vs linked list" is standard 1st-year CS matter, and like I said yesterday 20%-40% of questions in #haskell are answerable by just that.
10:01:09 <monochrom> Today you add a data point that pushes further towards the 40% side.
10:01:10 <kuribas> glguy: in practice asymptotic complexity also matters.  
10:01:17 <kuribas> glguy: it's just not the whole story.
10:01:20 <glguy> thanks
10:01:33 <itai33[m]> oops
10:01:45 <nshepperd2> vector is based on actual arrays, yes
10:01:54 <itai33[m]> guess I should go brush up on that entire topic
10:02:19 <dmj`> lambdabot might need a stack overflow plugin or something
10:02:27 <kuribas> glguy: some of the code we rewrote would loop over a linked list using indexing :)
10:02:39 <monochrom> But perhaps you can take consolation from that I also said this:
10:03:11 <monochrom> "except it doesn't count if your 1st-year CS is exclusively python, because it keeps you dumb on array vs linked list"
10:03:26 <itai33[m]> lol
10:03:33 <itai33[m]> honestly I know more haskell than I do python
10:04:13 <kuribas> is there something inherently hard about impredicative polymorphism, or is it not supported because of legacy reasons?
10:04:14 <itai33[m]> like I got into it in the first place because I have a friend who was like "dude it's like category theory but in a programming langauge"
10:04:27 <dolio> Quite a lot of languages don't really introduce you to linked lists, I think.
10:04:30 <monochrom> It is OK to choose the slower way if you know that it is slower but it buys you easier coding.
10:04:47 <monochrom> It is just not OK to not know what you're choosing.
10:04:53 <itai33[m]> makes sense
10:05:17 <itai33[m]> I mainly want to know what all the options are so if it turns out to be a bottleneck later I know what to look up to switch to
10:05:27 <itai33[m]> but this is honestly probably bikeshedding
10:05:36 <itai33[m]> interesting theoretical topic tho
10:05:51 <hyiltiz> From HMatrix, Vector and qlinear etc. listed here https://wiki.haskell.org/Libraries_and_tools/Mathematics#Linear_algebra what would best suit for a talk normally done in Octave? A lot of matrix multiplication, svd, craating special matrices, mutating rows/columns, some simple line and heatmap plots, read write to file etc.
10:06:12 <hyiltiz> s/talk/task
10:07:42 <sm[m]> I feel we've never had a true haskell beginners channel. #haskell-beginners used to quickly become advanced just like #haskell
10:08:14 <monochrom> kuribas: I think it did not fit into the OutsideIn(X) algorithm that GHC uses. (And OutsideIn(X) is so successful at everything else that GHC does, it's hard to give up.)  But recently they figured out a solution.
10:08:19 <sm[m]> perhaps beginner has different definitions
10:08:40 <kuribas> monochrom: I am just wondering if I should support it for my language.
10:09:43 <monochrom> If you don't have type inference, only type checking, you should.  If you have type inference, it's likely a rabbit hole.
10:10:00 <kuribas> monochrom: I have type inference for non-polymorphic types.
10:10:11 <kuribas> monochrom: and I support polymorphic types with signatures
10:10:17 <hyperisco> sm[m], it is more like a second channel for when this one is busy
10:10:19 <monochrom> For example System F works great because programmer has to hand-write so many types, there can't be confusion. :)
10:10:24 <sm[m]> ..and Haskell world has so many possible challenges it's not so easy to set a clear scope for a beginners channel
10:10:39 <monochrom> Oh! Hrm, now that's an interesting middle point I haven't thought of.
10:10:44 <sm[m]> hyperisco: yeah, which is misleading and a pity
10:11:33 <hyperisco> is there some failing? I don't see the problem
10:11:34 <monochrom> Upon 5 seconds of instinct (so take it with a grain of salt) I think you can easily support impredicativity.
10:11:46 <monochrom> (on the ground of handwritten polymorphic types)
10:12:17 <sm[m]> hyperisco: it's an unclear situation for a beginner seeking help
10:12:40 <dolio> kuribas: There are algorithms and type system modifications that support impredicativity more easily. However, combining those approaches with other stuff in GHC might be challenging.
10:12:44 <nshepperd2> impredicative types make my head hurt
10:13:09 <kuribas> dolio: so I am fine in my language, if I don't need GADTs and stuff?
10:13:40 <dolio> Depends what all you have.
10:13:54 <dolio> For instance, one challenge is implementing type classes.
10:14:10 <kuribas> dolio: rank-n types, refinement types and type classes
10:14:38 <dolio> Impredicativity requires a fundamentally different approach to type class implementation than usual.
10:14:48 <monochrom> yikes
10:15:19 <monochrom> On the flip side, how desperately do you want to support impredicativity? What benefits would you get?
10:15:46 <kuribas> monochrom: not that much, but I thought it would be a nicer fit with refinement types.
10:15:52 <monochrom> Because to a large extent it confuses users too. (It just doesn't confuse the computer given handwritten types.)
10:16:48 <monochrom> To be fair, predicativity confuses users too.
10:17:14 <dolio> Basically you need to implement your type classes as if you were doing MLF.
10:17:32 <monochrom> Is that ML functors?
10:18:15 <dolio> No, it is a type system with additions that can support encodings of rank-n types.
10:18:46 <dolio> But those are expresed as bounded quantifiers rather than actual rank-n types.
10:18:55 <monochrom> Ah, "MLF type system" is a successful googling. thanks.
10:19:10 <dolio> It actually has principal types, I think, unlike System F.
10:19:16 <monochrom> haha "raising ML to the power of system F", is that going for ML^F?
10:19:40 <dolio> Yeah, sometimes the F is written as an exponent.
10:21:18 <dolio> Anyhow, the problem is something like...
10:22:21 <monochrom> Ooohhh, so the paper "ML raised to the power F" is the seminal paper for MLF. Then you can follow up with "qualified types for MLF" for how to add type classes. (Caveat: I have only read the abstracts!)
10:22:33 <dolio> With impredicative types, you might have `List (forall a. a -> a)`. Then you cons on something with type `forall a. C a => a -> a`. That's valid, because the unconstrained type is a subtype.
10:22:59 <dolio> However, the calling convention of the former doesn't match. The unconstrained type doesn't expect a dictionary.
10:23:36 <dolio> You can also instantiate to `Int -> Int`, which is also a different calling convention.
10:24:07 <kuribas> dolio: so it's harder to do at runtime?
10:24:27 <dolio> So, impredicativity can involve these kinds of dictionary tweaks arbitrarily far under an unknown term, which is bad.
10:24:36 <kuribas> my inference algorithm seems to support the example at the top.  https://gitlab.haskell.org/ghc/ghc/-/wikis/impredicative-polymorphism
10:24:51 <kuribas> I haven't thought about dictionaries yet.
10:25:00 <dolio> So, what you want to do is factor the dictionary passing all the way out to the top level.
10:26:04 <kuribas> dolio: can these dictionary types be rewritten to function types?
10:27:23 <dolio> I'm not sure what you mean.
10:28:34 <kuribas> dolio: I mean, C a => a -> a could become (cDict -> a) -> (cDict -> a)?
10:30:13 <dolio> No, it would be like `C a -> a -> a`.
10:31:12 <monochrom> And "C a -> a -> a" has a different calling convention from "a -> a", I think that's what dolio is explaining.
10:31:21 <dolio> Right.
10:31:31 <kuribas> So you would need to convert C a -> a -> a to (C a -> a) -> (C a -> a) before passing it?
10:31:46 <dolio> But there's generally supposed to be a subtype relation.
10:33:14 <dolio> https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/qmlf.pdf
10:33:21 <dolio> That's the paper describing what I'm talking about.
10:34:17 <monochrom> Haha, paragraphs 2-4 of the introduction are great. (I am not sure whether I'm sarcastic or impressed, read on.) You can basically reuse it for every inferrable type system paper.
10:34:27 <monochrom> Here is what they are like:
10:34:51 <dolio> MLF's way of doing things makes it pretty easy, though. I think it will be less easy if your type system is less like MLF.
10:34:54 <monochrom> Actually add paragraph 1 to that.
10:37:08 <monochrom> Paragraphs 1-2: Static typing is good, but can stumble programmers from two opposite sides. One side: hand-writing types is a burden; the othr side: types rule out some perfectly fine programs.
10:38:01 <monochrom> Paragraph 3: Fortunately we know how to mitigate either. Type inference to help the former, more expressible type systems to help the latter.
10:38:12 <kuribas> dolio: I think I'll forbit putting foralls in type constructors.
10:38:16 <monochrom> Paragraph 4: Unfortunately, these two reliefs are in conflict.
10:39:01 <monochrom> See how beautifully up to now everything said applies to every type inference system, nothing particularly specific to either HM or System F? :)
10:40:45 <maerwald> you forgot: opt-in types
10:41:40 <monochrom> I think opt-in types cheat and opt-out of the issue rather than confront it.
10:43:09 <monochrom> And whenever you do opt-in, you're under the said dilemma again.
10:44:27 <justsomeguy> Whenever I see people suggest gradual typing, I just think that it would be a better strategy to have more polymorphic types.
10:45:10 <monochrom> Hell, let me make it more spicy. s/opt-out/chicken-out/ .  THERE!
10:45:45 <maerwald> I think the main problem with more expressive type systems isn't even type inference. It's intellectual complexity. Whenever you read such code, you either don't understand it (bad) or you do, but spent half your energy on understanding it (bad too)
10:45:50 <monochrom> Joining the army is tough. The recruited have to do thousands of push-ups and jog thousands of miles.  40 hours every day.  I know I won't make it.
10:46:22 <monochrom> But no one, not even me, say "a solution is to not join the army".  The toughness still exists for those who join.
10:46:48 <monochrom> I don't join the army, and this counts as chickening out.
10:47:14 <monochrom> Also in terms of Chinese zodiac I'm a rooster, so it's actually OK!
10:47:39 <maerwald> I'm a tiger, don't they eat roosters?
10:48:02 <monochrom> Yes but we're in Eden harmony!
10:48:31 <kuribas> dolio: what I change (forall a. C a => a -> a) -> Int  into (forall a. a -> a) -> Int
10:48:59 <kuribas> dolio: it type checks, but still has a different calling convention
10:50:08 <kuribas> of if I apply "(forall a. Num a => a -> a) -> Int" to "id"
10:50:33 <kuribas> dolio: that looks like the same problem you described above?
10:51:28 <dolio> Yes, it is the same problem.
10:51:51 <dolio> GHC recently made it so that that subtyping is invalid.
10:52:22 <monochrom> I think that developing an expressive type system of reasonable intellectual complexity is worthwhile.
10:52:26 <dolio> Previously it did eta expansions to fix up those cases.
10:52:40 <dolio> But it's even harder in e.g. a list.
10:52:41 <kuribas> dolio: why did they stop that?  Was it buggy?
10:52:58 <dolio> Because in a list, you have to map over all the elements to fix things up.
10:53:26 <monochrom> Research papers tend to push out unreasonable high complexity because it is research, it is tossing it out there in hope that other people can improve it or learn the negative lessons from it.
10:53:30 <dolio> kuribas: Eta expanding is not semantics-preserving.
10:54:21 <dolio> GHC actually had to do it in situations that don't even involve classes.
10:54:26 <monochrom> It all works out at the end. You see that unreasonably high complexity doesn't survive in languages people use, or even bother to write interpreters for.
10:55:02 <monochrom> Even ATS, it has an implementation at all only because a madman wrote it. :)
10:55:02 <dolio> Because the core level is typed, and type application is explicit, so shuffling around the explicit type applications to mediate between equivalent types could involve eta expanding actual value arguments.
10:55:17 <dolio> So it just got rid of all that.
10:55:20 * hackage qrcode-juicypixels 0.8.2 - Converts a qrcode-core image to JuicyPixels  https://hackage.haskell.org/package/qrcode-juicypixels-0.8.2 (alexkazik)
10:56:02 <monochrom> And you see how System F is basically unimplemented apart from code that comes with TaPL to let you do homework.
10:56:21 <monochrom> OK, and apart from GHC using it for itself.
10:56:47 <justsomeguy> ATS is a wonderful t@ype of madness. :-)
10:57:05 <dolio> Technically speaking, it's really the subtyping that is the problem with higher-rank types and type classes. I'm not sure i have examples where impredicativity makes it worse.
10:57:55 <dolio> Maybe I could come up with one if I thought about it. Impredicativity mainly requires different trade-offs for the inference algorithm that GHC was not willing to make.
10:58:50 <fendor_> is the module hiding of ghc supported in cabal? https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/packages.html?highlight=package%20id#package-thinning-and-renaming
10:59:49 <fendor_> e.g. I want to hide any imports from ghc, but I still want to be able to have different exposed-modules based on the ghc version
11:01:02 <fendor_> s/imports/modules exposed/
11:02:01 <monochrom> fendor_, my understanding is that this feature is to support backpack. So to trigger it via cabal you start writing "mixins: ..." clauses in *.cabal
11:02:17 <kuribas> dolio: I could also use specialisation instead of dictionary passing.
11:03:12 <fendor_> monochrom, awesome, that looks good
11:04:29 <fendor_> hm, but there is no way to specify, "expose only these modules"
11:06:22 <fendor_> no, `foo ()` should work
11:07:39 <pounce> are there any good meldable heap libraries? just wondering
11:08:27 <dolio> kuribas: It's usually possible to write examples where no finite amount of specialization is sufficient.
11:09:04 <kuribas> dolio: C++ templates do it :)
11:11:54 <monochrom> fendor_: Your options are at https://cabal.readthedocs.io/en/3.4/cabal-package.html#pkg-field-mixins
11:11:59 <itai33[m]> what are the usecases for boxed vs unboxed types (specifically vectors if that matters)?
11:12:09 <monochrom> But yeah "foo ()" is supposed to hide all
11:12:26 <fendor_> monochrom, it works :) 
11:12:36 <monochrom> \∩/
11:13:44 <monochrom> Learn backpack in full! You'll be pround again next time you talk to ML people who boast their parameterized modules. :)
11:13:55 <monochrom> err s/pround/proud/
11:15:18 <snbr> i can't seem to be able to build happstack on windows, i get SendFile\Win32.hsc:103:1: error:
11:15:42 <snbr> any tips should i downgrade my ghci?
11:15:59 <snbr> i am on 8.10.2
11:17:56 <snbr> its happstack-server &
11:18:34 <fendor_> monochrom, this is almost completely unrelated to backpack, I am just trying to update ghcide to compile with HEAD and using ghc-api-compat
11:18:54 <monochrom> I don't know windows, but that sounds like not remotely close to enough information.
11:19:33 <monochrom> haha OK, it's OK, computer doesn't know what you're using the "mixins:" field for.
11:20:10 <monochrom> I'm just saying now that you've got blood on your hands you may as well actually stab someone...
11:21:50 <fendor_> true that. And there was that nice tutorial about using backpack and containers...
11:25:21 <itai33[m]> I'm trying to install bhoogle, but when running `cabal install bhoogle` it fails, but also seems to install version 0.1.2.9 instead of the default 0.1.3.5. Is there any way to force it to install the newest version?
11:43:35 <ezzieyguywuf> itai33[m]: for what it's worth, I had to try two or three times before my hoogle installation went all the way through
11:43:41 <ezzieyguywuf> I used stack though.
11:43:50 <glguy> itai33[m]: You can run: cabal install --dry-run bhoogle-0.1.3.5
11:43:58 <ezzieyguywuf> and by "try two or three times" I mean I literally just kept saying "install", I didn't change anythin
11:44:06 <ezzieyguywuf> oh nvm, thought the b was a typo
11:44:06 <glguy> but if it's not picking the latest version that is likely because you're using a GHC that isn't supported by it
11:44:26 <ezzieyguywuf> 😍 I want bhoogle
11:45:13 <ezzieyguywuf> itai33[m]: do you have  hoogle installed already and a database created?
11:46:01 <ezzieyguywuf> yike,s I'm having issues building it too. could it be it's just a poorly set up package?
11:46:28 <glguy> It's probably just abandoned
11:46:37 <itai33[m]> I did not have a database generated, trying now
11:46:51 <glguy> I had to go back to ghc-8.4.4 to get a build-plan for it
11:46:57 <itai33[m]> it is semi abandoned, it has had one update since 2018 but it was last month
11:47:14 <glguy> cabal install -w ghc-8.4.4 --dry-run bhoogle-0.1.3.5
11:47:34 <itai33[m]> I'll try that as soon as hoogle stops generating
11:50:52 <metaxis> Hi folks. Are there Haskell bindings for the Telegram API?
11:51:05 <metaxis> not the Telegram Bot API, mind you -- just the client API
11:51:12 <metaxis> https://core.telegram.org/methods
11:55:13 <itai33[m]> @glg
11:55:13 <lambdabot> Maybe you meant: pl msg ghc bug
11:55:13 <itai33[m]> every time
11:55:26 <itai33[m]> glguy: the dry run seems to resolve, I'll try doing the full instalation
11:56:16 <sm[m]> snbr: woah haven't seen a happstack question in a long time
11:59:04 <jamestmartin> can someone explain why this trivial use of ConstraintKinds causes type ambiguity? https://gist.github.com/jamestmartin/223afb5ac942bd0fce13f4f78b2a0681
12:04:16 <itai33[m]> ezzieyguywuf: glguy's suggestion works if that's of interest to you
12:04:26 <itai33[m]> but dear god does bhoogle have like 20 million dependencies
12:05:04 <snbr> sm[m]: why is that? can you recommend any other web server worth visiting
12:05:28 <snbr> i run out of ideas how to fix that
12:06:06 <sm[m]> It's old and not widely used in recent years. Check when the release you're using was uploaded to hackage ?
12:07:20 <sm[m]> If not recently, it might take some work to get it building
12:11:47 <sm[m]> but it looks like j Shaw is still actively maintaining happstack, so if you want to get it working it should be quite doable
12:12:08 <merijn> sm[m]: Anything's "quite doable" if you're stubborn enough ;)
12:12:15 <sm[m]> yesod and servant are the current more popular frameworks, or sometimes Scotty and Spock for small stuff. IHP is the newest and slickest.
12:14:03 <sm[m]> what's going on with snap, I wonder
12:18:40 <snbr> thank you very much
12:32:35 <ezzieyguywuf> itai33[m]: thanks for the tip but can't figure out how to make that work with stack :-P
12:33:11 <ezzieyguywuf> itai33[m]: hah, but also, based on your comments regarding dependencies, I think I'll pass.
12:34:36 <monochrom> If old package, then in the case of stack, request an older resolver so you get an older GHC and base that has higher compatibility.
12:35:17 <monochrom> I wonder if "backward compatibility can be achieved by a time machine" is right or wrong :)
12:43:21 <jamestmartin> I'm completely stumped on why my example doesn't work. it's a simple enough example that there's got to be an obvious reason, but I'm missing it.
12:43:44 <jamestmartin> I don't understand where c0 is coming from
12:44:05 <dolio> jamestmartin: None of the function parameters determine what c is, so it's ambiguous.
12:44:46 <jamestmartin> dolio: it's determined by the typeclass parameter
12:44:54 <monochrom> short /= simple
12:45:28 <dolio> That doesn't help.
12:45:40 <hekkaidekapus> jamestmartin: You can bring constraints into scope via class variables, say `class Functor c => Example c where test :: c a -> c a`
12:45:42 <monochrom> Or maybe I'm wrong.  short is simple.  but could also be simply wrong, eh?
12:47:42 <dolio> Given the occurrence `test x`, we can determine what `a` is by inferring the type of `x`. How do we determine what `c` is?
12:48:29 <dolio> Oops, that's slightly wrong.
12:48:40 <dolio> Given `test`, we can determine `a` by the result type.
12:48:45 <solonarv> also using the type of 'x'. We know that 'x :: c a', which allows us to infer both c and a.
12:48:52 <dolio> But nothing about the result type implies `c`. It's ambiguous.
12:49:06 <jamestmartin> okay, I see
12:49:09 <solonarv> what makes you think that? the result type is also 'c a'.
12:49:24 <dolio> solonarv: Your not looking at the right example.
12:49:26 <jamestmartin> solonarv: no, the result type is c a => a
12:49:42 <solonarv> ah, okay
12:50:20 <solonarv> disregard my prior statements ;)
12:50:42 <dolio> You could enable AllowAmbiguousTypes like the error message says, but then the only way to use test would be with explicit type application.
12:51:51 <jamestmartin> dolio: is explicit type application still needed even if only one instance is in scope?
12:52:11 <dolio> Yes.
12:52:23 <solonarv> yes, ghc never goes "oh there is only one instance in scope, I guess I will just pick that"
12:52:25 <jamestmartin> yeah, looks like I'm going to need to find out another solution then
12:53:04 <ski> jamestmartin : `c a => Proxy c -> a', maybe ?
12:53:06 <merijn> jamestmartin: At a proxy argument
12:53:22 <merijn> s/At/Add
12:53:38 <hyiltiz> Reading thru stack docs, still can't figure out how I can import Text.Show.Pretty, uffff
12:53:57 <hyiltiz> package.yaml and stack.yaml both seem to ask for pretty-show
12:54:19 <merijn> hyiltiz: If it's not in the resolver, then yes
12:54:41 <hyiltiz> how the f should I be expected to k what their resolves knows...
12:55:00 <merijn> hyiltiz: Well, it's a pretty fundamental part of stack...
12:55:01 <jamestmartin> a proxy argument might work but that would make actual use of my actual typeclass (not the reduced example) extremely inconvenient, so I'm just going to look for other solutions I think
12:55:13 <hyiltiz> they don't know if I know what the resolver knows so they write the docs so they know that i know where to look to figure out what the resolver knows?
12:55:16 <merijn> Like, resolvers are the *entire point* of stack
12:55:27 <hyiltiz> ^ that i know
12:55:42 <merijn> hyiltiz: You go to stackage, click on your resolver and check?
12:56:39 <hyiltiz> OK will do so... https://www.stackage.org/lts-16.9/package/pretty-show-1.10
12:57:18 <hyiltiz> Don't know where to go from here and am disappointed that it is much complicated than the languages haskell ususally laughts at
12:57:33 <kuribas> dolio: couldn't you cast polymorphic values to some type that includes the value?  Like convert (Num a -> a -> a) to (a, Num a) -> (a, Num a) ?
12:58:47 <merijn> hyiltiz: Well, that's lts-16.9, are you actually using lts-16.9?
12:59:26 <hyiltiz> I don't know and I don't really care; I just wanted to import Text.Show.Pretty to pretty print a tree built with less than 20 lines of code
12:59:51 <hyiltiz> My stack.yaml file says resolver: lts-16.9
13:00:23 <hyiltiz> and it "builds" fine if I don't specify any extra-deps (aka omit pretty-show from there)
13:00:36 <hyiltiz> sorry I am too annoyed right now but really appreciate it
13:01:39 <itai33[m]> is there any way to figure out the minimum viable version of all your dependencies for which your program compiles?
13:04:21 * hackage propellor 5.11 - property-based host configuration management in haskell  https://hackage.haskell.org/package/propellor-5.11 (JoeyHess)
13:05:40 <hyiltiz> http://ix.io/2uaZ I guess anything implementing Haskell 98 would let it build
13:05:59 <hyiltiz> I am not even using the lib; just importing is enough to spew troubles
13:16:16 <isovector1> > putStrLn "hello"
13:16:18 <lambdabot>  <IO ()>
13:16:57 <isovector1> > "hello"
13:16:59 <lambdabot>  "hello"
13:19:13 <dyniec[m]> hyiltiz: adding `pretty-show` to dependencies in package.yaml or build-depends in .cabal should be enough
13:20:43 <hyiltiz> added to package.yaml, did stack ghci / stack build in any order, they all complain: /xxx/playground-hs/pretty-show/: getDirectoryContents:openDirStream: does not exist (No such file or directory)
13:20:48 <isovector1> > unsafePerformIO $ putStrLn "hello"
13:20:50 <lambdabot>  error:
13:20:50 <lambdabot>      Variable not in scope: unsafePerformIO :: IO () -> t
13:24:20 <dyniec[m]> Ahh. I run into this issue sometimes. You probably have put pretty-show in `packages` list in stack.yaml file. You'll need to remove it from there
13:32:46 <hyiltiz> Yeah I found that earlier myself reading the stack docs... Alas, it is not that http://ix.io/2ub2
13:33:39 <isovector1> > replicate 197 ' ' ++ ":t show" ++ replicate 200 ' '
13:33:41 <lambdabot>  "                                                                           ...
13:33:57 <isovector1> :( trying to get lambda bot to talk to itself
13:34:18 <ski> it's been set up to not trigger other bots
13:34:32 <ski> (and i don't think it even sees its own responses)
13:34:39 <isovector1> very wise :)
13:34:44 <isovector1> but no fun
13:40:23 <fendor_> in a pattern synonym, how can I apply a function correctly? I have the following: `pattern TypeSig x y <- GHC.TypeSig _ (map GHC.unXRec -> x) y`, where X is a [a] and I want the x to be a [b]
13:43:06 <ski> what're the types involved ?
13:43:42 <sm[m]> hyiltiz: if you want, share your stack.yaml & package.yaml and error output.. ?
13:45:55 <dyniec[m]> hyiltiz: In your stack.yaml I see `random` in `extra-deps`. It will cause same problem as stack will try to build cabal package in directory `random`
13:46:41 <fendor_> ski, types from GHC.HEAD https://gitlab.haskell.org/ghc/ghc/-/blob/master/compiler/GHC/Hs/Binds.hs#L899 and I want it to fit this pattern: https://github.com/digital-asset/ghcide/blob/master/src/Development/IDE/GHC/Compat.hs#L231
13:47:24 <fendor_> XRec is defined here https://gitlab.haskell.org/ghc/ghc/-/blob/master/compiler/GHC/Hs/Extension.hs#L175
13:48:01 <hyiltiz> sm[m]:  https://asciinema.org/a/kvR9iXLXLFkluKJF7YLPHAQ9G
13:49:47 <hyiltiz> So just list stuff at packages.yaml? stack doc mentioned putting stuff twice https://docs.haskellstack.org/en/stable/stack_yaml_vs_cabal_package_file/#why-specify-deps-twice
13:57:39 <dyniec[m]> It's easy to miss in this page (at the end), but if package is available in snapshot you probably don't need to specify it in `extra-deps`
13:59:25 <dyniec[m]> In your package.yaml you list pretty-print as dependency, but previously mentioned `pretty-show` package
14:02:22 <hyiltiz> hmm ok fixed that typo
14:02:54 <hyiltiz> now the <project>.cabal file has a few mentions of the non-existent pretty-print package; guess gotta generate that
14:03:45 <fendor_> fixed by requiring the type signature to use GhcPs and not any pass stage
14:08:06 <ski> ok
14:10:01 <fendor_> actually the obvious solution
14:11:16 <isovector1> it's silly that there's no `clamp :: Ord a => a -> a -> a -> a` function in base. where's the right venue to complain about this fact?
14:11:38 <sm[m]> hyiltiz: asciinema is an interesting idea, but hard for me to view where I am just now. From what I can see that's a weird one.
14:12:02 <hyiltiz> hmm would u prefer a few separate pastebin links?
14:12:52 <sm[m]> hyiltiz: ah, are you using cabal range syntax in stack files ?
14:13:30 <sm[m]> Use random-x.y instead
14:13:34 <hyiltiz> u mean the base line? everything is generated by "stack new" and I just copied a bunch of small .hs files that I was playing around
14:14:09 <sm[m]> or maybe I'm confused.
14:14:43 <sm[m]> start with a working stack new project and change it line by line until error is triggered ?
14:16:51 <hyiltiz> hmm ok
14:18:08 <monochrom> My angle: It's silly to complain.
14:20:16 <isovector1> monochrom: yeah?
14:20:32 <monochrom> yeah.
14:20:42 <isovector1> ok?
14:21:14 <isovector1> is your solution "the world magically gets better by itself?"
14:21:47 <ixlun> Hi all, I'm trying to write a chess engine as an exercise to learn haskell and I've got a question.  So far I've got: http://ix.io/2ubd (there's probably lots of n00b things I'm doing wrong in there so please feel free to critique).  How should I implement the move function?  I've got the bounds sorted but I don't want to explicitly give all different combinations of directions and loci
14:22:12 <ixlun> I thought I could maybe use `+` on the Rank or File typeclass but looks like that can only be applied to Num
14:25:15 <ixlun> I also thought that becuase they are in Ord, I should then be able to increment in some way as there is an implied ordering is what I thought
14:25:19 <ixlun> but I could be wrong
14:25:28 <lyxia> isovector1: the libraries mailing list
14:26:26 <monochrom> If you add Enum to your deriving list, you have access to fromEnum and toEnum for converting between File<->Int and Rank<->Int. I think it helps write a simpler formula.
14:28:13 <isovector1> lyxia: thanks! i was hoping i could just send a pr though?
14:28:15 <ixlun> monochrom: Ahhh I didn't know about enum.  That also gives me `succ` and `pred`
14:28:45 <monochrom> The problem is that the libraries mailing list is still not a right venue. And no, I really think there is no right venue at all.
14:29:25 <monochrom> The library mailing list is already in perpetual debates on silly unimportant differences. It won't solve this one.
14:29:45 <isovector1> that is my impression as well
14:30:06 <monochrom> And to answer the other question, the world won't get better regardless, and there is no solution.
14:30:19 <isovector1> not with that attitude.
14:30:34 <isovector1> that attitude is the exact reason things don't get better
14:31:13 <monochrom> My attitude does not include "my locality can't get better"
14:31:38 <monochrom> I just made my locality a bit better yesterday by banning fog.
14:32:06 <monochrom> That in no way makes the world better. I'm sure fog is now off with pestering another forum.
14:32:12 <hyiltiz> No wonder there was no monologues today
14:32:22 <monochrom> Even if not, banning fog doesn't make fog better in the holistic sense.
14:32:59 <monochrom> Whenever I make my locality better, the rest of the world is worse. This is basic entropy thingie.
14:33:27 <monochrom> Attitude cannot defy human nature, especially other huamns' nature.
14:34:05 <hyiltiz> Any way to convert data T a = Nil | L a | B (T a) B (T a) to data Rose a=Node a [Rose a] ?
14:34:20 <hyiltiz> I am getting stuck at translating Nil 
14:34:54 <ixlun> One quick question regarding the Locus code above, sorry: I've defined: type Locus = (Rank, File).  Is it possible to 'overwrrite' the default show implementation so rather than returning "(a, 0)" I can get it to return "a0"? 
14:35:14 <hpc> it needs to be a different type
14:35:40 <hyiltiz> To be more general, T has no labels on the nodes but Rose requires; but there is no general "Nil" element for forall a
14:35:43 <hpc> as written, there is no type called "Locus", it's just an alias
14:36:00 <hpc> the most direct way is something like newtype Locus = Locus (Rank, File)
14:36:02 <isovector1> i mailed the libraries list. we'll see what happens
14:36:24 <hpc> and then you can't treat Locus values as plain tuples anymore, but you can write different instances
14:38:12 <ixlun> hpc: Huh, just tried to do that and got about 50 errors --- looks like I was relying quite a bit on tuple's implementation!
14:38:42 <ixlun> Still, maybe I should start early, easier to go through the pain now rather than going down the line of having them as tuples.
14:40:03 <lyxia> isovector1: GHC also accepts drive-by PRs, but I can never tell where the line is for a feature request to not be worthy of the libraries mailing list.
14:40:46 <isovector1> lyxia: thanks. i think that might be the right move; just inundate base with PRs and see what happens :)
14:43:53 <hpc> ixlun: on the bright side, those errors are what makes this sort of refactor easy in the first place
14:45:04 <ixlun> hpc: agreed :-)
14:45:28 <ixlun> huh, looks like my pattern matching on minBound and maxBound matches everything for some reason :-(
14:46:42 <hpc> those aren't patterns, you're matching anything and giving it the name "minBound"
14:47:09 <ixlun> Ahhhhh
14:47:12 <ixlun> oops
14:49:33 <ixlun> I'm guessing I need to use guard syntax
14:53:17 <ski> ixlun : even if it was, it would be a bad idea, imho
14:54:30 <ixlun> ski: how so?
14:54:40 <ski> ixlun : .. and it should not say `a', unless you have a (toplevel) variable named `a' of type `Rank'
14:54:55 <ski> `Show' is not for custom pretty-printing
14:55:05 <hololeap> let's say i want to read a type inside a TVar, use this to generate something in IO, then write this result back to the TVar. how would i do this in an atomic way, so that nothing else can read or write to the tvar until this operation is finished?
14:56:11 <ski> ixlun : `Show' is expected to produce a valid string representation of a Haskell expression that, when evaluated in an appropriate environment, will yield an equal value
14:56:43 <ski> if you want pretty-printing, then define another function (or maybe type class) to do that
14:56:56 <hololeap> hm, maybe that's not what i want
14:58:08 <ixlun> ski: thanks, didn't think of using another class.. I'll look at that
15:01:05 <infinisil> hololeap: You can't
15:08:29 <ski> hololeap : maybe with `ivar-simple' (or `data-ivar' with `unsafeInterleaveIO', i guess)
15:20:09 <triteraflops> so I had a crazy idea
15:20:15 <triteraflops> anonymous records
15:20:52 <monochrom> Not crazy at all.
15:20:54 <triteraflops> they'd word like tuples, in that you can just make them without having to declare the type
15:21:15 <triteraflops> oh, is there an extension? 
15:21:18 * triteraflops is hopeful
15:21:47 <infinisil> triteraflops: So like a Data.Map?
15:21:53 <monochrom> I just mean it's perfect doable and usable such as SML shows that it's fine.
15:22:06 <monochrom> Too late to add to GHC.
15:22:12 <triteraflops> map is a hashmap, right?
15:22:27 <triteraflops> dictionary
15:22:33 <triteraflops> not like a dictionary.
15:22:38 <infinisil> Not a hashmap, but yes like a dictionary
15:22:43 <monochrom> Hugs had it as the "TREX" extension. This is not added to GHC, and probably doesn't fit at all.
15:22:45 <triteraflops> keys would be known at compile time and have names
15:23:10 <monochrom> I know.
15:23:15 <infinisil> I think there's also compile-time Maps
15:23:24 <triteraflops> I was explaining to infinisil, monochrom.
15:23:36 <monochrom> https://www.haskell.org/hugs/pages/hugsman/exts.html#sect7.2
15:23:40 <triteraflops> well, that would be fine, yeah
15:24:21 <infinisil> Oh right but Data.Map's are homogeneous, unlike tuples
15:24:26 <infinisil> triteraflops: How about this then: https://hackage.haskell.org/package/HMap-1.3.0/docs/Data-HMap.html
15:25:04 <triteraflops> something like f :: Real a => {keya: ValTypeA, keyb: ValTypeB} -> a -> a
15:25:11 <triteraflops> Is there a Real typeclass?
15:25:18 <triteraflops> There's integral
15:26:01 <monochrom> Yes.
15:26:12 <triteraflops> infinisil: reading now
15:26:32 <triteraflops> infinisil: but the keys would only ever be symbols, and never any kind of real data.
15:27:15 <triteraflops> There could be many use cases, but my motivation is a simple way of doing named optional parameters.
15:27:19 <monochrom> Data.HMap looks like still not statically checked.
15:27:51 <triteraflops> The type sig I just gave would be for a function with two optional parameters, keya and keyb.
15:28:32 <triteraflops> And there would be some machinery for specifying an incomplete record and filling in empty fields or something
15:28:53 <triteraflops> monochrom: so GHC is a no, eh?
15:29:00 <triteraflops> monochrom: what's HUGS?
15:29:07 * triteraflops looks up HUGS
15:29:15 <monochrom> An old interpreter that was awesome
15:29:23 <monochrom> I did give a direct link.
15:30:02 * triteraflops actually reads things people type
15:30:11 <triteraflops> ohhhh, yeah
15:32:21 <triteraflops> The other use case, which is used very frequently in Typescript, is you specify a sort of subtype and any type with at least the keys asked for would match.
15:33:02 <triteraflops> so {a: 1, b: 2, c: "fish"} would match the type {a: Int, b: Int}
15:33:32 <triteraflops> That's the sort of structural typing / ducktyping idea.
15:34:24 <triteraflops> If I could find a reliable way of converting this notation into a more longwinded haskell98 equivalent, shouldn't this be suppportable in GHC?
15:34:52 <monochrom> Yes. Look for "lens".  It really is longwinded.
15:35:20 * triteraflops websearches haskell lens
15:35:38 <monochrom> I hope it ruins your weekend.
15:36:29 <triteraflops> lol
15:37:35 <monochrom> Well, in the sense that if you haven't played Civ6 (or similar 4X games) and someone gifts it to you just now, that also has the prospect of ruining your weekend.
15:38:03 <monochrom> Stellaris ruined my sleep time just last night (or rather this morning)
15:38:10 <Rembane> It's a good game 
15:38:24 <monochrom> I don't like it though.
15:38:58 <monochrom> OK, only relatively comparatively compared with other games I already play.
15:39:32 <monochrom> Clearly if I didn't give up for 6 hours I am sufficiently liking it.
15:39:37 <triteraflops> ok, so ruining the weekend as in disrupting prior plans
15:39:48 <triteraflops> well, I have no prior plans, so that's impossible
15:39:54 <monochrom> But I like other games or other genres more.
15:40:11 <monochrom> Or maybe same genre but fewer knobs fewer switches.
15:40:39 <monochrom> I did say that I keep playing C&C Generals precisely because everyone says it's shallow.
15:41:28 <monochrom> BTW it also looks like probability that I like a movie is something near 100% minus rotten tomato score.
15:41:46 <triteraflops> ha, I tried C&C generals on my PC about 15 years ago, and it ran like shit, so I went back to starcraft and aoeII
15:42:03 <monochrom> Not always, not simply, but good approximation 70% of the time or something.
15:42:42 <monochrom> Does "ran like shit" mean too slow?
15:43:00 <triteraflops> There are multiple meanings? lol
15:43:19 <monochrom> I'm just paranoid I misinterpret.
15:43:25 <triteraflops> mind, that was 15 years ago, on a computer that was old then
15:45:23 <triteraflops> OK, well, maybe I should give you my criteria
15:45:41 <triteraflops> bad responsiveness
15:45:54 <triteraflops> that's it really.
15:45:56 <monochrom> Yeah that makes it unplayable at all.
15:47:07 <monochrom> Like you have to apply "negative lag" manually to compensate haha.
15:48:08 <triteraflops> lol
15:48:13 <triteraflops> so true damn
15:48:35 <triteraflops> In the past years, I've become convinced most games should be operable under zero lag. 
15:48:41 <triteraflops> There's just no excuse for it
15:49:03 <triteraflops> Unless you're rendering near the total available resources of the PC
15:50:15 <triteraflops> which is just not true for most games.
15:51:34 <triteraflops> And inadviseable in any case, especially for PC games. I would not be comfortable using more than 1/16 of the capacity of my test computers, to allow for the massive gulf in capability from low end to high end
16:06:58 <triteraflops> I'm watching this: https://www.youtube.com/watch?v=cefnmjtAolY I'm so confused
16:08:04 <triteraflops> This is the crash course recommended by the lens package
16:08:22 * triteraflops face->palmrests
16:08:41 * triteraflops afks
16:39:47 <dansho> are there any tools that will display a dependency graph for a given haskell library?
16:46:56 <yushyin> https://hackage.haskell.org/package/cabalgraph -- https://github.com/kowainik/awesome-cabal#dependencies-analysers
16:51:19 <dansho> i found a couple more, cabal-graphdeps and cabal-db graph, the latter has the most recent downloads
16:51:30 <yushyin> nice
16:53:48 <dansho> cabal-db is marked broken on nixos 19.03 tho =[
16:55:53 <dansho> huh, apparently all three are marked broken
16:56:35 <yushyin> not so nice :(
17:29:49 <dansho> stack dot --external worked...might needs pruning =) https://i.ibb.co/7zZzPGB/deps2560.png
17:30:56 <monochrom> great for the next galaxy-themed 4X game map :)
18:53:49 * hackage MIP 0.1.0.0 - Library for using Mixed Integer Programming (MIP)  https://hackage.haskell.org/package/MIP-0.1.0.0 (MasahiroSakai)
19:00:20 * hackage functor-combinators 0.3.4.0 - Tools for functor combinator-based program design  https://hackage.haskell.org/package/functor-combinators-0.3.4.0 (jle)
19:05:03 <monochrom> aaaaiiiiieeee this breaks my head and my heart
19:06:24 <monochrom> So I was digging into "what if you call Foreign.Marshal.Alloc.mallocBytes (-10) for example.
19:06:33 <hyiltiz> I can't seem to find a way to convert `data T a = Nil | L a | B (T a) B (T a)` to `data Rose a=Node a [Rose a]`?
19:06:44 <MarcelineVQ> Where are all the good men dead, in the heart or in the head?
19:06:56 <glguy> monochrom: and it goes and frees some of your already allocated bytes?
19:07:02 <monochrom> haha no
19:07:07 <hyiltiz> Is it theoretically not guaranteed? I could serialize one to a Cons list then rewrite it into the other.
19:07:48 <glguy> hyiltiz: Doesn't appear to be possible
19:08:01 <glguy> hyiltiz: convert Nil = ?
19:08:01 <monochrom> So recall C's malloc is malloc(size_t n) and the Haskell side foreign import is faithful to that: foreign import blahblah :: CSize -> IO (Ptr a)
19:08:02 <hyiltiz> But directly converting between the two withotu translating seems impossible; some Node x values get stuck
19:08:15 <solonarv> monochrom: oh no
19:08:26 <solonarv> does it allocate 2^N-10 bytes??
19:08:26 <monochrom> So mallocBytes n = apart from checking for returning NULL
19:08:28 <monochrom> err
19:08:42 <hyiltiz> Sorry; I found Nil wasn't necessary so eliminated it. Now it is just  `data T a = L a | B (T a) B (T a)` <=>`data Rose a=Node a [Rose a]`
19:08:50 <monochrom> So mallocBytes n = c's_malloc (fromIntegral n) (then check for NULL)
19:09:04 <glguy> hyiltiz: What's the type B?
19:09:18 <hyiltiz> Oh typo there, should be  `data T a = L a | B (T a) (T a)` <=>`data Rose a=Node a [Rose a]`
19:09:35 <hyiltiz> B is the constructor for T
19:09:51 <monochrom> Yeah solonarv so that will do it, 2^N - 10 bytes.
19:10:03 <monochrom> Why dear God why?
19:10:08 <solonarv> hyiltiz: oh, then again that doesn't seem straightforwardly possible
19:10:11 <hyiltiz> Just a binary tree with values only on the leaves vs. rose tree where Nodes carry values
19:10:43 <glguy> hyiltiz: IIRC those (or a very similar scenario) are isomorphic
19:10:52 <monochrom> The bytestring library OTOH is pretty vigilant in checking Int inputs and ioError if negative.
19:11:11 <hyiltiz> isomorphic or not straightforwardly possible? 
19:11:35 <glguy> hyiltiz: The exercise was non-obvious but the implementation was easy once you knew the strategy
19:11:40 <hyiltiz> I think they are "isomorphic" in that they can both carry the same data (they both have Cons list representation)
19:11:54 <glguy> and I'm trying to remember why I did this exercise
19:12:03 <hyiltiz> glguy: I've drawn enough trees on my sketch pad
19:13:28 <hyiltiz> It seems it is possible for some top Nodes to run out of values if we try to preserve the tree structure as much as possible
19:15:04 <ski> hyiltiz : what could `Node x [t1,t2,t2,t3]' be converted to ?
19:15:12 <dmwit> Isomorphism idea: the left spine gives the list to put in a node.
19:15:25 <dmwit> The left spine of the binary tree gives the list to put in a rose tree node, I mean.
19:15:34 <solonarv> oh yeah that should work
19:15:39 <dmwit> (And the leftmost leaf gives the value.)
19:15:45 <dmwit> Then recurse.
19:16:02 <hyiltiz> B (B (L t1) (L t2)) (B (L t3) (L t4)) 
19:16:08 <glguy> I think the exercise I did was that  data A a = A1 a | A2 (A a) (A a)   is isomorphic to  (a, B a)  for  data B a = B1 | B2 a (B a) (B a)
19:16:23 <ski> hyiltiz : why balanced ?
19:16:29 <ski> and where's the `x' ?
19:16:59 <hyiltiz> Yeah~ that x is annoying me
19:17:26 <ski> you know that a linked list can be seen as a degenerate binary tree, right +
19:17:27 <ski> ?
19:17:37 <hyiltiz> yea
19:18:38 * ski would go with right, btw
19:19:41 <dmwit> from (L a) = Node a []; from (B l r) = let Node a ts = from l in Node a (from r : ts)
19:21:37 <dmwit> to (Node a []) = L a; to (Node a (t:ts)) = B (to (Node a ts)) (to T) -- its inverse
19:21:51 <dmwit> to (Node a []) = L a; to (Node a (t:ts)) = B (to (Node a ts)) (to t) -- its inverse, without the typo'd T at the end
19:22:18 * ski . o O ( "Seven trees in one" by Andreas Blass in 1995 at <http://www.math.lsa.umich.edu/~ablass/cat.html> )
19:23:10 <ski> i guess you could make it a pattern synonym, dmwit ?
19:23:21 <dmwit> I guess technically rose trees can have infinite lists and these don't quite deal with that appropriately.
19:23:55 <dmwit> ski: Hm, maybe. Seems hard, because it's recursive.
19:27:11 <hyiltiz> `from r:ts` doesn't parse though since from doesn't take lists
19:27:32 <hyiltiz> but I geuss u mean append the two branches
19:27:37 <dmwit> Compiler likes it just fine here.
19:27:46 <dmwit> Perhaps your mental parser isn't working right. ^_^
19:28:27 <dmwit> (It parses as `(from r) : ts`, not `from (r : ts)`, natch.)
19:29:28 <hyiltiz> ah~ i need to remember my infix priorities
19:31:14 <solonarv> "function application binds more tightly than infix operators" - that's the rule to remember
19:34:52 <hyiltiz> invisible space binds more tightly than visible binary operators, hmm
19:35:35 <solonarv> it's juxtaposition (putting things next to each other), *not* space
19:36:22 <glguy> > succ(42)
19:36:24 <lambdabot>  43
19:36:32 <solonarv> > (succ)42 -- same thing
19:36:34 <lambdabot>  43
19:36:47 <solonarv> > subtract(-1)1
19:36:49 <lambdabot>  2
19:39:46 <hololeap> whoa
19:40:09 <hololeap> > sum[1,2]
19:40:11 <lambdabot>  3
19:40:21 <hololeap> > [1,2]sum
19:40:23 <lambdabot>  error:
19:40:23 <lambdabot>      • Couldn't match expected type ‘([Integer] -> Integer) -> t’
19:40:23 <lambdabot>                    with actual type ‘[Integer]’
19:40:39 <hololeap> haha don't know why i thought that might work
19:41:37 <hyiltiz> well technically it is juxt
19:41:49 <hyiltiz> and sum is unary
19:42:02 <hyiltiz> guess u can only apply f to x but not x to f
19:42:02 <ski> `[1,2]' is not a function
19:43:42 <ski> % (2^) . [1,2]
19:43:42 <yahb> ski: [2,4]
19:44:40 <yushyin> > [1,2]&sum -- just imagine that there is no & there
19:44:41 <lambdabot>  3
19:45:28 <solonarv> % :i .
19:45:28 <yahb> solonarv: (.) :: Functor f => (a -> b) -> f a -> f b -- Defined at <interactive>:16:51
19:45:45 <solonarv> ski: cheeky ;)
19:46:33 <ski> lambdabot used to have that definition
19:47:03 <hyiltiz> Well <$> isn't that ugly
19:47:26 <ski> also `flip :: Functor f => f (a -> b) -> (a -> f b)'
19:48:24 <dolio> ski: That paper is kind of amazing with regard to how bad the description of the algorithm part is.
19:49:36 <ski> dolio : iirc, i wrote it down as a bijective Mercury predicate, to better understand it
19:53:09 <dolio> That alone should be an argument for mathematicians to get on board with learning type theory. :)
19:56:22 <ski> which ?
19:58:52 <dolio> That it is already a well-developed arena for expressing/talking about functions like the one in that paper.
19:59:38 <dolio> Much better than the one that was invented for the paper. And would probably lead to better ways of describing its properties than "very explicit".
20:03:33 <Cale> dolio, ski: https://i.imgur.com/9M347Gf.png
20:07:07 <ski> nice :)
20:07:29 <ski> (do those two give rise to different isomorphisms ?)
20:08:08 <Cale> That's a good question
20:09:19 <ski> (when there's multiple of the same power of `T', there is a question of which one to pick, in a move. so lets consider all possible choices, and ask whether the two sets of isomorphisms overlap)
20:09:51 <int-e> Cale: what are you playing there?
20:10:26 <Cale> Also, is there a way to do it without having a coefficient of more than 1 at any point?
20:10:33 <ski> int-e : `T = 1 + T^2'
20:11:29 <int-e> ah you're proving T = T^7?
20:11:32 <Cale> yeah
20:13:09 <Cale> Those diagrams more or less give you the isomorphism, except as ski mentioned, there's more than one choice about what to do in any case where you end up with doubled tokens, representing having more than one T^k available in some step.
20:17:18 <ski> four vs. eight possibilities
20:40:52 <int-e> Nice, I can prove that T != T^4.
20:41:34 <int-e> err, what am I thinking.
20:41:52 <dolio> The paper says there is no similar bijection.
20:41:55 <int-e> T = -T^4, algebraically, but I somehow messed up the sign earlier :-/
20:52:43 <aneksteind> hello, I'm trying to run a QuickCheck test on a property that's of type [Map Int Int] -> Bool and I'm getting a stack overflow. my maxSize and maxSuccess are both trivially set to 1. Does anyone have any ideas?
20:53:05 <aneksteind> im using QuickCheck 2.13.2
20:57:25 <int-e> @check (\m -> sum (map M.size m) /= 10) :: [M.Map Int Int] -> Bool
20:57:27 <lambdabot>  +++ OK, passed 100 tests.
20:57:59 <int-e> that's QuickCheck-2.14 though
20:59:07 <int-e> @check (\m -> sum (map M.size m) /= 10) :: [M.Map Int Int] -> Bool
20:59:09 <lambdabot>  +++ OK, passed 100 tests.
20:59:22 <int-e> huh, it found a counterexample in my first test, seems I got lucky ;)
20:59:25 <int-e> :)
21:00:17 <aneksteind> int-e: i'm testing again with 2.14.1
21:01:44 <int-e> aneksteind: hmm, I'd guess it's your function and not quickcheck
21:02:08 <int-e> (I tried the above silliness with QuickCheck-2.13.1)
21:02:47 <int-e> But I'm not tweaking any QuickCheck settings.
21:04:19 <redmp> > symbolVal (Proxy :: Proxy "hello")
21:04:20 <lambdabot>  error:
21:04:21 <lambdabot>      Variable not in scope: symbolVal :: Proxy "hello" -> t
21:05:08 <redmp> i don't know how to import, but it's in `GHC.TypeLits`
21:05:47 <int-e> @let import GHC.TypeLits
21:05:49 <lambdabot>  Defined.
21:05:55 <redmp> > symbolVal (Proxy :: Proxy "hello")
21:05:55 <int-e> > symbolVal (Proxy :: Proxy "hello")
21:05:57 <lambdabot>  "hello"
21:05:57 <lambdabot>  "hello"
21:06:29 <int-e> Interesting, I half expected that import to be unsafe.
21:06:36 <redmp> > let symbolValTA = Proxy in symbolValTA @"hello"
21:06:37 <lambdabot>  error:
21:06:37 <lambdabot>      Pattern syntax in expression context: symbolValTA@"hello"
21:06:37 <lambdabot>      Did you mean to enable TypeApplications?
21:06:57 <redmp> yes, i did. lambdabot is great
21:08:08 <redmp> anyway, my question is this: Is `Proxy` a relic of the pre TypeApplications days? Are there cases where you need Proxy because TypeApplications aren't good enough? or cases where you need TypeApplications because Proxy isn't good enough?
21:09:14 <aneksteind> int-e: in quickcheck is there a way to specify that i want my list to be non-empty, or would i specifically have to use a non-empty list data type
21:09:46 <int-e> @check \xs -> not (null xs) ==> length xs > 0
21:09:48 <lambdabot>  error:
21:09:48 <lambdabot>  • No instance for (STestable Int) arising from a use of ‘==>’ • In the first...
21:09:56 <int-e> mmm
21:10:19 <int-e> @check \xs -> not (null xs) ==> (length xs > 0)
21:10:21 <lambdabot>  +++ OK, passed 100 tests.
21:10:48 <int-e> aneksteind: if there are few exceptional cases, this is appropriate
21:13:37 <aneksteind> never seen ==> before
21:13:50 <int-e> @check \xs -> length (getNonEmpty xs) > 0 -- QuickCheck has some builtin modifiers that adjust Arbitrary instances to respect various constraints.
21:13:52 <lambdabot>  <hint>:1:162: error:
21:13:52 <lambdabot>  parse error (possibly incorrect indentation or mismatched brackets)
21:14:00 <int-e> @check \xs -> length (getNonEmpty xs) > 0
21:14:02 <lambdabot>  +++ OK, passed 100 tests.
21:15:00 <int-e> @check \x -> getPositive x > 0
21:15:02 <lambdabot>  +++ OK, passed 100 tests.
21:18:16 <aneksteind> int-e: that's perfect, thank you
21:18:39 <aneksteind> the space leak was on my side by the way, i didn't anticipate a certain type of input
21:18:48 <aneksteind> tracing helped with that
21:30:03 <nshepperd1> TypeApplications was a mistake. we'd be better off with a convenient syntax for creating Proxys
21:31:03 <c_wraith> TypeApplications has a lot more value than that
21:32:58 <nshepperd1> like what
21:33:50 <glguy> For one, type applications work when you didn't add some proxy parameters ahead of time
21:34:09 <glguy> % :t map @Int
21:34:10 <yahb> glguy: (Int -> b) -> [Int] -> [b]
21:34:36 <nshepperd1> yeah but that's exactly when they cause woe
21:34:51 <c_wraith> they do what?
21:34:53 <glguy> and it's unfortunately to have to add a function type and a proxy type to something just to be able to specify extra information
21:35:14 <nshepperd1> due to people suddenly depending on the order of variable declaration in your function
21:35:16 <glguy> I don't like the positional, implicit nature of them
21:35:25 <glguy> but that's a separate design issue
21:36:49 * hackage jose 0.8.3.1 - Javascript Object Signing and Encryption and JSON Web Token library  https://hackage.haskell.org/package/jose-0.8.3.1 (frasertweedale)
22:17:49 * hackage optparse-generic 1.4.3 - Auto-generate a command-line parser for your datatype  https://hackage.haskell.org/package/optparse-generic-1.4.3 (GabrielGonzalez)
22:19:21 <dolio> nshepperd1: What if the type application syntax were syntax for proxies? :P
22:20:42 <tintint> hi guys
22:21:16 <tintint> I have a global IORef variable
22:21:35 <nshepperd2> dolio: well, i sometimes do 'let p :: Proxy a; p = Proxy' so that I can write 'myFunction p@Int', that's pretty close :)
22:23:21 <dolio> That's actually how I thought it should be back when they were first proposed. But I wasn't the one implementing it.
22:28:08 <tintint> I have a global IORef variable -- it is a variable which holds a list of tuples. I use template haskell add to the list. But, the only problem is for all the files that interact with the IORef. It clears the list and populates it with a new set of tuples. With the next file it clears the list again and populates with a new set of tuples. So this global IORef is basically used as a placeholder. Notice this sucks for parallel computatio
22:28:08 <tintint> id much rather define the IORef in each file such that each module has its own global variable. Does anyone have any ideas about the best way to go about this?  
22:30:18 * hackage functor-combinators 0.3.4.1 - Tools for functor combinator-based program design  https://hackage.haskell.org/package/functor-combinators-0.3.4.1 (jle)
22:33:24 <nshepperd2> if we had an explicit syntax for defining type variable visibility and ordering separate from the forall, TypeApplications would be alright really
22:35:14 <nshepperd2> map :: type a -> type b -> (a -> b) -> [a] -> [b] or something
22:35:14 <dolio> Right, but that's a much more major change, and the end result is probably almost the same as proxies.
22:35:38 <dolio> Especially since there was already work at the time to have 0-width proxy arguments.
22:36:36 <nshepperd2> well, @ has the benefit that you can skip it if you want everything to be inferred. instead of supplying a bunch of dummy proxies. that's kind of nice
22:37:37 <dolio> Do people use @ when things can be inferred?
22:38:31 <nshepperd2> I mean that with TypeApplications you can write either 'map (+1) [1,2,3]' or 'map @Int (+1) [1,2,3]'
22:38:35 <nshepperd2> both are ok
22:38:43 <dolio> You can, but why would you write the latter?
22:38:52 <nshepperd2> when you want to fix it to Int
22:39:06 <nshepperd2> with Proxy you are forced to pass two Proxies in both cases
22:39:57 <nshepperd2> 'map Proxy Proxy (+1) [1,2,3]' vs 'map Proxy@Int Proxy (+1) [1,2,3]' or something
22:40:08 <nshepperd2> the arguments aren't optional
22:40:22 <dolio> The point is that you don't write map to have proxy arguments, because it doesn't need them.
22:40:41 <dolio> And the need to explicitly apply map to types is extremely rare.
22:41:30 <nshepperd2> I have written functions that took proxy arguments that could sometimes be inferred
22:42:26 <nshepperd2> they were things involving typelits, where there were several different ways to fix a parameter
22:42:30 <c_wraith> tintint: why is it an IORef?
22:43:36 <c_wraith> tintint: if it's being populated with TH, couldn't you make it something immutable?
22:50:39 <tintint> Good question c_wraith. I don't think I can provide a great answer for this since it is legacy. And im quite new to haskell. The tuples are basically sorta of a mapping to generate controllers.  
22:55:49 * hackage turtle 1.5.21 - Shell programming, Haskell-style  https://hackage.haskell.org/package/turtle-1.5.21 (GabrielGonzalez)
23:13:34 <hyiltiz> Godel's Classic-Intuisionistic Embedding <=> Reynold's Continuation Passing Style -- Wadler 2020
23:13:47 <hyiltiz> That talk is mind blowing in so many different ways
23:25:40 <hyiltiz> Lambda calculus is omniversal, 'cuz universal is too limiting. --Wadler 2020
23:55:20 * hackage runhs 1.0.0.5 - Stack wrapper for single-file Haskell programs.  https://hackage.haskell.org/package/runhs-1.0.0.5 (danielbrice)
