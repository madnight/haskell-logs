00:24:19 * hackage cuckoo 0.2.1 - Haskell Implementation of Cuckoo Filters  https://hackage.haskell.org/package/cuckoo-0.2.1 (larsk)
01:06:16 <merijn> Ha! New prettyprinter version fixes my major gripe!
01:07:17 <merijn> No more Data.Text.Prettyprint.Doc prefix in the moduls
01:07:28 <merijn> That was a dumb idea for people who like typing too much >.>
01:29:17 <hc> typing as in "typing text" not "creating complicated types"? ;p
01:33:35 <merijn> yes
01:33:50 * hackage testcontainers 0.2.0.0 - Docker containers for your integration tests.  https://hackage.haskell.org/package/testcontainers-0.2.0.0 (alexbiehl)
01:46:48 <dminuoso> merijn: What are the major changes?
01:49:39 <merijn> dminuoso: Shorter hierarchy of modules was added
01:49:55 <merijn> So now you can just "import Prettyprinter"
01:52:54 <fendor> if I have only executables in a cabal project I can not build these executables with same dependency but different versions? :O 
01:55:59 <dminuoso> that's certainly nice
01:58:00 <merijn> fendor: That'd require per-component dependency resolution which is, afaik, a work in progress for public multi-libs
01:59:04 <fendor> merijn, ok thanks!
02:06:35 <Graypup_> how do I turn a template haskell Q (Q Exp) into a Q Exp?
02:06:48 <Graypup_> I have tried the <$> operator, which seems like the obvious solution, but perhaps I am doing it wrong?
02:07:19 <merijn> Graypup_: join?
02:07:23 <merijn> :t join
02:07:24 <lambdabot> Monad m => m (m a) -> m a
02:07:44 <merijn> <$> is the opposite of what you want :p
02:13:48 <Graypup_> wait, is it? I have a function that takes a normal world thing and returns a monad and an expression that I want to pass as an argument which is a monad. this is fmap, no?
02:15:02 <Graypup_> specifically I am calling a thing that is FilePath -> Q Exp, and have a thing that is a Q FilePath that I want to unwrap and give it
02:15:57 <dminuoso> Graypup_: Use >>= or do-notation :)
02:16:03 <dminuoso> (Or =<< if you like)
02:16:22 <Graypup_> that did it, thank you so much
02:16:56 <merijn> Graypup_: <$> and fmap put something *inside* Q, >>= runs a function that returns a Q against something coming from Q and join collapses Q (Q Foo) into Q Foo
02:17:38 <Graypup_> i need to draw myself a diagram like the first time I learned this and apparently didn't internalize it hehe
02:18:00 <merijn> :t fmap
02:18:01 <lambdabot> Functor f => (a -> b) -> f a -> f b
02:18:03 <merijn> :t (>>=)
02:18:05 <lambdabot> Monad m => m a -> (a -> m b) -> m b
02:18:07 <merijn> :t join
02:18:08 <lambdabot> Monad m => m (m a) -> m a
02:18:21 <merijn> Graypup_: Now just mentally replace the 'f' and 'm' with Q :)
02:24:02 <dminuoso> Mmm, is there some Storable version for structs containing zero length arrays at the end? Or should I just do mallocBytes manually, and write my own pokeFoo function?
02:27:04 <Graypup_> wat, my qAddDependentFile'd embedded file is not causing recompilation when its contents are changed. This seems surprising and/or incorrect?
02:28:43 <dminuoso> Graypup_: Recall that TemplateHaskell is executed during parsing, it then splices its result back into the AST during that parsing phase.
02:29:04 <merijn> dminuoso: There's no way to write a Storable version for that unless the length is encoded in the struct
02:30:11 <dminuoso> merijn: Well I could, but it'd be very awkard. I think I want custom peek/poke/malloc functions anyhow. Half the struct fields are not for me to write, but for the ioctl..
02:30:24 <dminuoso> So a generic poke is already silly
02:30:36 <dminuoso> (I mostly just want to poke the first field)
02:30:37 <Graypup_> dminuoso, so it's not evaluated on each compilation? I guess that makes sense, I would have assumed that the dependent files get saved somewhere at which time they are checked though
02:30:44 <merijn> dminuoso: tbh, here's a better idea
02:30:56 <merijn> dminuoso: Just call ioctl from C and call your simpler C wrapper from haskell
02:31:20 <merijn> why make your life so difficult
02:31:41 <dminuoso> well, I want to expose the entire ioctl here to haskell
02:32:05 <dminuoso> With dozens of sub commands. Im not convinced doing a separate C wrapper is a good idea
02:32:13 <dminuoso> Especially since some of the ioctl require previous ioctls
02:32:46 <dminuoso> (And gee, ioctl is a crude and shitty interface)
02:34:01 <merijn> Your funeral :p
02:36:25 <dminuoso> merijn: Ah! I think I know where my mistake is. I've tried mapping this 1:1 to Haskell and that's dumb.
03:45:49 * hackage alarmclock 0.7.0.5 - Wake up and perform an action at a certain time.  https://hackage.haskell.org/package/alarmclock-0.7.0.5 (dten)
03:50:19 * hackage bank-holidays-england 0.2.0.5 - Calculation of bank holidays in England and Wales  https://hackage.haskell.org/package/bank-holidays-england-0.2.0.5 (dten)
03:57:20 * hackage aws-lambda-haskell-runtime-wai 1.0.2 - Run wai applications on AWS Lambda  https://hackage.haskell.org/package/aws-lambda-haskell-runtime-wai-1.0.2 (dnikolovv)
04:47:20 * hackage lsp-test 0.11.0.4 - Functional test framework for LSP servers.  https://hackage.haskell.org/package/lsp-test-0.11.0.4 (luke_)
05:03:33 <siraben> @unmtl MaybeT (State a) (MaybeT (State a) b)
05:03:33 <lambdabot> a -> (Maybe (a -> (Maybe b, a)), a)
05:03:55 <siraben> What's an easy way to derive the join for the MaybeT (State a) monad?
05:04:00 <siraben> :t join :: forall a b. MaybeT (State a) (MaybeT (State a) b) -> MaybeT (State a) b
05:04:01 <lambdabot> MaybeT (State a) (MaybeT (State a) b) -> MaybeT (State a) b
05:04:11 <dminuoso> siraben: derive?
05:04:18 <siraben> I mean, see what it actually is
05:05:01 <dminuoso> There exists an `instance Monad m => Monad (MaybeT m)` in transformers.
05:05:06 <dminuoso> Is that what you mean?
05:06:02 <siraben> Right, thanks
05:06:20 <siraben> Then I could unfold and simplify until I get the direct function for join?
05:06:37 <Orbstheorem> It's so rewarding and pleasant to work in haskell. It refactors awesomely well, the type system allows me to say what I want to have. 
05:06:47 <dminuoso> Orbstheorem: You say that now.
05:07:02 <dminuoso> Until you hit at dead ends and wish the type system was dependent. :p
05:08:25 <MarcelineVQ> But doctor, the cure is worse than the disease
05:08:35 <siraben> @unmtl MaybeT (State a) b
05:08:35 <lambdabot> a -> (Maybe b, a)
05:08:56 <Orbstheorem> I implemented an extensible configuration using an open product. I made my PoC in a separate repository and transplanted it into the big haskell project relatively flawlessly. My diff is about +500 -1700, which is always awesome and after typechecking everything just works. 
05:09:07 <Orbstheorem> It also allowed me to realize stupid dependencies. 
05:10:38 <Orbstheorem> dminuoso: I've been faced multiple time to problems where dependent types would simplify my life, but the additional constraint forced me into refactoring my code to make it more concise and ended up realising I don't need dependent types. 
05:11:07 <Orbstheorem> But I haven't yet hit a wall where I can prove that dependent types are the only way, yet. 
05:11:37 <Orbstheorem> Though I got to say: _Screw you Monomorphism restriction!_
05:11:43 <Orbstheorem> (xD) 
05:12:56 * Orbstheorem raises and moves his fist like an old man
05:13:58 <dminuoso> Orbstheorem: oh you get into dependent type problems really quickly once you get used to the idea of encoding proprerties into the type system long enough.
05:14:23 <dminuoso> Perhaps it starts with "I want to track the length of this list in the type system"
05:14:39 <dminuoso> And then you're pretty much in dependent types already
05:15:18 * Orbstheorem will passively look for jobs doing idris.
05:16:12 <dminuoso> Im not saying they are the end-of-all solution, but Haskell has a way of showing how neat it is to encode things into the type system. And once you start doing that a lot, you'll notice that Haskell is not so pleasant.
05:17:19 * hackage reanimate-svg 0.10.2.0 - SVG file loader and serializer  https://hackage.haskell.org/package/reanimate-svg-0.10.2.0 (DavidHimmelstrup)
05:17:26 <dminuoso> It's tons better because most languages dont even let you express the simplest things.
05:17:58 <dminuoso> But in the scope of "expressing properties in the type system" its cumbersome, the more you want to express, the more you need to enable lots of extensions, make use of fancy packets like singletons..
05:19:58 <Guest_73> morning
05:20:09 <Guest_73> i keep getting an error while trying to run:
05:20:12 <Guest_73> curl --proto '=https' --tlsv1.2 -sSf https://get-ghcup.haskell.org | sh
05:20:21 <Guest_73> on my mac
05:20:30 <Guest_73> [ Error ] Build failed with NonZeroExit 77 "./configure" ["--prefix=/Users/LDV/.ghcup/ghc/8.8.4"]"_eghcup --cache install ghc recommended" failed!
05:20:52 <Guest_73> am trying to search for this on search engines but no luck
05:21:01 <Guest_73> does anyone have any insight please?
05:25:45 <merijn> Orbstheorem: The monomorphism restriction is great
05:26:01 <merijn> Orbstheorem: Or rather it's the best/least sucky alternative to an ambiguity
05:26:49 <dminuoso> And it's required for performance reasons :)
05:27:33 <dminuoso> Otherwise, some naive attempts would not have expected sharing
05:29:43 <merijn> Orbstheorem: Basically, you have to pick between "code is sometimes unexpectedly slow with no clear reason" and "sometimes code fails to compile with a trivial to solve issue"
05:30:20 <Orbstheorem> Fair enough
05:30:37 <dminuoso> To be fair, the MMR has sneaked up on me in ways that were not obvious before.
05:30:51 <dminuoso> It did cost me the odd half an hour on occasion
05:31:17 <merijn> dminuoso: If you always write top level type signatures (like you should!) it's a non-issue anyway
05:32:53 <merijn> Orbstheorem: The basic problem is something like: "foo = [1 .. expensiveComputation]" (imagine that 'expensiveComputation :: (Enum a, Num a) => a', so polymorphic result list 'foo')
05:34:00 <merijn> Orbstheorem: This *looks* like a list value, which you expect to be computed once. But the typeclass polymorphism means that can't happen (since you have no clue how many different instances might be used and caching all instantiations seems like a bad idea, besides being technically hard)
05:34:09 <dminuoso> merijn: The MMR is not limited to top level bindings.
05:34:22 <merijn> dminuoso: You should put type signatures on all bindings anyway ;)
05:35:10 <dminuoso> merijn: A type signature is not enough to bust the MMR necessarily
05:35:17 <dminuoso> It's a misconception based on what the most common cause is
05:35:34 <merijn> Orbstheorem: So you can do two things: 1) make 'foo' monomorphic, and check that's it's only ever used with one specific type, then it can behave as the value it looks like (and compile time error if you use it with multiple different types)
05:35:38 <merijn> dminuoso: wut
05:35:40 <merijn> dminuoso: Yes it is
05:35:42 <dminuoso> No it is not.
05:35:51 <merijn> dminuoso: [Citation Needed]
05:36:41 <dminuoso> merijn: Essentially, the Haskell report consideres a binding group to be unrestricted *iff* a) every variable in the group is bound by a function binding or a simple pattern binding *and* b) an explicit type signature is given for every variable in the group that is bound by simplepattern binding
05:36:43 <merijn> Orbstheorem: Alternatively, you can 2 makes 'foo' polymorphic and always recompute, but if the user doesn't expect that, you are now going to recompute 'expensiveComputation' *a lot*
05:36:59 <dminuoso> merijn: a) is generally presumed, since non-simple bindings are relatively rare.
05:37:09 <dminuoso> But if you have a non-simple binding, then adding a type signature will not unrestrict it
05:37:22 <dminuoso> This is straight from the haskell report, btw
05:37:40 <merijn> dminuoso: How would you write a case like that?
05:37:41 <dminuoso> The example the haskell report names for a) is:
05:37:43 <dminuoso> [(n,s)] = reads t
05:37:53 <dminuoso> Which is a non-simple binding
05:38:32 <dminuoso> Check 4.5.5 in https://www.haskell.org/definition/haskell2010.pdf
05:38:37 <dminuoso> I'd just end up copy pasting anyhow.
05:41:25 <dminuoso> I dont recall the specifics, but I think it was something along the lines of (f,g) = ((+),(-))
05:42:00 <dminuoso> (And, as the report states, f and g are monomorphic regardless of whether you specify a type signature for f or g)
05:43:02 <dminuoso> % f :: Num a => a -> a -> a; (f,g) = ((+),(-))
05:43:03 <yahb> dminuoso: ; <interactive>:78:1: error: Overloaded signature conflicts with monomorphism restriction f :: forall a. Num a => a -> a -> a
05:44:24 <merijn> % (f,g) = ((+), (-))
05:44:24 <yahb> merijn: 
05:44:28 <merijn> % :t f
05:44:28 <yahb> merijn: Integer -> Integer -> Integer
05:44:49 <merijn> heh
05:45:25 <merijn> oh, i had the MMR of in ghci >.>
05:45:36 <dminuoso> Also regarding type signatures, at the time I was using lens :p
05:45:50 <merijn> That's your own fault
05:45:57 <dminuoso> Heh. Well I do use optics now
05:46:01 <dminuoso> so everything is simple now :)
06:13:49 <maralorn> Wait does that mean a let (f,g) = binding can never be polymorphic? That contradicts my memory.
06:15:03 <dminuoso> maralorn: It can be if you set -XNoMonomorphismRestriction
06:15:07 <dminuoso> Or some equivalent
06:16:45 <maralorn> dminuoso: I am confused. I probably should read that report section. But a simple test in ghci worked for (a, b) = ... where a :: Num a => a, b :: Num a => a
06:17:06 <dminuoso> maralorn: GHCi has MMR disabled
06:17:19 <dminuoso> maralorn: Set -XMonomorphismRestriction to get it back to default.
06:19:28 <maralorn> Aah
06:20:04 <dminuoso> I did that sneakily in a PM to yahb before the demonstration, earlier.
06:22:42 <maralorn> ^^
06:25:28 <maralorn> Now i feel allowed to be confused.^^
06:30:59 <Orbstheorem> merijn: Thank you for the insight :)
06:43:43 <nil> maralorn: the MMR doesn't apply to e.g. (f, g) = (const, id) as there are no constraints involved
06:44:10 <alehander92> what other examples are
06:44:21 <alehander92> of encoding state which is hard to express without dependent types
06:44:34 <alehander92> i guess stuff like invariants between values?
06:44:40 <alehander92> or ranges of numbers?
07:01:57 <frdg`> say I have a table that organizes data based on row headers and column headers. What is a suitable way to organize data such that it holds a key to both the row header and column header?
07:03:13 <phadej> alehander92: cases like ^
07:03:23 <frdg`> I could just use a triple but am wondering if there is a better way.
07:03:47 <merijn> frdg`: A database? *duck*
07:04:58 <frdg`> merijn: huh I never thought of it like that
07:09:41 <frdg`> merijn: Wow I have should of thought of this sooner. Using a database for this will make everything I want to happen work in a much simpler and more expandable way.
07:19:32 <merijn> frdg`: I had this brilliant inception because I spend 1.5 years implementing something like that myself, eventually ripped it out and replaced it with SQLite and then my life became much better ;)
07:25:28 <thblt> I'm trying to understand a bit more about Applicative, and I kinda get the typeclass, but not really what it could be useful.  What package can I read to get a feel of what I can *do* with them?
07:25:42 <thblt> (Also, liftA2 is just a generalized zipWith, right?)
07:25:48 <thblt> Thanks!
07:26:08 <merijn> thblt: "generalized zipWith" <- well...maybe
07:26:18 <merijn> Depends on how you define generalised and zipWith :p
07:26:21 <phadej> https://arxiv.org/abs/1403.0749
07:26:32 <phadej> """  Applicative functors are to be preferred to monads when the structure of a computation is fixed a priori.
07:26:44 <phadej> """  That makes it possible to perform certain kinds of static analysis on applicative values.
07:27:18 <merijn> thblt: There's no real library that will "teach" you applicatives, otoh you will end up using them all the time since they're *everywhere*
07:27:38 <merijn> Like, I don't think I've ever written more than ~200 lines of Haskell without Applicative being used somewhere :p
07:27:49 <thblt> merijn: well, as in the [] instance of Applicative, liftA2 = zipWith, right? :)
07:27:54 <phadej> it is
07:27:56 <thblt> phadej: thanks, will read this.
07:28:01 <merijn> phadej: No it's not
07:28:07 <phadej> ah no
07:28:08 <merijn> thblt: Not quite
07:28:10 <phadej> ZipList
07:28:26 <phadej> merijn: an instance of Applicative which isn't also a Monad?
07:28:27 <merijn> thblt: You are, correct in seeing that that is an Applicative, but it's not the one defined for lists
07:28:42 <merijn> phadej: Wait, maybe I'm confused what you were referring too
07:28:52 <merijn> phadej: I thought you were answering thblt with "it is"
07:29:12 <merijn> thblt: So, turns out the lists have 2 possible (lawful) Applicative instances
07:29:16 <thblt> phadej: ok, maybe I can narrow down my question: I want to like <*>, but I fail to see in what practical cases I'd want to have a function lifted in the same type as its arguments.
07:29:47 <merijn> thblt: One of them is, indeed, zipWith, but it's not the default, because there is no Monad instance that matches it
07:30:10 <merijn> thblt: So instead the default instance for [] is the one which has a corresponding Monad (which does cartesian product)
07:30:24 <merijn> > (,) <$> [1..3] <*> [4..6]
07:30:26 <lambdabot>  [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
07:30:30 <merijn> Compare with
07:30:31 <thblt> merijn: thanks for the clarification :)
07:30:47 <merijn> > getZipList $ (,) <$> ZipList [1..3] <*> ZipList [4..6]
07:30:49 <lambdabot>  [(1,4),(2,5),(3,6)]
07:30:55 <phadej> but... 
07:31:04 <merijn> thblt: With "newtype ZipList a = ZipList { getZipList :: [a] }"
07:31:06 <phadej> > [ (x,y) | x <- [1..3], y <- [4..6] ]
07:31:08 <lambdabot>  [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
07:31:12 <phadej> the same as first
07:31:32 <phadej> and whether you want to use list comprehensions or Applicative combinators is mostyl matter of taste
07:31:34 <merijn> thblt: It's not about lifting function to their arguments
07:31:50 <merijn> thblt: I mean, I guess you can view "liftA2" that way, but most people will use <$> and <*>
07:32:00 <merijn> :t (<$>)
07:32:01 <lambdabot> Functor f => (a -> b) -> f a -> f b
07:32:13 <merijn> thblt: So <$> is just fmap, right. Apply a function to an 'a' inside some 'f'
07:32:25 <merijn> :t (<*>)
07:32:26 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
07:32:31 <thblt> Yeah, that I got, and I see it's useful.
07:32:35 <merijn> That's new with Applicative
07:32:42 <phadej> tldr; don't think too hard about Applicatives, if you don't see values in them, then it's fine.
07:33:00 <merijn> "if you have an function 'a -> b' inside an 'f', and an 'a' inside an 'f', apply the function to the 'a'"
07:33:01 <phadej> it's enough to know that they exist, for when you run into situations when you deal with non-Monads
07:33:54 <merijn> thblt: For example, if I have "getInt :: IO Int" which reads a number from stdin. I can do "fmap (+1)" to read a number and increment it, but I can't do "read two numbers and add them" with just Functor
07:34:11 <merijn> thblt: Functor gives you no way to combine two separate "IO Int" values together
07:34:38 <thblt> merijn: I'm with you, and I think that's what I was looking for.
07:34:44 <merijn> thblt: "(+) <$> getInt" has type "IO (Int -> Int)" ((+) applied to one argument)
07:34:48 <merijn> But then you're stuck
07:34:57 <merijn> Now, with Applicative you get <*>
07:35:08 <merijn> and then you can write "(+) <$> getInt <*> getInt"
07:35:29 * thblt pops ghci
07:35:33 <merijn> You can "continue" with your partially applied function
07:35:43 <merijn> thblt: Warning, I made up getInt ;)
07:36:04 <phadej> http://www.staff.city.ac.uk/~ross/papers/Applicative.pdf is another good reada
07:36:07 <thblt> merijn: I can write that :)
07:36:10 <phadej> expecially sections 3,4,5
07:36:19 <phadej> which I think people don't read that often
07:36:21 <merijn> thblt: This is also useful in parser combinator libraries like megaparsec, where you can use Applicative to combine results from two separate parsers
07:37:36 <merijn> thblt: Note that if we talk in "effects" (a poor and confusing name, but bear with me) the type signature of <*> gives you no way to control which effects run. (Say, in IO) so they always run unconditionally
07:38:21 <frdg`> why is (<|>) part of the Applicative library? I do not see the relationship.
07:38:23 <merijn> thblt: This is what distinguishes Monads from Applicatives. Functor let you apply pure functions, Applicatives let you "combine/group" effects (whatever that means abstractly), Monad gives you the power to run "effects" *conditionally*
07:38:45 <merijn> frdg`: Because Applicative is a superclass of Alternative
07:38:48 <dminuoso> thblt: The point of Applicative is two-fold. Sometimes, Applicative might have a more efficient implementation if you only use <*> rather than >>=. And furthermore, there's things that only admit Applicative either because you can't make it Monadic (ZipList being an example), or because you want to do static analysis. optparse-applicative is an example of the latter.
07:38:59 <c_wraith> frdg`: mostly historical.  Both came from use in parsers.  They were kind of factoring out the parts that had nothing to do with parsing per se.
07:39:22 <frdg`> ok cool
07:40:33 <merijn> thblt: Consider how "(>>=) :: Monad m => m a -> (a -> m b) -> m b" lets you use "\b -> if b then effectA else effectB" as argument function which clearly shows the ability to pick effects based on values (and thus do things conditionally) which you cannot achieve with the functions in Applicative
07:44:17 <thblt> merijn: phadej: dminuoso: Thanks a lot all, it's really helpful!
07:47:29 <Orbstheorem> What's the preferred way to access paths in haskell? I vaguely remember __not to__ use Paths_<package> in NixOS if I wanted my package to be "portable".
07:48:19 * hackage network 3.1.2.0 - Low-level networking interface  https://hackage.haskell.org/package/network-3.1.2.0 (dukerutledge)
07:48:35 <merijn> That sounds like NixOS breaks the entire portability options of cabal, then
07:48:59 <merijn> Orbstheorem: What paths do you want to access and why?
07:49:19 * hackage aeson 1.5.3.0 - Fast JSON parsing and encoding  https://hackage.haskell.org/package/aeson-1.5.3.0 (AdamBergmark)
07:49:53 <Orbstheorem> I have yaml example configuration files which I want to run my tests with.
07:50:12 <Orbstheorem> (configuration files of my application.)
07:51:01 <merijn> yeah, the only robust way to do that is Paths_ so if NixOS breaks that...
07:52:04 * Orbstheorem will go ask on #nixos
08:00:51 <dminuoso> thblt: That being said, there's another typeclass in that area called Selective. You can think of it as sitting between Applicative and Monad. You get the power to conditionally run a second effect. So you can statically analyze what effects *could* be run, while having the power to dynamically decide on the effects. That typeclass is somewhat underused, sadly. :)
08:01:37 <dminuoso> The signature function describing this could be `branch :: Selective f => f (Either a b) -> f (a -> c) -> f (b -> c) -> f c` - think of this as a sort of `either` with effects. :)
08:13:36 <sm[m]> frdg`: I always expect to find <|> in Control.Alternative as well
08:15:31 <thblt> dminuoso: thanks, i'll add that to my to-read list :)
08:15:51 <sm[m]> ...which doesn't exist except in my mind. That would explain it.
08:17:01 <sm[m]> I guess it's in purescript. And there's a haskell Control.Applicative.Alternative and Control.Alternative.Free
08:21:40 <thblt> sm[m]: My GHCI knows <|> but for Applicative
08:22:00 <thblt> (Why I uppercased ghci, I have no idea.)
08:22:19 * hackage jsop 0.1.0.0 - Cherry picking in JSON objects  https://hackage.haskell.org/package/jsop-0.1.0.0 (PaoloVeronelli)
08:22:22 <ddellacosta> sm[m]: yeah, I tried to import Control.Alternative for <|> just the other day. Whoops
08:30:24 <hololeap> Orbstheorem: isn't the filepath package the preferred way?
08:37:16 <Orbstheorem> hololeap: filepath doesn't give me access to files within my project.
08:38:36 <ezzieyguywuf> Orbstheorem: Isn't like MyModule_Paths
08:38:49 <ezzieyguywuf> Orbstheorem: and cabal auto-generates the XXX_Paths module
08:45:44 <Orbstheorem> ezzieyguywuf: I seem to recall someone telling me not to use that.
08:45:56 <Orbstheorem> Oh, well, I guess I'll go with that and see what breaks.
08:46:11 <ezzieyguywuf> Orbstheorem: what are you trying to do exactly?
08:47:12 <Orbstheorem> As I said, I have yaml example configuration files for my app which I want to run my tests with.
08:47:53 <ezzieyguywuf> Orbstheorem: XXX_Paths should probably be fine, but really you shouldn't trust me I  don't really know what I'm talking about.
08:50:25 <sm[m]> Orbstheorem: the two main approaches are to use Paths_, which is fragile, or to embed the files with file-embed
08:53:04 <Orbstheorem> Oh, I like the idea of file-embed :D
08:53:57 <Orbstheorem> QuickCheck passes \o/
08:54:00 <Orbstheorem> (After 2 days xD)
08:57:08 <ezzieyguywuf> Orbstheorem: you did it!
09:33:19 <Orbstheorem> How do you usually deal with orphan instances?
09:33:53 <Orbstheorem> Why is it a compiler warning and in case you leave it on, how do you reorganize your code to avoid it?
09:35:28 <thblt> Orbstheorem: IIUC it's a compiler warning because it makes possible for a type to have different instance implementations in different modules. It's probably be introduced to give C++ programmers their familiar level of #include hell :)
09:36:04 <thblt> Orbstheorem: a common solution I've seen, if you need an instance for a type and a class that arent't yours, is  newtype 
09:43:55 <Orbstheorem> <C++ programmers> ROFL x)
09:44:36 <dminuoso> Orbstheorem: Orphan instances are bad because they can lead to incoherent code.
09:45:10 <dminuoso> Consider https://gitlab.com/dminuoso/incoherent-orphan-instances as a contrived example how this can happen
09:46:07 <dminuoso> The way to "deal" with them, is to either newtype, or limit orphan instances to certain situations (they are usually fine in test packages, or when used in an executable package)
09:48:22 <dminuoso> Another situation is a surrogate package, say aeson-instances, where you provide orphan instances for packages such that people can depend on aeson without incurring too many transitive dependencies, whose only purpose would have been to provide instances.
09:51:11 <sm[m]> hooray, after rebuilding the world with --profile I got an excellent call stack: https://termbin.com/f0ld
09:51:38 <aldessa> With Reflex FRP, is there a better way than having, can_buy = ffilter predicate to_buy, cant_buy = ffilter not.predicate to_buy?
09:51:54 <aldessa> It seems a bit pointless doing the calculation twice
09:52:14 <sm[m]> I though I would get this with a non-profiling build, with GHC 8.10. I guess not, that still only gives a HasCallStack trace ?
09:57:10 <merijn> sm[m]: No, the profiling call stacks piggyback on the profiling cost centres inserted
09:57:23 <merijn> (no as in, no you can't get that)
09:57:32 <merijn> sm[m]: There's some work on DWARF based callstacks, though
09:58:08 <merijn> sm[m]: Those (unlike profiling cost centres) don't have runtime overhead, so are more realistically usable to deploy in production code
10:06:20 * hackage github-rest 1.0.3 - Query the GitHub REST API programmatically  https://hackage.haskell.org/package/github-rest-1.0.3 (leapyear)
10:07:53 <sm[m]> merijn: thanks, I guess I may have been thinking of DWARF stacks, which I've been hearing are in GHC but I guess are still WIP
10:08:02 <sm[m]> those are the only three kinds of call stack we deal with, if I'm not mistaken ?
10:08:06 <sm[m]> how fantastic it would be to get those full accurate call stacks reliably out of the box
10:10:53 <merijn> sm[m]: That's incredibly hard to do without also lowering the performance of code dramatically, though
10:11:13 <sm[m]> yes
10:11:51 <sm[m]> still, to have that mode always available with a cli flag, no matter how you built
10:12:44 <sm[m]> or is that a security problem. Bah, I guess you have to enable it only for special builds, require -rtsopts at least
10:12:49 * hackage postgresql-typed 0.6.1.2 - PostgreSQL interface with compile-time SQL type checking, optional HDBC backend  https://hackage.haskell.org/package/postgresql-typed-0.6.1.2 (DylanSimon)
10:22:24 <orcus> aldessa: perhaps fanEither is what you want? (Though internally it is just two 'mapMaybe's ...)
10:25:54 <L29Ah> what am i doing wrong? my generic function fails to typecheck when i try to make it a separate function, as opposed to one that's hardcoded to a specific example type:
10:25:55 <L29Ah> https://dpaste.com/9JMJRWRU4
10:25:56 <L29Ah> https://dpaste.com/AULCHARF2
10:26:04 <L29Ah> and the error messages are really cryptic
10:27:05 <L29Ah> if i replace arguments to `from` and Proxy type with {the value of ,} my type, it works as expected
10:32:49 <lyxia> I suspect an issue with the lambda, try pattern-matching on the argument directly with case
10:34:07 <lyxia> It's hard to infer the type of an anonymous function with GADTs
10:34:37 <aldessa> @orcus thank you, it is better although it looks worse but that's because i made it a one liner by accident
10:34:37 <lambdabot> Unknown command, try @list
10:35:49 * hackage zeolite-lang 0.8.0.0 - Zeolite is a statically-typed, general-purpose programming language.  https://hackage.haskell.org/package/zeolite-lang-0.8.0.0 (ta0kira)
10:37:10 <L29Ah> lyxia: but whether it's a lambda or case it doesn't matter from the typechecker standpoint as both are anonymous pattern-matching functions
10:44:10 <ddellacosta> is Haskell's type system (ignoring extensions) sound?
10:45:04 <frdg`> I often get `unexpected do block in function application` errors and have trouble figuring them out. I do not see what is wrong with this code: https://dpaste.org/ox3z
10:47:16 <merijn> frdg`: You didn't paste the full code,the error shows more lines after the case
10:47:33 <frdg`> that should explain a lot
10:48:12 <merijn> Also, consider moving the case branches into where blocks to clean up the main body
10:53:53 <lyxia> L29Ah: Ok yeah that's not the problem here, but I mentioned it because the type of anonymous functions with GADT inputs is a pretty common source of problem.
10:57:59 <lyxia> Instead a problem here is that the type of rec cannot be inferred. you can't even express it without adding constraints about the DatatTypeInfoOf a or using type families.
11:09:14 <jle`> L29Ah: for debugging things like this, i like to try adding type annotations
11:09:32 <jle`> sometimes it helps the typechecker, and other times it reveals what i don't understand
11:09:53 <jle`> L29Ah: what happens when give recs and dat a type signature?
11:11:54 <jle`> by "things like this" i mean errors about ambiguous type variables, like 'The type variable ‘h0’ is ambiguous' in your case
11:12:33 <jle`> in particular it looks like ghc can't infer the type of dat, so giving it a type annotation would help it along th eway
11:12:53 <jle`> if you aren't sure what to put, try asking what the type of 'dat' is when you have a speicific type, like in your example that worked
11:34:53 <L29Ah> jle`: well, the problem is the type depends on the type i've supplied in a non-trivial way
11:35:11 <L29Ah> say, i have `data T = T { foo :: Int, bar :: String, baz :: Bool} deriving (GHC.Generic, Show)` in my working example
11:35:18 <L29Ah> then recs :: NP FieldInfo '[Int, [Char], Bool]
11:35:22 <jle`> yes, the problem is to figure out what that non-trivial way is
11:35:32 <jle`> er, the solution
11:35:50 <L29Ah> and i have zero clue how to do such type-level conversions
11:36:07 <jle`> L29Ah: so ghc know it is '[Int, [Char], Bool] ?
11:36:10 <jle`> where does that list come from?
11:36:19 <L29Ah> λ> :t recs
11:36:25 <jle`> i mean, programatically
11:36:36 <jle`> how does it link 'T' with '[Int, [Char], Bool] ?
11:36:37 <L29Ah> recs = (\(ADT _ _ (Record _ fields :* Nil) _) -> fields) $ datatypeInfo (Proxy :: Proxy T)
11:36:44 <jle`> where does that association come from?
11:37:07 <L29Ah> somewhere deep in https://hackage.haskell.org/package/generics-sop
11:37:15 <jle`> maybe not as deep as you think :)
11:37:17 * L29Ah doesn't understand most of the types utilized there
11:37:22 <jle`> https://hackage.haskell.org/package/generics-sop-0.5.1.0/docs/Generics-SOP.html
11:37:34 <jle`> https://hackage.haskell.org/package/generics-sop-0.5.1.0/docs/Generics-SOP.html#t:Code
11:37:58 <jle`> λ> :kind! Code T
11:38:03 <jle`>  '[Int, [Char], Bool]
11:38:42 <jle`> but i think at least in this case you might not need to get the full type
11:38:57 <jle`> it looks like the error was being triggered on the 'h0' / NP part, not the code part
11:39:09 <jle`> so maybe `recs :: NP FieldInfo _` would work too
11:39:18 <jle`> since it was having trouble inferring NP in the error
11:40:10 <jle`> but in any case having a full type signature for tricky bindings can nice for readability, so recs :: NP FieldInfo (Code a) wouldn't be too bad either
11:41:39 <L29Ah> jle`: then i get     • Expected kind ‘[*]’, but ‘Code a’ has kind ‘[[*]]’
11:42:03 <jle`> oh ah, Code is the sum-of-products
11:42:09 <jle`> λ> :kind! Code T
11:42:11 <L29Ah> hammered ProductCode in there, now i get the original whining it seems
11:42:18 <jle`>  '[ '[Int, [Char], Bool] ]
11:42:29 <jle`> do you want your function to only work on things with a single constructor?
11:42:32 <L29Ah> (my code actually only supposed to work for products, not sums)
11:42:48 <L29Ah> yexs
11:43:18 <jle`> then you can match on your single constructor in the type maybe
11:43:40 <jle`> myShow :: forall a fs. (Generic a, HasDatatypeInfo a, Code a ~ '[fs]) => a -> [String]
11:44:02 <jle`> which means you can only call that function if the Code is a singleton list, and fs is your product
11:44:19 <jle`> so because Code T ~ '[ '[Int, String, Bool] ], then fs would be '[Int, String, Bool]
11:44:31 <jle`> and then you can have recs :: NP FieldInfo fs
11:45:01 <jle`> this also has a nice benefit of restricting `myShow` to only compile if Code a is a singleton list, so you can't ever call it on a sum type
11:45:30 <lyxia> You could also directly generalize the function, rather than trying to handle the case where it has a single constructor
11:45:51 <jle`> oh ah, it looks like generics-sop has some built-in things to handle this pattern, ProductCode/IsProductType/etc.
11:46:06 <jle`> myShow :: forall a fs. IsProductType a fs => ...
11:46:07 <lyxia> using the higher-order combinators of sop instead of pattern-matching on stuff manually
11:46:14 <L29Ah> lyxia: i think that would be even harder than fixing this stuff
11:46:28 <jle`> and then you can use 'productTypeFrom' instead of 'from'
11:46:31 <L29Ah> those combinators have mind-boggling types i don't even
11:47:02 <lyxia> well the result is going to be shorter and not involve manually defining your own type families
11:47:41 <jle`> i don't think you'd need to define any custom type families, but it just would basically be the code you would be writing anyways
11:47:49 <jle`> for example your 'dat' is actually just `productTypeFrom`
11:48:07 <jle`> productTypeFrom = (\(SOP (Z fields) -> fields) . from
11:48:36 <L29Ah> yay thanks now it works
11:48:37 <jle`> and yeah, my suggestin of (Generic a, Code a ~ '[fs]) is just `IsProductType`
11:48:48 <jle`> so it looks like they thought of your use case before
11:48:52 <jle`> but it actually isn't too bad to do from scratch
11:49:09 <jle`> like you were just doing it
11:49:17 <L29Ah> expanding it to work with SOPs sounds fun though
11:49:45 <jle`> oh boy :)
11:49:54 <L29Ah> i'd better read some sop examples
11:50:11 <lyxia> it's not too bad if you're already proficient with type-level programming
11:50:15 <L29Ah> as i have zero clue how to parse those type signature of the combinators
11:50:34 <jle`> it helps me to try to trace the types of those combinators for concrete types
11:50:38 <jle`> like your T, or a custom sum type you made
11:50:52 <jle`> seeing the actual concrete lists makes things a bit clearer for me
11:50:58 <L29Ah> sounds good, thanks
11:51:06 <jle`> -XTypeApplications will help
11:51:25 <jle`> λ> :t productTypeFrom @T
11:51:33 <jle`>   T -> NP I '[ Int, [Char], Bool ]
11:54:47 <L29Ah> does the @type just go into the first type variable of the corresponding expression?
11:59:25 <jle`> L29Ah: yeah
11:59:39 <jle`> % :t fmap @Maybe
11:59:39 <yahb> jle`: (a -> b) -> Maybe a -> Maybe b
11:59:45 <jle`> % :t fmap @Maybe @Int
11:59:45 <yahb> jle`: (Int -> b) -> Maybe Int -> Maybe b
11:59:48 <jle`> % :t fmap @_ @Int
11:59:48 <yahb> jle`: Functor _ => (Int -> b) -> _ Int -> _ b
12:00:09 <jle`> % :t fmap
12:00:09 <yahb> jle`: Functor f => (a -> b) -> f a -> f b
12:00:41 <jle`> it goes in the order that the variables appear in the type signature, including any forall's
12:13:21 <koala_man> huh. cabal says it can't create a link in /home/vidar/.cabal/bin because there's a non-cabal managed file there, so it installed it in /home/vidar/.cabal/bin instead. task failed successfully I guess
12:13:45 <monochrom> haha
12:15:05 <dolio> You can't use the order that the variables occur in :t to reliably determine the order to explicitly apply variables.
12:15:28 <dolio> You need to apply them in the order they're quantified in the actual definition you're applying.
12:15:38 <gmt> cd
12:15:47 <dolio> Which may not be the order of ocurrence in :t.
12:17:31 <dmwit> :t +v
12:17:32 <lambdabot> <no location info>: error: not an expression: ‘’
12:18:12 <dmwit> (...was made to address that problem)
12:18:48 <dmwit> You probably also want to turn on -fprint-explicit-foralls if the reason you're using it is for type applications.
12:19:17 * merijn repeats his mantra of "don't use -XTypeApplications"
12:20:14 <dolio> You might, but `:t` will not show you the right answer even then.
12:21:15 <dolio> Because :t is showing you the inferred type of an expression, which might reorder the quantifiers, not the declared type of the definition.
12:21:17 <merijn> TypeApplications is great, if you wanna give up literally every advantage PVP versioning of your dependencies gives you :)
12:21:47 <dolio> :i seems to give the right answer.
12:34:15 <pounce> can anybody help me with haskell package management on arch? (just good sanity suggestions)
12:34:35 <pounce> I wanted `ghc-mod` but `cabal install ghc-mod` has turned into a wild goose chase
12:34:36 <sm[m]> pounce: trying to improve it, or use it ?
12:34:40 <pounce> use it
12:35:25 <merijn> pounce: Simple solution is to basically ignore it (the arch side)
12:35:34 <sm[m]> it's a frequent problem, I'll let someone expert answer, there's also an arch wiki page
12:36:00 <merijn> pounce: It's super broken. There's a wiki page if you insist on using arch's packages, but just installing cabal and GHC via ghcup is probably easiest
12:36:15 <merijn> pounce: That said, ghc-mod is deprecated and no longer maintained
12:36:18 <tomsmeding> second ghcup
12:36:47 <sm[m]> quibble, stack is easiest
12:36:58 <tomsmeding> and takes the most disk space and is the slowest
12:37:04 <tomsmeding> but yes, it's also the easiest :)
12:37:06 <merijn> sm[m]: He was using cabal-install currently, so I assumed that's what he intend to use/keep using
12:37:15 <sm[m]> yup
12:37:28 <sm[m]> tomsmeding: stack takes more disk space than cabal ?
12:37:41 <merijn> pounce: https://github.com/DanielG/ghc-mod#legacy
12:37:47 <tomsmeding> cabal has less of a habit of installing a different ghc version for each project you're building
12:37:58 <tomsmeding> otherwise, granted, there isn't an appreciable difference in my experience
12:37:59 <merijn> sm[m]: Not unlikely, since multiple GHC can quickly/easily outweight lots of packages
12:38:16 <sm[m]> true, stack encourages per project ghc more, cabal encourages trying to reuse installed ghc more
12:40:14 <pounce> the only problem is when I install `stack` it pulls alongside a ton of hs packages... so "only" using it is somewhat difficult
12:41:38 <sm[m]> pounce: installing arch's stack package installs a bunch of other hs arch packages ? more than arch's cabal package ?
12:41:54 <merijn> Welcome to the world of incredibly poor decisionmaking of Arch's maintainers
12:42:32 <pounce> indeed :(
12:42:58 <merijn> pounce: Stack should provide binaries you can just install directly, though (so do GHC and cabal-install)
12:43:57 <monochrom> I still have a feeling that people conflate "install" with "build from source".
12:44:09 <merijn> monochrom: No, that's not the issue
12:44:16 <monochrom> Ah OK sorry!
12:44:32 <merijn> monochrom: The issue is that Arch maintainer's insist *all* libraries must *always* be installed as shared library
12:44:49 <merijn> monochrom: So their haskell packages literally install *all* haskell dependencies independently as system package
12:45:05 <merijn> monochrom: So something like pandoc incurs like 115 dependencies and they need to reinstall all of them each time
12:45:24 <ddellacosta> is this just specific to Haskell in arch or a "global policy?" I would expect this would cause problems with other language environments as well
12:45:27 <merijn> monochrom: Rather than, you know, doing the sensible thing of linking haskell statically and installing a single pandoc binary
12:45:34 <merijn> ddellacosta: Global policy
12:45:53 <merijn> ddellacosta: They refuse to make an exception for Haskell, despite dynamic linking making basically no sense
12:46:00 <merijn> (in haskell, I mean)
12:46:02 <ddellacosta> huh.
12:46:06 <merijn> monochrom: Even "funnier"
12:46:27 <merijn> monochrom: They even refuse to install the GHC static libs/runtime by default, but those are still the default compilation mode of GHC
12:46:48 <merijn> monochrom: So the default install of GHC fails with cryptic linker errors when invoked in the most trivial example any Haskell tutorial uses
12:48:16 <monochrom> Yeah
12:48:26 <merijn> yay...
12:48:47 <gnubison> unpl (. f) . g
12:49:06 <xerox_> \x y -> g x (f y)
13:02:48 <iqubic> So, I have "data Foo v a = Foo (v a) (v a)" How can I automatically derive Show and Eq?
13:03:06 <monochrom> deriving (Show, Eq)
13:03:53 <Cale> Or if you mean with standalone deriving, you'll probably need something like  deriving instance (Show (v a)) => Show (Foo v a)
13:04:21 <jle`> dolio: thanks for that, i always forget
13:04:38 <jle`> dolio: that the :t and the sig in the haddock don't always mwatch
13:05:02 <iqubic> monochrom: What if I have "Data Foo v = Foo (v Int) (v Int)"?
13:05:23 <dminuoso> iqubic: Look into Show1 :)
13:05:28 <solonarv> pretty much the same
13:05:33 <iqubic> Why do we need Show1?
13:05:37 <solonarv> '... deriving (Show, Eq)' works
13:05:50 <dminuoso> Oh wait, yea just derive Show heh
13:05:56 <jle`> @let data Foo v = Foo (v Int) (v Int) deriving Show
13:05:57 <lambdabot>  .L.hs:172:25: error:
13:05:57 <lambdabot>      • No instance for (Show (v Int))
13:05:57 <lambdabot>          arising from the first field of ‘Foo’ (type ‘v Int’)
13:06:06 <solonarv> as does a standalone 'deriving instance Show (v Int) => Show (Foo v)'
13:06:08 <jle`> looks like you might need standalone deriving
13:06:12 <solonarv> ah I guess you need the standalone instance
13:07:01 <jle`> @let data Foo v = Foo (v Int) (v Int)
13:07:03 <lambdabot>  Defined.
13:07:10 <jle`> @let deriving instance Show (v Int) => Show (Foo v)
13:07:10 <iqubic> Why do I need standalone deriving?
13:07:11 <lambdabot>  Defined.
13:07:26 <jle`> i guess ghc can't handle funky constraints
13:07:37 <jle`> maybe it can only handle constraints on type variables
13:07:51 <jle`> and not constraints on things that use type variables
13:07:52 <iqubic> @let bar = Maybe 10 :: Foo Maybe
13:07:53 <lambdabot>  .L.hs:174:7: error:
13:07:54 <lambdabot>      • Data constructor not in scope: Maybe :: Integer -> Foo Maybe
13:07:54 <lambdabot>      • Perhaps you meant one of these:
13:08:02 <iqubic> Hmm?
13:08:10 <jle`> what are you trying to do?
13:08:44 <iqubic> @let bar = (Maybe 10) :: Foo Maybe
13:08:45 <lambdabot>  .L.hs:174:8: error:
13:08:46 <lambdabot>      • Data constructor not in scope: Maybe :: Integer -> Foo Maybe
13:08:46 <lambdabot>      • Perhaps you meant one of these:
13:09:04 <jle`> are you trying to create a value of type `Foo Maybe`
13:09:10 <iqubic> Yes
13:09:15 <jle`> look at the data constructor for Foo
13:09:40 <iqubic> @let bar = Foo (Maybe 10)
13:09:41 <lambdabot>  .L.hs:174:12: error:
13:09:41 <lambdabot>      • Data constructor not in scope: Maybe :: Integer -> v Int
13:09:41 <lambdabot>      • Perhaps you meant one of these:
13:09:51 <iqubic> Hmm?
13:09:58 <jle`> what doe sthe data constructor for Foo take
13:10:08 <jle`> if you're trying to make a `Foo Maybe`
13:10:22 <iqubic> @let bar = Foo (Maybe 10) (Maybe 20)
13:10:24 <lambdabot>  .L.hs:174:12: error:
13:10:24 <lambdabot>      • Data constructor not in scope: Maybe :: Integer -> v Int
13:10:25 <lambdabot>      • Perhaps you meant one of these:
13:10:35 <iqubic> @let bar = Foo (Nothing) (Just 20)
13:10:37 <lambdabot>  Defined.
13:10:38 <jle`> what does the data constructor for Foo take
13:10:48 <jle`> ah yeah you figured it out, it takes a value of type Maybe Int
13:10:50 <iqubic> I haven't done haskell programing in a while.
13:11:01 <iqubic> > show bar
13:11:04 <lambdabot>  "Foo Nothing (Just 20)"
13:11:08 <iqubic> Cool
13:11:13 <jle`> > bar
13:11:15 <lambdabot>  Foo Nothing (Just 20)
13:11:39 <iqubic> I'm rusty on my Haskell
13:12:05 <jle`> that's ok :)
13:14:12 <iqubic> Well, I tried this in an actual HS file and got this error: https://dpaste.com/7F8W934DW
13:15:42 <jle`> there is a suggestion on how to fix it in the error message :)
13:17:00 <iqubic> I understand. I'm just wondering why this error shows up there, and not in GHCi
13:17:25 <jle`> it should show up in ghci if you don't have that extension enbaled
13:17:37 <monochrom> Your .ghci turns on a whole lot of extensions?
13:17:53 <jle`> it shows up in my ghci
13:17:58 <monochrom> This is why I don't turn on any extension in .ghci
13:18:15 <monochrom> People thought it would be so convenient. People fool themselves.
13:18:30 <solonarv> I turn on TemplateHaskell so I can have multiline strings
13:18:38 <solonarv> don't think I've used that in ages though
13:18:39 <monochrom> People set up traps for themselves for maximum surprise.
13:18:59 <monochrom> I don't even muck with the prompt.
13:19:14 <iqubic> I didn't actually try it in GHCi, but saw what happened here with lambdabot.
13:19:16 <ddellacosta> I always have to set OverloadedStrings when I use ghci though, which is conversely a pain
13:19:39 <monochrom> Oh lambdabot turns on a ton of extensions, too.
13:19:48 <iqubic> I assumed that lambdabot was a vanilla, unmodified GHCi
13:20:07 <jle`> i don't even think it uses ghci
13:20:11 <jle`> it uses ghc directly i believe
13:20:33 <jle`> it uses ghc's "evaluate this expression" option which nobody uses in real life heh
13:20:41 <monochrom> It uses hint
13:21:19 <jle`> ah, so it seems. so not the command line option but the ghc api directly
13:21:46 <iqubic> What does undecidable instances even do?
13:22:03 <monochrom> It puts your expression in a file that says "main = print (your expression)" and that file also turns on a ton of extensions and a truckload of imports.
13:22:35 <jle`> it relaxes some of the restrictions on what instances are allowed
13:22:41 <iqubic> I see.
13:22:51 <jle`> in this case there is a restriction that constraints must be smaller than the instance head
13:23:03 <jle`> and UndecidableInstances turns off that restriction
13:23:20 <jle`> pretty much what it says in the error message :)
13:23:32 <iqubic> Interesting.
13:23:57 <jle`> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-UndecidableInstances
13:24:50 * hackage strict-base-types 0.7 - Strict variants of the types provided in base.  https://hackage.haskell.org/package/strict-base-types-0.7 (phadej)
13:26:51 <iqubic> Which is better? Mutable Vectors or Unboxed Vectors?
13:27:09 <iqubic> Can you have both at the same time?
13:27:27 <jle`> they do diferent things
13:27:33 <jle`> it depends on what you want to do
13:27:52 <iqubic> I see
13:27:52 <jle`> they are both good tools at for the different purposes they were designed for
13:29:21 <iqubic> What were unboxed vectors made for?
13:29:56 <jle`> efficient O(1) access and memory usage
13:30:46 <iqubic> But updates to an unboxed vector still causes the vector to be copied over to a new location, with a portion of it modified.
13:31:03 <jle`> right, it's not very good for updates
13:31:13 <jle`> it's arguably worse for updates than boxed vectors
13:31:21 <jle`> because any modification requires a deep clone
13:31:53 <jle`> but for boxed vectors it only requires a shallow clone, the data in the vector itself doesn't need to be copied, since the vector stores only pointers
13:32:47 <iqubic> Why can't you have a vector that's both mutable and unboxed?
13:33:05 <jle`> you can
13:33:07 <jle`> https://hackage.haskell.org/package/vector-0.12.1.2/docs/Data-Vector-Unboxed-Mutable.html
13:33:49 <iqubic> Why don't you always use that?
13:34:12 <jle`> the same reason why you would use immutable data vs. mutable data
13:34:14 <jle`> it's situational
13:34:28 <jle`> sometimes you don't want to do updates, immutable/persistent data structures can be nicer
13:34:32 <jle`> better for parallelism/concurrency
13:34:51 <jle`> it's basically the general tradeoff of mutable vs immutable
13:35:15 <jle`> sometimes guarantees that your data won't change as you use it are useful
13:35:26 <jle`> because you don't expect it to change so you don't have to enforce that it doesn't change
13:35:55 <jle`> basically the reason why you'd use an `Int` instead of an `IORef Int`
13:38:11 <dmwit> dolio: :t +v does not reorder type variables
13:41:10 <dolio> Ah, that's nice.
13:41:35 <frdg`> jle`: what is IORef Int?
13:42:06 <jle`> frdg`: `IORef a` is a mutable reference to an 'a' that you can access in IO
13:42:32 <jle`> % r <- newIORef 10
13:42:32 <yahb> jle`: 
13:42:35 <jle`> % readIORef r
13:42:35 <yahb> jle`: 10
13:42:40 <jle`> % setIORef r 20
13:42:40 <yahb> jle`: ; <interactive>:91:1: error:; * Variable not in scope: setIORef :: IORef Integer -> t0 -> t; * Perhaps you meant `newIORef' (imported from Data.IORef)
13:42:42 <frdg`> oh I see
13:43:04 <jle`> % writeIORef r 20
13:43:04 <yahb> jle`: 
13:43:06 <jle`> % readIORef r
13:43:06 <yahb> jle`: 20
13:43:20 <iqubic> Well, I managed to do a clever thing: `U.constructN n (\v -> if U.null v then 1 else U.length v * U.last v)` That creates an unboxed vector where v U.! n = n!
13:44:15 <jle`> nice :)
13:45:36 <iqubic> I'm implementing an algorithm that requires being able to get the factorial of numbers quite a lot.
13:46:33 <jle`> using a list can be nice because it can expand automatically, but there's the cost of O(n) access
13:46:57 <jle`> @let factorials = scanl (*) [1..]
13:46:58 <lambdabot>  Defined.
13:47:05 <jle`> > factorials !! 1000
13:47:07 <lambdabot>  error:
13:47:07 <lambdabot>      • Couldn't match expected type ‘[a]’
13:47:07 <lambdabot>                    with actual type ‘[[Integer]] -> [[Integer]]’
13:47:16 <jle`> whoops
13:47:42 <jle`> @let factorials = scanl (*) 1 [1..]
13:47:43 <lambdabot>  .L.hs:176:1: error:
13:47:43 <lambdabot>      Multiple declarations of ‘factorials’
13:47:44 <lambdabot>      Declared at: .L.hs:175:1
13:47:48 <jle`> :(
13:47:51 <iqubic> @undefine
13:47:51 <lambdabot> Undefined.
13:47:55 <jle`> @let factorials = scanl (*) 1 [1..]
13:47:57 <lambdabot>  Defined.
13:48:03 <jle`> > factorials !! 100000
13:48:09 <lambdabot>  mueval-core: Time limit exceeded
13:48:24 <jle`> oh i need the strict one
13:48:25 <jle`> @undefline
13:48:26 <lambdabot> Undefined.
13:48:27 <monochrom> You can always produce a list and fromList to the final vector you need.
13:48:36 <jle`> @let factorials = scanl' (*) 1 [1..]
13:48:38 <lambdabot>  Defined.
13:48:53 <iqubic> Yeah. I'm using a Vector here because here because I want O(1) access int this lookup table.
13:48:57 <monochrom> If the moons align, code optimization will even skip the list nodes.
13:49:04 <iqubic> I'm also using popcount too.
13:49:07 <jle`> monochrom: yeah, but the only reason why you'd ever use a list in the first place for this instead of a vector is if you want automatic expansion
13:49:23 <jle`> which...is pretty rare probably in an actual application
13:49:27 <monochrom> Hrm, that's tougher.
13:49:29 <jle`> > factorials !! 100000
13:49:33 <lambdabot>  2824229407960347874293421578024535518477494926091224850578918086542977950901...
13:50:02 <iqubic> I don't need automatic expansion, as the size of this look up table will be known at run time.
13:51:11 <jle`> isn't there a CPU instruction for the gamma function these days anyway
13:51:17 <iqubic> No.
13:51:23 <jle`> :(
13:51:50 <iqubic> Unfortunately not. If there was, I'd use that and skip the precomputing of the factorials.
13:55:31 <monochrom> I need to start a rumour about a new CPU instructor for the generalized Riemann hypothesis. :)
13:55:40 <jle`> i remember for advent of code a couple years ago i figured out a way to do automatic expansion /and/ O(1) lookups in lazy ST with unsafeInterleaveST
13:55:52 <jle`> but it's probably not worth it for most applications
13:56:44 <monochrom> SSEGRHJMP tgt --- jump to tgt iff GRH is true. Only on CPUs that feature SSE. :)
13:57:30 <jle`> that's the secret reason why apple switched to ARM
13:57:54 <jle`> wait i got that backwards
13:57:57 <monochrom> haha
14:04:19 * hackage req 3.5.0 - Easy-to-use, type-safe, expandable, high-level HTTP client library  https://hackage.haskell.org/package/req-3.5.0 (mrkkrp)
14:07:56 <sm[m]> I think not right now honey
14:08:28 <sm[m]> lol.. good one sm. That was about grocery shopping btw :)
14:09:11 <MarcelineVQ> uguu~ not right now daddy
14:09:16 <MarcelineVQ> What is the state of the art for streaming IO libs? e.g. conduit, streaming, streamly, machines
14:09:26 <MarcelineVQ> *libs in funtional languages
14:14:19 * hackage predicate-typed 0.7.3.0 - Predicates, Refinement types and Dsl  https://hackage.haskell.org/package/predicate-typed-0.7.3.0 (gbwey)
14:15:07 <jle`> MarcelineVQ: machines has always been more of a proof of concept sort of library 
14:15:25 <jle`> i use conduit personally for most things, but maybe only because there's a whole ecosystem around it
14:15:55 <jle`> but streaming/streamly are more hip modern maybe
14:16:17 <MarcelineVQ> I'm more wondering about what the newest form of streaming IO library looks like. It's not the easiest thing to scan for on arxiv :>
14:17:44 <jle`> tbh i'm not sure what advantage streaming/streamly have over conduit, i haven't been following it too closely
14:17:46 <nshepperd> unsafeInterleaveIO
14:21:33 <monochrom> That's the oldest form, not the newest form.
14:23:20 * hackage invertible 0.2.0.7 - bidirectional arrows, bijective functions, and invariant functors  https://hackage.haskell.org/package/invertible-0.2.0.7 (DylanSimon)
14:24:30 <nshepperd1> Ah, perhaps it needs a fancy new library to make it cool again
14:24:54 <mastarija> Is it possible to create a local type alias within a 'where' scope? Sometimes I wish I could do that to reduce the type noise in my code.
14:25:59 <solonarv> mastarija: nope, not possible
14:26:56 <mastarija> solonarv, damn. I've seen that in agda so I had my hopes up
14:27:29 <dminuoso> Is there some TH library to generate an sum type with boilerplate enum (or better yet some equivalent) instances from something like [("FOO", 1), ("BAR", 2)]?
14:27:47 <dminuoso> Use case is generating matching code for C enums since hsc2hs has no support for this
14:31:06 <iqubic> I wish there was some way to do updates to a mutable vector while maintining some state through the computation.
14:31:09 <infinisil> dminuoso: TH isn't too bad to use iirc, and this sounds reasonably simple
14:31:20 <iqubic> Something like forM_ but with state.
14:32:34 <dminuoso> infinisil: Oh yeah, just wondering whether Im not just reinventing the wheel. I cant be the first hsc2hs user wanting to use enums. :)
14:32:44 <dminuoso> (By use enums I mean map them into sum types)
14:54:21 <jle`> iqubic: what do you mean by state
14:54:33 <jle`> forM_ with state is just forM_ with StateT
14:54:37 <iqubic> Right.
14:54:53 <jle`> but you can just use normal parameter passing too
14:56:31 <iqubic> Basically at each step of the computation, I'm going to be consulting a (Bits a) value, updating, and then somehow passing it on to the next step of the computation.
14:56:50 <iqubic> s/consulting/reading
15:11:06 <iqubic> Basically, I want to have an ST s action that modifies my mutable vector, but I also need to track and update a (Bits a) value.
15:15:17 <Cale> iqubic: You're in ST, so you can just make an additional STRef
15:15:28 <iqubic> I can?
15:15:37 <Cale> or, you can use foldrM or whatever
15:15:54 <Cale> (or recursion, where you pass forward the new value)
15:16:00 <iqubic> Cool.
15:16:23 <iqubic> How does one make a new STRef?
15:16:40 <iqubic> I don't know much about ST
15:16:44 <Cale> myRef <- newSTRef initialValue
15:17:05 <Cale> and then you have  readSTRef :: STRef s a -> ST s a
15:17:21 <Cale> and writeSTRef :: STRef s a -> a -> ST s ()
15:17:56 <iqubic> Cool. Makes sense.
15:17:59 <Cale> (for completeness, newSTRef :: a -> ST s (STRef s a)
15:18:02 <Cale> )
15:18:57 <iqubic> Cool. So I can have a ~ (Bits b)
15:19:03 <iqubic> Sounds like what I want.
15:19:28 <iqubic> Is there a version of forM_ that gives me an index?
15:21:46 <iqubic> I wish there was like an imapM_
15:21:47 <iqubic> https://hackage.haskell.org/package/vector-0.12.1.2/docs/Data-Vector-Primitive.html#v:imap
15:21:53 <jle`> tbh the mutable interface in vectors is pretty limited
15:22:00 <jle`> but you can use forM_ with StateT i guess
15:22:54 <iqubic> Or just use an additional STRef
15:24:05 <iqubic> But either way I'm going to need to track how many time elements I've processed.
15:30:40 <monochrom> Efficiency-wise, ST-mutable vector is a great idea, STRef for just a few bits is a poor idea.
15:31:10 <monochrom> The latter is much more efficient under parameter passing.
15:31:24 <monochrom> (You can see the asm code for why.)
15:32:49 <monochrom> I once helped a beginner speed up code 5 times by just migrating from "STRef Int" to "Int -> ..."
15:34:45 <iqubic> I see.
15:35:16 <iqubic> I just wanted to use forM_ because I heard explicit recursion was bad.
15:35:30 <iqubic> I think I'll just use explicit recursion
15:35:54 <monochrom> False dichotomy.
15:36:40 <iqubic> What's the false dichotomy?
15:36:55 <monochrom> Simplistic "X is good", "X is bad".
15:37:52 <iqubic> Right.
15:48:20 <L29Ah> okay, Show was easy, now Read is going to be tricky
15:48:54 <L29Ah> json-sop uses a custom GADT for some strange reason
16:01:19 * hackage chart-svg-various 0.0.2 - See readme.md  https://hackage.haskell.org/package/chart-svg-various-0.0.2 (tonyday567)
16:18:40 <moet> does anybody have experience with jsaddle? i'm trying to figure out how to test small functions in ghci
16:21:28 <moet> the testJSaddle function used throughout their documentation seems to be unavailable
17:15:51 <monochrom> sob sob, there is no more https://cabal.readthedocs.io/en/stable/
17:16:22 <monochrom> I guess one day it will come back.
17:19:00 <monochrom> The 3.4 version looks really good though.
17:22:12 <hpc> i don't really like readthedocs
17:22:22 <hpc> it's unclear in the navigation which links are to new pages and which are to anchors
17:22:31 <hpc> makes it hard to keep track of what i have and haven't read
17:25:14 <sm[m]> sorry monochrom .. phadej dropped that
17:25:39 <sm[m]> but https://cabal.readthedocs.io/ will redirect to what it would have shown
17:25:55 <monochrom> Yeah that's how I landed at 3.4
17:26:21 <monochrom> I reckon that at this time of transition, "stable" doesn't make sense.
17:26:34 <sm[m]> hpc, doesn't the color of links tell you ?
17:27:21 <sm[m]> ouch, https://github.com/haskell-crypto/cryptonite/issues/330 (fromIntegral)
17:46:47 <jle`> sm[m]: D:
17:46:49 * hackage functor-combinators 0.3.1.0 - Tools for functor combinator-based program design  https://hackage.haskell.org/package/functor-combinators-0.3.1.0 (jle)
17:47:42 <jle`> although the comment did make me chucke
17:55:57 <monochrom> > fromIntegral (round (1/0)) :: Double
17:55:59 <lambdabot>  Infinity
17:56:05 <monochrom> round trip :)
17:56:27 <monochrom> literally, haha
17:56:35 <monochrom> I'm a genius
17:58:29 <monochrom> Wait a second, how can functor combinators be unsafe (Data.Functor.Combinator.Unsafe) if they're type-level?
18:13:30 <plam4u> :D
18:14:12 <solonarv> monochrom: that module is full of functions which are very much term-level ;)
19:15:29 <fresheyeball> ok
19:16:39 <jle`> monochrom: hehe
19:34:50 * hackage ipfs 1.1.1 - Access IPFS locally and remotely  https://hackage.haskell.org/package/ipfs-1.1.1 (expede)
20:06:49 * hackage thread-supervisor 0.2.0.0 - A simplified implementation of Erlang/OTP like supervisor over thread  https://hackage.haskell.org/package/thread-supervisor-0.2.0.0 (nshimaza)
21:02:03 <arpl> Hi Conal, just saw you entering here. Only wanted to say I liked your talk at Haskell Love last weeken.
21:02:32 <conal> arpl: Howdy! Thanks. :) 
21:03:09 <iqubic> Is it possible to create a (Bits a) with a given length? Like just 3 bits.
21:03:35 <conal> It was a bit risky streaming from outside with lighting and connectivity, but it worked out and was a fun departure.
21:08:53 <arpl> I can imagine. Not just for you of course. But on the whole I think that everything went rather smoothly. It was a fun experience.
21:09:54 <kraeXen> > let hex6 h = head h : ( concat $ [ replicate (max 1 ( length h ) -4 ) x | x <- tail h ] ) in hex6 "#fff"
21:09:56 <lambdabot>  "#"
21:10:27 <kraeXen> > let hex6 h = head h : ( concat $ [ replicate (max 1 $ ( length h ) -4 ) x | x <- tail h ] ) in hex6 "#fff"
21:10:29 <lambdabot>  "#fff"
21:10:40 <kraeXen> > let hex6 h = head h : ( concat $ [ replicate (max 1 $ ( length h ) -3 ) x | x <- tail h ] ) in hex6 "#fff"
21:10:41 <lambdabot>  "#fff"
21:11:02 <kraeXen> anyone know what I'm doing wrong here?
21:11:36 <kraeXen> > let hex6 h = head h : ( concat $ [ replicate (max 1 $ ( length h ) - 3 ) x | x <- tail h ] ) in hex6 "#fff"
21:11:38 <lambdabot>  "#fff"
21:11:45 <kraeXen> > let hex6 h = head h : ( concat $ [ replicate (max 1 $ ( length h ) -1 ) x | x <- tail h ] ) in hex6 "#fff"
21:11:47 <lambdabot>  "#fffffffff"
21:11:55 <kraeXen> > let hex6 h = head h : ( concat $ [ replicate (max 1 $ ( length h ) -2 ) x | x <- tail h ] ) in hex6 "#fff"
21:11:57 <lambdabot>  "#ffffff"
21:12:17 <kraeXen> > let hex6 h = head h : ( concat $ [ replicate (max 1 $ ( length h ) -2 ) x | x <- tail h ] ) in hex6 "#111222"
21:12:18 <iqubic> kraeXen: Can you please take this to whispers
21:12:19 <lambdabot>  "#111111111111111222222222222222"
21:12:24 <kraeXen> alright
21:14:39 <iqubic> I really wish I could make bitset with a given number of bits.
21:22:21 <sm[m]> conal: I liked your outdoor backdrop very much
21:22:35 <conal> :)
22:02:05 <monochrom> Why do I have a feeling that it means conal gave a denotational lecture in the midst of a thunderstorm for dramatic effect :)
22:03:05 <monochrom> "Thou shalt not have garbage!"  <lightnigning strikes, rock explodes>
22:29:09 <dmwit> iqubic: data Oct = Oct Bool Bool Bool and write a Bits instance, I guess. There are other, more efficient ways, too.
22:29:17 <iqubic> Right. Yeah.
22:29:45 <dmwit> There's also http://hackage.haskell.org/package/bv-sized
22:30:05 <iqubic> But I want it to be scalable, so that I can create something like C++'s bitset.
22:30:40 <dmwit> I don't know C++. Can you tell me what features are important to you?
22:32:12 <moet> does anyone here know how to load custom javascript into a jsaddle page?
22:32:36 <moet> i've tried all the usual suspects, but i cannot seem to get a reference to the js in the loaded file
22:33:35 <moet> (jsaddle being the monad for interfacing with a browser in GHCJS or from haskell over a websockets connection)
22:33:49 <moet> s/monad/package/g
22:42:09 <moet> ok, nevermind... i've found that the thing i was trying a few days ago works if i switch my global functions from `function blah() {..}` to `var blah = function () {..}` .. 
23:05:11 <pagnol> anyone here who's used opengl from haskell? how useable are the available wrappers in practice?
23:06:55 <pounce> ugh, i think i am suffering from the sins of lazyIO
23:12:34 <c_wraith> I know edwardk has used his package, https://hackage.haskell.org/package/gl , in making some games.  But it's about the single most C-like opengl interface on hackage.
23:14:27 <c_wraith> (because it's a direct binding to every single function and data type in opengl - it's actually autogenerated from the opengl headers using some scripts written specifically for that purpose)
23:26:39 <iqubic> dmwit: I want minimal space usage, and bitwise operations.
23:27:39 <iqubic> I suppose I could just use Bits to do it, but I'm really only ever going to need a 12 bit number at most.
23:28:27 <iqubic> But I'm going to need to set individual bits.
23:29:12 <edwardk> the rules for opengl were first 'do no harm' because up til then everything we had for talking to opengl bolted some leaky abstraction on top
23:29:16 <edwardk> er for 'gl'
23:29:28 <edwardk> i have a couple of shim packages that sit on top and start to offer abstractions
23:29:34 <edwardk> not sure what of them is on hackage though
23:29:53 <edwardk> https://github.com/ekmett/codex/tree/master/glow is one
23:30:28 <pagnol> edwardk: thank you, I'll take a look at those
23:31:51 <iqubic> openGL seems like a highly imperative system.
