00:04:18 <Arahael> iqubic: Which mode are you using? That might be why.
00:04:31 <iqubic> mode for what?
00:04:37 <Arahael> iqubic: OpenGL.
00:04:59 <Arahael> Immediate Mode openGL would indeed feel imperative.
00:05:34 <iqubic> Oh, I haven't used OpenGL ever. I'm commenting based on my percived notion of how I think OpenGL works. It may or may not be right, as I've never used OpenGL.
00:06:34 <Arahael> Fair enough. I only have minimal OpenGL knowledge, myself.  And I worry that it's increasingly linux-specific.
01:06:49 * hackage ghc-tags-core 0.2.3.0 - a library to work with tags created from Haskell parsed tree  https://hackage.haskell.org/package/ghc-tags-core-0.2.3.0 (coot)
01:07:50 * hackage ghc-tags-plugin 0.2.3.0 - A compiler plugin which generates tags file from GHC parsed syntax tree.  https://hackage.haskell.org/package/ghc-tags-plugin-0.2.3.0 (coot)
02:20:23 <fendor> are there strategies to automate hackage releases? The first three times, it was exciting to do a release by hand, now it is getting tedious
02:22:05 <phadej> is cabal sdist && cabal upload ...tar.gz too manual? or what do you mean?
02:23:17 <Uniaika> fendor: I think you could put that in a GitHub Action?
02:23:43 <phadej> please donÃ¤t
02:23:53 <phadej> Hackage is not designed with automatic uploads in mind
02:24:01 <Uniaika> (donÃ¤t kebab?)
02:24:04 <Uniaika> ah
02:24:06 <Uniaika> hmm
02:24:36 <fendor> phadej, maybe I dont have enough trust in my CI, I always want to run the tests in my sdist archive, upload documentation, etc...
02:24:38 <shafox> I have done the servant tutorial. however was looking for a bit more real-world kind of example. Is there some post/code that is real-worldly? 
02:25:32 <phadej> fendor: haskell-ci runs CI by sdisting packages first
02:25:41 <fendor> I know
02:25:48 <phadej> and also makes haddocks, so hackage-server will build them 99% surely
02:26:05 <fendor> it is the reason why most of the PRs we get do not run, because no one remembers adding it to the Extra-Source-Files section
02:26:13 <fendor> *files
02:26:44 <phadej> adding it, what's it?
02:26:57 <fendor> extra-source-files, such as some testdata
02:27:14 <phadej> isn't it's good thing that CI catches such problems?
02:27:55 <fendor> yes it is. But CI does not properly explain that problem and most of us just look at the results and cant make sense of it
02:28:32 <fendor> e.g. dont understand why suddenly some tests are failing that ran fine locally
02:28:54 <phadej> that's a problem indeed. someone have yet to implement haskell-ci generator to generate .sh file you can run in a docker container
02:28:57 <phadej> or something like that
02:29:25 <phadej> (running tests on sdists locally is tricky)
02:29:57 <[exa]> what's the best way to get the current cabal package version in the program, say as a string?
02:30:02 <phadej> but removing that check from CI won't make making releases "more automatic" or easier
02:30:13 <[exa]> for stuff like printing "I am package X version YYY"
02:30:59 <fendor> I didn't claim so, though, I just said that a lot of initial PRs are red :) I guess I should trust in CI and just do sdist followed by upload
02:32:41 <phadej> [exa]: as a string it's easy, as Cabal since (I don't remember when) defines VERSION_<current_pkg> as well
02:33:27 <phadej> but you have to know current packages' name
02:33:41 <[exa]> yeah that should work
02:33:57 <[exa]> "defines" as with CPP preprocessor?
02:34:04 <phadej> https://github.com/haskell-CI/haskell-ci/blob/master/src/HaskellCI/VersionInfo.hs
02:34:07 <phadej> yes
02:34:26 <[exa]> good thanks a lot!
02:35:43 <phadej> there's also CURRENT_PACKAGE_VERSION since cabal-version: 2.0
02:35:51 <phadej> https://github.com/haskell/cabal/pull/4320
02:37:22 <phadej> (I cannot find a clear note whether VERSION_<current_pkg> was defined "since forever", or is it also somewhat recent addition)
02:57:34 <[exa]> hm, any good shortcut for `join.fmap sequenceA` ?
02:57:54 <[exa]> (except for removing the A, lol)
02:58:03 <phadej> :t join . fmap sequenceA
02:58:04 <lambdabot> (Monad m, Traversable t) => m (t (m a)) -> m (t a)
02:58:30 <phadej> :t (>>= sequenceA)
02:58:31 <lambdabot> (Monad m, Traversable t) => m (t (m a)) -> m (t a)
02:58:45 <[exa]> oh wow
02:58:52 <phadej> hah, found the current package https://github.com/Ericson2314/cabal/commit/cc63fbf9ac5e4f033c943a4395f7c3e1359a05c2#diff-8e4f327b78615f51bced3e26cadbe11c
02:59:16 <phadej> 2016, ok, not "since forever"
02:59:34 <[exa]> thanks again! 
03:00:18 <phadej> [exa]: types help :)
03:28:20 * hackage gi-gtk 3.0.36 - Gtk bindings  https://hackage.haskell.org/package/gi-gtk-3.0.36 (inaki)
03:36:37 <hololeap> also, you can remember that `(>>= f)` === `join . fmap f`
03:37:16 <Uniaika> /4/8
03:37:21 <Uniaika> (woopsie)
03:48:24 <petersen> What do people use instead of </> for urls?
03:53:42 <Rembane> petersen: I usually concatenate strings, but that's not very elegant. 
03:53:53 <petersen> Yea
03:54:14 <petersen> I usually use </> ðŸ˜¬ - sorry windows
03:54:34 <Rembane> I like the README for this package, but I've never used it: https://hackage.haskell.org/package/urlpath
03:54:46 <Rembane> OTOH you can write your own combinator function
03:57:23 <petersen> Right - not sure I agree with the "dirt-simple" :-)   Well it is not doing type-level urls, lol, I suppose hehe
03:59:01 <Rembane> ^^ there are always type level urls 
04:00:32 <petersen> Problem is the combinator needs to live in a library - maybe I try asking http-client...
04:03:28 <Rembane> Oh, that's a bummer 
04:06:05 <petersen> I mean I want to use all over the place
04:09:11 <petersen> well network-uri seems popular
04:09:50 <MarcelineVQ> req has a nice solution but it's for req, you could take the idea though  https://hackage.haskell.org/package/req-3.5.0/docs/Network-HTTP-Req.html#t:Url
04:12:43 <ollehar> Mocking in haskell = replace the io monad with a .i
04:12:58 <ollehar> A list of fake results?
04:15:55 <petersen> MarcelineVQ: thanks - that does look nice - I should play more with req
04:26:20 * hackage bson-generic 0.0.9 - Generic functionality for BSON  https://hackage.haskell.org/package/bson-generic-0.0.9 (PetrPilar)
04:30:50 * hackage timers 0.2.0.4 - Simple package that implements timers.  https://hackage.haskell.org/package/timers-0.2.0.4 (PetrPilar)
04:31:49 * hackage polysemy-webserver 0.2.1.0 - Start web servers from within a Polysemy effect stack  https://hackage.haskell.org/package/polysemy-webserver-0.2.1.0 (AndrewMiller)
04:35:20 <jkaye[m]> ollehar: that's one way to do it if you have a Monad stack that you can swap out
04:38:31 <petersen> Actually req looks really good
04:38:54 <ollehar> Jkaye, is it idiomatic? I was thinking the same mocking strategy could be used in oop if you wrap all side-effects in command objects
04:40:04 <ollehar> And then inject a command object factory everywhere
04:41:03 <jkaye[m]> In Haskell, it's a common way to do things from what I've seen. I'm not a Haskell expert, but I would say it's definitely well-accepted, if not idiomatic
04:41:56 <jkaye[m]> You could do something similar in OOP, but personally I would recommend trying to invert dependencies wherever possible instead. Have you heard of "Imperative shell, functional core"?
04:42:55 <ollehar> Inverted dependencies still force you to mock those dependencies, which gets ugly fast
04:43:17 <ollehar> Gonna search for the other thing :)
04:43:45 <jkaye[m]> With inverted dependencies, you don't mock. You inject test data, which is much cleaner than mocking for most use cases
04:45:04 <ollehar> Not my experience, but maybe I'm doing it wrong
04:49:45 <jkaye[m]> As all things in software, it's nuanced and always depends on the use case :) but generally, I would consider "inversion" to mean turning something like Frobulate(IDependency dep) into Frobulate(Map<Int, String> data). In many cases where a dependency is passed, it's really just data that's going to be used, or something will be done with that data; that's really the key difference in thinking. Rather than "doing things
04:49:45 <jkaye[m]> with dependencies" one can instead think about how "data moves between dependencies". It's a subtle difference. I could also be mistaken, this is all just from my experience
04:55:46 <Arahael> jkaye[m]: Most people use the term 'dependency inversion' to turn implicit (global) dependencies into explicit injected dependencies.
04:56:27 <Arahael> jkaye[m]: Eg, rather than have Frobulate() connect to the service itself, have Frobulate(IService service) instead.
04:59:48 <jkaye[m]> Technically, that would be dependency injection as a mechanism for accomplishing inversion, but I agree, I think what I am saying is probably not what most people would call it, so perhaps I should try to find/come up with a better name
05:03:42 <Arahael> jkaye[m]: In haskell, they say they make it "pure".
05:04:06 * Arahael notes he is in #haskell, not #programming, and is suddenly disconcerted with making such a claim...
05:25:06 <[exa]> hm, how do I force any regexes from Text.Regex.Base to decide whether a given regex matches as a prefix of the given string?
05:25:35 <[exa]> (ideally without placing ^ into the regex)
05:45:03 <sshine> what's a good way to create slides? I used to use beamer, but I'd like something that targets web and is less low-level.
05:45:32 <thblt> sshine: reveal.js is nice for simple things.
05:47:50 <sshine> jkaye[m], I agree with Arahael's perception on what DI means. but also, this understanding is coupled to OOP. so in Haskell, unless you pass a reference that contains functions or effects, you're kind of beyond the initial problem to begin with.
05:48:19 * hackage battleplace 0.1.0.10 - Core definitions for BattlePlace.io service  https://hackage.haskell.org/package/battleplace-0.1.0.10 (quyse)
05:49:19 <sshine> jkaye[m], and yes, if in OOP you'd pass an IFrobService, in FP you'd probably pass some central data piece of that service and import the functions to deal with it instead.
05:50:45 <sshine> jkaye[m], you could make a comparison with mtl-style/has-style type classes because DI talks of coupling and having 'MonadDB m => Int -> m (Maybe Frob)' loosens coupling, too.
06:05:47 <sshine> thblt, thanks :)
06:18:29 <dminuoso> Are there reasons to use fundeps over an associated tyfam?
06:18:53 <dminuoso> Or differently asked, what ergonomic benefits might I get from fundeps?
06:26:19 <ollehar> Test
06:26:34 <ollehar> (ollehar) Jkaye inject test data into what?
06:26:57 <ollehar> Functional core doesn't always work
06:28:10 <ollehar> jkaye[m] hm
06:33:45 <ollehar> Damn. Unstable internet.
06:40:26 * ollehar reading the logs
06:41:09 <ollehar> "Doing things with data" works if you don't have any writes :)
06:41:52 <ollehar> I'm assuming a read-compute-write pipeline, but often it's intermingled
06:42:30 <ollehar> Or you have multiple stages of read-compute-write
06:44:09 <ollehar> I want to see pipeline-oriented programming :D
06:45:37 <ollehar> Where you force side-effect usage in a certain way
06:46:00 <ollehar> Redux-saga for js is on this path
06:49:25 <ollehar> Even Haskell won't stop devs from mixing logic with io. There needs to be an enforcement on a higher abstraction level.
06:49:44 <ollehar> On an code organizational level.
06:49:54 <ollehar> Or architectural
06:53:50 * hackage barbies 2.0.2.0 - Classes for working with types that can change clothes.  https://hackage.haskell.org/package/barbies-2.0.2.0 (DanielGorin)
06:55:28 <thblt> I may be dumb, but using Emacs' haskell-mode, I can switch to the repl with C-c C-z, but I don't find how to send code to the repl, or the entire module.  Is there a way? (besides copy-and-paste)
06:57:45 <thblt> Shame on me there's a manual.
06:59:30 <thblt> Err C-c C-l, sorry for the noiseâ€¦
07:02:08 <ollehar> How dare you ^^
07:04:07 <thblt> I searched for functions called ^haskell interactive, ^haskell repl, etc; what I was looking for happens to be in haskell-process- :)
07:21:14 <fosterite> All of the construction functions in path seem to reject .. path components
07:21:30 <fosterite> what am I supposed to do if I actually want to parse a filepath with them?
07:22:27 <sshine> fosterite, could you elaborate?
07:23:01 <fosterite> I have a filepath "../whatever/x.png" (parsed from a file). When I call parseRelFile on it I get an exception
07:23:19 <fosterite> sshine: is the path library just not for this use case?
07:25:52 <fosterite> parsing an absolute file for the file I'm parsing and appending the relative file to it is really what I want to do
07:26:46 <sshine> fosterite, https://hackage.haskell.org/package/path-0.8.0/docs/Path-Posix.html#v:parseRelFile -- the documentation explicitly says that it will throw on ".."
07:27:23 <fosterite> sshine: yes, as does every other parse* function in there. So I just can't use path?
07:27:37 <sshine> fosterite, if you want to normalize a relative path that contains a "..", I think you have to do it using some absolute path as the basis, since ".."s may result in different paths depending on the context.
07:27:50 * hackage darcs 2.14.5 - a distributed, interactive, smart revision control system  https://hackage.haskell.org/package/darcs-2.14.5 (bfrk)
07:27:56 <sshine> fosterite, what are you expecting as the output?
07:28:46 <fosterite> Is there a paths library that will just lexically collapse any ..? parseAbsFile "/x/y/../x.txt" = exception
07:29:46 <fosterite> sshine: I was expecting parseRelFile "../x.txt" = "../x.txt" (in some wrapper, presumably) then it would lexically collapse when I append to an absolute file
07:30:41 <sshine> fosterite, if you look at filepath package's System.FilePath.Posix.makeRelative, it also objects to ".."s, but not with exceptions. https://hackage.haskell.org/package/filepath-1.4.2.1/docs/System-FilePath-Posix.html -- it links to a blogpost on why ".." is difficult to deal with due to symlinks: http://neilmitchell.blogspot.com/2015/10/filepaths-are-subtle-symlinks-are-hard.html
07:31:33 <sshine> fosterite, tl;dr: ".." may collapse differently depending on the absolute path, since symlinks behave unpredictable sometimes. (you may have experienced this if you ever tried to use ".." in a shell from within a symlinked directory.)
07:32:32 <thblt> Can ghci tell precisely where an instance is defined?  With :i I get a module name, I'd like a path to a source.
07:33:18 <NieDzejkob> > [x|x<-[1..],any(\y->show x/=y&&head y/='0'&&rem x(read y::Int)==0)$permutations$show x]
07:33:24 <lambdabot>  mueval-core: Time limit exceeded
07:33:27 <hpc> thblt: haddock docs have that
07:33:40 <hpc> either on hackage, or make sure to include it when you build
07:33:57 <fosterite> sshine: I am aware of the symlink issue, I just still expected lexical collapse because it's what I wanted (I like plan 9)
07:34:25 <thblt> hpc: thanks
07:34:34 <fosterite> sshine: thanks, I guess I will just use filepath
07:35:33 <fosterite> sshine: still, what do you do in path if you have a .. ? Say you're using path to implement a shell or something. You just can't?
07:37:06 <sshine> fosterite, if you're implementing an interactive shell to navigate directories, what you'd do is resolve the components of your path, and if those components are symlinks, then that means something else
07:37:34 <sshine> fosterite, the point is that you can't assume, inside a pure function, what a ".." means, because it depends on the (stateful) context of your filesystem. :)
07:38:50 <sshine> fosterite, so you might have chdir :: FilePath -> IO FilePath, with the input being relative or absolute, and the output being absolute.
07:40:52 <sshine> fosterite, if you make assumptions about how ".." works on your filesystem in specific (a standard library that works on arbitrary linux/windows filepaths can't do that), you can make a function that collapses ".."s.
07:41:42 <sshine> fosterite, but most likely, this assumption would be wrong unless you have an actually funky filesystem. :)
07:42:49 <sshine> I see that Plan 9's Fossil filesystem has symlinks. don't they work the same?
07:43:03 <fosterite> sshine: thanks for your help. that assumption is correct on plan 9 actually, the kernel maintains a filepath
07:43:42 <fosterite> sshine: http://doc.cat-v.org/plan_9/4th_edition/papers/lexnames
07:43:54 <sshine> ah, I'd just gotten to that page.
07:44:01 <sshine> and yeah, Plan 9 has it simpler. that's awesome.
07:44:49 <sshine> "This ambiguity is a source of confusion, especially since some shells work overtime to present a consistent view from programs such as pwd, while other programs and the kernel itself do nothing about the problem." -- so the answer, if you're implementing a shell, is to work overtime. ;-D
07:47:31 <fosterite> sshine: maybe I'll just write a shell that is really bad. my hugs 9front port has stalled for want of a hscpp implementation
07:49:36 <sshine> fosterite, so, I guess an unambiguous path to any (networked) file is kind of like a hybrid between an UUID and an inode. distributed hashtables and structural databases go this way, too. so I guess if you have some application that really depends on a Linux filesystem environment, and you want to avoid symlinks, you could write a FUSE driver that goes about this namespacing in the same way as Plan 9, but 
07:49:42 <sshine> backed with some arbitrary, path-agnostic database.
07:50:56 <sshine> then, in that FUSE mount, you're allowed to make the assumption that foo/../bar == bar :)
07:51:30 <fosterite> sshine: even worse I am on OSX.
07:51:38 <sshine> I think OSX supports FUSE?
07:52:07 <fosterite> sshine: pwd -> whatever/Unit; cd ../unit -> you are now in whatever/unit but it's the same folder
07:52:25 <fosterite> sshine: it does support fuse yes
08:19:30 <sm[m]> when are we all going to switch to plan 9 or inferno ?
08:25:21 <monochrom> WSP9 = Windows subsystem for Plan 9? :)
08:28:27 <hpc> and on linux, PINE
08:33:08 <monochrom> heh
08:36:20 <fosterite> you can get very far with vt and ssh but then you're just using linux with a long pole
08:58:17 <sm[m]> if you have a compiled Regex, is it possible to recover the original text form ?
08:58:55 <sm[m]> I don't think so
08:59:01 <c_wraith> in theory or with a specific library?
08:59:25 <sm[m]> regex-tdfa is the one I'm using, and switching would be hard
08:59:31 <c_wraith> with a specific library is "no", for every library I can think of.
08:59:44 <sm[m]> so yes, with this or other common library. Thought so, thanks
09:00:17 <c_wraith> in theory - it's possible to recover at least an equivalent regex - they aren't unique.  But it's a lot of work that I can't think of a single library that has wanted a reason to do
09:00:42 <sm[m]> I'm about to use Regex more and strings less, but it will make printing/debugging a bit harder
09:00:55 <sm[m]> unless I store both, which is clunky
09:03:48 <indian_yogi> hello every1
09:03:53 <monochrom> I think it's simplest to store your original regex :)
09:03:55 <indian_yogi> how is everybody?
09:04:20 <sm[m]> yes, agreed. If it seems needed enough, I'll do that
09:04:27 <sm[m]> great indian_yogi , hello to you
09:04:56 <monochrom> In particular tdfa compiles to a finite state automaton. It looks nothing like a regex anymore. If the library author would want the original regex recoverable, they would simply store it, too.
09:05:35 <monochrom> Decoding an FSA back to regex can give unreadable results.
09:05:57 <phadej> or insightful ones, depends!
09:06:23 <monochrom> That too, but I'm a pessimist.
09:06:35 <monochrom> Every silver lining has tarnish.
09:06:57 <sm[m]> unreadable does seem more likely than insightful :)
09:09:33 <monochrom> Actually it gets better. (I'm a pessimist, "better" means worse. >:) )  If compiling regex to non-deterministic automaton, that's not too far off, the automaton still has good correspondence with the original regex, decoding isn't that bad.
09:10:24 <monochrom> But I suspect tdfa goes on to determinize that (use a powerset construction). Now that automaton is very far away from any human-written regex.
09:10:36 <indian_yogi> i am new to programming and since a month or so, i have been learning and doing python, but I don't know should I learn haskell programming as well?
09:10:58 <indian_yogi> if i could then what purpose will ut serve?
09:11:01 <sm[m]> thanks all
09:11:25 <c_wraith> Haskell is a good way to learn a lot of ideas that are slowly being introduced to other languages, so it's a bit like looking into the future.  In exchange, it's basically like learning how to program all over again.
09:11:40 <ski> indian_yogi : learning multiple different ways to think about programming is good. broadens your vision, adds more diverse tools to your toolbox. but it might be sensible to only learn one at a time, to not overwhelm yourself
09:11:46 <sm[m]> indian_yogi: you should at some point, but for most people learning both at the same time will be too much 
09:12:08 <sm[m]> maybe alternate by month ?
09:13:05 <hololeap> indian_yogi: why do you have interest in haskell?
09:14:04 <sm[m]> one purpose may be, having a few small haskell projects in your github account will differentiate you from the other python job candidates
09:14:06 <L29Ah> indian_yogi: haskell works when you don't have the luxury of running your program all over again only to find that you've made a simple mistake
09:14:15 <L29Ah> (or just fed up with it)
09:16:14 <monochrom> It is strange to ask strangers for life decision advice. (Yes, it's a life decision, your time is a zero-sum game, every minute spent on Haskell means a minute not spent on something else more worthwhile or less worthwhile in your context.)
09:16:55 <L29Ah> > your time is a zero-sum game
09:16:56 <L29Ah> nah, some decisions can increase or decrease your total time
09:16:57 <lambdabot>  error:
09:16:57 <lambdabot>      Variable not in scope: your :: t0 -> t1 -> Expr -> t2 -> aerror: Variabl...
09:16:57 <lambdabot>      â€¢ Variable not in scope: is
09:17:11 <monochrom> But as far as letting external things decide your fate, why not simply use networking effects. If there is one day you run into mentions of Haskell 5 times, you go "that's it, I'm learning Haskell".
09:17:13 <sedeki> > putStrLn "hello"
09:17:15 <lambdabot>  <IO ()>
09:17:31 <monochrom> At least networking effects have actually scientifically, statistically proven relevance to you.
09:17:38 <ski> % putStrLn "ehlo"
09:17:39 <yahb> ski: ehlo
09:17:56 <sedeki> what's the difference between % and > ?
09:18:02 <ski> different bots
09:18:15 <monochrom> Whereas asking #haskell has scientifically, statistically proven bias.
09:19:52 <dminuoso> Mmm wow. c2hs consistently breaks line numbers on diagnostics. :(
09:20:12 <dminuoso> I think I may just go back to hsc2hs with custom template haskell
09:20:49 <indian_yogi> i want to learn haskell coz it excites me like it has more users than many programming languages on irc, just behind python though
09:21:21 <ski> you might try it a little bit, and see what you think ?
09:21:34 <indian_yogi> ok
09:22:16 <ski> (see whether learning any really does excite you)
09:24:07 <ski> do you have any learning resource ?
09:24:54 <L29Ah> https://github.com/haskell/c2hs/issues/232 :(
09:26:43 <indian_yogi> yes
09:27:19 <indian_yogi> i am thinking of enrolling into an online course
09:32:18 <ski> @where CIS194
09:32:18 <lambdabot> https://www.seas.upenn.edu/~cis194/spring13/lectures.html
09:32:33 <ski> indian_yogi : perhaps ^ could be of some use
09:34:55 <L29Ah> @where RWH
09:34:55 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
09:41:56 <dminuoso> Off
09:42:17 <sm[m]> @where HTAC ! (it's my job :)
09:42:18 <lambdabot> "Haskell Tutorial and Cookbook" by Mark Watson in 2017-09-04 at <https://leanpub.com/haskell-cookbook>
09:49:16 <fog> greetings earth people 
09:50:09 <ski> ehlo fog
09:50:46 <fog> it is nearly complete! 
09:59:03 <thblt> I'm trying to manually desugar do blocks, am I correct? https://paste.thb.lt/1596905868.hs.html
10:01:50 <monochrom> Yes it's right
10:01:57 <thblt> monochrom: thank you.
10:04:03 <sm[m]> indian_yogi: did you get the 5 links we shared ? If any of them work well for you, please report back
10:05:19 <sm[m]> 4 links. http://www.realworldhaskell.org/blog/ is dead
10:06:12 <monochrom> aww
10:08:21 <indian_yogi> sm[m]: yes, these links will be of geat help 
10:08:45 <indian_yogi> I am definitely going to use these sites and specially the university excercises
10:09:50 * hackage tldr 0.8.0 - Haskell tldr client  https://hackage.haskell.org/package/tldr-0.8.0 (psibi)
10:11:57 * ski . o O ( <https://web.archive.org/web/20131011171124/http://www.realworldhaskell.org/blog/> )
10:18:09 <sm[m]> good luck!
10:22:20 * hackage mwc-random 0.15.0.1 - Fast, high quality pseudo random number generation  https://hackage.haskell.org/package/mwc-random-0.15.0.1 (AlexeyKhudyakov)
10:25:50 <indian_yogi> sm[m]: thanks i will do it
10:33:51 <ski> indian_yogi : you're welcome to ask questions here
10:34:44 <dmwit> iqubic: If you only need 12 bits, I recommend Int. It is guaranteed to have 29 bits available, and I expect most sane implementations will make it fit a machine word (so you won't really get anything smaller than that as an atomic unit).
10:35:01 <dmwit> (Word could also be a sensible choice, for all the same reasons.)
10:36:24 <indian_yogi> ski: thanks i will !
11:24:13 <fog> i have a problem where i was trying to store a function and its input args in several places
11:24:31 <fog> along with a different lookup index 
11:25:15 <fog> ie, the function returns a tuple, and eg, if its a pair, then there are 2 datatypes, both storing the function and the input args. one for fst, one for snd
11:25:30 <fog> but then, i dont want to have the function being evaluated twice
11:25:40 <fog> since the input args are the same, there should be code reuse
11:26:37 <fog> let f x = (x+1,x-1) in ((fst,f,0),(snd,f,0))
11:27:39 <fog> ie, i dont want it to repeat the calculation of `f 0' 
11:28:22 <fog> when it evaluates that like; ((fst $ f $ 0),(snd $ f $ 0))
11:30:59 <ski> in that case, with lazy evaluation, the addition will only be computed once, and similarly for the subtraction
11:31:56 <fog> hmm, thats good
11:32:09 <fog> but if it were a more complex computation...
11:32:38 <fog> eg. f x = ((g x)+1,(g x)-1)
11:32:49 <fog> where g is expensive
11:33:23 <fog> then over each branch, it will re-perform the computation
11:33:55 <fog> whereas in the evaluation of f x, that returned both values to the same use site, like something that added each half together
11:34:14 <fog> it would reuse the calculated (g x)
11:34:59 <fog> f x = (x+1,x-1) was a bad example because the branches were decoupled
11:35:11 <ski>   f x = (y+1,y-1) where y = g x
11:35:20 <fog> yeah
11:35:31 <fog> that clearly shows the y being reused
11:35:32 <ski> `y' will be recomputed
11:36:23 <fog> well, yeah, when the computations are not performed, but instead the input is stored alongside the function, like, the evaluation is deffered
11:36:50 <fog> its only reused if both the fst and snd are used in the same place
11:37:17 <ski> hm, what about recomputation issues wrt `fst (f 0)' vs. `fst (f 1)' ?
11:37:22 <fog> eg, (\(a,b) -> a + b) . f
11:37:47 <fog> f will never be stored with differing inputs
11:38:23 <fog> but i dont want to collapse them down by performing evaluation, because it discards type information
11:40:20 * hackage hie-bios 0.6.2 - Set up a GHC API session  https://hackage.haskell.org/package/hie-bios-0.6.2 (fendor)
11:40:40 <fog> im not sure if it would help, but the inputs to f eg. 0, are looked up by symbols in an instance... 
11:41:09 <fog> probably too confusing. ill try to write up the idea with the expensive reuse, but it might make the technique useless in practice
11:42:37 <ski> i'm not following what situation you're having
11:45:53 <fog> im trying to think how there could be a way that the inputs could somehow have some way to make the reuse happen and prevent the recalculation
11:45:55 <fog> but i cant
11:46:56 <fog> i thought if they were "named" somehow that they would be kind of let bound, but i think the f would still be computed repeatedly even in this case
11:48:46 <fog> i guess if the function was really identifiable somehow, that the value could be stored along with the function applied to it, and then the function applied to *that* would kind of just retrieve the already computed thing.. but thats so complicated...
11:49:08 <fog> probably a better way to store the type information than that...
11:49:44 <ski> perhaps look into memoization, if you have a specific situation where you'd like to avoid recomputation
11:49:59 <fog> like f (f 0, g 0 ... ) = fst (f 0, g 0 ... )
11:50:21 <fog> but i cant see how it could match over f like that...
11:51:10 <fog> ski: i cant imagine that would work in this case
11:51:27 <fog> ill try and finish the example so you can see whats happening 
11:56:11 <fog> ok, i can describe whats happening
11:56:27 <fog> i have a tree that reuses lower nodes, ie i have converging edges
11:56:43 <fog> there is a function at each node, with inputs arriving over each edge
11:57:13 <fog> then, the inputs are stored along with the function that is to be applied to them
11:57:37 <fog> these inputs are left unevaluated - as function-trees
11:57:53 <fog> but then, since one lower node ends up at several upper nodes
11:58:00 <fog> the reuse problem occurs
11:58:17 <fog> i cant store the lower part of the tree as unevaluated 
11:58:29 <fog> and i dont want to collapse the tree down by evaluating all the functions
11:59:08 <fog> well, i *can* store reference to the unevaluated lower parts of the tree, but it will redo the calculation on the functions evaluation 
12:01:00 <fog> the thing i was saying about "naming" the nodes, was to be done by having an instance of a trivial class with a fundep, so each name uniquely corresponds to a node
12:01:56 <fog> but that only names, and guaranties uniqueness of - and so reuse of, the inputs - not with the function applied
12:02:43 <fog> a constraint at each node then says that each part of the tuple ends up at a set use-site, by the name of that node
12:03:53 <fog> so i guess i *could* have a similar constraint, like, it knows which node its being sent to, so it should also know which function is going to be applied to it, and to do the function that will be performed at each node before sending it along the edge, so at the nodes they just do different lensing lookups on the output tuple
12:04:11 <fog> ill stop describing it now to avoid spamming
12:11:34 <fog> actually i think that would work - but it has the problem that instead of storing the function at each branches/node in the tree, it has to be resolved as an instance over the Symbol name of the node, meaning many instances are needed, instead of just using datatype constructors
12:36:19 * hackage language-dickinson 1.1.0.3 - A language for generative literature  https://hackage.haskell.org/package/language-dickinson-1.1.0.3 (vmchale)
13:07:16 <monochrom> w00t 8.10.2
13:09:20 * hackage Unique 0.4.7.8 - It provides the functionality like unix "uniq" utility  https://hackage.haskell.org/package/Unique-0.4.7.8 (kapral)
13:10:56 <GreeboSnabble> @help let
13:10:56 <lambdabot> let <x> = <e>. Add a binding
13:12:30 <sm[m]> when I declare "instance X Regex" where X is Eq, Ord, Read, Show, Data, Generic... is that actually doing something sensible ?
13:14:57 <solonarv> depends on what 'Regex' is and what you write in the instance declaration.
13:18:25 <sm[m]> solonarv: well, it's http://hackage.haskell.org/package/regex-tdfa-1.3.1.0/docs/Text-Regex-TDFA.html#t:Regex, and I'm writing literally "instance Eq Regex", auto-deriving
13:18:57 <sm[m]> and GHC is happy with it
13:19:23 <sm[m]> guess I will test it
13:19:37 <ski> what do you mean by "auto-deriving" ?
13:19:42 <sm[m]> but it's rather hard to make Regex's in GHCI I find
13:20:13 <sm[m]> ski I mean I don't declare any implementation for this instance
13:20:31 <sm[m]> and I have various Derive* extensions enabled
13:20:49 <Rembane> sm[m]: When are two regexes equal to each other? 
13:22:37 <ski> sm[m] : sounds like you're simply declaring instances, without providing implementations of methods, to me. unless there's some default implementations (perhaps relying on `Generic' or something), that's providing some kind of possibly reasonable implementation
13:22:56 <sm[m]> https://termbin.com/bf3s is an excerpt of the code
13:23:39 <sm[m]> and I'm surprised I got this far, so I'm wondering if indeed there's some reasonable implementation, eg regex-tdfa knows the Regex's are the same object 
13:23:54 <sm[m]> and I can and will test, now
13:24:14 <sm[m]> though if anyone knows how to make a Regex in GHCI that would be quite helpful
13:25:54 <ski> can't you use the quasiquoter to get a `Regex' ?
13:27:51 <sm[m]> perhaps. I have been trying with http://hackage.haskell.org/package/regex-base-0.94.0.0/docs/Text-Regex-Base-RegexLike.html#v:makeRegex
13:28:03 <dminuoso> sm[m]: You can, pcre-heavy does it
13:28:30 <sm[m]> regex-base types are a nightmare if you're just exploring interactively
13:37:53 <sm[m]> ok, pretty sure I wasn't getting this before somehow, but now "instance Eq Regex" warns "No explicit implementation for either â€˜==â€™ or â€˜/=â€™"
13:38:25 <ski> that's what i thought you ought to be getting
13:38:35 <sm[m]> and r1 == r2 gives a stack overflow. (Same with the Show instance I "auto derived")
13:39:25 <monochrom> I really don't think "instance C T {}" means any kind of "auto derive".
13:41:41 * sm[m] backs up and tries to reproduce the no warning scenario
13:41:57 <int-e> monochrom: deriving instance C T by DefaultMethodsOnly
13:42:34 <sm[m]> can't do it. Let's assume I was blind
13:44:47 <sm[m]> new question: if I add the word deriving - "deriving instance Eq Regex" - I get the error "Can't make a derived instance of â€˜Eq Regexâ€™: The data constructors of â€˜Regexâ€™ are not all in scope so you cannot derive an instance for it". So I try importing Regex(..), with no difference. Any idea what it means by data constructors here ?
13:46:35 <monochrom> "data T = A Int | B | C Int T" the data constructors are A, B, C.
13:47:16 <sm[m]> I guess the issue is http://hackage.haskell.org/package/regex-tdfa-1.3.1.0/docs/Text-Regex-TDFA.html#t:Regex doesn't export them ?
13:47:25 <monochrom> Right.
13:47:27 <sm[m]> it
13:47:32 <hyiltiz> http://andrew.bromage.org/darcs/sudoku/
13:47:32 <sm[m]> thanks
13:47:43 <hyiltiz> https://wiki.haskell.org/Sudoku#Only_guessing_without_dancing_links
13:48:16 <hyiltiz> The haskell wiki links to AndrewBromage site mentioning an alternative tree based implementation of Dancing Links/Algorithm X
13:48:36 <hyiltiz> The site is 404 and wayback machine doesn't have a record either
13:48:59 <sm[m]> so this lack of instances seems rather a problem for my plan of storing Regex in my data types instead of regexp strings, because I need to be able serialise things to json, print them for debugging, force them to normal form etc.
13:49:48 <sm[m]> maybe it's not hard to implement some dummy instances, maybe not. Maybe there's a package of such instances, I should search
13:50:30 <sm[m]> oh, maybe it's time to think about that newer http://hackage.haskell.org/package/regex ...
13:51:57 <sm[m]> that looks similarly lacking in instances, if I read it right: http://hackage.haskell.org/package/regex-1.1.0.0/docs/Text-RE-TDFA-Text.html#t:RE
14:05:59 <ski> hyiltiz : AndrewBromage is Pseudonym
14:09:09 <GreeboSnabble> @let plus x y = x + y
14:09:10 <lambdabot>  Defined.
14:10:01 <GreeboSnabble> > plus 1 2
14:10:03 <lambdabot>  3
14:10:14 <GreeboSnabble> @let myPlus x y = x + y + 3
14:10:15 <lambdabot>  Defined.
14:10:18 <enikar> > (+) 1 2
14:10:20 <lambdabot>  3
14:10:25 <GreeboSnabble> > myPlus 2 2
14:10:27 <lambdabot>  7
14:10:55 <GreeboSnabble> > myPlus 1 1
14:10:57 <lambdabot>  5
14:17:57 <hyiltiz> Not looking for the person; just looking for that tree-based DLX implementating
14:19:44 <ski> yes. but perhaps, by looking for the person, you could find that implementation ?
14:22:45 <dminuoso> What's the efficient way to build a ByteString from a Ptr?
14:24:39 <dminuoso> Ohh hold on. A ByteString is just a ForeignPtr with offset and length...
14:24:44 <dminuoso> That's neat. :)
14:24:57 <phadej> from Ptr you have to copy still
14:25:00 <phadej> but there are function
14:25:23 <phadej> https://hackage.haskell.org/package/bytestring-0.10.12.0/docs/Data-ByteString.html#g:24
14:26:06 <dminuoso> Mmm, so it appears I want to use packCStringLen then
14:26:14 <MarcelineVQ> https://hackage.haskell.org/package/bytestring-0.10.12.0/docs/Data-ByteString-Unsafe.html#v:unsafePackCStringFinalizer if you are brave
14:36:39 <gentauro> MarcelineVQ: why not just code in C?
14:36:58 <gentauro> I mean, if you aint going to use Haskell for what it's good for, why even use it?
14:37:01 <gentauro> :|
14:38:47 <MarcelineVQ> Because a lot of smart people have done a lot of smart work that it's not always reasonable to redo yourself, so glue code exists to glue their genius/work onto yours.
14:43:28 <phadej> I wish there were a way to have test obligations in Haskell
14:44:04 <phadej> like if you use something unsafe*, a tool will point towards it, until you add a test case for that particular usage
14:44:20 <phadej> that would still rely on people reviewing code, but it would aid it
14:55:34 <ski> yes
14:58:53 <Lycurgus> would the test case make the thing any less safe?
14:59:39 <Lycurgus> *more safe
15:01:33 <kderme> I'm refactoring some code and I end up with many excessive constraints, like Monad m instead of Functor m. How come there is no ghc warning I can enable to find them all? redundant-constraints doesn't do it.
15:02:24 <dminuoso> Lycurgus: Sure. For one, it ensures the code path is tested, and it it increases the chances of catching a regression.
15:03:53 <Lycurgus> do people still say "unit test"?
15:04:45 <Lycurgus> say/do
15:26:06 <phadej> of course
15:27:39 <phadej> especially negative tests, i.e. counterexamples which should fail
15:28:06 <phadej> if you think that property-based testing is making unit-testing unnecessary
15:54:56 <dolio> I don't see how counter examples affect that opinion one way or the other.
16:10:12 <andrei> hi,  I
16:11:03 <andrei> I'm trying to install hsdev (using stack) to use in SublimeText
16:12:54 <andrei> the instructions https://github.com/SublimeHaskell/SublimeHaskell#required-before-you-install-sublimehaskell say that I need to add a hsdev.yaml which specifies the version of hsdev and all its dependencies
16:13:04 <int-e> @check \s -> s /= "swordfish"
16:13:06 <lambdabot>  +++ OK, passed 100 tests.
16:13:26 <frdg> I am trying to make an http request using Network.HTTP. I am at a loss for what I need as the last argument for constructing a Request. Is this where I would put an aeson decoder? https://dpaste.org/2gUy
16:14:27 <andrei> is there a way to add hsdev to stack.yaml without specifying the specific version? (just add `hsdev` as a dependency and let the package manager figure out the dependencies?)
16:14:32 <infinisil> frdg: Can you link to the docs?
16:14:43 <frdg> sure
16:15:03 <frdg> https://hackage.haskell.org/package/HTTP
16:15:07 <andrei> somethins similar to `yarn add package`
16:15:32 <frdg> functions I am using are in Network.HTTP and Network.HTTP.Base
16:17:32 <infinisil> frdg: empty should work
16:17:53 <infinisil> https://hackage.haskell.org/package/base-4.14.0.0/docs/Control-Applicative.html#v:empty
16:18:06 <infinisil> Or actually no, the ByteString empty
16:18:20 <infinisil> That's the request body
16:19:57 <frdg> yes this works
16:20:01 <frdg> thank you
16:21:51 <infinisil> :)
16:33:27 <frdg> Turns out that library doesn't support https. Anyway what does this type mean? `data Request :: *`? Seems illegal to me.
16:33:55 <frdg> from http-conduit
16:37:17 <monochrom> If the doc says that, it's haddock saying the type name is Request and its kind is *
16:41:07 <frdg> I just tested it and I see you are allowed to do this. This is strange to me. I always thought the relationship of kinds and types was the same as that of types and values.
16:44:32 <solonarv> '*' (also written 'Type') is the kind of types that have values
16:44:36 <solonarv> for example, Bool :: *
16:46:05 <solonarv> and you are right, value :: type and type :: kind
16:47:25 <frdg> solonarv: is this equivalent to the a in `f :: Maybe a` but going backwards?
16:48:21 <frdg> and is this what people mean when they talk about higher kinded polymorphism?
16:49:16 <solonarv> there is no polymorphism in any of what I said
16:49:45 <solonarv> '*' is not "a wildcard that can stand for anything", it's the (old) name of a specific kind
16:50:54 <frdg> ok you are correct that I was thinking it was a wildcard
16:54:20 <frdg> how does this compile? `x :: *; x = x` 
16:54:27 <solonarv> it shouldn't
16:54:38 <solonarv> % let { x :: *; x = x }
16:54:38 <yahb> solonarv: 
16:54:41 <solonarv> huh
16:54:52 <solonarv> oh, right
16:55:01 <solonarv> Type :: Type, so this typechecks
16:55:51 <solonarv> (in ghc, that is)
16:56:52 <frdg> Interesting. This is a bit mindblowing to me that you can have kinds in type signatures.
16:57:15 <solonarv> this isn't "kinds in type signatures", it's just a type signature
16:57:31 <solonarv> there are no kinds explicitly mentioned here
16:59:05 <frdg> it is a type that has the kind * ?
17:00:10 <frdg> ohh I understand
17:01:03 <solonarv> I'd also recommend mentally replaceing '*' with 'Type'
17:01:06 <solonarv> it is far less confusing
17:04:16 <frdg> I see. (* -> *) though would be better reffered to as a kind.
17:04:42 <frdg> but * is just a type
17:06:05 <dolio> No, they're both kinds.
17:07:06 <dolio> Like Int is a type, and Int -> Int is also a type.
17:07:12 <solonarv> yes. Rule: if something can go on the right side of a '::' , it's a type.
17:07:39 <solonarv> if it can go on the right side of a '::' when the left side is a type, then it's a kind.
17:08:08 <solonarv> (hmm, this needs refining)
17:08:20 * hackage ghc-lib-parser 8.10.2.20200808 - The GHC API, decoupled from GHC versions  https://hackage.haskell.org/package/ghc-lib-parser-8.10.2.20200808 (shayne_fletcher)
17:08:21 <phadej> that doesn't work
17:08:27 <solonarv> yeah I realized that too
17:08:51 <phadej> I'd use term :: type :: sort
17:09:14 <phadej> and in Haskell there's not many sorts (TYPE r)
17:09:20 * hackage ghc-lib 8.10.2.20200808 - The GHC API, decoupled from GHC versions  https://hackage.haskell.org/package/ghc-lib-8.10.2.20200808 (shayne_fletcher)
17:09:48 <dolio> You can do that, but that doesn't agree with other uses of 'sort'.
17:10:03 <phadej> but "kinds" is a bit difficult to pin point the different from "type"
17:10:12 <phadej> especially as you can promote terms to types
17:10:22 <phadej> (and thus types to kinds)
17:11:10 <phadej> but first approximation, "kinds are types of things in types" is good enough.
17:11:24 <phadej> because standalone "Maybe" is not a type
17:11:42 <phadej> (it has wrong "kind" if you wish)
17:11:52 <phadej> Maybe is type constructor
17:12:04 <dolio> But Int is also a constructor, so that doesn't help.
17:12:22 <phadej> I think I always make mistakes in the terminology if I'm not paying attention
17:12:23 <frdg> `'*' (also written 'Type') is the kind of types that have values`. Do not all types have values?
17:12:23 <frdg>  
17:12:57 <phadej> frdg: promoted types don't have non-trivial values
17:13:00 <phadej> > undefined :: 1
17:13:01 <lambdabot>  Terminated
17:13:07 <phadej> :t undefined :: 1
17:13:12 <solonarv> > undefined :: 'True
17:13:14 <lambdabot>  Terminated
17:13:26 <solonarv> % undefined :: 'True
17:13:27 <yahb> solonarv: ; <interactive>:96:14: error:; * Expected a type, but 'True has kind `Bool'; * In an expression type signature: 'True; In the expression: undefined :: 'True; In an equation for `it': it = undefined :: 'True
17:13:29 <phadej> poor lambdabot :)
17:13:35 <solonarv> aha, there's the actual error message
17:14:30 <phadej> there's also Void, which doesn't have values, if you want to nitpick :)
17:14:44 <phadej> inhabitation is non-trivial property
17:15:37 <phadej> (and people used empty types to great success, especially before DataKinds become available)
17:16:04 <phadej> data Zero; data Succ a; -- peano numbers on a type level - open kinded, so be careful
17:17:09 <frdg> so `x :: *` just means that x is a type that has values?
17:17:12 <phadej> (https://aphyr.com/posts/342-typing-the-technical-interview is a very good example of non-idiomatic Haskell :)
17:18:04 <phadej> if `x` isn't `*` itself :)
17:18:29 <andrei> Here is some more context:I want to use `hsdev` in SublimeTextI've read the following guide https://lexi-lambda.github.io/blog/2018/02/10/an-opinionated-guide-to-haskell-in-2018/#setting-up-editor-integrationwhich suggests not installing tools globally, that is avoid `stack install hsdev`.So I decided to install `hsdev` per project. Now `stack
17:18:29 <andrei> build hsdev` fails with the following errors:```stack build hsdevError: While constructing the build plan, the following exceptions were encountered:In the dependencies for hsdev-0.3.3.8:    direct-sqlite must match >=2.3.19 && <2.4, but the stack configuration has no specified version  (latest matching version is 2.3.26)    haddock-api must match
17:18:30 <andrei> >=2.23, but the stack configuration has no specified version  (latest matching version is 2.24.0)    hdocs must match >=0.5.3, but the stack configuration has no specified version  (latest matching version is 0.5.4.0)    sqlite-simple must match >=0.4.13.0 && <0.5, but the stack configuration has no specified version  (latest matching version is
17:18:30 <andrei> 0.4.18.0)needed since hsdev is a build target.Some different approaches to resolving this:  * Recommended action: try adding the following to your extra-deps in /home/andrei/code/haskell/hello-world/stack.yaml:- direct-sqlite-2.3.26@sha256:04e835402f1508abca383182023e4e2b9b86297b8533afbd4e57d1a5652e0c23,3718-
17:18:31 <andrei> haddock-api-2.24.0@sha256:f3dc94da74e99f855ba6401b4f1a8f1ae753d3f076b45b7627a90784bd2d591d,5627- hdocs-0.5.4.0@sha256:36e692b255e51ed38e0bb65f5ace5df9399217b522c34e2b5ed4e52a6b6097bd,2933- sqlite-simple-0.4.18.0@sha256:3ceea56375c0a3590c814e411a4eb86943f8d31b93b110ca159c90689b6b39e5,3002Plan construction failed.
17:18:31 <andrei> /0.6s```I could try to add the dependencies directly to stack.yaml as followsresolver: lts-15.8extra-deps:- hsdev-0.3.3.8- direct-sqlite-2.3.26- haddock-api-2.24.0- hdocs-0.5.4.0- sqlite-simple-0.4.18.0but of course there will be some conflicts. Plus I don't want to manually specify the individual versions of all dependencies.So then, here are my
17:18:31 <phadej> True :: Bool :: * :: * :: * :: *
17:18:32 <andrei> questions:- Is it possible to add `hsdev` as a dependency to the `stack.yaml` without manually resolving all its dependencies?- Is my approach even correct? Adding `hsdev` to stack.yml adds it as a package dependency thus forcing it upon any other users of this package.In the meantime, I have given up and installed hsdev globally (using `stack
17:18:32 <andrei> install hsdev`)
17:18:44 <phadej> the tower is infinite
17:20:13 <frdg> thanks for all the explaining
17:23:57 <phadej> Haskell is maybe not the best language to use to try to figure all the details of type "universes" as they are called. It cut corners for pragmatic reasons
17:27:07 <andrei> Here is some more context for my question regarding `hsdev` and `stack.yaml`. Can anyone please take a look? https://ybin.me/p/9b90f4199985eadd#OY1htAJu5Vrln35vqbRSEci+C3ec34AseXr+mZEowUg=
17:28:01 <phadej> frdg: reading introduction of http://richarde.dev/papers/2020/kind-inference/kind-inference.pdf  might answer some questions, or fill the blanks
17:29:19 <phadej> to see word "kind" used somewhere else, than in error messages
17:30:02 <frdg> appreciate it. Im gonna read it after the other article you linked. 
17:32:19 * hackage ghc-lib-parser-ex 8.10.0.16 - Algorithms on GHC parse trees  https://hackage.haskell.org/package/ghc-lib-parser-ex-8.10.0.16 (shayne_fletcher)
17:39:54 <sm[m]> andrei: there's a build-tools/build-tool-depends which may be relevant
17:43:44 <sm[m]> oh you are trying to set up an ide. Your best path is to follow the hsdev setup docs carefully and seek support from the developer/issue tracker
18:06:33 <tanner_> is anyone here
18:07:44 <ski> no
18:07:54 <darius-os> who names their kid anyone 
18:08:10 <tanner_> i have a beginner level question
18:08:18 <ski> ask
18:09:16 <tanner_> I defined a function in a weird way on purpose: 
18:09:23 <tanner_> lucky x = "thats not a 7"
18:09:28 <tanner_> lucky 7 = "thats a 7"
18:09:43 <Cale> The second pattern will never have a chance to match
18:09:44 <monochrom> First match is taken.
18:09:47 <tanner_> I understand why it doesn't work, what confuses me is the type ghci says it has
18:09:47 <ski> defining equations are tried in order, on pattern-matching
18:09:49 <Cale> because x matches everything
18:10:10 <ski> `7' is a polymorphic numeric literal, can have many (numeric) types
18:10:14 <tanner_> ghci says it has type: 
18:10:15 <tanner_> lucky :: (Eq a, Num a) => a -> [Char]
18:10:18 <Cale> yep
18:10:27 <ski> (it needs `Eq' to be able to match on the `7')
18:10:47 <ski> which part of it are you confused by ?
18:10:49 <Cale> For any type a which is a type of numbers that can be tested for equality, lucky will take a value of type a, and produce a list of characters (a String)
18:10:59 <monochrom> What is the question anyway?
18:11:01 <ski> have you seen constraints in type signatures before ?
18:11:16 <tanner_> why must is the Eq not a requirement of Num already? I would think saying (Num a) covers it
18:11:23 <ski> it used to be
18:11:37 <Cale> There are useful types of numbers which can't really be tested for equality
18:11:41 <tanner_> what kind of Num is not Eq
18:11:43 <ski> but that precludes e.g. having functions as numbers
18:12:10 <Cale> Yeah, various things defined using functions, or e.g. computable real numbers
18:13:00 <tanner_> Ok, that makes sense if there is such thing as a non Eq number
18:13:40 <ski> @let instance Num a => Num (rho -> a) where (f + g) r = f r + g r; (f - g) r = f r - g r; (f * g) r = f r * g r; negate f r = negate (f r); abs f r = abs (f r); signum f r = signum (f r); fromInteger n r = n
18:13:41 <Cale> It's not in the Prelude because a lot of the time it would simply be confusing, but it's possible to write an instance of Num like:
18:13:42 <lambdabot>  .L.hs:166:27: error:
18:13:42 <lambdabot>      â€¢ Couldn't match expected type â€˜aâ€™ with actual type â€˜Integerâ€™
18:13:42 <lambdabot>        â€˜aâ€™ is a rigid type variable bound by
18:13:47 <ski> @let instance Num a => Num (rho -> a) where (f + g) r = f r + g r; (f - g) r = f r - g r; (f * g) r = f r * g r; negate f r = negate (f r); abs f r = abs (f r); signum f r = signum (f r); fromInteger n r = fromInteger n
18:13:48 <Cale> oh, haha, like ski just did
18:13:48 <lambdabot>  Defined.
18:14:11 <Cale> > (sin^2 + cos^2) 5
18:14:13 <lambdabot>  0.9999999999999999
18:14:36 <Cale> > (1 + sin) (pi/2)
18:14:38 <ski> @let instance Fractional a => Fractional (rho -> a) where (f / g) r = f r / g r; recip f r = recip (f r); fromRational q r = fromRational q
18:14:38 <lambdabot>  2.0
18:14:39 <lambdabot>  Defined.
18:15:06 <Cale> So now we're allowed to do arithmetic on functions
18:15:58 <ski> > let p = (id^2 - id) / 2 in [p x | x <- [-4 .. 4]]
18:15:59 <lambdabot>  [10.0,6.0,3.0,1.0,0.0,0.0,1.0,3.0,6.0]
18:17:09 <ski> > let p = fst^2 - fst*snd + snd^2 in [[p (x,y) | x <- [-1 .. 1]] | y <- [-1 .. 1]]
18:17:11 <lambdabot>  [[1,1,3],[1,0,1],[3,1,1]]
18:17:47 <ski> tanner_ : in general, functions can't be checked for equality
18:18:54 <tanner_> So 5 is an example of Num and Eq, but these functions are only of Num?
18:19:11 <tanner_> Thanks to the definitions for function arithmetic that were just made?
18:19:24 <ski> well, also `Fractional', for the `(id^2 - id) / 2' polynomial example
18:19:27 <Cale> Well, when you write a pattern match against some integer constant like 5 or 7, it turns into something like:
18:19:42 <Cale> lucky x | x == fromInteger 7 = ...
18:20:01 <ski> (that's a "polynomial in a single variable/indeterminate", while the one with `fst' and `snd' is one "in two indeterminates/variables")
18:20:11 <Cale> i.e. it uses the fromInteger function from the Num class to translate the integer literal into the numeric type, and then uses == to compare for equality
18:20:56 <ski> anyeay, `Eq' used to be a superclass of `Num', so that only `Num a', not `Eq a', would be inferred as constraint for `lucky'
18:21:24 * ski presumes tanner_ has seen guards before
18:22:19 <tanner_> yes... kinda
18:23:33 <ski> the thing after the `|' is a boolean check, which must evaluate to `True', in order for that (branch of the) defining equation to be taken
18:24:02 <tanner_> whats the difference with an if statement?
18:24:16 <tanner_> is it just intended to be easier to branch with? like a switch?
18:24:20 <ski> there are no `if' statements in Haskell
18:24:43 <ski> if you mean an `if'-`then'-`else' expression, then .. well, it's an expression
18:24:53 <ski> while guards attach to a defining equation
18:24:55 <Cale> The biggest difference between guards and using an if expression is that guards will fall through to the next pattern match if the last guard fails
18:25:05 <ski> yes
18:25:25 <ski> `if'-`then'-`else's can be nested arbitrarily inside an expression, though
18:25:46 <ski> (guards can also be used in `case'-`of' expressions)
18:29:40 <tanner_> Ok, looks like stackoverflow had this question 6 years ago: https://stackoverflow.com/questions/23116449/haskell-does-num-class-inherit-eq-class
18:30:20 <tanner_> Thanks for the help!
19:08:50 * hackage metro 0.1.0.0 - A simple tcp and udp socket server framework  https://hackage.haskell.org/package/metro-0.1.0.0 (Lupino)
19:11:56 <andrei> sm[m]: thanks for taking the time. Yes, I am trying to setup the IDE. I have resorted to using `stack install hsdev` to install hsdev globally (for now)
19:15:19 * hackage metro-socket 0.1.0.0 - Socket transport for metro  https://hackage.haskell.org/package/metro-socket-0.1.0.0 (Lupino)
19:17:11 <sm[m]> andrei: and that's working ?
19:30:45 <andrei> sm[m]: Yes. I had to restart SublimeText and then Restart the backend (from within Sublime), but it seems to be working
21:12:20 * hackage metro 0.1.0.1 - A simple tcp and udp socket server framework  https://hackage.haskell.org/package/metro-0.1.0.1 (Lupino)
22:03:20 * hackage metro-transport-xor 0.1.0.0 - XOR transport for metro  https://hackage.haskell.org/package/metro-transport-xor-0.1.0.0 (Lupino)
22:08:49 * hackage metro-transport-websockets 0.1.0.0 - Websockets transport for metro  https://hackage.haskell.org/package/metro-transport-websockets-0.1.0.0 (Lupino)
22:10:50 * hackage metro-transport-crypto 0.1.0.0 - Crypto transport for metro  https://hackage.haskell.org/package/metro-transport-crypto-0.1.0.0 (Lupino)
22:11:50 * hackage metro-transport-tls 0.1.0.0 - TLS transport for metro  https://hackage.haskell.org/package/metro-transport-tls-0.1.0.0 (Lupino)
22:52:19 * hackage periodic-common 1.1.7.0 - Periodic task system common.  https://hackage.haskell.org/package/periodic-common-1.1.7.0 (Lupino)
22:59:50 * hackage periodic-client 1.1.7.1 - Periodic task system haskell client.  https://hackage.haskell.org/package/periodic-client-1.1.7.1 (Lupino)
23:40:42 <dintenk> Hello, I am seeing something strange , my hashmap has duplicate records with the same Key ! I am using - https://hackage.haskell.org/package/stm-containers-1.1.0.4/docs/StmContainers-Map.html
23:40:54 <dintenk> is this supposed to be happening?
23:41:56 <dintenk> I have a concurrent application, multiple threads are inserting to the hashmap, some with the intention of Updating the existing record
23:42:44 <dintenk> But it is inadvertently inserting a duplicate record with the same Key! this is what I am seeing , easy to reproduce too when left running for a few minutes
