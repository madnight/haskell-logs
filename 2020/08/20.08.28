00:01:04 <Cale> Axman6: While it's probably good to have a somewhat reliable implementation of these kinds of things in Haskell, it'd really be quite a lot of work to get something which one could really be convinced isn't vulnerable to all the kinds of attacks that the various C libraries have already been hardened against.
00:02:37 <typetetris> I would prefer mbed tls but one takes what one gets I guess.
00:06:54 <phadej> there are "too many" *ssl libraries to have bindings to in Haskell
00:07:22 <phadej> libressl, s2n...
00:07:41 <Cale> one at a time :)
00:07:49 * hackage psql-utils 0.1.0.0 - PostgreSQL Simple util tools.  https://hackage.haskell.org/package/psql-utils-0.1.0.0 (Lupino)
00:08:04 <Axman6> I was planning to write a WolfSSL binding at some point...
00:08:17 <phadej> though IIRC s2n depends on some (to be configured) library to provide cryptoprimitives
00:09:02 <phadej> https://github.com/awslabs/s2n#quickstart-for-osx-or-other-platforms looks like on openssl
00:09:09 <typetetris> is there any open source tls library which has had formal verification efforts?
00:09:14 <phadej> typetetris: s2n
00:09:38 <phadej> https://galois.com/project/amazon-s2n/
00:10:47 <phadej> Cale: http://oleg.fi/gists/posts/2018-12-09-preload-trick.html
00:10:52 <phadej> Cale: https://oleg.fi/gists/posts/2018-12-09-preload-trick.html -- https
00:12:37 <phadej> (I have since made `github` package to be configurable to use http-client-openssl directly)
00:17:26 <typetetris> s2n doesn't support tls1.3. I can't judge wether that is some severe thing, naively I would think tls1.3 is the newest protocol and so not supporting it is kind of a deal breaker, isn't it?
00:18:31 <Cale> phadej: We also do a bit of that kind of thing via nix
00:19:17 <Cale> phadej: In fact, we have the whole ecosystem built with -fexpose-all-unfoldings, if that counts ;)
00:20:58 <typetetris> lol, most of the open issues on s2n regard tls 1.3
00:20:59 <Cale> But also, on the ghcjs side of things, there are some hacks like replacing text with a version that uses javascript strings
00:39:11 <wz1000> > [ (x,y) | (x:xs) <- tails [1..5], y <- xs ]
00:39:13 <lambdabot>  [(1,2),(1,3),(1,4),(1,5),(2,3),(2,4),(2,5),(3,4),(3,5),(4,5)]
00:40:20 <wz1000> Is there a name for this operation, where you take the distinct (unordered) pairs from the cartesian product of a list with itself?
00:42:14 <Ferdirand> 2-combination ?
00:52:59 <wz1000> doh
01:09:51 <phadej> Cale: `ghc-options: -fexpose-all-unfoldings` in cabal.config for all packages is not "a trick"
01:11:37 <lemmih> I made a website for running Haskell animations right in your browser. Please feel free to try and break it so I can fix any bugs: https://reanimate.github.io/reanimate/playground/
01:22:11 <buggymcbugfix> Criterion seems to have 5 repeating colors for the bar charts in its output report (html). Is there some way of changing that to, say, 4 colors?
01:24:55 <dminuoso> Cale: I had an interesting talk with lexi-lambda the other day about -fexpose-all-unfoldings. They think it's not as effective, because worker/wrapper transformation usually defeats specialization anyway.
01:25:15 <dminuoso> (Effective for the reasons you appear to be using it)
01:25:34 <Cale> It seems to work well for us.
01:26:06 <dminuoso> Did you measure the difference between enabling and disabling it in some manner?
01:27:02 <Cale> Well, it was the difference between unacceptable and acceptable performance in at least one of our apps.
01:27:31 <dminuoso> Doesn't that seem a bit extreme, to enable it company wide because it helped in one project?
01:27:56 <dminuoso> Or do you just deem this unlikely to have a negative impact, with just a possibility of improving performance?
01:28:33 <Cale> Basically, yeah
01:29:05 <dminuoso> Fair enough. I'd be curious how much performance increases if you used backpack or implicit params instead. :p
01:29:09 <Cale> It's helps a ton with reflex-dom applications
01:29:55 <dminuoso> I see
01:29:58 <Cale> But yeah, we might end up trying backpack or something eventually
01:30:04 <Cale> It*
01:30:44 <Cale> We only just implemented -j support for backpack though
01:31:20 <Cale> (for a client)
01:31:55 <dminuoso> Im surprised people use backpack, despite the lack of documentation left and right.
01:32:08 <Cale> and I dunno, it still seems really new and untried in general
01:32:11 <Cale> yeah
01:32:21 <Cale> Maybe in a few years though :)
01:32:22 <dminuoso> Edward didn't sound too optimistic about the future of backpack either, given that ezyang has finished his PhD thesis.
01:32:47 <dminuoso> We can hope that someone finds the time.
01:33:05 <Cale> GHC is *so* hard to make progress on
01:34:28 <Cale> I kind of have a dream of making a fork which makes various aggressive changes just to see where we could get with it.
01:34:58 <dminuoso> And then you realize "I need a team and funding for this"
01:35:12 <Cale> Well, if Obsidian eventually gets big enough...
01:36:05 <dminuoso> How many folks do you have at the moment?
01:36:44 <dminuoso> From the webpage it seems 12 at minium. :)
01:37:04 <Cale> It's somewhere around 40-something
01:44:55 <Saten-san> Does someone have a good tutorial explaining Lamba Calculus?
01:45:03 <Saten-san> Know*
01:45:43 <[exa]> Saten-san: depends "for what purpose"
01:46:28 <[exa]> Saten-san: ie, do you aim for programming, formal models, logic and typesystems, ...?
01:47:02 <dminuoso> I think, if you have to even ask, they're just looking for a rudimentary introduction.
01:47:18 <Saten-san> Understanding Haskell, I'm sure I'll find something on YouTube.
01:47:35 <dminuoso> Saten-san: Only do this if you have a genuine curiosity about lambda calculus.
01:48:00 <Saten-san> I didn't quite understand it from the book I'm reading so I'm trying videos rn
01:48:12 <dminuoso> Are you reading the Haskell Book?
01:48:30 <Saten-san> Aren't all functional programming languages based on Lambda calculus?
01:48:32 <Saten-san> Yes :)
01:48:44 <Saten-san> Seems to be the best book on Haskell currently.
01:49:49 <dminuoso> Do you have a CS backgrod?
01:49:54 <dminuoso> background, even.
01:57:16 <dminuoso> At any rate, I recommend you just go through google and search for various uni courses, papers, slides and/or video lectures, and pick one that you can grok? Just don't give up too early, it might take a short bit before you grok it.
01:57:39 <dminuoso> Just remember: It's not necessary to learn lambda calculus to understand Haskell at any rate. 
01:59:48 <Saten-san> dminuoso: It's funny how much university learning material is freely available on the web.
01:59:56 <kuribas> but it's more useful than cathegory theory
02:02:01 <Saten-san> I'm still in highschool but I'm pretty sure that I'm going to do Math or Physics on college because CS feels like a waste of time and money.
02:02:06 <Saten-san> in*
02:07:53 <sshine> ah, shoot, I logged off before I had a chance to answer guest-10.
02:34:35 <maralorn> Saten-san: That sounds a quite offensive to probably a large part of this channel? And I don‘t think your reasoning is correct. On the other hand your conclusion is surely also a very sound option. (I don‘t regret it at all.)
02:39:28 <dminuoso> Keep in mind, that the quality of CS colleges/unis varies widely.
02:41:47 <dminuoso> Some are more worried about teaching you GoF and memorizing complexities of algorithms, others offer you good courses on type theory, programming language semantics, and so forth.
02:42:28 <dminuoso> If CS really interests you, then I wouldn't be too quick to dismiss CS on a college/uni.
02:42:34 <[exa]> Saten-san: depends a lot. There are "CS" courses which sum up to learning basic algorithms and obsolete technologies, which you probably had in mind
02:43:41 <[exa]> and there are the others, with the specialized math (complexity and enumerability), logic, advanced algorithm&data structure design, etc
02:44:37 <dminuoso> Sadly, there's no option of the latter nearby where I live. By the time I realized such a uni would have been what I wanted, I already had started a family, so moving is not as simple anymore.
02:44:50 * dminuoso did not get to study formal CS in a decent setting thereby
02:46:01 <cpressey> Hello.  Could someone help me understand what wheel I must have re-invented by writing this function?: https://gist.github.com/cpressey/a28ed9b3a274d1abd7edcc2844e54f3e
02:46:32 <[exa]> cpressey: that's very like >>=
02:46:35 <dminuoso> cpressey: >=>
02:46:40 <[exa]> yeah
02:46:41 <dminuoso> % :t (>=>)
02:46:41 <yahb> dminuoso: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
02:46:44 <dminuoso> % :t (<=<)
02:46:44 <yahb> dminuoso: Monad m => (b -> m c) -> (a -> m b) -> a -> m c
02:47:16 <dminuoso> cpressey: If you squint a bit, you might see the similarity to:
02:47:19 <dminuoso> % :t (.)
02:47:19 <yahb> dminuoso: (b -> c) -> (a -> b) -> a -> c
02:47:29 <dminuoso> Which is why (<=<) is called kleisli composition. :)
02:48:59 <dminuoso> cpressey: And, to make this even more exciting, `return` acts as an identity with respect to <=</>=> just like id acts as an identity with respect to (.)
02:49:20 <[exa]> cpressey: if you generalize that a bit (for lists, maybes, etc.), you've reinvented monads. Congratulations! :]
02:49:22 <dminuoso> And to double down some more, just like (.) (<=<)/(>=>) is associative! :)
02:49:45 <dminuoso> (f <=< g) <=< h = f <=< (g <=< h)
02:49:58 <dminuoso> And this is cleaner reformulation of the monad laws you may have heard of. :)
02:50:06 <cpressey> I did try writing this using Either as a monad just previous to this, but I used >>= and do notation and they both looked a bit awkward.
02:51:08 <dminuoso> So the identity law in action: `f <=< return = f` and `return <=< f = f`
02:51:12 <dminuoso> cpressey: ^- does all that make sense? :)
02:52:27 <cpressey> dminuoso: It's far too much info for me to say if it make sense or not quite yet. I definitely have not reinvented monads, I might have reinvented the operator known in Haskell as >=>, thanks, let me check it out to confirm.
02:54:44 <ixlun> If I've got: parseTest (digitToInt <$> char '3' :: Parser Int) "3"
02:55:45 <ixlun> that works great, but I want it in the range 1-8 in chars, so I'm trying something like: parseTest (choice $ ((digitToInt <$> char) <*> ['1'..'8']) :: Parser Int) "3"
02:56:21 <ixlun> which errors out.... any suggestions?
02:56:24 <Rembane> ixlun: Is choice from QuickCheck? 
02:56:53 <[exa]> ixlun: you may want `oneOf` or something similar
02:57:18 <[exa]> ixlun: (instead of just `char`)
02:57:26 <cpressey> dminuoso: Yes, that's it. Thanks!
02:58:16 <ixlun> Rembane: Don't think so, I think it's from Data.Applicative.Combinators
02:59:41 <dminuoso> cpressey: If you want a good excercise, try implementing >>= in terms of <=< and vice versa. :)
02:59:44 <Rembane> ixlun: Got it. 
02:59:54 <dminuoso> Shouldn't take too long, but it might demonstrate that they are equivalent in terms of expressivity.
03:00:19 <ixlun> [exa]: Nice, that works. Thanks!
03:01:40 <[exa]> ixlun: anyway your example would probably work as: digitToInt <$> choice (map char ['1'..'8'])
03:02:12 <[exa]> ixlun: but you're much better off not enumerating the lists, say with `satisfy isDigit`
03:03:59 <[exa]> or, `satisfy (inRange '1' '8')` for some idealized definition of inRange that you can probably spawn just for this purpose
03:14:05 <ulidtko> can I use ViewPatterns when pattern-matching records?
03:21:15 <ulidtko> well apparently, yes, sure, why not.
03:27:16 <kuribas> does the haskell language server use stack or old-style cabal by default?
03:27:31 <kuribas> because I am using new-style cabal, and get errors in visual-studio code
03:30:17 <ixlun> Thanks, I'll take a look at that [exa] 
03:32:43 <ixlun> What is an: Illegal equational constraint?
03:33:04 <ixlun> (other than a big scary error message!)
03:33:49 <kuribas> ixlun: context?
03:34:56 <kuribas> is my impression right that most tooling is build around stack?
03:35:40 <merijn> kuribas: Eh, define "most", "tooling", and "build around"? ;)
03:36:08 <kuribas> haskell language server, hie, intellij plugins, vscode, etc...
03:36:14 <ixlun> kuribas: http://ix.io/2vtL
03:36:26 <kuribas> even emacs modes seem to use stack by default
03:38:10 <kuribas> ixlun: what's Token s?
03:38:16 <merijn> kuribas: hls isn't build around stack
03:38:25 <kuribas> ixlun: it looks like just a type error.
03:38:31 <nij> Need help with monadic stuff :(((
03:38:51 <kuribas> ixlun: unless you meant Token s to be Char, then your types are wrong.
03:39:02 <merijn> kuribas: Token s is a type family from megaparsec
03:39:05 <nij> I'm parsing CSV using parseCSVFromFile :: FilePath -> IO( Either ..error [[String]] )
03:39:20 <merijn> kuribas: "Token Text = Char", "Token String = Char", etc.
03:39:25 <merijn> So that's fine
03:39:30 <nij> Now I've successfully parsed and see the result, but I want to get my hands on it as if I have a [[String]] already
03:39:42 <kuribas> merijn: yeah, it seems like he wants to have a String parser, but has given a type that's too general.
03:40:08 <kuribas> Lacking a bit of context here
03:40:09 <merijn> It just infers a polymorphic type and the extension for that type is not enabled, therefore error
03:40:20 <merijn> Solution: Enable extension or write down type explicitly
03:40:42 <kuribas> indeed
03:41:25 <ixlun> Type for what, sorry?  caseCharClr?
03:41:27 <kuribas> merijn: hls is giving errors about imports, while there is not error using cabal new-build
03:41:42 <kuribas> merijn: so that means it uses cabal build instead?
03:41:45 <merijn> kuribas: anyway, a lot of tooling does have a lot of effort to integrate with stack, because people who use stack pour in that effort, but HLS/HIE aren't specifically designed around stack
03:42:29 <merijn> kuribas: It doesn't use cabal to build at all, it uses the GHC API directly. But the interface to get the right config from cabal.project and .cabal files is still quite a bit in flux
03:42:43 <kuribas> merijn: so I am screwed?
03:42:53 <merijn> Last time I updated ghcide it magically started working for my complex repo
03:43:11 <kuribas> merijn: it's not for me, I want to provide a good tooling setup for my colleages.
03:43:28 <kuribas> I can live with emacs
03:43:29 <merijn> kuribas: You can manually create a hie.yaml and commit it to the repo
03:43:45 <kuribas> I use hls, not hie
03:43:47 <ixlun> Ah yep - fixed by adding ':: Parser Piece' to the end of caseCharClr :-)
03:43:51 <merijn> kuribas: Irrelevant
03:44:00 <merijn> kuribas: hls, hie, and ghcide all use hie-bios
03:44:02 <merijn> kuribas: https://github.com/mpickering/hie-bios
03:44:02 <ixlun> ':: Parser Colour', sorry.
03:44:07 <kuribas> hmm
03:44:24 <merijn> kuribas: Also hls is absorbing hie
03:44:51 <merijn> kuribas: See https://mpickering.github.io/ide/posts/2020-05-08-state-of-haskell-ide.html
03:45:21 <kuribas> is hie.yaml documented?
03:45:43 <merijn> To the extent of the hie-bios readme :p
03:46:01 <merijn> But mpickering is usually pretty good at responding quickly here if you get stuck
03:47:41 <kuribas> cladle: cabal: is new style?
03:47:44 <kuribas> or old style?
03:48:34 <merijn> I'm not even sure that question has an answer
03:49:23 <merijn> Like I said, it doesn't use cabal-install for building, it only looks up the configuration via it
03:51:18 <kuribas> this stuff really needs to improve
03:51:24 <merijn> So the only new-style/old-style the distinction is "where does it find the dependencies", in which case it will just return whatever cabal specifies
03:51:44 <kuribas> I have a cabal.project, but it doesn't seem to use it
03:52:21 <merijn> kuribas: Contributions welcome ;)
03:52:29 <kuribas> no way
03:53:31 <merijn> ghcide works fine with v2-build and cabal.project on my machine, so presumably hls should to, since it builds on top of ghcide
03:53:51 <kuribas> I might be able to contribute back to the community if I manage to convince my team to use haskell.
03:54:15 <kuribas> merijn: before I used hie, that worked well
03:54:22 <merijn> Everyone wants working tooling, no one wants to build working tooling
03:54:25 <kuribas> merijn: now I switched to hls, and it's failing
03:54:32 <merijn> Well, don't switch, then?
03:54:56 <kuribas> it's the default for the haskell plugin now
03:55:26 <kuribas> it doesn't require compilation
03:57:08 <merijn> "the default" <- well complain to whoever made it the default for whatever editor you're talking about?
03:57:22 <kuribas> vscode
03:58:09 <kuribas> also reddit posts seem to imply hls is where the work is being done
03:58:14 <kuribas> is that wrong then?
04:01:15 <kuribas> I already got the response, haskell is not useful, because they want to avoid success.
04:01:31 <merijn> hie-bios, ghcide, and hls is what people are working on, yes. But all three have evolved massively over the past year, and there's lots of work in progress
04:01:53 <kuribas> which is great... Maybe I just need to wait another year or so?
04:03:40 <merijn> yes, no, maybe? things are moving quickly, so there's no real stable documentation either, so your options boil down to "dive in and figure things (and ideally, write down what you learned)" or "wait until things are more settled and stable"
04:03:54 <ixlun> man, hlint is amazing
04:04:04 <nij> Hello.. I have obtained data of type (m1 (m2 a)), and would like to apply functions of type (a->b) and get (b), what should i do?
04:04:25 <nij> (where m1 m2 are two different monads.. really they are IO and Either
04:06:22 <fendor_> kuribas, why is hls failing? 
04:06:31 <kuribas> fendor_: idk
04:06:49 <kuribas> fendor: cabal new-build works
04:07:07 <kuribas> fendor: but hls reports module missing errors.
04:07:40 <fendor> kuribas, no hie.yaml? cabal version? In which component are modules missing?
04:07:55 <kuribas> cabal 3.0.1.0
04:08:00 <kuribas> no hie.yaml
04:08:11 <fendor> does `cabal repl <filename>` work?
04:08:43 <kuribas> cabal new-repl works
04:08:50 <fendor> with the filename?
04:09:00 <kuribas> repl as well
04:09:00 <kuribas> yes
04:09:58 <fendor> ok, what are the logs of `haskell-language-server --debug <path-to-file-that-fails>`
04:12:05 <merijn> kuribas: in 3.0 repl and new-repl are the same thing
04:12:11 <kuribas> hmm, where is that installed?
04:13:07 <fendor> haskell-language-server? uhm, dunno how vscode does it
04:14:16 <fendor> does install it
04:14:49 * hackage opentelemetry 0.6.1 -   https://hackage.haskell.org/package/opentelemetry-0.6.1 (DmitryIvanov)
04:15:49 * hackage opentelemetry-lightstep 0.6.1, opentelemetry-wai 0.6.1, opentelemetry-extra 0.6.1 (DmitryIvanov)
04:16:16 <kuribas> fendor: it's building stuff
04:16:59 <fendor> it usually does that if you invoked cabal build before hls
04:18:07 <fendor> but it *should* only configure your local components
04:18:45 <kuribas> fendor: ah it works if I launch it from the project directory
04:19:03 <kuribas> fendor: but it gives those error when I launch it from home.
04:19:46 <fendor> oh... ok. That used to work in hie?
04:19:49 <kuribas> so the plugin is launching it from the wrong directory?
04:20:04 <sshine> ixlun, if you think hlint is amazing, you should try it with an excessive amount of library-specific hints :-D https://github.com/kowainik/relude/blob/master/.hlint.yaml
04:20:17 <kuribas> fendor: I don't know how that plugin works...
04:20:50 <fendor> maybe. Neither do I. I usually just open the folder explictly with Open Folder.
04:20:54 <kuribas> sshine: what's "one"?
04:20:55 <kuribas> :t one
04:20:56 <lambdabot> error:
04:20:56 <lambdabot>     • Variable not in scope: one
04:20:57 <lambdabot>     • Perhaps you meant one of these:
04:21:22 <maralorn> Will the ICFP/Haskell 2020 talks be uploaded somewhere publicly?
04:21:24 <sshine> kuribas, https://hackage.haskell.org/package/relude-0.7.0.0/docs/Relude-Container-One.html#v:one
04:22:09 <sshine> kuribas, so 'one' is a generic 'singleton' function.
04:22:21 <kuribas> sshine: right
04:22:27 <fendor> maralorn, they are uploaded to youtube
04:22:33 <fendor> https://www.youtube.com/results?search_query=icfp+keynote+2020
04:22:40 <sshine> kuribas, I guess I think 'pure' is fine. :)
04:23:07 <sshine> kuribas, but there certainly is some unnecessary leak of abstraction, as if that were ever avoidable.
04:23:11 <kuribas> sshine: pure is something different, it doesn't mean "one"
04:23:17 <sshine> kuribas, right :)
04:23:24 <sshine> kuribas, it just often means that.
04:23:43 <sshine> or... is equivalent at some level..
04:23:44 <kuribas> sshine: no, it often *conincides* with it.
04:23:56 <sshine> right.
04:24:02 <kuribas> > pure 5 :: Const ()
04:24:03 <lambdabot>  Terminated
04:24:40 <kuribas> > pure 5 :: Const () Int
04:24:42 <lambdabot>  Const ()
04:25:27 <kuribas> fendor: so folders work, but workspaces don't?
04:26:21 <fendor> kuribas, I think they should, but I dont use workspaces, so I dont know :/
04:27:08 <kuribas> fendor:  but how does the plugin knows the project root?
04:27:15 <kuribas> fendor: shouldn't the language server find it?
04:32:41 <fendor> kuribas, it should, but I dont know workspaces work, whether they are different in some way
04:33:29 <kuribas> fendor: "it" = vscode?
04:33:49 * hackage shakespeare 2.0.25 - A toolkit for making compile-time interpolated templates  https://hackage.haskell.org/package/shakespeare-2.0.25 (MichaelSnoyman)
04:34:07 <kuribas> fendor: AFAIK a workspace is just a collection of folders in vscode
04:34:12 <kuribas> which get saved when you exit
04:34:15 <fendor> the language server should find the project root, via hie-bios: https://github.com/haskell/haskell-language-server/blob/master/exe/Main.hs#L166
04:34:41 <sshine> if I've got a data type that I'd like to make extensible, I could do 'data Foo a = X | Y | Ext a' and refer to 'Foo Void' for the non-extended version. is that my best option, or are there other ways?
04:34:48 <fendor> well, that is actually the opposite
04:35:53 <fendor> I guess that is what is actually wrong
04:35:58 <kuribas> fendor: ah indeed, opening a folder does work
04:36:04 <sshine> kuribas, yeah, VSCode is very nice about not adding a bunch of project management overhead.
04:36:41 <fendor> kuribas, we should probably open an issue at hls.
04:37:25 <kuribas> fendor: you or me? :-)
04:38:19 <fendor> kuribas, whatever you prefer :)
04:38:42 <kuribas> if you don't mind, it seems you know more about this than I...
04:39:51 <fendor> I do not know more about this particular issue than you :) but I dont mind, so Ill create the issue in a couple of hours
04:41:20 <kuribas> fendor: are you a developer of the hls project?
04:42:01 <kuribas> fendor: ok, thanks
04:43:13 <fendor> kuribas, yes I am :) 
04:44:25 <kuribas> fendor: ah, thanks for the work then :)
04:46:42 <fendor> gladly, I am having fun 
04:55:28 <sshine> https://github.com/dapphub/dapptools/blob/master/src/hevm/hevm.cabal#L74 -- can anyone tell me which dependency depends on libsecp256k1 and libff? might it be 'cryptonite'?
05:01:44 <olle> you guys have physical equality?
05:02:19 * hackage intro 0.9.0.0 - Safe and minimal prelude  https://hackage.haskell.org/package/intro-0.9.0.0 (minad)
05:04:48 <olle> hm, no
05:12:57 <SrPx> Good morning! How realistic it is to run Haskell on the browser today? I'm aware of GHCJS and Asterius. Are those fast? Are there benchmarks?
05:13:46 <opqdonut> not an answer to your question but purescript is pretty popular
05:14:18 <SrPx> I know! Needs to be Haskell though
05:14:44 <Arahael> SrPx: Specifiaclly Haskell? Then GHCJS or - I guess - Asterius - would be the only option.
05:15:05 <SrPx> Is there any comparison of them w.r.t code size & performance?
05:15:25 <Arahael> SrPx: If it has to be haskell ,then that's an irrelevant question.
05:15:49 <SrPx> I mean comparing GHCJS and Asterius
05:16:58 <Arahael> SrPx: Hmm, well, Asterius doesn't seem to work for me, I guess it really does require webassembly.
05:17:16 <Arahael> SrPx: GHCJS, however, would work, and is the only remaining option.
05:17:47 <sshine> I wonder, if I'm doing 'foo :: Foo -> Bar; foo X = a; foo Y = b; foo Z = c', could the compiler generate a non-linear lookup under the special case that there are no guards, that all patterns have the same depth, and that matching is exhaustive? this is probably very fringey.
05:17:50 <SrPx> I see
05:18:03 <Arahael> SrPx: (The browser I'm using is Safari)
05:18:18 <Arahael> SrPx: Why Haskell, though, as opposed to purescript?
05:20:03 <ixlun> Is there a parsing combinator, like replicateM, that also allows you to specify a delimeter and the last entry doesn't require the delimeter?
05:20:18 <SrPx> I'm the developer of Formality, which is sort of a PureScript with formal proofs & dependent types. I'm considering building the language in Haskell. GHC has the fastest HOAS in the world, so it is an amazing target if you're writing a type-checker and interpreter for a functional language. PureScript compiles to JS. JS lambdas are much slower and the runtime isn't nearly as good for pure functional programs.
05:20:34 <SrPx> (Formality right now is developed in JS.)
05:20:40 <sshine> oh hi SrPx :)
05:20:55 <sshine> SrPx, I mentioned Formality in a talk recently.
05:21:01 <Arahael> SrPx: I imagine that JS lambdas are still going to be faster than thunking everything?
05:21:04 <SrPx> The main problem with Haskell is that we want to run our type-checker in iOS, Android, and the Web. That is the one and only reason I never implement things in Haskell, my past experience with Haskell -> Web/Mobile has always been terrible.
05:21:10 <SrPx> And it is hard to ignore literally 99% of the market
05:21:17 <Arahael> SrPx: GHCJS runs *in* javascript.
05:21:24 <SrPx> sshine: you did? That is cool (:
05:21:25 <sshine> GHCJS runs??
05:22:19 <SrPx> Arahael: oh, but the point is that if we use Haskell we can still compile to efficient binaries for desktop use, leaving GHCJS only for browser/mobile. Also GHCJS does use STG so it may still be better than JS lambdas. And no stack overflows too
05:22:35 <SrPx> Not being able to disable the stack limit in JS is so dumb
05:22:41 <Arahael> SrPx: I think the #reflex-frp is the place to be if you want to do cross-platform-on-every-device haskell, I've not really used it, though, but every time I've asked, people have always recommended them.
05:23:09 <SrPx> sshine: what did you say? Feel free to link your talk in our channel!
05:23:50 <sshine> SrPx, I've followed your blog posts; it seems you're pretty geared towards making your PoCs available to people in browsers. I rarely make user-facing software, but my next front-end project will be done in Elm because I think Halogen still lacks a bit of ergonomics.
05:24:47 <SrPx> sshine: I mean, making a choice that forces you out of 99% of the market real user market sounds like a very bad business decision. We have lots of ideas that involve type-checking in an user-facing product.
05:24:54 <nij> May I try my luck again..? I have a two-fold monad.. which I don't know how to handle as if there's not monads: https://dpaste.com/2MR25Q6NS
05:25:30 <sshine> SrPx, if I was married to Haskell in some circumstance where client libraries are inconvenient in Haskell, I might go for something like what servant-elm / elm-street does.
05:25:32 <Arahael> SrPx: If you're using javascript, or ghcjs, on iOS, then you *must* run it within the apple-sanctioned web browser in order to get JIT.  Any other approach, will not be JIT, and you definitely can't use your own javascript engine.
05:25:40 <itai33[m]> is there a good text formatting library? all the ones I could find seem to have benn last updated a year and a half ago at the latest
05:25:46 <itai33[m]> that might not be an issue but it's a bit of a red flag
05:26:17 <Arahael> itai33[m]: Has there been dramatic new research in the past year and a half?
05:26:25 <sshine> itai33[m], what kind of text formatting?
05:26:46 * Arahael has to go - *poof*.
05:27:23 <itai33[m]> like printf type stuff
05:27:40 <sshine> Text.Printf.printf
05:27:44 <sshine> :t Text.Printf.printf
05:27:45 <lambdabot> PrintfType r => String -> r
05:28:14 <itai33[m]> is that the best one? there seem to be others such as formatting  and text-format
05:28:17 <itai33[m]> and one called fmt
05:29:21 <sshine> there are some more type-safe printf variants if you like.
05:30:04 <sshine> itai33[m], https://hackage.haskell.org/package/typelits-printf -- but you'll need to know slightly more Haskell to understand it. :)
05:31:29 <itai33[m]> sshine: what does @"foo" mean?
05:31:40 <sshine> itai33[m], it's a type-level string.
05:32:02 <itai33[m]> I see this is the slightly more haskell that was hinted at
05:33:47 <[exa]> nij: ad monads, you get rid of IO using the binding ( <- ), and you should probably patternmatch on Either
05:34:12 <sshine> itai33[m], https://kcsongor.github.io/symbol-parsing-haskell/ is a blog post that discusses how to implement this. you don't need to understand how it is implemented to use it, though, as long as you don't mind looking at FormatType "f" arg1 => arg1 -> ... for partially applied functions (this only requires understanding of type classes.)
05:34:40 <itai33[m]> sshine: thanks!
05:35:49 <merijn> itai33[m]: Honestly, I just use lists and "mconcat"
05:36:03 <merijn> itai33[m]: For really complex stuff maybe something like pretty-printer
05:36:32 <sshine> SrPx, I know what you mean. having type-checking in a Progressive Web App would rule out Haskell for everyone who doesn't like GHCJS pain. I guess this places you in the PureScript camp for some purposes?
05:36:33 <[exa]> nij: very roughly like this, https://dpaste.com/DQZF57RA7
05:36:57 <itai33[m]> merjin: I just want to have an easy way to convert things like numbers to formatted number strings in an easy way, does pretty-printer do that?
05:37:05 <sshine> merijn, I've used Text.Printf.printf for one thing recently which was "%x".
05:37:12 <itai33[m]> like 3.65 => 03.6 etc
05:37:20 <merijn> sshine: What's that?
05:37:25 <sshine> merijn, hex
05:37:44 <merijn> sshine: For next time: https://hackage.haskell.org/package/base-4.14.0.0/docs/Numeric.html#v:showIntAtBase ;)
05:37:56 <merijn> oh, there's already a showHex version in Numeric too
05:38:10 <sshine> merijn, yeah I was just about to say that. :-)
05:38:20 <sshine> I should replace that.
05:38:37 <sm[m]> it's handy for formatting decimals too
05:38:50 <SrPx> sshine: I mean, there is no reason to use PureScript 
05:38:58 <sm[m]> and aligning strings
05:39:03 <sshine> SrPx, eh?
05:39:28 <SrPx> Formality generates better JS output and has a much stronger type system, so I'd rather just implement it in itself, right?
05:40:07 <SrPx> The only reason to consider Haskell is to borrow GHC's lambdas with HOAS which is really attractive because GHC lambdas are *really really fast*
05:40:09 <merijn> itai33[m]: It doesn't really do that, but see the Numeric module linked above for more detailed number formatting options
05:43:22 <itai33[m]> merijn: it doesn't really seem to have the ability to add leading zeros
05:43:25 <ph88> does someone have a recommendation for a library that produces html ? i'm looking at blaze and ginger, but maybe there are some other interesting libraries out there
05:43:54 <sshine> SrPx, I suppose I'm a fan of the Plutus approach of limiting yourself to a subset of some existing ecosystem to piggyback on tooling. I don't know if that gives you HOAS, I'm not really that advanced.
05:44:00 <nij> [exa]: woah.. this seems complicated..
05:44:19 <nij> There's no way to forcefully extract (m1 (m2 a)) to `a` right..?
05:44:34 <merijn> nij: Not without know whating m1 and m2 are
05:44:56 <SrPx> sshine: that sounds reasonable, yes
05:45:01 <sshine> nij, for comonads there is. https://hackage.haskell.org/package/comonad-5.0.6/docs/Control-Comonad.html#v:extract
05:45:37 <[exa]> nij: you can use `either` to omit the case statement
05:45:41 <merijn> sshine: What are the odds of his m1 and m2 being Comonads? I'm gonna go with "around 1% or less" :)
05:46:07 <sshine> merijn, assuming you have any method to measure such probability, I'm going to vote for it.
05:46:53 <sshine> merijn, I'm at the kindergarten level of "I understand words!" and have yet to advance to apply them productively. ;-)
05:47:50 <[exa]> nij: but the code starts getting ugly https://dpaste.com/54M4FK7EU
05:48:15 <[exa]> nij: also, you can let the program explode in case loading fails, using `fromRight` or something
05:48:31 <sshine> nij, if you have 'Maybe a', you can also do 'fromMaybe def m' to extract the 'a'.
05:48:34 <sshine> :t join
05:48:36 <lambdabot> Monad m => m (m a) -> m a
05:49:50 <nij> merijn: In my case it's just `IO` and `Either`
05:50:11 <nij> sshine: yeah.. I hope my IO and Either are comonads :(
05:50:34 <nij> sshine: by the way are there types `bimonads`?.. namely a monad+comonad
05:51:46 <nij> sshine: Two of my monads are different, m1 = IO, m2 = Either
05:51:49 <lexi-lambda> nij: You certainly can’t expect to “forcefully” get an `a` from an `Either e a` because if the value is `Left` then there is no `a` to get. And with `IO`, you’re even worse, because there is no `a` inside an `IO a` at all; an `IO a` is just a recipe to somehow produce an `a`.
05:52:13 <ph88> hi tdammers 
05:52:31 <nij> lexi-lambda: What if I want to deal with something of type
05:52:47 <nij> IO (Either (IO [a]) (Maybe [b])) ?
05:53:05 <nij> Does that mean that I have to carry the nested monads until the end?
05:53:19 <nij> All I want is to deal with [a] directly :(
05:53:25 <lexi-lambda> I don’t know, I guess I’m glad I don’t have to deal with anything of that type. :) (I kid, sort of.)
05:53:29 <sshine> nij, you probably need to post some code.
05:54:00 <[exa]> nij: as I said, you squash the levels using `bind`, ie `<-` in do notation, or >>=. See the code I pasted.
05:54:15 <lexi-lambda> The fact that you’ve ended up with a type like that at all suggests to me that you’ve made a mistake somewhere earlier in the process.
05:54:38 <sshine> nij, main = do { derp <- m :: IO (Either Error 2DPlottable); case derp of Left x -> ...; Right y -> ...; ... }
05:55:16 <nij> [exa]: Yeah.. I will parse your code after my confusion.. I'm just making sure that it is necessary to carry the monads until the program ends.
05:55:48 <sshine> nij, part of this IO (Either Error 2DPlottable) mess is mixing IO and non-IO. your file-loading function needs to be IO, but your parse2DPlottable function probably doesn't need to be.
05:56:06 <[exa]> nij: you certainly can't get rid of IO; the only way is to squash it to the "main" IO. But you can patternmatch on Either to get rid of it.
05:57:11 <nij> Ok.. seems I have to stick with my `IO (Either a b)`
05:57:21 <nij> [exa]: Thanks I will study your code!
05:57:23 <lexi-lambda> nij: In the case of IO, you do have to “carry the monad until the program ends” in the sense that every Haskell program is definitionally in IO. But suppose you have a pure function `f :: Foo -> Bar`, and you have an `m :: IO Foo`. Then you can write `fmap f m`, and `f` doesn’t have to know anything about IO.
05:57:50 <sshine> nij, so if you e.g. have 'getFile :: FilePath -> IO ByteString' and 'parse2D :: ByteString -> Either Error 2DPlottable', then you can e.g. write: main = do { bs <- getFile "graph.png"; case parse2D bs of ... }
05:57:56 <nij> lexi-lambda: That's my concern.. I will end up be writing lots of fmap?
05:58:06 <lexi-lambda> nij: It depends on your program.
05:58:27 <nij> sshine: That seems pretty legit too, but I need some time to study it. Not comfortable with -> <- yet.
05:58:45 <nij> lexi-lambda: or maybe I should use symbols like <$>
05:58:46 <sshine> nij, you can avoid lots of fmap. try and isolate the part where you deal with parse errors in one function, the part where you deal with reading from files in another function.
05:59:08 <nij> sshine: I see! Wow
05:59:16 <lexi-lambda> If your program has to do a tiny bit of I/O at the beginning, then a bunch of pure stuff, then a tiny bit of I/O at the end, then all the middle bits can be a bunch of pure code that doesn’t touch IO, and you can use do/>>=/fmap in a couple key places to glue everything together. But if your whole program does tons of I/O, yeah, you’ll be in IO the whole way through. But that’s okay.
05:59:41 <sshine> nij, so, assuming those 'getFile' and 'parse2D' you could write 'parse2D <$> getFile "graph.png"' but that's when you end up with an IO (Either Error 2DPlottable).
05:59:43 <lexi-lambda> In the case of Either, you can “get rid of it” any time you’d like, assuming you can actually handle both the Left and Right possibilities.
06:00:53 <sshine> nij, if you post a file with stubs of the functions you aim to have, you can get feedback on whether those functions compose well.
06:01:48 <nij> Ok.. I will first try to make it work. And worry the simplicity of code later. :)
06:01:55 <nij> At least types should match.
06:01:59 <sshine> nij, '->' are functions, you better get comfortable with those soon. :-D
06:02:21 <sshine> nij, yeah just start doing everything in IO if it gets the ball rolling.
06:04:35 <maralorn> I remember at the beginning I was terrified of writing IO functions, because impurity is deemed so evil. But that is of course a misconception. When a program wants to be useful it needs to interact with the real world.
06:04:52 <olle> In Haskell, can I create a function L, without the IO monad, that returns a lambda M *with* the IO monad.
06:05:24 <olle> L never calls M, just constructs it and returns it
06:05:28 <nij> Thank you folks so much :D
06:05:41 <[exa]> olle: so what type should it return?
06:06:06 <maralorn> olle: you mean: `L :: a -> (b -> IO c)`?
06:06:18 <lexi-lambda> olle: What you describe sounds like a function of type `Foo -> Bar -> IO Baz`, which is indeed quite legal (and indeed common, though usually there isn’t any computation between receiving the Foo and Bar arguments, though there could be).
06:06:21 <olle> maralorn: hm, I think so
06:07:00 <olle> ok, good info :)
06:07:07 <maralorn> Then the simple answer to your question is: definitely yes.
06:07:28 <olle> +1
06:08:10 <[exa]> :t \_ _ -> return @IO undefined
06:08:11 <lambdabot> error:
06:08:11 <lambdabot>     Pattern syntax in expression context: return@IO
06:08:11 <lambdabot>     Did you mean to enable TypeApplications?
06:08:29 <[exa]> oh noes, missing type applications
06:10:48 <ph88> does anyone know where the scopeLookup function comes from here ?  https://github.com/tdammers/ginger#running 
06:12:09 <lexi-lambda> ph88: I think you’re intended to provide/define the function that goes there yourself, since it’s the bit that connects the variable names in the templates to the values you want them to reference.
06:12:43 <ph88> actually i found more documentation about this project now o_O
06:13:36 <ph88> lexi-lambda, did you make the video on effects for less ??
06:14:16 <lexi-lambda> yes, guilty as charged
06:14:39 <ph88> i really enjoyed this video :D
06:14:43 <ph88> nice work
06:14:50 <lexi-lambda> Thank you!
06:20:11 <itai33[m]> sshine: does using `typelits-printf` require a turning on some language extensions? because I'm getting compiler errors talking about `TypeApplications` and `DataKinds` but this isn't anywhere in the docs
06:21:07 <itai33[m]> also for some reason for `TypeApplications` it gets pissed if I only have it enabled in the `package.cabal` file and not in a LANGUAGE pragma at the top
06:22:01 <merijn> I would use any form of formatting that requires TypeApplications and DataKinds...that's some ridiculous levels of type level death machinery for formatting >.>
06:22:07 <merijn> s/would/wouldn't
06:22:37 <itai33[m]> yeah honestly I should probably just use the build in printf and pack things manually
06:22:48 <olle> 15:05 < maralorn> olle: you mean: `L :: a -> (b -> IO c)`?
06:22:51 <itai33[m]> because for some reason it doesn't automatically export to Text
06:22:58 <olle> How would this look like if L was also IO?
06:23:14 <olle> `L :: a -> (b -> IO c) IO` ?
06:23:25 <olle> hm, or IO before instead of after
06:23:50 <lexi-lambda> Yes, it would be `L :: a -> IO (b -> IO c)`.
06:24:08 <maralorn> olle: It would probably be `L :: a -> IO (b -> IO c)`
06:30:59 <tomsmeding> though, from an IO (a -> b) value, say f :: IO (a -> b), you can always make an a -> IO b function using \x -> fmap ($ x) f
06:31:38 <tomsmeding> so if you have L :: a -> IO (b -> IO c), then (\x y -> join (fmap ($ y) (L x))) :: a -> b -> IO c
06:31:58 <tomsmeding> but it might not be productive to think about why that works just yet :)
06:34:26 <lexi-lambda> The difference is that you can call the `b -> IO c` function multiple times and duplicate those effects without duplicating the effects needed to produce the `b -> IO c` function given an `a`.
06:35:19 * hackage http-api-data 0.4.2 - Converting to/from HTTP API data like URL pieces, headers and query parameters.  https://hackage.haskell.org/package/http-api-data-0.4.2 (phadej)
06:36:30 <lexi-lambda> Also, a slightly simpler way to write `Monad m => (a -> m (b -> m c)) -> a -> b -> m c` is `\f a b -> f a >>= ($ b)`.
06:37:51 <tomsmeding> good points :)
06:39:21 <olle> lexi-lambda: thanks!
06:42:30 <fizbin> Question about laziness with Data.IntMap.Lazy: is DIL.fromList strict in the list itself and the first element of the tuples in the list, and lazy in the second element of the tuples, or is it lazier than that?
06:44:36 <jchia_> Why does ContT from transformers have reset & shift but not ContT from mtl? It seems that mtl is just reexporting ContT from transformers but somehow it chooses not to reexport reset & shift.
06:44:45 <fizbin> Specifically, if I use DIL.fromList and then do something that forces a DIL.findWithDefault on that result, can I be sure that the input to DIL.fromList has been forced as far as the list itself, the keys in the list, and the value I looked up, but not any other values?
06:45:24 <lexi-lambda> fizbin: A quick peek at the implementation reveals that fromList is implemented using foldl', so it is unambiguously strict in the list spine. And if you think it through, it must be, since later values in the list replace earlier ones.
06:45:28 <jchia_> I mean Control.Monad.Trans.Cont of transformers has reset & shift but Control.Monad.Cont of mtl doesn't
06:46:28 <fizbin> lexi-lambda: Ah, true. I should also look up DIL.fromDistinctAscList's implementation though, since it occurs to me I can actually use that given my inupt.
06:47:56 <fizbin> (And the "it must be" consideration doesn't apply in that case)
06:48:20 <lexi-lambda> fizbin: The implementation looks tail recursive to me, so it’s still strict.
06:58:30 <lexi-lambda> fizbin: Actually, for that matter, all the fields of the IntMap data structure itself are strict (except the values). So the laziness you’d like is not representable, regardless of how you construct it.
06:59:00 <fizbin> Well, all I really need is laziness in the values.
06:59:48 <fizbin> And I need strictness in the list spine.
07:00:03 <lexi-lambda> I don’t understand; Data.IntMap.Lazy is always lazy in the values.
07:01:04 <lexi-lambda> Unless what you’re saying is you want strictness, not that you want laziness, in which case I misinterpreted your question, and my answer is instead “the strictness you want is always present by construction.”
07:01:35 <fizbin> Right; I just wanted to make sure it wasn't accidentally lazier than I expected (e.g. lazy in the list spine somehow)
07:01:55 <lexi-lambda> Yes, that makes sense.
07:02:07 <jophish> Is it possible to get cabal to tell me the path to a binary it's built?
07:02:27 <jophish> squirreled away somewhere in dist-newstyle
07:04:56 <jophish>  I guess I could cabal install to somewhere and then read the symlinks
07:08:14 <phadej> cabal-install-3.4 (look for rc on mailing lists) has list-bin command\
07:12:04 <sshine> itai33[m], my experience is that there is any number of rabbit holes available. you probably don't even need printf.
07:12:19 * hackage intmap-graph 1.2.0.0 - A graph library that allows to explore edges after their type  https://hackage.haskell.org/package/intmap-graph-1.2.0.0 (TillmannVogt)
07:13:09 <jophish> phadej: thanks!
07:14:19 * hackage path-like 0.2.0.2 - PathLike, FileLike and DirLike type classes for the Path library.  https://hackage.haskell.org/package/path-like-0.2.0.2 (locallycompact)
07:16:03 <itai33[m]> sshine: all I need is having an easy way to add leading zeros to numbers. a printf type thing feels like the most straightforward way to do that
07:16:46 <itai33[m]> on an unrelated note, is there a good guide somewhere about record usage?
07:17:15 <lexi-lambda> I can recommend crying
07:17:32 <jophish> hahaha
07:17:56 <itai33[m]> oh no
07:19:04 <jophish> You could look forward to RecordDotSyntax
07:20:02 <jophish> itai33[m]: depends on what you want to do with records, they're very useful at the moment, not sure of any specific general resources though
07:20:16 <itai33[m]> jophish: I thought that was already implemented
07:20:33 <itai33[m]> for now I'd settle for all of the build in syntax using them in one place
07:20:48 <itai33[m]> I don't have nested records and stuff at the moment
07:21:11 <dolio> The Haskell report will have that.
07:21:26 <itai33[m]> sweet
07:22:19 * hackage accelerate 1.3.0.0 - An embedded language for accelerated array processing  https://hackage.haskell.org/package/accelerate-1.3.0.0 (TrevorMcDonell)
07:23:19 * hackage accelerate-llvm-ptx 1.3.0.0, accelerate-llvm-native 1.3.0.0, accelerate-llvm 1.3.0.0 (TrevorMcDonell)
07:23:47 <jophish> itai33[m]: I think there's a plugin and preprocessor to implement it, but afaik it's not in GHC proper
07:24:19 * hackage accelerate-io-JuicyPixels 0.1.0.0, accelerate-io-cereal 0.1.0.0, accelerate-io-bytestring 0.1.0.0, accelerate-io-bmp 0.1.0.0, accelerate-io-array 0.1.0.0, accelerate-io 1.3.0.0 (TrevorMcDonell)
07:25:18 * hackage accelerate-fft 1.3.0.0, accelerate-blas 0.3.0.0, accelerate-bignum 0.3.0.0, accelerate-io-vector 0.1.0.0, accelerate-io-repa 0.1.0.0 (TrevorMcDonell)
07:26:19 * hackage lens-accelerate 0.3.0.0, gloss-raster-accelerate 2.1.0.0, gloss-accelerate 2.1.0.0, containers-accelerate 0.1.0.0, hashable-accelerate 0.1.0.0, colour-accelerate 0.4.0.0, accelerate-examples 1.3.0.0 (TrevorMcDonell)
07:27:19 * hackage mwc-random-accelerate 0.2.0.0, linear-accelerate 0.7.0.0 (TrevorMcDonell): https://qbin.io/each-wc-ig5d
07:28:48 * hackage zenacy-unicode 1.0.0 - Unicode utilities for Haskell  https://hackage.haskell.org/package/zenacy-unicode-1.0.0 (mlcfp)
07:37:12 <Athas> So much Accelerate!
07:40:19 * hackage within 0.2.0.1 - A value within another path.  https://hackage.haskell.org/package/within-0.2.0.1 (locallycompact)
07:57:27 <maerwald> is there a formatter that minimises newlining?
07:57:57 <itai33[m]> when compiling using `cabal run`, I get a gcc error in the Linker phase, and it seems to be complaining about undefined refrences about closures. I'm unsure where to start debugging
07:58:17 <maerwald> itai33[m]: which distro, ghc, cabal version
07:58:18 <itai33[m]> `cabal repl` works just fine, and the `app` part only imports that app starting function
07:58:42 <itai33[m]> ubuntu, ghc 8.8.4, cabal 3.2
07:58:47 <itai33[m]> installed haskell stuff with ghcup
07:58:57 <itai33[m]> the linking is to something internal in the project
07:59:05 <itai33[m]> that much I can gather from the variable names
07:59:15 <glguy> maerwald: putting everything on a single line?
07:59:34 <veverak> buggymcbugfix: ##fi.muni.cz 
07:59:34 <itai33[m]> it's in a file that isn't imported to `app/Main.hs`, would that matter for some reason?
07:59:36 <veverak> fuuuuuuuuu
07:59:38 <veverak> :)
08:00:27 <maerwald> glguy: no, keeping a line lenght limit (80-120 chars), but not lenwlining excessively once the line lenght is hit (e.g. making one newline rather than 20 when there's a long function composition)
08:00:50 <maerwald> some formatters like vertical alignment and start doing excessive newlining
08:02:49 * hackage zipper-extra 0.1.3.2 - Zipper utils that weren't in Control.Comonad.Store.Zipper  https://hackage.haskell.org/package/zipper-extra-0.1.3.2 (locallycompact)
08:04:19 * hackage hashmap-throw 0.1.0.0 - Throw behaviour for hashmap lookup.  https://hackage.haskell.org/package/hashmap-throw-0.1.0.0 (locallycompact)
08:04:19 <itai33[m]> nevermind, i deleted an exposed module in order to have a cleaner git history and forgot to readd it
08:06:44 <lortabac> maerwald: the README of brittany includes in the goals "Be clever about using the available horizontal space"
08:07:14 <maerwald> it does too much newlining for my taste
08:07:59 <maerwald> example https://github.com/lspitzner/brittany/issues/278
08:08:18 * hackage intmap-graph 1.3.0.0 - A graph library that allows to explore edges after their type  https://hackage.haskell.org/package/intmap-graph-1.3.0.0 (TillmannVogt)
08:08:23 <maerwald> so I'm looking for something that minimizes this
08:08:34 <dolio> The best way to get the formatting you want is to do it yourself when you write the code.
08:08:48 <maerwald> nah, waste of time
08:11:39 <ph88> how can i make a context in ginger that has a tree structure instead of flat hashmap ??  https://github.com/tdammers/ginger/blob/04d620dd01d31cd49efb676f96165ca8b009de97/doc/getting-started.markdown#running---the-easy-interface 
08:12:54 <merijn> O, ye of little faith, do not let yourself be tempted by the evil daemon that is automatic formatting. For it's vile siren song will lead you immer astray in your attempts to write readable code
08:12:54 <fog> so im wondering how to make these "implementations" monadic; https://pastebin.com/raw/AXh0BT3E
08:13:22 <fog> i think it could be something to do with Free...
08:13:42 <fog> the miso and mimo trees have miso and mimo functions at the nodes
08:14:13 <fog> if instead they had miso and mimo trees, then these could be "joined" by evaluation of the trees into functions
08:14:32 <merijn> dolio: https://twitter.com/comerijn/status/1257985271603367936 ;)
08:14:56 <fog> how do i write that using Free?
08:15:03 <merijn> I wish I could've managed to fit the follow up into a single concise tweet...
08:15:17 <dolio> Yeah, I pretty much agree with that.
08:17:07 <merijn> I wish the bottleneck in my programming was me manually line-wrapping/laying out code, that'd be great
08:17:17 <fog> i guess i could have the trees have functions *or* trees at the nodes, but im not sure if this is the best way
08:18:29 <fog> the advantage of doing this whole approach is so that you can "edit" an implementation using bind
08:18:55 <dolio> It also takes almost no time to manually format code.
08:19:06 <dolio> Go listen to David Cross' bit on electric scissors.
08:19:53 <fog> also, im not sure about if it can be comonadic - i dont think i can recover the implementation as a tree from a function... 
08:20:22 <fog> but possibly the function *tree* could be partitioned up in a structured way
08:21:38 <fog> what i really want to be able to do is have a way of generating random function trees and then extracting the most commonly useful higher order functions 
08:22:46 <itai33[m]> haskell throws me a non exhaustive pattern warning when I define things like [x,y]=[1,2]
08:23:01 <dolio> Well, it isn't exhaustive.
08:23:06 <itai33[m]> is there any way to get it to stop doing that but still have useful warning for incomplete patterns that actually matter?
08:23:08 <ezzieyguywuf> itai33[m]: that's because the list could be empty or a singleton
08:23:21 <itai33[m]> but x and y are top level variables
08:23:31 <itai33[m]> I'm just writing it like this for convenience
08:23:47 <itai33[m]> (because in the actual program I have like 10)
08:23:48 <fog> and another idea is to do with adding "local variables" to each functions scope - by using the functions as scanners over streams, so that the variables in the local scope of each function can change each time it consumes the HList of input streams
08:24:14 <fog> im not sure if thats more like object oriented code in a pure functional setting
08:25:07 <tomsmeding> Athas: yes go accelerate :D
08:25:43 <fog> itai33[m]: why not use fixed length lists?
08:25:49 * hackage path-binary-instance 0.1.0.1 - Binary instance for Path.  https://hackage.haskell.org/package/path-binary-instance-0.1.0.1 (locallycompact)
08:26:49 * hackage ixset-typed-binary-instance 0.1.0.2, ixset-typed-hashable-instance 0.1.0.2, lucid-cdn 0.2.0.0 (locallycompact)
08:28:54 <itai33[m]> fog: maybe.. but that makes it less readable, and more annoying to change later
08:29:48 * hackage futhark 0.16.4 - An optimising compiler for a functional, array-oriented language.  https://hackage.haskell.org/package/futhark-0.16.4 (TroelsHenriksen)
08:29:50 <hyperisco> itai33[m], why not  let (x,y) = (1,2)  ?
08:30:29 <itai33[m]> hyperisco: is there a way to fmap over values in tuples?
08:30:50 <itai33[m]> if I remeber correctly fmap only applies to the last element
08:30:55 <hyperisco> you can bimap a 2-tuple
08:31:11 <fog> you would have to make a synonym where all the values were of the same type
08:31:14 <itai33[m]> yeah but I have a 15tupple
08:31:17 <hyperisco> or you can define  data Pair a = Pair a a deriving Functor  let Pair x y = Pair 1 2
08:31:54 <tomsmeding> Athas: and also go futhark :)
08:32:09 <fog> if you only want one version, of a set length, otherwise fixed length lists are the way to go
08:32:33 <fog> which is like defining Pair for any number of them, as specified by the type level Nat param
08:32:44 <itai33[m]> alright
08:32:53 <itai33[m]> this is still very wierd tho
08:33:16 <itai33[m]> like I get how this type of assignement is non exhuastive, but that really only makes sense in the context of say a funciton on  a list
08:33:26 <itai33[m]> not some bunch defining syntactic sugar
08:33:40 <dolio> What you're doing is weird.
08:34:39 <merijn> itai33[m]: I mean, it seems like an awfully niche case to write a special check for
08:35:12 <itai33[m]> dolio: is there a better way to define 15 variables that are essentailly new versions of old variables? I don't want to write the same transformation operator every time, because I will always want to use the new version
08:35:34 <merijn> itai33[m]: What are you actually doing?
08:35:39 <c_wraith> why are there 15?
08:35:53 <c_wraith> It seems like that's a semantic constraint that you're not reflecting in the code
08:35:57 <dolio> I'm skeptical that the 15 new definitions are a good design.
08:36:11 <dolio> But you've barely described what you're doing, including all the stuff yesterday.
08:36:16 <itai33[m]> merijn: is wanting to do batch definitions really that niche?
08:36:39 <merijn> itai33[m]: I mean, I've done this maybe twice in about 10 years of writing Haskell, so...yeah?
08:37:57 <fog> itai33[m]: can you share some code, maybe it would be easy to rewrite in a nice way?
08:38:08 <merijn> itai33[m]: I suspect there's an easier/simpler way to what you want, but you haven't really said what it is, so who knows...
08:39:43 <itai33[m]> merijn: I'm writing an mpd client, and each song has like 15 tags. I want to format each tag in a simillar way, and only really want to deal with the formatted versions. Because of this, I don't want to write `format ($tag song)` every time, and would just rather have a tag function. I will post the code in a pastebin and share a link
08:40:17 <merijn> Sounds like you just want map?
08:40:29 <c_wraith> exactly 15, or "like 15"?
08:40:35 <itai33[m]> 14
08:40:43 <c_wraith> every single one?
08:40:50 <c_wraith> So each tag has its own semantic meaning?
08:41:09 <itai33[m]> https://pastebin.com/dn9Lg2Aj
08:41:13 <itai33[m]> they are just mpd tags
08:41:21 <itai33[m]> c_wraith: 
08:41:39 <itai33[m]> merijn: the thing I'm trying to get away from is writing map every single time
08:42:00 <itai33[m]> maybe that's bad design, I don't know
08:44:04 <c_wraith> here's what I'm trying to get at: is each tag meaningful to your program?  Is it just a mass of tags?  Is it somewhere between?
08:45:23 <fog> seems like you should write a datatype instead of a list
08:45:45 <fog> thats more like the Pair suggestion above
08:46:01 <fog> what is the idea of mapping over these?
08:46:05 <c_wraith> that would be good if each tag is meaningful
08:46:39 <fog> what do you mean? something like adding a Maybe to each of them?
08:46:56 <c_wraith> But if it's just a mass and all the formatting operations don't care about the semantics of the data, then a collection of some sort is appropriate
08:47:16 <itai33[m]> c_wraith: I will want to use individual tags a lot I think, say for displaying x tag of each song in the playlist
08:47:19 * hackage ginger 0.10.1.0 - An implementation of the Jinja2 template language in Haskell  https://hackage.haskell.org/package/ginger-0.10.1.0 (TobiasDammers)
08:47:43 <c_wraith> itai33[m]: that's still not answering the question.  does your code know what tags mean, or is that knowledge outside of your code?
08:47:49 <itai33[m]> fog: the only reason I'm mapping is to essentaily define the function `tag2 = format tag` all at once instead of copy pasting the definition 14 times
08:47:53 <itai33[m]> there is already a Metadata datatype provided by libmpd, but maybe I'm not understanding your meanning
08:48:11 <fog> c_wraith, seems more like they are just text labels really...
08:48:47 <fog> i guess they would transform as such, instead of having to handle the version before they were passed to show
08:48:52 <itai33[m]> c_wraith: I don't understand this question
08:48:54 <itai33[m]> like the trags are mp3 tags
08:48:57 <fog> idk, maybe they have a read instance
08:48:57 <itai33[m]> album, artist, etc. did you guys see the pastebin I posted?
08:49:23 <fog> right, but why do they all have their own datatype? why not just all String
08:50:37 <fog> ah, they are fields of a datatype, they are just sum constructors; https://hackage.haskell.org/package/libmpd-0.9.1.0/docs/src/Network.MPD.Commands.Types.html#Metadata
08:50:51 <itai33[m]> fog: they are all basically a string, the way libmpd reprisents song tags is by having a Map from the tag name to what is essentially a bytestring
08:51:18 <itai33[m]> yeah kind of
08:51:28 <c_wraith> so...  why aren't you representing this as a Map in your program?
08:51:33 <fog> i can see that from your metaLookup function
08:52:50 <itai33[m]> c_wraith: what do you mean?
08:53:18 <c_wraith> Well, some metadata may be absent.  There's no guarantee
08:53:31 <fog> so its these MetaQuery typed functions (eg artist) you are wanting to define
08:53:51 <itai33[m]> c_wraith: yeah thats why the functions return a Maybe
08:53:55 <itai33[m]> there is Map usage internally
08:54:00 <fog> why not just put them at top level instead of in a list like that?
08:54:00 <itai33[m]> fog: yeah
08:54:31 <fog> cant you just not use map over the list, and write it out manually?
08:55:10 <itai33[m]> fog: I can, but this feels like something that I should be able to do
08:55:28 <itai33[m]> like idk this feels like why macros exist
08:55:30 <fog> also, isnt there a way you can enumerate the fields of a sum datatype?
08:55:32 <merijn> itai33[m]: Why not map once over the metadata map in the track and call it a day?
08:56:14 <merijn> Or, why even have separate functions at all? Why not just rename metaLookup to "lookupTag" and leave it as is
08:56:16 <c_wraith> The feeling I get is that your code doesn't care about the tag type, only the value.  So why are you making it complicated by thinking "I need to do this 14 times" instead of "I need to do this for all elements"?
08:56:28 <merijn> Then users can just write "lookupTag Artist", done
08:56:52 <fog> true, they are precisely parametric in the tag
08:57:01 <merijn> I fail to see what convenience having a separate "artist" function adds
08:58:17 <fog> i guess its just sugar
08:58:30 <c_wraith> dunno, seems more like vinegar to me
08:58:33 <fog> but expensive sugar to write
08:58:51 <itai33[m]> merijn: mainly because I find `artist song` to be easier to read than `lookupTag MPD.Artist song`, but maybe I just got stuck in this way of thinking and it's just a detriment
08:59:14 <ph88> do kind constructors exist ?
08:59:44 <itai33[m]> I kind of need to qualify the `MPD` module because there are some name conflicts with other things
08:59:51 <itai33[m]> also this whole thing is going to be a brick tui app eventually, this is primarily for my own ease of reading my own code, which probably makes it less important to be concise of defined well
08:59:54 <c_wraith> ph88: sure, there's (->)
08:59:55 <fog> ph88 GADTs can be used for kinds
08:59:58 <sm[m]> you make it how you like itai33, it's your project :)
09:00:05 <fog> i think thats what datakinds extension if for
09:00:05 <dolio> * and (->) are kind constructors.
09:01:02 <glguy> Sure, but do they *exist*?
09:01:03 <fog> itai33[m]: then rewrite them at top level if all you want to do is supress the warning
09:01:11 <itai33[m]> fog: well yeah, I guess I should just write an ugly block once if there is really no better way to do this
09:01:11 <c_wraith> itai33[m]: if you really want to be magical, write some TH that auto-generates all those helpers based on the Metadata type's constructor list
09:01:48 <c_wraith> itai33[m]: it'll make you feel good
09:02:05 <merijn> itai33[m]: Incidentally, to go way back to your original question of "why does it not recognise this match is complete?"
09:02:38 <merijn> itai33[m]: In your example that would require GHC to derive that 'fmap' doesn't affect the length of the list
09:02:40 <itai33[m]> c_wraith: I was thinking of doing that but if felt like overkill. Also it means I have to learn what template haskell is (I have gathered that it is a way to write macros in haskell?)
09:02:48 <itai33[m]> sm: <3
09:02:56 <merijn> itai33[m]: macros is not really the right way
09:03:08 <c_wraith> itai33[m]: I mean, if you don't want to do it the easy way, do it the really powerful wrong way. :)
09:03:33 <fog> TH is advised!? 
09:03:33 <merijn> itai33[m]: Template Haskell is "compiling and running Haskell that produces the Haskell to actually compile"
09:03:55 <merijn> itai33[m]: So it's "macros, except the language you write the macros in is "all of Haskell""
09:03:58 <itai33[m]> merijn: isn't that kind of like lisp macros?
09:04:10 <merijn> itai33[m]: Maybe, kinda, not quite?
09:04:26 <fog> i guess its good they made a structured way to do that
09:04:29 <merijn> itai33[m]: With lisp it's greyer when things run
09:04:46 <merijn> itai33[m]: Because you can also read and compile arbitrary things at runtime
09:04:57 <merijn> itai33[m]: Haskell has a much harder/stricter phase separation
09:04:58 <fog> but, TH isnt haskell...
09:05:04 <fog> so you cant do it twice
09:05:05 <merijn> fog: Yes it is
09:05:07 <fog> can you?
09:05:09 <c_wraith> TH is definitely haskell
09:05:16 <fog> like, make TH output TH?
09:05:19 <c_wraith> sure
09:05:20 <merijn> fog: Yes
09:05:22 <fog> oh ok
09:05:30 <fog> still, seems like that would be a total mess
09:05:48 <c_wraith> Probably, but the staging restriction means you need to be in another file to use it
09:05:48 <fog> wouldnt it be better to have a way to write programs which write programs in pure haskell without TH?
09:05:59 <c_wraith> Which makes for a nice logical boundary
09:06:00 <merijn> itai33[m]: First you compile the template code, then you run it, outputting an AST of Haskell code. That AST gets spliced into your main program, and then the total result gets compiled
09:06:16 <fog> c_wraith: ah, so a GADT would be better
09:06:20 <itai33[m]> merijn: I see
09:06:29 <fog> maybe GHC exts or something would alow for that
09:06:32 <fog> and AST rather
09:06:38 <fog> an*
09:07:07 <merijn> itai33[m]: But since the Template Haskell code is "just Haskell" it can do literally anything, including IO, running external processes, networking, whatever, there's really no limit. (Compared to, say, C's pitiful macros :p)
09:07:11 <fog> merijn: why not work with the haskell AST directly?
09:07:40 <fog> i guess i should make my function net read in from the AST so you can use TH syntax to construct it... 
09:07:40 <merijn> itai33[m]: I think that actually makes them more powerful than Lisp macro's, because those can really only work on the structure, as far as I understand
09:07:45 <merijn> fog: You can, but it's painful
09:08:08 <fog> i was wanting to use the class interface instead
09:08:10 <merijn> fog: Template Haskell is really just a library for manipulating/reifying the AST and some magic to interact with GHC
09:08:12 <fog> just defining instances...
09:08:25 <fog> like, instance Function ... 
09:08:42 <fog> but i dont have rankNtypes or hardely anything fancy...
09:08:52 <fog> probably not even close to haskell 98
09:09:47 <fog> but then, being able to use full haskell to define the actual functions is useful
09:10:02 <fog> ah, i guess the point is i cant express *all* implementations on the function tree
09:10:32 <fog> there are only a subset of haskell implementations that can actually be unravelled onto the function tree
09:11:01 <fog> i wonder what the next extra functionality would be the easiest to add...
09:11:39 <fog> AllowAmbiguousTypes and TypeApplications is pretty cool
09:12:00 <fog> but i guess the "Class" instance does this...
09:12:19 <fog> that just like let binding with overloading and type matching to retrive the instance
09:12:36 <fog> i cant exactly see how much of haskell fits on these trees...
09:12:52 <itai33[m]> merijn: wow sounds like something I should look into
09:12:53 <itai33[m]> I was kind of under the impression that template haskell was a bit frowned upon tho
09:13:05 <merijn> itai33[m]: It is, to an extent
09:13:11 <merijn> itai33[m]: There's a few reasons
09:13:18 <merijn> itai33[m]: 1) compile time is shite
09:13:26 <merijn> Lots of TH will balloon your compilation times
09:14:03 <merijn> 2) plain TH is "untyped" so it can generate invalid ASTs, which means that after all the effort of generating code you have generated code that doesn't even typecheck and compilation fails
09:14:21 <sm[m]> s/lots of TH/TH that generates lots of slow-to-compile code/
09:14:28 <merijn> (this is alleviated by Typed Template Haskell, which can only generate well typed results without type errors)
09:14:29 <dolio> Macros seem like the appropriate way to do a batch definition.
09:14:42 <dolio> It's just questionable whether a batch definition is appropriate here, I think.
09:14:57 <merijn> 3) Template Haskell's interaction with cross-compilation is ill-specified so it basically doesn't work
09:15:13 <merijn> So, using TH ruins your ability to do cross-compilation, which is kind of a bummer
09:15:55 <merijn> itai33[m]: So it's a trade-off of "does the boiler plate avoidance/convenience outweigh those issues"
09:16:05 <merijn> itai33[m]: And some things just can't be done without TH
09:16:36 <merijn> itai33[m]: For neat abuse of (typed) TH see, for example: https://hackage.haskell.org/package/validated-literals
09:17:07 <fog> hmm, i think the idea i mentioned before, about partitioning up the tree - is then like a local scope like a where block
09:17:24 <merijn> itai33[m]: That lets you safely do compile time partial conversions
09:17:39 <fog> i guess you would only be able to partition it in a way that didnt remove a variable from scope
09:17:55 <fog> shouls be able to do that algorithmically though
09:18:09 <itai33[m]> yeah well here I think the lack of cross compilation is kind of an issue
09:18:10 <sm[m]> maybe also 4) TH tends to be supported last on new platforms, so makes your thing harder to build on non tier 1 platforms. 5) Most added-value dev tools (IDEs etc) don't support TH
09:18:18 <fog> which should give a comonad instance for function trees
09:18:47 <itai33[m]> merijn: that is pretty cool
09:21:01 <fog> i guess extend then would be like, mapping over the implementation to evaluate part of the function, turning it from a tree into a function, and then performing cojoin to repartition it among the rest of the code 
09:21:27 <fog> sounds like a total nightmare 
09:22:11 <fog> especially when you consider that this repartitioning would want to extract common function definitions!
09:22:17 <fog> argh!
09:22:40 <fog> defiantly not something i can do 
09:35:13 <random> hey guys
09:35:50 <random> is there a ready made solution for comparing strings with their cyrillic counterparts
09:36:03 <random> e.g. асдф == asdf -> True
09:36:20 <random> or at least latin to cyrillic translator, I couldn't find any
09:39:39 <davean> random: I just looked and there seem to be a bunch of systems used, none of which match.
09:39:48 <davean> (not in Haskell, in the world)
09:39:56 <random> damn
09:40:01 <random> google does it quite well lol
09:40:13 <davean> wikipedia lists 6 different standards for it
09:40:23 <itai33[m]> random: do you speak russian that you can verify that google does it well?
09:40:27 <davean> I checked and they aren't the same standard
09:40:35 <random> I speak Bulgarian
09:40:49 <itai33[m]> neat
09:40:56 <random> google is very very good at taking your random latin input and matching it to a correct cyrillic representation
09:41:05 <random> it's google of course but now we have a similar case
09:41:09 <davean> random: https://en.wikipedia.org/wiki/Cyrillic_script#Romanization
09:41:20 <davean> random: it would be trivial to make a lookup table based on that
09:41:26 <random> yeah I'll probably do that
09:41:28 <davean> its a oneliner to apply one of those.
09:41:32 <random> actually guys let me tell you our case
09:41:42 <random> we're searching for trips from -> to
09:42:20 <random> so the idea is to take free text and convert it to some sane value with which we could lookup trips in the store
09:42:37 <random> sounds too bad?
09:42:57 <davean> whats a trip?
09:43:09 <random> carpooling
09:43:12 <davean> oh
09:43:25 <davean> huh, and you want to cyrillicize it for that?
09:43:26 <davean> Ok.
09:43:38 <davean> I mean as long as everything is in one form
09:43:46 <davean> I mean you REALLY wnat fuzzy string matching
09:44:15 <davean> so why translate at all, why not make your fuzzy string matching distance aware and use ALL the translation tables as zero distance moves?
09:44:29 <random> I was thinking of doing it with a custom Eq instance
09:44:30 <random> some TripFrom type or whatever
09:44:30 <random> so you could take the free text wrap it in that and compare whether it's a valid value but
09:44:30 <random> it feels fragile
09:44:49 * hackage filestore 0.6.5 - Interface for versioning file stores.  https://hackage.haskell.org/package/filestore-0.6.5 (JohnMacFarlane)
09:45:18 <davean> random: That shouldn't be fragile! Though its not equality, its equivilence.
09:45:31 <davean> random: Really you want a fuzzy string match that returns distance with 0 for equivilency
09:45:38 <davean> and you sort by distance
09:45:46 <random> yes I'll fuzzy match it
09:45:51 <random> awesome, glad that you're on the same page
09:46:12 <davean> random: see like https://en.wikipedia.org/wiki/Levenshtein_distance
09:46:12 <random> so yeah custom Eq instance
09:46:15 <random> 1. convert cyrillic to latin -> fuzzy match
09:46:20 <random> should be good enough
09:46:22 <davean> No see
09:46:31 <davean> I'd do "distance stringA stringB -> Int"
09:46:41 <davean> Eq can't do fuzzy
09:46:46 <davean> Eq does Equality.
09:47:10 <davean> Then you can sortBy with it
09:47:23 <davean> mind you thats CONCEPTUALLY what you want, you'd want an acceleration structure to make it efficient
09:47:39 <davean> You get typo handling and such for free here too
09:47:54 <random> not if you override the semantics lol
09:47:54 <random> *whistles*
09:47:54 <random> that makes perfect sense
09:47:54 <random> you'll just get the closest valid value
09:48:39 <random> damn I get disconnected all the time
09:48:48 <random> davean: thanks!
09:48:52 <monochrom> random disconnections indeed
09:48:59 <davean> random: Right. And I think you specificly want Levenshtein distance or PERHAPS Damerau–Levenshtein distance if you're handling typos specificly
09:49:10 <random> monochrom: lol
09:49:41 <davean> Hamming distance would JUST be the translation directly with 0 distance meaning its a char replacement
09:49:59 <davean> but they're all pretty similar, I think think (D-)L is the best for your case
09:50:24 <davean> Oh, look, the wikipedia article example code is in Haskell
09:50:43 <monochrom> haha excellent
09:51:07 <davean> random: I have no idea how much of this you're missing due to the disconnects.
09:51:35 <random> davean: oh shit, well, all of it I think
09:52:21 <monochrom> The channel "topic" line has a URL to a channel log website. You may be able to recover much there.
09:52:38 <davean> random: well after you're tried it and seen that you like the result this is the basic technique behind spell checkers if you want to impliment a fast version.
09:52:59 <monochrom> But you have to scroll down to the bottom for today's. It's chronological.
09:53:19 <davean> but checking that you like the technique should be under an hour including typing in some translation tables.
09:53:43 <davean> It'll jsut be slow without the acceleration structure
09:53:54 <random_> ..... back again
09:54:13 <random_> davean: sorry if you've messaged and I didn't get it man, I very much appreciate the help
09:54:23 <davean> random_: monochrom was saying theres channel logs linked in the topic
09:54:34 <davean> you may want to review them
09:54:36 <random_> let me check
09:55:16 <random_> yep, got it, thanks!
09:59:36 <random_> hmm maybe this is the incorrect model for where a trip starts from
09:59:45 <random_> text is like, weird for that
10:01:11 <davean> That I can't help you with :-p Geocoding is nice if you can do it.
10:01:29 <random_> yes I was thinking of storing coordinates
10:01:45 <random_> google has a geocoding API
10:01:57 <random_> but then looking up trips would be horror
10:02:51 <davean> How to program something we can help with, what to program is mostly up to you ;)
10:03:24 <random_> oh yeah I'm just thinking out loud or something lol
10:03:58 <davean> fair
10:10:11 <ph88> Can someone help me figure out how this code works ? https://github.com/tdammers/ginger/blob/master/cli/GingerCLI.hs#L41-L44  there is here a single hashmap but somehow the template system can handle nested values like label and url in here https://github.com/tdammers/ginger/blob/master/doc/getting-started.markdown#a-basic-template  
10:15:40 <davean> ph88: I know little about it but toGVal looks suspiciously like the JSON.Value might contain a recursive structure
10:23:04 <ph88> ye
10:23:13 <ph88> though not sure which instance makes thats possible  https://hackage.haskell.org/package/ginger-0.10.1.0/docs/Text-Ginger-GVal.html 
10:24:04 <ph88> oh i think i found it here  https://hackage.haskell.org/package/ginger-0.10.1.0/docs/Text-Ginger-GVal.html#t:ToGVal 
10:25:17 <ph88> the thing is i rather pass in record types than HashMap .. 
10:46:01 <monochrom> OMG GHC 9 pre-release shows up on "ghcup list" now!
10:46:21 * monochrom checks disk space availability
10:48:14 <hyperisco> what's new?
10:49:26 <monochrom> I don't know. I don't know a URL for that.
10:50:19 <merijn> -XLinearHaskell, no?
10:50:29 <monochrom> I think pre-release stuff is usually on GHC-dev-oriented websites (I am not familiar with them) rather than GHC public release websites.
10:50:41 <monochrom> Yeah that one I gathered from here.
10:51:14 <monochrom> Well, alternatively, I could just ask ghcup to download it, then I will have the user guide on my disk :)
10:51:22 <monochrom> but too lazy, as usual.
10:51:50 <monochrom> Yeah in the time and effort of writing all this, I would have finished doing that haha.
10:52:12 <monochrom> But monologuing is more fun than installing.
10:56:43 <fog> is linear haskell something to do with session types?
10:56:50 <monochrom> No.
10:57:42 <fog> https://homepages.inf.ed.ac.uk/wadler/papers/propositions-as-sessions/propositions-as-sessions.pdf
10:57:50 <fog> linear logic correspond to session types
10:58:02 <fog> oh, is that linear logic different to linear types?
10:59:12 <phadej> they are all different takes on same ideas
10:59:13 <fog> linear haskell is to do with making function arrows so that the variables are used exactly once by the function and then can be assumed to be as if they had been removed from scope, right?
10:59:23 <fog> i dont know what is session types though...
10:59:41 <fog> or linear logic...
11:00:56 <fog> or pi calculus 
11:01:54 <fog> any tips? 
11:02:06 <fog> are we supposed to learn about linear logic now?
11:02:25 <phadej> are we supposed to learn about intuitionistic logic to program in Haskell?
11:02:27 <fog> i mean, i can understand linear types, and if they are part of GHC 9 then i should learn about them
11:02:27 <phadej> no.
11:02:42 <phadej> no harm, but not necessary
11:02:47 <fog> it helps teach it though...
11:02:54 <phadej> I doubt
11:03:09 <phadej> the LinearTypes in GHC-9.0 is experimental feature
11:03:19 <fog> understanding proofs by inductions and program evaluation as proof
11:03:20 <phadej> there's even a proposal to tweak a syntax
11:03:34 <fog> yeah we get new function arrows right
11:03:39 <monochrom> Linear logics and linear types are equivalent alright, in the same style as Curry-Howard.
11:03:53 <monochrom> But no one is "supposed" to learn or do anything.
11:04:11 <monochrom> You are now speaking like my students, "do I really have to read this?"
11:04:19 <monochrom> Do you really have to live?
11:04:24 <fog> understanding how linear types can make deadlock free programs or whatever it is
11:04:35 <fog> seems like some learning would help make the most of the new features 
11:04:41 <tomsmeding> for that you can read any sensible introduction to Rust, too :p
11:04:57 <fog> oh, rust has linear types?
11:04:59 <tomsmeding> for the bird's eye view
11:05:02 <yushyin> no
11:05:07 <tomsmeding> I believe it has affine types, technically
11:05:30 <tomsmeding> but as for how linear-like types can help prevent concurrency bugs, rust has that
11:06:09 <tomsmeding> in fact, that's the raison-d'être of Rust :p
11:06:19 <fog> monochrom: its more like, i feel justifiably motivated to learn about the implications of linear types - by the statements "haskell will soon include linear types". but the problem is that im not similarly motivated to learn about session types from the statement "linear logic corresponds to session types" 
11:06:40 <fog> i mean, i feel motivated enough to ask at least, but until i understand it, i cant be sure if its a good thing to understand
11:06:49 <dolio> A lot of linear type systems don't correspond to linear logics in an obvious Curry-Howard way.
11:06:51 <maralorn> sm: I recently told you what fragnix was about. Turns out I was wrong. They don‘t split by Module, they split by toplevel binding. And they aim to replace cabal/stack. There was a Talk about it at HIW 2020 and it's quite interesting.
11:06:52 <hyperisco> what is a session type
11:07:10 <fog> exactly!
11:07:32 <sm[m]> maralorn: cool, thanks. By they way is any of HIW visible on youtube yet ? I couldn't find it
11:07:33 <fog> something to do with a well typedness for comunication paradigms or something
11:07:38 <alehander92> sounds fun
11:07:40 <hyperisco> related to process calculi… well not I am interested
11:07:48 <hyperisco> well now*
11:07:49 <dolio> At least, not the usual presentation of linear logic. There are a lot of different presentations, though.
11:07:53 <maralorn> simonmic: I fear not. But I don‘t know.
11:07:56 <monochrom> Perhaps we should just answer "yes you should learn everything"
11:08:23 <phadej> who is replacing cabal and stack?
11:08:27 <fog> yeah but then there is something to do with competition for finite attention
11:08:30 <tomsmeding> and then you still won't know everything :)
11:08:38 <fog> except regret
11:08:46 <merijn> monochrom: Learning to prioritise things is an important life skill ;)
11:08:54 <sm[m]> phadej: those nix fanatics, of course!
11:09:18 <monochrom> merijn, in this case, that ship has clearly sailed.
11:09:23 <phadej> ah, fragnix, ...
11:09:27 <sm[m]> this is a new sect
11:09:37 <phadej> remind me in few years :)
11:09:45 <fog> the thing that really makes me think i might want to learn about session types, depending on what they are - is if it is good for the "scanner net" idea of streaming through graphs with functions at the nodes
11:09:58 <hyperisco> what is an entry point to session types
11:10:08 <fog> i want to understand how adding changing variables in the local scope of functions can be theoretically addressed
11:10:42 <hyperisco> Hoare Logic
11:10:54 <fog> and i dont want to have to learn what is session types just to understand if they can help explain that
11:10:55 <monochrom> OK, I know the perfect answer.
11:11:11 <hyperisco> everything I have seen is some variation of that
11:11:29 <tomsmeding> monochrom: does it fit in a margin?
11:11:39 <monochrom> You should suspend your current work in maching learning and type-level graphs and whatnot. Shelf them. Switch to learning linear types, linear logics, session types, and session logic.
11:11:52 <fog> hyperisco: whats that?
11:12:03 <hyperisco> whats what
11:12:16 <fog> Hoare Logic
11:12:27 <hyperisco> Wikipedia will do a better job than I
11:12:29 <fog> monochrom: can that be justified? 
11:12:34 <monochrom> Yes.
11:12:35 <dolio> Or just learn linear logics and not session types, because there are other applications of linear logic than session types.
11:12:39 <hyperisco> it is pre and post conditions of program state
11:12:51 <fog> s/can that be justified/how can that be justified
11:13:01 <monochrom> It's more beneficial to #haskell
11:13:12 <fog> how?
11:13:30 <monochrom> We are tired of your AI monologues.
11:13:36 <fog> hyperisco: perfect!
11:13:45 <monochrom> Linear type monologues are at least a small improvement.
11:13:52 <fog> monochrom: i dont want to have to remind you im not an AI
11:14:04 <monochrom> No, I mean your monologues on AI.
11:14:14 <hyperisco> fog, it is a way of formulating operational semantics
11:14:34 <monochrom> No, Hoare logic is an axiomatic semantics.
11:14:39 <phadej> I haven't found any introductionary text on linear logics which I really really liked
11:14:42 <fog> i already changed from tensor nets to function nets for that reason...
11:14:56 <monochrom> We don't want to hear about any nets.
11:14:59 <phadej> the texts are either not introductionary or crap
11:15:23 <fog> well, i was calling them function trees for *that* reason
11:15:43 <monochrom> Doesn't matter. We are still tired of it.
11:15:53 <fog> but thats how you implement functions...
11:16:08 <monochrom> We are users of functions.
11:16:18 <monochrom> Let GHC implement functions.
11:16:40 <fog> its not as if im constantly banging on about universal approximators as a restricted (co)monadic lambda calculus... 
11:16:59 <fog> monochrom: but i want to be able to apply function to implementations
11:17:24 <monochrom> Why are you arguing? You asked for life trade-off advice, I gave life trade-off advice. Take it or leave it.
11:17:53 <fog> fine. i was interested in what hyperisco was saying about programs having a post-evaluation state 
11:18:06 <hyperisco> monochrom, I don't have a useful way of distinguishing them
11:18:17 <monochrom> Well hyperisco could continue if they wish.
11:18:48 <monochrom> hyperisco: With an operational semantics, you can count steps for example.
11:19:25 <monochrom> Hrm no, that isn't a good criterion.
11:19:40 <dolio> Operational semantics isn't a semantics.
11:19:42 <monochrom> Ah OK, I think I know.
11:19:44 <dolio> That's the criterion. :)
11:19:47 <fog> oh right, and i was asking why #haskell would prefer thinking about session types than an implementation of modifiable programs
11:20:00 <fog> and if the answer is "it would make a nice change" then i guess thats fine
11:20:05 <hyperisco> well I guess it is because the examples of Hoare Logic I see are typically so trivial that the distinction is lost
11:20:14 <monochrom> All semantics look the same until you have iteration/recursion and there lies the big difference.
11:20:28 <hyperisco> but an operational semantics is executable, I should think, whereas axiomatic semantics are not
11:20:59 <monochrom> An operational semantics has explicit repetition or even cloning. It says that a loop is defined by running the body once, then "run that loop again".
11:21:05 <fog> so you could count how many times a function had been used, and make the function behave differently based on that?
11:21:18 <hyperisco> in other words, the Hoare Logic examples I've seen are so trivial that the program could be easily inferred, so the distinction seems lost
11:21:26 <monochrom> But neither Hoare logic nor denotational semantics say that.
11:21:59 <fog> is that like the idea of a "stack"? something that used to have to be explicit to do loops, but that modern languages hide under the hood? 
11:22:01 <merijn> Hoare logic is basically "fancy pre and post conditions"
11:22:11 <monochrom> In Hoare logic, "proving a loop correct" is defined by "proving the body preserves the loop invariant you think is a loop invariant".
11:22:24 <monochrom> So it doesn't say "repeat" at all.
11:22:50 <monochrom> In other words a loop is defined by just running the body once and see what happens.
11:23:08 <fog> whats that got to do with "function scope local state variables" ?
11:23:11 <monochrom> So Hoare logic doesn't count as operatinal.
11:23:42 <fog> im not getting how thats to do with proving properties about loops
11:24:17 <fog> except maybe if they are allowd to change type!
11:24:31 <fog> that could make things harder to prove about programs
11:24:39 <hyperisco> dolio, is that just to avoid admitting that everything has semantics?
11:24:55 <monochrom> the name "axiomatic semantics" is rather bland actually, it just means "doesn't look like the other styles, so I'll just call this suite a bunch of ad hoc axioms" :)
11:25:02 <dolio> No, it is a repetition of a critique I heard someone else give.
11:25:48 <hyperisco> it is probably the least useful for analysis, unless it is a Turing machine or something
11:26:11 <dolio> hyperisco: The story is that denotational semanatics is semantics. However, e.g. domain theory failed to satisfactorically account for all the aspects of computation people wanted to think about, so they retreated into just thinking about operation of machines, which isn't semantics, but was branded as such.
11:26:43 <hyperisco> well I haven't a clue what domain theory is so I'll leave it to them :P
11:26:52 <monochrom> That stance kind-of has a point.
11:27:01 <dolio> But possibly the HoTT type stuff can fix that, because higher-dimensional structures are the right mathematical objects to think about all these aspects of computation.
11:27:27 <monochrom> Hrm that may be reason for me to learn HoTT after all.
11:27:47 <fog> it just seems to have descended into a semantic discussion about semantics 
11:28:09 <monochrom> I am interested in both "what answer do you get?" (denotational) and "how much does it cost?" (for now operational does it best).
11:28:17 <fog> and i dont know what they are, so i cant see if its relevant 
11:28:52 <monochrom> It should be possible that a suitable extension of denotational can cover both. At least one can hope.
11:29:00 <fog> i guess its something to do with specifying programs?
11:29:01 <hyperisco> well what do you mean by "semantics" fog?
11:29:08 <dolio> Because that is how you get HoTT falling out naturaly of Martin-löf type theory with just a little extension. The 'identity' types are computationally relevant, and if you don't assume they're trivial by taking a different extra axiom, you can instead add all sorts of 'computations mediation between computations' that give rise to infinite dimensional structure.
11:29:13 <fog> splitting hairs over words
11:29:34 <fog> but maybe im confusing it with syntax
11:29:49 <fog> but i guess programing languages have actually different features
11:30:14 <hyperisco> true
11:30:40 <fog> maybe what im after is something more common in object oriented languages, and i dont know if they have the same foundations in formal language like haskell
11:31:27 <fog> i see mentions of various "type theories" so i guess thats what i mean
11:31:48 <monochrom> But over here (my area) in formal methods for imperative programming, we have figured out an easy way.
11:31:50 <alehander92> i really don't think oop languages have formal foundation
11:31:54 <fog> but objects are like functions that can remember if some of the locally defined variables are changed, right?
11:32:06 <merijn> alehander92: Sure they do
11:32:15 <alehander92> but maybe they do (but i really think many languages just developed in an ad hoc way)
11:32:17 <monochrom> The basic idea is very cheesy. Add ghost variables. It's so cheesy I like it very much. No need to go hi-tech.
11:32:22 <merijn> alehander92: Do you have any idea how many papers you can publish formalising a semantics for popular languages?
11:32:25 <hyperisco> I've lightly read some serious OO papers so I think the rigor is there
11:32:40 <fog> monochrom: what is the way? what are these "ghost variables" ?
11:32:45 <fog> do they have a type theory?
11:32:45 <alehander92> sorry for being unclear: probably one can fomalize this stuff later 
11:32:52 <hyperisco> what is true of most practical languages is they are not so rigorously justified
11:32:58 <monochrom> I did exactly that for my PhD on how to prove lazy evaluation timing.
11:33:16 <alehander92> but my impression was that a lot of the initial work was mostly inspired combination of ideas/ad hoc rules/concepts
11:33:39 <monochrom> And though it is in imperative dressing, the content is very denotational.
11:33:44 <alehander92> like, the smalltalk guys did X, the simula Y etc but i don't think it was *as* formalized as e.g. haskell or coq
11:33:57 <fog> basically when i move to streaming applications i get some place other than top level to store data
11:34:03 <fog> :t mapAccumL
11:34:04 <lambdabot> Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)
11:34:12 <fog> this has a carry, along with the function
11:34:41 <fog> so if i put one of those on every function, as long as its having a stream passed through it, i have a local environment for the functions
11:34:43 <monochrom> Well, closer to algebraic and axiomatic, but not too far from denotational.
11:35:22 <fog> algebraic is the compositionality of the parts right?
11:35:25 <monochrom> No, fog, instead, I have a feeling that ghost variables get rid of the need for type theories.
11:35:30 <fog> "components"
11:35:53 <hyperisco> sorry can you tell me about these ghost variables
11:36:01 <fog> no type theories!? on no!
11:36:29 <monochrom> hyperisco: You still remember you took a look at my supervisors "a practical theory of programming"?  (more next line)
11:36:34 <fog> axiomatic would be to do with canonical specifications?
11:37:03 <monochrom> It adds a ghost variable for "time" so you can state, and then prove, how much time your program takes.
11:37:04 <fog> and denotational would be to do with the adequacy of certain things like analogy in making these specifications
11:37:11 <dolio> monochrom: There is some maybe-less-wild work that captures a lot of different 'semantics'. You do enriched Lawvere theories. Normal Lawvere theories are enriched in Set, and that gives you denotational semantics, because set elements are up-to-equality. So normal Lawvere theories have their syntax quotiented up-to-equality of 'values'. However, if you enrich in preorders instead, you don't need to equate everything with 'the same value'. You can hav
11:37:11 <dolio> e a higher level of ordering that models a reduction relation.
11:37:56 <dolio> And if you enrich in simplicial stuff, you have things that are like lists of individual steps that can be composed together.
11:38:00 <monochrom> It just has the annoyance that you have to remember to "manually" insert "increase t by 1" at crucial places for your proof to mean anything. But we know this can be mechanically done. Or in other words, could be taken care of by a metalogic.
11:38:01 <dolio> Which is like small-step.
11:38:25 <hyperisco> monochrom, yes I was reading it again recently because I am hunting for a method by which I can refine specifications to programs
11:38:55 <monochrom> For lazy evaluation, I added more ghost variables to stand for "how much does the future use the list you produce".
11:39:26 <fog> that sounds more like linear types
11:39:40 <fog> you just make that many copies and have a tuple of that many outputs
11:39:57 <fog> anything more than that is infinite, and so has no be not a linear type
11:40:33 <monochrom> But here are two more incidents that really sold me on ghost variables to replace custom-made logics and types.
11:41:08 <hyperisco> monochrom, I am not sure I agree that there are no types, because it seems like : and ⇐ are somewhat similar
11:41:37 <monochrom> John Reynolds was coming up with a "separation logic" to help reason with heap-allocated objects, specifically how they don't interfere each other unless you have aliasing
11:41:51 <monochrom> It is not easy.
11:42:23 <hyperisco> ghost variables are addressed only in your dissertation?
11:42:56 <fog> its not a ghost dissertation is it?
11:43:04 <monochrom> Then my fellow grad student (Ioannis Kassios if you want to find the thesis) invented ghost variables to express ownership, or non-separation, and did it better.
11:44:41 <fog> this? http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.228.1659&rep=rep1&type=pdf
11:45:06 <monochrom> Another instance is some work by Ernie Cohen, I forgot what, invented another ghost variable to express another invariant that other people tried to express by a logic/type.
11:45:34 <hyperisco> A Theory of Object Oriented Refinement … where do I insert my tax dollars to get a copy
11:46:36 <monochrom> Cohen's so impressive that it impressed Hoare himself, and he said "looks like you can always add more ghost variables to prove more things".  I think he also added "instead of making a new logic" but I'm not sure.  Anyway that's the moment when I realized maybe ghost variables can replace logics.
11:47:37 <fog> and this on dynamic frames; https://doc.rero.ch/record/315975/files/165_2010_Article_152.pdf
11:47:38 <monochrom> fog's finding "dynamic frames" etc would be enough for now, it focuses on that separation/ownership part.
11:48:02 <monochrom> The whole thesis has both OO and, because OO needs separation/ownership, that.
11:48:17 <hyperisco> Modular Verification of Hybrid System Code with VCC
11:48:34 <monochrom> Yeah sounds like that one, but I have really forgotten.
11:49:06 <hyperisco> I couldn't find a copy of your colleague's thesis
11:49:16 <monochrom> OK, I'll see what I can do.
11:52:35 <hyperisco> it seems like Cohen's paper applies ghost variables but doesn't explain the idea
11:53:33 <hyperisco> presented in VCC which I am unfamiliar with
11:58:07 <hyperisco> if Hehner's treatment of time is considered a ghost variable then I think I understand
11:58:22 <monochrom> Yes.
11:59:24 <hyperisco> feels like operational semantics in axiomatic clothing but it does the job
12:00:23 <hyperisco> when you say "type" what are you referring to?
12:03:06 <monochrom> hyperisco: https://www.bac-lac.gc.ca/eng/services/theses/Pages/item.aspx?idNumber=364932825
12:03:25 <hyperisco> I didn't know we had that
12:03:29 <monochrom> :)
12:03:34 <monochrom> I didn't know either.
12:04:35 <monochrom> Until I handed in my thesis and there was a form to sign and agree "You allow Government of Canada to make public a copy"
12:05:15 <hyperisco> I have always regarded "type" as somewhat vague, certainly not as specific as "types are propositions"
12:05:44 <monochrom> I take the stance "types are invariants". This is actually a paper title.
12:05:59 <monochrom> or close to a paper title, but it convinced me
12:06:11 <merijn> "types are propositions" is saying something about the isomorphism between logic and typed lambda calculus, it's not saying something about types
12:06:15 <dminuoso> Types are those things which homotopy theory applies to. :p
12:06:28 <monochrom> haha
12:07:13 <hyperisco> so when you say ghost variables obviate types, are you saying they obviate invariants?
12:07:17 <dolio> "Types are propositions" is how people read "propositions as types" incorrectly.
12:07:47 <monochrom> Perhaps obviate logics instead.
12:08:38 <monochrom> You can express a class of invariants by inventing a new logic, e.g., Reynolds's separation logic.
12:08:39 <hyperisco> it seemed like Hehner's theory was more so a framework upon which logics could be bolted
12:08:48 <hyperisco> but maybe I misunderstood the aesthetic of it
12:09:36 <monochrom> or you can think up suitable ghost variables and how to update them. Then you just write down your invariant in terms of those ghost variables, and stay within vanilla Hoare logic for example.
12:10:01 <hyperisco> and then ghost variables are really just repurposing the Hoare-like logic for program state
12:10:32 <monochrom> Well yes and I and Ioannis bolted on our respective logics, except they don't look like logics (or extensions of logics), they just look like more ghost variables and invariants.
12:12:28 <hyperisco> well I have to look much more closely at it all again… getting into the weeds now
12:18:18 <hyperisco> I like the preface :) I've been practicing unification and decoupling for a while and didn't find those words when I tried to explain it
12:19:19 <monochrom> Kassios's thesis preface?
12:19:33 <monochrom> ah yes
12:20:11 <monochrom> I think it's a tautology. Everyone is doing unification and decoupling already.
12:20:39 <monochrom> The only problem is most people unify wrong targets and decouple wrong targets.
12:21:35 <monochrom> For example remember someone a few days ago tried to argue for optional parameters because "look at most python libraries"?
12:22:30 <koz_> Argumentum ad serpentum? :P
12:22:34 <monochrom> In most cases, one common function name with overloading or optional parameters is precisely unifying wrong targets: what should really be two functions, people unify them.
12:22:56 <koz_> (apologies for my total lack of Latin)
12:23:07 <topos> the arguments of snakes
12:23:21 <hyperisco> that is what type classes are for (snicker)
12:23:22 <monochrom> hahaha I finally get why snakes
12:23:46 <koz_> topos: I'm trying to be 'clever' here, by naming the terrible argument of 'it's good because python' in (faux) Latin. :P
12:24:10 <koz_> If someone actually knows how that ought to be conjugated, I'd appreciate being corrected.
12:24:14 <topos> things are good because of python? I thought everything in python was like a jenga tower of man hours and poor planning
12:24:22 <hyperisco> I think it is a refinement of argumentum ad populum
12:24:25 <koz_> topos: Lots of folks genuinely believe it.
12:24:29 <topos> rofl
12:24:33 <koz_> hyperisco: Yeah, but why spoil the fun?
12:24:44 <monochrom> The opposite also happens. There are APIs that give you two functions, but you find that you have to always call them in the same order, you never really separate them. That's a case of decoupling the wrong targets: the two functions should be unified, but people gave them false decoupling.
12:25:06 <hyperisco> oh I see where that's going lol
12:25:18 <monochrom> To a large extent you also saw me arguing that predicates+selectors is wrong decoupling, pattern matching unifies them.
12:26:13 <monochrom> But Ioannis has done justice to unfication and decoupling. Hehner too.
12:27:15 <koz_> (also, how is it that topos always magically materializes whenever I try to be halfway clever in here?)
12:27:32 <monochrom> They have a select-loop.
12:27:45 <koz_> (this is the second time it's happened in my, frankly leaky, memory)
12:28:07 <monochrom> FD_SET(koz_clever, &read_fd_set);
12:28:07 <hyperisco> monochrom, it is a testament to my intelligence that I knew what you would say before you said it
12:28:10 <koz_> monochrom: So, topos confirmed for async?
12:28:33 <koz_> hyperisco: So you're an oracle for monochrom?
12:28:55 <monochrom> Nah, hyperisco is referring to my IQ definition yesterday.
12:29:05 <topos> I'm always here.
12:29:09 <topos> Watching... judging.
12:29:14 <koz_> topos: Yikes.
12:29:16 <topos> :^)
12:29:46 <koz_> It's like, I'm going about my day, and then I get a popup: 'Topos disliked that.'
12:29:52 <topos> (jk lol i don't read #haskell often it's just coincidence)
12:30:19 <topos> i mean uh... yes. I am the all-seeing haskinati eye
12:30:44 <koz_> The Haskopticon.
12:30:49 <koz_> (which uses lenses of course)
12:31:39 <topos> oo i like that
12:32:10 <triteraflops> oh, that's why you didn't go for Haskelonomicon.
12:32:17 <koz_> Also, Hackage is 503ing for me.
12:32:31 <koz_> triteraflops: If you want that, you can look at the codebases I have to work on.
12:32:33 <triteraflops> maaan, should I actually learn what lenses?
12:32:40 <koz_> (one in particular, naming no names)
12:32:58 <koz_> triteraflops: It's not a bad thing to know, but my experience has been that I don't need them very often.
12:33:08 <koz_> Other folks' mileages certainly vary there, however.
12:33:20 <ph88> when i want to extract something from a GHC.Generics representation do i always have to make a typeclass around it ?? all the examples i see online use a typeclass
12:33:35 <koz_> ph88: Precisely what something do you want to extract?
12:33:44 <koz_> Just manipulation of Reps doesn't need a type class.
12:34:06 <ph88> what kind of manipulation ?
12:35:00 <koz_> ph88: Like, if you just want to, for example, check 'do I have a product here?' or 'does this constructor have this name?' or whatnot.
12:35:20 <koz_> Again, what's your goal here?
12:35:34 <ph88> get record field names and their values
12:35:47 <glguy> You'll almost always have to make a class
12:35:47 <ph88> is the typeclass only for recursive purposes ?
12:35:58 <koz_> You mean Generic?
12:36:11 <koz_> Generic basically says 'I have a canonical representation, and can go from and to it'.
12:36:14 <koz_> That's basically it.
12:36:18 <ph88> going recursively into Rep
12:36:28 <monochrom> If your algorithm is not recursive, you don't need your own class. But this premise is false 99.9% of the time.
12:37:17 <koz_> I don't quite get what you mean ph88. The representation Generic uses as canonical (sum-of-products) is indeed recursive (being a tree), but you can have a Generic full of non-Generic things just fine.
12:37:23 <monochrom> The issue is that you are working with a type family. You almost never know what really hits you. Apart from classes and instances that catch all.
12:38:15 <monochrom> Either that, or you are coding very specializedly for one single target, defeating the whole point of GHC.Generics.
12:39:09 <monochrom> If what I said makes no sense, then you've got to try, then you'll see you run into what I said.
12:39:15 <ph88> data Record1 = Record1 { str1 :: String }    data Record2 = Record2 { str2 :: String, int2 :: Int }   
12:40:22 <ph88> so you need the type class to "type match" on what is in your Rep structure ?
12:40:47 <koz_> Being an instance of Generic gives you two pieces of information about your type:
12:40:57 <koz_> 1) A canonical representation (Rep); and
12:41:02 <koz_> 2) A way of moving to and from it.
12:41:12 <koz_> You can carve up Rep a for whatever a just fine.
12:41:21 <koz_> Provided that a is an instnace of Generic.
12:41:26 <koz_> Type classes don't matter here.
12:41:54 <koz_> Having an instance of Generic for some type a just means 'Rep a is a meaningful thing to talk about'.
12:41:57 <glguy> You need the typeclass if you want to work with an arbitrary Rep
12:42:12 <koz_> Rep's a type family - you can shove whatever 'a' you want in there, doesn't mean it means anything.
12:42:45 <devalot> Is there a portable way to do blocking IO?  I want to read from a handle where the low-level read will return 0 and System.IO and Bytestring.hGet both consider that EOF.  hWaitForInput also returns EOF immediately.  I'm fine with the code not working on Windows, but I want it to at least compile there so it seems using the unix package is out.
12:43:11 <koz_> Why would you want something to _compile_ on a platform, but not _work_ on it?
12:44:00 <devalot> koz_: Because it's just one optional feature.
12:44:17 <devalot> So, windows users can't use that feature.
12:44:51 <koz_> devalot: Then you probably want flags in your Cabal file, and only depend on unix if it's _possible at all_.
12:45:12 <devalot> koz_: Ah, totally forgot I could do that.  Thanks.
12:45:34 <koz_> devalot: No worries - it's not something you need often, but when you need it, you _really_ need it.
12:45:46 <phadej> you don't even need flags
12:45:52 <phadej> if os(windows) ... else ...
12:46:12 <koz_> phadej: What's the proper name for those?
12:46:34 <phadej> https://cabal.readthedocs.io/en/3.4/cabal-package.html?highlight=conditional#conditional-blocks
12:46:45 <koz_> (also, is your handle pronounced 'fa-dedzh' or 'fa-day'?)
12:46:53 <koz_> Ah, conditional blocks. Thanks!
12:46:53 <phadej> Oleg
12:47:06 <koz_> Lol, the Japanese approach to orthography. :P
12:47:34 <koz_> (for names, anyway)
12:49:12 <phadej> That's what you get when you come up with an IRC nickname when you are 15 or so, and it sticks
12:49:46 <koz_> Yeah, it's funny how changing a handle is actually _harder_ than changing your real name.
12:49:54 <koz_> (speaking as someone who's done both, twice)
12:50:16 <phadej> I'm happy, it's quite unique
12:51:33 <phadej> why PhD is pronounced Pee-Ech-Dee, even it's from Philosophy which is Filo...
12:51:37 <phadej> shouldn't it be fido
12:52:14 <phadej> tl;dr better not to try to speak out loud. Typing is fine.
12:52:22 <monochrom> I pronounced SCSI as Es See Es Eye
12:52:37 <koz_> monochrom: And I guess it's also Ess Queue Ell?
12:52:45 <monochrom> I still pronounce PCMCIA as Pee See Em See Eye Eh
12:52:49 <monochrom> Yes
12:52:58 <phadej> :)
12:52:59 <dolio> Because it's just reading the letters.
12:53:00 <koz_> What about Pee See Eye Eee?
12:53:14 <koz_> (spelling out out like that reads funny)
12:53:19 <monochrom> I don't know PCIC
12:53:33 <koz_> PCIe?
12:53:35 <monochrom> But I know Tee See El Tee Kay
12:53:46 <phadej> mandatory mention https://blog.xkcd.com/2009/09/02/urinal-protocol-vulnerability/
12:53:49 <monochrom> Oh oops, misread, yeah.
12:54:24 <koz_> phadej: Truly there is an xkcd (adjacent thing) for every occasion.
12:55:41 <phadej> yeah, the creator is making the world much more bearable place
12:56:33 <phadej> I probably should by his book or two
12:56:39 <phadej> buy*
12:56:54 <koz_> Yeah, throwing him some money might not be a bad idea in general.
12:56:57 <koz_> (whatever way)
12:59:02 <itai33[m]> when I have a `newtype A = A Int` is there a standard way to extract the int?
12:59:18 <koz_> itai33[m]: Pattern matching.
12:59:31 <koz_> So like foo (A theIntIWant) = ...
13:00:08 <merijn> itai33[m]: Define it using record syntax and use that?
13:00:18 <koz_> You can also use coerce if the constructor's in scope, but you might have to give GHC a helping hand with the type inference.
13:00:23 <merijn> itai33[m]: "newtype A = A { getA :: Int }"
13:00:31 <dminuoso> coerce is likely the worst idea :p
13:00:38 <koz_> dminuoso: I never suggested otherwise.
13:00:43 <merijn> dminuoso: That's literally what coerce was designed for
13:01:02 <itai33[m]> merijn: I didn't define it unfortunately
13:01:02 <koz_> (as someone who DerivingVias almost as much as Iceland Jack)
13:01:09 <itai33[m]> I guess pattern matching it is
13:01:46 <dminuoso> merijn: I just dont think it's a very useful tool in general because it doesn't clearly communicate what you do.
13:02:01 <dminuoso> And since its so polymorphic, it's easy to use it in the wrong place and violate all your type safety.
13:02:20 <dolio> I think coerce was designed for more interesting cases.
13:02:23 <merijn> dminuoso: How does it violate your type safety?
13:02:33 <dminuoso> merijn: The type safety you used newtypes for in the first place!
13:02:44 <merijn> dminuoso: It only works if the constructor is in scope
13:02:48 <koz_> Type _safety_ is actually fairly tricky to violate with coerce - if you can do it with coerce, you can do it with other ways as well.
13:02:52 <dminuoso> If you specifically pattern match or use `unFoo`, then you're limiting the coercsion to just this particular combination.
13:02:57 <merijn> dminuoso: So it only works for newtypes that export their constructor anyway
13:03:00 <koz_> The biggest gripe I have with coerce is that it turns type inference to custard.
13:03:08 <dminuoso> merijn: You misunderstand what Im saying.
13:03:15 <dminuoso> Say `f (coerce x) y` vs `f x (coerce y)`. 
13:03:30 <merijn> koz_: meh, I don't care for inference too much :p
13:03:48 <dminuoso> Also, with coerce you can cross any possible boundary without this being clear or desirable
13:04:08 <koz_> merijn: It's a bit aggravating to me, especially in situations where it _should_ be obvious, but isn't. I get why it's _not_ obvious in said situations, but it still bugs me.
13:04:09 <merijn> dminuoso: But you can't
13:04:12 <dminuoso> with `unFoo` I only get `Foo -> Int`, but with coerce I might get `Foo -> Int`, `Foo -> Bar`, `Foo -> Quux`, all at the same time
13:04:30 <dminuoso> And if type inference doesnt work out right, it can do the unexpected/wrong thing.
13:04:47 <dminuoso> So, if you used type annotated coerce, then that's fine.
13:04:57 <koz_> dminuoso: You nearly always have to, I find.
13:05:00 <jle`> coerce @A @Int
13:05:01 <koz_> (hence my gripe above)
13:05:04 <phadej> as I see it, coerce is not meant to be used directly, but to be a (very efficient) implementation of combinators
13:05:24 <phadej> e.g. in DerivingVia you don't ever see coerce
13:05:30 <jle`> % newtype A = A Int
13:05:30 <yahb> jle`: 
13:05:32 <phadej> even*
13:05:40 <jle`> % coerce @A @Int (A 3)
13:05:40 <yahb> jle`: 3
13:06:20 <koz_> % coerce @A @(Sum Int) (A 3)
13:06:20 <yahb> koz_: Sum {getSum = 3}
13:06:25 <phadej> from reading perspective unannotated coerce is nightmare, even if type-inference works :)
13:06:33 <koz_> % coerce @A @(Sum (Down Int)) (A 3)
13:06:33 <yahb> koz_: Sum {getSum = Down 3}
13:06:41 <koz_> :D
13:06:56 <phadej> there are few coerce's in `lens` e.g. where you really have to think what the types it is instantiated to
13:07:18 <phadej> ... which doesn't really matter in lens case, as there is unique thing it can be
13:07:27 <koz_> phadej: Clearly my coerce game is weak. I basically only ever use it for newtype unwrapping/rewrapping.
13:07:59 <jle`> i think the original purpose of coerce was for performance hacks, but it has since expanded pretty far beyond that in normal haskellture
13:08:20 <phadej> it's still performance hack
13:08:49 <dolio> Using it in cases where it doesn't get you any performance seems like it's just going to annoy you.
13:08:49 <phadej> sometimes it's also convenience hack. E.g. unwrapping multiple levels of newtypes around and inside types
13:08:50 <jle`> the deriving via stuff is arguably an expansion of the scope for which it was originally designed
13:09:20 <phadej> :t coerce :: Compose f [] Int -> [Int]
13:09:21 <koz_> jle`: I see DerivingVia as less an expansion on coerce, and more an expansion on GND.
13:09:22 <lambdabot> error:
13:09:22 <lambdabot>     Not in scope: type constructor or class ‘Compose’
13:09:27 <phadej> % :t coerce :: Compose f [] Int -> [Int]
13:09:27 <yahb> phadej: ; <interactive>:1:11: error: Not in scope: type constructor or class `Compose'
13:09:33 <koz_> The fact it _uses_ coerce is an implementation detail.
13:09:38 <phadej> % :t coerce :: Data.Functor.Compose f [] Int -> [Int]
13:09:38 <yahb> phadej: ; <interactive>:1:11: error:; Not in scope: type constructor or class `Data.Functor.Compose'; No module named `Data.Functor' is imported.
13:09:41 <phadej> :(
13:09:48 <phadej> % :t coerce :: Data.Functor.Compose.Compose f [] Int -> [Int]
13:09:48 <yahb> phadej: ; <interactive>:1:1: error:; * Couldn't match representation of type `Data.Functor.Compose.Compose f1 [] Int' with that of `[Int]' arising from a use of `coerce'; The data constructor `Data.Functor.Compose.Compose' of newtype `Data.Functor.Compose.Compose' is not in scope; * In the expression: coerce :: Data.Functor.Compose.Compose f [] Int -> [Int]
13:09:55 <jle`> yeah, it's using coerce in a way that was different from its original design
13:10:02 <phadej> ah, doesn't work if f is variable :/
13:10:07 <jle`> :\
13:10:08 <phadej> jle`: not really
13:10:11 <dminuoso> coerce is essentially cool for tricks like
13:10:13 <dminuoso> % :t ala
13:10:13 <yahb> dminuoso: (Functor f, Rewrapped s t, Rewrapped t s) => (Unwrapped s -> s) -> ((Unwrapped t -> t) -> f s) -> f (Unwrapped s)
13:10:35 <dminuoso> Though.. that particular one doesnt use it? Mmm
13:10:42 <koz_> dminuoso: There are many definitions of this.
13:10:52 <koz_> The one you're thinking of is old coercible-utils.
13:10:55 <dminuoso> Right
13:11:03 <koz_> (the new one tones it down rather a lot)
13:11:21 <phadej> jle`: DerivingVia is essentialyl GND, just with a configurable "from what to coerce"
13:11:33 <phadej> quite elegant extension
13:12:32 <phadej> anyway, for small scale wrapping/unwrapping, IMO, the explicit constructors/selectors is more readable
13:12:48 <phadej> I'd reach for coerce only when in cases like
13:13:01 <jle`> there it's using Coercible as a mechanism to safely figure out what types are runtime-compatible in order to do typeclass dispatch.  slightly different than its original urpose of safely figuring out what types are runtime-compatible in order to do unsafeCoerce
13:13:01 <phadej> % :t coerce :: [Down Int] -> [Int]
13:13:02 <yahb> phadej: [Down Int] -> [Int]
13:14:11 <phadej> jle`: Coercible (and roles) was introduced to fix GND
13:14:32 <phadej> GND was using unsafeCoerce before, and because it was GND it was known that it's safe to use
13:14:51 <phadej> the fact that coerce is usable more generally came later
13:14:55 <jle`> ah, so maybe i have my history mixed up? 
13:15:20 <jle`> i seem to remember coerce coming out to be able to do things like a safe unsafeCoerce for [Down Int] -> [Int]
13:15:27 <jle`> to save the traversal
13:15:44 <phadej> it's all i nthe same paper
13:15:57 <phadej> 7. Generalized Newtype Deriving done right in https://www.seas.upenn.edu/~sweirich/papers/coercible.pdf
13:15:59 <jle`> i have imposed my own historicity D:
13:16:19 <jle`> i didn't realize it all happened at once
13:17:04 <phadej> 7.8 was big release
13:18:11 <phadej> patternsynonyms, coercible and roles, ghctypelits, autoderivetypeable...
13:18:21 <phadej> EmptyCase
13:19:08 <phadej> if 7.8 had AMP in it, it would been 8.0
13:19:18 <phadej> (AMP came in 7.10)
13:20:44 <phadej> (autoderivetypeable IIRC includes polykinded Typeable, which is massive)
13:27:43 <c_wraith> Typeable was a huge pain before it became polykinded
13:50:38 <ADG1089> how can I write my own code formatter like brittany or ormolu, i know i can use some libraries to parse syntax trees, but what after that
13:51:27 <dminuoso> ADG1089: What code do you want to format?
13:51:28 <dminuoso> Haskell code?
13:51:40 <ADG1089> possibly haskell
13:51:48 <ADG1089> but additionally python, rust, etc. too
13:51:52 <dminuoso> ADG1089: If its haskell, just use haskell-src-exts
13:51:59 <ADG1089> okay
13:52:12 <dminuoso> It's what all the other formatting tools use. :)
13:52:42 <Rembane> ADG1089: tree-sitter might be helpful too https://github.com/tree-sitter/tree-sitter
13:56:49 * hackage launchdarkly-server-sdk 2.0.1 - Server-side SDK for integrating with LaunchDarkly  https://hackage.haskell.org/package/launchdarkly-server-sdk-2.0.1 (launchdarkly)
13:57:25 <dminuoso> ADG1089: Ohh, you asked about "after that", sorry.
13:57:36 <dminuoso> ADG1089: `prettyprinter` is a good first step. :)
13:58:45 <dminuoso> haskell-src-exts has its own haskell specific version of it, but it doesnt seem very customizable. And it only works for haskell
14:25:03 <dminuoso> merijn: You named a library the other day for doing byte order conversions of base types. Which was that?
14:25:28 <merijn> cpu? I think?
14:28:37 <dminuoso> Yeah looks right. Cheers
15:24:39 <Graypup_> Hi! can I directly stuff some package's record into my Yesod models? It basically just needs to be stored verbatim in the database and seems silly to redefine it in my models and unwrap/rewrap it myself
15:24:52 <Graypup_> it's made of Strings and Text lol
15:26:18 * hackage safe-json 1.1.1 - Automatic JSON format versioning  https://hackage.haskell.org/package/safe-json-1.1.1 (nideco)
15:29:33 <dminuoso> Graypup_: Whats wrong with just using mkPersist to generate the boilerplate?
15:32:14 <Graypup_> dminuoso, perhaps I don't know how to use it super well? I have a config/models file with a bunch of such declarations, but I don't know how to hook it up so it generates the boilerplate for *someone else*'s record
15:32:31 <Graypup_> I assume you probably can, but I don't know what the syntax is
15:34:49 <dminuoso> Ohh no, mkPersist also creates a data type
15:35:27 <mac> Hi Guys! Can anybody point me in the right direction? I am trying to write a function that will get back an IO (String, String) and I did it with a do block...but it kind of looks weird. There has to be a nice way? 
15:35:50 <dminuoso> Graypup_: It should be enough to write an instance for PersistEntity
15:36:00 <Graypup_> hmm ok, I'll look into that!
15:36:20 <dminuoso> Graypup_: There's probably some kind of TH helper for that.
15:36:33 <koala_man> mac: how does it look now?
15:37:08 <mac> readDirectionAndCommand :: IO (String, String)readDirectionAndCommand = do  direction <- getLine  command <- getLine  return (direction, command)
15:37:09 <mac> oh sry, maybe there is a better way to quite code here?
15:37:44 <Graypup_> dminuoso, yeah it looks like it wouldn't be fun to write one of those and I might just as well convert it in client code
15:37:50 <dminuoso> Graypup_: Check out derivePersistField
15:37:58 <dminuoso> That is at least for a field
15:37:58 <mac> I am kinda trying to do the mars rover kata (if you have heard of it) in Haskell 
15:38:09 <mac> figured it might be a good exercise :)  
15:39:16 <mac> I know I can also use the bind operator with lambdas, but that looks even worse to me :(  
15:39:29 <dminuoso> Graypup_: Or maybe just mkPersist and create a new type, and just match between those?
15:43:41 <monochrom> mac: please see below
15:43:46 <monochrom> @where paste
15:43:46 <lambdabot> Help us help you: at https://hastebin.com please paste full code, input, and output.
15:45:08 <Graypup_> mac, replicateM ?
15:45:35 <monochrom> replicateM is unnecessary.
15:46:41 <mac> https://hastebin.com/jozavivudu.bash
15:47:13 <mmaruseacph2> mac: what is the mars rover kata?
15:47:26 <monochrom> mac, it is already good.
15:47:36 <mac> its just a fun way of learning new stuff :)  
15:47:43 <mac> mostly it is used to teach TDD 
15:48:55 <mmaruseacph2> oh, it's not the codingame puzzle
15:49:02 <mac> https://kata-log.rocks/mars-rover-kata
15:49:09 <mmaruseacph2> thanks for the link
15:49:45 <mac> there might be more versions of it... I met it at a TDD training that was done in Java at a bank :)  
15:50:20 <mac> but I figured since it has state and commands, but the domain itself is easy it might be a good way of learning Haskell :)  
15:51:02 <mac> what bugs me now is how to get that IO (String, String) point free style
15:51:16 <mmaruseacph2> the one in codingame is actually about a mars lander, you receive location of rover, orientation, current_speed, and land and need to output change in thrust and orientation
15:51:24 <mmaruseacph2> and have to land as economically as possible
15:52:14 <mac> mmaruseacph2 that sounds way more advanced :)  
15:52:29 <monochrom> No, don't try to be pointfree.
15:52:34 <nij> help..! I'm on arch, and I removed xmonad from pacman, and installed one with `cabal install`. Now it doesn't recompile.. complaining for lacking of dependencies: https://dpaste.com/GQV4KH9EX . I did use `pacman xmonad-contrib` to get extra packages for my config to work.. but I don't know how to in the cabal setting.
15:52:40 <koala_man> mac: dunno, liftM2 (,) getLine getLine
15:53:19 <nij> The command I used was `xmonad --recompile`. How to you `:set -package xmonad` for example in this case?
15:53:34 <mac> monochrom why not? I do not see the point (pun intended) of creating all these intermediate pointers
15:54:22 <monochrom> anti perfection OCD
15:56:19 <Graypup_> this is what I ended up writing (sorry for screenshot of code)
15:56:19 <Graypup_> https://i.imgur.com/jdugaCa.png
15:57:32 <solonarv> mac: this does not create any extra intermediate pointers (and that way of thinking is too low-level anyway unless you are really trying to squeeze for performance)
15:58:21 <Graypup_> point free is usually bad IMO for readability reasons, of course, depending on if your parameter name would have had any meaning to begin with
15:58:41 <mac> solonarv I know that do notation is just sugar over binds... what bugs me is that the code is ugly
15:58:46 <mac> what do I need these names for? 
15:59:03 <Graypup_> conveying meaning to the actual user of the code, the next person reading it ^^
15:59:27 <monochrom> Use de Bruijn numbering if you don't like names.
15:59:30 <solonarv> it isn't particularly ugly, just a bit verbose
15:59:31 <mac> even in Java I do most stuff nowadays without value references (for instance using function references) 
15:59:45 <solonarv> you can write 'liftA2 (,) getLine getLine' for the point-free variant
16:00:03 <solonarv> which in this case is also decently readable IMO, but not necessarily *better*
16:00:05 <dminuoso> monochrom: You seem to have your de Burijn week.
16:00:18 <dminuoso> Every day or so, you keep bringing it up to "the solution to the problem at hand"
16:00:25 <dminuoso> Do you get a provision for every customer?
16:00:27 <monochrom> At least it's better than "how do I get rid of parentheses"
16:00:40 <glguy> ^ backspace
16:01:25 <glguy> monochrom: It's closely related: name everything
16:01:52 <monochrom> I think I don't understand.
16:03:35 <glguy> don't need parentheses if you name all the subexpressions
16:03:45 <monochrom> Oh, that.
16:03:46 <glguy> (and the topic is losely naming things)
16:04:18 <dminuoso> glguy: Indeed! It's amazing how much of "$ vs pointfree" hassle seems better solved by just adding more bindings.
16:04:30 <dolio> Yeah, all code should be written in A normal form, so that "GHC's job is easier".
16:04:34 <dminuoso> Code becomes more modular, readable and maintainable.
16:05:11 <dminuoso> Also, you can properly document it better
16:05:34 <monochrom> Use de Bruijn numbering with let/where so you have neither parentheses nor names.
16:06:12 <nij> --- By the way, another example of liftA2:
16:06:16 <nij> Prelude Control.Applicative> import Control.Applicative
16:06:16 <nij> Prelude Control.Applicative> f = \x -> x+1
16:06:16 <nij> Prelude Control.Applicative> g = \x -> 2*x
16:06:16 <nij> Prelude Control.Applicative> (++) = liftA2 (+)
16:06:16 <nij> Prelude Control.Applicative> (f ++ g) 3
16:06:32 <monochrom> As for better documentation... You should have two distinct newtypes over your two Strings.
16:09:16 <nij> Anyone familiar with cabal :O ?
16:09:45 <monochrom> Yes but not its interaction with xmonad.
16:09:55 <nij> Oh..
16:10:29 <dansho> Yes but not its interaction with pacman.
16:12:17 <nij> dansho: I'm ditching pacman, so fortunately that's not relevant :)
16:13:07 <nij> I want to use cabal, but `cabal install xmonad` gives me an xmonad that complains lack of dependencies :(
16:18:40 <sm[m]> Doesn't xmonad's docs cover it nil ? If not you should open a bug
16:19:20 <dolio> Can you paste the error message somewhere?
16:20:04 <nij> dolio: I pasted in dpaste, should I do it in another site?
16:20:46 <nij> sm[m]: i don't think so. I think this is not a bug either.. just have to understand how cabal works.
16:21:43 <sm[m]> xmonad has an unusual way of configuring itself, it's their job to tell xmonad users how to do it and avoid such common problems
16:22:03 <dolio> Is it the paste earlier about import problems?
16:22:26 <nij> dolio: I can post it again https://dpaste.com/GQV4KH9EX
16:22:45 <sm[m]> Not that you can't try to get help here too, I think it's just not efficient for #haskell to field support for everything built in Haskell
16:22:56 <nij> sm[m]: Even cabal's doc was not up to date explaining that v2 style is the new standard  :( I don't really expect much from the doc :((
16:23:30 <nij> sm[m]: I see.. that makes sense! I think this is more like a cabal problem. Maybe I should go to #cabal
16:24:03 <sm[m]> I can understand that, cabals doc was pretty misleading (try it now). But again this is more xmonads job not cabals
16:24:29 <dolio> This is the output you get when running `cabal install xmonad`?
16:24:36 <sm[m]> I'm just guessing/opining. Carry on!
16:25:47 <dolio> Because it looks like error messages within ghci or something
16:26:13 <nij> dolio: No, it's the output when I run `xmonad --recompile`
16:26:38 <nij> Everytime you configure xmonad, you change its source code in `~/.xmonad/Main.hs`.
16:26:56 <nij> And then you run `xmonad --recompile`, which will look into that source code and recompile the binary.
16:26:57 <dolio> That doesn't sound like a cabal problem, then.
16:27:14 <nij> It will use `ghc` to compile.
16:27:31 <nij> Well, both `ghc` and `xmonad` are installed by `cabal`.
16:27:54 <nij> so while xmonad calls ghc, ghc looks for dependencies under `~/.cabal`.
16:28:27 <nij> Usually in a cabal project, you open a directory, `cabal init` it, and declare packages you want to use in a `.cabal` file.
16:28:57 <nij> But now `xmonad` is installed directly.. and there is no project directory. I have no `.cabal` file to declare which dependencies I want to call.
16:29:06 <dolio> The only way I can imagine it being cabal related is that xmonad assumes that it's installed using what is now v1-install.
16:29:20 <dolio> And everything it depends on, for that matter.
16:31:28 <nij> I use v2-install, and that's why it usually requires users to declare dependencies in a `.cabal` file.
16:31:59 <nij> v2-install is like the nix-way, which asks you to declare dependencies (aka packages you want to use) in each project. 
16:33:57 <dolio> Well, I don't know what `xmonad --recompile` does. If it assumes that you have a bunch of stuff v1-installed, then v2-installing it might not work.
16:34:04 <dolio> Regardless of what you'd like to do.
16:35:56 <solonarv> v2-installing libraries works and might be the solution
16:36:05 <solonarv> (I recommend using a separate package env for xmonad)
16:36:32 <dolio> The error messages don't even look like the libraries aren't installed, because the error messages say what packages they're from.
16:36:48 <dolio> It looks like whatever `xmonad --recompile` is doing isn't exposing the right libraries.
16:37:18 <solonarv> yes I don't know exactly what xmonad --recompile does
16:38:14 <sm[m]> xmonad docs don't mention any of this, it just had not kept up with cabal
16:38:21 <sm[m]> has not
16:38:57 <sm[m]> and there's no issue, so you'd be helping out by creating it
16:40:16 <nij> sm[m]: Yes lemme file it up
16:40:41 <nij> I just found an issue whose title was not suggesting me to look into in the first place.. actually trying what it suggests
16:40:52 <nij> it's still open though: https://github.com/xmonad/xmonad/issues/199
16:41:01 <nij> (Has been almost a year ;) )
17:24:11 <L29Ah> is it possible to ask ghc not to generate accessor functions from record data type definitions?
17:30:46 <rotaerk> L29Ah, isn't that the whole point of records?
17:30:59 <rotaerk> why not just not use record syntax
17:33:07 <yushyin> guess NoFieldSelectors is not yet part of any ghc release?
17:33:41 <yushyin> L29Ah: should be possible in the near feature the proposal was accepted
17:34:19 <yushyin> L29Ah: https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0160-no-toplevel-field-selectors.rst
17:36:21 <yushyin> L29Ah: Future*, sorry I'm on my phone ;)
17:51:16 <yushyin> rotaerk: the proposal lists some motivation, if you are interested
17:52:07 <rotaerk> hmm thanks
17:53:02 <rotaerk> I see... so field names available for matching and construction, but not accessing...
18:50:18 * hackage primal 0.1.0.0 - Primeval world of Haskell.  https://hackage.haskell.org/package/primal-0.1.0.0 (lehins)
18:51:19 * hackage primal-memory 0.1.0.0 - Unified interface for memory managemenet.  https://hackage.haskell.org/package/primal-memory-0.1.0.0 (lehins)
18:59:32 <hyiltiz> Failing to build bhoogle into the global cabal env https://paste.tomsmeding.com/xC7k8lv7 even tho I updated cabal
18:59:52 <hyiltiz> anything else to try, or I just stop trying and install it into its local dir?
19:03:55 <hyiltiz> Also failed when building inside a project https://paste.tomsmeding.com/PHP97nlp
19:29:57 <triteraflops> There should be an impossible-to-understand linear typing library called Linear A
19:31:01 <MarcelineVQ> idgi
19:32:25 <monochrom> I don't I don't understand "Linear A"
19:34:41 <MarcelineVQ> On the plus side if you ever get an A you understoor Linear exactly once.
19:35:37 <monochrom> hahaha
19:41:47 <int-e> linear knowledge is a well-known phenomenon... when people study for an exam and instantly forget afterwards :-/
19:42:18 <monochrom> My students, they instantly forget even before the exam begins.
19:44:01 <int-e> Well, affine linear knowledge then.
19:44:29 <monochrom> No, I have a simpler model.
19:44:50 <monochrom> /dev/null logic for my course material.  /dev/urandom for their answers.
19:45:27 <monochrom> In fact it gets better. /dev/null logic too for the exam questions.
19:45:37 <int-e> !random
19:46:26 <monochrom> Like the question says "do this to all files in the current directory". They answer "for i in "$@" "
19:46:32 <monochrom> (in shell scripts)
19:47:42 <monochrom> To be sure, I also have students solving it perfectly. Some even beautifully written code.
19:48:44 <int-e> eww, what do you want... for i in .* *; do if [[ -f "$i" ]]; then ...; fi; done?
19:49:13 <monochrom> Nah don't worry about dot files.  Just "for i in *" will do.
19:49:26 <int-e> so sloppy
19:50:35 <monochrom> Even without "[ -f "$i" ]" is OK. That's negligble compared to the blatant misconceptions they show.
19:51:00 <monochrom> "misconceptions" doesn't do it justice. Make it "fantasy".
19:52:34 <monochrom> My question further says, "using A1.tex and A1.pdf for example: under condition xxx, run 'pdflatex A1.tex', this will update A1.pdf"
19:52:58 <monochrom> They gave me "touch "$v.pdf" "
19:53:26 <monochrom> or " cat "$thetex" > "$thepdf" "
19:54:30 <monochrom> Oh here is the best part.
19:55:09 <monochrom> I said "there is a program called pdflatex". So this means it's given, you are the user, not implementer.
19:55:51 <monochrom> Other parts of the question also says "write a shell script so the protagonist of this question can run your shell script'.  This means not a shell function, right?
19:56:07 <monochrom> The students made it a shell function. Moreover, the name is "pdflatex".
19:57:39 <monochrom> So, what is a little "for i in *" compared to totally reading my question backwards?
20:03:38 <solonarv> explaining the 'Linear A' joke: there is an ancient language that hasn't been deciphered yet and that is the name it's been given
20:04:52 <monochrom> Haha thanks.
20:11:25 <monochrom> OK I played a pun on a student.
20:12:04 <monochrom> TCP socket server assignment.  Write a server that sends blah-blah to the client (when the client sends a command to request it.)
20:12:36 <monochrom> This student's bug is sending extra NUL bytes before blah-blah. Not after.
20:13:55 <monochrom> I told the student this observation. The student thought their mistake was in internal storage of blah-blah near the end.
20:14:23 <monochrom> The student told me how to fix their code, but it only fixed the end.
20:15:10 <monochrom> They even have an index variable called "end" and they were saying the fix involved "myarray[end] = '\0'" or something.
20:15:21 <monochrom> So my reply: "No. You're looking at the wrong end."
20:20:09 <monochrom> The real bug: Context: I wrote "don't let SIGPIPE kill your server".
20:20:38 <monochrom> Student's solution: send a NUL byte to probe the client to see if it's still connected, before sending real data.
20:21:06 <monochrom> That still doesn't explain it all because as time goes by, longer NUL prefixes are sent.
20:21:54 <MarcelineVQ> Well, you know how conversations go, you start slow and kind of feel it. If you start to strong you might burst pipes
20:22:06 <monochrom> hahaha
20:23:19 <MarcelineVQ> actually I'm somewhat dreading having to learn that stuff
20:24:03 <MarcelineVQ> All the little errors and corners of process communication
20:24:12 <int-e> monochrom: <mean>I'd ask what they were thinking, but I'm afraid that would assume too much.</mean>
20:24:17 <MarcelineVQ> process/socket/computer
20:25:42 <glguy> writing network/socket programs is fussy business
20:27:46 <int-e> But... sending 0 bytes...
20:28:28 <int-e> . o O ( Haskell would not save you this time. )
20:28:38 <monochrom> Like, what's the rush? If you send the real data, write()'s return value will tell you that the connection is gone. Why probe first?
20:29:12 <monochrom> I am less and less sympathetic to "I worked very hard for this assignment".
20:29:18 <int-e> Because that was the top answer on stackoverflow?
20:29:27 <MarcelineVQ> monochrom: you just don't understand how hard it is to stay with your data limits
20:29:46 <int-e> MarcelineVQ: ...
20:29:50 <MarcelineVQ> I can't be sending messages that don't get there!
20:30:00 * MarcelineVQ rubs index and thumb
20:30:11 <monochrom> If you over-engineer this thing and add this extra junk code, of course you're working too hard. Doesn't mean you're right.
20:30:21 <int-e> ...packet headers...
20:51:44 <glguy> monochrom: I'm guessing the sockets assignments are in C, is that right?
22:15:23 <dminuoso> % 277 :: Word8
22:15:23 <yahb> dminuoso: ; <interactive>:162:1: warning: [-Woverflowed-literals] Literal 277 is out of the Word8 range 0..255; 21
22:15:29 <dminuoso> What does this even do to produce 21?
22:16:07 <monochrom> glguy: Yeah, it's a C-and-unix course.
22:16:25 <Cale> > 277 - 256
22:16:26 <lambdabot>  21
22:16:37 <dminuoso> Oh.
22:16:42 <monochrom> > 227 .&. 255
22:16:44 <lambdabot>  227
22:16:46 <dminuoso> Haha, I kept testing with 221 against 21.
22:17:08 <dminuoso> > 277 .&. 255
22:17:10 <lambdabot>  21
22:17:14 <dminuoso> This you meant, right monochrom?
22:17:23 <monochrom> Oh haha we are kings of typos.
22:17:36 <monochrom> Math is hard. Let's go shopping.
22:17:52 <dminuoso> haha indeed
22:19:10 <dminuoso> hvr_: Im thinking int-cast should have: intSqueeze intCast :: (Integral a, Integral b, IsNotSubType a b ~ True) => a -> b 
23:31:12 <hyiltiz> % (<|>) <$> [Just 3, Just 14] <*> [Nothing, Just 15, Nothing]
23:31:12 <yahb> hyiltiz: [Just 3,Just 3,Just 3,Just 14,Just 14,Just 14]
23:32:21 <hyiltiz> % [x<|>y | x<-[Just 3, Just 14], y<-[Nothing, Just 15, Nothing]]
23:32:21 <yahb> hyiltiz: [Just 3,Just 3,Just 3,Just 14,Just 14,Just 14]
23:32:37 <hyiltiz> Stylewise, do folks prefer the first or the second?
23:33:59 <MarcelineVQ> I like  liftA2 (<|>)
23:34:09 <triteraflops> (Linear A is an ancient writing system that has yet to be deciphered.)
23:48:06 <hyiltiz> I kinda dont like the explicit numbers at the end of liftAn
