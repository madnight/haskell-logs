01:10:05 --- mode: ChanServ set +o Sigyn
01:15:19 * hackage http-client 0.7.2 - An HTTP client engine  https://hackage.haskell.org/package/http-client-0.7.2 (MichaelSnoyman)
01:42:22 <maier> Is there a way I can get cabal-install to list me all the used dependencies with their respective versions? Since I'm using nix to manage them, maybe there'd be a way to use that, too. Or perhaps this is something I'd need to leverage the library Cabal for?
01:43:08 <merijn> Possibly "cabal freeze", but I have no clue how that interacts with Nix setups
01:43:40 <merijn> afaict the solution to all problems of the shape "...and I'm using Nix" is "pray to god someone else has already fixed this for you"
01:44:35 <maier> merijn: I can confirm that
01:45:20 <maier> merijn: although in this case, the Nix backend is just something "on top". I'd still like to get a dependency tree or a list from "just" cabal-install :)
01:46:35 <maier> merijn: thanks for the freeze hint though, it seems to do the trick and I had already skipped over this command in the documentation!
01:49:15 <merijn> maier: The problem is that there is no "*the* dependency tree", because a cabal file specifies a graph with many possible solutions (and more might appear over time), so there's no real way to compute *the* tree. Freeze just gives you "the exact solution you happen to be using now"
01:49:49 <merijn> maier: And I don't think Nix can meaningfully handle anything other than explicitly fixed versions?
01:57:42 <maier> merijn: With nix, you usually get a fixed set of dependencies, similar to stackage, but there is the possibility to "make different versions of a package into different packages"
01:58:39 <maier> But yes, freeze is exactly what I want then! Nix gives a "ghc with a set of packages in fixed versions", and freeze can only return exactly those :)
02:03:24 <Arahael> Nix is basically stack.
02:03:33 <Arahael> (Everything is curated)
02:08:36 <maerwald> Nix is using stackage you mean
02:08:45 <maerwald> not much else is similar
02:10:37 <lambdaclan> Is there a way to update all packages via cabal after updating GHC to a new version? (sorry pretty new to Haskell scene).
02:11:16 <merijn> lambdaclan: That question is unanswerable as you're making some flawed assumptions to begin with :)
02:11:45 <merijn> lambdaclan: are you using stack or cabal-install?
02:12:54 <lambdaclan> I guess is too early to look into setup automations 
02:13:06 <lambdaclan> I have no idea how packages work in Haskell 
02:13:20 <lambdaclan> I use ghcup and cabal install
02:13:27 <maerwald> lambdaclan: cabal update
02:13:37 <merijn> maerwald: That doesn't update packages, it only updates the index
02:13:43 <maerwald> I now
02:13:58 <merijn> I'm assuming they're coming from a python/JS background with their utterly broken packaging system :p
02:14:06 <maerwald> lambdaclan: after cabal update, if you rebuild a project, it will update dependencies usually
02:14:15 <lambdaclan> Let us say I use GHC 8.8.3 and installed flint via cabal install
02:14:25 <merijn> lambdaclan: GHC has a package database, but there's a unique one per GHC version
02:14:35 <maerwald> lambdaclan: cabal update && cabal install flint
02:14:37 <merijn> lambdaclan: So different GHC version never see packages installed with another version
02:15:10 <merijn> lambdaclan: Moreover, with cabal-install all packages are installed into a global store that can have multiple different (even conflicting) versions of packages installed
02:15:16 <lambdaclan> Good to know merijn that's helpful 
02:15:53 <merijn> lambdaclan: cabal-install when building one your packages/project computes a single consistent set of dependencies for your projects and uses those. Any missing one are automatically added to the global store as needed
02:16:32 <merijn> lambdaclan: So in practice there's never a need to "update your package", you just work on your code and when you change the bounds on your dependencies, it will just install the new things "as needed"
02:16:53 <maerwald> not without cabal update
02:16:56 <lambdaclan> OK so if I understand correctly each time I upgrade GHC I need to.reinstall all.packages via cabal?
02:17:03 <merijn> lambdaclan: Yeah
02:17:12 <lambdaclan> Cool
02:17:15 <merijn> maerwald: Even without cabal update if you relax a bound
02:17:23 <maerwald> if it's in the index
02:17:29 <maerwald> you should run cabal update.
02:17:37 <merijn> lambdaclan: in ~/.cabal/store (on *nix, anyway) you will see global stores for each GHC version
02:17:54 <maerwald> lambdaclan: run `cabal update` :)
02:18:00 <merijn> lambdaclan: the workflow for GCing them is currently a bit...ad hoc and underdeveloped
02:18:17 <lambdaclan> Then if I do cabal install hlint no need to check for updates to hlint after sometime for example? 
02:18:21 <merijn> maerwald: Sure, you should cabal update, but that's tangential to what's being asked
02:18:26 <maerwald> no
02:18:44 <merijn> lambdaclan: It doesn't automatically update executables, no
02:18:48 <maerwald> you run cabal update, rebuild a project... that's how you update dependencies
02:18:59 <maerwald> that was the question
02:19:11 <lambdaclan> OK makes sense 
02:19:24 <lambdaclan> Currently working without a project just CLI 
02:20:16 <merijn> lambdaclan: Personally I tend to just nuke the subdirs in ~/.cabal/store like once or twice a year to free up space and get rid of unused packages, which is probably the easiest solution until a better "package GC" comes along
02:20:51 <lambdaclan> A good workaround I guess 
02:21:29 <maerwald> for GC try https://github.com/phadej/cabal-extras#cabal-store-gc
02:21:37 <lambdaclan> Thanks for the help everyone. Will read a bit more on the topic and will be back with more questions 😃
02:38:19 * hackage darcs 2.16.2 - a distributed, interactive, smart revision control system  https://hackage.haskell.org/package/darcs-2.16.2 (bfrk)
02:40:04 <raichoo> Oh, another darcs update \o/
03:18:03 <mirrorbird> why doesn't this work? :/ parMapM (\x -> 1) [1,2,3]
03:21:38 <polyphem> mirrorbird: your lambda isnt a moadic action
03:23:01 <mirrorbird> guess i need to learn haskell first
03:25:13 <polyphem> mirrorbird: functionnames with "M" as last letter work on actions rather than functions
03:26:36 <mirrorbird> well i have this signature
03:26:37 <mirrorbird> parReduce :: NFData a => (a -> a -> a) -> [a] -> Par a
03:26:46 <mirrorbird> i don't get how to get the return value as Par
03:26:56 <mirrorbird> (practice on old exam :/)
03:27:25 <polyphem> you pass it a lamda (a -> Int) it expects an acton (a  -> M a) where M is somekind of effect/context
03:28:05 <polyphem> (\x -> return 1)
03:28:15 <mirrorbird> oh O_o
03:28:16 <polyphem> :t return
03:28:17 <lambdabot> Monad m => a -> m a
03:28:26 <mirrorbird> because i did an assignment where i solved a similar thing, and it was months ago, and i forgot :/
03:28:29 <mirrorbird> ah.
03:28:36 <mirrorbird> thanks
03:28:46 <polyphem> return wraps it up in your "M"
03:29:08 <mirrorbird> yeah, well i tried to put return in there somewhere. just didn't get it right.
03:29:14 <mirrorbird> oh i remember. i needed the edge case. that was the problem
03:29:20 <mirrorbird> i'll try again. i should have asked sooner. i feel so relieved
03:29:42 <mirrorbird> def need to read a book i guess
03:32:23 <mirrorbird> parReduce f [a] = return a   -- called with parReduce (\x -> x) [1] just to test
03:32:30 <mirrorbird> Occurs check: cannot construct the infinite type: a ~ a -> a
03:32:40 <mirrorbird> i need to define a function with a signature?
03:36:34 <polyphem> oh, you try to implement parReduce with the given signature ...
03:37:20 <mirrorbird> yeah
03:37:29 <polyphem> its a foldl1 returning a Par action result
03:38:19 <polyphem> a is NFDate it means it can be deepseq'ed i.e fully evaluated all the way down
03:40:01 <polyphem> you have to deconstruct the list (3 cases) combine the elements with your f , and "return" the deepseq'd result to wrap it up in Par
03:41:26 <polyphem> have to go now, sorry , happy hacking :)
03:41:31 <mirrorbird> thanks
03:59:04 <ph88> How can i inspect json values with aeson ? the inspecting functions are not safe but can error   https://hackage.haskell.org/package/aeson-1.5.3.0/docs/Data-Aeson.html#g:20 
04:06:51 <Cale> Just case on Value?
05:13:00 <ph88> got it Cale thank you :)
05:14:13 <ph88> is there a good data structure to model a many-to-many relation ? on the relation i need to set one property as well
05:15:13 <juri_> model it as a many->one->many relation?
05:15:43 <ph88> example (about movies and users, real case is different): a movie is owned by many users, a user has many movies. And i want to set in which order a specific user got a specific movie.
05:16:36 <ph88> the problem is that if i have for example   data Relation = Relation User Movie Int   that i can't modify a specific Movie and it will change for all users
05:21:22 <ph88> I remember vaguely two years ago i asked about this but in the end didn't program it. I think at that time the recommendation was http://hackage.haskell.org/package/ixset but i like some fresh ideas
05:22:21 <lortabac> ph88: replace Movie by MovieId
05:25:55 <ph88> thanks lortabac  i will try
05:26:24 <lortabac> ph88: of course, this implies that you have a movie database/ixset/map somewhere
05:26:48 <ph88> maybe i dont need ixset
05:27:02 <ph88> [Movie] could be enough
05:27:43 <lortabac> if you have lots of movies, looking them up by index is slow
05:29:11 <ph88> i guess i could put them in a hashset later ... but i don't have that many actually
05:29:17 <stites[m]> Is there a good .bib parser that folks can recommend? All I see is https://hackage.haskell.org/package/bibtex but the core type: https://hackage.haskell.org/package/bibtex-0.1.0.6/docs/Text-BibTeX-Entry.html seems like it was made in a hurry
05:31:23 <stites[m]> Sorry, by "bib parser" I really meant "bibtex representation" -- I'm very slowly trying to do my own reference management
05:33:05 <alehander92> hey
05:33:12 <alehander92> does t.text make sense for compilators
05:33:38 <alehander92> it seems to me, just a list of (unicode) characters is what's usually needed for better pattern matching (e.g. for lexers)
05:42:19 <merijn> A good datastructure for many-to-many relationships is called a relational database :p
05:46:59 <stites[m]> Scratch that, I just looked up the spec for Bibtex -- it's a little more structured than the hackage package, but not by much.
05:48:36 <merijn> This does not surprise me at all :p
06:00:19 <zmagii> Probably biased to ask here, but does Haskell have good libraries for NNs?
06:02:01 <zmagii> I was reading Milewski's book on category theory and Haskell and thought it may be worthwhile to combine it with writing code for neural networks. Not that I particularly like NNs... But would it be better to write in Python?
06:06:12 <ph88> is there some fold function where i have the memory of the last element ? or should i just build that myself with an accumulator ?
06:06:28 <efm> I've heard back from cocalc, and they had someone help them set up haskell on ubuntu18 before, and that person wrote a script to do the setup, but that script no longer works on Ubuntu20, so they're asking for community help again to get it set up. 
06:15:31 <tomsmeding> efm: how complicated is that setup? how much of ghcup doesn't work?
06:15:50 <tomsmeding> (it's not even windows!)
06:17:47 <ph88> I have seconds in Word64 and i like to use this function https://hackage.haskell.org/package/time-1.10/docs/Data-Time-Clock.html#v:secondsToNominalDiffTime  how do i go from Word64 to Data.Fixed.Pico ??
06:17:58 <hc> wom 25
06:18:01 <hc> argh, sry
06:20:16 <ph88> was that your password ?
06:20:38 <efm> tomsmeding: I don't know, can I pm you their contact info?
06:21:30 <tomsmeding> I can spend an hour or so, but not much more perhaps; is that useful? :)
06:21:41 <tomsmeding> (if so, by all means)
06:22:22 <efm> ok
06:26:20 <lortabac> ph88: regarding the fold, I'm pretty sure there is some *morphism that does that (histomorphism?), but it's probably easier to implement it with explicit recursion
06:37:59 <AWizzArd> I read the first page of https://www.microsoft.com/en-us/research/uploads/prod/2017/12/linear-haskell-popl18-with-appendices.pdf and there it seems that they contrast linear typing with Rust’s ownership typing. So, IS ownership typing a kind of linear typing?
06:43:29 <merijn> AWizzArd: Yes
06:56:41 <stites[m]> zmagii: NNs in haskell is a bit of a funny thing. Haskell has some excellent libraries for simple NNs and it's not terribly hard to roll your own for learning. One good example of a successful project written in haskell and used by many is dextrify https://detexify.kirelabs.org/classify.html -- I believe that author wrote a tutorial as well. There are maybe a couple more but not much. Justin Le has an excellent tutorial
06:56:41 <stites[m]> here for his library, backprop: https://blog.jle.im/entry/purely-functional-typed-models-1.html (which is used for backprop-learn) and for more building blocks, there is, of course, linear and ad from kmett on hackage.
06:56:41 <stites[m]> That said, if you want to do any contemporary deep learning things get a little more hairy. Of the ones that I believe are still maintained, there are tensorflow bindings and libtorch bindings (disclaimer: I wrote the first version of hasktorch, there is also haskell-torch) -- I think grenade is no longer maintained but someone wrote a successor.
06:57:26 <AWizzArd> In the new Linear Haskell we need to place a `#` in front of the function arrow to introduce linearity. Why is this manual step needed? Why can’t the compiler see that a parameter is used exactly once and infer that it can use the #-> here?
06:58:57 <merijn> AWizzArd: Because what if an argument is used once, but not supposed to be linear?
06:59:11 <merijn> AWizzArd: making something linear isn't always better
06:59:19 <solonarv> (perhaps it is passed to another function that uses it in a non-linear fashion, for example)
07:00:11 <stites[m]> zmagii: sorry, using matrix for the first time to connect to IRC -- not sure if I tagged you above or a mangled matrix username ^^^
07:01:05 <AWizzArd> Okay I see. Passing it to some other (non-lin) FN is exactly one use in the body, yet we can't detect for sure that the the callee will ignore it.
07:01:13 <solonarv> stites[m]: the mention/"tag" worked fine.
07:01:57 <stites[m]> cool!
07:02:55 <kqr> This is probably not the right place to ask but I'll go anyway. I'm planning to hold a short (20ish minutes tops) presentation on functional programming for a small group of people who have dipped their toes in it, but mainly written "impertive code in a functional language." I plan on focusing this initial session on composition, first of pure functions, and then with the Maybe type as a more powerful
07:02:57 <kqr> example. These people are looking for practical tips on how to "think functionally" to improve their own code and make more efficient use of the standard libraries. Does focusing on composition make sense? The alternative I'm seeing would be to talk a bit about designing type-first, and how algebraic structures can inform type design. While that would also be a great topic to cover, I'm thinking it might be
07:02:59 <kqr> better as a separate session, since it doesn't provide all that much of a parctical guide to understanding how functional code is written differently from imperative code.
07:04:30 <merijn> kqr: I think a focus on ADTs is nice, because conceptually, the could easily apply in a non-functional language
07:04:36 <zmagii> stites[m]: Thanks. I did see the tag.
07:04:42 <merijn> I'm actually quite baffled why Rust is the only imperative language with ADTs
07:04:53 <kqr> Followup question: if I'm going to do the composition thing with the Maybe type, I'm considering two alternatives to bringing up the Maybe type: either as a sum type OR church encoded. the former might be more practically applicable. the latter has the benefit that one only technically needs to know how functions work to understand it, and it might have more of a "wow functions can suffice to do so many
07:04:55 <kqr> things my mind is blown" effect...
07:05:27 <alehander92> merijn nim also used variants (which can basically represent adt-s) a lot
07:05:38 <kqr> merijn, does your opinion not change from knowing that these people have indicated they're interested in becoming better at reading/writing code in functional languages specifically?
07:05:38 <zmagii> stites[m]: Someone asked for help with a recurrent NN and I was thinking of doing it in Haskell, since NNs are boring for me. You know, trying to spice things up.
07:06:18 <zmagii> And I've been putting off coding something in Haskell and now a bit more up for it.
07:06:45 <merijn> kqr: Well, I think ADTs are pretty much crucial and one of the best things ever, so I think they're important regardless ;)
07:07:00 <merijn> kqr: But, recursive ADTs are a good tool for talking about recursive solutions too
07:07:14 <stites[m]> zmagii: Check out https://github.com/hasktorch/hasktorch/tree/master/examples/rnn
07:07:31 <zmagii> I've actually used detexify.
07:07:44 <zmagii> It's pretty good at some symbols.
07:08:12 <zmagii> stites[m]: Cool, thanks for the link!
07:08:13 <stites[m]> zmagii: another perspective: https://mstksg.github.io/backprop-learn/Backprop-Learn-Model-Neural-LSTM.html
07:08:42 <kqr> merijn, when you're saying ADTs are pretty much crucial and one of the best things ever, are you talking about the ability of the language to express sum types as well as product types?
07:09:02 <lortabac> kqr: in my experience church encoding is more likely to bore people than blowing their minds
07:09:04 <merijn> kqr: and mixing those, yeah
07:09:46 <lortabac> of course it depends on your audience
07:09:51 <merijn> kqr: Also, you can easily take ADTs from "almost nothing" to "here's an elaborate recursive solution on trees that's hard to work out in imperative languages" in 20 minutes
07:10:03 <merijn> I mean, 20 minutes is *short*
07:10:33 <kqr> 20 minutes is incredibly short. it's a freshly started internal training programme where I work, and this is hopefully just the first session out of many, depending on how it's received.
07:13:23 <zmagii> stites[m]: Do you know of links with reinforment learning?
07:13:29 <zmagii> *reinforcement
07:13:49 <solonarv> merijn: well, C++17 has std::optional and std::variant, but I don't know how easy it is to make your own ADTs
07:14:01 <kqr> merijn, I like where you're going with ADTs, and I would like to share your vision but I'm not quite seeing it. in my mind, ADTs fall short due to ending up on the wrong side of the expression problem. I frequently want the number of cases to be extensible, and then I'm back at regular functions instead of sum types again. I've only really seen sum types used successfully in production code for very
07:14:03 <kqr> basic/low-level things like Maybe or trees. the other uses I've found have been rather academic in nature, at best. what am I missing?
07:15:08 <merijn> kqr: What kinda code do you write that having the cases extensible is such a frequent occurence?
07:17:20 <AWizzArd> So when we have:   foo :: Int #-> String -> Char     then what has to be used exactly once in the body? The Int or the String?
07:17:33 <AWizzArd> (pls don’t say Char)
07:18:37 <kqr> merijn, printing (encoding), parsing (tokens), searching (match types), and interpreting (commands) are some examples, but I can think of more. almost everything that has more than one or two options tends to have an infinite number of options once someone starts asking for them, in my experience
07:19:05 <kqr> AWizzArd, Does it help to know that a string is a list of chars?
07:19:58 <AWizzArd> kqr: I know this and that’s why I invented this type signature so that it could pratically make sense. But where is the linearity, in which argument?
07:20:01 <merijn> kqr: Not when he's asking about linear haskell ;)
07:20:11 <AWizzArd> merijn: yeah
07:20:13 <kqr> oh, never mind! sorry
07:20:23 <merijn> kqr: Those sound like problems that can be solved by writing more parametric code, tbh
07:21:59 <kqr> merijn, if I understand what you mean, then yes. and this is also why I relatively rarely find any use for sum types other than in the most basic/low-level situations. I'm not arguing ADTs are bad – they are a given fundamental thing. I'm just saying I'd have trouble convincing this crowd that "you'll use these things a lot going forward" because they'll quickly find themselves on the wrong end of the
07:22:01 <kqr> expression problem if they try
07:22:13 <merijn> kqr: tbh, the expression problem is fun when I play with interpreter style things or playing with abstractions, but if I look at the *practical* stuff I write in Haskell it's never once been relevant, tbh
07:22:54 <kqr> It sounds like whenever you need to add or remove a case, you do it on the corresponding ADT and then have the compiler guide you to all the locations where you'd need to modify the operations to include/remove the case there as well?
07:23:14 <merijn> kqr: I'd say the focus of ADTs should be on things like "making illegal states irrepresentible", that's a common problem in imperative languages
07:23:24 <kqr> Yes! That's a good point.
07:23:28 <merijn> kqr: Pretty much, but in the grand scheme of things that's not usually a lot of work
07:23:47 <merijn> kqr: I mean, doing the same in C++ is often orders of magnitude more painful
07:23:52 <kqr> Yeah, no, it's not, I agree. Not with the help of the compiler, anyway, which is more powerful with ADT support in the language than otherwise.
07:24:10 <AWizzArd> merijn: I would say that the Int can be used exactly once. Do you agree?
07:24:13 <merijn> kqr: Like, usually the ADT stuff needs to be updated in like 5-10 places and the compiler points all of them out
07:24:19 <kqr> Indeed.
07:24:26 <merijn> AWizzArd: I've not read anything about linear haskell, so I have no clue :)
07:25:11 <kqr> I just have a suspicion that these people are already familiar enough with the concept of ADTs and making illegal states irrepresentable to make it seem too boring. (They're pretty good at adopting the same principles in their imperative language of choice.)
07:25:22 <kqr> Not boring, but at least not useful.
07:25:32 <merijn> kqr: oh, actually
07:25:43 <merijn> kqr: Did you see the "haskell patterns" post earlier this week?
07:25:55 <kqr> I did!
07:26:01 <kqr> Let me find it
07:26:01 <merijn> kqr: I think picking a few of those and going over them is about as much as you can manage in 20 minutes
07:26:11 <merijn> And those are very practical/applicable
07:26:11 <kqr> This one? https://kowainik.github.io/posts/haskell-mini-patterns
07:26:14 <merijn> yeah
07:26:20 <wz1000> Is there any way to write: absurd :: (Int ~ Bool) => Void?
07:27:26 <kqr> This is crazy. I'm getting so many ideas for things I would like to introduce (like reasoning algebraically about ADTs to find isomorphisms) but that I'll have to reserve a separate session for...
07:28:24 <tomsmeding> AWizzArd: I _think_ that the Int can be used one if the returned (String -> Char) closure is used once, but don't hold me to it
07:30:44 <tomsmeding> s/used one/used once/
07:38:21 <hyiltiz> Hython left comprehension unimplemented. Seems quite unexpected given it is usually referred to as the first feature that is similar between the two.
07:39:33 <merijn> hyiltiz: That doesn't make it easy to implement
07:39:49 <merijn> Especially since python list comprehensions don't behave remotely like Haskell's
07:42:10 <hyiltiz> It is wire impressive python the language is just 2k lines of Haskell. 
07:42:41 <merijn> Python's fairly easy, once you've got mutable dictionaries that's like 95% of the feature set ;)
07:42:56 <merijn> The rest is ad hoc syntax to mutate various dictionaries :p
07:44:43 <kqr> That sounds very Lisp-like yet not at all
07:45:00 <merijn> nah
07:45:08 <merijn> Lisp is when it's all mutable lists
08:44:49 * hackage musicw 0.3.5.2 - Sound synthesis library, to be used with GHCJS and Web Audio API  https://hackage.haskell.org/package/musicw-0.3.5.2 (dktr0)
09:15:19 * hackage yesod-auth-oauth2 0.6.1.3 - OAuth 2.0 authentication plugins  https://hackage.haskell.org/package/yesod-auth-oauth2-0.6.1.3 (PatrickBrisbin)
09:37:16 <stites[m]> zmagii: RL without NNs is simple enough that you just need to pick up Barto and Sutton, which was originally written in perl 
09:40:12 <monochrom> <3 haskell
09:40:37 <stites[m]> Unfortunately all of the nice things in RL are very hard to get in Haskell. OpenAI's gym is a PITA to interface with. I think there are two efforts documented in the DataHaskell Gitter account since I last worked on haskell+rl. If you just need something like frozenlake and cartpole I have some abandonware which might still work: https://github.com/Sentenai/reinforce
09:42:06 <monochrom> I think it took me a minute to recognize the context and see RL = reinforcement learning, not real life :)
09:42:41 <monochrom> almost started commenting "what nice things in real life? they exist?" :)
09:45:28 <stites[m]> zmagii: The big problem with RL is that it is simple enough to get to approximation methods running and then you are a stone's throw away from Deep function approximators, so at that point you'd like to get tensors up and running.
09:50:23 <stites[m]> monochrom: haha, yes: the only nice things extracted from IO and siphoned into an ADT are acceptable
09:50:40 <monochrom> :)
09:52:32 <stites[m]> zmagii: anyhow, yeah, at that point you either want to move to accelerate, dip your toe in one of the bindings libraries, or pacify yourself with HMatrix's static API.
09:59:05 <sshine> hyiltiz, the 2k lines could probably be reduced a lot if you want a smallest possible implementation.
10:26:10 <zmagii> stites[m]: What do you mean tensors? As in tensors in a category?
10:39:19 <monochrom> Perhaps as in tensor-flow given the machine learning context.
10:46:18 <remexre> what's the least..... weird postgresql library? like, something like diesel.rs' functional query builder and FromSql/ToSql would be all I'd want
10:46:39 <remexre> vs in the snippets I've seen, persistent's template haskell dsl kinda sketches me out
10:46:59 <remexre> and I don't like having to replace all my fields with opaleye
10:48:40 <lodek> I have a newbie question. Say `f` is a function f :: String -> (String, Integer); `g` is a function g :: String -> Integer -> Bool. `g` and `f` are called in `h`, which is a long chain of functions composed together (d . e ... g . f). I'd like to apply the return of `f` over `g`, but since `f` returns a pair, I can't. I could use a `let` or a `where` in the definition of `h`, but is there a better
10:48:42 <lodek> way?
10:49:23 <stites[m]> zmagii: I just mean multidimensional arrays
10:54:49 * hackage boolector 0.0.0.13 - Haskell bindings for the Boolector SMT solver  https://hackage.haskell.org/package/boolector-0.0.0.13 (DeianStefan)
10:55:10 <hekkaidekapus> lodek: uncurry g . f
10:56:17 <lodek> hekkaidekapus: Thank you! I'll read about it 
10:56:30 <hekkaidekapus> np
11:05:25 <hekkaidekapus> lodek: There’s a search engine called hoogle—https://hoogle.haskell.org—to which you can feed type signatures.
11:05:38 <hekkaidekapus> For instance: (a -> b -> c) -> (a, b) -> c
11:07:49 * hackage debug-me 1.20200820 - secure remote debugging  https://hackage.haskell.org/package/debug-me-1.20200820 (JoeyHess)
11:08:07 <lodek> hekkaidekapus: That will be extremely helpful. I felt like my problem was common enough, but I haven't built the vocabulary to know what to search for yet. Thank you for the suggestion.
11:18:00 <iWantToKeepAnon> Hello all, first time poster. Let me know if this needs to go to #haskell-beginners.  I am working the 7languages in 7weeks haskell homework on day3. Namely write a hash lookup using the Maybe monad. I can bind several calls, but once I hit a Nothing return any more binds fails. I distilled it down to a simpler case and I can bind over and over after hitting a Nothing case.
11:18:01 <iWantToKeepAnon> Source code here https://pastebin.com/s8M2yNLg
11:18:33 <iWantToKeepAnon> My question is why my bind "chain" of lookups fail.  See comment in the source.
11:24:23 <pmikkelsen2> hey
11:24:59 <iWantToKeepAnon> yes
11:26:49 * hackage hascard 0.3.0.0 - A TUI for reviewing notes using 'flashcards' written with markdown-like syntax.  https://hackage.haskell.org/package/hascard-0.3.0.0 (Yvee1)
11:35:21 <sm[m]> hello iWantToKeepAnon, what do you want the code to do ?
11:46:50 * hackage shake-dhall 0.1.1.0 - Dhall dependencies  https://hackage.haskell.org/package/shake-dhall-0.1.1.0 (vmchale)
11:54:29 <hekkaidekapus> sm[m]: Hi, what they want might be what is in the header of the pastebin.
11:54:50 <hekkaidekapus> iWantToKeepAnon: Are you gone?
12:10:26 <lordgrenville> @pl \x -> take (succ $ length x) $ cycle x
12:10:26 <lambdabot> ap (take . succ . length) cycle
12:18:37 <monochrom> This is the next level of depravity. Now [(Key, Value)] is a hash table.
12:18:41 <lordgrenville> hmm.. (take . succ . length) cycle yields an error
12:18:59 <monochrom> [X] is an array type, [(X,Y)] is a hash table type. This is just great.
12:19:18 <lordgrenville> No instance for (Foldable ((->) [a0])) arising from a use of ‘length’
12:19:44 <edwardk> lordgrenville: not sure what you are trying to accomplish
12:20:01 <dminuoso> hyperisco: So I watched another talk from conal, this time explaining denotational semantics using an image manipulation library. And I think Im beginning to get the idea.
12:20:29 <edwardk> length there will bottom so take will never return
12:20:29 <hyperisco> dminuoso, great :)
12:20:51 <monochrom> lordgrenville: You're probably missing the "ap" at the beginning
12:21:06 <edwardk> oh
12:21:13 <edwardk> not length of the cycle
12:21:18 <edwardk> length of the original string
12:21:27 <edwardk> > ap (take . succ . length) cycle "hello"
12:21:29 <lambdabot>  "helloh"
12:21:39 <edwardk> > tail $ ap (take . succ . length) cycle "hello"
12:21:41 <lambdabot>  "elloh"
12:22:27 <dminuoso> % let f s = foldr (:) [head s] s in f "foo"
12:22:27 <yahb> dminuoso: "foof"
12:22:31 <oats> wooooohoooooo prebuilt binaries of haskell-language-server
12:22:37 <lordgrenville> monochrom oh that's it, thanks
12:22:39 <oats> haskell goin' to the moon
12:23:07 <edwardk> > (\xs -> xs ++ [head xs]) "foo"
12:23:08 <lambdabot>  "foof"
12:23:48 <lordgrenville> edwardk ah that's much better!
12:24:20 <dminuoso> It sadly is just unsafe
12:24:34 <dminuoso> Im thinking we can concat something with listToMaybe instead of head
12:24:38 <dminuoso> *concoct
12:24:51 <monochrom> cycle is unsafe to begin with
12:25:14 <edwardk> > (\xs -> zipWith (const id) (undefined:xs) (cycle xs)) "hello"
12:25:16 <lambdabot>  "helloh"
12:25:19 <oats> > cycle "foo"
12:25:21 <lambdabot>  "foofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoo...
12:25:27 <oats> nice going lambdabot
12:25:28 <edwardk> has the benefit that it works even in the infinit4 case
12:25:43 <dminuoso> % (\xs -> xs <> maybeToList (listToMaybe xs)) "foo"
12:25:43 <yahb> dminuoso: "foof"
12:26:03 <edwardk> > (\xs -> zipWith (const id) (undefined:xs) (cycle xs)) (cycle "foo")
12:26:04 <lambdabot>  "foofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoo...
12:26:21 <edwardk> of course so does the xs ++ [head xs] thing
12:26:34 <dminuoso> % (\xs -> zipWith (const id) (undefined:xs) (cycle xs)) ""
12:26:34 <yahb> dminuoso: "*** Exception: Prelude.cycle: empty list
12:26:38 <edwardk> but both are better than the one that uses length
12:27:06 <dminuoso> % (\xs -> xs <> maybeToList (listToMaybe xs)) (cycle "foo")
12:27:11 <yahb> dminuoso: "foofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoo
12:27:40 <dminuoso> So that has the upside of working with infinite lists, as well as with empty strings (though it begs whether it producing an empty string is desirable at all)
12:27:54 <edwardk> % (\xs -> xs <> maybeToList (listToMaybe xs)) (cycle "")
12:27:55 <yahb> edwardk: "*** Exception: Prelude.cycle: empty list
12:28:20 <edwardk> nm
12:28:33 <monochrom> Pikachu discovers that cycle is a partial function :)
12:28:51 <lordgrenville> (context if anyone's interested is Advent of Code 2017 prob 1)
12:30:04 <dminuoso> edwardk: It occured to me earlier, that a large chunk of your libaries don't appear to be built with denotational design, but "denotational implementation", where the mathematical model itself already is the implementation. Is that an accurate observation?
12:31:10 <monochrom> full-stack denotationation.
12:31:53 <hyperisco> huh, what is the point of having cycle be partial
12:32:13 <dminuoso> hyperisco: What should cycle on an empty list to exactly?
12:32:42 <hyperisco> it has one choice other than bottom
12:33:04 <dminuoso> `cycle ties a finite list into a circular one, or equivalently, the infinite repetition of the original list. It is the identity on infinite lists.`
12:33:15 <monochrom> Right, that's how biksheding happens.
12:33:20 <dminuoso> By the very definition in the Haskell report, returning an empty list would not fit
12:33:56 <hyperisco> if that is all it says, it doesn't seem precise enough to dictate one over the other
12:34:02 <dminuoso> I mean you could also argue "why is tail partial"
12:34:27 <dminuoso> hyperisco: If it demands that it turns a finite list into a circular/infinite repetition, then `cycle []` is not giving me an infinite/circular list back
12:34:46 <edwardk> dminuoso: i tend to write down the math and then go look for instances of it in the wild.
12:35:26 <dolio> The straight-forward definition `cycle xs = xs ++ cycle xs` is also partial. What the definition there does is give a better error message.
12:35:38 <edwardk> design implies the conceit that i can guess the right abstraction, and my experience is that i'm remarkably bad at that, but i can grab ncatlab, transcode something into haskell and try it out like a glove to see if it fits each of my problems.
12:35:39 <hyperisco> it seems like you've arbitrated that [] is not the circle of [] or the infinite repetition of []
12:35:51 <hyperisco> I am just arbitrating it the other way. How do you defeat me?
12:36:41 <monochrom> [] is not a cyclic data structure.
12:36:50 <monochrom> <<loop>> is.
12:37:24 <hyiltiz> Is there a GHC flag or formatter that shows all used unsafe functions, and ideally suggest transformations to convert them to safe versions?
12:37:42 <edwardk> clearly cycle [] should be [] as lim n->\inf (0^n) = 0
12:37:48 <solonarv> Safe (the language extension) gets you some of the way there
12:38:34 <dolio> Does it? What does "unsafe" mean here?
12:38:51 <dolio> People use it to mean all kinds of arbitrary stuff.
12:39:08 <hyperisco> and I might agree with a total  tail  depending on how it is worded in the report
12:39:21 <edwardk> total tail = drop 1
12:39:46 <monochrom> I have a better solution.
12:40:05 <monochrom> cycle :: [a] -> ([a], [a]), cycle [] = ([], bottom)
12:40:16 <edwardk> monochrom: heh
12:40:20 <edwardk> pick your poison?
12:40:20 <monochrom> tail :: [a] -> ([a], [a]), tail [] = ([], bottom)
12:40:24 <monochrom> yes
12:40:37 <monochrom> @quote monochrom debate.*poly
12:40:37 <lambdabot> monochrom says: All pointless debates can be settled by going polymorphic.
12:40:40 <hyiltiz> https://i.imgur.com/GpAqO.png 
12:40:55 <hyiltiz> I mean the green circle to be safe
12:41:30 <monochrom> Who drew that?
12:41:35 <hyiltiz> https://stackoverflow.com/questions/3124591/is-haskell-really-a-purely-functional-language-considering-unsafeperformio
12:41:47 <hyiltiz> "Don Stewart"(?)
12:42:00 <monochrom> If P=NP, does any of them collapse? :)
12:42:14 <monochrom> Ah thanks.
12:42:15 <dolio> So the total functions that Agda doesn't accept as total are unsafe? :)
12:42:52 <hyiltiz> Maybe some collapses but still better to overclassify than underclassify and confuse things.
12:43:19 <monochrom> dolio, people just recently 15 minutes ago used "unsafe" to just mean partial functions.
12:43:39 <dolio> Great. That's not what the Safe extension checks for.
12:43:50 <dminuoso> edwardk: Interesting, so what happens if it doesn't fit the problem? Release to hackage in case it'll fit a future problem?
12:43:52 <hyperisco> also I was very wrong… there are many choices other than ⊥ and [] because cons cells are nonstrict…
12:44:39 <hyperisco> cycle [] = cycle [⊥]  fight me
12:45:02 <ddellacosta> monochrom: is that not a good usage of unsafe? I always thought calling partial functions unsafe was pretty well accepted. Or are you saying someone was suggesting that's the _only_ acceptable usage?
12:45:08 <monochrom> No, fight the type system first.
12:45:33 <monochrom> err nevermind
12:47:05 <monochrom> ddellacosta: Vagueness and hyperboles and exaggerations are pretty well accepted. Sometimes I play along, sometimes I call it out.
12:47:36 <ddellacosta> monochrom: fair enough
12:52:00 <monochrom> tail [] = bottom has a stronger reason because it is meant to pair up with head as the pair of selectors for x:xs.
12:53:02 <monochrom> Insofar as you philosophically accept selectors, of course. (I don't.)
12:53:11 <hyperisco> oh, the report straight up defines the Prelude
12:53:22 <hyperisco> so there's the end of that discussion
12:57:27 <hyperisco> a philosophical argument against selectors… I'd like to hear that
12:58:21 <monochrom> http://www.vex.net/~trebla/haskell/crossroad.xhtml   scroll down to the philosophy section
12:58:56 <hyperisco> http://www.vex.net/~trebla/haskell/crossroad.xhtml#philosophy
12:59:18 <monochrom> Hey I forgot I put that anchor in!
12:59:49 <dminuoso> 21:44:17       hyperisco | cycle [] = cycle [⊥]  fight me
12:59:57 <dminuoso> Actually, this seems to be rather sensible
13:00:16 <dminuoso> It's an infinite list, you cant determine otherwise.
13:00:22 <dminuoso> (It's definitely not empty!)
13:00:28 <dolio> It's not an infinite list.
13:00:31 <dminuoso> oh
13:00:34 <dminuoso> well, maybe
13:00:42 <dminuoso> _|_ : _|_
13:00:43 <dminuoso> Rather
13:00:59 <MarcelineVQ> one property I enjoy with infinite lists is always being able to take a finite prefix from it
13:01:00 <dminuoso> dolio: ^- that is pretty infinite. ;)
13:01:23 <hyperisco> dolio, why?
13:01:35 <dolio> > length [undefined]
13:01:35 <monochrom> hyperisco was going for cycle [] = cycle [bottom] = bottom : bottom : bottom : ...
13:01:36 <dminuoso> hyperisco: well you an pattern match again [x] and figure out its not finite.
13:01:37 <lambdabot>  1
13:01:47 <edwardk> dminuoso: if it doesn't fit the problem then i don't get an instance for the thing and i try it out on the next 50 things
13:01:52 <dminuoso> You need to have a bottom in the tail
13:01:55 <hyperisco> > length (cycle [undefined]) -- this is what I said
13:02:04 <lambdabot>  mueval: ExitFailure 1
13:02:13 <dolio> Oh. I misread.
13:04:53 <dolio> What problem is this solving?
13:05:20 <dminuoso> dolio: Oh we're just discussing whether `cycle [] = _|_ is sensible
13:05:51 <dminuoso> Or whether maybe _|_ : _|_, or perhaps cycle [_|_] is a better definition for that
13:06:25 <dolio> If it were one of those other two, what problems would it solve?
13:08:23 <hyperisco> monochrom, I am having difficulty with the orthogonality argument
13:09:26 <hyperisco> monochrom, it seems to suppose pattern matching is otherwise, but it seems the same dependency is realised by  pat -> expr
13:10:07 <hyperisco> I cannot  fromJust mx  unless  isNothing mx  is false, and I cannot use  x  unless I match  Just x
13:11:39 <monochrom> You are splitting "case v of { pat1 -> e1; pat2 -> e2 }" into two pieces, "pat1 -> e1" and "pat2 -> e2", and remind me these two pieces are not orthogonal.
13:11:56 <monochrom> My answer is "who says I'm splitting like that?"
13:12:33 <hyperisco> "The problem with predicates and selectors is that they are not orthogonal"
13:12:41 <hyperisco> I am saying neither are patterns and expressions
13:12:48 <monochrom> I have one single integral atomic wholesome sieve and it's called "case v of { pat1 -> e1; pat2 -> e2 }" please don't break it up into unusable shards.
13:13:41 <monochrom> But predicates and selectors pose as a splitted bunch of functions.
13:14:00 <hyperisco> okay but is that part of the orthogonality argument?
13:14:07 <monochrom> "pat1 -> e1" is not posed as a thing that can survive alone.
13:14:16 <monochrom> Yes.
13:15:32 <hyperisco> I don't follow it
13:16:56 <hyperisco> it seems like there is something else underlying this
13:19:16 <hyperisco> you seem to be saying that, ordinarily, functions can be used orthogonally in the sense that the use of one is not dependent on the use of another, is that right?
13:22:23 <pus> Hello everyone!
13:22:41 <hyperisco> Hello one!
13:28:01 <pus> I am trying to create a coloured circle using Diagrams. It works well if I just use predefined colours like "red", but when I write "RGB 255 0 0", the compiler says that it can't match expected type ‘Colour Double’ with actual type ‘RGB Integer’. How do I make it "Colour Double"?
13:28:29 <hyperisco> pus, try  RGB 255.0 0.0 0.0
13:30:24 <turion> Is it true that gloss still doesn't work on a mac?
13:30:40 <monochrom> No, it's this: You run into an API presented as 5 functions, but the legal way to use them is almost always in the same configuration. Don't you think this API needs a redesign?
13:32:17 <dminuoso> Im in TH and Im digesting a bunch of numbers that are supposedly powers of two, and I want to turn them into the respective power. Using Floating seems a bit inappropriate
13:32:21 <ollehar> what's the benifit of knowing the side-effects a function has?
13:32:24 <hyperisco> I am not convinced it needs a redesign (though I haven't been told what I should care about)
13:32:35 <pus> hyperisco, now it can't match expected type "Color Double" with actual type "RGB Double"
13:32:40 <monochrom> To a large extent it's like comparing unix socket and java socket. Unix socket, on the server side: it's always the same socket-bind-listen workflow. Java shows, with hindsight, why not one single "Ctor(address, port, backlog)" to save you the trouble.
13:32:50 <dminuoso> (e.g. I want to turn 8 into 3, 16 into 4, and 7 into some kind of TH error)
13:33:11 <hyperisco> pus, oh, then maybe there is a conversion from  RGB Double  to  Color Double  but I do not know the library personally, sorry. Try using Hoogle or Hayoo
13:33:48 <turion> ollehar: If you know that your function will not access the database or the internet, for example, you can be sure that certain kinds of bugs don't happen (e.g. network or db not reachable, connection hung up). That's just one example.
13:33:51 <monochrom> In the case of predicates and selectors, we already have a redesign, it's called pattern matching.
13:34:10 <hyperisco> It seems like then that the argument is one of preference
13:34:30 <monochrom> In addition, the "maybe" function is a function-level redesign of isNothing-isJust-fromJust
13:34:38 <hyperisco> ie I like pattern matching, I don't like predicates and selectors
13:34:53 <monochrom> the "either" function is a redesign of isLeft-is-Right-getLeft-getRight
13:35:47 <hyperisco> or maybe it is an argument about quantity of syntax?
13:36:46 <turion> Has anyone successfully ran gloss on macos this year? Or GLUT for that matter?
13:37:06 <hyperisco> I'd like to have good arguments for pattern matching because I like pattern matching, but I'd like to say more than I like it, so that's my motivation in this discussion
13:37:51 <monochrom> I'll wait for you to come to see the API angle.
13:37:59 <dolio> Pattern matching is a good methodology for correct use of predicates and selectors.
13:38:18 <dolio> The alternative is complicated information flow checking.
13:38:43 <pus> hyperisco, I tried searching for "RGB Double" or "Colour Double" in Hoogle, but did not get any results.
13:39:00 <dolio> Or, it is a good methodology that corresponds to correct usage.
13:39:52 <hyperisco> For the sort of trivial pattern matching on sum types (like I assume we're talking about), I would say exhaustiveness checking is a good argument
13:40:28 <monochrom> I have that too, but it's under the "practice" section.
13:40:38 <hyperisco> pus, then I would visit the documentation on Hackage and see what it can tell me
13:41:11 <monochrom> Nothing says in theory you can't prove correctness of flexibly cavalierly written code.
13:41:41 <hyperisco> I don't think the orthogonality argument holds, and I think arguments about amount of syntax are shaky (because that will vary by language)
13:42:15 <monochrom> How about this? Mine is not an orthogonality argument.
13:42:22 <hyperisco> my rejection of the orthogonality argument is that, even ordinarily, the use of some functions depend on the use of other functions
13:42:39 <hyperisco> using  fst  or  snd  depends on a use of  Tuple
13:44:20 <hyperisco> and I was wondering if an argument that selectors and predicates can be used in invalid configurations would come up
13:44:46 <ollehar> turion: hm
13:45:05 <ollehar> turion: how would that affect testing?
13:45:09 <hyperisco> because then I would raise type guards
13:45:10 <ollehar> I mean, it's easier to test pure functions
13:45:21 <ollehar> (no IO)
13:46:11 <hyperisco> I like predicates and selectors quite a bit, and have argued against pattern matching in favour of them before
13:46:30 <hyperisco> boolean predicates that is
13:46:55 <monochrom> You're misreading me.
13:47:17 <monochrom> Mine is a toolbox-vs-monolith argument.
13:48:02 <monochrom> Normally monolith is problematic. I am using lack of orthogonality to explain why here is an exception, the toolbox is the problematic one this time.
13:50:23 <hyperisco> okay, then I think a paraphrase is that because the supposed toolbox can only actually be used in the way of the monolith, the monolith is no worse. Is that fair?
13:56:20 <hyperisco> I think this would be far easier to just assume we're talking about Haskell and comparing boolean predicates and partial selectors defined in Haskell versus case/of
13:56:34 <hyperisco> because then arguments in favour of case/of are abound
13:56:54 <monochrom> Do you understand the URL itself?
13:57:02 <monochrom> It has the substring "haskell" in it.
13:57:37 <monochrom> Do you see the practice section? It says I'm talking about Haskell.
13:58:03 <hyperisco> I was making an assumption that the #philosophy section was taking a broader view
13:58:06 <monochrom> At the end I have "I have more haskell notes and tutorials"
13:58:23 <monochrom> Yes and no.
13:58:54 <hyperisco> I think if we fix ourselves to Haskell it is powerful to argue against partial functions and powerful to argue the benefit of type refinement (or whatever it is properly called)
13:59:15 <monochrom> If the language is Rust I would say the same things.
13:59:19 * hackage hascard 0.3.0.1 - A TUI for reviewing notes using 'flashcards' written with markdown-like syntax.  https://hackage.haskell.org/package/hascard-0.3.0.1 (Yvee1)
13:59:27 <monochrom> If the language is Java I would say the same thing and trash Java.
13:59:40 <hyperisco> me too
13:59:46 <hyperisco> but TypeScript for example has type guards
14:00:05 <monochrom> It is broad because it applies to all of expressions of algorithms.
14:00:20 <hyperisco> and if we allow ourselves to design any language at all, it is harder to find justifications (or at least it seems to be to me)
14:00:35 <monochrom> It is not broad because I am not talking about every possible toolbox and every possible monolith.
14:02:49 * hackage pickle 1.0.1.0 - Instant StatsD in Haskell  https://hackage.haskell.org/package/pickle-1.0.1.0 (Luabee)
14:03:04 <hyperisco> also powerful to argue for exhaustiveness checking
14:03:33 <hyperisco> which in a usefully general boolean predicate design becomes difficult or impossible
14:03:41 <hyperisco> (but so does it in more general pattern matching designs)
14:05:31 <hyperisco> have a good evening
14:06:14 <monochrom> @tell hyperisco You need to read this too: https://mail.haskell.org/pipermail/haskell-cafe/2013-April/107775.html
14:06:15 <lambdabot> Consider it noted.
14:07:49 <monochrom> @tell hyperisco In other words there is no difference in exhaustiveness checking
14:07:49 <lambdabot> Consider it noted.
14:13:37 <kindaro> How can I find out from command line if a project has a given component?
14:14:12 <kindaro> Stack has `stack query locals $component`, but I would like not to use Stack. Can this be done with Cabal?
14:16:37 <maerwald> kindaro: what do you mean with project?
14:17:03 <kindaro> A Cabal package or a group thereof with a file `cabal.project` present.
14:17:23 <maerwald> ok, so what you're looking for a local packages
14:17:45 <kindaro> Yes.
14:18:21 <kindaro> I need a way to verify that a script is launched in the right project.
14:18:52 <maerwald> kindaro: you can examine `plan.json`, which has that information
14:19:10 <maerwald> I'm not sure if there is a tool to do specifically what you want, but you can do it programmatically
14:19:17 <kindaro> It is not required that the project can have a valid build plan.
14:19:33 <kindaro> This is why I cannot say `cabal build --dry-run $component`
14:20:34 <maerwald> kindaro: https://hackage.haskell.org/package/cabal-install-parsers ?
14:20:40 <maerwald> just parse cabal.project?
14:20:59 <maerwald> https://hackage.haskell.org/package/cabal-install-parsers-0.3.0.1/docs/Cabal-Project.html#t:Project
14:21:44 <kindaro> I was hoping that Cabal command line can do that for me… No luck I suppose.
14:57:20 <hekkaidekapus> @tell kindaro See `cabal-plan topo | grep ' ' | sed 's/ /:/g'`, but you will need an additional sed or similar to strip version suffixes.
14:57:20 <lambdabot> Consider it noted.
15:03:13 <maerwald> hekkaidekapus: a build plan isn't guaranteed
15:03:39 <hekkaidekapus> maerwald: bummer
15:15:37 <isd> Hey all. What do people use for csrf protection with scotty? I just realized I'd only previously used it with stuff that used websockets or programmatic APIs, so I've never actually needed csrf tokens before, but I can't find anything on hackage that seems maintained and isn't tied to some (other, larger) framework.
15:37:36 <hyiltiz> pus https://wiki.haskell.org/Colour seem helpful. Btw note that RGB is just one of the many color models. Converting Color to RGB probably requires specifying more info like white point etc.
15:45:34 <byorgey> I answered pus over in #diagrams but I'll answer here too for others' benefit: the likely answer is to import Data.Colour.SRGB and use a function like sRGB24
15:45:57 <byorgey> if you don't have a specific reason for wanting a different color space that's the recommended default
16:06:15 <pounce> So if I wanted to use the state monad and the list monad would I use the `StateT s []` monad
16:07:28 <tanner_> this is a beginner level question
16:07:43 <pounce> yes
16:07:51 <tanner_> i want to use (++ [' '] ++) as a function, but haskell doesn't like it
16:08:05 <pounce> oh, thought you were talking to me lmao
16:08:28 <tanner_> oh, no, did you also just ask a question?
16:08:52 <pounce> yeah sorry haha. Would this be a function String -> String -> String that appends to the start and end?
16:10:08 <tanner_> more like a modified version of (++), instead of combining two strings, i want to combine them with a space inbetween
16:11:05 <tanner_> Haskell has no problem with (++) but (++ [' '] ++) is apparently a syntax error
16:12:49 <hpc> sections are always one operator and one parameter on one side of it
16:13:05 <hpc> you'll need to write out the whole lambda
16:14:08 <pounce> Yeah, I don't think there's a point free way to  write this that is elegant
16:14:16 <tanner_> ok, I did \x y -> (x ++ [' '] ++ y) and that worked. Thanks for your help
16:17:01 <hekkaidekapus> > :t Data.List.intersperse
16:17:03 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
16:17:28 <hekkaidekapus> >:t Data.List.intersperse
16:21:24 <pounce> Would `StateT s []` even give me what I want from the list monad? or does `>>=` only deal with state
16:21:46 <pounce> Or would it be like a "stateful" flatmap
16:23:15 <hekkaidekapus> @type (>>=)
16:23:16 <lambdabot> Monad m => m a -> (a -> m b) -> m b
16:23:32 <pounce> I get the type..
16:23:33 <hekkaidekapus> pounce: Try out the types.
16:24:30 <hekkaidekapus> As you see, >>= is for any Monad instance.
16:25:16 <pounce> I know, but I'm asking specifically about the monad transformer `stateT s` applied to the list monad
16:26:30 <hekkaidekapus> So, what do you want “from the list monad”?
16:26:59 <pounce> mostly backtracking
16:27:58 <hekkaidekapus> That’s broad.
16:28:26 <hekkaidekapus> Could you show what is you tried and that is failing.
16:28:40 <pounce> lemme do some experiments and see
16:28:59 <hekkaidekapus> Fine.
16:44:13 <pounce> Ok, so yeah here's my problem: import qualified Control.Monad.State.Lazy as S
16:44:16 <pounce> wait no sorry
16:44:26 <pounce> here: https://paste.sr.ht/~pounce/e7a29c226ff4ca3ee99e8b0f7ed45fc9113376da
16:45:39 <pounce> I want the state to exist and be updated as I traverse the list
16:48:21 <hekkaidekapus> pounce: Let’s forget for a moment transformers. Could you first describe the algorithm that get you [1,1,1,2,3,4,3,5,7]?
16:49:43 <fog97> what frameworks do we have available for graphical streaming applications like actors models?
16:50:09 <fog97> i have an interacting particle system that exchanges force and mass with nearest neighbours...
16:50:24 <pounce> Yes. First 1 is taken out of [1,2,3] which is then mapped to [1,1,1]. the state is also set to 1. Then 2 is taken out, and so on
16:52:29 <hekkaidekapus> 1 is a literal. How do you “map” it to a list?
16:53:35 <pounce> No, the flatmap is on the entire list. I'm saying where the first literal goes in it.
16:54:59 <hekkaidekapus> Let me rephrase. Forget your snippet or any other *implementation* you may have in your mind.
16:55:23 <hekkaidekapus> We are doing plain English; what do you want to do?
16:55:46 <pounce> I want to perform a backtracking computation with state
16:56:38 <pounce> i.e. a branch and bound search that retains the current "best" result for early backtracking
16:57:04 <pounce> (tis is the main goal)
16:57:43 <hekkaidekapus> So you start with [1, 2, 3]. Good! What is the computation to go to the next branch?
16:58:41 <pounce> I take 1 since it is a valid start point, and return branch(1)
16:59:01 <pounce> which may produce more valid paths
16:59:24 <hekkaidekapus> Ok
16:59:33 <hekkaidekapus> What next?
17:03:44 <pounce> hekkaidekapus: well if I find a valid solution I want to store it as the current "best"
17:05:16 <hekkaidekapus> There is a little piece missing: you have not yet specified how to decide what is best.
17:07:07 <pounce> lets just say I have a function f(x) that gives a "weight" to solutions that I want to minimize
17:07:16 <pounce> and I want to store the best of these so far in the state
17:07:33 <hekkaidekapus> Ok
17:09:00 <hekkaidekapus> Do you understand the type `StateT s m a`?
17:09:49 <frdg> can this ever be possible? `x = ['0'..'9', 'a'..'z']`
17:10:22 <Axman6> x = ['0'..'9'] ++ ['a'..'z']?
17:10:55 <frdg> right
17:11:41 <hekkaidekapus> pounce: StateT ∷ ∀ {s} {m ∷ ★ → ★} {a}. (s → m (a, s)) → StateT s m a
17:29:23 <hekkaidekapus> pounce: Sorry but time is up for me, a lot of people here are ready to help you out. See you.
17:38:11 <koz_> Does a ZipVector newtype wrapper exist, analogous to ZipList?
17:48:01 <Axman6> It does exist... In your MIND!
17:48:59 <MarcelineVQ> That future, I created it, and it's real!
17:50:10 <Axman6> :rainbow:
17:59:57 <koz_> Axman6: Rofl.
18:03:35 <int-e> MarcelineVQ: megalomania meets solipsism?
18:04:04 <Cale> Megalovania meets In The Hall of the Mountain King
18:04:11 <MarcelineVQ> it's the sisko
18:04:18 <monochrom> "The phantom type of the zipvector is there! Inside your mind!"
18:04:43 <monochrom> "Code for me!"  "Ah ah ah ah ah ah ah ah ah!"
18:05:30 <MarcelineVQ> you're sure to appeal to the youth with phantom of the opera refs :>
18:06:14 <monochrom> Don't worry I also appeal to the twosetviolin audience.
18:06:57 <monochrom> I want you to take a look at my lecture slides at http://www.cs.utoronto.ca/~trebla/CSCB09-2020-Summer/03-c-data-l.pdf
18:07:24 <monochrom> in particular the table saying "char: 1 byte ... long long: 8 bytes"
18:07:27 <koz_> LOL, that awkward feeling when the instance you want can't exist.
18:07:37 * Cale expects to see a "Practice 40 hours a day" reference
18:07:37 <koz_> (infinite Vectors aren't a thing)
18:07:39 <monochrom> Next year I'll add one last row: "ling ling: 40 bytes"
18:08:42 <monochrom> But I did this on the midterm test.  "typedef lingling { ... ; double d[5]; } lingling;  what's sizeof(lingling)?"
18:08:57 <monochrom> err, typedef union { ... } lingling
18:09:05 <MarcelineVQ> What do we get for 10 bytes?
18:09:55 <monochrom> Cale, I do have this for you: http://www.cs.utoronto.ca/~trebla/CSCC24-2020-Summer/06-fam.html
18:10:45 <Cale> haha
18:10:49 <monochrom> On my C-and-unix exam I have a question on doing BST lookup but the BST is in a file. I open with "If you can lookup in RAM quickly, you can lookup on disk slowly!"
18:10:57 <Cale> InTeReStInG
18:21:22 <monochrom> koz_: If you don't mind coding up "data ZipVector a = InfiniteSequenceOfRepeatedly a | FiniteVector (Vector a)" it solves the problem of pure and is a zipwise instance of Applicative.
18:21:50 <koz_> monochrom: I considered that, but then it can't be Traversable, which kinda kills me.
19:21:05 <Axman6> I don't suppose there's a tool which can convert makefiles into shake?
19:21:24 <koz_> Axman6: The Glasgow Shake Compiler. :P
19:24:11 <fog6> argh, terrible news, the dynamical systems approach to deep learning considers the trajectory flowing through the layers during net evaluation, instead of the trajectory of the weights during learning - so the thing i was asking about was wrong
19:50:19 <sm[m]> Axman6: nice project idea
19:59:24 <Axman6> yeah I'm looking into it, makefiles are a bit painful though, since they can contain shell expressions too
20:06:56 <glguy> I've been working on some code for making a TCP connection to a hostname that might resolve to multiple IP addresses. I'm doing something based on happy eyeballs 2 where you concurrently connect to all the addresses with a short (in my case 150ms) delay between trying the next address. As soon as one of the connections succeeds you stop trying more connections and cancel the existing attempts 
20:06:58 <glguy> https://github.com/glguy/irc-core/blob/v2/hookup/src/Hookup/Concurrent.hs
20:07:42 <glguy> I wanted the code to be able to be killed with an asynchronous exception (to cancel a connection attempt) and to ensure that at most the returned socket is the only one left open
20:08:25 <glguy> I think this code achieves that but omg reasoning about where async exceptions can or can not pop up is breaking my brain
20:08:27 <yushyin> Axman6: and also scheme ... :/ (gnu make)
20:11:41 <dibblego> koz_: why can't it be Traversable?
20:21:24 <koz_> dibblego: For the same reason 'data Replicated a = Replicated Int a' can't be.
20:21:54 <dibblego> traverse f (Replicated n a) = Replicated n <$> f a
20:23:47 <glguy> toList (Replicated n a) = replicate n a -- but then you fail the Traversable requirement that: In the Foldable instance, foldMap should be equivalent to traversal with a constant applicative functor (foldMapDefault).
20:23:53 <topos> breaks the traversable laws
20:24:00 <topos> damn glguy got to it first
20:24:31 <koz_> I was _just_ hunting for a precise argument.
20:24:38 <koz_> When both glguy and topos ninja'd me hard.
20:25:43 <glguy> I've been playing Ghost of Tsushima lately. My sneak attack was dishonorable; I should have declared "Who will fight me?" or "Send your strongest warrior!"
20:31:06 <monochrom> Like I said yesterday tautologically, the system is optimized for gaming the system. :)
20:37:11 <topos> glguy jump on the pile of logs - they can't reach you there
20:37:27 <topos> you will be shogun of haskell
20:37:41 <dibblego> oh that particular instance right cheers
20:38:28 <glguy> topos: I'm playing on the default difficulty, so you don't really need to move out of reach to become invincible :)
20:38:39 <int-e> monochrom: That's what you get when you let lawyers make the rules.
20:38:51 <int-e> monochrom: Sorry for making it less tautological. :P
20:40:10 <monochrom> Chicken and egg puzzle: DId lawyers make the rules, or did rule makers become lawyers?
20:40:28 * glguy wonders what the difference is between "laywer" and "rules laywer"
20:40:40 <MarcelineVQ> arbiters made the rules
20:41:00 <int-e> glguy: the latter has 40% fewer typos, relatively speaking
20:41:19 <glguy> ah, that explains it
20:41:23 <int-e> (Oops, I meant to type 50%.)
20:41:38 <dibblego> I regularly encounter written laws that nobody can give a definitive answer on, including the one or two experts on it in the country.
20:41:46 <MarcelineVQ> rule slaywer
20:42:08 <int-e> laywering jokes :-/
21:03:24 <pounce> hm, looks like `monad-lgbt` does what I need for global state.... don't really need local state though
21:03:30 <pounce> I need to read about backtracking with continuations more...
21:05:49 <pounce> actually the backtrackT monad in that library is eagar which I don't want.
21:24:39 <pounce> Hm so i guess i know how to phrase my question better. I want a breadth first search backtracking monad with global state. Is there a good way to figure out how to make this?
22:35:19 * hackage chainweb-mining-client 0.2 - Mining Client for Kadena Chainweb  https://hackage.haskell.org/package/chainweb-mining-client-0.2 (larsk)
23:44:33 <ph88> I have seconds in Word64 and i like to use this function https://hackage.haskell.org/package/time-1.10/docs/Data-Time-Clock.html#v:secondsToNominalDiffTime  how do i go from Word64 to Data.Fixed.Pico ??
23:45:54 <c_wraith> fromIntegral?
23:47:47 <ph88> oh just like that o_O
23:47:57 <ph88> how could i know that i can call fromIntegral on it ?
23:48:25 <c_wraith> :t fromIntegral
23:48:27 <lambdabot> (Integral a, Num b) => a -> b
23:48:40 <c_wraith> If the source type is an instance of Integral
23:49:09 <c_wraith> which it is!  https://hackage.haskell.org/package/base-4.14.0.0/docs/Data-Word.html#t:Word64
23:50:39 <ph88> oh and then here    HasResolution a => Num (Fixed a)   when you supply a it will give you   Num (Fixed a)    i see
