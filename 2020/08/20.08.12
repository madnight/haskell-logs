00:29:13 <maerwald> does stack also generate a plan.json and if so, where?
00:48:26 <tomsmeding> maerwald: in a default build, at least, no
00:48:38 <tomsmeding> find . -name '*'.json  is empty :p
00:51:42 <typetetris> Can someone recommend a library to read pdfs he had good experiences with to me?
00:56:08 <dminuoso> typetetris: reading pdfs in an automated fashion is an extremely annoying and tough problem in general.
00:56:08 <dminuoso> (PDF was really not designed for this goal in mind)
00:57:04 <dminuoso> If you have a PDF or multiple that internally have some recognizable patterns you can special case a solution. I'd start and check whether pdftotext from Xpdf/poppler does enough for you already.
00:57:19 <dminuoso> If not, Im afraid you'll have to go all in with https://hackage.haskell.org/package/pdf-toolbox-core
00:58:22 <typetetris> dminuoso: Just looking if some text arrived in the pdf, that's all, so pdftotext should be enough. Will shell out to that.
00:58:53 <typetetris> http://hackage.haskell.org/package/pdftotext looks nice
01:00:25 <dminuoso> typetetris: That's just an ffi wrapper around poppler though, fyi.
01:01:43 <typetetris> dminuoso: That is fine.
01:01:48 <dminuoso> typetetris: Here's a fun bit we had. A service provider gave us technical documentation of telecommunication lines (essentially just tables with numbers) in form of a few hundred PDFs.
01:02:25 <typetetris> dminuoso: Ok, where is the fun? :)
01:02:38 <dminuoso> They manipulated the PDFs to visualize the tables using overlapping boxes
01:03:03 <dminuoso> Then they used bogus fonts that had randomized the glyph<>codepoint mapping differently for each PDF. So extracting textual information gave us random junk. 
01:03:37 <dminuoso> At the end it was all done intentoinally to make automated processing impossible.
01:04:13 <dminuoso> In another case they had prepared it in such a way to include non-visible text data that were triggered when textual extraction was done..
01:06:53 <typetetris> dminuoso: "service" provide, looks like a "headache" provider to me
01:08:55 <dminuoso> What can I say. When the big previous national ISP is forced to lease lines/loops to smaller ISPs as part of deregulation, then they do about 70% of the required minimum and fill up the remaining 30% with making your life harder.
01:18:48 <tomsmeding> I wonder if there are automated tools to perform that kind of pdf obfuscation
01:18:54 <tomsmeding> and how large of a market those tools have
01:19:14 <tomsmeding> how hard did you laugh when you realised how jumbled it was
01:19:32 <dminuoso> It was more of a head shaking than a laugh
01:22:35 <dminuoso> Even the way you had to request the PDFs was laughable. You had to "request a PDF", then after 24 hours it would be "delivered into a virtual mailbox" of sorts. Then you could only request some 10 PDFs or so a day, it would take another 24 hours before they became available, and they'd disappear another day later. So when you want to consume the documentation for a thousand PDFs, things become
01:22:37 <dminuoso> rather inconvenient
01:23:15 <dminuoso> On the legal side of things they satisfied the requirements of making technical documentation available digitally.
01:23:38 <dminuoso> I was surprised they didn't rasterize these PDFs into bitmaps before sending them.
01:23:57 <dminuoso> (Turned out, the way we scraped data off was with OCR btw)
01:34:50 * hackage extra 1.7.5 - Extra functions I use.  https://hackage.haskell.org/package/extra-1.7.5 (NeilMitchell)
01:51:32 <alm44> @free (a -> b) -> f a -> f b
01:51:32 <lambdabot> Try `free <ident>` or `free <ident> :: <type>`
01:52:29 <alm44> @free foo :: (a -> b) -> f a -> f b
01:52:29 <lambdabot> Extra stuff at end of line
01:52:51 <alm44> @free fmap
01:52:52 <lambdabot> Extra stuff at end of line in retrieved type "Functor f => (a -> b) -> f a -> f b"
01:53:01 <mniip> it can't work with higher kinded types
01:53:31 <alm44> @mnii
01:53:31 <lambdabot> Unknown command, try @list
01:53:40 <alm44> @mniip Thanks!
01:53:41 <lambdabot> Unknown command, try @list
01:53:52 <mniip> as I understand it, higher kinded parametricity is something of an open problem
01:54:06 <alm44> Well there is a free theorem for `fmap`
01:54:14 <alm44> It's
01:54:42 <mniip> for a fixed f
01:54:48 <mniip> not for a parametric f
01:55:07 <ski> (it's not IRC custom to adorn nicknames by sigils like `@'. simply mention the nickname of the one you wish to address or refer to)
01:55:12 <mniip> @free fmapMaybe :: (a -> b) -> Maybe a -> Maybe b
01:55:12 <lambdabot> g . h = k . f => $map_Maybe g . fmapMaybe h = fmapMaybe k . $map_Maybe f
01:55:27 <mniip> this is the free theorem you're talking about?
01:56:12 <alm44> `forall (g :: forall a. f a -> b).  g . fmap f = g`
01:56:37 <mniip> huh
01:57:10 <alm44> oops, I used f in two different ways there
01:57:36 <mniip> you also used a "forall" dot right next to a "compose" dot
01:57:42 <alm44> `forall (h :: forall a. f a -> b).  h . fmap g = h`
01:58:58 <mniip> I feel like that's not true for all f
02:02:04 <alm44> It is! The essence of the theorem is that the identity law guarantees that fmap can't affect the "structure" of a functor, so if we have some `h` that can only act on the structure of the functor, then composing `h` with `fmap g` must be the same as just `h`, since `fmap g` can't affect the "structure" of the functor
02:03:07 <alm44> you can prove it by hand, but it's rather tedious
02:03:47 <alm44> I recommend following along with https://reasonablypolymorphic.com/blog/theorems-for-free/ and https://www.well-typed.com/blog/2015/05/parametricity/
02:04:01 <ski> hm, identity law doesn't follow from parametricity
02:05:03 <mniip> so it's only true for functors
02:05:03 <alm44> that's true, but if we know that `fmap` satisfies the identity law, then that's correct
02:05:13 <alm44> yes, only true for functors
02:05:17 <mniip> right, so it's not really a parametricity result
02:05:28 <mniip> it's more of a statement that
02:05:37 <mniip> f is covariant hence (exists a. f a) ~ f ()
02:06:54 <ski> whee
02:06:58 <alm44> ah, I see what you mean
02:07:37 <alm44> I wonder if it's possible to prove something like that with paramCoq
02:10:49 <mniip> parametricity is weird
02:21:20 * hackage ngx-export-tools-extra 0.5.5.1 - More extra tools for Nginx haskell module  https://hackage.haskell.org/package/ngx-export-tools-extra-0.5.5.1 (lyokha)
02:28:49 * hackage qlinear 0.1.0.0 - Typesafe library for linear algebra  https://hackage.haskell.org/package/qlinear-0.1.0.0 (JuniorGarbageCollector)
02:40:55 <mniip> actually relational semantics of parametricity are even weirder in typed foundations
02:41:33 <mniip> type-lambdas are translated into particular sigma types, and showing that those are preserved under substitution is even wackier
02:46:52 <carbolymer> I'm running stack test --file-watch and after each change I need to scroll to the beginning of output to start fixing errors - is there a way to paginate stack output in such case?
02:49:53 <mniip> carbolymer, GHC has an option to display errors in reverse order -- that might help
02:54:13 <carbolymer> mniip, that's actually what I needed! thanks!
02:55:18 <mniip> assuming you're working on a single package that should work
02:55:30 <mniip> building multiple packages calls GHC multiple times (possibly concurrently) so
02:56:28 <alehander92> is it better to use `()`
02:56:33 <alehander92> or hiding or just importing normally
02:56:49 <alehander92> or use `as` ? it seems to me `()` or just direct import usually are simpler
02:56:58 <alehander92> (and maybe Data.Text as T
02:57:00 <alehander92> ~
02:57:01 <alehander92> ) *
03:07:56 <mniip> alehander92, what are you trying to do?
03:16:00 * hackage qlinear 0.1.0.1 - Typesafe library for linear algebra  https://hackage.haskell.org/package/qlinear-0.1.0.1 (JuniorGarbageCollector)
03:23:20 <alehander92> just wondering about convention
03:23:44 <alehander92> in python, it's usually expected to not import everything
03:23:50 <alehander92> in nim, usually it's normal to import all
03:26:11 <mniip> alehander92, there are certain modules that are expected to be imported qualified
03:26:19 <mniip> e.g. containers, text, or bytestring
03:26:26 <tomsmeding> I believe 'hiding' isn't done often, except perhaps for Prelude
03:26:45 <mniip> with those, it is idiomatic to import types unqualified, and the rest of the module qualified using some shorthand name
03:26:56 <mniip> import Data.Text (Text); import qualified Data.Text as T
03:27:31 <mniip> other modules are usually imported unqualified because name clashes are rare
03:27:54 <mniip> in some codebases I've seen all imports unquaified but also an alias for prelude
03:28:01 <alehander92> hm
03:28:05 <mniip> import Data.Text as T; import Prelude as P
03:28:10 <mniip> T.length vs P.length
03:28:14 <alehander92> ok, and i guess for my own modules it's personal 
03:28:20 <alehander92> sometimes it might be more clear to namespace
03:28:35 <alehander92> also, another question, should i write my own monads for stuff like
03:28:41 <tomsmeding> mniip: is it idiomatic to do 'import Data.Text as T', as opposed to 'import qualified Data.Text as T'?
03:28:51 <alehander92> specific state / io workflows
03:28:54 <tomsmeding> the former gives lots of issues like having to do Prelude.length
03:29:01 <tomsmeding> in my experience
03:29:19 <mniip> tomsmeding, read closely what I said
03:29:21 <alehander92> i'll focus on normal usage for now
03:29:24 <alehander92> and lastly
03:29:32 <mniip> I gave two different solutions both of which address this problem (in two different ways)
03:29:35 <alehander92> i am writing a compiler
03:30:11 <alehander92> i feel most of my code would be either using `IO` for handling files in certain components, or just "pure" code returning trees/other structures
03:30:16 <tomsmeding> mniip: I failed at reading, sorry carry on :)
03:30:29 <mniip> alehander92, in a compiler most of your code should probably be pure
03:30:31 <alehander92> is it a good place to use more advanced stuff like lens / other
03:30:50 <mniip> possibly using local effects (transformers)
03:31:24 <mniip> lens probably wouldn't fit in a compiler
03:31:42 <mniip> lens is for dealing with nested records
03:31:45 <mniip> (mostly)
03:33:49 <alehander92> hm, but i can have nested records hypothetically
03:34:24 <alehander92> but yeah, i see what you mean, i am thinking more of various "linked" trees
03:36:55 <Orbstheorem> Hello o/ What are 0-variable typeclasses usually useful for?
03:43:07 <mniip> global data
03:43:18 <mniip> and/or global assumptions
03:58:49 * hackage zenacy-html 2.0.0 - A standard compliant HTML parsing library  https://hackage.haskell.org/package/zenacy-html-2.0.0 (mlcfp)
04:22:37 <sarthor> let me paste here..... https://youtu.be/8vpE32K1jew
04:44:48 <carbolymer> any ideas how to write type of instance in line 10? https://repl.it/repls/IdioticFakeAdministrator
04:46:07 <tomsmeding> carbolymer: you can't directly, because you'd need some kind of "type-level lambda"
04:46:15 <carbolymer> :|
04:46:33 <tomsmeding> do you really need this particular instance, or could you perhaps reformulate it as 'instance Foo a => Foo (b -> a)' ?
04:49:18 <tomsmeding> if you want only exactly this instance, you'd need a newtype I think
04:50:43 <carbolymer> hmmm, I'm trying to write some kind of generic mapper function in a form: Resource -> (Token -> f -> m a) -> f ->  m a ; but the problem is that instead of f there, it should allow variable number of arguments, so I came with another ide: Resource -> (Token -> f m a) -> f m a; then If I could write class and instances for variable number of arguments for f - that would be nice
04:51:22 <tomsmeding> doesn't my suggestion above allow you to let the function have a variable number of arguments?
04:53:13 <carbolymer> I'm not saying it does not - I'm just trying to understand what you wrote, and I provided more context :)
04:53:26 <tomsmeding> let me set up a small example of what I mean
04:55:17 <dharthvader> Hi. Though i'm a beginner at haskell and AI/ML , I was curious in combining the two for my learning journey , though I have been hearing negative things about the pairings but the library HaskellR looks interesting though I dont know how to use it, anyone has any experience with it ?  any insights on Ai/Ml and haskell would be welcome ?  couldn't Haskell be used to built AI applications like spss? 
04:58:14 <tomsmeding> carbolymer: how do you obtain a Token from a Resource?
04:58:25 <tomsmeding> is that an action in 'm'?
04:58:30 <carbolymer> yes
05:04:48 <dminuoso> No instance for (MonadFail STM)
05:05:05 <dminuoso> Sigh, why not? This seems incredibly handy for something like: `do Foo int <- op; ...`
05:05:37 <tomsmeding> 'fail = const retry' seems like a non-useless definition
05:06:01 <tomsmeding> interesting
05:08:26 <dminuoso> In my case, want a simple `do Foo i <- op; pure i` :p
05:08:44 <dminuoso> Dont mind writing the extra 3 lines, but *sigh* :p
05:16:35 <dminuoso> There's a bit about it in https://wiki.haskell.org/MonadFail_Proposal but I cant make sense of it
05:16:55 <dminuoso> `Some types have different definitions for mzero and fail. Although STM is MonadPlus it uses the default fail = error. It should therefore not get a MonadFail instance.`
05:17:07 <dminuoso> Presumably STM had *error* for the old fail implementation.
05:17:20 <dminuoso> (That is, for Monad.fail)
05:17:44 <dminuoso> That's a sad mistake in hindsight I think.
05:18:07 <tomsmeding> perhaps it's to make legacy code not compile, instead of do something semantically different?
05:25:50 <tomsmeding> dharthvader: forgive me for ducking past your main question, but do you consider SPSS to be an "AI application"?
05:26:22 <tomsmeding> carbolymer: I haven't yet managed to make it work :p
05:29:14 <carbolymer> tomsmeding, me neither :) that instance Foo a => Foo (b -> a) or similar do not work - ghc is complaining that it needs an argument for "a"... wtf
05:30:18 <tomsmeding> that question I can answer at least :) -- you use the parameter to Foo as a "type function", because you apply an argument to it in the class. (more properly: the argument to Foo has kind * -> *)
05:30:28 <tomsmeding> thus it should always get an argument
05:33:44 <tomsmeding> carbolymer: how bad is it if you get something like: Resource -> (Token -> a -> b -> c -> m d) -> c -> b -> a -> m d
05:33:52 <tomsmeding> note the reversal :p
05:34:01 <jonathanx> tooling questions: the vscode Haskell plugin blocks intellisense/snippets from working, anyone recognize the issue? :)
05:34:06 <tomsmeding> no guarantee I can make that work either (in fact I don't think so)
05:35:16 <dharthvader> well I guess not its a tool that can assist statisticians in ML i dont know spss , but I was thinking of learning to create  that kind of gui to do ML work in haskell where maybe the gui is only in the browser using yesod etc and it calls R through HaskellR
05:36:01 <jonathanx> tooling answer: it conflicted with a specific ormolu-plugin
05:36:04 <jonathanx> :D
05:36:06 <tomsmeding> dharthvader: so, is it really about making a GUI in Haskell that calls out to existing backend libraries?
05:36:46 <tomsmeding> jonathanx: I don't use vscode but it sounds weird to me that a formatter plugin blocks snippets from working
05:37:43 <dharthvader> in cases where it is advantages to do it , where possible I would like to write and reason about ML in haskell 
05:38:16 <turion> I have this weird situation:
05:38:18 <turion> $ cabal sdist 
05:38:18 <turion> LICENSE: openBinaryFile: does not exist (No such file or directory)
05:38:19 <tomsmeding> well Haskell is certainly suited to reasoning :)
05:38:30 <turion> $ ls LICENSE ¬†¬†¬†¬†
05:38:30 <turion> LICENSE
05:38:41 <jonathanx> tomsmeding: I had two plugins that both wanted to handle format calls. I agree it's weird, but disabling one of them worked out, and that's enough for me
05:39:19 <tomsmeding> turion: $ strace cabal sdist 2>&1 | grep open | grep LICENSE
05:39:44 <tomsmeding> jonathanx: üëç
05:41:02 <turion> tomsmeding: $ strace cabal sdist 2>&1 | grep open | grep LICENSE 
05:41:02 <turion> openat(AT_FDCWD, "LICENSE", O_RDONLY|O_NOCTTY|O_NONBLOCK) = -1 ENOENT (No such file or directory) 
05:41:02 <turion> write(2, "LICENSE: openBinaryFile: does no"..., 68LICENSE: openBinaryFile: does not exist (No such file or directory)
05:41:59 <tomsmeding> are you sure you're running 'cabal sdist' in the directory where the LICENSE file lives?
05:42:05 <turion> tomsmeding: yes
05:42:12 * tomsmeding wut
05:42:44 <turion> Hah ok this is a really funny bug. By chance I had another package under the same cabal.project, that had the line "name: my-package-name" in its cabal file
05:43:59 <turion> So I'm entering directory my-package-name, calling cabal sdist there, and it tries to sdist ../other-package instead, because I did an error in other-package.cabal
05:44:12 <turion> Not even sure that's a bug
05:44:43 <turion> tomsmeding: That's a nice debugging approach though
05:44:56 <tomsmeding> ... interesting, not enough experience with either sdist or cabal projects to be able to say whether that's reasonable behaviour :p
05:45:31 <tomsmeding> strace is my lord and saviour when programs dump unclear errors on me that originate from syscall errors
05:45:59 <turion> tomsmeding: So many times I wished such errors were clearer. I'll try strace next time that happens again
05:46:38 <turion> I'm guessing it does something like this: 1. Discover cabal.project 2. Look for the current directory 3. Via cabal.project, find some cabal file that matches the name 4. Whoops it doesn't build
05:46:57 <tomsmeding> I _guess_ it makes sense
06:19:18 <turion> In Rust, I can do "cargo check" when I just want to typecheck without generating objects. It's much faster than "cargo build". With cabal, the closest I can think of is "cabal --ghc-options="-fno-code"", but that rebuilds all dependencies. Is there a better way to achieve the same?
06:20:50 * hackage essence-of-live-coding 0.2.0.0 - General purpose live coding framework  https://hackage.haskell.org/package/essence-of-live-coding-0.2.0.0 (turion)
06:20:56 <tomsmeding> turion: ghcid (https://github.com/ndmitchell/ghcid) basically needs the equiavalent of "cargo check", and it uses nothing more than -fno-code, I believe
06:21:15 <tomsmeding> so assuming that ghcid does the right thing, no, I don't think there's a better way
06:21:19 <merijn> turion: The problem is that -fno-code via ghc-options is *global*
06:21:33 <merijn> turion: So the configuration of your dependencies changes and is redone
06:21:33 <turion> tomsmeding: Hmm right. How does ghcid do that without rebuilding everything
06:21:50 * hackage essence-of-live-coding-quickcheck 0.2.0.0, essence-of-live-coding-pulse 0.2.0.0, essence-of-live-coding-gloss 0.2.0.0 (turion): https://qbin.io/lyrics-greene-ge0y
06:21:58 <turion> merijn: Ah, I could add ghc-options: -fno-code in my cabal file?
06:22:06 <merijn> turion: You wanna specify -fno-code for only the current package, which is most easily done via cabal.project (or cabal.project.local)
06:22:12 <merijn> turion: That works too, but is annoying :p
06:22:50 <turion> Oh yes cabal.project.local is much nicer. Applies to many packages and I won't accidentally commit it.
06:22:51 <merijn> turion: The simplest way is to make a cabal.project.local file which has "package your-package\n  ghc-options: -fno-code" in it
06:23:45 <turion> Ok so if I build only that package it won't generate code. But what if I run executables that depend on it?
06:23:54 <tomsmeding> carbolymer: I can't seem to manage :p
06:25:37 <tomsmeding> certainly doesn't mean it's impossible though
06:27:51 <turion> Hmm seems they fail at the linking stage
06:28:14 <turion> Ah no, at the build stage of the executable
06:28:17 <merijn> turion: Well, yeah, since no code is being built :p
06:29:57 <turion> I guess I'm just going to use ghcid[e]
06:38:34 <tomsmeding> can vouch for both
06:41:04 <jonathanx> Looking for a lib that's good for multi-edge DAG:s, anyone have any suggestions? :) 
06:46:20 <hseg> Having trouble getting ghci to reduce a type family
06:46:37 <hseg> thought :t TF T should have done the trick
06:47:11 <hseg> but that complains that TF should be a data constructor
06:48:07 <hseg> oh wait -- this is actually a data family
06:48:09 <hseg> but still
06:50:57 <hseg> ah, ok. it's data families that are problematic here
06:52:44 <dehun> hi, at a company I work for we decided to try haskell for a microservice. I am researching libraries that we can use. Any good suggestions for configuration file library? Not looking for a lot of features - just what is popular nowadays and used/maintained most? :) 
06:53:34 <dminuoso> dehun: There's nothing canonical. There's quite a few around if you search for `config` on hackage.
06:53:51 <dminuoso> Personally Im fond of ConfigFile
06:54:03 <pdack1> `getSomething :: Get (Maybe Something)getSomething = lookAheadM $ Just <$> get `
06:54:20 <dolio> hseg: :t asks for the type of a value level expression. You want :kind!
06:54:40 <pdack1> Hello I have a problem i am facing.. given the above, I am unable to figure out how to get for an array of Something
06:54:55 <hseg> dolio: yes, but since i'm using data families, i don't get info on constructors
06:55:00 <dminuoso> config-ini looks even more promising. :)
06:55:06 <pdack1> i.e. `getSomethingBatch :: Get ([Maybe Something]) `
06:55:23 <hseg> btw, annoying that you can't :i (TF T) -- only :i TF
06:56:13 <int-e> hseg: out of curiosity, what does :k TF T  do here?
06:56:13 <carbolymer> tomsmeding, I don't think so, I'm working with Servant API so the argument order is hard to change there I think - I gave up, I've copied my function 2 times :(
06:56:22 <carbolymer> tomsmeding, anyhow, thanks for help
06:56:30 <hseg> (TF T) :: * = TF T
06:56:40 <hseg> which is less than useful
06:57:08 <hseg> basically i'm forced to do mental unification to figure out the actual set of instances used
06:57:26 <int-e> there's also the fact that ghc tries to keep types as close to source code form as possible for (typically) better error messages
06:57:31 <hseg> which considering i'm using a handful of type synonyms gets "fun"
06:57:45 <int-e> which is the opposite of what you want
06:57:57 <tomsmeding> carbolymer: good luck!
06:58:00 <int-e> (as I understand it)
06:59:45 <hseg> weird... have no idea how my code compiled with the instances ghci is reporting
07:00:08 <hseg> at least according to what I'm seeing, i should have unreduced type families
07:00:28 <hseg> nm, checking code shows the instances exist
07:00:37 <hseg> but ghci isn't reporting them for some reason
07:01:02 <pdack1> anyone here that can help with my questions above please? thanks
07:01:34 <jumper149> What would you recommend to install a haskell ide for vim with nix, ghcide? haskell language server?
07:02:18 <hseg> ... even weirder is that i can look up the instance by constructor, but not the other way round
07:02:29 <jumper149> hseg: orphan instances?
07:02:37 <hseg> data family
07:02:53 <hseg> oh wait. these are type synonym instances
07:03:19 <hseg> (i have type Z = Integer floating around, and said newtype instance DF Z = ...)
07:03:34 <hseg> ... except neither instance DF Z nor instance DF Integer show up
07:04:16 <jumper149> hseg: ok, sorry I have no clue what `newtype instance ...` means
07:06:56 <hseg> jumper149: basically, a type family is a function which outputs types
07:07:19 <hseg> so e.g. type family Wrap a where Wrap a = [a]
07:08:50 <hseg> or type family Rot a; type instance Rot (a,b) = (b,a); type instance Rot (a,b,c) = (c,a,b)
07:10:16 <tomsmeding> hseg: I'm 99% sure that 'newtype instance' is invalid syntax
07:10:23 <hseg> *data* families are type families that guarantee their outputs are fresh types (so data instance DF T = D' is more or less data DF_T = D'; type instance DF T = DF_T)
07:10:30 <hseg> tomsmeding: it's valid
07:10:47 <hseg> and does what you expect
07:11:11 <tomsmeding> huh it's 'data instance' but then with 'newtype'
07:11:16 <tomsmeding> funny
07:11:49 <hseg> jumper149: The freshness guarantee also means that you get generativity for data families: DF a ~ DF b => a ~ b
07:11:59 <hseg> (a la how Maybe a ~ Maybe b => a ~ b)
07:12:23 <hseg> (in this regard, data family:type family :: pattern synonym : function)
07:14:12 <dminuoso> What is the point of type equalities in type signatures like `a ~ b => .. a .. b ..`? I mean why not just write `.. a .. a ..` instead?
07:14:13 <dolio> I wouldn't say 'fresh'. Data families are constructors; they don't reduce.
07:14:28 <dminuoso> Naively these two appear to mean the same thing.
07:15:17 <dolio> dminuoso: Depending on the context, they may not be exactly the same.
07:16:52 <dminuoso> What does "exactly" mean here?
07:18:33 <hseg> dolio: point. was a little lie
07:18:48 <dolio> Well, for instance, `instance a ~ T => C T a` works differently than `instance C T T`.
07:19:05 <hseg> dminuoso: you mean literally a ~ b => t a b vs t a a ?
07:20:53 <Rotfuchs> dolio: But are those different in normal function type signatures too?
07:21:33 <dolio> I can't think of any examples, but maybe there's one that I haven't seen.
07:22:04 <hseg> iirc there's a difference in when you need the constraint to discharge
07:23:34 <dminuoso> hseg: Oh you mean e.g. in a situation where `constraints` would do it?
07:24:12 <dminuoso> (\\) :: HasDict c e => (c => r) -> e -> r 
07:24:28 <dminuoso> I suppose in such a situation it can't just create the type equality out of nothing?
07:24:50 <dminuoso> dolio: Alright I think I can see why. Thanks
07:25:00 <dminuoso> Primarily this seems to be useful on contexts of instances then.
07:25:07 <hseg> sth like that. the only cases i've seen is in contexts of instances
07:25:49 <hseg> basically, whether equality is resolved at use site or propagated out as a constraint to the ultimate user
07:26:08 <hseg> cf https://journal.infinitenegativeutility.com/haskell-type-equality-constraints, https://stackoverflow.com/questions/11553705/haskell-equality-constraint-in-instance
07:29:50 * hackage hspec-core 2.7.2 - A Testing Framework for Haskell  https://hackage.haskell.org/package/hspec-core-2.7.2 (SimonHengel)
07:30:50 * hackage hspec 2.7.2, hspec-discover 2.7.2 (SimonHengel): https://qbin.io/saver-smell-xijm
08:08:32 <jumper149> ghcide doesn't use my cabal file, correct?
08:09:17 <dminuoso> Is there a way to kill a thread that is currently blocked on a c call?
08:10:49 * hackage qlinear 0.1.2.0 - Typesafe library for linear algebra  https://hackage.haskell.org/package/qlinear-0.1.2.0 (JuniorGarbageCollector)
08:11:09 <fendor> dminuoso, afaik, i dont thikn so
08:11:15 <fendor> jumper149, it does use it, usually
08:11:43 <jumper149> It doesn't load the default-extensions that I specified there
08:12:13 <jumper149> I might need to fix the hie.yaml file
08:14:16 <jumper149> I basically have trouble finding how to write that file x)
08:14:21 <dminuoso> fendor: Mmm that blows. So the only way to unblock something stuck on waitProcess is to SIG* the underlying process?
08:14:29 <jumper149> Is there some documentation on how to write it?
08:15:14 <fendor> jumper149, is this helpful? https://github.com/mpickering/hie-bios/#cabal
08:15:17 <fendor> if not, please say so :)
08:15:42 <jumper149> fendor: Yes, definetely helpful!
08:15:54 <fendor> dminuoso, I *think* so. But I am not that familiar
08:16:08 <jumper149> fendor: I think I might still try https://github.com/Avi-D-coder/implicit-hie
08:16:28 <fendor> jumper149, yeah, that is a good idea, but understanding how it works is nice, too. 
08:17:43 <fendor> so, if you find the documentation in hie-bios, lacking, please raise an issue :)
08:30:49 * hackage record-dot-preprocessor 0.2.6 - Preprocessor to allow record.field syntax  https://hackage.haskell.org/package/record-dot-preprocessor-0.2.6 (NeilMitchell)
08:36:06 <merijn> dminuoso: Are you using the threaded backend?
08:36:19 <merijn> dminuoso: You can't use waitProcess using the single threaded backend
09:03:19 * hackage essence-of-live-coding 0.2.0.1 - General purpose live coding framework  https://hackage.haskell.org/package/essence-of-live-coding-0.2.0.1 (turion)
09:04:20 * hackage essence-of-live-coding-quickcheck 0.2.0.1, essence-of-live-coding-pulse 0.2.0.1, essence-of-live-coding-gloss 0.2.0.1 (turion): https://qbin.io/travis-keen-5i2c
09:13:50 <ezzieyguywuf> is it bad-practice or non-idiomatic to do something like `data MyData = A {getVal :: Int} | B {getVal :: Int}`?
09:14:11 <ezzieyguywuf> specifically, I'm asking about the `getVal` record, which is named the same for both data values (is value the correct term?)
09:15:00 <Cale> Having record syntax for data types with multiple constructors is a bit of a misfeature of the language, but if you're going to use it, having the same record fields in every constructor is probably a good idea
09:15:44 <jumper149> ezzieyguywuf: Haven't had that idea before, but I don't see any problem.
09:16:02 <Cale> But usually it's possible/desirable to simply invert the situation -- that's not much different from having something like  data MyData = A | B, and then having a record that has a MyData and an Int
09:16:34 <Cale> In general, in any case where you'd have the same fields in every constructor
09:16:35 <ezzieyguywuf> Cale: you lost me at "and then having a record", what did you mean by that?
09:17:31 <ezzieyguywuf> also, I can see how it might be a "misfeature": I was using it because I wanted to do something like `myFunc :: MyData -> Blah; mydata = getVal mydata; doSomethingWithVal`
09:17:31 <Cale> I mean like,  data MyData2 = MD2 { md2_myData :: MyData, md2_getVal :: Int }
09:17:46 <ezzieyguywuf> Cale: ah, I see what you mean now.
09:18:16 <Cale> The reason it's a misfeature is that if your constructors don't have exactly the same fields, then some of the field extraction functions are partial and crash your program
09:18:20 * hackage shake-plus 0.3.2.0 - Re-export of Shake using well-typed paths and ReaderT.  https://hackage.haskell.org/package/shake-plus-0.3.2.0 (locallycompact)
09:18:50 <ezzieyguywuf> Cale: exactly. My sample `myFunc` above is fine until I add `data MyData = ... | C {getVals :: (Int, Int)`
09:19:06 <Cale> and then if they *do* have exactly the same fields, well, you can always do what I just did there, make an enumeration, and then a single-constructor record of whatever the fields were
09:19:44 <ezzieyguywuf> Cale: I like this approach, is it separates out the two concerns: (1) enumerating the type of data, (2) specifying the actual data
09:19:55 <ezzieyguywuf> Cale: thanks for walking through that with me :)
09:20:02 <ezzieyguywuf> also, jumper149 thank you for your input
09:25:04 <jumper149> ezzieyguywuf: With the same argument Cale gave, I can definetely see why you should be careful with records in sum types. You could also just define the accessor function seperately. GHC can more easily find missing patterns that way.
09:29:15 * ezzieyguywuf nods
09:32:56 <jle`> btw, this refactoring is the "algebra" of algebraic data types :)
09:33:05 <jle`> earlier you had Int + Int
09:33:14 <jle`> and we refactored it into 2 * Int
09:33:30 <jle`> where MyData is the 2-item data type, and * is tupling
09:35:29 <ezzieyguywuf> üòÆ lol, can't say I followed that entirely.
09:36:56 <jle`> ezzieyguywuf: when you make a sum type, you're 'adding' the types together
09:37:07 <jle`> so your MyData is Int + Int   -- that's why it's called a sum type
09:37:20 <jle`> but if you saw x+x in algebra, you know you could refactor it as 2*x
09:38:14 <jle`> so we know that we can rewrite x+x as 2*x,    so we can rewrite Int + Int as 2 * Int
09:38:34 <jle`> and that is what (MyData, Int) is, where MyData = A | B
09:38:58 <jle`> (multiplication is tupling)
09:42:47 <jle`> i guess the overall point is that while you don't need to be aware of the algebra behind things, it can guide you to neat ways to refactor/simplify your types using the same skills you learned in 8th grade algebra
09:43:09 <jle`> for example if you had data MyData = A Int | B Int | C Int | D Int, that's Int + Int + Int + Int
09:43:24 <jle`> and if you saw x+x+x+x, you know you can simplify it as 4*x
09:43:58 <jle`> so that MyData would be equivalent to (DType, Int), where data DType = A | B | C | D
09:54:21 <sm[m]> looks pretty interesting, that https://www.manuelbaerenz.de/essence-of-live-coding/EssenceOfLiveCodingPresentation.html
09:54:25 <monochrom> This is why "you don't need math for haskell" is just sales pitch.
09:54:44 <tomsmeding> eh, this is hardly "math"
09:55:20 <tomsmeding> I bet all people that are soothed by "you don't need math for haskell" are very well able so deduce that x+x+x+x = 4*x
09:55:58 <tomsmeding> it's more that without math, you're not really ready for the https://wiki.haskell.org/Zygohistomorphic_prepromorphisms
09:56:06 <tomsmeding> but then again, who is
09:57:56 <jle`> i mean i guess i hope i came off as 'you don't need the math, but this is a case where it could help if you can recognize x+x+x+x = 4*x, but you would have come to the same conclusion anyway without it'
10:00:14 <tomsmeding> you did, at least to me :)
10:00:21 <MarcelineVQ> "Do I‚Äã need math for haskell?" "Depends, can you tell me what you mean by math?"
10:00:35 <tomsmeding> yes
10:00:38 <MarcelineVQ> You can't not need math for programming of any kind, math is about patterns, programming is about patterns.
10:00:53 <tomsmeding> I love patterns
10:01:07 <MarcelineVQ> What poeople are scared of is having to learn new patterns. Well, tough, it's a new language.
10:03:32 <MarcelineVQ> Slightly differently worded: "Do I‚Äã need math to learn haskell?" "Did you need math to learn python?"
10:04:19 <monochrom> Python is not a good indicator because Haskell type inference requires a skill Python doesn't need.
10:04:42 <tomsmeding> perhaps Rust is a better comparison -- but then people are also scared of Rust's borrow checker
10:04:48 <monochrom> http://www.vex.net/~trebla/haskell/prerequisite.xhtml#unification
10:05:37 <monochrom> Also Haskell emphasizes equational reasoning, Python relieves you of it.  (The rest of that article.)
10:11:36 <tomsmeding> that's a quality piece of text
10:16:38 <monochrom> Thanks.
10:17:39 <mniip> nooooo you can't just learn haskell without learning n-category theory and presheaf logic
10:27:22 <dolio> "Zygohistomorphic prepromorphism" doesn't come from math.
10:28:30 <nij> Hello.. is there a way to define the type Date as an alias of String, but requiring that the format must be "####-##-##"?
10:28:45 <dolio> No.
10:29:00 <nij> dolio: :(
10:30:25 <nh> nij: you can do that in cobol
10:30:27 <xsperry> not statically, but you could export only a smart constructor that returns Maybe YourType
10:30:39 <sm[m]> you can define it and export only smart constructors.. right
10:31:29 <mniip> datatypes with smart constructors are subobjects... datatypes with smart destructors are quotients
10:32:48 <nij> I see!
10:32:52 <nij> Thank you :)
10:35:13 <dolio> Why represent dates as particularly formatted strings, though?
10:45:41 <[exa]> regex library flexibility problem: I have a string (a long one, more like a large mmapped bytestring) and would like to know if a regular expression would produce a match starting exactly at position N somewhere in the middle. I could just cut the "latter part" of the string out and run a regex on that (checking there's a match at the first position), but that won't know if the special regex marks for 
10:45:47 <[exa]> region begins/ends would match (like ^, $, \<, even \`). Is there some theoretically sound approach and/or library to do this?
10:46:58 <sm[m]> you meant the former part I think ? Uh, what happens if you prepend N .'s to your regexp ?
10:47:09 <[exa]> in particular, I'm not entirely sure if this is even doable with the "generic" Text.Regex interface
10:47:40 <[exa]> sm[m]: no, the latter part. The beginning of the file will be "already parsed" and I need to pick out a user-defined token
10:48:10 <sm[m]> I'm not familiar with those region/begin end matchers, which regex backend supports them ?
10:48:12 <[exa]> yeah I'd say it could be called a lexer
10:48:23 <[exa]> eg. regex-tdfa
10:48:33 <dmwit> Perhaps cut to position N-1, then match the regex with a . prepended
10:48:46 <[exa]> \< \> is begin/end of word, \` \' is gnu extension for beginning/end of the whole data
10:49:15 <[exa]> dmwit: hm yeah that could work (at least for now)
10:51:48 <sm[m]> speaking of regexes, it's a bit inconvenient for me that they don't support instances like Show/Read/Eq/Ord/Data/NFData. We've talked about making a new type that holds on to the original text form as well so those instances can be implemented. Do you think it makes sense for the (a) regex package to do this ?
10:53:49 <[exa]> sm[m]: holding the actual regex expression doesn't make much sense, it usually gets compiled to some kind of state machine... but certainly some insight into what's inside would be useful
10:54:14 <dmwit> Holding the original and the compiled version together makes sense.
10:54:15 <sm[m]> [exa]: it's the only way those instances could be implemented I think
10:54:42 <sm[m]> or some of them at least. I'm not certain they all can be implemented without problems
10:56:26 <sm[m]> an alternative is to use a stringly type & smart constructor, like nij, but that seems non-ideal
10:57:25 <sm[m]> (that is, an alternative way to ensure that regexps are valid and won't fail to compile at runtime. more context: https://github.com/simonmichael/hledger/issues/1312#issuecomment-671358325)
11:23:31 <justsomeguy> Phew, typing on an ergronomic keyboard after a while feels perilous. Enter is right next to j, and Win is where Esc used to be.
11:23:52 <justsomeguy> ...aaand I'm in the wrong channel...
11:24:38 <ezzieyguywuf> justsomeguy: which channel was that meant for?
11:24:40 <monochrom> The keyboard sent you to the wrong channel, too. :)
11:24:42 <MarcelineVQ> ergonomics strikes again!
11:25:29 <monochrom> But really, it's muscle memory. You can't easily beat 20 years of muscle memory without another 20 years.
11:26:20 * hackage blucontrol 0.2.1.1 - Configurable blue light filter  https://hackage.haskell.org/package/blucontrol-0.2.1.1 (jumper149)
11:26:21 <justsomeguy> #casualConversation on snoonet, ezzieyguywuf
11:26:31 <monochrom> If you used the new keyboard since day 1, you would not have this problem now. But you would have possibly a worse problem: You feel alienated by standard smartphone keyboards.
11:27:05 <[exa]> justsomeguy: I found it much simpler just to switch some keys on a normal keyboard to avoid RSI. level 1: LCtrl vs capslock, level 2: avoiding all the dumb ctrl/alt + Fx shortcuts, level 10: qwerty vs dvorak
11:27:59 <justsomeguy> That sounds like a good approach. But weird keyboards are too much fun :).
11:29:51 <sureyeaah> justsomeguy: waiting for moonlander ;_;
11:31:03 <maerwald> monochrom: it took me 4 weeks to switch from qwertz to workman layout and it's available for android too
11:31:13 <maerwald> my ebook reader I had to patch...
11:31:37 <monochrom> My first keyboard was Casio FX-702P's "ABCDE" keyboard. :)
11:32:48 <monochrom> I was young so it didn't take long to become bilingual to qwerty and abcde
11:45:13 <int-e> hello matrix
11:45:34 <L29Ah> lol
11:47:25 <hololeap> @unmtl StateT s (Writer w) a
11:47:25 <lambdabot> s -> (a, s, w)
11:47:39 <hololeap> @unmtl WriterT w (State s) a
11:47:40 <lambdabot> s -> (a, w, s)
11:47:58 <hololeap> Yay, isomorphic
11:53:19 * hackage servant-jsonrpc 1.1.0 - JSON-RPC messages and endpoints  https://hackage.haskell.org/package/servant-jsonrpc-1.1.0 (IanShipman)
11:54:19 * hackage servant-jsonrpc-client 1.1.0 - Generate JSON-RPC servant clients  https://hackage.haskell.org/package/servant-jsonrpc-client-1.1.0 (IanShipman)
11:54:39 <frdg> do thunks grow or shrink as expressions are evaluated?
11:55:19 * hackage servant-jsonrpc-server 2.1.0 - JSON-RPC servant servers  https://hackage.haskell.org/package/servant-jsonrpc-server-2.1.0 (IanShipman)
11:56:38 <koz_> hololeap: Yeah, {Reader,Writer,State}T can all be mashed in and out of each other.
12:08:16 <maerwald> is it isomorphic if you change the order of effects?
12:08:32 <monochrom> :)
12:08:43 <monochrom> The problem with overusing "isomorphic".
12:10:03 <merijn> monochrom: Isomorphic is when the same code runs on the server as the client, right? :p
12:10:11 <maerwald> lol
12:10:46 <merijn> maerwald: See, the funny thing is that you think I'm joking
12:10:48 <merijn> maerwald: https://medium.com/@ElyseKoGo/an-introduction-to-isomorphic-web-application-architecture-a8c81c42f59
12:11:00 <merijn> maerwald: https://www.jondjones.com/frontend/javascript/jagon-explained/what-the-hell-is-an-isomorphic-web-application/
12:11:13 <maerwald> will this affect my blood pressure?
12:11:16 <merijn> Just google "isomorphic webapp" for 20 billion examples
12:11:32 <monochrom> Are you telepathic and know that I am answering a unix-and-c student question concerning my socket-server-client assignment and so you mess with me by mentioning server and client too so I am thoroughly confused between my IRC window and my email window? :)
12:11:42 <merijn> maerwald: Given how upset you can get about posix, I think this might literally kill you :)
12:11:49 <maerwald> :D
12:19:14 <monochrom> Incidentally I started playing Galactic Civilzation III last night. So now I can't shed the image of a tech tree full of "xenomorphic this", "xenomorphic that".
12:19:36 <merijn> How is it?
12:19:41 <merijn> I like GalCiv 2 a lot
12:19:46 <merijn> But it's kinda dated by now
12:20:04 <monochrom> This greatly inspires me to start the trend of using "xenomorphic" to simply mean "not isomorphic". Example! Maybe Int is xenomorphic to Either Bool Int.
12:20:10 <merijn> Much more interesting AI than Civ, though :p
12:20:30 <monochrom> I have only played (and finished) the tutorial. Too many knobs.
12:20:51 <monochrom> Too many tech trees.
12:20:54 <merijn> Yeah, it's not very minimal in terms of systems design (if it's anything like 2)
12:21:29 <maerwald> these games stress me out, I end up micromanaging everything and trying to make all citizens happy
12:21:46 <maerwald> and then you get burn out
12:22:16 <monochrom> Yeah, too many knobs.
12:22:59 <maerwald> usually, only a handful of the knobs are actually relevant and can be abused to greater advantage
12:23:11 <maerwald> so game balance is usually poor with many knobs
12:23:25 <merijn> I notice the same trends in boardgames, some people seem to confuse complexity with depth
12:23:33 <monochrom> I think among you (and among my friends) there are great talented strategists who can easily make sense of the knobs and turn them to win in front of even the hardest AI opponents. But I can't do it.
12:24:14 * hololeap thinks Stellaris is pretty cool
12:24:24 <monochrom> Said strategists will also say that, e.g., C&C General is shallow. Precisely because of that, I keep coming back to it!
12:24:44 <merijn> (Not that complexity can't give rise to depth, but that requires sophistication that mean people don't have)
12:24:56 <merijn> hololeap: <3 grand strategy ;)
12:25:11 <merijn> Although I think we're drifting into -offtopic territory :p
12:25:47 <maerwald> you can implement those board games in haskell, ofc
12:26:12 <monochrom> Too many states.
12:26:15 <merijn> I'm not a good enough boardgame designer
12:26:20 <merijn> And yes, too many states :p
12:26:59 <monochrom> You would become another fog rambling about your new idea of representing graphs functionally, and at the type level.
12:27:25 <merijn> I once tried to implement my own Diplomacy adjudicator in Haskell. It was a PITA
12:27:38 <merijn> boardgame rules aren't designed for simple computer implementation :p
12:28:27 <monochrom> I guess I am no better. Grumpy old person grunting about "too many knobs", "too many states", "too many games"...
12:28:49 <monochrom> "too many extensions" haha
12:28:54 <merijn> monochrom: Naah, you're sophisticated ;)
12:29:26 <merijn> Having depth with "simple" games is hard
12:29:28 <maerwald> maybe ppl reach for new tools, because they don't understand the exising ones yet
12:30:14 <merijn> monochrom: I notice this a lot with new boardgames where I will see 20 different token types an already be preemptively exhausted about managing all that where half the time it just doesn't carry it's weight in terms of depth
12:30:46 <monochrom> Haha reminds me of oleg's work. Always boasting "I can do that too, and within Haskell 98".
12:31:55 <monochrom> And by the time he allows himself a little bit of UndecidableInstances, he can give you Java-style checked exception system, he can give you effectful streaming, he can give you a new effect system.
12:32:09 <monochrom> Hell, he started the frenzy on effect systems in Haskell.
12:32:21 <merijn> monochrom: So he's to blame! ;)
12:32:30 <maerwald> let's blame oleg, yes
12:35:56 <dminuoso> merijn: Turns out my issue lies elsewhere. Some part of streaming-commons is not doing resource cleanup properly. :(
12:36:22 * MarcelineVQ puts down an oleg streaming paper...
12:51:11 <Cale> merijn: ...and then there's go. :)
12:51:40 <hyiltiz> Have been using Spacemacs with haskell layer supported by `hdevtools` Debian package. I found that GHC gitlab page recommends ghcide tho doesn't mention hdevtools. Is ghcide the "state of the art" editor support for emacs now?
12:51:59 <merijn> hyiltiz: hdevtools has been dead for *at least* 5 years
12:52:16 <merijn> Because I was already running a custom fork of it back then
12:52:27 <monochrom> I think "state of the art" is right. I also think it carries no significance.
12:52:52 <hyiltiz> Just wanna set it up once and for like the next 2 years...
12:53:10 <monochrom> Perhaps it's because I'm cynical and synonymize "state of the art" with "hot talk hot air"
12:53:14 <merijn> hyiltiz: Yeah, that's likely not happening
12:53:20 <hyiltiz> Always honing the sword and not using it seems annoying
12:53:23 <merijn> hyiltiz: It's in a lot of flux right now
12:53:52 <merijn> I think there's at least 2 GSoC projects related to ghcide and still a bit rough around the edges
12:53:57 <monochrom> Instead, I trust a simpler program that, maybe older, but I already got it to work and it still works today.
12:54:33 <monochrom> I would recommend if your old setup hasn't failed you, don't break it.
12:54:34 <hyiltiz> there should be a setup called haskell-dev-monad that is implemented by whatever is "best" at the time https://xkcd.com/927/
12:55:09 <MarcelineVQ> monochrom maintaining the balance between 'wisened sage' and 'old man shouts at clouds'
12:55:12 <merijn> hdevtools only ever worked for v1-build
12:55:34 <monochrom> OK, then that's a good reason to switch.
12:55:37 <merijn> So I suggest giving up on it in favour of v2-build, which is why I stopped maintaining my personal hdevtools fork years ago
12:55:46 <hyiltiz> I just `apt upgrade`d today and hdevtools somehow got removed from Debian Testing; it removed a bunch of other packages along with it. Had to pull them back manually from Unstable/Sid.
12:56:03 <monochrom> emacs haskell-mode has been trivial to install and sufficient feature for me.
12:57:33 <merijn> monochrom: That'd require porting my dev environment to emacs, though :p
12:57:59 <monochrom> Even during a brief moment in history when it was not updated to new ghci conventions, it was easy to hand-patch, even by me who normally wouldn't bother.
12:58:14 <hyiltiz> Spacemacs haskell layer asks me to pick among company-ghci intero dante ghc-mod hie
12:58:40 <monochrom> dante is of the same nature and complexity/simplicity as haskell-mode
12:58:40 <hyiltiz> I am aware a few of those can be considered outdated but not sure which one to go with; it doesn't even list ghcide...
12:59:26 <hyiltiz> hmm I'll check out what the spacemacs haskell layer provides over haskell-mode then :D
12:59:27 <monochrom> I generally stay away from any offering that builds upon the GHC API. That means all the way from ghc-mod to ghcide
12:59:55 <monochrom> This is because I have used the GHC API myself and know how brittle it is in deployment.
13:00:26 <hyiltiz> Hmm without GHC how can it parse and report back errors? I guess you have a terminal open running stuff at all times (like ghcid or luit or some watchman)?
13:00:50 <monochrom> And empirically everyone else who have had trouble installing any of ghc-mod to ghcide are more data points supporting the same conlusion.
13:01:15 <merijn> ghc-mod is also dead :p
13:01:21 <merijn> For about 2 years, I think :p
13:01:35 <monochrom> haskell-mode and dante talks to ghci.
13:03:18 <monochrom> There is a big difference between: elisp code (or any not-compiled-haskell code) talking to ghci through a text pipe, vs binary built against GHC API
13:04:35 <monochrom> The latter requires loading a matching version of GHC library. As in: If your copy of ghc-mod binary is built against 7.10, when it runs it loads up and uses GHC 7.10 again.
13:04:45 <monochrom> Tight coupling.
13:05:21 <hyiltiz> Seems an awful design for a dev environment
13:05:29 <monochrom> Pretty similar to how, for glibc, even after you have done "static linking" you still need the same version of glibc to be present and ready to load dynamically.
13:07:14 <dminuoso> monochrom: And even then its not guaranteed to work right.
13:07:51 <dminuoso> Like, consider calling into sbrk. :)
13:08:07 <monochrom> Yeah I am oversimplifying the exact precondition for GHC API to work. "same GHC version installed and will be loaded" is only the 1st-order approximation.
13:08:53 <monochrom> I haven't thought of sbrk and how it breaks, though.
13:09:02 <monochrom> (Haha pun)
13:09:41 <monochrom> "If sbrk is working, it should break." :)
13:11:17 <monochrom> My impression of intero is that it copes by insisting on stack, so stack can auto-rebuild intero and also auto-download GHC.
13:12:45 <monochrom> But it's only a guess. I haven't tested or observed. Wouldn't be surprised, stack is involved, what else do you expect.
13:13:26 <monochrom> Or rather, would you expect any less.
13:15:28 <sm[m]> hyiltiz: https://www.reddit.com/r/haskell/comments/i8diib/feature_diff_between_haskelllanguageserver_and/ might be of interest
13:19:48 <monochrom> I initially agreed about "awful design" but now my opinion is "what is the alternative?'
13:20:17 <monochrom> There is no "awful" if there is no feasible alternative.
13:21:35 <monochrom> Let's assume that you bite the bullet, rid your addiction (I'm exaggerating! sorry!) to GHC API, and you have finished writing your own Haskell parser, your own type inferer, it's a clean-room re-implementation that rivals GHC.
13:22:01 <monochrom> Now what? The hardest part is yet to begin.
13:23:11 <dolio> A language server implementation for GHC needs to use GHC.
13:23:21 <dolio> And GHCi is not an appropriate vehicle for it.
13:23:54 <monochrom> A user loads up your new IDE, and asks about the type of a value that's in a library package "monofoo". This package has already been built and installed by/on the native GHC. But this package didn't even exist when you wrote your Haskell parser and type inferer and new Haskell IDE.
13:24:04 <monochrom> Where do you locate information about monofoo?
13:25:15 <merijn> monochrom: Hell, people can't manage this for C, that's why clangd exists :p
13:25:16 <monochrom> With Java, this is easier. The JVM bytecode file format is extremely stable, and has all the type and name information you need. You just read that.
13:25:19 <dolio> GHCi could be a vehicle if it exposed a lot more stuff via commands, but that would be implemented directly in GHC. If it's not directly in GHC, then it needs to use the API.
13:26:03 <monochrom> With the Java culture, furthermore, people usually also keep around third-party library source code, so a Java IDE can even "jump to definition" even for 3rd party libraries.
13:26:39 <monochrom> These are all more difficult with GHC. The *.hi format isn't as stable. Generally 3rd-party lib sources are thrown away.
13:27:03 <monochrom> Your new IDE still doesn't beat GHC API in terms of functionality.
13:28:43 <monochrom> Yeah merijn is right, generally any compiled-and-optimized-beyond-recognition setting faces this fundamental problem.
13:29:06 <hyiltiz> So it is again the problem about package management that is hardest to solve huh?
13:30:04 <dolio> The 'bite the bullet' part was an enormous ask already.
13:31:01 <monochrom> GHCi has already added a few IDE-ish commands fairly recently. (Probably a year already.)  It can do "what's the type of this expression which is from line 5 column 6 to line 7 column 13?", for example. There are a couple others.
13:31:25 <monochrom> And it is used by haskell-mode and dante. It's why dante can show you its impressive table of features.
13:31:45 <monochrom> The only problem: If you haven't had a successful :load or :reload, those commands can't work.
13:32:37 <monochrom> An IDE that talk to GHC API directly can still get some information in that case.
13:33:05 <monochrom> But you've already understood the price.  My preference is this price is too big for the small gain.
13:33:42 <monochrom> If I simply add -fdefer-type-errors then the haskell-mode/dante way already works with extremely high probability.
13:34:36 <monochrom> If I further add two-phase commit, i.e., run ghcid on the side to warn me of :load errors so I don't tell haskell-mode to :load, the scheme works 100% of the time.
13:35:15 <monochrom> The intallation process of this scheme is completely trivial compared to any of the Haskell IDEs.
13:36:35 <monochrom> BTW GHCi also has auto-complete commands for haskell-mode and dante.
13:37:36 <monochrom> My opinion is it is more viable to help contribute more GHCi IDE-aid commands than improving the IDEs.
14:06:37 <koz_> Can someone suggest to me how I can use `runReturningMany :: (m (Maybe x) -> m a) -> m a` to give me a Vector?
14:07:01 <koz_> And also whether this would be garbage vis a vis Vector construction?
14:07:10 <koz_> Function in question is http://hackage.haskell.org/package/beam-core-0.8.0.0/docs/Database-Beam.html#v:runReturningMany
14:08:22 <hyiltiz> Thx monochrom for the detailed explanation
14:09:28 <hyiltiz> Guess Haskell mode plus ghcid is the most straightforward approach with less chances to shoot myself in the foot
14:10:31 <monochrom> If you get ghcide to install in a reasonable amount of time, that's great, nothing wrong with that.
14:10:55 <monochrom> But if it takes more than a day, I would say don't lose hair over it, settle for less.
14:11:36 <monochrom> I do suffer from the selection bias that here in #haskell I never heard from people who got ghcide to install just fine no hassle!
14:12:08 <frdg> What is the syntax for specifying that I would like to install a cabal package using a specific version of ghc? Right now I am saying `cabal install foo`. I want to say `cabal install --withGHC-1.1 foo`.
14:12:18 <koz_> frdg: -w
14:12:30 <koz_> Then pass the path of the GHC you want.
14:12:36 <monochrom> --with-ghc=
14:12:43 <frdg> ok thanks
14:12:47 <koz_> monochrom: Is that the long-form of -w?
14:12:52 <monochrom> Yeah
14:12:59 <koz_> TIL.
14:13:27 <monochrom> err oops, --with-compiler=
14:13:45 <monochrom> I forgot that cabal tries to be uncommitted to ghc.
14:13:49 * hackage git-brunch 1.4.0.0 - git checkout command-line tool  https://hackage.haskell.org/package/git-brunch-1.4.0.0 (andys8)
14:14:48 <monochrom> The Old Republic ideal was "--with-compiler=hugs" would also make sense.
14:15:01 <monochrom> or jhc
14:15:26 <koz_> There needs to be a compiler that acronymises to 'jfc'.
14:15:34 <monochrom> haha
14:16:01 <monochrom> wait what's jfc?
14:17:07 <int-e> monochrom: this? https://www.urbandictionary.com/define.php?term=JFC
14:17:29 <monochrom> oh haha
14:18:06 <monochrom> ironically the ad served was for the movie "a beautiful day in the neighborhood"
14:18:33 <dminuoso> Mmm, https://hackage.haskell.org/package/unix-2.7.2.2/docs/src/System.Posix.IO.Common.html#createPipe
14:18:51 <monochrom> One doesn't simply utter "jfc" in front of Fred Rogers!
14:19:29 <dminuoso> If I just lose the Fds, will the underlying resources get cleaned up?
14:20:20 <monochrom> I believe no.
14:20:38 <monochrom> Not even ForeignPtr magic is attached to Fd. It's just the raw int.
14:22:03 <monochrom> You are in for a ride just as rough as what my student got when they didn't know there are always a few FDs they need to close. :)
14:22:49 <monochrom> http://www.cs.utoronto.ca/~trebla/CSCB09-2020-Summer/07-processes-l.pdf  slide 10
14:23:08 <monochrom> (Also please enjoy the title of the next slide, "Writer's Block" :) )
14:23:53 <monochrom> And a few other slide titles and subtitles. I was particularly proud of having fun with them.
14:25:18 <int-e> monochrom: see also https://www.ncbi.nlm.nih.gov/pmc/articles/PMC1311997/
14:26:50 <monochrom> haha
14:28:49 * hackage om-http-logging 0.1.0.0 - om-http-logging  https://hackage.haskell.org/package/om-http-logging-0.1.0.0 (taphu)
14:29:26 <hyiltiz> I wonder if a writer execing pipe hygiene would ever gets a writer's block
14:30:09 <koz_> [insert joke about async IO and pipes]
14:31:00 <kraeXen> how do I use an operator passed as an argument?
14:31:02 <kraeXen> as in:
14:31:12 <koz_> kraeXen: Bracket-wrap.
14:31:14 <koz_> So like
14:31:14 <monochrom> would. writer's block is an orthogonal issue, caused by uncooperative the-other-side, nothing you can do.
14:31:22 <koz_> (:) <$> foo <*> bar
14:31:50 <monochrom> fold (+) 0 [1,2,3]  the (+) there
14:33:05 <dolio> If you use fdToHandle, you might get something that will clean itself up. It's pretty hard to tell, though.
14:35:44 <kraeXen> > let a ??>> b = a * b in (??>>) <$> 5 <*> 5
14:35:46 <lambdabot>  error:
14:35:46 <lambdabot>      ‚Ä¢ Ambiguous type variable ‚Äòf0‚Äô arising from a use of ‚Äòshow_M607320438443...
14:35:46 <lambdabot>        prevents the constraint ‚Äò(Show (f0 Integer))‚Äô from being solved.
14:36:03 <kraeXen> what am I missing here?
14:36:24 <kraeXen> I tried foldr, but with no luck
14:36:48 <monochrom> > let a ??>> b = a * b in foldr (??>>) 1 [2,3,4]
14:36:50 <lambdabot>  24
14:36:55 <monochrom> worksforme
14:37:30 <int-e> > let a ??>> b = a * b in (??>>) <$> [5] <*> [5]
14:37:32 <lambdabot>  [25]
14:37:47 <int-e> > let a ??>> b = a * b in (??>>) <$> [1,2] <*> [3,4]
14:37:49 <lambdabot>  [3,4,6,8]
14:38:41 <int-e> (you need *some* applicative; list is just the easiest to conjure up)
14:43:02 <maralorn> There was a haskell.love talk about typed template Haskell where the type "Code a" appeared a lot. But I can‚Äòt find this type anywhere in template-haskell. What‚Äòs up with that?
14:45:49 * hackage generic-data 0.9.1.0 - Deriving instances with GHC.Generics and related utilities  https://hackage.haskell.org/package/generic-data-0.9.1.0 (lyxia)
14:46:34 <glguy> maralorn: the talk probably defined it locally
14:46:37 <hyiltiz> bleh~ ghcide page said to install via stack in its project directory; so I did. It downloaded an old GHC version via stack, built for an hour then when I ran, ghcide errored out telling me to cabal update (I never use cabal in my system). Cabal downloaded another 700MB+ of index.tar... Just uninstalling ghcide and going back to haskell-mode now
14:46:47 <kraeXen> > let fn op = op <$> [5] <*> [5] in fn (*)
14:46:49 <lambdabot>  [25]
14:46:54 <hyiltiz> Apparently "just do stack install" doesn't work
14:48:15 <glguy> maralorn: https://mpickering.github.io/papers/specification-typed-th.pdf defines `newtype Code a = MkCode (Q (TExp a))` and argues for why it's good to have that newtype
14:49:51 * monochrom cries. Why does "cabal run -v xxx" sends the verbose information to stdout?
14:50:13 <maralorn> hyiltiz: You should try again with haskell-language-server in a short while. e.g. after the first public release. The setup/configuration procedure has been improved _an amazing  lot_ in the last few weeks.
14:50:21 <monochrom> oh great, and a little bit to stderr
14:50:30 <glguy> monochrom: I think even without -v it sends the "Up to date" message to stdout, too
14:50:48 <hyiltiz> maralorn: oh i was about to try that now... Guess I'll set up a reminder myself to try in some indefinite future?
14:51:35 <maralorn> hyiltiz: Oh, no. I wouldn‚Äòt be surprised if it worked well now.
14:52:45 <hyiltiz> too many negatives in ur sentence; not sure if u are for or against trying now
14:53:08 <monochrom> for
14:53:18 <hyiltiz> k trying now; will report back
14:53:23 <monochrom> But you just tried an hour ago :)
14:53:29 <maralorn> hyiltiz: I don‚Äòt want to take any responsibility for you being disappointed now. But it will likely work.
14:53:49 <monochrom> But I think don't be discouraged by 700MB index.tar
14:54:48 <monochrom> Especially since no matter which IDE or editor you use or don't use, you will still have to have space for that.
14:54:52 <maralorn> That being said between cabal, ghcup and nix, stack is the setup that is hardest to get right for the hls people. That's at least the expression I got from their chatting.
14:55:11 <monochrom> Unless you never use cabal, you just "runghc Setup.hs"
14:55:58 <hyiltiz> I tried ghcide not lsp
14:56:47 <monochrom> Ah OK
14:57:02 <hyiltiz> but i have three 700MB index.tar files, which I believe are 99% similar with each other :(
14:57:31 <monochrom> That's abnormal then.
14:57:40 <hyiltiz> Not really complaining about space; I'd be happy to keep a single not redundant 2GB index.tar file
14:58:11 <hyiltiz> Stack keeps two for two GHC versions it seems (index0.tar and index1.tar under ~/.stack/); now .cabal just got another
14:58:30 <monochrom> Ah well. I just have cabal's.
14:58:59 <hyiltiz> Well I purged ~/.cabal now; I guess I'd have to purge ~/.stack instead and get back cabal to have a speaking right here? :-P
14:59:33 <monochrom> Nah, it's up to you whether to use stack or cabal.
14:59:38 <sm[m]> haskell ide setup can easily eat days of your time. Best to get the up to date accurate support from the devs
15:00:38 <hyiltiz> "get the up to date accurate support from the devs" <- yes; but neither haskell wiki or ghc wiki nor emacs/spacemacs/etc. have a single comprehensive source for what to do
15:00:43 <hyiltiz> too many stale docs lying around
15:00:49 * hackage aura 3.1.7 - A secure package manager for Arch Linux and the AUR.  https://hackage.haskell.org/package/aura-3.1.7 (fosskers)
15:01:17 <monochrom> and devs' habit of "I've already written in on github"
15:01:47 <sm[m]> that's what I'm saying, you can't rely on any of that, you have to chat to somebody actively developing it who installed it yesterday and/or might be tempted to debug and fix your hassles
15:02:13 <sm[m]> #haskell-ide-engine is where I'd pester them
15:02:17 <hyiltiz> but i.e. ghcide github readme didn't mention they joined forces with lsp so I'd better go with lsp for less trouble in the future
15:02:47 <hyiltiz> haha~ I'll pester once I try to get lsp working
15:03:58 <hyiltiz> lsp has binaries I can just download; then I'd have to remember to download them a while from now... A ppa or getting their package into Debian would be...
15:04:14 <sm[m]> current status of these things is pretty much unknown AFAICT, even the ide devs are constantly asking each other how it works :)
15:04:57 <maralorn> Just to get this straight: haskell-language-server (short hls) ist ghcide + plugins (like code formatting, etc.), haskell-lsp is the underlying library to speak the language-server-protocol that they use.
15:04:57 <sm[m]> s/how it/what/
15:06:07 <sm[m]> I think it's not yet quite that simple, there has been some parallel ghcide & hls work ongoing
15:06:15 <maerwald> also, enjoy cradle files
15:06:56 <sm[m]> I have the feeling VS Code + latest hls plugin which downloads binaries for you is the current easiest/happiest path
15:07:06 <maralorn> simonmic: Well since ghcide is a core component of hls, ghcide is being actively improved in parallel.
15:07:20 <maerwald> sm[m]: except it lacks a good editor
15:07:33 <sm[m]> yes, but the status is not clear. Eg whose branch are we talking about
15:07:51 <maralorn> I can just say that all of this got _a lot better_ in the last few months.
15:08:15 <maerwald> remember the days without github where ppl used emails and sent each other tarballs or ftp links? I feel communication was better back then
15:08:28 <sm[m]> sure, great work is ongoing. It can still easily eat days of your time, so be warned
15:09:11 <maralorn> simonmic: Well, it ate a lot of days for me. But know it's working quite stable and I am very happy about it.
15:09:33 <sm[m]> congrats! which is your setup now ?
15:10:01 <maralorn> simonmic: It's my understanding that all features get merged into mainline ghcide but the hls dev version uses some slightly more advanced ghcide. But that's only for dev speed reasons and the diff is quite small by know.
15:11:06 <maralorn> simonmic: I use nixos all-in. I just install ghc and haskell-language-server from nixpkgs and that works like a charm and is really easy to setup.
15:13:28 <hyiltiz> Installed lsp binaries downloaded from their Github Release page; put into a dir in PATH. The wrapper can't seem to find the lsp server https://termbin.com/jaba
15:13:54 <sm[m]> I will be more confident in this claim according to the number of others here who can reproduce your success :)
15:16:38 <maralorn> hyiltiz: I think you need to rename that binary with "s/Linux-//"
15:18:29 <hyiltiz> hmm right that was obvious from the error msg; thx!
15:19:34 <maralorn> hyiltiz: Also I think in this case if you only have installed one binary version anyways you can just call that directly.
15:23:14 <hekkaidekapus> maralorn, glguy: The newtype will be released with GHC 9.0, see https://gitlab.haskell.org/ghc/ghc/-/merge_requests/3358
15:24:30 <maralorn> ghc 9.0 will have so many goodies!
15:25:00 <hekkaidekapus> Yes!
15:25:07 <maralorn> Sadly RecordDotNotation wont make it, right?
15:25:22 <hekkaidekapus> I won‚Äôt bite‚Ä¶
15:26:33 <hekkaidekapus> There are prominent voices here that are sceptic about RecordDotNotation, and I tend to agree.
15:28:34 <monochrom> 9 for g for goodies
15:28:53 <hekkaidekapus> lol
15:31:43 <maralorn> hekkaidekapus: Are you sceptical of some detailled design decision or more the general direction of the extension?
15:31:56 <hekkaidekapus> Stealing composition syntax for another syntax that has tons of alternatives in the library and extension spaces.
15:34:31 <maralorn> Ah, yeah. That is a valid concern.
15:37:12 <hyiltiz> Ok I installed hls along with spacemacs (haskell layer, lsp layer, and a use-package chunk), seems to be working though it is jarringly slow
15:37:24 <hyiltiz> still I am satisfied for now
15:44:25 <maralorn> hyiltiz: Is it slow on startup or slow on reaction once started up?
15:44:33 <hyiltiz> both
15:44:52 <maralorn> :-(
15:44:59 <kraeXen> is there any way that I can add more arguments to an operator? eg `a *** b c`?
15:45:12 <kraeXen> I know that I can do `a *** (b, c)`
15:45:30 <kraeXen> but can I do more arguments rather than a tuple?
15:45:37 <monochrom> No way.
15:45:43 <maralorn> hyiltiz: That might be an issue with the emacs specific setup because that is normally very fast for me.
15:45:45 <kraeXen> darn, ah well
15:46:44 <hexagoxel> is there a way to "force-dirty" a package component with cabal so cabal invokes `ghc --make` again on that component, but without doing a clean of that component?
15:46:56 <maralorn> kraeXen: Of course you can. You can make () have the type a -> b -> c -> d.
15:47:26 <kraeXen> new to haskell, please elaborate
15:47:33 <maralorn> Oh, wow.
15:47:40 <maralorn> So first my matrix client stripped out the stars as markup ‚Ä¶
15:47:49 <monochrom> hexagoxel: Perhaps use the "touch" command to force-timestamp some source code file.
15:47:53 <maralorn> And second I reallize that you would need a parantheses.
15:48:14 <hexagoxel> monochrom: yeh tried that, but I _think_ cabal does a content hash-based check
15:48:22 <monochrom> Oh haha.
15:48:35 <monochrom> How about changing whitespace?
15:48:42 <monochrom> (I haven't tried, too lazy.)
15:49:31 <monochrom> Changing whitespace was among the most important tricks I used to catch a TA who gave my model answers to students for cheating.
15:50:10 <maralorn> kraeXen: An operator is a function that takes two arguments, but it can then return a function which consumes more arguments so you could define *** as (***) a b c = <something with a b and c> and then write (a (***) b) c in your code.
15:50:10 <maralorn> But I admit it's not very pretty
15:50:36 <monochrom> I gave my 5 TAs the "same" solution code, but each TA received slightly different spacing, sometimes additional or lacking punctuations in English comments.
15:50:38 <maralorn> Wait, the end had another typo.
15:50:48 <maralorn> (a *** b) c would be correct.
15:51:29 <maralorn> monochrom: Your TA do that??
15:51:35 <monochrom> Yes!
15:52:10 <hexagoxel> monochrom: yeah but then you get diffs too.. I guess there would be ways to hack around that too, but it is a bit ugly.
15:53:01 <hexagoxel> I wonder if deleting/unregistering from dist-newstyle/packagedb is viable here..
15:53:06 <hekkaidekapus> hexagoxel: Pass -fforce-recomp to ghc, see https://downloads.haskell.org/ghc/latest/docs/html/users_guide/separate_compilation.html#ghc-flag--fforce-recomp
15:53:32 <monochrom> That probably is as much rebuilding as "cabal clean"
15:54:14 <hekkaidekapus> Maybe as a module pragma, the recompilation will be less comprehensive.
15:54:15 <maralorn> Would it be possible to do th-stuff like "makeLenses" also with typed template Haskell or is it to restricted for that?
15:54:16 <hexagoxel> hmm but it's an idea: if there is some flag that triggers cabal but that gets ignored by ghc (or does not reach ghc..)
15:56:25 <hekkaidekapus> monochrom, hexagoxel: There is a proposition to have a per-component stanza in cabal.project, that would be neat for this use case. See https://github.com/haskell/cabal/issues/7010
16:26:31 <dminuoso> Mmm, I create a pipe with `System.Process.createPipe` and then connect the read end of it to a sourceConsumer, and then `hPut` into the writer handle... but the conduit is just not yielding anything.
16:26:48 <dminuoso> Is there something special about pipes that wouldn't allow this to work?
16:31:01 <hyiltiz> maralorn: I guess so; the same hls setup with nvim+Coc seems to be quite fast. Something is blocking emacs.
16:32:13 <maralorn> hyiltiz: Yeah, that was my experience.
16:40:18 <hexagoxel> tried a few things, looks like deleting dist-newstyle/build/../mycomponent-myversion/noopt/cache/build triggers a re-build that does not even re-link if nothing has changed
16:40:26 <koz_> What's the kind of Category?
16:40:28 <hexagoxel> (of course noopt depends on -O0)
16:42:18 <koz_> :k Category
16:42:20 <lambdabot> (k -> k -> *) -> Constraint
16:53:04 <hyiltiz> maralorn: somehow setting up hls with nvim (via Coc) also had its hickups (it was minor but was enough to get me looking around for 15+ mins) https://github.com/haskell/haskell-language-server/pull/317
16:54:45 <maralorn> hyiltiz: Thanks for fixing that!
16:54:54 <hyiltiz> Alas coc is based on npm... and somehow it seems the most popular LSP implementation for (n)vim
16:55:49 <monochrom> dminuoso: Very likely the writer needs a flush :)
16:55:55 <maralorn> hyiltiz: Yeah, I don‚Äòt know why either. But I am very satisfied with it. especially in combination with the coc-explorer plugin.
16:56:28 <monochrom> (The perks of teaching this unix course!)
16:56:37 <koz_> :kind! 'Nothing
16:57:05 <monochrom> I think lambdabot doesn't have :kind!. yahb has it.
16:57:19 * hackage assert-failure 0.1.2.4 - Syntactic sugar improving 'assert' and 'error'  https://hackage.haskell.org/package/assert-failure-0.1.2.4 (MikolajKonarski)
16:58:10 <hyiltiz> And I am seriously discouraged by that patreon/donation stuff via WeChat platform
16:58:50 <hyiltiz> Well as I've been warned, already spent way too much time today "catching up" with the "state of the art"
16:59:37 <monochrom> stack, new cabal, and ghcup are worth catching up to.
17:13:11 <maralorn> hyiltiz: I think I never bumped into that because I use the nix toJSON function to generate my coc-config.
17:13:55 <hyiltiz> haha nice! Whenever Nix is mentioned, I feel I grew older a bit
17:19:17 <hyiltiz> and profiling emacs doesn't seem to show anything suspecious about what's making even inserting a newline so slow (only in haskell-mode)
17:19:35 <hyiltiz> but maybe I'll go #emacs for that (if I jump that rabbit hole)
17:23:29 <koz_> I need some DerivingVia shenanigans assistance. I have newtype Foo phant m a b = Foo (ReaderT a (Either SomeErrorType) (m b)). This is clearly a Functor as long as m is, but 'deriving newtype' won't fire on it. What should I derive via to get the instance I desire?
17:26:11 <monochrom> It is somewhat not clear to me as a human.
17:26:48 <koz_> monochrom: That's isomorphic to a -> Either SomeErrorType (m b).
17:26:59 <koz_> So you can fmap through it like, three times.
17:27:53 <monochrom> I am worrying about the part "Either SET (m b)"
17:28:20 <koz_> monochrom: How does this inhibit a Functor instance?
17:28:24 <monochrom> As a human I can work it out mathematically, conceptually, whether it is a functor.
17:28:44 <monochrom> But Haskell does not have a functor instance already made for it.
17:29:18 <koz_> monochrom: It does, in a different formulation, since that's 'Compose (Either SET) m'.
17:29:28 <monochrom> It knows "Either SET". But it doesn't know "functor composition of Either SET and m".
17:29:44 <monochrom> OK, then maybe Foo needs to use Compose.
17:29:57 <koz_> monochrom: Yeah, I'm aware, but just not specifically how.
17:30:24 <koz_> Would it be like, via ReaderT a (Compose (Either SET) m) b?
17:30:33 <monochrom> ReaderT a (Compose (Either SET) m) b.  Yeah, that.
17:30:49 * hackage zenacy-html 2.0.1 - A standard compliant HTML parsing library  https://hackage.haskell.org/package/zenacy-html-2.0.1 (mlcfp)
17:31:42 <koz_> The monochrom Socratic method strikes.
17:31:46 <jle`> is there a common "is uninhabited" typeclass?
17:32:44 <koz_> Boring?
17:32:49 <koz_> No, wait, Intersting.
17:32:57 <koz_> Boring is 'has exactly one inhabitant'.
17:33:07 <koz_> Interesting is 'has exactly zero'.
17:33:20 <jle`> ah, does that exist anywhere :O
17:33:22 <monochrom> I think I haven't heard of a common one.
17:33:24 <jle`> in a common library
17:33:29 <koz_> It does exist.
17:33:36 <koz_> Whether the library is common is up to you.
17:33:40 <koz_> It's a phadej piece.
17:33:42 <jle`> i guess i'll settle with (a ~ Void)
17:33:45 <koz_> That much I recall.
17:35:07 <koz_> NO WAIT
17:35:09 <koz_> It's Absurd.
17:35:21 <koz_> http://hackage.haskell.org/package/boring-0.1.3/docs/Data-Boring.html#t:Absurd
17:35:39 <koz_> "... there are many Absurd products... " ROFL
17:36:13 <koz_> The library's on Stackage I think (boring), so it's reasonably common IMHO.
17:36:46 <monochrom> "very exciting"
17:37:38 <jle`> hm ... seems surprisingly dependency heavy heh
17:37:57 <koz_> You need lots of dependencies to be boring and absurd.
17:38:01 <jle`> but that is the class i'm looking for :O
17:38:06 <koz_> [insert joke about JS]
17:38:14 <plam4u> why "length [1, 2, 3, 4, undefined]" works but "length ([1, 2, 3, 4] ++ undefined)" fails?
17:38:16 <monochrom> Now that's absurd, literally. (The build-depends.)
17:38:20 <koz_> [insert joke about Java]
17:38:26 <koz_> monochrom: But not boring?
17:38:42 <jle`> plam4u: try evaluating it step-by-step
17:38:45 <jle`> and you'll see :)
17:38:52 <nij> Trying my luck here.. anyone uses org-babel?
17:38:55 <monochrom> "This package is very exciting. If you can get it to build without dependency hell, then you're in heaven and you can build any package you want."
17:39:05 <koz_> plam4u: Hint: consider whether you need to evaluate list _elements_ to determine list length.
17:39:07 <jle`> on the high-level the second should fail because it doesn't really have a well-defined length
17:39:09 <plam4u> I did and seems that "++" fails to concatenate the undefined value
17:39:14 <nij> By default, it calls `ghci`. But for my haskell project, I need it to call `cabal repl`..
17:39:20 <monochrom> in fact make it s/heaven/dependency heaven/
17:39:34 <koz_> monochrom: Dependency heaven is what we all wish for.
17:39:35 <jle`> plam4u: you should be able to evaluate ++ all the way
17:39:38 <jle`> @src (++)
17:39:38 <lambdabot> []     ++ ys = ys
17:39:38 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
17:39:38 <lambdabot> -- OR
17:39:38 <lambdabot> xs ++ ys = foldr (:) ys xs
17:39:47 <plam4u> koz_: then, by calling ++ it evalutes the elements?
17:39:48 <jle`> (1:2:3:4:[]) ++ undefined
17:39:59 <jle`> ^ can you simplify that by hand?
17:40:09 <jle`> until it just becomes a bunch of :'s and []'s
17:40:21 <jle`> you'd have to look at the definition of (++)
17:40:32 <jle`> (1 : [2,3,4]) ++ undefined = ??
17:40:43 <monochrom> length doesn't like undefined list.
17:40:44 <jle`> we see that (x:xs)++ys = x : (xs++ys)
17:40:57 <jle`> so (1:[2,3,4]) ++ undefined = 1:([2,3,4]++undefined)
17:41:02 <monochrom> length is only OK with definite list of undefined elements
17:41:28 <jle`> plam4u: ++ works just fine if the right hand side is undefined :)
17:41:53 <jle`> notice it's completely lazy on the second argument, it never touches it at all
17:42:00 <monochrom> If "length (xs ++ undefined)" blows up, it means ++ is working correctly. It's the only way to blow up length.
17:42:21 <plam4u> I'll try to re-read what you wrote a few times... my head is smoking :D
17:42:36 <jle`> plam4u: do you know how evaluation works in Haskell?
17:42:47 <jle`> it's 'evaluation by subsitution'
17:43:02 <jle`> if you want to evaluate a function, you match it up with the branch and fill in the variables
17:43:07 <plam4u> not in details but afaik it applies arguments to functions to simplify as much as it can
17:43:26 <jle`> and then you substitute the body
17:43:34 <jle`> so for example, the function f (x,y) = x + y + y
17:43:39 <jle`> and you want to evaluate it on argument (2,3)
17:43:45 <jle`> to do this, you would see how (2,3) matches with (x,y)
17:43:50 <jle`> and see that x = 2, and y = 3
17:44:00 <jle`> and then you would substitute in `x + y + y`, but replace all x with 2, and all y with 3
17:44:20 <jle`> and that's it :)
17:44:31 <plam4u> got it! evaluation is binding variables to arguments
17:44:42 <jle`> yeah, and the substituing in the body
17:45:01 <jle`> so if i wanted to evaluate [1,2] ++ undefined, i'd look at the definition of (++)
17:45:10 <jle`> and see that it's (x:xs) ++ ys = x : (xs++ys)
17:45:19 <jle`> so (1:[2]) ++ undefined, x is 1, xs is [2]
17:45:26 <jle`> that becomes 1 : ([2] ++ undefined)
17:46:44 <jle`> and if you repeat the same process, you'll get 1:(2:([] ++ undefined))
17:47:03 <jle`> and repeat it all the way, you'd get 1:(2:undefined)
17:47:10 <jle`> so, (++) works fine with undefined, it's not the problem :)
17:47:29 <jle`> the problem is length:
17:47:51 <jle`> length [] = 0; length (_:xs) = 1 + length xs       (pretend this is the definition)
17:48:11 <jle`> try evaluating length (1:2:undefined)
17:48:18 <plam4u> oh, I think I see what you mean
17:48:27 <jle`> using the same process as (++)
17:48:28 <plam4u> when it reaches "undefined" it won't match any pattern
17:48:35 <jle`> right :)
17:49:15 <plam4u> and this works "length [1, 2, 3, 4, undefined]" because the last element is []
17:49:17 <jle`> length (1:2:undefined) = 1 + length (2:undefined) = 1+1+length undefined, but `length undefined` doesn't match any pattern
17:49:22 <monochrom> I wouldn't even call it "length's problem". "length undefined" blowing up is working correctly. That is not a problem.
17:49:26 <monochrom> Where is the problem?
17:49:35 <monochrom> The problem is expectation management.
17:49:46 <monochrom> Expecting magic where there is none.
17:50:38 <plam4u> I guess if you understand what happens and how Haskell works, you would expect it to fail‚Ä¶ but I was really confused
17:50:53 <plam4u> and what jle` showed with the cons operator helps‚Ä¶ I forgot that you can represent it this way
17:51:51 <jle`> monochrom: sure, i shouldn't presumtively judge length. it's only doing its job :(
17:52:02 <nij> Hi.. anyone comfortable with emacs' haskell-mode?
17:52:32 <plam4u> thank you, guys :) I feel very lucky to be here. Every time I feel lost, I receive help from you 
17:52:44 <nij> plam4u: glad you have fun :)
17:52:56 <plam4u> jle`++
17:52:59 <plam4u> monochrom++
17:53:54 <jle`> koz_: digging deeper, i see that there is an entire olegverse
17:54:00 <koz_> jle`: LOL
17:54:09 <koz_> The Phadej Extended Universe.
17:54:16 <monochrom> onoes
17:54:17 <jle`> beginning to rival the kmettiverse
17:54:29 <koz_> So, is Kmett Marvel or DC?
17:54:43 <monochrom> Yes there was an olegverse before there was a kmettverse.
17:56:38 <monochrom> I think it's more like one is Rowling's Wizarding World and the other Peculiar Children world.
17:57:01 <monochrom> DEEP MAGIC
17:59:41 <nij> Q: Is there a way to run `cabal new-repl` without `cabal init`?
18:00:12 <monochrom> Do you already have a *.cabal file?
18:00:25 <nij> nno
18:00:38 <nij> I sometimes want to quickly test a package online
18:00:59 <nij> or quickly test a package that has been installed before with new-style..
18:01:36 <nij> To be quick, I often use `ghci` (old style).. but it doesn't look at new-style package store.
18:01:44 <monochrom> Yes, I forgot the syntax but there is "cabal new-repl <some flag that says you want package foo>"
18:03:17 <nij> Oh it's possibly cabal-env?
18:03:40 <monochrom> No
18:04:43 <monochrom> probably cabal new-repl --build-depends=foo
18:08:50 <nij> Indeed it worked! Yay
18:08:57 <nij> Example usage:
18:09:04 <nij> cabal new-repl --build-depends=Chart
18:09:39 <nij> I can uninstall my ghci...
18:09:48 <monochrom> There is now also a notion of "cabal script", to rival "stack script"
18:10:33 <monochrom> https://cabal.readthedocs.io/en/3.4/cabal-commands.html?highlight=script#cabal-v2-run
18:11:35 <monochrom> This is madness. This is road to hell paved with well intention. Or I'm just a conservative old-geezer.
18:15:23 <nij> Why do people still use stack?
18:15:36 <nij> What is its advantage?
18:15:57 <nij> cabal new style has no dependency issues any more i guess
18:16:12 <nij> and its thinner because it doesn't put packages into each project
18:16:18 <nij> did I miss anything?
18:24:21 <hyiltiz> Well; I'll report back on haskell-language-server+emacs now that I do not intend to continue. Earlier I said hls was slow on emacs (even inserting a newline took too long; it turned out it was emacs's flycheck, and it wasn't even using lsp as its "checker"; instead it was using haskell-ghc so it was irrelevant to hls). I tried following haskell-language-server instruction for emacs, which also asks setting up lsp-mode, lsp-ui and lsp-haskell 
18:24:21 <hyiltiz> packages. They each come with a plathora of irrelevant configurations and, lsp-haskell suggests configuring for haskell-ide (hie) instead of hls. This got too hairy so gave up. Instead, followed my emacs flavor's (spacemacs) advice on https://develop.spacemacs.org/layers/+lang/haskell/README.html. It simply said to enable layers haskell and lsp, and that everything should work out of the box (as long as hls was intalled in PATH). Well, it didn't. 
18:24:21 <hyiltiz> Flycheck didn't detect hls, and manually setting lsp mode or setting lsp as Flycheck's checker didn't work either.
18:25:08 <hyiltiz> So my take is (repeating the wise monochrom): just go with plain haskell-mode and ghcid in a terminal do the yelling.
18:26:08 <monochrom> :)
18:26:31 <hyiltiz> Sorry for the wall of text. With so many development, it is quite disappointing for a user like myself who is willing to read the docs, follow it while fixing the hairy bits to still fail setting up a decent working environment. I bet things were easier back in the old days...
18:26:56 <monochrom> Any sufficiently reliable robust mechanism is indistinguishable from grassroot low tech.
18:29:23 <hololeap> @src foldr
18:29:23 <lambdabot> foldr f z []     = z
18:29:23 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
18:30:16 <hyiltiz> monochrom: Does that mean NASA uses Casio calculators to determine trajectories to shoot people to the Mars? GASPS
18:32:00 <monochrom> Clearly, NASA's most reliable computers predate Casio calculators.
18:33:00 <monochrom> But really, they pulled it off by brute redundancy. Like 4 isomorphic (there!) servers and majority vote.
18:33:15 <fog> so if monoids in the category of endofunctors is Free, whats Cofree?
18:33:37 <fog> whats comonoids in the category of endofunctors got to do with un-nesting?
18:34:17 <ski> "monoids in the category of endofunctors is Free" -- no
18:35:05 <monochrom> And on the software side, they were very serious with testing and code review. To the point even Feymann was impressed.
18:35:09 <fog> is it like monads are like concat, and comonads are like uncons? 
18:35:40 <fog> ie split gives list pattern matching and join gives append
18:36:21 <monochrom> Remember Feynmann's minority report chastising how most departments' QA are a joke? Not so with the software department, Feymann praises they were really rigorous.
18:37:44 <fog> like, i get how join works on trees - and i get how uncons works on lists, so i think i get Free and Cofree
18:38:18 <fog> but i dont get how this is "inductive and coninductive" data, or anything to do with producers or consumers
18:38:49 * hackage swiss-ephemeris 0.1.0.0 - Haskell bindings for the Swiss Ephemeris C library  https://hackage.haskell.org/package/swiss-ephemeris-0.1.0.0 (lfborjas)
18:39:10 <hyiltiz> monochrom: Feynmann? Any reference ("surely you are joking")?
18:39:38 <monochrom> I forgot. One of that series certainly.
18:40:04 <monochrom> Or just go to any public repository that has a copy of the whole report :)
18:40:10 <hyiltiz> hmm ok; 'cuz I think I read that book at least twice and dont recall anything about softwares
18:40:35 <hyiltiz> just nuked my ~/.stack and did stack update to get 1.3G of stuff in there
18:41:01 <hololeap> fog: not sure what you mean. you can use both catamorphisms and anamorphisms on Free and Cofree, so both can be produced or consumed in a recursive way
18:41:21 <fog> Comonadic Notions of Computation Tarmo Uustalu, Varmo Vene
18:41:41 <monochrom> hrm, Amazon may help as a formidable associative memory!
18:42:38 <fog> hololeap: yes, thats true. im not sure why i think someone suggested that way of interpreting monads and comonads
18:43:05 <monochrom> Ah, "what do you care what other people think?"
18:43:52 <hyiltiz> WDYCWOPT didn't mention software either?
18:43:55 <fog> well it depends if it ends up understanding it...
18:44:14 <monochrom> It's in the shuttle investigation "appendix F"
18:44:25 <hyiltiz> There was a very interesting chapter about debugging rockets
18:44:30 <hyiltiz> ok
18:45:19 <fog> "The idea is to use a Kleisli category as the category of impure, effectful functions"
18:46:28 <fog> "instead of producing effects, computations consume something beyond just values"
18:46:52 <fog> costate?
18:47:15 <fog> doesnt sound very pure...
18:47:51 <fog> anyway, im not sure i even understand monads as environments in which to embed effects
18:48:14 <fog> i get how IO acts that way, allowing us to interface with the real world
18:49:10 <fog> but this seems to suggest that while the ways to function affects the environment is monadic, that the function depending on (being changed by) the environment, is comonadic
18:49:34 <fog> and then, im not sure if thats really getting towards initial vs terminal objects which is the thing i dont understand
18:49:56 <fog> or what is inductive vs coinductive data
18:50:09 <hololeap> you can think of a comonad as some "neighborhood" of data where you can focus on a particular datum and view things from its "perspective". a comonad allows you to view all these perspectives at once
18:50:52 <fog> like list as nondeterminism? and a product opperating like a sum?
18:52:19 <hololeap> % :t duplicate
18:52:20 <yahb> hololeap: Comonad w => w a -> w (w a)
18:52:35 <hololeap> % :t duplicate @NonEmpty
18:52:35 <yahb> hololeap: ; <interactive>:1:12: error:; Not in scope: type constructor or class `NonEmpty'; Perhaps you meant `NonEmptyF' (imported from Data.Functor.Base)
18:52:36 <fog> but then, (nonempty) list being a product and not a sum, as a comonad (and a monad).... is it like, !! as a lens gives something like Sum
18:52:57 <hololeap> % :t duplicate @NE.NonEmpty
18:52:57 <yahb> hololeap: ; <interactive>:1:12: error:; Not in scope: type constructor or class `NE.NonEmpty'; No module named `NE' is imported.
18:53:08 <hololeap> % import qualified Data.List.NonEmpty as NE
18:53:08 <yahb> hololeap: 
18:53:11 <hololeap> % :t duplicate @NE.NonEmpty
18:53:11 <yahb> hololeap: NE.NonEmpty a -> NE.NonEmpty (NE.NonEmpty a)
18:53:13 <fog> is it something to do with prisms over list?
18:54:42 <fog> or, like, is the thing more about being able to lens into all locations simultaneously, and then, whats that got to do with duality to monads
18:55:11 <fog> i guess your talking about extract, so then the dual is return
18:55:27 <fog> but then, doesnt the extract normally view over a set position, like the head?
18:55:45 <fog> so it is more like things as the same type as extract...
18:55:55 <fog> as "lookup lenses" 
18:56:03 <fog> to all the various positions
18:56:12 <fog> so the dual thing would be things the same type as return
18:56:23 <fog> which are somehow dual to lookup lenses!?
18:56:36 <fog> :t Right
18:56:37 <lambdabot> b -> Either a b
18:56:45 <fog> monadic!?
18:57:25 <hololeap> fog: yes extract has a set position, but when you combine it with duplicate, you can create the extend function, which is a cokleisli arrow
18:57:26 <fog> also, thats only extract, so thats only like half of the comonad power 
18:57:49 <fog> % :t duplicate
18:57:49 <yahb> fog: Comonad w => w a -> w (w a)
18:57:54 <fog> :% :t extend
18:58:00 <fog> % :t extend
18:58:00 <yahb> fog: Comonad w => (w a -> b) -> w a -> w b
18:58:07 <fog> :t extract
18:58:08 <lambdabot> Comonad w => w a -> a
18:58:43 <fog> @t (>#>)
18:58:44 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
18:58:47 <fog> :t (>#>)
18:58:48 <lambdabot> Comonad w => (w a -> b) -> (w b -> c) -> w a -> c
18:58:56 <fog> :t (>=>)
18:58:58 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
18:59:21 <hololeap> % :t (=>=)
18:59:21 <yahb> hololeap: Comonad w => (w a -> b) -> (w b -> c) -> w a -> c
19:00:07 <hololeap> (well extract isn't exactly a cokleisli arrow, it's more like co-bind)
19:00:07 <fog> ah, so that return or extract type is pretty important
19:00:20 <hololeap> s/extract/extend
19:00:27 <fog> :t extract
19:00:29 <lambdabot> Comonad w => w a -> a
19:00:32 <fog> :t return
19:00:34 <lambdabot> Monad m => a -> m a
19:00:52 <fog> those are the types being composed together by the (co)kliesli arrows
19:01:19 <fog> so i can string together things like Right, as co-lookups
19:01:35 <fog> using (>=>)
19:01:46 <hololeap> Either is not a comonad
19:01:47 <fog> and i can string together lookups using (=>=)
19:01:58 <fog> no thats for monads (>=>)
19:02:31 <koz_> For good reason.
19:02:33 <fog> returns for monads, extracts for comonads, composed by the corresponding (co)kliesli arrow
19:02:42 <hololeap> % :t extend
19:02:42 <yahb> hololeap: Comonad w => (w a -> b) -> w a -> w b
19:03:05 <fog> thats more like cobind, i think cokliesli is the more helpful type
19:03:19 <fog> its the "(co)monoid" in the category of endocuntors
19:03:41 <fog> dont quote me on that
19:03:59 <fog> endofunctors*
19:04:17 <hololeap> think about what extend is doing. it's converting a `w a` to some arbitrary type b, then somehow making this into a `w b`. think about what this means
19:04:56 <fog> well that seems more like the *comonoid* is doing the return-like opperation
19:05:01 <fog> comonad*
19:05:13 <fog> b -> w b
19:05:33 <fog> but then, i guess its hideen as a continuation or something
19:05:49 <dibblego> (Either e) is a semi-comonad though
19:05:55 <fog> :t (>>=)
19:05:57 <lambdabot> Monad m => m a -> (a -> m b) -> m b
19:05:58 <hololeap> there is no `b -> w b` defined for Comonad. think about how it can be done using extract and duplicate
19:06:05 <dibblego> fog: practice with some code.
19:06:12 <fog> this must be hiding an extract similarly
19:06:31 <fog> m (m b) -> m b
19:06:40 <dibblego> fog: here ya go, https://github.com/system-f/fp-course/blob/master/src/Course/Comonad.hs
19:07:20 <hololeap> % :t \f -> extract . fmap f . duplicate
19:07:20 <yahb> hololeap: Comonad w => (w a -> c) -> w a -> c
19:07:49 <fog> im guessing ExactlyOne is like Identity, which seems like a trivial (co)monaod
19:08:01 <dibblego> yes it is, write the code
19:08:02 <hololeap> % :t \f -> fmap f . duplicate
19:08:02 <yahb> hololeap: Comonad f => (f a -> b) -> f a -> f b
19:08:07 <hololeap> that's it
19:08:24 <fog> extract = runIdentity, extend = Identity
19:08:30 <fog> erm, dumplicate*
19:08:44 <dibblego> not here, in a text editor
19:08:56 <fog> excuse me?
19:09:14 <dibblego> next: https://github.com/system-f/fp-course/blob/master/src/Course/ListZipper.hs#L678
19:09:27 <dibblego> text editor? like vim or something
19:10:30 <fog> extract = zipperHead, duplicate = scanner forwards
19:11:06 <hololeap> fog: try implementing duplicate and extend for a few comonads on your own. it will help build your intuition.
19:11:07 <dibblego> Variable not in scope: scanner
19:11:11 <fog> probably would have (. rewind) on the rhs too...
19:11:31 <dibblego> try it with a text editor and compiler
19:11:51 <fog> :t forwards = Zipper a -> Maybe (Zipper a)
19:11:52 <lambdabot> error: parse error on input ‚Äò=‚Äô
19:11:54 <fog> :t unfoldr
19:11:56 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
19:12:19 <fog> :t (((fst.).).) mapAccumL
19:12:20 <lambdabot> Traversable t => (c1 -> b -> (c1, c2)) -> c1 -> t b -> c1
19:12:52 <fog> how is this supposed to help?
19:13:10 <fog> :t scanl
19:13:12 <lambdabot> (b -> a -> b) -> b -> [a] -> [b]
19:13:23 <dibblego> try it with a text editor and compiler
19:13:27 <fog> ah, its an unfold not a scanner, sorry
19:13:36 <fog> unfold forwards
19:13:44 <fog> why, its a one liner
19:13:49 <koz_> Is there a way to spell a constraint on `Rep a` (assuming we have a Generic instance) that amounts to 'I am a record'?
19:14:02 <dibblego> have you tried it with a text editor and compiler?
19:14:11 <fog> i have used these things 
19:14:15 <dibblego> try it
19:14:24 <fog> your being quite pushy
19:14:35 <koz_> Or rather, that amounts to 'a is a record'.
19:14:49 <dibblego> yes, I highly recommend this to address the issues you have raised
19:15:07 <fog> i think i understand enough, as demostrated by the correct answer being given , clearly demostrating sufficient understanding for this to not really help answer a question
19:15:28 <fog> if you could explain why it would help
19:15:43 <dibblego> because you will get an actual correct answer, or you will get stuck and ask for help
19:16:02 <dibblego> it will help you internalise the actual correct answer
19:16:22 <fog> what? why would i ask for help on excersizes you gave me that are not answering anything i asked, which i have already givven sufficent and correct answers to!? 
19:16:48 <dibblego> I do flight instruction on the side. I would typically throw my student in an aeroplane at this point and wish them luck. Cheerio!
19:17:01 <fog> you have not comunicated even which question these are supposed to be answering
19:17:39 <fog> your giving them lessons on how to answer questions or what?
19:18:00 <koz_> Something like this, but in constraint form: http://hackage.haskell.org/package/generic-data-0.9.1.0/docs/Generic-Data.html#v:gconIsRecord
19:19:19 <fog> thanks, thats much more helpful. so its something like observing the duality of record accessors and constructors
19:19:50 <fog> constructors as symbols with which lookup lenses can be derived
19:20:52 <fog> aha, now i get how one of them is seen as data production, and one as data consumption
19:21:03 <fog> this was the problem i was having, perfect
19:21:45 <fog> but then, now there is still a concern about "all the lenses can be used on a comonad" and whats dual to that for monads
19:22:43 <fog> if a list as a comonad has data in all the positions, how is a tree as a monad dual to that in any way? 
19:23:46 <fog> (!! anywhere) compared to (replaceAt anywhere) ?
19:24:21 <fog> so lookup lenses compared to edit lenses?
19:25:33 <fog> and im still confused about this "hidden return" in cobind, and the "hidden extract" in bind
19:26:04 <fog> ah, i guess it never happens because thats just the squashing together or making one into to, of the nestings
19:26:10 <fog> into 2
19:26:20 * hackage swiss-ephemeris 0.1.0.1 - Haskell bindings for the Swiss Ephemeris C library  https://hackage.haskell.org/package/swiss-ephemeris-0.1.0.1 (lfborjas)
19:27:49 <fog> so monad is, i can return inside the monad, and then squash the 2 layers together, and comonad is i can extract after having made 2 layers from 1
19:28:05 <fog> to get bind and cobind
19:29:06 <fog> with it actually just being something "of return type" or "of lookup type". so for the comonad, i can navigate the zipper to anywhere before extracting, ie i can "pointer" to any location
19:29:51 <fog> and instead of it being any simple return for the dual situation in monads, its, anything that produces a list from an initial value
19:29:57 <fog> like, any unfold
19:30:15 <fog> hmm, maybe instead of a pointer lookup i could have a fold inside the comonad after duplicate
19:30:35 <fog> and for the monad, unfold inside the monad before applying join
19:30:59 <fog> maybe this is how one of them is viewed as "data production" and one as "data consumption"
19:31:37 <fog> (w a -> b) is "consuming" the data `a', for comonads. and (a -> w b) is producing data, for monads.
19:31:55 <fog> so now i have the inductive vs coinductive data problem solved too, woot!
19:32:00 <fog> if its not totally mad
19:33:14 <iqubic> This seems correct.
19:36:29 <fog> iqubic: thanks
19:43:50 * hackage swiss-ephemeris 0.1.0.2 - Haskell bindings for the Swiss Ephemeris C library  https://hackage.haskell.org/package/swiss-ephemeris-0.1.0.2 (lfborjas)
20:12:19 * hackage aeson-helper 0.1.0.0 - Aeson helper func  https://hackage.haskell.org/package/aeson-helper-0.1.0.0 (Lupino)
21:09:39 <fresheyeball> is there an easy way to make IO safe?
21:10:13 <fresheyeball> safe :: IO a -> IO (Either SomeException a)
21:11:09 <dmwit> fresheyeball: try?
21:11:21 <fresheyeball> is that good practice?
21:11:25 <dmwit> no
21:11:42 <fresheyeball> what do you recommend?
21:11:51 <fresheyeball> using try in Haskell feels wrong
21:11:55 <dmwit> Figuring out what exceptions your action can actually throw, and handling them.
21:12:17 <fresheyeball> ah, that is fundamentally impossible in my case
21:12:25 <fresheyeball> I will never know
21:13:00 <dsal> :t catch
21:13:02 <lambdabot> Exception e => IO a -> (e -> IO a) -> IO a
21:13:11 <dsal> I guess that's not quite the same.
21:13:42 <dmwit> Then you are probably either writing a library or using the ghc-api. If you are writing a library, let your users handle the exceptions, or force them to tell you what exceptions to catch.
21:13:56 <dmwit> I don't have much experience with ghc-api, so I can't say much about what to do in that case.
21:14:08 <fresheyeball> This is dogshit template haskell madness in ghcjs
21:14:51 <fresheyeball> I don't have a choice though, because no one has taken the time to write a GHCjs JavaScript backend for Text.Regex
21:16:41 <dmwit> Why does TH+ghcjs make it fundamentally impossible to know what exceptions can be thrown?
21:17:13 <fresheyeball> because I am evaling arbitrary javascript code at template haskell time, which in ghcjs is done inside of nodejs
21:18:11 <fresheyeball> If I was writing this as a library, I would include a JavaScript file that does low level sanitization, and makes all of this pure
21:18:43 <fresheyeball> but right now I just want to not have total insanity, and atleast get an Either or something
21:24:10 <iqubic> :t try
21:24:11 <lambdabot> Exception e => IO a -> IO (Either e a)
21:24:27 <iqubic> :t finally
21:24:28 <lambdabot> IO a -> IO b -> IO a
21:25:50 <iqubic> does EitherT exist? Something like "data EitherT e m a = m (Eiter e a)"
21:26:11 <iqubic> Seems like it would useful for error handling in a monadic stack.
21:26:23 <iqubic> *monad transformer stack
21:27:28 <nshepperd1> iqubic: it exists. i think it's called ExceptT now
21:27:51 <iqubic> @unmtl ExceptT e m a
21:27:51 <lambdabot> ExceptT e m a
21:27:55 <iqubic> Hmmm?!
21:28:09 <iqubic> @unmtl EitherT e m a
21:28:09 <lambdabot> EitherT e m a
21:32:11 <fresheyeball> I think ExceptT and EitherT are a little different
21:33:18 <nshepperd1> data ExceptT e m a = ExceptT¬†(m (Either¬†e a))
21:33:54 <nshepperd1> newtype, rather
21:34:39 <jle`> iqubic: unmtlbot comes from a time from before ExceptT
21:34:45 <jle`> @unmtl ErrorT e m a
21:34:45 <lambdabot> m (Either e a)
21:34:53 <iqubic> I see.
21:34:57 <jle`> ErrorT is from the dark times
21:46:20 <dmj`> ErrorT, ExceptT, EitherT oh my
21:47:17 <dmj`> fresheyeball: why not use the browser's regex support and FFI into it
21:49:35 <fresheyeball> dmj`: yes that is what I am doing
21:51:11 <fresheyeball> or rather nodejs's regex support in this case
21:52:04 <fresheyeball> I need to do unsaferPerformIO, and it to be non-excpetional
21:52:15 <dmj`> is node throwing an exception
21:52:23 <fresheyeball> no
21:52:27 <fresheyeball> not yet anyway
21:52:58 <dmj`> you could wrap it in a try and return the result as json
21:53:03 <dmj`> decode it on the haskell side
21:53:18 <dmj`> get an either back
21:53:39 <fresheyeball> makes sense
21:53:47 <fresheyeball> making progress atleast now
21:55:08 <fresheyeball> http://ix.io/2u1P
21:55:16 <fresheyeball> dmj`: if you are curious ^
21:55:22 <fresheyeball> getAll is what I am working on
22:02:34 <fresheyeball> http://ix.io/2u1S
22:02:38 <fresheyeball> This is the error I am getting
22:08:28 <dmj`> https://stackoverflow.com/a/55691566/453261
22:09:40 <iqubic> > fix error -- I hope this fixes fresheyeball's error
22:09:42 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
22:10:05 <fresheyeball> oh hmm
22:10:07 <fresheyeball> let me try that
22:10:58 <iqubic> You may need to import Data.Function
22:12:27 <fresheyeball> Oooo it compiled
22:12:50 <fresheyeball> dmj`:++
22:12:52 <fresheyeball> nice fine
22:12:54 <fresheyeball> nice find
22:13:19 <dmj`> ty
22:14:54 <fresheyeball> yup everything is working
22:14:56 <fresheyeball> nice
22:15:28 <fresheyeball> behold, I now can parse the css classes and id's out of a css file, and export the entire namespace as named variables.
22:15:50 <fresheyeball> and now it works with ghcjs
22:15:52 <fresheyeball> woot
22:15:58 <fresheyeball> me happy for a sec
22:25:14 <iqubic> How's the haskell LSP support looking these days?
22:26:39 <iqubic> Like, is HIE any good?
22:31:20 <sureyeaah> It's descendant haskell-language-server works pretty great!
22:31:24 <sureyeaah> Its*
22:35:00 <iqubic> Oh, haskell-langauge-server is the thing to be using?
22:35:35 <iqubic> What features does it have?
22:42:10 <jchia> iqubic, I use hls in vscode. I get hover tooltip with info about the thing being hovered over, including signature, where it came from, and sometimes link to source code and documentation. it also shows you errors in your code continually
22:42:19 <jchia> there's also autocompletion
22:42:31 <iqubic> fancy.
22:42:50 <iqubic> I'm just using something akin to ghcid in emacs.
22:43:08 <jchia> "akin to ghcid"?
22:43:24 <jchia> not ghcid but something similar?
22:43:46 <jchia> long ago i tried to use ghc-mod then later intero on emacs. too unstable
22:43:51 <iqubic> yeah.
22:44:11 <iqubic> I'm using a thing called dante, which runs ghci in the background.
22:44:34 <iqubic> https://github.com/jyp/dante
22:45:20 <jchia> i c
22:46:13 <sureyeaah> iqubic: hls also has dante style eval
22:46:31 <iqubic> Oh cool. I use that feature a ton.
22:46:40 <iqubic> Is hls stable?
22:47:16 <sureyeaah> Yeah pretty stable.
22:48:07 <iqubic> Do you use hls with emacs? How hard was it to set that up?
22:51:30 <sureyeaah> I use nvim but it should be pretty straightforward to set it up on emacs as well since it's just like any other lsp server. The github repo has instructions on how you can do that.
22:53:54 <iqubic> Cool.
22:55:59 <Graypup_> I had a bit of trouble getting hls to work on $bigProject due to being unable to use latest nixpkgs as ghcjs is broken but using it on the host is also hosed, but it is working fantastically well for my smaller project
23:00:28 <cohelin> Hello, I was wondering if this is a red flag?
23:00:45 <cohelin> ` 
23:00:46 <cohelin>  35,312,511,400 bytes allocated in the heap
23:00:48 <cohelin>    4,200,816,352 bytes copied during GC
23:00:49 <cohelin>       60,337,640 bytes maximum residency (227 sample(s))
23:00:51 <cohelin>        1,933,848 bytes maximum slop
23:00:52 <cohelin>               57 MB total memory in use (0 MB lost due to fragmentation)
23:00:54 <cohelin>                                      Tot time (elapsed)  Avg pause  Max pause
23:00:55 <cohelin>   Gen  0     14734 colls, 14734 par   137.009s  16.311s     0.0011s    0.0538s
23:00:57 <cohelin>   Gen  1       227 colls,   226 par   10.226s   1.142s     0.0050s    0.0361s
23:00:58 <cohelin>   Parallel GC work balance: 71.55% (serial 0%, perfect 100%)
23:01:00 <cohelin>   TASKS: 62 (1 bound, 57 peak workers (61 total), using -N12)
23:01:01 <cohelin>   SPARKS: 0(0 converted, 0 overflowed, 0 dud, 0 GC'd, 0 fizzled)
23:01:03 <cohelin>   INIT    time    0.002s  (  0.003s elapsed)
23:01:04 <cohelin>   MUT     time  225.479s  ( 61.477s elapsed)
23:01:06 <Graypup_> shoulda used a paste website lol
23:01:06 <cohelin>   GC      time  147.235s  ( 17.453s elapsed)
23:01:07 <cohelin>   RP      time    0.000s  (  0.000s elapsed)
23:01:09 <cohelin>   PROF    time    0.000s  (  0.000s elapsed)
23:01:10 <cohelin>   EXIT    time    0.000s  (  0.007s elapsed)
23:01:12 <cohelin>   Total   time  372.715s  ( 78.940s elapsed)
23:01:13 <cohelin>   Alloc rate    156,611,297 bytes per MUT second
23:01:15 <cohelin>   Productivity  60.5% of total user, 77.9% of total elapsed
23:01:28 <cohelin> especially concerned looking at the GC allocated vs copied figures
23:01:56 <cohelin> :Graypup_ sorry i thought it would go as one message, but it didn't!
23:04:14 <Graypup_> the following is apparently illegal: `type Redirect = (Monad m) => Url -> m ()
23:04:14 <Graypup_> `. How do I write it?
23:09:41 <Graypup_> simplified to the actual problem I am having: data AuthFlowConfig m1 m2 = AuthFlowConfig { getPlatformInfo :: (Monad m1) => Issuer -> m1 PlatformInfo }
23:09:58 <Graypup_> "[typecheck] [E] ‚Ä¢ Illegal qualified type: Monad m1 => Issuer -> m1 PlatformInfo"
23:13:25 <Graypup_> I am trying to let the caller decide what monad they want to use for the computation, because I honestly don't care what it is as long as I can bind it (may be going about this completely wrong)
23:13:31 <ski> Graypup_ : depends on what you mean
23:14:02 <ski> hm, i think you want parametrization, that is
23:14:33 <ski> hmm
23:14:34 <Graypup_> ski, callbacks that may fail/do IO/whatever but I don't want to force people into Yesod/a particular implementation
23:15:23 <ski> where did you want to use `Redirect' ?
23:16:09 <Graypup_> I want to take a callback that "redirects to whatever URL" returning nothing, with the framework providing it being a detail of the user
23:16:20 * hackage aeson-result 0.1.0.0 - API Result for aeson  https://hackage.haskell.org/package/aeson-result-0.1.0.0 (Lupino)
23:16:59 <ski> can you show an example type signature where you'd want to use `Redirect' ?
23:17:36 <Graypup_> I want to have a do block that has redirect "theUrlIJustMade" at the end
23:17:53 <Graypup_> and the do block returns ()
23:19:17 * ski looks at Graypup_
23:19:53 <Graypup_> idk what i am doing!! lol
23:20:02 <ski> <ski> can you show an example type signature where you'd want to use `Redirect' ?
23:21:14 <Graypup_> then the answer is "no, I cannot think of one"
23:23:25 <Graypup_> and i am thus giving up on trying to make this independent of any particular web framework because i have deadlines
23:23:27 <ski> Graypup_ : then, what was the relevance of `AuthFlowConfig' to `Redirect' ?
23:23:57 <Graypup_> ski, passing in the details of the framework/harness you're using e.g. for persistent state and HTTP handling
23:24:05 <Graypup_> as one variable rather than several
23:24:57 <ski> `Redirect' isn't mentioned in the definition of `AuthFlowConfig', nor is `Url -> m ()'
23:25:10 <Graypup_> oh sorry, it was above and i forgot to copy it
23:25:42 <ski> or maybe `(Monad m) => Url -> m ()' was meant to be a similar situation as `(Monad m1) => Issuer -> m1 PlatformInfo' ?
23:26:28 <Graypup_> ski, yeah, I moved the definition into the data block to make it clearer, because it was fundamentally the same error, even though i did not understand the meaning of the error
23:26:31 <ski> Graypup_ : i can also ask where (and how) you're wanting to use `AuthFlowConfig'
23:29:18 <Graypup_> getting the fields out of it and using their values as functions in a monadic computation? I'm unsure what you mean
23:30:39 <ski> i'd like to see some context type (presumably signature), in which you're wanting to use `AuthFlowConfig'
23:31:49 <ski> e.g., if it's in a function signature, whether it's in an argument position, or a result position (or both). and what you're passing as parameters, and, in case they're type variables, whether they're constrained
23:35:59 * ski glances in Graypup_'s general direction
23:36:21 <fog> ok i wrote HCofree
23:36:22 <fog> https://gist.github.com/fog-hs/310ac00c0ed211b512af5d875b0b4603
23:36:39 <fog> and better way to write HFree
23:37:33 <fog> i was using the hcontainer corresponding to the fcontainer before, now its the Free container instead (as the type level info)
23:37:44 <fog> this ways much better!
23:38:57 <ski> why not `data FList (f :: k -> *) (xs :: [k])' ?
23:39:00 <fog> the example shows hetrogenous leaf and node trees built from Free and Cofree [] at type level
23:39:40 <ski> `Show' instances are incorrect
23:40:14 <fog> ah, thats an artefact of when it was mapping it to just using nested hcontainers at type level instead of Free
23:40:47 <fog> whats wrong with the show instances?
23:41:22 <ski> they're not emitting legal Haskell syntax
23:41:50 <fog> you mean they are un-Read-able ?
23:42:00 <ski> (and they're not handling precedence correctly, either)
23:42:24 <fog> oh?
23:42:29 <ski> also can't copy their output into the interactor (in an appropriate environment), to yield an equal value
23:42:29 <fog> i cant see why not...
23:42:54 <fog> a Read instance?
23:43:12 <ski> try showing a value of type `[FList f xs]', for some specific `f' and `xs'
23:43:28 <fog> ok, the show instances arent *good* but i dont see how they are not incorrect... it shows i can recurse on the HConstainer, which is the main point
23:43:43 <ski> `Show' instances (as well as `Read' instances) are intended to work together with each other
23:44:28 <ski> because we have `instance Show a => Show [a]', this means that the `Show' instance for lists will interface with your instance .. incorrectly, in this case
23:44:33 <fog> any specific f ?
23:44:39 <ski> any you like
23:45:44 <ski> the `Show' instance for lists will output something like `[ x , y , z ]' where `x',`y',`z' are what's showed by the instance for elements (that is, your instance)
23:45:45 <alehander92> what is a good example of haskell monad code to read
23:45:53 <alehander92> i wonder if i should just read stdlib/common libs
23:46:05 <alehander92> instead of tutorials
23:46:50 <ski> but in your case, `x' (e.g.) can be formatted like `x0 , x1 , x2 ,'. so there's an ambiguity with `,' as used for the list instance and `,' as used for your instance
23:46:56 <fog> skiTest :: [FList 'Pure '[]]
23:46:57 <fog> skiTest = [FEmpty]
23:46:58 <fog> test3 = show skiTest
23:47:11 <fog> *Main> test3
23:47:12 <fog> "[]"
23:47:19 <ski> try an `FList f xs' with more than one element
23:47:27 <ski> also try putting more than one of them, in the list
23:47:30 <Cale> alehander92: I think the most helpful example is to at some point use a parsing monad, and then write/understand the implementation of a simple one (probably a simpler one than a real practical library)
23:47:37 <[exa]> alehander92: std libs may be overkill but many common libs have good examples... I learned most from reading the parsec-style parsers
23:48:05 <fog> :r
23:48:17 <ski> Prelude>
23:48:18 <[exa]> fog: OK we will recompile
23:50:54 <fog> ski: I can just write; show [test1,test1]
23:51:21 <ski> if `test1' has some elements
23:51:48 <fog> *Main> show [test1,test1]
23:51:48 <fog> "[False , 1 , \"hello\" ,  , 3 ,  , ,False , 1 , \"hello\" ,  , 3 ,  , ]"
23:52:51 <fog> *Main> show [test2,test2]
23:52:51 <fog> "[True|2|\"world\"| ,  , 4|5| ,  , ,True|2|\"world\"| ,  , 4|5| ,  , ]"
23:54:07 <fog> i should be able to write HList as HCofree Maybe, and HTree as HFree (HCofree Maybe)
23:54:39 <fog> erm, nonempty
23:55:41 <ski> hopefully you see how the above `show' output isn't helpful
23:55:45 <fog> so that then `HCofree (HCofree Maybe) = HCofree HList' is a hetrogenous "node tree"
23:56:04 <fog> yeah its a bad show instance, but it compiles and displays and shows the datatypes work
23:56:24 <[exa]> fog: do they "work" though?
23:56:32 <fog> how do you mean?
23:56:38 <ski> would be easy to make a correct instance, i think
23:56:54 <fog> how would you like them displayed?
23:57:45 <fog> anyway, i just need it for function nets, and these trees that have branches connecting to the same lower node
23:57:52 <ski> i think [exa] might want to see some problem (not just "I want to use heterogenous trees"), whose solution would call for these types
23:58:12 <fog> to make a network for the scanners to stream data between, sending outputs to particular named functions
23:58:46 <fog> like, a streaming centric function implementation
23:59:04 <fog> like connecting together the arguments to the functions as inputs, with pipes
23:59:35 <fog> then each node has a carry, as the state of the scanner
23:59:45 <fog> and the data feeds in, are processed up
23:59:48 <[exa]> fog: I kindof wanted to express concern that the solution is overcomplicated and won't work any better than plain old arrows
23:59:57 <[exa]> just that you know. :]
