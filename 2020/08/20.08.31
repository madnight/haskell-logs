00:50:02 <Uniaika> int-e: it was related to the PR on bytestring, but nevermind. :)
00:52:10 <dminuoso> Mmm, where in the GHC documentation can I find where GHC looks for headers for `foreign import` statements?
00:54:03 <int-e> Uniaika: ah I stopped following that
01:00:43 <int-e> Uniaika: (assuming it's #258)
01:01:02 <Uniaika> yep, but don't worry :)
01:01:14 <phadej> dminuoso: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/phases.html#ghc-flag--I%E2%9F%A8dir%E2%9F%A9 -- IIRC
01:01:23 <phadej> if it is that, documentation ought to be improved
01:02:26 <dminuoso> phadej: Thank you. Ill give it a try and update the documentation if correct.
01:02:38 <int-e> phadej: last I checked the PR seemed to devolve into "while we're improving the documentation let's make it perfect" territory and I didn't like that.
01:02:46 <dminuoso> I skipped that part in the manual because it seemed as if it applied to CPP #include only
01:03:21 <phadej> int-e: for GHC manual?
01:03:53 <int-e> phadej: hmm. no. overlapping topics, it seems.
01:04:12 <int-e> Uniaika: should've highlighted you instead anyway.
01:05:15 <Uniaika> fortunately it's coming to an end and we're bundling it with the next release. :)
01:05:57 <dminuoso> phadej: I just realized, perhaps looking into how pkg-config in cabal works could help. Presumably it has to turn the pkg config into GHC flags.
01:22:04 <maerwald> [(x, y) | (xs, y) <- zs, x <- xs] -- is this strict in the accumulator? It desugars to monad bind, right? 
01:28:28 <maerwald> I think it uses concat in the end, which is foldr
01:47:37 <kuribas> maerwald: that has no accumulator
01:47:43 <kuribas> it's a lazy list
01:49:32 <maerwald> yes, it's foldr
02:02:46 <kuribas> that's an implementation detail
02:04:33 <maerwald> yes, I was asking for the implementation detail
02:05:22 <kuribas> why do you care?
02:06:13 <maerwald> because I wanted to figure out if it's isomorphic to another construct
02:07:04 <maerwald> while retaining laziness and space properties
02:09:27 <kuribas> AFAIK it desurgars to concatMap
02:12:14 <hc> hmm, a friend just gave me a link to this: https://insights.stackoverflow.com/survey/2020#technology-most-loved-dreaded-and-wanted-languages-loved
02:12:27 <hc> According to it, only 51% of the haskell users love haskell... I wonder why that could be? 
02:14:26 <phadej> obviously because our tooling is just that bad.
02:15:41 <phadej> (i.e. I have no idea, but SO isn't the place where e.g. experienced haskellers hang nowadays)
02:15:47 <phadej> I for example missed that survey
02:16:03 <maerwald> I think it might also be due to burnout from all the extensions and concepts ppl believe you have to know before you are a true haskeller
02:18:03 <hc> Maybe. But I think that's a good thing (don't get burned out, though)
02:18:47 <lortabac> it is surprising to see Rust so highly rated in spite of having probably a steeper learning curve than Haskell
02:19:05 <maerwald> lortabac: it doesn't
02:19:15 <hc> whatever gave you that idea lortabac? ;-)
02:19:18 <lortabac> it seems to indicate that tooling and documentation are the main problem
02:19:23 <maerwald> rust is easier to learn
02:19:49 <lortabac> I personally find it harder, but I guess it's ubjective
02:19:52 <lortabac> subjective
02:19:56 <hc> rust is harder to learn than haskell, if... you already know haskell. *g*
02:20:12 <hc> but maybe not even then
02:21:31 <maerwald> it has fewer concepts
02:22:01 <maerwald> the only really challenging thing is the borrow checker... and even that is a piece of cake compared to understanding evaluation imo
02:22:37 <maerwald> maybe async/futures too
02:22:56 <maerwald> (but you can avoid some of it)
02:23:09 <hc> true. async/await *does* make it harder to learn than haskell. (I loathe nothing as much as the async/await idea in a modern language)
02:24:26 <maerwald> futures was like effects system in haskell for a while
02:24:43 <maerwald> everyone had on opinion, but no one really understood them :p
02:24:46 <lortabac> ok let's forget about the comparison with Haskell, what I meant is that Rust is very high in spite of being a difficult language, probably because tooling and documentation are important
02:25:18 <lortabac> and Rust has good tooling and documentation
02:25:22 <Putonlalla> Rust also has a more powerful hype system.
02:25:34 <lortabac> :)
02:25:50 <hc> haskell has the best documentation available, called #haskell ;p
02:26:10 <maerwald> Mozilla branding is deteriorating though
02:26:38 <maerwald> I think that was a major factor... like "voting"... you want to be on the winner side
02:30:11 <xsperry> Putonlalla, how so? Rust doesn't have higher kinded types, for example
02:30:27 <xsperry> sorry, misread hype as type :)
02:30:40 <maerwald> it's similar :p
02:31:17 <maerwald> what's really better in rust is the macro system... no one likes TH
02:31:40 <Putonlalla> I totally didn't intend to mislead you like that, xsperry.
02:47:22 <Enrico63> Hello there
02:48:10 <Enrico63> How can I actually use the code [here](https://codereview.stackexchange.com/q/90054/152455)?
02:48:48 <Enrico63> It is a module for the Snake game, and it only exports a function, `newGame`. How do I make use of it in a `main`?
02:48:59 <Enrico63> assuming I import it
02:57:54 <tomsmeding> Enrico63: well you can just call it :)
02:58:28 <tomsmeding> though it won't be very useful because it'll give you a Game, which you can't really do anything with outside this Snake module because none of the other functions are exported
02:58:34 <Enrico63> If I `:load Snake.hs` in ghci, I just get a raw representation of the game
02:58:53 <Enrico63> I mean, if I load it and then run `newGame`, which is the only exported function
02:59:26 <Enrico63> So that module is not usable as it is???
02:59:55 <tomsmeding> not really I'd say, because it exports no useful "information" about this type Game, only how to produce one
03:00:05 <tomsmeding> why are you asking?
03:01:14 <Enrico63> Well, I'd like to write my own snake, for the sake of practicing Haskell, and so I searched for a solution to have a vague idea of how to set up the project in terms of module(s), main, whaterver
03:01:27 <Enrico63> but this is not even usable!
03:01:40 <tomsmeding> well you can just export more functions in the export list at the top of the file :p
03:02:06 <tomsmeding> in particular 'step' would be useful to have
03:02:10 <Enrico63> Plus, I see that there are function, like `step`, which are defined but never used...
03:02:24 <Enrico63> maybe they are meant to be used, if exported, by the client clode
03:02:25 <tomsmeding> but I guess for a snake game you also want to show the grid to the player and take input
03:02:25 <Enrico63> code
03:02:32 <tomsmeding> I think so yes
03:06:18 <Enrico63> So, let's say I don't want to make any other changes to the module, expect for adding some more exports; I shoudl export the game (to create one), the directions (to be able to create an instance of them based on the user input), and the step (to advance the snake).
03:07:00 <Enrico63> Then I would also need a way to keep advancing the snake when the user gives no input, which the module does not seem to offer anything about.
03:08:08 <tomsmeding> to create a game, 'newGame' is enough
03:08:27 <tomsmeding> as for advancing when there is no input, I guess you can just use the last used direction
03:09:14 <Enrico63> yeah, but I need to be able to wait for user input a given time, let's say .2 ms, and then move it anyway, and loop in such a logic
03:10:51 <tomsmeding> waiting for user input and doing stuff is a completely different kind of logic than updating a game state :)
03:11:01 <tomsmeding> it's IO stuff
03:11:33 <tomsmeding> do you have experience with another programming language already?
03:12:04 <Enrico63> yes, c++, but I'm still new to programming anyway
03:12:59 <tomsmeding> waiting for user input for some amount of time and doing something else if no input comes; how would you do that in c++? :p
03:13:03 <Enrico63> I understand that the way the snake passes from one state to another has nothing to do with the input/output, but it's not easy for me to start writing something if I don't have a bare idea of a "skeleton" of what I need to do
03:13:30 <Enrico63> in c++ I would use std::async 
03:14:46 <kuribas> I read on stackoverflow that to gracefully terminate a Warp servers, the easiest way is to use an explicit socket, and close it on termination.
03:15:05 <kuribas> It said "it will gracefully terminate all connections".
03:15:08 <kuribas> What does that mean?
03:15:44 <kuribas> It will wait for them to finish?  It will finish but keep the existing connection concurrently?  It will abort them in some way?
03:15:49 <tomsmeding> Enrico63: and if you get a timeout on your std::future, you'd cancel it somehow?
03:16:52 <tomsmeding> Enrico63: in haskell you have https://hackage.haskell.org/package/base-4.14.0.0/docs/System-IO.html#v:hWaitForInput
03:17:20 <Saten-san> Meh
03:17:39 <merijn> kuribas: Sockets can be closed
03:17:48 <merijn> kuribas: Notifying the other side that you are done
03:17:58 <merijn> kuribas: Otherwise the remote side is left waiting for a timeout
03:18:01 <Saten-san> Is skipping over understanding Lambda calculus until I played more with Haskell a problem?
03:18:19 <Saten-san> Because it's the kind of thing you have learn with pen and paper
03:18:19 <dminuoso> Saten-san: No.
03:18:19 <kuribas> merijn: when close, it means the request is aborted?
03:18:34 <merijn> kuribas: Presumably
03:18:40 <Saten-san> dminuoso: I asked this before I guess but I forgot the answer, sorry and thanks for answering :)
03:19:13 <Saten-san> I'm a little too perfectionist and want to make sure I understood 100% of the book.
03:19:28 <Enrico63> tomsmeding, thanks for the link, I'll give a look at it.
03:19:32 <dminuoso> Saten-san: You dropped out the other day, and I think you made some unfair characterizations about CS degrees by the way.
03:20:05 <dminuoso> Saten-san: Anyhow. When you read academic papers, it's perfectly normal that you may only understand 30-40% of it. Make notes of what parts you didn't understand, and proceed. You can always go back and look at it again later.,
03:20:21 <dminuoso> The same thing applies to a book that teaches you Haskell.
03:20:40 <kuribas> dminuoso: that applies to learning anything
03:20:45 <dminuoso> Right!
03:20:49 <Saten-san> dminuoso: Oh really? I thought I just had a really hard time concentrating on books and that I was stupid or something.
03:21:00 <dminuoso> Being stubborn and stopping until you understand a chapter just slows you down.
03:21:08 <dminuoso> Saten-san: Yes. really. :)
03:21:14 <Saten-san> Is using multiple resources that explain the same thing a little different every time also a good idea?
03:21:19 <dminuoso> Sure.
03:22:08 <dminuoso> Saten-san: There's often multiple mind models of explanation techniques. You have to build up your own intuition at the end.
03:22:13 <dminuoso> Just dont give up too early.
03:22:25 <dminuoso> But if you notice you're stuck, just go on without it. Go back later. :)
03:22:33 <kuribas> dminuoso: on the other hand, it also helps when reading difficult texts to work with pen and paper alongside, working out things, trying to find solutions by yourself.
03:22:55 <Enrico63> I'm not a CS, anyway. Studied aerospace engineering, then decided to move away from it, as I liked the feel of programming. Now I am studying from different resources, but I'm working at teh same time. It's not easy to study the way I used to do when I was at the uni
03:23:34 <Saten-san> dminuoso: My biggest struggle is laying down a book and making exercises to be honest because they take so long.
03:24:58 <ph88> how can i get the day of the week as a number from UTCTime ?
03:25:21 <Enrico63> tomsmeding, anyway, in C++ I create a future with std::async, then enter a loop in which I wait_for it, and if it is ready I create a new future with std::asycn, and draw it
03:26:25 <tomsmeding> Enrico63: how deep are you willing to go? :p
03:26:34 <Enrico63> ???
03:26:47 <Enrico63> it's just one loop :/
03:26:47 <tomsmeding> in haskell you can do a similar thing where you have a coroutine getting input, putting it on a channel whenever it gets some
03:27:13 <tomsmeding> well given that you understand std::async in C++ you'll be happy understanding this I think :p
03:28:02 <Enrico63> Well, I needed some help to get the std::async working. To rephrase, I did get what std::async does, but I used two nested loops to achieve the target
03:28:31 <tomsmeding> right, let me have a quick look
03:29:07 <Enrico63> and then when shown the one loop solution, I understood it. BUt I wasn't able to do it myself within one hour
03:30:50 <Enrico63> I'll come back later, but thanks for the link :)
03:33:07 <tomsmeding> Enrico63: https://paste.tomsmeding.com/xjr8LuJA
03:33:18 <tomsmeding> that's a small program that reads lines from input with timeout
03:34:03 <tomsmeding> mind that I'm using Control.Concurrent.Chan here for simplicity; it's generally encouraged to use Control.Concurrent.STM instead, which uses STM and is cool and fancy.
03:34:16 <tomsmeding> you can ask about that separately if you wish :)
03:34:21 <tomsmeding> I'm off for a while
04:09:07 <tomsmeding> @tell Enrico63 https://paste.tomsmeding.com/jd5ZdR8f
04:09:07 <lambdabot> Consider it noted.
04:55:34 <tomsmeding> is it a known issue that the -Wunused-imports warning can be dependent on import order?
04:55:40 <tomsmeding> minimal example: https://gist.github.com/tomsmeding/ef3cca5c4ebec4ea7e72167805d0450c
04:55:47 <phadej> tomsmeding: yes, it's by design
04:55:55 <tomsmeding> ah
04:56:09 <tomsmeding> that's... kind of unfortunate, I guess?
04:56:47 <tomsmeding> is it that if multiple import statements provide the same items, ghc reports none of those as redundant?
04:58:46 <phadej> https://gitlab.haskell.org/ghc/ghc/-/wikis/commentary/compiler/unused-imports#specfication
04:59:40 <phadej> when C is the first import, algorithm marks at as used as cstuff is imported from C
05:00:04 <phadej> it doesn't go extra mile to figure out that it could be imported from B too
05:00:17 <phadej> i.e. doesn't try to find the minimal set of imports which would be enough
05:00:53 <tomsmeding> right, that makes sense
05:00:54 <tomsmeding> thanks!
05:01:37 <phadej> I think it is very sane trade-off. Figuring out truly minimal imports would be expensive (for real world sized modules, 100s of identifiers)
05:01:50 <tomsmeding> very true
05:01:55 <tomsmeding> it was just slightly unexpected for me :)
05:02:06 <tomsmeding> I didn't consider the implementation difficulty in finding a minimal import set
05:02:08 <phadej> and I'd advice to use explicit import lists
05:02:26 <phadej> and at most one "wild" import (Prelude or your own variant)
05:02:47 <phadej> that way you yourself know better where from things are imported from
05:04:18 <phadej> in bigger packages that helps incremental compilation
05:04:44 <phadej> as adding a new symbol somewhere wouldn't necessarily recompile the dependent modules
05:04:49 <tomsmeding> does that help incremental compilation because it entices the programmer to remove unused imports, or does it actively help ghc?
05:05:17 <tomsmeding> that's pretty neat
05:05:25 <phadej> (with open import compiler have to at least check that there is no name clash)
05:05:40 <merijn> tbh, I would advise using explicit import lists for maintainability
05:06:05 <phadej> merijn: I'm pointing out that there are also other benefits
05:06:19 <phadej> maintainability should be obvious :)
05:06:24 <merijn> If you use explicit imports and/or qualified imports than any identifier is either 1) from Prelude or 2) you can search the module to find the definition or import
05:06:38 <merijn> phadej: In my experience it isn't obvious to many people :)
05:06:46 <phadej> many people aren't experienced
05:07:13 <phadej> e.g. haven't worked on a project of size which doesn't fit into one human head
05:07:19 <merijn> phadej: I just mean that it helps to point out why for the less experienced, instead of making them remake every mistake ;)
05:07:51 <phadej> I see how it's hard to believe if you never worked on large enough project
05:07:57 <phadej> e.g. GHC with open imports is just nightmare
05:09:04 <phadej> yet there's a camp which says that tooling will help
05:09:39 <int-e> . o O ( s/will/would/ )
05:10:50 <tomsmeding> I think good tooling would certainly help
05:11:13 <tomsmeding> that statement implies no particular judgement about the difficulty of building said tooling
05:11:32 <phadej> ... but I don't want Haskell become Java, that you *need* tooling to be able to work on Haskell codebases
05:11:56 * tomsmeding reflects
05:12:06 <tomsmeding> I retract my statement
05:12:29 <tomsmeding> I wholeheartedly agree
05:12:32 <merijn> I usually use imports while writing a new module
05:12:54 <merijn> And then when the code starts to settle I just add "()" to my import and see how many compile errors I get :p
05:13:12 <merijn> Then I add those as explicit imports, or I make it qualified (depending on the number of imports)
05:13:17 <maerwald> phadej: I've worked on a large enough codebase and didn't find lack of explicit imports a big issue (but it surely did cause issues)
05:13:31 <merijn> I will usually allow for 1 module/package to be open if I use nearly everything
05:14:04 <merijn> i.e. if I import optparse-applicative or megaparsec in a module I will usually do that open. But since everything else is explicit that doesn't clash
05:14:22 <maerwald> I'm just not sure the annoyance during development (hsimport used to work in ghc-8.0.2, not anymore) outweighs the benefit
05:14:31 <merijn> Simply because qualifying all 50 combinators sucks and writing them out too
05:14:55 <merijn> maerwald: Not even in my suggestion of writing open initially and then "closing up" as it gets closer to finished?
05:15:15 <merijn> I find that works really well
05:15:21 <maerwald> sure, I mean, if the intern does it :p
05:16:42 <maerwald> the fun thing is when you re-arrange imports and an identifier silently swaps its origin, which has the same type sig, but slightly different behavior :p
05:17:04 <maerwald> doesn't happen that often to be paranoid about it, though
05:17:08 <xerox_> how does it work, latter one overcome previous ones?
05:17:09 <merijn> So you've written Scala before? :p
05:17:34 <merijn> xerox_: It can't happen in Haskell (or it's a bug if it does) unless you use OverlappingInstances, I suppose
05:18:17 <maerwald> or just because you made an import qualified and added another one and the other one provides the symbol too
05:18:20 <merijn> xerox_: If you got two imports that aren't the same you get an ambiguous identifier error
05:18:59 <merijn> xerox_: So it can only happen if you delete the original import and add a new one that happens to have the same identifier, with a compatible type, *and* different behaviour
05:19:17 <maerwald> maybe you can use liquid haskell to prove the origin of your identifiers? :p
05:19:35 <merijn> maerwald: GHC already knows the transitive origin for re-exports, iirc
05:19:49 <merijn> So identical re-exports don't affect each other
05:20:28 <merijn> xerox_: This seems like a rare enough problem, doubly so if you use explicit imports.
05:28:56 <maerwald> Is there some trick to make MonadThrow more useful, by having the ability to recover the original Error type?
05:29:42 <maerwald> if you use it with Either, your are stuck with: (e ~ SomeException) => Either e a
05:32:25 <merijn> maerwald: No, because it's not really intended for use with Either or anything pure
05:32:47 <maerwald> that's the only benefit of it
05:33:15 <merijn> maerwald: It's goal (and thus benefit) is to provide a lifted alternative of Control.Exception
05:33:38 <merijn> If you want "pure" exception like Either or ExceptT, then you pretty clearly *don't* want MonadThrow
05:34:39 <maerwald> No, the point is that you can have it convert it to IOException or Maybe/Either depending on the context
05:35:36 <maerwald> Either is too heavy for some APIs
05:37:26 <xsperry> I thought that was the point as well, that the caller gets to pick whehther to have IO exception, Either, Maybe, or a list
05:37:27 <maerwald> I think it's very convenient for that. But so far I've only used it in cases where there's one possible failure anyway
05:37:45 <maerwald> So I don't need to worry about error recovery
05:37:49 <maerwald> But once you do, it gets ugly
05:38:42 <xsperry> typically, I either handle it right at the calling site, in which case I know what exception it is, or I let it fall down deeper, in which case I usually just have to print the error, clean up the mess, and quit
05:38:49 <merijn> maerwald: That might be what you *want*, but it's pretty clearly not the goal of exceptions nor MonadThrow, hence the limited instance
05:38:54 <xsperry> so SomeException is fine
05:39:15 <xsperry> merijn, if that is not the goal, then why have Either, Maybe and List instance of MonadThrow?
05:39:22 <maerwald> merijn: why do you think so?
05:39:29 <merijn> maerwald: I mean, it can't even do anything smart, because the class and throwM both only mention 'm', not the exception type
05:39:39 <Orbstheorem> o/, I just wanted to say that haskell is such a pleasure to work with when it comes to testing wrt python or scala :)
05:39:40 <merijn> maerwald: So it can't have a specific exception type for Either
05:39:53 <merijn> xsperry: Because you can have them, so why not
05:40:42 <merijn> xsperry: I mean, also literally the first 2 lines of documentation in Control.Monad.Catch say this :)
05:42:24 <xsperry> merijn, if it was really not intended to be used with Either or Maybe, then making those instances would be pointless, and misleading. I found those instances useful, and I also found it useful not having to make multiple versions of the same function (one that throws exception, returns Either, etc)
05:42:54 <merijn> xsperry: I'm not saying it's "not intended" as in "you shouldn't do it"
05:43:29 <merijn> xsperry: I'm saying the API was designed with IO exceptions in mind, and wanting to do specific things that only make sense for "non-IO exceptions" isn't well accommodated
05:44:38 <maerwald> I dunno... I was thinking of some trick with Typable maybe
05:45:11 <merijn> That's what SomeException is...
05:45:14 <xsperry> IO exceptoins have the same issue (if you consider it an issue) as Either, you can't get original exception, only SomeException
05:45:22 <merijn> xsperry: Eh
05:45:29 <merijn> xsperry: You *can* get the original exception
05:45:33 <merijn> xsperry: That's the entire point
05:45:45 <xsperry> how?
05:45:50 <merijn> xsperry: You can even do subclassing and catch different exception types
05:45:59 <dminuoso> xsperry: https://simonmar.github.io/bib/papers/ext-exceptions.pdf
05:46:21 <dminuoso> xsperry: This explains how hierarchies of exceptions can be implemented. The base provided exceptions use that hierarchy trick.
05:46:25 <merijn> xsperry: http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.78.205&rep=rep1&type=pdf
05:46:27 <jollygood2> why is this not possible with Either?
05:46:37 <dminuoso> merijn: I win!
05:46:49 <merijn> jollygood2: I mean, if you just write "Either SomeException a" then you can do the same, I guess
05:47:04 <jollygood2> exactly
05:47:12 <merijn> jollygood2: But the original complaint was "wanting something other than SomeException for the Left"
05:47:21 <dminuoso> xsperry: This lets you use exceptions with sort of superclass/subclass relationships you might know from Java.
05:47:34 <dminuoso> So you build up a tree of exceptions, and you can catch an entire branch with it
05:48:01 <merijn> Control.Exception is so much more powerful and flexible than 90% of people give it credit :p
05:48:20 <dminuoso> Sadly a lot of packages dont use this, and build a flat list of `data FooError = FooError deriving Show; instance Exception FooError`
05:48:32 <dminuoso> Which is annoying to work with, since you can't flat out catch exceptions stemming from this package sensibly
05:48:52 <dminuoso> You'd have to know and explicitly catch every single exception. Or you catch too many exceptions.
05:55:54 <timCF> Hi! A small question for TH users. I'm doing macro to derive implementation (unfortunately TH is the only way there). I'm passing type for deriving as Proxy, but I don't know how to lift this type to Q monad to use in declarations. forall does not help. Here is an example without extra implementation details
05:55:55 <timCF> https://gist.github.com/tim2CF/69b8a0b590c624bfb38c8ceb9dbc0e09
06:20:49 * hackage quickspec 2.1.5 - Equational laws for free!  https://hackage.haskell.org/package/quickspec-2.1.5 (NickSmallbone)
06:21:36 <Enrico63> tomsmeding, sorry but I had to leave
06:23:41 <tomsmeding> np, did you get the notification from lambdabot
06:23:42 <tomsmeding> ?
06:48:18 * hackage yesod-page-cursor 1.0.0.0 -   https://hackage.haskell.org/package/yesod-page-cursor-1.0.0.0 (PatrickBrisbin)
06:49:37 <jollygood2> Enrico63, I didn't follow the conversation closely, but I'd prefer async package over messing with channels and forkIO.
06:49:55 <jollygood2> https://hackage.haskell.org/package/async-2.2.2/docs/Control-Concurrent-Async.html
06:52:15 <Enrico63> tomsmeding, got it
06:52:32 <Saten-san> So ... there's substract, div, mod and rem in GHC, but why doesn't Haskell have add and multiply?
06:52:39 <Saten-san> GHC.Real*
06:53:51 <tomsmeding> subtract is there to help with the (- 2) special case syntax
06:54:09 <tomsmeding> div,quot,mod,rem are different operators than / and %
06:54:21 <Saten-san> Damn :/
06:54:29 <tomsmeding> they were never intended to be a full arsenal of arithmetic operators to replace the symbols
06:54:37 <tomsmeding> is there a particular reason why you'd want them?
06:56:03 <Saten-san> No, I was just curious. It just ... doesn't really make sense why you'd give such names to those functions if for example div and / do different things.
06:56:30 <dminuoso> Saten-san: Haskell has a sort of lattice of numerical typeclasses: http://perugini.cps.udayton.edu/teaching/courses/cps343/lecture_notes/images/typeclass.png
06:56:49 <dminuoso> Here arrow denotes a superclass relationship
06:57:40 <Saten-san> dminuoso: Can you send me the full lecture? Links that contain edu always contain some interesting information.
06:58:18 <dminuoso> Saten-san: Well it was just a random thing I googled for. I can't talk about the quality of the lecture: http://perugini.cps.udayton.edu/teaching/courses/cps343/lecture_notes/Haskell.html
06:58:24 <Saten-san> Thanks!
06:59:17 <int-e> @where ﬃ
06:59:25 <lambdabot> http://www.haskell.org/onlinereport/haskell2010/haskellch8.html
07:00:35 <dminuoso> UTF has hardcoded ligature code points?
07:00:37 <dminuoso> What madness.
07:00:59 <dminuoso> Sorry, *ligature characters
07:01:08 <merijn> dminuoso: Yes
07:01:13 <merijn> dminuoso: It's important!
07:01:20 <dminuoso> That seems disgusting.
07:01:30 <dminuoso> Shouldn't ligaturization be a glyph rendering problem?
07:01:35 <merijn> dminuoso: No
07:01:48 <merijn> dminuoso: I suspect Dutch is (one of) the reason for this :p
07:02:21 <Saten-san> merijn: So you really are Dutch :P
07:02:31 <merijn> dminuoso: Since ij is generally treated as one letter. Which means the correct capitalisation of, say, ijselmeer is IJselmeer
07:02:56 <dminuoso> "treated as one letter"
07:02:58 <merijn> dminuoso: Which becomes very hard in software unless you have:
07:02:58 <dminuoso> according to whom
07:03:03 <merijn> > toUpper 'ĳ'
07:03:04 <lambdabot>  '\306'
07:03:17 <merijn> > text [toUpper 'ĳ']
07:03:18 <lambdabot>  Ĳ
07:03:30 <dminuoso> merijn: Here comes the thing though. Does dutch have the notion of ij at all?
07:03:42 <merijn> dminuoso: Well, by allowing it to be written as ĳselmeer, problem gone :p
07:03:43 <dminuoso> Or does that always become ĳ?
07:04:03 <merijn> dminuoso: I don't know of a counter-example off hand, but theoretically it could, I guess
07:04:11 <merijn> If there was a syllable boundary
07:04:21 <dminuoso> Right. Is dutch agglutinating like German?
07:05:03 <merijn> No clue what that is :p
07:05:05 <dminuoso> merijn: In that case then a special character is fine I guess. But it's not a real ligature anymore.
07:05:18 <merijn> dminuoso: "It Depends"
07:05:19 <Saten-san> Strings really did become complex since Unicode didn't they
07:05:30 <dminuoso> ah well, it all boils down to "what does glyph/lexeme/character/ligature" even mean for your language
07:05:45 <int-e> dminuoso: I like to think that FFI is so important that it has its own Unicode point.
07:05:45 <merijn> dminuoso: I was taught ij as a single letter, but apparently in Belgium it never was, and nowadays (apparently) it's not taught as a single letter anymore
07:05:46 <dminuoso> Saten-san: The whole concept is utterly confusing once you want to support more than one particular language
07:05:58 <merijn> Saten-san: Strings were never easy, there was just no way to express them
07:06:00 <dminuoso> Saten-san: Unicode is just an attempt to bind them all in one character set.
07:06:16 <dminuoso> Saten-san: Consider the basic question. Try to define what a string even is.
07:06:21 <merijn> dminuoso: So whether ij is a ligature or not is...tricky
07:06:31 <merijn> I've always counted "merijn" as having 5 letters
07:06:37 <dminuoso> merijn: Now. What is "a letter"?
07:06:48 <int-e> glyph?
07:07:02 <dminuoso> Id rather understand letter as grapheme
07:07:03 <Saten-san> dminuoso: A list af characters according to GHC!
07:07:07 <int-e> . o O ( How many glyphs is ä? )
07:07:09 <dminuoso> And ligatures occur on the glyph level
07:07:14 <dminuoso> That's how I learned it
07:07:23 <dminuoso> int-e: that depends on the font!
07:07:34 <merijn> dminuoso: "it's complicated" :)
07:07:40 <dminuoso> If your wonky-fonky font decides to ligaturize it with the ampersand...
07:08:04 <int-e> dminuoso: As I understand it, the diaresis is derived from a lower case e, so... this is kind of interesting :)
07:08:13 <dminuoso> merijn: I suppose it's still fairly easy for western languages. Once you explore some of the more exotic languages in the asian continent, this gets even more messy
07:08:29 <dminuoso> (or maybe in the central/southern american continents)
07:09:16 <merijn> dminuoso: Just for fun, *sometimes* ü is an "u + umlaut" in Dutch, but sometimes it's u with diaeresis :p
07:09:50 <merijn> (I'm not aware of a word where it's diaeresis, but I'm sure I could come up with one if pressed
07:09:57 <dminuoso> merijn: Oh hah. We dont have diaeresis in German, so ü is just an umlaut.
07:10:04 <dminuoso> But it gets more interesting when you write ue.
07:10:08 <maerwald> dia-what?
07:10:21 <merijn> dminuoso: We only have umlaut for words stolen from German :p
07:10:33 <merijn> maerwald: https://en.wikipedia.org/wiki/Diaeresis_%28diacritic%29
07:10:38 * maerwald tried to push down a joke
07:11:01 <dminuoso> merijn: So ü for example is definitely not a ligature for ue, because ue can occur like that separately. Do you also write it as 'ue' in a system that doesnt have umlaute?
07:11:21 <merijn> No, because there's only, like, 2 words with an umlaut :p
07:11:26 <dminuoso> Haha
07:11:29 <dminuoso> Which one are those?
07:11:38 <merijn> We stole überhaupt
07:11:45 <merijn> Because it's just so darn useful
07:11:49 <dminuoso> Ich mag das überhaupt nicht.
07:12:26 <int-e> Meh they're different? I used the wrong term then.
07:12:28 <dminuoso> merijn: at any rate. writing textual libraries is so utterly complicated, because you get to non-trivial problems so quickly. Like... "length of a string". What does that even mean?
07:12:32 <tomsmeding> merijn: geüpdatet?
07:12:37 <dminuoso> It's highly language and possibly context dependent.
07:12:42 <merijn> With pretty much the exact same untranslatable "half contradicting" meaning :p
07:12:48 <merijn> tomsmeding: ooh, good one!
07:13:01 <dminuoso> tomsmeding: wait is that a word?
07:13:01 <int-e> tomsmeding: no, geupdäted.
07:13:07 <merijn> int-e: Nope
07:13:10 <merijn> Sadly
07:13:13 <dminuoso> That sounds almost Swiss.
07:13:16 <merijn> I refuse to spell that correctly
07:13:19 <tomsmeding> which also has the most atrocious spelling ever
07:13:21 <tomsmeding> yes
07:13:40 <dminuoso> tomsmeding: Do Dutch keyboards therefore waste 3 keys on umlauts just so you can write those words once in a year?
07:13:44 <tomsmeding> because it's a loan word from English that we messed up and applied dutch conjugations to
07:13:47 <merijn> dminuoso: It's the past participle
07:13:48 <tomsmeding> no
07:13:53 <tomsmeding> normal people use dead keys
07:14:15 <int-e> At what length or thickness does a string turn into a rope?
07:14:20 <dminuoso> merijn: I presumed as much. It made enough sense as German even.
07:14:20 <merijn> dminuoso: Also, while umlauts are almost nonexistent diaeresis are common
07:14:20 <tomsmeding> non-normal people like me instantly become insane when having dead keys on while programming, so resort to altgr combinations
07:14:38 <dminuoso> Well I just use US layouts.
07:14:52 <dminuoso> And switch between US and DE depending on whether I write emails or not
07:15:05 <tomsmeding> I just use US layouts always :P
07:15:06 <int-e> tomsmeding: dead keys are a nightmare
07:15:15 <merijn> dminuoso: Since there is a distinction between single vowels and diphtongs so you need diaeresis to correctly pronounce many words
07:15:17 <int-e> they should be taken out and shot
07:15:35 <merijn> dminuoso: coöperatie, zeeëendenei :p
07:15:39 <dminuoso> merijn: Haha, in German you are expected to just *know* 
07:15:43 <dminuoso> We dont bother writing it out.
07:16:07 <merijn> I think usage is slowly dying out
07:16:10 <dminuoso> Probably part of an ancient culture to keep Germany clean by making it as hard as possible to migrate here.
07:16:12 * jkaye[m] sent a long message:  < https://matrix.org/_matrix/media/r0/download/matrix.org/pkapfsDPwKmAyGUmtUxkLIXm/message.txt >
07:16:13 <merijn> but "proper" text has it
07:16:17 <dminuoso> </sarcasm>
07:16:30 <dminuoso> merijn: Ah, so its optional?
07:16:33 <merijn> dminuoso: No
07:16:36 <merijn> dminuoso: Well
07:16:48 <merijn> dminuoso: Depends if you're a prescriptivist of descriptivist? ;)
07:16:48 <tomsmeding> prescriptivists say it's not optional
07:16:50 <int-e> Hmm... Reinfall. Reintegration.
07:17:02 <tomsmeding> descriptivists would say that people are omitting it sometimes :p
07:17:17 <tomsmeding> I mean, people omit accents and stuff in french too in informal typing
07:17:28 <tomsmeding> doesn't mean that they are officially "optional"
07:17:29 <maerwald> dminuoso: careful with those jokes, given what's going on in Berlin :p
07:17:33 <int-e> Also, this channel has the weirdest discussions sometimes.
07:17:47 <merijn> @quote as.much.as.orbit
07:17:47 <lambdabot> No quotes match. There are some things that I just don't know.
07:17:49 <merijn> aww
07:17:54 <dminuoso> maerwald: Oh I made jokes about that just today! 
07:18:07 <maerwald> yeah, but ppl on the internet like to get offended :)
07:18:07 <int-e> All I wanted was to check that I didn't completely break @where while editing the database.
07:18:09 <dminuoso> maerwald: Are you German?
07:18:17 <merijn> @quote DRMacIver orbit
07:18:17 <lambdabot> DRMacIver says: #haskell doesn't so much wander off topic as orbit it. :)
07:18:28 <maerwald> dminuoso: is that a micro-aggression? xD
07:18:37 <dminuoso> No, just curiosity why you're up-to-date with German politics.
07:18:41 <int-e> And the ffl-ligature entry happens to be the last one.
07:18:46 <merijn> dminuoso: Healthy paranoia? ;)
07:18:46 <maerwald> yeah, unfortunately
07:18:55 <int-e> (they're sorted "lexicographically")
07:19:01 <dminuoso> merijn: haha.
07:19:26 <dminuoso> Honestly with what's going on, Berlin would be the last of my worries if I wanted to grow in international paranoia.
07:20:05 <merijn> dminuoso: Need to keep up to date when bicycle jokes start risking diplomatic incidents online :p
07:20:06 <dminuoso> int-e: Oh yes! That's an interesting question, are all languages grapheme sets totally ordered?
07:20:07 <Enrico63> I was looking for a way to read every character given in input, without the need of pressing enter. I have found this (https://stackoverflow.com/a/2983984/5825294), however, which says that's not possible because of a bug
07:20:10 <int-e> > sort ["ffi", "ﬃ", "ffl", "ﬄ"]
07:20:12 <lambdabot>  ["ffi","ffl","\64259","\64260"]
07:20:36 <int-e> I think lexicographers would object to that order :)
07:20:47 <merijn> Enrico63: "GHC 6.8.2" <- 6.8 is *ancient*
07:20:56 <merijn> Enrico63: That's, like, prehistorically old
07:21:01 <dminuoso> Enrico63: You need to run in raw mode. The easiest way to deal with this is using haskeline.
07:21:21 <int-e> dminuoso: I don't know? I suspect that with the advent of computers, they are totally ordered now, quite possibly with competing standards for some languages.
07:21:32 <dminuoso> (The reason you'd normally need <enter> is because in cooked mode, you have a line editor that runs between your program and the terminal)
07:21:38 <merijn> dminuoso: pfft
07:21:45 <Enrico63> I have 8.10.2
07:21:48 <int-e> merijn: I changed a path from /opt/ghc-7.6.3 to /opt/ghc-8.10.2 today ;)
07:21:51 <merijn> dminuoso: Dutch lexicographic ordering depends on what you're ordering :p
07:22:00 <dminuoso> merijn: Hah! Go on!
07:22:00 <int-e> (+/bin)
07:22:43 <merijn> dminuoso: "tussenvoegsels" in names are disregarded when sorting names, because else half the country would be sorted with 'd' or 'v' :p
07:22:53 <int-e> But sadly I realized that mueval is somehow broken so lambdabot is still on 8.8.1.
07:22:57 <dminuoso> What is a tussenvoegsel?
07:23:07 <tomsmeding> think "Van Gogh" and "De Bruijn"
07:23:09 <merijn> dminuoso: the "of", etc. in names
07:23:13 <merijn> Yeah, those :p
07:23:14 <dminuoso> Ah
07:23:26 <merijn> Van Gogh would be filed under G and De Bruijn under B
07:23:56 <tomsmeding> also name capitalisation where it's Nicolaas de Bruijn, but De Bruijn
07:24:07 <merijn> Also, note that, despite literally all those damn computer scientists citing him as "de Bruijn" de correct capitalisation is "De Bruijn" :p
07:24:13 <tomsmeding> ^
07:24:15 <merijn> jinx
07:24:34 <merijn> Pet peeve of mine
07:25:06 <dminuoso> Natural languages just suck. Like JavaScript, they are balls of unprincipled constant organic growth. While standardization attempts are made, there's enough descriptivists that just rely on "but it works on my machine"
07:25:12 <merijn> I have annoyed several people into updating their tutorials :p
07:25:40 <merijn> dminuoso: People suck ;)
07:25:56 <tomsmeding> difference is that JS is JS' fault but languages are no-one's fault
07:26:12 <dminuoso> tomsmeding: I dont think JS is anyones particular fault either.
07:26:19 <tomsmeding> and if it should be someone's fault, it's our fault for not even understanding the way we speak well enough to be able to model it adequately :p
07:26:19 <Enrico63> tomsmeding, I've saved your code in a safe place, but before looking at it I want to try doing something myself first, with some minor help
07:26:25 <merijn> tomsmeding: I'm sure we can pin the high consonant shift on "someone"
07:26:52 <dminuoso> But really, I think there are interetsing parallels between natural languages and these unprincipled organically grown languages like JavaScript or Python. And I say this without criticism.
07:27:23 <merijn> Anyway, I need to bail on this discussion or else my writing will go nowhere :p
07:27:36 <JavaSucksMan> @merjon We could avoid these problems if we just number all the computer scientists ;-)
07:27:37 <lambdabot> Unknown command, try @list
07:28:01 <hekkaidekapus> Hi there. In case you have a few minutes to spare, please go to <https://paste.centos.org/view/6f6e093a>. I would like to ask you: “How hard would it be for you to add a new version of one of ⦃GHC, cabal-install, ghcup⦄ to the mix?” This is for an accointance of yours, maerwald :p
07:28:59 <maerwald> I knew the dhall ppl wouldn't stop :p
07:30:02 <hekkaidekapus> hahahahha…
07:30:18 <maerwald> to me this is 5 times more complicated than the original yaml :>
07:30:29 <hekkaidekapus> This is an exercise in futility, but let’s have some fun!
07:30:48 <hekkaidekapus> maerwald: Give it a read!
07:30:52 <dminuoso> Cant you just... write a simple piece of haskell code that outputs yaml?
07:31:09 <maerwald> dminuoso: I did that and it's more annoying
07:31:33 <hekkaidekapus> dminuoso: Configuration as code?
07:31:51 <hekkaidekapus> or vice versa?
07:32:47 <dminuoso> Well, if all you need is a tool to *add* something, surely we can think of a tool that parses the yaml into some structure, makes the modification, and writes it out again.
07:33:28 <maerwald> or... just edit the damn yaml
07:33:50 <maerwald> hekkaidekapus: it sure looks clever
07:34:12 <maerwald> so how do you sync the types between the codebase and dhall
07:34:25 <hekkaidekapus> dminuoso: Let’s call that tool Dhall. It has built-in types (schema), it infers them for you and will enforce your config against them.
07:35:04 <dminuoso> hekkaidekapus: Ive never looked into Dhall, so I cant comment on that.
07:35:30 <hekkaidekapus> maerwald: You run `dhall --annotate` and you put the output type into the haddocks, Haskell side.
07:36:07 <maerwald> hekkaidekapus: huh?
07:36:44 <hekkaidekapus> It’s just a bunch of records or Maps, nothing too difficult.
07:37:03 <maerwald> I mean, "architectures" is already out of date in the dhall config
07:37:11 <maerwald> so how do you know that happens
07:38:26 <hekkaidekapus> I didn’t do a 1-1 conversion. That sample is to give a gist of how things would be in another world.
07:38:46 <maerwald> so you have to duplicate the types manually?
07:40:24 <hekkaidekapus> No, there is an `instance FromDhall` for records, maps, lists,…
07:41:32 <maerwald> and then it uses TH to insert it into my code?
07:41:33 <sm[m]> jkaye: apparently not right now.. you could try again in a bit, or try the mail list, or look at what comparable packages on hackage do if you haven't already
07:43:41 <jkaye[m]> sm: Thanks.. A decent portion of that 3-4 hours I've spent was looking through source of other packages. The mailing list might be a good bet. 
07:43:43 <hekkaidekapus> maerwald: No, just some {-# LANGUAGE DeriveAnyClass, DeriveGeneric, DerivingStrategies … #-} incantations.
07:43:54 <maerwald> I still don't get it
07:44:18 <maerwald> Maybe provide a full PR that shows how to maintain the pieces
07:45:02 <hekkaidekapus> If you mean “I want to avoid Template Haskell at all costs”, you can.
07:45:28 <maerwald> I'm more worried about additional maintenance burden
07:45:48 <maerwald> I don't care about elegance if elegance causes more work :)
07:46:17 <hekkaidekapus> Before a full-fledged PR, let’s see if we can find some merits to the approach.
07:46:46 <maerwald> sounds like a discussion suited for the issue tracker
07:47:42 <hekkaidekapus> About maintenance: last time, you were only worried about linting and ease-of-modification.
07:49:07 <hekkaidekapus> In all probability, potential contributors would be Haskellers. I wanted to have a glimpse of Haskellers’ thoughts as with regard to ease-of-modification.
07:58:10 <maerwald> how many haskellers know dhall?
07:59:03 <hekkaidekapus> It shouldn’t matter, I think.
07:59:49 <hekkaidekapus> Contributors should be able to come up with a hash for a GHC release, and add it to the boilerplate.
08:00:30 <maerwald> basically needs a walkthrough :p
08:01:44 <hekkaidekapus> If we agreed that Dhall was a viable option, that expression could be split into small, self-describing sub-expressions.
08:02:58 <hekkaidekapus> For instance, `ghc-9-2-0.dhall` comprised of a begetGhc for that version.
08:03:10 <hekkaidekapus> Very easy, isn’it?
08:03:30 <hekkaidekapus> No need to read the whole thing.
08:06:04 <maerwald> providing a proper PR wouldn't be much work then?
08:07:27 <hekkaidekapus> I will find a way to ping the contributor who was very eager to introduce Dhall and let them take the wheel.
08:08:09 <hekkaidekapus> Thank you for considering the option.
08:34:54 <cohn> hopefully a silly question. If I have a function that takes a tuple inside a Monad, how do I "destructure" the tuple to get the values?
08:35:41 <dolio> `(x,y) <- arg` in a do block
08:36:11 <ovitus> was wondering if somebody might help me out creating a function from a boolean list?
08:36:31 <ovitus> say I have a boolean list: [1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1]
08:36:45 <ovitus> how can I calculate the steps between each "true" value?
08:36:47 <cohn> dolio: thanks! 
08:37:05 <ovitus> so the output of that would be: [2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 1]
08:37:36 <cohn> dolio: how would I do that without using a do block?
08:37:58 <dolio> `arg >>= \(x,y) -> ...`
08:39:42 <cohn> ossum!
08:43:09 <[exa]> ovitus: that looks like a list of integers, but okay.. :]
08:43:54 <[exa]> ovitus: I understand that the steps between each "true" value is including the true value on the beginning, right?
08:44:24 <ovitus> yes, it wraps around
08:44:32 <tomsmeding> > tail . catMaybes . snd . mapAccumL (\a x -> if x /= 0 then (0, Just a) else (a+1, Nothing)) 0 $ [1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1]
08:44:35 <lambdabot>  [1,0,1,0,1,0,1,0,1,0]
08:44:44 <tomsmeding> > map succ . tail . catMaybes . snd . mapAccumL (\a x -> if x /= 0 then (0, Just a) else (a+1, Nothing)) 0 $ [1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1]
08:44:45 <itai33[m]> I have an element `x :: a` and  `xs :: Vector a`. If `x` isn't in `xs` I want to add it at the end, and if `x` is in `xs` I want to drop it from `xs`. Is there a good way to do this? I feel like if they were lists I just write it in patter matching but 1. I would like to keep them as vectors since the list will mutate a lot and 2. I feel like there is some way to do this with traverse that I'm missing 
08:44:46 <lambdabot>  [2,1,2,1,2,1,2,1,2,1]
08:45:01 <tomsmeding> ovitus: like that? ugly though :p
08:45:32 <[exa]> I think we can do with splitAt or something
08:45:39 <tomsmeding> > tail . catMaybes . snd . mapAccumL (\a x -> if x /= 0 then (1, Just a) else (a+1, Nothing)) 1 $ [1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1]
08:45:41 <lambdabot>  [2,1,2,1,2,1,2,1,2,1]
08:45:42 <tomsmeding> less map succ
08:45:52 <ovitus> close, but that's just 10 of the steps?
08:46:44 <[exa]> ovitus: combine this https://hackage.haskell.org/package/extra-1.7.7/docs/Data-List-Extra.html#v:split with `map length` and increase by 1, shold just work™
08:47:11 <tomsmeding> oh right you want the thing to wrap around
08:47:47 <monochrom> We usually don't expect succ or pred to wrap around.
08:48:08 <monochrom> Or more positively, we expect succ to error out at the max.
08:49:05 <monochrom> But you get to say this is just a social construct and you don't have to oblige. You also get to say if no one else will use your code anyway why not.
08:49:21 <tomsmeding> ovitus: what's it supposed to do given [0, 0, 0]
08:50:28 <tomsmeding> itai33[m]: appending an element to the end of a Vector is slow though
08:51:08 <tomsmeding> (well, appending to the end of a list is also slow, but okay :p)
08:51:19 <ovitus> I think that would just be 3
08:52:53 <ovitus> these are Euclids, the example I gave was (11,16)
08:54:16 <itai33[m]> tomsmeding: yeah i forgot, in vectors access to middle elements is fast but appending is still slow
08:55:02 <itai33[m]> still though, I feel like there has to be a good functional way to do this, and the speed concerns are probably not that important
08:56:36 <monochrom> Perhaps don't use arrays or linked lists at all. Use a binary search tree.
09:00:51 <[exa]> itai33[m]: Data.Seq ?
09:01:43 <monochrom> It is still annoying that looking for an occurence is still brute-force search.
09:01:58 <monochrom> In front of that, linear-time append and delete are nothing.
09:02:25 <monochrom> If you have to search, you immediately rule out linear data structures altogether already.
09:03:22 <monochrom> Either that, or you set a low bar and merely avoid quadratic time.
09:03:28 <MarcelineVQ> linear in the sense of singly linked list access?
09:04:02 <itai33[m]> wait I have been going about this wrong,  I Just want to keep track of a specific subset of a list, it would be a better to annotate each element as either in the subset or not that to create the second list
09:04:06 <monochrom> Yes, but growing an immutable array by 1 also takes linear time. Deleteing something in the middle too.
09:04:37 <kaol> How would I check in code whether it's being run as compiled or via ghci?
09:05:04 <monochrom> Err I understand the question now. linear as in sequential.
09:06:27 <monochrom> "I have an array/[]/Seq, my operation begins with looking for x in the array/[]/Seq, and then if..."  Stop right there, you have already lost.
09:08:43 <kaol> I have a heavy non-essential background thread that I'd rather leave aside with ghci. It's one line change to code to enable/disable it but I'd like to do away with that.
09:09:39 <monochrom> System.Environment.getProgName may give you a clue you may or may not trust.
09:11:06 <kaol> Thanks. It's good enough for development use, I'll force the setting for production.
09:16:01 <itai33[m]> "monochrom" (https://matrix.to/#/@freenode_monochrom:matrix.org) what do you mean lost?
09:16:46 <monochrom> You have lost the efficiency war. Even academically.
09:17:30 <Orbstheorem> Hi, I'm having an issue with some overlapping instances. I've assembled some notes here: https://paste.gnugen.ch/raw/ic9q
09:24:24 <lyxia> Orbstheorem: make TestOpts a superclass of Foo?
09:24:55 <sm[m]> from the tooling-fail department: several failures attempting to install cabal-install, https://termbin.com/j8hd
09:25:25 <sm[m]> pretty sure I also did a cabal update a day or two ago
09:25:49 <Orbstheorem> lyxia: TestOps is test code (in the test module) whereas Foo is "production". I'd find it super weird to have production code be a function of the tests.
09:26:05 <maerwald> sm[m]: don't install cabal-install via cabal-install :p
09:26:34 <sm[m]> haskell newcomer> "that's stupid" :)
09:26:40 <maerwald> yeah
09:26:48 <sm[m]> seriously, I've done it many times.. shouldn't it work ?
09:27:05 <maerwald> but can you install stack that way?
09:27:14 <sm[m]> stack can upgrade itself.. cabal just didn't today, I'm not really sure why
09:27:28 <maerwald> no, I am talking about "cabal install stack"
09:27:49 <sm[m]> sure, you can do that
09:28:59 <sm[m]> incidentally, to whom it may concern, Cabal has been added back to stack recently which is good but cabal-install is also needed
09:29:06 <sm[m]> s/stack/stackage/
09:29:32 <maerwald> I think there's an upstream issue, phadej would know
09:29:56 <sm[m]> actually, maybe adding Cabal to stackage is enough for "stack install cabal-install" to work
09:30:19 <sm[m]> still, no harm to add it, some distros use stackage as basis for packaging
09:30:35 <phadej> I'm confused, what you are trying to do?
09:30:45 <maerwald> phadej: cabal install cabal-install
09:30:55 <maerwald> I remember that didn't go well with 3.2
09:31:11 <sm[m]> phadej: I was trying to upgrade cabal-install and saw some unexpected failures. The rest is just FYI
09:31:44 <phadej> cabal install cabal-install may or may not work. Don't use.
09:31:55 <sm[m]> FGeneralInterest. Not Yours specifically since :)
09:32:48 <sm[m]> now I'm curious, it didn't fail me before.. why would it not work ?
09:33:05 <sm[m]> starting with a decently modern cabal-install at least
09:34:29 <phadej> it should work, I'd just advice to upgrade cabal in the way you first installed it
09:34:48 <phadej> fwiw stack's self-upgrade downloads binaries
09:34:56 <phadej> so it doesn't (by default) build itself eithere
09:35:12 <sm[m]> yes
09:35:22 <sm[m]> though it can, of course
09:35:27 <phadej> you don't build yourself new GHC versions either...
09:35:39 <phadej> I suspect, cannot know for sure
09:37:02 <maerwald> there was a reddit thread asking why `cabal install ghc` is not a thing :p
09:38:31 <sm[m]> ok looking closer at the error output, it seems the problem is cabal-install-3.2.0.0 doesn't want to be built with ghc 8.10
09:38:36 <sm[m]> (base 4.14)
09:39:14 <sm[m]> guess it'll be resolved in due course
09:39:36 <cohn> dolio: can't seem to get your solution to work. pm?
09:39:49 <maerwald> sm[m]: how did you install cabal in the first place?
09:40:49 <sm[m]> I don't remember, I've installed it a bunch of times - one of: homebrew, haskell.org/cabal binary, stack install cabal-install I expect
09:40:53 <[exa]> cohn: pastebin your current code?
09:41:14 <sm[m]> if I'd remembered homebrew I'd have reached for that first
09:41:14 <cohn> sure
09:43:05 <cohn> [exa]: https://pastebin.com/iKaL3BN5
09:43:34 <cohn> [exa]: basically trying to take the max of 2 values in a tuple contained in a Monad
09:43:45 <[exa]> cohn: okay val1 returns a pair (1 value), which you try to match to 2 values
09:44:06 <[exa]> cohn: you literally want val >>= \(x1,x2) -> ...
09:44:59 <cohn> ok, so maxPairM val >>= \(x1,x2 -> return (max x1 x2))
09:45:07 <[exa]> cohn: PRO version: maxPairM = fmap (uncurry max)
09:45:22 <cohn> haven't learned currying yet
09:45:23 <[exa]> cohn: it needs the () around (x1,x2)
09:45:23 <cohn> ; )
09:45:40 <[exa]> in fact you're kinda learning it now :]
09:46:01 <cohn> haha, true!
09:46:58 <cohn> still not working. argh
09:47:17 <cohn> [exa]: here's what I have:  maxPairM val >>= \(x1,x2) -> (return (max x1 x2))
09:48:03 <maerwald> snap-core doesn't build on windows? https://bsd.to/ohjV/raw
09:58:09 <monochrom> Best of both worlds: fmap (\(x1,x2) -> max x1 x2) val
10:00:53 <cohn> monochrom, [exa]: fixed it:  maxPairM val = val >>= (\(x1,x2) -> return (max x1 x2))
10:00:57 <cohn> thanks!
10:02:17 <monochrom> maerwald: "parseTime" exists in time 1.9.3 but not 1.10
10:03:30 <monochrom> Hrm, it's more subtle than that.
10:03:58 <monochrom> Err, nah, it's as simple as that.
10:04:13 <monochrom> "time                      >= 1.0     && < 1.11"  in snap-core.cabal
10:04:25 <maerwald> well, seem that's a wrong range then
10:04:44 <maerwald> confused why I only hit this on windows
10:05:19 <maerwald> seem it forces portable mode for win
10:05:28 <monochrom> yeah
10:05:40 <maerwald> ifdefs killed your code
10:09:34 <cmcma20> Orbstheorem: https://paste.gnugen.ch/raw/l1rR
10:10:59 <cmcma20> Orbstheorem: I guess you can't use 'say' not having an explicit TestOps constraint.
10:14:23 <cmcma20> What are the best instruments for profiling a Haskell program? I'm mainly interested in memory consumption, tracking how much was GC'd etc
10:20:28 <opqdonut> cmcma20: GHC's profiler is pretty great
10:20:44 <opqdonut> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/profiling.html
10:21:38 <maerwald> until you hit pinned memory :p
10:22:08 <opqdonut> for just basic memory & gc stats use +RTS -s
10:22:10 <opqdonut> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/runtime_control.html#rts-options-to-produce-runtime-statistics
10:31:59 <dmwit> ?src uncurry
10:32:00 <lambdabot> uncurry f p = f (fst p) (snd p)
10:32:10 <dmwit> That's it. Now you learned currying.
10:32:23 <dmwit> Okay, maybe you also need to see the other direction.
10:32:25 <dmwit> ?src curry
10:32:25 <lambdabot> curry f x y = f (x, y)
10:33:21 <irc_user> Hi, I'm not using haskell but I wrote a simple script that just runs from top to bottom in Python, is there any basic intro to how I might refactor something like that to functional?
10:34:24 <maerwald> try to fit everythint into a single line
10:34:28 <koz_> irc_user: That's a very vague question. If you're asking 'how do I write this in Haskell?', we can certainly help.
10:34:30 <irc_user> LOL
10:34:39 <koz_> If you're asking 'how do I write Python functionally?', this is the wrong channel.
10:34:52 <irc_user> koz_: hmm, maybe I'll ask once I learn haskell. thanks
10:39:26 <monochrom> My broad answer is "pretend immutable data". The Java and Scala people do that and get pretty good results.
10:40:18 <monochrom> There is a subtle consequence of that. You now find that loops are useless. You must use recursion.
10:40:29 <monochrom> Either that or list comprehension.
10:41:11 <dolio> You can use loops with a reference to immutable stuff.
10:41:28 <dolio> But in Scala you might as well just use tail recursion, probably.
10:41:45 <monochrom> Ah, mutable reference to immutable data.
10:42:11 <dolio> In Python I guess the recursion might not work out as well.
10:42:41 <monochrom> Right. But we need more Python users to petition for an improvement.
10:42:49 <irc_user> Well the flow of it is basically `read file -> categorize text -> write text to multiple files -> check that it was successful`, but that's just straight up top to bottom, no functions or anything
10:42:55 <monochrom> Not more Python users to keep their peace.
10:43:45 <monochrom> That's also the flow in Haskell. But in Haskell, the "categorize text" part is functional, in my sense above: immutable data.
10:44:33 <monochrom> http://www.vex.net/~trebla/haskell/IO.xhtml#organization
10:45:23 <monochrom> You don't need to understand the whole thing (too much Haskell-specific stuff).  But if you just understand the spirit of that one section "Program Design, Structure, or Architecture", you understand functional programming.
10:45:48 * hackage mprelude 0.2.0 - A minimalish prelude.  https://hackage.haskell.org/package/mprelude-0.2.0 (mbj)
10:45:54 <halogenandtoast> irc_user: <meme>Use traverse a bunch</meme>
10:47:08 <monochrom> Here is another simple way of seeing what's functional.
10:47:19 * hackage conversions 0.0.2 - Injective explicit total and partial conversions  https://hackage.haskell.org/package/conversions-0.0.2 (mbj)
10:47:25 <cmcma20> ?src unsafePerformIO
10:47:25 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
10:47:29 <monochrom> You have a binary search tree. You plan to do insertion.
10:47:30 <irc_user> monochrom: Thanks!! this is very close to the type of thing I was looking for
10:47:52 <monochrom> In imperative contexts, you think "update the existing tree in-place".
10:48:08 <monochrom> In functional contexts, you think "produce a new version, don't destroy the old version".
10:48:19 * hackage devtools 0.0.3 - Haskell development tool agregate  https://hackage.haskell.org/package/devtools-0.0.3 (mbj)
10:51:29 <irc_user> monochrom: That makes sense. So in the script i mentioned, if it's not too vague,  would you put stuff into functions or just put everything on the first indentation level? Like maybe make a main function that calls all the other ones or something, and passes returned values to the next function?
10:52:58 <monochrom> For a short program I am lazy and I put everything on the first indentation level. Still, you can easily see lines 1-3 reads input, lines 4-8 is functional, lines 9-11 writes output.
10:53:29 <monochrom> If the thing grows complex, or if the functional middle is reusable, I cut it out into a named function.
10:54:05 <geekosaur> or if I want to debug specific parts of the processing, etc.
10:54:14 <irc_user> Oh I see what you're saying, thank you
10:54:17 <geekosaur> (or write tests for it)
10:54:19 <monochrom> To be sure, if the read-input part grows complex and full of parsing and validation etc, I cut that out into a named procedure, too.
10:54:36 <monochrom> And yeah what geekosaur says.
10:54:42 <irc_user> So why haskell for you guys
10:54:47 <monochrom> Testability is a good reason to factor out something.
10:55:04 <irc_user> ? like if oyu have a simple script you want to write, do you more or less always reach for haskell?
10:55:09 <monochrom> Haskell is great for supporting and encouraging this code structure.
10:55:25 <monochrom> Also I am philosophically against dynamic typing.
10:55:48 <monochrom> Simple script, I try shell scripts first.
10:56:14 <monochrom> In some cases, the shell script way becomes unsustainable. Then it's Haskell.
10:56:27 <geekosaur> note that there's not a lot of difference between shell programming with pipelines and functional programming
10:56:36 <monochrom> But still, many tasks are better off as shell scripts.
10:57:34 <irc_user> what do you guys think of rust, if I may ask?
10:58:07 <monochrom> Actually a real world example of that (author is not me) is ghcup. It started out as a shell script. But grew complex enough, and staying POSIX too difficult, so Haskell it is.
10:58:48 <irc_user> huh, what does posix have to do with it?
10:58:55 <geekosaur> portability
10:58:56 <monochrom> I am happy that Rust is a mainstream imperative language that shows that algebraic data types are not exclusive to functional languages.
10:59:56 <monochrom> If you write a shell script, you have to decide "must be bash, must be dash, must be zsh, ..., or, try to be super-portable and assume POSIX only"
11:00:21 <monochrom> You know the drill. Trying to be super-portable ties your hands, you can't do anything practical.
11:01:00 <monochrom> Also I'm happy to be able to tell people "algebraic data types are not rocket science, learn Rust".
11:01:19 <irc_user> Don't you still have to account for different pathing in Haskell though? Or is it not just about pathing
11:01:48 <monochrom> I think I don't understand the question.
11:02:11 <geekosaur> it's not just pathing. it's bugs in different shells (and shell versions: there are some broken bash versions in the wild, notably on OS X), etc.
11:02:22 <geekosaur> and recent OS X's "bash" is zsh
11:02:50 <monochrom> geekosaur, is it also true that OS X's "sh" is "bash"?
11:03:17 <irc_user> oh i see
11:03:19 <geekosaur> until I think 10.9
11:03:26 <monochrom> Because I tell my students "don't use bash, sh features only" and they can still get "[[ x ~= y ]]" to work.
11:03:55 <irc_user> I never really fully understood what exactly POSIX specifies to be honest
11:04:08 <geekosaur> also keep in mind that older POSIX shells accept [[ ]]
11:04:37 <geekosaur> the process by which they changed that is partof why I don't much trust POSIX any more (thanks for breaking valid scripts!)
11:04:50 <monochrom> Ho hum
11:05:17 <irc_user> haha
11:05:53 <monochrom> I don't mind [[ ]] too much. Apart from students over-engineering it, and still getting it wrong.
11:06:07 <monochrom> What I mind is "cmd1 <(cmd2)"
11:06:59 <geekosaur> that's not any version of POSIX, yeh. it has its place, though
11:07:09 <monochrom> I give exercises and assignments to be easily solvable by "c1 | c2 | c3", and the students ignore all course material and just google for stackoverflow and hand in "cmd1 <(cmd2) etc"
11:07:43 <monochrom> It means that they miss out a chance to learn "c1 | c2 | c3"
11:07:56 <monochrom> To make the sequel worse...
11:08:35 <monochrom> I said, OK, in the syscall part of the course, let's have an assignment that implements "cmd1 <(cmd2)" so you learn how it works under the hood.
11:08:48 <monochrom> My students implemented "cmd1 | cmd2"
11:08:58 <monochrom> THEY REFUSE TO LEARN ANYTHING
11:10:03 * geekosaur 's pet peeve is "cat file1 | ..."
11:10:34 <irc_user> geekosaur: as opposed to...
11:10:55 <monochrom> "cat file1 | cmd" = "cmd < file1"
11:11:21 <geekosaur> including in a compound pipeline
11:11:39 <geekosaur> foo < file1 | bar | baz ...
11:11:53 <halogenandtoast> I find bash to be a terribly antiquated thing to have to learn in college
11:12:10 <halogenandtoast> s/bash/shell-scripting/
11:12:11 <geekosaur> you can even write it as: <file1 foo | bar | baz
11:12:29 <irc_user> oh, thanks guys
11:12:36 <irc_user> I'll keep that in mind
11:12:42 <irc_user> halogenandtoast: as opposed to...
11:12:53 <geekosaur> it still has its place, I can do quite a lot in shell one-liners and often do
11:13:03 <monochrom> Yeah I think I was surprised and thrilled about that when I carefully read the POSIX shell grammar.
11:13:15 <geekosaur> why whip up an e.g. python script when I already have all the tools I need in the shell?
11:13:23 <halogenandtoast> Oh I think it is useful to learn, but most people won't need it in any large capacity
11:13:33 <halogenandtoast> and you can generally learn enough to get by
11:13:40 <halogenandtoast> college feels like a weird place to be learning it
11:14:05 <halogenandtoast> (for the record, my college did not teach it)
11:14:09 <irc_user> I feel like college is a weird place to learn anything
11:14:13 <geekosaur> much of this also works in cmd.exe these days, and yes it should be taught much earlier
11:14:14 <irc_user> but I am very very biased against college
11:14:36 <monochrom> You're blowing it out of proportion. I require my students to write like 5-line shell scripts only. Maybe 10 if I can think up an interesting problem. But more like 1 or 2.
11:15:28 <halogenandtoast> monochrom: I had no reference for proportionality. But sure, that makes sense, give them a taste and let them decide for themselves if it is something they have an interest in.
11:16:05 <monochrom> Also it is a stepping stone. This is where you first hear about processes, pipes, exit status. Then the real nightmare is when these are taken to C and syscalls.
11:16:26 <halogenandtoast> monochrom: which class is this?
11:16:40 <monochrom> http://www.cs.utoronto.ca/~trebla/CSCB09-2020-Summer/
11:16:56 <monochrom> It's a unix-and-C course
11:17:27 <halogenandtoast> well then
11:18:01 * halogenandtoast busts out his Advanced Programming in the UNIX Environment 2nd Edition
11:18:20 <halogenandtoast> It's probably 3rd of 4th edition by now
11:19:05 <monochrom> Next time I will have to shrink the shell programming part to 2 weeks at most, yeah.
11:19:23 <monochrom> It is really not rocket science at all. Compared to, like, signals and select.
11:19:37 <halogenandtoast> Do you have them write their own shell? That would be fun.
11:20:05 <monochrom> Well just look at how successful they were at merely "cmd1 <(cmd2)".
11:20:22 <monochrom> You know what's even more ridiculous than that?
11:20:25 <halogenandtoast> :shrug: we had to write our own operating system it was madness.
11:20:44 <halogenandtoast> multi-threaded at that
11:21:31 <monochrom> Even those who understood the question, they coded like "fork-exec cmd2; wait for cmd2 to terminate; fork-exec cmd1"
11:21:46 <monochrom> You think they are ready to implement a whole bloody shell?
11:21:49 * hackage yesod-page-cursor 1.0.0.1 -   https://hackage.haskell.org/package/yesod-page-cursor-1.0.0.1 (PatrickBrisbin)
11:22:43 <tomsmeding> in my university's CS bachelor, we had to write a shell in C in the first semester of the second year
11:22:49 * hackage cut-the-crap 1.4.2 - Cuts out uninteresting parts of videos by detecting silences.  https://hackage.haskell.org/package/cut-the-crap-1.4.2 (Jappie)
11:23:01 <tomsmeding> number of people that succeeded wasn't even _that_ low
11:23:05 <geekosaur> bet it didn't include <() /  >()
11:23:05 <monochrom> Maybe I should do that. And sink most of them.
11:23:10 <tomsmeding> it didn't :p
11:23:21 <tomsmeding> pipes and file redirects, nothing else
11:23:29 <monochrom> Well their issue isn't <() any more.
11:23:33 <tomsmeding> that made it doable
11:24:15 <tomsmeding> this was assignment 1 of the course; assignment 2 was implementing a simple FUSE filesystem
11:24:17 <monochrom> Because on the exam I had a question on that, except it's the simpler "c1 | c2".  I wrote "what's wrong with: fork-exec c1; wait for c1 to terminate; fork-exec c2"
11:24:25 <monochrom> Most students thought it was fine.
11:24:59 <geekosaur> give them their copy of ms-dos, then :)
11:25:07 * tomsmeding misremembered, was actually second semester
11:25:27 <monochrom> Oh don't worry, this course is usually 2nd semester, too.
11:25:45 <tomsmeding> and the third assignment was a page tables implementation :)
11:25:56 <tomsmeding> that teacher is fairly ambitious
11:26:28 <monochrom> Parsing is going to be annoying.
11:26:48 <monochrom> Maybe I provide the parser.
11:27:29 <tomsmeding> would also belong to a different course
11:27:42 <dolio> Yeah, you don't want them writing parsers in C.
11:28:04 <monochrom> Let me tell you another horror story. It's a short story.
11:28:09 <dolio> That's why like half of the traditional book on compilers is just how to parse things. :)
11:28:13 <tomsmeding> oh monochrom remember my story about the student that handed in the makefile with -w ?
11:28:15 <dolio> Maybe more.
11:28:17 <tomsmeding> that was for the shell assignment :p
11:28:29 <monochrom> Some students' idea of parsing a number out of argv[1] is (int)argv[1].
11:28:49 <tomsmeding> and do they think that works?
11:29:18 <tomsmeding> like, if they've dabbled in something like JS before, I wouldn't even be surprised at them writing that
11:29:33 <tomsmeding> but then you run the program and it does random crap and you know that you've done something wrong :p
11:29:35 <monochrom> I don't know. I think someone else put it better. "Or is that assuming too much?"
11:29:49 * tomsmeding remembers that jibe
11:29:54 <monochrom> >:)
11:30:08 <tomsmeding> nah they do think, they managed to get into university
11:30:29 <monochrom> Sorry, I forgot the -w story!
11:31:07 <tomsmeding> well, I TA'ed that operating systems course the year after I took it, and someone handed in a shell with a makefile, where the makefile contained CFLAGS=-w
11:31:27 <tomsmeding> where I do not expect you to know what -w does with gcc because you shouldn't have used it
11:31:37 <tomsmeding> because what it means, is turn off all warnings
11:31:56 <tomsmeding> the most important warning that it hid was something like an int to pointer cast
11:32:21 * geekosaur *eyeroll*
11:32:26 <tomsmeding> they had a prefix-* too many somewhere so that the program could under no realistic circumstances run without crashing
11:32:39 <tomsmeding> like, why do you even submit something at that point
11:33:15 <monochrom> sunk cost policy
11:33:37 <geekosaur> "don't I get partial credit?"
11:34:11 <tomsmeding> https://i.pinimg.com/originals/14/f7/1a/14f71aa17a7ab289b3603e2a7272279d.jpg
11:34:32 <monochrom> whee thanks I was looking for that
11:35:00 <monochrom> My colleague posts that on her office door, but as a paper print, doesn't have the URL, and I have been too lazy too ask.
11:35:32 <tomsmeding> I just found it via a ddg search to be honest :p
11:35:44 <tomsmeding> remembered you referring to it last time this came up
11:36:00 <monochrom> OK I was too lazy to google-search too sorry!
11:38:36 <tomsmeding> @where+ partialcredit https://i.pinimg.com/originals/14/f7/1a/14f71aa17a7ab289b3603e2a7272279d.jpg
11:38:36 <lambdabot> I will remember.
11:47:54 <dminuoso> tomsmeding: I had another idea! I could go with `Tagged 6 ShortByteString` or `Tagged 6 ByteString` perhaps. It lets you just trip the type level tag, but it communicates in the type level the expected size at the very least.
11:48:02 <dminuoso> *strip
11:49:12 <monochrom> That's nice.
11:49:15 <tomsmeding> sounds like a good one
11:51:39 <monochrom> Oh hey I should also say this, for something positive about cabal v2. Here is a v2 feature I like: "cabal outdated"
11:52:21 <tomsmeding> ooh
11:53:09 <koz_> Yeah, that was a TIL for me right htere.
11:53:45 <tomsmeding> the following question was inspired by 'cabal outdated' but has nothing to do with it
11:54:04 <tomsmeding> ghcup still lists ghc 8.8.3 as 'recommended', and ghc 8.10.1 only as 'latest'
11:54:13 <tomsmeding> is there a reason why 8.10.1 is not 'recommended'?
11:54:19 <maerwald> tomsmeding: what version?
11:54:29 <maerwald> run `ghcup upgrade`
11:54:32 <tomsmeding> ah
11:54:47 <tomsmeding> > ghcup has been rewritten in haskell. Please upgrade again via 'ghcup upgrade'
11:54:49 <lambdabot>  <hint>:1:26: error: <hint>:1:26: error: parse error on input ‘in’
11:54:50 <tomsmeding> ✨
11:55:17 <monochrom> Your ghcup is very old. :)  See also my shell-vs-haskell remark. :)
11:55:34 <tomsmeding> okay so I double-upgraded ghcup to a thing that apparently doesn't accept --version anymore
11:55:40 <dminuoso> maerwald: Oh I finally realized why you dislike nix. You have an agenda to push for ghcup. ;p
11:55:47 <tomsmeding> but it still lists ghc 8.8.3 as recommended :p
11:55:53 * geekosaur makes a guess as to how that one happened…
11:55:55 <merijn> dminuoso: I have a simpler explanation :p
11:55:58 <monochrom> Maybe go back to ghcup website and install anew.
11:56:04 <merijn> dminuoso: He's just super stubborn :p
11:56:19 <maerwald> yeah, the upgrade path from the shell script isn't too well
11:56:19 * merijn just installs GHC via bindists, like a Luddite
11:56:45 <monochrom> ghcup is very close to luddism
11:56:49 <maerwald> tomsmeding: https://downloads.haskell.org/~ghcup/0.1.10/
11:56:56 <dminuoso> merijn: Im starting to get the groove of nix, it just took me about a year to become comfortable with everything. If we had someone holding my hands in the company, it might have been smoother.
11:57:25 <dmwit> What does ghcup do with the non-GHC executables?
11:57:33 <tomsmeding> maerwald: what more does the script at https://www.haskell.org/ghcup/ do?
11:57:43 <maerwald> dmwit: what do you mean?
11:57:48 <monochrom> dmwit: Do you mean e.g. ghc-pkg ?
11:57:51 <maerwald> tomsmeding: or run that
11:59:06 <maerwald> dmwit: https://bsd.to/4Kjh/raw does that answer it?
11:59:16 <dmwit> I don't mean ghc-pkg, I specifically mean the executables that don't have versioned names.
11:59:25 <dmwit> I'm trying to find the bug that I filed ages ago that makes me ask.
11:59:26 <maerwald> it versions all of them
11:59:31 <dmwit> That's nice.
11:59:46 <dmwit> In fact that might be a convincing reason to switch from bindists for me.
11:59:55 <monochrom> At your choice, ghc is a symlink to one of the ghc-x.y.z's. This applies to ghci, ghc-pkg, etc. too
12:00:11 <dmwit> monochrom: Yes, but does not apply to e.g. haddock and some others that ghc comes with!
12:00:16 <monochrom> You can also choose not to have such symlinks at all.
12:00:26 <maerwald> dmwit: exactly, it caused some headache
12:00:42 <dmwit> Which means that if you install a new GHC first, and an old GHC second, the executable you get from that ordering may not support the new GHC that you still have installed!!
12:00:46 <monochrom> ghcup adds these symlinks for haddock too.
12:00:59 <monochrom> even hp2ps
12:01:03 <dolio> Do the unversioned executables actually change from release to release?
12:01:09 <dmwit> They do.
12:01:26 <monochrom> Yeah I know GHC official bindist doesn't version haddock and hp2ps. But ghcup goes one step further and adds those.
12:01:33 <monochrom> haddock does.
12:01:41 <dolio> haddock is versioned.
12:01:48 <monochrom> But you can bet backward compatibility, no harm using a newer haddock.
12:01:52 <monochrom> Ah OK sorry
12:02:11 <dolio> It wouldn't surprise me if hp2ps almost never changes, though.
12:02:27 <dmwit> Here we go: https://gitlab.haskell.org/ghc/ghc/-/issues/14793
12:02:29 <monochrom> Right.
12:02:44 <maerwald> I use hp2any-manager... but don't ask me how I managed to compile it
12:02:52 <monochrom> haha
12:03:03 <maerwald> ancient gtk code
12:04:02 <maerwald> ok, so who knows how to run perl in mingw
12:04:24 <Lycurgus> vs cygwin?
12:05:01 <Lycurgus> i only ever used mingw for mozzila builds on dos
12:05:03 <maerwald> I dunno. I'm trying to run a bash script in powershell. It invokes perl, it doesn't crash, but the perl invocation does nothing
12:05:11 <yushyin> maybe #perl knows
12:05:54 <Lycurgus> not to verge off topic, but let ps/MS be ps/MS and work within their unix accent is my advice
12:06:08 <maerwald> well, it's part of installing a haskell package on windows
12:06:16 <maerwald> and I'm having 8392381 issues
12:06:36 <yushyin> wow, that's over 9000
12:07:12 <Lycurgus> that still didn fully bring it on topic, offtopic or blah are suggested
12:07:32 <koz_> Is there a list of 'features to come in GHC 9' anywhere?
12:07:45 <tomsmeding> wasn't that in the mailing list?
12:08:00 <yushyin> koz_: https://gitlab.haskell.org/ghc/ghc/-/wikis/status/ghc-9.0.1
12:08:06 <koz_> yushyin: Thanks!
12:09:18 <Lycurgus> s/accent/spin/
12:09:28 <maerwald> merijn: you say stubborn... I say *good taste*, bwaha
12:10:59 <tomsmeding> okay so I'm now hot and fancy with ghcup-hs 0.1.10
12:11:09 <maerwald> tomsmeding: run `ghcup -c tui`
12:11:10 <tomsmeding> but it now marks 8.8.4 as recommended :)
12:11:14 <maerwald> yes
12:11:17 <tomsmeding> so my original question stands
12:11:23 <tomsmeding> oooooooh
12:11:29 <tomsmeding> okay but that's just 'ghcup list'
12:11:35 <maerwald> sure
12:11:56 <tomsmeding> props for the tui tho
12:12:02 <maerwald> latest stackage LTS is 8.8.4
12:12:09 <maerwald> it's not a hard, but a soft indicator
12:12:35 <maerwald> being one major release behind for recommended is usually a safe bet
12:12:36 <merijn> "Latest GHC -1" is not a bad heuristic anyway :p
12:13:00 <tomsmeding> also, with everything I do with ghcup it 08[ Warn  ]'s me that there is a new version (8.10.2) available
12:13:01 <merijn> Gives everything a change to catch up so you're not stuck when something has broken :p
12:13:04 <tomsmeding> it's not really consistent :p
12:13:21 <maerwald> tomsmeding: yeah, all those little details
12:13:40 <merijn> I only use the latest GHC release when there's a compelling reason (like a crucial bugfix I need or feature that I need)
12:14:54 <maerwald> tomsmeding: you can silence it with `mkdir ~/.ghcup/ghc/8.10.2` lol (don't do it)
12:15:28 <tomsmeding> :') I'm not going to do that
12:32:09 <tomsmeding> https://paste.tomsmeding.com/ has been updated with multiple file support!
12:32:19 <tomsmeding> hyiltiz: this now dearly needs some css
12:33:34 <tomsmeding> that first file contained an NSFW word
12:35:45 <maerwald> nice
12:36:31 <maerwald> snap, good choice
12:37:51 <tomsmeding> I looked for a simple, fast web server library, saw "high performance web server library" on https://wiki.haskell.org/Web/Servers, found that the docs were fine enough, and went with it :p
12:37:53 <monochrom> I use -w to suppress ghcup warnings. (Joke.)
12:39:24 <maerwald> that would be funny, if shortopt is the inverse of longopt
12:39:43 <maerwald> good cli troll
12:40:51 <monochrom> I have a better idea for trolling. Randomize every setting that the user doesn't explicitly nail on the command line.
12:41:26 <maerwald> lol
12:41:48 * hackage hledger-iadd 1.3.12 - A terminal UI as drop-in replacement for hledger add  https://hackage.haskell.org/package/hledger-iadd-1.3.12 (hpdeifel)
12:41:49 <geekosaur> built-in fuzzer?
12:42:03 <maerwald> like a configure script... --foo not set... guessing what you mean
12:42:37 <monochrom> guessing what /dev/urandom means
12:43:13 <monochrom> (Look for the book "do dice play god?" hehehehe)
12:47:41 <justsomeguy> Is there an easy way to disable hlint for a particular file, like an in-line comment or config file setting, for example?
12:48:37 <justsomeguy> Ah, found it. Apparently "{-# HLINT ignore #-}" should work.
12:49:03 <dmwit> Have you tried reading the fine documentation? ;-)
12:54:07 <justsomeguy> I should have spent more time reading the docs before asking. (That's where I found the snippet I posted shortly after asking, anyways.) I think was starting to panic.
13:08:39 <dolio> DON'T PANIC
13:13:38 <halogenandtoast> merijn: how close is this to what you were referring to https://gist.github.com/halogenandtoast/57083a3073d1dc183a769efd099373bc
13:15:26 <comerijn> halogenandtoast: Looks about right, I'd probably limit the "getState" to only serialise stuff (I think), because else you're again requiring everyone to have the same state/API, but other than that
13:31:18 * hackage hspec-core 2.7.3 - A Testing Framework for Haskell  https://hackage.haskell.org/package/hspec-core-2.7.3 (SimonHengel)
13:32:19 * hackage hspec 2.7.3, hspec-discover 2.7.3 (SimonHengel): https://qbin.io/he-watson-7w2p
13:36:43 <halogenandtoast> comerijn: okay glad I was on a sort of right track
13:37:09 <halogenandtoast> I don't actually think I can implement what I want to with this yet, but I'm going to fight with it until I can't anymore
13:39:06 <maerwald> https://github.com/commercialhaskell/stack/issues/1947 ...
13:39:14 <maerwald> windows story never ending
13:39:55 <maerwald> sm[m]: if you ever say windows works well again :p
13:40:49 <yushyin> issue is closed, so works well, I guess? :P
13:41:05 <maerwald> well, then I wonder why I just hit that bug
13:46:15 <sm[m]> I never say things are perfect. I say haskell works relatively well & consistently on windows compared to some languages
13:46:38 <maerwald> My experince right now is the opposite... even python works better on windows
13:47:18 <sm[m]> I hear you
13:47:18 <maerwald> and now I'm stuck, because it always throws that realgcc.exe error
13:48:12 <sm[m]> maerwald, what are you doing ?
13:48:20 <maerwald> building a project
13:48:47 <sm[m]> got a command & output paste somewhere ? I wouldn't mind seeing
13:49:39 <maerwald> sm[m]: https://git.io/JUqhV
13:52:19 * hackage uniqueness-periods-vector-general 0.1.0.0 - Generalization of the functionality of the dobutokO-poetry-general-languages package  https://hackage.haskell.org/package/uniqueness-periods-vector-general-0.1.0.0 (OleksandrZhabenko)
13:53:09 <sm[m]> oh cool.. following their build procedure, or making your own ? And what's the output ?
13:56:10 <maerwald> sm[m]: https://bsd.to/mRS7/raw
13:57:29 <sm[m]> if it doesn't happen with stack, you could compare command invocations
13:57:36 <maerwald> meh
13:57:50 <maerwald> I don't have another 2 hours time to build with stack
13:58:19 <sm[m]> I worded that carefully to try and avoid rejection. Oh well :)
13:58:36 <sm[m]> just throwing out ideas to get it solved
14:01:13 <maerwald> took me 5 minutes just to rename a folder, bc on windows everything locks everything
14:01:49 <sm[m]> I guess the issues you linked are more useful anyway.. that max path thing sure is stupid
14:08:06 <[exa]> max path issues still exist in 2020?
14:09:49 * hackage conversions 0.0.3 - Injective explicit total and partial conversions  https://hackage.haskell.org/package/conversions-0.0.3 (mbj)
14:09:53 <fendor> the joys of windows :)
14:10:10 <davean> [exa]: sure, but but they're a few KiBs 
14:11:22 <davean> sometimes MiBsd
14:12:10 <monochrom> That's a new BSD. :)
14:12:32 <monochrom> MiiBSD is a BSD that runs on Wii :)
14:29:25 <jamestmartin> would it be accurate to say that `data Nat = Z | S Nat` is codata and `data Nat = Z | S !Nat` is data?
14:29:50 <monochrom> I think yes.
14:30:15 <jamestmartin> alright, cool. just making sure.
14:30:24 <monochrom> But I'm too lazy, so I say that "data Nat = Z | S Nat" is data too.
14:31:31 <jamestmartin> yeah, I think most people would. just in the cases where it's useful to distinguish them.
14:32:56 <comerijn> I thought codata *can't* terminate?
14:33:22 <comerijn> So, just like "codata Stream a = a :| Stream a" and the like?
14:33:33 <comerijn> Or is it a superset of data?
14:33:38 <comerijn> That seems counterintuitive
14:34:10 <glguy> At least how this works in Agda codata need not be infinite
14:36:58 <jamestmartin> comerijn: codata isn't a superset of data in total languages
14:37:22 <comerijn> jamestmartin: glguy seems to disagree :p
14:38:31 <jamestmartin> comerijn: you can't fold a potentially infinite list (codata), whereas you can fold a finite list (data)
14:38:49 <comerijn> So?
14:39:00 <jamestmartin> on the other hand, you can't unfold data
14:39:02 <MarcelineVQ> Can't you?
14:39:13 <comerijn> MarcelineVQ: Not in lame ass strict languages :p
14:39:18 <jamestmartin> MarcelineVQ: you can in Haskell, but not in total languages
14:39:28 <MarcelineVQ> Are you sure about that?
14:39:36 <comerijn> jamestmartin: Whether codata is a superset of data just depends on "is all data also valid codata"?
14:39:59 <comerijn> jamestmartin: glguy says yes, and your description doesn't contradict his claim
14:40:02 <jamestmartin> comerijn: oh, yeah. idk what I was thinking.
14:41:17 <jamestmartin> well, actually, no, it's not. if you define codata as "stuff which has a valid unfold operation" then the answer is no, recursive data is not corecursive codata
14:42:43 <jamestmartin> you can *convert* all data into codata, but it isn't codata per se
14:52:18 <dolio> What is the 'superset' being talked about?
14:52:46 <dolio> Also I wouldn't agree with the original characterization.
14:54:02 <dolio> I mean, it is accurate to say that the first is codata, and the second is data, but it's also accurate to say that the first is data, and the second is codata.
14:54:53 <dolio> Because data and codata coincides in Haskell (and ML for that matter).
15:02:16 <sm[m]> we dropped some Data, Typeable and NFData instances and I did a little informal measuring of build times. It seemed to speed up the build by ~7%, and it seems to me that NFData accounts for all of that. Does that sound likely ?
15:03:46 <dminuoso> sm[m]: Are you using generics derived NFData instances?
15:04:54 <sm[m]> yes I guess I am, they're auto-derived
15:05:14 <dminuoso> Then yeah, it's more than likely.
15:05:33 <dminuoso> Generics tend to be slow, especially if you have lots of ADTs and/or large ADTs.
15:06:34 <sm[m]> thanks. I wonder if I can remove Generic as well. No, I think it's required for aeson
15:06:48 <dminuoso> The mere Generic instance is not the problem, the code *using* generics is.
15:06:49 <sm[m]> oh, unless I write ToJSON instances by hand
15:07:31 <dminuoso> sm[m]: Remove those generic aeson instances and watch your compile speed jump up. :-)
15:07:58 <sm[m]> thanks! I will work towards that
15:08:58 <dminuoso> Perhaps Data.Aeson.TH might offer better performance than Generics based instances for aeson.
15:09:16 <dminuoso> (It especially does if you have some mechanism of manually splicing the generated instances, of course)
15:09:20 <davean> There are at least tools to reify the code for the later into your source files.
15:09:24 <sm[m]> I added NFData so that I could time code with criterion. And for the future, to be able to force values to help with optimisation. Not sure if it's worth keeping now
15:09:42 <sm[m]> oh, but again I could write instance by hand. I see
15:10:13 <dminuoso> sm[m]: Well, if you just care about NFData for profiling, you could use CPP with StandaloneDeriving.
15:10:21 <dminuoso> And enable all those instances with just a preprocessor flag
15:10:36 <sm[m]> yes, that's true too
15:10:38 <dminuoso> And for aeson, TH could be an option
15:11:01 <sm[m]> we've just been removing a bunch of CPP, but that would be a use for it
15:11:52 <sm[m]> dminuoso: hmm, TH you say. Is this an alternate way of generating aeson instances ? Usually people call it the devil
15:12:09 <dminuoso> Yes.
15:12:12 <sm[m]> yes.. I see. Thanks for the tip
15:13:07 <dminuoso> Ontop, you can manually splice the instances (perhaps using -ddump-splices), then you're paying the price only once - at the cost of having to do this job every time an ADT gets changed/added/removed
15:13:40 <davean> sm[m]: TH is often used when people should use a tool Haskell has thats better for the job. Its also designed terribly for cross-compiles and generally is too general. If you're actually solving a real problem with it after considering your options I'd say use it.
15:14:27 <dminuoso> well I dont mean to write out the TH yourself
15:14:31 <dminuoso> Just use https://hackage.haskell.org/package/aeson-1.5.4.0/docs/Data-Aeson-TH.html
15:14:41 <sm[m]> gotcha
15:15:52 <maralorn> I was wondering, would it be possible to do something like makeLenses with typed TH?
15:16:11 <maralorn> Or is TTH to restricted for that?
15:19:48 <tomsmeding> hyiltiz: what do you think about this restyle? (not live yet in the real instance, and also this page doesn't actually work): https://tomsmeding.com/f/pastebin-restyle-nonworking.html
15:20:33 <tomsmeding> I'll see your response tomorrow :p
15:21:09 <hyiltiz> tomsmeding: [Fantastic, Simple, Elegant]
15:21:48 <sm[m]> looking good!
15:22:20 <glguy> maralorn: Not without typed a typed 'reify' (which wouldn't be simple)
15:22:20 <hyiltiz> Are makeFileContainer doAddfile doRemovefile functions generated from haskell, or manually crafted js?
15:23:46 <hyiltiz> I think we somehow need to re-format the wall of prompt text into a better structure; maybe just by breaking the 3 sentences into 3 paragraphs?
15:24:09 <hyiltiz> Anyone bothered by a wall of text? Most people dont even skip-read it when presented with a wall of text
15:24:29 <hyiltiz> While bullet-points with the SAME content seem to be read
15:26:28 <mmaruseacph2> depends on the structure of the text too
15:26:50 <mmaruseacph2> I read blocks of text if the first few lines of every paragraph make me want to read it
15:27:08 <mmaruseacph2> if skimming does not seem to provide good anchors then I consider the wall of text to not be worth my time
15:28:52 <hyiltiz> Something like this structure: https://paste.tomsmeding.com/XZiMQH2o
15:29:03 <hyiltiz> This seem quite verbose and easy to read at a glance
15:29:12 <hyiltiz> Without having to chime thru text
15:39:26 <monochrom> This is why I go for a simple instruction that's sufficient for a large class of beginners.
15:40:11 <monochrom> As you want to cover more cases, your instruction becomes more complex, both longer and more conditionals.
15:45:13 <monochrom> Another idea is that a paste website doesn't have to limit to posting one file. It defaults to one file (one textbox) as usual. But there is a button for creating one more textbox, ad infinitum.
16:03:53 <hyiltiz> monochrom: it now allows "ad infinitum"
16:04:09 <hyiltiz> Any suggested brief instruction text?
16:04:21 <monochrom> Oh! I'm behind then. Cool.
16:04:39 <monochrom> I think your proposal is fine.
16:04:40 <hyiltiz> The idea of that text was to put it there so we do not need to type it almost every single time
16:05:11 <hyiltiz> if it can reduce some of the redundant typing for 95% cases, should be enough; no need to try to cover more cases and further complicate it
16:05:47 <monochrom> Yeah. I just set my eyes low and go for 70% or 60% or something haha
16:09:19 * hackage hie-bios 0.7.1 - Set up a GHC API session  https://hackage.haskell.org/package/hie-bios-0.7.1 (fendor)
16:27:44 <cohn> bios?? o_0
16:28:33 <Rembane> Basic input ouput system I believe.
16:29:43 <cohn> yea, just thought that was odd. Like being able to program hardware using Haskell.
16:32:49 <Rembane> Well, you can, but it's roundabout. I think the name in this case comes from that it is the base for hie. 
16:32:55 <maralorn> cohn: No, I guess it is called bios, because it is part of a start up process. But here it is not the start up of an computer / OS but a language server for a text editor.
16:44:54 <cohn> gotcha
16:45:23 <cohn> so more of a "boot loader".  ; )
16:46:11 <monochrom> yeah
17:11:20 * hackage algebra-driven-design 0.1.1.1 - Companion library for the book Algebra-Driven Design by Sandy Maguire  https://hackage.haskell.org/package/algebra-driven-design-0.1.1.1 (isovector)
17:56:22 <cheater> hi, can someone suggest a simple web server that supports https?
17:56:54 <jrqc> nginx with a reverse proxy :V
17:59:12 <cheater> no
17:59:25 <sm[m]> warp
18:01:01 <cheater> sm[m]: how does it compare to spock?
18:02:59 <sm[m]> or do I mean wai-app-static. Not sure. Are you looking for a web server you can program against ? If so warp is probably the most used & most basic. spock, scotty, yesod, snap etc. are frameworks providing more conveniences
18:03:00 <sm[m]> afk
18:03:21 <cheater> does any of them support websockets?
18:03:39 <justsomeguy> Out of curiosity, is LiquidHaskell a practical tool that I can expect to use after learning the basics of Haskell? I'm very interested in it, but a bit worried that the error messages will be unreadable.
18:04:23 <cheater> practical, sometimes yes. after learning the basics, no.
18:04:40 <cheater> if you're interested, don't let any of this stop you, go for it
18:05:17 <justsomeguy> I will :^).
18:10:16 <ddellacosta> cheater: re: websockets randomly noticed this function the other day, so assuming warp supports websockets somehow https://hackage.haskell.org/package/wai-3.2.2.1/docs/Network-Wai.html#v:responseRaw
18:10:32 <cheater> thanks ddellacosta 
18:10:58 <ddellacosta> np
18:19:18 * hackage language-dickinson 1.3.0.2 - A language for generative literature  https://hackage.haskell.org/package/language-dickinson-1.3.0.2 (vmchale)
19:06:24 <triteraflops> so is GHC.Exts.build something I should know about?
19:06:36 <triteraflops> I see it used in Data.List a bunch
19:06:47 <triteraflops> implying ghc isn't smart enough to add it itself?
19:07:38 <Axman6> if you use functions which are defined using build you don'tneed to worry (though chucking in INLINE pragmas may make things more likely to trigger the build/fold optimisation)
19:08:19 <MarcelineVQ> it's a component of list fusion/deforestation
19:08:50 <triteraflops> oh, no I don't want to deforest things :'(
19:09:19 <Axman6> why not?
19:09:33 <triteraflops> trees are nice! They're good carbon sinks! 
19:09:35 <triteraflops> lol
19:09:40 <triteraflops> k but seriously
19:09:48 <triteraflops> I thought fusion was done automatically...
19:13:08 <triteraflops> k so lets make an example here...
19:13:14 <MarcelineVQ> nope, it's too much work to guess there fusion opportunities will occur. but the compiler has rules pragmas in the list source where if it sees a foldr and a build next to each other it can merge them and skip making an intermediate list. That's the original fusion method but lists might be using stream fusion now, I've not looked into it for awhile
19:13:25 <MarcelineVQ> *where fusion opportunities
19:13:40 <triteraflops> if I make an unending list of fibonacci numbers then sum the first 100, for instance
19:14:25 <Axman6> it _may_ be possible that fusion happens if other optimisations fire (case of case?) 
19:14:46 <MarcelineVQ> dcoutts_: does base use stream fusion for lists currently?
19:17:11 <MarcelineVQ> ah doesn't look like it http://hackage.haskell.org/package/base-4.14.0.0/docs/src/GHC.Base.html#augment
19:20:06 <MarcelineVQ> stream fusion is really quite cool http://fun.cs.tufts.edu/stream-fusion.pdf
19:23:39 <triteraflops> so how do I get ghc to fuse that fibonacci example I just mentioned?
19:26:20 <triteraflops> hey, there's a d coutts in this pdf you just sent me...
19:26:30 <triteraflops> wow, same guy?
19:26:49 <MarcelineVQ> deforestation is about avoiding creating and destroying data structures when doing multiple operations on them, like mapping twice over a list or incrementing then summing partof a tree, so it depends on the actual structure of it.
19:26:57 <MarcelineVQ> triteraflops: should be
19:31:16 <triteraflops> for that matter, oh, I knew deforestation as fusion
19:31:41 <triteraflops> s/for that matter//
19:41:52 <triteraflops> hm, so should I be /using/ build, then...
19:42:38 <triteraflops> also, hm is simon peyton jones in here?
19:43:26 <Axman6> He's usually not in here but sometimes in #ghc
19:43:30 <Axman6> I think
19:45:14 <Guest_50> hey, im having tons of issues installing haskell on macOS catalina. can someone help?
19:50:32 <justsomeguy> Guest_50: How are you trying to install it? (stack, ghcup, something else?)
19:53:11 <Guest_50> i tried using stack 
19:53:33 <Guest_50> I can send the exact error that comes up when I try to run `stack build`
19:54:23 <justsomeguy> That would be helpful.
19:54:54 <Guest_50> ```Preparing to install GHC to an isolated location.This will not interfere with any system-level installation.Already downloaded.                xcode-select: error: tool 'xcodebuild' requires Xcode, but active developer directory '/Library/Developer/CommandLineTools' is a command line tools instanceconfigure: error: in
19:54:54 <Guest_50> `/Users/john/.stack/programs/x86_64-osx/ghc-8.8.4.temp/ghc-8.8.4':configure: error: C compiler cannot create executablesSee `config.log' for more detailsReceived ExitFailure 77 when runningRaw command: /Users/john/.stack/programs/x86_64-osx/ghc-8.8.4.temp/ghc-8.8.4/configure --prefix=/Users/john/.stack/programs/x86_64-osx/ghc-8.8.4/Run from:
19:54:55 <Guest_50> /Users/john/.stack/programs/x86_64-osx/ghc-8.8.4.temp/ghc-8.8.4/                   Error: Error encountered while configuring GHC with         /Users/john/.stack/programs/x86_64-osx/ghc-8.8.4.temp/ghc-8.8.4/configure --prefix=/Users/john/.stack/programs/x86_64-osx/ghc-8.8.4/         run in
19:54:55 <Guest_50> /Users/john/.stack/programs/x86_64-osx/ghc-8.8.4.temp/ghc-8.8.4/              The following directories may now contain files, but won't be used by stack:         - /Users/john/.stack/programs/x86_64-osx/ghc-8.8.4.temp/         - /Users/john/.stack/programs/x86_64-osx/ghc-8.8.4/              For more information consider rerunning with --verbose
19:54:56 <Guest_50> flag       Configuring GHC ...```
19:55:15 <justsomeguy> I should have mentions that you should use a pastebin service for that, like termbin.com.
19:55:17 <Guest_50> let me send it as a message instead. I thought it would send as a code block 
19:55:20 <Guest_50> ahhh ok
19:56:03 <justsomeguy> "command |& nc termbin.com 9999" is a good way to upload pastes
19:56:55 <Guest_50> just ran that
19:58:04 <justsomeguy> This seems relevant https://docs.haskellstack.org/en/stable/install_and_upgrade/#notes
19:58:33 <int-e> Also this part near the top sounds relevant: "tool 'xcodebuild' requires Xcode, but active developer directory '/Library/Developer/CommandLineTools' is a command line tools instance"
19:59:56 <Guest_50> justsomeguy that directory doesn't exist 
20:00:20 <Guest_50> `/Library/Developer/CommandLineTools/Packages`
20:02:10 <Guest_50> also, i just noticed that termbin didnt give me a url with the paste
20:02:37 <justsomeguy> did you substitute "command" with your command (like "stack build")?
20:02:42 <Guest_50> yeah lol
20:02:48 <justsomeguy> Just checking.
20:03:15 <Guest_50> it removed the color-coding that my terminal uses which is kinda weird
20:04:15 <justsomeguy> Did you already run "xcode-select --install" at some point?
20:04:40 <int-e> . o O ( and did it succeed? )
20:05:13 <Guest_50> `xcode-select: error: command line tools are already installed, use "Software Update" to install updates`
20:05:25 <justsomeguy> Ok, that's good.
20:07:30 <justsomeguy> I wonder if you have to install xcode? I'm not really sure what role xcode plays in setting up the C compiler toolchain on macos, but I think it's involved somehow.
20:07:52 <Guest_50> so i was reading about it, and it might be because i could have multiple versions of c?
20:08:21 <Guest_50> and yeah idk if xcode has something to do with that. I've already got xcode installed 
20:10:11 <justsomeguy> Another option is to use ghcup to install cabal. Do you want to try that?
20:11:52 <justsomeguy> https://www.haskell.org/ghcup
20:13:04 <Guest_50> i had already tried that too and it failed :/
20:13:11 <justsomeguy> Oh no!
20:13:12 <Guest_50> thats what prompted me to come here 
20:13:15 <Guest_50> yeah lol
20:13:52 <justsomeguy> How about trying to install cabal with brew?
20:14:01 <justsomeguy> Sorry, trying to install stack with brew.
20:15:20 <Guest_50> yup
20:15:30 <Guest_50> ive tried with both brew and curl/wget 
20:15:39 <glguy> What do the log files from the GHC configuration process actually say?
20:15:51 <glguy> from when they determined your C compiler didn't work
20:16:04 <Guest_50> ahhh i tried using termbin but its not working 
20:16:15 <Guest_50> do you guys mind if i just send it here?
20:16:21 <glguy> no, don't do that
20:16:34 <Guest_50> ok
20:16:36 <glguy> There's a bunch of pastebins online if the one you tried didn't work
20:17:33 <MarcelineVQ> Axman6: you might be thinking of marlow, but maybe not :>
20:17:58 <Guest_50> https://pastebin.com/5geQQGFn
20:18:18 <Guest_50> justsomeguy glguy
20:18:47 <glguy> Guest_50: Try to find the errors in: See `config.log' for more details
20:19:09 <glguy> if that doesn't exist you might try getting the tarball and doing the configure step manually to ensure the output goes somewhere you can find
20:19:35 <glguy> http://downloads.haskell.org/~ghc/8.8.4/ghc-8.8.4-src.tar.xz
20:22:33 <Guest_50> how would i do the configure manually?
20:22:45 <Guest_50> just unzip the tarball and run something?
20:22:45 <glguy> untar that and run: ./configure
20:22:49 <Guest_50> ok
20:22:59 <Guest_50> where? in home dir?
20:23:04 <glguy> It doesn't matter
20:23:13 <glguy> You're just doing this to debug the issue
20:23:19 <glguy> you'll be deleting it after
20:26:17 <justsomeguy> Guest_50: What happens if you run "sudo xcode-select --reset && stack build"?
20:28:36 <Guest_50> same error
20:29:07 <justsomeguy> crap
20:29:18 <Guest_50> should i just give up and not learn this language LOL
20:29:40 <Guest_50> is this a sign that I shouldn't pursue higher ed in theoretical cs and functional programming
20:29:43 <glguy> Yeah, it's that or see what error is in the config.log
20:29:56 <Guest_50> ok let me see
20:31:27 <Guest_50> theres nothing really useful in config.log
20:33:18 <int-e> it'll containt something like  configure:5530: checking whether the C compiler works  followed by the command it tried for that.
20:33:23 <glguy> xcode-select: error: tool 'xcodebuild' requires Xcode, but active developer directory '/Library/Developer/CommandLineTools' is a command line tools instance
20:33:30 <glguy> And to be clear, you have Xcode.app installed?
20:33:40 <Guest_50> yes
20:33:47 <Guest_50> I use it for swift programming
20:34:34 <glguy> Can you toss the config.log up on a pastebin?
20:34:53 <justsomeguy> ...and also the output of "stack build --verbose"?
20:35:39 <int-e> (btw, that 5530 line number is probably correct since I'm looking at a config.log from ghc-8.8.4 as well)
20:36:11 <int-e> (and I don't see any special treatment for MacOS in the vicinity)
20:36:26 <Guest_50> glguy will do
20:37:38 <Guest_50> https://pastebin.com/CLgqdA8U
20:37:47 <glguy> Guest_50: When happens when you run this command: xcodebuild -version ?
20:38:45 <Guest_50> Xcode 11.5Build version 11E608c
20:38:48 <int-e> hmm. did I run ./boot and generate my own configure... apparently so, oops.
20:39:04 <int-e> fun. 'clang-10: error: linker command failed with exit code 1 (use -v to see invocation)'
20:39:26 <glguy> 105-107
20:39:55 <glguy> err, 107-109; configure tried to compile a C program and got ld: unknown option: -platform_version
20:40:13 <glguy> What's your : which ld
20:41:33 <int-e> (Aside: so it did find the xcode version... the xcodebuild error seems irrelevant.)
20:42:11 <glguy> Guest_50: Can you share output from: which ld; and: ld -v
20:43:54 <glguy> LD='/usr/local/Caskroom/miniconda/base/bin/x86_64-apple-darwin13.4.0-ld'
20:44:32 <glguy> Guest_50: You've got the wrong ld in your PATH it seems
20:44:45 <int-e> Oh... stack runs autoconf itself :-/
20:45:50 <glguy> I don't know what Miniconda is, but it appears to be messing up your C environment
20:46:25 <int-e> Sorry, just ignore me. I'm off an irrelevant tangent and I've confused myself.
20:47:04 * justsomeguy would probably try creating a new user and install stack for that user to determine if $PATH was the problem.
20:47:33 <glguy> It looks like there's a bunch of stuff in `env` related to miniconda
20:48:01 <int-e> justsomeguy: but it's in /usr/local ... it may be messed up globally
20:48:31 <justsomeguy> Ah
20:49:14 <Guest_50> should i get out of my anaconda env?
20:49:17 <Guest_50> and then retry 
20:49:21 <glguy> yup
20:49:43 <glguy> You shouldn't use your anaconda env for anything other than anaconda :)
20:51:08 <justsomeguy> My dev tools like to fight with each other too.
20:54:01 <int-e> justsomeguy: isolation is key :)
20:54:07 <Guest_50> let me try that out
20:54:41 <Guest_50> the thing is i do soooooo much data science stuff that i have my base env activate when i open my terminal 
20:54:52 <Guest_50> i gotta stop being lazy and just manually activate it lol 
20:55:28 <int-e> (Unfortunately isolation tends to be at odds with using distribution packages, with the possible exception of nix... which I find too extreme.)
20:57:28 <justsomeguy> I've been getting into the habit of creating a script that sets $HOME to a dir named toolchain in my project directory, and then only altering $PATH using that script. It seems to help a bit. I'm learning docker, now, too.
20:57:37 <Guest_50> in a couple weeks, i might just save all my school/work stuffs onto an external drive and reset my whole OS
20:57:51 <Guest_50> thanks so much for the help everyone!! means alot
22:14:46 <petersen> cabal: filepath wildcard 'ChangeLog.md' does not match any files.
22:18:19 <petersen> nvm I managed to hunt it down myself
22:21:56 <int-e> . o ( extra-something )
22:42:07 <petersen> It would be kind of cabal-install told one which project...
22:42:16 <petersen> if
22:46:49 * hackage store 0.7.7 - Fast binary serialization  https://hackage.haskell.org/package/store-0.7.7 (MichaelSloan)
22:47:49 * hackage store-streaming 0.2.0.3 - Streaming interfaces for `store`  https://hackage.haskell.org/package/store-streaming-0.2.0.3 (MichaelSloan)
