00:04:19 <ph88> How can i make UTCTime hashable ? or maybe convert it to UnixTime first (with loosing some date range)
00:09:00 <ph88> maybe first format into string and then read back string into Int https://hackage.haskell.org/package/time-1.10/docs/Data-Time-Format.html#v:formatTime 
00:27:56 <ph88> bye bye
01:05:49 * hackage stateWriter 0.3.0 - A faster variant of the RWS monad transformers.  https://hackage.haskell.org/package/stateWriter-0.3.0 (SimonMarechal)
01:18:48 * hackage fastparser 0.5.0 - A fast, but bare bones, bytestring parser combinators library.  https://hackage.haskell.org/package/fastparser-0.5.0 (SimonMarechal)
01:31:16 <typetetris> Does `Text.pack (show something)` really roundtrip through `String` after optimizations? If so, is there an alternative, which doesn't do this? Or isn't it worth trying to avoid this?
01:34:05 <lortabac> @hackage text-show
01:34:05 <lambdabot> https://hackage.haskell.org/package/text-show
01:34:10 <lortabac> typetetris: ^
01:35:39 <typetetris> lortabac: nice .. thank you, I should browse hackage a bit more sometimes
01:36:12 <lortabac> however I don't have an answer to your first question, maybe you should benchmark
01:53:30 <MyNameIsArko> okay now I have xmobar 0.36 but fontawesome icon is still not there
02:12:27 <hyiltiz> https://github.com/rgleichman/glance/wiki/Advantages-of-Glance seems to have impressively eye candy graphs. Any one put them for practical use such as debugging or refactoring, it just to get a general overview into a new unfamiliar codebase?
02:15:35 <cohelin> Have a question regarding MVars, does it copy values in and out when doing a putMVar / takeMVar ? 
02:15:58 <cohelin> I am wondering if putting / taking large bytestrings into it is inefficient?
02:16:16 <opqdonut> haskell values are pure so they don't need to be copied
02:17:17 <opqdonut> the docs don't spell this out, but they do say for instance
02:17:19 <opqdonut> >  many other Haskell data structures, MVars are lazy. This means that if you place an expensive unevaluated thunk inside an MVar, it will be evaluated by the thread that consumes it, not the thread that produced it.
02:17:21 <lambdabot>  <hint>:1:20: error: parse error on input ‘data’
02:17:28 <opqdonut> meh, shouldn't use > to quote here
02:17:30 <Putonlalla> Remember that the `MVar` holds a mutable reference, cohelin.
02:18:09 <Putonlalla> It's not a reference to a mutable variable.
02:18:26 <opqdonut> mmh
02:34:39 <amosbird> Hello, what's the term of describing a operator
02:35:09 <amosbird> that does this :     apply(sum, a, b, c)   ->    sum(a), sum(b), sum(c)
02:35:21 <amosbird> is "apply" the proper term?
02:38:41 <opqdonut> sure, apply is fine
02:38:54 <nitrix> You can make the arguments variadic with a list, apply(f, xs), at which point you have map, which can generalize further into fmap.
02:39:06 <nitrix> You're rediscovering functors :)
02:40:36 <nitrix> > fmap (*2) [1,2,3,4,5]
02:40:38 <lambdabot>  [2,4,6,8,10]
02:40:56 <__monty__> hyiltiz: The complexity of these graphs for very simple examples doesn't exactly instill me with confidence. Take the first example, it would be so much clearer if the lines *didn't* cross in the first image.
02:41:32 <int-e> :t \(a :: f ()) (b :: [t]) -> a == b
02:41:33 <lambdabot> [()] -> [()] -> Bool
02:43:04 <cohelin> opqdonut: thank you! makes sense
02:43:30 <cohelin> Putonlalla: that makes sense too!
02:43:35 <cohelin> thank you
02:43:39 <nitrix> amosbird, Similarly, if you wanted sum(a + b + c) instead, those are foldables.
02:44:53 <nitrix> > foldl (+) 0 [1,2,3,4,5]
02:44:55 <lambdabot>  15
02:46:49 <nitrix> You could use lists or be a little more descriptive with custom types. Like a `data Vec3 t = Vec3 t t t` or something.
03:25:49 * hackage essence-of-live-coding 0.2.2 - General purpose live coding framework  https://hackage.haskell.org/package/essence-of-live-coding-0.2.2 (turion)
03:26:49 * hackage essence-of-live-coding-warp 0.2.2, essence-of-live-coding-quickcheck 0.2.2, essence-of-live-coding-pulse-example 0.2.2, essence-of-live-coding-pulse 0.2.2, essence-of-live-coding-gloss-example 0.2.2, essence-of-live-coding-gloss 0.2.2 (turion)
03:33:36 <typetetris> I am using servant and it rejects a request made to my api. The Endpoint doesn't provide any content, but the request contains an `Accept` header, so it gets a 406. What is an easy way to ignore `Accept` in this case?
05:13:49 * hackage optics-th 0.3.0.2 - Optics construction using TemplateHaskell  https://hackage.haskell.org/package/optics-th-0.3.0.2 (arybczak)
05:16:19 * hackage eveff 0.1.0.0 - Efficient effect handlers based on evidence translation.  https://hackage.haskell.org/package/eveff-0.1.0.0 (ningningxie)
05:24:39 <typetetris> *sigh* They send an invalid `Accept` header ... no I have to write a middleware to cut those out.
05:43:48 <cheater> i have a rose tree data Rose a = Node [Rose a]. Given a specific Node, how can I best find a parent for it if one exists?
05:44:15 <cheater> i'm guessing i will have to change the data structure somehow so this can be ensured but not sure how
05:46:30 <opqdonut> cheater: you could make your data structure cyclic and add parent pointers. however that makes constructing the tree a bit painful, and means any tree operations need to construct a completely new tree (no sharing is possible)
05:46:43 <cheater> right
05:46:52 <cheater> maybe i should just keep a stack
05:46:57 <cheater> what do you think?
05:46:59 <opqdonut> yeah, that would be my next suggestion
05:47:04 <cheater> i'll be traversing the tree from the top.
05:47:19 <opqdonut> if its enough to see 1 level of parents, just change your traversal so it "hangs back" one level
05:47:38 <cheater> i'll be making a tree of possible commands in a shell, where commands that themselves are shells are going to be subtrees.
05:47:44 <cheater> (non-trivial ones)
05:47:48 <opqdonut> so it's like `f parent@(Node children) = map (do_something parent) children`
05:48:03 <cheater> nah i'll have to be able to exit back to the top
05:48:11 <opqdonut> mmh, then you can keep an explicit stack
05:48:38 <opqdonut> if you end up doing lots of tree navigation that involves changes to the tree, a zipper is probably the right abstraction
05:48:49 <opqdonut> but if this is read-only, maintaining a stack manually is probably enough
05:52:52 <cheater> no changes, read only
05:52:54 <cheater> thanks
06:14:18 <sshine> cheater, in case you need material: http://learnyouahaskell.com/zippers
07:12:35 <cohn> hi, is there a simple way to use the app operator (<*>) between more than two items?
07:12:54 <hyperisco> cohn, maybe you just want to use the <*> operator multiple times?
07:13:10 <cohn> hyperisco: exactly
07:13:41 <cohn> so, I can do this: pure (+) [listA] <*> [listB]
07:14:31 <cohn> but I want to do this (or whatever the syntactically correct way of doing it is): pure (+) (pure (+) [listA] <*> [listB]) <*> [listC]
07:15:49 * hackage elynx-markov 0.3.4 - Simulate molecular sequences along trees  https://hackage.haskell.org/package/elynx-markov-0.3.4 (dschrempf)
07:16:42 <sshine> cohn, besides liftM2, liftM3, etc.?
07:16:47 <efm> I have more infomation from the cocalc team about what they are trying to do to get haskell installed in a docker container on ubuntu20.04. It appears they are using PPA ghc, not ghcup. They ran into problems with this and IHaskell for use as a Juypter kernel. They need to have the IHaskell sandboxed, but not in the user's directory (they need it globally available). I have a detailed email I could forward.
07:16:50 * hackage elynx 0.3.4, tlynx 0.3.4, slynx 0.3.4, elynx-tree 0.3.4, elynx-tools 0.3.4, elynx-seq 0.3.4, elynx-nexus 0.3.4 (dschrempf)
07:16:54 <sshine> cohn, sorry, liftA2, liftA3, etc.
07:16:59 <cheater> sshine: thank you
07:17:00 <cohn> sshine: no idea what those are.  : (
07:17:11 <sshine> :t liftA2
07:17:13 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
07:17:18 <sshine> :t (<*>)
07:17:19 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
07:17:26 <cohn> ah, cool!
07:17:38 <cohn> Hoogle within IRC... lol
07:17:40 <sshine> liftA2 (+) [listA] [listB] -- it's just a convenience sometimes.
07:17:56 <cohn> sshine: thanks!
07:17:56 <hyperisco> cohn,   pure (+) <*> listA <*> listB <*> listC  perhaps?
07:17:57 <sshine> probably you like the use of <$> and <*> more often. :)
07:18:37 <hyperisco> up to you to figure out the Num instance for that
07:18:54 <cohn> sshine: yes
07:18:55 <dolio> It seems like this is a situation that ApplicativeDo would help.
07:19:11 <merijn> There more general usage would drop the pure and use <$> though
07:19:14 <dolio> Because the actual function is also complicated.
07:19:37 <merijn> Or Compose :p
07:20:11 <sshine> pure f <*> x   =   fmap f x   =   f <$> x
07:20:14 <dolio> do x <- listA ; y <- listB ; z <- listC ; pure (x + y + z)
07:20:26 <hyperisco> if the question is how to have a variadic function that adds all its arguments… firstly, don't have it. secondly, try the foldapp package
07:20:57 <hyperisco> sumOf <$> as <*> bs <*> cs  will do ya
07:20:57 <cohn> hyperisco: I'm fairly new to Haskell, so 99% of that went way over my head. 
07:21:09 <sshine> I'd stick with the first recommendation. :) variadic smells of too much generality.
07:21:47 <hyperisco> I went overboard and generalised printf
07:21:51 <sshine> :P
07:22:10 <cohn> just curious though, how much (if any) Haskell do you use in a work/production environment?
07:22:47 <hyperisco> I use it for a build system, and I use a different FP language primarily outside that
07:22:51 <sshine> since I sold out to cryptocurrencies, I actually get to do a fair bit.
07:23:01 <cohn> hyperisco: Scala?
07:23:06 <hyperisco> PureScript
07:23:07 <cohn> sshine: heh, nice!
07:23:13 <cohn> hyperisco: oh cool!
07:23:14 <maerwald> efm: have them ask here on their own
07:23:59 <efm> maerwald: I'll consider that
07:24:20 <sshine> cohn, so a compiler for a blockchain language, a property-test generator suite for a Solidity project, and some DevOps-related work on getting a Cardano-node to do staking (the Cardano-node happens to be coded in Haskell, but I don't actually touch the code).
07:24:31 <cohn> I'd like to get to the point of at least writing command line utilities using Haskell. I'm currently using Python but I love Haskell's type system and separation of pure and unpure (like IO) code
07:24:58 <sshine> cohn, then you might like https://hackage.haskell.org/package/shelly
07:25:07 <cohn> sshine: wow! I'd love to get to your level of mastery!
07:25:10 <IanLiu> When using ghci, is it possible to extract the value off of a Just?
07:25:34 <cohn> sshine: thanks, looking at shelly now
07:25:40 <hyperisco> oh you can also use  ((+)...(+)) <$> as <*> bs <*> cs  from the dotdotdot package :P
07:25:42 <sshine> cohn, actually, the Shelly docs suggest http://hackage.haskell.org/package/turtle for beginners :)
07:25:54 <cohn> haha
07:25:58 <maerwald> I don't understand the point of either of them
07:26:12 <sshine> cohn, https://github.com/Gabriel439/Haskell-Turtle-Library
07:26:23 <sshine> maerwald, of shelly and turtle?
07:26:29 <maerwald> yeah
07:26:44 <maerwald> if I want to do half-baked scripting, I use shell
07:27:13 <sshine> I don't use them, so I can't say. so, recently I've been doing some shell scripts for DevOps-related stuff, and you come to realize, using ShellCheck (which was written in Haskell, for those who don't know), that shell script is incredibly difficult to get right.
07:27:15 <__monty__> IanLiu: You can pattern match, `let (Just val) = myMaybe`
07:27:23 <__monty__> @hoogle isJust
07:27:23 <lambdabot> Data.Maybe isJust :: Maybe a -> Bool
07:27:23 <lambdabot> Distribution.Compat.Prelude.Internal isJust :: () => Maybe a -> Bool
07:27:23 <lambdabot> Network.AWS.Prelude isJust :: () => Maybe a -> Bool
07:27:26 <__monty__> Or that.
07:27:34 <__monty__> No, *fromJust
07:27:40 <sshine> maerwald, what if you want to do full-baked shell scripting? :)
07:27:48 <IanLiu> __monty__: ah, thanks!
07:27:53 <maerwald> sshine: I use shell
07:28:19 <cohn> thanks everyone for your help
07:29:23 <sshine> maerwald, I try to do only POSIX sh, so no BASH-isms simply to stick to one can of worms.
07:29:52 <IanLiu> @hoogle fromJust
07:29:52 <lambdabot> Data.Maybe fromJust :: Maybe a -> a
07:29:53 <lambdabot> Network.AWS.Prelude fromJust :: () => Maybe a -> a
07:29:53 <lambdabot> Data.Strict.Maybe fromJust :: Maybe a -> a
07:30:03 <sshine> maerwald, learning sh/bash, I might encourage spending time some other way. :-P
07:30:13 <maerwald> writing correct bash is easier than writing correct POSIX sh
07:30:35 <maerwald> So you could argue you're in fact more portable.
07:30:36 <sshine> how so? wouldn't you first have to know if anything is either bash or sh?
07:30:46 <maerwald> ?
07:31:08 <sshine> you're saying correct bash is easier. I'm saying it's harder because a precondition for writing correct bash is knowing what's bash and what's sh.
07:31:17 <maerwald> nah
07:31:23 <maerwald> you don't
07:31:41 <maerwald> valid POSIX sh is valid bash
07:32:20 <sshine> so I'm writing valid bash with the least amount of features. :-P
07:32:46 <maerwald> yes and just by invoking your script through the bash interpreter you're making your code more portable
07:32:51 <sshine> e.g. if you have both '[' and '[[' available to you, you have to know when those break down in particular syntactic ways... having just one, you only need to know how one of them works.
07:33:04 <sshine> I guess you could code bash and never use '[' and you'd have somewhat of a similar position as a POSIX sh coder.
07:33:58 <maerwald> if you allow your script to be run by arbitrary interpreters... no matter if posix sh or not... you're going to have more portability problems as opposed to hard-requiring bash
07:34:23 <sshine> I don't know... I think the point at which I decided POSIX sh was enough for me was realizing '[' is sufficient. :-)
07:34:41 <maerwald> I can't follow
07:35:06 <sshine> point is: both sh and bash have complicated edge cases. I prefer to minimize the quantity of edge cases.
07:35:09 <merijn> sshine: bash is a superset of POSIX sh
07:35:21 <merijn> Especially when you set the right options to be strict
07:35:36 <maerwald> sshine: you minimize the edge cases by restraining yourself to one interpreter
07:35:54 <maerwald> then you only have to deal with interpreter version problems
07:36:04 <sshine> and off-shoot dialects
07:36:09 <maerwald> that's far less than knowing how your shit behaves on ksh
07:36:11 <sshine> I suppose dash is mostly compatible with bash.
07:36:18 <maerwald> no
07:36:24 <mananamenos> hi, why does this `aMap = mapFromList [(4, 'a'), (10, 'b')]` give an error? Why can't the compiler infer thistype?
07:36:35 <sm[m]> bash plus shellcheck is a good combo
07:36:37 <sshine> there was a time when ubuntu shipped with dash wasn't there?
07:37:18 <sshine> okay, I guess I'm just arguing for "I'd rather just pick one" and "if I have to pick one and have no other preferences, I prefer the portable one"
07:37:25 <maerwald> $ [[ true ]]
07:37:27 <maerwald> dash: 1: [[: not found
07:38:18 <sshine> most recently I wanted a weak pseudo-random number generator and POSIX sh doesn't seem to have one, but bash has $RANDOM. that's the first time in a long while I needed a feature that was only in bash. :)
07:39:54 <sshine> sm[m], yeah, coding bash without shellcheck is like coding java without an IDE. :-D
07:41:03 <maerwald> weird part is that ShellCheck doesn't expose the bash parser
07:47:47 <__monty__> sshine: Isn't /dev/urandom posix?
07:48:44 <sshine> __monty__, apparently not.
07:49:22 <merijn> Probably SUSv2, then
07:50:16 <sshine> __monty__, I do realize I'm making up a problem by caring.
07:55:12 <IanLiu> How do I convert a unix time stamp (number of seconds since 1970-01-01 midnight utc) to a UTCTime?
07:56:54 <IanLiu> never mind, found it!
08:00:09 <merijn> \o/
08:32:13 <monochrom> [[ true ]] is not POSIX either
08:32:53 <monochrom> Err I guess that's tangential, nevermind.
08:49:27 <aldessa> I've looked for a couple days but haven't found a way to do a newline in pretty. How do I do a newline with pretty?
08:52:44 <efm> Thank you tomsmeding for your help in getting a solution to try for cocalc.
08:53:03 <tomsmeding> :D
08:56:04 <__monty__> aldessa: Isn't vspace what you want?
08:58:48 <merijn> "Isn't prettyprinter what you want?" ;)
08:59:21 <aldessa> __monty__ I can't find vspace, I also git grepped the source for that and it isn't in there.
09:00:08 <__monty__> aldessa: Yeah, I meant vsep. But it's from the prettyprinter packages, as merijn suggested : )
09:00:11 <merijn> There is no vspace, I think vcat is the best you can do
09:00:23 <merijn> __monty__: It doesn't have vsep either :p
09:00:35 <merijn> I'm not sure what's up with that package, but I'd just ditch it
09:00:35 <__monty__> No, but prettyprinter does.
09:05:00 <aldessa> this is really weird, there isn't a newline
09:06:53 <monochrom> $$ and $+$ and vcat
09:07:01 <monochrom> the operational word is "above"
09:07:51 <aldessa> OOOH thank you, that explains a lot
09:09:57 <monochrom> $$ will be smart in the sense "sometimes I'll continue on the same line because it fits".
09:10:33 <monochrom> If you absolutely insist on vertical splitting, $+$ obeys.
09:12:38 <tomsmeding> mananamenos: what is the error? Perhaps it doesn't know what numeric type you want for 4 and 10?
09:12:57 <tomsmeding> does it typecheck if you replace "4" with "4 :: Int" for example?
09:13:31 <wavemode> :t mapFromList
09:13:32 <lambdabot> error: Variable not in scope: mapFromList
09:13:45 <tomsmeding> (I assume that's Data.Map(.Strict).fromList)
09:13:55 <monochrom> Please don't assume.
09:14:10 <tomsmeding> well, my first response holds whatever the definition of mapFromList is :)
09:14:39 <monochrom> 100% of the time you will be surprised at the actual problem once you see the actual code and actual error message.
09:14:49 <tomsmeding> ... which is why I asked for the error message too :)
09:14:55 <wavemode> pretty sure he's using mapFromList from mono-traversable. which would explain why the compiler can't figure out what specific type of map he wants
09:15:12 <monochrom> Just yesterday I saw a beginner question containing the word "hashmap".
09:15:50 <monochrom> Fortunately it came with actual code. The actual code went like [(key1, val1), (key2, val2)] and that's what they called "hashmap".
09:16:04 <tomsmeding> nice
09:16:39 <monochrom> Apparently the wording was from the teacher. Yes some instructor was calling this "hashmap".
09:16:46 <tomsmeding> that's very bad
09:16:51 <aldessa> ty that helps
09:17:00 <monochrom> You just can't trust students because you don't even know what lie their teacher is telling them.
09:18:24 <monochrom> Here: https://pastebin.com/raw/s8M2yNLg
09:18:47 <monochrom> err s/hashmap/hash table/
09:18:56 <monochrom> Now you can't even trust me. :)
09:19:15 <wavemode> as they say, trust but verify
09:19:55 <tomsmeding> also, why does that code even use (>>=); this is a typical instance of fmap I'd say?
09:21:20 <monochrom> I guess imagine val1 = [(key10, val10), (key11, val11)] and you need to also do lookup inside that.
09:22:09 <tomsmeding> yes, so findElem "Herbert" <$> findElem "books" as
09:22:14 <monochrom> But I disagree with "this can chain forever".
09:22:43 <tomsmeding> oh crap that makes no sense
09:22:47 <monochrom> :)
09:25:09 <monochrom> Imagine [ (Shelf, [(Person, Work)]) ]   or equivalently  Map Shelf (Map Person Work).
09:26:27 <monochrom> In the outer dict you look up books or movies. You get an inner dict, now you look up say Wayne there.
09:26:33 <tomsmeding> maybe the teacher is used to languages with a js-like type system
09:26:55 <monochrom> Which inner dict you look up in depends on the answer from the outer lookup, so you need the data dependency of >>=
09:27:03 <sm[m]> practically speaking, how would you encourage/simplify the process for showing relevant details along with questions ? including for brand new folks who've just rolled in
09:27:28 <sm[m]> a !paste command giving canned instructions ?
09:27:35 <monochrom> brand news folks have only 10 lines of code so I say show it all
09:28:04 <tomsmeding> there is a paste link in the channel topic, but I guess that's not intuitively accessible in all irc clients
09:28:30 <sm[m]> yes, topic seems almost never visible 
09:28:31 <tomsmeding> (e.g. it took me ~1 year to figure out that the weechat topic bar actually scrolls)
09:28:35 <sm[m]> a bot that PMs new visitors with tips ?
09:28:55 <tomsmeding> the general reactions to such bots is "shut up" so I vote against
09:29:45 <sm[m]> it can save a lot of repetitive tedious advice. But it does change the feel of the channel I guess
09:30:03 <sm[m]> the !paste command, I mean
09:31:00 <monochrom> The !paste version is better than the autobot version.
09:31:19 <sm[m]> also: a new paste bin customized/structured for #haskell to elicit more info ? eg cabal or yaml file, stack yaml file, command, output, platform..
09:31:38 <monochrom> At least until one day the autobot uses natural language processing and deep learning to detect beginners.
09:32:52 <tomsmeding> sm[m]: building that pastebin service would be trivial, question is who'd host it
09:33:07 <sm[m]> trivial eh :)
09:33:27 <sm[m]> if you build it I'll host it :)
09:33:43 <tomsmeding> sure lol
09:33:46 <sm[m]> IHP would be a fun framework for the job
09:34:49 <tomsmeding> I was actually thinking about modifying something like https://privatebin.info/ to do the job
09:35:05 <tomsmeding> though I now see it's php, which lessens my enthousiasm somewhat
09:36:46 <sm[m]> I think something customised for #haskell makes it more worthwhile
09:37:12 <tomsmeding> how much customisation were you thinking about?
09:37:41 <sm[m]> at minimum, suggesting the different items I mentioned above
09:38:15 <tomsmeding> imagine you're starting from a baseline service that presents a textbox and a submit button on /, stores the code in RAM, and purges old submissions when memory goes over a certain limmit
09:38:32 <tomsmeding> so you say at minimum, some additional text on / and multiple text boxes
09:39:55 <sm[m]> alternately, there's https://repl.it/languages/haskell , though it's more suited to code snippets than install failures
09:40:09 <tomsmeding> and it's also fairly heavy-weight
09:43:02 <sm[m]> I'd like a smart pastebin that assists with preparing a report of, or even solving, 1. cabal/stack install problems, 2. small code compilation failures
09:43:25 <hyiltiz> ix.io/link/haskell would work?
09:44:03 <hyiltiz> We simple need to provide an instruction for a  curl call
09:44:12 <sm[m]> that gives me a blank page, so I have doubts
09:44:28 <hyiltiz> That is a link I typed in bed...
09:44:39 <hyiltiz> Let new get up and generate a proper one...
09:44:42 <sm[m]> no good for windows & gui people
09:44:46 <tomsmeding> if it works like "just curl your stuff to this URL", that's too beginner-unfriendly I think
09:44:49 <tomsmeding> ^
09:45:23 <hyiltiz> Hmm so you had to also have a Click Me feature
09:48:38 <hyiltiz> How about: https://paste.debian.net/
09:49:36 <sm[m]> ugly/bad UX, bare bones, missing the haskell-specific fields I mentioned
09:49:38 <tomsmeding> good, except now we want to modify the html shown :)
09:50:02 <hyiltiz> http://ix.io/2uPu/haskell is what I meant sm[m]
09:50:45 <hyiltiz> We could reskin and reset the defaults for paste.debian.net hosting software...
09:50:51 <sm[m]> stepping back, how would you implement !paste ? I think lambdabot is too hairy and undocumented, you'd be better off with a simple bot aimed at that use case
09:51:04 <sm[m]> s/simple/popular/
09:52:39 <sm[m]> simple to maintain and customize, I guess I mean. Ie built in a dynamic language (gasp)
09:55:39 <tomsmeding> I guess the language choice for such a bot mostly depends on the quality of an irc library for that language
09:55:57 <tomsmeding> because the functionality, outside of interacting with irc, would be ~0 :p
09:56:00 <monochrom> One kind of beginners, probably majority, will have trouble with shells and command lines. (They hide comfortably behind vscode though.)
09:56:13 <hyiltiz> https://bpa.st/ written in python (dynamic lang) has a nice interface
09:57:08 <monochrom> I just had a student in my unix-and-C course (so they had been using the command line for 4 months straight, we would think?) asking me this question.
09:57:45 <monochrom> So my exam question goes "blah blah...write a shell script to run pdflatex foo.tex iff these conditions..."
09:58:17 <monochrom> The student asked "how do I run pdflatex in shell script? bash doesn't give you fork and exec"
09:58:41 <monochrom> EXPECT YOUR AVERAGE BEGINNER TO BE WORSE
09:59:18 <hyiltiz> LOL! Would u approve if the student wrote: #!/bin/sh\n runhaskell runPdfLatex.hs 
09:59:41 <monochrom> Would you think they are ready for Haskell?
09:59:43 <hyiltiz> providing his own runPdfLatex.hs of course
10:00:25 <monochrom> Also if they knew they could just write down "runhaskell arg" they would not have that question in the first place.
10:01:21 <hyiltiz> !paste
10:01:31 <solonarv> "bash doesn't give you fork and exec", that's a new one
10:01:34 <monochrom> Anyway I think if the web page has too many boxes to fill in, it will be more confusing than helpful.
10:02:06 <hyiltiz> bpa.st has "too" many boxes? i.e. how many is too many?
10:02:54 <hyiltiz> I feel like there are more than a dozen public pastebin services that we could choose from; we probably just need a simple bot that responds to !paste
10:03:28 <monochrom> In particular problems that require you to read their *.cabal or package.yaml files, while there are significantly many, they are still a minority.
10:03:33 <hyiltiz> > let paste="Paste your stuff at https://bpa.st/"
10:03:34 <lambdabot>  <no location info>: error:
10:03:34 <lambdabot>      not an expression: ‘let paste="Paste your stuff at https://bpa.st/"’
10:03:48 <hyiltiz> > let paste="Paste your stuff at https://bpa.st/" in paste
10:03:50 <lambdabot>  "Paste your stuff at https://bpa.st/"
10:03:54 <hyiltiz> > paste
10:03:55 <lambdabot>  error: Variable not in scope: paste
10:04:11 <hyiltiz> @let paste="paste at https://pba.st/"
10:04:12 <lambdabot>  Defined.
10:04:15 <hyiltiz> >paste
10:04:30 <hyiltiz> > paste
10:04:32 <lambdabot>  "paste at https://pba.st/"
10:04:47 <monochrom> A web form that says "do you have a cabal file? if so put it here" is more likely to inspire a rabbit hole than inspire the beginner to simply answer "no I don't have one, I'm using ghci directly"
10:05:01 <merijn> monochrom: Writing assignment for students is like telling a wish to a genie
10:05:23 <monochrom> Beginners are super paranoid about "I have not learned enough, everything you mention I must learn NOW"
10:05:39 <merijn> That's why the educational lie was invented
10:06:02 <monochrom> You mention both cabal and stack, you can bet they will disappear for 2 weeks reading about cabal and stack.
10:07:06 <merijn> monochrom: And still miss the most important points somehow!
10:08:19 <monochrom> My experience with people who don't already know they should post their files, the overwhelming majority is they only have one 10-line *.hs file, one 50-line error message, and maybe they should also tell you which function to call with what input to reproduce their error message.
10:11:04 <monochrom> Yes merijn, I had an assignment handout that spent 50% of the text raving on about /dev/fd/number and what it means and your job is execlp(prog, prog, that filename, NULL).
10:11:18 <monochrom> And some student handed in execlp(prog, prog, NULL).
10:11:40 <monochrom> and no where in the rest of the code do you see any mention of "/dev/fd/whatever".
10:12:17 <monochrom> You would think that if 50% of the assignment handout talks about that filename, and your code doesn't have any resemblance of it at all, something is amiss, no?
10:13:29 <tomsmeding> I once TA'd a student that handed in a makefile (for a C++ project) that included the '-w' flag to GCC
10:13:33 <tomsmeding> FYI that disables all warnings
10:13:38 <hyiltiz> a -> b -> b is an unfinished homework; it should be a -> b -> (a,b) ?
10:13:51 <tomsmeding> it hid a warning that indicated sure crash at runtime, and indeed, it did crash
10:13:57 <hyiltiz> maybe their inner idea of what a homework is is different
10:14:16 <monochrom> I think I can trump that, tomsmeding. I had a few students attempting to submit Makefile.mk instead of Makefile
10:14:56 <monochrom> (My question and the submission system are super clear that the required name is Makefile )
10:15:43 <monochrom> Why is a->b->b an unfinished homework? In what context?
10:15:54 <ski> "Over the years, one of the top complaints that I have heard from people who have taken programming courses and found them very hard going is \"I could never make sense of the compiler error messages.\""
10:16:00 <hyiltiz> you suggested they left off a
10:16:05 <ski> "Come to think of it, one of the things that drives me up the wall is 3rd year students handing in C programs with obvious problems that the C compiler DID tell them about, but they weren't EXPECTING to understand anything the compiler said, so they didn't bother looking at what it did say or even the particular lines it was talking about."
10:16:19 <hyiltiz> didn't fully incorporate all givens aka (a,b)
10:17:09 <monochrom> Why do you have to formalize this???!!!!
10:17:35 <hyiltiz> Doesn't your syllabus explictly ask them to always gcc -Wall and submit one that makes gcc glad?
10:18:10 * ski . o O ( "Re: Mercury in academic teaching?" by Richard A. O'Keefe in 2006-10-(09,10) at <http://lists.mercurylang.org/archives/users/2006-October/004000.html>,<http://lists.mercurylang.org/archives/users/2006-October/004011.html> )
10:20:19 * hackage ListLike 4.7.2 - Generalized support for list-like structures  https://hackage.haskell.org/package/ListLike-4.7.2 (DavidFox)
10:21:49 * hackage shake-dhall 0.1.1.1 - Dhall dependencies  https://hackage.haskell.org/package/shake-dhall-0.1.1.1 (vmchale)
10:24:28 <hyiltiz> Going back to the original topic, if the masses after that !paste is a/one good solution to these problems
10:24:56 <hyiltiz> s/after/think
10:25:19 <hyiltiz> And sm is offering to host 
10:25:23 <monochrom> masses no, we yes
10:25:46 <hyiltiz> We just need to pick an ircbot implementation from the sea of them
10:26:08 <hyiltiz> Or just write yet another ircbot 
10:26:19 <hyiltiz> Surely that name is taken
10:26:25 <monochrom> Actually...
10:26:28 <monochrom> @where paste
10:26:28 <lambdabot> https://gist.github.com
10:27:03 <monochrom> I think we can start using that more already. Unless you say the whole point is a paste site customized for us.
10:27:20 <merijn> I dislike gists, tbh
10:27:21 <monochrom> (I won't object.)
10:27:23 <hyiltiz> GitHub seem to require sign in before showing Create button
10:27:25 <merijn> It's too much work to make a paste
10:27:50 <merijn> And I dislike the JS heavy and/or ad heavy ones too
10:28:03 <merijn> I've been using debian paste for a while, but it's ugly
10:28:06 <monochrom> Yeah I dislike gist too, but I'm sure other people dislike my favourite paste site. I'm not going to bikeshed it. You guys vote on your favourite paste site, I'll support you.
10:28:14 <hyiltiz> Also !paste command probably in intuitive for a beginner to "accidentally" type
10:28:34 <monochrom> No.
10:28:47 <merijn> I don't think that ever happens, tbh
10:28:48 <monochrom> Only the nipple and !list are intuitive.
10:29:08 <merijn> Only "!list" gets used and that seems to be only by Italians for some weird reason :p
10:29:12 <hyiltiz> !nipple
10:29:15 <monochrom> And the latter, only to people looking for illegal downloads.
10:29:50 <monochrom> In fact have you tried !list here lately? >:)
10:29:59 <hyiltiz> !list
10:29:59 <monochrom> hyiltiz: http://lpaste.net/browse
10:30:14 <monochrom> hrm why does it not work?
10:30:18 <hyiltiz> Broken
10:30:21 <sm[m]> hyiltiz: well now, I offered to tomsmeding in doubt of their claim it would be trivial to build. It's not a permanent invitation to host any old thing :)
10:30:26 <monochrom> (I'll tell you what I have in mind soon)
10:31:07 <hyiltiz> sm sure we got what you meant
10:32:39 <sm[m]> since there's lots of interest, we should deploy a number of paste apps & bots, let them compete and improve until something great emerges
10:33:15 <monochrom> Err, !list worked, I merely misread.
10:33:35 <monochrom> But  http://lpaste.net/browse doesn't exist anymore, I have to update my list.
10:33:43 <sm[m]> I guess bot is first priority. That can at least guide people to a decent existing pastebin and suggest some things to paste
10:34:29 <monochrom> sm[m]: Is "@where paste" not good enough?  We can change where it points to, if gist isn't great.
10:34:47 <sm[m]> @where paste
10:34:47 <lambdabot> https://gist.github.com
10:36:00 <sm[m]> it's something, and already works. If the text were improved and we made it more discoverable, it's contender #1
10:36:56 <hyiltiz> %paste
10:37:15 <hyiltiz> %where paste
10:37:52 <hyiltiz> Contender 2 3 can live there it seems
10:38:28 <sm[m]> @where needs documenting at https://wiki.haskell.org/IRC_channel#lambdabot
10:38:28 <lambdabot> I know nothing about needs.
10:38:39 <monochrom> I think maybe you haven't known my idea.  I do not expect beginners to discover "!paste" or "@where paste" themselves---short of a complete drop-down menu system, nothing is discoverable.  My idea is we regulars know the command and use it.
10:39:29 <hyiltiz> @where nipple
10:39:29 <lambdabot> I know nothing about nipple.
10:39:45 <sm[m]> monochrom: yes, I mean it needs to be more discoverable for people in the channel who are available to answer - not just "regulars" I think
10:39:55 <hyiltiz> @where lambdabot
10:39:55 <lambdabot> http://haskell.org/haskellwiki/Lambdabot
10:39:58 <sm[m]> if we used it more often, that'd probably take care of it
10:41:24 <hyiltiz> @help
10:41:24 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
10:41:31 <hyiltiz> @help where
10:41:31 <lambdabot> where <key>. Return element associated with key
10:42:59 <hyiltiz> sm[m]: https://wiki.haskell.org/IRC_channel#lambdabot looks good now?
10:43:38 <sm[m]> good start, thanks hyiltiz . What's the procedure for updating the message ? @where <key> <text> ?
10:44:02 <hyiltiz> @where test me
10:44:02 <lambdabot> `echo test
10:44:06 <hyiltiz> @where test
10:44:06 <lambdabot> `echo test
10:44:19 <hyiltiz> @where someNewKey
10:44:19 <lambdabot> I know nothing about somenewkey.
10:44:19 * sm[m] wrote it down but lost the doc
10:44:24 <hyiltiz> @where someNewKey Huh
10:44:24 <lambdabot> I know nothing about somenewkey.
10:44:52 <sm[m]> @ where+ newkey newtext maybe
10:45:04 <monochrom> @list where
10:45:04 <lambdabot> where provides: where url what where+
10:45:19 <monochrom> That "where" is a module name from "@listmodules"
10:45:20 <hyiltiz> @where+ someNewKey Huh
10:45:20 <lambdabot> Done.
10:45:26 <hyiltiz> @where someNewKey
10:45:26 <lambdabot> Huh
10:45:52 <monochrom> hrm
10:45:53 <ski> @where+ someNewKey I know nothing about someNewKey.
10:45:53 <lambdabot> Okay.
10:45:55 <sm[m]> lambdabot's help is a twisty maze of little passages, all alike :)
10:47:08 <monochrom> Ah ok, @where+ is the one.
10:47:14 <ski> yes
10:47:40 <hyiltiz> @where paste2 https://bpa.st/
10:47:41 <lambdabot> I know nothing about paste2.
10:47:46 <monochrom> Today I'm just randomly misreading lines and thinking "that didn't work".
10:47:47 <hyiltiz> @where+ paste2 https://bpa.st/
10:47:47 <lambdabot> I will remember.
10:48:22 <hyiltiz> @where+ paste3 https://paste.debian.net/
10:48:22 <lambdabot> Good to know.
10:48:28 <ski> @paste
10:48:28 <lambdabot> A pastebin: https://paste.debian.net/
10:48:29 <hyiltiz> There two more contenders
10:48:34 <monochrom> How do you delete or GC those keys and values, btw?
10:48:39 <ski> you don't
10:48:43 <hyiltiz> :(
10:48:44 <ski> you do what i did, above
10:49:15 <hyiltiz> ah, you overwrite them with default string 
10:49:24 <sm[m]> so maybe it's overkill but for maintainability and to avoid unwanted content drift (spammers eg) we'd have some git repo storing any of this content that's valuable
10:49:55 <merijn> This is why Chris stopped maintaining lpaste, he was spending ages weeding out spam and worse
10:50:03 <sm[m]> I guess lambdabot dumps its facts as a text file somewhere
10:50:32 <monochrom> I believe that after all these past decades, no spammer has yet to discover our @where+
10:51:04 <ski> maybe if you'd document it enough, visibly ? ;)
10:51:37 <sm[m]> it's more that it discourages investing time in putting good content in, if you know it can be silently lost at any time
10:51:57 <monochrom> OK, now my !list has 1/3 chance of serving you the ghcup url. :)
10:52:21 <monochrom> basically it randomly picks one of: oleg url, ghcup url, hackage url
10:52:47 <ski> i have a bunch of `where' associations memorized that i mention, when relevant to the topic
10:52:49 * hackage shake-dhall 0.1.1.2 - Dhall dependencies  https://hackage.haskell.org/package/shake-dhall-0.1.1.2 (vmchale)
10:53:03 <sm[m]> a fact bot allowing admin via both irc and git push would be nice
10:53:40 <hyiltiz> !list
10:53:41 <monochrom> hyiltiz: http://okmij.org/ftp
10:53:52 <ski> @where oleg
10:53:52 <lambdabot> http://okmij.org/ftp/
10:53:55 <monochrom> that's the oleg url
10:54:06 <hyiltiz> !list
10:54:17 <monochrom> Now your weekend is ruined!
10:54:17 <ski> probably throttled
10:54:23 <hyiltiz> OooOoo~ this is like rock paper scissors
10:54:23 <monochrom> Yes, throttled
10:54:31 <hyiltiz> Someone else try
10:54:49 <ski> hyiltiz : maybe if you say "ciao a tutti", inbetween ?
10:55:27 <monochrom> A cool-down time 1 minute. You can try again now
10:55:39 <hyiltiz> !list
10:55:40 <monochrom> hyiltiz: https://hackage.haskell.org/
10:56:28 * sm[m] finds https://limnoria.net bot, bookmarked last time
10:56:58 <hyiltiz> ghcup > hackage > oleg > ghcup (for a rock-paper-scissors)?
10:57:50 <monochrom> No, it doesn't cycle, it consults PRNG.
10:58:01 <hyiltiz> @where+ goodBot Among sm[m]'s favourites: https://limnoria.net 
10:58:01 <lambdabot> It is stored.
10:58:39 <monochrom> Err no, sorry! It consults millisecond clock. :)
10:59:15 <ski> btw, it's probably a good habit to check with `@where', right before setting with `@where+', to see whether there's already something there
10:59:33 <hyiltiz> Hmm good point thx
11:00:07 <ski> (i tend to do that, visibly, in the channel, whenever i'm setting or updating an association)
11:00:19 <hyiltiz> @where where
11:00:19 <lambdabot> ^^^^^^
11:00:20 <dolio> Also it's pointless to store a bunch of information in there when you won't think of it 3 days from now.
11:00:27 <ski> yes
11:01:15 <hyiltiz> Lost key is there same as lost memory. 
11:02:08 <sm[m]> ski, do you operate lambdabot ?
11:02:11 <ski> no
11:03:08 <monochrom> OK I'm going to go ahead and @where+ paste to: Please post complete code and verbatim error message at https://gist.github.com
11:03:33 <ski> i probably have made some tens of entries with `where', though
11:03:35 <monochrom> But if you think of a better pastebin, please do replace it :)
11:03:46 <monochrom> @where+ paste Please post complete code and verbatim error message at https://gist.github.com
11:03:46 <lambdabot> Done.
11:04:19 <hyiltiz> Any way for where to list all stored keys?
11:04:44 <monochrom> Hrm! @url is alias for @where
11:05:01 <monochrom> I think it doesn't list.
11:05:27 <ski> (some of the entries i made because i got tired, after some years, of repeating the same information)
11:05:42 <merijn> ski: Same
11:05:43 <monochrom> This is like representing a dictionary by X -> Maybe Y. :)
11:05:46 <merijn> Or locating urls :p
11:05:52 <ski> yep
11:06:24 <ski> indeed, monochrom :) .. (i was just thinking of that, a few minutes ago)
11:06:27 <monochrom> There is a Chinese idiom for this. "A safe with the key lost".
11:06:45 <ski> well, it's safe and secure
11:07:17 <sm[m]> or: help us help you: at https://gist.github.com or https://hastebin.com please paste full code, command, output, cabal/stack files, mention platform, ghc/cabal/stack versions etc.  ?
11:07:24 <monochrom> Usually this idiom refers to a rich person you're trying to scam from, then you discover the rich person doesn't have access to their money (e.g., it's by inheritance, but something went wrong)
11:07:46 <sm[m]> github is sometimes too heavy / not everyone has or wants to use a github account 
11:08:56 <hyiltiz> Sounds good though I'd skip mentioning platform cabal stack etc. for reasons discussed above
11:09:16 <monochrom> I don't like hastebin's colours. But I agree gist is too bureacratic.
11:10:19 <sm[m]> hastebin is the cleanest/best I could think of off the top of my head with a web UI, replacements welcome
11:10:20 <ski> <paste.lisp.org> is no more, alas
11:11:00 <monochrom> @where+ paste Help us help you: at https://hastebin.com please paste full code, input, and output
11:11:00 <lambdabot> It is forever etched in my memory.
11:11:19 <sm[m]> something that works without js is also preferable
11:11:24 <ski> yes
11:11:40 <monochrom> For now I'm still hesitant to bring up cabal, stack, the rest, as explained. But we'll see.
11:12:24 <monochrom> The thing is my experience of the probability of (cabal/stack problem but the asker didn't think of posting) is not very high.
11:13:30 <monochrom> Let's say about 50%.  Compared to 99.9% for (basic 10-line haskell code problem but the asker didn't think of even pasting 10 lines of code)
11:13:59 <sm[m]> I seem to see many "it failed to build, haskell sucks" reports - can't remember if they're more here or on reddit these days - and pretty much 0% of those come with any of the necessary config files, command, or output
11:14:36 <monochrom> I bet reddit then. I don't see a lot here. Definitely not concluding "haskell sucks".
11:14:43 <sm[m]> a simple message is great for today, could refine it daily/weekly based on needs
11:15:58 <hyiltiz> @where+ paste Help us help you: at https://hastebin.com please paste full code, input, and output.
11:15:58 <lambdabot> Okay.
11:16:03 <merijn> reddit comments suck
11:16:13 <hyiltiz> Was missing a .
11:16:16 <merijn> Even in /r/haskell (although somewhat less than reddit as a whole)
11:16:29 <merijn> I mostly stick to just the posts and skip the comments :p
11:18:48 <sm[m]> hastebin is not so good for multiple files either
11:19:00 <justsomeguy> Many social media platforms are built on collectively making fun of some external group, or outrage cycles. I feel like that behavior originated in the political subs, but has bled into the technical subreddits now, too.
11:19:22 <merijn> pfft, plenty of tech reddits where shite for years
11:19:32 <justsomeguy> They're all bad.
11:19:47 <justsomeguy> Even my comments.
11:19:47 <merijn> Just look at hackers news comments
11:20:00 <sm[m]> how about a
11:20:00 <sm[m]> @where+ cabalstackhelp Help us help you: at https://gist.github.com or https://hastebin.com please paste your failing command, the full output, and your .cabal, package.yaml and/or stack.yaml files if appropriate
11:20:00 <lambdabot> It is stored.
11:20:05 <merijn> The problem is that most tech people have plenty of int, but not enough wis :p
11:20:15 <justsomeguy> merijn: Apple hate, VC worship, lisp lust, self aggrandizement...
11:20:27 <ski> sm[m] : are you writing down these keys somewhere, so that you're reminded they exist ?
11:21:11 <sm[m]> yes I will write down these two
11:21:24 <sm[m]> soon as I track down my lambdabot notes file..
11:22:36 <__monty__> I feel like cargo-culting wouldn't be such a big thing if it was high int, low wis.
11:22:58 <sm[m]> or..
11:22:59 <sm[m]> @where keys
11:22:59 <lambdabot> I know nothing about keys.
11:23:09 <merijn> Well, maybe not all of them have high int, but they definitely all have low wis :p
11:23:12 <sm[m]> @where+ keys Some useful @where queries: keys paste cabalstackhelp
11:23:12 <lambdabot> Good to know.
11:23:21 <hyiltiz> Yeah we should store keys too
11:24:00 <hyiltiz> @where+ keys.bak Some useful @where queries: keys paste cabalstackhelp
11:24:00 <lambdabot> Okay.
11:24:08 <hyiltiz> Just in case.
11:24:20 <merijn> ...
11:24:21 <ski> maybe "hyiltiz.keys" ?
11:24:55 <sm[m]> keys.bak.2020-08-21.1
11:26:13 <merijn> Just use the hash  of the contents
11:29:39 <monochrom> haha
11:30:36 <monochrom> Sorry, what is high int, low wis?
11:30:36 <merijn> I'm a funny guy ;)
11:30:49 <merijn> monochrom: intelligence and wisdom, 2 of the 6 core stats
11:30:57 <dolio> I think it's what you've been witnessing for the last half hour.
11:31:24 <merijn> monochrom: Intelligence is "book smarts" vs wisdom which is "street smarts". The common summary is: Intelligence is knowing a tomato is a fruit, wisdom is knowing it has no business in a fruit salad ;)
11:31:45 <__monty__> That's not a very common definition of intelligence.
11:32:43 <merijn> monochrom: Intelligence is just your ability to deduce things from stuff you know and insights in systems, wisdom is your ability to contextualise
11:33:43 <dolio> Tomataoes are only fruits if you think botanists get to pick the True definition of every word.
11:33:45 <merijn> monochrom: Or, in hacker news terminology, int is your ability to dream up "lets replace the justice system, job interviews, and academic evaluations with machine learning predictions!", wisdom is the ability to foresee that in the grand scheme of things that might not be wise ;)
11:34:02 <wavemode> yeah... knowledge vs. intelligence vs. wisdom are often conflated
11:34:46 <merijn> Fortunately knowledge is not a stat in D&D and thus irrelevant to my examples :p
11:34:50 <wavemode> (and, conversely, ignorance vs. stupidity vs. foolishness)
11:36:14 <int-e> Hmm... wisdom.
11:36:34 <int-e> I'd imagine that wisdom entails knowledge.
11:37:03 <wavemode> it does! but having knowledge doesn't necessarily mean you have wisdom
11:37:09 <int-e> Oh, sure.
11:38:46 <MarcelineVQ> Does a wise person consider themselves wise?
11:39:36 <ddellacosta> I think knowledge + experience + self-awareness + thinking hard about how you reconcile all of those = wisdom
11:39:55 <monochrom> 1st-level wise doesn't, 2nd-level wise does, 3rd-level wise doesn't, 4th-level wise does. etc etc  odd levels don't, even levels do.
11:39:58 <MarcelineVQ> I propose that having wisdom is something others attribute to you, and being wise only requires that you have convinced others that you are.
11:39:58 <ddellacosta> and I think a truly wise person knows how wise they are without needing to exaggerate or downplay it
11:40:21 <monochrom> This is because a wise person is in perpetual conscious struggle with the Dunning-Kruger effect. :)
11:40:36 <ddellacosta> is that the extensional perspective?
11:40:44 * ddellacosta ducks
11:42:46 <int-e> monochrom: the opposite is not true :P
11:42:58 <MarcelineVQ> dunning-kruger is what you call it when you want to cause people to suddenly recognize someone they know across the room when you say it, imposter syndrome othewise :>
11:43:58 <wavemode> the difference is that DK also applies to reverse-imposter syndrome
11:44:13 <MarcelineVQ> That's just the kind of correction that ruins the party atmosphere my dude
11:44:32 <monochrom> I'll continue in #haskell-offtopic. I have a great idea.
11:44:46 <MarcelineVQ> I​ have a cunning plan
11:44:52 <sm[m]> lambdabot puzzles: why no response for (specifically):
11:44:52 <sm[m]> @where ghcide-tips
11:44:53 <ski> MarcelineVQ : just about to say ;)
11:45:35 <tomsmeding> sm[m]: I have a basic pasting service written in haskell
11:45:37 <sm[m]> a factoid I set, or tried to set, last november. @where ghcide-x or x-tips works.
11:46:37 <sm[m]> go tomsmeding, link the demo when ready ?
11:46:37 <merijn> sm[m]: Fun fact: "a factoid" contrary to what people commonly think does not mean "a small/fun fact" it means "something that sounds like a fact, but isn't" :p
11:47:08 <tomsmeding> sm[m]: will add some XSS protection, then will put online
11:47:09 <wavemode> language evolves
11:47:24 <sm[m]> ack. Was trying to follow common irc bot terminology
11:47:38 <sm[m]> good point, thanks merijn
11:47:44 <merijn> sm[m]: Or rather, per Oxford: "an item of unreliable information that is reported and repeated so often that it becomes accepted as fact."
11:48:19 <sm[m]> I'll go with "topic" I guess
11:48:49 <sm[m]> hmm, doesn't work exactly
11:48:57 <monochrom> Just say "data'>
11:50:39 * ski . o O ( "datum" in singular )
11:51:09 <monochrom> Yeah I wish people used "datum" more and respected that "data" were plural.
11:51:14 <sm[m]> https://wiki.haskell.org/IRC_channel#lambdabot -> @where updated
11:51:30 <hyiltiz> [14:41] <monochrom> 1st-level wise doesn't, 2nd-level wise does, 3rd-level wise doesn't, 4th-level wise does. etc etc  odd levels don't, even levels do.
11:51:55 <hyiltiz> The infinite level does half the time, according to the zeta function?
11:51:59 <operand> What is the recommended way to install stack on arch?
11:52:48 <operand> It doesnt show up in ghcup and I somewhat distrust pacman for all things haskell :p
11:52:54 <sm[m]> https://www.fpcomplete.com/haskell/get-started is at least one reliable way, operand
11:53:52 <justsomeguy> operand: My advice is: Don't use pacman, download the binary from the github releases page and put in in $PATH. ... https://docs.haskellstack.org/en/stable/install_and_upgrade/
11:54:03 <int-e> sm[m]: you can look at http://silicon.int-e.eu/lambdabot/State/where (gzip file) and see what's special about ghcide-tips
11:54:35 <sm[m]> ah thanks int-e. Are you lambdabot's operator ?
11:54:50 <int-e> yes
11:55:33 <hyiltiz> @where+ owner int-e 
11:55:33 <lambdabot> Okay.
11:56:12 <sm[m]> hehe
11:56:24 <sm[m]> int-e: cool. It seems ghcide-tips' content is empty
11:56:35 * sm[m] removes it
11:56:37 <hyiltiz> fe8019@where+ keys.gzip look at http://silicon.int-e.eu/lambdabot/State/where
11:56:59 <tomsmeding> what's that a hash prefix of
11:57:07 <int-e> @where state
11:57:07 <lambdabot> https://silicon.int-e.eu/lambdabot/State/
11:57:22 <operand> sm[m], justsomeguy: Thanks, that's a statically linked binary right?
11:57:24 <int-e> hyiltiz: if you make such an entry, you can use https...
11:57:31 <int-e> (I just updated the other ones)
11:57:40 <justsomeguy> operand: Yes.
11:58:01 <operand> OK, there's a statically linked package available in the AUR, that seems more convenient, thanks a lot!
11:58:22 <Voidophone> I've been trying to figure out where to start coding replacement rules into haskell, but I keep slipping back into imperative thinking and I need some help. The system has a set logical predicates and then if a rule matches it fires and replaces predicates with new ones.
11:58:51 <merijn> Voidophone: tbh, I wouldn't worry *too* much about "slipping back into imperative" thinking
11:59:11 <merijn> 1) sometimes it's easier, 2) Haskell is an underrated imperative language :p
11:59:38 <merijn> Highly relevant: https://twitter.com/k0001/status/1295846402648682496 ;)
11:59:56 <sm[m]> int-e: is that state file live, up to date ?
11:59:57 <int-e> sm[m]: there should probably be an @where- command, but there is not.
12:00:31 <int-e> sm[m]: pretty much. there's some delay because lambdabot does not save the state on every command
12:01:49 <merijn> Voidophone: That said, you can always ask for advice, but your question is broad to the point no one knows what you're really doing :)
12:01:56 <sm[m]> int-e, right, I suspect there's no way to delete @where topics completely. With no content it says Done but if you query for it again you still get no response rather than I know nothing
12:02:13 <tomsmeding> sm[m]: http://nonssl.tomsmeding.com:8123/
12:02:14 <monochrom> Voidophone: Don't replace. Compute new version.
12:02:39 <monochrom> Toy example: How do I increase x by 1?  Answer: Don't, compute x+1.
12:03:15 <tomsmeding> funny how my server is suddenly spammed with requests from The Lounge IRC Client
12:03:24 <monochrom> Less toy example: BST insert. Don't "change" the input tree. Compute, even produce, the output tree.
12:03:57 <merijn> sm[m]: Patches welcome? ;)
12:04:13 <monochrom> in fact s/the output/a new/
12:04:48 <sm[m]> a nice lambdabot mission for somebody! 
12:05:24 <Voidophone> Alright that does help, I shouldn't think of it as mutating the world but just computing a new one. I'll take a crack at it and see if I can get to the point where I have some better questions.
12:05:40 <ski> @quote there.is.no.state
12:05:40 <lambdabot> MonadState says: Do not try to change the state; that's impossible. Instead only try to realize the truth: There is no state.
12:06:04 <sm[m]> good start tomsmeding 
12:06:17 <tomsmeding> sm[m]: the point is that this is infinitely customisable :)
12:06:37 <hyiltiz> Syntax highlighting? http://nonssl.tomsmeding.com:8123/paste/1EmlLtDb
12:06:47 <monochrom> Heh my state monad lecture says "state var fantasy" and "mathematical reality of s->(s,a)"
12:06:52 <sm[m]> of course, a simple matter of programming. It's still far from a production server I bet
12:07:05 <monochrom> err actually s/fantasy/fairy tale/
12:07:15 <tomsmeding> sm[m]: the source is 1 haskell file using snap-server; it's 195 lines
12:07:18 <tomsmeding> hardly production code
12:07:25 <tomsmeding> well there's 3 html files too
12:07:33 <tomsmeding> hyiltiz: allowed to be client-side JS?
12:08:28 <monochrom> I wouldn't place colouring at a high priority.
12:08:52 <monochrom> 10-to-1 spam war has a much higher priority.
12:09:11 <tomsmeding> what does "10-to-1 spam war" mean?
12:09:34 <monochrom> In fact, when people use pastebin.com, I click on "raw" and lose the colouring and it's absolutely better.
12:09:49 <sm[m]> same
12:09:55 <monochrom> I bet you with 10-to-1 odds that spam war is higher priority than colouring.
12:10:11 <sm[m]> after I cry "my eyes!" and squint
12:19:34 <tomsmeding> sm[m]: hyiltiz: https://github.com/tomsmeding/pastebin-haskell
12:20:19 <tomsmeding> feel free to open PR's with stuff you'd like to see :)
12:20:59 <monochrom> I guess colouring is easily done by importing someone else's library, though low priority but little work.
12:21:03 <hyiltiz> tomsmeding: u grok up 200 lines of haskel while we chat n chat n chat n ...?
12:21:23 <tomsmeding> hyiltiz: I turn brown bread with peanut butter into code
12:21:39 <monochrom> "If you can chat slowly you can code quickly"
12:22:01 <tomsmeding> monochrom: there are plethora of client-side JS libraries for highlighting code; you'd even be able to lazy-load them when clicking a button
12:22:11 <hyiltiz> I think I should keep a safe distance from IRC so I can be like tomsmeding as well
12:22:13 <tomsmeding> serving the ones who like to have a light page without that stuff :)
12:22:50 <monochrom> Yeah I think people are OK with that.
12:27:49 * hackage url-bytes 0.1.0.0 - Memory efficient url type and parser.  https://hackage.haskell.org/package/url-bytes-0.1.0.0 (goolord)
12:29:29 <sm[m]> int-e: ok to mention/credit you as operator at https://wiki.haskell.org/IRC_channel#lambdabot ?
12:31:46 <hyiltiz> I agree syntax highlighting is secondary; it is just one eww away anyway
12:32:03 <tomsmeding> eww?
12:32:05 <int-e> sm[m]: sure
12:32:59 <sm[m]> done
12:59:45 <ollehar> I just implemented typed effects in PHP with the help of static analyzer Psalm
13:00:05 <ollehar> `@return Generator<WriteIO|HttpIO>`
13:00:41 <ollehar> If anyone is interested: https://gist.github.com/olleharstedt/9942d8cb06541239e35d2fb7e8451966#file-amp_io-php-L109
13:00:46 <ollehar> Gonna write a proper article later
13:00:48 <systemfault> "Yeah, but your scientists were so preoccupied with whether or not they could, they didn't stop to think if they should." --Dr. Ian Malcolm
13:00:51 <systemfault> :)
13:00:54 <ollehar> hahaha yeah
13:01:02 <systemfault> Will definitely look at that for fun though
13:01:07 <ollehar> thanks ^^
13:01:26 <ollehar> this will help: amphp.org
13:01:45 <ollehar> Amphp + lazyness = side-effect free PHP
13:03:36 <hyperisco> it looks like a lot of side effects going on in saveFile
13:03:58 <hyperisco> I'll excuse variable initialisation
13:04:00 <ixlun> Is there a convention for where typeclass instancies should be defined? 
13:04:30 <ixlun> i.e. in the typeclass module or the class' implementation module?
13:05:41 <ollehar> hyperisco: it's all yielded
13:05:43 <hyperisco> ixlun, if the type is in someone else's package then in the class file. If the type is in your package then in the type's file.
13:06:09 <ollehar> and all objects that are yielded are lazy promises
13:06:17 <ollehar> (or, wrap lazy promises)
13:06:32 <ollehar> so it's possible to iterate through all effect objects of saveFile() without executing any side-effects.
13:07:18 <hyperisco> okay, if we say setBody doesn't count because it isn't visible, and that throw new Exception doesn't count
13:07:25 <sm[m]> I converted the current @where db to TSV: https://termbin.com/enr19
13:07:37 <ollehar> of course it doesn't stop you from doing whatever in saveFile() - to apply such restriction, you need to design a framework properly.
13:07:41 <ixlun> hyperisco: great thanks! It's my own package so I'll keep the implementations within the typeclass module.
13:07:58 <ollehar> hyperisco: right, didn't think of the exception :d
13:07:58 <sm[m]> a few records have miscoded/unknown-encoded characters removed
13:08:16 <ollehar> so it's pure but not total...? if pure = div|exn (div by zero or exception thrown)
13:09:27 <ollehar> setBody() could be withBody(), to return new request. some PHP objects follow this convention.
13:09:32 <ollehar> but not here
13:10:25 <hyperisco> I feel like you want to yield the exception
13:11:34 <ollehar> hyperisco: thought about it, but it's not how Amphp design the flow.
13:11:51 <ollehar> If you check this line, it's very similar to IO monad mocking: https://gist.github.com/olleharstedt/9942d8cb06541239e35d2fb7e8451966#file-amp_io-php-L138
13:12:09 <hyperisco> well possibly it handles the exception… so it is treating generators as though they can throw
13:12:38 <ollehar> Yeah, all that stuff is in the main Loop::run()
13:14:00 <hyperisco> now why are you flagellating yourself like this
13:15:44 <ollehar> hyperisco: because effect mocking > dependency mocking (I think/hope)
13:16:28 <hyperisco> good luck but it failed for me
13:16:45 <ollehar> what failed? effect mocking?
13:17:05 <ollehar> or the concept?
13:17:12 <hyperisco> it was hugely more complicated for an imperceptible benefit
13:17:36 <hyperisco> never mind less efficient
13:18:14 <ollehar> hyperisco: are you talking about your experience in haskell, or my PHP concept?
13:18:29 <hyperisco> neither but it is analogous
13:19:11 <ollehar> well, you also get concurreny for free with Amphp, if you yield an array of effect promises.
13:19:39 <ollehar> Last time I was doing dependency mocking with PHP it was %$#@^
13:19:49 <ollehar> But, an experiment is an experiment. We'll see.
13:20:11 <hyperisco> I just swap files
13:20:47 <ollehar> Not following
13:21:08 <hyperisco> there are one or more files that comprise all the definitions which are environment dependent
13:21:25 <hyperisco> you're talking about mocking so I presume you have a test environment and a real environment
13:21:36 <hyperisco> so, two versions of those files, one for each environment
13:21:51 <hyperisco> build system just selects the desired set
13:21:56 <ollehar> I wanted to avoid fixtures completely, if that's what you mean.
13:22:20 <hyperisco> I understand fixtures to be sample data, so I am not sure how that relates
13:22:42 <ollehar> Fixtures can also be the file-system your code is acting on
13:22:55 <hyperisco> sounds like sample data
13:23:00 <ollehar> Well :)
13:23:02 <ollehar> Maybe
13:24:01 <ollehar> Anyway, in my sample code above, you don't have to mock the file writer, and not the httpclient - so just don't run the yielded promises.
13:24:37 <ollehar> The only mock is the response from the http request.
13:25:28 <ollehar> Hm, I had a good article about this for Haskell...
13:26:36 <hyperisco> to me, an effect system like this suggests there should be many interesting ways to interpret the effects, and especially dynamically
13:27:00 <ollehar> hyperisco: that's getting closer to the "free monad", right? :)
13:27:15 <hyperisco> sure
13:27:16 <ollehar> sadly, in this case, the effect is just wrapped in a closure.
13:27:28 <hyperisco> but in the case of needing a few definitions swapped from live versions to test versions is not an exciting case for that
13:28:10 <hyperisco> so IMO it is a lot of engineering and fuss, and a cost to efficiency
13:28:29 <ollehar> the biggest downside for me is that the tests are tightly coupled
13:28:39 <ollehar> if you remove logging from saveFile(), the tests will fail
13:28:51 <ollehar> tightly coupled with the implementation*
13:30:12 <ollehar> but, if you already need concurrency (in PHP), then this step is not that big, just some extra wrappers.
13:30:40 <hyperisco> I am not convinced this relates to concurrency, even if Amphp has extra facilities for it
13:31:29 <hyperisco> anyways, that is just my story. your mileage may vary
13:31:30 <dansho> how can i write this? (not worried about overflow right now) https://hastebin.com/vetuzeyeri.hs
13:32:50 <monochrom> range :: Int64
13:32:52 * hackage extra 1.7.6 - Extra functions I use.  https://hackage.haskell.org/package/extra-1.7.6 (NeilMitchell)
13:33:05 <monochrom> Unless you want to explain why you need "v"
13:33:28 <hyperisco> I think it is measuring the cardinality of any bounded integral type
13:33:56 <hyperisco> in which case I think you need ScopedTypeVariables and probably TypeApplications
13:34:01 <hyperisco> or you can add a proxy argument to range
13:34:04 <dansho> yeah, like range @Int16 would be ~65535
13:34:31 <hyperisco> or is ScopedTypeVariables built in now if you add forall?
13:34:41 <hyperisco> range :: forall v. (Integral v, ...
13:34:43 <monochrom> You have 3 "v"s. You need ScopedTypeVariables and add "forall" to say that they are the same v.
13:35:35 <dansho> yep that works =) ty
13:54:41 <tomsmeding> sm[m]: https://paste.tomsmeding.com/  if you want to host, please do your thing :)
13:54:59 <tomsmeding> there is optional syntax highlighting now (it remembers your preference in localStorage)
13:57:25 <tomsmeding> I'll be there again tomorrow :)
14:19:41 <hololeap> data ItemType = Ready | Executing | Deleted ; data Item (t :: ItemType) a where ; ItemReady :: a -> Item 'Ready a ; ItemExecuting :: a -> Item 'Executing a ; ItemDeleted :: Item 'Deleted a
14:21:10 <hololeap> is it possible to describe at the type level that a function can some combination of Item types? for instance, one function returns either (Item 'Ready a) or (Item 'Executing a), while another can return any of the three
14:21:26 <hololeap> s/can some/can return some
14:21:47 <merijn> hololeap: Only via constraints
14:22:13 <merijn> hololeap: But you can define arbitrarily complex constraints via type families \o/
14:22:16 <merijn> hololeap: https://gist.github.com/merijn/6130082
14:22:34 <merijn> I should update to use the new fancy custom type error stuff
14:22:50 <merijn> Or maybe not...out of protest
14:23:19 <dminuoso> hololeap: Im going out on a limb here, but it this going to be some kind of network protocol?
14:24:17 <hololeap> dminuoso: no, it isn't
14:24:55 <hololeap> merijn: interesting. i've never seen error messages encoded like that before
14:26:09 <merijn> hololeap: It was the only way to get something useful
14:30:08 <dminuoso> Is there a safe version of fromIntegral that guarantees the conversion is not lossy?
14:30:18 <merijn> @hackage int-cast
14:30:18 <lambdabot> https://hackage.haskell.org/package/int-cast
14:30:34 <dminuoso> merijn: Ah that's perfect! Cheers.
14:30:43 <merijn> dminuoso: Also, did you not see the whole mailing list kerfuffle about that being missing? :p
14:30:44 <dminuoso> At least a 5 second skim suggests it is.
14:30:54 <dminuoso> No, I did not.
14:31:54 <monochrom> hrm, nice, maybe I should bookmark it
14:34:20 <dminuoso> Out of everything in base, fromIntegral I find to be one of the biggest thwarts. :<
14:35:14 <dminuoso> I mean despite having a strong type system, integral safety is as safe as C. After all, you're trained to just "add fromIntegral" whenever the type checker complains.
14:35:37 <dminuoso> It doesn't really add visibility to whats happening, half the time I dont even know what types Im converting between.
14:36:38 <dolio> What is "integral safety"?
14:39:02 <merijn> dolio: That you only convert Int64 to Int when Int can represent the entire range of Int64, for example
14:46:12 <Cale> Personally, I take usage of fromIntegral as an opportunity to think about what types I'm converting between and determine if I'm losing information that I actually want to keep.
14:47:20 <merijn> Cale: You can't, though
14:47:26 <Cale> How so?
14:47:36 <merijn> Cale: Because you don't know the size of Int or CInt
14:47:52 <merijn> Cale: So you can't determine once "is this conversion safe?"
14:47:56 <Cale> Well, if those are the types I'm converting between, that might be an issue.
14:48:01 <merijn> It depends on the platform the code is being compiled on
14:48:34 <merijn> And getting it right is hard enough that it can go wrong twice in a row, despite multiple code reviewers scrutinising it :)
14:49:23 <Cale> If CInt is involved, there might not be a great way forward in Haskell alone.
14:49:48 <Cale> (The C library you're interacting with just might not have a higher precision version of whatever it is that you need)
14:50:00 <merijn> That's one of the things that the Habit Language Report did well, imo
14:50:46 <merijn> They put a lot of effort into being able to write code between types with different bit sizes and detect mismatches at compile time
14:52:53 <Cale> We could have an additional type class where the only instances are guaranteed-safe conversions, which might be valuable in sensitive cases. We could even conditionally compile some instances based on the platform.
14:53:05 <dminuoso> Cale: that's pretty much what int-safe provides :)
14:53:38 <dminuoso> In addition to providing you runtime checking for when safety cant statically be determined
14:54:27 <Cale> As a separate class?
14:56:38 <hololeap> here's a tricky one: is it possible to build a fully functional homogeneous Seq in haskell?
14:57:27 <monochrom> As in Data.Sequence.Seq?
14:57:35 <hololeap> monochrom: right
14:57:57 <monochrom> Isn't Data.Sequence.Seq already fully functional and homogenous?
14:58:15 <hololeap> sorry... heterogeneous
14:59:00 <dminuoso> Cale: Well it uses a separate typefamily: intCast :: (Integral a, Integral b, IsIntSubType a b ~ True) => a -> b 
15:01:37 <hololeap> it seems like you would have to build a type-level Seq otherwise you'd be stuck with type level lists, which don't have O(log n) lookups and whatnot
15:03:21 <kirill> How to parse a whole string with "parsers" package? I do "manyTill alphaNum newline" but I need to parse any symbol, not only a letter or a digit
15:03:29 <hololeap> maybe this is something that (only?) dependent types can solve
15:04:23 <monochrom> hololeap: Wait a second! Type-level cons list has terrible time costs at compile time. 
15:04:36 <monochrom> It is not a run-time cost.
15:04:55 <hololeap> oh
15:05:00 <monochrom> Unless you really mean "GHC is already too slow with Haskell 2010", it should not be a concern.
15:05:28 <hololeap> i just want other heterogeneous containers
15:05:56 <monochrom> I do know that Okasaki found a way to cause GHC to take exponential time.
15:06:23 <dolio> It's easy to cause double-exponential time.
15:06:29 <hololeap> but i guess heterogenous lists can't be created at runtime, or can they?
15:06:51 <dolio> f0 x = (x,x) ; f1 = f0.f0 ; f2 = f1.f1; ...
15:07:20 <monochrom> He found a cute way to allow "begin push 5 push 6 push 8 push 3 pop end" by having extremely polymorphic begin, push, pop, end.  That did it.  He pushed GHC over the edge.
15:08:23 <monochrom> That would parallel "vector size known only at run time". You now have an existential type.
15:09:08 <dolio> You can use that same sequence to write down numbers that Nelson believed don't exist using operations he thinks are well-defined, too, I think. :)
15:09:38 <dolio> Or, notate numbers, I suppose.
15:09:57 <monochrom> To a large extent I think creation is easy. How the hell can you consume it, that's the real question.
15:19:00 <MarcelineVQ> huh, is it possible to have a version of https://hackage.haskell.org/package/transformers-0.5.6.2/docs/Control-Monad-Trans-Except.html#t:ExceptT that is both MonadTrans and Bifunctor?
15:25:08 <hyiltiz> https://github.com/tomsmeding/pastebin-haskell is going great, citing sm[m] and all
15:25:38 <hyiltiz> What would you all suggest for multiple file submission (for things like stack cabal etc)
15:25:55 <Cale> hololeap: Note that you can use type level information to keep track of things that you're going to store in an efficient structure of any sort that would normally be homogeneous, just unsafeCoercing safely after having determined that the types are correct.
15:53:20 * hackage generic-functor 0.0.1.0 - Deriving generalized functors with GHC.Generics  https://hackage.haskell.org/package/generic-functor-0.0.1.0 (lyxia)
15:55:49 * hackage generic-functor 0.0.1.1 - Deriving generalized functors with GHC.Generics  https://hackage.haskell.org/package/generic-functor-0.0.1.1 (lyxia)
16:05:11 <hyiltiz> tomsmeding: http://nonssl.tomsmeding.com:8123/paste/04PyHe4A Can't build
16:06:06 <hyiltiz> :hoogle genShortByteString
16:08:34 <hyiltiz> @hoogle genShortByteString
16:08:35 <lambdabot> No results found
16:10:16 <hyiltiz> https://hackage.haskell.org/package/random-1.2.0/docs/System-Random.html#v:genShortByteString says since random 1.2.0 but I had 1.1-12
16:17:10 <hyiltiz> https://github.com/tomsmeding/pastebin-haskell/pull/1
17:00:10 <Guest_30> when i install the ghcup this pops out on my terminal mac OSX "ghcup --cache install" failed!
17:01:13 <maerwald> Guest_30: what pops up?
17:01:50 <maerwald> "failed" is definitely not a ghcup error
17:01:57 <Guest_30> ghcup --cache install" failed!
17:02:00 <Guest_30> ok
17:02:06 <Guest_30> sorry ima n00b
17:02:16 <maerwald> can you run: ghcup --version
17:02:50 <Guest_30> yes, didnt work :(
17:02:54 <glguy> maerwald: Is it expected that I should keep running 'ghcup upgrade' until it eventually reports I've run it enough times to be done?
17:02:55 <Guest_30> this is the error
17:02:56 <Guest_30> "_eghcup --cache install ghc recommended" failed!
17:03:08 <glguy> like just now I ran once to get 0.1.9 and then again got me 0.1.10
17:03:30 <maerwald> glguy: heh, that can happen when the download format file changed (which it did)
17:03:52 <maerwald> so I only maintain the minimum upgrade path for old download files
17:04:15 <maerwald> Guest_30: run: ~/.ghcup/bin/ghcup --version
17:04:37 <Guest_30> thx ill se
17:05:07 <Guest_30> see*
17:11:17 <monochrom> I reckoned that it is no worse than "if you only have GHC 4.8 you have to build several intermediate GHC versions before you can catch up to 8.8" :)
17:13:25 <maerwald> Guest_30: and?
17:13:53 <monochrom> I think the problem solved itself.
17:14:00 <monochrom> "Don't answer to answer. Just don't answer."
17:15:01 <maerwald> I guess the bootstrap script could hard-error on non-supported OSX versions
17:15:03 <monochrom> When people cite "I'm n00b" you know they have decided to hide behind that façade instead of taking initiative to work with you.
17:16:26 <monochrom> A proactive, maturely minded learner would offer you "if there is information you need, let me know".
17:17:34 <maerwald> imagine apple made developing on mac easy.....
17:18:08 <maerwald> e.g. GHC devs could actually test things by hand instead of playing for ours on CI nodes
17:18:41 <maerwald> and anyone else developing cross-platform things too
17:19:42 <Arahael> pfft.
17:19:57 <Arahael> maerwald: imagine if they made interface builder and xcode good. ;)
17:21:06 <maerwald> xcode was fun... the syntax highlighter is its own process and it kept crashing every few seconds, so I got an epilepsy unfriendly editor experience
17:21:22 <maerwald> quite stimulating though
17:21:49 <monochrom> Matrix glitches
17:22:49 <maerwald> when your company invests more money in lawsuits and marketing than engineering...
17:24:21 <monochrom> Not sure about lawsuit, but tech people don't know how to bargain for a high price, marketers do, I think probably that's the only reason why.
17:25:02 <monochrom> I think we heard that Apple has good engineers but they're underpaid and overworked and not leaving.
17:27:00 <monochrom> Google is the only employer that comes close to "don't let your imposter syndrome stop you, you really are worth more"
17:31:28 <monochrom> Hell, I know of the term "imposter syndrome" only because Google talked about it.
17:32:19 <maerwald> if you don't have imposter syndrome in programming... then you have the wrong job
17:32:31 <monochrom> heh
17:33:31 <monochrom> But consider the implication. This means all tech employers before --- Microsoft, Yahoo, others --- they had been exploiting it.
17:35:14 <maerwald> Yeah, in germany employers discriminate programmers based on lack of academic background... no matter your actual skills
17:35:17 <monochrom> Maybe not consciously, but they certainly got a cheap bargain on your salary and working conditions and minion status if you had that much self-doubt.
17:36:14 <maerwald> (and I don't mean for academic jobs or developing the next blockchain protocol... but usual jobs)
17:38:45 <maerwald> then again... if you are self-employed, no one cares about your background anymore, just your skills... how come :)
17:38:52 <maerwald> bargaining position, nothing else
17:38:57 <monochrom> I guess everyone is looking for quick proxies.
17:39:39 <monochrom> My understanding of North America is they discriminate you based on lack of self-boasting BSing skills.
17:40:18 <maerwald> they hire confidence, not skill :p
17:40:29 <monochrom> Compared to that, I would rather take the academic hierarchy. :)
17:41:10 <monochrom> But of course this is out of self-interest. I got pretty high in the academic hierarchy, of course I prefer it.
17:42:07 <monochrom> confidence yes, but also packaging, presentation
17:42:40 <monochrom> See? This ties in to why Apple spends more on marketing!
17:43:06 <monochrom> Because it's the whole continent, this is our culture, it is not just Apple.
17:43:39 <maerwald> We are bad at it, which is why we focused on engineering :p
17:44:13 <monochrom> Our programmers have to learn from our marketers how to make résumés and CVs. That tells you what's going on.
17:44:44 <monochrom> Hell this immediately tells you the subordination relation.
17:47:05 <maerwald> Like... becoming your own headhunter?
17:48:31 <maerwald> Sorry, this thought is too much.
18:24:25 <redmp> @let class X x where type T x; make :: T x
18:24:26 <lambdabot>  .L.hs:173:9: error:
18:24:26 <lambdabot>      • Couldn't match expected type ‘T x’ with actual type ‘T x0’
18:24:26 <lambdabot>        NB: ‘T’ is a non-injective type family
18:25:19 * hackage servant-static-th 0.2.4.0 - Embed a directory of static files in your Servant server  https://hackage.haskell.org/package/servant-static-th-0.2.4.0 (cdepillabout)
18:25:37 <redmp> can somebody help me to understand this error? why is the use of `T x`  in the signature of `make` assigned a distinct `x` from the class head?
18:27:12 <redmp> is it saying "instance resolution won't be able to pick a class because your signature doesn't contain `x`"?
18:27:21 <redmp> *pick an instance
18:27:25 <c_wraith> well that certainly is a problem.
18:27:50 <c_wraith> As it points out, it's a non-injective type family
18:28:05 <redmp> sure, but i'm new to the terms and trying to confirm whether my understanding is correct
18:28:15 <c_wraith> yes, that's the problem.
18:29:41 <c_wraith> Though there's also the fact that there's no reason to assume x is the same type in different contexts.
18:30:30 <redmp> you mean in the context of the instance head and the type of `make` the `x` could be different?
18:31:59 <c_wraith> Hmm, that is the one case where they should be the same.  I wonder why the compiler didn't unify the type variables.  I guess because the lack of injectivity is enough to make it impossible to use anyway.
18:32:51 <redmp> @let class X x y | y -> x where make :: y
18:32:52 <lambdabot>  Defined.
18:33:33 <monochrom> Suppose I have two instances, type T Int = (), type T Bool = () too.
18:33:34 <c_wraith> Yes.  fundeps are injective.
18:33:52 <monochrom> I now say "make :: ()", so is x Int? is x Bool?
18:34:04 <redmp> yes, that makes sense.. 
18:35:03 <redmp> is there a way to represent this without fundeps? maybe -XAllowAmbiguousTypes and -XTypeApplication and then specify the instance type in the callsite?
18:35:16 <redmp> but that feels really messy
18:35:18 <c_wraith> the more I use fancy features, the less comfortable I am with type families.  They break too many things.
18:35:52 <monochrom> It looks to me "make :: Proxy x -> T x" is better.
18:35:54 <redmp> i've found type families to be the least easy part of haskell to learn thoroughly
18:36:01 <monochrom> Or complete redesign.
18:36:35 <redmp> monochrom: yes, proxy seems more conventional than ambiguous+typeapps
18:37:08 <monochrom> typeapp also works
18:37:16 <monochrom> I just keep forgetting that it exists.
18:37:53 <redmp> what's the "conventional" way to do things? i understand these features are kind of at the edge and there has been some back and forth between fundeps and typefamilies in the community
18:38:09 <redmp> is that drawing to a conclusion or still up for debate?
18:38:31 <redmp> or just "different tools in the toolbox"
18:40:27 <c_wraith> there's also  make :: Tagged x (T x)
18:40:47 <redmp> oh, that's new to me.. i'll look that up
18:40:49 <c_wraith> which has the advantage of being a phantom type tag that doesn't invent an argument
18:41:56 <dolio> The example is too contrived to give advice on what would be better.
18:42:47 <monochrom> Yes, but it's good to know all 3 choices. Then you decide which one fits best to your particular scenerio.
18:42:49 <redmp> dolio: sorry, i simplified it to paste into irc.. it's a store and an element wrapper specific to the store.. the store must be polymorphic over elements; but sometimes a store needs a specific wrapper
18:43:58 <redmp> in my original code it was `make :: element -> Wrapper store` which is ill concieved anyway since `element` doesn't appear on the right.. maybe `(Wrapper store) element` is a more correct type
18:45:51 <redmp> @let class Store s where type Wrapper s :: * -> *; wrap :: s -> e -> (Wrapper s) e
18:45:53 <lambdabot>  Defined.
18:46:04 <redmp> and my goal was to eliminate the first argument of `wrap` 
18:46:19 <redmp> proxy feels ugly, but it's the most common pattern i've seen
18:46:25 <redmp> Tagged seems nice
18:46:55 <redmp> fundeps are new to me and i'm wary of introducing types to the instance head and then not understanding the restrictions i'm stating in fundeps
18:50:15 <dolio> The fundep was working because the dependency was going the opposite way from the original example.
18:50:31 <dolio> T x determines x instead of x determines T x.
18:50:58 <redmp> dolio: yes, and i don't like that because I probably want x to determine `T x` .. and i want to reuse the wrappers in different places
18:51:05 <redmp> it seems this would rule out fundeps for my use case
18:57:48 <redmp> i guess i should look to what is Haskell98 for what is "conventional"
19:00:09 <dolio> Well, I don't think there's anything wrong with type families themselves. But a lot of what people try to do with them seems not worth it.
19:01:06 <dolio> In Haskell 98 there was Oleg to do similar stuff, and 95% of his type hacks were also not worth using in practice.
19:01:20 <dolio> Maybe 100% of the type hacks.
19:01:49 <redmp> as somebody who's learned haskell mainly through blog posts and trying to write my own stuff, learning what the advanced features are actually for has been very difficult .. i typically try to use type families because they look familiar, but they're not the same as a plain type alias
19:02:07 <redmp> ie. it's not clear that it's a type 'hack' to a beginner
19:05:11 <redmp> like, i think i go for type families because they mean i don't need the extra type in the class head .. which is important when writing functions where you have to state the class as a constraint.. 
19:05:23 <dolio> Well, I recently used type families because I was writing an interpreter that used two stacks. One has unboxed stuff on it, and the other has boxed stuff on it. And they have the same API. So there are some families indexed by a data kind for boxed vs. unboxed.
19:05:32 <redmp> (in this case, i mean, stating the store type is important, but stating the wrapper is just boilerplate)
19:05:39 <dolio> But that is very simple relative to what some people try to do with type families.
19:07:44 <redmp> in any case, i think i've understood the options now.. thank you dolio  monochrom  c_wraith 
19:08:28 <dolio> I think even with your fleshed out example it's still too close to 'solution in search of a problem' to give any particular advice.
19:08:50 <dolio> Which is fine for fooling around and learning stuff.
21:07:19 <hyiltiz1> hello this is me from weechat
21:07:40 <hyiltiz> wow I got it working
22:48:55 <hyiltiz> How du make g f x0 (B l r) = g f (g f x0 l) r where data T a=L a|B (T a) (T a) tail recursive or otherwise optimize without using CPS?
22:55:53 <c_wraith> the call tree isn't linear
22:59:40 <c_wraith> about the only thing I can see doing anything, and only if the data type makes it meaningful (what's the type of g, anyway?) is *maybe* throwing a bang pattern on x0
23:00:30 <c_wraith> but that'll only help if x0/the return type of g is properly strict
23:07:42 <ericmoritz> where can I find all the options for mkShell?
23:08:47 <tomsmeding> hyiltiz: I was already thinking I really needed some version bounds, and so indeed :p
23:09:09 <ericmoritz> sorry ignore that message
23:11:30 <tomsmeding> hyiltiz: also, if we're using my instance now anyway, please use the https version :) https://paste.tomsmeding.com/paste/04PyHe4A
23:12:10 <hyiltiz> g is fold
23:12:25 <hyiltiz> c_wraith: g is gold
23:16:11 <hyiltiz> @where+ paste3 tomsmeding's proof that programming > discussing: https://paste.tomsmeding.com/
23:16:11 <lambdabot> Done.
23:16:17 <hyiltiz> @where keys
23:16:17 <lambdabot> Please see: @where ?
23:16:20 <hyiltiz> @where key
23:16:20 <lambdabot> I know nothing about key.
23:16:32 <hyiltiz> @where ?
23:16:32 <lambdabot> Some useful @where queries: ? paste cabalstackhelp
23:16:48 <hyiltiz> @where keys.bak
23:16:48 <lambdabot> Some useful @where queries: keys paste cabalstackhelp
23:17:09 <hyiltiz> Glad I had a backup :D
