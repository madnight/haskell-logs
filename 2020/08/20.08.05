00:00:19 <tomjaguarpaw> hyiltiz: Have a look at http://h2.jaguarpaw.co.uk/posts/how-i-use-dante/
00:26:57 <bahamas> what would be the right term for "Hello, world"? do you declare the string? "defining" doesn't sound right to me
00:27:42 <bahamas> the same with any other primitive: Int, List, etc.
00:28:13 <xerox_> that's a string literal expression, you could peruse the haskell report if you want to see what kind of naming they give to these things
00:35:14 <bahamas> xerox_: declaration it is. "Declarations define things such as ordinary values, datatypes, type classes, andfixity information."
00:35:25 <xerox_> \o/
01:04:13 <ski> bahamas : it's not a declaration
01:06:01 <tomsmeding> isn't it just a "literal", which I guess you can "use"?
01:06:49 * hackage tasty-bdd 0.1.0.0 - BDD tests language and tasty provider  https://hackage.haskell.org/package/tasty-bdd-0.1.0.0 (PaoloVeronelli)
01:08:33 <ski> (also not all declarations define things)
01:21:24 <fog> noramlly in haskell we have single input, single output (SISO) functions, which compose together to emulate multiple input single output (MISO) functions. i want instead to work with composing single input multiple output (SIMO) functions to give multiple input multiple output (MIMO) functions
01:22:20 <fog> :: HList inputs -> HList outputs
01:22:22 <tomsmeding> how do you define multiple outputs?
01:22:42 <fog> basically just a tuple, like currying gives multiple inputs as a tuple
01:22:55 <tomsmeding> so tuples are not enough?
01:23:16 <fog> well, I can cons to a HList
01:24:03 <fog> i guess i could even have a Symbol-Map to name the outputs as variable names
01:24:22 <tomsmeding> do you have a concrete use case for such a construction? :)
01:24:31 <fog> depending on how they are supposed to be lookuped over
01:24:57 <fog> yes, i have a graph with several upper nodes having edges to the same lower node
01:25:27 <fog> where this is supposed to represent a dataflow going upwards through the graph
01:25:37 <tomsmeding> edges indicate dependencies?
01:25:49 <fog> edges would be labled with variable names
01:25:51 <tomsmeding> and nodes are stratified in generations, where a node can only depend on nodes from the previous generation?
01:26:42 <fog> um, no, they are basically just like a Tree GADT, where the constructor can take any existing variables
01:27:00 <tomsmeding> oh okay
01:27:10 <tomsmeding> so a DAG?
01:27:24 <fog> there is a "Let" constraint however that a name has a fundep to its assigned value
01:27:48 <fog> its not acyclic by any mechanism
01:28:05 <tomsmeding> > with several upper nodes having edges to the same lower node
01:28:08 <lambdabot>  error:
01:28:08 <lambdabot>      Variable not in scope:
01:28:08 <lambdabot>        with
01:28:11 <fog> there is nothing to stop cyclic referencing
01:28:12 <tomsmeding> that suggests to me that it's acyclic
01:28:15 <tomsmeding> sorry lambdabot
01:28:52 <fog> well, you could have one such variable having a reference to itself somewhere underneath
01:29:47 <fog> so i guess its just a directed graph
01:30:02 <fog> maybe a lattice?
01:30:24 <tomsmeding> well a lattice is a DAG ;)
01:30:46 <fog> whats to stop a lattice being self referential?
01:31:26 <fog> i guess its kind of "unrolling" a recursion into a potentially infinite lattice
01:31:54 <fog> so i suppose it *is* a DAG, but that can represent a cyclic graph after its unrolled
01:32:06 <tomsmeding> okay sure
01:32:12 <tomsmeding> so you have a generic graph
01:32:20 <tomsmeding> that presumably represents a computation
01:32:29 <fog> is that a technical term? "generic" graph?
01:32:30 <tomsmeding> with the talk about "variables" ;)
01:32:32 <tomsmeding> neh
01:32:50 <tomsmeding> it's just a "graph", but I wanted to emphasise that there's no qualifiers
01:32:51 <fog> yeah, its supposed to be a function implementation
01:32:52 <dminuoso> Why cant I have duplicate type signatures? At first glance that seems like an unnecessary restriction.
01:33:06 <tomsmeding> though I guess it's still a simple graph (no double edges)
01:33:08 <dminuoso> That is, I see no reason why `f :: Int; f :: Int; f = 1` should be invalid.
01:33:37 <fog> dminouso, because it would only ever typecheck if they were the same
01:33:40 <fog> ?
01:33:41 <dminuoso> (Whether its actually useful is another discussion, but hey we can have empty classes for no reason other than consistency)
01:33:52 <random> hey guys
01:34:06 <random> I have multiple `Parser a`s from Aeson
01:34:15 <random> how do I sequence these in a way so that
01:34:21 <random> if the first Parser succeeds, take its result
01:34:24 <random> if it fails, try the second
01:34:24 <dminuoso> asum
01:34:27 <random> and so on
01:34:31 <dminuoso> random: ^-
01:34:35 <random> dminuoso: thanks!
01:34:43 <dminuoso> random: Or, use <|> directly
01:34:45 <dminuoso> They are equivalent
01:34:49 <fog> dminuouso: we only have duplicate function heads to pattern match on differnt cases, i guess we dont pattern match types...
01:34:52 <tomsmeding> dminuoso: I guess you'd have to define how "equal" the signatures need to be; literally? up to alpha-equivalence? up to type aliases?
01:35:07 <ski> dminuoso : seems that it could reasonably be allowed
01:35:49 <fog> wouldnt it *replace* classes?
01:36:16 <fog> as matched type specifications
01:36:49 <tomsmeding> I don't see how the ability to declare a top-level definition twice has anything to do with type classes? :p
01:36:55 <random> dminuoso: worked like a charm
01:36:58 <fog> over the variable the class is defined over, as the yet to be specialised type variable
01:38:03 <fog> tomsmeding: because if your "matching on types" like we do with pattern matching on different Sum GADT constructors
01:38:49 <dminuoso> tomsmeding: The equality consideration makes sense in a subtle way. Alpha equivalence couldn't be sensible in the presence of things like ScopedTypeVariables.
01:38:52 <tomsmeding> sure if you go all the way and allow specialisation of functions via what basically amounts to OOP-style overloading
01:39:09 <tomsmeding> but I thought Haskell went with type classes as a conscious decision :p
01:39:19 <dminuoso> (Its either that, or disallow multiple type declarations in the presence of ScopedTypeVariables + forall)
01:39:43 <tomsmeding> dminuoso: true, so they'd have to be equal up to and including names of type variables
01:39:52 <dminuoso> because, what would: `f :: forall s t. T t s...; f :: forall t s. T s t; f = ... @s ...` even mean
01:39:59 <dminuoso> Right
01:40:08 <tomsmeding> That sort of thing is very useful in languages like C where you have headers, but I don't really see the use in Haskell
01:40:20 <MarcelineVQ> dminuoso: that'd be more useful if you could seperate f :: Int and f = 1 in haskell but they need to be defined together iirc. more useful in that you could show the types of things in your module early on and then again later where they're defined
01:40:26 <dminuoso> Oh I have no immediate use, it just stroke me as odd at first glance
01:40:28 <ski> tomsmeding : probably would need to quantify corresponding variables in the same order
01:40:43 <fog> you could put the foralls in a standalone clause
01:40:48 <tomsmeding> MarcelineVQ: I just tested that, ghc seems to allow 'f :: Int ; a :: Int ; f = 1; a = 1' just fine
01:40:48 <dminuoso> But perhaps, the ScopedTypeVariables bit is actually rather a weird hack in that we cant (yet) bind type variabes.
01:40:51 <dminuoso> That is, if we could do:
01:40:59 <ski> (oh, and `ScopedTypeVariables's treatment of `forall' is backwards !)
01:41:00 <dminuoso> f :: forall s. ...; f (@s) = ...
01:41:03 <MarcelineVQ> tomsmeding: oh it does then? alrighty then
01:41:08 <dminuoso> That would be much more preferrable
01:41:16 <fog> i guess the forall clause would be like how the variables appear in the class head
01:41:28 <dminuoso> (As opposed to this "magical link" between the type signature quantifier and a type variable in the term level)
01:41:46 <tomsmeding> dminuoso: agreed, that would be nice
01:41:52 <MarcelineVQ> yeah I guess that makes sense otherwise   f,g,h :: Int; f = 3; g = ...  wouldn't make sense
01:42:01 <tomsmeding> I believe you move slightly towards agda then
01:42:11 <ski> tomsmeding : yes, signatures doesn't need to be together with corresponding defining equations
01:42:15 <dminuoso> tomsmeding: that change is actually coming, soon, I think.
01:42:22 <dminuoso> There's an extension on the horizon to do just that IIRC
01:42:22 <fog> notice how the variables defined in the class head are in scope to the functions of the class, as if ScopedTypeVariables was on 
01:42:29 <ski> which change, dminuoso ?
01:42:43 <dminuoso> ski: binding type variables at the term level
01:42:47 <ski> ah, yes
01:43:20 <ski> it's sortof bad that `TypeApplications' uses the same syntactic token as "as"-patterns
01:43:44 <ski> (i remember thinking this, when they were first introduced ..)
01:43:46 <tomsmeding> it's unambiguous, right?
01:44:03 <tomsmeding> can't use type applications in a pattern
01:44:03 <dminuoso> tomsmeding: Well, it'd be ambiguous if you wanted to support term level binding using the same syntax like Ive shown above
01:44:21 <ski> tomsmeding : dminuoso just suggested being able to
01:44:21 <dminuoso> Or not necessarily in that case, but you get into weird edge cases perhaps
01:44:48 <tomsmeding> oh right
01:44:57 <dminuoso> ski: Do you know what the extension is going to be called?
01:45:04 <ski> i'd prefer not having constructs which look the same (or overlap) in patterns vs. expressions, but which don't have corresponding meanings
01:45:04 <dminuoso> I cant recall it from the top off my head, not sure what to look for
01:45:08 <ski> dunno, dminuoso
01:45:12 <fog> PatternApplications ?
01:46:04 <fog> but, wouldnt that replace classes?
01:46:43 <ski> (i also don't like using `_' for holes, in expressions)
01:47:25 <tomsmeding> the whole point of classes is that I can give a different definition for 'f' for type A than for type B, right?
01:47:35 <fog> isnt it better to have the class keyword to specify functions to require an instance for a certain type, to help the typechecker and user?
01:47:35 <dminuoso> ski: Heh, I recently was annoyed by the behavior of _ in combination with how lens by default generates lenses. My annoyance was, if you had a field starting with _ and you made a typo, that you wouldn't get "did you mean" suggestions because it's recognized as a hole instead.
01:48:00 <dminuoso> I should add a flag to GHC to disable this behavior, to consider identifiers starting with _ as just identifiers.
01:48:07 <fog> like, to end up with Constraints
01:48:37 <fog> which would be like, that a pattern application exists
01:49:22 <ski> tomsmeding : ad-hoc overloading, made less ad-hoc, yes
01:49:35 <tomsmeding> interesting
01:49:54 <tomsmeding> let's accrue all the paradigms :p
01:50:07 <fog> i guess with pattern applications it would push that to be a runtime error?
01:51:03 * ski . o O ( "How to make ad-hoc polymorphism less ad hoc" by Philip Wadler,Stephen Blott in 1989-01 at <http://homepages.inf.ed.ac.uk/wadler/topics/type-classes.html#class> )
01:51:19 <ski> also see
01:52:20 <ski> @where on-understanding
01:52:20 <lambdabot> "On Understanding Types, Data Abstraction, and Polymorphism" by Luca Cardelli,Peter Wegner in 1985-12 at <http://lucacardelli.name/Papers/OnUnderstanding.A4.pdf>
01:53:19 <fog> i guess the type checker could range through the function heads to see which pattern applications were mentioned, like how it checks which instances are written
01:53:40 <tomsmeding> fog: if your computation graph was really a DAG (so no looping/recursion), you could first transform it to a sequence of let bindings where each binding contains only a single computation node in its RHS. Then using typed de bruijn indices would give you something like you ask for, I think
01:53:44 <ski> oh, you mean with an extra space, dminuoso ?
01:53:51 <fog> but then also, there is no place to write superclass constraints
01:54:11 <fog> erm, unless this goes at the type signature
01:54:30 <ski> tomsmeding : ANF, you mean ?
01:54:35 <fog> but then, instances can have different constraints...
01:54:40 <tomsmeding> ski: basically :p
01:54:52 <tomsmeding> yes fog look at ANF I suppose
01:55:05 <tomsmeding> maybe that's what you were looking for
01:55:12 <fog> de bruijn!?
01:55:21 <tomsmeding> hey I'm dutch
01:55:39 <fog> i was thinking it might need a lookup argument over the HList of outputs
01:56:28 <fog> and there was something like, requiering the variable that *was going to* refer to each output position, to be specified in the GADT
01:57:07 <ski> is "Bruĳn" pronounced with a diphtong ?
01:57:09 <dminuoso> ski: Extra space?
01:57:14 <fog> so that the use-site is specified at the position (in code) of the function application, not the other way round
01:57:16 <ski> dminuoso : after the `_' ?
01:57:30 <tomsmeding> fog: for de bruijn indices in this kind of context, see also https://dblp.org/rec/conf/haskell/AtkeyLY09.html
01:57:37 <ski> dminuoso : i assumed you meant you accidentally wrote `_ foo', rather than `_foo' ?
01:57:47 <dminuoso> ski: No, rather _fop instead of _foo
01:58:08 <tomsmeding> ski: if you know dutch pronunciation: the 'j' is silent, and Bruijn is pronounced exactly like the usual dutch word 'bruin'
01:58:12 <ski> oh
01:58:16 <fog> i find that here; http://homepages.inf.ed.ac.uk/slindley/papers/unembedding.pdf
01:58:23 <dminuoso> If you have some `data Foo = Foo { _foo :: S, _bar :: T }`, so you can generate lenses with $(makeLenses ''Foo)
01:58:52 <dminuoso> Then, when using these fields directly, a typo will not generate a "did you mean" suggestion.
01:59:22 <ski> hm, so not the same sound as in "Ĳsselmeer" ?
01:59:29 <tomsmeding> ski: nope
01:59:30 <dminuoso> Ultimately, I found the solution to this is to not use underscored field names, but instead using HasLabel-based lenses.
01:59:40 <fog> bascally then, it would throw a type error if the lookup index, and the name of the variable - did not match that specified at the binding of the outputs HList
01:59:45 <ski> ok, ty
01:59:55 <dminuoso> But you get into equivalent problems on the lens side then, where #fob wont generate a useful did-you-mean error)
01:59:55 <random> guys is it possible to do something similar to `deriving newtype (FromJSON)` when you have `data A = A1 B | A2 B1` where B and B1 have a FromJSON instance?
01:59:57 <tomsmeding> ski: actually no idea what the etymology is of that uij thing; in any case, if you have uij, the j is silent
02:00:14 <ski> i see
02:00:20 <MarcelineVQ> "de bruijn!?"  "hey I'm dutch" "oh sorry, der bruijn?"
02:00:23 <dminuoso> random: If your newtype ha Generic, then you can.
02:00:28 <ski> mm, i see, dminuoso
02:00:37 <random> dminuoso: it's not a newtype but data
02:00:43 <dminuoso> random: same thing
02:00:47 <random> dminuoso: I can add Generic though
02:01:06 <random> dminuoso: aaah yeah actually this is how it is now but Aeson is adding these "tag" fields
02:01:10 <tomsmeding> MarcelineVQ: unsure of any dutch name with 'der' though :p
02:01:23 <fog> so as the GADT is constructed, it says "the variable using the nth of the outputs is called x", and at x, it checks that it looksup the nth of the outputs
02:01:27 <dminuoso> random: You can either control the generic options, or better yet, just write the FromJSON instance out yourself.
02:01:40 <random> dminuoso: yeah custom FromJSON instance it is, thanks!
02:01:49 <tomsmeding> fog: "nth of the outputs" sounds suspiciously like de bruijn indices ;)
02:02:05 <fog> so that x and y are *forced* to refer to different values in the output HList 
02:02:39 <dminuoso> ski: Or maybe, I could fix the root of the problem and perhaps add a bit of engineering so GHC will produce "did you mean" suggestions when a typed hole is discovered.
02:02:46 <fog> yeah, i was thinking symbols could be used instead, but then maybe you want to defer the binding of the name `x' to the use site
02:03:06 <dminuoso> For identifiers that are not just underscore, but underscore-then-some-characters, that could be desirable behavior.
02:03:13 <fog> like, i want unique edges to each of the upper nodes leading upwards from each node
02:03:31 <fog> several upper nodes should not converge at the same position in the tuple
02:03:38 <fog> edges from*
02:04:17 <fog> the really difficult thing is accounting for unreferenced tuple values 
02:05:18 <fog> that these should be gathered up over the whole tree and be essentially more outputs of the total HList for the whole tree
02:06:06 <fog> then it seems like every node should refer to the top node, but i kind of forget how that was supposed to work...
02:10:32 <fog> hmm, that might be a red herring. i guess if every output has the name of its use site, then any leftover edges *have* to be gathered up by the user into one of the nodes, to potentially be re-emitted.. possibly there is a Sum clause for the top of the tree so it doesnt have to specify a use site name
02:11:07 <fog> but then that might end up being used at lower parts of the tree to cheat having to specify use sites
02:11:39 <fog> which i guess could be used as a way to get multiple (or zero) edges into the same output
02:13:36 <fog> and yeah, this "de bruijn" indices thing seems way more like the DSL syntax tree approach, im sure this multiple output edges thing is different somehow 
02:14:09 <fog> i dont have GADTs like Lam and Term
02:15:46 <tomsmeding> sure, but you can have an environment-like thing containing all your nodes
02:15:48 <fog> just, at each node, a single input multiple output (SIMO) function, and the hetrogenous outputs, ie the result at some lower node, and a lookup index
02:15:54 <tomsmeding> where you can index into with typed indices
02:16:17 <tomsmeding> maybe it doesn't deserve the term "de bruijn indices", but it's the samea idea
02:16:51 <fog> i dont though, they are just assumed to be in scope sort of. ie its up to the user to actually be able to construct such a thing
02:17:10 <fog> its just a lookup over the outputs...
02:17:42 <fog> i cant actually find where they are referred to in the paper
02:18:28 <fog> oh, i was ctrl-f debruijn
02:18:31 <fog> nvm
02:18:43 <tomsmeding> 'bruijn' ;)
02:19:39 <fog> A popular choice for representing languages with binding is
02:19:40 <fog> de Bruijn indices, where each bound variable is represented as
02:19:41 <fog> a pointer to the binder that binds it
02:21:13 <fog> im not sure, but it seems like thats more like replacing variable names with Ints
02:22:01 <fog> actually, i could do away with a lookup over the HList at all if i used a Symbol-Map
02:22:25 <fog> then the variable name at the use site could be used directly as an accessor 
02:22:48 <fog> it would just have to typecheck so that it uses the type which is stored at that named position in the outputs
02:23:14 <fog> it being a SIMO function, that has one input type
02:24:20 <fog> argh, it should be a MIMO function. i need to think about this more, sorry. ill return 
02:28:39 <tomsmeding> @tell fog I guess I was referring more to this usage of de bruijn indices: https://github.com/AccelerateHS/accelerate/blob/eeb3765535f039909fda3e859d200a6560ff3433/src/Data/Array/Accelerate/AST/Idx.hs#L21-L26
02:28:39 <lambdabot> Consider it noted.
02:59:31 <Orbstheorem> Hi o/ I'm trying to build an extensible configuration type: I would like to construct a type that embbeds different component configurations, only known when the type is finally instanciated. (e.g. ExtConfig '[C1,C2,C3].) The order of the type does not matter, but I would like to be able to prove that given `class HasConfig a b where getConfig :: a -> b`, then `instance HasConfig (ExtConfig '[C1, ...]) C1`.
03:21:48 * hackage tasty-bdd 0.1.0.1 - BDD tests language and tasty provider  https://hackage.haskell.org/package/tasty-bdd-0.1.0.1 (PaoloVeronelli)
03:31:26 <[exa]> Orbstheorem: the C1 C2 are different "configuration values" that need to be filled in, right?
03:33:29 <[exa]> Orbstheorem: btw similar kind of tagging is pretty common, I believe even some extensible effects use this kind of "capability lists"
03:36:41 <[exa]> Orbstheorem: very roughly like this https://hackage.haskell.org/package/extensible-effects-5.0.0.1/docs/Data-OpenUnion.html#t:Member
03:38:30 <bradparker> Orbstheorem: servant uses something like that for specifying the content types a handler ... should handle. In the second half of this post I dig through some of the type classes they use https://bradparker.com/content/posts/2019-10-05-servant-types.html
03:39:13 <Orbstheorem> [exa]: C1 C2 C3 are different data types.
03:39:48 <Orbstheorem> bradparker: Thank you, my gut told me to smell servant x)
05:09:13 <bahamas> ski: I've decided to just use "definition". it still sounds weird, but even the sentence I pasted uses the word
05:10:40 <bahamas> does ghc expose functions that allow you to manipulate the Haskell AST? if so, where?
05:14:26 <merijn> bahamas: In the GHC library, presumably? :p
05:15:32 <ski> bahamas : what's wrong with the suggestion tomsmeding gave ?
05:16:32 <ski> or xerox_
05:19:01 <dminuoso> merijn: by GHC library, do you mean the cabal package `ghc`?
05:19:44 <merijn> yes
05:20:19 <ezzieyguywuf> How might I go about using `getVal` here in the `ExceptT` monad? https://dpaste.com/DQE2JWXEA
05:20:47 <merijn> :t lift
05:20:49 <lambdabot> (MonadTrans t, Monad m) => m a -> t m a
05:20:53 <ezzieyguywuf> dminuoso: this is an extension of our conversation from yesterday. I was able to get a working example with just Except, but I'm trying to increase the complexity in an attempt to work towards my real use-case
05:21:27 <ezzieyguywuf> merijn: so getVal returns a `State (Maybe String)`, but `note` requires just a `Maybe String`
05:21:36 <ezzieyguywuf> this is where I'm getting stuck
05:21:48 <ezzieyguywuf> especially because `useVal` returns a `State` itself
05:23:56 <frdg``> if I have a case statement item that can never be evaluated should I still account for it? For example say I have a Maybe that can only ever be Just 6, Just 7, or Nothing. When I pattern match in a case statement should I include Just x?
05:24:08 <merijn> ezzieyguywuf: lift turns the 'MyState (Maybe String)' from getVal into 'MyError (Maybe String)' and then you can just use do notation to combine it with note
05:24:39 <merijn> frdg``: Yes, because some day, someone will change something so that it *can* be something else
05:25:00 <merijn> frdg``: Alternatively, replace "6" and "7" with your own ADT
05:25:07 <merijn> (which is honestly better)
05:25:15 <ezzieyguywuf> merijn: I see. thonks, I will work on incorporating and understanding thing.
05:25:18 <ezzieyguywuf> s/thing/this
05:26:03 <frdg``> merijn: ok I'll include something. Would it be a partial function if I did not?
05:26:40 <ski> @type mapMaybeT . fmap
05:26:42 <lambdabot> Functor n => (Maybe a -> Maybe b) -> MaybeT n a -> MaybeT n b
05:27:38 <ski> if you had `note :: String -> Maybe a -> MyError a', you could use `hoist (note "blah") (...)'
05:27:51 <ski> hm
05:28:15 <ski> actually no, since `note' gives `MyError', not `Maybe'
05:29:16 <ski> it's a bit hard to see what you're trying to aim for here, ezzieyguywuf
05:31:08 <ezzieyguywuf> ski: I'm trying to update this code so that I can return an error string "Could not find v1" or "could not find v2" as appropriate. https://gitlab.com/ezzieyguywuf/mycad/-/blob/master/MyCAD/app/TUI/CommandRunner.hs#L59
05:31:12 <ski> 41
05:32:14 <ezzieyguywuf> ski: vertexFromID returns a `State (Maybe Int)` https://gitlab.com/ezzieyguywuf/mycad/-/blob/master/Topology/src/Topology.hs#L212
05:32:17 <ezzieyguywuf> ski: 41?
05:32:19 <ski> ezzieyguywuf> :i EntityState
05:33:59 <ezzieyguywuf> ski: https://gitlab.com/ezzieyguywuf/mycad/-/blob/master/Entity/src/Entity.hs#L90, but the gist is `type EntityState p = State (Entity p)`
05:36:03 <bahamas> ski: I didn't see their suggestions, because I disconnected. what were they?
05:36:32 <ski> `Topology' doesn't seem to match with `Entity p'
05:36:53 <ezzieyguywuf> ski: you mean you don't think it belongs as part of that data type?
05:37:02 <ski> <bahamas> what would be the right term for "Hello, world"? do you declare the string? "defining" doesn't sound right to me  <bahamas> the same with any other primitive: Int, List, etc.  <xerox_> that's a string literal expression, you could peruse the haskell report if you want to see what kind of naming they give to these things
05:37:15 <ski> <bahamas> xerox_: declaration it is. "Declarations define things such as ordinary values, datatypes, type classes, andfixity information."  <xerox_> \o/
05:37:31 <ski> <ski> bahamas : it's not a declaration  <tomsmeding> isn't it just a "literal", which I guess you can "use"?  <ski> (also not all declarations define things)
05:39:31 <ski> ezzieyguywuf : `vertexFromID :: Int -> TopoState (Maybe Vertex)', so `MaybeT $ vertexFromID n1 :: MaybeT TopoState Vertex', so that `do' is using `MaybeT TopoState'. then you use `runMaybeT' on it, getting back to `TopoState (Maybe Something)' (`Something' in fact being `String')
05:39:35 <bahamas> ski: well, I'm looking for a verb (I realize I didn't make that clear previously)
05:40:28 <ski> ezzieyguywuf : but the declared result type of `runAdd' is `EntityState p (Maybe String)'. now `TopoState' is `State Topology', while EntityState p' is `State (Entity p)', and `Topology' and `Entity p' are different types that doesn't match
05:40:48 <bahamas> merijn: can you point me where exactly? if this is the ghc library, it's not exactly obvious where I find what I'm looking for https://hackage.haskell.org/package/ghc
05:40:53 <ski> bahamas : "express" ? "denote" ?
05:41:21 <bahamas> the GHC module seems to be it
05:42:07 <bahamas> ski: for context, I'm working on creating a quick Haskell reference. the format of the prompts is like "Import a module", "Define a sum type", etc.
05:42:16 <ezzieyguywuf> ski: *facepalm*, I knew I was asking for trouble when I gave this the same name, https://gitlab.com/ezzieyguywuf/mycad/-/blob/master/Entity/src/Entity.hs#L189
05:42:23 <dminuoso> ezzieyguywuf: By the way, depending on what your goal is, you might also be interested in throwing IO exceptions. :)
05:42:41 <bahamas> ski: I think "Define a list with range" or "Define a string" is good enough
05:42:54 <dminuoso> Im not saying you should do this right away, but perhaps add it to your list of considerations. Perhaps for the next project. Or maybe some refactoring down the road as an experiment.
05:42:55 <ski> (i would not say "define" if there wasn't some name which was associated with something, by a definition. the phrase you had was not a definition, but an expression)
05:43:11 <ezzieyguywuf> dminuoso: my overall goal is to write clean maintainable code that in legible
05:43:25 <dminuoso> Depending on who you ask, IO exceptions are perfectly fine. :)
05:43:36 <ezzieyguywuf> dminuoso: lol, I'll keep that in mind.
05:44:04 <tomsmeding> bahamas: what about "Use a string"?
05:44:08 <ski> ezzieyguywuf : oh, a different `vertexFromID'
05:44:18 <tomsmeding> or perhaps "create"
05:44:43 <ski> bahamas : no, please don't say "define" there
05:44:43 <bahamas> tomsmeding: create sounds more appropriate to me
05:45:04 <dminuoso> ezzieyguywuf: But anyhow, this is not applicable to you anyhow, since you don't have IO in those codepaths. Carry on!
05:45:12 <ezzieyguywuf> ski: yes indeed.
05:45:30 <bahamas> ski: ok, I won't. although the sentence I pasted above comes out of the haskell report
05:45:54 <ski> bahamas : the example you had wasn't a declaration
05:46:14 <frdg``> what can I do to avoid using three layers of case statements and an if statement here? https://dpaste.org/CNiT
05:46:31 <ski> bahamas : to be clear, i'm talking about expression literals like `"Hello, world"'
05:46:47 <bahamas> ski: so, by ordinary values, the report doesn't mean primitives
05:47:48 <bahamas> anyway, I'm fine with using "Create ..."
05:48:26 <ski> bahamas : you could say "Express a list range","Express a string constant" ?
05:48:56 <ski> (not sure what you mean by "ordinary values", nor "primitives")
05:51:40 <bahamas> ski: "ordinary values" is what the haskell report says
05:51:48 * hackage aeson-with 0.1.1.2 - withXField combinators for aeson  https://hackage.haskell.org/package/aeson-with-0.1.1.2 (locallycompact)
05:52:15 <bahamas> ski: this is the sentence I got out of the report: "Declarations define things such as ordinary values, datatypes, type classes, andfixity information."
05:54:50 <ski> i think that refers to being able to name values, as in e.g. `x = 2'
05:55:22 <ski> (and also to be able to name data types, like `data Bool = False | True', &c.)
05:55:50 <ski> or, if you want
05:55:53 <bahamas> ski: naming things is called "binding" from what I know
05:56:03 <ski>   myString = "Hello, world"
05:56:17 <bahamas> as in, binding declaration
05:56:18 <ski> definition is a special case of binding
05:56:38 <ski> `\x -> x+1' binds the name `x' in the expression `x+1'
05:56:42 <ski> but it's not defining `x'
05:57:59 <tomsmeding> bahamas: the giveaway is "fixity information", which is certainly a top-level definition
05:58:31 <ski> `f x = x+1' binds both `f' and `x' (in different scopes). but only `f' is defined by that definition
05:59:50 <tomsmeding> frdg``: the 'if' can become pattern guards at least
06:00:50 <tomsmeding> and assuming all arms of the Country case evaluate plainStCode, you can case on (plainCountry loc, plainStCode loc) immediately
06:01:17 <bahamas> ski: tomsmeding to make sure I understand. you think it's correct to use "define" only when creating a new identifier, (variable, function, data type, typeclass, etc.). right?
06:01:18 <tomsmeding> or you can use one of the combinators from Data.Maybe for the innermost case, in particular 'maybe' or 'fromMaybe'
06:01:26 <tomsmeding> bahamas: yes
06:01:51 <ski> yes, bahamas
06:02:20 <bahamas> fair enough
06:02:24 <tomsmeding> if you "define" something, that produces a "definition", which makes sense for functions, types, etc., but not for literals
06:03:06 <ski> a definition is a kind of statement
06:03:33 <ski> (not talking about imperative languages, which sequence commands, not really statements)
06:12:59 <ezzieyguywuf> ski: is it more clear what I'm trying to do now? lol
06:14:28 <ski> hm, not really :/
06:14:33 <ezzieyguywuf> lol, dang.
06:48:04 <czrrrr> hi
06:48:08 <czrrrr> https://clipwatching.com/cbxbkbaip66m/Some_of_my_metal_detector_finds_in_this_year_from_B.C._300_to_modern_things.mp4.html
06:54:02 <ezzieyguywuf> ski: dminuoso: So, I was able to get my example running with ExcepT. Perhaps this makes my desired use-case more clear? I think I have what I need now, but I am of course open to any input https://dpaste.com/DZBPVTF72
07:03:59 <nerdypepper> where does one put fixity definitions ideally? should they be at the top of the file? or is there no convention?
07:06:02 <ski> preferably in close proximity to either the type signature (if any) of the infix operator, or else the definition of it ?
07:06:57 <MarcelineVQ> most people seem to stick them at the top of the moudle under imports, I think this is really mean and that they should be right above/near your type signature
07:19:20 <c_wraith> I've never seen them anywhere other than next to the type and definition....
07:23:39 <nerdypepper> gotcha ski 
07:24:33 <ski> c_wraith : can also be for a data constructor, or a field selection function
07:24:44 <ezzieyguywuf> dminuoso: do you usually define `note` polymorphically as you first showed it yesterday, or with the specific type signature that you're dealing with?
07:24:45 <nerdypepper> anyone know a good haskell formatter? stylish-haskell can't seem to parse some of my (valid haskell) files for some reason
07:24:47 <ski> oh, i hadn't noticed that, MarcelineVQ :p :(
07:25:19 * hackage floskell 0.10.4 - A flexible Haskell source code pretty printer  https://hackage.haskell.org/package/floskell-0.10.4 (ecramer)
07:27:46 <MarcelineVQ> hmm maybe I'm just used seeing it in base then where it's very common, and happens to be the source code I see most often which creates a bias
07:39:21 <dminuoso> ezzieyguywuf: Polymorphically, usually.
07:40:35 <ezzieyguywuf> dminuoso: patting myself on the back over this one, `note = (`maybe` pure) . throwError`
07:40:39 <ezzieyguywuf> lol.
07:41:22 <dminuoso> ezzieyguywuf: I like to write it as `note = flip maybe pure . throwError`
07:41:53 <dminuoso> I personally find sections in point-free code slightly less readable.
07:43:26 <ezzieyguywuf> dminuoso: I can see an argument for both. I can almost naturally read the former as "if Just then pure else throwError"
07:59:36 <dmwit> note e = maybe (throwError e) pure -- also reads very nicely
08:04:39 <glguy> Yay, dmwit fixed it!
08:08:49 * hackage lucid-cdn 0.1.1.1 - Curated list of CDN imports for lucid.  https://hackage.haskell.org/package/lucid-cdn-0.1.1.1 (locallycompact)
08:09:37 <ph88> how can i install phtread on windows ? i get this error https://bpa.st/Y5WA 
08:12:07 <merijn> eh, pthreads is a posix/unix thing, so you can only compile it if you use some posix compatibility layer like cygwin (does mingw support pthreads?)
08:17:33 <ph88> i tried these commands:   stack exec -- pacman -S mingw64/mingw-w64-x86_64-winpthreads-git    stack exec -- pacman -S mingw64/mingw-w64-x86_64-libwinpthread-git
08:18:02 <ph88> i have actually pthread.dll in a few places, including C:\Windows\System32  .. maybe it's a permission problem ?
08:18:04 <ezzieyguywuf> dmwit: very true.
08:18:21 <ezzieyguywuf> i was mostly just being proud of myself for understanding haskell enough to reduce it like I did ^_^
08:25:49 * hackage optparse-declarative 0.3.1 - Declarative command line option parser  https://hackage.haskell.org/package/optparse-declarative-0.3.1 (kakkun61)
09:09:46 <monochrom> \∩/ finally someone on reddit stating that people overcomlicate monads
09:10:40 <monochrom> onoes, it promises yet another monad tutorial
09:10:46 <wavemode> people also oversimplify monads
09:11:17 <monochrom> That's a major factor in overcomplication. Yet another tutorial.
09:15:06 <[exa]> a lot of monad tutorial beginner-level problems could be solved by renaming "Monad" to "Monadic"
09:15:12 <czrrrr> https://clipwatching.com/7eoer189ahgs/Some_of_my_metal_detecting_finds_from_this_year_from_B.C._2000_to_medieval_period.mp4.html
09:15:18 <phadej> few hours ago that thread was already full of "monad tutorials"
09:15:30 <monochrom> Yeah
09:15:55 --- mode: ChanServ set +o monochrom
09:16:04 --- mode: monochrom set -o monochrom
09:16:05 <phadej> yet, it's good there is something stable in this world.
09:16:15 <phadej> monad tutorials come and go
09:16:28 <monochrom> spammers march on? :)
09:16:52 <Cheery> http://boxbase.org/entries/2020/aug/5/how-a-haskell-programmer-wrote-a-tris-in-haskell/
09:17:02 <[exa]> "View this easy monad tutorial in 7 steps! You won't believe step 4!"
09:18:32 <phadej> [exa]: many problems can be solved by not mentioning Monad at all. "... in IO Monad" -> "... in IO"
09:19:12 <[exa]> yeah, 80% of the problem is linguistic
09:19:38 <[exa]> "What's a monad?" -> "Nothing, a mere property." -> "So WTF actually?!"
09:21:35 <Cheery> thought I had exhausted the backlog of silly stuff to write about, so I could finally get back to proper stuff.. oh right there's few in already.
09:21:52 <Cheery> yeah.. better to just focus on the proper stuff for a moment.
09:22:00 <[exa]> Cheery: I should record a talk, I'm now drawing a monad tutorial meme
09:22:07 <rotaerk> a monad is a type that supports a certain set of operations that follow certain laws
09:22:44 <jumper149> rotaerk: s/type/type constructor/
09:22:55 <Cheery> yeah, not a type
09:23:00 <[exa]> s/$/ class/
09:23:02 <Cheery> * -> *
09:23:32 <rotaerk> err, no `Monad a => a f` ... in this case, `a` is a type that is a monad
09:23:38 <fresheyeball> hey out there
09:23:44 <[exa]> btw can we track the first one who used the word "Monad"? 
09:23:49 * hackage store 0.7.6 - Fast binary serialization  https://hackage.haskell.org/package/store-0.7.6 (MichaelSloan)
09:23:51 <fresheyeball> I am looking at using native JSON decoding in a GHCjs application.
09:24:03 <rotaerk> also, types of kind * -> * are types
09:24:22 <Cheery> the precise definition pisses off people who try to bring monads into javascript.
09:24:41 <Cheery> or then it's just me.
09:24:44 <fresheyeball> Aeson is really just too slow
09:24:49 * hackage store-streaming 0.2.0.2, store-core 0.4.4.3 (MichaelSloan): https://qbin.io/hints-links-7j1b
09:25:32 <jumper149> rotaerk: Ok in Haskell that is a type yes.
09:27:07 <rotaerk> the term "type constructor" refers not to a specific kind, but to the name of a defined type, as opposed to a type variable
09:27:25 <rotaerk> so `Maybe` is a type constructor and so is `()`
09:28:20 <dminuoso> If we define a data constructor to be something you can pattern match on, then the same holds true for type constructors. Except, on the term level this is done via case-of (or things that desugar into uses of it), and on the type level its done with typeclass resolution or type families.
09:28:24 <Cheery> functor with two natural transformations satisfying some coherence properties.
09:28:26 <dminuoso> That's how I think about it :)
09:33:42 <Cheery> I like the CT definition because it's simple, and really if I need to worry about whether something's monad, it explodes into the definition.
09:34:04 <dminuoso> CT-wise I like the monoid definition
09:34:27 <dminuoso> Especially because get to think about what other monoids arise if you equip the category of endofunctors with other tensors
09:34:42 <dminuoso> There's some pretty interesting ones, between Sum, Product, These, Day
09:38:00 <dminuoso> (Or These1, rather)
09:41:32 <Cheery> string interpolation.. javascripts string interpolation is something like..
09:42:17 <Cheery> tag(strings, personExp, ageExp)
09:42:33 <Cheery> then you could do. tag`Foo${x} ${y}`
09:43:14 <Cheery> it's actually quite neat and maybe better than anywhere else.
09:43:52 <dminuoso> Cheery: We have someting better. QuasiQuotation
09:44:10 <dminuoso> You can create the same style of interpolation, but with the mighty power of Haskell behind it to do other things
09:44:34 <dminuoso> Parametrizable QQs are really neat
09:45:38 <sm[m]> excuse the lazy question.. I have a foldr of a pure function f.. how would I make that monadic, ie f is going to return an Either and I'd like to short-circuit if there's a Left ?
09:46:04 <ski> sm[m] : just use `foldr' still ?
09:47:15 <sm[m]> hmm, hmm, thanks for the hint!
09:47:20 <dminuoso> sm[m]: There's also foldM :)
09:48:24 <ski> > foldr (\n act -> if even n then (n `div` 2 :) <$> act else Left n) (pure []) [2,8,5,7,1,4]
09:48:26 <lambdabot>  Left 5
09:48:29 <ski> > foldr (\n act -> if even n then (n `div` 2 :) <$> act else Left n) (pure []) [2,8,4]
09:48:31 <lambdabot>  Right [1,4,2]
09:48:58 <ski> but `foldM' is more like `foldl'
09:49:21 <ski> (perhaps that's good enough for you, though)
09:49:28 <dminuoso> Well there's also foldrM, if you like
09:49:54 <sm[m]> very good.. it says to reverse the list if you want right to left
09:50:16 <sm[m]> and foldrM is in Data.Foldable, I see
09:51:18 <ski> in your case, with short-circuiting, probably it's not going to work with an infinite list, regardless
09:52:04 <dminuoso> % foldrM (\n xs -> if even n then pure (n `div` 2:xs) else Left n) [] [2,8,4]
09:52:04 <yahb> dminuoso: Right [1,4,2]
09:53:40 <pragma-> I am looking at https://github.com/ncfavier/glam -- what do you guys think?
09:54:15 <nil> ignore him, that's mine, he's joking.
10:00:14 <sm[m]> hooo, my head. 
10:00:44 <sm[m]> https://github.com/simonmichael/hledger/blob/master/hledger-lib/Hledger/Data/TransactionModifier.hs#L43 is the line, where transactionModifierToFunction is going to start returning an Either. I'm very interested to hear any tips for how you break it down when some new types exceed your brain space & familiarity 
10:03:38 <nh> pragma- looks interesting, why is it so slow
10:04:16 <dminuoso> sm[m]: An either?
10:05:25 <sm[m]> yes, an either is blowing my mind :)
10:05:42 <dminuoso> Where is the either?
10:06:49 <sm[m]> transactionModifierToFunction has been returning a simple value (and sometimes calling error), now I want it to return an Either
10:07:17 <sm[m]> and getting this module to compile again is not so easy. I guess I'll silence some of these other errors and take smaller steps
10:07:55 <dminuoso> Well, spoonfeeding is not gonna help you. Try writing out in non-pointfree.
10:08:27 <dminuoso> That is, rewrite `flip (.) . transactionModifierToFunction` as a lambda, 
10:10:03 <dminuoso> As an additional step, maybe use Control.Arrow.(>>>) instead of `flip (.)` until you deconfused yourself. :)
10:17:16 <czrrrr> Big explosion https://clipwatching.com/9q8hnqi42wjv/explosison_fishing.mp4.html
10:17:40 <sm[m]> silencing other errors helped.. making progress again. I'll check >>>, thanks
10:20:26 <leanr> hello, i wonder know if someone can help me, please
10:20:46 <aldessa> what is the question?
10:20:55 <aldessa> not sure i can help but you can ask
10:22:18 <leanr> i want to learn the functional paradigm, so i think the best way is learning haskell also i start to read "Learn You a Haskell for Great Good!: A Beginner's Guide", so is good to start there ?
10:22:28 <ezzieyguywuf> sm[m]: hey you're one of the hledgerers!?
10:22:28 <leanr> or i will loose my time?
10:24:06 <aldessa> i'm a bit confused, what are you trying to do?
10:24:08 <DigitalKiwi> i prefer the hutton book programming in haskell but if lyah makes sense to you it's not a bad one
10:24:20 <sm[m]> ezzieyguywuf: I am the lead hledgerer!
10:24:28 <DigitalKiwi> nice i use hledger
10:24:33 <DigitalKiwi> <3
10:24:54 <ezzieyguywuf> sm[m]: o/ hey!!!! I've been meaning to transition to hledger from beancount
10:24:58 <ezzieyguywuf> just haven't taken the time yet.
10:25:49 <ezzieyguywuf> sm[m]: I don't completely understand your line 43 there, but could a `sequence . zip` perhaps work here?
10:26:39 <DigitalKiwi> sm[m]: i think the bash aliases are broken for the timeclock as written on the page (i fixed them for myself at some point) but i made my own bash script that makes sure i don't do stupid things like clock in twice
10:26:51 <DigitalKiwi> https://mostlyabsurd.com/files/tito
10:26:59 <DigitalKiwi> good ol' tito
10:27:10 <DigitalKiwi> and then i symlink to and ti
10:28:53 <sm[m]> ezzieyguywuf: maybe, I'm simplifying 
10:28:57 <DigitalKiwi> also this 404s and i haven't ever found them :( or use the old ti and to scripts in the ledger 2.x repository. 
10:29:09 <sm[m]> DigitalKiwi: thanks! which page ?
10:29:16 <DigitalKiwi> https://hledger.org/timeclock.html
10:29:30 <sm[m]> thank you, I'll check it after this
10:30:12 <DigitalKiwi>   #alias ti='echo i $(TZ='America/Chicago' date "+%Y-%m-%d %H:%M:%S") >>$T  IMELOG'
10:30:13 <DigitalKiwi>   #alias to='echo o $(TZ='America/Chicago' date "+%Y-%m-%d %H:%M:%S") >>$T  IMELOG'
10:30:19 <DigitalKiwi> are what i came up with
10:30:37 <DigitalKiwi> minus the spaces...
10:30:47 <DigitalKiwi> small terminal
10:31:57 <DigitalKiwi> converting tito to haskell is on my todos
10:46:08 <ezzieyguywuf> DigitalKiwi: what does tito do?
10:53:00 <DigitalKiwi> it's for working with a timeclock file that hledger/ledger/emacs use. the bash aliases were too primitive for my liking. it was too easy to time in twice, or time out twice, and corrupt the file. so this trys to validate that and will (for me, do the right thing) clock out and then in. you can also just YOLO and type tito "comment" and it'll alternate
10:54:04 <DigitalKiwi> i make symlinks to to it from ti and to as well and it'll detect that and act accordingly
10:54:20 <dsal> Oh, does this work with org-mode?
10:54:22 <DigitalKiwi> that was not a proper sentence
10:54:44 <dsal> I've abused org-mode and emacs timers in some pretty impressive ways.
10:54:56 <DigitalKiwi> ln -s ~/bin/tito ~/bin/to
10:54:59 <DigitalKiwi> ln -s ~/bin/tito ~/bin/ti
10:55:14 <DigitalKiwi> timeclock.el
10:55:42 <DigitalKiwi> https://www.emacswiki.org/emacs/TimeClock
10:56:00 <DigitalKiwi> https://www.emacswiki.org/emacs/timeclock-x.el
10:56:26 <DigitalKiwi> i think the format is different from org mode?
10:58:20 <dsal> Ah.  I used some weird combination of org-mode and chronos to manage a thing where I had to run a couple hundred individual tasks concurrently manually from a list.  It would log when I started and ended things and tell me what commands to run.  Pretty neat seeing a wall of timers.
10:58:47 <lyxia> does -XCPP not support token concatenation?   #define F(X) Monad##X   should expand  F(IO)  to  MonadIO   but I get   Monad##IO
10:59:59 <DigitalKiwi> with a file in this format various ledger programs can import or parse it and tell you how long things have taken etc. as if it was a ledger
11:03:15 <phadej> lyxia: depends on your cpp
11:03:19 <phadej> cpphs doesn't do that by default
11:03:53 <sm[m]> DigitalKiwi: nice
11:04:05 <phadej> (and there's no way to specify which cpp you need, or different options to different cpp implementations)
11:05:46 <lyxia> so it depends on my cpp but I'm also not supposed to choose my cpp, which is observationally equivalent to "can't to that"
11:05:59 <phadej> yep
11:06:14 <phadej> i'm not annoyed enough to improve that
11:06:23 <phadej> cpphs-options in .cabal filed would do that
11:06:24 <sm[m]> DigitalKiwi: let's discuss in #hledger some time
11:07:12 <DigitalKiwi> sm[m]: sure! i want to convert this to haskell and then add more features but you know...life and other projects and it works well enough right now it has been low priority
11:07:38 <sm[m]> if you convert to haskell, it's maybe more portable for some, less so for others
11:08:05 <sm[m]> if you're always using it with hledger, a built in command is probably most convenient.. but you might not be..
11:08:41 <lyxia> phadej: no problem, thanks for the info
11:10:32 <lyxia> I can do    #define F(X) Monad'X   which is close enough...
11:10:56 <phadej> lyxia: https://github.com/malcolmwallace/cpphs/issues/20 (i.e. cpphs supports it, but it's disable by default)
11:18:41 <monochrom> lyxia, phadej: Noooooooo!  My cpp is gcc's cpp.  I have tested that using "gcc -E" directly, it honours ##.  Going through GHC, GHC issues "gcc -E -traditional", the -traditional kills it.
11:22:45 <monochrom> It seems that this is true way back to 7.10 or before.
11:23:15 <maerwald> phadej: badc0de work with base-4.14.0.0
11:32:44 * ezzieyguywuf wonders about time-in time-out
11:38:47 <phadej> maerwald: pr welcome
11:39:22 <phadej> monochrom: ok good to know. I don't remeber what -traditional does, have to check
11:40:18 <phadej> ah https://gcc.gnu.org/onlinedocs/cpp/Traditional-Mode.html
11:40:26 <phadej> ok, without probably not much stuff would work
11:41:14 <phadej> """ Generally speaking, in traditional mode an opening quote need not have a matching closing quote.
11:41:35 <phadej> #define m This macro's fine and has an unmatched quote
11:41:38 <phadej> so it's a necessity
11:41:50 <phadej> cpp is just blargh
11:42:26 <monochrom> :)
11:43:24 <ezzieyguywuf> I don't think c++ is so bad
11:43:33 <phadej> ezzieyguywuf: c preprocessor
11:43:35 <phadej> not cxx
11:43:59 <phadej> and yes, C++ has static_if
11:44:18 <ezzieyguywuf> ah
11:44:20 <ezzieyguywuf> nvm then
11:45:57 <phadej> """ While the feature may be easily implemented as part of the translation process,
11:46:00 <phadej> program analysis tools have traditionally struggled with conditional declarations.
11:48:05 <L29Ah> what's the best flattened generics library these days?
11:49:29 <L29Ah> XY: https://github.com/l29ah/hyborg/blob/master/Types.hs#L31
12:00:14 <DigitalKiwi> ezzieyguywuf: what is time-in time-out
12:00:43 <Orbstheorem> What types are not typeable?
12:02:03 <DigitalKiwi> need help with optparse-applicative; https://gist.github.com/Kiwi/92415b46d58bfce34f7773944b6dcc67#file-absurd-paste-client-hs-L260-L275 this seems the wrong way to do that
12:02:10 <DigitalKiwi> the if then else
12:02:54 <DigitalKiwi> is this a subparser/command situation
12:03:31 --- mode: ChanServ set +o glguy
12:03:31 --- mode: glguy set -qqqq *!*@85.95.114.253 *!*@182.1.0.0/16 *!*@gateway/web/freenode/ip.185.103.96.151 *!uid201163@gateway/web/irccloud.com/*
12:03:32 --- mode: glguy set -qqqq *!*@2001:999:61:aaf9::/64 *!*@gateway/web/cgi-irc/kiwiirc.com/ip.82.1.242.231 *!*@37.165.184.179 *!*@147.161.*
12:03:32 --- mode: glguy set -o glguy
12:04:06 <L29Ah> DigitalKiwi: it won't be much different if you use subparser/command tbh
12:04:21 <Orbstheorem> DigitalKiwi: looks very imperative-y :(
12:04:25 <L29Ah> optparse-applicative is about how you want your CLI to look and feel
12:04:53 <L29Ah> making sense of user inputs beyond command line option parsing is another matter
12:05:09 <DigitalKiwi> Orbstheorem: the whole program or run?
12:05:41 <Orbstheorem> run
12:05:43 <DigitalKiwi> L29Ah: yeah that making sense of it is where i'm not so much stuck but don't like where it's going
12:05:48 <DigitalKiwi> well it is IO () ;P
12:05:51 * Orbstheorem is looking at the rest for fun.
12:06:10 <DigitalKiwi> most of the rest of it should be fairly functional
12:06:47 <L29Ah> DigitalKiwi: you can do things like myFun [] bar baz = foo
12:06:48 <L29Ah> myFun (x:xs) bar baz = oof
12:07:08 <L29Ah> if you don't feel like stuffing everything in one big body
12:07:17 <DigitalKiwi> https://raw.githubusercontent.com/Kiwi/Uppity/master/README this is the current goal to be feature parity with my last one
12:08:24 <DigitalKiwi> that gist is about to become multiple files because https://dpaste.com/api/v2/syntax-choices/ ;_; will probably double the length of this file
12:09:08 <DigitalKiwi> L29Ah: oh, yeah, good idea
12:09:38 <L29Ah> you can write generic instances for the type enumerating all the syntax choices ;)
12:09:39 <Orbstheorem> DigitalKiwi: I'd move all the constants to a module.
12:09:42 * DigitalKiwi not looking forward to adding all of those data types
12:09:56 <DigitalKiwi> i have a helper script that gens some of it but still
12:10:07 <Orbstheorem> DigitalKiwi: Have your editor do it for you?
12:10:23 <Orbstheorem> You must be getting them from somewhere :)
12:10:50 <DigitalKiwi> i mean sometimes i've had to pull them out of html
12:11:10 <DigitalKiwi> apc is my 5th paste/upload client...
12:11:19 <Orbstheorem> And __please__ move dpasteOrgLanguages, Language and parseLanguages to a separate module :)
12:11:57 <Orbstheorem> <From the HTML> Probably writing beautifulsoup will take you as long __but__ you will learn a reusable skill.
12:11:58 <DigitalKiwi> yeah when it was only dpaste.org (it's now half way to dpaste.com as well) it was fine in one file and the plan was always to move it to separate modules
12:12:03 <DigitalKiwi> https://dpaste.com/7X627DCG3
12:12:15 <Orbstheorem> Though to be fair, I'd probably just regex and perl my way through x)
12:12:34 <DigitalKiwi> https://mostlyabsurd.com/files/LangFormat.hs
12:12:48 <DigitalKiwi> that was what i used for dpaste.org
12:13:01 <DigitalKiwi> i probably had to mass edit them to have the quotes
12:13:06 <DigitalKiwi> and commas
12:13:09 <DigitalKiwi> not a big deal
12:13:29 <Orbstheorem> :%s/.*/"\0"
12:13:43 <DigitalKiwi> they most likely started off looking like the first column or the same as that most recent dpaste.com
12:13:46 <DigitalKiwi> yes
12:14:23 <DigitalKiwi> i use things like that and visual column mode :P
12:14:43 <Orbstheorem> And perl <3
12:14:52 <DigitalKiwi> and haskell :|
12:14:52 <Orbstheorem> Don't forget good'ol perl!
12:15:10 <DigitalKiwi> i can't say that i've ever written a line of perl
12:15:29 <DigitalKiwi> i might have but i don't remember it
12:15:32 <L29Ah> perl is just sed Enterprise Edition ;)
12:15:35 <Orbstheorem> Last time I wrote a "quick and dirty" haskell parser I ended up doing a whole new project: https://gitlab.com/roosemberth/botw-cooking-rupees
12:15:43 <Orbstheorem> L29Ah: ROFL!
12:17:57 <DigitalKiwi> https://dpaste.com/93ZZHD3KK#line-216
12:18:03 <DigitalKiwi> if you want to see really bad code
12:18:46 <DigitalKiwi> suggestions appreciated
12:18:53 <DigitalKiwi> that was the last thing i did before going to bed
12:19:36 <L29Ah> i suggest you hlint
12:19:45 <Orbstheorem> Please
12:20:06 <Orbstheorem> Sorry, I'm in a bad mood.
12:20:16 <Shlomo> Hi, I want to hack on an open source hs project.  It only has a cabal file and no other build files or instructions.
12:20:17 * Orbstheorem will stop critisizing and go back to work.
12:20:56 <Shlomo> I've only ever built hs projects with stack and nix.  What should I Google to learn how to build a "simple" cabal project without polluting my home env?
12:20:58 <davean> Shlomo: the cabal file is build directions. Whats your experience with Haskell?
12:21:23 <Uniaika> Shlomo: `cabal v2-build`?
12:21:23 <L29Ah> Shlomo: run `cabal v2-build`
12:21:24 <davean> Shlomo: well what do you consider poluting your home enviroment?
12:21:38 <monochrom> I believe stack understands cabal file as well.
12:21:59 <Shlomo> davean: like, having a global ghc, globally installed packages, etc.
12:22:23 <L29Ah> also you can google cabal nix-style builds
12:22:30 <L29Ah> that describes how v2-build works
12:22:53 <Shlomo> ok lots of good info, whew, gonna go read up.  Thx er'body
12:23:08 <xsperry> stack uses cabal files, but it also requires stack.yaml 
12:23:42 <DigitalKiwi> L29Ah: oh thanks... wonder why it's not working right now in emacs :(
12:23:56 <DigitalKiwi> L29Ah: it had a few things that cleaned that up
12:24:24 <davean> Shlomo: you can use -w to specify which GHC to use so it isn't in your path.
12:24:33 <davean> Shlomo: (which is what stack is doing effectively)
12:27:17 <Shlomo> wow, cabal has changed since I last used it directly maybe 8 years ago
12:27:29 <davean> Shlomo: Oh?
12:28:35 <Shlomo> davean: I didn't remember there being sandboxing or anything but maybe I'm misremembering.  Anyway when stack came out I said "never going back to just cabal"
12:29:04 <davean> Shlomo: cabal sandboxes existed but people weren't educted about them. I used them.
12:29:14 <DigitalKiwi> most of the problems with cabal that stack purported to solve have been fixed in cabal
12:29:19 * hackage alex-meta 0.3.0.12 - Quasi-quoter for Alex lexers  https://hackage.haskell.org/package/alex-meta-0.3.0.12 (ArtemPelenitsyn)
12:29:35 <Shlomo> good to know.
12:29:43 <davean> Shlomo: they were a second tool that worked with cabal back in like 2010
12:29:47 <monochrom> No one is going back to 10-years-old cabal except me.
12:29:56 <DigitalKiwi> i've had a lot more trouble with stack than cabal :(
12:30:12 <davean> Shlomo: https://hackage.haskell.org/package/cabal-dev-0.7'
12:31:16 <davean> I have noticed layering functionality does not work for adoption
12:31:46 <sm[m]> DigitalKiwi: did you read the manual for both ?
12:31:49 <sm[m]> just curious
12:32:34 <DigitalKiwi> i haven't read completely anything but i have read both
12:32:44 <sm[m]> nod
12:33:13 <DigitalKiwi> i mostly use nix/cabal now 
12:33:35 <DigitalKiwi> i'm trying haskell.nix with apc 
12:33:47 <sm[m]> some people, not you, have a bad time with both tools because of trying to use them without the basic concepts
12:33:52 <DigitalKiwi> but usually i use a fairly simple shell.nix and just use cabal v2-*
12:34:21 <sm[m]> other people do everything right and the tool fails them.. hopefully that happens less often these days
12:34:23 <monochrom> I think all beginners use either without the basic concepts.
12:35:04 <DigitalKiwi> i probably spend 90% of my time reading 10% coding and 10% might be high
12:35:14 <DigitalKiwi> i should tito it
12:35:18 * hackage dobutokO-poetry 0.9.0.1 - Helps to order the 7 or less Ukrainian words to obtain somewhat suitable for poetry or music text  https://hackage.haskell.org/package/dobutokO-poetry-0.9.0.1 (OleksandrZhabenko)
12:35:22 <monochrom> This is why I just show my students using ghc itself directly.
12:35:23 <DigitalKiwi> and like 2x on irc
12:35:40 <DigitalKiwi> that's what fp-course started doing
12:35:49 <hyperisco> DigitalKiwi, this is why programs like emacs or vim do not attract me
12:35:51 <sm[m]> I probably ran my first commands by copy/paste from some haskell article, but I imagine I had a quick look at the docs when things stopped working
12:36:14 <DigitalKiwi> hyperisco: how so
12:36:27 <hyperisco> because they optimise on the 10%
12:36:54 <Shlomo> oh forehead-slap I did use cabal directly with nix integration, what am I talking about.
12:36:57 <DigitalKiwi> gotta make the most of that 10%
12:37:03 <ezzieyguywuf> DigitalKiwi: tito = time-in time-out?
12:37:11 <monochrom> My unix-and-C course students do too much reading and watching videos, too little coding.
12:37:12 <DigitalKiwi> ezzieyguywuf: yeah that one i linked
12:37:24 <hyperisco> you can… many do… I don't feel the motivation :P
12:37:36 <monochrom> To the point it's a spectator sport for them and it shows.
12:37:49 <hyperisco> I say this to speak up for the plebeians out there
12:37:50 <monochrom> They can memorize everything and implement nothing.
12:38:02 <DigitalKiwi> i don't spend a lot of time configuring vim for anything but i use doom-emacs for "projects"
12:38:28 <DigitalKiwi> monochrom: that's how i feel :(
12:38:46 <DigitalKiwi> monochrom: even when i do write code i'm like this is bad and then people look at it and are like this isn't that bad
12:38:54 <monochrom> And go on to speak like "how do I call /dev/fd/42"
12:39:09 * DigitalKiwi had soemone review some python the other day that i considered horrible and they said was ok
12:39:13 <DigitalKiwi> i don't know python
12:39:30 <hyperisco> why does only listening to something feel like competence but actually isn't
12:39:30 <DigitalKiwi> makes it a bit difficult to write :)
12:41:10 <DigitalKiwi> anyway most of my reading is like blog posts, documentation, source code, etc. otherwise how would i know what to write
12:41:42 <merijn> monochrom: otoh, there's also lots of students who do too much coding and too little reading :p
12:46:00 <hyperisco> I read until up until I understand enough to have a disagreement :P
12:47:21 <davean> I did all my reading about programming about a decade before I started programming, so I just treated it as a knowlege base to fall back on, and I think I'd read enough that when I took the majority oppinion with consideration of the minority oppinions I was well informed.
12:47:30 <hyperisco> like dependent types… I used them until I felt I couldn't see how I'd practically make use of them
12:47:57 <davean> but since I couldn't program when I read about it, I had to treat programming like math
12:48:18 <davean> So I studied it in the abstract and only got to try practing it many years later.
12:48:27 <davean> It seemed to work really well though for me.
12:48:29 <hyperisco> now I just spend my days moaning about how imprecise software is
12:49:41 <merijn> hyperisco: I moan about how imprecise people are ;)
12:49:57 <davean> merijn: Please don't bring people into this, they ruin everything.
12:50:03 <monochrom> I moan about how people are.
12:50:03 <hyperisco> davean, I feel like if you just go head first into programming, maybe read a Dummies book, you can rise to the level of proficient garden shed maker
12:50:07 <merijn> People are the worst
12:50:37 <davean> hyperisco: Thats probably true? I expect the method doesn't matter much really if you dive in.
12:50:45 <hyperisco> davean, but your approach can architect a cathedral, given the time
12:51:08 <davean> hyperisco: well my approach was because computers weren't pressent in my part of the world and I had things I wanted to make that required them.
12:51:41 <hyperisco> I am serious when I say computers are a source of confusion
12:51:59 <monochrom> I think your success factor is you treated it as math (when you couldn't test).
12:51:59 <hyperisco> because computation becomes identified with computer architecture, and that is mistaken
12:52:30 <monochrom> Most people read the same material as argumentative essays, not as math.
12:52:32 <hyperisco> walking back from that unnecessarily restrictive viewpoint is arduous… at least, that is me, and I think so
12:52:47 <davean> monochrom: interesting
12:53:03 <hyperisco> just figure… how did anyone reason about computation before the first computer. How was the first computer designed?
12:53:20 <hyperisco> so, even in principle, the computer as a machine is unnecessary
12:53:23 <tomjaguarpaw> Turing machines, lambda calculus, etc.
12:53:27 <hyperisco> but it is handy for checking your work :)
12:54:30 <davean> monochrom: I think I'm too deep in my perspective to understand what considering it an essay might mean.
12:54:59 <davean> That entire concept doesn't resonate with me and I'm just lost as to waht you might be saying when I consider it more.
12:55:51 <monochrom> I don't entirely understand it either.
12:56:08 <monochrom> In the end my "essay" theory may be off.
12:57:23 <davean> mmm, well what I got what you said from that was something about oppinions, and art. Which at first made sense but then on consideration only seemed slightly attached. I'll mull on it more as I see examples.
12:57:49 * hackage commonmark 0.1.0.2 - Pure Haskell commonmark parser.  https://hackage.haskell.org/package/commonmark-0.1.0.2 (JohnMacFarlane)
12:59:17 <monochrom> Part of an essay game is word game. For example, consider the fact that function application is left-leaning, "f x y" means "(f x) y", and the pairing fact that function type is right-leaning, "X -> Y -> Z" means "X -> (Y -> Z)".
12:59:42 <DigitalKiwi> Orbstheorem: so should i move all of the datatypes except Language to a different module and put Language and all of the functions in their own module and put the different services and their functions in a different module and import that?
13:00:00 <hyperisco> oh, the conflation of technical terminology with dictionary words
13:00:12 <monochrom> It is a common confusion for wordy reasoners why one is left and the other is right, why aren't they both left, why aren't they both right.
13:01:14 <hyperisco> some may be arguing the aesthetics
13:01:19 * hackage happy-meta 0.2.0.11 - Quasi-quoter for Happy parsers  https://hackage.haskell.org/package/happy-meta-0.2.0.11 (ArtemPelenitsyn)
13:01:26 <DigitalKiwi> Orbstheorem: so module per service: module for data types (not Language) and a few functions: module for Language: ...module for parser? : Main.hs mostly just...not a lot
13:01:33 <monochrom> In general, if there are two sides S1, S2 of the same coin, but their wordy descriptions use opposite wording (and rightfully so), essay wordy reasoners have trouble.
13:01:42 <davean> I mean one leans one direction basicly because the other leans the other. I suppose thats not requires but its certainly simpler.
13:01:52 <hyperisco> as opposed to trying to draw parallels by their syntactic structure
13:02:07 <monochrom> This is how I came up with my essay theory. But it still doesn't explain a lot of the other wrong things people infer.
13:02:30 <hyperisco> we can fix it once and for all anyhow, and I think <- is free at the type level
13:02:31 <Orbstheorem> DigitalKiwi: I don't have your code in mine anymore, but the reasoning behind is that when I read the code, I will scroll over "mechanical" code and by doing so, I may miss something different inbetween. So that "uninteresting" code must be moved to its own module.
13:02:38 <Orbstheorem> s/mine/mind/
13:02:39 <hyperisco> (Z <- Y) <- X
13:02:55 <davean> monochrom: that was very helpful.
13:03:02 <dolio> People seem to think they need to both be left or right to be 'consistent' or something.
13:03:20 <monochrom> A math-minded person has no problem because you shut up and calculate. Calculation says "(f x) y :: Z" iff "f :: X -> (Y -> Z)" and you see why they must go hand in hand.
13:03:28 <Orbstheorem> monochrom: Now, I would be curious to read about essay theory :)
13:03:33 <davean> monochrom: I'm having fun assembling a system for both being left leaning.
13:03:55 <DigitalKiwi> Orbstheorem: oh. well after i refactor it if you want to take a look again i have it in a git repo i just haven't put it public yet >.>
13:04:02 <dolio> hyperisco: Now the argument types are in the opposite order from the applied arguments.
13:04:10 <hyperisco> well, consider this… garden shed programming is highly identified with syntax as opposed to semantics
13:04:21 <Orbstheorem> DigitalKiwi: I don't mind ^^
13:04:23 <hyperisco> because, of course, syntax is what you type, it is what you see with your eye balls, it is what is saved to the disk
13:04:31 <monochrom> I have even shallower students who said "the empty list is empty, the empty set is empty, so they are the same thing".
13:04:34 <DigitalKiwi> Orbstheorem: ok great :D
13:04:56 <Rembane> shallow emptiness is empty
13:05:03 <Orbstheorem> monochrom: Structure :(
13:05:17 <davean> monochrom: OH, now thats an interesting confusion
13:05:58 <davean> if you start with an empty and can list add or set add to it, what does that look like?
13:06:08 <dolio> monochrom: They might be the same in ZFC. :P
13:06:09 <Orbstheorem> DigitalKiwi: you can PM me if I don't see your message here when you're done.
13:06:13 <davean> It really depends on the smeantics of a set add after a list add
13:06:17 <monochrom> Perhaps this means so far my theory is only "keyword knee-jerk/shallow reasoning".
13:06:22 <Tuplanolla> Are the holes in a doughnut and in a steel nut the same hole?
13:06:32 <DigitalKiwi> Orbstheorem: sounds good
13:06:44 <davean> Tuplanolla: topologically
13:06:59 <monochrom> E.g., people are fixated on seeing "left" or "right" duplicated, fixated on "empty".
13:07:39 <monochrom> You write a 10-word sentence explaining the empty list, they ignore the other 9 words and just see 1 word "empty".
13:07:49 <hyperisco> Tuplanolla, oh boy, I am part way through a lecture series on mereology
13:08:06 <Tuplanolla> They may even be isometrically so if you drill screws to the doughnut, davean.
13:08:09 <davean> monochrom: I mean it is interesting though. In some systems you don't know its a list or a set until it gets structure added.
13:08:12 <Tuplanolla> That's beside the point.
13:08:41 <davean> "Why do we know its a list or a set when it is empty" is informative.
13:08:54 <davean> its not really empty in a sense because we *are* tracking more information along with it.
13:09:22 <hyperisco> monochrom, what else do you instantiate your thoughts with if not the words they are transcribed by?
13:09:24 <davean> Its empty inside a system
13:10:10 <Tuplanolla> Sounds fun, hyperisco.
13:10:18 <monochrom> hyperisco, the difference is single-word vs a whole complete phrase.
13:10:20 <davean> If we're talking a range that we have operations to cut down, no data is the infinite range.
13:10:45 <davean> no data and empty are seperate concepts
13:11:08 <davean> I'm saying this quite poorly
13:11:09 <hyperisco> monochrom, yes, but, in natural language, using the same word in two places links them
13:11:10 <monochrom> I don't reason at the level of "is it empty?". I reason at the level of "is it the empty list?" or even more holistic.
13:11:48 <hyperisco> if I say the list is empty, and also the set is empty, a reasonable intuition is that they are empty in the same sense
13:12:11 <hyperisco> even though, really, the senses are different
13:12:44 <davean> hyperisco: a range empty of restrictions is the entirely opposite sense
13:14:00 <hololeap> how can i have cabal build with -O2 for my local builds without putting it in my *.cabal file?
13:14:01 <davean> monochrom: I mean such reasoning makes sense in Haskell for example but not in a setting without tags
13:14:11 <hyperisco> but if you find a student cannot free themselves from these false connections, maybe forward them to the OO course :P
13:14:15 <davean> cabal.project
13:14:33 <hyperisco> vapid analogies are invited there oO
13:14:33 <davean> hyperisco: they won't do well there either frankly.
13:14:49 <hyperisco> okay, I can only speak from my personal experience in OO education
13:14:57 <monochrom> Only politics is the right place to send them.
13:14:59 <hyperisco> but it is very much how they talk
13:15:25 <davean> hyperisco: They might do better, but they'll still get the same sorts of issues.
13:15:35 <monochrom> Using single keywords to blackmouth and scaremonger.
13:15:59 <hyperisco> it is very much oriented around the idea that you can transcribe ordinary human perception as computer programs
13:16:08 <hololeap> davean: what do i put in this cabal.project file?
13:16:19 <hyperisco> so something you identify ordinary as an object becomes an object in the program, and your job is to classify it
13:16:34 * dsal thinks about ooducation https://www.youtube.com/watch?v=QOF0UTKYdKw
13:16:44 <monochrom> I have anecdotal but still empirical evidence for davean's prediction actually :)
13:16:52 <davean> hyperisco: https://cabal.readthedocs.io/en/3.4/cabal-project.html Its the default example :)
13:17:03 <davean> hyperisco: though if you look down it takes nat
13:17:12 <davean> hyperisco: you can also pass specific GHC options
13:17:41 <hyperisco> sorry, we're burying hololeap's question
13:17:42 <monochrom> I met a 1st-year student (not in my course) in a lab, the student was learning a Java 1st-year very basic course. First time hearing classes and objects, you know the drill.
13:18:04 <hololeap> i assumed davean's last three responses were supposed to be for me :)
13:18:09 <monochrom> hololeap: optimization: 2
13:18:24 <monochrom> You also have the choice of cabal.project or cabal.project.local
13:18:26 <hyperisco> this conversation makes more sense now
13:18:35 <davean> hyperisco: the last 3 were for you!
13:18:44 <davean> hyperisco: but some others were not.
13:19:06 <monochrom> In general the syntax is very similar to that of $HOME/.cabal/config.  There are some minor differences.
13:19:38 <davean> because every cabal file format MUST be religuously different.
13:20:01 <davean> cabal ahs EIH syndrom
13:20:13 <hyperisco> davean, oh you were continuing from "a range empty of restrictions"
13:20:42 <davean> hyperisco: Yah, threading. IRC lacks it.
13:21:20 <hyperisco> I am not sure how the OO-minded would answer the emptiness question. If I was to mundanely apply what I was taught, though, then I would be observing that sets and lists are types of objects, and both can be empty
13:21:38 <monochrom> Anyway, the student was also an ardent Christian. I knew because he used Java to model the relation between God, Christ, and human. And the model got the relations all wrong, e.g., using subclassing when it should be instantiation, and vice versa.  Also, no way human can be either an object or subclass of either Christ or God.
13:21:44 <davean> hyperisco: sure, both can be empty.
13:22:13 <monochrom> So a student with very fuzzy reasoning is not going to make it in OOP either.
13:22:22 <hyperisco> so probably  Emptyable  with a boolean property "isEmpty" and a method "empty" and maybe a nullary constructor that  List  and  Set  inherit from (or implement)
13:22:47 <davean> hyperisco: where it still needs to be a member of Emptyable, so the tagging is back
13:23:18 <davean> hyperisco: you'll notice this basicly exactly matches "Monoid m => a -> Bool" "a = a == mempty" 
13:23:40 <monochrom> But cabal.project has a reason to have slightly different syntax from $HOME/.cabal/config. Because one of them has to expresss "for these packages, use this setting; for these other packages, use this other setting", and the other doesn't.
13:24:54 <davean> Yah I left off the Eq constraint, I wanted to draw attention to what mattered for the discussion but its bugging me
13:25:05 <hyperisco> monochrom, the reasoning can be so much sloppier, though
13:25:30 <monochrom> hololeap: If you do once "cabal configure --enable-optimization=2" you will receive a generated cabal.project.local that has the exact file content you want, and you can copy/move it to cabal.project
13:25:49 <hyperisco> there is a degree to which it doesn't really matter in regards to what term you come up with for a type
13:26:44 <hyperisco> watch out for bottom, don't use unsafe* things, and you'll do alright
13:26:58 <hyperisco> but the template you work under for OO is that of a class, and there are so many ways to go wrong
13:27:36 <hyperisco> and only your local greybeard can yell at you about it
13:28:10 <hololeap> monochrom: when i do that, it generates one line:  optimization: 2
13:28:36 <hololeap> but that seems to work, whereas following the example in the docs does not
13:28:38 <davean> hololeap: thats global for the compilation in that dir
13:28:48 <davean> hololeap: the example says which things you want to -O2
13:29:30 <merijn> hololeap: Which example in which docs?
13:29:42 <hololeap> in any case, i will remember `cabal configure` and use that in the future, since that seems to match my general use case
13:30:18 <hololeap> merijn: https://cabal.readthedocs.io/en/3.4/cabal-project.html#cabal-project-reference
13:30:52 * hololeap is using cabal 3.0
13:30:59 * hololeap wonders if that is part of the issue
13:31:02 <merijn> Well, what did you write and what did(n't) it do
13:31:18 <merijn> hololeap: No, that example looks fine since as early as 2.4
13:31:26 <hololeap> merijn: https://dpaste.com/C6YQREN5P https://dpaste.com/H84SKMLXD
13:31:44 <davean> hololeap: that example specifies a single package to compile with optimizations
13:31:51 <davean> hololeap: vs. everything in the stack
13:31:56 <hololeap> it didn't set -O2
13:32:45 <merijn> hololeap: I'm not sure you can use the package stanza for the direct package that your configuring (as opposed to your dependencies), although I guess it'd be confusing if you can't
13:33:35 <merijn> hololeap: ok, that appears to be a bug, since the stanza should also work for local packages
13:35:24 <merijn> hololeap: If you can make a minimal reporducing example on 3.4 you should file a bug report (if you can't because it's fixed, then, well, yay? :p)
13:35:39 <merijn> There's no real reason to use an old cabal-install
13:40:14 <hololeap> it's what's available in the haskell repo for gentoo... works well for me anyways. i don't need anything beyond `cabal configure --enable-optimization=2` for now
13:43:36 <merijn> hololeap: You can always just "cabal install cabal-install" ;)
13:52:49 * hackage ap-normalize 0.1.0.0 - Self-normalizing applicative expressions  https://hackage.haskell.org/package/ap-normalize-0.1.0.0 (lyxia)
13:58:55 <DigitalKiwi> Orbstheorem: <3 haskell for refactoring
13:59:06 <DigitalKiwi> and ghcid
13:59:13 <DigitalKiwi> the compiler tells me everything to do!
13:59:46 <DigitalKiwi> All good (6 modules, at 20:58:10)
14:32:03 <maerwald> why there's no split for String/List?
14:32:42 <merijn> There is
14:33:01 <merijn> I was pretty sure, anyway
14:33:03 <maerwald> is hoogle lying to me?
14:33:22 <merijn> splitAt
14:33:25 <merijn> In Data.List
14:33:32 <maerwald> that's completely different
14:33:34 <monochrom> The split package.
14:33:40 <merijn> If you want more flavours of splitting there's the split package
14:33:58 <maerwald> oh boy... why this is not in base
14:34:19 <merijn> Why should everything be in base?
14:34:27 <dsal> base could really be a good deal smaller.
14:34:29 <merijn> That means you can update/upgrade without changing compilers
14:34:40 <maerwald> I don't think everything should be in base
14:34:50 <maerwald> but splitting is so fundamental, it should
14:34:58 <monochrom> I don't think split needs frequent update any more :)
14:35:06 <merijn> monochrom: Sure, now
14:35:10 <merijn> maerwald: Is it, though
14:35:20 <merijn> I've used the split package...3 times in a decade?
14:35:36 <maerwald> I remember now implementing splitOn before manually in fact, 6 years ago
14:35:37 <merijn> Sure, some people might need it more frequently, but is it really that fundamental?
14:36:00 <monochrom> One function from split should have been in base as early as lines and words got into Prelude, i.e., all the way back to Haskell 98 and most likely before.
14:36:02 <sm[m]> maerwald++
14:36:13 <monochrom> Yes, that one.
14:36:23 <maerwald> I'm regretting that I used String... you know what... I'll be using Text instead, even though it doesn't make much sense
14:36:48 <monochrom> The rest of split is extra features that you would expect to be not in base.
14:38:07 <monochrom> But words and lines are such hardcoded special cases that you would think: since unsafeInterleaveIO is in base because getContents is a special case, so should splitOn be in Prelude or at least Data.List because words and lines are such special cases.
14:38:12 <kraeXen> #xmonad is pretty empty, does anyone know how to do this:
14:38:13 <kraeXen> 2:24:25 PM - kraeXen: how might I bind a key to "M-<any_mod(s)>-<Return>" using XMonad.Utils.EZConfig
14:38:14 <kraeXen> 2:24:54 PM - kraeXen: so it would register on both: "M-S-<Return>" and "M-C-<Return>" and so forth
14:38:27 <monochrom> And foldl because of sum/product/any/all, etc.
14:39:16 <maerwald> show me a language prelude that cannot split a string
14:39:42 <monochrom> Does C have a prelude? :)
14:39:58 <maerwald> pointer arithmetic 
14:40:04 <maerwald> all you need
14:41:11 <monochrom> When I was young and arrogant, I wrote this post in the CS department-wide forum: If you don't know how to use strtok, you still can't say you know C.
14:42:45 <monochrom> Show me a language that needs a #include just to print "hello". :)
14:43:14 <merijn> maerwald: If "implementing your own split in C using pointers" counts, then "implementing split yourself on lists" counts
14:43:38 <dsal> maerwald: I had to write my own split code when I was writing ocaml back in the day.
14:43:57 <dsal> stdlib had some regex stuff, but it was less exact and about 4x slower than my native splits.
14:44:16 <monochrom> Haha, so why did everyone use Fibonacci instead of split for their language tutorials? :)
14:45:00 <maerwald> C is like dark souls, you're constantly dying inside, haskell is like morrowind... you go to sleep and get woken up by cliff racers
14:45:43 <merijn> Hey now
14:45:49 <merijn> Dark Souls is fair and predictable
14:45:53 <merijn> C is very much not :p
14:46:06 <merijn> Also, Dark Souls is good and C is not :p
14:52:43 <monochrom> C is like C major, it is an unnatural key for almost all instruments, but everyone just assumes that it is the most common key.
14:53:16 <wavemode> ^
14:57:46 <monochrom> Every other key is expressed in terms of adding sharps and flats relative to C major, in the same way every language's FFI is defined relative to C!
14:59:16 <merijn> monochrom: I play guitar and only read tabs nowadays so keys no longer exist ;)
14:59:46 <merijn> I used to be able to read notes, but honestly, notes are a dumb way to transmit guitar information, so I stopped bothering :p
15:15:14 <dsal> I only read midi these days.
15:32:35 <sm[m]> ha.. new haskellers would say haskell is Dark Souls, no ?
15:33:29 <monochrom> For all X,Y, there is always a good reason to say X is like Y. :)
15:33:41 <merijn> Honestly pretty apt, both require you to unlearn a bunch of bad habits that made sense in other contexts that you bring with you going in :p
15:33:42 <dsal> A simile is like a metaphor.
15:33:54 <monochrom> Dark Souls is like Party Hard. There!
15:34:06 <merijn> @quote in.the.category.of
15:34:06 <lambdabot> merijn says: If you have a problem and you think "I know, I'll use lenses!", you now have morphisms in the category of problems :P
15:34:10 <merijn> dammit
15:34:13 <merijn> wrong quote
15:35:10 <sm[m]> there should be an official programming languages to video games mapping
15:36:25 <sm[m]> maybe C is Defender ?
15:36:39 <merijn> @quote dmwit analogies
15:36:39 <lambdabot> dmwit says: analogies are endofunctors in the category of bad explanations
15:36:43 <merijn> That's the one
15:40:42 <monochrom> I wonder if it's an endofunctor, a morphism, or an adjoint pair.
15:41:06 <monochrom> But meh, bad explanations anyway, doesn't need to be right!
15:41:07 <merijn> @quote cale theomorphism
15:41:07 <lambdabot> No quotes for this person. I am sorry.
15:41:13 <merijn> aww, really?
15:41:21 <merijn> But it's in my personal copy of lambdabot's quotes!
15:41:27 <merijn> @quote theomorphism
15:41:28 <lambdabot> Cale says: desrt: Did you hear about the trivial religion that I came up with? Its tenets consist of a single statement: "Believing in this statement will make you happier". It's like a terminal
15:41:28 <lambdabot> object in the category of religions and theomorphisms.
15:41:49 <monochrom> haha you need C not c
15:55:09 <hpc> merijn: reading that statement certainly made me happier :D
15:55:34 <merijn> hpc: :)
15:55:47 <merijn> hpc: It becomes truer and funnier the more you think about it :p
16:01:18 * hackage optics-core 0.3.0.1 - Optics as an abstract interface: core definitions  https://hackage.haskell.org/package/optics-core-0.3.0.1 (arybczak)
16:02:19 * hackage optics-th 0.3.0.1 - Optics construction using TemplateHaskell  https://hackage.haskell.org/package/optics-th-0.3.0.1 (arybczak)
16:13:19 * hackage generic-data 0.9.0.0 - Deriving instances with GHC.Generics and related utilities  https://hackage.haskell.org/package/generic-data-0.9.0.0 (lyxia)
16:15:45 <frdg> is there anyway I can avoid having three layers of case statements and an if statement here? https://dpaste.org/bpRX
16:21:29 <zeta_0> if anyone can help me with this issue that i'm having, thanks in advance: https://www.reddit.com/r/haskell/comments/i4g8bx/help_emacselisphaskell_after_running_einrun_to/
16:22:17 <sm[m]> frdg that doesn't compile, I assume
16:22:31 <dsal> frdg: Well, for one thing, your if just double checks your case.
16:23:06 <frdg> it does compile there is more code after bottom
16:23:15 <dsal> And the 'do' just seems to be in the way.  heh
16:23:51 <sm[m]> I didn't think you could pattern match with  string literals
16:24:38 <frdg> good point the do does nothing
16:25:13 <boxscape> ironic
16:25:25 <frdg> ok I see the redundancy 
16:25:27 <dsal> do doesn't
16:25:42 <boxscape> % do Nothing
16:25:42 <yahb> boxscape: Nothing
16:26:17 <frdg> the reason I have the redundancy is so I can pattern match on the strings though hmm
16:26:34 <dsal> I don't understand how redundancy helps.
16:26:47 <jle`> frdg: you can use guards instead of if/then/elses
16:26:51 <jle`> i find them a little nicer to use
16:27:28 <frdg> ok yes I could get rid of the if/then/else all together
16:27:29 <scarywatermelon> how can I add workspace names to xmobar?
16:27:31 <solonarv_> frdg: case plainCountry loc of "United States" -> ...; "Canada" -> ...; _ -> nonUsTable loc
16:27:42 <solonarv_> no need for the outer 'if'
16:27:49 <jle`> FormSuccess loc
16:27:57 <jle`>   | plainContry loc `elem countiresReqSt -> ...
16:28:26 <jle`> hm. oh i see you do a second match on which of the elements the things are
16:28:36 <jle`> yeah, the 'if' is completely redundent heh
16:30:24 <frdg> ok I majorly improved it thanks
16:31:21 <jle`> frdg: actually reading it again, it looks like the two branches of the case are identical
16:31:27 <jle`> so you can keep the 'if' and remove the inner case
16:31:43 <jle`> s/keep the 'if'/use a guard
16:34:54 <frdg> If I just get rid of the `global local variable` countriesReqSt then everything works out much nicer.
16:35:10 <frdg> what is a better name than `global local variable`?
16:35:25 <jle`> it looks like in this case it's not a variable, just a binding/alias
16:35:46 <jle`> or definition?
17:03:45 <koz_> Is there something like minOn?
17:04:05 <koz_> So like, (Ord b) => (a -> b) -> b -> b -> b
17:05:02 <monochrom> It is under the other name "argmin" or "argmin".
17:05:30 <koz_> monochrom: Wait, 'argmin' or 'argmin'?
17:05:34 <ski> @type minimumBy . comparing
17:05:35 <lambdabot> (Foldable t, Ord a1) => (a2 -> a1) -> t a2 -> a2
17:06:00 <solonarv_> koz_: did you mean Ord b => (a -> b) -> a -> a -> a ?
17:06:33 <monochrom> err haha my typo
17:06:36 <koz_> solonarv_: I actually sought (Ord b) => (a -> b) -> a -> a -> b
17:06:50 <solonarv_> oh yes that could work too
17:07:04 <solonarv_> but that is just \f -> min `on` f
17:07:08 <solonarv_> (or max, w/e)
17:07:10 <kupi> hi I am reading learn you a haskell and I don't understand this part: "Note: We can use the let keyword to define a name right in GHCI. Doing let a = 1 inside GHCI is the equivalent of writing a = 1 in a script and then loading it."
17:07:12 <koz_> Oh, nice.
17:07:33 <kupi> a = 1 doesn't already load a?
17:07:36 <jle`> kupi: that book is actually a little out of date there, 'a = 1' in ghci and in a script/file should be the same now
17:07:44 <monochrom> In Data.Semigroup there is an Arg type that intended to be used with Min: Min (Arg a b) and can solve an equivalent problem.
17:07:46 <koz_> @src on
17:07:46 <lambdabot> (*) `on` f = \x y -> f x * f y
17:07:49 <jle`> kupi: ah, there the book is talking about loading the script
17:07:54 <jle`> not loading the 'a'
17:07:56 <koz_> @info on
17:07:56 <lambdabot> on
17:08:02 <jle`> nice
17:08:04 <shachaf> The book isn't saying anything false.
17:08:07 <ski> @index on
17:08:07 <lambdabot> Data.Function
17:08:12 <solonarv_> basically, you *used to* need let in ghci, you don't anymore (but it still works)
17:08:39 <kupi> but that book declares names without let too
17:08:46 * ski still uses `let' in the interactor
17:09:07 <jle`> ah yeah, the book is still correct there.
17:09:09 <monochrom> kupi: We say "load" a file, not "load" a variable/name/def/whatever.  writing a = 1 in a script and then loading that script (file)
17:10:03 <kupi> does this statement true? "Doing a = 1 inside GHCI is the equivalent of writing a = 1 in a script and then loading it."
17:10:16 <jle`> yes, but it means loading the script
17:10:18 <jle`> not loading the 'a'
17:10:29 <jle`> the "it" refers to 'a script', not "a = 1"
17:10:41 <monochrom> This is why pronouns must be banned.
17:11:02 <koz_> monochrom: Yep, so we can all talk like Japanese 12-year-olds.
17:11:05 <monochrom> Use definitions and identifiers instead.
17:11:08 <jle`> "Doing a = 1 inside GHCI is the equivalent of writing a = 1 in a script and then loading the script"
17:11:39 <monochrom> Define foo = the problem with LYAH using "it" causing a truckload of confusion.
17:11:50 <monochrom> foo is why pronouns must be banned. There!
17:11:52 <jle`> monochrom: and then load it?
17:11:57 <monochrom> haha
17:12:19 * hackage functor-combinators 0.3.0.0 - Tools for functor combinator-based program design  https://hackage.haskell.org/package/functor-combinators-0.3.0.0 (jle)
17:12:40 <monochrom> Yeah, it's a truckload, someone has to load it on to the truck I guess.
17:13:23 <kupi> i still don't get the difference between let a = 1 and a = 1
17:14:07 <jle`> in ghci there is no difference for the most part
17:14:14 <monochrom> You can eliminate that question by using the fact that, in today's ghci, you don't need the "let" there.
17:14:22 <jle`> except for let triggers multiline stuff, if you have that enabled
17:14:39 <jle`> however, in a haskell ".hs" file, you can't use 'let' at the top level to make bindings/names
17:15:04 <monochrom> In very old ghci (the time LYAH was written), it was required, but the reason was a long story that really makes no sense.
17:15:12 <jle`> so if you have a haskell file or script, 'let a = 1' on a line on its own is not allowed
17:15:12 <ski> (or eliminate the question, by always using `let' for bindings, in the interactor)
17:15:38 <monochrom> But really I hope every programmer learns Chess before learning programming.
17:16:01 <monochrom> Because that's how you realize how to learn a bunch of rules most productively.
17:16:22 <kupi> Thanks, now I get it. conanO'Brien = "It's a-me, Conan O'Brien!" confused me because I thought it worked on GHCI.
17:16:26 <ski> (or Go ?)
17:16:37 <monochrom> If someone says: a pawn's first move can be 1 or 2 steps forward, up to you; but afterwards it's only 1 step forward.
17:17:09 <jle`> kupi: it does work in ghci now, and that's a legal top-level binding in a haskell file.  but at the time the book was written, it wasn't allowed in ghci
17:17:14 <monochrom> YOU DON'T GO "BUT WHY???!!!! WHAT'S THE DIFFERENCE???!!! I DON'T UNDERSTAND!!!!!"
17:17:20 <ski> you can't leave chess pieces in indeterminate states, after a move ?
17:17:28 <monochrom> There is nothing to understand. It's a rule.
17:18:13 <solonarv_> ski: you could probably wrangle that into a nobel prize in physics or two :p
17:18:14 * ski . o O ( "Where did you move that rook ?","Oh, either here, or there." )
17:18:41 <monochrom> And nevermind the eventual oddity about pawns hitting the other bottomline and how the hell does anyone remember its new identity.
17:19:21 * ski mumbles something about angels and demons
17:20:32 <ski> are you allowed to replace the pawn with a pawn, there ?
17:20:58 <ski> (and do you then get to choose again ?)
17:32:21 <kupi> ski: BUT WHY???!!!! WHAT'S THE DIFFERENCE???!!!
17:32:43 <ski> ?
17:32:56 <monochrom> haha
17:33:32 <kupi> it was my attempt at being funny (was a reply to your last message)
17:52:11 <koz_> Schrodinger's Chess Move.
17:52:39 <monochrom> Have you heard of Quantum Werewolf? :)
17:53:24 <monochrom> (It will be a bit disappointing because it's merely Stochastic Werewolf. Classical 0<=p<=1 probabilities. No complex numbers.)
18:10:15 <koz_> :t minimumBy
18:10:17 <lambdabot> Foldable t => (a -> a -> Ordering) -> t a -> a
18:10:23 <koz_> :t minimum
18:10:25 <lambdabot> (Foldable t, Ord a) => t a -> a
18:15:06 <sshine> monochrom, one difference between learning chess and learning programming is that you typically don't learn programming by iterating the axioms, but rather go by high-level examples where the "public static void main"-ness is saved for later. whereas with chess, you don't get to strategies until the basics are covered. :) I mean, I've learned languages by reading manuals, but I don't do that any more.
18:16:56 <sshine> ski, apparently, my colleagues can leave chess in indeterminate states after a move. the trick is to set your chess clock at 2 minutes.
18:17:04 <sshine> s/chess/chess pieces/
18:17:42 <ski> how does that work ?
18:18:36 <sshine> it's lightning chess :) 3+2 or 2+1 (being N minutes total + M seconds reward per move). /me manages to lose with grace at 3+2 games, but 2+1 is just a random bloodbath.
18:18:57 <sshine> people tend to be really bad at placing pieces in the middle of squares at that pace, is my experience.
18:21:20 <ski> mhm
19:12:48 <fog> is "Var" not considered to be part of lambda calculus?
19:15:28 <fog> it says here; http://homepages.inf.ed.ac.uk/slindley/papers/unembedding.pdf
19:15:35 <fog> It is not intended that the Var constructor be used in user programs. The problem with this representation is that it permits so-called exotic terms, members of the type that are not representatives of λ-calculus terms
19:17:38 <fog> is that kind of like, not having magic numbers in the scope of a function implementaion? 
19:22:42 <lemmih> Cabal question: I have a package with a data file. I install this package with 'cabal v2-install --lib'. The data file is record as being stored in ~/.cabal/share/.../data.file but it is not there. How do I tell cabal to actually install my data files?
19:23:22 <fog> what is this "data.file" ?
19:24:31 <c_wraith> lemmih: how are you determining the data file location?
19:24:42 <lemmih> It's a file with data in it. Listed under 'data-files' in my cabal file.
19:25:06 <lemmih> c_wraith: 'getDataFileName' from the autogenerated Paths module.
19:27:39 <fog> why does it end up there? seems like you would want it around your source code... or is it to do with installing from hackage, like, where else would it put it then? i guess there is a flag to specify where it should go?
19:28:04 <c_wraith> it's just part of how cabal installs the package
19:28:05 <lemmih> fog: See https://cabal.readthedocs.io/en/3.4/cabal-package.html?highlight=data%20files#accessing-data-files-from-package-code
19:28:11 <fog> thanks
19:30:38 <fog> "For example, the configured data directory for pretty-show is controlled with the pretty_show_datadir environment variable."
19:31:48 <fog> have you tried using this to get it to place the datadir somewhere else?
19:32:40 <fog> or is it something to do with the --lib argument? like how this is for "not building exes"... maybe it also doesnt make the data? 
19:33:05 <fog> thinking of the "you asked to build exes, did you mean to use --lib" error
19:33:11 <lemmih> Ideally I don't want to manually install my data files. This is something cabal-install usually did.
19:34:31 <fog> yeah, v1-install would normally do --lib, in that it would make a global install. but idk if it actually does the data building aswell.. actually, i know practically nothing about Cabal, and definatly someone else should interject at this point
19:35:33 <fog> did you try it without --lib to see if it builds the data?
19:36:11 <fog> just thinking of how you could figure out what its doing without actually understanding how it works at all...
19:37:59 <lemmih> fog: Well, it doesn't install anything without --lib.
19:38:23 <fog> oh, i thought it at least built the exes, as the error suggests it might
19:39:16 <fog> not sure if there is a distinction between exes for testing and as main
19:39:17 <lemmih> fog: I don't have any executables.
19:39:39 <fog> right, but clearly --lib is limiting what it produces
19:39:52 <fog> just thought it could also be limiting the production of the data.file
20:29:18 * hackage hstatistics 0.3.1 - Statistics  https://hackage.haskell.org/package/hstatistics-0.3.1 (VivianMcPhail)
20:32:52 <iqubic> What's the difference between boxed and unboxed data, as it relates to Vectors?
20:40:08 <lemmih> iqubic: A vector of boxed ints is a vector of pointers to heap allocated ints. An vector of unboxed ints is literally an array of ints.
20:40:08 <sm[m]> lemmih, maybe embedding the file in your executable is an option ?
20:40:24 <iqubic> lemmih: Which is better?
20:40:48 <lemmih> iqubic: It's usually better to unbox your data when you can.
20:40:57 <iqubic> Cool.
20:41:24 <iqubic> If I have a function of type Int -> Int, can I feed it unboxed values?
20:42:09 <lemmih> iqubic: GHC will take care of it for you. Usually you don't have to worry about it.
20:42:38 <iqubic> map :: (Unbox a, Unbox b) => (a -> b) -> Vector a -> Vector b
20:43:11 <iqubic> So, I can use that even if the function (a -> b) doesn't explicitly take or return unboxed values?
20:43:56 <lemmih> iqubic: If 'a' and 'b' are Unboxable, sure.
20:44:03 <iqubic> Cool.
20:44:07 <lemmih> iqubic: Your code won't compile if they aren't.
20:44:18 <iqubic> Right. I understand.
20:45:57 <iqubic> What's an unlifted literal?
20:46:42 <iqubic> Like the kind that Magic Hash allows.
20:49:49 * hackage apply-refact 0.8.2.1 - Perform refactorings specified by the refact library.  https://hackage.haskell.org/package/apply-refact-0.8.2.1 (zliu41)
20:50:25 <jle`> iqubic: the Unbox typeclass is an abstraction over how to access/interpret the actual bytes ini the unboxed vector
20:50:59 <jle`> so map :: (Unbox a, Unbox b) => (a -> b) -> Vector a -> Vector b, a and by are still technically lifted types there
20:51:26 <jle`> but the Unbox typeclass lets the implementation of 'map' work with the raw unboxed direct bytes in the memory array
20:52:38 <jle`> for example U.Vector Bool is a data family instance that is an array of Word8's in memory
20:52:54 <jle`> and Unbox Bool tells the implementation how it's supposed to treat those Word8's as Bools
20:54:07 <sshine> iqubic, https://github.com/ollef/sixten <- here's a language similar to Haskell that addresses boxed types in an explicit way.
20:55:29 <iqubic> Is there a type class/data type that will let me write my code in such a way that I can use either boxed, or unboxed vectors?
20:55:42 <jle`> yeah, there's Data.Vector.Generic
20:55:49 <jle`> the module
20:57:02 <iqubic> Oh. Cool. That also lets me feed MVectors into my functions too. Cool.
20:59:57 <iqubic> I think I do want to write this code using the generic API so that I can easily optimize the code later.
21:01:16 <iqubic> sshine: Not only does sixten have all data unboxed by default, it also has dependent types. That's wild.
21:01:57 <sshine> iqubic, yeah, that part blew my mind a bit, too, considering it's mostly one guy. :)
21:03:18 <lemmih> sm[m]: That might be a good option. Will also make it easier to compile to JavaScript.
21:05:02 <sshine> hi lemmih :)
21:44:07 <indian_yogi> hello every1
21:44:15 <indian_yogi> how is everybody
22:09:27 <lemmih> sshine: Hey you. Thank you for all your support. You're contribution is funding the server that will soon run a javascript compiler for reanimate.
22:11:13 <lemmih> s/You're/Your/
22:12:20 <indian_yogi> i'm new to programming
22:13:02 <indian_yogi> want to know how to learn haskell, it seems difficult at first
22:15:24 <lemmih> indian_yogi: It's worth it, though. Learning requires struggle but always ask for help when you get stuck.
22:27:27 <dminuoso> indian_yogi: Haskell is not difficult out of being difficult. It's rather that learning is closer to learning programming from beginning anew.
22:27:53 <dminuoso> It requires unlearning and approaching things as if you've never done programming frequently. And that might give the impression of "hard" because trivial problems seem hard to solve.
22:28:13 <dminuoso> If you have been programming for a while, you might have forgotten how hard the first programming language(s) might have been
22:29:19 <parsnip> i still find OOP very painful
22:29:32 <jackdk> does anyone have any recommendations for an alternative to `containers` where I can pass custom comparison functions instead of relying on the `Ord` instance of the elements? I do not want to add strange instances to my types.
22:29:44 <parsnip> i wonder if some people truly do find OOP or FP easier to learn
22:30:13 <parsnip> (sorry, kinda off-topic)
22:30:26 <indian_yogi> dminuoso: i'm new to programming, can i learn it fairly? i already know c programming though
22:30:45 <jackdk> I have seen people with no prior programming experience do well in haskell courses
22:31:17 <parsnip> i don't understand programming and OOP very well, but i really enjoyed my time in haskell
22:31:26 <sm[m]> lemmih: file-embed is good
22:31:32 <parsnip> referential transparency, terseness, etc
22:32:28 <koz_> jackdk: Is Hashable a strange instance? If not, then unordered-containers might work.
22:35:39 <jackdk> koz_: still kinda the same problem - I want to have the containers only care about the id field of a record
22:35:59 <koz_> Use a (Hash)Map keyed by said id?
22:36:11 <jackdk> but I don't want to stand up a cheeky Ord instance or whatever that's a bit suss
22:38:53 <jackdk> there's an obvious problem with ensuring that you use a common equality or comparison function on the sets, but perhaps there's something out there that's done an ST-style thing to track this??
22:41:46 <jle`> jackdk: are you talking about, say, reference equality?
22:41:50 * hackage reanimate-svg 0.10.1.0 - SVG file loader and serializer  https://hackage.haskell.org/package/reanimate-svg-0.10.1.0 (DavidHimmelstrup)
22:42:02 <jle`> equality is a weird thing
22:43:18 <c_wraith> if your needs are able to be locally-scoped, you might get away with using the reflection package to create a local Ord instance
22:44:01 <jackdk> I have records that contain an id, and a Set of those records that's mocking a DB. so if I put something in that set with id = 42, I want it to replace any existing member with id = 42 even if other fields differ.
22:45:00 <jackdk> Implementing the set as a HashMap from the Id to the record (as koz_ suggested) might be the easier thing.
22:50:57 <jtm> Hello! I am having troubles understanding why eval x >>= \n works in this code: https://pastebin.com/isjuj9zD
22:51:39 <dibblego> jtm: (>>=) has many types, one of which is :: Maybe x -> (x -> Maybe y) -> Maybe y
22:52:03 <jtm> Wouldn't eval x >>= \n where eval x is Just x result in (\n) x
22:52:13 <jtm> Which isn't that an Int and not a Maybe?
22:52:21 <c_wraith> that's not a valid expression
22:52:24 <jtm> I know it isn't
22:52:34 <dibblego> eval x :: Maybe Int
22:52:41 <jtm> (\n -> n) 5
22:52:50 <jtm> where x = 5
22:53:19 <jtm> Well I'm going based on (>>=) returning Maybe b
22:53:38 <dibblego> yeah, and its arguments appearing on each side
22:53:52 <jtm> If the function it is getting is (\n) (which seems like that would be (\n -> n)) then how is it even  valid?
22:54:07 <dibblego> why does it seem this way? the code looks quite different to that
22:54:26 <jtm> Because it is doing eval x >>= \n ->
22:54:33 <jtm> then eval y >>= \m ->
22:54:37 <c_wraith> you do really that the expression continues on the next line, right?
22:54:40 <dibblego> it's doing more than that
22:54:40 <jtm> And taking those results and feeding them into safediv
22:54:57 <dibblego> eval x >>= \n -> there is stuff here
22:55:10 <jtm> yeah it's multiple lines
22:55:14 <jtm> But they are connected
22:55:16 <dibblego> yes
22:55:23 <c_wraith> but you're ignoring that the next line *is important*
22:55:28 <dibblego> "there is stuff here" <-- this bit is quite relevant
22:55:29 <jle`> also note the parentheses
22:55:33 <jle`> er, the association
22:55:41 <jle`> it might help to draw out the parentheses explicitly
22:55:42 <jtm> I'm just not sure how the Monad is working here.
22:55:59 <jtm> Is it treating safediv as the f ?
22:56:00 <jle`> eval x >>= (\n -> eval y >>= (\m -> savediv n m))
22:56:08 <dibblego> see if this helps https://pastebin.com/hidn8U7L
22:56:39 <jtm> Associated right?
22:56:50 <jle`> yes, you're right
22:56:52 <jle`> it's associated
22:57:08 <jtm> Isn't left normal for monads?
22:57:30 <jle`> this isn't really a monad thing, it's just syntax for lambdas
22:58:00 <jle`> so the association rules are the same for any operator with a lambda
22:58:15 <c_wraith> I mean, fixity declarations don't even come into play
22:58:18 <jle`> doesn't have anything to do with monads necessarily
22:58:28 <c_wraith> It's just that lambdas bodies extend as far as possible
22:58:29 <jle`> the parentheses are just how the AST is parsed
22:58:30 <jtm> I'm just wondering how exactly this is getting applied. What is being passed into >>= as the function and the Maybe.
22:58:41 <jle`> eval x >>= (\n -> eval y >>= (\m -> savediv n m))
22:58:48 <dibblego> exactly as above
22:58:49 <jle`> in this case the top level >>= is being given two arguments
22:58:52 <jle`> "eval x"
22:59:01 <jle`> and "\n -> eval y >>= (\m -> safediv n m)"
22:59:16 <jle`> here's the definition of >>= for Maybe:
22:59:19 <jle`> Nothing >>= _ = Nothing
22:59:25 <jle`> Just x >>= f = f x
22:59:38 <jle`> so, you can try stepping through an evaluation of those >>='s for some sample input
22:59:42 <jtm> Ok I think I may understand
22:59:44 <jle`> for example, what if 'eval x' is Nothing?
22:59:50 <jle`> then you'd have Nothing >>= (\n -> ....)
22:59:59 <jle`> and we can see from the definition that `Nothing >>= _ = Nothing`
23:00:13 <jle`> so if 'eval x' is Nothing, then we have Nothing >>= (\n ...), which is Nothing
23:00:22 <jtm> (\n -> eval y) is actually the function being used
23:00:24 <jtm> Right?
23:00:29 <jle`> no
23:00:32 <jtm> well I know it's more than that
23:00:38 <jle`> it's (\n -> eval y >>= (\m -> safediv n m))
23:01:08 <jtm> so eval y >>= (\m -> safediv n m) ?
23:01:13 <jtm> I'm trying to see what applies first
23:01:20 <jle`> er, was that a question?
23:01:22 <jle`> sorry
23:01:44 <jle`> we can walk through another sample application.  what if 'eval x' was `Just 1`?
23:01:57 <jle`> then we have Just 1 >>= (\n -> eval y >>= (\m -> savediv n m))
23:02:04 <jtm> Then Just 1 >>= (\n....)
23:02:09 <jle`> and if we look at the definition of >>= for Maybe, we see `Just x >>= f = f x`
23:02:20 <jle`> so that means that Just 1 >>= (\n -> ...) is (\n -> ...) 1
23:02:34 <jle`> so that becumes (\n -> eval y >>= (\m -> safediv n m)) 1
23:02:42 <jle`> and now we can apply the lambda ....
23:02:53 <jle`> and it becomes `eval y >>= \m -> safediv 1 m`
23:03:14 <jle`> now, what if `eval y` is `Nothing`?
23:03:14 <jtm> It binds to n?
23:03:21 <jle`> ah yeah, that's how lambdas work
23:03:26 <jle`> > (\x -> x * 2) 10
23:03:27 <lambdabot>  20
23:03:35 <jtm> Ok I see
23:03:38 <jle`> basically it takes the argument and replaces every occurence of the binding with the argument
23:03:50 <jle`> so here, (\x -> x * 2) 10, it takes 10 and replaces every occurence of 'x' with 10
23:04:04 <jtm> I didn't know about this: "Just 1 >>= (\n -> ...) is (\n -> ...) 1"
23:04:18 <jtm> Didn't know that's what happens here
23:04:37 <jle`> ah yeah, to know that you have to look at the definition of >>= for Maybe
23:04:40 <jtm> if eval y is nothing then m becomes Nothing
23:04:51 <c_wraith> No, it doesn't
23:04:58 <c_wraith> if eval y is Nothing, m never exists
23:05:00 <jle`> and the definition of >>= for maybe is `Just x >>= f` is replaced with `f x`
23:05:09 <jle`> if eval y is Nothing, then we get Nothing >>= (\m -> safediv 1 m)
23:05:20 <jle`> and then we look up the definition of >>= again...
23:05:23 <jle`> Nothing >>= _ = Nothing
23:05:28 <jle`> so Nothing >>= (anything) = Nothing
23:05:35 <jle`> so Nothing >>= (\m -> safediv 1 m) is Nothing
23:05:48 <jle`> the function on the right hand side is ignored completely
23:05:52 <jtm> So it doesn't even bother to make \m into Nothing
23:06:35 <jtm> Wait I do know the definition and yes you are right about that.
23:06:47 <jtm> See I don't know which functions are being passed around, but I think I see now.
23:06:50 <jle`> ultimately remember that there is nothing magical going on here
23:06:55 <jle`> it's just normal function application
23:07:10 <jle`> and like everything else in haskell, you figure it out by just substituting in the definitions
23:07:12 <jtm> I thought it was passing \n as a function which was shorthand for (\n -> n)
23:07:23 <jle`> if you know the definition of >>=, then you know how to step through it
23:07:40 <jtm> I was looking at eval x >>= \n this way
23:07:47 <jtm> ignoring the -> and beyond
23:08:04 <jtm> Thinking it was taking eval x (assume it is Just x) and \n as (\n -> n) for a function
23:08:22 <jle`> ah no, yeah.  that is why re wrote the parentheses earlier
23:08:25 <jtm> And for me that made no sense
23:08:37 <jle`> eval x >>= (\n -> eval y >>= (\m -> savediv n m))
23:08:45 <jle`> the first argument on the right hand side is 'eval x'
23:08:59 <jle`> the second argument on the left hand side is (\n -> eval y >>= (\m -> safediv n m))
23:09:23 <jle`> not (\n -> n)
23:09:49 <jle`> maybe to be clearer, it's (\n -> (eval y >>= (\m -> (safediv n m))))
23:09:50 <jtm> I think I didn't know that you could write \n -> eval y  ...without doing (\n -> eval y ....)
23:10:18 <jle`> you mean, without the parentheses?
23:10:21 <jtm> I honestly thought this was a new type of notiation
23:10:23 <jtm> notation*
23:10:24 <jtm> Yeah
23:10:27 <jle`> ah yeah
23:10:36 <jtm> I thought it was like feeding the results into each other
23:10:44 <jle`> nothing new here, just normal function application and lamda syntax :)
23:10:47 <jtm> The way it was line by line
23:10:59 <jtm> I thought it computed the first line and fed it into the second line
23:11:10 <jtm> and then computed the second line and fed it into safediv
23:11:19 <jtm> Where n and m were assigned values
23:11:32 <jtm> from this "feeding"
23:11:43 <jtm> Seeing it as a lamda makes it clear :)
23:11:47 <jle`> ah yeah, the line breaks are a distraction maybe
23:11:52 <jtm> They are
23:11:58 <jtm> That's why I was confused
23:12:23 <jtm> If it was 1 line maybe I would have realized it was a lambda
23:13:16 <jtm> The book even says: "The case for division states that we first evaluate x and call its result value n, then evaluate y and call its result value m, and finally combined the two results by applying safediv"
23:13:27 <jtm> Which is EXACTLY why I thought it was applied that way
23:14:25 <jtm> Then it shows that this is the same as doing do n <- eval x  ...
23:14:55 <c_wraith> that's not a coincidence.  that's the definition of do-notation
23:15:15 <jtm> Yeah they said it was
23:15:23 <jtm> That you can do <- with Monads
23:15:45 <jtm> I don't exactly know how that works then
23:16:20 <c_wraith> it's just an internal rewriting to the exact same code
23:16:34 <c_wraith> literally *exactly*
23:16:40 <jtm> yeah it's just not exactly clear, I understand it translates it into that
23:17:00 <jtm> But like what if what is between those n <- eval x is something completely unrelated?
23:17:22 <jtm> Internally I don't know exactly what is going on
23:17:26 <c_wraith> then it'd desugar it, and it would either type-check or not
23:17:35 <c_wraith> https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-470003.14  the exact rules for desugaring do notation
23:18:17 <dibblego> to put it back in, https://github.com/system-f/fp-course/blob/master/README.markdown#do-notation
23:18:59 <jtm> Is >> without the = a typo or another operator?
23:19:07 <dibblego> another operator
23:19:17 <jtm> Ah ok, I'll look that one up
23:19:53 <jtm>  :t (>>)
23:20:12 <dibblego> :t (>>)
23:20:13 <lambdabot> Monad m => m a -> m b -> m b
23:22:10 <jtm> I guess it just becomes a big cluster of deeper level lambdas with the >>= operator.
23:22:34 <jtm> With each additional line in do going to another depth level
23:22:51 <c_wraith> well.  each line with a <- in it
23:23:04 <jtm> Yeah, ignoring the lets
23:23:33 <jtm> And whatever else is allowed.
23:23:55 <jtm> I'm obviously still learning, but just want to make sure I fully understand before continuing etc
23:24:40 <jtm> Thank you everyone.
23:25:03 <dminuoso> jtm: There's a way to write it with >>= without making the nested lambdas apparent
23:25:20 <jtm> dminuoso How so?
23:26:09 <dibblego> safediv <$> eval x <*> eval y
23:26:19 <dminuoso> jtm: https://gist.github.com/dminuoso/24af81c2c1dadabdb2d1968c605f32ce
23:26:42 <c_wraith> doesn't that need a join?
23:26:49 <jtm> Isn't that just an applicative? with pure being used on safediv?
23:27:05 <dminuoso> jtm: The fixity works out just fine this way, similarly how 1:2:3:[] is fine without the nested parens.
23:27:07 <dibblego> wait, disregard that
23:27:14 <dibblego> applicative will not work
23:27:51 <jtm> dminuoso Using the do notation is the solution to avoid using lambdas, we were discussing that.
23:28:11 <dminuoso> jtm: well it doesnt really avoid them, it just hides them behind the desugarer.
23:28:26 <jtm> Yeah, it's syntactic sugar.
23:28:47 <jtm> Is <- also called bind?
23:29:09 <dminuoso> jtm: You can call it that informally, if you like
23:29:23 <jtm> What is it normally called?
23:29:41 <jtm> I thought I heard it called bind, which is exactly what >>= is
23:30:17 <dminuoso> I have not heard a name for it
23:30:25 <dminuoso> But calling it bind is perfectly fine
23:30:31 <jtm> Ah ok
23:30:35 <dminuoso> Since that's what it desugars into anyhow
23:30:44 <jtm> Yes.
23:30:47 <jtm> Thank you :)
23:31:08 <jtm> I guess I should go deeper, not that I realize that this was just lambda sugar.
23:31:20 <sshine> I call it left-pointy arrow. it is rarely that I speak of it. :)
23:31:56 <sshine> jtm, this page explains a bit: https://en.wikibooks.org/wiki/Haskell/do_notation
23:33:00 <dminuoso> jtm: Just as a side note, there's strictly speaking slightly more going on than desugaring into uses of >>= and >>, because you can write patterns in do-notation. i.e. `Foo f <- g`, and that does not desugar into `g >>= \(Foo f) -> ...` as you might expect naively.
23:33:48 <dminuoso> @undo do { Foo f <- g; pure f }
23:33:48 <lambdabot> g >>= \ a -> case a of { Foo f -> pure f; _ -> fail ""}
23:33:58 <sshine> :o
23:34:04 <jtm> Final clarifying question, if we have: Just 1 >>= (\n -> eval y >>= (\m -> savediv n m))    How does (\n -> eval y >>= (\m -> savediv n m)) satisfy the Maybe b requirement of the Maybe monad definition?
23:34:47 <jtm> I mean
23:34:57 <jtm>  (\n -> eval y >>= (\m -> savediv n m)) applied to 1
23:35:25 <dminuoso> jtm: You are not applying that directly.
23:36:44 <jtm> Maybe x -> (x -> Maybe y) -> Maybe y   has a case of Just x  which does f x
23:37:13 <dminuoso> jtm: The important realization is this:
23:37:15 <jtm> Doesn't f x do    (\n -> eval y >>= (\m -> savediv n m)) 1
23:37:18 <dminuoso> % (>>=)
23:37:18 <yahb> dminuoso: ; <interactive>:49:1: error:; * No instance for (Show (m0 a0 -> (a0 -> m0 b0) -> m0 b0)) arising from a use of `print'; (maybe you haven't applied a function to enough arguments?); * In a stmt of an interactive GHCi command: print it
23:37:21 <dminuoso> % :t (>>=)
23:37:21 <yahb> dminuoso: Monad m => m a -> (a -> m b) -> m b
23:37:38 <sshine> > let safeDiv x y = if y == 0 then Nothing else Just (x `div` y) in Just 0 >>= (\n -> safeDiv 1 n)
23:37:39 <dminuoso> If we set `m` to Maybe, then applying (>>=) to *two* arguments you get a `Maybe b` back
23:37:40 <lambdabot>  Nothing
23:37:47 <dminuoso> So if we zoom out, we get:
23:38:27 <dminuoso> (\n -> <lexpr> >>= <rexpr>), we dont even need to know what lexpr and rexpr are!
23:38:42 <jtm> Yes
23:39:02 <jtm> So it needs to fully evaluate those before it can return from the first Monad?
23:39:11 <dminuoso> Why would it?
23:40:08 <jtm> It just knows it's going to be a Maybe ?
23:40:18 <dminuoso> It infers that.
23:40:34 <dminuoso> Let me present you with a simpler example:
23:40:34 <jtm> Impressive
23:40:39 <dminuoso> Assume you have f :: Int -> Char
23:40:41 <dminuoso> And x :: Int
23:40:49 <sshine> :t let safeDiv x y = if y == 0 then Nothing else Just (x `div` y) in safeDiv
23:40:51 <lambdabot> Integral a => a -> a -> Maybe a
23:40:54 <dminuoso> Then the compiler is completely free to assume that `f x :: Char` by means of a type inference rule
23:41:05 <dminuoso> jtm: ^- does that make sense?
23:41:12 <jtm> Yes
23:41:21 <jtm> I understand it does that all the time
23:41:24 <dminuoso> It doesnt have to evalute that to figure it out, that's the entire point of a type system. :)
23:41:29 <dminuoso> We can infer it statically
23:41:34 <dminuoso> Equivalently
23:41:44 <dminuoso> If we see `f x`, we can *infer* that x *must* be of type Int.
23:41:45 <jtm> I just find it interesting that it knows that the end result is going to end up being a Maybe
23:41:52 <jtm> for the other example
23:41:53 <dminuoso> Even if we dont know this a priori, we can infer that fact.
23:42:11 <dminuoso> (And if we found a conflicting type for x later on, the type checker would error out then)
23:42:43 <jtm> Yes, if we defined f x with f taking x as an Int and returning a Char
23:43:26 <jtm> That's why we probably can cons it to a [Char]
23:43:51 <sshine> jtm, https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system#The_Hindley%E2%80%93Milner_type_system gives an intro to the kind of type system Haskell's is based on. :)
23:43:56 <jtm> (f x) : ['a', 'b']
23:44:10 <dminuoso> jtm: Indeed!
23:44:18 <dminuoso> The type checker would have a few things to look at:
23:44:19 <jtm> Since it knows it must be a Char
23:44:22 <dminuoso> It would see that 
23:44:24 <dminuoso> % :t (:)
23:44:24 <yahb> dminuoso: a -> [a] -> [a]
23:45:21 <jtm> I just find it impressive it knows that a Maybe it being used in  (\n -> eval y >>= (\m -> savediv n m)) ,  but I'm guessing that due to it looking at the definition of eval or the definition of safediv?
23:45:31 <dminuoso> Very handwavingly and imprecisely: It would see that its right hand side is [Char], it could then assume that `a ~ Char`, and then it knows the left hand side *must* be Char. The definition of `f` agrees with that, since `f applied to one argument gives a Char back`. It would also know that `x must be Int`. And so forth.
23:45:47 <dminuoso> Note that I say handwavingly because it's a but more subtle and more principled, but maybe as a very rough intuitoin
23:45:48 <dibblego> it's because of the way you use it, no different sort [1,2,3] knows you just gave it numbers
23:46:03 <dminuoso> jtm: *all* of them
23:46:20 <jtm> All must be true to not have an error.
23:46:57 <dminuoso> jtm: Essentially, it doesnt even matter where the type checker begins.
23:47:01 <jtm> So I guess  it is pretty smart on knowing what lambda inside lambdas are going to return etc
23:47:04 <sshine> jtm, it doesn't necessarily know that that expression uses Maybe; that depends on 'eval' and 'savediv'. you can have generic monadic expressions, like...
23:47:13 <sshine> > Just 5 >>= (\n -> pure (n * 5))
23:47:15 <lambdabot>  Just 25
23:47:20 <sshine> > [1,2,3] >>= (\n -> pure (n * 5))
23:47:22 <lambdabot>  [5,10,15]
23:47:40 <sshine> :t (\n -> pure (n * 5))
23:47:41 <lambdabot> (Applicative f, Num a) => a -> f a
23:48:01 <dminuoso> It can infer things early on. Say it can infer some expression to have type `Foo`. If then however a type signature is found that pins this to `Bar`, you'd get something like `Expected type Foo, actual type Bar` from the type cherk
23:48:10 <jtm> But since it is inside the Maybe Monad is needs to have a function that eventually returns a Maybe
23:48:36 <dminuoso> jtm: Lets, for the sake of argument, replace >>= with something fully monomorphized.
23:48:57 <lpyfist> that was an image i pasted on accident, sorry
23:48:57 <dminuoso> call it `thenMaybeInt :: Maybe Int -> (Int -> Maybe Int) -> Maybe Int`
23:49:30 <jtm> Yes.
23:49:43 <jtm> So instead of generic a, you are using Int
23:50:15 <dminuoso> Use that instead of >>=, and you'd see everything works out. 
23:50:34 <dminuoso> (Maybe fix the type for what you actually have)
23:50:46 <jtm> Yeah because eveything is a Maybe Int or Int
23:52:37 <jtm> What I'm wondering is when it gets to the Monad part of  Just x -> f x and f is  (\n -> eval y >>= (\m -> savediv n m))  and x is 1,  is it waiting for eval y to finish while binding n to 1?
23:53:05 <jtm> which eval y then waits for safediv n m to finish?
23:53:16 <jtm> (\m -> safediv n m)
23:53:55 <dminuoso> Ah mm I see.
23:54:04 <jtm> And if yes, how does it have access to y? I'm guessing it replaces y earlier on inside eval (Div x y) ?
23:54:21 <jtm> with the appropriate value
23:54:30 <jtm> so lets say x is 1 and y is 5
23:54:33 <dminuoso> Im not well equipped to explain how evaluation works here to you. Perhaps someone else can?
23:54:39 <jtm> it is actually doing  (\n -> eval 5 >>= (\m -> savediv n m)) 
23:54:53 <dminuoso> (I wouldn't know how to start pedagogically)
23:54:59 <jtm>  (\n -> eval 5 >>= (\m -> savediv n m)) 1  (for the full picture)
23:55:34 <dminuoso> jtm: ah maybe I have an idea:
23:55:41 <dminuoso> Replace all functions by their definitoin
23:55:47 <dminuoso> And that's it.
23:56:18 <jtm> then it goes into eval 5, which then goes into another maybe with something like    (\m -> savediv 1 m) 5
23:56:59 <jtm> eval 5 being actually eval Just 5
23:57:11 <jtm> I'm guessing it just kinda recurses
23:57:32 <dminuoso> The reason I suggest that, is beause evaluation has no defined order. It's driven by need. So if you just replace bindings in the entire epxression with their respective definition (transitively), you'd end up with a large expression.
23:57:48 <jtm> ah ok
23:58:57 <dminuoso> The next thing to understand, is that evaluation stops at something we call WHNF. In this particular case, it stops at the first data constructor - more specifically it does not even evaluate what's inside unless it's demanded.
23:59:52 <jtm> I'm just assuming it isn't being lazy here.
