00:18:06 <ph88> hello
00:18:46 <ph88> When i have a type like    newtype M1 i c f p = M1 { unM1 :: f p }    how can i do something with i and c  ?
00:21:59 <lemmih> ph88, What do you want to do with them?
00:22:20 <ph88> get meta information
00:23:19 <lemmih> ph88, Perhaps: readI :: M1 i c f p -> String -> i; readI _ str = read str
00:25:08 <ph88> No instance for (Read i) arising from a use of ‘read’
00:26:00 <lemmih> readI :: Read i => ...
00:27:38 <ph88> here are some methods i can use to read https://hackage.haskell.org/package/base-4.14.0.0/docs/GHC-Generics.html#g:23 
00:29:04 <ph88> No instance for (Read D) arising from a use of ‘readI’
00:29:44 <ph88> i don't see M1 implementing Datatype, Constructor or Selector .. not sure what applies here
00:36:11 <lemmih> ph88, Is M1 from a library or did you define it yourself?
00:36:25 <ph88> from GHC.Generics
00:36:50 <triteraflops> So, the support for named optional arguments and a few other odds and ends, I concluded, is maybe not an obviously bad idea. Where did you say again I should send the proposal?
00:38:09 <phadej> ph88: `i` tells whether it's top-level D, constructor C, or selector S metadata
00:38:28 <phadej> and c has a data-type for which you have ..., Constructor and Selector instances
00:38:48 <phadej> look at e.g. :kind! Rep (Maybe Int)
00:39:08 <ph88> ye i got their meaning, but i'm not sure how to take that i and c and actually do something with it
00:39:47 <phadej> instance (Selector c, i ~ S) => GYourClassForFields (M1 i c f) where ...
00:41:00 <ph88> does it have to be a typeclass for this reason ? to be able to write  i ~ S  ??
00:43:00 <c_wraith> it has to be a typeclass because the input is a type and the output is a value
00:43:26 <ph88> oki
00:43:59 <ph88> Is there maybe some alternative way of writing so i could do pattern matching on type level for D, S and C ? or is the only choice to write 3 instances ?
00:44:20 <phadej> ph88: watch https://www.youtube.com/watch?v=pwnrfREbhWY
00:44:51 <ph88> thanks phadej :)
00:45:51 <phadej> the notes are at https://github.com/well-typed/gp-zurihac-2020/raw/master/GP.pdf
01:00:48 * hackage reanimate 0.4.3.0 - Animation library based on SVGs.  https://hackage.haskell.org/package/reanimate-0.4.3.0 (DavidHimmelstrup)
01:35:09 <itai33[m]> if I'm doing IO in a do block, and I have some `Maybe a`, is there any way to perform an action only if it's jsut?
01:35:18 <itai33[m]> *Just
01:36:20 <lexi-lambda> itai33[m]: You can use traverse_ or for_ (or traverse/for if you want the result).
01:37:13 <itai33[m]> lexi-lambda: sweet, thanks!
01:44:48 * hackage hledger-flow 0.14.0.0 - An hledger workflow focusing on automated statement import and classification.  https://hackage.haskell.org/package/hledger-flow-0.14.0.0 (apauley)
02:00:24 <nij> exploring haskell programs a lot recently :) however they take up so much virtual memory at least shown in `htop`
02:00:37 <nij> https://downloads.haskell.org/~ghc/8.0.1/docs/html/users_guide/8.0.1-notes.html#runtime-system
02:01:28 <nij> In this page, it's claimed that I don't have to worry. But I don't understand what it means by "most of this amount (VIRT) is merely mapped but uncommited address space which is not backed up by physical memory"
02:01:38 <nij> could someone explain a bit..?
02:03:06 <phadej> do you know about memory pages, https://en.wikipedia.org/wiki/Page_(computer_memory) ?
02:03:13 <c_wraith> linux memory management is not as simple as "allocate memory and the system sets it aside"
02:03:35 <phadej> in short, RTS asks for a lot of pages, but linux kernel gives them only when they are actually used
02:03:45 <phadej> there's huge overcommittment
02:03:50 <phadej> but it's fine :)
02:04:01 <nij> that's good news and bad news
02:04:05 <c_wraith> in linux, when you ask for memory, it says "sure, I'll set some space aside" but it doesn't actually find physical ram for it until you *use* the memory
02:04:08 <nij> good news: phew i dont have to worry
02:04:18 <nij> bad news: that number is meaningless now..
02:04:25 <c_wraith> has been for years
02:04:42 <nij> c_wraith: wow good to know but why does it do that
02:04:44 <phadej> nij: read through http://www.well-typed.com/blog/2020/08/memory-fragmentation/
02:05:16 <phadej> don't look at VIRT, look at RES
02:06:01 <c_wraith> nij: because most programs request more space than they actually need, just in case.
02:06:27 <phadej> e.g. chrome processes seem to have 4GB VIRT on my machine, but some hunders of megs of RES
02:06:28 <nij> I see
02:06:59 <phadej> TL;DR there isn't a single "memory usage" number
02:07:01 <c_wraith> nij: and then with 64-bit addresses and a memory management system known to behave that way, it turned out to improve garbage collection speed to just ask for a terabyte of memory up front
02:07:36 <phadej> in different contexts, you want different numbers :)
02:07:37 <nij> c_wraith: interesting
02:08:00 <nij> Some issue said it's better for it to "core-dump"
02:08:05 <nij> Is it related?
02:09:38 <nij> https://gitlab.haskell.org/ghc/ghc/-/issues/14192
02:09:48 <c_wraith> nah.  you have to jump through hoops to get a core dump these days anyway.  But I think they were getting at the idea that it's more reliable to let a process crash in out-of-memory conditions than try to recover
02:10:06 <c_wraith> linux doesn't do that, exactly, either.
02:10:36 <c_wraith> when it determines it's running out of memory, it picks a program and kills it.  Roughly at random.
02:10:43 <c_wraith> malloc never fails
02:10:43 <nij> :O
02:10:45 <nij> really
02:10:57 <c_wraith> yeah, look up the "oom killer"
02:13:48 * hackage LiterateMarkdown 0.1.0.1 - Converter to convert from .lhs to .md and vice versa.  https://hackage.haskell.org/package/LiterateMarkdown-0.1.0.1 (FabianSchneider)
02:15:26 <nij> :) well learned thank you folks!
02:22:24 <Arahael> c_wraith: That's configurable, actually.
02:22:54 <Arahael> c_wraith: I recall that redhat would change it so that malloc could fail if it runs out of memory.
02:23:03 <Arahael> (I don't know if it still does)
02:23:14 <Arahael> Almost every other distro does it as you describe, though.
02:30:05 <kuribas> Is it better to return "LoggingT MyLog (ExceptT String IO) a", or LoggingT MyLog (IO (Either String a))" ?
02:31:13 <koz_> @unmtl WriterT MyLog (ErrorT String IO) a
02:31:13 <lambdabot> IO (Either String (a, MyLog))
02:31:30 <koz_> @unmtl WriterT (IO (Either String a))
02:31:30 <lambdabot> err: `WriterT (IO (Either String a))' is not applied to enough arguments, giving `/\A B. A (B, IO (Either String a))'
02:31:49 <koz_> @unmtl WriterT MyLog IO (Either String a)
02:31:50 <lambdabot> IO (Either String a, MyLog)
02:31:57 <koz_> Therein lies the difference.
02:32:16 <koz_> Namely, in the former setup, the moment you error, your log goes away.
02:32:25 <koz_> In the latter setup, the log persists, error or none.
02:32:42 <koz_> (I used Writer for demonstration purposes, but it works with LoggingT as well)
02:32:54 <koz_> The answer to the question is 'which do you prefer'?
02:33:38 <kuribas> I mean, one requires unpacking at the call site
02:33:44 <kuribas> the other at the implementation side
02:34:25 <koz_> It's not just an unpacking question.
02:34:31 <koz_> They do different things.
02:34:34 <koz_> (as I said)
02:37:05 <kuribas> no, they are the same: Handler MyLog (IO (Either String a)) -> IO (Either String a)
02:37:19 <kuribas> (after unpacking)
02:39:37 <kuribas> maybe that would be a better type...
03:21:19 * hackage libfuse3 0.1.1.0 - A Haskell binding for libfuse-3.x  https://hackage.haskell.org/package/libfuse3-0.1.1.0 (yohashi)
04:20:09 <kuribas> ugh, why does MonadLogger use TH?
04:20:56 <kuribas> is there a decent logging library?  monad-logger is underwhelming
04:23:48 <merijn> kuribas: You don't have to use TH
04:24:09 <merijn> kuribas: The TH versions are just if you wanna get source locations automatically...
04:24:30 <kuribas> merijn: it looks like logging-effect has more features, like adding timestamps, etc...
04:24:56 <kuribas> transforming logging types
04:25:53 <merijn> My main gripe about MonadLogger is that I would've like a separate library for the class and the newtype
04:26:25 <kuribas> yeah
04:26:52 <merijn> So you could use the class with more minimal dependencies, although I guess that doesn't work since you'd keep the conduit dependency to be able to define the instance
04:28:48 <kuribas> what's the advantage of monad-logger over logging-effect?
04:28:52 <kuribas> is it more performant?
04:29:13 <kuribas> logging-effect uses pretty-printer...
04:30:07 <merijn> kuribas: Let us know when you find out? :p
04:30:25 <merijn> Although prettyprinter is relatively slow, compared to "just outputting stuff"
04:30:37 <kuribas> I guess logging is IO-bound
04:30:44 <kuribas> hmm, true
04:30:56 <kuribas> and do you really care about pretty logs?
04:32:28 <kuribas> https://hackage.haskell.org/package/logging-effect-1.3.11/docs/Control-Monad-Log.html
04:32:39 <kuribas> "In terms of performance, it seems to come out a little bit faster than monad-logger at runtime - but nothing to write home about"
04:41:15 <ph88> I copied this code https://bpa.st/MERA from stackoverflow but it gives type errors .. did anything change in GHC.Generics since 2019 ?
04:43:04 <merijn> Possibly?
04:51:33 <int-e> ph88: That code never worked, it's missing two extensions: ScopedTypeVariables and TypeOperators
04:52:10 <int-e> (Which may of course have been provided externally if it's from a larger project...)
04:52:56 <ph88> int-e, i added those myself they are not in the paste
04:53:12 <ph88> how can this answer have 17 upvotes i wonder
04:53:28 <int-e> Because it basically works?
04:54:09 <int-e> I find it more interesting that nobody remarked on the missing extensions.
04:55:29 <ph88> what you mean basically works ? i get a ton of type errors
04:56:12 <int-e> ph88: Those go away if you add {-# LANGUAGE FlexibleInstances, ScopedTypeVariables #-}
04:56:38 <ph88> eh ok
04:56:42 <int-e> Which the original code used... maybe that's why nobody really cared.
04:56:54 <int-e> Err, TypeOperators, not FlexibleInstances
04:57:38 <ph88> ok but i added those extensions :/
04:58:05 <int-e> ph88: The SO post had some more pragmas that you apparently dropped
04:58:23 <int-e> I have not checked which of those are actually needed.
05:01:09 <ph88> i see
05:01:24 <ph88> thanks int-e 
05:02:48 <cyberfined> Hi everyone, do you know any article about using recursion schemes for building interpreter (with functions and if or while statements) or really existing interpreter based on them?
05:05:01 <clemambi> yo, I was wondering if anyone could help me including my X11R6/includes directory with cabal?
05:10:06 <int-e> ph88: Actually the 17 votes are clearly not for the later version but for the first one.
05:10:29 <int-e> (Most of them anyway.)
05:12:57 <ph88> when i have a typeclass to implement a generic how can i get the value instead of the Rep  ?
05:14:22 <merijn> clemambi: That question has insufficient info :)
05:15:25 <clemambi> @merijin, on OpenBSD, x11 libs are stored in /usr/X11R6/include/*
05:15:25 <lambdabot> Unknown command, try @list
05:15:46 <clemambi> I'm building xmobar and it needs xkb libs in there, but it's not in the default includes list
05:16:48 <clemambi> The error is simply that it can't find the library. I manually pointed it at the right libarary, but then it couldn't find dependancies becuase it doesn't know the folder exists
05:17:04 <clemambi> so I need some way to add it to the include path
05:21:19 <merijn> clemambi: cabal-install has a --extra-include-dirs commandline flag where you can specify additional include directories
05:21:44 <merijn> clemambi: (and a billion more flags to tweak compiler locations, library paths, etc. consult --help for details)
05:22:49 <clemambi> right now my command is cabal new-install --extra-include-dirs="/usr/X11R6/include" xmobar.cabal -f-with_alsa and that's still giving me the error (failing to find library)
05:23:45 <merijn> clemambi: THe include dir just points at the header files, it doesn't help find the actual library
05:24:24 <merijn> clemambi: I don't know OpenBSD too well, but I will bet you $100 dollar that the X11 libraries are *not* in a directory called "include" :)
05:24:29 <clemambi> they are
05:24:33 <clemambi> I checked they're there
05:24:38 <clemambi> lol
05:24:46 <merijn> clemambi: There are .a/.so files in /usr/X11R6/include?
05:24:46 <[exa]> clemambi: look at /usr/lib or /usr/local/lib
05:25:02 <clemambi> it's asking for .h
05:25:10 <[exa]> show error message?
05:25:14 <merijn> clemambi: .h files are *headers*, they are not *libraries*
05:25:25 <clemambi> fatal error '11/skblib.h' file not found
05:25:35 <clemambi> x11/xkblib.h
05:25:48 <clemambi> ah, my bad
05:25:54 <[exa]> do you have libxkb package installed? (potentially the dev version?)
05:27:37 <merijn> pastebin the full error somewhere, because that one line doesn't even say which library fails to build
05:40:00 <clemambi> https://file.iof1aeyp2hHrse
05:40:17 <[exa]> clemambi: that link doesn't seem to work
05:40:30 <clemambi> https://file.io/f1aeyp2hHrse
05:40:48 <[exa]> still, 404
05:40:57 <clemambi> lol
05:41:04 <clemambi> that's the link the file uploader gave me
05:41:07 <clemambi> let me try antoehr one
05:41:11 <[exa]> does it work for you?
05:41:19 <clemambi> not even on the link on the uploader
05:41:26 <clemambi> should've tested it lol
05:43:05 <clemambi> pastebin.com/Jsframiz
05:43:09 <clemambi> that works
05:45:16 <clemambi> that's the result of cabal new-install --extra-include-dirs="/usr/X11R6/include" xmobar.cabal
05:49:30 <clemambi> as far as I can tell it looks like it's not respecting my include directory
05:50:40 <merijn> Looks like it's assuming the include for X11 will be under /usr/include/X11/ (with /usr/include as include path)
05:50:53 <merijn> Whereas you have /usr/X11R6/include (with no subdirectory)
05:51:36 <merijn> I'm going to guess most linux distros use "/usr/include/X11/" and as usual programmers working on linux refuse to acknowledge the existence of anything else
05:51:49 <clemambi> no, there is a sub directory
05:51:57 <clemambi> the path is identical beyond the include prefix
05:52:08 <merijn> hmmm
05:52:14 <clemambi> i double checked that
05:52:31 <clemambi> I swear to god I've been trying for at least an hour or I wouldn't be annoying you with this :D
05:53:03 <merijn> Out of curiosity, which version of cabal-install is this?
05:53:15 <clemambi> the latest one? I have no idea how to check
05:53:22 <merijn> cabal --version ? :p
05:53:34 <clemambi> 2.4
05:53:39 <merijn> oh, ouch
05:53:43 <clemambi> is it bad?
05:53:44 <merijn> Ok, new hypothesis
05:53:49 <clemambi> shoudl I install older cabal?
05:53:55 <clemambi> newer?
05:53:56 <clemambi> lol
05:53:58 <merijn> clemambi: new-install was only half implemented in 2.4
05:54:11 <clemambi> OK, so figure out how to update cabal
05:54:23 <merijn> "cabal instal cabal-install" should work :p
05:54:52 <merijn> clemambi: You probably want at least 3.2 (latest is 3.4) if you use new-build
05:55:03 <clemambi> that's doing 3.2
05:55:11 <clemambi> it's baking, pray for me :D
05:55:22 <merijn> clemambi: As of 3.0 the "new-build" commands are the default (i.e. "cabal install" is "cabal new-install")
05:55:25 <clemambi> been a long, long time since I last used haskell
05:55:37 <clemambi> I'm pretty sure last time was before cabal was a thing
05:55:47 <merijn> clemambi: And especially from 2.4 to 3.x at lot of missing/half implemented new-* commands were finished up
05:55:57 <clemambi> maybe not that long ago
05:56:03 <clemambi> ah
05:56:15 <clemambi> so it's probably just not working becuase it's a buggy old veriosn
05:56:19 <clemambi> version*
05:56:38 <merijn> clemambi: I'm not 100% sure, but it's also not unthinkable that it's just that :p
05:56:40 <clemambi> good to know the problem isn't my brain
05:56:42 <clemambi> :D
05:56:51 <clemambi> here's hoping at least
05:57:00 <merijn> And either way, if you use the new-build stuff you want 3.2 anyway :p
05:57:22 <clemambi> yeah, I just used new build because the internet told me to
05:57:23 <clemambi> :D
05:57:29 <clemambi> I don't know enough to know it's a bad idea
05:58:48 * hackage template-haskell-optics 0.1 - Optics for template-haskell types  https://hackage.haskell.org/package/template-haskell-optics-0.1 (arybczak)
05:59:00 <merijn> clemambi: It's much better than the old stuff :p
05:59:46 <clemambi> Cabal--install 3.2 depends on cabal install 3.2
05:59:50 <clemambi> hmmmm
06:01:17 <merijn> clemambi: it gives an error?
06:01:21 <clemambi> yup
06:01:25 <clemambi> it depends on itself
06:01:46 <merijn> Pastebin the error?
06:03:40 <clemambi> i got out of memory requested 1048576 bytes and exit faliure 251 and cabal install 3.2 depends on cabal isntall 3.2 and hackagae security6.0 dpends on hackage security 6.0
06:03:45 <clemambi> no error log
06:03:55 <clemambi> that's literally all it said
06:04:28 <merijn> hmm
06:05:01 <merijn> clemambi: There's a bootstrap script for building it just using GHC: https://github.com/haskell/cabal#installing-cabal-without-cabal
06:05:28 <clemambi> I'm trying cabal new-install cabal install
06:05:42 <clemambi> if/when that fails, I'll try that
06:06:16 <merijn> There should be a hyphen between the "cabal" and "install" in the target
06:06:57 <clemambi> ther was 
06:06:59 <clemambi> sorry, typ
06:11:16 <clemambi> alright same error using new build
06:22:11 <[exa]> hmeh, is there some good way to have a "default" command for optparse-applicative?
06:22:50 <[exa]> (hm I guess it would easily conflict with all argument parsing though...)
06:33:27 <merijn> [exa]: You mean a "myExe subcommand1" and then having alternate options for "myExe subcommand1 nestedsubcommand1" and "myExe subcommand1 nestedsubcommand2"?
06:36:05 <merijn> [exa]: the answer is: yes, you can do that, because I have that in my code, but don't ask me to remember exactly how :p
06:37:24 <clemambi> alright so they removed bootstrap.sh
06:37:36 <clemambi> but I've found an old commit so I'm gonna rollback my clone to that
06:37:38 <clemambi> and see if it works
06:38:10 <merijn> oh, bah, looks like they use a different python script now but the readme wasn't updated
06:39:24 <clemambi> it's workign so far
06:39:30 <clemambi> cabal 3.5
06:40:43 <merijn> that's the dev version, but that should be fine
06:44:46 <clemambi> I got an out of mem again
06:44:51 <clemambi> this can't be right
06:45:41 <merijn> clemambi: How much memory does this machine have?
06:45:46 <clemambi> 8gib
06:45:48 <clemambi> gig*
06:46:03 <merijn> ok, yeah, GHC is memory hungry, but not *that* memory hungry :p
06:46:09 <clemambi> ^^
06:46:18 <merijn> Which GHC version?
06:46:22 <clemambi> 8.6
06:46:32 <merijn> oh, I have an idea
06:46:44 <merijn> clemambi: Can you pastebin the output of "ulimit -a"?
06:48:27 <clemambi> on it
06:49:20 <clemambi> https://pastebin.com/QcnBpDZx
06:49:50 <merijn> curse you, openbsd for using different names for things
06:49:59 <clemambi> you think my stack size is too small?
06:50:05 <merijn> Naah
06:50:12 <clemambi> lol
06:50:19 <merijn> I'm wondering whether OpenBSD limits virtual memory
06:52:04 <merijn> clemambi: Ok, can you try setting "ulimit -d unlimited" and see if it fails then?
06:52:13 <clemambi> I think I've got it
06:52:24 <clemambi> cabal's dumping it's shit in /
06:52:34 <merijn> heh
06:52:41 <clemambi> which openbsd has as an individual partition for safety
06:52:48 <clemambi> and it has filled it
06:52:56 <merijn> cabal dumps stuff in $HOME by default
06:53:10 <clemambi> maybe theres a different reason then? hmm
06:53:22 <merijn> So unless your $HOME is set to / or there's a config file changing the default that's weird
06:53:37 <merijn> is /tmp running out, maybe?
06:53:49 <[exa]> merijn: it seems that I could just alternate the whole branch with subcommands and see...
06:53:56 <[exa]> anyway thanks for confirming :]
06:54:16 <clemambi> tmp is 1%
06:54:57 <[exa]> btw is there any name for:   \x -> fmap Just x <|> pure Nothing   ?  (aka: convert failure to Nothing and succeed)
06:56:02 <merijn> [exa]: optional?
06:56:15 <merijn> @hoogle optional
06:56:16 <[exa]> uuuuuh cool
06:56:16 <lambdabot> Control.Applicative optional :: Alternative f => f a -> f (Maybe a)
06:56:16 <lambdabot> Text.ParserCombinators.ReadP optional :: ReadP a -> ReadP ()
06:56:16 <lambdabot> Text.Parsec optional :: (Stream s m t) => ParsecT s u m a -> ParsecT s u m ()
06:56:23 <[exa]> yeah that's it by definition
06:56:25 <[exa]> thanks
06:56:53 <merijn> clemambi: Where is it putting stuff in / ?
06:57:03 <merijn> And what happens after "ulimit -d unlimited"?
06:59:14 <clemambi> data seg size got bigger
06:59:20 <clemambi> 33554432
06:59:28 <clemambi> kbytes
06:59:45 <merijn> clemambi: Yeah, but I meant "does it run without error then?" also, weird that it still has a fixed sizes, rather than actually unlimited
07:00:25 <clemambi> gonna try in a sec
07:00:33 <merijn> anyway, I gotta get back to writing >.>
07:01:01 <clemambi> alirhgt ty for all the help
07:01:02 <clemambi> gl
07:06:39 <clemambi> still fried
07:06:41 <clemambi> damnnit
07:09:52 <clemambi> I'm gonna try cabal-isntalling an older version
07:20:20 <sm[m]> clemambi, maybe some clues at https://github.com/haskell/cabal/issues/5505
07:21:38 <clemambi> thanks for the suggestion, I'll take a look
07:26:00 <clemambi> alright that one pointed to another that might have some answers :D
07:26:03 <clemambi> here's hoping
07:33:29 <ph88> if i want the names of record fields and their values should i use Data.Data or GHC.Generics ?
07:41:23 <jchia_> Is it possible to use GHC.Generics to implement a function that can convert between two types a & b that are isomorphic and have Generic instance? https://gist.github.com/jchia/afe04a4d21e2538a758c38999e80b379
07:42:59 <jchia_> A function that works for any two types as long as they are isomorphic and have Generic instances.
07:47:19 <dolio> That doesn't sound like a reasonable expectation.
07:47:54 <phadej> those types no
07:48:09 <phadej> data MyPair a b = MyPair a b, and (a,b) -- yes
07:48:17 <phadej> structurally the same
07:48:44 <phadej> or MyBool and Bool -- but not -- Either () () and Bool
07:49:37 <phadej> where by "no" I mean very very hard.
07:49:56 <clemambi> goddamnnit I just burnt 10mins trying to instal cabal before I realized my wifi was offline
07:50:11 <phadej> IRC works still? :)
07:51:05 <c_wraith> beware of using the word "isomorphic" there.  It has a more general meaning than "same structure".  It's "same structure with respect to some specific operation".  Two data types can have the same structure but be different with respect to a chosen operation - this is the whole reason for newtype wrappers that provide special instances.
07:52:01 <phadej> c_wraith: that's nitpicking, I think jchia_ asks for simple plumbing
07:52:06 <jchia_> i realize 'isomorphic' can be interpreted with different levels of generality. I don't mean it in the most general sense, just in a structural sense that can be detected using GHC.Generics.
07:52:28 <phadej> the problem jchia_ wants to solve is that you need to recursively `to` and `from` the datatypes
07:52:35 <phadej> and that's tricky
07:52:48 <phadej> if it's just one-level, that is easy
07:53:15 <phadej> https://hackage.haskell.org/package/recursion-schemes-5.2/docs/src/Data.Functor.Foldable.html#GCoerce
07:53:50 <phadej> generic-lens have a special type-family to know when to recurse and when to stop
07:53:56 <phadej> (e.g. to stop at Int or Text)
07:54:01 <phadej> but IIRC it's brittle
07:54:14 <dolio> What is the expectation when the types aren't isomorphic, like on lines 12 and 13?
07:56:05 <jchia_> phadej: From my gist: "Either () (Either [(Int, Bool)] Char)" presents three choices, "()", "[(Int, Bool)]" and "Char", so it should be isomorphic to "Three Unit [Foo (Identity Int) MyBool] Char". It was a typo.
07:56:50 <dolio> Although my question is just a symptom of the problem.
07:57:15 <jchia_> dolio: Then the convert function does not type-check
07:57:35 <jchia_> i mean that's ideally what i'm trying to get
07:58:25 <phadej> it's difficult. the GCoerce in recusion-schemes works because GHC.Generics makes always the same kind of binary tree for n-ary sums and products
07:58:54 <phadej> but if you have Either (Either a b) c and These a b their recursive Reps might be nested differently
07:59:02 <phadej> s/nested/balanced/
07:59:28 <phadej> with GHC.Generics it is hard, with TH would be easier
07:59:32 <phadej> but still, not nice
08:00:35 <jchia_> phadej: if we forgo the Either case, is it still hard?
08:00:37 <dolio> I don't think generics can cause things to not type check depending on the details of two arbitrary Generic instances given.
08:00:59 <jchia_> dolio: Then the next best thing is to have convert produce a Maybe
08:01:19 <jchia_> dolio: Do you think that the 'isomorphism' cannot be determined statically?
08:01:52 <dolio> I think there needs to be some proof obligation that the types are actually isomorphic in some way.
08:02:34 <phadej> dolio: of course it can be used to not type-check
08:02:43 <phadej> if there is no instance, it will fail with "no instance" error
08:03:01 <dolio> phadej: No instance of what?
08:03:21 <phadej> e.g. for GYourClass (f :+: g) case
08:03:23 <phadej> then sums won't work.
08:03:51 <phadej> or Semigroup a => K1 a -- when you generically derive Semigroup
08:04:16 <phadej> jchia_: with only product types it might work out
08:04:31 <phadej> but still, you need to flatten the structure, as trees will be balanced differently
08:04:40 <phadej> and you should have recursion termination condition
08:04:53 <phadej> (as e.g. arbitrary `a` type variable is not Generic, neither is Int)
08:08:43 <jchia_> phadej: How do you make a "recursion termination condition" at the type-level? We can't have negative instance constraints, right, so what can we do?
08:11:32 <phadej> the short answer is "you don't"
08:11:40 <phadej> see generic-lens for dirty tricks
08:11:53 <jchia_> ok
08:24:21 <sm[m]> @where+ zerotohero jargon-free language intro: https://rainbyte.net.ar/posts/200828-01-haskell-0-to-io.html
08:24:21 <lambdabot> Good to know.
08:31:19 * hackage polysemy-test 0.1.0.0 - Polysemy effects for testing  https://hackage.haskell.org/package/polysemy-test-0.1.0.0 (tek)
08:41:26 <clemambi> merijn I honestly have no idea how but I got it working, so ty for all the help
08:42:18 <merijn> \o/
08:44:01 <clemambi> here's hoping suckless makes a version of xmobar lol
08:44:24 <clemambi> I like C :(
08:44:28 <c_wraith> has anyone formalized the distinction between languages modeled by adding definitions to a global namespace at run time, vs those with a definition namespace fixed at compile time?
08:45:19 <c_wraith> and along with that, identified languages somewhere in between?
08:46:32 <monochrom> Not purely that, but "scripting language" includes that distinction.
08:46:45 <merijn> c_wraith: "languages in between" <- so, everything that supports dlopen?
08:46:54 <monochrom> haha
08:47:55 <c_wraith> I mean, yes.  There are names for distinctions that include that, but I'm wondering if there's any research focusing on that.
08:48:10 <monochrom> A language that includes an "eval", such as Lisp's eval and javascript's eval, also achieve it.
08:48:32 <c_wraith> that depends on if "eval" can change the calling namespace.
08:48:48 <monochrom> Ah right.
08:49:02 <c_wraith> you can use the ghc api to write an eval function in haskell, but it can't modify the calling namespace.
08:49:35 <c_wraith> in ghc haskell, to be specific.
08:52:39 <geekosaur> right, it depends on what namespace is available within eval. (notably, perl has modules that let you do an eval with restricted namespace access including read-only namespaces)
08:53:21 <geekosaur> whereas something like hint which uses ghc-api to do "eval" creates a new namespace
08:55:09 <c_wraith> I've been thinking about this for a while as a model difference that actually deserves the description "static" or "dynamic" for a whole language, though of course it's way too late to use those terms now.
08:55:31 <c_wraith> But I'm still interested in existing study of the difference.
08:55:47 <clemambi> Merjin I offically have working weather on my xmobar :D  now to try and hack a few more features in....
08:58:15 <monochrom> c_wraith, I think you're fine, people do expect "dynamic language" to be dynamic on at least the top-level binding front. (Oh they also expect dynamic typing.)
08:58:15 <geekosaur> this is even more complex: compare ghc to ghci
08:58:38 <geekosaur> ghci is arguably dynamic in this sense, since you can "unimport" with ":m -"
09:00:24 <MarcelineVQ> geekosaur: nice to see you
09:01:12 <c_wraith> when you look at ghci that way, you almost have to look at it as supporting a slightly different language than "Haskell"
09:02:16 <geekosaur> I've been thinking of it that way for a while now, because most of the weirdnesses of ghci vs. ghc boil down to this kind of thing
09:02:42 <geekosaur> consider also how it has to determine a most general type with no context from later things typed in
09:03:35 <geekosaur> so ghci can determine a different type than ghc would, and we have things like ExtendedDefaultRules to try to work around the differences
09:11:08 <geekosaur> (which implies that there is a sense in which ghc is more dynamic, since it can resolve types (or fixities, etc.) based on later information)
09:13:30 <monochrom> I don't have that sense. There is no "later" when it comes to the content of a X.hs file.
09:14:11 <geekosaur> consider TH stages
09:14:42 <geekosaur> which reintroduce the same notion of "later" for pretty much the same reason:TH speaks the same "dialect" as ghci and hint
09:15:26 <geekosaur> ghci's version of "later in X.hs" is "later in the same ghci session"
09:15:34 <nitrix> I think point, I'd see it's the property of a compiler vs interpreter, not of the language. The interpreter will always have the power to meddle with the namespaces, it oversees everything.
09:15:41 <nitrix> s/see/say
09:16:18 <geekosaur> but you as a user would be pretty annoyed if ghci didn't start producing results until the end of the session, hence the different "dialect"
09:18:43 <geekosaur> but there are interpreters that work the "not until the end of the session" way (hugs, runghc; also at least one C interpreter)
09:19:05 <c_wraith> nitrix: I think you're mixing up "interpreter" with "repl" there.  the JVM is an interpreter that doesn't load anything less than an entire class at once.
09:19:52 <geekosaur> and at least one compiled smalltalk that is dynamic in this sense
09:19:55 <c_wraith> the JVM *is* pretty dynamic within those constraints, but it didn't need to be.
09:21:45 <nitrix> I view interpreter and repl as two sides of the same coin. The only difference being the source for the R (read) and the optional P (print).
09:21:57 <geekosaur> the smalltalk I mentioned is a repl, btw
09:22:28 <geekosaur> but smalltalk is an ... interesting ... language which is well suited to blurring this boundary
09:23:13 <c_wraith> I still don't understand smalltalk images.  They seem like the opposite of software engineering to me.
09:23:57 <c_wraith> there may or may not be source code that describes the behavior the image contains.
09:24:06 <[exa]> c_wraith: indestructibility is just another view on reproducibility
09:24:23 <geekosaur> I'm tempted to draw a possibly insidious comparison to docker images
09:24:48 <geekosaur> urgh. invidious, not insidious
09:26:07 <[exa]> btw, R and matlab have images, and that's where the real values get lost. :]
09:27:49 * sm[m] did a little maintenance of
09:27:49 * sm[m] @where ?
09:28:00 <geekosaur> "who needs source when you have {backups | version control}?"
09:42:52 <Chousuke> that's literally what I once got told about a system consisting of a pile of docker containers when I asked how the deployment is done. "Just restore from backups if you lose the containers"
09:44:11 <Chousuke> it was quite literally just a pile of containers dumped on a system and then handed over to operations for "maintenance"
09:46:00 <geekosaur> …this is why I really don't want to get back into sysadmin…
09:47:45 <sm[m]> images have their uses, they're just not right for everything
09:48:12 <sm[m]> some smalltalk images (and docker images I guess) are built from declarative specs
09:49:30 <sm[m]> on another note, does anyone know a tool for generating stack/package.yaml files from cabal.project/.cabal files ?
09:50:25 <geekosaur> yes for docker images also
09:52:05 <JavaSucksMan> Wow... somebody mentioned smalltalk here (my fave)... im still in the early love/hate relationship with haskell
09:52:23 <geekosaur> I don't think that's possible in the general case
09:52:56 <JavaSucksMan> also, most smalltalks have binary kruft (ObjectMemory image) going back literally decades
09:53:19 * hackage graphql 0.10.0.0 - Haskell GraphQL implementation  https://hackage.haskell.org/package/graphql-0.10.0.0 (belka)
09:55:23 <ph88^> if i want the names of record fields and their values should i use Data.Data or GHC.Generics ?
09:58:56 <monochrom> GHC.Generics
10:03:45 <JavaSucksMan> as long as we're on the topic of REPLs and reflection, is their anyway in ghci to get the String result of a command (like :help) into an actual ghci haskell variable? (short of copy and paste) (sort of the inverse of :cmd) ? 
10:04:36 <[exa]> JavaSucksMan: most data can be parsed just with `read`
10:04:54 <c_wraith> what does that have to do with the question asked?
10:05:22 <[exa]> oh _String_ result of a command
10:07:33 <[exa]> there's something like evalString deep in GHCi package, guess GHCI.Run, but not sure if that's easily accessible
10:08:03 <sm[m]> tomsmeding: replaced hastebin with your pastebin in @where pastecabalstack
10:08:26 <JavaSucksMan> I've peeked into GHCI source (a little to gnarly for a beginner like me ;-)
10:08:35 <sm[m]> I would do the same in @where paste if I remembered who made that one
10:08:54 <tomsmeding> \o/
10:10:05 <sm[m]> was it merijn ? Well I'll be bold:
10:10:05 <sm[m]> @where+ paste Help us help you: please paste full code, input, and output at https://hastebin.com or https://paste.tomsmeding.com
10:10:05 <lambdabot> I will never forget.
10:10:37 <JavaSucksMan> And my mind boggles at :load ghci inside of ghci
10:11:03 <sm[m]> hastebin unfortunately is often a bit flaky in firefox for me
10:12:46 <monochrom> ah ok
10:13:28 <monochrom> Well "why does my program break?" is a bug report alright.
10:14:59 <monochrom> The world would be a better place if programmers thought of complaining about their own code.
10:17:11 <merijn> monochrom: But my code is a shiny beacon of perfection...
10:18:25 <monochrom> My students literally wrote "It fails the tests but the code is correct".
10:19:29 <monochrom> In front of that, "it passes the tests so the code is correct" is an infinite improvement.
10:20:37 <c_wraith> you know, one time I said to my coworkers "I created a model and analyzed it mathematically to get the right answers.  But then my code didn't actually work, and I'm not an economist so I had to admit I got it wrong."
10:21:14 <c_wraith> ever since then, they keep requesting that I insult economists some more.
10:21:29 <monochrom> haha
10:23:52 <c_wraith> Some part of me is *really* curious as to the mental model behind "the tests failed but my code is correct anyway"
10:24:27 <dolio> Sometimes it happens.
10:25:15 <c_wraith> well, yes.  But even then it's not the stopping point.  You either need to explain why the test is wrong or find a mistake in your explanation of why the code is right.
10:25:20 <monochrom> Does a defensive mechanism count as a mental model? :)
10:26:28 <dolio> Yeah, I think in most cases it's not a well-constructed thought process.
10:26:44 <c_wraith> monochrom: not at the level I'm thinking of.  It's a motivation, but it's not the model itself.
10:29:46 <c_wraith> I guess I can see something along the lines of "I did the work, it's not fair that this thing that doesn't understand me is telling me I'm not done."
10:31:24 <monochrom> My colleague has a great comic for that. I should show it to my students next time when a course begins, declaring kind of a course policy.
10:32:15 <monochrom> A bridge has been built, possibly by starting from the two ends and meeting in the middle.  The middle doesn't actually meet though, about 2 metres apart vertically.
10:32:40 <monochrom> Below is text "but don't I get partial credit?"
10:34:27 <dolio> Sometimes people just seem to have weird biases when thinking about this sort of stuff.
10:34:50 <dolio> Like, I was talking with someone about a variable capture issue I noticed in some substitution code I was working on.
10:35:25 <dolio> And, like, they refused to believe me without kind of an unreasonable amount of proof.
10:36:14 <dolio> I described generally how the variable capture would happen, but that wasn't good enough, and they just said, "well, probably that case can't happen somehow."
10:36:37 <geekosaur> sometimes people's boundaries for "the perfect is the enemy of the good" don't match up?
10:38:00 <dolio> So then I started coming up with particular examples of how the variable capture would actually happen, but I had to to keep adjusting the examples, because there were technicalities about the examples not being exactly well-formed.
10:38:46 <dolio> Which kind of suggests they weren't trying to understand how the variable capture would happen. They were looking for technicalities to dismiss the concern.
10:39:22 <c_wraith> personally, I just assume all substitution code has capture issues. If we don't know about them, it's because we've been lucky.
10:40:33 <sm[m]> int-e, I've pushed this repo tracking @where's db: https://github.com/simonmichael/lambdabot-where
10:41:42 <monochrom> This is really like adding more epicycles to avoid a heliocentric conclusion.
10:42:01 <monochrom> At least I added ferris wheels, not epicycles.
10:42:22 <monochrom> I want you to hear my ferris wheel exploit. :)
10:43:20 <monochrom> I was creating a programming contest problem. I wanted it to be solved by the Burnside lemma. So I created an outer ferris wheel, in which every "seat" is itself a small inner ferris wheel!
10:45:20 <monochrom> So the Burnside lemma is involved because the seats on the inner wheels are coloured, and I ask about how many configurations that look different.
10:47:14 <c_wraith> I can't remember even having heard of that.
10:47:53 <c_wraith> "Burnside's lemma, sometimes also called Burnside's counting theorem, the Cauchy–Frobenius lemma, orbit-counting theorem, or The Lemma that is not Burnside's" wow, wikipedia.  way to make the name more interesting than the lemma.
10:49:22 <monochrom> Hey, it's how I found out that you can say "a monad is just a fundamental construction, what's the problem?" :)
10:50:58 <dolio> The infinite version there seems a lot less interesting.
10:53:27 <merijn> Wikipedia is so shite for math
10:53:50 <merijn> And any approach to make it better is crushed by pedantic fucks >.>
10:56:49 * hackage servant-swagger 1.1.9 - Generate a Swagger/OpenAPI/OAS 2.0 specification for your servant API.  https://hackage.haskell.org/package/servant-swagger-1.1.9 (DavidJohnson)
10:57:25 <itai33[m]> is there an easy way to have a local version of all the docs of the dependencies of a project? All I can seem to find is how to generate docs for your own project with haddock
11:00:15 <c_wraith> there's an option for cabal to have it install docs when it installs a package.
11:00:27 <c_wraith> check ~/.cabal/config
11:00:55 <c_wraith> and then possibly reinstall everything so that it installs the docs too
11:10:52 <itai33[m]> c_wraith: If I understand correctly, if I want to have this for a specific project I should put it in the cabal.project file?
11:11:26 <c_wraith> if you want it *only* for that project, sure.
11:11:53 <itai33[m]> is there an easy way to access local docs?
11:12:17 <itai33[m]> because if it installs everthing in /usr/loca/... then it's kind of a hassle to find them
11:12:35 <c_wraith> I could swear there's a cabal command to give you the doc location for a specific library, but I can't remember it
11:13:03 <itai33[m]> also, if I turn on the .cabal/config option globally, will it also genrate docs for build dependencies of a local project as well?
11:13:18 <c_wraith> yes
11:16:02 <itai33[m]> c_wraith: it seems that `stack haddock --open` is a thing but I don't really want to move the whole thing over to stack for that
11:16:51 <c_wraith> Oh, I was testing obelisk, which had the front-end for doing it.
11:20:40 <merijn> itai33[m]: "finding the docs" with v2-build is still a bit of a work in progress, I think
11:21:56 <sm[m]> itai33: you can use them both together.. It'll just use double the disk space
11:22:17 <itai33[m]> how ironic, given that the docs for cabal 3 seem to be much better than the docs for cabal 2
11:22:38 <itai33[m]> sm: I can but as I am still finding my way around cabal I'd rather not use two overlapping tools at once
11:22:58 <sm[m]> I hear you
11:23:36 <merijn> itai33[m]: You can search the github issues for any related ticket and see what the work in progress is and if there's any workarounds
11:23:55 <itai33[m]> good idea
11:24:25 <itai33[m]> thank you my dudes
11:29:51 <cole> hello. I know this might not be the right question to ask, but I hope that someone here might be able to give me pointers to the right place. I've been searching for a paper/blog post/some page that explains in uncomplicated terms how to extend Hindley Milner unification-based type inference with recursive types. My understanding is that when inference would fail because a unification variable v is instantiated to a type t containing v,
11:29:52 <cole> you instead insantiate it to mu v. t. Is that all there is to it?
11:30:49 <merijn> cole: I don't have a blogpost for you, but I do have the recommendation that if you're even half interested in this question that you buy Benjamin Pierce's "Types and Programming Languages"
11:31:20 <kupi> what font do you use to code in Haskell?
11:31:24 <dolio> What does 'recursive types' mean?
11:31:31 <cole> merijn: Thank you. (sorry again if this is the wrong place)
11:32:21 <cole> dolio: I don't have a firm grasp myself. My understanding is that recursive types are of the form (Mu f a) where data Mu f a = f (Mu f a). Or something akin to that.
11:32:35 <merijn> cole: That book basically starts from untyped lambda calculus and builds up to everything you need to typecheck Hindley-Milner and recursive types (and a ton more)
11:32:57 <merijn> cole: It's widely considered the de facto standard introduction for anyone with an interest in learning how to implement type checker
11:33:00 <dolio> Well, the particularities matter.
11:33:38 <dolio> Just adding data types doesn't really require the unification you're talking about, for instance.
11:33:58 <dolio> But I assume you don't actually mean data types?
11:34:15 <merijn> dolio: I say the particularities don't matter, because whatever the actual details are, good odds that TaPL covers it ;)
11:34:25 <cole> dolio: I'm trying to type check recursive polymorphic variants.
11:34:38 <cole> (if I am using proper terminology)
11:35:41 <dolio> If you mean systems where there are solutions to `a = T a` and the like, then I don't think there's a lot to 'extend'. What you do is remove the occurs check from unification.
11:36:19 <dolio> But then you also need to somehow represent these infinite types in some places.
11:36:33 <dolio> Using a finite notation, presumably.
11:37:12 <dolio> I suppose TaPL might talk about this. I'm not really sure.
11:38:43 <merijn> chapter 20: recursive types, chapter 21: metatheory of recusrive types, section 2: finite and infinite types ;)
11:39:15 <cole> Looks like it's time to bite the bullet and do some reading. Thanks a bunch :)
11:39:56 <merijn> cole: It is a very readable book (especially if you skip the proofs when you get stuck), comes with example implementations of the type checkers in ocaml too :)
11:40:09 <cole> also, I think I left off a term, I am trying to type check anonymous polymorphic variants that might be recursive. But I'll see what the book has to say.
11:40:44 <juri_> if i ask nicely, can i get someone heavy with the maths to review my implementtation of geometric algebra? https://github.com/julialongtin/hslice/blob/master/Graphics/Slicer/Math/GeometricAlgebra.hs
11:40:53 <merijn> It covers variants too, I'm not sure about everything put together, but it should help :p
11:41:15 <cole> merijn: that is good. I was reading chapter 10 of advanced types and programming languages to try and understand how OCaml infers types for its variants and I was very lost
11:41:50 <juri_> I believe my implementation is correct (hspec tests at https://github.com/julialongtin/hslice/blob/master/tests/Math/PGA.hs ) ... :)
11:41:51 <cole> (that's what i get for searching for papers off of the website for a programming language with a very powerful type system)
11:42:37 <merijn> cole: At the very least that book will cover everything you need to be able to read and understand various more recent papers :)
11:43:01 <cole> ty again meijn and dolio!
11:43:07 <dolio> I suppose the sense in which you might want an 'addition' is that you might not actually want HM that infers recursive types.
11:43:09 <cole> merijn *
11:43:17 <dolio> Because the occurs check actually catches a lot of common problems.
11:43:48 <dolio> So you might only want recursion that is explicitly given by an annotation or something.
11:43:58 <cole> I agree. I believe that Remy and Pottier say OCaml only allows the occurs check to pass if it is on a variant or an object.
11:54:44 <rhit> Anyone have much experience with Servant? I think one of my JSON decoders is failing but can't figure out how to actually log the request body for debugging.
11:55:07 <rhit> By the time it gets to my Handler, it's either decoded or has already failed.
11:55:57 <rhit> And adding a logger with Warp.setLogger seems to log an empty body, presumably because it happens after Servant consumes the body (which is IO ByteString)
11:59:19 * hackage massiv 0.5.4.0 - Massiv (Массив) is an Array Library.  https://hackage.haskell.org/package/massiv-0.5.4.0 (lehins)
11:59:35 <ph88> when i have a typeclass for generic how can i get the actual value instead of Rep ?
12:00:28 <c_wraith> rhit: you'd need to run something as a middleware that can see the request before Servant does.  Then you need it to pass along a modified request that lets the next level read the body correctly, which isn't totally trivial.
12:01:10 <c_wraith> rhit: because the body is an IO action that is supposed to return an empty bytestring to mark that the body has been fully consumed.
12:01:58 <rhit> c_wraith: Hmm, yeah, that sounds a bit annoying to do. There's no way to hook into Servant when it's reading the body?
12:02:16 <c_wraith> Not sure.  I'm familiar with how warp manages things, but not servant.
12:04:48 <rhit> Gotcha... yeah, definitely seems odd to read and then try to repackage the body the same way for the next thing
12:05:01 <c_wraith> it can be done!  it's just a bit awkward.
12:06:18 <ph88> i have this code but im not sure what i can put at the question marks to get the value https://bpa.st/LZJA 
12:11:19 * hackage massiv-test 0.1.4 - Library that contains generators, properties and tests for Massiv Array Library.  https://hackage.haskell.org/package/massiv-test-0.1.4 (lehins)
12:11:44 <sim590> I have this WIP file: https://paste.debian.net/1161758/ that defines an interface for a Binary Tree. I'm now defining the copath function and I want to handle errors appropriately. I know about the alternatives runtime Maybe, Either and such, but what I'm looking for is a proper way in Haskell to do contract programming so that in debug mode, the compiled module could return an error and crash
12:11:46 <sim590> where it's faulty (just like using an assert in C), but in Release mode, I'd be using Either probably so that the program doesN't crash, but the error is handled graciously. Any tip on how to do that in Haskell?
12:15:03 <lyxia> if you can handle the error graciously, why not do that in debug mode as well?
12:19:46 <sim590> lyxia: because when the program becomes bigger and bigger, you have end up noticing the error way way up or down in the function call stack if you have lots of error handling that stack up and then it becomes harder to find the actual place where the error happened. In debug mode when you're doing contract programming, if you get a crash with a stack trace, you can know with more precision where
12:19:48 <sim590> it began to go wrong before stacking up error handling results. Let's say I would be using Maybe to handle errors. Then, I could be having a long stack of functions that would return Nothing and at some point lower in the function stack I would handle the Maybe result and say something in IO that would indicate taht something went wrong, but if I'm using the Maybe monad, I don't really know where
12:19:50 <sim590> it happened.
12:20:28 <sim590> So, if instead in debug mode, instead of returning a Maybe value Nothing at the top of the function stack where it went wrong, I'd be crashing exactly where it's wrong and I could isolate the issue.
12:20:52 <monochrom> HasCallStack
12:21:02 <monochrom> see the GHC user's guide.
12:22:52 <rhit> I was blown away when I first found out about HasCallStack and co. It's great.
12:24:54 <sim590> monochrom: I'm reading this: https://ghc.gitlab.haskell.org/ghc/doc/users_guide/exts/callstack.html. Thanks for the tip. I'm not yet sure that this brings all the pieces of the puzzle, but I'm reading the doc right now.
12:28:08 <sim590> For instance, will I be able to get a Debug/Release swtichable behaviour with this? Or does this only provide me with the feature of printing a callstack if something goes wrong? Because I'm really looking for a way to handle errors graciously in release mode so that the client of the library can handle the error graciously on its own too. But in debug mode, I want to crash. I'm not seeing how I
12:28:09 <sim590> can do this right now.
12:28:38 <tomsmeding> I think to be able to switch between debug and release mode, you'll have to do some CPP or TH trickery yourself
12:28:44 <idnc_sk> srk: cau
12:28:58 <idnc_sk> hi all
12:29:06 <sm[m]> why tomsmeding ?
12:29:13 <tomsmeding> also, is there a good reason you're not using a more complex exception type than Either or Maybe, that tracks the location where the failing arm is created (perhaps using HasCallStack)?
12:29:32 <tomsmeding> sm[m]: well, or use a library that has done that I suppose, but either way it's going to be CPP or TH trickery :p
12:29:42 <rhit> sim590: You can always add debug logging and log errors with the call stack and all that as they happen
12:30:05 <glguy> HasCallStack just means you have the information to print a callstack if something goes wrong; it doesn't require you to print one
12:30:25 <maerwald> is there a penalty?
12:30:28 <sm[m]> how about returning Left err or calling error based on a command line flag ?
12:31:19 <sim590> rhit: Oh. I see. So I could write errors on stderr during debugging without actually crashing and just suppress printing of errors in Release mode for example?
12:31:32 <sim590> glguy: ^
12:31:41 <sim590> Sry, I mixed up messages and authors.
12:32:10 <tomsmeding> though, if you know how to suppress printing of log messages in release mode, you also know how to exchange Left and error in release mode :)
12:32:13 <sim590> sm[m]: Yes. May be this. 
12:33:15 <rhit> sim590: One way or another, just store the environment you're running in (maybe in a ReaderT Env) and then you can handle errors differently depending on the environment
12:33:41 <rhit> So you can log them differently or even fail out in debug mode but handle it nicely in release
12:33:45 <sm[m]> though really, calling error is rarely optimal. Could be better to return the error to top level and there decide whether to handle it or exit
12:34:03 <sim590> Maybe a sort of binding decided at compile time?
12:34:35 <sm[m]> you don't want to have to recompile to see debug output
12:35:01 <rhit> Depending on how it's being run, an environment variable could work here or a command line flag
12:35:57 <dminuoso> sim590: In our compiler, we have an environment that roughly looks like `data Env = Env { envWarnings :: IORef [Warning], envErrors :: IORef [Error] }`, we just push to those. Depending on verbosity levels, we then render those (maybe hiding some, or render them differently)
12:36:24 <dminuoso> (The IORef there is for convenience, you could do this purely with some StateT as well)
12:36:43 <sim590> sm[m]: I don't want to go back to top level and lose the information about the callstack. That's what I'm looking for in Debug mode. But in release mode, yeah, I want to handle graciously the error and pop out of there and decide to exit or not.
12:36:48 <dminuoso> Just to provide you with some idea. :)
12:37:34 <rhit> sim590: You can grab the call stack at any given point with the HasCallStack thing discussed above
12:37:48 <rhit> No reason you can't push it to some top-level thingy and deal with it later (or not)
12:37:52 <sim590> dminuoso: Yes. That is helpful.
12:38:37 <sm[m]> sim590: ah, right. But yes you can also capture and return the call stack with the error if needed, as rhit says
12:38:46 <sim590> rhit: Alright. I have to re-read everything everyone said so that I can make myself a better idea of what I'll be going for.
12:39:42 <tomsmeding> such is life in a channel with 1k+ people :)
12:40:11 <sm[m]> so when do we hit 2k, anyway ?
12:40:17 <sim590> ʘ‿ʘ
12:44:56 <sim590> I was looking inito using co-log https://hackage.haskell.org/package/co-log. May be this could bring a lot of tools for doing what I need. For example, they provide a `Msg` data type which has a msgStack field.
12:45:51 <rhit> sim590: co-log is nice. It's actually where I learned about HasCallStack. Kinda just dug through co-log's source.
12:49:34 <sim590> rhit: So may be, in my example, I could return `Either Msg [BNode a]` and then include the callstack and a specific message in the Msg data type when I'm failing in copath function.
12:49:38 <dminuoso> sim590: Oh I forgot to mention. I also have some `IORef [Context]` in that environment as well. With a combinator `withContext :: Context -> Comp a -> Comp a` I can then sort of "push" context frames. The error combinators then obtain the current context, and append that.
12:49:57 <dminuoso> Maybe I could just give you a short example
12:50:08 <sim590> dminuoso: that would be very helpful!
12:53:44 <dminuoso> sim590: https://gist.github.com/dminuoso/7067ecda02417952ebce3375a4926202 this is a short extract from our code base. It's incomplete, but maybe it can give you an idea how to build up a toolset.
12:56:42 <sim590> dminuoso: So Comp is like a "state" Monad in which you store errors, warnings. Then you just do everything in the Monad?
12:56:54 <dminuoso> Right.
12:58:15 <dminuoso> sim590: You could furthermore think about combinators similar to >?> or >|> that depend on some environment field to be set at runtime.
12:59:48 <sim590> Does https://hackage.haskell.org/package/co-log-0.4.0.1/docs/Colog-Monad.html do similar thing to what you're cooking?
13:01:04 <dminuoso> I think not
13:03:28 <dminuoso> The machinery Ive shown you is more focused on erroring out, while giving you very fine control to toggle short circuiting on or off.
13:06:08 <dminuoso> co-log is too magic for my taste
13:06:29 <dminuoso> (And it rather replaces the monad-logger I use in addition to the above machinery, rather than the machinery)
13:06:40 <typetetris> Trying to play with optics in the repl, but `data Test = A | B; makePrisms ''Test` gives an error about a missing show instance for Language.Haskell.TH.Lib.Internal.DecsQ. How can I get generated prisms in the repl?
13:07:24 <dminuoso> typetetris: Mmm. Try $(makePrisns ''Test) perhaps?
13:07:43 <c_wraith> yeah, you can't use the bare expression syntax in ghci
13:07:57 <c_wraith> I still think the bare expression syntax should never have been added.
13:08:03 <dminuoso> Indeed.
13:08:23 <dminuoso> I never use it myself, it's always explicit splices in my code.
13:08:25 <typetetris> That gives me: `Expected type: Language.Haskell.TH.Lib.Internal.ExpQ` and `Actual type: Language.Haskell.TH.Lib.Internal.DecsQ`?
13:08:41 <dminuoso> Ah, its possible this wont even work in GHCi
13:08:44 <phadej> data Test = A | B; makePrisms ''Test`;
13:08:49 <phadej> semicolon at the end
13:08:54 <phadej> it's subtle
13:09:00 <dminuoso> Oh heh
13:09:14 <dminuoso> Alternatively, you can use a :{ :} block I suppose
13:09:43 <dminuoso> phadej: Who was mainly responsible for optics by the way?
13:09:46 <dminuoso> Is that you?
13:09:49 <typetetris> phadej, dminuoso: Thanks :{ :} worked
13:10:13 <phadej> ok, doesn't work on the single line
13:10:17 <phadej> but on separate works
13:10:22 <phadej> data Test = A | B;
13:10:25 <phadej> makePrisms ''Test`;
13:10:45 <c_wraith> why is there a ` in there?
13:10:51 <phadej> typo
13:10:54 <c_wraith> ah, ok
13:11:06 <c_wraith> copy & paste monster strikes again
13:11:13 <dminuoso> Ah actually it seems most commits are by Andrzej
13:11:19 * hackage z3 408.2 - Bindings for the Z3 Theorem Prover  https://hackage.haskell.org/package/z3-408.2 (IagoAbal)
13:13:47 <phadej> dminuoso: Adam bootstrapped, Andrzej completed it, I haven't contributed much, started the docuemntation (e.g. diagrams in the docs) and made initial indexed optics 
13:14:43 <phadej> or rather refactored broken indexed optics into something closer to current version
13:15:22 <phadej> anyway, it's mostly Andrzej :)
13:15:43 <dminuoso> I see, well it's a lovely package - thanks to you all for it. :)
13:16:13 <sim590> dminuoso: I understand a little bit more what your code does now. It can kind of help you write this generic choice of continuing to do some actions or not based on the state of errors so far.
13:17:11 <dminuoso> sim590: Something like that is easily implementable. Either in >>= itself, or some custom combiantor. :)
13:17:59 <nut> haskell is immutable. what is the common practice of modifying just one element of an array? by creating a new array? 
13:18:18 <Rembane> nut: Yes, or by using the ST monad. 
13:18:27 <c_wraith> nut: or use mutable arrays
13:19:08 <c_wraith> nut: Haskell doesn't prevent mutability.  It just forces you to be explicit about it.
13:19:28 <phadej> dminuoso: cheers, good to hear you like it.
13:19:31 <nut> I'm learning algorithm and many algo is based on array modifications. I can't figure out what should be the right way of doing it in Haskell
13:20:00 <c_wraith> nut: usually arrays aren't necessary at all in Haskell ports of common algorithms.  It's just convenient in C-like languages, so it's what gets used.
13:20:35 <phadej> have anyone read https://www.cambridge.org/core/books/algorithm-design-with-haskell, is it good?
13:20:37 <nut> operations such as updating an array in other languages, such a[i] = 2, is very concise. I've checked out the ST monad or mutable arrays or Vector, it's quite cumbersome
13:20:52 <c_wraith> nut: yes, that's to tell you to find a better way of expressing the algorithm
13:22:03 <phadej> (I have only seen presentation about that book, not actually read it)
13:22:13 <c_wraith> phadej: that link isn't working for me...
13:22:31 <phadej> https://www.cambridge.org/core/books/algorithm-design-with-haskell/824BE0319E3762CE8BA5B1D91EEA3F52 does this work
13:22:38 <c_wraith> yes
13:22:45 <c_wraith> apparently that id is necessary!
13:22:58 <c_wraith> ok, haven't read that one.  But I should, both of those authors are good.
13:23:14 <phadej> yes, I wonder if it's something nut is asking about :)
13:23:56 <phadej> i.e. "you just express the algorithms in Haskell differently"
13:24:10 <c_wraith> nut: what's an example algorithm?
13:24:25 <nut>  K e y - i n d e x e d   c o u n t i n g  
13:24:38 <nut> I've read that in the book: Algorithm 4th
13:24:44 <nut> expressed in Java
13:25:25 <dminuoso> phadej: As a success story, we didn't actually use lenses until I heard of optics. The combination of newtypes and tyfams with concise error messages, as well as small details like being unable to view through a Fold, gives us more comfort than lens does. Also, we can just use `f % g :: _` without being a genius.
13:26:09 <phadej> dminuoso: can you /msg me who are "you", if you are not willing tell it on the channel. I'm curious
13:26:16 <nut> phadej, I agree, I should take a closer look at that book
13:26:36 <c_wraith> nut: this looks like a radix sort variant?
13:26:52 <dminuoso> phadej: Me personally or us?
13:26:58 <nut> c_wraith, yes
13:27:00 <phadej> "us"
13:27:43 <dminuoso> phadej: We are Wobcom GmbH, a small local ISP in Germany.
13:27:54 <phadej> cool
13:28:16 <phadej> nice to hear about Haskell used in "traditional" industry :)
13:28:46 <Uniaika> France has a couple of players in "traditional" industry too
13:28:53 <Uniaika> I'm thinking logistics, especially
13:29:31 <nut> I'm located in France. Haven't heard much use of Haskell here. Ocaml is more popular
13:30:27 <c_wraith> nut: this feels like the sort of case I'd use https://hackage.haskell.org/package/array-0.5.4.0/docs/Data-Array.html#v:accumArray for - though of course that depends on the exact choices of interface data type.
13:30:37 * Lycurgus .oO( continental / anglo divide in FP )
13:31:05 <c_wraith> nut: that's a handy wrapper that uses mutable arrays internally but doesn't require you to mess with the details
13:31:17 <nut> c_wraith, I suppose I could use accumArray, it's just that accumArray is too cumbersome to use
13:31:32 <c_wraith> not compared to writing an explicit loop...
13:32:14 <nut> so the common practice is by using some recursive function to create a new array?
13:32:23 <c_wraith> no, there is no common practice.
13:32:27 <Uniaika> nut: it's especially Paris
13:32:29 <c_wraith> it just depends on the algorithm.
13:32:42 <Uniaika> according to flatmap.io, there are Vente Privée and Fretlink
13:32:58 <c_wraith> That algorithm specifically wants random access, so you probably end up at something array-like
13:33:31 <c_wraith> But not every algorithm that is written using an array in java needs random access.
13:33:58 <nut> c_wraith, I see, so the criteria is whether it calls for random access
13:34:16 <c_wraith> Well, that's certainly an important one.  It's not the only one.
13:34:20 <triteraflops> Isn't Tweag in Paris?
13:34:40 <c_wraith> but if the data type doesn't need random access, an array is probably not necessary
13:36:40 <sim590> dminuoso: You say you use monad-logger in addition to your custom definition for Comp. Do you then have a LoggerT transformer defined in monad-logger that lets you use your Comp inside it?
13:37:55 <sim590> Or is Comp not even an explicit monad and you don't make the usage of a transformer?
13:38:32 <dminuoso> sim590: Mmm. Actually it seems Ive gotten rid of it. I used to have `newtype Comp e a = Comp { runComp :: LoggingT (ReaderT (CompEnv e) IO) a }`
13:44:32 <c_wraith> nut: like...  https://gist.github.com/chowells79/5152e4e7515461ed62b9cdab4cabb6a6 isn't bad at all
13:46:34 <dminuoso> c_wraith: That should probably use foldMap'
13:46:44 <c_wraith> dminuoso: doesn't matter, the output is a list
13:47:12 <dminuoso> mmm
13:47:44 <c_wraith> and (.) is perfectly happy to work without evaluating its second argument, too
13:48:12 <c_wraith> it *does* depend on foldMap being based on foldr, but that seems likely, and foldMap' isn't gonna change that.
13:57:20 <sim590> dminuoso: Going back to what I said: based on your paste, you're using `do` so Comp is actually a monad. That said, you have gotten rid of the transformer? Why? How did that make things better? I'm trying to get a better understanding of how you're using your approach in the overall project of yours in pair with other monads like Logger and IO for example.
13:58:02 <dminuoso> sim590: I dont understand your question.
13:59:20 <c_wraith> dminuoso: on the other hand, explicitly using foldr when that's what I really want behind the scenes anyway is nice enough to get rid of an import.  So thanks for making me think about that more.
13:59:33 <c_wraith> nut: ok, https://gist.github.com/chowells79/5152e4e7515461ed62b9cdab4cabb6a6 is a bit nicer of an adaptation.
13:59:48 <nut> beautiful
14:00:28 <c_wraith> nut: you have to sort of tear down the algorithm and build it back up from a description of the solution, rather than porting code line by line.
14:00:53 <c_wraith> nut: otherwise you get lost in minutia
14:01:09 <dminuoso> sim590: A transformer is just a way to imbue the effects of one particular monad to another. There was no pre-existing monad to have the effects I wanted.
14:01:26 <nut> Yeah, i sort of get your idea. it certainly takes more getting use to, the new mind set
14:01:28 <monochrom> Hrm, not very happy with the cabal v2 way.
14:01:44 <c_wraith> nut: yeah, absolutely.  There is a very real sense in which it's learning to program all over again.
14:02:13 <monochrom> So I ran "cabal repl" once and caused a world building. Took a while and finished, all good from then on. Right?
14:03:19 * hackage generic-match 0.3.0.0 - First class pattern matching  https://hackage.haskell.org/package/generic-match-0.3.0.0 (sgschlesinger)
14:03:31 <monochrom> Then I indirectly ran "cabal repl" through my emacs haskell-mode setup. Since -ferror-spans and -fdefer-type-errors work better in that context, I set up my haskell-mode to add them when "cabal repl". Well that triggered a 2nd world building.
14:03:47 <sim590> I mean isn't it cumbersome to use Comp inside of Logger without a transformer? I'm not a real Haskell veteran and I have discovered transformers recently in the past months. To me, it's obvious that you must be using Comp inside Logger monad and in turn inside IO. Pretty much every critical functions you're going to run in your program will be run inside Comp I guess. Do you just run your
14:03:48 <sim590> computation, get the list at the end of the computation and use your Logger library at the base of the program in the IO monad to print all the errors/warnings from the list you got from the computation Comp ?
14:04:00 <monochrom> I did not need to go through this in the v1 good days.
14:04:14 <monochrom> Things were really simpler and cheaper back then.
14:04:31 <dminuoso> sim590: Yes to that last.
14:07:51 <dminuoso> sim590: I used to have a LoggingT (to give Comp a MonadLogger instance) to give access to instant logging, but ever since I refactored our compiler, we've stopped needing to log in the middle of the compiler. :)
14:07:52 <sim590> I'm just asking myself is there's a benefit to using a transformer for this at this point. To me, it would be to use Logger inside functions that behave like in the Comp monad, but wrapped in Logger. You could use Logger functions more deep in the program instead of just at the base of it. But I'm not sure if that would be helpful.
14:08:49 <sim590> dminuoso: Do you think that this is true for all use case? Do you think that this is sort of a design pattern that can be applied like this and that there's no need for a transformer then?
14:09:02 <sim590> In all cases or a broad set of cases.
14:09:19 <sim590> (I know that "broad set of cases" is a bit vague...)
14:10:02 <Cale> Honestly, I find logging transformers to usually be not worth their weight. If you can do arbitrary I/O, you can log already, and there's usually not much point in logging stuff that's not doing I/O on some level.
14:10:03 <dolio> monochrom: You told it to rebuild everything with different flags and it did.
14:10:24 <dminuoso> Cale: Well, the value comes from easily replugging the logging implementation.
14:10:40 * dminuoso is a big fan of monad-logger because of this
14:11:04 <monochrom> Yeah yeah I know
14:11:50 <monochrom> But let's take one step back.
14:12:11 <monochrom> I join the v2 bandwagon and I got what I deserved. That's more like it.
14:12:31 <dminuoso> sim590: If you need to log instantly, then yeah, this solution is not for you. Think of my machinery as a modified version of ChronicleT, rather than say some LoggingT. :)
14:13:10 <dminuoso> (In fact, my original code even used ChronicleT)
14:13:36 <Cale> dminuoso: I don't completely disagree on that, but usually I'd either just pass an argument for how to log, or if there's already some configuration record type being passed around / ReaderT'ed, add it to that.
14:13:53 <c_wraith> yeah, a logging function in the environment is a nice solution.
14:14:22 <Cale> If you already have a bunch of monad transformers, then adding a logging transformer isn't a huge deal, but I also would tend to avoid it if it's the first/only one.
14:14:36 <dminuoso> Cale: LoggingT is just a logging function in a reader environment. :)
14:14:42 <Cale> I know
14:15:23 <dminuoso> But yeah, there's a lot of options. There's no right and wrong really.
14:18:32 <Cale> There's a bunch of fancier stuff to do with logging that I might be able to get behind having some sort of library for. If you need log rotation, for example.
14:21:34 <hekkaidekapus> monochrom: ferror-spans seems to me that it should be part of components’ hashes. Maybe cabal should be patched.
14:22:30 <hekkaidekapus> Luckily, we have a regular here who is an expert: merijn (https://github.com/haskell/cabal/pull/5287)
14:23:01 <hekkaidekapus> *it shouldn’t
14:24:13 <dolio> -fdefer-type-errors would still require recompilation, though.
14:24:26 <hekkaidekapus> Yes.
14:24:36 <c_wraith> of the thing you're working on.  Not of your package dependencies...
14:24:50 <dolio> Not if you tell it to rebuild all dependencies with -fdefer-type-errors.
14:25:43 <c_wraith> I guess that makes some sense on dependencies that are being locally developed.  But ones being installed from hackage should never change behavior when that flag is added.
14:26:05 <dolio> I don't think that's true.
14:26:38 <c_wraith> how often do you successfully install packages with type errors in them?
14:26:49 * hackage http-link-header 1.2.0 - A parser and writer for the HTTP Link header per RFC 5988  https://hackage.haskell.org/package/http-link-header-1.2.0 (SShuck)
14:26:49 <dolio> I mean, ideally it would be, but there could be published package combinations that don't build, but do with -fdefer-type-errors.
14:27:06 <c_wraith> Yes, but if it was already building successfully, just adding that flag shouldn't change it.
14:27:26 <dolio> Okay, so it should have a special case for not rebuilding with -fdefer-type-errors if it already built without?
14:27:48 <c_wraith> there probably are several flags that fit that description
14:28:40 <monochrom> As usual, "what have I done?" :)
14:29:48 <monochrom> I boil it down to this.  One decision has to be made, and probably is already made, about the semantics of "cabal repl --ghc-option=blah".  Does that ghc option apply to just the package at hand?  To the whole dependency graph?
14:30:09 <c_wraith> I hope that's only to the current package.
14:30:21 <c_wraith> I'd find it deeply weird if it applied to dependencies
14:30:24 <dolio> Well, apparently it isn't just the current package.
14:30:31 <monochrom> And then whichever way you define it, half of the people will be unhappy, so you just tell them "use cabal.project.local to override".
14:30:32 <c_wraith> then I find that deeply weird
14:33:27 <dolio> How come you get special dispensation for complaints about 'it did what I said instead of what I meant'?
14:33:54 <c_wraith> the complaint is more of the form "why does what I said mean that?"
14:34:45 <sm[m]> which of the build tools' build options apply to deps ? Quite a small minority I think
14:35:01 <hekkaidekapus> The REPL should not have a custom build plan, I would wager.
14:36:38 <sm[m]> profiling builds is one, and I suppose haddock
14:37:01 <sm[m]> -fdefer-type-errors seems not something I'd ever want to apply to deps..
14:39:11 <monochrom> Profiling enjoys a cabal-level flag --enable-library-profiling
14:39:24 <c_wraith> I can see it in the case that you're doing simultaneous development of a package and some of dependencies.  
14:40:06 <c_wraith> But that seems like a special enough case that it would make sense to add support for "set these ghc options when building those dependencies"
14:40:18 <monochrom> However, sometimes you fine-tune profiling details by ghc options. It is not going to be easy.
14:51:27 <sm[m]> c_wraith: in that case those deps should be made local packages, ie "packages I am developing now"
14:52:22 <sm[m]> but you can set per-dep build flags, so I guess why not per-dep ghc options...
14:52:40 <sim590> dminuoso: Why make your own version of Chronicle and not just use it instead? Did Chronicle come after? Was there a use case it could not satisfy?
14:52:46 <sm[m]> because things are so simple already, let's spice it up.... :)
14:53:24 <monochrom> cabal.project has syntax for per-dep flags, down to ghc-options
14:53:42 <sim590> There are lots of options, so if I can know in advance about some challenges others have been through, I can may be go faster.
14:54:05 <sm[m]> thought so. And you want that same power on the command line
14:54:19 <monochrom> Maybe not. I don't know.
14:55:11 <sm[m]> at least, the UI should make it clear when you are applying flags to packages under development and when to all deps
14:56:33 <monochrom> I wonder if maybe "cabal repl", "cabal build", etc, shouldn't support those command line arguments at all. Tell the user "write cabal.project", where it already has an unambiguous syntax.
14:56:53 <monochrom> But that doesn't fly with "cabal configure".
14:58:43 <dminuoso> sim590: Several reasons. For one, I needed MonadUnliftIO. And it was too generic, I need somethingmore custom.
15:02:43 <Lycurgus> is MonadUnliftIO as ugly as it sounds?
15:03:14 <cjay> no
15:03:51 <c_wraith> It really just means "this monad doesn't contain anything interesting other than maybe a ReaderT environment"
15:04:01 <Lycurgus> cuz yall don't do ugly igess
15:04:29 <monochrom> Actually StateT is accomodated too.
15:04:40 <c_wraith> monochrom: not according to the docs or instance list...
15:05:05 <cjay> it only works with IO state
15:05:07 <c_wraith> monochrom: mostly because they couldn't figure out how to make State changes work across a catch.
15:05:47 <c_wraith> (because the state changes are lost on throw...)
15:05:55 <monochrom> Alright, I guess the article talking about it was talking about it hypothetically.
15:06:43 <dolio> Is there some other similar thing that does StateT? I thought someone brought it up the other day.
15:07:10 <c_wraith> there are things like monad-control
15:07:21 <c_wraith> which seem to be out of favor just because people don't understand the StateT problem
15:09:21 <rhit> I never quite figured out what monad-control was about. Is there a short way to describe what problem it solves?
15:10:12 <monochrom> For example forkIO :: IO a -> IO a, but you grow bold and want forkIO :: MT IO a -> MT IO a for your favourite monad transformer MT.
15:10:49 <monochrom> But you're too bold, forkIO makes no sense for most MT's.
15:10:54 <Cale> I don't like monad-control because instances are not unique, and which instance is the one you actually want can be impossible to know when considering all possible higher order functions you might be passed. (and sometimes the answer is even that this shouldn't be allowed)
15:12:11 <Cale> Making a separate class for each higher order operation is usually the saner way forward, because then you can think about what the operation actually means in the context of your monad.
15:13:17 <Cale> (at the cost of writing more instances, of course, but that work represents thought that ought to be taking place anyway)
15:17:49 * hackage polysemy-test 0.2.0.0 - Polysemy effects for testing  https://hackage.haskell.org/package/polysemy-test-0.2.0.0 (tek)
15:21:15 <sureyeaah> how can I create a reverse sorted Map? Is there any other way besides newtyping the key type and manually writing an Ord instance?
15:22:14 <Rembane> sureyeaah: What do you need the Map for? 
15:22:21 <glguy> http://hackage.haskell.org/package/base-4.14.0.0/docs/Data-Ord.html#t:Down
15:22:25 <Cale> There's already such a newtype called Down
15:22:27 <Cale> yeah
15:22:36 <glguy> There's already a newtype for that, though there aren't a lot of good reasons to have a reverse sorted Map
15:23:59 <sureyeaah> Rembane: access to largest element and fast lookup/insertion.
15:24:18 <glguy> sureyeaah: neither of those needs a reverse ordering
15:24:41 <Rembane> sureyeaah: maxView can help you with that. 
15:25:04 <Rembane> sureyeaah: Or findMax, or ... there are some functions that do that kind of thing.
15:25:12 <Rembane> sureyeaah: https://hackage.haskell.org/package/containers-0.6.3.1/docs/Data-Map-Strict.html#g:29
15:26:12 <c_wraith> huh, containers never added pattern synonyms for minView and maxView?
15:26:29 <c_wraith> those felt like the slam dunk case for adding the feature
15:26:55 <Rembane> Doesn't seem so, we can have a PR race. 
15:27:38 <c_wraith> Oh, I suppose there's a potential annoyance with minView vs minViewWithKey and wanting both and then suddenly having a huge proliferation of of new names
15:27:58 <sureyeaah> Rembane, thankss
15:28:12 <Rembane> sureyeaah: No worries. Good luck! 
15:30:14 <sureyeaah> Looks like I accidentally missed a huge section of the documentation before 😅
15:30:48 <c_wraith> oh.  and minView and friends can't be bidirectional patterns.  Ok, I totally understand why they are absent
15:31:35 <Rembane> c_wraith: What properties does something need to have to be a bidirectional pattern?
15:32:28 <c_wraith> They (more or less) have to be bijective.  You can't insert an arbitrary pair into a map as the "least" element in it.
15:32:46 <c_wraith> So while minView is a fine thing, minInsert isn't
15:32:57 <Rembane> That's a very good point. 
16:31:36 <sim590> dminuoso: Chronicle is actually nice. I've just passed through the doc and I like it. If I understand correctly, I can append my log messages by saying for example `dictate [mymessage]` in a list and since the list is a monoid, it will be concatenated with mappend, right?
16:52:30 <lingxiao> hello?
16:53:18 <solonarv> sim590: yes, that's right
17:02:36 <sim590> Alright. Thanks. That's nice. I see that the Writer monad does also just that, but just doesn't provide a bunch of functions to adjust whether actions are stopped or executed if I understand correctly.
17:30:15 <solonarv> yes, Writer has no notion of stopping.
18:36:18 * hackage timezone-detect 0.1.0.0 - Haskell bindings for the zone-detect C library  https://hackage.haskell.org/package/timezone-detect-0.1.0.0 (lfborjas)
18:40:51 <L29Ah> is it possible to ask ghc to make a weakly-typed newtype?
18:41:43 <glguy> L29Ah: You mean 'type' ?
18:41:45 <L29Ah> i want to override a ByteString instance for half of my data structures where a ByteString participates, and i don't want to pepper my code with `coerce`s afterwards
18:42:03 <L29Ah> glguy: no, i can't override instances for type synonyms
18:42:13 <glguy> Then no
18:42:49 * L29Ah wishes for a ByteStringable typeclass ;/
18:42:56 <glguy> You can make that
18:43:10 <L29Ah> yeah and it's as PITA as coerce's
18:43:29 <glguy> o.O then why were you wishing for it?
18:44:04 <L29Ah> it would be good if it already existed and everyone used it instead of concrete ByteString type so i could just have a ByteStringable newtype!
18:49:54 <sanj> Hi everyone,
18:49:54 <sanj> given a [IO (Maybe a)], is there a library function (from base or elsewhere) that can give me back an IO (Maybe a) where:
18:49:54 <sanj> - If any of the IO's fail, it tries the next one in the list (similar to <|>)
18:49:56 <sanj> - If the IO returns a Nothing it also tries the next one in the list
18:49:58 <sanj> - It returns the fist IO that passes with a Just
18:50:00 <sanj> This is similar to asum but, asum does not alternate on the Nothing case (but it does handle the case where IO fails with an IOException and tries the next alternative in the list)
18:50:02 <sanj> I’ve tried this with [MaybeT IO a] but its Alternative instance does not handle the case where IO fails - only the IO Nothing case
18:50:04 <sanj> I can write a custom function to do the above but I was wondering if there was any other function I could be using to do this.
18:58:28 <sanj> Sorry about the spam ^, I'm new to IRC :(
18:58:40 <dolio> I don't think there's anything that will automatically do that.
19:03:24 <kupi> why this function call works? join (Left "error") :: Either String Int
19:03:35 <kupi> Left "error" is not a Monad m => m (m a)
19:03:49 <dolio> :t Left "error" :: Either String (Either String Int)
19:03:50 <lambdabot> Either String (Either String Int)
19:04:40 <kupi> thanks, now i get it
20:07:39 <sim590> Is there a generalization of foldable for structures that can be folded along a path. For instance, I'm thinking about folding along the path from the root of a binary tree to some leaf. I would write the signature like so: `foldPath :: (BSTree a -> BSTree a -> BSTree a) -> (a -> b) -> b -> BSTree a -> b`. So the first argument would be a function deciding what is the next element node to follow
20:07:41 <sim590> to continue folding. The rest of the arguments would be regular foldr arguments. I suspect this could be generalized to Trees (not just binary tree) where the signature would resemble more to: `foldPath :: ([Tree a] -> Tree a) -> (a -> b) -> b -> Tree a -> b`. That's cool, but may be it can be generalized even more and may be this already exists as a data type class?
20:25:28 <hyiltiz> Have you tried implementing it? Sounds awfully like it might just be a composition of a fold and a predicate
20:26:15 <hyiltiz> Not in the sense of pred.fold of course
20:34:49 * hackage shake-futhark 0.1.0.1 - Dependency tracking for Futhark  https://hackage.haskell.org/package/shake-futhark-0.1.0.1 (vmchale)
20:44:14 <sim590> hyiltiz: I am about to do it. I was first researching to know if it already existed.
20:45:50 <sim590> hyiltiz: The thing is that I don't want to fold on all elements of the tree if it's only a path I'm looking for. It would be a difference between O(n) and O(log(n)). I much more prefer O(log(n)). 
20:46:13 <c_wraith> a fold along the lines of a catamorphism would do that
20:46:15 <sim590> And that is for a binary tree. For general Trees, it's even worst.
20:47:28 <sim590> c_wraith: https://wiki.haskell.org/Catamorphisms this ?
20:47:49 <c_wraith> Yes, though I'm not sure that's a particularly good introduction
20:48:48 <c_wraith> Ok, I'm pretty sure that's not a good introduction.  :)
20:50:03 <sim590> :D
20:51:51 <sim590> I have a good background in maths, but I have honestly never done category theory. I've just listened to a course on Youtube by the guy with long hair reminding me a little of Weird Al Yankovic. He likes Category theory.
20:52:13 <c_wraith> Bortosz?  I can't even come close to spelling his last name correctly. :)
20:52:21 <sim590> Yep :D
20:52:22 <c_wraith> This isn't really category theory, though.
20:52:44 <c_wraith> It gets labeled "recursion theory"
20:54:14 <sim590> Hmmm. Alright. It's not something I have done in my bachelor's degree in Maths ;) We've done lots of calculus, real/complex analysis, algebra but no basis for functional programming theory ;) I guess there was no functional programming enthousiast where I studied.
20:54:44 <c_wraith> I mean, it's a pretty different direction in match than the analysis-oriented programs are
20:54:48 <c_wraith> *math
20:54:54 <sim590> Yep
20:56:49 <sim590> Category theory seems to have defined a concept of catamorphism https://en.wikipedia.org/wiki/Catamorphism.
21:01:54 <c_wraith> anyway, a catamorphism is a pattern for tearing down a data structure.  There are things like F-Algebras for generalizing over all of them, but you can write a catamorphism for a specific type completely mechanically from its constructors.
21:02:05 <c_wraith> it turns out foldr is the catamorphism for lists
21:04:04 <c_wraith> if you had a binary tree like  Data BinaryTree a = Leaf | Node a (BinaryTree a) (BinaryTree a), the catamorphism for it would have the type   r -> (a -> r -> r -> r) -> BinaryTree a -> r
21:05:20 <c_wraith> when you have an `r` in a positive position in the type, it represents the result of a recursive call to the catamorphism.  Since haskell is lazy, if you don't use one of them, it means that recursion is never done.
21:06:09 <c_wraith> that lets you consume only one path in a binary tree, if you like.
21:06:23 <c_wraith> (or zero paths.  that's cool too!)
21:07:18 <sim590> Yeah, I just found that the wiki article provides just that example for binary trees.
21:08:20 <c_wraith> like I said, the type (and implementation, after that) are completely mechanical based on the constructors. :)
21:09:14 <sim590> Yes. That's really interresting. How did you learn about catamorphisms?
21:09:21 <c_wraith> hanging out here. :)
21:09:28 <sim590> hehe
21:09:41 <sim590> contagion, therefore.
21:09:47 <sim590> ;)
21:14:29 <slack1256> The presence of "type constructors" such a `Map` on System Fw is used to argue that this is a second order system, as you can quantify over them. But on a second order logic, you can quantify over non-logical terms and predicates (well relations) which are functions between these non-logical terms that return a proposition. In what way then are "type constructors" "predicates" to make System Fw be called second order? "type constructores" take a type/p
21:14:29 <slack1256> roposition and return a type/proposition.
21:14:36 <sim590> Interresting that you were talking about catamorphism as a way to tear down structures since I just finished watching a presentation on contravariant and other super classes of that class. Its job is also about tearing down stuff.
21:33:58 <Graypup_> I currently have a function that pattern matches a string and turns it into an enumeration and now I need one that goes the opposite way
21:34:07 <Graypup_> it would be bad code but I just want to copy paste it and be done with it
21:34:35 <Graypup_> can I do better?
21:35:24 <c_wraith> does it need to be a different string than the derived Show instance creates?
21:36:01 <Graypup_> yep, it turns long "persistent URLs" into an enumeration
21:36:38 <Graypup_> code merely illustrative: https://i.imgur.com/QULH6dB.png
21:37:25 <c_wraith> Except for the Other case, those are just a prefix tacked on to the derived Show instance
21:40:44 <Graypup_> c_wraith, hm, how can I do the other way though?
21:41:50 <c_wraith> stripPrefix + readMaybe
23:29:18 <hyiltiz> Is there a degree of equality, like less equal and more equal? I.e. instead of equal :: a -> a -> Bool, it may be equal' :: a -> a -> [0,1]
23:29:25 <hyiltiz> in CT
