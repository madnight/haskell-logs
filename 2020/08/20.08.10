00:09:49 * hackage functor-combinators 0.3.2.0 - Tools for functor combinator-based program design  https://hackage.haskell.org/package/functor-combinators-0.3.2.0 (jle)
01:41:13 <fraktor> Why do the functions in Data.Set go `function element set` instead of `function set element`? It seems like the latter would be better for partial application.
01:48:04 <koz_> fraktor: It makes 'insert foo . insert bar . insert baz' possible.
01:50:06 <fraktor> I hadn't thought of that.  It does make using sets in higher order functions a little trickier, but `(\x -> func x set)` and `(flip func set)` aren't that bad.
01:50:11 <dminuoso> fraktor: The presence of `flip` or sections makes the argument relatively mood. There's arguments for both ways.
01:50:30 <dminuoso> The authors had to pick one they deemed was more likely to be useful in most common partial applications.
01:50:50 <fraktor> "Relatively mood"?
01:50:56 <dminuoso> *moot sorry
01:50:59 <fraktor> Ah okay
01:51:02 <koz_> Speaking only for myself, the convenience of 'insert foo . insert bar'-style chains is definitely something I've benefitted from many times.
01:51:02 <dminuoso> Also, consider `foldr`
01:51:10 <koz_> That too.
01:51:34 <fraktor> Re: foldr, it seems like it would be more useful to add a lot of elements to a single set than add a single element to a lot of sets
01:51:55 <koz_> :t foldr
01:51:57 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
01:52:13 <koz_> Now consider how insert types when b ~ Set t for some t.
01:52:27 <koz_> s/insert/the function argument/
01:52:36 <dminuoso> % import qualified Data.IntMap as IM
01:52:37 <yahb> dminuoso: 
01:52:49 <fraktor> I could have sworn that foldl and foldr both accepted `(b -> a -> b)` functions.  Huh.
01:52:55 <koz_> fraktor: Nope.
01:52:58 <fraktor> This is what I get for always using foldl.
01:53:06 <koz_> I have to look both of them up all the time because of that.
01:53:12 <fraktor> It turns out that the exact example I was thinking of would be solved by foldr, so nevermind.
01:53:19 <koz_> fraktor: I hope you meant foldl' when you said that. :P
01:53:42 <fraktor> If I don't need strictness, should I always use foldr then?
01:54:07 <koz_> fraktor: It's a slightly trickier thing. It depends at least in part on what you're folding.
01:55:08 <fraktor> Actually wait, what's the difference between foldl and foldl`?
01:55:10 <fraktor> *foldl'
01:56:31 <dminuoso> https://hackage.haskell.org/package/base-4.14.0.0/docs/Data-List.html#v:foldl-39-
01:56:35 <dminuoso> Documentation is a blessing
01:57:30 <dminuoso> One could say that `foldl` is a historic accident, perhaps `foldl'` should have been its implementation instead.
01:57:35 <fraktor> It also occurs to me that if I wanted to partial application, I could just do "`Set.insert` set".
01:57:50 <fraktor> Wow, "if I wanted to partial application."  I think I need to use the sleep.
01:57:52 <dminuoso> fraktor: Like I said. flip and sections make the argument a bit moot. :)
01:58:01 <fraktor> I'm sorry, what do you mean by "sections"?
01:58:11 <dminuoso> fraktor: (`insert` set) is called a section
01:58:17 <fraktor> Interesting.
01:58:43 <dminuoso> The argument order largely becomes more difficult to design with functoins taking more than 2 arguments.
01:59:02 <dminuoso> I mean you can still trivially create adaptor functions that change the order of arguments to suit your need.
01:59:12 <fraktor> IMO it still makes sense to optimize for the common case.  I was just wrong about what the "common case" was.
02:00:04 <dminuoso> fraktor: To be fair, in many cases a choice will annoy the users fitting the other common case.
02:00:35 <dminuoso> But again, flip/sections make it easy to massage binary functions into the shape you need.
02:01:02 <dminuoso> Im regularly annoyed by modifyIORef to have the argument order it has.
02:01:39 <dminuoso> One of my projects is littered with code like `flip modifyIORef f . expr`
02:01:57 <dminuoso> e.g.: pushContext c = Comp $ (flip modifyIORef (c:) . _comp_context) =<< ask
02:02:17 <koz_> My gripe is the order of runWhateverT.
02:02:27 <koz_> Since I often want to 'chain together' multiple such functions.
02:05:49 <alehander92> how long does it take for this code to look natural when reading?
02:06:56 <koz_> alehander92: Which code?
02:13:55 <alehander92> combinations of `$` , `.` and other combinators
02:22:34 <dminuoso> alehander92: Hard to say. But you will get used to it eventually :)
02:23:27 <alehander92> is there a reverse `.` ?
02:23:33 <oxide> >>>
02:23:34 <dminuoso> (>>>) from Control.Arrow
02:23:39 <alehander92> more similar to me object method chanining
02:23:40 <alehander92> ah
02:23:49 <dminuoso> alehander92: I recommend you get used to . though. :)
02:23:56 <alehander92> no, it's not really a problem 
02:24:04 <dminuoso> One good reason for that order
02:24:13 <alehander92> i am just less used to combinations of 2-3 operators
02:24:20 <dminuoso> is such that have this nice `f . g = \x -> f (g x)` shape
02:24:27 <alehander92> yes, it makes sense
02:24:28 <dminuoso> Where the relative position of `f` and `g` remains the same
02:24:29 <alehander92> for haskell
02:25:02 <dminuoso> alehander92: Haskell, allowing you to define operators, has a way of demanding some time to get used to a library until you familiarize yourself with common operators.
02:25:13 <dminuoso> But I think they are great, because they attract more visual attention
02:25:31 <dminuoso> I've grown to like lens/optics operators, because you can visually identify what code does much more quickly. :)
02:25:48 <dminuoso> (Although it could be argued, that it makes it harder to learn them initially)
02:26:07 <alehander92> yes, this sounds like a very subjective design philosophy
02:26:41 <alehander92> i guess it's way more similar to math paper's usage of ops
02:27:11 <dminuoso> Indeed.
02:27:22 <alehander92> i wonder if some kind of language can be applied , some convention
02:28:36 <alehander92> e.g. if an operator is commutative it is written with `<>` , if it has some other property `@` etc
02:28:44 <alehander92> probably would get too messy
02:35:04 <dminuoso> Sure you can apply such a convention.
02:35:32 <dminuoso> However, I think a more fruitful solution would be to follow Agda and just use unicode operators.
02:35:58 <dminuoso> That way you don't have the linear problem of "how do I sensibly encode X properties into the operator, while giving visual clarity what it does"
02:36:23 <dminuoso> At the cost of making it harder to use a library, since you might have to figure out how to even type a given operator.
02:37:01 <dminuoso> This would follow mathematical conventions a bit more, where you might say use greek letters to denote some fact.
02:37:32 <dminuoso> But at that point, I wonder whether this is not rather a tooling question, where the IDE could hilight known properties of a given identifier.
02:39:18 <alehander92> yeahh .. and you can use its name
02:39:31 <alehander92> in some kind of quotes as an alternative and auto-switch
02:39:36 <alehander92> between both representations
02:39:52 <alehander92> which would make it look normal for anti-op people .. eventually
02:58:31 <dminuoso> alehander92: At that point, why not just use alphanumeric names? You can use these as ops with `` :)
02:58:51 <alehander92> yeah ! 
02:58:55 <dminuoso> Then you can use prefixes/suffices of all kinds to denote flavours, like foldl vs foldl'
02:58:56 <alehander92> but some people prefer operators 
02:59:00 <alehander92> that's the thing
02:59:04 <alehander92> having a dual view
02:59:04 <dminuoso> Provide both!
02:59:10 <dminuoso> like, fmap = <$>
02:59:12 <alehander92> ah, just as exports
02:59:24 <alehander92> is this usual in haskell ?
02:59:30 <dminuoso> In point free code, I find fmap to be handy since you can just write `fmap f . g`
02:59:30 <alehander92> to provide a name
02:59:44 <dminuoso> Depends on the library.
02:59:47 <alehander92> this makes sense :)
02:59:55 <dminuoso> lens exports every (sensible) operator as a named version as well
03:00:04 <dminuoso> So you can use ^. or view, whichever you prefer.
03:00:06 <alehander92> i guess most code doesn't look like `. @#^%&!` anyway
03:00:51 <alehander92> awesome
03:11:20 * hackage Spintax 0.3.5 - Random text generation based on spintax  https://hackage.haskell.org/package/Spintax-0.3.5 (MichelBoucey)
03:29:23 <thblt> I'm a bit confused about the status of the `mtl` and `transformers` packages. Are they part of the “standard library” along with base? They seem to be available in my ghci out of the box. 
03:30:40 <thblt> Found it: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/8.10.1-notes.html#included-libraries
03:38:19 * hackage fishfood 0.0.1.11 - Calculates file-size frequency-distribution.  https://hackage.haskell.org/package/fishfood-0.0.1.11 (AlistairWard)
03:39:19 * hackage weekdaze 0.0.0.3, squeeze 1.0.4.19 (AlistairWard): https://qbin.io/hired-pack-ln21
03:42:19 * hackage bishbosh 0.0.0.6 - Plays chess.  https://hackage.haskell.org/package/bishbosh-0.0.0.6 (AlistairWard)
04:14:20 * hackage haskell-ci 0.10.3 - Cabal package script generator for Travis-CI  https://hackage.haskell.org/package/haskell-ci-0.10.3 (phadej)
05:18:41 <manta97> is writing a note taking application in Haskell a bad idea?
05:20:02 <MasseR> It's not
05:20:54 <MasseR> Though, depending on the features you want, it might not be the best fit. Want to make and android app and you're in a world of pain. Want to make a cli app and it's beatifully suited. Or a webapp
05:22:07 <manta97> it would be targeted at students who would otherwise make notes in lectures by writing on pdf printouts by hand or using something like OneNote (i.e. me)
05:22:11 <dminuoso> manta97: Haskell is a general purpose programming language, so it's well suited for most tasks. :)
05:23:02 <dminuoso> It's limitations are a) when you have dependencies on libraries that simply dont exist on hackage or b) when you need to do bare metal in embedded, or c) when you have latency constraints, e.g. in real time applications
05:23:09 <MasseR> manta97: Try to figure out *what* you want it to do, what it should integrate with and check hackage/stackage if there are ready libraries helping you
05:23:14 <dminuoso> If none of these applies, chances are Haskell is just great for whatever you're doing.
05:23:22 <dminuoso> Like any other general purpose language
05:24:32 <manta97> Well I was thinking of making use of markdown in some way and pandoc is written in Haskell but I don't know if that means I should use Haskell for the entire project
05:25:19 * hackage summer 0.1.2.0 - An implementation of extensible products and sums  https://hackage.haskell.org/package/summer-0.1.2.0 (sgschlesinger)
05:25:20 <MasseR> Pandoc is great and its library is really user friendly so there's that
05:27:29 <manta97> Would it make more sense to use another language for the majority of the app and just use pandoc for markdown compilation? 
05:28:34 <MasseR> I'm biased and don't know your requirements, but I would write it in Haskell
05:29:17 <manta97> Okay thanks for your input
05:29:20 * hackage bludigon 0.1.1.0 - Configurable blue light filter  https://hackage.haskell.org/package/bludigon-0.1.1.0 (jumper149)
05:30:04 <manta97> I'd prefer to write it in Haskell as well, if that means it's, say, 20% more effort than writing it in an imperative language then that's no issue but if it's gonna be 3x the effort then it wouldn't be worth it
05:40:55 <gentauro> manta97: "if it's gonna be 3x the effort" only 3x? xD
05:41:19 <manta97> gentauro haha would it really be that bad?
05:41:20 <gentauro> unless you are pretty experienced in Haskell, you might end up using a lot of "learning" time on Haskell projects ;)
05:41:32 <gentauro> manta97: not bad, worse !!! xD
05:42:16 <gentauro> manta97: but you would end up with something robust
05:43:07 <manta97> I'm not very experienced in Haskell, I've got the most experience in Java but I'm not a fan of using it
05:43:30 <gentauro> 14:18 < manta97> is writing a note taking application in Haskell a bad idea?
05:43:38 <xsperry> it is rather ridiculous to count the time it takes to learn haskell 
05:43:40 <gentauro> how much (cross-platform UI) are we talking about?
05:44:06 <gentauro> already there you could use a lot of time :|
05:44:28 <xsperry> and I doubt that's what manta97 meant when asking the question
05:44:36 <sm[m]> would you be shipping easy to install binaries to your users ?
05:44:42 <gentauro> I mean, even terminal apps are pretty difficult to make cos (sometimes) you have to think int Windows and so
05:44:51 <sm[m]> and on which platforms ?
05:44:52 <gentauro> s/int/in/
05:45:12 <gentauro> 14:43 < xsperry> it is rather ridiculous to count the time it takes to learn haskell
05:45:19 <gentauro> I would say it's a never ending story
05:45:34 <gentauro> and don't even get me started on PRAGMAs
05:45:54 <manta97> It's for my final year project so it doesn't have to be amazing/even particularly useful, so I'd imagine it'd just have to work on one platform
05:46:28 <manta97> If I had an original idea for something more suited to Haskell then I'd do that instead but I haven't been able to come up with anything
05:47:29 <sm[m]> Make a much simpler, less important app first and see how it goes ? Or have a backup plan
05:48:05 <manta97> My back up plan is a gui proof tree builder in Java
05:48:16 <sm[m]> pandoc can also be invoked as a binary, you don't have to be in Haskell to use it
05:49:44 <sm[m]> any existing Haskell apps like what you have in mind ?
05:50:31 <manta97> Not that I know of, I have looked though
05:50:31 <sm[m]> iHaskell maybe ?
05:52:59 <sm[m]> Also neuron
05:55:51 <manta97> well
05:55:57 <manta97> I clearly hadn't looked hard enough haha
05:56:05 <manta97> Neuron looks interesting
06:23:47 <kuribas> xsperry: /s/haskell/programming/
06:24:13 <kuribas> xsperry: so, don't count it, just keep learning :)
06:24:50 * hackage blucontrol 0.2.0.0 - Configurable blue light filter  https://hackage.haskell.org/package/blucontrol-0.2.0.0 (jumper149)
06:26:58 <kuribas> xsperry: I am currently programming java, but many of the ideas of haskell apply just as well in java.  The language does get more in the way of applying them.
06:41:01 <sm[m]> manta97: if you search for note at http://hackage.haskell.org/packages/ you'll find a few more things
06:47:14 <Athas> I am using C-c C-l to load a file into haskell-mode.  By the log messages, it is loading the file.  Yet, I cannot call any of the functions inside it.  What's going on?
06:48:19 <Athas> Oh, apparently haskell-mode created two different REPL buffers, and only one of them is actually conneted to my project...
06:53:05 <typetetris> How can I unit test modules from executable in a test-suite? Am I forced to move the module to the library of the package?
07:02:02 <dminuoso> typetetris: Yeah.
07:02:30 <dminuoso> typetetris: it's a common idiom to have `foo`, `foo-lib` and some test package, where foo is a shallow stub package, perhaps with just a single `main = Lib.entry` stanza, or similar.
07:02:57 <dminuoso> s/stanza/binding/
07:06:41 <maralorn> I know of cases with foo-lib (a library), foo-app (a library, but not really meant as one), foo-test (which tests foo-app) and foo (the executable).
07:07:32 <maralorn> Where foo-lib contains binding meant to be used by others and foo-app the rest.
07:07:41 <dminuoso> typetetris: Recall, this can just be an internal (sub) component of a library.
07:19:41 <justsomeguy> Where do you guys like to hang out and read about functional programming news?
07:25:52 <merijn> Here :p
07:26:03 <justsomeguy> :^)
07:26:10 <merijn> /r/haskell is pretty good (well, the submissions, the comments are...hit and miss)
07:26:22 <merijn> haskell-cafe mailing list is good too
07:26:28 <dminuoso> Wow Im so spoiled. async is such a wonderful abstraction :)
07:27:43 <justsomeguy> Hmm... I didn't even consider haskell-cafe. I'll have to give that a shot. (With a new email, because mailing lists intimidate me.)
07:29:09 <merijn> haskell-cafe is fairly quiet, tbh
07:30:25 <phadej> haskell news weekly digest is good
07:30:39 <phadej> https://haskellweekly.news/
07:32:50 <justsomeguy> Neat. If we're talking podcasts, I think corecursive is pretty cool, too.
07:33:13 <phadej> the newsletter
07:33:16 <phadej> podcast is dead, afaik
07:33:16 <frdg> say I have the pair `("foo","bar")`. What is a clean way to concatenate "foo" and "bar"? I feel like I should be able to use a foldable instance here but I am not sure how. If I just do `fold ("foo","bar")` I get back "bar"
07:33:41 <phadej> > foldOf both ("foo","bar") 
07:33:43 <lambdabot>  "foobar"
07:33:47 <phadej> > foldOf each ("foo","bar") 
07:33:49 <lambdabot>  "foobar"
07:33:52 <phadej> "just use lens"
07:34:01 <frdg> ahh ok thanks
07:34:30 <phadej> I wonder if stan warns about using `Foldable` on tuples
07:35:34 <polyphem> justsomeguy: https://haskell.pl-a.net/
07:38:32 <ddellacosta> frdg: alternatively, more or less the same as phadej's solution
07:38:34 <ddellacosta> > ("foo", "bar") ^.. each . traversed
07:38:36 <lambdabot>  "foobar"
07:38:44 <justsomeguy> polyphem: Hey, that's perfect. Everything in one place.
07:43:37 <polyphem> justsomeguy: i got this link from haskell reddit , if you use rss reader you can pull the reddit into there , so you dont have to www :) 
07:53:52 <dminuoso> ddellacosta: It's subtly not the same.
07:54:26 <dminuoso> I mean they produce the same result, but they do different things.
08:00:29 <phadej> > ("foo", "bar" :: Text) ^.. each . traversed
08:00:32 <lambdabot>  error:
08:00:32 <lambdabot>      Not in scope: type constructor or class ‘Text’
08:00:38 <phadej> > ("foo", "bar" :: Data.Text.Text) ^.. each . traversed
08:00:40 <lambdabot>  error:
08:00:40 <lambdabot>      Not in scope: type constructor or class ‘Data.Text.Text’
08:00:40 <lambdabot>      Perhaps you meant ‘Data.Set.Set’ (imported from Data.Set)
08:00:43 <phadej> :(
08:00:47 <phadej> % ("foo", "bar" :: Data.Text.Text) ^.. each . traversed
08:00:47 <yahb> phadej: ; <interactive>:115:9: error:; * Couldn't match expected type `Data.Text.Internal.Text' with actual type `[Char]'; * In the expression: "bar" :: Data.Text.Internal.Text; In the first argument of `(^..)', namely `("foo", "bar" :: Data.Text.Internal.Text)'; In the expression: ("foo", "bar" :: Data.Text.Internal.Text) ^.. each . traversed; <interactive>:115:38: error:; * Couldn't ma
08:01:01 <phadej> % :set -XOverloadedStrings
08:01:01 <yahb> phadej: 
08:01:02 <phadej> % ("foo", "bar" :: Data.Text.Text) ^.. each . traversed
08:01:02 <yahb> phadej: ; <interactive>:117:38: error:; * Couldn't match type `f0 a' with `Data.Text.Internal.Text' arising from a use of `each'; * In the first argument of `(.)', namely `each'; In the second argument of `(^..)', namely `each . traversed'; In the expression: ("foo", "bar" :: Data.Text.Internal.Text) ^.. each . traversed; * Relevant bindings include it :: [a] (bound at <interactive>:117:
08:01:10 <phadej> doesn't work
08:01:11 <phadej> but 
08:01:19 <phadej> % foldOf both ("foo","bar" :: Text)
08:01:19 <yahb> phadej: ; <interactive>:118:29: error: Not in scope: type constructor or class `Text'
08:01:24 <phadej> % foldOf both ("foo","bar" :: Data.Text.Text)
08:01:25 <yahb> phadej: "foobar"
08:01:28 <phadej> works
08:01:48 <phadej> % ("foo", "bar" :: Data.Text.Text) ^.. each . each
08:01:49 <yahb> phadej: "foobar"
08:01:55 <phadej> % :t ("foo", "bar" :: Data.Text.Text) ^.. each . each
08:01:55 <yahb> phadej: [Char]
08:02:13 <phadej> there is plenty stuff to think about ;)
08:04:57 <Marked> Hello guyz.. now I am reading about instances of type classes. I can understand automatic deriving of Show and Eq, But Ord? Why is Nothing less than Just a. How can you order values produced by value constructor? Eg. Person "Albert" "Einstein" 52  and another person?
08:08:44 <ddellacosta> dminuoso: yeah, was trying to acknowledge that with the admittedly hand-wavy "more or less"
08:08:49 <dminuoso> Marked: " The class methods automatically introduced by derived instances of Eq and Ord are (==), (/=), compare, (<), (<=), (>), (>=), max, and min. The latter seven operators are defined so as to compare their arguments lexicographically with respect to the constructor set given, with earlier constructors in the datatype declaration counting as smaller than later ones."
08:09:05 <dminuoso> This is from the Haskell 2010 report, section 11.1 : https://www.haskell.org/onlinereport/haskell2010/haskellch11.html#x18-18300011.1
08:10:00 <dminuoso> And indeed, given the definition of Maybe: data  Maybe a  =  Nothing | Just a
08:10:15 <hseg> ok, reducing my bug, it seems i've misunderstood how backpack wants me to develop against a signature. suppose i have a signature S, how do i write an indefinite package P requiring an implementation of S?
08:10:17 <dminuoso> This seems to hold, since Nothing is mentioned first, it's considered "smaller" than Just.
08:10:25 <hseg> because http://ix.io/2tt0 doesn't seem to cut it
08:13:20 * hackage taskell 1.10.0 - A command-line kanban board/task manager  https://hackage.haskell.org/package/taskell-1.10.0 (smallhadroncollider)
08:19:20 * hackage Rattus 0.3 - A modal FRP language  https://hackage.haskell.org/package/Rattus-0.3 (PatrickBahr)
08:19:45 <justsomeguy> Marked: I think it gets the ordering from what order the data constructors are written in, so "data DumbType = Z | X | Y deriving Ord" will sort "Z" before "X", and "X" before "Y".
08:19:51 <Marked> First language I know that has automatic ordering. Seems dangerous to me 
08:20:30 <merijn> Marked: It's not automatic
08:20:35 <vaibhavsagar> yeah, you're right, fortunately you can always write the instances yourself
08:20:36 <merijn> Marked: You need to explicitly ask for it
08:20:53 <merijn> Marked: You either implement it yourself or ask "please implement it using the default logic"
08:21:44 <justsomeguy> I think you have to use "deriving Ord" in order to get that default logic.
08:21:53 <monochrom> yeah
08:23:39 <Marked> Eh I can't see the forest for the trees.
08:24:18 <Marked> Its optional..of it is...
08:25:10 <merijn> Marked: Nothing is ever automatically derived, you need to explicitly ask the compiler to derive things by writing "deriving (Eq, Ord)" in your datatype definition
08:36:01 <olle> who gave me the tip about functional core, imperative shell? It was a good tip. :)
08:43:25 <mniip> so I've been thinking about this weird pattern for a while now
08:44:13 <mniip> suppose you're in an abstract monad, and you want to have an environment that contains some "hooks"
08:44:30 <mniip> but you want those hooks to happen in your monad
08:45:36 <sm[m]> g'day all. Would anyone have an idea about this new mac CI failure I'm seeing: /Users/runner/.stack/setup-exe-cache/x86_64-osx/Cabal-simple_mPHDZzAJ_2.4.0.1_ghc-8.6.5: /Users/runner/.stack/setup-exe-cache/x86_64-osx/Cabal-simple_mPHDZzAJ_2.4.0.1_ghc-8.6.5: cannot execute binary file ? 
08:45:38 <mniip> so you're looking at something along the lines of  data Env m = Env { hook :: A -> m B };  MonadReader (Env m) m
08:45:48 <mniip> except there's a weird recursion going on
08:48:28 <mniip> like you need to be really clever about how you lift this "effect" through other transformers
08:52:22 <mniip> I have a library that I should probably push to hackage...
08:52:43 <mniip> but I'm wondering if anyone came across a similar problem and has a simpler solution
08:54:39 <dolio> It seems like the simpler solution is to not try to describe this as a MonadReader where the environment depends on the monad.
08:59:28 <dolio> Because for instance, none of the usual transformers maintain this circular relationship. They will result in a `MonadReader (Env m) (T m)`.
09:04:08 <monochrom> mniip: I ran into this when writing http://www.vex.net/~trebla/haskell/cont-monad.xhtml  (scroll down to the "Exception" section)
09:04:37 <monochrom> (and further scroll down to around "type RSC" :) )
09:05:35 <monochrom> tl;dr I wanted to use Cont to throw and catch exceptions; furthermore I wanted the in-scope exception handler to be ReaderT's env.
09:05:44 <mniip> right
09:05:55 <mniip> that sounds like a special case of what I'm trying to do
09:06:00 <mniip> sort of like a "panic hook"
09:06:24 <monochrom> It is a bit telling that RSC and Thrower are in a mutual recursion.
09:06:46 <monochrom> I have forgotten the "more advanced solutions".
09:08:34 <monochrom> Maybe I had fundep in mind.
09:09:33 <monochrom> It couldn't possibly be type families because I wrote it a long time ago, type families didn't exist, datakinds didn't exist, nothing existed.
09:23:25 <mniip> there
09:23:49 * hackage monad-introspect 0.1.0.0 - A reader monad that gives the environment access to the entire transformer stack  https://hackage.haskell.org/package/monad-introspect-0.1.0.0 (mniip)
09:26:02 <mniip> monochrom, if you don't mind taking a look at https://github.com/mniip/monad-introspect/blob/master/src/Control/Monad/Introspect/Class.hs and https://github.com/mniip/monad-introspect/blob/master/src/Control/Monad/Trans/Introspect.hs
09:28:19 <mniip> the commutation story is weird
09:28:52 <mniip> IntrospectT IdentityT Env MaybeT   provides the same effect as    MaybeT (IntrospectT MaybeT Env Identity)
09:29:07 <mniip> hence the extra argument
09:54:33 <MarcelineVQ> monochrom: and then evenmtually some things existed, and it was good for awhile, and then most things died from overoxygenation, and that wasn't as good, and then things got better and was good for awhile, and then a big asteroid meteo'd the planet and things were shitty for a bit again, and then things got a litte better again and bread was invented
09:58:17 <monochrom> haha
10:09:25 <MarcelineVQ> Rembane: I wasn't able to find where I learned to put the Build case as a constructor to pair with the relevant catamorphism (like foldr)
10:54:32 <fog> im trying to design a hetrogenous tree as a GADT and im having trouble understanding how to structure the type parameters
10:55:41 <fog> each node is supposed to have a type level name (Symbol) and a list of types that are stored at the node
10:55:49 * hackage nom 0.1.0.2 - Name-binding & alpha-equivalence  https://hackage.haskell.org/package/nom-0.1.0.2 (gabbay)
10:56:10 <fog> because it needs also to store the lower branches, it needs a kind of tree to store the type parameters for these
10:56:43 <fog> and im getting confused between how to store the labels at each node, and the types needed for the branches
11:03:07 <merijn> MarcelineVQ: pfft, as far as grain based products involving yeast go, breaad is overrated...
11:03:29 <MarcelineVQ> Not my bread
11:03:48 <merijn> MarcelineVQ: Even my homemade bread is overrated :p
11:04:11 <MarcelineVQ> Well yeah, yours is :>
11:04:20 <merijn> beer and whisky > bread :p
11:04:59 <MarcelineVQ> just wait, someone gonna come in and start talking up their home-made penecillin
11:05:55 <merijn> That's not grain based, though :p
11:06:19 <MarcelineVQ> hey fam, heard you think beer is great, did you know that without bread we wouldn't have the pyramids or self-driving cars?
11:06:42 <merijn> beer was a crucial part of the pyramid building diet!
11:08:16 <Marked> Seems  that :: is not a function right? So I can not chain it with . 
11:09:23 <monochrom> haha pyramid building diet
11:11:24 <MarcelineVQ> Right, it's not a function, just syntax. It can be read as 'has type of'     3 :: Int     3 has type of Int
11:13:32 <Polesch> How do I check if a character is in a string or list in haskell? Something like "c in ['a' .. 'z']" that would output True
11:13:43 <Marked> Is there function alternative?
11:14:24 <merijn> :t elem -- Polesch 
11:14:26 <lambdabot> (Foldable t, Eq a) => a -> t a -> Bool
11:16:41 <Polesch> Ah yes, finally, it was those pesky ` `
11:37:24 <tomsmeding> Marked: how would you expect :: to work as a function?
11:39:13 <ClaudiusMaximus> i'd like  (:: t)  to be the same as  (id :: t -> t)
11:39:36 <tomsmeding> `asTypeOf` (undefined :: t)
11:39:37 <tomsmeding> maybe?
11:41:25 <tomsmeding> not that I'm saying that using 'undefined' is good style :p
11:42:10 <monochrom> "::" does not work as a function. But asTypeOf can help.
11:42:12 <tomsmeding> with TypeApplications you could use id @t
11:42:19 <tomsmeding> if you must
11:42:28 <merijn> It's not a crazy idea
11:42:36 <merijn> Lennart has suggested making :: work as a function
11:42:47 <dolio> At some point (:: t) doing that was suggested. I guess it never made it in?
11:42:51 <monochrom> But "... asTypeOf (undefined :: X)" defeats the point of avoiding ::
11:43:15 <tomsmeding> monochrom: but that expression can be put in a (.) chain, which I think Marked was asking about
11:43:26 <monochrom> Why do programmers create so many XY problems for themselves?
11:43:39 <monochrom> In fact, self-defeating XY problems, even.
11:43:47 <merijn> monochrom: Play conditioning ;)
11:44:19 <monochrom> What is play conditioning?
11:45:21 <merijn> monochrom: A term coined in talking about game design about how games *implicitly* teach you to play, i.e. how does the combination of game mechanics + human intuition/instinct result in. Most notably discussed in cases where the game is inadvertently teaching people to play "the wrong way"
11:45:56 <dolio> Who said anything about avoiding ::?
11:46:32 <merijn> monochrom: i.e. you discover trick A, which helps you in the immediate scenario, but teaches you bad habits for the long term, but the immediate utility causes them to get ingrained and never re-examined, despite being suboptimal
11:46:57 <wavemode> that's how tennis is
11:47:14 <merijn> monochrom: That's how most XY problems arise. "I've learned hack X to tackle issue Y, therefore I should always use hack X any time I can, whether it's actually helpful or useful, because I know it works!"
11:54:46 <ixlun> Hi all. I was wondering if someone could help me with Cabal? I'm trying to start out with it and thought I'd try and create a simple program that uses CmdArgs.  I've listed it in my .cabal.  However when I try cabal new-run I get an error saying that the module could not be found.
11:55:13 <ixlun> Correct me if I'm wrong but AFAICS the new-run command should pull in the package dependencies locally
11:56:03 <monochrom> Please post actual files.
11:56:30 <monochrom> Lest the blanket answer would be "worksforme can't reproduce".
11:57:24 <merijn> Well, one problem would be that ther is no CmdArgs package :p
11:57:39 <merijn> There is a cmdargs package, of course
11:57:51 <monochrom> See, my experience is that we can't even trust them when they use the words "module" and "package".
11:58:12 <phadej> true minimilists use https://hackage.haskell.org/package/base-4.14.0.0/docs/System-Console-GetOpt.html
11:58:12 <monochrom> And BTW we also can't trust them on upper and lower cases.
11:59:52 <ixlun> cabal file: http://ix.io/2tP6  Main.hs: http://ix.io/2tP7   error: http://ix.io/2tP9
12:00:00 <merijn> monochrom: That was my point, yes
12:00:19 <merijn> Also new-run suggest a fairly old cabal-install
12:01:13 <merijn> ixlun: Looks like your cmdargs installation is broken
12:01:22 <merijn> ixlun: Are you perchance using arch?
12:01:44 <ixlun> merijn: Indeed I am
12:01:48 <merijn> ding ding
12:01:57 <merijn> and my streak of "broken installs == arch" continues
12:02:07 <merijn> ixlun: Did you install cmdargs via arch's package manager?
12:02:09 <monochrom> heh
12:02:24 <monochrom> I'll pull up the relevant link about archlinux.
12:02:38 <monochrom> https://wiki.archlinux.org/index.php/Haskell#Problems_with_linking
12:02:46 <merijn> ixlun: Arch's package for Haskell are irreversibly fucked and you should not ever use them for *anything*
12:02:58 <ixlun> merijn: I didn't explicitly install it but it does appear as though something has pulled it in
12:04:20 <ixlun> Ahh okay will give that link a look.  I did think the v2-* or new-* commands essentially made the package dir a sandbox?
12:05:02 <monochrom> Yes "essentially" (bendable word).
12:05:12 <merijn> ixlun: The problem is that Arch maintainers for some reason insist on "always use dynamic linking for libraries", this is a bad default in haskell, but they refuse make an exception
12:05:44 <merijn> ixlun: cmdargs is installed, but only the dynamic libs and not the static ones, because Arch. The default mode of operation for GHC and cabal-install is...static linking
12:05:57 <sm[m]> haskell love conference videos have landed: https://www.youtube.com/watch?v=JbeqwfZ2dRc&list=PLBqWQH1MiwBSK9wuaATNS701c43VYVTuc
12:06:15 <ixlun> merijn: Ahh I bet that's frustrating!
12:06:19 <ixlun> Sorry for the noise
12:06:26 <merijn> ixlun: So cabal-install sees "oh, the right version is installed, I don't need to do anything!" and then when GHC tries to actually use the installed package it suddenly notices "hey, the static lib is missing, the install must be broken!"
12:06:51 <monochrom> w00t thanks sm[m]
12:07:02 <tomsmeding> ixlun: 'pacman -Qi ghc' should show what system package depends on ghc
12:07:09 <tomsmeding> likely candidate: pandoc
12:07:24 <tomsmeding> tip: ghcup works well
12:07:48 <tomsmeding> ixlun: correction, 'pacman -Qi ghc-libs'
12:07:54 <Polesch> What is this function doing? "all (\x -> x `elem` ['a'..'z']) a" is it not checking if a contains all lowercase letters in the English alphabet?
12:08:03 <sm[m]> or so it was announced to me, but I think this is only one of the two rooms/days :-/
12:08:13 <sm[m]> I don't see tekmo's excellent marketing talk
12:08:17 <tomsmeding> Polesch: that's what it seems to be doing
12:08:34 <tomsmeding> > all (\x -> x `elem` ['a'..'z']) "lowercase"
12:08:36 <lambdabot>  True
12:08:42 <Polesch> ah
12:08:54 <Polesch> I got it the other way around
12:09:13 <xsperry> or slightly shorter:
12:09:18 <xsperry> > all (`elem` ['a'..'z']) "lowercase"
12:09:20 <lambdabot>  True
12:09:33 <tomsmeding> or with Data.Char:
12:09:37 <tomsmeding> > all isLower "lowercase"
12:09:39 <lambdabot>  True
12:09:48 <Polesch> What I actually want is the reverse
12:09:58 <tomsmeding> @t notElem
12:09:58 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
12:10:24 <xsperry> > all (not . (`elem` ['a'..'z'])) "lowercase"
12:10:26 <lambdabot>  False
12:10:29 <tomsmeding> % :t notElem
12:10:29 <yahb> tomsmeding: (Foldable t, Eq a) => a -> t a -> Bool
12:10:58 <xsperry> which is just isUpper, but I'm guessing this was just a test case
12:11:08 <MarcelineVQ> > all (`elem` ['A'..'Z']) "lowercase" -- :>
12:11:10 <lambdabot>  False
12:11:29 <Clint> > all isLower "esacrewol" -- he said reverse
12:11:31 <lambdabot>  True
12:11:35 <tomsmeding> fair
12:11:54 <Polesch> Not that type of reverse, I want to check if the string or "a" contain all elements in ['a'..'z']
12:11:56 <tomsmeding> > reverse . show . all isLower $ "lowercase"
12:11:58 <lambdabot>  "eurT"
12:12:25 <tomsmeding> Polesch: can it contain duplicates?
12:12:31 <Polesch> sure
12:13:23 <tomsmeding> > [] == ['a'..'z'] \\ "the quick brown fox jumps over the lazy dog"
12:13:25 <lambdabot>  True
12:13:30 <tomsmeding> where \\ is from Data.List
12:13:53 <Polesch> Not sure I like this solution but I'll read up on it
12:14:03 <tomsmeding> it might not be the fastest :p
12:14:11 <ixlun> tomsmeding: Thanks for the ghcup tip... Seems to be working great! :-)
12:14:20 * hackage myxine-client 0.0.1.0 - A Haskell client for the Myxine GUI server  https://hackage.haskell.org/package/myxine-client-0.0.1.0 (kwf)
12:14:22 <tomsmeding> ixlun: \o/
12:14:32 <monochrom> \∩/
12:14:32 <maerwald> \o/
12:14:43 <tomsmeding> Polesch: (and, well, ([] ==) == null)
12:15:19 <monochrom> null is better than ([] ==).
12:15:34 <monochrom> ([] ==) incurs an Eq requirement you don't need.
12:16:30 <xsperry> Polesch, just reverse the strings then
12:16:38 <Clint> you need it for (\\) though
12:16:45 <xsperry> reverse the arguments
12:16:50 * hackage ipfs 1.1.2 - Access IPFS locally and remotely  https://hackage.haskell.org/package/ipfs-1.1.2 (expede)
12:16:58 <MarcelineVQ> > (map head . group . sort . filter isAlpha $ "the quick brown fox jumps over the lazy dog") == ['a'..'z'] -- idk lol
12:17:00 <lambdabot>  True
12:17:04 <Polesch> After reading about \\ I kind of like the solution
12:17:36 <tomsmeding> > all (`elem` "the quick brown fox jumps over the lazy dog") ['a'..'z']  -- courtesy xsperry 
12:17:38 <lambdabot>  True
12:17:49 <hyperisco> If I have an inductively defined relation  R (a :: 'A) (b :: 'B)  is it possible to determine if, given a function  f :: A -> B  , there is a function  g :: (a :: A) -> R a ('f a)  ?  I am using dependently typed notations but you can substitute for the Haskellisms
12:18:47 <tomsmeding> both my \\ solution and xsperry's elem solution have complexity O(26 * length)
12:19:15 <xsperry> use Data.Set if you want it to be more efficient
12:19:42 <tomsmeding> MarcelineVQ 's solution probably has a higher constant factor for small strings but has complexity O(length * log(length) + 26)
12:19:44 <hyperisco> Also, we're allowed to look inside the definitions, so consider this from a meta or compiler perspective
12:19:52 <MarcelineVQ> Mine's just sillyness
12:20:09 <tomsmeding> MarcelineVQ: I wouldn't be surprised if it's faster than a Data.Set-based solution though
12:20:35 <xsperry> it'll probably be slower when it matters, though
12:21:12 <tomsmeding> oh wait the Data.Set one would be O(length * 26 * log(26))
12:21:18 <tomsmeding> that's quite nice
12:21:54 <tomsmeding> fail
12:21:59 <tomsmeding> O(length * log(26) + 26)
12:22:01 <monochrom> x `elem` ['a'..'z'] = x >= 'a' && x <= 'z'
12:22:20 <monochrom> This decreases 26 to 2.
12:22:25 <hyperisco> meh I'll move this to -offtopic
12:22:31 <tomsmeding> hyperisco: :( sorry
12:22:45 <tomsmeding> monochrom: no, because Polesch's alphabet is the input string, not a..z :)
12:23:01 * monochrom cries
12:23:03 <hyperisco> not your fault… I am asking something that doesn't relate to normal Haskell all that well
12:23:29 <monochrom> then BST or hashing is in order, yes.
12:23:32 <Polesch> Sorry for my bad explanation of the problem :P
12:23:32 <monochrom> (haha pun!)
12:23:42 * tomsmeding \o\
12:24:06 <MarcelineVQ> quick, someone come up with a pun about hashing being used for unordered containers
12:24:46 <monochrom> also let's bloom-filter it for good measure. (pun: probability theory is a measure theory!)
12:24:57 <MarcelineVQ> Are you sure?
12:25:03 <monochrom> haha
12:25:15 <tomsmeding> > sort ["BST", "hashing"]
12:25:17 <lambdabot>  ["BST","hashing"]
12:25:21 <tomsmeding> it was in indeed in order
12:26:17 <tomsmeding> also this is probably not what you want here except if you're really dying for performance, but you can get it in O(length + 26) using a mutable array in ST
12:26:29 <MarcelineVQ> > unwords . sort . words $ "<monochrom> then BST or hashing is in order, yes."
12:26:29 <tomsmeding> less function less log
12:26:31 <lambdabot>  "<monochrom> BST hashing in is or order, then yes."
12:26:54 <tomsmeding> it's not even completely incomprehensible
12:29:37 <tomsmeding> hyperisco: if your 'f' is not guaranteed total, then general turing completeness issues arise and you can't prove everything
12:30:13 <hyperisco> tomsmeding, assume totality then
12:32:14 <tomsmeding> hyperisco: I feel that there should be counterexamples
12:32:25 <tomsmeding> even total functions are too powerful
12:32:52 <hyperisco> I am looking for any leads on the problem, so if you know of something please let me know
12:33:26 <tomsmeding> say A = B = Natural, and R is defined by R 0 0 and R n n -> R (n+1) (n+1)
12:34:04 <tomsmeding> there must be some function f :: Nutural -> Natural that's empirically always id, but we don't know how to prove that it is
12:34:38 <hyperisco> you are allowed to inspect the definition of f
12:34:46 <hyperisco> as well as R
12:34:53 <tomsmeding> I invoke an obscure mathematical function connected to an unsolved conjecture
12:35:32 <hyperisco> if we're saying f is total (and I think that is a reasonable restriction) then you must have that proof already
12:36:55 <tomsmeding> total means that you can compute in finite time what f produces on a particular input, but I don't think it necessarily means that you can also prove statements of the form 'forall n. P (f n)' for certain predicates P
12:37:54 <hyperisco> what I was assuming was that solving unsolved problems could be stated as a proof of totality
12:38:02 <monochrom> Since dependent typing was mentioned, I interpreted the question as one set in CoC or type theory. So perhaps f comes with a proof of totality. One doesn't just walk into Mordor and assert "f : A -> B" without that. :)
12:38:12 <monochrom> (Sorry for calling it Mordor!)
12:38:27 <dolio> This conversation seems like it's too imprecise.
12:38:28 <MarcelineVQ> Know why it was called that?
12:38:38 <MarcelineVQ> It only had 2 entrances.
12:38:43 <hyperisco> it is the wrong conversation, is why
12:39:02 <hyperisco> I cannot argue this or that about it, I am just looking for leads… restrict R and f as much as you need to say "look here"
12:39:42 <monochrom> Hahaha MarcelineVQ I get it now
12:40:05 <tomsmeding> -.-
12:40:31 <hyperisco> MarcelineVQ, the fire marshal would have never allowed all the forces of evil in
12:40:54 <hyperisco> and served them right didn't it
12:41:14 <MarcelineVQ> "fire marshal bill would never have allowed this giant flaming eye, that's for darn sure!"
12:42:47 <tomsmeding> hyperisco: what if A = B = Natural, R is the relation I gave above (only R n n), and f :: Natural -> Natural maps n to n+1 if n is an odd perfect number, and n otherwise
12:43:14 <tomsmeding> I'm now claiming that one can compute in a total function whether a number is a perfect number
12:43:36 <tomsmeding> now no matter how much you know about those definitions, proving whether your 'g' exists amounts to proving whether there are any odd perfect numbers -- which is an unsolved problem
12:44:36 <tomsmeding> which is certainly an indication that deciding whether such a 'g' exists in general may be a very hard problem
12:44:48 <tomsmeding> (though I've proven nothing here)
12:45:17 <hyperisco> I've essentially failed if it isn't hard… let me think
12:45:21 <tomsmeding> (I found this example by just randomly going through the venerable https://en.wikipedia.org/wiki/List_of_unsolved_problems_in_mathematics)
12:45:49 <dolio> See, this is why this conversation is too imprecise.
12:46:09 <dolio> You've described a function, but part of the problem is that you're also given an algorithm for computing the function.
12:46:28 <tomsmeding> dolio: who is "You"?
12:46:35 <dolio> You.
12:47:08 <tomsmeding> where have I given an algorithm to compute a function?
12:47:23 <hyperisco> that is f
12:47:25 <dolio> That was part of the original problem, but the wording was imprecise.
12:47:28 <tomsmeding> I'm just trying to construct a counterexample to hyperisco's claim
12:47:48 <dolio> Because there is a difference between functions and algorithms for computing them.
12:48:00 <tomsmeding> sure
12:48:04 <monochrom> tomsmeding, you're probably working in classical logic, whereas hyperisco is working in a constructive logic.
12:48:27 <tomsmeding> but I'm constructing the (potential) counterexample, so I can choose the inputs that hyperisco's imaginary algorithm gets, including the algorithm for computing f
12:48:28 <tomsmeding> :p
12:48:39 <hyperisco> tomsmedings
12:48:44 <hyperisco> example is fine, I get it
12:49:17 <tomsmeding> monochrom: I believe the validity of my statements is fine in constructive logic, though it's late :p
12:49:22 <tomsmeding> hyperisco: :D
12:50:21 <dolio> Using an unsolved problem is not really convincing, though. You need an unsolvable problem.
12:50:30 <tomsmeding> very true
12:50:46 <hyperisco> it is sufficient for me because I need this solution to be already solved :)
12:50:59 <tomsmeding> hyperisco: still no guarantee, but strong indication
12:52:11 <hyperisco> I am not savvy on all the ways there are to prove a function is total. I want to ask, though, how many total functions are there in relation to how many provably total functions there are?
12:52:11 <dolio> However, unsolvable problems are going to be harder to produce algorithms for the input function, I think.
12:53:23 <tomsmeding> okay new try: let f interpret its input as a Gödel number of an expression in a logic of your choosing, and let f return its input if that expression is valid and proves p ʌ ¬p, or input+1 otherwise
12:53:33 <tomsmeding> then Gödel's incompleteness theorem suffices?
12:53:42 <tomsmeding> it's quite heavy-handed though :p
12:54:17 <tomsmeding> where "logic of your choosing" is of course a logic in which type checking is decidable, and thus doable with a total function
12:54:27 <tomsmeding> that includes ZFC and constructive logic, which should be enough :p
12:54:59 <dolio> Give an algorithm for f.
12:55:24 <hyperisco> okay, so you are saying there should be some way to state this question in terms of Godel incompleteness, and arrive at the conclusion that given any method of proving totality there will be total functions that are unprovable using that method?
12:55:57 <hyperisco> I think I am saying "method" where you are saying "logic"
12:56:06 <tomsmeding> dolio: https://github.com/MaiaVictor/calculus-of-constructions
12:56:09 <tomsmeding> ¯\_(ツ)_/¯
12:56:40 <monochrom> javascript aaaaaiiiiiieeeee
12:56:48 <hyperisco> and now is dolio saying there is no way to actually construct f
12:56:56 <tomsmeding> hyperisco: with "logic" I mean what axioms you want to use to prove your theorem, which may be e.g. ZFC or CoC
12:57:01 <monochrom> I just mean it must have been so painful for the author :)
12:57:09 <dolio> I didn't say that. I said prove it, don't just wave your hands.
12:57:21 <tomsmeding> dolio is claiming I'm bluffing and such an f doesn't actually exist
12:57:23 <monochrom> I also know of a tableaux proof generator written in javascript.
12:57:42 <tomsmeding> I concede that I don't have a ZFC proof checker handy
12:57:53 <dolio> I mean, the example is not great, because 'a logic of my choosing' may not be subject to the incompleteness theorem, for instance.
12:57:54 <monochrom> https://www.umsu.de/trees/
12:58:01 <tomsmeding> but isn't the entire point of the usual mathematical logics that proof checking is decidable?
12:58:06 <tomsmeding> and _especially_ CoC
12:58:11 <dolio> Or it may be weaker than the logic in which the algorithm for `f` is given.
12:58:17 <tomsmeding> dolio: okay choose calculus of constructions
12:58:36 <hyperisco> okay, so everything here is in doubt… I'll read more on this
12:59:05 <hyperisco> I brought up this question as an analogy to the original
13:00:14 <dolio> Okay, and you've proved the JavaScript implements a total function?
13:00:36 <tomsmeding> I certainly have not, but let me see
13:01:04 <dolio> Is JavaScript even the specification language in hyperisco's original problem?
13:01:42 <tomsmeding> no!
13:01:47 <tomsmeding> and I'm also not writing a paper :p
13:01:54 <tomsmeding> hyperisco was asking for leads, remember? :)
13:02:16 <tomsmeding> this is a sketch of how a proof might go, not an attempt to write a rigorous proof directly
13:02:28 <hyperisco> the lead right now is Godel incompleteness, which last time I tried to understand it seemed rather dense
13:03:15 <dolio> Well, there was a sketch of how it was impossible to write self-interpreters for total languages. Proofs, even. Then someone wrote one by slightly relaxing the assumptions on what counts as a self-interpreter.
13:03:31 <MarcelineVQ> Is it of note that hyperisco has stated all their definitions are inspectable? Doesn't this mean we can work from a meta viewpoint, the next step up in godel level?
13:03:37 <dolio> So, my point is, you need to get detailed and specific, or questions like these may have different answers depending on those details.
13:03:43 <tomsmeding> hyperisco: actually, I was referring to what wikipedia lists as the "gödel's second incompleteness theorem"
13:04:00 <hyperisco> MarcelineVQ, yes
13:04:02 <MarcelineVQ> meaning, we're in complete territory
13:04:39 <Cale> hyperisco: I'm just looking back at your original question, what do you mean by "is it possible to determine if"?
13:05:02 <Cale> You want to write a function of type
13:05:23 <dolio> And 'it kind of sounds like the incompleteness theorem' is way over-applied.
13:05:28 <hyperisco> Cale, I want to determine if g exists or not
13:05:37 <dolio> Because that's the obvious angle on self-interpreters.
13:05:43 <Cale> (f : A -> B) -> Dec ((a : A) -> R a (f a))
13:05:43 <MarcelineVQ> tomsmeding: did you know there's a ##dependent channel? that's just a name, all kind of language and theorem stuff comes up there
13:06:16 <Cale> hyperisco: R might be empty for some a : A, and it might be undecidable that it is empty
13:06:18 <hyperisco> Cale, I am not familiar with Dec but probably, yes
13:06:19 <tomsmeding> MarcelineVQ: I always feel kind of intimidated in the company of people that join that kind of thannel
13:06:36 <MarcelineVQ> Well I'm in there so you can relax, because I'm a moron
13:06:40 <Cale> Dec p is like  Either (Not p) p
13:06:44 <tomsmeding> :D
13:07:24 <Cale> i.e. it's like Maybe, but you have to supply a proof that no such thing exists if you don't provide one
13:08:49 * hackage proto3-wire 1.2.0 - A low-level implementation of the Protocol Buffers (version 3) wire format  https://hackage.haskell.org/package/proto3-wire-1.2.0 (rashad1030)
13:09:49 <dolio> Not literally that type, though.
13:10:19 <dolio> Because that accepts as input only a function, not an inspectable algorithm for the function.
13:11:10 <Cale> Well, that's kind of at the heart of what I was asking
13:11:19 <hyperisco> Cale, by empty you mean it cannot be constructed? It may be undecidable but that is the question being asked… and more specifically, if it is undecidable, what is the landscape of smaller classes of functions and/or relations for which it is decidable?
13:13:08 <Cale> hyperisco: The easiest thing would just be to equip your relation with whatever decision procedures you actually need :P
13:13:22 <tomsmeding> right, if it is undecidable whether, for a particular annoying a : A, the statement '\exists b : B . R a b' is undecidable, that's an alternative way to disprove hyperisco's claim
13:13:48 <Cale> i.e. just take a dependent sum of the relation with whatever function makes whatever decision about it you like, so the user will have to provide it to you
13:13:50 <tomsmeding> but then how would such a R,A,B look
13:14:10 <maerwald> the yaml package is witty... it has this funny side effect that I can feed it both json an yaml and it will be fine with either
13:15:32 <merijn> maerwald: Eh, that's required by the yaml spec
13:15:38 <maerwald> oh, is it?
13:15:41 <merijn> iirc
13:15:49 <maerwald> surprising
13:16:00 <merijn> maerwald: The YAML matrix suggests so: https://matrix.yaml.io/
13:16:05 <hyperisco> Cale, I'm the user :P
13:16:16 <merijn> See all the json entries
13:16:45 <hyperisco> okay thanks, I'll do some reading
13:17:19 <maerwald> I'm starting to like yaml
13:17:36 <Uniaika> maerwald: we will send a relief team at your home
13:17:44 <merijn> I think it's too late
13:17:53 <maerwald> xD
13:17:55 <merijn> Better make it a "cleanup" team
13:18:08 <maerwald> anchors are awesome too :p
13:19:12 <ADG1089> > State (([a], [a])) :> []
13:19:14 <lambdabot>  error:
13:19:15 <lambdabot>      • Data constructor not in scope: State :: ([Expr], [Expr]) -> a
13:19:15 <lambdabot>      • Perhaps you meant one of these:
13:19:19 <ADG1089> >:t  State (([a], [a])) :> []
13:23:24 <Cale> hyperisco: Yeah, but then, once the types of things are closer to being specified, you'll have a more specific question to answer for yourself, and it will perhaps be answerable in a concrete way then
13:25:22 <hyperisco> Cale, maybe a simpler question to start with is if a relation can be decided as functional or not
13:29:45 <ezzieyguywuf> are there any problem domains where you would prefer an OOP approach rather than an FP approach?
13:30:13 <maerwald> ezzieyguywuf: I think Linus once said "filesystems"
13:30:22 <merijn> ezzieyguywuf: Depends how you define OOP too
13:30:33 <maerwald> as the only application of OOP he could think of
13:30:40 <maerwald> but GUI is another
13:31:23 <maerwald> you have lots of things that are similar and behave similar and are extensions of one another
13:31:28 <maerwald> haskell is not good in expressing that
13:32:00 <maerwald> subtyping isn't nice here and extensible records etc a pain
13:32:08 <ezzieyguywuf> i see
13:32:18 <ezzieyguywuf> I guess I define OOP as classes with inheritance
13:32:24 <maerwald> structural typing could be a substitute for some OOP applications
13:32:36 <hyperisco> ezzieyguywuf, so far, the only time I've wanted subtyping is when binding to foreign code that uses subtyping
13:32:58 <maerwald> and see... that's why TypeScript is popular
13:33:36 <maerwald> bc in frontend, it's nice... even in haskell it would be, when you have "web types" in your backend that are 90% the same as some internal ones
13:33:41 <maerwald> no nice way to express that
13:35:47 <hyperisco> I don't think GUI is such a great example because GUI intrinsically (at least in the way we're probably thinking of it here) isn't a good example of programming
13:36:30 <maerwald> it's a great example
13:36:43 <maerwald> bc it's the only domain where the concept of OBJECT makes actual sesne
13:39:42 <maerwald> for everything else, it's usually abuse of state, contextful programming or poor mans message passing
13:40:37 <fog> what!?
13:40:52 <fog> "contextful" ?
13:40:59 <maerwald> a made that up
13:41:04 <maerwald> *I
13:41:13 <fog> oh, what to mean?
13:41:40 <maerwald> we were talking about applications of OOP
13:41:54 <fog> i guess when you say "abuse of state", your trying to hide some kind of coms in the environment?
13:42:23 <fog> im just wondering why you think thats worse than MMP?
13:42:39 <fog> MPP*
13:43:14 <fog> derp, MPI
13:43:40 <fog> confused message passing interface with message parsing programing
13:43:46 <fog> which isnt a thing...
13:44:03 <maerwald> yes, but now it's implicit... ppl don't even know they are doing it
13:44:11 <maerwald> and don't design it accordingly
13:44:15 <maerwald> it's now all ad-hoc
13:44:26 <fog> but yeah, for alternative concurrency models, whats wrong with global variables, which is i guess what your emulating with a monadic state
13:44:51 <fog> why would you favour something like actor models, with coms nodes?
13:45:17 <fog> whats implicit?
13:45:24 <maerwald> the MPI
13:45:32 <maerwald> the distributed system design
13:45:39 <fog> like, all just in IO or something?
13:45:44 <fog> using IORefs?
13:45:50 <maerwald> I'm talking about OOP :p
13:45:59 <fog> oh, idk what that means in this context
13:46:05 <fog> objects like actors?
13:46:41 <maerwald> you've all sorts of object communicating with each other, but you're not reasoning about all this as a state-machine or a distributed system
13:46:54 <maerwald> that's one of the main pitfalls of OOP
13:47:18 <hyperisco> what is the feature list of OOP? I was just going off subtyping… if we're adding state too then I am even less sure
13:47:27 <maerwald> like... imagine you write haskell code, but you fail to realise your functions are pure
13:47:38 <maerwald> it would turn weird
13:48:07 <fog> are you saying people forget they are objects?
13:48:20 <maerwald> most OOP code is state machinery without ppl realising it
13:48:31 <maerwald> and then they fix state bugs all the time
13:48:51 <fog> creation of an object is like making a value using the constructor of a datatype right?
13:49:14 <fog> and then, how do they coms?
13:49:24 <hyperisco> I think vaguely the trap with state in OOP is that every state (in the state machine sense) tend to blur together
13:49:47 <fog> graph Laplacian!? 
13:49:57 <hyperisco> and why… because you have one class name with one property list, and that must account for all states (in the state machine sense) of the object
13:50:21 <maerwald> hyperisco: there's a semi-sane school of OOP programmers (java even), who say that you must *never* change an object state after its creation... doing that style of OOP is quite different
13:50:46 <maerwald> but it isn't really inherent in OOP itself
13:50:49 <hyperisco> it isn't a necessary trap to fall into
13:50:53 <maerwald> it's just a school
13:51:06 <fog> so, if it was a haskell "object" it would be a datatype existing always wrapped in IO, with IORefs for the data?
13:51:21 <wavemode> i'm guessing adherents of that school don't work much on performance-critical software...
13:51:30 <fog> and then like, somehow altering the data stored there, like hacking using memory addresses or something?
13:51:51 <maerwald> wavemode: if you do performance critical stuff, OOP makes no sense anyway?
13:51:57 <ezzieyguywuf> maerwald: so whenever you need to design a GUI you step away from haskell and use something else?
13:52:11 <hyperisco> the mental model is more significant than the program
13:52:25 <fog> i thought some of the LVars were blocking and stuff...
13:52:36 <fog> like, couldnt you emulate a decent MPI like that?
13:52:47 <maerwald> ezzieyguywuf: dunno, haven't seen a full-blown GUI toolkit in haskell... GTK, QT are the main ones and they are all object based
13:52:51 <hyperisco> you can narrowly avoid all pitfalls, maximising efficiency, if you can maintain the correct mental model
13:52:58 <fog> with some kind of shared memory between datatype contents 
13:53:08 <hyperisco> maybe add some comments so you can recall it in a year
13:53:25 <ezzieyguywuf> hyperisco: I'm finding that maintaining a mental model in my haskell code is rather straightforward, but in any oop projects I've worked on in the past it becomes extremely difficult.
13:53:40 <ADG1089> I want to emulate a process where the possible next values depend on the current value and all previous values, can I use list and state monad?
13:53:50 <Morrow_> What does OOP even give you if you can't change the internal state of objects
13:54:02 <hyperisco> well, when you shoot for efficiency, you're often giving up language conveniences that make maintaining the mental model easier
13:54:05 <fog> ADG1089. yeah, and mapAccum does exactly that
13:54:15 <maerwald> ezzieyguywuf: that's because intellectual complexity skyrockets with state... it's easy to *write*, but hard go understand
13:54:30 <hyperisco> Morrow_, IMO, subtyping
13:54:36 <ezzieyguywuf> the more I mess with haskell and the State monad, the more I see that any of my OOP projects have really just been a perversion of the same
13:54:41 <fog> whats subtyping?
13:54:54 <Morrow_> As in inheritance?
13:55:02 <hyperisco> contravariance and covariance
13:55:07 <fog> oh right, just classes with constraints?
13:56:06 <fog> i thought contravarience and covarience were to do with eg. profunctors
13:56:07 <hyperisco> feels weird explaining this in reverse now
13:56:15 <fog> about how to compose the type params
13:56:29 <hyperisco> so people come here and ask why  f :: Num -> Num  isn't working
13:56:29 <ezzieyguywuf> g2g now, but thank you all for the insightful conversation.
13:56:31 <fog> hows that an explanation of what is subtyping?
13:56:42 <hyperisco> that is because they are used to a world where  Int  is a subtype of  Num
13:56:50 <fog> oh, hmmm
13:56:52 <ADG1089> fog, something like current value = (Int, Int, Int) & all previous values recorded in a Data.HashSet so my state would be like ((Int, Int, Int), HashSet (Int, Int, Int))
13:56:57 <ezzieyguywuf> `f :: (Num a) => a -> a`
13:57:01 <maerwald> so I always feel I'm not smart enough to write OOP, because it strains my working memory too much
13:57:21 <ADG1089> and then a step function step :: State -> [State]
13:57:47 <fog> wait, i thought you just wanted to scan over the list with a carry
13:57:51 <ezzieyguywuf> maerwald: I've been pondering this because I have a need in my current project to implement a complex GUI, and I've been brainstorming how I want to go about it
13:57:56 <hyperisco> covariance and contravariance is how subtyping applies to type constructors
13:57:56 <ADG1089> and then iterate (concatMap . step) [start] ? 
13:58:12 <maerwald> ezzieyguywuf: can you do TUI?
13:58:27 <ezzieyguywuf> maerwald: I can, and I am. But I have to have a GUI as well. It's a CAD program
13:58:28 <tomsmeding> maerwald: does that help?
13:58:54 <maerwald> TUI is nice in haskell
13:58:56 <fog> ADG1089, so your like, flattening a tree?
13:59:06 <tomsmeding> I mean, less messing around with libraries and platforms and stuff, but the GUI paradigm stuff is the same
13:59:06 <maerwald> GUI I'd choose gtk-gi
13:59:13 <dolio> I think there are plenty of examples of subtyping that wouldn't be considered OOP.
13:59:14 <maerwald> and gtk is a beast
13:59:16 <sm[m]> maerwald: it's supposed to encapsulate the complexity, just like functions, no ?
13:59:24 <ezzieyguywuf> maerwald: I was thinking qt
13:59:37 <ezzieyguywuf> maerwald: https://gitlab.com/ezzieyguywuf/mycad/-/raw/master/res/drawEntity_demo.gif this is my program so far, i'm rather proud of it ^_^ lol
13:59:38 <dolio> It's probably better to call subtyping subtyping. :)
13:59:43 <maerwald> either works, I guess, I just have more experience with gtk
13:59:56 <fog> % :t extend
13:59:57 <yahb> fog: Comonad w => (w a -> b) -> w a -> w b
14:00:05 <ADG1089> fog, you can say I want tree nodes at certain depth wherein I will check the size of the set in the state 
14:00:18 <maerwald> sm[m]: sure, but it also *encourages* it... some things better not be easy ;)
14:00:40 <tomsmeding> ezzieyguywuf: that's actually pretty cool!
14:00:49 <wavemode> ezzieyguywuf, that's fantastic
14:00:53 <fog> but if your basically, mapping a cokilesli type and then concating, its like join . fmap cojoin
14:00:58 <ezzieyguywuf> tomsmeding: thanks!!!
14:01:03 <ezzieyguywuf> wavemode: !!!
14:01:17 <sm[m]> people have built amazing, complex and even robust things in smalltalk seemingly without much trouble
14:01:53 <merijn> smalltalk OOP is pretty much entirely unlike OOP as taught currently, though :p
14:02:18 <merijn> Smalltalk OOP is more like actor model, and thus spiritually much closer to, say, Erlang than Java or C#
14:02:34 <maerwald> sm[m]: with enough discipline and experience, you can do anything.
14:02:37 <fog> ADG1089: can you explain again - i got distracted by the gui
14:02:43 <sm[m]> I constantly max out working memory, while building things with haskell. Constantly swapping, in fact
14:02:54 <merijn> sm[m]: Really?
14:03:19 <wavemode> no complex program was ever developed "without much trouble". that's just something proponents of a language will tell you to suck you in :p
14:03:28 <davean> sm[m]: huh, how?
14:03:28 <merijn> sm[m]: I hear that a lot, but it's personally rarely been an issue for me, so I guess I find it hard to imagine how it happens
14:03:33 <sm[m]> sure, when you consider all the unfamiliar packages, language extensions, tooling issues of the week..
14:03:52 <sm[m]> Platform issues, etc
14:04:01 <maerwald> working memory is an important skill... but the problem with reaching your limits is... you rarely realise you are over your limit already... because you'll just miss out on details and consequences
14:04:02 <fog> oh, i had a problem i wanted to ask about, i asked earlier but went afk
14:04:06 <ADG1089> fog, iow, i want to get values obtainable after n applications of step :: State -> [State], something like replicateM (concatMap step) [start]
14:04:25 <maerwald> in chess... you know when your working memory failed... because your opponent wins... in programming, you just created a bug
14:04:26 <ADG1089> *replicateM n
14:04:51 <fog> https://pastebin.com/raw/Tyf9dK7A
14:04:55 <merijn> maerwald: Naah, I just blunder my opponent into confusion
14:04:58 <maerwald> lol
14:05:03 <wavemode> sometimes your opponent doesn't catch your mistake
14:05:05 <merijn> #BotezGambit
14:05:31 <fog> ADG1089: that seems fairly straitforward, im not sure what your struggling with
14:05:52 <sm[m]> For a foss maintainer perhaps it's more of a problem, because you're hopping around many issues
14:06:07 <L29Ah> is it possible to explicitly write a polymorphic functions with different implementations for different argument types? say
14:06:08 <L29Ah> foo :: Proxy '[] -> [()]
14:06:09 <L29Ah> foo _ = []
14:06:10 <L29Ah> foo :: Proxy (x ': xs) -> [()]
14:06:11 <L29Ah> foo _ = () : foo $ Proxy @xs
14:06:16 <merijn> L29Ah: No
14:06:24 <ADG1089> fog, I got distracted by something similar: https://github.com/iokasimov/experiments/blob/master/joint/wolf-goat-cabbage.hs
14:06:37 <merijn> L29Ah: Well, maybe, if you abuse GADTs and typeclasses
14:06:39 <L29Ah> how do i recurse over a type-polymorphic list then?
14:06:47 <maerwald> sm[m]: especially when ppl use you software in ways you have never anticipated
14:06:56 <L29Ah> like those things that generics-sop throw at me
14:07:13 <merijn> L29Ah: https://gist.github.com/merijn/dc00bc7cebd6df012c5e#file-gistfile1-hs-L33-L35
14:07:21 <merijn> L29Ah: Painfully
14:07:27 <dolio> Casing on types is what type classes do.
14:08:21 <fog> i had this but its not right; https://pastebin.com/raw/7becagAV
14:09:09 <fog> it has to cheat by using a forall for bounds
14:09:35 <fog> really it should make these visible to the overall Nodes, and they were supposed to be stored in the Tree
14:16:05 <fog> sorry, that code was not good, this is better; https://pastebin.com/raw/n4Y1em4h
14:16:46 <fog> the problem is, to get it to typecheck i have to write;
14:16:47 <fog>  Nodes :: a -> FList Nodes (ts :: [Tree *]) -> Nodes ('Tree a ts)  
14:17:06 <fog> but i want it to be `Tree a' not `Tree *'
14:17:25 <fog> i think... 
14:17:37 <fog> its pretty confusing between term and type level
14:17:52 * L29Ah 's brain explodes
14:17:55 <fog> im not even sure how it ends up needing it to be Tree *
14:18:24 <fog> i think it might be the kind of `a' which is why it makes me think im confusing term and type level somehow
14:18:39 <fog> L29Ah: yeah sorry...
14:19:09 <fog> i had like 500 lines of code and managed to simplify the problem down to this design pattern and its still no more comprehensible...
14:19:12 <L29Ah> i wonder if i can indeed make an ad-hoc type class here for my recursive function
14:20:11 <fog> i managed to do something similar before but it was for trees with leafs
14:20:27 <fog> this just has empty leafs and data at the branch points
14:21:30 <fog> and i cant tell if im getting confused about the recursive datatype on the branches, which i think might have to be normal trees
14:21:44 <fog> so it kind of gets mixed up between Free and CoFree style trees
14:21:59 <fog> with labels at the branches, as well as data descending over the branches
14:22:05 <fog> but i cant understand it!
14:22:08 <L29Ah>     • Expected a type, but ‘x : xs’ has kind ‘[a0]’
14:22:33 <fog> % :kind! Int ': '[]
14:22:34 <yahb> fog: [*]; = '[Int]
14:23:13 <L29Ah> ouch
14:23:20 <fog> L29Ah: i think we are going to need more of the error to solve that one!
14:23:47 <L29Ah> % :kind! Int ': Bool ': '[]
14:23:47 <yahb> L29Ah: [*]; = '[Int, Bool]
14:24:07 <fog> why was it saying it needed a type?
14:24:35 <fog> maybe you meant it to be a phantom parameter?
14:24:42 <fog> like in a proxy
14:24:47 <L29Ah> yeah
14:28:17 <fog> oh damn, my param thing is on the wrong level, thats why
14:28:50 <fog> its constructor takes an argument which is a Symbol for example, so it seems like it could only exist at type level
14:29:01 <fog> since i cant have term level Symbols
14:40:53 <fog> hmm, this is closer, but still getting an error; https://pastebin.com/raw/3qX0MBcU
14:59:16 <ADG1089> which cabal to install v1/2/3?
14:59:33 <monochrom> 3
14:59:35 <merijn> ADG1089: 3
14:59:41 <ADG1089> stack install cabal-v3?
14:59:48 <merijn> ADG1089: The v1 v2 stuff does *not* refer to cabal-install version
15:00:04 <monochrom> No, please don't mix stack and cabal.
15:00:15 <hpc> if you're using stack, use its packaging mechanism
15:00:16 <merijn> ADG1089: v1 is the old workflow, v2 is the new workflow (which is the default from cabal-install 3.0)
15:00:24 <ADG1089> merijn, thanks
15:00:32 <ADG1089> monochrom, okay!
15:02:36 <ADG1089> monochrom, there is a bug in ghc-8.8.3 so i will need to use cabal to install some packages
15:02:41 <ADG1089> my default workflow is to use stack
15:02:45 <ADG1089> issue: https://github.com/haskell/haskell-ide-engine/issues/1779
15:03:02 <ADG1089> focused: https://gitlab.haskell.org/ghc/ghc/issues/17926
15:03:53 <monochrom> Perhaps stack has a resolver that uses 8.8.4
15:04:05 <monochrom> But I haven't checked whether 8.8.4 fixes that bug.
15:04:18 <ADG1089> can use 8.6.5 i think
15:06:42 <ADG1089> my macbook screen has a glitchy vertical strip that obstructs vision so had to re-setup on my windows laptop
15:06:57 <ADG1089> rip macbook reliability
15:09:26 <fog> *rage quit*
15:14:28 <sm[m]> if you already have stack you can certainly use it to install cabal, but grabbing a binary from https://www.haskell.org/cabal/download.html is quicker
15:14:50 <hpc> or ghcup
15:15:08 <sm[m]> ADG1089 has stack and is on windows, I think
15:15:31 <sm[m]> reading more, monochrom  is right, you can just pick a different stack resolver to avoid ghc 8.8.3
15:16:09 <ADG1089> tried with 8.4.4 and 8.6.5 got dependency hell
15:16:39 <ADG1089> i.e. build plan failing and asking to add dozen of extra-deps to stack.yaml
15:16:57 <sm[m]> that's quite normal, depending on what you're trying to build
15:17:02 <ADG1089> haha
15:17:10 <sm[m]> many haskell packages don't support a wide range of ghc versions
15:17:48 <ADG1089> will keep on re-running stack install then since the bug triggers undeterministically, so atleast some packages will be built everytime *sigh*
15:17:50 <koz_> sm[m]: That's not really anything to do with packages.
15:17:57 <koz_> It's more to do with Stack's curation policy.
15:18:00 <sm[m]> --resolver lts-15.3 uses ghc 8.8.2
15:18:07 <koz_> (and what resolver ADG1089 is using)
15:18:13 <koz_> Also, that resolver is _hilariously_ old.
15:18:25 <ADG1089> lts-16.0
15:18:39 <koz_> 16.0 is better.
15:18:53 <monochrom> @stack monochrom
15:18:54 <lambdabot> I'd rather not; monochrom looks rather dangerous.
15:18:59 <monochrom> haha
15:19:00 <monochrom> @stack monochrom
15:19:01 * lambdabot locks up monochrom in a Monad
15:19:09 <monochrom> That's better.
15:19:16 <koz_> ADG1089: 16.0 is about 2 months old.
15:19:33 <monochrom> ("stack" is within autocorrect distance from "slap")
15:19:38 <ADG1089> sarcasm?
15:19:44 <sm[m]> ADG1089 is trying to avoid ghc 8.8.3, which doesn't work on windows. 8.8.2 is pretty close and all deps should be pretty easy
15:19:52 <koz_> sm[m]: Ah, I see.
15:20:02 <koz_> 8.8.4 fixed this issue right?
15:20:14 <koz_> (but Stack has no resolvers for it, sadface)
15:20:25 <sm[m]> the alternative is to fiddle with nightly (ghc 8.10, more change of dep hassles) or forcing stack to use ghc 8.8.4 (no resolver for it yet)
15:20:27 <sm[m]> yup
15:20:56 <koz_> Lol.
15:21:08 <koz_> No 8.10 LTSes either, which is also lol.
15:21:32 <sm[m]> not at all koz_, it takes time for hackage to catch up with a GHC release
15:21:45 <sm[m]> if you try maintaining a package with many deps, you'll see
15:21:45 <Cale> Anyone know if it's possible to give explicit type signatures to pattern synonyms of existential data constructors?
15:21:46 <koz_> sm[m]: s/hackage/Stackage/ I assume?
15:22:45 <sm[m]> by "hackage" I meant "the haskell package ecosystem"
15:22:56 <koz_> sm[m]: Ah,
15:23:01 <sm[m]> sloppy wording there
15:23:44 <Cale> answer: it is
15:25:05 <dminuoso> Cale: There was a proposal but that was rejected: https://github.com/ghc-proposals/ghc-proposals/pull/96
15:25:59 <dminuoso> In favor of: https://github.com/ghc-proposals/ghc-proposals/pull/126
15:26:13 <dminuoso> So I guess that's the way?
15:26:29 <sm[m]> ADG1089: you saw my resolver suggestion hopefully. I just want to add, if you are seeing non-deterministic failures, you're probably running out of RAM
15:26:32 <Cale> I'm implementing 126 at the moment
15:27:09 <Cale> What I was asking about was just in the definition of the pattern synonym itself though
15:27:23 <ADG1089> yes, will try 8.8.4, could be due to ram but built easily on macbook with same lts
15:27:28 <Cale> data Foo a = forall b. MkFoo b (b -> a)
15:27:28 <Cale> pattern UnFoo :: (b -> a) -> b -> Foo a
15:27:28 <Cale> pattern UnFoo f x = MkFoo x f
15:27:31 <Cale> ^^ this works
15:27:43 <Cale> But also, I can't seem to explicitly quantify those variables
15:28:02 <sm[m]> how much ram on your windows machine ?
15:28:08 <dminuoso> Ah
15:28:51 <Cale> also, funnily enough, it seems that type applications in pattern synonym *expressions* don't seem to work
15:29:09 <Cale> even though I've implemented them for pattern synonym *patterns*
15:29:47 <Cale> (I had to do something a little sketchy to do it though -- basically taking a guess at what order to bind variables in)
15:30:34 <Cale> There doesn't seem to be anything analogous to dataConUserTyVarBinders for pattern synonyms
15:31:05 <Cale> and... actually trying to explicitly quantify variables in my pattern synonym declarations doesn't seem to work all that well anyway
15:32:13 <ADG1089> 8.8.4 also fails
15:32:54 <ADG1089> zzz
15:37:19 <sm[m]> ADG1089: how ?
15:37:33 <ADG1089> build plan failed
15:38:39 <sm[m]> if you want, share the output and the stack.yaml  & package.yaml/.cabal file and we can help you diagnose it
15:48:08 <ADG1089> was trying to solve project euler#265, finally done
15:48:29 <ADG1089> i was installing hlint & brittany but just deferred that 
15:54:27 <ADG1089> thinking i should buy another ddr3 8gb ram
15:54:27 <sm[m]> you probably should, but if you already have 8 it's probably not causing haskell build trouble
15:56:18 <MarcelineVQ> as long as your browser is closed :>
15:56:46 <ADG1089> yeah ghc usage is ~1Gb, firefox 1GB, vscode 300MB
16:01:28 <sm[m]> ghc/stack/cabal/ldd usage can spike up to several G while building certain packages, depending on platform & ghc version
16:02:42 <ADG1089> can't it swap onto ssd?
16:03:18 <sm[m]> pandoc on windows, for example. If you have swap enabled (no idea how that works on windows) of course it will use that when necessary, but then your build will run all night
16:03:53 <sm[m]> there are ways to encourage it to use less, when needed, but with 8G you're fine
16:05:31 <ADG1089> edifying!
16:06:12 <sm[m]> you'll see exactly if you run a quick-updating htop or equivalent while it's doing its thing
16:25:19 * hackage git-annex 8.20200810 - manage files with git, without checking their contents into git  https://hackage.haskell.org/package/git-annex-8.20200810 (JoeyHess)
16:38:50 * hackage ansi-terminal 0.11 - Simple ANSI terminal support, with Windows compatibility  https://hackage.haskell.org/package/ansi-terminal-0.11 (mpilgrem)
16:39:18 <Rembane> MarcelineVQ: No worries, just knowing about the technique is worth a lot. Did you end up with pattern matching on the different cases all over the code base, or did they end up in one module and only combinators exported? 
16:43:55 <MarcelineVQ> the latter currently but I'm not sure how it'll evolve. I'm using it to hopefully assemble a streaming lib with some basic stream fusion. since chaining operations on streams is pretty much what you do with them fusion is a good thing to have
16:50:50 * hackage invertible-grammar 0.1.3 - Invertible parsing combinators framework  https://hackage.haskell.org/package/invertible-grammar-0.1.3 (EugeneSmolanka)
16:51:50 * hackage sexp-grammar 2.2.0 - Invertible grammar combinators for S-expressions  https://hackage.haskell.org/package/sexp-grammar-2.2.0 (EugeneSmolanka)
16:53:04 * ski . o O ( DCG )
17:13:44 <ezzieyguywuf> y'all ever code without syntax highlighting?
17:14:48 <Arahael> yes, sometimes.
17:15:03 <Axman6> only if under duress
17:18:03 <ezzieyguywuf> lol, duress
17:20:15 <Arahael> ezzieyguywuf: sometimes, i code even if the only editor available is "vi", for some reason. ;)  rare, though. you did use the word "ever", and we are a literal bunch.
17:24:19 <ezzieyguywuf> lol, thanks for your feedback
17:24:50 <ski> yes
17:25:06 <dansho> is there a way to match multiple patterns in a case statement like: https://hastebin.com/ufubuqumox.hs ?
17:25:27 <solonarv> dansho: not currently
17:26:42 <solonarv> usual workaround is something like: let rhs = 3 in case x of A -> 1; B -> 2; C -> rhs; D -> rhs
17:27:01 <solonarv> (assuming that 1, 2, 3 are actually larger expressions, not much point with just single numbers)
17:28:15 <ski> no disjunctive/"or" patterns in Haskell :(
17:28:55 <Axman6> IS there a better reason for that than case x of (Left x | Right x) -> ... can be problematic?
17:29:20 <Axman6> IS there a reason my shift key seems to always stick?
17:30:06 <ski> can be problematic, in which way ?
17:32:11 <Arahael> Axman6: stop drinking sprite? ;)
17:32:44 <solonarv> seems kind of annoying to typecheck, though certainly not impossible
17:33:02 <Arahael> seriously though, i have the same problem with caps.
17:33:57 <ski> just make sure both patterns bind the same variables, with the same types
17:40:14 <fraktor> ezzieyguywuf: Why would you code without highlighting?  I've heard of lispers doing it, but that's just because there isn't really a syntax to highlight there.
17:49:45 <Axman6> highlighting matching brackets I would have though was essential for working in lisps
17:56:05 <Arahael> a consistent indentation style gets you most of the way there.
17:58:12 <DigitalKiwi> ezzieyguywuf: i messaged you a few days ago idk if you got them
18:01:01 <Axman6> Messages probably got caught in quarantine, might take up to two weeks to get out of NZ 
18:01:31 <ezzieyguywuf> DigitalKiwi: I got them! about the tito thing right?
18:02:32 <koz_> Axman6: *laughs in birthday parcels*
18:02:58 <DigitalKiwi> ezzieyguywuf: yes
18:03:09 <Axman6> koz_: u wot?
18:03:22 <DigitalKiwi> Axman6: i'm in the usa the messages probably have covid
18:03:27 <koz_> Axman6: I sent some birthday gifts to Australia.
18:03:35 <koz_> Took damn near two weeks to _leave NZ_.
18:03:54 <Axman6> I remember the days when there was only two kiwi haskellers, and they both came to my ~party~ AusHac hackathon. now there;s literally dozen of them!
18:03:59 <Axman6> haha
18:04:04 <koz_> Lol.
18:04:07 <DigitalKiwi> Axman6: also lol i sent something to tasmania july 15th and it's still not there :( but the ones i sent to australia mainland got there fast...
18:04:22 <koz_> I wish I had any of the remaining 11 anywhere nearby.
18:04:27 <koz_> There's like, zero around here.
18:04:35 <koz_> (for any definition of 'here')
18:04:41 <Axman6> Tasmania doesn't exist, that's why. You sending things to Brian?
18:05:01 <DigitalKiwi> yes!
18:05:24 <Axman6> Good work, puffnfresh_ deserves presents
18:05:48 <DigitalKiwi> https://twitter.com/ArchKiwi/status/1269321790016364544?s=20 that
18:06:22 <DigitalKiwi> and a bunch of https://twitter.com/ArchKiwi/status/1244354048691769349?s=20
18:06:48 <DigitalKiwi> and https://twitter.com/ArchKiwi/status/1244353474063740929?s=20
18:07:41 <DigitalKiwi> speaking of i'm making nixos stickers right now to give away and soon haskell ones... if anyone wants something let me know
18:07:55 <Axman6> You have like the best twitter handle I've ever seen
18:08:13 <DigitalKiwi> i can't change it to NixKiwi because i don't have a logo
18:08:18 <Axman6> and pic
18:08:39 <puffnfresh_> <3 <3 <3
18:10:43 <Axman6> Anyone played with https://ihp.digitallyinduced.com? It looks sweet as
18:10:56 <DigitalKiwi> i did the tutorial
18:11:01 <DigitalKiwi> that was about it
18:11:20 <Axman6> I just don't have a whole lot of use for CRUD apps sadly
18:12:05 <Axman6> also, similarly cool is the DAML tutorial and the good integration with React in the front end (Disclosure: I'm contracted to DA, but that doesn't stop DAML being super cool)
18:22:00 <koz_> If I have foo :: Maybe a, and f :: a -> Foo b, how would I munge them together to get a Foo (Maybe b)?
18:22:19 <c_wraith> traverse?
18:22:29 <koz_> .... u serious bro.
18:22:45 <koz_> Everything truly is traverse.
18:23:36 <sm[m]> yes, I played with it but soon ran into problems on mac which I haven't had a chance to debug
18:23:36 <sm[m]> https://ihp.digitallyinduced.com/blog/2020-08-10-ihp-live-reloading.html came out today and is quite interesting
18:26:52 <wavemode> haha haskell on rails
18:27:43 <sm[m]> it's at least the third attempt at it
18:28:27 <sm[m]> and will get a lot of traction!
18:28:56 <nshepperd1> Haskell on Horseback
18:29:12 <wavemode> aha
18:33:28 <sm[m]> their chat is https://gitter.im/digitallyinduced/ihp (#gitter_digitallyinduced=2Fihp:matrix.org for the matrix folks)
18:34:22 <DigitalKiwi> what about the irc people
18:35:55 <koz_> Haskell on Tram.
18:36:20 <monochrom> Haskell Curry on Rice.
18:36:37 <koz_> monochrom: That's either delicious or horrifying depending on parse precedence.
18:37:01 <monochrom> It's the delicious one!
18:38:02 <koz_> I can't believe I'm asking this question on #haskell of all places, but monochrom: Are you a necrocannibal?
18:38:34 <monochrom> No.
18:38:43 <koz_> Great!
18:39:10 <koz_> So now, I know monochrom's parse precedence for 'on'.
18:39:41 <monochrom> Consider it as "Haskell Curry's curry recipe on rice". Please don't assume the evil. >:)
18:40:11 <koz_> monochrom: Surely that's Haskell Curry Curry on Rice though?
18:40:20 <monochrom> Contraction
18:40:29 <koz_> Haskell CCurry on Rice.
18:41:05 <koz_> :t callCC
18:41:06 <lambdabot> MonadCont m => ((a -> m b) -> m a) -> m a
18:41:11 <koz_> :t curry callCC
18:41:12 <lambdabot> error:
18:41:12 <lambdabot>     • Couldn't match type ‘(a, b)’ with ‘(a1 -> m b0) -> m a1’
18:41:12 <lambdabot>       Expected type: (a, b) -> m a1
18:41:15 <koz_> :(
18:42:18 <wavemode> Haskell's* Curry on Rice
18:43:32 * koz_ wishes he could make a joke about Rice's Theorem now.
18:46:04 <monochrom> Haskell Curry worked on combinatory logic, no?  I.e., all lambda terms are expressible with S, K, function application, without needing any other explicit lambda.
18:46:30 <monochrom> So perhaps a version of Rice's theorem for this theoretical language.
18:47:50 <monochrom> Oh, then, I have a good one! (OK, I say that it's good, but it's subjective, of course I think that my ideas are all good!)
18:48:23 <monochrom> I simply can't decide whether I like this new Haskell Curry on Rice recipe or not. :)
18:48:40 <koz_> Because the question is not trivial? :P
18:48:53 <monochrom> No, because the recipe is non-trivial!
18:49:04 <koz_> Yep, that was good.
18:55:53 <ezzieyguywuf> is there a version of Data.List.NonEmpty that is sorted?
18:56:24 <koz_> ezzieyguywuf: Do you care about duplicates? If not, consider Data.Set.NonEmpty.NESet.
18:57:29 <ezzieyguywuf> koz_: there should not be duplicates, so NESet may be what I need thanks
18:57:37 <koz_> ezzieyguywuf: No worries.
18:58:13 <koz_> (also, am I the only one who mentally sounds the 'NE' in 'NESet' like the 'nii' in 'niisan'?)
18:58:19 <koz_> (so like, 'niiiSet')
18:58:52 <ezzieyguywuf> koz_: I read it like that ^_^
18:58:57 <koz_> :D
18:59:57 <koz_> > signum (0.0 / 0.0)
18:59:58 <lambdabot>  NaN
19:00:01 <koz_> Rofl.
19:00:24 <koz_> > signum 1.0
19:00:27 <lambdabot>  1.0
19:08:17 <hololeap> > signum (1.0/0.0)
19:08:18 <lambdabot>  1.0
19:10:33 <Axman6> koz_: I read it as any-set
19:12:34 <Axman6> like the classic number plate: NE1410S
21:13:49 * hackage vulkan 3.6.4 - Bindings to the Vulkan graphics API.  https://hackage.haskell.org/package/vulkan-3.6.4 (jophish)
21:23:20 * hackage yesod-auth-basic 0.1.0.3 - Yesod Middleware for HTTP Basic Authentication  https://hackage.haskell.org/package/yesod-auth-basic-0.1.0.3 (ChristopherReichert)
22:06:54 <nypro12> Hello, I am having a hard time understanding why the ghc profiler is showing such results.. appreciate if anyone can help.
22:07:00 <nypro12>   40,597,504,128 bytes allocated in the heap   8,509,910,280 bytes copied during GC   2,700,545,248 bytes maximum residency (131 sample(s))      26,641,760 bytes maximum slop            2575 MB total memory in use (9 MB lost due to fragmentation)                                     Tot time (elapsed)  Avg pause  Max pause  Gen  0     20168 colls,
22:07:01 <nypro12> 20168 par   190.635s  21.487s     0.0011s    0.0417s  Gen  1       131 colls,   130 par   43.785s   4.107s     0.0314s    0.1239s  Parallel GC work balance: 73.87% (serial 0%, perfect 100%)  TASKS: 92 (1 bound, 56 peak workers (91 total), using -N12)  SPARKS: 0(0 converted, 0 overflowed, 0 dud, 0 GC'd, 0 fizzled)  INIT    time    0.000s  (  0.004s
22:07:02 <nypro12> elapsed)  MUT     time  359.747s  (191.455s elapsed)  GC      time  210.289s  ( 23.510s elapsed)  RP      time    0.000s  (  0.000s elapsed)  PROF    time   24.132s  (  2.085s elapsed)  EXIT    time   24.162s  (  2.094s elapsed)  Total   time  618.329s  (219.148s elapsed)  Alloc rate    112,850,306 bytes per MUT second  Productivity  58.2% of total
22:07:02 <nypro12> user, 87.4% of total elapsed
22:07:43 <nypro12> ```   40,597,504,128 bytes allocated in the heap   8,509,910,280 bytes copied during GC   2,700,545,248 bytes maximum residency (131 sample(s))      26,641,760 bytes maximum slop            2575 MB total memory in use (9 MB lost due to fragmentation)                                     Tot time (elapsed)  Avg pause  Max pause  Gen  0     20168
22:07:44 <nypro12> colls, 20168 par   190.635s  21.487s     0.0011s    0.0417s  Gen  1       131 colls,   130 par   43.785s   4.107s     0.0314s    0.1239s  Parallel GC work balance: 73.87% (serial 0%, perfect 100%)  TASKS: 92 (1 bound, 56 peak workers (91 total), using -N12)  SPARKS: 0(0 converted, 0 overflowed, 0 dud, 0 GC'd, 0 fizzled)  INIT    time    0.000s  (
22:07:44 <nypro12> 0.004s elapsed)  MUT     time  359.747s  (191.455s elapsed)  GC      time  210.289s  ( 23.510s elapsed)  RP      time    0.000s  (  0.000s elapsed)  PROF    time   24.132s  (  2.085s elapsed)  EXIT    time   24.162s  (  2.094s elapsed)  Total   time  618.329s  (219.148s elapsed)  Alloc rate    112,850,306 bytes per MUT second  Productivity  58.2%
22:07:45 <nypro12> of total user, 87.4% of total elapsed```
22:09:08 <nypro12> I barely ran my server for 3-4 minutes, it ingested a few MB of data, and after certain transformation to the data stored them (with various indexes) into Cassandra DB
22:09:52 <nypro12>  the "bytes allocated in heap" and "bytes copied during GC" is alarming me, should I indeed be concerned?
22:11:18 <L29Ah> that's a lot indeed
22:11:29 <nypro12> 50 % of the allocation seems to be happening in the cassandra cql driver on a seemingly innocuous piece of code, which runs the put monad (cereal) to encode a message which will subsequently be sent out on wire
22:12:33 <nypro12> here is the link to the library , https://gitlab.com/twittner/cql/-/blob/develop/src/Database/CQL/Protocol/Codec.hs
22:13:22 <nypro12> this function seems to log ~50% of allocation `putValue :: Version -> Putter Value`
22:15:28 <nypro12> L29Ah: is it orders of magnitude higher than it should be?
22:16:46 <jazzanova> Hello, I've been coding "on a tree", for about a month. I've made a portable table that mount's on a tree's trunk. So I don't sit home all day, and the park is my office. The table is based on someone's expired patent by the name "Tree Table". I've now put it up on IndieGoGo under the same name. 
22:20:03 <L29Ah> i think so
22:20:36 <L29Ah> you'llneed to figure out which constructor is especially troublesome
22:24:27 <nypro12> as I pointed out above ---> this function seems to log ~50% of allocation `putValue :: Version -> Putter Value`
22:45:33 <Axman6> jazzanova: what does this have to do with Haskell?
22:46:22 <jazzanova> Axman6: it requires a hacker type of mindset
22:46:48 <jazzanova> I'm not posting this to Java people
22:47:21 <Axman6> to use a table?
22:47:48 <jazzanova> to look for inspiration by working with a nice view, in a park... 
22:48:02 <jazzanova> with an unusual weird setup
22:48:53 <jazzanova> gotta be a poet to code in Haskell
22:51:29 <nerdypepper> jazzanova: is this an advert for a table
22:53:15 <jazzanova> yep
22:53:36 <Axman6> advertising on IRC is generally frowned upon
22:54:20 <jazzanova> What would you recommend to reach developers?
22:54:20 <Axman6> I do appreciate hpowever that you didn't link directly to it
22:55:09 * ski was thinking of a tree encoded as a "table" (array ?), somehow
22:55:32 <jazzanova> I got that on Hacker News, from one guy.
22:56:02 <Axman6> buy ads on Stack Overflow and advertise to the 3% of users who don't use an ad blocker =) (I don't actually know, I have some sympathy for trying to bring a new product to market in this day and age, I don't know how I'd do it)
22:56:31 <jazzanova> It's easy to advertise to non-developers, regular people. TikTok, Twitter, Instagram, etc.
22:56:37 <jazzanova> But I actually never follow that
22:56:47 <Arahael> I think I'd be ok mentioning soething in a special-interest group, maybe.  But this is general for haskell.
22:57:03 <jazzanova> ok
22:57:05 <Arahael> Eg, maybe I'd advertise a... Plugin, I guess, for GHC itself.  A new extension, as an example.
22:57:43 <jazzanova> Axman6: never thought about ads on Stack Overflow -- great idea. thanks.
22:58:19 <Arahael> Twitter's also good, I think.
22:58:55 <Axman6> yeah, it's probably the one platform that I do actually sometimes see ads, and have once or twice actually been interested in the products
23:00:54 <nerdypepper> you might also want to be more specific in your ad: "I am selling a table on _", all the best jazzanova 
23:01:27 <Arahael> Also a good idea to specify the type of wood you used.
23:02:37 <dolio> This also isn't the advertising advice channel.
23:06:34 <L29Ah> the table is nice, but i choose lap as i mostly only need a laptop, and the table is unnecessary bulk // would be less bulky if made out of fiberglass probably (;
23:08:19 <justsomeguy> Maybe if the laptop bag was the table...
