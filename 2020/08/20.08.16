00:00:10 <ski> iow, if we ever have two instances of `MonadReader r m', that agrees on the `m' parameter, then the corresponding `r' parameters also must be the same
00:00:31 <ski> practically, this manifests in two ways :
00:00:44 <redmp> doesn't that contradict when you said "ski> but there can't be more than one `r'"
00:00:48 <ski> (a) it checks that you don't actually have two instances (in scope) with the same `m' but different `r's
00:01:06 <ski> redmp : no. i never assumed that `r0' and `r1' were distinct
00:01:33 <redmp> ok..
00:02:53 <ski> (b) it then uses this extra guarantee for `MonadReader' constraints, during type inference/checking so that if it ever has two constraints `MonadReader r0 m' and `MonadReader r1 m' (with the same `m'), then it knows that `r0' and `r1' must be the same, so it goes ahead and unifies them (and if that fails, you have a type error, i'm almost sure .. can't recall if i checked)
00:03:12 <ski> (and then it can drop one of the constraints since they're now equal)
00:03:30 <ski> this helps reducing ambiguity
00:03:57 <ski> redmp : as a comparision, consider the definition of when a function `f :: A -> B' is injective
00:04:39 <ski> it's injective when distinct inputs give distinct outputs. that is, `forall x0 x1. x0 =/= x1 => f x0 =/= f x1'
00:05:03 <ski> but we can rephrase this as : if the outputs are equal, then the two inputs were actually also equal, all along
00:05:17 <ski> that is `forall x0 x1. f x0 = f x1 => x0 = x1'
00:07:37 <ski> (that's another example of saying "two inputs", where "two" means that we "point at two" values, without specifying that they must be distinct. so, one might argue that we're really taking "at most two inputs". but that gets awkward to express in english, so the math idiom is that in cases like this, "two" refers not to two distinct values, but to two (distinct) names that we're using to "point at" two values, distinct or not)
00:07:42 <redmp> right, but the associated-type-aliases aren't injective because they're open and i can always define an instance that has the same reult as another instance
00:08:31 <redmp> or maybe that's not why, heh
00:08:47 <ski> (not sure whether that explanation attempt makes any sense to you)
00:09:12 <ski> "it sounds like it's saying there's \"only one r for a given m\" which seems wrong" -- why ?
00:12:15 <ski> redmp : "the associated-type-aliases aren't injective because they're open and i can always define an instance that has the same reult as another instance" -- unless you add an FD on it, as i suggested
00:12:29 <redmp> when i said that i was confused and thinking we were saying we could only use the MonadReader constraint on one on r for a given m, meaning if you had a  `MonadReader Int Maybe` somewhere you coudln't have a `MonadReader Char Maybe` .. that's wrong; as you continued explaining i remembered that FDs are talking about constraints on how GHC interprets instances of MonadReader (not instantiations)
00:13:31 <redmp> anyway, i think haskell is kind of obscuring the theory here for me .. is there a different system i should interact with to learn these ideas more clearly? coq?
00:14:19 <ski> "we could only use the MonadReader constraint on one on r for a given m, meaning if you had a  `MonadReader Int Maybe` somewhere you coudln't have a `MonadReader Char Maybe`" -- that's right !
00:14:52 <ski> that would violate check (a) for the FD `m -> r' on `MonadReader r m'
00:16:15 <ski> (not sure what you mean by "instantiations" in "i remembered that FDs are talking about constraints on how GHC interprets instances of MonadReader (not instantiations)" -- note that (b) is exactly about how it treats `MonadReader' constraints, while checking/inferring types)
00:17:48 <ski> redmp : well, for the basic idea of what an FD is, i think either knowing about injectivity in math, or about FDs in (normalization and normal forms in) relational data base theory, would help
00:18:52 <redmp> but i can have two functions in the same file, one `f :: MonadReader Int m => m ...` and another `g :: MonadReader Char m => m ...` and they could both turn out to be `m ~ Maybe` or `m ~ IO` or whatever... i'm calling that an "instantiation" of the class head as a constraint, vs. what a FD cares about: an "instance" of class ..
00:19:31 <ski> in relational databases, one may sometimes have to (or want to), split a relation into two (or more), because of FDs (or MVDs, or ..). similarly, the same idea can also occasionally be useful, to realize that it would be better to split a type class, in a design in Haskell
00:19:44 <redmp> FDs in normalization / normal forms is closer to my area
00:21:33 <ski> type classes are "like" relations on types, which is why the same FD concept applies. however regular relations don't have associated "methods", and there's more stuff re type inference that doesn't correspond to anything in relational database theory. but i think if one already has some familiarity with the latter, that can help, with understanding FDs for type classes. not that it's required
00:22:36 <ski> "but i can have two functions in the same file" .. yes, but those two `m's in those two type signatures are distinct type variables
00:23:21 <ski> and they're not affirming/claiming those two constraints, but assuming them .. that is, the exact opposite
00:23:23 <redmp> ahhh.... ok, yes.
00:25:08 <ski> let's say that both `m's were actually `F Int', where `F' is some type family. and say some third party module specifies `type instance F Int = Maybe'
00:25:50 <ski> that only means that at most one of `f' and `g' is usable. if e.g. `MonadReader Char Maybe', then you could call `g', but couldn't call `f'
00:26:44 <ski> (instead of `F Int' you could have `F a', where `a' is a tyvar that's determined by the rest of the signature. so then `f' is unusable in cases where `a' would have been `Int')
00:27:51 <ski> however, if you had `h :: (MonadReader Int m,MonadReader Char m) => ..m..', i think you'd either get an error, or else you definitely get an unusable operation
00:29:33 <ski> @let frobnicate :: (MonadReader Int m,MonadReader Char m) => m (); frobnicate = undefined
00:29:34 <lambdabot>  Defined.
00:29:37 <ski> @type frobnicate
00:29:39 <lambdabot> error:
00:29:39 <lambdabot>     No instance for (MonadReader Int m)
00:29:39 <lambdabot>       arising from a use of ‘frobnicate’
00:29:43 <ski> that's interesting :)
00:30:34 <ski> redmp : anyway .. is there something more that's unclear ?
00:31:16 <redmp> i think in that example it's possible for m to be a transformer stack containing more than one distinct instance of a reader, no?
00:31:47 <ski> @type frobnicate :: ReaderT Int (Reader Char) ()
00:31:48 <redmp> ski: i think i have the tools to put an understanding together now, thank you... i need to spend more time on it myself thought
00:31:48 <lambdabot> error:
00:31:48 <lambdabot>     • Couldn't match type ‘Int’ with ‘Char’
00:31:48 <lambdabot>         arising from a functional dependency between:
00:31:53 <ski> @type frobnicate :: ReaderT Char (Reader Int) ()
00:31:55 <lambdabot> error:
00:31:55 <lambdabot>     • Couldn't match type ‘Char’ with ‘Int’
00:31:55 <lambdabot>         arising from a functional dependency between:
00:32:20 <redmp> oh, well, there's the type error you were looking for
00:32:29 <ski> "a transformer stack containing more than one distinct instance of a reader" won't work, precisely because of the FD
00:33:08 <redmp> hah, alright, that's the bit i need to internalize
00:33:15 <ski> (and that's a shame, but it's because we only identify the effect by the type of the environment. all of `mtl' has this problem)
00:38:29 <ski> > (ask :: ReaderT Int (Reader Char) Int) `runReaderT` 2 `runReader` 'a'
00:38:31 <lambdabot>  2
00:38:44 <ski> > (lift ask :: ReaderT Int (Reader Char) Char) `runReaderT` 2 `runReader` 'a'
00:38:45 <lambdabot>  'a'
00:39:40 <ski> (clarification, you can use multiple of the same `mtl' effect class in the same stack, but you'll have to manually `lift', and probably be more explicit with types)
00:42:56 <redmp> ski: oh, it's interesting that you can get around it that way
00:43:47 <redmp> thanks for taking the time to explain this to me
00:43:56 <ski> hm, i guess you don't need the explicit types, actually
00:44:31 <ski> for other transformers, we defer to the inner one, like in `MonadReader r m => MonadReader r (StateT s m)'
00:44:40 <L29Ah> % unsafePerformIO $ putStrLn "good morning"
00:44:40 <yahb> L29Ah: good morning; ()
00:45:03 <ski> but for `ReaderT' we don't defer, that is `MonadReader r (ReaderT r m)' without checking `MonadReader r m'
00:45:20 <ski> > replicate (ask `runReaderT` 2 `runReader` 'a') (lift ask `runReaderT` 2 `runReader` 'a')
00:45:22 <lambdabot>  "aa"
00:45:59 <redmp> i think i'm at capacity and need to get sleep now
00:46:03 <redmp> but thanks for explaining
00:46:05 * ski nods
00:46:07 <redmp> i'll re read this tomorrow
00:46:13 <L29Ah> % readFile "/proc/self/cmdline"
00:46:13 <yahb> L29Ah: "/srv/sandbox/root/usr/lib/ghc-8.10.1/bin/ghc\NUL-B/srv/sandbox/root/usr/lib/ghc-8.10.1\NUL--interactive\NUL-v0\NUL-ghci-script\NUL/srv/sandbox/root/usr/lib/run/ghci-init\NUL-tmpdir\NUL/srv/sandbox/root/data/tmp/\NUL-odir\NUL/srv/sandbox/root/data/tmp/\NUL-hidir\NUL/srv/sandbox/root/data/tmp/\NUL-ignore-dot-ghci\NUL+RTS\NUL-M200M\NUL-V0\NUL-C0\NUL-K100M\NUL"
00:46:25 <ski> have fun, redmp
00:46:30 <redmp> thanks for your help
00:46:31 <ski> and good night
00:46:36 <redmp> g'night
00:47:15 <L29Ah> % readFile "/srv/sandbox/root/usr/lib/run/ghci-init"
00:47:15 <yahb> L29Ah: ":set -XBangPatterns -XConstraintKinds -XDataKinds -XDefaultSignatures -XDeriveAnyClass -XDeriveDataTypeable -XDeriveGeneric -XDeriveLift -XDeriveTraversable -XDerivingVia -XEmptyCase -XEmptyDataDecls -XEmptyDataDeriving -XExistentialQuantification -XFlexibleContexts -XFlexibleInstances -XFunctionalDependencies -XGADTs -XGeneralizedNewtypeDeriving -XHexFloatLiterals -XImplicitParams -XImportQualif
00:48:06 <L29Ah> % putStr =<< readFile "/srv/sandbox/root/usr/lib/run/ghci-init"
00:48:06 <yahb> L29Ah: :set -XBangPatterns -XConstraintKinds -XDataKinds -XDefaultSignatures -XDeriveAnyClass -XDeriveDataTypeable -XDeriveGeneric -XDeriveLift -XDeriveTraversable -XDerivingVia -XEmptyCase -XEmptyDataDecls -XEmptyDataDeriving -XExistentialQuantification -XFlexibleContexts -XFlexibleInstances -XFunctionalDependencies -XGADTs -XGeneralizedNewtypeDeriving -XHexFloatLiterals -XImplicitParams -XImportQualifi
00:48:56 <ski> perhaps try in private, L29Ah, unless there's something in particular you'd like to show the channel ?
00:49:41 <hyiltiz> what's all those talks in FD? There were descriptions about it but not definitions anywhere and can't seem to find out what to look up either
00:50:08 <ski> hyiltiz : <https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#type-family-examples>
00:50:33 <ski> actually check <https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#functional-dependencies>
00:50:40 <ski> (sorry, wrong link)
00:51:32 <hyiltiz> Functional dependency?
00:51:40 <hyiltiz> Yeah found it on that page, thx!
00:52:44 <ski> hyiltiz : how well do you understand type classes ?
00:53:07 <hyiltiz> BTW du just write one-liners like that, or u write then properly then join lines?
00:53:10 <ski> (basic ones, like `Eq',`Ord',`Num',`Functor')
00:53:18 <hyiltiz> Yeah I do
00:53:28 <ski> hm, which one-liners ?
00:53:38 <hyiltiz> As long as we dont do comonads yonedas etc.
00:53:44 <ski> you mean the lambdabot inputs ?
00:54:07 <ski> normally one'd write `class' and `instance' declarations over multiple lines, yes
00:54:17 <hyiltiz> class Apply f as b | f as -> b , as b -> f where apply :: f -> as -> b
00:54:21 <ski> yes
00:54:32 <ski>   class Apply f as b | f as -> b , as b -> f
00:54:34 <ski>     where
00:54:40 <ski>     apply :: f -> as -> b
00:54:45 <ski> is how i'd indent it
00:55:24 <hyiltiz> i k; i think the multiline format also helps me think; but i guess i'd have to first write them multiline then join since I cant just spew out a oneliner
00:56:20 <ski> you can't feed a declaration, or expression, or command, spanning over multiple messages, to lambdabot
01:01:02 <hyiltiz> Just reading what | and , means in the class definition (between class and where)
01:01:16 <ski> yea, that's the Functional Dependencies
01:01:54 <typetetris> How can I ensure, that a value is forced, before I put it into an TMVar? I search for kind of strict putTMVar
01:02:33 <ski>   putTMVar tmvar $! x
01:02:47 <typetetris> ski: Thank you!
01:02:58 <ski> normally one could also use
01:03:03 <ski>   putTMVar tmvar =<< evaluate x
01:03:25 <ski> but `evaluate' is just in `IO', and, afaik, there's no corresponding thing defined for `STM'
01:04:52 <hyiltiz> Ooooh~ found it, `class E a b | a -> b, b -> a where ...` means there is bijection
01:05:56 <ski> (sometimes there's also strict versions of operations, but it seems there's no such for `putTMVar', in `Control.Monad.STM' at least)
01:06:18 <ski> hyiltiz : partial bijection
01:07:02 <hyiltiz> right; cuz it doesnt have to fully cover
01:07:59 <ski> i wonder, with `DataKinds', if it would make sense to also be able to specify totality/surjectivity conditions, on a type class (or type family)
01:08:13 <hyiltiz> https://wiki.haskell.org/Functional_dependencies mentions Haskell'
01:08:18 <hyiltiz> Is that a new lang spec?
01:09:44 <ski> @wiki Haskell prime
01:09:44 <lambdabot> https://wiki.haskell.org/Haskell_prime
01:10:47 <ski> @wiki Language and library specification#Future revisions of the language
01:10:47 <lambdabot> https://wiki.haskell.org/Language_and_library_specification#Future_revisions_of_the_language
01:11:45 <ski> it's more like the continued process that'll (hopefully) turn out new language specs
01:12:22 <ski> i'm not sure whether that name is still in use, though, since <prime.haskell.org> is down
02:00:45 <hyiltiz> http://dis.um.es/~alberto/hmatrix/hmatrixtut.html Looks like such a beautifully designed library; anyone coming from Matlab/Octave/R/Python feeling anything lacking/awkward in HMatrix?
02:01:36 <hyiltiz> I'd like to use this for my next project (tho my collagues would hate me since they don't feel it is collaborative of me writing in a "weird" language)
02:05:29 <L29Ah> it lacks easiness to run on windows xp
02:05:45 <L29Ah> gladly it was simple to switch to matrix
02:13:23 <hyiltiz> matrix is another library more recent than HMatrix?
02:13:44 <hyiltiz> I care nothing about Windows XP
02:14:20 <hyiltiz> I even feel sad that I typed that^ sentence spending energy and using up channel space
02:15:33 <L29Ah> matrix is pure haskell while hmatrix is a binding
02:38:50 <asheshambasta> https://gist.github.com/asheshambasta/2ff9bf000d400f08f2856b916e7ee8d8#file-minimalfoo-hs-L27-L29 how does one implement this function?
02:48:08 <ski> which `Foo's do you want to compute ?
02:50:50 <ski> `wanted' ? `avail' ? `wanted ++ avail' ? something else ?
02:50:58 <asheshambasta> wanted
02:52:00 <ski> use a singleton instead of `Proxy wanted', or add some method to `HasFoo f fs' to query `f', is what i'd try
02:54:08 <ski> (since presumably `lookupFoo :: FooServers fs m -> ServerT (Route f) m' doesn't allow you to recover `f' from a `ServerT (Route f) m'. even assuming you could manufacture an `FooServers fs m' from nothing)
03:08:42 <asheshambasta> ski: thanks; I'll need to look into singletons. I tried the latter suggestion but couldn't really figure out how to add the lookupFoo for the inductive typeclass instances. 
03:09:14 <asheshambasta> I somewhat think `FCons` needs more values. 
03:12:31 <ski> asheshambasta : why ?
05:05:42 <asheshambasta> ski: was afk, sorry about that. Why I was saying it needs more values is that it could carry a value of `wanted` and I could just pattern match it out in a typeclass function .
05:05:52 <asheshambasta> Is there a good tutorial on singletons?
05:09:05 <merijn> asheshambasta: The Hasochism paper, probably?
05:09:44 <ski> asheshambasta : but that wouldn't directly help with `foos' now, would it ?
05:14:37 <asheshambasta> ski: you said use a `singleton` instead of a proxy foo so that led me to start looking into singletons. #facepalm
05:14:59 <asheshambasta> I now see you meant /singleton/ as in concept of a singleton not as in the library. 
05:15:25 <asheshambasta> merijn: thanks, looking that up.
05:17:18 <ski> yes
05:53:19 * hackage either-result 0.3.1.0 - ‘MonadFail’ instance for a wrapper of ‘ExceptT String m a’.  https://hackage.haskell.org/package/either-result-0.3.1.0 (kakkun61)
05:57:25 <fendor> I have a weird error message: https://gist.github.com/fendor/73692b6d132e754f93ddd0c63410024a that essentially says that  forall b. IO b -> IO b can not be matched on a type that should match, afaict
05:58:09 <merijn> fendor: The unmask function is a clue
05:58:28 <merijn> fendor: Unmask has a Rank2, which means it *requires* a polymorphic function
05:58:40 <merijn> fendor: I'm guessing that you're passing a non-polymorphic one
05:59:01 <fendor> merijn, but that used to compile, the error seems to be only with GHC HEAD...
05:59:18 <merijn> Indeed, the type of "workRun" isn't polymorphic
06:00:09 <ski> @type Control.Concurrent.Async.asyncWithUnmask
06:00:10 <lambdabot> ((forall b. IO b -> IO b) -> IO a) -> IO (Control.Concurrent.Async.Async a)
06:00:19 <merijn> fendor: I highly doubt that code ran in that exact form
06:00:43 <merijn> In fact, I promise you that it didn't :p
06:00:57 <merijn> Did you add the type signatures later?
06:01:08 <fendor> merijn, yeah
06:01:22 <fendor> did I do a mistake?
06:01:26 <merijn> fendor: That's what broke it, because your types are wrong (more restrictive)
06:01:36 <fendor> no, it broke before, that is why I added types
06:01:48 <fendor> to help me understand what is going on
06:01:54 <merijn> It might be broken for multiple reasons, then ;)
06:02:06 <merijn> fendor: Unmask wants "(forall b. IO b -> IO b) -> IO a"
06:02:14 <merijn> the 'forall b' *matters*
06:02:21 <ski> what's type of `logDebug',`shakeRunDatabase' ?
06:02:46 <fendor>  :t shakeRunDatabase :: ShakeDatabase -> [Action a] -> IO ([a], [IO ()])
06:03:04 <fendor>  :t logDebug :: Logger -> T.Text -> IO ()
06:03:16 <merijn> fendor: 'IO ([()], [IO ()]) ->  IO ([()], [IO ()])' isn't polymorphic, so that doesn't unify with (forall b. IO b -> IO b)
06:03:17 <fendor> merijn, matters how? 
06:03:25 <fendor> what, why?
06:03:58 <merijn> fendor: Let's leavet his code for a bit and let me point you to my minimal example for clarifying Rank2 types
06:04:14 <merijn> fendor: https://gist.github.com/merijn/77e3fa9757658e59b01d
06:04:31 <ski> (well, actually `asyncWithUnmask' is rank-3. it's `workRun' that must be rank-2)
06:04:37 <merijn> fendor: "forall b . IO b -> IO b" is a function that works for, well, all 'b'
06:05:25 <merijn> fendor: If you pick a specific type (like '([()], [IO ()])') then that's not working for *all* 'b' that just works for one specific 'b' (the one you specified)
06:06:02 <merijn> fendor: The simplest example I can think of is shown in that gist and (hopefully) gives some insight about what the difference is
06:06:16 <ski> fendor : try this signature : `workRun :: (forall a. IO a ->  IO a) -> IO (IO ())'
06:06:46 <merijn> fendor: It's basically the difference between "does the caller of a function pick the type variables" (the normal default) or "does the function itself get to pick the type of the type variables" (the Rank2 version)
06:07:22 <merijn> In the latter case the caller is *forced* to pass a polymorphic function, since you can't know what type variables the called function will pick
06:07:24 <ski> merijn : you saw that `asyncWithUnmask' is rank-3 ?
06:07:33 <merijn> ski: Yeah
06:07:35 <fendor> ah... by choosing the type in workRun, it can not satisfy the constraint from asyncWithUnmask?
06:07:41 <merijn> fendor: Right
06:08:13 <ski> which means that it's sortof polymorphic in `b'
06:08:28 <fendor> ok makes sense. Then the last question is why used this to compile and does not anymore? 
06:08:38 <fendor> ski, that works and makes sense with the contex, thank you! 
06:08:43 <ski> you had no signature before, fendor ?
06:08:54 <fendor> ski, yeah, no signature
06:09:39 <fendor> ski, that is what is looks like right now: https://github.com/digital-asset/ghcide/blob/master/src/Development/IDE/Core/Shake.hs#L596
06:09:50 * hackage webgear-server 0.1.0 - Composable, type-safe library to build HTTP API servers  https://hackage.haskell.org/package/webgear-server-0.1.0 (rkaippully)
06:10:00 <fendor> merijn, thanks for the nice explanation!
06:10:06 <ski> fendor : `asyncWithUnmask' requires to pass a polymorphic callback, `restore', to its callback, here your `workRun'
06:10:43 <ski> fendor : it's one step more complicated than the rank-2 situation merijn described
06:13:23 <ski> fendor : for ordinary polymorphic (aka rank-1), caller chooses/picks types for type variables. for rank-2, callee chooses. for rank-3, caller again (more specifically the callback argument that the caller passes, in your case that callback argument is `workRun') chooses
06:14:48 <ski> note that `mangle' is rank-2, but is not polymorphic. caller doesn't pick any type. callee, that is the implementation of `mangle', chooses `a' (to be either `Int', or `Double', depending on the case)
06:16:35 <ski> otoh, `asyncWithUnmask' has both rank-3 `forall', and rank-1 (ordinary polymorphism) `forall'. we still say it's rank-3 overall, taking maximum
06:17:19 * hackage eventsourcing 0.9.0 - CQRS/ES library.  https://hackage.haskell.org/package/eventsourcing-0.9.0 (thoferon)
06:17:56 <ski> while your `workRun' has a rank-2 `forall' (but no rank-1 `forall'), is rank-2. its implementation will pick `a' to be `([()],IO [()])'
06:18:44 <NewToHaskell> How do I install packages with cabal again through cmd? =)  
06:18:47 <NewToHaskell> Would like to install hlint
06:18:50 * hackage eventsourcing-postgresql 0.9.0 - PostgreSQL adaptor for eventsourcing.  https://hackage.haskell.org/package/eventsourcing-postgresql-0.9.0 (thoferon)
06:19:54 <NewToHaskell> `cabal install hlint` got it. 
06:24:02 <fendor> ski, that is a lot to digest. is it rank-1 polymoprhic because of this (... -> IO a) -> IO (Async a)?
06:25:57 <ski> there's a `forall a.' before the whole type. it's just left implicit
06:26:23 <ski> that `forall' could be said to be rank-1 (since it's not nested to the left of any `->')
06:26:43 <ski> however, we take the maximum of the left-nesting of all the `forall's
06:27:14 <ski> so since there's another `forall' at "level 3", we say that the operation is rank-3
06:30:25 <NewToHaskell> Can I call hlint with a function defitinon only instead of the entire script? =)  
06:30:43 <NewToHaskell> instead of `hlint C:\Users\Administrator\HaskellProjects`
06:30:52 <NewToHaskell> maybe hlint `function`
06:31:33 <fendor> ok thanks. so, caller chooses type of a, asyncWithUmask chooses the type of b?
06:32:04 <ski> no
06:32:30 <ski> that would be the case if it was `forall a. (forall b. ..a..b..) -> ..a..'
06:32:48 <asheshambasta> about singletons; I'm having quite a lot of trouble understanding the first 2 sentences in this answer: https://stackoverflow.com/a/16018937/1360368
06:32:56 <ski> but it's actually `forall a. ((forall b. ..a..b..) -> ..a..) -> ..a..'
06:33:23 <asheshambasta> Which singleton type is the author talking about? Is it `data S` or `data Z`?
06:33:41 <ski> instead of one `forall' on level 1, and one on level 2, we have one on level 1, and one on level 3
06:33:47 <asheshambasta> in which case, `data S` /does not/ have "one value" as is claimed by the answer. 
06:35:45 <ski> fendor : so, it's "caller (whatever definition contains your pasted code) chooses type `a', callback argument (your `workRun') chooses type `b'"
06:36:17 <maralorn> In the generated Haskell code here on the third line the GADT Just constructor. Is that valid Haskell? https://serras.github.io/hinc/
06:36:58 <fendor> ski, it chooses that by using it?
06:37:40 <ski> fendor : it chooses `b' by deciding what to pass to `restore' (or how to use the result of such calls)
06:38:18 <ski> (note that there can be multiple choices for `b', unlike for `a', for a single call to `asyncWithUnmask')
06:38:44 <fendor> yeah, that is why the explicit forall is needed, right?
06:38:50 <fendor> in ghc/haskell at least
06:38:59 <ski> asheshambasta : it does not mention `data S'. it mentions `data S n'
06:40:37 <ski> asheshambasta : "Which singleton type is the author talking about? Is it `data S` or `data Z`?" -- it's talking about types `n' such that `Nat n' holds. i.e. `Z',`S Z',`S (S Z)',`S (S (S Z))',&c. are singleton types
06:44:14 <ski> asheshambasta : another way to model this, is to not use a type class, but rather `DataKinds'. first make `data Nat = Z | S Nat', and note that you now get a kind `Nat', whose inhabitants are types `Z',`S n' (when `n' has kind `Nat'). then you can declare a GADT `data NatIs :: Nat -> * where IsZ :: NatIs Z; IsS :: NatIs n -> NatIs (S n)' so that all types `NatIs n' (for all possibly `n' of kind `Nat') are singleton types
06:48:34 <ski> fendor : search for "You can use record syntax on a GADT-style data type declaration:" under <https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#gadt-style>, also check <https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#generalised-algebraic-data-types-gadts>
06:48:42 <ski> er
06:48:44 <ski> sorry
06:48:49 <ski> maralorn ^
06:51:35 <ski> (also, bletch)
06:57:00 <asheshambasta> ski, thanks; that gets me a bit further.
07:02:18 <NewToHaskell> Someone who knows whether I can use hlint on a function alone or is it only possible to use over the entire file?
07:02:30 <NewToHaskell> https://github.com/ndmitchell/hlint/blob/master/README.md
07:27:55 <asheshambasta> https://blog.jle.im/entry/introduction-to-singletons-1.html this is also a very nice resource with practical examples.
07:38:36 <merijn> maralorn: It's valid if you enable GADTs (or GADTSyntax)
07:39:06 <merijn> tbh GADTSyntax is much better for teaching beginners ADTs, imo
07:39:45 <maralorn> merijn: Yeah, I just read the docu that ski linked. I new that you can use GADTSyntax but the record syntax was kinda a surprise to me.
07:39:58 <maralorn> On the right side of a type annotation.
07:40:18 <merijn> Only way you can make GADT records
07:41:34 <maralorn> Oh, interesting.
07:41:49 <maralorn> Apparently I never felt the urge to have a GADT record …
07:44:41 <merijn> That's likely :p
07:49:36 <merijn> Only masochists do
08:35:49 * hackage morpheus-graphql-core 0.14.1 - Morpheus GraphQL Core  https://hackage.haskell.org/package/morpheus-graphql-core-0.14.1 (nalchevanidze)
08:36:50 * hackage morpheus-graphql 0.14.1, morpheus-graphql-client 0.14.1 (nalchevanidze): https://qbin.io/male-gary-ymca
08:52:21 <ixlun> Does this sound senisble: say I have a 10x10 array of Integers and an index i.  I also have a 'vector' which says how to move along the array, say (x + 1, y + 1) for diagonal movement.  I then want to repeatedly apply that step, walking along the array until either we reach the array bounds, or, the element while walking meets some condition (elm == 1, say).  Is that a candidate for a writing monad?  Maybe a movement monad?
08:53:27 <ixlun> I'm thinking that the monad somhow controls the repeated application of the vector
08:54:12 <mmaruseacph2> does the array change? what do you do at every step with the movement? or maybe only the final position matters?
08:54:14 <merijn> ixlun: That (basically) sounds like the State monad?
08:54:37 <merijn> ixlun: Like, your state is a tuple of direction and array and you update the array at every step
08:55:02 <ixlun> mmaruseacph2: I want to get the list of elements that would be traversed
08:55:21 <ixlun> more precisely, the indexes, sorry.
08:56:06 <ixlun> merijn: Ahhh okay - looks like I need to do some reading around the State monad
08:58:10 <merijn> ixlun: State monad is really just "wrapper for passing arguments". The best way to understand it is to reinvent yourself: https://gist.github.com/merijn/098106abd45c940dab09
09:00:52 <monochrom> No monad. Pseudocode: takeWhile (\(x,y) -> (x,y) is within bounds and array(x,y) /= 1) (list of coordinates)
09:01:59 <monochrom> list of coordinates = iterate (starting point) (\(x,y) -> (x + deltax, y + deltay))
09:07:26 <monochrom> "state" is low-level thinking for what is a simple use of iterate.
09:10:37 <monochrom> Lest you argue (wrongly) that this approach requires having known "iterate":
09:11:24 <monochrom> The decomposition into "takeWhile (stopping condition) (list of coordinates)" is straight from the problem itself.
09:11:52 <monochrom> If you go on to generate the coordinates by your own recursion, you're still good.
09:12:23 <monochrom> Knowing that it's a use case of "iterate" is just a bonus.
09:13:43 <monochrom> For evidence, observe my time gap between posting the decomposition and posting how to generate the coordinates. I didn't know to use "iterate" either. I only knew it was a great decomposition.
09:29:27 <ixlun>  monochrom that makes sense.  I'll look at trying to decompose things into functions and seeing if that way I can build up the complexity by composing with takeWhile and iterate
09:33:50 <ixlun> so can you think of 'iterate' as basically a fold but just that intermediate values are returned in the list?
09:35:46 <MarcelineVQ> hmm, quit-message spam, interesting angle
09:44:05 <monochrom> unfold
09:44:20 <veverak> , /buffer #twitter_squirrelcze 
09:44:23 <veverak> fuuuu :)
09:48:56 <turion> Is there a fairly standard typeclass for product types? i.e. abstracting fst, snd and pair constructors?
09:52:02 <monochrom> No.
09:52:21 <monochrom> lens does that abstraction but not as type class.
09:52:29 <tomsmeding> what types would you expect to be members of that typeclass?
10:09:49 * hackage uniqueness-periods 0.1.0.0 - Can be used to produce the 'uniquenessPeriods' function and related functionality.  https://hackage.haskell.org/package/uniqueness-periods-0.1.0.0 (OleksandrZhabenko)
10:12:20 * hackage uniqueness-periods-general 0.1.0.0 - Can be used to produce the similar to 'String.Ukrainian.UniquenessPeriods' functions.  https://hackage.haskell.org/package/uniqueness-periods-general-0.1.0.0 (OleksandrZhabenko)
11:46:50 * hackage runhs 1.0.0.6 - Stack wrapper for single-file Haskell programs.  https://hackage.haskell.org/package/runhs-1.0.0.6 (danielbrice)
11:53:31 <ixlun> monochrom: Just had a go at using iterate as you suggested althgouh I've hit a problem.  The function that produces a new index from a given direction has signature: translate :: Position -> Direction -> Maybe Position. Since it yields I Maybe Position, I can't use that in iterate
11:53:45 <merijn> :t iterateM
11:53:46 <lambdabot> error:
11:53:46 <lambdabot>     • Variable not in scope: iterateM
11:53:46 <lambdabot>     • Perhaps you meant one of these:
11:53:49 <merijn> aww
11:53:53 <merijn> That doesn't exist?
11:54:15 <merijn> oh, I guess because it can't be lazy
11:57:35 <monochrom> ixlun: When does it give Nothing?
12:00:14 <ixlun> if the next index is out of bounds
12:02:19 <dminuoso> merijn: Well you could have something using a list-t
12:03:05 <monochrom> Then consider unfoldr, or you can still write your own recursion.
12:03:26 <monochrom> Or leave the bound checks to the takeWhile condition.
12:04:26 <monochrom> You can always steal the source code of iterate or unfoldr or whatever, then modify to suit your context.
12:05:00 <ixlun> ahh, unfoldr looks quite elegant
12:05:22 <ixlun> Sorry for all the questions - I'm still learning a lot!
12:16:24 <arashout> Hi I'm trying to the first problem in project euler using Haskell.
12:16:24 <arashout> It's "sum multiples of 3 or 5".
12:16:24 <arashout> I have function that can do it like so:
12:16:24 <arashout> sumMultiples :: Int -> Int
12:16:24 <arashout> sumMultiples limit = 
12:16:24 <arashout>     sum . 
12:16:25 <arashout>     filter (\x -> (mod x 3) == 0 || (mod x 5) == 0) $ 
12:17:19 * hackage mmsyn6ukr 0.8.0.0 - A musical instrument synthesizer or a tool for Ukrainian language listening  https://hackage.haskell.org/package/mmsyn6ukr-0.8.0.0 (OleksandrZhabenko)
12:51:19 * hackage mmsyn7ukr 0.17.0.0 - A simple basic interface to some SoX functionality or to produce a voice that can be used by mmsyn7h  https://hackage.haskell.org/package/mmsyn7ukr-0.17.0.0 (OleksandrZhabenko)
12:55:20 * hackage mmsyn7l 0.8.0.0 - Modifies the amplitudes of the Ukrainian sounds representations created by mmsyn7ukr package.  https://hackage.haskell.org/package/mmsyn7l-0.8.0.0 (OleksandrZhabenko)
12:57:51 <aldessa> Hello, does anyone know where I can get the source code to `Implementing functional languages: a tutorial` by Simon Peyton Jones et al?
12:58:31 <aldessa> I tried the 3 ftp servers `ftp.dcs.glasgow.ac.uk`, `nebula.cs.yale.edu` and `animal.cs.chalmers.se` in the book but they all sadly seem to be down (no surprise 28 years later)
12:59:37 <MarcelineVQ> aldessa: You can email simon if you don't find it elsewhere
12:59:51 <aldessa> should I email chalmers?
13:00:16 <MarcelineVQ> idk where to contact currently, any recent paper of his should get you a contact email though
13:01:01 <MarcelineVQ> If not in the paper then via where you found it :>
13:03:33 <dminuoso> aldessa: Also, try archive.org and see if it was scraped.
13:07:41 <sim590> What's the easiest way to go from MaybeT IO () to MaybeT m IO where m is some other monad?
13:08:42 <archaephyrryx> does anyone know why calling the `effects` function on a Stream (from the 'streaming' library) to get a return value for a monadic action involving the content of a stream would drop values when run over a lazy IO stream?
13:09:04 <aldessa> MarcelineVQ, dminuoso I found it on this site https://www.cs.tufts.edu/~nr/cs257/archive/simon-peyton-jones/?C=M;O=A
13:09:15 <merijn> sim590: I'll take "What is mmorph for 100 dollars" :)
13:09:18 <merijn> @hackage mmorph
13:09:18 <lambdabot> https://hackage.haskell.org/package/mmorph
13:11:19 * hackage mmsyn7s 0.8.0.0 - Shows a sorted list of the Ukrainian sounds representations that can be used by mmsyn7 series of programs  https://hackage.haskell.org/package/mmsyn7s-0.8.0.0 (OleksandrZhabenko)
13:13:43 <dminuoso> Are there haskell host to network byte order conversion for all Int*/Word* functions in base somewhere?
13:14:17 <merijn> Not in base, no (sadly)
13:14:46 <dminuoso> Mmm, what package has it?
13:15:35 <merijn> dminuoso: https://hackage.haskell.org/package/cpu-0.1.2/docs/System-Endian.html
13:16:01 <merijn> I guess that's only unsigned, though
13:16:12 <merijn> Adding signed versions was somewhere in my yak herd
13:21:08 <dminuoso> merijn: Mmm, base wouldn't happen to have casts between Int* and Word*, would it? :p
13:21:38 <dminuoso> But, I think I can work with having just unsigned
13:21:44 <sim590> merijn: Interesting. I opted for: `MaybeT $ liftIO $ runMaybeT $` which is a little more verbose, but it works. I'm not sure how to use mmorph. Would that be the "lift" function?
13:21:55 <dminuoso> sim590: look for hoist
13:22:19 <sim590> Oh. I see.
13:22:25 <merijn> Yeah, you want hoist
13:22:59 <sim590> hoIs(ee)t
13:24:04 <dminuoso> Mmm. Gah I think cpu wont help me... I hate you ioctl.
13:24:20 <merijn> dminuoso: Wait
13:24:20 * hackage mmsyn7h 0.8.0.0 - Produces a sound recording specified by the Ukrainian text.  https://hackage.haskell.org/package/mmsyn7h-0.8.0.0 (OleksandrZhabenko)
13:24:25 <merijn> dminuoso: Why does it matter for ioctl?
13:24:37 <dminuoso> Id need to have endianness conversion support on up to Word256
13:25:12 <dminuoso> merijn: So this ioctl gives me a bitmask.. in a u32* buffer..
13:27:42 <Batzy> I'm new to functional programming and I am trying to return the first divisor of a number N. I know I can get a list if divisors by doing something like [x | x <- [1..N], N `rem` x == 0] and I can even get the smallest divisor by doing "head" on this list. But doesn't this find all divisors first so it's less efficient than just finding the first divisor alone?
13:28:19 <merijn> Batzy: No, because it doesn't compute the entire list
13:28:32 <merijn> Batzy: You only compute as much of the list as needed to return
13:29:04 <merijn> Batzy: So if you use head and look at the first element, you only ever compute until the first time "n `rem` x == 0" is true
13:29:11 <Batzy> merijn: it picks that up from the head function?
13:29:13 <Batzy> omg
13:29:15 <Batzy> haskell 
13:29:18 <Batzy> you baby
13:29:23 <Batzy> that's crazy
13:29:36 <dminuoso> And it seems, that the buffer is little endian (in the sense that bit 0 is always located in the first u32)
13:29:54 <merijn> dminuoso: eh
13:29:55 <dminuoso> Perhaps Ill just pretend the buffer cant ever be larger than 2..
13:30:01 <Batzy> merijn: I like love and hate haskell
13:30:13 <merijn> bitmask indexing is very different an unrelated to endianness, though
13:30:15 <Batzy> the thing I hate about haskell is that I learned other paradigms first and used them for a long time
13:30:22 <dminuoso> merijn: No it is in this case.
13:31:05 <dminuoso> merijn: Given a `struct foo { ...; u32 *buf; }`, endianness dictates whether bit 0 is found in the first element at buf or the last..
13:31:54 <dminuoso> (That's the way this particular ioctl encodes a bitmask with more than 32 bits)
13:33:38 <merijn> wow...
13:33:47 <merijn> that's some linux quality engineering right there
13:33:51 * hackage dobutokO2 0.43.0.0 - Helps to create experimental music from a file (or its part) and a Ukrainian text.  https://hackage.haskell.org/package/dobutokO2-0.43.0.0 (OleksandrZhabenko)
13:34:26 <dminuoso> This entire ioctl is really rage inducing.
13:34:56 <dminuoso> Very little documentation ontop. Most of it Im just figuring out by dissecting (undocumented) tools that use it.
13:35:13 <merijn> ioctl itself is just shite and the hacky non-portable linux ones are even worse
13:35:36 <dminuoso> Well this one being replaced by netlink right now, but the support is brand new. 
13:42:51 * hackage runhs 1.0.0.7 - Stack wrapper for single-file Haskell programs.  https://hackage.haskell.org/package/runhs-1.0.0.7 (danielbrice)
13:44:23 <Batzy> https://gist.github.com/Tatzy/df0074eee63ab7ca03e3d34a264d3951 what am I doing wrong?
13:44:41 * sm[m] . o O ( soo.. like a stack script then ? )
13:44:45 <Batzy> im getting a parse error
13:45:08 <dminuoso> Batzy: let requires an in
13:45:17 <dminuoso> % let x = 1 in print x
13:45:17 <yahb> dminuoso: 1
13:45:33 <Batzy> wat
13:45:38 <dminuoso> The `in` is just dropped in the do-notation. Perhaps that confused you
13:45:53 <Batzy> i dont have any do
13:45:56 <dminuoso> Precisely.
13:46:07 <Batzy> so...
13:46:09 <Batzy> what
13:46:16 <dminuoso> Regular let requires an in. let inside do-notation does not.
13:46:31 <Batzy> what is "in" doing?
13:46:38 <Batzy> i guess i can just put this inside of do but
13:46:50 <dminuoso> Batzy: let creates bindings that are valid in a given expression
13:46:53 <sm[m]> the room recoils in horror
13:46:56 <dminuoso> So `let bindings in expr` :)
13:47:04 <hexagoxel> »primes n/x« is »(primes n)/x«
13:47:28 <Batzy> o
13:47:41 <dminuoso> "let x equal y in expression"
13:47:46 <dminuoso> If you read this aloud, it makes sense.
13:48:08 <Batzy> im still trying to figure out how to fix it, so
13:48:26 <dminuoso> Just add the `in`?
13:48:36 <sm[m]> putting "in " before "primes n/x" would fix it. Then you'll see the next problem
13:49:08 <dminuoso> Batzy: The confusing part is why do-notation does not require you to write the in. I dont know the answer to that. 
13:49:46 <dminuoso> Perhaps its to fit the entire mind model that everything you write is only valid in the following anyhow. Whether its let bindings or bindings introduced via <-
13:49:54 <Batzy> im going to guess the next error is because it doesnt know n/x is an integer?
13:50:44 <hexagoxel> :t (/)
13:50:45 <lambdabot> Fractional a => a -> a -> a
13:50:49 <sm[m]> it's because of what hexagoxel said. You need parenthese around n/x
13:50:52 <Batzy> i fixed it with `div`
13:51:00 <Batzy> sm[m]: that doesnt fix it either
13:51:08 <sm[m]> does too
13:51:10 <Batzy> these are integers, I think it breaks it
13:51:12 <Batzy> no it doesnt...
13:51:15 <Batzy> i literally *just* did it
13:51:21 <aldessa> Is prettyprinter the best pretty printing library?
13:51:21 <hexagoxel> yeah you are both correct :)
13:51:45 <sm[m]> bah so did ! I'll fight you!
13:51:48 <dminuoso> aldessa: Its certainly a good one.
13:51:57 <sm[m]> :) it compiles, anyway
13:52:01 <dminuoso> I'd be careful with any "is XYZ best?" assessment.
13:52:05 <Batzy> im using ghci sm[m] 
13:52:11 <Batzy> dminuoso: how do I do multiple expression that?
13:52:14 <Batzy> then*
13:52:16 <Batzy> do I need 'do'
13:52:18 <Batzy> ?
13:52:21 * hackage dobutokO3 0.3.0.0 - Helps to create more complex experimental music from a file (especially timbre).  https://hackage.haskell.org/package/dobutokO3-0.3.0.0 (OleksandrZhabenko)
13:52:42 <dminuoso> Batzy: What does multiple expressions even mean?
13:52:46 <dminuoso> Consider:
13:52:51 <Batzy> dminuoso: let's say I want to print x before doing primes n/x
13:52:52 <sm[m]> Batzy: I have https://termbin.com/auz8
13:52:58 <dminuoso> f = expr1 <magical seperator> expr2
13:53:02 <dminuoso> what would that even do?
13:53:14 <Batzy> dminuoso: it loads but then do primes 20
13:53:17 <Batzy> or something
13:53:19 * hackage dobutokO4 0.8.0.0 - Helps to create experimental music. Uses SoX inside.  https://hackage.haskell.org/package/dobutokO4-0.8.0.0 (OleksandrZhabenko)
13:53:36 <Batzy> sm[m]: that was to you, do primes 20
13:53:46 <Batzy> dminuoso: I'm not getting the cryptic answers tbh
13:53:50 <dminuoso> aldessa: There is also `pretty`
13:54:11 <sm[m]> yes it doesn't run. I meant it compiles.
13:54:20 * hackage dobutokO-poetry-general 0.1.0.0 - Helps to order the 7 or less words (first of all the Ukrainian ones) to obtain somewhat suitable for poetry or music text  https://hackage.haskell.org/package/dobutokO-poetry-general-0.1.0.0 (OleksandrZhabenko)
13:54:49 <Batzy> sm[m]: yes
13:55:06 <Batzy> you have to use `div`, apparently
13:55:21 <Batzy> let me repaste code
13:56:12 <dminuoso> Batzy: So strictly speaking, we cant just "print" in the middle of an expression or before it.
13:56:25 <dminuoso> printing being an effect, we need to do this inside IO somehow
13:57:18 <Batzy> i cant just do print x
13:57:20 <Batzy> after defining x
13:57:23 <Batzy> so
13:57:36 <dminuoso> well you can if you're in IO
13:57:39 <dminuoso> say
13:57:47 <dminuoso> `f :: IO (); f = print x where x = ...`
13:57:59 <dminuoso> But if your function is of type:
13:58:21 <dminuoso> `primes :: Integer -> String`, then you cant do printing in there.
13:58:49 <dminuoso> Well we have special debugging tools that still allow you to print there, e.g. `trace`, but lets ignore those
13:59:09 <aldessa> ty I think I'll try `pretty` simply for the dumb reason it has more downloads on hackage
14:00:41 <dminuoso> aldessa: The ergonomics pretty much the same. You can change forth and back with little effort.
14:00:52 <aldessa> so it really doesn't matter
14:00:53 <aldessa> ?
14:01:05 <hexagoxel> Batzy: what _do_ you want the function to return/print? (and yes I am torpedoing the pedagogy by conflating the two..)  because as it stands it seems the function should always return "done".. so why not primes _ = "done" :p
14:01:26 <Batzy> hexagoxel: well im building onto it, that's temporary
14:01:31 <aldessa> they both remind me of an ocaml pretty printing library so I guess functional pretty printing doesn't change too much?
14:02:11 <sm[m]> aldessa you should probably consider upload date and frequency too
14:02:53 <Batzy> dminuoso: so now I have to change the type of the function to print anything??
14:03:03 <dminuoso> Batzy: Right.
14:03:07 <Batzy> fuck me..
14:03:24 <aldessa> haha, hard to find the best arbitrary way to choose libraries
14:03:26 <dminuoso> Batzy: You had to add an `IO`. If you just want it for debugging, you can get away with using `trace`
14:04:10 <sm[m]> aldessa: two features you might care about: do they pretty-print Show-able things automatically, and do they print (prettily or not) things whose Show output is not Read-able
14:04:20 <hexagoxel> I would advise against involving IO in this. Instead, think about what information you want to get out of the function. Do you perhaps want to show a list of steps? then perhaps you want Int -> [Int] ?
14:04:29 <hexagoxel> you can always print (primes 20)
14:05:02 <hexagoxel> ("always" assuming that it is _not_ IO)
14:05:31 <aldessa> sm[m], are you saying that some pp libraries essentially derive their own show instances?
14:05:53 <aldessa> like they can take an arbitrary ADT and pretty print it in a nice way?
14:06:05 <Batzy> dminuoso: Debug.Trace.trace x ?
14:06:10 <sm[m]> yes indeed, eg pretty-show will pretty print a list of showable ADTs without you having to write any pretty printing code
14:06:27 <sm[m]> but it fails on item 2 I mentioned, I think there is a better newer lib
14:07:07 <aldessa> that sounds amazing for debugging
14:07:20 <sm[m]> tis, it's must
14:07:22 <sm[m]> a must
14:07:57 <aldessa> I tend to draw the output of programs, like a tree I might draw on paper based on the constructors
14:08:00 <aldessa> but this sounds easier
14:09:09 <dminuoso> Batzy: Any of the functions in the module. This is just for debugging though, partly because it's possible for various reasons it will never print. Or it will print. Or it will print multiple times (unexpectedly)
14:09:19 <sm[m]> pretty printing of Show-ables is always a good thing to have available, then you can add more custom printers where useful
14:09:38 <sm[m]> Data.Tree has showTree I think
14:10:03 <dminuoso> Batzy: It's a useful primitive to gain debugging insights in the middle of some pure code. "Show me XYZ when that other value is evaluated"
14:11:24 <Batzy> dminuoso: but if i import debug.trace
14:11:26 <Batzy> it breaks everything
14:12:36 <aldessa> damn, i feel like i've been programming in the stone age
14:12:49 * hackage dobutokO-poetry 0.12.0.0 - Helps to order the 7 or less Ukrainian words to obtain somewhat suitable for poetry or music text  https://hackage.haskell.org/package/dobutokO-poetry-0.12.0.0 (OleksandrZhabenko)
14:14:28 <maerwald> how do you do printing logs to a window in brick? Do you add the lines to the state?
14:14:40 <sm[m]> aldessa: many of us partly are I think. There's so much to think about, and so many ways to fail setting things up, we miss a lot of good stuff.
14:15:27 <sm[m]> maerwald: yeah I guess so
14:15:45 <maerwald> I wonder if the event loop is fast enough for that to scale
14:16:16 <aldessa> i wonder is there an extension to do custom typeclass derives, like deriving ShowPretty or something
14:17:08 <sm[m]> Batzy: hard to help without more details there. By the way https://leanpub.com/haskell-cookbook/read#leanpub-auto-tutorial-on-impure-haskell-programming gives more background on this IO stuff
14:17:39 * Batzy creys
14:17:43 <Batzy> I have to go for a bit though
14:17:53 <Batzy> I might be back if I am bored enough to try learning more Haskell
14:18:08 <sm[m]> good luck.. it'll be easy later :)
14:18:24 <Batzy> Haskell is never easy
14:18:35 <Batzy> but it looks so nice...
14:18:43 <Batzy> especially to a mathematician
14:18:45 <Batzy> ok bye
14:18:53 <sm[m]> it can be, it can be. For fastest help you have to show what you're doing. It's well worth the effort
14:19:22 <Batzy> I mean
14:19:26 <Batzy> I've also been looking at racket too
14:19:36 <Batzy> at the same time...but Haskell forces you to be more functional I think
14:20:14 <sm[m]> you mostly did that, sorry. Sometimes people don't show anything. Yeah Racket is cool but less transformative perhaps
14:20:55 <Batzy> i have no idea what you're referring to because I'm a noob at both :)
14:22:53 <aldessa> what does n/x mean?
14:23:03 <aldessa> is this meant to be list difference?
14:24:41 <sm[m]> normally just numerical division aldessa
14:26:16 <aldessa> will this always go to the base case of 1 Batzy, I'm concerned floating point error could make it not?
14:27:20 <aldessa> if you write primes (n `div` x) it compiles but i'm confused
14:28:19 * hackage dobutokO-poetry 0.13.0.0 - Helps to order the 7 or less Ukrainian words to obtain somewhat suitable for poetry or music text  https://hackage.haskell.org/package/dobutokO-poetry-0.13.0.0 (OleksandrZhabenko)
14:28:43 <sm[m]> aldessa: it figures that n is Integral because of the use of rem
14:29:01 <dolio> aldessa: (/) is fractional division, and div is integer division.
14:29:16 <aldessa> no like what is the program supposed to do
14:29:21 <aldessa> i get that
14:29:32 <sm[m]> ah, that we don't know
14:33:50 <sm[m]> Racket has a very good book on designing programs (HTDP). That would help designing this haskell program too.
14:34:33 <sm[m]> not just a book, a repeatable method for designing programs
14:36:23 <sm[m]> here it is: http://htdp.org/2003-09-26/Book/curriculum-Z-H-5.html#node_sec_2.5
14:37:00 <monochrom> I just resent that it doesn't promote pattern matching, still stuck in 1960s predicates and selectors.
14:37:15 <monochrom> The limitation of sticking to standard Scheme.
14:37:57 <sm[m]> they're working on a second edition ? Maybe it's haskell based ? we can hope :)
14:40:52 <sm[m]> I think the key advice there is: write down some examples first
14:41:19 <aldessa> maybe for learning functional programming, it could help to have a visual programming language. like where you can see the data structures that pattern match on a definition
14:41:22 <aldessa> has this been done before?
14:42:10 <monochrom> I think visual is overrated red herring.
14:42:40 <monochrom> If you have an elaborate tree or network, yes pictures are good.
14:42:47 <aldessa> i meant for that
14:43:01 <aldessa>  not for general purpose programming, just explaining those concepts
14:43:29 <sm[m]> there have been lots of visual hacks for illustrating various things, like evaluation
14:45:01 <sm[m]> https://www.google.com/search?hl=en&q=visualize%20haskell brings up a few
14:46:12 <aldessa> ty
14:46:24 <monochrom> I once saw a picture attempting to explain "fibs = 1 : 1 : zipWith (+) fibs (tail fibs)". It totally failed on me.
14:46:57 <dolio> Heh, I guess that's like that 7 trees thing an evening or two ago.
14:47:16 <dolio> Cale linked some picture of it, and it meant nothing to me, even after reading the paper. :)
14:47:39 <monochrom> Instead, the denotational formulaic "consider f_0 = bottom, f_n = 1 : 1 : zipWith (+) f_{n-1} (tail f_{n-1)}" worked perfectly.
14:47:53 <monochrom> A formula is worth a thousand pictures --- Dijkstra
14:48:07 <ski> @where Vital
14:48:07 <lambdabot> "Vital is a document-centered implementation of Haskell","The Vital project (acronym: Visual Interactive Typed Applicative Language) is investigating a /document-centered/ approach to functional
14:48:07 <lambdabot> programming with an emphasis on the display and /direct manipulation/ of complex data structures." (cf. spreadsheets) <http://www.cs.kent.ac.uk/projects/vital/>,<https://web.archive.org/web/2009052901
14:48:07 <lambdabot> 0107/http://www.cs.kent.ac.uk:80/projects/vital/>
14:49:51 <monochrom> https://www.haskell.org/tutorial/functions.html  scroll down to "3.4 "infinite" data structures"
14:52:03 <monochrom> The picture at most asserts that this is one fixed point. It still doesn't explain why this isn't circular logic --- the whole point of it.
14:52:33 <monochrom> Only either playing with bottoms or playing with lazy evaluation helped me.
14:52:43 <ski> isn't the largest problem with it is that it doesn't start at `0' ?
14:52:58 <dolio> I think that's one of the most frustrating things about learning homotopy type theory stuff. The mathematicians always want to tell you about visual intuitions that I don't have.
14:53:03 <Cale> dolio: Well, I neglected to explain what was going on there... did you figure it out?
14:53:14 <dolio> Cale: Nah, don't really care enough. :)
14:53:18 <monochrom> I'm OK with saying that in case of lazy evaluation, picture is even necessary to show sharing and aliasing. Hell, my own lazy eval tutorial is full of those.
14:53:19 <ski> hm, istr Thompson having a series of pics, that displayed the operational behaviour ?
14:53:30 <Cale> dolio: Ah, it's just representing the polynomials with rows of tokens
14:53:40 <monochrom> But it still means one picture per lazy eval step. Not this final picture out of the blue.
14:53:59 <monochrom> haha ski are you kidding? Dijkstra would agree haha.
14:55:24 <monochrom> And here is more empirical data that observe normal students, not me --- likely an outlier.
14:55:47 <Cale> So, a token on the first place represents 1, then T, then T^2, etc. Since we're using the isomorphism T = 1 + T^2, we can multiply that through by T^(k-1) to get T^k = T^(k-1) + T^(k+1), and it's like if there's a token in position k, we're allowed to replace it with two tokens, one at position k-1 and one at position k+1
14:55:57 <Cale> and vice versa of course, because it's an isomorphism
14:56:19 <Cale> So we can visualise the composition of these isomorphisms by playing a game where we split and merge tokens
14:56:20 <dolio> Ah.
14:56:33 <ski> Cale : yea, i got it immediately. probably i saw some similar pic, with counts instead of tokens, though
14:56:56 <monochrom> I make students learn foldr. The students split themselves into two groups, one emphasizing the popular picture that Cale drew and everyone is fond of, the other obeying me in taking algebra and induction proof seriously (http://www.cs.utoronto.ca/~trebla/CSCC24-2020-Summer/04-haskell-fold.html)
14:57:28 <Cale> Haha, sorry!
14:57:30 <monochrom> The picture group go on to totally fail at harder "rewrite as foldr" exercises.
14:57:38 <ski> i guess some people think more visually
14:57:45 <monochrom> The picture is actually a mental block.
14:58:09 <ski> maybe, if they're not trained on how to translate between it, and algebra ?
14:58:56 <monochrom> The algebra group figure out the hardest exercise I ever throw at them: the infamous "rewrite foldl as foldr" one.
14:59:25 <monochrom> This brings me to once again "what does 'understand' mean?"
14:59:51 <monochrom> Some people mean "I look at the pictures, I feel so good about myself, I understand this now"
14:59:59 <monochrom> I trash that.
15:00:17 <monochrom> I mean "you can make predictions and solve problems and get things done"
15:00:44 <ski> anyway, it ought to be `F_0 = 0',`F_1 = 1',`F_{n+2} = F_{n+1} + F_n'. that way, if one extends to negative inputs, one get the beautiful `F_{-n} = F_n' for odd `n' and `F_{-n} = -F_n' for even `n'
15:01:04 <monochrom> BTW this also ties in to how people fail or succeed with monads, for my last tangent. (End of tangent.)
15:01:45 <monochrom> I agree, ski, but it is a very minor point compared to how to learn and how to teach.
15:02:50 <ski> yes i know. it's just a pet peeve of mine ;)
15:03:02 <monochrom> ertes passed away. I hope I could tell him his article inspired me and I now teach this approach.
15:03:19 <ski> which article was that ?
15:03:27 <monochrom> http://ertes.eu/tutorial/foldr.html
15:04:13 <monochrom> It's super embarassing. I was trained to do this during my grad study days. I just didn't think of applying my training to this.
15:05:04 <monochrom> i.e., I read a lot of Hutton papers and Hinze papers and they do this too (prove correctness and come up with code at the same time).
15:05:35 <monochrom> s/hope/wish/  # damn English, so subtle
15:05:40 <monochrom> much nuance
15:05:49 * hackage dobutokO-poetry 0.14.0.0 - Helps to order the 7 or less Ukrainian words to obtain somewhat suitable for poetry or music text  https://hackage.haskell.org/package/dobutokO-poetry-0.14.0.0 (OleksandrZhabenko)
15:24:40 <kraeXen> in python we have something where we can expand a list or tuple into the arguments of a function
15:24:41 <kraeXen> eg
15:25:05 <monochrom> No, Haskell doesn't have that.
15:25:52 <kraeXen> with haskell's way of interpreting arguments to functions I'm surprised, but I'll take your word for it
15:26:09 <monochrom> Consider the types. Then it is natural.
15:26:20 <Rembane> If you are willing to squint wildly you could use curry for it. 
15:26:40 <kraeXen> curry?
15:26:46 <Rembane> :t curry 
15:26:47 <lambdabot> ((a, b) -> c) -> a -> b -> c
15:27:04 <maerwald> https://hackage.haskell.org/package/tuple-0.3.0.2/docs/Data-Tuple-Curry.html#v:curryN
15:27:06 <Rembane> kraeXen: Yes, you can give it a 2-tuple and it will apply it to a function that takes two arguments. 
15:27:07 <maerwald> might be useful
15:27:18 <maerwald> go wild
15:27:37 <kraeXen> ah, thanks
15:28:20 <ski> kraeXen : every Haskell function take exactly one argument
15:28:45 <kraeXen> technically yes
15:28:52 <kraeXen> I've seen the implementation
15:29:00 <ski> Rembane : not `uncurry', then ?
15:29:29 <Rembane> ski: Probably, I always mix them up, and it usually takes me three tries until I find the right one. 
15:29:35 <Rembane> :t uncurry 
15:29:36 <lambdabot> (a -> b -> c) -> (a, b) -> c
15:29:52 <Rembane> Yeah, uncurry it is. 
15:30:07 <dolio> It should be a clue that the person telling you about this doesn't use it often enough to remember which function is which. :)
15:30:49 <justsomeguy> So uncurry turns a function that takes two arguments into a function that takes a 2-tuple of arguments?
15:30:57 <Rembane> It's just my memory that's a bit off. I remember that I need to type :t curry <ENTER> :t uncurry <ENTER> into ghci instead of which one to actually use. 
15:31:55 <monochrom> Don't worry, sometimes I still need ":type foldl" to remind me what function I should give it. :)
15:32:03 <ski> `uncurry' turns a function that returns a function, into a function that takes a pair
15:32:38 <ski> (there is no "a function that takes two arguments")
15:32:42 <Rembane> monochrom: Same here, I also type :t foldr too many times into ghci :) 
15:33:06 <ski> i tend to mix up `toEnum' and `fromEnum'. and `chr',`ord'
15:33:13 <Rembane> ski: That's a very good point. I'm being fuzzy. 
15:33:25 <dsal> I just remember that I like foldr and it wants a function that wants "x o" so that's easy enough.  And then foldl is kind of backwards, so I give it "o x"
15:33:28 <monochrom> foldr I don't need help because I start with catamorphisms and specialize to list.
15:33:49 <monochrom> Showing that foldr is the one that has real structure.
15:34:21 <monochrom> With real structure you don't need mnemonic aid at all, there is nothing to remember, you understand the structure you have everything.
15:36:52 <ski> in SML, they have the same type
15:37:09 <monochrom> cringy
15:37:11 <ski>   val foldr : ('a * 'b -> 'b) -> 'b -> 'a list -> 'b
15:37:16 <ski>   val foldl : ('a * 'b -> 'b) -> 'b -> 'a list -> 'b
15:37:43 <ski> in OCaml they don't, but they're still not the same as in Haskell
15:37:59 <ski>   val fold_right : ('a -> 'b -> 'b) -> 'a list -> 'b -> 'b
15:38:19 <ski>   val fold_left  : ('b -> 'a -> 'b) -> 'b -> 'a list -> 'b
15:38:19 <monochrom> this ruins one of those nice theorems about "foldl = foldr . reverse" doesn't it?
15:38:52 <monochrom> bah I guess fixable by adding "flip"
15:39:03 <ski> with OCaml's version, you can now do `fold_right o fold_right' and `fold_left o fold_left'
15:40:25 <MarcelineVQ> foldr :: b -> (a -> b -> b) -> [a] -> b   :>
15:40:48 <monochrom> heh
15:55:09 <Mrbuck> Hi do haskell programmers like JS ?
15:55:20 <jle`> some of them do :)
15:55:59 <Mrbuck> jle`:  ok
15:56:41 <hyiltiz> What is s in `s f g x = f x (g x)` commonly known as?
15:57:12 <jle`> hyiltiz: 'S' is a common name for it. but sometimes in haskell people call it 'ap' due to a really weird concidence
15:57:39 <jle`> ah according to this wikipedia it is called "substitution" https://en.wikipedia.org/wiki/SKI_combinator_calculus
15:59:58 <monochrom> That's like a pretty blanket name.
16:00:18 <hyiltiz> Mrbuck: I think most of us can appreciate a subset of JS (namy its ability to define functions and bind variables) :P
16:00:40 <Batzy> question about this A -> B -> C notation in Haskell.. Does everyone just know A,B are inputs and C is an output?
16:00:47 <Batzy> I guess haskell can only return a single value?
16:01:00 <Batzy> I know something like Go you can return 2 things or 3 or whatever
16:01:08 <hpc> C can be a tuple
16:01:12 <Batzy> true
16:01:12 <hyiltiz> A -> B -> (C1, C2)
16:01:22 <Mrbuck> hyiltiz: nice
16:01:25 <hpc> but generally, yes everyone just knows that
16:01:27 <Batzy> hyiltiz: yes but 'the last item in the chain is always the output and everything else is input'
16:01:36 <xsperry> B -> C can be an input
16:01:40 <hpc> where "just knows that" = "learns that when they learn currying" ;)
16:01:43 <xsperry> B -> C can be an output*
16:01:43 <monochrom> May I write a tutorial on "fundamental constructions", too? :)
16:01:47 <hyiltiz> A -> B -> C <=> A -> (B -> C) <=> (A -> B) -> C <=> (A, B) -> C etc.
16:01:48 <Batzy> it's sort of weird that the input isn't presented as a tuple or something
16:01:54 <hpc> the input can be a tuple
16:01:58 <Batzy> it can be but
16:02:02 <hpc> and it's equivalent, but you don't get currying as nicely
16:02:13 <Batzy> idk why you'd do A -> B -> C over (A,B) -> C
16:02:20 <hpc> there are functions in prelude to convert between tuple-y functions and normal functions
16:02:26 <hyiltiz> monochrom: no it is ok; I can just continue reading AKI
16:02:33 <hpc> Batzy: you can partially apply the former and not the latter
16:02:51 <Batzy> partially apply? is that like missing an input?
16:03:00 <hpc> for example, the expression (map (*2)) contains two partially applied functions
16:03:00 <hpc> yep
16:03:03 <Batzy> do you mean it's like taking f(x,y) and fixing y
16:03:10 <Batzy> yeah
16:03:11 <hpc> :t (*)
16:03:12 <lambdabot> Num a => a -> a -> a
16:03:18 <hpc> so, that's not really a -> a -> a
16:03:19 <xsperry> > map (map (*10)) [[1,2],[3,4]]
16:03:21 <lambdabot>  [[10,20],[30,40]]
16:03:22 <hpc> it's a -> (a -> a)
16:03:24 <Batzy> hpc: that sort of thing is not useful to me
16:03:26 <Batzy> im a noob
16:03:33 <Batzy> i have 0 comprehension of what it means
16:03:40 <hpc> when you pass 2 to it, you get (a -> a) back
16:03:44 <xsperry> if map took a tuple instead you couldn't do above
16:03:47 <monochrom> Batzy: I know because I learned "Y -> Z" and applied it to "X -> (Y -> Z)".
16:04:04 <hpc> when you do the same thing with a tuple, you have to give it the whole tuple, instead of passing parameters separately in order
16:04:05 <Batzy> whatever
16:04:12 <Batzy> how di i learn haskell in a way that isn't reading a book
16:04:16 <Batzy> i hate coding books
16:04:26 <monochrom> OK, read a math book instead.
16:04:32 <Batzy> monochrom: i've read many
16:04:52 <monochrom> Bird's "thinking functionally with haskell"
16:05:06 <hyiltiz> monochrom: I was reading doi:10.1017/S0140525X10000919 The Origin of Concepts and tried to encode the theory of conepts for human development (how human's form concepts etc.) in Haskell. I am quite perplexed by the complexity and vagueness of that paper/"groundbreaking work"
16:05:06 <Batzy> sounds like a book but let me see
16:05:17 <monochrom> If you are a video type, I'm sure you have found all videos by now.
16:05:42 <Batzy> monochrom: i hate videos too
16:05:54 <Batzy> monochrom: although if you say that book is good I will trust you and try it
16:06:14 <monochrom> hyiltiz: BTW "fundamental construction" is one of the old blanket names for monad. "In category theory, a branch of mathematics, a monad (also triple, triad, standard construction and fundamental construction)[1] is ..."  https://en.wikipedia.org/wiki/Monad_(category_theory)
16:06:43 <Batzy> I know monads freak people out
16:06:53 <Batzy> but i do know a little bit of category theory, so it's not all bad
16:06:56 <dolio> I think it was "standard construction".
16:07:31 <dolio> Oh, you mentioned that.
16:07:51 <dolio> I can't believe they came up with two names like that.
16:07:57 <hyiltiz> "fundamental construction" where did that come from / why did u mention it / did u meantion it w.r.t. SKI or TOOC?
16:08:01 <monochrom> Would you care to join my Triad Society? >:)
16:08:02 <MarcelineVQ> what a bunch of jerks
16:08:16 <monochrom> https://en.wikipedia.org/wiki/Triad_(organized_crime)
16:09:00 <monochrom> also seized the pun opportunity on "join" haha
16:09:21 <dolio> I guess naming everything after people who may or may not have invented it isn't so bad if that's the alternative.
16:09:21 <MarcelineVQ> triple triad is the name of a terrible card game
16:09:35 <monochrom> haha
16:09:41 <MarcelineVQ> wait no triple triad was the good one...
16:09:55 <MarcelineVQ> tetra master was the bad one
16:10:03 <monochrom> ah
16:11:56 <hyiltiz> To Mock a Mockingbird seems like a fun read
16:12:04 <monochrom> hyiltiz: I mentioned it as a tangent of royally annoying blanket names like "substitution" for S and "triple" for monad.
16:12:39 <hyiltiz> Well I like the name Monad and dislike the name S...
16:13:21 <hyiltiz> For all that matters, S could be Sir Severus Snape of Salazar Slitherin...
16:13:33 <monochrom> heehee
16:13:44 <hyiltiz> Monad has awful translations in other languages tho
16:14:11 <hyiltiz> I'd rather they just transliterated it rather than come up with awful names
16:15:10 <Batzy> monochrom: in this book he has an example of a function which takes a text and outputs the most common words
16:15:41 <Batzy> but he says the type is Int -> [Char] -> [Char]..wouldnt it be [Char] -> [Char] -> Int?
16:16:05 <Batzy> your inputing a character array and outputing a character array (each word) with some int attachwd
16:21:02 <sm[m]> hanging out in #haskell, reading existing code, or working with a mentor are some other ways
16:21:58 * sm[m] wonders if that old interactive tutorial is still up
16:23:05 <ski> Batzy : it gives back a list (not array) of words
16:23:47 <sm[m]> if we were rust, I guess we'd have a monster interactive tutorial that walks you through everything from install to dependent types
16:24:30 <Batzy> ski: why Int
16:25:25 <dolio> Doesn't the book say?
16:25:58 <Batzy> id have to read it to know
16:26:16 <hyiltiz> I am reading  Int -> [Char] -> [Char] as: I'll specify the length to consider "most"
16:26:48 <hyiltiz> "the most common word" can be [Char]->[Char] but "the most common words" has to be Int->[Char]->[Char]
16:26:49 <dolio> I'm pretty sure Rust doesn't have dependent types, also.
16:27:06 <hyiltiz> You'll have to specify how many wordS to consider as *most*
16:34:50 * hackage modular-arithmetic 2.0.0.0 - A type for integers modulo some constant.  https://hackage.haskell.org/package/modular-arithmetic-2.0.0.0 (TikhonJelvis)
16:35:31 <monochrom> Last year I had a student who asked a question in the course forum, the question had been already asked and answered soon before in the same course forum.
16:36:01 <monochrom> I pointed out "see the existing thread on this" and you know what the student replied back?
16:36:20 <monochrom> "yeah but I would have to scroll down"
16:36:36 <monochrom> Please don't encourage these entitled people.
16:36:55 <monochrom> You owe them nothing. Tell them again they have to read for themselves.
16:40:41 <dmj`> Which OpenGL Haskell library is most recommended
16:43:02 <c_wraith> if you're looking for something that works like OpenGL in C, use gl
16:46:20 <hyiltiz> http://ix.io/2unt How du prove the Card{flower garden}=3, and is the answer to the 2nd question the last sentence?
16:47:11 <hyiltiz> Oh wow somone implemented the book in Haskell for later chapters https://github.com/simon-frankau/mock-a-mockingbird
16:51:09 <monochrom> I think I would brute-force it.
16:53:51 <monochrom> It is not too big a space to brute-force.  (1 or 2 red) and (1 or 2 yellow) and (1 or 2 blue).
16:54:57 <hyiltiz> If there were N colors and N-1 statisticians, and let N -> +Infty, what would you do then? (Co)Recurve till it is brute forceble?
16:55:10 <monochrom> I don't know.
16:55:44 <hyiltiz> Somehow we'd have to grab the Axiom of Choice for that case it seems
16:56:01 <monochrom> Perhaps some lessons learned from the small case can help with an induction proof for a general theorem.
16:57:00 <monochrom> Or yeah, brute-force the base cases, then the induction step could be elegant.
16:58:20 <hyiltiz> This book seems like a gem; I think I found a new bedtime favourite so I'll stop reading GHC manual in bed :D
16:58:49 <monochrom> From "every triple has a red" rule out (yellow 2, blue 2), (yellow 1, blue 2), (yellow 2, blue 1).  So 1 yellow, 1 blue.
16:59:09 <monochrom> similarly rule out 2 red.
17:00:04 <monochrom> I think that the story would be more convincing if s/statistician/combinatorian/ :)
17:00:52 <monochrom> Only combinatorians would look for and verify pigeon-hole-esque properties like those "every n-subset has at least foo"
17:01:01 <hyiltiz> now can we solve it using group theory/symmetry without brute-forcing base case/listing followed by elimination?
17:02:13 <monochrom> I don't know. I only know one connection between counting and symmetry: Polya counting.
17:02:25 <hyiltiz> If we changed the label R to Y, Y to B, B to R, nothing about that puzzle should change
17:02:29 <monochrom> Even then I have only learned Burnside lemma, not full Polya counting.
17:03:12 <hyiltiz> that group is order 3 therefore the cardinality is 3?
17:45:12 <hyiltiz> What is the simplest stack of Monad transformers that can implement http://wordpress.morningside.edu/cdl001/files/2010/08/SFF-2.gif 
17:45:45 <c_wraith> What does that have to do with monads at all?
17:47:54 <hyiltiz> Well for starters, we need a counter and also deal with beverates/dinner IO
17:58:38 <justsomeguy> I have that book, hyiltiz, it's pretty good but a bit beyond my comprehension in some places.
17:59:33 * justsomeguy found it from the wikipedias list of references for combinatory logic.
18:12:44 <jollygood2> first time I used a Text instead of String.. and got.. ZERO speed improvement
18:12:55 <jollygood2> littered all the code with T. etc for nothing
18:13:20 <hyiltiz> hmm what's the avg. length of your Strings?
18:13:36 <jollygood2> to be fair, it isn't Text fault, scalpel module just converts all the Texts to Strings internally
18:13:44 <jollygood2> s/module/package
18:14:05 <jollygood2> I wish I found that out before :)
18:14:09 <sm[m]> jollygood2: I experienced pretty much the same
18:14:32 <jollygood2> also used scalpel, or something else entirely?
18:18:30 <jollygood2> hyiltiz strings I store are small, but web pages I'm scraping are pretty big, it takes a couple of minutes to scrap them all
18:20:21 <jollygood2> I think it would be better if scalpel just didn't support Text at all, than to convert it to String internally
18:22:22 <L29Ah> probably they want YOU to complete the transition to Text (;
18:24:44 <dsal> I'm trying out haskell.nix.  I do kind of wish it took me fewer hours to build anything.
18:28:54 <hololeap> can i just use a TMVar just like i would an MVar, using `atomically` before every operation, without thinking about it or understanding the details of how STM works?
18:29:32 <dolio> You could, but why not just use an MVar in that case?
18:30:13 <hololeap> i have had people in this channel strongly encourage me to use STM whereever possible
18:30:59 <monochrom> That also includes the STM spirit of not bothering to "lock, critical section, unlock".
18:31:06 <L29Ah> use STM if you feel like you're going to want to do atomical updates of the variable w/ others someday
18:31:13 <L29Ah> otherwise there's no point
18:31:16 <monochrom> Instead, simply "atomically (critial section)"
18:31:56 <L29Ah> s/others/other variables or STM abstractions/
18:32:26 <monochrom> If you are using MVar as honest-to-God message box, not lock, then you can stay with MVar.
18:33:05 <L29Ah> i never understood why people use MVars and not Chans at such cases
18:33:09 <hololeap> i am using it as a lock
18:33:18 <L29Ah> what do you lock?
18:33:39 <monochrom> Then eliminate the lock and convert all the protected mutable vars to STM vars.
18:34:06 <L29Ah> monochrom: you can also want to lock sockets
18:34:11 <hololeap> right now, it's just blocking while a logger thread finishes. eventually i want to work up to something more complex.
18:34:37 <monochrom> convert "acquire lock; readIORef x; readIORef y; writeIORef z; release lock" to "atomically (readTVar x; readTVar y; writeTVar z)"
18:34:50 <L29Ah> say, for RPC
18:35:20 <monochrom> OK then it's a message box "are you done?" "yes I'm done" so it stays as MVar.
18:36:26 <monochrom> Not literally that exchange, of course.  Rather just "yes I'm done, you wake up".
18:36:58 <hololeap> when would TMVar be a good idea?
18:37:41 <L29Ah> hololeap: atomically $ putTMVar sockVar sock >> modifyTVar handledRequests (+1)
18:37:46 <monochrom> Perhaps when atomically (readTVar x; readTVar y; writeTVar z; putTMVar m)
18:37:52 <hololeap> "if you feel like you're going to want to do atomical updates of the variable w/ other variables or STM abstractions someday"
18:38:01 <hololeap> i don't really understand this
18:38:38 <monochrom> in general when the TMVar is involved in a much bigger transaction than itself.
18:38:40 <L29Ah> hololeap: the whole point of STM is being able to do an atomic update ("transaction") on arbitrary amount of primitives at the same time
18:39:02 <L29Ah> if you won't need to extend the atomicity to any other entity, you don't need STM
18:40:28 <sm[m]> dsal: I thought nix was supposed to have cached binaries & stuff
18:40:47 <dsal> *shrug*  Seems to want to build all of ghc a few times.
18:40:50 <dsal> It's getting a bit faster.
18:40:53 <jle`> idea: a variation of STM where instead of using 'atomically' you use 'anatomically'
18:41:04 <dsal> I guess I should line up all my projects before bringing up the new things.
18:41:20 <dsal> jle`: this sounds like it would require a new kind of correctness
18:41:28 <hololeap> L29Ah: can't "normal" haskell concurrency primitives accomplish the same thing? this is the problem that i'm running into: it isn't clear to me when to choose STM or MVar/Chan or what the pros/cons of each are.
18:41:30 <jle`> or maybe anatomically would be the STM a -> IO a, that does not do things atomically (an-atomically)
18:41:58 <hololeap> when i've asked before it sounded like using STM was just a win/win
18:41:59 <L29Ah> hololeap: yes they can, but STM can be much easier to use
18:42:38 <hololeap> i guess the appropriate question is when do i _not_ want to use STM but reach for MVar/Chan instead?
18:42:40 <L29Ah> not sure about the extra costs associated with it
18:43:05 <jle`> usually i hop onto STM whenever i do things non-trivial with mvar and stuff
18:43:12 <jle`> and it begins to hurt my brain when i try to imagine race conditions
18:43:23 <dsal> hololeap: I almost always start with STM, but I've had super trivial cases where just a simple chan made sense to me.
18:43:27 <jle`> but also when i do nontrivial things i can usually get away with using the async library if it fits one of my patterns
18:43:27 <dsal> Maybe just don't think about it too hard.  :)
18:43:55 <hololeap> has anyone ever been bitten by STM and realized it wasn't what they needed?
18:44:25 <dsal> I don't think I've done that in the sense you mean.  I've written dumb code before, though.
18:44:30 <L29Ah> i've been, but i tried to extend STM to where it doesn't apply correctly
18:44:58 <hololeap> e.g. started with STM and then had to move over to MVar/Chan because STM didn't fit the problem
18:45:00 <L29Ah> worst case proper STM use results in worse performance, i think
18:45:47 <L29Ah> but i haven't benchmarked anything
18:49:25 <hololeap> dolio asked why i wouldn't just use an MVar in my original question. everyone's responses makes sound like there's much of a reason to consider anything other than STM, since nobody can think of a good example of when _not_ to use it.
18:50:04 <dolio> My question was because using STM to just implement MVar is no better than MVar.
18:50:07 <hololeap> s/makes sound like there's much/makes it sound like there isn't much/
18:50:55 <hololeap> well, i really wanted to know if TMVar could be used as a drop-in replacement, or if there was some kind of caveat to using it
18:52:01 <dolio> And is probably strictly worse than MVar, because there would be more overhead than the direct implementation.
18:52:29 <hololeap> ok, that's a fair response
18:54:04 <hololeap> but other than that, could you theoretically replace every MVar with TMVar (and swap their corresponding functions), and not see any difference other than performance?
18:54:19 <dolio> I'm not sure, but they're probably close.
18:55:22 <dolio> My concern was that you are following "use STM" advice without any understanding of why the advice was given, and in a way that provides no benefit.
18:55:46 <dolio> Possibly because no explanation was offered. :)
18:55:49 <hololeap> that's essentially true
18:56:09 <dsal> I offer the advice because it's got a few different things that work well together and they're individually easy.  :)
18:56:23 <dsal> Also because the idea of STM is pretty unique haskell magic that reminds me of why I enjoy it.  :)
18:57:17 <L29Ah> stm package has a benchmark for various chans, and TChan is slower than Chan in some tests
18:59:25 <L29Ah> oh, Chan's have unlimited length, so that's why people use MVar's
19:04:55 <L29Ah> huh, TQueue is faster than Chan and TChan
19:06:06 <MarcelineVQ> is TMVar single wakeup these days?
19:06:34 <monochrom> TQueue = TVar ([a], [a]).  The front-list, back-list trick for queues.
19:08:44 <monochrom> Chan = MVar (a, MVar Chan)  you can see how traversal has more synchronization overhead.  TChan is coded in the Chan way with just s/MVar/TVar/
19:10:24 <MarcelineVQ> These are the konds of covo's merijn shouldn't be sleeping through :>
19:15:06 <L29Ah> so where's newtype Queue a = Queue (IORef ([a], [a]))?
19:15:18 <L29Ah> ah nvm, IORef doesn't wait
19:16:44 <nshepperd> stm is nice because it Just Works
19:18:37 <nshepperd> i've not personally had to worry about the performance of it since all my expensive code was other parts
19:25:02 <MarcelineVQ> "<hololeap> i guess the appropriate question is when do i _not_ want to use STM but reach for MVar/Chan instead?" short story vs TVars, MVars are better (in performance) for the purposes of access contention, are single-wakeup (promise to alert up to one thread when ready), and are fair in which threads get attention meaning some thread already subscribed to an MVar won't wait forever for a result as long as the MVar keeps getting values put into it. 
19:25:02 <MarcelineVQ> stm doens't promise single wakup or fairness for threads, at least in anything I've read, but modern ghc stm might have these.   iow when you want timely handling of blocked threads in a fifo manner, when you have a lot of threads waiting on one specific thing (TVar/MVar/etc), or when you have lots of threads putting in and out of some container, MVar is a good choice.
19:27:00 <MarcelineVQ> STM's composability and utlity really makes it an easy goto though
19:30:19 <MarcelineVQ> "When specifically do​ I not want to ..."  though is the usual answer for programming questions: when the benchmark shows one works better for you than the other :>
19:44:35 <hololeap> MarcelineVQ: thanks for the input. i'm not really worried about performance as much as deadlocks or things not behaving as expected
19:45:25 <MarcelineVQ> A gun is a gun but MVar is probaly easier to aim at your foot, can't reccomend simon's book enough
19:45:27 <MarcelineVQ> @where parconc
19:45:27 <lambdabot> https://www.safaribooksonline.com/library/view/parallel-and-concurrent/9781449335939/
19:45:38 <hololeap> but that gives some good cons (as in pro/con) for using STM
19:47:15 <hololeap> yes, i am reading that now, and i'm on an early chapter in the concurrency parts. but, since i've heard that STM is a better drop in replacement, i've been experimenting with using TMVars instead of MVars (for instance) 
19:54:25 <slack1256> Can I newtype a monad with two WriterT layers with different monoids? I don't remember if that was allowed on MTL.
19:55:35 <glguy> No, but when you're making your own newtyped Monad you generally don't make new instances of the MonadWriter class anyway
19:55:37 <hololeap> not sure how it would determine which MonadWriter to write to
19:55:58 <hololeap> but (Monoid a, Monoid b) => (a,b) is also a Monoid
19:57:27 <hololeap> % :t tell
19:57:27 <yahb> hololeap: MonadWriter w m => w -> m ()
19:59:33 <hololeap> % :t \a -> tell (a, mempty)
19:59:33 <yahb> hololeap: (MonadWriter (a, b) m, Monoid b) => a -> m ()
19:59:43 <hololeap> % :t \b -> tell (mempty, b)
19:59:43 <yahb> hololeap: (MonadWriter (a, b) m, Monoid a) => b -> m ()
20:00:01 <hololeap> so you could just name those functions and use them
20:05:10 <hololeap> i don't understand why it doesn't infer that a and b are both Monoids :/
20:09:43 <glguy> :t tell
20:09:44 <lambdabot> MonadWriter w m => w -> m ()
20:09:51 <glguy> tell doesn't require its argument to be a Monoid
20:10:35 <glguy> well..
20:10:39 <glguy> it's implied by class (Monoid w, Monad m) => MonadWriter w m
20:10:54 <glguy> but often the Monoid constraint isn't actually used in tell, it's used in bind
20:12:07 <hololeap> ok, so it only forces it in the position where mempty is used (in that example)
20:12:21 <hololeap> % :t tell (mempty, mempty)
20:12:21 <yahb> hololeap: (MonadWriter (a, b) m, Monoid a, Monoid b) => m ()
20:12:36 <hololeap> got it
20:13:51 <hololeap> i guess the curious thing is that since `MonadWriter (a,b)` implies `(Monoid a, Monoid b)`, why does it need to specify it again when using `mempty`?
20:14:05 <L29Ah> % fix error
20:14:11 <yahb> L29Ah: "*** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Excep
20:17:08 <hololeap> ghc is smart enough to know how to fix your errors for you
20:17:35 <hololeap> but the result is at the end of an infinitely long chain of exceptions
20:19:25 <slack1256> I've never seen this done, but has anyone implemented a monad transformer where the base monad of the stack is ST? That existentialy `s` on the definition of the Monad trips the compiler.
20:20:03 <slack1256> Well, it trips the instance deriving via GND.
20:20:36 <glguy> A monad transformer is one parameterized over a base monad
20:21:41 <slack1256> https://pastebin.com/bjwAKXd2
20:21:45 <hololeap> i think we all know what they mean
20:22:14 <glguy> hololeap: I certainly don't
20:22:22 <dolio> Me neither.
20:22:24 <koz_> slack1256: Why not have DidacticM s a?
20:22:34 <koz_> There's no need to existentialize 's' away like that.
20:22:46 <slack1256> You're probably right. Let me see
20:23:25 <slack1256> koz_: You're right, now it compiles.
20:23:57 <dolio> That wasn't an existential, by the way.
20:24:10 <koz_> dolio: Rank-2, my bad.
20:24:18 <hololeap> it's runST that has the existential bit
20:25:08 <dolio> That also isn't existential. :)
20:25:54 <hololeap> right...
20:26:08 <hololeap> universal
20:26:19 <slack1256> rank 2 type
20:26:35 <slack1256> Thank you all
20:29:50 * hackage runhs 1.0.0.8 - Stack wrapper for single-file Haskell programs.  https://hackage.haskell.org/package/runhs-1.0.0.8 (danielbrice)
20:51:20 * hackage ipfs 1.1.3 - Access IPFS locally and remotely  https://hackage.haskell.org/package/ipfs-1.1.3 (expede)
23:04:38 <cyberfined> Hi, everyone. Do anyone know educational compiler written in haskell? It would be nice if it was written without llvm, because i want to implement my own compiler completely by myself.
23:05:15 <xerox_> https://www.ioccc.org/2019/lynn/hint.html
23:07:23 <cyberfined> I think it would be hard enough to read the code from ioccc
23:11:05 <xerox_> it is educational in its own way!
23:12:01 <Axman6> cyberfined: how about https://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours?
23:12:18 <cyberfined> It's interpretter not a compiler
23:13:29 <cyberfined> I has problems with optimization compiler phase, i implemented all before it
23:13:54 <Axman6> avoiding all the hard work put into LLVM so you can got hrough all the hard work of working directly with assembly/machine code seems like a big yak to shave to me
23:16:21 <cyberfined> I don't want to use llvm, because i want to understand how do compilers work at each phase
23:16:47 <cyberfined> In the future projects i will use llvm, but not now
23:18:55 <Axman6> I honestly don't tghink you learn a lot going between outpoutting LLVM IR and outputting assembly files, except annoying details about the ahrdware you're targetting
23:19:12 <Axman6> Is this you? https://www.reddit.com/r/haskell/comments/iadmod/tutorials_on_writing_compilers_for_functional/
23:19:28 <cyberfined> No, it's not me
23:19:37 <Axman6> well take a look there then :)
23:22:25 <cyberfined> Thanks, "Implementing Functional Languages" seems interesting
23:25:33 <Arahael> cyberfined: For something "haskell-like", and if they already know Javascript, then perhaps purescript could fit the bill.
23:25:54 <Arahael> cyberfined: And by that, I mean because it's relatively easy to see how the code corresponds to the javascript output.
23:26:09 <Axman6> http://wiki.haskell.org/Applications_and_libraries/Compilers_and_interpreters also exists. looks like lots of old projects, maybe you'll find one you like
23:32:19 <cyberfined> Unfortunately purescript isn't compiled to the machine-language, hence IR isn't used inside its compiler. I have a problem with SSA optimizations, I should ask more concrete question, something like that: "Do anyone know compiler written in haskell which uses SSA as intermidiate representation?".
23:33:10 <cyberfined> Probably i shouldn't use SSA in my first compiler
23:35:50 <cyberfined> In the dragon book it was written that optimize SSA more simple than other intermidiate representations, but in practice it isn't. It's hard to find information about SSA optimizations
23:36:24 <nate48423> denaro and the american government is getting my human brain and i go through things like no sleep, not comprehending, changing taste of food. please tell your world leaders i dont want amaerica to get my human brain and its serious terrorism going on in the country with denaro chips inside of people
23:37:26 <hyiltiz> cyberfined: Did you check out? https://github.com/sdiehl/write-you-a-haskell
23:37:39 <MarcelineVQ> i hear you, they puttin denaro chips in my potato chips, can't even snack anymore
23:43:39 <turion> monochrom, tomsmeding: (Sorry for the long wait.) Three methods. cons :: a -> b -> t a b, fst :: t a b -> a, snd :: t a b -> b
23:43:49 <cyberfined> Yes, i checked it out. I thought write you a haskell was abandoned
23:44:28 <turion> I don't know how useful this is, but it turned out to be useful in my case
23:45:10 <turion> tomsmeding: well of course the tuple would be an instance, but one could define their own instance for a type data Foo a b = Foo a b
23:52:52 <Axman6> how do I make a LazyList fomr a List? and if someone could show me how I could have figured that out from the docs I would appreciate that, because I've spent half an hour bashing my head against
23:52:56 <Axman6> them
23:53:22 <Axman6> uh, wrong channel, I know how to do that in Haskell <3
