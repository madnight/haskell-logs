00:09:20 * hackage ip2proxy 3.0.0 - IP2Proxy Haskell package for proxy detection.  https://hackage.haskell.org/package/ip2proxy-3.0.0 (ip2location)
00:21:29 <Marked> Hello! When I load file from ghci with :load command will previously loaded files unload?
00:29:51 <ADG1089> llvm-7 not being detected by ghc, any suggestions?
00:30:43 <Arahael> Install it?
00:32:08 <ADG1089> choco install llvm --version=7.0.0
00:32:16 <ADG1089> already did that
00:34:32 <dminuoso> Oh. Windows.
00:36:04 <ADG1089> https://gitlab.haskell.org/ghc/ghc/-/issues/7143
00:36:19 <ADG1089> clang is installed too
00:39:11 <Arahael> Windows has no real conventions - you generally have to somehow install everything explicitly and explicitly configure all the dependencies.  It's annoying.  Never done it with Haskell, but it's one reason why I prefer the other systems. :)
00:40:07 <dminuoso> Arahael: And that's different how from Linux? :)
00:41:00 <Arahael> dminuoso: Linux has the giant fixpoint, chuck everything into /usr/local, and whatever sticks, sticks. ;)  Unless you actually know what you're doing.
00:41:26 <ADG1089> I have all llvm binaries in C:\Program Files\LLVM\bin and added to path
00:41:42 * dminuoso runs a Linux without such a directory
00:41:58 <ADG1089> I think opt & llc are named something else - maybe lld, llvm-rc?
00:42:33 <dminuoso> Ah
00:42:35 <dminuoso> 09:31:47         ADG1089 | choco install llvm --version=7.0.0
00:42:37 <dminuoso> There is your fault
00:42:40 <dminuoso> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/codegens.html#llvm-code-generator-fllvm
00:42:46 <dminuoso> ```Note that this GHC release expects an LLVM version in the 9 release series.```
00:43:04 <dminuoso> Or rather, Im *guessing* it could be the probem
00:43:42 <ADG1089> <no location info>: error:
00:43:43 <ADG1089>     Warning: Couldn't figure out LLVM version!
00:43:43 <ADG1089>              Make sure you have installed LLVM 7
00:44:00 <ADG1089> anyways let me see that link
00:44:06 <dminuoso> Okay that's really confusing :)
00:44:20 <dminuoso> It's possible the diagnostic is not up to date.
00:45:57 <ADG1089> anyways let me install the binaries from https://releases.llvm.org/download.html and check if that works before trying version 9
00:51:31 <ADG1089> :( both failed
00:52:35 <ADG1089> apparently some binaries are installed in C:\Program Files\LLVM\bin but ghc wants opt & llc which are missing, maybe they are renamed or optional?
01:01:42 <ADG1089> let
01:01:50 <ADG1089> 's build from source then
01:22:57 <Marked> Is this data LockerState = Taken | Free deriving (Show, Eq) a good idea? Or should I rather just type isLocked = Bool ?
01:24:06 <dminuoso> Marked: LockerState is preferable
01:25:02 <dminuoso> This is essentially the boolean blindness problem
01:25:29 <Marked> dminuoso Is it because we can pattern match against Taken, Free instead of True False? So is it more readable?
01:25:33 <dminuoso> To use a bool, you have to know its provenance to know what it means.
01:25:45 <dminuoso> Without its provenance, its completely meaningless
01:26:00 <dminuoso> (especially since its so ubiquitous)
01:26:03 <opqdonut> hmm, I think Pierce was condemning types like LockerState too when he talked about Boolean Blindness
01:26:22 <opqdonut> types should carry witnesses
01:26:51 <dminuoso> Right, that's what boolean blindness is really about, but not using Bool is an additional witness that this is indeed some locker state
01:26:52 <opqdonut> so something like `data LockerState = TakenBy Process | Free` or perhaps `data LockerState = Taken | Free AccessCode`
01:26:56 <dminuoso> And didnt come out of an arbitrary predicate
01:27:08 <opqdonut> yeah, I agree that LockerState is preferable to Bool
01:27:13 <Marked> Hmm.. got it... I thought using type alias is better as I am not creating whole new type just using existing.
01:27:24 <dminuoso> Marked: You can use a newtype around Bool, if you prefer.
01:27:32 <dminuoso> Type aliases themselves should be used sparingly, if at all.
01:27:46 <dminuoso> I tend to use type aliases to make large complicated types a bit more readable in a type signature.
01:28:17 <Marked> Ah okey.. I think I got it.
01:28:40 <Marked> Thank you
01:28:55 <dminuoso> e.g. `type Comp1 = Comp Stg1Env` because `Comp Stg1Env` is just annoying to write all the time. :)
01:29:09 * ski glances through a lens
01:29:33 <dminuoso> ski: Heh, you have the wrong optics for that.
01:29:50 <dminuoso> Perhaps a different view would help?
01:30:00 <ski> @quote getting.a
01:30:00 <lambdabot> byorgey says: <edwardk> @type (^.) <lambdabot> s -> Getting a s t a b -> a <byorgey> I would not like to be getting a stab, thank you
02:27:14 <olle> hi guys
02:27:25 <olle> I'd like to talk about the similarities between yield and generators and the IO monad
02:29:41 <olle> both gives control of side-effects to the calling function
02:30:03 <olle> So I was thinking similar mocking strategies could be applied
02:40:04 <jchia> olle: You mean python yield and python generators? Haskell has lists.
02:40:33 <jchia> And there's ListT
02:43:01 <olle> jchia: php and ruby has this language feature too
02:43:06 <dminuoso> olle: One class to rule them all, one functor to fmap them, one applicative to ap them, and in darkness bind them.
02:43:19 <dminuoso> Point being, the similarities are the monadic interface.
02:43:39 <olle> yep
02:47:23 <tomsmeding> *in the darkness bind them
02:59:31 <dminuoso> olle: Also, another interesting part, is that ContT is the mother of all (haskell implementable) monads. Any monad you have could be expressed with Cont. :)
03:00:02 <dminuoso> (The note about haskell implementable is to exclude things like IO or STM )
03:00:22 <dminuoso> So perhaps this is what you noticed?
03:00:41 <dminuoso> (That in the monads you observed, there's this theme of continuatoins)
03:09:44 <olle> dminuoso: I don't know Haskell well. Is ContT a contiuation monad?
03:09:57 <dminuoso> Yes.
03:10:00 <olle> kk
03:10:08 <olle> Yes, then it's very similar indeed.
03:18:49 <olle> I thought this would lead to better mocking, but so far, no one likes the idea :d
03:19:05 <olle> one drawback is that it's "too internal"
03:19:06 <olle> bah
03:20:37 <olle> "Hey, you can do similar mocking as in Haskell!" PHP devs: D:
03:22:20 * hackage kontrakcja-templates 0.12 - Utilities for working with many HStringTemplate templates from files.  https://hackage.haskell.org/package/kontrakcja-templates-0.12 (arybczak)
03:26:59 <alehander92> wow i saw https://www.stephendiehl.com/posts/monads_machine_code.html
03:27:03 <alehander92> that's cool
03:30:19 * hackage haskell-gi 0.24.4 - Generate Haskell bindings for GObject Introspection capable libraries  https://hackage.haskell.org/package/haskell-gi-0.24.4 (inaki)
04:03:10 <Ariakenom> alehander92, yeah!
04:09:57 <Cheery> ls
04:12:51 <maerwald> how do you see dependency tree during resolution/for failed resolution?
04:12:56 <maerwald> in cabal
04:15:50 * hackage fakefs 0.3.0.0 - Extensible fake file system for testing.  https://hackage.haskell.org/package/fakefs-0.3.0.0 (igrep)
04:18:26 <opqdonut> can I find a roadmap for the various Monoid/Semigroup changes? It seems that every release of base has changed something in these classes
04:19:56 <dminuoso> maerwald: Well there is none, that's sort of the point. If you bump up the verbosity cabal will print it's resolution attempt
04:20:20 <dminuoso> With all the backtracking, it can be a bit tricky to figure out why, but it's usually all there
04:25:49 <dminuoso> opqdonut: Mmm, there's only https://gitlab.haskell.org/ghc/ghc/-/wikis/proposal/semigroup-monoid that I know of
04:26:03 <dminuoso> (See migration plan)
04:28:44 <opqdonut> dminuoso: thanks, that's more than what I found via google
04:29:50 * hackage fakefs 0.3.0.1 - Extensible fake file system for testing.  https://hackage.haskell.org/package/fakefs-0.3.0.1 (igrep)
05:24:50 * dminuoso wishes `return Foo{..}` was allowed in standard haskell :(
05:35:13 <hseg> i'm at wits' end. how do i write an indefinite backpack package using an external signature? http://ix.io/2tSw gives a toy example of the trouble I'm running into
05:35:35 <hseg> apparently Wunused-packages doesn't know backpack that well
05:45:12 <hseg> worse, the point where -Wunused-packages gives up seems arbitrary -- playing around with it yields weird results
05:55:13 <dminuoso> odin-service: thread blocked indefinitely in an MVar operation
05:55:30 <dminuoso> Gah.. I *want* it to be indefinitely blocked..
05:55:34 <dminuoso> :(
05:55:59 <dminuoso> GHC too smart for me.
06:02:54 <merijn> dminuoso: That seems...wrong
06:03:07 <merijn> Why would you want it indefinitely blocked?
06:03:27 <merijn> That's like "I want my program to infinite loop"
06:05:48 <dolio> Right. That error is about a thread blocking on an MVar that GHC knows will never be filled.
06:06:19 <olle> good tutorial for mocking IO monad?
06:06:25 <merijn> dminuoso: If you wanna be indefinitely blocked, you might as well just kill the thread and save some resources
06:06:31 <merijn> olle: "Don't"? >.>
06:06:41 <olle> merijn: yes, I've seen that article
06:06:52 <olle> but the alternative to mocking it is going bananas with abstractions
06:07:05 <dolio> 'Indefinite' may not be strong enough a word, really.
06:07:08 <merijn> what? why?
06:07:40 <dminuoso> merijn: I cant. websockets demands some `Connection -> IO a` - so I forkIO two threads off, and want the parent to just block.
06:07:44 <merijn> dminuoso: Anyway, I think you're either misinterpreting that error or wanting silly things (in which case I recommend patching your brain)
06:08:01 <olle> merijn: this guy: https://degoes.net/articles/modern-fp
06:08:03 <merijn> dminuoso: Presumably you want to be able to shut your program down at some poin
06:08:10 <dminuoso> Not really :p
06:08:21 <dminuoso> But I get your point
06:08:29 <dminuoso> prehaps I could just put into that MVar on a signal
06:08:36 <dminuoso> at least that would squelch ghc
06:11:29 <solonarv> well... 'forever (sleep 10000000)' blocks forever, I guess?
06:12:00 <dminuoso> uh...
06:12:52 <solonarv> oh wait, you are forking two threads off and want their parent to block
06:13:02 <olle> Or, why *not* mock IO?
06:13:04 <solonarv> perhaps the parent should block until both children are terminated, rather than forever?
06:13:57 <dminuoso> solonarv: Mmm, actually that's not such a bad ide.a
06:14:22 <merijn> threadDelay maxBound
06:14:53 <dminuoso> merijn: That's like a guaranteed second! 
06:14:57 <dminuoso> :)
06:15:01 <merijn> In fact, guess how I found out that threadDelay maxBound used to be broken nearly everywhere? :p
06:15:12 <solonarv> or a variant like "when one child thread is killed, kill the other one then terminate"
06:15:21 <solonarv> async has nice functions for this sort of thing
06:15:24 <dminuoso> solonarv: Yeah Im already poking at async :)
06:15:35 <dminuoso> (I've learned my lesson to just use async whenever I want threads)
06:15:59 <solonarv> :)
06:19:50 <fendor> merijn, why was it broken?
06:20:49 <dminuoso> I keep forgetting. What aeson function did I have to use, to decode a ByteString into a value without using a FromJSON instance?
06:22:25 <merijn> fendor: on linux it blocked indefinitely and macOS it instantly crashed your program :p
06:22:53 <merijn> fendor: As for "why" because finite size integers and conversions are hard!
06:23:58 <fendor> I guess makes sense
06:25:19 <fendor> isn't Int 64-bit usually? and `man 3 sleep` says it uses int which, iirc means it is at least two bytes
06:25:48 <fendor> oh really, is that the problem? int is usually between 2-4 bytes while Int is 64-bit for haskell?
06:25:52 <merijn> fendor: Right, so you need to convert the max of 64 bit int to whatever int is in C :p
06:26:05 <merijn> Which gets you a negative value
06:26:24 <merijn> Which linux silently accepts as infinity (this is wrong according to posix, only -1 should be infinity)
06:26:43 <merijn> on macOS all negative values other than -1 result in an error return, leading the RTS to crash
06:28:29 <fendor> I thought, overflow for signed integers is UB? Only for unsigned it is defined 
06:30:11 <merijn> fendor: In *c*, sur
06:30:17 <merijn> but the conversion is in Haskell
06:30:48 <hyperisco> what was the wisdom of letting integer bounds vary by platform?
06:31:55 <fendor> merijn, ah.. I see, numbers in haskell, especially overflows/underflows are very hard to get right
06:37:35 <dminuoso> Mmm, haskell-mode hilights `proc`, which extension uses that?
06:39:40 <merijn> arrow notation
06:39:44 <merijn> So nothing :p
06:39:48 <dminuoso> Oh
06:40:13 <dminuoso> I have yet to see that in action. Arrows are one of the few parts I havent understood
06:40:55 <pavel12345> one thing I can't figure out - in the do notation how come the code compiles when you pattern-match on a sum type, since the values of the type can be vastly different? like "(x,y) <- ..." when the sum type can be defined either as (Int, Int) or a String or anything else
06:41:32 <dminuoso> @undo do { (x,y) <- f; blah } -- pavel12345 
06:41:33 <lambdabot> f >>= \ (x, y) -> blah
06:41:43 <dminuoso> Ah, bad example
06:41:48 <dminuoso> @undo do { Just x <- f; blah } -- pavel12345 
06:41:48 <lambdabot> f >>= \ a -> case a of { Just x -> blah; _ -> fail ""}
06:42:27 <dminuoso> That's what it desugars into. The above case is perhaps just lambdabot applying some obvious dead code elimination.
06:42:53 <tomsmeding> for completeness: the same thing happens in a list comprehension
06:43:10 <tomsmeding> > [x | Left x <- [Left 1, Right 2, Left 3]]
06:43:12 <lambdabot>  [1,3]
06:43:36 <dminuoso> % do { Left x <- [Left 1, Right 2, Left 3]; pure x }
06:43:36 <yahb> dminuoso: [1,3]
06:43:40 <dminuoso> @undo do { Left x <- [Left 1, Right 2, Left 3]; pure x }
06:43:40 <lambdabot> [Left 1, Right 2, Left 3] >>= \ a -> case a of { Left x -> pure x; _ -> fail ""}
06:43:44 <pavel12345> I am digesting what you have written :D
06:43:51 <dminuoso> Alright :)
06:46:31 <hekkaidekapus> <dminuoso> I have yet to see [arrows] in action. ‚Üí Maybe you haven‚Äôt yet seen https://github.com/ghc-proposals/ghc-proposals/pull/303#issuecomment-631108435
06:47:00 <hekkaidekapus> Or the whole proposal and discussion for that matter.
06:47:31 <dminuoso> Is there an simple and streaming compatible way to get the stdout of say a shell/proc (process)?
06:47:46 <dminuoso> hekkaidekapus: That's a bit over my head, heh
06:48:31 <dminuoso> It seems there should be an obvious way, considering how you can have pipes in the shell.. surely there must be some conduit magic :(
06:48:49 <hekkaidekapus> dminuoso: Patterson papers are dry, but Alexis‚Äô tutorial is very approachable.
06:51:04 <raichoo> Ah nice, the darcs 2.16.1 release candidate ist out \o/
06:57:46 <carbolymer> is there any clever way to do: Either a (IO b) -> IO (Either a b) ?
06:58:56 <fendor> carbolymer, sequenceA?
06:59:11 <fendor> > sequenceA (Right (pure 4 :: IO Int))
06:59:13 <lambdabot>  error:
06:59:13 <lambdabot>      ‚Ä¢ No instance for (Typeable a0)
06:59:13 <lambdabot>          arising from a use of ‚Äòshow_M6494583945269981106336‚Äô
06:59:22 <fendor> that was insanely wrong
06:59:29 <fendor> :t sequenceA 
06:59:30 <jkaye[m]> Traversable?
06:59:30 <lambdabot> (Traversable t, Applicative f) => t (f a) -> f (t a)
06:59:42 <jkaye[m]> Yeah
06:59:49 <fendor> :t sequenceA :: Either a (IO b) -> IO (Either a b)
06:59:50 <lambdabot> Either a (IO b) -> IO (Either a b)
07:00:37 <carbolymer> well... ghc is happy with sequenceA
07:00:40 <carbolymer> fendor, thanks
07:01:04 <fendor> sequenceA is fine, but my code example was totally wrong
07:01:13 <fendor> syntactically
07:01:21 <alehander92> guys
07:01:30 <alehander92> what is best way to represent unique
07:01:37 <alehander92> um, different kind of text
07:01:49 <alehander92> similarly to distinct types or unit ypes
07:02:23 <alehander92> e.g. something like `data Name = unit T.Text` where Name doesn't typecheck T.Text but otherwise
07:02:27 <alehander92> behaves the same way
07:04:28 <alehander92> https://nim-by-example.github.io/types/distinct/
07:04:33 <alehander92> something like that
07:05:24 <jkaye[m]> You're looking for newtype probably
07:07:21 <alehander92> hm, thanks!
07:07:31 <pavel12345> dminuoso - thanks I have to play with it some more :)
07:07:54 <alehander92> but can i lift some functions
07:08:01 <alehander92> to work automatically with my newtyped type 
07:08:14 <alehander92> or does this not make sense (or they would be generic anyways)
07:08:40 <alehander92> maybe it's better to explicitly redefine them / convert back to text if needed
07:08:41 <alehander92> thanks
07:19:58 <pavel12345> still struggling, how come this "do {Just a <- Nothing; return a}" returns "Nothing" and does not either fail with an exception or throw a compilation error?
07:20:26 <dminuoso> pavel12345: First, do you understand that do-notation is desugared into uses of >>= and other primitives?
07:20:38 <dminuoso> Second, do you understand how typeclasses work?
07:20:57 <pavel12345> I think so, yes
07:21:08 <dminuoso> @undo do {Just a <- Nothing; return a}
07:21:09 <lambdabot> Nothing >>= \ b -> case b of { Just a -> return a; _ -> fail ""}
07:21:33 <dminuoso> pavel12345: ^- the trick is to understand, that `fail` is a method of MonadFail, which has different implementations
07:22:02 <dminuoso> https://hackage.haskell.org/package/base-4.14.0.0/docs/Prelude.html#t:MonadFail
07:22:12 <dminuoso> Click to the right on [Source] to see the actual implementation
07:22:18 <dolio> The fail doesn't even really matter in this example, though.
07:22:32 <dminuoso> dolio: But it does.
07:22:52 <dminuoso> Oh
07:22:55 <dminuoso> Heh, you are right.
07:23:35 <dolio> It matters that Maybe is a MonadFail.
07:23:48 <dolio> But that's about it.
07:24:23 <pavel12345> ah I think this is becoming the missing piece, because in general I am wondering what happens when the pattern in the do notation does not match
07:24:57 <dminuoso> pavel12345: Like dolio points out, that's not even relevant! The >>= short circuits.
07:25:02 <pavel12345> (there is suprisingly little information about that)
07:25:26 <dminuoso> Do you however understand how pattern matching to the left of a <- results in case-of with `fail` ?
07:25:47 <dminuoso> But that happens *inside* the second argument of >>=
07:26:00 <dminuoso> The Maybe implementation of >>= short circuits before that, not even going inside that function
07:28:26 <pavel12345> dminuoso: I see, now I get it, I tried to create a pattern mistmach but on types that short circuit the computation (maybe, either)
07:29:29 <pavel12345> that's why I wasn't getting errors I wanted to trigger
07:29:52 <tomsmeding> @undo do {Just a <- Just Nothing; return a}
07:29:52 <lambdabot> Just Nothing >>= \ b -> case b of { Just a -> return a; _ -> fail ""}
07:30:00 <tomsmeding> here the fail _does_ trigger
07:30:19 * hackage turtle 1.5.20 - Shell programming, Haskell-style  https://hackage.haskell.org/package/turtle-1.5.20 (GabrielGonzalez)
07:30:21 <dolio> It still won't be an error, though.
07:30:26 <tomsmeding> where the 'Just Nothing' can also, perhaps more intuitively, be written as 'return Nothing'
07:31:11 <pavel12345> I loaded it ghci and get Nothing (literally)
07:31:34 <tomsmeding> > fail "" :: Maybe Int
07:31:36 <lambdabot>  Nothing
07:31:42 <tomsmeding> that's the Nothing you see with my example
07:31:59 <pavel12345> aha
07:32:14 <tomsmeding> the Nothing in dminuoso's example comes from >>=
07:32:23 <pavel12345> yeah I get it
07:32:40 <pavel12345> yours comes from maybes definition of fail I think
07:32:56 <tomsmeding> indeed, which is defined in its instance of MonadFail
07:33:57 <pavel12345> I've seen monadfail before, but I didn't know what it was good for - I learned smth new, thx!
07:36:29 <tomsmeding> semi-related: one of the types one (at least, I) would expect to have a MonadFail instance is the monad Either String
07:36:32 <tomsmeding> but it has none!
07:37:33 <tomsmeding> I believe that is because writing that instance requires the FlexibleInstance language extension, which apparently the writers of 'base' where not happy with
07:39:18 <c_wraith> That's not really accurate.
07:39:56 <dolio> I think base uses many more dubious extensions than that. :)
07:39:59 <tomsmeding> aside from it being FlexibleInstances, please enlighten me :)
07:40:04 <c_wraith> At one point long ago, before MonadFail was split out of Monad, base contained  instance Monad (Either String)
07:40:52 <c_wraith> That annoyed a lot of people, including me, who argued that String wasn't special and the Monad instance should be for Either a
07:41:33 <c_wraith> So sometime around GHC 6.12 (roughly), that instance was changed.  When it was, the implementation of fail changed from Right to error
07:41:49 <tomsmeding> s/Right/Left/
07:41:53 <pavel12345> I managed to get a "Couldn't match type ..." error when doing a mismatch on reader monad, the short-circuiting tripped me off, I am happy :)
07:41:54 <c_wraith> sorry, yes
07:43:06 <c_wraith> I didn't follow the MonadFail discussion all that closely.  Not sure why they made the choice they did with it.  But it's certainly not about caring about FlexibleInstances
07:43:32 <tomsmeding> perhaps then to not get into the same situation where String is different from the other types?
07:43:43 <c_wraith> that's probably it
07:43:48 <tomsmeding> like, if we can't get a consensus, let's not do it at all?
07:43:51 <tomsmeding> that makes sense
07:44:01 <dolio> Well, error isn't really a good fail implementation. It's decidedly not the point of fail.
07:44:21 <dolio> So at that point you just omit the MonadFail instance.
07:44:47 <tomsmeding> (or replace it with a MonadFail (Either String) instance, but that's subject to the point above :p)
07:44:56 <tomsmeding> but TIL, thanks
07:45:20 <dolio> Right. The only point of the error implementation was that previously Monad forced you to have one.
07:46:00 <ddellacosta> it's crazy how much I learn just lurking in here
07:46:21 <tomsmeding> this all begs the question for me though, why does 'fail' take a String
07:46:40 <c_wraith> ddellacosta: lurking in here was a huge part of my learning for the first couple years I used Haskell! :)
07:46:44 <tomsmeding> probably that wasn't changed in the MonadFail operation to not make the migration unnecessarily complicated
07:46:53 <ddellacosta> c_wraith: I can absolutely understand why
07:47:22 <dolio> tomsmeding: Because @undo is not really giving the full story. The real desugaring puts information in the string.
07:47:28 <c_wraith> tomsmeding: because fail is intended as a mechanism for reporting pattern match failures in <- pattern bindings.
07:47:41 <tomsmeding> aha
07:48:16 <c_wraith> (in do blocks specifically, not pattern guards)
07:48:47 <ski> (also not for list comprehensions)
07:49:33 <tomsmeding> the desugaring even inserts location info into the string apparently
07:49:39 <jle`> @undo do [x] <- xs; x
07:49:40 <lambdabot> xs >>= \ a -> case a of { [x] -> x; _ -> fail ""}
07:49:49 <jle`> oh someone already did it earlier
07:49:58 <frdg> should I be using the foldr/build rule wherever possible? Does it make a large difference in code quality?
07:50:53 <c_wraith> frdg: the compiler and the implementations in base take care of it for you most of the time.
07:51:22 <c_wraith> it's rare to both be able to coax it into working manually *and* have a good reason to at the same time.
07:52:01 <frdg> c_wraith: oh ok I am not far enough along in this reading to have realized it happens behind the scenes. 
07:52:02 <frdg>  
07:53:07 <c_wraith> yeah, it actually is a rather complex application of staged RULES pragmas and their interaction with GHC's optimization model
08:02:44 <aldessa> Hi, how do I search Hackage? I'm trying to read the Reflex documentation but it doesn't seem to be on Hoogle.
08:05:16 <hekkaidekapus> tomsmeding: My calling today seems to throw (pun ‚Ä¶) around GHC proposals, so Cale and co. are trying to overhaul the do-desugaring.
08:05:28 <hekkaidekapus> See https://github.com/ghc-proposals/ghc-proposals/pull/319 and https://github.com/ghc-proposals/ghc-proposals/pull/351
08:06:16 <tomsmeding> aldessa: is it this reflex? https://hackage.haskell.org/package/reflex-0.7.1.0/docs/Reflex-Class.html
08:06:29 <tomsmeding> @hoogle Reflex
08:06:30 <lambdabot> package reflex
08:06:30 <lambdabot> module Test.Validity.Relations.Reflexivity
08:06:30 <lambdabot> Algebra.Graph.Class class Graph g => Reflexive g
08:14:00 <aldessa> yes tomsmeding
08:14:14 <tomsmeding> well then, hoogle found it for me :)
08:14:30 <aldessa> but when I do this https://hoogle.haskell.org/?hoogle=reflex&scope=set%3Astackage
08:14:34 <aldessa> it says not on stackage so not searched
08:14:45 <tomsmeding> though it is kind of unfortunate that hoogle apparently searches Stackage, while this reflex library is not in there
08:15:12 <tomsmeding> it did find the package due to the name now, but indeed it would not have searched through it
08:16:03 <aldessa> are there any alternatives?
08:16:09 <aldessa> hoogle is generally super useful
08:18:53 <tomsmeding> apparently the reason hoogle only searches Stackage is as a kind of ad-hoc filter on package quality: https://github.com/ndmitchell/hoogle/issues/243#issuecomment-366818053
08:19:49 <tomsmeding> I guess it might be possible to build a local hoogle database yourself with all of hackage?
08:19:57 <int-e> > maximumBy (comparing fst) [(0,0),(0,1)]
08:19:59 <lambdabot>  (0,1)
08:20:06 <tomsmeding> hekkaidekapus: those are quite nice proposals!
08:20:13 <int-e> (not what I expected)
08:21:09 <tomsmeding> interesting, maximumBy takes the last maximal element
08:21:47 <tomsmeding> the alternative definition is a trivial change though
08:30:47 <maerwald> is there some syntax in cabal to test all "*:unit" targets?
08:36:05 <hekkaidekapus> maerwald: cabal test all:tests maybe?
08:42:26 <maerwald> hekkaidekapus: but that runs all tests, not just unit
08:45:11 <hekkaidekapus> Yep, I don‚Äôt know how to filter in units only.
08:45:24 <merijn> int-e: How is that not what you expected?
08:45:34 <merijn> int-e: Or did you mean you expected a left-biased tie breaker?
08:45:49 * hackage interval-algebra 0.1.2 - An implementation of Allen's interval algebra for temporal logic  https://hackage.haskell.org/package/interval-algebra-0.1.2 (bradleysaul)
08:46:07 <int-e> merijn: Yes, I expected a left bias.
08:46:32 <int-e> But it's been that way forever, I just forgot.
08:50:19 <fendor> maerwald, how about `stack ide targets | rg :unit -exec "cabal test {}"` modulo bash errors 
08:50:48 <maerwald> stack: command not found
08:50:53 <maerwald> :)
08:51:24 <fendor> we would need one more roundtrip to nix or something to really make it worthy
08:51:40 <fendor> nix-shell -p stack --run "stack ide targets | rg :unit -exec \"cabal test {}\""
08:52:08 <fog> im still stuck with this idea of cofree style hetrogenous trees
08:53:14 <alehander92> i read coffee style and i felt it's some kind of theory construct
08:54:47 <fog> how do you mean?
08:54:59 <alehander92> cofree coffee
08:55:17 <alehander92> i thought it's like coffee style is some kind of special tree maybe having a paper about it
08:55:31 <alehander92> based on having*
08:56:12 <fog> oh, cofree tree is just having the data at the branch nodes instead of at the leafs 
08:56:30 <fog> Tree = Free [], Nodes = CoFree []
08:57:17 <fog> then for HTree, you have a Tree of type params, so i guess for HNodes you have a Nodes of type params
08:57:23 <fog> but i cant write it
08:58:10 <fog> i think my brain is rejecting the types out of protest
09:00:05 <alehander92> i am just trying to understand cofree
09:00:51 <fog> oh ok
09:01:43 <fog> its like, everywhere there are branches you have the value aswell
09:01:56 <fog> its like, commuting the position of the `a' in Free
09:02:10 <fog> instead of it being inside the `f' its in a pair with it
09:02:22 <fog> so Free is like, nested containers
09:02:35 <fog> with the `a' at the leafs
09:02:51 <fog> and Cofree is like, nested containers, but with the `a' in a pair alongside the nesting
09:04:04 <fog> whats weird is that it does not have a terminating case like Free has Leafs
09:04:24 <fog> Free is either the nesting with the container, or the leaf with the value
09:04:32 <fog> whereas cofree is both the value and the nesting
09:04:57 <fog> then because its like a pair instead of either, you dont get to choose either value or container
09:05:09 <fog> you have to have both, so it can only terminate if the container can be empty
09:08:36 <alehander92> dude i realized i don't know what Free is
09:08:40 <alehander92> this is a good starting point
09:08:57 <alehander92> i am really a beginner in haskell sorry
09:13:11 <fog> oh right, yeah, describing Cofree using comparison to Free isnt going to be so helpful then!
09:13:36 <fog> i guess normally we start with free because its more commonly used 
09:14:06 <fog> data Free f a = Leaf a | Nesting (f (Free f a))
09:14:12 <dolio> That is not an accurate description of what free/cofree means.
09:14:29 <fog> oh..
09:15:07 <fog> because its too much revolving around the use case of Tree = Free [] ?
09:15:42 <fog> i guess the best example of Cofree is [] = Cofree Maybe
09:16:05 <fog> data Cofree f a = a :< (f (Cofree f a)) 
09:16:35 <fog> doio: why not?
09:16:48 <dolio> Because you are specifically describing the free monad on a functor, and the cofree comonad on a functor, and 'free' and 'cofree' are only part of that, and more general terms.
09:21:21 <jle`> alehander92: there's two aspects you might be conflating there too, Cofree the data type (which is just a normal ADT like any other), and this 'cofree style' you are talking about, which i'm not sure what it means
09:21:41 <dolio> 'Free' in general means something analogous to 'inductively generated,' or 'initial', while 'cofree' is coinductive or final.
09:21:48 <alehander92> i was making a pun mostly
09:22:04 <alehander92> but then i got into reading a bit about free 
09:28:26 <hololeap> coffee is just the dual of ffee
09:29:20 <dminuoso> And cocoa is just a.
09:30:00 <systemfault> I guess you can also make that joke with coconut...
09:30:13 <MarcelineVQ> dminuoso: Assuming a sufficiently smart compiler
09:31:50 <Lycurgus> an it's like kryptonite for the alzheimers
09:34:23 <Lycurgus> caffeine, cinnamon (verrum), and omega 3 PUSA, are that is the latter two specify address tau and AB
09:34:35 <Lycurgus> *specifically
09:34:54 <Lycurgus> is it me or has hs peaked?
09:35:39 <Lycurgus> of course there can me multi peaks, and I don't see hs goin the ruby way
09:37:33 <Lycurgus> nobody are chattink, even when I give topic bait
09:37:45 <Lycurgus> *topical
09:37:58 <MarcelineVQ> It's a workday
09:56:41 <hololeap> i like cinnamon and cayenne in my coffee :p
09:58:04 <hololeap> and coriander and cardamom. c^5
09:59:22 <hololeap> don't know if i have cassia or verum. it doesn't say, so it's probably cassia
10:08:59 <Polesch> How do I get something like this to work in Haskell? https://pastebin.com/RKUmASa4
10:09:01 <monochrom> type Tiramisu = CoffeeT Cake
10:10:07 <monochrom> add "let"..."in"
10:11:04 <monochrom> also wrong use of ".".  putStrLn (printf ...)
10:11:29 <ezzieyguywuf> If I have MyModule with `build-depends: nonempty-containers` in MyModule.cabal, how come MyOther module requires `build-depends: MyModule, nonempty-containers`? am I doing something wrong in MyModule.cabal that I need to explicitly list the sub-dependency?
10:11:48 <merijn> ezzieyguywuf: modules don't have build-depends
10:11:59 <merijn> ezzieyguywuf: libraries and executables do
10:12:33 <merijn> ezzieyguywuf: Also, based on Bayesian prior I'm going to go with: you have source for a library and an executable in the same directory, don't you?
10:12:43 <monochrom> I think maybe post the actual MyModule.cabal
10:13:15 <merijn> monochrom: pfft, don't diss my statistical debugging skills, 85% of the time they work every time! :p
10:13:32 <merijn> Because everyone predictably fucks up the same ways ;)
10:13:45 <monochrom> OK!
10:13:58 <Polesch> I get parse error on 'let
10:14:12 <monochrom> Is this why every sci-fi states that humans are telepathic in the future?
10:14:23 <merijn> ezzieyguywuf: And do I get a cookie for guessing right? :p
10:14:24 <ezzieyguywuf> merijn: I do not have a library and executable in the same direcotry. I have the library in a sub-directory, the executable in the root directory.
10:14:32 <ezzieyguywuf> merijn: lol, no cookie.
10:14:37 <merijn> That's weird
10:14:51 <ezzieyguywuf> weird i.e. I should move my executable to an app sub-dir?
10:15:00 <merijn> ezzieyguywuf: No, that's fine
10:15:04 <merijn> ezzieyguywuf: I meant getting that error
10:15:14 <ezzieyguywuf> that's what I thought!
10:15:29 <merijn> ezzieyguywuf: Do you import nonempty-containers in both your library and the executable?
10:16:14 <ezzieyguywuf> no, only in the library.
10:17:05 <ezzieyguywuf> merijn: https://gitlab.com/ezzieyguywuf/mycad/-/tree/makeFace/Test , I was wrong, I actually have the libarry and executable in two different sub-directories.
10:17:32 <merijn> ...
10:17:53 <ezzieyguywuf> merijn: notice, for example https://gitlab.com/ezzieyguywuf/mycad/-/blob/makeFace/Test/Test.cabal#L38
10:17:54 <monochrom> That's still fine, actually much safer IMO
10:17:54 <merijn> Right, you have them in separate directories, but then have both of those directories in hs-source-dirs of library
10:18:05 <ezzieyguywuf> (I haven't pushed the commit yet with the nonempty-containers)
10:18:06 <merijn> So you might as well have them in the same directory
10:18:16 <ezzieyguywuf> ü§¶‚Äç‚ôÇÔ∏è
10:18:16 <merijn> https://gitlab.com/ezzieyguywuf/mycad/-/blob/makeFace/Test/Test.cabal#L30-31
10:18:23 <merijn> That defeats the entire purpose >.>
10:18:26 <ezzieyguywuf> I did that because I was trying to get fancy with ghcid. I'll fix it
10:19:33 <monochrom> That's a lot of hs-source-dirs
10:20:05 <merijn> Yeah
10:20:08 <merijn> That doesn't seem right
10:20:41 <monochrom> I guess reasonable for the test-suite, but unusual for the library.
10:20:59 <monochrom> err nevermind the library has a very short hs-source-dirs list
10:21:49 <monochrom> I think I don't understand the question, but the library section needs its build-depends, and the test-suite section needs its build-depends, this is normal.
10:22:11 <Polesch> Do I always need main to compile?
10:22:37 <merijn> monochrom: The problem was that he was adding a build-depends to the library and then also needing it on the executable despite not importing it (due to the messed up source dirs)
10:22:54 <monochrom> But there is no executable section.
10:26:19 <ezzieyguywuf> monochrom: the executable is the test stanza
10:29:17 <solonarv> Polesch: you need a 'main' if you want to produce an executable, because 'main' defines what happens when the executable runs.
10:29:49 <monochrom> test-suite needs its own explicit build-depends, regardless of how, from your POV, conceptually, it is related to the library section
10:32:19 <Polesch> Keeping getting parse error on my main = do, not sure where the problem is
10:33:21 <fog> so if i write the body of the tree with the "FContainer" version, like the HContainer, but mapping the overall datatype over the list of parameters
10:33:38 <fog> erm... 
10:34:04 <fog> i mean, so that it "unmaps" the constructor from the parameters on each of the branches
10:34:29 <fog> then i can take the list of parameters and store that in the overall parameter to the Cofree style tree
10:34:36 <solonarv> Polesch: post the entire code, then (using a paste site, like gist.github.com)
10:34:51 <hyiltiz> Polesch: Don't "do print"; just `main = print "Hello world"`
10:34:59 <hyiltiz> %t print
10:34:59 <fog> i have something that does that here; https://gist.github.com/fog-hs/19abbf2ee8cf1f9f0c39abf0772da34e
10:35:06 <fog> but it is for Free, not Cofree
10:35:08 <hyiltiz> @t print
10:35:08 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
10:35:30 <fog> and i get confused about if my types are supposed to be at the branches or at the leafs
10:35:33 <hyiltiz> %type print
10:35:49 <solonarv> hyiltiz: we have two bots here
10:35:58 <monochrom> You're missing out a colon
10:36:03 <fog> % :t print
10:36:03 <yahb> fog: Show a => a -> IO ()
10:36:04 <hyiltiz> yeah both seems to be angry at me
10:36:07 <hyiltiz> oh
10:36:27 <fog> @slap yahb
10:36:27 * lambdabot decomposes yahb into several parts using the Banach-Tarski theorem and reassembles them to get two copies of yahb!
10:36:34 <solonarv> lambdabot responds to messages that start with @ or ? immediately followed by a command, as well as to messages starting with '> ' followed by a Haskell expression
10:36:41 <monochrom> \‚à©/ more yahbs
10:37:00 <Polesch> solonarv, this is what I've got now https://pastebin.com/vQL65CV9
10:37:12 <solonarv> yahb is just GHCi stapled to an IRC client, it responds to messages starting with '% ' followed by something you'd type into a GHCi prompt
10:37:32 <hyiltiz> thx!!!
10:37:38 <solonarv> Polesch: ah, the error here is not with 'main'
10:37:49 <solonarv> instead it is with lines 7-13, which are incorrect
10:37:51 <dminuoso> solonarv: Did the authors really use a stapler? I didn't know that.
10:38:06 <Polesch> Right, that makes sense
10:38:43 <fog> i thought they passed it through a guitar effects pedal that was modulated through the sound of a pheasant 
10:38:49 <ezzieyguywuf> monochrom: so even if my library has build-depends: containers, my test-suite needs it to, even if it build-depends:myLibrary?
10:38:50 <monochrom> I am teaching a unix and c course, including how to use pipes to do that stapling :)
10:38:59 <monochrom> yes
10:39:17 <MarcelineVQ> monochrom: yahb
10:39:19 <MarcelineVQ> woops
10:39:27 <monochrom> build-depend's rule is not transitivity.
10:39:55 <MarcelineVQ> yahb's stapling includes some process sandboxing of some kind I forget, mniip's source should be kicking around somewhere though
10:40:05 <monochrom> build-depend's rule is much simpler. Iff you have "import Foo", then build-depends needs the package that has Foo.
10:40:13 <hyiltiz> Polesch: your nucleotide is not really a function definition; for the least, you need a "=" at the end of line 7
10:40:24 <fog> if your pipe is a scanner that emulates the biased noised on a quantum channel to pass the compiler throught the modulated pheasant... 
10:40:30 <Polesch> Yeah, I noticed a few obvious errors in there
10:40:43 <fog> noise*
10:40:51 <Polesch> All of this code is a mess, unusable
10:40:59 <hyiltiz> then "test" or "x" is ambiguous; just pick one
10:41:02 <solonarv> the other error there is that 'let ... in ...' is an expression; 'let' without an 'in' is malformed (unless inside a 'do' block)
10:41:04 <fog> gibberish! 
10:41:10 <xsperry> Polesch, there are several errors, Text.Printf, not Text.Pritf, you are missing = in nucleotide, missing "in" in "let", or alternatively use do with proper indentation. it is also not necessary to put function types at the top
10:41:18 <ezzieyguywuf> monochrom: so how come when I build-depends a package that has its own build-depends, I don't have to specify each of the dependencies recursively?
10:41:22 <hyiltiz> Also don't return a Printf, just return a String
10:41:44 <monochrom> Perhaps you don't have a related "import Foo".
10:41:45 <fog> i think the problem i have with thinking about types is they stochastically flip into random branches 
10:42:06 <ezzieyguywuf> ah
10:42:15 <ezzieyguywuf> what you are saying makes sense.
10:42:23 <ezzieyguywuf> but also, I think it wasn't precisely my issue.
10:42:46 <hyiltiz> and your A T G C in the tuples in line 13 are undefined; just use them as Strings or Char
10:42:59 <monochrom> Dear God, types aren't stochastic at all.
10:43:00 <Polesch> Actually got it working now
10:43:10 <fog> monochrom: thats the problem!
10:43:15 <hyiltiz> I've been studying backtracking. Except using State or CPS, most seem to use NonDeterminism plus guard like https://en.wikibooks.org/wiki/Algorithm_Implementation/Miscellaneous/N-Queens#Haskell. But that is just brute-force with filtering, not really backtracking, isn't it?
10:43:46 <fog> i need a solid state partition to my brain to help with these thinkings
10:44:13 <fog> HCofree, whats the problem?
10:44:49 * hackage postgres-websockets 0.8.0.0 - Middleware to map LISTEN/NOTIFY messages to Websockets  https://hackage.haskell.org/package/postgres-websockets-0.8.0.0 (diogob)
10:44:52 <monochrom> hyiltiz: Long story short, if you use lazy evaluation on that code, you end up doing backtracking steps.
10:45:11 <fog> hmm i think it could be a mix between Free and Cofree, because some of the different typed data is on the branches and some is at the leafs 
10:45:38 <monochrom> You're right and I'm right. The code does not look like backtracking. The execution does.
10:45:46 <fog> but whatever it is, im sure it follows the pattern that the type annotations should use the hetrogenous version of itself
10:45:56 <hyiltiz> Nondeterminism+Guard+Strict evaluation=Brute force; Nondeterminism+Guard+Lazy evaluation=Brute force; 
10:46:00 <hyiltiz> Huh!?
10:46:19 <hyiltiz> Just when I thought I got lazy evaluation, it jumps out of nowhere in a completely new disguise
10:46:23 <monochrom> "backtrack" and "brute-force" can co-exist, no?
10:46:32 <dolio> What is backtracking other than brute force?
10:46:49 <hyiltiz> well, let me be clear in my semantics
10:46:58 <fog> wavefunction collapse?
10:47:13 <hyperisco> backtrack is an optimisation
10:47:38 <hyiltiz> brute force: start afresh and try till fail then repeat; backtrack: start afresh and try till fail then undo latest step and go to try;
10:47:42 <hyperisco> but what qualifies as "brute force" can vary
10:48:03 <monochrom> "brute force" is broad. Also a spectrum not a boolean
10:48:21 <hyiltiz> I dont see how lazy eval helps nondet to undo/restart from some latest state
10:49:05 <dolio> It seems like the only difference between 'brute force' and 'backtracking' in your descriptions is that 'brute force' re-does work.
10:49:13 <monochrom> If a problem says "find all even primes in the range 1-100" and you only search over the range "2-90" we still call it brute force even though it "optimizes away" 1 and 91-100.
10:49:27 <hyiltiz> I was reading about this because I wanted to implement DLX ideally without using CPP CPS or State if possible
10:49:59 <dolio> But even most eager evaluation won't re-do work. It will just do extra work before it's necessary.
10:50:30 <hyiltiz> monochrom: I see your point now; it is in a spectrum from blindly checking all state to simply using a generative function (maybe after doing manual math first)
10:50:46 <monochrom> Let's also hairsplit over what counts as Sieve of Erastothenes, shall we?
10:50:55 <hyperisco> to me, backtracking is an optimisation for problems in which a partial solution can be decided to be valid or not (for all completions)
10:51:15 <hyperisco> so then you back up to a prior decision point and try something else
10:51:44 <hyiltiz> So does the code pasted above in that wikibook does "back up to a prior decision point and try something else"?
10:52:04 <hyiltiz> prior decision point has to be specified it seems
10:52:12 <monochrom> Yes if you use lazy evaluation.
10:52:14 <hyperisco> brute force then would not be making use of this, so it would continue regardless, arriving at a complete candidate solution before checking if it is valid
10:52:29 <hyiltiz> if it means full chess board specification then it is pointless; if partial chess board, I'd say it is backtracking
10:52:31 <fog> seems like yall have a problem that could be solved with geometric information theory and approximate Bayesian computation
10:53:38 <fog> why not use quantization and simulated annealing? you act like quantum tunnelling isnt a thing - representation theory exists people! 
10:54:08 <hyperisco> for example, if you are solving Sudoku, if you are using backtracking you would stop at a partial candidate solution if, for example, you put two 3's in the same row. Then you'd back up and try something other than 3 in the current cell. Brute forcing would continue on with two 3's in the same row and complete the whole puzzle before checking if the candidate solution is valid
10:54:33 <hyiltiz> fog: u still need to specify a generating procedure for info theory / bayes; no idea how quant. is related to them
10:54:41 <fog> "no,no my probability space is discreet" ok, yeah, but, analytic continuation, or what?
10:55:07 <hyperisco> there are problems for which brute forcing is the best you can do, because only complete solutions can be validated
10:55:33 <fog> hyiltiz: right, but thats the whole point with jones polynomials and knott theory 
10:55:44 <fog> they are just inflection points
10:57:12 <hyiltiz> So ultimately backtracking for NonDet is implemented not fully by the nondet monad, but inside GHC runtime (lazy eval)? That sounds a bit like magic; how am I about to know what cases can GHC "smartly" does backtracking instead of generating all cases then filtering?
10:57:38 <fog> quantization is just sectioning, the "points" are probably just a manifestation of the flat earth conspiracy / orbitals  
10:57:56 <dolio> If you learn the evaluation model GHC uses, it is no longer magic.
10:58:28 <fog> probably just some hyperkhaler manifold or something...
10:58:41 <monochrom> OK very handwavingly before I go to class: regardless of lazy vs eager, the "foldM blah" describes a search tree --- OK it will collapse to a flat list but before simplifying >>='s to get the flat list you had a huge tree.  The "foldM blah" also calls "safe" to check every path of the tree and prunes the bad ones.
10:58:55 <hyiltiz> Seems like I can write a C backtracking then figure out knott theory and encode N-Queens into one and analyze its polynomials...
10:59:24 <dolio> There are also implementations of a NonDet type that use continuation passing, and have nothing to do with GHC's evaluation model.
10:59:30 <fog> the whole problem is to do with hyperbolicity. thats why you have "heat equations" with infinite charicteristics and expensive total inversions
10:59:47 <fog> as if you could blur out the local minima
10:59:59 <monochrom> Now if you use lazy evaluation on that, the evaluate steps have you do lazy DFS, i.e., you don't build a path until you walk it, and you retain a path prefix for returning to it and try another child. So that's backtracking.
11:00:32 <fog> so you just do some contour integrals and end up with a convergent analytic expansion and end up doing the computation using symbolic algebra 
11:00:59 <fog> you think you cant "solve" chess?
11:01:49 <hyiltiz> monochrom: thx I am reading that three times till it sinks in
11:02:17 <hyiltiz> Anywhere I can read about GHC eval model? I did read a few pages in the GHC gitlab wiki
11:02:35 <fog> something something residue theory, something something pole placement 
11:03:14 <fog> damn this hot weather! my brain is to hot!
11:03:41 <hyiltiz> Like Strictness analysis and Demand analysis
11:03:47 <dolio> https://www.microsoft.com/en-us/research/wp-content/uploads/1992/04/spineless-tagless-gmachine.pdf
11:04:56 <hyiltiz> Is that Simon's dissertation? 
11:05:11 <fog> then i think you use the schwinger kieldish formalism for the out-of-time ordered causal propegators... 
11:05:21 <hyiltiz> i.e. can i get away with reading something less than 80 pages?
11:05:55 <dolio> I don't know. There are probably many resources explaining lazy evaluation.
11:06:03 <merijn> hyiltiz: That's the easiest read on how things work, tbh
11:06:05 <fog> but anyway, yeah, its just a convex optimisation problem at the end of the day
11:06:28 <merijn> hyiltiz: There might be shorter things, but they'll either be harder or less complete
11:06:46 <dolio> You don't really need to understand STG.
11:06:52 <fog> i guess MPI ends up as a minima 
11:07:07 <dolio> But you need to understand lazy evaluation, and not just say "it's magic."
11:07:45 <hyiltiz> Hmm I think I can maybe get away with just reading the first two sections and skip the last section on how to translate into C?
11:08:22 <hyiltiz> That leaves me 40 pages
11:08:27 <dolio> Cale frequently explains it here, but I don't know if he has a page where it's just written down to read.
11:09:02 <fog> anyway, thats whats up with higgs bundles, the ghost terms as residues around which the path integral is performed. maybe your types end up as bosons 
11:09:09 <enikar> hyiltiz: I don't if that can help but in case: https://en.wikibooks.org/wiki/Haskell/Laziness
11:09:56 <fog> the adjoined cofunctor being the exchange particle for the yoneda field 
11:09:59 <hyiltiz> Well I did read about lazy eval in the haskell wiki, wikibook, Real World Haskell, LYAHFGG and a few blogs
11:10:13 <hyiltiz> Doesnt seem enough so I guess Simon's paper is a must read
11:11:20 * hackage sexp-grammar 2.2.1 - Invertible grammar combinators for S-expressions  https://hackage.haskell.org/package/sexp-grammar-2.2.1 (EugeneSmolanka)
11:13:47 <ski> @where lazy
11:13:47 <lambdabot> "Lazy Evaluation of Haskell" by monochrom at <http://www.vex.net/~trebla/haskell/lazy.xhtml>; "The Incomplete Guide to Lazy Evaluation (in Haskell)" by apfelmus in 2015-03-07 at <https://apfelmus.
11:13:47 <lambdabot> nfshost.com/articles/lazy-eval.html>; "Laziness, strictness, guarded recursion" by bitemyapp at <https://github.com/bitemyapp/learnhaskell/blob/master/specific_topics.md#user-content-laziness-
11:13:47 <lambdabot> strictness-guarded-recursion>
11:16:04 <hyperisco> using strictness as the default again becomes annoying
11:16:34 <hyperisco> I am really fond of  f  and  \x -> f x  being the same
11:22:21 <hyiltiz> thx!!!
11:22:30 <fog> i guess when you cool down the integrable system it settles into the grooves 
11:25:27 <fog> and then the whole task is fixing the subsystem so the interpolative surface has some reason for some particular twisty bias 
11:26:41 <fog> and then you should be able to recover the compiler as an emergent quazi-particle 
11:31:20 <hyiltiz> So u generate a compiler each time you run a simulated annealing? I wonder what the transitions, cost function and the constaints for that would be
11:31:48 <hseg> any way to get -Wunused-packages to display component names? my cabal project has internal dependencies, some of which are unused, but ghc says $project-$version is unnecessary, leaving me clueless
11:34:57 <Polesch> Anyone familiar with exercism?
11:37:59 <tomsmeding> Polesch: issues?
11:38:05 <tomsmeding> :)
11:38:35 <Polesch> I would just like to know where (if any) the information on the problems are
11:38:59 <tomsmeding> in the old days when exercism was simple, that was really easy
11:39:07 <tomsmeding> I wonder why it's so opaque now
11:39:28 <Polesch> Sure it gives you a brief explanation of the problem, but I can't find any information on the input or output it wants, or even what to name functions
11:40:37 <tomsmeding> can you give an example of an exercise where you're unsure about what to do, I/O-wise?
11:41:02 <Polesch> https://exercism.io/my/solutions/f6d18ef9170349e1ae5261f7effbc65a
11:41:14 <Polesch> Not sure if it's available without logging in?
11:41:46 <tomsmeding> I can't see your solution, but I can see the exercise to which it is a solution
11:42:17 <tomsmeding> right that _is_ kind of unclear
11:43:04 <tomsmeding> do you have the exercism command-line tool?
11:43:20 <Polesch> Yeah, I'm trying to run the tests/test suite
11:43:57 <tomsmeding> do you get an error?
11:44:22 <tomsmeding> the downloaded framework should give you a file (DNA.hs) with a stub implementation of the function you should implement
11:44:49 * hackage sak 0.1.2.6 - Compression command-line tool  https://hackage.haskell.org/package/sak-0.1.2.6 (vmchale)
11:45:26 <Polesch> Must have been the one in the src/ directory, too bad I deleted it
11:45:40 <tomsmeding> yes, that one :)
11:45:43 <Polesch> Can just download it again
11:45:45 <tomsmeding> you can
11:45:50 <tomsmeding> or get it from here: https://github.com/exercism/haskell/blob/master/exercises/nucleotide-count/src/DNA.hs
11:46:11 <tomsmeding> so yeah, that file you deleted gave you the I/O specification :)
11:46:42 <Polesch> The I/O specification is far more difficult for a beginner than the problems themselves :P
11:47:05 <tomsmeding> in the past, they allowed just editing the contents of e.g. DNA.hs in the browser, on the page of the exercise
11:47:21 <tomsmeding> perhaps they removed that to force you to go through the steps of building a proper application in the language you're learning
11:47:32 <tomsmeding> I don't know
11:47:39 <Polesch> Don't understand much of this file to be honest
11:47:50 <tomsmeding> is this the first exercise you do?
11:47:57 <Polesch> 5th one now
11:48:12 <tomsmeding> perhaps there's an earlier one that explains the components of that file
11:48:16 <tomsmeding> or you can ask here :)
11:48:26 <tomsmeding> what parts have you not seen before
11:49:44 <Polesch> This is the code that runs the test suite afaik https://pastebin.com/w6EjgTAx
11:50:19 <tomsmeding> it is; you shouldn't need to edit that file I think
11:50:52 <Polesch> So I wrote the code to output a list like those in matchsMap: [(A, 2), (C, 2), (G, 2), (T, 2)] as a putStrLn
11:51:24 <Polesch> Actually this looks quite complicated to me
11:51:42 <tomsmeding> perhaps you can paste the code you've written now?
11:54:02 <tomsmeding> and also, perhaps, how you're trying to run the tests
11:54:46 <Polesch> Well, that's another issue - in order for me to get the code working I need main, but the test suite imports the function with a specific name so I don't know how to test it myself written as they want it
11:54:57 <Polesch> This is the code I want to try: https://pastebin.com/KxHPY0bf
11:55:31 <Polesch> function name should be nucleotideCounts though
11:56:14 <Polesch> It doesn't seem to be what they want
11:56:15 <tomsmeding> cool, thanks
11:56:50 <xsperry> what's the point of putStrLn $ id?
11:56:51 <tomsmeding> as you can see in the original file (https://github.com/exercism/haskell/blob/master/exercises/nucleotide-count/src/DNA.hs), the function you write should return a value of type 'Either String (Map Nucleotide Int)'
11:57:10 <tomsmeding> you shouldn't be writing something to the output
11:57:29 <tomsmeding> I assume in earlier exercises, you have also needed to return values, haven't you?
12:00:51 <Polesch> Tricky question, I've written functions that evaluate input, but also a "Hello, World!" that just used print
12:02:19 <tomsmeding> none that produce output?
12:02:55 <tomsmeding> different question: do you have experience in other programming languages, or is this your introduction to programming in general?
12:03:04 <Polesch> No, the exercises so far has been to evaluate False or True
12:03:51 <Polesch> I've done a lot of R and python, new to functional programming
12:04:23 <tomsmeding> ah right
12:04:30 <Cheery> I used to do python as well.
12:05:22 <tomsmeding> so in this code (https://pastebin.com/KxHPY0bf), you're writing a string to standard output, analogously to print() in python
12:05:39 <tomsmeding> the exercise is asking you to return a value, same as you'd return a value from a python function
12:05:50 <Cheery> I was silly and ignored community moving on from Python 2, then my stuff broke.
12:05:55 <tomsmeding> :D
12:06:07 <Cheery> THE END
12:06:07 <tomsmeding> the python 2/3 situation was kind of unfortunate
12:06:20 <tomsmeding> well, is kind of unfortunate
12:06:31 <Polesch> What is the equivalent to return in haskell?
12:06:40 <Polesch> I did try to look this up but wasn't very successful
12:06:42 <tomsmeding> you know 'lambda' functions in python?
12:06:50 <Polesch> sure
12:06:59 <tomsmeding> all haskell functions are python-lambda-like things
12:07:03 <tomsmeding> there is no return statement
12:07:03 <Cheery> Polesch: do you mean return statement?
12:07:04 <tomsmeding> at all
12:07:16 <Polesch> right
12:07:19 <jle`> Polesch: all haskell functions evaluate to values
12:07:20 <tomsmeding> the 'return' function you may have seen in haskell code is not a return statement
12:07:37 <Polesch> And why I didn't try using it :P
12:07:38 <jle`> so the equivalent would be just...value value itself
12:07:40 <xsperry> Polesch, f x = x*x   in haskell is the same as    def f(x): return x*x    in python
12:07:42 <tomsmeding> that's a monadic thing you to which you will be introduced later :p
12:07:58 <jle`> *the value itself
12:08:19 <Cheery> Polesch: 'Either' could sort of work as a return.
12:08:22 <tomsmeding> xsperry: yes, though I'd argue 'f = lambda x: x*x' is a more literal translation to python
12:08:40 <tomsmeding> not sure how you see Either as a "return" though
12:08:47 <tomsmeding> don't think that's a helpful perspective at this point :p
12:08:56 <Cheery> do Left foo ; Right bar
12:09:11 <Polesch> I did order two books on haskell a week ago that still hasn't arrived, I can wait :P
12:09:13 <tomsmeding> and certainly let's ignore do notation for the moment :p
12:09:21 <jle`> probably not a helpful perspective at this point heh heh
12:09:47 <DigitalKiwi> Polesch: what books did you order?
12:10:10 <ski> Cheery : it's more `Right' which happens to coincide with the definition of Haskell `return', for `Either e'
12:11:36 <Polesch> https://www.amazon.com/Get-Programming-Haskell-Will-Kurt/dp/1617293768
12:12:00 <Polesch> And this https://www.amazon.com/Haskell-Very-Beginning-John-Whitington/dp/095767113X
12:12:28 <tomsmeding> there are also certain learning resources online, if you wish
12:12:53 <ski> Polesch : style (opinion), i would not use `$' at all there. imho, you'd do better with avoiding it completely, or almost completely, until you get a clearer sense of when it may be appropriate to use it (which is much more seldom than newbies (and some not-so-newbies) seem to use it)
12:13:03 <jle`> cute cover
12:13:07 <jle`> for the Kurt text
12:13:08 <DigitalKiwi> <3 hutton programming in haskell
12:13:17 <tomsmeding> but looking at the exercism questions, they don't seem to really explain anything, just test knowledge you already have; so I'd say: first learn some haskell (e.g. using a book, or an online resource), then start with exercism
12:13:43 <Polesch> Yeah, I think so
12:13:59 <tomsmeding> I thought that exercism explained more, but apparently that's not the case
12:14:11 <Polesch> I know hackerrank has a better offer for exercises
12:14:19 <ski> @where PIH
12:14:20 <lambdabot> "Programming in Haskell" by Graham Hutton in 2007-01-15,2016-09-01 at <http://www.cs.nott.ac.uk/~pszgmh/pih.html>
12:14:27 <Cheery> To understand Haskell, I think you want to understand types and the idea of how they're sort of ways to construct and then take it apart.
12:14:43 <tomsmeding> ... which you're best off learning from a tutorial or a book
12:14:45 <Polesch> Is this book by Hutton good?
12:14:47 <tomsmeding> the very first steps
12:15:00 <ski> Polesch : i understand many here consider it good
12:15:33 <Polesch> Price is good
12:15:47 <Cheery> it's all right.
12:15:59 <ski> @where HPFFP
12:16:00 <lambdabot> "Haskell Programming: from first principles - Pure functional programming without fear or frustration" by Chistopher Allen (bitemyapp),Julie Moronuki at <http://haskellbook.com/>,#haskell-beginners
12:16:05 <ski> some people like that one ^
12:16:10 <DigitalKiwi> it's one of the best ones i've read and one of the only i've read completely (twice even)
12:17:00 <ski> (note that different people have different learning styles, and different backgrounds. so it's not "one size fits all")
12:17:35 * ski learned from "Haskell: The Craft of Functional Programming" by Simon Thompson
12:17:41 <DigitalKiwi> yeah i've tried them all
12:18:02 <DigitalKiwi> that was a good one
12:18:16 * tomsmeding learned from http://learnyouahaskell.com/
12:18:24 <ski> @where CIS194
12:18:24 <lambdabot> https://www.seas.upenn.edu/~cis194/spring13/lectures.html
12:18:37 <ski> might perhaps be useful to take a glance at
12:18:51 <ski> @where HTAC
12:18:52 <lambdabot> "Haskell Tutorial and Cookbook" by Mark Watson in 2017-09-04 at <https://leanpub.com/haskell-cookbook>
12:18:56 <ski> @where wikibook
12:18:56 <lambdabot> http://en.wikibooks.org/wiki/Haskell
12:19:26 <tomsmeding> plethora!
12:19:29 <ski> (are we overloaded with suggestions, yet ?)
12:19:47 <tomsmeding> I'd be :')
12:20:12 <dolio> Where's the Gentle Introduction?
12:20:45 <ski> i didn't see Polesch say they were already familiar with functional programming
12:20:51 <dolio> :)
12:21:02 <dolio> I wasn't, either, really.
12:21:02 <Polesch> I am not, the concept is still quite bizarre.
12:21:31 <Cheery> How good is XMonad these days?
12:21:35 <DigitalKiwi> have anyone read the new bird book
12:21:45 <DigitalKiwi> is it going to make my head 'splode
12:21:56 <ski> @quote is.the.solution
12:21:57 <lambdabot> quicksilver says: head-explosion is the solution, not the problem.
12:22:21 <DigitalKiwi> perls of functional algorithm design makes it hurt
12:22:34 <ski> that's a cool book :)
12:22:48 <tomsmeding> how many lambdabot quotes are there
12:22:48 <ski> (not for the beginner, though)
12:22:54 <ski> dunno
12:23:14 <ski> there's some i contextually can recall
12:24:17 <DigitalKiwi> and i don't know if algorithm design with haskell is going to be "better" or "worse" (if it's up to par with his other works i'm sure it's a good book)
12:24:41 <ski> (also seems to be a lot of more or less "meh" ones, than ranging up to the more interesting/useful/funny ones)
12:24:53 <sureyeaah> Cheery: i switched a few weeks ago from i3 to xmonad and it's so much better.
12:25:22 <ski> DigitalKiwi : did you read FPDS ?
12:25:41 <ski> er, PFDS
12:25:43 <DigitalKiwi> i like xmonad haven't felt like using anything else in a long time
12:25:57 <DigitalKiwi> ski: ...i tried
12:27:10 <DigitalKiwi> i'm a bit better now than i was last time i read a lot of these and struggled; i should try again
12:27:45 <ski> there's also FOP, which is sortof similar to PFAD
12:27:49 <ski> @where FOP
12:27:49 <lambdabot> "The Fun of Programming" edited by Jeremy Gibbons,Oege de Moor in 2003-03-27 at <https://www.cs.ox.ac.uk/publications/books/fop/>
12:29:54 <ski> "Fun with phantom types" by Ralf Hinze at <http://www.cs.ox.ac.uk/ralf.hinze/publications/With.pdf> is one chapter from it
12:31:02 <DigitalKiwi> so many books so little brain :(
12:32:06 <sureyeaah> DigitalKiwi: my neurons are crying
12:34:49 * hackage functor-combinators 0.3.3.0 - Tools for functor combinator-based program design  https://hackage.haskell.org/package/functor-combinators-0.3.3.0 (jle)
12:42:01 <hyiltiz> Polesch: once you are finished with any of those books, you'd be able to write something like `f test = (\x -> (head x, length x)) <$> group [y | x<-"ATCG", y<-test, x==y]`
12:42:17 <hyiltiz> group comes from Data.List module
12:43:02 <ski> seems <http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.96.2612> is another chapter of FOP. "Functional images" by Conal Elliott
12:43:04 <hyiltiz> There are probably much more elegant ways to do it
12:43:43 <Polesch> I will try to make sense of it
12:45:15 <ski> hyiltiz : could use a list comprehension also in place of `<$>'
12:45:36 <hyiltiz> hmm right
12:46:06 <ski>   f test = [(head xs,length xs) | xs <- group [y | x <- "ATCG",y <- test,x == y]]
12:46:17 <ski> alternatively
12:46:37 <ski>   f test = [(x,length xs) | xs@(x:_) <- group [y | x <- "ATCG",y <- test,x == y]]
12:47:33 <hyiltiz> ^ that is pretty much reads like math/python (Polesch said he has Python background)
12:48:18 <ski> Polesch : either of those ^ might be easier to grasp. you don't have to understand lambda expressions (`\.. -> ..') nor functors (`<$>'). you'll still need to understand list comprehensions, though
12:49:08 <hyiltiz> yeah; lambda or functors were not necessary there. I just tend to heavily rely on them whenever I can...
12:49:54 <ski> @type head &&& length
12:49:55 <lambdabot> [c] -> (c, Int)
12:52:50 <frdg> is ghci the io monad?
12:54:28 <jle`> not really
12:54:50 <jle`> maybe once upon a time it could be argued that lines of ghc are as if you were doing do notation in IO
12:55:06 <jle`> but at this point we're so far from that stage that i don't think that perspective is helpful anymore
12:55:11 <hololeap> you can still do that though
12:55:22 <jle`> kind of but not really?
12:55:30 <ski> if you enter an expression of type `IO T', it'll (evaluate and) execute it, then `print' the result of type `T' (provided it's an instance of `Show')
12:55:32 <jle`> most of the things i use ghci for have no connection to IO monad do notation
12:55:46 <merijn> Fun fact: Python's list comprehensions were copied from Haskell ;)
12:55:53 <jle`> so using it for IO is like ... a very limited subset of what ghci is used for
12:56:38 <ski> if you enter a bind command `<pat> <- <expr>', then `<expr>' should have type `IO T', and that action will be executed as before, and the result of type `T' matched with the pattern `<pat>' (no `print'ing)
12:57:13 <frdg> There is similarity in that you are going layers deeper, into different contexts? Like why `> x = 2; > x = 3; > x` returns 3.
12:57:35 <frdg> and in between can perform side effects.
12:57:36 <jle`> merijn: that's the example i go to when i try to argue that even if haskell is never succesful, it's a good playground for language features that are adopted by other languages when they've been 'proven'
12:57:40 <merijn> frdg: You're defining a new 'x' that hides the old one, yes
12:57:58 <ski> (also you can enter `let <decls>' commands)
12:58:23 <frdg> ok I think I see how monads work now
12:58:25 <DigitalKiwi> merijn: this is one of reasons i encourage people (even if they don't end up using haskell a ton, and, say write javascript or python) to learn haskell. soooo many things in other languages are "borrowed" from *haskell, things like it* or have more clear implementations in haskell and thus easier to understand and makes understanding them in other languages easier
12:58:52 <jle`> i mean a lot of things we try in haskell-the-language are arguably dead ends
12:59:13 <jle`> so maybe our role in the grand scheme of things is to be that filter to insulate the mainstream PL ecosystem
12:59:25 <DigitalKiwi> like, scala, i didn't understand a lot of scala until i learned haskell
12:59:25 <ski> frdg : try `> let x = 2', then `> let f y = x + y', then `> let x = 3', then `> f 5' (nowadays, you can omit the `let's, if you want to)
13:00:28 <frdg> right I forgot that the let is beneath the surface. 
13:00:36 <ski> hm ?
13:01:27 <hyiltiz> f test =(head &&& length) <$> (group $ fst <$> (filter (\(x,y)->x==y) $ (,) <$> "ATCG" <*> test))
13:01:46 <hyiltiz> The Applicative style is much more uglier than the list comprehention sugar huh
13:02:12 <hyiltiz> Or am I not simplifying it enough?
13:02:12 <frdg> ski: that example kind of says it all.
13:02:42 <ski> (i remember i formulated a question (and figured out the answer), early on, about whether Haskell evaluation was "like macro-expansion" (i had CPP in mind). what i meant was whether Haskell used dynamic or static scoping)
13:03:14 <jle`> these days i like to think of the 'let' as the "you are allowed to use it if you want, for backwards compatibilty" rather than the underyling interpretation
13:03:28 <jle`> and x = 3 as the more consistent way to use ghci
13:03:48 <jle`> that's because most ghci commands are consistent with 'top level haskell code declarations'
13:04:28 <jle`> and only one oddball ghci command is consistent 'bind in IO do notation'
13:04:42 <hyiltiz> I can get rid of the lambda using uncurry: f test =(head &&& length) <$> (group $ fst <$> (filter (uncurry (==)) $ (,) <$> "ATCG" <*> test))
13:04:53 <hololeap> % x <- runConduitRes $ sourceFile "/dev/random" .| takeC 1 .| sinkList
13:04:53 <yahb> hololeap: ; <interactive>:129:6: error: Variable not in scope: runConduitRes :: t2 -> t1; <interactive>:129:22: error: Variable not in scope: sourceFile :: t5 -> t2; <interactive>:129:47: error:; * Variable not in scope: (.|) :: t1 -> t3 -> t0; * Perhaps you meant one of these: `C..' (imported from Control.Category), `.' (imported from Prelude), `||' (imported from Prelude); <interactive>:129:50: error
13:05:02 <hololeap> % import Conduit
13:05:02 <yahb> hololeap: ; <no location info>: error:; Could not find module `Conduit'; It is not a module in the current program, or in any known package.
13:05:04 <hyiltiz> Still, not as good as clean as the list comprehension
13:06:40 <hololeap> % :show imports
13:06:40 <yahb> hololeap: import Control.Applicative; import Control.Arrow; import Control.Concurrent; import Control.Concurrent.Chan; import Control.Concurrent.MVar; import Control.Concurrent.STM; import Control.Concurrent.STM.TChan; import Control.Concurrent.STM.TVar; import Control.Comonad.Store; import Control.Exception; import Control.Exception.Lens; import Control.Monad; import Control.Monad.Cont; import Control.Monad.Except; impo
13:08:03 <hololeap> % :i ByteString
13:08:04 <yahb> hololeap: ; <interactive>:1:1: error: Not in scope: `ByteString'
13:08:25 <hololeap> % :i BSL.ByteString
13:08:25 <yahb> hololeap: type BSL.ByteString :: *; data BSL.ByteString = Data.ByteString.Lazy.Internal.Empty | Data.ByteString.Lazy.Internal.Chunk {-# UNPACK #-}BS.ByteString BSL.ByteString; -- Defined in `Data.ByteString.Lazy.Internal'; instance Eq BSL.ByteString -- Defined in `Data.ByteString.Lazy.Internal'; instance Monoid BSL.ByteString -- Defined in `Data.ByteString.Lazy.Internal'; instance Ord BSL.ByteString -- Define
13:08:50 <hololeap> % x <- BSL.take 20 <$> BSL.readFile "/dev/random"
13:08:50 <yahb> hololeap: *** Exception: /dev/random: openBinaryFile: does not exist (No such file or directory)
13:09:07 <jle`> % withBinaryFile "/dev/urandom" ReadMode hGetLine
13:09:07 <yahb> jle`: "\a\b\158#\216w\218\254\137\239\183\179`\202\\x\223\132\228\181\196T6\238W\156<\175\130\178\&2\208-X\DEL1\156\233\243\253wnht\243:.\149\213E\177\211\168\ETB#\221O\205\RSP\237 ]\184\131\182\175\&6\129\EOTY\DC2\174\222w\158\212\229\253\136\216\199"
13:09:17 <ski> % let test = "ATACATAG" in [(the y,length y) | x <- "ATCG",y <- test,x == y,then group by y using groupWith]  -- hyiltiz
13:09:17 <yahb> ski: [('A',4),('C',1),('G',1),('T',2)]
13:09:39 <hololeap> % x <- BSL.take 20 <$> BSL.readFile "/dev/urandom"
13:09:39 <yahb> hololeap: 
13:09:43 <hololeap> % :t x
13:09:44 <yahb> hololeap: BSL.ByteString
13:10:00 <hololeap> % x
13:10:00 <yahb> hololeap: "d\252\228\DC2\218\225\EOT\r\200\193\223\251\194\ETX\224\211\DC2\167M\ETX"
13:10:14 <jle`> an ascii character, nice
13:10:22 <jle`> s/an/a printable
13:10:33 <jle`> does that mean you get a bitcoin now or something
13:10:49 <ski> jle` : there's been suggestions about allowing `<-' on module toplevel
13:11:01 <jle`> üéø life imitates art :o
13:11:10 <hololeap> a satoshi
13:12:27 <frdg> `let x = 2; let f y = x + y; let x = 3`. How does this not cause an error? You cannot redefine x.
13:12:38 <jle`> in ghci?
13:12:46 <jle`> it's a shadowing
13:14:29 <frdg> ok that is what I thought. I think.
13:14:44 <jle`> you can think of it as, the first x binding still exists, it's just not accessible
13:15:00 <jle`> let x_1 = 2; let f y = x_1 + 2; let x_2 = 3
13:15:11 <jle`> * x_1 + y
13:15:27 <jle`> so if you run 'f 10', it should still return 12
13:15:32 <jle`> the f has the old x in its closure
13:16:34 <frdg> this makes sense
13:19:38 <hololeap> % replicateM 10 $ BSL.take 5 . BSL.filter (\b -> b > 96 && b < 123) <$> BSL.readFile "/dev/urandom"
13:19:39 <yahb> hololeap: ["zvgyz","mrhon","absao","mooyg","qxezz","iktqr","knrwk","oteit","mqzds","xluva"]
13:20:05 <hololeap> aw, no english words
13:20:32 * ski . o O ( `[< f test >] = (x,xs) where xs@(x:_)  = [< group [> let x = [< "ATCG" >]; y = [< test >]; _ = [< guard (x == y) >] in y <] >]' )
13:21:56 <hololeap> % replicateM 10 $ BL.intersperse 101 . BL.take 3 . BL.filter (\b -> b > 96 && b < 123) <$> BL.readFile "/dev/urandom"
13:21:56 <yahb> hololeap: ; <interactive>:146:17: error:; Not in scope: `BL.intersperse'; Perhaps you meant one of these: `BSL.intersperse' (imported from Data.ByteString.Lazy), `BS.intersperse' (imported from Data.ByteString), `BSC.intersperse' (imported from Data.ByteString.Char8); No module named `BL' is imported.; <interactive>:146:38: error:; Not in scope: `BL.take'; Perhaps you meant one of these: `BS.t
13:22:07 <hololeap> % replicateM 10 $ BSL.intersperse 101 . BSL.take 3 . BSL.filter (\b -> b > 96 && b < 123) <$> BSL.readFile "/dev/urandom"
13:22:07 <yahb> hololeap: ["leyeu","oeeed","oexek","xeieb","levej","eejem","uegef","feyeg","eeied","verea"]
13:22:46 <jle`> % readFile "/usr/share/dict/words"
13:22:46 <yahb> jle`: *** Exception: /usr/share/dict/words: openFile: does not exist (No such file or directory)
13:24:22 <hyiltiz> ski: whats with [< >]
13:25:46 <jle`> hyiltiz: list comprehension syntax :)
13:26:09 <jle`> > [ (x,y,z) | x <- [1..], y <- [x..], z <- [y..], x*x+y*y == z*z]
13:26:15 <lambdabot>  mueval-core: Time limit exceeded
13:26:19 <jle`> that worked better in my mind
13:26:36 <jle`> > [ (x,y,z) | x <- [1..20], y <- [x..20], z <- [y..20], x*x+y*y == z*z]
13:26:38 <lambdabot>  [(3,4,5),(5,12,13),(6,8,10),(8,15,17),(9,12,15),(12,16,20)]
13:27:05 <hyiltiz> all that just to do fst<$> huh
13:27:57 <hyiltiz> but it can pattern-match list-comprehension; cool
13:28:06 <hyiltiz> or so it seems
13:29:39 <hyiltiz> jle`: can we not restrict by 20 but rather somehow tell it to breadth first search? maybe via something like bifunctor
13:30:27 <ski> hyiltiz : my imagined "reflective effects" syntax
13:30:32 <jle`> maybe with -XMonadComprehensions, but i'm not sure if it's doable using teh default behavior
13:30:46 <hyiltiz> take 5[(x,y,z) | a<-[1..], x <- [1..a], y <- [x..a], z <- [y..a], x*x+y*y == z*z]
13:31:15 <hyiltiz> > take 5 [(x,y,z) | a<-[1..], x <- [1..a], y <- [x..a], z <- [y..a], x*x+y*y == z*z]
13:31:17 <lambdabot>  [(3,4,5),(3,4,5),(3,4,5),(3,4,5),(3,4,5)]
13:31:45 <hyiltiz> at least it terminates
13:31:50 <jle`> > nub [(x,y,z) | a<-[1..], x <- [1..a], y <- [x..a], z <- [y..a], x*x+y*y == z*z]
13:31:57 <lambdabot>  mueval-core: Time limit exceeded
13:32:13 <jle`> i feel like that should return at least (3,4,5)
13:32:23 <jle`> > head $ nub [(x,y,z) | a<-[1..], x <- [1..a], y <- [x..a], z <- [y..a], x*x+y*y == z*z]
13:32:25 <lambdabot>  (3,4,5)
13:32:26 <hyiltiz> > take 5 $ nub [(x,y,z) | a<-[1..], x <- [1..a], y <- [x..a], z <- [y..a], x*x+y*y == z*z]
13:32:27 <fog> now what are you doing?
13:32:28 <lambdabot>  [(3,4,5),(6,8,10),(5,12,13),(9,12,15),(8,15,17)]
13:32:37 <int-e> jle`: you don't get partial outputs from timeouts
13:32:50 <jle`> > show $ nub [(x,y,z) | a<-[1..], x <- [1..a], y <- [x..a], z <- [y..a], x*x+y*y == z*z]
13:32:56 <lambdabot>  mueval-core: Time limit exceeded
13:33:07 <hyiltiz> > show [1..]
13:33:09 <lambdabot>  "[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
13:33:20 <ski> > [(x,y,z) | z <- [1 ..], y <- [1 .. z], x <- [1 .. y], x*x+y*y == z*z]
13:33:22 <lambdabot>  [(3,4,5),(6,8,10),(5,12,13),(9,12,15),(8,15,17),(12,16,20),(15,20,25),(7,24,...
13:33:23 <fog> i dont think your going to get the block that way
13:33:33 <jle`> big brain
13:33:46 <fog> needs more cubits! 
13:33:51 <int-e> > take 5 $ [(x,y,z) | z <- [1..], x <- [1..z], y <- [x..z], x^2 + y^2 == z^2]
13:33:53 <lambdabot>  [(3,4,5),(6,8,10),(5,12,13),(9,12,15),(8,15,17)]
13:34:24 <int-e> > [(x,y,z) | z <- [1..], x <- [1..z], y <- [x..z], x^2 + y^2 == z^2]
13:34:27 <lambdabot>  [(3,4,5),(6,8,10),(5,12,13),(9,12,15),(8,15,17),(12,16,20),(7,24,25),(15,20,...
13:34:36 <hololeap> i still don't understand `let x = [< "ATCG" >]`
13:34:56 <hololeap> what does that mean?
13:35:03 <jle`> oh i didn't see that one before
13:35:14 <int-e> Some joke about DNA splices?
13:35:22 <ski> hyiltiz : `[< "ATCG" >]' is a side-effectful expression, of type `Char', with side-effect `[]'
13:35:33 <ski> er, hololeap ^
13:35:35 <int-e> "is"
13:35:40 <ski> it's not Haskell
13:35:44 <hyiltiz> how is that different from []
13:35:45 <int-e> what is it?
13:35:45 <hyiltiz> Bleh
13:35:51 <hololeap> oh, it's not haskell...
13:35:53 <hyiltiz> not haskell!?
13:36:01 <hyiltiz> troll
13:36:10 <ski> (at least not currently, i guess)
13:36:14 <fog> ah, the ol' genetic dictionaries for sufficient statistics with gradient free relaxation problem again...
13:37:32 <fog> cant you just do sparse pooling on the mean convergence given per-parameter-weight learning rates?
13:37:49 <fog> aka "neuronal happyness" 
13:38:51 <fog> like, you have better sparse support using wavelets than pixel values, so i dont see why you would want orthogonal gradients
13:39:07 <fog> "vaguely in that direction" 
13:40:19 <fog> i think its something like if you have many random vectors and if you cant calculate the distance between all of them, but you can get bounds using the triangle inequality along the shortest path
13:40:43 <fog> so you just take many random projections, and then your just doing monte carlo again
13:41:00 <fog> (for jle's "big brain")
13:41:38 <fog> doing as much as possible to avoid backprop
13:41:55 <hololeap> totally
13:42:23 * hololeap does an air guitar riff
13:42:38 * maerwald starts moshing
13:42:44 <fog> i hope your modulating that through a pheasant 
13:43:36 <hololeap> hook up a guitar to a fowl? that would be some groovy tunes
13:44:29 <fog> basically you get the "features" at the autoencoder bottleneck, and you can cross the wires / neuronal edges to get the features to envelope each other 
13:45:09 <maerwald> you need to start a twitch stream about whatever it is you're usually talking about :p
13:45:25 <maerwald> maybe someone will be able to follow
13:45:36 <fog> now we are back to stochastic type theory again
13:46:13 <fog> oh! i was supposed to be asking about if anyone has an idea about how i can write a hetrogenous Cofree style tree...
13:47:23 <fog> (the ABC approach takes spherical contours of a gaussian in feature space to give contours over the input space)
13:48:36 <fog> i think its called "support vector clustering" 
13:49:26 <monochrom> "maybe someone will be able to follow" is exactly the rationalization for spamming.
13:49:33 <fog> https://www.jmlr.org/papers/volume2/horn01a/horn01a.pdf
13:49:56 <fog> im sure its not the most important mathematical discovery in history! 
13:50:10 <fog> "brukkaaaaakkk"
13:50:45 <monochrom> Instead, the correct antidote is https://www.smbc-comics.com/comic/app-3
13:51:31 <maerwald> I'm sure they mean well :)
13:52:26 <merijn> <3 SMBC
14:06:04 <monochrom> \‚à©/ ghcup knows 8.10.2
14:06:29 <jle`> \‚à™/
14:06:41 <jle`>  ... maybe /‚à™\
14:06:46 <monochrom> Actually why am I installing it? Should just wait until I need it. :)
14:07:01 <jle`> coward
14:07:04 <jle`> D:
14:07:41 <monochrom> My thesis is on eager and lazy evaluation, and my supervisor knows how to seize a pun opptorunity.
14:08:13 <jle`> :set -XStrict
14:11:16 * ski . o O ( "R√©sum√©" by Maria Kovalyova,Roman Cheplyaka in 2010-12-12 at <https://ro-che.info/ccc/11> )
14:11:20 <monochrom> We decided that Walter Guttmann https://www.canterbury.ac.nz/engineering/contact-us/people/walter-guttmann.html would be a good external examiner, he's doing related research.
14:12:05 <monochrom> My university declined on simply the ranking reason that he was not at a tenured rank yet.
14:13:02 <monochrom> So my supervisor wrote me an email to explain this situation with "Walter is, shall we say, eager to be your external examiner, but..."
14:13:23 <monochrom> 10 minutes later I finally realized "oh, 'eager', haha"
14:13:48 <jle`> heh heh
14:37:20 * hackage postgres-websockets 0.8.0.1 - Middleware to map LISTEN/NOTIFY messages to Websockets  https://hackage.haskell.org/package/postgres-websockets-0.8.0.1 (diogob)
15:17:32 <hyiltiz> Any recommended resources to prep for a job programming in haskell (for topics like machine learning, backend development etc.)?
15:23:32 <fog> hyiltiz: wait, do you have a job in haskell, or are you just planning on applying?
15:24:29 <fog> there was a haskell job going at tesla which looked pretty cool, it was something to do with "programming folklore" 
15:25:11 <hyiltiz> planning for applying
15:25:29 <fog> i guess they had some advice that haskell was a reasonably high level language with which to express some of the other programming languages intuitions 
15:26:06 <fog> hyilitiz: for any particular position, or yet to identify the job opportunities available?
15:26:42 <fog> like, if its a particular position, i guess you dont need to say on here incase all the other haskellers try and compete for that post!
15:27:03 <fog> i kind of thought there is about as many users of this chat as there are jobs in haskell, give or take one or 2
15:27:21 <ADG1089> hmm
15:28:01 <ADG1089> how effective have you guys seen bang pattern be for execution times? 
15:28:08 <fog> just asking because last time i checked the posts were all taken
15:28:33 <fog> ADG1089: normally its the difference between finite and infinite running time!
15:29:26 <ADG1089> well after trying to improve running times for something like this (link later) I reached from 700s to 344s, can i reach <60s ?
15:29:32 <ADG1089> link: https://github.com/adityagupta1089/Project-Euler-Haskell/blob/master/src/problems/Problem709.hs
15:29:43 <ADG1089> I used Vector instead of Array that helped a lot
15:30:15 <fog> hyilitiz: i had some tin-foil hat notion that if they actually paid any of us enough so that we could pay each other that we would take over the world
15:30:46 <fog> so they keep us all on peanuts and just extract the IP like the capitalist dogs they are
15:33:12 <fog> which is a shame, since i would quite like to be able to offer a bounty to anyone that can do my homework for me, since im not actually very good at doing it myself...
15:34:02 <fog> ADG1089: normally the advice is to compile using -o2, since then the compiler normally does about as much as it can to speed things up
15:34:32 <ADG1089> hmm, I'm using -O2 -fllvm
15:34:57 <fog> oh, cool. how much does llvm speed things up? do you have several cores?
15:35:04 <dmwit> ADG1089: You might be able to save some with strength reduction. e.g. div 2 -> shiftR 1, odd -> .&. 1
15:35:13 <fog> or is that just if your using the accelerate package...
15:35:23 <dmwit> Maybe llvm already does those, but GHC itself doesn't.
15:37:43 <fog> also i have the fear that if i dont solve the problems myself, that whichever company owns my consciousness will just allocate it less processing power - but im not sure if thats realistic 
15:39:38 <fog> oh god of haskell, so mighty and wise, how the hell do you write a hetrogenous cofree!? 
15:43:36 <dolio> Knowing project Euler, I would guess there's a better approach than dynamic programming to make it faster.
15:49:38 <monochrom> Micro-optimizations are usually ineffective in helping with PE. Mathematics is the most effective help.
15:53:50 * hackage blucontrol 0.2.1.0 - Configurable blue light filter  https://hackage.haskell.org/package/blucontrol-0.2.1.0 (jumper149)
15:54:50 <ADG1089> reduced to 41 secs
15:54:55 <ADG1089> i am satisfied with same dp
15:55:49 <ADG1089> 8x speedup
15:59:16 <ADG1089> removed Data.Modular and expanded all applications of mod for Z/1020202009
15:59:28 <ADG1089> and used Vector.Unboxed in nested array
16:12:44 <hyiltiz> fog: no specific position yet; just getting myself to be competitive first
16:36:55 <hyiltiz> is there a way to decorate `head` s.t. it becomes `[a] -> Maybe a`?
16:37:22 <dolio> Just don't use head.
16:37:32 <DigitalKiwi> write headMaybe/headSafe
16:38:01 <hyiltiz> I see that; I am wondering if there is a principled way to construct safe functions out of unsafe ones
16:38:13 <dolio> Or better yet, don't use that function at all, because you don't need to turn a list into a maybe to look at the first element.
16:38:13 <hyiltiz> aka a transformation from [] monad to Maybe
16:38:23 <DigitalKiwi>   headMay :: [a] -> Maybe a
16:38:23 <DigitalKiwi>   headMay [] = Nothing
16:38:24 <DigitalKiwi>   headMay (x:xs) = Just x
16:39:07 <hyiltiz> yes; I could implement headMay myself too. What I am asking is a automated way to do so (when possible)
16:39:18 <monochrom> There is none.
16:39:24 <hyiltiz> Some kinda "natural transformation" from a Monad to another
16:39:30 <DigitalKiwi> https://hackage.haskell.org/package/safe if there are a lot you want
16:39:39 <monochrom> All natural transformations are hand-written.
16:39:55 <hyiltiz> ^ is that a theorem?
16:40:16 <monochrom> Yes.
16:40:23 <hyiltiz> If it is natural "enough", surely it can be "solved" given a monad 1 and monad 2?
16:43:37 <monochrom> @quote monochrom safeFromJust
16:43:37 <lambdabot> monochrom says: I use safeFromJust :: Maybe a -> Maybe a
16:44:01 <DigitalKiwi> snort
16:44:43 <hpc> the real punchline is when safeFromJust = unsafeCoerce for optimization purposes
16:45:06 <monochrom> That's my position statement. Sometimes, head is fine, fromJust is fine. Other times, they are the totally wrong tools, safe or partial.
16:45:25 <monochrom> Oh, I have something like that, too.
16:45:32 <monochrom> @quote monochrom unsafeCoerce
16:45:33 <lambdabot> monochrom says: isTrue = (unsafeCoerce :: Either a b -> Bool) . (unsafeCoerce :: Maybe c -> Either a b) . (unsafeCoerce :: Bool -> Maybe c)
16:46:52 <dolio> Segfaults really fast.
16:50:55 <koz_> What's the append-and-concat-friendly list again? Seq?
16:51:39 <Axman6> yep
16:51:41 <monochrom> [] is friendly to both append and concat already.
16:51:55 <monochrom> err nevermind, prepend
16:51:55 <koz_> monochrom: O(n) concat isn't 'friendly'.
16:52:24 <monochrom> A mirror image of [] is friendly to append and concat
16:52:39 <koz_> monochrom: What's a 'mirror image of []'?
16:52:53 <hyiltiz> LOL ^
16:53:07 <hyiltiz> Too teasy
16:53:08 <monochrom> data SnocList a = Nil | Snoc (SnocList a) a
16:53:08 <koz_> hyiltiz: ??
16:53:19 <koz_> monochrom: Ah that one.
16:53:25 <hyiltiz> [19:53] <monochrom> A mirror image of [] is friendly to append and concat
16:53:28 <monochrom> The name "snoc" comes from reversing "cons"
16:53:48 <hyiltiz> Cannot hold back the grin
16:53:53 <koz_> monochrom: I'm aware. Because linguistic jokes are as much a part of Haskell as the Monad.
16:54:00 <monochrom> You need like friendly to append, prepend, and maybe also random access to warrant Seq
16:54:34 <monochrom> Nah I think the snoc idea predates Haskell
16:55:19 <hyiltiz> Are fingertrees (Data.Sequence) used frequently in real world applications?
16:55:39 <monochrom> Then again maybe "predate" doesn't matter. snoc was invented by some functional people, and the functional world was small, they would influence Haskell even if not directly Haskell people.
16:56:45 <koz_> (><) is best operator.
16:56:53 <koz_> (I guess it's pronounced 'wince'?)
16:56:56 <Axman6> >_<
16:57:09 <monochrom> >_< would be ideal, but illegal
16:57:23 <Axman6> need moar mixfix
16:57:51 <monochrom> No this goes beyond mixfix, at least for me.
16:58:32 <Axman6> so Agda wouldn't allow you to define > _ < ?
16:58:55 <hyiltiz> Should be possible if not using underscore but done UTF alternative though 
16:59:34 <monochrom> I want absolutely fully hand-annotatable tokenization. I want to tell the computer I consider >_< to be an infix operator, call-with-current-continuation to be one single identifier token, etc. I don't want stupid simplistic "identifier cannot have -" rules.
17:00:24 <Axman6> We have RULES in this HOUSE for a REASON!
17:00:29 <monochrom> Hrm, you're right, Unicode offers many ways out.
17:02:12 <ski> `/\/' is nice
17:02:56 <hyiltiz> Does that stand for N?
17:03:59 <ski> no
17:05:56 <MarcelineVQ> Axman6: fwiw you can define >_< in agda, and use of it would indeed be in the form of "> _‚Äã <"
17:06:53 <ski> @let infix 5 /\/; (/\/) :: [a] -> [a] -> [a]; [    ] /\/ ys =      ys; (x:xs) /\/ ys = x : (ys /\/ xs)
17:06:55 <lambdabot>  Defined.
17:07:01 <ski> > [0,2 .. 8] /\/ [9,7 .. 1]
17:07:03 <lambdabot>  [0,9,2,7,4,5,6,3,8,1]
17:07:47 <ski> > let abacaba = repeat 0 /\/ map (1 +) abacaba in abacaba
17:07:49 <lambdabot>  [0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1...
17:08:01 <MarcelineVQ> ahh, someone tipped your Z over
17:08:53 <monochrom> That one is like one of those nightmarish transcendental numbers.
17:14:22 <ski> > map (fst . until (odd . snd) ((1 +) *** (`div` 2)) . (0,)) [1 ..]
17:14:24 <lambdabot>  [0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1...
17:16:06 <ski> > let ones = 0 : tail (ones /\/ map (1 +) ones) in ones
17:16:08 <lambdabot>  [0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,1,2,2,3,2,3...
17:16:17 <ski> > map popCount [0 ..]
17:16:19 <lambdabot>  [0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,1,2,2,3,2,3...
17:16:45 <Axman6> :o
17:16:49 * hackage compact-sequences 0.1.0.0 - Stacks and queues with compact representations.  https://hackage.haskell.org/package/compact-sequences-0.1.0.0 (dfeuer)
17:17:46 <ski> (one could probably use `unamb' or something ..)
17:18:39 <int-e> . o O ( overambitious choice )
17:21:18 <monochrom> Yeah! If we take any typical denotational semantics CPO and just declare we add top, that really is an overambitious choice. :)
17:28:54 <hololeap> i'm having a hard time figuring out how to approach this problem. can anyone point me in the right direction?
17:28:57 <hololeap> https://www.hackerrank.com/rest/contests/master/challenges/mango/download_pdf?language=English
17:30:10 <hololeap> i discovered linear programming, but i can't figure out a way to fit this problem into the standard form
17:31:39 <ski> @let withHead :: Eq a => a -> [a] -> [a]; withHead x0 ~(x1:((x0 == x1,) -> (True,xs))) = x0:xs
17:31:41 <lambdabot>  Defined.
17:31:55 <ski> > let ones = withHead 0 (ones /\/ map (1 +) ones) in ones
17:31:57 <lambdabot>  [0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,1,2,2,3,2,3...
17:32:24 <ski> (or `withHead x0 ~(x1:xs) = x0 : case () of () | x0 == x1 -> xs')
17:39:22 <monochrom> hololeap: Add N unknowns c[1], ... c[N]. 0 <= c[i] <= 1, c[i] integer. c[i]=0 means friend #i doesn't come, c[i]=1 means friend #i comes.  Add one more unknown k and equation k = c[1] + ... + c[i]
17:40:27 <monochrom> Add constraint Sum{i=1 to N} c[i]*(a[i] + k*h[i]) <= M
17:40:35 <monochrom> OK I guess that's not linear.
17:41:45 <Axman6> feels like the knapsack problem?
17:42:38 <monochrom> But if you say, you hardwire k=3 and see how to solve for c[i]'s, that's linear again. :)
17:52:00 <monochrom> My current thinking is you don't want to make it a 0-1 integer programming in the way I said. It's NP-complete and you're looking at N = 10^4.
17:55:39 <monochrom> However, a Œò(N^2) algorithm is reasonable for that size of N.
17:56:51 <monochrom> Although, so far my solution is N^2 * lg N
17:57:59 <hololeap> ok, so it shouldn't be solved as a linear programming problem then
17:59:05 <hololeap> i'm less concerned with coming up with an ad-hoc solution and more interested in how to generalize this problem
18:32:09 <hyiltiz> ski: how would you implement skipping with that /\/? Skipping: https://youtu.be/kG6O4N3wxf8?t=6
18:36:06 <ski> skipping ?
18:38:35 <hyiltiz> Yeah, walkin' n jumpin' like that vid.
18:41:29 <ski> dunno what that would mean
18:50:14 <hyiltiz> nvm it looks like it is just `concatMap (replicate 2) [1..]`
18:50:36 <hyiltiz> somehow skipping felt like a much more complicated rythm
19:18:52 <kraeXen> how might I take a splice of type [Char] at the first occurence of an arbitrary Char?
19:19:16 <kraeXen> "abcd" 'c' -> "ab"
19:20:10 <ski> > takeWhile (/= 'c') "abcd"
19:20:12 <lambdabot>  "ab"
19:20:37 <kraeXen> thx
19:20:54 <ski> np
19:32:05 <dmwit> and see also
19:32:15 <dmwit> > span (/= 'c') "abcd"
19:32:17 <lambdabot>  ("ab","cd")
19:32:27 <dmwit> > break (== 'c') "abcd"
19:32:29 <lambdabot>  ("ab","cd")
19:33:30 <dmwit> > splitOn "c" "abcd"
19:33:32 <lambdabot>  ["ab","d"]
19:36:13 <kraeXen> v nice
20:05:45 <kraeXen> How might I take [1, 2, 3, 4] and (dynamically) convert it into [1 <||> 2 <||> 3 <||> 4]?
20:10:52 <monochrom> What is <||>?  Why isn't the whole thing simply  1 <||> 2 <||> 3 <||> 4 ?
20:11:01 <monochrom> Generally what does the question mean?
20:31:04 <fog> earlier i was asking about HCofree, and gave a description of how Cofree can be understood, but this was said to be oversimplistic by focusing on when the argument `f' is a functor. 
20:31:59 <fog> the alternative explanation was of Cofree in terms of terminal objects, and "coinductive" data, somehow dual to initial objects whis is apparently how to think about Free
20:32:06 <fog> i dont understand these ideas
20:33:28 <fog> the intuition of Cofree by analogy to a tree with data at the branches instead of the nodes seems understandable, but the more abstract version preferred by proponents of category theory, and technical accuracy - are baffling   
20:33:42 <fog> where is the middle ground?
20:34:23 <fog> is there a way to reconcile the ideas of the functoresque version with the categorical stuff? 
20:34:59 <fog> can trees with data at the branch points instead of the leafs be a way to understand the coindictive interpretation?
20:35:06 <fog> coinductive*
20:36:00 <fog> i cant see how they are similar at all, yet they are supposed to be the same thing; Cofree
20:37:10 <fog> this seems similar to how i have seen monads taught - or rather, not taught. with commentary like "they are kind of complicated, and if i try and give you a simple way of understanding them it would get you in the habit of thinking about them wrong"
20:38:20 <fog> so instead of saying, they are things that can be flattened using join, and initialised with return, people say things like "they are monoids in the category of endofunctors, whats the problem" which seems like a way of communicating a problem, rather than an explanation of monoids
20:38:23 <fog> monads*
20:39:55 <fog> maybe as category theory concepts, Free, which seems deeply connected to Monads, and CoFree, similarly to CoMonads are equally steeped in mysticism - needlessly, since simple examples are helpful.
20:40:15 <fog> the counterargument is then "helpful in a way that is limiting", which i get
20:40:39 <fog> but then, how can we get at the good use, that the simple example doesnt capture
20:41:01 <fog> whats an example of Cofree not using Functors, that better expresses this "dataflow" stype of thinking
20:41:14 <kraeXen> monochrom, how do I apply an operator dynamically to a tuple's contents?
20:41:18 <fog> like the Moggi paper on monads...
20:41:21 <kraeXen> as one final expression
20:41:35 <ski> that "monoids" one is a joke
20:41:44 <ski> (and also correct)
20:42:01 <fog> which one?
20:42:10 <ski> the Wadler one
20:42:16 <fog> oh the endofunctors
20:42:33 <fog> what, the wadler paper "theorems for free" ? 
20:42:41 <fog> im confused now
20:42:58 <fog> is the monoids in the category of endofunctors also due to Wadler?
20:43:28 <fog> im not sure what your saying...
20:43:55 <ski> kraeXen : you might be looking for `foldr1' or `foldl1', or perhaps some related thing
20:44:07 <ski> yes, that one is also Wadler
20:44:22 <fog> what im saying is i know the categorical discriptions are technically "correct" but they do not communicate the utility well
20:45:05 <fog> but are advocated for over more directly usable descriptions, because by their incomprehensibility, do not produce biased interpretation in the audience 
20:45:25 <ski> @quote a.monoid.in.the.category.of.endofunctors
20:45:25 <lambdabot> wadler says: A monad is a monoid in the category of endofunctors, what's the problem?
20:45:41 <fog> right, im describing the problem
20:45:53 <c_wraith> there's also the fact that comonads are just rather...  limited.  there aren't that many useful instances.
20:46:01 <fog> lists!
20:46:05 <c_wraith> not a comonad
20:46:09 <fog> oh
20:46:14 <fog> i thought it was Cofree Maybe
20:46:20 <dolio> Only infinitely many.
20:46:21 <fog> oh, comonad, sorry i misread
20:46:23 <ski> i'm not sure what more directly usable descriptions you have in mind
20:46:35 <fog> um, nonempty
20:46:48 <fog> er, Free Nonempty 
20:47:03 <c_wraith> Cofree Maybe is NonEmpty, give or take some bottoms, yes.
20:47:12 <fog> and its a comonad
20:47:43 <fog> its more useful to make trees from nonempty
20:47:58 <fog> Free Nonempty = Tree is probably one of the most useful things ever
20:48:42 <fog> but nonempty is not exactly capturing the "final object" or whatever it is that is its category theory description
20:49:17 <ski> trying to learn about the general monad concept before learning about particular instances is a bit like trying to learn about monoids,groups,rings, before learning about natural numbers, integers, rationals, reals, polynomials, matrices, say
20:49:54 <fog> Free [] has the pottential for empty leafs as empty-list, instead of forcing the use of the End constructor of Free like using nonempty does 
20:50:24 <ski> you need to know more about a monad instance, than it being a monad, to be able to do anything useful with it
20:50:57 <fog> ski: but i have seen haskell lectures where a student asks about monads and the teacher just deffers answering since their is stigma about presenting simple examples such as Trees
20:51:28 <fog> and before when i was trying to describe cofree it was commented that i was presenting a biased interpretation, by focusing on Cofree Functors
20:51:49 <fog> which do not comunicate the dataflow interpretation
20:51:59 <fog> i was wondering if there was a better example, which does
20:52:36 <ski> i don't see what you don't like about `Free []'
20:52:49 <fog> as a representation of Tree?
20:52:58 <ski> having no children doesn't have to be taken as being a leaf
20:53:30 <fog> its then giving the possibility to have "shaped empty trees"
20:54:01 <fog> when i was working with "structure directing indices" i wanted an unambiguous empty constructor which did not take a shape argument
20:54:10 <ski> if you consider `flatten :: Tree a -> [a]' as collecting the `a' solutions (stored in the leaves) in a list, then a (non-leaf / internal) node with no children corresponds to a failing subcomputation, that fails to produce any solutions
20:54:51 <ski> sometimes you might not want to allow that. but sometimes you do
20:55:28 <fog> i was using a class Empty for a while, but then just used Set that could take a Nothing argument
20:55:54 <fog> you get a different type of fold that is dual to unfold then
20:56:17 <fog> where the basecase is the being able to produce the folding functions output from a nothing input
20:56:20 <fog> :t unfold
20:56:21 <lambdabot> error:
20:56:21 <lambdabot>     ‚Ä¢ Variable not in scope: unfold
20:56:21 <lambdabot>     ‚Ä¢ Perhaps you meant one of these:
20:56:24 <fog> r:t unfold
20:56:27 <fog> :t unfoldr
20:56:28 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
20:56:34 <fog> :t foldr
20:56:34 <ski> dunno what you mean by "shaped empty trees", nor "unambiguous empty constructor which did not take a shape argument"
20:56:35 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
20:57:16 <fog> foldr' :: Foldable t => (Maybe (a,b) -> b) -> t a -> b 
20:57:41 <fog> so i have Nothing -> b
20:58:08 <fog> instead of providing b as a seperate argument
20:58:24 <fog> :t (:)
20:58:25 <lambdabot> a -> [a] -> [a]
20:58:52 <fog> set Nothing = []
20:59:09 <ski> not seeing how this is relevant to what you talked about just before
20:59:32 <fog> well, the "structure directing index" would be seti instead of set, with `i' being this index
20:59:35 <ski> that  foldr'  just looks like a variant of the usual  foldr
20:59:51 <fog> i want a "shapeless empty"
21:00:05 <fog> otherwise i have to use; seti (i,Nothing)
21:00:38 <fog> to create these shaped empty trees, that have no values, but some branches of branches nested recursively and all ending in empty-list
21:01:33 <fog> ski: the point of mentioning that rewriting of the type of fold to be dual to that of unfold, is to get a better type for set and get to be dual
21:01:37 <fog> and so you can fold with set
21:01:54 <fog> then the case that takes a Nothing is the Empty
21:02:22 <fog> :t foldr (:) []
21:02:24 <lambdabot> Foldable t => t a -> [a]
21:03:15 <fog> instance Set [] where set Nothing = []; set (Just (x,xs)) = x:xs
21:04:05 <ski> @type (uncurry . flip) (foldr . curry) . (($ Nothing) &&& (. Just))
21:04:06 <lambdabot> Foldable t => (Maybe (a1, a2) -> a2) -> t a1 -> a2
21:04:12 <fog> im just saying that if i have Tree as Free Nonempty, then i dont have any Empty, so i avoid this issue of "shaped empty"
21:05:02 <fog> :t (&&&)
21:05:04 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
21:05:08 <fog> !?
21:05:12 <fog> madness....
21:05:19 <ski> @type \f g x -> (f &&& g) x
21:05:20 <lambdabot> (t -> c) -> (t -> c') -> t -> (c, c')
21:05:28 <fog> oof
21:06:03 <ski> @type ($ Nothing) &&& (. Just)
21:06:04 <lambdabot> (Maybe a -> c) -> (c, a -> c)
21:06:33 <ski> (that example is pointless, though)
21:07:01 <fog> ah, it typechecks in my mind now
21:07:15 <fog> anyway...
21:07:25 <fog> what about this Cofree thats not Nonempty
21:07:40 <fog> or, that isnt functor oriented
21:08:24 <fog> all of my favourite one parameter datatypes are "containers" that are functors...
21:08:48 <fog> i cant see "what im missing" by presenting examples of cofree that use them
21:09:01 <ski> still dunno what you mean by "shapeless empty" or "shaped empty trees". and i can't recall what the purpose of your `Set' was exactly .. (and i'm not sure it'd really help if you tried to explain)
21:09:21 <fog> and then, also, dont understand the use of Cofree in dataflow processing, or whatever it is the categorical approach is supposed to be getting at
21:09:42 <fog> [[[[]]],[[],[]]]
21:09:49 <fog> shaped empty tree^
21:09:56 <ski> (but i get that for some reason, in the trees you're considering, you don't want internal nodes with no children)
21:10:05 <fog> sprinkle some Free constructors over that
21:10:35 <fog> yes, Free Nonempty has no Empty at all...
21:11:02 <fog> so no "structure directing index" for the seti which takes Nothing 
21:11:09 <fog> well, no seti which takes nothing at all
21:11:14 <fog> it always needs a value
21:11:30 <fog> and the only structure it can have is some depth of nesting
21:11:48 <fog> like seti (3,"hello") = [[["hello"]]]
21:12:23 <fog> where really you should be using Nat, as a monoid under (+) 
21:12:30 <fog> then with; 
21:12:44 <fog> seti (mempty,x) = return x
21:13:16 <ski> "i cant see \"what im missing\" by presenting examples of cofree that use them" -- perhaps you're referring to the earlier comment, by someone, that was about how the terms "free" and "cofree" are more general than `Free' and `Cofree', as in the `free' package, which are specifically for the free monad, respectively the cofree comonad, on a given functor ?
21:13:38 <fog> perhaps
21:13:57 <fog> but because im not sure i understood what they were saying, i cant be sure if thats what they meant
21:14:37 <ski> (it seemed like perhaps you didn't pick up that that was what was meant)
21:14:38 <fog> i guess i could be clutching at straws to invoke the idea of monads as dataflow ala moggi, as opposed to just nested lists
21:15:32 <fog> hmm, so then, whats the difference between haskell Free, for Free Monads, and Cofree, for Cofree Comonads, and the "real" free & cofree
21:16:21 <fog> but (>>=) vs join, as the fundamental Monad thing, seems to capture, dataflow vs flattening, as the fundamental monadic thing
21:16:58 <fog> i guess there is something similar with cofree in terms of cojoin vs extend
21:17:04 <fog> % :t duplicate
21:17:04 <yahb> fog: Comonad w => w a -> w (w a)
21:17:11 <fog> % :t extend
21:17:11 <yahb> fog: Comonad w => (w a -> b) -> w a -> w b
21:17:17 <ski> monads in general (even in Haskell), is not about nested lists
21:17:42 <fog> right, so im not sure the point nesacarily *is* to do with free & cofree beyond the realms of haskell
21:18:19 <fog> but then i dont really get what is meant by the final vs inital objects idea
21:18:33 <ski> the `Free' and `Cofree' in that package might have been named `FreeMonad' and `CofreeComonad'. or maybe even `FreeMonadOnFunctor' and `CofreeComonadOnFunctor' .. but those're a bit longwinded names
21:19:48 <fog> 09:16:48 <dolio> Because you are specifically describing the free monad on a functor, and the cofree comonad on a functor, and 'free' and 'cofree' are only part of that, and more general terms.
21:20:07 <ski> you can not just have a free monad on a functor. you can have a free abelian group on a set. a free abelian group on a group, a free vector space on a set. a free subgroup on a subset of a group. a free partial order on a set. a free partial order on a preorder. a free graph on a set. ...
21:20:11 <fog> 09:21:21 <jle`> alehander92: there's two aspects you might be conflating there too, Cofree the data type (which is just a normal ADT like any other), and this 'cofree style' you are talking about, which i'm not sure what it means
21:20:19 <fog> 09:21:41 <dolio> 'Free' in general means something analogous to 'inductively generated,' or 'initial', while 'cofree' is coinductive or final.
21:20:26 <ski> lots of different "free" things. similarly with "cofree"
21:20:44 <fog> so basically its about inductively or coinductively generated data
21:21:05 <fog> which it seems that the tree based descriptions miss 
21:21:08 <c_wraith> any attempt to be reductive rather than examining definitions is going to lead you wrong.
21:21:17 <fog> but im not sure if thats whats captured by (>>=) and extend
21:22:15 <ski> no idea what "the tree based descriptions" refer to
21:22:32 <fog> Tree = Free (Cofree Maybe)
21:22:48 <ski> i'm mostly attempting to dispell some possibly misconceptions that it seemed you were having ..
21:23:29 <fog> basically, the "tree idea" of monads is about join over Nonempty being concat
21:23:31 <ski> if you're interested in learning what "free" and "cofree" (the general terms) mean in CT, you should probably take a look at some CT book(s)
21:23:47 <fog> so then you get "flattening trees" intuition for what monads are 
21:24:20 <fog> no im not interested at all in learning the CT approach. there is seemingly no motivation for doing so
21:24:39 <fog> im asking for that motivation in the form of an example that is not like this tree idea
21:24:53 <c_wraith> But why?
21:25:23 <fog> because otherwise i see no reason *not* to teach these apparently misleading and biased, yet intuitive and useful approaches
21:25:46 <c_wraith> Odd that you call them useful, given what I've seen so far.
21:25:48 <fog> i guess when you had that arrow over the Reader monad, which is a good example of a Monad which is not "list like" in how it is joined
21:26:01 <fog> and fits better with the kliesli composition (.)
21:26:01 <ski> "join over Nonempty being concat" seems to be about some specific monad, not about monads in general. so i can only assume that your "\"tree idea\" of monads" is also not about monads in general, but only about some quite specific cases
21:26:21 <fog> exactly
21:26:40 <fog> hence why it is discouraged as a way of teaching monads, by this particularly ubiquitous monad
21:26:53 <fog> as it is essentially limiting the notion of the capability of monads
21:26:57 <ski> "no im not interested at all in learning the CT approach. there is seemingly no motivation for doing so" -- that's fine
21:27:17 <c_wraith> data Store s a = Store s (s -> a) -- this forms a comonad.  where's the tree?
21:27:43 <fog> you shouldnt imply that i claimed all monads or comonads were tree like
21:28:09 <fog> but yes, this is as good an example as Reader is for a non-list monad
21:28:10 <fog> thanks
21:28:38 <fog> so, if Reader is *particularly* good, since it is compositional in a dataflow sense by kliesli (.)
21:28:51 <fog> is Store similar in terms of cokliesli composition somehow?
21:29:26 <ski> dunno what "compositional in a dataflow sense" means
21:30:42 <ski> and why would you say your tree monad(s ?) is(/are) particularly ubiquitous ?
21:30:49 <fog> % :t (>=>)
21:30:49 <yahb> fog: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
21:31:00 <fog> % :t (<=<)
21:31:00 <yahb> fog: Monad m => (b -> m c) -> (a -> m b) -> a -> m c
21:31:13 <fog> hmm, whats the dual of the klieli arrow?
21:32:10 <fog> well, because the first thing we learn in haskell is lists. the reason for that is the languages key feature is lazyness, as a way to present proofs by induction as a style of program implementation
21:32:24 <fog> we want recursive functions, so we start pattern matching on cons
21:32:48 <fog> we have map as functors over list as a first thing, and soon start using concatMap
21:33:02 <fog> then we have our first encounter with join
21:33:39 <fog> similarly, if lists are almost nonempty, and thats the archetypal cofree datatype, similarly, our intuition of lists forms our intuition of cofree
21:34:15 <ski> @type \g f -> g . (=>> f)
21:34:16 <lambdabot> Comonad w => (w b -> c) -> (w a -> b) -> w a -> c
21:35:30 <fog> thanks
21:35:54 <fog> i find somthing similar to the discussion here; https://arxiv.org/abs/1402.1051
21:36:02 <fog> Breaking a monad-comonad symmetry between computational effects
21:36:12 <fog> it mentions State vs Exception as good examples
21:36:24 <ski> i don't see what lazyness (which is not a language feature, btw) has particularly to do with lists. nor what the connection between lazyness to induction is you're thinking of
21:36:29 <fog> how do i write that (.) = (>=>)
21:36:40 <fog> and then (?) = (=>>)
21:37:23 <fog> your right, we can have recursion in strict languages, my bad
21:37:25 <DigitalKiwi> ski: is lazyness a misfeature or do you just mean the feature is non-strict of which lazyness is a way to do that and happens to be what is used
21:37:53 <ski> i don't follow "lists are [..] the archetypal cofree datatype", nor "our intuition of lists forms our intuition of cofree"
21:38:33 <fog> well you soon enough start trying to see if you can write list using Free
21:38:37 <DigitalKiwi> what are other ways to implement non-strictness than lazyness
21:38:42 <fog> since it seems to capture recursive datatypes
21:39:10 <fog> and then discover that a whole nother family of datatypes exists, and that you need to use Cofree to write list
21:40:15 <dolio> You could do laziness without memoization.
21:40:19 <fog> whats (=>>) for Store?
21:40:29 <dolio> Or you could try some eager evaluation up front, but stop if it takes too long.
21:40:38 <fog> is it like (>=>) for reader?
21:41:04 <fog> does it capture coinductive dataflow, in the way that (>=>) = (.) for Reader captures Monadic dataflow?
21:41:33 <fog> and if Store isnt the correct thing, what comaond is?
21:41:40 <ski> @let infixr 1 <#<; g <#< f = g . (f <<=)  -- if you want to play with it
21:41:41 <fog> comonad*
21:41:41 <lambdabot>  Defined.
21:42:04 <fog> % :t (<#<)
21:42:04 <yahb> fog: ; <interactive>:1:1: error:; * Variable not in scope: <#<; * Perhaps you meant one of these: `<#' (imported from GHC.Prim), `<##' (imported from GHC.Prim), `<=<' (imported from Control.Monad)
21:42:09 <fog> :t (<#<)
21:42:11 <lambdabot> Comonad w => (w b -> c) -> (w a -> b) -> w a -> c
21:42:22 <fog> :t (<<=)
21:42:24 <lambdabot> Comonad w => (w a -> b) -> w a -> w b
21:42:33 <fog> ahh...
21:42:50 <fog> so wait, your using Reader again?
21:42:53 <ski> no
21:42:59 <fog> theres a (.) is all...
21:43:11 <ski> that's just ordinary function composition
21:44:03 <ski>   g <=< f = (g =<<) . f  -- note
21:44:06 <fog> woah, im not getting that at all...
21:44:13 <fog> ah, ok
21:45:27 <fog> hmm, i only mentioned <=< because i thought it was =>>, i didnt really need a backwards cokilesli arrow - just a cokliesli arrow
21:45:58 <fog> i think i want >#>
21:46:09 <ski> in that case, we get `a' as inout, which is transformed by `f' to `m b'. but `g' wants a `b' (not an `m b'), and will produce an `m c'. but since `g :: b -> m c', we have `(g =<<) :: m b -> m c', so that we can continue to feed the `m b' from `f' to `(g =<<)', getting an `m c' as output
21:47:43 <fog> @let (>#>) a b = b <#< a 
21:47:44 <lambdabot>  Defined.
21:47:51 <fog> :t (>#>)
21:47:53 <lambdabot> Comonad w => (w a -> b) -> (w b -> c) -> w a -> c
21:47:59 <fog> thats better
21:48:25 <fog> :t return >=> return
21:48:26 <lambdabot> Monad m => c -> m c
21:48:47 <fog> > ((return >=> return) 0) :: [Int]
21:48:49 <lambdabot>  [0]
21:49:09 <ski> similarly, in the cokleisli composition case, we want to get `c' as output, which we can get from `g', if we can feed it `w b' as input. but `f' doesn't produce a `w b' (but rather a `b'), from a `w a'. but since `f :: w a -> b', we have `(f <<=) :: w a -> w b', so that we it can produce the `w b' that `g' wants, from an initial input `w a'
21:49:46 <fog> :t extract
21:49:48 <lambdabot> Comonad w => w a -> a
21:50:00 <fog> :t (extract >#> extract)
21:50:02 <lambdabot> Comonad w => w c -> c
21:50:30 <fog> > (extract >#> extract) (0 :| [])
21:50:32 <lambdabot>  error:
21:50:32 <lambdabot>      ‚Ä¢ Data constructor not in scope: (:|) :: Integer -> [a0] -> w0 c
21:50:32 <lambdabot>      ‚Ä¢ Perhaps you meant one of these:
21:50:47 <fog> should give 0
21:51:31 <ski> DigitalKiwi : "do you just mean the feature is non-strict of which lazyness is a way to do that" -- yes
21:51:45 <ski> "(>=>) = (.) for Reader captures Monadic dataflow" -- dunno what this means
21:51:58 <fog> function composition
21:52:08 <fog> idk, what was moggi on about?
21:52:23 <fog> :t (>=>)
21:52:24 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
21:52:26 <fog> :t (.)
21:52:27 <lambdabot> (b -> c) -> (a -> b) -> a -> c
21:52:52 <fog> oh, wait thats kind of wrong, it doesnt have Reader the way i expected
21:52:55 <ski> for `Reader eho', `(>=>)' amounts to `(a -> rho -> b) -> (b -> rho -> c) -> (a -> rho -> c)'
21:52:57 <DigitalKiwi> ski: ok yay i am learning
21:53:11 <ski> perhaps you meant `Identity', rather than `Reader rho' ?
21:53:56 <fog> im not sure what i mean
21:54:24 <ski> (also note that `(.)' corresponds more to `(<=<)' (and also to `(<#<)', as defined above), rather than `(>=>)' (or `(>#>)'))
21:54:37 <ski> fog : maybe that's progress ?
21:54:55 <iqubic> :t (.)
21:54:56 <lambdabot> (b -> c) -> (a -> b) -> a -> c
21:55:01 <fog> im just going off of, if the list monad is a narrow idea of monadicness, and reader is better because then we get function compostion as monadic dataflow
21:55:04 <iqubic> :t (<=<)
21:55:05 <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
21:55:10 <fog> something then about the dual of that for comonads
21:55:16 <iqubic> :t (<#<)
21:55:17 <lambdabot> Comonad w => (w b -> c) -> (w a -> b) -> w a -> c
21:55:22 <fog> being better than just having nonempty as the idea of comonadicity 
21:55:50 <ski> fog : perhaps "reader is better because then we get function compostion as monadic dataflow" was based on a misconprehension ?
21:56:18 <fog> seems so, i had one too many arguments, like i thought it was (a -> b) when it was really (a -> rho -> b)
21:57:05 <fog> but anyway, the kliesli arrow seems to be doing what (.) does ok
21:57:11 <iqubic> Yes.
21:57:18 <fog> so i can understand how i can compose functions together to get programs
21:57:34 <fog> so maybe i can compose (>=>) together to get something like monadic dataflow
21:57:46 <fog> and then the same for (>#>)
21:57:54 <fog> and then there should be something like (.)
21:57:58 <fog> but for comonads
21:58:02 <fog> and something like reader
21:58:13 <fog> but scarmbled through my miscomprehension
21:58:14 <iqubic> "so i can understand how i can compose functions together to get programs" Isn't that like the central dogma of FP?
21:58:36 <iqubic> fog, If you want (.) for comonads, just use (<#<)
21:58:38 <fog> right, and thats what i thought the moggi idea was
21:58:55 <iqubic> moggi idea?
21:59:10 <fog> iqubic: no, just as (.) isnt (<=<), (?) isnt (<#<)
21:59:39 <iqubic> fog: It's very similar though.
21:59:43 <fog> and just as Reader doesnt monad like (.) ??? doesnt comonad like (?)
22:00:20 <fog> sorry, thats a pretty bad specification
22:00:44 <iqubic> https://hackage.haskell.org/package/category-extras-0.53.0/docs/Control-Comonad-Reader.html
22:00:45 <ski> fog : `(<=<)' for `Identity' amounts to `(.)'. `(<#<)', also for `Identity', also amounts to `(.)'
22:01:26 <ski> fog : anyway. it's been one and a half hour. perhaps if you want to continue the conversation, you could come over to #haskell-overflow .. as i think probably many other people would have trouble learning that much from the conversation at this point (i know i have trouble getting to what you seem to want to talk about) ?
22:01:28 <fog> % :t (<=<) @Identity 
22:01:28 <yahb> fog: (b -> Identity c) -> (a -> Identity b) -> a -> Identity c
22:01:42 <fog> thats not really (.)
22:01:50 <iqubic> except it is.
22:02:03 <ski> (if others want to read or comment at this point, they could also come other there ?)
22:02:42 <fog> yes, i think i have successfully communicated that i cant understand my question
22:02:53 <fog> what fantastic work
22:03:19 <iqubic> What is it that you want to know?
22:03:55 <fog> i wanted a thing that was a comonad, that was like how reader is a good learning monad
22:04:47 <iqubic> So what you want is a simple comonad that can teach you about how comonads work. Got it.
22:04:48 <fog> and that it could be shown why it can be used in teaching to give a better intuition about comonads than nonempty 
22:04:52 <Graypup_> i am having a confuse: I wrote a validator as a function returning an Aeson.Types.Internal.Parser, but I realized perhaps I shouldn't be exposing another library's internals, so I added a class constraint Monad m and put `m a` as my return type. My compiler is now complaining that it doesn't match?
22:05:16 <Graypup_> which, wat? Parser is a monad, right?
22:05:34 <fog> iqubic: thanks! i thought i was going sideways
22:05:58 <ski> > extract ("foo",42)
22:05:59 <ski> > extract ("foo",42)
22:06:00 <lambdabot>  42
22:06:01 <ski> > duplicate ("foo",42)
22:06:01 <lambdabot>  42
22:06:03 <lambdabot>  ("foo",("foo",42))
22:06:11 <iqubic> gra
22:06:16 <ski> fog : how about that comonad ?
22:07:05 <fog> erm
22:07:06 <ski> Graypup_ : putting a type variable in the signature means the whoever calls you, the caller, will pick/choose `m', not you
22:07:26 <fog> i think thats pretty much the same as nonempty though
22:07:58 <ski> fog : also, do you mind moving the discussion over to #haskell-overflow, if you want to continue ?
22:08:02 <fog> like how nesting lists is like nesting maybes, its the same intuition around monadic join
22:08:04 <Graypup_> ski, yeah I figured as much. as a rust person it's sorta analogous to making the function generic? whereas what I really want to do is return `impl Monad` to abuse some rust-speak
22:08:16 <iqubic> Graypup_: Using the Monad constraint there means that your code must work with ALL monads, and not just Parser
22:08:28 <ski> Graypup_ : yes, it's generic/polymorphic
22:08:29 <fog> ski: i think if its overflow time its bed time
22:08:36 <ski> ok, fog
22:08:48 <Graypup_> so how *would* I do it properly though?
22:09:12 <ski> and `(rho,)' isn't really like `Nonempty'
22:09:41 <fog> it gets more nestingyer
22:10:11 <iqubic> And they're gone.
22:11:10 <Graypup_> I don't want my return type to be polymorphic but I also don't want to write it ;-p
22:12:06 <Graypup_> here is the code in question: https://gist.github.com/lf-/ee12e4ff59a804e32f2179fdf3bbe9b3
22:12:25 <Graypup_> and perhaps I'm just doing the Wrong Thing and should instead make a higher order function of some sort? idk
22:14:29 <ski> "what I really want to do is return `impl Monad`" -- hm, did that correspond to having an existential return type ? (i forget. istr there was some subtlety somewhere around this stuff)
22:15:09 <Graypup_> ski, what that means in Rust land is that "I return some fixed type value that the compiler should infer the type of, that implements the trait Monad"
22:15:30 <Graypup_> as opposed to being polymorphic
22:15:54 <iqubic> Yeah, we don't have that in Haskell.
22:17:04 <ski> (what i was thinking about was some variant of using existentials, where the type was statically known. maybe that was for taking an `impl' (or some variant ?) as a parameter, though ?)
22:19:13 <iqubic> Graypup_:  I think you'll need to write out the type signature in full.
22:20:53 <ski> Graypup_ : hmm .. you could workaround it, by either making an "existential data type (constructor)", or (possibly slightly more attractive) doing the CPS existential encoding
22:21:05 <ski> .. but i'm not sure you'd really want to do either
22:21:33 <ski> but they'd work, to get the information-hiding in the interface that you want
22:21:56 <ski> hmm
22:22:51 <ski> actually, i wonder whether there's be a point to this. you'd need to have enough constraints on `m' to be able to do something useful with it, in the end ..
22:23:33 <Graypup_> yeah, I am just writing out the signature, it was mostly just a thought exercise
22:23:56 <ski> Graypup_ : how would you use the result of type `impl Monad' (or `impl Whatever'), in Rust ?
22:25:01 <ski> would the caller only know that it gets a value of a type that implements the trait ? or would the compiler actually allow the code of the caller to rely of the actual type chosen by the callee ?
22:26:47 <ski> (for other traits `Whatever', than `Monad', the former could be useful. for `Monad', not really)
22:28:57 <Graypup_> ski, e.g. with impl Read, the caller can only see the functions in the Read trait
22:29:21 <Graypup_> it's also useful for closures since closures have a concrete type that cannot be written
22:29:21 <ski> ok. so the former
22:30:16 <ski> mm. (something like `exists env. (# env , (# env , a #) -> b #)')
22:31:12 <ski> Graypup_ : do you have more contraints than `Monad m', that you'd like to express `m' as having, in the signature ?
22:32:20 <Graypup_> hm, well really I just wanted to write Parser without writing Parser, because I incorrectly thought it was not supposed to be part of the public interface of Aeson
22:33:49 <ski> <http://hackage.haskell.org/package/aeson-1.5.3.0/docs/Data-Aeson-Parser.html> mentions a `Parser' being defined in `attoparsec'. is that the one you're talking about ?
22:34:46 <Graypup_> appears to be defined in Data.Aeson.Types.Internal
22:35:06 <ski> hm, or i guess it may be <http://hackage.haskell.org/package/aeson-1.5.3.0/docs/Data-Aeson-Types.html#t:Parser>
22:35:19 <Graypup_> yeah it's that, I just had the wrong import and got real confused hehe
22:35:55 <ski> well, it looks like it's exported by `Data.Aeson.Types'
23:35:49 * hackage monad-logger 0.3.35 - A class of monads which can log messages.  https://hackage.haskell.org/package/monad-logger-0.3.35 (MichaelSnoyman)
23:43:32 <dminuoso> The GHC manual states: Note that you do not need -threaded in order to use concurrency; the single-threaded runtime supports concurrency between Haskell threads just fine.
23:43:58 <dminuoso> Im currently using a conduit library that only properly works if -threaded is enabled, and I'd like to understand why.
23:44:28 <dminuoso> (The library itself makes use of forkIOWithUnmask)
23:44:37 <dminuoso> Specifically to run `process` with
23:44:51 <dminuoso> Is that a foreign call?
23:54:12 <dminuoso> I suppose it is. Mmm
