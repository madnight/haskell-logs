00:17:45 * hackage depq 0.1.0.0 - Double-ended priority queues  https://hackage.haskell.org/package/depq-0.1.0.0 (ocramz)
00:31:45 * hackage depq 0.2.0.0 - Double-ended priority queues  https://hackage.haskell.org/package/depq-0.2.0.0 (ocramz)
00:32:23 <gcoakes[m]> Hmm. Multiple minor patches within a couple hours?
01:07:15 * hackage depq 0.3.0.0 - Double-ended priority queues  https://hackage.haskell.org/package/depq-0.3.0.0 (ocramz)
01:20:45 * hackage simple-cabal 0.1.2 - Cabal file wrapper library  https://hackage.haskell.org/package/simple-cabal-0.1.2 (JensPetersen)
02:36:15 * hackage speedy-slice 0.3.1 - Speedy slice sampling.  https://hackage.haskell.org/package/speedy-slice-0.3.1 (JaredTobin)
03:21:54 <Orbstheorem> Why is FlexibleContexts not turned on by default? Is there a usecase where FlexibleContexts is undesirable?
03:22:22 <Orbstheorem> Or is it because it is not part of the Haskell report?
03:24:24 <merijn> Orbstheorem: It's not in the report
03:24:44 <merijn> Orbstheorem: And by default GHC tries to (mostly) adhere to the report
03:24:53 <Orbstheorem> Thanks!
03:25:29 <Orbstheorem> How does upstreaming extensions to the report works?
03:25:42 <merijn> Honestly, at this point in time "not"
03:26:16 <merijn> There was another Haskell Prime committee for 2020, but it seems to have fizzled out
04:03:45 * hackage squares 0.0.1 - The double category of Hask functors and profunctors  https://hackage.haskell.org/package/squares-0.0.1 (SjoerdVisscher)
04:24:47 <absence> streaming libraries like streaming, pipes, conduit, etc. are usually implemented as monad transformers. has anyone attempted to do streaming with tagless final encoding (mtl style) instead?
04:29:37 <merijn> My gut instinct says that there's no way to get that to perform well
04:34:37 <Rembane> merijn: Can you elaborate a bit?
04:34:41 <absence> merijn: i thought mtl-style code was considered quite fast, but maybe that's just when comparing to other effect systems, or assuming a one-layer moand "stack"?
04:35:25 <merijn> absence: mtl code doesn't have a speed, its "typeclasses calling into various transformer stackings" and the performance of unknown monad stacks like that is quite bad
04:35:40 <wavemode_> "perform well" is relative, no?
04:35:53 <merijn> wavemode_: Comparable to conduit/pipes
04:36:18 <Rembane> IIRC mtl-style is slower than using the transformers package. 
04:36:29 <Rembane> It's also fast enough, but still slower.
04:36:51 <wavemode_> sure but that doesn't mean my software will be dog slow because I used mtl. that's what I mean by, it's relative
04:36:58 <wavemode_> haskell is slow relative to c++ but we still use it
04:36:58 <fog> wait, whats the difference between mtl style and monad transformers, i thought mtl was literally just "monad transformer library"
04:37:22 <fog> "usually implemented as monad transformers. has anyone attempted to do streaming with tagless final encoding (mtl style)"
04:37:24 <merijn> fog: mtl is a bunch of classes that try to abstract out the concrete monad transformer stack
04:37:47 <fog> whats tagless final encoding?
04:37:55 <merijn> wavemode_: "haskell is slow relative to C++" <- well, that entirely depends
04:38:15 <fog> i heard people saying things about cps being more expressive than transformers, is it something to do with that?
04:38:17 <merijn> Blanket statements about speed of languages are essentially always meaningless
04:38:45 <absence> merijn: i often hear ghc is pretty good at specialising, is there something that prevents this from happening in mtl?
04:39:30 <merijn> absence: Specialising can only happen if a type is entirely fixed (i.e. a concrete transformer stack) and if you have that, then you're no longer doing mtl-style code :)
04:40:29 <fog> i dont get how that happens... so its like, constraints instead of actual nested containers?
04:40:45 <merijn> fog: What containers?
04:40:47 <fog> and some properties that are common among various of these
04:41:03 <fog> idk, things of kind * -> * that are being nested
04:41:51 <absence> merijn: but the stack does get fixed at some point, where you deconstruct/"run" it. from that point, doesn't ghc know what the type will be, and can specialise accordingly?
04:42:39 <fog> yeah, how would it be slow just because it hadnt been typechecked yet
04:42:43 <merijn> absence: If I have a package that's all polymorphic implementations that you depend on there's no way to guarantee the GHC will specialise all these things you're importing
04:43:19 <fog> oh, so because its a class abstraction, "you could use something slow"
04:43:21 <merijn> absence: Suppose you have an entire "mtl" streaming lib, are you expecting GHC to inline the entire library into your package and then specialise all the implementations?
04:43:24 <absence> merijn: that's true, they'd all have to be INLINABLE or something? but assuming they were?
04:43:59 <merijn> absence: Now literally every package using your library is recompiling it and inlining it into your program, bloating program size and compile times
04:44:13 <fog> isnt that why some libraries or abstractions ship with rewrite rules?
04:44:34 <fog> i guess from what your saying that either mtl doesnt do this, or it cant
04:45:10 <fog> the usual example would probably be build fold fusion, which isnt irrelevant for streaming applications
04:45:45 <fog> so is the question about, how can transformer stacks guarantee fusion?
04:46:47 <fog> like, if you put an exception transformer somewhere in the stack, that it wouldnt mess up the streaming 
04:47:22 <fog> or is it more to do with under what conditions such an additional layer could be guarantied to inline through it
04:47:38 <absence> merijn: of course, there's a balance to be made when it comes to inlining and specialising, but calling functions in a library also isn't free. if i'm making an application rather than a library, is it that big of an issue?
04:48:33 <wavemode_> you could, conceivably, compile your project and all your dependencies with -fexpose-all-unfoldings and -fspecialise-aggressively, and then ghc will (probably) specialize everything
04:49:31 <wavemode_> i don't know how much time and RAM that would take
04:50:01 <fog> are people actually concerned about compile times!?
04:50:58 <wavemode_> for what is usually a relatively small or nonexistent increase in run time speed? yes
04:51:15 <fog> surely the type safety guarantees such runtime savings as to make this irrelevant 
04:51:23 <Rembane> fog: I am, compiling my package with all its dependencies takes 15 minutes, it gets tiresome quickly.
04:51:44 <fog> wavemode_ but the inlining would make huge savings!?
04:52:07 <fog> i cant see how it could really take *that* long to do at compile time
04:52:35 <fog> Rembane: do you use  -fobject-code?
04:52:38 <wavemode_> that's a common misconception. there are times where inlining can actually hurt performance
04:52:53 <fog> well, rewrite rules...
04:53:27 <fog> or a different example, like, doing type safe bounds checking to allow unsafe versions of vector updates
04:54:10 <fog> not having to perform a bounds check on each data modification or access should be a huge saving
04:54:26 <Rembane> fog: I don't, but I would prefer if it was quicker to recompile almost regardless of fast recompilation is.
04:55:12 <fog> I think the advantage of compiling to object code is that a small update should trigger only the least sufficient recompilation
04:55:30 <fog> i dont understand it properly, so im not sure, but i think thats how they were doing hotswapping at facebook
04:56:21 <fog> the idea was that you would deploy object code to the kuberneties or whatever modular server thing they use, and it would drastically reduce the memory of having to link that object code in, compared with a full recompilation
04:58:39 <fog> i had a problem with adaptive dynamic pruning of typesafe nets, where depending on how a state accumulating statistic was processed by a net, to derive the pruning scheme at the current step - that this would change the shape of the net in a way that couldnt be determined at compile time
04:59:13 <fog> i didnt want to have to save my net state, and recompile it midway through training just to change its shape adaptively 
05:00:49 <fog> and yeah, how to even save the shape, which is a type, to a file that could be read in, required its show instance to generate a haskell module, that had to be imported!
05:01:58 <wavemode> fog: well, situations like that are why compiler flags exist. you are free to benchmark your own code and use them as you see fit. but there is no reason compilation should massively slow down for everyone when only a small percentage of programs would see a measurable performance benefit. (whereas some programs would actually perform worse)
05:03:11 <fog> right, sure, it needs to be bytecode for the -O2 flag to make it super fast... idk how they did the hotswapping thing to be honest
05:05:28 <fog> i cant remember the talk where they had some elm bridge thing for "refresh driven development" which used ghcid, and the -fobject-code flag to make compilation faster for web dev (just hitting the refresh button, like rails devs are used to "monkey-patching" or whatever its called) 
05:06:08 <fog> but then i guess they just use the regular bytecode and optimiser flags for the finally deployed thing 
05:07:12 <fog> oh yeah, i guess there is even the option of turning off typechecking, like, if your determining types at runtime, you can kind of ensure that they should typecheck, and so just load in the module without bothering to typecheck it since you know it should
05:07:42 <fog> but then, i dont know if pattern matching would still work
05:08:09 <fog> idk if i can even pattern match on different subgraph shapes
05:08:50 <fog> yeah, i guess if different shapes were handled by a class you would *have* to typecheck it, or it wouldnt know which version of a function to call
05:39:10 <DanS_> hey everyone, wasted a whole day on this so hoping someone knows how to do this or why it's impossible to do this.
05:39:10 <DanS_> I have a datatype `data Cached (f :: * -> *) a`and to simplify the case where f is a partial function application, I made a type synonym: `CachedFun a b = Cached ((->) a) b`
05:39:10 <DanS_> I now would like to define a Profunctor for CachedFun, though I can't do this directly as GHC 8.6 complains my type synonym can't be partially applied, so I ended up with this (attaching)
05:39:30 <DanS_> https://www.irccloud.com/pastebin/ttFMlOg4/Cached%20Profunctor
05:40:09 <DanS_> This unfortunately fails like so, and I'm not sure how to debug this https://www.irccloud.com/pastebin/aEoTQmEw/failure
05:41:15 <Arahael> What's the current go-to package for XML these days using stack?  I want to do a lot of xpath queries.  Is hxt-xpath the way to go? If so, how do I learn it? The hackage is rather... sparse.
05:41:41 <DanS_> (also, happy to go to stackoverflow or somewhere else if this is a too large question for this kind of forum)
05:42:48 <Eduard_Munteanu> DanS_, probably not too large
05:44:57 <Arahael> Hmm, yep, HXT looks to be the ticket, and there's a pretty big page about it on the haskell wiki.  Coolies.
05:47:40 <Eduard_Munteanu> DanS_, can you settle for a newtype?
05:49:33 <DanS_> I thought I can make it work with newtype, but I'd like to see if I can avoid that :)
05:51:01 <DanS_> for wider context of what this is, I'm trying to extend the 'cached' package built on top of shake, to allow a function inside the Cached applicative
05:51:31 <ibloom> Is there a tool that can go through a haskell project and cull unused imports?
05:53:24 <maerwald> ibloom: weeder
05:53:39 <maerwald> https://github.com/ocharles/weeder
06:00:26 <ibloom> maerwald: thank you!
06:32:22 <ski> DanS_ : hm, i'm surprised how you didn't get other issues reported with `instance (cf a b ~ CachedFun a b) => Profunctor cf where ..'
06:34:51 <ski> DanS_ : (a) it looks like you logically really intended `(forall a b. cf a b ~ CachedFun a b) => Profunctor cf' (which would then require `QuantifiedConstraints'). without that'd assume it'd be interpreted as `forall cf a b. (cf a b ~ CachedFun a b) => Profunctor cf' which seems like it'd be equivalent to `forall cf. (exist a b. cf a b ~ CachedFun a b) => Profunctor cf' which would be comething completely different
06:37:59 <ski> perhaps my logical interpretation of how it would be interpreted, without the explicit quantifier, is inaccurate, though (and i haven't really played that much with `QuantifiedConstraints'). and i'm not sure whether the interpretation with `exists' would hold, in the presence of how instance resolution works
06:43:49 <ski> DanS_ : anyway, with just `(cf a b ~ CachedFun a b) => Profunctor cf', i'm surprised you don't get yelled at, for `a' and `b' occuring more often in the instance constraint, than in the instance head (where they don't occur at all), which would seem to run into `UndecidableInstances' or even just ambiguity issues
06:45:17 <ski> DanS_ : and i'm also surprised that you don't run into overlapping issues, since the instance head `Profunctor cf' seems to overlap with every instance of `Profunctor' whatsoever
06:45:38 <ski> however, when i try `newtype L a = MkL [a]; instance (l a ~ L a) => Functor l where fmap f (MkL as) = MkL (map f as)', i'm surprised that this is accepted, and apparently seems to work
06:48:34 <ski> (perhaps some of these things would be checked after the check that gave you the error, though ?)
06:50:04 <ski> btw, i would expect `cf a b ~ CachedFun a b' to be equivalent to `cf a b ~ Cached ((->) a) b', so, afaics, the type synonym `CachedFun' seems irrelevant here
06:52:07 <ski> DanS_ : although, looking at the error message, matching "Expected type: cf b1 c -> cf a1 c" with "Actual type: Cached (p0 b1) c -> Cached (p0 a1) c", it does look like it's refusing to attempt to bind `cf' to a type-level lambda `\x -> Cached (p0 x)' which, presumably, is what you were trying to work around, with that type synonym ?
06:55:00 <ski> DanS_ : conclusion, i guess, is that i'm confused why you don't get other issues, and confused why my other example was accepted. but that i think, most probably, what you're trying to do here isn't going to work anyway, that you need `CachedFun' to be a new data type
07:00:04 <DanS_> ski: yeah i actually did run into overlapping issues too, but I'm not sure I understand why, given the constraint  :(
07:01:59 <DanS_> yep I agree the type synonym should be irrelevant, initially I thought I can just write `instance Profunctor CachedFun` which does not work at all.. :)
07:02:28 <DanS_> which is surprising as this kind of thing works in Scala (I remember I did this kind of thing years ago when I was using scala at work)
07:02:46 <fog> ski: whats happening there? is ~ doing something injective?
07:03:23 <fog> like, you wouldnt be able to write l ~ L as they have kind * -> *, but ~ must be doing some kind of injectivity thing with the forall a.
07:04:56 <fog> im not sure why i think it is something to do with injectvity other than something goldfire said about it during the release, about it being able to propegate equality checks through a parametrised type to the type arg
07:05:40 <fog> something i didnt really understand, which is why i cant seem to ever get injective type families to work properly
07:05:50 <fog> maybe datatypes are more like proper injective type families
07:05:51 <ski> DanS_ : instance resolution works in a way that an instance is selected, only looking at the instance head, seeing if it matches the constraint in question that we're trying to resolve. specifically not checking the instance constraint when deciding which instance to pick. only after an instance has been selected, would the instance constraints be checked
07:06:58 <fog> ah, the ol' specificity hack
07:07:13 <fog> but yeah, that ends up using OverlappingInstances
07:07:30 <fog> so only really makes sense for custom typeclasses that you can ensure are not overlapping
07:07:39 <fog> not for things like Profunctor
07:08:08 <DanS_> I see... so if I could say instance `Profunctor (CachedFun ? ?)` where the instance has some structure, that would be unambiguous
07:08:09 <ski> e.g. `instance Foo (T Bool)' wouldn't match a constraint `Foo (T Int)', but if you'd write `instance (a ~ Bool) => Foo (T a)', that instance would match, only to generate an error when the constraint `Int ~ Bool' then couldn't be solved
07:08:14 <fog> that why we have ShowS right?
07:08:52 <ski> DanS_ : basically, `instance ..a.. => Foo a' would overlap with everything, and so, for the most part, be pretty useless
07:08:58 <DanS_> ski: yep, makes more sense now, I've seen that pattern in a number of places
07:09:49 <ski> (occasionaly, one may actually want to make such a general instance, but that's quite rare. it would preclude having any other instances whatsoever for `Foo', barring `OverlappingInstances' or (worse) `IncoherentInstances')
07:09:56 <DanS_> but I don't know how to partially apply this.. I really just want `Profunctor (\x y -> Cached1 ((->) x) y)` at the type level but that seems impossible :'(
07:10:54 <DanS_> is there some trick with type families that might get around this?
07:10:58 <ski> DanS_ : but under this understanding, i think my `L' example shouldn't have worked, so it seems i'm missing something (or maybe running into a bug ?)
07:12:00 <fog> no! not type families, they cant be partially applied wither
07:12:00 <ski> DanS_ : yea. basically you want something like `Profunctor (\a -> Cached (a ->))', but lambdas in types are not allowed
07:12:02 <fog> either
07:12:08 <fog> you need a datatype
07:12:09 <DanS_> oh, your example works because you're using `map` not `fmap` in the definition
07:12:23 <ski> (i wonder to which extent `QuantifiedConstraints' could ameliorate this ..)
07:12:28 <DanS_> oh, your example works because you're using `map` not `fmap` in the definition, if you try to use fmap like i just tried, you run into overlapping instances again
07:12:34 <fog> possibly you could defunctionalise your type synonym, but a newtype seems way easier
07:12:39 <ski> does Scala have type synonyms ?
07:12:58 <fog> making instances on defunctionalisation symbols is not advised, but could possibly useful somehow
07:13:53 <DanS_> yeah in scala I believe you can go `type CachedFun[a, b] = Cached[ a => _, b ]` 
07:14:29 <ski> > let xs :: l ~ [] => l Integer; xs = [0,1,2,3] in xs  -- fog, seems like `l ~ L' would also work, since this works
07:14:31 <lambdabot>  [0,1,2,3]
07:14:48 <DanS_> and scala doesn't have type classes per se, but a more powerful (and thus easy to abuse, hard to implement) feature called implicits
07:15:13 <ski> fog : i dunno what you mean by injectivity being involved/relevant here
07:15:40 <fog> ah, then your example probably puts the forall at the far left (not QuantifiedConstraints needed), does the equality check on the l and then the a, and then discards the a.
07:16:10 <fog> yeah sorry, i thought ~ was kind * -> *, not k -> k
07:16:38 <fog> injectivity is something to do with nested types... i cant remeber how, so probably dont worry
07:19:24 <fog> % newtype A a
07:19:24 <yahb> fog: ; <interactive>:5:1: error:; * A newtype must have exactly one constructor, but `A' has none; * In the newtype declaration for `A'
07:19:31 <fog> % data A a
07:19:31 <yahb> fog: 
07:19:49 <fog> % instance a ~ a => Functor A
07:19:49 <yahb> fog: ; <interactive>:7:10: warning: [-Wmissing-methods]; * No explicit implementation for; `fmap'; * In the instance declaration for `Functor A'
07:20:38 <fog> yeah, seems like it doesnt seem to mind about forall variables being brought into scope just to be used in the constraint
07:21:05 <fog> idk if it has UndecidableInstances enabled 
07:21:34 <fog> % instance Show a => Functor A
07:21:34 <yahb> fog: ; <interactive>:8:10: error:; * Variable `a' occurs more often in the constraint `Show a' than in the instance head `Functor A'; (Use UndecidableInstances to permit this); * In the instance declaration for `Functor A'
07:21:37 <fog> nope
07:22:34 <fog> % instance (forall a. a ~ a) => Functor A
07:22:34 <yahb> fog: ; <interactive>:9:10: warning: [-Wmissing-methods]; * No explicit implementation for; `fmap'; * In the instance declaration for `Functor A'
07:22:52 <fog> hmm, i thought it would complain about QuantifiedConstraints if the forall was in a bracket
07:23:46 <fog> % data B a b 
07:23:46 <yahb> fog: 
07:24:13 <fog> % instance (Show a) => Functor (B a)
07:24:13 <yahb> fog: ; <interactive>:11:10: warning: [-Wmissing-methods]; * No explicit implementation for; `fmap'; * In the instance declaration for `Functor (B a)'
07:24:48 <fog> % instance (forall b. (a~b,Show b)) => Functor (B a)
07:24:48 <yahb> fog: ; <interactive>:12:10: error:; * You can't specify an instance for a tuple constraint; * In the quantified constraint `forall b. (a ~ b, Show b)'; In the instance declaration for `Functor (B a)'
07:25:27 <fog> ok, no tuples in quantified constraints apparently... 
07:25:52 <ski> fog : "that why we have ShowS right?" -- huh ? `ShowS' is just a type synonym for `String -> String'. and using that in place of `String' in just a performance hack
07:26:03 <fog> ShowPrec?
07:26:11 <DanS_> % instance (forall b. a~b,Show b) => Functor (B a)
07:26:11 <yahb> DanS_: ; <interactive>:13:10: error:; * Variable `b' occurs more often in the constraint `Show b' than in the instance head `Functor (B a)'; (Use UndecidableInstances to permit this); * In the instance declaration for `Functor (B a)'
07:26:47 <fog> DanS_ are you sure that b is the same there?
07:27:06 <fog> forall b. (forall b' . a~b' ,Show b)
07:27:09 <ski> fog : perhaps constraints (including quantified ones ?) "ending" with `~' are handled differently ..
07:27:48 <ski> DanS_ : presumably you meant `(forall b. (a ~ b,Show b))' ?
07:28:13 <fog> or it just strips the parens off of the thing because its not a proper tuple
07:28:30 <fog> % instance (forall a. a ~ a,Show Int) => Functor A
07:28:31 <yahb> fog: ; <interactive>:14:10: warning: [-Wmissing-methods]; * No explicit implementation for; `fmap'; * In the instance declaration for `Functor A'
07:28:54 <fog> ah, well it does have QuantifiedConstraints enables...
07:28:54 <ski> hm
07:29:11 <DanS_> what's what fog had tried before hence why i tried to remove the ()s
07:29:29 <ski> on second though, i think `(forall b. (a ~ b) => Show b) => ..a..' might be what was intended, above ?
07:29:35 <fog> i think the forall is just for that side of the tuple though...
07:29:39 <ski> yea, i just noticed, DanS_
07:29:52 <ski> yes, fog
07:30:08 <ski> (and it's not really a tuple, but a conjunction constraint)
07:30:34 <fog> oh cool, so you can use nested constraints instead of the tuple that is not allowed in Qunatified constraints
07:31:03 <ski> (which, interpreting constraints as types inhabited by the corresponding constraint evidence, would amount to tuple types (not to (type) tuples))
07:31:08 <fog> wait, whats a conjunction constraint?
07:32:05 <fog> some kind of Constraint Kind
07:32:33 <ski> @type fromIntegral
07:32:34 <lambdabot> (Integral a, Num b) => a -> b
07:32:48 <fog> % :kind (Show Int,Show Bool) :: '(Constraint,Constraint)
07:32:48 <yahb> fog: 
07:32:53 <ski> `(Integral a,Num b)' is a conjunction of the two constraints `Integral a' and `Num b'
07:33:07 <fog> % :kind! (Show Int,Show Bool) :: '(Constraint,Constraint)
07:33:07 <yahb> fog: 
07:33:12 <fog> rrg
07:33:25 <ski> unfortunately, the syntax here is rather overloaded ..
07:33:53 <fog> % :kind! (Show Int,Show Bool)
07:33:53 <yahb> fog: Constraint; = (Show Int, Show Bool)
07:34:03 <ski> (who thought it would be a good idea for tuple types to be written in the same way as tuples, to begin with ?)
07:34:52 <fog> '(Constraint,Constraint) ~ Constraint ?
07:35:36 <fog> so confusing, still have not managed to use QuantifiedConstraints in a practical way
07:35:58 <LevelChart8> I am reading the Beam docs: https://tathougies.github.io/beam/tutorials/tutorial1/ and I am trying to understand how to use this with postgres.  Would I make one connection string (i.e. one PG user) and the same credentials are used by every user when my code is compiled onto a mobile build?
07:41:55 <LevelChart8> Also, I do not understand if Beam creates the table programmatically from the Haskell code, or I need to separately make the tables in postgres that match the schemas in Haskell
07:42:29 <ski> fog : no, they're not the same
07:55:10 <ibloom> Is there a standard type family to go from a container to it's element type. Such as type ElementType (Vector a) = a?
07:59:37 <merijn> Containers doesn't have a "traverseKeys"? :\
08:00:02 <merijn> ibloom: Not really. MonoTraversabl has something a bit like that
08:00:41 <ibloom> I see. Just trying not to reinvent the wheel.
08:05:11 <infinisil> ibloom: Yeah I'd say mono-traversable is the best thing for this
08:05:30 <ibloom> Will look into it.
08:08:48 <slack1256> How does concurrency (say a stm's TChan) fit with a reactive-banana graph? So far I've read all the interactions ought to happen on that graph.
08:12:44 <LevelChart8> My brain is failing.  What is the type I should use for data that can be any combination of a list of things/
08:15:59 <c_wraith> LevelChart8: what do you hope to do with such a list after creating it?
08:16:30 <LevelChart8> in a UI, the user might be asked to list all the days of the week she is available for a meeting.
08:16:40 <LevelChart8> so one user’s list might be [Mon, Wed, Thurs]
08:16:48 <LevelChart8> and another [Mon, Tues, Wed]
08:16:51 <c_wraith> ah, so you're concerned with preventing duplicates?
08:17:04 <c_wraith> I think you probably want Data.Set.Set
08:17:25 <LevelChart8> i want to then run like a matching function
08:17:31 <merijn> Why does Data.Foldable not have a foldMapM? >.>
08:17:35 <LevelChart8> dayMatch user1List user2List
08:17:51 <LevelChart8> c_wraith: thanks I will look at that
08:18:06 <c_wraith> merijn: because foldMap with some newtype wrappers can handle that
08:18:30 <LevelChart8> c_wraith: inside that set they are SumTypes?
08:18:39 <merijn> c_wraith: That's a hassle to apply, though :\
08:19:02 <c_wraith> LevelChart8: for the example you described, you'd have a Weekday sum type, sure
08:19:26 <LevelChart8> and then they could select mulltiple Weekdays in the UI
08:19:34 <LevelChart8> ok
08:19:38 <LevelChart8> [Weekday]
08:20:09 <slack1256> merijn: As c_wraith said, you can use the ~Ap~ newtype to make the (<*>) the monoid mappend.
08:21:04 <LevelChart8> I am confused though because i thought Sum Types force you to choose one item
08:22:06 <c_wraith> a value of a sum type is exactly one of the options.  But nothing stops you from putting multiple values in a container
08:22:25 <LevelChart8> ok i unnderstand now
08:22:32 <LevelChart8> thank you
08:36:37 <solonarv> I guess it's easy to write: foldMapM f = getAp . foldMap (f . Ap)
08:37:30 <c_wraith> Should that be (Ap . f)?
08:42:59 <solonarv> oh oops, yes
08:50:56 <LevelChart8> what’s the difference between “newtype Email = Email { unEmail :: T.Text }” and “type Email = T.Text”?
08:51:32 <hpc> the type is an alias
08:51:45 <hpc> anywhere you mention Email in say, a type signature, it will instead mean T.Text
08:52:02 <LevelChart8> what is the advantage of using a newtype?
08:52:07 <LevelChart8> an alias seems simpler
08:52:14 <merijn> LevelChart8: An alias does nothing
08:52:26 <merijn> Like, literally nothing
08:52:27 <hpc> the advantage of a newtype is you get to do different logic on emails specifically
08:52:41 <hpc> like you can limit the api so people can't do general text operations on it like concatenation
08:52:48 <hpc> it doesn't make sense to concatenate two email addresses
08:53:00 <LevelChart8> got it
08:53:01 <LevelChart8> newtype Email = Email { unEmail :: T.Text }
08:53:05 <LevelChart8> if i used that
08:53:15 <LevelChart8> how wuold i turn it into text when i needed it to be text
08:53:32 <solonarv> pattern matching, or applying unEmail to it
08:53:51 <solonarv> same way you'd do it with a normal data type
08:54:01 <LevelChart8> ok thank you
08:54:48 <hpc> a good example of a newtype is Sum and Product, btw
08:55:01 <hpc> representing the monoids (0, +) and (1, *) respectively
08:55:10 <hpc> they have different Monoid instances, and can't be mixed
08:55:16 <fpaulw> correct me if I'm wrong: defining it that way gives you a method for unpacking it. As opposed to just doing newtype Email = Email T.Text
08:55:25 <hpc> fpaulw: correct
08:55:28 <solonarv> yes, that's what record syntax is for
08:55:48 <LevelChart8> hpc: oh wow
08:55:53 <LevelChart8> i never realized that
08:55:56 <LevelChart8> makes sense
08:56:10 <LevelChart8> they are newtype wrappers for what?
08:56:18 <hpc> @src Sum
08:56:18 <lambdabot> newtype Sum a = Sum { getSum :: a }
08:56:38 <LevelChart8> they just wrap a generic object?
08:56:49 <LevelChart8> hmmm i guess that makes sense
08:56:52 <hpc> technically anything (the Monoid instance has additional class constraints so they only exist if you're wrapping numbers)
09:02:34 <LevelChart8> I am using this newtype with Beam
09:02:37 <LevelChart8> primaryKey = UserId . _userAddressEmail
09:02:46 <LevelChart8> that last type used to be T.Text
09:02:52 <LevelChart8> then i made a newtype wrapping that
09:02:58 <LevelChart8> but when i do:
09:03:24 <LevelChart8> Couldn't match expected type ‘UserT column
09:03:24 <LevelChart8>                                     -> Columnar column T.Text’
09:03:25 <LevelChart8>                   with actual type ‘T.Text’
09:03:32 <LevelChart8> In the expression: UserId . (unEmail _userAddressEmail)
09:04:56 <ja> if there is an arrow in the type mismatch, you must have an arity problem , no?
09:05:11 <LevelChart8> what does that mean
09:05:25 <ja> arity is the amount of arguments something takes 
09:05:26 <LevelChart8> i thought unEmail unwrapped the newtype
09:05:28 <monochrom> arity = number of parameters
09:05:47 <LevelChart8> newtype Email = Email { unEmail :: T.Text }
09:06:15 <LevelChart8> { _userAddressEmail                 :: Columnar f Email
09:06:39 <LevelChart8> but i’m confused because i did not get that error when it was “type Email = T.Text"
09:10:50 <wikiemol> Hello, is there a way using TemplateHaskell to parse a string of haskell code into an expression?
09:12:28 <merijn> wikiemol: Yes, but your question is suspect ;)
09:12:35 <merijn> wikiemol: What are you actually trying to do?
09:12:44 <wikiemol> merijn Lol I knew this would be the reaction
09:12:50 <wikiemol> I am not trying to do anything actually
09:12:57 <wikiemol> I am just trying to learn TemplateHaskell
09:13:21 <merijn> wikiemol: Because there's already support for quoting arbitrary Haskell into the corresponding template Haskell
09:13:41 <solonarv> wait, there is? where? I can't recall seeing such a QQ
09:13:56 <merijn> solonarv: Eh, that's just the regular [| |] ?
09:14:20 <merijn> % :set -XTemplateHaskell
09:14:20 <yahb> merijn: 
09:14:33 <merijn> % :t [|5 + 3|]
09:14:33 <yahb> merijn: Language.Haskell.TH.Lib.Internal.ExpQ
09:14:34 <solonarv> yes, I'm aware of that - but there isn't a corresponding function you can call
09:14:40 <merijn> % runQ [|5 + 3|]
09:14:40 <yahb> merijn: ; <interactive>:20:1: error: Variable not in scope: runQ :: Language.Haskell.TH.Lib.Internal.ExpQ -> t
09:15:36 <merijn> solonarv: Well, if someone asks "parse a string of Haskell into TH" the most obvious assumption is "sounds like you just want quotation"
09:16:34 <solonarv> the thing is that you can only use the [| ... |] forms on literals
09:16:54 <merijn> % [|5 + 3|]
09:16:54 <yahb> merijn: ; <interactive>:21:1: error:; * No instance for (Show Language.Haskell.TH.Lib.Internal.ExpQ) arising from a use of `print'; * In a stmt of an interactive GHCi command: print it
09:16:55 <solonarv> what I'd like is a 'Language.Haskell.TH.Quote.haskell :: QuasiQuoter' such that 'quoteExp haskell "blah blah"' is equivalent to '[| blah blah |]'
09:17:12 <solonarv> (absent any antiquotation in the [| ... |])
09:18:07 <ezzieyguywuf> In these examples, I don't see them using Text.pack - is this just to keep the examples concise? https://hackage.haskell.org/package/text-1.2.4.0/docs/Data-Text.html#g:6
09:18:14 <solonarv> presumably there is some difficulty involved in doing this, which is why it doesn't exist
09:18:17 <wikiemol> merijn I guess my imagined use case for this was writing refactoring/renaming tools like in an ide, to actually take in a haskell and generate the code in the file. So editing the code "at write time" (a term maybe I made up?) lol instead of at compile time
09:18:43 <solonarv> ezzieyguywuf: the examples probably assume you turn on OverloadedStrings
09:18:55 <solonarv> so string literals become polymorphic (just like numeric literals)
09:19:07 <merijn> ezzieyguywuf: Which example is missing T.pack?
09:19:27 <solonarv> look at 'intercalate', that's the first one
09:19:31 <ezzieyguywuf> merijn: the one I linked, for intercalate
09:19:37 <ezzieyguywuf> (maybe my link-fu is messed up)
09:19:38 <merijn> wikiemol: So, like, getting the result of a TH splice out?
09:19:51 <merijn> ezzieyguywuf: ah, yeah
09:19:51 <solonarv> your link does not go to intercalate, indeed :)
09:19:58 <ezzieyguywuf> solonarv: womp womp.
09:20:01 <merijn> ezzieyguywuf: Presumably they assume -XOverloadedStrings
09:20:24 <ezzieyguywuf> what is OverloadedStrings? should I use it, or just sprinkle all the Text.pack throughout my code as needed?
09:20:26 <wikiemol> merijn Yes, I suppose so, but also getting it in the first place without the programmer having to add anything to their code.
09:20:27 <dsal> ezzieyguywuf: OverloadedStrings is rarely confusing, but mostly just "why isn't this the default?"
09:20:52 <ezzieyguywuf> how do I enable it? I'm still pretty new to haskell
09:20:56 <dsal> OverloadedLists can be confusing, though.  heh
09:21:01 <solonarv> it's a language extension that (as I said earlier) makes string literals polymorphic
09:21:09 <awpr> put `{-# LANGUAGE OverloadedStrings #-}` at the top of the module file
09:21:10 <merijn> ezzieyguywuf: OverloadedStrings is an extension that makes string literals polymorphic (like numerical literals already are) and the Text instance for that extension let you use string literals directly as Text
09:21:13 <solonarv> so the type of "hello" becomes 'IsString s => s' rather then 'String'
09:21:27 <ezzieyguywuf> woah, interesting
09:21:33 <merijn> wikiemol: Not quite what you want, but there's -ddumpl-splices
09:21:34 <ezzieyguywuf> is `IsString` a Data.Text thing?
09:21:41 <dsal> ezzieyguywuf: Data.String
09:21:48 <ezzieyguywuf> interesting
09:21:51 <merijn> wikiemol: Which outputs the source file with all the TH quotes replaced with the resulting code
09:22:06 <awpr> it's a GHC thing that `Text` and `ByteString` and a few other stringy types implement so that string literals can be interpreted as their own types
09:22:08 <solonarv> merijn: wikiemol: it's -ddump-splices, there was a typo
09:22:11 <dsal> ezzieyguywuf: Text, ByteString, etc... all have IsString instances so you can use regular string syntax to refer to them in your code.
09:22:31 <ezzieyguywuf> I see
09:22:40 <ezzieyguywuf> thank you for the help all I think this gets me what I need.
09:22:42 <merijn> solonarv: No, see, I was intentationally talking about dumpling splices...
09:23:12 <wikiemol> merijn Interesting, so that compiles the code to a template haskell equivalent? Is that correct?
09:23:16 <dsal> ezzieyguywuf: It also means you can implement your own String type such that   `"something" :: MyString` works.  This is common in, e.g., database libraries.  Probably regex.
09:23:24 <awpr> merijn: `[e| 🥟 |]`?
09:23:28 <wikiemol> merijn Or does it make delicious dumplings?
09:23:33 <wikiemol> Either is acceptable
09:23:48 <awpr> ahh no that's a dumpling quote, nevermind
09:24:14 <solonarv> wikiemol: no, -ddump-splices just makes GHC print out stuff it's already evaluating
09:24:23 <merijn> wikiemol: Well it just compiles as normal, it's just that in addition to compiling it also logs a copy of the source with the TH results (mostly for debugging your TH, for example)
09:24:53 <solonarv> if you have a template haskell splice in a file - say, $(mkLenses ''Foo) - then when compiling that file, GHC has to actually run that splice to figure out what code it generates
09:25:05 <wikiemol> merijn solonarv ahh gotcha 
09:25:12 <solonarv> with -ddump-splices, the generated code is *also* printed to stdout or to a file, so you can see what's going on
09:25:28 <merijn> wikiemol: But you could certainly improvise on top of that/abuse it
09:25:59 <merijn> wikiemol: You could see if the GHC API has some way of extracting those splices
09:26:14 <merijn> wikiemol: Might be a nice plugin for haskell-language-server :)
09:28:03 <monochrom> splicing dumplings is messy. :)
09:30:28 <wikiemol> Well thanks for the help everyone!
09:42:21 <ezzieyguywuf> how do I make an `instance Show (Map.Map Int String)`?
09:42:26 <ezzieyguywuf> the compiler is saying this is illegal
09:42:56 <awpr> you can't write one because `containers` already defines that instance; do you need it to produce something different from the default one?
09:43:25 <ezzieyguywuf> awpr: yea I wanted to change the default
09:44:11 <awpr> if it's not important to use the actual name `show` for the new behavior, you can just implement it as a standalone function like `nicerShowMap :: ... -> String`
09:44:35 <ski> otherwise, make a `newtype' wrapper
09:44:39 <awpr> otherwise, the standard way to have different instances for existing types is to make a `newtype` and write the desired instance on that
09:45:04 <merijn> This smells like wanting to prettyprint via show
09:45:11 <merijn> To which I can only say: Please don't
09:45:36 <ski> (also, please don't make a `Show' instance that doesn't output valid Haskell code .. in case you were thinking about doing that)
09:46:53 <Heffalump> ski: valid in what scope, though? (This is a real problem I have with Show instances - in a big program I still can't copy and paste them sensibly because of all the constructors I would have to bring into scope to do it.)
09:47:01 <ski> yes
09:47:04 <ezzieyguywuf> merijn: I was actually doing prettyprint yes
09:47:10 <ezzieyguywuf> i was using show for my example
09:47:26 <ezzieyguywuf> g2g now
09:48:47 <ski> Heffalump : sometimes i wonder if there's a better way in which this issue ought to be handled ..
09:49:43 <wroathe> The problem I have with Show/Read is that there doesn't seem to be an agreed upon way to use them other than that you should avoid using them for what you were trying to use them for
09:50:42 <awpr> ski: what might a better way look like?  do you mostly have in mind that it would solve the scoping issues with pasting into .hs sources?
09:51:21 <merijn>  @hackage prettyprinter
09:51:30 <merijn> @hackage prettyprinter
09:51:30 <lambdabot> http://hackage.haskell.org/package/prettyprinter
09:51:39 <awpr> sure, I'm aware of that package; it's better in some ways and much worse in others
09:51:44 <awpr> it's prettier
09:51:47 <merijn> wroathe: The agreed upon way to use them is "debugging" :p
09:51:57 <ski> awpr : i'm not sure, that's why i'm wondering
09:52:05 <wroathe> merijn: Then there's no reason to formalize them as part of Base :P
09:52:21 <merijn> wroathe: Sure there is, we need ways to debug values in base
09:52:23 <wroathe> "Use these to write your debugging code"
09:52:32 <awpr> they're kind of currently fused into debugging and weird serialization
09:53:03 <merijn> awpr: Well, they suck at serialisation, so we can just skip that bit :p
09:53:05 <awpr> and if you try to make them better for debugging, you break the serialization
09:53:06 <wroathe> merijn: One could imagine a Debug class instead then
09:53:15 <merijn> Also, typeclass based serialisation is a dumbass idea
09:53:45 <merijn> aeson's ToJSON/FromJSON are spectacular mistakes
09:53:56 <wroathe> I just think there are too many interpretations of what an instance for either class could like like for them to really be useful as a core typeclass
09:54:26 <awpr> interesting, I haven't looked at those two in enough detail to derive why they're mistakes; got more details?
09:54:49 <wroathe> For 80% of the cases I find them to be useful
09:54:52 <merijn> awpr: They're mistakes because of the aforementioned "typeclass based serialisation is a dumbass idea"
09:55:01 <awpr> yeah, that's what I was asking about
09:55:01 <wroathe> But I'm sure merijn has some thoughts on the 20%
09:55:15 <awpr> I suppose you could say that it's not always the case that a composite type's serialization should embed the canonical serializations of its factors
09:55:31 <awpr> and also class-based serialization has zero backwards compat story
09:55:32 <merijn> awpr: Basically because there's absolutely no way you can actually have two separate (de)serialisations forms for the same data
09:55:38 <merijn> Yeah, that
09:55:42 <merijn> wroathe: It works fine
09:55:51 <wroathe> merijn: That's not entirely true though (see the newtype stuff above)
09:55:56 <merijn> wroathe: Until you *ever* want to change your datatype while maintaining backwards support
09:56:06 <wroathe> merijn: It's just that typeclasses make it a hassle when you start wrapping newtypes around everything
09:56:14 <merijn> wroathe: That's a lot more painful than just having an explicit deserialiser, though
09:56:51 <awpr> I've wrestled with this sort of issue in the codebase I've been working on; the conclusion ended up being that the class-based serializer was officially not considered a "persistent" form of serialization and we should break it from version to version
09:57:07 <wroathe> merijn: Yeah, I think what I've landed on with typeclasses is that they make sense when there's a good "default" implementation of an operation to fall back on, but otherwise you're just better off with plain ole functions
09:57:20 <awpr> i.e. it's fine as long as the program is only mumbling serialized stuff to itself in a closed room
09:57:30 <merijn> wroathe: Doesn't even have to be functions, consider the Put/Get datatypes from Binary
09:57:44 <wroathe> I'll have a look
09:57:51 <merijn> wroathe: I can have as many "Get Foo" values as I want and use different ones in different context to "parse a Foo"
09:58:17 <merijn> wroathe: (Binary also has a Serialise class, but that's bad, because you know...)
09:59:13 <awpr> it's more the auto-derivation from sum-of-products structure that forces you into backwards-incompatible serialization, right?
09:59:33 <merijn> Without lots of additional pain, yes
09:59:50 <awpr> you could just as well write a typeclass instance by hand and be careful when changing it, and that'd be no different from if it were a standalone serializer term
10:00:30 <wroathe> Anyways, time for chores
10:00:35 <merijn> wroathe: So instead of "parseData :: MyClass a => ByteString -> Maybe a" you do "parseData :: Get a -> ByteString -> Maybe a". Now writing a new/alternative/backwards compatible/whatever parse is much simpler
10:00:37 <awpr> so I guess "class-based" more specifically means "based on composing instances of the same class structurally"
10:05:27 <quiet_laika[m]> is there a way to write a type signature for an effect reinterpretation that isn't coupled to the underlying effect list? eg in freer-simple i want to write a transformation `lexToState :: Eff (Lex ': effs) a -> Eff (State LexState ': effs) a`
10:06:03 <quiet_laika[m]> but from what i understand, specifying the effect signature like that means that `Lex` would have to be the first effect in the stack
10:07:03 <quiet_laika[m]> but i get a type error for something like `lexToState :: (Member Lex effs, Member (State LexState) effs') Eff effs a -> Eff effs' a`
10:08:12 <codolio> Well, that latter type is going to be wrong.
10:08:40 <codolio> That say you can take any list of effects with Lex to any other list of effects as long as it has (State LexState).
10:09:35 <quiet_laika[m]> yeah that makes sense... i also tried `(Members (Lex ': effs) effs1, Members (State LexState ': effs) effs2` but i think it suffers from the same issue
10:09:35 <charms> Hi, I've been trying for a couple of days to get Neovim to work well with Haskell. What is the simplest way that I can get type information in neovim?
10:09:49 <quiet_laika[m]> is there any to decouple?
10:09:53 <quiet_laika[m]> any way*
10:11:32 <awpr> got a few ideas on this, I'll start with a bad one: there's probably a type family for ripping a particular effect out of a list and returning the rest of the list; that could give you something you can cons `State LexState` onto to have at least the right set of effects
10:12:12 <quiet_laika[m]> `class FindElem eff effs`?
10:12:26 <Heffalump> ski: FWIW I was thinking of writing a new type class that passes around some kind of "target scope" parameter to configure how things are printed
10:12:35 <Heffalump> but it'd be specific to a particular codebase/application
10:13:25 <quiet_laika[m]> FindElem returns the position, i suppose
10:13:39 <quiet_laika[m]> https://hackage.haskell.org/package/freer-simple-1.2.1.1/docs/src/Data.OpenUnion.Internal.html#FindElem
10:13:52 <awpr> hmm, I was thinking of something that'd remove the found element, too.  I don't see such a thing, but in any case it might still lead to an unimplementable type
10:16:31 <quiet_laika[m]> is it only possible to decoupled functions that "use" effects rather than "implement" them?
10:16:33 <quiet_laika[m]> decouple*
10:17:21 <berndl> What do you mean?
10:17:37 <indian_yogi> hi all haskellers
10:17:41 <indian_yogi> how are you all?
10:18:05 <berndl> Surviving. And you?
10:18:17 <quiet_laika[m]> eg handler functions generally look like `Eff (eff ': effs) a -> Eff effs a`
10:18:40 <quiet_laika[m]> but it doesnt seem like theres a way to express that in a way that doesn't depend on the order of the effects
10:19:05 <awpr> so one potential answer is: you have to handle all the outer effects before you lower `Lex` to `State LexerState`
10:19:28 <LevelChart8> does anyone know what I am doing wrong here? https://stackoverflow.com/questions/61975044/using-newtype-with-beam
10:19:58 <quiet_laika[m]> it seems like consumers are allowed to not worry about the order of effects, but code that actually manipulates effects has to handle that explicitly
10:20:00 <awpr> but since `Eff` actions generally don't specify their order of effects, your original signature may be just fine: it just decides that `Lex` is outermost and lowers it to `State`
10:20:06 <indian_yogi> i am new to programming and IT 
10:20:19 <quiet_laika[m]> which i guess makes sense because the order can be signficant in some cases, right?
10:20:24 <quiet_laika[m]> awpr: makes sense
10:20:33 <indian_yogi> can anyne tell me is it good to start with haskell as my first programming language?
10:20:50 <berndl> indian_yogi: Yes.
10:21:04 <awpr> indian_yogi: lots of people can tell you that, and they'll all have different answers :)
10:22:34 <awpr> there are people who say Haskell is too hard for newcomers with its mathematical structure; and there are people who say it's best to start with Haskell because you start out with clean, crisp semantics, and only later deal with the weirdness of actual computing hardware and operating systems
10:23:09 <berndl> quiet_laika[m]: Do you have a transformation from Lex to State?
10:23:29 <indian_yogi> thanks for motivating me and are there any good remote jobs available for haskell projects like remote jobs?
10:23:54 <Chobbes> awpr: I'd argue it depends what you want to do as well. Like learning Haskell first is great, but if you just want a job it's probably not the best choice :).
10:24:10 <berndl> awpr: You already hit weirdness with numbers in Haskell.
10:24:45 <awpr> yeah, that's true -- IEEE754 ruins the Num typeclass [even more than it already ruined itself]
10:25:07 <indian_yogi> ok, so there aren't many haskell jobs out there right?
10:25:34 <wavemode> there are some but not very many
10:25:41 <indian_yogi> i see lots of praise for haskell online and thought of building a career with it
10:25:43 <awpr> yeah, agreed Haskell is not the fastest, easiest path to gainful employment; it's substantially less prevalent than other languages, and often Haskell jobs are Haskell jobs because they want highly experienced engineers
10:25:55 <berndl> indian_yogi: compare to JavaScript, no.
10:26:05 <indian_yogi> but in this corona crisis i need job
10:26:34 <berndl> If I had a Haskell job to offer you, I would give it to you.
10:26:53 <awpr> on the other hand, it may (idealistically) be the best path to becoming a very employable engineer long-term: it gives you a strong foundation to think about computing, even if you end up writing (*shudder*) C++
10:27:07 <quiet_laika[m]> berndl: not sure if i grok, this function i'm trying to write is the transformation between them.
10:27:09 <Chobbes> indian_yogi: Haskell jobs exist, but it wouldn't be the fastest path to a job. You'd probably be better looking into web development with JS or Android / iOS development. Much as I love Haskell and would love to recommend it, if you're trying to get a job quickly it's probably not the best path.
10:27:26 <wavemode> the haskell jobs that exist are looking for experts in the language. so your first step would be mastering haskell. which is easier said than done
10:28:20 <Chobbes> indian_yogi: this is of course not to say you shouldn't learn Haskell --- it's reasonable to learn it alongside another language and see how they differ, which might give you a better idea of how to write and structure programs in general :).
10:29:23 <ski> Heffalump : hm, yea. i suppose it might be nice with some TH (?) magic reifying the current module-level scope
10:29:34 <indian_yogi> ok, so i can learn web technologies and get a job in that field and side by side learn haskell in the free time?
10:30:18 <indian_yogi> if I go into the web technology path can I change my career into haskell after few years?
10:30:19 <awpr> quiet_laika[m] is it actually a requirement that you have the intermediate effect stack of `State LexerState`, or can you lower it away entirely like `runState`?
10:31:10 <awpr> e.g. if some later transformation wants to interact directly with the lexer state outside of the abstraction of "doing lexing", that'd be a yes
10:31:18 <charms> indian_yogi, it may depend on your previous career
10:31:29 <indian_yogi> hmm
10:32:13 <mastarija> Any idea why I can't build network package on windows? When I do "cabal install network --lib" it just hangs on the build step for a very very long time.
10:32:25 <charms> for research in functional compilers, it is pretty reasonable to learn. however if you wanted to write electronics with software something like vhdl would be better
10:32:51 <charms> that's not to say it is just that
10:33:08 <awpr> that's an interesting counterexample, given just how many Haskell-based or Haskell-inspired HDLs there are
10:33:09 <indian_yogi> I was doing sales like medicine sales and then I lost my job and thought of learning programming and get a job for a living and then online I searched which programming language is the best for doing programming then in some article it showed uo as HASKELL
10:34:11 <charms> awpr yeah true, i suppose it may have been a bad example. don't really want to say my previous jobs on irc
10:34:58 <quiet_laika[m]> awpr: yeah im immediately lowering it with runState
10:38:17 <charms> indian_yogi, that really sucks :(
10:39:23 <indian_yogi> yeah, i feel that too
10:40:02 <indian_yogi> are there any people here who work at any company on haskell project?
10:44:01 <Heffalump> indian_yogi: I used to, but don't any more.
10:44:57 <awpr> it can be pretty difficult to get started in computing starting from zero.  it won't be a one-or-two-week time frame.  if you're interested in computing as a career, you should 100% learn!  but, it may not be the best answer to an immediate need for a job, given how much there is to learn
10:45:44 <awpr> if you do want to persist in getting a software job ASAP, something like JavaScript or Python is probably the fastest route, as much as I'd like to be able to recommend Haskell
10:45:56 <charms> i tried getting work with haskell before but found opening my options to a functional language was a lot more viable
10:46:03 <charms> it depends how much you want to compromise
10:46:57 <charms> i think haskell skills are quite transferrable to other functional languages
10:47:04 <merijn> It also depends on the kinds of jobs you aspire to have
10:47:32 <merijn> "Writing CRUD webapps" is a different job type than "solving super hard engineering problems"
10:47:35 <ja> indian_yogi: i think there are a bunch of functional tendencies in the industry, like, if you specialize in react.js, that is a bit functional, and it has tons of jobs
10:50:01 <indian_yogi> heffalump: ok
10:51:10 <charms> good luck, indian_yogi got to go for now!
10:52:16 <indian_yogi> python web devlopment using django is it good?
10:52:44 <indian_yogi> charms: thanks and see you again soon
10:53:18 <L29Ah> what's the popular solution for testing buildability against various versions of ghc for FOSS git repos ("CI")?
10:53:22 <berndl> indian_yogi: why not ask in #python?
10:54:20 <indian_yogi> bernd1: thanks for advise and i will ask in python channel
10:54:28 <indian_yogi> see you all bye
10:54:41 <D3gr4d0ff> ciao a tutti
11:02:55 <wroathe> merijn: Maybe I'm blind, but I don't see the benefit of doing that over parseData :: a -> ByteString -> Maybe a
11:03:09 <wroathe> merijn: But I'm not familiar with the Data.Binary stuff
11:03:54 <quiet_laika[m]> `Text.splitAt` is O(n), but is it more expensive than calling `Text.uncons` (O(1)) n times? does it allocate new lists?
11:04:03 <merijn> wroathe: The benefit is that there can only be *one* typeclass instance, but you can have infinitely many different "Get Foo" values
11:04:08 <quiet_laika[m]> err, arrays
11:04:29 <wroathe> merijn: I'm not talking about the typeclass though. I'm saying what's the "Get" wrapper get you?
11:04:41 <wroathe> a -> ByteString -> Maybe a vs Get a -> ByteString -> Maybe a
11:04:42 <merijn> wroathe: Which means that if you change the serialisation format later, you can keep using the original "Get Foo" for old data while working with the *new* "Get Foo" for new stuff
11:05:05 <merijn> wroathe: Get is just Binary's version of "Parser"
11:05:17 <wroathe> Ah
11:05:18 <merijn> wroathe: So it gets you Monad, Alternative, etc. instances :p
11:05:23 <awpr> it's actually `ByteString -> Maybe (a, ByteString)` vs. `Get a`
11:05:28 <wroathe> I see now
11:05:30 <wroathe> Thanks
11:05:45 <awpr> `splitAt` should be implemented by scanning the original array and returning "slices" of it, pointing to the same array
11:06:06 <awpr> it's very likely faster than iterated `uncons`
11:06:59 <sm[m]> indian_yogi: to get a computing job quickly, find the job first and learn the tech required - not the other way around
11:07:53 <indian_yogi> sm[m]: oh, ok. understood
11:08:33 <sm[m]> hunt for companies or well-off people, especially local ones, who have problems that need some tech help, of a kind you could learn quickly
11:09:09 <MarcelineVQ> quiet_laika[m]: 1*n is n so I would expect O(1) n times is also O(n)   neither uncons or splitAt allocate new memory for the purposes of holding text
11:09:28 <sm[m]> and keep upgrading your skills on the job
11:09:51 <quiet_laika[m]> MarcelineVQ: that makes sense
11:10:02 <awpr> (but note: if you're trying to replace `splitAt` with `uncons`, you might end up allocating lists or closures yourself)
11:10:10 <indian_yogi> ok, thanks for your advise
11:10:27 <MarcelineVQ> Yes, if you want to split at n, splitAt is your guy
11:11:22 <quiet_laika[m]> awpr: can i just use strictness annotations to avoid hurting myself there?
11:11:54 <quiet_laika[m]> MarcelineVQ: yeah looking more closely at the docs they call out that splitting functions don't allocate, and it seems like they specifically note all the functions that do
11:11:57 <merijn> What are you trying to do with the Text?
11:12:16 <merijn> Because repeatedly splitting sounds questionable
11:12:52 <awpr> strictness can't make data constructor allocations go away, but it can sometimes help with building up piles of thunks.  really it depends on the exact use case
11:13:11 <awpr> (from before, I gather the context is implementing a lexer effect for `freer-simple`)
11:13:17 <quiet_laika[m]> im implementing a "peek" function that takes a string and returns whether the string is a prefix of the input string... but now im realizing maybe i should just use `isPrefixOf` for that
11:13:34 <merijn> Yes :p
11:13:50 <quiet_laika[m]> :D glad i asked out loud
11:14:01 <awpr> with all these variations on `free` I wonder how long it'll be before someone uploads a `freer-simpler-faster-stronger` package
11:14:15 <merijn> Also, stripPrefix might be relevant
11:14:25 <merijn> stripPrefix is super flexible
11:14:43 <merijn> Because it combines "checking the prefix" and "splitting it off" into one thing
11:15:05 <merijn> Which I've found more useful than just isPrefixOf in many cases
11:15:30 <quiet_laika[m]> yes that could definitely be what i want
11:16:23 <quiet_laika[m]> im currently adapting my old plain recursive `State -> [Token]` functions (which had a ton of duplication) to work in an Effect, so the interface doesn't translate exactly
11:18:50 <ahmr88> Hi I'm relatively new to FP and was wondering is "call by name evaluation" and "lazy evaluation" basically different names for the same concept?
11:19:25 <berndl> Not really.
11:19:41 <berndl> Lazy evaluation as done in Haskell is "call by need".
11:20:18 <awpr> lazy evaluation is sometimes referred to as "call by need": rather than passing a full copy of a value ("call by value") or a reference to a (possibly-mutable) memory location ("call by name"), we pass sort of a recipe for how to compute a value if you need it
11:21:11 <awpr> so if a function never "looks at" one of its arguments, it might never be computed, and it was much cheaper to build the recipe (a "thunk") than to compute the full value
11:21:38 <sushi1234> Hello, i am working through the Monad Parsing. I have this example here https://pastebin.com/cVJChuR0. What I am trying to understand is when I run `a = return 1 :: Parser Int` and then `parse a "abcd"` it returns "[(1, "abcd")]
11:22:04 <ahmr88> Right. Thank you!
11:22:13 <sushi1234> what I am asking is how does the new Parser look like when created by `return` function
11:22:33 <dolio> That's not what call-by-name is.
11:23:05 <dolio> Call-by-name is when arguments are not evaluated until demanded, but computation is not shared.
11:23:17 <dolio> Call-by-need is when the computation is shared.
11:23:58 <berndl> sushi1234: Since return = pure, just look at the definition of pure
11:24:44 <sushi1234> berndl: oh, now it makes sense .. thanks
11:25:09 <ahmr88> So are "call by reference" and "call by name" the same thing?
11:25:26 <awpr> call-by-reference is the thing I mistakenly labeled as call-by-name
11:26:50 <awpr> it's more or less what Python or Java do for all (ish) function calls
11:28:23 <berndl> I'm still waiting for someone to make a call-by-push-value language.
11:30:31 <d34df00d> Like forth?
11:30:35 <monochrom> s/call by reference/pass by reference/  and is to be compared with pass-by-value.
11:30:44 <ahmr88> So my understanding is, call-by-name: evaluate arguments before function call, call-by-reference: pass memory locations, call-by-name: evaluate only when demanded (possibly multiple times), call-by-need: evaluate when demanded but memoise the result. Does this sound right?
11:30:56 <monochrom> and this axis is almost orthogonal to the call-by-* axis.
11:32:21 <dolio> Yeah, distinguishing between 'value' and 'reference' don't make much sense in the way a lot of semantics is structured, because it doesn't conflate variables with mutable references.
11:33:57 <dolio> You don't 'call-by-reference' you call-by-value with a reference value.
11:34:00 <wavemode> call by reference is just a special type of call by value, except the "values" are pointers to values.
11:34:29 <monochrom> why do you keep saying "call by reference"?  It's pass by reference.
11:35:30 <dolio> Who?
11:35:45 <monochrom> The lot of you.
11:35:46 <berndl> d34df00d: no, forth is not CBPV
11:36:01 <ahmr88> OK so... pass by reference is some sort of "call-by-value" and "call-by-need" is "call-by-name" where the value is memoised.
11:36:17 <monochrom> which is the main reason this is all conflating and confused.
11:43:45 * hackage shake 0.19 - Build system library, like Make, but more accurate dependencies.  https://hackage.haskell.org/package/shake-0.19 (NeilMitchell)
11:47:04 <steven_> merijn: what's the alternative to typeclass-based serialization?
11:47:16 <steven_> oh wow I was scrolled way up
11:48:58 <merijn> steven_: "function and values" :p
11:51:17 <steven_> yeah, and I guess that writing a typeclass instance with one function is similar to just passing a function, with the disadvantage that you need to make newtypes if you want different instances
11:55:26 <monochrom> What you gain is coherence: A suite of "f :: Ord a => ...; g :: Ord a => ..." are guaranteed to use the same comparator for the same type.  A suite of "f :: (a -> a -> Bool) -> ...; g :: (a -> a -> Bool) -> ..." cannot trust that the user is providing the same comparator for the same type.
11:56:05 <monochrom> So imagine f is binary search tree lookup, g is binary search tree insert, and the user erroneously provide <= for looup, => for insert.
11:57:16 <monochrom> So even if Ord had one method "leq" it would be worth the trouble.
11:58:25 <merijn> monochrom: That doesn't really apply for something as specific as serialisation, though
11:58:43 <merijn> monochrom: Because there's many reasons to want many different serialisations of the same type
11:59:15 * hackage JuicyPixels-blurhash 0.1.0.0 - Blurhash is a very compact represenation of a placeholder for an image  https://hackage.haskell.org/package/JuicyPixels-blurhash-0.1.0.0 (smprts)
12:32:15 * hackage splint 1.0.0.0 - HLint as a GHC source plugin.  https://hackage.haskell.org/package/splint-1.0.0.0 (fozworth)
13:13:09 <_d0t> ohai! I'm having troubles with building and installing haskell-language-server. Stack fails in the very beginning with this error https://bpa.st/MHDA What can I do with it?
13:13:22 <quiet_laika[m]> having trouble with my translation from direct recursion to a state-based effect... initially i recreating the `peek` (explicit n character lookahead and comparison) and `step` (manually step the lexer state forward n chars) combinators, but since they're in a monad it doesn't seem like i can easily pattern match on them. any ideas on translating the recursive logic to something that uses state? i can provide some
13:13:22 <quiet_laika[m]> code examples if need be
13:13:38 <quiet_laika[m]> (this is for a language lexer)
13:13:45 * hackage shakebook 0.3.1.0 - Shake-based technical documentation generator; HTML & PDF  https://hackage.haskell.org/package/shakebook-0.3.1.0 (locallycompact)
13:14:13 <Rembane> quiet_laika[m]: Save the old state in a variable, and put it back when you're done peeking 
13:25:39 <quiet_laika[m]> https://gist.github.com/matthewess/f0aa9ffdd42af4d2c78543e53cc64a32
13:28:56 <Welkin> nice spam
13:29:44 <MarcelineVQ> That isn't spam.
13:30:07 <mastarija> Any windows users here? I'm having some trouble installing network package. It just hangs on the build step no matter what I do.
13:30:11 <L29Ah> how do ppl generate simple instances of Arbitrary these days? are there some TH incantations to minimize boilerplate?
13:30:27 <L29Ah> i see derive package, but it's not maintained and depends on old libraries
13:31:46 * hackage taskwarrior 0.3.0.0 - Types and aeson instances for taskwarrior tasks  https://hackage.haskell.org/package/taskwarrior-0.3.0.0 (maralorn)
13:31:46 <maerwald> what is boilerplate?
13:31:50 <L29Ah> _d0t: you can write a bug report to the devs
13:32:13 <L29Ah> maerwald: instance Arbitrary Blah where blah blah blah
13:32:54 <maerwald> Hm, most of the arbitrary instances I write are manual, because they don't make much sense otherwise, but ok
13:33:15 <awpr> http://hackage.haskell.org/package/generic-random-1.3.0.1/docs/Generic-Random.html has been okay, with some caveats
13:33:35 <awpr> (like that the distribution you get is, well, arbitrary)
13:33:50 <L29Ah> awpr: yes, but it still requires me to write individual `instance`s unlike `derive`
13:34:08 <L29Ah> that's not very nice when you have a couple dozen of types
13:34:17 <awpr> you can make a `newtype WrappedGeneric a = WrappedGeneric a` to carry its instance
13:34:23 <L29Ah> i can always write a sed script and commit the result but that's not very nice
13:34:31 <awpr> and use `deriving Arbitrary via WrappedGeneric TheType`
13:34:46 <Welkin> I don't get this whole aversion to writing a few extra lines of code
13:34:56 <Welkin> you write code once, you read it many, many times
13:35:05 <Welkin> what's the problem with writing a few extra lines?
13:35:32 <L29Ah> awpr: https://github.com/l29ah/pontarius-xmpp/blob/master/tests/Tests/Arbitrary/Xmpp.hs#L67 i want this w/o using dead libraries in fact
13:35:54 <Welkin> xmpp is fun
13:36:22 <L29Ah> Welkin: the problem is that you just add ten additional words that are duplicated for every type
13:36:29 <L29Ah> that are the same
13:36:34 <awpr> if deriving clauses aren't good enough and only a TH splice is acceptable, then you can write a TH function if you really want to
13:36:36 <L29Ah> it's useless for reading
13:36:40 <Welkin> so what's the problem?
13:36:49 <Welkin> It's not ideal, but it's not blocking your work
13:37:11 <L29Ah> sure, i'm just perfecting my perfectionism (;
13:37:21 <awpr> my preferred point in this space, as GHC stands, is `DerivingVia` -- importantly it infers even the instance contexts for you, so if you add superclasses or mess with leaf instances, you don't have to update everything
13:37:34 <maerwald> Welkin: what makes me wonder more is that... in order to write useful arbitrary instances for non-trivial data, you almost always have to hand-tweak them
13:37:41 <maerwald> so you want manual instances anyway
13:38:01 <L29Ah> awpr: afaik there's no deriving clause for Arbitrary type sums
13:38:08 <L29Ah> looking into DerivingVia
13:39:10 <awpr> there's not a stock one, but you can wrap up `genericArbitraryU` into an instance on a newtype that can be used as `data TheType = <...> deriving Arbitrary via WrappedGeneric TheType`
13:39:15 <L29Ah> DerivingVia seems only useful for newtype's and otherwise synonyms
13:39:45 <awpr> it's useful for anything that can be wrapped in a newtype, too, which is everything
13:40:14 <awpr> `genericArbitraryU` works okayish enough on plain old sums of products, but hand-writing Arbitrary is definitely going to give better results
13:40:59 <awpr> if you just want "give me some values, I don't care about getting good coverage and I don't want to think about it", it'll do that
13:44:02 <monochrom> Randomization is pretty difficult.
13:46:18 <maerwald> Which is why I think quickcheck is oversold
13:46:24 <maerwald> It's hard to use properly
13:47:20 <monochrom> I think Rust is similar, with the replacement s/random/ownership/
13:47:46 <monochrom> Both randomization and ownership are pretty easy on basic types like int and string.
13:48:03 <monochrom> Then you try a recursive type and both blow up or implode.
13:48:52 <monochrom> s/basic types like int and string/basic types like int and string and their products/
13:49:07 <monochrom> s/products/products and sums/
13:50:18 <monochrom> But the elevator pitch is still pretty attractive because "a lot" of "real world" "applications" are just sums and products over int and string.
13:51:06 <Welkin> wrap them in opaque types that represent what they actually are
13:51:11 <monochrom> and if the standard library also magically takes cares of arrays, most "real world" "programmers" don't see a problem.
13:51:18 <Welkin> expose an API to them through a module
13:52:09 <monochrom> And this is when I would rather not be a "real world" "programmer".  Academia is more challenging than just slapping together a bunch of built-in types.
13:52:33 <Welkin> that depends on where you work
13:52:43 <Welkin> the larger your company, the more interesting the problems
13:52:54 <Welkin> just scaling something simple makes it enormously complex
13:52:59 <Welkin> it can be quite fun
13:53:09 <hpc> the trick is to work someplace where just slapping togehter a bunch of built-in types is somehow made challenging anyway :P
13:53:25 <awpr> aka somewhere they use protobuf
13:53:29 <hpc> no wait, that's horrible
13:56:09 <Welkin> fuzzy wuzzy was a bear
13:56:18 <Welkin> fuzzy wuzzy had no hair
13:56:27 <Welkin> fuzzy wuzzy wasn't fuzzy, was he?
13:56:44 <monochrom> perhaps it's "fur" not "hair"
13:56:57 <Welkin> nope, it's hair
13:57:03 <monochrom> The bear's name is "Fur Elise".
13:57:39 <maerwald> Für
13:58:05 <monochrom> Furry Elise.
13:58:17 <maerwald> She was pretty
13:58:28 <monochrom> Her friend, a fox, is Fast And Furrious
13:58:48 <maerwald> Oh boy, I should cover my innocent ears.
14:21:15 * hackage purescript 0.13.8 - PureScript Programming Language Compiler  https://hackage.haskell.org/package/purescript-0.13.8 (hdgarrood)
14:26:47 <d34df00d> Alright, I might be missing it, but is there a function like unfoldWhileM here ( http://hackage.haskell.org/package/monad-loops-0.4.3/docs/Control-Monad-Loops.html ) that _does not_ discard the last element?
14:35:15 <d34df00d> And how would you call such function?
14:46:15 <xerox_> d34df00d: I guess you could use untilM?
14:47:15 * hackage tidal 1.5.0 - Pattern language for improvised music  https://hackage.haskell.org/package/tidal-1.5.0 (AlexMcLean)
14:47:30 <d34df00d> xerox_: the predicate there is `m Bool` as opposed to `a -> Bool`.
14:50:57 <xerox_> if everything else fails you could snatch the implementation http://hackage.haskell.org/package/monad-loops-0.4.3/docs/src/Control-Monad-Loops.html#unfoldWhileM%27 and change the last line to return (x:xs)
14:51:15 <LevelChart8> How would I modify this to handle multiple OAuth cases/options? https://pastebin.com/mein5WYr
14:51:32 <d34df00d> xerox_: that's what I did for now, but I'm curious if there's a better way.
14:52:05 <xerox_> d34df00d: if one is interested in just the last element there are ways, but I don't see one that gives both the previous ones and the one failing the test
14:52:06 <d34df00d> Or maybe I should just contribute that variant back. How about the name `unfoldWhileIncludingM`?
14:52:25 <d34df00d> xerox_: yeah, I used iterateUntil previously, but then I realized I need all of the results.
14:52:42 <xerox_> iterateCollectingUntil hehe
14:52:43 <d34df00d> iterateWhile that is.
14:52:54 <d34df00d> xerox_: great name! Will use that.
15:06:05 <L29Ah> https://hackage.haskell.org/package/derive-2.6.5/docs/src/Data.Derive.Arbitrary.html#makeArbitrary oh boy, they generate generators
15:10:44 <koz_> L29Ah: Yo dawg, lol.
15:14:45 * hackage NaCl 0.0.1.0 - Easy-and-safe-to-use library for cryptography  https://hackage.haskell.org/package/NaCl-0.0.1.0 (kirelagin)
15:20:15 <monochrom> KCl is healthier than NaCl :)
15:21:17 <enikar> really?
15:21:22 <EvanR> NaOH is safer when electrolyzing water
15:23:45 * hackage pontarius-xmpp 0.5.6.1 - An XMPP client library  https://hackage.haskell.org/package/pontarius-xmpp-0.5.6.1 (SergeyAlirzaev)
15:23:46 <L29Ah> enikar: nah, just people tend to overdo Na+ and eat too little K+
15:25:11 <enikar> L29Ah: ok
15:25:17 <maralorn> Is it allowed to drop trailing .0 when following PVP versioning guidlines.
15:25:33 <maralorn> I notice that shake is doing this. 0.19 followed 0.18.5
15:26:12 <L29Ah> is it possible to ask hackage to rebuild a package?
15:31:45 * hackage cabal-appimage 0.3.0.0 - Cabal support for creating AppImage applications  https://hackage.haskell.org/package/cabal-appimage-0.3.0.0 (GabrieleSales)
15:36:15 <Taneb> aa/exit
15:51:30 <solonarv> maralorn: IIRC 0.19.0 and 0.19 aren't actually equivalent, but if people write their version constraints in a sane way it doesn't matter much
15:52:45 * hackage benchpress 0.2.2.14 - Micro-benchmarking with detailed statistics.  https://hackage.haskell.org/package/benchpress-0.2.2.14 (willsewell)
15:56:44 * hackage idris 1.3.3 - Functional Programming Language with Dependent Types  https://hackage.haskell.org/package/idris-1.3.3 (niklasl)
16:49:05 <jacks2> @hoogle (a -> c) -> (b -> c) -> Either a b -> c
16:49:05 <lambdabot> Prelude either :: (a -> c) -> (b -> c) -> Either a b -> c
16:49:05 <lambdabot> Data.Either either :: (a -> c) -> (b -> c) -> Either a b -> c
16:49:05 <lambdabot> Test.Hspec.Discover either :: () => (a -> c) -> (b -> c) -> Either a b -> c
16:58:14 <jacks2> @hoogle isjust
16:58:14 <lambdabot> Data.Maybe isJust :: Maybe a -> Bool
16:58:14 <lambdabot> Distribution.Compat.Prelude.Internal isJust :: () => Maybe a -> Bool
16:58:14 <lambdabot> Network.AWS.Prelude isJust :: () => Maybe a -> Bool
16:58:38 <jacks2> @hoogle isRight
16:58:38 <lambdabot> Data.Either isRight :: Either a b -> Bool
16:58:39 <lambdabot> Data.Either.Combinators isRight :: Either a b -> Bool
16:58:39 <lambdabot> Data.Either.Compat isRight :: () => Either a b -> Bool
17:00:15 * hackage ghc-lib-parser 8.10.1.20200523 - The GHC API, decoupled from GHC versions  https://hackage.haskell.org/package/ghc-lib-parser-8.10.1.20200523 (shayne_fletcher)
17:00:44 <infinisil> @hoogle isWrong
17:00:44 <lambdabot> Debug.Hoed.CompTree isWrong :: Vertex -> Bool
17:01:06 <hpc> you can pm lambdabot btw, if this isn't building up to some sort of discussion
17:01:15 * hackage ghc-lib 8.10.1.20200523 - The GHC API, decoupled from GHC versions  https://hackage.haskell.org/package/ghc-lib-8.10.1.20200523 (shayne_fletcher)
17:01:49 <jacks2> yeah I forgot
17:13:07 <ezzieyguywuf> so let's say I *do* want te pretty print a Data.Map (in fact, I have three similar but distinct Data.Map, thus I want to create a `class PrettyPrinter...` rather than just a `prettyPrintMyMap` function.) is the best (only?) way to do this to `newtype` each Data.Map and then define the appropriate PrettyPrinter instance for each?
17:14:26 <solonarv> what's wrong with three top-level 'prettyPrintSpecificMap' functions?
17:15:22 <ezzieyguywuf> `prettyPrintMyFirstMap` , `prettyPrintMySecondMap`, etc?
17:15:25 <EvanR> yeah this doesn't seem like a good time to create a type class. Just make different pretty printer functions
17:15:25 <ezzieyguywuf> seems clunky
17:15:40 <ezzieyguywuf> but i dunno, like I've said before I'm pretty new to haskell and not familiar with the typical idioms
17:15:55 <EvanR> you either don't gain anything from it or you need to invent a whole pretty printer library and support for many types
17:15:57 <ezzieyguywuf> well then, if that's how it seems, that is what I shall do :)
17:16:18 <EvanR> that being said, there are several pretty printer packages
17:16:20 <ezzieyguywuf> i want it for debugging, so probably the specific functions is what I want
17:30:10 <solonarv> ezzieyguywuf: a typeclass would be reasonable if you wanted to prettyprint a bunch of different types
17:30:38 <solonarv> but a typeclass + 3 newtypes, so you can have 3 different functions for th same type, is pretty suspect
17:57:36 <theuser> ls
18:05:15 * hackage cyclotomic 1.1.1 - A subfield of the complex numbers for exact calculation.  https://hackage.haskell.org/package/cyclotomic-1.1.1 (ScottWalck)
18:25:45 * hackage source-constraints 0.0.1 - Source constraints GHC plugin  https://hackage.haskell.org/package/source-constraints-0.0.1 (mbj)
18:28:01 <LevelChart8> Can anyone give me a hint on where / how to put a case statement to make this able to handle more than one OAuth method? https://pastebin.com/mein5WYr
18:28:20 <LevelChart8> The code currently handles Facebook, but I want to add Google and Apple
18:28:35 <LevelChart8> but I am not sure where to start editing this
18:33:45 * hackage timespan 0.4.0.0 - Useful timespan datatype and functions  https://hackage.haskell.org/package/timespan-0.4.0.0 (AlexanderThiemann)
18:46:08 <EvanR> I am morbidly curious about this web code
18:49:34 <dsal> I like :/ as an operator.  Inspires confidence.
18:51:01 <L29Ah> :*
18:51:35 <L29Ah> dsal: https://hackage.haskell.org/package/stm-conduit-4.0.1/docs/Data-Conduit-Async.html how confident are those?
18:52:08 <dsal> Those make sense somewhat m
18:52:28 <awpr> feature request for `-XUnicodeSyntax`: interpret emojis as equivalent to their ASCII forms
18:53:38 <MarcelineVQ> I can't wait for the indentation errors
18:54:15 <dsal> I wonder how the fights about making λ an operator go.
18:55:29 <wavemode> I will accept it just as soon as they add it to the qwerty keyboard
18:55:34 <wavemode> so never
18:55:57 <dsal> You don't have a qwertλ keyboard?
18:57:00 <ezzieyguywuf> solonarv: thanks for the insight.
19:00:15 <koz_> How do packages get added to LTS snapshots?
19:00:25 <koz_> (or rather, can you request this?)
19:00:33 <koz_> (or is it just osmething that magically happens occasionally)
19:00:41 <dsal> A pull request, afaict
19:00:46 <wavemode> a package that's on stackage? or not
19:01:05 <koz_> wavemode: It's on Stackage, but only in the latest nightly.
19:01:25 <koz_> dsal: I PRed for inclusion on Stackage as-such (and it got accepted). Didn't find anything specifying what you gotta do for LTSing.
19:01:29 <wavemode> I assume it automatically becomes part of the next LTS, no?
19:01:43 <dsal> It's it recent?  It might just graduate into the next major LTS
19:01:51 <koz_> dsal: It's it very recent.
19:01:57 <dsal> I should stick some of my stuff in there.
19:07:15 * hackage mprelude 0.1.0 - A minimalish prelude.  https://hackage.haskell.org/package/mprelude-0.1.0 (mbj)
19:08:10 <dsal> I should have a minimal prelude.   I'd just export `id`.
19:12:47 <koz_> dsal: You mean 's', 'k' and 'i' right?
19:13:38 <monochrom> Since Haskell has lambda already, don't even export id. :)
19:13:45 * hackage typed-encoding 0.3.0.1 - Type safe string transformations  https://hackage.haskell.org/package/typed-encoding-0.3.0.1 (rpeszek)
19:20:25 <wavemode> to be truly minimal, only export Category. the user can define their own id
19:21:41 <L29Ah> how do i disable if syntax
19:21:59 <L29Ah> that's an absolutely superficial special case
19:22:04 <monochrom> cannot
19:22:43 <L29Ah> wtf even Idris has this garbage
19:23:40 <MarcelineVQ> you can just not use a thing, if isn't a security risk to use so the option of its presence shouldn't be world ending :X
19:23:58 <L29Ah> MarcelineVQ: i want to use a function named "if"
19:24:15 <L29Ah> specifically, if :: Bool -> a -> a -> a
19:25:23 <L29Ah> @hoogle Bool -> a -> a -> a
19:25:23 <lambdabot> Data.Bool.HT if' :: Bool -> a -> a -> a
19:25:24 <lambdabot> Data.Bool.HT ifThenElse :: Bool -> a -> a -> a
19:25:24 <lambdabot> NumericPrelude ifThenElse :: () => Bool -> a -> a -> a
19:25:25 <MarcelineVQ> ah alright. often people would write if' there
19:26:58 <MarcelineVQ> bool  exists as well but the order is different than you'd be inlined to write for if', it matches the datatype definition in the same way that  maybe  and  either  do. so False is first, then True
19:27:02 <MarcelineVQ> :t bool
19:27:04 <lambdabot> a -> a -> Bool -> a
19:27:50 <L29Ah> > bool 1 2 True
19:27:51 <lambdabot>  2
19:28:23 <wavemode> can't you define your own ifThenElse function with RebindableSyntax
19:28:44 <L29Ah> @hoogle (a->b->c->d)->c->b->a->d
19:28:44 <lambdabot> Data.Function.Flip flip3 :: (a -> b -> c -> d) -> c -> b -> a -> d
19:28:44 <lambdabot> Data.Function.Flip (<-->) :: (a -> b -> c -> d) -> c -> b -> a -> d
19:28:56 <wavemode> but that doesn't let you use if as a function, it's still reserved
19:29:26 <awpr> this sounds like a feature request for `-XNoSyntax`
19:29:51 <L29Ah> (yes)
19:38:45 * hackage devtools 0.0.1 - Haskell development tool agregate  https://hackage.haskell.org/package/devtools-0.0.1 (mbj)
19:39:13 <solonarv> oof, the parser is enough of a mess already! this would make it so much worse
19:40:07 <awpr> you may be imagining a too-narrowly-scoped form of `-XNoSyntax`
19:40:24 <solonarv> if it's a language extension then it has to be per-module
19:40:25 <awpr> disabling all of the syntax would be quite easy: anything other than EOF is a parse error
19:40:32 <solonarv> oh haha
19:40:38 <solonarv> okay fair enough!
19:42:22 <awpr> a slight deficiency: if you turn it on project-wide in a .cabal file, you can't turn it back off per-module since the syntax for LANGUAGE pragmas no longer exists
19:44:07 <wavemode> hahaha
20:03:17 <c_wraith> Huh.  I can't seem to find this in the docs.  Can you antiquote a constructor name into a data type TH quote?  Like  [| data Foo = $(something calculated) |])
20:21:29 <solonarv> I think you can only antiquote things it's possible to quote in the first place, but don't quote me on that
20:21:48 <wavemode> I'll antiquote you on it
20:22:17 <solonarv> % :t \con -> [d| data Foo = $(con) |]
20:22:17 <yahb> solonarv: ; <interactive>:1:24: error:; Cannot parse data constructor in a data/newtype declaration:; $(con)
20:22:24 <solonarv> well, there's your answer
20:22:29 <c_wraith> Yeah, I've confirmed you can't do it.  So..  writing a DataD expression by hand.  why not?
20:22:57 <solonarv> yeah, I've run into that issue as well
20:23:26 <solonarv> there are only four syntactic forms you can quote/antiquote/splice: type, expression, pattern, declaration
20:39:06 <edwardk> awpr: the problem with NoSyntax is where do you put the language pragma? So confused.
20:39:31 <awpr> well the syntax exists up until the point where you turn it off
20:39:58 <awpr> ideally that would be the end of the `NoSyntax` token, but pragmatically I think we have to accept the following `#-}` token as well
20:40:11 <Arahael> I'm looking for an `[a] -> [b] -> [c] -> [(a, b, c)]` where the resulting tuple consists of every permutation of those inputs. (ie, is not zip)
20:40:52 <wavemode_> > [(a, b, c) | a <- [1, 2], b <- [3, 4], c <- [5, 6]]
20:40:54 <lambdabot>  [(1,3,5),(1,3,6),(1,4,5),(1,4,6),(2,3,5),(2,3,6),(2,4,5),(2,4,6)]
20:41:26 <Arahael> Ah, that's elegant enough - thanks, didn't think to use a list comprehension.
20:41:32 <edwardk> awpr: i dunno. there is a delightful asymmetry in requiring the user to type {-# LANGUAGE NoSyntax
20:42:21 <edwardk> you can emulate it with a compiler plugin i guess, til you get someone to let you have your extension
20:42:34 <fpaulw> > liftA3 (,,) [1,2] [3,4] [5,6]]
20:42:36 <lambdabot>  <hint>:1:30: error: parse error on input ‘]’
20:42:52 <fpaulw> another method, sans typo
20:43:19 <fpaulw> > liftA3 (,,) [1,2] [3,4] [5,6]
20:43:21 <lambdabot>  [(1,3,5),(1,3,6),(1,4,5),(1,4,6),(2,3,5),(2,3,6),(2,4,5),(2,4,6)]
20:45:21 <Arahael> That's nice too - I'm not sure which one is "better" - I think ostensibly, the list comprehension is clearer?
20:46:35 <fpaulw> I think the list comprehension is more obvious about intention, yes
20:49:50 <Arahael> Awesome, glad I'm thinking along similar lines.
21:11:50 <fog> so, for traversing hetrogenous containers, i have something like zipwith instead of fmap - meaning some kind of hetrogenous applicative should be used 
21:12:01 <fog> then, for traverse;
21:12:04 <fog> :t traverse
21:12:05 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
21:12:27 <fog> the first argument is kind of like a combination of fmap and pure
21:12:47 <fog> instead, this would be the zipwith style applicative thing
21:12:56 <fog> so that there would be 2 applicative constraints
21:13:15 <fog> one over f, and one for the associated types for the hetrogenous fmaps
21:13:27 <fog> i have no idea how to write this
21:14:04 <fog> is the idea about zipwith applicative instead of functor clear?
21:15:29 <fog> basically because you need one mapping function at both type and value level for the hetrogenous fmap
21:15:43 <fog> :t <*>
21:15:45 <lambdabot> error: parse error on input ‘<*>’
21:15:50 <fog> :t (<*>)
21:15:51 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
21:16:02 <fog> :t fmap
21:16:03 <lambdabot> Functor f => (a -> b) -> f a -> f b
21:16:43 <fog> you need an `f' of mapping functions (and the Proxy type defunctionalised families for mapping the types)
21:17:30 <fog> (Applicative' f,Applicative g) => f (a -> g b) 
21:17:38 <fog> is then like the first argument of traverse
21:17:40 <fog> :t traverse
21:17:42 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
21:18:42 <fog> argh! thats wrong, its supposed to use the type mapping function to get each `b' for each different `a'
21:18:58 <c_wraith> I think I've abused haskell too far for one night.  https://gist.github.com/chowells79/1d3560bdd7edd84de8c82c87e96cfaea  (this is a revision of something I did a couple days ago, to be even more ridiculous now)
21:21:49 <fog> i dont understand the TH
21:22:28 <fog> but the ability to use reifyInstances looks alluring
21:25:12 <c_wraith> I made Haskell feel like a dynamic language where you run code that modifies a global namespace and then other code looks at that modified namespace...  all during compilation.
21:25:58 <fog> i dont see where Test gets imported
21:26:16 <fog> or where Class is defined
21:26:24 <fog> (an import of your Main)
21:27:42 <fog> uh, i mean, where Test is used in First and Second
21:27:57 <c_wraith> they call testCase
21:28:30 <fog> oh yeah, your splitting the function definition over modules! mental
21:29:34 <fog> ok, but where is makeTestableTable used?
21:29:36 <awpr> if you make sure they're always orphan instances then all modules will have to propagate them upwards towards Main
21:30:08 <fog> so it doesnt need to reexport the module?
21:30:23 <c_wraith> makeTestableTable is used in Main
21:30:46 <fog> yeah, but Test isnt imported by Main
21:30:56 <awpr> I think all instances of an imported class for a `Symbol` are orphans, right?
21:31:00 <fog> only Class, which isnt defined in your gist
21:31:01 <c_wraith> that's a typo...
21:31:14 <c_wraith> I didn't update that file when I updated the gist last
21:31:15 <fog> thats what i was getting at, ok, its more clear now
21:31:18 <c_wraith> the only change was that import
21:31:41 <c_wraith> fixed now
21:32:20 <fog> so whats all this TH doing?
21:32:56 <c_wraith> creating data types and instances, then gathering all the in-scope instances
21:33:45 <fog> that sounds pretty powerful, damn, i thought i could avoid using template haskell for ever!
21:33:57 <c_wraith> You should.  Don't take inspiration from that!
21:34:29 <fog> yeah, but eg. i would need a bunch of reified instances every time i write a hetrogenous fmap
21:35:23 <fog> hmm, actually I was thinking the applicate zipwith was better, since eg. if a HList had two values of the same type, but you wanted to map them to different types
21:35:41 <fog> the alternative would be to use imap
21:35:54 <fog> and take the position into consideration as a singleton Int 
21:36:08 <fog> in order to determine the type family mapping the types
21:36:36 <fog> but then it just seems easier to do zipWith
21:37:04 <fog> possibly with a way of copying the "shape" of the container being mapped over, eg. so you could map from position to type mapping function
21:37:22 <fog> it a total mess tbh
21:38:12 <fog> maybe a better way to understand what HTraversable would be is to instead focus on HFoldable and HUnfoldable
21:38:41 <fog> and write HConvertable in terms of HGet and HSet, and use that as a default instance for HTraverse
21:38:58 <fog> and use hConvert as a default for hTraverse*
21:39:24 <fog> so then I only need to worry about the HGet and HSet classes
21:39:57 <fog> basically, you just need, eg. for HGet, a way to get the type of the head and tail of a Hcontainer
21:40:56 <fog> and then its still unclear if this should abstract over the kind like; [Type] -> * , or just make the instances over types of kind *
21:41:04 <crestfallen> @let divisibleBy = (( 0 == ) . ) . mod
21:41:05 <lambdabot>  Defined.
21:41:29 <crestfallen> can't get my head around this (pointfree?) function
21:42:07 <fog> :t ((.).(.))
21:42:09 <lambdabot> (b -> c) -> (a1 -> a2 -> b) -> a1 -> a2 -> c
21:42:23 <crestfallen> oh no please don't
21:42:25 <awpr> :t on
21:42:27 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
21:42:38 <wavemode_> @pointful divisibleBy = (( 0 == ) . ) . mod
21:42:38 <lambdabot> divisibleBy x x0 = 0 == mod x x0
21:42:59 <ja> oh that's cool, didn't know there was a pointful too
21:43:12 <crestfallen> yeah I understand the pointful 
21:43:29 <fog> :t \f -> (f.(.))
21:43:31 <lambdabot> (((a -> b) -> a -> c1) -> c2) -> (b -> c1) -> c2
21:43:35 <crestfallen> but is that partial application with mod in the pointfree vers?
21:43:52 <awpr> `(f .) . g` is a somewhat ugly way to write "take two arguments, pass them to g, and pass the result to f"
21:44:11 <ja> crestfallen: how can it be partial application if there is no arguments after mod?
21:44:32 <fog> :t \f g -> (f .) . g
21:44:33 <lambdabot> (b -> c) -> (a1 -> a2 -> b) -> a1 -> a2 -> c
21:44:34 <awpr> the partial application is referring to the type that the outermost `.` is working on
21:45:23 <awpr> i.e. if you chop up that definition into functions that are composed together, it's `mod :: Int -> (Int -> Int)` and `((==0) .) :: (Int -> Int) -> (Int -> Bool)`
21:45:42 <wavemode_> (f .) . g => you call g on a value, then compose the resulting function with f
21:46:12 <crestfallen> so g takes a single value first say
21:46:35 <crestfallen> > (mod 10) 5
21:46:37 <lambdabot>  0
21:47:00 <fog> ((f .) . g) a b = (((f .) . g) a) b = ((f .) (g a)) b = (f . (g a)) b = f (g a b)
21:47:01 <crestfallen> in this case:
21:47:23 <crestfallen> :t \f g -> (f . ) . g
21:47:24 <lambdabot> (b -> c) -> (a1 -> a2 -> b) -> a1 -> a2 -> c
21:47:48 <wavemode_> mod takes two arguments, so calling it on one value returns a function that is still awaiting one argument. you then compose that function with (0 ==)
21:48:36 <crestfallen> yeah so for a second there it is partial application, like mod x
21:48:50 <fog> ((f . ) . g)  a = f . (g a)
21:48:55 <crestfallen> then it is composed ..
21:48:57 <awpr> there are many compose-twice functions lying around that might make this clearer; let's see if lambdabot knows them:
21:49:03 <awpr> :t compose2
21:49:04 <lambdabot> error:
21:49:04 <lambdabot>     • Variable not in scope: compose2
21:49:04 <lambdabot>     • Perhaps you meant ‘icompose’ (imported from Control.Lens)
21:49:09 <awpr> :t (.:)
21:49:10 <lambdabot> error:
21:49:10 <lambdabot>     • Variable not in scope: .:
21:49:10 <lambdabot>     • Perhaps you meant one of these:
21:49:36 <awpr> @let (.:) = (.).(.)
21:49:37 <lambdabot>  Defined.
21:49:48 <awpr> :t (==0) .: mod
21:49:50 <lambdabot> Integral a => a -> a -> Bool
21:50:10 <awpr> there: compose equality with zero past two arguments
21:52:25 <ja> @pointful divisibleBy2 = (==0) .: mod
21:52:25 <lambdabot> divisibleBy2 = (\ a0 -> a0 == 0) .: mod
21:54:18 <ja> > 17 `divisibleBy2` -1
21:54:20 <lambdabot>  error:
21:54:20 <lambdabot>      • Variable not in scope: divisibleBy2 :: Integer -> Integer -> t
21:54:20 <lambdabot>      • Perhaps you meant ‘divisibleBy’ (line 180)
21:54:22 <ja> > 17 `divisibleBy2` (-1)
21:54:24 <lambdabot>  error:
21:54:24 <lambdabot>      • Variable not in scope: divisibleBy2 :: Integer -> Integer -> t
21:54:24 <lambdabot>      • Perhaps you meant ‘divisibleBy’ (line 180)
21:54:32 <ja> oh
21:56:28 <crestfallen> wavemode_ ja awpr   yeah thanks it's sinking in...
21:57:12 <crestfallen> I was trying to do this in ghci :
21:57:49 <crestfallen> > ((0 ==) . ) 4 . mod 2
21:57:50 <lambdabot>  <Integer -> Bool>
21:58:31 <crestfallen> what's that output?
21:58:58 <crestfallen> > ((0 ==) . ) 2 . mod 4
21:59:00 <lambdabot>  <Integer -> Bool>
21:59:20 <crestfallen> weird
21:59:22 <MarcelineVQ> some function expecting an Integer and giving a Bool
21:59:32 <awpr> it appears to be confused, in that it just ignored some constraints that won't actually be solvable
21:59:49 <wavemode_> actually, that's not really valid
22:00:09 <MarcelineVQ> it's really valid
22:00:11 <awpr> I think its algorithm is: default things aggressivel, ignore constraints, and print the type in brackets
22:00:28 <MarcelineVQ> ((0 ==) . ) 2 . mod 4 :: (Integral a1, Num a2, Num (a1 -> a2), Eq a2) => a1 -> Bool
22:00:28 <awpr> because there's secretly a `Num (Integer -> a2)` constraint in there
22:00:55 <ja> in lambdabot? or haskell generallt?
22:01:02 <wavemode_> ski made a num instance for functions in lambdabot
22:01:02 <MarcelineVQ> All you need is an instance for Num (a1 -> a2) and we can get a Bool, just because Prelue doesn't have one doesn't mean it's not valid
22:01:08 <crestfallen> > ((0 ==) . ) 2 . mod 4
22:01:10 <lambdabot>  <Integer -> Bool>
22:01:28 <crestfallen> so at least in principle that is how you would write it to get True
22:01:56 <awpr> not really; that's highly misleading output on lambdabot's part
22:02:00 <wavemode_> no, it wouldn't work in general
22:02:16 <awpr> > ((0==) .) . mod) 4 2
22:02:17 <lambdabot>  <hint>:1:16: error: parse error on input ‘)’
22:02:18 <crestfallen> ok, well it is interesting
22:03:00 <crestfallen> > ((0 ==) . )  . (mod 4 2)
22:03:02 <lambdabot>  error:
22:03:02 <lambdabot>      • Could not deduce (Integral (a1 -> a2 -> a0))
22:03:02 <lambdabot>          (maybe you haven't applied a function to enough arguments?)
22:03:09 <awpr> if I could manage to type the right number of parens, that'd be the way to apply it
22:04:21 <ja> % (((0 ==) . ) . mod) 4 2
22:04:21 <yahb> ja: True
22:06:04 <crestfallen> > (((0 ==) . )  . mod )4 2
22:06:06 <lambdabot>  True
22:06:41 <crestfallen> so 2 hangs out until (mod 4) is composed with the rest of it
22:07:24 <crestfallen> is that essentially correct ? ^
22:07:35 <ja> what do you mean hangs out? the four is applied first, not the two
22:08:18 <crestfallen> yeah that's what I mean . 2 is passed in to the composed function with argument 4
22:08:46 <crestfallen> yeah that's what I mean . 2 is passed in to the (composed function with argument 4)
22:09:15 * hackage web3 0.9.0.0 - Web3 API for Haskell.  https://hackage.haskell.org/package/web3-0.9.0.0 (akru)
23:35:15 * hackage calamity 0.1.9.2 - A library for writing discord bots  https://hackage.haskell.org/package/calamity-0.1.9.2 (nitros12)
