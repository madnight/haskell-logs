00:16:02 <p0a> When I document a constructor how can I make it show in haddock?
00:16:10 <p0a> I tried this https://www.haskell.org/haddock/doc/html/ch03s02.html#idm140354810896272 but it doesn't show up 
00:18:01 <phadej> show your code
00:19:57 <p0a> https://pastebin.com/j7b12SQc
00:20:30 <scasc> @p0: f :: Float -> Float cannot take a Double because you declared it to work only on Floats.
00:20:30 <lambdabot> (line 1, column 14):
00:20:30 <lambdabot> unexpected '>'
00:20:30 <lambdabot> expecting operator
00:20:46 <scasc> p0a I mean
00:21:09 <scasc> What you want is f :: Fractional a => a -> a
00:21:19 <scasc> Then you can use f with both Float and Double
00:22:20 <phadej> p0a: you have to export Shape constructors
00:22:23 <phadej> Shape (..)
00:22:24 <Axman6> p0a: I don't know for sure what the issue is, but generally I would use the -- ^ style documentation for constructors: Circle Point Float -- ^ A circle
00:22:30 <p0a> OH I did it again
00:22:34 <p0a> phadej: thank you 
00:22:54 <p0a> Axman6: thank you. I also wanted to use the -- ^ but the docs mentioned -- | and I thought maybe that was my mistake 
00:22:57 <p0a> I suppose they're interchangeable
00:23:06 <phadej> prefix and suffix
00:23:24 <phadej> with GADT syntax prefix looks nicer
00:23:31 <phadej> in my opinion
00:23:31 <Axman6> agreed
00:26:39 <d2ci8xc5> I'm having trouble with an exercise. I have to replace the word "the" in a sentence with the word "a"
00:27:00 <d2ci8xc5> I've written a function notThe :: String -> Maybe String
00:27:12 <d2ci8xc5> but am having trouble from there on
00:27:39 <koz_> d2ci8xc5: Is this homework?
00:30:42 <MarcelineVQ> it's okay if it is, it'll just change how people answer so they don't just spoil it
00:31:03 <MarcelineVQ> can't do any learning if you already have the answers
00:38:17 <MarcelineVQ> alright :>
00:46:36 <jophish> angerman: I had a cursory look at the names of the patches that haskell.nix applies to GHC, but nothing jumped out
00:46:38 <jophish> RE https://github.com/input-output-hk/haskell.nix/issues/553#issuecomment-622264223
00:46:59 <jophish> i.e. there was no patch named "fix-th-typechecker.patch"
00:47:19 <p0a> where can I read about the Data.Map.Map type constructor here? https://hackage.haskell.org/package/containers-0.6.2.1/docs/Data-Map.html
00:47:23 <p0a> I don't see where it is in the page 
00:47:24 <angerman> jophish: yea, I'd doubt we'd be doing severe surgery on ghc. :-/ 
00:48:02 <angerman> jophish: it's quite baffling that this even leads to any noticable difference. And quite frankly I find this somewhat scary.
00:53:08 <c_wraith> p0a: you aren't meant to use the constructor.  If you could, you could build trees that aren't binary search trees, which would break lots of functions that assume they are
00:54:09 <c_wraith> p0a: and in fact, the constructor isn't exported from the module, so you can't use it.  You can use things like empty, singleton, or fromList to create Map values
00:54:23 <p0a> c_wraith: okay it was used in the "learn you a haskell" book :/
00:54:33 <p0a> c_wraith: look up "lockermap"
00:54:38 <p0a> LockerMap to be accurate 
00:55:09 <c_wraith> well, that sounds like something different from Data.Map.Map
00:55:20 <p0a> I don't understand, that's what it look like they are using 
00:55:39 <p0a> "import Data.Map as Map ... Map.Map Int (LockerState, Code)"
00:56:48 <Axman6> what do you want to know about Map?
00:56:55 <c_wraith> Ah.  Ok, it's using Data.Map, but LockerState is just part of the value stored in the Map
00:57:20 <Axman6> everything you need to know about it is in the haddocks for Data.Map - it tells you the functions which can be used to work with a Map, without needing to know how it's implemented
00:57:22 <p0a> Axman6: they are using Data.Map.Map and I wanted to read about it but when I looked up the page in the docs I didn't see it
00:57:45 <p0a> Axman6: https://hackage.haskell.org/package/containers-0.6.2.1/docs/Data-Map.html
00:57:55 <p0a> I only see 5 functions there
00:58:03 <Axman6> look in Data.Map.Lazy
00:58:10 <p0a> and some Whoops there, what's happening there?
00:58:14 <Axman6> first thing linked in the documentation
00:58:15 * hackage haskoin-store 0.23.10 - Storage and index for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-store-0.23.10 (jprupp)
00:58:19 <c_wraith> The "module Data.Map.Lazy" line means it re-exports everything from the other module
00:58:56 <p0a> so Data.Map.Lazy is "larger"?
00:59:16 <Axman6> it has more code, sure
00:59:25 <c_wraith> Data.Map exports more things
00:59:25 <Axman6> it's where Map is actually implemented
00:59:40 <p0a> oh wait now I get it 
00:59:46 <p0a> Data.Map.Lazy is a submodule of Data.Map
01:00:06 <c_wraith> Better to just think in terms of "re-exports"
01:00:12 <Axman6> we don't really have submodules, though yes you can think of it like that
01:00:29 <Axman6> Data.Map reexports everything in Data.Map.Lazy
01:00:33 <p0a> so how am I to read `data Map k a' ?
01:00:35 <c_wraith> modules export things.  a module can export things defined in other modules.  It can even do that for a whole module
01:01:07 <p0a> I am not really thinking of it in terms of other programming languages or anything -- `sub' is just a way for me to point out that there's a dot (.) 
01:01:11 <Axman6> you read it as an opaque type which you don't need to know the details of its implementation.
01:01:31 <p0a> ah, got it
01:01:31 <jophish> angerman: I agree, it's quite concerning
01:01:34 <Axman6> you need to look at the functions which operate on Maps to understand the interface you should use
01:01:41 <jophish> I wasn't able to reproduce this anywhere but 'reify'
01:01:51 <p0a> right, thank you c_wraith & Axman6 
01:03:00 <Axman6> insert :: Ord k => k -> a -> Map k a -> Map k a ,_  so much info about maps!
01:03:13 <Axman6> lookup :: Ord k => k -> Map k a -> Maybe a <- even more!
01:03:32 <p0a> not sure why the keys need to be ordered
01:03:48 <koz_> p0a: Because that's how binary search trees work.
01:03:50 <c_wraith> Implementation detail, roughly.
01:04:01 <p0a> koz_: right but a general Map doesnt' make me think of ordered keys
01:04:07 <koz_> Essentially, they allow you to eliminate half of all possibilities per comparison.
01:04:10 <p0a> so it's not entirely fair to say that everything is immediately deducible
01:04:14 <koz_> p0a: Yeah, but you gotta implement it somehow.
01:04:23 <koz_> Balanced binary search trees are one strategy to do this.
01:04:23 <p0a> in common lisp for example
01:04:28 <koz_> However, they require ordered keys.
01:04:34 <p0a> you have hash tables with keys being any object in the language
01:04:43 <koz_> Any _hashable_ object.
01:04:43 <c_wraith> that sounds buggy
01:04:48 <koz_> c_wraith: It is!
01:04:55 <koz_> Because Common Lisp has three different forms of equality.
01:04:58 <p0a> :D lol koz_ didn't think you'd have experience with that
01:05:04 <koz_> And its hash tables vary based on whatever choice you make.
01:05:13 <koz_> p0a: I have a Master's degree in data structures.
01:05:20 <koz_> Common Lisp was my _second_ programming language.
01:05:28 <p0a> lol
01:05:32 <koz_> I also generally don't criticise what I don't understand.
01:05:56 <koz_> Basically, Map is an dictionary implemented atop a self-balancing binary tree.
01:06:06 <p0a> right
01:06:08 <koz_> (an _immutable_ self-balancing binary tree at that)
01:06:20 <p0a> yeah that's definitely the weirder part of it
01:06:27 <koz_> You can implement a dictionary atop a hashtable, but that can't be done immutably with the same perf guarantees.
01:06:30 <koz_> Why do you consider it weird?
01:06:40 <p0a> I'm entirely unfamiliar with how that'd look like
01:06:41 <koz_> It is not only sensible, but actually asymptotically optimal in an immutable setting.
01:06:49 <koz_> p0a: Go read any data structures book.
01:06:51 <p0a> The only thing I know is how to implement an immutable linked list 
01:07:01 <p0a> by returning a lambda that captures it
01:07:12 <koz_> p0a: You can just use tail sharing.
01:07:26 <koz_> You get O(1) copying as long as you manipulate only the head.
01:07:41 <koz_> For self-balancing binary trees, it's log(n) copying by path sharing.
01:07:59 <p0a> sorry I Don't follow
01:08:02 <koz_> (red-black trees are the most well-known, but you can do it with many others)
01:08:06 <p0a> It's really late I'm not in my best right now
01:08:14 * hackage zre 0.1.0.2 - ZRE protocol implementation  https://hackage.haskell.org/package/zre-0.1.0.2 (srk)
01:08:15 <p0a> you're setting me up for bed
01:08:17 <koz_> p0a: And this is exactly why I suggested reading a data structures book. Thoroughly. When awake.
01:08:25 <p0a> right :P 
01:08:31 <koz_> Otherwise, just assume implementations are magic and work by magic.
01:08:42 <koz_> Because without that knowledge, it might as well be.
01:08:54 <p0a> :<
01:09:57 <p0a> righto I'm going to rest now, thank you all for your help. I read as far as the middle of Ch8 of learn you a haskell. I hope tomorrow to get going with some File I/O and Graph algorithms. (maybe ambitious?)
01:11:07 <koz_> Also, amusingly, I'm reading Richard Bird's book on functional algorithm design.
01:11:18 <Axman6> we also have avery good implementation of an immutable "hashtable" in the unordered-containers package
01:11:21 <koz_> My take-home thirty pages in: 'Use divide and conquer and use it hard'.
01:11:28 <koz_> Axman6: Yeah, atop HAMTs.
01:11:32 <Axman6> oh p0a left
01:11:44 <koz_> Axman6: I think I scared them.
01:12:26 <Axman6> I'm ok with this
01:12:56 <koz_> Axman6: Lol.
01:22:46 <koz_> @pl \(f, g) x -> (f x, g x)
01:22:46 <lambdabot> uncurry (liftM2 (,))
01:25:43 <MarcelineVQ> uncurry (&&&)  too
01:26:26 <koz_> :t uncurry (&&&)
01:26:27 <lambdabot> Arrow a => (a b c, a b c') -> a b (c, c')
01:26:42 <koz_> Is there a profunctoral formulation of this, I wonder...
01:27:29 <MarcelineVQ> % bisequence  ((+1),(+2)) 1
01:27:30 <yahb> MarcelineVQ: (2,3)
01:28:08 <srk> is hackage updates bot broken?
01:28:21 <koz_> % :t bisequence
01:28:21 <yahb> koz_: (Bitraversable t, Applicative f) => t (f a) (f b) -> f (t a b)
01:28:49 <koz_> % :t bisequence @_ @((->) a)
01:28:49 <yahb> koz_: ; <interactive>:1:22: error: Not in scope: type variable `a'
01:28:50 <MarcelineVQ> t ~ (,)   f ~ (r ->)
01:29:18 <MarcelineVQ> % :t bisequence @_ @((->) _)
01:29:18 <yahb> MarcelineVQ: Bitraversable _1 => _1 (_2 -> a) (_2 -> b) -> _2 -> _1 a b
01:29:42 <koz_> MarcelineVQ: That's rather neat.
01:32:57 <MarcelineVQ> srk: probably :> it's at least odd
01:33:27 <srk> MarcelineVQ: do you know which bot is that?
01:34:01 <MarcelineVQ> That's my line, I was asssuming you were asking about the bot called   hackage
01:35:55 <srk> hackage: ping
01:36:15 * hackage pandora 0.2.7 - A box of patterns and paradigms  https://hackage.haskell.org/package/pandora-0.2.7 (iokasimovmt)
01:36:36 <srk> <3
01:36:45 <srk> magic.
01:36:47 <MarcelineVQ> so the evil machine awoketh, and the dread order was given
01:36:56 <srk> :D
01:38:01 <hugbubby> I had to link this here: https://www.lesswrong.com/posts/R2dpt846hMGCHLsEy/forbidden-technology?commentId=H9Ry9ZCq74NZCTJsz
01:39:21 <MarcelineVQ> I like harry potter and the methods of rationality as much as the next weird shut-in, but is that a hasjell related link? :>
01:39:52 <hugbubby> yes
01:54:02 <hugbubby> well I thought it was funny
02:09:30 <tobiasBora> ChaiTRex: Ok thanks!
02:20:45 * hackage morpheus-graphql 0.11.0 - Morpheus GraphQL  https://hackage.haskell.org/package/morpheus-graphql-0.11.0 (nalchevanidze)
02:22:02 <tobiasBora> Is there a class type like Num but that allows only negation?
02:22:18 <tobiasBora> (it does not makes sense to add to terms in my case)
02:23:04 <akr[m]> Hi! I have some code that uses TH and it seems to be crashing HIE: https://psty.io/p?q=8635b
02:23:12 <koz_> tobiasBora: So what would that look like?
02:23:20 <akr[m]> should I tryo to produce a small reproducible example, or is this a known problem?
02:24:00 <tobiasBora> koz_: well, I want to allow doing "- myvar", but "myvar1 + myvar2" does not make sense. Something like an inverse.
02:24:37 <koz_> tobiasBora: Let me be more specific. What sort of operations would this type class allow (in terms of their Haskell type), and what laws would they be governed by?
02:25:51 <tobiasBora> koz_: I need a single operation: (-) :: MyType -> MyType, with the law that -(-a) = a.
02:26:07 <Logio> tobiasBora: that's called an involution
02:26:58 <koz_> Now whether there's a type class for involutions, I dunno.
02:27:03 <koz_> But it is a sensible type class.
02:30:38 <akr[m]> ok I think my HIE problem might be the same as https://github.com/haskell/haskell-ide-engine/issues/1480
02:31:37 <merijn> tobiasBora: Why do you need a class for that, though?
02:32:08 <merijn> You could just...implement that function?
02:33:03 <tobiasBora> merijn: it's just that I like the "+" sign. But it seems that I have no way to avoid implementing a full Num instance for it. I guess I can still through errors if people try to use a bad num
02:33:15 <tobiasBora> I meant the - sign
02:33:53 <merijn> Implementing Num and not actually supporting all it's operations is a *terrible* idea
02:35:18 <tobiasBora> merijn: so no solution if I want to use the - sign?
02:35:22 <merijn> I'd recommend caring less over superficial details like "I like the - sign"
02:36:43 <Logio> tobiasBora: no good way, besides writing your own prelude with blackjack and Involutive typeclass
02:37:11 <tobiasBora> merijn: a clear syntax sometimes helps a lot ;-) Ok, so I'll forget that idea then 
02:38:11 <merijn> tobiasBora: I think "overloading an operator that everyone associates with numbers and that takes a lot of effort to subvert so that people don't expect it" is the opposite of clear syntax :)
02:38:45 <merijn> Especially compared to the simplicity of defining a function "invert" so you can just do "invert myvar" with "invert (invert myvar) == myvar" :)
02:39:23 <Logio> merijn: to be fair, there is a type of algebraist who will happily use '-' for general inversions
02:39:50 <tobiasBora> merijn: makes sense. But I have several type that I would like to add an invert function to. So then it gives dirty syntax like invertTypeA, invertTypeB, invertTypeC...
02:39:53 <merijn> Logio: I wouldn't look to mathematicians for examples of "unambigous and clear" syntax, though ;)
02:40:11 <merijn> tobiasBora: "class Invert a where invert :: a -> a" problem solved? ;)
02:40:21 <Logio> merijn: that is very true, but - is not the worst example 
02:40:32 <merijn> It's a better class than most custom classes people tend to define, at least it has laws!
02:41:00 <tobiasBora> merijn: makes sense, thanks!
02:41:31 <tobiasBora> merijn: just, why didn't haskell tried to separate a bit more the laws?
02:41:56 <merijn> Num honestly doesn't even really have much in terms of laws
02:42:16 <tobiasBora> Because Num packages all the laws in one group: +/-/*/div,negate...
02:42:17 <merijn> There've been several tens of attempts at defining a better Num hierarchy, but most of them are just annoying to use
02:42:31 <maerwald> merijn: weird, I keep seeing ppl argue about them on the mailing lists (which I largely cannot follow)
02:43:00 <merijn> maerwald: About what?
02:43:04 <maerwald> the laws
02:44:09 <tobiasBora> merijn: well if it's just a syntax issue, I guess it would makes sense, when a class is strictly bigger than another class, to allow to define both class at the same time. That way it would be transparent to the users, and still usable
02:44:18 <tobiasBora> make*
02:45:06 <merijn> tobiasBora: It's not just syntax, people don't agree on which classes Num should be split in, what their laws should be, etc.
02:45:38 <Arahael> The only thing that people might agree on, is that however Javascript does it, is wrong. :)
02:46:04 <Logio> Num is generally varying degrees of bad, mostly depending on how deep into algebra you are delving into 
02:46:58 <tobiasBora> merijn: the laws you give to Num is an orthogonal problem (that may be help by allowing more modularity in the operators)
02:47:46 <Logio> tobiasBora: the problem is, you could construct Num in a couple of different ways from separate typeclasses
02:48:02 <Logio> but the constructions might not implicitly result in the same laws 
02:48:17 <tobiasBora> Logio: oh I see
02:48:46 <tobiasBora> But in Num what law is so important?
02:48:54 <tobiasBora> I mean subject to discussion
02:49:04 <merijn> THere's no laws for Num at all now
02:49:24 <Logio> and when there's no laws, there's disagreement
02:55:15 <tobiasBora> I see. Thanks
03:06:47 <tobiasBora> Is there any way to avoid to always use pattern matching with newtype?
03:07:23 <koz_> tobiasBora: coerce exists, but you'll likely need type annotations.
03:07:41 <koz_> There's also coercible-utils, which provides 'op' (I think).
03:07:41 <tobiasBora> because it's a bit confusing, some functions do need to access the value inside the newtype, so they look like "f (MyType a) = ..." and some don't need to so they look like "f a"
03:08:11 <tobiasBora> koz_: is it a function that you need to apply or a pragma that does that for you?
03:08:43 <koz_> tobiasBora: Both are functions, because newtypes are distinct from what they wrap at compile time.
03:08:50 <koz_> (for _extremely_ good reason)
03:09:42 <tobiasBora> koz_: Really? I was seeing newtype mostly as a compilation type checker
03:10:09 <koz_> tobiasBora: There's not any other kind of type checker in Haskell.
03:10:12 <tobiasBora> so does that mean that it is less efficient to use newtype MyInt = MyInt Int?
03:10:18 <koz_> So I'm not sure what you mean by that.
03:10:31 <koz_> I'm not sure what you mean by _that_ either.
03:10:57 <koz_> newtype MyInt = MyInt Int says 'MyInt has the same representation as Int, but is distinct from it as far as the compiler is concerned'.
03:11:04 <koz_> Newtype wrappers don't exist at runtime.
03:11:14 * hackage nix-narinfo 0.1.0.0 - Parse and render .narinfo files  https://hackage.haskell.org/package/nix-narinfo-0.1.0.0 (srk)
03:12:03 <tobiasBora> koz_: oh yes, I'm sorry I read "from what they wrap at *runtime*" instead of "at compile time", that's why I was lost
03:12:17 <koz_> At runtime there are no types.
03:12:22 <koz_> GHC performs type erasure.
03:12:41 <phadej> protip with Haskell learning: don't think too much about performance
03:12:51 <phadej> get the code to compile and work first
03:13:05 <phadej> too much = like, at all.
03:13:36 <tobiasBora> phadej: well I do care about performance, and also I'm quite curious to understand what's happening behind.
03:14:05 <koz_> I (in general terms) agree with what phadej said.
03:14:24 <tobiasBora> koz_: so basically instead of writing "f (Mytype a) = a+1", I'd write with coerce something like "f a = (coerce a)+1"?
03:15:08 <phadej> I'd prefer f (Mytype a) = a + 1
03:15:12 <koz_> tobiasBora: Essentially, though you might need to tell coerce what type you're coercing into, because it is extremely polymorphic.
03:15:31 <tobiasBora> koz_: Ok thanks. 
03:15:33 <koz_> It's usually not worth it unless you're pulling off multiple layers of newtypes or something.
03:16:13 <tobiasBora> phadej: I think I also prefer the f (Mytype a), but it's quite confusing because some functions do need to access the a and some don't... But nevermind
03:16:45 <phadej> you can write f :: MyType -> MyType; f = coerce (+1) -- where it starts to make sense
03:17:39 <phadej> but as replacement for newtype constructor/selector, I wouldn't.
03:18:35 <tobiasBora> phadej: There is no selector if I don't want to use record right?
03:18:44 * hackage lhs2tex 1.24 - Preprocessor for typesetting Haskell sources with LaTeX  https://hackage.haskell.org/package/lhs2tex-1.24 (AndresLoeh)
03:19:53 <phadej> I usually always define newtypes with the selector, sooner or later you'll need it
03:20:24 <phadej> (I also don't care about Show instances that much)
03:21:05 <phadej> or then I define an unwrapper separately. Depends.
03:23:54 <tobiasBora> phadej: what do you call selector? Is it a custom function you write, or a record?
03:24:07 <phadej> both
03:24:19 <phadej> I'm not precise
03:24:57 <merijn> tobiasBora: The problem with thinking about performance when you're just starting to program in a language (and this goes doubly in Haskell) is that your intuition for which things are important and which things are slow will be utterly wrong and you will, therefore, invest lots of time on unimportant things (while potentially making important things worse)
03:25:31 <phadej> (e.g. thinkng too much about newtypes ;)
03:28:31 <tobiasBora> merijn: I understand...
03:28:33 <merijn> I once had a colleague spend 2 weeks refactoring code to move an if statement out of a hot innerloop invoked millions of times to speed up the code
03:28:45 <merijn> You know what the performance improvement was?
03:28:47 <merijn> Zero
03:29:00 <tobiasBora> ahah
03:29:10 <merijn> Turns out the branch never changed during the loop, so it was perfectly predictable and thus had no overhead on the actual CPU
03:29:32 <merijn> Since predictable branches are basically free on modern hardware.
03:30:10 <tobiasBora> funny
03:30:27 <Rembane> So the branching cost was only paid once? 
03:30:37 <Arahael> Rembane: Not even that.
03:30:48 <Arahael> Modern CPU's "guess" what the branch result is, and operate at risk.
03:31:11 <Rembane> Arahael: Yeah, but ... do you mean that the cpu guesses correctly when it is time to leave the loop? 
03:31:42 <Arahael> Rembane: That guess probably fails when it has to leave the loop - so it has a branch misprediction penalty at that point.
03:32:08 <Rembane> Arahael: Okay, then my mental models hold. 
03:32:11 <Arahael> Rembane: Seriously, don't think too hard about it, there are dragons.
03:32:41 <tobiasBora> Any reason why if I do "import Test.QuickCheck ([...], Positive)" I stil have a Not in scope: data constructor ‚ÄòPositive‚Äô
03:33:13 <Rembane> Arahael: Got it! 
03:33:40 <Arahael> Rembane: The main thing is to profile, profile, profile, and on as realistic data you can get.
03:33:46 <merijn> Rembane: I wasn't referring to the branch from the loop (although that's also predictable except for the last one)
03:34:14 <merijn> Rembane: I meant like "for (int i = 0; i < 1000000; i++) { if (foo) { doStuff(); } }"
03:34:38 <Arahael> merijn: Pfft.  Should've been ++i, such a newbie! :)
03:35:13 <Rembane> merijn: Okay, and your colleague tried to move the if(foo) { ... }  statement out of the loop?
03:35:42 <merijn> Rembane: The cost of jumps is that all modern CPUs are heavily pipelined (i.e. you're processing many instructions one bit at a time), you need to keep that pipeline filled to get good performance. The problem with jumps is that you can't fill the pipeline until the branch completes evaluation
03:35:47 <merijn> Rembane: Yeah
03:36:07 <merijn> Rembane: That pipeline stall is what kills your performance
03:36:49 <tobiasBora> ok, found the problem https://stackoverflow.com/questions/34547937/haskell-import-qualified-and-not-in-scope-data-constructor
03:36:50 <Rembane> merijn: That's true, I wonder if there are cpus out there with two parallell pipelines, so they both can be filled and a switch costs much less
03:36:53 <merijn> So the CPU will just (speculatively) keep filling the pipeline based on predicted jump outcome. If you guess right, free performance! If you guess wrong, well, you would've been stalled anyway, so wasted instructions don't have real cost
03:37:10 <Arahael> Rembane: They have quite a few parallel pipelines, too.
03:37:13 <merijn> Rembane: Yes, no, maye, it depends :)
03:37:18 <Rembane> merijn: ^^
03:37:37 <Rembane> Arahael: This becomes more and more magical. It's amazing! :D
03:37:39 <Arahael> Rembane: They also "share" parts of the pipeline, too - it's seriously complex.
03:37:40 <merijn> Rembane: Modern multi-scalar CPUs (i.e. all the desktop/server ones) have multiple logic units
03:38:12 <Arahael> merijn: Do we tell him about Minix? ;)
03:38:47 <merijn> Rembane: Intel CPUs actually translate their ISA instructions to a RISC microcode internall, so one instruction in the external instruction set might turn into 10 or so microcode instructions which get distributed across independent logic units
03:39:23 <merijn> Rembane: You'll usually get like 6 basic ALUs (so integer arithmetic/logic stuff) and 2 or so floating point units within a single core
03:39:52 <merijn> Rembane: So if you wanna get the absolute max performance you even need to worry about the mix of arithmetic instructions you're feeding the core
03:40:23 <merijn> Since feeding many more integer instructions might still outperform floating point, since you get more logic units that can execute it in parallel
03:41:30 <merijn> This, incidentally, is why people claiming "C is close to the machine!" are talking utter-shite
03:41:50 <dibblego> lol
03:42:21 <merijn> People think CPUs haven't changed much since early Pentiums and base all their intuitions on the basics of what they remember of Pentiums
03:42:27 <Rembane> merijn: Dang! Yeah... 
03:42:45 <merijn> Conveniently ignoring that everything is now deeply pipelined, multi-scalar, multi-issue, out-of-order execution
03:42:59 <Rembane> Wasn't everything seriously off even with the introduction of virtual memory in the 70s? 
03:43:18 <merijn> Rembane: If you're curious/interested in that sorta thing, Intel has a bible covering all this stuff in detail: https://software.intel.com/en-us/download/intel-64-and-ia-32-architectures-optimization-reference-manual
03:44:55 <merijn> Rembane: I can also highly recommend grabbing a free community license of Intel VTune and running stuff through it and having a look at the performance data you get :) Fascinating stuff!
03:45:21 <Rembane> merijn: This seems like the next level above the computer architecture course I took many years ago. Thank you! 
03:46:11 <Arahael> Rembane: He still hasn't gotten close to it, from what I understand.
03:46:34 <Rembane> Arahael: Close to what the cpus actually do? 
03:46:38 <Arahael> Rembane: Yes.
03:46:47 <merijn> Yeah, this is my really superficial and naive understanding of modern CPUs :p
03:47:32 <merijn> I used to be in a group of people working on hardware design and did some HPC stuff, so I've gleaned details here and there, but I don't even know a quart of it :p
03:47:51 <Arahael> Most of what I know is what merijn's told me, on IRC.
03:48:24 <Arahael> Usually in the form of correcting whatever it is I said. ;)
03:48:56 <Arahael> Or correcting others. (Eg, "C is close to the machine")
03:55:30 <[exa]> merijn: btw AMD has a similar manual, I found it a bit better from actual 64b code
04:04:15 * hackage opentelemetry 0.3.1 -   https://hackage.haskell.org/package/opentelemetry-0.3.1 (DmitryIvanov)
04:05:14 * hackage opentelemetry-wai 0.3.1, opentelemetry-lightstep 0.3.1, opentelemetry-extra 0.3.1 (DmitryIvanov)
04:06:21 <Uniaika> yay opentelemetry
04:25:44 * hackage haskoin-store 0.23.11 - Storage and index for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-store-0.23.11 (jprupp)
04:49:44 * hackage ghc-lib-parser 0.20200501 - The GHC API, decoupled from GHC versions  https://hackage.haskell.org/package/ghc-lib-parser-0.20200501 (shayne_fletcher)
04:50:45 * hackage ghc-lib 0.20200501 - The GHC API, decoupled from GHC versions  https://hackage.haskell.org/package/ghc-lib-0.20200501 (shayne_fletcher)
04:53:20 <disconsis> Is there a monad that returns on first success?
04:53:43 <disconsis> like, Maybe returns Nothing on the first Nothing it gets
04:54:01 <disconsis> I'd like the opposite - try a bunch of things and return the first Just 
04:54:41 <merijn> disconsis: Sounds like you want Alternative :)
04:54:54 <merijn> :t asum
04:54:55 <lambdabot> (Foldable t, Alternative f) => t (f a) -> f a
04:55:07 <merijn> > asum [Nothing, Just 1, Nothing, Just 2, Just 3]
04:55:09 <lambdabot>  Just 1
04:55:15 <disconsis> aha, nice
04:55:34 <disconsis> Is it a monad?
04:55:44 <dminuoso> Alternative is a different interface than Monad.
04:55:50 <dminuoso> It's a subclass, if you want.
04:55:57 <dminuoso> Or rather, MonadPlus is that one.
04:55:59 <merijn> disconsis: There's also MonadPlus
04:56:14 <dminuoso> Alternative is to Applicative like MonadPlus is to Monad.
04:56:15 * hackage morley 1.2.0 - Developer tools for the Michelson Language  https://hackage.haskell.org/package/morley-1.2.0 (gromak)
04:56:17 <merijn> Which is Alternative + Monad (+ identy on mzero)
04:56:35 <disconsis> ooh okay
04:56:40 <dminuoso> But honestly, nobody can agree on how monadplus and alternative relate and what exact laws they should have...
04:57:02 <disconsis> dminuoso: could you elaborate on what you mean by a different interface?
04:57:03 <merijn> dminuoso: I thought there was a rough consensus
04:57:20 <merijn> disconsis: Whether something is Alternative and whether it is Monad or independent issues
04:57:37 <dminuoso> merijn: I cant recall the details, but I think there's some instances that violate plenty.
04:57:41 <merijn> disconsis: But most monads where "first success" is meaningful will have an Alternative instance
04:57:56 <disconsis> Ah I see
04:58:00 <merijn> disconsis: Such as Maybe, Either e, Parser, etc.
04:58:28 <merijn> disconsis: Alternative is, effectively, the generalised API for "get me the first thing that succeeds"
04:58:42 <disconsis> Nice, thanks guys!
05:00:32 <merijn> dminuoso: afaik Alternative just requires left and right identity for empty and MonadPlus is just Alternative with the requirement that "mzero >>= f = mzero" and "v >> mzero = mzero"
05:26:13 <juri_> if i have a list, and an item in that list, what's the cheapest way to find the item before / after that item in the list?
05:30:02 <dibblego> list zipper
05:32:05 <Uniaika> zipper yeah
05:32:09 <Uniaika> oh hi dibblego
05:32:24 <dibblego> hi
05:48:15 * hackage haskoin-store 0.23.12 - Storage and index for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-store-0.23.12 (jprupp)
05:54:19 <siraben> Anyone know if there is a paper on the bound library by Edward Kmett?
05:56:15 <Uniaika> edwardk: ^
06:00:56 <mniip> ed usually doesn't make papers on packages, he makes packages on papers
06:01:35 <siraben> Ah, then the latter would be good as well.
06:03:05 <mniip> is this not it? https://github.com/ekmett/bound/blob/master/src/Bound.hs#L79-L92
06:05:15 <siraben> Ooh, looks like it, thanks mniip .
06:06:17 <siraben> Haven't seen that paper by Bird and Paterson before.
06:14:10 <disconsis> mniip:If that were always true then there's "bound" to be a paper on the bound library
06:26:15 * hackage ghc-lib-parser-ex 0.20200501 - Algorithms on GHC parse trees  https://hackage.haskell.org/package/ghc-lib-parser-ex-0.20200501 (shayne_fletcher)
06:45:15 <edwardk> siraben: papers aren't my forte, but there is an article
06:45:45 <edwardk> siraben: https://www.schoolofhaskell.com/user/edwardk/bound covers the thinking that went into it though
06:48:50 <siraben> edwardk:  Thanks, that's helpful.
06:49:16 <edwardk> there are slides somewhere as well, but the content and the content of that article are basically identical
06:49:42 <edwardk> in general you'll have an easier time finding a talk by me or a blog post than a paper
06:49:50 <edwardk> i'm a poor academic
06:50:12 <Plazma> hooray i have a friend in edwardk 
07:30:35 <Zago> Hello All
07:30:42 <Zago> I hope you are doing well !
07:32:28 <maerwald> You get by
07:33:48 <Zago> Yeah we do :)
07:33:51 <Zago> I am learning Haskell out of curiosity, but couldn't hemp thinking about how it can benefit me in the future 
07:34:36 <maerwald> Benefit?
07:35:52 <Zago> In what domains I use it ?
07:36:19 <maerwald> full stack, compilers, parsing, CLI tools
07:36:33 <maerwald> those are popular
07:37:12 <Zago> I am a Supply Chain Engineer / Dev, Experience in Python, C#, Java 
07:37:40 <Zago> Would it be wise to focus on Haskell or just continue on the usual languages ?
07:38:05 <maerwald> Zago: for jobs? Probably not that wise.
07:38:24 <maerwald> Java, python and C# have huge markets.
07:38:51 * sm[m] got hired once due to "haskell" on my resume
07:38:53 <maerwald> Although growing, haskell is niche.
07:39:40 <Zago> Ah I see
07:40:00 <Zago> But I do need a purpose to continue learning, any ideas ?
07:40:16 <maerwald> Zago: curiosity
07:40:23 <suppi> Haskell is nice and useful. I really enjoy it. There are more marketable languages out there though.
07:40:42 <sm[m]> it'll make you a better programmer
07:40:52 <sm[m]> and it's a good secret weapon to have in your pocket
07:40:52 <maerwald> sm[m]: uhmmm :)
07:41:02 <sm[m]> uhmm yourself!
07:41:18 <Zago> :) ,So far : 
07:41:28 <Zago> * Curiosity
07:41:37 <maerwald> It can help with thinking more explicitly about effects, I guess
07:41:45 <suppi> https://gilmi.me/blog/post/2020/04/28/consider-haskell
07:41:45 * hackage haskoin-store 0.23.13 - Storage and index for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-store-0.23.13 (jprupp)
07:41:52 <ameiners> I know that a friend of my works in Haskell with distributed education platforms
07:42:03 <Zago> * a better programmer (I started to feel that actually)
07:42:12 <ameiners> I have another friend working with Elixir for distributed advertisements in podcasts
07:42:18 <maerwald> Being familiar with different paradigms makes you a better programmer
07:42:27 <maerwald> if you only stick to one, you'll lose view
07:42:38 <sm[m]> right!
07:42:43 <ameiners> Agreed. I currently work in Java but was getting bored of it so have been learning Haskell/Rust/Elixir!
07:43:00 <suppi> I'm not sure if Haskell makes you a better programmer or just learning new things makes you a better programmer
07:43:03 <sm[m]> haskell is one of those "every serious programmer should learn a bit" languages
07:43:16 <sm[m]> like smalltalk, erlang, lisp, prolog
07:43:29 <sm[m]> oops.. that doesn't sound good does it :)
07:43:34 <maerwald> suppi: yes, if you know functional programming already and have a strong sense of reasoning about effects, I'm not sure it buys you much in terms of your programming skills
07:44:13 <suppi> Many people reach a certain point and stagnate. Keep doing the same things for years.
07:44:22 <maerwald> Also note: if you read some old ID software C code, you can see they were pretty strict in reasoning about effects and side effects were documented
07:44:35 <suppi> Learning Haskell is a good way to learn new things
07:44:37 <ameiners> I think that learning other programming languages gives you a great view of how other languages do things and makes you reflect more deeply on how your original language does it
07:44:37 <maerwald> I don't think anyone of them back then did haskell 
07:44:46 <maerwald> But it's certainly more rare there
07:46:00 <Zago> Well Thanks a lot everybody for your answers, very kind of you :)
07:46:02 <suppi> I personally think that Haskell is a great language and a useful tool. It can do many things better than other options.
07:46:18 <Zago> suppi like ?
07:46:24 <maerwald> I think programming skills are largely about awareness/levels of reasoning. If you don't understand software security at all and have no mental model of it, then you're lacking something
07:46:25 <ameiners> I really enjoy how Haskell keeps IO as minimal as possible.
07:46:50 <suppi> Zago I linked an article about it a few minutes ago
07:46:59 <ameiners> Also agreed with suppi. We are all programmers here and each new programming language is just a new tool in the toolbelt
07:47:49 <dsal> Zago: I just did a blog post on a thing I'd been working on: http://dustin.sallings.org/2020/04/29/gopro-plus.html
07:48:02 <suppi> Zago: this https://gilmi.me/blog/post/2020/04/28/consider-haskell
07:48:27 <maerwald> a little unbalanced blog post if you ask me
07:48:37 <srk> dsal: <3
07:48:45 <Zago> suppi Yes I am reading it right now (while trying to keep up with the conversation), thanks a lot
07:48:54 <Zago> dsal Thanks a lot :)
07:48:57 <suppi> maerwald what I linked? Can you elaborate please?
07:49:00 <maerwald> e.g. pointing to streamly, which is really really new and can't be used without internal modules much :)
07:49:04 <dsal> It doesn't have much to go with Haskell because Haskell isn't weird academic magic that is only useful for impressing friends. :)
07:49:27 <maerwald> You shouldn't point newcomers to a heavily WIP streaming lib
07:50:30 <suppi> Oh, I didn't really mean to, it's just that the readme was pretty good at summarizing what streaming libraries provide
07:50:39 <maerwald> And shake is pretty complicated too 
07:50:58 <dsal> Haskell is the easiest language I work in, though.
07:51:00 <C87> hey all.  I'm trying to figure out the "interchange" law of applicative functors from the paper "Applicative Programming with Effects" ... would here be a good place to ask?
07:51:52 <suppi> I think shake is really cool and I really think it's a good use case for Haskell. But I respect your opinion.
07:51:56 <merijn> maerwald: tbh, I think Shake is rather simple compared to the alternatives :p
07:52:16 <maerwald> merijn: well, you can build pretty complicated stuff in shake and it usually gets complicated quickly
07:52:32 <maerwald> If you don't use that power, stick to make, it's simpler
07:52:33 <suppi> I'm using it to build some C code and it's fairly simple atm.
07:52:47 <C87> So "u <*> pure x = pure (\f -> f x) <*> u" is the law.  But I just can't figure out how the LHS is equal to the RHS.
07:53:01 <maerwald> And in fact, for most things, you really want make
07:53:09 <merijn> maerwald: Sure, but make isn't in the same powerclass and doing it in Shake is going to be far easier and better maintainable than CMake :p
07:53:15 * hackage rampart 1.1.0.0 - üè∞ Determine how intervals relate to each other.  https://hackage.haskell.org/package/rampart-1.1.0.0 (fozworth)
07:53:32 <maerwald> merijn: I didn't find huge shake build systems particularly maintainable, tbh
07:53:36 <maerwald> but neither are cmake or make
07:53:44 <merijn> maerwald: I like plain (g)make, but it's pretty hard for clueless people to write correct makefiles
07:53:48 <suppi> I prefer shake.
07:53:55 <maerwald> merijn: yes
07:54:04 <merijn> maerwald: Which is why literally every makefile I've interacted with that wasn't written by me has been a broken mess
07:55:19 <merijn> (compared to about 60-70% of makefiles written by me being broken messes xD)
07:55:28 <sm[m]> for double the fun, use make and shake
07:57:00 <sm[m]> Zago: haskell is one of the best languages available for expressive abstractions, safe refactoring of large codebases, lowering the long-term cost of maintenance 
07:57:17 <sm[m]> it pays off especially for large/long-term projects
07:57:45 <sm[m]> but if you've learned it, you'll want to use it for many small things too
07:58:47 <Zago> @sm[m
07:58:47 <lambdabot> Unknown command, try @list
07:59:05 <Zago> @sm[m] can you explicit the small things please ?
07:59:05 <lambdabot> Unknown command, try @list
07:59:15 <Zago> sm[m] can you explicit the small things please ?
07:59:35 <Zago> sm[m] can you explicit the small things please ?
08:00:22 <sm[m]> whatever small projects you might have.. scripting.. command line tools.. small web services..
08:00:32 <suppi> maerwald I took your feedback and updated the post to point to pipes, conduit or streaming. Thanks!
08:00:51 <maerwald> merijn: I think my internet got cut off.
08:01:15 * hackage http-io-streams 0.1.3.0 - HTTP client based on io-streams  https://hackage.haskell.org/package/http-io-streams-0.1.3.0 (HerbertValerioRiedel)
08:01:31 <maerwald> merijn: I was going to say: yes. I've fixed lots of build system when I was still gento deving. Most of them are broken. Because they are too complicated/powerful
08:01:35 <maerwald> Shake doesn't make that better ;)
08:01:42 <maerwald> Less power, not more!
08:01:54 <lyxia> C87: the point is that functors satisfying those laws are useful. It's not something you can convince yourself of in the abstract. You have to look at examples and get some practical experience with it.
08:02:49 <C87> Fair enough, I get that they are semantic laws
08:03:06 <C87> But I can't get the LHS to equal the RHS, so I don't actually see what the law's semantics *are*
08:03:30 <maerwald> suppi: I think streaming is generally not very beginner friendly in haskell
08:03:41 <C87> For the other 3 laws, I think I'm doing OK.
08:03:44 <maerwald> parser libraries are probably a better sell
08:03:58 <C87> Law 1: don't mess with the function you're given.  Just apply it.
08:04:08 <C87> Law 2: respect ordering.
08:04:28 <C87> Law 3: wrap-then-apply must be the same as apply-then-wrap.
08:04:37 <lyxia> C87: By "get the LHS to equal the RHS", do you mean to interpret what it means to equate those things?
08:04:38 <dsal> Zago: I wrote a small commandline utility recently that parses a text file and looks for tags like {{ x }}, extracting those into a list of MQTT subscriptions, connects to my MQTT server, subscribes to those things and spits out the rendered template with the values substituted (I use it in xmobar to display stuff).
08:04:43 <C87> But that last one, interchange.... what is it even trying to say?
08:04:44 * hackage bytebuild 0.3.5.0 - Serialize to a small byte arrays  https://hackage.haskell.org/package/bytebuild-0.3.5.0 (andrewthad)
08:05:03 <dsal> Zago: It looks like this:  https://gist.github.com/dustin/19b2139fce384f0e86b710b544681635
08:05:10 <C87> lyxia, yes - that's what I can't figure out
08:05:38 <tobiasBora> Hello again, I'd like to know, I'm using newtype with something like "newtype Mymap = Mymap Map" in order to make sure that I don't do stupid errors during compilation. However, whenever I want to use a function from Map, I need to unwrap, apply the function, and wrap again. So for example if I code: "unwrapMytype (Mytype a) = a", then I have quite often something like "Mytype $ Map.insert a b $ unwrap
08:05:40 <tobiasBora> mymap", which is a bit heavy for no apparent reason. Would it be possible to create automatically a new "module" interface, so that I can replace this code with something like "Mytype.insert a b mymap"?
08:06:30 <lyxia> C87: if you ignore the result of computations (contained in the argument of pure), "pure" means "do nothing", so the laws says "doing the action 'u' then doing nothing is the same as doing nothing then the action 'u'"
08:06:54 <tobiasBora> (the Mytype module would be basically exactly like the Map module, except that the type Map is changed with Mytype)
08:07:17 <dsal> Zago: Oh, it's the first of the month!   This is a program that I run the first of every month that collects my uncompressed daily logs from papertrails exports on S3, combines them into a single .7z file, deletes the originals, and then uploads the rolled up month file.  Saves huge amounts of storage:  https://github.com/dustin/papertrails/blob/master/app/Main.hs
08:08:14 <C87> lyxia ... OK, going to have to think about that for a bit ...
08:08:18 <dsal> Zago: (don't try to learn Haskell from this, just answering what kinds of things people do with haskell)
08:09:10 <C87> How do you get the intuition that "pure x" does nothing?
08:09:20 <sm[m]> dsal++
08:09:25 <Zago> dsal Yes Yes, thanks for the examples, it warms the heart knowing it can be used for all kinds of stuff :)
08:09:36 <lyxia> C87: circularly by getting intuition for the interchange law.
08:09:58 <sm[m]> +1 for showing not telling !
08:10:19 <dsal> Zago: I have so many kinds of stuff.  Yesterday in #mqtt, someone was complaining about having trouble getting three-way bridging working in mosquitto -- causing loops and stuff.  I had a different problem with mosquitto's bridging support, so I ended up writing my own n-way mqtt bridge in haskell in like... a few lines.
08:10:54 <srk> dsal: which mqtt lib do you use if any?
08:11:05 <dsal> @hackage net-mqtt
08:11:06 <lambdabot> http://hackage.haskell.org/package/net-mqtt
08:11:14 <dsal> srk: I wrote that one because the existing ones didn't do the things I needed.
08:11:16 <srk> ty, need to switch to that 
08:11:18 <dsal> But it does all the things!
08:11:52 <srk> @hackage mqtt-hs
08:11:52 <lambdabot> http://hackage.haskell.org/package/mqtt-hs
08:12:04 <lyxia> tobiasBora: type classes or backpack do that.
08:12:05 <srk> I'm still using this but author is not responsive
08:12:20 <srk> wish he would just put a big red banner on the repo :)
08:12:21 <dsal> This is my bridge implementation:  https://github.com/dustin/mqtt-bridge/blob/master/app/Main.hs  -- it got a little fancy after MVP, but it can handle n bridges with different directions each.
08:13:00 <srk> cool, I only need client for ttn-client
08:13:04 <dsal> Ah, that's not even supporting 3.1.1.  https://github.com/k00mi/mqtt-hs/issues/19  -- v5 is a *huge* upgrade.
08:13:37 <C87> lyxia 'k, this one's going to bother my brain for a while ... thanks.  Let's hope that clue jolts something loose!
08:14:07 <srk> dsal: created two PRs for that :( gonna use your lib instead
08:14:20 <srk> and there's few more as well
08:14:43 <dsal> I do tons of stuff with it.  Check this out:
08:14:45 <dsal> @hackage net-mqtt-rpc
08:14:45 <lambdabot> http://hackage.haskell.org/package/net-mqtt-rpc
08:15:12 <srk> hehe, I'm not a huge fan of mqtt but if your lib is rock solid I might change my mind :D
08:15:18 <srk> only used it because of TTN
08:15:19 <tobiasBora> lyxia: not sure how type classes help in that case, do you have an example?
08:15:30 <srk> dsal: fun!
08:15:53 <srk> @hackage zre
08:15:53 <lambdabot> http://hackage.haskell.org/package/zre
08:15:59 <srk> dsal: ^ I'm dogfooding this :D
08:16:16 <sm[m]> Zsal: a few more small scripting examples: https://github.com/simonmichael/hledger/blob/master/tools
08:16:35 <dsal> $ mqtt-rpc --newline -u mqtt://eve/ -t tesla/x/in/cmd/sw/schedule -m 30
08:16:35 <dsal> update_not_available
08:16:49 <dsal> I just asked my car to start an upgrade, but there's not one available.  BOO
08:16:57 <srk> lol
08:17:07 <lyxia> tobiasBora: the type class way is, rather than wrapping Mymap, is to declare the interface of Map as a type class C, so code using it would have a constraint (C map) which gets resolved by specializing map to Map.
08:17:17 <srk> dsal: you should root it a flash your own
08:17:43 <dsal> hahaha.  Changing lanes... hold on, need to gC
08:17:45 * hackage scientific-notation 0.1.2.0 - Scientific notation intended for tokenization  https://hackage.haskell.org/package/scientific-notation-0.1.2.0 (andrewthad)
08:17:54 <srk> dsal: I have a critical component for that :D https://github.com/distrap/lambdadrive
08:18:40 <dsal> Woah, bldc in haskell?
08:18:45 <srk> not quite
08:18:52 <srk> there's intermediate C :)
08:19:17 <srk> @hackage ivory
08:19:17 <lambdabot> http://hackage.haskell.org/package/ivory
08:21:47 <suppi> oooh, interesting.
08:22:14 <dsal> I'm a pretty big mqtt fan at this point.  I've exploited all the thing.  I also wrote https://github.com/dustin/influxer and https://github.com/dustin/outfluxer for all my sensor junk.
08:22:40 <srk> sounds like influxdb integration :D
08:22:53 <srk> oh yeah
08:22:56 <dsal> Yeah.  One for each direction.
08:24:10 <dsal> I have one influxdb, but two MQTT servers in two locations.  I bridge them, but connection goes down sometimes and I don't want to lose data, so influxer spools to local disk.  I've lost my connection for like, days sometimes without losing data.  :)
08:25:11 <srk> nice, I was trying to solve similar problems few years ago (sensor stations that can loose internetz but shouldn't loose data)
08:25:37 <srk> was using python and xmpp at that time :P
08:25:44 <dsal> I also lose power here sometimes.  My MQTT broker is an orange pi.  I hacked together a battery backup for it:  https://usercontent.irccloud-cdn.com/file/SI705H09/vbat
08:26:15 <dsal> I did some really interesting XMPP stuff back in the day.  A bit of C, but a lot of twisted.
08:26:37 <srk> hehe, twisted was cool
08:27:07 * srk likes that runcam box
08:27:11 <srk> flying fpv? :)
08:27:48 * dsal has too many hobbies
08:27:58 * srk same
08:28:58 <dsal> Man, XMPP makes me angry in a get-off-my-lawn sort of way.  Solved so many problems they had to kill it off.
08:29:24 <peutri> it got killed off?
08:29:33 <srk> true but the xml overhead wasn't nice :)
08:30:12 <tobiasBora> lyxia: not sure how type classes help in that case, do you have an example?
08:30:14 <dsal> http://dustin.sallings.org/2009/07/11/skyscraper.html <-- this was a weekend hack with some Italian kid I met online who wanted to learn some programming.  We made a chat room that people could all go into and speak and read their native languages while it did machine translation across them.
08:30:45 <dsal> peutri: It was widely usable by everyone when Google (and sort of Facebook) supported it in federation, but they killed it off.
08:31:01 <peutri> ah, google, got it
08:31:23 <dsal> I had a slightly popular XMPP service that let people interact with twitter in quite pleasant ways.  Having all that stuff fall apart really sucked, but I guess it got me using twitter less, which is nice.
08:32:28 <srk> skyscraper is pretty neat idea :)
08:32:45 * hackage spectral-clustering 0.3.2.1 - Library for spectral clustering.  https://hackage.haskell.org/package/spectral-clustering-0.3.2.1 (GregorySchwartz)
08:34:53 <lyxia> tobiasBora: https://dpaste.org/kRCD
08:35:22 <dsal> Google stopped supporting xmpp because, among other things, it constrained them too much in developing chat solutions.  The thing they replaced it with had no API and eventually had to be replaced because it was differently awful.  In general, things that can't be programmed aren't useful and should die.
08:38:14 <merijn> dsal: Isn't Google's solution to every problem to kill off a chat product and invent a new chat product?
08:39:17 <dsal> srk: Speaking of too many hobbies.  Here's some haskell I wrote before I actually spent time trying to learn it:  https://github.com/dustin/OpenTXLog  It takes, you know, an OpenTX log and then injects distance and speed from GPS bits.  I should see if I can make it better.
08:39:36 <dsal> merijn: Sometimes google makes chat products without even trying.  One emerged from Docs on its own.
08:40:46 <srk> dsal: cool, I've created https://github.com/sorki/anomaly recently :)
08:41:23 <srk> dsal: -offtopic?
08:41:32 <tobiasBora> lyxia: hum... so it means I need to rewrite for MapLike all the operations? Like empty = Map.empty...? It could be an idea, thanks! And what about backpack? 
08:41:37 <srk> win 86
08:41:40 <srk> oop
08:41:44 * hackage brick 0.53 - A declarative terminal user interface library  https://hackage.haskell.org/package/brick-0.53 (JonathanDaugherty)
08:42:22 <tobiasBora> lyxia: Also I read here [1] that " (using typeclasses can have performance overhead due to how they are implemented in Haskell)". Does it apply here?   [1] https://stackoverflow.com/questions/52538213/example-on-the-use-of-backpack
08:42:28 <dsal> tobiasBora: Map is monoid.
08:43:00 <tobiasBora> dsal: not sure to see what you mean
08:43:23 <merijn> The Monoid for Map sucks, though :<
08:43:29 <merijn> I'm still pissed off by that!
08:45:21 <solonarv> tobiasBora: generally speaking, typeclasses have that performance penalty when the compiler can't figure out at compile time which instance is being used
08:45:31 <solonarv> and so can't monomorphize, specialize, inline, simplify, and so on
08:47:29 <solonarv> IIUC, with backpack it's just not possible to write code in a way that the instantiations aren't known at compile time (at the very least, compile-time-for-the-actual-program)
08:50:45 * hackage i3ipc 0.2.0.0 - A type-safe wrapper around i3's IPC  https://hackage.haskell.org/package/i3ipc-0.2.0.0 (leshow)
08:51:00 <tobiasBora> solonarv: oh I see, thanks! Also, I do need to manually write a specialization for any single function I'd need with lyxia's proposition https://dpaste.org/kRCD
08:51:05 <tobiasBora> solonarv: oh I see, thanks! Also, I do need to manually write a specialization for any single function I'd need with lyxia's proposition https://dpaste.org/kRCD?
08:51:19 <tobiasBora> (oups sorry for the double post)
08:51:36 <lyxia> tobiasBora: I feel conflicted about this concern. In principle, there shouldn't be a problem, in practice I can imagine the compiler currently needs a bit of help, but some SPECIALIZE annotations everywhere should suffice.
08:52:36 <tobiasBora> lyxia: so it means that I need to maintain always 2 functions, one normal and one prime? it seems quite hard to maintain no?
08:53:15 * hackage github-release 1.3.0 - Upload files to GitHub releases.  https://hackage.haskell.org/package/github-release-1.3.0 (fozworth)
08:53:55 <tobiasBora> and I guess that the compilator is not smart enough to see that if a function is always called with one specific type, then we can create a speicialized function for it?
08:54:06 <solonarv> no, you don't need to actually write myapplication'
08:54:36 <solonarv> you can just write a {-# SPECIALIZE myapplication :: <specialized type goes here> #-} pragma
08:55:02 <lyxia> tobiasBora: you only need to specialize your whole program at the very end, by using it in main or somewhere similar.
08:58:01 <tobiasBora> lyxia: solonarv : but when you write a library instead of a program, then I don't see how to avoid adding tons of SPECIALIZE pragma, one per function. (I guess for executable it makes sense because you just have one "end point")
08:59:39 <solonarv> yes, sometimes when you are writing libraries you end up slathering tons of pragmas all over the place
09:03:15 * hackage json-syntax 0.1.1.0 - High-performance JSON parser and encoder  https://hackage.haskell.org/package/json-syntax-0.1.1.0 (andrewthad)
09:05:51 <quiet_laika[m]> are there any libraries that make it easy to implement a lexer/parser according to www.unicode.org/reports/tr31/ ?
09:06:38 <tobiasBora> solonarv: ok too bad, thanks!
09:12:47 <solonarv> quiet_laika[m]: at a guess, any of the *parsec family will do just fine (my default parser combinator library is megaparsec)
09:20:15 * hackage front 0.0.0.8 - A reactive frontend web framework  https://hackage.haskell.org/package/front-0.0.0.8 (swamp_agr)
09:31:00 <toni37> undefined + undefined == defined
09:31:03 <toni37> > undefined + undefined == defined
09:31:06 <lambdabot>  True
09:31:11 <toni37> > undefined + undefined + undefined == defined
09:31:13 <lambdabot>  True
09:31:22 <toni37> > undefined == defined
09:31:24 <lambdabot>  *Exception: Prelude.undefined
09:31:34 <toni37> > undefined + undefined
09:31:36 <lambdabot>  *Exception: Prelude.undefined
09:33:00 --- mode: ChanServ set +o ski
09:33:16 --- mode: ChanServ set -o ski
09:51:10 <solonarv> :t defined
09:51:11 <lambdabot> Defined
09:51:18 <solonarv> aha!
09:51:59 <amf> i need to check a list of 2 ints if they are ascending order, i cant find a total way to do this (using relude). can i pattern match on just 2 list items and fail for everything else?
09:53:31 <ski> yes, if you know it should be just two
09:54:17 <ski> @type \[x,y] -> x <= y
09:54:19 <lambdabot> Ord a => [a] -> Bool
09:55:14 * hackage autoapply 0.2.0.0 - Template Haskell to automatically pass values to functions  https://hackage.haskell.org/package/autoapply-0.2.0.0 (jophish)
09:55:22 <amf> ah! i was using (C c1:C c2), thanks!!
09:56:01 <ski> well, `C c1:C c2:[]' would work, but the syntactic sugar `[C c1,C c2]' is usually nicer to read
09:56:49 <ski> (sometimes one can use the former form, when constructing a list, with one list item per line. easier to add/remove/change/reorder elements)
09:59:01 <p0a> Hello I am reading the haddock docs for Base, in particular the IO stuff 
09:59:34 <p0a> so I'm reading that readFile has type FilePath -> IO String. But what takes IO String as an argument?
09:59:50 <p0a> i.e. suppose I wanted to apply `reverse' to the file contents?
10:00:08 <maerwald> reverse <$> readFile foo
10:00:20 <maerwald> IO is a functor
10:00:22 <maerwald> :t fmap
10:00:24 <lambdabot> Functor f => (a -> b) -> f a -> f b
10:01:08 <p0a> Is it possible to obtain this from >> as well?
10:01:23 <EvanR> use >>= to get the result of reading the file and do something with it
10:01:29 <p0a> Right, thank you
10:01:31 <koz_> >> sequences effects, but discards the first value.
10:01:34 <koz_> :t (>>)
10:01:35 <lambdabot> Monad m => m a -> m b -> m b
10:01:56 <koz_> That translates to 'perform effect #1, then effect #2, giving us the value from #2'.
10:02:08 <p0a> Another question I have is about withFile
10:02:10 <p0a> its type is withFile :: FilePath -> IOMode -> (Handle -> IO r) -> IO r 
10:02:17 <p0a> but what is `r' here? it looks like it came from nowhere
10:02:23 <koz_> p0a: Whatever you want.
10:02:24 <EvanR> any type you want
10:02:35 <koz_> Ideally, this should _not_ be the Handle you get given. :P
10:02:45 <dsal> heh
10:02:47 <EvanR> r was picked for "return" I guess
10:02:47 <koz_> (although the type system will not stop you if you wish for such a vile and unwholesome thing)
10:02:48 <p0a> oh like f :: a -> a
10:02:57 <dsal> p0a: what do you want to do with a file?
10:02:58 <koz_> p0a: It helps to think of this as being
10:03:14 <p0a> dsal: I want to read some coordinates and create a data structure
10:03:17 <koz_> forall r . FilePath -> IOMode -> (Handle -> IO r) -> IO r
10:03:20 <dsal> Do you want to return it?
10:03:27 <p0a> the data structure?
10:03:30 <dsal> yeah
10:03:33 <dsal> It sounds like thta's r
10:03:39 <p0a> yeah sure let's say it has a Show and I'd like to see it
10:03:43 <koz_> There's an implicit forall at the beginning of every such declaration naming all type variables.
10:03:50 <dsal> So      withFile :: FilePath -> IOMode -> (Handle -> IO MyDataStructure) -> IO MyDataStructure
10:04:17 <p0a> dsal: should I do that or use readFile and parse the IO String?
10:04:29 <dsal> *shrug*
10:04:33 <p0a> ?
10:04:41 <dsal> It depends on various things.
10:05:11 <p0a> I'm basically reading 4-tuples of integers
10:05:13 <koz_> p0a: withFile is designed to ensure the Handle gets closed automatically.
10:05:15 <EvanR> the point of withFile is you can use the Handle to read incrementally, but it will be closed for you even if an exception occurs
10:05:23 <koz_> This is called the 'bracket pattern'.
10:05:26 <koz_> (or so I keep hearing)
10:05:42 <p0a> and 1 2 3 4 represents the edge connecting the vertex (1,2) to the vertex (3,4)
10:06:25 <EvanR> bracket pattern is great when it's possible
10:07:08 <p0a> something line (readFile "test.txt") >>= (\x -> IO (reverse x)) doesn't work
10:07:13 <p0a> I'm not sure why
10:07:31 <EvanR> IO isn't a function. Maybe you mean return?
10:07:50 <p0a> right
10:08:04 <EvanR> once that works you can simplify that code
10:08:05 <maerwald> use fmap
10:08:09 <EvanR> ^
10:08:13 <maerwald> Don't start with monads
10:08:16 <p0a> how does return know to become an IO monad
10:08:24 <maerwald> type inference
10:08:26 <p0a> okay
10:08:36 <p0a> thats wild
10:09:01 <ski> p0a : overloading. on the return type, in this case
10:09:03 <EvanR> same way + knows to add Ints or Doubles
10:10:01 <p0a> hm, writing a parser will be quite annoying
10:10:11 <ski> why ?
10:10:16 <p0a> I'd have to write a function that reads all the continuous digits and breaks
10:10:20 <p0a> at space or newline
10:10:32 <p0a> Guess I'm spoiled
10:10:46 <EvanR> sounds like you're about to learn about parsing with higher order functions
10:10:57 <EvanR> then you'll be spoiled
10:11:06 <maerwald> I never understood what higher order functions are :D
10:11:15 <p0a> I'll do a first attempt in my own basic ways 
10:11:20 <maerwald> and what lower order is
10:11:57 <EvanR> for example a function that parses by taking a parsing function for the item and a parsing function for the termination pattern to stop at and return a list
10:12:16 <ski> maerwald : first-order function is one which doesn't take functions as arguments. second-order is one which doesn't take functions of order higher than one as arguments. &c.
10:12:48 <maerwald> ski: does `id` take a function as argument? ;P
10:13:04 <maerwald> I find this distinction pretty hard to do in haskell.
10:13:12 <dsal> p0a: writing a parser in haskell is pleasant enough to sell haskell to anyone who has to parse anything
10:13:16 <ski> `id' is not a function, strictly speaking ;)
10:13:32 <ski> `id @(Bool -> Bool)' is second-order
10:13:40 <solonarv> koz_: it's called the "bracket pattern" because 'withFile fp mode = bracket (openFile fp mode) closeFile'
10:13:47 <maerwald> ski: so it is both first and second
10:14:24 <ski> maerwald : it's a polymorphic value, which has both first- and second- order functoin specializations, yes
10:14:33 <koz_> solonarv: I'm aware. :P
10:14:38 <solonarv> I say that something "is a function" if the outermost type constructor of its type is (->)
10:14:38 <maerwald> that's exactly why I have no idea what to do with that definition
10:14:44 <koz_> I too have read Simon's book. :P
10:14:51 <dsal> p0a: are you just reading a single line of four numbers?
10:14:54 <solonarv> maybe I will call these types "function types"
10:16:06 <fendor> the definition I learned at uni is basically, anything in haskell is a higher-order function, except for single values, since every function only takes a single parameter and returns a function
10:16:31 <fendor> a very helpful definition
10:17:18 <EvanR> wait everything returns a function?
10:17:49 <freeman42x[m]> what are the best ways of figuring out where to download a Windows version of a library dependency from? for example: `Configuring library for haskell-gi-base-0.21.5.. cabal.exe: The pkg-config package 'gobject-2.0' version ==2.32 || >2.32 is required but it could not be found.`
10:18:08 <freeman42x[m]> or `Configuring webkit2gtk3-javascriptcore-0.14.4.0... setup.exe: The pkg-config package 'webkit2gtk-4.0' version >=1.1.15 is required but it could not be found.`
10:18:19 <maerwald> gtk is installable on windows?
10:18:37 <monochrom> There is no universal answer.  For gtk, install the windows version of gtk.
10:19:25 <freeman42x[m]> monochrom: was thinking there might be some kind of global store like Chocolatey with a way to search into it for libs or executables
10:19:44 <monochrom> maybe chocolatey covers gtk but I don't know for real
10:19:55 <EvanR> windows package manager D:
10:20:00 <freeman42x[m]> I got those 2 errors above and I do not know what I need to install to provide the right deps
10:20:19 <monochrom> But consider the fact that on windows basically every program comes with its own independent "check for update" feature.
10:20:47 <monochrom> This tells you how anarchic it is on windows.
10:21:44 * hackage haskoin-store 0.23.14 - Storage and index for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-store-0.23.14 (jprupp)
10:21:58 <maerwald> better have linux anarchy, where packagers play CTO and make decisions for users, such as removing mysql in favor of mariadb :P
10:22:09 <monochrom> haha
10:22:20 <solonarv> well, I see "check for update" on some linux programs too. but they just tell me "hey, use the package manager to install new version"; they don't try to do it themselves.
10:22:57 <monochrom> If you also take the stance of "chocolatey requires you to enter complex powershell commands, I am against that", it is also understandable, I won't argue.
10:22:58 <dsal> p0a: If you have a function `parse` that can convert a String to an [Int], you're basically done.  e.g.:
10:22:59 <dsal> > let rf :: String -> Maybe String; rf _ = Just "1 2 3 4";  parse :: String -> [Int]; parse = map read . words   in   parse  <$>  rf "some file"
10:23:01 <lambdabot>  Just [1,2,3,4]
10:23:07 <fendor> EvanR, in haskell, yes. 
10:23:32 <monochrom> But there is a new lighter-weight one called Scoop I heard from here recently.
10:23:34 <dsal> (I guess I could've used IO here, but it's just a different Functor)
10:23:34 <ski> fendor : that doesn't make any sense to me :/
10:23:47 <p0a> here's my "extract numbers"
10:23:48 <p0a> https://pastebin.com/yBLEL2tn
10:23:58 <monochrom> Still requires powershell commands, but seems simpler.
10:24:03 <ski> @where everything-is-a-function
10:24:03 <lambdabot> http://conal.net/blog/posts/everything-is-a-function-in-haskell
10:24:09 <ski> fendor ^
10:24:13 <EvanR> fendor: it seems inaccurate, to be somewhat pedantic. E.g. the function chr :: Int -> Char
10:24:59 <dsal> p0a: Oh, do you have things that aren't numbers you want to worry about?
10:24:59 <p0a> dsal: check my link if you'd like
10:25:11 <p0a> dsal: well there's going to be blank spaces and newlines etc
10:25:17 <monochrom> I propose that "everything is a function" is true or false depending on how the audience disambiguates "everything".
10:25:30 <scasc> .
10:26:04 <maerwald> monochrom: true and false -- ha-ha
10:26:10 <EvanR> perhaps it goes te other way: function are everything, i.e. all you need is lambda
10:26:15 <freeman42x[m]> it seems that webkit2gtk is not available on Windows, pretty glad I did not build more using it. That means switching to Electron, NWJS or other
10:26:31 <monochrom> Like if I say "everyone is in #haskell" it is true if I say it to #haskell, false if I say it to ##c, etc.
10:26:54 <maerwald> you're thinking like a teacher
10:26:57 <maerwald> oh wait
10:26:59 <EvanR> is audience dependence one of your wise tautologies
10:27:00 <monochrom> haha
10:27:46 <dsal> p0a: mine deals with blank spaces and newlines.
10:28:18 <p0a> dsal: nice
10:28:53 <monochrom> p0a: Is it simpler to use "words" for "  123   456   " -> ["123", "456"] ?
10:29:14 <monochrom> to be sure, it won't play well with presence of letters etc
10:29:15 <scasc> oh, so p0a's still there?
10:29:23 <scasc> How's your progress?
10:29:45 <p0a> Well I just started reading about IO a bit. I realized the haddock docs for Base are quite useful
10:30:06 <dsal> p0a: IO is a functor.  Func it.
10:30:17 <p0a> func town
10:30:18 <monochrom> \‚à©/ finally someone who agrees that base doc doesn't suck :)
10:30:46 <dsal> All docs suck when they're new to you.
10:30:50 <EvanR> haskell docs both suck and don't suck
10:31:14 <Rembane> Schr√∂dinger's docs
10:31:19 <monochrom> maerwald should be playing a "it depends on the audience" on me now... :)
10:31:40 <maerwald> dsal: no
10:31:57 <maerwald> optics is the best example of a package with very complicated semantics and excellent documentation
10:32:02 <maerwald> But I don't know many others
10:32:10 <dsal> @hackage optics
10:32:10 <lambdabot> http://hackage.haskell.org/package/optics
10:32:19 <pera> There are four types of documentation: https://documentation.divio.com/
10:32:22 <p0a> If you want to see some really terrifying docs, I recommend "Gnus", the e-mail client for Emacs
10:32:47 <dsal> Well that's not a good example....
10:32:48 <monochrom> No I think the Gnus manual was fine.
10:33:11 <monochrom> Or perhaps s/fine/OK/
10:33:11 <maerwald> Most people think coding is harder than writing documentation
10:33:15 <dsal> gnu info was so hard to read I had to read the manual telling me how to read the manual before I could read any manual.  Like, each time.
10:33:23 <monochrom> It was not great but it was not terrifying.
10:33:32 <p0a> what's your worst then? :P
10:33:33 <EvanR> there are 4 kinds of docs: tutorials, how-to guides, technical reference, and explanation. If you can't be helped with any of these, here is a video presentation
10:33:35 <maerwald> so they code very hard, then are exhausted and have 5% energy left to write some shitty docs
10:33:56 <dsal> I'm very aware that docs are the hardest part.
10:34:24 <dsal> I write code and then people want me to explain what it does and I'm like... I just did.
10:34:41 <monochrom> I think java.util container library doc is worst.  "insert(x).  insert x."  The hell I need a doc to tell me that.
10:34:47 <maerwald> the problem with documentation is, that content alone is the smallest parts, the biggest part is getting the structure right. And then you realise you have to re-arrange your modules and redo half of your code, because the documentation would otherwise suck
10:34:49 <maerwald> ugh
10:35:31 * ski . o O ( "What nobody tells you about documentation" by Daniele Procidaa at <https://www.divio.com/en/blog/documentation/> )
10:35:58 <maerwald> I've had people argue to not write documentation, because it outdates too quickly. I still don't know what I think about that.
10:36:18 <EvanR> eXtreme documentation
10:36:26 <dsal> Oh, the optics docs looked because it's a listing of things without docs.  But then the actual package doc is actually pretty nice.
10:36:35 <p0a> here's a question, a bit related to algorithms now
10:36:36 <dsal> s/looked/looked bad/
10:36:46 <dsal> p0a: false.  That was not a question.
10:36:48 <maerwald> dsal: yes and the sections are structured consistently across all modules
10:37:00 <p0a> I have a circular 2D matrix and between two elements there may be an edge
10:37:17 <p0a> so in other words you can imagine Edge (Vertex 1 2) (Vertex 3 4)
10:37:32 <p0a> but it's circular so I want to be able to add the vertices and "loop" back (i.e. mod N arithmetic)
10:37:33 <maerwald> formation, elimination, computation, ...
10:37:39 <maerwald> You know where to find everything
10:38:11 <maerwald> and then a graphical view on the optics hierarchy that is useful 
10:38:14 <ski> EvanR : i guess you had that one in mind, yes ?
10:38:16 <p0a> I feel like the "Graph" is distinct from the "circular" structure of the vertices. I should be able to compartmentalize these right?
10:38:24 <EvanR> ski: pera linked to it earlier
10:38:39 <ski> ah, i missed that
10:38:40 <monochrom> p0a: Is it a cylinder? Is it a torus?
10:38:48 <p0a> monochrom: it's a torus 
10:38:58 <p0a> a 2 dimensional N by M torus
10:39:23 <maerwald> https://i.imgur.com/ALlbPRa.png vs https://hackage.haskell.org/package/optics-0.3/docs/diagrams/optics.png
10:39:40 <pera> ^_^
10:40:56 <monochrom> Yes, the graph is independent of the torus.
10:41:40 <p0a> but is it possible that the graph 'Vertex' "inherits" the additive structure of the points of the torus?
10:41:44 <monochrom> Is this some kind of Pac Man but with worm hole portals? :)
10:42:05 <p0a> ooh no :P I'm taking a look at a discrete problem
10:42:59 <p0a> and a simpler question: if I have a function f :: Int -> Int -> Int and I want to apply it to [Int] like so [1,2,3,4] => [f 1 2, f 3 4] (so Maybe ?) how would I do that?
10:43:13 <p0a> oh, zip?
10:43:25 <monochrom> At this point I guess yes?  A vertex is a tuple like (3,4) being an index into the torus array.
10:43:55 <dsal> zip doesn't give you two things, though.  You could use it with chunksOf
10:43:59 <dsal> :t chunksOf 2
10:43:59 <monochrom> and (3+k*n, 4+i*m) is considered equal to (3, 4) (the torus structure)
10:44:00 <lambdabot> [e] -> [[e]]
10:44:14 <monochrom> (I may have swapped n and m)
10:44:27 <p0a> dsal: I was thinking of map (\(x,y) -> f x y) $ zip myList myList
10:44:35 <EvanR> you wanted pairs of numbers but you have a list of single numbers
10:44:47 <dsal> :t zipWith -- p0a 
10:44:49 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
10:44:54 <EvanR> make your parser produce the pairs
10:44:55 <ski> that would also give you `f 2 3' (assuming you meant to shift one list to the side), p0a
10:44:55 <dsal> But that's not what you have.
10:45:10 <p0a> yeah I was wrong
10:45:33 <solonarv> > zipWith f [1,2,3,4] [1,2,3,4] -- not what you want, is it?
10:45:36 <lambdabot>  error:
10:45:36 <lambdabot>      ‚Ä¢ Ambiguous type variable ‚Äòc0‚Äô arising from a use of ‚Äòshow_M182468684442...
10:45:36 <lambdabot>        prevents the constraint ‚Äò(Show c0)‚Äô from being solved.
10:45:45 <solonarv> grumble grumble
10:45:48 <p0a> you can do it with x:y:xs = f x y : repeat f xs
10:45:50 <solonarv> > zipWith f [1,2,3,4] [1,2,3,4] :: Expr
10:45:51 <lambdabot>  error:
10:45:52 <lambdabot>      ‚Ä¢ Couldn't match expected type ‚ÄòExpr‚Äô with actual type ‚Äò[c0]‚Äô
10:45:52 <lambdabot>      ‚Ä¢ In the expression:
10:45:52 <p0a> by `repeat' I mean iterate
10:46:00 <solonarv> > zipWith f [1,2,3,4] [1,2,3,4] :: [Expr]
10:46:01 <EvanR> that too
10:46:01 <lambdabot>  [f 1 1,f 2 2,f 3 3,f 4 4]
10:46:04 <solonarv> aha!
10:46:23 <p0a> I was trying to get f [1,2,3,4] ===> [f 1 2, f 3 4] though
10:46:23 <EvanR> basically a manual looping strategy
10:46:58 <p0a> I thinnk I can do it with take 2 / drop 2
10:47:31 <dsal> (a:b:c:d:xs)
10:47:38 <EvanR> having a list of pairs or two lists in the first place would be better i think
10:48:31 <dsal> megaparsec is the sledge hammer I hang pictures with.
10:48:42 <EvanR> actually the parser is in the best place to operate on two at a time elements, or detect the second one of the last pair is missing
10:49:46 <dsal> It'd give you a nice error telling you that you forgot a thing.
10:50:41 <ski> > chunksOf 2 [0 .. 8]
10:50:43 <lambdabot>  [[0,1],[2,3],[4,5],[6,7],[8]]
10:51:31 <p0a> oooh, chunksOf. thank you 
10:52:16 <p0a> can I do import Data.List (chunksOf) or do I need to write Data.List.Split ?
10:52:45 <dsal> @hoogle chunksOf
10:52:45 <lambdabot> Data.Sequence chunksOf :: Int -> Seq a -> Seq (Seq a)
10:52:45 <lambdabot> Data.Sequence.Internal chunksOf :: Int -> Seq a -> Seq (Seq a)
10:52:45 <lambdabot> Data.Text chunksOf :: Int -> Text -> [Text]
10:52:52 <dsal> Well that isn't helpful.
10:52:58 <dsal> @index chunksOF
10:52:58 <lambdabot> bzzt
10:52:59 <dsal> @index chunksOf
10:53:00 <lambdabot> bzzt
10:53:08 <dsal> Anyway, it's not in base
10:53:59 <dsal> The list processing you'll have to do is a bit gross.
10:54:48 <monochrom> > Data.List.chunksOf
10:54:50 <lambdabot>  error:
10:54:50 <lambdabot>      Not in scope: ‚ÄòData.List.chunksOf‚Äô
10:54:50 <lambdabot>      No module named ‚ÄòData.List‚Äô is imported.
10:54:54 <monochrom> > Data.List.Split.chunksOf
10:54:56 <lambdabot>  error:
10:54:56 <lambdabot>      ‚Ä¢ No instance for (Typeable e0)
10:54:56 <lambdabot>          arising from a use of ‚Äòshow_M23822698077752552253677‚Äô
10:55:02 <monochrom> That's the one.
10:56:34 <dsal> You make a list of characters and convert it to a list of lists of characters and then into a list of numbers and then into a list of lists of numbers and then into a list of your type.  You'll have to verify you get the right stuff in that last phase.  The obvious thing is to make a partial function.
11:10:38 <p0a> here it is: https://pastebin.com/929BnVw4
11:11:10 <p0a> complete with error checking. Will `extractNumbers <$> readFile "test.txt"' work fine? I am not sure about Maybe working with IO
11:11:31 <p0a> it worked when the file had the right contents, I'll try to modify it to have bad contents
11:12:20 <p0a> yeah it works. How can I add error reporting to this? I'd like it to explain to the user that the file didn't have the right format when it fails
11:12:30 <p0a> is it something like `if foo == Nothing then error else continue' ?
11:12:50 <dsal> if you could avoid that 'length' that'd be good.
11:13:11 <p0a> the indentation on line 13. is messed up, how should I had indented it?
11:13:20 <toni37> > foldl (*) 0 [1..10^8]
11:13:26 <p0a> avoid length? 
11:13:27 <lambdabot>  mueval-core: Time limit exceeded
11:13:54 <dsal> p0a: You're flipping through the list entirely once just to figure out if when you flip through it whether it'll have the right number of items.
11:14:06 <dsal> Maybe monad might be an easy way to do this.
11:14:20 <p0a> dsal: I can modify the lambda as well I think
11:14:27 <p0a> [[x,y],[z,w]] is good, otherwise bad
11:14:29 <dsal> I also tend to really dislike if/then/else
11:15:24 <dsal> Hmm...   Let me think a sec.
11:15:26 <p0a> well honestly this is a small list :P like 1000 bytes long at most
11:15:35 <p0a> okay
11:16:21 <dsal> It's hard to think in lambdabot. heh
11:21:00 <p0a> for example if I use `case ... of ...' I can return Nothing when it's not of the form [[x,y],[z,w]]
11:21:27 <p0a> so then I'll have a [Maybe Edge]. Do I then use whatever monadic tool takes [m a] to m [a] ?
11:22:01 <dsal> Yeah, I'm starting to write too much code to do this well.
11:22:04 <dsal> :t sequenceA
11:22:06 <lambdabot> (Traversable t, Applicative f) => t (f a) -> f (t a)
11:22:37 <dsal> But at that point, you just want traverse.
11:23:29 <dsal> > traverse (\x -> if odd x then Nothing else Just x) [2,4,6]
11:23:31 <dsal> > traverse (\x -> if odd x then Nothing else Just x) [2,4,6,7]
11:23:31 <lambdabot>  Just [2,4,6]
11:23:33 <lambdabot>  Nothing
11:23:44 <p0a> nice
11:23:46 * dsal doesn't like if, but it's helpful here
11:23:56 <p0a> wait so you're saying the if version is better?
11:24:06 <p0a> I kinda like the traverse thing
11:24:08 <dsal> No, *your* if version is bad for a couple reaosns.
11:25:06 <p0a> I can't get the indentation right no matter what I Try lol
11:27:05 <koz_> % > traverse (\x -> guard (even x) $> x) [2, 4, 6, 7] 
11:27:05 <yahb> koz_: ; <interactive>:11:1: error: parse error on input `>'
11:27:12 <koz_> %  traverse (\x -> guard (even x) $> x) [2, 4, 6, 7] 
11:27:12 <yahb> koz_: *** Exception: user error (mzero)
11:27:39 <ski> % traverse (\x -> guard (even x) $> x) [2,4,6,7] :: Maybe [Integer]
11:27:40 <yahb> ski: Nothing
11:27:55 <koz_> ski: Ah, damn that polymorphism. :P 
11:28:03 <dsal> So many morphisms.
11:29:28 <ski> % sequenceA [[x | even x] | x <- [2,4,6,7]] :: Maybe [Integer]
11:29:28 <yahb> ski: Nothing
11:29:29 <dsal> p0a's problem would be so pleasant with megaparsec.
11:29:32 <p0a> https://pastebin.com/kXQNhJjk
11:29:40 <p0a> I am getting complaints here
11:29:48 <p0a> I don't know how to fix this one, it's hard
11:30:06 <p0a> dsal: I'll give megaparsec a go, I wouldn't mind. But I want to do it the hard way first to get a feeling for it
11:30:23 <dsal> It's differently hard if you also have to learn megaparsec.
11:30:32 <p0a> then perhaps I should stick to this
11:30:36 <dsal> This path is good.  It's just getting rid of chunksOf.
11:30:45 <dsal> Because you really want to do that twice.
11:30:56 <dsal> :t fmap (chunksOf  2) . chunksOf 2
11:30:57 <lambdabot> [e] -> [[[e]]]
11:31:34 <p0a> do you see any errors in the code I pasted?
11:31:34 <dsal> > let doubleChunks = fmap (chunksOf  2) . chunksOf 2 in   doubleChunks [0..17]
11:31:36 <lambdabot>  [[[0,1]],[[2,3]],[[4,5]],[[6,7]],[[8,9]],[[10,11]],[[12,13]],[[14,15]],[[16,...
11:31:38 <koz_> dsal: So chonky.
11:32:04 <dsal> Oh, you are doing double chunks.
11:32:26 <p0a> yeah the elements of the list are of the form [[x,y],[z,w]]
11:32:35 <dsal> Why traverse . map ?
11:32:47 <p0a> oh that was a remnant 
11:33:13 <p0a> that's what it was! thanks !
11:33:19 <monochrom> yeah
11:33:56 <p0a> that's pretty cool
11:33:59 <dsal> This is actually pretty decent.  The parser will keep you from having to do the chunks, but otherwise it seems pretty decent.  Not partial, handles the Edge cases, etc...
11:34:24 <p0a> we did it bois
11:34:25 <p0a> we chunked it
11:34:48 <p0a> and girls, gender inclusive
11:34:57 <dsal> in a parser, you'd be able to write something like:     some (Edge <$> point <*> point)
11:35:02 <dsal> Chunk Squad
11:35:23 <p0a> and what does `some' mean?
11:35:26 <dsal> :t some
11:35:28 <lambdabot> Alternative f => f a -> f [a]
11:35:34 <dsal> You know, like some.
11:35:34 <ski> p0a : "at least one"
11:35:46 <p0a> so it even reads files with noise?
11:35:55 <p0a> like "1 2 3 4 blah"
11:35:57 <ski> what kind of noise ?
11:35:58 <dsal> It reads what you want it to read.
11:36:16 <dsal> If you didn't account for that, it'd give you an error telling you that at line x, column y, there's a b when you expected a number.
11:36:20 <p0a> well nevermind, that is too advanced for me
11:36:28 <p0a> that's nice though
11:36:42 <dsal> Or in the case of "1 2 3" it'd be like, hey, there should be another number here, but whoever wrote your input is an idiot.
11:38:26 <ski> @palomer
11:38:26 <lambdabot> (_|_)
11:39:07 <p0a> lol
11:39:53 <ski> @help palomer
11:39:53 <lambdabot> palomer. Sound a bit like palomer on a good day.
11:40:47 <ski> @keal
11:40:47 <lambdabot> i show how spell triangle in less than three corners using darkmanifold
11:40:55 <Julian10> Hi, can someone help me with how I can code a small programm in haskell which asks for a number and returns the triple of that number?
11:41:11 <ski> what have you got, so far, Julian10 ?
11:41:20 <maerwald> that sounds overly specific :>
11:43:04 <koz_> Julian10: Is this homework?
11:43:26 <koz_> maerwald: Also, did you see my message vis-a-vis passing options to host GHC for ghcup compile?
11:43:41 <maerwald> not really, what was it
11:44:26 <Julian10> @ski I already tried different ways, but no way worked :/. I tried it with a do block, Integral, digitToInt, etc.
11:44:26 <lambdabot> Maybe you meant: wiki src ask
11:44:47 <Julian10> @koz_ Yes xD
11:44:48 <lambdabot> Unknown command, try @list
11:45:31 <koz_> maerwald: In order for the build not to fail, I need to be able to specify to my host GHC to use LLVM. However, I can't do that right now - the necessary thing is to pass -pgmlc and -pgmlo with the right binaries.
11:45:47 <koz_> Julian10: No need to @-tag, just type the name.
11:46:01 <koz_> Julian10: What have you got so far? Could you put it in a Github gist or other paste service?
11:46:01 <Julian10> Ok :)
11:46:06 <maerwald> koz_: pass to what?
11:46:14 <koz_> maerwald: The host GHC.
11:46:20 <koz_> Being used in ghc compile.
11:46:27 <maerwald> is this a configure switch?
11:46:30 <koz_> maerwald: No.
11:46:38 <koz_> It's a GHC compiler flag.
11:46:46 <koz_> s/compiler//
11:46:51 <maerwald> maybe this can be done in build.mk
11:47:00 <maerwald> but it's not too well documented, if it can be
11:47:06 <koz_> maerwald: You're the bigger expert on build.mk than me. :P
11:47:29 <koz_> But I suspect that's the last hurdle.
11:47:53 <Julian10> https://gist.github.com/JulianW99/2a5b5f53e59b62982f1207fd4e26f486
11:47:58 <p0a> so now that I have extractNumbers :: String -> [Edge] which I can combine with readFile myFile, how can I put it all together in main?
11:48:09 <p0a> I tried show $ extractNumbers <$> readFile myFile
11:48:12 <koz_> Julian10: Here's a clue.
11:48:17 <koz_> :t getLine
11:48:18 <lambdabot> IO String
11:48:23 <p0a> oh I need putStrLn with show right?
11:48:28 <koz_> Can you multiply a String by a number?
11:48:52 <Julian10> But we have to do it with Integer -> Integer
11:49:02 <koz_> Julian10: Yes, but that's my point.
11:49:08 <koz_> You don't _have_ an Integer.
11:49:11 <koz_> You have a String.
11:49:22 <koz_> So you first have to write code which takes said String, and turns it _into_ an Integer.
11:49:34 <Julian10> Yeah I know. That's why I tried to use digitTiInt
11:49:47 <koz_> What's digitTiInt?
11:49:53 <Julian10> Can I do that with DigitToInt?
11:49:55 <Julian10> Wait
11:50:26 <Julian10> https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Char.html#v:digitToInt
11:50:32 <koz_> :t digitToInt
11:50:34 <Julian10> *digitToInt
11:50:34 <lambdabot> Char -> Int
11:50:42 <koz_> It's a possible step.
11:50:55 <koz_> String is the same as [Char], so you can try it and see where it leads you.
11:51:10 <Julian10> I tried it and I only got errors
11:51:16 <koz_> Julian10: What did you try?
11:51:22 <koz_> Like, exact code.
11:51:35 <p0a> oh I see, I need to use >>= 
11:52:32 <Julian10> After I used zahl <- getLine
11:53:00 <Julian10> I tried to get the entered "zahl" to a int with digitToInt [zahl]
11:53:13 <koz_> Julian10: Let's thing about the types of this.
11:53:23 <koz_> zahl <- getLine means zahl :: String
11:53:27 <koz_> String is [Char]
11:53:33 <koz_> So thus, zahl is [Char]
11:53:40 <koz_> Therefore, [zahl] is [[Char]]
11:53:49 <koz_> But digitToInt is of type Char -> Int
11:53:53 <koz_> [[Char]] is not Char
11:53:57 <koz_> So of course this won't work.
11:54:16 <koz_> Number 1 rule of Haskell: follow the types.
11:54:26 <koz_> Get into the habit of this kind of thinking.
11:55:22 <Julian10> I also tried to get the type of digitToInt with :t digitToInt
11:55:31 <Julian10> But it said  error: Variable not in scope: digitToInt
11:56:08 <koz_> Because its module isn't imported.
11:56:15 <koz_> % :info digitToInt
11:56:15 <yahb> koz_: digitToInt :: Char -> Int -- Defined in `Data.Char'
11:56:26 <koz_> So you need Data.Char imported.
11:56:53 <Julian10> Ohh. Thank you
11:56:58 <Julian10> I'll try it with that
11:57:06 <koz_> Julian10: No problem. It'll get easier with practice.
11:57:09 <maerwald> koz_: there is EXTRA_HC_OPTS
11:57:21 <koz_> maerwald: That should be it then!
11:57:25 <koz_> Thanks, will try again today.
11:57:29 <maerwald> but I don't know if it's enough to set it as env variable or whether it needs to be passed to make
11:57:40 <koz_> It gives me something to try.
11:57:45 * hackage cabal2nix 2.15.3 - Convert Cabal files into Nix build instructions.  https://hackage.haskell.org/package/cabal2nix-2.15.3 (PeterSimons)
11:58:19 <Julian10> Yeah it's my first week with Haskell xD
11:59:51 <Julian10> How can I convert the String to Int?
11:59:54 <Julian10> I tried error: parse error on input `>>>'
12:00:07 <Julian10> *I tried >>> digitToInt 'zahl'
12:00:24 <Julian10> But I get the error above
12:01:01 <koz_> What's >>> got to do with it?
12:01:13 <koz_> You've gotten as far as zahl <- getLine.
12:01:17 <koz_> (also, the name is unhelpful af)
12:01:24 <koz_> (you don't have a number, you have a string)
12:01:28 <p0a> Julian10: digitToInt is a function that does not do what you want, it does something related however.
12:01:44 <p0a> So you need to figure out what it does, and then how to combine it with other things to do what you want
12:01:47 <koz_> You have a String.
12:01:51 <koz_> A string is [Char].
12:01:59 <koz_> You have a function which takes a Char and turns it into an Int.
12:02:05 <Julian10> So if I do x <- getLine and enter 2
12:02:05 <koz_> So you need to use some kind of list processing thing.
12:02:17 <Julian10> How can I multiply that x with 3?
12:02:20 <koz_> getLine used this way gives you a String.
12:02:26 <koz_> It doesn't matter what you enter.
12:02:30 <koz_> It will give a String.
12:02:47 <koz_> It is your responsibility to then take said String, which is [Char] as I keep saying, and turn it _into_ something you can multiply.
12:02:51 <koz_> String is [Char].
12:02:53 <p0a> try this: map digitToInt "123"
12:02:54 <koz_> So list of Char.
12:03:09 <Julian10> Yeah thats logically. I just used x now, because it's not so unhelpful
12:03:56 <koz_> So you clearly need to use some sort of list processing.
12:04:07 <koz_> if you want to use digitToInt, there's two steps.
12:04:17 <koz_> 1. Turn every Char into an Int
12:04:24 <koz_> 2. Combine all those Ints to make a single Int
12:04:40 <koz_> For this, you need list processing functions, which I guess you have been given or taught, right?
12:05:22 <Julian10> I don't have/want to use digitToInt especially. I just want to use x*3 correctlly+
12:05:39 <Julian10> Yes that's right
12:05:57 <koz_> Julian10: Well, you suggested digitToInt as a possible solution.
12:06:08 <koz_> I'm just helping you follow this to its logical conclusion.
12:06:14 <Julian10> Yes I can try it with digitToInt
12:06:18 <koz_> And the problem isn't 'using x*3 correctly'.
12:06:21 <Julian10> Thank you :)
12:06:26 <Julian10> Yeah
12:06:29 <koz_> The problem is that your input data is in a format that you can't just apply random stuff to.
12:06:32 <koz_> You get Strings.
12:06:34 <koz_> That's just it.
12:06:37 <koz_> getLine gives Strings.
12:06:39 <koz_> Strings.
12:06:41 <koz_> Not Ints.
12:06:43 <koz_> Not Chars.
12:06:45 <koz_> Not anything else.
12:06:47 <koz_> STRINGS.
12:06:49 <Julian10> Yes I Know xD
12:06:53 <dsal> p0a: you can also use =<<
12:06:57 <koz_> It is _your_ problem to then turn those _STRINGS_ into something else.
12:07:03 <koz_> This is the challenge of the exercise.
12:07:15 <koz_> The *3 is a trivial aspect of the problem which doesn't matter one iota.
12:07:18 <dsal> p0a: print =<< (parse <$> readFile "filename")
12:07:53 <koz_> I suggest looking back over the list processing functions you've learned as a start.
12:08:07 <koz_> Figure out at least how to take the step from String -> [Int] using digitToInt _as part of_ that.
12:08:23 <koz_> This means 'no, I iwll not just jam digitToInt into random places and hope it works somehow'.
12:08:41 <koz_> This means 'I will read all the list processing stuff I've been given, twice, think carefully about the types, and then try it, together with other things'.
12:09:02 <koz_> Once you get that far, the next step is to think about how to go from [Int] (which is a list of digits) to a single Int.
12:09:05 <koz_> Same process applies.
12:09:17 <Julian10> I will try it
12:09:22 <Julian10> Thank you for your help
12:09:30 <koz_> Julian10: No worries. Give it a go, see where you get.
12:09:37 <Julian10> I'll
12:09:51 <p0a> dsal: thank you
12:10:19 <dsal> =<< is just >>= the other way.  I like to think left when I'm printing or something.
12:10:51 <koz_> :t (>>=)
12:10:52 <lambdabot> Monad m => m a -> (a -> m b) -> m b
12:11:04 <koz_> A good mnemonic is that the > aims at the function argument.
12:11:30 <koz_> s/the > aims/the >s aim/
12:17:07 <p0a> dsal: I'm thinking of the << or >> as the direction of the flow
12:17:42 <dsal> @hackage tardis
12:17:43 <lambdabot> http://hackage.haskell.org/package/tardis
12:17:55 <dsal> ^ sorry about your brain
12:18:23 <p0a> yeah, wow
12:19:01 <disconsis> dsal: wtf
12:19:06 <disconsis> this is breaking my brain a little bit
12:19:10 <dsal> Example:  https://www.irccloud.com/pastebin/dnwzJzOO/tard.hs
12:19:14 <koz_> disconsis: Yeah... it's a bit wtf.
12:19:34 <disconsis> nice filename
12:21:14 <tobiasBora> Hello, I'd like to do a kind of recursive call on a (smaller) Map, like we usually do on List, what is the best way to proceed? The reason I don't want to use Fold is that usually I don't need to traverse the whole Map/List to get the result, and I usually stop before. I could convert the map to a list, and then redo the same, but I'm not sure how efficient it is, and I've the feeling I'm missing a more
12:21:17 <tobiasBora> adapted tool.
12:22:11 <koz_> tobiasBora: Define 'smaller'.
12:22:29 <disconsis> not sure how you're using it, but haskell is lazy so if you don't need it it won't get computed
12:23:32 <Feldmaus> Is there a simpler way to round to the next multiple of p than \n -> p * (n `div` p + 1)?
12:23:56 <koz_> Feldmaus: monochrom showed me a really clever way, but I have forgotten it.
12:25:12 <disconsis> > (\n p -> n + p - (n `mod` p)) 5 7
12:25:14 <lambdabot>  7
12:25:22 <disconsis> lol bad example
12:25:34 <disconsis> > (\n p -> n + p - (n `mod` p)) 18 5
12:25:36 <lambdabot>  20
12:25:44 * hackage ejdb2-binding 0.3.0.0 - Binding to EJDB2 C library, an embedded JSON noSQL database  https://hackage.haskell.org/package/ejdb2-binding-0.3.0.0 (buro)
12:25:47 <tobiasBora> koz_: I mean, with lists I kind do "myfunction [] = Just False; myfunction (x:r) = <some code that can eventually call (myfunction r)>". How can I code something like that with Map?
12:26:21 <koz_> tobiasBora: Maps don't work that way.
12:26:32 <koz_> What exactly are you trying to do?
12:27:26 <disconsis> tobiasBora: does the RHS need to use "x" here?
12:28:29 <Feldmaus> disconsis: Nice, thanks
12:28:48 <tobiasBora> disconsis: yes.
12:29:10 <disconsis> tobiasBora: you want fold then
12:29:19 <tobiasBora> koz_: disconsis : Here is basically the code I'd like to do if it was a list and not a map http://paste.debian.net/1144214
12:30:04 <tobiasBora> disconsis: but fold will traverse the whole list no? Quite often I'll be able to say the result without traversing the whole list
12:30:11 <koz_> tobiasBora: Not necessarily.
12:30:20 <koz_> I would say 'write a fold and don't worry about it'.
12:30:37 <disconsis> You might want to look into the docs for `foldr`
12:30:45 <disconsis> :t foldr
12:30:46 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
12:31:08 <koz_> Also read this: https://apfelmus.nfshost.com/articles/lazy-eval-intro.html
12:31:11 <tobiasBora> disconsis: but foldr can't be "strict" right?
12:31:36 <koz_> tobiasBora: What do you mean by that?
12:31:38 <disconsis> tobiasBora: hmm not sure what you mean. Sounds like you *want* laziness
12:31:46 <koz_> You can use foldr to implement foldl', so it TOTES can.
12:31:52 <koz_> I would again recommend reading what I just linked.
12:31:55 <koz_> Like, the whole series.
12:32:49 <disconsis> > foldr const 0 [1,2,undefined]
12:32:50 <lambdabot>  1
12:33:03 <disconsis> obiasBora: doesn't traverse the whole list
12:33:16 <koz_> > foldr const 0 [1..]
12:33:19 <lambdabot>  1
12:33:23 <disconsis> lol
12:33:53 <disconsis> koz_: implementing foldl with foldr always confused me
12:34:07 <disconsis> I just joined the types together somehow and it worked
12:34:45 <koz_> disconsis: You've just described 90% of my Haskell workflow.
12:34:52 <koz_> 'join the types together somehow and it works'.
12:35:10 <koz_> maerwald: Where is EXTRA_HC_OPTS documented?
12:35:18 <tobiasBora> ok thanks, give me 2mn then, I'll be back ;) And just to explain what I want to do, I have a logical disjunction of literals represented in a Map (like "a or (not b) or c") and I have a partial valuation of these variables, and I want to return Just True if the valuation is enough to claim that the disjunction eval to true, Just False if for sure the disjunction evals to true, and Nothing if I can't say
12:35:19 <koz_> It doesn't look like a ghcup thing.
12:35:20 <tobiasBora> because some variable need to be instanciated.
12:35:23 <koz_> Or rather, its docs don't mention it.
12:35:42 <koz_> tobiasBora: You probbo want traverseWithKey.
12:35:50 <koz_> If you hit a Nothing, it'll stop early.
12:37:01 <koz_> tobiasBora: Also, why a Map?
12:37:10 <koz_> Your keys are your literals, and your values are???
12:37:29 <maerwald> koz_: it's in GHC build system
12:37:38 <tobiasBora> koz_: Oh, sorry, I meant Set from the very beginning... I was confused because the assignment is the map
12:37:42 <koz_> maerwald: Ah, so it goes in build.mk.
12:37:49 <maerwald> Or just env variable
12:37:52 <koz_> tobiasBora: OK, so what you're saying is you have something like
12:37:53 <maerwald> I'm not sure either
12:38:17 <koz_> foo :: Set Literal -> ??? -> Maybe Bool
12:38:26 <koz_> So what's the ??? that describes your partial valuation?
12:39:13 <tobiasBora> koz_: foo: Set Literal -> Map Var Bool -> Maybe Bool
12:39:27 <koz_> OK, so you 100% want foldrWithKey here.
12:39:52 <koz_> The Set Literal just just a lookup target.
12:41:12 <koz_> Or actually, hold on.
12:41:23 <koz_> What's the difference between Literal and Var here?
12:42:03 <tobiasBora> koz_: Hum, but I want to loop on my Set, not on my Map (as I said I used Map instead of Set from the very beginning, my bad)
12:42:18 <tobiasBora> koz_: and Literal can be either a Variable (Var) or the negation of a Variable
12:42:23 <koz_> Ah.
12:42:33 <koz_> Then you want foldr on the Set.
12:43:34 <tobiasBora> koz_: Ok thanks a lot, I'll read your document and clear my mind first (my brain is a bit rusted with lazyness and foldr)
12:44:13 <disconsis> tobiasBora: what you were doing earlier on the list was equivalent to writing foldr for lists
12:44:22 <disconsis> This is the same interface
12:44:46 <tobiasBora> disconsis: it's lazyness that allows you to stop without evaluating the whole list?
12:44:56 <disconsis> tobiasBora: yep
12:45:12 <tobiasBora> disconsis: ok cool. Lazyness is maybe less absurd that I thought :P
12:45:17 <tobiasBora> than*
12:45:34 <disconsis> haha yeah, it's a pretty cool concept
12:49:59 <disconsis> only in haskell have I found libraries that I struggle to understand
12:50:44 <disconsis> I give up - I'm not getting tardis half asleep
12:52:06 <dsal> disconsis: it's a state monad and a reverse state monad at the same time.
12:52:43 <disconsis> dsal: I stared at the reverse state monad and I've sort of convinced myself I get it
12:52:45 * hackage plzwrk 0.0.0.0 - A front-end framework  https://hackage.haskell.org/package/plzwrk-0.0.0.0 (mikesol)
12:52:54 <dsal> I used the reverse state bits only there...  I think base has a reverse state, but it's not exposed.  It's an implementation detail for mapAccum L vs. R
12:53:01 <dsal> Or I'm making stuff up, I can't remember which.
12:53:54 <dsal> Approach life like a reverse state monad.  You can use it as if you understand it now as long as you put the effort in at some point in the future.
12:55:31 <disconsis> lol
12:58:22 <disconsis> Why does it not surprise me that there was a paper on this
12:58:45 * hackage hjsonschema 1.10.0 - JSON Schema library  https://hackage.haskell.org/package/hjsonschema-1.10.0 (seagreen)
13:05:57 <p0a> To deal with graphs (vertices, edges) should I use a library or write my own code?
13:06:49 <Rembane> p0a: I think the easiest is that you create a representation that works best for the problem.
13:06:52 <berndl> p0a: depends what you need to do.
13:07:20 <berndl> I like https://hackage.haskell.org/package/algebraic-graphs though.
13:07:40 <dmwit> I recommend using a library.
13:09:38 <fragamus> hey is the syntax of the ghc parse trees different than haskell-src-exts
13:10:10 <fragamus> I mean can anyone characterize how different these are
13:10:27 <p0a> berndl: thank you, will take a look
13:10:49 <Cale> p0a: *sometimes* just using Map Vertex (Set Vertex) directly will work out okay, depending on what you're doing
13:11:11 <dsal> :t _1
13:11:12 <lambdabot> (Field1 s t a b, Functor f) => (a -> f b) -> s -> f t
13:11:40 <p0a> Cale: I want something flexible 
13:11:52 <p0a> Cale: my last code was in C++ and I had to keep adding features to my crappy implementation
13:11:55 <p0a> lots of hacks 
13:12:01 <Cale> If you want an *abstraction* for graphs, that's obviously not what this is
13:12:12 <Cale> But most of the abstractions for graphs will admit things like this
13:13:08 <p0a> Maybe I don't know what I want
13:13:14 <p0a> I'll just try a couple things first and report back
13:13:20 <Cale> I've also got some mileage from writing general graph functions that just have a lot of function arguments to take things like a function to compute the distance between a pair of adjacent vertices, or the neighbourhood of a vertex
13:14:44 <p0a> Cale: my vertices are not integers, but tuples
13:14:53 <Cale> That should generally not be a problem
13:15:02 <p0a> right
13:15:26 <p0a> I'm a little worried about efficiency; C++ was good enough but it took ~5 seconds
13:15:45 <p0a> and I'd like to eventually get it to do more things, so a minute or two may be likely
13:16:03 <p0a> but I'll start simple
13:16:36 <Cale> There might be some advantage to be had in moving vertex labels into another structure so you can use IntMap or some sort of array or Vector rather than Map
13:17:19 <Cale> But hopefully if you abstract over the operations for inspecting graphs you end up needing, you'll have not much trouble switching representations
13:17:22 <dsal> Data.Graph does very little, but some of those things are useful.  There are some fancier packages.
13:17:43 <p0a> Cale: how do I accomplish such abstraction?
13:17:57 <p0a> Do I provide a Graph instance with some implementation, etc?
13:18:13 <p0a> I'm a noob, but I'm thinking of how Num, Ord etc work
13:18:52 <Cale> Like, if you're writing some sort of search algorithm, you just take the things you need as arguments -- just wish them into existence, and then work out how to provide them for the concrete graph type you end up using
13:19:28 <p0a> I see
13:24:00 <p0a> berndl: with regards to algebraic-graphs
13:24:28 <p0a> berndl: what does it mean "[..] safe, flexible and elegant foundation for working with graphs that have no edge labels."
13:24:34 <p0a> Edge labelS?
13:24:46 <p0a> Do you know?
13:25:42 <berndl> I suppose it means you cannot use it to produce graphs with weighted edges, for example.
13:26:14 <p0a> right, got it
13:26:31 <p0a> that's reflected by the Graph data type, I didn't understand it though
13:26:53 <p0a> it's pretty crazy that this guy made a paper out of this
13:27:00 <p0a> quite a simple idea
13:27:04 <p0a> but nice
13:28:09 <berndl> It's nice if you want to express thinigs like circuits as graphs.
13:28:22 <berndl> *things
13:30:30 <alp> it does have a module for labelled graphs
13:30:32 <alp> that came after
13:31:33 <alp> here's how it came about: https://github.com/snowleopard/alga/issues/17
13:33:05 <p0a> I think I won't actually need edge labels 
13:33:21 <p0a> all the info I need is the edge itself
13:35:00 <p0a> but it seems to me that alga allows for many different representations of the same graph 
13:35:07 <p0a> i.e. the constructors can be used in various orders
13:35:19 <p0a> Idk though, I'll have to keep reading
13:35:43 <alp> right, the laws tell you what is equivalent
13:36:08 <p0a> but how do I know which representation is efficient?
13:36:19 <alp> it depends on the problem at hand, essentially
13:36:39 <p0a> say I have a file with edges 1 -- 2, 3 -- 4, etc
13:36:53 <p0a> oh I see, maybe I'll have to sort the edges lexicographically
13:37:04 <p0a> and do some other tricks. basically figure out a short representation
13:39:11 <tobiasBora> koz_: disconsis : Now I understand much better, it works great, thanks!
13:39:35 <disconsis> :)
13:46:55 <p0a> in `class Graph g where ... type Vertex g' is Vertex a name for g?
13:47:20 <p0a> I don't understand the line `type Vertex g' above
13:49:45 * hackage propellor 5.10.2 - property-based host configuration management in haskell  https://hackage.haskell.org/package/propellor-5.10.2 (JoeyHess)
14:02:54 <berndl> p0a: Vertex g is the type of the vertices of g
14:03:30 <berndl> So when you define an instance you can say e.g. type Vertex g = Int
14:03:51 <p0a> I see, this has to do with defining instances 
14:04:06 <p0a> but then what is `g' itself?
14:04:12 <p0a> I thought `g' represented the Int
14:04:17 <p0a> or rather, could be
14:05:09 <koz_> p0a: The type is not g.
14:05:15 <koz_> It's 'Vertex g'.
14:05:23 <p0a> in `class Graph g' what is the g?
14:05:26 <Plazma> hi friends
14:05:41 <berndl> p0a: that's the type that you're defining an instance for.
14:06:28 <p0a> I think I'll look up some examples lnline 
14:06:29 <p0a> I Don't get it 
14:07:42 <p0a> for example `class BasiqEq a where isEqual :: a -> a -> Bool'
14:07:56 <koz_> a is the instance.
14:07:59 <p0a> then `instance BasicEq Bool where ...' 
14:08:09 <berndl> p0a: https://blogs.ncl.ac.uk/andreymokhov/an-algebra-of-graphs/
14:08:10 <koz_> For example, for 'class Show a' we have 'instance Show Bool'.
14:08:20 <p0a> So the above I wrote makes sense to me. So I thought in `class Graph g' I thought g is going to be the type of vertices
14:08:25 <koz_> So basically, this defines all the methods, copy-pasting 'Bool' for 'a'.
14:08:29 <koz_> p0a: Nope.
14:08:32 <koz_> g is the type of the graph.
14:08:38 <koz_> _Vertex g' is the type of the vertices.
14:08:44 <koz_> _Vertex g_*
14:08:49 <koz_> The naming convention is a clue.
14:08:54 <p0a> so your graph can be an Int?
14:09:00 <koz_> p0a: No.
14:09:04 <koz_> Vertex g is a type
14:09:06 <koz_> THE WHOLE THING
14:09:15 <koz_> You can't just randomly pull bits out of it and say 'OMG GRAPH IS THIS'.
14:09:24 <koz_> Nobody ever said types have to be spelled with one word.
14:09:28 * p0a throws a tantrum
14:09:31 <koz_> g is a type.
14:09:38 <koz_> Vertex g is a _related_, but separate, type.
14:09:39 <p0a> Got you
14:09:49 <p0a> Well, I still don't know why that is happening, but fine
14:09:54 <koz_> Why what is happening?
14:10:23 <p0a> Why are there two related types involved in a Graph
14:10:44 <p0a> so Int is the 'label' of the vertex and Vertex Int is the type of the vertex?
14:10:44 <koz_> p0a: Because we have a type for the graph itself, and a type for its vertices.
14:11:07 <p0a> but how do I know what type to supply to that for the graph?
14:11:30 <p0a> I'm reading berndl's link as well
14:11:38 <koz_> g is the type of the graph.
14:11:41 <koz_> This can be whatever.
14:11:46 <berndl> p0a: Look at the Examples section of the link I gave you.
14:11:55 <koz_> However, if this can be whatever, how do we know ahead of time what type its vertices are?
14:12:01 <koz_> The answer is 'it depends on the implementation'.
14:12:08 <koz_> Therefore, we have _another_ type called 'Vertex g'.
14:12:13 <koz_> That is 'the type of the vertices of g'.
14:12:16 <koz_> Whatever g is.
14:12:26 <koz_> We need two types because GHC is not an implementation mind-reader.
14:14:10 <p0a> berndl: so indeed g is the type of the vertex label itself
14:14:24 <p0a> I mean, this 'core' framework relies on using isolated vertices
14:14:26 <koz_> p0a: ....
14:14:40 <koz_> g is the type of the graph. Vertex g is the type of the vertex label.
14:14:57 <p0a> we're saying the same thing I Think
14:15:27 <koz_> p0a: We are very much not saying the same thing, because under no mathematics I am aware of is 'graph' synonymous with 'vertex label'.
14:16:12 <p0a> so for example in 1 * (2 + 3) :: Relation Int, it appears that '1', '2', '3' are graphs
14:16:12 <p0a>  
14:16:19 <p0a> each of type Relation Int
14:16:28 <koz_> p0a: What's Relation?
14:16:38 <p0a> similar to class Graph
14:16:45 <koz_> p0a: Can you link me to a definition?
14:16:52 <p0a> https://blogs.ncl.ac.uk/andreymokhov/an-algebra-of-graphs/
14:16:58 <p0a> See under 'Examples'
14:17:14 <koz_> Oh, this thing.
14:17:34 <koz_> OK, this is quite insightful actually.
14:17:41 <koz_> Look at the instance of Graph for Relation a.
14:18:06 <koz_> Going via the definition of the type class, here g ~ Relation a, and Vertex g ~ a
14:18:29 <koz_> The fact that 1 2 and 3 are graphs has absolutely nothing whatsoever to do with the Graph instance here.
14:18:44 <koz_> It has to do with the Num instance for Relation a defined just below.
14:19:44 <gentauro> can anybody explain `Setup.hs` -> https://github.com/joshcough/HaskellStarter/blob/master/Setup.hs
14:20:11 <koz_> gentauro: Basically, unless you're doing something fairly unusual, consider this boilerplate.
14:20:13 <gentauro> I `mimiced` the the Haskell project setup
14:20:46 <gentauro> but when I open that file in `emacs` I see this text -> `Could not load module ‚ÄòDistribution.Simple‚ÄôIt is a member of the hidden package ‚ÄòCabal-2.4.0.1‚Äô.You can run ‚Äò:set -package Cabal‚Äô to expose it.`
14:20:58 <koz_> gentauro: Yeah, it's basically telling Cabal how you want this built.
14:21:12 <koz_> You don't have to worry about it unless there's stuff you need Cabal to know outside of the normal build process.
14:21:49 <gentauro> koz_: but do I need to depend on `cabal`? I can see that OP doesn't do that -> https://github.com/joshcough/HaskellStarter/blob/master/haskell-starter.cabal#L26-L37
14:22:28 <koz_> gentauro: No.
14:22:42 <koz_> As I said - unless you need to hook into Cabal's build process itself, treat this file as boilerplate.
14:22:57 <gentauro> koz_: cool, so I just leave it there. Roger that
14:23:02 <koz_> gentauro: Basically yes.
14:23:14 <p0a> so `Relation a' is g/
14:23:17 <p0a> is that right?
14:23:21 <koz_> p0a: Yes.
14:23:35 <p0a> I see so class Graph g is a guideline for what the instance must do
14:23:44 <p0a> giving freedom for `g' to be whatever
14:23:47 <koz_> p0a: Not 'guideline'. Iron-clad unbreakable rule.
14:23:56 <gentauro> btw, now that I use that .cabal template, I can't use `other-modules: Paths_package` anymore
14:24:01 <gentauro> is this good or bad?
14:24:11 <koz_> Basically, it describes what any instance of this type class must have defined for it.
14:24:17 <gentauro> iirc somebody told me in here that they provided some versioning or so?
14:24:41 <koz_> gentauro: Hmm. What's the sample .cabal look like?
14:25:07 <p0a> yeah sure, then type Vertex g is a new type. The instance will define it via type parameter, like type Vertex (Constr a b c) = b
14:25:16 <p0a> where Constr is a constructor, right?
14:25:25 <p0a> no wait, a type?
14:25:33 <koz_> 'Constr a b c' is a type.
14:25:41 <gentauro> koz_: almost a 1:1 (except for names and so and that I have 3 binaries instead of 1) with https://github.com/joshcough/HaskellStarter/blob/master/haskell-starter.cabal
14:25:45 <koz_> maerwald: OK, even that didn't help. This has me completely thrown.
14:25:46 <p0a> thanks koz_ 
14:25:53 <gentauro> I could use them before with my previous .cabal file
14:26:10 <gentauro> but once I mimiced this one, I cat use `Paths_package` :(
14:26:10 <koz_> maerwald: I get a lot of this: http://paste.debian.net/1144231/
14:26:25 <koz_> gentauro: https://github.com/joshcough/HaskellStarter/blob/master/haskell-starter.cabal#L12
14:26:28 <koz_> There be your problem.
14:26:32 <koz_> This is _very_ old.
14:26:40 <koz_> I go with the minimum 2.2 approach.
14:26:45 <koz_> (which I would suggest doing anyway)
14:26:54 <p0a> if Vertex is a new type
14:27:04 <p0a> why must we write type Vertex g? Why the association with g?
14:27:15 <koz_> p0a: Because, for the fifth time, _Vertex is not a type_.
14:27:18 <koz_> Vertex g is a type.
14:27:27 <p0a> Well right, but why not name it Vertex?
14:27:36 <p0a> Why is it associated with g?
14:27:39 <gentauro> koz_: `cabal-version:   2.2`
14:27:43 <gentauro> show be good
14:27:52 <gentauro> koz_: but OP doens't use them in his .cabal file
14:27:55 <koz_> Because different instances of the Graph type class will have different vertex representations.
14:27:57 <gentauro> (I was wondering about that)
14:27:59 <koz_> gentauro: So what do you have?
14:28:06 <koz_> GHC can't read your mind.
14:28:11 <p0a> Ah, nice. I get it
14:28:20 <koz_> Therefore, we have to be able to specify what exact representation of graph we are a vertex of.
14:28:29 <p0a> What is `type Vertex g' called? In the language?
14:28:35 <gentauro> koz_: my question is just: "Do I need Paths_package"?
14:28:37 <koz_> p0a: An associated type definition.
14:28:43 <p0a> thank you 
14:28:46 <koz_> gentauro: Do you need to know about the installation path of your package?
14:29:02 <gentauro> koz_: I have no clue
14:29:13 <koz_> gentauro: Do you have any logic in your code which would change due to this?
14:29:17 <gentauro> that wasn't an issue with `package.yaml`
14:29:55 <gentauro> koz_: I mean, it would be a pretty bad code if my path to code had an impact on the library :|
14:30:07 <gentauro> does `cabal` hardcore this? (pwd)?
14:30:48 <koz_> gentauro: If you supply Paths_package, you get another module which has this information in it.
14:30:51 <koz_> Sometimes this matters.
14:30:59 <koz_> Case in point: the --inplace upgrade option of ghcup-hs.
14:31:18 <koz_> So basically, if your installation path isn't relevant to your code's interests, you don't need it.
14:32:34 <gentauro> koz_: OK, I don't think I need this then
14:32:36 <gentauro> koz_: thx
14:32:39 <koz_> gentauro: No worries.
14:33:03 <koz_> I have seen this used in a project I was involved in precisely once ever, for what it's worth, which is the _only_ reason I know about it.
14:38:44 <p0a> I tried to play around with classes and wrote this, https://pastebin.com/gjmuZpzU
14:38:52 <p0a> I can't get it to work, I'll post the error
14:39:27 <koz_> Your problem is 'type Box Cat = Maybe Cat'.
14:39:37 <koz_> Because you have class CatInBox a
14:39:41 <koz_> and type Box a
14:39:41 <p0a> https://pastebin.com/P1YM9N3K
14:39:48 <koz_> So by stating 'instance CatInBox Cat'
14:39:51 <koz_> You are saying a ~ Cat
14:40:05 <koz_> But then you're saying 'type Box Cat = Maybe Cat
14:40:07 <koz_> '
14:40:13 <koz_> Can you see the problem yet?
14:40:28 * p0a thinks
14:40:58 <koz_> What you _probably_ wanted was a type class for Boxes.
14:41:05 <koz_> And then an associated type Contents.
14:41:30 <koz_> If you wanna read up on associated types, read about type families.
14:41:40 <p0a> okay
14:42:15 * hackage haskoin-store 0.23.15 - Storage and index for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-store-0.23.15 (jprupp)
14:44:45 * hackage git-annex 8.20200501 - manage files with git, without checking their contents into git  https://hackage.haskell.org/package/git-annex-8.20200501 (JoeyHess)
14:49:40 <p0a> Question: What's ! in this: data instance XList Char = XCons !Char !(XList Char) | XNil
14:49:54 <dsal> p0a: it means the values are strict.
14:50:04 <EvanR> strict field
14:50:46 <EvanR> if XCons x y is constructed, then x and y are evaluated
14:51:11 <p0a> in the case of strict?
14:51:25 <EvanR> because both fields are defined with the !
14:51:59 <p0a> it's an optimization technique?
14:52:13 <EvanR> no, it could be a performance mistake
14:52:27 <p0a> well I'll steer away from it for now
14:52:28 <EvanR> it depends
14:52:33 <koz_> It very much depends.
14:52:46 <p0a> I probably don't need it
14:54:13 <koz_> p0a: Probably not, no.
14:55:32 <EvanR> one case where you often use it is when the field is a simple number. The number takes up more space unevaluated, sometimes a lot more. If you know you will use it soon, better to evaluate it at construction time.
14:56:15 <koz_> Related to this: {-# UNPACK #-}
14:56:59 <EvanR> if the field is another large data structure, like the rest of a list, it often makes more sense to wait. Which is the default
15:00:12 <p0a> : Data.IntMap.IntMap
15:00:17 <p0a> :t Data.IntMap.IntMap
15:00:18 <lambdabot> error:
15:00:18 <lambdabot>     Not in scope: data constructor ‚ÄòData.IntMap.IntMap‚Äô
15:00:18 <lambdabot>     Perhaps you meant one of these:
15:00:32 <p0a> sorry shgoudl've PM'ed it, I forgot
15:00:35 <EvanR> * -> *
15:01:37 <p0a> okay that makes sense, thanks 
15:06:06 <p0a> here, https://wiki.haskell.org/GHC/Type_families#An_Int_instance
15:06:10 <p0a> where was GMapInt defined?
15:06:21 <p0a> is it implicitly defined in the above snippet?
15:07:30 <p0a> guess I'll try to run the code
15:09:32 <p0a> How can I add Data.IntMap to my project in stack?
15:09:46 <koz_> p0a: Put 'containers' in your cabal file.
15:09:51 <koz_> Preferably with some version bounds.
15:10:11 <p0a> just add -containers
15:10:46 <koz_> p0a: There's a field in your library (or executable, same diff) stanza in your cabal file.
15:10:49 <koz_> It's called 'build-depends'.
15:10:59 <koz_> In there, you want to add 'containers' to the comma-separated list.
15:11:05 <p0a> I added it to package.yaml and it worked
15:11:23 <koz_> p0a: Ah, you're using package.yaml.
15:11:27 <koz_> Yeah, then there.
15:11:32 <p0a> right
15:11:40 <koz_> I love to pretend hpack doesn't exist.
15:11:46 <p0a> so the code of the snippet works, I am still curious how GMapInt was defined
15:12:00 <p0a> it seems the constructor is created right at the instance definition right?
15:12:04 <koz_> Does it not tell you how?
15:12:30 <p0a> in empty = GMapInt ... it appears that GMapInt is a constructor right?
15:12:42 <koz_> Can you link me to the whole context please?
15:12:51 <p0a> sure, https://wiki.haskell.org/GHC/Type_families#An_Int_instance
15:12:58 <c_wraith> p0a: in a data family, the instances *are* data definitions
15:13:16 <EvanR> i did not really understand type families by reading those examples, I hope you have better luck
15:13:17 <koz_> Ah, this is a data fam.
15:13:18 <solonarv> p0a: indeed, the 'data GMap Int v = ...' line defines the GMapInt constructor
15:13:40 <koz_> EvanR: I agree, it's _definitely_ not easy reading.
15:14:11 <p0a> I mean I'm getting a vague idea right now
15:14:17 <EvanR> pretending i was Mr Spock did not even help
15:14:26 <p0a> that the type families allow us to have different representations for the underlying thing depending on the type parameter
15:14:43 <EvanR> that's data families
15:14:56 <p0a> right
15:15:23 <p0a> oh
15:15:27 <p0a> I thought I was reading about type families
15:15:32 <p0a> I was told to read about type families at least :P 
15:15:38 <EvanR> data being the word to define new data structures with a new type, type being the confusing word for alias for already existing type, and no new actual type
15:15:56 <EvanR> so two wildly different kind of families
15:16:02 <p0a> well crap I was actually not reading the thing I was supposed to be reading 
15:16:13 <p0a> looked so similar but I just noticed the word 'data' instead of 'type'
15:16:52 <p0a> No wait that page is about type families. I'll just keep reading 
15:16:57 <EvanR> it has both
15:22:03 <p0a> so if a data family
15:22:11 <p0a> appears inside a type class, it is an associated type?
15:22:22 <EvanR> it's an associated data family
15:22:32 <p0a> okay, they ommitted the word data
15:22:56 <EvanR> if you put a type family in a class it's an associated type family
15:23:03 <p0a> actually "Data families appear in two flavours: (1) they can be defined on the toplevel or (2) they can appear inside type classes (in which case they are known as associated types)."
15:23:12 <p0a> I'm curious about (2), says 'associated types' at the end
15:23:29 <solonarv> both terms are used, "associated type family" is clearer IMO
15:23:41 <EvanR> yeah both can be in both places
15:23:57 <p0a> okay so in class Graph g where ... type Vertex g
15:24:09 <p0a> `type Vertex g' has to do with an associated type family right? it is a data family
15:24:14 <remexre> is there a monad or other trick for being able to write direct-style code w/ async requests+responses?
15:25:03 <remexre> e.g. to do some operation, I make an request to a service, it gives me back some ID number for that operation; later, it notifies me that an operation with ID number <x> had result <y>
15:25:50 <EvanR> p0a: type Vertex g... this is a type family, as in type synonym or alias
15:26:21 <p0a> EvanR: associated right?
15:26:30 <p0a> so by (2) a data family inside a type class?
15:26:34 <EvanR> it's going to act like a type function. It's in a class so "associated"
15:26:53 <p0a> I read (2) as "data families inside type classes are associated type families"
15:27:07 <p0a> NEverind
15:27:11 <p0a> I'll just keep reading
15:27:18 <EvanR> that phrase is probably thinking "well the whole feature is filed under TypeFamilies extension"
15:27:32 <EvanR> so everything is a type family, but that's just confusing
15:27:46 <monochrom> p0a: There are 4 combinations: { type family, data family } x { associated with a class, not associated }.
15:28:05 <p0a> okay, thank you
15:28:19 <monochrom> Orthogonally we can examine each axis.
15:28:44 <p0a> I am interested in associated type families
15:29:08 <monochrom> On the type-vs-data axis: type family is akin to type synonyms, data family is nominal typing.
15:29:09 <p0a> https://wiki.haskell.org/GHC/Type_families#An_associated_type_synonym_example
15:29:12 <p0a> ^ I think this is it right?
15:30:08 <monochrom> On the associatedness axis: You know what, the associated ones act like nice syntax sugar, the compiler will tear it out anyway.
15:30:21 <EvanR> https://wiki.haskell.org/GHC/Type_families#Detailed_definition_of_type_synonym_families discussion of type famlies not data families begins like 2/3 of the way down the page
15:31:01 <p0a> EvanR under 'associated type instances'? 
15:31:12 <EvanR> if you feel like indiana jones after diciphering these docs, good. But if you don't I think there's a need to reformat it
15:31:26 <solonarv> remexre: sure, you could do that with the 'async' library for example
15:31:47 <solonarv> which leans on GHC's green threads
15:32:05 <EvanR> under where i linked to
15:32:42 <p0a> EvanR: I'm there, I Don't know what you mean by 2/3, what's the first two words of the first sentence?
15:32:49 <dsal> remexre: If you write the code you wish to run, chances are it can be written with a bit of modification.
15:33:05 <EvanR> "Type families appear in two flavours: (1) they can be defined on the toplevel or (2) they can appear..."
15:33:07 <dsal> Though I tend to use Conc or mapConcurrently or race or whatever.
15:33:36 <p0a> EvanR: LOL They used the exact same wording
15:33:49 <remexre> solonarv: for that, would I want to do something like Go's "channel of channels" pattern, and have the thread listening for responses "wake up" the threads waiting for a response?
15:33:50 <p0a> EvanR: and just changed 'Data' to 'Type'! I thought I was reading the same thing from before
15:34:04 <EvanR> exactly
15:34:22 <p0a> lol dude
15:34:25 <p0a> that's some good stuff
15:34:33 <solonarv> remexre: example pseudocode: do { fooTid <- async do { ticket <- sendFooRequest; waitForAnswer ticket }; barTid <- async do { ticked <- sendBarRequest; waitForAnswer ticket }; foo <- wait fooTid; bar <- wait barTid; doStuff foo bar }
15:34:36 <p0a> reminds me of when I read math papers and they use four different font variations of the letter 'a'
15:34:37 <solonarv> oof, that's a bit long
15:35:06 <solonarv> depending on exactly how the you get the answers that would work too
15:35:38 <remexre> solonarv: yeah, it's one thread that gets all the answers (or rather, I get all of them in an unknown order off a websocket, so it seemed simplest to have a "dispatcher" thread)
15:35:46 <EvanR> hey with four fonts and 6 colors and just letter A... that's pretty much a full ALPHAbet
15:35:58 <solonarv> remexre: yup, seems like a sensible approach to me
15:36:10 <remexre> solonarv: okay cool, thanks
15:36:23 <solonarv> let me see if I can put together a useful gist
15:39:52 <p0a> in `type family F a b :: * -> *' why is its kind * -> * -> * -> * ? there's four stars
15:39:56 <p0a> I thought maybe three would do it
15:40:52 <p0a> oh I see it now
15:41:00 <p0a> a and b are two stars, and then also I have :: * -> *
15:41:18 <dsal> ... it's full of stars
15:42:24 <dsal> remexre: I'm interested in seeing what solonarv comes up with, but I'm guessing it involves Concurrently.
15:42:38 <EvanR> i know we changed * to Type but man capital script U would be nicer, universe as opposed to 'just a single star'
15:44:21 <monochrom> "My God, Type is full of stars!"
15:44:48 <monochrom> But consider "star in star"
15:44:50 <MarcelineVQ> T would be fine but people be like, is that ‚ä§
15:45:31 <dsal> üçµ
15:45:31 <EvanR> .oO( scott manley stars inside other stars https://www.youtube.com/watch?v=EU-HBPfbMKI )
15:49:01 <monochrom> ùì§
15:49:48 <p0a> apply a Functor to it to get the deuce
15:49:49 <EvanR> though star in star amounts to a star being inside itself. Much more trippy
15:53:30 <solonarv> remexre: https://gist.github.com/Solonarv/637bbf198783e4ce0ac8a87d81717032
15:53:49 <solonarv> dsal: see above
15:53:58 <solonarv> actually does not involve Concurrently, but it could!
15:54:51 <remexre> solonarv: doesn't this have a bit of a thundering herd problem?
15:55:23 <solonarv> you mean that we might hammer the server with too many requests at once?
15:55:48 <remexre> no, that every time a request is received, a large number of threads are woken up
15:55:55 <remexre> er, response* is received
15:56:48 <solonarv> ah, perhaps. but for this sort of thing I'm inclined to wave my hands and assert that this is not a big deal.
15:57:25 <solonarv> you could also make a smarter dispatcher where one can register interest in responses
15:57:41 <dsal> @hackage net-mqtt-rpc
15:57:41 <lambdabot> http://hackage.haskell.org/package/net-mqtt-rpc
15:57:44 <dsal> That's basically what this does ^
15:58:06 <dsal> A given RPC request registers itself for particular responses and deregisters when it's done.
15:59:39 <p0a> What's wrong with this https://pastebin.com/XvGnaNeh
15:59:50 <p0a> I tried to use type families above but to no avail
16:01:53 <remexre> p0a: what's the type of makeThing in e.g. main = print makeThing
16:02:26 <p0a> makeThing is a :: Thing a so :: a here?
16:02:33 <p0a> From MyBox a
16:02:47 <p0a> I wanted to use it with MyBox Int to put a number inside a container 
16:04:36 <remexre> I guess it would be more accurate to say, "without knowing a, whether makeThing has type Thing a can't be determined"
16:05:09 <remexre> e.g. is ("foo" :: Thing a) true
16:05:31 <p0a> but Thing is defined by
16:05:37 <p0a> type Thing (MyBox a) = a
16:05:54 <remexre> er, in this case calling the arg to MyBox "a" is somewhat confusing
16:06:04 <p0a> Why?
16:06:09 <remexre> so pretend you wrote instance Box (MyBox b) where ..., etc
16:06:16 <p0a> okay but would that solve it?
16:06:24 <remexre> then a from Box a is MyBox b
16:07:14 <p0a> I just want a thing 
16:07:18 <p0a> that I can put another thing in
16:07:21 <p0a> like a box where I can put a thing in it
16:07:25 <remexre> what's the purpose of makeThing
16:07:26 <p0a> and I want the thing to be whatever type
16:07:33 <p0a> makeThing makes something you can put inside a box
16:07:48 <p0a> ah you're saying makeThing can't arbitrarily make a value of type 'a'
16:08:16 <remexre> well, no (ya that's true in general,but that's not what the error you're getting is telling you)
16:08:47 <remexre> For what you seem to be defining, I don't think you want makeThing at all
16:08:48 <p0a> if I specialize Bounded a, then I can do makeThing = minBound
16:09:15 <p0a> you might be right
16:09:21 <remexre> uh, as in if class Bounded a => Box a? or class Bounded (Thing a) => Box a? or instance Bounded a => Box (MyBox a)
16:10:00 <p0a> instance Bounded a => Box (MyBox a) where ... 
16:10:07 <remexre> the latter two yes, but the error is fundamentally not about whether it's possible to define the value in your instances (after all, you could just use undefined)
16:10:17 <p0a> okay what's the error then 
16:10:51 <remexre> The error's basically saying, "it's going to be quite difficult to determine the type of makeThing when you use it, enough so that this is an error"
16:12:19 <p0a> so you're saying the issue is that I can't have something with type :: Thing a
16:12:33 <remexre> not without it being able to be known what a is
16:12:49 <p0a> so in takeFromBox :: a -> Thing a
16:12:51 <remexre> e.g. if you have something of type (a -> Thing a), or (MyBox a -> Thing a), that's fine
16:12:52 <p0a> why is  that fine?
16:13:14 <remexre> let's say I'm checking the term (takeFromBox x)
16:13:21 <pgiarrusso> Is the problem that Thing is not injective?
16:13:22 <remexre> I first can check, "what's the type of x"
16:13:24 <remexre> ya
16:13:37 <EvanR> in general it's possible to have something :: F a... for example Nothing :: Maybe a
16:13:49 <remexre> and if I find out "it's MyBox Int," I know (takeFromBox x) has type Thing (MyBox Int)
16:13:50 <EvanR> [] :: [a]
16:14:10 <remexre> which I can then reduce using the type family declaration in your instance, to get (takeFromBox x :: Int)
16:14:10 <pgiarrusso> EvanR: all of those constructors are injective.
16:14:34 <p0a> why is mine not injective?
16:14:46 <remexre> MyBox is, since it's a constructor
16:14:48 <EvanR> oh we are still on type families
16:14:51 <remexre> open type families aren't
16:15:03 <p0a> I see, it's an issue with it being open
16:15:04 <pgiarrusso> It‚Äôs not declared to be injective; it could be made so.
16:15:17 <p0a> how?
16:15:32 <p0a> This might be treading a little too far from what I'm supposed to be learning but ... worth a shot
16:15:48 <pgiarrusso> p0a: there‚Äôs a syntax for it, and them it‚Äôs still open but injectivity is checked.
16:15:56 <p0a> I see 
16:15:57 <remexre> pgiarrusso: oh, huh, TIL
16:16:28 <pgiarrusso> Looking it up a second
16:17:21 <EvanR> p0a's rabbit hole level increased
16:17:21 <pgiarrusso> IIRC it‚Äôs `type Thing a = r | r ‚Üí a`
16:17:35 <solonarv> remexre: here's a version with a "dispatcher" thread that wakes up only the waiting threads: https://gist.github.com/Solonarv/82079ceab7b695826fe6a3cd16d79e71
16:17:47 <pgiarrusso> Plus the extensions that GHC asks.
16:18:13 <remexre> solonarv: ah, thanks!
16:18:30 <pgiarrusso> I forget if GHC is going to accept the definition in the instance...
16:19:02 <remexre> pgiarrusso: wait, this breaks separate linking, right?
16:19:02 <solonarv> remexre: disclaimer: I wrote that directly in the gist.github.com editor, so I can't guarantee it works :p
16:19:03 <pgiarrusso> Checking for injectivity on open type functions requires non-obvious restrictions, but I forget which.
16:20:04 <pgiarrusso> remexre: no, I think injectivity is enforced locally, but yes that‚Äôs not obvious
16:20:06 <solonarv> remexre: the main trick is that you make a (T)MVar, toss it over to the dispatcher, and then block on that (T)MVar
16:20:21 <p0a> now that I sort of get type families and all that
16:20:22 <p0a> It's really cool
16:20:25 <remexre> solonarv: okay, yeah, makes sense
16:20:41 <p0a> that you can create a closed universe inside a type class and program in it
16:20:52 <p0a> and let the interested parties provide the implementation
16:22:27 <EvanR> interface vs implementation, a great way to get out of doing the dirty work!
16:29:45 * hackage list-predicate 0.1.0.0 - Predicates on lists  https://hackage.haskell.org/package/list-predicate-0.1.0.0 (pgujjula)
16:29:57 <p0a> okay I'm getting close to actually doing something
16:48:09 <koz_> What does this function: http://hackage.haskell.org/package/waargonaut-0.8.0.1/docs/Waargonaut-Decode-Runners.html#v:decodeWithInput represent with the 'i' type variable?
16:50:23 <Clint> input type?
16:50:52 <koz_> Clint: Go figure, lol.
16:51:27 <koz_> Am I missing something in this library, but is there no function that reads and parses straight from a Handle or something? Like, do yu have to first drag in a ByteString or whatever, and _then_ parse that?
16:54:58 <dibblego> mankyKitty: ^^
17:26:45 * hackage zeolite-lang 0.1.3.0 - Zeolite is a statically-typed, general-purpose programming language.  https://hackage.haskell.org/package/zeolite-lang-0.1.3.0 (ta0kira)
18:39:15 * hackage kleene-list 0.1.0.0 - A list type based on the Kleene star and plus.  https://hackage.haskell.org/package/kleene-list-0.1.0.0 (oisdk)
19:13:45 * hackage calamity 0.1.4.2 - A library for writing discord bots  https://hackage.haskell.org/package/calamity-0.1.4.2 (nitros12)
19:29:56 <dsal> :t foldByOf
19:29:57 <lambdabot> Fold s a -> (a -> a -> a) -> a -> s -> a
19:30:02 <dsal> I'm offended by the name of this function.
19:30:35 <MarcelineVQ> Me too, two o's in one identifier, what a joke
19:31:41 <dsal> > sort "foldByOf"
19:31:43 <lambdabot>  "BOdffloy"
19:31:58 <dsal> Guess I should fold the case first.
19:32:08 * MarcelineVQ le shock face
19:33:53 <dsal> I think I should alphabetize all my function names.
19:37:37 <dmwit> adls: deefiilnty
19:42:24 <chmmnooor> wow my name has 3 o's!
19:42:32 <dmwit> ^_^
19:42:59 <dmwit> Aha. Now we know that all smileys are backwards.
19:43:03 <dmwit> > sort "=("
19:43:05 <lambdabot>  "(="
19:59:45 <renzhi_> what's everyone's favorite auto indent for Haskell coding in Emacs?
20:06:06 <toni37> hello
20:06:18 <toni37> i have this type 
20:06:19 <toni37> data Cell =
20:06:19 <toni37>       EmptySpace   Position
20:06:19 <toni37>     | EmptyCell    Position
20:06:19 <toni37>     | StartCell    Position Directions
20:06:19 <toni37>     | EndCell      Position Directions
20:06:22 <toni37>     | CorridorCell Position Directions
20:07:01 <toni37> nvm
20:10:07 <dsal> paayste
20:12:23 <toni37> i figure it out
20:34:43 <win2ero> Hello good nitgh to all
20:35:42 <win2ero> I am starting with Haskell and i am currently reading about typeclass
20:35:52 <win2ero> But i dont really understand well
20:36:16 <c_wraith> How so?
20:36:20 <win2ero> Eq Ord Int Integer fromINtegral
20:36:26 <win2ero> are a littkle confising to me
20:36:37 <c_wraith> only two of those are type classes
20:37:06 <win2ero> I am relationing the concept with interface in java
20:37:18 <c_wraith> It's not a great analogy, despite how many things claim it.
20:37:26 <monochrom> That is the cause of confusion.
20:37:26 <win2ero> is this aproach corret?
20:38:27 <win2ero> Witch one are typeclass that i metioned
20:38:35 <monochrom> If you start with a clean-slate mind and not make any premature "connection", it's very clear and simple.
20:38:38 <c_wraith> Eq and Ord are classes.
20:38:46 <c_wraith> Int and Integer are types
20:39:17 <c_wraith> fromIntegral is a function that happens to use operations from two different classes in its implementation.
20:40:18 <win2ero> when you say classes are you refering to java class or interface
20:40:26 <c_wraith> I'm referring to haskell
20:40:42 <c_wraith> @src Eq
20:40:42 <lambdabot> class Eq a where
20:40:42 <lambdabot>     (==), (/=) :: a -> a -> Bool
20:40:44 <win2ero> clasess and typeclases are the same or diferent?
20:40:52 <c_wraith> They're the same thing.
20:40:58 <win2ero> ok
20:41:02 <c_wraith> You can see that a type class is defined with the keyword "class"
20:43:34 <c_wraith> type classes are best understood in the context of Haskell without analogy to other languages.  Unless you happen to know rust, as rust traits are basically directly copied from haskell classes.
20:44:20 <koz_> c_wraith: I did not know that.
20:44:48 <win2ero> so Ord is another class and it say that have to have a relation with Eq
20:45:05 <win2ero> Like a herarchy?
20:45:10 <c_wraith> the only significant difference in rust is the existence of "trait objects", which are syntactic sugar for the existential typeclass antipattern.
20:45:36 <c_wraith> win2ero: yes.  A type can only be an instance of Ord if it is also an instance of Eq
20:46:34 <win2ero> could you givme 2 example one in witch are and one in where isn't
20:47:42 <koz_> IORefs can be Eq (are they the same ref), but not Ord (what kind of ordering on addresses makes any sense?)
20:48:11 <win2ero> ok
20:48:24 <c_wraith> Complex numbers are another example
20:48:31 <c_wraith> Equality makes sense, but ordering does not
20:48:41 <win2ero> i got it
20:49:44 <win2ero> Ok thanks for helping me I understand a little more
20:54:28 <c_wraith> There are definitely parts of the type class system that are tricky, especially when mixed with other language features.  Don't worry if it isn't all immediately obvious.
20:58:05 <win2ero> it's there like some exercise to help clarifi thgis
20:58:07 <win2ero> this
20:58:48 <win2ero> i am getiing the concept but i am not aplying
21:02:15 * hackage generic-data-surgery 0.2.1.0 - Surgery for generic data types  https://hackage.haskell.org/package/generic-data-surgery-0.2.1.0 (lyxia)
21:02:46 <c_wraith> https://www.cis.upenn.edu/~cis194/spring13/lectures.html is very highly regarded.  I haven't gone through it myself, but maybe some of the stuff there would be helpful
21:08:05 <MarcelineVQ> it's showing its age a bit, missing a certain deriving Applicative in provided materials in particular iirc
21:08:42 <c_wraith> Oh, it predates AMP.  Ok.
21:12:19 <Disavowed> Hi. Does anyone have any recommendations for a good Haskell language server for use with CoC in Neovim?
21:22:22 <d34df00d> I guess hie is the only option at the moment.
21:22:46 <d34df00d> Although I'm not sure I can call something eventually eating 10 gigs of ram on a <1kloc project "good".
21:23:36 <dsal> Might be OK for me.  My Linux machine doesn't have that much RAM.
21:27:53 <Disavowed> d34df00d: Might throw it in a cgroup to show it who's boss! Thanks for this. Excited for this new venture into memory leaks
21:28:04 <Disavowed> dsal: Perfect attitude I think
21:45:12 <d34df00d> Well, it kinda stops at 10 gigs or so.
21:45:33 <d34df00d> So I'm not sure if it's a leak or it's just trying to cache whatever info it needs to cache about my project's deps.
21:48:59 <MarcelineVQ> I think it's a ghc leak related to reloading modules, other tools I've used over trime suffer from it as well
22:03:56 <vivekramaswamy> Hello all I have written a small program, that only capitalises the first letter of a String and returns it, I a unable to understand the error I am getting. Can someone tell me what really this error is. Thanks in advance the code is here . https://pastebin.com/7kuRheDB
22:05:43 <dsal> vivekramaswamy: Your style is a bit weird, but what is the error you got?
22:06:47 <dsal> It might be a little obscure.  But hopefully it's at least readable.
22:06:56 <vivekramaswamy> I was trying to write a point free function. I get this error Equations for ‚Äòmy_capitalize_head‚Äô have different numbers of arguments 
22:07:20 <dsal> Yes, each definition has to have the same number of parameters.
22:07:36 <dsal> IMO, that's kind of dumb, but I don't work on the compiler, so there's probably a good reason somewhere.
22:07:43 <vivekramaswamy> but when I change the to composition style the error goes away, my_capitalize_head str  = toUpper.head $ str
22:08:02 <dsal> Yes, because all the definitions have the same number of parameters.
22:09:16 <dsal> Your main problem is that head is a partial function and you are trying to create a total function that creates a new value when it encounters an empty string.
22:09:42 <vivekramaswamy> the question I am working on is asking for a pointfree implementation for this function. for making it work with pointfree I will have to let go of the line my_capitalize_head [] = ' ' . if that is done an empty string gives an error.
22:10:06 <dsal> Yes, that was the first thing we discussed.  :)
22:10:13 <dsal> BTW, "" looks better as an empty string.
22:10:15 <dsal> But try this:
22:10:19 <dsal> :t listToMaybe
22:10:21 <lambdabot> [a] -> Maybe a
22:10:30 <dsal> That's a total variant of `head`
22:11:34 <vivekramaswamy> ok, let me try that, thanks for your inputs
22:12:38 <dsal> It'd be better/more generally useful to define your function as `capHead :: String -> Maybe Char`  -- but you could do the same thing you're doing here pretty easily.
22:16:28 <vivekramaswamy> Just did that https://pastebin.com/GdKg5DY2 but still get the error
22:17:12 <dsal> What error?
22:17:53 <dsal> (also note that you don't need `head` here at all, though `listToMaybe` will get you that point-free action)
22:18:23 <vivekramaswamy>  I am also confused about the convention, Just.toUpper.head $ str does not work Just(toUpper.head $) works without an error
22:19:01 <vivekramaswamy> Not in scope: ‚ÄòJust.toUpper‚Äô
22:19:01 <vivekramaswamy> No module named ‚ÄòJust‚Äô is imported.
22:19:18 <dsal> Right.  Your lack of spaces is causing problems.  :)
22:19:43 <dsal> Smashing everything together makes it hard for everyone, including the compiler, to understand you.  :)
22:20:53 <vivekramaswamy> Oh got it, thanks for that, it works now, thanks a ton, I did not know you could add spaces in point free notation
22:21:09 <dsal> spaces and point free don't have anything to do with each other.
22:21:20 <dsal> But you can have spaces in operators.  . is just an operator like +
22:21:22 <dsal> :t (.)
22:21:24 <lambdabot> (b -> c) -> (a -> b) -> a -> c
22:21:25 <dsal> :t (+)
22:21:26 <lambdabot> Num a => a -> a -> a
22:21:43 <vivekramaswamy> then why do I need a space here Just .toUpper.head $ str
22:22:22 <dsal> Well, for readability sake, we generally put spaces between operators, but in this case, `Just.` looks like you're accessing a symbol out of a module named `Just`
22:22:49 <dsal> Because module imports are capitalized like constructors, but module dereferences will have a `.` after them and constructors won't.
22:23:01 <dsal> If you consistently space things, it'll never be confusing.
22:23:38 <vivekramaswamy> Thanks, thats a new thing i learned today.
22:23:57 <dsal> Now try for the point free variant.  :)  It's quite easy.
22:24:24 <dsal> Well, assuming you understand functors, anyway.
22:24:31 <vivekramaswamy> yes, this works Just .toUpper .head
22:24:56 <dsal> That crashes on "" though.
22:25:35 <dsal> :t Just . toUpper . head
22:25:36 <lambdabot> [Char] -> Maybe Char
22:25:44 * hackage plzwrk 0.0.0.1 - A front-end framework  https://hackage.haskell.org/package/plzwrk-0.0.0.1 (mikesol)
22:25:49 <dsal> :t fmap toUpper . listToMaybe
22:25:50 <lambdabot> [Char] -> Maybe Char
22:26:40 <vivekramaswamy> I have not covered functors as yet, it's 2 chapters away
22:27:03 <koz_> :t uncons
22:27:05 <lambdabot> [a] -> Maybe (a, [a])
22:27:29 <koz_> :t ((toUpper . fst) <$>) . uncons
22:27:30 <lambdabot> [Char] -> Maybe Char
22:27:45 <dsal> Ha.  nice
22:28:10 <dsal> listToMaybe is a weird name for headButNotPartial
22:28:21 <koz_> safeHead.
23:09:09 <remexre> is there a way without DataKinds to have a kind with exactly two inhabitants
23:09:49 <koz_> remexre: Why the restriction?
23:10:03 <c_wraith> No.  Without DataKinds you really only have Type and (->) available as building blocks
23:10:22 <mniip> you have quantified kinds thourgh polykinds though?
23:10:32 <mniip> (forall k, k -> k -> k) ?
23:10:38 <remexre> koz_: porting from code in slides that I /think/ is pseudoagda
23:11:18 <mniip> hmm I wonder
23:11:30 <mniip> % newtype Fst a b = Fst a
23:11:31 <yahb> mniip: 
23:11:34 <mniip> % :k Fst
23:11:35 <yahb> mniip: * -> k -> *
23:13:36 <mniip> seems like only TYPE _ is allowed
