00:00:43 <xerox_> @src (.)
00:00:43 <lambdabot> (f . g) x = f (g x)
00:00:49 <xerox_> aka function composition
00:01:30 <sshine> (1:) = \x -> 1:x
00:03:47 <sshine> > fix (\xs -> scanl (+) 0 (1:xs))
00:03:48 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
00:10:10 <liiae> sshine: why fixed-point is related to fibonacci?
00:11:12 <Cale> liiae: The fixed point that fix gives you can be used to define anything recursive
00:11:37 <Cale> fix (\x -> ... x ...) is the same as  let x = ... x ... in x
00:12:04 <Cale> > fix (\fac n -> if n == 0 then 1 else n * fac (n-1)) 10
00:12:06 <lambdabot>  3628800
00:12:12 <Cale> > product [1..10]
00:12:15 <lambdabot>  3628800
00:12:35 <Cale> > fix (\ones -> 1 : ones)
00:12:37 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
00:12:46 <Cale> > let ones = 1 : ones in ones
00:12:47 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
00:13:05 <Cale> fix f = let x = f x in x
00:13:50 <liiae> Cale: https://www.quora.com/Why-doesnt-Haskell-implement-infinite-types
00:14:28 <liiae> Cale: we can turn that infinite type to fixed-point stuff?
00:16:01 <awpr> you can write a type family that acts sort-of like `fix`, but it will just ruin GHC's day; or, you can write a newtype that acts slightly less like `fix` and get recursively-defined but not infinite types
00:16:04 <Cale> Which infinite type?
00:16:43 <Cale> But yeah, if you run into a case where you'd otherwise want an infinite type, you can generally turn it into a recursively defined type
00:16:54 <awpr> `newtype Fix f = Fix (f (Fix f))` is the common definition, and it gives you (modulo newtype constructors) `f (f (f (f (f (f ...)))))))`
00:56:43 <koz_> Oh, neat.
00:56:55 <koz_> I keep forgetting about how Applicative like, composes with everything.
00:56:58 <koz_> Thanks sshine !
01:42:45 * hackage hlint 3.1.3 - Source code suggestions  https://hackage.haskell.org/package/hlint-3.1.3 (NeilMitchell)
01:53:45 * hackage kubernetes-webhook-haskell 0.2.0.2 - Create Kubernetes Admission Webhooks in Haskell  https://hackage.haskell.org/package/kubernetes-webhook-haskell-0.2.0.2 (amarrella)
02:52:58 <buggymcbugfix> I want to `find` in Haskell. Is there an alternative to `file-manip`?
02:53:19 <buggymcbugfix> ... that does not involve me making everything from scratch.
02:53:41 <jackdk> !hackage directory-tree
02:53:42 <jackdk> ?
02:53:49 <jackdk> @hackage directory-tree
02:53:50 <lambdabot> http://hackage.haskell.org/package/directory-tree
02:55:49 <buggymcbugfix> Hm, doesn't look as full-featured as UNIX find. I'm trying to `find . -type f -exec shasum {} \;`
02:56:02 <xerox_> https://hackage.haskell.org/package/filesystem-trees-0.1.0.6/docs/System-File-Tree.html#g:12
02:58:34 <buggymcbugfix> xerox_: No update in 2015, no README. A bit of a red flag for me.
02:58:45 <buggymcbugfix> s/in/since
02:59:14 <xerox_> findM is exactly what you want tho
03:00:53 <buggymcbugfix> Alas, I can't use an abandodned library like this :(
03:01:03 <buggymcbugfix> It's only reverse dependency is Lykah
03:03:51 <Orbstheorem> What's the best way to chain two separate parsers? Say I have `csv :: GenParser Char st [[Text]]` and `recipe :: GenParser Text st Recipe`. For the moment I'm running `csv` to feed it to `recipe`, but It feels hacky. Ideally I'd like to write `csvRecipe :: GenParser Char st Recipe` without running `csv`.
03:06:39 <xerox_> :t (>>=) -- (:
03:06:40 <lambdabot> Monad m => m a -> (a -> m b) -> m b
03:10:49 <buggymcbugfix> Ah, the answer to my `find` question might be to use bits of `shake`: https://hackage.haskell.org/package/shake-0.19/docs/Development-Shake.html#t:FilePattern
03:13:45 * hackage dialogflow-fulfillment 0.1.1.3 - A Dialogflow Fulfillment library for Haskell.  https://hackage.haskell.org/package/dialogflow-fulfillment-0.1.1.3 (mauriciofierrom)
03:18:51 <davve> aa/33
03:38:12 <claes-magnus> Hi! I wrote a post about reduce in JavaScript, reproducing quite a few often used array methods. Perhaps someone particullary fond of foldr in Haskell also could enjoy this article? https://herebeseaswines.net/essays/2020-05-13-about-reduce-in-javascript
03:47:52 <Uniaika> davve: IRSSI USER DETECTED!!
03:48:14 <Maxdamantus> claes-magnus: first statement:
03:48:20 <Maxdamantus> > reduce has many names; in other languages reduce is called fold or foldr.
03:48:21 <lambdabot>  <hint>:1:22: error: parse error on input ‘;’
03:48:28 <Maxdamantus> I think you mean foldl.
03:48:40 <Maxdamantus> reduce in JS is a left fold.
03:49:03 <Maxdamantus> (the right fold is `reduceRight`)
03:49:28 <davve> Uniaika: ^^
03:49:46 <Uniaika> :P
03:50:55 <int-e> /lose
03:51:42 <claes-magnus> Maxdamantus: ah, ok! Thanks
03:52:44 <justsomeguy> claes-magnus: By the way, I like the clean layout, and that you don't require any JS to load the page. (I don't dislike JS itself, but arbitrary code execution makes me nervous.)
04:02:04 <tdammers> does anyone know what it takes to convince Cabal 3.0 to build an executable that accepts +RTS -p? --enable-profiling doesn't seem to do the job, and --ghc-options='-prof' produces GHC panics while building
04:14:02 <gauss> I am working on a excesise about using quickCheck to justify (associative, left identity , right identity) a instance of typeclass Monoid of a newtype of function (a->b). I find it's hard to implement the arbitrary instance of this newtype.
04:15:16 <gauss> newtype Combine a b =
04:15:16 <gauss>   Combine
04:15:16 <gauss>     { unCombine :: (a -> b)
04:15:16 <gauss>     }
04:15:26 <opqdonut> a->b doesn't form a monoid... did you mean a->a?
04:15:28 <gauss> instance (Function a, Arbitrary b) => Arbitrary (Combine a b) where
04:15:28 <gauss>   arbitrary = do
04:15:29 <gauss>     (Fun a x) <- (arbitrary :: (Gen (Fun a b)))
04:15:29 <gauss>     return $ Combine x
04:16:20 <gauss> I don't know what's wrong about the instance I write above
04:16:58 <opqdonut> what's the error?
04:17:12 <opqdonut> from a quick glance at the docs you probably need a CoArbitrary a constraing
04:17:29 <gauss>  • Could not deduce (Function a1) arising from a use of ‘arbitrary’
04:17:30 <gauss>       from the context: (Function a, Arbitrary b)
04:17:30 <gauss>         bound by the instance declaration at <interactive>:109:10-61
04:17:30 <gauss>       Possible fix:
04:17:30 <gauss>         add (Function a1) to the context of
04:17:30 <gauss>           an expression type signature:
04:17:30 <gauss>             forall a1 b1. Gen (Fun a1 b1)
04:17:31 <gauss>     • In a stmt of a 'do' block:
04:17:31 <gauss>         (Fun a x) <- (arbitrary :: (Gen (Fun a b)))
04:17:32 <gauss>       In the expression:
04:17:32 <gauss>         do (Fun a x) <- (arbitrary :: (Gen (Fun a b)))
04:17:33 <gauss>            return $ Combine x
04:18:02 <opqdonut> ah right the a and b in your (Fun a b) aren't the same as in Arbitrary (Combine a b)
04:18:23 <opqdonut> drop the :: (Gen (Fun a b)) type annotation or add the ScopedTypeVariables language extension
04:19:17 <opqdonut> (you can't refer to the same type variables again in another type signature without the ScopedTypeVariable extension)
04:20:33 <opqdonut> > let tuple :: a -> b -> (a,b); tuple x y = (x::a,y) in tuple  -- simple example
04:20:35 <lambdabot>  error:
04:20:36 <lambdabot>      • Couldn't match expected type ‘a2’ with actual type ‘a1’
04:20:36 <lambdabot>        ‘a2’ is a rigid type variable bound by
04:21:18 <opqdonut> that code won't pass without ScopedTypeVariables. by default the type variables called `a` are two different type variables – renamed to a1 and a2 in the error
04:21:43 <gauss> :opqdonut, thanks, it works. I add the coarbitrary constraint and the extension you mentioned
04:23:23 <gauss> by the way, part of this problem is to implement mappend and mempty  to make this newtype a Monoid
04:24:06 <opqdonut> I guess there's a constraint like Monoid b => Monoid (Combine a b)?
04:24:17 <opqdonut> because I can't see how it could work otherwise :)
04:24:31 <ski> gauss : btw, note that you have some redundant brackets, you can just say `Fun a x <- arbitrary :: Gen (Fun a b)', or, since you're enabling `ScopedTypeVariables', even `Fun a x :: Fun a b <- arbitrary'
04:24:52 <ski> opqdonut : yea, that's what i would assume
04:25:10 <gauss> :opqdonut ,yes, I add this constraint
04:25:12 <gauss> instance (Semigroup b) => Semigroup (Combine a b) where
04:25:13 <gauss>   (<>) (Combine f) (Combine g) = Combine $ \x -> (f x <> g x)
04:25:13 <gauss> instance (Monoid b) => Monoid (Combine a b) where
04:25:13 <gauss>   mappend = (<>)
04:25:13 <gauss>   mempty = Combine $ \x -> mempty
04:25:51 <claes-magnus> justsomeguy: thank you! no, I don't (besides on the server from where I render parsed Markdown files as HTML but that doesn't count). Perhaps it's because I am the world's oldest junior frontend developer, but I think the Web suffers when we focus to much on design and behaviour (styling and js). :)
04:26:11 <ski> btw, i would probably change `Fun a x' to `Fun _ f' .. and also `return $ Combine x' to `return (Combine f)'
04:27:19 <gauss> :ski yes, It makes sense. I will improve it
04:28:39 <ski> or, instead of `do Fun _ f <- arbitrary :: Gen (Fun a b); return (Combine f)' you could write just `Combine <$> (arbitrary :: Gen (Fun a b))' .. or i suspect `Combine <$> arbitrary' would be enough
04:30:42 <ski> (on a similar note, you could write `instance Semigroup b => Semigroup (Combine a b) where ...' (removing a redundant pair of brackets, and likewise for `Monoid'). and, you could also define like `Combine f <> Combine g <> = Combine $ \x -> f x <> g x')
04:31:03 <gauss> I am working on Chapter 15 of "Haskell Programming from first Principles", I havn't learn enough about Monad
04:31:29 <ski> but you have learned about `Functor', at least ?
04:31:35 <ski> and possibly some about `Applicative' ?
04:31:42 <gauss> no.., that Ch16
04:31:45 <ski> ah, ok
04:32:14 <ski> well, '<$>' is a `Functor' operator
04:33:04 <ski> the `do' is fine too, if you think you follow it better. it's just that simple cases like this can be simplified a bit using that `Functor' operator, and, also sometimes, some `Applicative' ones
04:33:37 * ski idly wonders whether gauss is a Lisper
04:34:06 <gauss> en, the author did briefly mention it once while introducing do and IO
04:34:23 <ski> "it" being `<$>' ?
04:34:37 <gauss> yes
04:34:39 <ski> ok
04:34:57 <ski> you can use whichever you're more comfortable with, for now
04:35:30 <ski> (it's your code, you should use what makes it clearer to you)
04:37:26 <ski> gauss : should i explain a little, about the (two alternatives for the) type ascription for the `arbitrary', or do you think you follow it ?
04:38:18 <maralorn> What‘s the go to, batteries included logging infrastructure for Haskell?
04:38:57 <gauss> :ski Ok, I am still a liitle confused about arbitrary of function
04:39:32 <ski> okay. what're you confused about, do you think ?
04:40:32 <gauss> what's the best way to do that
04:41:25 <ski> well, in your case, your `Combine a b' data type is just a type whose values wrap/contain values of type `a -> b'
04:44:44 <ski> there is an `Arbitrary' instance for functions, but iirc an issue is that functions can't in general be displayed. so you could generate arbitrary function values, but you wouldn't then be able to show which function values caused your QuickCheck property to fail
04:45:15 <ski> iiurc, that's the deal with the `Fun a b' type, that it also keeps a record of how it generated the function
04:46:26 <ski> anyway, there's an `Arbitrary' instance for `Fun a b', which you're using to generate a value, which (at least if you used my renaming), is matched with the pattern `Fun _ f' ignoring the representation part, just using the generated arbitrary function `f'
04:46:34 <ski> gauss : is that making any sense ?
04:47:33 <gauss> do i ever have to use this ' representation part '
04:48:26 <ski> hm, maybe. i don't recall enough about how one's supposed to use `Fun'
04:49:01 <gauss> how to use only coarbitrary to implement
04:49:19 <gauss> I tried, and failed
04:49:22 <ski> it seems that, though, as your `Combine' is defined, you don't have any use for it in this `Arbitrary' instance
04:49:46 <ski> use `coarbitrary' to implement what ?
04:50:04 <gauss> quickcheck for newtype of function
04:50:23 <gauss> or arbitrary of function
04:50:38 <ski> hm, what did you try ?
04:52:42 <gauss>  coarbitrary a arbitrary
04:53:05 <ski> when trying to implement what ? or do what ?
04:53:40 <gauss> ....just finish this excersise
04:54:12 <ski> i don't have the book, i don't know what parts are included in the exercise
04:54:57 <ski> you have defined `Combine', you have a `Semigroup' and a `Monoid' instance. you have an `Arbitrary' instance
04:55:09 <ski> what more are you supposed to do, in the exercise ?
04:55:56 <maralorn> Can I share common stanzas between multiple cabal files?
04:56:01 <merijn> maralorn: No
04:56:25 <maralorn> :-(
04:56:30 <ski> an instance `CoArbitrary (Combine a b)' would be used, if you ever want to generate arbitrary functions which take a `Combine a b' as input .. i dunno whether you're asked to do that
04:56:52 <merijn> maralorn: I wouldn't hold your breath either, because I'm pretty sure that's an anti-goal
04:57:07 <gauss> what about "promote" and "variant"
04:57:14 <gauss> do i have to use them?
04:58:46 <ski> `variant' can be used, when making `CoArbitrary' instances
04:59:57 <ski> `promote' is in `Test.QuickCheck.Gen.Unsafe', and deals with generating monadic actions in some way. i forgot what it does, or why it's unsafe. i'd assume you don't need to use that
05:00:34 <ski> gauss : in `coarbitrary a arbitrary', where does `a' come from ? what's the context of this code snippet ?
05:00:40 <gauss> :ski right now, this problem is solved, I'd better just use Fun just now, the rest of  my confusion maybe clear itself after later learning about type and syntax.
05:01:30 <ski> gauss : but you're able to follow the `Arbitrary' instance (in particular the `do'), more or less ? .. and also the `Semigroup' and `Monoid' instances ?
05:02:21 <gauss> :ski yes, I think i understand the ones you referred 
05:02:33 <ski> gauss : oh, also one terminological confusion. `arbitrary' is not a function (all functions take exactly one argument, in Haskell). `arbitrary' is a monadic action. a `Gen'-action, in this case
05:03:33 <gauss> I think I will know Gen better after I learn abount Monad
05:04:54 <ski> in your case, `Fun _ f <- arbitrary :: Gen (Fun a b)', inside the `do' will, whenever the `do' is executed (which doesn't happen just because this definition of `arbitrary' is used / referred to, somewhere), execute `arbitrary', which yields back a monadic result of type `Fun a b', which is matched with the pattern to the left of the `<-'
05:05:24 <ski> gauss : you can sortof think of the `<-' here as "removing" the `Gen' from `arbitrary', by executing that action
05:07:17 <ski> gauss : yes, you will. however, learning `Applicative' and `Monad' is, to a large degree, about understanding how specific instances of those type classes do wildly differing things, while still also fitting in the rather "vague"/modest interface described by those classes
05:08:19 <ski> that is, you don't really first learn what a monad or an idiom (aka applicative functor) is, in general. rather, you learn about those, to a large degree, by being exposed to particular examples. like the `Gen' example, in this case
05:23:34 <gauss> ski: sorry, I did't notice before i left for dinner. I'd like to learn it another time, I have to close my laptop right now. thanks for your help and patience.
05:28:45 * hackage json-feed 1.0.10 - JSON Feed  https://hackage.haskell.org/package/json-feed-1.0.10 (fozworth)
05:29:45 * hackage github-release 1.3.2 - Upload files to GitHub releases.  https://hackage.haskell.org/package/github-release-1.3.2 (fozworth)
05:31:15 * hackage ratel 1.0.11 - Notify Honeybadger about exceptions.  https://hackage.haskell.org/package/ratel-1.0.11 (fozworth)
05:34:45 * hackage strive 5.0.11 - A client for the Strava V3 API.  https://hackage.haskell.org/package/strive-5.0.11 (fozworth)
05:37:39 <polyphem> ski : hello again, have my language built. Tho one with the GADT VarType Expr evaluator ... if you want to take a look https://github.com/polyrod/chops/blob/master/s2.prg
05:39:15 * hackage rattletrap 9.1.2 - Parse and generate Rocket League replays.  https://hackage.haskell.org/package/rattletrap-9.1.2 (fozworth)
05:41:48 <ski> polyphem : hm, looks nice :)
05:42:21 <ski> all the stuff before `start' are pseudo-instructions, directives for the assembler ?
05:42:51 <ski> is fall-through after a labelled block allowed ?
05:43:21 <ski> why are the blocks in an apparently strange (out of) order ?
05:43:27 <ski> how do you reach `en' ?
05:44:49 <ski> hm, perhaps it's just a silly example, to showcase being able to parse (?), and manipulate the AST, so far ?
05:45:44 <polyphem> ski : its a somewhat high level assembler , complex instructions , start is just a label , instructions before set up the audio sequencer , and load audio data , then i du sequener reset (srst) to start counting bars/beats/pulses 
05:45:57 <ski> oh, i guess at least `sel' is not a pseudo-instruction ?
05:46:13 <polyphem> i hav s1.prg/s2.prg/s3.prg just to test ...
05:46:50 <ski> (but `bgn' presumably is)
05:47:07 <polyphem> sel is "select" , selecting a "workspace" in wich to load audio clip and stor "marks"
05:47:20 <polyphem> yea bgn is ....
05:47:29 <ski> ok
05:48:04 <ski> is this position-independent code ?
05:48:27 <polyphem> its running , however i used a timer based approach to actually time "slice" playback ,
05:48:32 <ski> is the starting address fixed by the assembler ?
05:49:28 <polyphem> addresses ar just indexes in : type Program = [Stmt]
05:50:06 <polyphem> i resolve/rewrite  labels , already in the parser
05:50:11 <ski> mhm
05:50:53 <ski> so there's not really any translation to machine code, then ?
05:51:24 <polyphem> i have to refactor , however since i have timing issues i.e my approach of using a tiimer to "time" playback of slices doesnt work out
05:51:46 <polyphem> i already have a plan :)
05:51:52 <ski> it's just parsing, and resolving labels to positions in the sequence of instructions ?
05:52:14 <ski> are there to be any memory-mapped I/O ? or just instructions for I/O ?
05:52:30 <ski> how about data sections ?
05:52:41 <polyphem> ski : its an language for a VM , that controlles sampleplayback via jack
05:53:09 <ski> an existing one, or one you're making ?
05:53:57 <polyphem> ski : havent implemanted any data memory, besides variables, its somehow a unlimited register abstract machine , without stack , and no calls just jumps
05:54:11 <ski> hm, also i suppose i feel a bit confused at seeing C-style (and C++-style) comments in an assembler source file :)
05:54:26 <ski> i'm used to seeing `;' as end-of-line comment
05:55:11 <ski> mhm
05:55:12 <polyphem> ski : comments style is just first shot , i am using parsecs languageDef , and i filled in some stuff 
05:55:44 <ski> perhaps you'd like to have some kind of local variable mechanism, if you're making larger examples ?
05:55:55 <ski> or maybe not, since you don't have subroutines. i dunno
05:56:23 <polyphem> sky , its complete , it parses ,and executes the code on  the VM and puts out audio , its working , apart the timing issues
05:56:45 <ski> that's great, apart from that final issue
05:57:47 <polyphem> ski : i dont want to go to technical like simulating a real cpu , as its intended to be an instrument rather than a "programming tool"
05:58:00 <ski> if you're using indices, perhaps you'd want to use an array instead of list. but perhaps that's for later, this is just to get something working
05:58:10 * ski nods
05:59:12 <polyphem> for example the "fit" instruction scales the selcted audio to the current bar length , so i can fit an audio loop easily to prefered tempo
06:01:35 <polyphem> think of it kind of a daw , but you "code" up the recipie for your song, so you can change your workflow aferwards by changing code , instead of doing evrything with mouse n clicks and drags as in a traditional daw
06:02:40 <ski> not sure what "daw" is
06:02:52 <polyphem> DigtalAudioWorkstation
06:02:54 <ski> (i'm not really familiar with audio processing)
06:03:36 <ski> (and i'm not really sure what workspaces, workflows, are here, either)
06:03:54 <ski> hm
06:04:10 <ski> what you just said reminded me of module/tracker music
06:04:32 <polyphem> workspace , is a type witch represents an audiofile and its marks 
06:04:56 <ski> mhm
06:05:18 <ski> a single piece of music composition ?
06:05:22 <polyphem> you can have multiple in a running porgram and can switch between them using the "sel" instruction
06:05:39 <ski> or could also be supporting things, meant to be used by another file ?
06:06:13 <ski> (i dunno what "marks" are, either)
06:06:26 <polyphem> workflow is just workflow in a gui application compared to workflow in an textual sng representation
06:07:02 <ski> have you seen tracker music ?
06:07:20 <polyphem> ski: yeas i loce tracking
06:07:27 <polyphem> love
06:07:34 * ski nods and smiles
06:07:53 <polyphem> think of it as a "free" tracker
06:09:25 <polyphem> marks ar just named indecies into the soundfile
06:10:06 <polyphem> so i can say "playf mark1" or "playb snare" or so
06:10:43 <polyphem> they are float so even if i stretch the audioclip the still point to the right place
06:10:55 * ski . o O ( Protracker,StarTrekker,FastTracker 2,.. )
06:12:05 <ski> "soundfile" here is the same as "audiofile" ? or is it like a sample/wav, or collection of those ?
06:12:09 <polyphem> ski: lately i used tutka , its a midi sequncer tracker
06:12:56 <polyphem> ski: https://github.com/polyrod/chops/blob/master/Chops/WSpace.hs
06:14:18 <polyphem> ski: and here you see "marks" in action . https://github.com/polyrod/chops/blob/master/s3.prg
06:15:37 <polyphem> marks are like jmp labels , but not for controllflow but rather pointers into audio data
06:16:15 * hackage pandoc-plot 0.5.0.0 - A Pandoc filter to include figures generated from code blocks using your plotting toolkit of choice.  https://hackage.haskell.org/package/pandoc-plot-0.5.0.0 (LaurentRDC)
06:16:23 <ski> mhm
06:17:31 <polyphem> well , going to refactor now , to get those timing issues resolved ...
06:40:45 * hackage extra 1.7.2 - Extra functions I use.  https://hackage.haskell.org/package/extra-1.7.2 (NeilMitchell)
06:56:15 * hackage tonatona-google-server-api 0.1.3.0 - tonatona plugin for google-server-api  https://hackage.haskell.org/package/tonatona-google-server-api-0.1.3.0 (arowM)
07:07:15 * hackage ginger 0.10.0.2 - An implementation of the Jinja2 template language in Haskell  https://hackage.haskell.org/package/ginger-0.10.0.2 (TobiasDammers)
07:16:56 <aveltras> is it possible to derive monoid for a record given that all its fields are themselves monoid ?
07:17:18 <aveltras> for example i'd like to be able to use mempty to get a fresh form with empty fields for the following
07:17:22 <aveltras> https://www.irccloud.com/pastebin/pvus7zEf/
07:17:27 <lortabac> aveltras: you can do it with Generic
07:18:02 <aveltras> how would the deriving look like ?
07:18:56 <lortabac> erm, the generic definitions are usually a little complex, but easy to use
07:19:10 <solonarv> there's a library which has a bunch of them, forunately
07:19:13 <solonarv> @hackage generic-data
07:19:14 <lambdabot> http://hackage.haskell.org/package/generic-data
07:19:35 <dgpratt> I stumbled across this recently https://github.com/ekmett/lens/blob/master/examples/Pong.hs#L85 and I've been driving myself a bit batty trying to puzzle it over. In particular, I don't understand the implementation of this "hitPos" function.
07:19:52 <aveltras> solonarv: seems to be what i need here, thanks
07:20:33 <solonarv> usage is very simple: just add 'deriving (Semigroup, Monoid) via (Generically MyType)' to your type's definition
07:20:53 <solonarv> (needs DerivingVia extension)
07:21:31 <dgpratt> I guess xdist represents the distance along the x-axis? And "u" is maybe the velocity along the same axis? But why then is the x distance 1 - x if the velocity is positive and 3 - x otherwise? Or am I entirely out in left field here?
07:24:13 <dgpratt> err...3 + x
07:43:15 * hackage euler 0.10.1 - Mathematics utilities for Haskell  https://hackage.haskell.org/package/euler-0.10.1 (luisonthekeyboard)
08:01:15 * hackage lambdabot-core 5.3 - Lambdabot core functionality  https://hackage.haskell.org/package/lambdabot-core-5.3 (BertramFelgenhauer)
08:02:15 * hackage lambdabot 5.3, lambdabot-trusted 5.3, lambdabot-social-plugins 5.3, lambdabot-reference-plugins 5.3, lambdabot-novelty-plugins 5.3, lambdabot-misc-plugins 5.3, lambdabot-irc-plugins 5.3, lambdabot-haskell-plugins 5.3 (BertramFelgenhauer)
08:05:32 <shapr> ooh, does lambdabot work with ghc 8.10 now?
08:08:49 <int-e> shapr: no way
08:09:02 <int-e> shapr: this is catching up with 8.8, finally
08:09:07 <shapr> hey, that's progress!
08:09:13 <int-e> I'm scared to even look at 8.10
08:09:17 <shapr> I was thinking about setting up lambdabot on my work slack
08:09:46 <int-e> Also... now I'll have to get it built for the VM.
08:09:46 <shapr> but I haven't looked at lambdabot source in a decade or more
08:10:16 <int-e> I guess it's not the most terrible code on Earth.
08:10:35 <shapr> it also wasn't the greatest, being a community project from #haskell that got handed off a bunch of times
08:11:39 <int-e> It's not nice either. And it has a ton of dependencies which means that catching up to new ghc versions tends to take a while.
08:12:55 <merijn> int-e: 8.10 is fairly minor from 8.8
08:13:17 <int-e> I'll believe it when I see it.
08:13:20 <int-e> :P
08:46:45 * hackage hasty-hamiltonian 1.3.3 - Speedy traversal through parameter space.  https://hackage.haskell.org/package/hasty-hamiltonian-1.3.3 (JaredTobin)
08:47:05 <polyphem> I have a concurrent app where thread A is producer and thread B is consumer ; B consumes steady  whereas A produces big chunks of data fast but somtimes A produces little data and takes a while for that. I need the optimal data structure to buffer As data that keeps B happy. I tried ConcurrentBuffer but doesnt work , it leaks memory and is to slow i.e. B stutters of buffer underrun . I was looking
08:47:07 <polyphem> for some DoubleBuffer but didnt find any. Any suggstions ? Please
08:50:31 <merijn> polyphem: Why not some kinda of concurrent Channel?
08:56:10 <polyphem> i looked at the source of ConcurrentBuffer  it uses STM but leaks , maybe i have to build my own
08:57:23 <mniip> why not Chan/TChan
08:57:58 <Uniaika> Unagi-Chan!
08:58:06 <polyphem> merijn , mniip : isnt STM  kinda slow ?
08:58:19 <mniip> Chan is not STM
08:58:40 <mniip> and how many entries per second are you pushing?
08:59:12 <polyphem> Uniaika: i came across that one while googleling/hackage search , didnt know if it fitted my need then , will take a look , thanks 
08:59:41 <mniip> what you could do is try to push/pop many at a time
09:00:05 <polyphem> mniip : around 44100
09:00:08 <polyphem> :)
09:00:14 <mniip> hmmm that's tough
09:00:23 <mniip> you might be interacting with the GC there
09:00:34 <mniip> might not be an intrinsic problem with ConcurrentBuffer or whatever
09:01:59 <polyphem> mniip: yeah , thats why i want to buffer up reasonable much , so that B can consume even if GC is blocking a from producing more
09:02:17 <polyphem> s/a/A/
09:05:31 <mniip> when GC is doing stuff B is not running
09:10:15 * hackage bugsnag-hs 0.1.0.2 - A Bugsnag client for Haskell.  https://hackage.haskell.org/package/bugsnag-hs-0.1.0.2 (JasperWoudenberg)
09:11:15 * hackage cabal-fmt 0.1.3 - Format .cabal files  https://hackage.haskell.org/package/cabal-fmt-0.1.3 (phadej)
09:12:12 <polyphem> mniip: ill try unagi-chan
09:12:14 * hackage cabal-plan 0.7.0.0 - Library and utility for processing cabal's plan.json file  https://hackage.haskell.org/package/cabal-plan-0.7.0.0 (phadej)
09:12:31 <mniip> polyphem, I think your issue might not be in the queue
09:16:46 <polyphem> mniip: you think its the GC ?!
09:17:04 <mniip> yes
09:17:31 <awpr> oh, you're doing audio processing by enqueuing individual samples?
09:17:31 <mniip> GC is known to mess up realtime guarantees
09:18:10 <awpr> that's going to generate a _ton_ of work for the GC
09:18:12 <maralorn> In what hell do I belong when I use unsafePerformIO to retrieve a ThreadId for debugging?
09:18:42 <int-e> maralorn: the monsters of impurity will devour you in your sleep
09:19:03 <maralorn> More specific would that ThreadId be meaningful?
09:19:10 <polyphem> awpr: yes , audio -> https://github.com/polyrod/chops
09:19:56 <polyphem> its A:sample generator,  B:jack
09:20:44 <polyphem> i ll throw unagi-chan at it , to see what it will do 
09:21:27 <NieDzejkob> I was about to ask why -3 `div` 7 evaluates to 0 instead of -1, but then I have realized that the precedence has bamboozled me and (-3) `div` 7 works as expected. Thanks rubber duckies!
09:22:25 <awpr> most audio processing is implemented by operating on a few hundreds of samples at a time and blitting them to a ring buffer
09:24:40 <Uniaika> polyphem: tell me if unagi-chan turns out to be what you needed or not
09:24:56 <polyphem> Uniaika: will do
09:25:22 <awpr> generally that's more low-level interaction with concurrency, since it's using the same memory many times.  I know I've written something before that talks to JACK that way, but I can't seem to find it
09:26:07 <awpr> I found a .cabal file in Google Drive...
09:26:07 <polyphem> awpr: ring buffer worked for you on jack ?
09:27:01 <polyphem> Uniaika: interface seems nice , also the bounded variant 
09:27:04 <awpr> the JACK API is actually using a ring buffer internally, IIRC
09:28:24 <polyphem> jack gives me a buffer i have to fill in time , first i computed each byte on the fly but now i want to precompute a lot fast in advance and lett jack read empty my buffer/chan/ring ...
09:29:48 <merijn> polyphem: Why would STM be slow? Also, slow compared to what?
09:30:36 <awpr> I suspect sourcing individual bytes from a concurrent queue will be slower than computing them
09:30:58 <awpr> synchronization is always more expensive than it seems like it should be
09:32:22 <awpr> how far in advance is it even possible to compute?  looks like (from a very quick glance) this is consuming real-time MIDI events from JACK to control the audio anyway?
09:32:45 * hackage wai-middleware-auth 0.2.3.1 - Authentication middleware that secures WAI application  https://hackage.haskell.org/package/wai-middleware-auth-0.2.3.1 (JasperWoudenberg)
09:34:48 <int-e> @hoogle init
09:34:49 <lambdabot> Prelude init :: [a] -> [a]
09:34:49 <lambdabot> Data.List init :: [a] -> [a]
09:34:49 <lambdabot> Data.List.NonEmpty init :: NonEmpty a -> [a]
09:34:58 <int-e> > 42
09:35:00 <lambdabot>  42
09:35:18 <int-e> Hmm, seems to work... it's on ghc-8.8.3 now.
09:37:58 <awpr> polyphem: have you tried the new low-latency GC with `+RTS -xn` (on GHC 8.10 and newer)?  it could conceivably help here
09:39:14 <awpr> my recollection is that the main obstacle I ran into with supplying JACK with samples was that the GC ran and just stopped me from doing any work at all until after the deadline
09:47:35 <polyphem> awpr, Uniaika , mniip : ok unagi chan is in , works better than ConcurentBuffer ,but still not good enough. Strange is that when may audio stutters (GC should block) aferwards it sys mem usage went up ???
09:47:58 <polyphem> checking with -xn
09:48:01 <polyphem> now
09:48:43 <Uniaika> polyphem: I would encourage you to open an issue if you've got trouble with perfs, this might raise awareness on performance-related optimisations
09:48:56 <Uniaika> (or give you more hints to further optimise the RTS options)
09:49:01 <Uniaika> (JVM-style :P)
09:49:25 <awpr> amusingly `-xn` enables a JVM-style GC :)
09:49:36 <polyphem> man , ghc-8.6.5 :(
09:50:31 <polyphem> cabal is using system ghc right , unlike stack ?
09:50:51 <awpr> yeah, cabal doesn't manage its own GHCs
09:51:30 <polyphem> i'll push the repo
09:51:31 <merijn> cabal-install uses whatever ghc is on your path
09:51:46 <merijn> Which may or may not be a "system ghc", whatever you interpret that to mean
09:54:56 <awpr> I found the code I was looking for -- indeed I'm computing samples directly into the JACK-provided buffers, and the only concurrency involved in that path is in `atomicModifyIORef` that updates synthesizer parameters
09:55:01 <polyphem> i am on debian unstable , gonn check if they have newer ghc
09:55:10 <solonarv> don't use system packages for GHC
09:55:30 <solonarv> they lag behind, sometimes they are broken, and usually they don't support multiple GHC versions
09:55:41 <polyphem> awpr: and does it perform reasonable
09:56:02 <awpr> I haven't run it in a few years, but I remember it working well enough for my tastes
09:56:19 <awpr> my hunch is that changing it to any kind of concurrent queue would just break it completely
09:57:24 <awpr> but I had to do a lot of work both to ruthlessly minimize the amount of allocations done by the sample generation code and also set up a thread to poke the GC every time we submitted a buffer to JACK
09:57:35 <awpr> so that _hopefully_ all the GC work is in the gaps
09:58:35 <polyphem> i have that VM that when in "waiting state" copies a lot of samples to jack untill it wakes up, then when awake executes instructions till it gets in waiting state again, and copies samples . so all VM computation is done in one sample step
09:59:19 <polyphem> thats too much for computing the sample directly , therfor i wanted to buffer up samples
10:02:35 <polyphem> awpr: its happening in operateVM : https://github.com/polyrod/chops/blob/master/Chops/Cpu.hs#L123
10:03:23 <awpr> yeah, that's more interesting than I had appreciated
10:03:45 * hackage pandoc-utils 0.7.1 - Utility functions to work with Pandoc in Haskell applications.  https://hackage.haskell.org/package/pandoc-utils-0.7.1 (Krasjet)
10:05:43 <awpr> does it generate samples fast enough to keep up with real-time in the first place?
10:06:18 <awpr> JACK's deadlines shouldn't be too much more aggressive than just "as long as it takes to finish playing the last buffer", maybe?
10:09:13 <polyphem> awrp: it plays reasonable well for some seconds then it stuuters, and then keeps playing nicly , till it stuuters again ... and every time it stutters sysmem usage gous up , so i have to kill it els it freezes my system
10:10:57 <awpr> if letting the VM run ahead is going to help (i.e. if it's fast enough on average but sometimes misses deadlines), maybe making the VM enqueue whole Storable Vectors of many samples at a time would help
10:11:14 <ClaudiusMaximus> you probably want to use something like LLVM to compile to machine code (or bytecode for a vm) that doesn't allocate or free or gc ever
10:11:16 <awpr> that also sounds like a space leak, which... can be hard to debug
10:12:45 <awpr> stuttering + jumping system memory usage sounds like a major GC pausing the program too long to keep up with real-time and deciding it needs to increase the heap size
10:13:15 <polyphem> awpr: thats what my intend was , to fill up a buffer for jack so it has to work when i am doing vm code progression
10:13:52 <rsoeldner> Is there a direct way to get the number of bytes of a `Data.Text` ?
10:14:25 <awpr> polyphem: yeah, you just really don't want to pay synchronization overhead for every sample -- if the items of the queue are vectors of 64ish-or-more-ish samples, you might have better luck
10:14:35 <polyphem> so , i think ill chase the space leak , then go to stack build system to get newer ghc wwith +RTS -xn ... and then try if it helps :(
10:15:33 <polyphem> yea, chunking the reads
10:15:39 <polyphem> and writes
10:16:02 <awpr> was the space leak already there before you moved VM computation behind a queue?
10:17:34 <wavemode_> rsoeldner: Data.Text.Foreign (lengthWord16 :: Text -> Int)
10:17:53 <polyphem> awpr : my initial commit used timed wakeup , no space leak , only with concurrentBuffer and unagi-chan 
10:18:37 <rsoeldner> wavemode_, thank you :)
10:19:44 <awpr> interesting, I don't have much experience debugging concurrent queues, but it does provide some hints
10:20:06 <awpr> hmm, any idea how far ahead your VM is running?  is it possible it's just making the queue grow unbounded?
10:20:59 <awpr> ah nevermind, it's bounded by a constant
10:22:24 <polyphem> yea i had that problem with ConcurrentBuffer , thats why i introdussed that wileM loop to threshold upper fill bound , unagi-chan comes with a bounded variant thet blocks writes if too full
10:24:33 <polyphem> well awpr, thanks for your input , think i have a plan on how to preceed .
10:26:26 <awpr> np, and good luck, realtime audio can be hard
10:28:36 <polyphem> awpr , yea , i like haskell , and i like audio , unfortunatly they dont fit easily ...
10:33:14 * hackage list-tuple 0.1.2.0 - List-like operations for tuples  https://hackage.haskell.org/package/list-tuple-0.1.2.0 (kakkun61)
10:34:15 * hackage single-tuple 0.1.1.0, homotuple 0.1.1.0 (kakkun61): https://qbin.io/good-pants-esxl
10:46:45 * hackage cabal-flatpak 0.1.0.2 - Generate a FlatPak manifest from a Cabal package description  https://hackage.haskell.org/package/cabal-flatpak-0.1.0.2 (HenningThielemann)
11:00:30 <awpr> `    • No instance for (Pretty Body)`  ... that's not a very nice thing to say, GHC
11:04:04 <xerox_> haha
11:08:44 <parsnip> haven't used haskell in a while. is this a fine place to start? https://cabal.readthedocs.io/en/latest/getting-started.html
11:10:01 <xerox_> judging by the url alone it looks likely
11:11:23 <yushyin> parsnip: if you just want to know how to use the cabal build tool to build your projects, yes.
11:11:48 <parsnip> i mean, stack was more pervasive going back years
11:12:38 <parsnip> when i google, "how to get started with haskell", i get a lot of sites that look like self interest, or old
11:13:05 <parsnip> oh... i could look at /topic
11:13:27 <awpr> I tend to use the Stack installer script installer script and then let stack take care of getting a GHC for me
11:13:47 <awpr> I've broken my system GHC's package database far too many times, to the point that often I don't even install a system GHC anymore
11:13:48 <sand_dull> "Learn You a Haskell for Great Good" is good and it's available free online, if you're looking to get (re)started
11:14:13 * awpr isn't sure how he managed to type "installer script" twice
11:14:22 <parsnip> i played with Haskell for seven months (as my first language) in 2015
11:14:34 <yushyin> parsnip: yeah just use ghcup+cabal or stack and you are good to go
11:14:42 <monochrom> parsnip: Don't forget to read Chapter 5.  It is the new mode of operation of cabal-3.  Most of it should be in Chapter 1.
11:14:55 <parsnip> cabal-3 !?!?!?
11:15:07 <monochrom> cabal-3
11:16:12 <parsnip> oh, right... v2 i guess
11:16:39 <parsnip> i noticed that in passing uses of Haskell more recently.
11:17:01 <parsnip> that using Haskell without Stack is improving
11:17:14 <parsnip> cabal new-install, etc
11:17:35 <yushyin> yup
11:18:47 <maerwald> parsnip: s/improving/recommended/ :P
11:20:32 <justsomeguy> HPFP (haskellbook.com) recommends stack, but I've been finding that cabal is pretty nice on it's own. Maybe it's improved a lot since 2015?
11:20:51 <parsnip> so installing ghc's via ghcup, is recommended over my dusty homebrew ghc?
11:21:10 <parsnip> haskell.org was basically pointing me towards installing Stack, btw
11:22:00 <parsnip> i'll try it and see
11:22:05 <parsnip> brew unintall ghc
11:22:08 <parsnip> *uninstall
11:22:35 <parsnip> seems quiet today. probably because weekend and holiday.
11:22:37 <awpr> I think `ghcup`'s GHCs won't conflict with homebrew's -- they end up in ~/.ghcup, I think
11:22:53 <awpr> just have to get the PATHs in the right order
11:23:08 <parsnip> i think i'll nuke it, just to be sure
11:23:35 * justsomeguy has something like ~10 copies of GHC. He should really learn how to develop in containers.
11:23:55 <maerwald> yes, containers will blow up your disk space less... lol
11:24:19 <monochrom> I go so far as: If you're on Windows, get Linux in WSL or a VM, then use ghcup there.
11:24:31 <steven_> hi, anyone know how I can remove explicit recursion from this function? Tried foldM but the output is reversed when I do that. Seems like I need a right foldM but I wanted to see if there's a better way. https://gist.github.com/stevenfontanella/701dda039889315f9f8057e322ec1fd7
11:24:51 <justsomeguy> All linux over here, baby! I got paranoid after the snowden leaks.
11:25:05 <sand_dull> same here
11:25:31 <justsomeguy> Cool, I'm not the only one.
11:26:18 <awpr> steven_: looks like `traverse` is what you're looking for
11:26:42 <awpr> in order to directly translate "for each character, accept a case-folded version of it"
11:26:54 <steven_> awpr: cool I'll try
11:32:45 <jlebar> I'm learning Haskell by doing problems at https://codeforces.com/.  One thing I haven't figured out is, which Haskell packages are available to me?  I'm wondering if maybe I can write a Haskell program which lists all packages that are installed?
11:33:36 <monochrom> cannot
11:33:49 <jlebar> It seems to be more than just https://hackage.haskell.org/package/base, because I can import Data.Array
11:33:54 <frdg> Is there an advantage to using `pure` instead of `return` ?
11:34:27 <jlebar> monochrom: is there a "standard set of packges" that are probably available?
11:34:29 <monochrom> But I'm pretty sure the website has the information somewhere. Even a simple sentence like "what comes with GHC".
11:35:13 <monochrom> pure is more future-proof.
11:35:39 <monochrom> but I bet return is here to stay, it can't go away.
11:35:49 <monochrom> But pure is a better name than return.
11:36:04 <monochrom> The GHC documentation contains a list of packages and modules.
11:36:39 <monochrom> I wouldn't call it standard because there are so many standards to choose from.
11:36:43 <frdg> monochrom: Ya ive been using solely pure just cause I can/you mentioned that its better one time
11:36:45 <monochrom> (There are at least 3.)
11:39:16 <EvanR> explaining pure x as a computation with no effects might pass the obvious test
11:39:33 <EvanR> explaining return x as that, might lead to follow up questions
11:40:09 * dmwit . o O ( pure is a sigil that we use to mark non-monadic computations )
11:40:16 <maerwald> what??
11:40:33 <monochrom> I hate sigils :)
11:40:33 <L29Ah> https://matrix.hackage.haskell.org/#/package/pontarius-xmpp why aren't 8.10.1 and 8.8.3 build results available?
11:40:56 <L29Ah> pure is a sigil that we use to mark our despise to return
11:41:21 <awpr> one might interpret `return` as "jump control flow to return immediately" by analogy to its behavior in most imperative languages
11:41:30 <monochrom> pure converts a pure computation to an impure computation.
11:41:39 <monochrom> Therefore it should be called impurify.
11:41:59 <awpr> or it should be called `id` :)
11:42:02 <dmwit> no no
11:42:10 <dmwit> pure is an adjective that describes its argument
11:42:35 * justsomeguy has seen enough weird and conflicting uses of the keyword return in different languages that he no longer makes assumptions.
11:42:59 <maerwald> "pure () :: IO ()" is as pure as any other IO value.
11:43:02 <L29Ah> @hoogle begin
11:43:02 <lambdabot> Database.PostgreSQL.Simple begin :: Connection -> IO ()
11:43:02 <lambdabot> Database.PostgreSQL.Simple.Transaction begin :: Connection -> IO ()
11:43:02 <lambdabot> Proto.Google.Protobuf.Descriptor_Fields begin :: forall f s a . (Functor f, HasField s "begin" a) => LensLike' f s a
11:43:07 <L29Ah> @hoogle end
11:43:07 <lambdabot> Proto.Google.Protobuf.Descriptor_Fields end :: forall f s a . (Functor f, HasField s "end" a) => LensLike' f s a
11:43:07 <lambdabot> Data.Text.ICU.Regex end :: Regex -> Int -> IO (Maybe I16)
11:43:07 <lambdabot> HaskellWorks.Data.AtIndex end :: Length v => v -> Position
11:43:15 <L29Ah> no fun
11:43:26 <xerox_> pure brings it back to the impure world from the pure platonic world, it should be called return
11:43:36 <monochrom> haha
11:44:16 <maerwald> "pure" is as much of a lie as "return"
11:44:32 <maerwald> except now it only confuses haskellers, not non-haskellers
11:44:35 <monochrom> . o O (Return of the Sith, Revenge of the Jedi)
11:45:06 <awpr> % let (?!) = pure
11:45:06 <yahb> awpr: 
11:45:12 <awpr> :t (42?!)
11:45:13 <lambdabot> error:
11:45:13 <lambdabot>     • Variable not in scope: (?!) :: Integer -> t
11:45:13 <lambdabot>     • Perhaps you meant one of these:
11:45:32 <awpr> ^ now we can confused everyone equally
11:48:38 <steven_> % (?!) = pure
11:48:38 <yahb> steven_: 
11:48:43 <steven_> :t (42?!)
11:48:44 <lambdabot> error:
11:48:44 <lambdabot>     • Variable not in scope: (?!) :: Integer -> t
11:48:44 <lambdabot>     • Perhaps you meant one of these:
11:48:58 <steven_> oh
11:49:02 <steven_> thought it would work without let
11:49:18 <wavemode_> you guys are making a definition in yahb and trying to evaluate it in lambdabot...
11:49:35 <justsomeguy> Newbie question: When should I use let in do blocks?
11:49:36 <monochrom> because the purpose was confusion
11:49:36 <dsal> I thought that was the joke
11:50:00 <monochrom> when you are forced to use let.
11:50:29 <steven_> justsomeguy: when the right hand side isn't a monadic value
11:50:44 <justsomeguy> monochrom: I am totally OK with that explanation.
11:50:55 <maerwald> steven_: what? :D
11:51:00 <awpr> wavemode_: yeah, I messed that up and didn't bother fixing it because it was already too much spam for a joke naming proposal anyway
11:51:32 <steven_> maerwald: usually if you're in a `do` block it's so you can 'extract' values from a monadic (like IO) computation
11:51:50 <maerwald> steven_: let ioValue = pure x
11:51:51 <steven_> so if you have a function with signature IO String (like getLine) and you want a String, then you use <- in a do block
11:52:02 <L29Ah> @define (?!) = pure
11:52:03 <lambdabot>  Defined.
11:52:13 <L29Ah> :t (42?!)
11:52:14 <lambdabot> (Applicative f, Num a) => f a
11:52:22 <steven_> but if you have a normal function that returns a string (not IO String) then you just use let x = whateverFunction
11:52:35 <maerwald> you can use let with monadic values just fine
11:52:38 <maerwald> and I do that a lot
11:52:50 <steven_> you can, but from a beginner perspective you usually won't
11:52:56 <maerwald> why not?
11:53:15 <monochrom> This is why my answer is superior. Especially for beginners.
11:53:16 <L29Ah> > 42?! ++ 34?!
11:53:17 <lambdabot>  <hint>:1:6: error: parse error on input ‘++’
11:53:27 <L29Ah> > (42?!) ++ (34?!)
11:53:29 <lambdabot>  [42,34]
11:54:04 <L29Ah> > (42?!) >> (34?!)
11:54:06 <lambdabot>  error:
11:54:06 <lambdabot>      • Ambiguous type variable ‘m0’ arising from a use of ‘show_M195162843512...
11:54:06 <lambdabot>        prevents the constraint ‘(Show (m0 Integer))’ from being solved.
11:54:16 <L29Ah> > take 6 $ (42?!) >> (34?!)
11:54:17 <steven_> maerwald: When I was a beginner it was easier for me to think <- goes with monads and let/= otherwise. Not everyone has the same experience of course
11:54:18 <lambdabot>  [34]
11:54:37 <maerwald> steven_: I think it gives you an odd intuition
11:54:52 <steven_> didn't mean to impose anything, just describing how I learned
11:55:04 <wavemode_> why obfuscate the issue? after `x <- func`, x would have type String, whereas after `let x = func`, x would have type IO String. which one you'd use depends on what you need it for
11:55:09 <monochrom> In an ideal world, the best answer would be "beginners don't use do-notation, end of story". But too many blogs use do-notation already, it's a lost cause.
11:55:13 <maerwald> the idea is to *break* the beginners intuition and have their mind blown
11:55:35 <monochrom> And in an ideal world, beginners wouldn't learn from blogs in the first place.
11:55:48 <maerwald> yeah, they would learn from haskell-wiki.....
11:56:05 <awpr> would they derive knowledge from first principles and/or reading the GHC user guide?
11:56:06 <monochrom> haskell-wiki in an ideal world would be OK :)
11:56:22 <steven_> I think it's acceptable to give a slightly wrong model that helps people make progress and correct it later
11:56:40 <L29Ah> damn lambdabot gets updated but my pull request is ignored :<
11:56:53 <monochrom> Bah, perhaps my whole point is moot.  In an ideal world, you learn by just plugging the computer into the USB port on your brain.
11:57:10 <awpr> I think in an ideal world it'd be USB-C
11:57:11 <maerwald> why not firewire?
11:57:42 <L29Ah> monochrom: i always start my program from `main = do`
11:57:49 <monochrom> because in this non-ideal world, if I said "firewire" fewer people would understand me
11:57:54 <justsomeguy> firewire has better electronica songs about it
11:58:08 <justsomeguy> :^)
11:58:16 * hackage ormolu 0.1.0.0 - A formatter for Haskell source code  https://hackage.haskell.org/package/ormolu-0.1.0.0 (mrkkrp)
11:58:33 <wavemode_> imagine using firewire in 2020
11:58:46 <maerwald> L29Ah: I start my programs with 50 LOC of GHC plugins and 500 LOC of imports. Before I get to main = ... all my editor plugins including HIE crashed
11:59:06 <monochrom> slightly wrong model is OK only when substantially simpler than the correct model.
11:59:42 <L29Ah> plugins? what plugins?
11:59:42 <monochrom> Unfortunately, in this case, the correct model "when you want a local definition" is so simple you can't beat it with any slightly wrong model.
11:59:48 <maerwald> L29Ah: :D
12:00:08 <L29Ah> hie maintainers shit on hackage users so i don't use it
12:00:16 <EvanR> firewire... sad this word was blown on such old tech. Like "high-speed CMOS"
12:00:20 <L29Ah> (actually on stack-nonusers)
12:00:32 <maerwald> L29Ah: it should work with cabal. At least last I fixed it
12:00:32 <monochrom> But when I gave my answer, my analysis went one step further than that.
12:00:54 <L29Ah> last time i've checked they tell the package is deprecated
12:01:25 <maerwald> I think building from hackage won't work so well, you gotta use shake
12:01:33 <L29Ah> wavemode_: actually usb3 is surprisingly okay
12:01:47 <monochrom> It stands to reason to assume that a beginner already knew that "let" is for local definitions. So the question was probably more about style. In that case, "when you have no other way" is a very good answer for the style question.
12:02:15 <maerwald> there are probably subtle differences wrt optimisation, inlining etc? But I can't be bothered to remember those
12:02:34 <maerwald> and they may all change in the next GHC version anyway, no?
12:02:51 <maerwald> I don't like moving target knowledge
12:05:41 <wavemode_> you type let so that hlint won't laugh at you for typing `x <- return ...`
12:08:48 <dsal> I wonder how often my main is a do block.
12:12:20 <monochrom> https://mail.haskell.org/pipermail/haskell-cafe/2011-August/094871.html
12:14:52 <polyphem> awpr: hey, mate, .... it works like a charm , using chunksize of 256 and a runs without glitch, and no more space leak :) 
12:15:20 <awpr> :D
12:31:47 <threestrikes> 1
12:32:01 <yushyin> 2
12:32:26 <threestrikes> lol sorry
12:48:20 <younder> Are there any DNN API's for Haskell or are they all Python etc.
12:53:37 <aveltras> any way i can pattern match on a type operator using template haskell ? the following gives me a "parse error in pattern"
12:53:42 <aveltras> https://www.irccloud.com/pastebin/ujdkB7S7/
12:53:54 <aveltras> i'd like to deconstruct a servant api
12:56:06 <awpr> looks like you're trying to write a function to manipulate `Type`s; in Haskell this is done with type families, since working with `Type`s isn't meaningfully allowed at runtime
12:56:55 <aveltras> this is template haskell
12:57:21 <awpr> oh, oops.  brain isn't working today
12:57:39 <aveltras> np :)
12:58:02 <wavemode_> my brain takes holidays off
13:03:49 <monochrom> Is it just because ' vs '' ?
13:05:25 <aveltras> double quote throws  the same error
13:05:49 <monochrom> not double quote ", instead, two single quotes
13:06:06 <aveltras> yes, that's what i meant sorry
13:06:54 <monochrom> perhaps delete the parentheses
13:08:01 <awpr> looks like quoted names aren't legal in patterns?
13:08:15 <monochrom> Oh, that may be it.
13:08:20 <awpr> you may have to use a pattern guard and `==`
13:08:56 <monochrom> yeah, very few things can be patterns.
13:10:42 <aveltras> seems the following compiles at least
13:10:45 <aveltras> https://www.irccloud.com/pastebin/EqXcSOH3/
13:10:51 <aveltras> thanks for the help
13:21:45 * hackage pusher-http-haskell 1.5.1.12 - Haskell client library for the Pusher HTTP API  https://hackage.haskell.org/package/pusher-http-haskell-1.5.1.12 (willsewell)
13:29:45 * hackage servant-errors 0.1.6.0 - Servant Errors wai-middlware  https://hackage.haskell.org/package/servant-errors-0.1.6.0 (epicallan)
13:31:10 <younder>  Are there any libraries that implement elliptic curve pairings?
13:38:33 <dgpratt> I'm trying to get my head around the cabal "v2" CLI. At present I'm wondering if it has any implications for how package dependencies are referenced in a .cabal file? I think the traditional advice is to mention the package name along with version bounds, e.g. "base >=4.13 && <4.14". But with Stack, the version bounds are obviated (right?) by the use of a resolver.
13:40:42 <dgpratt> Perhaps it would be better to ask: what are the implications of mentioning a package dependency without explicit version bounds in the "build-depends" section of a .cabal file? And does it matter if the "v2" commands are being used?
13:42:01 <sm[m]> dgpratt: it’s usually considered good practice to specify the dependencies even if using stack
13:43:00 <merijn> dgpratt: Not mentioning them will pick the latest version of every package and probably break billions of times as new versions come out
13:44:16 <merijn> dgpratt: v2-build doesn't meaningfully affect the bounds resolution at all (well, it does a bit in that it's now more predictable which versions it will select, the previous build approach would try and use whatever you already had installed, which is a recipe for confusion)
13:45:31 <pie_> since yall are obviously the sanest programmers i know
13:45:40 <pie_> i think i might accidentally a java job
13:46:18 <pie_> but I dont actually know java yet. ive used it, but im not productively comfortable with it. do you guys have any pointers for what material to start with?
13:46:42 <younder> pie don't worry plenty of us irrationals here. Don't count on us though ;)
13:46:47 <dgpratt> thanks sm[m] , merijn -- it sounds silly perhaps, but I appreciated that Stack gave me one less thing to figure out when referencing a package
13:47:00 <sm[m]> merijn: more precisely it’d usually pick the latest versions of things as of last time you did cabal v2-update, and also potentially could pick very old versions when it feels the need, am I right
13:49:10 <merijn> dgpratt: With cabal-version 2.0 You can use the ^>= syntax for bounds whith "foo ^>= 2.3" being "every foo package that's PVP compatible with 2.3"
13:49:31 <dgpratt> oh, gtk thanks merijn 
13:50:09 <sm[m]> dgpratt: not silly, but it’s valuable information that helps make a package more buildable and portable.. you don’t have to do it perfectly though. Good to specify accurate minimum bounds, and (arguably) the next major version as upper bound, especially for base and for all packages which change their api often
13:50:39 <dgpratt> what about hpack?
13:50:49 <merijn> dgpratt: It's easy, when you're working on something, just pick the latest version and use that with appropriate PVP bounds
13:51:09 <merijn> Then you can always relax the bounds as new versions come out (if relevant)
13:51:18 <sm[m]> If you like the package.yaml format, use it. It’s recommended to also commit the cabal file though
13:52:23 <dgpratt> ok, thanks
13:52:50 <younder> yaml and haskell are nor friends. You have to go through contusions to parse one.
13:53:26 <younder> same with JSON
13:58:36 <Bish> does haskell have it's own compiler for LLVM IR or does it also use the llvm code generator?
13:59:34 <dgpratt> I feel like I've seen a project somewhere that does something akin to "package-lock.json" of NPM fame. Thought that might be hpack, but now I think not.
14:00:05 <awpr> there's such a thing as stack.yaml.lock, and IIRC it's not quite settled whether it's best practice to check it in
14:01:48 <wavemode_> Bish: GHC generates IR, then LLVM translates that to machine code
14:03:18 <Bish> is ghc special in that regard? i don't see many projects generating IR directly
14:03:53 <younder> Love that LVM. Once upon a time I thought I would spend a great amount of time on the optimizer. No. LLVM. Just make a code block tree and it does it for you.
14:04:12 <younder> LLVM
14:04:18 <Bish> well the optimizing process comes after IR, right?
14:04:24 <frdg> Is it common to write a definition for `sequenceA` when making Traversable instances or is `traverse` sufficient?
14:04:33 <dgpratt> I suppose it's perhaps misguided for me to try to Haskell without Stack
14:04:43 <merijn> dgpratt: Why?
14:05:00 <merijn> frdg: The docs should list the "minimal complete definition"
14:05:01 <L29Ah> Bish: both
14:05:14 <dgpratt> just because I seem to be looking for Stack-like functionality outside of Stack...seems kind of silly
14:05:15 <Tuplanolla> I don't know if it's common, but writing both can improve performance, frdg.
14:05:30 <Bish> i was about to learn STG by writing my own FP mini language (educational purpose)
14:05:30 <frdg> Tuplanolla: ok thanks
14:05:40 <merijn> dgpratt: Which functionality is that?
14:05:44 <Bish> but immediatly lost motivation, when i saw those cpp stuff i have to use?
14:06:31 <EvanR> LLVM C++ is a bummer...
14:06:39 <EvanR> but it has haskell bindings
14:06:50 <Bish> hm
14:07:30 <dgpratt> merijn: I suppose the ergonomics of being able to mention package dependencies without dealing with version bounds but still being able to easily "lock in" on whatever I happen to be currently using
14:07:32 <frdg> Merijn: Right. You got a shout out in "Haskell Programming From First Principles", for making a function I do not understand point free!
14:08:32 <Tuplanolla> You can praise LLVM all you want, but using it still feels like filling out tax forms.
14:08:49 <[exa]> what's the name of the lightweight llvm that was somewhere out there
14:09:07 <awpr> I don't know but I would have definitely named it lllvm
14:09:51 <EvanR> libjit
14:09:54 <merijn> dgpratt: That only works if you expect no one else to use your package ;)
14:10:13 <EvanR> C library 
14:10:42 <dgpratt> that's a very reasonable expectation at this point merijn :D
14:10:45 <merijn> frdg: Really? I should tell my SO to check in her copy :p
14:11:15 <dgpratt> I'm not even sure what my package is going to do yet :P
14:11:36 <frdg> merijn: page 1267 if were being precise
14:11:43 <L29Ah> 00:10:21]<dgpratt> that's a very reasonable expectation at this point merijn :D
14:11:44 <L29Ah> then just use `ghc --make`
14:11:59 <L29Ah> no package = no problem
14:11:59 <wavemode_> man, that book has gotten long
14:12:00 <sm[m]> dgpratt: :)
14:12:40 <sm[m]> It was never not long :)
14:13:22 <wavemode_> that's like saying a person was never young :p
14:13:28 <wavemode_> in any case, it was incomplete when i read it
14:13:49 <sm[m]> yup I feel like it was born as a huge tome. I could be wrong :)
14:14:08 <younder> If at first you cant' connect try, try a SWIG.
14:14:09 <merijn> The very first draft I saw was already >500 pages and that was at like 1/3 finished :p
14:14:34 <srid> Cale: `deriveJSONGADT` derives `ToJSON (Foo a)` instances; is there a way to automatically derive `ToJSON (Some Foo)`?
14:16:13 <younder> Hskell is lazy and you should be too. Try conecting to a lib that does close to what you want rather than reinvent the weel
14:18:20 * srid uploaded an image: image.png (40KB) < https://matrix.org/_matrix/media/r0/download/matrix.org/KBaIVCBDJdpDyozCUrsvdOFX >
14:18:25 <srid> I suppose I could manually case dispatch like this.
14:22:47 <srid> Hmm, `decode . encode = Nothing`. That's no good
14:23:24 <srid> Oh, nevermind. Had to specify the type
14:23:38 <srid> (funny how `decode` worked on the ghci repl without complaining about ambiguous types)
14:24:37 <sm[m]> ghci is an outlaw!
14:25:09 <dolio> That one isn't ambiguous.
14:25:27 <dolio> `decode . encode :: a -> Maybe b`.
14:25:50 <srid> It is ambiguous on what `b` actually is.
14:27:01 <dolio> That gets defaulted.
14:27:03 <monochrom> Perhaps it was not literally as simple as "decode . encode"
14:27:30 <monochrom> Hell, the literal equation "decode . encode = Nothing" doesn't even type.
14:30:23 <srid> Oh, hmm: https://github.com/obsidiansystems/dependent-sum-aeson-orphans/blob/develop/src/Data/Dependent/Sum/Orphans.hs#L36-L37 
14:30:26 <monochrom> Not to mention that "a -> Maybe b" is also at most figure-of-speech.  That type if taken literally and seriously would mean it had nothing to do with ToJSON or FromJSON.
14:31:14 <monochrom> This is what's wrong with humans. They can't make up their mind whether they are telepathic or not.
14:36:15 <MarcelineVQ> 60% of the time I'm telepathic every time
14:37:39 <younder> MarcelineVQ, you sounde like a Machine AI..
14:39:20 <MarcelineVQ> bleep blorp
14:45:45 * hackage byte-count-reader 0.10.0.0 - Read strings describing a number of bytes like 2Kb and 0.5 MiB  https://hackage.haskell.org/package/byte-count-reader-0.10.0.0 (danielrolls)
14:53:28 <shapr> I made a fun silly thing in Haskell this weekend!
14:53:29 <shapr> https://github.com/shapr/sandwatch/
14:57:38 <MarcelineVQ> that's pretty cool really
14:59:27 <shapr> MarcelineVQ: try it out, report any bugs/issue/improvements ?
14:59:39 <shapr> It should really be a shell plugin, but I like writing Haskell more
14:59:44 * hackage brick 0.54 - A declarative terminal user interface library  https://hackage.haskell.org/package/brick-0.54 (JonathanDaugherty)
15:05:44 <fishooter> How would go about designing following? Suppose that you have a GameState, and a function
15:05:47 <fishooter> legalMoves :: GameState -> Moves
15:05:48 <fishooter> You'd like to have different implementations of legalMoves for different games, i.e. GameState can be a state of different games. You could do something like this:
15:05:51 <fishooter> data GameState = { game :: String, board :: Array }
15:05:57 <fishooter> and do pattern-matching as a dispatcher
15:05:57 <fishooter> legalMoves GameState {game="chess", board=b) = chessLegalMoves b
15:05:57 <fishooter> legalMoves GameState {game="go",    board=b) = goLegalMoves b
15:05:57 <fishooter> legalMoves GameState {game="poker", board=b) = pokerLegalMoves b
15:06:01 <fishooter> but how to do it nicely in general? So that when you add a game, you add to a list of games, and this dispatching will be done automatically, because you conform to a game "interface"? Also, different games will need different representations of state -- in poker, you don't have a board, but you have hand cards.
15:06:18 <L29Ah> fishooter: in general you don't do it since the amount of legal moves is huge
15:06:40 <fishooter> no it's not, for a given board it is small.
15:06:47 <L29Ah> so consider isLegal
15:07:03 <fishooter> that's not the point of the question :)
15:07:29 <fishooter> in C++ you could use templates for this
15:07:41 <fishooter> I was wondering how to go about doing it in Haskell
15:08:03 <L29Ah> > but how to do it nicely in general?
15:08:04 <L29Ah> typeclass?
15:08:05 <lambdabot>  <hint>:1:12: error:
15:08:06 <lambdabot>      Unexpected do block in function application:
15:08:06 <lambdabot>          do it nicely
15:08:37 <L29Ah> you have different gamestate types for different games that implement the typeclass method legalMoves differentl
15:09:55 <wavemode_> fishooter: functions are values. so your record could be `GameState = { game :: String, board :: GameBoard, evaluator :: GameBoard -> LegalMoves }`
15:10:12 <solonarv> I still don't like that
15:10:28 <solonarv> you are using the same type ('GameBoard') for all games, which is just not correct
15:10:41 <fishooter> I think type classes could be a way to go
15:10:46 <merijn> Noooo
15:10:55 <solonarv> they are, but you don't need a typeclass
15:10:59 <fishooter> Let's consider that you also have GameMove
15:11:01 <sm[m]> and nix
15:11:06 <fishooter> which depends on the Game
15:11:15 <fishooter> how would you tie the individiual states with moves?
15:11:48 <merijn> fishooter: You can just define a record parameterised over a specific gameboard/gamestate
15:12:27 <fishooter> merijn: but what if each game needs different representation of state?
15:12:42 <merijn> That's why you parameterise it...
15:12:44 <fishooter> in go you have a board, in poker cards, in scrabble letters ...
15:12:45 <solonarv> you could do something like: data GameDefinition state = GameDefinition { gameName :: String, gameStartingState :: state, gameMoves :: state -> [state] }
15:12:59 <solonarv> (here we don't even have a separate type for moves!)
15:13:56 <wavemode_> yes if you're looking for maximum flexibility, the evaluator function should simply be a member of the record
15:14:06 <wavemode_> avoid typeclasses for such simple polymorphism
15:14:14 <dgpratt> regarding my earlier inquiry, what about "cabal freeze"? can I just add a bare package reference to the .cabal file and "freeze" it to whatever version it gets?
15:16:08 <solonarv> the for chess you could have a bunch of definition like: data ChessColor = White | Black; data ChessPiece = King | Queen | ...; data ChessState = ChessState { chessBoard :: Array8x8 (Maybe (ChessPiece, ChessColor)), chessCurrentPlayer :: ChessColor }
15:17:18 <solonarv> and finally a definition like chess :: GameDefinition ChessState; chess = GameDefinition { gameName = "Chess"; gameStartingState = <starting piece positions>; gameMoves = <rules of chess here> }
15:18:04 <solonarv> dgpratt: yes, you can do that (the cabal freeze thing)
15:18:20 <solonarv> I d still recommend writing down actual version bounds in the cabal file, though
15:18:32 <L29Ah> cabal: unrecognised command: thaw (try --help)
15:18:32 <solonarv> you can run 'cabal gen-bounds' to generate some conservative bounds
15:19:23 <fishooter> solonarv: ok I think that makes sense, thank you :)
15:21:36 <solonarv> of course you could also get a bit fancier, like adding another 'player' type parameter to GameDefinition and functions to ask whose turn it is or who the winner is
15:21:37 <dgpratt> thanks solonarv
15:23:33 <fishooter> solonarv: a quick follow-up: Suppose that you have a large existing codebase with many functions and algorithms, now they will all need to change signature "GameDefinition s"
15:23:50 <fishooter> is it possible to avoid this, or this has to propagate through all the code?
15:24:11 <solonarv> it *is* possible, but IMO it's more trouble than it's worth
15:24:23 <fishooter> how?
15:24:24 <solonarv> just change the code. GHC will tell you what needs changing, you can't miss anything.
15:24:33 <fishooter> suppose it's a very big library :)
15:24:52 <solonarv> I think there are some refactoring tools that can automate some of this process
15:25:13 <solonarv> if it's a big library that just means you don't do this sort of change unless it's really worth it
15:25:56 <fishooter> aside from refactor etc., how would it be possible?
15:26:27 <solonarv> you're asking how you could "hide" that sort of change from the rest of the library?
15:26:37 <fishooter> yes
15:26:47 <wavemode_> what sort of code changes are you worried about? you shouldn't need to change the code except in places that directly deal with the changed field
15:26:58 <wavemode_> in which case you would certainly want to do it by hand
15:27:03 <solonarv> you could do it by adding a type synonym that wraps the new type, and maybe a huge pile of wrapper functions depending on what exactly the change is
15:27:13 <solonarv> but for this concrete example, you are mostly changing type signatures
15:27:42 <fishooter> I'm just interested in the "how" that solonarv mentioned
15:29:36 <fishooter> the question is sort of about how to hide "context" of some parts of the library -- like I said, I could propagate all the changes, not changing any functionality whatsoever, but I'd have to change many signatures
15:29:36 <fishooter> and I'd rather avoid that
15:29:46 <dgpratt> whereas I'm wishing to Haskell on a Windows machine, I'm fairly pleased with the options I have with WSL 2 plus VS Code "remote"...
15:29:58 <solonarv> you could start with something like: sed -i 's/GameDefinition [[:lower:]]+ /& player/' **/*.hs
15:29:59 <fishooter> >  adding a type synonym that wraps the new type
15:30:01 <lambdabot>  <hint>:1:10: error: parse error on input ‘type’
15:30:18 <solonarv> that will probably change most of the type signatures automatically, if they *can* be changed automatically
15:31:12 <dgpratt> but there is just ONE thing I wish would work, but seems not to: I'd like to be able to play around with working in a nix-shell environment, but I don't think I can setup VS Code remote to work in that :(
15:31:35 <fishooter> so something like GameStateChess = GameState ChessState? 
15:31:35 <fishooter> that's not quite what I had in mind
15:32:13 <solonarv> hrm
15:32:26 <solonarv> honestly I don't think there's even a good way of writing that type synonym in this example
15:32:30 <solonarv> just do the damn refactoring!
15:32:32 <dgpratt> seems when VS Code is launched from WSL, it starts the VS Code UI in Windows, which turns around and starts the VS Code server thingy in WSL
15:32:59 <dgpratt> by which point the context of the nix-shell environment is lost
15:34:09 <srid> GADTs https://haskell.zettel.page/5956fd49.html
15:34:24 <wavemode_> fishooter: Is this some feature another language has which you're looking for in haskell?
15:34:39 <fishooter> Ok, I think it's time to reveal my cards ;-) I find that thinking in "Haskell" makes much nicer designs also in other languages. The changes that I need touch a C++ library, and implementing this "polymorphism" would require extensive use of templates, which are notoriously known to be difficult to work with. 
15:34:39 <fishooter> I'd like to avoid precisely that, and I was wondering if there would be a way to imitate that in Haskell as well.
15:35:40 <fishooter> the other way to go about it is to use static_cast<> 
15:36:45 * shapr checks the channel name
15:36:46 <shapr> wait what?
15:36:51 <sm[m]> +1 for prototyping in haskell
15:37:00 <shapr> oh ok
15:37:24 <sm[m]> in your mind at least :)
15:40:06 <fishooter> yes, I'm just using Haskell for prototyping
15:40:06 <fishooter> because it's much nicer
15:44:10 <dgpratt> what do Haskellers use for code editing these days? guessing vim or emacs with syntax highlighting at most, perhaps also something like ghcid?
15:45:27 <solonarv> I've spent the last 5 or so years procrastinating on "get proficient with vim", so I'm just using VSCode at the moment actually
15:45:55 <sm[m]> emacs + ghcid for getting work done
15:46:18 <dgpratt> solonarv: you using any Haskell extensions beyond syntax highlighting?
15:46:29 <solonarv> not at the moment, no
15:46:34 <Welkin> I used to be like you
15:46:42 <Welkin> but then I took an arrow... wait, that's not right
15:46:56 <solonarv> I don't even use ghcid, I just forget to start it
15:47:08 <Welkin> I fully bought into the emacs-as-ide mindset
15:47:12 <Welkin> now I use doom-emacs
15:47:13 <Welkin> it's amazing
15:47:20 <Welkin> I have lsp-mode set up for all languages
15:47:40 <Welkin> the language servers some times break... but that's how it goes
15:48:06 <solonarv> yeah, I tried language servers a few times but there was always some issue
15:48:36 <solonarv> I'm not opposed to the idea or anything, I just can't be arsed to do the troubleshooting :)
15:48:37 <Welkin> the one thing I don't use emacs for is debugging. I have to use the browser debugger (for js) which sucks, or use intellij or vistual studio (haven't actually tried doing that yet) for java or dotnet
15:48:46 <dgpratt> had not heard of doom-emacs, will check that out
15:49:07 <Welkin> doom-emacs has its own declarative package manager and configuration system
15:49:12 <Welkin> it's like nix for emacs
15:50:03 <dgpratt> at first glance it reminds me a bit of spacemacs, which I like "in theory"
15:50:14 <Welkin> it's better than spacemacs
15:50:36 <Welkin> it took me some time to get used to it, but it's not that different from using normal emacs
15:50:39 <fishooter> sorry my internet is crap
15:50:44 <Welkin> it has some wrapper macros over use-package and others
15:50:49 <monochrom> I use emacs with haskell-mode.
15:51:20 <fishooter> solonarv: any suggestions beside the propagation of polymorphism?
15:51:26 <Welkin> lsp-mode works fine with ghcide
15:51:36 <monochrom> haskell-mode and dante have pretty much the same features.
15:51:38 <Welkin> I haven't tried brittany for formatting
15:52:11 <Welkin> I had to disable go-to-definition in haskell-mode so I could use the lsp-mode way
15:52:12 <solonarv> I guess you'll have to bite the bullet and go with some overly-general "game state" type that tries to encompass all games in one datatype
15:52:15 <monochrom> And both have the same benefit of not needing the permission of cabal or stack to install.
15:52:25 <Welkin> dante is dead
15:52:36 <Welkin> everything is converging on lsp
15:52:53 <Welkin> I couldn't even get dante to work
15:52:54 <monochrom> haskell-mode was said to be dead, too.  Then it came back with a new release.
15:53:03 <Welkin> haskell-mode is not great
15:53:14 <Welkin> it should only be concerned with syntac highlighting
15:53:19 <monochrom> Well I couldn't get any of the heavy-weight lsp ghcide etc to work.
15:53:28 <Welkin> monochrom: try doom emacs and it will work
15:53:39 <monochrom> I couldn't get doom emacs to work.
15:53:46 <fishooter> solonarv: ok, that was indeed one of the options I considered. Thanks!
15:53:46 <Welkin> with one small fix in your config 
15:53:52 <monochrom> Why are you arguing against me.
15:53:58 <Welkin> (map! :after haskell-mode :map interactive-haskell-mode-map "M-." nil)
15:54:08 <Welkin> if you can't get it to work, ask for help on the discord
15:54:11 <Welkin> the author helps you
15:54:37 <monochrom> No thanks, vanilla emacs and haskell-mode work for me already, I'm a happy camper.
15:54:52 <monochrom> If you can't get vanilla emacs and haskell-mode to work, ask in #haskell.
15:55:00 <Welkin> that's what I thought for years, then I saw the light
15:55:24 <Welkin> I used to be happy with just basic syntax highlighting. I used emacs like a glorified notepad
15:55:28 <sm[m]> return to the true light you sinner !
15:55:43 <Welkin> now I can't deal with anything less than having all the IDE features enabled and auto-formatting
15:55:58 <monochrom> Really my real purpose here is to expose how you just like to trash every other options that you don't use.
15:56:07 <Welkin> but that may have something to do with working in multi-million line java and javascript codebases
15:56:29 <Welkin> it's impossible without an IDE
15:56:31 <Welkin> it really is
15:56:41 <monochrom> If someone answers the asker "here is a 2nd option for your consideration" you just start telling people to take you as dictator.
15:56:45 <Welkin> for the small projects I used to work it, it was not a problem
15:57:29 <sm[m]> Welkin: didn’t you try JetBrains tools ? They are best IDE I feel
15:58:16 <parsnip> hmm, should i represent holidays as a record type, so i can associate date, string, etc?
15:58:35 <parsnip> hmm, i only need date, nm
15:58:37 <Welkin> I use intellij at work for debugging java. It's fine for that. It sucks for text editing compared to emacs _ lsp
15:58:38 <monochrom> What are holidays? I'm serious.
15:58:41 <Welkin> emacs + lsp
15:59:04 <parsnip> i mean the paid days off at my employer
15:59:05 * sm[m] uses both, but mostly sticks with emacs to save ram
15:59:28 <monochrom> Haha how time has changed. "emacs to save ram"
15:59:44 <parsnip> eight megs and constant swapping
15:59:44 <sm[m]> Yup. Lean and mean emacs!
15:59:44 <solonarv> you really just need a date? then you probably don't need a separate type at all, or I'm not sure what you'd need it for
15:59:46 * hackage yeshql 4.2.0.0 - YesQL-style SQL database abstraction (legacy compatibility wrapper)  https://hackage.haskell.org/package/yeshql-4.2.0.0 (TobiasDammers)
15:59:48 <monochrom> emacs used to be the way to waste ram
16:00:01 <monochrom> and to waste disk space
16:00:05 <parsnip> i think i was imagining just for easier debugging, reading
16:00:09 <Welkin> I run emacs as a daemon on my desktop machine, which is in the office, and I connect remotely over ssh. I need 64 GB of RAM to run my dev environment and the 6 cores (at least) that the desktop has
16:00:24 <Welkin> I've been working exclusively over ssh in emacs since march
16:00:39 <Welkin> can't get into the office if I wanted to
16:00:45 * hackage yeshql-postgresql-simple 4.2.0.0, yeshql-hdbc 4.2.0.0, yeshql-core 4.2.0.0 (TobiasDammers): https://qbin.io/aids-danish-w7xe
16:01:19 <Welkin> the only thing I can't do is debug th code. Dap-mode is broken as hell, or I don't understand how to set it up or use it.
16:02:09 <dgpratt> I wonder if there is a way to run emacs in a similar setup to VS Code "remote"? e.g. run the editor in Windows, but the engine/language server/whatever in WSL?
16:02:17 <Welkin> emacs is a huge pain in the ass until you configure it exactly the way you want it. doom emacs gets you 9%% of the way there out of the box
16:02:29 <Welkin> then you can't use anything other than emacs
16:02:30 <monochrom> I think no.
16:02:44 <Welkin> 95%
16:04:29 <solonarv> dgpratt: you could always jury-rig it with ssh, I suppose
16:05:22 <dgpratt> there are also options like VcxSrv, but I've tried that with e.g. spacemacs and was having some font-loading problems (seems emacs is kind of old-school in the way that it loads fonts? not surprising if true, I suppose)
16:05:56 <monochrom> Oh, maybe you run emacs remotely, and use MobaXTerm's X forwarding...
16:06:13 <sm[m]> Welkin: still a pain when it breaks under you but still worth It
16:09:48 * sm[m] has switched to daemon + terminal emacsclients only, can recommend
16:12:55 <sm[m]> Two daemons, in fact. But I’m getting off topic
16:15:03 <monochrom> ghci is underrated. It has commands for "what's the type of the expression in this source code region". It has commands for goto-definition. These work for local expressions and definitions too.
16:15:37 <monochrom> By extension, haskell-mode and dante are underrated, because they simply use those ghci commands to provide those features.
16:17:01 <monochrom> You could even use those commands yourself, though with tedium, so it's best to let haskell-mode or dante issue the command.
16:17:27 <shapr> ghci has :force !
16:17:29 <monochrom> This is why I can do fine with emacs and haskell-mode.
16:17:33 <shapr> you can use the :force in Haskell!
16:19:21 <monochrom> and auto-completion. same story. ghci can do it, haskell-mode and dante issue the command.
16:23:15 * hackage ginger 0.10.0.3 - An implementation of the Jinja2 template language in Haskell  https://hackage.haskell.org/package/ginger-0.10.0.3 (TobiasDammers)
16:28:13 <parsnip> wow, this holiday package appears to be utter garbage
16:28:36 <parsnip> first they write a function "firstMondayIn", then they write a function "firstThursdayIn" which just adds three days
16:29:32 <Welkin> just use the BSD cal program
16:29:38 <Welkin> and parse the text output
16:29:42 <Welkin> save yourself the trouble
16:30:24 <parsnip> "just"
16:30:29 <hexagoxel> I wonder if we will get auto-completion in combination with RecordDotSyntax.. "foo.myF<tab>" -> "foo.myField". And more importantly "foo.<tab>" -> list of fields
16:31:34 <Welkin> I haven't been following the developments with record dot syntax
16:31:51 <Welkin> but f# already has it
16:32:03 <Welkin> If only haskell handled records like f# or elm from the beginning
16:32:57 <wavemode_> there's https://hackage.haskell.org/package/record-dot-preprocessor
16:33:22 <Welkin> I haven't actually written any haskell in well over a year
16:33:34 * hexagoxel dreams about LensDotSyntax and "foo.<tab>" -> list of lenses
16:33:48 <Welkin> I'm disappointed by the lack of progress in the web area in the last 4 years
16:34:53 <Welkin> but then, the purpose of haskell isn't to be a production language, so I can't really fault it I guess
16:35:36 <Welkin> the focus of the last 4 years seems to have been solely on making the type system as complicated as possible, adding in evertyhing but the kitchen sink
16:35:55 <Welkin> it's the C++ (or Common Lisp) of ML
16:36:09 <parsnip> concise link?
16:36:17 <Welkin> ?
16:37:31 <parsnip> Welkin: can you point me to the changes in last four years to the type system, that is more complicated? or would it take four hours of reading to get the gist of it?
16:38:00 <Welkin> this is a summary based on my recollection over the last many years
16:38:13 <Welkin> there is no blog post on this
16:38:36 <parsnip> :)
16:38:50 <parsnip> youtube or it didn't happen
16:39:08 <Welkin> the big ones are: TypeInType, literals in types, type operators (around 2015/2016, used heavily in servant), dependent type things, linear type things, messing with overloading record syntax, etc
16:39:56 <Welkin> it has become more and more complicated to write haskell as the years have gone by, with many libraries requiring huge lists of compiler pragmas to turn on fancy new features just to get it working
16:40:08 <parsnip> TypeInType is deprecated, i guess
16:40:12 <Welkin> what?
16:40:32 <parsnip> The extension TypeInType is now deprecated: its sole effect is to switch on PolyKinds (and hence KindSignatures) and DataKinds.
16:40:44 <Welkin> okay
16:41:08 <Welkin> see what I mean? It changes so fast
16:41:17 <parsnip> yikes. idk
16:41:18 <Welkin> that's the whole point of haskell though
16:41:27 * parsnip runs away screaming
16:41:32 <parsnip> sure
16:41:36 <Welkin> it's a research language at heart, meant for pushing the boundary of prgramming language research
16:41:42 <parsnip> it's a research language for very smart people
16:41:45 <Welkin> it spawned my favorite languages ever
16:41:47 <parsnip> :)
16:41:51 <wavemode_> recorddotsyntax did pass committee vote
16:41:55 <Welkin> I still love haskell, but I don't use it much any more
16:42:26 <parsnip> i've very rarely used it, but decided on it for a small hobby puzzle i assigned myself
16:42:50 <Welkin> I used it in production for several years for small client projects and for my own products
16:42:59 <parsnip> it's the tersest language i have any experience with
16:43:08 <parsnip> most expressive, etc
16:43:29 <parsnip> i might like to learn f# later, but i'll just start with haskell for now
16:43:43 <Welkin> Elm is still my favorite language, but F# has replaced haskell as second place
16:43:45 <parsnip> i first want to see how easy this puzzle is in haskell
16:43:50 <Welkin> it may surpass Elm at some point for me
16:44:09 <parsnip> and for jvm, what is your favorite haskell-like thing
16:44:14 <Welkin> there is none
16:44:17 <parsnip> :)
16:44:57 <Welkin> luckily, java is slowly becoming more like the ML languages we love. It's getting anaonymous records and pattern matching
16:45:39 <parsnip> yeah, and f# has influenced c#, iiuc
16:45:57 <Welkin> I guess eta-lang is the closest. It's a fork of GHC that works with the jvm
16:46:10 <Welkin> it's literally haskell on the jvm
16:53:58 <koz_> :t toEnum
16:53:59 <lambdabot> Enum a => Int -> a
17:02:28 <parsnip> > print "in space, noone can hear you scream"
17:02:31 <lambdabot>  <IO ()>
17:17:15 * hackage calamity 0.1.9.4 - A library for writing discord bots  https://hackage.haskell.org/package/calamity-0.1.9.4 (nitros12)
18:07:02 <dgpratt> trying to get started with doom-emacs in the last hour has been an interesting experience :)
18:09:09 <dgpratt> "doom install" produced an inscrutable (to me) error, and my bing-fu was not much use; but 10 minutes on discord and "Henrik" (the maintainer I think?) is trying to resolve the issue :)
18:12:09 <monochrom> Wetware installer.
18:15:14 <ja> Welkin: there is Frege?
18:16:07 <ja> i wonder how hard it would be to get frege running in libreoffice
18:23:13 <sm[m]> return to the light, dgpratt!!
18:28:35 <sm[m]> or at least, grab the super shotgun!
18:32:34 <srid> Has anyone encountered this with when working postgres jsonb types? (in beam):
18:32:37 <srid>   Exception: BeamRowReadError {brreColumn = Just 1, brreError = ColumnUnexpectedNull}
18:32:58 <srid> Odd error when no column is actually null, and the json is valid
18:35:52 <liiae> is there's a function to tell us f is which function's fixed point?
18:36:18 <liiae> like we know f, how we to get g, which f = fix g
18:37:23 <wavemode> that seems like more of an algebraic problem than a computable one
18:38:19 <liiae> if we do fixed point to instead of recursion, that's not the way?
18:38:31 <liiae> find the target function is which one's fixed point
18:38:43 <liiae> f x = g f x
18:38:53 <koz_> How do Stackage packages go from being nightly to being in an LTS?
18:39:02 <koz_> Like, is there some application process?
18:42:03 <wavemode> liiae, so you are looking for some function `unfix` such that if `f = fix g` then `unfix f` evaluates to `g` ?
18:42:25 <liiae> wavemode: that's right, is there unfix?
18:43:24 <wavemode> sorry but it doesn't exist. (and I believe is impossible, on account of it being more complex than the halting problem...)
18:44:20 <liiae> > let f2 n accum = if n == 1 then accum else f2 (n-1) (n * accum) in f2 10 1
18:44:21 <lambdabot>  3628800
18:44:39 <liiae> if f2 = fix f3
18:44:45 * hackage typed-encoding 0.4.0.0 - Type safe string transformations  https://hackage.haskell.org/package/typed-encoding-0.4.0.0 (rpeszek)
18:45:28 <liiae> then we can get `f2 n accum = if n == 1 then accum else f3 f2 (n-1) (n * accum)` right?
18:45:52 <liiae> did I misunderstand about fixed point on recursion?
18:48:42 <liiae> wavemode: did I?
18:51:13 <awpr> "un-fixed-pointing" a function doesn't have a unique result -- e.g. for any `f`, `fix (const f) === f`
18:53:03 <liiae> yeah, const x 3, 3 is the only fixed pint here
18:54:50 <liiae> awpr: do I misunderstand about fixed point on recursion?
18:55:01 <awpr> I don't know?
18:55:22 <liiae> :)
18:56:00 <parsnip> is "distance" an decent name for (\x y) -> y - x `mod` 7... it's what i'm adding to get for example the first Monday of a month
19:30:02 <suzu_> dayDistance maybe?
19:30:10 <suzu_> naming stuff is hard
19:55:53 <liiae> anyone can help me to find f2's unfix function?
19:56:05 <liiae> f2 n accum = if n == 1 then accum    else f2' f2 (n-1) (n * accum)
19:56:11 <liiae> f2 = fix f2'
19:56:20 <liiae> how to get f2'
19:56:25 <liiae> through f2
20:05:43 <monochrom> It is a pretty mechanical process.  My http://www.vex.net/~trebla/haskell/fix.xhtml may inspire you.
20:26:02 <sooch> join #haskell
20:31:41 <dmwit> parsnip: For what it's worth, "distance" seems like a bad name to me, because that's not a metric. https://en.wikipedia.org/wiki/Metric_(mathematics)
20:32:48 <suzu_> sooch: worked
20:56:07 <parsnip> hmm, okay
20:56:25 <parsnip> i can't seem to find anything that can go here: parseICalendarFile ??? "holidays.ics"
20:56:45 * hackage wai-extra 3.0.29.2 - Provides some basic WAI handlers and middleware.  https://hackage.haskell.org/package/wai-extra-3.0.29.2 (MichaelSnoyman)
20:56:52 <parsnip> for https://github.com/chrra/iCalendar/blob/master/Text/ICalendar/Parser.hs#L36
20:57:16 <parsnip> er, https://github.com/chrra/iCalendar/blob/master/Text/ICalendar/Parser.hs#L59
21:06:01 <parsnip> hmm
21:06:04 <parsnip> this worked
21:06:05 <parsnip> parseICalendarFile (DecodingFunctions TE.decodeUtf8 (CI.mk . TE.decodeUtf8)) "holidays.ics"
21:06:26 <parsnip> but i'm not sure how i could have avoided copy/pasting that entire expression in the middle
21:08:35 <parsnip> seems like i should be able to leverage `instance Default DecodingFunctions where`
21:10:14 <awpr> yep, use `def`; it's exported by `Data.Default.Class`
21:10:17 <dmwit> Sure, you can just write `parseICalendarFile def "holidays.ics"`.
21:10:35 <dmwit> def is defined to be that gobsmacking great chunk of code you pasted above
21:12:18 <monochrom> If "default" meant what it was meant to meant (i.e., ask a banker, seriously), it would have type "forall a. Maybe a" and its value would be Nothing.
21:13:15 <awpr> that's as reasonable an instance of `Default` as any other one
21:15:18 <awpr> `instance Default Void where def = error "this class has no laws so why not"`
21:18:25 <parsnip> ah okay, thanks all
21:21:18 <edwardk> awpr: the general use i think of for Default is as an inhabitedness check. using it for Void makes me deeply uncomfortable.
21:23:37 <oats> edwardk: oh hey, you're that dude! don't think I've had the pleasure of saying hi to you yet. Thanks for your numerous contributions to haskell and the ecosystem :)
21:25:28 * edwardk waves
21:28:40 <suzu_> edwardk: have you seen the recent "simple haskell" post on r/haskell? what are your thoughts?
21:28:41 <la-s> Is there a way to get GHC/Stack to compile on multiple cores? ATM it's using only 1 core, which is pretty slow.
21:29:34 <suzu_> this post: https://www.reddit.com/r/haskell/comments/gok70o/simple_haskell_is_best_haskell/
21:30:25 <awpr> edwardk: yeah, I suppose the only thing Default says about a type is that it's inhabited.  or nothing at all, if you accept partial instances
21:31:02 <awpr> I've had so much misery from partial Num instances that I'm tempted to say no instance method should ever be partial unless it has HasCallStack
21:45:37 <edwardk>  awpr:   (/) in particular?
21:45:41 <edwardk> or abs/signum
21:45:50 <edwardk> which are a dumpster fire of their own
21:45:54 <awpr> fromIntegral, (+), and (-) in fact
21:46:05 <edwardk> things like Natural?
21:46:26 <awpr> yeah, an instance that raised errors on out-of-range values
21:46:33 <edwardk> or a non-overflowing int, etc.
21:47:21 <edwardk> sadly i didn't have enough spoons to try to tackle the Num situation when i was working on the whole standards/clc thing.
21:47:31 <edwardk> carter can do it. go carter!
21:47:45 * edwardk ducks
21:48:57 <topos> and emily ;)
21:50:20 <suzu_> edwardk: bump ^
21:52:53 <awpr> I've been waging war against that particular Num instance on and off since November-ish; there's a lot of code to update before I can remove it
21:53:36 <awpr> I doubt anyone would dare write a partial Applicative instance, I think it's just that the special treatment Num gets makes it extremely tempting to define even if it can't be total
21:54:40 <edwardk> topos: =)
21:55:00 <edwardk> i only mentioned carter because Num was a pet peeve of his
21:55:37 <topos> Num is definitely a dumpsterbath
21:55:47 <edwardk> awpr: Num is basically a lawless hellscape, so I don't feel so bad slipping partiality in here and there.
21:55:53 <topos> are you in #numerical-haskell at all?
21:56:05 <topos> that's where the collab will happen when we kick it off this week
21:57:15 <awpr> interesting, didn't know there was an effort so imminent.  I'll go sort out my ident situation so I can join
22:00:10 <quiet_laika[m]> has anyone used megaparsec with a custom token stream?
22:05:23 <koz_> topos: Rofl at 'dumpsterbath'.
22:56:05 <liiae> about fixed point, https://paste.ubuntu.com/p/KvP3jGJkfs/
22:56:38 <liiae> I know how to get g when f = fix g, but when there's let or where sugar, I don't...
22:56:56 <liiae> the parameters number is not right
22:57:54 <liiae> like that my foldl' is a non-recursive version of foldl, but I don't know how to do that with reverse
23:58:16 <kolu> hello guys
23:58:28 <kolu> https://pastebin.com/xpcXrCYZ
23:58:37 <kolu> can someone help me out
23:58:59 <kolu> with this function
23:59:14 <kolu> I want to be able to use either fst or snd as the first argument
