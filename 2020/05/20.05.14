00:36:28 <tdammers> limelier: yeah, it should be fine, worst case you use some configuration. it will lead to massive amounts of recompilation though, and stack will re-download GHC itself
00:36:58 <limelier> alright
00:37:23 <limelier> this time i'm also making sure to only install HIE for the latest ghc
00:47:26 <tdammers> this tickles me the wrong way: cabal --install-method, but --installdir
02:00:00 <Eugleo> Hey! I have a transformer stack of ReaderT ActionT SeldaT, which I'd like to rewrite into one flat newtype. However, most of Scotty's functions (from which the ActionT comes) are writtet as follows: `func :: (ScottyError e, Monad m) => ActionT e m a`
02:00:32 <merijn> Eugleo: Then you'll have to lift them and use your lifted version
02:00:35 <Eugleo> Do I understand correctly that I'm out of luck and have to use ActionT then,
02:01:30 <Eugleo> i.e. I can't do: newtype EAction a = A {runAction :: ReaderT Env (ActionT Lazy.Text (SeldaM PG)) a} 
02:02:08 <Eugleo> And somehow wrangle it to be used in the Scotty's functions (similar to what I'd do with MonadSelda to use the type in Selda's functions)
02:04:04 <Eugleo> (pinging merijn)
02:06:30 <Welkin> EA sports: it's in the game!
02:06:55 <Eugleo> Didn't hear that for quite some time!
02:07:15 <Welkin> EActionÂ® Registered Trademark of EA Games
02:09:17 <merijn> Eugleo: You say you can't do that. Why not?
02:09:44 <merijn> "liftedFunc = A (lift func)" done
02:10:44 <Eugleo> Huh, makes sense
02:12:43 <Eugleo> Not as convenient as having MonadAction derived automatically, but it works. And it's not worse than what I have to do now anyway
02:13:15 <Eugleo> Is there any reason why ActionT isn't abstracted away by Scotty to something like MonadAction or similar?
02:13:37 <Welkin> scotty is pretty basic
02:13:45 * hackage haskoin-store-data 0.29.1 - Data for Haskoin Store  https://hackage.haskell.org/package/haskoin-store-data-0.29.1 (jprupp)
02:13:46 <Welkin> it also hasn't seen a lot of work for many years
02:14:45 * hackage haskoin-store 0.29.1 - Storage and index for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-store-0.29.1 (jprupp)
02:16:25 <Eugleo> I see.
02:16:27 <Eugleo> Thanks for the help
02:40:17 <Eugleo> Well, there seems to be another problem with the translation to newtype
02:43:12 <Eugleo> When trying to get MonadSelda automatically derived, I first need to enable UndecidableInstances, and after that I receive the following error: No instance for (MonadSelda (ReaderT Env (ActionT Lazy.Text (SeldaM PG)))) [...]
02:43:41 <merijn> You need to create all the relevant instances, yes
02:43:43 <Welkin> you have to do something weird with scotty
02:43:55 <Welkin> it's backwards from how it works in other libraries
02:43:59 <Welkin> you wrap is inside out or something
02:45:10 <Welkin> look at Servant for some good guidance on doing a natural transformation from your App type into the monad transformer that the library uses
02:47:14 <Eugleo> merijn: Why didn't they get derived automatically, as opposed to MonadReader for instance?
02:47:27 <Eugleo> Welkin: Will check out, thanks
02:47:38 <merijn> Nothing gets derived "automtically", they all have to be defined "somewhere"
02:48:20 <merijn> You can sometimes use GeneralizedNewtypeDeriving, but then you still have to manually request that
02:48:39 <Eugleo> I did exactly that.
02:48:56 <Eugleo> Does that mean that MonadReader, as opposed to MonadSelda, has some deriving rules defined somewhere?
02:49:26 <merijn> The problem is that it can't newtype derive MonadSelda, because ReaderT is not an instance
02:56:15 * hackage shake-plus 0.1.1.0 - Re-export of Shake using well-typed paths and ReaderT.  https://hackage.haskell.org/package/shake-plus-0.1.1.0 (locallycompact)
02:57:15 * hackage language-css 0.0.3.1 - CSS 2.1 syntax  https://hackage.haskell.org/package/language-css-0.0.3.1 (tomjaguarpaw)
03:14:18 <mkru> Can anyone help me understand why this example hangs https://pastebin.com/SRk8v6uT , however when I replaces name `plansza` in the second let with something else it works?
03:14:32 <mkru> It hangs*
03:16:14 <mkru> If the same name can't be used in the second let, I would at least expect it to report some error, not freeze forever.
03:19:15 * hackage penntreebank-megaparsec 0.2.0 - Parser combinators for trees in the Penn Treebank format  https://hackage.haskell.org/package/penntreebank-megaparsec-0.2.0 (twotrees12)
03:31:08 <z16> I had an assignment to determine the type of the following expression: `let x = 3`
03:31:16 <solonarv> mkru: in 'let plansza = wstaw plansza 2 2 4', the 'plansza' on the RHS refers to the same 'plansza' that you are currently defining
03:31:20 <z16> Is that even an expression? I know `let x = 3 in x` is an expression
03:31:29 <z16> But just `let x = 3` should not return anything, right?
03:31:37 <solonarv> z16: indeed 'let x = 3' is not an expression
03:31:40 <z16> GHCi seems to agree, but what exactly is that, if not an expression?
03:32:12 <solonarv> it can be a statement in a 'do' block
03:32:28 <z16> Hm, I mean, I know what the assignment *meant* by now, they meant the `x` in the `let` statement
03:32:33 <solonarv> (where it is just syntactic sugar for 'let ... in ...')
03:32:41 <maerwald> seems the assignment is wrong then, tell your supervisor
03:32:44 <z16> But I find the question weirdly phrased
03:32:44 <solonarv> yeah, it's a pretty clear guess
03:32:51 <solonarv> you should still raise the issue IMO
03:32:59 <z16> Ok, thank you
03:33:16 <maerwald> I wouldn't even solve it, when the question is clearly wrong
03:33:28 <z16> I thought it was a trick question
03:33:33 <mkru> solonarv: So what is the proper Haskell way? I do not want to introduce new name.
03:33:38 <z16> Since it was just one of several expressions
03:33:52 <z16> So I figured I'd be smart by saying it doesn't return anything :X
03:33:57 <solonarv> mkru: introduce a new name. that *is* the proper haskell way.
03:34:36 <solonarv> z16: if you really want to hedge your bets, you could say something like "this isn't an expression, but in case you meant to ask for the type of 'x', here it is: ..."
03:34:50 <z16> Yeah, should have probably done that
04:58:59 <mniip> interesting, so if we wanted to get rid of extraneous terms in smth like `data LC = App LC LC | Abs (LC -> LC)` , we have to disallow elimination on LC in the body of Abs, which happens automatically if we church-encode the type: `type LC = forall l. (l -> l -> l) -> ((l -> l) -> l) -> l`  in the type of Abs `l` appears rigid so we can't eliminate on it
05:36:32 <Eugleo> I'm trying to write my own MonadSelda instance. Minimum definition is withConnection
05:36:44 <Eugleo> The type: 
05:36:46 <Eugleo> newtype EnvAction a = EA {unEA :: ReaderT Env (ActionT Lazy.Text (SeldaM PG)) a}
05:36:47 <Eugleo>   deriving (Functor, Applicative, Monad, MonadIO, MonadReader Env)
05:36:59 <Eugleo> The instance
05:37:18 <Eugleo> instance MonadSelda EnvAction where
05:37:19 <Eugleo>   type Backend EnvAction = PG
05:37:19 <Eugleo>   withConnection m = EA $ do
05:37:20 <Eugleo>     r <- lift . lift $ (withConnection m :: SeldaM PG a)
05:37:20 <Eugleo>     undefined
05:38:30 <Eugleo> However, the "withConnection m" next to the cast is apparently of type EnvAction a (i.e. a recursive call to myself). How can I use the SeldaM's withConnection there? Or am I misunderstanding something?
05:38:56 <Eugleo> (mentioning you, merijn, as you already helped me with some problems regarding this)
05:40:55 <Eugleo> The error is: Expected type: SeldaM PG a1, Actual type: EnvAction a.
05:51:38 <solonarv> Eugleo: look at the type of 'withConnection'
05:52:50 <solonarv> it's '(SeldaConnection (Backend m) -> m a) -> m a', so in your definition, 'm :: SeldaConnection PG -> EnvAction a'
05:54:34 <solonarv> also, (withConnection m :: SeldaM PG a) isn't a cast; it's a type annotation
05:55:21 <solonarv> (x :: T) doesn't change or set the type of x, or of the whole expression; it can only make the type less general
05:55:30 <solonarv> (which can be useful to remove ambiguity)
05:56:36 <ibloom> Compiled a project with cabal 3.0.0 v2-build, enable-profiling is specified in cabal.project but when I try to use +RTS -p it tells me "the flag -p requires the program to be built with -prof", if I use +RTS -h it creates cabal.hp which is an empty heap profile.
05:56:52 <solonarv> ibloom: what's the full command you ran?
05:57:08 <ibloom> cabal v2-run gudni-benchmarks +RTS -h
05:57:18 <solonarv> ah, I figured it would be something like that
05:57:35 <ibloom> What am I doing wrong?
05:57:39 <solonarv> the '+RTS -h' part gets eaten by cabal and isn't passed to your program
05:57:58 <solonarv> you can use -- to indicate "your arguments end here, pass the rest along verbatim"
05:58:13 <solonarv> like so: cabal run gudni-benchmarks -- +RTS -h
05:58:19 <ibloom> I see.
05:58:29 <solonarv> (note that you don't need the v2-* prefix if you're using cabal >= 3.0)
05:58:44 <ibloom> good to know.
05:59:41 <solonarv> (the -- thing is a common convention, not specific to cabal or the haskell ecosystem)
06:00:05 <ibloom> I see.
06:00:56 <ibloom> Ok that's working great. Thanks for the info.
06:08:41 <Eugleo> solonarv: I though there will be an equivalent withConnection of type (SeldaConnection (Backend SeldaM) -> SeldaM a) -> SeldaM a
06:08:56 <Eugleo> And that PG = Backend SeldaM
06:09:36 <Eugleo> That's why I added the annotation, to specify that I wish it to be of this type (instead of the other possible SeldaConn PG -> EnvAction)
06:10:13 <Eugleo> At least that's what I thought I was doing
06:10:28 <Eugleo> Why can't I use the withConnection specialised to m=SeldaM?
06:14:16 * hackage zipper-extra 0.1.1.0 - Zipper utils that weren't in Control.Comonad.Store.Zipper  https://hackage.haskell.org/package/zipper-extra-0.1.1.0 (locallycompact)
06:21:45 * hackage hpack 0.33.0.1 - A modern format for Haskell packages  https://hackage.haskell.org/package/hpack-0.33.0.1 (SimonHengel)
06:22:56 <lyxia> Eugleo: you can, but you didn't give it something of type (... -> SeldaM a)
06:23:51 <Eugleo> That's true. I'd need to unEA the m and then double-unlift it.
06:24:11 <Eugleo> I solved it, with help, like this
06:24:12 <Eugleo> instance MonadSelda EnvAction where
06:24:12 <Eugleo>   type Backend EnvAction = PG
06:24:13 <Eugleo>   withConnection m = EA $ lift (lift (S get)) >>= unEA . m
06:50:42 <freeman42x[m]1> What is the best way to use a `data` placeholder without using an external library? https://github.com/razvan-flavius-panda/Formalizing-Intelligence/blob/master/main.hs#L3
06:54:05 <lyxia> what's wrong with that code you linked to
06:54:15 * hackage concurrency 1.11.0.0 - Typeclasses, functions, and data types for concurrency and STM.  https://hackage.haskell.org/package/concurrency-1.11.0.0 (barrucadu)
06:55:15 * hackage tasty-dejafu 2.0.0.4, hunit-dejafu 2.0.0.3, dejafu 2.3.0.0 (barrucadu)
07:18:52 <untseac> hello. I'm stuck with something silly. I want to know if two string share the same prefix. Ex. "test1" and "testTT" share "test". Is it possible to do this with takeWhile? 
07:19:41 <untseac> or do I have to pull of my own recursive function?
07:19:46 <enikar> first zip the two strings.
07:20:38 <untseac> @enikar, err I think you already answered by question with just that
07:20:38 <lambdabot> Unknown command, try @list
07:20:46 * hackage mmsyn2 0.1.8.0 - The library that can be used for multiple (Ord a) => a -> b transformations  https://hackage.haskell.org/package/mmsyn2-0.1.8.0 (OleksandrZhabenko)
07:21:15 <untseac> enikar, I think you just answer my question with just that... I knew I was being silly
07:21:17 <untseac> thanks
07:21:18 <enikar> untseac: perhaps with this takeWhile (\(x,y) -> x == y) (zip s1 s2)
07:21:30 <untseac> y that will probably do it
07:24:14 <untseac> fst $ unzip $ takeWhile (\(x,y) -> x == y) $ zip "test1" "test2A"
07:24:21 <untseac> okay this works. thanks, enikar 
07:24:40 <enikar> in this case, a recursive function seems to be more complex.
07:24:57 <enikar> untseac: you're wellcome.
07:25:15 * hackage mmsyn3 0.1.5.0 - A small library to deal with executable endings  https://hackage.haskell.org/package/mmsyn3-0.1.5.0 (OleksandrZhabenko)
07:27:50 <enikar> untseac: notice, a section with (==) avoid the need of the lambda
07:28:11 <enikar> oh, nowâ¦
07:28:40 <enikar> oops. nvm, I was wrong.
07:29:24 <Ferdirand> :t (uncurry (==))
07:29:26 <lambdabot> Eq a => (a, a) -> Bool
07:29:35 <enikar> yes, we need uncurry 
07:30:17 <enikar> my haskell skill is not very good :(
07:31:09 <untseac> yes I don't think haskell has lamdba placeholders by default, like scala
07:31:16 <untseac> but it's not like it needs it
07:32:05 * ski wouldn't want it
07:32:33 <untseac> ski, I can see why, just makes it a lot confusing to newbies
07:32:36 <enikar> I don't know what are placeholders 
07:33:01 <untseac> enikar, allows you to do this: takeWhile (_ == _) s1
07:33:11 <untseac> because the underscores are the arguments
07:33:27 <untseac> hum... did the underscore just disapear?
07:33:33 <ski> nope
07:33:41 <untseac> ok it's my font than
07:33:48 <tdammers> yeah, so (_ == _) would desugar into \a b -> (a == b)
07:33:53 <untseac> y
07:33:56 <ski> (perhaps your client rendered the part inbetween as underlined, though)
07:34:05 <tdammers> but in Haskell you could just write (==)
07:34:11 <tdammers> (in this particular case, that is)
07:35:02 <untseac> we call syntax sugar, syssy stuff, in my country :P
07:35:04 <enikar> untseac: awful, imho.
07:35:35 <untseac> sissy* I think you get it. although syntax sugar is important in some case. just a curiosity.
07:35:49 * ski . o O ( "syntactic salt" )
07:36:08 <opqdonut> :D
07:36:09 <enikar> sections are better.
07:36:26 <tdammers> ski: I like to generalize to arbitrary syntactic seasonings, spices, and condiments
07:36:39 <tdammers> (inb4 "found the lisper")
07:36:52 <ski> (in Mercury, you have to prefix every call to an impure predicate and function (usually when doing FFI wrapping), with the keyword `impure')
07:37:38 <tdammers> ski: they should have syntax sugar for it that allows you to write `I repent' instead
07:37:38 <ski> i'd like to be able to write `(1 + 2 *)'
07:37:56 <Cale> .oO(Syntax bay leaves)
07:37:56 <ski> (it would mean the same as `(1 +) . (2 *)', of course)
07:38:03 <tdammers> haskell makes you return an IO u when writing impure code, which I think is appropriate
07:38:19 <ski> no, that's not a fair comparision
07:38:55 <ski> Mercury (normally) requires you to parameterize your predicates by two I/O states, when doing I/O. but that's not impure
07:39:15 <ski> (Mercury uses uniqueness for I/O, and mutable stuff)
07:39:23 <tdammers> yes, I am vaguely familiar
07:39:29 <ski> better to compare the `impure' stuff to `unsafePerformIO'
07:39:35 <tdammers> I was really just trying to land a pun here
07:41:12 <Boarders_> does anyone know the latest version of ghc that can build ghcide?
07:41:13 <ski> (fwiw, i prefer the `promise_pure' pragma to the `unsafe' prefix. makes it clearer what is the proof obligation)
07:42:31 <ski> (hm, <https://www.mercurylang.org/documentation/papers.html#purity>,<https://www.mercurylang.org/information/doc-latest/mercury_ref/Foreign-language-interface.html> talks a bit about the FFI. the paper compares a bit with Haskell)
07:42:56 <untseac> you know, I find it funny that this new fad of cloud, micro-services, nosql and so on is only really touching a tiny bit of functional because it needs to
07:43:31 <ski> how often have you attempted to write `(f . g .)', but realized you couldn't ?
07:44:16 <ski> (without inserting brackets, rendering it as `((f . g) .)', that is)
07:46:34 <untseac> sometimes, ski. But since I'm still kind of newbie I got a cryptic error and figured after many hours I couldn't do that
07:47:09 <untseac> Boarders_, I usually just use stack for that and let it figure out
07:47:20 <Boarders_> I don't use stack
07:47:40 <Boarders_> seems to build with 8.8 though
07:47:49 <Boarders_> but not 8.10
07:47:57 <untseac> you probably should if you can. It will be a lot less of a painful experience. but I'm using 8.8.3 is the LSP
07:48:09 <untseac> which is*
07:48:52 <Boarders_> I have had enough pain with stack to think that is not the case
07:49:47 <untseac> stack is definitely not perfect. there's no uninstall for example and it's really ugly to the eyes. but not using it is even worse.
07:50:43 <untseac> also I don't like that you have to compile everything (instead of plain old binaries) but I bet someone will start spitting on me if I say that enough times
07:51:15 * hackage mmsyn4 0.2.0.0 - The "glue" between electronic tables and GraphViz  https://hackage.haskell.org/package/mmsyn4-0.2.0.0 (OleksandrZhabenko)
07:52:07 <Guest_37> Anyone able to walk through an exercise with me? I will pay for your time via venmo/paypal
07:52:15 * hackage mmsyn5 0.4.4.0 - Various additional operations on lists (some with intermediate Monads)  https://hackage.haskell.org/package/mmsyn5-0.4.4.0 (OleksandrZhabenko)
07:56:13 <untseac> I dare say maven (or gradle) gives a better experience than stack and maven is full of flaws too. Stack is just what it is. Needs a lot of improvement. Just saying. Maybe I'll try to fix it myself one day.
07:56:54 <untseac> and let me not start with cabal... rant over
07:57:46 * hackage mmsyn6ukr 0.7.2.0 - A musical instrument synthesizer or a tool for Ukrainian language listening  https://hackage.haskell.org/package/mmsyn6ukr-0.7.2.0 (OleksandrZhabenko)
07:58:57 <enikar> stack uses cabal. It is not a replacement.
07:59:19 <untseac> I know but fixes a lot of issues with cabal even if it's just on top of it
08:01:15 * hackage hpack 0.33.1 - A modern format for Haskell packages  https://hackage.haskell.org/package/hpack-0.33.1 (SimonHengel)
08:01:25 <maerwald> untseac: like what
08:02:15 * hackage mmsyn7ukr 0.15.4.0 - A simple basic interface to some SoX functionality or to produce a voice that can be used by mmsyn7h  https://hackage.haskell.org/package/mmsyn7ukr-0.15.4.0 (OleksandrZhabenko)
08:03:09 <Boarders_> has anyone came across this sort of error with ghcide:
08:03:15 <Boarders_> "/usr/bin/ar: dist/build/Control/Monad/Primitive.o: No such file or directory"
08:03:26 <Boarders_> It fails to build primitive which is the only dependency this package has
08:04:15 * hackage strict-tuple-lens 0.1.0.1 - Optics for the `strict-tuple` library  https://hackage.haskell.org/package/strict-tuple-lens-0.1.0.1 (topos)
08:04:28 <enikar> I'm not sure, but it seems stack goal is not to fix issues from cabal. Stack is use to have reproducible build, instead. Thing that cabal is not aware of.
08:04:55 <maerwald> enikar: except... it isn't reproducible
08:05:22 <maerwald> It's a misuse of the term "reproducible"
08:05:31 <maerwald> False advertising, I would even say
08:05:39 <enikar> then, stack misses its goal
08:06:13 <untseac> maerwald, what was improved? stack has a graph of dependencies that work well together and downloads GHC. cabal is more of a "get the latest" kind of thing. I'm aware that was improved over time but still.
08:06:30 <maerwald> Yes. There are some instances in industry to have reproducible builds (e.g. for embedded stuff that gets shipped to customers). They either use nix or some of the proprietary solutions that do something similar
08:06:34 <Guest_37> how would i write a function that takes a string from a user and associates it with a row and column variable
08:07:18 <maerwald> untseac: GHC can be installed without stack easily. Stackage can be used with cabal as well.
08:07:30 <maerwald> So I'm not sure what is your point
08:08:15 * hackage mmsyn7s 0.6.7.0 - Shows a sorted list of the Ukrainian sounds representations that can be used by mmsyn7 series of programs  https://hackage.haskell.org/package/mmsyn7s-0.6.7.0 (OleksandrZhabenko)
08:08:22 <enikar> tools are not perfect, anyway.
08:08:41 <maerwald> enikar: true, but they are worse if they don't follow the unix principles, imo
08:09:18 <enikar> I'm agree with that.
08:09:35 <untseac> maerwald, my point is that stack is trying to fix the problem of dependency hell. It's more of a ugly patch IMO but better than getting errors all the time. Also lead to that static vs dynamic link dilemma.
08:09:47 <maerwald> untseac: there is no dependency hell since probably 3 years
08:09:49 <maerwald> or more
08:09:54 <ski> Guest_37 : associates, how ?
08:09:55 <untseac> well good
08:10:14 <untseac> because semantic versioning should be good enough to fix that
08:10:24 <maerwald> we don't have semantic versioning
08:10:56 <solonarv> ...instead we have the PVP (package versioning policy), which is very similar tbh
08:11:07 <maerwald> solonarv: semver is nicer, imo, but yeah
08:11:17 <untseac> yeah that's what I was going to say, it's similar
08:11:41 <solonarv> the big obvios difference is that in PVP, in a version like X.Y.Z.P, X.Y together is the major version (and Z minor, P patch)
08:12:03 <maerwald> solonarv: also, you can't really have pre-releases with PVP
08:12:15 <maerwald> at least not in a visible way
08:12:23 <solonarv> true
08:13:14 <maerwald> the grammar of PVP is, obviously, simpler though
08:13:16 <untseac> I don't like that the stack solution of graphs of dependencies that "just build" (kind of) lead to static linking... but that's just me. It feels like a nuclear strike solution.
08:13:22 <ski> Guest_37 : do you want to parse the string, or something else ?
08:13:28 <solonarv> static linking isn't a decision made by stack
08:13:38 <maerwald> the sad part is, you cannot safely convert PVP to semver or semver to PVP
08:13:42 <untseac> yeah but probably lead to it
08:13:57 <untseac> not sure
08:13:59 <solonarv> no, static linking has been the default for longer than stack has even existed
08:14:12 <untseac> but what's the problem with dynamic linking?
08:14:15 * hackage mmsyn7h 0.7.6.0 - Produces a sound recording specified by the Ukrainian text.  https://hackage.haskell.org/package/mmsyn7h-0.7.6.0 (OleksandrZhabenko)
08:14:19 <untseac> works with linux
08:14:23 <maerwald> untseac: it is useless when the ABI is unstable
08:14:37 <untseac> okay fair, so when is it going to be stable lol
08:14:42 <maerwald> never
08:14:45 <untseac> exactly
08:14:53 <solonarv> there is cross-module inlining
08:15:03 <maerwald> it breaks with every ghc version
08:15:09 <Guest_37> @ski im new to haskell so forgive me, but I have 5 lists, my end goal is to take an input from the user as a string and use the first part of the string to find which row to operate on and the second part of the inputted string to represent which element in that row
08:15:10 <lambdabot> Maybe you meant: wiki src ask
08:15:16 * hackage units-defs 2.2 - Definitions for use with the units package  https://hackage.haskell.org/package/units-defs-2.2 (RichardEisenberg)
08:15:20 <solonarv> that makes dynamic linking some mix of pointless and dangerous, even without considering the changes between GHC versions
08:15:47 <Guest_37> @ski the lists are labelled row sorry for any confusion
08:15:47 <lambdabot> Maybe you meant: wiki src ask
08:16:03 <untseac> well I just don't like static linking but it's not the end of the world
08:16:07 <ski> Guest_37 : souns like you want to parse the string to two list indices (integers), then
08:16:11 <solonarv> Guest_37: you don't need to put an @ before someone's name, the username alone is enough to ping them
08:16:16 * hackage mmsyn7l 0.4.3.0 - Modifies the amplitudes of the Ukrainian sounds representations created by mmsyn7ukr package.  https://hackage.haskell.org/package/mmsyn7l-0.4.3.0 (OleksandrZhabenko)
08:16:20 * ski smiles
08:16:25 <solonarv> (well, with most client configurations)
08:19:08 <freeman42x[m]1> lyxia: there is nothing wrong with: https://github.com/razvan-flavius-panda/Formalizing-Intelligence/blob/master/main.hs#L3
08:19:08 <freeman42x[m]1> afaict. But I am sure there has to be better way of using a data placeholder than to name it that way
08:19:43 <solonarv> sure, you can just give it the same name as the data type and put a TODO comment above
08:20:15 * hackage hpack 0.34.0 - A modern format for Haskell packages  https://hackage.haskell.org/package/hpack-0.34.0 (SimonHengel)
08:20:16 <solonarv> personally I find long camelcase/titlecase phrases hard to read and annoying to write, so I'd prefer that
08:21:03 <ski> Guest_37 : what have you tried, so far ?
08:22:00 <isovector1> does anyone have co/arbitrary instances for lenses?
08:22:46 * hackage dobutokO 0.3.2.0 - The library is intended to print updated messages on the terminal screen.  https://hackage.haskell.org/package/dobutokO-0.3.2.0 (OleksandrZhabenko)
08:22:59 <Guest_37> ski can i create a global variable that is modified over and over in haskell
08:23:16 <ski> technically yes, but you probably don't want to
08:24:20 <ski> part of the point of learning FP is to realize that one typically doesn't need mutable state all that often (and especially not global mutable state)
08:25:21 <ski> so, if you want to get something out of learning some Haskell (rather than programming C or whatever in Haskell, which can be done), i'd suggest trying to learn and understand the way things are typically done in Haskell
08:25:38 <Guest_37> ski My idea was to create a loop that asked for row and column as a string, parse that string to find which list and which list element they are referencing, modify that element, and repeat
08:26:35 <Guest_37> Im so used to C/JS that my first inclination is to loop those steps
08:27:01 <merijn> Guest_37: You probably don't want a list if you do random access like that. Haskell lists are linked lists, so updating positionally is inefficient. You probably want Array/Vector instead for that
08:27:32 <Guest_37> r1 = [0,0,0,0,0]
08:27:41 <Guest_37> array?
08:27:45 * hackage dobutokO2 0.39.1.0 - Helps to create experimental music from a file (or its part) and a Ukrainian text.  https://hackage.haskell.org/package/dobutokO2-0.39.1.0 (OleksandrZhabenko)
08:27:49 <ski> that's a list, not an array
08:27:52 <merijn> Guest_37: No, that's a linked list
08:28:05 <ski> Guest_37 : but yes, you can loop
08:29:05 <merijn> Guest_37: Anyway, the logic in Haskell is fairly straight forward. Instead of a loop you'd define a recursive function like "read input, compute the resulting modification, call the function again with the new state"
08:30:52 * ski would still call that a loop :)
08:31:17 <merijn> ski: So would I, but many beginners consider only for/while loops, so I adjust :p
08:31:39 <merijn> ski: Loops are just poor man's recursion, after all ;)
08:31:42 <freeman42x[m]1> <solonarv "personally I find long camelcase"> I prefer that over the TODO cause of the auto-complete...
08:34:19 <ski> Guest_37 : do you have some code you'd like advice on ?
08:34:29 <ski> Guest_37 : or perhaps you're unsure how to start ?
08:35:57 <Guest_37> myArray = array(1,25)[(i,"~")|i<-[1..25]]
08:36:48 <Guest_37> i tried this to make an array from 1 to 25 with each spot associating its index value to a charachter
08:37:07 <Guest_37> ski
08:38:46 * hackage cobot-io 0.1.3.4 - Biological data file formats and IO  https://hackage.haskell.org/package/cobot-io-0.1.3.4 (ozzzzz)
08:39:48 <ski> Guest_37 : that should work
08:39:57 <ski> that makes an immutable array, btw
08:40:05 <Guest_37> immutable?
08:40:17 <ski> those can be updated, by making a copy with some parts changed
08:40:41 <Guest_37> it failed saying array variable not in scope
08:40:46 <ski> but if you're only updating one element at a time, it's probably better to make a mutable array
08:41:07 <ski> ah, you need to import `Data.Array'
08:41:38 <ski> immutable arrays can often be nice for "dynamic programming" problems
08:41:48 <Guest_37> yay that worked
08:42:26 <ski> however, to work with mutable arrays, you need to dive into monads
08:42:59 <ski> (more specifically, `IO' or `ST s' monad)
08:44:24 <ski> Guest_37 : i'm not sure how much of the basics of Haskell you know, yet
08:45:17 <ski> it would be possible, if you prefer to, to work with lists, or even finite maps, atm
08:45:17 <Guest_37> okay i have my array of 25, how would I modify say the 23rd element
08:45:21 <ski> (or immutable arrays)
08:47:04 <ski> @let myArray :: Array Int String; myArray = array (1,25) [(i,"~") | i <- [1 .. 25]]
08:47:04 <dmwit> Guest_37: (\\)
08:47:05 <lambdabot>  Defined.
08:47:12 <ski> > elems myArray
08:47:14 <lambdabot>  ["~","~","~","~","~","~","~","~","~","~","~","~","~","~","~","~","~","~","~"...
08:47:20 <ski> > concat (elems myArray)
08:47:22 <lambdabot>  "~~~~~~~~~~~~~~~~~~~~~~~~~"
08:47:36 <ski> > concat (elems (myArray // [(23,".")]))
08:47:38 <lambdabot>  "~~~~~~~~~~~~~~~~~~~~~~.~~"
08:47:57 <dmwit> err.. yeah, other slash lol
08:48:53 <dmwit> But beware: modifications of immutable arrays are O(n). If you need O(1), you need mutable.
08:49:06 <ski> (yea, i noted that :)
08:49:52 <ski> `//' takes a list of updates to the array, so you can update multiple elements at once, only requiring one copy of the array
08:49:59 <ski> @type (//)
08:50:00 <lambdabot> Ix i => Array i e -> [(i, e)] -> Array i e
08:55:49 <ski> % import Data.Array.IO
08:55:49 <yahb> ski: 
08:55:55 <ski> % myArray :: IOArray Int String <- newArray (1,25) "~"
08:55:55 <yahb> ski: 
08:55:59 <ski> % concat <$> getElems myArray
08:55:59 <yahb> ski: "~~~~~~~~~~~~~~~~~~~~~~~~~"
08:56:03 <ski> % writeArray myArray 23 "."
08:56:03 <yahb> ski: 
08:56:05 <ski> % concat <$> getElems myArray
08:56:05 <yahb> ski: "~~~~~~~~~~~~~~~~~~~~~~.~~"
08:56:10 <ski> Guest_37 ^
08:56:32 <ski> that's how you could work with mutable arrays
08:56:41 <ski> (or rather, it hints at how to do it)
08:59:32 <dmwit> I'd have thought you learned your lesson on the second go and used '~' instead of "~". =P
09:00:16 <ski> nah, i wanted to reproduce that faithfully, to let Guest_37 decide (or not) to change that, on their own ;)
09:00:23 <joecordingley> hi I was messing around with lenses and the state monad and I can't get zoom working
09:00:51 <joecordingley> If I have this function:
09:00:55 <joecordingley> updateMaybe :: MonadState (Maybe a) m => a -> m Bool
09:00:55 <joecordingley> updateMaybe a = state update' where
09:00:55 <joecordingley>   update' s = (isNothing s, s <|> Just a)
09:00:57 <[exa]> joecordingley: please pastebin
09:01:13 <joecordingley> ok
09:01:14 <ski> (only three lines)
09:01:23 <[exa]> joecordingley: (if that's everything you don't have to, but longer examples will require it :] )
09:01:38 <joecordingley> ah,
09:01:43 <ski> @type state
09:01:44 <lambdabot> MonadState s m => (s -> (a, s)) -> m a
09:01:48 <merijn> ski: Yeah, but some of us use narrow IRC windows so they linewrap ugly, so even then it's annoying :p
09:02:09 <maerwald> merijn: get a bigger screen
09:02:23 <merijn> maerwald: My screen is plenty big, but most of it is "not IRC"
09:02:30 <maerwald> Get a second screen
09:02:46 <[exa]> my screen is cellphone tho, what do I do now
09:02:55 <maerwald> throw it away
09:02:57 <maerwald> :D
09:03:13 <solonarv> you can probably still connect a monitor to it :p
09:03:15 <merijn> maerwald: I have one, but there's no good thunderbolt/USB-C docks that support multiple screens, so I always just use one with my laptop :p
09:04:00 <[exa]> joecordingley: btw what is the behavior you expect and what you get instead?
09:04:15 <joecordingley> https://pastebin.com/Jjv02V8u
09:04:38 <joecordingley> so i have an update maybe, and I wanted to make it work on a larger state
09:05:05 <joecordingley> like a tuple of a b and a maybe, and zoom seems to claim to do that
09:05:32 <joecordingley> but there are many complaints of not being able to deduce type classes
09:05:46 <ski> merijn : yea, why i did `concat'
09:06:26 <dmwit> joecordingley: What happens if you delete the type signature on `updateRight`? ;-)
09:07:07 <joecordingley> it doesn't complain, but no longer has any relationship to monadState
09:07:16 <joecordingley> or maybes or anything
09:07:39 <joecordingley> oh still maybes
09:07:40 <[exa]> joecordingley: it should; the most generic type shold get derived automatically
09:07:49 <[exa]> joecordingley: try with :t in ghci
09:08:03 <dmwit> joecordingley: I still see a MonadState constraint in the list when I try it.
09:08:21 <joecordingley> this: https://pastebin.com/K87pV0N6
09:08:34 <[exa]> joecordingley: also from where do you get 'a' in the definition of updateRight?
09:08:36 <dmwit> That's not what I see.
09:08:41 <dmwit> :t zoom _2 (undefined :: MonadState (Maybe a) m => a -> m Bool)
09:08:42 <lambdabot> (Zoom ((->) a) n b s, Field2 s s b b, MonadState (Maybe a) m, Functor (Zoomed ((->) a) (m Bool))) => n (m Bool)
09:09:40 <dmwit> anyway
09:09:55 <joecordingley> maybe I have a different zoom being brought in
09:10:48 <[exa]> joecordingley: I guess it's simpler
09:11:28 <dmwit> Oh, I've made a mistake in my transcription.
09:11:29 <dmwit> Whoops.
09:11:43 <dmwit> :t \a -> zoom _2 ((undefined :: MonadState (Maybe a) m => a -> m Bool) a)
09:11:44 <joecordingley> :t zoom _2 (undefined :: MonadState (Maybe a) m => m Bool)
09:11:45 <lambdabot> (Zoom m n (Maybe a) s, Field2 s s (Maybe a) (Maybe a), Functor (Zoomed m Bool)) => a -> n Bool
09:11:45 <lambdabot> (Zoom m n (Maybe a) s, Field2 s s (Maybe a) (Maybe a), Functor (Zoomed m Bool)) => n Bool
09:12:13 <joecordingley> oops snap
09:12:27 <dmwit> My bad. =)
09:12:54 <joecordingley> (I made a mistake in my original pastebin and missed the a argument)
09:13:09 <joecordingley> for updateright
09:13:15 <[exa]> joecordingley: ok that part's explained then :]
09:13:19 <dmwit> Anyway, it still has a relationship to MonadState, because Zoom has a relationship to MonadState.
09:13:31 <dmwit> class (MonadState s m, MonadState t n) => Zoom m n s t | ...
09:13:51 <[exa]> joecordingley: can you pastebin the error you get after it's fixed?
09:15:53 <dmwit> :t (\a -> zoom _2 ((undefined :: MonadState (Maybe a) m => a -> m Bool) a)) :: (Zoom m n (Maybe a) (b, Maybe a), Functor (Zoomed m Bool)) => a -> n Bool
09:15:55 <lambdabot> (Zoom m n (Maybe a) (b, Maybe a), Functor (Zoomed m Bool)) => a -> n Bool
09:16:10 <rotaerk> "tell me something I *don't* know!"
09:16:12 <dmwit> joecordingley: That's a more specific type-signature you can give it if you want to specifically choose tuples for the _2 use.
09:16:54 <joecordingley> here is the full error: https://pastebin.com/mLKe56uh
09:18:12 <dmwit> Anyway, yes, MonadState definitely isn't enough context to use zoom.
09:18:26 <joecordingley> I would like it just to have the type signature of MonadState (b, Maybe a) m => a -> m Bool
09:18:29 <dmwit> Now, if you had a specific MonadState instance that you wanted to use, taht would almost certainly be fine.
09:18:34 <dmwit> joecordingley: Too bad.
09:18:59 <joecordingley> I can do it manually, it's just a bit of a mess
09:19:48 <joecordingley> i reckon I would be able to do it for an arbitrary "getter" and "setter" too, so you would assume that it is possible
09:20:01 <dmwit> Possibly: `updateRight a = zoom _2 (updateMaybe @_ @State a)`
09:20:13 <dmwit> err
09:20:29 <dmwit> ...and then you need to lift back from `State` to `MonadState` with something like `state . runState`.
09:21:16 <dmwit> :t state . runState . zoom _2 . (undefined :: MonadState (Maybe a) m => a -> m Bool)
09:21:17 <lambdabot> (MonadState s m, Field2 s s (Maybe a) (Maybe a)) => a -> m Bool
09:21:39 <dmwit> That's not too awful. Okay, I take back my "too bad" from earlier. =P
09:23:42 <joecordingley> this is what I thought zoom was, could I define zoomProper l = state . runState . zoom f
09:23:58 <dmwit> But it really only works for things that are as polymorphic as `updateMaybe` happens to be -- i.e. working in *any* `MonadState`. If the action you want to wrap has more effects (like also needing `MonadWriter` or whatever), this won't cut it.
09:24:08 <xcmw> Are there any performance tips for the diagrams library? I'm using the miso-diagrams backend. But it is really slow even with ghc. Is there a way to only recompute the parts that changed?
09:24:18 <dmwit> You could if you wanted. But it's much less useful than you might guess at first, for the reasons in my previous comment.
09:24:27 <joecordingley> Ah I see
09:26:15 * hackage it-has 0.1.0.0 - Automatically derivable Has instances.  https://hackage.haskell.org/package/it-has-0.1.0.0 (dnikolovv)
09:31:08 <solonarv> :t state . runState -- much less general
09:31:09 <lambdabot> MonadState s m => State s a -> m a
09:31:51 <solonarv> roughly speaking, zoom can change the outermost StateT no matter where it is in the stack of monad transformers
09:33:45 * hackage persist 0.1.1.5 - Minimal serialization library with focus on performance  https://hackage.haskell.org/package/persist-0.1.1.5 (minad)
09:44:22 <joecordingley> to step back from the specific question, how would you construct the function updateRight having not seen my attempt?
09:44:53 <joecordingley> ingoring the updateMaybe bit
09:58:18 <joecordingley> thanks dmwit
09:58:29 <joecordingley> that actually worked out quite well
09:59:28 <justsomeguy> Thank you to whoever pointed me towards Haskell Tutorial and Cookbook, yesterday.
10:02:21 <dmwit> joecordingley: First I'd try to make a plan that didn't need updateRight. =P
10:02:27 <dmwit> joecordingley: Then, if that failed, I'd use zoom _2
10:05:00 <joecordingley> I think I like the state . runstate, I tried writing the updateRight without the updateMaybe and it was less clear. Especially when it's more deeply nested than one part of a tuple
10:14:16 * hackage relude 0.7.0.0 - Safe, performant, user-friendly and lightweight Haskell Standard Library  https://hackage.haskell.org/package/relude-0.7.0.0 (vrom911)
10:16:24 <Guest_60> how would i generate a random number between 1 and 5
10:16:44 <ski> @type randomR
10:16:45 * hackage haskoin-store-data 0.29.3 - Data for Haskoin Store  https://hackage.haskell.org/package/haskoin-store-data-0.29.3 (jprupp)
10:16:46 <lambdabot> (Random a, RandomGen g) => (a, a) -> g -> (a, g)
10:16:50 <haskellhistorian> Hi, I remember that GHC error messages used to pretty print expressions. At some point it switched to showing the code as written in your files. Does anoyne remember which GHC version made this change?
10:17:38 <ski> Guest_60 : you need to get ahold of an initial random number generator state, e.g. an `StdGen'
10:17:45 * hackage haskoin-store 0.29.3 - Storage and index for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-store-0.29.3 (jprupp)
10:18:03 <ski> @type newStdGen
10:18:04 <lambdabot> IO StdGen
10:18:07 <ski> is one way
10:18:09 <dsal> % randomRIO (1,5)  --if you're already in IO, you can use the "already in IO" variant.
10:18:09 <yahb> dsal: 4
10:18:21 <ski> @type getStdRandom
10:18:22 <lambdabot> (StdGen -> (a, StdGen)) -> IO a
10:18:27 <ski> is another way
10:18:38 <dmwit> No, no, you can't use 4 for your random numbers. *I* use 4 for my random numbers.
10:18:59 <haskellhistorian> Does anyone know where I can find something like "release notes" of GHC?
10:19:10 <monochrom> GHC User's Guide
10:19:12 <ski> and yes, `randomRIO (lo,hi)' is basically `getStdRandom (randomR (lo,hi))'
10:19:18 <wavemode_> google "ghc release notes"
10:19:40 <monochrom> GHC User's Guide is underrated. More people should read it.
10:19:46 <Boarders_> has anyone here managed to successfully set up ghcide using emacs?
10:19:50 <Boarders_> and if so did you do anything special
10:20:03 <Boarders_> I can't seem to get company-mode pop ups with eglot
10:20:12 <Guest_60> im so confused
10:20:19 <haskellhistorian> @monochrom, thank you! Unlike wavemode_'s suggestion, that actually has the information I need!
10:20:20 <lambdabot> Unknown command, try @list
10:20:25 <Guest_60> getStdRandom didnt work
10:20:32 <ski> Guest_60 : do you have some sample code you'd want advice on ?
10:21:01 <ski> Guest_60 : "didn't work" doesn't tell us : (a) what you tried; (b) what you expected; (c) what you got instead
10:21:03 <dsal> % getStdRandom
10:21:03 <yahb> dsal: ; <interactive>:17:1: error:; * No instance for (Show ((StdGen -> (a0, StdGen)) -> IO a0)) arising from a use of `print'; (maybe you haven't applied a function to enough arguments?); * In a stmt of an interactive GHCi command: print it
10:21:10 <Guest_60> just trying to make a function that outputs a random number
10:21:14 <dsal> That suggests it worked, but I didn't ask it to do something.
10:21:18 <monochrom> googling "ghc release notes" still brings you to the GHC User's Guide, so I would think it's just as good.
10:21:22 <ski> Guest_60 : a function, of which type ?
10:21:35 <dsal> Guest_60: A function can't output a random number.  Can you provide some code?
10:21:44 <Guest_60> printRandom = do
10:21:55 <monochrom> I still like to recommend the user guide directly because more people need to know that it exists.
10:22:00 <haskellhistorian> Ah, I guess DuckDuckGo doesn't find it as easily.
10:22:00 <ski> (numbers aren't random. their means of generation may be)
10:22:22 <monochrom> I hate this post-manual era where people just assume that there is no manual to read, there is none at all.
10:22:28 <wavemode_> monochrom: true
10:23:46 <haskellhistorian> My more specific question is about when the error messages switched away from using a pretty printer. It was sometime between 7.6 and 8.6, but I do not recall which one exactly.
10:23:52 <haskellhistorian> Does anyone here recall?
10:27:05 <monochrom> I don't.  There is also the possibility that this change is not stated in the release notes.  My recollection is that the release notes focus on language features and libraries.
10:27:34 <ski> perhaps someone in #ghc would know
10:27:42 <monochrom> Ah yeah, definitely.
10:28:13 <haskellhistorian> Thank you! I'll check there!
10:29:11 <remexre> asked this yesterday, but another convo was going on, and I didn't get an answer; is there a way to make an explicitly bidirectional pattern synonym have an extra typeclass constraint in the expression form vs the pattern form?
10:30:59 <dmwit> Hah, nice. Indeed the typing rules for the two forms aren't necessarily formally tied together. Anyway I would guess that for simplicity the answer is "no".
10:32:27 <monochrom> dmwit, you sound like you have just speed-read GHC source code to answer that question. Is that true? >:)
10:33:08 <monochrom> "I took a look at GHC type checker, doesn't look like it ties the two forms"
10:45:45 <haskellhistorian> Update, it was in 8.2.1! https://downloads.haskell.org/ghc/8.2-latest/docs/html/users_guide/8.2.1-notes.html
10:45:50 <haskellhistorian> Thanks for the pointers on this!
10:46:06 <haskellhistorian> I ended up using https://www.jdoodle.com/execute-haskell-online/ to narrow down when the error message style changed!
10:47:08 <wavemode_> living up to your name :)
10:49:10 <monochrom> haha
10:53:06 <MarcelineVQ> :>
11:13:45 <infandum> I have a parser to parse simple Text such as "lab1:3-5", to some (T "1" 3 5). I use attoparsec to do this. I have a huge list of these strings and I use mapM parseLab ["lab1:3-5", "lab1:10-45", "lab2:20-450", ...] According to profiling, I have an obscene amount of memory being used for Data.Attoparsec.Text.decimal. Is there a way to improve this usage?
11:14:25 <infandum> I the text parser for decimal bad in attoparsec? Would I be using it wrong?
11:14:58 <infandum> It's just Atto.string "lab"; lab <- Atto.takeWhile1 (/= ':'
11:15:49 <infandum> Atto.string "lab"; lab <- Atto.takeWhile1 (/= ':'); Atto.char ':'; l <- Atto.decimal; Atto.char '-'; u <- Atto.decimal; return $ T lab l u
11:24:03 <wavemode_> do you need to hold all the parsed data in memory? or can it be streamed to a file as you're reading it in so you don't build up a huge list?
11:25:45 * hackage hpack 0.34.1 - A modern format for Haskell packages  https://hackage.haskell.org/package/hpack-0.34.1 (SimonHengel)
11:26:45 <infandum> wavemode_: It does need to be in memory because it's converted to a matrix
11:26:49 <infandum> then stuff is done
11:37:15 * hackage haskoin-core 0.13.4 - Bitcoin & Bitcoin Cash library for Haskell  https://hackage.haskell.org/package/haskoin-core-0.13.4 (jprupp)
11:37:48 <wavemode_> infadum: rather than `mapM parseLab list` which builds up a list of every parse operation, how about `forM_ list \lab -> do ...` where (...) is (parse the lab, insert it into the matrix)
11:45:15 * hackage yaya 0.3.0.0 - Total recursion schemes.  https://hackage.haskell.org/package/yaya-0.3.0.0 (sellout)
11:46:15 * hackage yaya-unsafe-test 0.1.1.2, yaya-unsafe 0.2.0.0, yaya-hedgehog 0.2.0.0, yaya-test 0.3.0.0 (sellout)
11:51:37 <infandum> wavemode_: I need the values to join with the same processed values from another input file, so unfortunately I can't directly stream the results to a matrix, they need to be intersected
11:51:57 <infandum> Would the mapM be the reason for decimal appearing as high memory usage?
11:51:57 <dmwit> monochrom: Instead of reading the GHC source code, I thought about what source code I would write. I cheated!
11:52:45 * hackage ghc-lib-parser-ex 8.10.0.8 - Algorithms on GHC parse trees  https://hackage.haskell.org/package/ghc-lib-parser-ex-8.10.0.8 (shayne_fletcher)
11:53:35 <wavemode_> infandum: well, I have no way of knowing for sure. It was just the thing that jumped out at me
11:54:31 <dmwit> How much memory is an obscene amount
11:56:18 <dmwit> Also: if you are getting your list from splitting, you might consider moving the split into your parser.
11:56:40 <dmwit> Though I don't really think that will change the memory usage much.
11:57:25 <infandum> dmwit: I'm running with -p (takes a while on big data), but the -hc results are about 200M and my wholeprocess is super slow, but I would expect almost no memory usage as it's just parsing each text and moving on
11:57:51 <infandum> each text of less than 20 characters each I'd say
11:57:55 <dmwit> How many labels are you parsing?
11:58:03 <infandum> hundreds of millions
11:58:10 <monochrom> 1TB RAM is obscene. Either that, or 64KB, depending on which extreme you have in mind!
11:58:19 <dmwit> 2 bytes per number is obscene?
11:58:37 <infandum> dmwit: Why would they all be held in memory?
11:58:38 * dmwit feels confused
11:58:53 <infandum> through the decimal function?
11:58:59 <dmwit> You said above that you have to hold them all in memory to do some later processing, didn't you?
11:59:26 <dmwit> Yes, the decimal function is the one that allocates the space for the actual number to live in.
11:59:27 <infandum> yes, but why would specifically the "Atto.decimal" function be showing up as the second highest memory usage?
11:59:41 <monochrom> Note: If you feel that a "question" sounds more like a rhetorical question with the purpose of venting, it most likely is.
11:59:54 <dmwit> Which function would you find more appropriate to blame than decimal?
12:00:13 <monochrom> "why does GHC use so much memory?! why don't other people write the software I want to use?!"
12:00:27 <monochrom> clearly totally uninterested in the why.
12:00:29 <infandum> dmwit: Probably the list that's holding them all, rather than the function producing them
12:00:48 <dmwit> Okay. Then you have misunderstood what profiling does.
12:00:53 <wavemode_> infandum: can you put the profiling results in a pastebin?
12:00:56 <infandum> I think that's probably it
12:00:57 <monochrom> Why can't people simply accept that other people have different priorities than yours?
12:01:18 <infandum> wavemode_: It's still running to get the complete -p
12:02:59 <dmwit> (...do you even have a cost center for that list?)
12:03:25 <infandum> dmwit: I compiled with profiling level of all functions
12:03:44 <monochrom> so probably no
12:03:56 <dmwit> Okay. Well, a list is not a function. Surely the compiler can't be asked to blame a thing which you have explicitly asked it not to blame.
12:03:59 <infandum> dmwit: So essentially, the cost center here would be decimal because decimal is what allocated the int in the first place?
12:04:26 <dmwit> Yes.
12:04:31 <infandum> dmwit: How would I have a cost center for, I guess, everything?
12:04:33 <dmwit> Adding a cost center for the list won't change that, of course.
12:04:36 <wavemode_> mapM returns a list of each parsing result (which, for you, is many millions of Results). that's why I felt your high Atto.decimal usage could be a result of that
12:04:38 <infandum> oh
12:05:03 <dmwit> It will just *also* indicate that the list requires a lot of memory to store.
12:05:13 <infandum> dmwit: Then how would I find out what would be making my program slow / take up memory?
12:05:46 <infandum> So it seems like the heap profiling is more for space leaks, to watch for growth rather than absolute usage?
12:05:49 <dmwit> I don't understand the question. You know what is causing your program to take up a lot of memory: you're building a list that takes up a lot of memory, and decimal is the guy creating the elements of that list.
12:06:09 <infandum> Okay, makes sense
12:06:23 <infandum> I guess the remaining question is timing, but I assume -p will reveal more for that
12:06:58 <infandum> Sorry, I just get confused with the profiling, even with the documentation
12:11:18 <dmwit> Ah, perhaps the confusion is this:
12:12:24 <dmwit> When the profiler says "decimal used 200MiB", that does not mean "there is some input that caused decimal to use 200MiB, and all the other inputs used less, so it reused that space for the other inputs". It means "aggregating all the calls to decimal, the total amount of space that it needed over all those calls is 200MiB".
12:12:54 <dmwit> Any single call only used a few bytes to store a number. But you made a hundred million of them.
12:13:18 <wavemode_> yeah, don't confuse allocations for memory usage
12:13:23 <infandum> dmwit: That's for -p, the profiling report, not heap profiling, right?
12:13:58 <dmwit> I don't know which flags. But I am 80% confident this description applies to all the memory profiling GHC is capable of doing.
12:14:01 <infandum> for the heap profiling, I see decimal use 200MiB over the course of thousands of seconds (constant)
12:14:28 <infandum> like, the +RTS -hc profiling, which can give a graph of live memory usage over time
12:14:43 <wavemode_> ahh
12:14:48 <infandum> I just assumed decimal would appear then disappear with low memory usage as it's the initial step
12:15:08 <infandum> but it is the second largest area curve and maintained for a very long time
12:15:17 <dmwit> I expect that graph is aggregating over a smaller collection of calls than "all of them", because probably you are doing *some* streaming. But it is almost certainly not the case that any single call to decimal has ever used over a megabyte.
12:15:34 <dmwit> (I would expect on the order of one or two words per call.)
12:15:43 <d34df00d> dmwit: hey, am I mistaken, or you've linked to a repo that has something to do with assembly language semantics for x86 in particular a few weeks ago?
12:15:47 <d34df00d> Can't find that in my logs :(
12:16:28 <infandum> dmwit: Ok, so what you said earlier makes sense, right? Decimal allocated 200MiB worth of Ints which are kept in memory for a while, even though all the decimal calls are done? Hence it has a sharp high memory increase and is maintained?
12:16:45 <infandum> So it sounds like heap profiling will not point to the right location but -p might
12:16:46 <dmwit> Whew, a big collection of repos, not just one. But yes: https://github.com/GaloisInc/renovate would be a half-decent top-level repo to start from.
12:16:57 <d34df00d> Cool thanks!
12:17:51 <d34df00d> Yeah, that's a bunch of deps!
12:18:19 <dmwit> d34df00d: Actually, https://github.com/GaloisInc/macaw is probably a better place to start.
12:18:22 * THEE- - server 110 - do not make notice. -
12:18:22 * THEE- - server 110 - do not make notice. -
12:18:23 * THEE- - server 110 - do not make notice. -
12:19:54 <dmwit> (It is one of the many dependencies of renovate; renovate is specifically for rewriting binaries, so if you want to do anything that isn't exactly that you probably want to go at least one layer down the dependency chain.)
12:20:10 <monochrom> It is possible to have a million "decimal"s unevaluated.
12:21:15 * hackage bv-sized 1.0.1 - a bitvector datatype that is parameterized by the vector width  https://hackage.haskell.org/package/bv-sized-1.0.1 (benselfridge)
12:21:32 <infandum> monochrom: How? I thought attoparsec with Text was strict
12:21:59 <dmwit> d34df00d: And of course, depending on what you want to do and what your budget is, you might consider hiring Galois to do it for you... ;-)
12:22:18 <monochrom> strictness is much more refined and relative than a simple boolean "strict" "not strict".
12:22:34 <d34df00d> dmwit: yeah, I'm not rewriting binaries :) I was playing around with inline assembly in haskell a couple of months ago, and then it dawned on me that textual C-style inline assembly is not the way to go, so I'd like to do something eDSLish.
12:22:39 <d34df00d> dmwit: I'd much rather Galois hiring me.
12:23:03 <koz_> d34df00d: Well, if you wanna DSL, you've picked a good language to work in. :P
12:23:10 <monochrom> For example suppose you have "const 4 (negate $! div 1 0)"
12:23:21 <monochrom> > const 4 (negate $! div 1 0)
12:23:23 <lambdabot>  4
12:23:25 <d34df00d> koz_: indeed!
12:23:36 <monochrom> The $! is completely ignored. Consider why.
12:23:47 <mniip> d34df00d, have you seen extended assembly (gcc)
12:23:52 <dmwit> d34df00d: Hm, for that, you may even want to go one farther down the dependency chain to flexdis86.
12:24:25 <monochrom> A strictness annotation hiding behind a lazy thing is not going to make anything happen earlier.
12:24:38 <d34df00d> mniip: yep, but it's not in haskell.
12:24:41 <dmwit> d34df00d: And... we are currently hiring, but mostly in hardware dev and cryptography researcher roles...
12:24:52 <mniip> I mean it's a mix of pure textual and eDSL
12:25:03 <mniip> does that look like a nice tradeoff to you?
12:25:30 <mniip> or rather, it's an axis in the design space that is worth considering
12:26:11 <infandum> monochrom: That assumes negate would never be called because of const. If the parser is called, then I would think decimal is called. And the parser must be called for each item because of the mapM parser list
12:26:17 <infandum> as mapM uses sequence
12:26:55 <monochrom> That's true.
12:26:58 <d34df00d> dmwit: frankly, not sure I'm a good fit there, at least, yet. In fact I'm looking to switch from more C++-ish (and, it so happened, finances-oriented) world, even if with some inclusions of haskell, to more research-oriented and formally verified stuff.
12:27:12 <d34df00d> So you might be quite dissatisfied with my skillset :)
12:27:15 <infandum> monochrom: I think, as usual, I'm probably misinterpreting the heap profiling output
12:27:24 <d34df00d> mniip: well, that's definitely one of the things to draw inspiration from!
12:29:08 <d34df00d> dmwit: and re assembly stuff, what I want to achieve is to be able to write smth like `do mov a b ; add 2 b ; vpxor smth smth ` â I don't really even have the syntax fleshed out, just rather want to explore this space.
12:29:28 <d34df00d> And what I really really want to avoid is having to define x86 instructions and their types at least.
12:30:26 <mniip> the almost-general-purpose register "thing" about modern arhictectures really makes an assembly eDSL tie in with register allocation
12:30:36 <mniip> and the "almost" makes that register allocation very hard
12:30:47 <dmwit> Yeah. I think if anything we did will be useful to you, flexdis86 is likely to be the right level.
12:31:21 <dmwit> I'm not super sure it will be useful to you. As I recall working with the flexdis86 types directly is a bit painful. But then, you're the one that signed up for x86, so maybe pain is in your skillset. ^_^
12:32:06 * dmwit . o O ( the newest music genre, vpxor wave )
12:32:09 <mniip> say, how fine grained would you like your instruction types to be
12:32:21 <d34df00d> Maybe I should rather invest my time into working on ghc's simd intrinsics.
12:33:57 <mniip> do you want `inc :: (Either ModRM16 (Either ModRM32 ModRM64)) -> Insn`
12:35:13 <d34df00d> mniip: ideally I'd like to have it precise enough to reject said vpxor on two ymm's if my whole (eDSL-) program is constrained by AVX or lower, but accept it if it's constrained by AVX2 or higher.
12:35:26 <mniip> do you want jmpFarIndirect :: ModRM32 -> Insn
12:35:26 <koz_> Is something up with Haskell Weekly?
12:35:39 <koz_> I thought the new one would be out already.
12:35:41 <mniip> oh but "EAX" is a valid ModRM32 and jmpFarIndirect EAX isn't
12:35:59 <d34df00d> More fun then!
12:36:00 <monochrom> koz_: IIRC last week's was out later too.
12:36:10 <mniip> d34df00d, constraining cpu features sounds like the least complicated part
12:36:22 <koz_> monochrom: I don't recall.
12:36:29 <monochrom> Err no, nevermind!
12:36:47 <mniip> it's more the odd non-compositional bits of the ISA
12:37:08 <d34df00d> That would be nice to reject too.
12:37:18 <mniip> there's like 200 ways to encode an SHL
12:37:46 <mniip> (9 ways)
12:38:17 <koz_> mniip: 200 = 9, got it.
12:38:31 <koz_> What base(s) were those two numbers in?
12:39:05 <mniip> base 3/sqrt(2)
12:39:10 <monochrom> heh
12:39:26 <monochrom> base hyperbole
12:39:40 <monochrom> In Chinese we use base hyperbole all the time.
12:40:29 <monochrom> Let m = 10000. We say "m years, m*m years" when hailing an emperor or something
12:41:31 <koz_> mniip: sqrt(2) as a base is certainly something
12:41:47 <monochrom> and then we also get pretty exact and literal about these hyperbole numbers. When hailing a prince, it is "9000 years" because must stay below the m we use towards the emperor!
12:42:19 <koz_> monochrom: So your rank is indicated by the degree of hyperbole?
12:42:38 <monochrom> Actually I am not sure whether it was m*m or m+m.  We juxtaposed m with m.
12:42:44 <dmwit> You're saying the emperor... is OVER NINE THOUSAAAAAAND!
12:42:49 <monochrom> Yes!
12:43:11 <Uniaika> FOR THE EMPRAH
12:45:23 <mniip> the conlang used inside the game heaven's vault uses "[three] [two] [five] [up] [two] [and] [four] [up] [two]" to mean 316
12:47:06 <kw> Is it safe to `unsafeCoerce` a `Left x :: Either a b` to a `Left x :: Either a c` in GHC?
12:47:30 <mniip> d34df00d, anyway there's some instructions where it's customary to include an operand for disambiguation reasons even though it's fixed, and in other instructions the operand is implicit
12:47:45 <d34df00d> Ok, I take that back.
12:47:54 <d34df00d> x86 assembly doesn't sound like fun enough for a fun pet project.
12:48:06 <mniip> e.g. 'shl _, cl', though you can't shift by any other register
12:48:15 <mniip> but you need to include cl because 'shl _, 1' is a different insn
12:48:21 <dmwit> If you already know it's a Left somehow, perhaps you should teach the type-system this and just have an `a` instead of an `Either a b`.
12:48:22 <monochrom> I recently learned from Numberphile featuring Tom Scott that 58 in Danish is 8+(3-0.5)*20
12:48:27 <mniip> and 'mul' has an implicit operand dx:ax
12:48:49 <monochrom> actually to preserve all of the order, 8+(subtract 0.5 3)*20
12:49:14 <monochrom> https://youtu.be/l4bmZ1gRqCc?t=123
12:49:38 <mniip> kw, very likely, and dmwit probably not possible
12:50:14 <monochrom> d34df00d: Would you prefer 680x0 assembly?
12:50:21 <mniip> a prism kinda gives you this power but it's not as performant as an unsafeCoerce I guess
12:50:24 <kw> I'd rather keep sharing the `(# Word#, a #)` tuple rather than allocating a new one.
12:50:47 <d34df00d> monochrom: I'm ashamed to admit I never had experience with it.
12:51:02 <kw> A prism always constructs a new value.
12:51:09 <kw> Unless it's not polymorphic.
12:51:16 <mniip> you could write an auxiliary function `castEither :: Either a b -> (Either a x -> r) -> (Either x b -> r) -> r`
12:51:30 <phadej> at stg level such (type-breaking) optimisations  happen
12:51:50 <monochrom> It is symmetrically 8 data registers plus 8 address registers. One of the address registers is stack pointer, but you just call it A7 and use it like any address registers.
12:52:13 <mniip> sounds like 8086's "general purpose" registers and SP
12:52:44 <monochrom> If you do "mul ? ??" it can be between any two data registers for example, none of that "dedicated accumulator" business like x86 and 6502
12:52:48 * ski . o O ( `Left :: forall a. a -> forall b. Either a b' )
12:53:02 <mniip> although with the caveat of addressing modes being [(BX|BP|0)+(SI|DI|0)+(imm8|imm16|0)]
12:53:31 <monochrom> Likewise, the equiv of a[i] in 680x0 is: can use any address register for a, any data register for i.
12:53:56 <ski> kw : iiuc, that unboxed tuple isn't a "single thing" anyway
12:54:05 <ski> 680x0 is rather nice
12:54:29 <monochrom> It is as RISC as it can get in a time of CISC
12:54:52 <ski> hm. haven't heard it described as RISC, before
12:55:23 <monochrom> It is CISC, but it is the kind of symmetry you see in RISC and PDP-11
12:56:01 <mniip> I wouldn't group x86 and 6502 under "dedicated accumulator"
12:56:02 <kw> @ski I was using the unboxed tuple syntax as an analogy to GHC's representation of an Either value. I assume it's a tuple of a word (probably 0 for Left) and a pointer to the payload.
12:56:02 <lambdabot> Maybe you meant: wiki src ask
12:56:20 <mniip> on 6502 almost everything is by implicit arguments
12:56:32 <mniip> save for having a choice of an addressing mode and offset in memory instructions
12:57:32 <monochrom> Perhaps my bar is too high, but I feel that 8086 is barely better.
12:57:33 <kw> So my assumption is that the representation of a Left `a` value is the same regardless of the type of its Right values.
12:57:49 <mniip> I would say 6502 is better by far
12:58:01 <kw> But I'm not sure.
12:58:04 <monochrom> haha
12:58:12 <mniip> kw, I'm almost 100% certain that yes
12:58:35 <mniip> but again, there might be some things here and there
12:58:54 <monochrom> Actually type erasure ensures that "Right b"s representation is also type-agnostic :)
12:59:22 <monochrom> one word that says "Right" in a way, another word being pointer to b.
13:00:43 <mniip> two words actually
13:00:54 <monochrom> there is detail about how to say "Left" and "Right" (they are not 0 and 1), but probably doesn't matter for that.
13:00:58 <monochrom> s/for that/for now/
13:00:59 <mniip> there's the info table that links the closure to being that of an Either
13:01:12 <mniip> p sure they are 0 and 1
13:01:16 * hackage hvega 0.8.0.0 - Create Vega-Lite visualizations (version 4) in Haskell.  https://hackage.haskell.org/package/hvega-0.8.0.0 (DouglasBurke)
13:01:32 <monochrom> No, the word is pointer to that info table.
13:01:55 <mniip> let's see
13:02:08 <ski> it might be nice if `case ... of e@(Left _) -> ..e..' causes `e' to have type `forall b. Either T b', for the relevant `T'
13:02:34 <monochrom> somewhere inside https://github.com/takenobu-hs/haskell-ghc-illustrated
13:02:50 <ski> also stuff like `Right x >>= k = k x; e >>= _ = e'
13:04:26 <kw> Yeah, it always surprises me when a type that's phantom for the relevant constructor keeps me from reusing the value.
13:04:33 <mniip> spj just implemented impredicative types
13:04:42 <kw> But at the same time it is a good reminder that the code is polymorphic.
13:04:53 <mniip> data Either a b where Left :: a -> Either a (forall b. b); Right b -> Either (forall a. a) b
13:05:42 <kw> @mniip So the actual structure of an Either is more like a pointer to a thunk that evaluates to a tuple of a pointer to an info table and a pointer to a thunk?
13:05:42 <lambdabot> Unknown command, try @list
13:05:45 <mniip> actually that probably doesn't work cause we don't have subtyping of quantified types
13:05:59 <mniip> kw, all closures have info table pointers
13:06:35 <monochrom> There is no "actual structure of an Either".  There are only "actual structure of Left x" and "actual structure of Right y".
13:06:35 <mniip> but a constructor closure points to a fixed table that is reused between all uses of that constructor
13:06:52 <mniip> and that info table references the Either data constructor
13:06:57 <mniip> typ*
13:06:57 <monochrom> The reason is that by the time you also look at Maybe you have to do it this way --- per constructor.
13:06:57 <kw> Oh, makes sense.
13:07:56 <kw> Not that it matters for my purposes, but is that erased during compilation?
13:08:58 <mniip> no
13:09:03 <mniip> very little reason to erase it
13:09:28 <monochrom> Types are erased. All instances of Left, regardless of incompatible types, point to the same info table for Left.
13:09:37 <mniip> right
13:09:44 <mniip> but it's still an Either's Left
13:09:51 <mniip> not whatever type's 0 variant
13:10:39 <monochrom> And yes it does suck that at the Haskell level you have to write "Left a >>= _ = Left a" and not "l@(Left _) >>= l" because the type checker is standing in the way even though the RTS doesn't care.
13:11:17 <monochrom> err l@(Left _) >>= _ = l
13:11:21 <kw> If Maybe were a newtype on Either (), they'd have the same info table, but as its own ADT it has its own table? 
13:12:00 <monochrom> Right
13:15:03 <kw> I'm kind of happy to hear I'm not the only one annoyed by not being able to write, e.g. runes like `l@Left{} <*> _ = l`. That's why the unsafeCoerce question came up.
13:16:09 <monochrom> :)
13:17:01 <monochrom> @quote monochrom unsafeCoerce
13:17:01 <lambdabot> monochrom says: isTrue = (unsafeCoerce :: Either a b -> Bool) . (unsafeCoerce :: Maybe c -> Either a b) . (unsafeCoerce :: Bool -> Maybe c)
13:17:43 <monochrom> I think I can strengthen it to "Either d e -> Bool" and nothing will go wrong.
13:19:38 * monochrom is deeply evil
13:19:47 <monochrom> > reverse "live"
13:19:49 <lambdabot>  "evil"
13:20:19 <dsal> > reverse "deeply"
13:20:21 <lambdabot>  "ylpeed"
13:20:34 <dsal> pronounced:  "y'all peed"
13:20:54 <monochrom> haha
13:20:56 <dsal> :t (some, many) -- things I find confusing
13:20:57 <lambdabot> (Alternative f1, Alternative f2) => (f1 a1 -> f1 [a1], f2 a2 -> f2 [a2])
13:21:04 <ski> iirc, you had some fun pastes on <lpaste.net> re lazy state monad
13:21:23 <kw> @type tagToEnum# . dataToTag#
13:21:24 <lambdabot> error:
13:21:24 <lambdabot>     Variable not in scope: tagToEnum# :: b0 -> c
13:21:24 <lambdabot> error:
13:21:31 <monochrom> Yes but lpaste.net is no more.
13:21:45 <monochrom> and I'm too lazy to re-enter
13:22:06 <monochrom> Please say that "monochrom is non-reentrant because he's too lazy" :)
13:22:30 <monochrom> probably yahb knows about tagToEnum# etc
13:29:45 <dmwit> dsal: What confuses you about them?
13:30:55 <dsal> dmwit: one of them requires at least one.
13:32:54 <kw> Many may be less than some, right?
13:33:01 <dsal> some is one or more, many is zero or more.
13:33:05 <dmwit> Huh. I don't think I've ever gotten confused about which is which, but I don't know why. There's no good reason for it to be obvious which is which.
13:33:30 <dmwit> And I don't have a mnemonic (aka "bad reason") that I fall back on either. Weird!
13:33:59 <dsal> It's just a "I was reading the manual at the time" selection.
13:35:06 <dsal> I don't know what word would work better there, though. some vs. some1 I guess.
13:36:12 <ski> "some" sounds like an existential thing, implying at least one. "many", i guess, sounds just like allowing a plurality (like a list)
13:37:30 <dsal> "I got some of these" doesn't work with zero. "how many?" Does. But "I have many" doesn't work with zero...
13:38:26 <ski> well, i agree `many' isn't as obvious
13:38:32 <dmwit> ski: For me, "many" also implies at least one (in fact implies strictly more than one).
13:39:10 <ski> you don't read Kleene star as "many", sometimes ?
13:39:31 <dmwit> I think using "some" to have a meaning that includes "exactly one" as a possibility is only in my brain because of how often it's used in the phrase "there exists some X..." in math.
13:40:08 <dmwit> ski: There are always two directions for language: when I hear it, what do I think it means? and when I have a meaning I want to convey, what word do I use?
13:40:13 <dsal> My meetings mnemonic will be "how many?"
13:40:43 <dmwit> For "zero or more", I think I will happily choose to use "many". But for "many", I will not first think "at least zero".
13:40:43 * dsal accidentally added an extra word with autocorrect
13:40:56 <ski> now, one could maybe imagine `any' to be a counterpart to `some' .. but `any's already taken (and in the "other" way ..)
13:41:24 <dsal> any and and confuse me, but at least you can't accidentally get the wrong one
13:41:53 <ski> (.. people seem to sometimes be confused about "any". but, afaict, this comes from not taking positive vs. negative context into account)
13:41:56 <dolio> What is a word that means '0 or more'?
13:42:14 <dolio> Commonly.
13:42:20 <ski> "positive", if you ask french people
13:42:42 <dsal> nonNegativeQuantity
13:43:05 <dolio> That's 3 words, and long ones.
13:43:30 <dsal> Yeah.  Programmers tend to grab nearby words and make better use of them.
13:43:39 <dsal> English is confusing in general.
13:43:47 <dmwit> Perhaps "repeatedly" would be a better name for many.
13:43:50 <ski> mathematicians also grab words
13:44:00 <dmwit> But I think also just "learn which is which" is fine.
13:44:17 <dolio> Seems like that has the same problem.
13:44:33 <dmwit> Perhaps.
13:44:34 <dolio> You aren't repeating until the second time.
13:44:55 <Guest_68> --select nth element in listselect :: Int -> [a] -> aselect n xs = head(drop(n-1) (take n xs))
13:44:57 <dmwit> Dunno. I've repeated 0 times before. =)
13:44:59 <ski> or at least, you aren't properly repeating, until that time
13:45:09 <Guest_68> wasMoveAHit :: Int -> [a] -> BoolwasMoveAHit n xs  |select n xs == 1 = True  |otherwise = False
13:45:30 <dmwit> Guest_68: If there's going to be many more lines, I suggest choosing a pastebin and sending us a link.
13:45:43 <Guest_68> thats all i have
13:46:09 <Guest_68> the first function returns the value stored at the position in the list
13:46:23 <ski> Guest_68 : note that `(!!)' already exists
13:46:34 <ski> @type (!!)
13:46:35 <lambdabot> [a] -> Int -> a
13:46:48 <dmwit> Guest_68: Your wasMoveAHit claims to work on lists of any type. What do you think `wasMoveAHit 0 [EQ]` should return?
13:47:21 <dsal> And converting booleans to True and False looks weird.
13:47:22 <Guest_68> wasMoveAHit is the one that is broken
13:47:41 <ski> yea, you should not use guards there
13:47:50 <Guest_68> im just trying to get wasMoveAHit to work
13:47:57 <Guest_68> how would i format without guard
13:48:08 <Guest_68> and how do I use !!
13:48:14 <dmwit> dsal and ski are giving style suggestions. I am giving advice about making it work.
13:48:15 <ski> Guest_68 : first, try to use `if'-`then'-`else'
13:48:53 <ski> but yes, getting it to type-check first may be a useful initial move
13:49:33 <ski> > "hello" !! 3
13:49:36 <lambdabot>  'l'
13:49:36 <ski> > "hello" !! 4
13:49:38 <lambdabot>  'o'
13:50:01 <Guest_68> im still confused on format of functions
13:50:03 <ski> Guest_68 : that's how you use it (remember that `String's are lists of `Char'acters)
13:50:25 <Guest_68> I type wasMoveAHit :: Int -> [a] -> Bool
13:50:30 <Guest_68> and that makes sense
13:50:38 <Guest_68> but i get stuck immediately after
13:50:44 <ski> then that means `wasMoveAHit' promises to work for lists of anyb type of element
13:50:45 * hackage monadic-recursion-schemes 0.1.6.0 - Recursion Schemes for Monadic version.  https://hackage.haskell.org/package/monadic-recursion-schemes-0.1.6.0 (KatsutoshiItoh)
13:51:45 * hackage lsp-test 0.11.0.0 - Functional test framework for LSP servers.  https://hackage.haskell.org/package/lsp-test-0.11.0.0 (luke_)
13:51:46 <ski> however, the implementation you gave above does in fact not work for lists with any type of elements
13:51:59 <Guest_68> okay, what does it work for?
13:52:09 <ski> so, you need to either change your implementation, or your type signature (or both)
13:52:25 <ski> well, `select n xs' will give back some element of your list
13:52:38 <ski> then you're comparing that to `1', and so that element must be a number
13:53:20 <ski> (you can only compare things for equality that have the same type)
13:53:39 <monochrom> dsal: This is the tension between "plain English" words and mathematical terms.  "kleene star" is the most meaningful and accurate name, but how many programmers (recall the point is they flunked math) will understand?
13:53:44 <ski> and, since all elements of a list must have the same type, this means that all elements of your list must be numbers, then
13:54:15 <Guest_68> okay lets evaluate my wasMoveAHit :: Int->[a]->Bool
13:54:28 <Guest_68> im passing in an integer and a list and returning a bool
13:54:36 <Guest_68> i do not know what to type after that
13:54:45 * hackage monadic-recursion-schemes 0.1.6.1 - Recursion Schemes for Monadic version.  https://hackage.haskell.org/package/monadic-recursion-schemes-0.1.6.1 (KatsutoshiItoh)
13:54:53 * ski . o O ( "simple group","normal subgroup" )
13:55:02 <dsal> monochrom: I'd never heard it called that, so your point is probably valid.
13:55:10 <ski> Guest_68 : why are you comparing to `1' ?
13:55:29 <dsal> i.e., what's it a list of?
13:55:52 <Guest_68> I have 5 lists, each containing 5 numbers
13:56:02 <monochrom> In regular expressions, * is the Kleene star.
13:56:13 <Guest_68> r1 = [1,0,0,0,0]
13:56:23 <dolio> I guess `star` fits, but probably more people would be coming in here asking why it's named that.
13:56:37 <dsal> `star` and `plus`
13:56:42 <monochrom> and generally formal language theory. ("language" means a subset of strings)
13:56:59 <Guest_68> i just want to return true if the nth element in the xs list is a 1
13:57:03 <Guest_68> and otherwise false
13:57:07 <Guest_68> that is it
13:57:27 * ski idly ponders derivatives of monoid elements
13:57:38 <ski> Guest_68 : but why ?
13:57:54 <ski> Guest_68 : what idea is `wasMoveAHit' intended to express ?
13:58:02 <ski> why compare to `1' ?
13:58:42 <Guest_68> if it is a 1, the function that calls wasMoveAHit will change the 1 to a 2 to mark it as a hit
13:58:42 <dsal> :t \n xs -> xs !! n == 1
13:58:44 <lambdabot> (Eq a, Num a) => Int -> [a] -> Bool
13:59:10 <dsal> (note that that's a partial function)
13:59:21 <ski> Guest_68 : so does `1' indicate a hit ? or `2' ?
13:59:41 <monochrom> dsal: Etymologically, the names "many", "some", and "<|>" were first chosen in Parsec, this was before Applicative and Alternative. (Later, Alternative adopted these names.) So it was up to the authors of Parsec to think up what names made sense to them.
14:00:20 <dsal> monochrom: I often find that when I name things like that, the names don't make much sense to me later.
14:00:22 <Guest_68> 1 indicates the place can be marked hit, it returns true and it is then changed to a 2 to be denoted as already hit
14:00:29 <ski> (`wasMoveAHit' is also partial)
14:00:29 <monochrom> :)
14:00:46 * monochrom prefers wasMovieAHit :)
14:00:55 <ski> hehe :)
14:01:01 <dsal> Didn't they make a Battleship movie?
14:01:01 <wavemode_> wasMovieShit
14:01:08 <monochrom> They did!
14:01:35 <ski> Guest_68 : perhaps it would be nicer to use symbolic names like `Hit', instead of having to remember what things these numbers are meant to symbolize ?
14:01:40 <xerox_> wavemode_: const True
14:01:53 <monochrom> There was only one scene (or plot point) that's relevant to the Battleship game, and you can tell it's artificial, it's forced upon, completely silly and unnecessary.
14:01:58 <dsal> Guest_68: This is a sort of boolean blindness.  Rather than an infinite number of possibilities in which you care about two (or three?).  Just have exactly the possibilities you need.
14:02:53 <Guest_68> This is my first haskell project so maybe you can help me rethink my process
14:02:55 <monochrom> Someone needs to register the domain HitOrShit.com quickly!
14:02:57 <dsal> You don't need a function to map an integer to hit or miss if Hit or Miss are the actual stored values.
14:02:59 <Guest_68> https://pastebin.com/Z9cND1ch
14:03:19 <dsal> Guest_68: That thing where you list the four values.  Just make a type that has four possibilities. 
14:03:51 <dsal> data Status = Starting | UnHit | Miss | Hit
14:04:04 <dsal> Everything else gets super obvious.
14:04:12 <monochrom> Oh this is literally Battleship!
14:04:25 <dsal> wasMoveAHit becomes `!!`
14:04:30 <Guest_68> Haha yes 
14:04:31 <ski> monochrom : oh, i thought that was why you brought it up ?
14:04:45 <monochrom> No, dsal brought it up
14:04:46 <wavemode_> immutable battleship
14:04:49 <ski> (hm, or i suppose it was dsal)
14:05:06 <monochrom> I was not paying attention to this beginner project
14:05:27 <ski> Guest_68 : i'd also suggest having just one list of lists, rather that separately named lists
14:05:49 <monochrom> I only saw "how to get random numbers" and later "how to use !!" and I was like "OK I don't want to get into this"
14:06:58 <ski> Guest_68 : i also suggest changing the `replace' function to take an update-element function as parameter, rather than just a new value to replace the element with ..
14:07:29 <ski> (this would help, with updating a list of lists)
14:08:05 <dsal> A `Map Coord Status` would be pretty easy to work with here, though.
14:08:32 <ski> yea, that, and arrays, were already mentioned before
14:08:54 <Guest_68> im still stuck on making the type
14:08:59 <dsal> Which type?
14:09:06 <ski> `Status', presumably
14:09:15 <dsal> Oh.  That's probably a bad name.  I'm bad at naming things.
14:09:31 <Guest_68> "data locationStatus = Starting|UnHit|Miss|Hit"
14:09:39 <monochrom> I'm bad at short names, good at long names :)
14:09:41 <Guest_68> is throwing an error 
14:09:47 <ski> needs to start with upper case letter, Guest_68
14:10:18 <Guest_68> thank you, gotta love newbies
14:10:18 <ski> (also, please give your data constructors some air to breath, put some space around those `|'s)
14:10:42 <monochrom> For example, I really enjoy renaming "compact" to "for every open cover there exists subcover" haha
14:10:54 <monochrom> err, finite subcover!
14:11:21 * ski . o O ( "supports universal quantifier" )
14:11:24 <dsal> IMO, there are enough unicode codepoints that we don't really need to use words for any of our symbols.
14:11:30 <Guest_68> okay now to making lists
14:12:13 <monochrom> ski: So "has compact support" becomes "has universal quantifier support support"? >:)
14:12:20 <ski> haha
14:12:50 <monochrom> reminds me of one of those "strongly strong monad" or something
14:13:09 <Guest_68> how do i combine the status and the list of lists
14:13:22 <dsal> [[Status]]  ?
14:13:40 <ski> Guest_68 : just replace `0' by `Starting', `1' by `UnHit', and so on
14:13:58 <monochrom> dsal: I said I am deeply evil. You wonn't even fathom how deeply. Because I say that every pixel could be one of 2^24 colours, you can use that...
14:14:40 <dsal> monochrom: Like a multidimensional whitespace with PNG inputs.  Sounds pretty great.
14:15:02 <Guest_68> do I use the ` charachters
14:15:09 <ski> no
14:16:39 <Guest_68> https://pastebin.com/uF6vRQC2
14:17:10 <Guest_68> This is what I have modified
14:17:49 <monochrom> And does it have any problem?
14:18:13 <Guest_68> no, not on compilation at least
14:19:05 <dsal> Guest_68: I'd recommend getting rid of select and just using !! --they both fail the same way, but one is other people's code.  :)
14:19:31 <dsal> You could also get rid of replace in favor of lens, but don't do that...
14:19:58 <dsal> The nice thing about using Map here is that you get lookupWithDefault, which fits the "nothing interesting here" idea.
14:20:38 <ski> Guest_68 : in `replace', instead of one call to `take' and another to `drop', you could use `splitAt'
14:20:41 <dsal> You can definitely do this with lists, it's just the worst way.  :)
14:21:48 <Guest_68> I am not stuck to any method of doing this, im just trying to learn as i go through it. I now see the complications list has, lesson learned, is Map more effectice?
14:21:52 <Guest_68> *effective
14:22:18 <monochrom> Eventually it is valuable to learn let's say 3 different ways of representing this board. Each has its strength. You will need to know them all so you can make good judgments for future projects.
14:24:29 <ski> Guest_68 : i think, for the time being, it's probably simpler to just use lists
14:25:18 <Guest_68> Seeing as ive started down the list path already, my next goal is to be able to mark a place as hit
14:25:31 <dsal> Different data structures are good at different things.  lists are good at having stuff stuck to the front of them, being iterated sequentially, and doing a bit of pattern matching at the head.
14:25:46 * hackage shake-plus 0.1.2.0 - Re-export of Shake using well-typed paths and ReaderT.  https://hackage.haskell.org/package/shake-plus-0.1.2.0 (locallycompact)
14:25:53 <Guest_68> i guess that was my original goal when i got on lol, kind of got side tracked
14:35:19 <dsal> "got side tracked" is colloquially just "was programming"
14:35:52 <mniip> bizarre
14:36:56 <Guest_68> haha
14:36:59 <Guest_68> https://pastebin.com/NHmRLXmd
14:37:00 <fog> im totally stuck.. does anyone need any help with anything, I could use a break
14:38:00 <dsal> Guest_68: What is the String that markPosition is supposed to return?
14:38:07 <Guest_68> dsal ski & monochrome have been helping with my beginner problems
14:39:06 <Guest_68> Honestly not sure, I was thinking of something along the lines of "You hit the ship", "you missed" etc...
14:39:43 <fog> you have something like Int -> Int -> Bool ?
14:40:36 <dsal> I'm not sure I'd want to use strings for that.  Use something more useful, like... well, the select thing you already made.  Having LocationStatus -> String can do the rest.
14:40:45 <ski> Guest_68 : it might be nice to parameterize such functions on the current playing "field"
14:41:33 <wavemode_> Guest_68: what is "markPosition" meant to do? update a square on the board?
14:41:47 <Guest_68> yeah
14:41:58 <dsal> Oh.  It can't do that.
14:42:02 <Guest_68> parameterize ?
14:42:10 <dsal> The only thing it's allowed to do is return a string based on two numbers.
14:42:16 <wavemode_> then you either need a mutable data structure for your board, or a recursive game loop
14:42:20 <dsal> It must always return the same string given the same two numbers.
14:42:47 <Guest_68> These were functions I was building to then put in a recursive game loop
14:43:24 <ski> you could have the function compute the updated board
14:43:53 <Guest_68> Okay maybe im going down a rabbit hole of too many helper functions
14:44:24 <ski> nah, as long as each one has a clear enough given task, that should be fine
14:44:32 <dsal> It'd be good to imagine how they'd fit together at least.  A function that returns a String based on two integers is probably not going to be useful to your end goal.
14:44:39 <Guest_68> I want my loop to prompt input and decrement a counter, when counter hits zero or there are 4 hits on the board game stops
14:44:48 * enikar didn't understand yet, what was the goal of Guest_68's projectâ¦
14:44:55 <Guest_68> battleship
14:45:10 <enikar> oh, yes. I see.
14:45:19 <fog> not crouton detection?
14:45:50 <Guest_68> lol not crouton detection
14:46:20 <fog> so do you not need some underlying ships?
14:46:45 <Guest_68> I only need 1 ship, 1x4 and a function to place it
14:47:21 <Guest_68> i was thinking my "main" function calls the place function which just marks 4 places as unhit
14:47:41 <dsal> a
14:47:44 <dsal> A function can't do that.
14:48:08 <Guest_68> A function cant modify the values in the list
14:48:11 <Guest_68> ?
14:48:26 <dsal> A function can receive a list and produce a new list, but it can't just change stuff.
14:48:56 <fog> seems like you would need (Int,Int) -> (Bool,Int) -> [(Int,Int)], thats lower left hand position, horizontal/vertical as a bool, and length of ship, returning positions to update
14:49:00 <dsal> For the lifetime of your program, whenever a particular function gets specific input values, it will always return the same result.
14:50:00 <fog> dsal: what about using a monadic state environment? then you could pass an update function
14:51:01 <dsal> Sure, you can have a state action and do stuff to that, but the state is visible.
14:51:10 <fog> i like the type (x,s) -> (a,s). its like a state, taking an argument as an input, and returning an observation from updating s
14:52:29 <dsal> Right, and any time you give it the same state input, it'll give you the same resulting output.
14:52:32 * enikar thought: state is a bit too complex for an absolute beginnerâ¦
14:52:57 * ski idly recalls making a Battleships implementation in 6502, when given it as a Java laboration
14:53:13 <fog> here you could have ((Int,Int),Board) -> (Bool,Board), the position to test as the input, and if it hit or not as an observation, with the new board storing this aswell 
14:54:25 <ski> enikar : state-passing-style isn't that hard, i think ..
14:54:40 <fog> otherwise, if you dont care about the Bool, since an updated board is returned anyway, it would just be an "action" (Int,Int) -> Board -> Board 
14:54:52 <fog> but you might want the bool for printing a message to the user
14:55:34 <dsal> There are lots of ways to do it.  I'm just at the level of telling our Guest_68 that it has to be done at all.
14:56:08 <Guest_68> that all went over my head
14:56:08 <fog> state/act are pretty fundamental building blocks of recursive modifications
14:56:17 <fog> :t unfoldr
14:56:18 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
14:56:32 <fog> :t foldr 
14:56:33 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
14:56:39 <wavemode_> simple recursion does the trick, in any case. `loop board = do ... loop newBoard`
14:56:54 <ski> Guest_68 : anyway, lists are immutable. it is possible to make mutable things, but you should probably focus on getting some basic immutable programming under your belt, first
14:58:02 <fog> ski is saying you should have the updated thing being returned by the function
14:58:08 <Guest_68> so ill im looking to do right now is make a list of lists, modify one of the lists within the list given user input, and repeat until a base case is reached
14:58:15 <Guest_68> base case being 4 in a row
14:58:26 <Guest_68> or all turns used up
14:59:49 <fog> then you need; (Int,Int) -> [[Status]] -> [[Status]]
15:00:11 <Guest_68> a funtion with those properties?
15:00:17 <fog> with that type
15:00:47 <fog> thats your kind of 2d update function
15:01:12 <fog> then if you check the type of foldr;
15:01:14 <fog> :t foldr
15:01:15 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
15:01:20 <Guest_68> (Int,Int) being coordinate, -> [[Status]] being my list of lists -> and [[Status]] being the updated list im returning
15:01:28 <fog> right
15:01:29 <ski> Guest_68 : that could be the type of a function that takes a position (vertical and horizontal coordinates), a current board, and computes an updated board
15:01:33 <ski> yes
15:02:24 <dsal> You may also want to specify what you want the update to do.
15:03:03 <fog> see the `t a' in the type of foldr? thats an input list of (Int,Int), the attempts made by the player. then, folding over this list with the update function, and the initial board as the `b' argument, should give you the final board state as the `b' return type
15:04:17 <ski> perhaps the `Foldable' stuff is a bit too much of a complication, presently
15:04:38 * ski doesn't even know whether Guest_68 knows `filter' and `map', yet
15:04:42 <fog> right, because of the complication of unfolding that list of user inputs
15:04:42 <ski> (or list comprehensions)
15:05:12 <Guest_68> This is the most frustrating part of learning a new language, I can pseudo code the recursion fine like when i typed out for fog but the second I go to start coding it the syntax stumps me
15:05:21 <fog> fold is a pretty good first higher order function to learn!
15:06:32 <fog> but your right, maybe it would just be better to wrap all the recursion into a monadic loop, if there are user inputs and prints etc. sorry to jump the gun
15:06:34 * ski would suggest `map' or `filter', before `foldr'
15:06:44 <fog> fair 
15:06:59 <ski> also, probably first writing specific cases, like `toUppers', manually
15:07:04 <mniip> dammit the kw person left
15:07:12 <mniip> meanwhile I made this
15:07:16 <mniip> % whoAmI (Left 3)
15:07:16 <yahb> mniip: "base:Data.Either.Left"
15:07:51 <fog> % :t whoAmI
15:07:51 <yahb> fog: a -> [Char]
15:08:04 <dsal> % whoAmI whoAmI
15:08:04 <yahb> dsal: "not a constructor"
15:08:15 <dsal> Well, I know who I'm not now.
15:08:32 <fog> % whoAmI ((:) 3 [])
15:08:32 <yahb> fog: "ghc-prim:GHC.Types.:"
15:08:58 <ski> % fix whoAmI
15:09:03 <yahb> ski: "[Timed out]
15:09:21 <fog> huh, a multiple arity constructor identifier 
15:09:25 <mniip> you broked it :(
15:09:42 <dsal> That's what happens when you try to fix something that isn't already broken.
15:09:45 <mniip> redefined it for ya
15:09:47 <fog> % whoAmI ((1,2,3))
15:09:47 <yahb> fog: "ghc-prim:GHC.Tuple.(,,)"
15:10:45 <fog> % whoAmI (((1,2),3))
15:10:45 <yahb> fog: "ghc-prim:GHC.Tuple.(,)"
15:10:58 <fog> not nested...
15:11:40 <mniip> could probably make it recursive at this point
15:11:49 <mniip> but there are some oddballs
15:12:11 <fog> what about a recursively nested hetrogenous state? 
15:12:44 <fog> for unfolding nested hetrogenous containers...
15:13:14 <fog> probably lens already has this 
15:13:52 <mniip> well as you can see from the type this doesn't have any constraints
15:13:58 <mniip> just pure GHC magic
15:14:35 <Guest_68> Why am I recursing the (int,int) if the user specifies their move within the recursive loop and the change is made before passing the changed list on the value of the users row/col change is unneeded in the next iteration right?
15:14:36 <fog> oh yeah, pretty cool...
15:15:36 <fog> Guest_68: thats why ski was saying I shouldnt have told you to use fold
15:15:46 <fog> sorry, my bad
15:16:18 <fog> basically your loop is kind of doing it one stage at a time
15:16:43 <fog> and also doing one stage at a time of the unfolding of the moves, in an IO monadic environment....
15:17:15 <mniip> for some reason nullary constructors actually all contain 1 word worth of non-pointer data?
15:17:43 <ski> Guest_68 : i didn't understand your question, could you rephrase ?
15:17:43 <fog> % whoAmI ()
15:17:43 <yahb> fog: "ghc-prim:GHC.Tuple.()"
15:19:25 <mniip> oh yeah
15:19:28 <Guest_68> https://pastebin.com/qyA0T2eR
15:19:50 <Guest_68> ski 
15:19:58 <mniip> % x = unsafeCoerce (Just "foo") :: Either Int String
15:19:58 <yahb> mniip: 
15:19:59 <mniip> % x
15:20:00 <yahb> mniip: Right "foo"
15:20:05 <mniip> % whoAmI x
15:20:06 <yahb> mniip: "base:GHC.Maybe.Just"
15:20:09 <ski> `[(r1),(r2),(r3),(r4),(r5)]' could be just `[r1,r2,r3,r4,r5]'
15:20:21 <ski> and you don't really need to name the individual lists, either
15:20:27 <fog> Guest_68. play :: [[Status]]->IO [[Status]]
15:20:32 <ski> you could say
15:21:32 <ski>   initialBoard = [[Starting,Starting,Starting,Starting,Starting]
15:21:37 <ski>                  ,[Starting,UnHit   ,UnHit   ,UnHit   ,UnHit   ]
15:21:43 <ski>                  ,...
15:21:45 <ski>                  ]
15:22:03 <dsal> > replicate 3 (replicate 3 True)
15:22:04 <lambdabot>  [[True,True,True],[True,True,True],[True,True,True]]
15:22:36 <fog> % replace n xs x = take (n-1) xs ++ [x] ++ drop n xs
15:22:37 <yahb> fog: 
15:22:48 <ski> Guest_68 : you're comparing `row' with a `Char'acter, but `row' is a `String'
15:24:02 <Guest_68> okay one step at a time
15:24:02 <ski> Guest_68 : and to be able to do "recurse with updated list", then you must have that as a parameter of your loop function
15:24:24 <fog> % replace2d (i,j) xs x = replace i xs (replace j (xs !! i) x)
15:24:24 <yahb> fog: 
15:24:40 <Guest_68> im going to leave the lists as theyre labelled right now assuming they work (even though theyre ugly)
15:25:05 <fog> % replace2d (1,2) (replicate 3 (replicate 3 True)) False
15:25:05 <yahb> fog: [[True,False,True],[True,True,True],[True,True,True]]
15:25:10 <dsal> Guest_68: the repeat/repeat thing + a list of other positions means you can do... ^
15:25:34 <dsal> (suddenly foldr seems really appealing)
15:25:35 <Guest_68> eli5
15:25:41 <dsal> > replicate 3 (replicate 3 True)
15:25:43 <lambdabot>  [[True,True,True],[True,True,True],[True,True,True]]
15:25:50 <dsal> So, that says, "give me three lists of three lists of True"
15:26:00 <dsal> So your initial board with everything in the Starting position
15:26:05 <dsal> (or state or whatever)
15:26:10 <ski> fog : fwiw, i suggested before to pass an update callback to `replace'
15:26:12 <dsal> Then you set the other states specifically.
15:26:48 <Guest_68> okay that makes sense
15:26:56 <dsal> So you place UnHit in [(1,1), (1,2), (1,3), (1,4)]  -- then you only have to worry about where you place stuff on a blank board.
15:27:11 <fog> ah, yeah, i was just having to make do with replace and (!!) as access. but its better to combine replace and access to make update, sure
15:27:22 <dsal> "Just use lens"
15:27:31 * ski 12meows
15:28:41 <fog> % update n xs f = replace n xs (f (xs !! n)) 
15:28:41 <yahb> fog: 
15:28:44 <Guest_68> can we work on recursive loop rn
15:28:58 <Guest_68> im so lost
15:29:09 <fog> % update 1 (replicate 3 True) not
15:29:09 <yahb> fog: [False,True,True]
15:29:33 <dsal> Which loop?
15:29:52 <Guest_68> what should my play loop have in it
15:30:02 <ski> Guest_68 : if you want to be able to pass on the updated board to the recursive call of the loop function, you probably want to have the board as an explicit parameter of that function, yes ?
15:30:52 <Guest_68> explicit parameter of that function?
15:30:57 <wavemode__> Guest_68: can I illustrate something for you? this is a program which simply prints an increasing number every 1 second: https://gist.github.com/wavemode/171b43de94319597abbd210eef06ceff
15:31:04 <wavemode__> Notice that I never directly modify the number. I have to make a new number based on the old number, and recurse with that as a parameter. Every binding in Haskell is immutable (unchangeable).
15:31:06 <dsal> It takes a board and it gets a board.
15:31:15 <wavemode__> Now look at this pseudocode for battleship: https://gist.github.com/wavemode/25f48e8a9746c6cdaff5f1bc949fc422
15:31:16 <fog> % replace2d (i,j) xs x = update i xs (\ys -> replace j ys x)
15:31:16 <yahb> fog: 
15:31:22 <wavemode__> The same logic and structure applies. Each loop, we have to create a new board based on the old board and the user's guess. The old board is immutable; we can't change it after creating it.
15:31:31 <fog> % replace2d (1,2) (replicate 3 (replicate 3 True)) False
15:31:31 <yahb> fog: [[True,False,True],[True,True,True],[True,True,True]]
15:31:41 <fog> ok that works
15:32:30 <ski> Guest_68 : ah. sorry, i didn't notice your `play' signature already specifies this. however, if you also want to do I/O in it, you need to adapt the signature as fog suggested
15:32:53 <Guest_68> play :: [[Status]]->IO [[Status]]  putStrLn "Enter row to fire upon: (1,2,3,4,5)"  row <- getLine  putStrLn "Enter column to fire upon: (1,2,3,4,5)"  col <- getLine  if row == '1'    then --Check if hittable      --then mark hit  --recurse with updated list
15:33:24 <Guest_68> https://pastebin.com/awSSa6XM
15:33:38 <ski> % :t \(i,j) xss y -> update i xss (\xs -> update j xs (\x -> y))
15:33:38 <yahb> ski: (Int, Int) -> [[t]] -> t -> [[t]]
15:34:06 <ski> Guest_68 : you're still not defining `play' properly
15:34:21 <ski> you're giving a type signature, but there's no start of the actual defining equation
15:34:46 <ski> you can't just type in commands after the type signature, and expect them to be associated with it
15:34:50 <fog> Guest_68: im not sure that you will need the "if"... can you incorporate the replace2d function to do that instead? 
15:35:03 <ski> there should be an equals sign, with `play' on the left side of it
15:35:42 <Guest_68> can you demonstrate
15:35:43 <fog> and a "do" to start the imperative IO block 
15:35:49 <ski>   play :: ...
15:35:51 <ski>   play = ...
15:35:56 <Guest_68> ah 
15:35:57 <Guest_68> thanks
15:35:58 <ski> that would be a good start
15:36:05 <ski> (you'll need to adapt it)
15:36:12 <fog> :t play x = do (return x)
15:36:13 <lambdabot> error:
15:36:13 <lambdabot>     parse error on input â=â
15:36:13 <lambdabot>     Perhaps you need a 'let' in a 'do' block?
15:36:20 <fog> oops
15:36:40 <fog> % :t \x = do (return x)
15:36:40 <yahb> fog: ; <interactive>:1:4: error: parse error on input `='
15:36:44 <fog> eh?
15:36:47 <fog> oh...
15:36:53 <fog> % :t \x -> do (return x)
15:36:53 <yahb> fog: Monad m => a -> m a
15:37:08 <fmardini> hi, i was experimenting with Scotty and http basic auth, I want to use save the passed in user to basicAuth in a variable in the surounding context, to eventually pass it to the view, https://hackage.haskell.org/package/wai-extra-3.0.29.1/docs/Network-Wai-Middleware-HttpAuth.html
15:38:04 <fmardini> is it at all possible? Initially I wanted to put the call inside a state monad and save that, but couldn't figure out how to set my moand transformer stack
15:39:26 <dsal> Guest_68: Consider:   `row <- read <$> getLine`
15:40:16 <ski> or just `let row :: Int; row = read rowStr'
15:40:38 <dsal> Yeah...  Just don't compare the string.  :)
15:40:56 <Guest_68> wait so which one do i do
15:41:00 <dsal> or perhaps a helper:   readRowAndColumn
15:41:16 <ski> Guest_68 : have you seen `<$>' before ?
15:41:25 <Guest_68> no
15:41:29 <Guest_68> but it is easy to type
15:41:30 <fog> % read @(Int,Int) ("1","2")
15:41:30 <yahb> fog: ; <interactive>:43:17: error:; * Couldn't match type `([Char], [Char])' with `[Char]'; Expected type: String; Actual type: ([Char], [Char]); * In the second argument of `read', namely `("1", "2")'; In the expression: read @(Int, Int) ("1", "2"); In an equation for `it': it = read @(Int, Int) ("1", "2")
15:41:31 <ski> then don't do that, yet
15:41:56 <ski>   rowStr <- getLine
15:41:59 <dsal> % read @(Int,Int) "(1,2)"
15:41:59 <yahb> dsal: (1,2)
15:42:00 <ski>   let row :: Int
15:42:04 <ski>       row = read rowStr
15:42:21 <fog> % read @(Int,Int) "1  3"
15:42:21 <yahb> fog: *** Exception: Prelude.read: no parse
15:42:37 <ski> Guest_68 : putting that in your `do' should parse ("convert") the `String' to an `Int' number
15:42:38 <Guest_68> im assuming good input
15:43:11 <ski> yea, gracefully handling parse errors is a further complication which you could tackle later
15:43:31 <dsal> Even a valid number might not be valid within your coordinate space.
15:43:51 <dsal> But shed strings sooner rather than later.  :)
15:44:03 <Guest_68> there is so much going on, i feel like this should be so much simpler
15:44:11 <Guest_68> do i need to build a replace2d
15:44:17 <Guest_68> what problem does that solve
15:44:30 <Guest_68> do i ned a helper function for handling the getLine
15:44:35 <Guest_68> or does read do that
15:44:38 <dsal> Well, it is pretty simple, but you're doing a few different things.
15:44:47 <dsal> read converts strings to whatever.
15:44:52 <dsal> getLine gives you a string.
15:45:09 <Guest_68> got it
15:45:30 <dsal> Having a helper   `getPosition  :: IO Point`  might be helpful so you don't have to think about it all at once.
15:45:43 <Guest_68> https://pastebin.com/1WGswBKg
15:45:46 <dsal> The replace/replace2d functions were what you build your modification upon.
15:46:25 <dsal> That's wrong for a few reasons, as I'm sure the compiler tells you.  :)
15:46:37 <fog> % :t \(board::[[Bool]]) -> do ij <- read @(Int,Int) <$> getLine; return $ replace2d ij board True
15:46:37 <yahb> fog: [[Bool]] -> IO [[Bool]]
15:46:54 <ski> Guest_68 : still missing "definition head"
15:47:31 <mniip> fog, well I've implemented
15:47:34 <mniip> % pp "foo"
15:47:34 <yahb> mniip: "(ghc-prim:GHC.Types.: (ghc-prim:GHC.Types.C# 102#) (ghc-prim:GHC.Types.: (ghc-prim:GHC.Types.C# 111#) (ghc-prim:GHC.Types.: (ghc-prim:GHC.Types.C# 111#) (ghc-prim:GHC.Types.[] 139709778298664#))))"
15:47:41 <mniip> which is like half of GHC.Vacuum already
15:48:00 <dsal> My suggestion for pushing read into the IO action with fmap was good.  Not really expected to be understood on day one.  ski's suggestion of just converting the strings makes more sense.  If you make the helper, you can get your two strings and have it return  `(read row, read col)`
15:48:33 <fog> mniip: what is that for?
15:48:38 <dsal> Er, I don't know what I meant by "was good"
15:48:49 <dsal> It's what I'd do, but not necessarily what you should do.
15:48:56 <solonarv> even better: instead of getLine and later 'read'ing the result, just use 'readLn'
15:49:00 <mniip> I don't know?
15:49:07 <fog> :t readLn
15:49:08 <lambdabot> Read a => IO a
15:49:33 <fog> its a shame we cant do that in yahb to demonstrate its use
15:49:52 <fog> unless using put?
15:50:08 <fog> might be too complicated
15:50:27 <fog> %:t readLn @(Int,Int)
15:50:35 <fog> % :t readLn @(Int,Int)
15:50:35 <yahb> fog: IO (Int, Int)
15:51:06 <mniip> readLn gives me pascal vibes
15:51:37 <fog> % :t \board -> readLn @(Int,Int) >>= \ij -> update2d ij board True
15:51:37 <yahb> fog: ; <interactive>:1:40: error:; * Variable not in scope: update2d :: (Int, Int) -> t -> Bool -> IO b; * Perhaps you meant one of these: `Seq.update' (imported from Data.Sequence), `IM.update' (imported from Data.IntMap), `M.update' (imported from Data.Map)
15:51:55 <ski> there ought to be `withInputFromString',`withOutputToString',&c. stuff, in Haskell
15:51:58 <ski> (as in Scheme)
15:52:03 <Guest_68> okay thank you for all your help but im going to take a break and try to make sense of all yalls input
15:52:26 * ski nods to Guest_68
15:52:30 <fog> % update2d (i,j) xs f = update i xs (\ys -> update j ys f)
15:52:30 <yahb> fog: 
15:52:59 <ski> fog : now do that, using `Cont'
15:53:00 <fog> % update2d (1,2) (replicate 3 (replicate 3 True)) not
15:53:00 <yahb> fog: [[True,False,True],[True,True,True],[True,True,True]]
15:53:04 <dsal> Guest_68: the path isn't super short, but once you get there, you realize almost everything you want to do is a tiny bit of work behind a large vocabulary.
15:53:27 <Guest_68> last question is what are the % and ":t
15:53:38 <Guest_68> *":t"
15:53:47 <fog> % is just for the irc chat, its a robot with ghci on
15:53:47 <yahb> fog: ; <interactive>:78:25: error: parse error on input `,'
15:53:59 <ski> Guest_68 : `%' is just a character that tells yahb to listen to what comes after
15:54:18 <Guest_68> thx
15:54:19 <fog> :t is short for :type, it give the type of a function
15:54:25 <lambdabot> error: parse error on input âtypeâ
15:54:28 <ski> Guest_68 : `:t' is short for `:type', and is an interactor command. yahb just runs GHCi. lambdabot doesn't really
15:55:01 <fog> % :t "hello"
15:55:02 <yahb> fog: [Char]
15:55:33 <mcwitt> I've seen it mentioned that Reader and Writer "commute" in monad transformer stacks.But I'm struggling to implement `Monoid w => WriterT w (Reader r) a -> ReaderT r (Writer w) a` (and not seeing matches from hoogle). Am I misunderstanding what "commute" means here?
15:55:57 <ski> @unmtl WriterT w (ReaderT r m) a
15:55:59 <lambdabot> r -> m (a, w)
15:56:07 <ski> @unmtl ReaderT r (WriterT w m) a
15:56:07 <lambdabot> r -> m (a, w)
15:56:54 <mcwitt> :ski Whoa, so they are literally the same. Ok. Need to wrap my head around this a bit more
15:57:03 <ski> @type ReaderT . (WriterT .)
15:57:04 <lambdabot> (r -> m (a, w)) -> ReaderT r (WriterT w m) a
15:57:44 * ski hasn't seen the `:' sigil, before ..
15:58:14 <wavemode_> :ski all the cool kids are doing it
15:58:15 * ski suspects mcwitt of being a Lisper
15:59:04 <monochrom> I say Racket :)
15:59:16 <ski> yea, that counts :)
15:59:27 <ski> (perhaps Dylan, too ?)
15:59:28 <mcwitt> haha, no, just bad at IRC
16:00:14 <monochrom> lang twitter is like lang racket except you write #foo instead of :foo  >:)
16:00:35 <mcwitt> perhaps too much typing into ghci
16:00:41 <ben_m> @<nick> is the new hotness that's been invading IRC in recent years
16:00:42 <lambdabot> Unknown command, try @list
16:00:50 <monochrom> haha I forgot ghci
16:01:06 <ski> heh, monochrom. i immediately thought of that, too
16:01:28 <ski> ben_m : we're attempting to keep it at bay, as best we can
16:01:46 <monochrom> #@:ski,: you can't go wrong with #@:ski,:
16:02:38 <ski> (one of the more confusing ones is when people say to me "<ski> blah blah ..")
16:03:00 <dsal> Guest_68: When you get all pro, you'll realize that update2d is just `over (ix r . ix c)` -- most of your code just slips away...
16:03:28 <monochrom> No, you use sqlite to store the board.
16:03:48 <dsal> That does sound like something I'd do.
16:04:47 <ben_m> Is `over' a Lens thing?
16:04:55 <dsal> Over is %~
16:05:11 <dsal> > over (ix 1 . ix 0) not (replicate 3 (replicate 3 True))
16:05:12 <lambdabot>  [[True,True,True],[False,True,True],[True,True,True]]
16:05:18 <fog> anyway, heres what iv got so far, kind of hit a brick wall before getting it working though; https://github.com/fog-hs/FogNet
16:05:27 <dsal> > (replicate 3 (replicate 3 True)) & ix 1 . ix 0 %~ not
16:05:29 <lambdabot>  [[True,True,True],[False,True,True],[True,True,True]]
16:05:44 <fog> so fold is too advanced but lens is ok!?
16:06:11 <dsal> You do it all manually, then you do folds, then you do lenses, then you do it all manually again.
16:06:11 * ski is surprised fog didn't try out the `Cont' suggestion yet
16:06:26 <fog> oh, i didnt know what you meant sorry
16:06:54 <ben_m> @info over
16:06:54 <lambdabot> over
16:06:57 <ben_m> Thanks
16:06:59 <dsal> haha
16:07:06 * dsal pictures army radio guys
16:07:10 <ski> your `update2d' is written in CPS, fog
16:07:52 <ski> oh, right. you need an indexed version
16:09:22 <monochrom> ben_m: Guess what this means:
16:09:38 <monochrom> @info do { x <- foo; return (bar x) }
16:09:38 <lambdabot> foo >>= \ x -> return (bar x)
16:10:33 <d34df00d> Let's say I have a stack-based project and I'd also like to allow running it without compiling, using the usual shebang stuff.
16:10:43 <d34df00d> So I do `#! env stack` as the first line
16:11:16 <ben_m> monochrom, which part?
16:11:24 <d34df00d> Is it possible to tell stack to use stack.yaml that's already naturally residing nearby, as opposed to duplicating stack options as described on https://github.com/commercialhaskell/stack/wiki/Script-interpreter ?
16:11:29 <monochrom> What "@info" means
16:11:47 <ben_m> Seems like it's @undo
16:12:01 <monochrom> Yes. Hamming distance = 2. Autocorrection.
16:12:19 <monochrom> Another example:
16:12:23 <monochrom> @typo sin
16:12:24 <lambdabot> Floating a => a -> a
16:12:25 <dsal> @unfoo do { x }
16:12:25 <lambdabot> x
16:12:34 <Guest_68> what is the difference between :: and =
16:12:54 <monochrom> The same difference between term and type.
16:13:03 <ben_m> monochrom, gotcha
16:13:50 <fog> :: is read "type", its for defining the type signature, the equals is for the implementation of the function and goes below the type signature
16:14:03 <dsal> @peer \a b c d ->  f a b c d
16:14:03 <lambdabot> \4 B c d -> f a 8 ( d
16:14:29 <ski> s/defining/specifying
16:14:41 <monochrom> I like lambdabot's typo allowance because it has a @slap command that I always like to misspell for comical relief.
16:14:44 <monochrom> @snap monochrom
16:14:45 * lambdabot activates her slap-o-matic...
16:14:49 <ski> Guest_68 : `::' is for "interface", `=' for "implementation"
16:14:56 <ski> @botslap
16:14:56 <lambdabot> Unknown command, try @list
16:15:07 <dsal> @lust
16:15:07 <lambdabot> What module?  Try @listmodules for some ideas.
16:15:19 <ski> @keal
16:15:19 <lambdabot> i aint running that on my puter
16:15:40 <monochrom> You will have better luck with @botsnap :)
16:15:53 <ski> istr `botslap' working in the past ..
16:15:56 <monochrom> the allowance is 2 so use it wisely!
16:15:58 <ski> oh
16:16:01 <ski> @botsmack
16:16:01 <lambdabot> :)
16:16:06 <ski> that's the one i was thinking about
16:16:13 <monochrom> that's better :)
16:16:19 <monochrom> @slit monochrom
16:16:19 <lambdabot> Maybe you meant: slap quit list let elite
16:16:23 <monochrom> oops
16:16:24 <dsal> Is there a way to ask how it resolved something?  e.g. what is @peer ?
16:16:48 <monochrom> I think no. You have to do your own exhaustive search.
16:16:55 <monochrom> But @list may help
16:17:58 <ski> @brain
16:17:58 <lambdabot> Has it ever occurred to you, Pinklet, that your scarf is
16:17:58 <lambdabot> constricting the bloodflow to your head?
16:18:54 <monochrom> Also try @slay some day (= @slap)
16:21:36 <Guest_68> Okay im sorry if im getting annoying you all are the only group i have found that can quickly/reliably answer questions re: haskell. My understanding of my program so far is that I should have a loop function "play" that takes in a list of lists of status's,  within play I prompt the user for their row and column using read and getline to change
16:21:37 <Guest_68> them to workable numbers, i then call replace2d that will change my list of lists and i can pass that back into itself...
16:22:33 <ski> that sounds like a plan, Guest_68
16:41:15 * hackage zeolite-lang 0.6.0.0 - Zeolite is a statically-typed, general-purpose programming language.  https://hackage.haskell.org/package/zeolite-lang-0.6.0.0 (ta0kira)
16:45:18 <Nilgeist_> So, i want to implement a few board games. My thinking is to create a board game monad typeclass who's instances are the board game. Then Ill write some generic AI for the typeclass, and (hopefully) create a high level interface with haskell-gi. Is this strategy good? Is there such a thing as a monad typeclass?
16:47:13 <dmwit> Why a typeclass and not just a type?
16:47:41 <dmwit> "Is there such a thing as a monad typeclass?" depends a lot on what you mean by "monad typeclass". If you mean a typeclass whose instances are monads, then yes.
16:50:18 <monochrom> I make my own monadic type classes all the time. Two every year. But not as general as one single class for all games.
16:50:36 <monochrom> It is more like one class per game.
16:52:05 <monochrom> The right thing to do is to not generalize until you see what's there to factor out.
16:53:43 <Nilgeist_> Suppose that all board games needed a "turn" function to determine who's turn it is; so the "board game monad typeclass" requires a "turn" function to be implemented, and I want to make sure my higher-order functions are able to use "turn". That's sort of what I'm aming for, but the algebraic types are still a bit hazy to me
16:54:39 <Nilgeist_> Well, the idea of the typeclass is that things like minimax with pruning or monte carlo don't really need to know the details of the game
16:55:19 <Nilgeist_> i just don't want to fiddle with the AI once I try different rulesets
16:56:52 <solonarv> aha, that makes sense
16:57:27 <Nilgeist_> it's on the order of a few functions: who's turn it is, list all legal moves, generate random legal move, and a static evaluator. If i can have those, the AI should be able to work on most rulesets that I give it
16:57:53 <solonarv> so your AI needs functions like 'legalMoves :: GameState -> [Move]' and 'applyMove :: Move -> GameState -> GameState', right
16:58:26 <Nilgeist_> exactly!
16:58:41 <solonarv> the most "low-tech" approach is to just pass those functions in
16:58:45 <solonarv> no typeclass, no nothing
16:59:16 <Nilgeist_> not a bad idea!
16:59:21 <monochrom> This really sounds like mistaking Haskell class for OOP "class".
16:59:49 <solonarv> all a typeclass does here is save you from having to pass those functions in explicitly
16:59:53 <Nilgeist_> i was mostly thinking of taking advantage of do notation to prevent multiple game states flying around.
17:00:23 <Nilgeist_> in a similar way to IO preventing multiple worlds flying around
17:00:52 <Nilgeist_> i'm open to not using an OOP shape if it's better
17:00:58 <Nilgeist_> non OOP shape*
17:01:18 <solonarv> but you *need* multiple game states flying around! else how can your AI ask questions like "okay, how would the game state look if I did this move? hm that's no good, what about this move?"
17:01:25 <asuper> At the request of SPJ on Gitlab, I wrote a little blog post thing about Haskell errors and my suggestions to make them more newbie-friendly. I'm not quite done with it, but I did cover a few of the more common errors already. Would anybody be willing to look it over to see if it's like constructive and useful and not hot garbage?
17:01:33 <solonarv> (at least) three game states, right there!
17:02:07 <asuper> If it's hot garbage and not helpful I'd kinda want to know now before doing a much more extensive thing with even more errors covered
17:02:07 <Nilgeist_> oh, that's true. hmm. might be some philosophical error in my approach in my head somewhere
17:02:47 <monochrom> solonarv, a newtype around s->[(a,s)] can do wonder in both honouring game tree exploration and monadic abstracting away from it.
17:03:05 <solonarv> yes, that is a useful approach
17:03:21 <solonarv> (note: 'StateT s [] a' is exactly that)
17:04:20 * Nilgeist_ is looking up StateT
17:04:44 <asuper> It lets you add state to a monad. So if I wanna like keep track of how many times I've done a thing while doing some IO
17:04:55 <asuper> I can use StateT Int IO as my monad type
17:05:05 <asuper> and then do things like "modify (+1)" to change the state of the int
17:05:11 <asuper> and get the final state at the end 
17:05:16 <asuper> or the current state at any time
17:06:12 <solonarv> correct, although I'm wary of StateT on top of IO specifically
17:06:31 <asuper> Yeah it has weird as hell interactions with exceptions 
17:10:04 <Nilgeist_> I might just to a low tech solution. But theoretically, could I create a new instance of the monad with something like `splitState :: GameState ()->(GameState (), GameState ())` for use within the AI? or is that poor design?
17:10:35 <asuper> Unless GameState is a struct of `IORef` or something, then you don't need to
17:11:09 <asuper> You can't mutate Haskell values. So you can pass the same `GameState` around wherever you want without issue.
17:12:20 <Nilgeist_> Ah. I was hoping to avoid manual passing with do notation. Maybe that's a weird thing for me to design around though
17:13:20 <solonarv> why is 'GameState' a monad now? that doesn't sound right.
17:14:22 <Cale> You might be able to use something like StateT GameState [] to explore the game tree
17:14:25 <Nilgeist_> oof, its inside the gameboard monad
17:14:37 <Nilgeist_> yeah, i am considering StateT
17:15:07 <sm[m]> d34df00d: you could add --stack-yaml=... to stack command in the script
17:15:07 <solonarv> it should just be a plain old data structure. like, for chess: data Piece = King | Queen ...; data Player = White | Black; data GameState = GameState { gsCurrentPlayer :: Player; gsPieces :: Array (Int, Int) (Piece, Player) }
17:15:41 <solonarv> (feel free to replace 'Array ...' with another data structure to represent the board state, of course.)
17:17:26 <Nilgeist_> mhmm. right now im leaning towards a simple data structure and then handing the minimax/monte carlo AI 3 or four functions it needs
17:17:47 <d34df00d> sm[m]: yay, that's exactly solves it, thanks!
17:18:12 <Nilgeist_> AI is easy enough with a closure
17:28:52 <pinusc> Hey all
17:29:37 <pinusc> So I'm writing a presentation on Haskell for my CS Programming Languages Class. I've been studying Haskell so I have a decent grasp of the basics of the language. Still, I want the presentation to be entertaining and showcase the most important/coolest features of the program
17:29:58 <pinusc> So my question is: if you could speak for 10 minutes about haskell and convince someone to try it, what would you talk about?
17:30:16 <wavemode__> I'd complain about java
17:31:37 <dmwit> pinusc: https://stackoverflow.com/a/7868790/791604
17:33:40 <dmwit> pinusc: It's also incredibly good at putting together small languages, so I might consider showing how you can implement an entire DSL in about 30 lines of code as a sort of "look how convenient algebraic data types and pattern matching is" thing.
17:34:23 <dmwit> pinusc: Depending on my audience, QuickCheck might be an option of a shiny thing to show off.
17:37:42 <pinusc> Huh. The DSL idea sounds really interesting. The class covered the basic building blocks of programming languages (including parsing) so it would be an excellent example
17:37:58 <pinusc> Also thanks for the link, there's a couple interesting examples there
17:39:53 <ski> @where whyfp
17:39:53 <lambdabot> "Why Functional Programming Matters" by John Hughes in 1984 at <http://www.cse.chalmers.se/~rjmh/Papers/whyfp.html>
17:58:20 <fog> 17:18:12 <Nilgeist_> AI is easy enough with a closure
17:58:43 <fog> Nilgeist_: what does closure mean in this context?
18:00:06 <fog> also, if your considering monte carlo, i was considering something like this could be helpful; https://pastebin.com/raw/6Pbs6pyf
18:05:06 <fog> basically, you dont want to be wasting training rounds, like "is training with this leaning rate better", where you would have to do a bunch of steps under this regime, only to then decide it was not a good strategy, and to reject all of that learning
18:05:58 <fog> so instead, you could kind of stochastically update some hyperparameter like learning rate, and store the observed quality of learning under this choice of hyperparameter
18:06:41 <fog> which, with these carried statistical observations, should allow hyperparameters to be adaptive, without wasting any learning rounds 
18:07:56 <fog> its important to take care with this approach however, as you dont have the advantage of starting from the same initial conditions as if you branched paths for these different hyperparameter choices 
18:08:52 <fog> eg. if using convergence rate per 100 training steps, this curve is much more steep close to initialisation. 
18:09:20 <fog> meaning these online observations would need to compensate for the lower convergence at more advanced stages of learning
18:10:26 <fog> obviously, as the learning is stochastic, there is some random influence over each step. ie, you need a large number of trails to see which choice of hyperparameter is best 
18:11:24 <fog> and if staggering these, like taking one step with one set of hyperparameters, and another with a different set, alternating back and forth, to eventually reject one set, and make a new hypothesis to see if its better
18:12:36 <fog> if you were going to try to alternate between a large number of choices of different hyperparamters, and needed a large number of each to get a good average of the random nature of this convergence, then your going to be in a much shallower rate of convergence by the time you have enough data
18:13:25 <fog> idk how to calculate all this stuff properly, so i was just going to try jamming it all into another net, which could hopefully learn after being used to train a large number of nets, to choose the hyperperametes best
18:13:50 <fog> solonarv: maybe that would fit into the idea you had with enumerating possible moves
18:14:17 <fog> though obviously these are parametric choices, ie not discreet
18:16:24 <fog> (btw, was meaning learning rate to basically be the width of the range for drawing the random number additions to edge weights at each neuron)
18:16:41 <fog> % randomIOR (0,1)
18:16:41 <yahb> fog: ; <interactive>:80:1: error:; * Variable not in scope: randomIOR :: (a0, b0) -> t; * Perhaps you meant one of these: `randomIO' (imported from System.Random), `randomR' (imported from System.Random), `randomRIO' (imported from System.Random)
18:17:18 <fog> % randomRIO (0,1::Double)
18:17:18 <yahb> fog: 2.4999341664371122e-2
18:18:18 <fog> so you want to be lowering the learning rate adaptively as the net converges, motivating this whole adaptive hyperparameters thing 
18:18:51 <fog> adding only very slight noise to the neuronal edge weights as it approaches convergence 
18:19:34 <justsomeguy> Heh. Some times when I join this channel I wonder if I've accidentally stepped into #rocketscience, which is cool.
18:19:46 <fog> you dont want to be making only slight changes before the net is converged as it would take too many updates 
18:21:42 <fog> here was my first attempt before I had this idea (basically motivating it, and also, motivating not using list!)
18:21:43 <fog> https://pastebin.com/raw/cmRR7mh0
18:55:27 <Nilgeist> Sorry, i come from a Racket background... Closures don't mean much when everything is a closure. Basically I mean that you can curry it
18:56:09 <Nilgeist> ah, yes, a neural net AI is also possible, and might be fun to play with
18:57:19 <Nilgeist> I was mostly worrried about it from an architectural standpoint: the board games are a small thing i want to do to try and learn Haskell, fog
18:59:45 * hackage monadic-recursion-schemes 0.1.7.0 - Recursion Schemes for Monadic version.  https://hackage.haskell.org/package/monadic-recursion-schemes-0.1.7.0 (KatsutoshiItoh)
19:03:28 <Nilgeist> not sure if you'll see this tmr; but that's sort of interesting. if i understand correctly, you're suggesting using the monte-carlo to train the neural net as we go along. neat!
19:04:29 <fog> Nilgeist: it seems like a good idea
19:04:44 <ski> everything is a closure, in Racket ?
19:04:49 <fog> so what were you thinking for the class API?
19:06:02 <fog> I was doing something with markets, which is kind of like a multiplayer game
19:06:10 <Nilgeist> No, in racket you'd need to do ((lambda (x) (lambda (y) (+ x y)))) 5) to get you (lambda (y) (+ 5 x)) explicitly
19:06:37 <ski> mm, yes
19:07:07 <ski> ah, you were talking about curried style
19:07:20 <fog> the market is like a board, and the traders are players, though they do not need to take turns in a round robin style, so that might need to be abstracted over - like for cardgames like snap, where there is a kind of turn which any player can make at any time
19:08:12 <Nilgeist> fog, well, right now i just want to abstract the AI from the ruleset. Then that's where it gets tricky for the API. In general I want to have a high level description of the graphics and the rules (and im not sure what that will look like yet)
19:08:12 <fog> when the trader trades, they get some feedback, and they can at any time query the state of the market for where the current open orders are
19:08:47 <Nilgeist> oh simular!
19:09:15 <Nilgeist> fog, did you do that with a monad by chance?
19:09:23 <fog> hmm, I wonder if this is kind of like a talk that ocharles gave recently about solving plans in the circuit plant he works at
19:10:05 <fog> Nilgeist: I was wondering about what you meant by a monad? why do you think that the game would be monadic?
19:11:14 <Nilgeist> well, for the api.. I was thinking of having the type require "turn" (get players turn), "legalMoves", "randomMove", and "applyMove"
19:11:20 <fog> i dont think it really makes sense at all really, what would even a nested game be?
19:11:25 <fog> :t join
19:11:27 <lambdabot> Monad m => m (m a) -> m a
19:12:25 <fog> hmm, yes your setup does seem similar to the idea with markets, except that the market doesnt decide which trader trades next
19:12:34 <Nilgeist> i was half thinking of using a monad so i could use do notation to manipulate my game state, but... from what i read here, that might not be the approach (or i could use StateT)
19:13:02 <Nilgeist> yeah.. some board games have a "roll again" sort of mechanism
19:13:03 <fog> ah, your thinking of working *within* a monad
19:13:58 <fog> i think maybe the problem is to do with trying to combine the players and the game into one entity...
19:14:02 <Nilgeist> that sounds right... the concept is still hazy
19:14:26 <fog> but when you have doen that, there should be some sort of a -> a style function which updates the whole system
19:15:10 <fog> kind of like a cpu "clock" since really these things should be done in real time...
19:16:00 <fog> otherwise you just have that if at any point you observe the system, the players will have generated a list of moves
19:16:20 <fog> and then you have to apply them to the board to get the resulting player updates
19:16:39 <Nilgeist> I think the idea is to have a "takeTurn" functions, one for the UI and one for the AI that work within the loop depending on "turn"
19:17:10 <fog> for the asynchronous thing it almost makes sense to abstract over a server client interaction between the board and the players
19:17:12 <Nilgeist> Yeah, the state is only modified on "applyMove"
19:17:22 <Nilgeist> oh yeah!
19:17:29 <Nilgeist> i was also thinking about that too
19:17:47 <fog> right, and this could give the update to the players, eg, if their move resulted in them having to pick up a bunch of cards
19:18:06 <Nilgeist> still; in that case the AI would still want to be abstracted from the rules
19:18:55 <Nilgeist> i was actually thinking of having a gui client and an AI backend just like chess does in linux
19:19:10 <fog> so its can observe the state of the board, and submit an action, the result of which would update the players state
19:19:31 <fog> as well as that of the board obviously
19:20:00 <Nilgeist> going back to what you said about real time.. In a turn based game, where would that come into play?
19:20:33 <fog> well, it depends if your abstraction is supposed to only include round robin style turn based games
19:21:18 <fog> but then there could be a rule where a player has to miss their next turn...
19:21:21 <Nilgeist> oh, i think i see what you mean now
19:21:46 <Nilgeist> well... I think i'll leave that logic up to the ruleset, where possible
19:22:04 <fog> really if you want an interface where an AI can play any random game, it should include both styles
19:22:17 <fog> I think I saw one where they were playing COD
19:22:30 <Nilgeist> i think i might just use tic-tac-toe to get my head around the abstractions, and the first game will probably be the royal game of ur, which is 2-player also
19:23:38 <fog> what about RPGs? 
19:23:41 <Nilgeist> haha; if i limit myself to turn based board games I have a little more flexibility in terms of playing with decision AI. Otherwise im pretty much forced to use ML
19:24:23 <fog> is that the same as markov decision trees? 
19:24:31 <Nilgeist> Well, I'd honestly probably just tie in someone elses neural net into the RPG or realtime game xD
19:25:18 <Nilgeist> nah, just decision tree AI
19:25:49 <dmwit> Haha, when I say it I am ignored, but when solonarv says it is a good idea. ^_^
19:25:52 <dmwit> Anyway.
19:25:57 <dmwit> https://github.com/dmwit/nurse-sveta/blob/master/src/Dr/Mario/Sveta/MCTS.hs may be of interest to you.
19:26:09 <fog> one cool idea was providing a layer over an existing game API - like for civilisation, where you have eg. many cities you can change the production of, but its labourious for the user to have to click to update each, then you can train an AI to elucidate a more convenient interface for gameplay
19:26:48 <Nilgeist> I could probably make a universal AI for games using some ML libraries; but im sort of also interested in playing with haskell-gi, and familiarizing myself with haskell abstractions, but maybe someday :P
19:27:34 <Nilgeist> that would be useful! poor UI in games solved!
19:27:50 <Nilgeist> dmwit, thanks!
19:28:00 <fog> sounds like your set on limiting the abstraction to round robin, so then you might just have a list of players that you rotate
19:30:01 <Nilgeist> well, some boards games have a "play again" thing; so i might wrap "turn" up in a case and loop around that; but the gameloop is defined by the rules so it easy to handle that logic per board game without effecting the AI! no biggie if it needs to be changed up
19:31:15 <fog> then the system is just a pair of this list of players and the board state. you initialise with initial players and initial board - and the taking turns interface need not feature into the abstraction - you pair current the player with the board and your ai chooses from a set of functions to update this pair  
19:31:38 <Nilgeist> oo, that has a nice `mcts_ ` function dmwit
19:32:00 <fog> (p -> b -> (a,b)) -> (a -> p -> p) -> ((p,b) -> (p,b))
19:32:13 <Nilgeist> yup! that sounds like a good idea to me fog
19:32:43 <Nilgeist> that's pretty much it
19:33:15 <fog> then the permissible moves is [(p -> b -> (a,b))]
19:33:30 <fog> and your AI just submits an index
19:33:49 <fog> one thing then is "permissions"
19:33:53 * Nilgeist looks up semigroup
19:34:07 <fog> can your AI see the other players states when deciding on the move to choose?
19:34:23 <Nilgeist> hopefully not
19:34:25 <Nilgeist> thats true
19:34:44 <Nilgeist> there needs to be some distinction between whats public and not
19:35:04 <Nilgeist> maybe i need the players to carry some state as well?
19:35:14 <fog> so then you just have the AI as ((p,b) -> Int)
19:35:31 <fog> p was the players state, b is the board state
19:35:42 <Nilgeist> mhmm
19:35:45 <fog> Int is the index over the list of moves
19:36:12 <Nilgeist> i guess things like catan have private information (though you can have most if it if you have a good memory)
19:36:27 <Nilgeist> the list is probably lazy
19:36:33 <Nilgeist> for legal moves
19:36:48 <fog> actually, you might need (p,b) -> [(p -> b -> (a,b))], ie to determine what moves *can* be made by the player depending on their state and that of the board
19:37:13 <Nilgeist> hmm... it might be useful to just have a move type (it might take a long time to go through the list)
19:37:45 <fog> ah, like a Store ?
19:37:47 <Nilgeist> oh, hmm. lemme think on that for a second
19:39:45 <Nilgeist> You might be right... I was thinking that `listMoves` would be for the GUI/minimax to show all the moves, and `randomMove` for the MCST. but i guess I don't really need randomMove, and then each move is just given an index now (which can be newtyped)
19:40:22 <Nilgeist> i was thinking of the rules defining a struct for each move "pawn to C4" sort of deal
19:40:25 <Nilgeist> and that being in a list
19:40:34 <Nilgeist> so (p,b) -> [moves]
19:41:12 <fog> ((p,b) -> [(p -> b -> (a,b))],a -> p -> p) ?
19:41:26 <fog> ah, for chess there is no `a'
19:41:36 <fog> the players state never changes
19:41:54 <ski> (remi ?)
19:42:24 <fog> and, also, p is not required to determine the list of moves in chess
19:42:45 <fog> it really seems like the API is depending a lot on the particular game
19:43:08 <Nilgeist> it took me a second to see what your doing there.
19:43:14 <Nilgeist> yeah, something like that might work!
19:43:34 <fog> whereas for a card game the players hand would give different possible moves
19:43:59 <fog> infact, maybe the only choice, if all they can do is put it face up on the deck
19:44:32 <Nilgeist> with MCST we can just randomise the player's private state such that it is still legal from the public information
19:44:47 <Nilgeist> at least to start with
19:45:50 <fog> its annoying when an abstraction that covers several cases has some of those cases not use the parts of the abstraction used by the other cases
19:45:55 <Nilgeist> i guess the list of player states can then just be included in the GameState; and then we have a function to give a randomized-legal version of GameState. Then the AI doesn't need to know about the players as much
19:46:15 <Nilgeist> "all" board games are more complicated then I thought :P
19:46:30 <Nilgeist> yeah
19:47:14 <Nilgeist> (since we always need to pass the players with the board state = they should just be carried together)
19:47:20 <fog> yeah, whats happened is when we split (a -> a) into (([p],b) -> [(p,b)]), there were a lot of combinations of interacting update functions 
19:47:33 <fog> (]p)
19:47:47 <fog> ([p],b) -> ([p],b)
19:47:49 <fog> sorry...
19:48:33 <fog> I had this problem before trying to unfold using a state that was a pair
19:48:44 <Nilgeist> well, i might need to go for an organic sort of abstraction, and add more cases as I go along, as I'm sure there are more then just the players private/public state
19:49:38 <Nilgeist> ah, i can see how that would be a pain
19:49:49 <fog> well, if you just work with the whole system, and dont bother about the distinction between players and board, then its going to give fewer possibilities
19:50:03 <fog> a -> [(a->a)]
19:50:12 <fog> pretty simplistic...
19:51:03 <fog> id say that was abstracted too much... but then it could give the interface that unify the different versions...
19:52:29 <fog> then the whole thing is the pair of the ai and this very abstracted form of game; (a -> Int,a->[(a->a)]) -> a -> [a]
19:52:50 <dsal> Almost every game I've ever had to deal with in AoC was a pretty basic graph search.
19:52:55 <fog> thats a pair of an AI and a game, an initial state, and an unfolding of consecutive states
19:54:04 <fog> i guess you could even combine the AI and the rules into a -> (a -> a)
19:54:12 <dsal> All the solutions looked something like that...  Given this state, find next states.  Recurse.
19:54:18 <fog> and i think thats about as abstract as you can get!
19:54:19 <dsal> :t fix
19:54:20 <lambdabot> (a -> a) -> a
19:54:49 <dsal> So close.
19:55:11 <fog> i think your looking for, (a -> (a -> a)) -> a -> [a]
19:56:20 <Nilgeist> Well, i might make gamestate a container for the playerstate's and the boardstate... then when i need to modify something, ill make a complete copy of both; at least to start with
19:57:33 <fog> % let next (f :: a -> (a -> a)) (a :: a) = let a' = (f a) a in a' : (next f a') 
19:57:33 <yahb> fog: 
19:57:40 <fog> % :t next
19:57:40 <yahb> fog: (a -> a -> a) -> a -> [a]
19:57:54 <Nilgeist> then just do search tree's on gamestate (randomized playerstate if necessary)
19:58:29 <Nilgeist> well, i think ill do an approach like this to start with and see where it takes me
19:59:08 <fog> hmm, you might want to give it an option of finishing the game aswell
19:59:16 <Nilgeist> haha, thats ture
19:59:24 <fog> like, wrapping the returned `a' in a Maybe
19:59:27 <Nilgeist> actually in Go.. finishing the game is really complicated
19:59:35 <fog> your probably going to und up with unfold
19:59:36 <Nilgeist> yeah
19:59:40 <fog> % :t unfoldr
19:59:40 <yahb> fog: (b -> Maybe (a, b)) -> b -> [a]
20:00:10 <Nilgeist> The AI would need a gameOver too I guess
20:00:27 <Nilgeist> and handle gameOver in main loop
20:00:33 <fog> yeah, we were talking about Go before, and the descision tree thing seemed worse than using classifiers to try and actually understand what good moves were
20:01:01 <Nilgeist> pfft. even the simple Go AI struggle with scoring.
20:01:03 <fog> metrics such as "that resulted in me losing pieces" can drastically simplify training
20:01:36 <fog> scoring like, what is a calculated loss?
20:02:10 <Nilgeist> yeah... there's also liberty counting used to priorities where the MCST should check first. I think that would need a specialized AI though, since doing it eficently also requires remembering all the structures
20:02:31 <fog> still, even simple heuristics are going to be better than running every possible game to completion - like "no games where i lose most of my pieces result in me winning"
20:02:49 <Nilgeist> Well... we end go games when both players pass... but scoring can be "debated" if players disagree, and they play it out
20:03:08 <Nilgeist> so to score, you essentially need to play the rest of the game where its "obvious"
20:03:51 <Nilgeist> there is no easy way to check to see who owns what territory in go, unless you're a human, or you build an AI just for scoring
20:04:44 <fog> i like the ko rule in go, its something like a simple stalemate prevention right? must have been evolved pretty early on, I wonder if there are more complex versions - like where grand masters basically consider some moves illegal because they ruin the game
20:04:46 <Nilgeist> Yeah, most of the Go AI i've seen (even the simple python ones) have a few things going on that I don't think can be abstracted very well to other games
20:05:35 <Nilgeist> komi prevents stalemate with the .5 yeah.. its also for first turn advantage.
20:05:41 <Nilgeist> hmm, good question
20:06:16 <Nilgeist> i think its because of oral tradition changing, translations of the game, and standardization efforts of the oral tradition and translations
20:06:21 <fog> then there is something to do with bifurcations in opponent strategy learning, like, can you "fool" the opponent into taking the bait
20:07:36 <fog> serious implications for markets there... it leads to an adversarial training environment where they learn "optimal causal inference", "interrogation strategies", and "differential privacy"   
20:07:47 <Nilgeist> yeah. the nash equalibrium is much harder to find, so human opponents can be tricked and all sorts of physiology is in play. definately harder then the royal game of ur xD
20:08:10 <Nilgeist> lol
20:08:55 <fog> right, there was work done on "mean field game theory with a major player" and it resulted in trying to guess how the opponent was guessing you were guessing it was guessing etc. thats what I think of when i hear "nash equilibria" 
20:10:26 <fog> its totally nothing to do with haskell, but this leads to a notion of over simplistic interpretation of market signals, and motivates the alteration of economic consensus... i never talk about that stuff here, and i should probably stop! 
20:10:35 <Nilgeist> good night! thanks for the help!
20:10:36 <fog> anyway, nice discussion
20:12:15 * hackage total 1.0.6 - Exhaustive pattern matching using lenses, traversals, and prisms  https://hackage.haskell.org/package/total-1.0.6 (GabrielGonzalez)
20:47:52 <Guest_68> https://pastebin.com/rKa1FGwx
20:47:57 <Guest_68> Im back...
20:49:17 <Guest_68> I have my function "set" and I can search my list and change the tuple 
20:49:33 <Guest_68> but im stuck on how i would recursively take input 
20:52:53 <Feldmaus> Input of what form?
20:53:25 <Feldmaus> Also your type signature userEntry :: IO() -> () seems already wrong
20:53:52 <Guest_68> The user inputs a string
20:54:02 <Guest_68> i.e. A1
20:54:15 <Guest_68> and yeah i commented it out
20:54:16 <Feldmaus> And then?
20:55:10 <Guest_68> https://pastebin.com/7Ezq5K8U
20:56:02 <Guest_68> the string is named, newBoard = set with guess
20:56:42 <Feldmaus> set takes two parameters
20:57:24 <Guest_68> crum
20:57:50 <Guest_68> hmm 
20:59:01 <Guest_68> ok, how would I take their input, run search on it, if the output of search is 1 "set" string with 2
21:00:50 <Feldmaus> When you remove that "read", you have guess :: String which you can use directly withsearch
21:01:32 <dmwit> :t lookup
21:01:33 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
21:07:52 <Guest_68> https://pastebin.com/LtAywc7a
21:08:02 <Guest_68> i changed to just using lookup
21:29:38 <Guest_68> https://pastebin.com/v4LcadPW
21:29:50 <Guest_68> parse error on input 'loop'
21:30:40 <steven_> you have an if with no else 
21:30:50 <steven_> you always need both in haskell
21:31:15 <steven_> probably in your case you want `when` instead
21:32:04 <steven_> when (fromJust mark == 1) $ do (let ... loop newBoard)
21:33:50 <Guest_68> I added else let newBoard = set (guess,3)
21:36:39 <Guest_68> steven
21:36:43 <Guest_68> https://pastebin.com/78zNtjFQ
21:36:45 <Guest_68> steven_
21:38:25 <steven_> Guest_68: I don't think that compiles, right?
21:38:43 <Guest_68> steven_ it does not
21:38:51 <Guest_68> parse error on input `else`
21:39:24 <steven_> yeah, if you're using `let` without `in` and you're not in a `do` block, it doesn't work
21:39:40 <fog> Guest_68: why not generate your initial board algorithmically? 
21:39:42 <steven_> it's kind of overloaded terminology, there's `let ... in` and `let` and they're two different things
21:40:35 <steven_> you could instead do `if ... then loop (set (guess, 2)) else loop (set (guess, 3))`
21:40:38 <Guest_68> I will, right now im setting manually to test the values
21:40:40 <fog> % [a++show b| a <- "abc",b<-[1,2,3]]
21:40:40 <yahb> fog: ; <interactive>:89:2: error:; * Couldn't match expected type `[Char]' with actual type `Char'; * In the first argument of `(++)', namely `a'; In the expression: a ++ show b; In the expression: [a ++ show b | a <- "abc", b <- [1, 2, 3]]
21:40:54 <fog> % [a:(show b)| a <- "abc",b<-[1,2,3]]
21:40:54 <yahb> fog: ["a1","a2","a3","b1","b2","b3","c1","c2","c3"]
21:41:54 <steven_> Guest_68: basically try to avoid variable assignments and try to think about expressions instead. It's not easy at first but once you get the hang of it, it's easier to do it that way in haskell
21:42:38 <steven_> the `let` statements you were using don't behave the way you'd expect
21:43:42 <Guest_68> https://pastebin.com/cjJBWw3s
21:44:12 <Guest_68> I tried doing away with the assignments now i have an unexpected do block in function application
21:44:41 <fog> % map (\x -> if x == "a1" then (x,1) else (x,0)) [a++show b| a <- "abc",b<-[1,2,3]]
21:44:41 <yahb> fog: ; <interactive>:91:49: error:; * Couldn't match expected type `[Char]' with actual type `Char'; * In the first argument of `(++)', namely `a'; In the expression: a ++ show b; In the second argument of `map', namely `[a ++ show b | a <- "abc", b <- [1, 2, 3]]'
21:44:48 <fog> % map (\x -> if x == "a1" then (x,1) else (x,0)) [a:show b| a <- "abc",b<-[1,2,3]]
21:44:48 <yahb> fog: [("a1",1),("a2",0),("a3",0),("b1",0),("b2",0),("b3",0),("c1",0),("c2",0),("c3",0)]
21:45:07 <Guest_68> awesome, thanks fog
21:45:16 <steven_> this looks good, I think maybe you need to remove two spaces of indentation in the last three lines
21:45:35 <steven_> besides that I think it should compile, unless I missed something
21:47:01 <fog> Guest_68: you should use a case expression rather than fromJust
21:47:04 <Guest_68> wow 2 spaces changed the error
21:47:07 <Guest_68> https://pastebin.com/nWj00pX3
21:47:13 <Guest_68> steven_
21:47:24 <steven_> did it compile?
21:47:51 <steven_> and yeah, the whitespace can be very tricky
21:48:20 <Guest_68> couldnt match expected type '[(String, Integer)]' with actual type '[(string, Integer)] -> [(String, Integer)]'
21:48:22 <fog> % (\x -> case x of Nothing -> error "!"; Just y -> print y) (Just 1)
21:48:22 <yahb> fog: 1
21:48:28 <fog> % (\x -> case x of Nothing -> error "!"; Just y -> print y) (Nothing)
21:48:29 <yahb> fog: *** Exception: !; CallStack (from HasCallStack):; error, called at <interactive>:94:29 in interactive:Ghci66
21:48:57 <fog> there is also a nice helper function;
21:48:59 <fog> :t maybe
21:49:01 <lambdabot> b -> (a -> b) -> Maybe a -> b
21:49:22 <fog> % maybe 0 (+1) (Just 2)
21:49:23 <yahb> fog: 3
21:49:29 <fog> % maybe 0 (+1) (Nothing)
21:49:29 <yahb> fog: 0
21:49:40 <Guest_68> no compile :/  steven_
21:50:19 <steven_> you should probably try to fix it on your own first
21:50:32 <steven_> and if you have specific questions we can help
21:51:55 <Guest_68> Ill play with it, thanks for the help 
21:51:59 <fog> did you mean (set (guess,2) board)
21:53:05 <Guest_68> wow that was it thanks fog
21:58:07 <Guest_68> How would I add another argument in the then portion
21:58:34 <Guest_68> i.e. putStrLn "hit", then loop
22:00:31 <steven_> then do
22:00:58 <steven_> then you can do one statement per line again
22:04:41 <Guest_68> I have spent the past two days on this and for the first time it is finally working, this community is amazing
22:05:45 <steven_> haha yeah it's nice to get quick feedback here
22:09:14 * hackage process 1.6.9.0 - Process libraries  https://hackage.haskell.org/package/process-1.6.9.0 (MichaelSnoyman)
22:22:14 <dsal> Guest_68: `fromJust mark == 1` is a slightly clunkier, less safe way of saying `mark == Just 1`
22:22:56 <dsal> (but as mentioned, I wouldn't use if/else here anyway)
22:23:32 <Guest_68> dsal thanks for the tip
22:23:50 <Guest_68> i missed your suggestion, is there a preferable alternative to if/else?
22:23:54 <dsal> Also, fromJust is in Data.Maybe.  But don't use it.  :)
22:24:03 <dsal> Other people suggested, e.g., maybe
22:26:22 <fog> % maybe (error "a better error than fromJust Nothing") (==1) (Just 1)
22:26:22 <yahb> fog: True
22:26:24 <dsal> `if fromJust mark == 1 then loop (set (guess, 2)) else loop (set guess, 3)))` is the same as `loop (set (guess, if mark == Just 1 then 2 else 3))`
22:26:25 <fog> % maybe (error "a better error than fromJust Nothing") (==1) (Just 2)
22:26:25 <yahb> fog: False
22:26:32 <fog> % maybe (error "a better error than fromJust Nothing") (==1) Nothing
22:26:32 <yahb> fog: *** Exception: a better error than fromJust Nothing; CallStack (from HasCallStack):; error, called at <interactive>:99:8 in interactive:Ghci70
22:27:03 <fog> also note;
22:27:14 <fog> % fmap (==1) (Just 1)
22:27:14 <yahb> fog: Just True
22:27:18 <dsal> Though I don't quite understand why `Just 1`
22:27:40 <fog> thats from lookup right?
22:27:43 <fog> :t lookup
22:27:44 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
22:28:15 <dsal> What does the number mean?
22:28:59 <fog> its a flag for if there is a battleship there
22:29:15 <dsal> I thought there was a proper type for that already.
22:29:50 <fog> i guess they are developing different parts seperarately 
22:30:25 <fog> i would like to see all these parts together though 
22:30:47 <dsal> If you case over the returned value, the compiler will tell you if you miss one.
22:31:52 <fog> oh, did you see spj's talk on propagating exhaustive case matching over extended scopes?
22:32:05 <dsal> I'm not familiar with that.
22:32:49 <fog> ah it was pretty cool, they had some kind of short metalanguage based on set uniouns or something
22:33:46 <fog> so it would be able to check if some cases were pattern matched at the arguments to the function, and some within the body of the implementation of a case expression and stuff
22:34:35 <fog> i think i read they had built it into the new ghc release 
22:36:44 <fog> trying to think how to segway into mentioning a metalanguage involving tensor rank typed function algebras... nvm
22:39:24 <Guest_68> https://pastebin.com/5CjC33jv
22:40:06 <Guest_68> I tried to make a set board function but printBoard in my main no longer can see the board
22:40:15 <Guest_68> is it because its not defined globally?
22:40:46 * hackage calamity 0.1.8.0 - A library for writing discord bots  https://hackage.haskell.org/package/calamity-0.1.8.0 (nitros12)
22:40:50 <dsal> What do you mean?
22:40:57 <fog> % :t (\x -> x == ("a1"||"a2"||"a3"||"a4"))
22:40:57 <yahb> fog: ; <interactive>:1:14: error:; * Couldn't match expected type `Bool' with actual type `[Char]'; * In the first argument of `(||)', namely `"a1"'; In the second argument of `(==)', namely `("a1" || "a2" || "a3" || "a4")'; In the expression: x == ("a1" || "a2" || "a3" || "a4"); <interactive>:1:20: error:; * Couldn't match expected type `Bool' with actual type `[Char]'; * In the f
22:41:33 <fog> % :t (\x -> x `elem` ["a1","a2","a3","a4"])
22:41:33 <yahb> fog: [Char] -> Bool
22:42:08 <dsal> Guest_68: what is the type of setBoard?
22:42:32 <dsal> And what do you think it does?
22:43:07 <fog> ah, i dont think the let bound variable will escape from the function there
22:43:17 <fog> you need to return it
22:43:59 <fog> return board, as the last line of the do loop in setBoard
22:44:21 <fog> then in the other do loop, use board <- setBoard 
22:44:49 <dsal> I generally don't suggest using `return`, but in this case, the only reason it's even an IO action is so it can print a misleading message.  Just make it a list.
22:45:11 <fog> oh yeah, why is everything in IO !?
22:45:24 <fog> your using do notation for no reason
22:45:42 <dsal> i.e., replace `setBoard :: IO ()` (which can't actually set anything that's used here) with `board :: BoardType`
22:47:22 <fog> hmm, i guess if you really want it to print a message within that function then it would be IO, but otherwise, you can just have, setBoard = map ... 
22:48:29 <dmwit> dsal: See, your mistake is reading "set" as a verb. It's actually an adjective: `setBoard` is a set (i.e. specific) board. =P
22:48:44 <dsal> English is hard.
22:48:49 <fog> % :t map (\x -> if x `elem` ["a1","a2","a3","a4"]) then (x,1) else (x,0)) [a:show b| a <- "abc",b<-[1,2,3]]
22:48:49 <yahb> fog: ; <interactive>:1:45: error: parse error on input `)'
22:49:02 <fog> % :t map (\x -> if x `elem` ["a1","a2","a3","a4"] then (x,1) else (x,0)) [a:show b| a <- "abc",b<-[1,2,3]]
22:49:02 <yahb> fog: Num b => [([Char], b)]
22:49:47 <fog> thats the type of setBoard if you dont have it in IO, otherwise, its; IO [([Char], b)]
22:49:58 <fog> you can make a type synonym by writing;
22:50:07 <fog> type Board = [([Char], b)]
22:50:32 <dsal> mapping a list comprehension seems a bit odd.  I can't quite understand what the idea is there, though.
22:50:42 <fog> then you could have setBoard :: Board, or setBoard :: IO Board if your going use return
22:51:03 <fog> dsal: my bad!
22:51:27 <fog> it was for educational purposes...
22:52:43 <dsal> Ah.  Yeah, it sort of makes sense if the map comes from somewhere else and is the overrides.
22:53:08 <dsal> Oh, yeah, reading it like that it makes sense.
22:54:48 <dsal> I'd recommend getting rid of the magic numbers again, but then not worry about prefilling all the Empties.  They're implied.
22:57:41 <dsal> > let board = [("a1", 1)];  lu x =  fromMaybe  0 .  lookup  x  in  (lu "a1" board, lu "a2" board)
22:57:43 <lambdabot>  (1,0)
23:04:49 <Guest_68> im confused on function definitions
23:05:11 <Guest_68> printBoard:: [board] -> IO()
23:05:32 <Guest_68> that would take in a list called board and perform IO on it right?
23:05:48 <johnw> it returns an IO action that the runtime will execute to perform the actual I/O
23:06:43 <Guest_68> so if i wanted there to be a bunch of lines printed within that  I would add a do block with the lines?
23:07:47 <johnw> I would say there's probably no need to add any additional do blocks, but I don't understand what you're doing in your function yet. You should be able to just use `print` in your function.
23:21:58 <Guest_68> im trying to print just the second number in each tuple, given a list of tuples
23:22:18 <Guest_68> and I want to print strings in between
23:22:34 <Guest_68> i.e. ("a1",0)
23:22:51 <Guest_68> prints "| 0 |"
23:24:13 <steven_> you can use `snd` to get the second element of a tuple
23:25:54 <Guest_68> how would i feed each tuple in the map to the command
23:26:11 <steven_> what did you try?
23:28:08 <Guest_68> showDetails :: (String, Integer) -> StringshowDetails (_, x)= "| " ++ show x
23:28:25 <Guest_68> *showDetails :: (String, Integer) -> String
23:28:41 <Guest_68> showDetails (_, x)= "| " ++ show x
23:29:42 <steven_> And you want to run this on a list [(String, Integer)] right? Did you have something for that?
