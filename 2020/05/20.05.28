00:02:28 <lortabac> liiae: what do you mean by "IO is not a constructor"? That the constructor of the IO type is hidden?
00:02:46 <Cale> Probably that IO isn't a data constructor
00:03:15 * hackage tdlib 0.1.1 - Bidings to the tdlib json interface  https://hackage.haskell.org/package/tdlib-0.1.1 (Poscat)
00:03:34 <lortabac> oh yes, as a beginner I found the punning between types and values confusing
00:05:58 <lortabac> not exactly the same problem, but somehow related
00:07:09 <liiae> lortabac: yes, IO is not a value constructor
00:08:13 <liiae> that data type stuff make me confused too
00:08:53 <liiae> data Maybe a = Just a|Nothing, the a in Maybe is a type, but a in Just a is a value variable
00:09:14 <liiae> there's no such thing like Just Int
00:09:26 <lortabac> liiae: yes, there is
00:09:26 <liiae> but Just (a::Int)
00:09:36 <Rembane> :t Just 7 
00:09:37 <lambdabot> Num a => Maybe a
00:09:40 <Rembane> Meh
00:09:44 <Rembane> lambdabot: Work with me! 
00:09:57 <liiae> Just Int is not ok
00:10:01 <Rembane> Just 7 :: Maybe Int 
00:10:08 <liiae> Just is value constructor, Int is a type
00:10:09 <c_wraith> liiae: to some extent, that's what GADT syntax gives you:  data Maybe a where Nothing :: Maybe a ; Just :: a -> Maybe a
00:10:24 <lortabac> I mean, when you define a datatype, the things you put after a constructor are types
00:10:25 <liiae> Just (a:: Int) is ok
00:10:27 <c_wraith> liiae: strange shorthand syntax replaced with something much more convenient
00:10:37 <c_wraith> err.  much more *consistent*
00:11:23 <lortabac> 'data MaybeInt = Nothing | Just Int' is correct
00:11:44 <Cale> liiae: Yeah, after the = in a data declaration, there are a bunch of possible cases separated by | and each one has the name of a data constructor, followed by the types of its arguments
00:11:45 <liiae> lortabac: only before Int is defined before this
00:12:00 <liiae> everything comes from some where
00:12:20 <Cale> liiae: It's meant to look a little bit like BNF grammars, but if you're unfamiliar with those, it can be confusing when you first see it
00:13:44 <liiae> dminuoso: do you think Just Int is ok?
00:14:47 <liiae> lortabac: Just 3 :: Maybe Int, in your definition, Just 3 :: MaybeInt
00:16:10 <liiae> data Maybe Int = Nothing | Just Int, this Int is redefined, it's not that Data.Int, right?
00:16:31 <Cale> You can't put the space there in Maybe Int
00:16:33 <Axman6> that
00:16:39 <Axman6> that's not legal
00:16:59 <lortabac> liiae: I think you are confusing data declarations and actual terms
00:17:03 <Cale> If you want to redefine Nothing and Just, you could write data MaybeInt = Nothing | Just Int
00:17:05 <Axman6> data Maybe int = Nothing | Just int is legal, but is equivalent to data Maybe a = Nothing | Just a
00:17:24 <Cale> It's kind of a confusing example though
00:17:48 <Cale> Perhaps it would be better to rename those data constructors too so they won't conflict with the existing ones
00:18:06 <liiae> if a show up in the left of = in the type definition, it can show up in the right side, and a can't show in the right side if a didn't show up in the left side unless a is defined in somewhere else
00:18:16 <Cale> data MaybeInt = NoInt | AnInt Int
00:18:37 <Cale> This introduces a new data type MaybeInt, with constructors NoInt :: MaybeInt and AnInt :: Int -> MaybeInt
00:18:41 <lortabac> liiae: that's only true for type variables (lowercase)
00:18:45 * hackage hasbolt-extras 0.0.1.4 - Extras for hasbolt library  https://hackage.haskell.org/package/hasbolt-extras-0.0.1.4 (ozzzzz)
00:19:02 <Cale> You wouldn't do this, because it's basically the same thing as Maybe Int, but it's valid
00:20:35 <liiae> lortabac: Just 3 is a value, Maybe Int is a type, and yes , there could be Just Int in data definition, what we should call it?
00:20:51 <liiae> data P = P Int
00:20:57 <liiae> P 3 :: P
00:21:51 <liiae> what we should call `P Int`?
00:22:01 <Cale> Yeah, that "Just Int" that potentially appears in a data declaration is neither an expression nor a type. It's a data declaration constructor clause, I guess.
00:22:21 <liiae> in the right side of =, P is a value constructor, and Int is a type, what we call P Int?
00:23:03 <Cale> It's just a thing that defines a new data constructor, things of that sort only appear in data declarations and define data constructors
00:23:55 <liiae> Cale: yes, but why people didn't split it or give it a new name so it won't confused beginners
00:24:05 <xerox_> is it possible to run locally the same thing that runs on stackage.org as far as search goes? I love that you can scope the search by a certain LTS Haskell version
00:24:26 <Cale> It would have been less confusing to use a syntax which let you specify the types of the data constructors, like:
00:24:32 <Cale> data Maybe a where
00:24:37 <Cale>   Nothing :: Maybe a
00:24:42 <Cale>   Just :: a -> Maybe a
00:25:13 <Cale> That syntax is available through an extension to the language (GADTs / GADTSyntax)
00:25:22 <liiae> but I think ADT is more intuitive than GADT
00:25:31 <Cale> However, syntax like that opens up a bunch of questions... what if I write:
00:25:31 <liiae> ADT is shorter
00:25:35 <Cale> data Expr a where
00:25:40 <dminuoso> liiae: Sometimes more dense can be harder to read.
00:25:45 <Cale>   Lit :: Int -> Expr Int
00:26:08 <Cale>   IsZero :: Expr Int -> Expr Bool
00:26:28 <Cale> With that syntax, I can define things that I couldn't define with the original Haskell syntax
00:28:06 <dsal> T is shorter than ADT
00:29:02 <liiae> I always like to define a type like `data IS = Int | String`
00:29:22 <liiae> but it's not gonna work
00:29:32 <Cale> That will introduce two data constructors named Int and String which confusingly have nothing to do with the types of those names
00:29:38 <liiae> Either Int String
00:29:38 <Cale> You could write
00:29:45 <Cale> data IS = Int Int | String String
00:29:58 <Cale> and then  Int 4 :: IS  and  String "hello" :: IS
00:30:39 <liiae> type IS = Either Int String
00:32:18 <liiae> err.. it's wrong
00:32:36 <Cale> That's valid though
00:32:52 <liiae> but :t (Left 3) :: IS is not ok
00:33:03 <Cale> should be fine
00:33:09 <Cale> If you have that type synonym
00:48:30 <liiae> Cale: what's the different between `type IS = Either Int String` and `data IS = Either Int String`?
00:49:44 <Cale> The first defines the type synonym IS to be exactly the same type as Either Int String. The type system will treat the two as being the same thing.
00:50:13 <Rembane> The name of the type keyword is confusing though and has always been.
00:50:16 <Cale> The second one defines a completely new datatype called IS, with a single constructor named Either, having two arguments of types Int and String
00:50:57 <Cale> It has nothing at all to do with the Either type
00:51:02 <liiae> oh, I see, this Either in the second is not that Either in the lib
00:51:09 <Cale> right
00:52:29 <liiae> newtype Fix f = Fix (f (Fix f)), this value constructor Fix in the right side of = has nothing to do with the second Fix in the right of =
00:52:55 <Cale> The first and third Fix are the same thing, the second Fix is a different thing
00:53:00 <liiae> the second Fix in the right side of = is that left Fix
00:53:05 <Cale> It might be less confusing to write like:
00:53:15 <Cale> newtype Fix f = MkFix (f (Fix f))
00:53:32 <liiae> right
00:53:33 <Cale> But when there's only one data constructor (as is always the case with newtypes), it's common to name it the same as the type
00:54:20 <liiae> why you all call it `data constructor`? not value constructor?
00:54:31 <liiae> the left of = is type constructor
00:54:54 <Cale> Value constructor would be a fine name to use. The standard and many other documents use the term "data constructor"
00:55:25 <Cale> Basically I'm just used to that term
02:02:15 * hackage shh 0.7.0.8 - Simple shell scripting from Haskell  https://hackage.haskell.org/package/shh-0.7.0.8 (lukec)
04:13:15 * hackage mutable-lens 0.3.0.0 - Interoperate mutable references with regular lens  https://hackage.haskell.org/package/mutable-lens-0.3.0.0 (infinity0)
04:32:33 <dminuoso> Is there a more elegant way to write this without this mess of withRunInIO, liftIO, and io? https://gitlab.com/snippets/1981252
04:33:37 <merijn> dminuoso: "liftIO (io" <- that seems redundant
04:34:00 <merijn> That's lowering and immediately lifting it again
04:34:00 <dminuoso> merijn: It's not. Im hoisting an Agnar into ActionM
04:34:25 <dminuoso> (And Agnar is essentially just some `ReaderT IO` - but that environment is necessary so I cant just use IO)
04:35:39 <dminuoso> I could perhaps write some `makeHoist :: Agnar (Agnar a -> ActionM a)`
04:36:23 <dminuoso> And then just go `hoist <- mkHoist; liftIO . scotty 8000 $ post "/tick" (hoist tickSplace)
04:36:45 <dminuoso> *ReaderT Env IO
04:45:03 <joecordingley> Hi, I was trying to combine an 'f m' n times where f is an applicative and m is a monoid, and I can do fold <$> replicateM n fm, but I expencted fm to be a monoid anyway and use stimesMonoid, why is it not? 
04:47:18 <dminuoso> joecordingley: Take note that "n times" doesn't mean much because of the applicative.
04:47:53 <dminuoso> Consider the following example
04:48:22 <dminuoso> % foldMap Sum <$> replicateM 5 [1..5]
04:48:23 <yahb> dminuoso: [Sum {getSum = 5},Sum {getSum = 6},Sum {getSum = 7},Sum {getSum = 8},Sum {getSum = 9},Sum {getSum = 6},Sum {getSum = 7},Sum {getSum = 8},Sum {getSum = 9},Sum {getSum = 10},Sum {getSum = 7},Sum {getSum = 8},Sum {getSum = 9},Sum {getSum = 10},Sum {getSum = 11},Sum {getSum = 8},Sum {getSum = 9},Sum {getSum = 10},Sum {getSum = 11},Sum {getSum = 12},Sum {getSum = 9},Sum {getSum = 10},Sum {getSum = 11},
04:49:05 <dminuoso> I think you might have a too specific understanding of Applicative, tied to some particular instance perhaps.
04:50:06 <joecordingley> % foldMap Sum <$> replicateM 5 Just 1
04:50:06 <yahb> joecordingley: ; <interactive>:53:1: error:; * Could not deduce (Foldable Maybe) arising from a use of `foldMap'; from the context: Num t bound by the inferred type of it :: Num t => [Sum t] at <interactive>:53:1-35; There are instances for similar types: instance Foldable Prelude.Maybe -- Defined in `Data.Foldable'; * In the first argument of `(<$>)', namely `foldMap Sum'; In the expression:
04:50:15 <joecordingley> % foldMap Sum <$> replicateM 5 (Just 1)
04:50:15 <yahb> joecordingley: ; <interactive>:54:1: error:; * Could not deduce (Functor Maybe) arising from a use of `<$>'; from the context: Num a bound by the inferred type of it :: Num a => Maybe (Sum a) at <interactive>:54:1-37; There are instances for similar types: instance Functor Prelude.Maybe -- Defined in `GHC.Base'; * In the expression: foldMap Sum <$> replicateM 5 (Just 1); In an equation for `i
04:50:22 <joecordingley> ach
04:50:32 <dminuoso> % :q
04:50:32 <yahb> dminuoso: 
04:50:35 <dminuoso> % foldMap Sum <$> replicateM 5 (Just 1)
04:50:36 <yahb> dminuoso: Just (Sum {getSum = 5})
04:50:46 <dminuoso> People have shadowed the data Maybe with some custom here previously. :)
04:51:04 <joecordingley> I'm not sure I understand
04:51:35 <joecordingley> I mean your previous comment
04:51:35 <dminuoso> joecordingley: Someone typed `% data Maybe = Just a | Nothing` earlier, thereby shadowing the Prelude.Maybe/Data.Maybe.Maybe you are familiar with, along with its instances.
04:51:38 <dminuoso> Ah.
04:52:18 <dminuoso> joecordingley: What exactly do you mean by "I was trying to combine an 'f m' n times where f is an applicative and m is a monoid"?
04:52:57 <joecordingley> if I want to repeat an effectful function n times and combine the outputs 
04:53:17 <dminuoso> I see.
04:53:25 <dminuoso> Drop the fmap then.
04:53:56 <joecordingley> but then I have a list
04:53:56 <dminuoso> % :t \t a n -> foldMap t (replicateM n a)
04:53:57 <yahb> dminuoso: (Foldable t, Monoid m, Applicative t) => ([a] -> m) -> t a -> Int -> m
04:54:11 <dminuoso> uhh
04:54:19 <dminuoso> joecordingley: Yes, so?
04:54:30 <dminuoso> What you wrote is exactly right then.
04:55:17 <joecordingley> I mean I can do fold <$> replicateM fm but I just wanted to know if there was a one step version
04:56:04 <joecordingley> I just thought, if you have an applicative f and a monoid m, don't you automatically have a monoid of f m ?
04:56:11 <dminuoso> Not that I know of, but perhaps foldM is more descriptive for you?
04:56:36 <dminuoso> joecordingley: No.
04:57:15 <merijn> You want Ap
04:57:37 <dminuoso> Do they?
04:57:57 <merijn> That's the generalised monoid for Applicatives
04:58:23 <merijn> He's right that in *theory* every Applicative gives rise to a Monoid, but that instance doesn't exist because it overlaps everything
05:00:16 <dminuoso> merijn: I just dont see the relationship between Ap and the code he thought of.
05:00:24 <joecordingley> Ah thanks, I see, I think.
05:01:08 <merijn> dminuoso: He was assuming every Applicative was a monoid
05:01:28 <merijn> Which it is, but the instance doesn't exist
05:01:41 <joecordingley> I think it's easier for me to just use my earlier code, but I want to understand.
05:01:46 <joecordingley> Thank you.
05:01:58 <merijn> fold <$> replicateM (Ap fm)" should do what you want
05:05:00 <joecordingley> or getAp $ stimesMonoid n (Ap fm)
05:05:13 <merijn> yeah
05:06:25 <joecordingley> thank you very much
05:07:01 <merijn> dminuoso: How I saw it: "Mentions 'm' is a Monoid", "attempts to use 'Applicative f => f m' as monoid", my inference "they expect '(Applicative f, Monoid m) => f m' to be a Monoid", this believe is obviously justified, as it *is* a monoid theoretically, conclusion: "they want the Ap newtype which provides said instance" :)
05:58:35 <dminuoso> Couldn't match type ‘x’ with ‘a0’
05:58:37 <dminuoso> https://gitlab.com/snippets/1981286
05:58:53 <dminuoso> Is this an attempt at unifying a skolem against a unificational?
06:32:49 <timCF> Hi guys! Is there some style conventions about ordering of definitions in Haskell source code file? Something like `newtype` then `data` then instances for type classes then smart constructors, and finally other functions? Or everybody just puts definitions in any order he wants?
06:34:56 <solonarv> I'm not aware of any widely-used conventions based on what sort of declarations they are
06:35:32 <solonarv> the rules of thumb I use are "instances for a datatype or typeclass go right after that datatype's/typeclass' definition" and "put related things close to each other"
06:35:46 <int-e> Personally I try to find logical groups...
06:36:13 <int-e> which is quite vague; the outcome may depend on my mood
06:36:56 <merijn> timCF: I (try) to have some logical ordering
06:37:37 <merijn> Like start with high level exported functions, towards smaller internal helpers (or the other way around)
06:37:52 <int-e> Anyway, I would reject the idea of ordering the definitions by their type (newtype, data, type, family instances, classes, instances, standalong deriving, others?).
06:39:11 <Ariakenom> alphabetically based on the first letter of the line
06:39:22 <merijn> Ariakenom: :(
06:39:33 <merijn> I try and list exports as types first, functions later
06:39:44 <int-e> In any case there basically are no rules (and people will disagree wildly on what order is most logical. It reflects bottom-up and top-down thinking, among other things.)
06:39:49 <merijn> I keep being torn between "logical grouping" and "alphabetical" for export lists
06:40:10 <merijn> int-e: Worse, I do bottom up in some and top down in other modules ;)
06:40:50 <int-e> Or, if you have a function that has a big helper... do you put them together so that the implementation is in one place, or do you pull them apart so it's better to get a high-level overview of the module?
06:41:12 <int-e> The logical structure tends to be a digraph ;)
06:41:18 <timCF> thanks!
06:42:13 <int-e> s/better to get/easier to get/
06:43:40 <int-e> This is a big attraction of splitting code into several modules: The file system has a tree structure, so you escape the need to decide on a linear order for every thing.
06:44:21 <merijn> If only GHC properly supported cyclical imports :(
06:44:33 <int-e> Right.
06:44:58 <int-e> (I was about to say something along those lines as well :) )
06:46:59 <lortabac> in all my projects I consistently end up putting everything in a huge *.Types module to avoid cyclical imports :P
06:47:31 <merijn> lortabac: Yeah, which sucks :\
06:48:51 <int-e> nobody likes hs-boot files
06:50:29 <int-e> Let's have some statistics... ghc: 49. base: 13. Cabal: 1 (in a testcase ;-) ). Everywhere else: 0?
06:51:29 <int-e> (actually lambdabot has one, hmm)
06:53:27 <merijn> I just can't get them to work, usually :p
06:54:18 <int-e> I have not tried in a long, long time.
06:56:32 <int-e> But I guess I have not written very complicated code either.
07:05:58 <dminuoso> alp: What's the proposed way to turn a MultipartData directly into a (lazy) ByteString? The interface seems to require me to use `SourceT IO` - that seems fairly cumbersome.
07:07:34 <alp> dminuoso, https://hackage.haskell.org/package/servant-multipart-0.11.5/docs/Servant-Multipart.html#v:multipartToBody ?
07:08:31 <dminuoso> That doesn't really give me a bytestring though (and it seems to be primarily for servant-client)
07:08:44 <dminuoso> Im just wondering how to consume files sensibly given to me 
07:09:30 <absence> is there a simple way to combine a Validation applicative with a context/environment? Reader r (Validation e a) works, but it's annoying to work with because e.g. traverse doesn't go through both layers. I can Compose them, which means I have to reimplement ask(s), but it's not the end of the world. ReaderT r (Validation e) a doesn't work because Validation isn't a monad. are there other options?
07:13:08 <lortabac> dminuoso: IIRC if tag = Mem, fdPayload should give you a lazy ByteString
07:13:57 <dminuoso> lortabac: It does not. It hands you a `MultipartResult tag`
07:14:09 <lortabac> well, check the instances
07:14:28 <dminuoso> Ohh!
07:14:43 <dminuoso> I see. 
07:14:58 <dminuoso> This was really not obvious from the haddock
07:15:16 <Cale> absence: I'd say the "reimplement ask(s)" way is the way to go regardless. I'd usually do that even if I did end up with a monad, since using the mtl directly everywhere is kind of ugly.
07:26:32 <lortabac> dminuoso: yeah, I did it last week, it took me sometime to realize
07:27:21 <merijn> I wish Map had a more convenient way to construct them from sequence with error reporting for duplicate keys
07:27:54 <Sathiana> Can someone explain what is meant here: "Generally, if you have a function like
07:27:55 <Sathiana> foo a = bar b a, you can rewrite it as foo = bar b, because of currying."
07:28:04 <Sathiana> Thought I understood how currying works but i'm still confused in case, how is
07:28:06 <Sathiana> `foo = bar b` able to take a value, (a), if the foo lacks that parameter?
07:28:33 <merijn> Sathiana: What makes you say "foo lacks a parameter"?
07:28:47 <absence> Cale: ok, thanks!
07:29:21 <Sathiana> shouldn't be foo a = ... to be able to take a parameter ?
07:29:27 <merijn> Sathiana: You're defining the variable 'foo' to be equivalent to "bar b". If "bar b" is a function, then so is "foo"
07:29:41 <solonarv> absence: actually, the 'Applicative (ReaderT e m)' instance only needs 'Applicative m', not 'Monad m' - so that should work!
07:30:04 <solonarv> (to clarify, 'ReaderT r (Validation e)' should work)
07:30:13 <Sathiana> merijn: aaah, I see
07:31:43 <merijn> Sathiana: In Haskell there's little to no distinction between "variables" and "functions" (besides their types, obviously). They're all just names/bindings for values.
07:32:24 <Cale> If I was being picky, I'd say that a function is a sort of value, while a variable is not.
07:32:24 <merijn> Sathiana: "foo a b = a + b" could just as easily be defined as "foo = \a b -> a + b"
07:32:26 <tdammers> Sathiana: it may help to meditate on the fact that f x y is the same as (f x) y, that is, (f applied to x) applied to y
07:32:38 <Cale> Variables are names for values though.
07:32:45 <tdammers> hence, foo a b means 
07:32:51 <Cale> (possibly functions)
07:32:52 <tdammers> "foo applied to a, applied to b"
07:33:01 <tdammers> and bar b means "bar applied to b"
07:33:28 <tdammers> so when we say "bar equals foo applied to a", then it should be easy to see how that works out
07:34:11 <tdammers> the "currying" part is a bit of a red herring, because nothing "gets curried" here, it's more that Haskell doesn't really have multi-argument functions in the first place, so we "emulate" those by writing functions that return functions
07:34:56 <tdammers> in foo a b, foo is a function that takes one argument (like all Haskell functions), but instead of returning a non-function value directly, it returns another function, and that function takes the "b" argument, returning the result of the entire calculation
07:37:53 <Sathiana> merijn: tdammers : I was reading a question on Stackoverflow and saw a function that takes two arguments (in its definition) being turned into (Pointfree)  one that looked like it took no arguments 
07:38:27 <Sathiana> then was confused when I saw that statement 
07:39:30 <Sathiana> but will meditate on it and fully grasp it 
07:39:39 <tdammers> what makes these things confusing is that we sometimes use slightly incorrect terminology and talk about "n-ary" functions, when really they are all higher-order unary functions, i.e., functions that return functions
07:40:23 <frdg> Once I left the idea of currying behind everything started to make more sense. 
07:40:24 <tdammers> so by the inaccurate but common interpretation, "foo" in "foo a b" is a binary function, taking two arguments; but the accurate version would be that "foo" is a function that returns a function
07:40:44 <merijn> frdg: tbh, I find it very frustrating many intros to Haskell talk about currying
07:40:52 <merijn> It's an entirely useless concept when explaining Haskell
07:41:03 <Sathiana> yes, that is making it difficult when learning, many terms describing the same thing 
07:41:05 <tdammers> currying only really makes sense in a language that truly supports multi-argument functions
07:41:05 <merijn> And it just misdirects everyone's thoughts to the wrong things
07:41:14 <merijn> tdammers: Or when comparing languages
07:41:34 <tdammers> merijn: yeah, but even then, at least one of them has to support multi-argument functions for the term to be useful
07:41:37 <solonarv> I suppose it also makes sense to call the transformation from '(a, b) -> c' to 'a -> (b -> c' "currying"
07:41:54 <solonarv> but if you never have a function taking a tuple in the first place, you're not doing currying either
07:42:01 <merijn> solonarv: Sure, but even then that's pretty uninteresting for most beginners
07:42:03 <tdammers> solonarv: yes, if you accept the interpretation that a function that takes an n-tuple as its argument is n-ary
07:42:22 <tdammers> and, yeah, it's uninteresting at this stage
07:50:19 <fosterite> Hello, does anyone remember a presentation by Edwin Brady about parsing files (jpegs, maybe) in idris?
07:50:51 <fosterite> Someone asked a question about why there was a +10 in the calculated length in the type, IIRC
07:59:35 <ezzieyguywuf> hwat does the ampersand mean in this snippet? `data Graph a b = Empty | Context a b & Graph a b`
08:00:14 <merijn> ezzieyguywuf: That's not valid Haskell
08:00:27 <merijn> ezzieyguywuf: Is it maybe :& ?
08:00:28 <ezzieyguywuf> ah
08:00:49 <veverak> so, I want to use haskell script to render data based on input written in haskell
08:00:54 <merijn> If not, then where did you see it?
08:00:55 <veverak> but, the recompilation is still slow :/
08:00:56 <ezzieyguywuf> no, it's not valid haskell you're right, I was misreading the explanation here: https://stackoverflow.com/a/38881393/4608626
08:01:01 <veverak> any tips about how to improve this?
08:01:52 <merijn> That said, I actually don't think the common graph libraries in Haskell are particularly great at representing graphs
08:02:03 <merijn> Although it depends on what you wanna do with said graphs
08:02:58 <ezzieyguywuf> I want to create a graph of geometric vertices edges and faces to represent 3d objects
08:03:03 <Ariakenom> is there a language with particularly great graph libraries? I remember lacking that when I looked many years ago 
08:03:30 <ezzieyguywuf> i.e. for a given vertex, I'd need to know which edges and faces are adjacent, etc.
08:04:03 <ezzieyguywuf> i found myself essentially writing my own graph library, so I thought I'd look around and see if there was one already in existing that I could leverage
08:04:19 <ezzieyguywuf> merijn: but based on your comment, maybe there isn't a de facto haskell graph library?
08:06:12 <merijn> @hackage fgl
08:06:12 <lambdabot> https://hackage.haskell.org/package/fgl
08:06:36 <ezzieyguywuf> merijn: I had just opened that in a new tab, was going to peruse it after I finished digesting that SO answer I linked ^_^
08:07:01 <merijn> ezzieyguywuf: The problem with those is that they're represented as complex ADTs. For analysis algorithms on static graphs I'd probably go for a Vector based CSR representation instead
08:07:10 <ezzieyguywuf> I was first looking at containers, which has a Data.Graph, but it seems to be for strictly directed graphs
08:07:13 <merijn> Which I suspect will be 1) much faster and 2) less memory hungry
08:07:27 <merijn> ezzieyguywuf: undirect graphs are a subset of directed ones, tbh
08:07:28 <ezzieyguywuf> merijn: erm...what's an ADT and CSR?
08:07:44 <merijn> ezzieyguywuf: ADT algebraic data type (so really just various sum types and list)
08:08:07 <merijn> ezzieyguywuf: CSR is Compressed Sparse Row which is a common representation for sparse matrices (and graphs)
08:08:18 <ezzieyguywuf> I don't expect my graphs to be static - a cube and a cylinder can be fused to make a new graph
08:09:01 <fosterite> are you thinking of meshes or some kind of CSG
08:09:27 <fosterite> fusing meshes like that requires some tricky computational geometry and the choice of graph library is not the major factor
08:10:21 <ezzieyguywuf> fosterite: neither, I was thinking Boundary Representation where each solid is represented by it's outer-boundary of Faces
08:10:47 <fosterite> How is that different from a mesh?
08:11:38 <ezzieyguywuf> a mesh, per my understanding, is a collection of little triangles
08:11:47 <ezzieyguywuf> a brep is a collection of arbitrary surfaces
08:12:26 <ezzieyguywuf> I consider it akin to the difference between raster graphics and vector graphics
08:14:15 * hackage hsinspect-lsp 0.0.2 - LSP interface over the hsinspect binary.  https://hackage.haskell.org/package/hsinspect-lsp-0.0.2 (tseenshe)
08:17:45 * hackage splitmix 0.0.5 - Fast Splittable PRNG  https://hackage.haskell.org/package/splitmix-0.0.5 (phadej)
08:32:40 <Ariakenom> merijn: is there a language with particularly great graph libraries?
08:34:56 <merijn> No :p
08:35:43 <ezzieyguywuf> I'm used to using Qt in C++ as pretty much a standard for creating cross-platform GUI's. is there a similar library in haskell?
08:36:16 <ezzieyguywuf> or would i be better off writing a gui frontend still in Qt and then having it interact with a haskell backend using sockets or something?
08:36:17 <merijn> ezzieyguywuf: There's not really any standard cross-platform GUI for Haskell
08:36:44 <Taneb> There exist QT bindings for Haskell but I can't comment on their quality
08:36:55 <merijn> ezzieyguywuf: Doesn't need to be a separate process with a socket, you can easily just call Haskell directly
08:37:09 <merijn> ezzieyguywuf: The C FFI is pretty good and easy
08:38:45 <ezzieyguywuf> merijn: ah, I remember reading about this foreign function stuff
08:39:14 <merijn> ezzieyguywuf: If you know C and basics of linking it's all pretty straight forward
08:39:29 <merijn> ezzieyguywuf: Chapter 8 of the report and the GHC user guide cover it pretty well
08:39:33 <merijn> @where userguide
08:39:33 <lambdabot> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/
08:39:59 <ezzieyguywuf> merijn: will I have to figure the linking stuff out manually or can I make cabal do it?
08:40:24 <ahri> speaking of linking, when trying to compile a haskell program with -optl-static I'm getting an error I've never seen before: 'error: relocation refers to local symbol "" [1], which is defined in a discarded section' - I think this is after having updated to the latest LTS of ubuntu, any idea how I can fix this?
08:40:36 <merijn> ezzieyguywuf: For C you can easily have cabal compile stuff for you, C++ is a bit trickier, but you can just have cabal build a shared library
08:40:41 <infinisil> Ariakenom: I do like https://hackage.haskell.org/package/algebraic-graphs
08:40:47 <infinisil> But I haven't used it that extensively
08:41:20 <ezzieyguywuf> merijn: cool. I'm not there yet, but it's nice to know that this should be relatively straightforward when I reach that point
08:41:49 <ezzieyguywuf> I will, in essence, be writing two libraries - the haskell one and the gui (probably qt) one, and they'll link to each other and inter-operate lovingly.
08:43:10 <merijn> ezzieyguywuf: As long as you don't want to mutate structs from Haskell (so only passing pointers or primitives like int/double/etc.) is pretty easy
08:43:38 <merijn> mutating structs is a bit more annoying, but not much
08:43:51 <ahri> (static linking error mentions /usr/lib/x86_64-linux-gnu/libm-2.31.a so perhaps I need a different package?)
08:44:41 <ezzieyguywuf> yea, well I'm going to be defining my data structures in Haskell (Face , Edge, Vertex, Solid [Face]) which the foreign program will be mutating
08:44:48 <ezzieyguywuf> so I guess I'll have to deal with those annoyances
08:45:34 <Ariakenom> infinisil: I recognise those primitives, I probably had a look at some point
08:46:28 <merijn> ezzieyguywuf: Linking/calling C functions can be as simple as: https://github.com/merijn/Belewitte/blob/master/benchmark-analysis/src/SQLiteExts.hs#L83-L131
08:47:30 <merijn> Which is importing a bunch C functions as function pointers
08:48:45 * hackage composition-prelude 3.0.0.1 - Higher-order function combinators  https://hackage.haskell.org/package/composition-prelude-3.0.0.1 (vmchale)
08:53:31 <ezzieyguywuf> merijn: thanks for the example
09:03:04 <ystael> Should I expect output from `Debug.Trace.trace` and friends to show up when I run Hspec? Because right now it doesn't, and on searching I find a discussion of this issue from 2012 which seems to end in the statement that "--verbose makes it show up now". Which isn't true for me, but I don't know whether that's because of something weird in our setup.
09:03:48 <wavemode> trace only traces if the expression is forced
09:04:05 <wavemode> clearly laziness is causing it to be ignored
09:06:04 <ezzieyguywuf> wow, I found this first chapter very illuminating: https://livebook.manning.com/book/functional-programming-in-c-plus-plus/chapter-1/1
09:07:15 * hackage splitmix 0.1 - Fast Splittable PRNG  https://hackage.haskell.org/package/splitmix-0.1 (phadej)
09:07:26 <ystael> wavemode: Derp, that was exactly it. Thank you!
09:12:29 <xerox_> ezzieyguywuf: not bad!
09:41:50 <sm[m]> ystael: yep trace is great for revealing that :)
09:42:15 <ezzieyguywuf> xerox_: ikr! kind of makes me want to read the rest of the book.
10:00:45 * hackage df1 0.4 - Type, render and parse the df1 hierarchical structured log format  https://hackage.haskell.org/package/df1-0.4 (RenzoCarbonara)
10:06:45 * hackage di-df1 1.2.1 - Write logs in the df1 format using the di logging framework  https://hackage.haskell.org/package/di-df1-1.2.1 (RenzoCarbonara)
10:15:27 <veverak> how is it with brackets in case of <> and $ ?
10:15:39 <veverak> $  $   $ <> $  $  $ <> $  $  $ ....
10:17:56 <dsal> ?
10:18:21 <xerox_> infixr 0 $, infixr 6 <>
10:18:33 <veverak> I have something like: a $ b $ c <> d $ e $ f
10:18:43 <EvanR> yeesh
10:18:48 <EvanR> too many $
10:18:57 <dsal> rich people and their high dollar haskell
10:19:10 <{abby}> sweet jesus
10:19:11 <veverak> ,so is it: (a $ b) <> (d $ e) or a ( b <> (d $ e) )
10:19:15 <EvanR> newtype riche
10:19:34 <veverak> it's not like htis, it's in more complex setup that is over multiple lines
10:19:42 <{abby}> % :t \a b c d e f -> a $ b $ c <> d $ e $ f
10:19:42 <yahb> {abby}: Semigroup t1 => (t2 -> t3) -> (t1 -> t2) -> (t4 -> t1) -> (t4 -> t1) -> (t5 -> t4) -> t5 -> t3
10:19:42 <juri_> hey, i upgraded to ghc 8.8, and now nothing on my system is able to build. https://gist.github.com/julialongtin/22301aafeaa2a521ce3239df3228f789
10:20:07 <juri_> it looks like comonad wants distributive, which is upset about cabal?
10:20:21 <{abby}> % :t \a b c d e f -> a (b ((c <> d) (e f)))
10:20:21 <yahb> {abby}: Semigroup t1 => (t2 -> t3) -> (t1 -> t2) -> (t4 -> t1) -> (t4 -> t1) -> (t5 -> t4) -> t5 -> t3
10:20:31 <{abby}> veverak: ^ it's that atrocity
10:20:32 <dmwit> veverak: it's a $ (b $ ((c <> d) $ (e $ f)))
10:20:36 <veverak> {abby}: thanks
10:20:38 <EvanR> operators, parentheses and $ all in a big complex expression is just too muc
10:20:42 <veverak> dmwit: thank you too
10:21:00 <veverak> note to myself: learn to use :t
10:25:45 <dsal> _ is :t when you're compiling code instead of ghci'n
10:27:00 <{abby}> don't forget to pass -fno-show-valid-hole-fits if you don't want to wait for the type of something
10:27:15 * hackage df1-html 0.1 - Render and parse df1 logs as HTML  https://hackage.haskell.org/package/df1-html-0.1 (MelisaLauraDiaz)
10:47:59 <ezzieyguywuf> hrm, I don't know about performance or w/e, but fgl seems like it may suit my needs just fine
10:48:22 <ezzieyguywuf> I don't know what a PatriciaTree is, but I don't think I need to know in order to use the library
10:53:43 <dmwit> ezzieyguywuf: Right, you mostly don't need to know.
10:55:35 <ezzieyguywuf> the one thing that confuses me in this blog post is the idea of 'distance' for the Edge - is this necessary? What if I just want to know about adjacencies? https://mmhaskell.com/blog/2017/6/21/graphing-it-out
10:58:50 <dsal> edges usually have weights.  If you don't care, you can just set them all the same.  Depends on what you're doing.
10:58:55 <ezzieyguywuf> nvm, I see now that it's a requirement of the shortest-path algorithm
10:59:38 <dsal> Sometimes you model all distances as 1.  Sometimes a particular hop is more costly.
10:59:42 <ezzieyguywuf> dsal: yea I see that now. I mistakenly thought that the b in `type LEdge = (Node, Node, b)` was for a uniqueID or something
10:59:56 <ezzieyguywuf> but it's just the 'label', which is used as 'weight' in the shortest-path algorithm
11:00:03 <dsal> ah
11:00:37 <merijn> ezzieyguywuf: PatriciaTrees are basically "more efficient search trees" (so binary trees on steroids)
11:00:51 <ezzieyguywuf> my coach said steroids are bad...
11:01:11 <merijn> ezzieyguywuf: Only if you hate winning ;)
11:01:27 <Cheery> appropriate pun
11:01:57 <merijn> ezzieyguywuf: basically, binary search trees assume that "less than or greater than" is the only information you have of elements. Patricia trees exploit more detailed information of the contents (making them less general, but faster)
11:01:57 <ezzieyguywuf> lol
11:02:27 <ezzieyguywuf> merijn: yea I saw an SO post talking about radix and stuff and showed an example with bits and bytes
11:02:30 <ezzieyguywuf> it mostly made sense
11:03:22 <ezzieyguywuf> so if an Edge's label can be used to specify a weight, what good is the Node label?
11:03:32 <ezzieyguywuf> the shortest-path algorithm in fgl doesn't seem to require an LNode, just a Node
11:03:50 <merijn> ezzieyguywuf: Pagerank is generally associated with nodes, so that's one example
11:04:06 <ezzieyguywuf> so again, it's not a uid
11:04:28 <ezzieyguywuf> i guess 'label' is just 'arbitrary data'
11:04:51 <dmwit> Edges and nodes are both uniquely determined by an Int that you should probably imagine not having control over.
11:05:28 <dmwit> The library gives you a way to associate those Ints with some data if you like.
11:05:32 <ezzieyguywuf> dmwit: no control over, but insight into, yea? i.e. I can say "hey, which nodes are adjacent to node 1?"
11:05:50 <dmwit> (Unfortunately, they do not give a way to associate some data with an Int, which means I typically end up keeping that association off to the side. Annoying.)
11:05:53 <ezzieyguywuf> dmwit: right, and that association is the label
11:06:19 <ezzieyguywuf> dmwit: ah, you mean the reverse-lookup type deal
11:06:22 <dmwit> I don't know what "insight" means. I usually treat them as opaque, not as Int.
11:06:27 <ezzieyguywuf> what if more than one node has the same data?
11:06:32 <ezzieyguywuf> i guess you'd return [Node]
11:06:33 <dmwit> I wouldn't advise adding two node identifiers.
11:07:05 <EvanR> newtypes rock
11:07:16 <ezzieyguywuf> by 'insight' I mean I should be able to query how many nodes there are, and what their identifiers are
11:07:25 <dmwit> ezzieyguywuf: For the applications I have, usually there are not two nodes with the same data.
11:08:06 <dmwit> If there are, it seems less likely that an association from label to identifier is useful.
11:09:01 <ezzieyguywuf> dmwit: I agree it'd be useful, but I guess I'm confused about how useful it is in the case where you have duplicate labels.
11:56:36 <dsal> Someone sent me a PR for my mqtt library that added a `$!` claiming it solves a timeout problem occurring after an ubuntu upgrade and ghc-8.8.3.  It's on a C.mapM_ of a conduit where I'm taking the input and sending it off to an IO action.  Super confused as to why it needs to be strict, but I also have no idea how to reproduce the problem, so I don't know if I can do it better.
11:57:08 <dsal> I use this code a lot in a lot of different places, so I'm a bit curious.  I guess I can try to contrive something.
11:58:26 <xerox_> dsal: would be interesting to make a small test case that shows it off, independent from the rest, maybe they can help with that?
12:04:56 <electricityZZZZ> can i automatically generate haskell types from a postgres database? i don't think (?) this is considered an orm; i'm too lazy to define (again) my types if possible
12:05:11 <xerox_> electricityZZZZ: there's a module that does that at compile time!
12:05:41 <merijn> electricityZZZZ: You will regret this in the future
12:06:00 <wavemode> electricityZZZZ: I have nothing to add, just saying hi
12:06:32 <merijn> electricityZZZZ: I thought like this 3-4ish years ago, and the "I regret this early decision" counter is currently at, like, 12 :p
12:06:39 <Cheery> has anybody used categorical databases here?
12:06:53 <Cheery> or ologs
12:07:14 <monochrom> Is olog like logarithm of oleg? :)
12:07:19 <merijn> electricityZZZZ: I've been slowly adding these types I couldn't be arsed to define and each time I add more my happiness and the maintainability increase :)
12:07:33 <monochrom> 1 millioleg = -3 olog
12:07:36 <Rembane> electricityZZZZ: You can do it the other way around. But I think in the long run you won't be too sad for that double work.
12:07:36 <Cheery> https://en.wikipedia.org/wiki/Olog
12:08:06 <Rembane> merijn: Do you increase your counter everytime you regret?
12:08:14 <Cheery> it's this kind of categorical treatment to relational database systems.
12:08:23 <xerox_> I can't find it anymore, it was kinda cool, it will connect to the db when you compile the haskell source to check it against the schema, by producing types
12:09:47 <wavemode> well theres: https://hackage.haskell.org/package/squeal-postgresql-0.6.0.2/docs/Squeal-PostgreSQL.html
12:10:04 <wavemode> which I think is a bit more sensible, since it's the other way around. it generates a schema from your types
12:10:05 <Cheery> I've actually thought about putting up postgresql to my server and then ssh-manipulating it through haskell programs to get different kind of small datasets for various things I need to track
12:10:12 <merijn> Rembane: As a proxy, I actually have a schema version which is currently at 24, to indicate the number of times I changed my mind ;)
12:11:00 <Cheery> schema from types seem much more sensible.
12:11:44 <Cheery> Those ologs sort of form like a schema and a way to instance and constraint datasets.
12:12:02 <Cheery> understood you can derive types and schema from it.
12:13:09 <wavemode> the ultimate would be if they could each be generated from each other. like that time travel movie I watched about a man who was his own father
12:13:42 <Rembane> merijn: Got it. :D
12:14:13 <Rembane> Recursive schemas are recursive.
12:14:28 <merijn> Rembane: Mind you, there's some schema changes just for simplicity (so each individual transition is simple) and not every problem with the original code is reflected in the schema
12:15:12 <merijn> I used persistent to get the schema and datatypes in one go without having to define "double boilerplate", but in hindsight I'd just use sqlite-simple if I had to redo it
12:16:12 <Rembane> merijn: How different are the types from each other in the Haskell case and the SQLite case? Where I assume that you have records in Haskell that maps to rows in the tables. 
12:17:16 <merijn> Rembane: I'm still using the persistent generated stuff, and maybe a handful of custom variations
12:17:29 <merijn> It's too much work to migrate to sqlite-simple
12:17:39 <Rembane> merijn: Okay, I can totally see why. 
12:18:20 <merijn> Rembane: I've put a number of patches into persistent-sqlite to get things to where I want them, so it's mostly fine now
12:18:53 <Rembane> merijn: Nice, but IIRC you wouldn't recommend persistent to anyone? 
12:20:17 <merijn> Not really, there's a number of things where it's not entirely clear how to safely use the persistent API and the obvious usecases aren't safe. Getting datatypes and schema in one thing is nice, but in hindsight the amount of work that saves is negligible
12:20:59 <merijn> In general, the main conclusion from working on this code has been "defining lots of custom and redundant datatypes" is great and using stuff like Bool, Either, and tuples is bad :p
12:21:11 <Rembane> On that description it sounds that a user of persistent trades the really important stuff for something that's nice on the surface but doesn't matter. 
12:21:19 <merijn> In other words, more boilerplate = better :p
12:21:28 <Rembane> So, don't code in Python in Haskell, code in Haskell instead? :)
12:22:23 <merijn> Types and custom interfaces = pretty great :p
12:23:01 <Rembane> Totally, less ways for creative future self to misinterpret and fudge things up.
12:23:09 <merijn> But transferring that knowledge is hard, same thing for type systems. It's hard to teach people who haven't gone through the pain why the short term gain isn't worth it :p
12:25:08 <Rembane> Yes. Type boot camp is needed. 
12:25:16 * Rembane signs up to be drill sergeant.
12:25:17 <monochrom> People who have gone through the pain may still consider it "productivity".
12:25:26 <merijn> monochrom: I know, that's even worse
12:25:34 <merijn> monochrom: I don't know how to fix/address either issue
12:25:35 <Rembane> monochrom: Would they consider the pain productivity?
12:25:42 <merijn> Rembane: Just look at Uncle Bob
12:25:51 <monochrom> When the Python official website claims "many users report increased productivity", you know they mean this.
12:25:55 <merijn> All problems are just insufficient programmer discipline
12:26:02 <Rembane> merijn: Yeah... good point. 
12:26:11 <monochrom> When C programmers brag about writing "real code", you know they mean this.
12:26:14 <merijn> monochrom: Of course, because before the didn't automate anything at all ;)
12:27:26 <dsal> xerox_: Sorry, typed and then went to lunch.  Yeah, they seem to have a repro on their system.  Kind of annoying to have something I use so heavily have a weird edge case like that.
12:27:32 <ja> if the universe is not deterministic, God is not sufficiently disciplined ;)
12:27:43 <xerox_> dsal: yeah
12:28:09 <monochrom> People have this prehistoric notion that you have to look busy in order to be called "productive".
12:28:39 <merijn> monochrom: I'm in organisation whose main purpose is "interacting with and supporting scientists writing code" and it's all Python stuff (except those daring R/Julia people...)
12:28:50 <Rembane> merijn: Any Fortran? 
12:28:55 <merijn> Rembane: Tons
12:29:06 <Rembane> merijn: How horrendous is it? 
12:29:12 <merijn> monochrom: But the Haskell/Rust cult is building steam internally
12:29:17 <monochrom> Dijkstra was the first one to burst this bubble and state that it's on the wrong side of the ledger, you should be measuring the amount of work saved.
12:29:19 <merijn> Rembane: Can't tell, I don't know FOrtran :p
12:29:51 <ja> that's the issue no? if you can't measure it, you'll always have some doubeters :P
12:30:14 <Rembane> merijn: But maybe you've seen the secondary effects of it? :)
12:30:28 <merijn> My code has segfaulted due to it, yes :p
12:30:34 <Rembane> :D
12:30:43 <monochrom> You can measure how many problems solved.  You can measure lack of bugs, lack of issues.  You can measure no-news-is-good-news.
12:31:13 <merijn> monochrom: But we don't wanna!
12:31:34 <ja> if you could sufficiently measure it, the world would be overrun with haskell firms
12:31:53 <Rembane> monochrom: But I can create more problems to have more problems solved. 
12:31:59 <monochrom> For example to measure a sysadmin's productivity, don't look at the sysadmin, look at the users. If the users look like doing fine and seldom needing help, the sysadmin has succeeded. (Oh, then you peek into the sysadmin office and find them slack off, that's even better.)
12:32:07 <sshine> productivity, sunk cost, potato schmomato.
12:33:14 <merijn> monochrom: Don't underestimate the Stockholm syndrome of people starting to like painful work :p
12:33:19 <merijn> See: all of git
12:33:33 <sshine> monochrom, similarly, the best code is code that doesn't exist. :-P it can't crash, and it has a zero cost of maintenance.
12:33:51 <ja> merijn: git itself was painful to write? or is it painful for a haskeller to read?
12:34:01 <merijn> ja: It's painful to use
12:34:11 <monochrom> Oh, today in my lecture I had the chance to say "some errors can be fixed by deleting code" :)
12:34:17 <merijn> git is one of the worst version control tools in terms of UX and ease of use
12:34:34 <ja> it is much better than svn, if you ask me
12:34:38 <merijn> Literally the only good thing git has (exclusively) is "github" 
12:34:40 <ja> and i see people praising magit left and right
12:34:42 <sshine> monochrom, hehe. I had a student job where I left after 18 months having deleted twice as much code as I'd added. that felt good.
12:35:16 <sshine> (the trick is to deprecate an entire database layer.)
12:35:41 <monochrom> I was explaining why "r :: [a] -> [a]; r x = [False, True]" is wrong.  So I put it in a file, loaded into ghci, to show the error message.  Then I got to say "so I'm going to fix this error by deleting the wrong code".
12:35:41 <merijn> ja: Distributed version control is better than SVN, sure
12:35:56 <merijn> ja: But there's many tools that do distributed version control with a saner UI than git
12:36:37 <ja> it takes time, i think git does reasonably well on many fronts. you don't like the command line flags, but maybe their consistency is not as important as you assume
12:36:45 <sshine> merijn, 'git clone' is pretty neat no?
12:37:01 <merijn> sshine: Compared to what?
12:37:08 <sshine> merijn, compared to SVN, CVS.
12:37:11 <merijn> sshine: Like, "hg clone" functions just as well
12:37:15 * hackage popkey 0.1.0.0 - Static key-value storage backed by poppy  https://hackage.haskell.org/package/popkey-0.1.0.0 (identicalsnowflake)
12:37:17 <sshine> merijn, sure okay.
12:37:25 <merijn> sshine: See above, there's many other distributed version control systems that suck less than git
12:37:50 <monochrom> I'm OK with git, but I'm a shallow user.  Also, I like the "create another branch" style.
12:37:58 <ja> does perforce suck less? people had a choice and they preferred git
12:38:05 <merijn> Everyone is just so used to it's insanity because they don't know any better anymore
12:38:08 <merijn> ja: No
12:38:13 <merijn> ja: People preferred *github*
12:38:28 <merijn> I'm 100% convinced github is the entire and sole reason for the git monoculture we have now
12:38:30 * sshine bothered to look into Pijul today. I'm going to try it out for my next toy project. then I read this in the FAQ: Q: "Is it possible to refer to a specific version?" A: "Yes! Although nothing is implemented so far, [...]" :-D
12:38:38 <merijn> Because it's still better than all the alternatives
12:38:40 <EvanR> i used git before it was cool
12:38:49 <electricityZZZZ> sshine: yeah i have my eye on pijul too
12:38:50 <sshine> EvanR, I was a git before it was cool. wait, is it cool yet?
12:38:59 <merijn> And 6 years ago all the github alternatives were even worse than they are now
12:39:10 <merijn> EvanR: I still don't use git
12:39:18 <merijn> I've come this far, I'm not planning to start now!
12:39:29 <EvanR> u so bad
12:39:35 <electricityZZZZ> pijul actually is a major reason i hesitate to invest in learning more about haskell. the darcs cvs project i guess ended up as not very usable software (?) according to what i read
12:39:54 <merijn> electricityZZZZ: What?
12:39:54 <ja> darcs does cvs too? my god
12:40:03 <sshine> electricityZZZZ, https://nest.pijul.com/ looks kinda usable.
12:40:04 <merijn> electricityZZZZ: That seems like rather non sequitur?
12:41:01 <ja> text-based programming is so yesterday! if you migrate from git may as well go directly to ast-based version control in Lamdu!
12:41:02 <sshine> electricityZZZZ, what's the chain of reasoning?
12:41:52 <sshine> electricityZZZZ, Darcs being unstable and made in Haskell, so Haskell is bad? is that like blaming communism on hammers and sickles?
12:42:00 <EvanR> AST-based programming is too syntactic
12:42:07 <EvanR> semantic version control
12:42:20 <merijn> ja: I still use github and other languages for now, so not anytime soon ;)
12:42:29 <sshine> we haven't seen half yet. I'm thinking Unison. :)
12:43:00 <monochrom> \∩/ math matches intuition, every time. (good luck with that.)
12:43:22 <sshine> ja, oh, Lamdu has similar goals to Unison. I'm a slow typer.
12:44:00 <ja> i just see unison as more ambitious, and i don't know if i believe in it
12:44:12 <ja> bandwidth is not made equal, a remote machine is not my machine
12:44:14 <wavemode> Mercurial is vastly better than git IMO. git just has more momentum and IDE integrations and GUIs and free services (GitHub etc.)
12:44:17 <monochrom> Something as simple as "product [] = 1, all [] = True" are sound math models that mismatch intuition.
12:44:24 <merijn> wavemode: I know, that's why I use mercurial :)
12:44:37 <merijn> wavemode: Have you not heard of our lord and saviour hg-git?
12:44:51 <sshine> ja: I think it's viable but we'll see if it gets the needed traction. I haven't written any Unison yet.
12:45:42 <EvanR> intuition is hammered into shape as needed
12:45:46 <sshine> merijn, I used git-svn at my old job. maybe I should look into hg-git when I realize Pijul isn't ready for production yet.
12:45:56 <ja> yeah and i have only written toy things in Lamdu, they still do not have user-defined data types...
12:46:17 <merijn> sshine: I've been using github since...probably 2013 and collaborated in several companies where everyone uses git using hg-git exclusively
12:46:24 <monochrom> \∩/ finally a category theory application that cares about pushouts.
12:46:24 <sshine> ja: who needs them! it's all 0s and 1s anyway!
12:47:00 <sshine> merijn, with git-svn I ended up with a lot of GC'ing. I don't suppose that's the case for the hg-git bridge?
12:47:00 <monochrom> http://www.vex.net/~trebla/photo/unorganized/IO-String.png   my favourite pushout
12:47:13 <merijn> sshine: There's a few nits. 1) is git submodules don't work, so you can't use it on anything using those, 2) I'm not sure if/how it handles octomerges, but then again I've never seen an octomerge in real life
12:47:21 <EvanR> 0 or 1, spoiler alert, is a user defined data type
12:47:35 <merijn> sshine: With hg-git you just directly clone/push/pull from git repo's using hg
12:47:42 <wavemode> analog computing ftw
12:47:46 <ja> the world is a user-defined data type ;)
12:47:55 <sshine> *mind blown*
12:48:13 <monochrom> RealWorld is an imaginary data type :)
12:48:22 <[exa]> monochrom: I'm saving that diagram for future reference
12:48:26 <merijn> sshine: The only thing that doesn't really work is cloning the hg repo using hg and then trying to push back to git
12:48:27 <monochrom> :)
12:48:38 <merijn> sshine: But if it's just you talking to other people's git repos it's fine
12:49:12 <monochrom> [exa]: If you want to, you can load http://www.vex.net/~trebla/photo/unorganized/IO-String.xcf into gimp and do further editing!
12:49:46 <merijn> sshine: Actually, the mercurial people are walking on a new mainline git extension (hg-git is 3rd party and not maintained very actively), but this new stuff promises to be even more robust/fast when it's production ready
12:49:51 <electricityZZZZ> i haven't used darcs, i don't know. i'm dependent on forum posts, which might be paid for by the C++ lobby or adversaries seeking to keep our code buggy. and those forum posts claimed both that darcs had major performance issues which limited its suitability for real-world usage,... and some folks blamed the haskell language for those issues,... but of course either of those statements could be false.
12:50:11 <merijn> electricityZZZZ: darcs had pretty severe algorithmic issues
12:50:15 <electricityZZZZ> maybe the project just had high level design problems
12:50:16 <electricityZZZZ> yeah
12:50:33 <merijn> electricityZZZZ: One of the main selling points of pijul is that they claim to have solved those
12:51:12 <[exa]> monochrom: worry not I'm typesetting it with tex right now
12:51:22 <monochrom> haha
12:52:51 <[exa]> merijn: btw, sorry for jumping into the discussion, can you point out some particular most painful interface problems of git?
12:54:15 <merijn> [exa]: The fact that checkout does 3 completely orthogonal things, inconsistencies between flags and arguments, commands structured around underlying representation rather than human workflows, in general putting (excessive!) flexibility front and center where the 99% of us who are not "the linux project" don't need all that
12:54:16 <monochrom> I think I'm interested in pijul now.
12:54:25 <monochrom> What is the etymology of pijul?
12:54:39 <merijn> monochrom: It's a bird
12:54:56 <merijn> monochrom: "Pijul is the mexican name of Crotophaga sulcirostris, a bird known to do collaborative nest building."
12:55:01 <fendor> checkout does no longer do three inconsistent things
12:55:09 <fendor> now there is restore! 
12:55:09 <monochrom> neato
12:55:09 <merijn> fendor: It now does 4?
12:55:30 <fendor> merijn, probably, but some commands now have a sensible alternative, e.g. restore instead of checkout -- 
12:56:12 <monochrom> haha that's great
12:56:54 <yushyin> https://github.com/git/git/blob/master/Documentation/RelNotes/2.23.0.txt#L61
12:57:20 <[exa]> merijn: well good point. Checkout problem is historical (I believe checkout was a pipeline-style script originally), but the linux focus is certainly interesting to think about
12:57:33 <[exa]> merijn: thx
12:57:53 <merijn> [exa]: Stuff like octomerges, or the whole distinction of "upstream" "tracking", etc.
12:58:08 <sshine> I wonder if the mexican Pijul bird actually has conflict-free merges, or if their nests are not built on an algebraic foundation. much disappoint ensues.
12:58:46 <[exa]> sshine: I imagined the birds doing a hard reset if 2 grass stalks collide
12:59:10 <EvanR> a command that does three things, this is not very unix. There should be three separate programs. And a fourth program which replaces the original that runs all three for me. Called the same thing as before
12:59:20 <monochrom> I'm sure pijuls find their nest building intuitive. :)
12:59:47 <sshine> [exa], surely birds must have perfected cherry-picking. :-D
12:59:51 <EvanR> this remark is joke-polymorphic. It can be a joke or not
12:59:56 <[exa]> merijn: octomerges are m'kay, except they should be in something like git-super-contrib
13:00:27 <[exa]> and well upstreams have been glued there :D
13:02:07 <sshine> I read one joke on twitter the other day: This Fibonacci joke is as bad as the last two you heard combined.
13:02:26 <monochrom> hahahaha
13:03:07 <sshine> https://twitter.com/sigfpe -- I thought he had gone underground with his blog being inactive.
13:04:54 <merijn> I'd tell you an UDP joke, but I'm not sure you'd get it
13:05:20 <wavemode> I'd tell you a laziness joke, but nobody's asked for one
13:05:29 * EvanR walks out
13:07:22 <electricityZZZZ> ahem, i think wavemode means a *nonstrictness* joke
13:08:45 * hackage ihaskell-hvega 0.3.0.0 - IHaskell display instance for hvega types.  https://hackage.haskell.org/package/ihaskell-hvega-0.3.0.0 (DouglasBurke)
13:08:48 <wavemode> well, no. laziness.
13:12:10 <Chobbes> wavemode: I guess you can only tell the joke once?
13:15:58 <electricityZZZZ> i have a joke to tell but i am waiting to tell it until after my garbage gets picked up
13:17:20 <MarcelineVQ> new yorker? :>
13:23:58 <dminuoso> merijn: Id tell you a joke about token ring, but I have to wait for my turn.
13:24:22 <merijn> I'd tell you a joke about my thesis, but I'd have to cry... :p
13:24:49 <dminuoso> You meant "I'd tell you a joke about my thesis, but it's just not done yet"
13:24:51 <dminuoso> Right?
13:24:56 <merijn> ow
13:25:00 <dminuoso> :p
13:25:10 <merijn> Below the belt, man...
13:25:39 <merijn> I actually have a meeting with my promotor tomorrow morning, so I'm scrambling to finish the plots I promised to be done writing about... >.>
13:25:54 <merijn> I've given up on the notion of writing about them :p
13:25:54 <dminuoso> Hold on, you're making the plots before writing about them?
13:25:57 <dminuoso> What shabby scientist are you?
13:26:23 <merijn> dminuoso: To be fair, I already wrote about said plots before, I'm producing "more final" ones :p
13:26:46 <dminuoso> heh
13:27:05 <dminuoso> Oh boy this one is good.
13:27:10 <dminuoso> I'd tell you a joke about IPv6, but I don't think you're ready just yet.
13:29:16 <merijn> Joke's on you, I've had native ipv6 for years now :p
13:30:18 <ezzieyguywuf> am I missing something, or does insEdge in Data.Graph.Inductive (from fgl package) allow you to insert an Edge with non-existent nodes?
13:43:14 <t7> holy moly ghcide builds and works in vscode now :D
13:43:15 * hackage di-polysemy 0.1.3.1 - DI logger wrapped for Polysemy  https://hackage.haskell.org/package/di-polysemy-0.1.3.1 (nitros12)
13:59:57 <monochrom> Clearly, you should have your plot before you write your book.
14:04:00 <ezzieyguywuf> so I use Nodes to represent EITHER an Vertex, Edge, or Face, and the Edges to represented the relationships between them. in a planar triangular face, each Vertex would have an Edge connecting to an...Edge. and a Face
14:04:10 <ezzieyguywuf> I think I'll just call the Node "joiners" Bridges instead :-P
14:09:57 <merijn> oof...4x slowdown due to my new indirection :\
14:10:39 <merijn> Sad times :\
14:11:09 <ezzieyguywuf> merijn: try misdirection
14:11:15 <ezzieyguywuf> fake Left, go Just
14:11:45 <ezzieyguywuf> 😂😂😂
14:13:54 <t7> heh
14:14:27 <MarcelineVQ> merijn: What if the real indirection was the extra time being taken, and while that's happening you robbed the bank?
14:19:00 <merijn> hmm, so given a list of N functions, where I wanna apply all N to the same output and get a vector of those results, what'd be the best way? Boxed vector + zipWith? Function monoid + vector monoid instance?
14:22:58 <ChaiTRex> > map ($ 3) [(+1), (+2)]
14:23:00 <lambdabot>  [4,5]
14:23:14 <ChaiTRex> merijn: Like that? Or like something else?
14:23:41 <merijn> ChaiTRex: See, the thing is that I need a Storable vector result and you can't put functions in those
14:24:29 <merijn> I guess the naive way would be to do it like that using list then go to storable Vector in the end
14:24:46 <merijn> But I already have a 4x slowdown and would prefer to not make it worse >.>
14:27:57 <ChaiTRex> Are there any functions that convert between boxed vectors and storable vectors?
14:28:10 <ChaiTRex> Other than through intermediate lists.
14:28:17 <koz_> ChaiTRex: Try using generate?
14:28:25 <koz_> Combined with indexing into the other vector?
14:28:29 <merijn> koz_: It was my question originally :)
14:28:44 <koz_> merijn: Rofl.
14:28:47 <merijn> koz_: And that'll still be painful, I fear
14:28:58 <koz_> Well, it's what I'd reach for when converting from one vector variety to another.
14:29:04 <koz_> (rather than going through intermediate lists)
14:29:15 <koz_> Although my understanding of the fusion done by the vector package is rudimentary at best.
14:30:41 <MarcelineVQ> merijn: silly but I gotta ask, you're using fromListN for your lists yeah?
14:30:54 <merijn> MarcelineVQ: I'm not doing anything yet
14:31:05 <MarcelineVQ> Why's it slow then :>
14:31:16 <MarcelineVQ> Or maybe "Well that's why it's slow!"
14:32:16 <koz_> MarcelineVQ: Infinitely slow, rofl.
14:32:38 <merijn> MarcelineVQ: It's slow already from needing an indirection earlier, now I need to add this stuff and I don't want to make it even worse
14:43:15 * hackage lightstep-haskell 0.9.0 - LightStep OpenTracing client library  https://hackage.haskell.org/package/lightstep-haskell-0.9.0 (DmitryIvanov)
14:43:49 <chloekek_> Hi, is there a name for data Bla f = Bla { runBla :: forall a. f a -> (a, Bla f) }? It looks like Mealy, but the type of the output depends on the given input. (Most useful when f is a GADT.)
14:45:49 <phadej> DMealy :)
14:46:22 <chloekek_> What would the D stand for?
14:46:25 <phadej> dependent
14:46:33 <chloekek_> Ah. :)
14:46:35 <phadej> anyway, that how I'd name it
14:46:45 <phadej> dependent-sum has DSum, and dependent-map has DMap
14:46:48 <phadej> so why not DMealy
14:46:57 <chloekek_> Thanks!
14:47:27 <merijn> ooh...almost negligible slow down, that's good :>
14:47:45 * hackage hslua-aeson 1.0.2 - Allow aeson data types to be used with lua.  https://hackage.haskell.org/package/hslua-aeson-1.0.2 (tarleb)
14:48:09 <phadej> chloekek_: though I'd might experiment if data DMealy f g = DMealy { runDMealy :: forall x. f x -> (g x, DMealy f g) } is better
14:48:44 <phadej> if you want to go from one indexed GADT to another
14:48:52 <phadej> Request tag -> Response tag
14:49:17 <ratzes> Hi, I used to have a simple code example to embed "getCurrentDirectory" with template haskell, but I lost it and I'm having a lot of trouble figuring it out or searching how to do it.
14:49:31 <chloekek_> phadej: I want to return a value of the given type, not index another GADT. But I could use Identity with your example.
14:50:10 <phadej> chloekek_: yes, you can always plug Identity. That what dependent-sum does
14:50:32 <phadej> it has e.g. ==> helper which works for DSum f Identity
14:51:24 <phadej> but making it with f g allows you to be polykinded and all that buzz
14:51:28 <phadej> more general
14:52:02 <phadej> and will allow you to make Category DMealy instance
14:52:06 <phadej> (I think)
14:54:19 <t7> hang on f(x) is called applying f to x? I have had this backwards my whole life...
14:56:09 <Taneb> t7: I think both conventions get used
14:56:31 <Taneb> Because maths loves inconsistent notations ;)
14:56:51 <koz_> What's stopping Data.Dynamic.Dynamic from having an Eq instance?
14:58:09 <phadej> where from it would get Eq dictionary?
14:59:02 <monochrom> No, it has always been "apply f to x" and "pass x to f".  There has never been "apply x to f" nor "pass f to x".
14:59:03 <phadej> and what it would do when you put functions inside
14:59:12 <koz_> phadej: Yeah, that's a valid point.
14:59:37 <koz_> You'd need to somehow say 'Eq a', but there's not really a way to do that unless you force it to cart around a dictionary in the GADT.
14:59:45 <koz_> ... which would make it 'EqDynamic' rofl.
15:00:26 <koz_> Thanks!
15:00:35 <monochrom> If you want to sound like an average programmer and say "call f with x", that's also OK, peasantism isn't a crime, but don't take its control-flow subtext seriously.
15:01:52 <rotaerk> lol
15:15:14 <zeta_0> i finally got ihaskell working in emacs, but i haven't been able to get haskell-mode's auto-completion to work for ihaskell, any tips?
15:15:41 <monochrom> haskell-mode's auto-completion calls ghci.
15:16:06 <monochrom> so I don't know how bad ihaskell is interfering with every basic assumption made by haskell-mode
15:17:10 <monochrom> naturally, ghci doesn't work until you have had a successful "load" (in haskell-mode best to go through its C-c C-l for example)
15:19:43 <zeta_0> ghc-mod is outdated and ihaskell does not yet work with ghcide, so i'm not sure what else to try out
15:20:52 <zeta_0> monochrom: the ihaskell dev told me this is more of an emacs problem, but the people in #emacs don't know much about haskell, that's why i'm asking here
15:20:56 <monochrom> This is why I just stick to haskell-mode. No additives. Best ROI ratio.
15:21:17 <monochrom> But I heard someone here said earlier today they got ghcide to work in vscode.
15:22:20 <monochrom> I don't know whether bringing up "someone here said earlier today they got ghcide to work in vscode" will send you into more wild-goose chase or will actually get you something that works.
15:22:20 <zeta_0> monochrom: could i see your haskell setup from your .emacs config?
15:22:42 <[exa]> using plain vim: leaves enough memory for all the browser tabs with haddock
15:23:29 <monochrom> Which pastebin would you like me to use?
15:23:35 <wavemode> EMACS: Eight-hundred Megabytes And Constantly Swapping
15:24:00 <ja> hey you sneaked that hundred in there
15:24:21 <monochrom> 800MB sounds more like Eclipse
15:24:26 <wavemode> I modernized it :p
15:24:30 <zeta_0> i got ghcide/ghcid working fine in emacs with regular haskell, but ghcide does not work(currently) with ihaskell and emacs-ipython-notebook 
15:24:38 <merijn> monochrom: Only 800MB for a java program? >.>
15:24:39 <zeta_0> monochrom: dpaste
15:24:43 <monochrom> emacs :: CLRS : editors : algo&datastructure textbooks
15:25:36 <ja> this paste bin is pretty minimal http://ix.io/
15:25:51 <zeta_0> i got ihaskell's auto-completion working a long time ago with ghc-mod, but now it's outdated so i'm going to try to stick with haskell-mode
15:26:16 <monochrom> stupid dpaste why doesn't it have any choice of Emacs, Lisp, Scheme?  Are these people chalatans?
15:26:43 <monochrom> like someone in the film industry who hasn't heard of the Bacon number?
15:27:06 <monochrom> But they know TeX
15:27:11 <monochrom> OK so these are physicists.
15:27:40 <merijn> monochrom: Is Fortran-66 on there?
15:27:42 <monochrom> https://dpaste.org/mVXC
15:28:22 <monochrom> Warning: my .emacs clearly has more things than things for haskell.  You will have to pick out the signal from the noise.  I'm too lazy to pick out for you.
15:28:35 <monochrom> I think like it's only 20%
15:29:19 <monochrom> merijn: No, they don't have Fortran, in fact they don't have anything starting with "F".  So these are millenial physicists.
15:31:05 <monochrom> To a large extent I think only two lines are important because they are most recommended by somehow not default.
15:31:10 <monochrom> (add-hook 'haskell-mode-hook 'haskell-indentation-mode)
15:31:11 <monochrom> (add-hook 'haskell-mode-hook 'interactive-haskell-mode)
15:31:22 <monochrom> The rest is just bells and whistles
15:32:47 <monochrom> Well, and lines about turning on emacs's packaging system and adding melpa-stable
15:33:33 <zeta_0> monochrom: thanks i'm scanning through your .emacs now
15:34:26 <zeta_0> that code might interfere with my haskell-lsp setup for ghcide, so i may need to set a hook or something
15:34:33 <ja> 'upgrading' quotes! what has the world come to! oh, the calamity!
15:35:07 <monochrom> :)
15:35:35 <monochrom> ASCII " doesn't look great on web pages.
15:36:06 <monochrom> Don't worry, I don't do it to code.
15:36:12 <monochrom> not even in comments.
15:36:41 <Plazma> monochrom: you a physicists?
15:36:43 <ja> yeah i do like nice typography. but once you waste a day with some weird parser and a weird quote...
15:37:45 <monochrom> The true calamity is back in 1960s when they defined ASCII they failed to acknowledge the concept of a matching pair of open and close quotes. This means parsers have a much harder time.
15:37:55 <monochrom> No, I am not a physicist.
15:39:14 <zeta_0> monochrom: so i don't need to setup up company-mode with haskell-mode for auto-completion?
15:39:57 <monochrom> I don't know whether they talk to each other.
15:40:15 <monochrom> And I don't want to know. #wildgoosechase
15:42:01 <merijn> Man, I really wish GHC tracked time spent in foreign calls too
15:42:03 <monochrom> haskell-mode took me less than two hours to set up. counted accumulatively over my lifetime, but spread out here and there.
15:42:23 <merijn> I've got 22s of profiling info on a 1minute 20s program >.>
15:42:24 <monochrom> For that super low cost, I get like 50%, maybe 70%, of what and IDE does.
15:43:04 <monochrom> Here we have a 50-50 rule. 2 hours for the first 50%. a month for the second 50%. Thanks but no thanks I don't miss the 2nd 50%.
15:43:15 * hackage ghc-source-gen 0.4.0.0 - Constructs Haskell syntax trees for the GHC API.  https://hackage.haskell.org/package/ghc-source-gen-0.4.0.0 (JinwooLee)
15:44:10 <zeta_0> monochrom: thanks, i'll try out your haskell-mode .emacs config
15:44:34 <zeta_0> i mostly just need good auto-completion and indention for ihaskell
15:44:40 <monochrom> this fiasco is beyond sunk cost fallacy. it is now religious pilgrimage zealotry.
15:44:43 <juri_> is it just me, or does distributive not compile on 8.8.3 with cabal 2.4.0.0?
15:45:10 <merijn> juri_: That'd be because nothing compiles with cabal 2.4 and ghc 8.8.3
15:45:18 <merijn> juri_: Because 8.8 requires 3.0 or higher
15:45:20 <topos> m-renaud hey, did you see my response on unordered-containers?
15:45:31 <juri_> merijn: great. ;)
15:46:08 <juri_> debian ships 2.4, and ghc 8.8.3 in unstable.
15:46:33 <merijn> "Linux packagers are idiots, news at 11"
15:46:41 <monochrom> A religious IDE pilgrim is required to do the pilgrimage of getting a full IDE to work. No compromise. Regardless of cost. Regardless that the journey takes 5 years, during which you are kidnapped 3 times, robbed 5 times, hospitalized 8 times, amputated 5 times.
15:47:36 <monochrom> juri_, I think with GHC 8.8 you're better off with cabal-install 3.x
15:47:59 <monochrom> err that's what merijn said :)
15:48:31 <monochrom> But I'm surprised debian gives you ghc 8.8.  I thought they were still at 7.10.
15:49:24 <koz_> monochrom: You mean 6.2 amirite? :P
15:49:34 <monochrom> heh
15:50:11 <monochrom> I thought their linux kernel was still at 2.4
15:53:19 <monochrom> ghc 6.x lacked the hash-after-package-built check we have today. (Also probably only for lower x's.)  So it was amplifying cabal hell.
15:53:56 <merijn> bah
15:54:12 <merijn> According to earlier 7.x docs GHC did track foreign call times back then
15:54:18 <merijn> Or maybe the docs are lying
15:54:50 <monochrom> May I talk you into installing GHC from Debian? >:)
15:54:55 <ezzieyguywuf> if I have `data MyType = MyType Char Int`, is it possible to do something like `type TypeA = MyType 'a'`?
15:54:57 <juri_> monochrom: I run unstable, so these things don't effect me.. but sometimes debian unstable is.. unstaable.
15:55:27 <monochrom> I have a sysadmin friend who told me that debian stable isn't all that stable either.
15:55:42 <monochrom> stable = like unstable but older
15:55:51 <monochrom> s/older/more outdated/
15:55:56 <juri_> I've been administrating it for 20 years. works for me. :P
15:56:45 <monochrom> The sysadmin friend specifically ran into "run-of-the-mill apt-get upgrade, some new package broke things"
15:57:21 <ja> if debian stable isn't stable, i'll be damned? some people have grudges with linux in general because it could be cleaner. i know some freeBSD fans, i get their arguments
15:57:22 <monochrom> I used to respect Debian stable until then.
15:57:56 <ja> on freeBSD, you get this long dump of instructions of things you gotta fix manually, after you have run the upgrade
15:58:03 <monochrom> ezzieyguywuf: That sounds like fixing up types with terms.
15:58:10 <ja> when i forget to run it in screen, i can only see the last of them hahaha
15:58:16 <monochrom> Is 'a' a term? Is 'a' a type?
16:00:02 <monochrom> darn, s/fixing/mixing/
16:00:35 <monochrom> confuse f = let x = f x in x
16:01:15 * hackage data-compat 0.1.0.2 - Define Backwards Compatibility Schemes for Arbitrary Data  https://hackage.haskell.org/package/data-compat-0.1.0.2 (TravisWhitaker)
16:04:45 * hackage deepseq-instances 0.1.0.1 - Candidate NFData Instances for Types in base  https://hackage.haskell.org/package/deepseq-instances-0.1.0.1 (TravisWhitaker)
16:06:57 <m-renaud> topos: I did not, have been pretty busy with work/life lately. Let me take a look, thanks for the ping!
16:14:21 <fog> https://gist.github.com/fog-hs/6590849a6491fc03c1704fe313617c1e
16:18:06 <fog> its cool because the "Output" type (a -> s -> (o,s)) is contained by the scanner, and scanning itself is of Output type
16:18:55 <fog> so scanners can contain processes which run other scanners eg. over lists of inputs, so they can be composed, into a tree 
16:20:29 <fog> ie, given an input updating a state and giving an output, these can be sequenced together to consume a list of inputs, 
16:20:37 <fog> giving a list of outputs and a final state
16:21:28 <fog> so that supplying the list of inputs "acted" on the original Scanner, to update it, and returns the list of outputs and the updated scanner, to hold the final state
16:21:45 * hackage worldturtle 0.1.1.0 - Turtle graphics.  https://hackage.haskell.org/package/worldturtle-0.1.1.0 (FortOyer)
16:22:27 <fog> so, because this is of Output type, it can be held within a Scanner, and it can be used on a list of lists
16:23:16 <fog> basically, being able to compose Outputs into Scanners over lists, nesting the Scanners, can then be extended to Trees
16:24:03 <fog> because a scanner consumes a value just as it does a list
16:28:15 * hackage postgres-websockets 0.6.1.0 - Middleware to map LISTEN/NOTIFY messages to Websockets  https://hackage.haskell.org/package/postgres-websockets-0.6.1.0 (diogob)
16:28:42 <fog> a scanner is nested by wrapping Scanner around the use of the input scanner to scan over a list. 
16:29:14 * hackage lzo 0.1.1.3 - minilzo bundled for Haskell  https://hackage.haskell.org/package/lzo-0.1.1.3 (vmchale)
16:31:45 <topos> m-renaud no worries, just helping treeowl clear a backlog :)
16:32:32 <Shiranai> Hello, trying the 99 questions in haskell and I was wondering why I can't use Maybe in my function http://prntscr.com/sppv9g
16:33:14 <Shiranai> (just learned the basics up to typeclasses, no monad knowledge which I think Maybe is)
16:34:29 <fog> try safeHead
16:36:46 <fog> basically, scanner is the abstraction over the state update mapping process, that based on any (a -.> s)
16:36:53 <fog> sorry;
16:37:01 <fog> (a -> s -> (o,s))
16:37:29 <fog> we have (a -> o) for mapping with and (s -> s) for the carried state update
16:37:39 <fog> so this type consumes and outputs 1 value
16:37:43 <solonarv> Shiranai: it's true that Maybe is a monad, but that doesn't matter here
16:38:04 <ja> Shiranai: your branches, they don't have the same type returned
16:38:04 <solonarv> have you read the error message? do you have an idea of what the problem might be, or at least *where* the problem is?
16:38:20 <fog> but from it we can scanner over a list, and because of this, over any traversable, including the example where the traversable instance for tree is written neatly using the properties of scanner.
16:39:17 <fog> basically, its using mapAccum to give a traversable... 
16:39:46 <fog> by building around that (a -> s -> (o,s)) type
16:40:04 <awpr> :t \f -> traverse (state . f)
16:40:05 <lambdabot> (Traversable t, MonadState s f) => (a -> s -> (b, s)) -> t a -> f (t b)
16:40:20 <fog> :t state
16:40:21 <lambdabot> MonadState s m => (s -> (a, s)) -> m a
16:40:33 <awpr> :t \f -> traverse (Control.Monad.Trans.State.Strict.state . f)
16:40:34 <lambdabot> (Traversable t, Monad m) => (a -> s -> (b, s)) -> t a -> Control.Monad.Trans.State.Strict.StateT s m (t b)
16:40:54 <fog> > state (\a->(1,a))
16:40:56 <lambdabot>  error:
16:40:57 <lambdabot>      • Ambiguous type variable ‘m0’ arising from a use of ‘show_M744940976196...
16:40:57 <lambdabot>        prevents the constraint ‘(Show (m0 Integer))’ from being solved.
16:41:05 <Shiranai> solonarv: I have read them but I was unsure what it was complaining about, I think it was because I should have said "k == 1 = Just head xs"
16:41:30 <solonarv> well, you're missing some parentheses
16:41:33 <fog> anyway, that discards the last state
16:41:37 <solonarv> but basically yes
16:41:42 <fog> you cant sequence them together then
16:42:00 <fog> ie, it doesnt form a state itself
16:42:15 <Shiranai> Thanks! parens solved it :)
16:42:38 <ezzieyguywuf> monochrom: i was confused before I saw the 's/fixing..'. I think I was geting stuff mixed up though
16:42:47 <ja> Shiranai: the error message when you apply Just to two things should be understandable
16:42:56 <ja> isn't it?
16:43:28 <fog> there is some kind of correspondence between traverse and state by virtue of fold / unfold with state and costate
16:43:49 <fog> here the tree traversable instance is given by nesting states instead
16:43:58 <solonarv> % Just head [1,2,3]
16:43:58 <yahb> solonarv: ; <interactive>:7:1: error:; * Couldn't match expected type `[a1] -> t' with actual type `Maybe ([a0] -> a0)'; * The function `Just' is applied to two arguments,; but its type `([a0] -> a0) -> Maybe ([a0] -> a0)' has only one; In the expression: Just head [1, 2, 3]; In an equation for `it': it = Just head [1, 2, 3]; * Relevant bindings include it :: t (bound at <interactive>
16:44:09 <solonarv> yeah, looks reasonable to me
16:44:35 <Shiranai> ja: in retrospect it is, just getting used to this kind of messages takes me some time I guess
16:45:54 <fog> "a state update function run over a sequence of inputs is a state update function taking the whole sequence of inputs" 
16:47:53 <fog> it should be possible to build all traversables this way, so they should all be isomorphic to tree, giving special status for list
16:50:32 <fog> the good thing is then that trees make good states
16:50:51 <fog> for streaming applications, since they can be scannered over, to absorb new input values
16:51:42 <fog> i should write that, hang on
17:03:22 <ezzieyguywuf> If thereas a `f :: a -> Maybe b` and I want to `map f [some a's...]`, how can I take the result and drop all the Nothing and pull the a's out of `Just`?
17:03:33 <ezzieyguywuf> or is this a bad idea?
17:04:56 <MarcelineVQ> in fact it's a common need, there's standard functions for it, are you wanting one or wanting to write one?
17:05:39 <ezzieyguywuf> MarcelineVQ: wanting one, no need to reinvent it
17:05:46 <ezzieyguywuf> I thought it might be standard that's why I asked ^_^
17:08:18 <ezzieyguywuf> catMaybes, maybe?
17:08:33 <MarcelineVQ> yep and more directly  mapMaybe
17:09:10 <ezzieyguywuf> oh sweet
17:09:34 <ezzieyguywuf> do I need to import Data.Maybe for that?
17:10:39 <zeta_0> monochrom:  well, your haskell-mode .emacs config did not work for me, i need auto-completion for ihaskell
17:11:28 <zeta_0> i found this link, but i'm not sure what would be the best method: https://stackoverflow.com/questions/3424697/haskell-autocompletion-in-emacs-using-haskell-mode#3427712
17:16:10 <MarcelineVQ> ezzieyguywuf: ye
17:20:29 <ezzieyguywuf> So, my text editor keeps adding a space whenever it puts an `in` on the next line under `let`, so that it's one space indented. Is this considered a good practice?
17:20:36 <ezzieyguywuf> i prefer to keep `let` and `in` aligned
17:20:55 <solonarv> so do I. I've never even heard of that style!
17:22:02 <ezzieyguywuf> hah nice probably just have a dumb setting turned on then
17:22:20 <ezzieyguywuf> I also prefer 4-space indents to 2...
17:22:37 <MarcelineVQ> my in is on the same line as let, or it's aligned with the l underneath
17:23:08 <ezzieyguywuf> MarcelineVQ: +1
17:23:26 <ezzieyguywuf> (although I don't usually ave it on the same line. altohugh I've only been doing this for a few months..>)
17:23:45 <MarcelineVQ> my = is a wilder character tho, someitmes it's foo = ...   sometimes it's foo\n  = ...  sometimes foo\n    = ...
17:24:16 <MarcelineVQ> and a similarly wild do
17:24:30 <MarcelineVQ> sometimes those two get up to antics together you could write a sitcom about
17:24:53 <solonarv> I find that I almost never have a 'do' on the same line as the first statement of that do block
17:24:59 <ezzieyguywuf> lol
17:24:59 <solonarv> unless the entire do block is on one line
17:25:06 <Shiranai> One of the things that weirds me out the most is trying to calculate the efficiency of my implementation. For example, if I define isPalindrome  xs = (reverse xs) == xs, I have no idea what ghc is doing. Does it compute the whole reverse xs and then compares it? Or does it do it the smart way of getting the last element first and comparing it with
17:25:07 <Shiranai> the first and so on (so to halt as soon as there is a non-match)
17:25:30 <Shiranai> should I just asume ghc is doing the smart thing to do and just hack away or is there some kind of rule of thumb
17:25:40 <solonarv> Shiranai: remember that these are singly-linked lists, so getting the last element requires walking through the entire list anyway
17:26:12 <solonarv> so there is not a very big difference between the two approaches you are suggesting
17:27:58 <Shiranai> Hmmm maybe bad example, but consider some foldl where the output is a bool and the function evaluates the satisfaction of a predicate and ANDs it to the next one
17:28:31 <Shiranai> does it halt as soon as it find a false value? or continues computing if the predicate holds
17:29:19 <solonarv> hm, I think it pays to be precise here
17:29:41 <solonarv> foldl always walks through the entire spine of the input list before it can possibly return a value
17:30:07 <solonarv> however it does not necessarily evaluate the elements of the list, that depends on the function you're folding with
17:31:15 <solonarv> the same thing is true in the 'reverse xs == xs' example: the spine of 'xs' will always be evaluated fully, because that is necessary for 'reverse xs' to return anything at all
17:31:41 <solonarv> but if the first and last elements of 'xs' are different then the other elements indeed won't be evaluated
17:32:14 <Shiranai> e.g. I want a function that tells me if all the elements of a list are even: foldl (\x y -> x && y `mod` 2 ) True xs
17:32:53 <solonarv> (you're missing a '== 0' there)
17:33:15 <Shiranai> yup thanks!
17:33:18 <solonarv> again, no matter what function you pass it, foldl will always walk through the entire input list
17:33:25 <solonarv> foldr in contrast doesn't
17:33:32 <solonarv> that one can truly "exit early"
17:34:04 <Shiranai> so the right implementation for that usecase would be just using foldr?
17:34:10 <solonarv> yes
17:34:19 <Shiranai> aight, thanks!
17:34:49 <solonarv> you also have to pay attention to the argument order for (&&): it is always strict in its first argument
17:35:07 <solonarv> and only evaluates its second argument if the first argument is 'True'
17:35:33 <solonarv> so your example had the wrong argument order for short-circuiting anyway
17:36:02 <wavemode_> it can be verified that the Eq instance for [] is short-circuiting
17:36:04 <Shiranai> what do you mean by 'it is always strict in its first argument'?
17:36:12 <wavemode_> > [1, 2, 3, 4] == reverse [undefined, 0, 2, 1]
17:36:14 <lambdabot>  False
17:36:22 <opticblast> bot && True === bot
17:36:34 <opticblast> False && bot === False
17:37:05 <opticblast> that's one way to define strictness - whether it propagates bottom
17:37:17 <opticblast> (where bottom is the value produced by `undefined` and `error`)
17:38:06 <opticblast> but in practical terms, strictness helps avoid space leaks by preventing thunks from being accumulated endlessly
17:39:17 <Shiranai> Oh thanks
17:48:00 <quiet_laika[m]> is there an obviously "better" way to write this function? https://gitlab.com/snippets/1981444 it just seems rather ugly...
17:51:37 <solonarv> yeah, I'd say so
17:51:55 <solonarv> for context: 'view' is from lens, 'lineCol' and 'pos' are lenses?
17:53:41 <solonarv> I left a comment with an improved version
18:00:45 <ezzieyguywuf> is there a function similar to `drop :: Int -> [a] -> [a]`, but that drops from the back and not the front?
18:01:21 <ezzieyguywuf> would it be 'expensive' to reverse, drop, then reverse again?
18:01:52 <ezzieyguywuf> is it any cheaper to just apply `init` N times, where "N" is the number of items I want to chop off the end?
18:03:07 <monochrom> init N times is the worst one. even a single init is pretty bad.
18:03:13 <ezzieyguywuf> maybe `tails !! n`?
18:03:32 <ezzieyguywuf> monochrom: I got the feeling that was the case based on my rough understanding of how lists work
18:03:39 <monochrom> reverse-drop-reverse is within  reason, but you can easily do better.
18:03:42 <ezzieyguywuf> something about stuff getting glued onto the top or something
18:04:06 <quiet_laika[m]> solonarv: apparently i tried to start using lenses too quickly before learning all the combinators, didn't realize there were state specific ones :) i will work a bit more through optics by example
18:04:24 <monochrom> for the same big-Theta you can easily cut down the constant multiplier by computing length then subtracting, then you have the correct number to give to drop.
18:04:38 <fog> ok, here is the more awesome thing; https://gist.github.com/fog-hs/6590849a6491fc03c1704fe313617c1e
18:06:02 <solonarv> quiet_laika[m]: don't worry, nobody knows all the combinators in lens ;)
18:06:15 <ezzieyguywuf> monochrom: the correct number to give drop is n, isn't it? i.e. in the reverse . drop . reverse case
18:06:31 <solonarv> yes
18:06:37 <fog> to be able to scan over a traversable of values, with a state update which itslef is traversable, and is scanned over in calculating the updated state
18:06:48 <solonarv> you could also write: dropEnd n xs = take (length xs - n) xs
18:07:04 <ezzieyguywuf> solonarv: ah, yes of course.
18:07:06 <monochrom> err, take, what solonarv said.
18:08:34 <fog> basically giving "a nice way to update something given just one input"
18:09:39 <fog> but the key part is using this again inside the state, so that *it* can be updated also by just one input
18:09:48 <fog> normally you would have a state transfer matrix
18:11:43 <fog> if i have s(t) = s(t-1) + f(x) = T(x,s(t-1))
18:11:57 <fog> then T(x, . ) is a time evolution opperator
18:12:15 <fog> incorperating this one value x into an update for the state
18:12:50 <fog> which is done nicely by scanning into it. like a memory buffer that accepts one value and changes by state scanning
18:13:48 <fog> both the taylor transformation, and the implementation of a regular buffer fit into this framework
18:15:15 * hackage servant-jsonrpc 1.0.1 - JSON-RPC messages and endpoints  https://hackage.haskell.org/package/servant-jsonrpc-1.0.1 (IanShipman)
18:16:16 * hackage servant-jsonrpc-server 2.0.0, servant-jsonrpc-client 1.0.1 (IanShipman): https://qbin.io/emma-newton-h76m
18:21:00 <EvanR> Question: has anyone published a formal discussion of "pure data" as opposed to non-pure data. This language comes up in here sometimes, and there is some intuition behind it, but I'm wondering if it comes from somewhere
18:25:04 <MarcelineVQ> the first linguistic hurdle is pure vs impure and pure vs effectful
18:25:13 <MarcelineVQ> EvanR: you should ask in ##dependent because there's a lot of type theory and data brain in there
18:28:12 <ezzieyguywuf> so, if I run `stack test`, everything runs fine. if I try `stack runhaskell -- test/Spec.hs -m "MySpec"`, it complains that "Could not find module MySpec"
18:28:14 <MarcelineVQ> sure doesn't help that purity is ualso used to mean referential transparency or even immutablility :X
18:28:25 <ezzieyguywuf> is there some other way that I should be invoking hspec in order to run a specific spec?
18:29:40 <ezzieyguywuf> nvm, https://stackoverflow.com/questions/39365402/select-which-test-to-run-with-hspec-and-stack
18:30:59 <EvanR> ok that sort of makes me want to not speak of "pure data"
18:31:18 <EvanR> if your imagination runs wild
18:34:13 <EvanR> or pointing out the obvious "people really mean immutable data" means maybe my intuition was wrong all along
18:40:48 <ezzieyguywuf> does anyone know how to do the same thing as the "-m" flag for hspec, but from ghci? i.e. `ghci> hspec spec -- how do I specify -m here? `
18:47:55 <quiet_laika[m]> hopefully not to silly a question, but what is the relationship between lenses and recursion schemes? is the former a specific application of the latter?
18:49:16 <liiae> eval :: (Num a) => Expr a -> a
18:49:24 <liiae> why this type constraint is not ok?
18:49:44 <liiae> eval (Add x y) = x + y
18:50:04 <liiae> ghci tell me Couldn't match expected type ‘a’ with actual type ‘Int’
18:50:19 <liiae> then I use eval :: forall a. Num a => Expr a -> a
18:50:35 <liiae> it tells me Perhaps you intended to use RankNTypes or a similar language
18:51:08 <EvanR> not enough info. Is this a file or what you are trying to type into ghci
18:52:41 <liiae> EvanR: https://paste.ubuntu.com/p/M6rCTnyZCd/
18:52:58 <EvanR> eval (Const x) = x
18:53:09 <EvanR> where Const always takes an Int
18:53:34 <EvanR> so your forall would be a lie
18:54:07 <solonarv> quiet_laika[m]: I'm not aware of any particularly obvious relationship
18:54:37 <EvanR> forall a. Num a => Expr a -> a means the user of eval can pick any type for a
18:54:54 <EvanR> but if they use it on Const 99, and they picked a = Char, it makes no sense
18:55:20 <solonarv> tbf, they can't pick a=Char because there is on 'Num Char' instance
18:55:20 <ezzieyguywuf> nice, "--test=":main -m Topology"" in .ghcid did the drick
18:55:23 <ezzieyguywuf> er, trick
18:55:36 <quiet_laika[m]> maybe i was mislead by the title of bananas lenses etc. but optics by example also has a large section on uniplate, which i thought was a recursions schemes library
18:55:37 <ezzieyguywuf> well, s/Topology/MySpec/
18:56:08 <solonarv> quiet_laika[m]: oh, that's just a random naming collision
18:56:26 <liiae> EvanR: what about eval :: (Num a) -> Expr a -> a
18:56:37 <liiae> (Num a) =>
18:56:41 <EvanR> same thing
18:56:53 <EvanR> forall is understood there
18:57:32 <liiae> I don't understand, this type constraint is not work?
18:57:49 <liiae> should a be a type instance of Num?
18:58:02 <EvanR> the constraint is incompatible with your eval function for Const
18:58:05 <Cale> quiet_laika[m]: The "bananas, lenses, and barbed wire" paper is much much older than the use of the term "lens" to mean a functional reference.
18:58:15 <solonarv> if you write 'eval :: Num a => Expr a -> a', that is the same thing as 'eval :: forall a. Num a => Expr a -> a'
18:58:35 <quiet_laika[m]> thrown off indeed
18:58:40 <solonarv> the caller gets to pick 'a'. This means the function you write must work for any choice of 'a'. so you cannot just assume that 'a' will be 'Int'.
18:58:54 <Cale> The "lenses" in that paper just referred to the typographical notation they were using :P
18:59:11 <EvanR> sorry. The constraint is fine. The "any type a" is incompatible with your Const case
18:59:25 <liiae> EvanR: I should use eval :: Expr Int -> Int?
18:59:35 <EvanR> that would work
18:59:39 <liiae> ok
18:59:39 <solonarv> yes, that would be a sensible change.
18:59:40 <quiet_laika[m]> (| tasty
18:59:50 <solonarv> |)
19:00:04 <solonarv> can't have unclosed things!
19:00:10 <quiet_laika[m]> heh
19:00:18 <quiet_laika[m]> so did i make up reading that uniplate is related to recursion schemes?
19:00:40 <Cale> Well, there's some relationship there
19:00:43 <EvanR> so: you just trapped yourself in a tasty banana
19:00:46 <EvanR> solonarv
19:01:51 <quiet_laika[m]> suppose ill have to keep reading optics by example and find out for myself
19:01:59 <quiet_laika[m]> thanks Cale solonarv :)
19:04:59 <solonarv> EvanR: oh no!
19:05:05 <solonarv> oh wait, I escaped
19:05:19 <EvanR> you must be a skolem
19:05:34 <solonarv> I thought skolems were not allowed to escape?
19:05:35 <EvanR> get back in
19:08:03 <solonarv> no >:(
19:08:04 <parsnip> wait, some people are allowed to escape?
19:09:17 <MarcelineVQ> truth is, the rig was w from the start.  the w was rig from the start. the, uh, this isn't working
19:12:01 <MarcelineVQ> w being little omega and rig being ring without negation, to uh, count binder uses. see it turns out that you didnt escape at all, you were always in the next scope up already
19:12:45 <EvanR> now i feel dumb for not getting it
19:20:34 <parsnip> rig? do you mean rng?
19:23:28 <opticblast> rng is ring without identity, rig is ring without negation
19:23:37 <opticblast> the latter being more commonly called "semiring"
19:44:34 <quiet_laika[m]> does the optics library not provide a way to modify a focus and return both the focus and structure?
19:47:12 <quiet_laika[m]> https://hackage.haskell.org/package/optics-extra-0.3/docs/Optics-Passthrough.html
20:08:00 <quiet_laika[m]> lenses seem like they could really lend themselves to writing a lexer
20:08:45 <quiet_laika[m]> a lot of the logic ive written so far seems like it could be expressed as a fold
21:29:45 * hackage postgres-websockets 0.6.1.1 - Middleware to map LISTEN/NOTIFY messages to Websockets  https://hackage.haskell.org/package/postgres-websockets-0.6.1.1 (diogob)
23:13:00 <opticblast> Why would you write f constr{} = x, where constr is a data constructor taking no arguments?
23:13:32 <opticblast> (As opposed to simply f constr = x.)
23:15:36 <opticblast> At first I thought it was an assertion that constr takes no arguments, but constr on its own does the same thing.
23:15:51 <juliusdeane> if you use the RecordWildCards field, then constr{..} syntax automatically puts the record's fields into the function scope
23:16:25 <opticblast> Hm, but RecordWildCards isn't enabled in this file and the .. isn't present
23:16:35 <opticblast> but that's good to know
23:16:54 <juliusdeane> yeah I'm not sure then
23:17:10 <juliusdeane> maybe it's to specify that the argument is a record, just for future modifiers to know? idk
23:18:23 <opticblast> I think I figured it out - it's generated code
23:18:37 <opticblast> so maybe it's easier to assume that all constructors have brackets
23:43:12 <c_wraith> opticblast: it is the way to write "match on this constructor regardless of how many arguments it has", so the code doesn't need to investigate argument counts.
23:57:39 <merijn> juliusdeane, opticblast: It's so the function declaration doesn't need to change if/when the datatype does
23:58:08 <merijn> The {} notation is legal on any constructor, not just those declared using record notation
23:58:32 <merijn> > [x | x@Just{} <-[Just True, Nothing, Just False, Nothing]]
23:58:34 <lambdabot>  [Just True,Just False]
23:59:51 <opticblast> huh, neat
