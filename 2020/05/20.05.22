00:45:06 <mattew> hi guys       let tokens = analyze input context options dims in      let inputRange = Range 0 $ Text.length input in      let (fullRangeTokens, restTokens) =            partition ((== inputRange) . range) tokens in      case fullRangeTokens of
00:45:15 <mattew> how I can debug in it?
00:45:20 <mattew> like use traceShow?
00:46:13 <mattew> like if I would like to see what is in tokens?
00:49:23 <mattew> let expr = expr in let expr = expr in case expr of expr
00:49:34 <mattew> how I can use traceShow or other in it? :o
01:00:14 <rsoeldner> Morning, why is `weigh` listed as dependency for xeno http://hackage.haskell.org/package/xeno which is only used in benchmarks/test suites and not for the library itself. When building my application with `xeno`, it pulls down all the additional dependencies, resulting in an old version of `time`... 
01:02:05 <gentauro> what if we instead of stroing `raw JSON`, we just parsed into something like this `data Value = S String | N Rational | O [(String,Value)] | A [Value] | B Bool | N deriving (Read,Show)` and stored the `Show`. That way we would only have an extra `char` by element and we can then easily just re-parse it again with `json = read :: String -> JSON.Value`
01:02:30 <gentauro> s/storing/storing/
01:03:21 * gentauro I tend to store my `JSON Numbers` as `Rational` which solves a lot of headaches 
01:03:42 <ahri> I'm sure I'm being really silly, but somehow I can't work this out... I have a function accepting data, some of whose types are parametarised by "str" because this code executes both on the server with `String` (and should probably be `Text` but hey ho) and also in JavaScript with type `JSString`, anyway, my function now needs to check whether a
01:03:43 <ahri> given string is empty (but doesn't know its type), so I figured I'd use `null` to check it, and added a `Foldable str` constraint to my function, but of course Foldable wants a `* -> *` kind giving to it, and I don't want to be specific about `[Char]` etc. - so all I want is some constraint that says "this is a string or a container or something,
01:03:43 <ahri> and I want to be able to check whether it's empty or not" - does this exist? - to be fair I'll probably soon want to provide more functionality like "is the string just whitespace" or whatever, so perhaps I should just create a TypeClass... - have I arrived at the correct conclusion?
01:05:18 <gentauro> ahri: an empty Haskell `String` like in `[]`? (you know that strings are just `[Char]` right?
01:05:42 <gentauro> ups, my bad, you already mention that :)
01:05:48 <ahri> gentauro: yep, but I have to abstract over "any" type of string!
01:06:57 <ahri> perhaps now that things a re a bit straighter in my head I can re-ask the question more succinctly: is there a typeclass for string-like-things that I can ask questions of, such as "are you empty" and "ok you're not empty but is it all just whitespace?"
01:07:18 <gentauro> ahri: I used this for a `parser combinator` lib I wrote -> https://hackage.haskell.org/package/base-4.14.0.0/docs/Data-String.html#t:IsString
01:08:12 <gentauro> that way I could make a distinction between `chars` and `bytes`
01:09:19 <ahri> hmmm, perhaps I can get what I want with `words` in there, I'll give it a try, thanks!
01:09:20 <gentauro> ahri: http://blog.stermon.com/articles/2018/07/03/haskell-url-parser-nanoparsec-only-https.html (CTRL+F `class (Eq a, IsString a) => Parseable a where`)
01:10:06 <gentauro> ahri: se how I define my instances, I think you are asking for the `nil :: a -> Bool` right?
01:12:45 * hackage dialogflow-fulfillment 0.1.1.2 - A Dialogflow Fulfillment library for Haskell.  https://hackage.haskell.org/package/dialogflow-fulfillment-0.1.1.2 (mauriciofierrom)
01:16:33 <ahri> yeah, that's right :) thanks!
01:23:18 <mattew> hi guys       let tokens = analyze input context options dims in      let inputRange = Range 0 $ Text.length input in      let (fullRangeTokens, restTokens) =            partition ((== inputRange) . range) tokens in      case fullRangeTokens ofhow I can debug in it?like use traceShow to see tokens?
01:23:43 <mattew> hi guys      how I can debug let statements?like use traceShow?
01:23:48 <mattew> for example:
01:23:49 <mattew>  let tokens = analyze input context options dims in      let inputRange = Range 0 $ Text.length input in      let (fullRangeTokens, restTokens) =            partition ((== inputRange) . range) tokens in      case fullRangeTokens of
01:56:14 * hackage google-server-api 0.3.2.0 - Google APIs for server to server applications  https://hackage.haskell.org/package/google-server-api-0.3.2.0 (arowM)
02:00:15 <charms> Hi, how can I compile a Ghc monad? I have this bit of code working but want to output a binary.
02:00:17 <charms> main = runGhc (Just libdir) (liftIO $ putStrLn "hello world")
02:01:25 <merijn> eh
02:01:57 <merijn> What does "compile a Ghc monad" mean?
02:02:13 <charms> I want to have some IO expression and compile it to a file essentially.
02:02:23 <merijn> Actually, let's rewind further
02:02:28 <merijn> Where is runGhc even from?
02:02:45 <charms> it is from the GHC API
02:02:47 <charms> https://hackage.haskell.org/package/ghc-8.4.3/docs/GHC.html
02:03:45 <merijn> charms: That's just to interact with the GHC API. To compile something you need to, well, write the code that compiles something
02:04:20 <charms> okay merijn could I write a minimal file like hello world then chain the computation from liftIO or something?
02:05:07 <merijn> charms: What are you trying to do, specifically?
02:07:02 <charms> merijn Suppose I have some program say the lambda calculus. Then I parse it and usually interpret it, possibly printing out the value at the end. I'm wondering if this computation of executing the AST can be compiled
02:07:12 <charms> it is a terrible idea but i think it is interesting
02:08:29 <merijn> That doesn't really specify very well what you actually want
02:09:05 <merijn> And if what you want isn't "I wanna parse and compile Haskell source files using GHC", then the GHC library isn't going to help you much
02:10:15 <charms> yeah it doesn't sorry merijn. I want to have some k :: IO () be compiled to a program. main would generate k then produce a program binary.
02:10:51 <charms> i was thinking is there a way to combine the monad computations or something
02:11:21 <merijn> The simple answer to "how do I compile arbitrary IO values into a program" is "you don't"
02:28:15 <gentauro> I noticed when I add the `default-extensions: Safe` to my `.cabal` file, I can no longer use `ghci`. Why is that?
02:28:18 <gentauro> :(
02:31:35 <gentauro> I'm adding `ghc-options: -fpackage-trust -trust=base` but I still get these kind of errors: `Not in scope: ‘System.IO.hSetBuffering’ No module named ‘System.IO’ is imported.`
02:31:39 <gentauro> kind of strange ...
02:43:45 * hackage fclabels 2.0.5 - First class accessor labels implemented as lenses.  https://hackage.haskell.org/package/fclabels-2.0.5 (ErikHesselink)
03:21:11 <random> hey guys, is it possible to lift a TH function
03:21:21 <random> I want to generate some TH that contains a function passed as a parameter
03:25:45 <merijn> Lift to where?
03:26:06 <merijn> random: You mean generate a TH function using TH?
03:26:45 <random> I found a stackoverflow question that matches what I want to do
03:26:46 <random> https://stackoverflow.com/questions/25618803/functions-as-arguments-to-be-used-in-template-haskell-quote
03:27:06 <random> I guess the accepted answer is right and you can't do this
03:57:45 * hackage aeson-diff 1.1.0.9 - Extract and apply patches to JSON documents.  https://hackage.haskell.org/package/aeson-diff-1.1.0.9 (ThomasSutton)
04:00:31 <Guest_55> Hi. I tried to install ghcup by running the command here https://www.haskell.org/ghcup/. It failed with message ```[ Info ] Cabal installation successfulDownloading the latest package list from hackage.haskell.orgdyld: lazy symbol binding failed: Symbol not found: _utimensatReferenced from: ~/.ghcup/bin/cabal (which was built for Mac OS X
04:00:32 <Guest_55> 10.13)Expected in: /usr/lib/libSystem.B.dylibdyld: Symbol not found: _utimensatReferenced from: ~/.ghcup/bin/cabal (which was built for Mac OS X 10.13)Expected in: /usr/lib/libSystem.B.dylibsh: line 14: 3108 Trace/BPT trap: 5 "$@""cabal new-update" failed!```I am on mac os x 10.11 So i’m not sure why cabal has been built for 10.13? Has anyone
04:00:33 <Guest_55> encountered this error or know what it is?
04:02:35 <maerwald> Guest_55: there is only one cabal binary for all macos versions
04:04:08 <charms> Ahh, you are right merijn. This is incredibly difficult because you shouldn't do it, though that makes it a worthwhile problem.
04:05:32 <Guest_55> Aha thanks maerwald. Are there know compatibility issues between cabal version 3.2.0.0 and OS X El Capitan 10.11? Can I set it to a lower version of cabal?
04:05:45 <maerwald> Guest_55: you can try building cabal from source, sec
04:06:34 <maerwald> Guest_55: source ~/.ghcup/env && ghcup install 8.10.1 && ghcup set 8.10.1 && ghcup compile cabal -v 3.2.0.0 -b 8.10.1
04:06:53 <maerwald> Also, report the issue upstream: https://github.com/haskell/cabal/issues/
04:12:37 <Guest_55> Thanks maerwald. I'll report it upstream there. I tried to run that command and there was an error: `Error during cabal-install bootstrap`
04:12:45 <maerwald> Yes, I get that too
04:12:57 <maerwald> Can you try: ghcup compile cabal -v 3.2.0.0 -b 8.8.3
04:13:14 <Guest_55> sure I'll try that now
04:29:54 <Guest_55> The command `ghcup compile cabal -v 3.2.0.0 -b 8.8.3` also gave an `Error during cabal-install bootstrap` with the detailed reason being `Setup: Haddock's internal GHC version must match the configured GHC version.[ cabal-bootstrap ] The GHC version is 8.8.3 but haddock is using GHC version 8.10.1`
04:34:27 <xerox_> maybe you ned to cabal set 8.8.3? I am not familiar
04:34:45 <xerox_> *ghcup set
04:40:21 <Guest_55> Ok so try `ghcup set 8.8.3 && ghcup compile cabal -v 3.2.0.0 -b 8.8.3`?
04:42:01 <Guest_55> I think this issue did specifically start happening after I tried to install `cabal install record-dot-preprocessor` so maybe it could be an issue specific to building that package?
04:53:16 <maerwald> Guest_55: hmm
04:53:27 <maerwald> xerox_: no need for that when doing compile
04:53:45 * hackage stripeapi 0.1.0.0 - Stripe-Library  https://hackage.haskell.org/package/stripeapi-0.1.0.0 (remo_doerig)
04:53:54 <maerwald> Guest_55: the syscall seems to exist only in 10.13 onwards
04:54:18 <maerwald> which means the 'unix' package was compiled with such a newer version
04:54:40 <maerwald> We have to figure out how to make it build from source. It is a bug that it doesn't build with 8.83
04:57:04 <Guest_55> Aha I see, we need to rebuild the 'unix' package from source to work with 10.11? What is the 'unix' package?
05:00:41 <maerwald> well, cabal uses the unix package, which is why the binary doesn't work
05:01:19 <maerwald> Maybe try: ghcup install 8.6.5 && ghcup compile cabal -v 3.0.0.0 -b 8.6.5
05:01:30 <maerwald> I remember 3.0.0.0 compiles fine from source
05:01:38 <maerwald> we just need a cabal to bootstrap a later cabal
05:17:14 <xerox_> so maybe it'd work to download an older binary distribution of cabal and install that?
05:19:06 <aveltras> is it possible to read file during template haskell compilation with ghcjs ? (doesn't seem so, wondering if there's a workaround for this)
05:26:45 * hackage pandora 0.2.8 - A box of patterns and paradigms  https://hackage.haskell.org/package/pandora-0.2.8 (iokasimovmt)
05:37:45 * hackage google-server-api 0.3.2.1 - Google APIs for server to server applications  https://hackage.haskell.org/package/google-server-api-0.3.2.1 (arowM)
05:41:05 <ibloom> Is there a common version of liftA2 for Maybe where if only one of the parameters is a Just it returns just the Just?
05:41:54 <phadej> > Just 'x' <|> Nothing
05:41:56 <lambdabot>  Just 'x'
05:42:02 <phadej> > Nothing <|> Just 'y'
05:42:04 <lambdabot>  Just 'y'
05:42:14 <phadej> > Just 'x' <|> Just 'y'
05:42:17 <lambdabot>  Just 'x'
05:42:19 <ibloom> That is from the Alternative monad?
05:42:30 <phadej> s/monad/type-class/ yes
05:42:32 <merijn> ibloom: Alternative is it's own class unrelated to Monad
05:44:17 <ibloom> The function I need is myCombine :: (a -> a -> a) -> Maybe a -> Maybe a -> Maybe a
05:44:39 <ibloom> such that myCombine (+) (Just 3) Nothing = Just 3
05:44:54 <ibloom> myCombine (+) (Just 3) (Just 4) = Just 7
05:45:34 <ibloom> I keep rewriting this function and I'm just wondering if it's in the prelude somewhere.
05:46:51 <ski> @type \f ia ib -> f <$> ia <*> ib <|> ia <|> ib
05:46:52 <lambdabot> Alternative f => (a -> a -> a) -> f a -> f a -> f a
05:48:37 * ski . o O ( outer join )
05:48:45 <ibloom> I see. Works in the repl, thank you!
05:51:04 <ski> @type \f ia ib -> foldr1 f <$> sequenceA [ia,ib]
05:51:05 <lambdabot> Applicative f => (b -> b -> b) -> f b -> f b -> f b
05:55:24 <ski> @hoogle Alternative i => (a -> a -> a) -> i a -> i a -> i a
05:55:25 <lambdabot> Linear.Vector liftU2 :: Additive f => (a -> a -> a) -> f a -> f a -> f a
05:55:25 <lambdabot> Numeric.LinearAlgebra.Class liftU2 :: Set f => (a -> a -> a) -> f a -> f a -> f a
05:55:25 <lambdabot> Data.Semigroup.Union unionWith :: HasUnionWith f => (a -> a -> a) -> f a -> f a -> f a
05:56:27 <ski> @hoogle (Foldable t,Applicative i) => (a -> a -> a) -> t (i a) -> i a
05:56:28 <lambdabot> No results found
06:11:00 <arjen-jonathan> Hi, I'm looking for a way to reliably load a file that is distributed with a haskell package.
06:11:09 <arjen-jonathan> I'm using stack.
06:11:48 <merijn> arjen-jonathan: https://cabal.readthedocs.io/en/latest/cabal-package.html?highlight=data-files#accessing-data-files-from-package-code
06:14:22 <arjen-jonathan> Thanks! Can I just add a data-files: section to my package.yaml?
06:15:06 <merijn> That's a question for the hpack documentation, although I'd personally recommend "just not using hpack"
06:17:57 <arjen-jonathan> I'm not very familiar with the haskell eco system. Hpack?
06:18:21 <arjen-jonathan> Ah, is that was stack uses to describe cabal files?
06:18:38 <arjen-jonathan> Right. Thanks!
06:18:50 <merijn> arjen-jonathan: hpack is a tool that generates a cabal file from package.yaml. Stack automatically calls it for you (a mistake, imo)
06:19:37 <merijn> arjen-jonathan: stack itself understand cabal files just fine, so if you have only a cabal file and no package.yaml everything still works the same
06:19:57 <merijn> See also: https://gist.github.com/merijn/8152d561fb8b011f9313c48d876ceb07
06:22:46 <arjen-jonathan> Are there downsides to using hpack as long as it does the job?
06:22:52 <arjen-jonathan> I haven't had any trouble with it.
06:23:41 <zincy__> For a backend server is it best pracctice to put all your typed errors for business logic in one centralised Error.hs file?
06:25:12 <merijn> arjen-jonathan: Downsides are: delay in support for new features (since they need to be manually added to hpack after Cabal gets support for them), underdocumented mapping of how hpack fields map to cabal, harder for people not using hpack to contribute to your repo (unless you also commit the generated cabal file)
06:25:24 <arjen-jonathan> Ok, thanks
06:26:21 <hyperisco> zincy__, how you organise code with directories and files is up to you. I like one file per type, but sometimes I'm feeling otherwise.
06:26:33 <merijn> And Yaml generally being a terrible file format :p
06:27:07 <merijn> arjen-jonathan: by all means keep it for now if it works, but for future/new stuff you might wanna reconsider :)
06:27:34 <zincy__> hyperisco: Thanks, so just do whatever is easiest at the time and be ready to restructure
06:28:05 <zincy__> merijn: Why is yaml terrible?
06:28:31 <merijn> zincy__: It has hundreds of special cases you need to be aware off
06:29:08 <zincy__> merijn: Ah cool
06:29:20 <hyperisco> zincy__, I keep in mind how easy it will be to change later. For new things it tends to be fairly easy because there are few dependants. As things age they solidify.
06:29:35 <merijn> zincy__: Just google for "yaml bug" and find the 100s/1000s of cases of subtle mistakes of what people THINK they wrote vs how the yaml got interpreted
06:29:50 <infinisil> Probably the most popular blog post going into why yaml is pretty bad: https://www.arp242.net/yaml-config.html
06:30:06 <merijn> zincy__: A favourite example of mine is someone writing a YAML file that listed the two letter abbreviations of all Canadian provinces and being confused why "True" was in there
06:30:17 <infinisil> I personally would use TOML or Dhall instead if I ever need a config format
06:30:31 <merijn> zincy__: Turns out Ontario's "ON" gets turned into true, because yaml says on/off are synonyms for true/false
06:30:55 <merijn> zincy__: Of course, even if your yaml is perfect, odds are your implementation isn't: https://matrix.yaml.io/
06:34:12 <merijn> zincy__: Plus, of course, the fact that the common argument for yaml/json/etc. is "so I don't have to learn a new file format". Which is of course a lie, because you still need to learn the schema of how said yaml/json gets parsed to be able to write correct files. Which is really not much simpler than just learning the cabal file format
06:36:20 <zincy__> Wow that sounds hairy
06:36:32 <zincy__> I am glad I have never had to really use YAML
06:36:55 <zincy__> hyperisco: Yeah, maybe experience is the best teacher here
06:37:00 <yushyin> afaik yaml 1.2 removed most of the boolean synonyms for the core yaml schema (good!)
06:38:02 <dolio> Another common example is that version numbers get encoded as other types that don't actually work like version numbers.
06:38:12 <hyperisco> zincy__, sometimes it is driven by the compiler or build tools. Sometimes you need files a certain way to achieve the desired laziness in compilation or resolve dependency cycles.
06:39:02 <hyperisco> iirc Haskell can have mutually dependant modules
06:39:12 <merijn> hyperisco: If you use hs-boot files, yes
06:39:49 <hyperisco> the alternative is to parameterise
07:03:15 * hackage cyclotomic 1.1.0 - A subfield of the complex numbers for exact calculation.  https://hackage.haskell.org/package/cyclotomic-1.1.0 (ScottWalck)
07:27:34 <shapr> any cool tools I could get moving at my company? I got hoogle working, and haskell-language-server is in progress. What other cool stuff should I try?
07:36:38 <untseac> shapr, depends on what you want
07:37:12 <untseac> I suppose you have this? https://github.com/haskell/haskell-ide-engine
07:37:27 <untseac> or haskell language server, same thing
07:38:14 <untseac> but haskell-language-server is still in early stage. It doesn't work very well in my experience.
07:38:49 <untseac> stack or cabal I guess. That should be the essentials.
07:39:13 <maerwald> shapr: cabal-fmt
07:39:51 <maerwald> also check out https://github.com/phadej/cabal-extras
07:40:33 <untseac> is cabal less annoying than stack today?
07:40:45 <untseac> I know stack uses cabal
07:41:00 <merijn> untseac: See: https://gist.github.com/merijn/8152d561fb8b011f9313c48d876ceb07
07:41:34 <untseac> thanks merijn 
07:41:51 <maerwald> untseac: stack has always been more annoying, because it conflates different concerns into one huge too and makes you work for it to separate those
07:42:11 <maerwald> but I guess the developer base is bigger
07:42:59 <merijn> maerwald: Don't think so
07:43:01 <untseac> well can't argue with that maerwald . I just want a tool that works. cabal-install used to be annoying.
07:43:14 <merijn> I think it's about 50/50, with older devs skewed too cabal-install
07:43:17 <untseac> but with time maybe it got better
07:43:32 <merijn> #haskell seems more like 60/40 in favour of cabal-install
07:43:50 <merijn> untseac: How long ago was "used to"? ;)
07:44:11 <maerwald> merijn: hm, who's maintaining cabal when phadej leaves :P
07:44:51 <maerwald> the other devs are too knee-deep in industry jobs to have time for it, it seems
07:45:28 <untseac> merijn, long enough for me not to remember
07:45:42 <untseac> years for sure
07:46:56 <untseac> it used to break itself from time to time. It was a PITA.
07:47:04 <untseac> but stack seems redundant
07:49:14 * hackage pandoc-plot 0.4.0.0 - A Pandoc filter to include figures generated from code blocks using your plotting toolkit of choice.  https://hackage.haskell.org/package/pandoc-plot-0.4.0.0 (LaurentRDC)
07:49:55 <Cale> maerwald: phadej is leaving, or you're just thinking about possible futures?
07:50:37 <maerwald> Cale: just a nightmare story ;)
07:51:11 <phadej> who said I'm leaving
07:51:15 <phadej> what where
07:51:17 <maerwald> No one
07:51:39 <untseac> I also read your take on "concrete type" while at it, merijn 
07:51:42 <untseac> makes sense to me
07:52:23 <phadej> I mean, me+Cabal future is definitely not clear. I might get a mental breakdown, but who wouldn't.
07:52:56 <untseac> maybe you need to hire slaves phadej 
07:53:09 <maerwald> phadej: why does the cabal CI take so long btw? I'm wondering if "cabal install cabal-install-x.y.z.p" might be faster? Or we can speed it up with cabal-cache?
07:53:45 <phadej> the dependency cache would save 5-10 minutes most.
07:53:53 <phadej> the test suite run takes 15-20 minutes
07:54:07 <phadej> it's just slow.
07:55:18 <maerwald> travis doesn't really support pipelines with artifacts etc I guess
07:55:38 <maerwald> to circumvent the timeout
07:56:17 <phadej> oh on travis?
07:56:22 <maerwald> yeah
07:56:49 <phadej> it's worse there. The machine is slooow. Also you have to install GHC (the cache isn't reliable enough)
07:57:17 <phadej> I mean, cold build have still to fit into the timelimit
07:57:29 <maerwald> should be doable with cabal-cache imo
07:57:46 <maerwald> afair building deps with ghcup in travis mac is ~20 minutes
07:58:09 <phadej> and believe me, I have experience with cabal CI. I'd prefer it to be simple, and with pieces cabal developers have control over.
07:58:26 <maerwald> travis has its own caching system too, no?
07:58:31 <untseac> I always thought the general consensus was that concrete type = monomorphic but apparently not
07:59:18 <shapr> untseac: I've had excellent success with haskell-language-server the past week or so
07:59:54 <untseac> shapr, ok thanks for the info. I may try again. It's been a while since I attempted to use haskell-language-server.
08:01:15 <phadej> TL;DR the only good thing about Travis is that it is free.
08:01:22 <untseac> thank god that silly name, haskell-ide-engine, will be dropped. it was yet another source of confusion.
08:02:08 <untseac> when you have to explain the name isn't actually what it looks there's something wrong with the name
08:02:31 <srk> phadej: would you prefer self-hostable CI?
08:02:43 <maerwald> we have that on gitlab haskell
08:02:56 <maerwald> But you don't have access to arbitrary macos versions there :)
08:03:01 <phadej> srk: no. I don't know how to manage macOS
08:03:29 <srk> valid point
08:03:52 <srk> maerwald: that's a bit heavyweight but nice of course :)
08:03:55 <phadej> or fwiw, the haskell's gitlab setup is not the most robust either (I culd grep "run out out of disk space" from #ghc)
08:04:29 <phadej> managing servers is not the haskell developers strongest skills
08:04:38 <phadej> you know, nix assumes infinite storage e.g.
08:06:28 <srk> you can configure automatic garbage collection but then you loose parts of cache, nixos hydra is like 40T because it never gcs
08:06:37 <maerwald> shapr: without a cradle file? :>
08:06:50 <shapr> maerwald: I'm using gen-hie
08:07:11 * maerwald doesn't understand why this has to be another tool
08:07:42 <shapr> https://github.com/Avi-D-coder/implicit-hie
08:07:49 <shapr> maerwald: dunno, but it works great
08:08:05 <shapr> alanz_ and mpickering are putting in lots of work and it's improving quickly
08:10:44 <shapr> The github comments show much exciting potential. A year or two ago alanz_ spent hours helping me configure hie with HaRe support, and that was MAGICAL
08:11:13 <shapr> I'm excited about Retrie as a possible replacement https://github.com/haskell/haskell-language-server/issues/103
08:11:22 <shapr> so much cool stuff happening around hie and hls!
08:11:51 <shapr> I got a hoogle server running for our internal codebase, and configure emacs to hit that server directly.
08:12:13 <maerwald> Will you write a blog post about your journey?
08:12:31 <shapr> ALSO! haskell-language-server respondse with zero human-perceivable lag on a two hundred thousand line Haskell monorepo
08:12:44 <shapr> that's *nice* many props to mpickering and alanz_ !
08:13:34 <shapr> cabal-fmt is a good suggestion, but we're using stack without cabal files, so not something I can use at this point.
08:13:55 <shapr> maerwald: probably not, too busy learning the codebase!
08:14:29 <shapr> untseac: zero lag! two hundred thousand lines of code! try it!
08:14:41 <maerwald> link to the git repo first :PP
08:15:12 <shapr> nope, closed source
08:15:29 <shapr> but the generated hie.yaml has ~550 non-blank lines
08:16:11 <shapr> I know some of our internal libraries have been open sourced, I'm glad simspace is supporting the community that way.
08:17:39 <shapr> for example, we're using squeal internally for some projects, and the squeal author is an employee, so squeal improvements reach the community that way.
08:34:15 * hackage reanimate 0.3.3.0 - Animation library based on SVGs.  https://hackage.haskell.org/package/reanimate-0.3.3.0 (DavidHimmelstrup)
09:09:39 <fragamus_> i need to create a simple executable, not a lib in stack.  what is the template for that
09:10:15 * hackage git-annex 8.20200522 - manage files with git, without checking their contents into git  https://hackage.haskell.org/package/git-annex-8.20200522 (JoeyHess)
09:10:24 <fragamus_> The list of templates has been replaced with something that is not so helpful
09:10:35 <theelous3> why can zero be defined as λs.(λz.z)?
09:10:45 <theelous3> (am reading: http://www.inf.fu-berlin.de/lehre/WS03/alpi/lambda.pdf)
09:11:35 <Cale> theelous3: Are you familiar with algebraic data types in Haskell?
09:11:46 <merijn> theelous3: That's a deep question, tbh. Starting with "what even is zero?"
09:11:59 <Cale> theelous3: I find it easiest to understand Church encodings once you already understand algebraic data types
09:12:20 <Cale> The idea is simply that you wish the data constructors into existence with lambda, and then construct whatever term you wanted to construct with them
09:12:20 <theelous3> Cale: I got about that far or farther last time I dipped my toe, but I'm going through hpffp atm, so I would say no for now
09:12:23 <merijn> Cale: tbh, I think you're already skipping an (intuitive to you) step :)
09:12:43 <Cale> So, first let's understand this description of the natural numbers:
09:12:50 <Cale> data Nat = Zero | Succ Nat
09:12:53 <monochrom> Generally you always take two parameters s,z. Then you represent a natural number by how many times you apply s to z.  If you apply s zero times, so z alone, that's zero.  one is λs.(λz. s z)
09:13:36 <Cale> i.e. every natural number is either Zero or it is the Succ(essor) of another natural number
09:14:10 <theelous3> I understand the idea of finding the natural numbs as sucessors to zero, where zero is defined as above, but I can't see how that defines zero.
09:14:14 <Cale> With the plain untyped lambda calculus, we don't have the luxury of defining such things, but we do have lambda, which can bring new names into scope
09:14:17 <theelous3> I have a hazy recollection of what you mean Cale 
09:14:38 <theelous3> where you're saying Zero is a type Nat that can be Succ'd or something
09:14:47 <Cale> Nat is a type
09:14:52 <Cale> Zero is a value
09:14:59 <Cale> Zero :: Nat
09:15:00 <theelous3> sure
09:15:05 <Cale> Succ :: Nat -> Nat
09:15:21 <Cale> But we don't really have types in the untyped lambda calculus
09:15:30 <theelous3> so in declaring zero, you're not explicitly declaring zero, but rather declaring "the thing from which naurual numbers Succ from"?
09:15:45 <theelous3> if that makes any sense?
09:16:12 <Cale> Well, we're declaring Zero to be a thing of type Nat in that data declaration
09:17:55 <ezzieyguywuf> I have `data MyData = Empty | NonEmpty Int` and `someFunct :: MyData -> MyData` that expects a "NonEmpty". how do I handle the case where the user tries to call `someFunct` with an "Empty"? Do I throw an error? how? I seem no recall reading somewhere that throwing errors in haskell is typically non-idiomatic
09:18:03 <Cale> theelous3: But the idea is, with plain lambda calculus, we don't have the luxury of defining new things like that
09:18:40 <ChaiTRex> ezzieyguywuf: That's up to you.
09:18:41 <Cale> theelous3: All we have is lambda, but what we can do is make lambdas that, if we ever did have the data constructors we wanted, we'd be able to supply them in order to build whatever terms we wanted
09:19:17 <ChaiTRex> ezzieyguywuf: If you want to throw an error, you can do error "whatever"
09:19:23 <Cale> So, while we can't write Succ (Succ Zero) for 2, we can wish Zero and Succ into existence with lambda, and then use them:
09:19:37 <ezzieyguywuf> ChaiTRex: is that the same thing that happens if, say, I try to get an element of a list that is out-of-bounds?
09:19:44 <Cale> λzero. λsucc. succ (succ zero)
09:19:59 <xerox_> ezzieyguywuf: the return value's type gives you just enough space to handle it in a simple way I guess: i.e. for an Empty produce... another Empty?
09:20:10 <Cale> Or the opposite order is a little more popular for natural numbers:
09:20:21 <Cale> λsucc. λzero. succ (succ zero)
09:20:27 <Cale> but... roughly the same thing
09:20:47 <ChaiTRex> ezzieyguywuf: Yes.
09:20:49 <theelous3> am struggling here :P
09:21:02 <Cale> theelous3: We sort of "wish our data constructors into scope" with lambda
09:23:06 <Cale> and then while we never actually have proper data constructors to plug in there, or any notion of pattern matching or anything like that, it turns out we can actually do all the meaningful computations on natural numbers we might want to, because this lambda version of the natural number lets us substitute zero and succ for anything else, and what better interpretation of a natural number than as the number of times 
09:23:06 <Cale> you apply an arbitrary process to an arbitrary thing?
09:24:08 <wavemode> ezzieyguywuf: a common solution is to change the signature of `someFunct :: MyData -> Maybe MyData`, and return Nothing if the input is Empty
09:26:41 <theelous3> Cale: I haven't disappeared, just processing this
09:28:07 <Cale> theelous3: It might help to have a few more examples... let's say we want to encode binary trees like
09:28:37 <Cale> data Bin = Tip | Branch Nat Bin Bin
09:29:13 <Cale> i.e. every binary tree is either the empty tree Tip, or it is a Branch with some Nat label at the root, together with two subtrees
09:29:27 <theelous3> sure
09:29:40 <Cale> Maybe we'd have an example tree like  Branch 0 (Branch 1 Tip Tip) (Branch 2 Tip Tip)
09:29:56 <Cale> We could encode this in the lambda calculus (ignoring the naturals) using:
09:30:26 <Cale> λtip. λbranch. branch 0 (branch 1 tip tip) (branch 2 tip tip)
09:31:07 <Cale> and of course, we can go on to encode the naturals as we would with Church numerals as well
09:31:56 <Cale> The point is just that we can use lambda to wish any building blocks we want into existence, and use those things to build data structures.
09:32:30 <Cale> If we then want to compute something like, say, the sum of the natural numbers in the tree
09:33:05 <Cale> We could supply 0 for tip, and (λn. λl. λr. n + l + r) for the branch
09:33:32 <Cale> and that would of course replace every occurrence of tip with 0
09:33:44 <Cale> and every occurrence of branch with this function for adding up three numbers
09:33:59 <Cale> and that would result in adding all the numbers in the tree
09:34:49 <theelous3> ok, I think I'm vaguely homing in on it with this example
09:35:22 <Cale> With natural numbers, we can do things like replace the zero at the end of one natural number with another natural number, and that will result in adding the two
09:36:29 <Cale> Using the zero,succ convention, that would look like   add n m = zero. succ. n (m zero succ) succ
09:38:22 <theelous3> we're building these kind of "generic" lambdas in such a way that were we - from the "outside" - to say "this represents zero", we can do things to it using lambda calculus rules to do other things, like define succ and apply it over our representation of zero
09:39:41 <theelous3> so like, I could look at \sz.z all day and never actually come up with a way for that to *actually* be zero, but if I just say it is then... it is
09:39:41 <theelous3> ?
09:40:12 <merijn> theelous3: Well, what does it mean to "be zero"?
09:40:14 <Cale> Yeah, I mean, all you really have is lambdas, but you can use those to wish anything you'd like into existence locally, so it's fine.
09:40:46 <theelous3> like, I could come along and say \xyz.x is zero just as easily, only issue being it would be difficult or maybe even impossible to keep that charade up as I try to work with it
09:40:47 <awpr> it's not so much that it "is zero" in isolation; but that in the convention of viewing `\s. \z. <apply s N times to z>` as natural numbers, it corresponds to zero
09:40:59 <Cale> theelous3: Sure.
09:41:01 <theelous3> yes
09:41:02 <theelous3> cool
09:41:03 <theelous3> ok :D
09:41:52 <awpr> you could have other terms that correspond to zero in other conventions, like `\succ. \pred. \four. pred (pred (pred (pred four)))`
09:42:21 <merijn> theelous3: So, if we just look at addition, then we know that "n + 0 = n" and "0 + n = n", so the question is "can we come up with a definition of "zero" and "successor" and corresponding arithmetic operations that obey the same law(s)?"
09:42:45 <merijn> theelous3: You can, in fact, define zero entirely differently in lambda calculus
09:42:56 <awpr> (which would correspond to a weird redundant representation of integers like `data I = Four | Succ I | Pred I`)
09:44:10 <merijn> theelous3: So when people say "\s.\z.z" is zero, what they're really saying is: In the most commonly used representation of Peano arithmetic in the lambda calculus, this is how zero is defined in relation to these other definitions of plus, successor, etc.
09:45:07 <merijn> Personally I find boolean logic a simpler starting point for this sorta thing
09:47:39 <merijn> theelous3: I mean, what's boolean logic, besides two distinct values and a bunch of operations (and/or/not). So "this is True" in lambda calculus is just saying "I've picked two distinct lambda calculus values and here's how I can get the behaviour of boolean logic using them"
09:48:11 <merijn> \x.\y.x as true and \x.\y.y as false are common, but that's pretty much arbitrary
09:48:41 <Cale> (and again, you can write those as λtrue. λfalse. true and λtrue. λfalse. false)
09:49:02 <merijn> (I mean, not really, those were picked because they're the simplest/most convenient values to implement the corresponding operations with, but there's nothing intrinsic that means "\x.\y.x" is true)
09:51:03 <fog> I have a function :: (a,b,c) -> (IO a,IO b,IO c), but I want it to be (a,b,c) -> IO (a,b,c)
09:51:18 <fog> is there anything from lens I can use to commute the monad through the tuple?
09:51:37 <Cale> Just use do-notation and execute the IO actions
09:51:58 <fog> it would be better if it were to work for different lengthed tuples
09:52:31 <fog> im not sure how Traversal, works, I was thinking there might be something to do with that
09:52:33 <theelous3> so to get a better handle on it I just tried manually applying succ (\wyx.y(wx)) to zero (\sz.z), and yeah, works out to \yx.y(z) which is a-equiv to the example 1 given as \sz.s(s(z)), so like, I think I see how that ties in to what you said about zero merijn, when we say zero is when "n + 0 = n" and obeying the same laws
09:52:34 <Cale> Yeah, there's no convenient way to abstract over tuples of different sizes, because their fields can all have different types.
09:52:50 <Cale> and they're all completely unrelated to one another anyway
09:52:56 <fog> I thought lenses could deal with arbitrary reccord accessors?
09:52:58 <dmwit> Working with differently-sized tuples is trickier than you might imagine. I invite you to consider just how bad it would be to only work with specific sizes. I would bet it's not so bad after all.
09:53:27 <Cale> Anyway, you could write something like: sequenceTriple :: (IO a, IO b, IO c) -> IO (a,b,c)
09:53:43 <Cale> sequenceTriple (x,y,z) = do u <- x; v <- y; w <- z; return (u,v,w)
09:54:00 <fog> dmwit: well, I'm trying work towards it working for this; https://gist.github.com/fog-hs/19abbf2ee8cf1f9f0c39abf0772da34e
09:54:08 <fog> (thats my basic tuple)
09:54:39 <merijn> theelous3: In essence it boils down to "all of math and arithmetic is just made up" and we can "make up" completely arbitrary new things and as long as they behave the same relative to our definitions we can call them the same (up to isomorphism ;))
09:54:49 <theelous3> merijn and following that, yes, I see what you mean by the arbitrary but not really arbitrary def of true and false
09:54:55 <theelous3> yes :)
09:55:04 <theelous3> this is awesome
09:55:13 <theelous3> thanks everyone
09:55:43 <merijn> theelous3: It's somewhat unfortuante that most people present the common definitions of arithmetic/booleans in lambda calculus as "the" definitions
09:55:51 <merijn> Rather than "a"
09:56:11 <theelous3> yeah, like you could probably spend a great deal of time coming up with new ones
09:56:25 <theelous3> but these have been thought about and are working well
09:56:38 <dmwit> fog: It is probably possible to implement `sequenceH :: Monad m => HList (HMap m xs) -> m (HList xs)`.
09:56:45 <merijn> theelous3: There's actually several mechanical ways of mapping, for example, ADTs to lambda calculus
09:57:08 <merijn> theelous3: Church-encoding is the most famous one, but there's also Scott-encoding (and I think some others?)
09:57:10 <dmwit> fog: (With a suitable HMap type family that was an analog to the computation-level map.)
09:57:23 <theelous3> I come from a mostly python background. I think I would have understood this much quicker if someone had related this to duck typing, in a sense
09:57:28 <dmwit> (Or even Applicative m.)
09:57:58 <merijn> theelous3: You're familiar with folds (on lists)?
09:58:26 <fog> dmwit: yeah, i was worried about trying to pass a type level mapping and a value level mapping together. i thought it would be easierst just to start with mapping pure over it, and tring to get the traversable like commuting of the applicative through the product type
09:58:27 <dmwit> fog: But I continue to hold the opinion that this is likely to be more work than not using HList in the first place for most day-to-day programming tasks.
09:58:45 <theelous3> oh man, don't start with the folds. I forget which one it was, probably foldr, but it broke my brain for weeks trying to get it. This is why I'm restarting from lambda calc :D
09:59:06 <merijn> theelous3: Ah, but there's surprising elegance to be had there!
09:59:08 <merijn> :t foldr
09:59:09 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
09:59:15 <merijn> ugh!
09:59:16 <dolio> This seems like overstating the variety. Church and Scott are basically the two strategies, and other variants start to make less sense unless you have types to constrain the way things are used.
09:59:24 <merijn> :t Data.OldList.foldr --this one?
09:59:25 <lambdabot> error:
09:59:25 <lambdabot>     Not in scope: ‘Data.OldList.foldr’
09:59:25 <lambdabot>     Perhaps you meant one of these:
09:59:30 <theelous3> :(
09:59:30 <dolio> Also Church and Scott agree on booleans.
09:59:42 <merijn> :t Data.List.foldr --this one?
09:59:42 <fog> dmwit: the problem I have is trying to traverse over graphs that are basically self referential trees, and there are so many type level shape annotations that everything ends up needing to be hetrogenous. 
09:59:43 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
09:59:47 <merijn> :(
09:59:52 <Rembane> This one? -- foldr :: (a -> b -> b) -> b -> [a] -> b
09:59:57 <merijn> oh, it's GHC.OldList
10:00:39 <merijn> theelous3: Anyway, if we look at lists "data List a = Cons a (List a) | Nil" our recursive type has two alternatives, right? A head and tail or an empty list
10:00:42 <fog> Datatype actually ends up being *less* complicated that the graph! 
10:01:11 <theelous3> merijn: sure
10:01:23 <fog> but i cant even figure out how to traverse a HList
10:01:54 <fog> except the value intuition from HMap that everyhting seems to need a corresponding type level version
10:02:13 <merijn> theelous3: You're basically supplying 2 things to foldr "a way to collapse Cons" (the function) and a way to collapse the empty list (the zero element) and those can be used to "crush" the entire list into one value
10:02:24 <merijn> theelous3: Now consider the definition of "succ"
10:02:43 <merijn> theelous3: It takes a function as argument for handling "the successor of something" and a base case for 0
10:02:45 <fog> I thought if I just started with a regular 3 tuple, and tried to see how lens could be used with Traversal, that would be a good place to start
10:02:59 <merijn> theelous3: Notice how these look kinda similar if you squint?
10:03:04 <theelous3> they do yes
10:04:25 <merijn> You can actually do the same trick for any ADT too. Define a function to handle each possible constructor and traverse the structure by picking the right eliminator for every constructor
10:04:41 <fog> but i guess they use some kind of reccord name label to do one location at a time edits and stuff
10:05:00 <fog> I thought I read somthing about biplate and traversing over arbitrary records...
10:05:01 <c_wraith> fog: traversing an HList is a weird idea.  Not impossible, but weird.
10:05:38 <merijn> theelous3: But then, if you can use a single uniform "fold" to apply functions to a data structure, why not skip the data structure entirely, have the data structure represented by the fold that eliminates it
10:05:51 <c_wraith> fog: do you just want to hit targets with a specific type and preserve their type?  That's probably the second-easiest case.
10:05:58 <merijn> (which, effectively, is what the succ/zero thing in lambda calculus is doing)
10:06:03 <fog> c_wraith, totally! any idea what it could actually do? i guess i only have the fact that it should reduce to the normal case for homogenous versions
10:06:40 <fog> yeah, sequence before traversable then at least saves the complication of trying to figure out about the type level mapping
10:07:23 <fog> sequence before traverse*
10:07:41 <fog> :t traverse return
10:07:42 <lambdabot> (Traversable t, Monad f) => t b -> f (t b)
10:08:12 <c_wraith> fog: are you familiar with higher-rank types?
10:08:37 <fog> thats what ski does with continuations encoding exists and stuff right?
10:09:08 <c_wraith> they are used in that, yes
10:09:13 <fog> like, :: (forall a. [a] -> [a]) -> ([String] -> [String])
10:09:15 <theelous3> have the data structure represented by the fold that eliminates it [...] (which, effectively, is what the succ/zero thing in lambda calculus is doing)
10:09:17 <theelous3> merijn: oooooooooooooooooooo
10:09:23 <theelous3> i seeeeeee!
10:09:33 <theelous3> very cool
10:10:01 <merijn> Breakthrough \o/
10:10:04 <fog> then, as this type is formed from another type which is has a forall, then its a higher rank type
10:10:11 <ezzieyguywuf> xerox_: ChaiTRex: wavemode: thank you for the help, I had to step away earlier.
10:10:14 <fog> why do you ask?
10:10:32 <c_wraith> fog: well, Applicative f => (forall x. a -> f a) -> HList xs -> f (HList xs) is a starting point
10:10:42 <c_wraith> err, forall a.
10:11:31 <ezzieyguywuf> is there any strong reason to prefer `someFunc => MyData -> Maybe MyData` versus `someFunct => MyData -> MyData` where the latter may throw an error?
10:11:34 <fog> hmm, i guess that kind of continuations away all the way that it actually uses that `a' to change xs
10:11:35 <ezzieyguywuf> or is it simply a matter of taste?
10:11:43 <fog> oh, it doesnt change the xs, thats the point... hmm
10:11:57 <merijn> theelous3: Graham Hutton also wrote a really nice tutorial showcasing step by step how powerful/general foldr is. https://www.cs.nott.ac.uk/~pszgmh/fold.pdf
10:12:01 <c_wraith> fog: then you could get something uniplate-like out of it by switching it up a little bit: Applicative f => (forall a. Data a => a -> f a) -> HList xs -> HList xs
10:12:24 <dolio> ezzieyguywuf: The former allows your program not to crash.
10:12:30 <fog> yeah, i guess it could be more informative to note that a :: Type, and xs :: [Type]
10:12:40 <fog> otherwise the xs could just be `a'
10:12:59 <c_wraith> fog: Hmm, that'd need one more constraint on it.  It'd need some way to say everything in xs is Data.  Which can be said, but it requires a type family
10:13:07 <fog> well, idk, I guess I would expect HList xs just to be one instance anyway
10:13:14 <fog> seems more like defining map than fmap
10:13:15 * hackage reflex-test-host 0.1.1.0 - reflex host methods for testing without external events  https://hackage.haskell.org/package/reflex-test-host-0.1.1.0 (pdlla)
10:13:21 <ezzieyguywuf> dolio: true, but the tradeoff is that any users of my library now have to worry about `Nothing`, but I guess the alternative is a hard crash so perhaps that is not such a burden
10:13:28 <c_wraith> err.  also -> f (HList xs)
10:14:14 <fog> c_wraith: yeah, normall I define CList, with a constraint on the CCons constructor to have a constraint passed in as a parameter
10:14:15 * hackage pandoc-plot 0.4.0.1 - A Pandoc filter to include figures generated from code blocks using your plotting toolkit of choice.  https://hackage.haskell.org/package/pandoc-plot-0.4.0.1 (LaurentRDC)
10:14:18 <c_wraith> fog: in any case, traversing an HList is limited by the fact that you might end up processing elements of different types
10:14:25 <dolio> It is not a burden to return a result that can properly be handled instead of crashing the program, no.
10:15:10 <c_wraith> fog: there are basically 3 ways to handle it.  Be completely polymorphic in the type of value processed.  This doesn't really let you do much other than sequence
10:15:29 <fog> right, for that I was using a defunctionalised type family in a Proxy as another argument
10:15:51 <c_wraith> fog: you can have some sort of constrained polymorphism going on, like with the Data constraint.  This gives you the ability to do a lot, but the code can be awkward
10:15:59 <fog> like how map needs (a -> b), hmap nees also (Proxy :: Proxy a ~> b)
10:16:19 <fog> well, one for each thing in the list
10:16:22 <c_wraith> fog: finally, you can have some sort of traversal that only touches elements of the expected type.
10:16:33 <fog> which you can do with a constraint...
10:16:48 <c_wraith> But you can do that in a type-changing way.  The others can't
10:17:37 <fog> yeah, i guess we are used to everything being the same type, so we only need to pass one argument to fmap for example
10:17:37 <c_wraith> like...  Applicative f => (a -> f b) -> HList xs -> f (HList (SomeSortOfMapTypeFamily a b xs))
10:18:13 <fog> doesnt it end up being more like zipWith?
10:18:33 <fog> the only way round that was to have the mapping function be provided by a class
10:19:02 <fog> then at least there is some extension on the notion of hetrogenaity, but instead of them all being the same type, they just have to be members of the class
10:19:04 <c_wraith> Ah, yes, it does need a class to handle type matching
10:19:24 <fog> then you have the type mapping function as an associated type, and can defunctionalise it
10:19:58 <fog> all the instances then have access to the mapping function at both type and value level 
10:20:44 <fog> you have to reify the arguments into it, defining all the instances locally, which seems like a pain, and its equivalent then to just doing the zipWith version anyway
10:21:17 <c_wraith> In the end, though...  HList is rather limited in Haskell.  It's not a particularly useful heterogenous list, because the type contains a record of all the element types.  This limits it severely.
10:21:25 <fog> well except the reify way is order independent and can have reuse on the same type appearing at multiple locations
10:22:07 <fog> c_wraith: how is that a limitation? seems hust lika an extensible record... 
10:22:21 <fog> did you see this? https://gist.github.com/fog-hs/19abbf2ee8cf1f9f0c39abf0772da34e
10:22:25 <fog> should be extensible...
10:22:32 <c_wraith> fog: that is the limitation.  It's usable as an extensible record, but not as a real heterogenous list.
10:22:45 <fog> oh..
10:23:03 <fog> how would a "real" hetrogenous list be different?
10:23:37 <c_wraith> It's awfully hard to write code that throws 10k elements of various types into an HList based on some external input, and then processes it in any especially meaningful way.
10:24:18 <fog> right, i had a use case like that, it was a graph of subgraphs, each with different type level shape annotations 
10:24:26 <monochrom> (and have the compiler not blow up)
10:24:44 <fog> it was for shuffling them around to see which were isomorphic for diagramatic counting
10:24:52 <monochrom> (maybe it won't blow up if you have 1PB RAM)
10:25:35 <fog> well, i just wanted to be able to compose together tensor subnets and make sure they were the right shape to connect together properly at type level
10:26:12 <fog> and swap regions of connected branching tensors for one approximate tensor with the same input output edges
10:26:29 <fog> so i could eliminate local "tadpole" diagrams 
10:26:45 <fog> i think thats what they are called... or wilson loops or something
10:27:39 <fog> anyway, never mind that, way too complicated at this point
10:28:56 <fog> the isomorphism thing is cool though, its like, if you have a cyclic tree/graph, and you have navigated over it with a vertical and horizontal zipper, to some location, then you kind of pinch this node and dangle the rest of the diagram from it, so it becomes the top node of the tree
10:30:08 <fog> and the local stencil operations can navigate over "bridges" on the cyclic references, which requires typing the knot 
10:30:39 <fog> tying*
10:31:08 <fog> i didnt realise before that everything would need to be hetrogenous 
10:31:26 <fog> maybe its a fairly weak form of hetroginaity, since its just kind of phantom decorations
10:32:43 <fog> data HFree' (container :: * -> *) (k :: z) where
10:33:10 <fog> that k is actually a tree of all the nested type level lists of annotations corresponding to each layer
10:33:25 <fog> its on like 130 of the paste
10:33:29 <fog> https://gist.github.com/fog-hs/19abbf2ee8cf1f9f0c39abf0772da34e
10:33:45 * hackage plzwrk 0.0.0.10 - A front-end framework  https://hackage.haskell.org/package/plzwrk-0.0.0.10 (mikesol)
10:35:10 <fog> sorry, got distracted, i think ill have to try this another time
10:55:14 * hackage squares 0 - The double category of Hask functors and profunctors  https://hackage.haskell.org/package/squares-0 (SjoerdVisscher)
10:58:01 <monochrom> theelous3: It may delight you that section 4 "recursion" will discuss the "\f. (\x. f (x x)) (\x. f (x x))" term you saw yesterday.
10:58:48 <theelous3> monochrom: aye I skipped ahead a bit and saw :)
10:59:18 <theelous3> still have my mind blown by this figuring out why zero is defined as it is part
10:59:35 <monochrom> Personally I am not fond of all these techniques or tricks.  Section 1 is all you need as preparation for Haskell.
11:00:10 <monochrom> I mean, in the context of Haskell or FP beginner.
11:17:53 <theelous3> monochrom: aye, I think I'm def side tracking myself a bit
11:18:41 <theelous3> though I get the feeling that insight about the similarities between fold and succ might be useful down the line
11:20:22 <awpr> theelous3: the connection there is pretty deep, in that the church encoding of naturals means representing them as their equivalent of the `foldr` function
11:20:33 <awpr> just comparing side-by-side:
11:20:44 <awpr> `data Nat = Z | S Nat`
11:20:55 <awpr> `data List a = Nil | Cons a (List a)`
11:22:38 <awpr> `foldr` takes a list `Cons x0 (Cons x1 (Cons x2 Nil))` to `\nil. \cons. cons x0 (cons x1 (cons x2 nil))` in the same way that a foldr-like thing on naturals would take `S (S (S Z))` to `\s. \z. s (s (s z))`
11:23:24 <awpr> so in that sense, `succ` corresponds to `cons`
11:26:11 <theelous3> vague memories of [1,2,3,4] being sugar for 1:2:3:4:[] which I `feel` relates to how List is defined there
11:26:16 <theelous3> as an aside
11:26:33 <monochrom> Yes.
11:27:05 <awpr> yeah, the "real" list type in Haskell has magical constructor names `:` and `Nil`, but if you want to type in your own definition, you have to use normal names like `Nil` and `Cons`
11:27:06 <monochrom> Consider how 5 is like [(), (), (), (), ()] = () : () : () : () : () : []
11:27:24 <awpr> er, I can't type.  magical names like `:` and `[]`
11:27:29 <theelous3> aye
11:28:43 <theelous3> monochrom: I see what you mean by the 5 there as it relates to () : () [...] : []
11:28:53 <theelous3> but I'm not sure what the left side has to do with it
11:29:13 <theelous3> ah nvm I see what you mean
11:30:09 <theelous3> where [(), (), [...]] is the output of () : () [...] : [], 5 is the output of what we discussed earlier, like succ over zero
11:30:13 <pong> Nat isomorphic to [()]
11:30:15 <pong> nice
11:30:22 <awpr> since `()` "contains no information", all there is to a list of `()`s is its length
11:31:06 <theelous3> ah
11:31:12 <int-e> and whether it ends in [] or in bottom
11:32:58 <int-e> Meh, actually it's messier than that if you consider bottoms at all... because the type () has two values in that case, or a value and a non-value (i.e., bottom)
11:34:32 <awpr> yeah, all the nice theoretical stuff falls apart when you consider bottoms, but IMO it's still reasonable to talk about the set of non-bottom inhabitants of a type
11:34:48 <monochrom> We sidestep the bottom issue by saying "I'm just giving lambda terms that represent natural numbers and finite lists, I'm not talking about weirdo terms".
11:34:57 <theelous3> all the nice theoretical stuff falls apart when you consider bottoms
11:35:00 <theelous3> too distracting
11:41:02 <charms> merijn, hi it turns out that it is impossible to compile arbitrary IO values to programs in GHC.
11:41:23 <charms> i looked into the design of GHC and the API for a while and it makes sense now, you can't
11:41:51 <charms> i'm going to try and see if there are other programming languages to support this but otherwise i may try to roll my own
11:42:19 <charms> so yes you were right
11:52:20 <dmwit> uh?
11:52:31 <dmwit> Isn't GHC a program that compiles arbitrary IO values to programs?
11:53:04 <Uniaika> no you're thinking of Perl
11:53:12 <Uniaika> GHC actually rejects some of the those values
11:55:25 <monochrom> GHC compiles source code to programs, not necessarily IO values constructed in situ to programs.
11:57:03 <dmwit> ok
11:57:53 <monochrom> its compiler pipeline has various entry points for hs file, hs tree, core tree, stg tree, cmm.  Just not IO a.
11:59:49 <monochrom> Most lisps come very close, though.
12:00:15 <monochrom> they have a "dump heap to exe" command.
12:00:33 <monochrom> or better wording "save heap as exe".
12:01:03 <monochrom> In fact that's their only "compile" command.
12:02:19 <monochrom> Did anyone complain about their exe size? Or is it just that IRC didn't exist back then so complaints could not happen in public? :)
12:02:54 <monochrom> Or was it like "my exe is still just one tenth of emacs so I call it small"? :)
12:04:31 <yushyin> Uniaika: not only arbitrary IO values but also paint splatters can be valid perl programs! https://www.famicol.in/sigbovik/
12:05:26 <monochrom> haha
12:06:15 * hackage Shpadoinkle-backend-static 0.1.0.1 - A backend for rendering Shpadoinkle as Text.  https://hackage.haskell.org/package/Shpadoinkle-backend-static-0.1.0.1 (fresheyeball)
12:16:37 <Uniaika> yushyin: nice! :D
12:17:16 <theelous3> "merely 93%"
12:31:15 * hackage Shpadoinkle-backend-snabbdom 0.1.0.1 - Use the high-performance Snabbdom virtual dom library written in JavaScript.  https://hackage.haskell.org/package/Shpadoinkle-backend-snabbdom-0.1.0.1 (fresheyeball)
12:36:45 * hackage opentelemetry 0.4.1 -   https://hackage.haskell.org/package/opentelemetry-0.4.1 (DmitryIvanov)
12:37:45 * hackage opentelemetry-wai 0.4.1, opentelemetry-lightstep 0.4.1, opentelemetry-extra 0.4.1 (DmitryIvanov)
12:45:31 <mniip> nil, sorry
12:45:58 <nil> sup
12:46:06 <mniip> the duality is that with recursion, you have, forall R, (F R -> R) -> I -> R
12:46:11 <mniip> where I is the initial algebra
12:46:27 <mniip> and with corecursion you have, forall R, (R -> F R) -> R -> T
12:46:32 <mniip> where T is the terminal coalgebra
12:47:19 <mniip> I'm not actually sure how to make this setup "fibered", i.e. "induction"-like
12:47:59 <mniip> but the gist is that the dual of "recursive pattern matching/fold" is "corecursive construction/unfold"
12:48:12 <mniip> and the dual of "constructor" is "non-recursive pattern match/case analysis"
12:48:47 <dolio> I ≅ (forall R. (F R -> R) -> R) ; T ≅ (exists S. S × (S -> F S))
12:49:45 <mniip> in a category with sufficiently many constructions, sure
12:50:02 <nil> hmm
12:50:33 <mniip> dolio, actually not quite
12:50:49 <nil> i would expect I to be rank 2 for some reason
12:51:13 <nil> even though i have no idea what i'm looking at and should read about (co)algebras first
12:51:14 <mniip> not sure about T, but for I you want uniqueness
12:51:22 <mniip> which is maybe guaranteed by parametricity of the forall
12:57:26 <dolio> Stating it as isomorphisms gives the right uniqueness properties, I believe.
12:58:27 <dolio> If you can make sense of it at all.
13:00:17 <mniip> you want exists i : FI -> I, forall f : FR -> R, exists unique h : I -> R, such that f . Fh = h . i
13:01:01 <monochrom> you may like Wadler's "recursive types for free" http://homepages.inf.ed.ac.uk/wadler/topics/parametricity.html#free
13:02:15 <mniip> the latter is a commutative square of an algebra homomorphism
13:08:33 <dolio> Yeah, but for an adjunction you don't want an isomorphism of hom sets, you want an arrow with a unique existence property that's harder to write down. :)
13:12:48 <dolio> Another possibility that's easier to internalize might be: `forall R. (I -> R) ≅ ((F R -> R) -> R)`
13:19:47 <lally> Hi, I'm trying to take a function as a param, but it's got a type param that's a bit hairy: SqliteM a -> IO a.  I've tried a type Exec = forall a. SqliteM a -> IO a, and then putting Exec in as the type of the parameter function.  But then I get that 'a' is a rigid variable and that it can't match with type 'a0'.
13:19:59 <lally> There's got to be a technique to this I'm not getiing.
13:21:19 <berndl> lally: Why not Exec a = SqliteM a -> IO a?
13:22:38 <lally> berndl: I tried that first, but when I call that more than once inside the function, it complains that the 'a's differ between invocations.
13:22:50 <lally> Specifically, it complains in the first call (by LOC) that a is ()
13:25:54 <berndl> lally: what if you pass the parameter as (forall x. Exec x)?
13:27:06 <lally> Worth a shot.  I'll check
13:27:10 <lally> Thanks
13:31:55 <lally> That does it!
13:32:39 <lally> Is there a neater way to do it?  
13:57:30 <wavemode> lally: can you post a code example?
13:58:15 * hackage github-release 1.3.1 - Upload files to GitHub releases.  https://hackage.haskell.org/package/github-release-1.3.1 (fozworth)
13:58:47 <lally> https://www.irccloud.com/pastebin/ORjhjQCw/
13:59:48 <lally> The first param will be either sqlExec or verbExec (with a bound conn param) depending on the cli verbosity flag
14:06:19 <ski> lally : hm, so `saveMetrics' is a rank-2 operation
14:08:49 <ski> lally : hm, i wonder why the original `type Exec = forall a. ..a..' didn't work
14:15:22 <lally> ski: I think because I called it more than once in saveMetrics with different types of a
14:16:05 <ski> that ought to be okay, i think
14:16:22 <ski> that's the main thing rank-2 is for, anyway
14:16:38 <ski> (and i just tried it, with a simple example, which seemed to work)
14:17:09 <lally> Ok, I might have misinterpreted the error then, thanks.  That will clean it up quite a bit
14:18:08 <ski> maybe ? i dunno (not having seen or tried the code)
14:18:48 <ski> i would expect it to work, at least after my trial also with a type synonym
14:21:15 * hackage zstd 0.1.2.0 - Haskell bindings to the Zstandard compression algorithm  https://hackage.haskell.org/package/zstd-0.1.2.0 (luispedro)
14:24:28 <ski> nil,mniip : i guess i'd call the dual of "constructor", "destructor", which often will end up being a field projection/selection function
14:25:05 <mniip> if F is a sum of functors that analogy doesn't work
14:32:15 <ski> yea, that's why i said "often"
14:32:31 <juri_> > even 0
14:32:33 <lambdabot>  True
14:32:41 <ski> but, by the same token, if it's a product, does the "constructor" analogy really work ?
14:33:03 <ski> (i guess it depends on what you intend by the word)
14:34:56 <Cale> .oO(copatterns)
14:35:29 <Cale> https://agda.readthedocs.io/en/v2.6.1/language/copatterns.html
14:35:31 <ski> yes, message-dispatching
14:35:38 <ski> @where ErikPoll
14:35:38 <lambdabot> "Subtyping and Inheritance for Inductive Types" in 1997 at <http://www.cs.ru.nl/E.Poll/papers/durham97.pdf>,"Subtyping and Inheritance for Categorical Datatypes" in 1997 at <http://www.cs.ru.nl/E.
14:35:38 <lambdabot> Poll/papers/kyoto97.pdf>,"A Coalgebraic Semantics of Subtyping" in 2000 at <http://www.cs.ru.nl/E.Poll/papers/cmcs00.pdf>,later version of that in 2001 at <http://www.cs.ru.nl/E.Poll/papers/ita01.
14:35:38 <lambdabot> pdf>
14:35:47 <ski> (first two papers, iirc)
14:37:51 <dolio> observer might be more neutral.
14:38:02 <berndl> Cale: copatterns are somwhat verbose though.
14:38:40 <ski> for which purpose ?
14:39:20 <ski> @hoogle destroy
14:39:20 <lambdabot> Streaming destroy :: (Functor f, Monad m) => Stream f m r -> (f b -> b) -> (m b -> b) -> (r -> b) -> b
14:39:20 <lambdabot> Streaming.Internal destroy :: (Functor f, Monad m) => Stream f m r -> (f b -> b) -> (m b -> b) -> (r -> b) -> b
14:39:20 <lambdabot> Foreign.CUDA.Driver destroy :: Context -> IO ()
14:42:53 <dolio> I don't think they're necessarily any more verbose than the other record syntax in Agda.
14:45:49 <berndl> dolio: there are three ways of specifying a record in Agda: copatterns (verbose), record {} (less verbose) and pattern lambdas (least verbose).
14:48:05 <berndl> Actually, there's a fourth way if your record has a constructor. That is actually the least verbose way.
14:51:58 <fpaulw> if (<>) and mappend are aliases, why do I get a different thing when I do (Right 1) <> (Right 2) and (Right 1) `mappend` (Right 2)?
14:52:30 <fpaulw> the former evaluates but the latter does not
14:53:34 <koz_> :t mappend
14:53:35 <lambdabot> Monoid a => a -> a -> a
14:53:57 <koz_> (Right 1) `mappend` (Right 2)
14:54:02 <koz_> > (Right 1) `mappend` (Right 2)
14:54:04 <lambdabot>  error:
14:54:04 <lambdabot>      • No instance for (Monoid (Either () Integer))
14:54:04 <lambdabot>          arising from a use of ‘e_112’
14:54:18 <koz_> > (Right 1) <> (Right 2)
14:54:20 <lambdabot>  Right 1
14:54:20 <berndl> It's not a monoid.
14:54:27 <koz_> Yeah, mappend is a Monoid method.
14:54:30 <fpaulw> But is a semigroup?
14:54:36 <fpaulw> > (Right 1) <> (Right 2)
14:54:39 <lambdabot>  Right 1
14:54:42 <koz_> fpaulw: Yeah, but (<>) is a Semigroup method.
14:54:50 <fpaulw> ah got it
14:54:51 <koz_> `mappend` is specifically a Monoid one (for hysterical raisins).
14:54:59 <koz_> So if you're not a Monoid, you don't get a mappend.
14:55:09 <koz_> (even if you happen to be a Semigroup)
14:55:19 <fpaulw> thanks, koz_
14:55:28 <koz_> fpaulw: No worries - confusion here is understandable.
14:56:14 <fpaulw> Yeah because IIRC mappend is defined as mappend = (<>) in the typeclass, so it confused me. But this makes perfect sense
14:56:33 <fpaulw> the Monoid typeclass that is
14:56:40 <koz_> fpaulw: Yeah, because Semigroup wasn't always a superclass of Monoid.
14:56:48 <koz_> Before, we _only_ had mappend.
14:58:04 <solonarv> actually, for a while Data.Monoid also exported (<>)
14:58:10 <solonarv> (which was just an alias for mappend_
14:58:27 <solonarv> this is actually one of the more recent breaking changes in base, I think it was in 4.12 (ghc 8.6)
15:01:01 <dolio> berndl: Pattern lambdas are copattern matching.
15:02:43 <berndl> dolio: In a way, yes.
15:04:30 <berndl> But it's less verbose. Compare writing fst myPair = 1; snd myPair = 2 vs myPair = \ { .fst -> 1; .snd -> 2}
15:05:43 <dolio> No, I mean that it is not 'pattern matching' it is copattern matching in a lambda term. It _is_ the same thing.
15:08:45 <dolio> It's just another syntax for the idea of copattern matching. Like how you can write pattern matching as a case statement instead of multiple equational clauses.
15:10:08 <berndl> dolio: yes. I was refering specifically to the syntax.
15:11:40 <berndl> write pattern matching as a case statement <-- Agda doesn't even have a builtin case statement. You just use pattern lambdas or with abstraction.
15:12:34 <dolio> This is completely dualized in e.g. Compiling with Classical Connectives, where function literals are just a special case of copattern matching on negative types, given by λ, while continuation literals are pattern matching on positive types, given by case (written as a backwards λ there).
15:17:45 * hackage opentelemetry 0.4.2 -   https://hackage.haskell.org/package/opentelemetry-0.4.2 (DmitryIvanov)
15:18:46 * hackage opentelemetry-wai 0.4.2, opentelemetry-lightstep 0.4.2, opentelemetry-extra 0.4.2 (DmitryIvanov)
15:19:24 <dolio> Right, but this is #haskell, which does acknowledge the possibility of writing case statements.
15:21:06 <berndl> Yep. In haskell, pattern matching is just syntax sugar on top of case statements.
15:45:38 <sushi1234> does someone have Programming in Haskell in PDF?
15:48:30 <yushyin> the author has, probably
16:02:59 <quiet_laika[m]> im trying to design a handwritten lexer for my programming language that i want to be reasonably efficient. if i gather input from the user as a `Text`, can I `uncons` through the source text for token analysis while still having a reference to the full text for error reporting? will that be inefficient?
16:04:52 <solonarv> is there a reason you aren't using a parser combinator library?
16:05:10 <Guest_26> So... I hit https://www.haskell.org/platform/#linux-generic and it says to use ghcup. Okay. Follow that link... and it says to get ghcup use haskell-platform and sends me back to that site.
16:05:25 <Guest_26> Circular install instructions :(
16:06:20 <solonarv> eh? that link takes you to https://www.haskell.org/ghcup/ , yes?
16:06:46 <solonarv> which has a curl | sh installer
16:07:02 <Guest_26> Right... and that page says "
16:07:17 <Guest_26> To Install Haskell, follow the instructions..."  There's nothing on there about how to install ghcup.
16:07:51 <Guest_26> oh, is this because the web page is trying to be smart and "detecting" my os?
16:09:07 <solonarv> you don't see a text field containing curl --proto '=https' --tlsv1.2 -sSf https://get-ghcup.haskell.org | sh
16:09:10 <solonarv> ?
16:10:01 <Guest_26> no, I saw "To install Haskell follow the instructions on Haskell Platform" then in much smaller text "You appear to be running Windows 64-bit. If not, display all supported installers."
16:10:24 <Guest_26> If I expand that out I get what I want.
16:11:27 <Guest_26> okay, that hidden curl seems to be doing the trick. Thanks!
16:11:36 <solonarv> aha, I see
16:12:13 <solonarv> it didn't occur to me that you would want to download the linux installer on a windows system ;)
16:12:13 <Guest_26> What might be useful is if the generic linux instructions could pass a query param to the ghc page that perhaps caused the target to expand to the linux one.
16:12:40 <Guest_26> Well I'm installing it on wsl.
16:13:03 <solonarv> yeah, after you said you were using windows I guessed as much
16:14:58 <quiet_laika[m]> solonarv: i initially tried to do all my lexing and parsing in megaparsec, but doing the type of indentation sensitivity i want to support got hairy really quickly
16:17:53 <solonarv> ah, I see
16:19:43 <solonarv> so to answer your original question, slicing Text is fast and cheap
16:20:13 <quiet_laika[m]> im basically trying to decide whether i will be better off trying to report errors by way of indices into the original source text, or by essentially splitting the source text so each token has the literal text it represents contained in it
16:20:15 <solonarv> internally a Text is an offset, length, and a pointer to the actual buffer where the data is
16:20:49 <quiet_laika[m]> at least, conceptually
16:21:16 <quiet_laika[m]> so generally, if i parse some large text and then split it into a bunch of substrings, those will all just reference back to the original array?
16:21:27 <solonarv> yup
16:23:43 <quiet_laika[m]> how does Text decide what to return as the leading Char for `uncons`? is it a unicode scalar? presumably not a word16?
16:24:38 <solonarv> a Char is one (1) unicode codepoint, so that's what you get
16:25:58 <aviD> Any one open to doing a 15-30 minute demonstration and q&a of using nix with Haskell?
16:25:58 <aviD> The weekly Haskell video chat  hosted on the FP zulip is looking for someone?
16:25:58 <aviD> We get 11-14 people per week, at 5PM UTC.
16:31:31 <remexre> there's no way to do ViewPatterns for a function that needs to run in the monad the function returns its results in, is there?
16:32:55 <solonarv> don't think so
16:33:59 <remexre> rip, guess I'm doing my arg matching in a case expression
16:34:08 <solonarv> I guess you could do something like: myFunc = viewFunc >=> \case pat -> ...
16:34:34 <solonarv> (if there's only one argument you want to do this with)
16:37:25 <remexre> hrm, might do that, yeah
16:38:06 <solonarv> I also fund 'foo x y z >>= \case ...' to be quite clean-looking
16:38:29 * ski . o O ( reflective syntax )
16:38:52 <untseac> I just found out that ecmascript (aka javascript) has optionals and filter/map functions. kind of nice in a way. it's something.
16:39:07 <remexre> ski: like elaborator reflection?
16:39:16 <ski> dunno what that is
16:39:53 <remexre> oh, it'd idris' template-haskell-like system
16:39:57 <remexre> it's*
16:40:06 <ski> ah
16:40:23 <ski> this is, sortof, more related to `!' (i think it was ?) in Idris, then
16:42:13 <remexre> ah
16:42:57 <remexre> solonarv: okay I think I'm going w/ the >>= version, looks like I need the variable later in the cases where the pattern "fails"
16:43:12 <ski> (although, it's also inspired a bit by quasi-quotation, yes. and Filinski's "Monadic Reflection")
16:53:45 * hackage parameterized-utils 2.1.0 - Classes and data structures for working with data-kind indexed types  https://hackage.haskell.org/package/parameterized-utils-2.1.0 (KevinQuick)
17:04:42 <mgomezch> Hi!  I use Nix on a Mac with a ghcWithPackages installed to my default environment, and included the ghcide package and some others I'd like to play with.  When I run ghcide in a directory with a source file, it fails on imports for non-core libraries (that are in my ghcWithPackages).  Is this an expected limitation, that ghcide only works if I
17:04:43 <mgomezch> actually define a Cabal / Stack package and enumerate dependencies?  Or am I missing some step?  (I can of course provide my configs if they're relevant)
17:05:12 <mgomezch> (not sure if there's some other channel more relevant to this sort of setup?)
17:08:06 <LevelChart8> is it safe to set { allowBroken = true; }
17:08:16 <LevelChart8> beam-postgres is broken apparently?
17:09:42 <mgomezch> It may cause your Nix to try installing something that is known to fail to build, and then it just spends a bunch of time compiling until it hits some error.
17:09:53 <LevelChart8> ok
17:10:12 <Welkin> nix is dead to me
17:10:30 <Welkin> the idea is great, the implementation is not
17:10:38 <Welkin> I literally cannot install it
17:11:39 <mgomezch> What's hot these days?  I'm very out of the loop; 5 years ago it was perhaps the lowest-friction option.  Sorry if this is a controversial subject ;)  I honestly don't know
17:14:45 <Welkin> what's hot in terms of what?
17:16:13 <Welkin> to install ghc, the recommended way is ghcup
17:16:15 <mgomezch> Tooling to install stuff, build stuff, manage environments… is Cabal Hell still a thing
17:16:23 <Welkin> and use cabal for package management and building
17:16:29 <mgomezch> Ah, I'll look into that :)
17:16:33 <Welkin> cabal hell is not a thing anymore
17:16:45 <Welkin> cabal has it's own nix-like way of manage packages
17:17:02 <mgomezch> Oh, nice!
17:26:17 <shapr> Anyone know how to tell gauge to run code only once? I thought it was iters in the config, but it doesn't seem to be? https://hackage.haskell.org/package/gauge-0.2.5/docs/Gauge-Main-Options.html#t:Config
17:33:31 <sm[m]> mgomezch: probably the hottest thing is indeed the ide-related projects. Hot as in bubbling on the stove, not quite ready to eat.
17:34:46 <sm[m]> Yes almost all haskell tooling requires a cabal project, not just source files, practically speaking. Stack scripts and cabal’s v2-run are a notable exception.
17:35:29 <LevelChart8> mgomezch: is config/nixpkgs/config.nix particular to a specific project? or its gllobal in my system?
17:35:34 <LevelChart8> i am trying to set alllowUnbroken
17:35:41 <LevelChart8> but i dont know where to find it
17:37:29 * sm[m] can’t think of much else to call “hot” exactly
17:38:26 <shapr> webdev?
17:39:24 <sm[m]> obelisk ?
17:39:59 <quiet_laika[m]> is it worth pulling in a dependency for difference lists? or is `Endo` good enough?
17:39:59 <shapr> uh, we're using servant
17:40:26 <quiet_laika[m]> i guess i could just use a `Seq` since i already have containers...
17:40:38 <sm[m]> Oh yeah, I guess servant could be called hot
17:41:28 <sm[m]> apps wise - shellcheck, postgrest, pandoc..
17:41:58 <LevelChart8> where can i find this? ~/.config/nixpkgs/config.nix
17:42:33 <sm[m]> Oh, and cardano
18:30:45 * hackage typed-encoding 0.3.0.0 - Type safe string transformations  https://hackage.haskell.org/package/typed-encoding-0.3.0.0 (rpeszek)
18:46:55 <ezzieyguywuf> so, I have a `f1 => Int -> MyData -> Maybe MyData` and `f2 => Int -> MyData -> Maybe SomeData`. How can I take the result of f1 and feed it into f2? I thought doing something like `(f2 0) <$> (f1 0 MyData)` would do it, but this results in a `Maybe Maybe MyData` and I don't understand why
18:56:31 <ezzieyguywuf> hm, it seems maybe I need =<<
19:48:34 <remexre> hm, is there some way to set the value that getArgs returns? (i.e. a setArgs :: [String] -> IO ()?)
19:52:52 <dolio> Yes, there's something like that.
19:53:35 <remexre> dolio: hints as to the name? hoogling for setArgs and putArgs got nothing useful
19:53:54 <crestfallen> very sorry why is it so tough to remove .cabal .ghc folders using $ rm -rf .ghc     AND   rm -rf  .cabal.  ? 
19:53:56 <dolio> Not sure. It could be withArgs, for a scoped thing.
19:54:06 <dolio> Did you try hoogling by type?
19:54:35 <crestfallen> I need a clean uninstall of cabal and anything hoogle. on a mac
19:54:47 <remexre> dolio: [String] -> IO () got nothing, will try withArgs + its type
19:55:25 <remexre> ah, withArgs indeed
19:56:40 <crestfallen> I've been using this by begriffs:   https://gist.github.com/begriffs/6408415
19:59:29 <crestfallen> never mind thanks I think I used homebrew to install
20:03:05 <crestfallen> I was able to uninstall ghc. any reasonable way to uninstall cabal?
20:04:21 <Welkin> with ghcup
20:04:29 <Welkin> or just rm -rf ~/.cabal
20:04:47 <Welkin> it depends on how you installed it
20:04:54 <Welkin> only install using ghcup
20:04:56 <Welkin> it's cleanest
20:05:23 <dsal> ezzieyguywuf: Yeah, that's what the maybe monad is all about.
20:05:24 <crestfallen> I think that's how I installed it but I removed .ghcup already :(
20:05:33 <crestfallen> Welkin 
20:05:57 <Welkin> install it again
20:06:14 <Welkin> it should just be ~/.cabal and ~/.ghc, I think
20:06:35 <Welkin> but again it depends on how you installed ghc and cabal in the first place
20:06:42 <dsal> % :t (>>=) @Maybe
20:06:42 <yahb> dsal: Maybe a -> (a -> Maybe b) -> Maybe b
20:07:14 <crestfallen> it's odd, ls -a doesn't show .cabal but I can query the version $ cabal --version
20:07:23 <Welkin> which cabal
20:07:26 <Welkin> try that
20:07:42 <crestfallen> 3.2.0.0
20:07:46 <Welkin> no, not version
20:07:49 <Welkin> type: which cabal
20:07:50 <crestfallen> ok
20:08:02 <Welkin> it tells you the location where it is stored
20:08:10 <crestfallen> ok I'll just nuke that binary?
20:08:11 <Welkin> ls -la $(which cabal)
20:08:20 <Welkin> it may be symlinked
20:10:04 <crestfallen> test
20:10:13 <crestfallen>     /usr/local/bin/cabal
20:11:32 <Welkin> yeah... that's not good
20:11:41 <Welkin> how did you install it?
20:11:45 <Welkin> you can just delete that
20:12:13 <Welkin> it's a bad practice to install into /usr/
20:12:31 <Welkin> should be in your home, then put it on your path, like ~/.cabal/bin
20:12:55 <crestfallen> ok I deleted it . where do you figure the symlink is hiding?
20:13:31 <Welkin> there is no symlink according to you
20:13:50 <Welkin> it would say so from that command I gave you
20:14:16 <crestfallen> I thought I used homebrew to install the whole thing does that make sense?
20:15:01 <Welkin> use ghcup from now on
20:15:35 <crestfallen> trying that now thanks!
20:15:37 <dsal> crestfallen: If you used homebrew, homebrew has an uninstall
20:16:14 <crestfallen> dsal I uninstalled ghc successfully but cabal I just did manually
20:16:22 <crestfallen> *with brew
20:17:03 <dsal> Ah, weird.  I can understand why nix is so appealing when it comes to stuff like this, though.  :)
20:20:27 <crestfallen> dsal yeah that keeps coming up. what's nix can I run a vm on mac for haskell study?
20:21:54 <dsal> You don't need a vm (nixos is another thing, which is super great).  You can kind of think of nix like a package manager, except you can have different packages running at the same time from simple recipes and not worry about all the other junk.
20:22:44 <dsal> e.g., in my gopro project, I can cd into the ui directory, and while I'm there, that shell will have elm and make installed.  Others won't.
20:23:38 <crestfallen> thanks you liking elm ?
20:24:21 <crestfallen> Welkin hi I assume the gcup put everything in its proper place
20:24:27 <dsal> A friend of mine was telling me he's been playing with nushell.  I figured I'd try it.  `nix-shell -p nushell nu` and I'm running nushell without "installing" it.  When I exit nu, it's gone"gone:
20:24:38 * dsal has a busted keyboard
20:24:59 <dsal> crestfallen: elm is OK.  I've not done much UI lately.
20:25:37 <Welkin> elm is my favorite language. I like it better than haskell
20:25:43 <Welkin> I've used it for 4 years now
20:25:59 <crestfallen> funny I got an older ghci version with the gcup than with the brew install. new is 8.8.3
20:26:49 <Welkin> type ghcup list
20:26:56 <Welkin> you can install any version you want and switch between them
20:28:02 <crestfallen> yeah it looks nice Welkin  8.8.3 is checked as recommended
20:29:26 <crestfallen> Welkin I'm not a programmer .. gotta stick with haskell can't look at other langs. My friend raves about erlang
20:29:51 <crestfallen> thanks kindly for your help
20:31:01 <crestfallen> one last thing the reason I had to reinstall: I botched installing hoogle. suggestions?
20:34:06 <Welkin> elm is much easier to pick up than haskell
20:34:24 <Welkin> it's a special language just for building web browser applications
20:36:15 * hackage simple-logger 0.1.0 - A very simple but efficient logging framework  https://hackage.haskell.org/package/simple-logger-0.1.0 (AlexanderThiemann)
20:37:15 <crestfallen> Welkin yeah I'm going down many rabbit holes with haskell. categories, unification. I like it but I get distracted
20:37:41 <crestfallen> S.K.I. calculus etc
20:38:19 <dsal> I just read stuff and build stuff.  Occasionally when I'm building something, I get annoyed and realize someone's solved the problem that's annoying me, so I get to use a thing I read aboutg.
20:40:00 <Welkin> I'm currently learning F#, which is a cousin of Ocaml, which is a cousin to Haskell
20:40:20 <Welkin> but it has a lot of oop interop features, which are strange
20:40:35 <dsal> That's the O in O'Caml.  :)
20:41:03 <crestfallen> I tried scheme before haskell. too hard to read I was going blind
20:41:19 <dsal> I used to write a lot of scheme on my Palm Pilot.
20:41:45 <crestfallen> I did get used to recursion to a degree though
20:42:08 <MarcelineVQ> ocaml is the strict but awkward librarian who wants to help you find what you need but would prefer if you were a bit quieter and doesn't really like how you dress
20:44:08 <crestfallen> well back to the back-breaking state monad.
20:44:21 <dsal> state is back breaking?
20:45:00 <crestfallen> sort of yeah . the text book has ST for state transformer which is confusing me
20:45:10 <dsal> ST is unrelated.
20:45:35 <dsal> StateT and ST sound like they do similar things, and you can do similar things with them, but they aren't very similar.
20:46:01 <crestfallen> you know a basic tutorial for state or some materials? dsal 
20:46:15 <dsal> haskellbook.com is a great path.
20:46:42 <dsal> StateT is really quite simple.  You can put values in it and pull values out of it.  That's pretty much it.
20:46:51 <Welkin> ST is for safe mutation
20:47:00 <MarcelineVQ> ST is unrealted to StateT, in haskell base libraries, but ST is probably related in the textbook given the context.
20:47:07 <Welkin> ST and IO are very closely related
20:47:09 <Welkin> State is pure
20:47:54 <dsal> crestfallen: Are you looking at StateT or ST? 
20:48:28 <dsal> The thing a little confusing about ST is that it's only really useful for things it works with.  Mutable vectors, IORefs, etc...   You can push any arbitrary state through a StateT
20:49:01 <Welkin> ST is State Thread
20:49:03 <crestfallen> hutton has ST and it's super terse. mr kmett suggested I read up on state elsewhere
20:49:21 <MarcelineVQ> That question can only be answered if you already know what the other ST is :>  Better to ask "What is the defintion of the ST you see in your book?"
20:49:46 <crestfallen> I essentially understand the thread fairly well, using it is another matter
20:49:53 <dsal> haskellbook.com takes you through some simple monads.  ReaderT and StateT are pretty similar.
20:52:35 <crestfallen> thanks dsal I have the book. I could use some chattiness after hutton
20:52:48 <crestfallen> thanks MarcelineVQ 
20:52:59 <crestfallen> thanks Welkin 
20:53:26 <dsal> Many of these things make way more sense once you need them to write a program.
20:53:39 <dsal> Or perhaps, use them.  You don't ever *need* them, but they make some things easier.
20:54:14 <crestfallen> yeah I don't know how to go about starting a project. like no clue. dsal
20:54:37 <dsal> I use stack, so it's "stack new hotness" and then post to instagram
20:55:05 <dsal> Then I just keep banging on the keyboard until my problems are all behind me.  It works pretty well most of the time.
20:55:34 <crestfallen> I used stack. complicated. members said just use cabal to learn haskell
20:56:06 <crestfallen> cabal sandbox is sort of cool
20:56:08 <dsal> People have opinions.
20:56:31 <dsal> I've tried cabal and haven't got completely to the point where it doesn't make things harder for me.
20:56:39 <dsal> I forgot what the last hangup I had was.
20:56:54 <crestfallen> are you an author of haskellbook? 
20:57:01 <dsal> No, just a customer.
20:57:19 <crestfallen> cool I should go back to it at this stage
20:58:09 <dsal> I'd written a couple of programs I used (and a couple libraries -- one relatively large) before going through the book.  Made a lot of the things I was doing make more sense.
20:58:24 <crestfallen> sweet
20:59:15 <dsal> Now any time I want to write a program, I just `stack new ...` and all my dreams come true.
20:59:35 <dsal> Except for this last little bit of the most recent thing I started.  Always something slowing me down.  Today, it was the chipper.
21:00:09 <crestfallen> I like the mathy side of haskell. I'd like to do a project where I can showcase haskell and some number theory for educational purposes
21:00:39 <dsal> I don't do much math.
21:00:47 <dsal> I don't believe in numbers.  Numbers are just a theory.
21:01:39 <crestfallen> pardon?
21:03:09 <dsal> I was mocking my ignorance.
21:03:47 <dsal> I'm a blue collar haskeller.  It's just the easiest tool to write programs, so I use it for that.
21:08:27 <crestfallen> thanks I like that
21:15:02 <MarcelineVQ> "<crestfallen> thanks MarcelineVQ " actually that was directed at dsal who said "<dsal> crestfallen: Are you looking at StateT or ST?"
21:15:08 <remexre> if I have something like,    let ys = fmap (foo (head xs)) xs in ...    with -XStrict, is it possible that this becomes non-total?
21:15:43 <remexre> and bizarrely, if I replace (head xs) with (head (traceShowId xs)), it becomes total again
21:15:43 <MarcelineVQ> But that's only a useful question to ask someone who knows the difference. If a person was looking at data ST s m a = ST (s -> m (s,a))  would they know to answer StateT instead of ST?
21:15:54 <dsal> remexre: head is not total
21:16:18 <remexre> dsal: er actually it's (\x -> foo (head xs) x)
21:17:25 <dsal> head is always partial.  I guess I don't understand your question.
21:17:44 <remexre> since I'm fmapping over xs, the lambda should only be called when xs is not []
21:17:48 <MarcelineVQ> I'd be asking where xs is coming from since that's also where your gurantee comes from
21:18:15 <monochrom> This question sounds like easily testable on an actual computer.
21:18:41 <remexre> monochrom: I'm getting weird behaviour in my unit tests, hence why I'm asking
21:19:18 <remexre> ghcid has it working, if I add the traceShowId it works, but otherwise I get head-of-empty-list
21:19:23 <monochrom> Yes if this is 1 line out of a 1000-line file, it is too hard to tell what's the determining factor.
21:19:50 <monochrom> Therefore throw away the 1000-line file.  Create a new small file that contains exactly what your question asks, no more.
21:19:58 <remexre> I guess I'm asking, is this a known bug/unexpected-behavior w/ -XStrict
21:20:02 <monochrom> Scientific least-moving-parts experiment.
21:20:03 <remexre> I'll try
21:20:14 <dsal> The journey of 1000 lines begins by deleting just one.
21:20:25 <remexre> :P
21:20:27 <dolio> Don't use -XStrict.
21:20:38 <monochrom> Programmers need to take a scientific method course, or even a philosophy of science course.
21:21:26 <monochrom> Because they have no idea what's "formulate a hypothesis" or "controlled experiment testing said hypothesis, no more no less".
21:21:37 <remexre> dolio: is that "it's broken and unmaintained," or "it's unhaskellful"
21:21:47 <MarcelineVQ> % :set -XStrict
21:21:47 <yahb> MarcelineVQ: 
21:21:56 <MarcelineVQ> % map undefined []
21:21:56 <yahb> MarcelineVQ: []
21:22:09 <remexre> monochrom: my hypothesis is that someone in #haskell would know if it were a common -XStrict unexpected-behavior :P
21:22:11 <MarcelineVQ> Now I have to wonder if Strict only works for source files
21:22:16 <dolio> I don't know if it's unmaintained. I just think it's a bad idea.
21:22:30 <MarcelineVQ> Not that it should matter for that example
21:23:28 <dolio> So that's my advice. :)
21:24:35 <monochrom> Yeah I now recall, even the efficiency-savvy tibbe only recommends strict data, not strict functions. In fact against strict functions.
21:27:00 <monochrom> Strict turns "let xs = ..." into "let !xs = ..."
21:27:23 <remexre> yeah, I prefer to use ~ where I need laziness
21:27:33 <remexre> StrictData does fix this, strangely enough
21:27:37 <monochrom> Now you have to dig into BangPatterns for what "let !xs =" means.
21:28:35 <dolio> What does it turn `let (x, y) = ...` in to, do you think?
21:28:56 <monochrom> haha "data T = C ~X" is a thing.
21:28:58 <remexre> something like a `seq` let (x, y) = a in b
21:29:31 <monochrom> it turns "let (x,y)" into "let !(x,y)". this case is uninteresting.
21:29:34 <remexre> I wonder if Strict is persisting further into desugaring, and (fmap (\x -> foo (head xs) x) xs) gets transformed into (let headXs = head xs in fmap (\x -> foo headXs x) xs) before all the patterns get bangs
21:29:54 <remexre> yeah, I meant more semantically, I guess
21:29:54 <dolio> Right, so it doesn't make it like a strict language at all.
21:29:55 <monochrom> err sorry, that case is still interesting.
21:30:14 <monochrom> The uninteresting one is "case ... of (x,y)" -> "case ... of !(x,y)"
21:30:34 <monochrom> But take care that the interesting one is "case ... of v" -> "case ... of !v"
21:32:25 <remexre> I'm unable to reproduce on a small example with runghc, ghc, nor ghc -O
21:32:25 <monochrom> Strict affects function defs, let/where bindings, and pattern matching only.  Even top-level "x = ..." is not turned into "!x = ..."
21:32:50 <dolio> Sure. That's not even allowed, I think.
21:33:33 <monochrom> and it only adds one seq rather than rnf.
21:34:03 <dolio> Well, rnf would be wasteful.
21:36:08 <remexre> hm, manually doing let ~headXs = ... doesn't help, though the ... expression in the real code does involve a strict data constructor
21:36:27 <remexre> (adding a strict data constructor to the small example doesn't make it get an exception, though)
21:43:10 <remexre> hm, in Core, no sigils would indicate that a case ... of { (x) -> ... } is lazy, right?
21:43:33 <dolio> In core case always evaluates.
21:44:27 <remexre>  hm, okay, then GHC is making the (let ~x = ... in ...) strict, then
21:45:35 <remexre> as of the -ddump-ds stage
21:47:43 <remexre> meh, I'll just switch to -XStrictData for now, and profile later
21:50:41 <remexre> I guess I care less about efficiency, more that (not to sound too inflammatory) thunks that contain exceptions always felt like null in OO languages
21:51:48 <Cale> remexre: I haven't been following closely, are you having trouble tracking down an incorrect use of head?
21:52:17 <remexre> Cale: I think GHC is misoptimizing my -XStrict code, lifting what /should/ be a safe use of head out of a lambda to where it's unsafe
21:52:26 <Cale> That's... odd
21:52:49 <Cale> remexre: One trick that I'd recommend is to always write head as (\(x:_) -> x) instead
21:53:09 <Cale> which will at least give you a line number when it fails
21:54:08 <remexre> oh, huh, that actually causes the exception to disappear
21:54:19 <Cale> hm
21:54:40 <remexre> changing (head xs) to (case xs of { [] -> error "sad"; (x:_) -> x })
21:54:58 <Cale> Well, -XStrict is something that essentially nobody uses, so I'm not too surprised if it sucks
21:56:22 <remexre> rip
22:07:51 <jsomedon> so I came across with online discussion that `Maybe` was made to solve NULL's problem?
22:08:36 <jsomedon> never realized such simple type had been carrying such a big role 
22:11:07 <gcoakes[m]> Hey, I'm hoping someone can help me with something. Is haskell capable of listing all types which are an instance of some type class?
22:12:18 <c_wraith> gcoakes[m]: in a global sense, no.  classes are open, so there might always be another instance defined somewhere it hasn't imported.  In a local sense, yes.  ghci can list all instances of a class that are currently in scope.
22:13:58 <Cale> jsomedon: I mean, I don't know if that could be said to be *the* motivation for its existence, but it's certainly some motivation.
22:14:37 <Cale> gcoakes[m]: In ghci, :info SomeClass
22:14:55 <Cale> (will show you the instances which are available via imported modules)
22:15:18 <gcoakes[m]> c_wraith: Local is fine, but I mean at runtime. I want to call a particular function on all instances which have been imported.
22:15:33 <c_wraith> gcoakes[m]: types don't exist at runtime, so that might be a problem...
22:15:47 <c_wraith> gcoakes[m]: but I think you really mean at compile time
22:16:00 <c_wraith> gcoakes[m]: which I think you can manage with template haskell
22:17:23 * gcoakes[m] sent a long message:  < https://matrix.org/_matrix/media/r0/download/matrix.org/aDOtfgqvluPsesiIMvJyrrRC >
22:19:06 <Cale> gcoakes[m]: I don't think that completely makes sense. But it's easy enough to construct a Data.Map String (... some function type ...)
22:19:28 <Cale> I guess that should be Data.Map.Map, lol
22:19:49 * gcoakes[m] sent a long message:  < https://matrix.org/_matrix/media/r0/download/matrix.org/TAONEPpIERZFUCrJEjxotEjv >
22:20:17 <Cale> I mean, you can use something like hint if you want
22:20:31 <Cale> https://hackage.haskell.org/package/hint
22:21:20 <Cale> That's basically a nicer wrapper around GHC-as-a-library
22:21:36 <Cale> that you can use to load Haskell code at runtime, if you really want
22:21:59 <gcoakes[m]> But, that eliminates the possibility of distributing the project as a single file executable, right?
22:22:14 <gcoakes[m]> I would have to have the .hs files available at runtime?
22:22:24 <c_wraith> I mean, if you want to compile haskell code at runtime, you need a haskell compiler.
22:23:01 <Cale> I mean, if you compare it with the situation with python, you still need a python implementation there
22:23:53 <gcoakes[m]> Cale: Absolutely, that's one of my biggest headaches and seemingly one of the reasons why python is so easy to collaborate with other teams.
22:24:26 <gcoakes[m]> c_wraith: The intention wasn't runtime compilation, but using a string to define the next function to call.
22:25:45 <awpr> the Haskell runtime doesn't provide lookup of functions by name, but if you have a particular set of functions in mind that you want users to be able to call, you can actually type in a Map of them
22:26:23 <Cale> ^^
22:26:25 <awpr> being able to call /any function in the program/ by name is problematic, though, since lots of functions (e.g. unexported ones) will disappear entirely
22:26:41 <gcoakes[m]> awpr: like a big `case` expression, right?
22:26:52 <Cale> Yeah, that's probably what I'd do -- work out some system by which I associate strings with actual functions/IO actions
22:26:59 <awpr> the particulars ultimately depend on what you mean by "call" and "function"
22:27:05 <Cale> You could use a case expression, or you could use a Map
22:27:27 <Cale> What type of functions are these?
22:28:03 <gcoakes[m]> https://gitlab.com/gcoakes/sys-expect/-/blob/master/sys_expect/plugin/nvme_cli.py
22:28:47 <gcoakes[m]> I want to ultimately be able to read a file like this: https://gitlab.com/gcoakes/sys-expect/-/blob/master/examples/trivial_reset.yaml
22:28:47 <gcoakes[m]> And, have it make certain assertions about system state which are defined in that file.
22:29:23 <Cale> oh, this sounds kind of propellor-ish
22:29:36 <gcoakes[m]> propeller?
22:29:37 <Cale> https://hackage.haskell.org/package/propellor
22:30:16 <gcoakes[m]> Oooh, that looks cool. Kinda like ansible?
22:30:32 <gcoakes[m]> Ansible was part of the inspiration for this project.
22:34:35 <kaol> I'm tempted to replace every return in my code with pure.
22:34:49 <Cale> I don't know these tools all that well, but I think so. The idea is that you write a bunch of properties of a system (in Haskell), and it takes steps as necessary to ensure that those properties are satisfied
22:35:04 <Cale> kaol: That seems to be a trend. I don't particularly like it, but it's happening.
22:37:08 <Cale> It loses a small amount of information which can help a human reader figure out what's going on
22:37:57 <Cale> When I see 'pure' it slightly suggests to me that no Monad instance is available, and when that's not the case, it's kind of annoying.
22:42:39 <fpaulw> does 'pure' equate to 'return' for every monad because monads are subclasses of applicatives?
22:43:00 <suppi> Do you also prefer liftM over fmap?
22:45:39 <Cale> suppi: Not unless I'm writing a functor instance, or there are liftM2's adjacent
22:46:24 <Cale> fpaulw: Pretty much, yeah
22:46:36 <Cale> Or, Monad is a subclass of Applicative
22:46:39 <suppi> Isn't the two cases pretty similar though? liftM / fmap and return / pure
22:46:45 * hackage calamity 0.1.9.1 - A library for writing discord bots  https://hackage.haskell.org/package/calamity-0.1.9.1 (nitros12)
22:47:02 <suppi> Aren't*
22:47:40 <Cale> Somewhat, though liftM isn't guaranteed to be as efficient as fmap (though usually the difference will be trivial)
22:48:01 <Cale> liftM is a possible implementation of fmap, using the Monad operations
22:48:27 <Cale> fmap will often be implemented more directly
22:48:32 <dsal> jsomedon: I wouldn't say Maybe was made to solve NULL's problem.  Maybe was made to solve the problem where you may not have a value.  null is used for that in some languages as well and then that has problems.
22:49:31 <Cale> dsal: Yeah, that's a nice way to put it. Though I think the problems of null being used for that in other languages is something that the people who defined Maybe in Haskell (and similar types in ML) were well aware of.
22:51:05 <dolio> Also it's not so much using null for that, but making every type contain null just for that.
22:52:00 <dsal> Yeah, I suspect they'd heard of Dijkstra.
23:06:20 <c_wraith> gcoakes[m]: I did something very, very silly.
23:06:47 <c_wraith> and if I could ever actually stay logged in to github, I'd have it in a gist now
23:10:41 <gcoakes[m]> c_wraith: I hope it wasn't related to my project. You can really mess things up if you use some of the tools in there without knowing what you're doing.
23:10:48 <gcoakes[m]> What happened?
23:11:09 <c_wraith> Oh, I meant I did some very silly template haskell hacking.  https://gist.github.com/chowells79/1d3560bdd7edd84de8c82c87e96cfaea
23:11:52 <gcoakes[m]> Oh! You were trying to implement the template haskell for what I was asking about.
23:12:01 <c_wraith> It works.  That's the silliest part.
23:13:01 <Cale> haha, you're making use of the feature of reifyInstances which is normally the bane of my existence
23:13:09 <gcoakes[m]> I'm not familiar with implementing template haskell at all. Would you mind running me through this a bit?
23:13:26 <c_wraith> Cale: the fact that if you pass it an unconstrained type variable it returns all instances?
23:13:29 <Cale> yes
23:14:12 <Cale> I ended up making hacky Skolem type families with no instances to avoid that while preserving the variables so I know what I'm doing later
23:14:26 <c_wraith> gcoakes[m]: ok.  Big picture first. Class.hs has all the dumb magic.  First.hs and Second.hs exist just to show that importing them magically makes things happen.
23:15:42 <gcoakes[m]> `reifyInstances ''Testable ([VarT (mkName "a")])` gets all instances of Testable, right>?
23:15:46 <gcoakes[m]>  * `reifyInstances ''Testable ([VarT (mkName "a")])` gets all instances of Testable, right?
23:15:57 <Cale> yeah, all those in scope
23:16:07 <c_wraith> gcoakes[m]: makeTestableTable is the magic part.  It uses reifyInstances to get all instances of Testable that are in scope *where it is spliced*, and then create a Data.Map.Map of type names to the particlar test value for that type
23:17:06 <c_wraith> everything inside `let exprs = ...` is just template haskell data type munging and then use in a Q Exp literal
23:17:10 <gcoakes[m]> Is `InstanceD` a compile time type for an instance of a typeclass?
23:17:24 <c_wraith> https://hackage.haskell.org/package/template-haskell-2.16.0.0/docs/Language-Haskell-TH.html#v:InstanceD
23:17:42 <c_wraith> It's the template haskell representation of an instance declaration
23:20:08 <gcoakes[m]> So, there can be multiple instances of Testable in `First.hs` and `Second.hs`, right?
23:20:18 <c_wraith> yep
23:22:28 <c_wraith> It's all a bit silly, though.  You have to create no-arg instances for no reason other than to make them visible to the class magic.  And the class has to be ambiguous so that the instances can actually be used interchangeably.  And TypeApplications is needed to resolve that ambiguity
23:23:03 <c_wraith> I wouldn't really use that.  But as much as I dislike using template haskell in real programs, I like creating hacks with it :)
23:24:34 <gcoakes[m]> So, if I were to take the long approach and use a case expression, every instance of that trait would be +1 line and every module containing those implementations would be +1 line, right? That doesn't seem terrible. I just really liked the idea of a commit which adds a new tool or functionality of a tool only touching a single file.
23:26:24 <gcoakes[m]> Either way, I think I've landed on not shifting away from python because I want to maintain the ability to import plugins which are potentially maintained by teams/contributors other than myself.
23:27:28 <gcoakes[m]> As much as I wanted to have more compile time guarantees, I think I'll have to suffice with static analysis.
