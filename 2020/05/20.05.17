00:06:44 * hackage monadic-recursion-schemes 0.1.9.1 - Recursion Schemes for Monadic version.  https://hackage.haskell.org/package/monadic-recursion-schemes-0.1.9.1 (KatsutoshiItoh)
00:23:36 <scasc> Quick question: after I generate haddock documentation with `cabal new-haddock`, is there an easy way to open it up in a browser?
00:24:34 <scasc> By an easy way I'm thinking of something like `cabal run` after `cabal build`.
00:25:01 <scasc> I know where the generated .html is, but it's buried deep in the dist-newstyle directory.
00:25:12 <scasc> So a singular command which opens up it's index would be nice
00:27:40 <[exa]> scasc: I guess this is not in cabal, but you can make a pretty simple script that does it for you
00:46:15 * hackage servant-wasm 0.1.1.0 - Servant support for delivering WebAssembly  https://hackage.haskell.org/package/servant-wasm-0.1.1.0 (DavidJohnson)
01:00:45 * hackage tasty 1.3.1 - Modern and extensible testing framework  https://hackage.haskell.org/package/tasty-1.3.1 (RomanCheplyaka)
01:07:04 <Athas> Is there an equivalent to 'cabal install' that does incremental builds?  Looks like 'cabal install' first generates a source dist tarball and then builds from scratch.
01:07:26 <Athas> I know I can write a script to extract the binaries produced by 'cabal build' myself, but surely this is not an obscure use case?
01:08:01 <Athas> I know I can also use 'cabal run', but there is 100% likelyhood that I will sometimes forget, and accidentally use the previously installed version of whatever program I'm working on.
01:24:42 <int-e> . o O ( Sigh, now I'm annoyed at getting annoyed at an oversized jpeg being attached to a haskell-cafe message. )
01:50:15 * hackage publicsuffix 0.20200517 - The publicsuffix list exposed as proper Haskell types  https://hackage.haskell.org/package/publicsuffix-0.20200517 (wereHamster)
02:01:14 * hackage odd-jobs 0.2.0 - A full-featured PostgreSQL-backed job queue (with an admin UI)  https://hackage.haskell.org/package/odd-jobs-0.2.0 (saurabhnanda)
02:33:39 <veverak> let's say I have same parametrized type A a { attr : a } and foo :: A Int -> A String, can I just write: foo a = a { attr = toString attr a } ?
02:33:59 <veverak> -> change 'parameter type' of the type with record syntax?
02:38:18 <mniip> veverak, yes
02:39:34 <veverak> \o/
02:46:45 * hackage odd-jobs 0.2.1 - A full-featured PostgreSQL-backed job queue (with an admin UI)  https://hackage.haskell.org/package/odd-jobs-0.2.1 (saurabhnanda)
02:59:07 <veverak> hmm, I am using 'sequnece $ foo <$> a' a lot, is there a <$> version that does sequncing ?
02:59:38 <siraben> Should I use Haskell or Purescript if I want to do web development with a purely functional language?
02:59:49 <siraben> Can Haskell integrate with react components, for instance?
03:00:02 <xerox_> :t traverse -- veverak 
03:00:03 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
03:00:19 <veverak> nice, thanks!
03:41:40 <ivegotasthma> hello, can someone give me a hand at understanding why my Arbitrary implementation for a naive Tree is not working? https://pastebin.com/raw/BzhT2PVx
03:43:34 <int-e> so many type errors
03:43:57 <int-e> a) check the size=0 case. b) check the order of the arguments of Node.
03:45:27 <ivegotasthma> a) oh yeah, true, my bad
03:45:44 <ivegotasthma> b) if I'm understanding it correctly, I should pass the arbitrary first, then the two subtrees
03:49:19 <ivegotasthma> thanks man!
03:49:25 <ivegotasthma> I replaced oneof with frequency as well
04:45:45 * hackage servant-errors 0.1.5.0 - Servant Errors wai-middlware  https://hackage.haskell.org/package/servant-errors-0.1.5.0 (epicallan)
04:48:45 * hackage ttc 0.2.2.0 - Textual Type Classes  https://hackage.haskell.org/package/ttc-0.2.2.0 (TravisCardwell)
05:06:09 <pie_> if haskell is so cool why havent we made ourselves a bigger job market yet
05:10:15 * hackage binary-io 0.1.0 - Read and write values of types that implement Binary from and to Handles  https://hackage.haskell.org/package/binary-io-0.1.0 (vapourismo)
05:21:11 <maerwald> pie_: Hmm, I would say intellectual complexity, performance issues and ecosystem/compiler
05:21:54 <maerwald> the first you cannot really improve much, the others yes, but would take some major companies to invest imo
05:38:52 <dmj`> pie_: languages need to be dumbed down for corporations to accept
05:39:05 <dmj`> pie_: we had lisp in the 50s
05:39:32 <dmj`> pie_: languages just steal haskell features to "level up"
05:44:38 <Cheery> I wrote yet another monad blogpost http://boxbase.org/entries/2020/may/18/diy-io-monad/
05:49:32 <juri_> FWIW, the place i work is hiring haskell developers. we can't find any with enough experience. also, we're a devops team, so 'pure' software developers need not apply.
05:50:45 <Rembane> juri_: Do you have a work ad somewhere?
05:51:36 <dmj`> juri_: do you guys use nix?
05:51:58 <pie_> case in point of "it takes a lot more to get going with haskell" <juri_> FWIW, the place i work is hiring haskell developers. we can't find any with enough experience. also, we're a devops team, so 'pure' software developers need not apply.
05:52:18 <pie_> noone wants you if you arent already a guru
05:52:29 <juri_> pie_: I am not a guru. ;P
05:52:53 <pie_> where do you work btw
05:52:54 <juri_> I've only been programming in haskell for 5 years.
05:52:55 <dmj`> pie_: you just need to be "guru enough"
05:53:29 <pie_> from my point of view thats pretty guru ;)
05:55:26 <juri_> pie_: you'd think, but you'd be wrong. i got hired with 3 years of 'hobby' haskell development. mainly due to the 20 years of operations...
05:56:24 <pie_> ok so it sa very ops-y job :P
05:56:24 <juri_> having one skill is nice. having two is the current state of the industry, at least in my corner of the world.
05:56:33 <pie_> i still want to say this isnt geting a whole lot better
05:57:08 <juri_> pie_: sure, but how old will you be in 5 years if you don't study haskell? :P
05:57:35 <pie_> im not sure how to answer that
05:57:45 <pie_> probably same old
05:57:47 <sshine> juri_, what's your company?
05:58:01 <pie_> i have to resort to python to get anything at all done still xD
05:58:10 <Rembane> pie_: What do you do in Python?
05:58:25 <pie_> random stuff
05:58:32 <Rembane> pie_: What stops you from doing it in Haskell?
05:58:37 * sshine gets to use Haskell as part of his work, but his workplace is a pipedream factory :-P
05:58:41 <juri_> pie_: nod. there have been at least three rewrites of the haskell project i run, because.. ;)
05:58:58 <pie_> i think i just need to crank out a lot more code in anything at all because i seem to be bad at implementing anything at all
05:59:09 <sshine> s/pipedream/moonshot/ sorry
05:59:20 <pie_> moonshot factories sound cool
05:59:21 <Rembane> sshine: Those either make you really rich or really poor. :)
05:59:27 <juri_> dmj`: nope! we have some evangelists for it amongst the DEV side, but so far the OPS side is dubious.
05:59:29 <Rembane> sshine: Are you hiring? :)
05:59:47 <pie_> Rembane: empirically i get nowhere fast with haskell
05:59:54 <pie_> Rembane: at least with python i can iterate
06:00:10 <pie_> Rembane: not that one cant iterate with askell but i try to start and nothing gets anywhere
06:00:24 <sshine> Rembane, I'm just being employed, but I think so :) at least, my boss asked me to co-conduct an interview monday.
06:00:25 <Rembane> pie_: Got it, but you won't get fast with Haskell until you have loads of experience with it. So if you do the things in Haskell that you normally would do in Python you will get more experience.
06:00:36 <Rembane> sshine: Sweetness! :D 
06:00:40 <pie_> Rembane: right i guess im agreeing with you
06:00:48 <Cheery> I stopped using Python, but Haskell partially is plagued by the same reason why I did so.
06:00:52 <dmj`> juri_: Nixops for AWS works well enough ime. Just a wrapper around boto. Are you using kubernetes currently?
06:00:57 <pie_> Cheery: hm?
06:01:21 <Rembane> pie_: There's also a blogpost about this that I have completely forgotten how to find.
06:01:22 <juri_> dmj`: yeah, that's what's been proposed, but we maintain a LOT of environments, and a lot of them are not AWS.
06:02:11 <pie_> Rembane: do tell if you find it
06:02:12 <juri_> k8s on metal, k8s on kvm, aws without vpc... there's a reason we hire heavy ops / light haskell.
06:02:15 <sshine> pie_, I think working with ideas of which most don't amount to anything can be very depressing to some. I certainly need some amount of certainty about the effect of my work, even if that effect won't reach to the world's end.
06:02:41 <pie_> i should really get a job shouldnt i
06:02:47 <sshine> pie_, maybe not.
06:03:01 <pie_> working on stuff alone isnt great and id proably learn better in a team - or not
06:03:20 <pie_> none is interested in flexibly timed junior positions though bleh...
06:03:21 <Rembane> pie_: I found it! This one! https://williamyaoh.com/posts/2020-04-19-permissive-vs-restrictive.html
06:03:25 <pie_> (independent of haskell)
06:03:27 <juri_> pie_: jobs are good for that, but there are plenty of free software projects you could join up with.
06:03:44 <pie_> juri_: i guess you have a point. i poke at nixos way too much
06:03:45 * sshine 's weekend highlights has so far consisted of watching a youtube video of a guy doing a swarm intelligence ai bot for minecraft, watching a Ben Goertzel interview, and playing Tekken high, and I can't for the life of me imagine doing financial applications is key to anything.
06:03:53 <pie_> otoh i really could use some pocket money, sigh
06:04:00 * pie_ needs a beefier machine
06:04:24 <pie_> Rembane: thanks! i always like article recommendations
06:04:37 <Cheery> pie_: the python2 → python3 coercion pisses me off because python3 isn't particularly much better than python2
06:04:44 <juri_> sshine: my weekend has been working on a 3d printing stack component (a slicer) in haskell. wheee! ;)
06:04:54 <pie_> Cheery: oh, i expected something worse :P
06:04:56 <sshine> pie_, you need pocket money :-D in all honesty, I'm just working towards financial independence.
06:05:03 <pie_> Cheery: i get it but it doesnt affect me too much
06:05:10 <sshine> juri_, sounds productive :)
06:05:10 <pie_> sshine: thats one way to phrase it
06:05:20 <Cheery> pie_: but it also demonstrates a point, once python2 is done, my code written in python stops meaning anything.
06:05:43 <sshine> pie_, my friend who is a comic book artist achieved this years before me, which is ironic.
06:05:47 <juri_> sshine: it's a bit midlife-crisisey. i am getting old, and am shooting for 3d printing saving us all. ;)
06:06:10 <pie_> Cheery: once haskell is done it becomes meaningless?
06:06:12 <sshine> juri_, convergence of technology. it'll be good for something, and in the meantime it'll be fun for something else. :)
06:07:00 <pie_> people are always on about lack of employees in IT cant someone throw me a bone :PP
06:07:18 <pie_> otoh ok sure maybe its all normal day jobs
06:07:38 <sheepfleece> I'm not sure how exactly generic-lens library might use interface of a lens library without having a dependency on it. Am I missing something? (I'm not sure whether I was able to send this message the first time, but whatever!)
06:07:48 <Cheery> pie_: third there's a bitrotting effect because interfaces are defined by implementations rather than as something more abstract.
06:08:31 <Cheery> I've patched beautifulsoup few times in a hurry because it wrecked up in some or other way.
06:08:49 <Cheery> due to an update
06:09:06 <pie_> Cheery: yeah thats always fun
06:09:28 <pie_> this is why i prefer physics over engineering
06:09:40 <pie_> at least in the past 200 years reality seems to have behaved pretty consistently
06:09:49 <pie_> engineered systems are dumb
06:09:55 <pie_> here i am doing software engineering anywat
06:10:08 <juri_> haskell is very consistent. I'm done with implementing in other languages.
06:10:13 <Cheery> Haskell has also bit of this problem, but I think it can be fixed because there's better grounding to theory.
06:11:03 <sshine> pie_, yeah, we need more self-adapting systems. :)
06:12:37 <dmj`> juri_: I'd prefer AWS w/o VPC :) if Kubernetes is the tool you're going for, then nix is great for building thin docker images, o/w nixops is more of a provisioning and nice wrapper over scp. No "self-healing" like kubernetes
06:12:56 <pie_> juri_: sure see the X different typed impleentations of things that have X diferent implementations :P
06:13:00 <dmj`> juri_: but kubernetes is pretty monolithic and all-encompassing for ops
06:13:14 <dmj`> juri_: some would say nix is the same for builds
06:13:20 <pie_> haskell is much better but not invulnerable to human laziness or lack of exactly correct polymorphism
06:13:54 <maerwald> nix is nice if you want to lock your devops team into an overcomplicated ecosystem with poor documentation
06:14:01 <pie_> :V
06:14:14 <dmj`> sheepfleece: lenses are just functions, you don't the lens library to construct lenses.
06:14:19 <maerwald> and then pay your main nix dev very well, so they don't leave out of boredom and you won
06:14:21 <pie_> i-i-i mean youre not *completely* wrong
06:14:24 <maerwald> have to rewrite everything
06:14:26 <sshine> maybe I will become enough of a masochist to venture into nix eventually.
06:14:34 <dmj`> sshine: it's worth it
06:14:47 <pie_> my main gripe with nix is iteration speed if you have to keep recompiling stuff
06:14:56 <pie_> yes ecosystem integration can be hard
06:14:57 <dmj`> sshine: the nixos testing infrastructure alone is worth the price of admission
06:15:12 <maerwald> but the nix evangelists here are very persistent
06:15:18 <pie_> dmj`: yeah i saw some random project using hydra the other day and i was like oh neat uwu
06:15:26 <dmj`> pie_: that's what nix-shell is for, you can also just nix install the whole environment into your PATH
06:15:35 <juri_> I won't be nixing any time soon. There is one true inheritor of Unix, and it's name is Debian. ;)
06:15:36 <pie_> dmj`: yeah
06:15:55 <dmj`> juri_: blasphemy :) 
06:16:02 <sheepfleece> dmj`: Ah, I see, it's just a function, thank you. 
06:16:03 <dmj`> pie_: hydra is real bad yea
06:16:22 <pie_> i havent actually used it yet
06:16:33 <sheepfleece> Is there a lens to get inside reader? I want something like `ask ^. field ^. field`
06:16:47 <dmj`> sheepfleece: view 
06:16:56 <sshine> juri_, yeah I'm in a similar boat.
06:17:10 <dmj`> > flip runReader (1,1) (view _1)
06:17:12 <lambdabot>  1
06:17:31 <dmj`> juri_: nix installs on debian just fine :)
06:17:34 <pie_> im open to being someones well paid lead nix dev who doesnt get bored
06:17:38 <pie_> sidenote
06:17:41 <pie_> ;PPPP
06:17:44 <dmj`> its just hard to get rid of nix, it can weasel its way into anywhere
06:17:47 <sshine> juri_, Debian/Arch/MacOS, I just need a window in which to type letters, and it'd be nice if they show up in color and <tab> does something half-smart. :)
06:18:11 <juri_> sshine: indeed. my biggest/best machines are the ones i SSH into. ;)
06:18:22 <pie_> dmj`: you have a point :I though the build results can be used independent of it as long as you can put stuff in /nix or use a bind mount or however that workaround works
06:18:31 <pie_> or you can rebuild the world with a different root path.
06:19:41 <pie_> nix needs a lo of polish and the core devs seem to be off doing something else. or im just blind
06:20:00 <pie_> but if it fits you youll find notiheng better
06:20:04 <pie_> though i havent used guix yet
06:20:16 <maerwald> pie_: well, nix is like microservices. Some big company used it successfully, because they have a very specific use case and then everyone goes "oh look, we need that too"
06:20:28 <pie_> maerwald: n...o?
06:20:49 <maerwald> While in fact, most companies have no interest in the advantages it gives
06:21:29 <maerwald> But yes, you can build everything with microservices too :)
06:21:48 <maerwald> And then you go "look, we used microservices successfully" and everyone goes "oh wow"
06:22:03 <pie_> heh
06:22:04 <hexagoxel> "no, we want our CI to rebuild haskell deps each time, or invent some hand-written caching logic on top of docker images"
06:22:15 <maerwald> hexagoxel: cabal-cache?
06:22:31 <maerwald> even stack has caching
06:22:36 <maerwald> it's such a trivial problem
06:24:49 <hexagoxel> I love how cabal-cache's readme starts with a "failed" of their master build.
06:24:49 <dmj`> pie_: nix is great, it just takes a lot of failing with it to get used to it, lots of people don't have the patience, but once you get over that its great
06:24:56 <hexagoxel> I guess it highlights that their CI works :)
06:25:13 <maerwald> pie_: and then nix evangelists "you're just too lazy" :)
06:25:36 <pie_> i think doing anything without nix or something similar is a waste of time
06:25:41 <maerwald> hexagoxel: odd that I've used it in production for 1 year successfully
06:26:07 <maerwald> I must have been dreaming that the CI had less problems compared to when it was all nixified
06:26:12 <hexagoxel> and people are using nix successfully. This is not an argument that matters.
06:26:29 <pie_> by which i mean having a centrlized configuration description
06:26:32 <maerwald> hexagoxel: no, but it invalidates your argument that you have to invent hand-written caching logic =)
06:26:43 <pie_> having a proper language for that as opposed to the other tools that do their ad-hoc tihng
06:26:47 <hexagoxel> that readme does not even tell me what cabal-cache does. From the first impression, on par with nix docs
06:26:57 <pie_> mnd you im talking out of my ass becuase ive never tried to use something like chef or ansible
06:27:15 <maerwald> pie_: exactly, to make a proper decision, you have to understand more than one tool
06:27:34 <pie_> otoh i like having a proper -ish programming language for system configuration
06:27:42 <pie_> let alone a purely functional one
06:27:50 <pie_> let alone a purely functional one with laziness
06:27:53 <maerwald> pie_: you prefer turing complete configuration languages?
06:28:03 <pie_> yes because otherwise you end up copy pasting
06:28:07 <maerwald> huh
06:28:10 <pie_> or whatever
06:28:15 <maerwald> you're aware of the problems that causes? :)
06:28:21 <pie_> roughly probably
06:29:21 <pie_> but im pretty bad at things and some things just dont click in my head so
06:29:57 <pie_> (there's so many things i wish nix would handle better :( )
06:34:15 <hexagoxel> maerwald: I have no idea how cabal-cache integrates with other tooling, so invalidate away, I can't check your claims anyway.
06:36:28 <maerwald> hexagoxel: it doesn't need to "integrate", because it's just a caching tool. That's unix.
06:36:49 <maerwald> And yes, you can easily check my claims with a travis CI setup.
06:37:24 <hexagoxel> i'd be interested to look at an example. do you have a link?
06:39:42 <maerwald> hexagoxel: I don't know why you would need an example for that. There's nothig to learn about it
06:40:00 <maerwald> you just sync to and from your bucket, those are two lines each
06:40:15 <maerwald> *in total
06:40:31 <maerwald> https://github.com/haskell-works/cabal-cache#example-usage
06:41:03 <hexagoxel> so I need to start reading the source to see what it even does? good. So it really is like nix.
06:41:30 <maerwald> hexagoxel: what do you mean?
06:41:35 <maerwald> it's a cli tool
06:41:47 <maerwald> read the readme
06:42:19 <hexagoxel> so it copies things from the cabal new-style store?
06:42:28 <maerwald> based on plan.json
06:42:35 <pie_> Rembane: so i still need to read the article, but getting permissiveness is also hard in haskell? like, getting the right kind of polymorphism, idk
06:43:04 <hexagoxel> why can't they say this in the readme? how am I supposed to know it does it? educated guessing?
06:43:12 <pie_> hexagoxel: haskel ecosystem problems
06:43:25 <maerwald> hexagoxel: it does
06:43:27 <Rembane> pie_: What's the right kind of polymorphism? Do you have an example? 
06:43:30 <maerwald> read the README
06:43:31 <pie_> Rembane: no idk
06:43:40 <Rembane> pie_: Okay. :)
06:43:45 <pie_> Rembane: x)
06:43:55 <maerwald> "Build the project with cabal v2-build. This will ensure your dependencies are built and will produce a plan.json file that is required for the cabal-cache tool to know which built packages to sync up."
06:44:05 <maerwald> it's mentioned directly in the README
06:44:05 <Rembane> pie_: If you can avoid it, don't use polymorphism. 
06:45:07 <hexagoxel> of course it is all obvious if you have used the tool before
06:45:17 <maerwald> no, it's obvious if you have read the README
06:47:00 <hexagoxel> nevermind, sorry for wasting your time
06:47:23 * hexagoxel will continue using nix
06:48:12 <maerwald> Not sure what's hard about reading the README. It's small and concise.
06:48:34 <yushyin> so I've never used such tool, but after reading the readme I would say, you build with cabal on machineA, run cabal-cache sync-to-archive ... on machineA, run cabal-cache sync-from-archive ... on machineB, run cabal on machineB with cached prebuilds?
06:48:46 <maerwald> yes
06:48:50 <maerwald> it's very simple
06:49:14 <maerwald> and due to cabal there are no collisions, even for different ghc versions and whatnot
06:49:33 <maerwald> stack has a similar tool, I forgot the name
06:50:15 * hackage mutable-lens 0.2.0.0 - Interoperate mutable references with regular lens  https://hackage.haskell.org/package/mutable-lens-0.2.0.0 (infinity0)
06:50:27 <maerwald> https://github.com/fpco/cache-s3
06:50:51 <maerwald> looks more complicated, but then again, it's stack
06:51:14 <hexagoxel> so it is like nix caches, only specific to haskell deps :)
06:51:20 <maerwald> yes
06:51:32 <hexagoxel> and if your CI involves anything other than haskell, you need to merge two sorts of caches
06:51:41 <hexagoxel> ding ding custom caching logic
06:51:41 <maerwald> it's pretty rare that you need to rebuild your system libs every time you do a CI build
06:52:05 <maerwald> hexagoxel: not really
06:52:19 <maerwald> but there are too many ways to do this to argue about it
06:52:56 <maerwald> what is true is this: it is hard to share complicated build config and have the same result without controlling the environment, except with nix
06:54:04 <hexagoxel> cabal-cache looks like a useful tool for certain setups, I admit. but it seems it would stop being useful once you have different distros or other languages involved in your project.
06:54:29 <maerwald> hexagoxel: yes, you can get into libc incompatibility issues, so your build machine should have a low libc version
06:55:29 <maerwald> All still relatively trivial issues, if you ask me
06:56:06 <hexagoxel> yeah, I see your point
06:56:16 <maerwald> last time I wanted to use nix for something non-trivial (building fully static binaries)... it just didn't work and barfed out with confusing errors
06:56:24 <maerwald> I then stopped trying and just used alpine til today.
06:56:50 <hexagoxel> I just have setups in mind that are sufficiently complex that nix feels appropriate
06:57:07 <maerwald> hexagoxel: maybe, hard to argue about it without seeing the setup
06:57:12 <hexagoxel> :)
06:58:29 <maerwald> hexagoxel: I've met a CI embedded engineer who previously worked at tesla, who was so proficient with docker that he could literally do everything with it in a matter of a few hours. Ofc the complexity was sometimes unsettling, but yeah
06:58:53 <maerwald> not sure what to think about it
06:59:16 <maerwald> The tools you know...
07:00:10 <maerwald> and ofc they would argue for docker all day :)
07:00:38 <maerwald> (no matter if it was needed or not)
07:01:24 <maerwald> and bc they are so productive with it, you stop caring... UNTIL
07:01:28 <maerwald> you have to touch any of it.
07:02:10 <maerwald> Then you realise the lack of balance between a) complexity of the problem and b) complexity of the solution
07:02:29 <maerwald> Not much different from nix
07:02:33 <hexagoxel> does cabal-cache upload just the transitive dependencies of your project?
07:02:44 <maerwald> hexagoxel: local packages are excluded
07:02:56 <maerwald> otherwise everything
07:03:26 <maerwald> the "local packages are excluded" was a bit confusing and forced me to read the code (which was more confusing)
07:03:47 <maerwald> Because I wanted to be sure it doesn't upload proprietary stuff to a public S3 bucket xD
07:03:50 <hexagoxel> uh, but cabal store still has no GC right?
07:04:06 <hexagoxel> or the only GC is "delete the store"
07:04:44 <maerwald> hexagoxel: as I said, it only upload the dependencies that cabal generates and puts in plan.json, not your entire cabal store
07:05:09 <maerwald> so if you remove a dependency, you might have some stray files on your bucket, yes
07:06:40 <maerwald> https://github.com/haskell-works/cabal-cache/issues/108
07:08:03 <maerwald> If you use an alternative package repository/index... well, I guess you're on your own then
07:08:43 <hexagoxel> ok, that sounds sensible
07:27:40 <sheepfleece> I've been trying to make generic-lenses work but it seems unmanageable. What am I doing wrong? https://paste.debian.net/1147290/
07:29:27 <sheepfleece> Oh, I forgot to derive Generic, oh.
07:39:11 <epic_guy[m]> is this the channel in which we can ask haskell noob doubts?
07:42:50 <enikar> epic_guy[m]: either here, either in #haskell-beginners
07:43:11 <epic_guy[m]> right
07:43:12 <enikar> the both are possible.
07:43:12 * epic_guy[m] sent a long message:  < https://matrix.org/_matrix/media/r0/download/matrix.org/IJNfXUolDwjHZtpUUzvhURgM >
07:43:22 <epic_guy[m]> Pls help here
07:43:32 <epic_guy[m]> it returns some big error
07:44:02 <Rembane> What's the error?
07:44:04 <epic_guy[m]> i just want the value of waxOn to be expected as 1125
07:44:22 <epic_guy[m]> parse error
07:44:35 <epic_guy[m]> should i paste the whole error?
07:45:09 <Rembane> epic_guy[m]: I think I know why. You need to define the uppermost part as either a proper top level definition or put it in the main-function.
07:45:10 <enikar> I think you'd write: waxOn = let … in x * 5
07:46:22 <epic_guy[m]> Thank you...it worked..
07:46:52 <epic_guy[m]> sorry i'm really a noob...
07:49:41 <enikar> nothing is wrong, it's ok.
07:52:13 <aveltras> is there a way to have "appName" used as its content here using the qq or do i have to use sigD ?
07:52:31 <aveltras> https://www.irccloud.com/pastebin/L8gCO2TM/
08:01:17 <frdg> https://pastebin.com/7ZUVBLmj question about the difference between `.` and `$` operators
08:01:59 <nil> frdg: sum2 is ill-typed
08:02:15 <hexagoxel> frdg: getSum . foldMap Sum  is  getSum . (foldMap Sum)  but you want  (getSum . foldMap) Sum
08:02:19 <nil> you're thinking of the equivalence between  a . b $ c  and a $ b $ c
08:02:44 <frdg> ohhhh
08:03:01 <frdg> Ok I understand thanks
08:03:20 <nil> note that the equivalence is only true because the parentheses are in different places:  (a . b) $ c  vs.  a $ (b $ c)
08:03:40 <nil> (if you remove the dollar signs, this is the definition of (.)
08:04:22 <nil> s/vs./=/
08:53:15 * hackage sixel 0.1.0.0 - Sixel library to show images in a terminal emulator  https://hackage.haskell.org/package/sixel-0.1.0.0 (junjihashimoto)
08:53:18 <tomtomgps> hi i'm new to haskell   why doesnt this line work     [x, x <-[1..50], 50 `mod` x == 0]
08:53:42 <tomtomgps> <interactive>:12:7: error:
08:53:45 <tomtomgps>     parse error on input ‘<-’
08:53:45 <Rembane> tomtomgps: Replace the first comma with a pipe and it should work better.
08:53:46 <tomtomgps>     Perhaps this statement should be within a 'do' block?
08:54:02 <xerox_> tomtomgps: the syntax for list comprehensions is [ <expr> | ... ] not [ <expr> , ... ]
08:54:10 <Rembane> > [x | x <- [1..50], 50 `mod` x == 0]
08:54:11 <tomtomgps> ok cool thanks
08:54:12 <lambdabot>  [1,2,5,10,25,50]
08:54:34 <xerox_> the various clauses in the second part are separated by commas
09:08:03 <xerox_> is there a way to make ctrl+y paste in ghci instead of backgrounding it?
09:09:18 <Cale> xerox_: ghci has no special interaction with the clipboard, you probably want to ask that question about your terminal emulator
09:09:35 <xerox_> I was lucky I hit upon: stty dsusp undef, this works around it
09:09:56 <xerox_> it's curious because it's the only repl that doesn't just paste with ctrl+y but suspends
09:11:39 <xerox_> yeah I guess "paste" can mean a lot of things, in particular everywhere like in bash there's an interaction between ctrl+k (kill the rest of the line) and ctrl+y (which will paste such kill) as well as a few other ways to remove part of the line
09:21:01 <lukelau> in TH is there a way to reference a record field for a specific data type when DuplicateRecordFields is enabled?
09:22:40 <justsomeguy> xerox_: Control-y does paste for me. Maybe you have some setting in your terminal emulator that is binding Control-y to send the TSTP signal?
09:23:48 <xerox_> justsomeguy: stty -a | grep dsusp
09:23:55 <xerox_> does it give you dsusp = ^Y ?
09:24:38 <justsomeguy> No, not at all. susp is bound to ^Z.
09:25:21 <xerox_> maybe it's OS dependant, I don't have special bash configs
09:25:36 <justsomeguy> What OS are you on?
09:25:41 <xerox_> mac
09:25:51 <justsomeguy> Aha... macs are weird.
09:28:01 <justsomeguy> I guess it makes sense to add a "stty" to your ~/.bashrc (or ~/.zshrc, if you use zsh).
09:28:12 <justsomeguy> s/"stty"/"stty" command/
09:28:13 <xerox_> sure
09:28:51 <xerox_> I was curious because it's the only repl that has this behavior, maybe because haskeline or what it's called doesn't catch it? I'm not sure
09:30:08 <justsomeguy> Oh, yeah, that is peculiar.
09:30:53 <justsomeguy> Do you launch ghci differently from your regular terminal? Through a desktop, icon, for example?
09:31:49 <xerox_> nope
09:33:19 <justsomeguy> ¯\_(ツ)_/¯
09:33:51 <xerox_> (:
09:39:02 <enikar> in .ghci, I had: PS.installHandler PS.sigTSTP PS.ignore Nothing
09:39:40 <enikar> where PS is System.Posix.Signals, to ignore Ctrl-Z.
09:40:52 <xerox_> ah interesting
09:41:12 <xerox_> what's the rationale for ignoring ctrl+z?
09:44:09 <enikar> I ignore Ctrl-Z, because I use a terminal that launch only ghci. Sometines, I hit Ctrl-Z by oversight, and ghci was freezed.
09:45:20 <xerox_> I see
09:45:44 <xerox_> in my terminals I launch tmux by default but I don't do without bash behind it, for the flexibility
09:46:15 * hackage timeplot 1.0.33 - A tool for visualizing time series from log files.  https://hackage.haskell.org/package/timeplot-1.0.33 (EugeneKirpichov)
09:47:04 <tomjaguarpaw> c
09:48:08 <enikar> I use tmux, as well. But not for terminal for ghci, where I use differents colors which I use for bash.
10:27:10 <sm[m]> pie_ : re not getting anywhere with implementing haskell things - may I suggest building smaller things,  eg tiny cli scripts, repeatedly and with rapid feedback. Things will get much easier soon.
10:28:27 <pie_> suggestion noted
10:28:33 <dsal> My things just keep getting bigger.
10:28:49 <dsal> One thing I found in haskell is that when I think of something ridiculous, I can usually actually do it.
10:29:00 <pie_> haha
10:30:28 <dsal> Though probably my useful (as in, regularly used) tool I've written in haskell is one I've written in a bunch of languages:  https://github.com/dustin/waitforsocket -- I think I've had versions if this in C, ocaml, go, and haskell so far.
10:33:43 <dsal> My current project is an mqtt broker.  I started it a couple weeks ago.  It's actually really far along.  I took a detour to try to come up with a really nice looking config file for it.  Figuring out what a really nice looking config file looks like is kind of hard. heh
10:33:55 <sm[m]> project euler and exercism are also good sources of practice "katas"
10:34:10 <xerox_> what are you using for config files dsal?
10:34:16 <dsal> megaparsec
10:34:32 <dsal> I used dhall in one project.  It's kind of interesting, but has a few downsides.
10:34:45 * hackage flat 0.4 - Principled and efficient bit-oriented binary serialization.  https://hackage.haskell.org/package/flat-0.4 (PasqualinoAssini)
10:35:16 <dsal> This is where I am right now: https://github.com/dustin/mqttd/blob/master/test/test.conf -- it's not great, but I can work with it.
10:35:59 <sm[m]> dsal, toml didn't work ?
10:36:29 <dsal> I don't know toml.  I just started typing things into my config that I wanted and then wrote a parser around it.
10:37:11 <maerwald> weird
10:38:10 <sm[m]> I've been thinking about config file formats too. I'd like to use something standard, but it's not always optimal for usability
10:38:23 <maerwald> ini or toml
10:38:45 <maerwald> if you do something custom, you end up with something like cabal
10:39:21 <maerwald> because it's convenient to just add more syntax etc
10:39:30 <maerwald> convenience is not always your friend
10:39:40 <juri_> json.
10:39:50 <dsal> json is not for humans.
10:39:56 <juri_> all the cool kids are doing it.
10:40:08 <sm[m]> for a given application, the standard config formats aren't always expressive enough
10:40:14 <maerwald> yeah, coc.nvim uses json, doesn't it? and it's awful to configure
10:40:36 <maerwald> sm[m]: cargo does fine with toml :)
10:40:52 <dsal> The megaparsec errors are pretty handy when I'm up late and making typos. https://www.irccloud.com/pastebin/eSy0OfGU/error
10:41:02 <nshepperd> toml seems pretty straightforward
10:41:05 <maerwald> I don't believe people really *need* more expressivity, they just do it because they can and there's no pressure to not do it
10:41:07 <juri_> curaEngine uses either json, command line arguments, or some abomination where you connect() to it, and feed it configuration values.
10:41:12 <xerox_> that's a beautiful error
10:41:35 <maerwald> if toml is too much, ini is still your friend
10:42:07 <maerwald> sm[m]: in fact, darcsden uses ini, doesn't it? I remember adding config file to it ;)
10:43:17 <dsal> ini and toml seem like a tradeoff in quite the opposite direction.  I still have to write a parser over the parser, but I get a format that makes it awkward to express things specific to my needs.
10:43:37 <sm[m]> hledger's .csv.rules format is custom, designed to make describing CSV conversion rules as simple and foolproof as possible. Doing that with toml/ini would make it harder to learn and much more error-prone, I think
10:43:41 <sm[m]> could be maerwald, I don't remember
10:45:33 <maerwald> sm[m]: https://hub.darcs.net/simon/darcsden/browse/src/DarcsDen/Settings/Common.hs
10:45:43 <maerwald> it uses ConfigFile, which is similar to ini
10:47:08 <sm[m]> http://hackage.haskell.org/package/ConfigFile.. right
10:51:05 <dsal> I guess I can understand why one would want a "standard config file" but writing a parser over a parser and trying to fit my model into their model while making sure only and all valid keys are provided and giving users good feedback on errors seems like a big task.
10:51:35 <sm[m]> to put it another way, a custom format can constrain what can be expressed - more expressivity for things we want to express, and none for anything else, making it harder to make bad configs
10:51:57 <dsal> Anyway, I'd be surprised if anyone other than me ever users this software anyway.  I've been burned by "do this standard thing instead of the thing that's working well for you and others will contribute" promise before.  :)
10:53:11 <sm[m]> robust custom parsers aren't a trivial amount of effort though
10:54:09 <dsal> https://github.com/dustin/mqttd/blob/master/src/MQTTD/Config.hs <-- this does all the things I've thought of so far.
10:55:17 <dsal> My config file is ahead of my server currently, though.  Need to actually use some of these new things I added.
10:56:44 <sm[m]> nice and simple dsal. If it's like my parsers, I bet I could find 50 ways to break it right now.. but it might not be like mine..
10:57:02 <sm[m]> and of course for most needs, that level of robustness isn't needed/worthwhiel
10:57:39 <dsal> The worst thing I know how to do with it right now is create some ugly config bits.  Like putting two listeners on one line is supported.
10:58:44 <xerox_> if we don't write parsers in Haskell why even use the language :D
10:58:49 <dsal>  heh
10:59:25 <dsal> There's actually a fancy data structure I need to make for this, but haven't fully figured out what it looks like yet.
11:00:01 <dsal> Right now, publishing is O(n m) for n session with m subscriptions each.  Each session has a list of subscriptions and each published messages just looks through the list to see if any matach.
11:01:11 <dsal> Topics look like `a/b/c` and subscriptions can look like `a/b/c` or `a/+/c` or `+/+/+` or `a/#` or `#` or whatever.  It's fairly constrained, but I've so far punted on doing that efficiently.
11:01:15 * hackage ghc-check 0.4.0.0 - detect mismatches between compile-time and run-time versions of the ghc api  https://hackage.haskell.org/package/ghc-check-0.4.0.0 (PepeIborra)
11:08:54 <xerox_> I was wondering, if you have a String that is an emoji you often end up with the unicode codepoint escaped as the output, e.g. if you print a [(String,Int)], is there a way around it that doesn't require one two write a custom formatted print that does putStr on such strings to get them output as glyphs?
11:18:15 * hackage blake3 0.2 - BLAKE3 hashing algorithm  https://hackage.haskell.org/package/blake3-0.2 (RenzoCarbonara)
11:19:12 <ski> xerox_ : hm, maybe one could make an alternative instance for a wrapper for `String'
11:21:13 <xerox_> by wrapper you mean newtype for example?
11:23:19 <ski> yes
11:25:19 <dsal> `either fail pure =<< thing` is such purity
11:32:33 <xerox_> ski: that was a good suggestion https://i.imgur.com/naoFBgt.png
11:34:42 <ski> @type (either fail pure =<<)
11:34:44 <lambdabot> Monad m => m (Either String b) -> m b
11:34:48 <johnw> dsal: back in Control.Monad.Error days, that was called liftEither
11:35:14 <ski> @type (either fail pure =<<) . runExceptT
11:35:15 <lambdabot> Monad m => ExceptT String m b -> m b
11:35:28 <ski> ok, xerox_
11:35:49 <dsal> xerox_: how do you like those apples?
11:35:54 <xerox_> (:
11:36:33 * ski doesn't
12:13:08 <slack1256> Not really a haskell question. I got a program that uses `req` and stm, but doesn't work correctly when the network interface is chocking. What is the usual way to simulate a chocking network interface?
12:13:46 <slack1256> Currently I am saturating my network with a torrent download but that's just a hack.
12:13:48 <[exa]> slack1256: by `chocking' you mean choking like getting traffic-limited?
12:13:55 <Rembane> slack1256: In which state does it choke? 
12:14:19 <xerox_> on macos there's network link conditioner in the apple dev tools
12:14:20 <[exa]> slack1256: anyway on linux you can use the `tc` framework to simulate egress/ingress traffic limits
12:14:33 <[exa]> same with pf on BSDs
12:14:41 <[exa]> see `man 8 pf` or `man 8 tc`
12:15:08 <slack1256> [exa]: `tc` looks useful!
12:16:04 <[exa]> slack1256: it is a it cryptic but I guess you can read through to something interesting. Notably, for setting the exact amount of traffic for something, google HTB tutorials
12:16:32 <[exa]> they are most explanatory in that way, and you can probably downscale them to classifier problems and/or TBF etc
12:17:02 <slack1256> Rembane: I didn't express correctly, I meant that the downward link was saturated.
12:17:32 <[exa]> slack1256: also, very ugly solution: pipe through SSH tunnel with limited traffic
12:17:50 <Rembane> slack1256: Got it. I had some idea that by looking at the connection in Wireshark you could figure it out, but [exa]'s suggestion was miles better. :)
12:18:10 <Rembane> slack1256: Where it = the state of the connection when things break. 
12:18:47 <[exa]> anyway
12:19:04 <slack1256> [exa]: Yeah, but `tc` seems like a useful tool I could use on other situations. Solving this bug seems like a good oportunity to learn it.
12:19:16 <[exa]> I guess it might be better to solve the actual problem :D what is the trouble the program you're experiencing?
12:20:55 <[exa]> slack1256: the learning curve _is_ steep tho. TC has internally classes with weird 2-part IDs, (qdiscID:classID), you can classify the incoming packets (on an _outgoing_ interface queue) to those, and they bubble up to the "root" qdisc
12:22:17 <[exa]> all those are manipulated through tc class/qdisc, and atop of that you add `tc filter` to send the packets into correct leaf classes
12:31:50 <koz_> Is there some place I can read how I can get something on Stackage?
12:32:15 <dmj`> koz_: https://github.com/commercialhaskell/stackage/blob/master/MAINTAINERS.md
12:33:00 <koz_> dmj`: Thanks!
12:33:10 <dmj`> koz_: np
12:46:50 <koz_> If I have two common stanzas which both declare ghc-options, what happens if I import them both?
12:46:57 <koz_> Do I get union, intersection, an error, something else?
12:49:16 * hackage floskell 0.10.3 - A flexible Haskell source code pretty printer  https://hackage.haskell.org/package/floskell-0.10.3 (ecramer)
13:13:48 <solonarv> koz_: pretty sure they are appended together
13:14:20 <solonarv> (the same is true if you import a common stanza which specifies ghc-options, and then also specify ghc-options in the importing stanza)
13:26:15 * hackage miso-examples 1.5.2.0 - A tasty Haskell front-end framework  https://hackage.haskell.org/package/miso-examples-1.5.2.0 (DavidJohnson)
13:27:15 * hackage miso 1.5.2.0 - A tasty Haskell front-end framework  https://hackage.haskell.org/package/miso-1.5.2.0 (DavidJohnson)
13:29:47 <koz_> solonarv: Ah, OK.
13:30:11 <koz_> Is there any way to see what exactly I get from common stanza imports?
13:30:22 <solonarv> idk
13:30:23 <koz_> (like, -ddump-splices but for common stanzas)
13:31:54 <koz_> Also, how do I make the 'extraneous version range for a dependency on an internal library' thing go away?
13:33:57 <koz_> (it's for tests - I have a dep on the library itself that's being tested)
13:37:24 <koz_> (seems like it's not a fixable thing)
13:41:14 <koz_> solonarv: Yeah, 'append together' seems to be the behaviour, thanks!
13:44:40 <koz_> Also, where can I find the list of boot library versions for each GHC version?
13:48:56 <raehik> Interested in using the formatter brittany in a Stack project but unsure how to run it on all my source files (need to enumerate them all). Any thoughts?
13:49:19 <koz_> raehik: find . -name "*.hs" is a good start.
13:49:38 <koz_> Then use like, xargs.
13:49:40 <koz_> Or something.
13:49:49 <koz_> Or like, -exec.
13:50:37 <raehik> koz_: any chance stack has some commads that will list out the files it finds or sth?
13:51:14 <koz_> raehik: Not to my knowledge. You can either check the modules in the Cabal file, or use the methods I just defined.
13:51:34 <raehik> dang, gotcha. Thanks!
13:53:42 <koz_> find-exec is probbo the way I would go, assuming Brittany has in-place formatting.
13:53:46 <koz_> (I think it probably does)
14:01:00 <roconnor> As I recall GHC has some funky extenstion to let you make type classes with 0 type arguments.  Does this sound familiar to anyone?
14:01:12 <roconnor> or something similar to that?
14:01:13 <koz_> roconnor: Yes, it does.
14:01:25 <koz_> I believe MultiParamTypeClasses enables this?
14:01:41 <koz_> (I am unsure what you want this for though)
14:05:22 <roconnor> I was thinking of using it in a place where I basically only want to ever pass in a single value for a specific data type.
14:05:58 <roconnor> But I also want that value shared between all those places.
14:06:08 <roconnor> so that it doesn't get computed multiple times.
14:06:29 <koz_> roconnor: Yeah, Haskell will probably do this for you anyway.
14:06:34 <roconnor> But actually my value has a polymorphic type, so now I'm thinking what I want to do won't work.
14:06:37 <koz_> Something something laziness, something something immutability.
14:06:55 <koz_> I would not worry about something like this, honestly.
14:07:08 <roconnor> I find that GHC is very reluctant to do Common Subexpression Elimination because it is really scared for wasting memory resources.
14:07:25 <koz_> roconnor: How did you find this out?
14:07:43 <roconnor> Based on chatting on #haskell for the last 20 years.
14:08:05 <roconnor> that said, GHC has changed a lot in the last 20 years, so maybe my thinking is out of date.
14:08:28 <koz_> roconnor: Well, even if it _was_, there's no guarantee it a) affects your code at all, or b) affects it in a way you'd notice.
14:08:52 <koz_> I can't really say one way or the other without a concrete case, honestly.
14:08:58 <dsal> GHC hasn't changed much in the last 20 years.  They figured it all at once, but have been slowly rolling it out so mortals can keep up.
14:09:11 <roconnor> *lol*
14:09:40 <roconnor> Anyhow, upon second thought, my value is polymorphic so what I was originally thinking doesn't work.
14:10:10 <roconnor> polymorphic values are practically functions, and there is very limited value in sharing values that are functions.
14:10:34 <xerox_> basically the idea is to use the fact that C => .. is actually a parameter C_dictionary -> .. to the function to pass that one value around?
14:10:49 <roconnor> xerox_: that's what I was thinking.
14:11:20 <roconnor> I mean, I only have a vague idea about this trick.  I've never used it before and I'm not sure my thinking is sound here.
14:11:54 <xerox_> it's interesting
14:11:55 <dsal> I just wrote some code and I know what it does, but I don't quite understand it.  I should make tea.
14:12:41 <koz_> dsal: That is a brilliant idea.
14:12:56 <MarcelineVQ> Yes.
14:13:44 <dsal> `runModified = modifyAuthorizer . applyListenerOptions . view listenerOpts <*> runListener`   <-- uses `local` to apply an overridden environment based on options found within a listener, and then runs the listener.
14:13:52 <johnw> dsal: by far the more common error is to write some code, and then think we understand it. :)
14:13:57 <dsal> haha
14:19:45 <koz_> If I'm missing link destinations for some identifiers when I do 'cabal new-haddock' (said destinations are libraries on Hackage), what flags do I have to feed to Cabal so it can find them?
14:24:21 <koz_> Found it, never mind.
14:25:15 * hackage cabal-appimage 0.2.0 - Cabal support for creating AppImage applications  https://hackage.haskell.org/package/cabal-appimage-0.2.0 (GabrieleSales)
14:33:17 <solonarv> roconnor: you don't need a typeclass to get that sort of sharing. top-level bindings already work that way
14:33:43 <solonarv> (or to be clear: you don't need a *zero-arity* typeclass)
14:46:45 * hackage flat 0.4.2 - Principled and efficient bit-oriented binary serialization.  https://hackage.haskell.org/package/flat-0.4.2 (PasqualinoAssini)
14:55:28 <ski> roconnor : is it constrained polymorphic ?
15:11:59 <gentauro> what names are `valid` for Haskell package names (.cabal)?
15:12:10 <gentauro> for example, `foo-utils` works
15:12:25 <gentauro> but `foo++` doesn't
15:13:03 <gentauro> where can I read more about this?
15:13:29 <xerox_> https://cabal.readthedocs.io/en/latest/cabal-package.html#package-properties
15:16:58 <gentauro> xerox_: is this only related to `.cabal`?
15:17:49 <xerox_> gentauro: packages are a Cabal concept
15:18:11 <gentauro> xerox_: fair enough
15:19:58 <gentauro> xerox_: so it's not even possible to make a binary file named: `foo++` :)
15:23:28 <xerox_> gentauro: executable names don't seem to be constrained by the same regexp at a cursory glance https://cabal.readthedocs.io/en/latest/cabal-package.html#executables
15:27:18 <gentauro> xerox_: `Unable to parse cabal file from package` -> `154:1: Invalid name [SecArgName (Position 154 12) "foo",SecArgOther (Position 154 15) "++"]` ;)
15:27:44 <gentauro> xerox_: I have a `build.bash` file, so I might just rename the files after build (if it succed)
15:27:44 * hackage xor 0.0.1.0 - Efficient XOR masking  https://hackage.haskell.org/package/xor-0.0.1.0 (HerbertValerioRiedel)
15:30:26 <koz_> If I have a newtype around something with a Generic instance, and I wanna derive a type class via the Generic instance of the thing I am wrapping, how would I do this?
15:30:29 <koz_> Like, deriving newtype?
15:30:31 <koz_> Deriving via?
15:30:33 <koz_> Some other thing?
15:33:49 <xerox_> gentauro: yeah I think it's just alphanum divided by '-' again perusing the source
15:46:59 <dsal> @hoogle a -> b -> Either c d -> Either a b
15:47:00 <lambdabot> No results found
15:47:20 <dsal> I'm surprised something like that isn't on the shelf.   I used  `bimap (const a) (const b) e`
15:47:36 <dsal> I guess that's not that hard.
15:47:53 <gentauro> xerox_: `.bash` script solves the problem ;)
15:48:00 <gentauro> thx for the help :)
15:48:45 * hackage both 0.1.1.1 - Like Maybe, but with a different Monoid instance.  https://hackage.haskell.org/package/both-0.1.1.1 (barrucadu)
15:53:14 <rotaerk> dsal, how would that be useful?
15:54:00 <rotaerk> hmm nm
15:54:20 <rotaerk> it does seem like something that wouldn't get much use though
15:57:51 <dmj`> koz_: you should be able to derive Generic using stock (stock is default if omitted, no need for DerivingStrategies)
15:58:24 <koz_> dmj`: Yeah, I know. I don't really want Generic - I want NFData via the underlying thing's Generic instance.
16:00:38 <dmj`> koz_: then you should just be able to do deriving newtype NFData
16:00:57 <dmj`> it will inherit NFData instance, regardless if it came from generic deriving or not
16:01:03 <koz_> dmj`: Ah, OK.
16:01:06 <koz_> Will try.
16:05:00 <heatsink> gentauro: https://cabal.readthedocs.io/en/latest/developing-packages.html#package-names-and-versions
16:05:08 <heatsink> Oh, nevermind
16:05:16 <heatsink> I wasn't scrolled to the bottom of the chat window
16:11:27 <dsal> rotaerk: It's kind of like if.
16:12:06 <dsal> It fit pretty well into my protocol manipulation, but maybe it's not generally useful enough to give a name.
16:52:16 <dmj`> koz_: did it work?
16:54:07 <koz_> dmj`: Yep!
16:57:57 <frdg> Is traversable mostly used for flipping structure? I've seen around here a few times people saying that traversable is extremely useful.
16:59:47 <Axman6> it's used for... traversing structures. Imagine I have a tree of URLs and I want a tree of the pages those URLs point to. obviously I need IO for that, so we'd expect out operation to look like Tree URL -> IO (Tree Page), right?
16:59:57 <dsal> :t traverse
16:59:59 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
17:00:16 <dsal> :t mapM
17:00:17 <lambdabot> (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
17:00:53 <Axman6> well if we have a function fetch :: URL -> IO Page, we can use Traverse to apply it to all the URLS: traverse fetch :: Traversable t => t URL -> IO (t Page). now we can take out Tree URL and get back a Treee Page 
17:01:35 <Axman6> so traverse fetc, in thos case has type Tree URL -> IO (Tree Page)
17:01:47 <frdg> Axman6: I see. Would this be much more difficult with out Traversable?
17:02:13 <dsal> traverse is approximately the same as mapM.  It just works in more contexts.
17:03:27 <Axman6> well, you'd have to recurse over the tree manually without it, Traverseable refactors the idea performing some action on every a in some structure, that only needs to be written once, and now you can write code which can handle any structure which can be traversed
17:04:02 <Axman6> the function fetchAll = traverse fetch is generally useful for a lot of structures, you don't need to care about wehat strructure your user has, only that it can be traversed
17:05:02 <frdg> Axman6: Ok I understand! 
17:05:04 <frdg> thanks you
17:05:15 <dsal> I also have `justM = traverse_` which is pretty handy.
17:05:26 <dsal> `justM :: Monad m => (a -> m ()) -> Maybe a -> m ()`
17:07:20 <dsal> It's sort of like a combination of `when` and `fmap`
17:07:23 <dsal> :t when
17:07:24 <lambdabot> Applicative f => Bool -> f () -> f ()
17:11:06 <dmj`> koz_: cool
18:08:24 <durandal1> HXT unpickling is making my head explode. Dark magic. Lots of dark magic.
18:11:01 <mathewma> hello
18:11:47 <mathewma> Is it possible to debug/print inside case of?
18:12:26 <wavemode> well, you could trace wherever you want with Debug.Trace
18:12:46 <wavemode> https://hackage.haskell.org/package/base-4.14.0.0/docs/Debug-Trace.html
18:13:03 <Axman6> case foo of x | traceShow x False -> undefined; Just x -> ...; Noithing -> ...;
18:14:07 <monochrom> That's a useful trick.
18:15:18 <liiae> what's the right to turn a number string to a number? like "123" to 123
18:15:45 <Axman6> ther'es several, the easiest is read
18:15:52 <Axman6> > read "123" :: Int
18:15:54 <lambdabot>  123
18:16:24 <wavemode> you should `import Text.Read (readMaybe)` though, which is significantly safer
18:16:28 <liiae> Axman6: and others?
18:16:42 <Axman6> he various parsing libraries
18:16:44 <Axman6> the*
18:20:05 <mathewma> wavemode thanks for the link but I already saw that, as it is my second week of fighting with a bug and learning how to debug; Thanks Axman6, it works, that's what I was searching for!!
18:21:33 <liiae> Axman6: aha, when the number is large, this is not proper
18:22:10 <Axman6> > read "189759867239867498764589723459872368762398547" :: Integer
18:22:12 <lambdabot>  189759867239867498764589723459872368762398547
18:22:17 <enikar> liiae: you'd better convert to integer in this case.
18:22:56 <liiae> Axman6: enikar yeah, Integer is ok
18:23:23 <mathewma> liiae int is a type of variable, you can read more here if you are interested (http://www.learnyouahaskell.com/types-and-typeclasses)
18:23:37 <liiae> it's too easy for 4kyu hard on codewars
18:26:24 <liiae> https://www.codewars.com/kata/55911ef14065454c75000062/haskell
18:26:41 <liiae> multiply xs ys = show $ (read xs::Integer)*(read ys::Integer)
18:34:07 <mathewma> When you guys started with Haskell did you struggle more than with other languages? Because I was programming professionally in OOP languages, and previously when I was jumping into new OOP language it was pretty smooth, but now I started a new job in which I had to jump in this big Haskell project, and I struggle a lot with it.
18:35:57 <newsham> the distance between most imperative languages and most OO languages is pretty close. the distance from those to functional languages is a bit further, and the distance from pure languages is a little further.  its going to be a little harder to pick up
18:36:15 <newsham> sort of like how learning latin langauges is easier for english speakers than learning mandarin
18:36:24 <sm[m]> mathewma: yes, that is normal
18:36:30 <wavemode> haskell made absolutely zero sense to me when I started, even though I'd been programming for years
18:36:46 <Axman6> this is a good thing
18:36:52 <newsham> expand your mind :)
18:37:19 <jackdk> Yep, absolutely. Switching back to OO langs has also been pretty hard :D
18:37:36 <DigitalKiwi> allegedly as a first language it's a lot easier
18:37:54 <sm[m]> mathewma: I’m going to jump in with the first learning recommendation here:
18:38:02 <sm[m]> @where htac
18:38:03 <lambdabot> "Haskell Tutorial and Cookbook" by Mark Watson in 2017-09-04 at <https://leanpub.com/haskell-cookbook>
18:38:12 <newsham> when you're done you can start in on a dependantly typed language :)
18:39:53 <mathewma> Thank you guys for your support, It feels better to know that it is normal.  
18:40:57 <EvanR> could it be that your first programming language is always the easiest
18:41:18 <heatsink> You just forget how hard your first programming language was
18:41:21 <EvanR> before you realize how much chaos there is globally
18:41:24 <mathewma> Well my first was the hardest, because I failed at it
18:41:41 <mathewma> and I started 2-3 years later with different one
18:41:42 <mathewma> haha
18:42:50 <liiae> mathewma: there's a book for beginner, learn youself a haskell for good
18:42:53 <liiae> IIRC
18:43:01 <mathewma> Thanks for the book recommendations I will look into that. But I found out this Haskell Programming book by Christopher Allen and Julie Moronuki
18:43:07 <Axman6> mathewma: the reason why other languages were so easy to jump into those other languages ius a) they are mostly using familliar constructs, but also b) because they limit what you can express much more than Haskell does. There are very few limits on how much abstraction you can have in Haskell, but most lkanguages can't even let you express Functor, which is a trivial abstraction. <F><B> fmap<F,A,B>(Function<A,B>, <F><A>) is just not a though
18:43:07 <Axman6> t you can think in most languages
18:43:44 <Axman6> uh,tgot sidetracked at the beginning of that 
18:44:16 <mathewma> Axman6 yea, the problem is that I already have task to do at work in this project, and the tutorial projects that I was trying to learn on web was very basic/simple
18:44:45 <mathewma> And the problem in learning haskell, I think the biggest one 
18:44:46 <liiae> mathewma: everything starts simply
18:45:20 <mathewma> was because of the size of the community, as there were not enough stackoverflow questions
18:45:37 <mathewma> when I was starting more popular languages there was almost question on everything
18:45:46 <mathewma> and in the way I would search it
18:45:55 <liiae> you just need the proper "keyword" 
18:46:01 <mathewma> Yea, I guess
18:46:04 <EvanR> IRC is the stackoverflow of haskell
18:46:20 <liiae> something in haskell are not common in the others
18:47:10 <mathewma> Yeah! I am really glad I joined here, like this debugging keyword that I got few minutes ago
18:47:20 <mathewma> I was trying to do that 2-3 days 
18:47:23 <heatsink> #haskell was super helpful when I was learning
18:47:56 <liiae> yes, I couldn't do it without here too
18:48:26 <liiae> there're too many things need to be understood
18:49:06 <liiae> It takes me a lot of time to understand concepts
18:58:45 * hackage tasty-mgolden 0.0.1 - Golden testing provider for tasty with muti-line diff output  https://hackage.haskell.org/package/tasty-mgolden-0.0.1 (mbj)
19:07:34 <remexre> hm, is there any reason why (in fused-effects) State isn't split up into read + write in the same way Error is split into throw + catch?
19:12:22 <EvanR> heh, you want to make sure this code can do nothing but write the state
19:12:54 <EvanR> it can't even make a submodification without reading first
19:17:15 * hackage reflex-dom-retractable 0.1.3.0 - Routing and retractable back button for reflex-dom  https://hackage.haskell.org/package/reflex-dom-retractable-0.1.3.0 (NCrashed)
19:21:15 * hackage vulkan 3.3.1 - Bindings to the Vulkan graphics API.  https://hackage.haskell.org/package/vulkan-3.3.1 (jophish)
19:22:15 * hackage VulkanMemoryAllocator 0.3.1 - Bindings to the VulkanMemoryAllocator library  https://hackage.haskell.org/package/VulkanMemoryAllocator-0.3.1 (jophish)
19:26:15 * hackage equational-reasoning 0.6.0.3 - Proof assistant for Haskell using DataKinds & PolyKinds  https://hackage.haskell.org/package/equational-reasoning-0.6.0.3 (HiromiIshii)
19:33:14 * hackage text-utils 0.1.1.0 - Various text utilities  https://hackage.haskell.org/package/text-utils-0.1.1.0 (AlexanderThiemann)
19:35:04 <remexre> EvanR: more like, I want to weaken a State effect to a Reader one, but I can't just write (ReaderT s m a -> StateT s m a)
19:36:29 <remexre> I guess I can just use runReader where it's useful, but /shrug
19:50:08 <koz_> When did the 'only on LLVM' warning appear on WordNXM# types in GHC.Exts?
19:50:24 <koz_> (and what happens if you try and use them when you're not generating with LLVM?)
19:59:50 <liiae> how to write a function like `returnLists n = []`
20:00:02 <liiae> returnLists 1 = [[]]
20:00:09 <liiae> returnLists 2 = [[] []]
20:00:17 <liiae> returnLists 3 = [[] [] []]
20:04:27 <ski> liiae : recursion ?
20:04:40 <koz_> Also, is this homework?
20:06:03 <liiae> ski: yeah
20:06:20 <liiae> returnLists n alist = if  n == 0 then alist  else  returnLists (n-1) []:alist
20:06:27 <liiae> returnLists 3 []
20:06:49 <Feldmaus> You base case is wrong
20:06:52 <Feldmaus> *Your
20:07:09 <Feldmaus> Err, never mind
20:08:01 <Feldmaus> liiae: Missing parentheses around []:alist
20:08:20 <Feldmaus> It's parsed as (returnLists (n-1) []) : alist
20:09:04 <liiae> Feldmaus: returnLists n alist = if n == 0 then alist  else  returnLists (n-1) ([]:alist)?
20:09:26 <Feldmaus> Yes
20:09:42 <sleblanc> liiae, how is this just not returnLists n = replicate n [] ?
20:09:58 <Feldmaus> > let returnLists n alist = if n == 0 then alist else returnLists (n-1) ([]:alist) in returnLists 3 []
20:10:01 <lambdabot>  [[],[],[]]
20:10:35 <liiae> sleblanc: right
20:10:52 <sleblanc> > let mrl = (flip replicate) []
20:10:54 <lambdabot>  <no location info>: error:
20:10:54 <lambdabot>      not an expression: ‘let mrl = (flip replicate) []’
20:12:51 <carl_> @src break
20:12:51 <lambdabot> break p = span (not . p)
20:12:59 <ski> sleblanc : it's clearly an exercise
20:13:24 <ski> liiae : your function takes two parameters, not one
20:14:23 <carl_> my client can't display full response from lambdabot
20:14:32 <ski> how come ?
20:14:44 <liiae> ski: it's just one piece of another program, parameters are not strict
20:15:17 <carl_> not only ones from the bot
20:15:24 <Xnuk> :i Monad
20:15:29 <carl_> It's HexChat
20:15:33 <ski> liiae : if you want to implement it via an extra accumulator parameter, i'd suggest defining a "wrapper" function that wraps this worker/helper, initializing the accumulator
20:15:59 <ski> liiae : usually, the worker would be defined as a local function to the wrapper, so that other code can't see it
20:16:41 <ski> i don't recall having a problem with that, when i used that, carl_ .. although that was years ago
20:16:46 <carl_> maybe i'd better to switch to irssi
20:17:15 <Xnuk> try weechat instead of irssi
20:17:31 <ski> liiae : although .. i'd actually suggest you don't introduce an accumulator at all, in this case
20:18:50 <carl_> ok, thanks, Originally I want to install lambdabot locally and use it in ghci, but failed beacuse of i can't install djinn properlly by stack. so this is the first time that I use IR....
20:19:40 <ski> IRC ?
20:19:41 <liiae> ski: actually the whole case is this https://www.codewars.com/kata/58c5577d61aefcf3ff000081/train/haskell
20:19:57 <carl_> IRC, yeah
20:20:13 <ski> welcome to #haskell, and IRC, then :)
20:20:51 <liiae> ski: I'd like to create a list that contain several list in it, and put ['a', 'b', 'c
20:20:58 <ski> if you'd like to try out lambdabot commands, but don't feel the need to show the interchange to the channel, you can also privately message lambdabot
20:21:04 <liiae> '] to [[], [], []]
20:21:14 <ski> hm, liiae, that page displays as almost blank, to me
20:21:41 <Xnuk> question: is the only difference of Monad and Applicative that there's no equivalent of `join :: Applicative f => f (f a) -> f a` ?
20:21:49 <ski> liiae : sounds like you could do that with a simple list comprehension
20:22:16 <ski> (if i understood correctly what you wanted to do)
20:22:21 <liiae> ski: https://www.codewars.com/kata/58c5577d61aefcf3ff000081
20:22:27 <ski> Xnuk : basically, yes
20:22:30 <carl_> It seems that I can get some help here. Honestly I think the resource about haskell from google is rare and outdated for a lot, compared with other languages. It often takes me a lot time. 
20:23:08 <liiae> ski: actually I don't like list comprehension, sometime it's hard to understand what it's doing
20:23:21 <ski> liiae : you could also use `map'
20:23:36 <liiae> and yes, list compreheion is really elegent
20:23:48 <ski> carl_ : beginner and newbie questions are welcome here
20:24:44 * ski sees various stats, but no code, or problem description
20:25:10 <liiae> ski: yeah, map, but this map need two lists
20:25:16 <liiae> like map f list1 list2
20:25:19 <liiae> not map f list1
20:25:20 <ski> liiae : did you mean that, given  ['a','b','c']  you'd like your function to output  [[],[],[]]  ?
20:25:38 <ski> liiae : or did you mean that you wanted to "add" the former list of elements to the latter list of lists, somehow ?
20:26:17 <liiae> ['a','b','c','d','e','f'] to "afbecf"
20:26:30 <ski> oh .. the former is the same as the latter
20:26:35 <carl_> ski: haha, thinks a lot, I will try to solve it myself first, ask only the ones really bothering me
20:26:45 <ski> (assuming those were typos in the latter)
20:26:52 <ski> > ['a','b','c','d','e','f']
20:26:53 <lambdabot>  "abcdef"
20:26:57 <ski> those two are the same thing
20:27:05 <ski> the latter is just syntactic sugar for the former
20:27:43 <liiae> yes, "abcdef" to "afbecf" it the 'rail fence' number is 3
20:28:31 <liiae> https://www.codewars.com/kata/58c5577d61aefcf3ff000081
20:28:40 <liiae> rail fence cipher 
20:29:04 <ski> <mathewma> And the problem in learning haskell, I think the biggest one  <mathewma> was because of the size of the community, as there were not enough stackoverflow questions  <mathewma> when I was starting more popular languages there was almost question on everything  <mathewma> and in the way I would search it  <liiae> you just need the proper "keyword"  <mathewma> Yea, I guess  <EvanR> IRC is the stackoverflow of haskell
20:29:13 <ski> <liiae> something in haskell are not common in the others  <mathewma> Yeah! I am really glad I joined here, like this debugging keyword that I got few minutes ago  <mathewma> I was trying to do that 2-3 days  <heatsink> #haskell was super helpful when I was learning  <liiae> yes, I couldn't do it without here too  <liiae> there're too many things need to be understood  <liiae> It takes me a lot of time to understand concepts
20:29:58 <ski> carl_ : ^ that's some conversation in here from about three quarters of an hour ago, that's a bit relevant to what you were saying
20:30:26 <ski> oh, okay, liiae
20:32:27 <carl_> OK, I will try to understand them
20:32:36 <liiae> ski: there must be a function that can do `fmap f list1 list2` not just `fmap f list`, I forget that function's name
20:32:43 <ski> @type zip
20:32:44 <lambdabot> [a] -> [b] -> [(a, b)]
20:32:45 <ski> @type zipWith
20:32:46 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
20:33:08 <ski> > zip "hello" [0 ..]
20:33:11 <lambdabot>  [('h',0),('e',1),('l',2),('l',3),('o',4)]
20:33:13 <liiae> fmap (+) [1,2] [3,4]
20:33:34 <wavemode> what do you want that to return
20:33:35 <ski> write `> ' to query lambdabot to evaluate an expression
20:33:40 <Xnuk> > zipWith (+) [1,2] [3,4]
20:33:42 <lambdabot>  [4,6]
20:34:20 <liiae> ski: aha, zip is good way to tag the elements, so I just need to care about the number sequence, good one
20:34:37 <liiae> Xnuk: yeah
20:35:09 <ski> > zipWith (:) "ABCD" ["e","fg","hij","klmn"]
20:35:11 <lambdabot>  ["Ae","Bfg","Chij","Dklmn"]
20:35:40 <liiae> put "abcdefg" to ["af", "be", "cf"]
20:36:05 <ski> i don't understand what you mean
20:37:09 <liiae> I'm talking about this one https://www.codewars.com/kata/58c5577d61aefcf3ff000081
20:37:31 <ski> * ski sees various stats, but no code, or problem description
20:37:32 <liiae>  "WEAREDISCOVEREDFLEEATONCE" to WECRLTEERDSOEEFEAOCAIVDEN
20:40:52 <carl1> >((-)4) 5
20:40:57 <fog> how do I make a Big Integer, twice the size of Integer?
20:41:07 <Xnuk> > ((-)4) 5
20:41:09 <lambdabot>  -1
20:41:28 <fog> with twice the max size of*
20:42:05 <fog> or, like, that it would use twice as many bits
20:42:18 <fog> so probably much bigger max size...
20:42:25 <Feldmaus> Integers have no max size
20:42:28 <Xnuk> fog: `Integer` has no maximum size
20:42:39 <fog> it will just take all the bits?
20:42:39 <carl1> why ((-4)) 5 equal -1 not 1. I thought it equals "(-) 5 4" instead of (-) 4 5
20:43:15 * hackage rank2classes 1.4.0.1 - standard type constructor class hierarchy, only with methods of rank 2 types  https://hackage.haskell.org/package/rank2classes-1.4.0.1 (MarioBlazevic)
20:43:22 <carl1> typo, ((-)4) 5
20:43:39 <fog> so howver you make a double lengthed word encoding Ints, Integer does does this automatically to arbitrary lengthed words?
20:43:55 <fog> does it do it in chunks in powers of 2 length
20:44:03 <fog> like, Word8, Word16 etc
20:44:17 <Feldmaus> carl1: ((-) 4) == \x -> (-) 4 x == \x -> 4 - x
20:45:09 <fog> like, if i did getRandomR to return an integer from a range, I wouldnt have a max value to supply to the range?
20:45:52 <fog> and if I just pick some random power of 2 for my upper bound, how do I make sure some of the Integers dont use more storage?
20:46:28 <Feldmaus> > getRandomR (0, 100^100)
20:46:30 <lambdabot>  error:
20:46:30 <lambdabot>      Variable not in scope: getRandomR :: (Integer, Integer) -> t
20:46:32 <fog> like, if its going to double the word length its stored as beyond some value, then I should make sure I dont make the upper range above that
20:46:36 <koz_> fog: If you're using the GMP back-end, then it divides bigints into 'limbs' of 64 bits each.
20:46:45 <Feldmaus> > randomR (0, 100^100 :: Integer)
20:46:47 <lambdabot>  error:
20:46:47 <lambdabot>      • No instance for (Typeable g0)
20:46:47 <lambdabot>          arising from a use of ‘show_M16680573550800360573392’
20:47:10 <fog> % > getRandomR (0, 2^(2^(2^2)))
20:47:11 <yahb> fog: ; <interactive>:6:1: error: parse error on input `>'
20:47:15 <fog> % getRandomR (0, 2^(2^(2^2)))
20:47:15 <yahb> fog: ; <interactive>:7:1: error: Variable not in scope: getRandomR :: (a0, b0) -> t
20:47:27 <fog> % randomRIO (0, 2^(2^(2^2)))
20:47:27 <yahb> fog: 35058
20:47:32 <wavemode> random for Integer uses the same range as for Int
20:48:01 <fog> koz: I'm not sure what is the GMP backend
20:48:17 <koz_> The thing GHC uses for its Integer implementation.
20:48:24 <koz_> There's integer-simple and GMP.
20:48:29 <Feldmaus> So you can't have huuuge random numbers?
20:48:52 <fog> I saw data.discrimination has a function for chunking integers into words
20:49:10 <Xnuk> :t randomRIO
20:49:11 <lambdabot> Random a => (a, a) -> IO a
20:49:23 <fog> so i could basically generate a bunch of random numbers by just generating an Integer with a large max bound
20:49:56 <fog> not sure if that would be particularly effecient though
20:50:05 <koz_> Yeah, I don't think it would either.
20:50:53 <liiae> what is Hurry Coward Isomorphism?
20:50:58 <wavemode> I doubt it would be a good random distribution
20:51:04 <koz_> liiae: A joke. 
20:51:07 <fog> so i just calculate how big each extra 64 bit "limb" would allow the Integer to be
20:51:21 <koz_> fog: What are you trying to do exactly?
20:51:33 <liiae> koz_: haha
20:51:53 <fog> idk, i just was thinking about the donald knuth RNG with Bigints for prime mod
20:52:03 <fog> and i wondered how haskell does bigints
20:52:08 <koz_> fog: The answer is '
20:52:13 <koz_> calling out to another implementation'.
20:52:58 <fog> ok...
20:53:47 <fog> it was for some stochastic zeroth order optimisation thing
20:54:31 <fog> was thinking maybe krylov subspace projection or pseudo-markov monte carlo 
20:55:05 <fog> like, in a really high dimensional space, you would need way too many interpolation points to get the graidient
20:55:36 <fog> so you just get some kind of partial eigenbasis from however many samples you have in a buffer as you step through the space
20:55:45 <fog> and it gives you like a kind of partial gradient
20:56:24 <fog> all the approaches I see around use backprop or automatic differentiation, but they are way too costly
20:56:58 <fog> but pure stochastic updates with no gradient information are cheap but require online addpative hyperparameter tuning
20:57:11 <carl1> (6/)3 = 3 while (/6)3=0.5 , I thought it's the same with (4(-)) and ((-)4), it's not, (4(-)) is illegal, and ((-)4) is curry of (-). But (-4) is a negative number not like (/4), is there a way to use it in the same way as (/6)?
20:58:16 <fog> could be similar to simulated annealing using coarse grained surrogates or space mapping towers
20:58:51 <fog> g2g
20:59:42 <Xnuk> carl1: try `subtract` instead
20:59:55 <Xnuk> > (subtract 4) 5
20:59:57 <lambdabot>  1
21:01:08 <carl1> Xnuk: yes, It did work for me. Thanks
21:01:47 <wavemode> > (4-) 5
21:01:49 <lambdabot>  -1
21:02:27 <wavemode> > ((-)4) 5
21:02:29 <lambdabot>  -1
21:09:02 <int-e> > (-4+) 5
21:09:04 <lambdabot>  1
21:09:56 <int-e> Hmm, I never figured out whether ghc is correct in accepting that.
21:10:31 <wavemode> well, it's just ((-4) +)
21:11:16 <int-e> > (+ -4) 5
21:11:18 <lambdabot>  error:
21:11:18 <lambdabot>      The operator ‘+’ [infixl 6] of a section
21:11:18 <lambdabot>          must have lower precedence than that of the operand,
21:12:42 <wavemode> yeah, lexing is hard :p
21:12:57 <int-e> Okay, checking the syntax of expressions, yes that is correct.
21:13:26 <int-e> wavemode: It's not about lexing, it's about how exactly the production for negation is embedded into the expression grammar.
21:14:28 <int-e> Hmm, why is https://www.haskell.org/onlinereport/ the 1998 version?
21:15:22 <int-e> But regardless, that part of https://www.haskell.org/onlinereport/exps.html hasn't changed.
21:17:15 * hackage conferer-source-dhall 0.4.0.0 - Configuration for reading dhall files  https://hackage.haskell.org/package/conferer-source-dhall-0.4.0.0 (ludat)
21:18:15 * hackage conferer-snap 0.4.0.0, conferer-hspec 0.4.0.0, conferer-warp 0.4.0.0, conferer-hedis 0.4.0.0, conferer 0.4.0.0, conferer-source-json 0.4.0.0, conferer-source-yaml 0.4.0.0 (ludat)
22:00:15 * hackage isbn 1.0.0.0 - ISBN Validation and Manipulation  https://hackage.haskell.org/package/isbn-1.0.0.0 (charukiewicz)
22:27:19 <liiae> how to create an infinite number sequence like 3 2 1 2 3 2 1 2 3 ... ?
22:27:30 <fog71>  think I found the thing i was implementing discussed here; https://papers.nips.cc/paper/8941-zo-adamm-zeroth-order-adaptive-momentum-method-for-black-box-optimization.pdf
22:28:12 <dsal> > cycle [3,2,1] -- liiae 
22:28:14 <lambdabot>  [3,2,1,3,2,1,3,2,1,3,2,1,3,2,1,3,2,1,3,2,1,3,2,1,3,2,1,3,2,1,3,2,1,3,2,1,3,2...
22:28:24 <dsal> Or whatever
22:28:26 <fog71> liiae: what rule are you using to generate that sequence?
22:28:38 <liiae> dsal: it's not like that
22:28:42 <dsal> > cycle [3,2,1,2] 
22:28:44 <lambdabot>  [3,2,1,2,3,2,1,2,3,2,1,2,3,2,1,2,3,2,1,2,3,2,1,2,3,2,1,2,3,2,1,2,3,2,1,2,3,2...
22:28:46 <dsal> I don't know.  What's it like?
22:29:01 <liiae> fog71: https://www.codewars.com/kata/58c5577d61aefcf3ff000081
22:29:11 <liiae> fog71: Rail Fence Cipher: Encoding and Decoding
22:29:14 <fog71> are the previous values used to determine the next?
22:29:26 <liiae> I found that it's very look like the number sequence
22:29:58 <liiae> you see, 123456789 if the rails number is 3, then it's 159246837
22:30:14 <liiae> and all 1 5 9 are in 3 position
22:30:31 <liiae> 2 4 6 9 are in 2 position
22:30:38 <liiae> 3 7 are in 1 position
22:31:02 <liiae> so this 1 2 3 4 5 6 7 8 9, tag it with 3 2 1 2 3 2 1...
22:31:10 <fog71> ok so i would start with the cycle of length 4 dsal suggested, and zip this with the input string, and then group by the int label 
22:31:18 <fog71> :t zip
22:31:19 <lambdabot> [a] -> [b] -> [(a, b)]
22:31:22 <fog71> :t group
22:31:23 <lambdabot> Eq a => [a] -> [[a]]
22:31:24 <liiae> then just get all the 3 position, then 2 position, then 1 position
22:31:29 <fog71> :t groupBy
22:31:30 <lambdabot> (a -> a -> Bool) -> [a] -> [[a]]
22:31:47 <fog71> :t groupOn
22:31:48 <lambdabot> error:
22:31:49 <lambdabot>     • Variable not in scope: groupOn
22:31:49 <lambdabot>     • Perhaps you meant one of these:
22:31:52 <fog71> hmm
22:32:19 <fog71> ok, well you can use (\ a b -> compare (fst a) (fst b))
22:32:25 <fog71> :t compare
22:32:27 <lambdabot> Ord a => a -> a -> Ordering
22:32:45 <Axman6> :t comparing
22:32:46 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
22:32:54 <Axman6> :t comparing fst
22:32:55 <lambdabot> Ord a => (a, b) -> (a, b) -> Ordering
22:33:02 <fog71> oh its supposed to be a bool its not sorting its grouping so it is an equality
22:33:17 <Axman6> :t (==) `on` fst
22:33:19 <lambdabot> Eq a => (a, b) -> (a, b) -> Bool
22:34:15 <fog71> :t groupBy ((==) `on` fst)
22:34:16 <lambdabot> Eq a => [(a, b)] -> [[(a, b)]]
22:34:49 <fog71> :t groupBy ((==) `on` fst) . zip (cycle [3,2,1,2])
22:34:51 <lambdabot> (Eq a, Num a) => [b] -> [[(a, b)]]
22:35:14 <fog71> > (map snd . groupBy ((==) `on` fst) . zip (cycle [3,2,1,2])) "hello"
22:35:16 <lambdabot>  error:
22:35:16 <lambdabot>      • Couldn't match type ‘[(Integer, Char)]’ with ‘(a0, b)’
22:35:16 <lambdabot>        Expected type: [Char] -> [(a0, b)]
22:35:36 <fog71> oh dear...
22:36:32 <liiae> more general, how to get a function, that f n = n..1..n ?
22:36:43 <liiae> f 3 = 3 2 1 2 3 2 1 2 3
22:36:50 <liiae> f 4 = 4 3 2 1 2 3 4 3 2 1 
22:36:58 <liiae> f 5 = 5 4 3 2 1 2 3 4 5
22:37:44 <Axman6> take note that groupBy doesn't work how you expect
22:37:52 <dsal> > let nin x = let l1 = [x, succ x ..] in cycle (l1 <> reverse l1) in    nin 5
22:37:54 <lambdabot>  [5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31...
22:37:57 <Axman6> > group "aaabbbaaacbc"
22:37:58 <dsal> Heh.  oops
22:37:58 <lambdabot>  ["aaa","bbb","aaa","c","b","c"]
22:38:02 <dsal> > let nin x = let l1 = [x, pred x ..] in cycle (l1 <> reverse l1) in    nin 5
22:38:03 <fog71> yeah
22:38:04 <lambdabot>  [5,4,3,2,1,0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,...
22:38:05 <fog71> % ( groupBy ((==) `on` fst) . zip (cycle [3,2,1,2])) "hello"
22:38:05 <yahb> fog71: [[(3,'h')],[(2,'e')],[(1,'l')],[(2,'l')],[(3,'o')]]
22:38:10 <dsal> > let nin x = let l1 = [x, pred x .. 1] in cycle (l1 <> reverse l1) in    nin 5
22:38:12 <lambdabot>  [5,4,3,2,1,1,2,3,4,5,5,4,3,2,1,1,2,3,4,5,5,4,3,2,1,1,2,3,4,5,5,4,3,2,1,1,2,3...
22:38:14 <Axman6> sort is usually a good idea
22:38:17 <fog71> its not grouping on eq fst at all
22:38:19 <dsal> Hmm...  Too many ones.
22:38:29 <dsal> > let nin x = let l1 = [x, pred x .. 1] in cycle (l1 <> (tail . reverse) l1) in    nin 5
22:38:31 <lambdabot>  [5,4,3,2,1,2,3,4,5,5,4,3,2,1,2,3,4,5,5,4,3,2,1,2,3,4,5,5,4,3,2,1,2,3,4,5,5,4...
22:38:33 <Axman6> (or see Ed's discrimination package)
22:38:49 <Axman6> it groups _runs_ of things which are equal
22:39:00 <Axman6> > group "aaabaaa"
22:39:02 <lambdabot>  ["aaa","b","aaa"]
22:39:06 <fog71> oh right, you could just sortOn fst
22:39:12 <Axman6> yep
22:39:58 <fog71> % (map snd . sortOn fst . zip (cycle [3 :: Int,2,1,2])) "hello"
22:39:58 <yahb> fog71: "lelho"
22:40:01 <dsal> Oh, that doubles on the top as well.  Getting hacky, but something like that.
22:40:36 <dsal> > let nin x = let l1 = [x, pred x .. 1] in cycle (l1 <> (tail . reverse . tail) l1) in    nin 5 -- lol
22:40:38 <lambdabot>  [5,4,3,2,1,2,3,4,5,4,3,2,1,2,3,4,5,4,3,2,1,2,3,4,5,4,3,2,1,2,3,4,5,4,3,2,1,2...
22:41:45 <fog71> % (map snd . sortOn fst . zip (let nin x = let l1 = [x, pred x .. 1] in cycle (l1 <> (tail . reverse . tail) l1) in    nin 3)) "hello"
22:41:46 <yahb> fog71: "lelho"
22:41:46 * hackage it-has 0.2.0.0 - Automatically derivable Has instances.  https://hackage.haskell.org/package/it-has-0.2.0.0 (dnikolovv)
22:41:57 <fog71> % (map snd . sortOn fst . zip (let nin x = let l1 = [x, pred x .. 1] in cycle (l1 <> (tail . reverse . tail) l1) in    nin 4)) "hello world"
22:41:58 <yahb> fog71: "lllorde ohw"
22:44:03 <fog71> and then for the cocypher, we can use lambdabots built in genetic functional programming;
22:44:05 <fog71> @deriveFunction "lllorde ohw" "hello world"
22:44:05 <lambdabot> Unknown command, try @list
22:44:12 <fog71> hmm...
22:44:29 <wavemode> > let rail str = let l = length str in map (str !!) $ [0,4..l-1] ++ [1,3..l-1] ++ [2,6..l-1] in rail "WEAREDISCOVEREDFLEEATONCE"
22:44:31 <lambdabot>  "WECRLTEERDSOEEFEAOCAIVDEN"
22:46:03 <fog71> i think the sortOn version is going to be faster for longer lists, but this version looks ok for Vectors IntMaps etc
22:47:56 <fog71> not sure about the cost of accumulating the input lists too, cycle should reuse memory?
23:06:57 <liiae> > [1..3] <> (tail .reverse $ [1..3]) <> (tail [1..3]) <> (tail . reverse $ [1..3])
23:06:59 <lambdabot>  [1,2,3,2,1,2,3,2,1]
23:08:33 <liiae> > [1..3] <> (tail .reverse $ [1..3]) <> (tail [1..3]) <> (tail . reverse $ [1..3]) <> (tail [1..3]) <> (tail . reverse $ [1..3])
23:08:35 <lambdabot>  [1,2,3,2,1,2,3,2,1,2,3,2,1]
23:09:06 <liiae> this (tail [1..3]) <> (tail . reverse $ [1..3]) is reapting
23:09:16 <liiae> how to make more clear?
23:09:46 <c_wraith> nothing that makes it shorter really would qualify as "more clear"
23:10:15 <liiae> c_wraith: more in general?
23:10:22 <liiae> my english is not good
23:11:00 <c_wraith> I'm just saying that most attempts to improve it will make it harder to understand
23:11:45 * hackage yaya 0.3.1.1 - Total recursion schemes.  https://hackage.haskell.org/package/yaya-0.3.1.1 (sellout)
23:12:01 <c_wraith>  > (tail <> tail . reverse) [1..3] -- like, this is shorter but...  is it really better?
23:12:17 <c_wraith> heh.  even without the extra space.
23:12:22 <c_wraith> > (tail <> tail . reverse) [1..3]
23:12:24 <lambdabot>  [2,3,2,1]
23:12:46 * hackage yaya-test 0.3.1.0, yaya-hedgehog 0.2.0.1, yaya-unsafe 0.2.0.1 (sellout)
23:12:49 <c_wraith> That immediately makes you go "wait, *what* Semigroup instance?"
23:14:21 <liiae> let s = [1..n], g = (tail . reverse $ s) <> (tail s) in f n = s <> g <> g <> g <> g <> g
23:14:49 <liiae> :t cycle
23:14:50 <lambdabot> [a] -> [a]
23:14:51 <c_wraith> that has a scoping error.  you're using n outside of where it's defined.
23:17:23 <liiae> let s n = [1..n], g = (tail . reverse $ s) <> (tail s) in f n = s n <> g <> g <> g <> g <> g?
23:19:02 <c_wraith> that has type errors.  You should be checking in ghci or in a file that you :load into ghci
23:19:06 <liiae> how to repeat to do something?
23:19:23 <liiae> because this <> g is repeat
23:19:49 <c_wraith> Get working code, then try to simplify it.
23:20:10 <liiae> c_wraith: I need a function name that prove repeat
23:20:13 <liiae> provide
23:20:22 <c_wraith> do you want replicate ?
23:20:31 <c_wraith> But really, make it work first
23:24:00 <liiae> > let s n = [1..n]; g n = (tail . reverse $ s n) <> (tail $ s n) ; f n = (s n) <> (g n) <> (g n) in f 3
23:24:03 <lambdabot>  [1,2,3,2,1,2,3,2,1,2,3]
23:24:13 <liiae> c_wraith: ^
23:26:37 <c_wraith> ok. What part of that is unsatisfying?
23:27:05 <liiae> c_wraith: (s n) <> (g n) <> (g n) is not infinite
23:27:16 <liiae> it should be infinite
23:27:20 <c_wraith> ah, ok.
23:27:39 <c_wraith> f n = s n <> cycle (g n)
23:28:14 <liiae> let s n = [1..n]; g n = (tail . reverse $ s n) <> (tail $ s n) ; f n = (s n) <> cycle (g n) in f 3
23:28:40 <liiae> > let s n = [1..n]; g n = (tail . reverse $ s n) <> (tail $ s n) ; f n = (s n) <> cycle (g n) in f 3
23:28:41 <lambdabot>  [1,2,3,2,1,2,3,2,1,2,3,2,1,2,3,2,1,2,3,2,1,2,3,2,1,2,3,2,1,2,3,2,1,2,3,2,1,2...
23:28:52 <c_wraith> (g n) is a list.  cycle causes that list to be repeated infinitely
23:29:25 <liiae> aha, replicate and cycle
23:29:49 <dsal> > let nin x = let l1 = [x, pred x .. 1] in cycle (l1 <> (tail . reverse . tail) l1) in    nin 5 --   <-- I did an ugly version of that above
23:29:51 <lambdabot>  [5,4,3,2,1,2,3,4,5,4,3,2,1,2,3,4,5,4,3,2,1,2,3,4,5,4,3,2,1,2,3,4,5,4,3,2,1,2...
23:29:53 <c_wraith> throw repeat in, also.  it's closer to replicate than cycle is
23:30:11 <c_wraith> > repeat "hi!"
23:30:13 <lambdabot>  ["hi!","hi!","hi!","hi!","hi!","hi!","hi!","hi!","hi!","hi!","hi!","hi!","hi...
23:30:57 <liiae> let s n = [1..n]; g n = (tail . reverse $ s n) <> (tail $ s n) ; f n = (s n) <> cycle (g n) in f 5
23:31:10 <liiae> > let s n = [1..n]; g n = (tail . reverse $ s n) <> (tail $ s n) ; f n = (s n) <> cycle (g n) in f 5
23:31:12 <lambdabot>  [1,2,3,4,5,4,3,2,1,2,3,4,5,4,3,2,1,2,3,4,5,4,3,2,1,2,3,4,5,4,3,2,1,2,3,4,5,4...
23:40:15 * hackage sixel 0.1.1.0 - Sixel library to show images in a terminal emulator  https://hackage.haskell.org/package/sixel-0.1.1.0 (junjihashimoto)
23:44:04 <liiae> [('W',1),('E',2),('A',3),('R',2),('E',1),('D',2),('I',3),('S',2),('C',1),('O',2),('V',3),('E',2),('R',1),('E',2),('D',3),('F',2),('L',1),('E',2),('E',3),('A',2),('T',1),('O',2),('N',3),('C',2),('E',1)]
23:44:39 <liiae> how to get all the second element as 1 to a group, and a group to 2, a group to 3
23:45:00 <liiae> WECRLTE are all with 1
23:45:20 <liiae> ERDSOEEFEAOC are all with 2
23:45:33 <liiae> AIVDEN are all with 3
23:45:51 <liiae> group and sort
23:50:51 <wavemode> @define lst = [('W',1),('E',2),('A',3),('R',2),('E',1),('D',2),('I',3),('S',2),('C',1),('O',2),('V',3),('E',2),('R',1),('E',2),('D',3),('F',2),('L',1),('E',2),('E',3),('A',2),('T',1),('O',2),('N',3),('C',2),('E',1)]
23:50:52 <lambdabot>  Defined.
23:50:59 <wavemode> > concat [ [ fst x | x <- lst, snd x == n ] | n <- [1..3] ]
23:51:01 <lambdabot>  "WECRLTEERDSOEEFEAOCAIVDEN"
23:52:00 <int-e> > map fst . sortOn snd $ lst
23:52:03 <lambdabot>  "WECRLTEERDSOEEFEAOCAIVDEN"
23:53:04 <int-e> > map (map fst) . groupBy ((==) `on` snd) . sortOn snd $ lst
23:53:06 <lambdabot>  ["WECRLTE","ERDSOEEFEAOC","AIVDEN"]
23:53:31 <liiae> ok
23:56:02 <liiae> sortOn is good here
23:57:16 <Geekingfrog> > Data.IntMap.fromListWith (<>) $ map (\(a, b) -> (b, [a])) lst
23:57:18 <lambdabot>  fromList [(1,"ETLRCEW"),(2,"COAEFEEOSDRE"),(3,"NEDVIA")]
