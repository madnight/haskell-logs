00:39:58 <gentauro> I just realized that `ghci` has path completion :o (I normally use it inside `emacs` where it doesn't). What an amazing tool !!!
00:41:28 <mniip> gentauro, it also has identifier and module completion
00:43:06 <gentauro> mniip: tell me about it !!!
00:43:29 <gentauro> and amazing intellisense !!!
01:14:16 * hackage mmsyn6ukr 0.6.5.0 - A musical instrument synthesizer or a tool for Ukrainian language listening  https://hackage.haskell.org/package/mmsyn6ukr-0.6.5.0 (OleksandrZhabenko)
01:22:03 <Uniaika> hey folks, I just learned about https://github.com/rxi/microui
01:22:18 <Uniaika> and I was wondering: how does one write haskell bindings to a C UI library?
01:22:47 <koz_> Uniaika: Like... using the FFI?
01:22:53 <koz_> I'm not too sure what you're asking.
01:23:53 <Uniaika> I was wondering if there was more than just that. if code generation was involved, etc…
01:24:05 <koz_> I would recommend inline-c if possible.
01:24:25 <koz_> It makes this _a tonne_ easier in many situations.
01:24:51 <koz_> If you wanna write bindings to something like this, you could just embed it into your project.
01:24:52 <Uniaika> okay cool!
01:24:56 <koz_> (it's two files, one of which is a header)
01:25:04 <koz_> (kinda like what Squeather does)
01:25:28 <[exa]> Uniaika: btw afaik other immediate mode libraries should already hove some bindings, e.g. imgui claims to have some
01:25:30 <koz_> You could actually check out Squeather's source as a guide.
01:27:05 <Uniaika> [exa]: imgui's bindings are abandonned :(
01:27:08 <Uniaika> (in haskell)
01:27:13 <[exa]> Uniaika: also also, c2hs is a pretty systematic approach for wrapping stuff
01:27:16 <[exa]> oh noes :(
01:27:42 <koz_> Yeah, c2hs is pretty good, especially if you have a large binding surface.
01:28:04 <koz_> FWIW, I'm working on some wrapper stuff around inotify, and I found inline-c to be more than sufficient.
01:28:10 <[exa]> oh wow, microui has 1.1k sloc
01:28:28 <Uniaika> [exa]: this is quite small, isn't it?
01:28:28 <[exa]> might be easier to just port it as a whole
01:28:37 <koz_> [exa]: I agree.
01:28:40 <Uniaika> what do you mean? just rewrite it in Haskell?
01:28:46 <koz_> Uniaika: No, just bundle it.
01:28:53 <koz_> Like, embed the C code in the project.
01:28:55 <[exa]> I always wanted to write a imgui library that uses StateT + lenses
01:29:00 <Uniaika> ah
01:29:13 <koz_> Also, thank you for bringing this to my attention.
01:29:17 * koz_ is the maintainer of awesome-c.
01:29:30 <koz_> (or rather, the awesome-c you should be reading)
01:29:35 <Uniaika> haha
01:30:12 <[exa]> koz_: you might want to add imgui too, it's superuseful
01:30:13 <Uniaika> alright, so what you folks recommend is to use inline-c and bundle the C code in my package?
01:30:23 <[exa]> Uniaika: bundle first, polish later
01:30:35 <koz_> [exa]: I remember examining it a while ago and finding it lacking. Maybe it's gotten better since then.
01:30:43 <koz_> Uniaika: Bundle the C, yes.
01:30:49 <koz_> inline-c may or may not be suitable for your uses.
01:31:06 <koz_> Try and see - it's definitely the _easiest_ from the Haskell end, I'd say, but it might not be the best choice in your particular case.
01:31:33 <Uniaika> okay so bundle and normal FFI?
01:31:33 <koz_> "The library expects the user to provide input and handle the resultant drawing commands, it does not do any drawing itself." Wat.
01:31:42 <koz_> I was wondering where its rendering code was.
01:31:48 <koz_> Or any platform-specifics.
01:31:52 <koz_> (since it has neither of those things)
01:32:01 <Uniaika> oh.
01:32:02 <Uniaika> indeed.
01:32:09 <Uniaika> well that's actually not good
01:32:28 <koz_> Like, I thought 1.1Kloc was a bit low for a GUI library, even single-platform.
01:32:40 <Uniaika> alright, let's head to imgui haha
01:32:41 <koz_> I figured it was targeting Vulkan or something, but I saw nothing like it there.
01:32:47 <koz_> No platform-specific #ifdefs either.
01:32:50 <koz_> No build system _either_.
01:32:56 <koz_> So I was like 'what sorcery is this?'.
01:33:43 <Uniaika> [exa]: https://github.com/dbousamra/imgui-haskell
01:34:58 <koz_> Uniaika: This uses c2hs.
01:35:05 <koz_> Which is probably the right idea.
01:35:54 <Uniaika> alright
01:40:16 * koz_ should really finish that wrapper.
01:40:20 <koz_> (and his other stuff)
01:57:26 <sheepfleece> How can I get documentation of all dependencies in my project? I'm using cabal with nix.
01:57:58 <sheepfleece> I tried `cabal new-haddock --enable-documentation` but it throws an error instead.
02:25:25 <Nolrai> whats the most ideomatic way to apply a function (f:a->a) n times?
02:26:48 <buggymcbugfix> :t iterate
02:26:50 <lambdabot> (a -> a) -> a -> [a]
02:27:02 <buggymcbugfix> Nolrai: ☝️
02:27:35 <Nolrai> So, `iterate f a !! n`
02:27:37 <Nolrai> ?
02:28:05 <dibblego> then take
02:28:51 <[exa]> Nolrai: yes. (given a bit of optimization the list shouldn't even get materialized)
02:29:10 <Nolrai> Seems weird to use !! when I shouldn';t have to.
02:29:44 <[exa]> Nolrai: generic advice is wrong in specific cases :]
02:31:30 <Bish> is there some funny way to make all windows inside a container mmake the same size
02:32:37 <Bish> s/funny/good, s/make/have
02:32:56 <buggymcbugfix> Nolrai: you can use `applyN`, e.g. from protolude or define it yourself
02:34:16 <kuribas> stimesMonoid?
02:34:29 <Bish> ohshit, wrong channel!
02:34:42 <kuribas> :t \i -> stimesMonoid i . Endo
02:34:43 <lambdabot> error:
02:34:44 <lambdabot>     Variable not in scope: stimesMonoid :: t -> Endo a -> c
02:35:06 <kuribas> erm \i -> appEndo . stimesMonoid i . Endo
02:35:40 <buggymcbugfix> Nolrai: ```Prelude> let applyN n = foldr (.) id . replicate n
02:35:40 <buggymcbugfix> Prelude> :t applyN
02:35:40 <buggymcbugfix> applyN :: Int -> (b -> b) -> b -> b
02:35:40 <buggymcbugfix> Prelude> applyN 5 succ 1
02:35:40 <buggymcbugfix> 6```
02:37:39 <kuribas> λ> let ntimes i = appEndo . stimesMonoid i . Endo in ntimes 5 succ 1
02:37:39 <kuribas> 6
02:37:39 <kuribas>  
02:40:23 <gentauro> JS uses `unix timestamps` (epoch) on the FE. How do people convert those to Haskell timestamps?
02:41:28 <Uniaika> gentauro: there are no haskell timestamps
02:41:43 <Uniaika> there are RFC timestamps, ISO timestamps…
02:41:48 <gentauro> I guess formatting FE to ISO-8601 strings could help -> https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString
02:42:02 <Uniaika> there are haskell libraries for a variety of timestamps
02:42:16 <gentauro> (but what if you consume API's that where you can't change anything?)
02:42:31 <gentauro> Uniaika: I'm aware of `time` (I used it several times)
02:42:52 <Uniaika> gentauro: ISO8601 is a pandemonium of formats, I'd suggest you to restrict to RFC2822
02:43:11 <Uniaika> yes, but I was making a point on how the concept of "Haskell Timestamp" is nonsensical. :)
02:43:31 <opqdonut> lol are you joking with RFC2822 timestamps :D
02:43:32 <gentauro> Out of curiosity, how do people here do it? I guess it's not the first time somebody had to consume some `*nix timestamp` :) 
02:43:42 <Nolrai> Does https://hackage.haskell.org/package/time-1.9.3/docs/Data-Time-Clock-POSIX.html not do what you want?
02:43:59 <opqdonut> RFC3339 is the sane timestamp standard
02:44:12 <gentauro> Nolrai: https://hackage.haskell.org/package/time-1.9.3/docs/Data-Time-Clock-POSIX.html#v:posixSecondsToUTCTime
02:44:17 <gentauro> looks like we have a winner :)
02:44:26 <gentauro> Nolrai: thx
02:44:27 <Uniaika> opqdonut: err my bad, yes 3339
02:45:15 * hackage zeolite-lang 0.5.0.0 - Zeolite is a statically-typed, general-purpose programming language.  https://hackage.haskell.org/package/zeolite-lang-0.5.0.0 (ta0kira)
02:45:25 <opqdonut> also, programmatic representation of timestamps doesn't really have anything to do with RFC3339 or ISO8601
02:45:29 <opqdonut> they're more about the textual representation
02:46:02 <opqdonut> (some people call these pieces of text timestrings, and timestamps are the abstract objects they represent)
02:47:19 <phadej> I recently removed feature to allow (a lot easier) addition of another
02:47:21 <phadej> trade-offs
02:47:56 <opqdonut> yep
02:49:06 <phadej> galaxy brain: systems are rewritten when adding new features is infeasible, but removing or refactoring is impossible as well.
02:49:28 <phadej> i.e. "new system" is a justification for "removal of features"
02:56:04 <phadej> worst: legacy file formats
02:57:45 * hackage file-embed 0.0.12.0 - Use Template Haskell to embed file contents directly.  https://hackage.haskell.org/package/file-embed-0.0.12.0 (MichaelSnoyman)
03:07:20 <gentauro> living on the edge ("https://www.stackage.org/lts-15") -> `Stack has not been tested with GHC versions above 8.6, and using 8.8.2, this may fail` :o
03:14:34 <koz_> gentauro: Update to latest stack to make that go away. :P
03:19:12 <elbeem> Hi, I just made a post on /r/haskell, but I am not able to see it in incognito mode. Can anyone else see it? Link: https://www.reddit.com/r/haskell/comments/gi6ppi/building_a_progressive_web_app_with_obelisk_reflex/
03:19:45 <elbeem> When I go to https://www.reddit.com/user/elbeem in incognito, it says [removed] on my post. Have I been shadow-banned?
03:20:17 <maerwald> I see an empty post
03:20:22 <maerwald> with no link
03:21:37 <elbeem> I also see an empty post in incognito, but I can see it when logged in. Strange. Maybe the mods can help me?
03:33:43 <MarcelineVQ> You still see your own posts if you're shadowbanned, that's the shadow part :>
03:33:53 <MarcelineVQ> Oh I misread you, truly I am the fool
03:35:25 <Lycurgus> if ur a fool an u know it jump ur conclusions!
03:45:07 <Uniaika> *jump* *jump*
03:50:29 <kuribas> I wonder if there is a concept like semi-totality, where you are allowed to loop forever, but at any point in time there will be some observable side-effect after some finite interval.
03:51:25 * Lycurgus jumps to sem nil-potency
03:51:35 * Lycurgus *semi
03:52:38 <kuribas> I suppose that can be modelled as a total function taking a state, and producing a new state and side-effect.
04:27:35 <solonarv> or some kind of stream, perhaps
04:29:57 <solonarv> a fixpoint of this, for example: data StreamF i m a r = NeedInputF (i -> r) | HaveOutputF a r | PerformActionF (m a)
04:30:49 <solonarv> oops, s/\(m a\)/(m r)/
04:31:44 <solonarv> with a stipulation that the 'i -> r' and 'm a' fields (if m is function-ish) are total, and that none of the fields are ever bottom
04:43:28 <gentauro> koz_: will do :D
04:57:59 <z16> When I check the type of a value with `:t` it seems it only displays the type class it's in
04:58:08 <z16> So when I do `:t 3` it only gives me `Num`
04:58:21 <z16> Can I figure out if it's an `Int` vs `Integer`?
04:58:25 <merijn> z16: It's not displaying the typeclass it's in
04:58:27 <merijn> :t 3
04:58:29 <lambdabot> Num p => p
04:58:53 <z16> So I guess that means `3`, when used, can be applied to any `Num`
04:58:58 <merijn> z16: The type of 3 is "any type that is an instance of Num"
04:59:08 <merijn> yes
04:59:27 <merijn> > 3 :: Int
04:59:28 <lambdabot>  3
04:59:30 <merijn> > 3 :: Double
04:59:32 <lambdabot>  3.0
04:59:34 <merijn> > 3 :: Rational
04:59:36 <lambdabot>  3 % 1
05:00:00 <z16> Hm
05:00:53 <merijn> Note that
05:00:57 <merijn> :t 3.2
05:00:58 <lambdabot> Fractional p => p
05:01:14 <merijn> > 3.2 :: Int -- type error
05:01:17 <lambdabot>  error:
05:01:17 <lambdabot>      • No instance for (Fractional Int) arising from the literal ‘3.2’
05:01:17 <lambdabot>      • In the expression: 3.2 :: Int
05:01:18 <merijn> > 3.2 :: Double
05:01:20 <lambdabot>  3.2
05:01:26 <merijn> > 3.2 :: Rational
05:01:28 <lambdabot>  16 % 5
05:01:38 <z16> Then I guess this assigment that asks for a precise type when I don't *know* the precise type (or when it could be one of several, depending on how it's applied) is incorrect? As an example, I got a comment on an assignment that `mod 4 3` should be `Integer`, but `Integral` would be correct, since it could be used for that as well?
05:01:50 <aveltras> does anyone have an example of a yesod setup with templates reloading (base on yesod-core, not yesod) ?
05:03:00 <merijn> z16: Well, technically "Num p => p" is precise, it's just polymorphic
05:03:32 <z16> But it's not a type, it's a type class? Or are types type classes as well in the hierarchy?
05:04:25 <kuribas> solonarv: it looks to me that totality is almost always desirable.
05:04:41 <merijn> z16: Type classes are part of type. The part in front of "=>" is usually called the constraint (because it, well, constrains your choices for type variables)
05:04:52 <kuribas> solonarv: even in a potentially never ending computation, you can always put a finit counter...
05:04:53 <solonarv> 'Num p => p' is not a type class. 'Num' is a type class.
05:05:13 <merijn> z16: I mean, even just 'a' is a type. It's a rather non descript type (a single type variable, so it can be literally anything)
05:05:49 <merijn> z16: "Num p => p" is a type variable 'p' (so, anything), but the constraint says "the only legal picks for 'p' are those that are instances of Num"
05:06:39 <solonarv> kuribas: yes, usually you want your programs to terminate or at least be productive (i.e. run forever but keep producing results)
05:06:41 <merijn> Of course, there's not many useful values of type 'a', because very few things can be "literally any type".
05:07:15 <merijn> kuribas: Yes, this is why I've come to realise that Turing completeness is an overrated non-feature :)
05:08:18 <merijn> z16: Let's take a more concrete example of values that are polymorphic, maybe that'll help provide inside
05:08:27 <kuribas> is there a name of non-turning complete, but still useful for general computations?
05:08:31 <z16> merijn Thanks, but that all makes a lot of sense
05:08:32 <merijn> z16: Consider this: What is the type of 'Nothing'?
05:08:52 <z16> And it also answered the second part of my question
05:09:19 <merijn> kuribas: Generally you'd refer to total languages, because you could imagine a language that's not Turing complete, but also non-total, but that'd be the worst of both worlds :p
05:09:45 <merijn> Or, "What is the type of []?"
05:09:46 <kuribas> merijn: so python?
05:09:53 <merijn> kuribas: Basically
05:10:27 <merijn> kuribas: Actually, Python is Turing complete, so that's unfair
05:10:38 <merijn> Unlike C, which is not
05:10:39 <kuribas> true
05:10:48 <kuribas> C isn't turing complete?
05:10:53 <kuribas> because of memory limits?
05:11:01 <z16> It is
05:11:03 <merijn> kuribas: Turing completeness requires arbitrary memory
05:11:13 <z16> And C has that
05:11:29 <merijn> C requires two things: all memory objects must fit inside a void* and void pointers are finite size
05:11:39 <merijn> Therefore, C memory can never be unbounded
05:12:41 <merijn> And C cannot be Turing complete. (Neither can any real world implementation of languages, but at least their definition can be. Haskell doesn't specify any bounds on the memory model and can therefore work on hypothetical unbounded memory machines)
05:13:53 <z16> <_< I need to consult the standard lol, this will require some language lawyering, are you sure that C specifies a finite size on pointers? Obviously *implementations* must have that, but does the language prescribe it?
05:14:15 <merijn> Yes
05:14:17 <z16> Or does it just say "objects may not exceed pointer size"
05:15:43 <peutri> i'm not sure how a language lawyer could say "pointers must have an infinite size" with a straight face
05:16:42 <merijn> "A type has known constant size if the type is not incomplete and is not a variable length array type."
05:17:10 <merijn> 6.2.5.23 of the C11 spec ;)
05:17:18 <peutri> so it's constant
05:17:22 <peutri> is it bounded?
05:17:38 <merijn> Damn, lawyered...I wish it was easier to find stuff in the spec >.>
05:17:56 <peutri> being unbounded wouldn't be an argument against TC
05:18:01 <peutri> that's just my curiosity
05:21:43 <wjlewis123> @djinn a -> b
05:21:43 <lambdabot> -- f cannot be realized.
05:21:50 <wjlewis123> @djinn a -> a
05:21:50 <lambdabot> f a = a
05:21:55 <merijn> Ok, I can't find it explicitly stated, but consider the fact that 1) size is constant and 2) The sizeof operator yields the size (in bytes) of its operand, which may be an expression or the parenthesized name of a type. 
05:22:06 <wjlewis123> @djinn a -> ()
05:22:06 <lambdabot> f _ = ()
05:22:26 <merijn> There's no real way to return an unbounded/infinite value of bytes back, therefore there must be a fixed size :p
05:22:42 <merijn> (for object pointers! Function pointers are unspecified!)
05:22:44 <peutri> (tangent: i didn't think the type had to be parenythesized)
05:23:17 <merijn> peutri: It does, probably to make parsing easier :p
05:23:34 <peutri> yet i was pretty sure i'd already used it unparenthesized... until now
05:25:32 <peutri> well that's one thing that'll be more clear in my mind in the future
05:26:19 <merijn> If you do sizeof on types you're doing it wrong anyway :p
05:28:17 <peutri> that's another debate :)
05:28:52 <peutri> though your argument is probably worth something
05:29:09 <peutri> type *p = malloc(n * sizeof(type)) sounds reasonable to me
05:30:01 <peutri> what's the better way?
05:31:26 <merijn> peutri: "type *p = malloc(n * sizeof *p);" or "type *p = malloc(n * (sizeof *p));" for clarity
05:31:51 <peutri> mmm
05:31:57 <peutri> pros not obvious to me
05:32:09 <merijn> peutri: because, imagine if there's a 100 lines between the declaration of 'p' and the malloc, no imagine 1 year later someone changes the type of the declaration, but doesn't notice the malloc
05:32:23 <peutri> but there isn't
05:32:47 <peutri> there's no better place for a storing a malloc result than the pointer declaration
05:33:42 <merijn> peutri: You never need to resize, say, an array, or whatever and assign a malloc to an existing pointer? Anyway, we're getting off topic :p
05:33:58 <peutri> nobody's talking haskell right now, we're clear
05:34:13 <peutri> the point's very abstract in many ways
05:34:40 <peutri> i don't think i ever felt the need to allocate an array of basic types in anything production-like
05:35:55 <peutri> so typedefs or structs, and then it's either (a) someone changes the type/struct def, and all falls into place or (b) they couldn't dereference a field anyway
05:36:29 <peutri> resize an array: honestly, i think not
05:37:06 <peutri> assigning: not as such. *returning* yes, but it would likely be a declaration on the caller's side
05:37:48 <peutri> IIRC C compilers warn (or err?) on pointer type mismatch
05:38:40 <merijn> peutri: malloc returns void*, so it never has a mismatch :)
05:39:11 <peutri> my memories of C programming was I had to cast
05:39:23 <peutri> lemme ideone for a bit
05:39:44 <merijn> C++ requires a cast, C does not
05:39:53 <peutri> ah, that's it
05:40:14 <peutri> please don't ask me why I was malloc'ing in C++
06:22:21 <typetetris> Whats the suggestion for sending emails in haskell via smtp?
06:29:15 * hackage ircbot 0.6.6 - A library for writing IRC bots  https://hackage.haskell.org/package/ircbot-0.6.6 (JeremyShaw)
07:00:35 <tdammers> typetetris: my first impulse would be to shell out to something that can send emails
07:11:05 <typetetris> tdammers: if all else fails, I would do that. Have seen HaskelNet package but it is unsupported, so don't know if there are unfixed bugs.
07:11:45 * hackage boomerang 1.4.6 - Library for invertible parsing and printing  https://hackage.haskell.org/package/boomerang-1.4.6 (JeremyShaw)
07:13:05 <Bish> why does the rts have a disassembler?
07:14:46 <merijn> Bish: What makes you say that?
07:14:55 <Bish> couriousity
07:15:07 <Bish> insatiable curiousity
07:15:19 <Bish> and the file "Disassembler.c"
07:16:52 <aveltras> does anyone have an example of using the BottomOfHeadAsync here https://hackage.haskell.org/package/yesod-core-1.6.18/docs/Yesod-Core.html#t:ScriptLoadPosition ? I can't find examples on github search which aren't commented..
07:17:11 <merijn> Bish: Looking at the comments that seems related to ghci's bytecode?
07:18:01 <Bish> which comments?
07:18:19 <Bish>    See GHC.CoreToByteCode.linkBCO.insns_arr for construction ...
07:18:21 <Bish> this?
07:18:35 <merijn> Bish: Also, the comment on line 2? :p
07:18:45 <merijn> "* Bytecode disassembler"
07:18:51 <Bish> :> oopsie
07:31:41 <remexre> hm, is there a convenient way to do a "slightly non-local" operation on a type w/ recursion schemes? e.g. I have a data Term a = App a a | Lam Name a | Var Name, and I want to convert it to an s-expression, but e.g. App (App f x) y should collapse to (f x y), Lam x (Lam y z) should collapse to (lam (x y) z), etc
07:33:35 <remexre> I guess maybe instead of Algebra TermF SExpr, I'd want an Algebra TermF { onApp :: SExpr -> SExpr, onLam :: Name -> SExpr, onOther :: SExpr } ?
07:34:31 <Cale> remexre: I don't have a ready answer for the recursion schemes question, but... I'd be a little worried about whether making that change is actually okay -- if the functions in your target language have a fixed arity, then it might not be valid to do that.
07:35:05 <ski> hm, i was thinking of folding into a product, with one case being `(SExpr,[SExpr])', another being `([Name],SExpr)', and so on
07:35:36 <remexre> my language has currying; and besides, this is an IR anyway, nothing should really be parsing it other than human eyeballs
07:35:45 * hackage haskoin-store-data 0.28.0 - Data for Haskoin Store  https://hackage.haskell.org/package/haskoin-store-data-0.28.0 (jprupp)
07:35:50 <Cale> ah, okay :)
07:36:45 * hackage haskoin-store 0.28.0 - Storage and index for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-store-0.28.0 (jprupp)
07:37:37 <remexre> ski: er yeah, I'd probably want that, since I think the record would have to have its functions return a value of its own type, not SExpr; and then it'd be equivalent
07:39:52 <ski> mm, i didn't quite get your idea, but it looked like it was a similar notion of what i was thinking about
07:40:06 <remexre> yeah, mine used basically the ShowS transform
07:40:13 <remexre> but I screwed it up, I think
07:53:09 <Eugleo> Hey, anybody here has experience with Databse.Selda?
07:53:36 <Eugleo> I cannot seem to understand how joins work from the docs
07:57:37 <Eugleo> Or if anybody has any recommendations on interaction with db in Haskell, I'll be happy to hear them
07:58:17 <Uniaika> Eugleo: I think it has a glitter chatroom
07:58:23 <Uniaika> pretty sure of it
07:58:33 <Uniaika> you can ask their community there
07:58:58 <Eugleo> You'r eright! Thanks a ton, I missed the little badge in the repo
08:00:25 <Uniaika> no worries, have fun and good luck!
08:00:43 <merijn> Eugleo: Honestly, sqlite-simple or postgres-simple >.>
08:01:05 <Uniaika> *cough*Squeal*cough*
08:01:42 <Eugleo> merijn: Bummer. That's what we've been using a week ago, but somebody here recommended Selda to a colleague and we've been rewriting it since :-D
08:01:47 <merijn> Uniaika: I've only opened the package page and just the number of modules already tells me this'd suck :p
08:02:14 <merijn> Eugleo: tbh, I'm getting more and more convinced that the best functional way of interacting with a database is...SQL :p
08:02:44 <merijn> Uniaika: Yeah, I open one module and I already hate Squeal as much as BEAM >.>
08:06:03 <dmwit> merijn: http://hackage.haskell.org/package/yeshql
08:06:11 <Eugleo> Well, maybe I'll be able to resolve the issues
08:06:26 <Eugleo> I'd rather not lose the time spent on the rewrite
08:06:50 <dmwit> merijn: I think the number of modules will be right up your ally.
08:06:58 <merijn> dmwit: Interesting :)
08:06:59 <dmwit> alley
08:09:17 <Uniaika> merijn: we have one person at work dedicated to understanding / orchestrating the Squeal code
08:09:18 <Eugleo> dmwit: Looks cool
08:09:39 <Uniaika> (in exactly one service whose PG queries are business-critical and fairly complex)
08:09:44 <Eugleo> dmwit: Do you have any personal or at least second-hand experience with it?
08:14:15 * hackage bz2 1.0.1.0 - Bindings to libbz2  https://hackage.haskell.org/package/bz2-1.0.1.0 (vmchale)
08:16:54 <o1lo01ol1o> Eugleo:  beam is solid though it has a bit of a learning curve 
08:18:15 <Eugleo> o1lo01ol1o: Thanks for the recommendation. I initially steered away from Beam, because somewhere I'd read it uses `persistent` and that it leaks into all of the code
08:18:23 <Ariakenom> merijn: are you even programming if your sql "abstraction" doesnt have imports with side effects?
08:18:31 <maerwald> I don't understand what's wrong with SQL
08:18:33 <Eugleo> (no idea what `persistent` is)
08:18:42 <o1lo01ol1o> Eugleo: `persistant`?
08:18:44 <maerwald> Everyone wants to avoid writing SQL
08:18:49 <maerwald> Just learn SQL
08:19:05 <Eugleo> maerwald: Oh, I have no problems with SQL
08:19:39 <o1lo01ol1o> We've got lots of complex SQL queries in beam and I much prefer working with those to SQL
08:19:41 <Eugleo> It's definitely easier to learn than profunctors+arrows (opaleye), for example
08:20:11 <maerwald> Exactly. Now you got all sorts of CT and type-level foo and don't know to what SQL it really translates.
08:21:02 <Eugleo> maerwald: We've got many rather simple querries, unlike o1lo01ol1o, but we're adding new models/db tables/apis rather quickly and things keep breaking when you have to edit 4 points in code at the same time
08:21:12 <Eugleo> And keep track of the names, types and whatnot, yourself
08:21:58 <maerwald> Eugleo: but it's all quite well testable
08:22:46 <merijn> persistent is a library from the Yesod ecosystem, I don't think it has anything to do with beam, though
08:22:57 <Eugleo> maerwald: That's true. That would probably be a better option.
08:23:24 <maerwald> Eugleo: I think so, because I still wouldn't trust types to preserve my database semantics, no matter what.
08:23:29 <merijn> o1lo01ol1o: honestly, like 90% of the types in beam are enough to make me cry. I ain't got time to deal with types like that and the most likely godawful errors that produces
08:24:36 <maerwald> Types tell you the "motivation" of a function, not what it does.
08:25:05 <fresheyeball> class Demote (x :: k) where demote :: Proxy x -> k
08:25:06 <fresheyeball> works
08:25:09 <fresheyeball> but
08:25:27 <fresheyeball> class Demote (x :: k) where demoted :: k
08:25:28 <fresheyeball> doesn't
08:25:50 <fresheyeball> even with appropriate language extensions, poly kinds, data kinds, ambigious types
08:25:53 <fresheyeball> why?
08:26:05 <fresheyeball> to make things more confusing
08:26:13 <fresheyeball> class Demote (x :: Bool) where demoted :: Bool
08:26:17 <Eugleo> merijn: I skimmed this reddit thread and thus thought persistent and Beam are interconnected. https://www.reddit.com/r/haskell/comments/8qxvir/a_comparison_among_various_database_edsls_selda/e0ttdkw/
08:26:17 <fresheyeball> does work
08:26:27 <o1lo01ol1o> merijn:  In practice there aren't that many that we've ended up need to really deal with; there were some painpoints in learning somethings for sure.  In our case the maintainability of the queries outweighed the upfront costs. But yes, if you don't have to add new tables and maintain complex aggregations, I could see beam being overkill
08:26:50 <fresheyeball> IE the Proxy is only required when `k` is polymorphic
08:27:08 <o1lo01ol1o> Eugleo: beam is not related to persistent
08:27:19 <fresheyeball> every other time a Proxy has been required I have been able to eliminate it with the combination of ambiguous types and type applications
08:27:21 <statusfailed> fresheyeball: hmmmm can't you do that with TypeApplications? 
08:27:25 <statusfailed> oh damnit hahah
08:27:27 <statusfailed> sorry :-)
08:27:36 <fresheyeball> statusfailed: no worries
08:27:44 <fresheyeball> the type class itself wont compile
08:27:52 <fresheyeball> so I don't even get to use the type application
08:27:59 <statusfailed> oh I see!
08:28:03 <fresheyeball> demote @'Foo = Foo
08:28:07 <fresheyeball> would be a killer api
08:28:08 <maerwald> merijn: libraries are not popular in haskell, DSLs and frameworks are :P
08:28:17 <fresheyeball> and I see no reason why I can't have it
08:28:23 <Eugleo> o1lo01ol1o: I see.
08:28:29 <fresheyeball> demote (Proxy @'Foo) = Foo 
08:28:36 <fresheyeball> works, but I don't see why
08:29:11 <maerwald> Look at yesod and servant vs e.g. scotty. I would only consider scotty a library.
08:29:48 <fresheyeball> interesting, of those choices, I would consider Servant the library
08:30:02 <maerwald> it's a type-level DSL for defining APIs
08:30:11 <Eugleo> o1lo01ol1o merijn: Well, I think that if I'm going to have to rewrite this thing _again_, I'll stick with the good ol' psql-simple and a bunch of tests to boot. But it's nice to hear about those other options
08:31:39 <maerwald> for databases: tests > types, imo
08:32:06 <Eugleo> It was hard to resist the coolness of this
08:32:13 <Eugleo> Coming to bite me, as it always does
08:32:15 * hackage sampling 0.3.4 - Sample values from collections.  https://hackage.haskell.org/package/sampling-0.3.4 (JaredTobin)
08:59:46 <tdammers> servant is borderline ecosystem by now
09:01:09 <maerwald> borderline in what sense
09:16:21 <mkru> Is it possible to specify format for Int on print when putStr is used? 
09:16:45 <wavemode> there's Text.Printf
09:17:11 <wavemode> https://hackage.haskell.org/package/base-4.14.0.0/docs/Text-Printf.html
09:19:15 * hackage gather 0.1.0.0 - An applicative for parsing unordered things, heterogenous sorting  https://hackage.haskell.org/package/gather-0.1.0.0 (RobertHensing)
09:26:17 <sm[m]> g'day all. In case you didn't see it by yesterday.. this ascii drawing tool is really nifty: https://github.com/jtdaugherty/tart/#readme
09:29:15 * hackage too-many-cells 0.2.2.2 - Cluster single cells and analyze cell clade relationships.  https://hackage.haskell.org/package/too-many-cells-0.2.2.2 (GregorySchwartz)
09:33:56 <maerwald> I have to get into ncurses programming
09:34:33 <wavemode> brick is a real gem
09:34:36 <maerwald> I've been so annoyed by mutt, that I was gonna write something in haskell
09:35:10 <dmwit> Wait, are you using "ncurses" to just generically mean terminal-drawing, or do you actually mean specifically the library ncurses? And if specifically ncurses... why??
09:35:23 <maerwald> ncurses yeah
09:35:54 <maerwald> because slang is worse?
09:36:09 <dmwit> But brick is worlds better.
09:36:43 <maerwald> does it have true color support?
09:38:11 <dmwit> yes: http://hackage.haskell.org/package/vty-5.28.2/docs/Graphics-Vty-Attributes-Color.html
09:40:00 <maerwald> might be worth a shot then
09:45:45 * hackage within 0.1.0.0 - A value within another path.  https://hackage.haskell.org/package/within-0.1.0.0 (locallycompact)
09:49:37 <sm[m]> wavemode: agreed!
09:49:52 <sm[m]> when will someone port it to windows..
09:53:19 <wavemode> it doesn't work on windows?
09:53:21 <wavemode> why not?
09:57:43 <sm[m]> wavemode: the vty library isn't portable to windows, and it seems nobody can port it
10:03:25 <tomjaguarpaw> Does anyone know why Cabal does in-tree builds for v2-build but out-of-tree builds for v2-install (i.e. the latter are done in a temporary directory with the source files copied inside)
10:03:43 <maerwald> tomjaguarpaw: haha yes it does
10:03:58 <maerwald> v2-install does an sdist, unpacks it to a temporary dir and builds from there
10:04:18 <maerwald> that's a design decision, I guess
10:05:02 <maerwald> which is why I usually do cabal build and then copy the binary manually
10:05:56 <maerwald> cp "$(cabal v2-exec --verbose=0 --offline sh -- -c 'command -v <your-exe>')" /some/where
10:06:14 <tomjaguarpaw> Aha, I was wondering about that, thanks.
10:06:15 * hackage within 0.1.1.0 - A value within another path.  https://hackage.haskell.org/package/within-0.1.1.0 (locallycompact)
10:06:53 <tomjaguarpaw> How do I interpret this magic command?
10:07:11 <maerwald> replace <your-exe> with your executable name
10:07:21 <maerwald> and /some/where with the path it should go in
10:07:49 <tomjaguarpaw> But how does that work?
10:08:07 <tomjaguarpaw> command is a shell builtin?
10:08:19 <maerwald> yeah
10:08:26 <maerwald> it isn't posix
10:08:47 <tomjaguarpaw> It's unsurprisingly hard to searh for
10:08:50 <maerwald> when you run "cabal exec sh", then "sh" will have a special environment of cabal (including stuff added to PATH)
10:09:09 <maerwald> so your binary location will be added to PATH
10:09:21 <tomjaguarpaw> Ah I see.  And command looks up its full pah?
10:09:22 <maerwald> "command -v exe" resolves it to an absolute path then
10:09:33 <tomjaguarpaw> Right, could also use type?  Which is posix, I believe.
10:10:08 <tomjaguarpaw> Or even which
10:10:09 <maerwald> none of that is posix I believe
10:10:13 <tomjaguarpaw> Interesting
10:10:30 <tomjaguarpaw> Well that's very helpful anyway
10:10:37 <tomjaguarpaw> And thanks for your help with ghcup too
10:11:03 <maerwald> Should probably add npm style ads to it, so I make some coin
10:11:09 <tomjaguarpaw> v2-install seems to mean "if my source tree were a package do what you would do to install it", which seams reasonable
10:11:09 <maerwald> :D
10:11:13 <tomjaguarpaw> Hahahaha
10:12:16 <maerwald> yeah, the hard part about v2-install is that it will likely ignore your cabal.project files, unless you added them to extra-source-files (which I'm not even sure is a good idea)
10:12:38 <maerwald> sdist doesn't pack the entire tree
10:12:43 <maerwald> only what is specified by the cabal file
10:13:36 <maerwald> so once I wanted to install my executable with profiling, but the profiling was defined in cabal.project.local
10:13:38 <tomjaguarpaw> Hmmm, well, at least I know now.
10:13:42 <tomjaguarpaw> Ouch
10:13:54 <maerwald> Wasted a lot of time trying to figure out what's going on
10:15:10 <Eugleo> I have a bunch of pairs of types, such as Person+PersonWithID and House+HouseWithID, that differ only by one field (the id). Is it possible to write a function that would be of type `ID -> a -> aWithID`?
10:16:20 <lyxia> Eugleo: like this? https://hackage.haskell.org/package/generic-data-surgery
10:16:39 <Eugleo> I don't like the sound of the url. Will check out, thanks
10:16:59 <wavemode> why not just make a type `data TypeWithId a = TypeWithId ID a`
10:20:03 <Eugleo> lyxia: It seems exactly like what I need! How tf does that work, though. I might have to check some articles on generics
10:21:46 <Eugleo> wavemode: The "as" are coming from frontend, and I need to save them into the db, while the aWithID are coming from the db and I serve them to frontend. And I didn't manage to implement SqlRow for `WithID a` in Selda
10:22:03 <Eugleo> wavemode: But yeah, if I could do that, that would be the best way
10:22:29 <statusfailed> what's the 'right' way to spawn async threads that will die when I Ctrl-C? 
10:28:48 <tomjaguarpaw> maerwald: Thanks for this v2-exec advice.  It's really handy.  I get my git commit hash into my executables using TH and it doesn't work with out-of-tree builds.  I couldn't even find a Setup.hs hook that works.  There's something called autogen-modules that looks useful but I can't see how to use it.
10:29:16 <maerwald> yes, I've had the same problem with commit hash.
10:30:55 <tomjaguarpaw> It's hard to even specify the problem actually.  If you made a source package it would have to get into that somehow, but it's not a source file.  Maybe it could be an autogenerated extra source file?  It needs to be generated at packaging time not a build time, so it's an odd one.
10:31:09 <tomjaguarpaw> Anyway, your workaround will work for me for now.  Thanks!
10:31:54 <Eugleo> lyxia: Any way to keep type variables from function signature in scope for the body?
10:32:05 <Eugleo> ScopedTypeVariables doesn't work
10:32:59 <lyxia> Eugleo: did you make sure to have an explicit forall in the signature?
10:37:36 <Eugleo> lyxia: The code looks like this:
10:37:38 <Eugleo> addId :: Generic a => forall a. Text -> a -> a
10:37:38 <Eugleo> addId s = fromOR . _ . insertRField @"id" @1 @a . toOR
10:38:19 <Eugleo> And the @a throws a  `Not in scope: type variable ‘a’` error.
10:39:58 <lyxia> Eugleo: the forall needs to be before =>
10:40:22 <lyxia> addId :: forall a. ...
10:40:25 <Eugleo> I see.
10:41:12 <Eugleo> I tried that too, but it spit so many errors at me that I reckoned I'll try to put it after the => 
10:43:34 <dsal> Any particular errors?
10:43:36 <lyxia> Eugleo: the type is actually wrong too, since the types before and after adding the ids are not the same, and I just realized to fix this requires a feature I'm still working on. See last comment of https://github.com/Lysxia/generic-data-surgery/issues/6
10:48:45 * hackage shake-plus 0.1.0.0 - Re-export of Shake using well-typed paths and ReaderT.  https://hackage.haskell.org/package/shake-plus-0.1.0.0 (locallycompact)
10:50:06 <Eugleo> lyxia: Oh, right. I thought I'd go toOr -> add id field -> fromOr -> func where I need the ID... Just to be sure, you're saying that woudln't work rn?
10:51:52 <Eugleo> lyxia: As you seem to be skilled in the Generics-stuff, I'd like to ask one more question. Ba any chance, did you ever use Selda?
10:52:42 <Eugleo> This whole thing (me trying to surgically insert id fields) is caused by my inability to write an SqlRow instance for `SqlRow a => WithId (ID a) a`. 
10:52:45 * hackage shake-plus 0.1.0.1 - Re-export of Shake using well-typed paths and ReaderT.  https://hackage.haskell.org/package/shake-plus-0.1.0.1 (locallycompact)
10:52:58 <lyxia> It's possible to make it work by using the internals, but it's not going to be pretty.
10:53:34 <lyxia> I never used Selda, sorry
10:54:21 <tomjaguarpaw> I really wish cabal would say how many packages it has already built and how many to go, when installing a large set of dependencies
10:55:42 <sheepfleece> Hi! Is there a `Generic Map` defined somewhere? I don't mind having an orphan instance too..
10:55:51 <Eugleo> lyxia: I'll continue my search, then
10:55:52 <sheepfleece> `Arbitrary Map` would be also nice.
10:56:16 <Eugleo> lyxia: Thanks for your help :-)  I'll keep an eye out on the surgery lib
10:58:06 <ski> what do you have in mind, sheepfleece ?
10:58:45 * hackage shake-plus 0.1.0.2 - Re-export of Shake using well-typed paths and ReaderT.  https://hackage.haskell.org/package/shake-plus-0.1.0.2 (locallycompact)
10:59:25 <sheepfleece> I have a class with Map inside, I want to test it with QuickCheck. So I need an arbitrary instance of Map for that.
10:59:54 <sheepfleece> I can use List which I would transform into a Map, but then I have to define `shrink` somehow.
11:02:52 <sheepfleece> Which I can easily with a Generic instance for Map, but I don't have one.
11:03:23 <sheepfleece> I think I can write one myself, (or just `shrink`), but it seems like there should be a library for that.
11:04:11 <lyxia> Eugleo: just for reference, this is what it would look like today https://gist.github.com/Lysxia/072dfe1b67678b429b9866119b1b6ffa
11:06:37 <lyxia> sheepfleece: there's nothing Generic about a Map
11:08:14 <lyxia> and QuickCheck already has an Arbitrary instance for Map
11:09:06 <sheepfleece> Oh, it is true, sorry, I somehow missed it. 
11:09:32 <dsal> :t shrinkList -- Also, regarding shrinking a list...
11:09:33 <lambdabot> (a -> [a]) -> [a] -> [[a]]
11:16:15 <mupf> https://twitter.com/mupfelofen/status/1260271728556638209?s=19
11:20:20 <typetetris> how expensive is a forkIO thread? Do I need to pay attention not to create to much of those?
11:21:14 <dsal> Kind of a vague question.  Not too expensive.  Maybe don't make millions of them if you don't have to.
11:21:43 <dsal> Higher level abstractions can be nice.  The async package overall is pretty great, but I end up doing a bit of higher level abstractions over that.
11:23:09 <dsal> e.g.:  `mapConcurrentlyLimited :: (MonadMask m, MonadUnliftIO m, Traversable f) => Int -> (a -> m b)  -> f a  -> m (f b)`
11:23:12 <typetetris> dsal: Each one will be polling some external state every quarter of a second or some such.
11:23:46 <dsal> How many of them?  Is there a better abstraction?
11:24:38 <dsal> In my current project, I threw this thing together to avoid having huge piles of threads lying around sleeping like my first pass:  https://github.com/dustin/mqttd/blob/master/src/Scheduler.hs
11:24:41 <typetetris> dsal: Can't say yet, maybe in the hundreds? If the external system would push its changes, no polling would be necessary :)
11:25:07 <EvanR> forkIO threads are much cheaper than OS threads
11:25:10 <dsal> Hundreds of things polling doesn't sound great.
11:25:45 <EvanR> yeah use notifications if possible
11:25:59 <Cale> typetetris: The thread itself is pretty cheap, most of its cost is the stack that's allocated for it, which is around 1KB
11:29:26 <typetetris> *sigh* If I understood things correctly the external system doesn't even provide long polling ...
11:29:53 <Cale> typetetris: Note that from each thread, you're allowed to do reads that you'd normally think of as blocking, and GHC implements those with nonblocking reads and something like select/epoll/kqueue depending on availability
11:31:26 <typetetris> Cale: That is grea.
11:31:32 <typetetris> s/grea./great./
11:33:13 <EvanR> 'long polling' ?
11:38:43 <dsal> e.g. ask for data and block until it's availble.
11:38:53 <dsal> I need a computer with a new a key.
11:41:07 <dsal> The link above is to the mqtt server I've been writing.  I guess I'm a couple weeks in...  But it's great for this kind of thing.  You could have multiple separate processes on separate machines doing whatever kinds of polling you need and then they can publish results that can be picked up by the processor that's just idling until data becomes available.
11:41:20 <dsal> It also has the advantage of allowing you to take down the processor without dropping any messages.
11:41:41 <dsal> I'm biased, though, because that's what I've been building. heh
11:41:42 <EvanR> ok, same API as waiting for events
11:42:27 <dsal> Instead of one request and waiting, you'd have to loop your requests.  Now you've got that thing where the polling either has to have a lot of latency or produce a lot of load.
11:42:47 <dsal> And then the service owner adds caching to combat the load, but does a bad job.
11:43:39 <EvanR> yeesh. I've been playing with a UDP based scheme without requests. So far seems simpler but well see
11:50:51 <dsal> MQTTv5 is actually pretty nice.  It's TCP, but sessions live beyond TCP sessions, so you can drop connections and still get messages delivered to you. 
11:51:16 <dsal> It answers the immediate scaling problem, anyway.  If you're burning a bunch of CPU and connections to deal with polling hundreds of things a few times a second, whatever work you might want to do when there's actually interesting data might be starved.  At least conceptually being able to isolate that is nice.
11:54:18 <dsal> Or more even more specifically to typetetris' question:  In the described scenario, a thread won't be your bottleneck.  :)
11:57:15 * hackage versions 3.5.4 - Types and parsers for software version numbers.  https://hackage.haskell.org/package/versions-3.5.4 (fosskers)
12:02:16 * hackage mmsyn6ukr 0.6.6.0 - A musical instrument synthesizer or a tool for Ukrainian language listening  https://hackage.haskell.org/package/mmsyn6ukr-0.6.6.0 (OleksandrZhabenko)
13:12:45 * hackage warp 3.3.11 - A fast, light-weight web server for WAI applications.  https://hackage.haskell.org/package/warp-3.3.11 (KazuYamamoto)
13:18:44 * hackage mmsyn6ukr 0.7.0.0 - A musical instrument synthesizer or a tool for Ukrainian language listening  https://hackage.haskell.org/package/mmsyn6ukr-0.7.0.0 (OleksandrZhabenko)
13:24:19 <frdg> What does it mean about the relationship of two objects if there exists both a section and a retraction between them? 
13:24:51 <frdg> ...oops I thought I was in #math
13:38:57 <Eugleo>  Hey, anyone here has experience with Scotty? I have my own kind of actions defined as ActionT [...]. How can I run/use the ActionM () actions inside my ActionT ones?
13:39:12 <Eugleo> (for context: ActionM a = ActionT IO a)
13:39:42 <Eugleo> It's as if I needed to do an "unlift" operation... Not sure how to do that, though
13:41:20 <Eugleo> With one lift, the error says it can't match the types:
13:41:34 <Eugleo> ReaderT Env (ActionT Lazy.Text (SeldaT PG IO)) (Maybe Lazy.Text), and
13:41:47 <Eugleo> ReaderT Env (ActionT Lazy.Text IO) (Maybe Lazy.Text)
13:43:36 <Cale> I'm not sure if Scotty intends for you to try that, but you could write something which runs the ActionT (and the ExceptT, ReaderT and StateT), and then does a liftIO
13:45:16 <dsal> I use ScottyT.  I'm not sure if that's exactly what you're looking for.
13:46:08 <Cale> It's probably easier to go the other way
13:46:36 <Cale> Transform ActionM, and then you can run whatever transformers you added and deal with the fallout in order to produce an ActionM
13:46:57 <dsal> My code is a bit complicated at this point because it also supports websockets, but I end up with my type inside of ScottyT
13:47:13 <dsal> `    application :: ScottyT LT.Text GoPro ()`
13:47:25 <Cale> Since e.g.  defaultHandler :: (Text -> ActionM ()) -> ScottyM ()
13:47:27 <Eugleo> I have to have my db code in ActionM though
13:48:08 <Eugleo> Yeah and I figured out that all the Scotty ActionM producing functions (headers, get ...) have trans-versions in Scotty.Trans
13:48:13 <dsal> e.g., `get "/api/areas" (lift selectAreas >>= json)`  -- (select stuff from the database from within a scotty handler and spit it out as JSON)
13:48:41 <Cale> Those don't produce ActionM's, do they?
13:48:47 <Cale> They take ActionM's as arguments
13:49:06 <Eugleo> Oh well, yes. I meant headers, json etc.
13:49:09 <Cale> Oh, I see
13:49:12 <Eugleo> But it's relevant for get as well
13:49:37 <Cale> Yeah, that's useful, it can take something of type ActionT e m () and produce a ScottyT e m ()
13:49:59 <Eugleo> I was somehow trying to get my ActionT to ActionM to play nice with Scotty's functions, and just now saw that Scotty has dedicated versions that work with ScottyT >.> Too late here, sorry
13:53:01 <Eugleo> Does that mean, though, that I'll be able to "run" the very inmost monad only at the top level? To explain: Let's say I have a stack of ReaderT ActionT Database. The order they're executed in will be runReaderT -> get /route ActionT -> and only then runDatabase, right? So that would mean that I'll be able to "run" the database only at the
13:53:01 <Eugleo> top-level, from where I call scottyT?
13:54:11 <Cale> Eugleo: Look at the scottyT/scottyAppT/scottyOptsT functions
13:54:20 <Cale> They take a parameter of type
13:54:27 <Cale> (m Response -> IO Response)
13:54:36 <Cale> which is supposed to explain how to run the monad m
13:55:04 <Cale> and which apparently gets used for each action
13:55:24 <dsal> My state is just in an env in the reader.  So I extract it and then rewrap it inside the ScottyT.
13:55:30 <Eugleo> Oh, so I run the database monad from within the scottyT, I see. That means I can run db for each route if I want.
13:55:57 <Eugleo> (and not only the db monad, but the whole stack ofc)
13:56:18 <Cale> It's kind of unfortunate that it sort of forces that
13:56:20 <Cale> but yeah
13:56:35 <dsal> I got rid of the concept of a stack in the recent versions in favor of just having a newtype that does the things.  Made things a lot easier.
13:57:35 <dsal> `deriving (Applicative, Functor, Monad, MonadIO, MonadUnliftIO, MonadCatch, MonadThrow, MonadMask, MonadReader Env, MonadFail)` and then some handwritten instances of a few other things (Alternative, MonadLogger, some custom stuff)
13:57:39 <Cale> If you have to think of your monad as a stack of monad transformers, then something is wrong.
13:57:53 <koz_> dsal: Yeah, it's the old 'newtype deriving ALL THE THINGS' I've grown all too familiar with.
13:58:13 <Cale> (at least apart from in very small pieces of the code)
13:58:17 <dsal> Need a new deriving strategy (*)
13:58:24 <Eugleo> Cale: not used to think of MTs as single types, bit sounds nice
13:59:03 <koz_> dsal: You mean 'kitchen sink' right?
13:59:05 <Eugleo> dsal: so, is this the kind of Haskell style I've heard of as being orthogonal to mtl?
13:59:10 <Cale> The uses of lift should usually be pretty well confined to the definitions of very basic operations in your monad
13:59:15 <koz_> 'newtype Foo a = ... deriving kitchen sink'.
13:59:25 <dsal> koz_: Yeah.  Deriving *
13:59:46 <koz_> * is a bit non-descriptive. Plus, makes work even harder for the poor parser.
13:59:47 <Cale> But usually you don't want deriving MonadReader
13:59:51 <dsal> Eugleo: No, it's not free monads or anything.  It's just not having an explicit stack of types when you could just have a single type.
14:00:04 <wavemode> at a certain point, I wonder why people don't just use IO
14:00:16 <dsal> Why?  IO would be harder.
14:00:18 <Eugleo> Does it have any pros/cons other than not having to lift everything every time?
14:00:23 <Cale> wavemode: Monad transformers certainly get overused
14:00:26 <koz_> MyLittleMonad a is a lot easier to write that 'ThisT a (ThatT b (AnotherT c)) d'
14:00:45 <dsal> It's a lot easier to think about.
14:01:20 <Cale> You also shouldn't let mtl's operations spread throughout too much of your code most of the time
14:01:43 <Eugleo> koz_: Not that anyone isn't just using type MyLittleMonad a = ThisT a (ThatT b (AnotherT c)) d anyway
14:01:45 * hackage network-byte-order 0.1.5 - Network byte order utilities  https://hackage.haskell.org/package/network-byte-order-0.1.5 (KazuYamamoto)
14:01:55 <koz_> Eugleo: I am not a fan of type synonyms.
14:02:00 <Cale> Usually there's something much nicer than ask or get/put which you ought to make your own type class for
14:02:10 <Eugleo> > You also shouldn't let mtl's operations spread throughout too much of your code most of the time
14:02:12 <lambdabot>  <hint>:1:68: error: parse error on input ‘of’
14:02:14 <koz_> Just newtype already - you'll probably want different semantics soon.
14:02:15 <Eugleo> What does that mean, Cale?
14:02:15 <dsal> Eugleo: I was doing that originally in this project.  Once I stopped, it got easier.
14:02:56 <Cale> Eugleo: I mean, instead of using ask/asks from MonadReader, consider defining something more particular -- why does the environment exist? What operations is it enabling?
14:02:56 <Eugleo> dsal: I believe you, seems a lot easier. Just trying to find the tradeoffs that come with this (if any)
14:03:27 <Cale> It can be okay to still have an operation that simply gets you the environment, but there's still probably a better name for it than 'ask'
14:03:43 <nh> nil: that's true, but continue anyway
14:03:45 <Eugleo> Could "Monadreader" be substituted with "ReaderT stack" in the sentence?
14:03:56 <Cale> and making a class for that operation will make sure the names won't conflict when you have another ReaderT later
14:03:57 <dsal> MonadReader is a class.
14:04:07 <Cale> No
14:04:11 <Cale> right
14:04:12 <Eugleo> Sorry
14:04:23 <Eugleo> Will try to reformulate
14:04:23 <Cale> MonadReader is a class, ReaderT is a monad (transformer)
14:04:42 <Cale> It's possible to define MonadReader instances for monads that aren't constructed using ReaderT
14:04:47 <Cale> but you usually wouldn't bother
14:05:00 <Cale> Usually there's a better class you'd prefer to use, but you have to write it yourself
14:05:05 <Eugleo> Is your point to find better and semantically appropriate functions for your particular type? Or jost MonadReader specifically being bad?
14:05:37 <Cale> The former, mostly... let MonadReader just be a convenience for defining the operations you actually care about
14:06:32 <Eugleo> Yeah, that's what I meant originally with the substituting: I mean, instead of using ask/asks from [some implementation of the Reader idiom], consider defining something more particular
14:06:37 <Cale> E.g. If you have a ReaderT which is carrying around a database connection, well, why are you carrying that DB connection around?
14:06:44 <Cale> Presumably to be able to make queries
14:07:10 <dsal> So like, don't do this?  :)   `instance (Monad m, MonadReader Env m) => HasGoProDB m where goproDB = asks dbConn`
14:07:14 <Eugleo> ...so it's better to just be in some DatabaseM from start?
14:08:07 <Cale> dsal: You can't really do that in the first place
14:08:24 <Cale> dsal: Not if you want to have any other instances of HasGoProDB anyway...
14:08:53 <Cale> and yeah, that goproDB operation looks a bit... well, it's probably not getting to the point of what's going on
14:09:10 <Cale> It could be fine to offer such a function
14:09:41 <Eugleo> Are there any antipatterns that would suggest "hey, is this monad _really_ the right fit"?
14:09:46 <Cale> But you probably want to at least immediately define a bunch of stuff in terms of it, and there might be some benefit to remaining more abstract than that -- you don't really care about the dbConn probably
14:10:27 <Eugleo> As in: "db in your Reader? Pause and think" type of thing
14:10:59 <Cale> Eugleo: Well, ask yourself what each constraint that's constraining a variable monad means, and ask yourself what each monad transformer means
14:11:04 <dsal> I just have a bunch of database operations that want a database.  I'm not sure what else I'd use this for.
14:11:12 <dsal> Er, how else I'd define this.
14:11:33 <Cale> If it's hard to express that in English, or the answer seems in some way obtuse, maybe a different class/transformer would be better
14:12:23 <Cale> dsal: Well, you could add those operations to the class...
14:12:29 <dsal> e.g., it doesn't make sense to have a class that contains all of the specific operations does it?
14:12:37 <Cale> Doesn't it?
14:13:04 <Cale> Maybe not directly as members (though there's no reason they couldn't be members with default implementations)
14:13:14 <Eugleo> Isn't that what Cale was trying to point out as good?
14:13:30 <Eugleo> i.e. be specific about your needs and use fitting abstractions
14:13:33 <Cale> But there should be a class which means "I have this set of operations for querying my database"
14:13:39 <Eugleo> ofc if they're still abstractions
14:13:49 <Eugleo> Cale: Interesting way to approach things.  Will try to use in my day-to-day coding, thanks!
14:14:59 <Cale> Well, and that class should probably only exist if you need those operations from more than one monad, but, it tends to be useful to do things that way, because eventually you always might want to build some new monad from your existing one.
14:15:07 <Eugleo> One last thing; I'd still have to use others' monad(transformer)s, right? I.e. ScottyT, SeldaT (db lib) etc.
14:15:14 <Cale> Yeah
14:15:18 <dsal> At a high level, I want stuff like the above `selectAreas` to get a list of `Area`s.  But I have different types of things that are inserted, updated, selected, deleted and sometimes in different ways.   It made sense to me to just give them access to a DB and not try to build a type of all of those operations.
14:15:30 <Cale> and libraries' monad transformers don't always make perfect sense, sadly
14:16:10 <Eugleo> "might want to build some new monad from your existing one"? Could you elaborate?
14:16:22 <Eugleo> Adding some functions to a class I can understand
14:16:30 <Eugleo> Spinning a new monad I can not :D  
14:17:32 <Cale> Eugleo: Well, why are we in a monad that isn't IO to begin with?
14:17:45 * hackage mmsyn6ukr 0.7.1.0 - A musical instrument synthesizer or a tool for Ukrainian language listening  https://hackage.haskell.org/package/mmsyn6ukr-0.7.1.0 (OleksandrZhabenko)
14:18:04 <Cale> The same kind of reason can come up to build another abstraction on top of your new monad.
14:18:59 <Cale> I guess I can provide an example from reflex-vty... we had a widget monad for things that could control part of the terminal, draw characters in it and process user input, filtering it to its children
14:19:02 <Eugleo> Yeah, I was thinking of how can I build something on top of it. Didn't think of MyMonad1 a => MyMonad2 a. It's getting late
14:19:55 <Cale> and then we wanted a monad to handle layout of widgets and allocation of screen real-estate in a smarter way than simply nesting widgets could provide
14:20:19 <Cale> so that was a good reason to have a transformer to manage the extra layout constraints
14:20:55 <Eugleo> Makes sense.
14:21:39 <Eugleo> And from the stylistic POV, dsal's approach of newtypes isn't inherently worse than using the transformers, right?
14:21:57 <Eugleo> It has the same kind of pitfalls (unfitting abstractions), but not any addition ones
14:22:03 <Eugleo> additional*
14:22:22 <Cale> Yeah, newtypes only help things
14:22:44 <Eugleo> Good to hear
14:22:50 <Eugleo> Good night everyone! Thanks for the discussion, dsal and Cale!
14:22:50 <Cale> and they can hide the incidental things like when MonadReader is being used to accomplish something
14:23:04 <Cale> you don't need to have MonadReader on your new monad or transformer
14:23:08 <Cale> you can just have the better class
14:44:58 <koz_> Is there a binary search for vectors implemented somewhere?
14:45:03 <koz_> (under the assumption of order, of course)
14:48:24 <phadej> koz_: https://hackage.haskell.org/package/vector-algorithms-0.8.0.3/docs/Data-Vector-Algorithms-Search.html
14:51:02 <koz_> phadej: Thanks!
14:55:22 <refried_> Hi Will `fmap (const y) (x >>= pure . f)` have the same performance as `x >>= pure . const y`, meaning `f` doesn’t get called?
14:55:35 <refried_> +punctuation
14:55:43 <refried_>  / english
14:57:01 <xerox_> not for strict monads I guess
14:57:06 <monochrom> I won't comment on possible tiny differences in "performance".  But f won't get called.
14:58:37 <wavemode> this is just abstract code, the performance will depend on the implementation of the monad. what sort of performance issue are you worried about?
15:00:12 <wavemode> or perhaps you didn't mean "performance" in the sense of "how many nanoseconds will this take to execute"
15:04:47 <koz_> % :info ($>)
15:04:48 <yahb> koz_: ($>) :: Functor f => f a -> b -> f b -- Defined in `Data.Functor'; infixl 4 $>
15:30:48 <refried_> monochrom: Sorry yeah, I just want to be sure the pure function `f` there won't get called, if I `void` on the outside
15:33:16 <refried_> wavemode: I'm trying to avoid calling `f`, by putting that `fmap (const y)` on the outside
15:33:51 <wavemode> in that sense, the two are equivalent
15:34:24 <dsal> refried_: Thinking of functions as being called is possibly a point of confusion.
15:37:39 <nil> does GHC have a way of deriving an Applicative instance from a Monad instance?
15:38:00 <nil> (i just want to avoid typing  instance Applicative Foo where pure = return; (<*>) = ap)
15:38:25 <lyxia> deriving via WrappedMonad MyMonad
15:39:20 <nil> nice
16:01:15 * hackage hinterface 2.0.0 - Haskell / Erlang interoperability library  https://hackage.haskell.org/package/hinterface-2.0.0 (SvenHeyll)
16:02:14 <davean> nil: return      = pure in the Monad class so you just define pure in Applicative and don't do return in Monad normally
16:03:38 <nil> yeah, i know; the context is i'm defining a free monad, and (<*>) is somewhat tedious to write down (3 cases, can you imagine!?), so i was trying to cheat
16:03:54 <pong> wow much lazy
16:04:06 <nil> hi pong
16:04:09 <koz_> Very productivity.
16:04:10 <koz_> Amaze.
16:04:29 <pong> reminds me of that guy who spent 16 hours automating a 10 minute task
16:05:21 <nil> isn't that every programmer ever
16:07:19 <koz_> Automation is its own reward.
16:10:00 <monochrom> >>= is usually less tedious to code up than <*>
16:10:18 <monochrom> OTOH >>= also needs more cleverness
16:10:39 <koz_> Recent example I saw was Edward's talk about combinator calculus shindigs for bound variable tricks.
16:10:46 <monochrom> during learning, it can be helpful to figure out <*>, though more tedious, before figuring out >>=
16:10:47 <koz_> Defined (>>=), then defined <*> as ap and moved on.
16:11:38 <monochrom> Yes, for professional work, if you know it is a monad, just code up >>= and use ap for <*>. Unless efficiency concerns.
16:23:43 <maralorn> I wonder if one could define applicative with just `pure ()`, but not `pure`.
16:25:04 <nil> given  unit :: f ()  ,  pure x = fmap (const x) unit
16:25:38 <nil> (but now you explicitly depend on the Functor superclass)
16:26:08 <koz_> nil: Yeah, that's the Monoidal derivation described in the Typeclassopedia I think.
16:26:51 <nil> indeed https://wiki.haskell.org/Typeclassopedia#Alternative_formulation
16:32:23 <maralorn> Interesting.
16:32:41 <maralorn> e.g. relude has pass = pure () I use that one quite often.
16:41:33 <nil> this is just wrong, isn't it https://en.wikipedia.org/wiki/Monad_(functional_programming)#Free_monads
16:41:42 <nil> "by working entirely through the Just and Nothing markers, the Maybe monad is in fact a free monad"
16:42:26 <nil> i'm also not sure what the next sentence is saying
16:44:03 <nil> the pseudo-code also makes no sense... who wrote this
16:46:14 <maralorn> nil: You say Maybe is not a free Monad?
16:47:02 <nil> it's not; it destroys the number of nested Justs
16:49:22 <maralorn> Yeah, that sounds plausible.
16:49:41 <davean> https://en.wikipedia.org/w/index.php?title=Monad_%28functional_programming%29&type=revision&diff=870941044&oldid=870552565
16:49:50 <davean> Zar2gar1
16:51:29 <maralorn> > This user is a mathematician.
16:51:31 <lambdabot>  <hint>:1:30: error:
16:51:31 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
16:52:03 <maralorn> lambdabot: Does not agree.^^
16:55:59 <iqubic> data Free f a = Pure a | Roll (f (Free f a))
16:56:24 <iqubic> That's the free monad
16:56:43 <nil> that's *a* free monad over f
16:58:51 <lyxia> nil: Maybe is the free monad with respect to the functor (Const ())
16:59:24 <nil> aaah
16:59:42 <lyxia> the free monad (wrt to a functor f) is unique up to isomorphism, that's why we say "the free monad"
17:00:43 <nil> yes, i was merely pointing out that there are more than one way to define it (even if they're all isomorphic)
17:01:04 <remexre> is it reasonalbe w/ recursion-schemes to name ctors like MyType'Foo and define pattern synonyms like Foo a = Fix (MyType'Foo a)
17:01:06 <remexre> ?
17:01:08 <hololeap> so then `Either b a` is isomorphic to `Free (Const b) a`...
17:01:18 <maralorn> Free (Const ()) a = Pure a | Roll (Const () (Free (Const () a)) = Pure a | Roll () = Just a | Nothing
17:01:53 <monochrom> I prefer using the Proxy functor but yeah.
17:01:58 <maralorn> hololeap: cool
17:02:01 <nil> lyxia: re Maybe, i don't think that's what the author meant
17:02:58 <lyxia> what do you think they meant
17:03:42 <lyxia> Note I'm not saying the explanation is not shit.
17:03:43 <nil> i think they meant that the (Haskell) Maybe monad was the free monad over the Maybe functor
17:03:45 <hololeap> `(b,a)` is isomorphic to `Cofree (Const b) a`... just realized that as well
17:03:58 <nil> "by working entirely through the Just and Nothing markers" looks suspicious
17:05:12 <lyxia> that would be an incorrect explanation, so I'm tempted to be generous and assume the author had a correct interpretation in mind, so that's not what they meant.
17:05:54 <monochrom> The text I see is "For example, by working entirely through the Just and Nothing markers, the Maybe monad is in fact a free monad. The List monad, on the other hand, is not a free monad since "
17:06:55 <monochrom> But you've got to see its pseudocode for arbitrary free monad of functor F :)
17:07:40 <hololeap> I thought the List monad was a free monad
17:07:57 <monochrom> It would make it to dailywtf if dailywtf would understand broken functional code :)
17:08:05 <nil> maybe you're thinking of free monoids?
17:11:01 <hololeap> Maybe I'm confused... If something is isomorphic to some `Free f a`, does that make it a free monad?
17:11:10 <monochrom> Yes.
17:11:24 <nil> well, to some Free f
17:11:52 <monochrom> But I can't come up with a suitable f for [].  Could you help?
17:12:11 <hololeap> So [a] === Free ((,) a) ()
17:12:56 <Wes28> I'm going through LYAH, and I got to the section about Random generators, but I can't seem to load System.Random.
17:12:56 <monochrom> I think that's no fair.  It needs to be [] = Free F.
17:14:01 <hololeap> Yeah, I don't think that's possible then
17:17:04 <wavemode> Wes28: in a file or in the repl? what happens when you try?
17:17:46 <Wes28> I was using WinGHCi. I would write import System.Random and it told me it could not find the module.
17:17:55 <Wes28> Also tried it directly in ghci
17:21:05 <Wes28> I'm on a different computer now with a newer version of ghci (8.10.1) and doing :browse System.Random => could not find module System.Random
17:21:22 <refried_> thanks wavemode 
17:23:24 <wavemode> Wes28: you have to install the random package. try to `cabal update` and then `cabal install random` and then `cabal repl`
17:23:33 <dmwit> hololeap: Also, the isomorphism has to be a monad isomorphism, not just any old unstructured isomorphism.
17:24:00 <dmwit> Just a fancy way of saying: the Monad instances have to be the same, it's not enough to just have the same collection of values.
17:29:47 <Wes28> wavemode, It seems like I installed it (although it asked me to use the --lib flag), but when I get in the repl, it still acts like it doesn't know what System.Random is when I import it
17:31:01 <wavemode> Wes28: in the cabal repl do `:set -package random`
17:31:04 <Wes28> Actually now it says I need to add random to the build depends in my .cabal file.
17:31:33 <koz_> If I have Either Foo a, and I wanna preview over the 'a' using a Prism' (from Optics) 'p', do I have to use fmap, or does Optics have me covered?>
17:31:39 <wavemode> yeah lol this is all normally taken care of with project files and such
17:31:40 <Wes28> that did it
17:32:50 <Wes28> wavermode, do i need to set up a project for going through LYAH?
17:33:20 <wavemode> I haven't read it so I wouldn't know
17:34:54 <Wes28> wavermode, more generally for learning, how do I install packages globally so that I can bring them in scope for playing about?
17:40:47 <wavemode> well what you did just now is one way
17:41:43 <wavemode> if you want to just list packages in a project file and have them loaded automatically, you set up a cabal project
17:42:00 <wavemode> pretty much `cabal init` in a new folder and `cabal repl` inside
17:42:12 <wavemode> you can learn how the cabal file works: https://www.haskell.org/cabal/users-guide/developing-packages.html
18:01:22 <dsal> koz_: That's pretty much what preview does.
18:02:07 <dsal> > Left 3 ^?  _Right
18:02:10 <lambdabot>  Nothing
18:02:11 <dsal> > Right  3 ^?  _Right
18:02:13 <lambdabot>  Just 3
18:02:49 <dsal> > Right  (Just 3) ^?  _Right . _Just
18:02:51 <lambdabot>  Just 3
18:03:21 <dsal> The `_Right` prism gets you into the right side, and the `_Just` prism gets me to the 3
18:04:27 <koz_> dsal: Ooh, cool.
18:17:46 * hackage monadic-recursion-schemes 0.1.3.0 - Recursion Schemes for Monadic version.  https://hackage.haskell.org/package/monadic-recursion-schemes-0.1.3.0 (KatsutoshiItoh)
18:24:15 * hackage monadic-recursion-schemes 0.1.3.1 - Recursion Schemes for Monadic version.  https://hackage.haskell.org/package/monadic-recursion-schemes-0.1.3.1 (KatsutoshiItoh)
18:28:15 * hackage dataflower 0.1.0.0 - A Pure-Haskell Timely Dataflow System  https://hackage.haskell.org/package/dataflower-0.1.0.0 (jessekempf)
18:32:45 * hackage monadic-recursion-schemes 0.1.3.2 - Recursion Schemes for Monadic version.  https://hackage.haskell.org/package/monadic-recursion-schemes-0.1.3.2 (KatsutoshiItoh)
18:37:46 * hackage monadic-recursion-schemes 0.1.3.3 - Recursion Schemes for Monadic version.  https://hackage.haskell.org/package/monadic-recursion-schemes-0.1.3.3 (KatsutoshiItoh)
18:43:54 <jphaskell> are there any examples of haskell source written in japanese or other non- English languages?
18:46:11 <dsal> How do you say MonadFail in Japanese?
18:47:39 <jphaskell> :)  I don't know. My Japanese is not that great.
18:47:58 <jphaskell> I was just curious
18:48:04 <jphaskell> I am
18:48:47 <dsal> Some of the concepts will be written in whatever language has words like "Profunctor", but your local symbols can be something else.  So it can't totally Japanese.
18:48:51 <MarcelineVQ> MonadoFayoru
18:49:27 <dsal> But in Kanji
18:50:17 <jphaskell> how is upper case/ lower case determined?
18:50:28 <jphaskell> for Type vs function names
18:50:28 <dsal> Character classes in unicode.
18:50:40 <dsal> But that's like, a differently annoying thing in practice.
18:50:42 <MarcelineVQ> why would it have a kanji?
18:54:00 <jphaskell> -- Teluguమీ_పేరు = 1 -- hiraganaてす= 2--Teluguసరిగమ = 3
18:54:18 <jphaskell> the first one fails, but the other two pass!! 
18:58:56 <MarcelineVQ> tesu? テスト ガ?
19:00:01 <jlebar> Looking for help improving a function I've written.  https://pastebin.com/4cGvpYL9  This finds all ways to partition a list "in order", i.e. if a partition contains [..., yi, yj, ...] then yi appears before yj in the initial list.
19:00:01 <jlebar> What I don't like about this is that the `map (addAt part) [0...length part -1]` feels like an imperative program.  I'm basically writing a hard-to-read for loop to find the N ways I can stick `x` at the back of one of the sublists in `part`.
19:00:01 <jlebar> Is there a better way?
19:08:45 * hackage unexceptionalio 0.5.1 - IO without any non-error, synchronous exceptions  https://hackage.haskell.org/package/unexceptionalio-0.5.1 (StephenWeber)
19:12:50 <MarcelineVQ> jlebar: dunno overall but   addAt p i = let (a, b) = splitAt i p in a ++ [head b ++ [x]] ++ tail b     addAt p i = let (a, (b:bs) = splitAt i p in a ++ b : x : bs
19:45:42 <crestfallen> hi quite lost in the state monad/ functor/ applicative. anyone mind showing me how to use fmap on lines 7-13   ?    https://github.com/varreli/haskell/blob/master/hutton/85_chapt12/state.hs
19:47:01 <crestfallen> totally confused by this still..
19:47:53 <koz_> crestfallen: Can you be more specific about what's confusing you?
19:50:01 <crestfallen> thanks koz_   I'd just like to see fmap in action. I have no idea how to use it or what to expect
19:50:35 <koz_> OK, so you can see that State a is just a fancy way of saying 'State -> (a, State)'.
19:50:53 <koz_> So what fmap does is, given a -> b, take us from 'State a' to 'State b'.
19:51:05 <crestfallen> ok
19:51:18 <koz_> Essentially, it allows us to operate on _stateful_ values of 'a', without touching the state.
19:51:48 <koz_> Easy example: You can't normally use 'negate' on State Int.
19:51:51 <koz_> :t negate
19:51:52 <lambdabot> Num a => a -> a
19:52:10 <koz_> Obviously, even if we have (Num a), State a is not a Num.
19:52:21 <koz_> But we _can_ use negate on State Int if we're helped by fmap
19:52:23 <koz_> :t fmap negate
19:52:24 <lambdabot> (Functor f, Num b) => f b -> f b
19:52:45 <koz_> If you set f ~ State, the type of that becomes '(Num b) => State b -> State b'.
19:52:50 <koz_> With me so far?
19:53:24 <crestfallen> well, back where you said " it allows us to operate on _stateful_ values of 'a', without touching the state."   ...
19:53:59 <ski> (fwiw, you're using `State' in two different ways)
19:54:15 <koz_> Oh sorry, that's bad of me.
19:54:21 <koz_> I should have said something like
19:54:36 <koz_> What fmap does is, given a -> b, take us from 'ST a' to 'ST b'.
19:54:50 <koz_> I should read more carefully lol.
19:55:32 <crestfallen> I've been stuck on this file for months
19:56:04 <koz_> crestfallen: OK, we get that. However, 'lol dunno' isn't a good way of resolving confusion.
19:56:16 <koz_> Specifically identifying _what_ throws you is the first step to getting somewhere.
19:56:31 <koz_> Is the issue 'I have no idea in what set of circumstances fmap would be useful?'.
19:56:33 <[rg]> does the name mathew naylor ring a bell?
19:56:44 <koz_> s/?'./?'?/
19:56:51 <koz_> [rg]: Can't say it does.
19:57:10 <wavemode_> crestfallen: are you working through the first principles book?
19:57:20 <ski> @where PIH
19:57:20 <lambdabot> "Programming in Haskell" by Graham Hutton in 2007-01-15,2016-09-01 at <http://www.cs.nott.ac.uk/~pszgmh/pih.html>
19:57:22 <ski> it looks like
19:58:00 <crestfallen> PIH
19:58:02 <koz_> How do you folks render 'PIH'? 'Pee-aye-eych'? 'Pie'? Some other way?
19:59:18 <wavemode_> pee-aye-eych
19:59:25 <wavemode_> pie is just silly
19:59:47 <ski> hm. i guess i might try to say "Pih"
20:00:28 <koz_> ski: With a hard 'H'?
20:02:12 <ski> not quite sure what "hard" means here, but i suspect yes
20:02:43 <wavemode_> I didn't realize H's could be hard
20:03:15 <electricityZZZZ> so when i used C# somebody set our application up with an interactive ironpython shell which could interactively access objects in the running program. does haskell have a similar feature?
20:03:15 <koz_> ski: I meant 'the sound of the 'h' is a voiceless velar fricative'. 
20:03:28 <electricityZZZZ> can i "include ghci in my program" trivially and have a program console?
20:03:39 <koz_> electricityZZZZ: Probably not _trivially_, but hint exists.
20:03:44 <koz_> @hackage hint
20:03:45 <lambdabot> http://hackage.haskell.org/package/hint
20:04:05 <ski> crestfallen : oh, you want to use `fmap' to implement `fmap' ?
20:05:01 <ski> (this is where `State -> (State,a)' would have been nicer, btw)
20:05:10 <electricityZZZZ> koz: cool thanks
20:05:35 <koz_> electricityZZZZ: Do you just want a scripting layer to an existing Haskell codebase or something?
20:06:11 <lyxia> jlebar: https://gist.github.com/Lysxia/4061ec91653289c50db9bd109cb0a49c
20:06:32 <wavemode_> "interactively access objects in the running program" may be a bit more involved
20:07:05 <crestfallen> ski not sure what i want. i just don't know how to run any of these, what to use as arguments, nothing
20:07:47 <ski> crestfallen : you need some actions that does something interesting, to test with
20:08:28 <ski> crestfallen : e.g. `tick :: ST Int; tick = S (\n -> (n,n+1))' is a simple one
20:09:35 <ski> now you can try e.g. `map (app (fmap even tick)) [0 .. 9]' as a simple example
20:10:47 <electricityZZZZ> koz: what would be the alternative to a scripting layer?
20:11:09 <ski> or even just `app tick 0' vs. `app (liftA2 (,) tick tick) 0'
20:11:10 <crestfallen> thanks kindly ski, working...
20:11:50 <ski> crestfallen : have you seen `liftA2' ? `sequence' (or `sequenceA') ? `replicateM' ?
20:14:33 <ski> crestfallen : `app' is used to run a `ST'-action (being a value of type `ST T', for some type `T'. being a "state transformer", on the state type `State' (which is just `Int' here). note that such a value hasn't been given an initial state yet, to work with), giving it its initial state, so that it can compute a result (of type `T', say), and a final state
20:15:02 * ski idly wonders whether `replicateM' will be renamed into `replicateA', at some point
20:15:21 <crestfallen> I think I've used sequenceA. I just can't keep all this stuff in my head. ski
20:15:32 <ski> crestfallen : could you describe in words, what `tick' does ?
20:15:52 <crestfallen> tick == increment
20:16:10 <crestfallen> it's a counter
20:16:18 <ski> yep. move the "clock" along one step. also giving back as result the previous value of the state
20:16:30 <crestfallen> cool
20:16:50 <ski> you could also think of it as allocating `Int's, and the state is the next unused `Int' that hasn't been allocated yet
20:17:29 <crestfallen> allocating Int's. ?
20:17:37 <ski> so, if you start by calling `app' on an action, with initial state `0', the first execution of `tick' will give back zero as first result. next execution will give back one, and so on
20:19:18 <ski> yea. e.g. you might be generating assembler code to work on a stack machine, and each time you need a new temporary (e.g. mutable) variable, you want a new position on the stack to hold it. so `tick' could be used to give the next unused position. and the final state is then the number of allocated stack slots, assuming you started counting at zero
20:20:26 <ski> any time you want to generate a fresh something, that's not equal to any previously generated thing, you could use something like `tick'
20:21:19 <ski> crestfallen : another example is to write a function `Tree a -> ST (Tree (a,Int))', where you label the elements of a `Tree' (pick any favorite reasonably kind of tree)
20:21:33 <crestfallen> above you said " start by calling `app' on an action "  . what is the action, is it say (fmap even tick). ?
20:22:22 <crestfallen> I only am used to action in re: to monads
20:22:23 <ski> writing such a function, using `ST', is less tedious (and less errorprone), than writing it explicitly (not hiding the state passing plumbing, that the operations at the link you provided performs)
20:22:55 <ski> yes. `tick' here would be an `ST'-action, and `fmap even tick' another `ST'-action
20:24:17 <crestfallen> PIH is extremely terse in this section. it makes me sad. 
20:24:28 <ski> (`fmap' here takes a function (on action execution results), and an action, and produces another action. when executed, the returned action will first execute the input action. then, it will call the callback post-processing function on the result of that, giving back the output of that as result of executing the returned action)
20:25:20 <ski> (that's somewhat of a mouthful to state, but hopefully the idea should get across as not too involved)
20:25:55 <crestfallen> yeah I can't get my teeth into that one .. sorry
20:26:20 <crestfallen> but the examples are very helpful
20:26:52 <ski> it's more common to use the "collection" terminology/analogy with types `F' that are instances of `Functor'. however, your `ST' is already also an instance of `Applicative' and `Monad'. and, it's harder (or more of a stretch, if you prefer), to think of `ST T' as some kind of "collection" of `T's
20:27:44 <ski> so, i think the action/recipe analogy/terminology is better to use, with `ST' here, even when only using the `Functor' instance, not the `Applicative' or `Monad' one
20:28:21 <ski> crestfallen : you know `replicate', yes ?
20:28:26 <crestfallen> yes
20:28:34 <ski> > replicate 7 '*'
20:28:36 <lambdabot>  "*******"
20:28:38 <ski> consider
20:28:59 <ski>   replicateM :: Applicative i => Int -> i a -> i [a]
20:29:12 <ski>   replicateM n act = sequenceA (replicate n act)
20:29:31 <ski> what does `replicateM 4 tick' do ?
20:32:44 <crestfallen> I'm assuming [1111,2222,3333...]
20:33:46 <ski> well, `replicate 4 tick' will be a list `[tick,tick,tick,tick]', of type `[ST Int]'
20:34:50 <ski> then, `sequenceA' has type `Applicative i => [i a] -> i [a]'. in this case, calling `sequenceA' on that list, the argument type `[i a]' would have to be equal to `[ST Int]', so `i' would be `ST' and `a' would be `Int', in this case
20:35:15 <ski> (and we know `Applicative ST' holds, because you made such an instance, so we're allowed to call `sequenceA' in this case)
20:35:37 <ski> so, the result of calling it would have type `i [a]', which here would then be `ST [Int]'
20:36:44 <ski> iow, `replicateM 4 tick' is `sequenceA (replicate 4 tick)' is `sequenceA [tick,tick,tick,tick]', and that last function call takes us from `[ST Int]' to `ST [Int]'
20:36:53 <ski> crestfallen : is this making any sense to you, so far ?
20:38:55 <crestfallen> some parts very much so. if I may stop there. I need to get on a larger screen and go through these examples. thanks you're a natural teacher ski. really appreciate it.
20:40:15 <ski> anyway, this last call, to `sequenceA', takes us from a list of actions (which haven't been performed/executed/run yet, remember. they're just inert descriptions of something that could be executed, in the future. perhaps out of order, perhaps multiple times, perhaps none)
20:40:49 <ski> .. takes us from a list of actions, to a single action -- whose execution will yield a result that is a list of `Int's
20:42:17 <ski> and, if you remember what `sequenceA' does, it takes its list of actions, and "glues" them together into a single large action. when (if) later executed, this action will execute, in the order given, all the actions in the list. and it will collect all the individual results of those executions, into a list, and yield this list as final result of executing the `sequenceA [...]' action
20:42:50 <ski> so .. in this case, `sequenceA [tick,tick,tick,tick]' will simply execute `tick' four times, and give back a list of the four results of each such execution
20:43:29 <ski> if you try e.g. `app (replicateM 4 tick) 10', you should be able to confirm that this appears to be the case (starting at ten rather than zero, just for variety)
20:44:43 <crestfallen> ski let me run with that .. thanks again
20:44:58 <ski> crestfallen : btw, if you don't know how `sequenceA :: Applicative i => [i a] -> i [a]' works, you could try to implement it yourself. could be a useful exercise
20:45:18 <crestfallen> copy that
20:45:35 <ski> i would also suggest trying out my "tree labelling" exercise. operations like `liftA2',`liftA3',&c. might be useful
20:45:49 <ski> but, perhaps you need to try more simple examples, first
20:46:03 <crestfallen> yeah this is plenty thanks
20:46:35 <ski> anyway, i'll leave at this point, but hopefully you have enough to process and go over, being able to make some progress
20:46:56 <crestfallen> thanks very helpful!
20:47:18 <ski> (perhaps later, if i'm here, i could try to give some further elaborations)
20:47:27 <ski> no problem
20:48:48 <ski> oh. and doing the tree labelling, without something like `ST', but "manually / explicitly", could also be helpful. to see how much (and what) `ST' (and its `Functor',`Applicative',`Monad' instances) buys you
20:50:45 * hackage dataflower 0.1.1.0 - A Pure-Haskell Timely Dataflow System  https://hackage.haskell.org/package/dataflower-0.1.1.0 (jessekempf)
21:23:46 * hackage dataflower 0.1.2.0 - A Pure-Haskell Timely Dataflow System  https://hackage.haskell.org/package/dataflower-0.1.2.0 (jessekempf)
22:18:16 * hackage dataflower 0.1.3.0 - A Pure-Haskell Timely Dataflow System  https://hackage.haskell.org/package/dataflower-0.1.3.0 (jessekempf)
22:29:45 * hackage dataflower 0.1.4.0 - A Pure-Haskell Timely Dataflow System  https://hackage.haskell.org/package/dataflower-0.1.4.0 (jessekempf)
23:27:01 <Zambino> > take 5 $ cycle 3
23:27:04 <lambdabot>  error:
23:27:04 <lambdabot>      • No instance for (Num [()]) arising from a use of ‘e_153’
23:27:04 <lambdabot>      • In the expression: e_153
23:27:26 <Zambino> > take 5 $ [1..]
23:27:28 <lambdabot>  [1,2,3,4,5]
23:28:03 <c_wraith> > take 5 $ cycle [3]
23:28:05 <lambdabot>  [3,3,3,3,3]
23:28:13 <c_wraith> > take 5 $ repeat 3
23:28:15 <lambdabot>  [3,3,3,3,3]
23:28:21 <Zambino> Oh thanks
23:45:23 <int-e> :t replicate
23:45:25 <lambdabot> Int -> a -> [a]
