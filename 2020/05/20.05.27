00:14:28 <dibblego> you mean generally recursive to tail recursive
00:18:06 <liiae> dibblego: that tail recursive take one more argument than normal recursive
00:18:33 <dibblego> correct
00:18:39 <dibblego> and the type of that argument is the same as the return type
00:19:45 * hackage bugsnag-hs 0.1.0.3 - A Bugsnag client for Haskell.  https://hackage.haskell.org/package/bugsnag-hs-0.1.0.3 (JasperWoudenberg)
00:22:34 <dibblego> the one you have written is O(n^2) 
00:23:33 <liiae> dibblego: and that https://hackage.haskell.org/package/base-4.14.0.0/docs/src/GHC.List.html#reverse is not O(n^2)?
00:23:51 <dminuoso> liiae: Why are you under the impression that GHC.List.reverse is not recursive?
00:24:03 <dibblego> no, it has the function we just described
00:26:19 <liiae> dminuoso: reverse l =  rev l [], rev is recursive, reverse is?
00:26:21 <MarcelineVQ> dminuoso: in the sense that reverse not not mention reverse it is not recursive, rev is recursive as it does mention rev
00:26:28 <MarcelineVQ> *does not mention
00:26:36 <dibblego> rev is recursive
00:26:37 <dminuoso> MarcelineVQ: That seems like... a silly distinction.
00:26:47 <dminuoso> In what sense is it meaningful?
00:27:18 <liiae> dminuoso: MarcelineVQ that GHC.List.reverse can not be some function's fixed point, right?
00:27:28 <liiae> 'cause GHC.List.reverse is not recursive
00:27:45 <dibblego> it can be written that way
00:27:51 <dminuoso> liiae: Judging from how you started this topic yesterday, I think you have some misunderstanding about what fixed points are, and you are trying to discover something you suspect to be true.
00:28:05 <liiae> yeah, it can be written with that recursive way
00:28:11 <dibblego> write foldl with foldr, then write reverse = foldl (flip (:)) []
00:28:30 <dibblego> foldl is currently written similarly to rev
00:28:35 <dminuoso> More interestingly, try writing reverse in terms of foldr :P
00:28:45 <dibblego> ...and make it O(n)
00:29:00 <dibblego> that's just an exercise in substitution afterward though
00:30:18 <liiae> dminuoso: where I'm misunderstanding?
00:30:31 <dminuoso> liiae: I'm not quite sure, actually.
00:31:31 <liiae> dminuoso: I'm just following the mechanical process to get g which f = fix g
00:31:41 <dminuoso> But I think you are dodging around a mixed up understanding, trying to confirm some suspicion you can't yet formulate.
00:32:17 <dminuoso> Are you asking, how to write a function in terms of fix in general?
00:32:30 <dminuoso> Like, how to transform a recursive function into a parameter to fix?
00:32:35 <MarcelineVQ> "<liiae> dminuoso: MarcelineVQ that GHC.List.reverse can not be some function's fixed point, right?" it can, in a way you've already been shown in earlier conversations via const. but it's not a useful thing to know to solve your codewars problem :(
00:33:05 <MarcelineVQ> Which is what you should really be asking about, imo
00:33:21 <liiae> dminuoso: I'm trying to do something without `fix'
00:33:47 <liiae> dminuoso: if we have f, I'm trying to get g, which f = fix g,
00:33:49 <dminuoso> liiae: It might be useful to understand that fix is just an anonymous/implicit form of recursion.
00:34:13 <dminuoso> That is, whether you use `fix f` or some recursive version of f called f' - is really not different. It's conceptually (!) recursive either way.
00:34:14 <liiae> dminuoso: we can have g f = f, why we need fix?
00:34:19 <dminuoso> liiae: We dont, really.
00:34:27 <dminuoso> fix is just a convenience tool.
00:34:38 <liiae> dminuoso: yes, 
00:34:47 <dminuoso> You can delete the fix binding and replace everything with explicit recursion without any loss.
00:35:11 <dminuoso> Or equivalently you can remove any (single/non-mutual) recursion and replace it with fix.
00:36:07 <liiae> MarcelineVQ: "it can, in a way you've already been shown in earlier conversations via const." more details? I forget that const
00:36:13 <dminuoso> There's this common idiom where you write something like `fix $ \loop -> ... loop` - where fix is merely used to avoid an explicit recursive *binding*
00:36:25 <dminuoso> This is sort of why fix is useful.
00:36:47 <dminuoso> It's just mere convenience, sometimes it's a little more expressive to the mathematically inclined people.
00:37:51 <liiae> dminuoso: could we implement `fix` in other languages?
00:38:01 <MarcelineVQ> I'll paste it if you like but it's sincerely not useful to your codewars task you linked earlier
00:38:19 <MarcelineVQ> liiae:  https://gist.github.com/MarcelineVQ/ff0e8bd3ac144782dec9ab6f3e35e267
00:38:32 <dminuoso> liiae: Sure. But it usually requires some more trickery because many languages have different evaluation semantics.
00:38:54 <dminuoso> Let me give you a simple snippet to show you why fix is really redundant.
00:39:37 <liiae> MarcelineVQ: I thought that codewars task if askeing people to turn non-recursive to recursive function more than find who is its fixed point
00:39:56 <liiae> dminuoso: python or js is good :)
00:39:57 <dminuoso> liiae: Let's assume, that you have some recursion going on, maybe you are creating an infinite list.
00:40:04 <dminuoso> For the sake of argument, alright?
00:40:12 <dminuoso> And we don't have access to repeat, so what you could do is
00:40:26 <liiae> MarcelineVQ: you mean "`reverse' = const Prelude.reverse`"?
00:40:53 <dminuoso> And we don't have access to repeat, so what you could do is write `fix (1:)` right in some place where an expression is wanted.
00:40:55 <liiae> MarcelineVQ: but now I'm not sure this right, reverse [1,2] /= const Prelude.reverse [1,2]
00:40:57 <dminuoso> This is convenient
00:41:21 <dminuoso> Of course, you could write `infiniteList = 1 : infiniteList`, but that would require a separate binding (!)
00:41:35 <dminuoso> So fix mere purpose, is to allow you to avoid a binding, nothing more.
00:41:42 <dminuoso> It's pure code convenience.
00:42:12 <dminuoso> I frequently use fix when I need recursion in a spot where Im too lazy to add a where clause just to set up a recursive binding.
00:42:51 <liiae> fix (1:)
00:43:19 <MarcelineVQ> const is mentioned in a few places, that's only the first, this line might be clearer:  <awpr> `fix (const x) === x` for any `x`, so you can always find a `g` such that `fix g === f`, namely `const g`
00:43:36 <dminuoso> liiae: It's exactly the same as `infiniteList`, but the different is you can use `fix (1:)` right in the middle of an expression, but for infinite list you have to create a binding (using let/where/top-level) first.
00:43:47 <dminuoso> *for infiniteList
00:44:18 <liiae> dminuoso: yeah, (1:) [1,1,1...] = [1,1,1...]
00:44:35 <MarcelineVQ> you can press  ctrl+f  on webpages to search them for a partcular word
00:44:37 <liiae> [1,1,1...] is the fixed point of function (1:)
00:44:52 <dminuoso> liiae: It's not about fixed points, really.
00:45:02 <dminuoso> The fact that its called fix requires understanding of denotational semantics, really.
00:45:14 <dminuoso> And it's not really useful. Think of fix as just a tool for setting up anonymous recursion.
00:45:56 <dminuoso> Because fix does not compute any fixed point, it computes the "least defined" fixed point - always.
00:46:34 <liiae> MarcelineVQ: I don't understand, const x = id, fix id?
00:47:25 <liiae> > fix (const 3)
00:47:27 <lambdabot>  3
00:48:05 <MarcelineVQ> hmm? const x is not id
00:48:28 <liiae> > fix (const reverse) [1,2,3]
00:48:30 <lambdabot>  [3,2,1]
00:48:43 <liiae> reverse = fix (const reverse)
00:49:01 <liiae> reverse' = const reverse
00:49:05 <dminuoso> fix (const f) = f
00:49:32 <dminuoso> % :t (fix . const)
00:49:32 <yahb> dminuoso: c -> c
00:50:10 <liiae> wow
00:50:38 <liiae> MarcelineVQ: wait a sec, this reverse could not be recursive?
00:50:54 <MarcelineVQ> Which reverse?
00:51:04 <liiae> MarcelineVQ: GHC.List.reverse
00:52:11 <MarcelineVQ> I don't understand your question. Could you ask in another way?
00:52:54 <liiae> MarcelineVQ: GHC.List.reverse's definition is not recursive, right?
00:53:06 <liiae> MarcelineVQ: https://hackage.haskell.org/package/base-4.14.0.0/docs/src/GHC.List.html#reverse
00:53:34 <MarcelineVQ> correct. reverse does not call reverse, so it is not recursive by the normal definition
00:54:09 <MarcelineVQ> however, rev calls rev. rev is recursive.
00:54:22 <liiae> MarcelineVQ: but that non-recursive reverse still could be a fixed point of reverse', right?
00:54:24 <MarcelineVQ> I'm really really sure this was said earlier though..
00:54:38 <liiae> fix (const f) = f
00:54:42 <liiae> const f = f'
00:55:08 <Axman6> so I disconnected at 11:35AM and it's not 17:53PM and exactly the same conversation is still happeneing. amazing
00:55:23 <Axman6> now*
00:55:49 <liiae> MarcelineVQ: so that codewars anwser can be "import Data.List.reverse; reverse' = const reverse"
00:56:06 <dminuoso> Oh boy, this is just about codewars?
00:56:17 <dminuoso> Wish I had caught onto that.
00:56:24 <liiae> dminuoso: fixed point on codwars
00:56:38 <liiae> dminuoso: https://www.codewars.com/kata/5443dd2d7fc4478154000ac6
00:57:01 <dminuoso> liiae: Let me reiterate then.
00:57:17 <MarcelineVQ> There's a reason I said mere minutes ago that const wasn't relevant to the codewars problem. That's not the answer they're trying to get you to write.
00:57:30 <liiae> MarcelineVQ: sorry, I'm telling by other people, that GHC.List.reverse is not recursive, it couldn't have reverse'
00:57:36 <dminuoso> fix allows you to turn explicit recursion into implicit recursion
00:58:03 <liiae> MarcelineVQ: people trying to tell me `rev` can have `rev'`
00:58:11 <liiae> but reverse could not have reverse'
00:58:29 <liiae> so I suppose only recursive function could be a fixed point of other function
00:59:00 <liiae> now, f' = const f, this change me view
00:59:11 <MarcelineVQ> Those same people mentioned the   const  method earlier, but they also knew that's not what the codewars problem was wanting you to do
00:59:34 <liiae> if this f is not recursive, so that every function even not recursive, they could have f'
00:59:42 <liiae> they could be fixed point of some functions
00:59:48 <MarcelineVQ> I even included that part in the paste hehe
01:00:24 <dminuoso> It is my opinion that it's more valuable to just learn haskell for the sake of writing Haskell problems, rather than asking on #haskell in order to do codewars katas...
01:00:31 <dminuoso> But then again I think very lowly of codewars..
01:00:40 <liiae> MarcelineVQ: sorry, I don't pay more attention
01:01:55 <liiae> MarcelineVQ: at that time, I didn't understand that 
01:02:25 <srk> > fix error
01:02:28 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
01:02:36 <srk> :(
01:03:21 * dminuoso really should learn how GHC exceptions are implemented.
01:08:18 <Axman6> is it covered in concurrent & parallel programming in Haskell?
01:09:03 <liiae> MarcelineVQ: I'm not sure that codewars really want what I to do
01:09:08 <liiae> me
01:09:42 <liiae> and that's right, reverse' = const reverse, could pass the question
01:10:01 <Axman6> can you define reverse as a recursive function?
01:10:12 <Axman6> (explicitly recursive, not using foldl)
01:10:41 <liiae> reverse [] = []; reverse (x:xs) = reverse xs ++ [x]
01:11:11 <antaoiseach> Hey guys, I'm torn between learning Idris or Agda ... I want a powerful formal verification tool, practical programming capabilities (lots of I/O etc.), and also something which has a decent chance of surviving for a while ... ideas?
01:11:25 <Axman6> that's an awful definition but it will do. firstly convert that to using case directly: reverse xs = case xs of ...
01:11:48 <antaoiseach> Background-wise, beginner in Haskell, did some Idris from the book, and also a couple of chapters from Wadler's Agda course
01:13:05 <MarcelineVQ> antaoiseach: hard to say really, a lot of bright minds are working on each, and some on both. idris1/2's goal is to be used for practical programming while agdas currently leans more towards the theory/proofing so that might guide you a bit
01:13:13 <liiae> awpr: sorry, I didn't pay more attension on your anwsers, you're right, there's always f' = const f
01:14:11 <dminuoso> antaoiseach: From what I've seen, Idris lets you actually do programming, whereas Agda is really just about thereom proving.
01:14:17 <antaoiseach> MarcelineVQ: Hmmmm
01:14:25 <dminuoso> antaoiseach: And it goes beyond just leaning.
01:14:29 <MarcelineVQ> dminuoso: cedille is written in agda so it's not like it's impractical, it's just not the community goal as far as I've seen
01:14:58 <antaoiseach> dminuoso: That's what I got a feel of myself ... just worried if Edwin Brady has a bit of a bus-factor problem? Of late, he seems to be the main person working on Idris2 ... 
01:15:28 <antaoiseach> And how about say, for formal verification - will Idris suffice (note that I have no experience with formal verification of any sorts)
01:15:41 <antaoiseach> (but am curious to learn about it and see how to use it for practical programming)
01:15:44 <dminuoso> MarcelineVQ: To be fair, the fact that Agda was used to write a program does not itself prove it's practical.
01:15:59 <dminuoso> You can write a Haskell implementation in Brainfuck, but that's not much of an argument about the usefulness of Brainfuck.
01:17:09 <antaoiseach> Also, does anyone have experience performance-wise how they compare?
01:17:17 <edwardk> antaoiseach:  idris is basically a one man effort, agda has a bit more of a community behind it. idris gets you something designed for use as a programming language, agda is better at proof in many ways.
01:17:25 <MarcelineVQ> antaoiseach: the powers are pretty comparable there really, agda has a bit of an edge for various small reasons
01:17:29 <edwardk> antaoiseach: so its really a function of goals
01:17:40 <antaoiseach> edwardk: that's one of my biggest fears :(
01:17:41 <MarcelineVQ> powers of verification that is
01:17:48 <edwardk> agda gets you slightly mathier syntax, but a slightly wonkier metatheory
01:18:07 <edwardk> but then it also has more eyeballs on it
01:18:07 <antaoiseach> MarcelineVQ: Aha? Any specific places (that I could google further on)
01:18:48 <antaoiseach> edwardk: Hmmm ... my confusion is getting worse ... hahaha!
01:18:55 <edwardk> i like coq for practical proof efforts, despite not being as 'haskelly' as agda/idris, and having a strong french accent
01:19:12 <MarcelineVQ> a more robust termination checker, nicer syntax for corecursion (depending who you ask), support in the compiler for sized types
01:19:13 <edwardk> why? tactics are super important if you want to ever refactor your code
01:19:34 <antaoiseach> edwardk: I did try to get into Coq using 'Software Foundations', but couldn't bear it for some reason .. .despite them claiming it's Ocaml-ly ...
01:19:42 <antaoiseach> MarcelineVQ: Thanks!
01:20:07 <edwardk> i like agda when i want something to be a bit more experimental. e.g. when i want induction-recursion or something coq just doesn't want to let into their pretty locked down meta theory
01:20:14 <MarcelineVQ> there's software foundations in idris and agda fwiw. the agda one is called  plfa
01:20:37 <edwardk> software foundations is the pierce book right?
01:20:39 <antaoiseach> Yes .. .plfa by Wadler et al was what I was exploring to get a feel of Agda
01:20:44 <antaoiseach> edwardk: Yup!
01:20:53 <edwardk> i really don't like that book as an entry way
01:21:04 <antaoiseach> I mean it's a course, but yes, it's by him
01:21:24 <antaoiseach> Syntax wise, I found Idris to be the easiest to grok
01:21:25 <edwardk> it teaches you all the ways to use tactics by brute force step by step to solve problems, but then using tactics effectively is all about avoiding EVER DOING THAT
01:21:42 <antaoiseach> Hmmm
01:22:00 <edwardk> http://adam.chlipala.net/cpdt/
01:22:11 <antaoiseach> So, again, with the caveat that I have no background in it, how practical would these concepts be ... say for designing real-world software?
01:22:14 * MarcelineVQ stops linking that link that was about to link
01:22:18 <antaoiseach> That's more of the angle I'm coming from
01:22:37 <edwardk> is a much more effective book to learn how to use tactics as a tool rather than a particularly baroque and complicated way to write basic expressions
01:22:49 <antaoiseach> edwardk: Bookmarked .. thanks!
01:23:32 <edwardk> now, once you get through adam's approach about how tactics should be used, then sure, pierce's very mechanical step by step plodding way ot writing proofs is fine, but i find the way advocated by pierce leads to code that doesn't enjoy any benefits from having been written with tactics
01:24:37 <edwardk> i like tactics because what you can do is set up a way to solve a whole space of problems once and for all, and call out to it. then when you refactor your code, so long as both the before and after are _in the same kind of space_ the whole proof doesn't break.
01:24:57 <edwardk> on the other hand, agda/idris encourage you to work where you yourself are the tactic engine clicking magic 4 key combos
01:25:07 <edwardk> so when you refactor your code YOU have to redo all that work
01:25:19 <edwardk> rather than the tactic code surviving the refactor
01:25:36 <MarcelineVQ> agda is gaining more tactic support currently fwiw if proofs are your goal
01:25:48 <Tuplanolla> It's a shame Ltac is such a terrible language.
01:25:49 <MarcelineVQ> currently meaning right now
01:25:57 <Tuplanolla> Luckily, things are changing.
01:26:16 <edwardk> in the pierce (in my most uncharitable parody-like interpretation of his style) style you tend to write proofs that don't survive refactoring.
01:26:36 <edwardk> in the parody-of-chlipala style you wind up writing tactics that are way too strong and spending too long waiting for them
01:26:51 <edwardk> or where they are uninformative 'crush.' calls
01:27:05 <MarcelineVQ> in the cubical parody you just transport your proofs and pay for shipping
01:27:20 <edwardk> MarcelineVQ: i stopped holding my breath there about 5 years ago ;)
01:28:27 <edwardk> MarcelineVQ: i tend to like to write coq in a sort of univalence-agnostic fashion as much as possible. i like talking in terms of paths as much as possible, because it lets me punt a lot of fancy equality concerns up to the meta theory and keep my proof terms small
01:28:38 <edwardk> even if i don't go full HoTT on it.
01:31:13 <edwardk> antaoiseach: as a point in the design space https://github.com/ekmett/homotopy/blob/master/Core.v shows me using about 8 lines of tactics to resolve a few hundred proof obligations by mixing the chlipala-style and sozeau's program syntax
01:31:47 <edwardk> antaoiseach: i don't claim to be a coq expert and i didn't finish that project, but i did like how it was coming together and figured it'd be a nice 'haskelly' sort of example that didn't use many tactics
01:32:36 <edwardk> 113-123 is basically all my tactic code (the other tactic isn't used) and it is used automatically for all the subgoals introduced by the Program statements
01:32:56 <edwardk> Program Definition Types : category := {| hom := λ (x y : Type), x -> y |}.   -- then becomes my _entire_ definition of the category of types
01:33:11 <edwardk> it infers the type of objects, the identity, the composition, the laws...
01:34:33 <edwardk> (this file isn't perfect, but i like to use it as an example of a style I think is important.)
01:38:44 <edwardk> another tool i really happen to like, but which is maybe not far enough down the power tool  curve yet is Lean. I really like their tooling and approach to tactics.
01:40:08 <edwardk> If Coq wins for mature ecosystem and robust tactic story. Lean wins for my confidence in Leo, and having an awesome direction to grow.
01:42:35 <edwardk> take basically the most brilliant implementor of SMT solvers out there, have them get fed up and decide to write a theorem prover that he wants to both use to lean out on those for external proof AND implement them and you get Lean. For everyone else external solvers are basically an afterthought. (Add the fancy congruence closure bits lean offers and things get interesting.)
01:42:46 <edwardk> -- and i realize i seem to have lost my audience ;)
01:42:57 <yushyin> haha
01:43:54 <yushyin> we just listen very carefully!
01:45:44 <dminuoso> Bonus points to edwardk for adhering to the traditional #haskell policy of just whomping an innocent Haskell beginner just wondering about a general direction.
01:48:17 <edwardk> =)
01:48:41 <antaoiseach> edwardk: Okay, read that - didn't understand a thing
01:48:44 <antaoiseach> Hahahah
01:48:44 <antaoiseach> :D
01:48:49 <Tuplanolla> I'd say something, but I don't want to echo what edwardk is saying.
01:49:08 <antaoiseach> There is so much for me to learn before I feel comfortable with this whole array of subjects! 
01:49:17 <edwardk> you have to let people know how deep the rabbit hole goes BEFORE they jump in with both feet or the splat is on your conscience.
01:49:18 <Tuplanolla> I do have to point out that Coq's developers find Lean's metatheory to be questionable.
01:49:20 <antaoiseach> Right now you folks might as well be talking Martian! :D
01:49:42 <antaoiseach> edwardk: Hahaha ... I suppose that makes sense! 
01:49:49 <edwardk> Tuplanolla: the coq developers find _everybody_'s metatheory questionable ;)
01:49:57 <merijn> antaoiseach: The secret answer is: you'll never feel comfortable :p
01:50:03 <Tuplanolla> Mainly because adding quotients in by force loses some nice properties.
01:50:15 <antaoiseach> merijn: Oh hey merijn ... nice to see you here! :-)
01:50:17 <merijn> You just get used to a new base level of unease and ignorance :p
01:50:24 <edwardk> the quotient thing is a total hack, but it is a useful hack
01:50:25 <antaoiseach> Haha
01:50:33 <merijn> Not even joking >.>
01:51:22 <antaoiseach> I feel like I should have taken maths as my major in uni ... would have loved to! This is my way of trying to get back into some form of mathematics ... well, this does count as maths in some way, right?
01:51:25 <MarcelineVQ> The real horror is when you go to ask an expert for help and find out it's you.
01:51:33 <antaoiseach> MarcelineVQ: LOL!
01:51:41 <edwardk> fortunately you don't have to turn quot.sound on
01:52:12 <edwardk> MarcelineVQ: or when you start to google a topic and the only posts you find are ones you wrote =(
01:53:02 <MarcelineVQ> "It's you, you're the rocketman." *boom*
01:53:03 <merijn> edwardk: I actually quote you on that in my thesis' intro ;)
01:53:06 <merijn> @quote cavalry
01:53:06 <lambdabot> roconnor says: <roconnor> where are all the category theoriest? why don't they already have all the answers for us? <edwardk> roconnor: this is the point in your career where you look around for the
01:53:06 <lambdabot> cavalry and realize that you're it ;)
01:54:14 <antaoiseach> Okay, so basically I either do all of it, or none at all seems to be making most sense to me right now ... hehe
01:54:23 <edwardk> merijn: =)
01:54:48 <MarcelineVQ> antaoiseach: people are just being silly, start anywhere and ask questions as you go :>
01:55:26 <antaoiseach> Ah, okay ... I was getting a bit overwhelmed with the stuff I have no idea about! 
01:55:38 <edwardk> antaoiseach: if things are going slow, i'd like to point out i probably spent 6 months flailing around when i first learned haskell reading everything I could before I produced any meaningful amount of code.
01:55:55 <antaoiseach> edwardk: Thanks, that does help! :-)
01:56:02 <MarcelineVQ> only 6 months, what a legend :>
01:56:03 <edwardk> and that was at a time when i could devote basically every waking hour to it
01:56:38 <edwardk> MarcelineVQ: at the end of that time period i produced a bad STM-based hash table =P
01:56:59 <dminuoso> Haskell, especially in its current state, has that difficulty that it's hard for a beginner to get an idea when to stop chasing rabbits and start writing code.
01:57:23 <MarcelineVQ> But, of course, now all my hash tables call out to the collective via hyperspace relays
01:57:25 <dminuoso> We have plenty of tunnels with even more rabbits in them.
01:57:49 <antaoiseach> I learnt Haskell from Graham Hutton's book, "Programming in Haskell" - loved every bit of it, but when I started looking at real code, I couldn't understand anything ... there seem to be a million extensions or what not
01:58:58 <dminuoso> With what I know now, GHC is a fine codebase to look at - code-style wise it's written with great simplicity. It's just that the architecture and some of the thoughts going into it are complex..
01:59:10 <dminuoso> GHC is really light on extensions as well.
01:59:58 <antaoiseach> I have to go now, but I'll keep visiting more frequently - I learnt a lot more in half an hour (well, at least about things I have to lean) than I imagined ... thanks to all you guys for the excellent info and convo ... cheers!
02:10:39 <liiae> dminuoso: id == fix . const?
02:12:26 <[exa]> liiae: why not
02:14:52 <ibrahims> Hello
02:15:52 <ibrahims> i keep getting 'Loaded package environment from ...', twice.
02:16:01 <ibrahims> at 'cabal exec -- shake'
02:16:12 <ibrahims> any comments?
02:16:55 <ibrahims> i used to use 'cabal run shake' which was faster. but that fails somehow.
02:18:37 <liiae> [exa]: wow, id is simple and fix is not simple in my view, and they're the same, is magic
02:19:08 <merijn> ibrahims: Define "somehow"?
02:19:41 <[exa]> liiae: you instantly "kill" the fix complexity by passing in a function that discards it
02:22:08 <ibrahims> merijn: 'cabal: Unknown executable shake in package shk-0.18.5-b0fbf6bf'
02:23:03 <ibrahims> merijn: i don't know how that comes up
02:23:05 <merijn> ibrahims: Insufficient info, tbh. Are you running this in a project? Standalone?
02:23:25 <merijn> Like what exactly is "cabal run shake" supposed to call?
02:23:38 <ibrahims> yes, yes. in a project. shake is listed in dependencies
02:24:02 <ibrahims> that used to work, so i used it for long time now
02:24:26 <merijn> Which version of cabal-install?
02:24:42 <ibrahims> ' ∂ cabal --version
02:24:42 <ibrahims> cabal-install version 3.2.0.0
02:24:43 <ibrahims> compiled using version 3.2.0.0 of the Cabal library'
02:25:28 <ibrahims> cabal-version: 2.4 
02:25:36 <ibrahims> in the .cabal file
02:26:06 <ibrahims> ' ∂ cabal install shake
02:26:07 <ibrahims> LICENSE: openBinaryFile: does not exist (No such file or directory)'
02:26:39 <ibrahims> i tried to install shake binary generally but this message is even more obscure
02:29:23 <MarcelineVQ> does your cabal file specify a license file that doesn't exist? possibly called LICENSE
02:29:58 <ibrahims> oh, it does.
02:30:36 <ibrahims> i thought 'cabal install' would do a system install
02:30:46 <ibrahims> didn't think to look for it in the project
02:31:34 <ibrahims> with an installdir specified to '~/bin/`, shake binary is available now
02:31:54 <ibrahims> but it can't find modules
02:32:07 <ibrahims> 'Could not find module ‘Development.Shake’'
02:32:30 <ibrahims> do you know why that might be?
02:34:27 <ibrahims> i don't want to switch to stack now, cabal was going well for me. any help is greatly appreciated.
02:39:10 <ibrahims> maybe someone can comment onto whether 'Loaded package environment from ..' messages could indicate unnecessary work at every execution of the 'cabal exec -- shake' command?
02:40:16 <ibrahims> is that an understa concern?
02:40:21 <ibrahims> understandable
02:43:51 <ibrahims> i could also work with a 'go read this and this' reply.
02:48:17 <ibrahims> it worked to have a new executable that builds Shakefile.hs instead of relying on the executable in the shake package. 
02:48:49 <ibrahims> Very nice. Gratitude!
02:51:15 <fog> im not used to doing something in a way thats not pure, but i want to embed a list into an monadic variable
02:51:54 <fog> I want to be able to traverse a container within this monad, to replace its values by those of a stream
02:52:07 <fog> where this stream is a mutable variable in the monadic context
02:52:40 <fog> so that on reading from it, this returns head and tail, replacing the variable with the tail and returning head 
02:53:48 <fog> basically I have a complicated structure, functions all about the place, and i want to replace them with neural nets, but i dont want to have to bother traversing over the thing to update the weights
02:54:03 <fog> i would rather just mutate the global list variable of all the weights
02:54:11 <fog> and have these be referred to 
02:55:08 <fog> so that i just need traverse one time to make reference to the mutable list
02:56:16 <fog> i suppose I could as easily traverse, and accumulate an Int counter to use to lookup the mutable value at that position
02:57:55 <fog> is there a nice way to write that as a state transformer monad stack?
02:58:43 <fog> traversal over something with a function that needs the Int (State) in a monadic context where it can look up from an available MVector (Reader ?) 
03:02:32 <fog> % traverse (const (randomRIO (0,1))) [1,2,3]
03:02:33 <yahb> fog: [1,1,1]
03:02:36 <fog> % traverse (const (randomRIO (0,1))) [1,2,3]
03:02:37 <yahb> fog: [1,0,0]
03:05:34 <ibrahims> fog: there could be many nice ways once you go around introducing intermediate structures, which is what the monads would be. it is always nice to have ghc fuse the transformers but that usually pays off when you have multiple moving pieces to coordinate. for something specific it is best to use functions immediate ti MVector directly and see what kind of generalization you need afterwards.
03:13:17 <whataday> any value could be fixed point on id
03:13:32 <whataday> I wounder what fix id would be?
03:13:38 <whataday> > fix id
03:13:40 <lambdabot>  *Exception: <<loop>>
03:13:57 <dminuoso> whataday: Remember, fix produces the least (defined) fixed point of a function.
03:14:09 <dminuoso> So its semantics only make sense within denotational semantics.
03:14:54 <dminuoso> And bottom is certainly a fixed points of id
03:15:14 <fog> ibrahibs: i guess it ends up the same, using MVector, or a tail stream as a State, because you still need to "traverse" over it by incrementing a counter
03:15:54 <whataday> f x = x, x is the fixed point on f, and f x = x is id, wonderful
03:16:05 <dminuoso> id _|_ = _|_
03:16:10 <int-e> Hmm, wait, could lambdabot be the source of the idea that ghci detects that kind of loop? (e.g. https://stackoverflow.com/questions/56450693/why-does-running-ghci-in-windows-make-it-not-possible-to-detect-infinite-loops )
03:16:10 <dminuoso> So indeed, it is a fixed point.
03:16:44 <whataday> id is a wonderful function
03:16:54 <dminuoso> int-e: No, it's GHC.
03:17:00 <int-e> (lambdabot is *not* ghci; it uses mueval and actually compiles code.)
03:17:18 <Axman6> it's the most unifersal function, it can be anything you want it to be
03:17:22 <dminuoso> int-e: https://gitlab.haskell.org/ghc/ghc/issues/2786
03:17:23 <Axman6> universal*
03:18:17 <dminuoso> So it's a strange interaction with other things, but the underlying feature is black holes closures
03:18:47 <turion> Is there a language extension that allows me to do partial type operator application?
03:18:57 <dminuoso> turion: No.
03:18:58 <turion> E.g. I want to be able to write:
03:18:59 <turion> instance Functor (a ->) wher
03:19:14 <dminuoso> turion: You have to write `instance Functor ((->) a) where ...`
03:19:25 <turion> dminuoso ok
03:19:30 <dminuoso> But it only works for arguments from the left side, but you cant partially apply the "right hand side"
03:19:56 <dminuoso> That is, something like `(-> a)` is not possible, you'd have to use a newtype wrapper like `newtype Op a b = Op (b -> a)`
03:20:09 <turion> Ok makes sense
03:20:19 <dminuoso> (And then write e.g. `instance Contravariant (Op a) where ...`
03:20:20 <turion> dminuoso so if I want to implement Functor for Kleisli arrows on the nose, that won't work?
03:20:49 <dminuoso> turion: Well it wouldn't be valid anyway. But assuming you meant Contravariant, then like I showed with Op
03:21:06 <dminuoso> Oh sorry! I mixed things up
03:21:08 <dminuoso> Heh.
03:21:32 <dminuoso> turion: You can with Kleisli the same way
03:21:35 <int-e> dminuoso: Thanks... but did that ever work and when exactly did it stop? The book (Haskell Programming from first principles) was written around the time ghc 7.10 was the current version and was written with an eye on the upcoming ghc 8... I'm confused how the claim ended up in that book. (Though it could be reusing some old material I suppose.)
03:22:00 <dminuoso> % newtype Kleisli m a b = Kleisli { runKleisli :: a -> m b }
03:22:00 <yahb> dminuoso: 
03:22:13 <int-e> It's not terribly important of course... but it's nagging me.
03:22:17 <dminuoso> % instance Functor (Kleisli m a) where fmap = fmap
03:22:18 <yahb> dminuoso: 
03:22:43 <turion> Yes, but something like instance Functor (m . (a ->)) won't work I guess?
03:22:45 * hackage juicy-gcode 0.1.0.9 - SVG to G-Code converter  https://hackage.haskell.org/package/juicy-gcode-0.1.0.9 (dlacko)
03:22:50 <dminuoso> Well I guess this should rather have a `Funtor m` constraint
03:24:41 <turion> dminuoso: Ok, thanks!
03:24:44 <dminuoso> int-e: Well the details depend on GHC optimizations, you have sadly no guarantees for <<loop>>
03:26:15 * hackage streamly-fsnotify 1.1.0.0 - Folder watching as a Streamly stream.  https://hackage.haskell.org/package/streamly-fsnotify-1.1.0.0 (GeorgeThomas)
03:26:39 <dminuoso> Depending on optimization flags (and possible surrounding code), it can vary where thunks actually appear eventually. This can change from GHC version to version, obviously
03:27:44 <dminuoso> Are you familiar with how black holes work?
03:27:45 <int-e> dminuoso: I know
03:27:48 <dminuoso> Ah okay
03:29:15 * hackage rattle 0.2 - Forward build system, with caching and speculation  https://hackage.haskell.org/package/rattle-0.2 (NeilMitchell)
03:33:59 <whataday> we can't do recursive in type definition, but we can use fixed point to implement that?
03:34:38 <dminuoso> % newtype Fix f = Fix { unFix :: f (Fix f) }
03:34:38 <yahb> dminuoso: 
03:34:42 <dminuoso> Enjoy!
03:35:36 <whataday> is there an example on the value level for your type?
03:36:25 <Hoppelhase> What is meant by recursive here? data Tree a = Leaf a | Branch [Tree a] would be a recursive type, no?
03:37:02 <dibblego> the definition of Tree (left of =) references itself (right of =)
03:37:05 <dminuoso> whataday: F-Algebras are a good example
03:37:44 <fog> https://pastebin.com/raw/ATnz0w9S
03:37:47 <dminuoso> % data ExprF a = Const Int | Add a a
03:37:47 <yahb> dminuoso: 
03:38:30 <dminuoso> Then you use `Fix ExprF` and be happy.
03:38:55 <dminuoso> % x :: Fix ExprF; x = Fix (Const 1)
03:38:55 <yahb> dminuoso: 
03:39:33 <whataday> unFix is the fixed point of f, but what Fix unFix is?
03:42:46 <xerox_> dminuoso: what does "F-" stand for in there?
03:43:45 * hackage streamly-fsnotify 1.1.1.0 - Folder watching as a Streamly stream.  https://hackage.haskell.org/package/streamly-fsnotify-1.1.1.0 (GeorgeThomas)
03:43:45 <dminuoso> xerox_: I think the F is just from the generic "F" that category theorists use for some random Functor.
03:43:53 <dminuoso> But dont quote me on that.
03:44:43 <xerox_> I feel compelled now: «I think the F is just from the generic "F" that category theorists use for some random Functor.» — dminuoso, 27/5/2020
03:45:22 <whataday> confused on the type
03:47:15 <dminuoso> https://bartoszmilewski.com/2013/06/10/understanding-f-algebras/ has some good bits on that topic
03:47:28 <int-e> % newtype Y a = Y { runY :: Y a -> a }
03:47:28 <yahb> int-e: 
03:47:38 <int-e> % let fix' f = (\x -> f (runY x x)) (Y (\x -> f (runY x x)))
03:47:38 <yahb> int-e: 
03:47:40 <int-e> % :t fix'
03:47:40 <yahb> int-e: (t -> t) -> t
03:48:08 <dminuoso> int-e: Amusingly that piece of code can crash GHC with the wrong optimization flags I think.
03:48:12 <int-e> % fix' error
03:48:15 * hackage lightstep-haskell 0.7.0 - LightStep OpenTracing client library  https://hackage.haskell.org/package/lightstep-haskell-0.7.0 (DmitryIvanov)
03:48:18 <yahb> int-e: "*** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Excep
03:48:22 <dminuoso> (Well drive it out of ticks, but it does give you some 'internal error')
03:48:53 <dminuoso> I
03:49:32 <int-e> dminuoso: I believe that was fixed.
03:50:00 <dminuoso> int-e: Only if you add NOLINE pragmas.
03:50:04 <dminuoso> *NOINLINE even
03:50:15 <dminuoso> I dont think its fixable otherwise, because GHC will just try inlining...
03:50:57 <dminuoso> It's a documented bug, in fact.
03:51:00 <dminuoso> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/bugs.html
03:54:02 <int-e> dminuoso: Ah, right. You have to actually use the function to trigger this. Which in retrospect is obvious.
03:54:17 <int-e> % print (fix' not) -- something like this
03:54:17 <yahb> int-e: ; <interactive>:1:8: error:; * Variable not in scope: fix' :: (Bool -> Bool) -> a0; * Perhaps you meant `fix' (imported from Control.Monad.Except)
03:55:56 <whataday> newtype Fix f = MkFix f (Fix f) is not right?
03:56:24 <dminuoso> It's the same.
03:56:44 <dminuoso> newtype Fix f = Fix { unFix :: f (Fix f) }
03:56:55 <dminuoso> Merely has a field accessor added for convenience.
03:57:06 <int-e> MkFix (f (Fix f)) needs parentheses
03:57:28 <whataday> it's same with that data P = P Int?
03:58:44 <whataday> x :: Fix Maybe, what x would be?
03:59:24 <dminuoso> Fix Nothing or bottom.
03:59:33 <int-e> whataday: MkFix Nothing, or MkFix Just (MkFix Nothing), and so on.
03:59:38 <dminuoso> Or that..
03:59:46 <int-e> up to the fixpoint of MkFix Just.
03:59:47 <whataday> MkFix Just (MkFix Just ( MkFix Nothing)) ?
03:59:53 <dminuoso> This is an interetsing way to construct peano numbers.
04:00:03 <dminuoso> Nat = Fix Maybe
04:00:05 <int-e> (And then you can throw in some bottoms to get the whole mess)
04:00:19 <dminuoso> Is there any useful intuition here?
04:00:29 <int-e> Nat ~= 1 + Nat
04:00:48 <int-e> dminuoso: Oh, that was a guiding question, wasn't it.
04:01:05 <dminuoso> No, actually I was curious.
04:01:20 <whataday> can we have an actually recursive function which has that type?
04:01:59 <whataday> fixed point on type level is not intuitive on the value level
04:02:24 <dminuoso> int-e: It just occured to me, that `Fix Maybe` is essentially equivalent to `data Nat = Succ Nat | Zero`, and I was wondering why that is.
04:02:50 <int-e> It's interesting to look at the corresponding fold, which is Fix a -> (a -> a) -> Fix Maybe -> a, which can be reordered to Fix Maybe -> (a -> a) -> a -> a, so we get Church numerals.
04:04:08 <int-e> dminuoso: Ah. Go the generics route: data Foo = ... | ... | ... becomes a sum and each constructor becomes a product, and each recursive use of the datatype becomes an argument (assuming iso-recursion); then you take the fixed point.
04:06:23 <int-e> Not sure how much intuition this adds. The underlying algebra has operations for zero (just a constant) and the successor, so that's a function (1 + a) -> a.
04:06:27 <whataday> f = _ => {console.log(_); return f}
04:06:42 <whataday> f(1)(2)(3)
04:07:00 <absence> why doesn't deriving Traversable work here? https://repl.it/repls/GreenyellowExcitableQuote#main.hs
04:07:04 <whataday> turn this into haskell?
04:07:22 <whataday> with fixed point?
04:07:28 <int-e> whataday: for debugging purposes there is Debug.Trace
04:07:41 <int-e> :t Debug.Trace.trace
04:07:43 <lambdabot> String -> a -> a
04:08:00 <int-e> % import Debug.Trace
04:08:00 <yahb> int-e: 
04:08:41 <whataday> that f :: a -> a-> a -> a ...
04:09:23 <int-e> % let fib n | traceShow ("fib",n) False = undefined  | n < 2 = n | otherwise = fib (n-1) + fib (n-2) in fib 3
04:09:23 <yahb> int-e: ("fib",3); ("fib",1); ("fib",2); ("fib",0); ("fib",1); 2
04:15:29 <dminuoso> int-e: Okay I can see it from a Haskell level, it's actually dead obvious if you stare at `data M a = S a | N` and `data N = S N | N`
04:16:25 <dminuoso> (Ignore the conflicting constructor names here)
04:16:50 <int-e> dminuoso: Yeah. The notion of an M-algebra is the bit that I have to think about for a moment because it does so little.
04:18:52 <int-e> Whereas, as already stated (more or less), foldN :: N -> (M a -> a) -> a basically gives you Church numerals, so that's familiar territory again.
04:20:42 <dminuoso> Indeed
04:21:20 <dminuoso> When simple datatypes like Maybe reveal so many things to be discovered, it seems to be a good indicator that Haskell is barking up the right tree..
04:22:27 <mniip> natural numbers are just the initial algebra of the pointed set monad
04:23:05 <dminuoso> What exactly is the pointed set monad?
04:23:26 <dminuoso> Or did you mean pointed set comonad?
04:23:30 <mniip> a left adjoint to the forgetful functor from pointed sets
04:23:34 <dminuoso> Ah. 
04:23:46 <mniip> or rather
04:23:49 <mniip> not the left adjoint no
04:23:53 <mniip> the monad this adjunction generates
04:24:13 <int-e> why'd you have to move beyond functors
04:24:34 <mniip> you don't particularly have to
04:24:46 <mniip> but "pointed set monad" is a cute description of 1+X
04:25:09 <fog> ok, heres what iv got so far; https://pastebin.com/raw/naUbVvjU
04:25:30 <fog> still seems like its not going to help
04:26:41 <fog> wait, no
04:26:46 <fog> its faster for convolutions
04:26:50 <dminuoso> mniip: That's a really strange monad.
04:27:24 <mniip> is it?
04:28:19 <fog> I have; Traversable f => (Int -> Vec -> IO (Double -> Double)) -> f Double -> IO (f Double)
04:29:17 <fog> so you can have access to the vector version of the traversable input, and are given the index being updated, eg to read the vec at several places
04:29:45 <dminuoso> Are you talking about this implementation? http://conway.rutgers.edu/~ccshan/wiki/blog/posts/Pointed_set/
04:30:11 <dminuoso> Or am I barking up the wrong tree here
04:30:24 <fog> dminuoso: that just looks like nonempty
04:31:03 <fog> so whatever Integers were used in the Algegra, the version over regular list instead of pointed would just have access to the natural number 0 aswell
04:31:20 <dminuoso> Ohh, my google-fu is just bad.
04:31:58 <fog> "list monad" is a cute description of 0+X?
04:34:38 <mniip> no?
04:35:02 <mniip> what in haskell we may call the list monad is called the free monoid monad, 1+A*X
04:35:29 <mniip> no wait
04:35:32 <mniip> that'd be []
04:35:50 <mniip> and initial algebra of 1+A*X is []
04:35:55 <mniip> [A}
04:37:25 <Orbstheorem> How can I impose a constrain in the type of a data family? (Without GADTs, I want a bijective type).
04:38:26 <Orbstheorem> as in `class Fooc a ...` `data family Foo a :: FooC a => a -> *`.
04:40:46 <dminuoso> Orbstheorem: Well you could use an associated data family and constrain the class I guess?
04:40:51 <dminuoso> (By means of a superclass constraint)
04:42:45 <Orbstheorem> dminuoso: How would that go?
04:43:25 <Orbstheorem> Oh, this: https://downloads.haskell.org/ghc/latest/docs/html/users_guide/glasgow_exts.html#associated-type-families ?
04:43:36 <dminuoso> Yes.
04:43:53 <dminuoso> Well, not necessarily type families, you can have associated data families too of course.
04:44:17 <mniip> a friend of mine has been wondering
04:44:25 <mniip> what is the use case for non-associated open families?
04:45:03 <Orbstheorem> dminuoso: Let me play with it a little bit.
04:45:09 <dminuoso> % class C a
04:45:09 <yahb> dminuoso: 
04:45:51 <dminuoso> % class C a => D a where data F a :: a -> *
04:45:52 <yahb> dminuoso: 
04:48:22 <jcarpenter2> Is undefined the sole value of the top type?
04:48:47 <jcarpenter2> I think I've heard it connected with the bottom type, but the bottom type has no inhabitants so undefined can't be a "member" of the bottom type
04:49:17 <dminuoso> jcarpenter2: undefined is a particular occurence of the bottom value
04:49:26 <dminuoso> jcarpenter2: And the bottom value inhabits all (lifted) types in Haskell.
04:49:41 <jcarpenter2> "the bottom type is the type that has no values" https://en.wikipedia.org/wiki/Bottom_type
04:49:46 <jcarpenter2> so... bottom value?
04:50:07 <dminuoso> jcarpenter2: You are conflating type and value level here
04:50:20 <dminuoso> jcarpenter2: The closest analogy to the bottom type is Void
04:50:31 <dminuoso> However, Void does have an inhabitant, namely bottom - so it's not actually empty.
04:51:04 <dminuoso> So whether Void is the bottom type or not, depends on whether you're willing to pretend bottom doesn't exist.
04:51:56 <jcarpenter2> ok, but undefined is the Haskell inhabitant of the top type
04:52:03 <jcarpenter2> see https://en.wikipedia.org/wiki/Top_type
04:52:23 <jcarpenter2> the top type is the universal supertype, and in haskell "undefined :: a"
04:53:36 <jcarpenter2> if you suppose i don't pretend undefined doesn't exist, then Void is not the bottom type because undefined :: Void
04:53:43 <dminuoso> Mmm, Im not sure whether `forall a. a` is a valid top type.
04:55:17 <dminuoso> It's rather a bottom type.
04:55:33 <dminuoso> The reason is quite simple, In order to be a top type, every value would have to be an inhabitant of that.
04:55:43 <dminuoso> But 'a' is certainly not an inhabitant of `forall a. a`
04:56:35 <jcarpenter2> Oh ok, i think i got it
04:56:52 <jcarpenter2> Top is like the union of all types
04:57:02 <jcarpenter2> undefined is just a nonterminating computation
04:57:08 <jcarpenter2> or, unsuccessful computation
04:57:15 * hackage strive 5.0.12 - A client for the Strava V3 API.  https://hackage.haskell.org/package/strive-5.0.12 (fozworth)
04:57:21 <dminuoso> Im not sure whether "union" is a good term because it might have the wrong connotation.
04:57:25 <jcarpenter2> right
04:59:04 <dminuoso> jcarpenter2: However, if you squint a bit and select a subset of Haskell types, there is a top type to be discovered.
04:59:41 <dminuoso> So in the subset of Typeable types, there's sort of Dynamic. But that requires adopting a different mind model wrt to how you think about the type system.
05:01:14 * hackage ratel-wai 1.1.3 - Notify Honeybadger about exceptions via a WAI middleware.  https://hackage.haskell.org/package/ratel-wai-1.1.3 (fozworth)
05:03:01 <whataday> currying, eval from left to right on the parameter
05:03:11 <whataday> compose from right to left
05:03:21 <whataday> right?
05:03:45 * hackage ratel 1.0.12 - Notify Honeybadger about exceptions.  https://hackage.haskell.org/package/ratel-1.0.12 (fozworth)
05:05:15 * hackage github-release 1.3.3 - Upload files to GitHub releases.  https://hackage.haskell.org/package/github-release-1.3.3 (fozworth)
05:05:18 <whataday> newtype Fix f = MkFix f (Fix f) | MkFix f
05:05:24 <whataday> this is ok?
05:06:15 * hackage rattletrap 9.1.3 - Parse and generate Rocket League replays.  https://hackage.haskell.org/package/rattletrap-9.1.3 (fozworth)
05:10:20 <whataday> newtype Fix f = MkFix f ( Fix f)
05:10:45 <whataday> I don't understand why MkFix Nothing :: Fix Maybe
05:11:48 <dminuoso> It might be helpful to first understand that `Fix Maybe ~ Maybe Maybe Maybe Maybe Maybe ....`
05:12:57 <dminuoso> And consider
05:13:12 <whataday> Maybe (Fix Maybe) = Maybe?
05:13:14 <dminuoso> %  newtype Fix f = MkFix { unFix :: f ( Fix f) }
05:13:14 <yahb> dminuoso: 
05:13:26 <dminuoso> whataday: just staring at the declaratoin, what's the type of MkFix?
05:13:45 <Orbstheorem> dminuoso: I when using type family applications inside the constraint class, I can't derive generic instances, even if they are always satisfied: https://paste.gnugen.ch/raw/G7v9
05:13:54 <whataday> MkFix is a value construct or
05:14:03 <whataday> MkFix is not a type
05:14:04 <solonarv> whataday: no, 'newtype Fix f = MkFix f (Fix f) | MkFix f' is not okay, for two reasons: 1) it's a newtype, so it's only allowed to have one constructor - but yo have two constructors!; and 2) you have two constructors with the same name
05:14:14 <dminuoso> whataday: MkFix being a value level thing, it has a type.
05:14:39 <whataday> MkFix a :: Fix f
05:14:43 <dminuoso> Not quite!
05:14:51 <dminuoso> Consider a simpler example
05:14:53 <whataday> MkFix is not whole value
05:15:00 <whataday> Just is a type
05:15:07 <dminuoso> % data Something = Blah Int
05:15:07 <yahb> dminuoso: 
05:15:07 <whataday> Just has no type
05:15:09 <dminuoso> What is the type of Blah?
05:15:17 <dminuoso> Of course MkFix is a whole value.
05:15:23 <whataday> Blah 3 :: Something
05:15:29 <dminuoso> Not `Blah 3`, juts Blah
05:15:38 <whataday> Blah :: Int -> Something
05:15:49 <dminuoso> % data Maybe a = Just a | Nothing
05:15:50 <yahb> dminuoso: 
05:15:52 <dminuoso> The type of Just?
05:16:04 <whataday> Just :: a-> Maybe a
05:16:19 <dminuoso> % newtype Fix f = MkFix f (Fix f)
05:16:19 <yahb> dminuoso: ; <interactive>:12:17: error:; * The constructor of a newtype must have exactly one field but `MkFix' has two; * In the definition of data constructor `MkFix'; In the newtype declaration for `Fix'
05:16:26 <whataday> MkFix :: f (Fix f) -> Fix f
05:16:29 <dminuoso> % newtype Fix f = MkFix (f (Fix f))
05:16:29 <yahb> dminuoso: 
05:16:31 <dminuoso> Good!
05:16:40 <dminuoso> Now, set f ~ Maybe
05:17:17 <whataday> MkFix :: Maybe ( Fix Maybe) -> Fix Maybe
05:17:51 <dminuoso> So if you apply `MkFix` to something of value `Maube (Fix Maybe)`, you get a `Fix Maybe` back.
05:18:10 <whataday> yeah
05:18:39 <whataday> and?
05:18:45 <dminuoso> Now it so happens, for *any* particular choice of A, you can construct a value of `Maybe A` with Nothing.
05:19:08 <dminuoso> So we can apply `MkFix` to `Nothing`, giving us `MkFix Nothing :: Fix Maybe`
05:19:19 <whataday> Nothing :: Maybe (Fix Maybe)
05:19:34 <dminuoso> Right.
05:19:37 <whataday> Nothing :: Maybe a
05:19:53 <dminuoso> Indeed, and that type allows us to monomorphise a to whatever we want, including `Fix Maybe`
05:20:05 <dminuoso> So if you do `MkFix Nothing` you get `Fix Maybe` back
05:20:16 <whataday> MkFix Maybe (Fix Maybe) :: Fix Maybe
05:20:28 <whataday> MkFix Nothing :: Fix Maybe
05:20:29 <dminuoso> Hold on, that makes no sens
05:20:50 <dminuoso> 14:16:55    whataday | MkFix :: Maybe ( Fix Maybe) -> Fix Maybe
05:20:59 <dminuoso> But what if we wanted to construct that Maybe with the Just constructor?
05:21:01 <whataday> yeah
05:21:09 <dminuoso> You'd need something of type `Fix Maybe`, right?
05:21:49 <whataday> MkFix Jus :: Fix Maybe -> Fix Maybe?
05:21:55 <dminuoso> No
05:22:01 <dminuoso> 14:16:55    whataday | MkFix :: Maybe ( Fix Maybe) -> Fix Maybe
05:22:13 <dminuoso> Whatever the argument to `MkFix` is, it must be of type `Maybe (Fix Maybe)`
05:22:13 <whataday> right
05:22:56 <dminuoso> In our first example we used the trivial constructor `Nothing` because that gives us any a `Maybe T` for any choice of T, incuding `Maybe (Fix Maybe)`
05:23:46 <whataday> Just (x :: Fix Maybe) :: Maybe (Fix Maybe)?
05:24:14 <dminuoso> Hold on
05:24:34 <dminuoso> How many ways can you think of constructing something of type `Maybe (Fix Maybe)`?
05:25:28 <whataday> Nothing, Just (Fix (Just ( Fix ...
05:25:43 <whataday> MkFix
05:25:48 <dminuoso> ` Just (Fix (Just ( Fix ...` is not a valid expression.
05:26:26 <dminuoso> So if it's a Maybe, construct a value with it's Just constructor. Think about what type the argument to that Just would need. 
05:26:32 <whataday> Just (MkFix Just (MkFix Nothing))
05:26:50 <dminuoso> Did you guess?
05:27:05 <whataday> yes I guess
05:27:30 <dminuoso> Well sadly it's wrong. 
05:27:38 <dminuoso> Perhaps an accident, but wrong nevertheless
05:27:48 <dminuoso> 14:26:04    dminuoso | So if it's a Maybe, construct a value with it's Just constructor. Think about what type the argument to that Just would need.
05:27:54 <dminuoso> Can you tackle that second sentence?
05:32:12 <whataday> Just need a value x :: Fix Maybe?
05:32:37 <dminuoso> Right. But didn't we just make such a value?
05:32:56 <dminuoso> Oh no we didn't.
05:33:23 <dminuoso> But let's make a value of type `Fix Maybe`. How do we construct values of type `Fix Maybe`? Surely with its data constructor MkFix`.
05:34:00 <dminuoso> 14:20:07    whataday | MkFix Nothing :: Fix Maybe
05:34:05 <dminuoso> You did it a while ago, in fact.
05:34:19 <whataday> MkFix Nothing :: Fix Maybe
05:34:45 <dminuoso> So how do you construct another value of type `Maybe (Fix Maybe)` in conclusion?
05:34:54 <whataday> Just $ MkFix Nothing :: Maybe ( Fix Maybe)
05:34:58 <dminuoso> Spot on.
05:35:18 <whataday> right?
05:35:22 <dminuoso> Yes.
05:35:58 <whataday> newtype Fix f = MkFix f ( Fix f)
05:36:27 <dminuoso> So if you follow this line of though
05:36:38 <whataday> MkFix Nothing :: Fix Maybe
05:36:41 <dminuoso> MkFix Nothing :: Fix Maybe
05:36:48 <dminuoso> MkFix (Just (MkFix Nothing)) :: Fix Maybe
05:36:57 <dminuoso> MkFix (Just (MkFix (Just (MkFix Nothing)))) :: Fix Maybe
05:37:01 <dminuoso> And so forth..
05:38:11 <dminuoso> The MkFix is just visual noise that the type system requires, but semantically it's when you want values of the type `Maybe Maybe Maybe Maybe... ad infinitum` with values like `Nothing`, `Just Nothing`, Just (Just Nothing), Just (Just (Just Nothing)) 
05:39:00 <dminuoso> Granted, this is a not very useful example, but perhaps one example to get acquainted with Fix.
05:40:07 <whataday> when we would need this kind type?
05:40:23 <whataday> used for?
05:41:10 <dminuoso> whataday: consider that recursive types are allowed first
05:41:24 <dminuoso> e.g.: data List a = Cons a (List a) | Nil
05:41:50 <dminuoso> But sometimes, it's more elegant (or perhaps even required for type checking reasons) to transform a recursive type into a non-recursive type (and make it recursive by means of Fix in the necessary spots)
05:43:17 <whataday> anyone else we could actually use in the code?
05:43:29 <dminuoso> In some specialized fields, yes.
05:43:40 <whataday> like?
05:45:40 <dminuoso> I think much of the motivation is the same as for https://maartenfokkinga.github.io/utwente/mmf91m.pdf
05:46:45 <whataday> ok... too fancy to me now
05:47:06 <whataday> dminuoso any way thanks
05:47:44 <Rembane> whataday: Example: https://github.com/Rembane/MiniML/blob/master/src/Language/MiniML/Expr.hs
05:48:30 <dminuoso> Of course, this code requires being intimiately familiar with what cata is/does/means. 
05:48:51 <Rembane> dminuoso: That's a small drawback this code has yes
05:49:11 <Rembane> dminuoso: ...and being intimately familiar with cata leads us back to the paper you linked. 
05:50:58 <mniip> I should learn recursion shcemes one day
05:51:03 <mniip> they seem really handy
05:52:55 <whataday> but there is no Fix ExprF definition
05:53:06 <whataday> in other files?
05:53:17 <funrep__> anyone played with monad-bayes? once i have a sampler of the posterior of my model, in this case an "MonadInfer m => m Bool" how do i for example ask "P(True)", do i need to manually sample X many times and calculate mean and std? 
05:53:42 <st8less> I have a fresh install of Haskell, and I'm trying to install http-conduit on OSX.  I'm getting a failure at installing `network-3.1.1.1` when `stack install http-conduit` in a project.  Any quick ideas, or give up and use Docker?  :)
05:55:53 <dminuoso> st8less: Can you gist/pastie the error you are getting?
05:57:39 <edwardk> mniip: nah. they are a great time sink past the basics
05:58:21 <dminuoso> edwardk: Your recursion-schemes advertises them differently.
05:58:39 <dminuoso> Or are you just that good of a salesman?
05:58:39 <mniip> I come across several patterns in GHC code that look like recursion schemes
05:59:05 <edwardk> dminuoso: eh, don't remember writing that language, but i guess i ddi
05:59:07 <edwardk> er did
05:59:28 <edwardk> i think it might have been cribbed from category-extras
06:00:23 <edwardk> clearer, faster, and safer does not necessarily imply 'easier to wrte
06:00:31 <edwardk> er write'
06:02:04 <edwardk> dminuoso: ah i didn't write that line
06:02:27 <edwardk> that was gelisam
06:06:42 <st8less> dminuoso: https://gist.github.com/dgjustice/b01d437e4c4764a09f6444dc8e0fc255
06:07:54 <dminuoso> st8less: Ah, yeah. You don't use stack that way.
06:08:14 <dminuoso> st8less: I think you have to modify your package.yaml accordingly and then just use `stack build` or `stack repl` (presumably)
06:09:36 <st8less> Ok, cool, thanks!  I'll try that.  Silly n00bs.  :D
06:09:45 * hackage openapi3-code-generator 0.1.0.2 - OpenAPI3 Haskell Client Code Generator  https://hackage.haskell.org/package/openapi3-code-generator-0.1.0.2 (remo_doerig)
06:09:57 <dminuoso> st8less: You might want to give https://docs.haskellstack.org/en/stable/GUIDE/ a read.
06:10:13 <dminuoso> I'm not familiar with stack, but I reckon their team has prepared a guide to cover all your questions.
06:12:39 <merijn> dminuoso: Naive optimism, yay! ;)
06:13:35 <dminuoso> Of course, Haskell package authors are reknown for their cunning ability to throughouly document their code.
06:13:51 <dminuoso> *renown
06:14:47 <merijn> dminuoso: Hey, my code has 1:1500 ratio of comment and code lines! :p
06:15:16 <merijn> And only 12.5% of those comments are FIXME :p
06:15:20 <Bish> can i tell ghci to output stg?
06:15:33 <Ariakenom> cunning documentation ... does that mean made of riddles or something? I approve
06:15:35 <solonarv> you can, yes
06:15:43 <merijn> Bish: Yes, but I don't think it'll listen ;)
06:15:43 <solonarv> just -ddump-stg as usual
06:16:05 <solonarv> idk if STG is actually used when compiling to bytecode though, so maybe you won't get any output
06:16:51 <Bish> solonarv: that makes sense i guess
06:16:53 <Bish> but core is?
06:17:06 <Bish> how do i dump core?
06:17:10 <solonarv> yeah, core is what you get after desugaring
06:17:16 <merijn> "peek nullPtr"
06:17:25 <dminuoso> merijn: Haha.
06:17:28 <merijn> (I'm so witty)
06:17:33 <dminuoso> That was truly funny.
06:17:45 <Bish> solonarv: that would imply haskell is only sugaring
06:17:54 <solonarv> depends on the stage you want: -ddump-ds is right after desugaring, -ddump-simpl is after the simplifier runs, -ddump-prep is the last phase where you still have core
06:19:48 <merijn> hmm, text only has a lazy builder?
06:20:21 <dminuoso> Well, what would a strict builder be exactly?
06:20:40 <dminuoso> Isn't it the whole point of the builder pattern to lazily construct a big chunk of stuff?
06:20:58 <solonarv> the pipeline goes, roughly: source -parse-> "raw" haskell -rename-> renamed haskell -typecheck-> forgot the name -desugar-> core -simplify-> core again -prep-> core --> STG --> ...
06:21:01 <merijn> hmm, I wonder what's faster, using lazy build or just yeeting a bunch of strict Text chunks down a conduit
06:21:19 <merijn> dminuoso: I'm gonna dump it down a conduit anyway
06:21:43 <solonarv> you could use a lazy builder and yeet its chunks down a conduit
06:21:58 <merijn> Maybe I should just use ByteString directly, but I guess there's no efficient way to serialise values to that
06:22:23 <merijn> solonarv: All the Text conduits want strict Text or ByteString builders, so then I'd have to convert the Text builder to strict Text anyway
06:22:28 <merijn> Which feels rather pointless
06:22:41 <dminuoso> I hate Haskell for making it so apparent that you cant have byte access to text, and that text <> bytestring requires conversion, and that you have to deal with conversion errors...
06:23:03 <merijn> dminuoso: There's no conversion errors for Text to ByteString
06:25:15 * hackage futhark 0.15.8 - An optimising compiler for a functional, array-oriented language.  https://hackage.haskell.org/package/futhark-0.15.8 (TroelsHenriksen)
06:25:24 <Bish> why does stg have types :o
06:25:32 <merijn> Bish: Why wouldn't it?
06:26:16 <Bish> i remember having read that it doesn't
06:26:21 <Bish> didn't it have types at some time?
06:26:35 <solonarv> the same reason Core has types: makes it harder for GHC devs to mess up
06:27:37 <Bish> but i have heard a talk where it is was stated that it doesn't have types
06:27:42 <Bish> and i figured that makes sense
06:32:55 <dminuoso> Bish: Remember that both for stg and core the types are actually not checked unless you explicitly set -dcore-lint or -dstg-lint
06:33:22 <Bish> so they're more like notes?
06:33:26 <dminuoso> They are essentially debug tools that you should always flip on certain bugs.
06:33:44 <dminuoso> Well they are tools you can enable to pin down compiler bugs, they cost too much time to run always
06:34:13 <Bish> so you can check stg for types? i wonder why that talk says it doesnt have that :/
06:34:23 <dminuoso> Just like you can check core for types.
06:34:42 <dminuoso> The idea is, GHC has type checked your code, so it's semantically valid. Now GHC takes that code and transforms it into something new.
06:35:00 <dminuoso> core lint and stg lint act as sanity checks, ensuring that GHC doesn't do something completely wonky 
06:35:01 <Bish> https://www.youtube.com/watch?v=-MFk7PIKYsg
06:35:14 <Bish> any idea why this dood says it doesn't have types
06:35:32 <dminuoso> At the time it might not have had types?
06:35:33 <Bish> https://www.youtube.com/watch?v=-MFk7PIKYsg
06:35:53 <Bish> https://www.youtube.com/watch?v=-MFk7PIKYsg
06:35:56 <Bish> oopsie
06:36:05 <Bish> https://youtu.be/-MFk7PIKYsg?t=931
06:36:28 <Bish> that slide shows "all it has" and there is a slide after that with thingsi t doesnt have
06:40:49 <Bish> supposed to have*
06:43:11 <dminuoso> Bish: stg linter has existed since 2014
06:43:27 <Bish> so it's simply wrong?
06:43:32 <dminuoso> 2 years ago there was some debate about removing stg lint though, based on a lot of issues that the stg linter hat.
06:44:57 <dminuoso> I cant tell you why quchen said what he said.
06:45:23 <Bish> david = quchen?
06:45:27 <dminuoso> Yes.
06:45:28 <Bish> and hes a regular here?
06:45:38 <dminuoso> He used to be, now he's only on sporadically
06:45:39 <merijn> Not anymore, it seems
06:45:49 <dminuoso> But you can probably reach him via mail
06:45:56 <Bish> https://youtu.be/-MFk7PIKYsg?t=783 ⇐ that does nothing look like ddump-stg
06:46:51 <dminuoso> Keep in mind he that he was on a different GHC version.
06:46:58 <dminuoso> Perhaps GHC at that time didn't emit type information?
06:47:08 <dminuoso> (Perhaps it was kept internal and used for stg lint only?)
06:49:02 <Bish> is that valid stg tho?
06:49:10 <Bish> i think he wrote that stg part by hand
06:50:02 <merijn> Yes, no, maybe, who knows?
06:50:08 <merijn> Maybe it was at the time?
06:50:11 <merijn> Maybe it still is?
06:50:16 <dminuoso> Bish: Why dont you ask him? https://quchen.github.io/ has his contact details.
06:50:40 <Bish> merijn: thats why i ask?
06:50:45 <Bish> dminuoso: i figured you guys would know
06:51:03 <merijn> Bish: STG isn't exactly a well documented public interface
06:51:06 <dminuoso> Bish: You might have better luck asking in #ghc actually, since core/stg is something that usually they stare at much more than the rest of it.
06:51:19 <dminuoso> Or ask quchen since he was the one who said what he said and wrote what he wrote.
06:51:21 <Bish> didn't know that channel existed
06:52:54 <dolio> If you pass -dsuppress-all, it will come out much closer to those slides.
06:52:57 <dolio> But not identical.
06:53:42 <dminuoso> That might be it, any further difference could easily be 2 (or perhaps more, who knows what version quchen used) years of development.
06:54:30 <Bish> i think quchen wrote these by hand, to make it clear what stg is
06:55:09 <Bish> but he explicitly says it doesn't have types, and that sounds like a fact
06:55:24 <Bish> (inside his talk)
06:55:30 <merijn> bah...there's no way to directly convert doubles to Text?
06:55:44 <dminuoso> ...
06:55:45 <merijn> There's a lazy builder for integrals/RealFloat
06:56:06 <dminuoso> Bish: Perhaps he didn't know?
06:56:14 <Bish> maybe!
06:56:23 <dminuoso> Bish: Really, there's not much value in speculating any further because we can't answer your question
06:56:34 <Bish> well, you could say "that's wrong"
06:56:44 <Bish> and that wouldn't be a speculation anymore
06:57:17 <dminuoso> All I can tell you, is that GHC has had an stg linter for at least 4 years.
06:57:24 <dminuoso> As per git history.
07:02:09 <t7> is IO still a valid monad if given `print 1 >> print 2` the runtime could print '12' OR '21' ?
07:04:53 <Bish> even if that was the case, why wouldn't that be an invalid monad?
07:04:55 <Bish> what is invalid
07:06:18 <t7> i mean it still can obey the monad laws right?
07:06:38 <Bish> guess so
07:06:41 <t7> `print 1` always returns the same thing
07:07:29 <Bish> don't know what makes sure the order is done right when using >> 
07:07:53 <t7> lets just say the runtime chooses at random 
07:08:28 <Bish> i guess it's still a monad, yes
07:08:50 <dminuoso> t7: If the semantics is that it is random, then sure.
07:08:57 <Bish> but when you use >>= >> you kinda "note" that the things further down can only be evaluated if the things "above" are already evluatied
07:09:37 <Bish> how do you call >> ? i forgot
07:09:41 <dminuoso> "then"
07:09:45 <Bish> oof
07:10:04 <dminuoso> t7: The problem is that you cant impose the semantics onto IO
07:10:08 <dminuoso> t7: Consider >>=
07:10:30 <dminuoso> getLine >>= \x -> if x == "die" then exitFailure else exitSuccess
07:10:41 <Ariakenom> t7: you can already write: forkIO (print 1) >> forkIO (print 2)
07:10:43 <dminuoso> You can't randomly order the effects because there's an explicit dependcy ordering
07:11:03 <t7> dminuoso: yeah in this case there is a dependency 
07:11:15 <Bish> t7: >> is an artifical dependency
07:11:15 <dminuoso> t7: If you just made >> random but not >>=, then you have a non-coherent imlementation
07:11:51 <Bish> wasn't haxl able to evaluate "lines" of the sourcecode in parallel?
07:12:09 <Bish> or: does haskell do that either way, i don't know
07:12:24 <t7> dminuoso: maybe i could track the dependencies in the values of IO, or lets make a new monad named Foo
07:12:31 <dolio> Just because some data dependencies determine certain ordering doesn't mean everything has to be linearized.
07:12:56 <Ariakenom> like any optimising compiler the code may not be executed as you expected. but the effects will
07:13:20 <Ariakenom> will happen as expected
07:13:31 <dminuoso> Bish: well haxl can do it if its an applicative.
07:13:36 <dminuoso> % :t (<*>)
07:13:36 <yahb> dminuoso: Applicative f => f (a -> b) -> f a -> f b
07:13:42 <dminuoso> As you can see, there is no data depenency between them.
07:13:46 <dminuoso> So applicative admits for parallelism.
07:13:57 <dminuoso> (You can think of it as a sort of diamond-style forking)
07:14:30 <dminuoso> (It appears to be a monad usually there, because of the ApplicativeDo extension)
07:15:17 <solonarv> haxl is *also* a monad, IIRC, and it breaks the monad laws
07:15:36 <Bish> dminuoso: why is that a requirement for that?
07:15:49 <Bish> applicative ⇒ can do things in parallel?
07:15:57 <dminuoso> 16:13:14      yahb | dminuoso: Applicative f => f (a -> b) -> f a -> f b
07:16:06 <dminuoso> The second argument is independent from the first.
07:16:10 <dminuoso> % :t (>>=)
07:16:10 <yahb> dminuoso: Monad m => m a -> (a -> m b) -> m b
07:16:15 <Bish> hm, okay
07:16:17 <dminuoso> Here the second effect depends on the first.
07:16:23 <solonarv> part of the laws is that 'ff <*> fx' should be equivalent to 'ff >>= \f -> fx >>= \x -> pure (f x)'
07:16:27 <dminuoso> So Monad is deeply rooted in sequentiality.
07:16:28 <Bish> yeah i think applicivedo is that made that possible
07:16:33 <dminuoso> Applicative is deeply rooted in parallelism
07:16:39 <Bish> solonarv: which one does it break?
07:16:40 <dminuoso> (That doesnt mean every applicative can be run parallel though)
07:16:49 <solonarv> the one I just stated
07:16:55 <solonarv> I don't remember what it's called
07:16:57 <Bish> yeah you were too quick
07:17:20 <dolio> It is equivalent.
07:17:23 <Uniaika> does anyone know if I can log ghcide's requests from the editor? I feel that sometimes it just doesn't do what I'm asking it to do
07:17:26 <solonarv> not in the case of haxl
07:17:40 <solonarv> (well, my info might be outdated)
07:18:05 <dolio> Sure, it is. 'Equivalence' just has to not include parallelism.
07:18:22 <solonarv> yeah sure, that's how they justify it ;)
07:18:26 <dolio> Equivalent things can have different parallel behavior.
07:20:59 <dminuoso> I suppose in some sense, a strictly ordered version of two events is the same as two random events... 
07:21:20 <dminuoso> They are potentially indistinguishable!
07:21:36 <dminuoso> If they aren't, run your tests again until they agree.
07:22:01 <dminuoso> Or you could say that the ordered version is just *very* lucky to - for some reason - always appear in the same order
07:24:58 <dolio> Also, contrary to the above, Haskell/GHC has monadic (IO) stuff that is much like parallelism (although it is not actually implemented as happening concurrently).
07:26:19 <dolio> So you cannot tell from `m a -> (a -> m b) -> m b` that 'sequencing' must happen.
07:28:11 <dminuoso> dolio: Can elaborate how that would be true?
07:28:36 <dolio> unsafeInterleaveIO does it.
07:29:00 <dminuoso> I think unsafeInterleaveIO is a very bad example.
07:29:45 * hackage openapi3-code-generator 0.1.0.3 - OpenAPI3 Haskell Client Code Generator  https://hackage.haskell.org/package/openapi3-code-generator-0.1.0.3 (remo_doerig)
07:29:52 <merijn> ah, rats...
07:30:07 <dminuoso> If your reasoning is that because an unsafe magical internal primitive exists some other property doesn't hold, then I'll just argue anything with unsafeCoerce.
07:30:12 <merijn> I've found the double-conversions package, but that doesn't help be with integers..
07:30:24 <Ariakenom> I vote for differentiating concurrency and parallelism
07:30:39 <dolio> Those aren't the same at all.
07:30:49 <dolio> unsafeCoerce and unsafeInterleaveIO, that is.
07:33:06 <dminuoso> dolio: The reason you can state that IO imposes ordering, is because `newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))` under the assumption that it is impossible to generate a State# RealWorld.
07:33:09 <dminuoso> Now
07:33:31 <Ariakenom> from a "is it monad" perspective I dont think interleave is much different from forkIO. see also RecursiveDo
07:33:48 <dminuoso> unsafeInterleaveIO breaks that ordering by being able to generate a State# RealWorld (which is essentially just an unlifted unit)
07:33:50 <dolio> No. That implementation cannot even be used to correctly reason about IO.
07:33:51 <dminuoso> However
07:33:57 <dolio> It is just an implementation hack.
07:34:05 <dminuoso> (>>=) is fundamentally sequenced
07:34:19 <dminuoso> You yourself made an argument about implementation hacks.
07:34:26 <dminuoso> unsafeInterleaveIO is *based* on that implementaiton
07:34:38 <dminuoso> It's based by being able to generate that State# RealWorld
07:34:42 <dminuoso> Anyhow
07:34:53 <dminuoso> (>>=) is fundamentally sequenced because you can't make up the second effect before running the first effect.
07:34:55 <dolio> No, it isn't at all.
07:35:37 <dminuoso> Mmm
07:35:44 <Bish> dolio: how so ?
07:35:46 <dminuoso> Did I confuse it with unsafePerformIO?
07:36:02 <dminuoso> Ah it seems I did.
07:36:06 <dolio> Bish: You'll have to be more specific.
07:36:16 <Bish> if i have ... >>=  (\x => x+x)
07:36:27 <Bish> i'd need to have x, to add it with itself
07:36:42 <c_wraith> > runIdentity (undefined >>= const (pure "hello"))
07:36:44 <lambdabot>  "hello"
07:37:30 <dminuoso> dolio: Fundamentally the reason why unsafeInterleaveIO an unsafePerformIO works, is because of the underlying implementation. Effects are, behind the scenes, tied to evaluation of things. The only reason we even have access to something "breaking the assumed semantics" is because GHC is giving you a backdoor.
07:38:23 <dminuoso> But I still dont accept any "unsafeXXX is a proof that this violates that assumption"
07:39:05 <merijn> If I wanna inline a typeclass method to I put INLINE on the class, the instance, or both?
07:39:12 <dolio> Well, that isn't well-typed. But what unsafeInterleaveIO does is start running subsequent operations with a thunk that only gets filled in once it's actually needed for continuing evaluation. You could also imagine it's evaluated in a lower-priority thread or something, so its effects occur 'at random'.
07:39:33 <dolio> dminuoso: Prove that IO with unsafeInterleaveIO has _no_ possible semantics that are monadic.
07:39:41 <dminuoso> merijn: instances, I think typeclass wide inline pragmas have been suggested on gitlab
07:40:13 <dminuoso> dolio: The effects are still sequenced.
07:40:25 <dminuoso> Are they not?
07:40:57 <dminuoso> unsafeDupableInterleaveIO (IO m) = IO (\ s -> let r = case m s of (# _, res #) -> res in (# s, r #))
07:41:52 <dolio> You can't answer this by looking at the implementation in GHC.
07:43:52 <dolio> If mutable references are implemented by memory operations on a CPU that doesn't guarantee that writes happen in any deterministic order, are the 'effects still sequenced'?
07:44:54 <merijn> dminuoso: Counter point: "replicateM 1000 (readChan foo) :: IO [a]" is not sequenced when you use unsafeInterleaveIO
07:47:03 <ezzieyguywuf> I'm trying to run the first example frem the Prettyprint-Doc documentation, https://hackage.haskell.org/package/prettyprinter-1.6.1/docs/Data-Text-Prettyprint-Doc.html. I've `import Data.Text.Prettyprint.Doc` then entered let prettyType = align . sep . zipWith (<+>) ("::" : repeat "->"), however I get an error [Char] does not match Doc ann. am I doing something wrong?
07:47:44 <merijn> ezzieyguywuf: Lack of OverloadedStrings
07:48:08 <ezzieyguywuf> ah. perhaps the documentation should specify that...
07:48:17 <ezzieyguywuf> or is it so ubiquitously used that it's not needed?
07:48:21 <dminuoso> It is.
07:48:24 <dminuoso> Sadly.
07:48:39 <dminuoso> Though prettyprinter is arguably the one package where the extenion is justifiable.
07:48:43 <dminuoso> And perhaps text.
07:49:36 <dminuoso> ezzieyguywuf: But you are right, the module description could have a hint about that extension.
07:50:33 <dminuoso> Perhaps GHC could actually emit a hint if it has some `match expected type T with actual type '[Char]', if there exists an `instance IsString T` in scope?
07:50:35 <dolio> The monad part is just an algebraic description of a language with extended operations, and since IO is abstract and handled by the runtime system that also implements pure evaluation, it can have very flexible semantics that might not otherwise be possible.
07:50:41 <ezzieyguywuf> 👍 thanks for the help, that fixed me up.
07:50:52 <maralorn> dminuoso: You don‘t think one should use OverloadedStrings?
07:51:24 <ezzieyguywuf> I would think that it's better to be explicit about what types of strings one is using
07:51:26 <dminuoso> maralorn: What do you think `IsString ByteString` does?
07:51:29 <ezzieyguywuf> but, you know, I'm new here...
07:51:50 <dminuoso> Now before you answer, remember that String contains unicode data.
07:52:34 <maralorn> dminuoso: Oh, wow. I never considered that ByteString has an IsString instance.
07:52:45 * hackage openapi3-code-generator 0.1.0.4 - OpenAPI3 Haskell Client Code Generator  https://hackage.haskell.org/package/openapi3-code-generator-0.1.0.4 (remo_doerig)
07:52:50 <maralorn> dminuoso: I guess I‘d like -XStringsAreText.^^
07:54:03 <cocreature> the ByteString instance is crap but I’m not going to start writing T.pack everywhere just to avoid OverloadedStrings
07:54:22 <maralorn> What cocreature says.
07:54:43 <dminuoso> cocreature: sadly the bytestring IsString instance is almost guaranteed in every module you write. transitively.
07:54:49 <dminuoso> and that's the great bummer.
07:55:03 <dminuoso> It's easy to accidentally write a string in place of a bytestring, and frequently it appears to work.
07:55:23 <cocreature> dminuoso: sure but I’m not guaranteed to use it. I don’t recall ever actually having caused a bug due to this
07:56:06 <cocreature> mostly because writing bytestring literals isn’t actually all that common ime and if you do have one it’s mostly in a protocol where the ascii encoding is fine
07:56:22 <dminuoso> cocreature: I have 2 bugs in my track record because of that.
07:56:55 <dminuoso> If you wrongly expect somewhere to accept a Text, but it takes a ByteString..
07:57:32 <cocreature> why do you have non-ascii literals in your code? you seem to have different usecases than I do :)
07:58:05 <merijn> cocreature: To write my name >.>
07:58:19 <mniip> we used to
07:58:27 <cocreature> merijn: the solution is obviously to change your name
07:58:40 <dminuoso> Yes, we should make a GHC proposal to change merijn's name.
07:58:43 <cocreature> merijn: but even then, don’t hardcode your name in your code :)
07:58:48 <dminuoso> Are GHC proposals the correct method?
07:58:51 <solonarv> if only there was a sensible way to have smart constructors peform checks at *compile* time (for literals)
07:59:00 <dminuoso> wait for it...
07:59:00 <mniip> dminuoso, I think this is more of a libraries proposal?
07:59:08 <merijn> solonarv: You mean like my library?
07:59:15 <merijn> @hackage validated-literals
07:59:15 <lambdabot> https://hackage.haskell.org/package/validated-literals
07:59:34 <dminuoso> mniip: Do I get to upload him onto hackage?
07:59:37 <solonarv> :)
07:59:53 <mniip> already there, just gotta get a trustee to make a revision
08:00:10 <solonarv> unfortunately "TH and you need an additional library" is a real cost
08:00:20 <merijn> solonarv: Well, yes
08:00:30 <merijn> solonarv: Which is why I argued to build this into GHC in 2013
08:00:42 <dminuoso> solonarv: Oh I know I know. We could have -XSmartConstructorChecks so we can avoid -XOverloadedStrings.
08:00:42 <merijn> And was told "first show there is demand by implementing it as a library"
08:01:15 <merijn> solonarv: Incidentally, you can't get less dependencies than that library and in the common case you don't need to know how to do TH :p
08:04:11 <disconsis> Hey people - is there any way to derive Read instances for a closed 3rd party library type? It has an instance for Generic
08:04:42 <merijn> disconsis: Yes, but you probably don't want to?
08:04:44 * hackage aws-lambda-haskell-runtime 2.0.6 - Haskell runtime for AWS Lambda  https://hackage.haskell.org/package/aws-lambda-haskell-runtime-2.0.6 (NickSeagull)
08:05:06 <disconsis> I'm curious and fearful
08:05:21 <merijn> disconsis: Read is a bad class and you almost certainly don't want it
08:05:26 <dminuoso> disconsis: Yes and no.
08:05:31 <merijn> If only because it's performance is terrible
08:05:43 <dminuoso> disconsis: Yes in the sense its technically possible, and no in the sense that it requires creating orphan instances which is sort of bad.
08:05:43 <merijn> Secondly, orphan instances are bad, derived or not
08:05:54 <dminuoso> Though whether its bad depends.
08:06:07 <disconsis> I fully agree with all those points, but I don't really have a choice in the matter
08:06:08 <dminuoso> When you write a program/executable, make orphan instances as much as you want.
08:06:20 <disconsis> I *am* writing an executable :)
08:06:28 <dminuoso> Then orphan instances are fine.
08:06:40 <dminuoso> (Until you decide to split off code into a library and publish it...)
08:06:42 <merijn> That doesn't affect point one of "Read is terrible", though :p
08:06:55 <disconsis> I have to write a read instance to persist data for XMonad
08:07:07 <dminuoso> disconsis: Oh this is for xmonad? Go for it.
08:07:29 <merijn> You could just use any other parser/serialisation, though :p
08:07:41 <dminuoso> Haha, it's probably overkill.
08:07:46 <disconsis> merijn: yes and no
08:08:01 <disconsis> XMonad already does that using Show and Read automatically with a setting
08:08:19 <disconsis> I don't want to go through the headache of duplicating that logic just to change the instance
08:08:48 <merijn> In other news
08:08:52 <disconsis> And the constructor for this type isn't exposed anyway
08:09:06 <merijn> Developer pro-tip: When optimising code, make sure you use the codepath you're optimising ;)
08:09:38 <disconsis> hahaha I'll make sure of it :P
08:09:53 <disconsis> Back to the (inefficient) Read instance though
08:10:12 <disconsis> Does just "instance Read <type>" cut it?
08:10:12 <merijn> disconsis: You can try StandaloneDeriving, see GHC user's guide
08:10:42 <disconsis> merijn: Ah shit, that's what I was forgetting. Thanks!
08:10:45 <dminuoso> disconsis: No, that actually does something different.
08:11:03 <dminuoso> For reasons that are beyond me, leaving method definitions doesn't error out GHC?
08:11:28 <disconsis> I had a vague recollection of doing this for FromJSON and ToJSON, so I thought this would work
08:12:00 <dminuoso> disconsis: The reason it works there is because FromJSON and ToJSON have default definitions that use Generics.
08:12:39 <disconsis> dminuoso: Ohhhhh okay
08:12:42 <disconsis> That makes sense
08:14:38 <disconsis> Well fuck. GHC is complaining that the constructors aren't exposed
08:14:57 <dminuoso> disconsis: What datatype is that?
08:15:04 <disconsis> Bimap
08:15:14 <dminuoso> As in from the package `bimap`?
08:15:21 <disconsis> http://hackage.haskell.org/package/bimap-0.4.0/docs/Data-Bimap.html#t:Bimap
08:15:22 <disconsis> Yep
08:15:42 <dminuoso> How much dirty dirt are you willing to accept?
08:16:01 <disconsis> dminuoso: ...some....
08:16:03 <dminuoso> You could copy the definition, generate an instance for that and unsafeCoerce between them.
08:16:28 <merijn> ugh
08:16:30 <dminuoso> (If the constructor layout ever changes xmonad will likely segfault and you have to fix that...)
08:16:37 <dminuoso> merijn: Its just for xmonad... :P
08:16:40 <merijn> I wish there was a foldMap that also did intersperse
08:16:44 <merijn> dminuoso: Unrelated
08:16:46 <dminuoso> Ah
08:17:22 <merijn> The number of times I've wanted to foldMap things with an interspersed values is, like 20, and there's no elegant way to do it
08:17:38 <disconsis> dminuoso: not *that* desperate yet. I'll try to find another package in the meanwhile
08:17:42 <dminuoso> disconsis: Or you write your own Read instance that unfolds your string into a bimap
08:17:50 <dminuoso> disconsis: It's probably easier to just write it out by hand then.
08:18:06 <disconsis> Yeah, I think it'll have to come to that
08:18:13 <disconsis> Thanks for your help
08:26:45 * hackage hoauth2 1.14.0 - Haskell OAuth2 authentication client  https://hackage.haskell.org/package/hoauth2-1.14.0 (HaishengWu)
08:37:18 <funrep__> If i get "Prelude.!!: index too large" is there anyway to backtrace where the (!!) is called?
08:38:36 <lortabac> funrep__: if you compile with profiling enabled, you can run the executable with +RTS -xc -RTS to get stack traces
08:39:53 <funrep__> oh nice! do i just add those to "ghc-options:" in my cabal or do i have to set something up for profiling?
08:40:31 <dmwit> disconsis: Does it have a Show instance already?
08:41:34 <dmwit> disconsis: If not, you can do like `instance ... => Show (Bimap k v) where show m = show (toList m); instance ... => Read (Bimap k v) where read s = fromList <$> read s` or whatever.
08:41:48 <dmwit> disconsis: If it does already have a Show instance, you could newtype wrap it to give your own.
08:43:28 <dmwit> Obviously use the better Show/Read methods, I just didn't want to look up their types and write all the confusing noise in IRC.
08:43:51 <whataday> dminuoso data ExprF a = Const Int | Add a a
08:44:17 <whataday> Const 3 :: ExprF (Fix ExprF)
08:44:37 <whataday> MkFix (Const 3) :: Fix ExprF
08:45:15 <dminuoso> funrep__: Are you using cabal v2-*?
08:45:20 <whataday> Add (MkFix (Const 3)) (MkFix (Const 3)) :: ExprF (Fix ExprF)
08:45:47 <lortabac> funrep__: -xc is a runtime option. Profiling needs to be enabled at compilation
08:46:02 <whataday> MkFix $ Add (MkFix (Const 3)) (MkFix (Const 3)) :: Fix ExprF
08:46:13 <dminuoso> funrep__: You could just build with `cabal v2-build --enable-profiling --profiling-detail=all-functions` and then execute with the runtime flags above
08:46:36 <whataday> dminuoso I don't understand what this ExprF is used for?
08:46:45 <lortabac> funrep__: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/profiling.html#profiling
08:47:15 <lortabac> or let cabal do it, as dminuoso said
08:47:16 <dminuoso> whataday: essentially imagine coming from `data Expr = Const Int | Add Expr Expr | Mult Expr Expr`
08:47:29 <funrep__> i am building the project using this configuration: https://github.com/hasktorch/hasktorch/blob/master/examples/examples.cabal so cabal 2.2
08:47:36 <funrep__> thanks for the pointers!
08:48:10 <whataday> dminuoso it's related to parser or eval something?
08:48:14 <dminuoso> whataday: So this is turned into `data ExprF a = Const Int | Add a a | Mult a a`
08:48:16 <dminuoso> whataday: Right!
08:48:37 <dmwit> whataday: Well, obviously it's the free magma over Ints, what could be simpler? ;-)
08:49:15 <dminuoso> whataday: I left the Mult constructor away for simplicity, but really imagine there being multiple constructors.
08:49:30 <whataday> is there a simple example for this?
08:49:59 <dminuoso> https://bartoszmilewski.com/2013/06/10/understanding-f-algebras/ can perhaps guide you through it
08:50:18 <dminuoso> But it's filled with references to category theory.
08:52:54 <dminuoso> whataday: The cool thing you get with this, is you can define an arbitrary algebra with a carrier of your chosing, say `fooAlg :: ExprF String -> String`, and get an evaluation function for free by just writing `eval :: Fix ExprF -> String; eval = cata fooAlg`
08:53:07 <dminuoso> (cata is a common recursion scheme utility)
08:53:49 <whataday> ok... Cat Theory is fancy to me
08:53:56 <dminuoso> Ignore the category theory, its irrelevant really
08:54:14 <dminuoso> Look at the blog post I mentioned, there's a section title that reads "foldr", right above is a motivating example.
08:54:18 <dminuoso> It shows how clean and simple it looks.
08:54:28 <whataday> ok
08:54:31 <dminuoso> (Ignore the definition of cata, you can assume its defined in a recursion scheme library)
08:54:34 <merijn> whataday: Cat theory is easy, they love warm places, cream and chicken ;)
08:55:24 <dminuoso> whataday: https://gitlab.com/snippets/1981002
08:55:32 <dminuoso> Like, if this doesn't look dead obvious and simple, I dont know what is!
08:56:46 <mniip> do you think it would be useful to have a library that interfaces with the GHC heap?
08:58:11 <merijn> mniip: Explain?
08:58:55 <mniip> a more elaborate wrapper on top of unpackClosure# that is able to parse in-memory closures and info tables taking into accounts the options the runtime has been compiled with
08:59:40 <dminuoso> whataday: Let me give a motivating similar tool.
08:59:44 <dminuoso> whataday: Have you ever used foldr?
09:00:48 <mniip> I wrote this the other day
09:00:59 <mniip> % pp x=compose_3pba unpackClosure#x(\p b a->let t=W#(indexWord32OffAddr#p 2#);s=I#(sizeofByteArray#b)`div`8-1;u=I#(sizeofArray#a);c=foldl(\z(I#i)->z++' ':show(I#(indexIntArray#b(i+#1#)))++"#")(foldl(\z(I#i)->z++' ':composei1_(indexArray#a)i pp)(if t<8 then unpackCString#(plusAddr#(plusAddr#p 16#)(indexInt32OffAddr#p-2#))else"closure_"++show t)[0..u-1])[u..s-1];in if s+u>0 then '(':c++")"else c)
09:00:59 <yahb> mniip: ; <interactive>:25:256: error:; * Variable not in scope: unpackCString# :: Addr# -> [Char]; * Perhaps you meant `BS.packCString' (imported from Data.ByteString)
09:01:16 <mniip> % pp x=compose_3pba unpackClosure#x(\p b a->let t=W#(indexWord32OffAddr#p 2#);s=I#(sizeofByteArray#b)`div`8-1;u=I#(sizeofArray#a);c=foldl(\z(I#i)->z++' ':show(I#(indexIntArray#b(i+#1#)))++"#")(foldl(\z(I#i)->z++' ':composei1_(indexArray#a)i pp)(if t<8 then unpackCString#(plusAddr#(plusAddr#p 16#)(indexInt32OffAddr#p-2#))else"closure_"++show t)[0..u-1])[u..s-1];in if s+u>0 then '(':c++")"else c)
09:01:16 <yahb> mniip: 
09:01:34 <dminuoso> It prints.. nothing?
09:01:34 <mniip> and I was perplexed by how difficult it is to understand the memory layout, even having the C sources for the RTS in hand
09:01:41 <mniip> well we defined a function
09:01:47 <mniip> % pp "foo"
09:01:48 <yahb> mniip: "(closure_24 (closure_23 (closure_42 14# 7318353689444377# 249108103179#) (closure_42 8# 30760096#) (closure_45 closure_14 2# 140499899502944# 140499645364737#) 25769803776# 0#) 0# 140499599650112#)"
09:01:52 <mniip> % pp $! "foo"
09:01:52 <yahb> mniip: "(ghc-prim:GHC.Types.: (ghc-prim:GHC.Types.C# 102#) (closure_20 140499895330472# 30760128# 0#))"
09:02:00 <mniip> % pp $! force "foo"
09:02:00 <yahb> mniip: ; <interactive>:30:7: error: Variable not in scope: force :: [Char] -> a0
09:02:21 <mniip> % pp $! Control.DeepSeq.force "foo"
09:02:21 <yahb> mniip: "(ghc-prim:GHC.Types.: (ghc-prim:GHC.Types.C# 102#) (closure_38 (ghc-prim:GHC.Types.: (ghc-prim:GHC.Types.C# 111#) (closure_38 (ghc-prim:GHC.Types.: (ghc-prim:GHC.Types.C# 111#) (closure_38 (ghc-prim:GHC.Types.[] 140499899463464#)))))))"
09:02:35 <mniip> weird but you get the gist
09:03:19 <dminuoso> Right, seems fairly need. 
09:03:21 <dminuoso> neat.
09:03:46 <mniip> but this specific code is *highly* dependent on RTS compilation options
09:03:55 <mniip> TABLES_NEXT_TO_CODE, profiling etc
09:05:27 <mniip> there used to be ghc-vacuum which as part of its operation did something similar
09:05:32 <mniip> but vacuum is no longer maintained
09:06:49 <whataday> dminuoso no, I just used foldl and foldl1
09:07:19 <dminuoso> whataday: Well, regarding the following example they work just as well
09:07:28 <dminuoso> Consider from a zoomed out perspective:
09:07:35 <dminuoso> % foldr1 (+) [1,2,3,4]
09:07:36 <yahb> dminuoso: 10
09:08:16 <dminuoso> Now foldr1  turns this into `((1+2)+3)+4` - there's an obvious recursive pattern (which is from the way that list is defined!)
09:08:22 <dminuoso> But I give it a flat function that just adds two numbers.
09:08:43 <dminuoso> Considering the exact nature of the data type it'd be better to actually say
09:08:49 <dminuoso> % foldr (+) 0 [1,2,3,4]
09:08:49 <yahb> dminuoso: 10
09:08:54 <dminuoso> If you look at how list is defined, this might make sense to you
09:09:14 <whataday> ok
09:10:08 <dminuoso> Equivalently, we can do
09:10:10 <whataday> I have to go now, thanks and have a nice day :)
09:10:14 <dminuoso> % foldr (*) 1 [1,2,3,4]
09:10:14 <yahb> dminuoso: 24
09:10:21 <dminuoso> This is really simple to reasona about :)
09:10:36 <Wes98> I've got a WriterT list monad that I want to filter, but I can't figure out how to do it. filterM seems to be the opposite of what I want. How do I do this?
09:10:51 <mniip> :t censor
09:10:52 <lambdabot> MonadWriter w m => (w -> w) -> m a -> m a
09:10:55 <whataday> I have check that article in a few hours:)
09:10:59 <mniip> Wes98, ^
09:11:04 <whataday> will
09:12:15 * hackage squares 0.1.1 - The double category of Hask functors and profunctors  https://hackage.haskell.org/package/squares-0.1.1 (SjoerdVisscher)
09:16:38 <Wes98> So, for a monad of m, it takes a function that goes from w -> w and a WriterT and returns a WriterT. But isn't that more like map than filter?
09:17:00 <dminuoso> Wes98: The word filter is meant in the sense that it writes to a log.
09:17:43 <dminuoso> You are censoring the log so to speak.
09:19:07 <dminuoso> A simple way to think of it `censor filterPassword logRequest` where `filterPassword` will censor the log so that it removes all plaintext passwords.
09:19:27 <fresheyeball> so I got a problem
09:19:30 <fresheyeball> https://gitlab.com/fresheyeball/Shpadoinkle/-/jobs/569950363
09:19:40 <fresheyeball> I added antora docs to my project and am serving them with gitlab pages
09:19:53 <fresheyeball> so in my gitlab runner build I do the following
09:20:01 <fresheyeball> cp -r result/* public
09:20:01 <dminuoso> Random gitlab ci issue?
09:20:05 <fresheyeball> no
09:20:08 <Wes98> oh. Okay, let me try again. I have a WriterT [(Int,Int)] [] (Int,Int)  which ends up looking like `WriterT [((6,2],[(4,2),(3,4)]),...]` I want to filter that list down to only those with a fst of (6,2)
09:20:18 <fresheyeball> erp sorry wrong irc
09:20:48 <dminuoso> Wes98: Sure you can do that with censor. 
09:21:15 * hackage hvega 0.9.0.0 - Create Vega-Lite visualizations (version 4) in Haskell.  https://hackage.haskell.org/package/hvega-0.9.0.0 (DouglasBurke)
09:22:59 <dminuoso> % censor (filter (\(x,_) -> x == (6,2)))
09:22:59 <yahb> dminuoso: ; <interactive>:42:1: error:; * No instance for (Show (m0 a0 -> m0 a0)) arising from a use of `print'; (maybe you haven't applied a function to enough arguments?); * In a stmt of an interactive GHCi command: print it
09:23:02 <dminuoso> % :t censor (filter (\(x,_) -> x == (6,2)))
09:23:03 <yahb> dminuoso: (MonadWriter [((a1, b1), b2)] m, Eq a1, Eq b1, Num a1, Num b1) => m a2 -> m a2
09:24:19 <Wes98> `censor (\(x,_) -> (6,1) == x) a` => ` Couldn't match expected type `((a, b), b1)'
09:24:36 <Wes98> oh the filter...
09:25:35 <dminuoso> Wes98: censor takes a function that "manipulates" the log and an action - it executes the action, applies the filter but leaves the return value of the action untouched.
09:27:21 <Wes98> I got it to work, but it's not what I want. I see now that it removes log entries while keeping the "value in a context" untouched.
09:28:54 <Wes98> cool, but I have a monad list of "values in a context" with their logs which are how we arrived at that value. I want to extract the items in the monad list that have a current value of (6,2) and keep them and their logs (context) while discarding others.
09:29:00 <ezzieyguywuf> I feel like I'm re-inventing the wheel - I want to prettyprint my Data.Map.Map, and it seems like using the prettyprint package is the 'right' way to do this. How do a make a Doc MyMap?
09:29:41 <ezzieyguywuf> I understand in the Prettyprint.Doc documentation how they gave an example with [String], but I don't understand how to translate this to Data.Map
09:29:57 <dminuoso> ezzieyguywuf: The "right way" would be to write a function `prettyMap :: Map T -> Doc`
09:30:18 <dminuoso> ezzieyguywuf: The entire point of prettyprinter is to give you the tools to write such a function.
09:31:45 <dminuoso> Ah the correct type would be `prettyMap :: Map T -> Doc ann` of course (or perhaps some specific annotation type)
09:32:15 <ezzieyguywuf> yea, but I'm still confused. For example, per the flowchart in the Pretttyprint.Doc documentation, I would use (say) vsep to create a Doc. But vsep is `[Doc ann] -> Doc ann`, so it presumes I already have a Doc to start with
09:34:22 <Wes98> ah, mfilter is what I needed
09:35:05 <Wes98> dominuoso, thanks for the assist
09:37:32 <ezzieyguywuf> in fact, I don't understand how `vsep ["hello", "world"]` works
09:37:45 * hackage ihaskell-hvega 0.2.6.0 - IHaskell display instance for hvega types.  https://hackage.haskell.org/package/ihaskell-hvega-0.2.6.0 (DouglasBurke)
09:37:52 <ezzieyguywuf> how is `[String]` a `[Doc ann]`
09:38:25 <merijn> ezzieyguywuf: OverloadedStrings extension turns string literals into "anything that is an instance of IsString"
09:38:41 <merijn> ezzieyguywuf: "Doc" is an instance of IsString
09:38:50 <ezzieyguywuf> merijn: so let's say I wanted to do this without OverloadedStrings, for science
09:38:51 <solonarv> with OverloadedStrings, the type of ["hello", "world"] is not [String]. instead it is 'IsString s => [s]'
09:38:52 <ezzieyguywuf> how would I do that?
09:39:15 * hackage hsinspect-lsp 0.0.1 - LSP interface over the hsinspect binary.  https://hackage.haskell.org/package/hsinspect-lsp-0.0.1 (tseenshe)
09:39:15 <merijn> ezzieyguywuf: You'd have to explicitly call 'pretty' on each string literal
09:39:34 <merijn> ezzieyguywuf: (or do 'map pretty ["hello", "world"]')
09:40:13 <ezzieyguywuf> it looks like Char is an instance of Pretty, but not [Char] (or String)
09:40:16 <ezzieyguywuf> am I missing something?
09:42:44 <merijn> It is, transitively via "Pretty a => Pretty [a]" but that's probably not what you want
09:43:06 <merijn> ezzieyguywuf: The library pretty much assumes you're either using Text and/or OverloadedStrings
09:43:51 <ezzieyguywuf> ah, things are making more sense now
09:44:26 <ezzieyguywuf> so the Pretty class is used to turn an `a` into a `Doc ann`, and there are Pretty instances for all sorts of things, including Data.Text, Int, etc.
09:44:39 <merijn> ezzieyguywuf: Yes
09:44:54 <ezzieyguywuf> so if I create a function that turns my Data.Map into, say, a Data.Text (or an Int even), then I can 'prettify' it and turn it into a Doc ann
09:46:11 <merijn> ezzieyguywuf: Well, usually you'd define a new pretty instance for your type and implement pretty using existing instances, but yes
09:46:51 <ezzieyguywuf> hm, I can see how defining a pretty instance would be preferable. I'll work up to taht.
09:47:12 <ezzieyguywuf> i'll start with a function to convert a (key, value) to a suitable Doc ann and go from there
10:53:52 <dminuoso> I prefer not using Pretty instances because its more messy
10:54:30 <dminuoso> It scales far better if you use prettyFoo functions, generally there's little value from using the Pretty typeclass, unless you have an obvious, single, canonical Pretty form for your thing
10:54:49 <dminuoso> Also it requires less clutter, as you can write them as little bindings in your let/where clauses
10:57:15 * hackage aur 7.0.3 - Access metadata from the Arch Linux User Repository.  https://hackage.haskell.org/package/aur-7.0.3 (fosskers)
10:58:15 * hackage aura 3.1.0 - A secure package manager for Arch Linux and the AUR.  https://hackage.haskell.org/package/aura-3.1.0 (fosskers)
11:16:50 * hackage cpsa 3.6.6 - Symbolic cryptographic protocol analyzer  https://hackage.haskell.org/package/cpsa-3.6.6 (mliskov)
11:18:10 <tabaqui1> hey all!
11:18:28 <tabaqui1> Do you know a cool paper about testing parallel code?
11:18:48 <tabaqui1> I guess, actor model is very common in Haskell
11:19:04 <tabaqui1> but I can't realise how to test it properly
11:19:35 <merijn> tabaqui1: Are you sure you're not thinking of concurrent code?
11:20:01 <tabaqui1> parallel code is a subset of concurrent, right?
11:20:17 <merijn> No, I'd even say they're not on the same axis
11:20:51 <tabaqui1> concurrency is all about multitasking. It can be parallel of asyncronious. The last one can be preemptive or cooperative
11:20:54 <monochrom> What all of you need to be aware is that different communities use different, even conflicting, terminologies on this.
11:21:17 <tabaqui1> *parallel or asyncronious
11:21:25 <merijn> monochrom: I know, but anyone who disagrees with me is wrong! ;)
11:21:44 <monochrom> No, anyone who disagrees with my thesis supervisor is wrong. :)
11:21:45 <Uniaika> let's say that the terminology from Marlow's book is Right
11:21:50 <Uniaika> and everyone else is Wrong
11:21:51 <merijn> tabaqui1: Concurrency is about the semantics of code. i.e. the fact that several effects can be "arbitrarily interleaved"
11:22:00 <merijn> Uniaika: He uses the same as mine, so that's fine
11:22:12 <Uniaika> merijn: ;D
11:22:13 <tabaqui1> ghc implements preemptive multitasking, but programmer deal with it like with parallel
11:22:19 <merijn> tabaqui1: Parallelism otoh is an implementation detail, i.e. "things are actually happening at the same time"
11:22:47 <merijn> tabaqui1: In the threaded runtime GHC threads are both concurrent (in semantics) and parallel (executing at the same time)
11:23:00 <monochrom> My supervisor's cut: parallel = concurrent.  Oh you say the processes/threads are interacting/interfering?  That's communication.
11:23:20 <tabaqui1> all right :)
11:23:25 <tabaqui1> anyway
11:23:27 <merijn> tabaqui1: But these are orthogonal properties. Deterministic parallel code you can test the same as regular functions, it's still deterministic
11:23:33 <tabaqui1> how would you test actors based code?
11:23:36 <merijn> tabaqui1: Concurrency is much harder
11:23:45 <merijn> tabaqui1: I advise lots of whisky and crying ;)
11:23:56 <tabaqui1> I have both
11:24:01 <tabaqui1> What is next?
11:24:32 <tabaqui1> No shiny papers from some famous mathematician?
11:24:55 <merijn> tabaqui1: More realistically, having spend several years on distributed language runtimes I'd say that testing is a doomed method for dealing with concurrency. The only workable approach is a more formal method, define a state machine or whatever and convince yourself that 1) your state machine model is correct and 2) your code matches it
11:25:28 <merijn> tabaqui1: There's lots of stuff on formal verification of concurrent systems, but they're all rather arduous
11:26:09 <monochrom> On this front I do think that formal verification is ahead of testing.
11:26:34 <monochrom> Even, the testing people have given up.
11:26:52 <monochrom> Some of them switched to the formal verification side. :)
11:27:09 <tabaqui1> No doubts, but it is much harder
11:27:10 <merijn> Mu calculus and CSP are some starting pointers
11:27:33 <monochrom> The formal verification side also takes on a flavour of testing, i.e., they're OK with approximations and incompleteness.
11:27:59 <ezzieyguywuf> dminuoso: can you provide an example where you've used 'prettyFoo' and mabye a counter-example where the Pretty instanced were 'cluttered'?
11:28:08 <tabaqui1> merijn: that is something!
11:28:30 <tabaqui1> thx
11:28:31 <monochrom> The most obvious one being bounded model checking, e.g., "checked for 10 threads".
11:29:06 <merijn> tabaqui1: One of my former professors worked a lot on that stuff, he has some links to course notes: https://www.cs.vu.nl/~wanf/courses.html
11:30:44 <tabaqui1> sweet
11:42:25 <monochrom> would be nice if you extend "concurrent is semantics, parallel is implementation, they are orthogonal" to "non-strict is semantics, lazy is implementation, they are orthogonal" and therefore by this logic it makes no sense to say "lazy data vs strict data".
11:42:30 <dminuoso> ezzieyguywuf: The problem with typeclass based instance for such things appear when suddenly you want to have two different pretty styles for a given type.
11:43:00 <monochrom> either that or concede that when Y implements X, X and Y are no longer all that orthogonal after all.
11:44:01 <dminuoso> ezzieyguywuf: If you split code off into a library, you get into the open world assumption, where you can have only a single Pretty instance for a given type. So you either start newtyping just to have access to different Pretty forms, or you just end up writing prettyFoo and prettyFoo' anyway.
11:44:11 <ezzieyguywuf> dminuoso: ah hah. Whereas with the function approach, `prettyMyType`, `prettyMyType'` is possible, this is not the case with `instance Pretty MyType`
11:44:25 <monochrom> (I take the latter stance. The x axis is orthogonal to the y axis.  Therefore the y axis cannot possibly implement the x axis.)
11:44:27 <dminuoso> Right. And you can control it via exports, you can pass things around in dictionaries...
11:45:04 <ezzieyguywuf> interesting. I'm still wrapping my brain around "functions are first-class citizens in haskell", but this seems a very concrete example of how that is useful
11:45:36 <merijn> ezzieyguywuf: That's pretty common in lots of languages now (python, JS, even Java, I think?)
11:45:46 <dminuoso> I've stopped using FromJSON and ToJSON for the same exact reason. My code has gotten cleaner ever since.
11:45:54 <ezzieyguywuf> merijn: it is. even c++
11:46:06 <merijn> ezzieyguywuf: Much weirder is that in haskell IO is also first class and can be put in data structures :)
11:46:07 <ezzieyguywuf> I'm just more used to progrmming from an object-oriented standpoint
11:46:56 <ezzieyguywuf> hah, well whereas I'm perhaps beyond dipping my toes into haskell, I'm still probably only up to my ankles or knees. I don't think I can appreciate the weirdness of what you've described :-P
11:46:58 <dminuoso> The only good reason for ToJSON and FromJSON is the Generic derived instances, but I usually find myself replacing them with handwritten instances *anyway*. So I might as well not use typeclass based JSON at all.
11:47:15 <merijn> ezzieyguywuf: For example try the following in ghci: "map print [1..10] !! 3"
11:47:54 <ezzieyguywuf> merijn: 4
11:48:09 <merijn> :t map print [1..10]
11:48:10 <lambdabot> [IO ()]
11:48:29 <ezzieyguywuf> *insert mind blown emoji*
11:48:32 <merijn> ezzieyguywuf: Note that the map creates a list of IO actions, but doesn't actually run/do anything with them
11:48:35 <ezzieyguywuf> IO is 'just a monad' though, right?
11:48:38 <ezzieyguywuf> like...a box?
11:48:48 <monochrom> monad is not like a box.
11:49:07 <merijn> ezzieyguywuf: They only get run/executed when you manually tie them into an existing IO action (which, in the end boils down to "somewhere in main")
11:49:09 <monochrom> there are only a few exceptions.
11:49:28 <merijn> @quote shachaf list.of.files
11:49:29 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
11:49:32 <monochrom> A few trivial monads are like boxes. The interesting monads are no where near.
11:49:40 <dminuoso> ezzieyguywuf: IO Int can be thought of as a type representing *assembly* instructions that, if they were executed, would produce an Int as their result.
11:50:09 <merijn> ezzieyguywuf: It helps to (conceptually) think of IO values as "actions" (or "program fragments") that produce some value when executed
11:50:11 <dminuoso> And in some sense, you get to hold these "instructions" themselves as a first class action.
11:50:11 <awpr> `data Box a = Box a` <- this is a trivial monad that's like a box :) 
11:50:19 <dminuoso> *first class value
11:50:23 <monochrom> For example IO isn't, State isn't, Reader isn't, Cont isn't.
11:50:27 <merijn> awpr: How about "data Proxy a = Proxy"? ;)
11:50:33 <ezzieyguywuf> dang
11:50:37 <awpr> an empty box :D
11:50:37 <ezzieyguywuf> that's a lot y'all :-P
11:50:55 <ezzieyguywuf> although I can say I can now appreciate the "weirdness" of what merijn said earlier
11:51:03 <monochrom> When you think IO you should think of unix commands such as ls.
11:51:16 <dminuoso> ezzieyguywuf: Anyway, you asked for an example regarding pretty functions. Ive prepared a snippet from one of my projects (they are taken out of nested bindings, so there's a couple of undeclared identifiers in them, but they shouldnt be relevant) https://gitlab.com/snippets/1981051 
11:51:38 <monochrom> ls is not a box. ls doesn't "already contains and conceals a fixed list of files".
11:51:54 <dminuoso> I write them on the spot in where bindings, so they are just local
11:52:00 <ezzieyguywuf> O_O ppr0n?! lol
11:52:16 <monochrom> @quote IO.*ls
11:52:16 <lambdabot> rickyclarkson says: I've been experimenting with functional programming from within Java (is this like asking your wife to dress up as someone else?)
11:52:23 <monochrom> hrm, not that one
11:52:26 <dminuoso> Note that Msg is just a type alias for `Doc AnsiStyle`
11:52:30 <merijn> monochrom: I already quotes it earlier
11:52:37 <merijn> s/quotes/quoted
11:52:48 <monochrom> @quote ls.*contain
11:52:49 <lambdabot> smerdyakov says: Some might argue that you can derive False from a sentence containing both "dependent types" and "contract programming."
11:52:52 <monochrom> darn
11:53:00 <merijn> monochrom: Now you're just embarrassing yourself ;)
11:53:01 <monochrom> @quote shachaf ls
11:53:02 <lambdabot> shachaf says: <dmwit> CReal is the computable reals. <shachaf> Just like CInt is the computable integers!
11:53:10 <merijn> haha
11:53:12 <yushyin> oO
11:53:27 <monochrom> yeah sorry, I'll work on it in private first
11:53:37 <merijn> @quote shachaf list.of.files
11:53:37 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
11:53:40 <dminuoso> Oh and "On" is just a short suffix for "Ontep"
11:53:44 <monochrom> Yeah, that one.
11:54:17 <monochrom> But hey, getLinee contains a string in the same way monochrom contains lambdabot quote database!
11:54:20 <ezzieyguywuf> dminuoso: if you write them on-the-spot in where-bindings, how can you refer to one from the other, i.e. "pprVLANs i = foldr1 (<+>) (pprVLANcom..."
11:54:32 <dminuoso> ezzieyguywuf: Some of them are in the same group.
11:54:39 <dminuoso> I just grepped `ppr` and copy pasted a chunk. :P
11:54:52 <ezzieyguywuf> gotcha. well thanks that is helpful!
11:55:09 <ezzieyguywuf> and my face was just because pr0n is sometimes used as a sort of euphamism
11:55:19 <ezzieyguywuf> i know it was likely unintentional
11:55:37 <dminuoso> Heh. No, in the codebase you will find a lot of *On things, which are all related to ontep interfaces...
11:55:38 <monochrom> Hey, how do you derive false from dependent programming and contract programming?!
11:55:54 <monochrom> err dependent types
11:55:55 <dminuoso> Written out I would have written pprOntepInterface ...
11:56:02 <monochrom> (much as I despise dependent types)
11:56:04 <merijn> "It's been 0 hours since I last appreciated adding a version number to my database schema..."
11:56:06 <dminuoso> But my pretty code should be dence and compact..
11:56:09 <merijn> monochrom: I love dependent types
11:56:13 <merijn> monochrom: Just not in Haskell :p
11:56:19 <monochrom> same here
11:57:59 <monochrom> dminuoso: If your pretty code prettyprints exactly the rational numbers between 0 and 1 inclusive, it's dense and compact. :)
11:58:15 <monochrom> at least the output is.
11:58:50 <dminuoso> Hold on, is that a trick question hidden inside a statement?
11:58:57 <ezzieyguywuf> dminuoso: in your code, what is Msg? some sort of wrapper around Doc ann?
11:59:06 <dminuoso> 20:52:04     dminuoso | Note that Msg is just a type alias for `Doc AnsiStyle`
11:59:19 <ezzieyguywuf> ah, thanks
11:59:31 <monochrom> No, just a topology joke from a childish guy who learned just the definitions in topology.
11:59:47 <dminuoso> It gets tiring to write `Doc AnsiStyle` everywhere, and I have established a personal rule that "if its worth binding it to a variable, its worth writing a type annotation for it"
11:59:52 <ezzieyguywuf> topology! i'm trying to write topology in haskell :)
12:00:10 <merijn> dminuoso: You're violating the prettyprinter recommendations by using AnsiStyle everywhere! ;)
12:00:35 <dminuoso> Can you violate a "recommendation"?
12:01:13 <merijn> dminuoso: The recommendation is to use an application specific annotation and then map it to the backend specific only right before calling said backend
12:01:13 <dminuoso> Also, where is that recommendation to be found?
12:02:20 <merijn> dminuoso: "Some helpful tips" in the documentation at the top
12:02:28 <merijn> "Summary: Use semantic annotations for Doc, and after layouting map to backend-specific ones."
12:02:36 <ezzieyguywuf> dminuoso: https://hackage.haskell.org/package/prettyprinter-1.6.1/docs/Data-Text-Prettyprint-Doc.html#g:2 under 'some helpful tips'
12:03:07 <dminuoso> Ah well, I actually rejected that thought on the basis of being lazy.
12:03:31 <dminuoso> Being a professional programmer, I get paid to decide where I'm lazy. I decided that I can just infest AnsiStyle everywhere.
12:03:31 <merijn> The bigger my Haskell codebase grows the more I learn to appreciate not being lazy
12:03:39 <merijn> Defining custom datatypes everywhere, etc.
12:03:42 <dminuoso> Well this is actually trivially refactorable, luckily.
12:04:08 <merijn> I, for one, can't wait to welcome our -XNoFieldSelectors overlords
12:05:18 <dminuoso> merijn: Actually I remember now. The reason I actually use AnsiStyle is even more silly...
12:05:33 <dminuoso> My code already has the necessary modularity.
12:06:00 <dminuoso> But it would have required an additional call to unAnnotate...
12:06:23 <dminuoso> So it seemed simpler to just write Doc AnsiStyle instead, and when I got tired of that, I wrote a type alias for it..
12:06:36 <dminuoso> I saved typing `unAnnotate` twice.
12:06:40 <dminuoso> Profit.
12:07:15 <ezzieyguywuf> lol
12:07:20 <ezzieyguywuf> i just program for fun
12:07:44 <merijn> No fun allowed, srs bsns only
12:08:04 <ezzieyguywuf> fine, i'll head back to python.
12:08:11 <ezzieyguywuf> they have a cute mascot and everything.
12:08:13 <monochrom> would be nice if robots wrote all the code for work, so we write code for fun only
12:08:15 <merijn> You have a twisted idea of fun >.>
12:08:28 <ezzieyguywuf> hah, that's what my wife says.
12:08:30 <merijn> monochrom: Simple solution, just don't do any work at work
12:08:34 <monochrom> the same way cars run for work, so when we run we run for fun only
12:08:37 <ezzieyguywuf> (and she doesn't even know about the coding..)
12:08:41 <merijn> (don't tell my boss I said that...)
12:09:00 <dminuoso> My girlfriend has started learning Haskell because she's getting bored out of her mind.
12:09:02 <dminuoso> True story.
12:09:09 <merijn> Actually, maybe do...my last performance review said I should do less work at work >.>
12:09:11 <ezzieyguywuf> hah, srsly?
12:09:15 <ezzieyguywuf> cool girlfriend.
12:09:40 <merijn> dminuoso: Mine already finished Haskell Book and nand2tetris part one...and then she had to take a 6 month Java class :p
12:09:48 <dminuoso> Yes. Though I should say that we just got a child and she's still on parental leave. With SARS-CoV-2, there's really not much to do...
12:10:12 <dminuoso> (SARS-CoV-2 is my evil invention to get her to learn Haskell, really. The child too)
12:10:24 <merijn> The upside of COVID is that I'll be on equal footing attending ICFP this year :p
12:11:16 <dminuoso> merijn: That sounds bitter. Is she hating herself already?
12:11:19 <monochrom> not sure which one you mean: invent child to get her to learn haskell, invent SARS-CoV-2 to get child, invent Haskell to get child, ...
12:11:23 <ezzieyguywuf> dminuoso: don't say that too loud the feds might come after you!
12:11:47 <ezzieyguywuf> monochrom: i read it as the first. though perhaps it was intentionally abstract.
12:12:02 <ezzieyguywuf> kind: (* -> *) -> *
12:12:05 <dminuoso> monochrom has no sense of humor, they meant it literally.
12:12:09 <ezzieyguywuf> (was that a good haskell joke!?)
12:12:46 <dminuoso> merijn: Fun thing, my girlfriend having absolutely no programming background had absolutely no trouble accepting or understanding recursive bindings..
12:12:57 <dminuoso> It was a pleasant surprise.
12:13:13 <monochrom> On that digression, there was a sentence from Game of Thrones on TV that got me confused and had to reparse it many ways to finally get it. "Money wins wars, not soldiers".  For like 3 minutes I was wondering "why doesn't money win soldiers?"
12:13:32 <monochrom> "oh, you mean soldiers don't win wars"
12:13:56 <Rembane> monochrom: Did you go rock, paper, scissors in your head?
12:14:08 <dminuoso> Do you think either wins a war, Rembane?
12:14:23 <monochrom> No, I think I did random permutations desperately.
12:14:50 <dminuoso> I did that at the end of season 7, when I was trying to make sense of everything.
12:15:10 <xerox_> all tv shows are the same tv show anyway
12:15:12 <dminuoso> But there were so many words said that the computational complexity of thinking how long that would take was too large to conceive.
12:15:34 <merijn> If I've learned one thing it's that being to lazy to watch beyond season 1 was a good life choice :p
12:15:40 <wavemode_> a programmer's wife said to him "go to the store and buy two loaves of bread. If they have eggs, buy a dozen. He came back home with 14 loaves of bread. when she asked why, he said 'because they had eggs!'"
12:16:05 <merijn> Now I "just" have to wait for the Winds of Winter
12:16:22 <merijn> Any moment now...
12:16:56 <monochrom> I think the Logo inventors also had great success in inflicting recursion on unsuspecting children.
12:18:11 <dminuoso> Logo? As in Siemens Logo?
12:18:16 <koz_> What does it mean if a cabal build says 'The build process terminated with exit code 11'?
12:18:33 <monochrom> However, I also know possible counter-cases. There are also a lot of college juniors, no programming background, having trouble with recursion in their 1st programming course.
12:18:42 <maerwald> koz_: lol
12:18:45 <koz_> I'm trying to see why this particular combination of GHC and platform fails to build on a Github Actions CI.
12:18:50 <maerwald> have a grep at the source code :P
12:18:59 <koz_> maerwald: It builds _everywhere else_.
12:19:02 <monochrom> The Logo programming language. Turtle (cursor) drawing vector graphics.
12:19:08 <koz_> It's _one_ specific GHC, _one_ specific platform. Only.
12:19:14 <merijn> koz_: exit code 11 is usually SEGFAULT
12:19:20 <koz_> Can I feed some flags to Cabal to be a bit more informative?
12:19:23 <dminuoso> merijn: No it's not? That should be 139.
12:19:45 <dminuoso> merijn: The convention is that if it dies by a signal, its 128 + signal no, or do some set the exit code to the signal?
12:19:46 <merijn> koz_: -v3?
12:20:17 <maerwald> monochrom: I did my first recursion with borland pascal and this turtle library drawing this tree. I think visualy really help
12:20:21 <merijn> dminuoso: Oh, actually, I think I wrote a signal handler doing exactly that xD
12:20:32 <maerwald> I don't even remember what tree that is
12:20:42 <koz_> merijn: Thanks, let me try that.
12:21:00 <monochrom> 128+n could be downcasted back to n by bug or by intention.
12:21:00 <dminuoso> koz_: be sure to redirect the data into a file (maybe use tee)
12:21:03 <merijn> koz_: tbh, -v3 is so informative as to become uninformative :p
12:21:05 <maerwald> but if you just throw foldr at them, they're gonna be confused
12:21:13 <koz_> merijn: So what, -v2 then?
12:21:20 <dminuoso> koz_: Does it take long to provoke the bug?
12:21:26 <dminuoso> If yes, use -v3 and tee, otherwise try -v2 first.
12:21:32 <merijn> koz_: That was mostly a joke :p
12:21:35 <merijn> (mostly...)
12:21:45 * hackage lightstep-haskell 0.8.0 - LightStep OpenTracing client library  https://hackage.haskell.org/package/lightstep-haskell-0.8.0 (DmitryIvanov)
12:22:15 <dminuoso> But it can easily be more than what your terminal emulator has for buffer..
12:22:23 <koz_> dminuoso: It's a Github Actions thingo.
12:22:27 <koz_> It's not even my damned machine. :P
12:22:33 <koz_> I'll try -v2.
12:25:01 <monochrom> merijn, koz_: Daoism actually takes that stance. Whereas we draw a line segment to indicate a spectrum, Daoism bend it around and join the two extreme points to form a circle, and state the belief that going to one extreme brings you to the other side.
12:25:39 <monochrom> For better or worse, this works for some things in life.
12:27:07 <maerwald> the problem isn't knowing what works, but what works when :)
12:27:45 <monochrom> Yeah! So as a scientist, I think that since it doesn't have all that much predictive power, it is not a good model.
12:29:51 <monochrom> Anyway, I tell my terminal emulator to buffer 1500 lines.
12:30:26 <monochrom> But don't forget file redirection and even tee :)
12:30:58 <xerox_> I give it 20.000
12:32:47 <koz_> OK, I have the logs at -v2, but I can't understand why it's failing.
12:32:53 <koz_> Would someone have the headspace to have a look?
12:33:39 <koz_> If so: http://ix.io/2nwC
12:34:35 <merijn> oh, I think that's some weird failure case where doctest doesn't work with some version of cabal-install
12:34:46 <koz_> Huh, seriously?
12:34:51 <koz_> What tips you off to that?
12:34:58 <koz_> (in case I ever see it again in the wild)
12:35:02 <merijn> adjunctions is an edwardk package (lots of which use doctests)
12:35:17 <merijn> koz_: cabal *itself* is crashing during the Setup execution
12:35:45 <merijn> And I recall seeing intermittent doctest related failures on ghc 8.8.3 with some specific cabal-install
12:35:55 <koz_> It varies as to which package it reports issues with.
12:36:06 <koz_> Sometimes it's base-compat, sometimes it's StateVar.
12:36:17 <koz_> This is the first -v2 run I've done, and _adjunctions_ never got reported before.
12:36:31 <koz_> The combination is 'latest cabal, GHC 8.8.3, Windows'.
12:36:37 <koz_> Literally every other combination works.
12:36:54 <koz_> (including Windows + another GHC and GHC 8.8.3 + another platform)
12:40:27 <maerwald> merijn: I dropped doctest at some point, because it's just too heavy and problematic imo
12:41:22 <maerwald> There's also https://hackage.haskell.org/package/cabal-doctest
12:41:34 <maerwald> But I'm not sure if that solves anything
12:43:14 <monochrom> does this count as sing-along blog? http://www.vex.net/~trebla/humour/twelve-math.txt
12:43:28 <monochrom> and this: http://www.vex.net/~trebla/humour/twelve-dcs.txt
12:43:30 <merijn> monochrom: Wrong channel ;)
12:43:34 <monochrom> err yeah
12:52:45 * hackage keera-hails-i18n 0.6.0 - Rapid Gtk Application Development - I18N  https://hackage.haskell.org/package/keera-hails-i18n-0.6.0 (keera_studios_ci)
12:53:45 * hackage keera-hails-mvc-model-protectedmodel 0.6.0, keera-hails-mvc-environment-gtk 0.6.0 (keera_studios_ci): https://qbin.io/cite-kg-hvsx
13:12:45 <mastarija> I'm playing with gloss and I'm just using this at the moment: main = display (InWindow "Nice Window" (200, 200) (10, 10)) white (Circle 80)
13:13:00 <mastarija> It's kind of annoying because I get kicked out of the repl every time I close the window
13:13:09 <mastarija> Any idea on how to fix that?
13:13:37 <mastarija> I tried forking this into another thread but when I try to kill the thread window is still active
13:15:15 * hackage keera-hails-mvc-controller 0.6.0 - Haskell on Gtk rails - Gtk-based controller for MVC applications  https://hackage.haskell.org/package/keera-hails-mvc-controller-0.6.0 (keera_studios_ci)
13:16:04 <mlugg> Hi, I'm working on emulating a 6502 processor in Haskell, and am looking into how to structure my program. Because of the amount of data in RAM which will constantly be mutated, I'm guessing my best bet is to use the ST monad alongside a Reader with STRefs to store the current state. Am I correct, or is there a better way? Also, I'm planning to use
13:16:05 <mlugg> co-log (it seems like a really nice logging framework), and at least initially that means IO is in my monad stack. Does this complicate matters, since there is no ST monad transformer? I've seen a library which defines a STT - is there any disadvantage to this? (sorry for like 4 questions in 1 :p)
13:16:15 * hackage keera-hails-reactivevalues 0.6.0, keera-hails-reactive-wx 0.6.0, keera-hails-reactive-network 0.6.0, keera-hails-reactive-cbmvar 0.6.0, keera-hails-mvc-model-lightmodel 0.6.0 (keera_studios_ci)
13:18:27 <merijn> mlugg: Why ST, though? Could just use IORef if you have IO anyway
13:19:05 <mastarija> And depending on how you implement things you can use just a plain State monad.
13:19:10 <merijn> I doubt STRefs in Reader will ever work/typecheck without lots of effort
13:20:00 <mlugg> merijn: Valid point - I suppose the IO dependency isn't going anywhere so I may as well use it
13:21:03 <merijn> mlugg: Don't underestimate the unreasonable effectiveness of "Haskell as typed imperative language", I say ;)
13:21:41 <mlugg> Hah, fair enough - thanks
13:22:41 <mlugg> mastarija, can you clarify? wouldn't the huge memcpy of ram on basically every instruction make things, like, super slow? or are there clever things i'm missing?
13:23:28 <mastarija> mlugg: I wasn't aware this was supposed to be performant :D
13:23:37 <mlugg> ah, yeah :p
13:24:16 <mlugg> i eventually hope to write a NES emulator so it has to be able to hit about 2MHz of CPUness :p
13:24:16 <merijn> Why would State result in copies every instruction?
13:24:19 <Bish> Kemwer_: du hattestt ne 5700 xt?
13:24:25 <Bish> sorry
13:24:48 <mlugg> merijn, I mean, depends how you did it - I assumed they meant an immutable Array or something in the state
13:25:11 <maerwald> That's orthogonal to IORef vs State monad
13:25:21 <merijn> mlugg: This is going to mimic basically a Vector of memory cells?
13:25:59 <merijn> mlugg: If yes, you are aware that the vector package has mutable vectors? :)
13:27:40 <solonarv> mlugg: if you have code that works in ST, you can use stToIO to change it to IO
13:27:45 <solonarv> % :t stTiIO
13:27:45 <yahb> solonarv: ; <interactive>:1:1: error:; * Variable not in scope: stTiIO; * Perhaps you meant `stToIO' (imported from Control.Monad.ST)
13:27:49 <solonarv> % :t stToIO
13:27:49 <yahb> solonarv: ST RealWorld a -> IO a
13:29:22 <ezzieyguywuf> dminuoso: so here's what I ended up with https://gitlab.com/ezzieyguywuf/haskellcad/-/blob/master/src/Topology.hs#L192
13:29:35 <ezzieyguywuf> is this in the vein of what you were trying to illustrate earlier?
13:33:50 <mlugg> merijn, how do those vectors work? isn't the mvector object still just a reference, which won't change, so should be in a reader rather than a state?
13:34:06 <mlugg> solonarv: that may be helpful, ty
13:36:10 <solonarv> and, it is *possible* to write an STT, but it won't really do anything sensible
13:36:11 <ezzieyguywuf> dminuoso: I ask because it seems like I'm setting myself up for a lot of 'boilerplate' if I keep down this path, but maybe I'm just doing something 'wrong'?
13:38:20 <merijn> mlugg: that comment was unrelated to reader vs state, yes :p
13:38:39 <mlugg> oh, sorry, misunderstood your point xD
13:39:06 <merijn> mlugg: But there you just get "writeVector :: Int -> v -> MVector v -> IO ()" and "readVector :: MVector v -> Int -> IO v" (approximately)
13:39:20 <merijn> So you just get in place updates
13:43:06 <mlugg> Right, okay, yeah, so I can use an MVector with IO (or with ST using stToIO in case i can remove the io dep somehow later) and store the refs in a reader. Cool, tyvm :)
13:44:11 <mlugg> there's some other state-ey stuff - registers - which normally I'd put in a state monad, but I'm guessing it makes more sense here to just do them as [IO/ST]Refs so that it's all in the reader env
13:44:23 <mlugg> (plus it's technically a bit faster)
13:45:39 <solonarv> actually vector's mutable-vector functions are already general enough: they don't care about ST vs. IO
13:45:58 <mlugg> yeah, i actually noticed that just reading docs, that's quite neat
13:46:02 <solonarv> (and you get the same vector type anyway)
13:46:09 <mlugg> ye
13:46:34 <solonarv> this is because ST and IO are actually the same thing "under the hood", they're just different at the type level
13:47:16 <mlugg> Ye, IO = ST RealWorld right?
13:47:24 <solonarv> pretty much, yes
13:47:39 <mlugg> whereas ST just uses the forall s as a magical type trick to make sure you don't do bad stuff
13:56:03 <mlugg> okay one more question :p when i look in other people's code i normally see monad stacks defined as a newtype - what's the advantage of doing this over just a type alias?
13:57:06 <ja> type aliases don't provide any hiding, could that be the reason?
14:00:24 <solonarv> indeed
14:03:13 <mlugg> ah, okay, ty
14:04:21 <mlugg> on a similar note, why define typeclasses for your monads? i'm guessing that like mtl's, it's so you can extend the monad without having to do lifts or whatever everywhere
14:25:22 <t7> is there a generic class for      Just 1 `something` Just 2 = Just 1
14:25:36 <t7> like use the first 'success'
14:25:37 <monochrom> I define a type class when I have two or more instances. Then/So I can write a function that works for all instances.
14:26:02 <Rembane> t7: Alternative I believe.
14:27:30 <ja> but wouldn't the bind of monad work?
14:27:48 <wavemode_> > Just 1 <|> Just 2
14:27:50 <lambdabot>  Just 1
14:27:57 <wavemode_> :t (<|>)
14:27:58 <lambdabot> Alternative f => f a -> f a -> f a
14:28:02 <monochrom> Just 1 >>= Just 2  is a type error, if that's what you mean.
14:28:15 * hackage gothic 0.1.5 - A Haskell Vault KVv2 secret engine client  https://hackage.haskell.org/package/gothic-0.1.5 (MichelBoucey)
14:28:17 <xerox_> :t asum
14:28:18 <lambdabot> (Foldable t, Alternative f) => t (f a) -> f a
14:28:23 <xerox_> lovely little thing
14:28:42 <Rembane> > asum [Just 1, Just 2, Nothing]
14:28:44 <lambdabot>  Just 1
14:28:52 <Rembane> Sweet
14:29:21 <t7> Rembane: thanks
14:30:15 <Rembane> t7: np
14:30:45 * hackage keera-hails-reactive-gtk 0.6.0 - Haskell on Gtk rails - Reactive Fields for Gtk widgets  https://hackage.haskell.org/package/keera-hails-reactive-gtk-0.6.0 (keera_studios_ci)
14:31:45 * hackage keera-hails-reactive-yampa 0.6.0 - Haskell on Rails - FRP Yampa Signal Functions as RVs  https://hackage.haskell.org/package/keera-hails-reactive-yampa-0.6.0 (keera_studios_ci)
14:32:19 <ja> monochrom: oh right. the maybe monad makes sense when i need all of the Maybes, but in this case we just need one of them, and they have the same type. totally different operation
14:32:26 <ja> @undo do { a <- Just 1; b <- Just 2; (a,b) }
14:32:27 <lambdabot> Just 1 >>= \ a -> Just 2 >>= \ b -> (a, b)
14:32:40 <koz_> TIL about @undo.
14:32:59 <koz_> ja: That can also be spelled (,) <$> Just 1 <*> Just 2
14:33:06 <monochrom>  @undo is why @info acts unhelpful
14:33:10 <koz_> > (,) <$> Just 1 <*> Just 2
14:33:12 <lambdabot>  Just (1,2)
14:33:19 <monochrom> @info IO
14:33:19 <lambdabot> IO
14:33:27 <xerox_>  @info always makes me sad
14:33:28 <monochrom> This is "unhelpful" because:
14:33:36 <monochrom> @info do { a <- Just 1; b <- Just 2; (a,b) }
14:33:36 <lambdabot> Just 1 >>= \ a -> Just 2 >>= \ b -> (a, b)
14:33:51 <monochrom> so it is helpful.
14:33:58 <monochrom> "helpful"
14:34:46 <monochrom> I have observed that "helpful" is such a subjective, bendable, moving target, that I have decided to refuse to entertain the notion altogether.
14:34:52 <xerox_> inasmuch you want a drink and you're given a steak
14:35:12 <ja> monochrom: how do you give the grocery lady compliments then :P
14:35:15 <monochrom> But entitlement, now that's a useful notion.
14:35:50 <koz_> (or even 'pure (1, 2)', rofl)
14:36:11 <wavemode_> monochrom truly sounds like a tenured professor
14:36:30 <xerox_> wavemode_: are you looking for references
14:36:31 <ja> oh damn, didn't gender-polymorphize 
14:36:44 <koz_> monochrom: Are you a tenured staff member? I know you teach, but that's about it.
14:36:58 <monochrom> Not tenured.
14:37:09 <monochrom> But I was a tenured grad student.
14:37:40 <koz_> monochrom: In that case, I am sorry. :(
14:38:00 <monochrom> was. I successfully finished my PhD finally and got out of it.
14:38:12 <koz_> So you're Dr. Monochrom?
14:38:16 <monochrom> Yes
14:38:23 <koz_> Congratulations!
14:38:27 <monochrom> thanks
14:38:27 <koz_> (however late)
14:38:45 * hackage IPv6Addr 1.1.4 - Library to deal with IPv6 address text representations.  https://hackage.haskell.org/package/IPv6Addr-1.1.4 (MichelBoucey)
14:42:15 * hackage glabrous 2.0.2 - A template DSL library  https://hackage.haskell.org/package/glabrous-2.0.2 (MichelBoucey)
14:50:25 <ezzieyguywuf> is it possible to do something like `type someFunc = (SomeType -> SomeOtherType -> SomeType)`?
14:50:46 <wavemode> yes. why not?
14:50:53 <ezzieyguywuf> I got "Malformed head of type or class declaration"
14:51:01 <monochrom> show actual code
14:51:06 <wavemode> type names must be capitalized, for one
14:51:52 <ezzieyguywuf> `type modTopo = (T.Topology -> T.Topology)`
14:52:01 <ezzieyguywuf> ah, must be capitalized
15:01:27 <NemesisD> anyone know if its possible to write a Conduit that takes a `ConduitM i o m ()` and tracks which `i`s went into producing each `o`, resulting in `ConduitM i ([i], o) m ()`?
15:02:18 <t7> can i rename an imported thing? like    import Foo (foo as bar)
15:04:15 * hackage kdesrc-build-profiles 0.2.0 - Build profiles for kdesrc-build  https://hackage.haskell.org/package/kdesrc-build-profiles-0.2.0 (ivan)
15:09:03 <koz_> Am I reading correctly that TypeRep is like a tree?
15:13:02 <NemesisD> hmm upon reflection i think what i'm asking for isn't reasonable
15:29:15 * hackage keera-hails-reactive-htmldom 0.6.0 - Keera Hails Reactive bindings for HTML DOM via GHCJS  https://hackage.haskell.org/package/keera-hails-reactive-htmldom-0.6.0 (keera_studios_ci)
15:30:53 <solonarv> NemesisD: doesn't seem totally impossible, but it will probably have to have a fairly restrictive type
15:39:48 <gnut96> hello
15:40:50 <gnut96> is accelerate still being maintained?
15:42:17 <koz_> Is there some reason why ByteStrings aren't Storable?
15:48:57 <ja> how would you know their alignment?
15:51:57 <awpr> koz_: would you expect it to write {pointer, size} or something like {size, bytes*} to memory?  there are different answers to "why not?" for each of these
16:06:48 <solonarv> note: if you need a 'Ptr Word8' corresponding to a ByteString there is useAsCString and a handful of variants
16:07:01 <solonarv> for going the other direction there is packCString and, again, a handful of variants
16:07:12 <solonarv> (including unsafeXXX variants that don't do any copying)
16:15:21 <koz_> awpr: Yeah, fair point. I was forgetting about how ByteString is represented.
16:17:09 <awpr> I mean either you try to write it like a (C++ism) `string_view` in which case there are memory safety problems with the Haskell GC being potentially willing to free the ByteString's memory; or you try to unroll the entire thing and then it doesn't fit into the concept of Storable anymore
16:20:11 <typetetris> Ormolu removes the space in front of `@` for type application and my ghc 8.6.5 chokes on that. Any way around that?
16:21:20 <koz_> typetetris: So is Ormolu going from 'foo @Int' to 'foo @ Int' or something?
16:21:37 <typetetris> from `embed @IO` to `embed@IO`
16:21:50 <koz_> Huh, weird. Do you have {-# LANGUAGE TypeApplications #-} in your module?
16:21:57 <koz_> s/module/source file/
16:22:36 <typetetris> koz_: no but -o'-XTypeApplications' on the command line for ormolu an in the cabal file for default extensions
16:23:44 <koz_> Hmmm.
16:24:07 <koz_> I've not seen that behaviour before. Could you gist the whole line for context?
16:24:14 <koz_> I suspect something around it is confusing it.
16:24:44 <typetetris> strangely enough, fixed one occurrence, called ormolu again and it didn't change it now.
16:24:45 <typetetris> strange
16:25:19 <koz_> typetetris: I find Ormolu sometimes gets confused contextually, but I've never seen this form of confusion.
16:25:23 <koz_> What version is this, out of interest?
16:26:42 <typetetris> ormolu 0.0.3.1 UNKNOWN UNKNOWN and using ghc-lib-parser 8.8.2.20200205
16:27:33 <koz_> typetetris: That's a bit old.
16:27:37 <koz_> Try upgrading to 0.1.0.0
16:41:03 <typetetris> koz_ that requires ghc 8.10
16:41:09 <typetetris> don't have that.
16:41:58 <koz_> typetetris: base >= 4.12 isn't GHC 8.10.
16:42:13 <koz_> ghc-lib-parser 8.10 also doesn't need GHC 8.10 as far as I can see.
16:42:17 <koz_> (base >= 4.11)
16:42:37 <typetetris> koz_: sorry assumed ghc-lib-parser 8.10 means ghc 8.10
16:42:54 <koz_> It's a sensible assumption, but the whole point of ghc-lib-parser is to avoid having to match GHC versions I believe.
16:43:03 <typetetris> koz_: Will try tomorrow, good night.
17:02:54 <frdg> https://pastebin.com/U9ES27ps question regarding functions as monads
17:06:55 <koz_> frdg: For the part regarding partially-applied functions, I recommend reading the Typeclassopedia entry.
17:07:23 <koz_> https://wiki.haskell.org/Typeclassopedia#Instances_3
17:07:30 <koz_> You can also read about how they're functors and applicatives.
17:07:50 <koz_> As far as 'writing that without do-notation', I recommend reading the Haskell Wiki on do-notation desugaring.
17:08:14 <koz_> It may give you some insights.
17:08:24 <frdg> koz: ok thanks 
17:08:28 <solonarv> remember that 'Integer -> Integer' is the same as '(->) Integer Integer' which is the same as '((->) Integer) Integer'
17:08:34 <solonarv> now try matching that against 'm a'
17:08:58 <koz_> Namely, what is 'm' and 'a' in this case?
17:09:11 <koz_> Then just paste those into the type sigs for 'fmap', 'pure', etc.
17:09:22 <koz_> This is what 'follow the types' can mean.
17:09:55 <frdg> ok I should be able to do this with following the suggested resources. I've been using do notation all along and Im trying to stop.
17:09:59 <frdg> thanks
17:11:30 <koz_> To note - do-notation isn't necessarily a bad thing. Doesn't hurt to understand how it behaves and what it actually desugars to, though.
17:11:42 <koz_> (especially in cases where you can write it more concisely using, say, applicative operators)
17:14:12 <solonarv> haskell does a pretty decent imperative langugae cosplay and do notation is part of the reason
17:14:22 <koz_> solonarv: Rofl at 'imperative language cosplay'.
17:14:25 <solonarv> it's certainly not bad to use, but you should know how it works
17:14:28 <koz_> 'Notice me, Java-senpai!'.
17:14:38 <solonarv> (fortunately it isn't massively complicated)
17:18:57 <LN001> opa suave
17:19:01 <LN001> alguem br?
17:19:09 <koz_> LN001: This is an English-language channel.
17:19:47 <LN001> someone speak português?
17:20:53 <LN001> Hello guys
17:21:04 <LN001> what's up
17:21:26 <solonarv> hello. do you have questions about haskell?
17:22:19 <LN001> I?
17:22:42 <solonarv> you.
17:22:59 <LN001> no, why?
17:23:16 <solonarv> because this channel is about Haskell (the programming language)
17:23:50 <solonarv> if that is what you are here to talk about, great! if not, please go somewhere more appropriate.
17:24:32 <LN001> '-'
17:25:16 <LN001> i dont want bro
17:25:53 <LN001> i'll dont leave
17:26:36 <LN001> whether you want it or not
17:27:52 <solonarv> well, surely you are not here just to talk about how you won't leave. what are you here to talk about?
17:30:20 <LN001> bro
17:30:41 <LN001> bro
17:30:46 <LN001> bro
17:30:47 <LN001> bro
17:30:48 <LN001> bro
17:31:11 <LN001> no have someone here '-'
17:33:05 <kamek> is there a http client that doesn't rely on exceptions ?
17:33:56 <koz_> kamek: Exceptions-the-library or exceptions-the-concept?
17:34:40 <LN001> someone here?
17:34:40 <kamek> the concept, sorry, I'd rather use something that returns Eithers instead of throwing
17:34:55 <kamek> I don't mind the extra plumbing
17:35:02 <LN001> fuck you?
17:35:42 <koz_> @where ops
17:35:42 <lambdabot> byorgey Cale conal copumpkin dcoutts dibblego dolio edwardk geekosaur glguy jmcarthur johnw mniip monochrom quicksilver shachaf shapr ski
17:35:58 <koz_> kamek: Given that most web servers are quite async, you can't really avoid exceptions completely.
17:36:20 <koz_> What if someone Ctrl-C's the server process while you've got 3 separate async things servicing requests?
17:36:35 <solonarv> this seems like a non sequitur to me
17:36:46 --- mode: ChanServ set +o shapr
17:36:47 <LN001> fuck bro
17:36:52 --- kick: LN001 was kicked by shapr (Kicked by shapr)
17:36:58 <koz_> Thank you shapr!
17:37:06 <shapr> right on
17:37:17 <solonarv> surely the server process getting interrupted doesn't mean you must throw an exception rather than returning (Left ConnectionTimedOut) or something
17:37:22 <MarcelineVQ> bro
17:38:09 <solonarv> shapr <3
17:38:20 <shapr> hopefully a kick is enough
17:38:26 <shapr> otherwise I'll have to remember how to ban
17:39:18 <kamek> oops
17:40:07 <kamek> that's what I was thinking as well, throwing or returning Left seems like a design choice to me
17:40:36 <shapr> I learned a new trick at work today, https://hoogle.haskell.org/?hoogle=shouldMatchList
17:40:44 <koz_> solonarv: Do you really want all the non-main threads to just die in mid-swing?
17:41:02 <koz_> Mark Karpov wrote a good take on why async needs exceptions.
17:41:39 <solonarv> remember that we were asking about clients, and there was no mention of async
17:41:53 <koz_> Oh ffs... I should learn to read.
17:41:56 <solonarv> s/asking/talking/
17:41:58 <koz_> My apologies, please ignore me.
17:43:10 * shapr hugs koz_
17:45:49 <koz_> shapr: Awww, thanks.
17:46:34 <shapr> It's good to be helpful :-)
17:47:03 <superguest> Just briefly, how does dynamic programming work in a pure-functional language (like Haskell) work?
17:47:17 <koz_> superguest: Do you mean 'dynamic programming' the algorithmic design techique?
17:47:19 <koz_> Or something else?
17:48:08 <superguest> koz_ yes, the technique. Informally, DP = recursion + memoization
17:48:23 <koz_> superguest: I'm aware. I'm not sure what issue you're seeing here.
17:48:30 <ski> superguest : it depends, but one often nice technique can be to define an (immutable) lazy array recursively
17:49:38 <ski> (that gives a top-down, demand-driven, DP. only the elements of the arrays that are needed will be computed. alternatively, instead of demanding the result, you could begin by scanning the elements in turn, forcing them)
17:50:13 <ski> the technique also works with other data structures than arrays. even e.g. infinite streams (as long as you don't force it all)
17:52:45 <superguest> what do you mean by "forcing them"?
17:53:14 <superguest> ^ ski
17:53:38 <ski> demanding their computation
17:55:25 <ski> > let fibs n = arr ! n where arr = listArray (0,n) [case k of 0 -> 0; 1 -> 1; _ -> arr ! (k-1) + arr ! (k-2) | k <- [0 .. 12]] in fibs 12
17:55:28 <lambdabot>  144
17:55:35 <ski> that's a very simple example
17:55:50 <ski> note how the array `arr' is defined recursively
17:56:00 <superguest> ski, yes, a very good example though.
17:56:12 <superguest> it gets the point across.
17:56:24 <ski> you can add some abstractions, yo make it look prettier, if you want to
17:57:23 <ski> @let tabulate :: Ix i => (i,i) -> (i -> e) -> Array i e; tabulate ix f = listArray ix [f i | i <- range ix]
17:57:24 <lambdabot>  Defined.
17:57:55 <ski> > tabulate (0,7) $ \i -> i^2  -- handy function for generating arrays from indices
17:57:57 <lambdabot>  error:
17:57:57 <lambdabot>      Ambiguous occurrence ‘tabulate’
17:57:57 <lambdabot>      It could refer to
17:58:00 <ski> bah
17:58:09 <ski> > L.tabulate (0,7) $ \i -> i^2
17:58:11 <lambdabot>  array (0,7) [(0,0),(1,1),(2,4),(3,9),(4,16),(5,25),(6,36),(7,49)]
17:59:14 <ski> @let memoArray :: Ix i => (i,i) -> (i -> e) -> (i -> e); memoArray ix f = (L.tabulate ix f !)
17:59:15 <lambdabot>  Defined.
18:00:49 <ski> > let fib n = fib_n n where (memoArray (0,n) -> fib_n) = \case 0 -> 0; 1 -> 1; n -> fib_n (n-1) + fib_n (n-2) in fib 12
18:00:52 <lambdabot>  144
18:00:58 <superguest> what is the ! operator again?
18:01:02 <ski> array indexing
18:01:07 <ski> @type (!)
18:01:08 <lambdabot> Ix i => Array i e -> i -> e
18:01:20 <ski> (immutable arrays)
18:02:00 <ski> that example hides the array internally, it's used as a cache, "intercepting" the recursive calls of `fib_n'
18:02:16 <ski> you need to decide on the size of the array first, though
18:03:19 <freeman42x[m]1> can cabal-install do the same thing as stack here: https://github.com/commercialhaskell/stack/blob/master/doc/GUIDE.md#script-interpreter ? basically run a Haskell script file
18:03:28 <ski> one can use the same technique to do inexact matching of a "pattern" string against some text, where we want to minimize the number of transpositions, deletions, and insertions we have to make to the pattern string, to match a contiguous subsequence of the text string
18:04:01 <ski> in that case, one defines a two-dimensional array, one dimension for the positions in the pattern, one for the positions in the text
18:04:18 <ski> superguest : hth
18:05:07 <ski> if you want/need to, you can also do DP with mutable arrays (perhaps using `ST', so that you can present an interface that doesn't betray that you're doing mutable stuff, internally)
18:05:26 <sclv> freeman42x[m]1: grep “script” https://www.haskell.org/cabal/users-guide/nix-local-build.html
18:06:34 <ski> anyway, forcing `arr ! 12' will force `arr ! 11' and `arr ! 10'. the first of those will in turn force `arr ! 10' and `arr ! 9'. but since the results are cached (if our Haskell implementation uses lazy / by-need evaluation, which GHC does), `arr ! 10' will only be computed once
18:06:43 <ski> so, in this case, the whole array will be forced
18:07:22 <ski> but you can easily imagine more irregular cases, where that won't happen, and where it may be hard to predict in advance how much will need to be forced (that string matching i mentioned is an example of that)
18:08:02 <ski> but if you want to, you can start at the "lower end" of the array, and just force every element
18:08:26 <solonarv> freeman42x[m]1: yes, see cabal docs linked above
18:08:49 <solonarv> it won't install GHC (because that isn't something cabal does) and is a bit slower to start up
18:10:23 <superguest> "but since the results are cached (if our Haskell implementation uses lazy / by-need evaluation, which GHC does), `arr ! 10' will only be computed once" <- this clarification was needed.  B/c your fib implementation doesn't hint at the cache-nature
18:11:34 <ski> yea, superguest. that's the whole point of it, getting that caching, for each element :)
18:17:03 <superguest> ski, you went off topic a bit to talk about inexact matching earlier, let's talk about that; because I want to see if I understand the problem, and applicability of the technique we just talked about.  Are we trying to do inexact matching through transformations of _a_ pattern string.  The transformations are computed and stored in a 2-d array?
18:17:45 <superguest> I guess the transformations are recursive defined
18:18:45 * hackage warp 3.3.12 - A fast, light-weight web server for WAI applications.  https://hackage.haskell.org/package/warp-3.3.12 (KazuYamamoto)
18:19:45 * hackage wai-http2-extra 0.1.3, warp-tls 3.2.12 (KazuYamamoto): https://qbin.io/pre-condo-xsgy
18:28:11 <superguest> @type (L)
18:28:12 <lambdabot> error: Data constructor not in scope: L
18:29:34 <ski> oh
18:29:53 <superguest> > L.tabulate(3,7)
18:29:54 <ski> that's just the name of the module in which things you define with `@let', for lambdabot, gets defined
18:29:55 <lambdabot>  error:
18:29:55 <lambdabot>      • No instance for (Typeable e0)
18:29:55 <lambdabot>          arising from a use of ‘show_M687027374344959070521064’
18:30:00 <ski> @type L.tabulate
18:30:01 <lambdabot> Ix i => (i, i) -> (i -> e) -> Array i e
18:30:21 <superguest> > L.tabulate (3,7)
18:30:23 <lambdabot>  error:
18:30:23 <lambdabot>      • No instance for (Typeable e0)
18:30:23 <lambdabot>          arising from a use of ‘show_M527747827437390425521104’
18:31:00 <superguest> > L.tabulate (3,7) $ \i -> i^3
18:31:02 <lambdabot>  array (3,7) [(3,27),(4,64),(5,125),(6,216),(7,343)]
18:32:38 <dsal> > L.tabulate (3,7) (^3)
18:32:40 <lambdabot>  array (3,7) [(3,27),(4,64),(5,125),(6,216),(7,343)]
18:33:27 <dsal> Does `L` mean "L'array" ?
18:49:33 <ski> dsal : no
18:51:43 <liiae> why we don't have  Writer in Control.Monad?
18:57:59 <monochrom> Why do you ask?
18:58:45 <Axman6> because it's somewhere else
18:58:58 <liiae> WriterT?
18:59:07 <Axman6> @hoogle WriterT
18:59:07 <lambdabot> Control.Monad.Trans.Writer.CPS data WriterT w m a
18:59:07 <lambdabot> Control.Monad.Trans.Writer.Lazy newtype WriterT w m a
18:59:07 <lambdabot> Control.Monad.Trans.Writer.Lazy WriterT :: m (a, w) -> WriterT w m a
18:59:14 <liiae> like no Cont, but there's ContT?
18:59:16 <Axman6> there's a couple
18:59:52 <monochrom> Writer exists. Cont exists.
19:00:09 <liiae> @hoogle Writer
19:00:10 <lambdabot> module Control.Monad.Trans.Writer
19:00:10 <lambdabot> Control.Monad.Trans.Writer.CPS type Writer w = WriterT w Identity
19:00:10 <lambdabot> Control.Monad.Trans.Writer.Lazy type Writer w = WriterT w Identity
19:00:41 <liiae> @hoogle Maybe
19:00:41 <lambdabot> Prelude data Maybe a
19:00:42 <lambdabot> module Data.Maybe
19:00:42 <lambdabot> Data.Maybe data Maybe a
19:03:25 <liiae> mtl and transformers package, different?
19:03:46 <monochrom> yes
19:04:18 <monochrom> (They have different names. mtl.  transformers.  You just can't infer that they are different packages?)
19:04:35 <ezzieyguywuf> how do I run a specific hspec test in ghci?
19:04:40 <liiae> but mtl is not short for monad transformer library?
19:04:57 <monochrom> Yes and irrelevant.
19:04:57 <liiae> and transformers doesn't point monad transformer?
19:05:08 <ezzieyguywuf> I know I gat `import test/MyStuffSpec.hs` then `hspec MyStuffSpec.spec`, but i want to run a specific test from in there
19:05:25 <liiae> and what the CPS here mean in Control.Monad.Trans.Writer.CPS?
19:05:37 <liiae> Continuation Passing-Style?
19:05:46 <monochrom> Are you a liberal arts major?
19:05:57 <liiae> what the CPS has to do with type?
19:06:22 <monochrom> Because only a liberal arts major would use the "logic" "these two names roughly allude to the same idea, therefore they are the same".
19:06:22 <liiae> no
19:36:28 <liiae> what's the meaning of w and a in newtype WriterT w m a?
19:36:33 <liiae> short for?
19:36:46 <liiae> m mean monad, what's w and a?
19:41:03 <ski> `w' probably comes from "writer". `a' is just the first letter in the alphabet
19:41:09 <ski> @type (.)
19:41:10 <lambdabot> (b -> c) -> (a -> b) -> a -> c
19:41:18 <ski> that uses the first three available letters
19:41:41 <wavemode_> a is the value of the computation, just like IO a or Maybe a. w is the monoid we are writing to
19:42:37 <monochrom> Ah I get it now. w means monoid, they wanted to use m, but m already take, so turn it upside down for w.
19:43:03 <monochrom> s/take/taken/
19:48:48 <ski> mm, that could also have been a factor
19:49:20 <ski> (for `Comonad w', i'm pretty sure the `w' is supposed to be an upside-down `m', basically, anyway)
19:51:30 <liiae> it's a little weird, I saw that artiles tell people how to use Writer, but in the lib, it's WriterT
19:51:41 <liiae> newtype WriterT w m a = WriterT { runWriterT :: m (a, w) }; type Writer w = WriterT w Identity
19:52:03 <liiae> where's  data Writer w a = Writer { runWriter :: (a, w) }？
19:52:14 <monochrom> replaced
19:52:39 <wavemode_> yes - the Writer they write about in book and articles is just a theoretical one. In reality, Writer is usually an alias for WriterT over Identity
19:53:10 <liiae> wavemode_: that's really weird, we learn from theoretical one ,and using another one
19:53:26 <monochrom> It used to be not theoretical.
19:53:52 <monochrom> Libraries evolve. Blogs bit-rot.
19:54:01 <liiae> why people don't put that data Writer w a = Writer { runWriter :: (a, w) } into Control.Monad.Writer
19:54:04 <monochrom> The problem with "learning from blogs".
19:54:23 <awpr> because `type Writer w = WriterT w Identity` is already there
19:54:37 <liiae> monochrom: that learn yourself a haskll for good, it's a book, 
19:55:14 <liiae> awpr: how I can get a value x :: Writer String Int?
19:55:25 <awpr> `pure 0` is one
19:55:33 <monochrom> It gets old and out-dated too.
19:55:52 <liiae> WriterT Identity (3,"3")?
19:56:10 <liiae> why not just Writer (3,"3")?
19:56:28 <dmwit> :t writer
19:56:29 <lambdabot> MonadWriter w m => (a, w) -> m a
19:56:30 <liiae> awpr: pure, return, 
19:56:38 <dmwit> writer (3, "3") -- works fine
19:56:44 <liiae> awpr: this need declare type
19:57:09 <dmwit> As for "why not include Writer": the true answer is "because that's a lot of code duplication for very little benefit".
19:58:50 <dmwit> `pure` and `return` almost never need to have their type explicitly declared. `writer`, too.
19:59:16 <liiae> dmwit: writer (3, "3") get error Non type-variable argument in the constraint: MonadWriter Char m
20:00:17 <liiae> return 0 could be Maybe Int or [Int] or others
20:00:38 <awpr> the one from `Control.Monad.Trans.Writer.Lazy` is probably easier to explore with initially
20:00:50 <awpr> you've got the one from `Control.Monad.Writer.Class`, looks like
20:01:00 <monochrom> You can use an old version of GHC, the one that's period to LYAH. Then you won't have all these incompatibilities.
20:01:22 <liiae> Control.Monad.Writer is from transformers pacakge, it points Control.Monad.Trans.Writer.Lazy
20:02:31 <awpr> yeah, `Control.Monad.Writer.Class` is a different module from `Control.Monad.Writer`
20:02:35 <liiae> type Writer w = WriterT w Identity, this Identity need be imported from Data.Functor.Identity
20:02:49 <dmwit> liiae: You may use the `writer` from transformers instead.
20:02:52 <awpr> it does if you want to name it in your own code, yes
20:02:58 <dmwit> But I don't really know what you want.
20:03:10 <dmwit> I don't really understand your complaint, TBH.
20:03:24 <liiae> dmwit: I want to use Writer simply...
20:03:52 <dsal> @hoogle Writer
20:03:52 <lambdabot> module Control.Monad.Trans.Writer
20:03:52 <lambdabot> Control.Monad.Trans.Writer.CPS type Writer w = WriterT w Identity
20:03:52 <lambdabot> Control.Monad.Trans.Writer.Lazy type Writer w = WriterT w Identity
20:03:52 <awpr> also, single quotes and double quotes are not interchangeable
20:03:57 <dsal> Then simply use Writer?
20:03:58 <monochrom> The complaint is to be bit-to-bit compatible with LYAH.
20:04:01 <dmwit> > runWriter (writer (3, "3"))
20:04:03 <lambdabot>  (3,"3")
20:04:08 <dmwit> liiae: looks pretty simple to me
20:04:42 <awpr> if your error message mentions `MonadWriter Char m`, you've probably used single quotes
20:05:04 <monochrom> Makes me miss the days when a book came with a floppy diskette containing the relevant software so you were guaranteed consistency.
20:05:28 <dsal> I'd like to get a floppy disk with ghc on it.
20:05:51 <monochrom> I think ghc is too big, you have to settle for hugs.
20:06:02 <monochrom> It has simpler error messages anyway.
20:06:04 <liiae> ok
20:06:14 * dsal always settles for hugs
20:06:50 <monochrom> God, Computerphile just has a Hutton's tail recursion video posted today.
20:07:22 <liiae> :t writer (3, "3")
20:07:23 <lambdabot> (MonadWriter [Char] m, Num a) => m a
20:07:27 <monochrom> I have a feeling that next few days we'll get tail recursion shit storm.
20:07:53 <dsal> TBH, I don't quite understand tail recursion wrt haskell.
20:09:03 <liiae> writer (3, "3") :: Writer String Int, right?
20:09:49 <liiae> also WriterT String Identity Int?
20:10:40 <awpr> :t writer (3, "3") :: Writer String Int 
20:10:41 <lambdabot> Writer String Int
20:10:48 <awpr> ^ that'll let you test such hypotheses
20:12:10 <liiae> ok
20:14:34 <dmwit> Yes, `writer (3, "3")` has both of those types. In fact, both of those types are just different ways of spelling the same type.
20:15:23 <dsal> I've never used a Writer monad.  Now I feel like I should try to wedge one into a problem.
20:15:31 <dsal> Well, "used"
20:16:01 <liiae> > runWriter (writer (3, "3"))
20:16:03 <lambdabot>  (3,"3")
20:16:10 <liiae> > runWriter (writer ("3", 3))
20:16:12 <lambdabot>  error:
20:16:12 <lambdabot>      • Ambiguous type variable ‘w0’ arising from a use of ‘show_M526474288769...
20:16:12 <lambdabot>        prevents the constraint ‘(Show w0)’ from being solved.
20:16:53 <liiae> why?
20:17:24 <monochrom> dsal: I synthesized the problem of "a semantic model for an EDSL that has an output command" :)
20:17:31 <monochrom> and put it on the exam
20:18:44 <dsal> Makes sense.
20:19:19 <superguest> for which course?
20:19:22 <dsal> I wrote an mqtt broker recently and finally moved all of my brokers off of mosquitto (C-based server from eclipse) into my own.  It's pretty great.
20:19:28 <awpr> liiae:  the monoid type in that second example is not uniquely identified by saying `3`; it can be anything with a `Num` instance and a `Monoid` instance, and the compiler isn't willing to guess what type it should be
20:19:30 <monochrom> a "principles of programming languages" course
20:19:53 <superguest> monochrom, oh yes, I remember that course :-)
20:20:48 <liiae> awpr: but writer (3:: Int, "3") still the same error
20:22:20 <liiae> but writer (3, "3") :: Writer String Int is ok
20:22:56 <dsal> [] is a monoid
20:23:11 <dsal> Int is not a monoid.
20:23:37 <awpr> I'm guessing you meant `writer ("3", 3 :: Int)`, and that has a different error, not the same error
20:24:07 <liiae> Writer w a, w need be a monoid?
20:25:09 <dsal> > runWriter(writer("3", 3 :: Sum Int))
20:25:10 <lambdabot>  ("3",Sum {getSum = 3})
20:26:30 <liiae> awpr: right, I mixed up them
20:27:29 <dsal> :t runWriter . writer . (3,) 
20:27:31 <lambdabot> (Monoid w, Num a) => w -> (a, w)
20:27:47 <liiae> dsal: what Sum Int is?
20:28:01 <liiae> it makes 3 as a monoid?
20:28:02 <dsal> Sum is from Data.Monoid.
20:28:09 <awpr> :t runWriter . Control.Monad.Trans.Writer.Lazy.writer . (3,)
20:28:10 <lambdabot> Num a => w -> (a, w)
20:28:28 <awpr> ^ that version doesn't required the Monoid constraint if you're not using its Applicative instance
20:28:29 <dsal> :t 3
20:28:30 <lambdabot> Num p => p
20:28:39 <dsal> :t Sum
20:28:41 <lambdabot> a -> Sum a
20:28:45 <awpr> it's only the `mtl` machinery that makes it required in degenerate uses
20:28:45 <dsal> well that's helpful.
20:29:45 <liiae> awpr: I'm confused, in that newtype WriterT w m a = WriterT { runWriterT :: m (a, w) }, does w has monoid constraint?
20:29:56 <awpr> `Sum` takes any numeric type and gives it the monoid where `mempty = 0` and `(<>) = (+)`
20:30:17 <awpr> liiae: generally, constraints don't go in the types but in the function signatures
20:30:27 <awpr> in this case it's coming from `writer` in a fairly roundabout way
20:30:48 <awpr> :i WriterT
20:30:51 <liiae> awpr: writer = WriterT . return
20:31:10 <awpr> that's a different definition of `writer` than the one you're using
20:31:23 <awpr> oh, no it isn't
20:31:39 <liiae> newtype WriterT w m a = WriterT { runWriterT :: m (a, w) }
20:31:47 <awpr> `return` is requiring `Monad`, and the `Monad` instance has `Monoid` in its context
20:32:27 <awpr> never mind, my brain isn't currently working
20:32:36 <liiae> those from transformer, Control-Monad-Trans-Writer-Lazy.
20:33:14 <dsal> I'm not very familiar with this Writer, but I can read the error messages and have a rough idea of what the thing is supposed to do.  :)
20:34:06 <awpr> with the one from `transformers`, there shouldn't be a `Monoid` constraint involved if you're just using `writer` and `runWriter`
20:34:35 <dsal> What does it give you?
20:35:12 <liiae> 0 is a monoid in (+)?
20:35:21 <liiae> 0 is a unit in (+)
20:35:31 <dsal> What?
20:35:33 <dsal> :t 0
20:35:34 <lambdabot> Num p => p
20:35:41 <dsal> 0 can be just about anything.
20:35:49 <dsal> But I don't understand your question.
20:35:57 <awpr> the second one is fairly right: 0 and (+) form a monoid (lower-case monoid) over integers
20:35:58 <liiae> what is a monoid now?
20:36:28 <awpr> `Sum` is a type that has a `Monoid` (upper-case) instance implementing that 0 and (+) behavior
20:36:40 <dsal> A monoid is any type that has a binary operator (think: "combine") and an empty value.
20:36:40 <liiae> > runWriter ( writer ("3", (+0)))
20:36:43 <lambdabot>  error:
20:36:43 <lambdabot>      • No instance for (Typeable a0)
20:36:43 <lambdabot>          arising from a use of ‘show_M899134767796535179724397’
20:37:03 <dsal> :t (+0)
20:37:04 <lambdabot> Num a => a -> a
20:37:26 <dsal> That could be a monoid if the 0 were a Sum type, but it's getting pretty confusing.
20:38:13 <awpr> I don't actually know why it wants Typeable there
20:38:14 <dsal> > runWriter ( writer ("3", (+0)))  (11 :: Sum Int)
20:38:16 <lambdabot>  error:
20:38:16 <lambdabot>      • Couldn't match expected type ‘Sum Int -> t’
20:38:16 <lambdabot>                    with actual type ‘([Char], a0 -> a0)’
20:39:02 <monochrom> (+0) = \x -> x+0
20:39:12 <monochrom> from there it goes downhill
20:39:15 * hackage pandoc-crossref 0.3.6.3 - Pandoc filter for cross-references  https://hackage.haskell.org/package/pandoc-crossref-0.3.6.3 (lierdakil)
20:39:55 <dsal> > ($ (11 :: Sum Int)) . snd $ runWriter (writer ("3", (+0))) -- that's just getting weird.
20:39:57 <lambdabot>  Sum {getSum = 11}
20:41:05 <dsal> > getSum . ($ 11) . snd $ runWriter (writer ("3", (+0))) -- if I'm going to go that far...
20:41:07 <lambdabot>  11
20:41:25 <dsal> I wonder if there's a goal somewhere in here.
20:47:37 <liiae> what type is monoid not monad?
20:47:47 <dsal> monoid and monad aren't related.
20:48:10 <liiae> yes, and which one is a monoid, but not monad?
20:48:31 <dsal> There are countless of each.  I'm not sure what you're asking.
20:48:50 <awpr> strictly speaking no type is both a Monoid and a Monad because they have different kinds
20:49:06 <liiae> monad has kind *->*
20:49:10 <liiae> and monoid has?
20:49:14 <awpr> *
20:49:50 <liiae> Maybe is a monad, and Maybe a is a monoid?
20:50:02 <dsal> Maybe a where a is a monoid is a monoid.
20:50:12 <liiae> what about semigroup? semigroup has kind *?
20:50:19 <dsal> a monoid is a semigroup
20:50:27 <awpr> well, in a hand-waving sort of way: `Monad :: (* -> *) -> Constraint` and `Monoid :: * -> Constraint`, so _things that are Monads_ have kind `* -> *`
20:50:33 <dsal> a monoid is a semigroup with an empty value.
20:51:17 <liiae> dsal: "<dsal> Maybe a where a is a monoid is a monoid." I don't understand this
20:51:36 <dsal> `Maybe a` is a `Monoid` where `a` is a `Monoid`
20:51:41 <awpr> `Maybe a` has a `Monoid` instance only if `a` has a `Monoid` instance
20:52:06 <dsal> > Just "hi" <> mempty
20:52:08 <lambdabot>  Just "hi"
20:52:08 <liiae> wait, Maybe Int is not a monoid?
20:52:16 <dsal> > Just (1::Int) <> mempty
20:52:18 <lambdabot>  error:
20:52:18 <lambdabot>      • No instance for (Semigroup Int) arising from a use of ‘<>’
20:52:18 <lambdabot>      • In the expression: Just (1 :: Int) <> mempty
20:52:58 <liiae> Maybe a is a monoid when a is a monoid, and Maybe is a monad, right?
20:53:02 <awpr> liiae:  this changed recently-ish, it's possible that LYAH talks about `Maybe` having a `Monoid` instance for all types?
20:53:24 <awpr> yes, `Maybe a` is (sometimes) a monoid and `Maybe` is a monad
20:53:25 <liiae> awpr: I forget that...
20:53:49 <awpr> and `Maybe` is a different type from `Maybe a`
20:56:57 <liiae> [] is a monad, [Int] is not a monoid, [Char] is a monoid
20:57:41 <dsal> No, that's a little confusing.
20:57:41 <awpr> for all `a`, `[a]` is a monoid, so in particular `[Int]` is a monoid
20:58:34 <liiae> this [] is a monad?
20:58:56 <liiae> :k []
20:58:57 <lambdabot> * -> *
20:59:01 <Cale> liiae: Specifically, the *type* constructor for lists is a monad, yes
20:59:02 * dsal wonders if this is the little haskeller
20:59:56 <Cale> Recall that in general, return :: (Monad m) => a -> m a, so in this case, we have return :: a -> [a], and this is implemented by return v = [v]
21:00:20 <Cale> and in general, (>>=) :: (Monad m) => m a -> (a -> m b) -> m b
21:00:31 <Cale> in this case, (>>=) :: [a] -> (a -> [b]) -> [b]
21:00:48 <Cale> and the implementation... well what do you suppose it might do?
21:01:14 <Cale> We have a list of values of type a, and a function which, given a single value of type a, will give us a list of values of type b
21:01:20 <Cale> We want a list of values of type b
21:01:53 <dsal> This is one of those things where >>= is pretty clear and do is weird voodoo magic.
21:02:13 <Cale> Well, do-notation should become pretty clear too :)
21:02:17 <awpr> voo-do notation
21:02:29 <Cale> Once you understand what it's supposed to mean, anyway
21:02:57 <dsal> > let omg = "omg" in do {o <- omg; m <- omg; g <- omg; pure (o,m,g) }
21:02:59 <lambdabot>  [('o','o','o'),('o','o','m'),('o','o','g'),('o','m','o'),('o','m','m'),('o',...
21:03:10 <Cale> liiae: Still here? (It's okay if you're taking time to think about it)
21:03:42 <liiae> Cale: yeah, I'm here, but thoes words I'm confused
21:04:25 <Cale> liiae: Okay...
21:04:35 <Cale> What's the first bit that's confusing?
21:05:37 <liiae> Maybe String is a monid where String is a monoid and Maybe is a monad
21:05:48 <liiae> Maybe Int is not a monid
21:05:56 <Cale> Ah, the fact that Maybe is a monad there is only slightly relevant
21:06:01 <liiae> return :: Int -> Maybe Int
21:06:08 <Cale> The instance of Monoid for Maybe doesn't depend on that
21:06:29 <Cale> It's just:
21:07:00 <Cale> instance Monoid a => Monoid (Maybe a) where
21:07:15 <Cale>   mempty = Nothing
21:07:24 <Cale>   Nothing <> x = x
21:07:34 <Cale>   x <> Nothing = x
21:07:44 <Cale>   Just u <> Just v = Just (u <> v)
21:08:12 <liiae> but [3] <> [2] =?
21:08:18 <liiae> [3,2]
21:08:19 <Cale> That's a whole other instance
21:08:26 <liiae> 3 <> 2
21:08:33 <Cale> The instance for lists and for Maybe are quite different
21:08:40 <liiae> oh, I see
21:08:56 <liiae> <> is different behavior between different types
21:09:08 <Cale> yep
21:09:15 <Cale> All these things defined using type classes are like that
21:09:35 <Cale> (that's the point of type classes, to have different implementations of a thing depending on the type)
21:09:52 <liiae> Cale: actually my origianl question is newtype WriterT w m a = WriterT { runWriterT :: m (a, w) }, is this w need to be a monoid?
21:10:05 <liiae> and here we are :)
21:10:07 <Cale> If you want the Monad instance for WriterT, then yes
21:10:20 <Cale> because of how return and (>>=) are implemented:
21:10:44 <Cale> return v = WriterT (return (v, mempty))
21:10:51 <liiae> Cale: this w could be not a monoid instance? like what?
21:11:05 <Cale> hm?
21:11:20 <liiae> writer ("3", 3) is not ok
21:11:31 <liiae> here w :: Int
21:11:31 <Cale> Well, we need w to be a monoid instance in order to implement return and (>>=)
21:11:41 <Cale> See how I used mempty there?
21:11:59 <liiae> oh
21:12:12 <Cale> When we implement return v, the m (a,w) we produce is the one which is just return (v, mempty)
21:12:29 <Cale> and then we wrap that up in the WriterT data constructor
21:12:37 <Cale> and then (>>=) looks like this:
21:12:49 <Cale> x >>= f = WriterT $ do
21:13:03 <Cale>   (v,m1) <- runWriterT x
21:13:14 <Cale>   (w,m2) <- runWriterT (f v)
21:13:23 <Cale>   return (w, m1 <> m2)
21:14:04 <liiae> ok
21:14:04 <Cale> Where runWriterT is the function  WriterT w m a -> m (a,w)  which pretty much just unwraps the WriterT data constructor
21:14:56 <juliusdeane> are there any good ways to accomplish left-recursion in megaparsec?
21:15:08 <Cale> So one way of thinking about that is that we're first running x, collecting up whatever we "logged" while running x (which is m1), along with its result v, and then we're running (f v), and getting some additional "logs" m2
21:15:13 <juliusdeane> I've seen `chainl1` be used with parsec but I wasn't able to find that fn in the megaparsec docs
21:15:59 <Cale> and then the result of our computation is the result of that, and we combine the logs
21:17:17 <liiae> Cale: the logs is w, and result is a, in Writer w a
21:17:28 <Cale> juliusdeane: huh, weird that's not in Control.Monad.Combinators from the parser-combinators package
21:17:36 <Cale> liiae: yeah
21:19:09 <liiae> w is a monoid instance, so it can be concatenated
21:19:49 <Cale> yep
21:52:54 <superguest> let fib n = fib_n n where (memoArray (0,n) -> fib_n) = \case 0 -> 0; 1 -> 1; n -> fib_n (n-1) + fib_n (n-2) in fib 12
21:52:57 <superguest> > let fib n = fib_n n where (memoArray (0,n) -> fib_n) = \case 0 -> 0; 1 -> 1; n -> fib_n (n-1) + fib_n (n-2) in fib 12
21:53:00 <lambdabot>  144
21:53:37 <superguest> But when I tried that same expression in ghci, it says: "Illegal lambda-case (use LambdaCase)"
21:53:42 <superguest> any idea?
21:53:46 <Cale> :set -XLambdaCase
21:53:48 <dmwit> :set -XLambdaCase to turn it on
21:54:05 <dmwit> Or you can start ghci with ghci -XLambdaCase.
21:54:49 <Cale> Or you can write your definitions into a file and put {-# LANGUAGE LambdaCase #-} at the top of it
21:54:50 <dmwit> What an odd spelling, though.
21:55:06 <dmwit> I mean, I get it. But weird.
21:55:54 <superguest> Is LambdaCase non-standard?
21:56:10 <dmwit> yes
21:57:29 <dmwit> > let fib n = fib_n n where fib_n = memoArray (0,n) $ \case 0 -> 0; 1 -> 1; n -> fib_n (n-1) + fib_n (n-1) in fib 12
21:57:31 <lambdabot>  2048
21:57:42 <dmwit> :t memoArray
21:57:43 <lambdabot> Ix i => (i, i) -> (i -> e) -> i -> e
21:57:57 <dmwit> > let fib n = fib_n n where fib_n = memoArray (0,n) $ \case 0 -> 0; 1 -> 1; n -> fib_n (n-1) + fib_n (n-2) in fib 12
21:57:59 <Cale> For some value of non-standard anyway. The meaning of the standard has been diluted somewhat by a lack of separate maintained implementations.
21:57:59 <lambdabot>  144
21:58:47 <dmwit> This way, without the odd view pattern, seems more straightforward to me.
21:58:55 <Cale> Yeah, I agree there.
22:00:53 <dmwit> hm
22:01:59 <dmwit> I wonder if this memoArray is even doing the right thing, though?
22:02:06 <dmwit> That type looks to me like it can't possibly work right.
22:02:42 <dmwit> I dunno. Maybe not. Never mind.
22:09:08 <superguest> dmwit, yes, your version of `fib` is much easier to read (and understand)
22:19:35 <liiae> why there's no f :: Writer w a -> a?
22:19:46 <liiae> in Control.Monad.Writer
22:20:12 <liiae> try State?
22:22:41 <MarcelineVQ> that's runWriter, use  fst  if you want just the  a
22:24:15 * hackage prometheus-client 1.0.0.1 - Haskell client library for http://prometheus.io.  https://hackage.haskell.org/package/prometheus-client-1.0.0.1 (fimad)
22:28:17 <liiae> right, runWrite (Writer w a) :: (a, w)
22:34:18 <liiae> what's the proper way to get current time in haskell?
22:34:43 <liiae> Data.Time?
22:39:07 <liiae> why l <- getCurrentTime can work in ghci without do notation?
22:39:15 <liiae> but s <- Just 3 can't
22:43:19 <xerox_> it tells you why
22:44:30 <dsal> > do { x <- Just 3; pure x }
22:44:32 <lambdabot>  Just 3
22:45:02 <liiae> > l <- getCurrentTime
22:45:04 <lambdabot>  <no location info>: error: not an expression: ‘l <- getCurrentTime’
22:45:11 <dsal> % getCurrentTime
22:45:11 <yahb> dsal: ; <interactive>:46:1: error:; * Variable not in scope: getCurrentTime; * Perhaps you meant `getCurrentCCS#' (imported from GHC.Prim)
22:45:37 <liiae> halfWriter :: Writer String Int -> Writer String Int
22:45:57 <liiae> halfWriter x = do v2 <- (liftIO getCurrentTime); v <- x; tell ((show v2) <> ","); return (v `div` 2)
22:47:00 <dsal> I don't see MonadIO in there.
22:47:12 <xerox_> by what dark magic do you want to hide an IO into a pure thing there
22:48:02 <liiae> getCurrentTime :: IO UTCTime, I thought that liftIO can lift it into Writer context, no?
22:48:31 <liiae> I want that UTCTime, so I can log the time when the halfWriter run
22:48:31 <xerox_> it can lift it into a monad that has a MonadIO instance
22:48:57 <xerox_> "Writer String Int" is very suspiciously missing any IO mention (or MonadIO mention)
22:49:00 <liiae> you mean Writer or WriterT is not an instance of MonadIO?
22:49:25 <xerox_> yeah but those are very different, Writer doesn't have a MonadIO instance, some WriterT's can have one
22:50:04 <liiae> but  type Writer w = WriterT w Identity
22:50:33 <xerox_> yup, and that second type parameter is where the monad who has a MonadIO instance would go, except it's already taken by Identity that doesn't have it
22:50:44 <liiae> I see
22:53:42 <liiae> halfWriter :: WriterT String IO Int -> WriterT String IO Int
22:54:02 <liiae> halfWriter x = do v2 <- (liftIO getCurrentTime); v <- x; tell ((show v2) <> ","); return (v `div` 2)
22:59:13 <liiae> main = do l <- runWriterT $ halfWriter (writer (16, ""):: WriterT String IO Int); print l
23:02:52 <dminuoso> 08:01:04        liiae | [05:38:45] why l <- getCurrentTime can work in ghci without do notation?
23:02:56 <dminuoso> Because GHCi is magic
23:03:21 <liiae> dminuoso: ghci is whole IO?
23:03:26 <dminuoso> Sort of, yes. 
23:03:44 <liiae> ok
23:03:50 <dminuoso> Also, you don't type haskell into it, it's rather a really strange mix of "you can write bindings *and* pretend you're in the middle of main"
23:04:16 <dminuoso> But you can't just copy and paste a haskell module into it.
23:04:40 <dminuoso> Well you can actually, but you need to enable multi lines..
23:04:57 <liiae> a bunch of extensions?
23:05:12 <dminuoso> Well Haskell was never designed to be run interactively.
23:05:32 <dminuoso> So GHCi is sort of a hack in order to give you an interactive haskell shell, despite the language not being designed for it.
23:06:06 <liiae> ghci is very useful to get some value's type with :t
23:06:08 <dminuoso> So GHCi supports lots of invocations that are otherwise invalid Haskell.
23:06:36 <liiae> :i is not very useful to me, I prefer hoogle
23:06:52 <dminuoso> :i can actually be very useful because it shows you context hoogle does not have.
23:07:02 <dminuoso> instances that are currently in scope for instance
23:07:10 <liiae> but :i doesn't how you the type definition
23:07:25 <dminuoso> That's not it's purpose
23:07:44 <dminuoso> And it can show you somethings type if its a binding
23:07:46 <liiae> is there aother paramter for that?
23:07:48 <dminuoso> % :i getLine
23:07:49 <yahb> dminuoso: getLine :: IO String -- Defined in `System.IO'
23:08:01 <dminuoso> % :i Int
23:08:01 <yahb> dminuoso: type Int :: *; data Int = I# Int#; -- Defined in `GHC.Types'; instance Eq Int -- Defined in `GHC.Classes'; instance Ord Int -- Defined in `GHC.Classes'; instance Enum Int -- Defined in `GHC.Enum'; instance Num Int -- Defined in `GHC.Num'; instance Real Int -- Defined in `GHC.Real'; instance Show Int -- Defined in `GHC.Show'; instance [safe] PrintfArg Int -- Defined in `Text.Printf'; instance Bits Int -- 
23:08:31 <liiae> % :i WriterT w m a
23:08:31 <yahb> liiae: ; <interactive>:1:1: error: Not in scope: `w'
23:09:12 <dminuoso> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html#ghci-cmd-:info
23:09:33 <dminuoso> Admittedly, I don't use GHCi really directly for development.
23:09:52 <dminuoso> For figuring out a particular expressions type in some code I'm writing, I use the `a :: _` trick.
23:10:02 <dminuoso> (Which, together with ghcid gives me an instant response)
23:10:53 <liiae> this is good
23:11:01 <liiae> :info!
23:16:38 <liiae> that liftIO is magic to me
23:16:57 <liiae> liftIO lift IO into other monad context
23:21:23 <dminuoso> liiae: The idea is quite simple. There are other things that can execute IO things.
23:21:48 <liiae> liftIO is related to lift?
23:21:56 <dminuoso> Yes.
23:22:27 <liiae> like f :: Int -> Int; f x = x;  f is related to id?
23:22:28 <dminuoso> Consider first the trivial case of `ReaderT Env IO`, is it obvious how this is just `Env -> IO` in disguise?
23:22:59 <dminuoso> Not quite
23:23:13 <liiae> what lift do?
23:23:27 <dminuoso> Well you can use lift instead of liftIO, but you might have to use lift multiple times.
23:23:29 <liiae> liftIO lift IO into other monad context, what lift?
23:23:50 <dminuoso> Also, liftIO is more than just about transformers.
23:24:17 <dminuoso> The rough idea is this. There is a typeclass that captures all monads that can, for some reason, do IO.
23:24:24 <dminuoso> That typeclass is called MonadIO
23:24:24 <liiae> liftM liftA liftF exist?
23:24:31 <dminuoso> Ignore those for a second
23:25:31 <dminuoso> So any monad that can execute IO stuff can/should have an instance MonadIO, and implement just its single method liftIO that tells how to "lift" an IO into that custom monad (essentially just type fitting)
23:26:01 <dminuoso> Or rather, an IO action to be exact.
23:26:19 <liiae> Writer w is a monad, but Writer w isn't an instance of MonadIO
23:26:33 <dminuoso> Because Writer has no access to IO.
23:26:39 <liiae> WriterT w m is a monad also an instance of MonadIO
23:26:45 <dminuoso> Not quite.
23:26:52 <dminuoso> Look closely at what the instance says
23:27:05 <dminuoso> The distinction is important
23:27:11 <dminuoso>  (Monoid w, MonadIO m) => MonadIO (WriterT w m)
23:27:28 <dminuoso> Under the assumption that `m` is MonadIO (and w is Monoid), then `WriterT w m` is also MonadIO
23:28:25 <liiae> instance (Monoid w, MonadIO m) => MonadIO (WriterT w m) where
23:28:39 <liiae>  liftIO = lift . liftIO
23:28:40 <dminuoso> If you think of a Monad transformer as "adding effects to another monad", then this just means "if m can do IO, then adding the writer effect to m will still allow you to do IO"
23:30:37 <liiae> I'm confused, m must be MonadIO at first, so WriterT w m could be monadIO?
23:30:42 <dminuoso> Yes.
23:31:00 <liiae> IO is an instance of MonadIO
23:31:36 <dminuoso> liiae: Well *and* w must be Monoid of course, but let's take that for granted, the Writer wouldn't be very useful if we didn't assume that.
23:32:55 <dminuoso> So, do you have a MonadIO instance for `WriterT [Int] IO`?
23:33:04 <liiae> dminuoso: except that other monad transformers like WriterT what ever, IO is the only instance of MonadiO?
23:33:19 <dminuoso> Well no...
23:33:25 <dminuoso> 08:28:04        liiae | instance (Monoid w, MonadIO m) => MonadIO (WriterT w m) where
23:33:32 <dminuoso> You just mentioned another instance yourself.
23:33:50 <liiae> WriterT w m is MonadIO when m is MonadIO
23:34:03 <liiae> except IO, m could be?
23:34:12 <dminuoso> It could be `ReaderT Env IO`
23:34:14 <liiae> except thtat MonadTrans
23:34:24 <dminuoso> Ah. Well any newtype you might have that has IO access.
23:34:25 <liiae> ReaderT is MonadTrans?
23:35:09 <Welkin> #TRANSRIGHTS ?
23:35:42 <liiae> #BiRIGHTS
23:35:43 <dminuoso> Say you create some `newtype IOE = IOE { runIOE :: Env -> IO }` - now you could argue "but this is just effectively ReaderT", but it's not. Maybe you have a more complicated type that happens to be a monad and include an IO.
23:35:58 <dminuoso> `newtype IOE a = IOE { runIOE :: Env -> IO a }`
23:36:00 <dminuoso> Sorry.
23:36:34 <liiae> ok
23:36:52 <liiae> and I have to make it as an instance of MonadIO
23:37:12 <dminuoso> Or maybe it's someone elses monad and you dont even know how its constructed. You are presented some newtype wrapper that you cant inspect, but the library author has granted you access to its IO via MonadIO
23:37:16 <dminuoso> Yes.
23:37:50 <dminuoso> Perhaps that author has just newtyped some transformer stack, but we dont know that. MonadIO is the typeclass of all monads that can do IO. :)
23:38:36 <liiae> those MonadIO, Monad, IO, MonadTrans make me confused about their meaning
23:38:37 <dminuoso> And liftIO lets you just take an arbitrary IO action and lift it into the monad, because when you have `f :: IOE (); f = do ...` you can't directly use `getLine :: IO String` in that, it wouldn't type chec
23:38:42 <Welkin> DecepticonIO
23:38:53 <liiae> MonadIO is the type who can access IO?
23:39:29 <liiae> what about MonadTrans, MonadTrans is for multiple effects to combine monad?
23:39:38 <liiae> to an giant one or new one
23:40:56 <Welkin> those typeclasses are just typeclass versions of an explicit transformer stack
23:40:57 <dminuoso> MonadTrans is a bit more interesting. It basically gives you a single function called `lift`, so that when you have a transformer T applied to some other monad M, then you can take an arbitrary value of `M a` for some choice of a, and turn it into `T M a`
23:41:11 <Welkin> monad transformers are clumsy 
23:41:19 <Welkin> and annoying
23:41:24 <dminuoso> So for instance, if you have a value of type `IO a`, then you can turn it into `WriterT [Int] IO a` by means of just lift.
23:41:30 <Welkin> but the alternative solutions are not better, and some are worse
23:41:48 <liiae> Welkin: what is DeceptionIO? ExceptionIO?
23:42:24 <Welkin> Megatron RealWorld
23:50:45 <liiae> why coding in haskell need to learn those concepts...
23:51:13 <liiae> I find out learning those concepts take much time than coding
23:52:04 <Cale> which concepts?
23:52:06 <liiae> it's amazing that I didn't know that before, and my code could run
23:52:56 <liiae> Cale: semigroup, monoid, monad, monadIO, monadTrans, 
23:53:03 <Cale> Honestly, you can get a lot done in Haskell without needing to understand very much.
23:53:51 <liiae> yeah, I still have no idea about Cat Theory
23:54:28 <liiae> and I still can write haskell code, amazing
23:54:51 <Cale> Abstractions like that are eventually good to know, but mostly just knowing what classes the things you're trying to use support is good enough. Like, you probably want to know that IO is an instance of Monad so that when you see type signatures with Monad in them, you can tell that IO will fit.
23:55:11 <Cale> But you don't actually need to understand the whole abstraction all at once.
23:55:32 <Cale> The best way to understand what a monad is, is to just learn lots of examples of monads over time
23:55:41 <Cale> and eventually the thing which they all have in common will be obvious
23:56:07 <liiae> I learn the most useful stuff about IO, is that IO is not a constructor
23:56:21 <liiae> it takes me a lot of time to admit it
23:56:44 <liiae> I always to use Maybe to image that IO
