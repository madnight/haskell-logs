00:07:44 * hackage net-spider 0.4.3.2 - A graph database middleware to maintain a time-varying graph.  https://hackage.haskell.org/package/net-spider-0.4.3.2 (debugito)
00:08:45 * hackage net-spider-rpl 0.4.1.2 - NetSpider data model and utility for RPL networks  https://hackage.haskell.org/package/net-spider-rpl-0.4.1.2 (debugito)
00:10:15 * hackage net-spider-cli 0.2.0.2 - CLI option parsers for NetSpider objects  https://hackage.haskell.org/package/net-spider-cli-0.2.0.2 (debugito)
00:12:52 <jluttine[m]> Do you have any examples of a type constructor that is a functor but not an applicative/monad?
00:13:49 <jluttine[m]> Similarly, are there type constructors that are Foldable but not Functor?
00:14:28 <dsal> What do you mean?  Type constructors aren't any of these things.
00:14:46 <dsal> Do you just mean type?
00:16:59 <dsal> Data.Set is Foldable, but not a Functor.
00:17:35 <dsal> Map is a Functor, but not Applicative.
00:21:45 * hackage staversion 0.2.3.6 - What version is the package X in stackage lts-Y.ZZ?  https://hackage.haskell.org/package/staversion-0.2.3.6 (debugito)
00:21:58 <dsal> Also, applicative and monad are separate.  There are applicatives that aren't monads, but I'm tired, so you just have to believe me.
00:39:28 <jluttine[m]> dsal: thanks for the examples! and yeah, i'm not too familiar with the terms so indeed i often misuse them.. thanks for clearing that up! and yes, i know applicatives are monads, should've dropped mentioning monad in that sentence. actually, that's also interesting: types that are applicative but not monads.
00:40:43 <jluttine[m]> without digging into it, it feels counter-intuitive that Data.Set isn't a Functor. have to see the details to understand why that is
00:42:35 <wavemode__> :t fmap
00:42:36 <lambdabot> Functor f => (a -> b) -> f a -> f b
00:42:56 <wavemode__> but Data.Set cannot possibly satisfy that type signature
00:43:22 <wavemode__> because the elements must be Ord. they can't be any arbitrary b
00:44:41 <wavemode__> the function Data.Set.map is more restricted: `map :: Ord b => (a -> b) -> Set a -> Set b `
00:45:05 <Philonous> jluttine[m], It's the other way around. Every Monad is also an Applicative, but there are Applicatives that aren't Monads 
00:45:51 <jluttine[m]> Philonous: ah, yes indeed, i typoed! thanks
00:48:15 <[exa]> jluttine[m]: a slighly imprecise but useful intuition for recognizing functors: `fmap` should always preserve the "shape" of the wrapper, which gives a contradiction for Set if you would, for example, `fmap (const 0)`
00:56:20 <Philonous> Now I wonder if you Set could be an (endo-)functor in a different category where every object is a total order and all the morphisms are strictly monotonic functions 
00:57:09 <Philonous> Eh, except I don't know how to give a total order on Sets
00:59:19 <Philonous> Seems like containers implements it as the lexicographic order of the ordered list of the elements. THat should work
01:00:27 <ski> i was thinking of considering them as bit-vectors, and lexicographically comparing those
01:02:30 <Philonous> That wouldn't work for Types with infinite cardinality, unless you mean something different than I'm thinking
01:02:34 <Philonous> types*
01:03:14 <ski>   s < t  iff  exists y. not (y in s) /\ y in t /\ forall x. x < y => (x in s <=> x in t)
01:03:17 <ski> something like that
01:04:04 <Philonous> Right, but that's what you get when you compare the list of sorted elements, too. 
01:04:12 <ski> hm, perhaps it is
01:04:19 <ski> (i was wondering that)
01:08:38 <ski>   s =< t  iff  forall y. (forall x. x < y => (x in s <=> x in t)) => (y in s => y in t)
01:45:45 * hackage hasql 1.4.3 - An efficient PostgreSQL driver with a flexible mapping API  https://hackage.haskell.org/package/hasql-1.4.3 (NikitaVolkov)
01:45:46 <kuribas> In this HM-type inference code, the unifier has to go over all the substitution every time: http://dev.stephendiehl.com/fun/006_hindley_milner.html
01:46:21 <kuribas> Wouldn't it be more efficient to keep a reverse map (which variables are contained in which substituion), then only do necessary substitutions?
01:46:45 * hackage imm 1.9.0.0 - Execute arbitrary callbacks for each element of RSS/Atom feeds  https://hackage.haskell.org/package/imm-1.9.0.0 (koral)
01:47:11 <kuribas> How does ghc does this?
01:49:32 <[exa]> kuribas: does the performance improvement balance out the necessary beancounting?
01:49:56 <[exa]> (generally, most type expressions are pretty short)
01:50:02 <kuribas> [exa]: no idea...
01:50:08 <kuribas> [exa]: worth timing it though.
01:50:26 <kuribas> [exa]: on the other hand, even if it is the same for small expressions, it will have better complexity
01:51:10 <kuribas> it will not blow up
01:54:27 <[exa]> kuribas: anyway, in ghc the vars have integer keys for fast comparison
01:55:09 <kuribas> so it doesn't have to go over the whole substitution?
01:55:43 <phadej> kuribas: GHC uses mutable references
01:55:50 <kuribas> yucj
01:55:53 <kuribas> yuck
01:57:04 <phadej> kuribas: It's really practical choice, even "unelegant". See e.g. https://www.type-driven.org.uk/edwinb/why-is-idris-2-so-much-faster-than-idris-1.html (section unification)
01:57:14 <phadej> the performance gain is just too big
01:57:25 <phadej> to not use mutable refs
01:58:25 <phadej> [exa]: generically (see what I did here) type expressions are of enormous size
01:58:42 <phadej> e.g. :kind! Rep YourFavouriteBigRecord
02:00:38 <kuribas> phadej: wouldn't the pure equivalent be to use a pure map, and to calculate the substitutions dynamically?
02:01:00 <kuribas> phadej: that would be only a log factor slower
02:01:40 <phadej> kuribas: see http://www.cs.uu.nl/research/techreps/repo/CS-2008/2008-027.pdf
02:02:04 <kuribas> phadej: thanks!
02:13:56 <kuribas> phadej: yes, functional shared memory seems to be what I had in mind
02:21:20 <phadej> kuribas: and FWIW, when https://hackage.haskell.org/package/unification-fd fits, it's awesome
02:21:42 <phadej> i.e. unification is one the things which you shouldn't implement yourself
02:21:47 <phadej> (if you can help it)
02:22:19 <kuribas> is it efficient?
02:26:09 <ambiso> Is there a separate channel for cabal new build?
02:37:53 <kuribas> phadej: it looks pretty clear in: http://dev.stephendiehl.com/fun/006_hindley_milner.html
02:38:09 <kuribas> phadej: I wonder if using to many generic libraries will complicate the code...
02:46:46 <timCF> Hi guys! Why do we have `type` in Haskell if `newtype` seems like much better alternative for similar capabilities? With `newtype` it's much less chance to mess around values accidentally, and you can have different implementation of type classes if you want.. But if want to inherit parent implementation - you can have it for free with
02:46:46 <timCF> `GeneralizedNewtypeDeriving`.. If you want to cast to original type, you can have `coerce` which is completely for free.. Maybe I don't understand something, but I can't find any reason why to use `type` instead of `newtype`
02:48:07 <timCF> Or any cases where `type` can do something better than `newtype`
02:48:36 <kuribas> timCF: type is for when you don't want to make a new type
02:48:49 <kuribas> timCF: but still less typing, or a more descriptive name.
02:49:22 <kuribas> it's a convenience mostly
02:50:10 <kuribas> For example if you have a big composite type, and you want to simplify the signatures.
02:50:20 <kuribas> But you don't want to make new type for it.
02:51:01 <kuribas> I sometimes use Type when I don't care for a new type right now, but might in the future.
02:51:08 <kuribas> It will make refactoring later easy.
02:54:39 <timCF> So it's just personal preference I guess? For me - to write couple of derive and coerce is not an issue at all, the most work is just to come up with good name, which have to be done in both newtype and type cases anyway)
02:56:56 <phadej> kuribas: unification is an example algorithm where types don't really help you much
02:57:04 <phadej> it's easy to make mistakes, so you need to test it quite a lot
02:57:22 <phadej> the unification-fd abstractness also makes you think about the problem better
02:57:29 <phadej> even it needs some boilerplate to be used
02:57:38 <phadej> (ala recursion-schemes)
02:57:58 <kuribas> phadej: does it use the implementation from the paper?
02:58:26 <phadej> most importantly: if you can decouple unification algo from the data it unifies (like unification-fd) it's a win, as concerns are separated.
02:58:59 <kuribas> phadej: would using unbound-generics help?
02:59:25 <phadej> that's different concern, how to represent binders
02:59:29 <phadej> but yes, use a library
02:59:34 <phadej> bound, unbound, unbound-generics
02:59:49 <phadej> don't use `type Name = String`
03:00:03 <phadej> it's like most expensive mistake you'll make
03:01:29 <kuribas> Name + Int?
03:01:38 <kuribas> erm Name = String + Int
03:01:49 <kuribas> like in unbound
03:16:00 <kuribas> phadej: I'd like to use an smt solver (sbv) to check constraint when unifying.
03:18:16 <phadej> use a library, leave the name cpaturing etc. worries to it
03:19:35 <kuribas> ah, it uses a recursion-scheme like representation?
03:22:07 <phadej> sbv? I don't know
03:22:14 <timCF> Btw, is there any recommendations which type (Text, ByteString or Lazy equivalents) to use for custom variant of `Show` class which I want to use in my application for logging of data? Don't want to use default String `Show` because of some reasons
03:22:23 <kuribas> no unification-fb
03:22:32 <phadej> unification-fd, yes.
03:22:37 <phadej> functional dependencies
03:22:41 <phadej> if you wonder
03:23:33 <phadej> timCF: `Doc` from `prettyprinter`
03:24:17 <kuribas> no, the solver is for adding refinement constraints like  (< index array-size)
03:24:51 <timCF> thanks phadej
03:26:23 <kuribas> so I'd need to find a way to combine sbv with unification-fb
03:26:58 <kuribas> so equals, unify, etc... may need to perform smt proofs
03:27:08 <kuribas> or return counter-example for the error message
03:30:54 <phadej> Unifiable from Control.Unification allows that.
03:31:35 <phadej> zipMatch (Constrainted c x) (Constraint c' x') = if unSat (c /\ c') then Nothing else ...
03:31:54 <phadej> you'll get something like "cannot unify (a == 1) and (a == 2)"
03:32:14 <phadej> you won't get the best possible errors, but you'll get stuff working today :)
03:32:31 <kuribas> good errors are important...
03:32:37 <kuribas> though not necessarily today
03:33:02 <phadej> except that sbv wants to be run in IO, which complicated the nice story of unification-fd
03:33:13 <phadej> yet, you can unify and check constraints afterwards
03:33:37 <phadej> sat won't simplify them anyway.
03:35:09 <phadej> (I haven't used sbv optimize, can it be used to simplify formulae?)
03:35:10 <kuribas> right
03:35:54 <kuribas> so basically unify as if all refinements match, then do a separate check afterwards?
03:37:00 <phadej> I'd do that so. Refinement don't guide the unification, you'll only be able to short cut earlier if you interleave unification and constraint checking.
03:38:48 <phadej> if refinements will tell you that n == m at the end (because say you had n <=m and m <= n constraints), then you can simplify your types from "(n <= m, n <=m) -> {x | ... n} -> { x | ... m }" to "{x | ... n} -> {x | ... n}"
03:39:07 <phadej> how much that matters for you, depends
03:39:24 <phadej> (n <= m, m <= n)  ==>  n == m
03:39:51 <kuribas> I'll require explicit anotations
03:40:05 <kuribas> this only matters for error messages
03:41:36 <timCF> I wonder, are Template Haskell, GHC.Generics, and SYB kinda competing standards which are doing similar things, but just in different scope? TH looks the most powerful tool there, can be used to generate arbitrary AST. But for simpler tasks like class deriving - which you would prefer?
03:43:06 <kuribas> timCF: Generics is pure haskell, it doesn't have the drawbacks of TH
03:43:27 <kuribas> timCF: however it's less powerfull, and depends on GHC optimizations to generate efficient code.
03:43:49 <kuribas> SYB I didn't use, I believe it's Generics predecessor
03:45:24 <timCF> I used TH a lot, to do very useful things like generating classes from API spec documents, and I like it. But I just heard that cool guys are using Generics today.
03:46:44 <kuribas> Generics just blends better with the language
03:47:20 <kuribas> TH complicates the compiling procedures
03:47:28 <kuribas> makes cross compiling impossible
03:48:22 <timCF> So probably it worth to take a look to Generics, at least for typical tasks like class instance deriving?
03:48:41 <kuribas> I think so
03:48:50 <timCF> thanks kuribas
03:55:51 <kuribas> np
04:28:14 * hackage mmsyn7l 0.6.0.0 - Modifies the amplitudes of the Ukrainian sounds representations created by mmsyn7ukr package.  https://hackage.haskell.org/package/mmsyn7l-0.6.0.0 (OleksandrZhabenko)
04:36:21 <phadej> fwiw, between GHC.Generics, SYB and TH the GHC.Generics is the only one where you can be sure that the thing is "right" when it type-checks. It doesn't mean that it's easy to use though.
04:44:58 <phadej> (I think all three are difficult to use, but differently difficult)
04:55:44 <kuribas> phadej: zipMatch returns Nothing when two terms are equal.  Then doesn't that mean I lose my information about the refinements?
04:56:25 <kuribas> phadej: ah, no it returns a new term.
04:56:39 <kuribas> phadej: but where do I put the refinements?
04:56:54 <phadej> in a new term :)
04:58:59 <kuribas> ah, you mean collect them separately?
05:00:15 <kuribas> but zipMatch is pure
05:00:25 <phadej> I guess you have some type constructor which is Constrained Constraints Type
05:01:30 <phadej> then when you zipMatch (Constrained c t) (Constrained c' t') = Just (Constrained (conjunction c c') (Left (t, t'))
05:02:00 <kuribas> Ah right!
05:02:02 <kuribas> thanks!
06:02:15 * hackage pocket 0.3.0 - Bindings for the Pocket API  https://hackage.haskell.org/package/pocket-0.3.0 (jpvillaisaza)
06:16:45 * hackage mmsyn7l 0.6.1.0 - Modifies the amplitudes of the Ukrainian sounds representations created by mmsyn7ukr package.  https://hackage.haskell.org/package/mmsyn7l-0.6.1.0 (OleksandrZhabenko)
06:22:41 <tt> Hi, when I stack build it does not seem to run the Language Extension of OverloadedStringsWhere do I specify this option so the compiler knows how to build thisUsually when I do fixes with `stack ghci` I just set it in the `.ghci` file.  `:set -XOverloadedStrings`
06:24:22 <lyxia> put it in the file(s) you're compiling
06:25:52 <lyxia> tt: {-# LANGUAGE OverloadedStrings #-} at the top of the file. https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#language-pragma
06:27:08 <tt> lyxia omg. I just did my module export at top of file and put the language pragma below. God thanks for the thelp. I was stuck on this for too long
06:27:45 * hackage req 3.2.0 - Easy-to-use, type-safe, expandable, high-level HTTP client library  https://hackage.haskell.org/package/req-3.2.0 (mrkkrp)
06:40:32 <merijn> So...uh...trying to core dump a mix of Haskell code and sqlite does, uh, not go well
06:44:52 <merijn> I realised this around the time my OS started prompting me about running out of RAM and running out of hard disk space continuously >.>
06:45:55 <L29Ah> is linux stupid enough to dump mapped but never used pages?
06:46:09 <merijn> L29Ah: This was macOS
06:46:12 <merijn> It's actually worse
06:46:28 <merijn> I suspect it was trying to dump reserved pages that weren't even mapped
06:46:47 <merijn> Because the core file on my disk was about 1TB by the time I decided to hard reboot my machine
06:47:19 <merijn> Which is suspiciously similar to the 1 TB virtual reservation GHC makes
07:12:28 <kuribas> LSP on emacs is such crap
07:12:31 <kuribas> I often need to restart emacs when it's stuck
07:15:28 <ddellacosta> so, acknowledging that extensions muck this up, is there any documentation around the characteristics of Haskell's type system wrt soundness and decidability? I'd like to learn more about this aspect of the type system but having trouble finding anything but SO posts
07:16:41 <merijn> ddellacosta: The GHC wiki maybe has some references?
07:17:57 <ddellacosta> merijn: yeah I found this but it didn't seem like what I wanted, but will poke around some more https://gitlab.haskell.org/ghc/ghc/-/wikis/commentary/compiler/type-checker
07:18:18 <ddellacosta> (or, I'm too dense to learn much from that page at this point lol)
07:18:30 <merijn> There's also this OutsideIn or whatever it's called paper on GHC's inference?
07:18:47 <ddellacosta> oh that sounds promising
07:19:40 <ddellacosta> hmm if this is what you're talking about looks like it's dead :-( https://www.reddit.com/r/haskell/comments/4isua9/ghc_development_outsidein/
07:21:18 <fog> Hi, I have 2 datatypes i want to compare to existing streaming/machine based encodings of unfoldable containers
07:21:20 <ddellacosta> ah nevermind, found this https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/jfp-outsidein.pdf?from=http%3A%2F%2Fresearch.microsoft.com%2F%7Esimonpj%2Fpapers%2Fconstraints%2Fjfp-outsidein.pdf
07:21:33 <fog> here is the more simple version, a tape; https://gist.github.com/fog-hs/66e5139aa18884cb8393be028995fa6b
07:21:55 <fog> its just a uncons state over a "get" instance (something foldable)
07:22:33 <fog> and then, when the stored list is supposed to return a different element dependent on an input, this is a scanner;
07:22:34 <fog> https://gist.github.com/fog-hs/6590849a6491fc03c1704fe313617c1e
07:23:00 <fog> i think i have something like an applicative instance, combining a scanner and a tape
07:23:12 <fog> which im going to write today
07:23:33 <fog> but i wanted to check about eg, "pipes" or "conduit" approaches which seem similar
07:23:48 <fog> are they all just reexpressions of this encoding? is it the church encoding?
07:24:35 <fog> going offline, but will check the logs for replies 
07:24:41 <merijn> ddellacosta: I'm sure someone in #ghc might have some pointers too
07:29:39 <merijn> so
07:29:52 <merijn> Anyone wanna make any bets on whether linux handles core dumps any better? ;)
07:32:15 * hackage xls 0.1.3 - Parse Microsoft Excel xls files (BIFF/Excel 97-2004)  https://hackage.haskell.org/package/xls-0.1.3 (harendra)
07:41:39 <ddellacosta> merijn: thanks!
07:42:34 <merijn> Spoiler: Linux handles it better
08:03:58 <safinaskar> how to create monads in post-applicative-monad-proposal world?
08:04:16 <safinaskar> i don't need backward compatibility. i just to write clean modern code
08:04:25 <Cheery> huh?
08:04:43 <Cheery> you got a monad when the mathematics check up
08:04:59 <Cheery> you got it even if you didn't know.
08:05:40 <Cheery> though, what do you think makes a monad?
08:05:44 <safinaskar> so, how to write monads? https://wiki.haskell.org/Functor-Applicative-Monad_Proposal gives an example, but this example tries to be compatible with both "old" and "new" compilers. i just need "new"
08:06:13 <safinaskar> Cheery: also, i already know what is monad. i am just asking what is current preferred practice
08:08:08 <Cheery> class Applicative m => Monad m
08:08:17 <Cheery> class Functor f => Applicative f
08:08:24 <Cheery> class Functor f
08:08:31 <Cheery> you implement those
08:09:00 <safinaskar> give me link to some guide, please
08:09:29 <Cheery> there are the docs where it reads: https://hackage.haskell.org/package/base-4.14.0.0/docs/Control-Monad.html
08:09:49 <Cheery> though wait a moment.. I check that there's all the stuff.
08:10:45 <Cheery> well I'm not sure about how applicative should be constructed.
08:12:21 <Cheery> but functors, they're structure preserving maps. eg. you can compose functions or then apply functor to them both and compose the results, and things should remain same.
08:14:17 <Cheery> and the way they behave is important, because that it fits doesn't alone make it work.
08:19:31 <kuribas> phadej: I don't get subst: https://hackage.haskell.org/package/unbound-generics-0.4.1/docs/Unbound-Generics-LocallyNameless-Subst.html
08:19:42 <kuribas> phadej: how can a ~ b?
08:20:18 <kuribas> phadej: in SubstName.  Then Var ~ Factor which is false?
08:20:29 <kuribas> so the example is wrong?
08:20:36 <kuribas> Or I am missing something?
08:24:54 <tt> why is it I cant find `cabal` or `ghc` after this install using `ghcup` https://www.haskell.org/ghcup/
08:24:55 <kuribas> The a ~ b constraint doesn't make any sense to me
08:25:02 <safinaskar> Cheery: i still don't got what i want. i want guide similar to https://wiki.haskell.org/Functor-Applicative-Monad_Proposal , but without intention to be compatible with both "new" and "old" compilers, i just need "new" ones
08:25:41 <tt> I already source the file ~/.bashrc file with this line `[ -f "${GHCUP_INSTALL_BASE_PREFIX:=$HOME}/.ghcup/env" ] && source "${GHCUP_I    NSTALL_BASE_PREFIX:=$HOME}/.ghcup/env"`
08:27:02 <maerwald> tt: check ~/.ghcup/bin
08:27:05 <maerwald> is there something inside?
08:27:38 <merijn> safinaskar: I'm not sure what you're asking
08:27:49 <merijn> safinaskar: You just define an instance for all three classes and you're done
08:27:50 <Cheery> that future proofing seems like what you need to implement today
08:28:05 <Cheery> and it's all right, that's done because monads have those properties.
08:28:27 <tt> maerwald yup. Bunch of ghcs, cabal, ghcis.. 
08:28:54 <maerwald> tt: source ~/.ghcup/env # does work?
08:29:44 <merijn> safinaskar: Nothing has changed about how you define those clases, only the definition of the classes has changed (which requires you make sure that the relevant superclasses are defined too)
08:30:34 <tt> maerwald ooo that works. It looks like my `~/.bashrc` not working then
08:32:14 <merijn> tt: Which OS?
08:32:42 <kuribas> phadej: did he mean (Name a) ~ b?
08:33:06 <merijn> I suspect your bashrc is working fine and you're being bit by arcane shell knowledge lost to the mists of time (aka, my brain)
08:33:48 <merijn> tt: macOS by any chance?
08:33:52 <tt> merijn macOS
08:33:55 <merijn> boom!
08:33:58 <merijn> I'm a genius
08:34:38 <merijn> tt: Right, so Terminal.app starts bash as an interactive login shell. Here's where the arcane shell knowledge comes in
08:35:49 <merijn> .bashrc is only automatically sourced for interactive *non*login shells. And .bash_profile only for interactive login shells. So if you want changes in your .bashrc to apply to login shells (like the ones in Terminal.app) you need to explicitly source ~/.bashrc from ~/.bash_profile
08:36:48 <merijn> Although I guess the latest macOS come with Zsh, and who knows how it works there...
08:38:46 <kuribas> phadej: to confirm than the example is broken: https://gist.github.com/kuribas/c493c9599d832aac6f68ca9d9d47f376
08:39:25 <tt> merijn oh thats great.thanks! 
08:44:03 <phadej> kuribas: I'm not familiar with unbound, sorry :(
08:44:21 <kuribas> phadej: could be the documentation is wrong 
08:46:24 <safinaskar> merijn: "You just define an instance for all three classes and you're done" - i don't want to define manually all 3 classes, this is error-prone. so i want some recommended practice, for example, "just set fmap to liftM".  https://wiki.haskell.org/Functor-Applicative-Monad_Proposal gives such practice. it recommends setting fmap to liftM and <*> to
08:46:24 <safinaskar> ap.   but that wiki page is compatible with old compilers, i want some modern guide
08:49:02 <merijn> safinaskar: That wiki page is still correct
08:49:09 <merijn> What makes you think it's not
08:50:45 * hackage red-black-record 2.1.4.0 - Extensible records and variants indexed by a type-level Red-Black tree.  https://hackage.haskell.org/package/red-black-record-2.1.4.0 (DanielDiazCarrete)
08:51:03 <solonarv> although if you're not going to write out a full Functor instance you might as well let GHC derive it for you
08:56:00 <shapr> has anyone heard of hint or ghci as wai middleware?
08:56:10 <shapr> I want to be able to connect to servant like it's django
08:59:24 <Eduard_Munteanu> shapr, what do you mean? Make API calls from ghci?
09:00:08 <shapr> Eduard_Munteanu: yeh, I want a django style repl to be able to call all the code attached to my servant app
09:00:10 <shapr> ever heard of such a thing?
09:02:25 <Eduard_Munteanu> shapr, not really, no... usually the API depends on a lot of HTTP context for things like authorization.
09:03:01 <shapr> I dunno, I just want to have a ghci/repl hooked up to my servant app so I can try stuff interactively
09:03:18 <shapr> I guess hint is the way to go?
09:03:37 <hyperfekt> Is there any way I can get ghc to show me all the modules a package exports?
09:03:57 <shapr> wouldn't that be in the cabal file?
09:04:03 <shapr> or the stack file, for stack?
09:04:19 <shapr> or do you mean, the top level module could export other modules as well?
09:05:08 <solonarv> stack uses xxx.cabal files too, it just also runs hpack automatically if needed to generate that
09:05:50 <hyperfekt> shapr: It probably would be in the cabal file but I was hoping to get it for already compiled packages.
09:05:54 <solonarv> anyway, ghc-pkg describe $PACKAGE will show that info
09:06:22 <solonarv> (you may need to wrap that command in a 'stack exec' or 'cabal exec' so it sees the right package database)
09:08:04 <hyperfekt> great, thank you! that should do the job. i was hoping to do less parsing to get the list but it will suffice.
09:09:28 <hyperfekt> actually, there's ghc-pkg field :D this is great.
09:09:42 <solonarv> oh, excellent :D
09:11:32 <safinaskar> ok, thanks
09:20:14 * hackage evdev 2.0.0.0 - Bindings to libevdev  https://hackage.haskell.org/package/evdev-2.0.0.0 (GeorgeThomas)
09:20:51 <frdg> I just finished reading about the Reader type but I'm still unsure of how it works. The root of the problem I believe is that I don't completely understand record syntax or types that have functions as parameters. I think an explanation of its type declaration would be helpful.
09:22:16 <Cheery> frdg: can you point out the type declaration?
09:22:31 <merijn> frdg: What exactly don't you understand about datatypes that have functions inside them?
09:22:40 <frdg> Cheery: https://pastebin.com/CQM8qWaX
09:23:14 <merijn> frdg: I mean, do you understand "Just (+1)"?
09:23:35 <frdg> merijn: I definetly understand that
09:23:55 <Cheery> > Just (1+2)
09:23:57 <lambdabot>  Just 3
09:24:07 <merijn> frdg: Right, now consider that, but with the Nothing constructor thrown away ;)
09:24:09 <Cheery> > Just (+1) <*> Just 4
09:24:11 <lambdabot>  Just 5
09:24:31 <merijn> :t (+1)
09:24:32 <lambdabot> Num a => a -> a
09:24:37 <frdg> merijn: Its that simple?
09:24:50 <merijn> So if we pretend (+1) has type "Int -> Int" 
09:25:05 <merijn> Then "Reader (+1)" has type "Reader Int Int"
09:25:29 <frdg> ok I was really overthinking things
09:25:30 <merijn> "newtype Reader r a = Reader (r -> a)"
09:25:44 <merijn> That's exactly the same thing
09:26:09 <Cheery> given "r", provides "a"
09:26:21 <Cheery> or if "r" is, then "a" is.
09:26:27 <merijn> "newtype Reader r a = Reader (r -> a)" + "runReader :: Reader r a -> r -> a; runReader (Reader f) = f"
09:26:29 <frdg> so when it becomes a functor were ignoring the function and just focusing on its argument
09:26:42 <merijn> frdg: That last line is (basically) equivalent to the newtype with record syntax
09:27:29 <merijn> frdg: The functor instance is basically "you can alter the return type using fmap" yes
09:27:45 * hackage evdev 2.0.0.1 - Bindings to libevdev  https://hackage.haskell.org/package/evdev-2.0.0.1 (GeorgeThomas)
09:28:10 <Cheery> :t fmap show (+4)
09:28:11 <lambdabot> (Show a, Num a) => a -> String
09:28:19 <frdg> ok I'm gonna reread the chapter. Its way simpler than I was imagining.
09:28:30 <Cheery> fmap show (+4) 6
09:28:33 <Cheery> > fmap show (+4) 6
09:28:35 <lambdabot>  "10"
09:28:40 <merijn> frdg: ;)
09:29:26 <merijn> frdg: When you get to State and StateT you can use this as homework to practice: https://gist.github.com/merijn/098106abd45c940dab09
09:29:50 <frdg> bookmarked it
09:31:48 <RENNNN> is there a nicer way of writing `f (a, b)= fmap (a,) b`
09:31:49 <RENNNN> ?
09:32:41 <solonarv> :t \(a,b) -> (,) a <$> b
09:32:42 <lambdabot> Functor f => (a, f b) -> f (a, b)
09:32:51 <Cheery> :t \(a,b) -> fmap (a,) b
09:32:52 <lambdabot> Functor f => (t1, f t2) -> f (t1, t2)
09:32:57 <solonarv> % :t sequence @((,) _)
09:32:58 <yahb> solonarv: Monad m => (_, m a) -> m (_, a)
09:33:03 <solonarv> % :t sequenceA @((,) _)
09:33:03 <yahb> solonarv: Applicative f => (_, f a) -> f (_, a)
09:33:19 <solonarv> if you have Applicative then 'sequenceA' also works
09:33:33 <quiet_laika[m]> what does yahb do?
09:33:48 <solonarv> it's a GHCi session stapled to an IRC bot
09:33:51 <kuribas> :t \a -> uncurry ((a,) <$>)
09:33:52 <lambdabot> t1 -> (b -> t2, b) -> (t1, t2)
09:34:20 <quiet_laika[m]> how many long running instance of GHC does it take to run an IRC server? :p
09:34:24 <kuribas> :t uncurry (fmap . (,))
09:34:26 <lambdabot> Functor f => (a1, f a2) -> f (a1, a2)
09:34:51 <kuribas> but don't use this, it's obfuscation
09:34:59 <solonarv> huh? no, no, it's just *one* ghci session, shared across all channels and PMs
09:35:22 <Cheery> :t uncurry
09:35:23 <lambdabot> (a -> b -> c) -> (a, b) -> c
09:35:35 <Cheery> :t fmap . (,)
09:35:36 <lambdabot> Functor f => a1 -> f a2 -> f (a1, a2)
09:37:29 <Cheery> that must be correct, but how does that actually happen?
09:37:37 <quiet_laika[m]> makes sense, i was just trying to crack wise about having a compiler in the chat. does yahb do arbitrary evaluation?
09:37:45 * hackage evdev-streamly 0.0.1.0 - Bridge for working with evdev and streamly  https://hackage.haskell.org/package/evdev-streamly-0.0.1.0 (GeorgeThomas)
09:38:02 <solonarv> yes, it does IO and has filesystem access and so on
09:38:08 <Cheery> :t fmap (,)
09:38:09 <lambdabot> Functor f => f a -> f (b -> (a, b))
09:38:19 <solonarv> (but it's in a ptrace jail so you can't break stuff)
09:38:20 <Cheery> ah right.
09:38:55 <Cheery> fmap fmap (,)
09:39:05 <quiet_laika[m]> something something little bobby tables
09:39:21 <Cheery> :t uncurry (fmap fmap (,)
09:39:23 <lambdabot> error:
09:39:23 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
09:39:28 <Cheery> :t uncurry (fmap fmap (,))
09:39:29 <lambdabot> Functor f => (a1, f a2) -> f (a1, a2)
09:39:41 <Cheery> perfect.
09:43:15 <Cheery> hm.. so it actually does this.
09:43:31 <Cheery> > uncurry (fmap fmap (,)) (3,[1,2,3])
09:43:33 <lambdabot>  [(3,1),(3,2),(3,3)]
09:47:04 <Cheery> if it already reads in the type what it does, it's a bit weird thinking you could obfuscate it.
09:47:17 <ibloom> Is there an online repl that supports packages?
09:49:42 <RENNNN> thanks!
10:13:14 <st8less> I'm trying to convert this out of "do" notation just trying to learn how things work.  https://pastebin.com/xnsNxQjn
10:13:48 <st8less> I figured out someFunc = httpJSON ... >>= \response print ...
10:14:18 <st8less> But I'm not sure how to pipe the same response variable to 2 or 3 other functions in a chain.  Any pointers?
10:16:00 <kuribas> httpJSON >>= \response -> f1 response >> f2 response
10:22:18 <timCF> Is there some `Composable` type class in Haskell? When I'm doing something like `newtype Renderer = Renderer (Text -> Text)` is pretty annoying to write custom helper every time for every type like `composeRenderer :: Renderer -> Renderer -> Renderer`. I would like to infer somehow `.` from function type and work with it instead. Or maybe I should
10:22:19 <timCF> consider to use `Monoid` class in this case?
10:23:06 <merijn> timCF: You want Endo
10:23:11 <merijn> :t Endo
10:23:12 <lambdabot> (a -> a) -> Endo a
10:24:45 <merijn> timCF: Anyway, yeah Monoid would work too, since the Monoid you want is just Endo :)
10:26:25 <timCF> Oh, thanks merijn)
10:26:44 <timCF> Question already had an answer)
10:42:43 <st8less> Ooof, that took some head banging. I had to use "func (print ...) >>" instead of "func $ print ... >>".  Thanks for the tip kuribas!
10:42:53 <kuribas> np
10:44:02 <st8less> Are >> and >>= both referred to as "bind"?
10:44:52 <Cheery> yup
10:45:19 <Cheery> :t \f g -> f >> g
10:45:20 <lambdabot> Monad m => m a -> m b -> m b
10:45:31 <Cheery> :t \f g -> f >>= const g
10:45:31 <solonarv> I don't see '>>' called "bind" very often, tbh
10:45:32 <lambdabot> Monad m => m b1 -> m b2 -> m b2
10:45:49 <solonarv> '>>=' is called "bind" because you can use it to "bind" a variable to the 'a' in 'm a'
10:45:53 <berndl> >> is like snd
10:46:19 <solonarv> if 'f :: m a' then 'f >>= \x -> <in here, x :: a>'
10:46:45 * hackage fixed-vector-hetero 0.6.0.0 - Library for working with product types generically  https://hackage.haskell.org/package/fixed-vector-hetero-0.6.0.0 (AlexeyKhudyakov)
10:48:09 <st8less> I think that makes sense, I'll keep messing with it.  Thanks again!
10:57:23 <dsal> @undo {do r <- doThing; print r; shred r } -- st8less 
10:57:24 <lambdabot> <unknown>.hs:1:1:Parse error: {
10:57:36 <dsal> @undo do {r <- doThing; print r; shred r } -- st8less 
10:57:36 <lambdabot> doThing >>= \ r -> print r >> shred r
10:57:37 <dsal> damnit
11:57:15 * hackage smuggler2 0.3.2.1 - GHC Source Plugin that helps to minimise imports and generate explicit exports  https://hackage.haskell.org/package/smuggler2-0.3.2.1 (jrp)
12:01:16 <monochrom> yikes, ghcup is now a 10MB exe :)
12:01:32 <monochrom> oh, not stripped, haha
12:01:50 <monochrom> < 6MB after strip.
12:05:41 <dsal> This must be what strip clubs are like in Antarctica.
12:06:06 <monochrom> haha
12:07:22 <monochrom> I was recently watching Game of Thrones season 3, Jon Snow deep into the north. And got laid. That relates, so much cloth to take off.
12:08:04 <Rembane> But no hat! :(
12:30:35 <ski> st8less,Cheery : no, `>>' is "then"
12:32:45 * hackage Network-NineP 0.4.7 - High-level abstraction over 9P protocol  https://hackage.haskell.org/package/Network-NineP-0.4.7 (SergeyAlirzaev)
12:40:33 <st8less> üëç 
12:50:12 <Cheery> oh ok.
12:50:34 <Cheery> I saw text where it was used to refer on both, but I find that ok as well.
12:51:40 <Cheery> hm. is there a convenient way to take a number and then do f >>= f >>= f -n times?
12:52:12 <Rembane> :t replicateM 
12:52:13 <lambdabot> Applicative m => Int -> m a -> m [a]
12:52:24 <Rembane> Nah, that's not the one you wanty
12:52:31 <Rembane> :t iterate 
12:52:32 <lambdabot> (a -> a) -> a -> [a]
12:52:56 <xerox_> :t \f -> f >>= f
12:52:57 <lambdabot> error:
12:52:57 <lambdabot>     ‚Ä¢ Occurs check: cannot construct the infinite type: m ~ (->) (m b)
12:52:57 <lambdabot>       Expected type: m b -> m b
12:53:54 <Cheery> hoogle found 'nest' in Control.Monad.HT
12:54:14 <Rembane> Cheery: Do you want to apply the function f, n times to some argument? And the type of f is (a -> m b)? 
12:55:08 <Cheery> yup. nest 4 f = \x -> f f f f (x)
12:55:12 <Cheery> etc..
12:55:28 <Cheery> hm. that thing not available in my system.
12:55:36 <xerox_> > take 4 $ iterate f x
12:55:38 <lambdabot>  [x,f x,f (f x),f (f (f x))]
12:56:50 <xerox_> > foldr (.) id (replicate 4 f) x
12:56:51 <lambdabot>  f (f (f (f x)))
12:57:11 <Cheery> yup. :)
12:57:28 <Cheery> now such that 'f' is a -> m a
13:04:00 <Cheery> nest n f = foldr (>=>) pure (replicate n f)
13:06:03 <Cheery> > foldr (>=>) pure (replicate 2 (\i -> (print i) >> pure (i+1))) (1)
13:06:05 <lambdabot>  <IO Integer>
13:12:09 <maerwald> monochrom: I haven't considered stripping, but I guess debugging doesn't help much anyway
13:30:08 <ezzieyguywuf> lol, out of context "I haven't considered stripping"
13:33:01 * shapr peers balefully at ezzieyguywuf
13:33:13 * ezzieyguywuf looks up definition of  balefull
13:33:28 <ezzieyguywuf> yikes!
13:33:41 <shapr> ezzieyguywuf: are you learning Haskell?
13:34:05 <ezzieyguywuf> shapr: yes. why do you ask?
13:34:15 <shapr> just checking your on-topic-ness
13:34:40 <shapr> ezzieyguywuf: check out this fun thing I wrote last weekend: https://github.com/shapr/sandwatch/
13:34:54 --- mode: shapr set -o shapr
13:36:12 <ezzieyguywuf> shapr: lol, nice.
13:36:55 <ezzieyguywuf> "I wish all programs would dump some number of percent complete" why?
13:37:03 <Rembane> shapr: How many sandwhiches have you eaten based on that new data? 
13:37:15 <ezzieyguywuf> I'd think that for most "unix-philosophy" programs it would take more time to make this calculation than to run the program itself.
13:37:16 <shapr> Rembane: four or five at least
13:37:38 <shapr> ezzieyguywuf: I do a bunch of 45 minute compiles most days
13:37:45 <shapr> sometimes they're 20 minute compiles
13:38:12 <Rembane> shapr: Good stuff. What do you compile that takes so long time? 
13:38:27 <ezzieyguywuf> ah, well compiling is another matter altogether
13:38:30 <shapr> Part of my feedback loop has been to use a bunch of LEDs to tell me when a command succeeds or fails: https://twitter.com/shapr/status/1257789158677872640
13:38:46 <shapr> but that just tells that I need to rush back to my computer
13:39:58 <ben> "need" is a strong word
13:40:18 <shapr> ben: I get paid to add features to this codebase
13:40:49 <Rembane> shapr: Do you have a left-handed trackball or is the photo mirrored? 
13:40:51 <tomsmeding> and not get the lights on red along the way, I guess
13:40:59 <shapr> so there's an indirect kind of "get things done to keep receiving money"
13:41:11 <ben> breaks are important to keep up your productivity :)
13:41:11 <shapr> Rembane: elecom lefthanded wireless
13:41:35 <shapr> ben: yes, but with sandwatch I know how long the break lasts?
13:41:45 <Rembane> shapr: Sweet. Have you considered adding a wireless speaker that can tell you when a long-running command succeeds or fails? Like in Star Trek. 
13:41:52 <shapr> tomsmeding: lights turn red pretty often honestly
13:42:16 <shapr> Rembane: yeah, I thought about using patch bay to fire notifications to my phone
13:42:28 <shapr> this thing https://patchbay.pub/
13:42:43 <Rembane> shapr: Did you try it or did you go for the leds because LEDs? 
13:43:13 <shapr> I haven't yet tried the patch bay thing
13:43:33 * Rembane nods 
13:43:51 <shapr> I'm kinda miffed about the wireless trackball, it goes to sleep when you're not using it, and the first use has a second or two of lag
13:43:57 <Rembane> I should have read the Twitter thread before asking already answered questions here. 
13:43:58 <shapr> I'm tempted to hack a wire into it so it never goes to sleep
13:44:08 <Rembane> Yeah, hack it! Add at least one LED.
13:44:16 <shapr> I certainly have enough LEDs
13:44:24 <shapr> but! I have a Haskell question
13:44:53 <shapr> I accidentally started a reading group for Hamming's style book, and my conclusion from today is that I want to make it easy for others to use toys I build like sandwatch
13:45:07 <shapr> so, is there a recipe I can follow to have github publish binaries?
13:46:02 <Rembane> shapr: I don't know, but I've built Haskell binaries on Github using Circle CI I think. I can throw some code and stuff at you while we wait for someone with more detailed knowledge to answer.
13:46:18 <shapr> speaking of which, if you don't own this book I recommend it strongly: https://www.amazon.com/dp/1732265178/
13:46:27 <shapr> Rembane: yes please!
13:46:59 <shapr> ezzieyguywuf: what OS do you use? What would be the easiest way for you to install a program?
13:47:03 * shapr takes a random poll
13:47:32 <Rembane> shapr: https://github.com/Rembane/postgres-websockets/commit/77c00b56960e20e54a969930f4e5eeceb4c18d1d
13:48:24 * shapr reads
13:48:31 <Rembane> shapr: Start from the bottom up of .circleci/config.yaml
13:49:23 <shapr> ok
14:00:06 <zincy__> Why is NULL bad generally? I know it is I just don't know how to articulate it
14:00:32 <Rembane> zincy__: NULL in which context? 
14:00:57 <zincy__> Just in the general context of programming languages
14:01:05 <Cheery> case explosion
14:01:42 <Rembane> zincy__: It never goes away. If you have one NULL it will poison the whole program, and it can show up anywhere and you're never sure. 
14:01:50 <enikar> NULL is bad as a failure, like in null pointer in java, e.g.
14:02:09 <Rembane> zincy__: Compare thay with Maybe where you can see where you have to care about them, that you can't do with a NULL. 
14:02:31 <zincy__> Rembane: Ah ok so you don't know *which* kind of value was expected because NULL can be of any type?
14:02:32 <ski> zincy__ : when you know it can't be `NULL' (or shouldn't be allowed to be `NULL'), you'd like the language to know that as well, so you don't have to add redundant checks (which might not be redundant if there's a bug someone, someone violating a precondition, not satisfying a postcondition)
14:02:39 <Cheery> if you got a and b. you only need to worry about one case.
14:02:57 <Rembane> zincy__: Yup 
14:02:58 <Cheery> though, if anything can be NULL in your language, now you need to worry about 4
14:03:03 <ski> zincy__ : and the other side is that when it could be `NULL', you'd like the language to remind you of that, so that you do check
14:03:12 <zincy__> ski: Wait so in other languages *any* value could be NULL?
14:03:30 <zincy__> That is terrifying maybe I have spent too long in Haskell
14:03:33 <ski> zincy__ : the basic problem is that every pointer, or every object reference, can be `NULL'/`null'
14:03:40 <zincy__> ah
14:03:46 <Cheery> and for every pointer, you double the cases you have.
14:03:59 <zincy__> That is crazy
14:04:21 <Rembane> There's a reason for why NULL is called the billion dollar mistake. 
14:04:23 <zincy__> How does anything get done in a language where anything could be NULL in a sneaky way
14:04:45 * hackage hsinspect-lsp 0.0.3 - LSP interface over the hsinspect binary.  https://hackage.haskell.org/package/hsinspect-lsp-0.0.3 (tseenshe)
14:04:50 <Cheery> you basically encode a with (1+a) and you can model consequences of NULL.
14:04:55 <zincy__> Maybe because there are so many things wrong with it, its hard to summarise them all
14:05:25 <Rembane> zincy__: Because in most of the cases the value you are after isn't null. 
14:05:59 * ski . o O ( "Null References: The Billion Dollar Mistake" by Sir Charles Antony ("Tony") Richard Hoare in 2009-08-25 at <https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare/> )
14:06:09 <zincy__> thanks ski
14:06:10 <Cheery> zincy__: if you know the case doesn't happen, you can crash on it.
14:06:54 <Cheery> so in NULL-languages you just assume a lot.
14:07:08 <zincy__> So Erlang doesnt have NULL
14:07:19 <zincy__> And its dynamically typed so Javascript has no excuses
14:08:13 <zincy__> So thanks for clearing that up everyone.
14:08:18 <Rembane> No worries.
14:08:33 <zincy__> I was just having a moment where I felt I knew something but I wasn't clear on the reasons why
14:09:15 * ski . o O ( "Option types, optional parameters" by Riastradh in 2006-02-03 at <https://mumble.net/~campbell/blag.txt>,(RSS) <http://vrici.lojban.org/~cowan/blag.xml> )
14:09:24 <Cheery> in C only pointers can be NULL, but there's enough of that stuff to trip you anyway.
14:09:25 <ski> that one also talks about "domain contagion", which is related
14:09:31 <zincy__> Just need to finish my self-study maths course and I can code more again
14:10:23 <zincy__> 3 years later :D
14:49:15 * hackage lens-process 0.3.0.2 - Optics for system processes  https://hackage.haskell.org/package/lens-process-0.3.0.2 (topos)
14:52:45 * hackage microlens-process 0.2.0.2 - Micro-optics for the process library  https://hackage.haskell.org/package/microlens-process-0.2.0.2 (topos)
14:56:07 <asdfasdfasdf> HI
14:58:15 * hackage base32 0.1.1.2 - RFC 4648-compliant Base32 encodings/decodings  https://hackage.haskell.org/package/base32-0.1.1.2 (topos)
14:59:58 <topos> sorry for the spam. Stackage is griefing me
15:24:45 * hackage nonempty-vector 0.2.0.2 - Non-empty vectors  https://hackage.haskell.org/package/nonempty-vector-0.2.0.2 (topos)
15:31:45 * hackage extra 1.7.3 - Extra functions I use.  https://hackage.haskell.org/package/extra-1.7.3 (NeilMitchell)
15:37:15 * hackage ip 1.7.2 - Library for IP and MAC addresses  https://hackage.haskell.org/package/ip-1.7.2 (chessai)
16:16:08 <isene> Could someone here give me their viewpoint on pros and cons of Haskell versus Ruby and versus Julia?
16:17:40 <Cheery> Julia's multimethod dispatch probably doesn't solve problems that a full-blown computer algebra system integration into a programming language demands to be solved.
16:21:44 <Cheery> People think about static typing in a bit odd way. I think the problem is that early computer systems used types to optimise implementation details.
16:22:26 <Cheery> it's not entirely wrong, but it stuck to culture.
16:26:27 <init> How is `1 :: Num p => p` read?
16:26:35 <Cheery> Anyway haven't used Ruby, but it's presented as alternative to Python. I've heard people have programmed with it.
16:26:44 <init> My understanding is `::` is read,  "has type of" 
16:27:15 <init> p => p,  I don't understand 
16:27:26 <RENNNN> isene, Julia is pretty easy to use if you come from C or C++ and maybe matlab
16:28:07 <Cheery> init: (::) means that you state a judgement, the term on the left side is of the type on the right side.
16:28:13 <ski> init : it means `1' has type `p' for any type `p', as long as the constraint `Num p' is satisfied ("`p' is a numeric type)
16:28:20 <Cheery> You tell how the thing is supposed to be read.
16:28:34 <kamek> is there anything out there that can parse friendly durations from strings ? like "10s" or "30m"
16:29:00 <RENNNN> isene, they use the functional part when it makes sense to them. (i.e. pass a line search function to your optimizer)
16:29:01 <Cheery> dunno the name for such thing. Maybe search for that term if you know it?
16:29:19 <Cheery> kamek: it's also fairly easy to implement yourself.
16:29:25 <RENNNN> kamek, deca second?
16:29:34 <RENNNN> nvm
16:29:36 <RENNNN> read that wrong
16:29:41 <Ariakenom> in c => t then c is a list of constraints that affect the type t. as in Num p, p is a number type
16:30:06 <Cheery> kamek: also you probably want it the other way around as well.
16:30:24 <RENNNN> isene, my point is, they have some functional programming stuff and used them normally but the entry barrier is VERY low
16:30:31 <Cheery> I'd guess, datetime or deltatime parsing/printing
16:30:45 <kamek> yeah I found a few libs that can display human friendly durations but nothing that can parse them
16:31:01 <Cheery> they probably have parsers in them as well?
16:31:34 <Ariakenom> init, another example would be "Num p => [p]" a list of things of type "p" and "p" has to be a number type
16:31:59 <init> How is `=>` read?
16:32:24 <Ariakenom> c => t reads the type t wit the constraints c
16:32:55 <Cheery> init: you can look up Num p from the haskell documentation
16:33:21 <Ariakenom> also let me add some parenthesis to make the syntax clear (1 :: ((Num p) => p))
16:33:33 <Cheery> http://hackage.haskell.org/package/base-4.14.0.0/docs/GHC-Num.html
16:33:56 <Ariakenom> > :t sum
16:33:59 <lambdabot>  <hint>:1:1: error: parse error on input ‚Äò:‚Äô
16:34:05 <Ariakenom> % :t sum
16:34:05 <yahb> Ariakenom: (Foldable t, Num a) => t a -> a
16:34:11 <Ariakenom> eh well
16:34:21 <init> % :t 1
16:34:21 <yahb> init: Num p => p
16:34:41 <Cheery> I'm btw. annoyed about '-' being  infix/prefix, for some reason.
16:34:53 <Cheery> maybe because it's ambiguous
16:34:53 <Ariakenom> sum :: Num a => [a] -> a      sum takes a list of "a"s and returns one "a", and "a" has to be a number type
16:35:35 <init> Oh!
16:35:50 <init> I get it now 
16:36:03 <init> `=>` is the type constraint 
16:36:23 <init> or indicated it at least 
16:36:38 <Cheery> yeah, it's like you'd expect more from 'a' that it's just is there.
16:36:55 <Ariakenom> a constraint => a type
16:37:12 <Cheery> eg. you expect it forms a ring, and numbers can be interpreted as constructors for it.
16:38:06 <Ariakenom> Num only has one law and it's dumb :p
16:39:11 <Cheery> oh lol.. it assumes Natural there, so the ring -form isn't exact.
16:39:36 <Cheery> there's also Float, that also violates few commonly expected rules.
16:40:53 <Ariakenom> Cheery, https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#negative-literals
16:42:50 <Cheery> I'll throw a table around because of that someday
16:57:38 <ezzieyguywuf> shapr: gentoo. what program?
16:57:45 <solonarv> I am one of the people who occasionally go on rants about Num being bad
17:00:58 <Cheery> solonarv: it contributed to me abandoning Haskell the first time.
17:01:26 <Cheery> Though, that's not necessarily a bad thing because I learned a thing or two and returned.
17:04:42 <solonarv> a better division IMO would be a Semiring class with (+), (*) and fromNatural; a Ring class with (-), negate, and fromInteger
17:04:52 <solonarv> and finally some class to shove abs/signum into, I suppose
17:05:41 <Cheery> (-1) :: Num a => a -> a
17:06:01 <Cheery> I'd want it that way
17:06:48 <solonarv> yeah, but then someone adds Natural and writes a Num Natural instance so you can use (*) and (+) and literals with Natural
17:07:10 <solonarv> but oh no! (-1) :: Natural compiles, but is guaranteed to fail at runtime!
17:09:26 <Cheery> um. but yeah. something like that. and bit of consistency such that things aren't terrible to write.
17:09:36 <Cheery> I'd think that (-1) could be perhaps identified from the context.
17:09:47 <Cheery> eg. whether it's subtract by 1, or negative 1
17:12:15 * hackage hlint 3.1.4 - Source code suggestions  https://hackage.haskell.org/package/hlint-3.1.4 (NeilMitchell)
17:13:47 <solonarv> theoretically yes, but it would be messy to implement and would surely have very unintuitive edge cases
17:14:43 <Cheery> how about. (-1) (+1) :: Numeral a => a
17:15:14 <Cheery> actully no, it needs to be negative and positive numerals
17:15:38 <Cheery> with SemiRing a => (a -> a) being an instance of it.
17:16:44 <Cheery> and Ring being instance of NegNumeral
17:16:46 <Cheery> heh.
17:17:26 <Cheery> but there's still the annoying x y z - 4, though.. maybe I'd cope with that then.
17:17:58 <Cheery> though not sure about the ring property because.. Floats
17:18:13 <solonarv> bah, floats ruin everything anyway
17:18:18 <solonarv> just pretend they don't ;)
17:18:52 <Cheery> well it's actually a big deal that should be layed around. Correctness of numerical code.
17:19:38 <Cheery> there were few resources but I've probably missed them already.. The next project I have to take on is probably link database to my server.
17:31:49 <ezzieyguywuf> is there anything in prelude that offers something like this? https://hackage.haskell.org/package/MissingH-1.4.3.0/docs/Data-List-Utils.html#v:hasAny
17:32:03 <ezzieyguywuf> missingH has a lot of dependencies, it's a shame to pull tat in for a single function.
17:32:45 <infinisil> ezzieyguywuf: Could you use Set's?
17:32:54 <infinisil> Because then it's just checking whether the intersection isn't empty
17:33:02 <infinisil> Which would also be much faster
17:33:36 <ezzieyguywuf> hrm, I suppose it's possible, I'll just have to learn about sets.
17:33:52 <ben> the function is like three lines, just copy it, heh
17:33:54 <ezzieyguywuf> my `getAs` function returns a list, but in fact it should be a Set, so this makes sense
17:34:02 <ezzieyguywuf> ben: hah, thought about it.
17:34:19 <ben> i come from the land of vendoring :P
17:34:44 <ezzieyguywuf> I'll split the difference - copy the function and add a TODO to convert to Set
17:37:26 <infinisil> (Set's are in the containers package, but that's rather standard anyways)
17:49:12 <ezzieyguywuf> yea, i don't mind having containers as a dep
18:19:15 <freeman42x[m]1> I run into following issue, any advice on how to get HIE to work? https://github.com/haskell/haskell-ide-engine/issues/1781
19:10:31 <ezzieyguywuf> https://www.haskell.org/haddock/doc/html/ch03s04.html, is the syntax after "The alternative style of placing the commas..." valid?
19:10:41 <ezzieyguywuf> i.e. `, C(..)`?
19:10:46 <ezzieyguywuf> I tried it in my module and got a syntax error
19:11:47 <Johnhs> Hello guys
19:14:56 <Johnhs> :-*
19:15:21 <Johnhs> :P
19:19:26 <Johnhs> :-*
19:19:38 <ski> ezzieyguywuf : remove the initial comma ?
19:19:52 <ski> hello Johnhs
19:20:14 <ski> i do it like
19:20:23 <ski>   module Blah
19:20:28 <ski>     ( foo
19:20:31 <ski>     , bar
19:20:34 <ski>     , ...
19:20:37 <ski>     ) where
19:25:10 <ezzieyguywuf> ski: yes removing the initial comma fixes the syntax error
19:25:19 <ezzieyguywuf> I'm just surprised that the haddock documentation had that typo.
19:25:27 <ezzieyguywuf> i thought maybe I was doing something wrong.
19:25:30 <ski> mm. so it seems that page is in error, as i thought, then
19:26:37 <ski> does Haddock understand it, if you put e.g. `-- * Classes' on the line before `( foo', with the open bracket ?
19:26:49 <ski> or does it have to be after the bracket ?
19:27:05 <ezzieyguywuf> ski: I'm messing around with haddock now, I can check. just a sec
19:27:40 <ezzieyguywuf> (I doubt it though)
19:28:14 <ezzieyguywuf> ski: haddock errors out
19:28:35 <ski> okay. so you have to have that first item, without either of `(' and `,' then, i assume
19:29:24 <ezzieyguywuf> seems so.
19:29:47 <ezzieyguywuf> wowsa wowsa wasn't expecting my haddock documentation to look so purty
19:30:19 <ski> @wn purty
19:30:21 <lambdabot> No match for "purty".
19:30:50 <ezzieyguywuf> @wn pretty
19:30:51 <lambdabot> *** "pretty" wn "WordNet (r) 3.0 (2006)"
19:30:51 <lambdabot> pretty
19:30:51 <lambdabot>     adv 1: to a moderately sufficient extent or degree; "pretty
19:30:51 <lambdabot>            big"; "pretty bad"; "jolly decent of him"; "the shoes are
19:30:51 <lambdabot>            priced reasonably"; "he is fairly clever with computers"
19:30:53 <lambdabot> [7 @more lines]
19:31:05 <ezzieyguywuf> @wn urbandictionary
19:31:06 <lambdabot> No match for "urbandictionary".
19:31:08 <ezzieyguywuf> lol
19:33:21 <ezzieyguywuf> if I don't export a function, should I still document it?
19:34:03 <RENNNN> ezzieyguywuf, if you expect people to read it yes
19:34:17 <RENNNN> i.e. contribute to your whatever
19:36:40 * ezzieyguywuf nods "Good point."
19:36:54 <ezzieyguywuf> or even just for myself, if I'm wondering what the heck I was thinking.
19:38:52 <ski> interface documentation is not the same as implementation documentation. but if the function has some non-obvious precondition or postcondition, or is maintaining some invariant, it could be a good thing to mention that, at least
19:39:26 <ski> in some cases, documenting some choice that was made, that could have been made differently
19:41:14 * hackage calamity 0.1.10.1 - A library for writing discord bots  https://hackage.haskell.org/package/calamity-0.1.10.1 (nitros12)
19:41:48 <ezzieyguywuf> lol, nice name
19:45:06 <RENNNN> can i implement a binary three insert as a hylomorphism
19:45:07 <RENNNN> ?
19:46:17 <ezzieyguywuf> you know, because of currying, I guess it really matters what order I choose for my 'parameters'
19:46:37 <ezzieyguywuf> this will end up having implicaions on whether a function is easily foldable or mapable or something
19:48:39 <ski> i guess you mean partial application, ezzieyguywuf
19:48:52 <ski> RENNNN : with what as the intermediate data structure ?
19:48:56 <ezzieyguywuf> ski: probably.
19:49:00 <ezzieyguywuf> I'm still leraning all the lingo.
19:49:14 <ski> btw, note that Haskell doesn't "have currying"
19:49:53 * ski usually also prefers talking about "curried style"
19:49:55 <ezzieyguywuf> that's how I learned about in Learn You a Haskell For Great Good
19:50:03 <ezzieyguywuf> there was even a cute picture of ghandi or something I think
19:50:41 <ski> yea. LYAH is known for cute pics
19:51:03 <ezzieyguywuf> love the pics
19:51:15 <RENNNN> ski, a Either v (o, [Trie v o]) -> Exp v o
19:51:19 <ski> anyway, consider an expression, say `x^2 - x*y + y^2'
19:52:00 <ski> it's natural to consider this as depending on "parameters", `x' and `y'
19:52:44 <ski> this leads to an intuitive concept of multi-parameter function. in this case, a function mapping given values for `x' and `y' into the corresponding value of `x^2 - x*y + y^2'
19:52:53 <ski> ezzieyguywuf : making sense ?
19:53:50 <ezzieyguywuf> yes
19:53:57 <ski> RENNNN : i fail to see how that function type would easily be considered as a fix-point of a specific functor
19:54:34 <ski> ezzieyguywuf : now, you may have an expression like `a*x^2 + b*x + c', where, strictly speaking, the parameters would be `a',`b',`c',`x'
19:54:52 <ezzieyguywuf> ok
19:55:37 <ski> however, this may be a generalization from specific examples like `x^2 - 3*x + 5',`4*x^2 + 3*x',`9*x + 1', &c., which would correspond to particular values of `a',`b',`c'
19:56:17 <ski> so, we may only want to consider some variables occuring in an expression as parameters, not all of them. the rest being considered as "fixed, but unknown"
19:56:30 <ezzieyguywuf> that's fair
19:56:55 <ski> so, in this case, if we're given particular values of `a',`b',`c', then that determines a particular mapping/function, from `x' to `a*x^2 + b*x + c'
19:57:35 <ski> so, if `a = 0',`b = 9',`c = 1', then we have the particular mapping that maps `x' to  `9*x + 1'
19:57:55 <ski> this is actually a "partiall application" that we did here
19:58:08 <ski> we supplied values for some of the variables
19:58:16 <RENNNN> ski, can you imagine something that would work?
19:58:56 <ski> anyway, the mapping from `x' and `y' to `x^2 - x*y + y^2' is not the same as the mapping from `x' (considering `y' as fixed) to `x^2 - x*y + y^2'
19:59:03 <RENNNN> for a trie or and ordered b tree
19:59:03 <ezzieyguywuf> so your function would make the most sense as `func :: (a, b, c) -> (x, y, z) -> Float` or something, rather than swapping those around
19:59:28 <ski> ezzieyguywuf : so. we can't just mention an expression like `x^2 - x*y + y^2', and have that determine which mapping/function we're after. since that's ambiguous
20:00:21 <ski> so, here's where lambda notation for functions come in. `\(x,y) -> x^2 - x*y + y^2' is one function, `\x -> x^2 - x*y + y^2' is another
20:00:47 <ski> the first doesn't depend on `x' nor `y'. the second depends on `y' (but not on `x')
20:01:01 <ski> while the expression `x^2 - x*y + y^2' depends on both `x' and `y'
20:01:45 <ski> often, people blur the lines here, which, imho, doesn't really help beginners to understand the distinction
20:01:48 <ski> anyway
20:02:06 <ski> we have an intuitive concept of "multiple-parameter function/mapping"
20:02:39 <ezzieyguywuf> i don't see how the syntax in your second lamba is valid
20:02:41 <ezzieyguywuf> where did y come from
20:02:45 <ski> if you have an expression, you can pick some of the variables occuring in it, and "consider the expression as a mapping from those variables"
20:03:12 <ski> ezzieyguywuf : well, how about `\x -> a*x^2 + b*x + c' ?
20:03:18 <ski> where did `a',`b',`c' come from ?
20:03:43 <ski> if i ask you what `x + 1' is, you will ask me first what `x' is
20:03:51 <ezzieyguywuf> shouldn't ther ebe a `where` somewhere or something?
20:04:06 <ski> `x + 1' is an open expression. the value of it depends on the value that we'll end up giving to `x'
20:04:27 <ski> if `x' is `5', then `x + 1' is `5 + 1', that is `6'
20:04:59 <ski> but, it's important to be able to reason about open expressions, like `x + 1', without knowing yet what the value of `x' is to be
20:05:03 <ezzieyguywuf> I'm getting pretty confused
20:05:10 <ezzieyguywuf> I'm going to go now, thanks for helping
20:05:12 <ski> okay
20:06:56 <RENNNN> the more i read about catamorphism the more confused i get
20:07:15 <RENNNN> what can we compute with no recursion and only cata, ana and hylo
20:07:45 <RENNNN> can we simulate a turing machine only on this?
20:10:32 <dolio> You can compute everything with hylo.
20:11:08 <RENNNN> dolio, that's a bold clame that i'm not prepared to argue with, but do you have a small sketch of a proof?
20:11:37 <RENNNN> or some sort of example?
20:11:41 <dolio> Well, it might depend on what type you have hylo for, but list is sufficient at least.
20:11:58 <dolio> Even nat might be, though.
20:12:44 <dolio> Just a minute.
20:14:50 <dolio> @type \f -> foldr (\_ x -> f x) undefined . unfoldr (const $ Just ((),()))
20:14:51 <lambdabot> (c -> c) -> () -> c
20:15:31 <dolio> > (\f -> foldr (\_ x -> f x) undefined . unfoldr (const $ Just ((),()))) (1:) ()
20:15:33 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
20:16:20 <dolio> Note that `(c -> c) -> c` is the type of the fixed point combinator.
20:24:16 <RENNNN> dolio, how does this compile?
20:24:28 <RENNNN> > :t foldr
20:24:30 <lambdabot>  <hint>:1:1: error: parse error on input ‚Äò:‚Äô
20:24:37 <RENNNN> @type foldr
20:24:38 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
20:24:44 <RENNNN> @type (\ x -> f x)
20:24:45 <lambdabot> (Show t1, FromExpr t2) => t1 -> t2
20:26:55 <dolio> I don't really understand the question.
20:27:15 <RENNNN> @type foldr (\ x -> x)
20:27:17 <lambdabot> Foldable t => b -> t (b -> b) -> b
20:28:02 <RENNNN> i thought foldr's first argument should take 2  arguments
20:28:26 <dolio> Mine did. I just threw one away with _, because it's just a unit.
20:28:58 <RENNNN> i see
20:30:23 <dolio> Anyhow, that unfolds an infinite list of units, and then folds it with an application of `f` for every unit, so it is `f (f (f (...)))`
21:06:45 * hackage shwifty 0.0.3.0 - Generate swift types from haskell types.  https://hackage.haskell.org/package/shwifty-0.0.3.0 (chessai)
21:18:45 * hackage calamity 0.1.11.0 - A library for writing discord bots  https://hackage.haskell.org/package/calamity-0.1.11.0 (nitros12)
21:25:21 <RENNNN>       f x = let r = catMaybes x in ff r
21:25:22 <RENNNN>       ff [] = Nothing
21:25:22 <RENNNN>       ff x = Just x
21:25:26 <RENNNN> is there a nicer way of writing this?
21:25:52 <RENNNN> the only function that matched ff was sequence but it doesn't do that
21:26:29 <RENNNN> i have a list maybes and i want to return either the just the non nothing elements or nothing if the list will be empty
21:26:47 <ezzieyguywuf> so, I've used python's cmd module, and gnu readline as well, in the past to write some basic REPL stuff with history and tab completion and basic editing. Is there a similar library for haskell?
21:27:03 <ezzieyguywuf> I see there's a readline wrapper, but I was curious if here was anything native or more "haskelly"
21:27:11 <koz_> ezzieyguywuf: Haskeline?
21:27:29 <koz_> http://hackage.haskell.org/package/haskeline
21:28:07 <ja> wow, so many downloads but no ratings :O
21:28:19 <ezzieyguywuf> koz_: seems interesting, I'll take a look.
21:39:07 <ezzieyguywuf> why is the hackage rating scale out of 3? seems too few
21:39:32 <wavemode_> hackage ratings are completely meaningless
21:39:38 <ezzieyguywuf> heh i see
21:39:52 <ezzieyguywuf> so how can I know if a list of dependencies on a given package are 'sane' or not?
21:40:05 <ezzieyguywuf> i.e. "did this author use a bunch of weird obscure stuff? or mostly normal things."
21:40:58 <wavemode_> I'm not sure what you mean. Can you give an example?
21:41:19 <wavemode_> A very large download count usually indicates that the library does what it's supposed to
21:41:33 <ezzieyguywuf> well, koz_ linked haskeline. I don't know what stm is, or transformers. I can guess that its other dependencies are pretty standard
21:41:46 <dsal> stm is great magic
21:41:51 <ezzieyguywuf> ah, i see.
21:41:53 <dsal> transformers is pretty much part of anything real you build
21:42:06 <dsal> If you do anything with concurrency, you probably want stm.
21:42:07 <ezzieyguywuf> haskeline has a large download count. although, wat is 'large'? what is a 'download'?
21:42:15 <dsal> :t count
21:42:16 <lambdabot> error:
21:42:16 <lambdabot>     ‚Ä¢ Variable not in scope: count
21:42:16 <lambdabot>     ‚Ä¢ Perhaps you meant one of these:
21:43:49 <koz_> ezzieyguywuf: Haskeline is distributed with GHC itself.
21:43:53 <koz_> (it's a core part of GHCi)
21:44:04 <koz_> You don't _get_ much more 'reliable and sensible' than this.
21:44:45 <ezzieyguywuf> *thumbs up*
21:44:46 <ezzieyguywuf> nice
21:45:41 <ezzieyguywuf> oh snap, even the basic example in the documentation has command history and tab completion
21:45:58 <ezzieyguywuf> neat, so cool it won't be time wasted learning how to use haskeline.
21:46:07 <dsal> ezzieyguywuf: If you've ever written any multithreaded programming, imagine never having learned all of the things you had to learn to get things working (mutexes, lock acquisition sequences to prevent deadlocks, etc...) and having things mostly just work.  STM is approximately that.
21:46:26 <ezzieyguywuf> I might need to learn more about monads...
21:46:36 <dsal> STM is a monad!  :)
21:46:51 <ezzieyguywuf> dsal: yea I've heard that concurrency in haskell is less of a headache
21:46:52 <ezzieyguywuf> go too
21:47:02 <ezzieyguywuf> haven't quite gotten there yet though.
21:47:28 <dsal> go makes a few things easier, but it's almost the same headache you'd have in any other GC'd language.
21:47:48 <dsal> You still have mutexes you have to acquire in the right order.  You have channels and a sort of neat "select" thing you can do with them.
21:48:43 <dsal> It's not possible to write something like STM in almost any other language (though certain libraries exist that will work if you use them very carefully).
21:50:40 <dsal> e.g., in go, everything's mutated all the time by convention.  It's *possible* to copy things (though some things are quite tedious to copy), so you can't even conceive of making some changes and then retrying/rolling back/committing.
21:51:25 <ezzieyguywuf> that sounds really cool, I'm excited to try stm out. in the way future
21:51:28 * dsal did a bunch of silly complicated concurrency stuff in a network server today with STM
21:53:05 <ski> @type let anyJusts :: [Maybe a] -> Maybe [a]; anyJusts = mconcat . (map . fmap) (: []) in anyJusts  -- RENNNN
21:53:06 <lambdabot> [Maybe a] -> Maybe [a]
21:53:38 <ski> > let anyJusts :: [Maybe a] -> Maybe [a]; anyJusts = mconcat . (map . fmap) (: []) in anyJusts [Nothing,Just 2,Just 3,Nothing,Just 5]
21:53:40 <lambdabot>  Just [2,3,5]
21:53:48 <ski> > let anyJusts :: [Maybe a] -> Maybe [a]; anyJusts = mconcat . (map . fmap) (: []) in anyJusts [Nothing,Nothing]
21:53:49 <lambdabot>  Nothing
21:53:52 <ski> > let anyJusts :: [Maybe a] -> Maybe [a]; anyJusts = mconcat . (map . fmap) (: []) in anyJusts []
21:53:54 <lambdabot>  Nothing
21:54:24 <dsal> It sounds like "that's magic, so it must be hard" but it's basically    atomically { x <- read aVar; y <- read anotherVar; write zVar (x + y); j <- read oneMoreVar; sendResult ch j }.  -- Something reading from `ch` will only get the value after the transaction commits and any number of other threads can be doing any number of things with all those variables without you having to think about it.
21:56:03 <dsal> i.e., both the write to `zVar` and the send to `ch` happen, or neither happen.  And they only happen with a consistent state of all of the reference vars.
21:57:27 <dsal> ezzieyguywuf: Anyway, it's a level of "just works" that you could explain to an inexperienced programmer much more easily than a battle-hardened one.  The latter will think you're lying.  But you'll see it everywhere.
21:58:32 <ezzieyguywuf> sounds like schrodinger's cat
21:58:45 <ezzieyguywuf> "it will happen. or it won't"
21:58:50 <ezzieyguywuf> #YodaVoice
21:59:24 <monochrom> Um, I'm afraid that should be "happen it will, or won't" :)
21:59:35 <dsal> monochrom: is there a try?
21:59:38 <ezzieyguywuf> lol
22:00:20 <dsal> ezzieyguywuf: If you're familiar with database transactions, it's similar to that.  begin transcaction;  do stuff;  commit;  Except it doesn't fail, per se.
22:00:32 <monochrom> Yoda's Law of Excluded Try.
22:00:48 * ski . o O ( "Language of the Included Miracle" )
22:01:18 <monochrom> Angelic nondeterminism has included miracle :)
22:02:06 <ski> hm, what does that mean ?
22:04:29 <monochrom> whereas demonic nondeterminism is an adversary---it chooses the choice that breaks your specification whenever possible, angelic nondeterminism is an ally---it chooses the choice that fulfills your specification whenever possible.
22:15:29 <ski> mm, yes
22:46:19 <dmwit> What about chaotic lawful nondeterminism, which fulfills your spec but breaks everybody else's?
22:49:34 <monochrom> :)
23:14:24 <n5771> https://www.facebook.com/100002188643854/posts/2917826294966963/?app=fbl
23:15:20 <ja> meh, don't click that link
23:15:29 <dsal> It already said facebook
23:23:32 <ja> john carmack used to post things on facebook because they had employed him :P
23:44:21 <Nolrai> god dangit mkSparse from HMatrix throws an exception when given an empty list. How am I supposed to generate the zero matrix?
23:49:16 <iqubic> Are you trying to create a matrix with all cells being 0?
23:50:31 <ja> there is a SO question on this: https://stackoverflow.com/a/8434962/309483
23:51:18 <iqubic> try "konst 0 (rows, columns)" where rows :: Int, and columns :: Int.
23:51:42 <iqubic> And yes, they named it konst with a k to avoid conflict with this:
23:51:44 <iqubic> :t const
23:51:45 <lambdabot> a -> b -> a
23:54:54 <iqubic> But yeah, konst will build either a vector or matrix where all the elements are the same. The first argument is the element to put in each cell, and the second element is the dimensions. If you set that second argument (dimension) to a single Int, then you get a vector, if you set the second argument to (Int, Int) you get a matrix.
23:55:12 <Nolrai> I don't actually know the dimensions I need because mkSparse doesn't need it. :/
23:55:28 <iqubic> Ah. I see.
23:56:20 <iqubic> I'm not sure how to help you then. I've never used this library. I'm just telling you what I found in like 3 minutes of searching the documentation.
23:58:19 <dmwit> Nolrai: mkSparse needs it, it just infers it from the maximal row and column you pass in. Which explains why it crashes on an empty list.
23:58:37 <Nolrai> Oh. Well, then this wont work at all.
23:59:03 <dmwit> I don't really think it's sensible to make a matrix of unknown size.
23:59:28 <dmwit> Why do you (think you) need that capability?
