00:17:45 * hackage encoding 0.8.4 - A library for various character encodings  https://hackage.haskell.org/package/encoding-0.8.4 (swamp_agr)
00:46:39 <Eugleo> Is it possible to create a "constraint synonym"? I have a pretty long constraint list, and I'd like to alias it to MyContraints
00:47:35 <Eugleo> (so that I can write MyConstraints a b w => ..., instead of (Generic a, Generic b, ToOR_ a, ...) => ...)
00:49:01 <lortabac> Eugleo: yes, you need to enable the ConstraintKinds extension
00:50:30 <koz_> Then you just write it like a type synonym.
00:50:48 <koz_> type EqShow a = (Eq a, Show a)
00:50:50 <koz_> For instance.
00:50:57 <Eugleo> Thanks
00:51:24 <Eugleo> Isn't really a good style, is it? Would it be better to create a whole new class for it?
00:52:10 <koz_> Eugleo: I would say constraint synonyms are a _much_ better plan.
00:53:07 <Eugleo> Any particular reason for that? You didn't like type synonyms very much, I thought you'd dislike the Contraint ones as well
00:53:46 <koz_> Oh, I don't like it either, because I find it just as confusing to abbreviate type class constraints in this manner.
00:53:56 <koz_> However, if the toss-up is between that and _a new class_?
00:54:00 <koz_> Yeah, pretty easy answer.
00:54:46 <Eugleo> What's so bad about new classes? Yesterday I got the idea that writing new classes is good if it fits my abstraction model
00:55:07 <koz_> Because type classes are generally the wrong solution to most problems.
00:55:32 <phadej> opinions...
00:55:39 <koz_> phadej: Yes, it's an opinion.
00:55:45 <koz_> I understand not everyone shares it.
00:57:11 <koz_> In this case, your problem is 'type class constraints take too long to spell out'.
00:57:21 <koz_> For _this_? A type class is 100% not the right solution.
00:57:40 <phadej> ... except if you want to be able to partially apply it
00:57:52 <phadej> so not 100%
00:58:01 <koz_> phadej: Partial application wasn't mentioned anywhere, but yes, you are correct.
00:58:06 <Eugleo> Which I'm not, in this case. 
02:08:45 <peli> how can i go from writing mostly trivial haskell to writing useful(tm) stuff
02:09:01 <Taneb> peli: by giving it a go
02:09:59 <juri_> find a deadish project, and contribute to it. 
02:19:10 <anonymous_entity> //history
02:19:23 <anonymous_entity> /history #haskell
02:26:21 <merijn> peli: "Just doing it" is, probably the only real answer. It also depends a bit on what your experience so far as been (i.e., what's trivial haskell?)
03:10:40 <fendor> can I register a package in the global package db such that it is available for every user on the system?
03:11:56 <merijn> fendor: Technically, yes. Should you? Probably no
03:12:37 <fendor> merijn, I know that I should not. I only want QuickCheck, though :/ How terrible of a person am I for attempting this?
03:13:50 <merijn> fendor: Is there any reason you can't just rely on cabal (or stack) to install it?
03:14:31 <fendor> merijn, Students are instructed to use ghci. It it kind of hard for me to instruct them to use `cabal repl -b QuickCheck`
03:15:07 <fendor> mainly because I cant send global messages to every participant
03:15:08 <maerwald> cabal install --lib QuickCheck?
03:15:26 <fendor> maerwald, that is not global, right? It modifies ~/.ghc/../default?
03:19:21 <maerwald> fendor: global enough
03:20:09 <fendor> maerwald, global for my user, not the students, though
03:20:45 <maerwald> well, I have no idea what kind of system you are thinking of and you haven't explained
03:22:48 <fendor> I am sorry, it is a server, where cabal and ghc are available, students have a user account (out of laziness by the admin, I do not have access to their home dirs, I only have access to  specific directory ) and I have user account
03:25:24 <fendor> and I want to make `QuickCheck` available for students by just calling `ghci`. As a work-around, I know I can suggest `cabal repl -b QuickCheck`
03:41:45 * hackage monadic-recursion-schemes 0.1.3.4 - Recursion Schemes for Monadic version.  https://hackage.haskell.org/package/monadic-recursion-schemes-0.1.3.4 (KatsutoshiItoh)
03:42:54 <Eugleo> Does anybody here know Selda? 
03:44:00 <Eugleo> How can I use the `update` function to replace the whole row? Is it even possible?
03:44:12 <Eugleo> (i.e. without specifying each field/column that should be updated)
04:04:21 <maralorn> fendor: It would work with nixos, but that‘s not an option is it?^^
04:06:15 <fendor> maralorn, no <_<
04:06:58 <hpc> can they not run cabal install?
04:07:19 <Welkin> fucking nixos
04:07:32 <Welkin> nix is also dead to me, and all mac users
04:08:45 <maralorn> <Welkin "fucking nixos"> That‘s a bit rude.
04:09:03 <Welkin> it's really not, based on my experience with it
04:13:15 * hackage minilight-lua 0.2.0.0 - A binding library of minilight for Lua langauge.  https://hackage.haskell.org/package/minilight-lua-0.2.0.0 (myuon)
04:19:27 <merijn> maralorn: The problem is that the "Nix Evangelism Strike Force" is unrelenting and with 0 empathy for any difficulties and immediately waving any criticism/issues as "trivial". And it honestly gets *incredibly* tiresome >.>
04:20:44 <maralorn> merijn: Fair point. I‘d never claim that getting to know nix and the Haskell nix ecosystem is trivial.
04:21:43 <maralorn> In fact I struggled for months because no one seemed enclined to aktually explain how it works.
04:22:22 <maralorn> A general problem in these circles where a lot of documentation focuses on "how to do xy" but not on "why that actually achieves xy".
04:22:33 <merijn> fendor: If it's for students can't you simply establish a "project" cabal file for them to add their assignment too and ensure it already includes the right QuickCheck dependency?
04:23:12 <maralorn> It‘s like: Don‘t confuse the newcomers with technical explanations. Just try to guess the command they need.
04:23:32 <merijn> fendor: Like a skeleton repo they clone and add their exercises too, then you can just say "clone this, use 'cabal repl'/'cabal run'/etc." and call it a day :)
04:23:58 <maralorn> merijn: I only suggested it to fendor btw. because I know that they like to work with nix.
04:24:12 <maralorn> Wouldn‘t just pester anyone with it.
04:24:24 <merijn> fendor: Seems simpler/more reliable than getting a consistent/reliable way to globally install quickcheck across various student machines
04:24:51 <merijn> fendor: Also prepares them more accurately for "real world" coding using Haskell :)
04:24:52 <sheepfleece> Hello! I have lots of threads which execute an action every hour or so. But I want to be able to also wake them up manually. How can I do this? Use timers and a global data structure, which stores them?  
04:25:21 <merijn> sheepfleece: You could use STM to block on multiple events simultaneously?
04:25:55 <merijn> sheepfleece: Like, one TVar that represents the timer wakeup and one that represents a manual interrupt, then you can use STM's <|> to block until the first of those two
04:26:29 <sheepfleece> Thank you! I forgot I could do it this way! How can I organise STM timer then? 
04:28:51 <merijn> sheepfleece: I'm assuming the "every hour or so" means you're not to strict about the exact timing?
04:29:09 <sheepfleece> Exactly.
04:29:53 <merijn> sheepfleece: You can simply plug directly into the GHC event manager via 'registerTimeout' from GHC.Event and register an event that updates the relevant TVar when the timeout expires
04:30:13 <merijn> (and reregisters the timeout, of course)
04:30:31 <merijn> You might need some extra logic to de/reschedule timeouts upon manual interrupt, depending on what exactly you want
04:31:39 <merijn> sheepfleece: Simply "TVar Bool" or something and then "readTVar signalTVar >>= check" (which retries until the TVar contains True) effectively blocking until you "writeTVar signalTvar True"
04:31:44 <merijn> (from the timeout)
04:32:33 <sheepfleece> I think storing in TVar custom data type so I can distinguish between different interrupts.
04:32:38 <merijn> "(Left <$> (readTVar signalTVar >>= check)) <|> (Right <$> (readTVar manualInterrupt >>= check))"
04:33:16 <merijn> sheepfleece: See, the great thing about STM is that you can just use <|> to block on two separate TVars and check which one actually finished (Left vs Right in this example)
04:33:29 <maralorn> Is there somewhere a comparision table between IORef, MVar, TVar, STMVar, STVar (I am starting to make them up now, but there are a lot …)
04:34:21 <merijn> maralorn: I don't think so?
04:34:41 <merijn> Also, comparison along which axis? :p
04:34:52 <merijn> And you forgot STRef ;)
04:35:30 <maralorn> merijn: Well a long the when to use what axis.^^
04:35:58 <maralorn> I was actually surprised to learn that IORef is threadsafe.
04:36:17 <sheepfleece> Oh, I should think about how to prevent a possible dead lock when both of them shoot at the same time, ..., I guess I should just always create a timeout with a new TVar inside.
04:36:20 <merijn> Else it'd be rather useless :p
04:36:45 <merijn> maralorn: STRef already can do everything IORef can do in a single threaded setting
04:37:06 <merijn> (Well, depending on your definition of everything...)
04:41:07 <Ariakenom> sounds like a channel might fit instead of TVar Bool?
04:41:20 <maralorn> Okay, so STRef, if you want to run it pure, IORef is the go to becaus quickest, if you need a semaphore use MVar or chan and when you need the ability to make custom atomic actions use STM with TVar and TChan?
04:41:41 <merijn> maralorn: Approximately
04:42:00 <merijn> maralorn: Note that MVar's are also useful for blocking
04:42:21 <maralorn> sheepfleece: Should the threads act twice when both events happen at the same time?
04:42:26 <merijn> So they're also useful to manage ownership in concurrent settings
04:43:47 <Ariakenom> I would have stm as go to for concurrent stuff because its easy
04:47:47 <merijn> "It Depends"
04:48:30 <merijn> STM is great for some things and not for others
04:48:36 <sheepfleece> Now, they should not.
04:48:40 <sheepfleece> *No
04:49:40 <merijn> The GHC STM implementation is great at: fine grained transactions/short-lived transactions. So having 1000s of tiny transactions will perform *great*, especially at low contention
04:49:57 <merijn> STM *sucks* at massive and/or highly contended operations
04:50:21 <merijn> It also suffers from stampeding herd and fairness issues
04:50:42 <merijn> MVar guarantees fairness, TVar and TMVar do not
04:51:53 <sheepfleece> Is there a practical difference between `Has` typeclass which will deconstruct my parametrize, and Tagless Final, which will parametrize my ReaderT?
04:52:21 <sheepfleece> Oh, parametrize my Environment, I meant that.
04:53:02 <Ariakenom> but im fine calling it a go to because implementing at that point requires some expertise. at which point you dont need a go to.
05:05:50 <Ariakenom> I once suggested a stm solution with a stampede issue here. But the MVar solutions tried were more complicated, had deadlocks and other issues. I had a working MVar solution with better performance but it required more to understand and maintain, so I suggested stm.
05:06:04 <fendor> merijn, I already provide a project template for the local machines, but the submission is on a remote machine where the project is not available
05:06:25 <fendor> maralorn, I like the idea in general, I jsut have no control over the machine :(
05:14:02 <nil> is there a reason to use  case m of (# s, a #) -> ...  over  let (# s, a #) = m in ...  ?
05:14:10 <nil> e.g. in https://hackage.haskell.org/package/base-4.14.0.0/docs/src/GHC.Base.html#bindIO
05:29:15 <maralorn> Are TVars more expensive than MVars?
05:30:05 <Ariakenom> maralorn: It depends :)
05:32:29 <maerwald> maralorn: "From fastest to most flexible, the three types of mutable referencesin Haskell are IORef, MVar, and STM."
05:32:39 <maerwald> from https://www.goodreads.com/book/show/32298390-haskell-high-performance-programming
05:33:25 <tdammers>  but... but...
05:33:32 <tdammers> ForeignPtr, Ptr, ...
05:33:57 <Ariakenom> anything I would say about the performance would be from merijn so I will just try to summon him 
05:40:49 <merijn> maerwald: Honestly, bogus
05:41:02 <merijn> maerwald: For most workloads TVar seem to be much, much faster
05:41:15 <merijn> At least in the (micro)benchmarking I've done
05:53:21 <pie_> "a tool that trades off correctness for convenience might overall produce a more correct ecosystem than a more correct but less convenient alternative, if programmers end up avoiding the latter. "
05:53:28 <pie_> this feels very true but i hate to admit it :)
05:53:30 <pie_> * :(
05:55:13 <maerwald> is stack more correct or more convenient?
05:55:42 <pie_> dunno havent used it and dont care to :D
05:55:50 <pie_> or at least
05:55:53 <pie_> not yet anyway
05:56:09 <hpc> cabal's implemented enough of its features that it's perhaps neither at this point
05:56:27 <pie_> ^
05:56:32 <hpc> certainly it's less convenient when people don't package for cabal as well
05:56:41 <maerwald> ime, it has led to library authors to not care about their dependency bounds and worse quality of .cabal files overall
05:56:46 <hpc> i have seen plenty of packages where all the hackage docs say is "go look at stackage"
05:57:03 <pie_> oh theres docs on stackage that arent on hackage?
05:57:07 <pie_> good to know
05:57:08 <hpc> when i see that, i question if it's going to build at all outside the developer's workstation
05:57:43 <maerwald> so I'm not sure I agree that convenient tools produce more correct ecosystem. I would actually claim the opposite is true
05:58:15 <maerwald> When your tools don't shield you from things anymore (like API breakage), you're forced to be more careful
05:58:23 <pie_> i wouldnt want to argue too hard on that, im leaning in your direction too, but i think the bottom line is the amount of people you can amass that are fixing stuff
05:58:41 <pie_> everything is a popularity contest, meh :P
05:59:02 <merijn> hpc: Most of those packages do, in fact, have docs on hackage, weirdly enough :p
05:59:10 <maerwald> API breakage in e.g. Go (at least a couple years ago) was very very rare, because there was not enough tooling or any semver standard to shield you
05:59:10 <pie_> ive again regressed to prototyping something in python because im not good enough at haskell yet
05:59:22 <maerwald> so authors would lose their sleep over breaking API and rather create a new library
05:59:29 <pie_> hm
05:59:31 <juri_> I've taken the approach of using make to invoke cabal for regular uses, then using stack for profiling builds. this way i test against the latest version of things, and can very simply profile my code with a different stack.
05:59:48 <merijn> juri_: Why stack for profiling builds?
05:59:52 <merijn> juri_: That seems weird
06:00:21 <merijn> Like, why not just make profiling build with cabal if you're already using it
06:00:28 <juri_> merijn: it just makes it easy. one command, rather than figguring out how to get cabal to manage both profiling and non-profiling versions of my dependencies.
06:00:58 <maerwald> juri_: but stack is worse at that
06:01:03 <merijn> juri_: v2-build got rid of all that, though?
06:01:07 <maerwald> it doesn't separate profiling from non-profiling build afair
06:01:20 <juri_> the project i'm working on has an executable, a library, and depends on a library i maintain on hackage.
06:01:25 <merijn> juri_: Like, you just do "cabal v2-build --enable-profiling" and you're done (or just regular build if you have 3.x or later)
06:01:48 <juri_> maerwald: sure, but it doesn't know about the non-profiling build, and cabal does not have to rebuild every time.
06:02:16 <maerwald> juri_: it shouldn't rebuild, because those are in different directories
06:02:24 <merijn> juri_: cabal only builds twice: once for non-profiling dependencies and once for profiling dependencies
06:02:48 <merijn> maerwald: If you use "cabal run" it's not quite as simple, although it has some detection to avoid repeatedly rebuilding in that case
06:03:21 <maerwald> yes, run is a mess
06:03:28 <maerwald> it thinks it needs to rebuild, but then doesn't
06:03:29 <juri_> merijn: sure, but i don't want to throw away and rebuild my dependencies. that's a lot of compiling.
06:03:37 <merijn> juri_: It doesn't throw them away
06:03:51 <juri_> so it will keep both trees?
06:04:16 <merijn> juri_: With v2-build it will keep both the profiling and non-profiling versions in the global store, yes
06:04:50 <merijn> So any rebuilding is limited to only your specific code, not your dependencies
06:04:55 <juri_> I'm checking now. ;)
06:05:13 <juri_> wow. and that completely failed.
06:05:27 <merijn> juri_: That was one of the problems with v1-build, since you could only have 1 copy of a package installed, it'd break if you didn't build the profiling version right away
06:05:28 <juri_> SO.
06:06:14 <juri_> Codec/Compression/Zlib/Stream.hsc:104:1: error: Could not find module ‘Foreign’ Perhaps you haven't installed the profiling libraries for package ‘base-4.12.0.0’?
06:06:27 <juri_> so yeah, cabal does a bad job of this.
06:07:45 <merijn> juri_: Wait, what
06:07:58 <merijn> How do you not having profiling versions of base? Those ship with GHC
06:08:07 <merijn> juri_: cabal can't compile base
06:08:20 <merijn> juri_: Sounds like your GHC installs is messed up
06:08:30 <juri_> these are the current debian packages.
06:08:50 <merijn> juri_: I'm guessing debian ships GHC and it's profiling libraries separately because "reasons"
06:09:02 <merijn> (Because I don't know why else you'd be missing those)
06:09:46 <merijn> juri_: tbh, this is the exact reason why I personally avoid (and would recommend avoiding) distro installations of haskell tooling. They all seem to insist on breaking everything in "fun" and "interesting" ways
06:10:12 <merijn> juri_: Stack probably works because stack installs it's own copies of GHC that are not broken :)
06:10:27 <maerwald> the bindists should also have profiling libs
06:10:39 <merijn> Yes, that's what I meant
06:10:46 <merijn> bindists fo' life
06:11:04 <juri_> ok, yeah, that was the problem.
06:11:11 <juri_> neat! ;)
06:12:40 <merijn> juri_: Same kinda thing happens on Arch where pacman only installs the dynamic libraries of GHC/base and the default GHC and cabal invocations build statically, leading to cryptic broken library messages...*sigh*
06:13:09 <maerwald> not many distros have competent packagers
06:14:10 <merijn> maerwald: Sad thing is Haskell/haskell tools always get blamed for it :\
06:15:54 <maerwald> well, they don't make it better :P
06:16:07 <maerwald> supporting haskell libraries on distro level is a nightmare
06:16:34 <maerwald> that is easily solved with rust and go: you can't :P
06:17:31 <merijn> maerwald: cabal actually has lots of stuff built-in to make it easier for packagers to control where everything is put/looked up from. Although I think supporting haskell libraries as distro packages is a mistake anyway
06:18:21 <maerwald> yes, because usually you can only have one version of a library installed
06:19:00 <maerwald> some distros manage to make the package manager aware what ghc version was used to build the lib, but that still doesn't solve the problem that you can have only one
06:19:29 <merijn> Not to mention that having shared dynamic libs for Haskell is a mostly pointless exercise
06:22:17 <merijn> I swear, nobody knows what Haskell2010 even is >.>
06:22:48 <merijn> This is the billionth time I've seen someone on the mailing lists refer to an extension that has not been an extension for over a decade >.>
06:23:16 * hackage cardano-coin-selection 1.0.1 - Algorithms for coin selection and fee balancing.  https://hackage.haskell.org/package/cardano-coin-selection-1.0.1 (JonathanKnowles)
06:39:41 <pie_> its also a lot of work to figure out whats going on <maerwald> not many distros have competent packagers
06:40:35 <pie_> merijn: probably because of outdated blog posts
06:40:48 <pie_> which seems to be The way to learn about haskell
06:41:06 <merijn> pie_: Sure, but we're talking about people intentionally removing parts of the GHC/cabal bindists when packaging for their distro
06:41:29 <pie_> mhhh well ok
06:41:33 <merijn> pie_: So they're doing actively doing extra work that breaks things for users
06:42:55 <juri_> and fixes things. i like having a minimal install. I've been haskelling for 5+ years, and only now have run into that problem. i just worked around it with stack.
06:42:56 <mkru> Sometimes one mistake in the code generates multiple errors. What is the proper order of analysis, from top to bottom or from bottom to top (GHC)?
06:43:28 <lyxia> that's a question that needs a lot more context
06:44:42 <maerwald> Hmm, there is an order in what type errors appear first. So after fixing some errors, you might see more (which were previously ignored by the type chcker). I don't know exactly what it is though
06:45:05 <maerwald> some type errors seem to "short-circuit" a module
06:45:25 <ski> type error slicing would be nice to have, for Haskell
06:45:56 <maerwald> so the way to go would be to fix the most "severe" type errors first, which would allow the type-checker to do more work
06:47:01 <mkru> Ok, as a newbie you got no idea which one is the most severe :)
06:47:20 <tomjaguarpaw> Has anyone noticed optparse-applicative taking a bizarrely long time to build?
06:47:35 <merijn> tomjaguarpaw: Not really?
06:47:42 <ski> a type error slicer would report all the locations that contributed to the error, so that fixing the error requires changing (at least) one of those locations, and no locations are reported that didn't actually contribute to the error
06:47:58 <merijn> mkru: I usually go from start of file to down, but that's pretty arbitrary, tbh
06:48:01 <tomjaguarpaw> It's been building for about five minutes.
06:48:34 <ski> (although, it may be that fixing one of those locations in turn causes other "neighbouring" locations to be flagged for error, some of them also need to be changed, to eradicate the error)
06:48:47 <tomjaguarpaw> It finished. It took about 9 minutes in total.
06:49:10 <mkru> btw. do you declare signatures before defining functions? I have seen some codes where people do it, and some where they do not. What is the rule of thumb? 
06:49:39 <ski> some people seem to prefer to (usually ?) have as few mentions of types as possible ?
06:49:50 <merijn> mkru: I'd say the rule of thumb is "always for top level declarations"
06:50:02 <maerwald> ski: mhh, a type-fixing error map (like a quest: go here first, fight the transformers, then move into the cave)
06:50:03 <ski> but i think it's pretty common to have signatures for all top-level definitions
06:50:09 <merijn> mkru: Although I personally write them for essentiallye verything, even "where/let"
06:50:23 <mkru> merijn: Why?
06:50:25 <merijn> mkru: More signatures also means simpler/clearer type errors
06:50:46 <maerwald> mkru: look at rust code, where people often omit types for bindings. It's just hard to read.
06:50:54 <ski> i sometimes write them for local definitions, especially if they're larger
06:50:57 <merijn> mkru: Because code is read more than it's written. Having a signature written out makes it trivial to see what everything is
06:51:28 <merijn> mkru: In the early days of Haskell every really though "type inference is great, you never have to write types", but imo that's a mistake
06:51:49 <merijn> mkru: If you don't write out the types the reader of your code has to manually run a copy of the typechecker in his brain to see what's going on
06:51:57 <ski> (iirc John Hughes prefers writing few signatures)
06:52:05 <merijn> If you just write it out, you save a lot of time, and additionally get better error messages
06:52:22 <mkru> merijn: ok, I understand, thanks
06:53:01 <ski> some people seem to put an ascription on every `read' call (or similar)
06:53:12 <merijn> mkru: Now, during development I'll sometimes leave them out if they're still likely to change a lot, but the more finished your code, the more type signatures should be written out.
06:53:52 <maerwald> merijn: more controversial: type annotations for lambdas? :)
06:54:01 <merijn> In an entirely unrelated thing. I'm increasingly convinced pattern synonyms are on of the best things since sliced bread!
06:54:11 <ski> maerwald : catching exceptions
06:54:16 <merijn> maerwald: I don't, if it needs a type it should have a name
06:54:39 <merijn> (ironically, I've been mostly eating unsliced bread lately...)
06:55:10 <maerwald> bread and water is all you need
06:55:14 <ski> pattern synonyms are sortof a limited mode & det system for Haskell
06:56:20 <maerwald> merijn: aren't there massive problems with exhaustiveness checks still?
06:56:41 <merijn> maerwald: Define "massive problems" it depends on the complexity of your pattern synonyms and how you use them
06:56:52 <merijn> maerwald: I'm using them for value construction right now
06:56:54 <ski> i would like to be able to export `data T = A | B ... | C ...', but have `A',`B',`C' implemented as pattern synonyms
06:57:00 <maerwald> massive: industrial grade
06:57:19 <merijn> maerwald: No, I mean that simple pattern synonyms have no problems
06:57:31 <merijn> maerwald: If you do complex stuff like "guarded synonyms" then sure
06:57:33 <ski> (obviously, i should also be able to export `data T = E | F ...' at the same time)
06:58:45 <maerwald> merijn: https://git.io/Jf4Bt
06:59:10 <Ariakenom> you can mark exhaustiveness right? although I remember it didn't work for my esoteric case.
06:59:55 <maerwald> My idea was to be able to match on all sorts of things like (BrokenSymlink f)
07:00:06 <maerwald> it didn't work well
07:00:07 <merijn> maerwald: I'm not sure what I'm supposed to glean from that
07:00:33 <justsomeguy> ski: Are you a combinatory logic?
07:00:44 <merijn> maerwald: Those look like pretty arbitrary predicates, which has the exact same issues as boolean guard would?
07:01:13 <ski> "a" ?
07:01:24 <maerwald> Yes, so your pattern synonyms degrade to boolean guards where you end up with a catch-all case.
07:01:36 <merijn> maerwald: In your example yes
07:02:21 <merijn> maerwald: I wouldn't consider "this undecidable case is still undecidable when I use pattern synonyms" a "massive problem", though
07:02:47 <merijn> maerwald: To me "massive problem" means "this solved solution gets broken when you introduce pattern synonyms"
07:03:17 <maerwald> sure, but that makes pattern synonyms much less exciting
07:03:22 <Ariakenom> my case was _ tuples and sums. where (a,b)=(a,(b,())). (whats _ called again?)
07:03:39 <ski> "wildcard"
07:03:46 <ski> "don't care", "anonymous pattern"
07:04:26 <Ariakenom> ski: ha no sry. it was placeholder for a word
07:04:55 <ski> oh
07:04:59 <merijn> maerwald: Well, what I've been doing is having a simple/uniform datatype that's convenient to program against, but painful to construct and wrapping it with pattern synonyms that pretend like I have 7 convenient special case constructors that all map to my single uniform datatype. So my code operating on the datatype is simple with a single general case. But the code creating value has nicely readable 
07:05:05 <merijn> "special case constructors" which is incredibly powerful and pleasant :)
07:06:19 <Ariakenom> ski: im quite sure you know the word. when a 3-tuple is a structural subtype of a 2-tuple.
07:06:31 <Ariakenom> unlike in haskell
07:06:39 <ski> maybe "inductive" ?
07:08:46 <ski> (or "nested" ?)
07:09:52 <Ariakenom> yeah inductive seems right thanks!
07:10:11 <ski> hm
07:10:21 <ski> although, maybe "recursive" would be better ?
07:10:58 <ski> consider the difference between
07:11:25 <ski>   data Vec (A : Set) : Nat -> Set
07:11:28 <ski>     where
07:12:09 <Ariakenom> I think inductive product|sum is terminology though?
07:12:25 <sm[m]> mkru: the ghcid tool shows the topmost errors. I always work on the first one - unless it’s a real head scratcher, then I might look for an easier one further down
07:12:57 <ski>     Nil  :                1         -> Vec A  Zero
07:13:03 <ski>     Cons : {n : Nat} -> A * Vec A n -> Vec A (Succ n)
07:13:07 <ski> and
07:13:53 <ski>   Vec : Set -> Nat -> Set
07:14:08 <ski>   Vec A  Zero    =   1
07:14:23 <ski>   Vec A (Succ n) = A * Vec A n
07:15:28 <ski> in the latter case, a `2'-tuple would be a structural subtype of a `3'-tuple. but not in the former case
07:17:37 <Ariakenom> sm[m]: I usually just look at the linenumber of the type error. I often make stupid mistakes that are obv when scrutinizing the line
07:17:38 <ski> (also, in the latter case, you need to know whether the length/size is zero or not, before you can match on the value. but in the former case, you can match anyway, and doing so will tell you whether it was zero or positive)
07:20:20 <nil> ski: is this induction vs coinduction?
07:21:22 <ski> it's certainly not coinduction
07:21:35 <Ariakenom> ski: I refer to my last question  :)
07:22:27 <ski> the former is an inductive (even indexed) data type. i don't think i'd call the latter an inductive data type
07:23:24 <nil> ah, i see it now
07:24:15 <ski> it's just a recursive function, which computes a type for you
07:27:43 <mkru> I get a feeling that getting user input in Haskell is harder than in other languages. Can anyone help me with this snippet https://pastebin.com/e9pRhXTU I can't get it to work.
07:29:07 <[exa]> mkru: what's exactly wrong with it?
07:29:19 <ski> mkru : `readLn :: Integer' should be `readLn :: IO Integer'
07:29:55 <nil> that last line makes no sense
07:30:14 <[exa]> mkru: in the last line, you are concatenating an IO action to a list
07:30:40 <Ariakenom> ski: I dont really have any dependent typing skills so I'm gonna leave that ball
07:31:02 <mkru> Yeah but this action should return a list
07:31:04 <ski> `:: Krawedz' is redundant. also `wp <- pobierz rozmiar' followed by `return wp' could be abbreviated to just `pobierz rozmiar'
07:31:23 <ski> mkru : [exa] is saying you're missing some brackets in that line
07:31:42 <ski> although, you'd still have a type error
07:32:01 <ski> you need to first do the recursive call
07:33:19 <ski> @type toEnum
07:33:20 <lambdabot> Enum a => Int -> a
07:33:48 <ski> mkru : `krawedz <- readLn :: IO Integer' is wrong, you need an `Int', not an `Integer'
07:34:07 <mkru> but Int is limited
07:34:12 <sm[m]> mkru it can be helpful to get something simpler compiling, and enhance it in small steps (watching ghcid)
07:34:17 <ski> then don't use `toEnum' ?
07:34:40 <[exa]> mkru: your enum is limited to 4, which is quite a bit less than the Int limit
07:35:06 <mkru> Ohh, right in this case Int is fine.
07:35:41 <ski> in any case, with those fixes in place, you don't need the type ascriptions on the `readLn's
07:35:43 <[exa]> mkru: (technical reason: Int maximum is around 2^63 and you can't expect toEnum to work with larger enums)
07:36:19 <nil> [foo] ++ bar  is the same as  foo:bar
07:36:23 * ski idly imagines a Haskell program with a `data' type with more than `2^63' `data' constructors
07:37:20 <sm[m]> data Star { ...
07:37:46 <Ariakenom> sm[m]: yeah that's great advice for learning. one error at a time :)
07:38:53 <sm[m]> That was the only way I succeeded with haskell. Sometimes literally inching forward like a rock climber
07:39:53 <sm[m]> for accelerated learning, you could also watch Hlint in another window
07:43:46 <[exa]> ski: ....Int is not defined that way?!
07:44:10 <ski> hehe
07:51:45 <mkru> Ok, I get it working, however I still do not know why the first one does not work, but the second one works https://pastebin.com/vwX35CMF
07:57:45 * hackage postgresql-syntax 0.3 - PostgreSQL AST parsing and rendering  https://hackage.haskell.org/package/postgresql-syntax-0.3 (NikitaVolkov)
08:05:15 * hackage hasql-th 0.4.0.8 - Template Haskell utilities for Hasql  https://hackage.haskell.org/package/hasql-th-0.4.0.8 (NikitaVolkov)
08:10:46 * hackage postgresql-syntax 0.3.0.1 - PostgreSQL AST parsing and rendering  https://hackage.haskell.org/package/postgresql-syntax-0.3.0.1 (NikitaVolkov)
08:11:32 <merijn> Ah...peak clarity: "map (fmap (flip ($))) cmds"
08:18:02 <Ariakenom> mkru: minimal example is that do {x <- a; return x;} is not the same as do {return a;}
08:19:24 <john20> Hello, I've currently got a function that looks like this :  myFunc :: a -> b -> IO c and I'd like to apply it to IO a and IO b . So far the best that I've managed is to do: join $ myFunc <$> ioa <*> iob . Is there a better way to do that?
08:19:46 <xerox_> :t liftA2 -- not better, just another way
08:19:47 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
08:20:22 <xerox_> still needs the join
08:21:15 <john20> That would still need the join at the end though right? It feels like there should be a function a bit like >>= that works with a function that takes 2 args instead of 1. Can't find anything though
08:23:00 <solonarv> there isn't a built-in one, although it wouldn't be terribly hard to write
08:23:15 <ski> john20 : sometimes i define `infixl 4 <*>>; mamb <*>> ma = join (mamb <*> ma)', and then i can say `myFunc <$> ioa <*> iob <*> ioc <*>> iod'
08:24:35 <solonarv> most of the time I'd probably end up writing something like : do a <- ioa; b <- iob; myFunc a b
08:26:29 <ski> merijn : needs more composition
08:28:12 <john20> Thanks for the help and advice. I'm currently learning haskell and I'm at the stage where I'm trying to avoid do syntax so that I can get a better feel for what is going on. I'll give the mamb idea a go
08:28:18 <ski> mkru : also, repeatedly adding to the end of a list is (needlessly) inefficient
08:28:35 * ski grins
08:30:16 <ski> mkru : anyway, `x <- a; return x' at the end of a `do' is the same as just `a' there (which is different from `return a', as Ariakenom noted)
08:30:49 <ski> mkru : anyway, `x <- a; return x' at the end of a `do' is the same as just `a' there (which is different from `return a', as Ariakenom noted)
08:36:01 <mkru> It looks like you can't have actions in return, but I am not 100% sure.
08:37:19 <solonarv> you can - in fact you can have whatever value you want there
08:37:23 <ski> mkru : `return' is just a regular function, and actions are just a particular type of value. you can pass actions to `return', if you want to ..
08:37:29 <solonarv> it just won't end up getting executed
08:38:23 <ski> `IO'-actions are only executed if they're `main' (or an action entered in the interactor), or if they're being made part of a larger `IO'-action that is executed
08:38:50 <ski> (merely evaluating an action won't cause it to execute)
08:39:30 <mkru> Yes, this a bit different than what I am experienced with in other languages.
08:40:28 <ski> our function `return' isn't really much related to the common `return' command, in other languages
08:40:29 <Cale> Yeah, return v just constructs the action which does nothing except to... return... v
08:40:54 <Cale> So it doesn't have the funky control flow behaviour that return in other imperative languages has
08:41:40 <Cale> If you write  u <- return v  in the middle of a do-block, it will proceed with the next line, and u will be equal to v
08:41:45 * hackage monadic-recursion-schemes 0.1.4.0 - Recursion Schemes for Monadic version.  https://hackage.haskell.org/package/monadic-recursion-schemes-0.1.4.0 (KatsutoshiItoh)
08:42:26 <Cale> So usually you'll never see that, but since the result of an action described by a do-block is the same as the result of the last action in it, return is still very useful there
08:42:38 <ski> `do if ... then return x else blah; ...' is the same as `do unless (...) blah; ...' (`x' is ignored)
08:46:55 <electricityZZZZ> so i read somewhere once (not sure if this is true) is that some/many ghc libraries (and maybe ghc itself) actually provides a haskell interface to underlying code which is written in C/C--/C++,... 
08:47:29 <electricityZZZZ> pardon, meant to say some/many haskell libraries
08:48:08 <electricityZZZZ> so my questions are (1) is this true? and (2) doesn't this mean that those libraries/etc lack the memory safety and type safety guarantees of haskell?
08:49:00 <solonarv> it is true that some libraries work that way, although not as many as you seem to imply
08:49:22 <sm[m]> a minority
08:49:44 <sm[m]> And maybe, yes
08:49:53 <solonarv> note that you don't have to call any actual C code to do raw low-level things, btw
08:50:29 <sm[m]> But it’s a matter of degree, the c lib may be very simple or well tested
08:50:57 <solonarv> % import Foreign
08:50:58 <yahb> solonarv: 
08:51:19 <solonarv> % badPtr = intPtrToPtr 0xDEADBEEF
08:51:20 <yahb> solonarv: 
08:51:26 <solonarv> % peek @Int badPtr
08:51:26 <yahb> solonarv: ; <interactive>:40:1: error:; Ambiguous occurrence `peek'; It could refer to; either `Foreign.peek', imported from `Foreign' (and originally defined in `Foreign.Storable'); or `Control.Comonad.Store.peek', imported from `Control.Comonad.Store' (and originally defined in `Control.Comonad.Store.Class')
08:51:33 <solonarv> % Foreign.peek @Int badPtr
08:51:34 <yahb> solonarv: [Segmentation fault]
08:51:46 <xerox_> haha
08:51:50 <solonarv> see, we can segfault without any external libraries
08:51:59 <solonarv> ('Foreign' is in base)
08:53:33 <Cale> electricityZZZZ: For certain cases, I'd be more confident binding a C library than using nice high-level Haskell code, mostly relating to cryptography libraries where people have spent years looking at possible side-channel attacks and such.
08:54:06 <solonarv> yeah, that's part of it: do you write bindings to a well-tested C library, or do you write a Haskell library from scratch?
08:55:57 <Cale> There exist cryptography libraries written directly in Haskell, but I'm not really sure how confident I'd be that they don't leak private information through timing or space usage.
08:56:29 <Cale> They *might* be just fine, but they're certainly way less battle-tested
08:57:20 <[exa]> almost fine as long as you own the hardware, keep it far away from people with weird gadgets and don't let the crypto talk directly to internet
09:01:09 <tdammers> biggest concerns with doing crypto in haskell are leaking via long-lived RAM and swap, and timing sidechannels
09:01:53 <tdammers> the "long-lived" thing is mainly a concern when you need to reliably forget secrets
09:02:21 <tdammers> that is *really* difficult to achieve in Haskell, because we don't normally get to manage our own memory
09:02:50 <tdammers> correctly implementing the crypto primitives is relatively straightforward in comparison
09:02:59 <electricityZZZZ> crypto is a valid domain of concern
09:03:25 <tdammers> and there's even the advantage that haskell is less subject to undefined behavior (though not entirely)
09:04:08 <electricityZZZZ> i saw some dude complaining about having a hard time writing unsafe in rust, and it left me wondering how the dark corners of unsafe-ish programming behaves in other languages
09:04:31 <electricityZZZZ> i have yet to need to write unsafe code myself,...
09:08:02 <hololeap> I'm reading a lot of people raving about neovim + haskell-mode, but I can't find any sort of tutorial on how to set this up. I've used vim, but never emacs, and it looks to me like haskell-mode is for emacs
09:09:27 <hololeap> Oops, I misread
09:09:37 <hololeap> HIE + Coc + neovim
09:11:14 <justsomeguy> So I've been trying to pick up Haskell for a few months now (maybe six), and nothing is sticking. I think part of this is because unlike other languages I've learned, I took a different approach and have been working through a huge book in a pretty depth-first kind of way. I don't want to give up, but I'm pretty discouraged. What... should I do?
09:11:47 <electricityZZZZ> justsomeguy: i have the same problem. have you tried starting with something simpler, like elm?
09:12:05 <electricityZZZZ> i felt like i understood elm in a few hours
09:12:06 <hololeap> justsomeguy: try writing something useful, or do some online coding challenges. keep going.
09:12:15 <shafox> I am learning haskell, and I have started a project to parse discogs xml dump. I know there are several options to parse. However I am looking for something for a begineer level library that I can use and work on. There is xml library, however I do not find any examples/tutorials for this. xml-conduit seems little advanced or confusing for me. Can someone point me a tutorial or example on how to parse xml with nested-path ?
09:12:29 <hc> justsomeguy: i started with erlang, got to write some real world applications real fast, then started to miss a type system and moved to haskell :-)
09:12:57 <hc> justsomeguy: before that, i tried to write python in a more functional way... easier than a full migration ;)
09:14:34 <hololeap> justsomeguy: solving these challenges with haskell really helped hone my intuition for the language: https://www.hackerrank.com/domains/fp?filters%5Bsubdomains%5D%5B%5D=intro
09:14:58 <enikar> there is a haskellmode for vim, but it is pretty old: https://github.com/lukerandall/haskellmode-vim
09:15:12 <hc> hololeap: that site is terrible... forcing you to create an account
09:15:48 <hololeap> I suppose. I just used oath with my github account
09:16:03 <hololeap> *oauth
09:16:23 <hc> Why has a site to force you into creating an account for no reason, though? (okay, this is a bit off-topic here, granted)
09:16:52 <justsomeguy> hololeap: I definitely like the idea of learning by making small, simple, things. Personally I've had a lot of trouble with the exercises on sites like exercism and codekatas, though. Maybe HackerRank is better.
09:17:37 <hololeap> The reasons for having an account for this kind of site are obvious (tracking your progress, giving you a score). Part of it's gimmick is that it's a way to show off your coding skills and get hired.
09:19:07 <hololeap> Now, as to why they don't allow you to try a particular challenge without logging in/getting ranked, I suppose that's arguably not cool
09:20:55 <Chobbes> shafox: nested-path?
09:20:58 <hololeap> justsomeguy: I found the lambda calculus challenges to be tedious and not very helpful, so you can skip those if you want
09:22:36 <justsomeguy> One thing I'd really like to find is a guide on writing command line applications with Haskell.
09:23:30 <Cale> What aspect of that in particular? Parsing command line options?
09:23:49 <Cale> Or you mean applications which provide their own command line?
09:24:45 <hololeap> or do you mean something that runs in the console with a minimal "gui"
09:24:50 <justsomeguy> I'd like to learn how to manage file IO, read/write from pipes, send signals, and parse arguments. All the stuff you'd usually see in a good unix cli app.
09:25:05 <Cale> ah, okay
09:25:37 <refried_> if I have `m1 :: MonadWriter a m => m x`, and I want to turn it into a `MonadWriter (b, a) m => m x` action, ... can I?
09:25:55 <shafox> Chobbes, as in <a><b><c></c></b><b><c></c></b></a>
09:26:45 * hackage linearEqSolver 2.1 - Use SMT solvers to solve linear systems over integers and rationals  https://hackage.haskell.org/package/linearEqSolver-2.1 (LeventErkok)
09:27:08 <john20> justsomeguy, if you're looking for a relatively nice beginner friendly haskell setup, I'm really enjoying vscode + ghcide. You have to build ghcide yourself, but it's not that hard - stack build, and you also need to use the same stack resolver in your project, but other than that, it's really nice
09:27:14 <Cale> justsomeguy: For file I/O, I mostly recommend starting from using the stuff that's available in the bytestring or text package as appropriate to what kind of I/O you're doing. If you're not doing complicated streaming, that tends to be all you'll need.
09:28:21 <hololeap> refried_: mapWriter or mapWriterT probably
09:28:26 <Cale> There is also http://hackage.haskell.org/package/unix which lets you send signals and such, but obviously if you want your program to also run on Windows, you'll need to do some abstraction.
09:28:51 <Cale> For commandline parsing, I usually recommend optparse-applicative
09:29:08 <Cale> http://hackage.haskell.org/package/optparse-applicative
09:29:31 <Cale> There's a tutorial for that at the github link in the description
09:30:32 <justsomeguy> Maybe I should have just started by reading the library documentation in the first place instead of looking for a guide or deferring learning it until I got far enough in the book I'm learning. It seems manageable.
09:31:08 <justsomeguy> s/I'm learning./I'm reading./
09:31:32 <justsomeguy> Thanks for the pointers. :^)
09:31:42 <Cale> One thing I will say about optparse-applicative that its tutorial doesn't make obvious is that rather than constructing a data structure representing your arguments like the tutorial there does, it's possible to just use some other IO-producing function where the tutorial's style would have used data constructors
09:31:44 <ibloom> What is your normal procedure to switching a cabal v2 project over to profiling?
09:37:07 <dsal> justsomeguy: It's a pretty generic request.  optparse-applicative covers part of what you're asking for.  The rest sounds too vague ("how do I write a program that does stuff?")
09:40:09 <justsomeguy> That's true, it's pretty vague. Maybe I should port a simple file renaming utility that I wrote in python. It just renames files to exclude characters not in a predefined set of good chars.
09:40:18 <maerwald> Cale: another good argument why it isn't really declarative
09:40:41 <dsal> justsomeguy: Yeah, that sounds like a great start.
09:40:46 * hackage monadic-recursion-schemes 0.1.4.1 - Recursion Schemes for Monadic version.  https://hackage.haskell.org/package/monadic-recursion-schemes-0.1.4.1 (KatsutoshiItoh)
09:42:46 * hackage hlint 3.1.1 - Source code suggestions  https://hackage.haskell.org/package/hlint-3.1.1 (NeilMitchell)
09:45:45 * hackage monadic-recursion-schemes 0.1.4.2 - Recursion Schemes for Monadic version.  https://hackage.haskell.org/package/monadic-recursion-schemes-0.1.4.2 (KatsutoshiItoh)
10:16:15 * hackage linearEqSolver 2.2 - Use SMT solvers to solve linear systems over integers and rationals  https://hackage.haskell.org/package/linearEqSolver-2.2 (LeventErkok)
10:29:45 * hackage ihaskell 0.10.1.1 - A Haskell backend kernel for the IPython project.  https://hackage.haskell.org/package/ihaskell-0.10.1.1 (VaibhavSagar)
10:32:53 <timCF> Hello! Are there some really working Haskell client libraries for gRPC? I tried this one, seems not working https://github.com/awakesecurity/gRPC-haskell
10:39:14 * hackage linearEqSolver 2.3 - Use SMT solvers to solve linear systems over integers and rationals  https://hackage.haskell.org/package/linearEqSolver-2.3 (LeventErkok)
10:45:14 <cocreature> timCF: I use that one so it does work :)
10:48:42 <timCF> cocreature Well, in my case there are multiple unsolved issues with this library) It don't like some protobuf options, have bugs with generated namespaces.. these 2 options might be solved by editing proto and generated files, but this one hard to solve manually https://github.com/awakesecurity/proto3-suite/issues/119
10:57:13 <koz_> cocreature: Zomg, we haven't seen you here in ages.
10:59:54 <cocreature> timCF: I seem to be using swagger2 2.4 afaict. although I’ve never tried to compile the Arithmetic example I think so maybe that is broken in our setup as well.
11:01:26 <cocreature> koz_: damn this life stuff that stops me from hanging out in irc
11:03:01 <koz_> cocreature: I KNOW RIGHT? :P
11:04:56 <monochrom> irc vs irl. Just a hamming distance of 1.
11:05:30 <monochrom> Theorem: hamming distance 1 > social distance 2 metres  :)
11:11:32 <koz_> monochrom: Is social distance even a distance metric?
11:11:58 <heatsink> Erdös number is a social distance metric
11:12:11 <monochrom> It surely satisfies the triangle inequality :)
11:17:04 <sm[m]> justsomeguy: also, maybe try a different book, eg
11:17:07 <sm[m]> @where HTAC
11:17:07 <lambdabot> "Haskell Tutorial and Cookbook" by Mark Watson in 2017-09-04 at <https://leanpub.com/haskell-cookbook>
11:17:33 <sm[m]> also, simply study and tweak existing projects of the kind you want to write
11:17:36 <dmwit> Is it? If I should keep 2m from monochrom, and monochrom should keep 2m from koz_, should I keep 4m from koz_?
11:17:49 <electricityZZZZ> so if it is true that real-world haskell involves occasionally dropping into C-family languages, does that mean that focusing on dropping into rust instead of C could provide safety (and one day, speed) advantages?
11:18:22 <koz_> electricityZZZZ: Real-world _anything_ involves dropping into C because C is the lowest common denominator.
11:18:22 <dmwit> No, it does not mean that. Your conclusion may be true, but it does not follow from the premises.
11:18:25 <koz_> For better or for worse.
11:18:37 <koz_> (usually the latter)
11:19:56 <dmwit> (I don't know whether the conclusion is true. I am skeptical. Usually the result of meshing between two systems that guarantee different things is that you get neither guarantee, not that you get both.)
11:20:29 <sm[m]> dropping into C is "easy", dropping into anything more complicated is probably not
11:20:51 <koz_> I would go further. I would say FFI is tricky regardless, unless the languages are very similar.
11:20:55 <electricityZZZZ> well, in my fictitious haskell-rust ecosystem, that may require a redesign of the haskell language to make it more friendly to ownership etc
11:21:02 <koz_> Whether you're going Haskell -> C or Haskell -> Rust or w/e.
11:21:03 <electricityZZZZ> and it might be engineered to FFI to rust from the ground up
11:21:07 <koz_> Differently tricky, but tricky.
11:21:30 <merijn> electricityZZZZ: The problem boils down to "you need an agreed upon interface", C exists and is popular so people support that
11:21:31 <sm[m]> electricityZZZZ: ah well yes if we're redesigning haskell all things are possible
11:21:34 <electricityZZZZ> for instance raskell would try to focus on linear types as much as possible
11:21:44 <electricityZZZZ> and minimize GC dependence
11:21:49 <merijn> And since everyone supports C is much easier/less effort to just call everything else via this stable C ABI
11:22:02 <electricityZZZZ> i don't like C :-/
11:22:06 <dmwit> The question is now too vague to be answerable. "Does some hypothetical language that does not exist work better than Haskell?" Who knows.
11:22:19 <dmwit> The devil is in the details, and you have elided a *lot* of details.
11:22:23 <EvanR> you could define an implement a different FFI
11:22:25 <merijn> electricityZZZZ: Nobody likes C
11:22:30 <tdammers> I like C
11:22:45 <electricityZZZZ> haha ok,... so, it's plausible that a (noveau haskell)+rust ecosystem could work
11:22:52 <electricityZZZZ> i suppose that's all i am asking
11:22:53 <tdammers> but yeah
11:22:56 <EvanR> you want to change haskell too?
11:23:03 <monochrom> Programmers simply assume that over-generalizing their real question is meaningful.
11:23:04 <electricityZZZZ> i think also haskell has enough warts for beginners that it prevents people from learning the language
11:23:10 <tdammers> suppose we could make a language that is better than haskell, would that language be better than haskell?
11:23:21 <sm[m]> electricityZZZZ: you're not wrong
11:23:30 <tdammers> electricityZZZZ: I don't think haskell has particularly many warts, objectively
11:23:48 <tdammers> compared to, say, Java, C++, Python, JavaScript, or pretty much any mainstream language
11:23:51 <electricityZZZZ> whereas rust is maybe not wart-free, but it has minimized warts so much that it is imo very pleasant to get started with
11:24:13 <tdammers> and, idk, but I found Haskell quite pleasant from day 1
11:24:13 <dmwit> tdammers: The hardest part of joining tautology club is the hardest part of joining tautology club.
11:24:46 <EvanR> now the question is, if i want to use C from your better haskell. Do I go through original haskell then through its FFI, or through rust and then its FFI. Easy!
11:24:54 <tdammers> dmwit: the first rule of technicality club is you don't talk, speak, write, blog, broadcast, sign, silently mouth, e-mail, instant-message, or otherwise communicate about technicality club
11:25:11 <monochrom> How dare you compete with the tautology master that is me! :)
11:25:16 * dmwit sets up a technicality club canary
11:25:45 <electricityZZZZ> EvanR: raskell might not prioritize C interop. it's time to try to deprecate C
11:25:49 <dmwit> monochrom: Ah, but don't worry; my tautology is not wise. ^_^
11:26:02 <EvanR> poor C. no respect
11:26:03 <monochrom> I offer you #3 on http://www.vex.net/~trebla/humour/tautologies.html
11:26:12 <monochrom> hehe
11:26:16 <tdammers> EvanR: I said: "I like C."
11:26:37 <sm[m]> electricityZZZZ: it's good to think about how to do better, pretty hard to make it happen of course
11:26:55 <monochrom> Also dmwit, are you sure you did not mistakenly flip the triangle inequality?  Because social distance is basically just a newtype wrapper over Euclidean distance...
11:28:08 <dmwit> Nah, I played a more subtle trick. I redefined social distance on you without explicitly calling it out.
11:28:48 <dmwit> I switched from "social distance is how far apart we are, but now we call it something new" to "social distance is how far apart we're supposed to stay to satisfy our social contract".
11:28:52 * monochrom cries
11:29:08 <dsal> Are we wanting a thing that doesn't act like C but interoperates seamlessly with systems that are written in C?
11:29:25 <mastarija> Is there something like Word4 or Word1? I've seen word package on hackage, but it's deprecated and there's also OddWord package but I'm not sure if that's what I need.
11:29:39 <dmwit> ?quote dmwit Num.*Bool
11:29:39 <lambdabot> dmwit says: ?let instance Num Bool where (+) = (/=); (*) = (&&); negate = id; abs = id; signum = id; fromInteger = odd
11:29:44 <dmwit> There's your Word1 ^_^
11:29:47 <mastarija> I'm trying to read and write to some binary file format and I'm not sure how this is usually handled in Haskell.
11:30:04 <dsal> It's pretty hard to read less than a byte.
11:30:15 <dmwit> For Word4 I'd just newtype wrap Word8, I think.
11:30:45 <mastarija> Yes, that's what I'm doing at the moment
11:30:51 <electricityZZZZ> dsal: some people here are worried about C interop whereas i am not so concerned
11:31:03 <mastarija> I thought there might be a better / more compact way
11:31:07 <koz_> @hackage binary-bits
11:31:08 <lambdabot> http://hackage.haskell.org/package/binary-bits
11:31:10 <dmwit> I think I've also seen a Wordn type that is parameterized by a Nat. But for Word1 and Word4 there will be a lot of overhead, because it has to use something akin to ByteString to ensure it has enough storage independently of the chosen Nat.
11:32:10 <dsal> electricityZZZZ: Oh, you mean where C is gone and Linux has been rewritten in rust and we FFI that instead?
11:32:19 * monochrom going out on a limb to ask the tautological or techncality question --- I am not sure which
11:32:35 <monochrom> How do you plan to use the Word1 type?
11:32:42 <EvanR> if linux were rewritten in rust or in haskell... not sure which to pick
11:32:48 <dsal> It seems weird to call a bit a word.
11:32:51 <eacameron> I'm trying to upload cabal package to hackage and I'm getting `Unknown architecture name 'wasm32'` because my package has a conditional for wasm32 platforms.... Does anyone know why?
11:33:01 <maerwald> EvanR: the kernel?
11:33:34 <EvanR> yes, the thing currently using C conventions to access it, and C is deprecated
11:34:08 <dsal> The rate at which automated tools find bugs in Linux kernel code is pretty impressive.
11:34:27 <ivegotasthma> does anyone here have access to the haskell wiki? 
11:34:29 * monochrom asks this based on insight gain from teaching a data structure course and explaining why one would care.  You don't pick a data structure by "I want a tree", that's an XY problem.  You pick by "I want operations o1, o2, o3 to be efficient, I am OK with sacrificing o4, o5, etc."  IOW you have to make up your mind what you use it for.
11:34:39 <maerwald> EvanR: do you want your kernel to suddenly take 12GB of ram when it's loading a module?
11:34:52 <ivegotasthma> I'd like to submit an SVG version of https://wiki.haskell.org/File:Typeclassopedia-diagram.png because the resolution is killing me
11:36:14 <monochrom> This is why, for example, "how do I represent an infinite set?" is worse than vague. It's completely missing the point.
11:36:18 <EvanR> just write the modules in C and dynamic load ;)
11:37:21 <monochrom> And deserves this tautological answer: "newtype InfinitySet = IS ()".  Since no operations have been specified, you can't observe any difference anyway.
11:38:02 <EvanR> it clearly needs an operation to return the element count so we can verify it's working
11:38:11 <koz_> monochrom has the right of it vis a vis data structures.
11:38:21 <dmwit> monochrom: Disgusting. That exposes the operation of creation, which was not yet demanded. newtype InfinitySet = IS Void is much better.
11:38:37 <monochrom> heh
11:39:32 <monochrom> That goes beyond tautological. It's vacuous. >:)
11:39:48 <electricityZZZZ> well, keep in mind that rust already has reasonable bindings to important C libraries
11:40:10 <monochrom> (I know! I know! Vacuously true is a special case of tautologically true. Perhaps equivalent too if you stretch a bit.)
11:40:55 <electricityZZZZ> but sure, if you want to never worry about the C bindings problem you might have to build on top of like tockOS redox etc, which is admittely strange...
11:41:55 <monochrom> Haskell FFI would need a complete rewrite, at least for the Ptr and ForeignPtr part, if it is to interface with Rust.
11:42:31 <monochrom> Or else you just all-out unsafeDon'tCheckOwnership on the Rust side.
11:42:57 <monochrom> which is, clearly, how most of the Rust standard library is written. :)
11:44:11 * monochrom learned so much from "let me learn Rust by coding up singly-linked list, what could possible go wrong?"  (Answer: the whole notion of linked list.)
11:44:56 <electricityZZZZ> monochrom: yeah i am talking about basically rebooting haskell from the ground up
11:45:11 <electricityZZZZ> monochrom: yeah, exactly, i learned that you almost never need linked lists
11:45:16 <monochrom> I think no one has time to actually do that.
11:45:38 <monochrom> Just look at how people don't even have time to make a nice Windows installer for GHC.
11:45:39 <electricityZZZZ> monochrom: there are 7 billion people, lol
11:45:42 <xerox_> maybe the guy who wrote the haskell interpreter for ioccc
11:45:43 <dmwit> Uh. If linked lists are out, does this mean trees of all kinds are out? Linked lists are sort of a special case of trees. And trees are dang useful.
11:45:55 <monochrom> They only have time for Dependent Haskell research.
11:47:03 <monochrom> If you heavily use Box and RefCell, you can get linked lists and trees done easily. And also defeats the point of learning ownership.
11:47:44 <dmwit> Is the problem that you need sort of a recursive delegation of ownership?
11:47:49 <monochrom> It becomes "learn how to use Rust like you use Haskell"
11:48:15 <dmwit> "Whoever owns node X also owns all children of X" or whatever
11:49:12 * Lycurgus .oO( FP monoculture problems)
11:49:15 <monochrom> No. The problem is a small narrow window of invalid state when you insert a node (for example) and so you are swapping a few pointers.  The pre-state and post-state are valid (in terms of ownership), the intermediate temp state is not.
11:50:20 <monochrom> Eventually the resolution is a lesser-known standard library backdoor that does the pointer swapping for you, and the backdoor is marked as safe.
11:50:40 <monochrom> (whereas user-written pointer-swapping code is marked as unsafe)
11:51:22 <monochrom> See why I said most of the Rust standard library is written with unsafeDon'tCheckOwnership?
11:51:59 <dmwit> Oh, sure.
11:52:07 <manni41234> Hello, I am using QuickCheck for some testing, would like to make some reporting using "trivial", but I get "Variable not in scope". other reporting functions such as collect and classify are usable but not trivial
11:52:40 <dmwit> Why do you believe trivial should be in scope?
11:53:45 <Lycurgus> trivial was conflated with "basic"
11:53:57 <manni41234> dmwit: I imported Test.QuickCheck, saw some examples from lectures that it should be usable
11:54:38 <dmwit> What version of QuickCheck was the lecture tested with? (Perhaps none!)
11:55:11 <monochrom> That is a very questionable source on multiple counts.
11:55:40 <monochrom> I don't mean to say those lectures are bad for learning ideas.  They are great for ideas.
11:55:50 <dmwit> I also consider it possible that trivial was defined in the lecture notes, or mentioned in the lecture as being defined elsewhere without even going in the notes.
11:55:52 <manni41234> I am not sure, just slides from our proff for Monitoring and reporting
11:56:18 <manni41234> so it's not a function from QuickCheck library then?
11:56:28 <monochrom> But they are also very poor for tiny little details like "where to import this function from", "is it even up-to-date", etc.
11:56:41 <dmwit> I don't know. What you have is not very strong evidence that it is.
11:57:10 <dmwit> I do not see it in the few versions of the Hackage documentation that I spot-checked.
11:57:59 <monochrom> Programmers keep forgetting that, until one day when computers become telepathic, you have to get every tiny detail right.
11:58:14 <manni41234> this is in the slides .. i guess i'll try to find something similiar"Instrumental are the QuickCheck combinators:1. trivial 2. classify 3. collect"
12:00:05 <dmwit> You will probably get much better results here if you tell us what you want it to do than if you just tell us its name and nothing else.
12:00:58 <electricityZZZZ> monochrom: what's the technical term for unsafe don't check ownership? i'd like to read about your stdlib comment
12:01:33 <manni41234> here is my snippet, what i want is to quickcheck report number of trivial cases (cases where n is < 10) `prop_ccc_5 n = trivial (\x -> x < 10) $ forAll (generator_positive 1000 2000) $ \x -> claim_c x`
12:01:44 <monochrom> I forgot!
12:02:38 <dmwit> manni41234: Perhaps classify is good enough for that.
12:02:44 <monochrom> But probably used in, for example, the source code of Rust's vector library.
12:03:04 <monochrom> The Rust reference manual may also have discussions.
12:03:45 * hackage encoding 0.8.5 - A library for various character encodings  https://hackage.haskell.org/package/encoding-0.8.5 (swamp_agr)
12:03:56 <manni41234> dmwit: thanks a lot, sorry for my inability to ask properly
12:05:17 <pweids> manni41234: for what it's wroth, there's no mention of trivial (outside a couple of comments) in the QuickCheck source code
12:07:22 <dsal> manni41234: I don't think trivial is a concept, other than an example of how you might use classify.
12:07:48 <monochrom> Pretty sure it's a homebrew definition in the lecture.
12:08:06 <dsal> Or collect...  I can't remember collect vs. classify.
12:08:39 <monochrom> It's classify, don't worry.
12:09:12 <monochrom> This is what's wrong with English, and the whole idea of using English for meanginful names.
12:09:33 <monochrom> There are so many conflicting and overlapping meanings to choose from.
12:10:34 <manni41234> somebody already asked prof and he said that it was in quickcheck until 2.1 but they removed it and he hasn't updated the slides since
12:10:44 <monochrom> Or at least the idea that programmers are in a great position to choose the right diction for their meaningful names.
12:11:38 <Lycurgus> triviality is definitely a concept dependent on that of effort
12:12:11 <monochrom> The selection bias is such that programmers chose to be programmers precisely because they aren't great (even very poor) with English or whatever their natural language is.
12:12:28 <koz_> monochrom: Yes, so much this.
12:12:45 <koz_> I've been dealing with the fallout of this for the last month or so at My Real Life Paying Haskell Job.
12:13:38 <monochrom> At least I was one of them.  I preferred to converse with the computer because conversing with humans was so imprecise, unpredictable, and full of misunderstanding.
12:14:08 <monochrom> (Later, under great guidance from great English teachers, I became good enough --- just look at my Haskell tutorials :) )
12:14:46 <dmwit> mmm
12:14:58 <dmwit> I find the opposite: I find programmers are *much* more precise with their English than non-programmers.
12:15:13 <koz_> dmwit: We've clearly met very different programmers. In writing _especially_.
12:15:23 <c_wraith> But that's not the opposite.  great precision in english is not the same as good communication.
12:15:36 <c_wraith> great precision is often poor communication, in fact.
12:15:43 <MarcelineVQ> ohhoho, I think you mean _far_ more precise. /fakesnarkbutmaybenotreallyfakebutprobably
12:15:50 <dmwit> I don't know. I think you observe that programmers are worse at picking a big-picture story to tell. But the details of the bad story they tell will be very precise.
12:16:04 <dmwit> Right. As c_wraith says.
12:16:24 <monochrom> Well, there is what c_wraith said.  There is also a few lucky ones and a few ones who made a concious effort.
12:17:03 <dmwit> In fact I think this is an experience we have all had: we ask a precise question, and somebody else answers a different question because they thought it was not precise and they should interpret what we want to know instead of what we asked.
12:17:29 <dmwit> And we have probably also experienced the opposite: we are asked a question, and answer that precise question, and the querier gets frustrated because it doesn't address their actual concern.
12:17:48 <c_wraith> I'm very much an example of using english precisely to communicate poorly.  A sentence I once said "I almost had no fun at that party".  I meant something very different from "I had almost no fun at that party", but that's not obvious to the typical listener.
12:18:13 <dmwit> ^
12:19:57 <maerwald> c_wraith: those two things can mean the same
12:20:05 <maerwald> there's an overlap
12:21:14 <monochrom> I'm wondering whether they really overlap, or they don't overlap but most people haven't heard of the 1st form so they just auto-correct to the 2nd form.
12:21:26 <monochrom> or even s/heard/thought/
12:22:00 <monochrom> Right? People suck at modal logic. Haven't even thought of it.
12:22:33 <maerwald> yes, you went to a party, someone spilled beer over your new jacket, you almost had no fun... but then it got better, however you still had almost no fun
12:22:37 <MarcelineVQ> Neccesarily some people suck at modal logic.
12:22:44 <koz_> monochrom: We can safely extend that statement to 'all logic' really.
12:23:01 <koz_> That was hammered home to me _very_ hard when I taught a first-year logic class a few times.
12:23:02 <dmwit> monochrom: The "PAC" in PAC learning is an example of that for me: it wasn't even a thought I could have had until somebody else forced it into my head.
12:23:22 <dmwit> "probably approximately correct" sounds like the first two words are redundant. But they're not.
12:23:52 * ski . o O ( "absence of proof isn't proof of absence", "de re" vs. "de dicto" modality, Barcan formulae, &c. )
12:24:57 <koz_> ski: What's a Barcan formula?
12:25:39 <c_wraith> anyway - my greater point is that precise use of words can easily lead to misunderstanding on the part of an audience that isn't trained to look for that same mode of precision.
12:25:51 <Uniaika> "absence of proof isn't proof of absence" // this, very much, a lot
12:25:54 <MarcelineVQ> that's really meta
12:26:14 <c_wraith> in programming, the audience happens to be trained for and require the same precision.
12:26:21 <ski> ⌜(∀ x. ◻ F x) → (◻ ∀ x. F x)⌝ and ⌜(◊ ∃ x. F x) → (∃ x. ◊ F x)⌝
12:26:27 <ski> koz_ ^
12:26:28 <MarcelineVQ> but which 'that' do I mean
12:26:50 <Uniaika> the sentence ski said is my general stance towards testing
12:26:59 <koz_> ski: OK, thanks. I have to remind myself of what 'box' and 'diamond' mean again.
12:27:15 <Uniaika> I thought box was the end of a proof?
12:27:21 <koz_> Uniaika: Not in this context.
12:27:21 <ski> ⌜∃ x. ◊ F x⌝ is "de re" and ⌜◊ ∃ x. F x⌝ is "de dicto" modality
12:27:26 <MarcelineVQ> Uniaika: that's tombstone
12:27:27 <Uniaika> diamond is the chaos emerald in Sonic, obviously
12:27:56 <solonarv> one of them is "necessarily" and the other is "possibly", IIRC
12:27:59 <MarcelineVQ> box is neccesarily, diamond is may be
12:28:04 <monochrom> Clearly, box is only the beginning of a proof :)
12:28:34 <koz_> solonarv: Yeah, but which is which is the one thing I keep forgetting!
12:28:36 <MarcelineVQ> other modalities exist like,  had always been  vs  might eventually be
12:29:18 <MarcelineVQ> endless options really
12:29:24 <koz_> MarcelineVQ: Logic is like a buffet.
12:29:30 <koz_> Pick the pieces you like, blend em together.
12:29:31 <dmwit> I have an anecdote about precision. When we first got a dishwasher, my partner and I spent a lot of timing asking each other whether the dishes inside were clean. Finally, I said that we would agree that when the door was closed, the dishes were clean, and when the door was open, the dishes were dirty.
12:29:36 <monochrom> Disclaimer: All I know about modal logics I learned from LTL, CTL, and mu calculus.
12:30:01 <solonarv> koz_: surely they are dual, so that if you swap them everywhere, everything still works :p
12:30:14 <dmwit> For once I overcame my programmer training and did not start launching into all the edge cases, like "what about when it is running, and so the door is closed but the dishes are not yet cleaned?" and "what about when we are putting the dishes away, and so the door is open but the dishes are clean?".
12:30:20 <dmwit> But it was an effort of will.
12:30:31 <koz_> solonarv: Yes, I'm sure if I systematically replace 'garbage' with 'delicious hot dogs' and vice versa, everything will still make sense.
12:30:34 <dmwit> And it turned out never to be a problem. She had already understood all of that anyway.
12:30:48 <maerwald> What if there's a time loop and the dishes are always clean?
12:30:55 <maerwald> (possible in programming)
12:30:56 <MarcelineVQ> modern dishwashers have a light on them that shows the dishstate so the error margin is significantly reduced, if the machine has operated properly
12:31:01 <koz_> solonarv: For example: 'GHC's delicious hot dogs collector is well-designed'.
12:31:06 <ski> koz_ : ⌜◻⌝ is necessary/always/henceforth/heretofore/hitherto/everywhere/obligatory/provable/known/believed, ⌜◊⌝ is possible/sometimes/eventually/somewhere/permissible/consistent, in various modal logics
12:31:07 <MarcelineVQ> *iff
12:31:17 <koz_> ski: Thanks!
12:36:23 <ski> ⌜¬ ◊⌝ / ⌜◻  ¬⌝ is impossible/never/nowhere/forbidden/inconsistent
12:39:13 <zeta_0> a while back someone recommended me a book that is similar to real world haskell, but i forgot the name of the book
12:39:56 <ski> i guess ⌜◊ ¬⌝ / ⌜¬ ◻⌝ would be unprovable/unknown
12:40:33 <ski> while "disbelieved" would be the former of these two combinations with negation ?
12:40:57 <ChaiTRex> zeta_0: Programming in Haskell?
12:41:03 <ski> hm, now sure about which book would be deemed "similar"
12:41:07 <ski> @where PIH
12:41:07 <lambdabot> "Programming in Haskell" by Graham Hutton in 2007-01-15,2016-09-01 at <http://www.cs.nott.ac.uk/~pszgmh/pih.html>
12:41:11 <ski> @where HTAC
12:41:11 <lambdabot> "Haskell Tutorial and Cookbook" by Mark Watson in 2017-09-04 at <https://leanpub.com/haskell-cookbook>
12:41:24 <ski> i was thinking, maybe that latter one ^ ?
12:41:32 <monochrom> I think "cookbook" sounds closer to "real world".
12:41:37 <ski> s/now/not/
12:41:47 <monochrom> Hell, on my cynical days I call them synonyms!
12:41:56 <koz_> monochrom: The term 'cookbook' in programming settings always makes me giggle.
12:42:06 * ski asks language sequencer to please not substitute "now" for "not"
12:42:17 <monochrom> We need our "IO cookbook. Literally."
12:42:26 <zeta_0> yes it's this one: https://leanpub.com/haskell-cookbook/read
12:42:27 <monochrom> or "Monad cookbook".
12:42:36 <zeta_0> thanks, i could not remember
12:42:53 <koz_> monochrom: Containg entries like "Async Souflee".
12:43:00 <monochrom> haha that's great
12:43:04 <koz_> Or "Perfect shortcrust iteratee IO".
12:43:34 <monochrom> Do you happen to know what I have in mind? The pun in "IO cookbook, literally", why "literally"
12:43:58 <koz_> monochrom: Sorry, my pun sense never developed.
12:44:26 <monochrom> Nah, probably you just didn't know a little bit of history before you joined this channel.
12:44:55 <monochrom> We used to explain IO to beginners "when you write code like getLine >>= putStrLn, you're writing a recipe"
12:44:57 * ski . o O ( "Casting SPELs in Lisp - A Comic Book" by Conrad Barski at <http://www.lisperati.com/casting_spels.pdf> )
12:45:10 <koz_> LOL.
12:45:13 <monochrom> Hence, IO cookbook. Literally.
12:45:29 * ski notes the mention of "Haskell Version?!" there
12:46:08 <ski> "used to" ? :)
12:47:26 <monochrom> I haven't seen it done lately. But probably it's just because I was busy teaching IRL.
12:47:53 <monochrom> Err, hell, there is a better reason.
12:47:55 <wavemode> a recipe for a burrito
12:48:12 <monochrom> It's because the recipe narrative is superceded by my narrative!
12:49:24 * ski . o O ( "Burritos for the Hungry Mathematician" by Ed Morehouse in 2015-04-01 at <https://emorehouse.wescreates.wesleyan.edu/silliness/burrito_monads.pdf> )
12:50:15 * hackage reflex-dom-core 0.6.0.0 - Functional Reactive Web Apps with Reflex  https://hackage.haskell.org/package/reflex-dom-core-0.6.0.0 (3noch)
12:50:15 <wavemode> that's hilarious
12:52:15 * hackage reflex-dom 0.6.0.0 - Functional Reactive Web Apps with Reflex  https://hackage.haskell.org/package/reflex-dom-0.6.0.0 (3noch)
12:54:28 <sm> ski: high five! I'm stoked that someone other than me mentions HTAC. Now I know I'm not just imaginging it
12:55:17 <ski> @wn stoke
12:55:18 <lambdabot> *** "stoke" wn "WordNet (r) 3.0 (2006)"
12:55:18 <lambdabot> stoke
12:55:18 <lambdabot>     v 1: stir up or tend; of a fire
12:56:33 <sm[m]> excited, inspired, happy
12:57:03 <sm[m]> possibly on fire a little
12:57:40 <ski> oh
12:57:53 <ski> (there's two sm's ?)
12:58:49 <koz_> One has been seized by the Matrix.
12:58:52 <sm[m]> both me, sorry about that. Usually I use this one (Riot client, coming over matrix-irc bridge). The bridge was showing messages out of order just now so I switched to sm
12:59:22 <remexre> is there a way to get GHC to do typeclass search at runtime? I wanna Debug.Trace.trace something pretty deep in generic code, but I don't wanna have to add a bajillion Show constraints everywhere
12:59:53 <wavemode> well, typeclasses don't exist at runtime.
13:00:37 <sm[m]> remexre: you could convert the thing to something showable on the fly
13:00:37 <ski> s/classe//
13:02:14 <sm[m]> I use a traceShowWith :: (a -> String) -> a -> a for that sort of thing
13:02:52 <remexre> sm[m]: it's showable, but since it's behind a bunch of generic parameters, I don't know that in the context
13:03:22 <remexre> or would you mean pass the a -> String around? also probably a no-go
13:04:27 <sm[m]> I mean, if it's a temporary debugging thing, trace (show $ someShowablePartOf foo) foo, or some more elegant variation
13:06:38 <manni41234> I have written these 3 functions https://pastebin.com/x0dVwTP9. Function prop_ccc_3 should use a generator to ensure that only positive integers greater than 1 are generated as test inputs by QuickCheck. It works but I think quickCheck sometimes negative numbers into the function but the function itself just tests forAll property everytime. Is
13:06:39 <manni41234> there a different way I could do this?
13:07:25 <sm[m]> in general if debuggability is important, I'd consider changing types or building helpers to make it easier to (pretty) trace
13:07:35 <wavemode> I'm curious in what context you would be able to know enough to know that a given `a` is showable, yet the compiler does not know that
13:11:29 <dsal> :t Positive -- manni41234 
13:11:30 <remexre> because I haven't splatted the necessary Show constraints around
13:11:30 <lambdabot> a -> Positive a
13:11:59 <dsal> I'd get rid of the second function altogether and not use forAll
13:12:06 <remexre> like the type in the context is (f a n)
13:12:13 <dsal> Just say you property is valid for positive numbers.
13:14:29 <manni41234> I can't change the signature of the function. I tried to use the generator inside the prop
13:23:18 <dsal> You can't change the signature of prop_ccc_3?   That's kind of silly.  I wouldn't write it that way.  You can use ==> though.
13:24:36 <manni41234> yeah, I have no idea why is it that way. We can only use generators and we can't use boolean filter such as ==> .. Prof hates us I think
13:25:57 <dsal> Well, I don't think you need the type definition in the middle of the definition of genPos, and I've never seen <$> spelled `fmap` but it's otherwise OK.
13:26:57 <dsal> Actually, I don't know why you need abs and suchThat...  You could just do   succ.abs <$> arbitrary
13:27:47 <manni41234> the thing is that when I run quickCheck prop_ccc_3, it still receives negative numbers.
13:27:55 <manni41234> i'll change that thanks
13:28:33 <dsal> I don't see how that genPos could produce a negative number.  Are you sure you're running that?
13:30:30 <manni41234> no, the inside of function goes well. But the "n" argument I receive from quickCheck is negative. Basically what I understand is that prop_ccc_3 can receive negative numbers from quickCheck, but the function itself runs another testing "forAll" for only positive numbers
13:31:00 <dsal> Well, yeah, I'd assume it does, but you're ignoring that.
13:31:20 <dsal> If you want it to not receive negative numbers, you have to not tell it that it cn.
13:32:32 <manni41234> and is my understanding correct that quickCheck generates a number prop_ccc_3 with that number, and then all tests are run for genPos? so forAll testing is run multiple times?
13:33:07 <dsal> Yes.  It should run proc_cccx_3 multiple times with different n values (which are ignored).
13:34:59 <manni41234> Ah, okay, thanks for your help. I'll have to ask prof what he actually wants because I think the signature of the function is wrong.
13:35:03 <dsal> I know you're not allowed to do the sensible thing, but the sensible thing is:    proc_ccc_sensible :: Positive Integer -> Bool;  prop_ccc_sensible = claim_c . getPositive
13:35:31 <dsal> Which reduces quite a bit in your actual framework, because then you just have       testProperty "some name" (claim_c . getPositive)
13:37:28 <manni41234> Yeah, that would be a lot easier. The idea is to practice generators. 
13:37:56 <manni41234> `prop_ccc_5 :: Integer -> Property` is another function that 5 should ensure that only test data n within the range of 1000 ≤ n ≤ 2000 are generated by QuickCheck.
13:38:15 <manni41234> I feel like it's not possible without boolean filter ==> 
13:38:36 <dsal> :t choose
13:38:37 <lambdabot> Random a => (a, a) -> Gen a
13:39:38 <dsal> The thing that looks wrong to me is that you shouldn't say `Integer` when you mean `numbers between 1000 and 2000`
13:39:39 <manni41234> this is how I did it https://pastebin.com/yZNpLmsL
13:40:33 <dsal> Yeah.  Notice you can η-duce that, btw.  `forAll (generator_positive 1000 2000) claim_c`
13:40:45 * hackage spacecookie 0.2.1.2 - Gopher Library and Server Daemon  https://hackage.haskell.org/package/spacecookie-0.2.1.2 (sternenseemann)
13:41:05 <dsal> heh, I have to order a new keyborad soon
13:41:07 <manni41234> oh, nice, didn't know that :)  thanks
13:41:33 <dsal> Also, that do block is superfluous.
13:41:48 <dsal> `generator_positive a b = choose (a, b)`
13:42:24 <dsal> `forAll (choose (1000, 2000)) claim_c`
13:42:25 <manni41234> I modified snippet from lectures, just learned about monads today
13:42:58 <dsal> @undo do { k <- choose (a,b); return k}
13:42:58 <lambdabot> choose (a, b) >>= \ k -> return k
13:43:04 <dsal> @. pl undo do { k <- choose (a,b); return k}
13:43:05 <lambdabot> choose (a, b)
13:43:31 <manni41234> do you have an idea how else to do this so it satisfies the requirements?
13:44:30 <dsal> I don't typically do things this way, but it should work.  It's just weird that a requirement is that it must work for all possible integer values as long as it ignores them.
13:44:49 <dsal> The problem is the generator is called *before* that property, and it's already defined for Integer, so it's outside of your power there.
13:45:20 <dsal> You can wrap it with a constraining type (e.g., `Positive`) and do stuff there, but you can't do much given this case.
13:46:08 <manni41234> Okay. Thanks for your help tonight dsal
13:47:53 <EvanR> Hi. Does anyone use a debugger to debug haskell code
13:48:41 <dsal> Seems unlikely.
13:48:42 <remexre> hm, if I have a type like data Annot a f = Annot a (f (Annot a f)), is there a way to make a pattern synonym that matches both Annot and Fix (from Data.Functor.Foldable) ?
13:49:32 <zeta_0> is there something similar to atom's hydrogen package in emacs? it's nice because all i have to do is connect the haskell kernel and ihaskell will work out-of-the-box
13:49:39 <solonarv> EvanR: there is a debugger built into ghci, so presumably *someone* uses it. it's not very popular, though
13:49:43 <remexre> EvanR: ghci works pretty well for most pure code; for effectful code, depends what kind of bug you're trying to find
13:50:10 <ski> remexre : with a type class, perhaps ?
13:50:10 <remexre> (I didn't mean the debugger, I just meant running stuff)
13:50:29 <monochrom> I add Debug.Trace messages when debugging.
13:50:35 <solonarv> same
13:50:36 <zeta_0> i'm currently using emacs-ipython-notebook with ihaskell, but i'm struggling to much to get features like auto-completion to work
13:50:51 <remexre> ski: oh, didn't realize I could put pattern synonyms in typeclasses
13:50:55 <ski> @where DecoratingStructures
13:50:55 <lambdabot> <http://web.archive.org/web/20051126143527/http://haskell.org/hawiki/DecoratingStructures>
13:50:57 <solonarv> well, most of the code I write these days is effectful, so actually I just use putStrLn and friends
13:51:15 <ski> remexre : i meant having a type class constraint on the pattern synonym
13:51:20 <solonarv> remexre: you can't, but you can write a typeclass and then write a pattern synonym that uses methods from that typeclass
13:51:42 <zeta_0> does anyone here even use ihaskell or am i the only one?
13:51:45 <remexre> ski: oh, hm, do you have an example?
13:51:47 <monochrom> But really I test each small expressions to confirm what they really do before I consider them "done" and move on.
13:51:51 <remexre> ^^
13:51:59 <ski> remexre : there is one, in the user's guide, i think ?
13:52:07 <monochrom> I do that even in C.
13:52:23 <EvanR> Yeah I'm aware of ghci and Debug.Trace
13:52:53 <monochrom> I don't understand the "debugging" mindset because it sounds like you simply vomit 500 lines of code before you even ask "what am I doing?"
13:53:16 <EvanR> I just noticed the extensive work required to make debugging technology work. And was curious if the type system + repl approach just makes it a waste
13:54:13 <EvanR> yes when my windows program crashes and gives a memory address or list of registers... it seems incongruous. Am I supposed to use a debugger?
13:54:43 <solonarv> well, apparently if you have one instaled(?) you can attach it to the program(?) or something
13:54:45 <monochrom> OK sure, core dumps and other people's code need a debugger.
13:54:46 <EvanR> it would seem pointless in C++ much less haskell
13:54:57 <solonarv> I clicked the "debug this error" button once, that's all I know :p
13:55:12 <EvanR> if only "debug this error" literally removed the bug
13:55:19 <monochrom> In lieu of a debugger, adding messages at key points can be almost as good.
13:55:42 <ski> remexre : i'd imagine something like `class Unfix t where unroll :: t f -> f (t f)', `instance Unfix Fix where ...', `instance Unfix (Annot a) where ...', `pattern Fixish :: Unfix t => f (t f) -> t f; pattern Fixish ftf <- (unroll -> ftf)'
13:56:06 <monochrom> In fact last time I was trouble-shooting someone else's code, it was C code and I merely used fprintf(stderr) and the mindset of Dijkstra's weakest preconditions.
13:56:08 <solonarv> ski: those classes are already in recursion-schemes btw
13:56:21 <ski> oic
13:56:28 <solonarv> they're named Recursive and Corecursive, IIRC
13:56:46 <solonarv> (and structured a bit differently, using fundeps, but same idea)
13:56:51 <EvanR> so if inspecting registers and runtime state is not a sensible way to debug modern programs, and "printf's everywhere" aside, is there a more modern way to debug things? Maybe it would require again too much labor to create such tech
13:56:56 <monochrom> To some extent I forgot that "debugger" exists because I was in Haskell for too long without needing a debugger.
13:56:57 <remexre> ski: oh, right, forgot view patterns were a thing
13:57:18 <solonarv> ah yeah you may not even need a pattern synonym, perhaps view pattern works already
13:58:32 <remexre> I mean, I want {-# COMPLETE #-} and bidirectionality, so I think I still want the patterns
13:58:35 <solonarv> pattern Roll btt <- (project -> btt) where Roll btt = embed btt
13:58:41 <solonarv> this one's bidirectional
13:59:02 <solonarv> (and already complete by itself)
13:59:29 <remexre> yeah, I'm trying to make it so the Fix/Annot are invisible when matching on the functor inside the Fix/Annot
13:59:45 <solonarv> ah, hm, not sure how doable that is
14:00:33 <dolio> There were other sorts of debuggers in the past, but no one seems interested enough to bring them back.
14:01:12 <monochrom> I propose that history is a suitable debugging paradigm.
14:02:05 <monochrom> When running the program, log history of state changes, maybe function calls and returns, etc.  After you have the log, a browser tool.
14:02:45 <EvanR> that will be a big log if it logs everything
14:02:54 <EvanR> new compression tech will be needed
14:02:55 <dolio> Yeah, a big problem with the debuggers mostly available is that you have to catch things in the act.
14:03:37 <ski> solonarv : yea, but bidi doesn't work for `Annot'
14:04:04 <monochrom> In practice, it sounds like a great university final-year project that, after finishing the 1st version, is abandoned because the student graduates and no one updates it anymore.
14:04:16 <ski> (and yes, i was thinking of writing it with an FD, but decided to keep it simple)
14:04:24 <monochrom> Meaning I'm sure it has already happened a million times all over the world.
14:04:31 <dolio> You can specify to watch for things and the like, but you have to keep going through the execution over and over until you watch for the right thing, or just break down and step through the whole program.
14:04:44 <remexre> ski: oh, wait, yeah; forgot about that (the Annot ctor, that is)
14:05:07 <remexre> hm
14:05:17 <dolio> Even stepping through the program, you might only notice something's wrong after stepping too far, then you can't go back without starting over.
14:06:00 <EvanR> when a crash occurs, trigger a message to send 22 microseconds into the past to begin logging
14:06:18 <ski> hm, i think i read about a Mercury debugger emitting events to a log, which was then parsed into a tree
14:07:11 <monochrom> I thought "developers" had 100PB hard disks and 1TB RAM and 128-core CPUs and 4-head 8K screens, so more than enough resource for comprehensive logging and browsing such huge logs.
14:08:08 <EvanR> actually that gets a lot of milage in web world: each "run" is a self contained request handling with a printable context. If a crash occurs, the context is posted and given the same database the process could even be reproduced
14:08:18 <ski> EvanR : sounds like time-travel debugging
14:08:44 <EvanR> the program is small enough, the run is isolated, you're not expecting a long looping run
14:08:46 <ski> (some such things exist, for Prolog systems, Mercury. also, iirc, Ocaml ?)
14:08:51 <dolio> Another problem is assuming that a crash happens because a mistake was made 22 microseconds ago, but temporal locality has nothing to do with the logical locality that makes the program work.
14:08:54 <dolio> :)
14:09:11 <monochrom> If you prefer running and pausing the program real-time, may I propose that what you are looking for is gdb but with a timing diagram rather than text input and output.
14:09:20 <EvanR> yeah, it's natural to want a mistake to cause a crash "soon"
14:09:29 * ski . o O ( declarative debuggers )
14:09:41 <monochrom> Because chip designers get things done that way. Timing diagrams.
14:09:49 <dolio> No. It's natural to want the debugger to allow you to examine the logical dependencies, not the temporal execution.
14:10:05 <EvanR> ok two different naturals
14:10:30 <monochrom> Natural to want. Maybe impossible to implement.
14:10:31 <ski> (you can mark the part of the output that was incorrect, and it tries to do dependency tracking (with you as oracle for what's expected), to determine where the offending value comes from)
14:10:51 <dolio> Declarative debuggers have been implemented twice (at least) for Haskell.
14:11:04 <monochrom> OK!
14:11:05 * ski remembers Buddha
14:11:16 * hackage reflex-fsnotify 0.2.1.1 - reflex-frp interface for watching files  https://hackage.haskell.org/package/reflex-fsnotify-0.2.1.1 (3noch)
14:11:51 <EvanR> basically printfs and "thinking very hard" has trumped all these efforts
14:12:06 <monochrom> Causality is consistent with the time arrow, mind you.  I was not far off.
14:12:38 <maerwald> I took a time arrow to the knee
14:13:51 <dolio> I think the problem with the efforts was that they weren't integrated into GHC, so they broke soon after someone stopped modifying them to work with each new GHC version.
14:14:31 <EvanR> does ghc change too fast to have such alien tech debugging integrated?
14:14:43 <monochrom> This is why I chalked it up to "it was someone's dissertation therefore it is abandoned".
14:14:46 * ski . o O ( "<shapr> I'm addicted to arrows.  * shapr begins his own paper "\Generalizing Arrows to Spears\"  <shapr> Spears can do anything efficiently, but they have sixty thousand laws they must satisfy, and we haven't actually found one yet.  <raphael> maybe \"Generalizing Arrows to Nuclear Weapons\" would simply be: unsafeInterleaveIO" )
14:15:00 * shapr snickers
14:15:09 <monochrom> haha
14:15:15 <ski> how long ago was that now ?
14:15:18 <shapr> arrows were far more useful than my caricature
14:15:18 * ski forgets
14:15:24 <maerwald> monochrom: either it leads to a startup or to bitrot
14:15:29 <shapr> ski: uh, same year the arrows paper was published
14:15:56 <monochrom> One of the Chinese missiles is named "Celestral Bow".  Actually I am not sure why not "Celetrial Arrow", but meh.
14:15:58 <dolio> It's probably not worse than the other tracing stuff in GHC, but someone would have to shepherd it, presumably.
14:16:00 <shapr> nah, can't be 1998, I didn't get into Haskell until 2000? 2001?
14:16:20 <ski> somewhere around then sounds right
14:16:38 <MarcelineVQ> gosh, that was almost 7 years ago now, time flies like a bow
14:16:38 <ski> (that's when i started hanging around here, and i remember when you said that)
14:16:44 <monochrom> But it is not a nuclear or balistic missile, IIRC.
14:17:00 <monochrom> It's air-to-air for jet fighters IIRC
14:17:08 <shapr> ski: I haven't seen you since EuroHaskell 2003 I think, but I want to visit Europe after the plague has ended.
14:17:17 <EvanR> 1998 was 7 years ago. 1970 was 30 years ago
14:17:39 <EvanR> it's 5 o'clock somewhere
14:17:49 <ski> hm, i remember your unicyle, shapr !
14:18:05 <remexre> hm, is there a way to have a explicitly bidirectional pattern that has a different type in its expression use from its pattern use?
14:18:43 <shapr> ski: I got another one, but haven't purchased another one since 200x or so
14:18:44 <ski> what're you wanting to do now, remexre ?
14:18:56 <dolio> remexre: I don't think it is, but I've wanted it.
14:18:57 * shapr goes back to fighting deriving something
14:19:04 * ski also remembers "scanned-in-avian"
14:19:23 <Heffalump> shapr!
14:19:31 <ski> @get-shapr
14:19:31 <lambdabot> shapr!!
14:19:32 <remexre> ski: expression has a Corecursive constraint, pattern has a Recursive constraint
14:19:37 * shapr APPEARS
14:19:38 <remexre> Annot isn't Corecursive
14:19:43 <shapr> whoa Heffalump! how you doin?
14:20:02 <shapr> I think Heffalump was #haskell member number four or something
14:20:19 <remexre> or really, I just want f ~ Fix for the expression
14:20:45 <shapr> ski: yes, I still have the scannedinavian domains
14:20:56 <Heffalump> hey, not too bad, just dealing with the whole "everyone at home" thing
14:20:58 <Heffalump> yourself?
14:22:42 <shapr> writing Haskell for a living, though also not so much enjoying staying at home forever
14:22:45 * hackage ghc-lib-parser-ex 8.10.0.7 - Algorithms on GHC parse trees  https://hackage.haskell.org/package/ghc-lib-parser-ex-8.10.0.7 (shayne_fletcher)
14:23:31 <Heffalump> nice, I haven't really done that for about 10 years (though we do use F#)
14:24:20 <shapr> Thinking back to the early times of #haskell it's sorta weird to work on a massive Haskell codebase that's mostly just a nifty webapp wrapper around a database.
14:24:28 * ski . o O ( Pseudonym,ddarius,augustss,TheHunter,mmorrow,SyntaxPolice,vixey,ProfTeggy,andersca,esap,... )
14:25:32 <shapr> ski: Pseudonym is still active on twitter, ddarius is mostly offline doing category theory near Seattle, augustss is working for Google X writing his own compilers for FPGA hardware stuff (as usual), SyntaxPolice started his own company that does webform validation
14:25:50 <shapr> andersca went to work for Apple long years ago, and last I heard is still there
14:26:02 <shapr> Esap is also still active on twitter
14:26:09 <shapr> I'm not sure about mmorrow or vixey
14:26:49 <shapr> Heffalump: are you working at ARM still?
14:27:26 <Heffalump> shapr: nope, been at Credit Suisse for 13 years. Moved there for Haskell but then it turned into F# over time (Haskell projects died out, bigger and more durable F# projects appeared)
14:27:36 <shapr> ah, fair enough
14:28:13 <fen> what about type level deriving?
14:28:37 <monochrom> (Do not engage.)
14:28:41 <maerwald> Heffalump: F# scales better?
14:29:13 <Heffalump> maerwald: fits better into a COM/.NET ecosystem, plus easier to debug
14:29:44 <maerwald> Heffalump: do you guys use F*? :>
14:29:45 <fen> i guess you would just have to have the class being derived have associated types mirroring the functions, so that the type level version could be opperated on similarly
14:29:48 <Heffalump> the former was probably the main reason for adopting it for certain projects. The latter may have kept it going.
14:30:05 <Heffalump> maerwald: yes, as it happens. But only very experimentally and recently.
14:30:53 <maerwald> I find this idea of levels of expressiveness as a programming language tech stack that is interoperable (to a degree) exicting
14:31:01 <maerwald> Better than stuffing everything into a single language
14:31:13 <Heffalump> yes, that's a good point
14:31:34 <Heffalump> we wrote an initial prototype of this thing in Idris but then moved onto F*
14:31:43 <maerwald> And F* has an Ocaml extractor too, last I checked
14:31:48 <fen> also, i thought of a good use for levity recursion. basically if you have a hetrogenous container like a tree, then you need the corresponding shape for the type level params. then you want this to have hetrogeneity too, so different kinds being suppled as parameters 
14:32:16 <Heffalump> maerwald: yes, in fact that gets all the attention and the F# extraction is broken. We're having to fix it now.
14:32:17 <maerwald> And they were planning to do a C extractor as well, for their evers project thing (which will probably never finish)
14:32:26 <maerwald> *everest
14:32:37 <maerwald> Oh, that's sad
14:32:56 <Heffalump> well, fixing it is a fun project for one of my colleagues :-)
14:33:52 <fen> i guess then for traversing over the container you end up having to do that at type level too, so type level zippers, and up the lvity 
14:35:19 <maerwald> Heffalump: I did a short F* presentation in an environment of Java developers in automotive industry once. I thought it might be an exciting thing wrt ISO 26262, but I guess it was a little misplaced in the end
14:35:36 <maerwald> Judging from the confused faces
14:35:41 <Heffalump> :-)
14:38:32 <fen> so i need to redo the Convert machinery with associated type families, for derving Traversable for hetrogenous containers
14:40:02 <Guest_14> I cant seem to get haskell to work on my mac. When I type "GHCi" it doesnt load
14:40:16 <fen> im not sure if this goes beyond what is possible using generics, i dont know how they handle heroginatity 
14:40:29 <monochrom> Try "ghci"
14:40:51 <Guest_14> "-bash: ghci: command not found"
14:40:59 <heatsink> How did you install haskell?
14:41:33 <Guest_14> ghcup
14:41:34 <maerwald> Guest_14: source ~/.ghcup/env && ghci
14:42:24 <Guest_14> awesome thank you maerwald
14:42:39 <maerwald> add "source ~/.ghcup/env" to your .bashrc if you use bash
14:43:34 <Guest_14> now my follow up question is where do I save the .hs from my text editor to access from prelude?
14:44:07 <dmwit> Anywhere is fine. You direct ghc to look where you saved it by running `ghci /path/to/thing/you/saved`
14:44:26 <dmwit> Or, from inside ghci, you may `:load /path/to/thing/you/saved`.
14:44:50 <dmwit> In both cases, relative paths are interpreted as relative to the current working directory as always.
14:46:02 <heatsink> If you are working with files that import other files, there is another option for telling it where to find imports.
14:47:42 <Guest_14> wow  I am glad i found this chat ive been trying to figure this stuff out for 20 min, thank you 
15:05:49 <dsal> Most people master haskell within 30 minutes, so you're going to ace it with that head start.
15:08:27 <pta2002> If I have a function a -> Either b c and i have a [a] and want to get a [c] by running the a's within a do block
15:08:43 <pta2002> but short circuit and return b from the function with the do block
15:08:50 <pta2002> if any of them returns b
15:08:52 <pta2002> how do i do that
15:09:38 <solonarv> what type should the result of that whole operation have? Either b [c] ?
15:09:39 <dsal> traverse?
15:09:48 <monochrom> I take it you don't mean type variables a,b,c, you mean you have unspecified but very concrete types A,B,C
15:11:07 <solonarv> yes, traverse is probably what you are looking for.
15:11:16 <ben_m> Is there a {-# LANGUAGE #-} extension with which I can undo any .ghci extensions previously loaded? I have a bunch in there for convenience, but when I use the repl for interactive development that messes up some scripts that shouldn't have those extensions
15:11:32 <ski> `Validation' might also be interesting to know about
15:11:37 <pta2002> solonarv: well it returns Either b d, but you get d from a [c] -> d function so yeah
15:11:40 <pta2002> monochrom: yeah
15:11:49 <pta2002> i'll check traverse thanks
15:12:09 <solonarv> ben_m: I'm surprised you are even running into this, since it's rare for "enable an extension" to break code IMO
15:12:46 <solonarv> ben_m: in any case, you can use ':seti' instead of ':set' to enable language extensions in ghci but not in modules it compiles, IIRC
15:12:51 <solonarv> s/IMO/IME/
15:13:07 <pta2002> dsal: so how'd i use traverse
15:13:23 <ski> pta2002 : `traverse myFunction myList'
15:13:32 <ben_m> solonarv: ambiguous type variable due to overloadestrings in `flip elem "aeiou"`
15:13:47 <ben_m> I'll have a look at :seti, thanks
15:13:48 <ski> where `myFunction :: a -> Either b c' and `myList :: [a]'
15:13:49 <pta2002> ski: and i can do result <- traverse func list?
15:13:53 <monochrom> ben_m: Some of them, but not all.  For example there is a pair MonomorphismRestriction and NoMonomorphismRestriction.  ghc --supported-extensions has a complete list.
15:14:03 <pta2002> oh that seems to work
15:14:05 <pta2002> compiles at least
15:14:18 <ski> pta2002 : if you're already in an `Either b' `do', yes
15:14:39 <dsal> > let evenOnly x | even x = Right x | odd x = Left x    in    traverse evenOnly [ 1, 2, 3, 4] -- pta2002 
15:14:40 <lambdabot>  Left 1
15:14:46 <dsal> > let evenOnly x | even x = Right x | odd x = Left x    in    traverse evenOnly [ 2, 4] 
15:14:48 <lambdabot>  Right [2,4]
15:14:57 <solonarv> ben_m: ah yeah, I forgot about that one
15:15:47 <solonarv> in general for each language extension 'FooBar' there is a 'NoFooBar' extension that turns those features off
15:15:49 <pta2002> i see
15:15:50 <pta2002> thank you
15:16:26 <ben_m> :seti fixed the issue, thanks!
15:16:27 <solonarv> but littering the top of each file with {-# LANGUAGE NoEveryExtensionIDontUseInThisFile #-}is, uh, not great :p
15:16:32 <solonarv> glad to help :)
15:16:47 <monochrom> Oh God, most of them have a No version!
15:16:50 <pta2002> and with this my toy lisp works
15:16:51 <pta2002> yay
15:17:18 <ski> @hackage Validation
15:17:18 <lambdabot> http://hackage.haskell.org/package/Validation
15:17:18 <solonarv> are there any extensions that don't have a No variant..?
15:17:20 <ski> pta2002 ^
15:17:38 * ski . o O ( `NoHaskell98' )
15:18:30 <pta2002> ski: seems to work with just this
15:18:50 <dsal> pta2002: Validation will give you more than just the first failure.
15:18:56 <pta2002> Oo
15:19:02 <pta2002> so i can get a list of all failures?
15:19:05 <solonarv> yup
15:19:26 <pta2002> So instead of getting back an Either a [b]
15:19:32 <pta2002> I get back an Either [a] [b]
15:19:38 <pta2002> well, not either but you get what i mean
15:19:39 <dsal> Something like that.
15:19:42 <dsal> Except Validation.
15:19:55 <pta2002> that's cool
15:27:13 <ski> @type partitionEithers
15:27:14 <lambdabot> [Either a b] -> ([a], [b])
15:30:57 <monochrom> Yeah, it begins to sound like ([a], [b]) is right, Either [a] [b] is a misunderstanding.
15:35:18 <dsal> The goal may be lost in the question.
15:45:33 * ski looks at pta2002
15:45:33 <pta2002> https://pastebin.com/4sQnQGKm can I compact this?
15:45:38 <pta2002> uh
15:45:46 <pta2002> are you reading my mind ski
15:46:48 <Heffalump> runProgram = either (Left . Err . show) run . parse lispexpr ""
15:47:06 <Heffalump> or somethin glike that
15:47:35 <pta2002> @type either
15:47:36 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
15:49:54 <ben_m> Going through Haskell Programming From First Principles exercises to refresh my Haskell, any improvements to make this more idiomatic? https://gist.github.com/bmeinl/4ed9b51f775682137876dd6b912f4321 (16 Lines)
15:56:15 * hackage haskoin-store-data 0.29.0 - Data for Haskoin Store  https://hackage.haskell.org/package/haskoin-store-data-0.29.0 (jprupp)
15:57:15 * hackage haskoin-store 0.29.0 - Storage and index for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-store-0.29.0 (jprupp)
15:58:25 <ski>   isVowel = (`elem` "aeiouAEIOU")
15:58:51 <ben_m> I thought of that, is the section more idiomatic than using flip?
15:58:54 <ski> ben_m : don't use guards in `theBeforeVowel'
15:59:12 <ski> probably depends on who you ask
15:59:13 <solonarv> I'd say it is more idiomatic if the function is usually used infix already
15:59:19 <solonarv> (which is the case for elem)
16:00:00 <ben_m> Oh yeah, the guards are a bit dumb. I had some intuition that they would be, that's why I asked. Thanks.
16:00:15 <ski> ben_m : i'd tell you to use boolean operations like `&&',`||',`not' instead, but ..
16:00:58 <ben_m> theBeforeVowel ("the", c:_) = isVowel c
16:01:32 <ski> yes
16:02:09 <ski> (personally, i'd also get rid of the `$'s ..)
16:03:07 <ben_m> length (filter theBeforeVowel (zip ws (tail ws)))? Or some kind of point free magic?
16:03:15 <pta2002> so Heffalump that worked, so thank you :)
16:03:25 <ski> i see no problem with that. but if you prefer, you could say
16:03:45 <ski>   (length . filter theBeforeVowel) (ws `zip` tail ws)
16:03:49 <ski> or something like that
16:04:07 <ski> @quote aztec
16:04:07 <lambdabot> quicksilver says: zip`ap`tail the aztec god of consecutive numbers
16:04:30 <ski> > (zip `ap` tail) [0,1,2,3]
16:04:32 <lambdabot>  [(0,1),(1,2),(2,3)]
16:04:59 <ben_m> TODO: work through the types to understand how that works
16:05:54 <ben_m> I think your last version is the cleanest, thanks. It's like a point-free section and then a section to prepare the input
16:06:13 <solonarv> > (zip<*>tail) [0,1,2,3] -- you can also spell it like this
16:06:15 <lambdabot>  [(0,1),(1,2),(2,3)]
16:06:16 <ski> not a section, just infix use of an ordinary identifier
16:06:42 <ben_m> s/section/part/g
16:06:59 <ben_m> Didn't mean a Haskell section
16:07:16 <ski> ah
16:08:24 <ski> (some people like to write `f . g x y . h z $ blah', but i usually prefer `(f . g x y . h z) blah' instead. either is better than `f $ g x y $ h z $ blah', though)
16:08:56 <ben_m> I wonder what the reason is behind certain functions generally being used as infix. mathematical ones like `div` make sense to me, but `zip` and `ap` seem arbitrary
16:09:02 <monochrom> I like parentheses.
16:09:10 <ben_m> ski, i see why, good point
16:09:40 <solonarv> `ap` is not used much anymore, so it's not used infix very much either :p
16:10:00 <ben_m> Because you'd use <*> instead?
16:10:03 <solonarv> yup
16:10:10 <wavemode> typing ap infix takes more characters than just typing <*> ...
16:10:24 <solonarv> and that's an infix operator because it's often used like so: foo <$> bar <*> baz <*> quux
16:10:31 <ben_m> yeah
16:11:28 <ski> ben_m : hm, i guess because `flip . zip = (map swap .) . zip' ?
16:12:00 <ski> iow, swapping the arguments of `zip' is the same as swapping the components of the pairs that it outputs
16:12:14 <ski> so, it's "sortof commutative"
16:12:35 <ski> and commutative functions often gets written infix
16:12:47 * solonarv scratches head
16:13:04 <solonarv> really? mostly it's associativity that determines this, afaict
16:13:27 <ski> well, that too
16:14:02 <ski> but it would tend to highlight that both operands are treated "on an equal footing", i was thinking ?
16:14:42 * solonarv nods
16:14:44 <ski> (then there's the inverses (or adjunctions) of (partial applications of) commutative functions)
16:15:24 <ski> hm. now i wonder how common it is with commutative, but not associative, operations
16:15:32 <monochrom> Associative (or nearly enough) operators really make sense being infix.  For the rest, it's as arbitrary as culture.
16:15:38 <solonarv> although this isn't the full story: there are also functions that are commonly used infix simply to match how the thing would be arranged in english
16:15:43 <ski> (arithmetic mean of two would be one example)
16:15:45 <solonarv> e.g. isInfixOf, elem
16:16:07 <ski> yes, i was thinking about how one could rationalize those
16:16:53 <monochrom> In the case of elem and isInfixOf, someone chose their names so that they are puns of English SOV sentences.
16:17:07 <monochrom> In other words, totally nonsense in Korean, for example.
16:17:26 <monochrom> Hence, as arbitrary as culture.
16:18:47 <monochrom> Some big shot chose a notation, then some networking effect perpetuates it.
16:44:24 <zfnmxt> Is there a recording of SPJ's impredicativity talk on Monday anywhere?
17:10:38 <Guest_14> I am looking for someone proficient in haskell to walk through a programing exercise with me via discord, I usually use an online tutoring service but they do not have haskell tutors. I will pay you for your time via Venmo/Paypal.
17:23:37 <hololeap> hc: what coding challenge sites would you recommend that don't force you to create an account?
17:39:15 * hackage monadic-recursion-schemes 0.1.5.0 - Recursion Schemes for Monadic version.  https://hackage.haskell.org/package/monadic-recursion-schemes-0.1.5.0 (KatsutoshiItoh)
17:48:10 <crestfallen> hi I cannot get the 'copier' function to print. I tried adding deriving Show on line 6 however I'm getting the 'no instance' error with suggestion to ' use a standalone 'deriving instance' declaration '. But isn't line 6 sufficient?
17:48:13 <crestfallen> http://ix.io/2lWk
17:48:47 <crestfallen> ps I don't know how to write a standalone declaration..
17:49:46 <crestfallen> * ' standalone 'deriving instance' declaration '
17:50:20 <crestfallen> why is printing so brutal in haskell?
17:53:19 <crestfallen> the error is pasted here: http://ix.io/2lWm
17:53:34 <wavemode> a function cannot derive Show
17:53:38 <wavemode> how would you print a function
17:55:41 <crestfallen> well, printing shit totally baffles me tbh wavemode 
17:57:20 <crestfallen> I tried copier n = print $ replicateM n tick
17:59:10 <crestfallen> (without the deriving clause)
18:00:15 <ben_m> @type replicateM
18:00:17 <lambdabot> Applicative m => Int -> m a -> m [a]
18:00:19 <ben_m> @type print
18:00:20 <lambdabot> Show a => a -> IO ()
18:00:23 <ben_m> crestfallen, follow the types
18:02:19 <ben_m> That's the main thing I got out of typeclassopedia and it's good advice. Might be worth a quick departure from your learning resource of choice
18:03:05 <crestfallen> ben_m thanks but I still don't understand your hint
18:04:45 * hackage network-run 0.2.3 - Simple network runner library  https://hackage.haskell.org/package/network-run-0.2.3 (KazuYamamoto)
18:05:16 <ski> crestfallen : what do you want to print ?
18:06:15 <crestfallen> oh hi ski is that copier function even correct?
18:06:32 <crestfallen> http://ix.io/2lWk
18:06:33 <ski> `copier n = replicateM n tick' or `copier n = print $ replicateM n tick' ?
18:06:43 <crestfallen> the first
18:06:53 <ski> well, what do you want it to do ?
18:06:58 <monochrom> "follow the types" requires one to take types formally (symbolically, as in symbolic logic), not "conceptually", "intuitively", or any of the similar imprecise fuzzy ambiguous handwaving wishful mindset.
18:07:02 <ski> it doesn't have a type error, at least
18:07:11 <crestfallen> just run it in ghci with copier 5 say
18:07:16 <ben_m> Syntactically correct and type correct, but semantically correct is hard to answer
18:07:29 <ski> no, what do you want `copier' to do ?
18:07:49 <monochrom> Fortunately(!), if there is a type error, there is no semantics to discuss!
18:07:51 <ski> it's hard to tell whether it's correct, without knowing what it's meant to express
18:08:12 <ben_m> monochrom, I tried to understand them in all those handwavy mindsets, which was very slow, then followed the types and the intuition came automatically over time
18:09:09 <monochrom> I have come to conjecture that some (many?) people don't have formal capability at all.
18:09:12 * ski . o O ( "Follow the types where they lead. Follow the types where they lead. Follow, follow, follow, follow -- follow the types where they lead." )
18:09:28 <ben_m> except arrows that aren't (->) but i'll just have to spend more time with that
18:09:39 <monochrom> If you have formal capability and one day decide to actually use it, yes a formula is worth a thousand pictures, you fly.
18:09:55 <ski> crestfallen : to run an `ST'-action, use `app'
18:11:33 <srid> > System.IO.Unsafe.unsafePerformIO $ putStrLn "42"
18:11:35 <lambdabot>  error:
18:11:35 <lambdabot>      Not in scope: ‘System.IO.Unsafe.unsafePerformIO’
18:11:35 <lambdabot>      No module named ‘System.IO.Unsafe’ is imported.
18:13:31 <monochrom> yahb can do IO and unsafePerformIO
18:13:48 <monochrom> But I know how to trick lambdabot :)
18:13:56 <monochrom> > putStrLn "<IO ()>"
18:13:58 <lambdabot>  <IO ()>
18:14:32 * ski grins
18:14:50 * ski looks at crestfallen
18:18:22 <crestfallen> << doubly crestfallen ski
18:18:51 <ski> hm ?
18:29:08 <crestfallen> ski I go thrown off by someone sorry
18:30:08 * ski doesn't understand
18:31:57 <crestfallen> forget it thanks kindly
18:32:23 <crestfallen> I'm going over my notes from your help last night
18:32:25 <crestfallen> ski
18:32:29 <ski> oh, ok
18:33:29 <crestfallen> so I got to     replicateM :: Applicative i => Int -> i a -> i [a] ; replicateM n act = sequenceA (replicate n act)
18:34:38 <crestfallen> and I'm trying to use tick to achieve [tick,tick,tick,tick] as per our discussion.
18:35:11 <ski> ok
18:52:10 <crestfallen> ski so considering the member's suggestion to follow the types:
18:52:18 <crestfallen> @type print
18:52:20 <lambdabot> Show a => a -> IO ()
18:52:33 <crestfallen> @type replicateM
18:52:34 <lambdabot> Applicative m => Int -> m a -> m [a]
18:53:24 <ski> ok ?
18:53:37 <ski> (on your case, `m = ST')
18:54:32 <crestfallen> could I (we?) go through the unification as we did last week with (>>= id)
18:55:06 <crestfallen> two weeks ago perhaps :)
18:55:38 <ski> hm, anything in particular you're wondering about, with that ?
18:55:56 <crestfallen> with (>>= id) ? 
18:56:02 <ski> hm, or do you mean, why `m' is `ST', here ?
18:56:27 <crestfallen> no I get that m = ST
18:57:17 <crestfallen> better perhaps if I paste my notes, I edited them and may have bastardized them in the process
18:57:39 <ski> hm, i think i remember talking about `(>>= id)', but i think it was longer ago
18:58:05 <crestfallen> yeah it was over two weeks ago, 3?
18:58:22 <ski> i don't recall. could have been over a month ago, or more
18:58:33 <crestfallen> covid19 time
18:59:20 <crestfallen> in a prison cell so to speak
19:00:11 <crestfallen> let me say that unification is one thing which gives me hope I will eventually understand haskell. really enjoy it.
19:01:24 <ski> are you preparing those notes, now ?
19:02:10 <crestfallen> http://ix.io/2lWv  ski
19:03:17 <ski> `sequence' and `sequenceA' does the same thing, btw
19:03:37 <crestfallen> ok
19:04:03 <ski> oh, seems most of the lines are things i said
19:04:31 <crestfallen> I tried to edit them for brevity but it's not all linear to my mind
19:05:06 <ski> yea, i suppose i often tend to comment on multiple things in parallel, or go off on tangents a bit
19:06:05 <crestfallen> yeah tbh I couldn't follow a lot of it. essentially I just would like to see those examples operate with our app function and mr. Hutton's instances
19:06:11 <ski> (and some things i said were attempts to reiterate some point, or go over it in more detail)
19:07:50 <ski> i don't remember, do you know how `sequenceA :: Applicative i => [i a] -> i [a]' is implemented ?
19:10:15 <ski> (and which examples were you just thinking of ?)
19:11:08 <crestfallen> well, you started off with : 
19:11:16 <crestfallen> > replicate 7 '*'
19:11:17 <lambdabot>  "*******"
19:11:28 <crestfallen> then in the notes, just under that...
19:12:25 <crestfallen> there is ghci> replicate 4 tick
19:12:32 <crestfallen> [tick,tick,tick,tick]
19:13:02 <ski> well, at the top, i suggested tyyiong `app tick 0',`app (liftA2 (,) tick tick) 0',`map (app (fmap even tick)) [0 .. 9]'
19:13:10 <ski> s/tyying/trying/
19:13:24 <ski> do you feel you understand those examples ?
19:13:30 <crestfallen> [tick,tick,tick,tick] of type [ST Int]   ?
19:13:53 <crestfallen> this I understand   `map (app (fmap even tick)) [0 .. 9]
19:14:33 <ski> the `map' is just for running (using `app') the same action, `fmap even tick', multiple times, with different starting/initial states
19:14:54 <crestfallen> yeah I like that example
19:15:29 <ski> (each of those runs is separate, independent, of the others. so those don't affect each other. unlike the examples where we have multiple `tick's in the same action)
19:15:59 <crestfallen> but ski you're saying that:
19:16:20 <crestfallen> replicateM n act == sequenceA (replicate n act)   ,  correct?
19:16:43 <ski> i'd say `=', not `==', but yes
19:17:08 <ski> (you can't really compare functions for equality (using `=='), and therefore not `ST'-actions either)
19:18:09 <ski> however, to make sense of that definition of `replicateM', you should first understand `sequenceA' (which is why i was asking you about it, above) .. do you ?
19:19:15 <MarcelineVQ> What is another good name for ByteString that conveys its purpose without String which seems to confuse some people. ByteChunk? Bytes? Buffer?
19:19:37 <Lycurgus> array?
19:19:38 <monochrom> "Buffer" sounds too mutable.
19:19:50 <crestfallen> well, if I could jump ahead for one moment ski ..   in any case I couldn't get copier n = app sequenceA n tick)   to print in ghci. so once again I'm stuck on basic printing stuff.
19:20:07 <MarcelineVQ> arrays tend imply a sort of marshalling or alignment though yeah?
19:20:12 <crestfallen> app (sequenceA n tick)    I meant
19:20:17 <monochrom> "Bytes" is my first thought. (doesn't mean best, but I can't think of any other yet)
19:20:33 <Lycurgus> not to me they don't, just indexability
19:20:54 <monochrom> Have you also considered Blob :)
19:20:56 <MarcelineVQ> Bytes is what I had started with already so that's a good sign
19:21:18 <MarcelineVQ> hmm blob
19:21:18 <Lycurgus> bag o bytes is fugly
19:21:48 <ski> crestfallen : i still don't know what you wanted printed, there
19:21:52 <monochrom> For striking fear into programmers' hearts about "this is really arbitrary data", there is nothing like "Blob" >:)
19:22:52 * ski 'sn't too happy about the "binary"
19:23:49 <monochrom> Perhaps someone should ask "very concretely, what do you want 'copier 5' to print?"
19:24:03 <crestfallen> I was trying to get two functions you brought up in our chat, sequenceA and replicateM, to run in *any fashion* using the hutton instance of Functor and the app function.   :)
19:24:08 <crestfallen> ski ^
19:24:29 <crestfallen> to get them to print something in ghci
19:24:57 <ski> using `copier n = app (sequenceA n tick)', you ought to be able to test `copier 3 0', in the interactor
19:25:20 <ski> er, sorry
19:25:31 <ski> that should be `replicateM', not `sequenceA'
19:25:49 <crestfallen> thanks! checking..
19:28:19 <crestfallen> success thanks ski. no I can dig into why the use of replicateM was given me print errors..
19:28:24 <crestfallen> now*
19:46:31 <dmwit> MarcelineVQ: MostlyNullsAndControlCharactersTBH
19:53:19 <peli> merijn: while i can appreciate "just doing it," i feel like there is a gap between toying with writing a toy monadic parser and doing something like composing db access and logging or stuff like that
19:55:09 <peli> basically im having trouble wrapping my head around composing lots of different kinds of 'stateful' operations that might be necessary in doing something useful ('tm' again)
20:01:51 <monochrom> dmwit: I think "mostly nulls and control characters" describes tar very well :)
20:02:58 <solrize> @hoogle Eq p => (a -> p) -> [a] -> [[a]]
20:02:59 <lambdabot> Data.List.Key group :: Eq b => (a -> b) -> [a] -> [[a]]
20:02:59 <lambdabot> Data.List.Extra groupOn :: Eq b => (a -> b) -> [a] -> [[a]]
20:02:59 <lambdabot> Extra groupOn :: Eq b => (a -> b) -> [a] -> [[a]]
20:11:12 <ski> @type GHC.Exts.groupWith
20:11:13 <lambdabot> Ord b => (a -> b) -> [a] -> [[a]]
20:13:23 <ski> @let equating :: Eq b => (a -> b) -> (a -> a -> Bool); equating f = (==) `on` f
20:13:25 <lambdabot>  Defined.
20:13:59 <ski> @type let groupOn :: Eq b => (a -> b) -> [a] -> [[a]]; groupOn = groupBy . equating
20:14:00 <lambdabot> <no location info>: error:
20:14:00 <lambdabot>     not an expression: ‘let groupOn :: Eq b => (a -> b) -> [a] -> [[a]]; groupOn = groupBy . equating’
20:14:04 <ski> @let groupOn :: Eq b => (a -> b) -> [a] -> [[a]]; groupOn = groupBy . equating
20:14:05 <lambdabot>  Defined.
20:14:46 <ski> > groupOn toLower "Mississippi"
20:14:48 <lambdabot>  ["M","i","ss","i","ss","i","pp","i"]
20:14:57 <ski> > GHC.Exts.groupWith toLower "Mississippi"
20:14:59 <lambdabot>  error:
20:14:59 <lambdabot>      Not in scope: ‘GHC.Exts.groupWith’
20:14:59 <lambdabot>      No module named ‘GHC.Exts’ is imported.
20:15:05 <ski> oic
20:15:09 <ski> % GHC.Exts.groupWith toLower "Mississippi"
20:15:09 <yahb> ski: *** Parser [source]:; !!! Parser [source]: finished in 0.09 milliseconds, allocated 0.036 megabytes; *** Desugar:; *** Simplify [expr]:; !!! Simplify [expr]: finished in 0.23 milliseconds, allocated 0.128 megabytes; *** CorePrep [expr]:; !!! CorePrep [expr]: finished in 0.08 milliseconds, allocated 0.040 megabytes; *** ByteCodeGen [Ghci4]:; !!! ByteCodeGen [Ghci4]: finished in 0.16 milliseconds, allocated
20:15:48 <ski> hm
20:16:40 <ski> % :q
20:16:40 <yahb> ski: 
20:16:44 <ski> % GHC.Exts.groupWith toLower "Mississippi"
20:16:45 <yahb> ski: ["iiii","M","pp","ssss"]
20:19:09 <dsal> peli: where are you stuck?  I just kept writing code until things I'd heard people talking about made sense.
20:48:31 <solrize> @hoogle (a -> Bool) -> [a] -> [[a]]
20:48:32 <lambdabot> Data.List.Split splitWhen :: (a -> Bool) -> [a] -> [[a]]
20:48:32 <lambdabot> Data.List.Split wordsBy :: (a -> Bool) -> [a] -> [[a]]
20:48:32 <lambdabot> Data.List.Split linesBy :: (a -> Bool) -> [a] -> [[a]]
20:49:08 <solrize> ski yeah, i have to install those extra modules though and my install is already messed up in some way
21:36:08 <sm[m]> MarcelineVQ: I agree with Bytes, seems the obvious short name
21:37:57 <EvanR> Just a Bunch of Bytes (JBOB)
21:38:28 <EvanR> the thing that bytestring is doesn't have enough names yet
21:39:16 * ski . o O ( Meal )
21:41:37 * kaychaks_riot sent a long message:  < https://matrix.org/_matrix/media/r0/download/matrix.org/FwVhUweCbmxQIlNSVczvpAHo >
21:57:37 <Axman6> kaychaks_riot: FYI your message was too long and gut turned into a link by matrix, so most people won't see see what you said (most won't click random links from IRC)
21:58:54 <Axman6> I'm crazy and did read it, have you tried deriving Functor? probably won't work but I'd be keen to see
22:01:24 <monochrom> BLOB = buttload of bytes >:)
22:01:48 <Axman6> Amazon missed an oportunity to name S3
22:03:40 <kaychaks_riot> Axman6: oh I have done the same mistake before. 
22:03:47 <kaychaks_riot> Am using Kmett's zippers to encode a list zipper like newtype ListZipper a = ListZipper { _unlist :: Top :>> [a] :>> a } and now I want to do an fmap (a -> a) -> Top :>> [a] :>> a -> Top :>> [a] :>> a .
22:03:54 <kaychaks_riot> I need some pointers on how to apply f to  all elements to the left and right of the focus while still maintaining the original focus. 
22:03:58 <kaychaks_riot> I could just travel all the way to leftmost and rightmost applying f recursively  and then coming back to the focus as it was before (if I could remember the tooth of the original focus). 
22:04:03 <kaychaks_riot> But am sure there must be a better way
22:04:25 <kaychaks_riot> Axman6:  I've not done deriving functor. lemme try
22:04:52 <Axman6> I doubt it'kll work, since Zipper doesn't have a Functor instance
22:05:00 <Axman6> I'm not sure it can in general either
22:06:15 <lyxia> yeah that representation of zippers seems difficult for that
22:07:48 <Axman6> I feel like it may not be possible actually, since you need to provide AnIndexedTraversal' i s a, you can't actually change the type of the [a] there, because you'd also need a function from b -> a too
22:09:56 <Axman6> so sadly I think the best you can go is grab the index of the focus, rebuild the list and then recreate the zipper. how unsatisfying
22:13:04 <kaychaks_riot> yeah so that's my approach now but its not satisfying as you said
22:21:05 <Axman6> I would bet that edwardk would be able to come up with a clever solution (or prove it's impossible with the preprsentation used)
22:25:31 <Axman6> so the a's in a Coil are in the traversal stored in the Snoc and the function from Jacket i a -> s, I think that bose of those make it impossible to apply (a -> b) to all the a's, since Jacket i is a Functor, then (Jacket i a -> r) is more lof a contravariant functor in a (definitely don't have the language correct)
22:26:04 <Axman6> and given a -> b you can turn a traversal from s to a into one from s to b
23:01:27 <Axman6> s/can/can't/ oops
23:24:59 <limelier> hey :)
23:25:37 <Axman6> afternoon
23:25:46 <limelier> small question for you guys; i've been trying to install haskell-ide-engine off of the AUR for the past day or so, and my third attempt at installing it failed because i ran out of disk space
23:26:12 <limelier> i look, and it seems my ~/.stack/programs directory is now 10 gigs
23:26:52 <limelier> i assume this is mostly build dependencies for HIE that didn't get cleared when the install processes failed for various reasons
23:27:05 <limelier> how would i go about cleaning this up? i'm not sure what's what
23:30:29 <limelier> (snapshots/ is also pretty big, at 5.9gb)
23:37:57 <MarcelineVQ> are you sure that's the same place you run out of space? dunno if it's the case there but quite often when you run out of disk space making things on arch it's temp space, be sure to check if your /tmp is full and you might need to enlarge it
23:38:32 <MarcelineVQ> df -h  is quick way to see what space is being used where
23:46:46 <limelier> yeah, i'm pretty sure it is
23:47:01 <d1xie> How to convice Windows to suggest my application for particular file-formats, e.g. XML? Are there some metadata, which are needed to provide with my application? (relation with channel - application is written in haskell :))
23:47:28 <d1xie> I mean "Open With" in context menu. 
23:47:29 <limelier> https://i.imgur.com/HEQs1US.png 
23:49:42 <limelier> i'm basically looking to see what parts of this directory are safe to delete
23:56:22 <hc> hololeap: tbh, I don't know of any, but I've never used any... I always had real world problems to solve, or in the case of haskell, I did the challenges presented in various papers. i.e., i tried to write my own state monad, or even wrap my head around the existing one. or implement foldl with foldr, ...
23:59:21 <limelier> ok after some googling it looks like it's probably safe to just delete the entire .stack directory
