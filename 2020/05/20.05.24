00:12:44 <winny> hello - why does this code not error out when compiled and run, but errors out when ran from ghci? https://gist.github.com/616a9192a1b7ada7e729724f3b30186b (ghc: <stdout>: hFlush: illegal operation (handle is closed))
00:14:09 <xerox_> winny: must be because ghci uses stdout and doesn't want you to mess with it
00:15:15 <xerox_> winny: yeah, ghc itself tries to use it to print its prompt and when it flushes it out it gets a fatal error since you closed the file
00:16:18 <winny> that makes sense. i was looking at the ghc sources, and wasn't able to pinpoint why it's happening.
00:20:03 <xerox_> winny: I guess https://github.com/ghc/ghc/blob/master/ghc/GHCi/UI.hs#L690 which calls nextInputLine, getInputLine prmpt, which is an haskeline function which writes to stdout
00:20:54 <xerox_> this one: https://www.stackage.org/haddock/lts-15.13/haskeline-0.7.5.0/src/System.Console.Haskeline.html#getInputLine
00:21:17 <xerox_> which uses promptedInput which flushes tdout to start with: https://www.stackage.org/haddock/lts-15.13/haskeline-0.7.5.0/src/System.Console.Haskeline.html#promptedInput
00:25:21 <winny> that makes sense, thanks, so basically don't hClose the standard file handles
00:27:33 <winny>  /b #emacs
00:27:38 <winny> (oops)
01:09:48 <mearcat> Hi!  I'm using optparse-applicative to implement a CLI but I hit a roadblock.  I have an interface of the form `program [-a] [-b [file1]] file2 file3` and I want to be able to parse `program -b file file'` in the sense of "option -b has received no arguments and the two required files were given" (more general, if the parsing could succeed with the
01:09:49 <mearcat> given arguments, I would like to choose that branch).  It this possible?
01:14:41 <Cale> mearcat: Should be...
01:17:04 <phadej> there are no optional arguments in optparse-applicative
01:17:58 <Cale> optparse-applicative's Parser type is an instance of Alternative though
01:18:26 <phadej> yes, you can have separate `flag' (short 'b')` and `strOption (short 'b')` and <|> them together
01:18:44 <phadej> it might work. I recommend not to do that
01:19:11 <phadej> though, infinite backtracking might make it work at the end
01:19:18 <phadej> (--help output will be confusing)
01:21:35 <mearcat> Mh what would you recommend instead?  Use another library for this?  I sadly have no control over how the CLI looks (though I'm willing to sacrifice help texts)
01:22:18 <phadej> https://github.com/pcapriotti/optparse-applicative/issues/67
01:23:03 <phadej> the problem is what `-b -a file2 file3` means, in your case
01:23:35 <phadej> GetOpt in base supports optional arguments
01:24:22 <phadej> i don't remember though if it requires optional args to be glued to though
01:24:33 <phadej> like -j5 vs -j 5
01:25:53 <Cale> It'll show up as (-b | -b ARG) in the help
01:28:10 <phadej> I'll be surprised if it just works, and doesn't disambiguate some case in the wrong way I'd expect as a human
01:28:27 <phadej> please test well
01:31:42 <mearcat> Okay, I'll give it a try.  Thank you two for your help!
01:38:45 * hackage depq 0.4.0.0 - Double-ended priority queues  https://hackage.haskell.org/package/depq-0.4.0.0 (ocramz)
02:02:02 <mearcat> Mh so `flag' Opt1 (short 'b') <|> (Opt2 <$> strOption (short 'b'))` does work for `program -b file file'`, however when I try to do `program -b inputB file file'` I get an error concerning too many arguments
03:13:30 <Tritlo> Is there any way to define a postfix operator so that it doesn't need parenthisis? E.g. I have a function `(^#)` and I want to be able to write `k = True ^#`, but I get a parse error. Works if I write `(True ^#)`.
03:14:11 <xsperry> hi. what is the name of extension that allows accessing all the fields without passing data to them: (Data@{..})
03:17:34 <Tritlo> xsperry: RecordWildCards
03:18:49 <xsperry> that's the one, thanks
03:43:09 <merijn> Observation based on reddit: I swear, dependent Haskell is like a flame to the moths of beginner Haskell programmers >.>
03:43:34 <Rembane> merijn: Does it kill them?
03:43:53 <merijn> Rembane: Well, it definitely burns them like crazy and yet they can't keep away...
03:44:17 <Rembane> merijn: Sounds "fun". 
03:44:55 <Rembane> merijn: They've really found a local maximum.
03:46:02 <Rembane> merijn: Where e.g. Idris and Agda would be much more pleasant experiences for the same kind of programming. 
03:46:10 <Rembane> ...and closer to global maximum
03:46:16 <merijn> Tritlo: I would just *highly* recommend to stop wanting what you want >.>
03:46:55 <Tritlo> they just want a compiler with dependent types but also widespread industry adoption
03:47:24 <merijn> I want a compiler with dependent types, I just don't want a *haskell* compiler with dependent types >.>
03:48:26 <Athas> Hear hear.
03:48:35 <Athas> But every language becomes C++ eventually.
03:49:11 <Rembane> I can definitely settle for Idris with dependent types. 
03:49:20 <merijn> Dependent Haskell is more pain than it's worth and TypeInType is an atrocity
03:49:42 <Rembane> But I'm also happy that someone has tried to do it in Haskell and somewhat succeeded, but maybe we don't need to make it more mainstream.
03:50:00 <merijn> Like, I'm not *entirely* against messing about the Haskell type-level stuff, but many people have extremely poor understanding of the "pain/effort" to "gain" ratio
03:50:05 <Athas> I think I dislike LinearTypes more than TypeInType and its siblings, though.
03:50:15 * hackage pandoc-utils 0.4.0 - Utility functions to work with Pandoc in Haskell applications.  https://hackage.haskell.org/package/pandoc-utils-0.4.0 (Krasjet)
03:50:33 <merijn> Athas: I dislike TypeInType because there's a well established alternative that's far easier to reason about as mere mortal
03:50:43 <Athas> merijn: which alternative is that?
03:50:49 <Athas> Just not doing it?
03:50:51 <merijn> Athas: Infinite hierarchy
03:51:09 <merijn> Athas: Luo's paper on Extended CoC explains it
03:51:22 <merijn> I think Idris uses stratification too?
03:52:09 <merijn> Athas: So values have Type_0, Type_0 has Type_1, etc. until infinity
03:52:39 <merijn> Type_0 just being types, Type_1 being kinds, Type_2 being sorts, and the rest don't have common names, I think
03:53:15 <Athas> That's the usual way of doing it in logic, isn't it?
03:53:20 <merijn> Yes
03:53:30 <merijn> And I think in Coq (and possibly Agda/Idris?)
03:53:50 <Athas> I don't have a good intuition for how that is simpler than the current trajectory of Dependent Haskell.
03:53:55 <merijn> And people have already worked out how to abstract the boring index massaging in tooling
03:54:57 <merijn> Athas: It's mostly an orthogonal issue from dependent Haskell, it just solves the same problem as TypeInType does, but in a way that's easier to reason about for me :p
03:55:08 <merijn> And also more sound, theoretically :p
03:55:52 <Athas> Dependent Haskell will never be sound anyway, so I don't care about that part.
03:55:52 <Tuplanolla> I'm going to challenge your "far easier to reason about", merijn.
03:56:27 <merijn> Tuplanolla: TypeInType often mixes types and kinds and I can't trick which is which, because they're all "the same"
03:56:35 <merijn> s/trick/track
03:56:56 <merijn> It's DataKinds and [Int] all over again
03:57:15 * hackage yeshql 4.1.1.2 - YesQL-style SQL database abstraction (legacy compatibility wrapper)  https://hackage.haskell.org/package/yeshql-4.1.1.2 (TobiasDammers)
03:57:45 <merijn> Tuplanolla: i.e. is it "[Int] :: *" or "[Int] :: [*]"
03:58:15 * hackage yeshql-postgresql-simple 4.1.1.2, yeshql-hdbc 4.1.1.2, yeshql-core 4.1.1.2 (TobiasDammers): https://qbin.io/expand-boat-bu4p
03:59:54 <merijn> The fact that "* :: *" and "* -> * :: *" makes things very confusing, imo
04:00:36 <johntalent> What is haskell normally used for (and by)?
04:00:59 <merijn> With universe stratification you'd get (with * = Type_1) "Type_1 :: Type_2" and "Type_1 -> Type_1 :: Type_2", etc.
04:01:34 <Tuplanolla> Let's say that you have a universe hierarchy and define `id` with the type `forall A : Type@{0}, A -> A`. What is the type of `id id` now?
04:02:57 <merijn> Tuplanolla: Those are two unrelated things?
04:04:03 <Tuplanolla> They are not. Without a mechanism like type-in-type or universe polymorphism, this creates a universe inconsistency error.
04:04:53 <Maxdamantus> I don't quite get how they're stratified in Idris .. I can write some straightforward functions `f : (a: Type) -> (v: a) -> (Type, a)` and `g : (a, a) -> List a` then call them as `g (f Type Int)` and I get back `[Type, Int]` as expected.
04:05:47 <Maxdamantus> presumably that shouldn't be possible if that `Int` term is of that `Type` type.
04:08:26 <Athas> johntalent: originally, writing Haskell compilers.
04:09:47 <Maxdamantus> or maybe a clearer example `g (f Type Type)`
04:11:09 <Solid> johntalent: you might want to check out https://github.com/Gabriel439/post-rfc/blob/master/sotu.md
04:13:19 <johntalent> Solid: nice. thanks!
04:24:50 <merijn> Data.Set.member's arguments are in the wrong order. Change my mind :p
04:32:10 <Philonous> »elem `member` set« reads quite naturally, But I guess you'd more often want to partially apply the set than the key
04:32:37 <merijn> Philonous: Just the past 3 days I've wanted to check a fixed set against many keys like 7 times...
04:32:53 <Philonous> Yes, that seems like a natural thing to do
04:33:05 <Philonous> »map (`member` myset) elements «
04:33:22 <merijn> Philonous: That reads awkwardly, though :\
04:33:33 <Philonous> It's not terrybad, but not as clean as it could be
04:37:04 <Solid> this is the perfect oportunity for you to define a myMember function :>
04:45:31 <Tuplanolla> This is the prefect reason to have a separate notation system, so that your function can have the "more constant" arguments first, while the infix notation has them flipped.
04:46:46 <Tuplanolla> The same problem concerns `-` and `/`. You usually want to subtract a constant amount from some variable.
05:29:46 * hackage splint 1.0.0.1 - HLint as a GHC source plugin.  https://hackage.haskell.org/package/splint-1.0.0.1 (fozworth)
06:06:29 <hungig> hello, i am getting this error `No instance for (MonadFail Parse2)
06:06:31 <hungig>         arising from a do statement
06:06:33 <hungig>         with the failable pattern ‘(I n)’
06:06:35 <hungig> `
06:06:48 <hungig> when i am trying to pattern match in `do` expression
06:07:11 <merijn> hungig: Means the pattern match you're doing is partial
06:07:13 <hungig> the problem is that the pattern match is not exhaustive .. how do I fail this pattern match?
06:07:16 <xerox_> hungig: are you implementing Parse2?
06:07:24 <hungig> xerox_: yes :D
06:07:35 <merijn> hungig: Well, then the solution is to just "implement MonadFail" :)
06:07:42 <xerox_> then I guess you could go ahead with the suggestion implicit in the error! yeah :)
06:07:45 <hungig> merijn: yes, i would like to have something like `fail empty` after thepattern match
06:08:04 <merijn> hungig: GHC already automatically calls fail for partial patterns
06:08:22 <hungig> oh, i thught the fail function was default for monad classes
06:08:31 <xerox_> it only recently changed, very very recently
06:08:31 <merijn> hungig: It used to be
06:08:31 <hungig> xerox_: are you doing the AFP course too?
06:08:40 <xerox_> hungig: nope, what's that?
06:08:41 <merijn> hungig: But not all monads have a sensible notion of failure
06:08:53 <hungig> xerox_: that you knew about Parse2 :D
06:09:18 <merijn> hungig: So recently GHC changed things to put "fail" into the MonadFail class and now (trying to) use a partial pattern in do notation will add a MonadFail constraint too
06:09:31 <hungig> oh, i am stupid, it's in the error message ..
06:09:41 <xerox_> hungig: I see, mine was just a question of whether you were an implementor or user of the monad, whatever its name or story
06:09:43 <hungig> i thought i met a fellow student doing the same assignment 
06:09:44 <hungig> mb 
06:09:47 <xerox_> np
06:10:31 <merijn> hungig: So all you really need is "instance MonadFail Parse2 where fail errMsg = ???"
06:10:33 <hungig> merijn: ah, i see. I was reading a book that mention that fail was a hack but it it's implemented and he didn't mention it anymore in the book
06:10:35 <hungig> thanks
06:10:48 <kuribas> Isn't a type error the same as an uninhabited type?  For example, unifying String with Int gives the empty set.
06:10:58 <merijn> hungig: This change is very recent, so probably the book wasn't updated :)
06:11:15 <xerox_> I think it is just the very latest ghc release
06:11:24 <merijn> 8.8 switched the default
06:11:32 <xerox_> ah so the last two
06:11:39 <merijn> MonadFail has been around for several releases, but 8.8 flipped the final switch
06:11:44 <hungig> yeah, i just implemented the fail as `fail _ = empty`
06:11:46 <hungig> thanks
06:11:50 <hungig> it compiles now
06:12:46 <kuribas> Unification is intersection right?
06:13:25 <kuribas> For example, unifying "a" with "Int" is the intersection of all types with "Int"
06:20:28 <kuribas> Which is just Int
06:20:47 <berndl> I wouldn't call it intersection.
06:22:00 <hungig> when is the fail function called in the pattern matching in do notation? is it called always if the pattern match is not exhaustive?
06:22:17 <merijn> hungig: It's called if the pattern fails
06:23:01 <kuribas> Why couldn't you unify Int and String?
06:23:01 <xerox_> https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-470003.14
06:23:02 <merijn> hungig: So "Foo a <- blah" translates to "blah >>= \x -> case x of Foo a -> ...; _ -> fail "Non-exhaustive pattern"'
06:23:15 <xerox_> right there in the box you see how fail appears
06:23:26 <merijn> hungig: With '...' being "whatever comes after that line"
06:23:43 <kuribas> Int U String = Void?
06:23:45 * hackage tidal 1.5.1 - Pattern language for improvised music  https://hackage.haskell.org/package/tidal-1.5.1 (AlexMcLean)
06:23:56 <kuribas> erm U isn't the right operator
06:24:05 <xerox_> funny they used let and you used case for the desugaring
06:25:20 <hungig> merijn: i have this simple parser https://pastebin.com/FM8ZpRVZ, when I try `parse nat "123" I get an instance of I 123, but if trying `parse int "123"` just fails and returns nothing
06:26:46 <merijn> hungig: The "char '-'" isn't optional
06:27:02 <kuribas> So if I have an "x" which is both "Int" and "String", then it means x doesn't exist, or x :: Void right?
06:27:41 <hungig> merijn: hmm, but the <|> operator should make it optional
06:27:56 <Philonous> kuribas, Unification is the meet in the subsumtpion lattice, intersection is the meet in another lattice
06:28:00 <merijn> hungig: That's...not what you wrote
06:28:17 <merijn> hungig: The "<|> nat" only applies to the last "return" line
06:28:24 <merijn> (and thus never fires)
06:29:04 <Philonous> kuribas, Your unification variable x does not unify with Void, since Void :: Type is another type entirely 
06:29:31 <hungig> merijn: does it mean i have to some brackets around?
06:29:36 <kuribas> Philonous: that makes sense...
06:29:42 <merijn> hungig: For example
06:29:53 <kuribas> Philonous: it's isomorphic to it, but not the same
06:30:46 <Philonous> kuribas, No. Depending on what you're doing, type checking woudl simply fail, since there is no substitution for x that can satisfy all your constraints
06:30:51 <Philonous> would* 
06:31:31 <kuribas> Philonous: how do type checking and type inference relate?
06:31:34 <hungig> merijn: http://www.cs.nott.ac.uk/~pszgmh/Parsing.hs i am using the example from professor Graham Hutton and he has it the same way, without the data constructors
06:32:55 <Philonous> kuribas, I'm afraid I can't give you a good answer to that since I only now the basic principles of it. 
06:33:00 <Philonous> know*
06:33:46 <kuribas> Philonous: type inference with hindley-millner is bi-directional, but type checking not...
06:34:42 <kuribas> for example: (10 :: Int) , 10 has type Num a, then Int must be a subtype of (Num a), right?
06:35:02 <kuribas> So given types must be subtypes of inferred types?
06:36:01 <hungig> merijn: hmm, i changed the indentation and it works now
06:36:13 <hungig> merijn: i should read about the indentation rules i guess
06:36:25 <xerox_> you're probably now using the whole do block as <|>'s first argument
06:38:13 <kuribas> > (10 :: a)
06:38:15 <lambdabot>  error:
06:38:15 <lambdabot>      • No instance for (Num a1) arising from the literal ‘10’
06:38:15 <lambdabot>        Possible fix:
06:38:45 <kuribas> So (10 :: a) fails because "a" is not a subtype of (Num a => a)?
06:39:28 <hungig> xerox_: https://pastebin.com/mAwRiHKa this is the difference. does it mean that in the incorrect verseion, only the return was the argument of <|> instead of the entire block starting with `char '-'`?
06:40:49 <Philonous> kuribas, I'm not sure how valid it is to speak of "subtyping" in this context, but essentially yes. 
06:42:01 <xerox_> hungig: do { char '-'; (I n) <- nat; return (I (-n)) <|> nat }  versus  do { char '-'; (I n) <- nat; return (I (-n)) } <|> nat
06:43:31 <hungig> xerox_: oh, it's clear now
06:43:36 <xerox_> \o/
06:43:47 <hungig> i miss curly braces ..
06:43:49 <hungig> :D
06:44:01 <xerox_> if you look at GHC's sources you see they do spell out the braces!
06:46:30 <xerox_> at least they used to spell them out, that's the style I would often find, can't find an example now O_o
06:47:02 <hungig> as a beginner i can confused really fast by things like this
06:47:25 <merijn> xerox_: Mostly old code by SPJ does that :p
06:47:43 <merijn> hungig: See: https://en.wikibooks.org/wiki/Haskell/Indentation
06:47:57 <merijn> hungig: The rules are fairly straightforward
06:47:59 <xerox_> yeah! do you know where is an example nowadays? randomly browsing doesn't surface one
06:50:50 <hungig> merijn: i used the first example `myFunction firstArgument secondArgument = do` where i have do at the end of the line and then everything indented once but it lead to the problem I had.
06:52:57 <xerox_> there we go, this style https://github.com/ghc/ghc/blob/8bfb021/compiler/GHC.hs#L511-L523
06:53:16 <solonarv> here is the key insight: it does not matter where you place the 'do'. it matters where you place the first thing that follows it.
06:54:15 <hungig> yeah, i understand that it has to be relative to the line where the do is right
06:54:24 <merijn> No
06:54:40 <solonarv> that is the exact opposite of what I just said
06:54:42 <merijn> hungig: It just has to be indented more than whatever indent the line of the do had
06:55:33 <hungig> merijn: this "need to be indented relative to the line that contains the do, not relative to the do itself." is what you mean right?
06:56:15 <merijn> yes
07:04:44 * hackage pandoc-utils 0.5.0 - Utility functions to work with Pandoc in Haskell applications.  https://hackage.haskell.org/package/pandoc-utils-0.5.0 (Krasjet)
07:04:53 <siraben> Is it possible to insert into a sorted list with a tail-recursive function?
07:05:52 <siraben> Using foldl, perhaps?
07:06:10 <merijn> siraben: Why do you care?
07:06:27 <siraben> merijn: stack overflow
07:07:09 <siraben> (not the website)
07:07:37 <merijn> siraben: You've been misguided by information for other languages :)
07:07:57 <solonarv> yeah, you don't want tail recursion for this
07:08:01 <siraben> Ah this is occurring on Elm not Haskell
07:08:08 <merijn> siraben: (GHC) Haskell doesn't *have* a function call stack, so whether a function is tail recursive or not has no direct impact on things
07:08:15 * hackage pandoc-utils 0.5.1 - Utility functions to work with Pandoc in Haskell applications.  https://hackage.haskell.org/package/pandoc-utils-0.5.1 (Krasjet)
07:08:20 <solonarv> ...then why ask in #haskell?
07:09:40 <siraben> Should've kept in mind the runtime systems are different, apologies!
07:09:56 <maerwald> the entire language is different
07:10:24 <maerwald> I don't think they even have the same denotational semantics, do they?
07:11:20 <siraben> Yeah Elm is eagerly evaluated.
07:11:32 <[exa]> elm is eager?
07:11:34 * [exa] disappoint
07:11:48 <dmj`> miso is lazy :) 
07:13:45 <Chobbes> merijn: how so? You mean that everything ends up getting CPS'd behind the scenes so there isn't really a call stack? Don't you still care about tail recursion, though?
07:15:23 <solonarv> no, GHC doesn't even exactly use CPS as an intermediate representation
07:15:41 <solonarv> laziness is the reason there isn't a call stack, and also the reason you don't always want tail recursion
07:17:46 <merijn> Chobbes: Tail recursion isn't really relevant ever. Strictness is and sometimes the only way to get the right strictness is by rewriting to tail call style, but the tail call itself is never really relevant
07:18:07 <Chobbes> I see. Do you have an example, or maybe a jumping off point for better understanding this? I feel like I'm pretty terrible at understanding Haskell performance and would like to know more.
07:18:09 <merijn> Chobbes: Basically in GHC's compilation *all* function calls compile to assembly jumps, rather than CALL instructions
07:18:24 <merijn> @where stg
07:18:24 <lambdabot> http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.53.3729
07:18:32 <berndl> STG uses three stacks no?
07:18:49 <merijn> Chobbes: That paper is a good starting point for the basics of "how do you compile lazy FP to Intel CPUs" :)
07:18:57 <solonarv> there's an evaluation stack IIRC, what others are you thinking of?
07:19:06 <merijn> berndl: I think you can reduce it to two and then merge those into one
07:19:21 <merijn> solonarv: The STG paper talks about multiple conceptual stacks, but reduces them to a single one
07:19:23 <Chobbes> merijn: sounds great. I've been meaning to go through the STG paper.
07:19:45 <merijn> Chobbes: The example where you use tail calls for strictness would be, say, "sum"
07:20:02 <berndl> https://www.microsoft.com/en-us/research/wp-content/uploads/1992/04/spineless-tagless-gmachine.pdf <-- It says there's an argument stack, a return stack and an update stack.
07:20:04 <merijn> Chobbes: You want the accumulation to be strict, but you can't force strictness on a function result
07:20:33 <merijn> Chobbes: If you write it in tail call style, the accumulator becomes a function argument which you *can* make strict, thereby solving the lazy leak from a naive sum
07:20:48 <merijn> Chobbes: But the improvement is from the strictness, not the tail call.
07:20:53 <Chobbes> merijn: ahh, I see.
07:21:30 <merijn> So while tail calls sometimes appear as a solution to lazy leaks, that's more coincidental than the tail call really being important
07:21:50 <solonarv> and conversely, there are functions where you *don't* want tail recursion
07:22:01 <solonarv> you could feasibly write 'map' in a tail-recursive style
07:22:16 <xerox_> is there a similarly simple example for a problem whose solution is again adding strictness but you aren't forced into tail call style as in the sum example?
07:22:20 <merijn> Productivity/WHNF is usually more important
07:22:31 <solonarv> but now you would have to wait for the *entire* list to get processed before you can look at *any* part of the result!
07:26:11 <merijn> xerox_: hmm, tricky question
07:27:07 <jophish_> In GHC Haskell, is the initial thread bound to a partitcular OS thread when using -threaded
07:27:14 <merijn> xerox_: An easier example of when tail calls are harmful is when you consider something like map
07:27:24 <merijn> jophish_: I *think* the main thread is bound by default, yes
07:27:57 <Axman6> jophish_: yes, I believe main runs in a bound thread
07:28:00 <merijn> xerox_: "map f (x:xs) = f x : map f xs" normally this would be terrible in a strict language
07:28:26 <merijn> xerox_: But normally you only evaluate things to WHNF in haskell and in that case you hit WHNF immediately
07:29:43 <dmj`> Why doesn't Storable have a default GHC.Generics instance
07:30:10 <solonarv> easily checked thanks to threadCapability
07:30:12 <xerox_> merijn: you removed both strictness and tail rec there! (:
07:30:15 * hackage ghc-lib-parser-ex 8.10.0.11 - Algorithms on GHC parse trees  https://hackage.haskell.org/package/ghc-lib-parser-ex-8.10.0.11 (shayne_fletcher)
07:30:36 <merijn> dmj`: How would that possibly work sensibly?
07:32:06 <merijn> dmj`: There's no way to sensibly handle generic sum types
07:32:44 <dmj`> merijn: well for product types it seems to make sense, when all I want is to translate some struct w/o pulling in hsc2hs
07:33:08 <merijn> dmj`: You don't *have* to use hsc2hs
07:33:27 <merijn> Well, I guess for arbitrary C side structs you might :p
07:33:52 <dmj`> merijn:  from a convenience standpoint its advantageous but you lose other niceties like 
07:34:04 <solonarv> checking with 'main = print =<< threadCapability =<< myThreadId' suggests the main thread is, shockingly, *not* a bound thread
07:34:06 <dmj`> using ghci in haskell-mode (for me at least)
07:34:10 <solonarv> perhaps I'm overlooking something
07:35:17 <merijn> dmj`: Actually, the Generic instance can't work either :p
07:35:34 <merijn> For the same reason I had to correct myself about not having to use hsc2hs
07:35:53 <super-user> Hello I am new to haskell, and I am looking for a good introductionary text
07:36:04 <merijn> dmj`: Like, simple question: What would the Generic instance for products do?
07:36:22 <super-user> The text I am looking for should preferrably be written in some fashion `around` types
07:36:49 <dmj`> merijn: http://hackage.haskell.org/package/generic-storable-0.1.0.0/docs/src/Foreign-Storable-Generic.html#GStorable
07:36:55 <dmj`> the :*: part
07:37:08 <solonarv> surely it could just put the fields next to each other (while requiring the fields to also be Storable, of course)
07:37:42 <jophish_> merijn, Axman6. Thanks that makes sense. I'll see if I can find this in the GHC docs
07:37:55 <merijn> dmj`: Right, the problem with that is...it's not correct
07:37:56 <dolio> xerox_: let from n = n : from (n+1) in head . drop 1000000 $ from 0
07:38:01 <merijn> dmj`: And you can't make it correct
07:38:16 <merijn> dmj`: At least, wrt to accessing C structs defined by external code
07:40:28 <xerox_> dolio: interesting, where does that one benefit from strictness?
07:40:55 <dolio> from !n = n : from (n+1)
07:42:03 <dmj`> merijn: suppose you have a C struct with a single 64-bit field defined externally and a corresponding Haskell data type with an Int64
07:43:26 <merijn> Define "64-bit field" :)
07:43:32 <merijn> int64_t?
07:43:37 <dmj`> yea
07:44:01 <dmj`> let's keep it simple
07:44:12 <xerox_> dolio: so if I understand correcly that will compute straight away the (+1) applications, instead of accumulating a whole lot of them until the drop is done?
07:44:47 <merijn> dmj`: That's one of the very few cases you can do the right thing
07:44:49 <xerox_> informal benchmarking in ghci suggests the strict version is twice as fast (:
07:45:02 <dmj`> merijn: :) but if that's all I want to do, that's great
07:45:35 <merijn> dmj`: C requires that pointer to a structure and pointer to its very first field must be the same
07:46:47 <dolio> xerox_: Twice as fast sounds about right. In the non-strict version, you get back `((...)+1)+1`, so you have to reduce as many thunks as you dropped list elements. So it's almost like you have to go through two lists instead of one.
07:47:17 <merijn> dmj`: The problem is that the internal padding and alignments within a structure are entirely implementation defined, so you (technically) can't even assume struct field access in C are portable across compilers >.>
07:47:33 <xerox_> dolio: neat
07:48:05 <dmj`> merijn: we could put some CPP in the generics for things like that maybe
07:48:15 * hackage cabal-file 0.1.0 - Cabal file access  https://hackage.haskell.org/package/cabal-file-0.1.0 (JensPetersen)
07:48:30 <xerox_> dolio: are we computing the n+1's wastefully for the dropped elements in the strict case?
07:48:41 <merijn> dmj`: No, because it doesn't have to be consistent between different struct types >.<
07:49:23 <merijn> dmj`: And eventually you end up redoing what hsc2hs does, which is just "compile and run a C program that produces a Haskell source file with the right sizes"
07:49:24 <dolio> xerox_: No, because you're always computing those numbers anyway.
07:49:47 <dolio> You're just wating until the big `(...)+1` to do it.
07:51:08 <xerox_> dolio: makes sense, the n in the last n+1 is the actual computation done at !n, there aren't two versions of them hehe
07:51:18 <dmj`> merijn:  well I hope it was omitted for a good reason then. I'm fine with Generics that don't cover all cases and are specific to my problem and requirements. The goal is to remove boilerplate for the small subset of problem that is my own, not account for every possible union / struct combination with haskell sum and products. 
07:51:32 <xerox_> dolio: cool example, appreciate it
07:51:43 <dolio> No problem.
07:52:28 <merijn> dmj`: For some of my code I just handwrite Storable instances for the very specific thing I want, but then I also control the C side, so I just manually make sure they match :p
07:54:22 <dmj`> merijn: sounds reasonable :) 
08:06:25 <dolio> xerox_: Actually, this is kind of the idea behind an entire different evaluation strategy for Haskell. It's often good to just reduce stuff like Int immediately, so instead of just laziness, you try a quick eager reduction and limit the time it's allowed to take.
08:07:30 <xerox_> dolio: fun! what do you provide for the case where the time limit is exceeded
08:07:32 <dolio> However, it requires book keeping, because if you're handing an expensive-to-evaluate argument around to multiple functions, you don't want it to keep being reduced on each one.
08:08:18 <dolio> I'm not sure. Maybe there's a way to write back the intermediate state of partial reduction to the thunk.
08:08:25 <xerox_> just-out-of-time evaluation
08:08:38 <dolio> So that when you really need it, you can pick up where you left off.
08:08:53 <dolio> Or, _if_ you really need it.
08:09:39 <Philonous> Doesn't any reasoning about memory consumption go out the window at that point? 
08:10:15 <dolio> I don't know. I've never had a chance to use it.
08:10:46 <xerox_> dolio: it reminds me of that process that is possible to do in llvm (maybe w/ othercompilers too) in which a profiling run is made and that in turn provides the weights for the inilining/optimization; if not a strategy in itself, it could be a strategy to figure out where strictness annotations could make sense after a test run
08:11:23 <dolio> Yeah, you could do that, too.
08:15:55 <merijn> xerox_: Note also that this sorta thing is why we have the subtle distinction of Haskell being specified as "non-strict", rather than "lazy". The distinction being that the former requires lazy code to work, but doesn't require laziness, which means the compiler is allowed to (and does) make things strict if it is sure that doesn't affect the semantics
08:31:35 <dmj`> instance IsString CString where fromString = unsafePerformIO . newCString
08:31:39 <dmj`> how bad of a person does this make me
08:32:06 <merijn> dmj`: Very >.>
08:33:56 <dmj`> *slow evil grin*
09:10:45 * hackage pattern-trie 0.1.1 - Pattern tries  https://hackage.haskell.org/package/pattern-trie-0.1.1 (romanb)
09:15:45 * hackage pandoc-utils 0.6.0 - Utility functions to work with Pandoc in Haskell applications.  https://hackage.haskell.org/package/pandoc-utils-0.6.0 (Krasjet)
09:20:45 * hackage pandoc-utils 0.6.1 - Utility functions to work with Pandoc in Haskell applications.  https://hackage.haskell.org/package/pandoc-utils-0.6.1 (Krasjet)
09:43:15 * hackage hlint 3.1.2 - Source code suggestions  https://hackage.haskell.org/package/hlint-3.1.2 (NeilMitchell)
10:17:11 <awpr> if I understand correctly, bottom values are represented uniformly across all lifted types: a thunk whose entry code either throws an error or fails to terminate.  is that correct?
10:18:01 <c_wraith> "thunk" is a bit of an implementation detail.  If you're trying to keep implementation separated, go with "expression"
10:18:06 <awpr> in particular, for any `a :: TYPE 'LiftedRep` and `b`, `undefined :: a === unsafeCoerce (undefined :: b) :: a`
10:18:39 <awpr> I am intentionally trying to get into the implementation, I suppose
10:19:28 <c_wraith> a bottom value is an expression that does not evaluate to a value that can be pattern matched (or if it's a function, applied)
10:19:34 <awpr> thus the mention of"representation": I'm talking about the machine representation, not the semantics
10:20:29 <c_wraith> In which case...  there are a lot of different bottom values
10:21:06 <awpr> there sure are, but IIUC they all can be "provoked" by the same call-site code: it's a thunk, and you enter it and it never has a result
10:21:35 <merijn> awpr: implementation details like this might get more accurate answers in #ghc :)
10:21:43 <monochrom> "uniformly either throw error or non-terminate" is an oxymoron. since there are diverse ways to throw errors and there are diverse ways to non-terminate, and throwing error is in a sense an opposite of non-terminating, you can't sanely call them "uniform".
10:22:00 <awpr> indeed, I'm just concerned I'm being too chatty in there lately
10:22:17 <merijn> awpr: It's fine, that's what channels are for
10:22:21 <monochrom> In fact, strictly speaking, by the time you get down to evaluation, there is no longer a "bottom value". Only the denotational level has it.
10:22:42 <monochrom> merijn: Now consider fog.
10:22:54 <merijn> awpr: The main thing to keep out of #ghc is beginner stuff, i.e. it should all be either related to hacking on GHC or power user questions
10:22:56 <awpr> monochrom: I don't mean that uniformity is between looping and erroring; I mean that the same loop is uniform across all lifted types, and the same 'error' is uniform across all lifted types
10:23:15 <maerwald> strictly speaking about lazy evaluation? I see what you did there
10:23:16 <monochrom> Like I said, still no.
10:23:43 <monochrom> (Did you read my whole sentence completely?)
10:23:51 <monochrom> (For 3 times?)
10:23:53 <c_wraith> I mean, by the time you're asking about what it's compiled down to, types don't exist anymore anyway...
10:23:58 <merijn> monochrom: I'm not saying "everything is fine and there's no limit to chattiness", but "detailed questions about representations of #ghc" seem solidly "on topic" for #ghc :)
10:24:02 <awpr> yes
10:24:10 <awpr> okay, probably you're poking at "value" being the wrong term here?
10:24:20 <awpr> in that a thunk isn't a "value"?
10:24:21 <monochrom> value is the right term.
10:24:33 <dolio> `sum [1..] :: Int` isn't a loop that naturally occurs in every type.
10:25:07 <monochrom> "there are diverse ways to throw errors" and "there are diverse ways to non-terminate".  Read that again.
10:25:35 <monochrom> Exercise: come up with 10 different expressions that non-terminate.
10:25:48 <awpr> `error . show <$> [1..10]`
10:25:55 <awpr> well, that's erroring
10:26:14 <awpr> but the same thing with a function that calls itself in infinite recursion
10:27:03 <awpr> maybe my English description was garbage, but I don't think this has anything to do with what I'm trying to confirm
10:27:22 <monochrom> dolio: I think you'll have better luck with s/Int/Integer/ :)
10:27:32 <dolio> Oh yeah, my bad.
10:27:47 <dolio> Or I should use cycle or something.
10:27:54 <monochrom> ELINT = explain like I'm not telepathic.
10:28:45 <monochrom> Also consider Sapir-Worf.
10:29:33 <monochrom> And there is always formal mathematics, when natural languages fall short.
10:31:15 <biggiepow> Hello please noob>?!
10:31:19 <biggiepow> averageThree :: Integer -> Integer -> Integer -> Float
10:31:19 <biggiepow> averageThree a b c = (a + b + c) / 3
10:31:28 <c_wraith> :t (/)
10:31:29 <lambdabot> Fractional a => a -> a -> a
10:31:37 <monochrom> @quote monochrom fromIntegral
10:31:37 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
10:31:40 <biggiepow> why is that giving error?
10:31:51 <c_wraith> biggiepow: notice how both arguments are the *same* type?
10:31:51 <merijn> biggiepow: / is for fractional division, Integers are not fractional
10:32:01 <merijn> biggiepow: You probably want 'div'
10:32:01 <monochrom> / cannot be used directly on Integer
10:32:03 <merijn> :t div
10:32:04 <lambdabot> Integral a => a -> a -> a
10:32:10 <c_wraith> biggiepow: arithmetic operators don't change types from arguments to results
10:32:19 <monochrom> but div doesn't give Float and doesn't give 1/2
10:32:30 <merijn> monochrom: I missed the Float part of the type :)
10:32:47 <monochrom> and usually people don't want rounded averages.
10:33:31 <monochrom> Anyway, use fromIntegral to convert Int or Integer (works for both) to fraction types.
10:33:51 <monochrom> actually, in this case, does anyone prefer realToFrac?
10:34:11 <c_wraith> Why does every class that uses Haskell talk point people at Float instead of Double?
10:34:14 <merijn> realToFrac should just "convertWithExtremePrejudice" :p
10:34:17 <c_wraith> -talk
10:34:46 <monochrom> Not my class, I go to Double and Rational.
10:34:57 <c_wraith> ok, thank you for doing the rational thing. :P
10:34:57 <merijn> Rational is criminally underrated
10:35:05 <monochrom> \∩/
10:35:09 <merijn> Rational is fantastic
10:35:12 <Philonous> Because bits are heavy and the lecturer didn't want to bring enough for everyone in the lecture
10:35:25 <monochrom> I gave a probability monad assignment, and I used Rational there.
10:35:34 <maerwald> merijn: takes some memory though afair
10:35:41 <c_wraith> Rational is easy to use *way too much* memory with if you aren't aware of the implementation
10:36:20 <maerwald> Even in finance, they rather use Double than Rational :P
10:36:26 <monochrom> But when not using Rational, I use Double.  In a C class, I use double, too.
10:37:08 <merijn> Double is to wasteful
10:37:13 <monochrom> On x86, float is not faster than double, apart from "smaller therefore faster read/write"
10:37:15 <merijn> half-precision FP!
10:37:54 <monochrom> and the fact remains that float's precision is a joke.
10:37:57 <merijn> People who pick float because it's faster than double clearly know jack shit about writing fast code >.>
10:39:12 <awpr> if your code is going to throw an error due to NaNs, you can make it throw that error faster by switching to `Float` :)
10:40:29 <c_wraith> there was a big discussion in here a couple days ago about how awful it is that NaN doesn't throw any errors at all. :P
10:42:18 <monochrom> That's a good topic, but that particular discussion was pointless becasue hypererisco was being dense or facetious or something.
10:42:50 <[exa]> monochrom: well, 2x faster reads/writes usually translate to 2x the performance
10:42:54 <biggiepow> Thanks! One more printing strings over mulitple lines/ using tabs etc...  trying to get these 3 on mulitple lines, my book is outdated maybe..str4 = "gorilla\nhippo\nibex"   
10:43:22 <operand> [exa]: memory latency is usually a bigger problem than memory throughput, though
10:43:22 <merijn> biggiepow: In ghci?
10:43:35 <biggiepow> yes
10:44:00 <merijn> biggiepow: That's because ghci (by default) shows it's output which escapes special characters
10:44:12 <[exa]> operand: well if you want it fast and the data isn't array-ized... :]
10:44:22 <merijn> biggiepow: Try explicitly printing your string via "putStrLn"
10:44:32 <merijn> % "gorilla\nhippo\nibex"
10:44:33 <yahb> merijn: "gorilla\nhippo\nibex"
10:44:38 <merijn> % putStrLn "gorilla\nhippo\nibex"
10:44:38 <yahb> merijn: gorilla; hippo; ibex
10:44:49 <merijn> oh, it replaces newlines with ;
10:44:55 <merijn> Anyway, you can try that in ghci
10:44:58 <monochrom> \∩/ \n is programmable semicolon >:)
10:45:29 <maerwald> :t \n
10:45:31 <lambdabot> error:
10:45:31 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
10:45:54 <monochrom> Monad is programmable newline >:)
10:46:59 <merijn> Speaking of performance
10:47:05 <merijn> Here's a nice question
10:47:50 <biggiepow> you are good people thx
10:48:36 <merijn> I have a mapping of old indices to new indices into a vector. I need to decide whether I just take every input vector and shuffle/filter it into the right new order, or do all my lookups via the indirection
10:49:20 <merijn> I'm thinking that since my vectors are fairly small (50-100 Int64) compacting them once before repeatedly accessing them is most likely faster than indirect indexing
10:50:26 <merijn> otoh, that also depends on how much gets indexed
10:50:27 <c_wraith> it depends on all sorts of things. how expensive is the function? how big is the array? how many times is it used? and so on.
10:50:50 <awpr> I would guess that compacting first is faster as long as the average access count per index is more than a bit above 1
10:51:15 * hackage pandoc-utils 0.7.0 - Utility functions to work with Pandoc in Haskell applications.  https://hackage.haskell.org/package/pandoc-utils-0.7.0 (Krasjet)
10:51:20 <awpr> but this seems like something `gauge` or `criterion` would be really well suited to answering definitively, and not too hard to write a benchmark
10:51:20 <merijn> c_wraith: The mapping is just a straight static mapping (so, like IntMap Int or whatever), the vector is 50-100. The number of lookups is the question. I'd say "anywhere from 10 to a few 100?" but I'm not sure
10:51:38 <merijn> Maybe I should just pick the easiest and tweak it later :p
10:51:43 <c_wraith> all told, that's a sort of expensive indirection
10:52:15 <awpr> it probably also depends on how far separated the lookups are: if you drop that line from the cache between lookups, the indirection is even more expensive
10:52:27 <awpr> whereas if you're compacting en masse, it should stay cached
10:52:41 <awpr> (for the duration of the compacting function)
10:52:54 <merijn> awpr: The vectors are being streamed in via conduit and all lookups happen in a dense loop :)
10:53:01 <monochrom> I feel that any specific answer is not future-proof.  A performant solution on today's hardware can become slow on future hardware.
10:53:24 <merijn> monochrom: Fortunately, my thesis should *really* be done before that becomes relevant, so I don't give a shit :p
10:53:38 <monochrom> But currently, any indirection is thought of as more expensive than you think.
10:53:50 <c_wraith> IntMap is not cache-friendly even in the best cases.
10:54:03 <merijn> c_wraith: I can use "Vector Int" too, probably, so
10:54:59 <merijn> I guess that if I'm traversing my input Vector first to compute the mapping I might as well transform it, since most of the cost is already paid and then I wouldn't need to change my existing logic
10:55:22 <Philonous> merijn, But at some point you're already building a vector of the same length, or does that indirection stay constant while the vectors you want to look up change?
10:56:25 <c_wraith> yeah, it sounds like your building a good case to just do the rewrite.
10:56:30 <c_wraith> *you're
10:56:41 <merijn> c_wraith: Not possible to do it statically
10:57:21 <merijn> Basically, I have a model trained on M out of N inputs. I want to simultaneously evaluate multiple models to compare. So I need to feed each model the right subset of all N inputs to do predictions
10:57:44 <merijn> (and N may grow in the future)
10:57:54 <Philonous> Maybe the correct answer is "benchmark it"
10:58:42 <merijn> So I can either 1) expand my model with an extra mapping from it's internal indices to the external indices on the vector of N, or 2) filter the relevant M values for each model and feed it that.
10:59:07 <merijn> Philonous: Well, like I said, probably the answer is "do whatever's easiest and use that until it's too slow" :p
11:00:43 <Philonous> merijn, It sounds to me like there's little benefit in building the indirection. You have to look at each of the indices once anyway to build that indirection vector, might instead just build the new input vector. 
11:02:31 <merijn> Philonous: I'm going over ~90k inputs and the indirection vector could be reused for all inputs. Anyway, probably overthinking this for now
11:03:04 <shapr> Is there a time series file format that has good Haskell lib support?
11:21:43 <merijn> shapr: SQLite? ;)
11:36:42 <isovector1> is there a guide on how to use cabal to build projects in 2020? i have no idea and am hitting a weird bug in stack
11:36:45 * hackage NaCl 0.0.2.0 - Easy-and-safe-to-use high-level Haskell bindings to NaCl  https://hackage.haskell.org/package/NaCl-0.0.2.0 (kirelagin)
11:38:45 * hackage crypto-sodium 0.0.2.0 - Easy-and-safe-to-use high-level cryptography based on Sodium  https://hackage.haskell.org/package/crypto-sodium-0.0.2.0 (kirelagin)
11:40:45 * hackage JuicyPixels-blurhash 0.1.0.1 - Blurhash is a very compact represenation of a placeholder for an image  https://hackage.haskell.org/package/JuicyPixels-blurhash-0.1.0.1 (smprts)
11:49:25 <enikar> isovector1: have you read this: <https://www.haskell.org/cabal/users-guide/index.html>?
11:55:15 <isovector1> enikar: not in its entirety, no. have you?
11:55:59 <isovector1> also this seems not to have been touched since 2017
11:56:23 <enikar> isovector1: me too.
11:57:24 <solonarv> this is updated: https://cabal.readthedocs.io
11:57:48 <solonarv> and its quickstarts *does* talk about the modern way to use cabal
11:58:49 <yushyin> v2- should be the default by now, right?
11:58:59 <solonarv> if you're using cabal >= 3.0 yes
11:59:15 <yushyin> good :)
11:59:15 <solonarv> (you should be using that, but maybe you haven't updated yet)
12:00:27 <isovector1> what about dealing with cabal hell? is there a guide for that? :)
12:00:37 <isovector1> https://pastebin.com/W78Jn4He
12:00:49 <monochrom> if you go v2, there is no cabal helll.
12:01:01 <merijn> isovector1: cabal hell hasn't been a thing in years
12:01:24 <merijn> Nowadays when people say "cabal hell" they just mean "I dependent on super fringe/unmaintained packages and now my bounds are broken"
12:01:45 <awpr> proposal to call that cabal limbo
12:01:51 <isovector1> merijn: maybe? but it still doesn't compile complaining about bounds. stack happily compiles this thing
12:02:03 <merijn> Cabal not being able to invent a build plan because you're trying to depend on a package with ~1 user that hasn't been touched in 5 years is not cabal's fault
12:02:16 <merijn> isovector1: Sounds like your bounds are broken
12:02:20 <awpr> Hackage Purgatory, then
12:02:25 <merijn> (or your dependencies bounds are broken)
12:03:00 <isovector1> sure but how do i fix it?
12:03:17 <isovector1> the error messages are not exactly readable
12:03:24 <merijn> isovector1: Figure out which versions your stack LTS used, use those
12:04:55 <rsoeldner> Is the `beam-postgres` working with auto incremented values? I used `beam-migrate` and no seq is generated. Have I missed something ?
12:05:45 * hackage JuicyPixels-blurhash 0.1.0.2 - Blurhash is a very compact represenation of a placeholder for an image  https://hackage.haskell.org/package/JuicyPixels-blurhash-0.1.0.2 (smprts)
12:06:59 <isovector1> what i'm hearing is "no, there isn't a helpful guide to using cabal in 2020"
12:07:37 <merijn> isovector1: I'm not really sure what kinda guide you're expecting. If the problem with your build is "incorrect bounds", I'm not really sure how any form of guide would help fix that?
12:08:02 <merijn> If the problem is not incorrect bounds, then what is?
12:08:51 <monochrom> I took a brief look, my first-order approx is too-new-ghc or too-old-package.
12:08:52 <isovector1> a guide that talks about the differences between `build` and `v2-build` and `new-build`. do i still need a cabal sandbox? how to i troubleshoot bad bounds? what if the problematic package is on hackage? how do i work around that?
12:09:09 <merijn> isovector1: new-build and v2-build are the same thing
12:09:29 <merijn> isovector1: See https://cabal.readthedocs.io/en/latest/nix-local-build-overview.html for a v2-build primer
12:10:18 <merijn> isovector1: Sandboxes are (almost) entirely obsolete.
12:10:25 <isovector1> ah, thanks. it's an unhelpful section title because i don't know what nix is and i am epxlicitly not using nix, so i skipped that part
12:10:41 <merijn> isovector1: I believe stack has a command to dump out the snapshot's version bounds, afaik
12:10:54 <isovector1> the ghc guys think i have a too-old version of cabal-install installed
12:10:55 <monochrom> Yes I agree "nix-style" sends the wrong message.
12:11:04 <isovector1> so old that it can't install a newer version of cabal-install
12:11:06 <merijn> So if you had a working stack snapshot, you should be able to get a first approximation of the bounds
12:11:23 <merijn> isovector1: Which version of cabal-install do you have?
12:11:48 <isovector1> maybe  2.4.1.0?
12:11:59 <merijn> That's...odd
12:12:14 <merijn> isovector1: How new is your GHC, exactly?
12:12:18 <isovector1> ghc 8.8
12:13:39 <merijn> Ah, 8.8 only works with 3.0 or newer, according to the GHC docs. You can get a binary https://www.haskell.org/cabal/download.html or bootstrap it from the cabal repo
12:15:10 <monochrom> or go back to ghc 8.6
12:15:41 <isovector1> ghc 8.6 has a bug in profiling TH
12:16:01 <isovector1> this has been a week-long endeavor, involving patching two upstraem libs to compile on 8.8 :)
12:16:49 <merijn> isovector1: In general cabal-install is backwards compatible, but not guaranteed to be forwards compatible (I forget why GHC 8.8 needs the newer version, though)
12:18:07 <monochrom> ghc 8.8 comes with Cabal 3.0.  cabal-install doesn't need to care per se, but if someone has a non-trivial Setup.hs, there could be inconsistency.
12:18:41 <isovector1> yay! new cabal got things building
12:18:42 <isovector1> thanks all
12:19:21 <kompakt> Hello, need help with async & waitAny please.
12:19:38 <solonarv> kompakt: then you're probably at the right place. what's your problem?
12:20:52 <monochrom> in fact "constraint from maximum version of Cabal used by Setup.hs requires <2.6" may mean that.
12:22:23 <isovector1> monochrom: maybe? but it's not exactly helpful!
12:22:45 * hackage sixel 0.1.2.3 - Sixel library to show images in a terminal emulator  https://hackage.haskell.org/package/sixel-0.1.2.3 (junjihashimoto)
12:22:51 <kompakt> :solonarv I have the following 
12:22:54 <kompakt> pair :: (SomeEnv env m, MonadIO m) => SomethingElse -> m (MessageResp)
12:22:56 <kompakt> --
12:22:57 <kompakt> t1 <- (LA.async $ pair pr)
12:22:59 <kompakt> t2 <- (LA.async $ pair pr)
12:23:00 <kompakt> t3 <- (LA.async $ pair pr)
12:23:02 <kompakt> t4 <- (LA.async $ pair pr)
12:23:03 <kompakt> ares <- LE.try $ LA.waitAny [t1, t2, t3, t4]
12:23:34 <kompakt> how can I use something like 'map' to make it less repetitive? 
12:24:01 <xerox_> :t sequence
12:24:02 <lambdabot> (Traversable t, Monad m) => t (m a) -> m (t a)
12:24:39 <solonarv> 'traverse' is what you want here
12:24:43 <xerox_> to turn a list of actions into an action that gives you the list of results
12:24:50 <xerox_> :t traverse
12:24:51 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
12:25:02 <[exa]> kompakt: some libraries have even `iterateM`
12:25:02 <solonarv> sequence (map f xs)   is the same as   traverse f xs
12:25:24 <kompakt> I see, thank you! 
12:25:35 <[exa]> (oh I mean `replicateM` )
12:25:40 <solonarv> or since you are repeating the same action 4 times, you could use replicateM
12:26:02 <xerox_> :t Control.Monad.replicateM
12:26:03 <lambdabot> Applicative m => Int -> m a -> m [a]
12:26:08 <kompakt> thank you, I will explore these !
12:26:15 <xerox_> @src replicateM
12:26:15 <lambdabot> replicateM n x = sequence (replicate n x)
12:26:17 <rain1> hey
12:26:18 <xerox_> ha
12:26:22 <rain1> does lambdabot have a way to factor numbers?
12:26:24 <[exa]> solonarv: I still need to find a good memory helper for remembering which one of 'iterate' 'replicate' and 'repeat' does what
12:26:33 <monochrom> rain1: No.
12:26:41 * solonarv shrugs
12:26:47 <solonarv> I just kind of got used to it
12:26:51 <[exa]> rain1: why though
12:26:53 <monochrom> lambdabot is not a CAS.
12:27:03 <[exa]> solonarv: guess I'm in the process
12:27:05 <[exa]> :]
12:27:59 <solonarv> kompakt: btw, are you sure waitAny is what you want here? I would guess waitAnyCatch, waitAnyCancel, or waitAnyCatchCancel would be better suited
12:31:35 <kompakt> solonarv: yes, I am going to use waitAnyCatch. Thanks
12:33:15 <awpr> if you're using exactly the code you posted, it sort-of looks like trying to deal with a service with highly variable latency by racing four copies of the same request against each other
12:33:45 <awpr> which I suspect most service owners would consider somewhat undesirable behavior, in that if everyone does that, the service just gets slower and flakier
12:34:03 <kompakt> solonarv: I am trying this , traverse (LA.async $ pair pr) [1 .. 4]
12:34:23 <kompakt> not sure I understnad Applicative yet
12:34:48 <solonarv> that doesn't typecheck
12:35:03 <solonarv> which has nothing to do with Applicative in particular, really
12:35:38 <xerox_> > unfoldr (\case 1 -> Nothing; n -> case [ m | m <- [2..n], n `mod` m == 0 ] of [] -> Nothing; (k:_) -> Just (k, n `div` k)) 23670
12:35:40 <lambdabot>  [2,3,3,5,263]
12:35:46 <kompakt> not sure I understand it well enough
12:35:49 <kompakt> Couldn't match type ‘(->) env0’ with ‘IO’
12:36:27 <solonarv> the problem is simply that the first argument of 'traverse' should be a function (look at the type!), but '(LA.async $ pair pr)' isn't a functin
12:39:53 <kompakt> so the first argument should just be async?
12:40:11 <solonarv> well, that would be one way to do things
12:40:31 <solonarv> but really, if you just want to replicate the same action some number of times you should use replicateM
12:40:38 <solonarv> :t replicateM @IO
12:40:40 <lambdabot> error:
12:40:40 <lambdabot>     Pattern syntax in expression context: replicateM@IO
12:40:40 <lambdabot>     Did you mean to enable TypeApplications?
12:40:46 * solonarv grumbles
12:40:50 <solonarv> % :t replicateM @IO
12:40:50 <yahb> solonarv: Int -> IO a -> IO [a]
12:42:54 <kompakt> thanks, replicateM is a lot better
12:43:10 <kompakt> I will try understnading traverse someother time :)
13:06:45 * hackage worldturtle 0.1.0.0 - Turtle graphics.  https://hackage.haskell.org/package/worldturtle-0.1.0.0 (FortOyer)
13:08:04 <dsal> kompakt: traverse is basically mapM
13:20:41 <Cjen1> Hey all, probably stupid question, what is the syntax for types without a concrete implemenatation? Purpose is for restricting application of functions inside a type class
13:21:54 <xerox_> i.e. missing the "= ..." in "data Type = ..." ?
13:22:45 * hackage safe 0.3.19 - Library of safe (exception free) functions  https://hackage.haskell.org/package/safe-0.3.19 (NeilMitchell)
13:23:07 <Cjen1> yes
13:23:20 <Cjen1> asdf
13:23:28 <xerox_> hehe
13:23:36 <Cjen1> darn no multiline...
13:25:32 <awpr> you can't pre-declare a type without defining it like you would in a C++ header, but what you can do is export the type without exporting its data constructors
13:25:47 <awpr> `data Void` is valid syntax, but it means uninhabited rather than "abstract"
13:25:51 <Cjen1> Ok so if I have a type class : `class A repr where t :: repr foo; g :: repr foo -> repr bar; foobar :: repr bar -> repr String` the issue is that the foo and bar seemingly have to be previously defined?
13:27:10 <awpr> this looks like a final encoding of an AST?
13:27:30 <Welkin> a FINAL FANTASY?
13:27:47 <awpr> Final FantAST
13:27:51 <Cjen1> tagless final specifically but yes :)
13:28:19 <awpr> and `foo` and `bar` are among the types of your language, then
13:28:34 <awpr> and the types of your embedded language are of kind `Type` since one of them is `String`
13:28:35 <Cjen1> Yep
13:28:49 <awpr> do `foo` and `bar` need to vary between `repr`s?
13:30:33 <Cjen1> no they should be constant (so theoretically I could just make them have a concrete type, but that feels kinda wrong...)
13:30:57 <awpr> if they're just tags and the types of `t` and `g` and `foobar` should be uniform across interpretations, then probably `data Foo` and `data Bar` should work
13:31:34 <awpr> this notion of abstractness feels like an existential, i.e. there's some `foo` and there's some `bar` but we won't tell you what they are
13:31:56 <awpr> but I don't know of a way to have global existentials like this
13:32:33 <Cjen1> true so I was thinking more of the gadt style of this thing has a type `repr foo` which is something related to `foo`
13:34:51 <awpr> a GADT constructor like `Foobar :: forall bar. Repr bar -> Repr String` would be quite different, since it would accept any `Repr` rather than a single specific type of `Repr`
13:36:08 <awpr> if that `forall` were `exists`, it'd still be odd, since it wouldn't be the same `bar` as in other constructors' signatures; it'd have to be quantified over the whole GADT definition somehow
13:36:16 <awpr> but this is very far into `-XImaginarySyntax` land
13:38:15 * hackage typed-encoding 0.3.0.2 - Type safe string transformations  https://hackage.haskell.org/package/typed-encoding-0.3.0.2 (rpeszek)
13:55:45 * hackage JuicyPixels-blurhash 0.1.0.3 - Blurhash is a very compact represenation of a placeholder for an image  https://hackage.haskell.org/package/JuicyPixels-blurhash-0.1.0.3 (smprts)
14:01:35 <isovector1> i want to write a program that finds every possible place in an AST a rewrite rule matches
14:01:42 <isovector1> is there a known algorithm for this?
14:01:59 <isovector1> right now i'm doing the naive thing and finding every subexpression and trying to match. this is O(stupid)
14:02:18 <awpr> can you harvest the algorithm from GHC's simplifier?
14:03:09 <isovector1> awpr: maybe. is it documented anywhere?
14:03:32 <awpr> I read a paper on it from the 90s ish, let's see if I can find it
14:04:16 <Tuplanolla> I came across news on this just a few days ago. Give me a moment.
14:04:40 <awpr> https://www.microsoft.com/en-us/research/wp-content/uploads/2002/07/inline.pdf?from=http%3A%2F%2Fresearch.microsoft.com%2Fen-us%2Fum%2Fpeople%2Fsimonpj%2Fpapers%2Finlining%2Finline.pdf is the one I was thinking of, but it doesn't seem to discuss user-specified RULES, just inliner concerns in general
14:04:46 <isovector1> https://www.microsoft.com/en-us/research/publication/playing-by-the-rules-rewriting-as-a-practical-optimisation-technique-in-ghc/?from=http%3A%2F%2Fresearch.microsoft.com%2F%257esimonpj%2Fpapers%2Frules.htm
14:04:48 <isovector1> this one i think
14:05:18 <awpr> yeah, that's the one I should have been thinking of.
14:07:39 <isovector1> thanks
14:08:43 <awpr> I suspect it won't tell you anything better than "index the set of rules by their top-level atoms, visit every subexpression, and try to match the ones with the same head"
14:10:04 <wavemode_> even GHC seems to have not mastered optimizing the rewrite process :P (considering how much slower -O2 is than -O0)
14:11:08 <awpr> `-ddump-simpl-stats` will show that it's sometimes dealing with some pretty outrageously large programs in the intermediate simplifier passes
14:11:37 <isovector1> mine is gruesomely worse than ghc's right now, so any improvements will be much appreciated
14:12:15 <awpr> I must have read this paper before, because the thing I said above is very nearly a paraphrase of section 2.2
14:13:01 <awpr> out of curiosity, is this an automated refactoring tool?
14:13:30 <isovector1> it's a proof search
14:14:05 <isovector1> matching on the function seems a bit wonky; since it's the deepest thing in the AST
14:15:26 <awpr> it's just an optimization for quickly pruning most of the rewrite rules at most of the subexpression
14:15:29 <awpr> s
14:15:49 <awpr> if there's only one rewrite rule it doesn't really seem applicable
14:32:06 <isovector1> no MonadState instance for the CPS'd WriterT?
14:35:02 <Welkin> is it a sovereign monad state?
14:35:59 <wavemode_> isovector1: you mean Writer.CPS in `transformers`?
14:36:04 <isovector1> wavemode: yeah
14:36:16 <wavemode_> MonadState is mtl
14:36:39 <isovector1> okay but the regular writer in transformers has a monadstate instance
14:48:34 <hexagoxel> isovector1: it only has the pass-through instance (for WriterT, if underlying monad is MonadState), doesn't it?
15:07:26 <wavemode_> the CPS version is relatively newly added to transformers. it's not reexported by mtl
15:08:32 <Welkin> too many adverbs
15:09:03 <wavemode_> 2 is too many?
15:10:06 <Welkin> more than zero is too many
15:10:15 <Welkin> never 2 in a row
15:10:41 <wavemode_> "more than zero is too many" contains more than zero adverbs :P
15:11:17 <Welkin> there are no adverbs in that phrase
15:11:34 <wavemode_> then what do you call "too"
15:11:39 <awpr> I use adverbs too manily
15:13:35 <Welkin> how else would you express the idea of having more than you need, if not "too many"?
15:14:30 <wavemode_> I agree with you! which is why "more than zero is too many" is unnecessarily strict
15:14:41 <awpr> that "too many" is the best way to express having more than you need has no bearing on whether "too" is an adverb
15:15:08 <awpr> it's perfectly fine to modify an adverb with another adverb
15:15:25 <Welkin> this is why grammar is stupid
15:15:30 <awpr> "dramatically too many" has dramatically too many adverbs
15:15:48 <wavemode_> Welkinly nitpickedly tooly muchly
15:16:07 <Welkin> verily so
15:16:24 <awpr> natural language grammars do tend to be stupid and hazily defined, but humans are pretty good at parsing them intuitively
15:17:02 <xerox_> it's strange to consider stupid what works
15:17:23 <awpr> I mean stupid in the sense that they wouldn't be considered reasonable as a machine-parseable grammar
15:17:57 <awpr> they're fine for human use.  anyway, how about: "the CPS'd Writer is too new to have grown an instance in mtl"
15:18:08 <Welkin> xerox_: grammar is an attempt to codify a language as a set of rules, with many exceptions. It has nothing to do with language itself
15:18:49 <Welkin> grammar does not "work" as evidenced by the numerous exceptions to their "rules"
15:19:14 <awpr> if people weren't in the habit of using adverbs to modify adverbs, then English grammar rules wouldn't consider that a valid thing to do
15:19:58 <awpr> the fallout of rigid rules being silly in this case is that you can stack a thousand adverbs end to end and grammar doesn't have any problem with that, but most humans would
15:22:09 <Welkin> language isn't even consistent regionally, or across dialects
15:22:55 <Welkin> the word "quite" in british english means the exact opposite in american english, for example. Construction in indian english that are well accepted (such as "very less" and describing something as "less") is not valid in other dialects of english
15:22:59 <Welkin> it's stupid
15:24:00 <MarcelineVQ> hmm? what does quite mean to you if you feel quite mean the opposite?
15:24:10 <Cale> It might help to assign costs to each grammatical construction, so that constructions that have high costs are perhaps not going to be considered very good.
15:24:28 <awpr> should "the" be `INLINE CONLIKE`?
15:24:45 <awpr> *shrug* then let's just say wavemode_ and I speak a dialect where two is an acceptable number of adverbs, and not try to debate whether that's universally correct
15:25:07 <Welkin> MarcelineVQ: in british english "quite" means "not at all", while in american english it means "very much so"
15:25:18 <Cale> There does seem to be a continuum of badness, where someone might eventually be able to understand what you've said, but it becomes harder and harder to parse.
15:25:47 <MarcelineVQ> No, both on their own mean "I agree. I think perphaps you've just heard it from being who have sarcatic characters?
15:25:57 <MarcelineVQ> *mean "I agree."
15:26:17 <sheepfleece> Hello! Say I have a type `f :: forall k (a :: k) b. a -> b`, can I somehow move `k` to the right so when I want to use `TypeApplications` I could do `f @Int` instead of `f @Type @Int` or `f @_ @Int`?
15:26:32 <Cale> Welkin: uhhh... I don't agree about "quite"
15:26:46 <Cale> Welkin: can you give an example of that?
15:27:05 <Welkin> "I'm _quite_ alright!"
15:27:13 <MarcelineVQ> Now, this only supports your position that people use words differently, I'm only asking about it because I'm curious now
15:27:19 <awpr> sheepfleece: can you let the `k` be implicitly quantified, or does it need to be visible to other `TypeApplications`?
15:27:33 <Cale> Welkin: Are you referring to sarcasm?
15:27:42 <Welkin> no
15:27:42 <sheepfleece> I can. How should I do it? 
15:27:54 <awpr> `f :: forall (a :: k) b. a -> b`
15:28:04 <Cale> If it's not used in a sarcastic manner, that would mean "very much fine" on both sides of the pond
15:28:14 <MarcelineVQ> Quite. I'm quite alright means exactly the same in north america and uk english.
15:28:29 <sheepfleece> Ah, but that's how it is written, however ghc itself inserts `k` before `(a :: k)`.
15:28:32 <MarcelineVQ> You can make anything the opposite using sarcasm however
15:30:16 <awpr> sheepfleece: actually I can't seem to convince GHC to compile either of those signatures
15:30:55 <awpr> `->` wants something of some kind `TYPE r`
15:31:51 <sheepfleece> Ah, sure, sorry, my real example uses proxies.
15:32:16 * hackage flat 0.4.4 - Principled and efficient bit-oriented binary serialization.  https://hackage.haskell.org/package/flat-0.4.4 (PasqualinoAssini)
15:32:34 <sheepfleece> So it should be something like `f :: forall (a :: k) b. Proxy a -> b` 
15:33:21 <Welkin> Monad is the best proxy
15:33:50 <awpr> I see -- I don't know of a way to explicitly introduce an invisible, dependent quantifier like that, although GHC will insert them implicitly in lots of contexts
15:35:09 <awpr> > :kind Coercible
15:35:11 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
15:35:52 <awpr> well, if that had worked, it'd have said: `Coercible :: k -> k -> Constraint`, which has an invisible quantifier of the sort you want
15:36:05 <sheepfleece> I see! Thank you. I wanted to use `[Type]` and `Type` in one place. However I can always just wrap a `Type` like so `@'[Int]`. 
15:36:22 <sheepfleece> It is just somewhat more noisy.
15:37:37 <awpr> actually I seem to have convinced GHC to make one: just drop the kind signature entirely and it'll infer the type you want
15:38:27 <awpr> `f :: forall a b. Proxy a -> b` has the invisible dependent parameter and infers it accordingly
15:39:15 <sheepfleece> Oh, it worked! Thank you! I have no idea why though. 
15:39:44 <awpr> with `PolyKinds` enabled it does some form of kind generalization that I don't understand thoroughly
15:40:13 <awpr> and since `Proxy` is poly-kinded, there's nothing forcing `a` to be of type `Type`, so it gets quantified
15:52:46 * hackage unicode-tricks 0.8.0.0 - Functions to work with unicode blocks more convenient.  https://hackage.haskell.org/package/unicode-tricks-0.8.0.0 (wvanonsem90)
16:39:07 <acertain> are all of containers and unordered-containers spine-strict?
16:41:49 <wavemode_> afaik, yes
16:46:41 <Cale> acertain: They more or less have to be, because you need to compare keys while building them
16:58:09 <Tritlo> If I have two phantom types `data L` and `data H`, and I want to "pretend" that I've solved (`H ~ L` or `L ~ H`) in a type checker plugin, what's the right `EvTerm` to use?
16:59:51 <Tritlo> The two types don't have any constructors, so they're phantom. I've been using `evCorecion $ mkReflCo Phantom anyTy` and it doesn't panic... but I don't know if that's the right choice.
17:03:38 <koz_> If I'm using RecordWildCards, and I've imported a module qualified as Foo, if I write 'bar Foo.Baz {..}', are the fields made available qualified or unqualified?
17:03:56 <koz_> So say, if Baz had a field quux, would it be available as Foo.quux, or just plain quux?
17:06:27 <Tritlo> koz_: just plain quux, Foo.quux would refer to the quux function in Foo.
17:06:44 <koz_> Tritlo: Interesting, and actually rather irritating in my case.
17:41:11 <edwardk> acertain:  Data.Sequence is not
17:41:37 <edwardk> same with Data.Tree
17:41:43 <edwardk> but the flagship entries are
17:42:27 <edwardk> Data.Sequence actually weaponizes laziness as part of its asymptotics (otherwise it loses a log factor). Data.Tree is just kinda slopped into the package
17:47:00 <wavemode_> hm why do the docs say Seq is strict in its length? or am i misunderstanding that
18:17:25 <koz_> :t guard
18:17:26 <lambdabot> Alternative f => Bool -> f ()
18:17:36 <koz_> % :info guard
18:17:37 <yahb> koz_: guard :: Alternative f => Bool -> f () -- Defined in `Control.Monad'
18:23:45 * hackage stackcollapse-ghc 0.0.1 - Program to fold GHC prof files into flamegraph input  https://hackage.haskell.org/package/stackcollapse-ghc-0.0.1 (rzeznik)
18:44:13 <quiet_laika[m]> anyone already using haskell-language-server? is it stable enough to pick over ghcide?
18:52:07 <dolio> shapr was saying he's using it a couple days ago.
18:54:31 <shapr> he still says that too!
18:55:03 <shapr> quiet_laika[m]: I'd suggest the 0.1 release, with implicit-hie https://github.com/Avi-D-coder/implicit-hie
18:55:09 <shapr> it works great inside emacs and vscode
18:55:12 <shapr> dunno about any others
18:55:37 <quiet_laika[m]> ill check it out :)
18:56:13 <shapr> quiet_laika[m]: it's still an early release, but I'm a big fan
18:56:39 <quiet_laika[m]> tbf ghcide is still pretty young
18:56:52 <shapr> quiet_laika[m]: I suggest joining #haskell-ide-engine where all the discussion happens and questions are answered about haskell-language-server and friends
18:57:10 <quiet_laika[m]> ooh ++
19:45:58 <srid> Cale: If I combine these two GADTs into a single one (`Query queryType r`) would that work with the TH stuff below? https://github.com/srid/neuron/blob/2d05fed0e93870c1d9d39b735bfdf39e446f7787/neuron/src/lib/Neuron/Zettelkasten/Query/Type.hs#L24-L35
19:46:32 <srid> `deriveGEq ''GraphQuery` is hardcoded to support 1-param GADTs
19:51:11 <srid> hmm, https://github.com/obsidiansystems/dependent-sum-template/blob/847d178795f139589d531425ddea40225cc8d90e/test/test.hs#L129-L149
19:54:57 <srid> not sure how that would work for aeson-gadt-th
19:55:46 <Cale> srid: There's a new version of the deriveGEq stuff that can handle multiparameter GADTs
19:56:15 <Cale> https://github.com/obsidiansystems/dependent-sum/pull/53
19:56:37 <srid> Cale: cool; but I'm stuck with the version in reflex-platform I guess? 
19:56:58 <Cale> It's possible to override that in the nix
19:57:23 <Cale> I think aeson-gadt-th is already upgraded in the same way
19:57:34 <Cale> I mean, sorry, that it supports multiparameter gadts
19:57:47 <Cale> I'm not sure which version is in reflex-platform at the moment
19:58:04 <srid> Cale: do you have an example for aeson-gadt-th, multi param? 
19:58:08 <srid> i can't find it here https://github.com/obsidiansystems/aeson-gadt-th/blob/develop/test/Test.hs
19:58:31 <Cale> I mean, it should just work
19:58:42 <Cale> You give it the name of the type like any other situation
19:59:16 <Cale> You're not allowed to have more than one index type though
19:59:21 <Cale> The rest need to be parameters
19:59:47 * srid uploaded an image: image.png (74KB) < https://matrix.org/_matrix/media/r0/download/matrix.org/MxRWeLoLRANejzJUoftgTvSb >
19:59:56 <srid> WIP ^ - but deriveJSONGADT - not sure about it
20:00:18 <Cale> Try just deriveJSONGADT 'Query
20:00:38 <srid> Not in scope: data constructor ‘Query’
20:00:51 <Cale> oh, ''Query, right
20:01:07 <Cale> (Probably 'Query_Foo would also work, but that's just confusing)
20:01:31 * srid uploaded an image: image.png (137KB) < https://matrix.org/_matrix/media/r0/download/matrix.org/gwWxtTkqbpBVAucfXcJxbNPA >
20:01:36 <Cale> Oh, but this won't work because you have two indices
20:01:57 <Cale> You're not allowed to have more than one index in the kinds of instances it knows how to write
20:02:14 <srid> The other one is giving me: tyConArity': Supplied name reified to something other than a data declaration: Neuron.Zettelkasten.Query.Type.Query_Foo
20:02:23 <Cale> ah, interesting
20:02:31 <Cale> ahhhh
20:02:47 <Cale> It's still using that bit of shenanigans even though it's using th-abstraction elsewhere
20:03:02 <Cale> good to know, at some point I should fix that
20:03:31 <Cale> but yeah, it doesn't know how to deal with writing an instance because it would need more than just Some, or nested layers of Some to write the FromJSON instance
20:03:57 <Cale> You'd be deserialising Some (Some Query)
20:04:13 <Cale> and it's not set up to predict that (and it might be confusing even if it did)
20:04:23 <Cale> I suppose it's possible though
20:05:13 <srid> The first parameter would ideally be a different kind (a kind with only two possible types, each uninhabited)
20:05:27 <srid> The idea is that I'm differentiating between two different kinds of queries.
20:05:47 <srid> Writing functions that operate on one or the other (but not both), while still unifying with the query result type (the second parameter) uniformly
20:05:59 <Cale> (I renamed the issue you made -- the issue we're having there is that tyConArity' gets confused if you name a data constructor of a type rather than the name of the type, and there's no reason it ought to
20:06:00 <Cale> )
20:06:19 <Cale> btw, the first thing there is not a parameter, it's an index
20:06:27 <Cale> because you're specifying it in the data constructors
20:06:45 <Cale> Though, the issue is made blurry what with equality constraints
20:07:11 <Cale> The thing which is not supported at present is more than one index, or an index which is not the last argument to the type
20:09:56 <srid> I could create a 'wrapper' GADT, with a constructor like `Query_Zettel :: ZettelQuery r -> Query r` - but then I'm hitting https://github.com/obsidiansystems/aeson-gadt-th/issues/8
20:10:40 <srid> I think it wants me to use `Some ZettelQuery` - which means I can't unify the `r` anymore.
20:11:05 <srid> deriveGEq and friends work though!
20:11:10 <Cale> Sometimes if the types get complicated, you just have to write some instances by hand
20:11:23 <Cale> because they're not going to be very mechanical
20:11:51 <Cale> Did you see my comments on the other issue?
20:12:03 <Cale> or, on the issue you linked ;)
20:12:29 <Cale> The error messages when the type isn't one that deriveJSONGADT knows how to deal with kind of suck
20:13:07 <srid> You are saying that when writing manual instances, the ambiguity becomes clear (so as to illustrate the trickiness of automatic TH derivation)?
20:13:15 * hackage pontarius-xmpp 0.5.6.2 - An XMPP client library  https://hackage.haskell.org/package/pontarius-xmpp-0.5.6.2 (SergeyAlirzaev)
20:14:22 <Cale> yeah
20:15:07 <Cale> and sometimes there are additional tricks you can pull
20:15:17 <Cale> like that "OK" thing in the comments on #8
20:15:32 <srid> Okay, I'll try writing a manual instance as next step when there is a strong need to refactor this.
20:15:32 <kwannoel> is Hoogle down for anyone else?
20:15:34 <Cale> which I don't think it'll ever really be able to do itself
20:16:11 <Cale> (At least, it's hard to know when pattern matching on arguments would solve a problem with the types...)
20:16:34 <Cale> seems up for me
20:16:42 <Cale> https://hoogle.haskell.org/?hoogle=map
20:16:46 <Cale> at least that link is working
20:16:54 <srid> In my case too that OK trick will work. Just knowing the constructor name is enough should be enough?
20:17:27 <Cale> In your case, the trickiness isn't quite the same, but rather just that you can't have FromJSON (Some (Query t))
20:17:38 <Cale> but you could have  FromJSON (Some (Some Query))
20:18:16 <srid> Right
20:18:29 <srid> This is the multiparam case
20:18:37 <Cale> and since it doesn't even know to try to write an instance like that, it's just totally confused
20:19:11 <Cale> One thing you could do is to define Fst and Snd type families (or maybe more domain-specific names) and just pair the types up
20:20:00 <Cale> So you'd have something like:
20:20:04 <Cale> data Query i where
20:20:30 <Cale>   Query_Foo :: Query (String, Int)
20:20:33 <Cale> or perhaps
20:20:43 <Cale>   Query_Foo :: Query (Interface String Int)
20:21:01 <Cale> or I don't know, some better name based on what relationship String and Int have with each other here
20:21:18 <Cale> and then type families to get the parts back out
20:21:28 <srid> Query_Foo :: Query (InputSource, OutputType)
20:21:52 <srid> Essentially that's what the two types are: type of input it queries, and the type of results
20:21:58 <Cale> yeah
20:22:25 <Cale> So you could make that an empty data type that only gets used in these indices
20:22:28 <srid> And the individual constructors are the app logic specific query types that gets used in all sorts of places (in one place, URI is parsed in query type, and another place optparse-applicative parses the cli arguments to query type)
20:22:37 <Cale> data Interface in out
20:22:46 <Cale> type family Input t
20:22:49 <Cale> er
20:22:55 <Cale> type family Input t where
20:23:23 <Cale>   Input (Interface in out) = in
20:23:33 <Cale> type family Output t where
20:23:40 <Cale>   Output (Interface in out) = out
20:23:53 * srid uploaded an image: image.png (121KB) < https://matrix.org/_matrix/media/r0/download/matrix.org/ISnGsvHSRcgdgBrvTLooSnSJ >
20:23:55 <srid> incidentally i already use type-families in the route type, to unify willy-nilly gadt constructors ^^ 
20:25:02 <srid> Cale:thanks, I'll give that approach a try!
20:25:45 <Cale> Type families are kind of annoying, so I can't say I 100% love my own suggestion here, but it's worth a shot
20:27:22 <srid> I have had to tear out type famillies code in the past to simplify things. In some cases they seem inevitable 
20:38:45 * hackage aeson 1.5.0.0 - Fast JSON parsing and encoding  https://hackage.haskell.org/package/aeson-1.5.0.0 (AdamBergmark)
20:45:36 <Shiranai> Probably has been asked a million times, but I'll still ask: how useful is category theory for learning haskell?
20:46:44 <awpr> lots of answers to that -- in any case, strong knowledge of category theory is absolutely not required for learning Haskell
20:46:46 <dmj`> Shiranai: it's detrimental
20:47:04 <awpr> for learning the semantics of the language: little to no value
20:47:28 <Shiranai> oh so what is it good for then?
20:47:54 <awpr> for learning a particular hierarchy of typeclasses (Functor, Applicative, Monad, Category, Arrow): it's a huge step towards already knowing all of these
20:48:20 <dmj`> Shiranai: If you want to learn category theory, learn category theory. It might help you think more abstractly. Haskell typeclasses implement algebraic structures with laws that you can prove correct by equational reasoning for a variety of algebra data types (usually looks like turning the right hand side into the left).
20:48:44 <dmj`> algebraic*
20:48:59 <Shiranai> interesting, thanks!
20:49:11 <awpr> basically a lot of ideas from category theory have been wedged into ubiquitous Haskell libraries in various forms, so if you already know them, you have a head start
20:50:16 <awpr> beyond that, it's extremely helpful for recognizing patterns even when they aren't explicitly copied from category theory, and getting intuitions about how they behave for free
20:50:34 <dmj`> Shiranai: In order to keep haskell from becoming too successful, haskell people will say category theory is required.
20:50:36 <awpr> but that's sort of the general sales pitch for category theory and not specific to Haskell
20:56:52 <kamek> I have to manipulate a bunch of Eithers in tests, I'd like to unwrap the left or right members and throw if that fails. Is there a standard function I'm missing ?
20:57:40 <awpr> `either (error . show) id` does okay at that if you do actually want to raise errors
20:58:29 <fpaulw> I don't know category theory, and am still learning Haskell. But having a good intuition for applicatives, functors, monads, etc. and how they all relate seems like it would come free with category theory. But I don't see a need to learn category theory specirically. Much like I don't see a need to learn cryptography to understand public and private keys, for example
20:58:46 <ja> you can also use sequenceA to make a list of eithers into an either of list
20:59:19 <MarcelineVQ> a bunch of eithers? possibly ExceptT depending what you're then doing with the Right's
21:01:22 <kamek> I would have likes something like Rust's unwrap, I don't see anything like it in base
21:01:27 <c_wraith> if this is for testing and you expect Left or Right values, why not compare to Left or Right values?
21:02:17 <kamek> they are somewhat complex constructs, records holding nested eithers
21:02:34 <c_wraith> that sounds like something has gone wrong already
21:02:47 <kamek> could be yeah
21:03:32 <awpr> I like how the answer to every question in Haskell is "wait, you did something wrong 15 commits back"
21:03:47 <c_wraith> though if that structure is right, and you are testing particular points inside a nested data structure, that's often what lens is for.
21:04:22 <ja> just read yesterday in the lens book that you can get all elements of a certain type out with uniplate
21:04:25 <ja> mind blown :O
21:04:31 <ja> s/lens/optics/
21:04:36 <c_wraith> well, as long as everything is an instance of Data
21:04:41 * awpr avoids *plate stuff whenever possible
21:13:38 <jle`> i mostly just use it for AST manipulations, where writing traversals by hand can be tedious
21:14:44 <d34df00d> stripAnnotations = transformBi $ const mempty
21:14:48 <d34df00d> Isn't it cool?
21:15:14 <awpr> yeah, it's good for visiting all of something in ASTs, but I still feel dirty when I use it
21:16:16 <awpr> er, does that fail to typecheck with an ambiguous type, or does it eradicate all values that happen to have Monoid instances?
21:18:13 <jle`> yeah, there's definitely a trade-off you have to consider
21:28:33 <saxon> i am trying to build a terminal file manager. in your experience, what is the best curses lib to use?
21:28:40 <d34df00d> It's actually more complicated than that (`mempty` appears in a context that makes it monomorphic), so it's fine.
21:28:57 <d34df00d> Everybody's tryingto build terminal things and nobody's building initial things :(
21:29:00 <d34df00d> 0 needs its love too!
21:29:36 <saxon> d34df00d: command line file manager i mean :)
21:30:42 <saxon> d34df00d: like ranger but less bloat. using perl coz not sure of curses lib in haskell. thought u guys could help?
21:31:28 <c_wraith> saxon: brick is the most common choice, I think
21:35:58 <saxon> c_wraith: this looks cool. dunno why didnt hear of this earlier? thank you guys. time to impress the potential interviewers :)
21:38:45 <Cale> Dang, missed my chance to recommend reflex-vty, haha
22:12:42 <dsal> I actually kind of need something fancy for a TUI.  Mainly just a block progress indicator thing.
22:13:30 <dsal> My gopro uploader uploads multiple media files concurrently (with each file being uploaded concurrently).
22:22:44 <crestfallen> > ff = fmap (*10) [4,5]
22:22:46 <lambdabot>  <hint>:1:4: error:
22:22:46 <lambdabot>      parse error on input ‘=’
22:22:46 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
22:23:08 <crestfallen> @let ff = fmap (*10) [4,5]
22:23:10 <lambdabot>  Defined.
22:23:14 <crestfallen> ff
22:23:22 <crestfallen> > ff
22:23:24 <lambdabot>  [40,50]
22:24:24 <crestfallen> @let gg = fmap (*10) [(Just 4), (Just 5)]
22:24:25 <lambdabot>  Defined.
22:24:32 <crestfallen> gg
22:24:39 <crestfallen> > gg
22:24:42 <lambdabot>  error:
22:24:42 <lambdabot>      • No instance for (Num (Maybe Integer)) arising from a use of ‘e_1’
22:24:42 <lambdabot>      • In the expression: e_1
22:25:04 <crestfallen> :t gg
22:25:05 <lambdabot> (Num a, Num (Maybe a)) => [Maybe a]
22:25:35 <{abby}> % fmap (fmap (* 10)) [Just 4, Just 5]
22:25:35 <yahb> {abby}: [Just 40,Just 50]
22:26:12 <crestfallen> thanks abby you need 2 fmaps
22:26:33 <crestfallen> {abby} 
22:28:15 * hackage calamity 0.1.9.3 - A library for writing discord bots  https://hackage.haskell.org/package/calamity-0.1.9.3 (nitros12)
22:28:45 <crestfallen> {abby} why would my gg compile then?
22:28:55 <{abby}> :t (10*)
22:28:56 <lambdabot> Num a => a -> a
22:29:33 <{abby}> crestfallen: functions like (+) and (*) work for any type that implement Num, and the compiler has no reason to assume that, even though there's no instance for Num (Maybe sth) right now, there can't be one in the future
22:30:51 <crestfallen> you mean like if I did:
22:31:16 <crestfallen> > fmap gg
22:31:17 <lambdabot>  error:
22:31:18 <lambdabot>      • Couldn't match expected type ‘a -> b’
22:31:18 <lambdabot>                    with actual type ‘[Maybe Integer]’
22:31:36 <crestfallen> @let tt = fmap
22:31:37 <lambdabot>  Defined.
22:31:59 <crestfallen> @let ss = tt gg
22:32:00 <lambdabot>  .L.hs:186:9: error:
22:32:00 <lambdabot>      • Couldn't match expected type ‘a -> b’
22:32:00 <lambdabot>                    with actual type ‘[Maybe Integer]’
22:32:35 <{abby}> % instance Num a => Num (Maybe a) { fromInteger = pure . fromInteger; (+) = liftA2 (+); (-) = liftA2 (-); negate = fmap negate; signum = fmap signum; abs = fmap abs; (*) = liftA2 (*) }
22:32:35 <yahb> {abby}: ; <interactive>:40:47: error: parse error on input `='
22:32:41 <{abby}> oh yeah
22:33:00 <{abby}> % fmap (*10) [(Just 4), (Just 5)]
22:33:00 <yahb> {abby}: [Just 40,Just 50]
22:33:15 <{abby}> crestfallen: if you define an instance for Num (Maybe a) then your expression gg works
22:33:41 <{abby}> that's what the type (Num a, Num (Maybe a)) => [Maybe a] tells you
22:34:12 <{abby}> (I defined the instance Num (Maybe a) in a private message as so to not spam the channel further, but the code is essentially the one I pasted above, with a ``where'' inserted before the opening braces)
22:35:02 <crestfallen> sorry could you kindly pm me with what your did?
23:21:52 <liiae> what this does [a,b,c,d] = map (*2) [1,a,b,c]
23:22:02 <liiae> d == 16
23:22:58 <liiae> aha
23:23:12 <Cale> Well, d = c*2, and c = b*2, and b = a*2, and a = 1*2
23:23:26 <liiae> a = 2, b =2 a, c=2b, d=2c
23:23:33 <Cale> yeah
23:24:12 <liiae> Cale: why this can happen? 
23:24:34 <frobnicator> isn't is beautiful
23:24:36 <liiae> Cale: in other languages, this is possible?
23:25:40 <Cale> liiae: Well, lazy evaluation makes this kind of thing a little easier.
23:26:24 <liiae> Cale: yeah, a is not defined in JS
23:26:29 <Cale> I don't know if any eagerly evaluated languages support this kind of recursive definition of data structures.
23:27:30 <Cale> > let primes = 2 : filter isPrime [3,5..]; isPrime n = all (\p -> n `mod` p /= 0) (takeWhile (\p -> p*p <= n) primes) in primes
23:27:32 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
23:28:26 <Cale> There's a recursive definition of the infinite list of primes alongside a function which checks if a number is prime by checking that all the primes less than or equal to the number's square root don't divide it.
23:29:16 <liiae> > let fibs = 0: 1: zipWith(+) fibs (tail fibs) in fibs
23:29:18 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
23:30:15 * hackage byte-count-reader 0.9.0.0 - Read strings describing a number of bytes like 2Kb and 0.5 MiB  https://hackage.haskell.org/package/byte-count-reader-0.9.0.0 (danielrolls)
23:36:41 <liiae> > let s (x:xs) = x : s [ i | i <- xs , mod i x /=0] in s [2..]
23:36:43 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
23:39:35 <liiae> > fix $ scanl (+) 0 . (1:)
23:39:37 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
23:39:51 <koz_> For optparse-applicative, how do I make a strOption optional? Basically, I wanna say 'try and parse, and give me Just if you do, Nothing otherwise'?
23:41:20 <liiae> > let as = map (*2) (1:as) in as
23:41:22 <lambdabot>  [2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,262...
23:49:03 <dsal> koz_: I've done it with maybeReader
23:50:06 <dsal> `optMQTTLWTTopic  :: Maybe Text`    [...]   `<*> option mt (long "mqtt-lwt-topic" <> showDefault <> value Nothing <> help "mqtt last will topic")`  [...] `mt = maybeReader $ pure.pure.pack`
23:53:12 <dsal> (I wrote that code a long time ago.  It may be dumb, but it does do the thing you asked)
23:54:32 <sshine> I can't think of a smarter way. 'Maybe String' doesn't have the instance of IsString. I've only had to provide strOption that had default values.
23:57:33 <sshine> koz_, https://stackoverflow.com/questions/32422339/how-to-parse-an-optional-flag-as-a-maybe-value
23:59:01 <sshine> koz_, that was easier than I thought. :-D
23:59:44 <liiae> what this `.' in scanl (+) 0 . (1:)?
