00:00:10 <iqubic> I mean, I also understand the last one too, because that's the simplest one.
00:00:13 <siraben> iqubic:  Ah, so that example just uses the length of a list to encode a natural number.
00:00:46 <siraben> listprod takes the cartesian product of two lists n and m, resulting in a list of size n*m
00:01:02 <monochrom> "arb = arb" would be great haha
00:01:18 <siraben> data Nat = Z | S Nat is isomorphic to [()]
00:01:29 <iqubic> Ah, Right that's a clever way of doing it.
00:02:31 <siraben> The other ones include creating an interpreter for a dynamically-typed language, doing type level factorial, using cata/ana/hylo-morphisms and so on.
00:04:31 <iqubic> I see.
00:05:46 <monochrom> haha "hylomorphism, unfolded"
00:06:09 <siraben> Speaking of recursion schemes, Algebra of Programming claims to only need an intro to FP and some math, but in reality requires a lot of math, IMO worth the content though, have a few chapters left which get deep into this relational view of programs to solve problems.
00:07:59 <iqubic> Is that a book?
00:08:24 <monochrom> It's a pretty short and small book.
00:08:34 <monochrom> Smaller than HFFPP
00:08:43 <monochrom> even smaller than Bird's other FP books.
00:09:28 <iqubic> What is HFFPP
00:09:40 <monochrom> the haskellbook.com one
00:09:45 <p0a> looks interesting 
00:09:49 <p0a> algebra of programming I mean
00:09:52 * MarcelineVQ changes monochrom's name to google
00:10:30 <siraben> monochrom: Algebraic and Coalgebraic Methods in the Mathemaitcs of Program Construction is interesting
00:10:31 <monochrom> monogle
00:10:38 <siraben> s/Mathemaitcs/Mathematics
00:10:39 <MarcelineVQ> HPFFPPFPFFFPFPPFPF
00:11:10 <tukane> How different is TypeApplications from type instantiation in System F?
00:11:51 <monochrom> TypeApplication lives in a language that is not quite System F
00:12:23 <monochrom> I don't think there is a moral difference.
00:12:47 <tukane> thanks. what is that language called specifically?
00:13:00 <siraben> Core?
00:13:00 <monochrom> apart from what I said about "not living in System F" such as: being optional, having fix.
00:13:11 <monochrom> Haskell.
00:21:55 <p0a> I still havent' understood this 
00:22:20 <p0a> if I want a function odd'  that works like odd except odd' 1 ==> Just 1 and odd' 2 ==> Nothing
00:22:25 <p0a> How do I do that? Is that `ensure' ?
00:22:34 <p0a> no wait
00:22:59 <monochrom> It is "ensure odd"
00:23:14 <p0a> Okay, thank you 
00:23:14 <siraben> What's ensure?
00:23:15 <siraben> :t ensure
00:23:17 <lambdabot> error: Variable not in scope: ensure
00:23:21 <p0a> it was defined above 
00:23:27 <monochrom> If you use it on the elements of a list, it's map (ensure odd)
00:23:27 <siraben> Ah
00:23:37 <p0a> ensure p x = x <$ guard (p x)
00:23:45 <p0a> Got it, thanks mono
00:24:03 <p0a> but who defines `guard' ?
00:24:06 <p0a> it says `guard' is undefined 
00:24:10 <monochrom> Control.Monad
00:24:14 <p0a> got it, ahnk you 
00:24:20 <koz_> % :info guard
00:24:20 <yahb> koz_: guard :: Alternative f => Bool -> f () -- Defined in `Control.Monad'
00:24:25 <p0a> Oh, nice
00:29:47 <NGravity> To unloop list you have to loop it 2 times , one time to extract and remove duplicate lines, second time is to extract first line matching duplicates in single line, so 2 loops are needed anyway
00:33:06 <Axman6> what does unlooping a list mean?
00:33:56 <iqubic> No clue.
00:34:08 <p0a> let's just say it won't be around anymore
00:35:20 * hackage zeolite-lang 0.4.0.0 - Zeolite is a statically-typed, general-purpose programming language.  https://hackage.haskell.org/package/zeolite-lang-0.4.0.0 (ta0kira)
00:37:20 <siraben> % :info foldM
00:37:20 <yahb> siraben: foldM :: (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m b -- Defined in `Control.Monad'
00:37:29 <siraben> Huh why don't I see foldM in my Control.Monad
00:37:45 <siraben> Control.Monad.foldM is there, but importing Control.Monad doesn't bring it into scope.
00:38:46 <siraben> Nevermind, had to import in GHCi
00:38:49 <pdxleif> Somewhat curious why `fromGregorian` takes an Integer for the year. Date values past the extinction of the universe weren't big enough?
00:39:00 <Axman6> no
00:43:42 <pdxleif> I guess theoretically, time is infinite?
00:45:35 <p0a> whats your practical evidence to the contrary anyway
00:50:48 <pdxleif> celestial events that will wipe out all life on the planet. and beyond that, some physics happens... https://en.wikipedia.org/wiki/Timeline_of_the_far_future
00:51:29 <p0a> "[..] as postulated [..]"
00:52:44 <MarcelineVQ> pdxleif: you sidestep overflows launching your nukes earlier than running out of memory would
00:55:53 <pdxleif> I guess the Day type is a newtype wrapper around Integer, anyways...
01:09:11 <sshine> hey siraben :)
01:09:32 <siraben> Hello sshine
01:09:49 <sshine> siraben, evm-lang-design, right?
01:10:27 <siraben> sshine: Indeed.
01:15:14 <p0a> I am literally doing a triple asum and a traverse inside of it
01:15:17 <p0a> lol
01:25:18 <dmj`> monochrom:  Canonicalize (a :> (b :<|> c)) = ((a :> Canonicalize b)  :<|>  (a :> Canonicalize c))
01:25:33 <dmj`> found this trick to reassociate a type to be right associative
01:27:50 * hackage roundtrip 0.2.0.7 - Bidirectional (de-)serialization  https://hackage.haskell.org/package/roundtrip-0.2.0.7 (StefanWehr)
01:31:19 <p0a> okay
01:31:23 <p0a> now that I completed my program 
01:31:27 <p0a> well, some interesting parts of it
01:31:48 <p0a> it was fun learning Haskell so I think the next step should be for me to read a nice intro to Haskell
01:32:15 <p0a> this course impressed me as good: https://crypto.stanford.edu/~blynn/haskell/ so I will give it a try right now
01:34:24 <MarcelineVQ> next step after learning is making :>
01:34:35 <davve> 3/18
01:35:06 <MarcelineVQ> 1/6
01:35:46 <p0a> MarcelineVQ: making?
01:35:56 <MarcelineVQ> write a program
01:36:18 <p0a> well I wrote a program
01:36:27 <p0a> I mean it's something esoteric that only I will use but yeah
01:37:13 <p0a> MarcelineVQ: some time ago I started learning Yesod in hopes of creating a service I had in mind
01:37:47 <p0a> then I gave up realizing how little I understood of Haskell. Maybe in the near future I'll do it tho
01:45:49 <[exa]> p0a: try scotty? (it's less intensive)
01:46:19 <p0a> [exa]: based on the features I realized Yesod has
01:46:22 <p0a> I sort of was enlightened 
01:46:34 <p0a> it looks really promising
01:46:47 <p0a> so I'm hoping to use Yesod 
01:47:02 <[exa]> ok great :] you seemed overwhelmed a bit
02:03:24 <fendor> I know this is a horrible idea, but can I define a type conditionally, e.g. only if this type (by name) isnt already in scope?
02:03:43 <dibblego> then why do it?
02:04:03 <fendor> The context, student submissions that might not define all the types that I need for defining test-data
02:04:24 <fendor> and the requirement wasnt rigid enough to define that all submissions *must* define the types
02:06:11 <DigitalKiwi> fendor: how many submissions are there
02:06:29 <fendor> DigitalKiwi, 14, but it should scale to over 300
02:06:56 <DigitalKiwi> do it by hand and in the future change the requirements? :D
02:07:01 <dibblego> ah this problem, I have it too, parse the source?
02:07:09 <DigitalKiwi> though i'd just write a script that...yeah
02:07:37 <p0a> unfortunately that stanford page refers to google's codejam which has been updated and the archive link doesnt work
02:07:39 <p0a> too bad
02:09:04 <p0a> easiest thing to do is just give everyone the credit
02:10:01 <fendor> dibblego, what are the steps then?
02:10:31 <fendor> when I have one test-suite and a submission file
02:12:33 <p0a> google rm -rf'd everything, https://code.google.com/codejam/past-contests
02:12:36 <p0a> what the hell
02:14:47 <fendor> oh, I have a truly horrible solution. Surround test-data with th, and check for an unbound (type-)variable, if there is some, replace function definition with `error "Undefined type"`
02:26:05 <dibblego> fendor: I have not attempted to solve this problem, but if I had to, I'd consider parsing the source
02:28:01 <dibblego> chanserv deop #haskell dibblego 
02:28:03 --- mode: ChanServ set -o dibblego
02:28:04 <fendor> dibblego, I did so, too, but I just dont see the workflow.
02:28:06 <dibblego> sorry
02:32:13 <DigitalKiwi> bash script grep the source for the types sed them in if they're not there
02:32:36 <DigitalKiwi> do that before you pass it to your test suite
02:33:43 <DigitalKiwi> here "bash script grep" is not ideal and probably not what you'd actually do. substitute real parsing in...
02:35:21 <DigitalKiwi> then again if it works...if...
02:41:20 * hackage wstunnel 0.1.0.0 - Initial project template from stack  https://hackage.haskell.org/package/wstunnel-0.1.0.0 (erebe)
02:42:13 <DigitalKiwi> i mean ideally you'd give them enough of a stub file and clear requirements of what is required and depending on how you're scoring it if they don't meet that it's complete fail or you try and figure out what they left out and give partial credit. if it's automated enough that they can submit their answers and get feedback then there aren't so many surprises...they know they failed :P
02:42:19 * hackage wstunnel 0.3.0.0 - Initial project template from stack  https://hackage.haskell.org/package/wstunnel-0.3.0.0 (erebe)
02:43:25 <fendor> DigitalKiwi, yeah, I would prefer the real stub file, too
02:43:39 <DigitalKiwi> https://www.coursera.org/learn/programming-languages this course is not only good imo but might have some insight into how you could do things
02:44:38 <DigitalKiwi> that's the first of 3 sections of the course. goes from SML to racket to ruby
02:44:49 <DigitalKiwi> so basically just do the first two sections :D
02:45:54 <loyon[m]> is there a way to parse and generate nix configuration using haskell? like a DSL library or something of this kind?
02:46:03 <DigitalKiwi> hnix
02:46:12 <DigitalKiwi> https://github.com/haskell-nix/hnix
02:46:25 <loyon[m]> DigitalKiwi: awesome :) my duckduckgo fu was failing, thanks
02:46:49 <DigitalKiwi> yw
03:00:30 <__monty__> Afaik you'd have to build said DSL on top of hnix.
03:00:52 <__monty__> It's just a nix implementation in haskell. Going from nix source to nix derivations.
03:04:50 <p0a> any good ways to learn about monads, applicatives, functors etc?
03:08:43 <Taneb> p0a: I recommend https://wiki.haskell.org/Typeclassopedia
03:08:46 <[exa]> p0a: depends on the amount of background and intuition you already have. I'd start by looking at the definition and applications of Functor, then the same with Applicative, then the same with Monad
03:12:01 <p0a> [exa]: where would you look for those?
03:12:05 <p0a> Taneb: thank you 
03:13:55 <[exa]> p0a: well, typeclassopaedia is a good start; various other courses (including LYAH) may help for intuition. Ask here for tricky questions :] (Like, functors are kinda like containers, but why ordered sets aren't functors?)
03:16:06 <p0a> lyah?
03:16:11 <p0a> oh learn you ahaskell, sure
03:16:30 <p0a> wow that wiki page is massive
03:16:49 <p0a> looks really good
03:17:51 <p0a> im gonna read until I get a cool idea
03:18:00 <p0a> then imma jog to the grocery store
03:18:40 <[exa]> buy tortillas, you'll find a good use for them
03:18:55 <p0a> huh? :D
03:18:57 <[exa]> </bad_monadic_wrapper_jokes>
03:19:21 <p0a> you inspired me to make enchiladas
03:19:57 <Taneb> p0a: the joke [exa] is making is referring to an old, not very useful, much parodied explanation of monads which compare them to burritos
03:20:20 <[exa]> ok for reference, https://blog.plover.com/prog/burritos.html
03:20:59 <Taneb> (fun fact: this is how I learnt what a burrito is)
03:21:37 <bjs> this is sadly probably a true statement
03:21:44 <p0a> in 3030 when people understand food in non-pill form via haskell references
03:33:33 <p0a`> if Maybe is a Functor
03:33:36 <p0a`> then what is Either?
03:33:56 <p0a`> `Either e' is an instance of a Functor, okay. But what about `Either' alone?
03:35:00 <__monty__> Nothing? It's like tuples, (a,) is a functor (,) isn't.
03:36:19 <Taneb> p0a`: we can call it a "Bifunctor", because we can map over both the first parameter and the second
03:41:17 <p0a`> thank you 
03:48:48 <siraben> How do I get the fractional part of a fractional in Haskell?
03:49:43 <siraben> > (1.5 - fromIntegral (floor (1.5)))
03:49:46 <lambdabot>  0.5
03:50:14 <siraben> :t (fromIntegral . floor) `on` (-)
03:50:16 <lambdabot> (RealFrac (a -> a), Num c, Num a) => a -> a -> c
03:50:44 <siraben> :t (-) `on` (fromIntegral . floor)
03:50:45 <lambdabot> (RealFrac a, Num c) => a -> a -> c
03:51:01 <siraben> Oops anyway
03:51:14 <p0a`> can't you do x - truncate x
03:52:02 <p0a`> also snd . properFraction
03:53:47 <p0a`> "Give an example of a kind * -> * which cannot be made an instance of Functor". How do I do that?
03:54:24 <__monty__> p0a`: Probably start from the laws. Figure out how they could not hold.
03:54:45 <p0a`> what do you mean by law?
03:55:00 <__monty__> The functor laws.
03:55:19 <p0a`> I have the definition as fmap :: (a -> b) -> f a -> f b, is that it?
03:55:20 <__monty__> https://wiki.haskell.org/Typeclassopedia#Laws
03:55:33 <p0a`> thanks
03:55:39 <__monty__> Oh, that's what you're supposed to get to >.<
03:56:44 <p0a`> what about this: "The composition of two Functors is also a Functor?"
03:57:04 <p0a`> From my math background I want to say yes but I Am not sure what is being composed here
03:57:18 <p0a`> oh, f1 (f2 a) ?
03:57:25 <p0a`> goooooot it, nevermind
03:57:48 <p0a`> I Was tryign to compose fmap 
04:01:34 <timCF> Hello guys! Am I reinventing the wheel? Is there some standard Haskell type class which is already doing similar things? https://gist.github.com/tim2CF/b6f7be262c4b4e7c26e60550f405c787
04:02:55 <Taneb> timCF: I think that's a bit of a square wheel to reinvent
04:03:05 <Taneb> (it's been done before and doesn't work well as things get larger)
04:04:13 <timCF> well, maybe not exactly like this. It could return `Maybe a` or `Maybe b` for example (it's not isomorphism but sill might be very useful)
04:06:20 * hackage wstunnel 0.3.0.1 - Initial project template from stack  https://hackage.haskell.org/package/wstunnel-0.3.0.1 (erebe)
04:07:49 <sshine> timCF, like this? http://hackage.haskell.org/package/type-iso-1.0.1.0/docs/Data-Types-Isomorphic.html
04:08:10 <sshine> timCF, it seems that there are several attempts at this.
04:09:46 <timCF> sshine yes, thanks
04:10:23 <sshine> timCF, also this: https://hackage.haskell.org/package/control-iso-0.1.0.2/docs/Control-Isomorphic.html
04:11:05 <sshine> timCF, and here's a discussion of why you may want/not want this class: https://www.reddit.com/r/haskell/comments/56ycvi/standard_isomorphism_class/
04:11:45 <sshine> timCF, the tl;dr against it is: too much overloading can also be inconvenient
04:12:58 <sshine> timCF, in particular, this comment sums it up nicely: https://www.reddit.com/r/haskell/comments/56ycvi/standard_isomorphism_class/d8njh5p/
04:16:09 <typetetris> what is a cradle?
04:17:15 <timCF> thanks sshine)
04:23:46 <siraben> p0a`:  Here's an example, data ReaderB a s = ReaderB (s -> a)
04:24:02 <siraben> It's a contravariant functor, but no covariant.
04:37:22 <tukane> why doesn't ScopedTypeVariables resolve the ambiguity in this code? isn't `a` in `String -> a` supposed to refer to the `a` of `forall`? normalizePoly :: forall a. (Show a, Read a) => String -> String 
04:37:22 <tukane> normalizePoly x = show ((read :: String -> a) x)
04:43:32 <hpc> how does the caller select the a?
04:44:01 <Axman6> normalizePoly @a
04:44:12 <Axman6> (I want this but probably isn't a thing)
04:44:21 <hpc> yeah, i don't think it's a thing
04:44:27 <hpc> since a doesn't occur in the type itself
04:44:58 <hpc> maybe newtype ShownString a = ShownString String
04:45:01 <hpc> or something like that
04:45:15 <hpc> but as-is, it won't work
04:47:45 <tukane> for a little bit of context, i've come across that piece of code in the paper that introduced TypeApplications: https://www.seas.upenn.edu/~sweirich/papers/type-app-extended.pdf
04:48:51 <tukane> hpc: i'm not sure if i have sufficient knowledge about the type system to understand what's going on, but can't `a` in String->a be `a` in the `a` the parameter?
04:58:56 <hpc> tukane: it's not in the top-level type signature
04:59:12 <hpc> you effectively have normalizePoly :: String -> String
04:59:31 <hpc> try defining it as a hard-coded string instead of show/read, and :t it in ghci
05:02:15 <fog51> tukane: it needs a proxy type
05:02:36 <fog51> to make sure a appears in the type signature
05:03:05 <_Cactus_> I'm writing a library of reusable Setup.hs parts, and I would like to configure them via the .cabal file. What is my best bet of getting some custom per-executable/per-library setting all the way to the build hook?
05:03:08 <fog51> then instead of using type applications, you supply Proxy :: Proxy a
05:04:06 <fog51> % normalizePoly :: forall a. (Show a, Read a) => Proxy a -> String -> String ; normalizePoly _ x = show ((read :: String -> a) x)
05:04:06 <yahb> fog51: 
05:04:41 <fog51> % normalizePoly (Proxy @Int) "1"
05:04:42 <yahb> fog51: "1"
05:04:50 <_Cactus_> fog51: or the cleaner 'normalizePoly _ = show . read @a'
05:05:10 <fog51> yeah
05:06:08 <fog51> data Proxy a = Proxy
05:06:32 <MarcelineVQ> normalizePoly "foo"     which 'a' doâ€‹ I have here?
05:06:40 <fog51> so thats kind of like adding the phantom parameter `a' to a newtype as mentioned by hpc
05:07:20 <fog51> MarcelineVQ: probably just String, unless there is a read instance to something that can read "foo"
05:08:36 <fog51> or maybe something like Bytestring...
05:09:04 <fog51> % normalizePoly (Proxy @Bytestring) "foo"
05:09:05 <yahb> fog51: ; <interactive>:115:23: error:; Not in scope: type constructor or class `Bytestring'; Perhaps you meant one of these: `BSL.ByteString' (imported from Data.ByteString.Lazy), `BS.ByteString' (imported from Data.ByteString), `IsByteString' (imported from Data.ByteString.Lens)
05:09:17 <fog51> % normalizePoly (Proxy @BLS.ByteString) "foo"
05:09:18 <yahb> fog51: ; <interactive>:116:23: error:; Not in scope: type constructor or class `BLS.ByteString'; Perhaps you meant one of these: `BSL.ByteString' (imported from Data.ByteString.Lazy), `BS.ByteString' (imported from Data.ByteString), `BSLC.ByteString' (imported from Data.ByteString.Lazy.Char8); No module named `BLS' is imported.
05:09:25 <fog51> wow,sry
05:10:11 <fog51> % normalizePoly (Proxy @Data.ByteString) "foo"
05:10:12 <yahb> fog51: ; <interactive>:117:23: error:; Not in scope: type constructor or class `Data.ByteString'; Perhaps you meant one of these: `BSL.ByteString' (imported from Data.ByteString.Lazy), `BSLC.ByteString' (imported from Data.ByteString.Lazy.Char8), `BS.ByteString' (imported from Data.ByteString); No module named `Data' is imported.
05:10:17 <fog51> ok nvm
05:16:39 <JohnTalent> % nomalizePoly (Proxy @BS.ByteString) "foo"
05:16:39 <yahb> JohnTalent: ; <interactive>:118:1: error:; * Variable not in scope: nomalizePoly :: Proxy @{*} BS.ByteString -> [Char] -> t; * Perhaps you meant `normalizePoly' (line 113)
05:18:50 * hackage ghc-lib-parser-ex 8.10.0.6 - Algorithms on GHC parse trees  https://hackage.haskell.org/package/ghc-lib-parser-ex-8.10.0.6 (shayne_fletcher)
05:30:04 <Unhammer> if I have `a <- async myThread`, and the main program gets some exception â€“ is there a way to do some cleanup in myThread before exiting?
05:30:44 <Unhammer> (myThread in this case is writing stuff to file, I'd like it to write the current buffer and flush)
05:56:55 <cohn> hi, what's the difference between Stack and Cabal?
05:57:56 <Axman6> Unhammer: do you have the main thread watching the forked thread? you might be able to wrap the forked thread in something which catches the exception thrown to it
06:01:27 <hpc> cohn: cabal is the actual build tool, stack is a third-party wrapper
06:02:25 <hpc> stack implemented some convenient stuff on top of cabal, but if you're using an up-to-date toolchain you don't need it for anything anymore
06:05:26 <cohn> hpc: can I use stack to install the toolchain and ghc?
06:06:07 <Axman6> stack will instal, the version of GHC it needs, but these days people seem to prefer ghcup
06:08:24 <cohn> Axman6: thanks, I'll take a look at ghcup
06:08:51 <Axman6> I've never used it so good luck!
06:09:19 <cohn> heh, thanks!  ; )
06:11:14 <rain1> how do I find every sum of subsets of a list? [a,b] -> 0,a,b,a+b
06:12:15 <hpc> map sum (permutations yourList)
06:12:46 <rain1> not permutations
06:13:27 <rain1> for each element in the list i want to add it or drop it
06:16:20 <sshine> rain1, you could make a 'select [a,b,c] == [[a,b],[a,c],[b,c]]' and apply it recursively.
06:16:56 <cohn> Axman6: seems like ghcup worked.  :D
06:19:00 <cohn> can anyone suggest books or other resources to use after going through the "Learn You a Haskell..." book?
06:19:35 <cohn> I'm trying to become more comfortable with Haskell before trying to do any big projects with it.
06:20:07 <sshine> cohn, get involved with a small-time open source project maybe?
06:20:20 <sshine> cohn, somewhere that'll give you access to isolated, practical tasks and someone to review your code.
06:20:23 <cohn> sshine: ah, great point!
06:28:46 <sshine> rain1, or better: Set.map sum . Set.powerSet . Set.fromList
06:29:21 <sshine> > Data.Set.powerSet (Data.Set.fromList [3,5])
06:29:24 <lambdabot>  fromList [fromList [],fromList [3],fromList [3,5],fromList [5]]
06:30:36 <sshine> cohn, (rather than plugging my own projects) https://github.com/diku-dk/futhark/issues?q=is%3Aopen+is%3Aissue+label%3A%22good+first+issue%22
06:31:49 <sshine> rain1, you may want to consider converting the powerset to a list if you want duplicate sums to occur more than once.
06:32:00 <sshine> rain1, e.g. if a == b.
06:33:18 <sshine> cohn, also if your powerset is very large and you're only interested in the sums of subsets up until a certain point, you could construct them lazily with lists instead.
06:33:39 <sshine> oops, sorry, mixing up names.
06:35:27 <rain1> thanks!
06:40:09 <cohn> heh
06:40:27 <cohn> my powersets are *always* large!  xD
06:40:58 <sshine> haha
06:41:51 <sshine> https://i.imgflip.com/406h59.jpg
06:42:13 <cohn> xD
06:47:00 <Unhammer> Axman6: it's kind of the opposite â€¦ but I think I found a way, by doing "finally mainProgram (sayFlush chan >> wait a)" :-)
06:52:18 <timCF> Hi! If I want some unsigned integer data type which will represent money amount, are types from Data.Word exact thing I want? Something like `newtype MoneyAmount = MoneyAmount Word64`? Or there is more common representation of unsigned integers in Haskell which is widely used in community?
06:52:54 <fog> whats wrong with Integer?
06:53:14 <timCF> Nothing, I just want unsigned
06:53:28 <fog> ah, ok
06:53:46 <fog> well yeah, Word8 is usual for binary data I think
06:54:41 <fog> seems strange that you wouldnt just use Double
06:54:58 <fog> is the performance gain from it not being signed really so significant?
06:55:40 <fog> but yeah, if the question is just about what is commonly used, Word seems fairly ubiquitous 
06:56:02 <Boarders_> unsigned might cause you serious problems with underflow bugs, be careful!
06:56:46 <Boarders_> does anyone know if there is a good reason why ByteArray from the primitive library doesn't have an NFData instance?
06:57:09 <fog> oh that reminds me, I have benchmarks; https://gist.github.com/fog-hs/3b2267500847538508e43418107d566d
06:57:10 <timCF> I'm working with bitcoin, so unsigned integer is the most exact representation of money in my app (because there is no smaller unit than satoshi)
06:58:06 <fog> is there as many satoshis as some common lengthed Word?
06:59:14 <fog> and why would that motivate it being unsigned? 
06:59:45 <fog> still seems like Integer would make more sense 
07:00:15 <timCF> hmm, but negative money amount does not make much sense 
07:00:59 <fog> since the amount is just a number of satoshis - and yes, negative certainly makes sense if your doing arithmetic such as subtraction
07:01:04 <loyon[m]> there is no smaller unit than cents anyway, those crypto hipsters...
07:01:49 <timCF> well, if you consider gold as money - it does not have smallest unit at all ðŸ˜€
07:02:14 <fog> no gold...
07:03:33 <fog> anyway, please dont do things like drawing comparisons between gold and bitcoin here
07:04:44 <TMA> timCF: there is no smaller unit than satoshi _yet_
07:04:50 <timCF> ok) but regarding newtype MoneyAmount around some Integral type - seems like using Word* don't make any overhead if compare with integer?
07:05:09 <timCF> * if compare with Int
07:06:00 <Boarders_> something you can do with Int but not with Word is test that none of your api produces a negative value
07:06:28 <TMA> I have read that it is possible to extend the precision to sub-satoshi fractions
07:07:41 <timCF> I think any Word* type will fail parsing of API result, if there will be negative amount.. but not sure
07:07:52 <Axman6> TMA: have you looked at https://hackage.haskell.org/package/safe-money? it's the bees knees
07:07:55 <Axman6> uh, timCF
07:09:15 <timCF> Axman6 I have seen it some time ago, it introduces some pretty complex type-level programming.. Previously I didn't fully understood it.. But maybe I will do now)
07:09:32 <[exa]> timCF: biology people routinely work with colloid gold and atomic gold coatings. It is indivisible at that point, unless you want yttrium and zirconium
07:11:19 * hackage viewprof 0.0.0.33 - Text-based interactive GHC .prof viewer  https://hackage.haskell.org/package/viewprof-0.0.0.33 (MitsutoshiAoe)
07:12:40 <timCF> [exa] technically the smallest unit is atom there, and theoretically it can be managed, anyway avogadro number is pretty big
07:13:06 <Axman6> timCF: https://ren.zone/articles/safe-money might help. you can basically define your own currency, "BTC" which can be used with type UnitScale "BTC" "satoshi" = (100000000,1)
07:15:14 <Axman6> you can also add type UnitScale "BTC" "bits" = (1000000,1) for completeness
07:17:08 <timCF> thanks Axman6!
07:20:12 <whataday> ghc a.hs ld: cannot find -lncursesw
07:20:30 <whataday> but I have already installed that curses lib
07:20:56 <whataday> there is /usr/lib/libncursesw.so.6
07:21:29 <whataday> oh, its gcc, not ghc
07:22:24 <whataday> ghc-8.6.5 on alphine linux
07:24:40 <Axman6> have you told ghc/gcc where to find the library?
07:24:55 <Axman6> using -L/usr/lib
07:25:22 <whataday> yes
07:25:52 <whataday> with -optl-static, this error will show up
07:28:33 <whataday> https://paste.ubuntu.com/p/TS8TnsdhmB/
07:29:14 <whataday> ghc 8.6.5 with musl on alpine linux
07:41:55 <sm[m]> @where HTAC, cohn
07:41:56 <lambdabot> I know nothing about htac,.
07:42:27 <ski> @where HTAC
07:42:27 <lambdabot> "Haskell Tutorial and Cookbook" by Mark Watson in 2017-09-04 at <https://leanpub.com/haskell-cookbook>
07:42:39 <ski> (no comma)
07:43:01 <sm[m]> thank you.. I'm always trying to blend lambdabot commands with nicks. Sometimes it works..
07:43:11 <ski> @where HTAC -- blah blach
07:43:11 <lambdabot> "Haskell Tutorial and Cookbook" by Mark Watson in 2017-09-04 at <https://leanpub.com/haskell-cookbook>
07:46:40 <kuribas> is it possible to dynamically compile and load code?
07:46:57 <kuribas> Like in generating haskell code at runtime, then compiling it?
07:47:05 <kuribas> (not just interpreting it)
07:48:09 <sm[m]> cohn: and https://tech.fpcomplete.com/haskell/learn . Plus (obviously) https://www.haskell.org/documentation
07:52:02 <c_wraith> kuribas: it's possible with the ghc api, but it can be pretty slow.
07:52:30 <kuribas> c_wraith: is llvm a better alternive?
07:53:20 <c_wraith> that's such an incredibly different level of abstraction that I'm not sure I can assign any meaning to the word "better"
07:54:21 <kuribas> supposing I can compile my code to llvm level, will it compile faster?
08:01:34 <wavemode> kuribas: the process of compiling haskell to llvm is even slower than the regular codegen
08:02:02 <kuribas> what is slow?  Even for small amounts of code?
08:02:23 <kuribas> actually it's for numeric code, so maybe llvm is better...
08:04:46 <wavemode> well, what is the context? why do you need to generate and run haskell code at runtime?
08:05:05 <kuribas> I want to optimize queries on timeseries...
08:08:06 <kuribas> they could be precompiled
08:11:16 <wavemode> if they can be precompiled, your job is much easier. you wouldn't need runtime compilation
08:28:49 * hackage hpqtypes-extras 1.10.2.1 - Extra utilities for hpqtypes library  https://hackage.haskell.org/package/hpqtypes-extras-1.10.2.1 (arybczak)
08:34:50 * hackage shake-plus 0.0.1.0 - Re-export of Shake using well-typed paths and ReaderT.  https://hackage.haskell.org/package/shake-plus-0.0.1.0 (locallycompact)
08:35:50 * hackage shake-plus 0.0.1.1 - Re-export of Shake using well-typed paths and ReaderT.  https://hackage.haskell.org/package/shake-plus-0.0.1.1 (locallycompact)
08:45:29 <timCF> Is there some good Decimal library for Haskell? I need something like `toDecimal :: Sign -> Coef -> Exp -> Decimal` and `fromDecimal :: Decimal -> (Sign, Coef, Exp)` where `Sign = Bool, Coef = Word64, Exp = Word32` or something similar
08:47:05 <sm[m]> Decimal works well
08:48:50 <timCF> sm[m] thanks!
08:50:36 <maerwald> sm[m]: how's your haskell code compiling?
08:51:22 <sm[m]> hi maerwald.. eh.. can you say more ?
08:51:34 <maerwald> Just making conversation!
08:51:36 <sm[m]> I'm not as good as GHC
08:51:39 <maerwald> haha
08:51:59 <maerwald> I evaluate my programs on paper, before I pass them to GHC!
08:52:13 <dsal> Heh, paper.  So wasteful.
08:52:35 <maerwald> dsal: recycled paper of course
08:52:48 <dsal> Oh, sorry, never mind.
08:52:57 <dsal> I'm suddenly regretting having all of these types without named fields.
08:53:25 <maerwald> There should be an extension to autogenerate fields.
08:53:37 <sm[m]> ah! hello
08:53:39 <dsal> Maybe it's not that bad, though.  I'll craft up some fancy lens stuff.
08:54:08 <sm[m]> phew. Thought you were about to make me work :)
08:55:29 <maerwald> Hm, another alternative prelude with the "Avoid all partial functions" mantra.
08:55:44 <maerwald> https://github.com/serokell/universum
08:56:09 <maerwald> https://hackage.haskell.org/package/universum-1.6.1/docs/Universum-Monad-Reexport.html#v:forever
08:56:15 <maerwald> but they have partial functions =)
08:56:19 * hackage shake-plus 0.0.1.2 - Re-export of Shake using well-typed paths and ReaderT.  https://hackage.haskell.org/package/shake-plus-0.0.1.2 (locallycompact)
08:56:57 <dsal> Lens got pretty non-exotic for me last night when I made a lens library for my mqtt types and I could do    `cc ^? clientConnReq . properties . folded . _PropSessionExpiryInterval` -- I've been doing this manually in other bits of code where I have to fold over a list of properties pattern matching each one to see if it's this one with this one's structure to pull the value of it.
08:57:04 <oats> maerwald: what is 'forever' not defined over?
08:57:26 <maerwald> oats: it never terminates
08:57:47 <dsal> At least it's named accurately.
08:57:54 <dsal> divMostOfTheTime
08:58:24 <solonarv> eh, depends on how you define 'partial'
08:58:25 <maerwald> oats: https://en.wikipedia.org/wiki/Machine_that_always_halts
08:58:30 <maerwald> solonarv: it is well defined
08:58:44 <solonarv> I certainly can't think of an input that makes 'forever' return a bottom
08:58:47 <oats> % forever Nothing
08:58:47 <yahb> oats: Nothing
08:58:51 <oats> % forever $ Just 5
08:58:53 <solonarv> well, a non-bottom input
08:58:53 <maerwald> "a turing machine that eventually halts for every input"
08:58:56 <yahb> oats: [Timed out]
08:59:00 <oats> huh
08:59:03 <solonarv> oats: ah, that works
08:59:42 <oats> % :t forever $ Just 5
08:59:43 <yahb> oats: Maybe b
08:59:45 <solonarv> it's just as partial as fix, then
08:59:49 <oats> fun type
09:00:05 <solonarv> forever = fix . (>>) after all
09:01:51 <maerwald> Also, since you can pass bottom to any function, you can't really make a function total, can you?
09:02:23 <tdammers> maerwald: fast and loose reasoning and all that
09:03:17 <tdammers> maerwald: in short, no, but you can make a function total over the universe of all values excluding bottom - that is, you can make a function that is guaranteed to not bottom out unless its input is bottom
09:04:39 <maerwald> The problem is also: termination depends on laziness
09:04:58 <maerwald> so proving that a function is "total" can be hard
09:06:50 <maerwald> I wonder if that's one of the reasons Idris has a Lazy type?
09:07:29 <oats> is idris not lazy?
09:07:40 <oats> huh, interesting
09:07:57 <__monty__> Haskell's pretty unique with its default laziness.
09:08:57 <tdammers> oh sure, a general proof of termination is impossible
09:09:15 <sm[m]> nix is that way too, right ?
09:09:20 * hackage validity-aeson 0.2.0.4 - Validity instances for aeson  https://hackage.haskell.org/package/validity-aeson-0.2.0.4 (Norfair)
09:09:21 <tdammers> note that I didn't say that it's possible to guarantee the "no bottoms in, no bottoms out" property for *all* functions
09:09:40 <tdammers> just that it's possible to write functions for which such a guarantee can be given
09:10:05 <maerwald> __monty__: I've had success with -XStrict and -XStrictData and am not planning to go back. The only times I need laziness is usually in monadic combinators I defined myself or places where I *know* a computation may be skipped for performance reasons.
09:10:20 <tomberek> any liquidhaskell users out there?
09:10:31 <__monty__> Question about dealing with JSON. I have an object that contains an object which's fields depend on another field of the first object. Is there a nicer way of dealing with this than a record full of Nothings?
09:11:43 <maerwald> My opinion is that laziness by default isn't as useful as it first seems. It is much more natural to add laziness, when you know you want it (and then also have a guarantee that it actually IS lazy)
09:13:00 <maerwald> for certain problem domain, like lens, I can imagine you have different requirements
09:14:14 <tdammers> I think the whopping advantage of this approach in haskell is not so much *default* laziness, but *transparent* laziness
09:14:43 <tdammers> i.e., we can write let c = a + b, and not worry about whether a and b are lazy or not, or whether they have been evaluated yet
09:15:00 <tdammers> iow., we can ignore evaluation order and burden our brains with more important things
09:15:16 <sm[m]> right
09:15:45 <maerwald> until you get a space leak, or allocations are slowing down your program, yeah
09:16:13 <tdammers> (fwiw, Purescript, which is strict by default, provides the same experience, and only very rarely does strictness actually matter in practice)
09:16:14 <maerwald> I don't mind spending extra time on reasoning about performance... IF that reasoning is explicit and made easy
09:16:31 <sm[m]> if using -XStrict, can you still use let and where with abandon, or is it suddenly all "must define everything in order" and "everything you define is evaluated" ?
09:17:30 <maerwald> sm[m]: maybe enable it for one of your bigger projects and see. I enabled it for a filemanger and it had *zero* impact on semantics.
09:17:42 <maerwald> And runtime performance was pretty similar
09:18:18 <maerwald> In another project is broke one of my monadic combinators and then never terminated. Had to annotate that lazy.
09:19:40 <tdammers> yeah, monadic combinators is where it typically breaks
09:19:53 <tdammers> learned that the hard way when trying to make a parser-combinator lib in purescript
09:20:02 <tdammers> when >>= is strict, it all falls apart
09:20:04 <sm[m]> I mean to try it, indeed. What was the advantage for you then ?
09:21:20 <maerwald> sm[m]: StrictData fixed almost all space leaks at work. Strict is more controversial I'd say. The only reason I enabled it is because Kazu Yamamoto was arguing to enable it for warp/wai.
09:21:59 <maerwald> A few times when people tried to improve performance with trivial algorithmic implementations here it also had a small benefit.
09:22:53 <maerwald> One reason to enable it globally was to see whether it breaks my intuition...
09:29:15 <dmwit> I think being forced to think about performance when deciding whether to name a subexpression would make the language worse.
09:29:48 <dmwit> Cheap renaming means more readable code.
09:30:10 <dmwit> Both because you can have a descriptive name, and because it gives you more flexibility about layout and reading order.
09:30:50 * hackage validation-selective 0.1.0.0 - Lighweight pure data validation based on Applicative and Selective functors  https://hackage.haskell.org/package/validation-selective-0.1.0.0 (shersh)
09:31:04 <monochrom> tibbe promotes strict data, lazy functions.  I agree.
09:31:12 <dmwit> __monty__: I think I don't understand the question.
09:31:55 <maerwald> monochrom: yeah, for most data, you don't need laziness. Except for things like Maybe/Either, which you want to use monadically, of course.
09:32:07 <maerwald> but that is easy to reason about imo
09:32:11 <maerwald> with functions, it's way harder
09:32:20 <dmwit> (I don't understand the problem, and so that makes it really hard to understand why a record full of Nothings would be a solution or to imagine an alternative solution.)
09:32:31 <dmwit> __monty__: ^
09:33:16 <monochrom> Don't worry, as with all preaching and advocacy, it is meant to be "most data strict, most functions lazy".
09:34:47 <__monty__> dmwit: Examples: { type: 1, data: { fieldA, fieldB } }, { type: 2, data: { fieldA, fieldC, fieldD } }, I'm currently representing "data" as a record with all the possible fields. So most of those are Maybes.
09:35:17 <dmwit> __monty__: `data Foo = One FieldA FieldB | Two FieldA FieldC FieldD` ?
09:35:19 <monochrom> In the data case, especially user-defined data --- most users really mean to use them for data, not control.  Maybe, Either, [] are controls, not data.
09:35:25 <Cale> __monty__: Sometimes DMap is a nice thing to know about
09:35:37 <Cale> https://hackage.haskell.org/package/dependent-map-0.4.0.0/docs/Data-Dependent-Map.html
09:36:02 <Cale> __monty__: You can make a gadt that explains what your possible fields are
09:36:07 <dmwit> Wow, not sure I agree with the DMap suggestion here. That's going to introduce a lot of boilerplate and complication.
09:36:22 <Cale> Well, I have a solution to the boilerplate :D
09:36:35 <Cale> https://hackage.haskell.org/package/aeson-gadt-th
09:36:52 <Cale> Oh, I guess it's a little weird
09:37:03 <Cale> That's a little bit of a different problem
09:37:05 <monochrom> piled higher and deeper :)
09:37:21 <dmwit> The boilerplate I'm complaining about isn't even about making *JSON instances, but about interfacing with DMap.
09:37:32 <dmwit> A sum type seems much simpler.
09:37:43 <sm[m]> whadya mean, we are haskellers, boilerplate and complication is our MO ðŸ˜‚
09:37:44 <Cale> Yeah, it depends
09:37:58 <monochrom> pun! >:)
09:38:02 <Cale> haha
09:38:25 <Cale> I've used DMap to manage cases where there were hundreds to thousands of optional fields
09:38:28 <dmwit> monochrom: Proposal: if your data declaration has a | in it, make it lazy, otherwise strict
09:38:44 <monochrom> the benefit of more static invariant vs the cost of faking dependent typing in haskell.
09:38:49 <monochrom> Yes, it's faking.
09:38:56 <dmwit> Cale: oof
09:39:14 <Cale> dmwit: Mortgage application forms :P
09:39:43 <dmwit> Did you know that until very recently, mortgages basically weren't a thing in India?
09:39:52 <Cale> I didn't
09:40:14 <Cale> It's nice that you can construct a hierarchy of types explaining what fields exist, to be able to reuse common structures in it
09:40:15 <dmwit> Their houses are much cheaper compared to typical salaries. I leave it to you to ponder which direction the causation goes there.
09:41:04 <Fede> @free x :: Int
09:41:04 <lambdabot> x = x
09:41:15 <Cale> I consider that sort of just inside the border of what dependently-typed stuff is reasonable to do in Haskell, since your indices are still properly types, and you won't be tempted to start doing computations on them
09:41:26 <Fede> @free x:: [a] -> [a]
09:41:26 <lambdabot> $map f . x = x . $map f
09:41:39 <Cale> It's where you start wanting to pull in the singletons package where you've gone too far and need to turn back
09:42:36 <monochrom> I think most user-defined sum types are still meant to be strict because the users use a sum type to express the equivalent of OOP subclasses.  data User = Local String | Remote Address Port, things like that.
09:43:07 <Cale> Using a GADT to explain what fields are possible in something is a good enough idea that I wish all the GHC proposals related to records weren't happening
09:43:08 <Fede> @free x :: a -> b -> a
09:43:08 <lambdabot> f . x y = x (f y) . g
09:43:31 <monochrom> Now, user-defined recursive data types! That's a tougher one.  But recall even Data.Set uses a strict tree.
09:43:33 <dmwit> When will we have strict, unpacked []? =P
09:43:47 <Cale> Extensible records are a much nicer concept when the field identifiers are typed
09:44:07 <justsomeguy> Are there any good books or guide on TTD in Haskell?
09:44:45 <dmwit> Huh. Is TTD very different in Haskell than other languages for some reason?
09:45:00 <oats> TTD?
09:45:09 <tdammers> transport tycoon deluxe?
09:45:09 <dmwit> oh
09:45:16 <dmwit> I misread, and assumed TDD.
09:45:23 <justsomeguy> Probably not, but I don't even write tests, so I was looking for a guide, and I figured that it would be nice to find one for the language I'm learning.
09:45:23 <dmwit> (test-driven development)
09:45:26 <__monty__> Guess I'll go with a sum type. The overlapping fields kinda bother me though.
09:45:34 <maerwald> tdammers: great game
09:46:06 <dmwit> __monty__: It is usually possible to come up with an interesting factorization. But it does require some human insight to do well.
09:46:17 <maerwald> TDD is boring in haskell. The times when I found TDD useful was when writing larger python applications, where I cannot trust myself changing a single line of code.
09:46:52 <monochrom> People do TDD naturally in Haskell because they only know ghci or cabal repl etc.
09:46:57 <Cale> Actually, there is one interesting thing: if you write QuickCheck tests, you'll encourage yourself to think about the laws that your functions might satisfy, which tends to be a good thing
09:47:09 <dmwit> __monty__: e.g. in the example above, sometimes I would write that as `data Foo' = One FieldB | Two FieldC FieldD; data Foo = Foo FieldA Foo'`. But sometimes not. Depends on whether it makes sense to think of `FieldA` as an independent entity from the other fields.
09:47:16 <justsomeguy> Boring is good. Maybe I should just get to know the hUnit and QuickCheck docs a bit better.
09:47:23 <monochrom> In fact they take it to the next level and do RDD = REPL driven development.
09:47:49 <monochrom> RDD means TDD plus you enter code directly into the REPL and then wonder how to save your code.
09:47:53 <maerwald> I like the excitement of compiling every 30 minutes only
09:47:54 <dmwit> justsomeguy: I think hunit and quickcheck are great places to start. There's some excellent academic writing on how to do quickcheck well, too.
09:48:13 <maerwald> And I try to make the periods of not compiling longer, which forces me to think more deeply about the code and what it *actually* does
09:48:33 <maerwald> Too much feedback makes you lazy
09:48:47 <justsomeguy> I'll do just that, then. Thanks for the encouragement, dmwit.
09:49:28 <maerwald> You stop thinking and it becomes trial and error. Like frontend development.
09:49:44 <justsomeguy> I don't think anyone really likes writing tests, but honestly my code could use some basic checks. I write a lot of stuff that blows up, since I'm a beginner and have no idea what I'm doing.
09:51:16 <justsomeguy> Though, I'll admit that one of the reasons I even started looking at Haskell in the first place was the potential that the type system could eliminate a bunch of failure modes that I encountered in JavaScript. It would be nice to some day master LiquidHaskell and dispense with a ton of tests.
09:51:41 <maerwald> justsomeguy: liquidhaskell is so hard
09:52:25 <maerwald> You get exposed to details very quickly
09:52:31 <oats> repls are so nice
09:52:35 <oats> I wish all languages had repl
09:52:38 <oats> s
09:53:03 <dmwit> The type checker will indeed already dispense with a ton of tests that you would want to write in certain other languages.
09:53:17 <dmwit> But there will definitely still be things you want to test even of well-typed code.
09:53:43 <oats> 21:56 <dmwit> I'm really, really good at writing well-typed bugs.
09:53:47 <oats> :P
09:54:02 <sm[m]> doctest is also worth knowing, and after quickcheck: hedgehog/smallcheck
09:54:29 <sm[m]> and tasty seems to be the preferred test runner
09:54:35 * ski imagines "Well-Typed Bugs" to be the name of a company, or maybe band
09:54:43 <maerwald> sm[m]: sadly, in order to run doctests, you need the entire source code and GHC. While with something like hspec, you can make a binary and run it somewhere.
09:55:10 <dsal> I like tasty.  I try to mostly do quickcheck tests.  Occasionally assertion things.  A few golden tests.  I don't like the ruby-style BDD stuff.
09:55:43 <sm[m]> justsomeguy: ghcid's --test  feature is great, too
09:56:44 <dmwit> oats: Yeah. :3
10:01:07 <justsomeguy> (Heh, it took me a long time to realize that I wrote TTD instead of TDD by accident.)
10:02:20 * hackage kontrakcja-templates 0.11 - Utilities for working with many HStringTemplate templates from files.  https://hackage.haskell.org/package/kontrakcja-templates-0.11 (arybczak)
10:06:20 * hackage consumers 2.2.0.2 - Concurrent PostgreSQL data consumers  https://hackage.haskell.org/package/consumers-2.2.0.2 (arybczak)
10:14:12 <__monty__> dmwit: Thanks, that's looking like what I'll go with.
10:16:29 <dsal> __monty__: Are you working primarily with JSON data or your domain types?
10:17:43 <dsal> lens-aeson is pretty great for dealing with the JSON parts without having to model everything exactly the same way.
10:18:07 <dsal> Sometimes... Sometimes it's not.  I guess I have three different approaches depending on what I'm doing.
10:18:24 <sm[m]> maerwald: that's true, doctest assumes you have the source and GHC. Sadly you say.. are you thinking it would be nice to have a compiled version of doctests ?
10:20:20 * hackage within 0.0.1.0 - A path within another path.  https://hackage.haskell.org/package/within-0.0.1.0 (locallycompact)
10:20:54 * sm[m] thinks about when exactly it's desirable to have compiled tests you can run outside of a development context
10:30:17 <maerwald> sm[m]: yes, it's a no-go for some docker-based CI workflows
10:33:31 <dsal> compiled tests are handy when the tests test things about the environment.
10:34:20 * hackage crypto-rng 0.1.2.0 - Cryptographic random number generator.  https://hackage.haskell.org/package/crypto-rng-0.1.2.0 (arybczak)
10:36:09 <sm[m]> or to give users a warm feeling.. or as extra verification that the release was in fact tested. That's all I can think of
10:41:10 <fog> this page says that there is a Mutable version of List! https://blog.jle.im/entry/introducing-the-mutable-library.html
10:41:24 <fog> this is very confusing
10:41:57 <fog> it has; instance (Mutable m a, PrimMonad m) => Mutable m (List a)
10:44:33 <fog> I'm not sure what to make of this, I was just wanting to write a benchmark to compare the efficiency of MVector vs Vector
10:46:19 <fog> ah! its for a totally different library, nvm; https://hackage.haskell.org/package/mutable
10:46:28 <dsal> I think that's going to depend on what you do with them.
10:48:23 <fog> % :t Data.Vector.update
10:48:23 <yahb> fog: Data.Vector.Vector a -> Data.Vector.Vector (Int, a) -> Data.Vector.Vector a
10:48:53 <fog> was just looking for a version of this for MVector
10:49:42 <fog> the closest thing the library provides is;
10:49:48 <fog> modify :: PrimMonad m => MVector (PrimState m) a -> (a -> a) -> Int -> m ()
10:50:19 <dsal> Right, both reading and writing are side effects.
10:50:20 * hackage minilight 0.5.0 - A SDL2-based graphics library, batteries-included.  https://hackage.haskell.org/package/minilight-0.5.0 (myuon)
10:50:40 <fog> so if m ~ ST s a
10:50:42 <dsal> You could build an action that combines the two.
10:51:13 <fog> then PrimState m ~ s
10:51:40 <dsal> s is just a magic word.
10:51:55 <fog> but thats confusing because I thought it was supposed to be (MVector (ST s a))
10:52:13 <fog> so it seems to need ST s a ~ ST
10:52:16 <fog> !?
10:52:24 <dsal> :t ST
10:52:25 <lambdabot> error:
10:52:25 <lambdabot>     â€¢ Data constructor not in scope: ST
10:52:25 <lambdabot>     â€¢ Perhaps you meant one of these:
10:52:31 <dsal> % :k ST
10:52:31 <yahb> dsal: * -> * -> *
10:53:19 * hackage diagrams-solve 0.1.2 - Pure Haskell solver routines used by diagrams  https://hackage.haskell.org/package/diagrams-solve-0.1.2 (BrentYorgey)
10:53:22 <dsal> Anyway, it's not super unintuitive to actually use.  Your modify action above pushes the state forward.  You can read the new state after that.
10:53:52 <fog> so what is State?
10:54:01 <fog> i thought it lived in the ST monad
10:54:13 <Cale> State is a completely unrelated monad
10:55:48 <fog> % :t Data.Vector.modify
10:55:49 <yahb> fog: (forall s. Data.Vector.Mutable.MVector s a -> ST s ()) -> Data.Vector.Vector a -> Data.Vector.Vector a
10:56:17 <fog> wait thats wrong, it seems to be editing a regular Vector
10:57:07 <xe4> with pattern guards, is it possible to emit the error from the returned Left if you're guarding against functions that return Either
10:58:23 <dsal> fog: Well, you're looking in Data.Vector.
10:58:40 <fog> % :t Data.Vector.Mutable.modify
10:58:40 <yahb> fog: Control.Monad.Primitive.PrimMonad m => Data.Vector.Mutable.MVector (Control.Monad.Primitive.PrimState m) a -> (a -> a) -> Int -> m ()
10:59:02 <fog> so this is just a monadic action
10:59:18 <dsal> Yes.  What would you expect?
10:59:21 <fog> ah! so thats why its a "state" monad, because we expect the vector to be in the environment
11:01:27 <fog> hmmm, I guess the first thing to do is to read the vector into the state monad environment then
11:08:38 <fog> % Data.Unboxed.Mutable.thaw
11:08:39 <yahb> fog: ; <interactive>:12:1: error:; Not in scope: `Data.Unboxed.Mutable.thaw'; No module named `Data.Unboxed.Mutable' is imported.
11:08:42 <fog> % :t Data.Unboxed.Mutable.thaw
11:08:43 <yahb> fog: ; <interactive>:1:1: error:; Not in scope: `Data.Unboxed.Mutable.thaw'; No module named `Data.Unboxed.Mutable' is imported.
11:08:57 <fog> % :t Data.Vector.Unboxed.thaw
11:08:57 <yahb> fog: (Data.Vector.Unboxed.Base.Unbox a, Control.Monad.Primitive.PrimMonad m) => Data.Vector.Unboxed.Base.Vector a -> m (Data.Vector.Unboxed.Base.MVector (Control.Monad.Primitive.PrimState m) a)
11:09:02 <fog> ok
11:10:10 <dsal> %  let l = [1, 2, 3] in   runST $ do { v <- (V.thaw . V.fromList)  l; VM.modify v succ 1; V.freeze v }
11:10:10 <yahb> dsal: [1,3,3]
11:10:47 <dsal> % :t it
11:10:48 <yahb> dsal: (Num a, Enum a) => V.Vector a
11:13:28 <__monty__> dsal: It's mostly parse, fetch a bunch of stuff, save some state. Fairly uniform JSON though so I think I'll stick to what I have for now.
11:15:59 <dsal> I've needed some of the fanciness of aeson lens just for the sake of having a lot of things that need to be modified in bulk, or extracted.
11:16:49 <dsal> In some cases, I just store raw, unprocessed JSON and figure out how to deal with it later.  :)
11:19:07 <fog> % :t \f xs -> V.thaw xs >>= \x -> f x >> V.freeze x 
11:19:07 <yahb> fog: Control.Monad.Primitive.PrimMonad m => (V.MVector (Control.Monad.Primitive.PrimState m) a1 -> m a2) -> V.Vector a1 -> m (V.Vector a1)
11:19:35 <dsal> That's gonna be slower than a immutable vector, I think.
11:20:50 <fog> right because it has to do some freezing and thawing
11:21:05 <fog> but as long as f is much more intensive than these, it should be faster?
11:21:22 <fog> well, as long as f leverages mutability sufficiently
11:21:38 <dsal> Yeah, it's possible for that to be faster.
11:26:22 <fog> ok I think I can write the benchmark now
11:27:01 <fog> to show that doing many updates in the mutable setting should be faster than over the reglar Vector
11:27:31 <fog> this one shows Vector to be as fast as IntMap and Seq;
11:27:32 <fog> https://gist.github.com/fog-hs/3b2267500847538508e43418107d566d
11:31:25 <vaibhavsagar> if I install `alex` from hvr's ppa, where does it put the binary?
11:33:27 <vaibhavsagar> oh, under /opt
11:43:17 <ChaiTRex> vaibhavsagar: https://gist.github.com/ChaiTRex/1202c1f0621f4af9e5d4ac49eec06c98
11:46:03 <vaibhavsagar> ChaiTRex: thanks!
11:46:17 <ChaiTRex> vaibhavsagar: No problem.
11:49:31 <fog> so is there any reason to use Vector over MVector?
11:49:46 <fog> in terms of computational effeciency
11:49:48 <merijn> fog: Better question: Is there any reason to use MVector over Vector?
11:49:49 <koz_> fog: If you don't need to mutate it.
11:49:52 <merijn> fog: Usually not
11:50:00 <koz_> Like, you mght as well use Vector then.
11:50:11 <merijn> koz_: Honestly, even if you do it *strongly* depends on the mutation operations
11:50:20 <koz_> merijn: Yeah, that's true too.
11:50:34 <koz_> Basically, _start_ with immutable.
11:50:38 <fog> was thinking maybe traverse
11:50:44 <merijn> koz_: Vector (the package) is very well optimised and so is its fusion, so mutable vectors aren't event guaranteed to speed things up
11:50:51 <fog> like, i dont want to have to increment a counter
11:50:57 <koz_> If it's too slow for you, and _that_ happens to be the bottleneck, then try mutability.
11:51:30 <koz_> merijn: Is there a canonical paper describing the current fusion approach vector-the-library takes?
11:51:31 <merijn> fog: For the record, I have code that accumulates 90k vectors (so for every 90k input vectors I update every element in the output vector). I tried speeding it up using mutable vectors, zero difference
11:51:44 <fog> well, certainly stochastic update seems to motivate use of MVector
11:51:51 <koz_> I keep hearing it's 'very good', but I have no way to know exactly what the fusion framework does, so I can't evaluate it.
11:52:00 <koz_> (other than reading the source code)
11:52:07 <merijn> koz_: I have no idea if there's a paper :)
11:52:09 <fog> and then the question is if there is any situation where it would be faster to freeze it for some opperation
11:52:30 <solonarv> I vaguely recall reading such a paper once, but I doubt I can find it
11:52:40 * koz_ should do a bench of Fisher-Yates shuffles.
11:52:56 <merijn> fog: immutable access don't have to go through ST/IO, so the reads can just be inlined into all the code, etc.
11:53:17 <merijn> koz_: While you're at it, add (partial) Fisher-Yates to vector-algorithms!
11:53:23 <merijn> It's been on my todo list for ages
11:53:41 <koz_> merijn: I might.
11:53:47 <fog> hmm, so possibly if there is a rewrite rule
11:53:52 <koz_> I've gotta update finitary-derive first!
11:53:57 <fog> like (map . map) or something
11:54:19 <fog> er, fmap f . fmap g = fmap (f.g)
11:54:40 <solonarv> merijn: wait, why would it be partial?
11:54:49 <koz_> solonarv: RNG exhaustion.
11:54:51 <fog> seems difficult to know which parts of the code use such rewrites though
11:54:56 <merijn> No
11:55:05 <koz_> In order for it to _truly_ be statistically fair, your RNG has to have enough state, I believe.
11:55:06 <merijn> solonarv: Partial as in partial shuffle
11:55:19 <koz_> merijn: Ah, you mean 'shuffle a subrange of the indices'?
11:55:23 <koz_> Or like, a slice?
11:55:24 <merijn> And "why?" because partial Fisher-Yates is super useful
11:55:30 <solonarv> oh, you mean something like "here is a vector of length 20, please shuffle the slice from 10 to 15"?
11:55:59 <merijn> solonarv: You know the implementation of Fisher-Yates?
11:56:25 <fog> something like randomly cutting the deck but too few times to get a decent shuffle?
11:56:37 <solonarv> vaguely, yes
11:56:50 <solonarv> don't have cause to recall the exact implementation very often
11:56:59 <koz_> solonarv: You can always look it up, lol.
11:57:09 * koz_ does, to this day, despite having written it far more than once.
11:57:22 <fog> maybe something like a partial quicksort with random pivots too
11:57:26 <merijn> No, Fisher-Yates is effectively: Given an array of N elements, select a uniform random index between 0 and (N-1), move that index to index (N-1), then repeat with indices 0 through \(N-2)
11:57:41 <merijn> etc, until you only have only one index left
11:57:50 * hackage data-ascii 1.0.0.0 - Type-safe, bytestring-based ASCII values  https://hackage.haskell.org/package/data-ascii-1.0.0.0 (chris_martin)
11:58:03 <merijn> A partial Fisher Yates would just stop at say 5, 10, whatever repeats
11:58:12 <koz_> merijn: Ah, I see.
11:58:12 <merijn> What's the point of that?
11:58:28 <merijn> It's effectively the most efficient way to implement N choose K!
11:58:48 <koz_> merijn: ... that's actually brilliant.
11:58:50 * hackage ascii 1.0.0.0, ascii-th 1.0.0.0, ascii-superset 1.0.0.0, ascii-predicates 1.0.0.0, ascii-case 1.0.0.0, ascii-group 1.0.0.0, ascii-char 1.0.0.0 (chris_martin)
11:59:05 <merijn> koz_: You can do even cooler things
11:59:08 <koz_> That's O(k) with k turns of the PRNG.
11:59:16 <fog> well if you were only going to use a few of the random elements using take
11:59:17 <koz_> (assuming you can slice in O(1))
11:59:34 <merijn> koz_: I dove into this because I needed to uniform randomly sample a large number of values from an even huger dataset with no repeats
11:59:46 <koz_> merijn: Stream sampling wasn't your jam I guess?
11:59:46 <fog> partially shuffling random slices
12:00:11 <fog> thats kind of inductive
12:00:19 <merijn> koz_: I didn't want to reify the sample, because I wanted to pick millions of values
12:00:53 <merijn> koz_: Also, in the limit "stream sampling" and "partial Fisher-Yates" are the same algorithm :p
12:01:03 <fog> also, the crude sort is useful, if your going to be randomly sampling the result anyway
12:02:13 <fog> this is common for basis pursuit, where you want to order the dictionary for a greater probability of finding the desired atoms close to the front  
12:02:17 <merijn> koz_: Anyway, so I had N values (with N > million) and wanted to sample K values (with > up to 50% of N). The first thing I came up with is "sample random values between 0 and N, store in set, repeat until set size is K", but that's of course bad, since you'll get a high collision rate and spend much more than linear complexity
12:02:38 <koz_> Yeah, that's definitely not great with K that hihg.
12:02:50 * hackage vinyl 0.12.2 - Extensible Records  https://hackage.haskell.org/package/vinyl-0.12.2 (AnthonyCowley)
12:03:27 <merijn> koz_: So, simple solution someone in ##C++ came up with was: start with empty Map Int Int (representing values at a given index), where missing value = equal to index
12:03:52 <fog> typically you would want to be selecting atoms that are not overlapping in an l2 sense, so satisfying the restricted isometry property 
12:04:31 <merijn> koz_: Follow Fisher-Yates logic on the Map, using "lookupWithDefault" with the default equal to the key. If you have swapped an index before it's in the Map. If you haven't it's just the index
12:05:25 <merijn> koz_: So you end up with O(K) time and O(K) storage. In hindsight I could've just used a streaming PRNG solution and then it'd be O(K) time and O(1) space, but hindsight :p
12:05:34 <fog> like if you had a curvelet frame, generated by translating, rotating and stretching different variance gaussian windowed sin waves
12:06:34 <fog> but i was working with lists, where the ordering for use with take was the implementation
12:07:56 <fog> the really hellish thing is trying to get a gradient with each of those different tranformations as a gradient
12:08:39 <fog> ends up being better just to do monte carlo updates on sparsely placed initial guesses, and then they kind of flow twist and dilate into the correct configuration
12:08:53 <fog> as a direction*
12:08:56 <koz_> merijn: Ah, that's actually quite clever.
12:11:08 <merijn> koz_: You can even do arbitrary offsets by assuming all indices are +M
12:12:02 <merijn> koz_: For sampling of my database results I do just use a seeded PRNG to sample values uniform randomly
12:12:10 <fog> the main cost was creating these patches, so they were written to disk, then its faster to read them in from filepaths than calculating them on the fly. after they are pixelated, things like translation are pretty cheap, and the more expensive things like rotations were written to disk
12:13:50 <fog> i think something like this is common for inflating training data, like, classification on rotated faces - where then the classifier ends up robust to rotations
12:14:14 <fog> like, training on*
12:17:38 <operand> Hi, ghci seems to be failing to find the "Test.QuickCheck" module, despite this being installed (through my system package manager)
12:17:50 * hackage hpp 0.6.3 - A Haskell pre-processor  https://hackage.haskell.org/package/hpp-0.6.3 (AnthonyCowley)
12:17:54 <operand> Anybody know why? It worked fine not too long ago, last week or so
12:19:22 <solonarv> "installed (through my system package manager)" - this is not the recommended way to do haskell development, so I cannot tell you why precisely it isn't working
12:21:03 <maerwald> depends
12:21:07 <pragma-> nil: good day!
12:21:09 <maerwald> if it is done right (it rarely is)
12:22:16 <sm[m]> operand: "ghc-pkg list" is a useful troubleshooting command, it should show you what packages your "ghci" can see
12:23:29 <sm[m]> so you need the QuickCheck package to be in that list (and not marked broken or hidden). Secondly, you would usually need to tell ghci to load that package at startup: ghci -package QuickCheck
12:24:37 <operand> Yeah, it does seem to be the arch repos being broken
12:24:54 <merijn> Arch's Haskell packages are all entirely broken
12:24:56 <solonarv> arch? oh those are *double* not-recommended
12:25:14 <operand> Oh, or perhaps my fault for thinking pacman works transactionally and pressing ctrl+c during the post-install hooks
12:25:40 <operand> Let's just say I already had to figure out how maven works this semester and couldn't be arsed to figure out any more build systems, is that a good excuse? :p
12:26:12 <sm[m]> why are we still saying this in #haskell.. surely some arch maintainer hangs out here, and could fix arch, or defend it, or something
12:26:27 <sm[m]> it has been years....
12:26:46 <merijn> sm[m]: It's intentional
12:27:04 <merijn> sm[m]: It's an ideological issue
12:27:15 <maerwald> operand: uninstall all haskell stuff that you installed via pacman
12:27:19 <merijn> sm[m]: Arch maintainers have decided *everything* should be linked dynamically
12:27:28 <solonarv> yes, they want dynamic linking for all the things - but they can't even make that work right!
12:27:35 <merijn> sm[m]: Therefore all their Haskell packages install *only* dynamic libraries
12:27:48 <merijn> sm[m]: GHC, normally (and by default) uses static linking for Haskell code
12:27:58 <solonarv> if they really cared they could have forked cabal/ghc that is set to dynamic by default, but they don't
12:28:01 <operand> yeah, i noticed. it's *extremely* annoying
12:28:19 <merijn> sm[m]: So, when you try and use GHC "normally" as a developer, it tries to link libs statically and then errors out, because those are not installed
12:28:20 <operand> i sure love having half of my updates consist of haskell package 'hotfix' versions
12:28:30 <solonarv> so they just give you broken packages and have a wiki page saying "oh, you have to edit a config file and/or pass extra arguments all the time"
12:28:57 <merijn> operand: Yeah, dynamic linking haskell libraries is very nonsensical and also leads to dumb issues like "pandoc has 140 dependencies", they should just link pandoc statically and call it a day
12:28:57 <maerwald> merijn: I'm curious how they do go packaging =)
12:29:05 <sm[m]> surely they could communicate this better to their users, who seem to be numerous.. it's such a common "haskell fail" experience, and an entirely preventable one
12:29:14 <fog> do MVectors have a Generic instance for writing them to disk as Binary?
12:29:20 <maerwald> sm[m]: arch linux packaging is anarchy :)
12:29:37 <operand> merijn: i found this in the AUR: "Pandoc - executable only, without 750MB Haskell depends/makedepends" :D
12:29:38 <maerwald> fixing attitude is harder than fixing code
12:29:57 <merijn> operand: Anyway, there are generic linux binary distributions of GHC and there's ghcup too
12:30:17 <merijn> operand: I always just use those to install GHC in my home directory so I'm *sure* everything is the same on each *nix system I use :)
12:30:19 <operand> Yeah, I guess I'll just make sure to use cabal in the future
12:30:44 <fog> or is it normal to freeze them before writing?
12:30:45 <solonarv> note, ghcup is basically just a small program to figure out which distribution you have and stuff GHC binaries in ~/.ghcup
12:30:49 <operand> Though I'm happy things broke *after* i wrote all the code for my bachelor thesis, lmao
12:30:58 <merijn> operand: On the upside, GHC and cabal are both extremely well behaved with regards to having multiple different user home dir (or wherever else) installs
12:31:04 <operand> Was just trying to do a quick check (heh) of an example in my paper
12:31:30 <fog> operand: could you use stack to resolve the environment at that date?
12:31:37 <sm[m]> operand: stack scripts are good for long term repeatability like that
12:31:46 <sm[m]> cabal has a similar feature (not quite as good)
12:31:56 <merijn> sm[m]: What's "not as good" about it?
12:32:10 <operand> Anyway, what's the advantage of using a binary distribution of GHC?
12:32:15 <sm[m]> recompiles every time, IIRC
12:32:28 <merijn> sm[m]: What? No it doesn't
12:32:42 <maerwald> solonarv: ~5K LOC haskell :)
12:32:50 <operand> I get the dynamic linking thing, but I don't quite understand how arch repo's ghc fits into it
12:32:54 <radish> hello all
12:32:57 <sm[m]> I tested it not too long ago.. has it been fixed ?
12:33:00 <merijn> sm[m]: I'm using freeze files for my phd stuff right now and it certainly doesn't recompile everything :)
12:33:21 <merijn> sm[m]: What exactly are you doing, then?
12:33:31 <sm[m]> merijn, I'm talking about executable scripts, are you ?
12:33:58 <merijn> sm[m]: Ah, no, I was referring to freeze files for ensuring repeatability
12:34:01 <maerwald> stack doesn't? I don't remember that
12:34:38 <sm[m]> stack's "script" command compiles the script only if it has changed, otherwise just runs the binary version
12:34:41 <sm[m]> which is great
12:34:46 <merijn> operand: GHC ships with the base library (consider it "the standard library"), Arch only installs the dynamic one with the default GHC
12:35:05 <operand> Aaah
12:35:08 <merijn> operand: So you need to install static GHC to get the static version too (which is what it defaults to using)
12:36:23 <solonarv> the main downside of cabal run compared to stack script is that it doesn't install GHC; you must already have a compatible GHC installed
12:36:39 <koz_> solonarv: Luckily, we have ghcup. :D
12:36:50 <solonarv> this is admittedly out-of-scope for cabal, but that doesn't mean people don't want it or that it isn't additional effort needed before running such a script
12:37:13 <sm[m]> yes, that's the other downside (a big one)
12:37:23 <maerwald> solonarv: I've never seen rust users complain that cargo doesn't install a rust version, though
12:37:38 <koz_> I also really think it's not as big a deal as some folks believe.
12:37:42 <maerwald> I'm still at loss why haskellers appreciate this behavior
12:37:43 <koz_> Like, ghcup exists.
12:37:48 <koz_> It also works quite well.
12:37:51 <solonarv> oh sure, I don't think it's a big deal either
12:37:53 <sm[m]> also, for full repeatability you'd need a freeze file in addition, right ?
12:37:55 <koz_> (unless it's me doing cross-comps :P)
12:38:01 <maerwald> sm[m]: and fixing index state
12:38:08 <maerwald> because of hackage revisions
12:38:13 <maerwald> they are nort part of the freeze file
12:38:25 <solonarv> if you fix index state you *technically* don't even need a freeze file
12:38:31 <merijn> maerwald: Hackage revisions can't change the build plan in the presence of a freeze file
12:38:35 <solonarv> since the solver is deterministic, IIRC
12:38:35 <maerwald> solonarv: not sure about it
12:38:43 <solonarv> I guess maybe it isn't
12:38:47 <merijn> maerwald: Since hackage revisions can only change bounds and those are all pinned by the freeze file
12:38:49 <maerwald> yes, but your global config could change what the solver does
12:38:53 <solonarv> ah! true
12:38:58 <solonarv> or a later cabal version
12:39:19 <maerwald> merijn: yes and then cabal doesn't resolve
12:39:45 <maerwald> so your freeze file is broken 
12:40:25 <yushyin> maerwald: they package golang tools statically
12:40:29 <merijn> maerwald: We have different definitions of broken, then :)
12:40:42 <sm[m]> maerwald: managing ghc automatically as just another dep is obviously useful for certain use cases, don't you think ? Why should you have to deal with getting that right if you don't want to
12:40:53 <maerwald> merijn: no? If I have a freeze file, I expect cabal to resolve the deps :)
12:40:55 <merijn> maerwald: Because revisions should only be used to enforce broken setups, so then it's already broken
12:41:09 <sm[m]> it's ideal for beginners - they only have to download one binary to get going
12:41:19 <maerwald> merijn: sometimes the tighten upper bounds too aggressively, because it failed on *one* platform
12:41:25 <maerwald> but not on yours
12:41:30 <maerwald> and then boom
12:41:34 <merijn> sm[m]: tbh, I'm not convinced about stack's beginner friendliness
12:41:55 <Cale> maerwald: re: the installing GHC thing, imagine a project which has a bunch of developers working on it, you want them to be able to get set up to begin contributing as easily as possible. If you have a thing that can completely fabricate an environment with the appropriate compiler and libraries and tools, that's pretty helpful. If it only does libraries, maybe a bit less helpful -- you end up with people running different versions of 
12:41:55 <Cale> the compiler and dealing with different set-up issues accidentally.
12:42:03 <merijn> sm[m]: My SO has been using it because it's what the Haskell book uses and she's on windows and I couldn't figure out an easier way to install GHC on windows
12:42:12 <merijn> sm[m]: But the experience has been...less than stellar
12:42:37 <Cale> Of course, you also potentially want to be able to test a fixed library you're building against many different versions of the compiler
12:42:40 <merijn> sm[m]: If GHC had a better windows install story than chocolatey I would've switched her over to cabal-install already
12:42:51 <solonarv> apparently ghcups exists, but I can't speak more about it
12:43:01 <nisstyre> ghcup is great
12:43:06 <Cale> and so having a tool that can install compilers and create package environments is helpful there as well
12:43:11 <solonarv> I suppose now that it's written in Haskell ghcup could be extended to work on windows as well
12:43:12 <sm[m]> merijn: would you agree that managing ghc is beginner friendly at least ?
12:43:21 <nisstyre> if ghcup didn't exist I would hate every interaction with Haskell I have
12:43:23 <sclv> chocolatey is a really good story
12:43:29 <sclv> it just takes a minute to acclimate yourself to it
12:43:41 <dcoutts_> maerwald: the freeze file still has to be consistent with the constraints of the packages. You can override the package constraints if you need to however, selectively or generally.
12:43:43 <nisstyre> mostly because I'm on Arch and Haskell is completely broken in the system packages
12:43:53 <sclv> right arch is a nightmare
12:44:01 <maerwald> merijn: https://github.com/ekmett/contravariant/issues/61
12:44:06 <maerwald> this broke CI in production
12:44:09 <sclv> i've been begging the ghc devs to just disable the "dynamic only" mode so arch can't use it
12:44:17 <sclv> since it clearly doesn't work well at scale
12:44:30 <Cale> sclv: That's a great idea actually.
12:44:38 <Cale> I don't know why anyone would want it
12:44:46 <merijn> sm[m]: managing GHC would be userfriendly, but the whole snapshot/resolver thing is *incredibly* confusing, more so than managing GHC version would be
12:45:39 <maerwald> sm[m]: would you like coreutils to be one binary? coreutils --rm? :>
12:46:10 <merijn> sclv: This it even work well on "not scale"? :p
12:46:14 <merijn> s/This/Does
12:46:16 <sm[m]> merijn: I'm sure there's room for improvement in all areas; we'd have to pick a specific use case to discuss it
12:46:36 <sm[m]> but stack gets you going with one small binary download, works the same on all platforms - that's pretty damn useful
12:46:55 <maerwald> solonarv: ghcup windows support would have to be done from scratch. The current code heavily assumes unix. And there is more stuff to be installed on windows and to be configured to make it work, afair.
12:46:57 <dsal> stack seems to make a lot of sense to me.  It gives me a lot less to have to worry about.
12:47:50 <sclv> the right notion of ghcup on windows is literally chocolatey
12:47:51 <maerwald> And afair, windows users prefer chocolatey over stack?
12:47:54 <maerwald> yeah
12:48:25 <maerwald> sclv: that already exists: https://github.com/kakkun61/ghcups
12:48:33 <dsal> stack has been getting a bit weird lately, though.
12:48:37 <maerwald> (that is a chocolatey wrapper)
12:49:01 <sm[m]> how so dsal 
12:49:58 <dsal> I've had a couple cases where I had to remove stack.yaml.lock to get things compiling again.  Today, I had a really weird one I didn't understand where I was trying to use a package I was writing in ../x -- it would build x and then tell me it couldn't find x.  I removed the executable part of package.yaml from x and the local package started working?  No idea.
12:50:42 <sclv> Cale: after some googling I can't find the issues/tickets where I raised the "disable dynamic only" thing
12:50:51 <Cale> -r-xr-xr-x 1 cale cale 1291396 Dec 31  1969  coreutils
12:50:51 <Cale> lrwxrwxrwx 1 cale cale       9 Dec 31  1969  cp -> coreutils
12:50:55 <sclv> if you like the idea can you take it up and run through a better ticket on it?
12:50:57 <Cale> maerwald: ^^
12:51:20 <maerwald> Cale: :)
12:51:33 <maerwald> same with git
12:51:39 <maerwald> what is important is the user interface
12:52:10 <merijn> maerwald: Which is absolutely terrible in git :p
12:52:15 <radish> can someone help me w cabal-install real quick?
12:52:17 <sm[m]> dsal: sounds like the normal weirdness of haskell build tools.. I haven't noticed any increase of weirdness
12:52:22 <dsal> heh
12:52:31 <merijn> radish: What's the problem?
12:52:41 <radish> i run $cabal install cabal-install
12:52:47 <maerwald> unix principle is: one tool that does one job. If the implementation shares code, doesn't matter.
12:52:56 <sm[m]> overlapping names do seem to be a source of horrible failure modes in stack/cabal/ghc
12:53:16 <radish> it says that it installed 3.0.0.0
12:53:31 <radish> then i run $cabal --version
12:53:43 <radish> and i get 1.24.0.2
12:53:48 <dcoutts_> check your $PATH
12:54:01 <radish> i /really/ struggle to understand $PATH or how it works
12:54:06 <radish> im kind of a beginner w this kind of thing
12:54:18 <sclv> radish: what operating system are you on?
12:54:25 <radish> like ive done programming but installing stuff for libraries is still a struggle
12:54:30 <radish> im on linux mint
12:54:31 <dcoutts_> or adjust cabal to put things in ~/bin/
12:54:41 <maerwald> radish: when you type in "cabal" in your terminal, the terminal goes through the colon-seperates list of paths that is your PATH variable and finds the *first match
12:55:04 <maerwald> if "cabal" exists multiple times, the "first" path wins
12:55:55 <sclv> your path is usually configured in a file called like .bash_profile or something, depending on your operating system
12:56:02 <radish> should i do something like $cabal uninstall cabal-install-1.24
12:56:06 <sclv> and it has a line like "export PATH="~/Library/Python/3.6/bin:/usr/local/opt/openssl/bin:$PATH""
12:56:09 <radish> wild guess
12:56:11 <maerwald> sclv: .bash_profile is for login shells
12:56:19 <sclv> or .bashrc or...
12:56:36 <sclv> anyway, you want to edit the file to add "~/.cabal/bin" as the first entry
12:56:42 <sclv> and then, importantly, start a new shell
12:57:18 <radish> so we want cabal to have its own path entry so its not matching something else first?
12:57:31 <maerwald> is mint on dash?
12:57:42 <sclv> right. when you "cabal install" an executable, then, by default, it goes into ~/.cabal/bin
12:57:42 <radish> thats awful - what if there's like a loop in the order requirements??
12:57:48 <sclv> so you need to teach your shell how to get there
12:58:27 <sm[m]> this is known as "PATH hell" :)
12:58:27 <sclv> radish: thus it has been since the early days of *nix systems, don't take it up with me :-P
12:58:43 <radish> so add ~/.cabal/bin to my %PATH% and then the "shell" will spot the correct one first?
12:58:51 <sclv> you could also just cp the executable installed in ~/.cabal/bin into your /usr/bin or something
12:59:13 <sclv> literally just google up and learn about path variables and shell configs in linux in general though
12:59:13 <maerwald> sm[m]: there was a ghcup bug where it would crash when you had a *file* in your PATH :D
12:59:17 <sclv> it will serve you well
12:59:33 <sm[m]> radish: in bash, "type -a somecommand" is good for detecting multiple copies of somecommand
12:59:51 <radish> yeah ive been feeling like PATH was def something i need to learn soon for a while now
13:00:06 <radish> im just trying to build a simple app for personal use and i keep hitting these barriers
13:00:17 <radish> i cant install /any/ gui tools for haskell for some reason
13:00:35 <sm[m]> I'll quickly interject: seeing dcoutts_ reminds me: big congrats to you and all IOHKers here, for shipping the haskell cardano node and Daedalus 1.0 ! \o/
13:00:59 <radish> \o/
13:01:48 <sclv> radish: gui tools for haskell are fragile and in only partial shape on linux
13:02:03 <sclv> unfortunately, though they benefit beginners most, they're not in a state where i'd recommend beginners even try to set them up
13:02:03 <iqubic> Leskah exists.
13:02:15 <radish> i noticed lol
13:02:26 <sclv> last i tried leksah it was clear it wasn't ready for beginners use
13:02:28 <sclv> too many sharp edges
13:02:36 <maerwald> Leksah is a mammoth. I can't fathom how they keep it going
13:02:51 <radish> was thinking about writing my app in lua but since im stuck at /installing the libraries/ i figured switching languages wouldn't be exactly helpful right now
13:03:08 <maerwald> hamishmack is a beast :)
13:03:13 <sm[m]> I think radish meant installing gui libs to build gui apps with haskell
13:03:21 <radish> yeah exactly
13:03:29 <sclv> oh oops, gotcha
13:03:37 <sm[m]> fltkhs is supposed to be an easy one to start with
13:03:41 <radish> cant even get a hello world working because haskell cant spot the libraries because im installing them wrong or something
13:04:02 <sclv> fltkhs is the one gui for haskell i know of thats ok
13:04:09 <maerwald> gtk is fine too
13:04:10 <radish> some of them wont even install and wont tell me why im getting github 404s and no ./configure files in my dls and stuff like that
13:04:10 <sclv> for beginners
13:04:38 <radish> like id love to learn all this stuff but i feel like im not far enough along to even learn why nothing is working lol
13:04:55 <sclv> the gui stuff isn't haskell specific, its just about system libraries and linking and shit
13:05:05 <radish> i tried to install both and i couldnt get either to even install
13:05:13 <sm[m]> radish, hassles installing gui frameworks is normal since most of them rely on platform-specific C libs as well as haskell stuff. We could help if you share exact platform info, commands & errors on a paste site
13:05:48 <sm[m]> or you could try fltkhs
13:06:32 <radish> well see i switched back to trying gtk again from fltkhs because i couldnt get that one working, and now im seeing this PATH problem w gi-gtk preliminary steps so i think that might've been what held me back before
13:07:09 <maerwald> sm[m]: have you used fltk?
13:07:36 <maerwald> the only reason I sometimes consider abandoning gtk is that it's extremely difficult to build your own widgets
13:08:20 <radish> im a bit afraid to use gi-gtk because it uses this {-# LANGUAGE OverloadedLabels #-} crap which makes ZERO sense to me
13:09:17 <sm[m]> maerwald: I just built the demos IIRC. But it's the only one with install instructions for all platforms I think
13:09:23 <sm[m]> so top of my list if I ever get a round tuit
13:09:41 <radish> i just want something easy, thats why im using haskell (i find FP much easier than say OO)
13:10:02 <radish> i need a tree of text and some click behavior THATS ALL
13:12:24 <sm[m]> so, what went wrong with fltkhs install ?
13:12:28 <radish> im trying to write a tool that helps me w data entry. i want to generate not hideous forms automagically and be able to adjust them to make the data entry easier. then im going to use maybe lua scripts or something to spit out svg prints of the data. but i cant even start with all that complexity until i can open a damn window
13:12:55 <radish> hang on i'll open it back up and see if i can remember where it went wrong
13:14:43 <radish> i did the git clone and then stack install and i get a bunch of garbled nonsense w a 404 in it
13:15:15 <radish> "Downloading lts-15.0 build plan ...RedownloadFailed Request { ..."
13:15:39 <radish> want a pastebin or something?
13:17:36 <maerwald> Hm, problems with the mirrors?
13:18:23 <sm[m]> commiserations! but what commands, what output ?
13:19:30 <radish> ?
13:19:36 <radish> gimme a sec
13:22:26 <sm[m]> radish: could you be having network trouble ? does ping -A s3.amazonaws.com show any packet loss ? are you in china ?
13:23:06 <sm[m]> yes please, that's always useful
13:25:21 <sm[m]> also what's your stack --version ? It seems to work here
13:30:50 * hackage Frames 0.6.4 - Data frames For working with tabular data files  https://hackage.haskell.org/package/Frames-0.6.4 (AnthonyCowley)
13:43:01 <radish> sm[m]: are you saying i can type something to show you my stack version in this chatroom??
13:43:19 <radish> sorry for the absence my mom is writing a novel and she came to have me look over a piece lol
13:43:37 <radish> visiting fam and friends for the summer :)
13:44:58 <maerwald> pastebin the novel
13:45:01 <maerwald> jk! :D
13:45:02 <radish> sm[m]: 1% packet loss
13:45:32 <radish> its still pretty rough
13:45:35 <radish> its her life story
13:45:50 <radish> which for once is actually interesting lol
13:47:51 <radish> she starts out poor and her parents were abusive (a lot of parents were back then as you must already know). she joins a maybe cult at one point, works on the pipelines in alaska for a bit, gets a job basically running a multi national gold mining company which is acused of having some ties to terrorism, and has a few supernatural experiences that she can't really explain. its a real page turner.
13:48:26 <sm> radish: no, I was asking what you see when you run "stack --version" in your terminal
13:48:42 <sm> if it's super old, that could be another reason
13:48:58 <sm> 2.3.1 is current
13:49:47 <radish> https://pastebin.com/tP0XqrqL
13:49:53 <dmj`> so when are we going to get Symbol deconstruction
13:50:25 <dmj`> type family Pop (xs :: Symbol) :: Char where Pop (x ': xs) = x
13:50:47 <sm> radish: 1% packet loss when pinging raw.githubusercontent.com too ?
13:51:12 <radish> https://pastebin.com/V42qhHpj
13:51:28 <sm> ah, that's too old. Try "stack upgrade"
13:52:09 <maerwald> https://github.com/commercialhaskell/lts-haskell hmm, it seems this repo isn't updated anymore?
13:52:41 <maerwald> because it doesn't have that file indeed
13:52:54 <maerwald> so they probably switched the location
13:52:55 <radish> "WARNING: Installation path /home/radish/.local/bin not found on the PATH environment variable
13:52:56 <radish> New stack executable available at /home/radish/.local/bin/stack"
13:52:58 <sm> the process changed recently ("pantry" something something)
13:53:07 <radish> so i need to do the %PATH% thing right?
13:53:17 <maerwald> never heard of pantry
13:54:19 <sm> radish: I wouldn't bother with that just now, just say /home/radish/.local/bin/stack instead of stack
13:54:32 <sm> if in doubt
13:55:22 <radish> 2.3.1
13:55:35 <sm> but yes, this will probably work: echo "export PATH=/home/radish/.local/bin:$PATH" >> ~/.bash_profile; bash -l
13:55:43 <solonarv> dmj`: you can already do it by abusing the behavior of CmpSymbol
13:55:43 <radish> i think i should add both cabal and stack to the path
13:55:45 <maerwald> sm: why login shell?
13:55:52 <solonarv> but it is really horrible
13:56:16 <sm> maerwald: because only they read .bash_profile, right ? 
13:56:25 <maerwald> yes, that's why you use .bashrc :>
13:56:29 <radish> sm: cant i just do "PATH=/my/new/path:$PATH"?
13:56:39 <solonarv> you see, if CmpSynbol x "a" ~ GT and CmpSymbol x "b" ~ LT, then x must start with an 'a'
13:56:51 <sm> maerwald: but then someone will shout at me for filling up $PATH on every new shell session ?
13:57:07 <sm> radish: yes but that won't be persistent
13:57:19 <radish> wut
13:57:23 <radish> omfg
13:57:26 <sm> of course, I don't know what shell you use, since you haven't mentined it
13:57:27 <radish> why is it so confusing
13:57:43 <sm> I told you, it's PATH hell and you shouldn't deal with it right now :)
13:57:43 <radish> how do i figure out what shell im using lmfao
13:57:50 <maerwald> echo $SHELL
13:58:13 <radish> "/bin/bash"
13:58:19 <maerwald> use .bashrc then
13:58:30 <sm> got to go.. good luck
13:58:32 <radish> i have no idea what that means
13:58:34 <radish> nooo
13:58:37 <radish> okay thanks sm
13:58:52 <radish> your the man
13:58:54 <radish> or woman
13:58:58 <radish> hard to tell from text lol
13:59:25 <radish> XP
13:59:28 <maerwald> radish: export PATH=/home/radish/.local/bin:$PATH
13:59:32 <maerwald> add that to ~/.bashrc
13:59:36 <maerwald> with an editor
13:59:49 <radish> maerwald: what is .bashrc and how do i use it
13:59:55 <maerwald> open it with an editor
14:00:00 <maerwald> just add that line
14:00:00 <solonarv> it's a file that lives in your home directory
14:00:06 <radish> okay so theres a text file called .bashrc?
14:00:37 <solonarv> yes
14:00:52 <solonarv> (linux mint creates it when installed, so it should exist already)
14:01:06 <radish> i dont know where to put it. its full of if blocks.
14:01:16 <maerwald> at the end
14:01:19 <maerwald> likely
14:01:27 <solonarv> yeah, just add new stuff at the end
14:02:31 <radish> what am i adding at the end? just the paths on newlines?
14:03:02 <radish> no quotes or anything?
14:03:10 <radish> never done any of this before :'(
14:04:07 <sm> my command was simpler
14:04:18 <sm> echo "export PATH=/home/radish/.local/bin:$PATH" >> ~/.bash_profile; bash -l
14:05:50 <radish> ive got it open but svcl was saying earlier that i should add it at the start of the file, not the end
14:06:06 <maerwald> sm: that will not work for most of their terminal sessions
14:06:22 <maerwald> if you open a terminal normally under some distro, it is not a login shell
14:06:30 <solonarv> you'll want to add the following: export PATH="/home/radish/.local/bin:$PATH"
14:06:40 <radish> just have "~/.local/bin" and then "~/.cabal/bin" at the end is that what i want?
14:06:43 <solonarv> on a single line
14:06:48 <radish> oh i want to add that whole thing at the end?
14:06:57 <maerwald> solonarv: you already had 3 people telling you what to add
14:07:02 <maerwald> radish: ^
14:07:06 <maerwald> just do it
14:07:15 <solonarv> at the end of the file, yes
14:07:30 <solonarv> that's the directory where stack puts its binaries
14:07:35 <radish> can i do ~/ here or do i need /home/radish? just asking for learning sake
14:07:46 <maerwald> try it
14:07:50 <maerwald> why ask :>
14:07:55 <sm> maerwald: it would work for this one at least.. and all terminal windows after a reboot ? or not ?
14:07:55 <radish> i dont want to break anything >_<
14:08:01 <maerwald> you're not breaking anything
14:08:03 <solonarv> you're not going to break anything
14:08:12 <maerwald> sm: no
14:08:12 <radish> okay i'll try it
14:08:22 <solonarv> the worst that will happen is "oh, I guess that didn't work, let's change it to /home/radish"
14:08:32 <maerwald> sm: most display managers don't initiate a login shell
14:08:37 <maerwald> nor do they source .bash_profile
14:08:40 <dmj`> solonarv: no abuse, just want type level Uncons to implement my lexers at compile time
14:08:41 <sm> maerwald: good to know. I see I used your .bashrc advice in another doc. THanks
14:08:41 <radish> export PATH="~/.local/bin:~/.cabal/bin:$PATH"
14:08:50 * hackage lowlin 0.2.0.0 - Low dimensional linear algebra  https://hackage.haskell.org/package/lowlin-0.2.0.0 (jodak)
14:08:59 <maerwald> sm: it is all confusing, a bit
14:09:02 <sm> maerwald: I do find duplicate entries added to $PATH sometimes, who knows why
14:09:13 <solonarv> dmj`: well, this thing could be done in a library that ou just import (but it would still be horrible)
14:09:18 <sm> it's truly PATH hell for beginners, I'd really love if it all went away
14:09:28 <maerwald> there should be a proper shell builtin to add something to path. Not messing with the variable directly
14:09:28 <solonarv> a less horrible solution would be a GHC plugin
14:09:57 <dmj`> solonarv: that's cheating
14:10:10 <dmj`> solonarv: and the GHC AST is a hairball
14:10:10 <solonarv> if you aren't cheating, are you really trying?
14:10:16 <radish> "$ stack --version" gives me "Version 2.3.1" :)
14:10:17 <dmj`> solonarv: depends who you ask
14:10:39 <sm> radish: very good, press on.. build the gui demo
14:10:52 <radish> okay now maybe i can move forward on this crap lol
14:11:18 <sm> though I have to say, don't expect it to be too exciting
14:11:37 <radish> its installing ghc to an isolated location
14:11:44 <radish> looks like 8.8
14:11:54 <radish> looks good so far
14:11:59 <radish> but my point was, i want 8.8 lol
14:12:15 <radish> can i get like a repo or something for the newest version of ghc to install w my system update?
14:14:19 * hackage dwergaz 0.2.0.4 - A minimal testing library  https://hackage.haskell.org/package/dwergaz-0.2.0.4 (henrytill)
14:15:16 <solonarv> radish: yes, actually, but stack won't use that
14:15:29 <solonarv> so if you are using stack (which it seems you are) there is no point
14:16:01 <solonarv> stack wants to install GHC itself, somewhere in ~/.stack, to make sure it has the right GHC version each time
14:16:27 <solonarv> so it will not use a GHC installed system-wide unless you explictly tell it to
14:17:01 <radish> it says i need to run stack init first :'(
14:17:04 <radish> running it now
14:18:29 <radish> stuck yet again https://pastebin.com/Jx01EHWn
14:19:01 <radish> stack init cant find fltkhs and stack install fltkhs cant run until i run stack init
14:19:11 <solonarv> ah yes, the great downside of stack (and the main reason I personally stopped using it)
14:19:37 <radish> this is why i dont program
14:19:37 <solonarv> stack operates based on "snapshots", which is a set of packages with a specific fixed version for each package
14:19:40 <sm> waiit, you've gone off the rails somewhere
14:20:09 <sm> did you cd into the fltkhs-hello-world directory ?
14:20:17 <solonarv> these snapshots are curated, so all the packages in a snapshot are supposed to work together
14:20:28 <radish> ah see i reset the terminal after the path updated
14:20:53 <radish> so no i'll fix that and try again
14:20:57 <solonarv> but what if you need a package that isn't in the snapshot you are using? well, you *can* add it to a list and use it, but it's a bit annoying...
14:21:10 <sm> follow the install instructions exactly
14:21:37 <radish> ^ right??
14:22:03 <radish> i'll just restart if i get stuck after i do anything next time lol
14:22:13 <sm> solonarv: you know you can install a non-snapshot package with stack about as easily as with cabal, right ?
14:22:41 <radish> so /this/ looks bad "Verification error: Invalid hash for <repo>/01-index.tar.gz"
14:22:57 <radish> but it seems to be working on stuff still so~~
14:24:18 <solonarv> sm: eh? installing packages? who even does that anymore?
14:24:23 <solonarv> (only half joking, at most)
14:24:36 <sm> me, frequently ? haskell tools, etc ?
14:24:51 <solonarv> ah right, you meant executable packages. fair enough
14:25:06 <sm> cd; stack install PKG-X.Y . Same as with cabal
14:25:38 <solonarv> okay, to clarify: I was talking about intalling *libraries*.
14:25:55 <sm> every haskell newcomer needs to do this, I think we shouldn't be pretending only libraries exist
14:26:58 <monochrom> I agree with zero assumptions.
14:27:20 <radish> dear god this thing is doing a lot of things
14:27:22 <monochrom> or is it s/with/about/ ?
14:27:49 <sm> radish: I meant to say, at this point make a nice cup of tea
14:28:48 <sm> "it's taking a heck of a long time" is considered good in haskell land (better than "it failed", at least :/ )
14:29:09 <radish> i /should/ make tea. i always go for coffee but ive got this fantastic "emperor's pu'erh" which tastes like if tobacco tasted really really good
14:29:36 <radish> it died
14:29:37 <monochrom> I endorse pu'erh, too.
14:29:57 <radish> that stuffs straight delicio~
14:29:59 <sm> in another window you can repeat the build command with "--dry-run" added to see how much work is remaining
14:30:15 <radish> nah its dead
14:30:18 <radish> something went wrong again
14:30:29 <sm> ack. paste or it didn't happen
14:30:32 <radish> should i pastebin the entire output?
14:30:52 <sm> perhaps just the last 20 lines will do
14:34:07 <radish> https://pastebin.com/xEqXtgw6
14:34:16 <radish> oh sorry thats the whole thing
14:34:18 <radish> lol
14:34:59 <sm> that's good. I saw autoconf mentioned in the readme.. thought it was only needed for windows
14:35:19 <radish> okay so whats autoconf
14:35:37 <sm> only for mac, it says. Well I guess you need to install it
14:35:52 <radish> even for linux??
14:36:07 <solonarv> apparently it's not installed yet, yes
14:36:17 <solonarv> should only be a 'apt install autoconf' away
14:36:33 <radish> installed via my software manager
14:37:29 <radish> so "autoconf: not found" was the giveaway?
14:37:58 <sm> radish, exactly. You get used to reading these errors after a while
14:38:42 <sm> you look for the one line which seems to be the first significant error. It's not always right at the end of the output, unfortunately
14:39:18 <radish> yeah ive got a hair of experience doing that, but that one seemed especially encrypted lol
14:39:35 <gallais> Is there a way to grab the version of the package currently being installed from inside `Setup.hs`? My intuition was to import `Paths_PACKAGE` but that does not exist yet!
14:42:56 <radish> holy frejole the test is working wholy
14:43:07 <sm> hello world ?
14:43:14 <radish> yessir
14:43:26 <sm> pretty underwhelming isn't it :) but, congrats!
14:43:46 <radish> now to struggle with other simple things <3
14:43:53 <radish> yallre the best
14:43:55 <radish> thanks a million
14:44:13 <sm> well done. Now we have three suggestions for fltkhs maintainer to improve
14:44:18 <radish> learned me a bash for great good today
14:44:47 <radish> what are the three things tho? lulz
14:45:26 <radish> i wasnt able to keep up i guess lol
14:45:32 <sm> mention the minimum stack version.. mention installing autoconf on linux.. provide a more rewarding demo!
14:45:45 <radish> ah lol nice
14:45:54 <sm> I can pass these along to him if you like
14:46:01 <monochrom> such as s/world/galaxy/
14:46:38 <radish> since fltkhs is aimed at making it easy to get going, you might suggest he mention the path problems i had since he's talking about updating stack even
14:46:51 <sm> you're right
14:47:00 <maerwald> and I thought stack does the path thing for you
14:47:02 <radish> phew thought i was dumb there for a minute lulz
14:47:13 <radish> apparently not!!
14:47:15 <maerwald> at least the stack install script
14:47:17 <maerwald> not stack itself
14:47:45 <sm> stack warns you about the PATH thing, but I don't think it (even install script ? I could be wrong) fixes it for you, because that's Too Hard (diverse shells..)
14:48:25 <maerwald> sm: works well in ghcup for ~80% of the users
14:48:41 <maerwald> but yes, you can't have 100% coverage
14:48:43 <radish> right i mean the instructions might be more helpful toward beginners? i dunno haskell is not exactly a beginner language. but then again its that we-all-know-what-we're-doing attitude that makes it not beginner friendly lol
14:48:43 <sm> maerwald: what does ghcup do.. adds it to .bashrc ?
14:49:17 <maerwald> sm: https://gitlab.haskell.org/haskell/ghcup-hs/-/blob/master/bootstrap-haskell#L141
14:49:23 <sm> radish you're right again.. it's hard to fix
14:49:57 <radish> thanks for reducing my imposter syndrome lol
14:49:59 <maerwald> https://raw.githubusercontent.com/commercialhaskell/stack/stable/etc/scripts/get-stack.sh 
14:50:04 <maerwald> doesn't seem to do any PATH stuff
14:50:05 <radish> i feel like such a noob after today
14:50:23 <radish> well /now/ i feel slightly better
14:51:03 <sm> radish it can be painful indeed. Well done for persisting. PATH and too-old versions of tools are a big cause of problems, things may be a bit better now
14:51:58 <sm> maerwald: so ghcup does it automatically for bash and zsh, nice. They have to run that env script for it to take effect in current terminal, is that it
14:51:59 <sm> ?
14:52:08 <maerwald> yeah
14:52:13 <maerwald> or open new terminal
14:53:15 <radish> i'll throw y'all some screenshots when i finish :)
14:53:23 <sm> yes please
14:53:46 <sm> maerwald: would it be wrong to dump them into a new shell ? is that possible ?
14:53:57 <sm> end with exec bash ?
14:53:59 <radish> aight i gtg i gotta eat and go build a deck :'(
14:54:14 <radish> thanks again everyone
14:54:34 <sm> o/
14:54:35 <maerwald> sm: not sure that preserves local variables etc
14:54:53 <maerwald> or even CWD
14:54:56 <maerwald> and whatnot
14:55:11 <monochrom> I think it's morally wrong.
14:56:06 <maerwald> immoral or ugly, I dunno
14:56:27 <sm> "I would now like to start a shell for you, in which things will work; are you morally ok with this ? Y/N:"
14:57:12 <sm> "If you are a beginner, type Y and ENTER"
14:57:33 <solonarv> gallais: I'm sure that is possible somehow. Have you looked through the Cabal (-the-library) docs?
14:57:52 <maerwald> I don't know. If people want to spend hours and hours of programming a highly technical language that needs weeks to even understand the basics, but they can't be bothered to type in some shell command. Uh?
14:58:13 <maerwald> assuming they are devs, of course
14:58:32 <maerwald> (which most are, not many users compile haskell programs for fun)
14:58:49 <sm> right. Which many of them aren't (yet!). Look at radish. Look at any of us when we first want to try out this haskell thing
14:59:11 <maerwald> Yes, this will be their first challenge!
14:59:24 <gallais> solonarv: I am at the moment but it's a bit overwhelming given I have never needed to before
14:59:25 <sm> don't you think they have enough ahead of them ? :)
14:59:39 <maerwald> sm: not everyone survives... true
14:59:47 <maerwald> 'tis a deep forest
15:00:12 <monochrom> I am morally against leaky abstractions.  Heuristically starting a new shell, even with user consent, is a leaky abstraction.
15:00:38 <radish> yeah mr beginner over here actually turns out im still stuck lmfao
15:00:40 <monochrom> My stance is either proper abstraction or screw any pretended abstraction.
15:01:33 <monochrom> Specialized to this case: Either a new thing that replaces the traditional unix shell and fixes its shortcoming, or inform the user to start a new terminal.
15:01:47 <solonarv> gallais: clicking through a bit, if you can get your hands on a PackageDescription (or a GenericPackageDescription, which contains a PD) you should be set
15:02:20 <solonarv> PD's 'package' field is a PackageIdentifier, which is a PackageName and a Version
15:03:28 <radish> monochrom if youre saying what i think youre saying then i think youre def on to something. if the abstraction isnt based in reality then it cannot physically actually help you, but it can and will lure you into a false sense of security.
15:03:35 <solonarv> it looks like most of the UserHooks pass you a (Generic)PackageDescription, so you can likely do your stuff in there.
15:04:41 <radish> im trying to program in sublime, but when i do a standard build sublime cant see to import FLTK
15:04:48 <radish> my shellcmd is "runhaskell $file +RTS -A249m"
15:05:28 <radish> so that wont work and i need to use "stack exec blah"
15:05:30 <sm> radish: first, know that getting haskell integrated smoothly with any IDE is "advanced", can eat up days
15:05:32 <radish> right?
15:05:35 <sm> second, use "stack ghci" instead
15:05:57 <radish> so you think if i switch out runhaskell for stack ghci it'll work here and in my normal use cases?
15:06:12 <sm> I wouldn't be so rash, but it's more likely to
15:06:18 <radish> cuz i can do that easily i wrote the thing to use runhaskell in the first place
15:06:29 <radish> normally i just hit build on my main.hs files so~
15:06:43 <Cale> radish: stack ghci will rely on having a stack project in the current directory, and will load up an appropriate version of ghc with its dependencies for that project
15:07:14 <radish> omfg im getting the 404 message again lmfao
15:07:18 <radish> hmmmm
15:07:25 <radish> guess im using terminal from now on lulz
15:07:28 <sm> stack/cabal generally don't install libraries "globally" where "runhaskell" would see them. "runhaskell" is not used much for this reason
15:08:40 <Cale> As a Sublime Text user, I'd recommend using a proper terminal rather than trying to use any of sublime's terminal simulation nonsense
15:08:54 <sm> oh, and sorry, you were trying to run the script right ? "stack runghc" then
15:08:58 <Cale> Sublime is good at editing text, it's not particularly good at being a terminal
15:09:04 <maerwald> I recently switched to fish
15:09:48 <radish> fish as in bluefish or what?
15:10:01 <Cale> (I do use the Terminus package for Sublime occasionally when pairing with coworkers online, so that I can just share the one window, but it sucks)
15:10:07 <maerwald> fish the shell
15:10:08 <gallais> 00:03 < solonarv> it looks like most of the UserHooks pass you a (Generic)PackageDescription, so you can likely do your stuff 
15:10:11 <gallais>                   in there.
15:10:20 <gallais> that looks perfect. Thanks!
15:10:30 <maerwald> https://fishshell.com/
15:11:28 <maerwald> zsh is too much configuration nonsense
15:11:56 <maerwald> but even fish doesn't have a nice abstraction for handling PATH, although it is considered on their issue tracker
15:12:22 <sm> oil shell will save us
15:13:27 <monochrom> The fundamental issue with PATH is it was made an environment variable but today most users would rather use it as a global shared variable.
15:13:50 <maerwald> sm: oil is directed at programmers
15:14:11 <maerwald> I don't think their main concern is usability for day-to-day use, but scripting.
15:14:28 <sm> maerwald: I think it's everything eventually
15:14:28 <monochrom> The name "environment variable" is very apt.  Recall "environment" as in programming language semantics of local variables and parameters.  It is really the ReaderT kind of environment variable.
15:14:34 <sm> anyway I believe it will save us
15:15:00 <maerwald> sm: like stack? :D
15:15:15 <maerwald> I think the scope is too wide
15:15:24 <maerwald> But lets see
15:15:24 <sm> sure, stack saved me and my users
15:15:45 <sm> I think the oil guy is very impressive, though it takes time. I believe!
15:15:54 <maerwald> you can already do scripting in python and other languages fine if shell is not enough for you
15:15:57 <monochrom> Why is PATH an environment variable?  Probably because of a mixture of these two considerations back then:  Some unix experts really wanted it local.  The unix inventors could not think up a clean simple way to implement a shared global variable. (Recall that STM was not a thing back then.)
15:17:39 <monochrom> Until PATH becomes an STM variable, it will be a perpetual uphill battle confronting the tension of guiding beginners to "update" it.
15:18:07 <maerwald> monochrom: if there was a concept of read only environment variables, you could still have shell builtins that only allow sensible things (like add, rm, view, reset etc)
15:18:15 <sm> yes, it's horribly stateful when you don't want that
15:18:27 <Cale> What if PATH were a directory full of symlinks?
15:18:39 <maerwald> Cale: sounds like nix :D
15:18:43 <sm> oh oh I think I see where you're going..
15:18:51 <monochrom> sounds like windows
15:19:00 <monochrom> Err no, nevermind
15:19:01 <sm> fish has some kind of global shared env vars I think
15:19:08 <MarcelineVQ> Are you allowed to choose that directory? :>
15:19:08 <Cale> maerwald: funny you should say that, the nix guy I'm talking to just said "Okay, plan9"
15:19:47 <maerwald> MarcelineVQ: in an environment variable!
15:20:03 <maerwald> And now... you want a LIST of directories with symlinks
15:20:06 <maerwald> tadaa
15:20:15 <Cale> MarcelineVQ: It would be per-user then, rather than per-environment
15:20:26 <sclv> the two things unix design got most right were directories and files
15:20:39 <sclv> so its natural to want to represent everything else in terms of the only things that make any goddamn sense
15:21:03 <maerwald> sclv: symlinks is the one thing they didn't get right :P
15:21:24 <maerwald> it's one of the major hurdles of implementing things, because it introduces so many edge cases
15:21:45 <tukane> Is Wadler's `How to make ad-hoc polymorphism less ad hoc' a right choice for reading if I want to have a formal understanding of type classes in Haskell?
15:21:53 <Cale> tukane: It's a start
15:22:00 <monochrom> Most linuxes have a default .profile or .bashrc or the like that includes an "if $HOME/bin exists, add it to PATH".  I think I'm seeing ubuntu 20.04 adding further "if $HOME/.local/bin exists, that too".
15:22:06 <sclv> arguably the haskell report gives a formal understanding of typeclasses
15:22:09 <sclv> for the simple case
15:22:13 <Cale> tukane: Just don't be fooled by the title, type classes are not ad-hoc polymorphism
15:22:44 <monochrom> So I think in the long run you can just put symlinks or exes in one of those two directories and you're set.
15:22:47 <sclv> understanding mptcs, fundeps, type families, etc takes a lot more
15:22:51 <Cale> If you want to understand things even more... there's the OutsideIn(X) paper...
15:23:06 <sclv> that's about inference and reconstruction
15:23:12 <sclv> not just like the "meaning" of typeclasses
15:23:22 <Cale> yeah
15:23:57 <monochrom> No, the Haskell Report is not formal enough >:)
15:24:03 <Cale> But it deals with how to work with constraints in a general way
15:24:07 <monochrom> "typing haskell in haskell" is the really formal one.
15:24:30 <sclv> again thats an algorithm, not just a specification
15:24:36 <monochrom> However! Read both, it's best to have cross referencing and mutual help.
15:24:36 <tukane> thanks everyone. the paper has been a non-trivial reading for me, but i'd continue to struggle with this
15:24:36 <Cale> https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/jfp-outsidein.pdf -- this is the paper I'm talking about
15:25:28 <Cale> tukane: What are you hoping to get out of it?
15:26:55 <tukane> Cale: I'm trying to understand why \x->show (read x) can't be of type forall a. (Read a, Show a)=>String->String
15:28:05 <Cale> tukane: Well, it could be, except that a is ambiguous
15:28:14 <radish> how do i temporarily add a path again
15:28:16 <radish> ?
15:28:16 <Cale> In the type String -> String the variable a no longer appears
15:28:24 <radish> just for that one terminal session
15:28:28 <Cale> So, there would ordinarily be no way to specify it
15:28:32 <koz_> tukane: Basically, if your constraints mention type variables that aren't in the function definition itself, how's GHC to know which instance you mean?
15:28:38 <Cale> (until TypeApplications came along)
15:28:50 <koz_> There are _zillions_ of possible things which have Read and Show instances.
15:29:09 <monochrom> radish: PATH=$PATH:/hello/there   (this adds /hello/there)
15:29:26 <solonarv> shouldn't you add to the start, usually?
15:29:32 <solonarv> but yes.
15:29:47 <monochrom> Oh, maybe the start.  PATH=/hello/there:$PATH
15:29:54 <radish> i got it
15:30:07 <Cale> tukane: Does that make sense?
15:30:17 <radish> okay now i just need to choose the first file that ends w .cabal - how would i do that?
15:30:51 <radish> nah that doesnt work either
15:30:56 <radish> hmmmmm
15:31:19 <sclv> what do you mean "choose the first file that ends w .cabal"? for what?
15:31:24 <sclv> for the path?
15:31:41 <monochrom> probably unrelated to PATH
15:32:18 <Cale> tukane: Using modern extensions, we can force the situation though -- if you turn on TypeApplications, AllowAmbiguousTypes and ScopedTypeVariables, you can write
15:32:18 <radish> nah path is working
15:32:38 <Cale> f :: forall a. (Read a, Show a) => String -> String; f x = show (read x :: a)
15:32:43 <Cale> and then something like
15:32:43 <tukane> Cale, koz_: I'm not sure if I'm getting it... `a` appears in `forall a` and also `(Read a)`, which means that the typeclass dictionary is passed to the function when invoked. And because upon typechecking `read x` there's the typeclass dictionary available, the ambiguity can be resolved with that instance. This is my understanding
15:32:49 <Cale> f @Int "56"
15:32:54 <Cale> will evaluate to "56"
15:33:01 <radish> im trying to write the sublime build tool - ive got a bash script for it so its /kind of/ working
15:33:22 <Cale> tukane: But you ended up with a function of type String -> String, so *which* type class dictionary should be passed?
15:33:37 <Cale> tukane: Normally, without TypeApplications, there would be no way to ever make that decision
15:33:53 <solonarv> each of the extensions here has a different purpose.
15:34:15 <Cale> tukane: The compiler would usually sort out which dictionary to pass in by figuring out which type a got unified with
15:34:31 <solonarv> ScopedTypeVariables allows us to explicitly bind the 'a' type variable with the 'forall a. ' in the type signature, and then refer to that *same* type variable in the function's body
15:34:38 <Cale> tukane: But since a no longer actually gets used in the type, only in the constraint, there's no way it'll ever get unified with anything
15:35:00 <solonarv> AllowAmbiguousTypes asks GHC to shut up about that "can't figure out what 'a' should be" error (and defers it to the use site)
15:35:21 <solonarv> finally, TypeApplications at the use site allows us to explicitly say what type we want to instantiate 'a' to
15:35:50 <xe4> with pattern guards, is it possible to emit the error from a Left if you're guarding against several functions that return Either?
15:36:22 <maerwald> monochrom: https://github.com/fish-shell/fish-shell/issues/6960 
15:36:27 <monochrom> tukane: Let me take it to the extreme.  I have type "(Read a, Read b, Show a, Show b) => (String, String) -> (String, String)".  The term is "\(x, y) -> (show (read x), show (read y))".  Should the 1st read use a? b?  Should the 1st show use a? b?  Should the 2nd read use a? b?  Should the 2nd show use a? b?
15:36:31 <maerwald> that's the right direction
15:36:33 <sm> radish: can I ask, to upgrade your stack 1.5.1, did you successfully run "stack upgrade" ? Or did you have to use your system package manager ?
15:39:34 <solonarv> xe4: you mean you have a pattern guard like 'func x y | Right z <- bar x = ...' and in case 'bar x' is actually 'Left err' you want to do something with 'err'?
15:40:18 <tukane> Thanks everyone! Now I think I understand why it's ambiguous
15:40:38 <monochrom> Hey!  "add to path" is a nice exercise for a unix course!
15:40:47 <monochrom> Perhaps I should put it on the exam!
15:41:21 <tukane> Rather than TypeApplications, I tried to resolve the ambiguity with ScopedTypeVariables, which somehow failed: https://pastebin.com/8Fy7XWZ2
15:42:32 <Cale> tukane: That solution works, it's just that you *also* need AllowAmbiguousTypes to make the definition acceptable
15:42:43 <monochrom> You need AllowAmbiguousWhatDoYouCallIt (sp?) to allow "forall a. (Foo a, ..) => here you don't mention a at all" in the first place.
15:42:48 <Cale> and then if you ever want to use normalizePoly, you'll need TypeApplications
15:43:13 <Cale> However, you could also add a fake argument to normalizePoly
15:43:21 <Cale> data Proxy a = Proxy
15:43:34 <monochrom> Yes please just add a proxy parameter!
15:43:42 <Cale> normalizePoly :: forall a. (Show a, Read a) => Proxy a -> String -> String
15:43:50 <radish> sm, i ran stack upgrade and it upgraded just fine, but i had to add something to my path in order to see it, for some reason
15:44:04 <sm> that's right.. it warns you about that at the end
15:44:11 <Cale> Then, when you use normalizePoly, you pass in a Proxy argument of the appropriate type in order to specify which 'a' you wanted to use.
15:44:19 <radish> my current situation is that i can run the precompiled version but i cant figure out how to build one to replace it D:
15:44:19 <sm> radish: ok great. FYI I opened https://github.com/deech/fltkhs/issues/162
15:45:54 <radish> thanks thats great!
15:49:26 <radish> okay ive got sublime building and then running the example program
15:49:45 <radish> i think. better change something to be sure
15:50:28 <gentauro> wow, I just realized that it's possible to do this in pattern matching -> `case list of; x:xs | x=='a' -> "Is an A"; _ -> "It's not an A"` (the part with the `| x == ...` :o
15:51:14 <wikiemol> Does anyone know if there is a quick way to create a stack project template from a project?
15:52:07 <koz_> Is there some way to make compilation of Aeson-including stuff not be super-slow? Even with 'stack build --fast' it takes surprisingly long.
15:53:31 <radish> i dont even understand this at all! i deleted the executable but its still running lmao
15:53:57 <radish> i changed the code and built another one but it didnt appear anywhere and didnt change the output
15:54:56 <radish> man its /really/ hard to break into all this stuff
15:55:14 <jacks2>  whereis <executable name>
15:55:51 <radish> result is blank space
15:55:59 <radish> damn im out of time too
15:56:08 <radish> guess i'll study stack tomorrow?
15:56:13 <ja> gentauro: i think it is called pattern guards
15:56:17 <radish> not really sure lol
15:56:24 <xe4> solonarv: that is correct
15:56:26 <radish> bye all thanks for everything
15:56:28 <ja> gentauro: monochrom had some weird favorite usage of that, iirc
15:56:53 <sm[m]> radish: good luck
15:57:36 <solonarv> xe4: don't think you can do that... well you can just have another '| Left err <- bar x' pattern guard further down, I suppose
15:57:44 <radish> oh wait my code did effect it somehow
15:57:50 <radish> wtf
15:57:56 <radish> just partially not completely
15:58:08 <radish> i have no idea why gotta study the codebase a bit closer maybe
15:58:45 <solonarv> gentauro, ja: no, the '| <condition>' thing in a case expression is just a guard
15:58:49 <solonarv> not a pattern guard
15:59:01 <radish> ah okay got everything working
15:59:09 <radish> thanks a ton everyone i can maybe progress on my own from here
15:59:24 <sm[m]> Great progress, congrats
15:59:40 <sm[m]> Expect more headaches, but they are temporary
16:00:24 <radish> the only thing im worried about is how overly convoluted the basic project is
16:01:00 <sm[m]> Do you mean the project files ?
16:01:11 <radish> like theres a setup.hs and a main.hs and they're both pretty big for a hello world
16:01:31 <ja> solonarv: ok. so a pattern guard always uses <- ?
16:01:32 <radish> couldnt even figure out how to rename the executable properly lol
16:01:42 <radish> but yeah anyway i can work with this
16:02:05 <sm[m]> you can write a single file script if you prefer. But as soon as you have multiple files, you wonâ€™t mind the project layout so much
16:02:41 <gentauro> ja: and solonarv it's usefull in some cases (iirc I saw it in some OCaml code)
16:02:50 <sm[m]> Setup.hs can be deleted I think
16:03:28 <sm[m]> Radish: also ghcid is a tool that will be useful
16:04:34 <ja> pattern guards are always safe right? they will never be "incomplete" like if you match in e.g. do notation?
16:05:36 <solonarv> ja: if the pattern doesn't match, the guard just won't happen and you go to the next guard or clause
16:06:00 <MarcelineVQ> they're just like comprehensions in that way
16:06:23 <solonarv> radish: Setup.hs should contain like 3 or 4 lines, what's in it?
16:07:22 <ja> solonarv: https://wiki.haskell.org/Pattern_guard are pattern guards constraned to working with monad? how do they know that this function should return none if a match fails?
16:07:44 <solonarv> where did you get the idea that there has to be a monad involved?
16:08:13 <solonarv> and, "how do they know that this function should return none if a match fails?" - that's what the other equations are for
16:08:52 <ja> aaah, ok, so that example will indeed have runtime errors without sufficient other equations
16:09:23 <ja> i thought it was somehow equivalent to a MaybeT, e.g. the first Nothing encountered would return Nothing for the whole block
16:09:29 <solonarv> yes, and I think you'll get a warning at compile time as well
16:10:13 <wavemode_> if you have -Wall
16:10:30 <wavemode_> or -Wincomplete-patterns
16:11:02 <tukane> Cale, monochrom: It took a bit for what I read to sink in, but I think I finally got this. Thanks for the explanations
16:11:14 <ja> but ok, i do see how it could be useful if you want to avoid having a ton of matches on the LHS and don't want to name another function
16:14:21 <sm[m]> radish was talking about this project template I assume: https://github.com/deech/fltkhs-hello-world
16:15:33 <sm[m]> 50 lines of setup doing something or other
16:18:17 <monochrom> solonarv, ja: Perhaps ja saw "<-" and think do-notation and think monad.  But I have a good explanation why they chose "<-" not "->".
16:19:10 <monochrom> Suppose they chose "->".  We should also expect pattern guards to appear in "case-of".  So: "case foo of Just x -> x>0 -> 45" doesn't that look really bad? :)
16:19:36 <monochrom> Err I blew the example. Here is a better one.
16:20:22 <monochrom> case foo of lookup foo bar -> Just x -> x+5
16:21:29 <monochrom> This is now also how I remember it's "pat <- expr".  To remember that the other option is insane.
16:22:03 <monochrom> or maybe s/is insane/has a problem/
16:23:31 <monochrom> Ah I also see the wiki page can send the wrong message because it brings up list comprehension (therefore monad comprehension).
16:23:47 <monochrom> This is why I distance myself from the wiki.
16:45:36 <johnw> monochrom                          the wiki
16:54:46 <monochrom> haha
16:55:14 <monochrom> please wear mask when reading the wiki, and wash hands afterwards!
16:59:10 <maerwald> wiki is a great source... for confusion
17:02:23 <MarcelineVQ> pattern guard syntax is directly taken from comprehensions. literally someone went, hey we have this form of patterns in comprehensions, why don't we let those appear in guards too
17:02:53 <monochrom> The problem is that the semantics is markedly different.
17:03:47 <monochrom> A history documentary would be right to point out how the choice was made.  But the wiki has other priorities.
17:05:04 <monochrom> My idea of the wiki's priority is coherence.  But other people's idea is brain dump and showing they're high.
17:07:25 <MarcelineVQ> hmm, I thought the wiki linked to the mailing list entry, now I wonder how I saw it in the first place
17:13:03 <MarcelineVQ> monochrom: someone shares your opinion about the differing semantics of <- https://mail.haskell.org/pipermail/haskell-prime/2006-December/001973.html
17:28:17 <koz_> phadej: Are you gonna push 0.1.3 of cabal-fmt to Hackage?
17:34:09 <jacks2> @hoogle (a <- Bool) -> [a] -> [(a, a)]
17:34:09 <lambdabot> package base
17:34:09 <lambdabot> package bytestring
17:34:09 <lambdabot> package containers
17:34:48 <Axman6> <- o.O
17:34:52 <jacks2> is it me or lambdabot who forgot how to hoogle
17:35:07 <Axman6> well, your type doesn't make sense...
17:35:20 <jacks2> what about it makes no sense?
17:35:32 <Axman6> (a <- Bool)
17:35:37 <jacks2> oh :)
17:35:47 <jacks2> @hoogle (a -> Bool) -> [a] -> [(a, a)]
17:35:48 <lambdabot> No results found
17:36:12 <Axman6> what result do you want? what's that supposed to do?
17:36:14 <jacks2> @hoogle (a -> Bool) -> [a] -> ([a], [a])]
17:36:14 <lambdabot> package base
17:36:14 <lambdabot> package bytestring
17:36:14 <lambdabot> package containers
17:36:16 <jacks2> @hoogle (a -> Bool) -> [a] -> ([a], [a])
17:36:17 <lambdabot> Prelude span :: (a -> Bool) -> [a] -> ([a], [a])
17:36:17 <lambdabot> Prelude break :: (a -> Bool) -> [a] -> ([a], [a])
17:36:17 <lambdabot> Data.List span :: (a -> Bool) -> [a] -> ([a], [a])
17:36:25 <Axman6> there's also partition
17:36:33 <Axman6> > partition even [1..10]
17:36:36 <lambdabot>  ([2,4,6,8,10],[1,3,5,7,9])
17:36:38 <jacks2> I want two lists, those that match the predicate, and those that don't
17:37:00 <jacks2> partition seems to be what I want
17:37:03 <jacks2> > span even [1..10]
17:37:05 <lambdabot>  ([],[1,2,3,4,5,6,7,8,9,10])
17:37:06 <Axman6> then you want parttition
17:37:10 <jacks2> > break even [1..10]
17:37:12 <lambdabot>  ([1],[2,3,4,5,6,7,8,9,10])
17:40:15 <koz_> For the iterateN method of Data.Vector.*, am I right in assuming that 'iterateN k f x' will give me a vector of length (k + 1)?
17:41:38 <dsal> % V.iterateN 5 succ 0
17:41:39 <yahb> dsal: [0,1,2,3,4]
17:41:55 <koz_> Huh, OK then.
17:42:07 <koz_> So it actually disagrees with the docs.
17:42:11 <dsal> off-by-one as a service
17:42:18 <koz_> Since the function is clearly _not_ being applied 'n' times.
17:42:32 * koz_ shuffles off to file another bug.
17:42:51 <dsal> :t makeClassyFor -- I don't quite understand this thing.
17:42:52 <lambdabot> String -> String -> [(String, String)] -> Language.Haskell.TH.Syntax.Name -> Language.Haskell.TH.Lib.Internal.DecsQ
17:43:21 <dsal> Why does it need to put a thing between my value and the property I want?
17:46:44 <koz_> dsal: Woo, it's even better. It doesn't apply the function n times, or even (n - 1) times!
17:46:50 <koz_> It's actually min{0, n - 1} times.
17:47:14 <dsal> Any time I see something like that, I assume I'm writing an off-by-one error.
17:50:20 * hackage zeolite-lang 0.4.1.0 - Zeolite is a statically-typed, general-purpose programming language.  https://hackage.haskell.org/package/zeolite-lang-0.4.1.0 (ta0kira)
17:52:14 <koz_> ... and reported. 69 issues!
17:52:17 <koz_> (nice)
17:52:47 <Uniaika> < koz_> So it actually disagrees with the docs. // May I serve you? :)
17:52:47 <Axman6> nice
17:53:19 <koz_> Uniaika: You may. I'll have one coffee, three croissants, all the butter you have in the cafe, and the wifi password.
17:53:40 <koz_> (although asking for _all the butter_ at a French cafe is dangerous)
17:53:59 <dmwit> Don't worry. This is a Jamaican cafe, all it gets you here is some swears.
17:54:02 <Uniaika> koz_: Sorry, but chances are that you wouldn't survive the pure, raw essence of french viennoiseries 
17:54:17 <koz_> viennoseries?
17:54:41 <Uniaika> croissants, pains au chocolat, pains aux raisinsâ€¦
17:54:54 <Uniaika> all that is not pastry
17:55:02 <Uniaika> but not bread either
17:55:16 <koz_> Uniaika: Try me. :P
17:55:34 <koz_> (I have a resident French baker, trained in actual France)
17:55:42 <Uniaika> haha
17:55:45 <koz_> (I doubt he cuts down on his butter use because of silly things like 'not being in France')
17:55:56 <Axman6> I'm also willing to participate
17:56:10 <Uniaika> more seriously, before I go to bed, is there anything I can help with in terms of documentation?
17:56:22 <koz_> Uniaika: Are you involved with docs for vector?
17:56:27 <koz_> I thought you only dealt with base.
17:56:48 <Uniaika> no but I can be insistant enough so that it may be the cse.
17:56:50 <Uniaika> case
17:56:52 <lyxia> min(0, n-1) is nonpositive...
17:57:10 <koz_> ... MAX.
17:57:14 <koz_> Now who's off-by-one.
17:57:43 <koz_> Duly fixed.
17:58:10 <koz_> Uniaika: In that case, please insist in whoever-is-responsible's direction.
18:02:01 <sm[m]> I'm hungry
18:02:45 <koz_> sm[m]: What is the timezone-local timestamp?
18:03:39 <sm[m]> pardon koz_ ? local time is 18:03:15
18:03:53 <koz_> sm[m]: That's what I meant. Order pizza.
18:04:03 * sm[m] feels like a barbarian for thinking are croissants etc. are pastry
18:04:14 <koz_> With like, three cheese or five cheese or twenty cheese or whatever absurd cheese number you have available.
18:04:32 <sm[m]> pizza, pah... I crave real food
18:04:39 <koz_> sm[m]: Pizza is real food.
18:04:56 <sm[m]> if I could get it delivered from europe , yes :)
18:05:37 <koz_> sm[m]: Lol.
18:05:41 <koz_> Little difficult nowadays.
18:05:44 <koz_> What with all the COVID-19.
18:05:47 <koz_> Everywhere.
18:05:56 <koz_> Flying food in got _so_ hard!
18:06:15 * sm[m] dreams of pre-covid viennoiseries.. delivering to Los Angeles..
18:06:22 <Axman6> with the way airlines are going at the moment, they might just say yes if you asked them to fly you a pizza
18:06:39 <koz_> Axman6: Sure. Then bill you like, a million dollars.
18:06:48 <koz_> After laughing amongst themselves for ten minutes.
18:07:09 <Uniaika> sm[m]: the order of complexity is the following: breads < viennoiseries < pastries
18:07:14 <koz_> @pl \p t -> find (== t) (foo p)
18:07:14 <lambdabot> flip (find . (==)) . foo
18:07:20 <Axman6> you jujst reply "$30, take it or leave it", they'll come begging for any cash at allin no time
18:07:22 <Uniaika> viennoiseries are most often a good compromise
18:07:29 <koz_> Axman6: Can't argue with that logic.
18:07:39 <koz_> Start with the 'budget' airlines first.
18:07:45 <koz_> Since you can argue that their flights are usually cheaper.
18:07:55 <sm[m]> Uniaika: I see
18:07:56 <Axman6> fuck that, I'm asking Qantas
18:08:02 <koz_> Axman6: Not Virgin Australia>?
18:08:12 <koz_> Or whatever the Australian Ryanair is.
18:08:23 <Axman6> if they weren't in administration at the moment, perhaps
18:08:52 <Axman6> Virgin aren't a budget carrier anymore in Aus, they've been competing with Qantas
18:09:10 <koz_> Axman6: Huh, OK. Learn something new every day.
18:25:39 <dsal> I want to release a library version like 0.7.-3.0
18:26:23 <dsal> I broke the API and I'm not done breaking the API.  I guess the logical thing is to not release the thing yet.
18:31:28 <koz_> Is it correct to say that deriving Generic for an ADT means you can no longer enforce any constraints on said ADT, aside from the types of its fields?
18:32:52 <koz_> I believe 'yes' because you can just grab its Rep, munge it arbitrarily, then turn it back into the thing it Reps.
18:33:05 <koz_> Or heck, just build said Rep directly.
18:38:29 <dsal> "Not cryptographic hash found for Hackage package exceptions-0.10.4"
18:38:41 <dsal> My build is failing on github.  That's unfortunate.
18:39:03 <Axman6> I had that happen to me with exceptions the other day too
18:39:43 <Axman6> koz_: you should take a look at the higgledy from scratch videos on youtube, it's built around doing exactly that
18:40:17 <koz_> Axman6: You mean building arbitrary Reps?
18:40:22 <koz_> And turning them into whatever?
18:40:48 <dsal> I really don't understand where `makeClassyFor` is useful, but I wrote my own class and instances and all the things I want to happen happen now.
18:41:04 <Axman6> the idea behind Higgeldy is taking product types and getting generic HKD versions of them for free
18:42:50 <Axman6> everything is done using a Rep derived version of your data (which sounds very inefficient but whatevs), where there's a type family and typeclass for taking a Rep a and applying some functor to all the fields
18:48:46 <dsal> Argh.  Works on my machines, but not on github's.  I hope someone somewhere fixes that so I don't have to think about it.
18:54:32 <solonarv> koz_: I am inclined to agree (with the Generic thing)
18:55:11 <Axman6> dsal: have you done a cabal/stack update?
18:55:32 <dsal> Not lately.
18:55:43 <dsal> Will that fix the "works for me" part?  :)
18:59:03 <koz_> Good to know.
18:59:07 <koz_> This is legit useful info.
19:33:04 <dmwit> koz_: You can have `to` enforce your invariant, I guess?
19:33:57 <dmwit> koz_: e.g. imagine `instance Generic (Map k v) where from = from . toAscList; to = fromList . to` or something.
19:34:32 <radish> solonarv, you still on?
19:34:51 <dmwit> koz_: ordered-containers does something similar to offer a Data instance that doesn't violate its internal invariants.
19:36:31 <dada_cetacean> now that `intero` is not being mantained, is there a canonical replacement for it (for Haskell development in Emacs)?
19:42:30 <solonarv> radish: I am, yes
19:42:55 <koz_> dmwit: Oh, that's really clever.
19:42:59 <koz_> Thanks, will use.
19:45:20 * hackage calamity 0.1.5.0 - A library for writing discord bots  https://hackage.haskell.org/package/calamity-0.1.5.0 (nitros12)
20:39:28 <petersen> I have an unused import in my module but ghc isn't warning me with -Wall and -fwarn-unused-imports
20:41:27 <dibblego> petersen: can you make code that can reproduce it for others?
20:57:47 <koz_> I require wordplay assistance from the experts. I currently have a newtype (called Finiteness), purely there for DerivingVia shenanigans. Currently, this leads to wording of the form 'deriving ... via (Finiteness Foo)'. Is there a less awkward, more clever name I could give to 'Finiteness' for maximizing wordplay?
20:58:08 <koz_> (the newtype essentially 'manifests' the fact that its wrapped type is Finitary to derive a whole bunch of things)
21:18:56 <p0a> how can I read the definition of Applicative
21:18:57 <p0a> from ghci?
21:19:08 <koz_> p0a: Why not just read the base docs?
21:19:20 <p0a> Is there a quick way to bring them up?
21:19:26 <Cale> You can :info Applicative and get something approximate
21:19:36 <koz_> % :info Applicative
21:19:37 <yahb> koz_: type Applicative :: (* -> *) -> Constraint; class Functor f => Applicative f where; pure :: a -> f a; (<*>) :: f (a -> b) -> f a -> f b; liftA2 :: (a -> b -> c) -> f a -> f b -> f c; (*>) :: f a -> f b -> f b; (<*) :: f a -> f b -> f a; {-# MINIMAL pure, ((<*>) | liftA2) #-}; -- Defined in `GHC.Base'; instance [safe] Applicative (Bazaar p a b) -- Defined in `Control.Lens.Internal.Bazaar'; ins
21:19:39 <p0a> nice thank you 
21:19:50 <Cale> @hackage base
21:19:50 <lambdabot> http://hackage.haskell.org/package/base
21:20:49 <Cale> (click module names for documentation, look near the right margin for source links on definitions)
21:22:36 <Cale> Also, once you're on any of the documentation pages, there's a link to an index at the top, if you're not sure what module something is in, but know it's in this package
21:22:42 <p0a> so lift2A means lift to applicative 
21:23:01 <p0a> oh nice
21:23:15 <p0a> I see that now 
21:23:43 <Cale> liftA2 means lift a function of two arguments using Applicative
21:23:51 <p0a> oh hah I misread it
21:23:59 <Axman6> liftA3 means lift three Applicative
21:24:03 <Axman6> >_>
21:24:21 <p0a> right :P
21:26:37 <koz_> Haskell most powerful language - all we do is lift.
21:27:13 <p0a> I prefer isometrics :P
21:28:50 <Cale> Yeah, the word "lift" is a word that is given a lot of different meanings, but generally used to refer to operations which generalise things or embed them into a "larger" type of things
21:29:17 <koz_> Yep, which is why Haskellers lift so much.
21:53:50 * hackage zeolite-lang 0.4.1.1 - Zeolite is a statically-typed, general-purpose programming language.  https://hackage.haskell.org/package/zeolite-lang-0.4.1.1 (ta0kira)
21:58:33 <dibblego> data Blah f a b = Blah (f a) (f b) -- is this in any library?
22:04:41 <p0a> why is a functor not an applicative?
22:05:40 <p0a> I think (as I read it), an applicative is a functor with more stuff. Why not the other way around? fmap f x =  (pure f <*> x
22:06:05 <dibblego> that demonstrates that given Applicative, you can recover Functor
22:06:12 <dibblego> try writing (<*>) using only fmap
22:06:57 <p0a> ahah
22:06:58 <p0a> okay
22:07:06 <p0a> I got tripped up, thanks
22:07:31 <monochrom> Be careful.  More operations to support = Fewer instances.
22:07:59 <monochrom> So be careful with "more stuff" --- which stuff? which side?
22:09:06 <p0a> I'm going to try to write <*> using fmap to see 
22:09:23 <monochrom> The classical Aristotle duality of enumerating properties vs enumerating examples.  More on one side means restrictions on the other side.
22:10:16 <dibblego> set yourself a time limit â€” don't want you to be there forever
22:10:21 <monochrom> I haven't proved it, I may be wrong, but I conjecture that "data B a = Leaf | Node a (B a) (B a)" cannot be made an Applicative instance.
22:11:58 <monochrom> Hrm, maybe the zip-list idea can be brought to B and make it an Applicative instance.
22:12:06 <isovector1> is there some way to get the defaulting rules to apply to user-written classes?
22:12:38 <isovector1> i have a custom Eq-ish class that I'd to turn on the extended defaulting rules for
22:12:47 <dibblego> https://gist.github.com/tonymorris/8726e90a80fe0d89bc50fbf050d02d60
22:13:11 <isovector1> alternatively, is there a way to locally introduce an INCOHERENT instance? :) 
22:14:20 <Cale> isovector1: These sound like XY problems to me, what are you actually trying to do?
22:16:23 <isovector1> what i'm really trying to do is generate code that describes algebraic laws for functions. those functions are possibly polymorphic, and so GHC refuses to pick an instance of my Eq-ish thing. but paramatricity proves that it can't matter
22:16:51 <p0a> is there a way to have ghci appear in color?
22:17:02 <isovector1> so rather than have ghc complain that it can't choose which Eqish a to use, i'd like to steamroll those errors and assume it's Int
22:17:06 <p0a> I tried ghci --colour from https://wiki.haskell.org/GHCi_in_colour but it didn't recognize the option
22:17:47 <Axman6> that page is documenting a proposal that didn't happen
22:17:58 <p0a> alright
22:18:06 <Axman6> there are ways to get prettier output in ghci, ghci-pretty being one
22:18:51 <p0a> thank you 
22:20:53 <isovector1> Cale: so assuming i really do want to change the defaulting rules (or alternatively, introduce a locally incoherent instance) how do i go about doing that
22:21:14 <Cale> I don't think there's a way of doing either of those things.
22:22:08 <isovector1> not with that attitude
22:24:50 <Cale> isovector1: Does it not work just to @Int in the right place enough times?
22:25:38 * Axman6 senses a new ghc plugin from isovector1
22:25:53 <Cale> isovector1: I suppose that only gets you proofs for Int, but you want them for other types instead?
22:25:59 <Cale> (but that makes sense)
22:26:23 <isovector1> int is fine. but this is arbitrary user code, and doing that automatically would require me to write a typechecker :)
22:26:54 <isovector1> edwardk: do you know of any sorcery for doing reflection to generate incoherent instances?
22:27:00 <Cale> You could also just write the polymorphic laws you wanted, prove them on paper, and then unsafeCoerce an arbitrary thing to them or something.
22:27:15 <Cale> If it doesn't matter what value you get
22:27:30 <Cale> I'm assuming you're talking about type-level equalities?
22:28:38 <Cale> You can always unsafeCoerce Refl to whatever sort of equality you wanted.
22:28:59 <isovector1> Cale: in particular i'm talking about a library for generating checkers properties based around EqProp for arbitrary programs of arbitrary types, none of which is specified by me.
22:29:51 <isovector1> what would this refl thing look like?
22:30:12 <isovector1> eg i have this: `property $ \ix c v v' s -> (setEntity ix (set c v') (setEntity ix (set c v) s)) == (setEntity ix (set c v') s)`
22:30:25 <isovector1> except with (=-=) instead of (==)
22:30:34 <isovector1> == would be ok, because then i'd get defaulting :0
22:30:41 <Cale> Ah, so this is entirely term-level
22:30:44 <Cale> okay
22:31:29 <Cale> Is that property from QuickCheck?
22:31:33 <isovector1> yeah
22:32:03 <Cale> QuickCheck has some template haskell for checking polymorphic properties by defaulting everything to Integer
22:32:05 <isovector1> setEntity, eg, is specified by the end user, and might be polymorphic in many variables, only some of which might be ambiguous and thus need to be instantiated at Int. blindly throwing ty apps at this seems infeasible to me
22:32:09 <Cale> polyQuickCheck
22:32:23 <Cale> There's also monomorphic
22:32:32 <Cale> http://hackage.haskell.org/package/QuickCheck-2.14/docs/Test-QuickCheck-All.html#v:monomorphic
22:33:09 <isovector1> this happens before quickcheck gets a chance, i think. these functions won't even compile
22:33:26 <Cale> ah, right
22:33:59 <Cale> But wait... what's the type of the thing this is in?
22:34:13 <isovector1> ?
22:34:20 <Cale> Is the user required to provide polymorphic things?
22:34:51 <isovector1> no. this is an interactive tool for designing APIs
22:34:54 <Cale> I'm confused about why this code can't just be making the decision about what type to use =-= at
22:35:02 <petersen> dibblego: not sure, thanks - I can "reproduce" in my project - it might well be some edge case...
22:35:05 <isovector1> let me upload something
22:36:20 * hackage lens-toml-parser 0.1.0.4 - Lenses for toml-parser  https://hackage.haskell.org/package/lens-toml-parser-0.1.0.4 (henrytill)
22:36:22 <Cale> isovector1: One idea might be to just make a new class that you don't export and make incoherent instances for it
22:37:11 <Cale> But that might not work, if the user is writing Eqish instances themselves
22:39:42 <isovector1> Cale: https://gist.github.com/isovector/f78c968f6799e17434e02686f7826df8
22:40:44 <isovector1> the user is.
22:41:34 <Cale> What's the type of =-= ?
22:41:45 <Cale> Oh, you gave it
22:52:34 <Cale> isovector1: I guess another approach to think about is whether the tool should maybe transform the types that the user gave for API things as it's rewriting everything.
22:55:09 <isovector1> how should it transform the types?
22:55:26 <Cale> Replace every free type variable with Int or something
22:56:30 <isovector1> that requires doing a typechecking pass
22:56:59 <Cale> You mean, just to make sure that the user's types made sense in the first place?
22:57:12 <isovector1> oh sorry i misunderstood
22:57:46 <isovector1> i think you're suggesting monomorphizing all of the definitions it sees?
22:57:50 <Cale> Of course, this won't deal with the situation where the user binds type variables
22:58:08 <Cale> But quickchecking higher-rank stuff doesn't sound easy :P
22:58:17 <Cale> yeah
22:58:17 <isovector1> i could make a copy of every definition with a monomorphic type and then pointing its definition at the polymorphic one
22:58:34 <isovector1> but it's a pretty big hack rather than just turning on defaulting :)
23:00:36 <Cale> The only classes for which ExtendedDefaultRules works are Show, Eq, Ord, Foldable, and Traversable
23:01:27 <Cale> (In addition to the usual numeric classes)
23:06:17 <Cale> Well, you need the variable to be constrained by at least one of those classes, if that helps
23:06:19 <p0a> I want to create a tree of subsets of a set
23:06:36 <Cale> Maybe you could add additional constraints, but I'm not sure that's any easier than just rewriting the types
23:06:44 <p0a> and perform a breadth-first search there
23:07:03 <p0a> Should I define my own types and algorithms or ?
23:07:38 <Cale> I probably would
23:08:43 <p0a> There's also Data.Tree 
23:08:48 <Cale> You could use the tree type from Data.Tree, but it would save you approximately one line of code and you'd get something that had an ugly Show instance. :P
23:09:00 <p0a> I see 
23:09:27 <p0a> Can show generate images?
23:09:51 <Cale> show should generally produce something that is as close to Haskell source code as it can
23:10:00 <p0a> I think they had something like that in Racket
23:10:13 <p0a> Cale: to be used by read?
23:10:27 <Cale> To be used by Haskell developers trying to test functions
23:10:42 <p0a> fair point but sometimes the best way to test something is with an image. Not that trees fit this description
23:10:44 <Cale> Remember that when ghci prints a value, it's going to put it through show
23:10:59 <p0a> right
23:11:17 <Cale> and it's really useful to be able to copy/paste values from ghci to do things like making unit tests
23:11:43 <Cale> Not all show instances produce valid Haskell code, but usually people try
23:12:06 <Cale> But it's not like it's the only type class in existence -- you can define all the Show-like classes you want
23:12:40 <Cale> So it would make perfect sense to have something which turned values of various types into pictures of some form
23:13:04 <Cale> ghci won't be able to display them itself, but perhaps you could use gloss or something
23:13:44 <Cale> There's that iHaskell thing as well, which I think has some facility for doing tricks of that sort
23:15:30 <p0a> oh nice
23:15:46 <p0a> I've never used Jupyter and I'm not sure what it is but it seems quite useful
23:17:05 <p0a> also gloss looks very nice
23:21:50 <koz_> Cale: class ReallyPretty a where ...
23:23:24 <p0a> okay so here's what I Want 
23:23:30 <p0a> I want to define a Tree data type
23:23:57 <p0a> I want to transverse it breadth first and create Maybe's in the nodes and then I want to prune the Nothing's
23:24:44 <p0a> so for example if the tree was {1 -> 2 -> 5, 1 -> 3} and you apply `odd' it becomes {Just 1 -> Nothing, Just 1 -> Just 3}
23:24:58 <p0a> and perhaps that should be Just { 1 -> 3 }
23:25:08 <koz_> p0a: So you want mapMaybe for a tree?
23:25:26 <p0a> :t mapMaybe
23:25:30 <lambdabot> (a -> Maybe b) -> [a] -> [b]
23:25:44 <c_wraith> What do you want to happen to the children of the Nothing nodes?
23:25:50 <p0a> gone
23:25:54 <p0a> they'll be Nothing's too
23:26:12 <p0a> (according to what I'm looking for; if you're bad, so are your descendants)
23:26:31 <c_wraith> hereditary sin?  noooo!
23:26:37 <p0a> lol
23:26:42 <p0a> I knew it sounded awful as I said
23:26:43 <p0a> it
23:27:02 <koz_> Yeah, so define something like mapMaybe for said tree.
23:27:10 <koz_> It's quite doable recursively given wht you just said.
23:27:37 <Cale> @let data MyTree a = Tip | Branch a (MyTree a) (MyTree a)
23:27:39 <lambdabot>  Defined.
23:28:29 <Cale> @let foldTree tip branch = f where f Tip = tip; f (Branch x l r) = branch x (f l) (f r)
23:28:32 <lambdabot>  Defined.
23:29:15 <Cale> :t foldTree Tip (\x l r -> case x of Nothing -> Tip; Just v -> Branch v l r)
23:29:17 <lambdabot> error:
23:29:17 <lambdabot>     Ambiguous occurrence â€˜foldTreeâ€™
23:29:17 <lambdabot>     It could refer to either â€˜Data.Tree.foldTreeâ€™,
23:29:21 <Cale> tsk
23:29:28 <Cale> @let foldMyTree tip branch = f where f Tip = tip; f (Branch x l r) = branch x (f l) (f r)
23:29:30 <lambdabot>  Defined.
23:29:33 <Cale> :t foldTree Tip (\x l r -> case x of Nothing -> Tip; Just v -> Branch v l r)
23:29:35 <lambdabot> error:
23:29:35 <lambdabot>     Ambiguous occurrence â€˜foldTreeâ€™
23:29:35 <lambdabot>     It could refer to either â€˜Data.Tree.foldTreeâ€™,
23:29:37 <Cale> :t foldMyTree Tip (\x l r -> case x of Nothing -> Tip; Just v -> Branch v l r)
23:29:38 <lambdabot> MyTree (Maybe a) -> MyTree a
23:30:19 <Cale> @let mapMyTree f = foldMyTree Tip (\x l r -> Branch (f x) l r)
23:30:22 <lambdabot>  Defined.
23:31:14 <p0a> I'll look at what you did soon 
23:31:22 <Cale> > mapMyTree (\x -> guard (odd x) >> Just x) (Branch 1 (Branch 2 (Branch 5 Tip Tip) Tip) (Branch 3 Tip Tip)))
23:31:25 <lambdabot>  <hint>:1:106: error: parse error on input â€˜)â€™
23:31:27 <Cale> oops
23:31:29 <p0a> I'm testing my Functor instance first, see if I got it right. Our tree definitions are the same, except the names
23:31:33 <Cale> > mapMyTree (\x -> guard (odd x) >> Just x) (Branch 1 (Branch 2 (Branch 5 Tip Tip) Tip) (Branch 3 Tip Tip))
23:31:35 <lambdabot>  error:
23:31:35 <lambdabot>      â€¢ No instance for (Show (MyTree (Maybe Integer)))
23:31:35 <lambdabot>          arising from a use of â€˜show_M37405245464561430272944â€™
23:31:40 <Cale> oh of course
23:31:47 <p0a> almost the same, you're using two branches I'm using a list
23:31:56 <Cale> @let deriving instance Show a => Show (MyTree a)
23:31:58 <lambdabot>  Defined.
23:32:01 <Cale> > mapMyTree (\x -> guard (odd x) >> Just x) (Branch 1 (Branch 2 (Branch 5 Tip Tip) Tip) (Branch 3 Tip Tip))
23:32:04 <lambdabot>  Branch (Just 1) (Branch Nothing (Branch (Just 5) Tip Tip) Tip) (Branch (Just...
23:32:57 <Cale> @let pruneMyTree = foldMyTree Tip (\x l r -> case x of Nothing -> Tip; Just v -> Branch v l r)
23:32:59 <lambdabot>  Defined.
23:33:06 <Cale> > pruneMyTree (mapMyTree (\x -> guard (odd x) >> Just x) (Branch 1 (Branch 2 (Branch 5 Tip Tip) Tip) (Branch 3 Tip Tip)))
23:33:09 <lambdabot>  Branch 1 Tip (Branch 3 Tip Tip)
23:34:15 <Cale> p0a: This kind of "fold" which replaces each of the data constructors of a type with other values (called a "catamorphism" if you're being technical) is often very useful in general
23:34:54 <p0a> what's wrong with 
23:35:00 <p0a> instance Functor (Tree a) where ... 
23:35:04 <Cale> Oh, nothing
23:35:13 <Cale> I just didn't feel like writing an instance head
23:35:21 <p0a> Cale: I havent' yet read what you wrote I am trying to define a Functor instance first
23:35:26 <p0a> but I can't get it to work, let me past ethe code 
23:35:26 <Cale> But definitely you'd prefer that
23:35:32 <Cale> oh
23:35:42 <p0a> I will read your code after I do this Functor thing. I was trying to practice 
23:35:44 <Cale> There's a problem in that you probably have only one parameter
23:35:56 <Cale> The argument to Functor needs to be a type of kind * -> *
23:36:01 <p0a> https://pastebin.com/x09Hy8i0
23:36:07 <Cale> So you probably just want  instance Functor Tree where
23:36:10 <p0a> AH RIGHT
23:36:13 <p0a> gash
23:38:45 <p0a> okay I did it, now I'll read your code
23:39:49 <Cale> Could also have done it in one shot...
23:40:38 <Cale> > foldMyTree Tip (\x l r -> if odd x then Tip else Branch x l r) (Branch 1 (Branch 2 (Branch 5 Tip Tip) Tip) (Branch 3 Tip Tip)))
23:40:40 <lambdabot>  <hint>:1:127: error: parse error on input â€˜)â€™
23:40:45 <Cale> > foldMyTree Tip (\x l r -> if odd x then Tip else Branch x l r) (Branch 1 (Branch 2 (Branch 5 Tip Tip) Tip) (Branch 3 Tip Tip))
23:40:47 <lambdabot>  Tip
23:40:50 <Cale> oops
23:40:57 <Cale> oh, right, I negated it
23:41:13 <Cale> > foldMyTree Tip (\x l r -> if odd x then Branch x l r else Tip) (Branch 1 (Branch 2 (Branch 5 Tip Tip) Tip) (Branch 3 Tip Tip))
23:41:15 <lambdabot>  Branch 1 Tip (Branch 3 Tip Tip)
23:41:19 <Cale> there
23:41:36 <Cale> I should go to sleep
23:41:38 <p0a> thanks Cale 
23:41:44 <Cale> no problem
