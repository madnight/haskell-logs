00:01:12 <MATx> Hi guys, how can I took value out of this data structure?
00:01:13 <MATx> {TPesel.value = Text.pack $ show v ++ Text.foldl(\acc x -> acc ++ show x where Token Numeral NumeralData{TNumeral.value = x}) 0 arr }
00:01:37 <MATx> I tried to do it in Text.foldl
00:02:00 <MATx> so I can add every value inside Token array
00:04:28 <MATx> I tried to do show x where Token {token.value = x}
00:04:34 <MATx> but it seems to not work :(
00:04:54 <MATx> any ideas I can try?
00:15:42 <MATx> I was thinking about map function
00:15:59 <MATx> but I don't know how to strip Token {token.value} 
00:16:02 <MATx> to just token.value
00:24:38 <dmj`> kolu: fn :: ((a, b) -> c) -> (a, b) -> c
00:25:08 <dmj`> MATx: can you make a gist of your code? or use lpaste.net
00:25:50 <kolu> damn
00:25:52 <kolu> that was easy
00:26:08 <kolu> thanks
00:26:14 <dmj`> kolu: np
00:26:36 <dmj`> the trick is that c is polymorphic enough to be a or b
00:31:43 <MATx> https://gist.github.com/Kaspazza/6d07e6d773d71be7deeafe72b85a4792
00:31:51 <MATx> Here is gist dmj'
00:31:59 <MATx> dmj`
00:32:44 <kolu> dmj`
00:32:57 <kolu> can u suggest something begginer friendly on types and typeclasses?
00:33:00 <MATx> I have data in form of list of objects: Token {token.value} and I want to make it a list of token.value
00:33:10 <MATx> so I can print it
00:33:42 <MATx> kolu http://learnyouahaskell.com/making-our-own-types-and-typeclasses
00:33:44 <dmj`> kolu: http://cmsc-16100.cs.uchicago.edu/2019-autumn/lectures.php <- I learned from these back in the day
00:34:14 <MATx> dmj` or instead of making it a list of values from tokens I was thinking of directly using them in foldl
00:34:22 <MATx> but I can't do any of it
00:34:54 <kindaro> Hello! I just posted a question on Haskell Discourse, and I would like to hear possibly more opinions. Since the medium is not as lively and well-known as here, Stack Overflow or Reddit, I am throwing a link here. https://discourse.haskell.org/t/code-style-case-versus-when-in-imperative-blocks/1265
00:37:45 * hackage aeson 1.5.1.0 - Fast JSON parsing and encoding  https://hackage.haskell.org/package/aeson-1.5.1.0 (AdamBergmark)
00:37:46 <kolu> thank you
00:42:45 * hackage quickcheck-instances 0.3.23 - Common quickcheck instances  https://hackage.haskell.org/package/quickcheck-instances-0.3.23 (phadej)
00:46:26 <MATx> dmj` if you have any questions about gist code, feel free to ask
00:57:15 * hackage these 1.1 - An either-or-both data type.  https://hackage.haskell.org/package/these-1.1 (phadej)
01:14:29 <Orbstheorem> when using DataKinds, how can I constrain a type to be a constructor of another type? (e.g. `class IsConstructor tree Tree => Foo tree where...`).
01:15:05 <Orbstheorem> (IsConstructor doesn't exist)
01:16:40 <Orbstheorem> If I use an equality over the main type (ie. `class Tree ~~ tree => ...`), then my instances need to provide methods for all Tree constructors, which is not what I want.
01:20:28 <phadej> the kinds already restrict that? class Foo (tree :: Tree) where .., or am I missing some detail here
01:23:15 * hackage monad-chronicle 1.0.0.1 - These as a transformer, ChronicleT  https://hackage.haskell.org/package/monad-chronicle-1.0.0.1 (phadej)
01:23:21 <Orbstheorem> when I do `class Foo (tree :: Tree)`, I can't use `tree` inside my declaration, I get the error "Expected a type, but tree has kind Tree”
01:23:50 <Orbstheorem> concrete example: https://paste.gnugen.ch/raw/KXAX (s/tree/CurrencyOperations).
01:34:03 <kolu> how can I make this work? [print x | x <- list]
01:34:13 <xerox_> :t sequence
01:34:15 <lambdabot> (Traversable t, Monad m) => t (m a) -> m (t a)
01:35:21 <xerox_> :t sequence_
01:35:22 <lambdabot> (Foldable t, Monad m) => t (m a) -> m ()
01:35:57 <Orbstheorem> :sequence putStrLn <$> [1..2]
01:36:38 <Orbstheorem> : sequence $ putStrLn . show <$> [1..2]
01:37:15 <kolu> sequence_ worked
01:37:16 <kolu> thank you
01:38:44 <mceier> > mapM_ print [1..2]
01:38:46 <lambdabot>  <IO ()>
01:39:56 <koz_> traverse_ is also good for that.
01:40:21 <Orbstheorem> phadej: Do you see what could be wrong in my example?
01:46:02 <xerox_> :t traverse_
01:46:03 <lambdabot> (Foldable t, Applicative f) => (a -> f b) -> t a -> f ()
02:03:39 <Orbstheorem> I solved my constraint problem by using Proxy tree as type.
02:49:49 <liiae> re l = rev l [], now I get ` fix rev' = rev `, how I can get re' ?
02:49:56 <liiae> fix re' = re
02:55:08 <xerox_> not sure what you mean liiae 
02:55:14 <Axman6> I have no idea what you're asking
02:56:36 <liiae> xerox_: Axman6  https://paste.ubuntu.com/p/3gKkhBbzKR/
02:56:57 <liiae> rev is the fixed point of rev'
02:57:23 <dminuoso> liiae: Your question is unclear.
02:58:24 <liiae> dminuoso: rev is the fixed point of rev', and ` re l = rev l [] `, how to get the relation between re' and rev',  re is the fixed point of re' 
02:58:58 <dminuoso> Try starting anew perhaps.
02:59:08 <dminuoso> Do you have a compilation error?
03:01:59 <liiae> dminuoso: https://paste.ubuntu.com/p/MnRHPpJ6t5/
03:02:24 <liiae> I just want to know how to get the unfix function of reverse...
03:02:48 <liiae> reverse use `where` in its definition, and I don't know how to get reverse'
03:03:20 <liiae> @src foldl
03:03:20 <lambdabot> foldl f z []     = z
03:03:20 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
03:03:29 <liiae> foldl' f z [] = z
03:03:39 <liiae> foldl' f z (x:xs) = foldl f (f z x) xs
03:03:54 <liiae> foldl is the fixed point of foldl'
03:03:56 <liiae> right?
03:04:06 <liiae> @src reverse
03:04:06 <lambdabot> reverse = foldl (flip (:)) []
03:04:09 <nil> no
03:04:24 <dminuoso> liiae: I dont think fixed point means what you think it means.
03:04:52 <nil> `fix f` is a fixed point of f
03:05:08 <liiae> dminuoso: foldl' foldl = foldl, wrong?
03:05:15 <dminuoso> Correct, it's wrong.
03:05:32 <dminuoso> % :t foldl' foldl
03:05:32 <yahb> dminuoso: ; <interactive>:1:8: error:; * Occurs check: cannot construct the infinite type: a ~ a -> a; Expected type: ((a -> a) -> a -> a) -> (a -> a) -> (a -> a) -> a -> a; Actual type: ((a -> a) -> a -> a -> a) -> (a -> a) -> (a -> a) -> a -> a; * In the first argument of foldl', namely `foldl'; In the expression: foldl' foldl
03:05:37 <dminuoso> It doesn't even type check!
03:05:54 <kuribas> > fix (\rev l -> case l of [] -> []; (x:xs) -> rev xs ++ x) [1, 2, 3, 4]
03:05:56 <lambdabot>  error:
03:05:56 <lambdabot>      • No instance for (Num [()]) arising from a use of ‘e_11234’
03:05:56 <lambdabot>      • In the expression: e_11234
03:05:57 <dminuoso> In other words "foldl' foldl" is nonsense
03:06:03 <nil> i don't think you're talking about the same foldl'
03:07:02 <kuribas> > fix (\rev l -> case l of [] -> []; (x:xs) -> rev xs ++ [x]) [a, b, c, d]
03:07:03 <lambdabot>  [d,c,b,a]
03:07:12 <nil> % foldl'' f z [] = z; foldl'' f z (x:xs) = foldl f (f z x) xs
03:07:12 <yahb> nil: 
03:07:16 <nil> % :t foldl'' foldl
03:07:16 <yahb> nil: ; <interactive>:1:9: error:; * Occurs check: cannot construct the infinite type: a ~ a -> a; Expected type: ((a -> a) -> a -> a) -> (a -> a) -> (a -> a) -> a -> a; Actual type: ((a -> a) -> a -> a -> a) -> (a -> a) -> (a -> a) -> a -> a; * In the first argument of foldl'', namely `foldl'; In the expression: foldl'' foldl
03:07:34 <dminuoso> % :t foldl'
03:07:34 <yahb> dminuoso: Foldable t => (b -> a -> b) -> b -> t a -> b
03:07:38 <dminuoso> % :t foldl
03:07:38 <yahb> dminuoso: Foldable t => (b -> a -> b) -> b -> t a -> b
03:08:01 <liiae> dminuoso: https://paste.ubuntu.com/p/rR9PdDrMks/
03:08:10 <liiae> it's fine on my ghc
03:08:40 <nil> that's not what you pasted earlier.
03:09:19 <liiae> nil: sorry, you mean which one?
03:09:53 <nil> 12:03:07 <liiae> foldl' f z [] = z   12:03:18 <liiae> foldl' f z (x:xs) = foldl f (f z x) xs 
03:10:15 <nil> maybe you forgot the foldl argument?
03:10:40 <liiae> nil: it's same
03:11:15 <nil> look harder
03:11:30 <nil> gg _foldl f z [] = z   vs.   foldl' f z [] = z
03:12:18 <liiae> > let foldl' _foldl f z [] = z; foldl' _foldl f z (x:xs) = _foldl f (f z x) xs in foldl' fold (+) 0 [1..10]
03:12:20 <lambdabot>  error:
03:12:20 <lambdabot>      • Occurs check: cannot construct the infinite type: t ~ [t] -> t
03:12:20 <lambdabot>        Expected type: (t -> t -> t) -> t -> [t] -> t
03:13:01 <liiae> nil: sorry, my fault
03:13:59 <nil> > let foldl' _foldl f z [] = z; foldl' _foldl f z (x:xs) = _foldl f (f z x) xs in fix foldl' (+) 0 [1..10] 
03:14:00 <lambdabot>  55
03:14:14 <nil> this is a fixed point definition of foldl
03:15:08 <liiae> nil https://paste.ubuntu.com/p/8YVB9qtJHm/
03:15:21 <liiae> nil this one is ok?
03:15:38 <nil> sure, but you're relying on an already-defined foldl, which is weird
03:16:31 <liiae> nil now I don't know how to get reverse' defintion https://paste.ubuntu.com/p/MnRHPpJ6t5/
03:16:40 <liiae> nil reverse is the fixed point of reverse'
03:17:00 <liiae> it would be nice if we have `unfix` function...
03:17:07 <liiae> if there would be
03:17:22 <Poscat[m]> Hi all. I'm trying to build a library that requires c2hs and it fails with this error:
03:17:22 <Poscat[m]> Warning: Failed to build documentation for exe:c2hs from c2hs-0.28.6 (which is
03:17:22 <Poscat[m]> required by test:tdlib-test from tdlib-0.1.0).
03:17:31 <nil> what on earth would be the semantics of `unfix`?
03:17:41 <liiae> knowing a function f's defintion, and know f is which function's fixed point
03:17:58 <dminuoso> liiae: 1
03:18:00 <Poscat[m]> and every time I runs `cabal build` cabal tries to recompile c2hs all over again
03:18:01 <dminuoso> What functions fixed point is that?
03:18:11 <nil> liiae: i don't know why you have two definitions reverse' and reverse_, or why you're trying to call `reverse' reverse_`, or have any idea what you're trying to do at all
03:18:23 <dminuoso> Hint, there are infinite ones.
03:18:31 <liiae> nil fix g = f, knowing f, and get g
03:18:47 <liiae> unfix f = g
03:18:52 <nil> unfix x = id
03:18:58 <nil> works for all x
03:19:04 <dminuoso> Heh.
03:19:22 <Poscat[m]> Is this a bug of c2hs or cabal and how do I solve this?
03:19:35 <nil> liiae: i think your whole approach is confusing. let me write something up
03:19:44 <liiae> nil reverse_ is the reverse function,  reverse' reverse_ = reverse_
03:20:34 <liiae> reverse_ has the same defintion with GHC.List.reverse
03:21:44 <liiae> f2 n accum = if n == 1 then accum else f2 (n-1) (n * accum)
03:21:57 <liiae> f2' f2 n accum = if n==1 then accum else f2 (n-1) (n* accum)
03:22:05 <liiae> f2 is the fixed point of f2'
03:22:12 <liiae> which f2' f2 = f2
03:22:25 <liiae> so we can rewrite f2 like
03:22:27 <liiae> f2NoRecur n accum = if n ==1 then accum else f2' f2NoRecur (n-1) (n* accum)
03:22:35 <liiae> right
03:22:37 <liiae> ?
03:23:11 <liiae> fix f2' = f2
03:23:44 <nil> f2NoRecur is recursive so i don't know what you mean
03:24:02 <liiae> > let f2 n accum = if n == 1 then accum else f2 (n-1) (n * accum) in f2 10 1
03:24:04 <lambdabot>  3628800
03:25:08 <liiae> > let f2' f2 n accum = if n==1 then accum else f2 (n-1) (n* accum); f2NoRecur n accum = if n ==1 then accum else f2' f2NoRecur (n-1) (n* accum) in f2NoRecur 10 1
03:25:10 <lambdabot>  3628800
03:25:49 <liiae> nil f2NoRecur is reversive?
03:26:09 <nil> what does reversive mean?
03:26:21 <liiae> f2NoRecur n accum = if n ==1 then accum else f2' f2NoRecur (n-1) (n* accum)
03:26:30 <timCF> Hi guys! Is there at any reason why I should prefer to use `Data.Text.Text` instead of `Data.Text.Lazy.Text`? 
03:26:52 <timCF> Or in which situations it might be preferrable?
03:26:58 <liiae> nil call f in f's definition?
03:27:27 <liiae> f2' f2NoRecur .. in f2NoRecur definition is recursive?
03:29:20 <nil> "f is recursive" means that f appears as a free (non-bound) variable inside f's body
03:29:42 <nil> f2NoRecur appears inside f2NoRecur, so it's recursive
03:30:08 <liiae> nil dminuoso the original question https://www.codewars.com/kata/5443dd2d7fc4478154000ac6
03:30:51 <nil> liiae: does this help? https://up.monade.li/sL34es
03:33:50 <liiae> nil yeah, but I'm tring do it without Control.Monad.Fix.fix
03:34:34 <nil> fix f = let x = f x in x
03:34:37 <solonarv> timCF: lazy text is more complicated (admittedly most of that is internal, but still), and a bit slower
03:35:14 <solonarv> the fact that the modules are named 'Data.Text' and 'Data.Text.Lazy', as opposed to 'Data.Text.Strict' and 'Data.Text', should give you a hint as to which one you should default to :)
03:37:27 <solonarv> lazy Text is basically a linked list of strict Text.
03:39:58 <timCF> thanks solonarv
03:40:24 <Axman6> it's quite rare that lazy text is the right option
03:40:44 <Axman6> the recent reddit post of reqriting split in Haskell is one exampe of when it;'s not awful
03:44:11 <Axman6> generally if you need to handle text that's large, something like conduit is usually a better option, processing the chunks explicitly
03:48:45 * hackage http-client 0.7.0 - An HTTP client engine  https://hackage.haskell.org/package/http-client-0.7.0 (MichaelSnoyman)
03:54:15 * hackage atom-conduit 0.8.0.0 - Streaming parser/renderer for the Atom 1.0 standard (RFC 4287).  https://hackage.haskell.org/package/atom-conduit-0.8.0.0 (koral)
04:09:45 * hackage shakebook 0.4.0.0 - Shake-based technical documentation generator; HTML & PDF  https://hackage.haskell.org/package/shakebook-0.4.0.0 (locallycompact)
04:11:07 <xerox_> solonarv: I was fooled by Data.Map(.Strict) module names being the opposite for a long time
04:21:06 <int-e> merijn: I guess you're right about ghc-8.10 not being so bad. There's a breaking haskeline change though which is a bit annoying.
04:35:15 <fog> hi, im trying to calculate a taylor expansion, using a rule that can be used with scan
04:35:22 <fog> :t scanl
04:35:23 <lambdabot> (b -> a -> b) -> b -> [a] -> [b]
04:37:59 <fog> I have the rule; grad f(.) @ x =f(x)-f(x-h)
04:38:26 <fog> um, h . grad f(.) *
04:39:34 <fog> maybe a traversal would be better
04:39:41 <fog> :t mapAccumL
04:39:42 <lambdabot> Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)
04:40:52 <fog> I was wondering if there was a way to make something like Mean, ie. a monoid, to put the subsequent values into
04:42:48 <fog> but i guess each time a new datapoint is added, the vector of calculated derivatives increases in length
04:45:07 <fog> h . grad_n f(.) @ x =grad_(n-1)f(x)-grad_(n-1)f(x-h), grad_0 = 1
04:56:18 <fog> https://pastebin.com/raw/nBtCnPf1
04:59:05 <fog> i want it so that replacing each value of the list of inputs with a gradient vector is an invertable function
04:59:20 <fog> ie, that the list of inputs can be recovered from the list of gradients
04:59:23 <dminuoso> Axman6: The same holds true for lazy bytestrings too. It's interesting to note that frequently proponents of "lazy data enable modular code" end up noting that "Streaming solutions like conduit scale better than lazy data"
05:00:19 <fog> dminuoso; i dont see how...
05:00:37 <maerwald> conduit is slow
05:01:01 <merijn> maerwald: That's a nonsensical statement without context
05:01:10 <fog> shouldnt they be basically equivalent?
05:01:16 <merijn> slow doing what, compared to what alternative?
05:01:22 <maerwald> merijn: streaming
05:01:31 <merijn> maerwald: streaming of what data?
05:01:37 <dminuoso> I think they meant the package called streaming.
05:01:37 <maerwald> streaming the library
05:01:49 <merijn> maerwald: Yeah, but doing *what*
05:02:35 <maerwald> there's a company in australia doing high performance audio/video streaming that did a talk in SG wrt different streaming libraries. The moral was that conduit is slow
05:02:36 <fog> i want this thing with the recusive definition of gradients to serve as a template for hierarchical HMM
05:02:37 <merijn> The overhead is completely insignificant when streaming data from an SSD
05:02:51 <dminuoso> I meant conduit as an example, hence the expression "streaming solutions like" - it's silly bikeshedding.
05:03:17 <maerwald> not all streaming libs scale
05:03:24 <fog> well, isnt the point that fusion is at the heart of compositionality of streaming opperations?
05:03:40 <merijn> maerwald: So a super niche usecase by a company doing something very specialised is enough to blanket condemn a library? How is that constructive?
05:04:03 <dminuoso> fog: My point is, when you are working on large chunks of binary blobs, chances are conduit/streaming/pipes are a much better fit than using Data.ByteString.Lazy
05:04:03 <merijn> For 95% of all people streaming data from somewhere are going to be IO bottlenecked and conduit will have essentially 0 overhead
05:04:06 <fog> you have some kind of zipWith style generator for unfolding, with fusion rules for combining streams, and conversely for splitting
05:04:34 <maerwald> merijn: I wasn't evaluating conduit as a whole
05:04:48 <fog> i cant see how you could compare performance since its down to rewrite rules
05:06:21 <fog> streaming is just about parallel interactions between suspended traversals 
05:06:40 <fog> ie zippers and zip
05:07:02 <merijn> maerwald: That might not be your intention, but people are just going to see "conduit is slow, streaming is fast" spend a bunch of time fighting streaming's far more complex API and eventually conclude "wow, doing anything useful in Haskell is hard!"
05:07:22 <maerwald> merijn: I found conduit to be the most complicated API
05:08:08 <lortabac> "streaming's far more complex API" -> are you sure?
05:08:10 <fog> the point is about abstracted recursion schemes, with patterns extending on hylomorphisms, zygomorphisms for example
05:08:49 <fog> then you have the API for giving the user compositional way to construct things leveraging the communication directions and data reuse of these
05:09:05 <merijn> lortabac: Well, *I* don't understand it without spending significant time figuring out wtf is going on and I like to consider myself pretty good at reading Haskell types
05:09:08 <fog> like, using upstream or downstream information
05:10:27 <fog> the idea of cursor in conduit, and the pipes for upstream and downstream message passing, are then basically these zippers based on higher recursion schemes
05:10:45 * hackage opml-conduit 0.8.0.0 - Streaming parser/renderer for the OPML 2.0 format.  https://hackage.haskell.org/package/opml-conduit-0.8.0.0 (koral)
05:11:09 <fog> it should simply be a different interface for expressing the same functionality for compositional design
05:11:59 <fog> i cant see how that should introduce any overhead at all
05:12:50 <fog> its just different encodings of the same phenomina, like cps zippers, doubly linked lists etc
05:13:33 <fog> the implementation should not do anything different when encoding the same phenomena 
05:14:02 <fog> ie, it should not take longer - not sure if it compiles down to the same core though
05:41:30 <carter> The funniest part is i much prefer machines
05:41:46 <carter> Because it gives me a different vocab
05:42:01 <carter> One for writing stages.  And another for compositing stages
05:51:45 * hackage cobot-io 0.1.3.5 - Biological data file formats and IO  https://hackage.haskell.org/package/cobot-io-0.1.3.5 (ozzzzz)
06:23:32 <dminuoso> Constant-time comparison of bytestring, is there a suitable package that has this done right already?
06:24:15 * hackage rss-conduit 0.6.0.0 - Streaming parser/renderer for the RSS standard.  https://hackage.haskell.org/package/rss-conduit-0.6.0.0 (koral)
06:29:15 * hackage tidal 1.5.2 - Pattern language for improvised music  https://hackage.haskell.org/package/tidal-1.5.2 (AlexMcLean)
06:30:23 <merijn> dminuoso: Define constant time?
06:32:06 <c_wraith> I think it's about equality checks without a timing side channel
06:32:39 <merijn> Hash it and compare the hash? ;)
06:32:58 <c_wraith> that's slower than the standard approach, though it does come up in literature
06:37:36 <dminuoso> merijn: That risks hashes, and you dont want to open yourself up to future preimage attacks unnecessarily
06:37:41 <c_wraith> dminuoso: the standard algorithm is just \x y -> foldl' (.|.) 0 (B.zipWith xor x y) == 0
06:38:26 <c_wraith> after checking that they're the same length
06:38:46 <dminuoso> c_wraith: And GHC will not play tricks on me there?
06:39:06 <c_wraith> It's usually not considered an important side channel to quick-reject inputs of different lengths
06:39:27 <c_wraith> Nah, neither GHC nor LLVM will mess with that loop
06:39:42 <merijn> I don't dare make that claim
06:39:58 <merijn> I can easily see LLVM vectorising that and adding shortcircuiting
06:40:16 <c_wraith> if it does, it breaks tons of "secure" code that's already out there
06:40:32 <c_wraith> oh, yeah.  one other level.  So far CPUs don't break that either
06:40:32 <merijn> c_wraith: That's almost certainly the case, yes
06:40:49 <c_wraith> CPUs are actually as big a threat as the compiler in this world
06:41:07 <c_wraith> so writing in assembly doesn't even help
06:42:43 <c_wraith> But until CPUs add a fixed-time comparison instruction so that you know they won't mess it up, that's the best anyone has got.
06:45:40 <dminuoso> c_wraith: Modern x86 CPUs have specialized instructions for timing resistant algorithms.
06:45:48 <dminuoso> And in fact, they are frequently used in certain crypto implementations
06:46:12 <c_wraith> dminuoso: fwiw, with hashing you can get around the preimage attack by generating a random secret per comparison, then using HMAC with the random secret and each value.
06:46:21 <c_wraith> but that's even slower...
07:24:04 <ggVGc> I've got a weird issue with hpack and flags, I think. If I just do this I get all modules in the source-dirs exposed by default(which I want): https://gist.github.com/6d832c7b499fa6a8dafb1b7671b6e24f but if I use a flag (https://gist.github.com/6d832c7b499fa6a8dafb1b7671b6e24f), I seem to have to expicitly list them in exposed-modules 
07:24:15 <ggVGc> does anyone know if this is expected behaviour, or a bug?
07:24:31 <ggVGc> or how I could get it to work the same way with a flag, as without one
07:25:16 <ggVGc> sorry, the first paste should have been this: https://gist.github.com/ggVGc/6d832c7b499fa6a8dafb1b7671b6e24f/e1237fba577071edb6d6730f3a5913d257f9f86e
07:40:45 * hackage splint 1.0.1.0 - HLint as a GHC source plugin.  https://hackage.haskell.org/package/splint-1.0.1.0 (fozworth)
07:44:16 * hackage squares 0.1 - The double category of Hask functors and profunctors  https://hackage.haskell.org/package/squares-0.1 (SjoerdVisscher)
07:48:33 <hyperfekt> Is there any way to be able to change the set of enabled language extensions depending on the GHC version? Or a better alternative than doing that?
07:50:45 * hackage ginger 0.10.0.4 - An implementation of the Jinja2 template language in Haskell  https://hackage.haskell.org/package/ginger-0.10.0.4 (TobiasDammers)
07:51:49 <solonarv> hyperfekt: yeah, you can do that
07:52:07 <solonarv> at least I think so
07:52:09 <solonarv> CPP should work
07:53:30 <hyperfekt> solonarv: I tried putting the CPP extension pragma above the one I'm trying to exclude with CPP but the CPP instructions seem to be ignored for the purpose of selecting the language extensions.
07:54:31 <hyperfekt> solonarv: wait no, i was just being a dummy about it ^^ got the version comparison the wrong way around -_- 
07:56:06 <hyperfekt> solonarv: thanks for the help c:
07:57:09 <solonarv> glad to be a rubber duck :D
07:57:27 <unsupervised> what should I read after *Haskell Programming From First Principles*?
07:57:52 <unsupervised> I feel I know how transformers and monads work, but not how to apply them to real world programs
07:58:44 <solonarv> make a program! 
07:59:03 <unsupervised> I think I need a book like Java's gang of four where they teach you design patterns
07:59:08 <merijn> unsupervised: Only way to learn is to do
08:00:18 <unsupervised> are there at least good OSS haskell programs I can read?
08:02:40 <phadej> for educational purposes? I doubt.
08:02:52 <phadej> Don't look at cabal-install, it's horrible under the surface
08:03:05 <phadej> Real software is rarely pretty
08:04:22 <[exa]> unsupervised: any specific category?
08:04:29 <ggVGc> what I've found is that I largely don't use 90% of the features of haskell when actually using it
08:04:45 <ggVGc> I've been using it for about 5 years now, and I barely even use GADTs
08:05:09 <ggVGc> I feel a lot of haskell is good for research exploration of ideas, but a lot of it is actually not useful for making software
08:05:25 <ggVGc> as in, not necessary, and adds more complexity than the benefits it provides
08:05:34 <unsupervised> no category, maybe something that doesn't require too much domain knowledge like graphics or low level networking
08:05:40 <ggVGc> so I'm basically just programming at 6 months-knowledge haskell level forever
08:05:56 <merijn> ggVGc: Honestly, that's probably smart
08:06:23 <merijn> ggVGc: I see lots of people going superhard on "type everything" attempts and it just makes everything more painful to work with and slow to compile
08:06:42 <merijn> ggVGc: Imperative, IO heavy haskell is massively underrated in terms of productivity
08:06:45 <unsupervised> I think I might just follow along *Write Yourself a Scheme*
08:06:57 <ggVGc> what I found is that when I went into type-playground mode I ended up with too rigid constructions that just made it super slow to work with
08:07:05 <merijn> ggVGc: Exactly
08:07:23 <merijn> ggVGc: Sometimes it can be very helpful/worthwhile, but most beginners are terrible at judging when/where :p
08:07:32 <LevelChart8> What is the most straightforward way to introduce a proximity feature in a mobile app built with Haskell?  I.e. I want to allow users to set their home location and search for people within a radius.
08:07:42 <LevelChart8> Not real-time location.
08:07:51 <ggVGc> yeah, I just gave up basically. I like the idea of learning all the advanced things in haskell, but it also doesn't matter if I can never actuallt use them
08:08:02 <LevelChart8> Google Maps API to set lat/long in SQL via Beam?
08:08:06 <phadej> LevelChart8:I guess in the same way as in an app build with something else than Haskell?
08:08:10 <ggVGc> for example, I studied type families a few years ago, and played around with somet hings, and since then I never used them
08:08:17 <ggVGc> and I stil don't know when I'd use type families
08:08:26 <merijn> ggVGc: I've used them a few times, they can be quite neat :)
08:08:28 <ggVGc> and hence I don't feel comfortable with them and largely ignore they exist
08:08:36 <LevelChart8> phadej: yes, but I didn’t know if there were location-focused libraries in haskell
08:08:56 <phadej> ggVGc: you'll know a year after you need type families that you should used them
08:09:10 <ggVGc> merijn: yeah that goes for a lot of things, in many languages, but I tend to gravitate towards "What's the smallest building blocks I need to understand in order to get work done", and then just use those
08:09:11 <merijn> phadej: Very true :)
08:09:12 <phadej> ggVGc: suddently in the middle of something else you'll get an heureka momeent
08:09:23 <ggVGc> I work in several languages daily, so I guess that infuences it
08:09:33 <Cale> phadej: I recommend struggling for at least 3 years to be really sure ;)
08:10:10 <phadej> Cale: I didn't mention struggling, You could even move to some other project. I think that even might help the realization to appear
08:10:45 * hackage aur 7.0.2 - Access metadata from the Arch Linux User Repository.  https://hackage.haskell.org/package/aur-7.0.2 (fosskers)
08:10:45 <ggVGc> I think haskell tricks you into too much generic code. Like asking yourself for every type "Can this thing be a functor, can it be a monoid etc." and implementing any classes that makes sense, and then in the end you actually onlyt ever care about using the types concretely
08:11:02 <ggVGc> at the end of the day, almost no code ends up being generic, in any language
08:11:05 <ggVGc> or any project
08:11:11 <Cale> I'm half-joking, but I meant, after having realised that they might be useful, wait another couple years while you keep trying more basic approaches to things.
08:11:51 <phadej> hmm. when i design a dat atype I most likely already think "it have to be a Functor because I'll use it in a place where I need Functor instance"
08:12:23 <phadej> I don't think I just type out all possible instances I could imagine
08:12:43 <Cale> There have been some cases where fancy type system features turned out to be part of a good solution to eliminating some hotspots for bugs, but I think it really was good to try many other things first, and be really certain about what the problems were.
08:12:50 <dolio> Lots of these features are actually used in, say, GHC.
08:13:47 <dolio> I'd agree that many people try to use them for impractical things, though.
08:14:24 <phadej> "don't build your apps like netflix if you aren't netflix"
08:14:27 <Cale> I feel like there are a lot of beginners these days who read all the blog posts about type families and singletons and stuff, and just jump right in to quasi-dependently-typed programming in Haskell before they even know what they want the type system to guarantee for them yet.
08:14:31 <phadej> same advise applies on all alevels
08:14:50 <merijn> Cale: Yeah, same
08:14:53 <Cale> and sometimes even before they know how to do basic practical things
08:14:55 <phadej> if you don't have the same problems, don't use same solutions :)
08:15:16 <merijn> Cale: And then they come here asking why everything is so hard
08:15:21 <Cale> hahaha, yes
08:15:50 <merijn> "So I'm using beam and these 30 custom data families I came up with and everything is really painful with these 5 overlapping instances I defined..."
08:15:56 <merijn> Yeah, no fucking shit
08:16:06 <Cale> lol
08:16:19 <dolio> Like, someone was in here yesterday and what they were describing sounded like they should have been using a proof assistant.
08:16:27 <merijn> I have to say that some people here and on reddit aren't helping
08:17:18 <merijn> *newbie asks innocent simple question on how to, like, query a website* "yeah, you should use beam, servant, and free monads!"
08:18:15 * hackage tdlib 0.1.0 - Bidings to the tdlib json interface  https://hackage.haskell.org/package/tdlib-0.1.0 (Poscat)
08:18:35 <dolio> But, that's assuming the main point is to prove everything correct, and doing that is not really a useful step if you want to have runnable code (at this point).
08:19:01 <Uniaika> at work we use postgresql-simple everywhere except for a couple of places
08:19:25 <Uniaika> you need more tests than type-safety with databases, in most of the cases
08:20:14 <Uniaika> type-safety isn't the ultimate silver bullet for everything, *thank god*
08:20:22 <Cale> I really want to like beam - in principle it would really be nice to have guaranteed syntactically-correct SQL, and I respect the level of care that went into breaking down the SQL standards and encoding everything.
08:20:36 <merijn> Cale: But, dear god, those types
08:20:40 <Cale> yes, exactly
08:21:00 <merijn> I open one page of the haddocks and just go "fuck this, got better stuff to do"
08:21:04 * awpr grabs popcorn and types `hk beam` into a Chrome Omnibox
08:22:15 * hackage influxdb 1.7.1.4 - Haskell client library for InfluxDB  https://hackage.haskell.org/package/influxdb-1.7.1.4 (MitsutoshiAoe)
08:23:43 <unsupervised> > *newbie asks innocent simple question on how to, like, query a website* "yeah, you should use beam, servant, and free monads!"
08:23:43 <unsupervised> I asked how to make a simple program with monads or monad transformers or book to read after HPFFP and got derailed into a discussion about advanced haskell features so ¯\_(ツ)_/¯
08:23:44 <lambdabot>  <hint>:1:1: error: parse error on input ‘*’
08:23:58 <wavemode_> ggVGc: this is the argument behind https://www.simplehaskell.org/
08:24:00 <merijn> unsupervised: Ah, but #haskell derailing any discussion is standard ;)
08:24:13 <merijn> unsupervised: It'd help to get some kinda clue what kinda program you wanna make, though :)
08:24:29 <merijn> unsupervised: Web app? Commandline program? Something else entirely
08:25:36 <wavemode_> haskell's complexity reminds me a lot of C++'s. Frankly, a 10 year old could learn C++ well enough to write a game in it. Because as complex as the language is, much of that complexity is meant for library writers and not application developers.
08:25:45 <wavemode_> I think haskell is the same way
08:25:59 <merijn> wavemode_: Honestly, Haskell is *much* simpler than C++ :p
08:26:08 <Cale> wavemode_: It's not quite that bad yet, but it's gradually getting there
08:26:56 <Cale> (I mean, specifically when it comes to the language that GHC implements, rather than what's in the Report)
08:27:07 <merijn> unsupervised: Like, there's a bunch of relatively standalone commandline programs in haskell. There's pandoc, of course, xmonad
08:27:10 <unsupervised> It doesn't matter what kind of program as long as I learn what transformers or monads to use in practical examples, when, why, how to compose monads, applicatives, etc to do something real world and messy
08:27:40 <Cale> I think we need a second Haskell implementation if only to indicate which extensions people should be more cautious about using.
08:27:45 * hackage influxdb 1.7.1.5 - Haskell client library for InfluxDB  https://hackage.haskell.org/package/influxdb-1.7.1.5 (MitsutoshiAoe)
08:28:07 <merijn> Cale: I blame the SC lawyers and lack of funding in Utrecht :p
08:28:43 <Cale> I've had the half-joking idea of just forking GHC and ripping out all the extensions I don't like, if only so that we can make PRs that say "Added support for BHC" rather than "Removed usage of OverloadedRecordFields"
08:28:58 <unsupervised> are there web app sources I can read? Not the libraries for web apps themselves
08:29:10 <Taneb> At uni I started making a Haskell compiler with some friends
08:29:33 <Taneb> But because there'd already been a compiler made at the University of York, we called it the "New York Haskell Compiler" to disambiguate
08:29:45 <Cale> haha!
08:30:05 <Taneb> (we didn't get very far, I think we had record desugaring and import resolution)
08:30:13 <Cale> unsupervised: hmm... we have a little example...
08:30:13 <merijn> I mean, afaik UHC supports Haskell2010 + several GHC extensions
08:30:32 <Cale> https://gitlab.com/obsidian.systems/lithograph -- I think this is a public repo
08:31:04 <Taneb> Looks fairly public to me
08:31:11 <Cale> good :D
08:31:22 <Cale> Sorry that it's not better documented, it's just a little worked example of a blog using Obelisk
08:34:49 <merijn> Documentation is for suckers ;)
08:35:08 <opqdonut> unsupervised: not sure if this is the type of thing you're after, but here's a simple haskell backend (+ a couple of lines of js for the frontend) https://github.com/opqdonut/nikls
08:35:48 <merijn> I'm at a ratio of 1 line of comment per 1k SLOC, with 1/8th of those being FIXMEs :p
08:35:50 <c_wraith> Cale: is there an example anywhere of using Obelisk in a way that has a backend data api that also pre-fills that data at initial render when possible?
08:36:23 <Cale> c_wraith: You mean prerendering the data on the backend so that it exists before the javascript loads?
08:36:48 <c_wraith> yes
08:36:58 <Cale> That's theoretically possible to do, but it's tricky -- we need to formalise the way that Obelisk frontends and backends communicate more before we can really do it in any truly sensible way.
08:37:40 <c_wraith> That's the piece that's missing in Obelisk, from my perspective.
08:37:55 <Taneb> I accidentally started doing literate programming on a side project when I realised I could turn my notes into the program itself
08:38:08 <Cale> The problem is that you don't want the javascript to load and knock all that stuff out, and at the same time, you're not guaranteed for any particular widget that it's ever going to be prerendered -- when someone uses a routeLink widget to change routes for instance, you'll switch widgets without necessarily reloading anything from the backend.
08:40:10 <c_wraith> That doesn't *seem* like an issue.  That's already handled just fine for html elements.
08:40:57 <Cale> I mean, you could sneakily encode some value while you were prerendering the page, and decode it on the frontend
08:41:03 <c_wraith> I'd just like to be able to say "here's an API, call it directly if you know you're pre-rendering, otherwise make it an http call to load data"
08:41:13 <Cale> But then what happens when you run the same widget and it was never prerendered?
08:41:26 <Cale> Yeah
08:42:26 <c_wraith> It might miss some cases - that's ok.  I'd just like to get as much into the easy pre-render cases as possible.
08:43:44 <Cale> Right, I think there's probably something fairly simple we could rig up to that effect. I think there's some worry that people will not understand the contract properly to make such a thing work well, but it's also probably not really that bad.
08:45:29 <Cale> We've been working on a more comprehensive solution with regard to the interaction between the Obelisk backend, frontend, and database, and it's pretty cool, but that's still a ways off.
08:47:15 <plakband> Is there a type class (or combination thereof) for types with a single inhabitant? Something more lightweight than singleton?
08:48:40 <dsal> What would it do?  () has instances of a lot of things, but what would it mean to only have one thing?
08:49:03 <c_wraith> plakband: to what end? we can probably give much better recommendations if we know why
08:51:11 <plakband> c_wraith: I have a library that stores data; if the user can prove that their type doesn't contain any information that makes storing it a lot easier
08:53:15 <plakband> Think optimizing IntMap t to IntSet
08:53:26 <Cale> plakband: Don't you just want instances of your own serialisation type class which say as much though?
08:53:55 <Cale> Having some other type class for singletons won't actually absolve you of the need for that, I think
08:53:56 <awpr> depending on the serialization, I'd expect that information-less types would be serialized as zero bits
08:54:28 <Cale> Though, I don't really know what's going on :)
08:55:27 <plakband> I have a similar situation where, depending on whether the user has Ord, Enum, or Ix instances, I can provide a Map, IntMap, or Array, respectively
08:55:41 <plakband> Each with better performance characteristics
08:56:02 <Cale> The user chooses between them with different combinators of some sort?
08:56:26 <plakband> Essentially, yeah
08:56:56 <awpr> so it's more about a safety net that you don't accidentally `() <$ myData`
08:57:00 <dminuoso> I suppose you could do that kind of trickery with TemplateHaskell, but at type checking that seems a bit late.
08:57:45 * hackage mmsyn7ukr 0.15.5.0 - A simple basic interface to some SoX functionality or to produce a voice that can be used by mmsyn7h  https://hackage.haskell.org/package/mmsyn7ukr-0.15.5.0 (OleksandrZhabenko)
08:58:06 <Cale> I think in a similar vein, you could make a combinator which just takes the one particular value that it expects/produces
08:58:58 <Cale> I suppose also you could use something like a Coercible constraint, but I'm not sure you'll actually have those when you need them
08:59:31 <awpr> `data ConstIntMap a = ConstIntMap a IntSet; _ :: Eq a => IntMap a -> ConstIntMap a`
09:00:27 <awpr> needs a `Maybe` to be total, actually
09:00:54 <Cale> Like, you can say something like Coercible a () -- but this won't apply to just any one-constructor datatype at present
09:01:00 <plakband> So the thing is, the user chooses a way to store their data as a type family instance, which means I don't get to do any value-level things like having them provide a value
09:01:06 <Cale> It'll only apply to newtypes of () whose constructors are exposed
09:01:21 <plakband> I _could_ do TH or Generics, but at that point I can also just define the type class myself
09:01:45 <plakband> But I'd like to avoid it if there is some free/de facto way of doing it
09:01:58 <Cale> Is there a good reason to encode that with a type family rather than something at the term level?
09:02:53 <awpr> I have a `class Finite a where type Cardinality a :: Nat; ...`, which you could in principle use to say `(Finite a, Cardinality a ~ 1) => IntMap a -> IntSet`
09:03:15 <awpr> it's a while out from being ready to open-source, though
09:03:32 <plakband> Cale: There's reasons for and against, but at this point the choice has been made and out of my control
09:04:22 <awpr> that could also let you do silly things like `(Finite a, Cardinality a ~ 0) => [a] <-> ()`
09:05:05 <plakband> awpr: that's pretty neat
09:05:20 <awpr> you can approximate it pretty well with a standalone type family and `Enum`, even
09:06:45 * hackage publicsuffix 0.20200526 - The publicsuffix list exposed as proper Haskell types  https://hackage.haskell.org/package/publicsuffix-0.20200526 (wereHamster)
09:07:12 <plakband> I was hoping that somebody would go "oh yeah there's this Kmett library that you've never heard and has a million downloads"
09:07:40 <plakband> But looks like I'll write the type class myself
09:08:47 <awpr> if you're willing to require Generic, there's also a neat trick hiding in one of the DerivingVia papers
09:09:21 <awpr> you can correlate `Rep` types of two `Generic` instances to convert between them
09:10:15 <awpr> so if something has the same `Rep` as `()` (namely some metadata wrapped around `U1`), you can pull one out of thin air with `to (M1 (M1 U1))`
09:11:07 <awpr> I guess that's probably better suited as a default method impl. of your `IsoToUnit` class though
09:11:15 <plakband> That's not a bad idea, thanks, I'll give it a shot and see how it works out
09:12:03 <awpr> incidentally, the dicts of `Default` happen to be isomorphic to what you'd write for `IsoToUnit`; it's just missing the law that all values are equal to `def`
09:12:55 <awpr> so you could theoretically make an empty subclass of Default.  not sure I'd recommend it, though
09:15:41 <plakband> I like the idea of using a constraint on the Rep, that should both force it to be lawful and not require the user to write any instances by hand
09:17:05 <awpr> yeah, I haven't thought through whether it could rule out any effectively-singleton-but-not-Generic types
09:17:21 <awpr> okay, yes it could: `newtype Unit = Unit (forall a. a -> a)`
09:17:28 <awpr> but that may be too silly to care about
09:21:34 <plakband> Maybe Void
09:21:56 <plakband> But yeah forcing it to be single constructor with no fields should do nicely
10:06:32 <jluttine[m]> Does a type constructor always accept any types as its argument or can it constrain the types somehow? Are there some examples of such constraints? At least `Maybe a` and `Either a b` accept any types as `a` and `b`.
10:08:40 <plakband> jluttine[m]: A GADT allows you to attack constraints to constructors, is that what you're looking for?
10:08:44 <merijn> jluttine[m]: Well, the most obvious counter example would be types that expect types with kinds other than *
10:08:55 <plakband> s/attack/attach
10:09:03 <merijn> plakband: That's true, but also more complex than needed for his question :)
10:09:29 <merijn> jluttine[m]: Consider the following type: "data Foo f = IntFoo (f Int) | CharFoo (f Char)"
10:09:49 <plakband> Oh wait, can the _type_ constructor constrain the types
10:09:51 <merijn> jluttine[m]: 'f' can't be a type like 'Int', or 'Bool', because the types don't match
10:09:56 <awpr> barring features that I'm not sure exist yet, it's not possible to make it a type error to apply a type constructor to a particular type [of the right kind]
10:10:21 <merijn> awpr: You can, actually, if you're willing to use -XKitchenSink
10:10:37 <awpr> it is possible to make that result in a stuck type family application or an uninhabited type
10:10:37 <merijn> awpr: https://gist.github.com/merijn/6130082
10:11:09 <merijn> I should update that gist to user the new custom type errors
10:11:20 <awpr> ah, I was ignoring custom type errors
10:11:38 <merijn> awpr: Even without those you can force a failing constraint to make an error :)
10:11:42 <wavemode> jluttine[m]: type parameters are almost always constrained by what kind they must be. there are also additional constraints you can apply using various language extensions
10:12:14 <awpr> merijn: that seems to be making it an error to instantiate a term of quantified type at a particular type
10:12:23 <merijn> I think we're getting ahead of ourselves, I wanna see if they get my higher kinded example first ;)
10:12:48 <awpr> I think applying a type constructor to any right-kinded argument is always accepted?
10:13:00 <awpr> things like constrained type families may change this
10:13:04 <merijn> Maybe? Honestly, who knows ;)
10:13:09 <jluttine[m]> merijn: wavemode ah, yes indeed, thanks!
10:14:05 <merijn> jluttine[m]: But in principle (barring any extensions) type constructors will accept any type of the right kind, yes
10:14:22 <awpr> jluttine[m]: sorry we got distracted with type-level silliness; we might have more reasonable advice if you give more context on what you want to achieve by constraining the argument of a type constructor
10:16:10 <jluttine[m]> awpr: i'm not trying to achieve much, just wanted to understand if i can make some general assumption or not
10:17:17 <awpr> I see; so, there are two things you might mean by "type constructor" here: either a "generative type function", i.e. anything created by a `data` or `newtype` or `class` declaration; or "any capitalized type-level name"
10:17:53 <awpr> the former can always be applied to anything of the right kind and will always result in a "reasonable" type
10:18:20 <merijn> hmm, I have a type that feels like a Monad, but I don't think the Applicative is particularly sensible
10:18:29 <awpr> the latter can be applied to anything of the right kind, but it might be a stuck type family application or something odd like that
10:18:40 <dsal> One thing I've wanted to do a few times is add constraints (e.g., Ord) to the value in my data type.  This is typically wrong.
10:19:21 <merijn> Maybe I should just define a custom bind/join
10:20:31 <wavemode> maybe it's an Arrow?
10:20:49 <solonarv> you could use generics to decide whether a type has only one inhabitant
10:20:53 <dsal> jluttine[m]: e.g., a Map doesn't have any constraints on its key type, but you can't actually compile code that creates a map with keys that aren't Ord.  You need that to modify them, but not to create them.
10:20:58 <awpr> the other axis of this is that you can make type constructors give uninhabited types, e.g. with `GADTs`, which in many practical cases is sort-of like "constraining the argument of a type constructor"
10:21:11 <merijn> dsal: Sure you can
10:21:21 <merijn> dsal: As long as you only ever use single element maps :)
10:21:39 <merijn> (or empty ones)
10:21:46 <awpr> merijn: is the `pure` / `return` the part that's unreasonable?
10:22:02 <merijn> awpr: no, "ap"
10:22:03 <dsal> heh.  Yeah.  This seemed dumb at first, but I made  type recently that's kind of similar to map and found it kind of useful to think about things this way.
10:22:15 <awpr> re Map: `fromAscList :: Eq k => [(k, a)] -> Map k a`
10:22:21 <dsal> Most of the time, I need my values to be monoidal, but it's a lot of work to ensure that in all cases, and I don't actually care in all cases.
10:22:22 <solonarv> woops I was scrolled up
10:22:39 <awpr> hmm, how can the `ap` be unreasonable if the `join` is reasonable?
10:22:45 <merijn> awpr: Basically I have a "Query r" type which is, well, a query returning a stream 'r's of r values
10:23:15 <merijn> awpr: join/bind is reasonable because that's just fan out for every result
10:23:17 <jluttine[m]> `MaybeT m a` has a constraint that `m` needs to be a monad, right? So that's one example of a constraint in a type constructor if I'm understanding correctly
10:23:26 <awpr> so bind == subqueries and ap == cartesian product
10:23:46 <dsal> :t MaybeT
10:23:47 <solonarv> jluttine[m]: your understanding is incorrect.
10:23:47 <merijn> awpr: the cartesian product will perform like shit and blow up, so I never want those
10:23:48 <lambdabot> error:
10:23:48 <lambdabot>     • Data constructor not in scope: MaybeT
10:23:48 <lambdabot>     • Perhaps you meant variable ‘maybe’ (imported from Data.Maybe)
10:23:51 <merijn> jluttine[m]: It does not
10:23:57 <dsal> jluttine[m]: It doesn't appear to:  `newtype MaybeT m a`
10:24:07 <merijn> jluttine[m]: The *instances* and operation on MaybeT have those constraints
10:24:08 <jluttine[m]> (Or at least `MaybeT m a` requires `m` to have kind `* -> *`, not `*`)
10:24:09 <awpr> jluttine[m]: yes and no -- it makes a pretty useless type for non-`Monad` parameters, but it's still a type
10:24:16 <solonarv> % newtype NotAMonad a = NotAMonad (a -> Bool)
10:24:16 <yahb> solonarv: 
10:24:44 <wavemode> :t runMaybe
10:24:45 <solonarv> % foo = MaybeT isNothing :: MaybeT NotAMonad a
10:24:45 <lambdabot> error: Variable not in scope: runMaybe
10:24:45 <yahb> solonarv: ; <interactive>:51:27: error:; Not in scope: type constructor or class `MaybeT'; Perhaps you meant `Maybe' (imported from Prelude)
10:24:58 <merijn> awpr: Hence I'm probably better of implementing a single one-of "joinQuery :: Query (Query r) -> Query r"
10:25:00 <dsal> jluttine[m]: This is what I was referring to with `Map` above.  The data type doesn't require the key to be ordered, but practical use does.
10:25:01 <solonarv> % import Control.Monad.Maybe.Trans
10:25:01 <yahb> solonarv: ; <no location info>: error:; Could not find module `Control.Monad.Maybe.Trans'; Perhaps you meant Control.Monad.Trans (from mtl-2.2.2)
10:25:12 <solonarv> % import Control.Monad.Trans.Maybe
10:25:12 <yahb> solonarv: 
10:25:14 <solonarv> % foo = MaybeT isNothing :: MaybeT NotAMonad a
10:25:14 <yahb> solonarv: ; <interactive>:54:14: error:; * Couldn't match expected type `NotAMonad (Maybe a1)' with actual type `Maybe a0 -> Bool'; * Probable cause: `isNothing' is applied to too few arguments; In the first argument of `MaybeT', namely `isNothing'; In the expression: MaybeT isNothing :: MaybeT NotAMonad a; In an equation for `foo': foo = MaybeT isNothing :: MaybeT NotAMonad a
10:25:27 * solonarv grumbles
10:25:29 <solonarv> % foo = MaybeT isNothing :: MaybeT NotAMonad Int
10:25:29 <yahb> solonarv: ; <interactive>:55:14: error:; * Couldn't match expected type `NotAMonad (Maybe Int)' with actual type `Maybe a0 -> Bool'; * Probable cause: `isNothing' is applied to too few arguments; In the first argument of `MaybeT', namely `isNothing'; In the expression: MaybeT isNothing :: MaybeT NotAMonad Int; In an equation for `foo': foo = MaybeT isNothing :: MaybeT NotAMonad Int
10:25:45 <monochrom> "NotAMonad" is a "great" name. :)
10:25:55 <solonarv> okay brb puzzling this out in ghci
10:25:55 <dsal> e.g., you can list all of the keys out of a map without those keys being orderable, but you can't add a key to a map without the key type being orderable
10:27:17 <solonarv> aha!
10:27:29 <solonarv> % foo = MaybeT (NotAMonad isNothing)
10:27:29 <yahb> solonarv: 
10:27:33 <solonarv> % :t foo
10:27:33 <yahb> solonarv: MaybeT NotAMonad a
10:27:57 <solonarv> behold! we used 'MaybeT m a' with a type 'm' that isn't (and can't be) a Monad!
10:29:03 <monochrom> I have an argument for why you never need constraints on your type definition.
10:29:40 <monochrom> You are supposed to make up your mind whether you allow users to use your type in ways you haven't conceived.
10:30:02 <monochrom> If yes, then you shouldn't impose the constraint.
10:30:30 <merijn> A better argument is that imposing the constraint is more work and "does nothing"
10:30:32 <monochrom> If no, then you should have made your type an abstract type in the first place.
10:30:51 <monochrom> Either way the constraint has no right of existence.
10:30:52 <merijn> 95% of people asking "can I constraint my datatype?" want this so they don't have to put constraints on every function using them
10:30:58 <merijn> But that doesn't work
10:31:10 <merijn> If you constraint the datatype you *still* need to constraint the function
10:31:24 <merijn> So it's literally more work and less flexibility and no gain.
10:31:34 <awpr> IIRC some of the types in `transformers` even have `Applicative` instances that don't require the argument to be `Monad`: even though they were meant to be monad transformers, the type still exists at non-monads and can be useful even without the Monad instance it was invented for
10:33:20 <monochrom> Programming attracts control freaks, and control freaks ruin programming.
10:33:28 <berndl> lol
10:34:57 <monochrom> If you use GADTs, you can omit the constraint on the functions.
10:35:17 <monochrom> I was totally horrified when first learning that.
10:35:39 <monochrom> But this is why I have to fall back to my "make up your mind" argument.
10:36:01 <awpr> indeed -- in some cases.  this doesn't work for things in negative position, though: `data Thing a = Ord a => Thing a; thingPure :: a -> Thing a` can't be written with that signature
10:36:10 <berndl> One thing I've found from programming in Agda is that constraints are a pain-in-the-ass.
10:36:27 <monochrom> OK, "can omit constraint on the functions" is probably true of some functions and false of the others.
10:36:33 <berndl> You have to plumb proofs of constraints and the code gets messy really fast.
10:36:52 <dsal> We must unconstrain ourselves.  Bring back TCL.
10:37:38 <awpr> i.e. what GADTs let you do is bundle up an instance inside dict the value of your type, so it's not _quite_ the same as implicitly having a constraint on all signatures that mention your type, but it often behaves similarly
10:37:52 <monochrom> yeah
10:39:49 <monochrom> Also this is what's wrong with harnassing curry-howard to write proofs in a program form, and write programs in a proof form.
10:41:27 <monochrom> "they are oh so isomorphic!"  doesn't mean you use it everyday.  In fact experience from all kinds of isomorphisms from math is exactly that you use them sparingly, only when they actually help.
10:41:45 * hackage stratosphere 0.53.0 - EDSL for AWS CloudFormation  https://hackage.haskell.org/package/stratosphere-0.53.0 (jdreaver)
10:41:59 <Uniaika> that's actually a pretty name, stratosphere.
10:42:41 <EvanR> proofs rely on epic omission of vast details that are painfully obvious, but are still there if you need them. Seems like programs could benefit from that. If technoogy even existed for it
10:43:12 <EvanR> sort of like how exceptions cleaned up procedural code
10:43:13 <awpr> EvanR now there's an idea: tactic-based programming
10:43:45 <awpr> instead of writing boilerplate code, you just say "use the `boilerplate` tactic"
10:43:46 <Cheery> monochrom: you rely on that property all the time.
10:45:00 <Cheery> and when you don't, you got stuff that doesn't fit that model, and corresponding issues.
10:45:35 <EvanR> awpr: on boilerplate, that is why i originally wondered what the diff between macros and functions were
10:45:47 <EvanR> how is a tactic not just a function
10:46:14 <EvanR> because "code" is not first class
10:46:27 <Cheery> the whole structured programming rooted on hoare logic
10:46:41 <Cheery> that's why "gotos are considered harmful"
10:47:19 <Cheery> and when your abstractions dont work, you go chisel it up
10:47:29 <monochrom> Then you should read Floyd's paper. In which Floyd did it on arbitrary flowcharts.
10:47:46 <monochrom> And it was totally before Hoare's.
10:48:16 <monochrom> And Hoare was like open with "this is not new, Floyd already did it, I'm just make it text-only no pics".
10:48:47 <monochrom> "and I was thinking more people will read it if I bring it to CACM"
10:48:53 <merijn> monochrom: That's how you get famous :p
10:49:12 <merijn> I like how everyone fawns about Dijkstra's algorithm, made him cringe :p
10:49:54 <merijn> "I'm just gonna whip up something on a napkin to talk to students about during their graph processing lecture..." *everyone promptly forgets about most other things he's done*
10:49:55 <monochrom> Well, everyone also still talks about dining philosophers and semaphores, so all is not lost.
10:50:39 <merijn> monochrom: I suspect 90% of programmers (if not more) could not relate those things to Dijkstra, though :p
10:52:10 <monochrom> OS courses that bring up dining philosophers and semaphores still acknowledge Dijkstra.  So I think it is because 90% of programmers don't take an OS course.
10:52:26 <monochrom> Hell 90% of programmers don't take any course at all.
10:52:44 <merijn> monochrom: I knew about semaphores, but I didn't know dining philosophers was his
10:52:51 <monochrom> Like, if you had taken a computer organization course, how would you not know more about floating point.
10:53:09 <merijn> And semaphores I only know because of the classical P/V naming :p
10:53:13 <monochrom> how would you have never seen any kind of assembly
10:53:32 <monochrom> how would you not know PATH
11:07:35 <Cheery> I'd actually like to understand curry-howard correspondence a bit better than I already do.
11:08:00 <Cheery> specifically the cut elimination -parts.
11:14:36 <Cale> Cheery: I think that corresponds to terms having normal forms.
11:15:22 <berndl> Wikipedia says: cut elimination algorithms correspond to the strong normalization property (every proof term reduces in a finite number of steps into a normal form)
11:18:36 <Cheery> it does, but it's not straightforward. Sum types make it complicated
11:19:44 <Cheery> simple sort of sum types that have (Left/Right) constructros and case statement as eliminator.
11:21:23 <phadej> if you thinking about category theory, it means that [f, g] . i_1 = f
11:21:23 <Cheery> It's a bit like the "if dog wore pants" -meme.
11:21:39 <phadej> and [f, g] . i_2 = g
11:21:46 <Cheery> yup.
11:22:05 <Cheery> and if you read that upside down, it's product types.
11:24:44 <Cheery> depending on how you reduce STLC with sum types, you may get case x of Left/Right -> (\y -> ...) or then (\y -> case x of Left/Right -> ...)
11:25:36 <phadej> this are considered equivalent
11:25:38 <phadej> these*
11:26:03 <phadej> the equivalance you have to use for STLC terms is (IIRC) is eta-beta
11:26:18 <phadej> importantly, not "syntactic" equality
11:26:59 <phadej> in [f, g] . i_1 = f the lhs and rhs are indistiguishable
11:28:15 <phadej> cut-elimination then is a property of STLC terms, saying that you can always remove "cuts", and get the "same" term
11:28:33 <unsupervised> The only feature I miss from discord here is ability to search all history. Is there some search index for freenode so I can lookup past haskell questions here?
11:29:15 * hackage pusher-http-haskell 1.5.1.13 - Haskell client library for the Pusher HTTP API  https://hackage.haskell.org/package/pusher-http-haskell-1.5.1.13 (willsewell)
11:30:39 <phadej> these cuts are however not usually visiable in syntax we use for writing lambda-calculus (it's a typing rule).
11:32:11 <Cheery> if you separate neutral/normal terms, they are though?
11:32:12 <dolio> They're not 'visible' because type theory is usually presented as natural deduction, which doesn't have cut.
11:32:26 <phadej> Cheery: no, you need to eta-expansion
11:32:28 <phadej> eta-expand
11:32:32 <Cale> unsupervised: Right now I don't think there's an especially easy way. There's a link in the channel topic to an archive of logs, but it isn't really easily searchable. There used to be a web application, but it's not running any longer I think.
11:32:55 <phadej> to make `f` and `\x -> f x` equal
11:33:19 <unsupervised> okay, maybe I can do that as a haskell project then, assuming there are no legal problems and that riot.im doesn't offer a good search
11:34:45 <dolio> Instead you need to talk about 'standard conversions' or something.
11:35:26 <phadej> sequent calculus / gentzen systems / ...
11:36:05 <Cheery> ok. so it involves moving from syntactic equivalence to some other sort of equivalence, then cut elimination can be described to bring the structure into a normal form.
11:36:36 <phadej> yes.
11:36:51 <phadej> eta-expansion is trivial when you know the types
11:37:04 <phadej> (then after)
11:37:10 <Cheery> yup. it's quite simple.
11:38:19 <Cheery> does this fit together with category theory & adjoint functors somehow?
11:39:21 <phadej> with my self-learned CT knowledge, when you are in CT land of the isomorphism you don't think about beta/eta stuff at all
11:39:31 <phadej> it simply doens't exist, hidden by the abstraction
11:40:14 <Cheery> the rules with adjoints seem to describe local completeness/soundness for products/sums/exponentials.
11:41:26 <phadej> the isomorphism is "Some class of categories ~ some kind of lambda calculus"
11:41:43 <Cheery> for product you'd get i_0 . f * g = f, etc.. then (i_0 * i_1) . pair = (id * id)
11:41:47 <phadej> simplest example is CCC ~ lambda calculus with products and functions (and nothing else)
11:42:16 <phadej> if you add sums on the right hand side, you have to add them on the left hand side too
11:43:19 <phadej> and the correspondence is "forall CCCs"
11:43:36 <phadej> so you cannot think about category of Sets and go into lambda calculus
11:43:58 <phadej> there is sum in Sets, but not in CCC
11:44:47 <Cheery> yup.
11:46:17 <Cheery> now I guess I'd like to figure out somehow, how cut elimination fits in with category theory and game semantics.
11:46:48 <Cheery> I'll see if I find something.
11:46:55 <fog> % let accumulator f = mapAccumL ((((\a->(a,a)).).f))
11:46:56 <yahb> fog: 
11:47:12 <fog> % let scanner f =  ((snd .) . (accumulator (flip (scanr f)))) []
11:47:12 <yahb> fog: 
11:47:24 <fog> % let taylor = scanner (flip (-))
11:47:24 <yahb> fog: 
11:47:43 <fog> % taylor [1,2,3,4]
11:47:43 <yahb> fog: [[1],[1,2],[0,1,3],[0,0,1,4]]
11:48:43 <fog> each value has enough gradient information to calculate the whole signal
11:49:11 <phadej> Cheery: when you have a closed term t : A, then you can construct an arrow 1 -> [| A |] in the category
11:49:26 <phadej> Cheery: that process may involve normalising the term etc.
11:50:08 <fog> its good because updating the list of gradients to one extra power is just a scan
11:54:19 <phadej> my text book says I should read Scott & Lambek (1986) book for more information
11:54:37 <fog> https://pastebin.com/raw/XqN4HEgj
11:54:56 <phadej> I doubt reading that will make me better haskell programmer though :)
11:57:37 <fog> the recursion has the previous tail value used to calculate the next term snocced onto the right, as the output list is calculated successively  
11:58:31 <fog> while consuming over the input list to give each input in tern as the basecase to the scan over the previous list to give the next 
11:58:59 <fog> % :t scanner
11:58:59 <yahb> fog: Traversable t => (a -> a -> a) -> t a -> t [a]
12:10:15 <turion> how do people keep code examples in Readme.md's working?
12:10:37 <phadej> not well :P
12:10:43 <turion> Is it possible to somehow quote a *.hs from a readme such that it displays on Github?
12:10:43 <wavemode> what do you mean?
12:10:58 <turion> Or run a readme.md with a code block as literate haskell?
12:11:15 <phadej> turion: that [literate haskell] works with e.g. using markdown-unlit
12:11:35 <fog> :t \ f -> (snd .) . mapAccumL ((((\a->(a,a)).).(flip f))) 
12:11:35 <phadej> turion: you have to trick GHC to unlit the file by having .lhs symlink though
12:11:36 <lambdabot> Traversable t => (a1 -> a2 -> a2) -> a2 -> t a1 -> t a2
12:11:38 <turion> End result: I want a Readme.md in my repo, and it should show, amongst other stuff, a code example that is type checked every time I do cabal build or so
12:11:59 <fog> :: Traversable t => (a -> b -> b) -> b -> t a -> t b
12:12:17 <wavemode> most people just do that manually
12:12:17 <fog> :t scanr
12:12:19 <lambdabot> (a -> b -> b) -> b -> [a] -> [b]
12:12:19 <turion> phadej, oh ok :) I guess I'll look into that
12:13:57 <fog> :t \ f -> ((snd .) . mapAccumL ((((\a->(a,a)).).(flip (scanr f))))) []
12:13:58 <lambdabot> Traversable t => (a -> a -> a) -> t a -> t [a]
12:15:42 <fog> with f = (-) this gives the taylor expansion at each position
12:16:17 <turion> wavemode: By manually you mean copy-pasting the code into an *.hs and checking that?
12:17:01 <fog> > (\ f -> ((snd .) . mapAccumL ((((\a->(a,a)).).(flip (scanr (-)))))) []) [1,2,3]
12:17:03 <lambdabot>  <[Integer] -> [[Integer]]>
12:17:24 <fog> > (((snd .) . mapAccumL ((((\a->(a,a)).).(flip (scanr (-)))))) []) [1,2,3]
12:17:25 <lambdabot>  [[1],[-1,2],[0,-1,3]]
12:18:18 <turion> phadej: Awesome, that worked. Thanks!
12:18:31 <fog> > (((snd .) . mapAccumL ((((\a->(a,a)).).(flip (scanr (flip (-))))))) []) [1,2,3]
12:18:34 <lambdabot>  [[1],[1,2],[0,1,3]]
12:18:40 <fog> (needs to be flip (-))
12:19:03 <fog> > (((snd .) . mapAccumL ((((\a->(a,a)).).(flip (scanr (flip (-))))))) []) [1,2,3,4]
12:19:04 <lambdabot>  [[1],[1,2],[0,1,3],[0,0,1,4]]
12:19:21 <fog> notice the 1 is in the first derivative location
12:19:36 <fog> > (((snd .) . mapAccumL ((((\a->(a,a)).).(flip (scanr (flip (-))))))) []) (map (*2) [1,2,3,4])
12:19:38 <lambdabot>  [[2],[2,4],[0,2,6],[0,0,2,8]]
12:19:59 <fog> > (((snd .) . mapAccumL ((((\a->(a,a)).).(flip (scanr (flip (-))))))) []) (map (^2) [1,2,3,4])
12:20:01 <lambdabot>  [[1],[3,4],[2,5,9],[0,2,7,16]]
12:20:11 <gentauro> could really use some feedback on this one -> https://gitlab.com/spisemisu/arraylog (mostly why it takes half an hour to build …)
12:24:01 <ja> gentauro: is it difficult to profile ghc?
12:25:39 <phadej> turion: cheers
12:26:33 <gentauro> ja: I tried :)
12:27:09 <gentauro> somebody in here told me that `build` times could increate by having `big records`
12:27:26 <gentauro> (mine has 256 attributes so that could be)
12:27:41 <gentauro> but it could also be that I `INLINE` a lot of stuff
12:29:39 <solonarv> both of those affect compile times adversely
12:29:48 <solonarv> I recall big data types being especially bad
12:29:56 <solonarv> I think in some cases you get quadratic or worse blowup
12:30:05 <koz_> INLINEing is no picnic either. I've had a wrapper around vector-algorithms exhaust GHC before.
12:30:34 <freeman42x[m]1> what is the .cabal file equivalent of enabling the jsaddle flag here: https://github.com/dmjio/miso/blob/master/sample-app-jsaddle/README.md#dev-with-stack ?
12:31:30 <fog> i have extensible datatypes, with sum types in nested datatypes, these can be enumerated over
12:32:01 <solonarv> package.yaml just ends up generating a .cabal file, so you could look at the generated cabal file
12:32:09 <fog> then, a particular type is a choice index list for each sum encountered in the descent through the tree of enumerated Sum layers
12:32:19 <solonarv> there is certainly a way to express this in a .cabal file, else hpack could not support it
12:32:39 <freeman42x[m]1> solonarv: I know that but I would rather have to avoid having to install stack just to check that out
12:32:49 <merijn> solonarv: It requires cabal.project
12:32:50 <solonarv> yeah, I'm looking through the docs
12:33:19 <merijn> solonarv: You can't encode it in the .cabal file, because flags aren't supposed/allowed to affect the interface of a package
12:33:43 <merijn> Of course, everyone ignores this, which is why we can't have nice things
12:33:54 <fog> i want to use this to encode a graph as a choice in the tree of all datatypes, with the Sum types being the choice between different values in the Product types
12:34:28 <gentauro> solonarv: koz_: I might just remove all `INLINE` pragmas to begin with
12:34:33 <gentauro> to see if that helps :)
12:35:13 <fog> where these different choices require some kind of type level Enum instance
12:35:14 <merijn> So, suppose I want to Show records, but like, have it faster than Show. What's the way to go
12:35:54 <wavemode> show is a -> String. a -> Text is probably faster?
12:36:02 <merijn> i.e. I want the fastest possible way to go from an input datatype to a String/Text representation with the shortest amount of text
12:36:15 <solonarv> perhaps even a builder
12:36:21 <koz_> I guess fastness is a higher priority than shortness, merijn ?
12:36:23 <merijn> wavemode: See, you say that, but I'd need a way to get Text directly, rather than String
12:36:41 <merijn> eh
12:36:56 <merijn> Why did I type shortest amount of text...I meant least amount of work/boilerplate
12:37:07 <solonarv> you could probably do something with Generic?
12:37:18 <merijn> solonarv: That sounds like the absolute *opposite* of fast
12:37:19 <wavemode> the best situation is if you can know in advance how much space you need and preallocate a buffer
12:37:25 <wavemode> easier said than done for most datatypes
12:37:50 <merijn> solonarv: I'd be surprised if Generic was faster than show
12:38:28 <merijn> wavemode: Well, the records of interest are essentially all Int/Double and vectors of those, so...
12:38:48 <merijn> Of course double's have varying lengths, but at least that gives an upperbound (ish?)
12:38:59 <solonarv> alrighty then, use template haskell to write fast show functions for you I guess
12:39:14 <merijn> solonarv: I'm not sure how to write a fast Show, hence my question :p
12:39:31 <solonarv> well, String is certainly the wrong datatype to output
12:39:39 <solonarv> text builder should be fine, I think?
12:41:40 <awpr> depending on what record types you use it on, a well-written Generic implementation should ideally be as fast as generated Show instances
12:42:07 <merijn> awpr: Right, but then I've introduced the work and boilerplate of Generic at no benefit...
12:42:09 <awpr> with the usual caveat of: as long as GHC manages to inline and annihilate the to/from
12:42:18 <solonarv> assuming it gets specialized and inlined, yes
12:43:13 <awpr> I'm just saying a Generic implementation of the same thing should usually be the same as a stock one
12:43:36 <awpr> maybe just doing that and using Text Builders instead of ShowSs would be faster than Show?
12:43:39 <merijn> Right, but then there's literally 0 benefit over just the stock one >.>
12:44:13 <awpr> "of the same thing" is the key qualifier there: if you make a Generic implementation of a better thing, it'll probably still be better
12:44:16 <merijn> awpr: Then it's probably easier to define the builder functions by hand directly, which I guess I'll try next
12:44:28 <awpr> for 1-4 records yes
12:44:32 <awpr> for 2000 records, no
12:44:35 <awpr> :)
12:44:44 <merijn> If you have 2000 records you have bigger problems
12:45:00 <koz_> merijn: Or you're beam. :P
12:45:08 <awpr> or you just have a lot of Haskell code
12:45:08 <koz_> s/beam/using beam/
12:45:53 <awpr> Haskell (esp. with Generic and DerivingVia) makes it really comfortable to write data types for local use, so we do
12:46:34 <fog> is there a DerivingVia for something like get and set for extensible datatypes?
12:46:35 <merijn> awpr: I fear for your compile times :)
12:46:48 <awpr> there are some rather slow modules, yeah
12:47:09 <merijn> I'm already incredibly sad from the compile times of my medium codebase >.>
12:47:18 <fog> where these are supposed to be like cons and uncons, possibly directed to some location
12:47:27 <awpr> my approach is just to avoid building the code whenever possible
12:47:43 <awpr> that sounds glib, but in fact type-check-only builds are awesome
12:47:55 <merijn> awpr: Those are hard to test, though :)
12:48:37 <fog> my datatype is here; https://gist.github.com/fog-hs/19abbf2ee8cf1f9f0c39abf0772da34e
12:48:43 <fog> what would generic be able to do?
12:50:16 <awpr> fog: probably nothing for HList or FList since GHC can't derive Generic for types with existentials or equality constraints
12:51:04 <awpr> (which is in turn because Generic doesn't come with rep constructors that could encode them; there was an ICFP talk about this 2ish years ago, but I don't think it's been implemented)
12:51:39 <fog> ah, I need that machinery to upmap the Free wrapper to just nest the containers directly inside each other for the type level "tree" of kind *
12:53:17 <fog> the argument to Free is a container with the Free constructor mapped over the types, and casting from this FList to HList strips off the Free constructors
12:54:03 <fog> its like, unfmap at type level using the type checker and matching! pretty awesome
12:54:26 <gentauro> solonarv: koz_: I might just remove all `INLINE` pragmas to begin with = 6 minutes build (from half an hour)
12:54:31 <gentauro> I guess I can live with that :)
13:11:45 <matix> Hi guys, can you help me with unpacking the object?
13:12:48 <biggiepow> noob needs help plz?! howmanyEqual :: Integer -> Integer -> Integer -> Integer
13:12:48 <biggiepow> howmanyEqual a b c 
13:12:48 <biggiepow>     | a = b && b = c         = 3
13:12:48 <biggiepow>     | a = b not b = c        = 2
13:12:48 <biggiepow>     | a = b                  = 1
13:12:48 <biggiepow>     | otherwise              = 0
13:12:50 <biggiepow>     
13:12:55 <gentauro> matix: you mean `unboxing`?
13:13:09 <gentauro> biggiepow: carefull or you will get banned for copy/pasta (happened to me)
13:13:12 <solonarv> gentauro: bear in mind that your program might now be slower at runtime
13:13:17 <biggiepow> ok
13:13:23 <gentauro> solonarv: I understand that
13:13:50 <gentauro> solonarv: that's the reason I "outcommented the INLINE pragmas" ;)
13:13:52 <solonarv> biggiepow: is this a homework question?
13:13:57 <biggiepow> yes
13:14:00 <dwt> biggiepow: what error message are you getting? I'd expect a note from the parser there, which should help guide you toward the answer
13:14:14 <biggiepow> parse error in input =
13:14:27 <biggiepow> not sure what that means
13:14:28 <solonarv> you will definitely get a parse error there, but I'm not sure how helpful it is
13:14:32 <dwt> pretty concrete - what do you think it means?
13:14:40 <dwt> hint: it's being literal about '='
13:14:51 <solonarv> (note: it also tells you *which* of the '='s is a parse error)
13:14:53 <biggiepow> the equals need to be different 
13:15:06 <biggiepow> somehow...
13:15:09 <dwt> yes, some of them!
13:15:10 <gentauro> biggiepow: it's Haskell, not F#
13:15:13 <gentauro> ;)
13:15:33 <solonarv> *which* equal signs need to be different? (hint: the error message includes a location)
13:15:39 <dwt> which are testing equality and which are defining results?
13:16:06 <biggiepow> b = c
13:16:22 <matix> I am failing on "where" cause, because I am trying to use value of object in foldl
13:16:23 <matix> https://www.notepadonline.org/dHXQHeafh7
13:16:24 * gentauro I wondering what students think when you can write this expression in F#: `let foo 42 = 42 = 0` :|
13:16:56 <matix> This part is important
13:16:57 <matix> Text.foldl(\acc x -> acc ++ show te
13:17:00 <Rembane> gentauro: That looks like some serious bet hedging. 
13:17:30 <matix> I was thinking about instead of using data from object in foldl to pass array of values using map but I failed to do that either ;(
13:17:59 <ja> gentauro: yeah i don't think it was a good choice to use = for comparison in f#
13:18:13 <gentauro> Rembane: and ja well it is what it is :P
13:18:21 <ja> gentauro: too much momentum from virtually every other language
13:18:27 <Rembane> gentauro: ^^
13:18:40 <pweids> biggiepow: try looking at the docs for Data.Eq to see how it defines equality operator
13:18:40 <gentauro> I would have gone for `let foo := 42 = 42`
13:18:45 <Rembane> +1
13:18:45 * hackage github 0.26 - Access to the GitHub API, v3.  https://hackage.haskell.org/package/github-0.26 (phadej)
13:18:59 <koz_> gentauro: I can't say I'm surprised.
13:19:08 <gentauro> s/`let foo 42 = 42 = 0`/`let foo = 42 = 0`/ (small mistake)
13:19:54 <ja> another thing that bugs me about f# is that casing is not enforced, so if you try to catch an exception with a name that doesn't exist, your exception block is a catch-all that binds to that name
13:19:55 <dwt> gentauro: the first one is valid too, it's just a very odd partial function
13:20:22 <ja> like , i think i did "try ... with | NonExistingException -> ..."
13:20:40 <ja> and it should have been ":? NonExistingException"
13:21:13 <gentauro> ja: always when in doubt, you the `Elvis Presly` operator xD
13:21:14 <ja> it is worse line noise than lens because it is built into the language :P
13:21:18 <gentauro> `:?`
13:21:27 * gentauro shaking his head
13:22:23 <gentauro> dwt: you are right, but I get a pattern match not-exhaustive warning :)
13:22:46 <matix>  (Just $ Token Pesel PeselData {TPesel.value = Text.pack $ show v ++ (Text.foldl(\acc x -> acc ++ show t) 0 arr)        where         (Token Numeral NumeralData{TNumeral.value = t}) })
13:22:54 <matix> how to make it work guys :(
13:23:31 <fog> what is Token Pesel?
13:23:36 <matix> I want to use data from passed Objects (Tnumeral.value = t) that 't' is what I need to use in Text.foldl
13:23:52 <matix> it is just an Object that contains value = t
13:24:00 <matix> TNumeral.value *
13:24:32 <ja> matix: why not break your expression into smaller parts and put type annotations on them?
13:24:48 <fog> whats with the where inside the {} !?
13:25:14 <fog> shouldnt you be binding something lowercase there?
13:25:15 * hackage shake-dhall 0.1.0.0 - Dhall dependencies  https://hackage.haskell.org/package/shake-dhall-0.1.0.0 (vmchale)
13:25:55 <ja> fog: you can have 'where' in every expression, no? but i do prefer not having a ton of where blocks, when one is sufficient
13:26:08 <matix> data NumeralData = NumeralData  { value        :: Double  }
13:26:21 <matix> and this NumeralData I import as TNumeral
13:26:26 <wavemode> matix: put your code in a gist
13:27:21 <gentauro> matix: does your IDE give your any suggestion?
13:27:24 <fog> i guess, more used to seeing let inline though
13:28:04 <fog> anyway, the where should not followed by something uppercase like Token
13:28:13 <gentauro> matix: you can fil with either `_` or `undefined` and then just position close to the function and it will tell you the signature that you need to provide code for
13:28:16 <gentauro> :)
13:28:40 <fog> i think maybe an @ would allow the pattern matching over the constructor?
13:29:03 <matix> I only get error: parse error on input ‘where’
13:29:25 <matix> about gist: https://www.notepadonline.org/dHXQHeafh7
13:29:47 <fog> > \xs -> x where (x:_) = xs
13:29:49 <lambdabot>  <hint>:1:10: error: parse error on input ‘where’
13:30:03 <fog> > \xs -> x where a@(x:_) = xs
13:30:06 <lambdabot>  <hint>:1:10: error: parse error on input ‘where’
13:30:09 <fog> hmm
13:30:30 <fog> > let f xs = x where a@(x:_) = xs
13:30:33 <lambdabot>  <no location info>: error:
13:30:33 <lambdabot>      not an expression: ‘let f xs = x where a@(x:_) = xs’
13:31:00 <fog> % f xs = x where a@(x:_) = xs
13:31:00 <yahb> fog: 
13:31:03 <fog> sorry...
13:31:10 <fog> % f xs = x where (x:_) = xs
13:31:11 <yahb> fog: 
13:31:15 <fog> huh, that works too
13:31:32 <fog> ok, maybe the constructors not the problem, my bad
13:33:49 <fog> still, i never seen something bound like that with the t inside {} 
13:37:43 <matix> fog 
13:37:44 <matix> data NumeralData = NumeralData  { value        :: Double  , grain        :: Maybe Int  , multipliable :: Bool  -- Hack until other use cases pop up,  -- at which point we'll craft a generic solution.  -- This allows to explicitly flag Numerals that don't work well with Time.  -- See `ruleTODLatent`. Prevents things like "at single", "dozens
13:37:45 <matix> o'clock".  , okForAnyTime :: Bool  }  deriving (Eq, Generic, Hashable, Ord, Show, NFData)instance Resolve NumeralData where  type ResolvedValue NumeralData = NumeralValue  resolve _ _ NumeralData {value} = Just (NumeralValue {vValue = value}, False)newtype NumeralValue = NumeralValue { vValue :: Double }  deriving (Eq, Show)
13:38:28 <fog> use pastebin!
13:38:53 <matix> https://pastebin.com/vF4iAF2S
13:39:44 <matix> it's from duckling 
13:39:47 <matix> facebook
13:39:51 <fog> I dont see class Resolve 
13:40:08 <matix> https://github.com/facebook/duckling/blob/master/Duckling/Numeral/Types.hs
13:40:33 <matix> I think I should link it earlier here
13:40:45 <matix> That it is from Facebook opensource library
13:40:48 <matix> but I am tired
13:40:51 <matix> sorry
13:41:43 <matix> Here is Token
13:41:43 <matix> https://github.com/facebook/duckling/blob/master/Duckling/Types.hs#L71
13:42:10 <matix> Here is file Resolve
13:42:10 <matix> https://github.com/facebook/duckling/blob/master/Duckling/Resolve.hs
13:42:14 <matix> I think you asked about it
13:42:52 <gentauro> matix: out of curiosity, do you normally code in Python?
13:42:56 <fog> i guess imports on your paste would have done aswell
13:43:40 <fog> so whats the error/question?
13:45:15 <matix> gentauro no, I was coding in OOP and I am trying to understand Haskell now
13:45:41 <fog> why dont you just pattern match it like (NumeralData value _ _ _)
13:46:34 <matix> because I get case that looks like this Token Numeral NumeralData{TNumeral.value = v}
13:46:40 <matix> and I match it
13:47:01 <fog> ok, so whats the problem?
13:47:40 <matix> because in case xs of
13:47:42 <fog> does (Token a b) need to be in parenthesis?
13:47:44 <matix> if I didn't match it like that
13:47:55 <matix> it will not be found
13:48:28 <fog> can you paste the error your getting?
13:48:42 <matix> \xs -> case XS of      (Token Numeral NumeralData{TNumeral.value = v}:       arr) ->
13:48:51 <matix> That is the case that I am catching
13:49:18 <matix> https://pastebin.com/05qSbTgD
13:49:23 <fog> no, there should not be capital letters after case
13:49:24 <matix> here is the error
13:49:48 <matix> but that part is working
13:50:13 <fog> to what code?
13:50:20 <fog> the code you linked has no misplaced where
13:52:05 <matix> because the code I pasted now, was just the case that I am showing to you, earlier I pasted this: https://pastebin.com/2nN0dLKs
13:52:31 <matix> now what I pasted here on irc was just to show you that this is the case I'm catching
13:52:35 <matix> so it has to have Token
13:53:14 <matix> here is the example in Facebook duckling how it is done https://github.com/facebook/duckling/blob/master/Duckling/Numeral/EN/Rules.hs#L155
13:53:23 <matix> I just want to after this case pass
13:53:59 <matix> use values from array of Token Numeral NumeralData{value}
13:54:07 <fog> so you dont expect t and v to be the same?
13:54:35 <matix> No
13:54:47 <matix> I get the array of Token Numeral NumeralData{value}
13:54:48 <matix> I split it
13:54:49 <matix> to 
13:54:52 <matix> Token Numeral NumeralData{TNumeral.value = v}:       arr
13:54:54 <matix> first element
13:54:58 <matix> and array of rest of elements
13:55:13 <fog> right, but what are you binding t to?
13:55:16 <matix> I want to use values from this "array"
13:55:28 <matix> I wanted to bind it to: where         (Token Numeral NumeralData{TNumeral.value = t}) })
13:55:45 <matix> Here I use this t in where
13:55:48 <matix> but I probably do it wrong
13:55:51 <matix> way
13:55:59 <matix> So I am asking how can I do it properly
13:56:08 <matix> Other idea I had was instead of doing it like that
13:56:12 <matix> Just use map function
13:56:17 <matix> on "arr"
13:56:21 <matix> so I can get values
13:56:26 <matix> But I don't know how to do it either
13:58:19 <matix> https://pastebin.com/G4TGyh8W
13:58:24 <matix> Here is cleaner example
13:58:49 <matix> at the end I am passing are which is [Token Numeral NumeralData{value}, ....]
13:58:57 <matix> and I was thinking about somehow using map
13:59:00 <matix> on this arr
13:59:19 <matix> to strip it and use only "value" that is inside Token Numeral NumeralData{value}
13:59:22 <fog> so what does t correspond to, or x in the newer paste
13:59:45 <matix> Text.foldl(\acc x -> acc ++ show x) 0 arr 
14:00:00 <matix> So x is the element of arr (arr is an array)
14:00:02 <fog> no, you need to bind it to something
14:00:21 <fog> the where statement does not make sense
14:00:23 <Orbstheorem> Hi! How do I control the memoization in a recursive pure function? Do I have to implement the memoization myself?
14:00:49 <matix> Yea I know it does not
14:00:50 <fog> you could unfold something
14:00:52 <solonarv> Orbstheorem: yes, or use a library to do it for you :)
14:00:54 <matix> But I don't know how to do it
14:01:09 <fog> well it depends what you want to bind it to!
14:01:16 <solonarv> % :i memoFix
14:01:17 <yahb> solonarv: ; <interactive>:1:1: error: Not in scope: `memoFix'
14:01:26 <matix> fog what do you mean?
14:01:26 <solonarv> hm, no luck
14:01:34 <matix> fog I want to use the values
14:01:41 <matix> to concat them
14:01:44 <fog> v binds ok, because you are pattern matching on the head of the input
14:01:53 <matix> Yea
14:02:03 <matix> But I can't match all data
14:02:06 <matix> from array
14:02:06 <fog> so where are you getting the t value from
14:02:10 <Orbstheorem> solonarv: Thank you.
14:02:13 <matix> as I don't know how many elements there will be
14:02:30 <fog> well, it has to have at least one since you are matching on the head
14:02:43 <fog> but you need to match on something else for that t value
14:02:50 <matix> Maybe I should ask it in different way, you see now how I am taking value out of first element
14:02:57 <matix> How can I take it from the rest of array?
14:03:03 <matix> If I don't know the size
14:03:09 <matix> but I know the format will be like the first element
14:03:25 <fog> well there are many places t could be bound, at each of the values of the tail
14:03:39 <fog> if its supposed to be different from v
14:03:59 <matix> The v and t is the number
14:04:05 <solonarv> Orbstheorem: a simple example: memoFixInt :: ((Int -> a) -> Int -> a) -> Int -> a; memoFixInt recur = let xs = map f [0..]; f = recur (xs !!) in f
14:04:08 <matix> it is the same type
14:04:23 <matix> I don't need to specify the first element
14:04:25 <fog> right, the list has all the same type for its values
14:04:35 <solonarv> this uses a list as the datastructure for memoization and obviously isn't right for every use case
14:04:40 <fog> you *do* need to *match* on the first ellement
14:04:50 <fog> thats how your getting the v
14:04:56 <matix> Oh yeah
14:04:58 <matix> you are right
14:05:01 <awpr> http://hackage.haskell.org/package/chimera is pretty cool for memoizing functions whose domains can be mapped nicely to naturals
14:05:03 <matix> That's how I match it
14:05:19 <fog> so, there should be some other matching going on to get the t
14:05:46 <matix> (Token Numeral NumeralData{TNumeral.value = v}: arr)
14:05:48 <matix> could also be
14:05:53 <fog> have you any idea how you want to process the tail to get the t?
14:05:55 <matix> (Token Numeral NumeralData{TNumeral.value = v}: _)
14:06:06 <matix> or anything after :
14:06:14 <fog> well, if your not using the tail, there is not much else the t could be
14:06:19 <matix> If I write (Token Numeral NumeralData{TNumeral.value = v}:Token Numeral NumeralData{TNumeral.value = v}: arr)
14:06:24 <matix> I will get first two elements
14:06:31 <fog> that would work yes
14:06:43 <matix> (Token Numeral NumeralData{TNumeral.value = v}:Token Numeral NumeralData{TNumeral.value = v2}: arr)
14:06:45 <matix> more like this
14:06:48 <matix> yea I know that
14:06:53 <matix> But I need to get all values
14:06:59 <matix> and I don't know how long list will be
14:07:14 <fog> well you cant bind them all like that, normally you would use recursion
14:07:39 <fog> recursing on the tail means you could bind the head element each time
14:07:52 <fog> successively consuming it
14:07:57 <matix> yea, but it is not a normal situations
14:07:59 <matix> situation
14:08:02 <matix> as it is case matching
14:08:03 <matix> because after that (Token Numeral NumeralData{TNumeral.value = v}: _) -> code to do something with it goes here
14:08:31 <fog> but that code to do something used a second thing, t
14:08:53 <matix> Yea, but I wrote it
14:08:59 <matix> and it was not correct
14:09:02 <Orbstheorem> solonarv: Time to do some benchmarking ;)
14:09:03 <fog> where were you wanting to get that from?
14:09:15 <matix> I wanted to get that from the rest of array
14:09:23 <matix> As foldl works like reduce in javascript
14:09:28 <matix> and will go after every element of list
14:09:36 <fog> then you should have your code to do something using arr, and not discarding it with _
14:09:48 <matix> Yea, I just wrote it now like that
14:10:01 <fog> ok great!
14:10:02 <matix> but in code I sent you, I'm using name "arr"
14:10:17 <fog> oh ok
14:10:19 <matix> The _ I used just here to show that I understand how it works
14:10:35 <matix> I just don't know
14:10:41 <matix> how to take the values from the rest of array
14:10:52 <fog> you need to use a function over arr to bind the new variable t
14:11:02 <matix> Yeah!
14:11:07 <matix> I used foldl for that
14:11:08 <fog> let t = f arr in
14:11:36 <fog> then you would need to write a function f to get the variable from the tail
14:11:53 <matix> but where should I use this let?
14:12:04 <matix> show v ++ (Text.foldl(\acc x -> acc ++ show t) 0 arr)
14:12:15 <fog> well, it brings t into scope, so after you bind arr, and before you use t
14:12:21 <matix> v <- first element
14:12:25 <matix> arr <- rest of elements
14:12:33 <matix> v <- value of first elements *
14:12:38 <matix> element *
14:12:55 <matix> lets focus on this part
14:12:56 <matix> (Text.foldl(\acc x -> acc ++ show t) 0 arr)
14:13:20 <matix> I want this t to be value of every element that I'm going over from arr
14:13:21 <fog> \(Token Numeral NumeralData{TNumeral.value = v}: arr) -> et t = f arr in show v ++ (Text.foldl(\acc x -> acc ++ show t) 0 arr)
14:13:47 <fog> ohh, i see  how your using t now
14:13:59 <fog> you expect it to be available to the fold
14:14:05 <matix> YESSS!!!
14:14:10 <fog> so you can bind it by matching on acc
14:14:14 <matix> Yes
14:14:15 <matix> yes
14:14:19 <matix> x is an element of arr
14:14:23 <matix> and I want t to be value of x
14:14:34 <fog> ie, writing acc using the Token Constructor and binding the value to t there
14:14:53 <fog> :t foldl
14:14:54 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
14:15:02 <fog> oh sorry, the x
14:15:10 <t8> im still a little confused about higher rank: are there two types of type level applications in haskell ?
14:15:31 <matix> (Text.foldl(\acc x -> acc ++ show xValue) 0 arr) ,
14:15:44 <matix> and x is Token Numeral NumeralData{value}
14:16:14 <matix> so I want xValue to be equal Token Numeral NumeralData {value = xValue}
14:16:14 <t8> ah term level type application !
14:16:18 <fog> (Text.foldl(\acc (Token Numeral (NumeralData t _ _ _)) -> acc ++ show t) 0 arr) ,
14:16:39 <fog> yes, or you can act on x with the record accessor value
14:17:03 <fog> (Text.foldl(\acc x -> acc ++ show (value x)) 0 arr) ,
14:17:03 <matix> What is this " _ _ _" after "t"?
14:17:37 <fog> the rest of the aruments to NumeralData, the things that arent value, that your not matching on
14:18:04 <fog> like ((:) a _)
14:18:22 <fog> cons is a constructor, just like NumeralValue
14:18:31 <fog> NumeralData*
14:29:11 <matix> fog thank you for your help, it does not work anyway but I understand it better :)
14:29:28 <wavemode> the #haskell classic
14:46:09 <Partmedia> Hi there, I want to create a data type where every field has a name (like a record), where every field also has an associated string. I've done some searching on the haskell wiki about record types, but can't seem to find what I would call what I'm trying to do to find out more. This is, of course, what I think I want. What I'm trying to do, is have a way to read a text file that has "name: value"
14:46:11 <Partmedia> pairs and store them in the data I created.
14:46:52 <Partmedia> (and the reverse)
14:47:15 * hackage ekg-statsd 0.2.4.1 - Push metrics to statsd  https://hackage.haskell.org/package/ekg-statsd-0.2.4.1 (ejconlon)
14:57:15 * hackage haskell-names 0.9.9 - Name resolution library for Haskell  https://hackage.haskell.org/package/haskell-names-0.9.9 (AlexandrRuchkin)
14:57:53 <matix> how can I take value from data in Haskell map function or similar?
14:58:17 <dsal> matix: what do you mean?
14:58:35 <dsal> Partmedia: I've seen an open records package come through here recently that does something that rhymes with what you're saying.
14:59:23 <Partmedia> dsal, thanks for the suggestion. I've found my way to Template Haskell, and am trying to figure out if that's what I want...
15:00:58 <matix> dsal I have x = Token Numeral NumeralData {value} and if I want to take just a value I can use (value x)
15:01:16 <matix> but in map function (Prelude.map (TNumeral.value) arr))
15:01:31 <matix> This does not change the array of Token Numeral NumeralData {value}
15:01:35 <matix> to array of value
15:01:44 <dsal> :t map
15:01:45 <lambdabot> (a -> b) -> [a] -> [b]
15:02:15 <matix> but in map function (Prelude.map (value) arr))*
15:02:24 <dsal> map just works on lists.  You don't have a list. 
15:02:34 <matix> arr is an list of Tokens
15:02:54 <matix> [Token Numeral umeralData {value}, Token Numeral umeralData {value}, ...]
15:02:55 <dsal> Oh, you just want a function `value :: Token -> a` ?
15:03:32 <matix> I don't understand
15:03:33 <dsal> You just have to make the function like the above.  It's fairly straightforward, but you haven't completely defined your type.
15:04:16 <matix> https://github.com/facebook/duckling/blob/master/Duckling/Numeral/Types.hs#L27
15:04:28 <matix> That's how my NumeralData looks like in full description
15:04:47 <matix> That's how my Token looks like
15:04:47 <matix> https://github.com/facebook/duckling/blob/master/Duckling/Types.hs#L71
15:04:59 <matix> And I have list of Tokens
15:05:09 <matix> and when I normally go over them
15:05:15 <matix> I can get value of each Token
15:05:52 <matix> with (TNumeral.value (Token Numeral NumralData {value,...})
15:05:58 <matix> but in map
15:06:00 <matix> it does not work
15:06:08 <matix> if I use it like this
15:06:09 <dsal> map is not important.
15:06:09 <matix> (Prelude.map (TNumeral.value) arr))
15:06:29 <dsal> The problem is that's not what you hahve.
15:06:36 <matix> ?
15:06:56 <matix> I get
15:06:57 <matix>     • Couldn't match type ‘Token’ with ‘NumeralData’      Expected type: [NumeralData]        Actual type: [Token]
15:07:06 <matix> so it sounds right what you say
15:07:09 <matix> but I don't get it
15:07:21 <dsal> Right.  You don't have a NumeralData, you have a Token.
15:07:59 <matix> I understood it like that: (Prelude.map (TNumeral.value) arr)) <- this is checking if arr element is of type TNumeral.value
15:08:06 <matix> instead of taking the value
15:08:10 <matix> out of Token
15:08:10 <dsal> You should ignore map right now.  It's confusing you.
15:08:43 <matix> Yea I have a token
15:08:49 <matix> but I want to get value out of this Token
15:08:54 <dsal> The Token has a Dimension type that sometimes has a NumeralData.  You need a function that, given a Token, gets you the NumeralData, on which you could call `value` to get the value.  Probably a `Maybe NumeralData` because there are other kinds of Tokens.
15:09:10 <dsal> There may be many different *types* of values in the Token.
15:09:30 <dsal> If you want a particular value of a particular type, you need something that can get that value iff it's in there and then combine them.
15:09:39 <dsal> (assuming you want map)
15:09:48 <dsal> (which you should ignore right now)
15:10:28 <matix> Hmm
15:10:35 <matix> so I first need to get NumeralData out of the Token
15:10:39 <dsal> You can see a bit how this works in, e.g. the Show instance:  The Token has a Dimension type that sometimes has a NumeralData.  You need a function that 
15:10:40 <matix> if it is there
15:10:41 <dsal> argh
15:10:46 <dsal> https://github.com/facebook/duckling/blob/master/Duckling/Types.hs#L119
15:11:13 <dsal> Show gets a String from a Token for all different types of Token.
15:13:28 <matix> soo
15:14:00 <dsal> You want to write a function that looks like that show.  You don't have to cover every type.
15:14:49 <unsupervised> who do I contact for permission to use the #haskell logs in the channel topic to make a search?
15:15:07 <dsal> `numeral (Token Numeral NumeralData x) = Just x;  numeral _ = Nothing`
15:15:11 <dsal> Something like that.
15:20:14 <matix> And how can I use it with map?
15:23:17 <dsal> :t map
15:23:18 <lambdabot> (a -> b) -> [a] -> [b]
15:23:46 <dsal> map wants a function that turns an `a` into a `b`.  You give it a list of `a`s and it gives you a list of `b`s.
15:24:17 <matix> Yeah
15:24:28 <dsal> `a` is `Token`, `b` is `Maybe WhahteverNumeralHolds`
15:24:34 <matix> Yes
15:24:40 <matix> I understand to this part
15:25:01 <matix> I have the function
15:25:02 <matix> instance Numeral (Dimension NumeralData) where  numeral (Token Numeral NumeralData x) = Just x  numeral _ = Nothing
15:25:06 <matix> instance Numeral (Dimension NumeralData) where  numeral (Token Numeral NumeralData x) = Just x  numeral _ = Nothing
15:25:55 <matix> https://pastebin.com/cdkc0UUF
15:26:02 <dsal> Things that start with `instance` are not functions.
15:26:17 <dsal> Git rid of that first line and you'll have a function.
15:27:06 <matix> how is this a function?
15:27:11 <matix> numeral (Token Numeral NumeralData x) = Just xnumeral _ = Nothing
15:27:17 <matix> numeral (Token Numeral NumeralData x) = Just xnumeral _ = Nothing
15:27:30 <matix> numeral (Token Numeral NumeralData x) = Just x
15:27:33 <matix> numeral _ = Nothing
15:27:40 <matix> It looks like two lines of pattern matching
15:27:45 * hackage project-m36 0.8 - Relational Algebra Engine  https://hackage.haskell.org/package/project-m36-0.8 (agentm)
15:28:32 <matix> like case of 
15:28:37 <matix> and than these two lines
15:29:16 <dsal> Don't put the same line in twice?
15:29:37 <matix> I meant 
15:29:42 <matix> numeral (Token Numeral NumeralData x) = Just x
15:29:46 <matix> numeral _ = Nothing
15:30:01 <matix> Oh wait
15:30:02 <matix> right
15:30:04 <matix> I forgot
15:30:06 <matix> it is legal
15:30:07 <matix> in haskell
15:30:08 <matix> sorry
15:30:09 <matix> my bad
15:32:20 <matix> but map numeral x
15:32:23 <matix> is still not working
15:34:07 <ja> matix, your messages are too short and useless, there is no sense in sending them to this chat room which has hundreds of people
15:35:14 <ja> matix: i just mean to say, i would appreciate if you thought, just 30 seconds about a question before spamming 20 lines which nobody can reply to anyway
15:37:19 <matix> Sorry ja I am new here, I will try to write it better
15:37:41 <matix> Thank you for your feedback
15:38:20 <ja> yeah, don't be discouraged. i just think it is important to remember to be constructive
15:41:24 <matix> dsal what I meant to say is numeral (Token Numeral NumeralData x) = Just x can't work as Token needs two arguments, so I used numeral (Token Numeral NumeralData{TNumeral.value = x}) = Just x
15:42:42 <matix> but I get error Couldn't match type ‘a’ with ‘Double’
15:42:48 <matix> with that function
15:43:15 <matix> full error https://pastebin.com/wgHUK5Rm
15:44:27 <EvanR> the enter key needs a plastic cover over it like the nuclear launch button
15:46:45 * hackage shake-futhark 0.1.0.0 - Dependency tracking for Futhark  https://hackage.haskell.org/package/shake-futhark-0.1.0.0 (vmchale)
15:48:23 <alx741> Reminds me of the -one word per line- habit some folks have on things like whatsapp, FB messenger and such
15:48:53 <awpr> a.k.a. the Ormolu approach to IRC?
15:49:20 <wavemode> aha
15:49:59 <matix> in my case it was more about shift + enter that in slack for example makes space between text and here it just sends it
16:05:43 <dsal> I don't spend much time in slack, but the big button on the bottom of my keyboard puts a space between text.
16:07:16 <awpr> many chat UIs have shift+enter type a newline into the chat entry box; I've been tripped up by that in here a few times too (currently on freenode Kiwi web chat)
16:08:38 <ja> i am on slack for a month now, and i hate it because it _actively encourages_ being super spammy. our slack is filled with build bots, each time a commit happens they will fill half a screen
16:18:31 <solonarv> ugh, can't you quarantine (haha) the build bots in their own channel so they don't shit up the conversation channels?
16:19:45 * hackage streamly-fsnotify 1.0.1.0 - Folder watching as a Streamly stream.  https://hackage.haskell.org/package/streamly-fsnotify-1.0.1.0 (GeorgeThomas)
16:20:14 <ja> yeah, but as i see it, slack is a lost cause anyway. there is "@here" (ping all people in channel) and people use it all the time!
16:23:12 <solonarv> can it not be disabled?
16:27:49 <Axman6> ja: We've always had a separate channel for notifications - means you can keep conversations going elsewhere with little distraction
16:37:37 <koz_> It's the Sixth Axe Bro!
16:50:56 <jackdk> I have a macro on my keyboard that sends `Shut up slackbot.<RET>` for exactly this reason. Of course, some joker always ends up adding that as a slackbot trigger phrase, and the cycle repeats...
17:10:46 <jacks2> hi. is there something like "peek" in Parsec, that will try a parser and tell me if it would succeed or not, without consuming input
17:11:14 <jacks2> [I have to use original Parsec, I'm maintaining some relatively old code]
17:12:02 <wavemode> that's what lookAhead does
17:12:27 <jacks2> nice!
17:13:54 <jacks2> I thought Parsec doesn't have it. there's peek in attoparsec, which is apparently just renamed lookAhead
17:19:12 <jacks2> this fails, why?  try $ lookAhead (char 'f')   unexpected "1" expecting "f"
17:20:19 <dmwit> Because there's no alternative?
17:20:47 <dmwit> Compare `try (lookAhead (char 'f')) <|> pure '\0'`.
17:20:53 <jacks2> ah ok
17:21:47 <dmwit> try (lookAhead p) never consumes input. But it still fails if p fails.
17:22:31 <jacks2> I know. I thought it was a lookAhead issue, but it was a try issue [which I have used in the past, but forgot how to use it]
17:45:45 * hackage calamity 0.1.10 - A library for writing discord bots  https://hackage.haskell.org/package/calamity-0.1.10 (nitros12)
17:47:39 <topos> ooo
17:47:46 <topos> i might use that 
17:48:16 <Boarders_> do any of you know a monadic parser framework which works on inputs that are lists of tokens?
17:48:24 <Boarders_> i.e. where I have already lexed
17:48:37 <Boarders_> I tried megaparsec but the Stream typeclass seems like a disaster for it
18:13:58 <fog> https://gist.github.com/fog-hs/a2053b6a5a5c583d548d6c5b6911460e
18:15:15 * hackage haskellish 0.2.3 - For parsing Haskell-ish languages  https://hackage.haskell.org/package/haskellish-0.2.3 (dktr0)
18:16:40 <monochrom> Boarders_: parsec can do it, and megaparsec should be similar.  See my http://www.vex.net/~trebla/haskell/parsec-generally.xhtml#token
18:25:15 * hackage miso-from-html 0.2.0.0 - Convert HTML to miso View syntax  https://hackage.haskell.org/package/miso-from-html-0.2.0.0 (DavidJohnson)
18:32:13 <liiae> nil: hi there, I saw your anwser about fixed point a few hours ago, https://up.monade.li/sL34es  I wonder can we get reverse'?
18:32:26 <liiae> reverse is fixed point of reverse'
18:34:32 <liiae> this helper function is really make me confused...
18:35:36 <liiae> f = fix (\f x y -> .. f..x..y)
18:35:53 <liiae> f is fixed point of (\f x y -> ...)
18:47:23 <monochrom> 1. rev is the only recursive function there, so you can rewrite only rev with fix.
18:47:33 <monochrom> 2. which function is "this helper function"?
18:47:50 <liiae> monochrom: rev
18:48:14 <liiae> monochrom: can we define reverse without where?
18:48:26 <monochrom> Rewriting with fix is a mechanical process. You don't even have to care what rev does.
18:48:42 <monochrom> What do you have in mind?
18:48:43 <liiae> monochrom: but the question ask for reverse' not rev'
18:48:51 <liiae> fix reverse' = reverse
18:48:56 <liiae> not fix rev' = rev
18:49:07 <monochrom> Cannot.
18:49:24 <liiae> monochrom: https://www.codewars.com/kata/5443dd2d7fc4478154000ac6
18:49:29 <monochrom> reverse is not recursive. Nothing you can do to it.
18:49:36 <jacks2> "*** Exception: Text.ParserCombinators.Parsec.Prim.many: combinator 'many' is applied to a parser that accepts an empty string."
18:49:46 <monochrom> rev is recursive. This is the one you can rewrite.
18:49:46 <jacks2> is there a way to force this, despite that message?
18:50:08 <monochrom> I'll let you take time to accept it.
18:51:09 <liiae> monochrom: so the first rule, if a function A would be another functionB's fixed point, that B must be a recursive function at first?
18:51:28 <liiae> so we can have A = fix B
18:52:14 <awpr> `reverse' = const Prelude.reverse`
18:52:19 <jacks2> nevermind, I fixed it it
18:52:22 <ezzieyguywuf> I'm very confused about how to add a dependency using stack
18:52:33 <koz_> ezzieyguywuf: You add it to the cabal file.
18:52:45 <ezzieyguywuf> koz_: I thought I needed it add it to stack.yaml
18:52:53 <koz_> ezzieyguywuf: No.
18:53:00 <liiae> awpr: what???
18:53:00 <koz_> stack.yaml doesn't specify build deps.
18:53:14 <ezzieyguywuf> wat does stack.yaml specify?
18:53:19 <MarcelineVQ> https://docs.haskellstack.org/en/stable/stack_yaml_vs_cabal_package_file/
18:53:20 <monochrom> I think you misworded it.  "fix B" is recursive.  B itself probably not.
18:53:26 <liiae> awpr: that would mean reverse is the only fixed point of reverse?
18:53:30 <koz_> What MarcelineVQ posted.
18:53:31 <Cale> liiae: If the fixed point of a function f is another function g, then f must both take and produce another function.
18:53:32 <ezzieyguywuf> I thought that if I didn't touch the cabal file that stack would manage it for me
18:53:43 <koz_> ezzieyguywuf: Nope.
18:53:46 <koz_> That's not a thing.
18:53:48 <monochrom> And I don't even always define "A = fix B".  Sometimes I just go ahead use "fix B" without giving it a name.
18:53:50 <Cale> (but maybe that has nothing to do with the question)
18:53:53 <koz_> Are you perhaps thinking of package.yaml?
18:54:00 <ezzieyguywuf> MarcelineVQ: I think I need to read that link thank you
18:54:05 <monochrom> So you probably need to grow out of wanting to see "=" somewhere.
18:54:28 <ezzieyguywuf> I'm probably thinking of package.yaml!
18:54:56 <awpr> `fix (const x) === x` for any `x`, so you can always find a `g` such that `fix g === f`, namely `const g`
18:55:08 <awpr> it's not really in the spirit of the exercise, though
18:55:23 <koz_> If it's package.yaml, there's a place to put build dependencies: https://github.com/sol/hpack#top-level-fields
18:55:42 <awpr> I mean `const f`
18:55:42 <monochrom> awpr: I think after these two days it's pretty clear we're being hit by an XY problem.
18:56:10 <awpr> it's a somewhat weirdly written coding exercise, check out the codewars link
18:56:12 <monochrom> The real exercise has always been "here is a function written recursively already. your job is to replace recursion by fix"
18:56:14 <liiae> awpr https://www.codewars.com/kata/5443dd2d7fc4478154000ac6  so this question has no anwser?
18:56:45 <awpr> `const reverse` is technically an answer; there are many possible answers
18:56:57 <monochrom> But it's butchered into the Y problem "how to 'unfix'". (What the hell does that even mean?)  And it is nothing to do with the real exercise.
18:57:49 <monochrom> OTOH my evil twin says it's AOK, XY problem should deserve derailing answers like "yeah x = fix (const x) generally, done"
18:58:09 <monochrom> "just is served"
18:58:15 <monochrom> err, "justice is served"
18:58:45 * hackage bond 0.12.1.0 - Bond schema compiler and code generator  https://hackage.haskell.org/package/bond-0.12.1.0 (chwarr)
19:00:10 <ezzieyguywuf> should I prefer to manage my cabal file directly or use package.yaml?
19:00:11 <liiae> if f is a recursive function, if there must be a function g, which f = fix g?
19:00:26 <monochrom> Yes.
19:00:50 <liiae> and g may be not recursive, and fix g must be recursive?
19:00:56 <monochrom> Have you read my http://www.vex.net/~trebla/haskell/fix.xhtml ?
19:01:49 <liiae> monochrom: yeah, but it doesn't tell me how to get g
19:02:19 <monochrom> It does.
19:02:37 <monochrom> It's just too long so you just scroll, not study slowly.
19:02:59 <monochrom> Happens to my students all the time.
19:03:17 <liiae> ok
19:03:30 <monochrom> Once in a while my lecture notes/slides have one sentence that directly exactly answer their question.
19:03:53 <monochrom> So during office hours they ask that question and I say "it's on my slide file xyz.pdf"
19:04:31 <monochrom> Then what I see is the equivalent of rolling stop (see, there is a reason it's illegal).  They scroll past that very sentence.
19:04:40 <monochrom> In fact, it's worse than that.
19:05:20 <monochrom> They spend 10 seconds on every slide except that slide. That slide they just skip within 0.5 seconds.
19:05:43 <monochrom> It's like their brain has a backend that knows the correct slide, and a frontend that's a not-gate.
19:06:49 <liiae> like the Bible?
19:06:58 <monochrom> This is what's wrong with humanity.
19:07:10 <monochrom> They really want to prove that their problem is unanswerable.
19:08:00 <monochrom> When an answer is presented, their brain has a self-esteem-protection system to overlook the answer so as to preserve their belief of unanswerability.
19:08:44 <monochrom> How dare you to say the brain is like the Bible.
19:08:50 <fresheyeball> for some reason I can't get into repls all the sudden
19:09:13 <liiae> monochrom: I mean your docs like the Bible
19:09:17 <fresheyeball>  The package,component pair is
19:09:19 <fresheyeball> not in the set of available targets for the project plan, which would suggest
19:09:21 <fresheyeball> an inconsistency between readTargetSelectors and resolveTargets.
19:09:29 <fresheyeball> never seen this before
19:10:03 <liiae> monochrom: like the other people said, the Bible has all the anwsers, you just need to read
19:10:24 <Cale> Including the answers that contradict the other answers ;)
19:10:30 * awpr wonders what the bible has to say about implementing recursion with a fixed point combinator
19:10:34 <koz_> Cale: Principle of explosion?
19:10:41 <koz_> You can prove anything from a contradiction, after all.
19:10:45 <awpr> it probably says it's a sin
19:11:02 <monochrom> I take it that since you are at leisure to discuss the bible, your fixed point problems have been resolved.
19:11:30 <liiae> ...
19:12:20 <liiae> awpr: maybe a father good at math can anwser that
19:13:12 <liiae> what's that X-files's slogan?
19:13:22 <liiae> "the answer is out therer"?
19:13:45 <liiae> and the alien give them ALL THE ANWSERS in the season 11
19:14:12 <monochrom> Well, I'm off to finish my AOE2 game.
19:14:31 <jackdk> awpr: closest I can find is https://kingjamesprogramming.tumblr.com/post/137161923781/i-do-not-believe-i-would-like-to-show-that-the
19:15:15 <monochrom> onoes
19:16:24 <jackdk> It occasionally comes up with real gems: "37:29 The righteous shall inherit the land, and leave it for an inheritance unto the children of Gad according to the number of steps that is linear in b."
19:22:16 <Getgle> Hey
19:22:32 <Getgle> I like lisp development is haskell like lisp?
19:22:48 <wavemode> nope
19:23:02 <Getgle> they are both functional though
19:23:40 <fresheyeball> I figured out it. For postarity, make sure all your cabal files are named right.
19:23:49 <wavemode> common lisp is not particularly functional. racket and clojure are kind of functional, I suppose. But they're still drastically different from haskell
19:31:54 <Getgle> i see
19:31:59 <Getgle> so is haskell more like scheme
19:35:59 <wavemode> sorry but programming in haskell is really not at all like programming in any lisp. haskell is pure and statically typed. it's more like elm or ocaml or F#
19:36:33 <jacks2> Getgle, give it a quick try. https://tryhaskell.org/
19:36:38 <Getgle> ok
19:38:45 <jacks2> [that's not a tutorial, just a bunch of small examples to, potentially, peak your interest]
19:43:25 <jackdk> Getgle: I think the "functional" label doesn't apply to lisp as well as it used to, as many key things that used to be confined to functional languages (map/filter/reduce, first class functions) percolated into many mainstream languages. I haven't done a lot of lisp development, but this outsider sees the key differences of lisp as homoiconicity and easy syntactic abstraction
19:43:56 <ezzieyguywuf> so I have stack installed as "stack-bin" (because that's how my package manager installed it). When I try to `stack-bin exec ghcid` it complains that "/bin/sh: stack: command not found"
19:44:08 <ezzieyguywuf> is it possible to specify to ghcid that my executable is actually stack-bin, not stack?
19:44:45 <jackdk> Getgle: and in Haskell, you have a lot of abstraction power, but it's different. Laziness means that some things you'd write as macros in CL are instead normal functions. Similarly, we can define small domain-specific languages using regular data types, and interpret them into functions or whatever
19:45:07 <mbox> ezzieyguywuf: the quick and easy fix is `ln -s stack-bin /bin/stack`
19:45:40 <ezzieyguywuf> mbox: yea, I'd prefer to avoid that if possible, in case the symlink gets clobbered by my package manager
19:45:49 <{abby}> ghcid -c 'stack-bin ghci'?
19:46:03 <ezzieyguywuf> but I suppose I could should do that, maybe `ln -n stackbin /usr/local/bin/stack` to be a bit safer
19:46:30 <ezzieyguywuf> {abby}: but ghcid was installed using `stack-bin install ghcid`, so I don't think it's in my path
19:46:40 <{abby}> stack exec -- ghcid -c 'stack-bin ghci'
19:46:43 <justsomeguy> ezzieyguywuf: Personally I'd install stack using the official instructions, instead of the system package manager.
19:46:46 <ezzieyguywuf> well, I guess it is in ~/.local/something, but _that_ isn't in my path (but I can add it)
19:46:51 <{abby}> ezzieyguywuf: my point is the -c flag
19:46:58 <{abby}> which lets you control how ghcid will start its repl
19:47:11 <ezzieyguywuf> {abby}: I'll try that.
19:47:18 <ezzieyguywuf> justsomeguy: I think I tried that and ran into an issue.
19:47:44 <justsomeguy> ezzieyguywuf: What issue did you run into?
19:48:09 <ezzieyguywuf> justsomeguy: i can't remember it was last week
19:48:16 <mbox> ezzieyguywuf: what package manager btw
19:49:18 <ezzieyguywuf> {abby}: --command did it! I just dumped it into .ghcid
19:49:26 <ezzieyguywuf> mbox: portage on gentoo.
19:49:37 <justsomeguy> ezzieyguywuf: If I recall correctly, all I had to do was grab the binary from the github release page, drop it into ~/.local/bin, and then edit ~/.profile to make sure ~/.local/bin is in the PATH environment variable.
19:50:33 <justsomeguy> (After checking the signature and checksum, of course.)
19:50:49 <ezzieyguywuf> justsomeguy: I did something similar - i wrote an ebuild for portage to pull the binary from github and install it using the regular means.
19:51:11 <justsomeguy> Heh, gotta love Gentoo.
19:52:05 <ezzieyguywuf> ^_^
19:53:55 <justsomeguy> Something like "ln -s $(which stack-bin) ~/.local/bin/stack" will work if you don't want you symlink to be in a global location, too.
19:54:27 <ezzieyguywuf> <interactive>:27:1-5: error:, Variable not in scope: hspec :: t0 -> t. this is coming from ghcid, but I don't understand what it means
19:55:30 <ezzieyguywuf> when I run `stack-bin ghci`, everything loads just fine with no errors
19:55:47 <ezzieyguywuf> oh, I left off a line: <interactive>:27:7-10: error: Variable not in scope: spec
19:58:23 <ezzieyguywuf> hm, I reproduced the error in `stack-bin ghci` by trying to execute `hspec spec` so I guess the error is in my config somewhere
20:02:53 <ezzieyguywuf> so, I have ":load test/Spec.hs" in .ghci, and it seems to load it when I launch ghci, but still I have to manually type ":load test/Spec.hs" from the prompt before "hspec spec" will work
20:04:23 <wavemode> the curse of the .ghci file strikes again
20:04:36 <ezzieyguywuf> wavemode: is .ghci not reliable?
20:05:12 <monochrom> .ghci is usually run at the wrong time for most people's purposes.
20:06:25 <ezzieyguywuf> is there a better alternative?
20:06:35 <monochrom> last time I saw someone having a problem with it, it was run-too-early and so some packages or project-specific modules were not yet in scope
20:06:59 <monochrom> (especially under "cabal repl" etc)
20:07:07 <monochrom> I think no.
20:08:16 <monochrom> If there is a test to be run frequently, use ghcid, or make "cabal test" work, or both.
20:08:31 <ezzieyguywuf> monochrom: I'm trying to use ghcid
20:08:52 <ezzieyguywuf> i fixed it by changed my .ghcid --commmand to explicitly run "ghci test/Spec.hs"
20:09:06 <monochrom> yes
20:11:35 <justsomeguy> I'm only a beginner, so I could be wrong, but this seems like something to specify as an import statement in the source file, instead. (You'll also have to add the HSpec package to your package.yaml's dependencies.)
20:12:01 <justsomeguy> Does that sound right?
20:45:50 <dsal> Why does Conduit have mapInput and mapOutput and mapInputM but no mapOutputM.  That seems like something that would be worth mentioning in the documentation.
20:48:00 <dsal> The annoying part is that it's the *easy* side that works.  Oh well.
21:17:45 * hackage net-mqtt 0.7.0.1 - An MQTT Protocol Implementation.  https://hackage.haskell.org/package/net-mqtt-0.7.0.1 (dustin)
21:35:28 <parsnip> in need of easy to setup formatter for haskell code in emacs
21:36:00 <parsnip> or do i have to fiddle with line breaks and indentation a bit
21:36:16 <parsnip> i've been spoiled by dartfmt
21:37:31 <jackdk> There are a few kicking around. Work uses ormolu, which has an emacs mode. I disagree with most of what it does, but like that we don't have to argue about output too much
21:38:29 <MarcelineVQ> "I ​hate it, but at least I don't have to have my coworkers anymore"
21:38:33 <parsnip> right
21:38:36 <MarcelineVQ> *have to hate
21:38:42 <parsnip> i like that i don't have to think
21:39:03 <parsnip> i don't care if it's ugly, as long as it's less ugly than what i have with zero effort
21:39:18 <parsnip> leverage my epsilon effort
21:39:25 <parsnip> almost zero
21:40:50 <parsnip> oh, requires nix or stack
21:41:56 * parsnip tries `cabal v2-install ormolu`
23:10:15 * hackage openapi3-code-generator 0.1.0.0 - OpenAPI3 Haskell Client Code Generator  https://hackage.haskell.org/package/openapi3-code-generator-0.1.0.0 (remo_doerig)
23:12:45 * hackage termonad 3.1.0.1 - Terminal emulator configurable in Haskell  https://hackage.haskell.org/package/termonad-3.1.0.1 (cdepillabout)
23:20:03 <liiae> monochrom: nil, that reverse could be rewrite with recursive, just the GHC.List.reverse is not recursive
23:20:10 <liiae> reverse [] = []
23:20:19 <liiae> reverse (x:xs) = reverse xs ++ [x]
23:20:35 <liiae> this reverse is defined with recursive, and it has reverse'
23:20:45 * hackage openapi3-code-generator 0.1.0.1 - OpenAPI3 Haskell Client Code Generator  https://hackage.haskell.org/package/openapi3-code-generator-0.1.0.1 (remo_doerig)
23:22:12 <liiae> this reverse and that GHC.List.reverse have the same function, but one is defined with recursive, another one isn't
23:23:19 <liiae> only recursive function can be another function's fixed point, 
23:24:33 <liiae> change the non-recursive GHC.List.reverse to that recursive reverse, we could get recursive'
23:28:35 <liiae> > let reverse' f [] = []; reverse' f (x:xs) = f xs ++ [x] in fix reverse' [1,2,3]
23:28:37 <lambdabot>  [3,2,1]
23:28:57 <liiae> > let reverse' f [] = []; reverse' f (x:xs) = f xs ++ [x] in reverse' reverse [1,2,3]
23:28:59 <lambdabot>  [3,2,1]
23:30:41 <liiae> here is the new question, is there a mechnical process to change a non-recursive function to a recursive function?
