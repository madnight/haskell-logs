00:00:05 <mniip> so with cabal-v2 how does one reinstall a packag
00:00:29 <mniip> it just keeps saying "up to date"
00:00:34 <MarcelineVQ> and so the system files are dynamically linked and what you're building expects things that aren't and that doesn't go so hot
00:04:46 <freeside> mmm, that's an interesting clue. but i'm pretty sure all the haskell on this system was built via stack. it's an AWS linux box so everything derives from i think centos?
00:06:57 <MarcelineVQ> freeside: how are you building pandoc and pandoc-crossref ?
00:07:19 <[exa]> freeside: you might have luck with just some simpler markdown-reading package; `cmark` is good with HTML conversion already available
00:09:19 <[exa]> freeside: anyway pandoc+crossreff installed just right for me like a week ago, on a manually installed ghc (from the prebuilt binaries), so I'd really suspect some system problem
00:09:26 <[exa]> freeside: what exact file is missing?
00:15:42 <freeside> /home/ec2-user/src/pandoc-crossref/lib/Text/Pandoc/CrossRef/Util/Util.hs:30:1: error: Could not find module ‘Text.Pandoc.Class’ ... Could not find module ‘Text.Pandoc.Writers.LaTeX’
00:15:51 <mniip> does the --reinstall flag actually even do anything
00:17:39 <freeside> There are files missing in the ‘pandoc-2.9.1.1’ package, try running 'ghc-pkg check'.
00:18:35 <freeside> i'm going to try a    ~/src/pandoc-crossref% stack install pandoc pandoc-citeproc
00:18:54 <mniip> freeside, can you run with -v
00:18:58 <mniip> it's probably a way issue
00:20:53 <freeside> ok, will try that once i get my cpu back
00:21:47 <freeside> i successfully built and installed pandoc from latest git, in the next directory over, in ~/src/pandoc, so i have to assume ~/.stack/ is now properly populated with pandoc itself, but the pandoc-crossref plugin isn't happy with what was built, and wants to build its own pandoc?
00:22:00 <freeside> in Soviet Haskell, Plugins Compile Core!
00:23:08 <freeside> neat, the pandoc-citeproc install failed identically.
00:23:43 <mniip> I mean --ghc-options="-v"
00:26:32 <freeside> where do i impose that? package.yaml?
00:26:39 <mniip> when calling stack
00:27:07 <freeside> ~/src/pandoc-crossref% stack --ghc-options="-v" install pandoc-citeproc
00:27:07 <freeside> Invalid option `--ghc-options=-v'
00:27:17 <mniip> goes after install
00:27:27 <freeside> erf, yes, it does
00:29:59 <freeside> https://pastebin.com/Xu9MSiSX
00:30:50 <mniip> let me guess: that directory exists but has files ending in something else than .hi?
00:31:47 <mniip> though /home/ec2-user/devbox5/home/ec2-user/ huh
00:34:56 <freeside> wait a minute, you've spotted something interesting there
00:35:22 <freeside> that's from a mount some time ago when i was building on this volume but mounted from a different box
00:35:43 <freeside> i thought my chroot and ln -s was proper but maybe some traces of that are left over
00:35:47 <mniip> did you install GHC with a custom installdir
00:35:48 <freeside> sigh, i may have to redo the whole thing
00:36:37 <mniip> freeside, if you're using stack
00:36:44 <mniip> why not just tell it to install a particular git commit hash
00:36:49 <freeside> ok
00:40:00 <freeside> i don't think i have enough of a mental model to be confident about how to tell pandoc-crossref to specify a different version of pandoc. presumably something inside stack.yaml and package.yaml.
00:40:52 <freeside> will try
00:48:05 <mniip> freeside, in stack.yaml in extra-deps
00:48:27 <mniip> you can create a subobject with fields "git" and "commit"
01:12:13 <maerwald> yeah, some packages somehow hardcore the compiler location
01:12:20 <maerwald> including brittany
01:12:28 <maerwald> *hardcode
01:19:02 <Heffalump> n
01:19:09 <Heffalump> sorry, wrong window
01:51:01 <pie_> does anyone know why trying to use printf with inline-c (at least in ghci) isnt actually showing any output, but printf's return value does give the correct amount of printed characters?
01:51:27 <pie_> im just running this:
01:51:43 <pie_> test :: ByteString -> IO CInt
01:51:43 <pie_> test str = BS.useAsCString str $ \cs -> [C.expr| int { printf("asd%s", $(char *cs));   }|]
01:51:51 <merijn> No end of line
01:51:55 <pie_> doh
01:52:17 <merijn> terminal buffering strikes again
01:52:36 <merijn> libc buffering I suppose, in this case
01:53:02 <pie_> yeah that was it
01:53:08 <pie_> yeah id think libc over terminal :P
01:53:14 <pie_> i make so many stupid mistakes ;_;
01:53:26 <pie_> this is the kind of stuff i wouldnt even notice by myself
01:54:28 <pie_> merijn: the thought that it was returning before libs outputs its buffer even crossed my mind, since idk how stuff across the boundard works, but thats where the "yeah but the bytes count..." thing crossed my mind
01:54:38 <pie_> well , i guess its the amount of bytes written to the buffer
01:54:46 <pie_> and not the actually printed number of bytes
01:54:50 * pie_ looks at man page
01:55:58 <pie_> only says "number of characters written" not where
01:56:12 <pie_> so which buffer is it getting stuck in
02:04:34 <merijn> stdout, presumably :p
02:04:46 <merijn> Why not just, add an end of line?
02:18:18 <pie_> merijn: i did
02:18:23 <pie_> i was jst wondering
02:22:27 <pie_> the readme seems to be missing some stuff about how inline-c is supposed to be used, how am I supposed to figure it out?
02:22:41 <pie_> say for example, Id like to return a struct from C
02:22:56 <pie_> theres some cTypesTable conversion thing but apparently template haskell is also involved and idk
02:28:08 <pie_> the .Context module docs are not very verbose
02:29:15 * hackage membrain 0.0.0.2 - Type-safe memory units  https://hackage.haskell.org/package/membrain-0.0.0.2 (vrom911)
02:30:15 <pie_> ok apparently the [t is some template haskell thing https://github.com/fpco/inline-c-nag/blob/1b06d0fab0e545752b0744cc4725d5a661cdb0c9/src/Language/C/Inline/Nag/Internal.hsc#L97 -> https://downloads.haskell.org/~ghc/7.8.4/docs/html/users_guide/template-haskell.html
02:33:25 <pie_> but how do i specify the semantics of the type conversions...
02:36:35 <pie_> it looks like people know how to use this so they must know something i dont
02:40:32 <merijn> pie_: You can't return structs from C. At best you can return pointers to structs
02:41:00 <pie_> uh, sure i guess
02:41:19 <pie_> i have to pay attention to ownership stuff then, not quite sure how that works either
02:41:31 <merijn> tbh, I've never really bothered with inline-c and just used the FFI
02:41:35 <pie_> though maybe this is avoidable, ill just check on the haskell side if somthing is null
02:41:47 <pie_> im looking at it because the library im patching uses it
02:42:32 <pie_> e.g. https://github.com/chpatrick/clang-pure/blob/master/src/Language/C/Clang/Internal/FFI.hsc
02:42:45 * hackage jose 0.8.3 - Javascript Object Signing and Encryption and JSON Web Token library  https://hackage.haskell.org/package/jose-0.8.3 (frasertweedale)
02:43:39 <mpickering> What flag do I need to get GHC to show me kind arguments?
02:44:54 <merijn> mpickering: Is there a simple way to get rid of all the debug noise in your ghcide fork? Since linking it dynamically seems like it does work
02:45:12 <mpickering> what in particular?
02:45:28 <mpickering> which branch are you using as well
02:46:03 <merijn> I think I was using hls?
02:48:13 <mpickering> and what debug output are you talking about
02:49:51 <merijn> I get several thousand lines of (apparent) debug output on stdout
02:53:25 <merijn> Lemme update to the latest hls version and see what happens
02:57:35 <mpickering> But in an editor you don't see that?
03:00:18 <merijn> mpickering: That's true, but if it's spending 10s of seconds printing things, that's bad :p
03:00:30 <merijn> mpickering: Anyway, the latest version seems considerably less noisy and faster
03:01:32 <merijn> Plus, it seems to work without a hie.yaml, so that's a plus :)
03:01:46 * hackage haskoin-store-data 0.26.5 - Data for Haskoin Store  https://hackage.haskell.org/package/haskoin-store-data-0.26.5 (jprupp)
03:01:48 <merijn> Now I just need to figure out how to use the right builddir
03:02:46 * hackage haskoin-store 0.26.5 - Storage and index for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-store-0.26.5 (jprupp)
03:04:49 <merijn> mpickering: Is there a way to get the hie-bios cradle detection to include additional cabal flags (ideally without writing *all* flags out into hie.yaml)
03:11:20 <merijn> Also, the recompilation logic appears to be broken >.>
03:16:06 <fendor> merijn, currently not 
03:16:17 <fendor> but it could be done
03:16:56 <fendor> or unless you write a bios cradle, then probably yes
03:47:42 <maerwald> Isn't there already a tool that autogenerates cradle files? 
04:23:15 * hackage graphql 0.7.0.0 - Haskell GraphQL implementation  https://hackage.haskell.org/package/graphql-0.7.0.0 (belka)
04:24:06 <hexagoxel> Afaik all packages that use the GHC API will have a runtime dependency on GHC paths (of the ghc they are compiled with). To deploy such executables I resorted to copying those paths over (you don't need the full ghc install, just the $prefix/lib/ghc-xxx/* paths)
04:42:04 <merijn> fendor: ah, that's annoying. My cabal is using a non-default build dir (to play nice with the rest of my buildsystem), so ghcide using dist-newstyle duplicates the build tree :\
05:00:06 <merijn> maerwald: Could be, but no clue where to find said tool, then :p
05:03:19 <maerwald> I still don't fully understand why the default (no cradle file) rarely works
05:05:00 <merijn> maerwald: The problem is that ghci doesn't support multiple components being loaded at once, hie-bios (afaik) uses cabal-repl to discover the proper GHC environment to check things
05:05:28 <merijn> maerwald: So if your project has multiple components, then cabal repl breaks and hie-bios can't figure out what to do
05:06:09 <merijn> maerwald: The *true* solution is to fix GHCI with multi-component support, but that's hard and I don't know if anyone is working on it
05:06:41 <merijn> maerwald: The workaround is to have an explicit cradle that has the union of the config of every component (IFF those don't conflict) and then check files using that
05:08:08 <merijn> With multi-package repos it's a bit worse still in that "cabal repl" won't run at all without a target, so auto-dection never works there until cabal-install has a better workflow to support it
05:08:20 <merijn> (Which I think is a GSoC project for this year, so that's good!)
05:25:59 <asheshambasta> what is the recommended way to overcome conflicting family instance declarations for associated type-families? I'd like to have one such class that has an instance of for all types satisfying some constraint, but I'd also like to define overlapping instances.
05:26:28 <merijn> The recommended way to overcome that is "don't do that"
05:26:38 <asheshambasta> hehe :-)
05:26:47 <merijn> Not really joking, tbh :p
05:27:20 <merijn> asheshambasta: This is because you have some sort of sensible default implementation IFF said constraint applies?
05:27:23 <asheshambasta> I understand, I've come to believe this myself that GHC is most of the times right if its complaining about some design decision 
05:27:40 <asheshambasta> merijn: correct
05:27:52 <merijn> asheshambasta: Then you probably want DefaultSignatures
05:28:07 <merijn> asheshambasta: Which allows you to define more specific default implementations for your class
05:28:37 <merijn> asheshambasta: See for example: https://github.com/merijn/validated-literals/blob/master/ValidLiterals.hs#L87-L89
05:28:45 <asheshambasta> merijn: yeah I was being led towards that via some googling.
05:29:04 <merijn> asheshambasta: Which basically says "if 'b' is a 'Lift' instance, use this default implementation"
05:29:23 <asheshambasta> merijn: but coming back to "don't do that", does this smell like bad design?
05:29:59 <asheshambasta> the "Lift" approach does seem nice.
05:30:01 <merijn> asheshambasta: There's no real reliable way to handle overlap. The default signature approach tackles most of the problem the overlap solves
05:30:34 <merijn> asheshambasta: You still have to write "instance YourClass YourType", but if YourType has the appropriate instance, you don't have to define any implementations (just use the default)
05:31:14 <merijn> So it's slightly more verbose than the overlapping solution (i.e., you have to write explicit "instance Class Type"), but all the overlap problems instantly disappear
05:31:37 <merijn> So I find it the best trade-off between brevity and robustness
05:32:24 <asheshambasta> interesting, and in this case, I'm assuming that we also have to provide reasonable "defaults" for the assoc. type-families. 
05:32:29 <merijn> asheshambasta: With DeriveAnyClass and co you can even simply do "deriving (YourClass)" and use this. Which seems about as easy as it gets
05:32:47 <merijn> I'm not really sure how well this plays with type families, tbh
05:32:49 <asheshambasta> this leads to my imports being inverted wrt the module that supplies this class but its no biggiel
05:33:37 <asheshambasta> yeah but your example answers my questions
05:34:33 <asheshambasta> thank you: this helped. I'd basically just want to have default types for these families, and then require some sort of a "Lifted" constraint to provide with default implementations.
05:46:54 <jumper149> Is it possible to export the accessor functions of a record but not the ability to construct it?
05:53:06 <maerwald> jumper149: you mean not export the constructor but the accessor?
05:56:07 <Cale> jumper149: yes
05:58:51 <jumper149> maerwald: yes
05:59:32 <maerwald> jumper149: yes
05:59:45 * hackage http-client-openssl 0.3.1.0 - http-client backend using the OpenSSL library.  https://hackage.haskell.org/package/http-client-openssl-0.3.1.0 (MichaelSnoyman)
06:00:39 <jumper149> Oh it's super easy ^^ shouldve just tried it x)
06:01:12 <maerwald> https://hackage.haskell.org/package/http-client-openssl-0.3.0.0/docs/Network-HTTP-Client-OpenSSL.html#v:withOpenSSL
06:01:18 <jumper149> Is there a way to export ALL accessor but not the constructor?
06:01:25 <jumper149> without listing them manually
06:01:27 <maerwald> Imagine this function would have documentation about the 200 ways openssl initialization may fail
06:06:30 <Cale> maerwald: It doesn't look like any of that has been reflected on the Haskell side anyway, so if you want to deal with it, you'll probably need to modify the library.
06:07:19 <maerwald> I've been using http-io-streams, which uses openssl and it would just crash on this and that. Impossible to predict
06:08:14 <maerwald> Would make a lot of sense to make that an Either and create an OpenSSLError type
06:20:45 * hackage unbound-generics 0.4.1 - Support for programming with names and binders using GHC Generics  https://hackage.haskell.org/package/unbound-generics-0.4.1 (AlekseyKliger)
06:29:54 <ahri> I have a type `Foo a b` and a Functor instance for `Foo a` so I can easily get to a type `Foo a c` having derived Functor so it's nice and low on boilerplate, but now I've got a new requirement and really I need to get from `Foo a b` to `Foo c d` - is there a neat way to get there via `deriving` or am I going to have to get my hands dirty?
06:30:40 <merijn> ahri: There's no easy deriving way, but it seems relevant to point out Bifunctor :)
06:33:29 <maerwald> merijn: should you even be on IRC? :P
06:33:53 <Cale> maerwald: why?
06:33:59 <ahri> cool, ok, I just thought I'd check before jumping in! Bifunctor it is!
06:34:14 <maerwald> Cale: why what?
06:35:37 <Cale> The question to merijn 
06:35:56 <maerwald> IRC being a timesink an all that
06:39:36 <jumper149> Is there a better way to write (Proxy :: Proxy a)?
06:41:23 <maerwald> Using type applications :P
06:41:30 <Cale> Depends on what you mean by "better", but you can write (Proxy @a)
06:42:18 <maerwald> With type applications, you may not need Proxy at all, just 'a'
06:42:43 <jumper149> maerwald: what
06:42:45 <MarcelineVQ> maerwald: that's the kind of line you use when you want merijn to respond :>
06:42:51 <maerwald> lolo
06:43:46 <jumper149> but a is a type I can only use it in type level, right?
06:44:28 <maerwald> https://www.reddit.com/r/haskell/comments/6ufnmr/scrap_your_proxy_arguments_with_typeapplications/?utm_source=share&utm_medium=web2x
06:44:32 <maerwald> why are the urls so long
06:44:33 <Cale> maerwald, jumper149: You need the @
06:44:35 <merijn> Cale: Because I need to finish my thesis :p
06:44:43 <Cale> merijn: ah :D
06:45:13 <jumper149> Can you explain how TypeApplications work exactly. The user guide paragrapgh doesn't explain it very well
06:45:28 <maerwald> Forget it about it if you're comfortable with Proxy
06:45:36 <jumper149> Like what is it's relation to setting types with ::
06:46:04 <maerwald> The most confusing part about type applications is figuring out the position of what you want sometimes
06:46:19 <maerwald> @_ @_ @_ @Int
06:46:19 <lambdabot> Maybe you meant: v @ ? .
06:46:23 <Cale> jumper149: When you have a type like  forall a. (...), it's like saying that the type is a function of the chosen type a
06:46:42 <Cale> jumper149: Type applications give you a way to provide that type explicitly at the term level.
06:47:32 <Cale> maerwald: Particularly because type applications work in cases where nobody used an explicit forall when defining the thing -- I really think that was a mistake
06:48:44 * shapr hugs Cale
06:48:57 <maerwald> shapr: that's an offense in this time :P
06:49:16 <shapr> it's an internet hug! it's safe!
06:49:18 <maerwald> (in germany you'd be fined 500€ or so)
06:53:52 <jumper149> How would I write something like ((,) :: Int -> Char -> (Int,Char)) with TypeApplications?
06:54:31 <opqdonut> jumper149: (,) @Int @Char
06:54:41 <opqdonut> just apply the type arguments in the same order as they're in the forall
06:54:42 <opqdonut> :t (,)
06:54:44 <lambdabot> a -> b -> (a, b)
06:55:00 <opqdonut> %type (,)
06:55:31 <opqdonut> % :type (,)
06:55:31 <yahb> opqdonut: a -> b -> (a, b)
06:55:35 <opqdonut> oh well
06:56:15 <gentauro> I asked some question last week with regard of parsing something similar to a `split :: [a] -> [a] -> [[a]]`. I was suggested to implement the `pc` with `splitOn` which I have done: https://pastebin.com/T5rrUe3Z The problem I see now, is that this `pc` will consume the stream of bytes and therefore I would need to use a local parser for each chunk. So far so good, but the problem is, how do I bubble up 
06:56:21 <gentauro> the errors for each of them? (Until I expend my (Index, Error) to [(Index,Error)] I would just like to see the first one)
06:57:08 <jumper149> Is it just the order in which the type variables occur in the type signature of (,)?
06:58:39 <maerwald> good question, the haskell reports probably specifies this
06:58:50 <maerwald> (in the absence of forall)
07:00:18 <jumper149> I think I'm gonna stick to using :: for now. Wouldn't be that hard to change in the future.
07:00:40 <maerwald> it makes your code look more advanced, so you get better job offers
07:00:48 <maerwald> (I'm kidding)
07:01:37 <opqdonut> it's the order in which they are in the implicit forall, but ghc _probably_ uses the same order as the type signature in the implicit forall
07:01:50 <maerwald> if every of your modules start with ~25 LOC of language pragmas... that's when you know you're the real deal
07:02:53 <maerwald> also: post your obscure libs on reddit for extra fame
07:03:05 <gentauro> maerwald: never gets old -> https://twitter.com/edwinbrady/status/1163816732902883329
07:03:45 <carter> Write code that works on every version with fgaz
07:03:53 <maerwald> lolo
07:03:58 <carter> Fglasgow exts
07:12:17 <kuribas> if you do property tests, shouldn't you have property tests for the property tests?
07:12:36 <kuribas> meta-property tests?
07:12:49 <maerwald> they run in TH?
07:14:26 <kuribas> or to make sure the generators are actually generating the right data?
07:21:31 <lyxia> you could have those. if the generators don't generate the right data usually one of the other properties is going to fail anyway.
07:22:29 <kuribas> what if you want to generate, say bezier curves, but you want to make sure that different kind of curves are generated?
07:23:05 <kuribas> if the generator is broken, your maybe not get all curves.
07:28:16 * hackage monadic-recursion-schemes 0.1.1.0 - Recursion Schemes for Monadic version.  https://hackage.haskell.org/package/monadic-recursion-schemes-0.1.1.0 (KatsutoshiItoh)
07:32:19 <lyxia> yeah that's harder to test, one way is to collect some statistics about the generated data
07:50:02 <Bish> hello, why has haskell never tried to be a language to be embedded or scripted? i mean ghci proves it can be compiled just in time™
07:55:09 <hololeap> Bish: the large runtime prevents it from being used in embedded applications easily. Not sure what you mean by "scripted", if you mean "can be run without compiling first", that would defeat the point of it being a strongly-typed language IMO
07:55:53 <Bish> hololeap: i don't see how scripting implies dynamic typing
07:56:29 <Bish> hololeap: how does the large runtime prevent it? i mean, is+.t that included anyways in ghc programs?
07:56:35 <Bish> ghc compiled programs*
07:56:47 <hololeap> then you'll have to define what you mean by scripting. You can do anything with Haskell that you can do with bash, for instance
07:57:38 <Bish> kinda like a ghci compiled into every application and some interfacing between native & "bytecode" ?
07:57:46 <Bish> and that's kinda like what ghci does?
07:57:54 <Bish> but it's always ghci invoking stuff, none invokes ghci
07:57:58 <hololeap> embedded applications usually have very tight memory/storage constraints. I'm not saying you _couldn't_ but that it's not an optimal language for that domain, unfortunately
07:58:45 <Bish> it would be cool if you could extend haskell programs, without having to do fancy .so loading in native code
07:58:48 <Bish> don't you agree?
08:00:41 <hololeap> I suppose... I'd have to see some compelling examples first
08:02:55 <Cale> I think you're using the word "embedded" in two different ways
08:03:22 <Bish> yeah i don't mean embedded processors
08:03:36 <hololeap> Take a look at this code for tryhaskell.org; it's evaluating expressions in something besides ghci:
08:03:37 <hololeap> https://github.com/tryhaskell/tryhaskell/blob/master/src/TryHaskell.hs#L140
08:04:32 <Cale> Bish: There are some programs that load Haskell code at runtime -- see the 'hint' library on Hackage if you want a more convenient way to write that.
08:04:54 <Bish> Cale: thanks for pointing me there
08:05:09 <Cale> There's also the approach that xmonad takes to it, which is just to recompile itself with GHC and exec the new executable.
08:05:23 <Cale> (iirc)
08:05:37 <Bish> that sounds way too hacky, but it was a thing i thought about when getting to this thought
08:05:56 <Cale> Its "configuration file" is just a program that you write using the XMonad library.
08:06:44 <Cale> I'm not sure it's any more hacky than including the entire compiler within your executable.
08:18:48 <Bish> Cale: i don't see how having a compiler inside your application is hacky :/
08:18:55 <Bish> bulky maybe, but hacky?
08:19:54 <Bish> Cale: yeah, i've seen xmonad users configure stuff, it's odd 
08:22:45 <sm[m]> freeside: were you able to tell if that flag fixed your overweight pandoc build ?
08:23:27 <Cale> Bish: I don't see either way as necessarily hacky.
08:24:00 <sm[m]> FTR pandoc has always been a slow build, but not this memory hungry - that is a problem with recent GHC, can’t really blame pandoc
08:24:45 <sm[m]> it’s just a command line doc converter, not Microsoft Windows :)
08:26:02 <phadej> it handles microsoft office docx -- somehow
08:26:03 <phadej> so...
08:26:07 <merijn> XMonad has suckered people into think it's a configurable window manager, while it's secretly just an EDSL for writing your own window manager :p
08:26:25 <jumper149> merijn++
08:27:30 <Bish> im guessing they didnt want to include a parser into their binary..
08:28:10 * sm[m] switched to using only pandoc binaries some time ago so has avoided this madness
08:28:44 <jumper149> Bish: Nah the approach is totally fine. GHC is a way better parser than anything you could write without making a wm bloated imo.
08:28:55 <Bish> yes i know, iw as joking
08:29:18 <merijn> Also, a bunch of stuff you can do with XMonad just can't be sensibly done with a config file, unless you make your config file fully programmable
08:29:30 <Bish> when i first heard from the approach i also thought.. maybe this isn't as stupid as it sounds
08:29:30 <merijn> In which case you just get the same result, but with worse error handling
08:30:21 <jumper149> Yup, to me it's more like a high level library to Xlib :p
08:34:15 * hackage data-category 0.10 - Category theory  https://hackage.haskell.org/package/data-category-0.10 (SjoerdVisscher)
08:39:58 <tdammers> xmonad actually suckered me into learning haskell
08:41:33 <enikar> nice :)
08:44:14 <polyphem> Hi , i got this Expr evaluator written , and if i evaluate terms from ghci it works but if i define i get error about ambiguity. I think it has to do with ghci defaulting . Could someone please take a look : https://pastebin.com/GLKBdt9G
08:45:14 <polyphem> s/define/define a term in the source,/
08:49:44 <polyphem> i played with GADTs and Typelevel extensions to get a variant type , dont no if it even makes sense how i did it ...
08:50:31 <lyxia> Var "a" and Var "b" probably default to  Expr Double in ghci but without defaulting you need a type annotation
08:51:18 <lyxia> because of that, it's a problem that the result type of (:/:) is disconnected from its arguments
08:51:29 <polyphem> lyxia: yes , thats what i thought, however i dont know where and how to put it 
08:54:58 <polyphem> can i do type applications  ?
08:55:16 <lyxia> polyphem: (Var "a" :: Expr Double)
08:55:45 <lyxia> maybe also  (Var @Double "a")
08:56:29 <ski> do you want `(:/:)' to be able to change type ?
08:57:20 <polyphem> that contercarates what i wanted to do , having "variant variables" , else i could have different constructors like VarI , VarD ,VarF ... 
08:57:47 <ski> i dunno what "variant variables" means
08:58:14 <polyphem> ski : yes , 10 :: Int / 3 :: Int ==> 3.333 :: Double
08:59:05 <polyphem> sky : variant typed , like dynamicly typed
08:59:31 <ski> so it doesn't know that `Var "x"' i intended to have type `Expr Double', yes
08:59:50 <lyxia> your Expr is statically typed though...
08:59:50 <tdammers> the way "variants" are typically done in Haskell is via sum types
09:00:41 <tdammers> that, or something like Dynamic, but that one is less useful in practice than it may seem at first glance
09:00:43 <ski> (to me "variant type" is a synonym for "sum type")
09:00:51 <polyphem> lyxia: i have the VarType Sum type for that , the Environment Env is a Map String VarType
09:01:45 * hackage hpc-codecov 0.2.0.0 - Generate codecov report from hpc data  https://hackage.haskell.org/package/hpc-codecov-0.2.0.0 (AtsuroHoshino)
09:02:46 <tdammers> GADTs are nice when you want to kind of lift Haskell's type system into your expression language, but they won't give you a variant type
09:03:19 <tdammers> they basically allow you to express things such as "the sum of two integer expressions in this language is also an integer expression"
09:03:43 <tdammers> but once you write such an expression, it's still statically locked into the integer type. it's not dynamically typed.
09:04:06 <polyphem> tdammers: yea , i had some issues getting it to compile , now that it dous it doesnt behave as expected. What would be a more idiomatic approach ?
09:04:20 <tdammers> if you want proper dynamic typing, you need to just make a "variant" sum type that can represent all values that you care about
09:04:38 <tdammers> data Variant = VarInt Int | VarStr Text | VarBool Bool | ...
09:04:51 <tdammers> now your expression language is dynamically typed
09:04:59 <ski> which is what `VarType' is
09:05:00 <tdammers> but of course that means that all expressions are statically 'valid'
09:05:03 <tdammers> yeah
09:05:32 <tdammers> and you can't catch nonsensical constructs statically anymore
09:05:51 <tdammers> e.g. AddE (VarString "hello") (VarFunc id) -- is now well-typed
09:07:23 <tdammers> the variant type, at least with exhaustiveness checks enabled, still forces you to handle all possible combinations, but you can't reject them until runtime
09:07:33 <tdammers> unless you write a type checker on top of that of course
09:07:46 <ski> polyphem : btw, your `Show' instance is wrong. i think you should be able to just derive it. but it you want to do it by hand, it should be `showsPrec p (I x) = showParen (p > 10) $ showString "I " . showsPrec 11 x' (and similarly for the other cases
09:07:51 <polyphem> tdammers: yea i think the GADTs derailed me on that , i got the sumtype , the environment  dynamic , but the Expr type is static , right ?
09:08:34 * ski would also prefer `extr :: x -> Maybe t' ..
09:09:20 <polyphem> ski : i had "show (I i) = show i" , and when i printed my env in ghci , i suddenly had heterogenous lists :)
09:10:36 <ski> also, you probably should use `realToFrac'
09:10:47 <ski> polyphem : yes, that's worse :)
09:11:06 <polyphem> λ> env                                          
09:11:08 <polyphem> fromList [("x",4),("y",4.1),("z","foo")]        
09:11:10 <polyphem> it :: M.Map [Char] VarType 
09:11:45 <ski> `Show' instances are supposed to work together with each other (so it's not the place to do custom syntax, or even pretty-printing)
09:12:26 <polyphem> ski: it was a "debugging" hack
09:12:47 <polyphem> ski: but thank you for clearification
09:12:48 <ski> if you only have constant constructors, it's okay to define `show'. otherwise, you should define `showsPrec', if you're making a `Show' instance
09:13:13 <ski> but in your case, i think it should be able to derive it for you
09:13:50 <polyphem> ski: ghc yelled at me that it couldnt derive for GADTs 
09:14:07 <ski> (occasionally, one wants to do a custom instance, for abstract data type, representation hiding, purposes. case in point is `Map' just above, emitting `fromList' rather that display internal representation)
09:14:20 <ski> well, a standalone should work, no ?
09:14:34 <ski>   deriving instance Show VarType
09:15:12 <polyphem> dunno , first time i am using GADTs and all that .
09:15:42 <ski> of course, `VarType' doesn't need to be declared using `GADTSyntax'
09:15:46 * hackage haskoin-store-data 0.26.6 - Data for Haskoin Store  https://hackage.haskell.org/package/haskoin-store-data-0.26.6 (jprupp)
09:16:03 <ski> (but perhaps you fancied it, for whatever reason)
09:16:30 <polyphem> ski ... thats what i did ... how did you know ß :)
09:16:45 * hackage haskoin-store 0.26.6 - Storage and index for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-store-0.26.6 (jprupp)
09:16:53 <ski> what's what you did ?
09:17:18 <polyphem> i fancied it ,  i went GADTs all the way ...
09:17:28 <ski> ah, ic :)
09:19:14 <polyphem> so , either i go full dynamic and wont catch nonsensical errors like tdammers said , or i stick with static checks using GADTs syntax for my Expr type and have to give up my Variant Environment , right ?
09:20:35 <polyphem> and now its the wost of the two worlds , dynamic types wich need type annotations to be statically checkabale by the GADT Expr type.
09:20:44 <polyphem> doh !
09:25:21 <ski> polyphem : not following the "have to give up my Variant Environment" part
09:26:27 <polyphem> ski: my "Map String VarType" approach ...
09:26:39 <ski> (oh, and btw, you might want to adjust the operator precedence&dixity declaration, to let the operators follow the conventional ones ?)
09:26:40 <polyphem> ski: my variable store
09:27:17 <ski> @hackage dependent-map
09:27:17 <lambdabot> http://hackage.haskell.org/package/dependent-map
09:27:24 <ski> it would be nice if one could us that
09:28:26 <ski> polyphem : still not following. your code, as is now, works (FSVO "works"), it's just that you have to add annotations to operands of division
09:29:05 <ski> @type fromRational . toRational
09:29:07 <lambdabot> (Fractional c, Real a) => a -> c
09:29:10 <ski> @type realToFrac
09:29:11 <lambdabot> (Real a, Fractional b) => a -> b
09:30:09 <ski> (perhaps you'd want to refrain from having to do so, but you didn't include that as a desiderata above)
09:31:40 <polyphem> ski  : its work in progress , but i think having to type annotate my VarTypes , works contrary to having them in the first place.
09:33:10 <ski> it's not your `VarType's that need to be annotated
09:33:21 <polyphem> TODO: realToFrac;operator fixety,precedence; extr :: x -> Maybe t
09:34:00 <polyphem> ski :: what do u mean , the Expr then ?
09:34:08 <polyphem> s/::/:/
09:34:18 <ski> it seems nicer to me to put calls to `error' not in type class methods, but rather in `envLookup'
09:34:59 <polyphem> TODO: realToFrac;operator fixety,precedence; <em>extr :: x -> Maybe t<em>
09:35:09 <polyphem> TODO: realToFrac;operator fixety,precedence; <em>extr :: x -> Maybe t</em>
09:35:38 <ski> (probably requires adding `Typeable a' constraint to `envLookup', if you want the target type in the error message)
09:35:57 <gentauro> Athas: Joakim siger at Zoom var lort (han så med på SPJ oplæg)
09:36:13 <gentauro> ups, wrong channel :)
09:36:30 <ski> #haskell.scandinavian ?
09:36:31 <polyphem> gentauro: hungarian ?
09:38:08 * ski . o O ( <https://chalmersfp.github.io/> )
09:38:18 <polyphem> ski : so you think its "ok-ish" all in all as concept , and i should implement your suggestions , istead of refactoring "en gross" ? 
09:38:52 <ski> polyphem : i dunno. depends on your goals, and what annoyances you're willing to stand
09:39:45 <ski> polyphem : btw, i tend to remark on smaller points, even if i would also sometimes suggest a larger change which would make those smaller ones moot
09:40:24 <ski> (on that note, `(VType VarType a) => ' could be `VType VarType a => ')
09:41:11 <polyphem> ski : i like that , but it may be wasted effort in the end when the overall direction isnt right
09:41:12 <gentauro> polyphem: close enough -> Danish ;)
09:41:23 <ski> (the idea being that there could be something useful learned in such small points, for another time)
09:41:24 <polyphem> appart from learning new stuff
09:42:28 <polyphem> as , i said i like that , thank you
09:45:08 <ski> (hm. one could also ask whether `x' needs to be a parameter of `VType', or if you could replace it with `VarType' .. if you plan on having alternative types, which you make instances of `VType' for, in the `x' position, that could be reason to keep it)
09:45:57 <polyphem> so the Expr evaluater is of course part of a bigger "project" , its a (stack||regiser)-vm with (assemblerish syntax)for manipulating sound playback , and if i need to compute some indexes or lengths thats where the Exprs come in to not do all too low level ,i.e on the stack as rpn computations
09:46:35 <ski> ok
09:49:03 <polyphem> thats why i didnt want to make it "staticaly annotated" its only the side show, and its also too big of a gun , cause i intend to implement "goto" intentionally for spaghetti code :) 
09:52:23 <ski> (btw, if you don't provide a precedence&fixity declaration, you would still be able to use those operators infix. iirc, you get the effect of `infixl 9')
09:55:33 <ski> polyphem : you need `Double' for the lengths ?
09:55:49 <polyphem> ski : i had an issue erliar in ghci where "eval env (Var "y" :/: Var "y")" ... sad it expected an Integer , even if Var "y" is Double ... i put the expression in the source to post this question when i head the ambigiuity error
09:56:42 <polyphem> ski: no i need Integer for the lenghts :)
09:56:56 <ski> (`Var "y"' has type `forall a. VType VarType a => Expr a')
09:57:18 <ski> what do you need `Double' for, then ?
09:57:27 <ski> and division ?
09:58:16 <polyphem> ski : yea, i figured out , the code as is is "pull" style , the consumer determins what it was a Var to be . That wasnt intended at all ...
09:59:02 <ski> if you defined `y :: Expr Double; y = Var "y"', then you could refer to `y' multiple times
09:59:24 <polyphem> ski: division, for slicing a file in x slices, Double for devision
10:00:10 <polyphem> ski : i dont follow
10:00:47 <ski> i figured indices would be integers, so the only thing that you mentioned that i could imagine being `Double' was lengths, presumably lengths of samples or slices. but you said lengths are also integers
10:01:32 <ski> i mean that you could define a Haskell variable `y', with type specified to be `Expr Double', then consumers of that wouldn't determine which type it should be
10:02:12 <polyphem> ski: audiofile lengths are Integres, indexes should be Floats , so Marks at Indexes remain at same place if i stretch audio playback 
10:02:35 <ski> (but this may be a moot point, since presumably you're not going to write that much closed expressions of type `Expr Double', rather parsing them from some input format (or maybe generating them in some other way) ?)
10:03:07 <ski> oh ok. i was thinking indices into some kind of (discrete) sequence
10:03:15 <polyphem> ski , ahh ok , y :: Expr Double as the "consumer"
10:03:46 <ski> consumer of `Var "y"', yes. while other things would be consumers of `y' itself
10:04:42 <polyphem> ski audio clips have discrete domain , however i like to somtimes stretch and pitch and there i use floating indexes
10:06:19 <polyphem> ski : my head is hurting now .... have to contemplate and think things through ... thanks for your input as for now
10:07:12 <polyphem> your suggestions are on the TODO list, maybe i come back later with more "questions" ....
10:07:16 * ski . o O ( "Why program with continuous time?" by Conal Elliott in 2010-01-02 at <http://conal.net/blog/posts/why-program-with-continuous-time> )
10:08:26 <ski> yw, polyphem
10:08:57 <polyphem> ski : conal is BIG
10:09:29 <polyphem> thanks again , afk 
10:09:31 <MarcelineVQ> Well we all get a bit out of shape over time
10:10:53 <MarcelineVQ> conal is here from time to time if you end up with questions to ask him
10:11:18 <MarcelineVQ> sometimes sooner than later
10:11:20 <ski> (ssh, he's here)
10:31:16 * hackage aur 7.0.1 - Access metadata from the Arch Linux User Repository.  https://hackage.haskell.org/package/aur-7.0.1 (fosskers)
10:33:35 <dsal> I just ran hlint in a directory and it's compiling ghc.  I feel like there's too much magic here.
10:34:04 <wavemode_> talk about side effects
10:37:59 <sm[m]> next it’ll order itself a bigger computer
10:40:13 <Rembane> And rename you to Dave.
11:07:16 * hackage tart 0.2 - Terminal Art  https://hackage.haskell.org/package/tart-0.2 (JonathanDaugherty)
11:20:04 <koz_> dsal: I must admit, that's a new one.
11:21:39 <dsal> I don't understand what's happening.  I have an installed hlint in ~/.local/bin/hlint that `which` tells me it wants to use.  I don't care too much at the moment, though... it gives my computer something to do.  I asked a different computer and got some good suggestions in the meantime.
11:29:15 * hackage juicy-gcode 0.1.0.6 - SVG to G-Code converter  https://hackage.haskell.org/package/juicy-gcode-0.1.0.6 (dlacko)
11:36:15 * hackage mmsyn6ukr 0.6.4.0 - A musical instrument synthesizer or a tool for Ukrainian language listening  https://hackage.haskell.org/package/mmsyn6ukr-0.6.4.0 (OleksandrZhabenko)
12:33:19 <pie_> anyone have any pointers on how i can debug this https://bpa.st/BUYQ
12:33:40 <pie_> im not even sure if its breaking on the haskell or c++ side
12:35:15 <Heffalump> pie_: do you know how CPP.include expands?
12:35:51 <wavemode> "has not been declared" sounds like a c++ error
12:41:07 <pie_> thats what i thought
12:41:18 <pie_> Heffalump: not really? i figured it adds an include
12:41:26 <pie_> Heffalump: id be confused because all the other includes work
12:42:05 <pie_> some more context;
12:42:06 <pie_> <pie_> im trying to use inline-c-cpp and it seems to more or less work but i just started trying to get stuff across the ffi
12:42:06 <pie_> <pie_> i didnt really find a good explanation of how to use that part
12:42:06 <pie_> <pie_> this is ASTContext https://clang.llvm.org/doxygen/classclang_1_1ASTContext.html
12:42:06 <pie_> <pie_> i *think* the c++ isnt seeing ASTContext() but that seems odd
12:42:06 <jumper149> What is an idiomatic way to write a function `f :: (Maybe a,Maybe b) -> Maybe (a,b)`?
12:42:07 <pie_> <pie_> its not private or anything so that cant be the problem
12:42:31 <Heffalump> jumper149: use Applicative
12:42:44 <Heffalump> or just pattern-matching if you want to be explicit
12:43:02 <pie_> Heffalump: and I dont see a way yet for ghc to give me some intermediate file so i can look at it
12:43:06 <jumper149> okdok ty :)
12:44:11 <Heffalump> pie_: -ddump-splices ?
12:44:39 <Heffalump> or maybe -ddump-to-file
12:45:03 <solonarv> -ddump-to-file says *where* the dumps should go
12:45:33 <solonarv> -ddump-splices makes GHC output the result of template haskell splices and quasiquoters
12:46:17 <Heffalump> I see, yes. I was misreading the SO question I found after quickly googling "dump-splices" which I had remembered existing.
12:46:47 <pie_> dump spliced just seemed to dump a little haskell gibberish not c when i tried it?
12:47:36 <Heffalump> ah, it probably dumped a Haskell AST of the C.
12:47:50 <Heffalump> I'm not sure at what point the C would be pretty-printed and passed to a compiler.
12:49:30 <pie_> Heffalump: https://bpa.st/JVMA this is what the repl gives me
12:49:43 <pie_> (cabal run)
12:49:47 <pie_> * cabal repl
12:50:14 <pie_> line 67 is the interesting part but its pretty opaque
12:50:21 <Heffalump> pie_: it looks to me like $(ASTContext astcontext) was supposed to be an antiquotation, but it didn't happen
12:51:44 <pie_> huh
12:52:05 <Heffalump> did you write the code?
12:52:15 <pie_> well that would make sense given what the c errors look like
12:52:22 <pie_> yeah i did somethgn wrong somewhere then
12:52:34 <pie_> howd you figure the antiquotation is bad from that output
12:52:41 <Heffalump> because I was expecting it to have gone
12:52:49 <Heffalump> and it's still there in what looks like the C code
12:53:08 <Heffalump> mind you, the $(char* cs) is still there too
12:53:35 <Heffalump> so I'm really just guessing randomly
12:53:43 <pie_> the test function worked tough
12:53:44 <pie_> *though
12:53:48 <pie_> hm
12:53:52 <pie_> well maybe not in this iteration
12:53:53 <pie_> lets see
12:54:49 <pie_> Heffalump: the test function works fine
12:55:22 <aveltras> any servant expert here ? i'd like to have the "myLink" function working for arbitrary endpoint types, right now it works only with endpoints which don't need any argument, as soon as endpoint needs one (Capture.., etc), the types don't align. I think it's possible to have it working using the MkLink associated types and all, but cant make it work myself..
12:55:28 <aveltras> https://www.irccloud.com/pastebin/FPVLORLW/
12:55:43 <Heffalump> pie_: I'm out of ideas really.
12:55:46 <pie_> mh
12:55:57 <aveltras> the goal being to have arbitrarily nested apis and dont have to mention the specific links record for the nested api
12:55:59 <pie_> sooo close dammit xD
12:58:11 <pie_> Heffalump: uh
12:58:12 <pie_> oh wow
12:58:19 <pie_> i think i renamed it from hsc to hs and it worked?
12:58:49 <Heffalump> hmm, ok. Maybe the pre-processor was getting confused and this isn't supposed to be run through hsc2hs..
12:59:05 <pie_> no wait i think its still against the code i just disabled
12:59:08 <pie_> hold on???
13:00:20 <pie_> ok this is real weird
13:01:00 <pie_> i renamed it because this is named .hs https://github.com/fpco/inline-c/blob/master/inline-c-cpp/test/tests.hs
13:01:17 <pie_> Heffalump: ok after clearing my dist directory its broken again
13:05:26 <pie_> i guess i can try just stracing everythin
13:06:51 <bolti> Hi, I'm learning haskell, I'm reading Real World haskell, it's ok? or it's outdated?
13:07:18 <pie_> actually this strace might not be that great
13:08:50 <bolti> what source or book do you recommend?
13:14:53 <pie_> the other reason its gotta be a C problem is that the haskell typechecks and it would complain otherwise...
13:16:28 <pie_> ...its at least somewhat a haskell problem because i added cpp block comments and i still get the error...
13:17:58 <tdammers> bolti: it's a great book, though horribly out of date. there is an ongoing effort to edit it to align with "modern" haskell, but I'm not sure how far that has gotten
13:18:01 <Welkin> I'm trying to set up doom emacs with either dante or lsp. It looks like dante relies on ghc-mod, which is deprecated, so I should use lsp. It gets more confusing though, since there is ghcide and haskell-language-server.
13:18:13 <Welkin> I just want to know: how do I use LSP with haskell in emacs?
13:18:14 <tdammers> bolti: the canonical resource people recommend these days is https://haskellbook.com/
13:18:40 <Welkin> the instructions are a giant mess, sadly
13:19:01 <bolti> thanks!
13:19:10 <Welkin> also, I do not want stack at all, even though the instructions here https://github.com/hlissner/doom-emacs/tree/develop/modules/lang/haskell say stack is required for LSP (I think that is wrong)
13:20:39 <Welkin> bolti: haskellbook.com has some really bad/outdated advice like using stack. Just use cabal to avoid trouble
13:21:29 <maerwald> :D
13:21:38 <bolti> it's my first time using a irc client, how do you reply my messages? 
13:21:50 <wavemode> using stack is not bad or outdated...
13:22:08 <Heffalump> Welkin: ghcide is released and stable, as is hie. haskell-language-server is a unification project that is pretty usable, but not yet on hackage.
13:22:28 <mmaruseacph2> Welkin: stack is not outdated and definitely not bad
13:22:36 <mmaruseacph2> but let's not bring the war up again
13:22:37 <Welkin> wavemode: I was here before stack, and I am here after stack. It came and went and outlived its usefulness
13:22:44 <mmaruseacph2> it's still around
13:22:48 <Welkin> it's also a political thing
13:23:11 <maerwald> The ideas were great, the implementation not so much
13:23:21 <mmaruseacph2> possible
13:23:39 <Welkin> Heffalump: so I just want to know: What do I do to get LSP working with haskell in emacs?
13:23:46 <Heffalump> I'm not really sure what stack offers nowadays that you couldn't get from stackage serving up cabal freeze files
13:23:50 <Welkin> This is a sore point right now (as is common in haskell)
13:24:03 <maerwald> more stable hackage subset: yes. Easier installation of ghc: yes. Nix-style sharing of installed libraries: yes.
13:24:26 <maerwald> but now you get all of that without it
13:24:47 <Heffalump> Welkin: LSP is just a protocol, so the question is what messages do you want to come over LSP? :-) I can recommend ghcide for straightforward and fairly lightweight integration of ghc compiler errors/warnings.
13:25:22 <Heffalump> hie is more fully-featured but heavier-weight, and haskell-language-server is a step on from ghcide but experimental in a sense (e.g. not on hackage)
13:25:41 <Welkin> the biggest gripe with stack is the political bullshit. The creators/group tried to split this community in two by creating a new website, trying to pretend they were the "official" authority on haskell, and tried to push newcomers to their own custom package manager and repository (stackage).
13:26:23 <Heffalump> maerwald: are you referring to stack or cabal when you say nix-style sharing? AFAIK stack doesn't do any kind of nix-style sharing.
13:26:24 <Welkin> Heffalump: I just want it to work with doom emacs https://github.com/hlissner/doom-emacs/tree/develop/modules/lang/haskell
13:26:41 <maerwald> Heffalump: it shares between repos, does it not
13:26:50 <wavemode> bolti: the caveat I would apply to the First Principles book is that it's extremely long and kind of dry. So I recommend stepping away from it regularly and just practice exploring the haskell ecosystem and making things
13:26:53 <dsal> stack is fine.  I've not tried building a project without it, though.  I guess I should figure out how much harder life is without it.
13:27:12 <Heffalump> maerwald: yes, but not using strong hashes to share subgraphs of otherwise different build sets
13:27:23 <maerwald> right
13:27:24 <Welkin> dsal: it's not. Just `cabal v2-build`
13:27:28 <maerwald> so cabal is in fact more reliable
13:27:47 <dsal> Welkin: How does that create a new project?  Does it have my dependencies in order?  Is my test skeleton ready?
13:28:00 <Welkin> dsal: yes. `cabal init -i`
13:28:11 <maerwald> or use summoner
13:28:30 <dsal> cabal: unrecognized 'init' option `-i'
13:28:37 <Heffalump> Welkin: I'd go with ghcide personally.
13:28:37 <Welkin> do you have cabal 3.0.0?
13:28:52 <dsal> I guess not.  This isn't off to a good start...
13:29:05 <maerwald> Heffalump: yeah, but very few features
13:29:11 <Welkin> you are using a severely outdated cabal
13:29:23 <maerwald> you shoulde use 3.2.0.0 by now
13:29:42 <Heffalump> maerwald: if you mean ghcide, yes. But pretty solid.
13:29:50 <maerwald> Heffalump: and all this cradle file stuff is annoying me
13:30:20 <maerwald> So I end up disabling it and just go back to ghci.
13:30:45 <Heffalump> maerwald: does hie not need cradles? I haven't used it. But I think the cradles are there for good reason until auto-configuration is better.
13:30:49 <Heffalump> not even ghcid? :-)
13:30:50 <maerwald> with keybindings to search hoogle based on identifiers in my editor
13:30:54 <maerwald> ghcid? no
13:31:12 <maerwald> I had problems configuring it properly, because the parser is weird
13:31:24 <Heffalump> ghcid was an amazing productivity jump for me over ghci, just being able to hit save in my editor to see errors made a huge difference.
13:31:33 <Welkin> I'm installing ghcide
13:31:36 <Welkin> we'll see how that goes
13:31:55 <Welkin> java and javascript/typescript work amazingly well with lsp
13:31:58 <maerwald> Heffalump: I disciplined myself over that. I don't do regular type checking anymore. I code for 10+ minutes before I reload in ghci.
13:32:22 * dsal tries to figure out how to even get a modern cabal other than asking stack to install it
13:32:29 <maerwald> And then when the problems start, I fix all the type errors, reload again. So it is infrequent.
13:32:32 <Heffalump> maerwald: I spend approximately half my coding time doing type-driven refactoring :-)
13:32:41 <merijn> dsal: You can either just download the binary or clone the repo and run the install script
13:32:45 <maerwald> I found it makes myself more blind to my own code.
13:32:49 <Welkin> I've gotten so used to prettier and elm-format, too
13:33:02 <maerwald> If I can't figure out what my code is doing without the type checker... then it's too complicated.
13:33:02 <Welkin> I haven't used brittany or any other haskell auto-formatter yet
13:33:15 <merijn> dsal: Or even "cabal install cabal-install"
13:33:21 <dsal> Oh there it goes.   `nix-env -q` didn't find it.
13:33:21 <Heffalump> I _could_ figure it out, I just don't want to.
13:33:30 <merijn> Auto-formatters are the devil anyway!
13:33:45 <Welkin> dsal: see, that is problem number one: with stack, you are a slave to stack, because it locks you into its ecosystem
13:33:55 <Welkin> break free!
13:34:08 <dsal> With stack, I have tools that work.   It doesn't feel that slavey.
13:35:03 <maerwald> dsal: you can manage ghc and cabal with ghcup or use hvr's ppa if you're on ubuntu or download it manually
13:35:04 <merijn> What part of cabal-install is broken, exactly?
13:36:58 <Welkin> ghup is great
13:37:12 <Welkin> I used to manually install ghc or use haskell-platform
13:37:41 <Heffalump> ghcup is great if you don't use nixos
13:38:05 <Heffalump> and chocolatey is nice on Windows (for all it's rightly drawing criticism now that it's the _only_ recommended way)
13:38:14 <[exa]> I got a bit upset when ghcup became a binary blob, to find out that manual ghc installation is so straightforward that ghcup doesn't really pay off
13:38:51 <maerwald> [exa]: well, other people were upset that it was a 2000 LOC posix sh script. Can't please everyone :)
13:39:01 <dsal> OK, so now I have a directory with a couple files in it.  How do I get a better starting point?  I have some language extensions I enable by default, some test libraries I want to use and have ready (with the starting point in place).  Also, how do I get this using hpack so I don't have to edit this file every time I make or move a file?
13:39:25 <maerwald> And I personally was more scared of the shell code.
13:39:59 <merijn> [exa]: Yeah, GHC bindist for life ;)
13:40:14 <[exa]> maerwald: you don't need to disassembly shell code to see what it does :]
13:40:23 <dmj`> did unboxed sums make it into ghc 8.6
13:40:34 <maerwald> [exa]: then you're not aware of all the weird bugs that were caused due to shell differences
13:40:54 <glguy> Yeah, you also can't really open a shell script up to know what it does
13:41:01 <[exa]> maerwald: worry not, I spent 8 years with m4
13:41:12 <merijn> dmj`: According to google they were in 8.2 already :p
13:41:31 <dmj`> merijn: well I'll be
13:41:40 <merijn> dmj`: https://gitlab.haskell.org/ghc/ghc/-/wikis/unpacked-sum-types
13:42:10 <dmj`> do they really make a difference
13:42:20 <merijn> No clue :p
13:43:32 <maerwald> [exa]: what does 'mktemp -d' do? :)
13:44:10 <[exa]> maerwald: honestly, platform dependency
13:44:38 <maerwald> how to do "realpath" portably? (It's not in the posix standard)
13:44:55 <dsal> I don't see how the cabal stuff would improve my life over stack.  AFAICT, it might use less space, but strictly increases the work I have to do. 
13:45:10 <maerwald> what does "make" do?
13:45:19 <maerwald> shell is a mess
13:46:45 <[exa]> maerwald: realpath: you're not even supposed to know if your directory is accessible by the absolute path. make: some precise make commands have the prefix (gmake, bmake) and well-described behavior in that case
13:47:11 <maerwald> yeah: Unknown command: gmake
13:47:13 <merijn> dsal: tbh, intended or not, your comments come off as rather antagonistic, which doesn't really make me (and presumably) others feel like it's worth the bother to help/comment. And if you don't want to use cabal, well, then don't? I'm not sure what the point of complaining here is?
13:48:00 <maerwald> and resolving symlinks without realpath is fun
13:48:20 <[exa]> maerwald: anyway the posix standard is pretty usable, but you need the bag of tricks that allow you not to assume anything
13:48:44 <dsal> merijn: I understand.  The argument was that stack is obsolete and we should just use cabal.  So I'm asking how.  I installed a new cabal and recent ghc so I could try it out and it seems to only increase the amount of work I have to do.  So I assume I'm missing something.
13:48:44 <maerwald> yes and that makes your shell code horribly complicated and impossible to understand by just looking at it
13:49:03 <maerwald> it's a minefield of edge cases and hidden knowledge
13:49:05 <dsal> I don't have a dog in the cabal/stack fight.  I've been using stack and am open to just using cabal as long as it doesn't increase my work a lot.
13:49:21 <[exa]> maerwald: shell comments are portable :]
13:49:41 <maerwald> I comment my shell code, but I don't know what half of it does anymore.
13:50:05 <maerwald> Feel free to maintain the old ghcup shell script, if you really like pain.
13:51:33 <sclv> i do have a dog. his name is sandy, and he likes to fetch
13:51:55 <merijn> dsal: "define increase your work", I mean, installing cabal doesn't count, you have to install stack before using it too. You don't want to "constantly rename modules when you move them", ok that's extra work, but honestly how often do you move modules that this is an issue? Hpack has a number of problems, to the point that even Snoyberg doesn't recommend entirely relying on hpack when using stack anymore
13:52:01 <merijn> sclv: Pics or it didn't happen
13:52:09 <sclv> he doesn’t like to fight tho
13:53:21 <koz_> merijn: Yeah, that led to a hilarious bit of fail with our work codebase when Stack suddenly got opinionated about it.
13:53:40 <[exa]> maerwald: well that's the point, I believe it's better to just write a decent how-to on running ./configure --prefix=... --bindir=...
13:54:08 <maerwald> [exa]: that still lacks half of the things ghcup does, but yes, that's a perfectly fine use case
13:54:18 <merijn> tbh, there's a number of technical and subjective reasons why hpack is a terrible idea
13:54:36 <Welkin> ghcide is disappointing too
13:54:42 <Welkin> I just can't get this thing to work
13:54:53 <Welkin> xref is busted. It can't find references even in the same file!
13:55:13 <Welkin> and it gives me an error about a library not existing, even though compiling it with cabal works fine
13:55:27 <dsal> merijn: I'm not counting the initial install.  In stack, I have a starting point that's got the things I'm likely to need in my project (test frameworks, language extensions, etc...).  The cost of starting a project is low for me currently, so I did like, two or three last week while oncall.  Part of having a new project is creating modules regularly.
13:55:45 * hackage hextream 0.2.0.0 - Streaming-friendly XML parsers  https://hackage.haskell.org/package/hextream-0.2.0.0 (koral)
13:55:50 <tdammers> IMO the main raison-d'etre for ghcide is to drive forward the development of a more formalized, controlled ghc api
13:55:54 <merijn> dsal: I dunno, I just run "cabal init" and add things as I need them...
13:56:02 <dsal> If I could get my editor to do the magic of writing it into the cabal file, that'd probably be fine.  I don't like working in the .cabal format that much, and having to do it on any rename or creation is kind of a pain.
13:56:31 <maerwald> dsal: yes, that's fair. cabal file format is over-complicated imo. Would have been nicer if it was toml or something simple
13:56:43 <merijn> maerwald: Still better than YAML :p
13:56:49 <maerwald> yes, hence toml
13:57:34 <Welkin> tdammers: now I'm spoiled by lsp for java and typescript from using them at work (because it is impossible to work in a multi-million line codebase without all the fancy features)
13:57:47 <maerwald> it is basically impossible to parse a cabal file, add fields programmatically and output it in the same formatting + the new fields
13:58:06 <maerwald> at least impossible with Cabal API
13:58:09 <sclv> i wish it wasn’t
13:58:40 <Welkin> so I want my autoformatting, syntax checking, type errors, and everything in the editor, as well as code navigation of course
13:58:46 <maerwald> with toml, this would be really trivial
13:58:57 <dsal> `cabal init -i` without "sensible defaults" lets me get a little closer.  But is there a way to just give it a default template?  Or do I just create a "default template" project and try to keep it in sync with cabal?
13:59:14 <maerwald> dsal: have you checked summoner?
13:59:25 <dsal> I looked at it a long time ago.  I'll give it another shot.
13:59:55 <merijn> dsal: tbh, I just copy an existing cabal file from one of my other projects and edit that
13:59:57 <dsal> I guess it didn't make much sense to me as a stack interface since 'stack new x' already builds the exact tree I want to start with (with a custom template)
14:00:10 <dsal> merijn: That's not completely unreasonable.
14:01:20 <dsal>  So the three things I get from stack are:   1) default project config  2) hpack keeping up with my modules  3) a named version of various library versions (LTS)
14:01:51 <dsal> Does cabal have an equivalent of   `stack test --file-watch` ?
14:01:56 <merijn> dsal: The 3rd is just a single "cabal freeze" away
14:02:14 <merijn> dsal: Which generates a freeze files that pins to the versions you have locally right now
14:02:15 <monochrom> cabal doesn't. But ghcid does.
14:02:47 <dsal> OK.  I'm going to try de-stacking one of my projects.  Maybe the new one I'm working on right now and am excited about.
14:03:04 <Welkin> https://github.com/kowainik/summoner is pretty cool
14:03:07 <Welkin> love the TUI
14:03:44 <dsal> Last time I tried it, it seemed like it might be good for making a template one time or something, but I wouldn't want to go through that every time I start a project.
14:04:29 <aveltras> could someone help me with the following (at least tell me if what i want to achieve is even possible so that i stop banging my head against thuis), i'd like to be able to generate links (using myLink function here) given an arbitrarily nested servant generic endpoint. This works for endpoint with arguments but not for those with some, here's the code
14:04:33 <aveltras> https://www.irccloud.com/pastebin/0E5ltpt5/
14:05:50 <aveltras> without*
14:06:18 <Welkin> aveltras: ask in #haskell-servant
14:06:33 <Welkin> servant can be... a bitch, when it comes to types
14:08:01 <aveltras> Welkin: ok i'll ask there, thx
14:10:39 <Heffalump> Welkin: what went wrong? (with ghcide) I might be able to help with basic things.
14:12:56 <Welkin> for some reason, xref doesn't work
14:13:06 <Welkin> I even geenrated the TAGS file myself using hasktags
14:13:19 <Welkin> I cannot jump to definition because it says it wasn't found
14:13:26 <Heffalump> oh, I don't use find references, not sure if that's expected to work. Jump to definition should work.
14:13:32 <Welkin> it looks like it generated the TAGS itself on startup, too
14:13:55 <Heffalump> can you try running ghcide directly in the root of your project and see if it complains about anything?
14:14:06 <Welkin> "Unable to find symbol in current document"
14:14:18 <Welkin> how should I do that? Just `ghcide`?
14:14:50 <Heffalump> yep
14:14:51 <Welkin> I get a bunch of errors
14:14:54 <Welkin> what is cradle?
14:14:58 <Heffalump> did you make a hie.yaml file?
14:15:24 <Welkin> Could not find module ‘Graphics.Vty’ It is not a module in the current program, or in any known package.
14:15:27 <Welkin> nope
14:15:41 <merijn> Welkin: And no .ghc.environment?
14:15:48 <Welkin> this is an old project I just converted to use ghc 8.8. Previously was 8.4 I think
14:16:10 <dsal> I just found a fourth thing stack does that makes it hard to migrate this project...  4) I can reference unreleased / newer versions of packages on github.  Do I have to publish a version of a dependency to get it to work elsewhere?
14:16:10 <Heffalump> I guess from the above you normally use cabal for your project? Try making a hie.yaml file containing "cradle: {cabal: {component: "exe:cashflow"}}" but replacing exe:cashflow with your component name
14:16:31 <Heffalump> dsal: AFAIK you can use cabal.project to do it
14:17:00 <Welkin> yes, cabal.project should work. I think I've used that before to reference local repos and github repos
14:17:11 <dcoutts> yup, I use it _all_ the time
14:17:15 * hackage opentelemetry 0.4.0 -   https://hackage.haskell.org/package/opentelemetry-0.4.0 (DmitryIvanov)
14:17:19 <dsal> This doesn't give me a cabal.project...  Can someone show me an example?
14:17:36 <maerwald> dsal: check the cabal repo
14:17:38 <maerwald> haha
14:17:54 <Welkin> this is hilarious. My old project has a cabal.sandox.config
14:18:15 * hackage opentelemetry-wai 0.4.0, opentelemetry-lightstep 0.4.0, opentelemetry-extra 0.4.0 (DmitryIvanov)
14:18:28 <dcoutts> dsal: here's an example:
14:18:28 <dcoutts> source-repository-package
14:18:29 <dcoutts>   type: git
14:18:29 <dcoutts>   location: https://github.com/well-typed/cborg.git
14:18:29 <dcoutts>   tag: 42a83192749774268337258f4f94c97584b80ca6
14:18:29 <dcoutts>   subdir: cborg
14:18:41 <dsal> Oh cool, thanks.
14:18:50 <Welkin> Heffalump: that gave me another error
14:18:57 <maerwald> and unlike stack, it takes any git reference as tag, doesn't it?
14:19:11 <Heffalump> Welkin: does it seem less fatal?
14:19:20 <Welkin> exe:roguelike-vty (unknown-component)
14:19:22 <dcoutts> it also supports darcs (yay!), svn etc
14:19:29 <dcoutts> maerwald: yes, branch names, tags
14:19:34 <Heffalump> Welkin: hmm, try without the exe:
14:19:38 <maerwald> stack now only accepts full sha1 hashes
14:19:42 <maerwald> not even short hashes
14:19:43 <Heffalump> I get confused repeatedly by cabal component names
14:29:09 <wildtrees[m]> so cabl install polynomial fails for 8.6.5 , it lasts seems to have worked with 8.2.2 and was released like in 2017, so what is something for doing some basic operations with polynomials in 8.6.5 ? need like addition, subtraction, multiplication and division+remainder 
14:31:14 <Welkin> Heffalump: I get a new error now
14:31:32 <Welkin> I wonder if I should just start a new cabal project since this is so old, and copy the src folder over
14:32:28 <Heffalump> Welkin: if it builds with cabal it ought to work with ghcide.
14:32:32 <Heffalump> what's your new error?
14:34:17 <Welkin> I got it working
14:34:21 <Welkin> I had the name wrong, haha
14:34:28 <Heffalump> :-)
14:34:31 <Welkin> it was `roguelike`, not `roguelike-vty`
14:34:47 <Welkin>   Could not load module ‘Distribution.Simple’
14:34:47 <Welkin>   It is a member of the hidden package ‘Cabal-3.0.1.0’.
14:34:47 <Welkin>   Perhaps you need to add ‘Cabal’ to the build-depends in your .cabal file.
14:35:07 <Heffalump> sorry, is it fixed or not?
14:35:09 <pie_> Heffalump: 
14:35:10 <pie_> ok progress
14:35:10 <pie_>  cabal repl --repl-options="-fobject-code" --repl-options="-O0" --repl-options="-optc=-v" --repl-options=-keep-tmp-files
14:35:10 <pie_> -v to the compile showd some clang output whch gave the source file path
14:35:10 <pie_> keep tmp kept it after finishing
14:35:12 <pie_> afraid it wouldnt show any output and then more yak shave
14:35:14 <pie_> its actually close to the output of whatever the show splice command was
14:35:16 <pie_> but i didnt see the args in the splicey
14:35:46 <pie_> https://bpa.st/TF2A
14:36:01 <Welkin> it's not quite fixed
14:36:04 <Welkin> I get this one error
14:36:43 <Heffalump> Welkin: does cabal v2-build work (from clean, e.g. blowing away dist-newstyle)?
14:37:22 <pie_> #include "clang/AST/ASTContext.h"
14:37:23 <pie_> char * inline_c_Language_C_Clang_Internal_Matcher_1(char * cs_inline_c_0, ASTContext * astcontext_inline_c_1) { 
14:37:23 <pie_> who knows why that doesnt work...
14:37:44 <Welkin> yes
14:37:47 <Heffalump> pie_: that causes the ASTContext not declared error?
14:38:00 <Heffalump> if so check whether ASTContext is actually declared, e.g. in that header file
14:38:06 <Welkin> ghcide is failing on the Setup.hs file
14:38:17 <Welkin> which I've never used or touched in my 7 years of haskell
14:38:17 <Heffalump> Welkin: oh, ok. You can just ignore that.
14:38:32 <Heffalump> in fact if you have build-type: Simple or whatever it is you can just delete that
14:38:41 <Heffalump> delete Setup.hs that is
14:38:51 <Welkin> where is build-type? in the .cabal?
14:39:07 <Heffalump> yes (I might have misremembered the exact name)
14:40:20 <Welkin> nice, that worked
14:42:41 <Welkin> well the errors disappeared in emacs
14:42:45 <Welkin> but xref still fails
14:43:01 <Heffalump> you mean you still can't jump to definition?
14:43:07 <Welkin> nope
14:43:19 <Heffalump> is anything using CPU, like ghcide?
14:43:46 <Welkin> it is using 0 cpu
14:43:51 <Welkin> almost 800 mb of memory
14:43:57 <Heffalump> I'm out of ideas then :-/
14:44:18 <Welkin> I generate tags using the generate haskell tags function and regenerate projectile tags function. Neither seem to fix it
14:44:40 <Heffalump> I don't use emacs with ghcide, I use vscode
14:44:48 <Heffalump> but presumably if the LSP stuff works it ought to be fine
14:46:49 <maerwald> Heffalump: you must have a lot of ram to spare
14:47:02 <Heffalump> maerwald: 32GB :-)
14:47:11 <maerwald> right, vscode with 16 gig doesn't work
14:47:16 <Heffalump> but ghcide is the thing that eats the RAM on my machine, not vscode
14:48:07 <Cale> dcoutts, Heffalump: good to see you both :D
14:48:09 <Welkin> I have 8 gb on this machine
14:48:14 <Welkin> 64 gb on my desktop
14:48:18 <Heffalump> hi Cale :-)
14:48:20 <Welkin> hello Cale!
14:48:28 <Cale> Hello!
14:52:28 <maerwald> Welkin: 8gb is unbearable. With firefox and a cabal repl, I'm stuck at 90% ram use
14:52:47 <maerwald> These days it seems programmers don't care much about wasting your resources :P
14:52:50 <Welkin> I can end up using a few gb of swap, sure
14:53:02 <Welkin> I may upgrade to a new macbook with 16 gb of ram
14:53:08 <Welkin> and the new keyboard
14:53:12 <maerwald> but then... you have a mac
14:53:18 <Welkin> my imac has 64 gb of ram which feels amazing
14:53:27 <Welkin> I can upgrade it to 128 if needed :P
14:53:48 <Welkin> Heffalump: this issue seems relevant https://github.com/hlissner/doom-emacs/issues/2839
14:54:27 <Heffalump> Welkin: fair enough. I only know ghcide, not dante or emacs.
14:57:55 <Welkin> I think it's a setup problem
14:58:06 <Welkin> manually invoking xref-find-definitions works
14:58:19 <Welkin> I can file a bug with doom-emacs
15:06:51 <pie_> Heffalump: ifigured some stuff out meanwhile
15:07:52 <pie_> `oh you know what, i think i justunderstood something, note thecontentof the function body,using declarations all go in the body,the problem is in the parametersbefore it, ...theres a CPP.using function`
15:08:09 <pie_> and yep that seems to be the solution
15:08:31 <pie_> add a CPP.using "namespace clang"
15:13:03 <pie_> wooo it compiled \o/ time to crash it since the c code is just some copy pasted stuff right now
15:42:15 * hackage haskoin-store-data 0.27.0 - Data for Haskoin Store  https://hackage.haskell.org/package/haskoin-store-data-0.27.0 (jprupp)
15:43:15 * hackage haskoin-store 0.27.0 - Storage and index for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-store-0.27.0 (jprupp)
15:51:59 <dsal> My cabal build of my project failed for the same reason my stack ones have been failing -- lack of -lz
15:52:25 <dmwit> Have you considered installing libz?
15:52:39 <dmwit> I know this sounds stupid, but... it's just crazy enough that it might work.
15:53:16 <pong> isn't zlib installed by default almost everywhere?
15:53:24 <dmwit> Very yes.
15:53:59 <dsal> Even when I install zlib, it fails on my machines unless I specifically add it to the nix section of stack.yaml.
15:54:15 <dsal> I'm trying to find the equivalent in cabal
15:54:29 <dmwit> extra-lib-dirs, probably
15:54:36 <dmwit> A flag for configure
15:54:45 <dmwit> Well. A flag for whatever ails you, these days.
15:54:46 <dsal> But in short:  no, that didn't work.  Installing zlib didn't make my builds work, but adding it to stack.yaml did.
15:56:59 <dsal> It seems like a hole in some tool somewhere since libz manages to be a dependency of anything I touch, but I have to declare it in all of my projects.  I don't know whose tool is broken here.  I think I found a bug about it somewhere.
15:58:17 <dmwit> I'd blame your /etc/ld.so.conf
15:59:48 <dsal> This happens on both my mac and linux machines.   Has something to do with nix.
16:24:15 <wildtrees[m]> dsal, I have found and heard that using zlib with haskell on nix is broken for some use cases or a real pain 
16:24:53 <dsal> I'm not even directly using it.  It's just pretty much a dependency everywhere.  Seems like something someone should fix.
16:25:47 <wildtrees[m]> I had it go away using cabal2nix in general for my haskell projects on nix 
17:07:15 * hackage list-tries 0.6.7 - Tries and Patricia tries: finite sets and maps for list keys  https://hackage.haskell.org/package/list-tries-0.6.7 (arybczak)
17:08:43 <Welkin> why is `M-.` bound to `haskell-jump-to-definition` in haskell-mode? It totally breaks any other integrations that do that
17:08:54 <Welkin> it just errors out every time now
17:11:47 <jackdk> yeah for some reason I've never been able to get zlib from an external environment, but if it's wired in through cabal2nix or in a hakellPackages.ghcWithPackages env it seems to work ok
17:12:15 * hackage calamity 0.1.6.2 - A library for writing discord bots  https://hackage.haskell.org/package/calamity-0.1.6.2 (nitros12)
17:35:36 <Welkin> I had to unset the keybinding to get it working
17:35:42 <Welkin> haskell-mode is pretty crufty
17:37:36 <dsal> M-. means "go to thing"  -- why would it be different in haskell?
17:39:23 <Welkin> it has its own custom function that tries to be smart, but it sucks
17:39:27 <Welkin> it was added 6 years ago
17:41:54 <Welkin> https://github.com/haskell/haskell-mode/blob/27c1309db3c25c41bf7633c8e5046a74a5407f9d/haskell-commands.el#L366
17:56:43 <monochrom> I am fine with haskell-mode doing its own goto-definition. I like it that way.
17:58:12 <monochrom> The reason it does this is because it calls ghci to do the real work. It cannot be a "standard emacs tags-based thing".
17:58:59 <monochrom> And yes I would rather not get ctags tags etc involved.
17:59:56 <monochrom> However, this is all mood. 90% of "why does X do it the Y way?" are really rhetorical questions expressing "to hell with X doing it the Y way".
18:00:16 <monochrom> "My way or rhetorical question like I care"
18:00:26 <monochrom> s/mood/moot/
18:01:06 <monochrom> Why the hell do people ask rhetorical questions anyway?
18:01:22 <monochrom> "plausible deniability"
18:05:43 <monochrom> Oh interesting, haskell-mode-jump-to-def-or-tag allows xref-pop-marker-stack to return to where I was.
18:05:53 * monochrom was using haskell-mode-goto-loc previously
18:07:29 <monochrom> Ah I remember why I chose haskell-mode-goto-loc.  It can jump to local defs too.
18:09:47 <Welkin> well I use lsp-mode and doom-emacs, which have a very nice integration
18:09:59 <Welkin> so I had to unbind haskell-mode's version
18:10:58 <monochrom> Then perhaps don't add haskell-mode into the mix.  I don't think haskell-mode has "integration" in mind.
18:11:28 <Welkin> it is the only haskell syntax highlighting mode
18:23:31 <heatsink> I've been using lsp-mode and it leaks open files so that emacs stops working after a while
18:31:08 <Welkin> I haven't noticed that
18:31:38 <Welkin> I've run emacs as a daemon for months with 40 or more buffers open without issue
18:35:49 <slack1256> I don't understand express existential types via universal encoding. I read about double negation enconding but this to me doesn't make sense. As ~~(exists a. P a) = ~(forall a. ~(P a)) = ~(forall a. (P a -> Void)) = (exists a. ~(P a -> Void)) = (exists a. (P a -> Void) -> Void) = (exists a. forall r. (P a -> r) -> r) . Notice the last forall, how do I deal with that?.
18:36:12 <slack1256> I don't understand /how to/ express
18:36:44 <monochrom> Instead, consider "(exists n. p n) implies q" and "forall n. p n implies q"
18:36:45 * hackage calamity 0.1.7.0 - A library for writing discord bots  https://hackage.haskell.org/package/calamity-0.1.7.0 (nitros12)
18:37:22 <slack1256> monochrom: Right, as in a type constructor. Let me see.
18:38:01 <monochrom> If necessary, start with 2-ary.  "(p 0 or p 1) implies q" = "(p 0 implies q) and (p 1 implies q)"
18:39:33 <monochrom> You don't need double negation. The equivalence holds in intuitionistic logic too.  Consider in natural deduction the elimination rule for "or" and "exists".  The "or" version: prove "p 0 implies q", and prove "p 1 implies q", then you can conclude "(p 0 or p 1) implies q".
18:42:18 <slack1256> When done via natural deduction, seeing the existential as a generalized sum type I can prove the isomorphism.
18:43:29 <slack1256> But I saw the claims on blogpost that it could be done via a double negation. But when I apply the double negation as I would do on a 1-order logic on set theory, I don't get the result they claim.
18:44:46 <jmcarthur> I think for me this is the most straightforward way, but I don't think the individual steps are necessarily immediately obvious:  (exists n. p n)  =  (forall r. ((exists n. p n) -> r) -> r)  =  (forall r. (forall n. p n -> r) -> r)
18:47:30 <jmcarthur> The first step is basically the double negation
18:47:44 <slack1256> jmcarthur: You're are a genius!
18:48:38 <slack1256> (exists n. p n) = (forall n. p n -> r) on that subterm.
18:48:42 <monochrom> Yeah, ((forall a. P a) -> Void) -> Void
18:50:00 <monochrom> err, nevermind
18:51:08 <jmcarthur> Another way to see the first step is Yoneda Identity
18:52:46 <slack1256> jmcarthur: Yeah, that is the basically the isomorphism made explicit.
18:53:05 <slack1256> I was just bothered as I could prove it along other methods but not this "obvious" one.
18:54:20 <slack1256> Thank you jmcarthur, monochrom.
18:54:57 <jmcarthur> As a non-mathematician, I'm impressed by anybody that can do it more than one way. :)
18:58:25 <slack1256> Last night I started to implement Cont by myself. When doing callCC I ended learning haskell type system correspond to a second order /propositional/ (not predicative) logic. That is that terms can depend on types (polymorphism), types can depend on types (type constructors/ introduciton rules) but no types that depend on term (dependent types). Somehow that led me to try to understand most of the basic stuff of Curry-horward but I just c
18:58:26 <slack1256> ould do this basic (forward) double negation.
19:33:24 <fresheyeball> hey out there
19:33:29 <fresheyeball> I am in a time pickle
19:33:47 <fresheyeball> I have a string such as "america/denver"
19:33:55 <fresheyeball> which is from IANA
19:34:12 <fresheyeball> and a CTime (seconds since 1970)
19:34:32 <fresheyeball> how can I my string as a timelocal?
19:34:39 <fresheyeball> so I can format my CTime
19:34:59 <fresheyeball> TimeLocale <- this I mean 
19:43:45 * hackage monadic-recursion-schemes 0.1.2.0 - Recursion Schemes for Monadic version.  https://hackage.haskell.org/package/monadic-recursion-schemes-0.1.2.0 (KatsutoshiItoh)
19:51:27 <hololeap> fresheyeball: it looks like you just need to add a new TimeZone to the knownTimeZones field of TimeLocale
20:19:55 <poliquin> I'm stumped ... I'm trying to learn about TypeClasses. I wrote my own Functor class. I tried to write a default fmap method .. It won't compile.
20:20:11 <poliquin> Any help greatly appreciated ... Here's the code ...   http://vps.faroth.com/Main.hs
20:20:28 <poliquin> Looks like I can't pattern match in a default class method?
20:20:39 <poliquin> Are default class methods bad?
20:20:59 <poliquin> I love Haskell but sometimes it's hard :-(
20:23:12 <poliquin> I must be missing a basic concept.
20:25:44 <int-e> poliquin: what's h supposed to be?
20:26:51 <int-e> Haskell can't pattern match on an unknown data constructor.
20:27:28 <wavemode> yeah that "g (h j)" is not legal
20:27:32 <int-e> In other words, you cannot abstract from patterns.
20:28:01 <wavemode> more generally, there is no meaningful default implementation of fmap
20:28:23 <wavemode> the user has to define their own
20:28:36 <poliquin> h is the functor instance (i.e. Box .. or other instances)
20:29:27 <EvanR> wavemode: DeriveFunctor disagrees ;)
20:29:40 <poliquin> Ok .. fmap has no meaningful default implementation but Eq does have a couple ..
20:30:01 <poliquin> Why is that different .. ??
20:30:06 <int-e> Yes, Functor has compiler support. We also have generics which help.
20:30:41 <int-e> poliquin: It's no different... Eq defines (==) in terms of (/=) and (/=) in terms of (==), and a user still has to define one of them to get the other one.
20:31:45 <poliquin> Hmmmm .. So there is actually no default method in Eq .. ?
20:32:23 <int-e> The equivalent for  fmapB  would be something like  fmapB = (<$$>) and (<$$>) = fmapB (btw, there's really no point in having two identical functions in the class)
20:32:38 <poliquin> Does any class have a default method .. 
20:33:13 <poliquin> Agreed no point in having two identical functions in the class ... I was just experimenting
20:33:36 <EvanR> the class system really doesn't play nice with default implementations
20:33:56 <int-e> Eq /could/ have  a == b = compare a b == EQ, for types that also provide Ord.
20:34:43 <poliquin> Ah .. This is my basic problem ... I won't use them.
20:35:35 <wavemode> poliquin: Your attempt to make a generalized fmap with (h j) is understandable, but think about it. Not every type which could be a Functor is a `data` that could be deconstructed like that. IO is a Functor. [a] is a Functor. Even (a -> b) is a Functor.
20:36:46 <poliquin> Ah ... That makes some sense if it's not generalized for every type. ... Ok, Ok, .. I'll avoid default methods :-)
20:37:27 <poliquin> Thanks everyone for the help ... I feel better now. 
20:37:29 <EvanR> default implementation indications you might want to override, and you can't override either
20:37:33 <EvanR> indicates
20:38:19 <EvanR> for all types T, T has an instance of C or it doesn't. And if it does, this is the case for any program uses this module
20:38:37 <int-e> poliquin: The problem that default methods solve is really redundant functions in type classes. For example, Ord has comapre, <, <=, >, >=, max, and min. But for manually defined Ord instances it would be very tedious to define all of them. And in fact, you can get away with comparing only compare, or one of <, <=, >=, or >.
20:40:08 <int-e> poliquin: Functor has basically only one method so default methods are not nearly as helpful. But even for Functor, the default method for (<$) is helpful.
20:46:09 <poliquin> Thanks again to everyone ... One more step to learning Haskell
21:01:49 <dmj`> they never should have discontinued ryan gosling haskell https://haskellryangosling.tumblr.com/
21:19:59 <Axman6> poliquin: just to give a more concrete counterexampkle to what you're tryi8ng to do, what happens if I define data Three a = Three a a a. even if fmap f (h x) worked, that wouldn't match Three's constructor
22:21:15 * hackage reanimate 0.3.1.0 - Animation library based on SVGs.  https://hackage.haskell.org/package/reanimate-0.3.1.0 (DavidHimmelstrup)
23:34:41 <freeside> good news! my pandoc build finally worked. i started from a completely fresh build environment and this time it worked. i don't know what the problem was before :(
23:34:56 <freeside> thank you everybody who was patient with me through this adventure.
