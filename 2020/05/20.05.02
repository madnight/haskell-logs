01:06:31 <chirp> http://curvelet.org/software.html
01:06:41 <chirp> this has matlab bindings
01:07:06 <chirp> its source code is written in C++
01:07:32 <chirp> what are the options for using it via Haskell?
01:09:08 <chirp> can the existing matlab port help pass in into Haskell world?
01:41:25 <kuribas> Is typechecking the same as doing type-inference on the term and the given type, then verifying they are the same?
01:41:44 * hackage email-validate 2.3.2.13 - Email address validation  https://hackage.haskell.org/package/email-validate-2.3.2.13 (GeorgePollard)
01:41:54 <kuribas> for example x :: Int, if we can infer x :: a, then unifying gives x :: Int.
01:42:21 <kuribas> the other way around doesn't work, so x :: a, if we infer x :: Int, then a /= Int
01:43:33 <kuribas> So the given type signature is just another term to unify with, is that right?
01:56:48 <fog> kuribas: i dont think so
01:57:12 <fog> there can be ambiguity which only a type annotation can resolve 
01:58:00 <kuribas> fog: for example?
01:58:05 <fog> if you try to do inference, it can be guarantied that it would be able to determine the type you specify to unify with it
01:58:19 <fog> so it has to be done top down, the opposite way round to inference
01:58:22 <kuribas> fog: I can include the given type in the inference.
01:59:07 <fog> then i think i might misuderstand what you mean about unifying with it, if its already been used in the equational reasoning, wouldnt that be redundant?
01:59:53 <kuribas> no, because if I give x :: a; x = 2, it will infer x :: Int a => a, which is different from a
02:00:15 <kuribas> So the comparison is necessary
02:00:19 <fog> Num*
02:00:35 <kuribas> right :)
02:00:42 <kuribas> :t 2
02:00:43 <lambdabot> Num p => p
02:01:52 <kuribas> do typeclasses introduce ambiguity?
02:01:57 <gentauro> is there a way to make something similar to: `chunksOf :: Int -> [Char] -> [String]; chunksOf _ [] = []; chunksOf n xs = y : chunksOf n ys where (y,ys) = splitAt n xs` but instead of passing an Int, it's a substring as pattern? (aiming for the following signature: `chunksOf :: [ Char ] -> [ Char ] -> [ String ]`
02:03:08 <fog> its not just ambiguous types, i think there are some other complexities 
02:03:37 <fog> i get what you mean about doing partial type inference and then completing it by unifying it with the signature provided
02:04:02 <fog> which i guess is how ambiguous types are solved using type signatures  
02:04:59 <fog> oh wait, now i see what you mean, its about if this last step of completing the inference with unification to an annotation is *all* that typechecking does
02:05:28 <gentauro> oh, nevermind (forgot about the power of `hoogle` -> `[a] -> [a] -> [[a]]`) -> https://hackage.haskell.org/package/split-0.2.3.4/docs/Data-List-Split.html#v:splitOn
02:05:32 <fog> i cant think of a counterexample that you would have to do top down that would be deeper into the equational reasoning
02:05:46 <kuribas> fog: yes
02:06:14 <kuribas> fog: I am implementing a language which is some subset of haskell
02:06:38 <kuribas> well, both subset and superset
02:06:45 <fog> !?
02:07:00 <fog> what does it omit, and what does it add?
02:08:09 <kuribas> it adds refinement types and uniqueness types.
02:08:29 <kuribas> But it only has a limited number of types, no ADTs
02:08:38 <kuribas> only single parameter typeclasses
02:08:48 <fog> and omits all the language extensions that are difficult to implement?
02:09:18 <kuribas> fog: I'd like to have rank-N types
02:09:36 <kuribas> and type variables are scoped by default.
02:09:58 <kuribas> it's meant as a DSL limited to timeseries.
02:10:07 <fog> surely multiparameter typeclasses and functional dependencies are pretty useful, i dont think we could have done without type families as well for so long without them
02:11:03 <kuribas> fog: well, since there are no user defined types, they shouldn't be necessary.
02:11:14 <fog> omg!
02:11:29 <fog> sounds like some kind of generics madness
02:11:40 <kuribas> what do you mean?
02:12:08 <fog> well how else could you do without datatypes? 
02:12:45 * hackage simplistic-generics 2.0.0 - Generic programming without too many type classes  https://hackage.haskell.org/package/simplistic-generics-2.0.0 (AlejandroSerrano)
02:13:03 <fog> "no user defined types" - you allow synonyms though right? just not data constructors
02:13:15 <kuribas> I may allow synonyms
02:13:24 <fog> like, you could still have pairs and either?
02:13:33 <kuribas> tuples yes, no either.
02:13:46 <fog> and then with synonyms or extensions you would basically be doing generics
02:13:54 <kuribas> there is Maybe and Either Int
02:14:13 <kuribas> It's meant as a computation language for timeseries...
02:14:24 <kuribas> only numerical computations
02:14:38 <kuribas> and time of course
02:14:45 <fog> so yeah, wouldnt those primatives basically allow the user to hack some kind of way to define arbitrary datatypes?
02:15:36 <fog> just the issue with type synonym instances and multiparameter typeclasses
02:15:53 <kuribas> if they want...
02:16:26 <kuribas> by keeping it simple I can optimize for it's purpose...
02:16:37 <kuribas> Which is doing computations efficiently on time series
02:16:53 <fog> would be good though, if by restricting the types available that classes would be less nesacary, like if everything could then be Derived
02:17:32 <kuribas> Also possible, but then I need different types for + on Integer, Double, etc...
02:17:39 <kuribas> like in ocaml I suppose
02:17:54 <fog> wait, how do you define the functions *over* the timeseries? 
02:18:06 <fog> wouldnt that need the more expressive language?
02:18:11 <kuribas> a timeseries is a list of tuples (Time, a)
02:19:03 <kuribas> where can be Int, Double, ...
02:19:24 <kuribas> fog: I mean, it has functions...
02:19:33 <kuribas> Those functions don't need to be polymorphic
02:20:22 <fog> right, but if thats unfolded from a measure over a state recursion, then the update function would be operating on some datatype, with a function that might need a more complex program, like, even though the state is *measured* to give the x(t) displacement, the transfer function might still need to be written in a language that passes functions as
02:20:22 <fog> arguments, which requires the more expressive language features for typechecking 
02:21:41 <kuribas> fog: I have HOFs
02:21:55 <fog> ah, just an issue with polymorphism
02:22:24 <kuribas> also I have type variables
02:22:46 <kuribas> I could eliminate type classes, but they I need different versions of addition, etc...
02:23:12 <fog> which is why you have no need yet for multiparameter-typeclasses
02:23:17 <kuribas> indeed
02:23:45 <fog> i cant imagine how it would be safe to imagine they wouldnt occur at some point though...
02:23:57 <kuribas> I can add them later
02:24:39 <fog> and then at which point, wouldnt it be easier to restrict haskell than to slowly grow a subset of it untill it subsumes most of haskell?
02:25:42 <kuribas> you mean rewrite my language to haskell?
02:25:45 <fog> maybe a language extension like "NumericallyRestrictedTypesOnly"
02:26:09 <kuribas> It has uniqueness types for array mutation
02:26:20 <kuribas> I don't want users to need an ST monad...
02:26:23 <fog> oh, i dont understand what that is
02:26:35 <kuribas> Some sort of linear type.
02:26:45 <fog> you can do that in haskell?
02:26:50 <kuribas> no
02:27:06 <kuribas> So setting a value on a vector will "consume" the array.
02:27:26 <kuribas> And the compiler verifies that the "consumed" argument is not used anymore.
02:27:57 <kuribas> Which allows for mutation in a functional language, but without most of the complication...
02:28:06 <fog> but why do you need to have uniqueness (at most one reference to a value?), cant you just traverse the list?
02:28:26 <kuribas> fog: no, arrays are separate from lists.
02:28:50 <kuribas> and the update is mutable
02:28:53 <kuribas> for efficiency
02:29:05 <MarcelineVQ> mutable updates tend to be faster, or at least easier to make fast, so guaranteeing the mutable update is done safely via the types enforcing it means you can be faster still by not having to do extra checks
02:30:14 <fog26> hmm, i didnt think they were faster
02:30:32 <kuribas> it's O(1) vs O(n)
02:30:38 <fog26> ha!
02:30:48 <kuribas> so if you have an array of 1000 elements, it's 1000 times faster!
02:30:55 <fog26> dubious...
02:31:18 <fog26> is the saving not basically just by saving on some GC?
02:31:31 <kuribas> fog26: no, you need to copy the whole array
02:31:48 <fog26> i cant see how guaranteeing immediate deallocation would be all that more effecient
02:32:04 <kuribas> there is no deallocation
02:32:12 <fog26> right, thats the point
02:32:18 <kuribas> updating a value doesn't actually create a new array.
02:32:19 <fog26> surely the number crunching is going to far outweight the cost of GC
02:32:50 <kuribas> fog26: it's not the GC, it's the copying which is slow
02:33:28 <fog26> hmm, so its just for sparse updates, like, if you updated the whole array it would be no better
02:33:43 <kuribas> fog26: are you debating weither copying 1000 values is slower than updating a single value?
02:34:18 <kuribas> indeed, updating a single value
02:34:29 <kuribas> for example for a histogram
02:34:44 <fog> no, just about the idea of updating the values asynchronously 
02:35:31 <fog> normally we have something like a matrix multiplication for the transfer matrix 
02:35:39 <fog> vector*
02:35:48 <kuribas> you mean for convolution?
02:36:16 <fog> no, convolution is block diagonal, so there is a more effecient implementation in terms of stencil traversals
02:36:32 <fog> wait not block diagonal, like n-diagonal
02:36:46 <fog> and for higher dimensional tensors its even worse
02:37:12 <fog> like if your state was a square array, then the transfer would be like a rank 4 tensor
02:37:43 <fog> and there ends up being mostly 0's if you do simple contraction over indicies 
02:39:51 <kuribas> I don't know tensors
02:40:01 <fog> if your state is like a vector update, then the asynchronous gains of being able to update the values eg on seperate processors - with this mulability idea, could be done as easily using sequential access, ie, regular tail recursion?
02:41:02 <fog> well, if you were going to try and do eg, a gausian blur on a square image matrix for the state update, and it was encoded into a single column vector, you wouldnt get the nice tridiagonal structure of nearest neighbour access
02:41:26 <kuribas> I can make optimized build in functions
02:42:17 <kuribas> but images aren't my usecase
02:42:45 <fog> that was just an example for how tensors instead of vectors are better for the state
02:43:32 <fog> to leverage structured access such as convolutions - so that the matrix multiplication can be replaced by a more efficient algorithm 
02:43:58 <kuribas> the current model isn't really for heavy parralelisable computations, more like for streaming aggregations.
02:44:11 <kuribas> resampling etc...
02:44:12 <fog> like max pooling?
02:44:38 <kuribas> I suppose...
02:44:58 <fog> i think thats equivalent to a pruning regime - but i g2g now 
02:45:13 <fog> best of luck!
02:45:32 <kuribas> thanks :)
03:12:14 * hackage vulkan 3.2.0.0 - Bindings to the Vulkan graphics API.  https://hackage.haskell.org/package/vulkan-3.2.0.0 (jophish)
03:13:14 * hackage VulkanMemoryAllocator 0.2.0.0 - Bindings to the VulkanMemoryAllocator library  https://hackage.haskell.org/package/VulkanMemoryAllocator-0.2.0.0 (jophish)
05:04:50 <thongpv87> #join nixos
05:45:20 <dps910> hello
06:03:15 * hackage lean-peano 1.0.2.0 - A maximally lazy, simple implementation of the Peano numbers with minimal dependencies.  https://hackage.haskell.org/package/lean-peano-1.0.2.0 (oisdk)
06:06:02 <merijn> Wait, what?
06:06:19 <merijn> Why does System.Posix.IO.ByteString have functions operating on String?!
06:07:36 <maerwald> merijn: yes, that's what unix-bytestring is for
06:09:00 <maerwald> This is the worst though: https://hackage.haskell.org/package/unix-2.7.2.2/docs/System-Posix-User.html#t:UserEntry
06:18:45 * hackage ghc-lib-parser-ex 8.10.0.5 - Algorithms on GHC parse trees  https://hackage.haskell.org/package/ghc-lib-parser-ex-8.10.0.5 (shayne_fletcher)
06:28:14 * hackage mwc-probability 2.3.0 - Sampling function-based probability distributions.  https://hackage.haskell.org/package/mwc-probability-2.3.0 (JaredTobin)
06:56:00 <tomjaguarpaw> Why is this a syntax error?   `do { let y = 1; pure y }`
06:57:25 <tomjaguarpaw> Furthermore, assuming we could put do-notation on a single line, which is seems we can't, why is the following not acceptable to ApplicativeDo?  `do { x <- pure (); let y = x; pure y }`
06:58:45 * hackage opentelemetry 0.3.2 -   https://hackage.haskell.org/package/opentelemetry-0.3.2 (DmitryIvanov)
06:58:56 <merijn> tomjaguarpaw: THe ; is interpreted as part of the let, not the do
06:59:23 <merijn> > do { let y = 1; pure y } :: Maybe Int
06:59:25 <lambdabot>  <hint>:1:24: error: parse error on input ‘}’
06:59:33 <merijn> > do { let { y = 1 }; pure y } :: Maybe Int
06:59:35 <lambdabot>  Just 1
06:59:44 <tomjaguarpaw> Ah, that makes sense, thanks merijn.
06:59:45 * hackage opentelemetry-wai 0.3.2, opentelemetry-lightstep 0.3.2, opentelemetry-extra 0.3.2 (DmitryIvanov)
06:59:52 <tomjaguarpaw> Anyway, the more important thing is the ApplicativeDo
06:59:54 <maralorn> > do { let { y = 1;}; pure y }
06:59:56 <lambdabot>  error:
06:59:56 <lambdabot>      • Ambiguous type variable ‘f0’ arising from a use of ‘show_M203423250112...
06:59:56 <lambdabot>        prevents the constraint ‘(Show (f0 Integer))’ from being solved.
06:59:59 <tomjaguarpaw> I don't understand that at all
07:00:09 <merijn> ApplicativeDo is rather brittle, afaik
07:00:23 <tomjaguarpaw> Basically unusable, apparently
07:00:52 <merijn> Not unusable, what you're writing is pretty explicitly unsupported
07:01:21 <merijn> Pretty sure you're only allowed to use the bound names in the final "pure" expression
07:01:34 <tomjaguarpaw> So what can you do in an Applicative do after the final <-?
07:01:37 <tomjaguarpaw> Only pure?
07:01:40 <merijn> Yes
07:03:33 <Cale> Other statements should be fine as well
07:04:27 <maerwald> afair, the pattern matching must be lazy
07:04:35 <Cale> (other statements that don't use the variables)
07:05:06 <tomjaguarpaw> Ah, you can put a let *anywhere* if it mentions something bound on the lhs of a <-
07:05:17 <tomjaguarpaw> That's somewhat more sane, but still not quite sane
07:05:28 <tomjaguarpaw> Arrow notation already solved this problem
07:05:31 <Cale> Honestly though, if you care that your expression is using Applicative, you probably care enough to actually use the Applicative combinators. The manner in which ApplicativeDo does the translation can be a bit opaque
07:05:59 <tomjaguarpaw> Well, this is my first time using it.
07:06:02 <tomjaguarpaw> It may be the last.
07:06:36 <merijn> What are you using it for?
07:07:30 <tomjaguarpaw> To make it clearer than liftAn and <$>/<*> what action binds which variable
07:07:50 <glguy> I can't remember using ApplicativeDo for anything other than defining configuration file schemas
07:08:10 <merijn> glguy: I use it to clean up some optparse parsers, but that's about it, yeah
07:13:01 <maerwald> The error messages are confusing, because it just infers Monad constraint, but doesn't tell what you did wrong
07:14:22 <tomjaguarpaw> Yeah, very confusing
07:18:10 <maerwald> > do { (y, _) <- pure (2, 2) ;  pure (1 + y) } :: Applicative f => f Int
07:18:12 <lambdabot>  error:
07:18:13 <lambdabot>      • Could not deduce (Monad f1) arising from a do statement
07:18:13 <lambdabot>        from the context: Applicative f
07:18:18 <maerwald> do { ~(y, _) <- pure (2, 2) ;  pure (1 + y) } :: Applicative f => f Int
07:18:27 <maerwald> > do { ~(y, _) <- pure (2, 2) ;  pure (1 + y) } :: Applicative f => f Int
07:18:29 <lambdabot>  error:
07:18:29 <lambdabot>      • Could not deduce (Monad f1) arising from a do statement
07:18:29 <lambdabot>        from the context: Applicative f
07:19:10 <maerwald> hm, the latter should compile
07:19:54 <glguy> lambdabot might not have that extension enabled
08:02:36 <toni37> hello, how can i find the line which generates exception?
08:18:29 <jakalx> is there a reason why `[LT..]` doesn't expand to the full enum?
08:19:02 <jakalx> > enumFrom LT
08:19:04 <lambdabot>  [LT,EQ,GT]
08:19:15 <merijn> > [LT..]
08:19:17 <lambdabot>  <hint>:1:6: error: parse error on input ‘]’
08:19:20 <merijn> > [LT ..]
08:19:22 <lambdabot>  [LT,EQ,GT]
08:19:23 <jakalx> yep
08:19:28 <jakalx> hu
08:19:30 <merijn> jakalx: Ambiguous parse :)
08:19:34 <jakalx> oh, that easy
08:19:42 <jakalx> stupid me
08:19:44 <merijn> jakalx: It's trying to parse it as a qualified name/import
08:20:00 <merijn> Same with:
08:20:03 <jakalx> merijn: thanks
08:20:06 <merijn> > Just.even $ 5
08:20:08 <lambdabot>  error:
08:20:08 <lambdabot>      Not in scope: ‘Just.even’
08:20:08 <lambdabot>      No module named ‘Just’ is imported.
08:20:12 <merijn> > Just . even $ 5
08:20:14 <lambdabot>  Just False
08:20:18 <merijn> The error could be nicer, though
08:44:45 * hackage colourista 0.1.0.0 - Convenient interface for printing colourful messages  https://hackage.haskell.org/package/colourista-0.1.0.0 (vrom911)
09:02:45 * hackage krank 0.2.1 - Krank checks your code source comments for important markers  https://hackage.haskell.org/package/krank-0.2.1 (guibou)
09:12:14 <Geraffe> Maybe someone could help me with a Haskell exercise. I have to create a function called ’triple :: Integer -> Integer’ which gets an Integer value as Input and gives the triple of this value as an output
09:13:34 <ddellacosta> Geraffe: what do you have so far, got a gist or something? Or question about the problem?
09:16:57 <maerwald> I've heard this triple question multiple times. This is homework :)
09:18:14 <c_wraith> I have to say - if people are having trouble with that question, I'm not impressed by the quality of the instruction they received
09:19:59 <dminuoso> c_wraith: To be fair, without knowing more it's hard to say what they have troubles with.
09:20:17 <Geraffe> ddellacosta https://gist.github.com/JulianW99/dd7fc7b534d1a545422cc1cb9db09f8c
09:21:30 <Geraffe> I know the code should be easy because its just *3, but the instruction is very bad
09:21:59 <ChaiTRex> Geraffe: You want to write two lines: triple :: Integer -> Integer
09:22:14 <c_wraith> ok.  First off, you don't need "do" notation for this.
09:22:15 <ChaiTRex> Geraffe: And: triple number = 3 * number
09:22:33 <ChaiTRex> Geraffe: You had it right, but a lot of extra stuff was added in that you don't want.
09:23:39 <ChaiTRex> Geraffe: You basically just remove the let on the fourth line: triple number = 3 * number
09:23:43 <ChaiTRex> Geraffe: That's it.
09:25:05 <Geraffe> Oh wow :D  Thank you for your help !
09:26:10 <ChaiTRex> Geraffe: You're welcome. I've added a comment to your Gist with the full two-line code.
09:27:00 <Geraffe> :o that´ s so nice of you. Thanks a lot !!! :)
09:32:25 <tobiasBora> Hello, Just a quick question, is there a library that provides a (real) shuffle of lists in haskell? I saw the library [1] but people reported it was buggy [2]. [1] http://hackage.haskell.org/package/random-shuffle-0.0.4/docs/System-Random-Shuffle.html [2]: https://www.reddit.com/r/haskell/comments/96ic6c/how_do_i_shuffle_a_list/
09:35:50 <dminuoso> tobiasBora: Did you look at http://okmij.org/ftp/Haskell/perfect-shuffle.txt ?
09:36:10 <dminuoso> Oh hold on, that [1] is an implementation of that.
09:40:25 <tobiasBora> dminuoso: yes
09:42:31 <tobiasBora> Or maybe someone has an idea of the origin of the bug in that library?
09:44:16 <dminuoso> Apfelmus made an interesting blog post about shuffling lists in a simple manner: apfelmus.nfshost.com/articles/random-permutations.html
09:47:12 <tobiasBora> dminuoso: I'll look at it thanks. too bad there is no good library for that, and the wiki points to a library... which does not contain any shuffle function (or it seems a different shuffle, is it?): https://hackage.haskell.org/package/shuffle. 
09:47:41 <tobiasBora> and do you know if the problem of [1] is the reference at the end: "I'm afraid this is not true."?
09:48:47 <dminuoso> What are you citing with "I'm afraid this is not true"?
09:50:45 <dminuoso> Oh. Essentially linear congrentual number generators could in principle, have repeating patterns. 
09:52:22 <dminuoso> The code from apfelmus blog can be copied directly with little modification.
09:52:47 <Julian23> Do you know if I can install ghci only on my main drive or also on E: or F:,...
09:52:49 <Julian23> ?
09:52:56 <dminuoso> Julian23: It does not matter.
09:53:10 <Julian23> Because I have to less free space on my main
09:53:13 <dminuoso> It's convenient if its on your executable path, but you can add any path t oit.
09:53:18 <Julian23> How can I install it on a different one?
09:53:26 <dminuoso> What installer method are you using?
09:53:40 <tobiasBora> dminuoso: true. It's just a bit weird not to use a regular library for such a common task... Anyway, thanks!
09:53:47 <dminuoso> tobiasBora: Well there is a library
09:54:14 <dminuoso> https://hackage.haskell.org/package/perfect-vector-shuffle
09:54:32 <dminuoso> The problem is that the traditional shuffle methods use Fisher-Yates, but that needs to be done in-place.
09:54:53 <dminuoso> So you need mutable containers (the mutability is hidden away with ST)
09:55:06 <Julian23> I'm installing it with Chocolatey
09:55:55 <tobiasBora> dminuoso: maybe I can just convert my list to a vector, and then do the shuffle. I guess it shouldn't be that innefficient
09:56:35 <dminuoso> Are your lists long? Are there performance constraints?
09:58:02 <tobiasBora> dminuoso: The lists are not long. I just need to shuffle very often.
09:58:12 <Julian23> dominuoso I'm using Chocolatey
09:58:34 <dminuoso> tobiasBora: Is sticking to vectors an option?
09:58:50 <tobiasBora> dminuoso: I guess it makes sense yes
09:58:51 <dminuoso> Constantly roundtripping through a vector is going to drive up allocations
09:59:43 <dminuoso> Julian23: Im not familiar with Chocolatey, I'm afraid. But perhaps you can do something to control the installation path?
10:00:08 <tobiasBora> dminuoso: you're right, and even shuffling lists in a pure way is likely to be inneficient compared to a vector shuffle. I'll do that then, thanks.
10:00:11 <Julian23> Is there a different way to change the path/do you knwo one without Chocolatey?
10:01:10 <dminuoso> Julian23: Mmm, I think chocolatey installs stack only right?
10:01:25 <Julian23> I thought that it installed Cabel
10:01:38 <dminuoso> Oh.
10:01:50 <dminuoso> Im really not familiar with how this works on Windows.
10:02:15 <dminuoso> Based on the fact that you're the first windows user I've seen in a long while, you probably have better luck asking on the mailing list.
10:03:31 <Julian23> Where can I find the mailing list?
10:03:49 <Julian23> But it does work in generel right? I just need to figure out how
10:03:55 <dminuoso> https://www.haskell.org/mailing-lists/
10:04:31 <Julian23> Thank you
10:08:44 * hackage proteaaudio 0.8.0 - Simple audio library for Windows, Linux, OSX.  https://hackage.haskell.org/package/proteaaudio-0.8.0 (CsabaHruska)
10:32:15 * hackage cabal-helper 1.1.0.0 - Give Haskell development tools access to Cabal project environment  https://hackage.haskell.org/package/cabal-helper-1.1.0.0 (DanielG)
11:29:50 <p0a> Hello trying to use `alga' in my project but stack, after all the extra-deps workarounds, tells me my GHC is the wrong version
11:30:06 <berndl> How do I figure out which type `a` Haskell is deducing when I run `show Nothing` in ghci?
11:30:13 <p0a> "Build requires unattainable version of Base". What can I Do?
11:31:32 <koz_> > show Nothing
11:31:34 <lambdabot>  "Nothing"
11:31:45 <koz_> Hmmm, is this where the defaulting rules would apply?
11:31:55 <berndl> default rules?
11:32:23 <berndl> I see that the Show instead for maybe is dervied: `deriving instance Show a => Show (Maybe a)` in GHC.Show
11:32:32 <berndl> s/instead/instance
11:32:52 <evelyn> p0a: are you using lts 15? have you tried lts 14? stack is reportably not well tested with ghc 8.8.x for some packages... '
11:34:47 <p0a> evelyn: not sure which lts I use
11:36:10 <koz_> p0a: It should be the 'resolver' field of your stack.yaml.
11:38:49 <solonarv> koz_: indeed
11:38:54 <solonarv> > show (Nothing :: _)
11:38:57 <lambdabot>  error:
11:38:57 <lambdabot>      • Found type wildcard ‘_’ standing for ‘Maybe a’
11:38:57 <lambdabot>        Where: ‘a’ is a rigid type variable bound by
11:39:01 <solonarv> hm
11:39:37 <p0a> lts-14 gives me invalid YAML not found
11:39:58 <p0a> wait 14.1 works
11:40:08 <koz_> p0a: Because lts-14 is not a thing.
11:40:17 <koz_> All LTS releases are of the form major.minor.
11:40:28 <koz_> You also probbo want _latest_ 14 release, which is 14.27.
11:40:30 <evelyn> don't use lts 14,1, use the most recent verison
11:41:19 <solonarv> berndl: relevant bit of GHC manual: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html#extension-ExtendedDefaultRules
11:41:22 <c_wraith> berndl: it's the defaulting rules.  enable -Wall in ghci and it will tell you when it applies them
11:41:31 <solonarv> with this you can deduce that a defaults to ()
11:41:38 <p0a> thanky ou 
11:41:41 <c_wraith> solonarv: that case doesn't even need the extended rules
11:42:02 <berndl> solonarv: Ah, nice.
11:42:39 <koz_> c_wraith: TIL.
11:45:09 <solonarv> c_wraith: the GHC manual implies that it does, because without ExtendedDefaultRules defaulting a) only happens for numeric typeclasses and b) doesn't try ()
11:45:59 <solonarv> indeed if I type 'main = print Nothing' into a source file and compile it, GHC complains of ambiguity.
11:46:29 <c_wraith> Hmm.  I only remembered the extended defaulting allows for defaulting when there's an unknown (to the defaulting rules) class involved
11:46:30 <solonarv> (with -XExtendedDefaultRules it works, though)
11:46:36 <c_wraith> But I guess it also allows defaulting to ()
11:47:52 <p0a> https://pastebin.com/cULRKbJz
11:48:00 <p0a> I get these errors. Not sure what's happening
11:48:16 <p0a> >= 4.4 and <4.11 but I have 4.10? shouldn't that be ok?
11:48:32 <p0a> although base is 4.12 and I need < than that 
11:48:41 <c_wraith> that last bullet point is the most important
11:48:56 <p0a> Should I just allow-newer?
11:48:59 <c_wraith> "Build requires unattainable version of base. Since base is a part of GHC, you most likely need to use a different GHC version with the matching base"
11:49:18 <p0a> or am I setting myself up for more trouble?
11:49:59 <c_wraith> something is requiring a really old version of process, which isn't compatible with your version of ghc
11:50:13 <c_wraith> *that* requirement is the problem
11:50:29 <p0a> okay
11:50:55 <p0a> optparse-applicative-0.12.1.0
11:50:58 <p0a> is the one that does that
11:51:12 <c_wraith> that's a pretty old version, too
11:51:16 <p0a> and that's an alga-0.2.2 dependency
11:52:21 <c_wraith> yep, alga looks like it was last uploaded in 2016.  And even with HVR updating the dependencies in the middle of last year, it's still just old
11:52:55 <p0a> poop
11:53:10 <c_wraith> If you want to make things work with it, you're best off using a contemporaneous version of GHC.  Your next best bet is downloading and patching alga to build on modern ghc
11:53:29 <c_wraith> In most cases that's easy, unless a dependency has changed drastically
11:54:03 <p0a> I want plug and play
11:54:14 <p0a> I don't want nuisances
11:54:31 <p0a> :P
11:54:44 <p0a> I think I'll try a different graph library 
11:54:51 <p0a> tis a shame I thought alga was pretty sweet
11:55:10 <c_wraith> note that the very first line of Alga's description is "Deprecated."
11:55:20 <koz_> p0a: http://hackage.haskell.org/package/algebraic-graphs
11:55:56 <c_wraith> ah, that looks like the non-deprecated replacement.  Nice find.
11:56:03 <p0a>  oh dang
11:56:09 <koz_> c_wraith: :D
11:56:10 <p0a> that's why, because they added labels
11:56:22 <p0a> I thought it was such a good library no way it's not maintained
11:56:32 <c_wraith> the package description is important!
11:57:11 <p0a> yadda yadda!
11:57:18 <p0a> :P I'll be more careful
11:57:37 <p0a> I've never used a module much
11:59:57 <p0a> so when you look at a hackage page 
12:00:13 <p0a> how do you know what's the textual description for stack? alga didn't cut it -- that was the old deprecated package
12:00:15 <p0a> or module
12:00:34 <p0a> Distributions: stackage link? 
12:02:50 <p0a> whoa that did it! sweet, thanks
12:03:00 <p0a> I get it now, stackage is the thing you look up the stack names
12:06:15 <mekeor> when translating the GADT syntax "Nil :: forall a. List a" to plain simple mathematical notation, would it be "∀ a ∈ Set: Nil ∈ List a"? i.e. wouldn't the "forall" get to the left the "::"?
12:07:04 <mekeor> s/left the/left of the/
12:10:26 <p0a> you mean forall a, Nil :: a ?
12:12:12 <mekeor> p0a: i mean, "for all types a, Nil is of type List(a)"
12:12:44 <mekeor> or "for all t of kind *, Nil is of type List a"
12:14:17 <mekeor> hm, it doesn't make much sense to say something like "Nil is of type 'for all a, List a'" anyway. i guess my question is meaningless, i dunno
12:21:52 <{abby}> sure does. it says Nil (in an idealised world) takes a single argument, which is a type of kind Type, and yields a List of that type
12:22:42 <berndl> So Nil :: (a :: Type) -> List A
12:23:11 <berndl> oops, I meant Nil :: (a :: Type) -> List a
12:23:12 <koz_> mekeor: I think of it like 'Nil is of type List a, for absolutely any choice of a'.
12:23:51 <mekeor> berndl: i can't sport a difference between those lines :D
12:24:05 <berndl> I used a capital A in the first one.
12:24:10 <mekeor> ah :D
12:24:33 <koz_> Yeah, which is hilarious, because in Haskell, 'a' is a type variable, but 'A' is a concrete type.
12:25:00 <mekeor> i mean, what confuses me is that i think "forall a. Nil :: List a" would make more sense to me
12:25:06 <berndl> I'm too used to using capital letters for type variables.
12:26:00 <mekeor> but the signature berndl provided also makes sense. apart from 'a' being an "implicit" argument
12:26:34 <koz_> mekeor: 'foo :: a -> b -> c' is really 'foo :: forall a b c . a -> (b -> c)'
12:27:06 <berndl> mekeor: That's right. in languages like Idris and Agda, that's exactly how it is.
12:27:35 <{abby}> mekeor: ``forall (a :: t). _'' is a type former just like ``t -> _'' is, the difference(s) being that forall is dependent (the quantified thing has a name), irrelevant (the quantified thing is erased at runtime) and invisible (you don't normally write the argument there) whereas -> is nondependent, relevant, and visible
12:30:51 <p0a> forall a. Nil :: List a changes the meaning of Nil depending on a
12:31:03 <p0a> I think you want to think of Nil as a thing that doesn't change depending on the weather
12:31:17 <berndl> It just occured to me that we could never use (+) for Either since + is infixl instead of infixr. That's a bummer.
12:31:50 <p0a> berndl: you said you use algebraic-graphs
12:32:06 <p0a> I'm curious, how do you implement your graphs? Using Set?
12:32:08 <berndl> Nope. I don't use it.
12:32:12 <p0a> Oh nevermind 
12:32:18 <berndl> I just know about it.
12:32:35 <p0a> it gives you this freedom of providing certain parts of the implementation of the graph
12:32:38 <mekeor> hm, maybe i'm criticizing the syntax at this point because i'm thinking of type-signature too much as "∈", whereas the type within a type-signature is usually required to hold the whole context…
12:32:45 <p0a> and I'm not sure how to do it. Then again, I work with small graphs, so probably Set will do fine
12:32:45 <hseg> dmwit: now that i'm in a better headspace, your recommendation to write an ArbitraryRing class makes more sense, especially given derivingVia
12:33:27 <hseg> have run into a bit of a roadblock though - how do you apply DerivingVia to data family instances?
12:34:03 <hseg> (in this case, i'd like to derive via (Unit (W T)) instance Arbitrary (Unit T)
12:34:19 <hseg> where W is the usual DerivingVia wrapper)
12:35:37 <hseg> hrm. maybe if I export the constructors of Unit T? it is defined behind a backpack signature that i'm bypassing anyway, so it might work
12:38:29 <p0a> how can I get an ambiguous occurence of `empty' when I import Set qualified? (but Algreba.Graph unqualified?)
12:39:16 <dsal> a) don't do unqualified imports of all the things.
12:39:23 <dsal> b) I don't use empty in general.
12:39:32 <p0a> how can I not use empty?
12:39:40 <p0a> It's part of the thing
12:39:47 <p0a> I'm defining an instance of
12:40:11 <dsal> Typically, I use mempty.  But it looks like Graph isn't a Monoid.
12:40:53 <p0a> yeah the empty graph is both the additive and multiplicative identity
12:41:01 <dsal> I don't quite get how you're getting ambiguity if the symbol names aren't the same, though.  What's the code and error?
12:41:08 <p0a> let me paste it
12:42:56 <p0a> code: https://pastebin.com/1967L8Zn error: https://pastebin.com/Q9K0K0s5
12:43:33 <p0a> the lines of the error don't correspond because I deleted "someFunc" that stack adds automatically
12:44:36 <dsal> Well that's a bit confusing.
12:45:43 <p0a> What does it mean that Vertex is not visible?
12:46:07 <p0a> Does it have to do with the module not exporting it?
12:46:14 <{abby}> yes
12:46:18 <p0a> I think that means the tutorials I'm reading are outdated 
12:46:46 <p0a> idk
12:46:47 <{abby}> Algebra.Graph exports a graph *type*, you need Algebra.Graph.Class
12:46:56 <dsal> Yeah, looking at that module, you have a Graph .... that thing ^
12:47:37 <dsal> The tutorial you're reading must be for something else.
12:47:38 <tobiasBora> Hello, Is the traditional way to create a *mutable* vector from a list is "Data.Vector.unsafethaw $ Data.Vector.fromList $ [5,2,6]"?
12:48:03 <dsal> Should work.
12:48:24 <p0a> okay reading the module description (Which I was told to do before...) I realize you are right {abby}. In fact it seems they have provided some instances so that I don't have to do the polymorphism myself 
12:48:58 <{abby}> indeed
12:49:27 <p0a> thank you 
12:50:46 <tirej> what should i expect from the following expression? 
12:51:02 <tirej> takeWhile (> 3) [1,2,3,4,1,2,3,4]
12:52:07 <{abby}> % takeWhile (> 3) [1,2,3,4,1,2,3,4]
12:52:07 <yahb> {abby}: []
12:52:14 <tirej> Well, I expect output to be this [4,4]
12:52:26 <tirej> why is it [] ?
12:52:33 <{abby}> because takeWhile takes elements while the predicate holds
12:53:01 <{abby}> filter is the function you want for all elements for which the predicate holds
12:54:36 <tirej> I'm not sure I understand the second part which is "predicate holds"
12:54:58 <tirej> Because, if you change the predicate to this (< 3) the result will be different
12:55:09 <xsperry> > takeWhile (>3) [5,4,3,2,1,2,3,4,5]
12:55:11 <lambdabot>  [5,4]
12:55:41 <{abby}> yes..? (< 3) 1 is true and (> 3) 1 is false
12:57:29 <{abby}> takeWhile returns the largest prefix of a list such for all elements of that prefix, the predicate function returns True. the largest prefix of [1,2,3,4,1,2,3,4] for which all elements are > 3 is []. [4,4] is not a prefix of [1,2,3,4,1,2,3,4
12:57:30 <tobiasBora> dsal: it's funny to see that the normal way to create a mutable vector is to use an unsafe thing ^^
12:59:35 <rosterok> beginner.  is there a way of using a fold or traverse optic where it only iterates over the list once?  I have the following, but that will perform two filters:  (sample ^.. folded . filtered (< 0), sample ^.. folded . filtered (>= 0))
12:59:59 <dsal> tobiasBora: You don't have to use the unsafe thing, but you might as well since you know it's safe in this case.
13:00:21 <dsal> rosterok: How do you know how many times it iterates the list?
13:00:33 <rosterok> i just assumed
13:00:46 <tirej> {abby}: Thanks for the explanantion. One more question though, for a non-native speaker. What is the prefix in this context?
13:01:02 <{abby}> % [1,2,3] `isPrefixOf` [1,2,3,4]
13:01:02 <yahb> {abby}: True
13:01:05 <dsal> rosterok: Oh, you're doing partition?
13:01:09 <rosterok> yes
13:01:11 <toni37> helllo
13:01:18 <{abby}> tirej: equal elements at the beginning
13:01:23 <rosterok> should have mentioned that
13:01:31 <dsal> rosterok: I should've read your code.  heh
13:01:35 <tirej> {abby}: you rock, thanks!
13:01:49 <{abby}> glad to have helped :)
13:02:05 <toni37> i want to make a list comprehension like: [x | x <- A.assocs level, let x = snd x, k = (StartCell _)]
13:02:29 <{abby}> % let x = snd x in x
13:02:30 <yahb> {abby}: ; <interactive>:35:9: error:; * Occurs check: cannot construct the infinite type: b1 ~ (a1, b1); * In the expression: snd x; In an equation for `x': x = snd x; In the expression: let x = snd x in x; * Relevant bindings include x :: (a1, b1) (bound at <interactive>:35:5)
13:02:37 <toni37> where level is an Data.Array and StartCell is a data constructor which get's an argument
13:03:07 <dsal> rosterok: I feel like the answer involves "bifunctor", but I'm not super well-versed in optics.
13:03:10 <toni37> all i want is that k to be constructed with StartCell constructor
13:03:24 <toni37> how can i specify that?
13:03:42 <{abby}> "StartCell _ <- pure k" works but is a bit gross
13:04:10 <toni37> wow, thanks
13:04:19 <{abby}> have you considered e.g. [k | (_, k@(StartCell _)) <- A.assocs level]
13:04:44 <{abby}> or uh if you want the pair it'd be [x | x@(_, StartCell _) <- A.assocs level], my bad
13:05:48 <toni37> yep this is exactly what i was looking for :D
13:06:22 <{abby}> toni37: the generators in a list comprehension can be bound to any pattern, and if the pattern doesn't match execution just continues with the next element
13:06:42 <{abby}> % let xs = [Just 1, Nothing, Just 2, Nothing] in [x | Just x <- xs]
13:06:42 <yahb> {abby}: [1,2]
13:07:10 <p0a> so in my Lib.hs I import stuff 
13:07:22 <p0a> but when I type `stack repl' although I'm in Lib I don't get access to the stuff I've imported 
13:07:26 <p0a> I need to reimport it. Why?
13:07:38 <dsal> p0a: You get what you export, not what it imports.
13:07:45 <p0a> ah I see 
13:08:00 <dsal> You can have *that* export the other stuff, but like, don't do that.  :)
13:08:02 <ChaiTRex> p0a: You're not really in Lib, I think. I think you just imported Lib.
13:08:10 <sm[m]> unless you do :m +*Lib
13:08:14 <toni37> {abby}: thx
13:08:18 <{abby}> np
13:09:08 <p0a> ChaiTRex: I find it really hard to be accurate these days
13:11:26 <dsal> That detail is the whole difference, though.
13:11:47 <dsal> If you were "in" the Lib, you'd have access to unexported symbols and everything it imported.  If you just import it, you only have access to what it exports.
13:11:49 <monochrom> The GHC user's guide explains this completely. But no one reads it ever.
13:12:09 <dsal> monochrom: Is there a 5 minute YouTube video version?
13:12:23 <p0a> I wouldn't be able to watch it even if there were one
13:12:24 <monochrom> Yes and no.
13:12:26 <hseg> hrm. maybe if I export the constructors of Unit T? it is defined behind a backpack signature that i'm bypassing anyway, so it might work
13:12:31 <hseg> oops
13:13:08 <monochrom> No one has made one. But it can be made by pointing a camera at a browser that scrolls over it for 5 minutes.  Just add background music and it's "professional" and "10k likes".
13:13:15 <sm[m]> what if for May we answered only with doc links
13:13:29 <monochrom> :)
13:13:41 <monochrom> May the Source Be With You
13:13:44 * hackage nix-diff 1.0.10 - Explain why two Nix derivations differ  https://hackage.haskell.org/package/nix-diff-1.0.10 (GabrielGonzalez)
13:14:01 <sm[m]> or we could set up a better doc sharing bot 
13:14:39 <{abby}> only with doc links is too kind, let's do only source links
13:14:49 <tobiasBora> dsal: ok thanks.
13:16:43 <monochrom> But Veritasium research shows that the optimal video length is around 20 minutes, not 5 minutes.
13:17:05 <p0a> Why can't I do (1+) =<< Just 1
13:17:07 <p0a> to get Just 2?
13:17:14 <{abby}> :t (=<<)
13:17:15 <lambdabot> Monad m => (a -> m b) -> m a -> m b
13:17:16 <{abby}> :t (1+)
13:17:17 <lambdabot> Num a => a -> a
13:17:37 <p0a> right
13:17:45 <{abby}> :t fmap -- this is what you want
13:17:46 <lambdabot> Functor f => (a -> b) -> f a -> f b
13:17:54 <p0a> yeah I get it now
13:18:45 <dsal> > succ <$> Just 1
13:18:46 <lambdabot>  Just 2
13:18:59 <tobiasBora> Also, I'm a bit lost, what is the type of a mutable vector (in an IO monad)? Not sure what is this PrimState in "MVector (PrimState m) a"
13:19:17 <dsal> You mostly just need to pay attention to MVector.
13:19:39 <xsperry> > return . (1+) =<< Just 1  -- but don't do this, use <$> or fmap
13:19:41 <lambdabot>  Just 2
13:19:49 <dsal> tobiasBora: https://hackage.haskell.org/package/vector-0.12.1.2/docs/Data-Vector-Mutable.html
13:19:54 <p0a> xsperry: I see 
13:20:08 <dsal> :t pure . succ
13:20:09 <lambdabot> (Applicative f, Enum a) => a -> f a
13:20:10 <{abby}> tobiasBora: PrimState m identifies what IO-like monad you're using.. better to ignore it for now
13:21:03 <p0a> I have an IO (Maybe T)
13:21:11 <p0a> and a f :: T -> T say
13:21:18 <p0a> do I need to do 2 <$>'s?
13:21:18 <{abby}> :t fmap . fmap
13:21:19 <lambdabot> (Functor f1, Functor f2) => (a -> b) -> f1 (f2 a) -> f1 (f2 b)
13:21:21 <{abby}> p0a: yeah
13:21:24 <tobiasBora> {abby}: dsal not sure to understand... Which type can I put when I declare the type of the operators?
13:21:34 <p0a> {abby}: how do I not make it look weird?
13:21:39 <{abby}> p0a: fmap foo <$> bar
13:21:46 <tobiasBora> (I would need to use it in the IO monad)
13:21:46 <p0a> thanks
13:22:10 <{abby}> tobiasBora: IOVector
13:24:05 <dsal> tobiasBora: If you're calling it from IO, you ideally don't mention that it's doing anything with mutable vectors at all.
13:24:35 <tobiasBora> {abby}: hum... but then I'm a bit lost, I was using before the Data.Vector interface like Vec.thaw $ Vec.fromList [1,2,3], but Vata.Vector.Mutable has not fromlist anymore
13:25:12 <tobiasBora> dsal: I don't understand
13:25:26 <dsal> Yeah, the idea is that the mutable vector only lives within the place you're mutating.  A regular vector goes in and a regular vector comes out, but in the middle, it's mutable.  The mutable reference doesn't escape, though.
13:26:02 <dsal> I normally do this in ST where it's a lot more constrained.  In IO, you can theoretically move the mutable vector all over the place, though.
13:26:24 <tobiasBora> dsal: I should read more on ST at some point ^^'
13:27:04 <dsal> ST has a magic spell that lets you do IO-like things without IO†.  You write a pure function that does mutation on the inside.
13:27:24 <dsal> If you're doing it all in IO, it's easier to blur the line.  It's roughly the same code, but you *can't* blur the line in ST.
13:28:03 <tobiasBora> dsal: nice, should definitely read at that later.
13:28:25 <tobiasBora> but right now how do I convert my non-mutable vector into a VM.IOVector?
13:29:21 <{abby}> thaw?
13:29:45 * hackage list-predicate 0.1.0.1 - Predicates on lists  https://hackage.haskell.org/package/list-predicate-0.1.0.1 (pgujjula)
13:30:12 <tobiasBora> {abby}: but thaw is defined in Data.Vector only no? I tried (Vec.thaw $ Vec.fromList [1,2,3]) :: VM.IOVector Int but it fails
13:30:50 <{abby}> it fails how, exactly?
13:31:13 <tobiasBora> {abby}: http://paste.debian.net/1144438
13:31:39 <{abby}> :t V.thaw
13:31:41 <lambdabot> error:
13:31:41 <lambdabot>     Not in scope: ‘V.thaw’
13:31:41 <lambdabot>     No module named ‘V’ is imported.
13:31:43 <{abby}> woops wrong bot
13:31:55 <{abby}> % :t V.thaw -- the mutable vector lives in IO
13:31:55 <yahb> {abby}: Control.Monad.Primitive.PrimMonad m => V.Vector a -> m (V.MVector (Control.Monad.Primitive.PrimState m) a)
13:32:28 <{abby}> % (V.thaw (V.fromList [1,2,3])) :: IO (Vm.IOVector Int)
13:32:28 <yahb> {abby}: 
13:32:48 <tobiasBora> ohhh
13:32:50 <tobiasBora> good job
13:32:57 <tobiasBora> thanks a lot
13:33:24 <tobiasBora> so last question: what is the difference between V.MVector and VM.MVector?
13:34:09 <{abby}> % (\x -> x) :: V.MVector () Int -> Vm.MVector () Int
13:34:10 <yahb> {abby}: ; <interactive>:42:1: error:; * No instance for (Show (V.MVector () Int -> V.MVector () Int)) arising from a use of `print'; (maybe you haven't applied a function to enough arguments?); * In a stmt of an interactive GHCi command: print it
13:34:17 <{abby}> Oh, screw you, yahb 
13:34:21 <{abby}> tobiasBora: They're the same type.
13:35:06 <tobiasBora> {abby}: oh really? Ok. And what's the difference with the generic version?
13:35:40 <{abby}> The generic version defines a class, not a type, which can be implemented by various vector-like structures
13:36:26 <{abby}> So you can write code that uniformly works for immutable vectors, mutable vectors, unboxed vectors, etc
13:36:50 <tobiasBora> {abby}: oh I see, thanks a lot!
13:36:54 <{abby}> np
13:38:46 <tobiasBora> Sorry I'm a bit annoying, it's not possible to derive show for MVector?
13:39:43 <{abby}> No, mutable vectors don't have an instance of Show. They're not supposed to exist for very long, as dsal said
13:40:19 <tobiasBora> {abby}: Ok. And in my case it's not a problem to make them live longer?
13:40:55 <tobiasBora> (I'd be still more scared to apply unsafeThaw everywhere)
13:41:00 <{abby}> It shouldn't be but it's not exactly good style
13:41:43 <tobiasBora> {abby}: so the good style is to keep sending normal vectors and unsafethaw them everywhere?
13:41:50 <dsal> What are you doing that makes you feel like you should keep a vector around for a while?
13:41:58 <dsal> It's not safe to use unsafe everywhere.  :)
13:42:03 <{abby}> The good style is to not use mutable vectors in the first place
13:42:27 <tobiasBora> dsal: I'm supposed to take a vector, permute it, compute a value, permute it again, compute another value and so on...
13:42:49 <tobiasBora> and people here told me "use mutable vectors" to permute
13:42:55 <p0a> https://pastebin.com/n7sZTc30
13:42:55 <tobiasBora> (which makes sense I guess)
13:43:00 <p0a> ^ I don't get why I can't fmap this
13:43:03 <p0a> the types seem to match 
13:43:29 <{abby}> what is the error you get?
13:43:45 <xsperry> what is the type of extractEdges?
13:43:55 <dsal> p0a: that's a lot of fmapping
13:44:05 <MarcelineVQ> or not enough
13:44:19 <{abby}> I'm betting on not enough, but until we see the error message..
13:45:09 <ChaiTRex> tobiasBora: Do you create the vector in your function or is an immutable vector passed in?
13:45:10 <dsal> tobiasBora: I guess I don't know why you were recommended to use mutable vectors.  A regular one should be fine, I'd think.
13:46:08 <tobiasBora> ChaiTRex: well I create a vector in my function, and then gives it to other functions to compute the value I need
13:47:04 <dsal> Where is the vector mutated?
13:47:09 <tobiasBora> dsal: really? Interesting...
13:47:17 <tobiasBora> Only during the shuffle
13:47:38 <tobiasBora> (and above when I wrote "permute" I meant shuffle)
13:47:58 <dsal> Oh, so you could have a `shuffle :: Vector a -> Vector a` that uses a mutable vector in the midde.
13:48:05 <dsal> You don't ned anyone else to know that, though.
13:48:39 <dsal> I wouldn't think you'd *need* a mutable vector.  It might make it faster, though.
13:48:53 <tobiasBora> dsal: funny. And the first vector will be garbage collected?
13:48:57 <p0a> well I just did fmap edges <$> ... and it owrke
13:48:59 <tobiasBora> dsal: I do care about performance though
13:49:11 <p0a> worked! I think my type signature was rong. I swear I thought it didn't work in the repl
13:49:51 <dsal> tobiasBora: If you care about performance, measure it... but immutability has pros and cons.
13:50:03 <p0a> I was doing something wrong with `do'
13:50:04 <dsal> It's not like you're reproducing the entire program core on every invocation, though.
13:50:14 * hackage lzo 0.1.1.1 - minilzo bundled for Haskell  https://hackage.haskell.org/package/lzo-0.1.1.1 (vmchale)
13:50:17 <dsal> p0a: can't do something wrong if you don't do at all.
13:50:51 <tobiasBora> dsal: ok I see, thanks
13:51:05 <p0a> dsal: lol
13:51:15 * hackage dobutokO2 0.38.0.0 - Helps to create experimental music from a file (or its part) and a Ukrainian text.  https://hackage.haskell.org/package/dobutokO2-0.38.0.0 (OleksandrZhabenko)
13:51:27 <tobiasBora> dsal: actually the program body is mainly once the permutation is fixed.
13:52:51 <dsal> premature evil is the optimization of all roots
13:55:33 <dsal> Now I'm having to read about this thing:
13:55:36 <dsal> @hackage discrimination
13:55:36 <lambdabot> http://hackage.haskell.org/package/discrimination
13:55:45 * hackage mole 0.0.7 - A glorified string replacement tool  https://hackage.haskell.org/package/mole-0.0.7 (wereHamster)
13:56:45 * hackage hlint 3.0 - Source code suggestions  https://hackage.haskell.org/package/hlint-3.0 (NeilMitchell)
14:00:14 * hackage turtle 1.5.19 - Shell programming, Haskell-style  https://hackage.haskell.org/package/turtle-1.5.19 (GabrielGonzalez)
14:01:56 * dsal can't wait to see all the complaints hlint 3.0 has to offer
14:02:11 <juri_> ooh.
14:02:15 <juri_> time to try it!
14:03:16 <tobiasBora> Hum... The random-shuffle can't shuffle an empty vector, is it a bug or a feature?
14:05:33 <dsal> file bug:  can't shuffle nothin'
14:21:02 <juri_> slightly better. i like the data -> newtype warning.
14:23:52 <dsal> I've had that for a while.
14:24:29 <dsal> My slow computers are still building.  I better get some good warnings.
14:27:33 <p0a> can I use `where' inside a lambda?
14:28:19 <tomjaguarpaw> Not directly, but you can do `\x -> let y = ... where ... in ...`
14:30:27 <p0a> thank you 
14:38:13 <davve> /32/
14:38:28 <davve> sorry
14:43:45 * hackage list-filter 0.1.0.0 - Special takes and drops on lists  https://hackage.haskell.org/package/list-filter-0.1.0.0 (pgujjula)
14:45:35 <Uniaika> IRSSI USER SPOTTED!!!
14:45:38 <p0a> really happy with Haskell
14:45:43 <Uniaika> p0a: nice!
14:46:26 <p0a> took me 3 days to get up and running with C++ on some project and in 3 days I did the same in Haskell (but with minimal Haskell knowledge, kudos to #haskell of course)
14:46:42 <p0a> but the future looks bright now, I think the rest will be much faster
14:51:02 <Uniaika> p0a: some stuff will be discouraging, at times. In Python you learn imperative programming, then OOP, then you move on with your field (ML, sysadmin, webapps). In Haskell, the growth towards language mastery is much richer, can lead to areas still under R&D
14:51:46 <Uniaika> p0a: find yourself a nice subset of the possibilities given to you by the language. Don't hope to master them all because countless souls^Wthesis have been spent into crafting new techniques
14:52:02 <Uniaika> and as you'll grow as a Haskell developer, you'll adopt new techniques. :)
14:54:14 <dsal> hlint suggested    fromMaybe False --> (Just True ==)
14:55:17 <dsal> It's weird that they mean the same thing, but I don't think about them similarly.
14:57:10 <dsal> @index MonadFail
14:57:10 <lambdabot> bzzt
14:57:21 <dsal> @hoogle MonadFail
14:57:21 <lambdabot> Control.Monad.Fail class Monad m => MonadFail m
14:57:21 <lambdabot> RIO.Prelude.Types class Monad m => MonadFail (m :: Type -> Type)
14:57:21 <lambdabot> Universum.Monad.Reexport class Monad m => MonadFail (m :: Type -> Type)
14:57:57 <dsal> Where am I getting MonadFail?  I had an import for it and hlint said it was redundant.  I removed it and my code still compiles.
15:00:01 <dsal> Here's a weird one.      if optNoMQTT then [] else [excLoop "mqtt" mqttSink]   -->   ([excLoop "mqtt" mqttSink | not optNoMQTT])  
15:00:31 <MarcelineVQ> Are you actually using monad fail?
15:00:31 <dsal> On one hand, I don't like if/else.  On the other hand, this feels like abuse of list comprehensions.
15:00:39 <dsal> I'm deriving MonadFail
15:05:44 * hackage list-duplicate 0.1.0.0 - Group and delete duplicates from a list  https://hackage.haskell.org/package/list-duplicate-0.1.0.0 (pgujjula)
15:06:45 * hackage hlint 3.0.1 - Source code suggestions  https://hackage.haskell.org/package/hlint-3.0.1 (NeilMitchell)
15:07:06 <dsal> hlint 3.0.1?!?  I just got 3.0!
15:07:29 <dsal> Oh, it apparently crashes if you use Safe.  None of my code is Safe
15:15:37 <p0a> if I have a list [(a,b)] how can I lookup a and return b?
15:15:43 <p0a> key-value I suppose
15:17:05 <dsal> :t lookup
15:17:06 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
15:17:12 <p0a> nice thanks
15:22:15 * hackage zeolite-lang 0.1.3.1 - Zeolite is a statically-typed, general-purpose programming language.  https://hackage.haskell.org/package/zeolite-lang-0.1.3.1 (ta0kira)
15:25:22 <hseg> ... wtf. why does http://ix.io/2kws give me varying values for arbitrary @(Unit N) ?
15:26:24 <hseg> i'd've thought that instance Arbitrary T where {arbitrary = return whatever} would force sample (arbitrary @T) to be equivalent to replicate 10 whatever
15:27:28 <hseg> and i don't see why derivingvia would break that
15:28:17 <hseg> ... *facepalm*
15:28:33 <hseg> of course it doesn't -- derived via the wrong wrapper
15:29:03 <hseg> deriving via (Unit (OnlyOne N)) and deriving via (OnlyOne N) are very different things
15:39:22 <Robbie> Hi there. I have a general dev question. How do I find the package name of a library as required to install it. I come from the javascript world where every libraries documentation starts with "install with `npm install my-package-name`".It seems like Haskell world doesn't do this, and I'm not sure how I find the package nameEg, I'd like to install
15:39:22 <Robbie> this package: http://hackage.haskell.org/package/hip-1.5.4.0/docs/Graphics-Image.html, but I don't know what to put in my dependencies field to get it.Is there some convention I'm missing?
15:40:13 <berndl> hip is the package name
15:41:33 <c_wraith> Robbie: it's in the url
15:41:52 <c_wraith> Robbie: and it's the very first words in the page header
15:42:01 <Robbie> berndl, c_wraith - thanks!
15:53:57 <jcowan> I don't understand why sequenceA insists on its argument being ordered.  If it is unordered surely it's possible to order it arbitrarily and then deliver the argument in the applicative functor in arbitrary order too.
15:54:02 <jcowan> Can someone explain this?
15:57:14 <berndl> :t sequenceA
15:57:16 <lambdabot> (Traversable t, Applicative f) => t (f a) -> f (t a)
15:57:24 <berndl> I don't see an Ord constraint.
16:02:45 <hseg> why does this http://ix.io/2kwK not discharge the KnownNat constraint on my prop_nat_ix :: forall n. KnownNat n => Property ?
16:05:01 <Cale> ?
16:05:44 <c_wraith> jcowan: yes, an order can often be imposed.  But since the ordering is observable via Applicative effects, it's important to make the ordering something "expected", for some definition of the word.
16:06:51 <hseg> thought that forAll (arbitrary @Integer) $ \n -> reifyNat n (\(_ :: Proxy n) -> p @n) would work to discharge a KnownNat n constraint on p
16:07:21 <hseg> (so for p :: forall n. KnownNat n => Property, this term would typecheck)
16:12:43 <Cale> hseg: You'll need AllowAmbiguousTypes because the KnownNat constraint on Property there is ambiguous
16:13:24 <hseg> yep, enabled at both define and use site
16:13:44 <Cale> Your code is accepted by GHC for me
16:14:54 <Cale> (it might be really helpful if you'd share enough of the code to actually run something, so I didn't have to guess what extensions and imports you had going on, and what the error was)
16:15:25 <hseg> :-/ sorrt
16:15:45 <hseg> it's just that my code is an interdependent mess
16:17:24 <hseg> lemme try and cook something up
16:20:19 <hseg> this mwe should illustrate my problem: http://ix.io/2kwQ
16:22:22 <hseg> just checked, mwe does indeed demonstrate the problem
16:26:00 <solonarv> tobiasBora: oh, if you're still wondering about the mutable vector creation thing, thaw (fromList xs) ends up generating the same code as unsafeThaw (fromList xs)
16:26:37 <solonarv> (I guessed that this would be the case because the vector library is pretty good about that sort of thing, then looked at the source code and saw the right rewrite rules)
16:31:39 <dsal> Huh.  That seems smart.
16:33:22 <koz_> solonarv: It's still better to use unsafe{Freeze,Thaw} if you're sure it's not an issue.
16:33:27 <koz_> (at least IMHO)
16:34:22 <jcowan> c_wraith: Thanks.  Because I have a concrete mind, I'm thinking about the concrete case of Set (Maybe a) -> Maybe (Set a).  What effects would you be able to observe while doing this?
16:34:36 <jcowan> Also, while Set a is not Traversable, it seems that Set (Ord a) should be.
16:34:42 <dsal> koz_: Why's that?  It seems better to only use them if you're sure it's correct.  If the library can optimize, then you shouldn't need to.
16:34:42 <hseg> Cale: ping? you asked for a mwe, i provided it
16:34:51 <jcowan> (Indeed, I don't understand how Set is implemented when a is not an Ord.)
16:35:09 <koz_> jcowan: Set is defined as an ADT with some internal invariants which the type system doesn't reflect.
16:35:22 <koz_> Also 'Set (Ord a)' isn't kinded correctly to be a Traversable.
16:35:42 <koz_> dsal: See my point where I said 'if you're sure it's not an issue'.
16:35:52 <koz_> Mostly because the library may not optimize in _all_ cases.
16:35:58 <koz_> But if you write it, then it will just do that.
16:36:15 <Rembane> Or you write the most naive code that solves the problem and then profile if things are too slow.
16:36:21 <dsal> I guess I see your point.  I've used it for premature optimization that seems like may have been unnecessary anyway.
16:36:55 <koz_> Rembane: In that case why are you even using mutable vectors at all?
16:37:01 <koz_> Just use immutable ones!
16:37:03 <Cale> hseg: ah, sorry, I'll have a look
16:37:09 <hseg> ty
16:37:11 <Rembane> koz_: Because immutable vectors were too slow. 
16:37:21 <jcowan> So in some cases Set is *not* a binary tree?
16:37:32 <koz_> jcowan: Uhh, no. It's implemented as a binary tree.
16:37:45 <koz_> The fact that we need an Ord constraint on its elements isn't reflected in the _data_ type.
16:37:53 <koz_> It's only reflected in its operations.
16:37:57 <koz_> (and not even all of them)
16:37:57 <dsal> There's this confusing thing where how you define it and how you implement it are separate things.
16:38:28 <koz_> A Set in Haskell is a self-balancing binary tree. The 'binary tree' part is reflectable in its definition as an ADT, the 'self-balancing' part is not.
16:38:37 <dsal> You need Ord to like, insert and stuff, but not to fold.
16:38:47 <jcowan> Hackage says " Most operations require that e be an instance of the Ord class", which implies that you can construct a Set of unorderables even if it won't do everything you want it to.
16:38:48 <koz_> (actually, it's a self-balancing binary _search_ tree, but close enough :P)
16:38:51 <toni37> hello, how can i place in a case block something like that? case x of 1 || 2 -> True; _ -> False
16:39:23 <hpc> do you want to match multiple cases at once, or arbitrary boolean expressions?
16:39:26 <koz_> toni37: I don't understand what you're trying to say.
16:39:32 <toni37> multiple cases at once
16:39:33 <peutri> or || for ints?
16:39:52 <toni37> || as 'or'
16:39:59 <hseg> toni37: do you mean c-style switch(x) { case 1: case 2: return true; default: return false; } ?
16:40:02 <peutri> what does 1 or 2 mean?
16:40:03 <Cale> hseg: hmmm
16:40:04 <toni37> ok, so it works with or, thx
16:40:05 <koz_> jcowan: https://hackage.haskell.org/package/containers-0.6.2.1/docs/Data-Set.html#v:singleton
16:40:05 <hpc> give "True" a name, and write multiple cases
16:40:11 <koz_> So 'yes, you absolutely can'.
16:40:20 <koz_> You can construct singleton sets of un-Ord-erable things.
16:40:24 <koz_> The library won't stop you/
16:40:29 <toni37> hseg: yes
16:40:29 <dsal> toni37: Probably not what you're looking for, but that exact code (probably) is  (`elem` [1,2])
16:40:31 <hpc> you sort of have to do it that way, because pattern matching is also variable binding
16:40:41 <toni37> dsal:not really
16:40:50 <Cale> hseg: ahhh, ghc complains about an occurrence of prop_foo on its own
16:40:56 <toni37> https://pastebin.com/QamRFNFx
16:41:03 <hpc> so making sure that two patterns have equivalent "definitionness" isn't easy to implement
16:41:19 <toni37> i want to make smth like Up or Down, Left or Right
16:41:23 <Cale> hseg: I wonder if we use forall n ->
16:41:44 <hpc> you can also use guards
16:41:49 <hpc> upDown Up = True
16:41:50 <hseg> Cale: which we don't have, but which i'm trying to simulate by reflection
16:41:52 <hpc> upDown Down = True
16:41:55 <hpc> upDown _ = False
16:41:55 <dsal> Yeah, I'd just do that ^
16:41:57 <hpc> and then
16:41:57 <dsal> so much code.
16:42:10 <hpc> case x of _ | upDown x -> ...
16:42:28 <hseg> toni37: i think you want https://stackoverflow.com/questions/29246108
16:42:33 <hpc> maybe get fancy with view patterns or pattern guards, but defining upDown in the first place is your key to success
16:42:36 <Cale> hseg: Adding a proxy argument would work though
16:42:45 <Cale> hseg: So, I'd probably just do that
16:42:54 <toni37> hseg: yep, t hx
16:46:03 <jcowan> Okay, got it.  Now let us say we do have an orderable type.  What can we observe when transforming a glotch of Maybe Ints into a Maybe glotch of Ints based on the order in the glotch? 
16:46:20 <koz_> jcowan: What's a 'glotch'?
16:46:21 <hseg> Cale: yeah, http://ix.io/2kwY works
16:46:37 <c_wraith> jcowan: the important part is that traverse *isn't* concrete.
16:46:39 <hseg> shame, but i'll take it
16:46:52 <jcowan> koz_: An unspecified aggregate
16:47:04 <c_wraith> jcowan: traverse (and sequenceA, and so on) *must* work for all instances of Applicative
16:47:24 <Cale> hseg: Of course, now you can refactor that so that it just takes a Nat to begin with :P
16:47:33 <jcowan> Fair enough.  Can you give me an example of an Applicative that breaks?
16:47:36 <c_wraith> jcowan: Maybe happens to be commutative, so sure. It can't observe the order.
16:47:37 <Cale> hseg: and stop fucking around with the type system
16:47:38 <Cale> lol
16:47:40 <koz_> jcowan: Const is a popular one.
16:47:42 <hseg> :)
16:47:46 <c_wraith> jcowan: but IO can.  State can.
16:48:26 <hseg> thing is, i want to use quickcheck at the type level
16:48:38 <koz_> hseg: That... actual wat.
16:48:40 <dsal> jcowan: I don't know what you guys are talking about, but Tardis, probably.
16:48:42 <Cale> NO! STOP!
16:48:43 <Cale> lol
16:48:58 <Cale> You've gone too far
16:49:23 <{abby}> hseg: What the christ?
16:49:29 <hseg> specifically, i have a type :: Nat -> Type and want to test it satisfies a property for every Nat, by using the Arbitrary Natural instance
16:49:32 <c_wraith> jcowan: consider `traverse print :: Show a => Set a -> IO (Set ())`
16:49:44 <hseg> i don't _think_ i'm crazy?
16:49:56 <c_wraith> jcowan: how big is the output?  Does that size match the number of values it printed?
16:51:03 <koz_> hseg: What kind of property on _types_ are you trying to prove using a generator of _values_?
16:51:23 <dsal> Arbitrary Num?
16:51:25 <koz_> More concretely - how are you _stating_ said property on types?
16:51:43 <koz_> dsal: I wasn't aware that Arbitrary had kind Constraint -> Constraint.
16:51:44 <hseg> i'm tired and might not be making sense
16:51:47 <hseg> sorry
16:51:49 <jcowan> dsal: No worries, I barely know what I'm talking about either
16:52:03 <dsal> koz_: I just imagine that's the kind of thing that would be nice.
16:52:12 <{abby}> koz_: (Type -> Constraint) -> Constraint, surely.
16:52:23 <koz_> {abby}: You're right.
16:52:35 <koz_> I shouldn't open my mouth on type-related matters, clearly. :P
16:52:36 <hseg> am testing my Polynomial type satisfies ring laws
16:52:47 <hseg> for any number of indeterminates
16:52:52 <jcowan> c_wraith: Unless I am confused, I don't see how Set () can have more than one element.
16:52:58 <hseg> (indeterminates are Nat index)
16:53:05 <koz_> jcowan: This is exactly c_wraith's point.
16:53:08 <c_wraith> jcowan: you are correct.
16:53:13 <koz_> Your Traversable laws are now dead and bleeding in a ditch.
16:53:26 <hseg> (except these are Laurent polynomials, which i haven't found implemented anywhere) 
16:53:36 <hseg> *to my satisfaction
16:53:55 <koz_> hseg: As far as I'm aware, the ring laws are value laws.
16:54:06 <{abby}> hseg: so you want a KnownNat n => Arbitrary (Polynomial n) instance?
16:54:10 <koz_> Since those laws deal with _values_ of your Polynomial type, not the type itself.
16:54:15 <koz_> So I ask again. 
16:54:23 <koz_> How are you stating properties on types?
16:54:24 <hseg> koz_: yeah, i misspoke, sorry
16:54:33 <hseg> {abby}: yeah, but that part isn't hard
16:55:06 <hseg> {abby}: it's the "lift forAll (arbitrary @Natural) to typelevel indeces" that's causing me trouble
16:55:50 <koz_> hseg: So what you wanna do is test value laws against a range of different types?
16:55:57 <koz_> Yeah, QuickCheck ain't gonna help you any there.
16:55:57 <hseg> yep
16:56:21 <hseg> well, actually, once i get ghc to stop complaining about the current error, i should be ok
16:56:38 <koz_> Also, have you seen this? http://hackage.haskell.org/package/quickcheck-classes-0.6.4.0/docs/Test-QuickCheck-Classes.html#v:ringLaws
16:56:43 <hseg> (succeeded with the lifting with a little reflection and nudging)
16:56:43 <c_wraith> jcowan: for a more technical reason - an instance of Traversable can't place constraints on a, b, or f because those type variables don't appear in the instance head.
16:56:54 <koz_> Functor has the same issue.
16:57:01 <koz_> So you're dead even before you get to Traversable.
16:57:43 <hseg> koz_: yes, a little too late in my coding, and besides it wouldn't work with my types for unrelated reasons. thanks though
16:57:56 <koz_> hseg: Why wouldn't it?
16:58:07 <koz_> The Ring and Semiring type classes 100% exist.
16:58:24 <koz_> So what makes your types not workable with them?
16:58:35 <hseg> koz_: bc i'm not making use of them
16:58:43 <koz_> hseg: OK, and why not?
16:58:49 <koz_> I'm just curious.
16:59:21 <hseg> because i'm an idiot and sank way too much effort into this code without looking at alternatives, and reingeneering looks too painful
16:59:40 <koz_> hseg: So, Sunk Cost Fallacy. Got it. :P
16:59:45 <hseg> besides, which Ring/Semiring classes are you referring to besides kmett's and Num?
16:59:52 <hseg> :P
16:59:57 <koz_> Uhh, click the link?
17:00:11 <koz_> Ring and Semiring in the thing I linked you are links themselves.
17:00:17 <koz_> I hear that's how the Internet works these days.
17:00:21 <koz_> Something about hypertext.
17:01:21 <hseg> yeah, and the quickcheck-classes haddocks suck
17:01:32 <koz_> hseg: In what way?
17:01:54 <hseg> in that they have no indeces for anything except the main module and the IsList module
17:02:01 <hseg> they do have highlighted sources though
17:02:08 <koz_> What do you mean by 'indices'?
17:03:19 <hseg> https://hackage.haskell.org/package/quickcheck-classes-0.6.4.0/docs/src/Test.QuickCheck.Classes.Semiring.html exists, but not https://hackage.haskell.org/package/quickcheck-classes-0.6.4.0/docs/Test-QuickCheck-Classes-Semiring.html
17:03:42 <hseg> anyway, that 'semiring' package it uses actually looks useful
17:03:49 <jcowan> c_wraith: At least I understand that I don't understand, which is better off than I was before.
17:04:03 <dsal> jcowan: unknowing is half the battle
17:04:38 <koz_> hseg: ... I still don't follow. In the Haddocks, every laws generator is described, along with the laws it checks.
17:04:50 <koz_> Your complaint appears to be about hypertext hierarchies.
17:05:06 <hseg> i'm tired and am making little sense, sorry
17:05:24 <dsal> I kind of wanted to write some code today and thought about using polysemy or some other kind of free monads.  I looked at some example polysemy code and realized I don't know this language at all and should probably just write my code in haskell in the meantime.
17:05:45 <koz_> dsal: You've described my thought process vis a vis use of Polysemy exactly.
17:06:03 <dsal> I'm glad I'm not alone.  heh
17:06:03 <maerwald> no, it's not complicated enough, we need something more expressive
17:06:16 <koz_> maerwald: Needs more cowbell.
17:06:27 <hseg> btw, wish 'semirings' were better promoted - had only really seen kmettverse algebra packages before i began coding
17:06:33 <koz_> Also maerwald - any idea what could be causing the kind of compile error I pasted the other day?
17:06:45 <koz_> hseg: Agreed, it's not an ideal situation.
17:07:09 <maerwald> I'm only satisfied when I see the naked fear in the face of my coworker, trying to refactor my piece of code!
17:07:22 <koz_> maerwald: Are you, perchance, a C++ developer?
17:07:31 <hseg> maerwald: until we cannot get ghc to parse the entirety of the HoTT book, we have failed as a language
17:07:45 <maerwald> koz_: no, I value my sanity
17:07:52 <maerwald> I just want others to be insane.
17:07:59 <hseg> koz_: marked for future refactoring
17:08:12 <hseg> koz_: right now, i just want my code to work in time for my deadline
17:08:53 <koz_> maerwald: You're succeeding, because I have absolutely no clue why ghcup won't cross-comp properly, despite everything, and it's driving me a bit insane.
17:09:13 <maerwald> koz_: it is arch linux insanity
17:09:25 <koz_> maerwald: Arch has nothing to do with it.
17:09:29 <koz_> I'm using _nothing_ from it.
17:09:39 <koz_> Toolchain is local, GHC is local, LLVM is local.
17:09:49 <koz_> Blaming the distro is missing the point.
17:10:11 <maerwald> But your local libraries can smell the rotten piece of pacman!
17:10:15 <maerwald> :D
17:10:31 <koz_> maerwald: So 'I dunno lol'.
17:10:43 <koz_> Who'd be the person to ask who's intimately familiar with GHC's build process?
17:10:51 <koz_> I suspect it's one of those really obscure gotchas I keep tripping over.
17:11:08 <maerwald> I didn't even pass a single argument to configure and it just worked
17:11:20 <maerwald> But my toolchain is well and healthy
17:11:38 <koz_> maerwald: Are you on like, Debian or something? And were you trying to build 8.6.5?
17:11:49 <maerwald> No, exherbo, which has native cross support
17:12:07 <koz_> maerwald: So... Works on My Machine of the nth degree. :P
17:12:19 <koz_> Considering practically _no_ distro has cross support built-in.
17:12:27 <maerwald> Right
17:12:28 <koz_> And pretty much nobody can guarantee a fixed version of LLVM.
17:12:46 <koz_> I wanna figure this out, but I'm _completely_ out of my depth vis a vis the GHC build process.
17:12:49 <maerwald> koz_: oh, I didn't have the right llvm either, it just throws 30.000 warnings I ignore
17:12:54 <maerwald> and all is fine
17:12:55 <koz_> maerwald: Lol.
17:13:14 <koz_> Yeah, that's _not_ how I do things. And if you knew how many bugs I've found _just yesterday_, you would know why too.
17:13:20 <koz_> (namely, I find every bug with my face)
17:13:24 <koz_> (they're all super-obscure)
17:13:37 <koz_> (and it's always when I try to do something perfectly reasonable)
17:13:53 <koz_> Fun fact: I've managed to crash GHC itself.
17:13:56 <maerwald> Computers are just broken
17:14:08 <koz_> maerwald: No need to make the problem worse by ignoring warnings, lol.
17:14:21 <maerwald> The only thing more broken are my bones
17:14:51 <maerwald> koz_: the funny thing is... the warning isn't just there once, it's on link-time or something
17:14:57 <maerwald> so *EVERY* invocation spits it
17:15:07 <maerwald> if you watch the build log for too long, something changes inside you
17:15:29 <koz_> maerwald: But anyways, who should I ask about this?
17:15:45 <maerwald> I think we're the only ones left. We only have each other.
17:16:25 <Nolrai> So my quick check shrinks keep hanging, will using hedge hog instead help with this issue.
17:16:37 <Nolrai> ?
17:16:42 <dsal> Nolrai: shrinks are hard to get right.
17:16:46 <koz_> Nolrai: What's your definition of shrink?
17:17:40 <Rembane> Nolrai: Do you have any example code? Or rather, what are you trying to shrink? And how?
17:19:57 <Nolrai> https://pastebin.com/Fuh26X9g
17:20:01 <Nolrai> Is the example.
17:20:52 <dsal> You have to make sure it terminates on some input.
17:21:18 <koz_> Yeah, this will never terminate.
17:21:39 <dsal> > shrink 2325
17:21:41 <lambdabot>  [0,1163,1744,2035,2180,2253,2289,2307,2316,2321,2323,2324]
17:21:42 <maerwald> call the terminator
17:21:45 <dsal> > shrink 0
17:21:47 <lambdabot>  []
17:22:09 <dsal> Think of a zero value, make sure you emit it, and if shrink gets it, return []
17:22:43 <Nolrai> Do I just need some terminator, or do all paths need to terminate? 
17:22:54 <dsal> Well, this is the thing that's shrinking.
17:22:55 <koz_> There needs to be a _reachable_ set of terminators.
17:23:06 <koz_> Where reachable means 'from any value, with a finite number of shrinks'.
17:23:32 <koz_> I would also argue that your type is simple enough that shrinking is probably not needed.
17:23:33 <Nolrai> But there can still be a infinite path of shrinks?
17:23:39 <dsal> Notice how when int is shrinking, the first thing it spits out in all cases is its zero value.
17:24:19 <dsal> shrink "looking at strings might also help"
17:24:26 <dsal> > shrink "looking at strings might also help"
17:24:28 <lambdabot>  ["","s might also help","looking at string","at strings might also help","lo...
17:24:50 <dsal> > shrink "https://www.youtube.com/watch?v=Wn7RE8zycJQ"  -- relevant youtube video
17:24:50 <koz_> They're all 'structurally smaller'.
17:24:51 <lambdabot>  ["","om/watch?v=Wn7RE8zycJQ","https://www.youtube.cQ","w.youtube.com/watch?v...
17:25:09 <koz_> But honestly, in this case? I would just not bother having a defined shrink at all.
17:25:15 <koz_> Your type has four fields, all very small.
17:25:30 <koz_> You can probably easily determine why a test blows up from any instance of Gene.
17:25:43 <koz_> Shrinking is most useful for things that have variable length.
17:25:48 <koz_> (like lists, strings, trees, etc)
17:25:51 <koz_> s/length/size/
17:25:59 <koz_> Becuase then you get back a minimum reproducing example.
17:26:08 <koz_> Instead of something of ${TEXAS} size.
17:26:12 <dsal> haha
17:26:27 <wikiemol> Hello, can anyone point me to a resource that tells me how to configure stack to include c header files while building? Including how to specify the c compiler and options? 
17:26:31 <Nolrai> Yeah, weight used to be a double, and I got irritated by random large ints for the first two feilds.
17:26:48 <koz_> Nolrai: Modify your arbitrary instance?
17:26:56 <Nolrai> But its not like `maxBound @ Int` is that big.
17:26:56 <koz_> s/instance/method/
17:27:04 <koz_> Can the field _really_ have _any_ Int AT ALL?
17:27:08 <koz_> I somehow doubt that.
17:27:27 <koz_> If you have internal invariants, your arbitrary definition should honour those.
17:27:59 <Nolrai> I mean techinicaly no..but they are hashes so without either context or a much better understanding of the hash function?
17:28:24 <koz_> Then you can have your arbitrary method generate basically whatever range you feel like.
17:28:27 <koz_> So generate 1 to 10.
17:28:35 <koz_> If you have no context, then what difference does it make?
17:28:41 <koz_> You can't write properties against 'lol is number'.
17:29:24 <Nolrai> Hmm. I wanted to be able to test the shrinking function! >.<
17:29:27 <dsal> There's also a generic recursive shrink.
17:29:32 <hseg> ok, so the quickcheck test run! still need to comb out all the bugs it catches, but it's a start
17:29:35 <dsal> It'd probably work well for this.
17:29:49 <bob7djyf> To the chief Musician, A Psalm of David. The fool hath said in his heart, There is no God. They are corrupt, they have done abominable works, there is none that doeth good.
17:29:52 <koz_> dsal has a good idea here - I would be _super_ careful of that thing in self-recursive ADTs.
17:29:57 <koz_> Since it has no termination or limit.
17:30:09 <hseg> however, it's late, i'm tired, and i guess i'll just have to make my excuses and face the music tomorrow
17:30:10 <koz_> bob7djyf: This is #haskell, not #bible.
17:30:14 <bob7djyf> Jesus is KING OF KINGS, AND LORD OF LORDS, He is The Way, The Truth, and The Life, He is Beautiful, Beautiful, Beautiful! Jesus Christ Loved you to die for you, you can have a relationship with Him, He says, "And ye shall seek Me, and find Me, if ye shall search for Me with all your heart." - Jeremiah 29:13. I hope you have a Beautiful day today,
17:30:15 <bob7djyf> you can have True Overwhelming Peace and Joy in your soul, only with Jesus Christ! May Jesus Bless you and your family!
17:30:26 <hseg> thanks everyone, and good night!
17:30:52 <Nolrai> Bob7djyf: learn to troll better.
17:31:08 * dsal wonders if Jesus bots are actually trying to make people hate Jesus
17:31:09 <bob7djyf> I care for your soul, you can have Beautiful Life with Jesus Christ, alleluia!
17:31:26 <dsal> Speaking of ale... I may be intoxicated enough to write a server.
17:31:28 <maerwald> But I'm a pagan.
17:31:46 <koz_> @where ops
17:31:46 <lambdabot> byorgey Cale conal copumpkin dcoutts dibblego dolio edwardk geekosaur glguy jmcarthur johnw mniip monochrom quicksilver shachaf shapr ski
17:31:50 <dsal> maerwald: You can be saved, just C-x C-s
17:31:53 <maerwald> lol
17:32:11 <koz_> dsal: What kinda server?
17:32:15 <koz_> A WEB SERVER PERHAPS
17:32:23 <maerwald> dsal: I do not succumb to this sorcery, which you call emacs
17:32:28 <fragamus> hi is Elm really just Haskell in disguise
17:32:36 <koz_> If so, call it hengnx.
17:32:39 <dsal> maerwald: Oh, so it's a religious war?
17:32:47 <koz_> (yes, the Japanese pun was intended)
17:32:53 <Rembane> fragamus: No, but it looks like Haskell.
17:32:54 <dsal> koz_: mqtt.  :(  I think I didn't want to do this, but maybe.
17:33:02 <dsal> mqtt is pretty complicated.
17:33:13 <maerwald> dsal: I've probably seen 4 haskell implementations of it
17:33:14 <fragamus> Rembane: yeah it sure does
17:33:16 <maerwald> one proprietary
17:33:17 <dsal> I use it hard enough to find every obscure bug mosquitto has to offer.
17:33:42 --- mode: ChanServ set +q *!*@c-76-23-218-162.hsd1.me.comcast.net
17:33:52 <maerwald> wonder why it's so popular
17:33:57 <dsal> maerwald: Most mqtt implementations I've seen have failed to tackle v5.  It'd be good to not actually write such a thing.
17:34:05 <dsal> It's a pretty good protocol overall.  I use it quite heavily.
17:34:26 <koz_> dsal: Yeah, I think you need it for monadically controlling your car.
17:35:04 <dsal> Yeah, and a bunch of other stuff.  I walked into my house about an hour ago and said, "OK Google, turn on the 3d printer" -- that went through some of my mqtt haskell junk, I'm pretty sure.
17:35:24 <koz_> dsal: Next up, HouseT monad transformer.
17:35:29 <dsal> ...actually, it's possible that one case doesn't.
17:35:51 <dsal> I need more grid tie stuff, then I could have a TransformerT
17:36:00 <koz_> instance (MonadError HouseOnFire m) => MonadError HouseOnFire (HouseT m)
17:37:02 <dsal> I made a pretty cool thing to operate my gate remotely.  Actually, "cool" isn't the right word.  Definitely lazy.  I took apart an old remote and made a little thing that electrically presses the button on the remote when I send a particular MQTT message.  That transmits a signal to my gate to open it.
17:37:33 <koz_> dsal: 'Smarter Home With Haskell' blog post when.
17:37:41 <dsal> I'm confident I've written the best mqtt *client* in haskell.  But there's a lot for brokers to keep up with.
17:38:34 <dsal> https://usercontent.irccloud-cdn.com/file/lUCZtDi8/packet+loss.jpg
17:38:39 <dsal> This thing is showing packet loss...
17:39:43 <xsperry> program interface question: I can start my program "normally", and then it collects the data, or I can start it in webserver mode, and then it creates a webserver that displays the collected data. the webserver is started with --webserver option. subsequent options are completely different than without the --webserver flag. do you think this is confusing, and that I should just have two different executables?
17:40:24 <maerwald> I think I'm writing an MUA in haskell.
17:40:35 <Rembane> xsperry: You can have the same executable but two different subcommands. 
17:40:47 <dsal> xsperry: That's exactly my gopro command.
17:40:52 <maerwald> I tried out this thing called mutt today, and thought: wow, such terminal, many C, must be fast. And realised it takes 90s to load my mailbox (compared to 3s thunderbird).
17:41:11 <p0a> maerwald: really? wow
17:41:21 <koz_> maerwald: mutt is a nightmare to configure.
17:41:22 <maerwald> I'm sure I can do better with naive haskell code.
17:41:33 <koz_> But I suspect you are right.
17:41:35 <maerwald> koz_: the configuration isn't the problem, but the abyssmal performance
17:41:37 <dsal> xsperry: Though I ended up tying monadlogger into websockets so I could log to the web browser and moved more of my CLI stuff there.
17:41:45 <koz_> maerwald: The two are connected intimately.
17:41:50 <maerwald> it even blocks the entire UI on download
17:42:04 <maerwald> nothing is async, nothing is lazy, the hashing is poor
17:42:08 <koz_> xsperry: Have 'foo webserver' and 'foo normal'. Kinda like stack.
17:42:12 <koz_> maerwald: 80s design yo.
17:42:22 <koz_> This is the future Rob Pike wants.
17:42:53 <Nolrai> Who's Rob Pike?
17:43:07 <koz_> Nolrai: Famous 80s C person, and the guy behind Go.
17:43:20 <maerwald> koz_: make no mistake, there's "aerc", a terminal MUA written in Go.
17:43:24 <maerwald> And it is the fastest.
17:44:06 <xsperry> koz_ ah, so make webserver|normal the first argument, and then have two different set of options? I'm using optparse applicative. I think I could massage it into accepting --webserver, but webserver or normal first argument seems cleaner
17:44:08 <dsal> plan9 was pretty rad.
17:44:16 <xsperry> dsal, Rembane, is that what you had in mind?
17:44:26 <koz_> xsperry: It's similar to what stack does, for example.
17:44:30 <koz_> Or, in fact, cabal-install!
17:44:36 <dsal> xsperry: https://github.com/dustin/gopro/blob/master/app/Main.hs#L78-L98
17:44:51 <koz_> Since you have 'stack build --some-option --stop-snoyman-from-opinionating-the-build ...'
17:45:10 <koz_> But also 'stack ide ...', and so on.
17:45:15 <koz_> All with different flags.
17:45:37 <koz_> I'm pretty sure optparse-applicative supports this design.
17:45:45 <koz_> s/this design/this kind of design/
17:45:48 <koz_> But I'm no expert on it.
17:46:10 <dsal> I didn't go as far as to make arguments for my subcommands.  Most of them are the same... -u for upload concurrency, -d for download concurrency, etc...
17:46:23 <dsal> I have a few weird ones but nobody uses gopro plus but me, so I'll live with it.
17:46:29 <xsperry> it doesn't even need to support it, I could just case on args, and run two different optparse-applicative parsers
17:46:34 <maerwald> yes, you can do everything with optparse-applicative, except monadic parsers
17:46:58 <maerwald> so your parsers are all fixed, just the values are dynamic
17:47:28 <koz_> maerwald: Hence optparse-_applicative_.
17:47:32 <maerwald> yes
17:47:35 <koz_> And not 'optparse-monadic'.
17:47:43 <koz_> Or 'optparse-arrowized'.
17:47:56 <dsal> I parse my args first, and then take the first leftover as new argv[0], and leave the rest as an exercise for the Reader
17:48:26 <koz_> Tired: optparse-applicative; Wired: optparse-monadic; Inspired: optparse-categorical.
17:48:30 <Nolrai> @kos yep its nice an easy! I could paste up my options parser if someone is interested.
17:48:30 <lambdabot> Maybe you meant: yow docs do
17:48:32 <solonarv> optparse-applicative in fact has *explicit support* for subcommands
17:48:40 <solonarv> you don't even need to kludge it together
17:48:59 <xsperry> solonarv cool, I'll take a look
17:49:26 <maerwald> In the end, optparse-applicative isn't really declarative though
17:49:42 <dsal> solonarv: aww man, I already kludged it together.
17:49:49 <maerwald> I still miss a proper declrative style library, such as pythons 'click'
17:50:00 <Nolrai> Whats the difference?
17:50:00 <solonarv> example from the docs: https://hackage.haskell.org/package/optparse-applicative-0.15.0.0/docs/Options-Applicative.html#v:command
17:50:50 <dasli> is anybody familiar with the technique of a rank-2 type that quantifies a phantom type, as described here? http://www.scs.stanford.edu/11au-cs240h/notes/laziness.html
17:51:53 <koz_> dasli: What's the question you wanna ask?
17:52:33 <dasli> I am trying to abstract my application over GPipe, which uses this technique. It seems that, by intention, my application can abstract everything except this phantom type.
17:55:00 <dasli> My question is whether there is any known approach to handling monadic actions with a phantom type parameter other than just letting them be your whole application.
17:55:17 <koz_> dasli: Could you give a small example of what you're being blocked from doing?
17:55:22 <koz_> It's a bit vague at the moment.
17:55:23 <dasli> I'd prefer to have my application traffic in these actions, but in order to do so the application needs to have this quantified type parameter.
17:55:26 <dasli> Yeah I understand
17:57:51 <dasli> Consider that example I posted. What if I wanted to store those database actions in my own data type?
17:58:09 <koz_> What example?
17:58:19 <koz_> There's lots of code in laziness.html.
17:58:19 <dasli> Is there any way to do so without the data type including that type parameter?
17:58:38 <dasli> withConnection :: Pool
17:58:38 <dasli>                -> (forall c. SafeConn c -> DB c a) 
17:58:38 <dasli>                -> IO a
17:58:54 --- mode: ChanServ set -q *!*@c-76-23-218-162.hsd1.me.comcast.net
17:59:26 <koz_> Ah, and you're saying 'I want MySafeConn rather than SafeConn c everywhere'?
17:59:43 <dasli> Basically, yes.
17:59:54 <dasli> So that I can plug in some other implementation of MySafeConn
17:59:55 <koz_> You can do that, but you probably don't want to.
18:00:01 <koz_> Do you know what purpose this c serves?
18:00:08 <koz_> Specifically why we need that rank-2?
18:00:26 <dasli> It's supposed to prevent what I'm trying to do, I think. :)
18:00:49 <dasli> Otherwise I don't fully grasp it.
18:00:55 <koz_> OK.
18:01:03 <koz_> Have you read the paper 'Lazy Functional State Threads'?
18:01:09 <koz_> It explains this in a very specific situation.
18:01:12 <koz_> (namely mutable state)
18:01:26 <koz_> I consider _that_ to be the best explanation of the 'why'.
18:01:28 <dasli> I have not, though I was looking at that title today.
18:01:31 <ski> `MySafeConn' being `exists c. SafeConn c' ?
18:01:34 <koz_> After you've read that, then you'll know.
18:02:42 <dasli> ski: I would want to abstract my application over the implementation of connections.
18:02:48 <dasli> safe connections or otherwise
18:02:55 <sm[m]> hey all.. https://haskell.zettel.page is a zettelkasten thing for haskell docs. There's another thing of this kind that's been going for a few years, collecting links etc. Would you remember where it is ?
18:03:16 <sm[m]> (not the wiki)
18:03:19 <ski> are there other connection types, than `SafeConn' and `MySafeConn' ?
18:03:40 <p0a> to have -XTypeFamilies on my projects
18:03:52 <p0a> I added it to ghc-options but I'm getting some warnings 
18:04:05 <dasli> Possibly. I'm thinking two years down the line and MySafeConn doesn't compile with the latest GHC anymore.
18:04:08 <p0a> instead suggesting to add it to individual files; but I want to be able to do `stack repl' afterwards. Shouldn't I keep it there?
18:04:25 <p0a> This is about `stack' by the way
18:04:34 <dasli> sorry *SafeConn*
18:04:34 <sm[m]> p0a, in the files is most robust, that way all tools will use it
18:04:46 <sm[m]> also it helps with code readability
18:04:54 <ski> why not, dasli ?
18:05:09 <p0a> sm[m]: thanky ou 
18:05:26 <dasli> koz_: thank you
18:05:29 <sm[m]> and it's more localised, you can turn it on only in files which need it
18:05:51 <p0a> sm[m]: but every time I use stack repl I need to do --ghc-options -XTypeFamilies
18:05:51 <p0a> right?
18:05:57 <dasli> ski: there are many reasons I might want to use a different implementation
18:06:18 <sm[m]> no, stack repl runs ghci which (like all the tools) will honour LANGUAGE pragmas in the source file
18:06:20 <dasli> compatibility, features, etc.
18:06:24 <ski> different implementation than what ?
18:06:48 <dasli> than whatever decided it needed this rank-2, phantom type thing
18:06:55 <ski> and why would changing implementation cause `SafeConn' to not compile ?
18:07:10 <ski> mhm
18:07:11 <p0a> sm[m]: okay, thank you 
18:07:32 <ski> it seems to me, that is not (only) part of the implementation, but also of the offered interface, then
18:07:36 <xsperry> optparse-applicative has very nice support for subcommands
18:09:03 <sm[m]> p0a: doc: https://downloads.haskell.org/ghc/latest/docs/html/users_guide/glasgow_exts.html#language-options
18:09:43 <p0a> nice
18:10:02 <sm[m]> darn, wish I could remember that collaborative haskell docs/links site
18:11:18 <sm[m]> it's completely unlinked from haskell.org, of course
18:13:38 <sm[m]> and from the wiki, AFAICT. Small wonder it hasn't caught on.
18:16:14 <dasli> koz_: is everything that touches the type |ST s a| bound to retain the parameter |s|, lest it possibly not match the parameter |s| in |runST :: (forall s . ST s a) -> a|?
18:16:53 <dasli> there's no way to retain |ST s a| actions in a type that's agnostic to |s|?
18:17:36 <koz_> dasli: Basically, the 's' parameter ensures that the mutability is confined.\
18:17:51 <koz_> The (forall s. ST s a) -> a basically says two things.
18:18:05 <koz_> One is that 's' cannot be referred to outside of the bracketed part.
18:18:17 <koz_> So if you tried to run something like
18:18:24 <koz_> ST s (STVar s a)
18:18:32 <koz_> The type system would yell at you until you stopped.
18:18:53 <koz_> The other is that we can't even _talk about_ that s.
18:19:54 <ski> dasli : "agnostic" meaning ?
18:20:04 <dasli> interesting
18:20:15 <koz_> So for example, if we had (forall s . SafeConn s -> a) -> a, even if we tried to make s ~ a, the type system wouldn't let us!
18:20:16 <dasli> it fits with what I've read so far elsewhere
18:20:30 <koz_> The whole point of this is to ensure that 's' doesn't 'leak' anywhere.
18:20:36 <ski> dasli : it would be possible to, in some circumstances, to encapsulate the `s', so that it doesn't appear in the type
18:20:38 <koz_> And that's what enables ST (and in fact, IO) to do its thing.
18:21:13 <siraben> Working with raw OpenGL bindings, how do I allocate a Ptr GLint?
18:21:27 <koz_> siraben: Which package is this?
18:21:27 <siraben> In C it would be, int x = 0; doSomething(&x)
18:21:45 <siraben> koz_:  https://hackage.haskell.org/package/OpenGLRaw
18:21:54 <dasli> koz_: thanks
18:22:16 <dasli> I like that I can't do wrong things, but it really sucks when the right thing is not at all obvious.
18:22:21 <dasli> But this helps.
18:22:33 <koz_> dasli: Well, maybe it might help if you showed us what you're trying to do.
18:22:37 <koz_> As in, specific to your case.
18:22:44 <koz_> And then told us what it was that was blocking you.
18:22:59 <koz_> We're living in abstract-land right now, so without more specific information, we can't tell what issue you're having.
18:23:26 <koz_> siraben: What are you aiming to do here?
18:23:53 <siraben> glGenBuffers :: MonadIO m => GLsizei -> Ptr GLuint -> m ()
18:24:00 <siraben> I need a Ptr GLUint lying around somewhere
18:24:17 <koz_> What does it represent conceptually? Maybe there's another function that gives it to you?
18:24:22 <koz_> Or is it an out-param in the original C or something?
18:25:34 <siraben> So the C would look like
18:26:05 <siraben> GLUint VBO; glGenBuffers(1, &VBO)
18:26:13 <koz_> Yeah, so it's an out-param.
18:26:24 <koz_> Hmm.
18:27:03 <dasli> GPipe has to be my application. There's no way to use it as a library, sending and receiving data from it.
18:27:04 <koz_> https://hackage.haskell.org/package/base-4.12.0.0/docs/Foreign-Marshal-Alloc.html should have you covered.
18:27:17 <koz_> dasli: What's GPipe?
18:27:24 <dasli> Except in its ContextT Handle os IO monad
18:27:26 <dasli> https://hackage.haskell.org/package/GPipe
18:28:07 <koz_> Yep, definite ST trick use there.
18:28:12 <koz_> SO what's it stopping you from doing?
18:28:20 <dasli> |runContextT| has a rank-2 type in order to prevent any GPU resources from getting retained or the GPU state from being messed with.
18:28:32 <siraben> koz_:  Any thoughts?
18:28:37 <siraben> There's no newIORef equivalent for Ptr
18:28:44 <koz_> siraben: https://hackage.haskell.org/package/base-4.12.0.0/docs/Foreign-Marshal-Alloc.html
18:28:54 <koz_> That should have you covered, probably by way of alloca.
18:29:07 <dasli> It's stopping me from writing my application code without referring directly to the type ContextT Handle os IO
18:29:29 <koz_> Yeah, it's a concrete monad stack.
18:29:33 <koz_> This is exactly what you'd expect.
18:29:34 <ski> @type Foreign.Marshal.with
18:29:36 <dasli> I essentially want to request texture handles from it
18:29:37 <lambdabot> Foreign.Storable.Storable a => a -> (GHC.Ptr.Ptr a -> IO b) -> IO b
18:29:53 <dasli> And then send them back when my app decides to draw them
18:30:08 <dasli> Through some abstract interface that could change if I decide I can't use GPipe anymore
18:30:09 <koz_> dasli: Is there no function in GPipe which does this?
18:30:19 <koz_> Ah, OK.
18:30:20 <dasli> There is but the abstract interface is the killer
18:30:26 <koz_> Yeah... there's really no hope for you in that.
18:30:33 <koz_> The stack GPipe uses is rather specific.
18:30:39 <koz_> And it's designed in a rather specific way.
18:30:47 <dasli> FART
18:30:52 <koz_> So an attempt to use 'something else' would require _considerable_ regrafting.
18:31:01 <koz_> Why are you worried about changing it later?
18:31:36 <koz_> ski: What's the first argument of 'with' meant to be?
18:31:45 <koz_> Is that just a constant value?
18:31:52 <ski> intitialized value
18:31:56 <koz_> Ah, OK.
18:32:08 <dasli> Well one reason is that it's stuck on OpenGL 3
18:32:12 <dsal> Well, I published a message.  Time to disrupt the IoT industry.
18:32:17 <ski> @type Foreign.Marshal.Utils.maybePeek
18:32:21 <lambdabot> (GHC.Ptr.Ptr a -> IO b) -> GHC.Ptr.Ptr a -> IO (Maybe b)
18:32:32 <koz_> ski: Why that over alloca? That's an out-param, so it should get filled unless something explodes.
18:32:38 <sm[m]> go dsal
18:33:26 <koz_> dasli: If _that_ is a concern, then perhaps you shouldn't use it to begin with.
18:33:41 <koz_> Abstracting something like this is a whole other problem.
18:33:52 <dsal> Man.  Doing even the part I've done so far correctly is an oververt battle.
18:34:05 <xsperry> how can I make optparse-applicative list all the available commands when the command option is missing, instead of just printing "Missing: COMMAND"?
18:34:07 <ski> @type Foreign.Marshal.alloca
18:34:11 <lambdabot> Foreign.Storable.Storable a => (GHC.Ptr.Ptr a -> IO b) -> IO b
18:34:16 <ski> yea, probably better, koz_
18:34:20 <Nolrai> Why does haskell use "case"/"of" and not "match"/
18:34:21 <dasli> Well I think I could manage it with something like SDL and the raw OpenGL bindings
18:34:26 <Nolrai> "on"?
18:34:42 <koz_> ski: Though I will admit, proper initialization is likely better.
18:34:43 <dsal> What's wrong with case?  Matches are dangerous.
18:35:06 <koz_> dasli: Or like, Vulkan maybe?
18:35:11 <koz_> Since modernity appears a concern.
18:35:11 <Nolrai> I just forget sometimes, and I never forget the other way.
18:35:21 <koz_> (there's a library for that too!)
18:35:21 <dasli> I have this nice interface going based on abstracting from a previous SDL-based application.
18:35:45 <dasli> I think a lot of libraries could be abstracted, and I basically abstracted GPipe except for this phantom variable.
18:36:08 <koz_> dasli: You could just add that same kind of thing to your abstraction?
18:36:17 <dasli> So I was wondering am I missing something subtle? It seems the answer is no, it's not meant to work this way.
18:36:26 <koz_> Like, you can just cart around an extra phantom type variable, surely?
18:36:32 <dasli> Yeah that's what I did
18:36:47 <ski> Nolrai : it's `match'-`with' in OCaml. but SML still has `case'-`of'
18:37:02 <koz_> ski: I guess Haskell got it from ML?
18:37:25 <ski> (which ML ? the original one ?)
18:37:30 <koz_> (yes)
18:37:31 <dasli> I guess it's fine, but it's the sort of complexity I'm trying to hide.
18:38:08 <Nolrai> xsperry I..was going to say something but cant remember now.
18:38:44 <xsperry> prog --help prints them, but it would be nice if they were also printed when running prog without any options
18:39:10 <dasli> koz_: thank you very much
18:48:11 <dmwit> ?tell hseg I mean, the main thing is just making sure the data family you want to derive your instance for is coercible to the type that already has the instance. If you're using `newtype instance` that should be easy, I think?
18:48:11 <lambdabot> Consider it noted.
19:00:05 <Nolrai> I kind of wish there was a opperator for show and append.
19:00:11 <Nolrai> I guess I could make one.
19:00:28 <koz_> Nolrai: append as in ++?
19:00:38 <koz_> Or as in snoc?
19:00:50 <Nolrai> Well "<>"
19:01:03 <koz_> You need something shorter than <>?
19:01:09 <ski> > 42 `shows` "bar"
19:01:14 <lambdabot>  "42bar"
19:01:24 <koz_> :t shows
19:01:29 <lambdabot> Show a => a -> ShowS
19:01:30 <Nolrai> No I want something shorter then `<> show`
19:01:35 <Nolrai> Huh.
19:01:39 <koz_> Yeah, TIL.
19:01:47 <koz_> Because I think ShowS is a type synonym.
19:01:51 <koz_> :info ShowS
19:01:56 <ski>   type ShowS = String -> String
19:02:13 <koz_> So shows is actually a -> String -> String, wow.
19:02:43 <Nolrai> Huh, but I usually have the string at the front.
19:02:51 <Nolrai> like I want 
19:03:56 <ski> > "foo" ++ 42 `shows` "bar"
19:04:02 <lambdabot>  mueval-core: Time limit exceeded
19:04:08 <ski> @slap lambdabot
19:04:08 * lambdabot moulds lambdabot into a delicous cookie, and places it in her oven
19:04:17 <ski> > "foo" ++ 42 `shows` "bar"
19:04:24 <lambdabot>  mueval-core: Time limit exceeded
19:04:30 * ski sighs
19:04:37 <ski> <lambdabot>  "foo42bar"
19:04:40 <ski> i got, in PM
19:10:33 <hololeap> Never realized lambdabot had a gender until now
19:10:45 <hololeap> Or maybe it's like a ship
19:10:56 <Nolrai> I mean ships have genders.
19:14:30 <hololeap> Which part of the ship do I look at to tell?
19:15:39 <Nolrai> They have linguistic genders, not biological sexes.
19:15:48 <Nolrai> <-- is being a bit pendantic.
19:16:09 <hololeap> lol
19:16:33 <maerwald> what's a linguistic gender?
19:17:25 <siraben> glShaderSource :: MonadIO m =>GLuint -> GLsizei -> Ptr (Ptr GLchar) -> Ptr GLint -> m ()
19:17:33 <siraben> So I have a Haskell string, how do I get a pointer to a pointer to it?
19:17:45 <siraben> There's withCString :: String -> (CString -> IO a) -> IO a
19:18:07 <xsperry> you want char **, in C terms?
19:18:31 <siraben> Yes
19:19:30 <siraben> dasli: Are you working with raw OpenGL too?
19:20:15 * hackage calamity 0.1.4.3 - A library for writing discord bots  https://hackage.haskell.org/package/calamity-0.1.4.3 (nitros12)
19:20:59 <MarcelineVQ> hololeap: the ladies have two props
19:23:19 <Nolrai> maerwald: its the traditional term for a "noun category", e.g. how its "la mesa" but "el plazo". The connection to gender as in gender idenity is that most european languages have either "Masculine/Feminine" or "Masculine/Feminine/Neuter" noun systems.
19:23:50 <hololeap> or perhaps the males died out long ago and the species reproduces asexually at this point
19:24:58 <Nolrai> But linguistic use came first, and it was only later used as a polite word for sex, and then for sexual presentation.
19:26:26 <siraben> I managed to do it
19:26:29 <siraben> http://ix.io/2ky3
19:26:34 <maerwald> categorising lambdabot as a noun is at least micro-agression
19:26:34 <siraben> Anyone have suggestions on refactoring this code?
19:27:35 <Iceland_jack> siraben: -XBlockArguments (https://ghc.gitlab.haskell.org/ghc/doc/users_guide/exts/block_arguments.html?highlight=blockarguments#extension-BlockArguments) would immediately shave of a few bucks
19:29:07 <hololeap> I wonder if the phallic rocket from Austin Powers could classify as a "he"
19:29:17 <Iceland_jack> I would probably lower the indentation, I don't know the domain so I mostly have feedback layout 
19:30:41 <solonarv> p0a: if you want to enable a language extension everywhere, you can also put it in a 'default-extensions' field
19:30:54 <solonarv> siraben: oh, you're doing the same thing I am!
19:30:59 <Iceland_jack> but I would avoid shadowing 'vertices'
19:31:06 <solonarv> note that it's perfectly fine to define a bunch of utility functions
19:31:40 <solonarv> I am getting a lot of mileage out of 'allocaPeek inner = alloca $ \ptr -> do inner ptr; peek ptr' (which makes out-params less painful)
19:32:24 <solonarv> you also don't have to allocate all the pointers up front
19:33:04 <hololeap> siraben: breaking the code up into (sub)functions would help the readability. The line `\s -> do` could be changed to `\s -> alloca $` (e.g. remove that do)
19:33:18 <siraben> What about rewriting in continuation passing style?
19:33:25 <solonarv> eh
19:33:25 <siraben> With the Cont monad, I mean
19:33:55 <solonarv> can be done, but again you don't actually need the pointer to live particularly long when you're using it as an out parameter
19:34:08 <solonarv> for comparison here is my (untested) shader loadign code: https://github.com/Solonarv/perfect-flow/blob/master/gl-utils/Graphics/GL/Shaders.hs
19:34:10 <ski> hololeap : there was a vote, in which the image on <https://wiki.haskell.org/Lambdabot> was decided. atm i can't find the original page with it, though
19:34:55 <Iceland_jack> Codensity or https://hackage.haskell.org/package/managed also fit
19:38:04 <hololeap> ski: Oh, right... I remember seeing that picture before
19:38:14 * hackage typed-encoding 0.2.0.0 - Type safe string transformations  https://hackage.haskell.org/package/typed-encoding-0.2.0.0 (rpeszek)
19:41:07 <siraben> http://ix.io/2ky9
19:41:16 <siraben> oof
19:53:52 <Nolrai> > 339466990083890198 == 339748469858739839
19:53:58 <lambdabot>  False
19:54:50 <MarcelineVQ> lgtm
19:55:02 <Nolrai> :t elem
19:55:06 <lambdabot> (Foldable t, Eq a) => a -> t a -> Bool
19:55:47 <Nolrai> > 339748469858739839 `elem` [6,281488499309167,339466990083890198,339748469858739839,340592909720563122,-2857642056496775827]
19:55:53 <lambdabot>  mueval-core: Time limit exceeded
20:08:11 <dmwit> siraben: It does seem like ContT would help with that.
20:09:55 <Nolrai> What would ContT help with?
20:11:24 <{abby}> Nolrai: this http://ix.io/2ky9
20:11:28 <siraben> The whole with.* mess
20:14:22 <MarcelineVQ> siraben: or Codensity, or packaged up Codensity http://hackage.haskell.org/package/managed
20:33:21 <dsal> Weird, if I create a new env with new TVars for every connection, they don't share state.
20:33:51 <Nolrai> Okay, I am picking a key from a IntMap, then looking up the value at that key and getting Nothing, wtf? https://pastebin.com/1uhiYrU7
20:34:15 <Nolrai> dsal: isn't that what you would expect?
20:34:28 <dsal> Nolrai: heh.  Apparently that's not what I would expect.
20:34:36 <dsal> Actually, I think I just didn't quite understand how this thing was launching my bits.
20:47:58 <solonarv> yes, ContT / Codensity would help with this nesting.
20:48:16 <solonarv> but I repeat that you do not need the pointer created by 'alloca' to last all that long
20:48:53 <solonarv> you are just using them as parameters to one function call. it is fine if the pointers become invalid after that function call (and possibly a peek).
20:49:27 <solonarv> so you don't have to stuff the entire rest of the program into the continuation. just one GL function call (and maybe a peek(.
20:52:37 <siraben> Right, that's true. I'll refactor.
20:53:10 <siraben> solonarv: What are you working on wrt. OpenGL + Haskell?
20:58:17 <solonarv> I'm making a game with a home-grown engine (that I am building in parallel)
20:59:32 <solonarv> the engine is going to use OpenGL for rendering, but also be built on top of reflex (a FRP framework)
21:13:27 <Nolrai> God damn it this bug doesn't show up in my tests, but does super fast in the actual use case.
21:19:06 <siraben> solonarv:  Nice. Is it public?
21:20:23 <siraben> Dang where is ekmett, the code slide 8 does not work, right? https://www.slideshare.net/ekmett/bound-making-de-bruijn-succ-less
21:20:26 <siraben> b is free
21:20:43 <hololeap> I was working on a 2d game engine using gloss and reflex; It's still in the works but the original code was lost in a crash
21:25:57 <hololeap> It uses a type that I just call Object, which is essentially `Event t InputEvent -> Behavior t (Picture, SubObjects)`
21:31:55 <solonarv> siraben: yes, but it's nowhere close to being usable (even by me)
21:31:56 <solonarv> hang on
21:32:10 <solonarv> siraben: https://github.com/Solonarv/perfect-flow/
21:32:50 <solonarv> I was at the point where I had a clickable button that cycled colors on click (as a demo, basically)
21:33:04 <solonarv> but that was using SDL's 2D rendering, which is a bit limited
21:33:10 <solonarv> so I tossed it out and broke everything :P
21:33:53 <siraben> Ah I see.
22:42:22 <koz_> siraben and possibly solonarv: Thanks for taking me on another Edward Kmett wild ride.
22:42:47 <koz_> Maybe I'm just going a bit mad from this lockdown, but I felt I actually _understood_ more than 50% of the Edward Kmett talk I found.
22:43:28 <koz_> As a fun aside, I learned why supercombinators are what GHC uses, instead of the combinator calculus.
22:44:14 <dasli> which talk?
22:45:02 <edwardk> guessing one from zurihac based on that lead-in
22:45:26 <koz_> edwardk: Yep. Brilliant, as ever.
22:45:40 <edwardk> https://www.youtube.com/watch?v=KzqNQMpRbac
22:46:03 <koz_> One thing that eludes me - how do you make the conceptual leap from 'combinator calculus' to 'GPUs' there?
22:47:13 <koz_> You had the section on SPMD-on-SIMD, but I didn't quite follow how we got there from combinator calculus.
22:47:21 <edwardk> don't remember the leap i made. the main thing was  that if you have a small combinator basis then you can get 'back' to a common state after each reduction
22:48:44 <edwardk> the spmd-on-simd stuff is good at maintaining throughput as long as control doesn't diverge
22:48:50 <koz_> Ah, I see.
22:49:07 <edwardk> doing "normal" programs that way doesn't work so well, as you lose coherence every if/case, etc.
22:49:07 <koz_> So because we 'get back to a common state' after each reduction, we don't end up needing to branch?
22:49:11 <edwardk> yeah
22:49:27 <edwardk> so you get no loss due to branching factor after each instruction
22:49:51 <koz_> Suppose we're in SKI (to keep things simple). What would such a common state look like?
22:49:52 <edwardk> and can have 8 or 32 or 64 reductions happening per warp depending on the target
22:50:47 <koz_> I guess the bit that's throwing me is that I see a combinator-compiled program as a DAG, and so I can't see how you get _that_ much reduction parallelism.
22:55:21 <edwardk> well, you're going to do a batch of reductions, so first look at the top of each to see if it is an application node. if not go this site is done, grab another and bail out. now that we're looking at applications, look at their left child, what is it? If 'I' then next iteration we'll be reducing the right hand child instead, so update the top to aim there. If it isn't check if its an app, if it is, look left again, check for K, repeat do 
22:55:21 <edwardk> S, etc.   (I x) vs (K x) y  vs. ((S x) y) z  -- once you've done one reduction, go back to the top, but everyone has a reduction to do
22:56:05 <edwardk> I can give you seq and par combinators to help get additional reduction opportunities
22:56:07 <koz_> Ah, I get ya.
22:56:21 <koz_> So basically, we are looking at a 'slice' of the DAG at once.
22:56:28 <koz_> And then we reduce the whole 'slice' at once.
22:56:46 <edwardk> yeah, how many SIMD lanes do we have, we can do that many reductions at once in perfect lockstep
22:56:49 <edwardk> rather than one per thread
22:57:07 <koz_> How wide does each lane have to be?
22:57:53 <edwardk> well, lets just look at, say, AVX or AVX-8 assuming a 256-bit register usage you get 8 lanes at a time per core for 32 bit wide addresses
22:58:05 <koz_> Oh right, I get it.
22:58:10 <edwardk> You can then decide if you're going to deal with the extra slowdown to use multiple cores
22:58:14 <koz_> You basically have a bunch of _pointers_ into your graph.
22:58:33 <edwardk> Yeah and all those pointers are things we want to reduce
22:58:39 <edwardk> Which in turn may give us more things to reduce
22:58:50 <koz_> Because since we have a DAG, each of those pointers is a sub-DAG really.
22:59:03 <edwardk> Yeah
22:59:16 <koz_> OK, I think that at least gives me a conceptual model. Thanks!
23:00:10 <edwardk> In a GPU setting you're getting 32-64 per "warp" instead of 8 per SIMD instruction.
23:00:29 <koz_> Yeah, that part I follow.
23:01:31 <edwardk> another path that may have more juice to it is the lamping optimal reduction stuff that the formality folks care about. there you also do combinator reduction with sharing, but its a different kind of reduction machine
23:01:46 <koz_> Is there a paper I can read about this?
23:01:51 <edwardk> i've slowly come around to liking their approach more and more
23:02:10 <koz_> Is it also similarly parallelizable?
23:02:16 <edwardk> It is all the stuff that Victor Maia / SrPiexinho posts on reddit.
23:02:32 <edwardk> yeah it should have basically the same story, but now with linear logic built in
23:02:33 * koz_ isn't on Reddit.
23:02:46 <koz_> OK, _now_ you have my undivided attention lol.
23:03:23 <edwardk> https://medium.com/@maiavictor  might be a decent start
23:03:41 <edwardk> not sure if his business partner also has articles somewhere
23:03:44 <koz_> OK, it just clicked.
23:03:50 <koz_> I've seen Formality around.
23:04:05 <koz_> That's definitely very cool, thanks for helping form that connection.
23:04:09 <koz_> (in my brain)
23:04:56 <edwardk> its a different kind of combinator calculus, but you can think of those sort of particle/anti-particle pairs it uses as reduction sites the same way as i do those pointers in the model above
23:05:25 <koz_> So the idea is you still have a 'slice', it's just full of slightly different things?
23:05:39 <koz_> And you can basically work over the entire slice at once?
23:07:28 <edwardk> well, usually for spmd-on-simd i'd write a compiler that compiled everything down to code, but the notion of where i am in that code would vary quite a bit. if i'm working on a list reduction somewhere and doing something involving trees somewhere else, there's no common context, so those have to run at different times or different cores. the idea behind that talk was that i could get away with a _small_ combinator basis, which would 
23:07:28 <edwardk> make those two reduction sites look similar enough i could do them on the same core at the same time.
23:08:24 <edwardk> If it is just basically S K and I all the way down one part of my program looks much the same as any other, so so long as i keep doing reductions we just keep working, and nothing stalls out.
23:09:09 <edwardk> the idea is to use S K and I as a very thin interpreted language rather than compiling all the way down to assembly
23:09:20 <edwardk> (replace SKI with a better basis, but the idea remains)
23:10:09 <koz_> So like, a combinator bytecode?
23:10:12 <edwardk> yeah
23:10:33 <koz_> And yeah, I figured SKI would be inadequate for size reasons if nothing else.
23:10:47 <koz_> You're already being punched with O(n^2)
23:11:25 <koz_> Why make it worse.
23:11:26 <edwardk> you can use various tricks to improve the overhead of SKI. oleg's encoding, the one i sketch in that talk, etc.
23:11:39 <koz_> Oleg's encoding?
23:12:16 <edwardk> he has a blog post where he provides an encoding using memoization of the little helper combinators. i'm not going to comment on its asymptotic complexity claims
23:12:35 <koz_> What's the title if you can recall?
23:12:49 <edwardk> http://okmij.org/ftp/tagless-final/ski.pdf
23:12:54 <koz_> Oh that one!
23:13:05 <koz_> OK, yeah, that jogged my memory, thanks.
23:14:30 <koz_> Well, I have some reading and thinking to do. Thanks for that! Made for a great end to an otherwise mediocre weekend.
23:41:45 * hackage web3 0.8.4.0 - Ethereum API for Haskell  https://hackage.haskell.org/package/web3-0.8.4.0 (akru)
