00:36:45 * hackage lightstep-haskell 0.10.0 - LightStep OpenTracing client library  https://hackage.haskell.org/package/lightstep-haskell-0.10.0 (DmitryIvanov)
00:55:47 <dfin> hi. If I declare a struct A { val :: SomeType, nested :: Nested } where data Nested = Nested { val :: SomeType }, ghcid complains that val was re-declared, even the second occurrence is scoped to the nested struct.
00:55:52 <dfin> How do I mitigate this?
00:58:08 <dminuoso> dfin: Can you share the exact code you are trying please?
00:58:52 <dfin> Let me try to get to a minimum example.
00:59:01 <L29Ah> how do i `ghc --make` in a cabal sandbox?
00:59:30 <L29Ah> `cabal exec ghc --make foo.hs` complains about libraries that are in fact present in the sandbox
00:59:47 <L29Ah> i'm trying to make a library witn examples that aren't specified in the library's .cabal file btw
01:00:40 <L29Ah> // if there's a better way to have examples around near a library for co-development, tell me please
01:00:58 <dfin> dminuoso: https://pastebin.com/ApWtLyk9
01:02:00 <dminuoso> dfin: Ah yes, So essentially generating a field named value actually creates a function.
01:02:21 <dminuoso> So `data Nested = Nested { value :: Int }` implicitly creates a function `value :: Nested -> Int`
01:02:59 <dminuoso> There exists an extension called DuplicateFieldRecords to allow for this, but generally it's better to just prefix.
01:03:21 <dfin> Well, this is to be serialized as JSON. The names are not under my control, unfortunately.
01:03:52 <dminuoso> dfin: I strongly recommend you don't use haskell names to match an API.
01:04:00 <dminuoso> You can use aeson by hand very easily, then it doesn't matter.
01:04:38 <dfin> Do you have an example of that?
01:04:58 <dminuoso> dfin: Just to be sure, you are using aeson right?
01:05:10 <phadej> See ther docs: https://hackage.haskell.org/package/aeson-1.5.1.0/docs/Data-Aeson.html#g:2
01:05:16 <dfin> I'm importing Data.Aeson. ;-) 
01:09:00 <dfin> phadej: thanks
01:12:41 <dminuoso> dfin: Also, you can avoid the instance as well.
01:30:17 <timCF> Hi guys! Any `Persistent/Esqueleto` library users there? I'm thinking why `PersistEntity.Unique` class (and maybe others) require `Show` instance to be implemented? I'm avoiding `Show` class in my code to prevent leaks of sensitive data and credentials to logs.. But I still want to use Persistent/Esqueleto. Do anyone know exact reason why it needs
01:30:18 <timCF> `Show`? Maybe it's for some kind of internal logging and I can disable it? Or safely implement `Show` which will safely show something like `MyType<SECRET>` or even `MyType<HASH_DATA>` to prevent data leaks?
01:31:33 <merijn> Unique is not a class, though?
01:32:08 <merijn> And it doesn't require Show either, because I've had to manually implement those instances...
01:32:17 <merijn> Or maybe this is an esqueleto thing
01:35:32 <timCF> merijn I'm using this helper to generate models and instances for them (I guess it's standard thing) `share [mkPersist x, mkMigrate y] $(persistFileWith z)` and it automatically tries to derive `Show` for some of models, and can't because one of the fields don't have `Show`
01:38:40 <merijn> timCF: It only does that if you explicitly write "deriving Show" in your schema...
01:39:03 <timCF> Oh, thanks merijn
01:39:15 <timCF> I didn't noticed that ðŸ˜€
01:40:04 <timCF> But my schema don't have any Show at all
01:48:27 <kuribas> How do you represent a type constructure in an ADT?  TypeCon Type for arity 1, and TypeCon2 Type Type for arity > 1?
01:48:49 <kuribas> Or TypeCon [Type] for all arities?
01:48:50 <merijn> kuribas: "TypeCon [Type]"?
01:49:37 <kuribas> Same for lambda?
01:49:58 <kuribas> This uses Lam Name Expr:  http://dev.stephendiehl.com/fun/006_hindley_milner.html
01:50:27 <merijn> kuribas: I have a super hacky/unfinished thing here: https://github.com/merijn/lambda-except/blob/master/AST.hs
01:51:09 <kuribas> merijn: thanks!
01:51:11 <merijn> kuribas: I just have "Con Name [Expr a] Loc" (Loc being the origin string in the source)
01:51:34 <kuribas> a is the name type?
01:51:55 <merijn> Completely unrelated, cabal is failing to build stuff due to failing documentation in dependencies, anyone know how to deal with that?
01:52:22 <merijn> kuribas: "Expr a" is just the type of each argument
01:52:35 <kuribas> what's a?
01:53:12 <merijn> kuribas: Confusing :p
01:53:53 <merijn> 'a' is the type of variables
01:54:00 <kuribas> I could use a type variable for signifying if every expression is typed or not.
01:54:21 <merijn> Except, that this is based on the Henk stuff where types and expressions are the same type
01:54:36 <merijn> So the type of an "Expr a" is an "Expr a"
01:54:48 <kuribas> it's a dependently typed language?
01:55:26 <xerox_> merijn: the link to the pdf in the readme is broken
01:56:00 <merijn> xerox_: Could be, haven't touched this in years :p
01:56:58 <kuribas> I guess I only need kind annotation on type variables...
02:23:57 <merijn> hmm
02:24:04 <merijn> What does this mean? "Warning: Couldn't find .haddock for export"
02:31:45 * hackage broadcast-chan 0.2.1.1 - Closable, fair, single-wakeup channel type that avoids 0reader space leaks.  https://hackage.haskell.org/package/broadcast-chan-0.2.1.1 (MerijnVerstraaten)
02:32:46 * hackage broadcast-chan-tests 0.2.1.1, broadcast-chan-conduit 0.2.1.1 (MerijnVerstraaten): https://qbin.io/hotels-had-653k
03:10:28 <xerox_> what does this mean? https://pastebin.com/raw/CksjteD4
03:10:59 <xerox_> I'm at a loss because there aren't any ranges in my executable(s)
03:12:00 <dminuoso> xerox_: can you share the cabal file with us?
03:14:44 <xerox_> dminuoso: it looks like this and there are more executables with the same stanza shape https://pastebin.com/raw/rFZ0Uxjt
03:31:15 * hackage static 0.1.0.1 - Type-safe and interoperable static values and closures  https://hackage.haskell.org/package/static-0.1.0.1 (infinity0)
03:37:15 * hackage mutable-lens 0.4.0.0 - Interoperate mutable references with regular lens  https://hackage.haskell.org/package/mutable-lens-0.4.0.0 (infinity0)
03:42:01 <dminuoso> xerox_: Can you build with `cabal build -v3` and share the output?
03:56:37 <martinmch> Is there another way of accessing an unpacked variable, without using a where like this?
03:56:42 <martinmch> requestRoll :: Roll -> IO [Int]Ã‚Â¬ 13 requestRoll (Roll (Dice cnt sides) mod) = doÃ‚Â¬ 14             putStrLn $ "Please roll " ++ dicerollÃ‚Â¬ 15             putStrLn "What number does the dice show?"Ã‚Â¬ 16             values <- fmap ((+mod) . read) <$> getLines cntÃ‚Â¬ 17             return valuesÃ‚Â¬ 18         where diceroll = show (Roll (Dice cnt sides) mod)
03:56:49 <martinmch> Dang, that was ugly.
03:57:04 <martinmch> requestRoll :: Roll -> IO [Int]
03:57:04 <martinmch> requestRoll (Roll (Dice cnt sides) mod) = do
03:57:04 <martinmch>             putStrLn $ "Please roll " ++ diceroll
03:57:04 <martinmch>             putStrLn "What number does the dice show?"
03:57:04 <martinmch>             values <- fmap ((+mod) . read) <$> getLines cnt
03:57:07 <martinmch>             return values
03:57:09 <martinmch>         where diceroll = show (Roll (Dice cnt sides) mod)
03:58:42 <sshine> hm
04:12:15 * hackage cayley-client 0.4.13 - A Haskell client for the Cayley graph database  https://hackage.haskell.org/package/cayley-client-0.4.13 (MichelBoucey)
04:14:28 <kuribas> is there a working library for creating unique identifiers?
04:14:33 <kuribas> one that is recent
04:14:34 <kuribas> ?
04:14:47 <dminuoso> uuid?
04:14:59 <kuribas> dminuoso: no, just integers
04:15:38 <dminuoso> kuribas: You can trivially turn a uuid into an integer
04:15:39 <sshine> unixtime microseconds?
04:16:11 <kuribas> dminuoso: it's for creating unique bindings in a code generator
04:16:14 <Arahael> I want a `\\` (ie, Data.List.difference), except I want to provide a custom comparator.  What's the simplest way to do this?
04:16:16 <kuribas> dminuoso: so they should be small
04:16:25 <sshine> uuid tackles some problems of identifiers being unique across computers.
04:16:45 <dminuoso> kuribas: Hold on, is this by any chance related to variable names?
04:16:51 <kuribas> dminuoso: it is!
04:17:16 <dminuoso> kuribas: Perhaps you meant to be using the library unbound?
04:17:36 <sshine> kuribas, like this? https://github.com/diku-dk/futhark/blob/master/src/Futhark/MonadFreshNames.hs
04:17:56 <kuribas> dminuoso: oh, that looks pretty neat !
04:18:18 <sshine> dminuoso, oohh, nice. thanks.
04:18:19 <kuribas> sshine: I was more thinking about a splittable supply like in ghc
04:18:26 <Arahael> Hmm, in the mean time, I think I'll use `foldl (\a b -> deleteBy...)` instead.
04:18:36 <dminuoso> kuribas: There's very good reasons not to reroll it on your own. Trying to deal with names and binders yourself ends up throwing you in endless tricky situations. :)
04:19:14 <int-e> kuribas: unless it's for learning :)
04:19:17 <kuribas> dminuoso: yeah, I think that library is what I need :)
04:19:35 <kuribas> int-e: nah, I want to get something as quick as possible
04:19:58 <sshine> dminuoso, resolving labelled jumps in Ethereum VM opcodes to absolute addresses leads to a curious fixpoint problem because the size of a jump instruction depends on the address being jumped to. :-D
04:20:25 <int-e> sshine: a classic
04:20:42 <kuribas> dminuoso: I was following the Write you a haskell, but it's unique supply isn't very efficient.
04:21:05 <int-e> . o O ( multi-pass vs. single pass assemblers were a fight in the 90s, probably even earlier.)
04:21:49 <sshine> int-e, if that is so, do you know if there is something smarter than resolving the absolute addresses by fixpoint iteration? like an algorithm that certainly only uses two passes.
04:21:52 <MarcelineVQ> was its unique supply modifyIORef' (+)! ?
04:22:00 <MarcelineVQ> (+1)
04:23:32 <int-e> sshine: I don't know anything better. Note that you still have a choice between starting out optimistically (picking shorter encodings, but which may then fail) and pessimistically (which has the advantage that you always get working code). The former may produce shorter code in some cases.
04:24:07 <sshine> int-e, apparently I'm an optimist.
04:24:45 <int-e> sshine: I imagine the real fun in this context comes from possibly reordering code blocks. But it's nothing I've ever really worked on.
04:25:04 <sshine> (the number of passes is largely decided by how many 256-byte chunks of EVM code I'm generating, which is economically limited.
04:25:13 <int-e> (I've done it manually in some assembly code golfing a pretty long time ago)
04:25:31 <sshine> int-e, hehe yes, that'd be a fun problem.
04:26:15 <sshine> int-e, honestly, I think I'd probably translate absolute jumps to temporary labelled jumps, move the code chunks around, and translate back. ;-)
04:26:51 <int-e> yeah but what makes it challenging is combinatorial explosion
04:27:21 <int-e> anyway, just musing.
04:27:51 <sshine> yeah
04:29:31 <MarcelineVQ> it's murder then
04:32:53 <int-e> Like many things it's fun to ponder as long as you don't actually need it.
04:33:03 <kuribas> MarcelineVQ: no: http://dev.stephendiehl.com/fun/006_hindley_milner.html#hindley-milner-inference
04:38:28 <xerox_> dminuoso: that's a big output, it has the same warning at the beginning and then calls all the various binaries
04:41:15 * hackage amqp 0.20.0 - Client library for AMQP servers (currently only RabbitMQ)  https://hackage.haskell.org/package/amqp-0.20.0 (HolgerReinhardt)
04:46:48 <dminuoso> xerox_: Can you share the output regardless?
04:53:53 <dminuoso> Mmm, it's a bit strange. I find myself frequently having a bunch of data of some type T that has some nested Maybes. Now I often find myself filtering through all where that nested Maybe is Just, pass that data around - but then I lost the recovered knowledge that these nested Maybes are Just.
04:54:29 <merijn> dminuoso: Sounds like you need to define new types for these levels of nesting
04:55:10 <dminuoso> merijn: With some 4-5 deep data types, that seems like a waste for just a handful of functions interacting with that.
04:55:24 <merijn> dminuoso: Yes, but no :p
04:55:33 <dminuoso> My data types are.. somewhat large.
04:55:44 <dminuoso> And I'd lose instances as well
04:55:44 <merijn> dminuoso: I've thought like that several times and ended up doing it anyway eventually
04:55:51 <merijn> dminuoso: Redefine them
04:56:09 <dminuoso> merijn: How hard did you fight the instinct to encode the knowledge at the type level?
04:56:14 <merijn> In other news, if anyone's bored and needs a challenge, I've got one
04:56:23 <merijn> dminuoso: I have very little encoded at the type level, tbh
04:57:30 <merijn> I've got a race condition. I know exactly what it is and how to fix it, but I'm having a hard time coming up with a test to (semi-)reliably reproduce it. So if anyone wants to feel clever and give it a try :p
04:57:58 <dminuoso> Actually, there's another trick I can do...
04:58:32 <dminuoso> I could adopt he practice of `filterSome :: T -> (T, F)`, when T holds a single nested `Maybe F`
04:58:46 <dminuoso> Or encode this (T, F) as an actual data type
04:59:10 <dminuoso> Then the knowledge is preserved at least, and I dont have to redefine multiple data types for just this bit.
05:03:34 <typetetris> Is there an easy way to test at program start wether my persisten database specification matches my database schema?
05:03:45 * hackage exact-real 0.12.3 - Exact real arithmetic  https://hackage.haskell.org/package/exact-real-0.12.3 (jophish)
05:04:38 <merijn> typetetris: Not really
05:04:45 <merijn> You can check for an empty migration
05:05:42 <merijn> typetetris: https://github.com/merijn/Belewitte/blob/master/benchmark-analysis/src/Migration.hs#L52-L57
05:05:49 <Shiranai> Hello, I'm reading LearYouAHaskell and they implemented BSTs as follow: data Tree a = EmptyTree | Node a (Tree a) (Tree a) deriving (Show, Read, Eq)
05:06:10 <Shiranai> and then treeInsert with some recursion
05:06:12 <dminuoso> typetetris: I think it's better to enforce this on an operational level.
05:06:23 <dminuoso> Ensure that nobody other than your application has permissions to modify the schema.
05:06:29 <Shiranai> but does that mean all the intermediate trees are stored in memory?
05:06:40 <dminuoso> Shiranai: No.
05:06:48 <merijn> Shiranai: What does "intermediate tree" mean?
05:06:58 <dminuoso> Shiranai: Lets take a simpler example, lists.
05:06:58 <typetetris> merijn: thanks
05:07:04 <merijn> dminuoso: That doesn't work for all cases
05:07:09 <dminuoso> Shiranai: When you replace the head of a list, then the tail of both lists are shared.
05:07:18 <typetetris> dminuoso: thanks its also about protecting myself from myself :)
05:07:19 <merijn> dminuoso: Trivial example from my case: sqlite database files
05:07:47 <Shiranai> oh so it is working with pointers under the hood?
05:07:51 <dminuoso> merijn: Even then. File permissions go a long way.
05:07:54 <dminuoso> Shiranai: Right.
05:07:57 <merijn> Shiranai: Yes, no, maybe it's not defined
05:08:18 <merijn> dminuoso: I'm treating the database as an application file format and expect to be backwards compatible with older versions
05:08:38 <Shiranai> Okay, thanks!
05:08:59 <dminuoso> Shiranai: Mostly, when you reference something it doesn't get copied.
05:09:04 <merijn> dminuoso: The entire point is that you should be able to (try to) point it at arbitrary data files and check if they are the appropriate format and if so, use them
05:10:00 <merijn> Shiranai: Haskell (the language) doesn't actually specify how data types should be implemented, so what you're asking is inherently implementation specific and there the compiler isn't even required to do the same thing every time
05:48:45 * hackage zipper-extra 0.1.2.0 - Zipper utils that weren't in Control.Comonad.Store.Zipper  https://hackage.haskell.org/package/zipper-extra-0.1.2.0 (locallycompact)
05:54:49 <xsperry> join $ liftA2 ioFunction valueInContext valueInContext <- is there a nicer way of writing this?
05:55:44 <dminuoso> % :t \f t -> join $ liftA2 f t t
05:55:44 <yahb> dminuoso: Monad m => (b -> b -> m a) -> m b -> m a
05:56:45 <xsperry> % :t \f t u -> join $ liftA2 f t u
05:56:45 <yahb> xsperry: Monad m => (a1 -> b -> m a2) -> m a1 -> m b -> m a2
05:57:35 <xsperry> I mistyped the original line, should have been valueInContext1 and valueInContext2
06:00:11 <dminuoso> join (f <$> v1 <*> v2)
06:00:29 <dminuoso> I mean that one is obvious, but sometimes <*> can be easier to read than liftA2
06:00:37 <dminuoso> Also you can use do-notation
06:00:39 <dminuoso> do { s <- v1; t <- v2; f s t }
06:00:56 <dminuoso> I'd probably go for the do-notation version.
06:01:09 <dminuoso> Seems a bit more apparent what's happening.
06:05:39 <xsperry> I tend to prefer liftA2 over operators, and I was hoping for a function that combines join and liftA2. but without that, do just might be the clearest in this case
06:06:28 <dminuoso> xsperry: My reasoning for <$> and <*> is that you sort of squint and pretend they dont exist. Then it's just looks like function application... :P
06:07:00 <xsperry> you'd have to squint very hard for that effect :)
06:07:25 <dminuoso> You don't really
06:07:33 <dminuoso> It's quite literally inside <*> type signature
06:07:35 <dminuoso> % :t (<*>)
06:07:35 <yahb> dminuoso: Applicative f => f (a -> b) -> f a -> f b
06:07:50 <dminuoso> It's very function applicativy (hint hint!)
06:08:58 <xsperry> I find the call easier to parse with parenthesis around arguments. I guess you can use them with <$> and <*> as well, but most people don't
06:12:02 <dminuoso> xsperry: Anyhow. If you wanted to give it a name, you could call it `bind2 :: Monad m => (a -> b -> m c) -> m a -> m b -> m c; bind2 f v1 v2 = do { s <- v1; t <- v2; f s t }`
06:12:40 <xsperry> I think I'll just use do, since this isn't a common idiom 
06:22:48 <xsperry> @pl (\n -> do x <- io; f x n)
06:22:48 <lambdabot> (line 1, column 18):
06:22:48 <lambdabot> unexpected ";"
06:22:48 <lambdabot> expecting letter or digit, variable, "(", "`", "!!", ".", operator or ")"
06:23:38 <xsperry> @pl (\n -> io >>= flip f n)
06:23:38 <lambdabot> (io >>=) . flip f
06:23:50 <xsperry> @pl (\n -> io >>= f n)
06:23:50 <lambdabot> (io >>=) . f
06:35:00 <L29Ah> STM: how do i `retry` the transaction at the first time and succeed the second regardless of the value?
06:35:22 <L29Ah> (just want to hang on a TVar to grab it when it is written by someone else)
06:36:51 <merijn> L29Ah: What does "the second time" mean?
06:37:08 <merijn> You can't detect writes
06:37:14 <merijn> You can only detect changes
06:39:25 <L29Ah> i mean the STM transaction restart
06:39:40 <L29Ah> i can't detect changes as TVar contents aren't necessarily Eq ;)
06:40:17 <L29Ah> well, not restart, but re-proceeding after retry
06:40:21 <merijn> L29Ah: Transaction may restart arbitrarily many times, though?
06:42:20 <L29Ah> yes, but it only restarts after the involved state changes somehow, AFAIK
06:42:44 <L29Ah> so i want to detect it and return the new value
06:43:22 <merijn> What do you *actually* want
06:43:41 <L29Ah> handle configuration updates
06:44:02 <L29Ah> configuration is updated by UI via setting TVar contents
06:44:18 <merijn> Because I suspect that the real answer is "stop wanting this" and there's probably better ways to check things
06:44:22 <L29Ah> so i spawn a thread to wait at each TVar
06:44:23 <typetetris> L29Ah: make your UI send it to a TChan?  
06:44:43 <L29Ah> typetetris: TChan will make it impossible to read the current value
06:44:49 <merijn> L29Ah: Just add a second "TVar Bool" that you toggle when the configuration changes
06:44:51 <L29Ah> w/o blocking or stealing it
06:45:05 <merijn> Then block until the TVar is True using guard
06:45:17 <merijn> Update config and reset TVar to False. Done.
06:46:52 <typetetris> L29Ah: merijn solution sounds good. With `TChan` you would have to get more elaborate: Set the value in the TVar and send in the TChan the change happened, if you have multiple "subscribers" to those infos, use `newBroadcastTChan` and `dupTChan`?
06:47:42 <L29Ah> with TChan i will have problems with multiple quick updates getting squashed at the receiving end
06:48:29 <L29Ah> while i can wait for TVar Bool at both ends
06:49:02 <L29Ah> but now the hacky (Eq + retry) solution seems the simplest
06:49:45 <merijn> L29Ah: Except you can't make it work, while the TVar Bool one is simple ;)
06:51:02 <typetetris> L29Ah: Depends on your use case of course, with TChan you don't miss an event. TVar Bool is simple, but squashes multiple fast changes.
06:51:07 <L29Ah> ohh, maybe i can unsafePerformIO an IORef Bool instead and retry on that!
06:51:15 <merijn> typetetris: It doesn't
06:51:26 <merijn> typetetris: If you guard update with the TVar being False
06:51:27 <L29Ah> typetetris: it doesn't if you retry at the writer
06:51:46 <merijn> L29Ah: That's going to ruin your day
06:51:59 <merijn> Why "IORef Bool"? That's going to break everything
06:52:04 <L29Ah> while you need to have TChan of actual (duplicated) values to do the same
06:52:05 <typetetris> More like the whole next week.
06:52:29 <L29Ah> merijn: set to true and retry on false, proceed on true
06:52:55 <L29Ah> and create the IORef just before entering atomically
06:53:00 <merijn> L29Ah: THe problem is that it's not atomic with the IORef
06:53:54 <L29Ah> merijn: but the IORef is only used within the atomically block and gc'd after returning from it
06:54:15 <merijn> what
06:54:20 <merijn> How would that even work
06:54:29 <merijn> The readers and writers both need access to it
06:54:33 <L29Ah> no
06:54:35 <L29Ah> see:
06:54:48 <L29Ah> retried <- newIORef False
06:54:51 <merijn> WHy are you making this so difficult
06:54:52 <L29Ah> atomically $ do
06:54:56 <merijn> Just use "TVar Bool"
06:55:39 <L29Ah> if (!retried) {retried = true; retry} else {readTVar myVar}
06:55:56 <merijn> this is a terrible idea and you will regret this day
06:55:59 <merijn> but whatever
06:56:17 <L29Ah> while TVar Bool will require me to pure lots of boilerplate all over my beautiful data structures ;)
06:56:29 <L29Ah> what's so terrible about it?
06:56:43 <L29Ah> except it's using the function prefixed with "unsafe"
06:57:12 <merijn> it doesn't, you just write 1 function for writing updates and one for reading them and use those everywhere
06:59:36 <L29Ah> and some type synonyms and creating function and non-blocking reading function and whatever else i forgot about
07:00:23 <L29Ah> but i admit that your solution is semantically cleaner and won't squash changes unlike mine
07:20:17 <xerox_> dminuoso: apparently this has been going on for a while https://github.com/haskell/cabal/issues/5119
07:23:12 <merijn> xerox_: The warning about stuff depending on something in the same package?
07:23:16 <merijn> Just ignore it
07:23:44 * hackage orbits 0.3 - Types and functions for Kepler orbits.  https://hackage.haskell.org/package/orbits-0.3 (jophish)
07:23:56 <jchia_> How long would it take to learn enough nix to port a stack multi-package project to nix that uses hackage & github packages? I want to use GHC 8.10 but stack lts and nightly are still on 8.8 and cabal doesn't properly cache files for github packages. That leaves nix.
07:24:29 <xerox_> merijn: I did for months
07:24:30 <merijn> Or "fixing cabal" ;)
07:24:33 <jchia_> I would use cabal if it cached github packages properly
07:25:10 <merijn> jchia_: Is there a ticket for that already? I'm not even sure if that'd be super hard to implement
07:25:43 <merijn> xerox_: I've been ignoring it for over a year :p
07:26:02 <jchia_> merijn: IDK, but there are 1000+ open issues, so I didn't check. I don't want to file a duplicate issue.
07:26:55 <merijn> The fastest way to get issues fixed is to be annoyed enough to fix it yourself ;)
07:30:11 <jchia_> i wonder whether it's faster for me to make that fix or to learn nix
07:30:38 <merijn> Depending on the complexity of why caching isn't there yet, it might be close :p
07:32:51 <merijn> jchia_: There's a bunch of discussion here: https://github.com/haskell/cabal/issues/5586
07:33:57 <jchia_> merijn: Good catch.
07:34:10 <L29Ah> https://alexgaynor.net/2020/may/27/science-on-memory-unsafety-and-security/ meanwhile in the parallel world
07:45:17 <ryantrinkle> is there anything like vacuum that still works today?
07:45:23 <ryantrinkle> (on ghc 8.6 or so)
07:45:23 <xsperry> is there a parser in parsec or megaparsec that can parse haskell-like list syntax? "1,2,3"  "1..10" etc
07:45:53 <xsperry> a long shot but..
07:46:00 <xsperry> @hoogle list :: (Enum a, Stream s m Char) => ParsecT s u m a -> ParsecT s u m [a]
07:46:01 <lambdabot> No results found
07:46:07 <xsperry> @hoogle (Enum a, Stream s m Char) => ParsecT s u m a -> ParsecT s u m [a]
07:46:08 <lambdabot> Text.Parsec many1 :: (Stream s m t) => ParsecT s u m a -> ParsecT s u m [a]
07:46:08 <lambdabot> Text.Parsec.Combinator many1 :: (Stream s m t) => ParsecT s u m a -> ParsecT s u m [a]
07:46:08 <lambdabot> Text.ParserCombinators.Parsec.Combinator many1 :: (Stream s m t) => ParsecT s u m a -> ParsecT s u m [a]
07:46:36 <lortabac> I think it's called sepBy
07:47:01 <xsperry> that can handle 1,2,3 but not 1..10, or 0,10..
07:47:23 <xerox_> you need different parsers for there, or at least different choices in a single parser
07:47:29 <xerox_> *for that there
07:47:37 <xsperry> yes I want the latter
07:47:44 <merijn> ryantrinkle: Seems like more of a question for #ghc ?
07:47:45 <xsperry> I can write it, I was just wondering if it already exists
07:48:22 <xerox_> xsperry: I think you're supposed to use the choice combinator and then you can use sepByOne and friends
07:48:46 <merijn> xsperry: I doubt it, tbh
07:59:17 <dminuoso> xerox_: Wow that's... oof.
07:59:35 <dminuoso> xerox_: I reckon the best workaround is upgrading to a newer version?
08:02:30 <xerox_> dminuoso: this is the latest ghc and latest cabal that ghcup affords me
08:04:50 <Shiranai> Reading the Learn you a Haskell chapter on IO and there's this code:
08:04:59 <Shiranai> main = do   
08:05:00 <Shiranai>     withFile "something.txt" ReadMode (\handle -> do  
08:05:00 <Shiranai>         hSetBuffering handle $ BlockBuffering (Just 2048)  
08:05:01 <Shiranai>         contents <- hGetContents handle  
08:05:01 <Shiranai>         putStr contents)  
08:05:25 <Shiranai> how does `contents <- hGetContents handle` "remembers" the setbuffering on the line above?
08:05:38 <wavemode_> please paste code in a gist/pastebin
08:05:51 <L29Ah> Shiranai: it doesn't, hSetBuffering communicates directly with OS
08:05:54 <Shiranai> Ok, my bad, will do from now on
08:07:45 <Shiranai> Don't know that much about OSs but is this setting just local for that "handle" right? So no risk of colliding two different handles or two different programs with different buffer size
08:07:56 <L29Ah> yes
08:08:09 <Shiranai> Makes sense, thanks!
08:08:23 <L29Ah> actually seems like i've mistaken and it's handled at the rtl level
08:08:37 <L29Ah> well, actually in base
08:09:18 <L29Ah> as i can't find the syscall responsible for buffering, so probably it controls the application-level buffer between fd and Handle
08:10:17 <L29Ah> Shiranai: aha, https://hackage.haskell.org/package/base-4.12.0.0/docs/src/GHC.IO.Handle.Types.html#haBufferMode
08:10:20 <Shiranai> That sounds too advanced for me I have no idea what that means :)  But for the moment do I have to take some notice so there is no collision or is that guaranteed by haskell?
08:11:46 <L29Ah> that is kinda guaranteed by haskell
08:12:50 <Shiranai> Thanks! Once I finish the book I'll be sure to check this stuff again
08:42:39 <quiet_laika[m]> i had some plain predicates i was using to guard pattern matches in code with explicitly passed state. im moving the explicit state into the state monad, but now im facing a problem that my predicates can't be used in guards because they're inside of `StateT`. has anyone faced something similar?
08:42:46 <quiet_laika[m]> i can provide a short example if that helps
08:46:22 <scasc> Quick question re "cabal": If I'm writing a library (~/dev/mylib/mylib.cabal) and I want to test its usage in another package (~/dev/testapp/testapp.cabal), how do I make the testapp recognize the library?
08:46:35 <scasc> How do I cabal to install mylib into ~/.cabal/store?
08:46:57 <merijn> scasc: You don't want to do that :)
08:47:07 <merijn> scasc: The anwer to your first question is much easier
08:47:08 <quiet_laika[m]> you should be able to use cabal.project to specify that there's a dependency at `../mylib`
08:47:33 <quiet_laika[m]> (i believe)
08:47:33 <merijn> scasc: You can use cabal.project files to build against unreleased libraries on your local filesystem/github/etc.
08:47:53 <scasc> @merijn: I understand I don't want to install it into ~/.cabal/store.
08:47:53 <lambdabot> Unknown command, try @list
08:48:05 <scasc> But what's the solution to my original question?
08:48:06 <merijn> scasc: https://cabal.readthedocs.io/en/latest/cabal-project.html
08:48:43 <merijn> Specifically the "local packages" section
08:49:47 <scasc> I knew about multi-package projects, but I thought I'd avoid them because GHCi does not seem to handle them well?
08:50:01 <merijn> scasc: Define "handle them well"
08:50:37 <scasc> I just read that somewhere. You're right, I'll just try and see whether it does impede me.
08:50:42 <quiet_laika[m]> cabal lets you specify the package and component you want to open a repl for if need be
08:50:43 <scasc> And will probably find that it does not.
08:50:44 <merijn> scasc: If you use "cabal repl" to start ghci it should set up everything for you
08:50:48 <quiet_laika[m]> `cabal new-repl blah blah`
08:51:10 <merijn> scasc: The only "problem" with "cabal repl" is that for multi-package projects you need to explicitly say which to load
08:51:13 <solonarv> you don't need the new- / v2- prefix if you're using cabal >+ 3.0 (which you should be)
08:51:28 <quiet_laika[m]> :o
08:51:30 <quiet_laika[m]> TIL
08:51:57 <quiet_laika[m]> does the help text reflect that?
08:52:50 <merijn> scasc: Also, if you configure cabal to write .ghc.environment files (https://cabal.readthedocs.io/en/latest/cabal-project.html?highlight=environment#cfg-field-write-ghc-environment-files) then "ghci" will automatically pick up the build config for your library
08:53:04 <merijn> scasc: Using that and cabal repl I haven't really had issue loading stuff in ghci
08:53:23 <quiet_laika[m]> im on cabal-install-3.2.0.0 but the help text still says "new-style projects (beta)"
08:53:56 <ja> quiet_laika[m]: right, same for me. my cabal --help does not mention any commands without prefixes. maybe it is folklore or something ;)
08:54:04 <scasc> quiet_lakai: I saw that too :-) it should be updated
08:54:23 <ja> ok, does mention commands without prefixes, but those are not in the set of v1/v2 commands for project building
08:54:48 <quiet_laika[m]> here i've been unnecessarily typing 4 characters...
08:54:55 <merijn> quiet_laika[m]: :)
08:55:17 <ja> man, it is indeed confusing that the help page has the commands duplicated 3 times for each variant
08:55:21 <merijn> quiet_laika[m]: v1/v2 or mostly intended for people scripting things so they can write scripts that support multiple cabal-install versions
08:55:50 <ja> actually 4 times :O
08:55:54 <merijn> Since v1-/v2- work in both old and new cabal versions, without scripts needing complex logic to determine what they do
08:56:07 <merijn> ja: Easy PR to contribute! ;)
08:56:33 <quiet_laika[m]> yeah the reasoning for them is sound, i just missed the announcement that `new-` was no longer necessary for the new build style :)
08:56:37 <ja> merijn: but i don't even know what would be a fix...
08:57:04 <ja> i mean, it would be easier to understand to prune v1 commands, but that will also confuse users who insist on the old way...
08:57:18 <merijn> v1 is going away at some point soon-ish
08:57:29 <merijn> But there are some unsolved workflow issues
08:58:27 <ja> are they in the bug tracker?
08:59:07 <merijn> "probably"?
08:59:29 <merijn> I mean, there's like 1300 issues, so :p
09:00:42 <scasc> > Easy PR to contribute
09:00:44 <lambdabot>  error:
09:00:44 <lambdabot>      Data constructor not in scope:
09:00:44 <lambdabot>        Easy :: t0 -> ((s0 -> a0) -> Optic' p0 f0 s0 a0) -> t1 -> terror: Data...
09:01:01 <scasc> Actually cloned the repo :-)
09:01:19 <ezzieyguywuf> if I have  `myFunc :: [a] -> b`, how might I do something like "if length of a <= 2, a' = do something, else a' = as" and then perform the same logic on a' either way?
09:01:25 <merijn> cabal(-install) can always use more love
09:01:46 <merijn> The Cabal code is fairly gnarly, but cabal-install is fairly accessible (as far as any big project is, anyway)
09:02:25 <merijn> ezzieyguywuf: define a where block and define a' using a guard?
09:03:10 <maerwald> merijn: I thought it's the other way around
09:03:16 <merijn> maerwald: No
09:03:21 <merijn> Cabal is *gnarly*
09:03:29 <merijn> cabal-install is complex, but predictable
09:03:33 <maerwald> I just had a brief look at cabal-install code (the solver) and it is really... uh
09:04:10 <ezzieyguywuf> merijn: I thought about using a guard, but I thought each had it's own scope. you're suggesting `myFunc as | check1 = a' = someValue | otherwise = a' = somethingElse where something a'`?
09:04:12 <merijn> maerwald: I haven't looked at the solver
09:04:22 <quiet_laika[m]> merijn ezzieyguywuf depending on how complicated the function you shouldnt even need a where block right?
09:04:31 <quiet_laika[m]> `myFunc as | length as > 2 = ...`
09:04:44 <quiet_laika[m]> oh well
09:04:48 <merijn> ezzieyguywuf: I mean like so: https://paste.debian.net/1149563/
09:04:49 <quiet_laika[m]> i guess the body is the same
09:05:02 <quiet_laika[m]> merijn++
09:06:09 <merijn> guards are like if/then/else, but superior in every possible way ;)
09:06:42 <wavemode_> MultiWayIf says you can have both
09:06:47 <maerwald> merijn: I wanted to get into cabal coding, but then surgery got in between. phadej needs help
09:07:31 <quiet_laika[m]> MultiWayIf++
09:07:31 <maerwald> many contributors, few maintainers
09:07:58 <merijn> wavemode_: I don't really like MultiWayIf, the advantage of my suggestion is you have names. Names are good
09:08:12 <scasc> Also checkout : Multiway ifs!
09:08:12 <maerwald> let foo in if | ... -- is awesome
09:08:28 <scasc> Ah, I see wavemode_ was faster
09:09:55 <ezzieyguywuf> merijn: woah, didn't know where and guards went together like that, nice.
09:10:36 <ezzieyguywuf> quiet_laika[m]: you're right, I don't technically need a where-block, but I end up duplicating the logic on a' and i"d like to avoid that
09:10:39 <ezzieyguywuf> for posterity.
09:10:52 <merijn> ezzieyguywuf: bindings/definitions in where blocks are exactly the same as the top level
09:11:11 <merijn> ezzieyguywuf: This also means you can define where blocks for functions/variables inside where blocks
09:11:20 <ezzieyguywuf> merijn: yea this is really neat
09:11:39 <merijn> ezzieyguywuf: See, for example, https://github.com/merijn/Belewitte/blob/master/benchmark-analysis/src/StepAggregate.hs
09:11:40 <ezzieyguywuf> I mostly find myself not using slash avoiding if-statements (seems the haskell way) and this seems like a veritable tool to help with that
09:11:57 <ezzieyguywuf> s/veritable/venerable/
09:14:10 <ezzieyguywuf> if anyone is interested in a bit of code review, I'd really like some feedback on my testing approach. Specifically, I'd like to hear thoughts on my test definitions themselves (are they general enough? specific enough?) as well as my use of helper functions in the property definitions themselves (is this silly? am i somehow reinventing the wheel?) . 
09:14:15 <ezzieyguywuf> https://gitlab.com/ezzieyguywuf/haskellcad/-/blob/master/test/TopologySpec.hs
09:16:32 <merijn> ezzieyguywuf: Super personal style remark: The way you're line wrapping type signatures is kinda weird
09:17:08 <merijn> If you move the :: to the next line you can nicely align your -> and => under it, see: https://github.com/merijn/Belewitte/blob/master/benchmark-analysis/src/StepAggregate.hs#L81-L85
09:17:57 <merijn> ezzieyguywuf: Also for things like prepXaddXAppendsNToY I'd just use a where block for all those. I find that let/in usually looks ugly, so I try to avoid it (as do most people it seems)
09:19:09 <ezzieyguywuf> merijn: thanks for taking a look!
09:19:45 <ezzieyguywuf> and yes, that is a nice stylistic note
09:19:48 <dsal> I wouldn't even bother wrapping stuff like prepXaddXDoesNotModifyY.  It's not significantly less readable on one line than six.
09:21:20 <ezzieyguywuf> dsal: I was trying to keep it to within 80 cols
09:21:28 <dsal> Alternatively, instead of ending each thing with `-> T.Topology -> Bool -- This is what is left for QuickCheck` you could just name that and end with the name
09:21:29 <ezzieyguywuf> and I was able to add comments this way too
09:21:46 <ezzieyguywuf> merijn: I'll keep in mind that in general it seems folks prefer where-blocks to let/in
09:22:06 <ezzieyguywuf> dsal: like I did with ModTopo, that's not a bad idea
09:22:10 <dsal> `addXDoesNotModifyY :: (Eq a) =>  ModTopo -> (T.Topology -> [a]) -> T.Topology -> Bool`  is less than 80.  I mentioned that one in particular because it doesn't have comments (other than the obligatory)
09:23:06 <dsal> `addXDoesNotModifyY :: Eq a =>  ModTopo -> (T.Topology -> [a]) -> T.Topology -> Bool` is even more less!  :)
09:24:06 <ezzieyguywuf> dsal: lol, yea thanks! I think I will do `type TopoProperty = T.Topology -> Bool` and move them to one-liners
09:24:39 <dsal> The new school seems to prefer tall code to wide.  I'd rather exceed 80 columns than have to scroll to read.  e.g. that entire code could fit on one page which, at least to me, is easier to read since I can see all the parts at once.
09:26:02 <dsal> Note that with QC, `Property` is a thing you might actually want to return instead of Bool.  Once you end up doing something slightly fancy with QC builtins, you won't use it anyway.  e.g., instead of `==` maybe you want `===` and now Bool doesn't fit.
09:27:01 <dsal> Also:  hlint would probably tell you that you have a lot of unnecessary `do` blocks.
09:27:08 <kamek> Say I have `a :: Either Err1 T` and `b :: Either Err2 T` and define a `data DomainErr = E1 Err1 | E2 Err2`. Is there a magical way to use a and b together in a do block and have their Lefts automatically mapped to DomainErr ?
09:27:57 <ezzieyguywuf> dsal: I'll check out hlint
09:28:21 <ezzieyguywuf> dsal: I'll read up on `Property` (I guess that's in the QuickCheck module?)
09:28:44 <dsal> ezzieyguywuf: Yeah.  It's just what you get if you use any additional features like ==> or === or labels or whatever.
09:29:03 <dsal> kamek: Not sure how that'd work.  What if `data DomainErr = E1 Err1 | E2 Err2 | E3 Err1` ?
09:29:06 <ezzieyguywuf> dsal: I also prefer wide to tall, I really liked your idea of mapping the output func to a type as that let me shorten it up.
09:30:26 <dsal> I use stylish-haskell, but ormolu has been gaining traction.  They at least began with elm guidelines which are unnecessarily vertically spacious.  It might be improving, at least.
09:31:38 <kamek> dsal: Good point, I don't mind having to define the mapping elsewhere though. I'm after something similar to Rust's `From` combined with the `?` operator. Maybe I'm just approaching things the wrong way
09:32:31 <ezzieyguywuf> boom, this incorporates all the changes we've discussed, thanks for taking a look merijn and dsal ! https://gitlab.com/ezzieyguywuf/haskellcad/-/blob/master/test/TopologySpec.hs
09:32:32 <dsal> I think either is a bifunctor.  You could map the lefts into your domain error, but I don't think it'll happen magically.
09:34:15 <kamek> that's what I'm using right know, it's ok I guess, but the mapping is a bit noisy so I wanted to move it somewhere else
09:35:20 <dsal> ezzieyguywuf: `ModTopo -> (T.Topology -> Bool)` looks a little weird to me.  You could just use `ModTopo -> TopoProp`.  In any case, the parens aren't necessary.
09:35:31 <dsal> :t undefined :: (a -> (b -> c))
09:35:33 <lambdabot> a -> b -> c
09:36:15 <L29Ah> > undefined "rabbit"
09:36:17 <lambdabot>  *Exception: Prelude.undefined
09:36:50 <ezzieyguywuf> dsal: yea, I missed that on the properties
09:37:47 <dsal> The parens in particular look weird.  That's how all functions work. :)
09:37:51 <ezzieyguywuf> fixed it ^_^
09:38:13 <ezzieyguywuf> dsal: hm, are the parens not needed?
09:38:20 <dsal> :t undefined :: (a -> (b -> c))
09:38:21 <lambdabot> a -> b -> c
09:38:22 <ezzieyguywuf> I guess not, because of currying
09:38:30 <ezzieyguywuf> my brain hurts sometimes when I think of these things :-P
09:38:50 <ezzieyguywuf> the parens definetely helped me when I was logicing through it though :-P
09:38:57 <dsal> Soon your brain will hurt when you're working on something else and they're missing.
09:39:33 <dsal> Yeah, I do dumb things sometime when the right thing doesn't work at first.
09:51:45 * hackage summoner 2.0.1.1 - Tool for scaffolding fully configured batteries-included production-level Haskell projects.  https://hackage.haskell.org/package/summoner-2.0.1.1 (vrom911)
09:52:10 <Shiranai> Are bytestrings always better when doing IO? Are there any cases where I'd prefer plain strings?
09:54:15 * hackage summoner-tui 2.0.1.1 - Tool for scaffolding fully configured batteries-included production-level Haskell projects using TUI.  https://hackage.haskell.org/package/summoner-tui-2.0.1.1 (shersh)
09:54:19 <[exa]> Shiranai: if you don't care about performance (IO is tiny) and you are sure that the input will be valid unicode, it's probably okay to go with just String
09:55:34 <Shiranai> aight, thanks
09:57:15 * hackage cases 0.1.4 - A converter for spinal, snake and camel cases  https://hackage.haskell.org/package/cases-0.1.4 (NikitaVolkov)
09:59:57 <merijn> Shiranai: ByteString and Strings are entirely different and not alternatives to each other
10:00:58 <Shiranai> I get that they are different, but why wouldn't they be alternatives to each other?
10:01:57 <quiet_laika[m]> Shiranai they're really meant for entirely different things. they are only "alternatives" in the sense that String is probably used lots of places where ByteString would be more appropriate
10:02:03 <samiamsam> Shiranai: the alternative to String that is semantically equivalent is Text, while ByteString is semantically quite different and in that sense not an alternative
10:02:52 <L29Ah> ByteString is a C buffer
10:02:53 <wavemode_> Shiranai: usually what you want is Text, if what you're dealing with is, well, text. If it's not text and is rather some other kind of data (a binary file, encrypted data etc.) then you would use ByteString
10:03:23 <quiet_laika[m]> how do people feel about `>>` vs `*>`? :think:
10:03:53 <dsal> quiet_laika[m]: monad of no return...
10:03:54 <Shiranai> Hmm so to have a concrete example, if I were writing a ToDo CLI I should use text, right? (Assuming I want to display it at some point)
10:03:58 <dsal> Though I use >> a lot
10:03:59 <L29Ah> i feel like >> belong in Applicative
10:04:10 <dsal> Shiranai: If you are displaying text, you should use Text.
10:04:19 <dsal> If you are processing blobs, you should use ByteString
10:04:20 <L29Ah> and *> should be a deprecated synonym
10:04:50 <dsal> *> is part of <*>
10:05:01 <wavemode_> and deprecate return while they're at it :p
10:05:01 <dsal> >> doesn't really fit in anywhere except for being 2/3 of a bind, I guess.
10:05:12 <dsal> wavemode_: that's "monad of no return"
10:05:12 <Shiranai> Ok, that makes sense, then I shouls only use strings as inputs/outputs of "intermediate" functions?
10:05:25 <dsal> Shiranai: sages would suggest never using String
10:06:17 <L29Ah> dsal: >> is more convenient to type than *>!
10:06:22 <Shiranai> damn sounds hard, I will try to then, thanks
10:06:29 <EvanR> String being a list means it's more conceptually like a single loop over Char, not a data storage strategy
10:06:54 <Cheery> you should not assume that type has an implementation
10:07:02 <Cheery> or that it's specific
10:07:11 <dsal> L29Ah: Yeah, I don't ever even think to do *> when I'm monading
10:07:13 <EvanR> don't assume String = [Char] ?
10:07:14 <Cheery> string is a denotation for a monoid consisting of characters.
10:07:26 <dsal> So is text?
10:07:43 <Cheery> well Haskell doesn't have it all right.
10:07:51 <L29Ah> EvanR: String is [Char] in some haskell standard
10:08:03 <dsal> Haskell would have more right if it weren't for the users.
10:08:19 <EvanR> uhm
10:08:26 <wavemode_> Most hypothetical reasons for using String are satisfied via text Builder
10:08:54 <dsal> I use String a lot out of sheer laziness.
10:09:21 <L29Ah> what's the Prelude with Text?
10:10:21 <wavemode_> protolude banishes String
10:12:18 <Cheery> just because you got (Bool,Bool,Bool) doesn't mean that it should be a linked list of pointers.
10:13:05 <L29Ah> but it is not a linked list of pointers
10:15:24 <polyphem> Hi , is mapAccumL faster on Data.Sequence than on Lists ?
10:16:43 <wavemode> why would it be?
10:17:39 <polyphem> because Lists are not the fastest container , and Seq is said to be faster in some cases .. 
10:19:57 <cocreature> polyphem: Seq is mainly faster when it comes to indexing. if you traverse the whole list lists arenâ€™t that bad
10:20:23 <solonarv> *indexing into* lists is slow. if you're walking through the entire data structure one by one, lists are fine.
10:20:50 <slack1256> Do you expect that `base` functions should be written in a way they express maximal laziness?
10:21:04 <dsal> Sticking a new element on the front of a list is super fast.
10:21:24 <slack1256> That sentiment is expressed on the mailing lists sometimes but I don't know how popular that idea is.
10:24:05 <polyphem> cocreature , solonarv :  ok, thanks , makes sense
10:30:13 <st8less> I've seen a lot of Maybe examples using things like safeDiv for when the denominator is 0.  Why not use the type system to restrict the domain of the function?  I guess that could be considered punting the problem to a different place, but curious from a functional n00b's viewpoint.
10:31:22 <slack1256> st8less: That's an alternative, yes.
10:32:08 <st8less> Is one pattern more common than the other in Haskell projects?
10:32:10 <slack1256> I guess when those functions where being written, it was popular to use the monadic chaining of Maybe to deal with failures.
10:32:45 <slack1256> I certainly like more to restrict the domain of the functions instead of increasing the codomain of them.
10:32:57 <wavemode__> do people really use safeDiv in the real world? I think in practicality most people just make sure their denominators aren't zero
10:33:07 <awpr> Haskell's type system isn't currently great at expressing things like "nonzero integers", so it tends not to happen much
10:33:08 <st8less> Yeah, at some point you have to deal with the possiblity of invalid inputs, so the Maybe doesn't magically disappear.
10:33:45 <st8less> awpr: I was wondering about that, too
10:33:50 <st8less> Thanks for the replies!
10:34:01 <awpr> barring Liquid Haskell, we can't say (fake syntax) `div :: Int -> {x :: Int s.t. x /= 0} -> Int`
10:34:42 <awpr> the best we can do is have a newtype that enforces the invariant of not being zero, in which case you have to get one of those values somehow
10:34:56 <awpr> which would just move the Maybe back to `mkNonZero :: Int -> Maybe (NonZero Int)`
10:36:43 <dsal> What would be the best thing in theory?  I don't see how you could generally guarantee a NonZero Int when writing code that is just moving around numbers.
10:36:49 <dsal> i.e., the Maybe has to live somewhere.
10:36:53 <awpr> for division by a static constant we can actually do better, but it's a bit heavy-handed in practice: `divC :: forall n. (KnownNat n, IsNonZero n) => Int -> Proxy n -> Int`
10:37:11 <statusfailed> How can you extract metadata information from the GHC.Generics.M1 type? For example, in https://hackage.haskell.org/package/base-4.14.0.0/docs/GHC-Generics.html they have an instance (Encode' f) => Encode' (M1 i t f) , but it throws metadata information away- how do you use it?
10:39:16 <awpr> yeah, ultimately you do have to prove nonzero-ness somehow.  if you're starting from a runtime Int, that's going to be with a dynamic check or unsafe "I promise" kind of code.  but sometimes you can trick the type checker into proving things about Nats for you
11:01:33 <monochrom> Methods of the type classes Datatype, Constructor, Selector, etc. can do it.
11:02:19 <monochrom> For example if your M1 has a data constructor, then Constructor's method conName gives you the data constructor name.
11:02:56 <ezzieyguywuf> wooohoooo TDD helped me find a bug
11:02:57 <ezzieyguywuf> lol
11:04:33 <Uniaika> hurray
11:05:02 <ezzieyguywuf> ^_^
11:09:17 <statusfailed> monochrom: ah the trick was I had to give instances for D1, C1, and S1, rather than M1
11:09:58 <monochrom> But there are all aliases of M1, just with different parameters.
11:10:06 <statusfailed> e.g., instance (Constructor c, GSerialize f) => (GSerialize (C1 c f)) where ...
11:10:22 <statusfailed> monochrom: yeah I know that's why I was confused :D
11:10:25 <ezzieyguywuf> I have `func :: a -> b -> [c]` and I want to get the legth of `c`. Is there a way to `f = length . func` so i can `f a b` and get an Int?
11:12:35 <monochrom> No.
11:12:46 <wavemode__> f = (length .) . func
11:13:02 <ChaiTRex> @pl \ a b -> length (func a b)
11:13:02 <lambdabot> (length .) . func
11:14:00 * dmwit . o O ( f a b = length (func a b) )
11:14:11 <ezzieyguywuf> wavemode__: that works!
11:14:28 <ezzieyguywuf> but i'm confounded as to why 
11:14:42 <monochrom> This is why "no" is the best answer for beginners.
11:15:00 <monochrom> Programming is not Wizarding World spell/charm casting.
11:15:19 <dmwit> If you're going to skip the pointfree solution, I think my answer is better than "no".
11:15:51 <monochrom> OK! I concede that.
11:16:46 <monochrom> Wizarding World magic = Chinese room
11:17:40 <ezzieyguywuf> dmwit: what is the pointfree solution?
11:17:45 <ezzieyguywuf> and I don't understand your answer...
11:18:07 <monochrom> Huge lookup table of "this phrase does that" and no underlying principle of lower Kolmogorov complexity than the huge lookup table.
11:19:04 <wavemode__> ezzieyguywuf: working through the types of (length .) . func is an educational exercise. but frankly, pointfree style is overrated and you should write it the long way
11:19:05 <monochrom> dmwit's answer means: define "f a b = length (func a b)".  Then "f a b" gives you an Int, as wanted.
11:19:27 <ezzieyguywuf> monochrom: ahhh
11:19:32 <ezzieyguywuf> that makes sense to me
11:20:14 <ezzieyguywuf> and I would have tried `f = length $ func`, which would have failed (I suppose) because of the parens and dots in dmwit 's answer
11:20:41 * tomsmeding . o O ( this is a thought bubble :) )
11:20:44 <monochrom> Do you understand that  length $ func = length func
11:21:11 <ezzieyguywuf> tomboy64: ah hah!
11:21:13 <ezzieyguywuf> . o O
11:21:14 <Shiranai> Wait how does that work? What is the dot after length? Just function composition?
11:21:16 <ezzieyguywuf> interesting
11:21:17 <monochrom> Do you understand that $ has a simpler underlying principle than yet another Harry Potter spell.
11:21:31 <ezzieyguywuf> monochrom: no I don't understand that...
11:21:51 <ezzieyguywuf> monochrom: my understanding of $ is that it replaces right-grouping parens
11:21:54 <monochrom> Definition of $ goes like this very simply: f $ x = f x
11:22:07 <tomboy64> saywat?
11:22:20 <monochrom> It doesn't replace any parentheses.  Operator precedence does.
11:22:39 <monochrom> This is what's wrong with cargo culting.
11:22:42 <ezzieyguywuf> `(f1 (f2 (f3 a)))` == (from my understanding) `f1 $ f2 $ f3 a`
11:22:58 <monochrom> This is what's wrong with telling beginners about $
11:23:19 <ezzieyguywuf> yea, i think i learned about it in learn you a haskell for great good
11:23:28 <Cale> haha, I think it's fine to tell beginners about ($), just so long as you also tell them about its definition
11:23:48 <monochrom> This is what's wrong with programmers, having flunked math, go out of their ways to avoid parentheses because they are scared.
11:23:56 <ezzieyguywuf> shoot
11:24:01 <ezzieyguywuf> my math skills are on point.
11:24:12 * ezzieyguywuf stands taller
11:24:29 <Cale> Parentheses can actually be a real nuisance though, especially for expressions which span several lines
11:24:39 <Cale> Mathematics rarely has expressions which are so long
11:25:12 <monochrom> For long expressions, a more universal solution is local definitions. This works for other languages too.
11:25:12 <wavemode__> i dont think that's really true :p
11:25:44 <Cale> But I don't think there's ever a really good reason to chain ($)
11:26:01 <monochrom> In fact math suffers as much, and the solution is also local definitions.
11:26:10 <Cale> You can always have written f . g . h $ x when you would have written f $ g $ h $ x
11:26:33 <Cale> (pretty much, barring perhaps some situations involving other infix operators)
11:26:49 <EvanR> math has some luxurious tricks like, change the font size or put a fraction bar for grouping. Or inexplicable do sin^2 x
11:27:44 <Cale> Yeah, in math, we can just invent whatever notation suits our current whims, and most things in formulas end up named with single letters.
11:27:57 <monochrom> Consider compactness in topology.  It is a long sentence: for every family F of open subsets such that F's union is a superset of your X, there exists a finite subfamily G of F such that G's union is a superset of your X
11:28:15 * hackage hnix 0.8.0 - Haskell implementation of the Nix language  https://hackage.haskell.org/package/hnix-0.8.0 (JohnWiegley)
11:28:28 <Cale> Compactness usually doesn't even have a name that would be inserted into a formula
11:29:07 <merijn> Simple heuristic: If you have more than one $ in a line/expression it's probably bad :p
11:29:20 <monochrom> Mathematicians deal with that by making a couple of definitions for subphrases. For example, define "open cover" and "subcover" suitably, then the sentence is shortened to: for every open cover, there exists a finite subcover.
11:29:34 <monochrom> And one more definition, and you just say "compact" henceforth.
11:29:37 <wavemode__> people complain about the mess of the english language, meanwhile mathematicians write nonsense like sin^2 x :p
11:30:02 <Cale> It's fair enough that you can make smaller definitions, but it's possible to go too far in that direction as well.
11:30:10 <chloekek_> When Cabal complains about a conflict â€œcircuits => circuits:setup.Cabal>=1.8 && <1.25â€, what does that mean? (circuits is the name of my library)
11:30:16 <monochrom> Now, you say, those are top-level definitions, you define them once globally, then a million proofs can benefit. Yes.
11:30:20 <Cale> Sometimes it just doesn't make sense to define abstractions for things.
11:30:30 <Shiranai> can I use type definitions inside a function being defined inside a let (in a let-in definition)
11:31:07 <monochrom> But there are also ample examples of proof-local definitions like that, definitions that are only useful in the context of one single proof.  And the definitions are for really long, 4-alternating-quantifiers sentences.
11:31:30 <Cale> Shiranai: you can't define new types there, but you can use types that you have defined there
11:31:46 <Cale> Shiranai: Definitions of types must go at the top level
11:31:47 <merijn> chloekek_: Looks like you have a Custom Setup.hs?
11:31:54 <chloekek_> merijn: I have no Setup.hs file
11:32:15 <merijn> chloekek_: Cabal seems to disagree ;) What's your cabal file?
11:32:58 <chloekek_> merijn: but I do use Nix haskellPackages.shellFor
11:33:23 <chloekek_> Iâ€™m extremely confused about Nix and Haskell, and almost at the point of throwing it all out and just calling GHC directly.
11:33:41 <merijn> chloekek_: Oh, I never could be bothered with Nix
11:34:11 <merijn> chloekek_: I know the Nix Evangelism Strike Force likes to claim differently, but imo nix seems like a whole lotta work for not much gain
11:34:26 <Shiranai> Cale: How could I ensure that my func in this code works correctly then? (without creating it outside) https://pastebin.com/8izx2bGJ
11:34:47 <chloekek_> merijn: I use Nix for all development, and refuse to globally install compilers and interpreters. But I have never succeeded in using Nix together with Cabal, with GHC it works fine.
11:34:58 <Cale> Shiranai: What's the newly defined type here?
11:35:15 <Shiranai> wait maybe I'm usign the phrase type definition badly
11:35:21 <monochrom> We need a standard form to fill in for cabal tech support.
11:35:24 <merijn> chloekek_: Cabal and GHC are rather well behaved when "installed globally"
11:35:43 <Shiranai> but I mean I want to do `func :: [a] -> Int`
11:35:46 <monochrom> GHC version, cabal-install version, OS, are you using nix, etc etc
11:36:02 <Cale> chloekek_: cabal install is generally bad with nix, but you should be able to cabal build just fine
11:36:04 <merijn> chloekek_: They auto sandbox everything by GHC version, so you can have as many installs as you want without issue
11:36:41 <monochrom> Nix is global.
11:36:43 <Cale> Shiranai: ah, you can certainly do that
11:37:03 <monochrom> Nix is so global you can't even change from /nix to /home/monochrom/nix
11:37:11 <Cale> Shiranai: type annotations are allowed
11:37:22 <merijn> monochrom: I know, right
11:37:29 <merijn> monochrom: Talk about mixed opportunities
11:37:30 <Cale> monochrom: You could, but it would break all the caches
11:37:38 <merijn> Cale: Only if you build from source
11:37:40 <monochrom> It is simpler to admit that your philosophy is "I refuse to not use nix".
11:37:47 <Cale> merijn: right
11:37:59 <monochrom> nixed opportunities
11:38:02 <merijn> Cale: Which defeats like 90% of the reasons I'd wanna use Nix
11:38:20 <Cale> I think it's fair that if you want to leverage caches, then you need to keep install directories consistent with those caches
11:39:07 <Cale> Nix is all about making different machines look similar enough anyway
11:39:10 <merijn> Main reason I wantedW Nix was to not build a bunch of stuff from source with all the painful dependency hunting, but then they make me hunt down like 8+ Nix dependencies :\
11:39:19 <Cale> If I spin up a new host, I don't care
11:39:30 <merijn> Cale: I really, *really* want to like Nix, but they make it so damn hard
11:39:34 <Cale> ... if it's /nix or /home/foo/nix or whatever
11:39:50 <merijn> Cale: You would if you didn't have root access to make /nix :p
11:40:00 <Cale> But I do, because I just created the machine
11:40:34 <merijn> Cale: Yeah, but I don't
11:40:46 <Cale> I totally agree that nix isn't good if you don't own your computers
11:41:00 <merijn> Frankly, the fact that every linux package manager requires root is downright embarassing
11:41:01 <monochrom> What have I done? :)
11:41:06 <merijn> Utter failure of engineering
11:41:34 <Lycurgus> see? FP is a family of religions. that being the case nix/os was in ur future
11:41:42 <monochrom> ah pastebin.com is so much nicer when raw
11:41:47 <Cale> Is it though? I mean, there's a lot of important things about the system that you're not going to be able to change anyway, if you don't have root.
11:41:47 <chloekek_> I recently came across this project that would generate a Nix derivation for each module but I forgot what it was called.
11:42:14 <chloekek_> It was something with an S (not Stack).
11:43:15 <merijn> Cale: How many programs actually require changing those things?
11:43:48 <merijn> Cale: Actually, name one application that requires root besides anything involving drivers
11:43:55 <Cale> Well, it's more like "do I really want to deal with uncontrolled variation in those things in deployment of my software?"
11:44:04 <monochrom> sudo :)
11:44:06 <Cale> Why leave the kernel up to chance?
11:44:14 <Shiranai> Using type annotations inside a let gives me an error https://pastebin.com/9PRstaUJ , ghc only tells me that "parse error on input let"
11:45:00 <Cale> Shiranai: That type annotation isn't inside the let
11:45:11 <monochrom> let { mySum :: Int -> Int -> Int ; mySum = (+) } in (mySum a b) * c
11:45:25 <ChaiTRex> Shiranai: Like this: https://pastebin.com/sf4hD2hL
11:45:28 <monochrom> You may also use layout instead of { ; }
11:45:41 <Shiranai> god I feel so stupid haha
11:45:44 <Shiranai> tahnks guys
11:46:02 <chloekek_> Ah, it was called Snack.
11:46:06 <Shiranai> Using brackets and semicolons is the same as indenting? first time I see that
11:46:07 <Cale> http://dpaste.com/2GERHWE -- here's what it looks like with layout
11:46:12 <monochrom> @botstack
11:46:12 <lambdabot> :)
11:46:14 <Cale> chloekek_: ahhhh, that's it
11:46:21 <Cale> (I was trying to think of it as well)
11:46:44 <chloekek_> I found it with the GitHub topic page for Nix, then Ctrl+F Haskell.
11:47:16 * hackage splint 1.0.1.1 - HLint as a GHC source plugin.  https://hackage.haskell.org/package/splint-1.0.1.1 (fozworth)
11:47:49 <monochrom> merijn: Also, this requires root: runghc Setup.hs install :)
11:48:06 <merijn> monochrom: Cabal and ghc work and install fine without that, though
11:48:07 <Cale> merijn: But also things like the glibc and various system services can't be meaningfully changed by single users
11:48:50 <Cale> If my application requires an external mail server to be running, I'm probably going to need to be root to set that up.
11:49:26 <chloekek_> Cale: Iâ€™ll give it a try and report back.
11:49:27 <merijn> Cale: That seems like a rather niche reason for package managers to not support installing the ten billion applications not requiring that
11:49:46 <merijn> Hell, there's like 5 different Conda's and a ton of other package managers doing literally that
11:50:06 <merijn> Except, since they're not integrated and getting the support that apt-get and co do they all suck and break non-stop
11:50:09 <monochrom> I will think about package managers more carefully.
11:50:46 <dsal> I think I ran into Snack once.  It was pretty terrible if that's the thing I ran into.
11:51:15 <monochrom> For now, it is Haskell packages that are worst in having paths hardcoded into binary builds, not relocatable.
11:51:42 <monochrom> So if someone built it with prefix=/usr you need root to install it.
11:51:54 <merijn> monochrom: What?
11:52:00 <monochrom> I have been bugged by that for a long time.
11:52:07 <merijn> monochrom: Since when?
11:52:15 <monochrom> The dawn of men.
11:52:45 <merijn> monochrom: Cabal supports overridable lookups of executables and data files to be relocatable
11:53:08 <monochrom> and the generated haddock html files? the links inside?
11:53:11 <merijn> monochrom: Do you have an example of hardcoded path in binary builds?
11:53:26 <monochrom> the generated haddock html files. the links inside.
11:53:54 <merijn> I don't really know how haddock functions, but I'm pretty sure that when I last used local haddock they weren't under /usr and worked fine
11:54:03 <Cale> merijn: Maybe. I tend to think about nix in terms of the situations where I presently use it, which is mostly developing and building web applications and deploying the backends to AWS machines
11:55:01 <Cale> I don't actually use it to control most of the software on my machine -- only the software I'm using that's related to those project builds.
11:55:23 <Cale> (and I think it's okay to need root to make my machine look more like the eventual deployment machine)
11:57:01 <Cale> Most of my coworkers use nix to control their personal machines though, and I'm envious of a few aspects of that, though overall not enough to do it myself
11:57:32 <Cale> It's really nice when you get a new computer to just be able to copy some config over to it and immediately have it configured the way that you like your machines set up.
11:58:59 <monochrom> Bah no one comes to my office hours
11:59:41 <monochrom> This is why I am harassing all of you here.
12:00:18 <monochrom> Like, instead of doing the next AoE2 DE challenge. :)
12:03:29 <merijn> monochrom: You're aware games have come out since AoE2, right? ;)
12:04:21 <monochrom> yes, but doesn't matter
12:04:57 <monochrom> and perhaps we can argue over whether the DE counts as "a game that came out since AoE2".
12:07:29 <monochrom> similarly, many languages have come out since Haskell, but here I am, not even having touched Kotlin.
12:07:45 <monochrom> or even Agda
12:07:45 <merijn> ;)
12:07:46 <chloekek_> Cale: No success, too difficult to install.
12:09:27 <dgpratt> I wanted to try to use ghcup just to see how that felt, but I think I feel better about using nix -- any advice on removing ghcup and what it placed? I assume I can remove ghc, cabal, etc. through ghcup, but what about ghcup itself?
12:10:27 <solonarv> ghcup lives entirely in ~/.ghcup (if you didn't change the defaults)
12:10:57 <dgpratt> ok, thanks solonarv 
12:11:14 <monochrom> I think only two persons in the whole world know about non-default ghcup location :)
12:11:26 <solonarv> cabal (which you probably also used) keeps its stuff in ~/.cabal and similarly doesn't spill elsewhere AFAIK
12:12:17 <monochrom> (One such person enjoys it, the other person is thoroughly annoyed because he has to keep that feature working. :) )
12:27:14 * hackage hspec-expectations-json 1.0.0.0 - Hspec expectations for JSON Values  https://hackage.haskell.org/package/hspec-expectations-json-1.0.0.0 (PatrickBrisbin)
12:45:51 <maerwald> dgpratt: rm -r ~/.ghcup
12:47:14 <dsal> dgpratt: The nice thing about doing this in nix, is you can uninstall by typing `exit` heh
12:47:44 <maerwald> nix is nice if you have infinite storage
12:47:58 <dsal> I'm running NixOS on a super old Chromebook.
12:48:17 <dsal> I think it's a 64GB SSD and 4GB of RAM.  It's a little tight as my haskell dev box.
12:48:30 <maerwald> 4gb of ram?
12:48:42 <maerwald> I couldn't even build my smallest project with that
12:49:14 <dsal> https://en.wikipedia.org/wiki/Chromebook_Pixel <-- oh man, there was an 8GB version of that.
12:49:44 <maerwald> I have done *some* deving on an 8gb thinkpad, but it was awful
12:50:24 <maerwald> I'm aiming at 64gb for my next haskell devbox
12:50:55 <dsal> Setting `jobs: 2` in stack makes things at least... finish.
12:51:07 <maerwald> I always set to 1, no matter the cores or ram
12:51:35 <dsal> I wouldn't mind more concurrency in general, but it always finds all the largest things and tires to do them all at the same time.
12:52:16 <maerwald> compilation ram use is so unpredictable that it's hard to find a default that works consistently
12:52:36 <maerwald> but $ncpu is almost always wrong
12:52:57 <maerwald> yet it is the default for both cabal and stack -.-
12:52:59 <dsal> Heh, it's not *that* unpredictable.  aeson is going to be huge.
12:53:56 <maerwald> well, if you build pandoc and a small package in parallel, ok. If you build pandoc and, say, amazonka in parallel
12:53:58 <maerwald> boom.
12:54:34 <dsal> Is amazonka a big compile?  I use it in a few places, but everytime it's stuck and I look, it's like aeson or lens-something.
12:55:21 <maerwald> Not sure about big compile, but it eats ram.
12:55:37 <maerwald> Which probably means very large modules
12:55:50 <maerwald> Which is common for generated or semi-generated stuff
12:57:04 <Cheery> implemented my own variation of optimal reduction, but not sure if it's correct.
12:57:07 <dsal> I've only seen bits of amazonka.
12:57:20 <Cheery> Ideas on how to verify this works? https://gist.github.com/cheery/15966c6df4f14fa2681a138d8794df73
12:57:53 <maerwald> dsal: all the type-safety is for nothing :P
12:58:29 <dsal> I like it so far.  It's done all the things I've needed.  :)
12:58:43 <dsal> Cheery: Looks like haskell code.  If it compiles, it's correct.
12:58:55 <maerwald> dsal: https://github.com/brendanhay/amazonka/issues/546
12:59:02 <maerwald> this hit a lot of companies in production
12:59:11 <dsal> Heh, I've hit that bug.
12:59:37 <dsal> Oh yeah, my name's in there.
13:00:18 <maerwald> There's only so much types can do ;)
13:00:23 <dsal> "As long as the functionality is in the library, we have runtime bugs that could be compile time bugs.  Filtering it out in the meantime would be an improvement." -- I guess I already argued your point before suggesting it wasn't a big deal a minute ago.
13:01:33 <Cheery> dsal: I roughly have an idea how that could be correct, but there's few details that I have had difficult time to figure out.
13:02:30 <dsal> Cheery: what is that?
13:05:22 <Cheery> the exp/at -structures represent scope of an element that can be copied. It triggers when copy hits 'Exp', and the 'At' is divided at the same time.
13:05:37 <Cheery> so it triggers with "inner" and "outer" copying.
13:06:07 <Cheery> though, "At" is there so that another "Exp" can enter that element. I'm not sure I've thought it through.
13:07:03 <Cheery> but in other hand it forms something that seems fairly consistent in behavior, and I'd think it may work.
13:13:12 <dsal> Bigger picture, though, what are you working on?
13:14:52 <Cheery> Programming language stuff. This is an attempt to get a normaliser for classical linear logic.
13:18:01 <kuribas> dminuoso: the unbound library doesn't look very efficient: https://hackage.haskell.org/package/unbound-generics-0.4.1/docs/Unbound-Generics-LocallyNameless-Subst.html#v:substs
13:18:13 <kuribas> dminuoso: subs uses a list, instead of a map
13:22:28 <ezzieyguywuf> how do I take a Data.Text in ghci and print it without, say, the '\n' showing up as '\n' but as actually newlines?
13:23:02 <kuribas> putStr?
13:23:16 <kuribas> > Data.Text.putStr "hello\nworld"
13:23:18 <lambdabot>  error:
13:23:18 <lambdabot>      Not in scope: â€˜Data.Text.putStrâ€™
13:23:18 <lambdabot>      No module named â€˜Data.Textâ€™ is imported.
13:23:57 <ezzieyguywuf> kuribas: I think that's in Data.Text.IO maybe, let me try that
13:24:06 <ezzieyguywuf> I tried with raw putStr but I guess that's in prelude as something else
13:24:29 <ezzieyguywuf> yup that did it
13:24:34 <kuribas> ezzieyguywuf: prelude putStr works on String not Text
13:24:39 <kuribas> :t putStr
13:24:40 <lambdabot> String -> IO ()
13:25:54 <t7> Can i tell ghcide to ignore my stack.yaml ?
13:26:18 <t7> (otherwise it fails to start with ghcide: ghcide: unable to load package `ghc-prim-0.5.3')
13:31:41 <dsal> ezzieyguywuf: You wouldn't worry too much about how to get stuff working well in ghci.  However, the "take" part is pretty easy, though.   `:set -XOverloadedStrings` in the .ghci is a must.
13:33:10 <ezzieyguywuf> dsal: is it though?
13:33:23 <ezzieyguywuf> I've heard some convos in here that suggest that maybe that shouldn't be used globally
13:33:43 <dsal> For any given thing, someone disagrees with it.
13:33:46 <ezzieyguywuf> and also, at least for me right now (as I am early in my haskell learning), it helps to be explicit about what is what.
13:34:02 <ezzieyguywuf> I don't mind the extra Text.pack for now, because again, it forces me to think about what's going on
13:34:18 <dsal> But OverloadedStrings seems to be considered generally a "oh come on, why isn't this the default"
13:35:00 <Cheery> heh. I had issue with the simplest function in the whole thing, that can be verified to be correct, especially if I type annotate it more generally.
13:35:10 <ezzieyguywuf> ind in terms of 'getting things working well in ghci', ghci is very handy for debugging.
13:35:21 <ezzieyguywuf> so it's nice to be able to view prettyprinted stuff
13:35:28 <dsal> Do you use scoped types as well so your numbers are always clear as to what their types are? :)
13:36:09 <ezzieyguywuf> dsal: how do you mean?
13:36:14 <dsal> :t 1
13:36:15 <lambdabot> Num p => p
13:36:17 <ezzieyguywuf> oh, like on my numeric literals?
13:36:20 <dsal> :t "one"
13:36:21 <lambdabot> [Char]
13:36:23 <ezzieyguywuf> no I don't do that
13:36:25 <dsal> % :t "one"
13:36:26 <yahb> dsal: [Char]
13:36:41 <dsal> Weird.  Anyway.  Same concept.
13:36:50 <Cheery> ghci program I tried. *Linc> runST ((fresh 2 >>= (\env -> pure (eval env [] (Pair (Link 1) (Link 1))))) >>= (\stuf -> readback stuf ([],[]) >>= pure . readback_done))
13:37:08 <ezzieyguywuf> dsal: I'm not 100% against it, but for now I prefer to be more explicit.
13:38:51 <dsal> All of these things have an IsString instance, so instead of using custom functions (like Text.pack, BL.pack, BS.pack, etc...) you can just use `fromString "one"` (or just don't do that, because that's what OverloadedStrings does.
13:39:52 <dsal> Most of my programs have three or four (or so) string types.  I wouldn't want to do special things for literals for each of those.
14:03:15 * hackage shake-plus 0.0.3.0 - Re-export of Shake using well-typed paths and ReaderT.  https://hackage.haskell.org/package/shake-plus-0.0.3.0 (locallycompact)
14:08:15 * hackage shake-plus 0.1.4.0 - Re-export of Shake using well-typed paths and ReaderT.  https://hackage.haskell.org/package/shake-plus-0.1.4.0 (locallycompact)
14:25:15 * hackage shake-plus 0.1.4.1 - Re-export of Shake using well-typed paths and ReaderT.  https://hackage.haskell.org/package/shake-plus-0.1.4.1 (locallycompact)
14:41:00 <freeman42x[m]1> anyone got haskell ide engine to work with cabal script files? https://github.com/haskell/haskell-ide-engine/issues/1780
15:10:55 <Boarders_> does anyone know if haskell without the llvm backend generates decent assembly if you do something like (`div` 2^12)?
15:14:35 <Uniaika> that's actually an interesting question
15:14:36 <Uniaika> let me try
15:18:27 * Lycurgus expects it emits reasonable c by default, with a fuckton of overhead
15:19:06 * Lycurgus and even the thing many times the size of hand coded c
15:20:22 * Lycurgus let alone assembly
15:21:22 <Lycurgus> jump off a steep cliff then step off a curb
15:22:08 <Uniaika> Boarders_: https://hastebin.com/fesogikeju.pl
15:22:27 <Uniaika> Lycurgus: if you're interested ^
15:22:36 * Lycurgus looking
15:22:47 <Uniaika> (I printed the result of the computation to kinda-sorta force evaluation)
15:23:03 <Uniaika> (didn't want GHC to discard an unused variable lol)
15:24:43 <Lycurgus> about as expected, the fuckton comes with the symbol ref
15:25:10 <Lycurgus> appeared to be a few tens of lines of machine oriented code
15:25:32 <dsal> fucktonnal programming?
15:25:33 <Lycurgus> but a hand coding in one could doubtless be under 10
15:25:54 <Lycurgus> *symbol refs
15:26:19 <Lycurgus> dsal: lol
15:28:38 <Lycurgus> way under 10
15:31:13 <Lycurgus> you would think at this point in history that lines of code might not map to instructions
15:31:32 <Lycurgus> but i can't thin of anything without qubits that doesn't
15:31:37 <Lycurgus> *think
15:32:00 <Lycurgus> i.e. lines of machine oriented code
15:32:52 <dsal> I rewrote some arduino code in asm a while back.  It was nuts how much stuff it does to do the most trivial thing.
15:32:53 <Lycurgus> ie. no physical arch, can think of soft ones
15:33:32 <Lycurgus> yeah its a pretty conventional instruction set arch
15:34:53 <Lycurgus> with qubits u can do anything, square the circle, have the cat and eat it too
15:39:43 <Lycurgus> sfaik, the only thing not insstruction set is the tiny set of arches that were user microprammable
15:40:51 <Lycurgus> which still dosn't even begin to approach what might be possible if the units of computation were synapse like rather than arithmetic registers
15:47:32 <Lycurgus> *uprogrammable, Instruction
16:05:18 <quiet_laika[m]> is there an easy way to replicate `taking` and `dropping` from `lens` in `optics`?
16:08:43 <dsal> What do you mean "replicate" ?
16:08:46 <dsal> :t taking
16:08:47 <lambdabot> (Conjoined p, Applicative f) => Int -> Traversing p f s t a a -> Over p f s t a a
16:09:15 <dsal> Oh, I parsed what you mean.
16:09:20 <dsal> I've not used `optics`.
16:14:30 <quiet_laika[m]> im trying to use it going through Optics by Example
16:14:35 <quiet_laika[m]> but it's missing a lot of combinators they use
16:14:46 <quiet_laika[m]> so i may just switch to lens
16:18:08 <dsal> Yeah, lens is a junk drawer, but if you're just trying to learn all the concepts, having all the parts available is helpful.
16:19:17 <c_wraith> pfft. it's the assorted item drawer, not the junk drawer. those things are all useful!    ... sometimes.
16:30:58 <ezzieyguywuf> If I want to concatenate a [Char] and an Int, is it 'right' to do `"v" ++ show 1`?
16:31:13 <ezzieyguywuf> I've heard it bandied about that `show` isn't really meant to be used
16:31:16 <ezzieyguywuf> or something like that
16:31:22 <wavemode> what else would you do?
16:31:47 <ezzieyguywuf> I don't know, I guess that's what I'm asking
16:32:03 <dsal> ezzieyguywuf: I never use ++
16:32:31 <wavemode> I suppose the alternative is using a pretty printing library which uses Text instead
16:32:42 <c_wraith> there's  nothing wrong with what you've got
16:33:14 <ezzieyguywuf> what if I'm ultimately feeding it to Text.pack anyway?
16:33:19 <ezzieyguywuf> dsal: what do you use instead?
16:33:27 <c_wraith> don't worry about something else unless you have evidence it's a performance bottleneck
16:33:28 <dsal> <>
16:34:00 <dsal> ++ only works with lists.  <> works with any semigroup, including text
16:34:06 <ezzieyguywuf> I'm not really familiar with <>
16:34:12 <wavemode> :t (<>)
16:34:14 <lambdabot> Semigroup a => a -> a -> a
16:34:21 <dsal> :t fromString . show
16:34:22 <lambdabot> (IsString c, Show a) => a -> c
16:34:33 <ezzieyguywuf> hrm, very interesting
16:34:35 <dsal> ezzieyguywuf: ++ is a language wart
16:34:42 <dsal> Like return
16:34:51 <ezzieyguywuf> what's wrong with return?
16:34:58 * ezzieyguywuf he asks, not really wanting to know
16:35:02 <Rembane> :t (++)
16:35:03 <lambdabot> [a] -> [a] -> [a]
16:35:15 <dsal> return really confuses people and is superfluous
16:35:18 <ezzieyguywuf> <> is really neat!
16:36:11 <Rembane> return wasn't superfluous when it was introduced, which is one of the more interesting aspects of using a language that has been in development for a while. 
16:36:14 <dsal> Once you get used to OverloadedStrings, <> will magically just work
16:36:26 <wavemode> but for lists, ++ = <> . so If I know for a fact I'm working with lists, using ++ makes my code slightly more self-documenting
16:37:02 <Rembane> I think it's more a question about style than anything else.
16:37:07 <dsal> Yeah, I've heard similar arguments for map.  I use map still, but i still think it's a wart
16:38:01 <dsal> In this case, it's a string, and might someday be a text.  It'd be easy to make a better implementation with text by just changing the thing on the *right*
16:38:04 <safinaskar> consider this code: https://godbolt.org/z/KJLkeh
16:38:29 <safinaskar> it is ambiguous what type has constant "a"
16:38:47 <safinaskar> but ghc compiles it without any warnings (even with -Wall -Wextra)
16:38:57 <safinaskar> is there some way to enable warning here?
16:39:25 <dsal> https://usercontent.irccloud-cdn.com/file/iRpsiemY/that%27s+a+bit+hard+to+read%3A+.png
16:39:33 <Rembane> safinaskar: undefined does that kind of things, if you're concerned about those kind of things, you an udnerscore instead of undefined. 
16:40:27 <safinaskar> dsal: close 2nd and 3rd pane
16:40:45 <safinaskar> dsal: also don't use smartphone for serious programming stuff
16:41:01 <safinaskar> dsal: okey, i pasted here: http://paste.debian.net/hidden/a4d5654e/
16:41:12 <dsal> > let s = fromString . show in   "x" <> s 3
16:41:15 <lambdabot>  "x3"
16:41:19 <c_wraith> there's nothing wrong with an ambiguous type of it doesn't have a class constraint.
16:41:34 <c_wraith> *if it doesn't
16:44:56 <dsal> % let s = fromString . show in  ("x" <> s 3) :: Data.Text.Text -- ezzieyguywuf 
16:44:57 <yahb> dsal: "x3"
16:45:08 <dsal> % let s = fromString . show in  ("x" <> s 3) :: String
16:45:08 <yahb> dsal: "x3"
16:49:10 <dsal> % showverload = fromString . show
16:49:10 <yahb> dsal: 
16:49:34 <solonarv> nice variable name :)
16:49:50 <dsal> It's for ShowverloadedStrings
16:50:48 <dsal> Now I wish show just did that.  I keep making custom shows.  It never occurred to me to just make one that does it all.
16:51:06 <dsal> (I understand this is kind of abusive)
16:58:45 <dgpratt> Thinking "out loud" here, I'd be gratified if I could get VS Code "remote SSH" working with the ghcide extension/service all inside a nix shell environment. What if I made a "wrapper" shell script around the ghcide executable that would enter the shell environment if e.g. a shell.nix file was in the project dir? Anyone have an opinion on if that might work?
17:00:11 <dgpratt> I also wonder if something like that could work with emacs/TRAMP
17:11:49 <safinaskar> % const 1 undefined
17:11:49 <yahb> safinaskar: 1
17:11:54 <safinaskar> const 1 (read "o")
17:11:57 <safinaskar> % const 1 (read "o")
17:11:57 <yahb> safinaskar: ; <interactive>:30:10: error:; * Could not deduce (Read b0) arising from a use of `read'; from the context: Num a bound by the inferred type of it :: Num a => a at <interactive>:30:1-18; The type variable `b0' is ambiguous; These potential instances exist:; instance Read a => Read (ZipList a) -- Defined in `Control.Applicative'; instance Read a => Read (Complex a) --
17:12:05 <safinaskar> why first works and second doesn't?
17:12:28 <dsal> safinaskar: they both "work"
17:12:37 <dsal> But the second one doesn't compile because the type isn't clear.
17:12:57 <dsal> That it's not going to run the code isn't a reason for it to ignore the type safety.
17:12:58 <safinaskar> dsal: in first case type "undefined" is not clear, too
17:13:07 <dsal> Not exactly.
17:13:09 <dsal> :t undefined
17:13:10 <lambdabot> a
17:13:12 <dsal> :t read
17:13:13 <lambdabot> Read a => String -> a
17:13:59 <dsal> undefined can be any type, but the return value of read can only be a subset of types that meet the Read constraint.
17:14:00 <safinaskar> i mean final non-polymorphic type of "undefined" is ambiguous
17:14:55 <safinaskar> i absolutely understand why "read" example doesn't compile. i don't understand why "undefined" example compiles
17:16:03 <dsal> I guess I can see how that's confusing.  `undefined` is a bottom value that fits all possible holes.
17:18:51 <dsal> But consider the definition of const:
17:18:52 <dsal> :t const
17:18:54 <lambdabot> a -> b -> a
17:19:12 <dsal> It takes any b, doesn't care what it is, and moves on.  undefined satisfies that.
17:19:50 <Cale> safinaskar: It's because when you use read there, because the type of its result no longer appears in the type of the expression, the type class instance to use must be resolved.
17:20:18 <Cale> That's perhaps a little too approximate, but usually type checking doesn't rely in any way on dead code analysis
17:20:38 <safinaskar> thanks
17:20:39 <Cale> When it comes to undefined, there's no type class which constrains it
17:20:50 <Cale> If we had something like class Undefined a where undefined :: a
17:20:57 <safinaskar> Cale: there a way to force compiler to check that dead code?
17:20:57 <Cale> then you'd have the same issue
17:21:10 <Cale> You mean to not typecheck dead code?
17:21:24 <safinaskar> Cale: i. e. to force compiler to give error on that ambiguous "const 1 undefined" code?
17:21:32 <Cale> Oh, no
17:21:33 <dsal> Why is that ambiguous?
17:21:33 <safinaskar> Cale: or warning
17:21:39 <Cale> Also, it's not ambiguous
17:21:56 <Cale> Because polymorphic code which doesn't involve type classes doesn't *need* to choose a type
17:22:10 <Cale> It's compiled to the same thing regardless
17:22:40 <Cale> For example, the function map :: (a -> b) -> [a] -> [b] is a single compiled function, it doesn't get recompiled for each choice of a and b
17:22:50 <dsal> heh.  I was going to use map as an example.
17:22:55 <Cale> It's just that the function happens not to care at all about what the types a and b are
17:23:22 <dsal> > let x = map undefined [undefined, undefined] in ()
17:23:24 <lambdabot>  ()
17:23:28 <Cale> Since it's all pointers (to code) at runtime, you only have to compile a single thing, and it works on any sort of list.
17:24:21 <Cale> When it comes to type classes though, the implementations of things start to depend on the types which are selected
17:24:28 <Cale> and then you really have to decide somewhere
17:26:32 <dsal> > length [undefined, undefined]
17:26:33 <lambdabot>  2
17:28:47 <safinaskar> ok, thanks
17:28:49 <dsal> These examples are all equivalent to the const thing, I guess.  But if you look at length as turning a list of `a` into a number, and that `undefined` is an `a`, it makes sense.  The return value of `read` isn't known without more context.
17:28:49 <safinaskar> i understand
17:30:27 <safinaskar> does haskell has C++-style polymorphism? I mean is it possible to construct List with elements which satisfy some type class, but which has different types?
17:30:52 <dsal> No, not exactly.
17:31:52 <dsal> `[a]` only works for a type `a`
17:32:18 <solonarv> you can do something similar, but it's a big hassle and not actually very useful
17:32:45 <safinaskar> solonarv: how to do this? maybe some link?
17:32:52 <wavemode_> with existential quantification you can kind of achieve that. it's really not that useful though. you'd usually rather go a different method for what you're trying to achieve
17:33:02 <solonarv> I don't have a link handy, sorry
17:33:27 <solonarv> and anyway I want to stress that it is not very useful and pretty much never the right solution to your problem
17:33:52 <solonarv> like, say you want to have "a list of things that have a 'Show' instance"
17:34:12 <solonarv> this is useless, because the only thing you can do with an element of that list is applying 'show' to it to get a String
17:34:23 <solonarv> so you could just as well have a list of String in the first place!
17:36:01 <safinaskar> "you'd usually rather go a different method for what you're trying to achieve" - i am just curious
17:36:33 <safinaskar> i am trying to covert some c++-style code to haskell as closely as possible. just as exercise. i am curious what will happen
17:36:49 <solonarv> in this example the "different method" is just using [String]
17:36:49 <solonarv> ah
17:36:56 <dsal> The easy way is to create a wrapper sum type.
17:36:59 <solonarv> well, I still don't have a link handy, sorry
17:37:39 <wavemode_> safinaskar: well then here: https://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types
17:37:45 <wavemode_> you've been warned :p
17:37:58 <safinaskar> wavemode_: thanks
17:44:54 <Cale> safinaskar: Usually a better bet than trying to using existentials is just to come up with a record type that would correspond to the type of objects in your OO program
17:45:26 <Cale> safinaskar: Since Haskell has first class functions, you can define a type of records of functions, and every value of that type can implement the functions differently if it wans
17:45:28 <Cale> wants*
17:46:28 <Cale> and that's usually the clearest way to encode OO -- you get "encapsulation" by defining functions which build those records and which take some arguments, or define some things locally
17:47:00 <Cale> You don't get subtyping, but that was always a red herring for OO anyway
17:47:17 <safinaskar> ok, thanks
19:17:35 <RENNNN> Hi
19:17:54 <RENNNN> i'm trying to implement fmap for data NatF a = ZeroF | SuccF a
19:18:22 <RENNNN> but   doesn't compile instance Functor NatF where
19:18:22 <RENNNN>     fmap f ZeroF = ZeroF
19:18:22 <RENNNN>     fmap f (SuccF a) = SuccF $ fmap f a
19:18:37 <RENNNN> Occurs check: cannot construct the infinite type: b ~ f0 b
19:18:37 <RENNNN>       Expected type: NatF b
19:18:37 <RENNNN>         Actual type: NatF (f0 b)
19:19:27 <RENNNN> is this really the solution fmap f (SuccF a) = SuccF $ f a?
19:20:28 <MarcelineVQ> It has to be since SuccF isn't defined recursively.
19:21:13 <MarcelineVQ> or otherwise in a way it'd make sense to fmap the a
19:22:41 <MarcelineVQ> Note that your type is the same as Maybe
19:22:54 <MarcelineVQ> in case that's at all helpful
19:23:05 <RENNNN> MarcelineVQ, you're right
19:23:08 <RENNNN> thanks!
19:35:45 * hackage greskell-core 0.1.3.3 - Haskell binding for Gremlin graph query language - core data types and tools  https://hackage.haskell.org/package/greskell-core-0.1.3.3 (debugito)
19:37:45 * hackage greskell 1.1.0.1 - Haskell binding for Gremlin graph query language  https://hackage.haskell.org/package/greskell-1.1.0.1 (debugito)
19:39:45 * hackage greskell-websocket 0.1.2.3 - Haskell client for Gremlin Server using WebSocket serializer  https://hackage.haskell.org/package/greskell-websocket-0.1.2.3 (debugito)
20:22:41 <dsal> I want takeWhile, but also give me the next thing if there is one.
20:23:56 <johnw> something like.... takeWhileAndOne p xs = let ys = takeWhile p xs in ys ++ maybeToList (maybeHead (drop (length ys) xs))?
20:24:10 <johnw> this is the sort of thing that's way more efficient to write as a plain recursive function
20:28:59 <dsal> Yeah, I just did the recursive thing.
20:29:13 <dsal> Just like... why isn't the exact thing I want already sitting there?
20:31:01 <fog> https://gist.github.com/fog-hs/66e5139aa18884cb8393be028995fa6b
20:31:25 <fog> states of states as states with tapes
20:50:47 <johnw> dsal: because most people don't need it?
20:50:55 <johnw> there are a lot of thinsg that can be imagined that aren't in the stdlib
20:51:26 <dsal> I understand.  But it's still surprising sometimes.  I'm sure there's an npm-esque library out there with that function in it.
20:53:51 <johnw> takeWhileAndOne p = (\(xs, ys) -> xs ++ case ys of [] -> []; y:_ -> [y]) . break p
20:54:11 <johnw> still not as efficient as it could be
20:54:43 <dsal> It doesn't need to be efficient, but I did this:  https://github.com/dustin/mqttd/blob/master/test/Spec.hs#L129-L131
20:55:25 <wavemode_> in Data.List.HT (from the package utility-ht): takeUntil ("Take all elements until one matches. The matching element is returned,
20:55:25 <wavemode_>  too")
20:55:32 <wavemode_> so you would invert the predicate
20:55:43 <dsal> Given an arbitrary mqtt topic, I'm generating an arbitrary pattern match for it.  The match can use + for a segment wildcard, or it can use # for a segment-and-children wildcard, but nothing can come after the wildcard.
20:56:00 <dsal> I think I've seen that one... or one like it.
20:56:35 <johnw> so you just want a break that breaks after, not before
20:56:48 <dsal> Right.
20:57:03 <johnw> that function exists here: https://hackage.haskell.org/package/utility-ht-0.0.15/docs/Data-List-HT.html
20:57:08 <johnw> breakAfter
20:57:52 <dsal> Hmm...  This is the third extra-list thing I've seen.
20:58:00 <johnw> give it time
20:58:12 <johnw> preludes and extra-list/monad libraries are legion
20:58:51 <wavemode_> someone defined takeWhileInclusive in Data.Avro.Internal.Container (from the package avro). so if you feel like importing someone's internal module :D
21:00:22 <slack1256> Does lazyness help to have equational reasoning or is it just a consequence of purity?
21:01:09 <MarcelineVQ> it being equational reasoning?
21:01:31 <wavemode_> um haskell was a research project to create a lazy functional language. laziness wasn't a necessity, it was a design goal
21:01:56 <wavemode_> other pure functional languages are not lazy, for the most part
21:03:00 <slack1256> MarcelineVQ: Yep.
21:03:52 <slack1256> MarcelineVQ: https://stackoverflow.com/questions/265392/why-is-lazy-evaluation-useful check out the part where it's called "poor man's equational reasoning"
21:05:11 <tt> hi 
21:06:49 <tt> im just trying to go through the examples on setting up a db here. But I seem to get errors. 
21:06:51 <tt> <no location info>: error:    Could not find module â€˜Database.HDBC.Sqlite3â€™    Perhaps you meant Database.HDBC.SqlValue (from HDBC-2.4.0.3)
21:08:07 <tt> http://book.realworldhaskell.org/read/using-databases.html
21:08:21 <johnw> slack1256: math has equational reasoning; laziness is how Haskell's call-by-need evaluation model is implemented
21:09:53 <wavemode_> tt: do note that Real World Haskell is rather old. it's possible the library has changed
21:10:37 <tt> wavemode_ Im trying to setup a simple sql db and connection. Is there a more up-to-date tutorial you'd recommend? 
21:10:50 <slack1256> johnw: But more equalities hold on a non-strict setting right? We can float out binding for example and still have the same semantic expression
21:11:24 <slack1256> My question is that if such abilities provided by the "laziness" are essential to equational reasoning or they are superflous once you have a pure language.
21:18:06 <wavemode_> tt: I don't know of a tutorial but you could look into this, it has a usage example: https://hackage.haskell.org/package/sqlite-simple
21:18:40 <tt> wavemode_ naise. looks simple and approachable. cheers
21:19:34 <johnw> slack1256: laziness is a bigger universe, certainly
21:19:48 <johnw> or rather, a non-strict domain where all types are inhabited by bottom
21:20:14 <slack1256> tt: Also, Real world haskell is a good book, but the code examples and libraries have changed since it was published. It's better to go to the hackage docs directly to see how to import things.
21:21:00 <johnw> there are articles out there documenting some of these subtleties: for example, the one showing that Haskell's list data structure is not precisely the same as the free monoid, exactly because of this difference
21:22:47 <slack1256> Yeah, there is an article by tekmo that shows that.
21:23:03 <steven_> johnw: just curious when you say the free monoid, does that mean there's only one?
21:23:25 <johnw> by definition, yes
21:23:30 <slack1256> yeah
21:23:35 <johnw> anything else must be isomorphic to it, up to unique isomorphism
21:23:45 <steven_> ohh gotcha
21:25:11 <steven_> slack1256: do you think you could link the article? I tried googling tekmo free monoid and it didn't seem to come up
21:25:31 <johnw> http://comonad.com/reader/2015/free-monoids-in-haskell/
21:27:33 <steven_> thanks
21:42:44 <tt> I was thinking `stack install` will function similar to `npm install` where the packages installed autoamitcally go into your local packages. But apparently, you have to include the package under `packages` of your stack.yml. 
21:43:43 <tt> Is there a way to just do `stack install` where stack will update my local packages (`.stack-work`) and the `stack.yml` file automatically?
22:01:15 * hackage pontarius-xmpp 0.5.6.3 - An XMPP client library  https://hackage.haskell.org/package/pontarius-xmpp-0.5.6.3 (SergeyAlirzaev)
22:05:14 * hackage pontarius-xmpp-extras 0.1.0.2 - XEPs implementation on top of pontarius-xmpp  https://hackage.haskell.org/package/pontarius-xmpp-extras-0.1.0.2 (SergeyAlirzaev)
22:49:45 * hackage pontarius-xmpp-extras 0.1.0.3 - XEPs implementation on top of pontarius-xmpp  https://hackage.haskell.org/package/pontarius-xmpp-extras-0.1.0.3 (SergeyAlirzaev)
22:53:14 * hackage hsendxmpp 0.1.2.1 - sendxmpp clone, sending XMPP messages via CLI  https://hackage.haskell.org/package/hsendxmpp-0.1.2.1 (SergeyAlirzaev)
23:22:08 <ruoyomo> IDIOTS
23:26:05 <EvanR> AVANTS
