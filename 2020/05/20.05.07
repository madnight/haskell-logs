00:16:33 <jthvai> hlint just politely informed me that i should use `zipWith (curry f) xs ys` instead of `map f (zip xs ys)` - what is the benefit of the first option over the second?
00:18:40 <phadej> single traversal
00:19:14 <jthvai> Ooohhhh thank you
00:19:21 <pong> hold the phone
00:19:36 <pong> lazy evaluation is a thing
00:20:04 <jthvai> so "conceptual" single traversal then?
00:20:15 <phadej> `zipWith f xs ys` is still better than `map (uncurry f) (zip xs ys)`
00:20:54 <pong> but yeah you're zipping with something
00:21:02 <pong> first is more expressive that's about it
00:21:09 <phadej> for the same reason `fromMaybe def x` is better than `maybe x id x
00:21:24 <phadej> tells an intention more clearly
00:21:36 <phadej> `maybe def id x`*
00:22:39 <jthvai> that makes sense
00:27:27 <suppi> Is it lazy evaluation that makes this single traversal or rewrite rules?
00:28:25 <MarcelineVQ> if anything the latter afaik. lazyness doesn't prevent two traversals there, it just means we don't build the the intermediate list all at once
00:29:11 <suppi> yeah that's what i thought. thanks!
00:29:52 <Welkin> hi suppi
00:30:02 <suppi> So yeah - single traversal is still a good reason to prefer zipWith
00:30:03 <Welkin> are you still a koala?
00:30:06 <suppi> Hi Welkin
00:30:09 <suppi> yep
00:31:43 <suppi> oh I wrote you something on a different channel and didn't notice you weren't online, I'll repost
00:39:37 * Welkin waves to Lycurgus 
00:42:22 * Lycurgus pm'ed Welkin
01:29:19 * hackage yaml 0.11.4.0 - Support for parsing and rendering YAML documents.  https://hackage.haskell.org/package/yaml-0.11.4.0 (MichaelSnoyman)
01:35:50 * hackage zsdd 0.2.1.0 - Zero-Suppressed and Reduced Decision Diagrams  https://hackage.haskell.org/package/zsdd-0.2.1.0 (eddiejones)
01:36:49 * hackage pantry 0.5.0.0 - Content addressable Haskell package management  https://hackage.haskell.org/package/pantry-0.5.0.0 (MichaelSnoyman)
01:51:19 * hackage sqlcli 0.2.2.0 - Bindings for SQL/CLI (ODBC) C API.  https://hackage.haskell.org/package/sqlcli-0.2.2.0 (mihaigiurgeanu)
01:53:52 <absence> is it possible to combine NamedFieldPuns and ViewPatterns? my first attempt isn't working: https://repl.it/repls/RichInsecureQuadrilateral
01:54:40 <merijn> absence: Maybe it, but if it is you really shouldn't >.>
01:55:22 <merijn> Because no one on earth will know how to read it :p
01:59:10 <absence> merijn: that may be true, but since we don't even know how to write it, it's hard to say how it reads ;)
02:00:27 <merijn> absence: Generally I'd just rebind the name in a where block
02:01:03 <gentauro> why is this not working :| -> `(many get `sepBy` string ".|.") "4.|.2.|.8.|.5" -- Expected result: ["4","2","8","5"]`?
02:01:33 <merijn> What does "get" do?
02:02:30 <gentauro> if I do -> `(many get <* string ".|.") "4.|.2.|.8.|.5" -- Result: ["4",".2.|.8.|.5"]` I get up to the first result
02:02:33 <gentauro> :S
02:02:46 <gentauro> merijn: `get` just reads a `char`
02:03:15 <gentauro> if I look into `sepBy` -> https://hackage.haskell.org/package/base-4.14.0.0/docs/src/Text.ParserCombinators.ReadP.html#sepBy1
02:03:21 <merijn> gentauro: Eh, "many get" reads your entire string
02:03:44 <absence> merijn: i know how to work around it, i just don't like the readability of having both someVariable and someVariable' or someVariable0 or whatever
02:03:48 <gentauro> merijn: I'm seeing that
02:03:59 <gentauro> but why doesn't it stop with my `separator`?
02:04:05 <merijn> gentauro: Why would it?
02:04:16 <gentauro> the `<*` operator seems to be able to stop the `many get`
02:04:24 <merijn> gentauro: If get parses a character, then "many get" will read, well, many characters
02:04:37 <jchia> gentauro string matches as far as it can
02:04:38 <gentauro> merijn: I understand that
02:05:08 <jchia> i mean get
02:05:11 <gentauro> merijn: so if `many get` reads the entire stream, how is this possible -> `(many get <* string ".|.") "4.|.2.|.8.|.5" -- Result: ["4",".2.|.8.|.5"]`
02:05:14 <gentauro> ?
02:05:19 <merijn> tbh, I think you just want 'sepBy get (string ".|.")'
02:06:08 <merijn> gentauro: ReadP produces *all* possible parses and you probably shouldn't use it for writing parsers if you wanna stay sane :p
02:06:21 <jchia> gentauro: Do you really want get to match all possible strings? or just all possible strings that don't contain '.' or '|'?
02:06:51 <gentauro> jchia: my `sep` pattern is a `string`, not a `char`
02:07:17 <gentauro> my expected result is: `["4","2","8","5"]`
02:07:26 <jchia> I know, but is "a.|.b" supposed to be parsed as "a.|.b" or ["a", "b"]?
02:07:27 <gentauro> a `[String]`
02:07:39 <gentauro> jchia: the last one
02:07:55 <jchia> why not the first one?
02:08:10 <jchia> cause you didn't say those two characters are not supposed to match the 'get'
02:08:12 <gentauro> jchia: cos my separator is `".|."`
02:08:22 <jchia> but you didn't say those two characters are disallowed
02:08:38 <gentauro> jchia: I understand that
02:08:57 <jchia> so won't 'get' also match the entire "a.|.b"?
02:09:00 <gentauro> I also didn't tell that for `(many get <* string ".|.")` and it seems to work
02:09:07 <gentauro> (at least for the first ocurrence)
02:09:37 <gentauro> what I would like to have is a `recurrent` version of this `(many get <* string ".|.")` so I can get my expected result -> `["4",".2.|.8.|.5"]`
02:09:40 <gentauro> :)
02:10:20 <gentauro> ups, expected result -> `["4","2","8","5"]`
02:10:21 <gentauro> :)
02:10:40 <jchia> gentauro: OK, I see your point. ReadP-related parsing is more complicated than regular parsing like megaparsec.
02:10:52 <jchia> So, I don't really know how to reason properly about it.
02:11:11 <jchia> like what merijn said, I suppose
02:11:16 <gentauro> jchia: good to hear that I'm not the only one "going Dalí"
02:12:09 <jchia> I don't really know the actual use case for the full complexity of read, though. If I want to parse something, I just use a regular parser.
02:12:23 <__monty__> > last <$> readP_to_S (sepBy get (string ".|.")) "4.|.2.|.8.|.5"
02:12:26 <lambdabot>  error:
02:12:26 <lambdabot>      Variable not in scope: readP_to_S :: [[()]] -> [Char] -> f [b]error:
02:12:26 <lambdabot>      • Variable not in scope: string :: [Char] -> [()]
02:18:19 * hackage earcut 0.1.0.0 - Binding to C++ earcut library.  https://hackage.haskell.org/package/earcut-0.1.0.0 (DavidHimmelstrup)
02:20:05 <gentauro> `filter (\x -> x == (["14","12","18","15"],"")) $ readP_to_S (sepBy (many get) (string ".|.")) "14.|.12.|.18.|.15"` -> [(["14","12","18","15"],"")]
02:20:08 <gentauro> :|
02:27:26 <__monty__> last $ readP_to_S (sepBy (munch (/= '.')) (string ".|.")) "14.|.12.|.18.|.15" ?
02:27:45 <__monty__> > import Text.ParserCombinators.ReadP
02:27:47 <lambdabot>  <hint>:1:1: error: parse error on input ‘import’
02:36:30 <[exa]> gentauro: this is really a case for Data.List.String.splitOn :]
02:36:52 <[exa]> gentauro: ie. what shold happen with "4.5.|.6.7" ?
02:37:34 <[exa]> ^^s/String/Split/ sorry
02:40:37 <gentauro> [exa]: that's how I been doing it until now, but i wanted to re-write it as a `parser combinator` ;)
02:43:36 <[exa]> gentauro: matching stuff like "x not followed by y" is problematic, you will effectively need a parser that accepts a string that ends either before .|. (thus reading the whole .|. to verify that it's indeed the separator!) or at eof
02:48:11 <gentauro> [exa]: I'm guessing that `(many get) <* string ".|.")` should be the way to go. The problem is I don't know how to make it recursive ... 
02:48:43 <__monty__> gentauro: That doesn't capture the last element though?
02:48:56 <merijn> gentauro: You really don't want to use ReadP from base as parser combinator, though :p
02:49:15 <__monty__> I like using it as a brainteaser.
02:50:09 <gentauro> __monty__: no? Isn't the `many` taking care of that?
02:51:02 <gentauro> otherwise I could probably just do for the case exiting the recursion `<*> many get`. That should take care of that :)
02:52:30 <gentauro> so I think I nailed it down to -> `… <$> ((many get) <* string ".|.") {- Needs recursion -}) <*> many get`
02:52:49 <gentauro> s/Needs recursion/Needs to be recurrent/
03:05:11 <__monty__> gentauro: I can't think of a way to do it without lookahead: last $ readP_to_S (sepBy (many (look >>= \peek -> if ".|." == take 3 peek then pfail else get)) (string ".|.")) "14.|.1.2.|.18.|.1.5"
03:07:39 <MarcelineVQ> man, how do you even use ReadP... the 'correct' parse of    readP_to_S (many (many get <* string ".|.")) "adc.|.bdfs.|.dfsdf.|.ed.|.d"   is in the middle of the results list.
03:09:14 <siraben> How do I compile a C file that uses the Haskell RTS with GHC?
03:10:41 <typetetris> Can I get persistent to allow me to use my newtype wrappers in the database schema dsl, so I don't have to do the wrapping and unwrapping from and to e.g. Text in the queries?
03:11:25 <merijn> typetetris: Yes
03:11:48 <merijn> typetetris: https://github.com/merijn/Belewitte/blob/master/benchmark-analysis/src/Types.hs
03:12:22 <typetetris> merijn: Thank you!
03:19:20 <davve> holy
03:19:42 <mniip> just matrix things
03:25:26 <siraben> Today I learned round is faster than floor
03:25:38 <gentauro> MarcelineVQ: tell me about it ...
03:25:41 <siraben> My rendering went from 110 ms/frame to 72 ms/frame
03:25:57 <gentauro> next person who tells me that `parser combinators` are `trivial to use` ... 
03:26:30 <merijn> gentauro: Literally no one refers to ReadP when they say that
03:26:49 <merijn> They mean "one of the parsecs"
03:27:17 <merijn> I already said "don't use ReadP" about an hour or ago :)
03:27:37 <merijn> ReadP is like the "esoteric language" version of parser combinators
03:28:41 <Cale> merijn: Of course, you know gentauro will be back about 3 days from now asking tricky questions about parsers that are giving up mysteriously and the solution will be to place a try somewhere deep within them
03:29:03 <Cale> (That's one thing that ReadP does have over Parsec)
03:29:06 <gentauro> merijn: -> http://book.realworldhaskell.org/read/using-parsec.html
03:29:16 <gentauro> `import Text.ParserCombinators.Parsec` :|
03:29:22 <c_wraith> I still like Earley, though the number of grammars that don't include something far easier to model with a monadic bind makes it limited.
03:29:44 <siraben> Wow, using truncate I render at 65 ms/frame
03:29:53 <merijn> gentauro: Honestly, for new code I would say use "megaparsec" over parsec
03:29:55 <siraben> floor is slower than ceiling is slower than truncate
03:29:56 <gentauro> :o, it's not `ReadP` :o
03:30:06 <siraben> Any other suggestions?
03:30:19 <merijn> https://markkarpov.com/tutorial/megaparsec.html
03:38:36 <gentauro> merijn: what i miss sometimes in these `parse tutorials` is that instead of writing `mySequence = (,,) <$> … <*> …` they showed something like this: `foo = (\ x y xs -> x:x:xs) <$> … <*> …` I think it would give newcomers more understanding what it's happening and also what they can do with `Applicative` values :)
03:39:13 <gentauro> `foo = (\ x y xs -> x:x:xs) <$> … <*> …` -> `foo = (\ x y xs -> x:y:xs) <$> … <*> … <*> …`
03:53:48 <siraben> Looks like truncate is much faster because it's inlined and has barely any logic to it
03:53:52 <siraben> https://hackage.haskell.org/package/base-4.14.0.0/docs/src/GHC.Real.html#truncate
03:54:00 <siraben> truncate x =  m  where (m,_) = properFraction x
03:56:48 <c_wraith> floor, truncate, and round should all have alternate implementations specified in RULES pragmas when doing Double -> Int or Float -> Int
03:59:16 <[exa]> gentauro: the problem is that `many get` won't ever terminate
04:08:04 <gentauro> [exa]: it does, but it's to difficult to retrieve the corret result from the many provided by parser :|
04:23:11 <Plazma> how come school of haskell is read-only since March?
05:06:57 <timCF> Hi guys! I have a super difficult question for you. Which Haskell prelude is the best? I want to use prelude which: encourages safety (no legacy unsafe partial functions)encourages modern Haskellis popularis supported well
05:07:24 <merijn> timCF: Prelude
05:07:29 <phadej> timCF: Prelude
05:07:52 <timCF> why Prelude?
05:08:05 <timCF> it has partial functions
05:08:11 <phadej> but more seriously: my own.
05:08:28 <phadej> everyone else seems to make at least one or two wrong choices
05:08:45 <merijn> timCF: Because everything else incurs a whole bunch of dependencies and/or is incompatible with other Prelude's and it's just not worth it
05:17:16 <raichoo> Also: Prelude.
05:21:19 * hackage replace-attoparsec 1.4.0.0 - Find, replace, and split string patterns with Attoparsec parsers (instead of regex)  https://hackage.haskell.org/package/replace-attoparsec-1.4.0.0 (JamesBrock)
05:22:19 * hackage replace-megaparsec 1.4.0.0 - Find, replace, and split string patterns with Megaparsec parsers (instead of regex)  https://hackage.haskell.org/package/replace-megaparsec-1.4.0.0 (JamesBrock)
05:25:49 * hackage vulkan 3.3 - Bindings to the Vulkan graphics API.  https://hackage.haskell.org/package/vulkan-3.3 (jophish)
05:26:49 * hackage VulkanMemoryAllocator 0.3 - Bindings to the VulkanMemoryAllocator library  https://hackage.haskell.org/package/VulkanMemoryAllocator-0.3 (jophish)
05:37:22 <olavx200> I remember reading there was a term for the smallest set of functions needed to make a type an instance of a typeclass. Can anyone tell me what that word is?
05:39:20 <phadej> MINIMAL definition?
05:40:30 <olavx200> Thanks
05:58:49 * hackage servant-docs-simple 0.2.0.0 - Generate endpoints overview for Servant API  https://hackage.haskell.org/package/servant-docs-simple-0.2.0.0 (HolmuskTechTeam)
06:11:08 <srid> timCF: There is a comparison of preludes here: https://guide.aelve.com/haskell/alternative-preludes-zr69k1hc
06:11:51 <merijn> Honestly, just define a small custom "prelude" for your package as you need it
06:14:40 <phadej> an example, https://hackage.haskell.org/package/github-0.25/docs/GitHub-Internal-Prelude.html
06:15:29 <phadej> it's not so small, but reduced repetiion by a lot
06:16:24 <merijn> phadej: small as in "just what you need for the package" :p
06:17:05 <merijn> I have a frankly massive "Schema" module reexporting several 10s of modules, types, etc. too
06:27:57 <maerwald> I find all the preludes striving for "totality" nonsense, but ymmv.
06:28:13 <merijn> that too
06:28:24 <maerwald> First: they are not total at all, second: functions like "head"... cmon. Everyone knows it's inherently partial.
06:28:59 <maerwald> It's usually much more difficult to make your program not crash due to IO exceptions
06:29:34 <maerwald> and for the few cases where head etc are not enough: I use the 'safe' package and NonEmpty
06:29:40 <maerwald> Don't need an entire prelude for that
06:32:29 <maerwald> And none of those alternative preludes have sensible file/directory IO modules :)
06:32:50 <merijn> maerwald: Everyone wants to to the easy fixes, not the hard ones :p
06:33:26 <maerwald> yeah, since someone 10 years ago wrote in a blog post how "head" is a mistakge, people have been "fixing" it ever since
06:34:51 <Cale> It's kind of a mistake, but not a big enough deal that I'd switch to a nonstandard Prelude
06:35:19 <maerwald> especially since the fix is as trivial as "import Safe"
06:35:36 <maralorn> phadej: I am not sure if you read my last question (or if I didn‘t notice an answer). cabal-fmt 0.1.2 is broken on nixpkgs but I believe cabal-fmt 0.1.3 (which already exists on github) would work. Can you consider releasing 0.1.3 to hackage?
06:36:22 <Cale> For partial functions like head, writing something like (\(x:xs) -> x) is generally better because when that fails you get an error message which tells you where the problem is
06:36:28 <absence> if i want to parse a ByteString to Double, what's the easiest "good" way? converting to String and using readMaybe feels a bit kludgy, and pulling in something like parsec feels overkill when i don't have anything else to parse
06:36:38 <Cale> and it's only a few characters longer
06:36:53 <maerwald> a good nonstandard Prelude would have to take the off the burden of newcomers to choose how to do certain things: effects, streaming, IO, exceptions etc.
06:37:29 <srid> Cale: since you are here, I'm curious: have you looked at polysemy? What do you think?
06:37:31 <merijn> maerwald: You mean "import Data.Maybe (listToMaybe)" :p
06:37:39 <merijn> maerwald: Don't even need a new dependency!
06:38:03 <srid> Cale: I battled with mtl, before giving up and switching polysemy (for an obelisk backend); it was surprisingly easy and smooth.
06:38:16 <merijn> absence: As text or just like "an 8 byte IEEE-754 double"?
06:38:30 <maerwald> merijn: that's such a terribly mis-named function though
06:38:38 <merijn> maerwald: Why?
06:38:49 <merijn> :t listToMaybe
06:38:50 <lambdabot> [a] -> Maybe a
06:38:53 <maerwald> because you can't really tell what it does without reading the documentation
06:39:05 <maerwald> it could as well pick the last element
06:39:08 <maerwald> or the center
06:40:11 <maerwald> I'm waiting for a new prelude going full polysemy
06:40:21 <Cale> srid: I haven't been all that impressed with any of the recent effects systems in Haskell. What particular battle did you have with mtl?
06:41:22 <Cale> srid: I tend to think of MonadReader/MonadState/etc. as things which aren't meant to be used directly, and instead are just conveniences for defining your own class of operations (if it's a class at all -- applications often don't need the polymorphism)
06:41:33 <srid> Cale: "battle" mostly because I have not been very proficient with defining them. Was trying to do the three-layer-haskell-cake thing in a new obelisk app backend: https://funprog.srid.ca/haskell/why-not-monaddatabase.html
06:41:39 <absence> merijn: good point, it's ascii
06:42:05 <srid> Polysemy effects, on the other hands, were very easy to define and use. And very simple to understand and reason about.
06:43:00 <Cale> "Easy to reason about" wouldn't have been my first thought about polysemy
06:43:06 <Exarmatio> hello, maybe slightly silly question: I'm trying to write a utility function that uses TypeFamilies and ScopedTypeVariables and the type ends up being ambiguous and I can't tell why
06:43:13 <Exarmatio> error and code is too big, snippet here: https://gitlab.com/snippets/1974578
06:43:25 <maerwald> Cale: at the surface, it is
06:43:44 <maerwald> but I'm not sure that'll get you far for larger applications
06:44:03 <Exarmatio> the error says something about the type family not being injective, but I'm not sure if that's the actual reason for the ambiguity?
06:44:08 <maerwald> especially when the maintainer gave up on fixing certain semantic bugs
06:44:41 <srid> Easy to reason about, because I think - it is just a type-level list of effects (which are themselves GADTs), that you wrap/unwrap.
06:46:15 <Cale> But what does that mean?
06:46:34 <srid> In any case, I was able to add polysemy as a dep, and actually use it in my application in a surprisingly small amount of time. The resulting code was understadable. 
06:46:38 <Cale> It's easy to understand how some monad transformers are implemented in terms of functions.
06:47:05 <Cale> and thus to understand how they're going to interact with one another when you nest them
06:47:32 <maerwald> not sure I agree with the latter
06:47:34 <srid> With the traditional approach, on the other hand, I had trouble understanding how to solve certain issues. See this: https://funprog.srid.ca/haskell/why-not-monaddatabase.html#196690912
06:47:35 <Cale> What all the type-level machinery does with your list of promoted GADTs or whatever it is, that's a little less clear to me
06:47:53 <Cale> maerwald: Well, perhaps not *easy*, but let's say *possible*
06:48:04 <maerwald> it's very non-abstract reasoning
06:48:08 <Poscat[m]> the GADT just describes your effect
06:48:43 <Poscat[m]> if you don't need custom effects then you can just ignore those
06:48:50 <maralorn> What I am really curious about is the matter of commutativity of effects. In most systems they are clearly not, but there was this other contender in a recent ghc-proposal which claimed to have commutative effects. If you can pull that of without losing expressiveness it would simplify reasoning a lot.
06:49:18 <Poscat[m]> it's quite easy to translate mtl to polysemy, for exampleT
06:49:22 <Poscat[m]> example*
06:49:34 <Cale> maralorn: Wishing for effects to commute with each other is like wishing there were fewer colours because it would be easier to paint
06:49:48 <maerwald> lol
06:50:02 <Cale> There are *useful* distinctions between those noncommuting pairs
06:50:39 <maralorn> Cale: Yeah, I‘d expect that. I hadn‘t really looked into that claim.
06:50:49 <maralorn> But of course the prime example is error handling.
06:50:56 <Poscat[m]> the constraint `(MonadState s m, MonadError e m)  => m a` translate directly into `Members '[State s, Error e] r => Sem r a`
06:51:29 <Cale> Poscat[m]: But is that going to because like an ErrorT over State or like a StateT over an Error monad?
06:51:34 <Cale> behave*
06:52:20 <maralorn> https://github.com/hasura/eff says:
06:52:34 <maralorn> Other approaches to scoped operations (including those taken in mtl, fused-effects, and polysemy) have behavior that changes depending on handler order, and some combinations can lead to nonsensical results. eff’s semantics is consistent regardless of handler order, and scoped operations compose in predictable ways.
06:53:13 <maralorn> I don‘t know if it succeeds with that claim but it sounds interesting.
06:53:14 <Cale> "Consistent regardless of handler order" = "Fewer things are expressible"
06:53:52 <Poscat[m]> Cale: the monad transfermer stack (carrier) is constructed when you run the effects
06:54:13 <Exarmatio> oh wait
06:54:44 <Exarmatio> regarding my earlier question - is it just complaining about ambiguity because the fname doesn't appear in the (value) arguments?
06:55:12 <Poscat[m]> You really don't need to care about how those effects are gonna get interpreted when constructing your program.
06:55:20 <Cale> Poscat[m]: Yeah, I recall that's the idea, but there were weird issues having to do with what happens when it starts commuting the effects around in those type level lists such that you *could* run the handlers in different orders.
06:56:04 <Cale> But maybe my impression of the situation isn't quite right, I haven't really used polysemy, just observed some of isovector's struggling with it.
06:56:22 <phadej> maralorn: I'm a way from my primary machine, will go through OSS stuff once I'm back
06:57:50 <Cale> Exarmatio: haha, that error message
06:58:06 <maralorn> phadej: Thank you, no hurries.
06:58:26 <Cale> Exarmatio: The problem is that knowing (FieldType fname a) wouldn't help you determine fname
06:58:54 <Cale> Exarmatio: because FieldType is a type family, and might send multiple choices of fname to the same type(s)
06:59:15 <yushyin> maralorn: it remains to be seen, if lexi-lambda's ghc-proposal will be accepted and i would like to give eff at least a chance to try it out
06:59:23 <Cale> and of course, fname is something that needs to be determined in order to know which instance of HasField fname a to use
07:01:01 <Cale> The thing which would get me excited re: effect systems is if someone could come up with a thing that compiles to better code than monad transformers do, with all the usual GHC optimisations turned on
07:01:41 <Exarmatio> Cale: Thanks, that makes sense, so this isn't a problem here because this funciton is meant to be used with TypeApplications to resolve the ambiguity
07:02:15 <maralorn> yushyin: Well, I am actually not that interested in implementations or performance but more what the different possible semantics are.
07:02:57 <Cale> Exarmatio: Yeah, if you're intending to use TypeApplications to resolve it, you can just add {-# LANGUAGE AllowAmbiguousTypes #-} and not worry too much. In the future once it's supported, you'll probably want to switch that to be  forall (fname :: Symbol) -> ...
07:03:08 <Cale> (i.e. with an arrow rather than a dot)
07:03:56 <Exarmatio> does that indicate a mandatory (explicit? not sure what the right name is) type argument?
07:03:58 <Cale> Which will make the Symbol into an explicit argument, rather than one which needs an @ to provide
07:04:00 <Cale> yeah
07:04:43 <Exarmatio> hm, without @? Wouldn't that be a bit weird because types and value bindings have different namespaces?
07:05:08 <Cale> Yeah, they're going to have to sort that all out
07:05:42 <Cale> I think Richard has some sort of plan for it though
07:07:48 <Cale> srid: If it's any consolation, I agree about MonadBaseControl being a terrible idea -- in fact, all similar libraries, like the UnliftIO thing and such, are also problematic, becuase they try to abstract over a bunch of things which don't really behave the same way.
07:07:49 * hackage replace-megaparsec 1.4.1.0 - Find, replace, and split string patterns with Megaparsec parsers (instead of regex)  https://hackage.haskell.org/package/replace-megaparsec-1.4.1.0 (JamesBrock)
07:08:55 <Cale> It's easier to make sure you're doing things right if you just invent a type class for the operation you want to use, and then implement instances for the monads you need it on (or the transformers you used to build up your monad)
07:09:43 <Cale> It seems like slightly more work in the short term, but it'll give you a chance to think through a bunch of interactions and make sure what you're attempting makes sense.
07:11:17 <Cale> The whole "Has" pattern is another kind of weird thing, but at least it's closer to being the right thing than using MonadReader directly.
07:12:27 <Cale> Make classes that reflect the operations you want, not necessarily the values in the environment.
07:14:37 <Exarmatio> also I really appreciate that GHC has support for user defined type errors, but the problem is that they make all non-user defined type errors they are involved them much harder to read
07:14:39 <maerwald> heave HasFoo code is utterly confusing and hard to follow
07:14:48 <maerwald> I've worked with such code, I did not like it
07:16:05 <Cale> It can be fine to make a HasFoo class if what you're really concerned with is getting a value of type Foo from somewhere (config?), but usually there's something a little more domain specific which is the reason you wanted that value in the first place, so making a class for the operations which were going to need Foo might be better
07:16:49 <Cale> e.g. instead of making a HasDBConnection class for grabbing the database connection from a ReaderT, make a class that has operations for querying the database
07:17:37 <Cale> You can still provide a method that hands the user the connection, and provide default implementations in terms of it if you like, but it'll just be clearer what the class is for that way.
07:21:49 * hackage cobot-io 0.1.3.3 - Biological data file formats and IO  https://hackage.haskell.org/package/cobot-io-0.1.3.3 (ozzzzz)
07:27:11 <Unhammer> very confusing when hlint says I have a redundant bracket at the line `bracket (startProcess cmd) (stopProcess) $ …`
07:28:21 <Rembane> Unhammer: hlint isn't always right. 
07:28:22 <Unhammer> (guess that says something about how high expectations I have of hlint's suggestions =P)
07:28:39 <Rembane> Unhammer: Is it quiet if you replace $ with brackets? 
07:28:49 <Unhammer> rembane, in this case it was – but I misunderstood it as referring to the function call "bracket", not the ()'s
07:29:11 <Rembane> Unhammer: Oh. That's funny, it took me way too long time to understand that joke. :)
07:29:45 <Unhammer> :) 
07:31:08 <phadej> in (stopProcess) can bejust stopProcess
07:54:20 * hackage postgresql-syntax 0.2 - PostgreSQL AST parsing and rendering  https://hackage.haskell.org/package/postgresql-syntax-0.2 (NikitaVolkov)
08:05:19 * hackage within 0.0.2.0 - A path within another path.  https://hackage.haskell.org/package/within-0.0.2.0 (locallycompact)
08:22:44 <win2ero> Good mornig i am new to haskell. could some one explainme what is the difrence between int and In Integer
08:23:09 <win2ero> i was trying to sum all the number
08:23:12 <win2ero> sumatoria ::  int -> int
08:23:50 <win2ero> but when i run it say's no instance for (Eq int)
08:24:09 <win2ero> and when i replace paramater for Integral it work
08:24:12 <olavx200> data Digit = Ace | Two | Three | Four | Five | Six | Seven | Eight | Nine | Ten | Jack | Queen | King deriving (Ord)
08:24:12 <olavx200> Why is this line invalid?
08:24:48 <olavx200> Int is a normal bounded int
08:24:49 <Franciman> deriving, I think
08:24:52 <olavx200> Integer is unbounded
08:24:56 <Franciman> oh
08:26:55 <win2ero> What do you mean by unbounded.
08:27:23 <olavx200> It has no (theoretical) limit to how big it can be.
08:27:28 <olavx200> Like a bigint.
08:28:48 <olavx200> This might help you http://learnyouahaskell.com/types-and-typeclasses
08:32:10 <olavx200> > data Digit = Ace | Two | Three | Four | Five | Six | Seven | Eight | Nine | Ten | Jack | Queen | King deriving (Ord)
08:32:10 <olavx200> > Why is this line invalid?
08:32:10 <olavx200> Turns out this was fixed by deriving Eq too.
08:32:12 <lambdabot>  <hint>:1:26: error:
08:32:13 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
08:32:13 <lambdabot>  <hint>:1:1: error: parse error on input ‘data’
08:32:23 <olavx200> I guess that kind of makes sense.
08:34:55 <merijn> olavx200: Eq is a superclass of Ord, yeah
08:35:27 <olavx200> True
08:36:55 <olavx200> The bonus guy doesn't seem to be online very much :/
08:37:17 <merijn> It's been ages since he was around
08:37:34 <olavx200> ah
08:39:14 <olavx200> I was going by the info on the learnyouahaskell.com page. It didn't mention there that you needed to derive the Eq typeclass before the Ord so I thought I would send him a message. Guess I will have to use email then :/
08:40:03 <merijn> olavx200: You don't, technically, have to derive Eq. You could write it by hand :p
08:40:19 <olavx200> technically :)
08:40:29 <merijn> I doubt the page will get updated
08:40:41 <olavx200> Damn the bot is purging the matrix users
08:40:44 <merijn> LYAH is, like, 11 years old by now
08:41:07 <merijn> And honestly, not that great from a pedagogical standpoint
08:41:59 <olavx200> The lack of exercises kinda sucks, but I found some on github.
08:44:40 <olavx200> I will finish LYAH since I have started it, but why is it that you think it is not great?
08:45:31 <olavx200> And as a followup is there any better alternatives?
08:46:57 <ChaiTRex> olavx200: Someone was recommending Programming in Haskell by Hutton.
08:47:12 <shapr> it's a good book
08:49:09 <sushsis> Hello, good someone explain `a = (+) <$> Nothing` `b = a <*> Just 1` what is happening here? from my understanding the first part should return `a == Nothing` but it returns `a :: Num a => Maybe (a -> a)`
08:50:01 <merijn> :t (+)
08:50:02 <lambdabot> Num a => a -> a -> a
08:50:14 <merijn> sushsis: So (+) takes two arguments
08:50:18 <disconsis> win2ero: I think you used "int" instead of "Int"
08:50:19 <merijn> :t fmap
08:50:21 <lambdabot> Functor f => (a -> b) -> f a -> f b
08:50:27 <merijn> :t fmap (+)
08:50:28 <lambdabot> (Functor f, Num a) => f a -> f (a -> a)
08:50:32 <Cale> (+) :: Num a => a -> (a -> a)
08:50:55 <Cale> ^^ these redundant parens might help
08:50:59 <merijn> sushsis: "Num a => Maybe (a -> a)" can still be Nothing :)
08:51:05 <suppi> If you pattern match on a the Nothing pattern will match. But it's type does not have an Eq constraint because functions don't have that.
08:51:07 <disconsis> :t (+) <$> Nothing
08:51:08 <lambdabot> Num a => Maybe (a -> a)
08:51:34 <merijn> sushsis: It just says that "IF there is something, that something has type "a -> a" with 'a' having an instance of Num"
08:51:47 <sushsis> merijn: ah, okay, I get it now, I thought it was some partially applied function with Nothing as first argument and was a bit confused
08:51:57 <sushsis> merijn: thanks
08:52:24 <ChaiTRex> > (+) <$> Nothing
08:52:24 <merijn> > Just (+1) <*> Just 2
08:52:26 <lambdabot>  Nothing
08:52:26 <lambdabot>  Just 3
08:52:33 <merijn> > Nothing <*> Just 2
08:52:35 <lambdabot>  Nothing
08:59:50 <gaze__> what's the current best practice in writing concurrent software in haskell for shared datastructures? Is STM still a thing that's popular?
09:00:14 <wavemode__> stm is wildly popular
09:00:26 <merijn> stm is great
09:00:29 <gaze__> interesting! Ok.
09:00:54 <merijn> Haskell is pretty much the only language STM was ever great in, and probably will be for the forseeable future :p
09:01:10 <gaze__> do you have any examples of big codebases that use STM?
09:01:44 <merijn> Lots of them probably indirectly :p
09:02:28 <Uniaika> I like that the main abstraction for processes in Erlang (GenServer) protects from race conditions because the messages you send to its mailbox are sequentially processed
09:03:44 <merijn> gaze__: STM (or, at least GHC's implementation) is best used by having lots of little bits in lots of places, so I'm not sure there's any specifically big codebase that has large amounts of it
09:04:56 <gaze__> ehhh maybe what I'm looking for is some large codebase that's dependent on it in some way. I don't know of that many big concurrent haskell applications that are open source.
09:05:08 <gaze__> most times I look for examples for how to structure haskell code I look at GHC
09:05:23 <gaze__> but I also haven't looked particularly deeply in a long time.
09:05:52 <merijn> gaze__: What sorta code/thing are you implementing?
09:06:20 <gaze__> a server for coordinating access to a bunch of servers that control lab instruments.
09:06:34 <wavemode__> well, warp uses stm, and warp is depended on by many web apps, including yesod
09:06:44 <gaze__> super :)
09:07:06 <gaze__> I'll check out Warp. I think that's a nearly perfect model for what I'm trying to do
09:09:09 <maerwald> gaze__: I know of an application, but it's proprietary
09:09:14 <maerwald> using STM
09:09:26 <gaze__> yeah! I imagine there's quite a lot of closed source haskell at this point
09:09:58 <maerwald> gaze__: you can read about some of the architecture here https://tech-blog.capital-match.com/posts/3-anatomy-of-haskell-web-app.html
09:10:08 <maerwald> It talks about STM use too
09:13:06 <dsal> I was writing some STM code last night.  I keep seeing it available in other languages, but like... you can't really do it in other languages.
09:13:58 <dsal> The async library is built on STM as well, allowing for useful composition of threaded stuff.
09:14:38 <dsal> STM composition is also quite amazing on its own.
09:18:38 <johnw> STM is one of the things I miss most when using any other language
09:22:03 <grepcake> Hi! I am making a CLI and I want to make it easy to add new commands. Right now, I designed it in a way that for properties of every new command have to be specified separately as show in the link. I would be very glad for any ideas on how to specify command properties in one place. https://gist.github.com/grepcake/d30f994f8f41598d0994e6c467f92f94
09:23:17 <dsal> I learned recently that optparse-applicative has explicit support for subcommands.
09:24:11 <grepcake> Yeah, that's what I use.
09:24:32 <dsal> But you can, you know, instead of having  `CommandTag -> Thing` have `CommandTag -> (More, Than, One, Thing)`
09:25:02 <dsal> Or even instead of having Command as a type with no information, just put all that information directly in the type.
09:25:08 <grepcake> dsal: But I don't generally need all the things at once 
09:25:31 <dsal> You said you did above.  ^ "I would be very glad for any ideas on how to specify command properties in one place"
09:26:20 <dsal> If you put them all in one place, they'll all be in one place.  It's easy to programmatically split them out if you want a bit here and there.
09:26:48 <grepcake> Okay, that's fair
09:27:33 <grepcake> Putting all information in the type would though imply that it's possible to construct different Cd's with different names which seems undesirable
09:28:12 <johnw> I'd like to see a marriage of optparse-applicative and servant: define the option schema at the type level so that you can just as easily generate an options parser as an options generator.
09:28:47 <johnw> (by the latter I mean: given an Options value, generate the set of options that are needed to recreate that value)
09:29:15 <dsal> https://hackage.haskell.org/package/optparse-generic ?
09:30:08 <johnw> closer
09:30:13 <johnw> not exactly what I meant
09:30:29 <johnw> but at least it does use the data type itself to generate the options parser
09:30:37 <aveltras> having some gadt like the following, how can i encode the information representing the request and its response in a tuple in order to use it later (as some sort of cache), for example, let's say that i have already handled RequestG2 here, i'd like to have the information that if another RequestG2 comes with the same Int as argument, i can use the previous response by looking up its "cache tag". Is the hashable 
09:30:37 <aveltras> package a possible solution in that case ?
09:30:41 <aveltras> https://www.irccloud.com/pastebin/WR6IYnJ1/
09:36:58 <olavx200> I don't understand the difference between function composition and  function application($). Could someone help me clear it up?
09:38:13 <dsal> Function composition makes functions.  Function application applies functions.
09:38:54 <dsal> Though that's differently confusing, heh.
09:39:03 <dsal> :t (+1) . (*3)
09:39:04 <lambdabot> Num c => c -> c
09:39:06 <dsal> :t (+1) $ (*3)
09:39:07 <lambdabot> Num a => a -> a
09:39:30 <sm[m]> http://hackage.haskell.org/package/docopt lets you define CLIs from their usage message. It's less featureful, but might be of interest
09:40:20 <olavx200> I thought that was the same. Like f1 f2 is the same as f1(f2)
09:41:06 <sushsi> from the documentation of Applicative `(<*>) :: Applicative f => f (a -> b) -> f a -> f b` I would assume that only functions with one parameter can be in the applicative. How come I can have `(Applicative f, Num a) => f (a -> a -> a -> a)`?
09:41:28 <dsal> Well, parentheses don't' do anything there, so yeah, that's very much the same.
09:41:43 <dsal> sushsi: all functions have one parameter
09:42:26 <sushsi> ah, my bad, thanks 
09:44:00 <merijn> sushsi: 'b' can be anything, including a function :)
09:44:39 <merijn> sushsi: Keep in mind that "Char -> Int -> Bool" is equivalent to "Char -> (Int -> Bool)" (i.e. a function that takes a Char and returns a function of type "Int -> Bool"
09:45:50 * dsal runs `stack test` -- nixos: "Hold on, I gottta install a perl5 fastcgi library"
09:46:36 <merijn> So if we have "f (x -> x -> x -> x)" that just means (in the original Applicative signature) 'a = x' and 'b = x -> x -> x'
09:48:49 * hackage yamlparse-applicative 0.0.0.0 -   https://hackage.haskell.org/package/yamlparse-applicative-0.0.0.0 (Norfair)
09:51:21 <day> can i compare characters to unicode codepoints in haskell somehow?
09:56:30 <maerwald> characters are unicode codepoints
09:56:50 * hackage haskoin-store 0.24.0 - Storage and index for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-store-0.24.0 (jprupp)
09:57:08 <day> well i doubt "a" == 0xXX would evaluate to true in haskell :p
09:57:24 <dsal> That's a different question.
09:57:33 <maerwald> day: String is a list of unicode code points
09:57:34 <day> o0
09:57:42 <day> well 'a'
09:57:49 <dsal> > ord 'a'
09:57:51 <lambdabot>  97
09:57:59 <day> yeah just stumpled across ord too
09:58:27 <dsal> I like how `ord` and `Ord` are unrelated.
10:00:32 <Borland04> do they?
10:03:07 <Borland04> Wow, they're really unrelated... God damn =)
10:03:26 <day> thought the same lol
10:11:08 <dmwit> > 'a' == '\x61' -- day, where is your god now?
10:11:10 <lambdabot>  True
10:13:04 <sushsi> did anyone read Programming with Haskell by Will Kurt?
10:13:08 <maerwald> dmwit: lol
10:13:23 <maerwald> I read that with a viking voice
10:15:39 <dmwit> Okay. I can't say I understand why, but I'm not complaining. ^_^
10:15:50 * hackage shellmet 0.0.3.1 - Out of the shell solution for scripting in Haskell  https://hackage.haskell.org/package/shellmet-0.0.3.1 (shersh)
10:17:20 <sm[m]> yet another call shell from haskell solution, eh
10:18:01 <dsal> shell is just really microservice glue of unix
10:18:40 <sm[m]> I think kowainik are not newbies, so why.. ? Is this syntax easier than all that have come before ?
10:20:43 <sm[m]> text <- "cat" $| ["README.md"]   -- <- is that intuitive ?
10:20:55 <sm[m]> for reading the content of README.md ?
10:22:07 <phadej> no.
10:22:23 <phadej> text <- readTextUtf8 "README.md" -- would be
10:22:34 <maerwald> I find https://hackage.haskell.org/package/shake-0.18.5/docs/Development-Shake.html#v:cmd better, but the type machinery isn't that nice
10:23:01 <maerwald> Stdout out <- cmd "cat README.md"
10:23:16 <sm[m]> what's not nice, maerwald ?
10:23:23 <maerwald> the types
10:23:38 <sm[m]> I know you said, type machinery, but.. ie type errors are hard ?
10:23:48 <maerwald> just reading it I have no idea what it is
10:24:04 <sm[m]> or do you mean reading the code is hard ?
10:24:22 <maerwald> all of it
10:26:07 <sm[m]> I remember having a slight learning curve with shake's cmd, but then it felt comprehensive and robust and fairly low boilerplate. It's my current favourite
10:26:22 <sm[m]> I'd like to use it as a standalone lib
10:29:41 <day> after the ghc update to 8.8.3 i can no longer 'import Data.List.Split' Data.List is still importable however
10:30:14 <day> ah wait. it appears to be it's own package
10:30:38 <sm[m]> yup. ALAS
10:33:50 <Exarmatio> does anyone know if there's a way in optparse-applicative to specify groups of options with their own header (not subcommands, just related options)
10:40:38 <maerwald> yes
10:41:19 * hackage ilist 0.4.0.1 - Optimised list functions for doing index-related things  https://hackage.haskell.org/package/ilist-0.4.0.1 (shersh)
10:41:28 <maerwald> commandGroup
10:41:37 <monochrom> neat
10:41:59 <sm[m]> that's a group of commands, not options ?
10:42:54 <maerwald> yes
10:43:13 <monochrom> yikes
10:43:26 <sm[m]> I know you can do it with cmdargs
10:46:00 <dsal> If there were a group for arguments, they should call it facebook or something.
10:46:05 <sm[m]> because Flags are first-class values. Maybe they aren't in optparse-applicative ?
10:46:25 <monochrom> err why facebook? heh
10:46:37 <Exarmatio> they are
10:46:40 <dsal> That's how you organize argument groups.
10:46:55 <monochrom> because I thought people do mutual congratulations, not arguments, on facebook
10:47:06 <Exarmatio> I just can't find a way to say "these all go under one heading" for flags
10:47:54 <monochrom> perhaps I have only been in self-congratulating echo-chamber groups.
10:48:11 <monochrom> perhaps that's exactly what you mean!
10:49:54 <sm[m]> cmdargs FTW! ra ra ra!
10:50:30 <maerwald> Exarmatio: https://github.com/pcapriotti/optparse-applicative/issues/270
10:53:35 <Exarmatio> cmdargs looks weird... how is `def &= help "World argument" &= opt "world"` a string? Looks like cheating to me
10:54:08 <sm[m]> it's not
10:56:46 <sm[m]> uh.. yes that readme example does look weird
11:01:08 <Exarmatio> Maybe I'm wrong but from glancing over the docs it looks like there's the Explicit module which doesn't do weird things, but the (recommended?) default looks very strange and hacky to me
11:01:33 <sm[m]> &= adds Ann annotations to a Data type. Maybe String is an instance of Data ? I'm not seeing it though
11:02:02 <Exarmatio> https://hackage.haskell.org/package/cmdargs-0.10.20/docs/System-Console-CmdArgs-Explicit.html
11:02:02 <sm[m]> ah, 'tis. After importing Data.Data I see it.
11:02:32 <merijn> Honestly, I find cmdargs API extremely opaque and confusing
11:02:44 <monochrom> Data Char and (Data a => Data [a]) combined to give Data [Char].
11:02:57 <sm[m]> it offers three, you can pick the one you like best
11:03:17 <merijn> sm[m]: The cmdargs API I like best is optparse-applicative ;)
11:03:43 <sm[m]> clearly that's not a cmdargs API since you can't group options :)
11:03:49 <monochrom> command line parsing : cmdargs :: regex matching : regex family
11:03:52 <sm[m]> or accept partial command-line flags
11:04:06 <merijn> sm[m]: You can group options
11:04:16 <merijn> Or did you mean the help output?
11:04:29 <sm[m]> and display them with their own headings.. yes
11:04:34 <sm[m]> we were discussing it above
11:04:36 <monochrom> i.e., a lot of type classes and instances for automatic type-directed name resolution
11:04:44 <Exarmatio> I was looking for a way to group flags earlier and the consensus was the optparse-applicative can't do it
11:04:53 <merijn> Dramatically improving the help output of optpase-applicative is on my todo list
11:05:13 <merijn> You know, right after "finish thesis" >.>
11:05:37 <sm[m]> merijn: are you optparse-applicative's author/maintainer ?
11:05:42 <merijn> No
11:06:19 <monochrom> I have a cunning plan!  A CFG parser library that tells you to "deriving Generic" on your recursive type, and the library automatically writes a default parser for you!
11:06:28 <Exarmatio> I'm not sure how dramatically it needs to be improved, but that's a minor nuisance... Related options tend to be appear together because of how optparse-applicative works anyway
11:06:32 <monochrom> Oh wait it's called "deriving Read" nevermind!
11:06:42 <sm[m]> ok. Personally optparse-applicative was the one I always found extremely opaque and confusing, but presumably things have improved. Also it's much harder to type than "cmdargs".
11:06:45 <merijn> But I've got about 2k lines of commandline parser using optparse-applicative and the only gripes I have are: 1) insufficient control over help rendering, 2) no support for selective functors yet, and 3) no support for ByteString access to args
11:07:00 <Exarmatio> but if you have a lot of options, that's not really sufficient anymore
11:10:02 <sm[m]> some company should invest in improving docopt, making it more on par with the other two
11:10:51 <sm[m]> or making it a front end for one of the others, with the ability to escape to the lower level when it can't do what you need
11:11:14 <maerwald> sm[m]: I also find optparse-applicative confusing
11:11:20 <maerwald> too much monoid stuff to combine
11:12:11 <merijn> maerwald: How so "too much" you don't need to write out any of the things you don't need
11:12:24 <merijn> Although I think the examples in the readme are written exceedingly ugly
11:12:26 <maerwald> merijn: it's just odd API, not declarative API
11:12:33 <maerwald> it's bound to the parser
11:12:37 <Exarmatio> how is it not declarative?
11:13:13 <monochrom> What would a declarative API look like for this?
11:13:20 <maerwald> monochrom: https://click.palletsprojects.com/en/7.x/
11:13:31 <maerwald> you see nothing of a "parser" in that API
11:13:33 <maerwald> and you shouldn't
11:14:00 <merijn> maerwald: There's lot of things you can't express with that, though
11:14:15 <maerwald> merijn: anything specific in mind?
11:14:27 <maerwald> it has escape hatches to pretty much do anything
11:14:30 <merijn> Even something as simple as "mutually exclusive option sets" 
11:14:38 <merijn> maerwald: I don't want escape hatches
11:14:43 <monochrom> I think I have used optparse-applicative exactly like that.
11:14:47 <merijn> I want to be able to write those things directly
11:15:05 <maerwald> Well, and I want a declarative API, not code parsers :P
11:15:19 <merijn> optparse is a bit minimal, so for truly big and complex commandline setups you want to package it up a bit further
11:15:41 <Exarmatio> I just don't see how @option("--count", default=1, help="number of greetings") is that much better than option 1 (long "count", help "number of greetings")
11:15:43 <maerwald> my optparse-applicative code usually ends up so huge, that I'm not sure it's less than manually doing everything
11:16:01 <Exarmatio> <>, not comma but you get what i mean
11:16:04 <maerwald> Exarmatio: it's a function annotation
11:16:10 <Exarmatio> I know
11:16:14 <merijn> maerwald: Then you're doing something wrong, I think? :p
11:16:16 <maerwald> the function is the command
11:16:16 <Exarmatio> how is that an improvement?
11:16:21 <merijn> Exarmatio: Better yet, use mconcat!
11:16:22 <maerwald> optparse-applicative is nothing like that
11:16:33 <sm[m]> command line options parsing gets complicated..
11:16:37 <merijn> I don't understand why people use <> and braces with optparse
11:16:44 <merijn> mconcat + lists is so much cleaner
11:17:01 <merijn> maerwald: Define "nothing like"
11:17:15 <maerwald> there was a haskell cli lib that was a little similar to this, where you define functions as commands
11:17:18 <Exarmatio> I don't know what you mean with "nothing like", I really don't see a big difference
11:17:19 <maerwald> but I can't find it anymore
11:17:34 <maerwald> Exarmatio: well, then maybe use it a little
11:17:38 <Exarmatio> if you have a non-trivial entry point you'll want it in a separate class with annotation based parsers too
11:17:39 <maerwald> I've used both heavily
11:17:49 <merijn> maerwald: I use it a lot and I still don't see a big difference :)
11:18:00 <maerwald> and I would pick 'click' over 'optparse-applicative' any day
11:18:30 <sm[m]> maerwald: what are some things you've wanted to do that were hard with click ?
11:18:35 <Exarmatio> I'm not using that one specifically, but I've used https://picocli.info/ a bit, basically the same thing
11:18:40 <maerwald> sm[m]: none
11:18:55 <Exarmatio> but I don't see how one is way better than the other
11:19:27 <maerwald> I really don't care about expressivity here. An API isn't better than another just because it's more expressive. It's about intuition, code structure and readability.
11:19:28 <sm[m]> nice. Well I guess it's python, nothing should be hard, except avoiding runtime type errors
11:19:41 <koz_> sm[m]: Or refactoring. :P
11:19:45 <merijn> maerwald: If you only write simple things, then it doesn't matter
11:20:08 <maerwald> merijn: click allows complicated things too
11:20:23 <Exarmatio> If you have 50-60 command line arguments it gets really annoying having to put all of them as annotations on a function
11:20:27 <maerwald> But when you optimise your entire API for the most complicated use cases, it will turn out odd
11:20:38 <sm[m]> I care most about fine control of the UX (presentation, flexible ordering, partial flags etc.), secondly about cognitive load & boilerplate for the developer
11:20:39 <merijn> maerwald: I can tell you know that my optparse parser is much simpler to follow than my python one, despite my optparse parser literally being 5x more code than my entire python scripts :p
11:20:58 <maerwald> yes, it's noisy
11:21:09 <maerwald> and I don't like the code structure
11:21:28 <merijn> maerwald: Not because it's noisy, because my haskell commandline is much more complex than the python one
11:21:31 <maerwald> It basically reminds me of how I do argparsing in shell.
11:21:45 <Exarmatio> now you're reaching
11:22:06 <merijn> I've done argparsing in the shell a lot too, and it's nothing alike...
11:22:12 <maerwald> Well, you're usually pattern matching on your commands later
11:22:24 <sm[m]> oh! he's gone too far
11:22:33 <maerwald> which will look pretty equivalent to how you do it in shell
11:22:34 <merijn> maerwald: No reason too, you can just return "IO ()" if it makes you happy
11:22:36 <merijn> And I do
11:22:46 <maerwald> sm[m]: :D
11:23:07 <fog> why does this open type family not work, while the closed type family version does? 
11:23:08 <fog> https://pastebin.com/raw/g7puRbyM
11:23:45 <sm[m]> fog can't you see we have a crisis to resolve
11:24:01 <maerwald> xD
11:24:02 <fog> oh, ill check the log
11:24:38 <sm[m]> sorry. carry on
11:25:01 <maerwald> I'm trying to find the other cli parsing lib which uses functions as commands afair.
11:25:06 <maerwald> It was lots of type hackery though
11:25:20 <fog> idk about ottoparsec
11:25:26 <maerwald> otto?
11:25:43 <fog> or any of the parsecs
11:25:45 <Exarmatio> I still don't see why you see functions as entry point as the gold standard to reach
11:25:50 <sm[m]> maerwald: IIRC only the big two are complete enough for production use
11:25:57 <maerwald> otto is kinda an insult in my language xD
11:26:16 <maerwald> you meant attoparsec?
11:26:22 <Exarmatio> I mean aside from the fact that that one python lib and probably some others do it like that
11:26:34 <sm[m]> fog we're talking command line option parsing, not general parsing 
11:26:44 <fog> oh no!
11:27:08 <monochrom> We have an argument argument.
11:27:13 <sm[m]> yes I'm afraid so
11:27:27 <monochrom> This is an argument argument group.
11:27:32 <sm[m]> the options are perplexing
11:27:40 <monochrom> \∩/
11:28:05 <fog> be well people!
11:28:18 <maerwald> We're too well, I think
11:29:39 <monochrom> I consider the monoid-and-applicative-based ones declarative enough in the constraint of Haskell.
11:30:04 <maerwald> next thing you're telling me haskell is declarative?
11:30:13 <monochrom> Any step further is too magical like click and the type hackery one you have in mind.
11:30:17 <fog> i can see this is a bad time...
11:30:22 <maerwald> :D
11:30:24 <monochrom> No, I don't go that far.
11:32:09 <maerwald> Ah, I found it (after wading through 200 reddit comments)
11:32:23 <maerwald> https://github.com/SamuelSchlesinger/environment
11:34:18 <monochrom> Oh, that is an interesting idea.  I shouldn't diss it.
11:34:26 <maerwald> but ultimately, all this should be a polysemy effect
11:36:08 <fog> hmm there is a workaround by putting the open type family in a class...
11:36:27 <fog> https://pastebin.com/raw/x5MYuNz5
11:36:37 <fog> still not sure why the original version doesnt work though
11:38:07 <monochrom> Does it have to use type-level string literals?  Can't it use term-level strings?  arg "file-name" \fileName -> ...
11:44:00 <maerwald> that's probably not cool enough
11:50:22 <hseg> trying to cleanly optimize http://ix.io/2laV. basically am comparing two vectors on inner products with weights n = [replicate k 1 ++ replicate (n-k) 0 | k <- [n,(n-1)..1]]
11:50:57 <hseg> (so iow, compare on sum, then sum . init, then sum . init . init, until we're comparing on head
11:50:58 <hseg> )
11:51:54 <hseg> can brute-force it, but is there a nicer way of doing so?
11:52:32 <monochrom> maerwald: I think I understand everything now!
11:52:51 <hseg> (btw, if anyone's wondering, this is implementing grevlex ordering on monomials)
11:52:55 <maerwald> oh well, I haven't looked at it long enough
11:53:32 <monochrom> I believe that the type-level strings can be replaced by term-level strings. It is non-essential.
11:56:07 <monochrom> I believe the essential point is: foo :: (A -> IO b) -> IO b, foo (\filename -> ...) means foo will take a look at getArgs, fish for the appropriate arguments, and if successful, call (\filename -> ...) with the filename extracted from getArgs.
11:57:06 <monochrom> And next thing you know, it could as well be fooV2 :: IO A, and you may as well go "fooV2 >>= \filename -> ..."
11:57:36 <maerwald> and then <*> is not far
11:58:00 <monochrom> the characterizing law being: foo k = fooV2 >>= k. The usual monad-vs-cps correspondence.
11:58:55 <koz_> CPS is all the way down.
12:00:27 <monochrom> This is more expressive, not less, than the monoid-applicative-based methods.
12:02:00 <monochrom> You now have the power to do: foo (\filename -> if filename is all upper case then bar (\url -> ...) else quar (\bool -> ...))
12:02:03 <dmwit> hseg: compare `on` (scanl (+) 0 . reverse) -- ?
12:02:23 <hseg> always forget about scanl
12:02:26 <monochrom> whereas applicative-based methods cannot support such dynamic dispatch.
12:02:27 <dmwit> hseg: N.B. I didn't read your original code, just your English description
12:02:58 <hseg> dmwit: actually, you want map reverse . scanl (+) 0
12:03:07 <dmwit> Dunno. Might want both reverses.
12:03:19 <monochrom> But perhaps you are agnostic to expressivity.  You prefer "foo" and "\filename" to stick together.
12:03:32 <dmwit> The reverse I put is so that your sums are the whole thing, the init, the init.init, etc.
12:03:41 <dmwit> Instead of the whole thing, the tail, the tail.tail, etc.
12:04:09 <hseg> right, mistyped. should be reverse . scanl (+) 0
12:04:28 <dmwit> But I didn't think carefully enough. So you're probably right. I'm just glad I transmitted the important core of the idea.
12:04:42 <hseg> will that get fused?
12:05:45 <hseg> especially, will let mWeight = reverse . scanl (+) 0 in mconcat $ zipWith compare (mWeight x) (mWeight y) fuse?
12:06:17 <monochrom> I find that the monoid-applicative-based methods not too far off from that ideal, if I stick to a simple idiom.  Yes there is still a difference but it's small.
12:06:32 <dmwit> Why not just `let mWeight = ... in compare (mWeight x) (mWeight y)`?
12:07:40 <dmwit> ?quickCheck \xs_ ys_ -> let len = min (length xs_) (length ys_); xs = take len xs_; ys = take len ys_ in mconcat (zipWith compare xs ys) == compare xs ys
12:07:40 <lambdabot> Unknown command, try @list
12:07:46 <dmwit> ?check \xs_ ys_ -> let len = min (length xs_) (length ys_); xs = take len xs_; ys = take len ys_ in mconcat (zipWith compare xs ys) == compare xs ys
12:07:49 <lambdabot>  +++ OK, passed 100 tests.
12:07:56 <dmwit> ?check \xs_ ys_ -> let len = min (length xs_) (length ys_); xs = take len xs_; ys = take len ys_ in mconcat (zipWith compare xs ys) == compare xs (ys :: [Int])
12:07:58 <lambdabot>  +++ OK, passed 100 tests.
12:08:10 <monochrom> I define a record type.  I write a "parser" (really only extractor) using applicatively and/or monoidly, which is a composition by <*> and <> of names, messages, how to convert string to field type.
12:08:47 <monochrom> Then my function takes that record type for parameter.
12:12:10 <monochrom> I don't have "main = foo (\filename -> bar (\url -> ...))", I have instead "foobar = Ctor <$> foo <*> bar" and "main = get foobar >>= \Ctor filename url -> ..."
12:14:25 <monochrom> Though my hands are defending the monoid-applicative way, my brain is still working on the monadic way.
12:15:05 <maerwald> but what does your heart say?
12:15:37 <monochrom> At the very least someone should publish an implementation of the monadic way to hackage and see how many people like it.
12:15:56 <monochrom> My heart says this is likable and we need this diversity.
12:16:34 <monochrom> My crystal ball says there is approx 70% chance I will switch to it in the future for my https://github.com/treblacy/random-read
12:17:22 <monochrom> My soul says diversity is beautiful, the world is beautiful
12:17:23 <merijn> monochrom: I'd like a selective functor one first :p
12:17:25 <fog> what a waste of good crystals..
12:17:39 <maerwald> merijn: that'd be interesting
12:18:19 <merijn> maerwald: There's an issue for possibly adding selective to optparse
12:18:33 <monochrom> What is selective functor?  Is it the one about "foo >>= \b -> if b then x else y"?
12:18:43 <merijn> monochrom: Roughly
12:19:12 <merijn> monochrom: The paper is quite a nice read. One of my favourite papers from the past few years
12:19:19 <merijn> Together with Build Systems a la Carte
12:19:28 <monochrom> I mean TL;DR of course. We know that they went more general and "let's use Either for the medium" etc.
12:19:43 <fog> simon marlow was talking about automatically parellelising those kinds of things
12:20:04 <maerwald> but... the real question is: can you make it a polysemy effect? :>
12:20:15 <fog> something about <*> vs join
12:20:56 <fog> was it Haxl? i cant remember, just something about sledgehammers
12:21:32 <monochrom> Somehow I don't like Either but I understand that it's "from the people who brought you ArrowChoice which also uses Either"
12:22:14 <monochrom> (please imagine that in movie trailer deep-bass narrator voice!)
12:22:35 <fog> like, detecting which branching computations can be run seperatly and when the branches need to recombine
12:22:56 <maerwald> I'm imagining that in deep beijing accent
12:23:07 <monochrom> maerwald: I will start with vanilla IO :)
12:23:24 <fog> which i think rested on factoring within the Monad to parts which could just use Applicative
12:23:31 <fog> i have no idea how it worked
12:23:38 * dsal sings Vanilla IO, Baby
12:24:09 <monochrom> Also! We need to unify treating command line arguments and treating environment variables!
12:24:20 * hackage hlint 3.1 - Source code suggestions  https://hackage.haskell.org/package/hlint-3.1 (NeilMitchell)
12:24:30 <dsal> I thought someone here did that.
12:24:35 <fog> isnt nix like a command like functional language?
12:24:55 <maerwald> ofc someone has to bring up nix!
12:25:04 <fog> *hides*
12:25:05 <maerwald> it's the answer to everything, after all
12:25:43 <maerwald> monochrom: there's also a recent library, but I didn't even see why it's useful
12:25:56 <maerwald> let me find it in reddit again
12:26:17 <monochrom> reddit sounds like a haystack of needles
12:26:42 <monochrom> If P=NP, can you find stuff in reddit in polynomial time? >:)
12:27:18 <maerwald> https://hackage.haskell.org/package/mr-env-0.1.0.3
12:27:18 <fog99> nix is just a monad in the category of build tools, whats the problem? 
12:27:21 <maerwald> there you go
12:27:50 <maerwald> monochrom: would need an option to hide troll comments (including your own) :P
12:28:39 <maerwald> but I don't see the usefulness in that lib
12:29:07 <maerwald> it's just a wrapper around readMaybe
12:29:10 <fog99> an extensible logic grammar for spam filtering; toll-o-parsec 
12:35:04 <maerwald> hm, then you could require environment variables to be set for a certain subcommand
12:35:08 <maerwald> isn't that a little weird?
12:35:38 <maerwald> environment should always be entirely optional (mostly)
12:39:50 * hackage dobutokO2 0.39.0.0 - Helps to create experimental music from a file (or its part) and a Ukrainian text.  https://hackage.haskell.org/package/dobutokO2-0.39.0.0 (OleksandrZhabenko)
12:51:24 <monochrom> maerwald: Environment variables should be optional, yes. I will think about how to preserve that.
13:56:50 * hackage infernal 0.4.0 - The Infernal Machine - An AWS Lambda Custom Runtime for Haskell  https://hackage.haskell.org/package/infernal-0.4.0 (ejconlon)
13:59:23 <fog> im having trouble with some type equalities;
13:59:27 <fog> https://pastebin.com/raw/88P16S4e
14:00:40 <fog>     * Expected kind `k', but `Root s' has kind `RootKind s'
14:00:43 <fog> despite;
14:00:44 <fog>  ,RootKind s ~ k
14:08:28 <hseg> don't think that's how constraint synonyms work -- the RootKind s ~ k isn't available for the r ~ (Root s) equation afaict
14:08:59 <hseg> have you tried the class (ctx a) => syn a; instance (ctx a) => syn a trick yet? 
14:15:11 <Eugleo> Hey! Anyone has experience with Selda, the SQL library?
14:16:49 <Eugleo> I don't want to have the models' IDs in their type; rather, I'd like to have a "data WithID a = WithID Int a", in which I would wrap any of my model objects.
14:17:35 <Eugleo> Provided I have derived SqlRow for the "a", how do I derive the SqlRow for WithID a?
14:18:45 <Eugleo> It seems like Selda sees the "a" as a field only, while I'd like it to be a whole SqlRow
14:21:25 <fog> its a ghc bug
14:22:21 <fog> this works; https://pastebin.com/raw/aKB386HE
14:22:51 <fog> this doesnt; https://pastebin.com/raw/WnhquN2n
14:22:58 <fog> !!
14:23:17 <fog> the only difference is permuting the order of the code at top level
14:23:42 <fog> thats with ghci-8.10.1
14:25:02 <ovitus> how can I load additional functions into ghci that use the scope that's currently there?
14:25:14 <fog> and as it needs the datatype to be declared before the class it instantiates, I cant factor that class into its own module
14:25:47 <fog> ovitus: you can use :m + Data.SomeModule
14:27:09 <fog> can anyone check to see if this is a bug in another version of ghci?
14:27:25 <fog> i would revert to the previous version if it doesnt have this bug
14:27:46 <maerwald> try with another ghc version then?
14:28:10 <fog> i dont have another installed... 
14:28:15 <maerwald> install it
14:28:26 <fog> i dont know i i need to
14:28:28 <fog> or if it would help
14:28:33 <ovitus> hi fog
14:28:34 <ovitus> I see this
14:28:34 <ovitus> tidal> :module + function.hssyntax:  :module [+/-] [*]M1 ... [*]Mn
14:28:38 <fog> thats why im asking..
14:28:59 <ovitus> function.hs is a file with functions defined
14:29:05 <fog> you cant just import one function
14:29:11 <fog> its for importing whole modules
14:29:16 <fog> they have uppercase syntax
14:29:26 <fog> oh..
14:29:37 <fog> to import your own code you should use :load
14:29:56 <ovitus> when I do :load it says a whole bunch of functions are out of scope
14:30:04 <fog> but i dont think you can use + with that
14:30:16 <ovitus> can I make it a module that can be read?
14:30:19 <fog> why not make another source which imports both modules?
14:30:32 <fog> you *can* install it as a lib
14:30:35 <fog> using cabal
14:30:37 <fog> or stack
14:30:44 <fog> but thats not usually the way to do it
14:30:59 <fog> you should use import at the top of your source file
14:31:34 <ovitus> I don't understand why it needs to be read separately. just would prefer to have a different file to load in addition to what I have already loaded
14:31:44 <ovitus> using some of the same functions that are in scope
14:32:06 <fog> right, but since only :m but not :l supports the +
14:32:19 <fog> you would need to do it the other way
14:34:13 <fog> im not sure if you can open ghci with multiple source.hs files from command line
14:42:34 <freeman42x[m]> does Haskell have anything like the F# Type Providers: https://docs.microsoft.com/en-us/dotnet/fsharp/tutorials/type-providers/ ? if yes, why are they not more popular?
14:43:33 <johnw> does anyone know how to get ghc -static to *not* put -lm on the link line?
14:43:51 <hpc> there's some stuff with template haskell, but it introduces IO to the compilation process
14:43:53 <johnw> I'm using clang, and there is no libm.a
14:44:13 <hpc> so for example, an idea that seems pretty much perfect for this, generating types from db schema
14:44:29 <hpc> you need to have the database running in order to build your code now
14:47:21 <fog> I can confirm its also a bug in ghci 8.8.3
14:48:39 <yushyin> joining for one message and leaving right away?
14:49:57 <enikar> we must be very speed to commicate with him/her…
14:58:20 * hackage reflex 0.7.1.0 - Higher-order Functional Reactive Programming  https://hackage.haskell.org/package/reflex-0.7.1.0 (3noch)
15:14:25 <ovitus> :script Functions.hs
15:14:32 <ovitus> that does as I intended
15:14:45 <ovitus> is there any way to make that part of a do statement?
15:14:53 <ovitus> or does that break the laws of Haskell
15:16:18 <hpc> ghci commands aren't part of the language
15:17:19 <johnw> the Laws of Haskell
15:17:35 <johnw> thou shalt neither abstract too much, nor too little
15:18:27 <ovitus> hehe. but damn that would make Tidalcycles so much more modular if possible
15:18:57 <dsal> Make what part of a do statement?
15:20:58 <freeman42x[m]> hpc: Type Providers by basically their very nature require IO to function, so ofc. whatever implements them will use IO
15:21:49 * hackage capnp 0.6.0.0 - Cap'n Proto for Haskell  https://hackage.haskell.org/package/capnp-0.6.0.0 (isd)
15:35:20 <koz_> Is the common advice that, for any sort of string thing where regexps become sensible, I should use parser combinators?
15:35:34 <koz_> In my specific case, I don't care _how_ something fails - merely whether it does or not.
15:35:45 <koz_> I already have Text, which means I know it'll be sensibly encoded.
15:36:06 <koz_> (so I basically have Text -> Maybe Foo)
15:36:16 <koz_> Dragging in something like megaparsec seems hilariously excessive for this.
15:38:05 <solonarv> koz_: there is actually a parser combinator lib in base (Text.ReadP)
15:38:15 <solonarv> now, I've never used it myself, but maybe it'll work for you
15:38:47 <koz_> solonarv: It works for String if I'm not much mistaken.
15:38:55 <koz_> Which is suboptimal, since I have Text already.
15:39:06 <MarcelineVQ> ghc comes with parsec if you want to be a little saner, but megaparsec isn't on my list of excessive
15:39:28 <koz_> MarcelineVQ: For a one-place use, for one type, requiring no error reporting beyond 'lol I failed'?
15:39:38 <maerwald> koz_: regex is awesome
15:39:50 <maerwald> and we have good regex libs
15:40:01 <koz_> maerwald: What would you suggest?
15:40:30 <maerwald> I use regex-posix, because of the low dependency footprint
15:40:42 <maerwald> but it isn't the fastes and has a pretty constrained feature set
15:40:44 <maerwald> there are others
15:41:31 <solonarv> koz_: oh right
15:41:44 <koz_> maerwald: Low dep footprint and simplicity are my main concerns. I don't need much functionality - it can be written as a regular expression (in the formal languages sense).
15:41:54 <koz_> (meaning nothing outside of concatenation, alternation, Kleene star)
15:43:11 <maerwald> regex-posix then
15:43:20 <koz_> maerwald: Thanks!
15:43:49 <dsal> koz_: I tried doing my APRS stuff with regex originally and suffered tremendously.
15:44:21 <dsal> I did not expect it to fail with async exceptions.
15:44:51 <dsal> I was using regex-compat, though.
15:44:53 <koz_> dsal: APRS?
15:45:27 <dsal> koz_: packet radio stuff.  Before I learned how to parsec at all, I tried using regex to parse the protocol.
15:46:03 <dsal> In addition to just being gross for that task, I'd end up with input causing exceptions to be thrown because the input strings were invalid.  I'd hope for just like, a match failure.
15:47:12 <dsal> I don't mind going the extra parsec to keep things sensible.  But I'm fairly biased against regex in general.
15:47:23 <koz_> maerwald: Can Text.Regex.Posix work with Text?
15:47:28 <koz_> It looks like String or ByteString.
15:47:52 <koz_> dsal: I'm asking because in general, I would be biased against regexps too. However, dragging in a whole parser combinator library here seems overkill.
15:48:10 <dsal> Yeah.  Half the time I do it just to get slightly better at parsers.  I'm still not great.
15:48:42 <maerwald> koz_: seems not, is the text that huge that you are concerned with conversion?
15:49:57 <koz_> maerwald: No.
15:50:05 <koz_> But if I can avoid having to round-trip, that'd be nice.
15:50:24 <koala_man> what do you want the user to be able to do?
15:50:28 <koala_man> oops, ww
16:07:50 <sm[m]> dsal: that sounds no fun.. when did regex-compat throw async exceptions ? Does that mean calling error  on malformed regexps ?
16:08:07 <dsal> No, on malformed input.
16:08:49 <sm[m]> input is the text you are searching with the regexp ?
16:10:54 <sm[m]> if so, how can that be malformed ? bad text encoding ?
16:14:20 <maerwald> feeding user input into regexps? :>
16:15:04 <sm[m]> that'd be what I meant by malformed regexps.. user-entered regexps causing the program to die
16:15:11 <sm[m]> it's a pretty bad feature in a regexp lib
16:15:17 <sm[m]> "feature"
16:16:40 <sm[m]> koz_, I feel like http://hackage.haskell.org/package/regex is the most modern full-featured (eg with Text support) regex lib right now. Maybe you can find another with smaller footprint, not sure. I think if you use regexps at all you're going to want more features later and you might as well learn one good one
16:18:03 <dsal> sm[m]: yeah, it assumes the thing you're looking at is valid text.
16:18:23 <koz_> sm[m]: Thanks, will look.
16:18:58 <sm[m]> aha.. so add that to my desiderata for a good regex lib.. handle malformed matchee
16:19:28 <maerwald> should it?
16:19:39 <sm[m]> how come a Text can be not valid ?
16:20:12 <sm[m]> maerwald: no, it shouldn't have to you'd think
16:20:55 <maerwald> I feel this is something you can come up with separately. Sanitizing and verifying input is also too broad of a problem to solve generically.
16:21:00 <wavemode> invalid as in invalid Unicode
16:21:18 <wavemode> many regex libs operate on ByteString instead
16:21:38 <maerwald> well, that's a user error then ::)
16:21:52 <sm[m]> dsal if you remember any more details I wouldn't mind understanding exactly what/who was to blame
16:21:57 <dsal> I'm looking...
16:22:04 <sm[m]> +1
16:26:35 <dsal> Well, I can't the exact thing.  This is how I learned about `evaluate` though.  heh.  My tests include running the parser over a bunch of test cases I extracted from some perl library that had a lot of samples it had parsed.  Some of these running through my parser would cause an exception to be thrown from the regex library.
16:29:50 <sm[m]> gotcha. I used http://hackage.haskell.org/package/regex-tdfa which also has this flaw
16:30:45 <dsal> Yeah, it may not be in the regex library at all.
16:31:02 <dsal> Something was reading bytes from disk and converting it to a string of some sort.  That's presumably what broke.
16:31:16 <sm[m]> or a similar flaw I should say (it calls error when given a malformed regexp). Though, perhaps if I called compile more I could avoid that.
16:31:42 <dsal> malformed regex would be OK at least.  In my case, they'd be programming errors.
16:32:09 <sm[m]> I use them heavily in user data
16:32:52 <dsal> It's not great in general, but it kind of sucks to get an exception on the thing you're trying to match.
16:33:27 <jacks2> there's no Maybe, Either, or similar alternative function for reporting errors
16:33:31 <jacks2> ?
16:33:31 <dsal> In any case, a proper parser was the right thing to do for me and solved this problem and got me a significantly better implementation because the protocol is more... observed than designed.
16:33:36 <dsal> jacks2: why not both?
16:33:45 * sm[m] plans to try regex next time
16:33:55 <jacks2> dsal, is this a hypothetical question? I thought we were discussing actual library
16:34:19 <dsal> Heh, yeah, this is the actual library.  It has a sort of "not even wrong" answer.
16:35:11 <dsal> It's like, "that matches" vs. "that doesn't match" vs. "I'm offended you'd even ask about that"
16:35:54 <sm[m]> jacks2 it's a bit hard to keep track of all the different libs and which does what
16:36:37 <dsal> This was a few  years ago.  I probably didn't understand the whole problem.  The library I was using worked on String, and in retrospect, it was probably whatever was trying to make a String out of bytes or something.  I can't even compile the code now.
16:36:45 <sm[m]> mostly they offer a regex compile function which should let you detect malformed regexps. But it's not required, you can also use string literals. I think that's one way it happens
16:37:17 <dsal> Oh, you mean it's an `IsString`?
16:37:24 <dsal> That actually makes sense, then.
16:38:30 <dsal> `IsString` is intended to be used at compile time.  I mean, I abuse it in a few places, but it can't do much other than fail if the input isn't valid.
16:43:28 <Heffalump> is there a way to get cabal to run 'runghc', like it can run ghci with 'cabal v2-repl'?
16:46:07 <dmwit> cabal exec runghc
16:46:17 <sm[m]> investigating my nearest regex bug.. it seems I'm using https://hackage.haskell.org/package/regex-base-0.94.0.0/docs/Text-Regex-Base-RegexLike.html#v:makeRegexOptshttps://hackage.haskell.org/package/regex-base-0.94.0.0/docs/Text-Regex-Base-RegexLike.html#v:makeRegexOpts which calls error.. I should use makeRegexOptsM instead. But this requires MonadFail, which IIRC made it hard to use
16:46:26 <solonarv> dmwit: does that make sure dependencies are available?
16:46:43 <dmwit> I'm not sure.
16:46:54 <dmwit> It didn't used to. But it might now.
16:47:40 <dmwit> It used to be that cabal exec would look at the command you asked it to run and try to guess the right flags to pass to indicate a package database. I don't know if runghc was on the list of commands it knew how to construct that guess for.
16:48:07 <sm[m]> yes, I remember trying and failing to refactor this. Currently I do lots of regex operations in pure code, and I really wish this was an Either instead of a MonadFail
16:48:08 <dmwit> There was discussion at one point of setting an environment variable pointing at the package database -- so that, e.g., cabal exec my-fancy-script.sh could work appropriately -- but I don't know if that was ever done in the end.
16:48:37 <solonarv> if not, you can probably put together a wrapper script that runs 'cabal build --lib' / 'cabal build --deps-only' first, creating a ghc environment file, and then call runghc with that ghc environment file
16:51:32 <koz_> Upon further inspection, I think I _will_ need parser combinators. What's a lightweight one?
16:51:38 * sm[m] tries again.. it's probably as simple as converting it to Maybe. Just can't get a useful error message.
16:57:53 <raehik> In megaparsec, how can I make a parser not match on a given stream of tokens? I want to disallow certain keywords
16:58:27 <sm[m]> notFollowedBy I think
16:59:08 <raehik> I hoped so too, but notFollowedBy is for checking the next char
16:59:28 <wavemode> it can be used with any parser, no?
16:59:29 <raehik> I want to restrict a Parser String
16:59:34 <sm[m]> no, it takes any parser
16:59:51 <raehik> Oh, oops! You're right
17:00:04 <raehik> thanks, brainfart :)
17:00:05 <sm[m]> eg: notFollowedBy $ choice $ map (try . string) keywordslist
17:01:21 <dsal> koz_: I use attoparsec or megaparsec mostly
17:02:54 <dsal> Working with time is so great.
17:08:20 <sm[m]> now there's something we don't hear too often
17:11:08 <raehik> sm[m]: fantastic, that was basically the last part of my troubles. great fun using megaparsec so far
17:19:47 <sm[m]> raehik: congrats! megaparsec is awesome. Be aware that overuse of try can make your parser inefficient, I just showed it for robustness
17:20:41 <sm[m]> I guess there's a standard technique to get around that - parse any common prefix first, then a choice of the unique parts 
17:27:48 <koz_> If I do something like 'do d <- decimal; _ <- char '.'; dp1 <- digit', will this succeed on something like "100.1"?
17:30:15 <dsal> Kind of annoyed that registerDelay is in IO
17:30:15 <solonarv> yes, why wouldn't it?
17:30:26 <MarcelineVQ> which decimal?
17:30:33 <koz_> solonarv: Lol, I guess I'm not familiar with the sheer power of attoparsec.
17:30:47 <koz_> MarcelineVQ: http://hackage.haskell.org/package/attoparsec-0.13.2.4/docs/Data-Attoparsec-Text.html#v:decimal
17:32:29 <Axman6> (,) <$> decimal <*> "." *> digit
17:32:46 <dsal> "x" is a pretty great feature
17:32:46 <koz_> Axman6: Lol, I can also write in applicative style.
17:33:19 <dsal> Yeah, most of my parsers are a bunch of `"x" $> p` junk.
17:33:55 <dsal> attoparsec-applicative
17:36:36 <dsal> My brain is hurting trying to figure out how to handle this `registerDelay` problem.
17:37:16 <sm[m]> improved my bad regex errors at last. Thanks for the inspiration dsal! https://github.com/simonmichael/hledger/commit/3ef2fc9567089dad377afaa33176d9864584c2f0
17:37:32 <dsal> I need an STM transaction to figure out when my next work is available.  I'd like to block until a) that time b) something changes that might affect when that time is.
17:38:23 <dsal> error, but nicer error.  :)
17:39:38 <sm[m]> yeah! Though.. hmm.. not good enough for long running apps, eg the web/terminal uis
17:40:35 <sm[m]> much refactoring ahead
17:57:40 <koz_> Does 'decimal' not parse 0?
17:57:55 <sm[m]> Really a lot. Or maybe I could say: if your regexp is malformed it’ll just never match (and you’ll get a warning on street)
17:58:22 <sm[m]> on stderr
17:59:03 <monochrom> unsafePerformIO launchErrorOnStreet :)
17:59:04 <MarcelineVQ> koz_: from its definition it does
17:59:14 <koz_> MarcelineVQ: Yeah, agreed, which means my parser is off somewhere.
17:59:42 <koz_> What I have is basically 'Foo . (* 100) <$> decimal @Word64' to get my Parser Foo.
17:59:48 <koz_> Why would this miss?
18:00:37 <monochrom> Maybe some other parser or code ate your 0.
18:00:58 <koz_> choice [p1, p2] means 'try p1, then if that fails, try p2', right?
18:01:09 <koz_> I guess with only two choices, I could have spelled it p1 <|> p2.
18:01:31 <dsal> Note that attoparsec is try-by-default
18:01:57 <koz_> dsal: Meaning?
18:02:14 <dsal> Oh, just that you don't have to explicitly `try` anywhere.
18:02:15 <monochrom> I forgot whether attoparsec has backtracking choice or anti-backtracking choice.
18:02:25 <sm[m]> koz_: not exactly, if p1 partalially succeeds it doesn’t backtrack
18:02:35 <dsal> It does in attoparsec.
18:02:44 <monochrom> But this is something you should explicitly test for first, don't assume, don't even trust doc.
18:02:48 <sm[m]> That’s why I did map try
18:03:09 <dsal> Always believe me.  I'm never wrong.
18:03:12 <koz_> sm[m]: So how do I spell 'try p1, if that fails _backtrack_, then try p2'?
18:03:25 <dsal> `p1 <|> p2` should work in attoparsec.
18:03:26 <monochrom> Because I actually heard from here many years ago that the doc lied.
18:03:35 <monochrom> (or rather, not updated)
18:03:38 <dsal> Otherwise, `try p1 <|> p2`
18:03:54 <koz_> Ah.
18:04:03 <sm[m]> koz_: I use choice’ = choice . map try
18:05:57 <MarcelineVQ> "<koz_> What I have is basically 'Foo . (* 100) <$> decimal @Word64' to get my Parser Foo." what result did you end with?
18:06:19 <koz_> MarcelineVQ: If I feed it "0", I get 'Nothing' back.
18:06:25 <koz_> (using maybeResult)
18:06:50 <dsal> What if you just parse with decimal?
18:06:50 <monochrom> Hrm! Maybe it wants "0.0"
18:06:52 <MarcelineVQ> I don't think it failed then
18:06:58 <MarcelineVQ> it's probably a Partial result?
18:07:13 <koz_> MarcelineVQ: Why would that be partial?
18:07:18 <MarcelineVQ> does it work with parseOnly ?
18:07:42 * koz_ tries.
18:07:50 <dsal> Are you using parseOnly?
18:07:51 <dsal> oh, that
18:07:52 <MarcelineVQ> cause that's how attoparsec does things, though I know as much as you from this point on
18:08:51 <koz_> MarcelineVQ: OK, gonna try.
18:09:19 <koz_> MarcelineVQ: OK, parseOnly seems to fix that particular hiccup.
18:09:22 <dsal> I don't think you need try here
18:09:31 <koz_> dsal: Cut-down case.
18:09:38 <dsal> Well, if you're parsing literal strings, parseOnly is what you want.
18:09:46 <koz_> dsal: Good to know.
18:10:02 <koz_> (also, is there a more concise way to write 'either (const Nothing) pure'?
18:10:04 <MarcelineVQ> koz_: if you want to parse like you're used to you need to tell it the remaining input is empty, something like   feed (parse (many1 decimal) "10123") ""   it seems like
18:10:15 <koz_> MarcelineVQ: Or use parseOnly.
18:10:21 <MarcelineVQ> feed: "If a parser has returned a Partial result, supply it with more input."
18:10:29 <monochrom> @hoogle Either a b -> Maybe b
18:10:30 <lambdabot> Data.Either.Combinators rightToMaybe :: Either a b -> Maybe b
18:10:30 <lambdabot> Control.Error.Util hush :: Either a b -> Maybe b
18:10:30 <lambdabot> Data.Either.Extra eitherToMaybe :: Either a b -> Maybe b
18:10:43 <monochrom> one of those
18:10:47 <koz_> monochrom: Thanks.
18:10:54 <koz_> (lol @ 'hush')
18:11:21 <monochrom> all sound like adding one more dependency.  I would define it once myself.
18:11:32 <dsal> I looked that up the other direction earlier.
18:11:34 <koz_> Yeah, I probably will.
18:11:39 <dsal> I ended up writing my own and then not using that instead.
18:11:45 <koz_> dsal: The other direction meaning Maybe a -> Either () a?
18:11:50 <dsal> Yeah.
18:12:05 <dsal> Well, Either b a.
18:12:11 <dsal> :t maybeToRight
18:12:12 <lambdabot> error:
18:12:12 <lambdabot>     • Variable not in scope: maybeToRight
18:12:12 <lambdabot>     • Perhaps you meant ‘maybeToList’ (imported from Data.Maybe)
18:12:18 <dsal> It found one, anyway.
18:13:01 <MarcelineVQ> fromRight Nothing . fmap Just   if const bugs you :>
18:14:15 <koz_> dsal: What's 'b' supposed to be?
18:14:21 <koz_> Unless b is a Monoid.
18:14:38 <monochrom> No no.  What you need is: class (Monad m, Monad n) => MonadMorphism m n where monadmorphism :: m a -> n a
18:15:43 <monochrom> err no, probably just natural transformation
18:16:20 * MarcelineVQ hoists a foisted petard
18:20:27 <dsal> koz_: b is provided.
18:20:27 * sm[m] thought koz was using megaparsec
18:20:33 <dsal> @hoogle maybeToRight
18:20:33 <lambdabot> Data.Either.Combinators maybeToRight :: b -> Maybe a -> Either b a
18:20:33 <lambdabot> Protolude maybeToRight :: l -> Maybe r -> Either l r
18:20:33 <lambdabot> Protolude.Either maybeToRight :: l -> Maybe r -> Either l r
18:20:35 <koz_> If I wanna write x <> y, but x and y are Applicatives, I can do (<>) <$> x <*> y. What's the analog for x <> y <> z?
18:20:48 <koz_> sm[m]: Attoparsec. Should ahve been clearer, apologies.
18:21:07 <dsal> liftA3?
18:21:09 <Axman6> mconcat <$> sequence [x,y,z]?
18:21:37 <dsal> :t liftA3 (<>)
18:21:38 <lambdabot> (Applicative f, Semigroup d) => f (c -> d) -> f (c -> d) -> f c -> f d
18:21:55 <koz_> dsal: liftA3 is not what I seek I don't think.
18:22:03 <koz_> Axman6: that combo of mconcat and sequence really ought to exist.
18:22:05 <dsal> I'm not totally sure I understand what you're doing.
18:22:18 <koz_> dsal: Axman6 has the right of it.
18:22:40 <dsal> :t mconcat <$> sequence
18:22:42 <lambdabot> (Monoid (t a), Traversable t) => t [a] -> t a
18:23:21 <koz_> :t \x -> mconcat <$> sequence x
18:23:22 <lambdabot> (Monoid b, Monad f) => [f b] -> f b
18:23:29 <koz_> Not quite the same thing with that notation.
18:23:43 <koz_> (a partial application of that is not what you think)
18:23:59 <koz_> :t (mconcat <$>) . sequence
18:24:01 <lambdabot> (Monoid b, Monad f) => [f b] -> f b
18:24:04 <dsal> Thinking is super hard for me right now, so I'll believe you.
18:24:20 <koz_> :t (mconcat <$>) . sequenceA
18:24:21 <lambdabot> (Monoid b, Applicative f) => [f b] -> f b
18:24:30 <dsal> I'll get back to my problem I'm being dumb about.
18:25:39 <koz_> @hoogle (Monoid b, Applicative f) => [f b] -> f b
18:25:39 <lambdabot> Text.Pretty.Simple.Internal.OutputPrinter sequenceFold :: (Monad f, Monoid a, Traversable t) => t (f a) -> f a
18:25:39 <lambdabot> Linear.Vector sumV :: (Foldable f, Additive v, Num a) => f (v a) -> v a
18:26:26 <MarcelineVQ> :t getAp . foldMap Ap
18:26:28 <lambdabot> forall k (t :: * -> *) (f :: k -> *) (a :: k). (Foldable t, Monoid (Ap f a)) => t (f a) -> f a
18:26:46 <MarcelineVQ> these extras being on is a nuisance.
18:26:53 <MarcelineVQ> getAp . foldMap Ap :: (Foldable t, Applicative f, Monoid a) => t (f a) -> f a
18:27:06 <koz_> MarcelineVQ: You mean ala Ap foldMap amirite?
18:27:24 <MarcelineVQ> Not if you have some import phobia
18:28:38 <Axman6> koz_: yeah I've wanted it several times recently
18:30:19 <MarcelineVQ> but it's right there :O  Ap  is liftA2 (<>) x y
18:36:22 <solonarv> koz_: big brain solution: getAp (Ap x <> Ap y <> Ap z)
18:36:48 <koz_> solonarv: Lol.
18:36:56 <koz_> For galaxy brain, we need to make it pointfree.
18:37:08 <koz_> @pl \x y z -> getAp (Ap x <> Ap y <> Ap z)
18:37:08 <lambdabot> ((getAp .) .) . flip flip Ap . (((.) . (<>)) .) . (. Ap) . (<>) . Ap
18:37:57 <ratzes> I've been writing haskell for a very long time, but stumbled across something like: i = 2 :: Int, (Nothing :: Maybe i) == (Nothing :: Maybe Int), not only checks, but is true, when was this a thing?!?
18:38:11 <koz_> ratzes: Since forever I think?
18:38:28 <ratzes> thats crazy, i've never seen it mentioned anywhere
18:38:37 <koz_> The only thing that's a bit newer is stuff like 'do x :: Int <- somePolything', which needs ScopedTypeVariables on.
18:38:57 <solonarv> ratzes: note that the 'i = 2 :: Int' part doesn't actually do anything there.
18:39:27 <ratzes> yeah, ive been using scopedtypevariables in probably so many places it wasn't necessary
18:39:42 <ratzes> solonarv: ?
18:40:05 <koz_> solonarv: I believe it does? 2 :: (Num a) => a in the most general case.
18:41:56 <ratzes> solornarv: I think you're right...
18:42:12 <ratzes> solonarv:...
18:45:36 <solonarv> koz_: well yes, but 'i' is redundant
18:45:55 <koz_> solonarv: Fair.
18:45:59 <solonarv> the 'i' in ':: Maybe i' is completely unrelated to the 'i' in 'i = ...'
18:49:20 <ratzes> Oh, now I understand what happened, I was writing something last night, i used a variable, thought I had a forall in the main function, but the variable wasn't present and it still compiled fine
18:49:31 <monochrom> The main confusion is due to most people's wrong assumption that "e :: T" is "type casting", "type coercion", or the like from other languages that have absolutely no analogy with Haskell.
18:49:59 <ratzes> for ScopedTypeVariables, didn't realize it stayed a generic type variable
18:50:16 <ratzes> removed the type cast and everything works
18:50:47 <monochrom> The correct meaning of "e :: T" is at most type specialization.  And type inference reserves the right to do further type specialization than what T says.
18:51:37 <ratzes> monochrom: yeah, i should probably stop referring to it as a type cast in my head.
18:51:53 <monochrom> Also keep in mind ":: Maybe a" means ":: forall a. Maybe a"
18:52:05 <monochrom> (unless ScopedTypeVariable)
18:53:22 <monochrom> As another example, "(3 :: forall a. Num a => a) == (3 :: Integer)"  type inference will narrow it down to ((3 :: forall a. Num a => a) :: Integer) == (3 :: Integer)" resistance is futile.
18:53:49 * hackage little-rio 0.1.0 - When you need just the RIO monad  https://hackage.haskell.org/package/little-rio-0.1.0 (ejconlon)
18:54:49 * hackage little-logger 0.1.0 - Basic logging based on co-log  https://hackage.haskell.org/package/little-logger-0.1.0 (ejconlon)
18:54:55 <monochrom> Whenever you write "Nothing", it's already forall a. Maybe a to start with.  Whenver you write "3", it's already forall a. Num a => a to start with.  Adding the same polymorphic type ascription doesn't do anything.
18:54:57 <ratzes> i never really explored this much, but if i do let x = (3 :: forall a. Num a => a), does that mean x == (3 :: Integer) and x == (3 :: Float) will both be true and typecheck in the same scope?
18:55:18 <solonarv> why don't you try it?
18:55:27 <ratzes> yeah, was just going to say...
18:55:30 <monochrom> That one runs into the monomorphic restriction.
18:57:18 <wavemode> you constrain `a` to be general, but it is still determined at compile time to be one specific type. it can't also be another
18:58:02 <jchia> What is the documentation for the decompress function really saying? https://hackage.haskell.org/package/bz2-1.0.0.2/docs/Codec-Compression-BZip.html#v:decompress
18:58:15 <ratzes> hmm, it doesnt give the monomorphism restriction, but it does say "Couldn't match expected type ‘Int’ with actual type ‘Float’"
18:58:17 <jchia> To me it reads like "don't call this function"
18:58:27 <monochrom> What you should test is "x = ([] :: [a])" and then see that True:x and 'c':x both make sense, showing that x stays polymorphic.
18:58:40 <monochrom> However like I said "[] :: [a]" means "[]" no more no less.
18:59:22 <monochrom> What you should also test that "x = (3 :: Num a => a)" and "x = 3" behave the same too.  Both are ruined by the monomorphism restriction.
19:00:21 <monochrom> "Couldn't match expected type ‘Int’ with actual type ‘Float’" means monomorphism restriction.
19:00:32 <ratzes> gotcha
19:01:36 <ratzes> so I think ive been able to pass a function in that's (forall a. Something a => a -> b) and call it for different a, does that sound right?
19:07:04 <wavemode> jchia: i believe "pathological" means "near-worst-case performance"
19:07:24 <wavemode> the man page for bzip says: "The sorting phase of compression gathers together similar strings in the file. Because of this, files containing very long runs of repeated symbols, like "aabaabaabaab ..." (repeated several hundred  times) may compress extraordinarily slowly."
19:07:27 <jchia> wavemode: I thought pathological means maliciously-crafted
19:07:55 <wavemode> "...Such pathological cases seem rare in practice."
19:07:57 <jchia> but being very slow is not the same as being insecure, is it?
19:08:15 <monochrom> shake hands and agree to combine to "maliciously crafted to force worst-case performance" :)
19:08:30 <jchia> the man page itself does not mention security or insecurity
19:08:48 <monochrom> being malicious does not mean violating privacy either
19:09:13 <wavemode> you know of denial-of-service attack? someone who knows you're using bzip could send you data that is crafted to slow down your server
19:09:14 <jchia> sure, malicious could also mean trying to slow you down
19:09:40 <jchia> i would just let the computation time out
19:09:43 <monochrom> what you can do is broaden "security" to include "DoS" so that slowness counts as "vulnerability".
19:09:57 <monochrom> This is what's wrong with the whole "computer security" notion.
19:09:58 <jchia> with the other kind of insecurity, there's not much i can do
19:10:06 <jchia> the knid that compromises information
19:10:56 <Axman6> path traversals are probably the biggest risk for decompression utilities
19:11:23 <wavemode> well, the function is question is just ByteString -> ByteString
19:11:48 <Axman6> if I send you something with a file with paht "../../../../../../../ets/ssh/sshd_config" and you run as root then I'm going to have a good time
19:12:08 <Axman6> ah I missed the initial context
19:12:49 <Axman6> I wonder if what it's referring to is maliciously constrcuted, invalid bz2 data may acess memory it shoudnt'
19:13:05 <jchia> that's the first thought i had
19:13:16 <monochrom> maliciously constructed to make bzip2 run slow
19:13:32 <jchia> The doc doesn't clarify whether it's the DDOS kind of insecurity or the information-compromise kind of insecurity
19:13:49 * hackage infernal 0.5.0 - The Infernal Machine - An AWS Lambda Custom Runtime for Haskell  https://hackage.haskell.org/package/infernal-0.5.0 (ejconlon)
19:16:25 <wavemode> well then you should ask vanessa mchale :) though to be fair this is just an ffi call, you should really ask the libbz2 devs
19:18:11 <Axman6> She's been doing some really cool compression stuff lately. her sak tool looks really useful
20:08:19 * hackage earcut 0.1.0.1 - Binding to C++ earcut library.  https://hackage.haskell.org/package/earcut-0.1.0.1 (DavidHimmelstrup)
20:21:20 * hackage tokyocabinet-haskell 0.0.6 - Haskell binding of Tokyo Cabinet  https://hackage.haskell.org/package/tokyocabinet-haskell-0.0.6 (StephenWeber)
20:23:43 <dsal> The secret to success for my STM junk was to allow for spurious wakeups.  Get state/set timeout.  block is basically  (check =<< readTVar timedOut) `orElse` (check =<< (/= state) . readState)
20:23:54 <dsal> (not actual code, but something like that).
20:24:44 <dsal> It's not *that* many spurious wakeups, but trying to be price in an STM transaction and also dealing with side effects is too much when it doesn't actually matter because the part where I do the work I blocked for won't do work that's not ready anyway.
20:28:18 <dmj`> Is there a way, just using GHC.Generics, to reify a list of constructors using just a sum type declaration
20:28:39 <dmj`> data StopLight = Red | Yellow | Green deriving (Generic)
20:28:56 <dmj`> lights :: [StopLight] = gToStopLightCons (Proxy @ (Rep StopLight))
20:29:00 <dmj`> ^ is this possible?
20:29:10 <dmj`> lights == [Red, Yellow, Green]
20:29:26 <dsal> aeson does that, doesn't it?
20:29:41 <dmj`> dsal: it does not
20:30:09 <monochrom> seems easier to deriving (Enum, Bounded) and [minBound .. ]
20:30:29 <dmj`> monochrom: I knew somebody was going to bring that up :) but let's suppose that's not what I'm after
20:30:39 <monochrom> or just Enum and [ toEnum 0 .. ]
20:30:52 <dmj`> assume deriving (Generic) only
20:31:21 <monochrom> I think yes but I haven't tried.
20:32:56 <monochrom> orElse is the best thing since transaction.
20:35:24 <dmj`> monochrom: I don't think it's possible
20:44:19 <dmj`> :t to
20:44:21 <lambdabot> (Profunctor p, Contravariant f) => (s -> a) -> Optic' p f s a
20:55:00 <dmj`> monochrom: if you can, you'd need to know the Generic Rep of the list type you're converting into
20:55:09 <dmj`> and a way to go from one to the other
21:07:24 <dmwit> dmj`: The universe package offers that.
21:08:46 <dmj`> dmwit: woa
21:09:02 <dmwit> http://hackage.haskell.org/package/universe-base-1.1.1/docs/Data-Universe-Generic.html#v:universeGeneric
21:10:16 <shachaf> "Creating an instance of this class is a declaration that your type is recursively enumerable (and that universe is that enumeration)."
21:10:32 <shachaf> I'm not so sure about the third "that" there.
21:10:42 <iqubic> Here's a really really bad way to get a list of 5 zeros:
21:10:50 <iqubic> % [NoGCStats..] $> 0
21:10:50 <yahb> iqubic: ; <interactive>:26:13: error: parse error on input `]'
21:11:39 <dmwit> shachaf: It's correct if you work in an intuitionistic logic where a declaration of an existential is a witness.
21:12:02 <dmj`> dmwit: this is black magic
21:13:05 <dmwit> % [NoGCStats ..] $> 0
21:13:05 <yahb> dmwit: ; <interactive>:27:2: error: Data constructor not in scope: NoGCStats
22:01:49 * hackage json-api-lib 0.2.1.0 - Utilities for generating JSON-API payloads  https://hackage.haskell.org/package/json-api-lib-0.2.1.0 (shirren)
22:05:10 <slack1256> Is there an use for (co)-limits on haskell? I know that terminal and initial objects can be seen as limits, but apart from that?
22:09:17 <dmj`> If only there was a way to generic diff two different generic reps to convert one into the other, we could generically convert anything into anything else
22:10:16 <pgiarrusso> Add products and sums (especially in ideal Hask), but not (easily) equalizers/pullbacks, slack1256
22:11:34 <dmj`> equalizers/pullbacks ?
22:17:22 <slack1256> I only know pullback from when I studied covering spaces.
22:26:36 <dmj`> (Generic a, Generic b) => a -> b
22:26:39 <dmj`> I want this function
22:30:22 <dmj`> "safer than an unsafeCoerce, more flexible than a coerce"
22:32:06 <Axman6> not even a -> Maybe b?
22:32:29 <dmj`> convert :: Generic a => Generic b => a -> b; convert = to . magic . from
22:36:42 <wavemode_> how about I skip the middleman and let magic solve all my problems
22:36:46 <wavemode_> main = magic
22:40:15 <dmj`> wavemode_: that's cheating
22:42:55 * hackage servant-docs-simple 0.2.0.1 - Generate endpoints overview for Servant API  https://hackage.haskell.org/package/servant-docs-simple-0.2.0.1 (HolmuskTechTeam)
22:44:08 <iqubic> :t magic
22:44:10 <lambdabot> error: Variable not in scope: magic
22:44:17 <iqubic> % :t magic
22:44:18 <yahb> iqubic: ; <interactive>:1:1: error: Variable not in scope: magic
22:46:07 <jonathan_> hi
22:46:11 <jonathan_> testing
22:46:25 <Axman6> this is not a channel for testing things
22:46:55 <dsal> @check \x -> x == "test"
22:46:58 <lambdabot>  *** Failed! Falsifiable (after 1 test):
22:46:58 <lambdabot>  ""
22:47:12 <Axman6> so much failure
22:48:19 * hackage plzwrk 0.0.0.6 - A front-end framework  https://hackage.haskell.org/package/plzwrk-0.0.0.6 (mikesol)
22:48:59 <koz_> dmj`: What you're really asking for is a function of type forall a b . Rep a -> Rep b.
22:49:11 <dmj`> koz_: yep
22:49:19 <dmj`> koz_: can we gdiff that :)
22:49:19 <koz_> dmj`: I am unsure if such a thing is generally possible.
22:50:26 <int-e> @check (/= "test")
22:50:32 <lambdabot>  +++ OK, passed 100 tests.
22:50:45 <dmj`> koz_: there would need to be like a closed type family diff on the reps
22:52:21 <dmj`> but the type level diff would compare every type in GHC.Generics against itself
23:13:09 <phadej> dmj`: https://hackage.haskell.org/package/recursion-schemes-5.1.3/docs/src/Data.Functor.Foldable.html#GCoerce
23:13:36 <phadej> it's not re-exported, but there is Rep a -> Rep b function when reps are "same enough"
23:17:41 <dmj`> yea, that's exactly what I'm looking for. GCoerce looks nice
23:28:05 <dmj`> phadej: does this actually let you do better than just using coerce
23:31:44 <dmj`> I guess if the two foldable's have equivalent Rep
23:32:39 <dmj`> coerce enforces runtime representational equality, so you wouldn't need that guarantee on the Foldable if you used GCoerce, just on the inner a
23:38:50 * hackage plzwrk 0.0.0.7 - A front-end framework  https://hackage.haskell.org/package/plzwrk-0.0.0.7 (mikesol)
23:39:39 <phadej> dmj`: yes an no. `coerce` can go from `ZipList (Down Int)` to `Int`, GCoerce cannot (as it's not "recursive")
23:39:55 <phadej> to `[Int]` *
