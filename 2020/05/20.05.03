00:01:10 <siraben> koz_: Which talk by Edward Kmett?
00:01:39 <siraben> I'm guessing this one; https://www.youtube.com/watch?v=KzqNQMpRbac
00:06:08 <siraben> That paper by Oleg on semantic translation to lambda calculus is great, anyone know of a translation of the OCaml code in the paper to Haskell?
00:07:37 <siraben> It's at the core of Ben Lynn's Haskell compiler, https://github.com/blynn/compiler/blob/master/effectively.hs#L372-L432 , although it's a little obfuscated vs. a tagless-final presentation.
00:46:42 <p0a> any good libraries for graph visualization?
00:46:53 <p0a> Or at least basic drawing capabilities, I can probably visualize the graphs myself 
00:48:54 <rsoeldner> p0a, https://hackage.haskell.org/package/graphviz 
00:52:59 <p0a> rsoeldner: thank you 
00:53:42 <p0a> rsoeldner: unfortunately graphviz forces a layout, do you know if custom layouts are possible? I think I need to have my own drawing really
01:01:04 <koz_> p0a: Yes, but it's very obnoxious.
01:01:14 * hackage hw-json-standard-cursor 0.2.3.0 - Memory efficient JSON parser  https://hackage.haskell.org/package/hw-json-standard-cursor-0.2.3.0 (haskellworks)
01:01:53 <p0a> koz_: another option is ouputting textual data that I convert to an image with a bash script
01:01:55 <p0a> so no big deal
01:02:34 <koz_> p0a: Yeah, that's the obnoxious option, except s/textual data/graphvis's internal rep/ and s/with a bash script/with a graphviz renderer you wrote/
01:03:18 <p0a> gotcha didnt know you can do that 
01:03:29 <koz_> p0a: You can write graphviz formatters just fine.
01:03:35 <koz_> It involves learning the library.
01:03:38 <koz_> Which I don't recommend.
01:03:45 <p0a> the C library right
01:04:18 <koz_> p0a: Yup.
01:12:39 <koz_> @pl \f x y -> f y x
01:12:39 <lambdabot> flip
01:12:55 <koz_> OK, so C is indeed flip.
01:53:25 <p0a> I want to write a function
01:53:33 <p0a> that lets me map over all k-combinations of n items
01:53:39 <p0a> What should its type be?
01:54:04 <p0a> as a first idea I can do Int -> [a] -> [[a]] that returns all k-sublists of the argument
01:55:25 <koz_> So you want something like ([a] -> b) -> [a] -> ???
01:55:39 <koz_> Well, sorry, there's a missing Int in there.
01:56:10 <koz_> Int -> ([a] -> b) -> [a] -> ???
01:56:17 <koz_> What should ??? be in your formulation?
01:56:57 <p0a> I have two different ideas in mind
01:57:03 <p0a> 1) Get all k-combinations of an n-sized list
01:57:11 <p0a> 2) Or map over all k-combinations of an n-sized list
01:57:17 <p0a> I think a list may be generalized to something else. Not sure what
01:57:27 <koz_> p0a: Set is an obvious choice.
01:57:32 <p0a> Int -> ([a] -> b) -> [a] -> [b]
01:57:45 <p0a> Isn't both Set and List instances of the same thing?
01:57:55 <koz_> Very much not.
01:58:00 <p0a> okay
01:58:12 <koz_> Sets have unique elements under (==), lists don't.
01:58:31 <koz_> (and that's purely an idealized view - there are implementation and performance differences to account for)
01:58:40 <koz_> Also, if you can do 1), you can do 2).
01:58:41 <p0a> exactly
01:59:12 <p0a> there's a trick called Gosper's hack I learned recently
01:59:49 <p0a> where you take 00011 and produce all permutations (in order) and obtain all 2-selections of a 5-list for example. Notice the list needs to be indexed
02:00:06 <p0a> i.e. 00011 corresponds to [0,1] indices, 00101 to [0,2] etc
02:00:48 <koz_> p0a: That works, but it's _grossly_ inefficient.
02:01:11 <koz_> Even if you have an efficient way to enumerate said permutations, slicing lists according to them is linear _per permutation_.
02:01:24 <p0a> Yeah I agree, so you'd use a vector
02:01:26 <koz_> So you're literally in O(N choose K * N) land.
02:01:30 <p0a> hehe
02:01:34 <koz_> Wouldn't make a difference.
02:01:43 <koz_> You have discontinuous subsets.
02:01:53 <koz_> You can't take slices.
02:01:57 <koz_> So you're copying each time.
02:02:09 <koz_> So you've gone from O(N choose K * N) to O(N choose K * K)
02:02:14 <koz_> An improvement, sure, but still gory.
02:02:41 <p0a> well it's going to be at least N choose K no matter what
02:02:57 <koz_> Agreed.
02:03:03 <koz_> Maths says so. :P
02:03:24 <koz_> This is where Richard Bird would go something like
02:03:25 <p0a> so how did I do it in C++
02:03:49 <p0a> Yeah I used next_permutation to produce the next from the string "00011", then found the right indices (by transversing that string) and... yah
02:03:53 <koz_> 'By appealing to the fold law and using divide and conquer [17 pages of Haskell equivalences later] solution!'.
02:04:13 <koz_> p0a: So basically, you did an O(N choose K * N). :P
02:04:45 <koz_> There is a way it can be done faster, assuming we go for option 2 and your operation is a monoidal fold.
02:04:52 <koz_> That would get you O(N choose K * K).
02:05:09 <p0a> okay
02:05:22 <koz_> You can't really go lower than this unless you can collapse K elements in better than O(K).
02:06:03 <koz_> So that would give you the type
02:06:31 <koz_> (Monoid b) => Int -> (a -> b) -> [a] -> [b]
02:06:54 <koz_> Probbo can be weakened to Semigroup, unless we allow 0-combinations or something stupid like that.
02:07:12 <koz_> Also, to clarify - by 'combinations' do you mean 'allowing repeats'?
02:07:27 <p0a> well that's a good question
02:07:36 <p0a> it's a nonissue with Set, and a nonissue with the problem I'm trying to solve
02:07:47 <koz_> Then it's permutations, not combinations.
02:07:53 <koz_> My analysis kind of assumed that, so I wanted to check.
02:07:54 <p0a> ah okay
02:08:52 <p0a> how would you do it
02:08:58 <koz_> Now that I think about it, I'm not sure O(N choose K * K) is achievable either.
02:08:59 <p0a> I was going to use Gosper's hack in some form or another
02:09:24 <koz_> OK, so let's suppose you're working with Set (namely we have an order).
02:09:39 <koz_> We can represent a subset of that as a bitstring of length N, with set bits corresponding to included elements.
02:10:13 <koz_> So we basically want to enumerate all bitstrings of length N with exactly K set bits.
02:10:25 <koz_> A simple loopfree algorithm handles those in O(N choose K).
02:11:07 <koz_> Now, my idea was that each one acts as a mask on the resulting set, but then I figured out that to apply it has a cost of O(N) irrespective of representation.
02:12:17 <koz_> But the idea is that you essentially do a zip followed by a foldMap into your monoid, turning any element corresponding to a 0 into mempty and any element corresponding to a 1 into a Monoid value using the given function.
02:12:28 <koz_> So you just do that over and over, and emit what you get one at a time.
02:12:40 <p0a> nice
02:12:41 <koz_> The result _has_ to be some kind of ordered collection permitting duplicates, as we can't ensure uniqueness.
02:12:48 <koz_> This is O(N choose K * N).
02:12:53 <koz_> I'm not sure you can do it any faster.
02:13:08 <p0a> so the thing is that is roughly N^(K+1) I believe
02:13:22 <p0a> so for any sizable choice of K, it is roughly the same
02:13:30 <p0a> which is to say, terrible unless K is small
02:13:55 <p0a> of course saving +1 would be awesome
02:13:59 <koz_> Welcome to combinatorics.
02:14:04 <p0a> hahah
02:14:10 <koz_> You'll _pray_ for exponential complexity. :P
02:14:22 <p0a> 2030: please let it be e^e^x
02:14:26 <koz_> And it's actually worse than this.
02:14:38 <koz_> N choose K is n!/(n - k)!
02:14:51 <koz_> That's _much_ worse than N^(K + c) I believe.
02:15:29 <koz_> Are you _certain_ there's no way to do what you want in a less scary way?
02:15:47 <p0a> Well I thought about it a few days ago and then googled it because I gave up
02:15:55 <koz_> Well, what's the actual task?
02:15:57 <p0a> then saw Gosper's hack from 1970 or something and was enlightened
02:16:12 <p0a> I have a graph on a grid
02:16:23 <p0a> I want to choose k rows and k columns and take a subgraph
02:16:29 <p0a> but all subgraphs, I am checking a property
02:16:33 <p0a> for all*
02:16:48 <koz_> What do you mean by a 'graph on a grid' in this case?
02:17:03 <p0a> A grid is a NxN set of points in row-column manner
02:17:09 <koz_> Ah, right.
02:17:14 <p0a> and a grad is just undirected edges between these points
02:17:16 <p0a> grpah*
02:17:30 <koz_> I guess the grid doesn't wrap around?
02:17:34 <p0a> it does !
02:17:42 <koz_> So you have a sphere. :P
02:17:54 <koz_> And every graph node has degree 4.
02:18:08 <p0a> Actually those are not real edges you think of
02:18:13 <p0a> the edges are diagonal
02:18:33 <p0a> well ok basically I have 2 colors on the edges, black and white
02:18:36 <koz_> Sure, but every vertex of this graph has degree 4 right?
02:18:43 <p0a> and the vertical/horizontal edges are white so I don't care about them
02:18:49 <koz_> Just wanna make sure I understand correctly.
02:18:57 <p0a> the diagonal black edges are the ones I care about
02:19:03 <koz_> Yep, got it.
02:19:06 <p0a> the horizontal/vertical edges can be ignored. Degrees are arbitrary
02:19:29 <koz_> Well, if it's a 2D grid, and diagonals form edges, degrees are _not_ arbitrary.
02:19:41 <koz_> If you wrap around, and every grid cell is a vertex, you have a uniform degree 4 everywhere.
02:19:52 <p0a> not all edges are present however
02:19:58 <koz_> Ah, OK.
02:20:00 <p0a> and not all edges are 1-unit long
02:20:02 <koz_> So we have a _maximum_ degree 4.
02:20:12 <koz_> Do we assume that the graph is connected?
02:20:22 <p0a> I don't know
02:20:27 <p0a> :P it's a bit exploratory
02:20:32 <koz_> So can we have vertices with _no_ edges?
02:20:41 <p0a> no there's no isolated ones
02:20:45 * hackage ipython-kernel 0.10.2.0 - A library for creating kernels for IPython frontends  https://hackage.haskell.org/package/ipython-kernel-0.10.2.0 (VaibhavSagar)
02:20:50 <koz_> OK, so that means we have a range of degrees from 1 to 4.
02:21:06 <koz_> And so you pick a k by k subpart of the grid.
02:21:14 <koz_> And take the induced subgraph on those vertices.
02:21:16 <koz_> Right?
02:21:18 <p0a> yeah 
02:21:26 <koz_> OK.
02:21:39 <koz_> So you've got this - what are you trying to test?
02:21:45 * hackage ihaskell 0.10.1.0, ghc-parser 0.2.2.0 (VaibhavSagar): https://qbin.io/lo-hh-b4v5
02:22:25 <koz_> Or discover or w/e.
02:22:27 <p0a> i'm trying to exclude certain subgraphs
02:22:36 <koz_> Subgraphs of that k x k thing?
02:22:37 <p0a> if a bad subgraph is present, the entire graph is bad
02:22:41 <koz_> Ah, I see.
02:22:45 <p0a> no kxk is the subgraph
02:23:02 <koz_> OK, so basically you need to check _every_ k x k subgraph for said property?
02:23:06 <p0a> yeah
02:23:15 <koz_> And all we know structurally is what I've described
02:23:17 <koz_> ?*
02:23:17 <lambdabot> Maybe you meant: v @ ? .
02:23:27 <p0a> yeah I believe so
02:23:30 <koz_> Hmm.
02:23:43 <koz_> Is the property you're trying to test elusive?
02:23:53 <koz_> (in the sense that we must examine every vertex of the subgraph to check it)
02:24:11 <p0a> yeah
02:24:43 <koz_> OK, so one thing I can immediately observe is that, according to your description, 'gridding' in this manner won't necessarily produce a connected subgraph.
02:25:02 <koz_> Since you may end up having to 'cut away' a part of the graph which isn't connected to the rest of the subgrid.
02:26:08 <p0a> right
02:26:18 <p0a> your'e saying the k choices need to be continuous?
02:26:37 <p0a> I think so right?
02:26:40 <koz_> I'm saying that, if I understnad you correctly, the subgraph construction you're describing won't necessarily produce _one_ graph.
02:26:48 <p0a> yeah
02:27:07 <koz_> Now, by 'every' k by k subgraph, you're not describing a tiling?
02:27:09 <Athas> Is there a faster random number generator than System.Random?
02:27:11 <koz_> You're describing a stencilling?
02:27:17 <koz_> Athas: mwc-random's plenty fast.
02:27:29 <p0a> I am not familiar with stencils
02:27:43 <koz_> p0a: A tiling means that any vertex belongs to at most one subgraph.
02:28:05 <Athas> koz_: hm.  And it doesn't even look like it has too much of a dependency footprint!
02:28:08 <koz_> Basically, are you slicing your grid up into k by k tiles?
02:28:25 <koz_> Or are you taking _every possible_ k x k stencil, even though they might overlap with each other?
02:29:03 <koz_> Athas: It's pretty good.
02:29:16 <p0a> oh yeah, every k by k stencil 
02:29:27 <p0a> overlap allowed
02:29:30 <koz_> Well, I have _one_ good news: your problem is embarassingly parallel.
02:29:42 <koz_> So embarassingly in fact that you could probably ram it through a GPU.
02:29:52 <Athas> koz_: I'm a little concerned about the giant state (that tends to be slow), but I guess I'll see.
02:30:08 <koz_> Athas: I haven't benchmarked, so I can't really say.
02:30:38 <koz_> If you want small state, I'd just port one of these: http://prng.di.unimi.it/
02:30:44 * hackage zeolite-lang 0.2.0.0 - Zeolite is a statically-typed, general-purpose programming language.  https://hackage.haskell.org/package/zeolite-lang-0.2.0.0 (ta0kira)
02:30:46 <p0a> ah nice koz_ 
02:30:49 <koz_> They have good (and _tested_) statistical properties and quite small states.
02:30:50 <p0a> that is a very good observation
02:31:05 <p0a> thanks 
02:31:10 <koz_> Let me drag you out a reference.
02:31:24 <koz_> p0a: I was an algorithm researcher in a past life.
02:31:51 <p0a> aah and so it shows
02:32:08 <koz_> https://en.wikipedia.org/wiki/Stencil_code
02:32:24 <koz_> And just your luck, massiv (the library) supports stencilling.
02:32:31 <koz_> It even supports array wrap-around.
02:32:36 <Athas> koz_: I have written enough fast RNGs in my life, so I'm reluctant to write another.  I can live with my current performance, but it'd be great if there was already a Haskell library that was a little faster.  I think I will try out mwc-random first.
02:32:41 <koz_> As well as efficient parallel scheduling.
02:32:50 <koz_> Athas: You'll probably find it quite fast enough, I suspect.
02:33:10 <koz_> Whether you can ram it through a GPU depends on what the subgraph property is and how it can be tested.
02:33:23 <koz_> Basically, your representation would be a 2D array.
02:33:32 <koz_> Full of numbers, which indicate what they're connected to.
02:33:45 <p0a> wow
02:33:46 <p0a> alright
02:33:55 <p0a> got some learning to be doing
02:33:58 <koz_> You basically have several possibilities: 1 edge, 2 edge, 3 edge, 4 edge.
02:34:04 <koz_> 1 edge has four options.
02:34:18 <koz_> 2 edge would have 4 choose 2 options.
02:34:20 <koz_> Etc.
02:34:28 <koz_> Sum them up, that's the limit of values.
02:34:35 <koz_> Then stencil aggressively.
02:34:44 <koz_> And get yourself a ThreadRipper or something. :P
02:35:07 <koz_> You can _easily_ jam that into Words.
02:35:11 <koz_> Which means you can unbox too.
02:35:55 <koz_> http://hackage.haskell.org/package/massiv <-- use this library here
02:38:30 <koz_> Rofl, you don't even need Words - Word8s would do.
02:41:47 <koz_> (there's only 15 edge options)
02:42:31 <Athas> Then you can pack 2x2 cells in a single Word32.
02:44:31 <koz_> Athas: You can, but you probably don't want to.
02:44:38 <koz_> it destroys the stencilling.
02:44:59 <koz_> You could also use that extra space to give you loop-free subgraphing on the edges of the k x k tile I think.
02:45:12 <koz_> Though the exact data layout would require me breaking out my whiteboard and drawing on it for an hour. :P
02:45:21 <p0a> haha
02:45:31 <koz_> Also, p0a - thank you for asking such an awesome question.
02:46:00 <p0a> oh no problem I'm glad you liked it
02:46:09 <koz_> Anyway, think you've got enough to proceed?
02:46:11 <p0a> I'm working on it a while
02:46:14 <p0a> yeah
02:46:24 <koz_> Let me know if you want more help - you've got my attention and interest.
02:46:25 <Athas> Oooh: https://hackage.haskell.org/package/pcg-random
02:46:33 <Athas> I really like the PCG series.  I guess that is what I should use.
02:46:37 <p0a> sure, thanks
02:46:41 <koz_> Athas: Oh, nice! Didn't know that existed.
02:47:21 <koz_> p0a: Out of curiousity, how big are N and K roughly?
02:48:45 <p0a> koz_: 
02:48:52 <p0a> right now N is 4 or 5 and K in between 
02:48:54 <p0a> lol
02:49:04 <p0a> I mean, that's the kind of stuff I've managed to solve in C++ on a crappy computer
02:49:07 <koz_> Wow, I was thinking we're talking like, N = 1000 or so.
02:49:28 <koz_> Or 10,000.
02:49:42 <p0a> those sound like really big numbers to me
02:50:02 <koz_> p0a: You're talking to a guy who had to grind 3 years of NASA satellite data for a research project.
02:50:08 <p0a> havent' ever done muc concurrent stuff
02:50:16 <koz_> That took _overnight_ jobs.
02:50:21 <p0a> oh yikes
02:50:22 <p0a> lol :D
02:50:32 <koz_> (and yes, I parallelized the hell out of it)
02:50:44 <p0a> thats awesome
02:50:48 <koz_> p0a: massiv makes array parallelism _very_ easy.
02:50:59 <p0a> but what is array paralellism?
02:51:03 <p0a> sorry this is a stupid question but I am not sure what that means
02:51:10 <koz_> Using parallel processing to grind arrays.
02:51:19 <koz_> Arrays as structures lend themselves quite naturally to this.
02:51:24 <koz_> Stencilling is an example of that.
02:51:27 <p0a> i.e. create arrays, manipulate them, etc right
02:51:32 <koz_> Yep.
02:52:15 <Athas> Yesterday I managed to make my Haskell program 30% faster by adding -H1G -A4M to the default RTS options.
02:52:31 <Athas> I wonder what the defaults are tuned for.
02:52:44 <koz_> Athas: No idea - I've never had to do that kind of thing yet.
02:53:01 <koz_> (mostly because many of my problems are either trivial or embarassingly parallel, it seems)
02:53:24 <Athas> Yes, but the -A4M stuff really helps parallelism I think, because it reduces the number of garbage collections (GHCs parallel GC isn't great).
02:53:53 <Athas> It does mean that each individual GC becomes longer, but my program isn't interactive, so latency doesn't matter.
02:54:02 <koz_> Athas: Good to know.
02:57:50 <merijn> GHC parallel GC is downright *terrible* for 90% of all workloads
02:57:56 <xsperry> hi. is anyone using Scotty webserver? running `scotty 3000', when that port is already locked, succeeds without any errors. I'd like to throw an exception instead. would using other scotty* functions with certain options do that, or do I have to manually check if the port is locked?
02:58:20 <merijn> There's a reason why the GHC proposal that suggests making -threaded the default RTS also plans to disable the parallel GC by default in the threaded RTS
02:58:38 <Athas> Yes, my default RTS options also disable the parallel GC entirely.
02:59:04 <koz_> merijn: What proposal is this?
02:59:06 <merijn> koz_: In my data processing pipeline disabling parallel GC gave me a 20x speedup
02:59:15 <koz_> merijn: Woah.
02:59:19 <tobiasBora> Hello,
02:59:22 <koz_> OK, _definitely_ got my attention.
02:59:28 <koz_> How do I disable the parallel GC?
02:59:39 <merijn> koz_: https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0240-threaded-by-default.rst
03:00:01 <merijn> koz_: "+RTS -qg"
03:00:12 <koz_> merijn: Thanks!
03:00:15 <merijn> koz_: (or -with-rtsopts=-qg to set it at compile time)
03:00:50 <JohnnyL> merijn: is that name of yours a script version of 'merlin'?
03:01:15 <merijn> koz_: It depends on how many capabilities you spawn, I use quite a few, which means quite a bit of locking so like 90% of GC is spend on synchronising between capabilities
03:01:34 <merijn> koz_: Without paralle GC there's obvious no locking, so that all goes
03:01:47 <Athas> Parallel GC is a cache saboteur.
03:01:57 <xsperry> googling a bit, it seems that this behavior is intentional. "2  This occurs because the Data.Streaming.Network library used by scotty (well, by warp, which is used by scotty) acquires a list of possible addresses which spans both IPv4 and IPv6 then tries to bind to ports on each of these addresses one at a time, discarding any IO exceptions."
03:02:00 <koz_> Athas: Lol @ 'cache sabouteur'.
03:02:25 <merijn> koz_: The idea behind the parallel GC is that, since GHC uses a copying collector, if your liveset is huge then copying in parallel can speed it up
03:02:52 <merijn> koz_: But a lot of Haskell programs don't have huge livesets and you waste more time locking then you gain speeding up
03:03:26 <merijn> JohnnyL: Nope
03:03:29 <koz_> And obviously, more capabilities makes this worse on any given size of liveset.
03:04:08 <merijn> koz_: yeah
03:04:16 <xsperry> no solution how to change this behavior, at least not in that thread  https://stackoverflow.com/questions/50300481/scotty-doesnt-detect-if-the-port-is-already-in-use
03:04:38 <merijn> koz_: Even if parallel GC is beneficial you probably want to limit it to at most a handful of capabilities doing parallel GC
03:06:56 <merijn> koz_: btw, the GHC user guide has a chapter on what kinda flags/twiddling you can do to speed things up (talking about GC flags amongst other things)
03:07:35 <koz_> merijn: Yeah, definitely will read when I get the chance. The GHC user's guide seems to have all kinds of cool things in it every time I go looking.
03:07:52 <merijn> koz_: Also, if your code works with GHC 8.10 (or can be fixed to do so relatively easily) you can use mpickering's stuff to use speedscope.app :)
03:13:14 <Athas> Cool!  pcg-random made my dataset generator about 8x faster.
03:13:24 <merijn> \o/
03:14:10 <fog> what are the advantages of using Vector for streaming applications?
03:14:27 <fog> i dont know what is the significance of boxed vs unboxed and mutable vs immutable
03:15:05 <fog> how do various use cases motivate a particular choice of these?
03:15:09 <Athas> fog: mutable/immutable has the obvious meaning (can you change a single element of the vector), and boxing/unboxing is about how efficiently the vector is stored in memory.
03:15:12 <merijn> fog: Mutable requires IO or ST to access data, but you can do in place updates (i.e. like arrays in C/Java/Python/etc), immutable are read only, so you need to copy to update contents
03:15:37 <Athas> If possible, you always want unboxed vectors.  But you can only do that when the elements are primitive types (Int32, Float, etc).
03:15:56 <Athas> There may be some convoluted cases where you want boxed vectors even if you have the choice, but I can't think of any...
03:16:02 <merijn> Athas: Just do what I do and fake unboxed via Storable :p
03:16:14 <fog> Athas: why would random update be required? i was looking at these;
03:16:15 <fog> https://hackage.haskell.org/package/perfect-vector-shuffle-0.1.1.1/docs/Immutable-Shuffle.html
03:16:20 <fog> https://hackage.haskell.org/package/perfect-vector-shuffle-0.1.1.1/docs/Mutable-Shuffle.html
03:16:27 <koz_> Athas: Technically not correct - you can define your own Unbox instances. It's just a uniquely tedious chore. :P
03:16:44 <merijn> koz_: But defining Storable instances is easy ;)
03:16:50 <koz_> merijn: Indeed.
03:16:54 <merijn> Storable Vector is the MVP of vector :p
03:17:03 <koz_> You can even automagic them from Finitary instances. :P
03:17:04 <Athas> fog: that uses "random" in the sense of "random number".
03:17:24 <Athas> Those functions shuffle the vector contents, so they need a source of random numbers.
03:18:33 <fog> so Storable is something to do with efficiency of memory usage too? 
03:19:58 <merijn> fog: Storable is for raw memory access, usually used for the FFI
03:20:03 <fog> oh right, so its not that the particular shuffle algos are of different efficiencies depending on the type of Vector used, but that if the shuffle was just part of another function, which had other requirements for which Vector
03:20:54 <Athas> fog: I think the difference is that if you give those functions a mutable vector, they can shuffle in-place.  If you give them a non-mutable vector, then they first do a copy to get a mutable one, and then shuffle there.
03:20:56 <merijn> fog: So with Storable you can just go "I wanna read these 4 bytes from memory and treat them as an Int32"
03:20:58 <fog> merijn: that sounds dangerous! dont we rely on the compiler to make sure the C calls are sane?
03:21:13 <Athas> So if you already have a mutable vector, and you don't care about its old values, you can save a copy.
03:21:18 <merijn> fog: You can certainly segfault or corrupt your program via Storable, sure
03:21:40 <merijn> fog: Storable is exactly like C pointers (if C pointers behaved the way people think they did, anyway...)
03:21:54 <Athas> fog: this kind of low-level work is unchecked by the compiler even in Haskell, but Haskell then lets you wrap it in a safe API so the *users* cannot screw up.
03:22:15 <merijn> Contrary to popular opinion on "everything is safe Haskell", Haskell gives you a ton of super dangerous unsafe things you can do :
03:22:20 <fog> Athas: sounds like I should start with a mutable vector then to save it having to do the conversion, thanks, thats not clear from the docs on that lib
03:22:30 <Athas> The 'vector' library uses unsafe low level programming behind the scenes, but assuming the implementation is correct (and you don't use the "Unsafe" modules in the API), you cannot screw it up as a user.
03:22:31 <merijn> But you gotta go out of your way to use them
03:23:22 <merijn> fog: Stuff like this horribly unsafe module I'm proud of :p https://github.com/merijn/Belewitte/blob/master/benchmark-analysis/src/Utils/Vector.hs
03:23:39 <merijn> fog: Which rips a pointer out of a ByteString and rams it into a Storable Vector
03:23:51 <fog> im still not sure about vectors and mutability, im used to having everything being copied and GC'd, im not sure if I know how to make the most of this mutability 
03:24:08 <Athas> merijn: that one is going to anger the spirits.  How does it even work with the GC?
03:24:18 <merijn> Athas: ByteString uses a ForeignPtr
03:24:24 <Athas> Ah, so the actual byte array a GC-visible object?
03:24:24 <merijn> Athas: So does Storable Vector
03:24:34 <Athas> Ah, so the actual byte array is a GC-visible object?
03:24:38 <merijn> Athas: So it "Just Works" if you don't got out of bytes
03:24:40 <merijn> Yeah
03:24:50 <merijn> s/got out of bytes/go out of bounds/
03:24:59 <merijn> fog: Probably safest to default to immutable
03:25:15 <gentauro> if I have the following `String` -> "Espa\241a", shouldn't `Data.ByteString.Lazy.Char8.pack` (https://hackage.haskell.org/package/bytestring-0.10.10.0/docs/Data-ByteString-Lazy-Char8.html#v:pack) convert it to "España"?
03:25:32 <fog> merijn: that doesnt look so bad, is there anything to be wary of, or is all the unsafe stuff to do with Storable kept under the hood by that api?
03:25:35 <merijn> fog: I have a loop that goes over 90k vectors, accumulating elements pairwise using immutable vectors (so copying every of those 90k updates)
03:25:49 <merijn> fog: I rewrote it to use mutable vectors and in place updates
03:25:55 <merijn> fog: Didn't even speed it up :(
03:26:08 <Athas> Immutable vectors are going to be good enough for most things.  I really wouldn't suggest using mutable ones unless you know you'll need it.
03:26:17 <Athas> Many vector operations are going to be bulk anyway.
03:26:22 <gentauro> I mean, when combined with `Data.ByteString.Lazy.Char8.putStrLn`?
03:26:23 <fog> i guess thats the question
03:26:35 <merijn> fog: The unsafe part is that ForeignPtr is, as the name implies, a pointer
03:26:49 <fog> Athas: "I really wouldn't suggest using mutable ones unless you know you'll need it."
03:26:55 <fog> how would you?
03:26:58 <merijn> fog: So if part of your code writes to that pointer's memory, your pure immutable vector magically changes in pure code
03:27:09 <merijn> fog: Which pretty fundamentally breaks the purity of your code :)
03:27:20 <Athas> fog: when you end up copying an entire vector just to change a single element.
03:27:23 <merijn> fog: Profiling and going "hmm, this should be faster!"
03:27:56 <Athas> You can always locally convert an immutable vector to a mutable one, by using an ST monad operation.
03:28:11 <merijn> Basically, pure vectors are faster than you think, even when you know they're fast :p
03:28:12 <Athas> It'll cost you a single copy, of course, but that's not terrible.
03:28:18 <fog> wait, so it doesnt break, but it just becomes less fast?
03:28:23 <Athas> Yes.
03:28:48 <fog> so how do you make the most of this fastness without causing it to start copying everything?
03:29:03 <merijn> fog: If you have a 1000 element vector and you use the immutable API to update index 5, you need to copy all 1000 elements into a new vector (since you can't mutate)
03:29:03 <fog> sorry, totally new to the idea of mutability 
03:29:22 <Athas> 'vector' is more or less the only really solid Haskell library for high-performance computation.  It's legitimately just good, with hardly any reservations.  'massiv' might be the second one, though.
03:29:36 <JohnnyL> Are the haskell error codes cryptic?
03:29:45 <Athas> JohnnyL: not in most cases.
03:30:02 <merijn> fog: The mutable interface of vector just let's you access C-style arrays "array[5] = 10;" overwriting position 5 in the array
03:30:08 <Athas> GHC is not bad, not great when it comes to errors.
03:30:24 <fog> hmm, I have only ever used traverse
03:30:26 <merijn> JohnnyL: Most of them are okay when you learn to read them (there is a bit of learning, though)
03:31:03 <fog> i have never had a use case that only updates one array index
03:31:05 <merijn> fog: The paper on ST is pretty interesting discussion of how to do mutability in Haskell
03:31:20 <merijn> fog: "Lazy Functional State Threads" is the name, I think
03:31:30 <fog> i get the stuff with LVars
03:31:53 <fog> and I had servers holding values which was pretty concurrent 
03:32:19 <fog> but the use case is only ever for time evolution which updates all the values
03:32:49 <fog> only really doing scientific computing, mostly finite difference schemes 
03:33:09 <fog> the idea of using shuffle was just for some monte carlo 
03:34:04 <fog> you can project against arrays of random matricies, basically just adding static to the solution
03:34:34 <fog> so shuffling huge arrays of white noise becomes a thing 
03:34:37 <JohnnyL> merijn: right
03:35:22 <merijn> JohnnyL: You can always ask here if you can't decipher it :)
03:35:37 <JohnnyL> ok
03:35:37 <fog> basically, i have something that can be built up by adding together basis functions, but only sparsely many of an infinite set
03:35:38 <Athas> fog: using the pure shuffling functions in Immutable.Shuffle are going to be fine.  You only need to worry about impurity if you want to write your own shuffle functions.
03:35:42 <JohnnyL> thank you.
03:36:27 <JohnnyL> if i make a game in haskell i have to distribute the source.
03:38:12 <Arahael> JohnnyL: If that's a statement, then that's great. I agree. :)  If that's a question, however, then no, you don't have to.
03:38:44 <JohnnyL> ok
03:49:45 * hackage haskoin-node 0.10.0 - Haskoin Node P2P library for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-node-0.10.0 (jprupp)
04:09:06 <berndl> I just discovered the Unit type: https://hackage.haskell.org/package/ghc-prim-0.5.3/docs/GHC-Tuple.html#t:Unit. Has anyone ever used it for anything?
04:09:27 <jchia_> I have a question about haskell-ide-engine. Is the user responsible for making a hie.yaml? Why can't haskell-ide-engine figure it out from the content of the project directory, e.g. looking at the cabal.project or stack.yaml?
04:10:00 <jchia_> The README on the github says that the user can make a hie.yaml but doesn't say why he would want to do so.
04:10:14 <jchia_> or what happens if he doesn't
04:13:35 <merijn> berndl: That just looks like Identity
04:13:47 <berndl> Indeed.
04:13:51 <merijn> Except, less efficient and less instances :p
04:14:05 <berndl> I guess they wanted a type to represent 1-tuples.
04:14:51 <berndl> Calling it Unit was a bad idea though.
04:15:16 <maerwald> jchia_: yes, it doesn't make much sense
04:15:57 <Poscat[m]> jchia_: check out implicit-hie
04:16:14 <Poscat[m]> https://github.com/Avi-D-coder/implicit-hie
04:16:24 <merijn> hie-bios (what hie and ghcide use) can't handle multi-component projects well
04:16:39 <merijn> So you might have to create an explicit hie.yaml to get things to work
04:16:47 <alanz_> jchia, it is a work in progress, see https://github.com/haskell/haskell-language-server/issues/38
04:24:47 <xsperry> given some type with IsString instance, how can I use an actual String, not a string literal, to create an object of that type? 
04:24:54 <jchia_> merijn: alanz_, Poscat[m]: i c. it's a work in progress, so needs some human guidance. my project has packages, and hie gives errors unless I provide hie.yaml for the exe targets I want to edit, so I hope implicit-hie works.
04:25:15 <xsperry> nevermind.. fromString
04:26:44 <alanz_> jchia_, that is exactly the use-case we are aiming for, but still quite a bit to be done
04:28:08 <gentauro> can't `Read/Show` handle UTF-8?
04:28:49 <gentauro> `data Foo = F [Char] deriving (Read,Show)` and `read ("F \"España\"") :: Foo` becomes `F "Espa\241a"` ...
04:28:58 <merijn> xsperry: fromString and IsString used for anything other than Text are generally evil, tbh, so...
04:29:03 <jchia_> alanz_: hie just fails to load cradles for the executable targets in my multi-package project right now unless I provide the cradles in hie.yaml. I'll try to find a way to generate the hie.yaml for now.
04:29:06 <merijn> gentauro: Show creates valid Haskell source
04:29:33 <merijn> gentauro: The encoding of haskell source isn't defined (it's just "some unicode") so it escapes non ascii characters
04:29:45 <xsperry> merijn, I am passing HostPreference as a program option. no way around using fromString, as far as I can tell
04:29:51 <gentauro> merijn: so it transforms UTF-8 `Char` to `\uxxxx` values?
04:30:10 <merijn> gentauro: Your problem is tha you are calling Show on the string, rather than printing it
04:30:21 <gentauro> merijn: well `ñ` is ASCII (extended and less than 255)
04:30:34 <merijn> extended ASCII is not a thing
04:30:52 <alanz_> jchia_, as examples you can look at https://github.com/haskell/haskell-language-server/blob/master/hie.yaml.cbl for cabal and https://github.com/haskell/haskell-language-server/blob/master/hie.yaml.stack for stack
04:31:05 <gentauro> merijn: I'm showing my type `Foo`, see `F "Espa\241a"`
04:31:10 <merijn> gentauro: Anyway, compare the following two in ghci:
04:31:19 <merijn> "España"
04:31:21 <merijn> And:
04:31:23 <jchia_> alanz_: I think I can write the cradles, but there are just too many targets in my project.
04:31:27 <merijn> putStrLn "España"
04:31:37 <alanz_> ok
04:31:52 <merijn> gentauro: in ghci there is an implicit "show" being called on any expression, which renders the original string escaped
04:32:05 <merijn> But if you print it directly with putStrLn that doesn't happen
04:32:17 <jchia_> thanks for clarifying the mystery, though. I have been trying to get hie to work on my exe source code for a while.
04:32:50 <gentauro> merijn: so whenever I have print my datatype, I will need to create somekind of JSON container?
04:34:20 <merijn> "It Depends"
04:34:36 <gentauro> I thought I could just use the `showed` datatype to be used as a `config` file, but it wouldn't work if I have to do manually the UTF8 conversions myself :S
04:35:16 <gentauro> hmmmm
04:35:25 <gentauro> maybe there is a pretty-printer that handles that
04:35:33 <gentauro> I think I used it once
04:35:40 <gentauro> let me look in my code base :)
04:35:55 <jchia_> alanz_: And thanks for the great work on haskell-ide-engine. It really makes it possible for me to write Haskell productively.
04:36:34 <alanz_> jchia_, it is a whole of team of people now, mostly not me.  But it is very encouraging to see progress
04:38:01 <merijn> gentauro: Show is really not ideal for anything other than basic debug output
04:38:25 <merijn> gentauro: If you want to, well, prettyprint stuff I recommend using something like
04:38:30 <merijn> @hackage prettyprinter
04:38:30 <lambdabot> http://hackage.haskell.org/package/prettyprinter
04:44:07 <gentauro> merijn: I think the one I used was `Text.PrettyPrint.HughesPJ`
04:44:24 <gentauro> merijn: I will give the pkg you mentioned a go
04:44:25 <gentauro> :0
04:47:30 <gentauro> :)
04:53:14 * hackage haskoin-store 0.23.16 - Storage and index for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-store-0.23.16 (jprupp)
04:59:43 <hseg> trying to debug why instance Semiring (WrappedFiniteDefinition p m r)'s definition of (+) isn't commutative: http://ix.io/2kAO
05:01:10 <hseg> the counterexamples basically are of form [(k,v)] + [(k',v')] = [(k,v+v')], instead of [(k,v),(k',v')] (k/=k' here)
05:06:44 * hackage haskoin-node 0.10.1 - Haskoin Node P2P library for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-node-0.10.1 (jprupp)
05:13:06 <hseg> ok, traced it down to Data.Align's faulty Semialign (Map k) instance
05:15:35 <hseg> hrm... seems to depend on what key type i use for Map
05:17:04 <hseg> ... ok, problem found: my Ord instance was spuriously equating two keys
05:17:15 <hseg> which is a reasonable error
05:19:40 <gentauro> merijn: I found the packages I was using (for some understanding while parsing with TH) -> https://hackage.haskell.org/package/pretty-show-1.10/docs/Text-Show-Pretty.html#v:ppShow
05:19:45 * hackage plzwrk 0.0.0.2 - A front-end framework  https://hackage.haskell.org/package/plzwrk-0.0.0.2 (mikesol)
05:19:54 <gentauro> it's pretty nice cos you just replace `show` with `ppShow` :)
05:20:14 <gentauro> and it just makes it really readable (with line changes and so, comared to `show` one-liners)
05:20:44 * hackage gll 0.4.0.13 - GLL parser with simple combinator interface  https://hackage.haskell.org/package/gll-0.4.0.13 (ltvanbinsbergen)
05:23:17 <gentauro> merijn: it still doesn't work with the extended ASCII though ...
05:31:23 <ivegotasthma> hello
05:31:46 <ivegotasthma> I'm getting a huge memory leak on haskell, I'm doing a lot of nested indexing and I'm trying to diagnose the issue. Any advice? I'm a newb
05:34:56 <ivegotasthma> I think I have an answer, how can I take one element from a generator at a time?
05:40:28 <Uniaika> ivegotasthma: what do you mean a "generator"?
05:41:07 <ivegotasthma> Uniaika: I generate a big list of nested lists
05:41:12 <ivegotasthma> then I do a lot of nested indexing on them
05:41:36 <ivegotasthma> I'm wondering if the memory explosion is due to the lists being generated all at the same time and staying in memory after processing
05:45:26 <Uniaika> ivegotasthma: did you read https://wiki.haskell.org/Space_leak ?
05:50:45 * hackage haskoin-node 0.11.0 - Haskoin Node P2P library for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-node-0.11.0 (jprupp)
05:58:59 <ivegotasthma> Uniaika: yes
05:59:11 <ivegotasthma> the leak happens only with a -O2 binary
05:59:14 <ivegotasthma> not in the intepreter
05:59:31 <ivegotasthma> I don't think I'm breaking laziness
06:20:15 * hackage binaryen 0.0.1.1 - Haskell bindings to binaryen  https://hackage.haskell.org/package/binaryen-0.0.1.1 (terrorjack)
06:33:50 <Phantom_Hoover> hmm
06:33:51 <Phantom_Hoover> https://wiki.haskell.org/Unamb
06:34:13 <Phantom_Hoover> the value of unamb u v is undefined if u and v are non-bottom and nonequal, right?
06:34:47 <Phantom_Hoover> or is it simply an undefined choice of u or v?
06:35:15 * hackage hlint 3.0.2 - Source code suggestions  https://hackage.haskell.org/package/hlint-3.0.2 (NeilMitchell)
06:40:15 * hackage haskoin-store 0.23.18 - Storage and index for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-store-0.23.18 (jprupp)
06:51:15 * hackage websockets 0.12.7.1 - A sensible and clean way to write WebSocket-capable servers in Haskell.  https://hackage.haskell.org/package/websockets-0.12.7.1 (JasperVanDerJeugt)
06:53:11 <DocKlobi> how can I achieve a nested applicative calculation, e.g.    [Just succ] <*> [Just 3]
06:54:28 <aveltras> is it possible to have something like the following with servant ? i have a protected api and want to have a catch all throw error if the argument passed to server is Nothing, this should work with any number of endpoints, right now i have to repeat the throwError for the number of endpoints
06:54:32 <aveltras> https://www.irccloud.com/pastebin/ruTCTUZF/
06:59:44 * hackage haskoin-store 0.23.19 - Storage and index for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-store-0.23.19 (jprupp)
07:01:04 <jchia_> Poscat[m]: jchia_: I think implicit-hie fails to process common stanzas properly. Isn't there a library to help parse cabal files?
07:12:30 <lebalifant> DocKlobi: https://hackage.haskell.org/package/transformers-0.4.2.0/docs/Data-Functor-Compose.html
07:41:31 <DocKlobi> lebalifant: thxs
07:41:44 <DocKlobi> >(liftA2 . liftA2) (\f x -> f x) [Just succ ]  [Just 3]
07:42:22 <DocKlobi> it is just to verbose and ugly
07:46:39 <DocKlobi> ah     Compose [Just succ] <*> Compose [Just 3]  works fine. Nice
07:55:30 <lyxia> liftA2 (<*>)
08:05:07 <pie_> i dont know enough about algorithms to have any idea at this point, but do you guys think there would be value to having an encyclopedia of data structure invariants, somewhat analogous to say, OEIS? so for example, to make easier implementing things in various languages because you can just look up what properties you need to verify?
08:07:14 * hackage rss-conduit 0.5.0.0 - Streaming parser/renderer for the RSS standard.  https://hackage.haskell.org/package/rss-conduit-0.5.0.0 (koral)
08:08:13 <DocKlobi> lyxia: thxs. do not know why it did not come to myself
08:33:31 <juri_> pie: you mean like rosetta code?
08:36:14 * hackage hlint 3.0.3 - Source code suggestions  https://hackage.haskell.org/package/hlint-3.0.3 (NeilMitchell)
08:42:56 <dmwit> pie_: That seems hard, because of how general the term "invariant" is. The thing that makes OEIS useful is there's a very clear, precise query language.
08:43:18 <dmwit> I'm trying to imagine what query language you'd use for an invariant database that isn't already better served by Google.
08:43:47 <pie_> juri_: not really? this would be more about the abstract properties i tihnk
08:44:00 <pie_> mh.
08:44:25 <pie_> yeah im not really sure about querying
08:45:09 <pie_> would probably have to have a vague idea what youre looking for already
08:46:11 <dmwit> Let's say I knew *exactly* what I was looking for. Then what?
08:47:15 <pie_> I guess you can read a paper :I
08:49:43 <pie_> still more tedious tan having some hoare triples or something
08:49:46 <pie_> *than
08:51:37 <ja> but what about all the variants of data structures? every b-tree is slightly different
08:51:49 <dmwit> Perhaps it would be worth spending a little time writing down half a dozen invariants you have in mind, and thinking about what it would take to have a language that encompassed all of them.
08:52:04 <pie_> otoh you still have to be able to make sense of what youre reading probably <pie_> still more tedious tan having some hoare triples or something
08:52:12 <pie_> dmwit: yeah
08:52:18 <dmwit> Things like "there are no more than 2x as many nodes on the longest path as the shortest one" and "the list is sorted" and whatever else.
08:52:46 <dmwit> "no two nodes have the same identifier" or whatever
08:53:12 <pie_> im scratching my head because this largely sounds like a library for some modeling language like TLA+ or something
08:53:33 <dmwit> Maybe canvas a couple friends for ideas, too, to avoid blind spots.
08:53:48 <pie_> yeah thats why i started poking here a little c:
08:53:59 <pie_> for starters at least, we'll see what happens
08:55:01 <dmwit> Okay. Well my answer to the question as asked is "the value of such a database depends intimately on how good the query language is". If the actual question is "what invariants would you imagine being in such a database?" then I guess the answer is much bigger. =P
08:57:04 <pie_> i think your answer was reasonable
09:00:54 <kitakami_kyle> Good morning from Japan
09:01:02 <pie_> ja: idk
09:01:34 <kitakami_kyle> I'm brand new to Haskell - Haven't even looked at one line of Haskell code yet - but I'm excited to learn it.
09:03:57 <pie_> \o/ ganbatte
09:06:41 <ski> hello kitakami_kyle
09:08:33 * Lycurgus .oO( abandon hope all ye ... )
09:08:43 * ski smiles
09:09:24 <[exa]> kitakami_kyle: well, do you know any other programming language? (that will help you estimate the amount of impending shock :] )
09:10:59 <kitakami_kyle> @exa, yes I know several others.  I have learned a lot about Elm and that is what got me interested in Haskell
09:11:38 * ski looks at tdammers
09:12:08 <ski> do you have any learning resources that you want to follow, yet, kitakami_kyle ?
09:12:56 <kitakami_kyle> I just came across this site http://learnyouahaskell.com/ and that's how I found this channel
09:13:09 <ski> ah, okay
09:13:31 <kitakami_kyle> I'm pretty new to deep FP concepts.
09:13:35 <ski> LYAH tends to not be that much recommended, around here. partly because it has no exercises
09:13:51 <kitakami_kyle> I'm open to ideas
09:14:06 <ski> and that it doesn't got that deep into concepts. it has sometimes been likened to a "four hour trailer"
09:14:12 <kitakami_kyle> by the way, how do you address members here -...  @name etc
09:14:13 <ski> but it has pretty pictures ! :)
09:14:27 <kitakami_kyle> haha
09:14:36 <ski> well, IRC tradition is to just mention the persons nickname (without any adorning sigils like `@')
09:14:43 <ski> @where CIS194
09:14:43 <lambdabot> https://www.seas.upenn.edu/~cis194/spring13/lectures.html
09:14:50 <ski> has exercises, which you could try
09:15:31 <kitakami_kyle> Ok great.  I just installed the "stack"
09:15:40 <kitakami_kyle> whatever that is... I guess it is the compiler
09:15:46 <kitakami_kyle> I'll learn soon enough
09:15:50 <freeside> if i may comment, i went through LYAH, and the Hutton book, and the haskellbook.com, and FWIW I got the most value out of haskellbook.com
09:16:13 <kitakami_kyle> haskellbook.com?  Ok, I'll check that out also.
09:16:40 <ja> kitakami_kyle: some clients only hilight/alert by default if the nick is a prefix
09:17:02 <[exa]> kitakami_kyle: LYAH is great if you really have the motivation to create&finish your own exercises, otherwise it's a bit bland
09:17:29 <[exa]> kitakami_kyle: (anyway asking on #haskell for exercises is almost always a success)
09:17:30 <kitakami_kyle> ok, well I'll try the other suggestions you offered 
09:17:31 <ski> @where PIH
09:17:31 <lambdabot> "Programming in Haskell" by Graham Hutton in 2007-01-15,2016-09-01 at <http://www.cs.nott.ac.uk/~pszgmh/pih.html>
09:17:34 <ski> is Hutton
09:17:56 <ski> @where HPFFP
09:17:56 <lambdabot> "Haskell Programming: from first principles - Pure functional programming without fear or frustration" by Chistopher Allen (bitemyapp),Julie Moronuki at <http://haskellbook.com/>,#haskell-beginners
09:18:26 <kitakami_kyle> I'm getting overwhelmed now.... LOL
09:18:52 <[exa]> kitakami_kyle: a pretty good approach is to make up a very simple starting project, try to code it with some support, and then ask #haskell for code feedback (or for the project idea feedback as well)
09:18:53 <kitakami_kyle> I will check out those first two sites.  I'll be back for sure.  I love the helpful community
09:19:04 <ski> kitakami_kyle : yea, i'd suggest hanging around on this channel (and also, possibly, on #haskell-beginners), as you're reading, and doing exercises. both channels welcome beginner questions
09:19:19 <kitakami_kyle> exa, will do
09:19:33 <russruss> HI all, coming back to haskell after a long absence.  I'm wondering if there's a way using GHC.Generics to auto-derive type classes for record _projection_, i.e., converting to a smaller record with matching names.  Or, if this isn't possible, if there's a template haskell-based library I could use for this
09:20:01 <ski> (the difference is mostly that the other channel is more silent. so there's less noise. but also may take longer for someone to start replying to you. while in here, there's more noise, and also more non-beginner conversations (both practical and theoretical))
09:20:08 <[exa]> kitakami_kyle: very highly suggest looking at Gloss library, it's a very easily manageable graphical frontend for simple functionally-described worlds, without much hassle with advanced haskell features
09:20:16 <freeside> russruss: what are you trying to achieve? This could be a job for Lenses
09:21:02 <ski> kitakami_kyle : oh, and Stack isn't the compiler. GHC is. Stack, and Cabal, are two package managers, one could say. they're sortof rivals
09:21:28 <kitakami_kyle> well, I have been learning Elm recently.  I really like it - therefore I have wanted to learn more about Haskell - AND more about real FP.
09:21:33 <russruss> I just want less boilerplate when passing around records.  i.e., if I have a function that takes an argument a record, I want to be able to conveniently pass a "larger" record with extra rows to that function
09:21:39 <russruss> without explicitly writing the conversion functions
09:22:21 <kitakami_kyle> over and out - I'll check out those resources and visit again soon
09:22:44 <freeside> sounds like the smaller record is, in a more OOPy programming paradigm, an Interface, and the larger record is an Implementation
09:23:52 <russruss> oh, I wonder if this will help.... https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Records.html
09:24:47 <ja> russruss: did you see this blog post https://www.well-typed.com/blog/2013/11/overloaded-record-fields-for-ghc/
09:25:24 <ski> hm, sounds like russruss maybe wants row polymorphism ?
09:25:53 <ja> well he can't have it!!! :D
09:26:00 <ja> he/she, sorry :O
09:26:50 <freeside> as long as he/she can have gender polymorphism
09:26:58 <ski> freeside, hm, how's the smaller one an interface ?
09:27:26 <russruss> I'm familiar with row polymorphism in purescript, I don't exactly need _all that power_, I just want a class that enables projection down to specific smaller records that can be derived by the compiler.  Maybe that's still asking for too much heh
09:27:33 <freeside> ski: in the sense of https://www.typescriptlang.org/docs/handbook/interfaces.html
09:27:55 <hseg> well, any function is polymorphic in a variable it doesn't mention, so gender polymorphism can be attained syntactically
09:28:04 <hseg> just need to avoid mentioning it
09:28:19 <hseg> (which is easier said than done)
09:29:50 * ski doesn't understand what hseg just said
09:30:21 <freeside> perhaps an allusion to https://en.wikipedia.org/wiki/Pro-drop_language
09:31:08 <russruss> I guess one option is to forget about actually converting to the smaller record and instead have the function take a constraint that mentions all the fields it needs with `HasField`.  The downside of that is I want to be able to ultimately convert this smaller record to JSON, and I don't know how to do that with only the `HasField` constraints...
09:31:22 <ja> freeside: oh that is a great article! fun examples!
09:33:08 <russruss> ah, this looks like _exactly_ what I was looking for http://hackage.haskell.org/package/generic-records-0.2.0.0/docs/Records-Generic.html
09:35:15 <ski> oh
09:35:32 <freeside> nice. i was just reading about downcasting at https://wiki.haskell.org/OOP_vs_type_classes#Downcasting_is_a_mission_impossible
09:35:38 <ski> hm, freeside. hadn't heard that term before. ty
09:36:00 <ski> (still not seeing how what hseg could be an allusion to that, though)
09:37:31 <ja> english is gender polymorphic in the first and second persons
09:37:44 <[exa]> hseg: that's too insightful to work
09:37:54 * ski 's never heard the term "gender polymorphism", before
09:39:37 <freeside> linearize :: Human Gender NthPerson -> String
09:39:47 <freeside> linearlize (Human _ 1) = "I did it"
09:39:55 <freeside> linearize (Human _ 2) = "You did it"
09:40:07 <freeside> linearize (Human Male 3) = "He did it"
09:40:13 <freeside> linearize (Human Female 3) = "She did it"
09:40:40 * ski just noticed freeside's in #gf
09:41:14 <freeside> it's not really polymorphism, it's whether we need to pattern-match Gender, which is a sum type, or not, depending on how progressive your social circles are
09:41:26 <ski> mm. so you mean it's uniform/"agnostic"/"parametric" in the gender, in those cases
09:42:06 <freeside> a pro-drop language wouldn't even have the first word ... linearize = "did it"
09:42:27 <freeside> linearize _ = "did it"
09:43:16 <ja> freeside: but in some languages, the results of linearize will have to have different types to compose sensibly
09:43:17 <ski> yea
09:43:30 <ja> freeside: so in those languages, you will put it in the type system
09:43:36 <ja> isn't it polymorphism then?
09:43:45 <freeside> is it? i don't know enough type theory to say
09:44:03 <ja> isn't polymorphism just pattern matching in the type system?
09:44:50 <ski> could you elaborate on how they'd "have different types to compose sensibly" ?
09:44:52 <freeside> but on this note, i came across a really interesting type-level concept in natural language grammar today ... given the sentence "i ate and drank the food and wine", what's really going on is "i ate the food and drank the wine", but there's a hidden magical type inference going on in what is essentially [ate, drank] <*> [food, wine]
09:45:10 <freeside> that might be an example of "composing different types"
09:45:50 <freeside> "ate" only takes "food" as an argument, not "wine"; "drank" only takes "wine" as an argument, not "food"; so they match accordingly
09:47:07 <hseg> freeside: yeah, type-directed parsing is a doozy
09:48:18 <ja> ski: e.g. in spanish you have a gendered "we". so if you say "we are girls", you should say "nosotras" for "we". if there is a male member in the group, it becomes "nosotros"
09:48:47 <freeside> oh, can you tell me the rules for "bravo" vs "brava"?
09:48:53 <hseg> ski: sorry, needed to go. basically, idea was that by avoiding mentioning gender, you automatically make things gender-neutral
09:49:46 <ja> ok, so i will use "they" and "fireperson" :D
09:49:58 <hseg> translation to haskelese: a type with a phantom type parameter is automatically parametric in that parameter 
09:51:08 <ja> freeside: many adjectives are gendered. same principle. if it is plural, one male spoils the femininity
09:51:13 <freeside> right.
09:51:25 <ski> hseg : mhm. i see that. i just don't see how you connected that to not mentioning variables, or to being polymorphic in non-referred-to record field
09:51:44 * hackage haskoin-node 0.11.1 - Haskoin Node P2P library for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-node-0.11.1 (jprupp)
09:52:12 <freeside> btw, this is a bit awkward, but the research group that i'm working for is hiring for Haskell and computational linguistics, so if anybody would like to move to Singapore to get paid to write open-source Haskell code, please message me directly for details
09:52:38 <ja> not awkward at all! what an awesome opportunity
09:55:07 <ski> ja : hm, i think it's the same in arabic
09:55:34 <ja> ski: but arabic is pro-drop, spanish is not really
09:55:43 <ski> ah, okay
09:56:13 <ski> (i meant "the same", re "gender tainting", or however you'd call that linguistic phenomenon)
09:56:35 <ja> hmmm i don't know arabic, but maybe there is also a wildcard gender? :P
09:56:56 <sm[m]> freeside, what's the application/industry ?
09:57:28 <ski> freeside : re the eating and drinking example, from a logic programming perspective one could explain it as eating wine, and drinking food, each fails, leaving only two of the four possibilities
09:57:56 <ski> another way to think of it would be to assume a "respectively" interpretation (like `zip')
09:59:25 <ja> i think the zip approach is too strict to model actual usage
10:01:13 <ja> ski: hmm according to https://en.wikipedia.org/wiki/Arabic_grammar it seems like gender is seeping in all over the grammar
10:01:53 <ja> the issue with this pro-dropness is that it doesn't really extend to real usage, i think
10:02:18 <dsal> I'm using Data.Conduit.Network.runTCPServer and am having a bit of difficulty tearing down my connections.  If I have two "conflicting" connections to my service, the second one wins and the first one should get dropped.  I throw an exception at the first one and I can log a message after the `finally` that brackets my main connection loop, but the client does not get disconnected.
10:02:29 <freeside> sm[m]: the goal is to turn law into an application domain for computer science, and build an opensource tech stack of tools that do for qualitative (legal) reasoning what the spreadsheet does for quantitative reasoning. this is largely an exercise in old fashioned AI, no TensorFlow anywhere in sight
10:02:30 <dsal> Does anyone know if there's a way to explicitly disconnect from within runConduit?
10:03:36 <freeside> there's a long list of technologies and languages at the bottom of https://computational.law/hiring/ that give a sense of the kinds of toys we play with, starting with DSL development
10:04:10 <sm[m]> cool
10:04:55 <freeside> our recruitment efforts appear to resonate with people whose parents wanted them to go to law school but they ended up in software instead lol
10:05:34 <ja> wow, i didn't know people still used the term "symbolic AI"
10:06:07 <freeside> persons of a certain age
10:06:57 <xsperry> why is Scotty still not detecting that the port is in use in the following code, after I manually selected address? I can run 3 or more processes that bind to the same host and port, without any error, exception, or warning that the port is in use. https://pastebin.com/1vERhB1d
10:07:05 <xsperry> related: https://stackoverflow.com/questions/50300481/scotty-doesnt-detect-if-the-port-is-already-in-use
10:08:33 <dsal> Oh.  The problem seems to be that I'm wrong.
10:08:53 <freeside> i hate it when i run into those problems.
10:09:04 <dsal> -v and -u, while similar, don't do the same thing.
10:09:22 <[exa]> freeside: So easily avoidable by being right! :D
10:09:22 <freeside> if you were programming in Latin 2000 years ago you'd be all set.
10:09:45 <dsal> Ha.  Yeah.
10:10:04 <freeside> you would be VICTORIVS
10:10:05 <dsal> I spent a while on this last night.  The whole time, my "conflict" seemed to be that I just wasn't doing the same thing in two windows.
10:14:15 * hackage haskoin-store 0.23.20 - Storage and index for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-store-0.23.20 (jprupp)
10:16:39 <slack1256> Does anybody know why libgpg-error is linked by the rts on all ghc compiled programs?
10:24:18 <ski> freeside : hm, i'm reminded of Darryl McAdams, who's a linguist, interested in type theoretical and logical stuff. i'm not sure which nickname he's using, nowadays, though
10:24:49 <dsal> slack1256: obviously to give maximally cryptic error messages.
10:26:09 <freeside> ski: mmmm
10:27:23 <maerwald> dsal: lol
10:27:41 <freeside> haha
10:28:30 <wz1000> how do I mapMaybe on a Set in O(n)?
10:28:41 <freeside> this is a programming style called "security through aab28f2bf61f797adc6e994db522bd9d25beb51c"
10:28:43 <dsal> :t mapMaybe
10:28:45 <lambdabot> (a -> Maybe b) -> [a] -> [b]
10:29:00 <dsal> wz1000: well, mapMaybe is defined on a list, so
10:29:01 <wz1000> filter and fromJust seems quite dirty
10:29:09 <dsal> :t mapMaybe . S.toList
10:29:10 <lambdabot> error:
10:29:10 <lambdabot>     • Couldn't match type ‘[a]’ with ‘a1 -> Maybe b’
10:29:10 <lambdabot>       Expected type: S.Set a -> a1 -> Maybe b
10:29:23 <dsal> :t mapMaybe f . S.toList
10:29:25 <lambdabot> (Show a, FromExpr (Maybe b)) => S.Set a -> [b]
10:30:29 <wz1000> I know, I want the same operation on a Set instead
10:30:50 <ski> @type \f -> S.unions . S.map (maybe S.empty S.singleton . f)  -- hm, what's complexity of this ?
10:30:52 <lambdabot> Ord a1 => (a2 -> Maybe a1) -> S.Set a2 -> S.Set a1
10:31:59 <dsal> :t \f -> Set.fromList . mapMaybe f . Set.toList
10:32:00 <lambdabot> error:
10:32:00 <lambdabot>     Not in scope: ‘Set.fromList’
10:32:00 <lambdabot>     Perhaps you meant one of these:
10:32:08 <dsal> :t \f -> S.fromList . mapMaybe f . S.toList
10:32:09 <lambdabot> Ord a1 => (a2 -> Maybe a1) -> S.Set a2 -> S.Set a1
10:32:28 <dsal> I mean, it's not like you can do it "in place"
10:34:12 <dsal> I like that it works on Sets that don't have any constraints on the elements.  Building one is an exercise left to the reader, though.
10:34:42 <slack1256> dsal: god damn, lol.
10:42:15 * hackage haskoin-node 0.11.2 - Haskoin Node P2P library for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-node-0.11.2 (jprupp)
10:53:15 * hackage haskoin-store 0.23.21 - Storage and index for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-store-0.23.21 (jprupp)
10:59:15 * hackage haskoin-node 0.11.3 - Haskoin Node P2P library for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-node-0.11.3 (jprupp)
11:06:05 <ivegotasthma> could someone tell me why this little snipper of code is hanging forever to construct an array? https://dpaste.org/uN4E/raw
11:07:45 * hackage password 2.0.0.0 - Hashing and checking of passwords  https://hackage.haskell.org/package/password-2.0.0.0 (nideco)
11:08:26 <c_wraith> I don't know how this would cause an infinite loop, but your range implementation is wrong
11:08:59 <c_wraith> Also, your inRange implementation is a lot more verbose than it needs to be.
11:09:34 <sushi27> Hello, what is the easiest way to modify a matrix created by nesting lists [[a]]?
11:09:40 <c_wraith> ....  to be complete, your matrixFilled implementation could be a lot more succinct, too.
11:09:57 <c_wraith> sushi27: that's a really bad representation for that purpose.
11:10:21 <sushi27> c_wraith: yeah i know :/  but it's in the assignment like this and i can't change the signature
11:10:35 <c_wraith> so you probably can't use lenses, either.  that's the easiest way!
11:10:40 <ivegotasthma> c_wraith: how can I fix my Ix implementation?
11:10:44 * hackage password-instances 2.0.0.0 - typeclass instances for password package  https://hackage.haskell.org/package/password-instances-2.0.0.0 (nideco)
11:11:05 <dsal> Is it possible to derive Ix?  Seems like you should be able to do that for a bounded enum
11:11:18 <c_wraith> sushi27: write a function like alterIndex :: Int -> (a -> a) -> [a] -> [a]   and use it
11:11:27 <ivegotasthma> dsal: I need to write it out manually
11:11:31 <ivegotasthma> I can't figure out what I'm doing wrong
11:11:39 <c_wraith> ivegotasthma: well, range should return all the intermediate points.  I think you mean [l .. u]
11:11:45 * hackage haskoin-store 0.23.22 - Storage and index for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-store-0.23.22 (jprupp)
11:11:46 <ivegotasthma> I've checked it out from the GHC sources to see how they implement it for Bool
11:11:53 <dsal> I'm just wondering.  Last time I needed an Ix instance, I wrote it myself.
11:11:54 <c_wraith> well that's your problem
11:12:00 <c_wraith> Bool doesn't have intermediate values
11:12:47 <c_wraith> Index is an instance of Ord, so you can write inRange (l, u) e =  l <= e && e <= u
11:13:29 <c_wraith> and in MatrixFilled, you can once again use the fact that Index is an instance of Enum to have x <- [One .. Four]  and skip the toEnum calls
11:13:51 <ivegotasthma> c_wraith: thanks <3
11:14:56 <c_wraith> ivegotasthma: I still don't know why range being wrong would result in an infinite loop.  But it's the one bug that I saw in there.
11:17:25 <ivegotasthma> c_wraith: I fixed that, I'm still stuck in the loop :/
11:17:39 <c_wraith> then it's probably not that code that's responsible
11:17:40 <ivegotasthma> thanks though, I'll keep banging my head against the wall
11:29:35 <c_wraith> > sequenceAOf (_Wrapped . traverse) (S.fromList [Just 1, Just 17])
11:29:37 <lambdabot>  Just (fromList [1,17])
11:29:48 <c_wraith> that's a funny instance of Wrapped.  But I'm glad it's there.
11:36:14 <dsal> Huh.  I guess that answers my question about what makeLenses does if you give it a product type that isn't a record.
11:37:22 <c_wraith> Does it?
11:37:33 <dsal> It just doesn't do anything at all.
11:37:41 <c_wraith> Oh.  well that makes some sense.
11:38:10 <dsal> I was kind of hoping for some _1 kinds of things or something, but if I actually want to do this, I should probably hand-write some lenses.
11:38:18 <dsal> But this is an absurd level of yak shaving.
11:38:47 <c_wraith> if you wanted to be super-lazy, generic-lens can handle non-record products
11:39:06 <dsal> I want to be hyper-lazy... just like, "lens up that module over there"
11:39:24 <c_wraith> generic-lens just requires adding a Generic instance.
11:39:39 <c_wraith> (or having one already)
11:40:51 <dsal> This is really interesting, but I should probably just work on my actual problem.
11:41:15 <c_wraith> but the rabbit hole beckons...
11:41:48 <dsal> "actual problem" is also not something I really need.  It's just differently interesting.  I have such a tremendous source of interesting puzzles.
11:43:06 <dsal> There's a data structure problem looming here that I don't really want to work on, but it's pretty interesting.  I can hack on something super inefficient in the meantime.
11:44:17 <koz_> dsal: What's the data structure problem?
11:48:12 <ski> @let data Index = One | Two | Three | Four | Five | Six deriving (Eq,Ord,Enum,Show,Ix)
11:48:14 <lambdabot>  Defined.
11:51:45 * hackage kind-generics 0.4.1.0 - Generic programming in GHC style for arbitrary kinds and GADTs.  https://hackage.haskell.org/package/kind-generics-0.4.1.0 (AlejandroSerrano)
11:52:44 * hackage kind-generics-th 0.2.2.0 - Template Haskell support for generating `GenericK` instances  https://hackage.haskell.org/package/kind-generics-th-0.2.2.0 (AlejandroSerrano)
11:53:12 <ddellacosta> so I'd like to mess around with some hardware hacking, in particular record some sensor values and send them over the network (or more generally allow networked access). What is the best experience right now in terms of Haskell support, Raspberry Pi? I don't have much sense of where to start
11:53:24 <ddellacosta> in terms of which device to look at
11:53:53 <koz_> ddellacosta: I think ARMv8 has the best non-x86 GHC support.
11:54:02 <koz_> (however, #ghc might be the better place to ask)
11:54:06 <dsal> ddellacosta: I run a few of my haskell mqtt stuff on orange pi.
11:54:17 <dsal> Both 64-bit and 32-bit ARM.
11:54:39 <ddellacosta> koz_ dsal thanks, will check that out, and thanks koz_ for the tip on #ghc
11:54:55 <koz_> dsal: You managed to build a cross-comp toolchain?
11:55:03 <koz_> Or do you just run ${TEXAS} duration builds?
11:55:34 <dsal> ha.  I used to do it all in docker/qemu.  I think lately I've been running on AWS.
11:55:49 <koz_> Ah.
11:55:57 <dsal> I've not actually done a build lately.
11:56:30 <dsal> If I actually do this project I've been poking around at, I might need another build.
11:56:51 <koz_> dsal: Well, I've been thinking of getting myself an ARMv7 thing from Hardkernel.
11:56:58 <koz_> Might offer it to the community as a build bot lol.
11:57:46 <dsal> Wiring such a thing into github would be pretty great.  I need to figure out how to do that since I'm doing it for x86 linux and mac.  Might as well just have all the binaries for all the pushes.
11:58:22 <koz_> There's probbo a way? 
11:58:24 * koz_ shrugs.
12:06:40 <win2ero> Hello
12:07:23 <koz_> win2ero: Sup?
12:07:36 <win2ero> I am new to haskell and taking a course. I need to do a homework about a guide to setup a framework
12:07:41 <win2ero> but i am getting this error
12:07:51 <win2ero> <interactive>:1:24: error:    * Couldn't match expected type `Text' with actual type `[Char]'    * In the `name' field of a record      In the first argument of `encode', namely        `Person {name = "Leela", age = 25}'      In the expression: encode (Person {name = "Leela", age = 25})
12:07:58 <win2ero> i am following this guide
12:08:07 <win2ero> https://www.spock.li/tutorials/rest-api
12:08:24 <win2ero> i try to look for the error in the code
12:08:28 <win2ero> i have so far this
12:08:37 <win2ero> {-# LANGUAGE DeriveGeneric     #-}{-# LANGUAGE OverloadedStrings #-}import           Web.Spockimport           Web.Spock.Configimport           Data.Aeson       hiding (json)import           Data.Monoid      ((<>))import           Data.Text        (Text, pack)import           GHC.Genericsdata Person = Person  { name :: Text  , age  :: Int  }
12:08:37 <win2ero> deriving (Generic, Show)instance ToJSON Personinstance FromJSON Person
12:08:45 <hseg_> testcase is looping, how do i get ghc to blame the culprit?
12:09:05 <koz_> win2ero: Yeah, please don't paste into IRC. Use like, Github gist or something.
12:09:13 <koz_> hseg_: QuickCheck?
12:09:19 <win2ero> ok sorry, i am new here
12:09:21 <hseg_> yeah
12:09:30 <koz_> hseg_: Is the arbitrary instance generating a recursive structure?
12:09:35 <koz_> s/arbitrary/Arbitrary/
12:09:57 <hseg_> not afaict. but does have a chain of derivations
12:10:07 <win2ero> {-# LANGUAGE OverloadedStrings #-} this supose to allow me get String as text
12:10:17 <win2ero> but isn't working
12:10:22 <koz_> hseg_: Did you define a shrink method?
12:10:25 <hseg_> no
12:10:31 <hseg_> should i have?
12:10:38 <xsperry> win2ero, do you have a test case, with errors
12:10:39 <dsal> win2ero: what's giving you the error?
12:10:45 <koz_> hseg_: Not necessarily, but it can be a cause if badly done.
12:10:48 <dsal> Looks like ghci
12:10:54 <win2ero> encode Person { name = "Leela", age = 25 }
12:11:00 <hseg_> :(
12:11:06 <hseg_> ok, will give it a try
12:11:18 <koz_> hseg_: Can you paste the data definitions and their Arbitrary instance(s)?
12:11:22 <koz_> I might be able to spot the problem.
12:11:23 <dsal> win2ero: :set -XOverloadedStrings
12:11:32 <win2ero> i did
12:11:54 <win2ero> no, wait where
12:12:07 <xsperry> try this in ghci:  "Leela" :: Text
12:12:25 <dsal> In ghci where you got the error message.
12:12:35 <hseg_> koz_: have a dozen different instance declarations, think it'd be better to narrow it down first
12:12:44 <win2ero> yes
12:13:15 <win2ero>  Couldn't match expected type `text1' with actual type `[Char]'
12:13:19 <koz_> hseg_: Well, the two most common causes of looping QuickCheck are recursive structures without termination conditions in the Arbitrary instance, or shrink methods without non-shrinking cases.
12:14:11 <dsal> win2ero: now try it with overloaded strings
12:15:52 <win2ero> sorry i dont know how to do it?
12:16:14 <win2ero> i have this on my file
12:16:15 <hseg> koz_: instance defns at http://ix.io/2kEJ, many of these are newtypes
12:16:16 <win2ero> {-# LANGUAGE OverloadedStrings #-}
12:16:37 <dsal> win2ero: you can paste in the thing I suggested earlier
12:17:03 <hseg> most probable cause of looping is a type iso to Map (Vector n Int) Rational
12:17:21 <hseg> which is using the derived Arbitrary instance
12:17:36 <win2ero> i got a error
12:17:54 <win2ero> variable not in scope
12:18:11 <koz_> hseg: ... yeah, I see what you mean, since your very first lines are a bunch of type classes whose meaning I cannot establish.
12:18:16 <koz_> And whose laws I don't know.
12:18:51 <hseg> the first couple of lines are just typeclass aliases for abbreviation's sake
12:19:06 <hseg> basically newtypes for constraints
12:19:10 <koz_> hseg: Yeah... don't do that.
12:19:15 <koz_> It doesn't work how you expect and it's confusing.
12:19:19 <hseg> why not?
12:19:20 <koz_> Just spell your constraints.
12:19:51 <koz_> That alone will likely help you spot your problem.
12:20:01 <hseg> why encourage needless repetition?
12:20:09 <hseg> anyway, testcase *did* end up finishing
12:20:25 <hseg> just taking 10m on two heavy properties
12:20:46 <koz_> What's the discard count like?
12:20:54 <koz_> If you're discarding heavily, that's a possible cause.
12:21:28 <hseg> nope. having ~15 discards in some other tests, but none are reported for these
12:21:43 <koz_> Hmm.
12:21:50 <koz_> Try forcing a smaller size on those tests?
12:21:55 <koz_> (like, try forcing a size of like, 15)
12:21:59 <koz_> (and see if that helps any)
12:21:59 <hseg> how?
12:22:27 <hseg> also, just had an idea -- changed an internal function to sort its inputs instead of expecting them to be presorted
12:22:42 <hseg> this made tests pass, but i suspect it might make them expensive
12:22:53 <koz_> What are you sorting, of what length, using what method?
12:23:15 <koz_> This can force a size: https://hackage.haskell.org/package/QuickCheck-2.14/docs/Test-QuickCheck.html#v:resize
12:23:26 <koz_> You can also use scale just underneath it.
12:23:30 <hseg> list of key-value pairs, should be <10 elems in length, using Data.List.sortOn
12:23:42 <koz_> Yeah, that won't take long.
12:24:01 <hseg> ... actually, before pointing any fingers, should use profiler to check my hunch
12:24:15 <hseg> have had enough wild goose chases on this project
12:24:22 <hseg> how do i profile a testcase?
12:25:51 <hseg> ok, will go through https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/profiling.html, see who's to blame
12:26:22 <koz_> hseg: I think you can request the whole thing build with profiling, then just run the test binary that results?
12:33:19 <statusbot> Maintenance update: Scheduled Hackage maintenance downtime imminent... -- http://status.haskell.org/pages/maintenance/537c07b0cf1fad5830000093/5eaf093b2d75b004bc2c7bf0
12:36:32 <Uniaika> bgamari: hi, I don't know if you're also responsible for this, but http://auto-status.haskell.org/ (as advertised in status.haskell.org's bannerl) doesn't lead to anywhere
12:37:23 <bgamari> Uniaika, I'm not but I know that it's a known issue
12:39:12 <Uniaika> bgamari: may I ask you who's the person I need to spam (if they don't already know)?
12:39:15 <Uniaika> :)
12:39:35 <bgamari> Uniaika, I believe sclv already knows about it
12:39:53 <bgamari> I think he's looking for a new provider for the serve
12:39:56 <bgamari> service*
12:40:05 <sclv> Our provider shut down
12:40:59 <sclv> if you know of a monitoring service that will provide free service to free software or nonprofits please let us know!!
12:43:05 <lambada-calculis> I would like feedback on project, if anyone's willing to take a look https://gitlab.com/lambadacalculist/consummate-cxx
12:46:42 <Uniaika> sclv: if I hear of such a gem I'll let you know. :) 
12:59:14 * hackage hlint 3.0.4 - Source code suggestions  https://hackage.haskell.org/package/hlint-3.0.4 (NeilMitchell)
13:00:44 * hackage ghc-boot-th 8.10.1 - Shared functionality between GHC and the `template-haskell`library  https://hackage.haskell.org/package/ghc-boot-th-8.10.1 (HerbertValerioRiedel)
13:05:59 <fendor_> is there some simple library that provides an edsl that can be dumped to markdown?
13:06:14 * hackage digest-sig 0.1.0.0 - Signature for digest  https://hackage.haskell.org/package/digest-sig-0.1.0.0 (vmchale)
13:12:15 * hackage zeolite-lang 0.3.0.0 - Zeolite is a statically-typed, general-purpose programming language.  https://hackage.haskell.org/package/zeolite-lang-0.3.0.0 (ta0kira)
13:14:45 * hackage template-haskell 2.16.0.0 - Support library for Template Haskell  https://hackage.haskell.org/package/template-haskell-2.16.0.0 (HerbertValerioRiedel)
13:36:09 <statusbot> Maintenance update: Hackage maintenance window is over and Hackage is operational again. Let us know if you notice any issues. -- http://status.haskell.org/pages/maintenance/537c07b0cf1fad5830000093/5eaf093b2d75b004bc2c7bf0
13:40:39 <dmj`> fendor_: pandoc?
13:41:38 <fendor_> dmj`, a bit huge but I think it provides an edsl that can be rendered to markdown
13:41:51 <raehik> hi folks, I'm trying to flatten a NonEmpty list of NonEmpty lists, and I can't figure out how to do it. all the base functions for folding/concatting work on lists, not NonEmptys
13:42:12 <dmj`> fendor_: why not just write markdown
13:42:23 <solonarv> raehik: NonEmpty is a monad, so you can use 'join'
13:42:29 <solonarv> % :t join @NonEmpty
13:42:29 <yahb> solonarv: ; <interactive>:1:7: error:; Not in scope: type constructor or class `NonEmpty'; Perhaps you meant `NonEmptyF' (imported from Data.Functor.Base)
13:42:45 <solonarv> % import Data.List.NonEmpty
13:42:45 <yahb> solonarv: 
13:42:46 <solonarv> % :t join @NonEmpty
13:42:47 <yahb> solonarv: NonEmpty (NonEmpty a) -> NonEmpty a
13:43:09 <solonarv> it's also Foldable and a Monoid, so 'fold' would work too:
13:43:14 <dmj`> fendor_: if you're generating it pandoc will give you an AST that can a pretty print as markdown
13:43:16 <fendor_> dmj`, because I want to print a haskell data structure into a markdown report
13:43:25 <solonarv> % :t fold @NonEmpty @(NonEmpty _)
13:43:25 <yahb> solonarv: Monoid (NonEmpty _) => NonEmpty (NonEmpty _) -> NonEmpty _
13:43:34 <dmj`> fendor_: I'd use generics for this
13:43:46 <solonarv> ...huh?
13:43:49 <dmj`> instance ToMarkdown YourType
13:44:10 <koz_> solonarv: NonEmpty isn't a monoid.
13:44:15 <koz_> (what would mempty be?)
13:44:17 <fendor_> the type doesnt translate 1:1 to the report structure
13:44:22 <solonarv> koz_: oh, of course
13:44:29 <koz_> :t sconcat
13:44:30 <dmj`> fendor_: or is it as simple as wrapping it in ```haskell\n <haskell-code-goes-here> \n```
13:44:30 <lambdabot> error:
13:44:30 <lambdabot>     • Variable not in scope: sconcat
13:44:30 <lambdabot>     • Perhaps you meant one of these:
13:44:34 <koz_> % :t sconcat
13:44:35 <yahb> koz_: ; <interactive>:1:1: error:; * Variable not in scope: sconcat; * Perhaps you meant one of these: `mconcat' (imported from Prelude), `V.concat' (imported from Data.Vector), `BSL.concat' (imported from Data.ByteString.Lazy)
13:44:45 <koz_> ARGH what's the mconcat thing from Semigroup?
13:44:45 <solonarv> % :t Data.Semigroup.sconcat
13:44:45 <yahb> solonarv: Semigroup a => NonEmpty a -> a
13:44:51 <koz_> Yeah, that'd do it.
13:44:59 <koz_> Since NonEmpty _is_ a Semigroup.
13:45:07 <koz_> (or at least ought to be)
13:45:09 <fendor_> dmj`, no it is not. For context, I ran some tests on haskell code, gathered the results and now I am looking for a nice human readable output format
13:45:17 <raehik> koz_: right I thought using the Semigroup instance was the right way. but I got sth wrong
13:45:21 <fendor_> I thought markdown is nice
13:45:22 <solonarv> % :t Data.Semigroup.sconcat @(NonEmpty _)
13:45:22 <yahb> solonarv: NonEmpty (NonEmpty _) -> NonEmpty _
13:45:32 <solonarv> yup. (see how the constraint isn't there anymore)
13:45:41 <dmj`> fendor_: is the test output machine readable
13:45:56 <fendor_> dmj`, yeah, json. 
13:47:00 <raehik> solonarv, koz_ thx, a bit lost but I'll play with that
13:47:14 <koz_> raehik: If you want, pastebin what you've got and we can try and assist.
13:48:01 <fendor_> btw, with "ran some tests on haskell code", I mean I executed some tests on students submission and now I want to present students a pretty report of their test-results
13:48:58 <solonarv> raehik: the '@something' notation I used here is called "type applications" and I am using it to specialize the type of some general function
13:49:37 <solonarv> for example the type of 'join' is 'forall m a. Monad m => m (m a) -> m a', and with 'join @NonEmpty' I can say "I want 'm' to be 'NonEmpty'"
13:49:38 <dmj`> fendor_: ahh, very cool
13:50:05 <dmj`> fendor_: are you automating this on github PR webhook events ? So you can post a response as markdown on github
13:50:10 <sm[m]> pandoc has a generic data model you can render to whatever
13:51:09 <fendor_> dmj`, unfortunately not, the course I am doing this is not ready for this century. Up until this semester, hugs was used to evaluate submissions
13:51:20 <solonarv> fendor_: yikes! how ancient
13:51:35 <dmj`> fendor_: oh wow, that's great. 
13:51:50 * sm[m] backpedals fast
13:52:34 <dmj`> GHC is becoming a too big to fail monolith maybe we should all go back to hugs
13:52:36 <raehik> solonarv: I see, hadn't actually seen that before
13:53:07 <dmj`> fendor_: I'd just parse the JSON into some ADT, and then pretty print it as Markdown (using string concatenation). Or you could introduce your own IR for markdown, and then translate to that, then pretty print it
13:53:08 <fendor_> hugs is increasingly hard to install on some systems
13:53:23 <dmj`> nix-repl> hugs
13:53:23 <dmj`> «derivation /nix/store/sa0jr16bbvwyc1bglzxdixdvhwgs81s6-hugs98-200609.drv»
13:53:28 <fendor_> dmj`, yeah, I am currently tending to create my own IR
13:53:29 <sm[m]> and now I see dmj` already mentioned pandoc, and I kind of wish we had zulip's feature of grouping by topic
13:53:29 <dmj`> problem solved :)
13:54:29 <raehik> sconcat is exactly what I wanted, not sure how I missed it. wanted a megaparsec parser that parses 1 or more blocks
13:54:48 <dmj`> sm[m]: we should have put a GUI on IRC, could've been a billion dollar company like slack. Really missed the boat on that one
13:55:02 <dsal> That's irccloud.  It's nice.
13:55:02 <raehik> thank yall very much for the help. every day using Haskell it becomes increasingly clear how much there is to learn 6_9
13:55:09 <dsal> Doesn't do threading, though.  Not enough info, really.
13:55:32 <dmj`> dsal: yea but the Javascript programmer Hordes have chosen slack
13:55:39 <sm[m]>  I'm really quite impressed with zulip. And it can bridge to irc
13:55:42 <solonarv> teaching to a compiler/interpreter that has not been updated in nearly 14 years seems like a suboptimal choice :/
13:55:44 <dmj`> dsal: plus the emoji game is weak on irccloud (I use it btw)
13:56:13 <sm[m]> matrix needs to steal that topic feature
13:56:17 <dsal> slack makes me pretty sad.  It used to bridge to irc, but they killed that off.  irccloud can integrate with slack, but most don't because of licensing issues.
13:56:26 <dmj`> fendor_: yea if you don't need the full markdown AST better off defining just a subset, I do this for GHC plugins, since the GHC AST is a giant anaconda monster
13:57:22 <fendor_> dmj`, probably going to do that, thanks! 
13:59:41 <dmj`> cheers
14:01:21 <quinn> i have a function 'a :: IO String', and i want to print it. is it stupid to to 'join $ print <$> a' ?
14:01:47 <dsal> quinn: print =<< a
14:02:20 <dsal> or `a >>= print` if you're left-handed
14:02:46 <Taneb> quinn: that's certainly a reasonable solution that'll do what you want. However, as dsal points out, you can use (=<<) for something more succinct
14:03:50 <quinn> oh my god. i'm been fumbling around incorrectly using (>>=) everywhere but that function. thank you both. (:
14:04:01 <dsal> Do you use do blocks?
14:04:19 <dsal> @undo do { v <- a; print v }
14:04:19 <lambdabot> a >>= \ v -> print v
14:04:48 <dsal> that + η-reduce and then switch directions if you want.
14:05:46 <quinn> dsal: oh that's a cool bot feature. i've been writing stuff in do notation and then trying to write it more succintly once i know my idea works. i was misusing 'return' when i tried to use do-notation for that function though
14:06:14 <quinn> i'm afraid i don't really know what you mean when you say n-reduce and switch directions though
14:06:17 <dsal> return is confusing.
14:06:50 <dsal> Not n, η  :p      `f x = g x`    is the same thing as    `f = g`
14:07:08 <solonarv> specifically, return is confusingly *named*
14:07:31 <dsal> Yeah, I guess as a concept return is fine, but I wouldn't use its name in my code.
14:07:41 <quinn> dsal: isn't that currying?\
14:08:00 <solonarv> especially confusing to people coming from imperative languages, where 'return' does control flow
14:08:04 <solonarv> in Haskell it does not!
14:08:17 <dsal> quinn: No, it's η-reduction.  You don't need to put the same thing on both side of an equation.
14:08:25 <solonarv> (it also isn't a keyword, just a library function)
14:09:12 <quinn> dsal: does that work via partial application, or is it something else?
14:09:41 <dsal> quinn: In this case in particular, @undo is suggesting making a lambda function that takes a parameter and names it `v` and then passes it to a function that takes a parameter.  That's the same thing as not doing all that extra work.
14:11:25 <quinn> dsal: yeah, i ran into that un-doing a few other functions. partial application is one of my favorite features of haskell
14:14:44 * hackage ztar 1.0.2 - Creating and extracting arbitrary archives  https://hackage.haskell.org/package/ztar-1.0.2 (brandonchinn178)
14:15:09 <dsal> quinn: it's not even partial application, though.
14:15:11 <dsal> :t print
14:15:12 <lambdabot> Show a => a -> IO ()
14:15:16 <dsal> :t \x -> print x
14:15:17 <lambdabot> Show a => a -> IO ()
14:15:59 <dsal> :t \x -> (\y -> print y) x
14:16:00 <lambdabot> Show a => a -> IO ()
14:16:14 <dsal> Like, you can keep adding complication...  but print just wants a single parameter.
14:16:43 <quinn> okay, it looks like i thought partial application referred to a broader set of features than it does. η-reduction is what i like i guess. either way, very nice
14:16:53 <quinn> thank you for the help!
14:17:34 <solonarv> note, eta reduction is a specific program transformation
14:18:01 <dsal> :t subtract 1   -- subtract is partially applied here since it wants two things and I'm only giving it one.
14:18:02 <lambdabot> Num a => a -> a
14:18:19 <solonarv> it turns '(\y -> f y)' into 'f', or 'f x = g x' into 'f = g'
14:18:26 <dsal> solonarv: Do you think "don't make a lambda" is outside of the scope?
14:18:36 <JohnnyL> Consuming animals torturously is what Corona is all about. We need to learn this lesson. It started with animals as it will end with animals. The Earth is a Living Library and we need to respect it. All of it!
14:18:51 <dsal> JohnnyL: even haskell irc channels?
14:18:53 <koz_> @where ops
14:18:53 <lambdabot> byorgey Cale conal copumpkin dcoutts dibblego dolio edwardk geekosaur glguy jmcarthur johnw mniip monochrom quicksilver shachaf shapr ski
14:18:54 <solonarv> that's all eta reduction is. it is not currying and it is not partial application.
14:19:30 <solonarv> dsal: if you make a lambda that you can eta-reduce away, you should eta-reduce it away
14:19:49 <solonarv> if you are working through program transformations it is better IMO to not skip over too many intermediate steps
14:20:20 <quinn> why is that?
14:20:37 <dsal> I guess @undo shouldn't do that, as it demonstrates what happens, but in a way I would hope people wouldn't write in general.
14:20:41 --- mode: ChanServ set +o dibblego
14:22:27 --- mode: ChanServ set +o shapr
14:22:46 <shapr> JohnnyL: off topic, please move those sorts of comments to other channels
14:30:14 * hackage serverless-haskell 0.11.2 - Deploying Haskell code onto AWS Lambda using Serverless  https://hackage.haskell.org/package/serverless-haskell-0.11.2 (AlexeyKotlyarov)
14:32:06 <solonarv> @. pl undo do { v <- f; print v }
14:32:06 <lambdabot> print =<< f
14:32:09 <solonarv> \o/
14:32:41 <solonarv> dsal: look!
14:32:43 <dsal> Heh.  lambdabot is neat.
14:34:51 <koz_> It is indeed.
14:35:17 <dsal> @. do undo do a
14:35:18 <lambdabot> a
14:37:15 * hackage base 4.14.0.0 - Basic libraries  https://hackage.haskell.org/package/base-4.14.0.0 (HerbertValerioRiedel)
14:38:27 <koz_> Wooooo.
14:38:44 <koz_> > Data.Ord.Down now has a field name, getDown
14:38:45 <lambdabot>  <hint>:1:35: error: parse error on input ‘,’
14:38:47 <koz_> Awww yisss.
14:39:03 <dsal> Nice.
14:39:15 * hackage serverless-haskell 0.11.3 - Deploying Haskell code onto AWS Lambda using Serverless  https://hackage.haskell.org/package/serverless-haskell-0.11.3 (AlexeyKotlyarov)
14:39:20 <koz_> > Add Functor, Applicative, Monad, Alternative, MonadPlus, Generic and Generic1 instances to Kleisli
14:39:22 <lambdabot>  <hint>:1:12: error: parse error on input ‘,’
14:39:25 <koz_> :party hat emoji:
14:39:43 <solonarv> :O
14:39:49 <solonarv> finally! it's on hackage!
14:39:55 <koz_> > Add IsList instance for ZipList.
14:39:57 <lambdabot>  <hint>:1:12: error: parse error on input ‘instance’
14:39:59 <koz_> :party hat emoji:
14:40:11 <solonarv> koz_: maybe add a space before the > so you don't make lambdabot sad :/
14:40:19 <koz_> solonarv: Yah, my bad.
14:40:33 <solonarv> Huh. base-4.13 is still not on hackage, though.
14:40:47 <sm[m]> the daily lament
14:40:50 <d34df00d> I propose a new game of reverse code golf.
14:40:51 <koz_> solonarv: I think there's some issue with the building of its docs. Perhaps we'll see it momentarily?
14:41:02 <koz_> d34df00d: That's easy. Rewrite in Java. :P
14:41:02 <d34df00d> Let's say we want to count the lengths of longest runs of a letter in a string.
14:41:05 <dsal> d34df00d: code cricket?
14:41:13 <d34df00d> dsal: sorta.
14:41:22 <d34df00d> So my solution to the task is `runs = M.fromListWith max . map (head &&& length) . group`
14:41:35 <d34df00d> On "aabccaaab" it outputs `fromList [('a',3),('b',1),('c',2)]`
14:41:37 <d34df00d> You get the idea.
14:41:56 <d34df00d> How would you make it most algebraically convoluted, bringing as much abstractions as possible?
14:42:24 <dsal> I do that sometimes, but it's more like, "OK, this works, but how can I use lens?"
14:42:30 <koz_> dsal: Rofl.
14:42:36 <koz_> That could be the challenge in itself.
14:42:43 <d34df00d> You can take a  s t a b   at using lenses.
14:42:44 <koz_> Rewrite d34df00d's solution, only lens operators allowed.
14:42:47 <dsal> haha
14:43:15 <dsal> I'm writing an mqtt server on account of because.
14:43:25 <koz_> Bonus points if its type signature involves really gory things.
14:43:35 <d34df00d> And requires -XImpredicativeTypes.
14:43:59 <koz_> First International Obfuscated Lens Contest when.
14:44:06 <c_wraith> if it requires -XImpredicativeTypes and compiles too, even better.
14:44:21 <iqubic> Hey, I can read Lens type signatures real well.
14:44:30 <koz_> :t confusing
14:44:31 <lambdabot> Applicative f => LensLike (Data.Functor.Day.Curried.Curried (Data.Functor.Yoneda.Yoneda f) (Data.Functor.Yoneda.Yoneda f)) s t a b -> LensLike f s t a b
14:44:37 <koz_> iqubic: ^
14:44:39 <c_wraith> :t makesSense
14:44:40 <lambdabot> error:
14:44:41 <lambdabot>     • Variable not in scope: makesSense
14:44:41 <lambdabot>     • Perhaps you meant ‘makeLenses’ (imported from Control.Lens)
14:44:44 --- mode: shapr set -o shapr
14:44:47 <solonarv> one step would be: use the Max monoid and AppendMap (or whatever it is called)
14:44:47 <dsal> hahaha
14:45:13 <dsal> c_wraith: You seem to be trying to make sense.  Wouldn't you rather make lenses?
14:45:14 <iqubic> Alright, that one is confusing, because I have no idea what a Yoneda is. All I know is that there's a lemma called the Yoneda Lemma.
14:45:15 * hackage futhark 0.15.6 - An optimising compiler for a functional, array-oriented language.  https://hackage.haskell.org/package/futhark-0.15.6 (TroelsHenriksen)
14:45:32 <d34df00d> It's indeed confusing, the name says so!
14:45:40 <dsal> iqubic: I believe yoneda is a kanye west album.
14:45:47 <koz_> d34df00d: It's also a hilarious pun, because it's designed to aid fusion by reassociating things.
14:46:08 <d34df00d> I should learn more optics really.
14:46:09 <koz_> (so 'con' as in 'with' and 'fusion')
14:46:12 <d34df00d> All those jokes just fly past me.
14:46:49 <dsal> lens is often a simple and straightforward way to solve a problem.
14:47:03 <d34df00d> solonarv: doesn't AppendMap require maps explicitly (and thus too straightforward for the task)?
14:47:18 <d34df00d> dsal: regexps are often a simple and straightforward way to solve a problem too!
14:47:28 <solonarv> oh sure, it is not all the way up the ladder
14:47:35 <dsal> d34df00d: There are regex optics.
14:47:37 <solonarv> but it is a few rungs above your nice straightforward solution!
14:48:03 <dsal> But I almost always find regex to be a bad idea.  lens is sometimes the best thing.
14:48:09 <d34df00d> How can you call it nice if it's straightforward!
14:48:24 <solonarv> hm, I don't think regex makes a valid Traversal. Unfortunate.
14:48:31 <solonarv> (for the same reason 'filtered' doesn't)
14:49:44 <koz_> :t isn't
14:49:45 <lambdabot> APrism s t a b -> s -> Bool
14:49:48 <koz_> Sheer naming genius.
14:50:03 <dsal> :t ain't
14:50:04 <lambdabot> error: Variable not in scope: ain't
14:50:11 <koz_> isn't = hasn't
14:50:17 <koz_> Lol lens.
14:50:34 <iqubic> Chris Penner made this blog post about lens-regex-pcre, which is a library he made.
14:50:35 <iqubic> https://chrispenner.ca/posts/lens-regex-pcre
14:50:39 <d34df00d> I somehow find ' in the middle of the names beyond evil.
14:50:43 <iqubic> I recommend reading it.
14:51:29 <pie_> can I override the GHCi pretty printer somehow?
14:51:38 <pie_> (without recompiling ghc)
14:51:56 <dsal> d34df00d: there's more middle than ends.
14:52:01 <dsal> protoLens makes good use of that.
14:52:31 <koz_> :t itakingWhile
14:52:32 <lambdabot> (Indexable i p, Contravariant f, Profunctor q, Applicative f) => (i -> a -> Bool) -> Optical' (Indexed i) q (Const (Endo (f s))) s a -> Optical' p q f s a
14:52:38 <koz_> iqubic: Have fun with that one too.
14:52:47 <iqubic> I love itakingWhile
14:53:19 <dsal> I know what all those words mean, but that type is a bit hard to read.
14:53:31 <iqubic> I can read it we enough.
14:54:14 <aviD> stack test with hspec highlights the diff of "expected" and "but got", is there a way to get cabal test to do the same?
14:54:24 <dsal> :t takingWhile
14:54:26 <lambdabot> (Conjoined p, Applicative f) => (a -> Bool) -> Over p (Control.Lens.Internal.Magma.TakingWhile p f a a) s t a a -> Over p f s t a a
14:54:55 <koz_> Someone needs to write 'Introduction to Algorithms with Lens'.
14:57:36 <koz_> Preferably while doing like, Richard Bird-style stuff.
15:01:58 <iqubic> So, like Optics By Example, but with Richard Bird algorithms?
15:02:19 <iqubic> I'm not sure you can sort a foldable with lenses.
15:02:20 <koz_> iqubic: Yes.
15:02:30 <koz_> iqubic: You can't sort a foldable with _anything_ in general.
15:02:36 <koz_> (Traversable is possible)
15:03:37 <iqubic> Would it be a lawful traversable.
15:06:19 <koz_> iqubic: It's not about the Traversable.
15:06:31 <koz_> There's a technique for nlog(n) sorting any Traversable as long as it's full of Ord as.
15:06:52 <koz_> I've not seen it extended to non-comparison sorts, but I _guess_ it's doable?
15:10:17 <koz_> iqubic: Original idea - https://elvishjerricco.github.io/2017/03/23/applicative-sorting.html
15:10:30 <koz_> Improved O(n log(n)) version: https://github.com/treeowl/sort-traversable
15:13:35 <koz_> :t build
15:13:36 <lambdabot> error:
15:13:36 <lambdabot>     • Variable not in scope: build
15:13:36 <lambdabot>     • Perhaps you meant ‘buildG’ (imported from Data.Graph)
15:13:41 <koz_> % :t build
15:13:42 <yahb> koz_: (forall b. (a -> b -> b) -> b -> b) -> [a]
15:13:56 <koz_> Ah, right, so that's how you do it.
15:18:15 * hackage ghci 8.10.1 - The library supporting GHC's interactive interpreter  https://hackage.haskell.org/package/ghci-8.10.1 (HerbertValerioRiedel)
15:21:07 <koz_> So a Boehm-Beraducci encoding of Maybe is like (forall b . b -> (a -> b) -> b) ?
15:21:44 <koz_> And (,) would be (forall c . (a -> b -> c) -> c)?
15:22:32 <d34df00d> Looks so.
15:22:41 <koz_> d34df00d: Yay!
15:22:48 <c_wraith> It's a very mechanical translation.
15:22:55 <koz_> c_wraith: Yeah, it is.
15:22:57 <c_wraith> See also "fold" :)
15:23:22 <koz_> Basically 'encode every constructor as a function ending in your foralled thing, then have each of those as an argument to a HOF that ends in your foralled thing'.
15:23:44 <koz_> c_wraith: What does fold have to do with it?
15:23:46 <koz_> :t fold
15:23:47 <c_wraith> that encoding is the catamorphism for a type.
15:23:47 <lambdabot> (Foldable t, Monoid m) => t m -> m
15:23:56 <d34df00d> I think Girard's "Proofs and Types" has it most straightforward (at least it was enlightening for me).
15:24:02 <d34df00d> Don't remember the chapter tho.
15:24:11 <koz_> d34df00d: I'm reading it right now. It's the Frenchest thing I've read in forever, even in translation.
15:24:25 <koz_> Like, straight up opens with a philosophical question worthy of like, Derrida. :P
15:24:27 <d34df00d> I bet you haven't read anything in Coq have you?
15:24:32 <koz_> d34df00d: Nope.
15:24:40 <c_wraith> koz_: not the function fold, just the idea.
15:24:45 <koz_> c_wraith: Oh, OK.
15:24:56 <koz_> Now I get you.
15:25:11 <d34df00d> Well, philosophically it's also cool.
15:25:31 <d34df00d> I mean, I've heard from numerous folks whose first language is English that French stuff is hard to read for them even in translation.
15:25:38 <d34df00d> It was kinda hard to read for me as well :)
15:25:55 <koz_> d34df00d: It's not hard, it's just very different to what I'm used to from logic books.
15:26:11 <koz_> They don't usually go that philosophical on you that fast. :P
15:26:33 <koz_> Eminently readable book though.
15:26:48 <koz_> c_wraith: Is there a dual encoding of the anamorphism for the type?
15:27:07 <solonarv> pie_: yes, it's something like ':set interactive-print myFunction'
15:27:11 <Nolrai> I am totaly just..like I don't really belive that the bug I see is happening.
15:27:22 <koz_> Nolrai: Lol, welcome to my life every day.
15:27:30 <d34df00d> Things got really messy for me around 
15:27:35 <d34df00d> the chapters on coherence spaces.
15:28:04 <c_wraith> koz_: not with a name I'm aware of, but look at unfoldr for how you'd have to construct it.
15:28:33 <koz_> So the foralled thing is what you'd have to _start_ with.
15:28:44 <koz_> Kinda like, the foralled thing in B-B is the 'target' or 'result'.
15:28:48 <koz_> But here it's the 'seed'?
15:28:54 <Nolrai> So like every few 10,000s of thousands to times, I will select a key from the keys of a IntMap, and then lookup with that key and get Nothing.
15:29:12 <c_wraith> koz_: I think that's focusing on the wrong part.
15:29:25 <koz_> c_wraith: I'm not sure I follow.
15:29:56 <Nolrai> d34df00d: what book you talking about.
15:30:08 <d34df00d> Nolrai: Girard's "Proofs and Types"
15:30:12 <koz_> Nolrai: https://github.com/treeowl/sort-traversable
15:30:14 <koz_> Nope, sorry.
15:30:19 <koz_> http://www.paultaylor.eu/stable/Proofs+Types.html
15:30:21 <koz_> That one.
15:30:34 <d34df00d> koz_: my intuition is that you only need (inductive) types to consume them.
15:30:52 <d34df00d> So in a sense you only really care about the shape of them and the recursively obtained results of such consumption.
15:31:15 <koz_> d34df00d: Hmm.
15:31:43 <d34df00d> So writing a function over say a Nat is equivalent to supplying an object of type Nat with a pair of functions — what to do if it's zero (so that's a constant function) and what to do if it's non-zero (based on the result on a smaller number).
15:32:21 <d34df00d> And then Nat gives you back your result.
15:32:25 <koz_> d34df00d: Are you describing B-B here?
15:32:27 <d34df00d> Yea.
15:32:43 <Nolrai> Here is the paste bin of what's happening, I am sorry its so opaque but I don't feel comfortable changing things when its behaving so strangely. https://pastebin.com/1uhiYrU7
15:33:22 <koz_> d34df00d: So how would that translate to co-B-B that I'm considering? I have a good sense for B-B, but I'm pretty sure there's a dual.
15:33:38 <Nolrai> I guess I could just use vectors of pairs instead of a IntMap..
15:33:43 <d34df00d> I don't have a good intuition or model for co-B-B, lol.
15:33:58 <koz_> :t unfoldr
15:33:59 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
15:34:06 <Nolrai> Which is BB?
15:34:13 <koz_> Nolrai: Boehm-Beraducci.
15:34:45 <koz_> :t foldr
15:34:47 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
15:34:56 <Nolrai> I guess my question then woulbe 'co' in what category?
15:35:54 <koz_> Nolrai: I was being somewhat informal. B-B, as c_wraith so eloquently said, is a catamorphism for the type.
15:36:07 <koz_> So my question is 'do we have an analogous encoding for the _ana_morphism of the type?'.
15:36:14 <Nolrai> Ah.
15:37:01 <d34df00d> I think co-B-B would do something with coinductive types.
15:37:20 <d34df00d> But I don't have neither a good intuition nor good experience there.
15:39:46 <Nolrai> I think it might just be the inverse of the B-B transform, i.e. take you from a BB type to a inductive deffinition.
15:41:08 <koz_> Nolrai: There is something like that in the foldr/unfoldr juxtaposition I have up there.
15:41:34 <koz_> Since in foldr, we have ((a -> b -> b) -> b), but in unfoldr, (b -> (Maybe a, b))
15:48:25 <pie_> solonarv: oh hm cool ill look into it thanks
15:48:50 <pie_> i was peeking through the ghci source at one point trying to figure out how something works and that sounds familiar
15:52:04 <pie_> hm :help shows stuff like :set prompt-function but nothing for the pretty printer...
15:52:07 <pie_> at least not in 8.6.5
15:52:30 <pie_> doh https://hackage.haskell.org/package/ghci-pretty
15:52:37 <pie_> not sure what keywords i used the first time
15:53:53 <pie_> solonarv: <3 thats soooo much better
16:30:45 * hackage ghc 8.10.1 - The GHC API  https://hackage.haskell.org/package/ghc-8.10.1 (HerbertValerioRiedel)
16:36:19 <Axman6> :o
16:58:45 * hackage hip 1.5.6.0 - Haskell Image Processing (HIP) Library.  https://hackage.haskell.org/package/hip-1.5.6.0 (lehins)
17:17:39 <tukane> I have a question regarding DataKinds. In this code, is there a way to examine what Tag is attached to Foo in the funciton `processFoo` ? https://pastebin.com/DmJ06JPC
17:19:07 <c_wraith> tukane: No, you've thrown out the information
17:20:00 <c_wraith> tukane: if you want to recover it, you need Tagged to have different constructors for each Tag
17:25:57 <tukane> c_wraith: thanks for the info. I thought it's possible extract TagA or TagB in a similar mechanism to that of natVal in GHC.TypeLits
17:26:36 <c_wraith> You could do something with a typeclass, but then the existential would need to hold that too.
17:27:49 <c_wraith> and at runtime, it amounts to passing a second value as an extra tag
17:31:15 * hackage greskell-websocket 0.1.2.2 - Haskell client for Gremlin Server using WebSocket serializer  https://hackage.haskell.org/package/greskell-websocket-0.1.2.2 (debugito)
17:31:21 <tukane> Thanks. I think I'd need to read something to understand that. Even after reading TaPL and playing with Coq, dependently typed programming in Haskell is hard for me...
17:32:12 <c_wraith> the thing is, *something* must exist at runtime to make a choice
17:32:37 <c_wraith> Either multiple constructors or an extra value (like a type class dictionary) or some other stuff
17:35:58 <p0a> hello I am transversing a list 
17:36:09 <p0a> I want to transform that list into something else but at the same time find its maximum and minimum
17:36:25 <p0a> is it unnecessary optimization to combine these operations into one? i.e. only transverse once
17:37:10 <p0a> i.e. imagine I want to do reverse list but also find its maximum
17:37:40 <c_wraith> Sometimes doing it as a single pass really does make an important difference.
17:37:53 <p0a> and how is that accomplished functionally?
17:37:59 <Rembane> p0a: It's probably unnecessary, but at the same time it's fun. If you only want to get out things that can be represented as Monoids or Semigroups you have a very clean way of doing it. 
17:38:09 <p0a> How so?
17:38:32 <c_wraith> The most fun solution is https://hackage.haskell.org/package/foldl-1.4.6/docs/Control-Foldl.html
17:38:38 <Rembane> Definitely 
17:38:41 <c_wraith> composable folds!
17:38:41 <solonarv> ah, I was about to mention that library
17:38:59 <solonarv> if the things you need are all Monoids, you can just shove them in a tuple
17:39:22 <p0a> shove intuple?
17:39:54 <c_wraith> solonarv: eh, tuples aren't strict enough :(
17:40:04 <Rembane> foldMap (\x -> (Min x, Max x, ...)) [...]
17:40:14 <solonarv> @let average xs = case foldMap (\x -> (Sum x, 1)) xs of (Sum total, Sum len) -> total / fromIntegral len
17:40:16 <lambdabot>  Defined.
17:40:19 <solonarv> @type average
17:40:21 <lambdabot> (Foldable t, Fractional a) => t a -> a
17:40:23 <Rembane> c_wraith: Will you get a thunk buildup? 
17:41:10 <p0a> wait whats going on
17:41:18 <p0a> say you want an average of a list but also its max. How do you do it?
17:41:53 <solonarv> @let averageMax xs = case foldMap (\x -> (Max x, Sum x, 1)) xs of (Max m, Sum total, Sum len) -> (m, total / fromIntegral len)
17:41:54 <lambdabot>  .L.hs:171:10: error:
17:41:54 <lambdabot>      Not in scope: data constructor ‘Max’
17:41:54 <lambdabot>      Perhaps you meant variable ‘max’ (imported from Data.Ord)
17:42:02 <solonarv> @let averageMax xs = case foldMap (\x -> (Data.Monoid.Max x, Sum x, 1)) xs of (Max m, Sum total, Sum len) -> (m, total / fromIntegral len)
17:42:03 <lambdabot>  .L.hs:170:27: error:
17:42:03 <lambdabot>      Not in scope: data constructor ‘Data.Monoid.Max’
17:42:03 <lambdabot>      Perhaps you meant one of these:
17:42:14 <solonarv> @let import Data.Monoid
17:42:16 <lambdabot>  Defined.
17:42:26 <xsperry> how can I programatically terminate Scotty webserver? exitWith ExitSuccess doesn't work, scotty loop catches it and continues running
17:42:29 <solonarv> @let averageMax xs = case foldMap (\x -> (Max x, Sum x, 1)) xs of (Max m, Sum total, Sum len) -> (m, total / fromIntegral len)
17:42:30 <lambdabot>  .L.hs:171:10: error:
17:42:30 <lambdabot>      Not in scope: data constructor ‘Max’
17:42:30 <lambdabot>      Perhaps you meant variable ‘max’ (imported from Data.Ord)
17:42:44 <solonarv> !?
17:42:55 <solonarv> anyway, that's how
17:43:02 <solonarv> obviously this gets cumbersome
17:43:23 <solonarv> the foldl library uses the same underlying technique, but abstracts it a bit so it's less verbose
17:43:40 <solonarv> % import qualified Control.Foldl as Foldl
17:43:40 <yahb> solonarv: ; <no location info>: error:; Could not find module `Control.Foldl'; It is not a module in the current program, or in any known package.
17:43:44 <solonarv> aww :(
17:44:09 <c_wraith> Rembane: yes.  "(a,b) <> (a',b') = (a<>a',b<>b')".  A strict fold will force the (,) constructors, but leave a giant chain of thunks in each component
17:44:47 <Rembane> c_wraith: What a disappointment. 
17:44:57 <Rembane> c_wraith: I can totally see why FoldL is a thing
17:45:13 <c_wraith> tuples are lazy.  Go elsewhere if you need to control memory use
17:45:54 <p0a> solonarv: thank you 
17:45:56 <p0a> I'll try to understand that 
17:46:15 <MarcelineVQ> can I​ make +RTS  -h  not truncate names?  (80987)mkState/mkStateST/dec... 40   I want to know what that ... is
17:46:21 <solonarv> honestly if you're at the point where you're doing that you should probably just switch to foldl
17:46:29 <p0a> solonarv: ?
17:46:33 <p0a> solonarv: I don't understand
17:46:40 <c_wraith> MarcelineVQ: there's a flag somewhere (I don't remember the name of it) for the max label length
17:46:45 <solonarv> the 'foldl' library
17:46:50 <p0a> solonarv: you mean Control.Foldl?
17:46:51 <solonarv> not the function from the prelude
17:46:51 <MarcelineVQ> c_wraith: thank you I'll look
17:46:56 <solonarv> yes, that's the name of the module
17:47:04 <p0a> solonarv: well I thought that's what you meant. Thats' what I'll be reading 
17:48:16 <MarcelineVQ> c_wraith: -L possibly, will try
17:50:14 <p0a> if I want to extend the concept of a graph I'm using
17:50:21 <p0a> to also have an id :: Int say
17:50:34 <p0a> but I don't want to have to rewrite all the library functions for the wrapper, how do I do it?
17:53:41 <p0a> Control.Foldl is very nice, the docs are nice to
18:07:40 <p0a> although the pointfree example
18:07:42 <p0a> is a bit hard to read
18:07:46 <p0a> but at least only one argument
18:08:29 <p0a> can someone help me with the precedence in 
18:08:39 <p0a> ((,) <$> Fold.sum <*> Fold.length)
18:09:22 <koz_> Fold.whatever are functions.
18:10:01 <koz_> So there's not really much to consider - you're lifting (,) to two functions.
18:10:25 <p0a> is it ((((,) <$>) Fold.sum) <*> Fold.length) ?
18:10:35 <koz_> No, it is exactly what it says.
18:11:07 <koz_> > (,) <$> Just 1 <*> Just 2
18:11:09 <lambdabot>  Just (1,2)
18:11:14 <koz_> Same idea.
18:11:47 <p0a> got it
18:11:49 <p0a> thank you
18:16:36 <xe4> I want to use Network.Wreq (req), but instead of executing  req "https://mysite.com"  once, I want to build a list of these requests. I don't even care about changing the url right now. I guess I'm asking how might I obtain :: m a -> t (m a)
18:17:06 <koz_> :t lift
18:17:07 <lambdabot> (MonadTrans t, Monad m) => m a -> t m a
18:17:09 <koz_> :D
18:17:18 <koz_> Unless you mean something else by 't' here.
18:18:42 <xe4> i.e. I want to save myself from typing out [req "https://mysite.com", req "https://mysite.com", req "https://mysite.com"]
18:18:43 <MarcelineVQ> repeat (req "https://mysite.com")
18:18:52 <MarcelineVQ> or replicate for a specific length
18:18:53 <xe4> oh that works?
18:19:05 <koz_> What's the type of req?
18:19:17 <koz_> MarcelineVQ's suggestion won't work in the case you're describing.
18:19:26 <xe4> repeat :: a -> [a]  -- the a here can be IO ()? 
18:19:37 <koz_> xe4: Nope. Again, what's the type of 'req'?
18:19:58 <xe4> Network.HTTP.Req req :: (MonadHttp m, HttpMethod method, HttpBody body, HttpResponse response, HttpBodyAllowed (AllowsBody method) (ProvidesBody body)) => method -> Url scheme -> body -> Proxy response -> Option scheme -> m response
18:20:17 <koz_> :t traverse
18:20:19 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
18:20:31 <xe4> I meant get :: String -> IO (Response ByteString)
18:20:31 <koz_> Now set t ~ [], f ~ the m above.
18:20:38 <koz_> OK, even easier.
18:20:39 <xe4> and I guess I meant get instead of req
18:20:49 <koz_> :t traverse
18:20:50 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
18:20:56 <koz_> Set t ~ [], f ~ IO
18:20:58 <koz_> And we get
18:21:08 <koz_> (a -> IO b) -> [a] -> IO [b]
18:21:27 <p0a> okay so I want to use Control.Foldl, but I am already using traverse
18:21:28 <koz_> Clearly 'get' fits into the function argument.
18:21:40 <koz_> So we then have a ~ String, b ~ Response ByteString.
18:21:44 <koz_> Filling that all in, our result is
18:21:51 <koz_> [String] -> IO [Response ByteString]
18:21:54 <koz_> :D
18:23:22 <koz_> p0a: What are you trying to do that's not working?
18:23:49 <MarcelineVQ> Was that the task, a list of the results of executed requests?
18:23:52 <xe4> koz_: traverse doesn't repeat the action does it?
18:24:00 <koz_> xe4: Not only _does_ it, it _must_!
18:24:07 <p0a> I have a [Maybe Int] that I traverse over; I now want to do a few more things with it
18:24:17 <koz_> p0a: So what's the final result?
18:24:18 <xe4> traverse acts like repeat then? 
18:24:20 <p0a> so I think I need some custom step/done functions
18:24:25 <koz_> xe4: Traverse acts as traverse.
18:24:30 <koz_> The type spells it pretty well.
18:24:32 <koz_> :t traverse
18:24:33 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
18:24:44 <koz_> You can think of it as an 'effectful fmap' if you want.
18:25:04 <xe4> if it results in IO [ Response ByteString], I guess we can use take to execute the action so many times
18:25:13 <koz_> Nope.
18:25:16 <p0a> koz_: it basically transforms to [((a,a),(a,a))] from [[[a,a],[a,a]]]
18:25:17 <solonarv> in fact 'mapM' is a (less general) alias for 'traverse'
18:25:24 <koz_> It'll execute it once for every single element of the list.
18:25:26 <koz_> Take or none.
18:25:31 <koz_> (and can't possibly work any other way)
18:25:35 <koz_> (the laws say as much)
18:25:59 <koz_> p0a: So where does traverse come into this?
18:26:30 <p0a> koz_: the list may be ill-formed, I forgot the MAybe
18:26:50 <koz_> So you have [((a, a), (a, a))] -> Maybe [[[a, a]]]?
18:26:56 <koz_> (since that second thing isn't even a type)
18:26:56 <p0a> the other way around but yeah
18:27:19 <koz_> OK, so it's [[[a]]] -> Maybe [((a, a), (a, a))]
18:27:21 <koz_> ?
18:27:26 <p0a> yeah
18:27:27 <xe4> okay, so then I could say traverse (get "https://mysite.com") [1.. 20] in order for it to build up the list of functions
18:27:32 <xe4> 20 of them to be precise
18:27:39 <koz_> My first suggestion - ((a, a), (a, a)) is gory, just write a type for it.
18:27:39 <p0a> koz_: and elements look like [[1,2],[3,4]] of that list
18:28:22 <p0a> koz_: I immediately apply `edges' afterwards that turns [(b,b)] into a graph, here b = (a,a)
18:28:31 <p0a> so I Thought of skipping the type
18:28:37 <koz_> Word of advice - don't.
18:28:42 <koz_> You have a wonderful expressive type system.
18:28:44 <koz_> Use it.
18:28:55 <koz_> Instead of wrangling [[[[[[[(((((((a, a, a, a)))()))]]]]] or w/e.
18:28:58 <koz_> This isn't Lisp.
18:29:08 <p0a> okay
18:29:15 <p0a> thats a good point
18:31:07 <MarcelineVQ> xe4: do you want a list of 20 actions or do you want the action done 20 times?
18:33:39 <MarcelineVQ> because that's as direct as  replicate 20 (get "https://mysite.com")   vs   replicateM 20 (get "https://mysite.com")     with  get :: String -> IO (Response ByteString)
18:34:40 <koz_> MarcelineVQ: I believe the original thing started with a list of strings.
18:34:47 <koz_> Which I presume are different from each other.
18:35:37 <MarcelineVQ> not if I'm going by "<xe4> i.e. I want to save myself from typing out [req "https://mysite.com", req "https://mysite.com", req "https://mysite.com"]"
18:35:54 <koz_> MarcelineVQ: Lol, I guess I should lern2reed.
18:36:00 <koz_> So xe4: Are they the same, or different?
18:36:45 <p0a> why doesn't 
18:36:59 <p0a> :t Fold.Fold (\(x,y) (z,w) -> max x z) (0,0) id
18:37:00 <lambdabot> error:
18:37:00 <lambdabot>     Not in scope: data constructor ‘Fold.Fold’
18:37:00 <lambdabot>     No module named ‘Fold’ is imported.
18:37:14 <p0a> work? It complains I'm trying to define an infinite datatype. Hre I imported Control.Foldl as Fold
18:37:42 <p0a> the format is Fold step begin done, i.e. like Fold (+) 0 id
18:37:57 <p0a> OH I get it
18:38:20 <koz_> What's the best way to go from a Seq to a Vector?
18:38:30 <koz_> Should I just fromList . toList like a peasant?
18:38:54 <monochrom> I think yes.
18:42:38 <koz_> I guess Seq is designed to be incremental, and Vector fuses that kind of thing aggresively?
18:42:47 <suzu_> it'll fuse
18:42:55 <suzu_> it _should_ fuse. most of the tolist + fromlists in containers fuse
18:43:51 <p0a> any improvements on this? https://pastebin.com/ek5qTCy4
18:44:06 <p0a> the tuple step function is looking awkward to me
18:44:21 <p0a> oooh I know
18:44:32 <p0a> I'll change both the lambda and the initial value
18:46:28 <p0a> plus there's a bug with the initial value
18:46:38 <p0a> shoudl've been minBound
18:46:41 <p0a> nevermind
18:46:53 <koz_> Does prettyprinter supply a thing that renders a Word as hex?
18:48:14 <monochrom> I think no.
18:48:22 <koz_> monochrom: Back to peasant methods it is then.
18:48:30 <suzu_> peasant programming is good
18:48:40 <koz_> Does _base_ have some way of doing like, Word to hex String?
18:48:56 <monochrom> Numeric has showHex
18:49:21 <koz_> And then I gotta apply it to "" as well.
18:49:26 <koz_> much peasant.
18:49:31 <koz_> very convenience
18:49:36 <solonarv> koz_: Seq has O(1) length, so maybe it'd help to use vector's fromListN
18:49:44 <koz_> solonarv: Oh, nice catch.
18:50:06 <solonarv> Vector.fromListN (length xs) (toList xs)
18:50:20 <koz_> solonarv: That's just fromList but with a size hint right?
18:50:37 <solonarv> yup, so that it can allocate the correct amount of space right away
18:51:41 <p0a> okay here's my issue
18:51:52 <MarcelineVQ> now to write the fusion code to skip the intermediate list
18:52:05 <p0a> I can do Fold.fold (Fold.Fold (+) 0 id) [1,2,3] ==> 6. But I have [Just 1, Just 2, Just 3]. 
18:52:15 <tukane> How can I tell GHC to make use of the type class constraint in Foo for `recover`? Currently it says it's ambiguous: https://pastebin.com/dAGkdJg3
18:54:34 <solonarv> tukane: ScopedTypeVariables so you can change the pattern match to '(Foo (Tagged n :: Tagged x))', then change 'recover' to 'recover :: SingTag t'
18:54:50 <solonarv> or for the second step, you can also turn on TypeApplications and write 'recover @x'
18:55:08 <solonarv> s/SingTag t/SingTag x/ in my first message
18:55:42 <Axman6> p0a: one thing that works is replacing (+) with ((+) . fromMaybe 0) then the fold will be Fold (Maybe a) a
18:56:41 <koz_> % @src ap
18:56:41 <yahb> koz_: ; <interactive>:70:1: error: parse error on input `@'
18:56:46 <koz_> % :src ap
18:56:46 <yahb> koz_: unknown command ':src'; use :? for help.
18:56:50 <p0a> Axman6: I thought I'd replace (+) by (\x y -> (+) <$> x <*> y) 
18:56:58 <p0a> Axman6: and 0 with Just 0
18:57:02 <Axman6> depends what result you want
18:57:20 <p0a> I want the sum or Nothing
18:57:20 <Axman6> do you want to get back a Maybe?
18:57:44 <p0a> yeah because it could be [Just 1, Nothing, Just 2]
18:57:57 <Axman6> > sumOf (traverse . _Just) [Just 1, Just 2, Just 3] -- gives the other behaviour
18:58:00 <lambdabot>  6
18:58:09 <p0a> but "I want to use this with Control.Foldl
18:58:52 <p0a> Oh, I get it I think. WHoa _Just looks weird
18:59:14 <xsperry> can doEither be made more generic? so that "doEither show" has the same type as showEither. https://pastebin.com/HUiZ35Xj
18:59:40 <tukane> solonarv: thank you so much! finally I got what I wanted
18:59:42 <p0a> Axman6: I'll be honest I dont' really understand yours I'll post my code once I do it my way and you can tae alook if you'd like 
18:59:46 <p0a> but it's no biggie
18:59:57 <Axman6> you don't have to undersrand mine, I'm just showing off :P
19:00:21 <Axman6> :t foldMap
19:00:22 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
19:00:41 <Axman6> > foldMap (fmap Sum) [Just 1, Just 2, Just 3]
19:00:43 <lambdabot>  Just (Sum {getSum = 6})
19:00:47 <Axman6> > foldMap (fmap Sum) [Just 1, Just 2, Just 3, Nothing]
19:00:49 <lambdabot>  Just (Sum {getSum = 6})
19:01:17 <Axman6> :t asum
19:01:18 <lambdabot> (Foldable t, Alternative f) => t (f a) -> f a
19:01:24 <Axman6> hmm that';s also wrong
19:03:34 <p0a> okay I think
19:03:46 <p0a> this is a case of premature optimization in fact
19:03:54 <p0a> I'll just transverse this list twice, it's not larger than 100 elements lol
19:04:05 <p0a> what am I even doing
19:05:59 <kamek> is there a way to not repeat constraints on every methods on a typeclass ? say I have: class Foo a where bar :: (Monad m) => a -> m Bool
19:06:07 <kamek> and I'd like to do something like: class (Monad m) => Foo a where bar :: a -> m Bool
19:06:12 <kamek> if that even makes sense
19:06:36 <Axman6> not if m isn't mentioned in the class I believe
19:08:05 <kamek> I see, not a huge deal I guess
19:22:05 <koz_> Someone who's more versed in lambda calculus than me - what do the ... versus . mean in this expression? https://en.wikipedia.org/wiki/Mogensen%E2%80%93Scott_encoding#Scott_encoding
19:22:14 <MarcelineVQ> Axman6: getAp . fmap getSum . foldMap (Ap @_ @(Sum _))   :X
19:22:16 <koz_> I guess the ... is shorthand for something, but I don't get what.
19:22:28 <koz_> MarcelineVQ: something something ala.
19:24:28 <MarcelineVQ> ... is just expressing a range of things   e.g.  1 ... 5  is standing in in for 1,2,3,4,5
19:25:00 <koz_> MarcelineVQ: So in this case, is it just a sequence of \x1\x2..\x_{A_i}?
19:25:02 <MarcelineVQ> \a.b is  \a -> b
19:25:05 <monochrom> koz_: Looks like whereas haskell writes "\a1 a2 a3 a4 a5 -> foo", it's abbreviated "lambda a1 ... a5 . foo"
19:27:37 <justsomeguy> I think that they're trying to represent a range of nested heads.
19:27:41 <MarcelineVQ> \x.y.z -> x (y z) z    \x,y,z. x (y z) z  \x ... z. x (y z) z
19:28:29 <MarcelineVQ> oops, that first one is a little whack.   \x y z -> x (y z) 
19:28:59 <MarcelineVQ> If the world economy ran on notations we'd be post-scarcity.
19:29:20 <koz_> Lol.
19:31:12 <justsomeguy> I keep on running into Dana Scott's name whenever I'm reading up about the lambda calculus.
19:31:42 <Axman6> is that the Scott of Scott encoding?
19:32:00 <justsomeguy> Pretty sure. He did a lot of research on lambda calculus.
19:32:39 <shachaf> There are no other Scotts.
19:32:39 <xe4> koz_ and MarcelineVQ: sorry, I want a list of 20 actions to be performed
19:33:10 <xe4> though, I guess I am interested in performing the action X times
19:33:29 <koz_> If you just wanna spam 1 action, replicateM works. If you want 20 different actions, traverse.
19:33:45 <justsomeguy> I really enjoyed his lecture on the history of lambda calculus and it's role in computability for the acm turing award https://www.invidio.us/watch?v=7cPtCpyBPNI
19:34:08 <xe4> thanks koz_. I'm playing around. if any other question comes up, I'll come back
19:34:19 <justsomeguy> oops, it's this one https://www.invidio.us/watch?v=SphBW9ILVPU
19:38:13 <justsomeguy> Ugh, I shouldn't IRC and drink. It always ends up with me saying stupid things to smart people.
19:38:20 <koz_> justsomeguy: Lol.
19:38:55 <p0a> I have a function a -> IO a
19:39:04 <p0a> and I want to do a case ... of ... with it
19:39:13 <p0a> no sorry, a -> IO (Maybe a)
19:39:26 <p0a> so I want to do a case of Nothing, doing nothing and otherwise working with the argument. How do I do that?
19:39:32 <Axman6> you can't (meaningfully) pattern match on functions, so that's going to be hard :)
19:39:39 <p0a> no on its result
19:39:56 <p0a> sth like "loadStuff filepath"
19:40:14 <koz_> Which way do applications associate in lambda calculus again?
19:40:14 <Axman6> foo a >>= \case Nothing -> pure (); Just a' -> so stuff with a
19:40:27 <p0a> pure (), got it
19:40:28 <koz_> If I have z x y does this mean z (x y) or (z x) y?
19:40:43 <p0a> koz_: the latter I believe
19:40:52 <p0a> given all lambdas are single argument
19:42:06 <p0a> Axman6: but foo a is of type :: IO (Maybe a)
19:42:17 <p0a> Axman6: so you can't pattern match against Nothing
19:42:19 <koz_> p0a: pure . pure $ () then
19:42:20 <Axman6> yes, hence the >>=
19:42:22 <p0a> Are you pattern matching against pure (Nothing) ?
19:42:26 <p0a> OH, got it
19:42:48 <p0a> right but what about pure (); ? is that pure . pure $ () or pure (Nothing)?
19:42:53 <Axman6> \case is LambdaCase, shorthand for foo a >>= \ma -> case ma of Nothing -> ...
19:42:57 <koz_> :t pure ()
19:42:58 <lambdabot> Applicative f => f ()
19:43:02 <p0a> Oh I see, you are inside IO 
19:43:13 <Axman6> you said you wanted to do nothing, pure () does nothing
19:43:19 <p0a> I want nothing!
19:43:22 <Axman6> do you actually want to return a Maybe?
19:43:31 <p0a> well foo returns an IO (Maybe a)
19:43:36 <p0a> and I want to continue doing that
19:43:46 <Axman6> then all you need is reavese then: foo a >>= traverse loadFile
19:44:02 <p0a> hm
19:44:22 <p0a> I'll do it my way let me try 
19:44:23 <Axman6> :t traverse (undefined :: String -> IO String) `asAppliedTo` (Just "")
19:44:25 <lambdabot> Maybe String -> IO (Maybe String)
19:44:51 <p0a> you know
19:44:52 <p0a> Haskell is nice
19:44:57 <p0a> but I find that modifying my code is really hard
19:45:00 <p0a> after I've written it
19:45:18 <koz_> p0a: It's not that bad _if_ you follow the types and listen to the compiler.
19:45:18 <p0a> damn it
19:45:50 <p0a> kind of want to give up right now lol
19:46:10 <p0a> it's incredibly painful to simply obtain the maximum size of the graph I've already loaded, lol
19:46:22 <koz_> p0a: Why?
19:46:33 <koz_> If you have a bad representation, change the representation.
19:46:35 <p0a> so I have a Graph (Int, Int)
19:46:39 <p0a> inside an IO (Maybe )
19:46:49 <koz_> p0a: There be your problem.
19:46:50 <p0a> I want to apply a vertexList to it, and obtain the maximum x and y values
19:46:58 <p0a> right, good point
19:46:58 <koz_> You need to resolve that Maybe _immediately_.
19:47:12 <p0a> I think I have an idea
19:47:14 <koz_> If you fail to load, just blow up the program.
19:47:23 <p0a> AAh, I see.
19:47:31 <p0a> so don't carry that Maybe around eh
19:47:46 <p0a> Is there an idiom for that? Otherwise I'd write a partially defined case
19:48:44 <koz_> foo <- getMyDataMaybe; case foo of Nothing -> error "I blew up lol"; Just data -> ...
19:49:05 <koz_> Replace 'error "I blew up lol"' with more appropriate erroring in IO or whatever as you see fit.
19:49:23 <koz_> Carting that Maybe around is 100% not necessary, since you can't proceed anyway.
19:49:42 <koz_> peek = lam 1 (App (Var 1) (lam 2 (lam 3 (Var 2))))
19:49:44 <p0a> Right, thank you 
19:49:51 <koz_> Yo dawg, we heard you liked Lisp... :P
19:50:49 <p0a> lol
19:51:05 <p0a> I remember once talking to a person with a Lisp
19:51:23 <p0a> I mean, with a lisp, and I told him my favorite programming language was Lisp and he was offended
19:51:34 <p0a> and then it occured me that he had a lisp
19:52:08 <p0a> maybe he wasnt offended, i dont know. That's how I remembe rit
19:56:28 <koz_> Well, I'm trying a super-silly idea I had of compiling (a fragment of a) Forth to SKI combinators.
20:03:57 <p0a> can I Do `let g = ... in case g of ...' ?
20:04:10 <p0a> or do I need in $ case ... ?
20:05:58 <p0a> hm, it works. not sure what's wrong
20:06:47 <quinn> i'm writing a program where i care about latency and i want to see if switching to output streams over putStr is a good idea, any recommendations about how to go about figuring that out?
20:08:40 <p0a> Why is this simple thing wrong? https://pastebin.com/83yT492w
20:08:57 <p0a> OH you can't use where inside let? okay
20:11:50 <koz_> Edward Kmett has the most hilarious programming puns.
20:12:08 <koz_> abstract me expr = Scope (letmeB o expr) where
20:12:18 <koz_> letmeB this (F you) 
20:12:25 <koz_> | you == me = B this
20:12:28 <koz_> | otherwise = F you
20:12:45 <koz_> That _better_ have gotten laughter from the audience.
20:14:03 <Axman6> hey, F you too buddy
20:14:22 <koz_> Axman6: I'm looking over the slides describing the 'bound' library.
20:14:32 <koz_> Every single slide is a pun.
20:14:45 <koz_> With titles like 'Just: don't succ' and 'Succ the whole thing'.
20:15:14 <Axman6> He's a man of (too) many talents
20:17:44 <p0a> what's wrong with this? https://pastebin.com/DZ2v594e
20:17:48 <p0a> The error is in the comment
20:21:02 <p0a> found this, https://gitlab.haskell.org/ghc/ghc/issues/9581
20:21:05 <p0a> explaining the issue I think
20:21:29 <Axman6> I thnk your where needs to be indented more
20:21:49 <p0a> And then it'd work?
20:22:06 <Axman6> it needs to be as indented or more as the function it related to, so that where clause is actually scoped to extractEdges, not g (I think)
20:22:12 <Axman6> you tell me
20:22:28 <p0a> I tried, doesn't work
20:22:36 <p0a> I had to manually indent it with spaces my editor wouldn't let me tab it
20:22:45 <MarcelineVQ> just is indented a space too far
20:22:45 <Axman6> well without more info I have no idea
20:22:52 <MarcelineVQ> Just x -> x
20:22:55 <Axman6> oh yeah, good catch
20:23:02 <p0a> OH
20:23:03 <p0a> Ugh
20:23:11 <koz_> Alrighty, let's see how gory the resulting lambda calculus is.
20:23:11 <p0a> what a tricky situation, thank you 
20:23:16 <MarcelineVQ> when you're more indented than the previous line it means a continuation of the previous line
20:23:32 <p0a> Aaah, got it. thank you MarcelineVQ I wasn't aware of that 
20:23:39 <p0a> tricks, tricks everywhere
20:31:38 <toni37> > :t pure
20:31:40 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
20:36:54 <dsal> :t pure
20:36:55 <lambdabot> Applicative f => a -> f a
20:37:22 <dsal> > pure "ice" :: Maybe String
20:37:24 <lambdabot>  Just "ice"
20:37:43 <koz_> Egads writing this without let-bindings will get super-gory.
20:37:56 <koz_> I guess I'll need a de-letting pass too.
20:38:11 <p0a> ever since I tried loading Control.Foldl
20:38:31 <p0a> now I'm getting "Cannot load 'Lib', It is a member of the hidden package 'libiserv-8.8.3'.
20:38:41 <p0a> because the name of my module is Lib
20:39:10 <koz_> Pick a better name.
20:39:50 <Axman6> I wish the defualy name in stack projects was I'mADumbNameChangeMe.hs
20:39:55 <p0a> but I'm not even using Control.Lib
20:39:59 <p0a> I mean Control.Foldl
20:40:07 <koz_> Axman6: Yeah, that'd work.
20:40:13 <p0a> kay kay I'll change it
20:40:31 <Axman6> or You'llProbablyJustDeleteMe.hs
20:40:33 <dsal> Change it to Libby
20:40:41 <p0a> thats cute I did MyLib tho
20:41:23 <dsal> My brain is rejecting things kmett is saying.  Does this guy have any idea what he's talking about?
20:41:26 <koz_> I wonder, in Japanese, do code libraries get called 'toshokan'?
20:41:32 <koz_> dsal: Uhh?
20:41:44 <dsal> O(n) all the things.
20:41:49 <dsal> I'm going to have to play with this.
20:41:54 <koz_> dsal: In what?
20:41:56 <dsal> O(n) sort, map creation, nub, etc...
20:41:59 <dsal> @hackage discrimination
20:41:59 <lambdabot> http://hackage.haskell.org/package/discrimination
20:42:05 <koz_> O(n) sort isn't even that mind-bending.
20:42:15 <koz_> Discrimination sorting is just a very general radix sort.
20:42:22 <koz_> (like, _very very very_ general)
20:42:28 <koz_> The basic idea is fairly logical.
20:42:33 <dsal> I've not used it, so I'm pretty sure everyone is lying to me.
20:42:37 <koz_> (although as with everything, the constants can get _very_ large)
20:42:43 <koz_> dsal: Are you familiar with radix sorting as such?
20:43:03 <dsal> Somewhat.  I've only done specialized versions.
20:43:33 <koz_> The basic idea is 'if your things look like strings over a fixed alphabet, you can dodge the comparison sorting bullet'.
20:43:45 <koz_> Discrimination sorting says 'we can make ADTs look like strings over a fixed alphabet'.
20:43:52 <koz_> That's _literally_ 100% of the idea.
20:44:00 <dsal> I'll have to see how it works in practice.  It sounds fine.
20:44:42 <p0a> what is meant by ADT?
20:44:47 <p0a> Abstract Data Type or Tree?
20:45:00 <koz_> p0a: Algebraic Data Type around these parts.
20:45:24 <p0a> okay, thanks
21:00:30 <p0a> Is this another whitespace issue? I get 'vertices' not defined. https://pastebin.com/eefGVwfj
21:00:38 <p0a> well, "Variable not in scope, 'vertices'"
21:00:59 <p0a> oh where needs to be indented?
21:01:18 <p0a> nope...
21:01:19 <monochrom> No, "where" belongs to "findBounds g".
21:01:28 <monochrom> "findBounds g ="
21:02:03 <p0a> hm, how do I fix that?
21:02:09 <monochrom> findBounds g = (let ... in ...) where xvalues = map fst waitwhatisvertices?
21:02:26 <p0a> a list of (,)
21:02:39 <monochrom> move vertices to the where
21:03:29 <p0a> so move everything to where?
21:03:34 <monochrom> Yes.
21:03:55 <p0a> nice, thanks. I didn't know that where knew about its previous definitions
21:04:59 <monochrom> and its next definitions
21:05:08 <p0a> it knows everything 
21:05:41 <p0a> wait, the next definitions? What? Nevermind. I'll accept it as magic now
21:06:48 <monochrom> You have worked with serialized representations of graph. You know forward references is a thing.
21:07:40 <Axman6> dsal: gave you seen https://www.youtube.com/watch?v=eXDJ5Jcbgk8? I was there in the audience, and I feel like I was one of the like 5% of the room that got it and was like "yo,wtf, that's insane". I'vbe been meaning to put into practice for a while, ahev used it for a few toy things
21:08:13 <dsal> Axman6: I think that's the one I just watched.
21:08:19 <Axman6> dsal: once you understand its internals, it makes it very easy to do things like fork a thread for each key in a stream when you don't know how many keys there, and multiplex messages to them
21:09:53 <dsal> Axman6: I'm working on a project and haven't tried it.  I'm sure the magic goes away quickly like everything else.  Meanwhile, it's a lie.
21:11:47 <Axman6> the real magic in its implementation is how Ed managed to create lazy lists by appending to the end of them, it's very :mindblown:
21:13:10 <dsal> Is there a good way to get a unique atom of some sort?
21:13:56 <Axman6> All atoms are unique little snowflakes
21:14:56 <dsal> I just want a thing that has an Eq and I don't have to think about it beyond that.
21:14:58 <koz_> dsal: Work in MonadState Word m.
21:15:14 <koz_> Or just use newtype Atom = Atom Word deriving newtype (Eq).
21:15:19 <koz_> And write some helpers to make them.
21:15:26 <Axman6> if you have a little more than Eq you can use discrimination
21:16:11 <dsal> For this case, I just want to tag a structure with a thing that I can tell where it came from.  i.e., when I destroy something, I want to make sure it's "my" data.
21:16:30 <koz_> Seeking input: https://gist.github.com/kozross/36a75eb593dfbdf240b724aad7296d99#file-forth-hs-L35
21:16:41 <koz_> dsal: Newtype around Word is fine.
21:16:45 <koz_> Plenty small and fast.
21:20:15 <dsal> Yeah.  I just have to make one.
21:30:28 <sm[m]> quinn: trying different things in ghci, timed via timeit, is one nice easy way to start
21:33:30 <MarcelineVQ> koz_: "-- can I write this with a fold?" ye, the mechanical translation is to replace your recursive call with fold function's second argument, so maybe like    letMany xs res = foldr (\(bind,def) lc -> Let (abstract1 bind def) (abstract1 bind lc)) rest xs
21:33:45 <koz_> MarcelineVQ: Yeah, that makes sense. I'm off my game today lol.
21:33:46 <MarcelineVQ> Thought I can't test that without writing more scaffolding than I'd prefer right now
21:33:49 <koz_> Too much lambda calculus gore.
21:34:12 <koz_> I did some arg shuffling and ended up with 'letMany = foldr (\(def, bind) acc -> let1 def bind acc)'
21:39:15 <koz_> MarcelineVQ: https://gist.github.com/kozross/36a75eb593dfbdf240b724aad7296d99#file-forth-hs-L54
21:39:30 <koz_> This is what happens when you try to compile Forth into the untyped lambda calculus.
21:39:39 <koz_> That giant field of lambda calculus gore is 'swap'.
21:41:36 <koz_> I'm unsure how to implement 'add' and 'mul' in this model.
21:41:43 <koz_> I guess they're just special things I can App?
21:41:50 <koz_> And then the graph reduction machine handles it?
21:45:06 <koz_> I also suspect I'm not using Bound correctly.
21:46:38 <MarcelineVQ> depends on your numerical repsentation  https://plfa.github.io/ has a section where you do add and mul in churuch encoded numbers and peano
21:46:47 <MarcelineVQ> * <koz_> I'm unsure how to implement 'add' and 'mul' in this model.
21:47:00 <koz_> MarcelineVQ: I have literal Words available.
21:47:08 <koz_> As a primitive.
21:47:55 <koz_> But I think I know what needs to happen.
21:48:27 <koz_> You basically do the swap-style gore to get the top 2 elements, then App (App Add (Var "tos")) (Var "sos"), then push that.
21:50:12 <MarcelineVQ> if your number is primitive then won't your addition need to be as well?
21:50:17 <koz_> MarcelineVQ: Yep!
21:50:29 <koz_> So I gotta add WordAdd and WordMul as LC a.
21:50:41 <koz_> Took me a moment to figure that out.
21:51:52 <MarcelineVQ> Who's the mad scientist that appeared in your lab out of a time machine who tasked you to write forth to save the world of future past?
21:51:59 <koz_> MarcelineVQ: Lol.
21:52:05 <koz_> Well, the 80s are trendy again?
21:52:27 <koz_> So I'm taking two 80s trends (stack computing and combinator calculus) and throwing them in a blender.
21:52:34 <MarcelineVQ> for the 4th time? :>
21:52:34 <Axman6> is it New Coke time yet?
21:52:50 <koz_> I wanna eventually try Edward's idea for running combinator calculus reduction on a GPU.
21:52:57 <koz_> Axman6: This is more Crystal Pepsi.
21:53:18 <koz_> More exactly, it's like _blending_ New Coke and Crystal Pepsi.
21:53:20 <MarcelineVQ> oh, he's probably got an implementation of that stuffed in the coda source somewhere :>
21:53:35 <Axman6> sign me up
21:53:36 <MarcelineVQ> *the ##coda source
21:53:59 <koz_> Axman6: My current plan is Forth -> ULC -> SKI(BC???)
21:54:04 <MarcelineVQ> cola? la lala la lolaaa
21:54:10 <koz_> Probably with wired-in hash consing.
21:54:15 <koz_> (and using Oleg's algorithm)
21:54:37 <koz_> I'm starting with four-function calculator capabilities.
21:54:42 <MarcelineVQ> if you write his name as edwardk he'll often point you in the right direction as well
21:54:52 <koz_> MarcelineVQ: I'm trying to give the poor man some peace! :P
21:55:05 <MarcelineVQ> If he didn't like it he wouldn't do it!
21:56:43 <Axman6> he knew what he was doing when he decided to be agenius and stay connected to IRC
21:56:51 <Axman6> a genius*
21:57:32 <MarcelineVQ> heavy is the crown
21:58:04 <MarcelineVQ> literally, you wear an iron crown on off-days because it's lighter
21:58:31 <Axman6> gotta maintain those neck muscle gainz
21:58:50 <koz_> Never skip neck day.
21:59:02 <MarcelineVQ> jokes on you, real kings don't have necks. confuses the revolutionists you see
22:00:03 <koz_> Speaking of which, time to import mtl.
22:00:29 <MarcelineVQ> So you're only going to oleg so far
22:00:54 <koz_> MarcelineVQ: What, were you expecting me to import Polysemy or something?
22:01:15 <Axman6> do it
22:01:19 <Axman6> you won't
22:01:22 <koz_> No.
22:01:29 <Axman6> I just did it, it was fine
22:02:45 * hackage calamity 0.1.4.4 - A library for writing discord bots  https://hackage.haskell.org/package/calamity-0.1.4.4 (nitros12)
22:07:16 <koz_> OK, need to be able to pretty-print this lambda gore.
22:08:01 <MarcelineVQ> koz_: oh no, nothing like that.  http://okmij.org/ftp/tagless-final/course/lecture.pdf
22:08:25 <MarcelineVQ> why let someone else do all the work
22:09:23 <dsal> someone else is my favorite coworker.  Writes pretty awful code, though.
22:14:42 <koz_> For the morbidly curious: https://gist.github.com/kozross/36a75eb593dfbdf240b724aad7296d99
22:16:02 <koz_> Might save pretty printing for another day.
22:16:20 <koz_> It's be curious what sort of thing '4 2 * 2 2 * +' would compile to.
22:34:45 <iqubic> What are you doing koz_?
22:35:00 <koz_> I am trying to compile Forth into SKI.
22:35:10 <koz_> (well, SKIBC probbo)
22:35:11 <iqubic> Why?
22:35:35 <koz_> iqubic: Fun, learning, and the fact that combinator calculus based graph representations admit a (fairly) massively parallel reduction.
22:35:51 <iqubic> Oh, that sounds lovely.
22:36:13 <koz_> Hence the idea.
22:36:32 <koz_> I'm starting with a soft toss (basically a four-function stack calculator)
22:36:43 <koz_> (with Word literals and operators)
22:37:46 <iqubic> So you'll be able to compile things like "2 2 2 + *"?
22:37:58 <iqubic> Are you going to set up a parser for that?
22:38:59 <iqubic> Actually, I'd be something like "2 2 2 + * +" as the former would still leave two values on the stack.
22:40:38 <koz_> It's currently an EDSL.
22:40:52 <koz_> It wouldn't be particularly hard to give it a front-end that reads text though.
22:41:32 <koz_> iqubic: https://notabug.org/koz.ross/skirth/src/master/src/Language/Skirth/Forth.hs#L117
22:42:23 <koz_> So you'd write something like 'compile $ replicateM_ 3 (lit 2) >> add >> mul >> add'
22:46:13 <iqubic> What's the type signature of compile?
22:47:05 <koz_> It's at the bottom of the thing I linked.
22:47:11 <koz_> ForthM () -> LC Text
22:47:21 <iqubic> Ah. I see.
22:49:06 <koz_> It'll get much harder when we reach the dictionary.
22:49:19 <koz_> I can only imagine with mute horror what _that_ will render into in SKI.
22:51:17 <iqubic> What's a dictionary?
22:51:35 <koz_> The Forth dictionary?
22:51:41 <koz_> Like, the thing where user-defined words live?
22:52:19 <koz_> Like, if I do ': square dup * ;', then if I have 'square' anywhere else, the dictionary is where you gotta look to find the definition.
22:52:31 <iqubic> Oh hell.
22:53:16 <koz_> But hey, one problem at a time. :P
22:53:30 <Welkin> yeah
22:53:38 <Welkin> covid-19, then trump
22:53:55 <suzu_> ^
22:54:10 <MarcelineVQ> Map UserThingy Definition
22:54:34 <iqubic> MarcelineVQ: Not sure how that translates to SKI.
22:55:59 <MarcelineVQ> trick one is determining whether it needs to
22:56:41 <koz_> Yeah, that is a thing to consider.
22:56:51 <koz_> But yeah, one problem at a time.
22:56:59 <koz_> I just wanna see if I can get _something_ which works.
22:57:11 <koz_> It'll be fun learning in any case.
22:57:19 <Welkin> I wrote SKI in javascript once
23:02:49 <Axman6> I remember years ago a great reddit discussion on an article about why stack based languages were amazing and could do things that weren't possible in other languages, and in the comments the whole thing was reimplemented in Haskell, using the same syntax (with IIRC the addition of a start and end keyword), which also had the advantage of being statically typed
23:03:55 <koz_> Axman6: Rofl.
23:04:47 <koz_> I'm just using Forth as a starting point for a laugh really.
23:05:02 <koz_> (and because I figured it'd be an easy starting point)
23:06:41 <Welkin> write yourself a scheme
23:07:12 <Axman6> it was all or two
23:07:18 <Axman6> uh, or two*
23:08:00 <koz_> Welkin: I practically am with this lambda gore.
23:08:35 <koz_> https://notabug.org/koz.ross/skirth/src/master/src/Language/Skirth/Forth.hs#L64
23:08:57 <koz_> The thing above it also.
23:09:22 <iqubic> Have you done the working out to make sure this correct?
23:09:52 <koz_> iqubic: Yeah.
23:09:55 <dsal> I did some moderate ranching today, but I managed to get a little bit of work on my mqtt broker.  I keep changing where I put all the things.  A good data structure to manage mqtt subscriptions seems like something that would exist, but it's probably going to be a good deal of work, so I'll use a list in the meantime.
23:09:56 <iqubic> Nice.
23:09:57 <koz_> Although I could have missed something.
23:10:10 <koz_> dsal: Not a Vector?
23:10:29 <Axman6> :alianhands: threads
23:10:33 <Axman6> alienhands*
23:10:59 <iqubic> koz_: Just write a LC interpreter and run the code you get as output from compile
23:11:12 <Axman6> also, something something propagators
23:11:13 <dsal> It should be some kind of weird tree like thing, probably.  Topics are in the form of a/b/c/d, but subscriptions can have single-element wildcards, or "Any element below" wildcards.  e.g.,  a/+/b/c or a/#
23:11:30 <koz_> Axman6: Propagators?
23:11:38 <koz_> iqubic: Yeah, when it comes to testing I likely will.
23:12:28 <Welkin> ranching?
23:12:34 <dsal> When I publish to a/b/c/d, I need to deliver that to anyone subscribed to # or a/# or +/b/c/d etc...
23:12:41 <Welkin> like slime rancher? Or somethign in stardew valley or animal crossing?
23:12:47 <Welkin> Or real cow herding?
23:13:14 <Welkin> or you mean ranch as part of the erlang cowboy ecosystem?
23:13:57 <dsal> I've given a talk at an erlang conference, but I've got actual cows, heh.
23:14:20 <dsal> I added dtrace support to beam a bunch of years ago.  It was pretty awesome to use.
23:14:59 <Axman6> nice
23:15:01 <dsal> Today's work didn't exactly involve cows, though.  Just prepping the garden.
23:15:20 <dsal> And trying to figure out how to write an mqtt broker, which is working reasonably well for the level of engagement I've had.
23:15:57 <Welkin> phil wadler and simon marlow tried to write a type system for erlang a long time ago
23:16:26 <Welkin> I always found thay funny
23:16:39 <dsal> erlang has several types already.
23:16:42 <Welkin> how intertwined different languages and communities are
23:16:54 <Axman6> at least three
23:16:57 <Axman6> possibly four!
23:17:04 <Welkin> it has no type system
23:17:07 <dsal> int, list, record, atom
23:17:11 <Welkin> just some static analysis tools
23:17:20 <Axman6> numbers, lists, bytestrings, tuples, atoms, at least five!
23:17:30 <dsal> Oh yeah, the bytestring stuff is pretty great.
23:17:34 <Axman6> yeah
23:17:41 <Welkin> binaries
23:17:49 <Axman6> the bit syntax stuff is very neat
23:17:57 <dsal> I've not written any erlang in so long I don't remember what anything is.
23:18:03 <Axman6> writing something like CBOR in it would be great
23:18:11 <Welkin> processes are the main primitive
23:18:22 <Welkin> that's a "type" I think
23:18:28 <Axman6> it's all kist OOP
23:18:31 <Axman6> just*
23:18:31 <Welkin> it has maps too
23:18:50 <Welkin> and arrays, but that's weird to use
23:18:54 <dsal> That's built on the primtives, though.
23:19:37 <dsal> Anyway, I'm going to try to sleep.  I'm going oncall in the morning.
23:19:44 <Welkin> have fun
23:19:52 <Axman6> ew
23:20:25 <Welkin> I got a page the morning of the day I was going to go on-call that afternoon
23:20:27 <Welkin> I was the backup
23:20:54 <Welkin> not a good way to start a monday
23:21:11 <dsal> I got a page once on a weekend when I had to go somewhere, but a tree had fallen across my road.  I spent three hours going between my chainsaw and laptop trying to get out of here...
23:21:19 <dsal> Anyway, 'night all :)
23:22:48 <Welkin> I'm grateful for the doctors and surgeons that go on call and get paged at 2 am to come in and do a 5 hour surgery at 3 am
23:23:30 <Welkin> software dev on-call is a joke by comparison
23:41:58 <d2ci8xc5> anyone able to help me out with the following monoid question? https://old.reddit.com/r/haskell/comments/gd6b8e/question_about_monoids/
23:42:47 <d2ci8xc5> I don't see why `a` should require a Monoid instance when it's not even used in the Monoid Optional instance
23:44:17 <EvanR> that's pretty clear, try to implement Monoid there without a Monoid instance for a
23:45:50 <d2ci8xc5> I understand that a implement Semigroup for the Semigroup instance (you're mappending two values of type a)
23:46:10 <d2ci8xc5> *a must implement Semigroup
23:46:56 <EvanR> you're right, a needs Semigroup
23:47:03 <d2ci8xc5> but Monoid is only defined by the mempty at this point isnt it?
23:47:18 <d2ci8xc5> which has nothing to do with a and only requires Optional a
23:47:33 <d2ci8xc5> as memepty = Nada
23:47:41 <EvanR> Monoid can be supported by naming mempty for a given Semigrou[
23:49:20 <EvanR> instance Semigroup a => Monoid (Optional a) where
23:49:51 <d2ci8xc5> where is `a` actually used in that monoid instance? 
23:50:05 <d2ci8xc5> I understand Nada :: Optional a
23:50:40 <EvanR> because of the requirement in the Monoid class that Optional a also have a Semigroup instance
23:50:55 <EvanR> all Monoids must have a Semigroup instance
23:51:10 <EvanR> and your Semigroup instance requires Semigroup a
23:52:44 <d2ci8xc5> aahhhhhh ok
23:52:53 <d2ci8xc5> sorry i've just thought it through
23:53:15 * hackage character-cases 0.1.0.4 - Exposes subspecies types of Char. And naming cases.  https://hackage.haskell.org/package/character-cases-0.1.0.4 (aiya000)
23:53:51 <MarcelineVQ> One way to understands superclass constraints is from the other direction, "I can use Monoid to implement Semigroup, thus all Monoids are Semigroups."
23:54:28 <d2ci8xc5> to be honest I'm not using an official version of haskell programming from first principles, is the official version up to date with these changes? I wanted to save off for a physical copy but I might have to buy an official version if it;s updated
23:57:05 <EvanR> the => in class declarations sometimes feels a bit backward. In class Semigroup a => Monoid a, the fact of the matter is, if you hold a Monoid implementation for a, then you can have the Semigroup implementation for a. (if the program compiled)
23:57:54 <MarcelineVQ> d2ci8xc5: it's worth it for the sake of supporting the author but I wouldn't bother if it's just for the sake of updates
23:58:15 * hackage plzwrk 0.0.0.3 - A front-end framework  https://hackage.haskell.org/package/plzwrk-0.0.0.3 (mikesol)
23:58:50 <d2ci8xc5> I've emailed the author for when he's bringing out the physical copy and he just said soon so I hope it's still in the pipelines because it's been 'soon' for quite a while haha
23:58:55 <EvanR> whether or not it's backwards, that's how I think of it to make it make sense
