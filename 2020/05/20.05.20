01:21:15 * hackage numhask-prelude 0.5.0 - A numeric prelude  https://hackage.haskell.org/package/numhask-prelude-0.5.0 (tonyday567)
01:28:52 <jackdk> Axman6: I saw someone add barewords to ruby once, I think by overriding `Kernel#method_missing` `:D`
01:30:40 <yushyin> nice
01:38:25 <jackdk> looks like it's harder to do in ruby 1.9+, and I don't really want to load the MOP back into my brain ^^
01:41:45 * hackage numhask-hedgehog 0.4.0 - Laws and tests for numhask  https://hackage.haskell.org/package/numhask-hedgehog-0.4.0 (tonyday567)
02:01:35 <__monty__> Then why can't you convert the function to accumulator style?
02:01:52 <__monty__> whoops
02:25:57 <phadej> when it's not linear scan!
03:38:29 <Cheery> purescript seem to assign haskell structures on JS structures. It's sort of like an evaluator function.
03:39:19 <phadej> galaxy brain: compiler is partially evaluated interpreter
03:39:27 <Cheery> it's quite well founded to theory.
03:41:21 <tdammers> phadej: "haskell is a dynamically typed, interpreted language; unfortunately, it doesn't have lists, function composition, or currying built into it"
03:41:35 <phadej> tdammers: :)
03:41:48 <phadej> tdammers: DataKinds...
03:43:08 <phadej> someone should propose DadaKinds though "...movement consisted of artists who rejected the logic, reason, and aestheticism..."
03:49:25 <heebo> hello can anyone review this code im writing for an SQL DDL Parser using Trifecta, https://paste.ofcode.org/mpEqNWPmcKfQstw43hJpgz
03:50:36 <heebo> i was trying to just parse the first table and schema name out of the ddl file as a stopgap. but i seem to get the error detailed
03:50:49 <heebo> any ideas are appreciated
04:11:26 <[exa]> heebo: seems a bit like it fails in the middle and then tries to parse another createtable there
04:12:50 <[exa]> heebo: anyway you might better convert the whole thing to monadic sequence, like:
04:14:57 <[exa]> do { string "CREATE ... " ; schema <- brackets (many notBracketChar) ; char ~.
04:15:30 <[exa]> .... char '.'; name <- brackets (...); return ... }
04:15:57 <[exa]> (I got dropped by SSH and the ~. somehow got through, sorry :] )
04:20:24 <tdammers> phadej: dadaism was absolutely glorious
04:20:39 <tdammers> also, completely underestimated in its impact on modern art
04:24:00 <maerwald> tdammers: I liked this piece where someone filled up an entire apartment with cardboard boxes (like, all of it)
04:24:50 <tdammers> wonderful
04:25:08 <maerwald> but I would say it isn't on the brink of madness, it is far beyond :)
04:25:40 <tdammers> well, dadaism took the observation that "making sense" or "being logically consistent" aren't requirements for valid art, and ran with it
04:26:14 <tdammers> that's probably its biggest merit - exploring how far you can take nonsensicality while still producing "valid" art
04:26:41 <tdammers> that, and questioning the established presentation forms and categorizations of "art"
04:26:47 <maerwald> Well, going ontopic again: programming is art as well. So what can we learn from it?
04:27:03 <tdammers> programming is not usually art
04:27:08 <tdammers> artisanal; yes
04:27:16 <maerwald> tdammers: perl programs usually have an Art license :P
04:27:30 <maerwald> Maybe it is specific to perl, lol
04:27:52 <tdammers> anything *can* be art if you want it to, including programming
04:28:05 <TMA> that is just a label. nothing would change if their license would be called #:G12415
04:28:11 <tdammers> but most programming isn't art, or at least doesn't primarily intend to be art
04:28:31 <hpc> tdammers: a nice corrolary of that is that anything can *not* be art as well
04:28:52 <phadej> hpc: photographers can be artists, many aren't.
04:29:12 <tdammers> hpc: yes. and more confusingly, being an "art form" doesn't imply that every thing that uses or adheres to that particular "art form" is automatically art
04:30:16 <phadej> or buildings designed by architects
04:30:16 <maerwald> Isn't that the same with science? There has to be a moment of delight.
04:32:19 <tdammers> no, the requirements for "science" are way more rigid and well-understood
04:32:31 <tdammers> Scientific Method and all that
04:33:01 <tdammers> best definition of "art" is "if the artist says it's art, then it is"
04:33:11 <maerwald> tdammers: just following scientific method doesn't really produce science though
04:33:15 <maerwald> or: relevant science
04:33:17 <tdammers> but that doesn't hold for science - just calling something "scientific" doesn't make it science
04:34:09 <tdammers> following scientific method produces science. it may not be useful, interesting, relevant, or novel, but it'll meet the criteria. but more importantly, violating the scientific method makes it "not science"
04:34:26 <tdammers> if you can't come up with a repeatable experiment or proof, then you fail at sciencing
04:34:35 <tdammers> but you can't really fail at art
04:34:40 <maerwald> well, there's also meta-science :)
04:34:49 <maerwald> (e.g. study of science)
04:35:04 <tdammers> yes, so?
04:35:34 <maerwald> just saying, not all science is empirical or even formal
04:36:05 <tdammers> true; and the scientific community has well-defined terms and idioms for saying so
04:36:42 <mac_ava> What about Aristotleâ™¡!?
04:37:51 <tdammers> "historical science" - Aristotle was pre-scientific-method, so you can't hold him up to those standards, however the goals were already similar, just not made explicit or formalized yet
04:38:55 <maerwald> as was astrology
04:39:39 * maerwald looks up his daily horoscope
04:39:54 <mac_ava> His idea
04:40:53 <tdammers> Aristotle was wrong on a lot of things, but he was instrumental in promoting the idea of relying on observation and rational thought rather than guesswork and wishful thinking
04:43:57 <maerwald> tdammers: Hmm, I remember reading a pamphlet (would need a while to find it) where Aristotle basically stopped the discussion about whether the earth is a sphere via *authority*.
04:47:50 <mac_ava> HIS definition of Time is very impressive to me.
04:53:50 <tdammers> maerwald: I'm not saying he actually applied that idea at all times. More like, "hey, wouldn't it be interesting to do that"
04:54:07 <mac_ava> His Time is "a number of change with respect to the before and after"
04:54:27 <maerwald> tdammers: yeah, but it's a good example of how science evolves in terms of schools and authority still plays a huge role, til today
04:55:09 <mac_ava> Even atom clock is in his hand
04:55:18 <maerwald> This is especially true in sciences that are a bit harder wrt foundations, such as national economics
05:00:00 <merijn> maerwald: That's because while arguments from authority are a logical fallacy, they're in fact perfectly reasonable if you have a Bayesian view of the world :p
05:01:36 <maerwald> merijn: yeah, that's why Popper wrote his book :)
05:01:41 <mac_ava> Basic idea looks simple to anyone, But simple is not easy like Unix KISS philosophical.
05:05:22 <tdammers> there's also the scalability problem of science
05:06:05 <merijn> I'd say the biggest issue is lack of funding and misaligned incentives :p
05:06:21 <mac_ava> We can not build Top from any fragile ground. WE NEED STRONG BASIS.
05:06:45 <tdammers> mac_ava: which kind of completes the circle back to programming
05:07:05 <mac_ava> Think Basic
05:08:05 <maerwald> merijn: you just want money, so you can do cool stuff?!
05:08:23 <mac_ava> What is human nature and core value? Know thyself.
05:08:37 <merijn> maerwald: Yes
05:09:09 <mac_ava> What is my life ?
05:09:26 <mac_ava> What is my ending?
05:09:56 <maerwald> mac_ava: I'm more with Kant on that one. Most of the things you cannot know about yourself. Even if you try.
05:10:52 <tdammers> ah, the old philosophical problem of "reality" and "truth"
05:11:15 <tdammers> if you take it to extreme, you have to question even the "self"
05:11:25 * maerwald dumps the Gettier problem into the channel :P
05:11:39 <tdammers> I like to reason nondeterministically on those things
05:12:14 <tdammers> e.g., I can't tell the difference between a "reality" that includes my "self" and a "simulation" (a.k.a. "The Matrix", a.k.a. Solipsism)
05:12:36 <tdammers> but I can reason in both of them, speculatively, and see if I end up with compatible results
05:13:35 <tdammers> in the "reality" assumption, my actions have consequences that matter greatly, while in the "solipsism" assumption, they might not; but in the "solipsism" assumption, there is no cost to making deliberate choices either, so I might as well operate under the "reality" assumption
05:16:40 <mac_ava> Make good habit that is true asset.
05:17:38 <mac_ava> Take good answer and action
05:18:56 <mac_ava> TIME is Gold. Think your Self.
05:22:33 <mac_ava> Make small changes about your true Value that habit is the Key of Happiness.
05:24:29 <maerwald> Happiness is a system and a fragile one.
05:24:44 <mac_ava> Take plato or Aristotle advice make your only way
05:25:25 <mac_ava> Make mistakes is good.
05:25:44 <mac_ava> That is Freedom.
05:27:35 <kuribas> tdammers: there is more evidence that reality is discrete rather than continuous (energy quanta, atoms, etc...)
05:27:44 <kuribas> so a matrix basically
05:28:12 <kuribas> but then cause and consequence aren't really understood, and mostly an invention to make reasoning more managable.
05:28:18 <maerwald> s/evidence/indicators/
05:29:10 <kuribas> reality is likely not linear, just are view on it is linear
05:29:14 * hackage yesod-paginator 1.1.1.0 - A pagination approach for yesod  https://hackage.haskell.org/package/yesod-paginator-1.1.1.0 (PatrickBrisbin)
05:30:23 <tdammers> kuribas: that's not what I'm talking about *at all*
05:30:44 <maerwald> kuribas: in Anachronox the game there is a weird animal you can save the game at, which supposedly experiences time at once instead of linear (similar to how we experience space at once) :P
05:30:44 <tdammers> kuribas: I'm talking about a much deeper philosophical concern, namely the question whether such a thing as "reality" exists *at all*
05:30:57 <tdammers> and if so, to what degree humans are capable of experiencing it
05:30:58 <kuribas> maerwald: yeah, loved that game
05:31:00 <kuribas> tdammers: right :)
05:31:09 <tdammers> hence my mentioning of "the matrix" (as in the movie)
05:31:15 <kuribas> tdammers: well, speaking about reality isn't reality
05:31:23 <tdammers> of course not
05:31:28 <tdammers> not the point either though
05:31:59 <maerwald> if such thing as reality exists, it is ineffable
05:32:10 <tdammers> yep
05:32:15 <kuribas> reality and existing are the same thing
05:32:26 <kuribas> because if it doesn't exist it isn't reality
05:32:30 <juri_> ... where am i? aren't we supposed to be talking about haskell?
05:32:42 <kuribas> should bring this to haskell-offtopic :)
05:32:47 <tdammers> juri_: we are, only at a VERY abstract level
05:32:59 <juri_> too abstract. :P
05:33:47 * maerwald clears throat and acts like Sokrates at the market place
05:33:53 <maerwald> So: what is true abstraction?
06:29:15 * hackage dobutokO2 0.41.0.0 - Helps to create experimental music from a file (or its part) and a Ukrainian text.  https://hackage.haskell.org/package/dobutokO2-0.41.0.0 (OleksandrZhabenko)
06:32:20 <Sathiana> Is this possible: https://pastebin.com/Ms9Pi05z
06:33:20 <merijn> Sathiana: Eh, move the two lambda arguments to the left of = and done?
06:34:13 <merijn> https://paste.debian.net/1147871/
06:36:32 <joecordingley> hello
06:38:16 <merijn> @hoogle String -> Maybe a -> Either String a
06:38:17 <lambdabot> Data.Either.Combinators maybeToRight :: b -> Maybe a -> Either b a
06:38:17 <lambdabot> Rebase.Prelude maybeToRight :: () => b -> Maybe a -> Either b a
06:38:17 <lambdabot> Network.Haskoin.Util maybeToEither :: b -> Maybe a -> Either b a
06:39:07 <solonarv> no merijn , what you wrote isn't even valid syntax
06:39:31 <solonarv> Sathiana: instead of using a lambda that you immediately apply, use 'let' or 'where'
06:39:49 <merijn> solonarv: Eh, how isn't it valid syntax?
06:40:15 <solonarv> all of line 3 after 'squareSum'
06:40:24 <joecordingley> I was just using aeson for the first time. The first thing that strikes me is that I would like to define records exactly as the json object would be and just derive Generic. And that works well up to a point. That point being hampered by haskell stopping me define the same record field twice. How do people tend to get around this. Do they start defining their own ToJSON FromJSON instances manually?
06:40:32 <merijn> oh, I forgot to delete a brace
06:40:58 <solonarv> in any case, adding extra function arguments isn't what Sathiana was asking about
06:40:58 <merijn> Anyway the answer is always "add more where bindings"
06:41:17 <solonarv> they were crudely emulating a let/where by using a lambda and immediately applying it (qhy!?)
06:41:18 <Sathiana> merijn: I'm aware of that syntax, wass thinking of having Guards inside a lambda function
06:41:28 <merijn> Sathiana: Don't
06:42:01 <solonarv> yeah. don't use a lambda at all, here.
06:42:03 <merijn> joecordingley: Don't rely on entirely automatic deriving
06:42:20 <merijn> joecordingley: It's too brittle and makes it hard to refactor/change things later
06:43:09 <solonarv> Sathiana: write it like this: https://gist.github.com/Solonarv/98fd741d3a64d0600fb673eeb06db770
06:43:15 <merijn> joecordingley: You want your haskell datatype to be decoupled from it's JSON specification so you can change the two independently (so yes, define your own ToJSON/FromJSON instances)
06:43:39 <solonarv> or just eliminate the whole problem by using 'max' instead of reimplementing it ;)
06:44:23 <joecordingley> It's a shame as the record is quite a nice document of the JSON.
06:44:32 <sm[m]> maerwald: aliens and protagonist in Arrival experience Time that way too I believe
06:44:32 <merijn> joecordingley: tbh, I think the aeson reliance on typeclasses is a bad design, tbh :p
06:46:05 <Sathiana> solonarv: Yes, the book also mentions this way, was trying so solve it via lambda (without using Where)
06:46:11 <joecordingley> I could separate the JSON datatypes from the internal datatypes and just have concise functions to transform. But I would have to keep all the JSON records away from each other, too. It could end up as a file per JSON object
06:46:23 <merijn> joecordingley: Binary (for, well, binary serialisation) lets you (optionally) use typeclasses to derive serialisation instead of doing so explicitly. So far I think I've seen a 100% overlap between "projects using the typeclass serialisation" and "projects that have regretted doing so" ;)
06:47:33 <solonarv> Sathiana: ah. in that case the answer is: no you cannot have guards in a lambda, because in a lambda you only get *one* equation with *one* clause to define your function
06:47:44 <joecordingley> I guess I just need to get used to reading ToJson instances rather than JSON ADT representation.
06:48:28 <Sathiana> solonarv: aha i see 
06:48:43 <solonarv> explaining the terminology: in something like 'foo True = "yes"; foo _ = "no"', each of these lines is a separate equation
06:49:27 <ski> (defining equation, one can say)
06:49:29 <solonarv> and 'max x y | x > y = x; | otherwise = y', each of the '| condition = body' things is a clause (and the whole thing is one equation)
06:49:45 * ski . o O ( `\case' )
06:49:56 <solonarv> yes, I was building up to that
06:50:17 <Sathiana> make sense 
06:52:53 <joecordingley> merijn: thanks for the advice
07:11:41 <Cheery> is ghci able to watcha file and check it when it's saved?
07:12:28 <sm[m]> ghcid is for that
07:14:15 * hackage clckwrks-plugin-page 0.4.3.22 - support for CMS/Blogging in clckwrks  https://hackage.haskell.org/package/clckwrks-plugin-page-0.4.3.22 (JeremyShaw)
07:20:43 <merijn> heh
07:20:50 <merijn> ByteString doesn't have a mapM/forM?
07:36:05 <dsal> joecordingley: you can name record fields _t_name for field "name" of type T -- I do that in many of mine
07:36:15 * hackage snap-server 1.1.1.2 - A web server for the Snap Framework  https://hackage.haskell.org/package/snap-server-1.1.1.2 (DougBeardsley)
07:38:15 * hackage dobutokO3 0.1.0.0 - Helps to create more complex experimental music from a file (especially timbre).  https://hackage.haskell.org/package/dobutokO3-0.1.0.0 (OleksandrZhabenko)
07:40:32 <dsal> joecordingley: e.g., https://github.com/dustin/gopro-plus/blob/master/src/GoPro/Plus/Media.hs#L137
08:07:15 * hackage sixel 0.1.2.0 - Sixel library to show images in a terminal emulator  https://hackage.haskell.org/package/sixel-0.1.2.0 (junjihashimoto)
08:11:08 <ezzieyguywuf> how can I do `newtype MyType = [Int]` such that `length (MyType [1,2,3])` works as expected
08:11:35 <ezzieyguywuf> do I need to do `deriving` in the `newtype` definition? if so, what do I derive?
08:11:48 <Cheery> ezzieyguywuf: implement Foldable t
08:11:52 <phadej> you cannot make `length` work `MyType`
08:12:06 <phadej> it has to be of `MyType a`
08:12:49 <Cheery> right, it needs to be abstract since the interface expects it to be.
08:20:44 <ezzieyguywuf> so, `length [1,2,3]` obviously works as expected
08:21:23 <ezzieyguywuf> but even though `MyType` is a `[Int]`, just like `[1,2,3]`, I can't expect to "easily" have `length (MyType [1,2,3])` work?
08:21:38 <ezzieyguywuf> i.e. I have to manually write a Foldable implementation for MyType?
08:22:20 <ArsenArsen> does ghc support out of tree building?
08:23:09 <ski> ezzieyguywuf : i think you could derive it ?
08:25:50 <solonarv> ArsenArsen: you mean something like your source code living in ~/my-project-src, but the build happening in /build/my-project-build ?
08:26:24 <ArsenArsen> solonarv: yes, but just to be clear: I'm building ghc itself
08:27:01 <merijn> ArsenArsen: Might wanna check out #ghc ? :)
08:27:14 <ArsenArsen> TIL of it's existance, absolutely
08:27:27 <solonarv> ah. I don't know much about GHC's build system, but in general GHC does let you configure the build dir via command line argument (both cabal and stack use this to direct it to ./stack-work or ./dist-newstyle)
08:28:04 <solonarv> definitely ask there as well. hadrian (the GHC build system) is a bit of a complex beast itself AFAIK
08:35:46 * hackage ihaskell-hvega 0.2.5.0 - IHaskell display instance for hvega types.  https://hackage.haskell.org/package/ihaskell-hvega-0.2.5.0 (DouglasBurke)
08:49:28 <dmwit> ezzieyguywuf: In case what phadej told you wasn't clear, `newtype MyType a = MyType [a] deriving Foldable` is okay but `newtype MyType = MyType [Int]` cannot be made an instance of `Foldable` in any way, deriving or otherwise.
08:50:37 <dmwit> (Should length be in a separate typeclass than Foldable, since it never touches the elements? Arguably. But that's not the world we live in.)
08:52:53 * nshepperd . o O (class Length a where length :: a -> Int)
08:53:14 <dmwit> merijn: http://hackage.haskell.org/package/mono-traversable-1.0.15.1/docs/Data-MonoTraversable.html#v:omapM
08:53:16 * hackage sixel 0.1.2.1 - Sixel library to show images in a terminal emulator  https://hackage.haskell.org/package/sixel-0.1.2.1 (junjihashimoto)
08:53:44 <merijn> dmwit: Yes, but then I might as well just unpack and traverse
08:54:00 <dmwit> Yes, that is how the instance works.
08:54:03 <dmwit> I agree it's a bummer.
08:54:08 <merijn> dmwit: Vector, containers, text, etc. expose mapM/forM
09:03:15 * hackage http-io-streams 0.1.4.0 - HTTP and WebSocket client based on io-streams  https://hackage.haskell.org/package/http-io-streams-0.1.4.0 (HerbertValerioRiedel)
09:03:48 <ornxka> whats the easiest way to get a framebuffer + input events in haskell
09:04:27 <sm[m]> sdl2 I guess
09:05:00 <ornxka> ty
09:06:18 <sm[m]> if youâ€™re ok with drawing instead of a frame buffer, then gloss
09:24:45 * hackage clckwrks-theme-bootstrap 0.4.2.3 - simple bootstrap based template for clckwrks  https://hackage.haskell.org/package/clckwrks-theme-bootstrap-0.4.2.3 (JeremyShaw)
09:34:12 <srid> grr, can't use JSON with `withSome`
09:38:24 <Cheery> https://gist.github.com/cheery/9fe87d534909cc8795e02b6109b80fb3
09:42:04 <Cheery> not sure what's going on there.
10:03:20 <maerwald> sm[m]: I would imagine moving through space for them is like moving through time for us. So you'd probably make a single spatial journey in your entire life. Move from city A to city B, then die.
10:04:00 <maerwald> And your life is contrained by the amount of space you covered.
10:08:40 <sm[m]> could be, though the human could overview both space and time
10:10:23 <wavemode> but you're always hurtling through space at hundreds of thousands of miles per hour. so by "space" you would need to specify "relative to the earth"
10:12:15 * hackage threepenny-gui 0.8.3.2 - GUI framework that uses the web browser as a display.  https://hackage.haskell.org/package/threepenny-gui-0.8.3.2 (sjakobi)
10:14:02 <maerwald> wavemode: you seem to have more experience with space-time travel :)
10:15:18 * sm[m] orders https://www.amazon.com/Stories-Your-Life-Others-Chiang/dp/1101972122
11:00:59 <dsal> srid: What;s withSome?
11:03:11 <srid> > import Data.Some
11:03:13 <lambdabot>  <hint>:1:1: error: parse error on input â€˜importâ€™
11:03:24 <srid> (Can't the bot import from hackage?)
11:03:27 <srid> dsal: https://hackage.haskell.org/package/some-1.0.1/docs/Data-Some.html#v:withSome
11:05:29 <dsal> hmm...   I should try using that.
11:06:12 <solonarv> srid: not from every package on hackage, only a manually-selected subset
11:06:18 <solonarv> I don't know who maintains it, though
11:06:29 <nshepperd>  > is for evaluating expressions
11:06:33 <dsal> % import Data.Some
11:06:33 <yahb> dsal: ; <no location info>: error:; Could not find module `Data.Some'; Perhaps you meant Data.Time (from time-1.9.3)
11:06:41 <dsal> Oh yeah, Time
11:06:43 <solonarv> @let import Data.Some
11:06:45 <lambdabot>  Defined.
11:06:59 <solonarv> oho! it does have that package!
11:07:03 <solonarv> @type withSome
11:07:04 <lambdabot> forall k (tag :: k -> *) b. Some tag -> (forall (a :: k). tag a -> b) -> b
11:07:56 <dsal> I haven't done anything particularly fancy with types.  Too much "I just want to write this server" kinds of things.
11:09:16 <solonarv> okay this seems like a reasonable library. I think I've unknowingly mentioned it a few times, even.
11:28:15 * hackage data-ascii 1.0.0.2 - Type-safe, bytestring-based ASCII values  https://hackage.haskell.org/package/data-ascii-1.0.0.2 (chris_martin)
11:28:54 <rsoeldner> Hi, just encountered an cabal issue with xsd, see https://gist.github.com/rsoeldner/089f27dbe161c2951e8a9e09510c5183 Do I understand the error message correctly, I'm using a "to new" cabal version ? :-/
11:29:15 * hackage ascii 1.0.0.2, ascii-th 1.0.0.2, ascii-group 1.0.0.2, ascii-case 1.0.0.2, ascii-predicates 1.0.0.2, ascii-char 1.0.0.2 (chris_martin)
11:30:15 * hackage ascii-superset 1.0.0.2 - Representing ASCII with refined supersets  https://hackage.haskell.org/package/ascii-superset-1.0.0.2 (chris_martin)
11:31:30 <solonarv> rsoeldner: looks like that is indeed what the error message says. very unfortunate!
11:33:05 <rsoeldner> solonarv, I thought cabal is backward compatible :-/ 
11:33:58 <solonarv> no, major version changes (the 'X.Y' part in 'X.Y.Z.T') can break backwards compat
11:34:18 <solonarv> and anyway, backwards compat doesn't mean "we will just silently ignore version bounds"
11:35:16 <solonarv> the authot of this package 1) hasn't touched the code in 6 years, and b) apparently hasn't given much thought to forwards compat
11:36:46 <rsoeldner> solonarv, thanks for the explanation :)
11:37:46 <solonarv> frankly I'm not even sure what that complicated Setup.lhs is supposed to do. I think it generates a list of all dependencies and their versions in order to cobble together a doctest command line?
11:39:43 <solonarv> okay, looks like doctest still works sort of like that but there are now helpers for it
11:40:08 <solonarv> this appears to be a case of bit rot
11:40:31 <solonarv> cabal had to go through some pretty large changes in the past few years because the old way of building just didn't work all that well
11:42:26 <isovector1> is there some way to get profile information for code running in TH splices?
11:47:49 <rsoeldner> solonarv, I understand
11:50:45 * hackage data-forest 0.1.0.8 - A simple multi-way tree data structure.  https://hackage.haskell.org/package/data-forest-0.1.0.8 (chris_martin)
11:54:15 * hackage loc 0.1.3.8 - Types representing line and column positions and ranges in text files.  https://hackage.haskell.org/package/loc-0.1.3.8 (chris_martin)
11:55:15 * hackage loc-test 0.1.3.8 - Test-related utilities related to the /loc/ package.  https://hackage.haskell.org/package/loc-test-0.1.3.8 (chris_martin)
11:57:15 * hackage partial-semigroup 0.5.1.6 - A partial binary associative operator  https://hackage.haskell.org/package/partial-semigroup-0.5.1.6 (chris_martin)
11:58:16 * hackage partial-semigroup-hedgehog 0.6.0.6 - Property testing for partial semigroups using Hedgehog  https://hackage.haskell.org/package/partial-semigroup-hedgehog-0.6.0.6 (chris_martin)
11:59:16 * hackage aura 3.0.0 - A secure package manager for Arch Linux and the AUR.  https://hackage.haskell.org/package/aura-3.0.0 (fosskers)
11:59:18 * hackage path-text-utf8 0.0.1.6 - Read and write UTF-8 text files  https://hackage.haskell.org/package/path-text-utf8-0.0.1.6 (chris_martin)
12:17:38 <MarcelineVQ> Is there a (popular) license as permissive as MIT but you are also permitted to not include it in derivative software? In essence just the "there's no warranty, leave me alone" part https://opensource.org/licenses/MIT
12:18:44 <monochrom> Does BSD do it?
12:18:56 <maerwald> BSD-2?
12:20:05 <monochrom> There is also a half-joke half-serious half-position-statment (alright I can't count) "do whatever the fuck you want" license, I forgot the exact name.
12:20:14 <maerwald> WTFPL
12:20:27 <maerwald> But it isn't clear how well that would hold in court
12:21:18 <dsal> "And what was the name of this license, again?"  "WTF, your honor"
12:21:47 <monochrom> My angle is it's pretty clear no one will bring it to court :)
12:21:59 <MarcelineVQ> hmm bsd-3 isn't too bad. I'll keep looking around, thank you
12:22:38 <wavemode> BSD-3 also requires retention of the copyright notice
12:23:01 <wavemode> use the CC0 license
12:23:23 <juri_> I agplv3 my software, that way no-one uses it. :P
12:23:30 <MarcelineVQ> basically I want to impose on people as little as possible but also be clear that I'm not support staff, I'm not involved if you misuse or something goes wrong
12:23:33 <dsal> juri_: I don't need such a deterrent.
12:24:10 <dsal> MarcelineVQ: Yeah.  I really just want "I made this.  I hope you like it.  I don't want to hear if you don't."
12:24:18 <dsal> (useful bugs are fine)
12:24:29 <dmwit> I vaguely recall there being a successor to the WTFPL, noting that the WTFPL was *too* free in that in particular it permitted users to complain.
12:24:39 <MarcelineVQ> More like, don't take my ass to court if your business servers crash
12:24:45 <dsal> WTFSTFUPL
12:25:11 <wavemode> CC0 dedicates the software to the public domain. In jurisdictions that do not recognize a public domain, it releases the software as permissively as possible, imposing no restrictions. It also includes a notice that there is no warranty.
12:25:13 <dsal> I got an email recently from some random person asking me how my software was used in like, some vpn software I'd never heard of.
12:26:44 * hackage stripe-concepts 1.0.2.4 - Types for the Stripe API  https://hackage.haskell.org/package/stripe-concepts-1.0.2.4 (chris_martin)
12:27:45 * hackage stripe-wreq 1.0.1.4, stripe-signature 1.0.0.4, stripe-scotty 1.0.0.4 (chris_martin)
12:28:13 <MarcelineVQ> I'll probably just leave as CC0 for now, though CC0 itself says it's not for software. I don't want a copyright because (and this might come as a shock) MarcelineVQ does't exist :>
12:28:45 * hackage d10 0.2.1.4 - Digits 0-9  https://hackage.haskell.org/package/d10-0.2.1.4 (chris_martin)
12:28:55 <monochrom> My whole world vanishes in a puff of logic...
12:29:11 <dsal> MarcelineVQ was a M Night Shyamalan character the whole time.
12:30:08 <wavemode> One of the guy's multiple personalities in split
12:31:38 <dsal> et cetera
12:46:15 * hackage row-types 0.4.0.0 - Open Records and Variants  https://hackage.haskell.org/package/row-types-0.4.0.0 (dwincort)
12:57:20 <hseg> ghcid --command 'cabal repl component' works, but plain ghcid with .ghcid having contents --command 'cabal repl component' doesn't
12:57:22 <hseg> ideas?
12:57:45 <hseg> judging by the error, it seems to be trying to literally call 'cabal repl component'
12:59:01 <hseg> moreover, i can't manage to add a --test flag in .ghcid -- it seems ghcid strips it
12:59:21 <hseg> but again, passing it explicitly works
13:06:45 * hackage clckwrks-plugin-media 0.6.16.9 - media plugin for clckwrks  https://hackage.haskell.org/package/clckwrks-plugin-media-0.6.16.9 (JeremyShaw)
13:18:20 <hseg> trying to debug the above -- why does cabal repl on a test-suite not know what module main is in? :main fails
13:22:09 <hseg> similarly, :l Main complains i'm missing the relevant other-modules, but they're right there!
13:44:06 <gentauro> I'm parsing some `bytes` and I'm writting some samples in `emacs`. It's a bit annonying that `emacs` keeps appending `\n` at the end. Anyway to check for this (and skip) without having to use `last`? https://hackage.haskell.org/package/bytestring-0.10.10.0/docs/Data-ByteString-Lazy.html#v:last
13:45:26 <pie_> apparently this gets HN-d a lot (not that i regularly read hn) and I havent seen it yet http://winestockwebdesign.com/Essays/Lisp_Curse.html
13:45:45 * hackage box 0.4.0 - boxes  https://hackage.haskell.org/package/box-0.4.0 (tonyday567)
14:01:06 <sfogarty> I am finally moving to cabal v3, and having a hard time finding documentation on how to deal with store vs. packagedb vs install. cabal install --lib hspec shows "up to date", but cabal info shows "not installed". It does exist in the cabal\store directory. I've found several posts explaining this is, indeed, the new behavior... but not on how to
14:01:06 <sfogarty> actually load it into a project.
14:01:31 <monochrom> pie_: Heh, the Haskell curse of many stream libraries? :)
14:02:27 <monochrom> sfogarty: I think "cabal info" is stuck at v1 semantics.
14:03:08 <solonarv> sfogarty: if you want to use a library in a project, add the library to 'build-depends' in the corresponding xyz.cabal file
14:03:16 <solonarv> no need to 'cabal install' anything
14:03:23 <monochrom> In a project, you never use or care about "install --lib".  You do what solonarv said.
14:04:02 <monochrom> dependencies will be built as needed or reused if possible upon you saying "v2-build" etc.
14:04:08 <monochrom> even "v2-repl"
14:04:39 <gentauro> nevermind, I just go through all the bytes and if the last is `[0x0A] = [] -- skip '\n' if eof`
14:04:53 <monochrom> You can omit "v2-" but I am just emphasizing.
14:04:54 <sfogarty> Is there a guide to v2 (=3.0?) semantics? The quickstart still mentions/suggests cabal install. 
14:05:25 <solonarv> which quickstart do you mean?
14:05:31 <monochrom> chapter 5 "nix-style so-and-so"?
14:05:37 <sfogarty> https://www.haskell.org/cabal/users-guide/
14:06:36 <monochrom> It is possible that the cabal user guide needs a re-ordering because v2 semantics is the default now, but the user guide was written with v1 semantics in mind when v1 was the only thing.
14:06:48 <solonarv> hm, that appears to be a bit dated
14:07:11 <solonarv> https://cabal.readthedocs.io has newer things
14:07:16 <monochrom> And this is one of those times when I say "would you like to hear an Aesop fable?" :)
14:07:34 <solonarv> (and it has a "Getting Started" section that correctly uses the v2 stuff)
14:07:39 <monochrom> Yes but it's still the same user guide except chapter 5 is up to date.
14:07:40 <sfogarty> Still suggests I use cabal-install
14:07:49 <maerwald> this is almost as bad as "how do I install haskell" where you navigate through 3 or 4 different pages
14:07:54 <monochrom> Basically chapter 1 has never changed.
14:08:01 <solonarv> 'cabal-install' is also the name of the package that provides the 'cabal' executable
14:08:08 <solonarv> very confusing
14:08:12 <sfogarty> Sorry, cabal install, not cabal-install
14:09:29 <monochrom> Anyway start with chapter 5
14:10:15 <sfogarty> Chapter 5 starts with "you are in a directory with a cabal package you want to build."
14:10:23 <monochrom> basically only read chapters 5 and 3.  chapters 1 and 2 are for v1 semantics.
14:10:28 <sfogarty> I am not yet in  such a directory. I simply want to load existing cabal packages in ghci.
14:10:52 <monochrom> Then perhaps you like v1 semantics.  v1-install etc.
14:11:46 <monochrom> But if you say the magic word "project", people takes it you mean you are writing your own package. (Therefore you are in a directory with a cabal package you want to build --- your package.)
14:12:27 <sfogarty> Okay, then is there a way to use the global v2 store outside of a cabal package?
14:12:34 <monochrom> No.
14:13:15 <monochrom> Some people say "yes, cabal v2-install --lib".  Sure.  But since you're asking, it is not working out.
14:13:37 <monochrom> I personally find it too fragile.  It works under very specific conditions only.
14:14:00 <sfogarty> The first time I did the install was without the --lib, so that may have caused it
14:14:07 <monochrom> If you're doing it, you still have v1 use cases in mind, so you should use v1.
14:14:23 <solonarv> however if you want a one-off repl you can just 'cabal v2-repl -b package1 -b package2'
14:14:31 <monochrom> Without --lib, it installs the executables (if any)
14:14:43 <solonarv> (if there are no executables, it complains at you)
14:14:44 <monochrom> Yeah that's much better.
14:14:48 <sfogarty> It complained, I re-ran it with lib, and nothing happened.
14:15:39 <sfogarty> I think trying to show my students how neat haskell is with "cabal v2-repl -b hspec -b ansi-terminal -b colour -b " is going to go over a bit poorly, tbh.
14:15:48 <monochrom> I don't understand why the experts and opinion leaders scaremonger against v1.
14:17:13 <monochrom> There are a lot of beginners and old-timers who really have v1 use cases, have v1 expectations, and are OK with its downsides, or even completely unaffected by its downsides.
14:18:08 <solonarv> using v1 commands is *supposed* to be unnecessary, unfortunately they haven't quite reached parity yet
14:18:31 <solonarv> if install --lib worked correctly, surely you would not need v1 commands for this anymore?
14:18:34 <sfogarty> I think having both project-specific packages and global store sounds great, especially if it is will just install an old required version if the global store is updated. That it doesn't work natively/easily with haskell files outside of a cabal package is.. frustrating.
14:19:48 <monochrom> Define "work correctly".  My definition includes "the docs are installed at a predictable, stable location".  I bet you it will never happen.
14:20:35 <c_wraith> how can it, when the docs can change with install flags?  (They shouldn't, but they can)
14:21:10 <c_wraith> Fortunately ghci has :doc now
14:21:23 <c_wraith> It's not as nice as html, but it often does the job
14:21:36 <solonarv> you said that you find it too fragile and it works under very specific conditions only
14:21:38 <monochrom> It can be done if I accept the "unsafe" stance that every doc rebuild overwrites the previous doc build.
14:22:05 <solonarv> I was referring to whatever exact problems you meant by that (which given the context I assume v1 does/did not have)
14:22:18 <monochrom> Have you actually tried :doc lately?  My finding is it only works for stuff that comes with GHC.  That's right, not even docs installed by v1.
14:23:08 <solonarv> hm. would you be satisfied with the docs being installed somewhere in the store (with hashes in the path, and so on) but being symlinked to soem predictable location?
14:23:16 <monochrom> Yes.
14:24:56 <solonarv> okay, that seems to me like it should be possible
14:25:07 <c_wraith> windows strikes again :(
14:25:35 <solonarv> bah, same logic as for executables: have a 'copy' fallback
14:25:48 <solonarv> I guess copying docs is a bit weightier than copying binaries
14:26:11 <monochrom> I think it's the opposite, given GHC linking on windows.
14:26:55 <monochrom> But I suspect that windows doesn't stop getting this done.  Windows has a notion of symlinks, too.
14:29:22 <solonarv> it does, but on older versions it's weird and finicky
14:43:15 * hackage aeson-injector 1.1.3.0 - Injecting fields into aeson values  https://hackage.haskell.org/package/aeson-injector-1.1.3.0 (NCrashed)
15:09:47 <koz_> I'm having this weird issue where I'm doing 'foo <- doFoo; bar <- doBar; pure Baz{..}' with RecordWildcards on, and I get complaints like 'Constructor 'Baz' does not have the required strict field(s): foo, bar'.
15:09:58 <koz_> Even though (my analog of) those things 100% does have those fields.
15:18:57 <lifelearner> Hello
15:21:45 * hackage web-rep 0.5.0 - representations of a web page  https://hackage.haskell.org/package/web-rep-0.5.0 (tonyday567)
15:22:45 * hackage numhask-array 0.6.0 - n-dimensional arrays  https://hackage.haskell.org/package/numhask-array-0.6.0 (tonyday567)
15:24:44 <monochrom> koz_: That's strange. I can't reproduce it in a standalone example. I even have "f xy = let xn=4 in X{..}".  (data X = X{xy :: !Int, xn :: !Int})
15:24:59 <koz_> monochrom: I agree, it is strange.
15:25:22 <koz_> I'll poke about at it a bit more I guess.
15:29:18 <koz_> monochrom: Huh, this is interesting.
15:29:24 <koz_> How you import affects this.
15:29:43 <koz_> My original import was the equivalent of import MyModule (Baz(Baz)), and on this, it breaks.
15:29:45 <koz_> But if I do
15:29:51 <koz_> import MyModule (Baz(..)), it works.
15:30:08 <koz_> Am I missing something regarding records?
15:31:27 <monochrom> Yikes.
15:31:32 <koz_> Is this a bug?
15:32:45 * hackage cornea 0.3.0.0 - classy optical monadic state  https://hackage.haskell.org/package/cornea-0.3.0.0 (tek)
15:33:30 <ACHLO> https://youtu.be/Dr7HGkP74mE
15:33:41 --- mode: ChanServ set +o monochrom
15:33:47 --- mode: monochrom set +b *!*@41.249.39.106
15:33:47 --- kick: ACHLO was kicked by monochrom (ACHLO)
15:33:52 --- mode: monochrom set -o monochrom
15:34:02 <monochrom> I think the Haskell Report doesn't say!
15:34:14 <koz_> RecordWildCards is part of the Haskell Report?
15:34:40 <monochrom> No, but the question of how much "Type(Ctor)" imports is.
15:35:19 <koz_> Yeah, I guess the field... functions? Selectors? Spiffies? have to be dragged in for RecordWildCards to do its work.
15:36:02 <monochrom> but perhaps it wants you to say "X(X, xy, xn)" for my X type
15:36:11 <koz_> monochrom: Let me try that.
15:36:12 <MarcelineVQ> That seems reasonable, otherwise you could turn that on and break into abstract datypes
15:36:32 <koz_> Yep!
15:36:36 <koz_> That solves it.
15:37:07 <koz_> The thing is, you're importing the constructor already.
15:37:10 <koz_> You can already break in.
15:37:46 <monochrom> A point to note is that "data Y = Y1{y :: Int} | Y2{y :: Int, b :: Bool}" is a good reason to require saying "y" on its own. It no longer "belongs" to Y1 or Y2.
15:38:34 <koz_> Ah, OK.
15:39:44 <koz_> Yeah, that's a good point.
15:39:48 <koz_> Good discovery though.
15:40:20 * monochrom should have gone to law school.
15:42:58 <koz_> Does hedgehog have a way to generate LocalTime?
16:07:15 * hackage readme-lhs 0.6.0 - See readme.md  https://hackage.haskell.org/package/readme-lhs-0.6.0 (tonyday567)
16:24:26 * sm[m] thinks new cabal would have been better with a new name
16:24:43 <koz_> sm[m]: coven.
16:24:53 <koz_> Or 'hermetic-circle'.
16:25:02 <wavemode__> yeah they should call it "stack"
16:25:03 <koz_> Or 'conspiracy' maybe? :P
16:25:27 <sm[m]> cobble ?
16:25:32 <koz_> wavemode__: I forget who made the joke that someone needs to found a company named NPComplete, whose toolchain is called 'queue'.
16:25:54 <sm[m]> caper ?
16:26:05 <wavemode__> koz_: hahaha
16:26:12 <sm[m]> itâ€™s not too late
16:26:18 <koz_> wavemode__: I am afraid I can take no credit for this humour.
16:26:24 <koz_> (I personally don't think it's aiming high enough)
16:27:03 <koz_> (something like 'PSPACEComplete' and 'deque' maybe)
16:33:45 * hackage cornea 0.3.0.1 - classy optical monadic state  https://hackage.haskell.org/package/cornea-0.3.0.1 (tek)
17:12:15 * hackage perf 0.6.0 - Low-level run time measurement.  https://hackage.haskell.org/package/perf-0.6.0 (tonyday567)
17:13:15 * hackage perf-analysis 0.3.0 - analysis example using perf  https://hackage.haskell.org/package/perf-analysis-0.3.0 (tonyday567)
17:27:15 * hackage chart-svg 0.0.3 - Charts in SVG  https://hackage.haskell.org/package/chart-svg-0.0.3 (tonyday567)
17:33:01 <pie_> re, me posting this earlier: apparently this gets HN-d a lot (not that i regularly read hn) and I havent seen it yet http://winestockwebdesign.com/Essays/Lisp_Curse.html
17:33:19 <pie_> as a counterpoint, have any smug lisp weenies actually managed to get together and make something awesome?
17:33:45 * hackage zeolite-lang 0.7.0.1 - Zeolite is a statically-typed, general-purpose programming language.  https://hackage.haskell.org/package/zeolite-lang-0.7.0.1 (ta0kira)
17:35:30 <wavemode__> you hear anecdotal stories here and there of a company using lisp as its "secret weapon"
17:38:06 <argent0> hi, I was trying to use 'reflex' through nix and got `reflex ... is marked as broken`. Same for 'reactive-banana'. What could be the issue?
17:42:31 <wavemode__> overall though, I believe the essay is correct. as powerful and flexible as lisp is (I'm speaking personally about common lisp), there's no momentum behind standardizing a "right" way of doing anything. lisp by its very nature encourages you to invent your own solution to every problem
17:46:39 <koz_> I would basically argue that 'Lisp' doesn't exist.
17:46:43 <koz_> It's a concept, like 'art'.
17:46:51 <koz_> You can have different expressions of it, some better, some worse.
17:47:03 <koz_> Common Lisp is, IMHO, extremely bad.
17:47:16 <justsomeguy> I've heard lispers say that haskell is a lisp. It was a confusing moment.
17:47:26 <koz_> And the fact that non-trivial subsets of the community think that it's good tells you about all you need to know.
17:47:38 <koz_> justsomeguy: That further reinforces what I just said before. :P
17:47:44 <koz_> 'Lisp' isn't a concrete entity.
17:47:52 <koz_> It's 'whatever you think "good" means right now'.
17:50:19 <wavemode__> There is a specific family of languages which fall under the moniker "lisp". haskell is on a completely different end of the spectrum. the word lisp does have a specific meaning, even though many people seem to have forgotten what it is
17:50:32 <koz_> wavemode__: What would you say that meaning is?
17:51:29 <MarcelineVQ> I would say someone calling haskell a lisp just hasn't heard the term lambda calculus yet, so all lambda calculus are lisp
17:51:38 <k4zysh> hello.
17:51:44 <wavemode__> If a language is homoiconic and dynamically metaprogrammable, I would call it a lisp
17:51:44 <koz_> k4zysh: Sup?
17:53:23 <koz_> wavemode__: I'm pretty sure _assembly_ qualifies.
17:53:50 <wavemode__> assembly is not homoiconic
17:54:58 <koz_> "A language is homoiconic if a program written in it can be manipulated as data using the language" <-- why can't you manipulate assembly in assembly? Self-modifying code is a thing.
17:55:16 <koz_> Unless this is not your definition of homoiconicity.
17:55:32 <justsomeguy> Is haskell metaprogrammable with compiler extensions?
17:55:54 <k4zysh> koz, what is sup? i'am from Brazil, sorry..
17:55:58 <dmwit> Yes, TemplateHaskell.
17:56:06 <koz_> k4zysh: It's short for 'what's up?'. Generic greeting.
17:56:20 <dmwit> k4zysh: It's another way to say "hi".
17:56:27 <k4zysh> ah, thanks :)
17:56:47 <justsomeguy> It's kind of like "Que pasa?"
18:04:08 <wavemode__> koz_: but you're talking about two different levels of abstraction. asm as a language is a sequence of instructions and associated operands. asm as data is an array of bytes.
18:05:14 <koz_> The exact same reasoning can be applied to, say, Scheme. Technically, Scheme source is also an array of bytes.
18:05:21 <wavemode__> whereas a lisp program is just a lisp list. as data it's still just a list
18:07:49 <wavemode__> koz_: again, you're mixing levels of abstraction. scheme the language is not the same thing as scheme the text file. if I write a macro in scheme, I can manipulate the statements and expressions of the program itself as a list, then execute the list as a program. a text file is just text - you'd have to feed it through a parser
18:11:45 * hackage monadic-recursion-schemes 0.1.10.0 - Recursion Schemes for Monadic version.  https://hackage.haskell.org/package/monadic-recursion-schemes-0.1.10.0 (KatsutoshiItoh)
18:13:01 <jumper149> Hi, can I have a whole WAI application under a route with servant?
18:14:53 <jumper149> I would like to use eventSourceAppChan as a Handler: https://hackage.haskell.org/package/wai-extra-3.0.29.1/docs/Network-Wai-EventSource.html#v:eventSourceAppChan
18:15:51 <jumper149> So my API would look something like `"sse" :> Raw :<
18:16:39 <jumper149> So my API would look something like `"sse" :> Raw :<|> ...`
18:23:28 <k4zysh> koz_ see PM
18:30:25 <koz_> k4zysh: Anything you wanna ask, please ask the whole channel.
18:30:34 <koz_> If it's not Haskell-related, ask somewhere else.
18:31:10 <k4zysh> okay
18:44:36 <jumper149> Yey: I found this and it fixed it for me :) http://hackage.haskell.org/package/servant-rawm-0.3.2.0/docs/Servant-RawM.html
19:15:45 * hackage online 0.5.0 - online statistics  https://hackage.haskell.org/package/online-0.5.0 (tonyday567)
19:17:15 * hackage ruby-marshal 0.2.0 - Parse a subset of Ruby objects serialised with Marshal.dump.  https://hackage.haskell.org/package/ruby-marshal-0.2.0 (filib)
19:49:22 <jumper149> Is there a library allowing me to send http requests from the Effect monad with GHCJS?
21:12:53 <remexre> what's the right way w/ happy-hunit to produce logs that only show on failure?
21:15:09 <remexre> er, sorry, tasty-hunit
21:28:53 <dsal> remexre: what do you mean?
21:30:04 <dsal> remexre: Do you want HideSuccesses ?
21:30:36 <remexre> dsal: I;ve got a bunch of tests that can either produce a lot of output or not, via putStrLn
21:30:52 <remexre> I'd like the output to not go to the console unless the test fails
21:31:37 <remexre> (though I guess option 2 is that I just run the test in quiet mode, and disable quiet mode only when I'm debugging)
21:32:32 <dsal> Ah.  The test failure itself only shows on failure, so you can just use that facility.
21:52:00 <matt2> Hi
21:52:21 <matt2> Does anyone know how can I make trace/print in let statement?
21:53:12 <dsal> matt2: Debug.Trace?
21:53:43 <matt2> yea, but how to use it in let xxx in statement?
21:55:02 <dsal> :t traceShow
21:55:04 <lambdabot> error: Variable not in scope: traceShow
21:55:15 <dsal> % :t traceShow
21:55:16 <yahb> dsal: Show a => a -> b -> b
21:55:48 <dsal> % let x = traceShow 4 6 in   x
21:55:49 <yahb> dsal: 4; 6
21:56:17 <dsal> That's not super clear, but it prints the first argument and then returns the second.
21:57:12 <dsal> % let x = trace "you are here" 6 in   x + 4
21:57:12 <yahb> dsal: you are here; 10
21:59:44 <matt2> I was using it like that with traceShow, but it does not work :(
21:59:57 <dsal> How were you using it?
22:01:39 <matt2> let x = "hello"
22:01:49 <matt2> let y = traceShow x
22:01:56 <matt2> sorry
22:01:57 <matt2> once again
22:02:00 <dsal> traceShow takes another argument.
22:02:06 <matt2> let x = "hello"
22:02:11 <dsal> % :t traceShowId
22:02:11 <yahb> dsal: Show a => a -> a
22:02:12 <matt2> y = traceShow x
22:02:14 <matt2> in ...
22:02:28 <matt2> yea and I am passing there "x"
22:02:49 <dsal> When?
22:03:01 <matt2> let x = "hello"y = traceShow x
22:03:03 <matt2> in ...
22:03:18 <dsal> % :t traceShow
22:03:18 <yahb> dsal: Show a => a -> b -> b
22:03:24 <dsal> matt2: ^
22:03:51 <dsal> % let x = trace "matt2 needs to supply all the arguments" 6 in   x + 4
22:03:52 <yahb> dsal: matt2 needs to supply all the arguments; 10
22:04:22 <dsal> % let x = "hello"; y = traceShowId "world" in  unwords [x, y
22:04:22 <yahb> dsal: ; <interactive>:14:59: error: parse error (possibly incorrect indentation or mismatched brackets)
22:04:28 <dsal> % let x = "hello"; y = traceShowId "world" in  unwords [x, y]
22:04:28 <yahb> dsal: "hello "world"; world"
22:04:53 <dsal> Or you use traceShowId liek that.
22:07:16 <matt2> hmmm
22:07:26 <matt2> I think my code just don't get to that point
22:07:30 <matt2> thank you for your help
22:07:43 <remexre> dsal: I got sidetracked, sorry; you mean I should have e.g. MonadLog m, with instances MonadLog IO, MonadLog (StateT [String] m) ? that breaks for failure caused by exceptions, no?
22:08:40 <dsal> % let x = "hello"; y = traceShowId "world" in  unwords [x]
22:08:41 <yahb> dsal: "hello"
22:08:49 <dsal> matt2: ^ see what I did there?
22:09:27 <dsal> remexre: It might be more complicated...  It sounds like you're wanting an effect to calculate the failure message.  I'm not sure if that's a built-in thing.  Seems somewhat doable.
22:12:15 <matt2> And do you know how can I remove all letters in Haskell? 
22:12:16 <matt2> Text.filter (not . (`elem` (",.?!-:;\"\' " :: String))) x
22:12:22 <matt2> I've done something like that for special chars
22:12:35 <matt2> but is there way to remove all letters like in regex /d
22:12:56 <matt2> like in regex /w *
22:16:15 <dsal> > filter (not.isAlpha) "Do you mean like this, matt2?"
22:16:17 <lambdabot>  "    , 2?"
22:20:39 <dsal> > partition (not.isAlpha) "Do you mean like this, matt2?"
22:20:42 <lambdabot>  ("    , 2?","Doyoumeanlikethismatt")
22:25:25 <matt2> filter is good, thank you dsal! You are the best
22:50:59 <slack1256> I got a doubt on fusion rules for list. Instead of rewriting list's introduction/destruction via rewrite rules, wouldn't be more predicatable to introduce a module with the Stream data type and only the functions that fuse correctly?
22:51:31 <slack1256> Or that package already exists?
22:55:04 <dsal> fusion is an optimization.  I'm not sure thinking about "correctly" in such a context.
22:58:42 <mniip> problem is, a "stream" is not a datatype
22:59:28 <mniip> list fusion turns something like "f x" where f is a list consumer and x is a list prooducer, into a pattern of interlinked control flow between f's and x's code
22:59:35 <mniip> in a way that avoids allocating cons cells
23:04:44 <wavemode> slack1256: that said, such packages which ensure fusion do exist. pipes is a popular one
23:06:19 <wavemode> conduit even more so
23:08:15 <slack1256> mniip: You are technically right, stream is an optimization. But there are functions on Data.List that break fusion as we don't know how to reliably express them on the work framework. So and alternative would be to just export the "fuseable" functions on a new module.
23:09:15 <slack1256> wavemode: Pipes, really? I only use it when my problem is coroutine like. I guess the relationship with ListT done right also had effects on their fusion rules.
23:11:18 <wavemode> well, the point is stream processing. you can use it for a lot of things.
