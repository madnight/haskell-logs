00:33:23 <s900000s> hello, I am thinking through a program architecture. I want the program to in one thread start a python process, and another thread to watch for intermediate outputs of the process and report when it is finished. Would I use a combination of asynic and subprocess to do this?
00:37:13 <s900000s> Alternatively, I think that I could use typed process AND async
00:49:06 <juri_> s900000s: you're in the wrong channel. ;)
01:01:47 <s900000s> oops
01:59:18 <kuribas> Which language would be most suited for proving floating point operations?
01:59:28 <kuribas> for example 2D graphics?
01:59:31 <kuribas> agda?
02:10:19 <kuribas> Aren't dependent types too tedious for proving properties?
02:10:41 <kuribas> It looks like refinement types + SMT solver is much less work.
02:10:57 <kuribas> As the SMT solver takes a lot of the work out of your hands.
02:11:05 <[exa]> kuribas: how complex the proving should be in "proving floating point operations"? Checking algebraic identities?
02:11:35 <kuribas> [exa]: verifying graphics routines
02:14:13 <kuribas> having a verified library with graphics operations over bezier curves and lines.
02:18:15 * hackage juicy-gcode 0.1.0.8 - SVG to G-Code converter  https://hackage.haskell.org/package/juicy-gcode-0.1.0.8 (dlacko)
02:28:19 <stand> hello
02:28:21 <stand> lsaldsadad
02:28:21 <stand> a
02:28:21 <stand> d
02:28:21 <stand> asd
02:28:24 <stand> a
02:28:26 <stand> sd
02:36:00 <kuribas> vi not working?
02:36:18 <kuribas> should use a decent editor, like emacs
02:38:15 <phadej> maybe stand accidentally entered ex mode
02:45:22 <juri_> kuribas: I've seen work along these lines in OCaml.
02:46:05 <juri_> in fact, as the maintainer of a haskell 3d modelling system, i need to reverse engineer said OCaml code. ;)
02:47:03 <kuribas> the effort may be to much compared to thorough testing
03:11:14 <juri_> I'm taking both approaches... by writing a consumer of the output of ImplicitCAD, and filing bugs against ImplicitCAD when i find bad output.
04:16:34 <ibloom> Someone implemented a library recently for vectors that could be appended and would automatically reallocate memory but I can't remember the name. Does anyone remember? (Vigorous discussion on reddit)
05:41:45 * hackage mmsyn4 0.4.0.0 - The "glue" between electronic tables and GraphViz  https://hackage.haskell.org/package/mmsyn4-0.4.0.0 (OleksandrZhabenko)
06:08:01 <epic_guy[m]> let f = 3
06:08:01 <epic_guy[m]> let g = 6 * f + h
06:08:01 <epic_guy[m]> why does this not return an error in repl??
06:08:10 <epic_guy[m]> like isnt h not defined?
06:08:46 <merijn> It should be an error unless you previously defined it or set some weird setting
06:09:18 <epic_guy[m]> no, i started a clean slate
06:09:23 <epic_guy[m]> new REPL
06:09:43 <epic_guy[m]> but g is out of scope!
06:09:48 <merijn> It's an error here
06:09:58 <tomjaguarpaw> So what does `:i h` say
06:10:07 <epic_guy[m]> No it does not say any error
06:10:13 <merijn> λ let f = 3
06:10:13 <merijn> λ let g = 6 * f + h
06:10:13 <merijn> <interactive>:2:17: error: Variable not in scope: h
06:12:11 <epic_guy[m]> hmm..I'm using ghc 8.6.5
06:12:21 <merijn> Same :p
06:12:39 <epic_guy[m]>   >let f = 3
06:12:39 <epic_guy[m]>   >let g = 6 * f + h
06:12:39 <epic_guy[m]> >
06:12:48 <merijn> How are you starting the repl?
06:12:52 <epic_guy[m]> umm Im using in the repl.it site
06:13:16 <merijn> See, that sounds like it may simply be a bug/error in how they display/show errors
06:13:37 <epic_guy[m]> oh ho
06:14:29 <merijn> epic_guy[m]: Since I get an error when I do that in my local ghci on two different OSes and with two different GHC versions ;)
06:15:04 <epic_guy[m]> okay, i think u are right...i tried it on a different site and it showed an error
06:16:22 <freeman42x[m]1> epic_guy: can you share the repl.it with us? curious
06:17:45 <epic_guy[m]> https://repl.it/@EPIC203/Learning-Haskell
06:18:29 <epic_guy[m]> i did not write in the source files, just the REPl
06:24:38 * epic_guy[m] uploaded an image: image.png (18KB) < https://matrix.org/_matrix/media/r0/download/matrix.org/xdddquaoFDTQxenqXEKwEMNH >
06:25:18 <epic_guy[m]> just showing, so that, I dont fall for this online repl ever again
06:57:05 <vaibhavsagar> silly question: is there a way to use template-haskell's runIO when my resulting data type doesn't have Lift instances (and they come from a different package so I can't derive them easily)
07:00:12 <merijn> vaibhavsagar: What does the Lift instance of a datatype have to do with runIO?
07:00:54 <vaibhavsagar> merijn: is there another way to use the result of a runIO?
07:00:59 <Cale> vaibhavsagar: sure... runIO is just liftIO, but for Q
07:01:23 <Cale> So, you can do whatever, get the result and turn it into syntax by hand yourself
07:01:27 <merijn> vaibhavsagar: One of us is confused about what you want and I'm not sure which :p
07:01:36 <vaibhavsagar> yeah, but then I can't use the resulting value elsewhere in my program without Lift
07:02:05 <Cale> Not directly, but you can bind it, presumably pattern match on it, and decide what syntax to emit
07:02:10 <vaibhavsagar> doingIOatCompileTime :: Q Exp
07:02:54 <untseac> silly question, how does haskell deal with the micro-services bandwagon? does it have something similar to apache kafka and friends?
07:03:47 <merijn> untseac: It'd probably help to explain what kafka and friends are/do? :p
07:05:33 <vaibhavsagar> concretely, I'm trying to compute HLint's settings at compile time instead of reading and parsing YAML when it starts up, which seems slow under GHCJS
07:05:36 <untseac> merijn, lol. kafka is a distributed streaming platform. Basically it solves the problem of managing communication in a cluster with a declarative language and streams. The different message timings and such are dealt by kafka.
07:06:29 <untseac> so haskell is already declarative, problem solved. how does it manage the communication between cluster nodes though? if there's a framework/lib for that.
07:06:35 <merijn> vaibhavsagar: And why do you not have a Lift instance of the result?
07:07:03 <untseac> kafka is very popular in the micro-services space
07:08:26 <vaibhavsagar> merijn: HLint's settings are of type `(ParseFlags, [Classify], Hint)` and I can't derive those instances automatically
07:08:35 <Cale> Personally I kind of view microservices as a reflection of some sort of political breakdown
07:08:44 <vaibhavsagar> without invasive changes to HLint
07:08:56 <Cale> moreso than as a real technique one would want to apply in building software :D
07:09:19 <Cale> But sometimes political breakdowns happen, I guess it's good to be prepared for them
07:10:15 <tomjaguarpaw> https://en.wikipedia.org/wiki/Conway%27s_law
07:10:39 <Cale> tomjaguarpaw: haha, yes, 100%
07:11:22 <Cale> Microservices are a reflection of the company where nobody wants to talk to anyone else, and as a result, they'll all end up in perpetual meetings with each other.
07:12:11 <untseac> Cale, you're not wrong but micro-services are trying to solve a real problem, the problem of efficiency of limited resources in distributed computing (aka money).
07:12:54 <tdammers> not exactly
07:13:06 <untseac> well that's what I understood out of it
07:13:17 <merijn> untseac: Doubt it
07:13:18 <tdammers> it's rather about exploiting the availability of practically unlimited resources
07:13:22 <untseac> because that way you can scale your micro-services the way you want
07:13:36 <merijn> untseac: Most distributed computing solutions are terribad at effectively using resources
07:13:51 <Cale> untseac: I just think it's much easier to take a more global approach to the development of distributed systems, where you don't really regard the code running on different nodes as separate programs.
07:14:05 <tdammers> the whole issue with microservices is that you can NOT scale them the way you want; you can scale them quite aggressively, but you have to adapt your problem to the ways in which they can scale
07:14:44 <untseac> that may be but better than replicating your entire application
07:14:50 <Cale> After all, the correctness of the system depends on correct interaction between those nodes, so developing them all separately means you need to define as many interfaces and constantly deal with bugs related to APIs changing.
07:15:03 <untseac> y
07:15:04 <untseac> true
07:15:10 <untseac> that's what kafka tries to solve
07:15:13 <untseac> poorly
07:15:20 <untseac> but better than REST and friends
07:15:51 <untseac> as for haskell no clue if there's a lib or framework for that
07:16:01 <untseac> maybe there's not even a need for that
07:16:06 <untseac> just curiosity
07:16:41 <Cale> There are a bunch of Haskell bindings for Kafka, apparently
07:16:56 <untseac> well when all you have is a hammer
07:17:06 <untseac> everything looks like a nail
07:18:05 <untseac> you know, the best solution perhaps would be automagic scaling
07:18:32 <untseac> and not this super manual thing with separate applications
07:18:43 <Cale> We haven't really built full-on distributed systems where I work, but we do build web applications, and at the very least have scaling via replication of the backend machines, which then all communicate via an external postgres server
07:19:22 <Cale> and that works pretty damn well until you're quite big
07:20:31 <untseac> yeah the problem with that (according to business guys) is that you don't always need the entire web app to duplicate resources. it would be better if parts of the app to have more resources, not the entire thing.
07:20:52 <merijn> Cale: 90% of all distributed microservice setups can be effectively and efficiently replaced by 1 or 2 beefy machines and postgres :p
07:21:00 <untseac> But I do agree with tdammers that micro-services (at least the current methods) are not really the ideal solution
07:21:54 <vaibhavsagar> I wonder what typed microservices would look like
07:22:02 <vaibhavsagar> i.e. communication between them is typed
07:22:10 <untseac> anyway seems like nobody knows an obvious solution in haskell here. I was hoping there was some kind of magical framework that did it differently than java libs.
07:22:16 <untseac> vaibhavsagar, it would be the ideal solution
07:22:21 <untseac> that's why I asked
07:22:39 <untseac> at least as far as micro-services go right now
07:22:47 <untseac> automic scaling would be better
07:22:51 <untseac> automagic*
07:22:57 <vaibhavsagar> Cloud Haskell looks like it gets some of the way there
07:23:35 <untseac> hum, okay sound good
07:23:55 <untseac> yeah that's what I was looking for vaibhavsagar 
07:24:14 <untseac> so it's the erlang way huh?
07:24:47 <vaibhavsagar> kind of, I think think we've figured out how to be better at Erlang than Erlang
07:24:59 <untseac> lol very true
07:26:27 <tdammers> also worth noting that there's a bit of a difference between just "services" and "microservices"
07:26:42 <tdammers> service-based architectures aren't a bad idea
07:28:09 <untseac> I think everyone is still figuring out what's for the best in distributing computing but I need that crapola to eat. Around here you either know the bandwagon or you're stuck with legacy.
07:28:37 <untseac> frankly I would rather avoid all that
07:30:28 <untseac> what annoys me the most is when think "man... spring sure sucks bad... super over-engineered" and nobody really gets what I'm saying :\
08:12:14 * hackage nix-derivation 1.1.1 - Parse and render *.drv files  https://hackage.haskell.org/package/nix-derivation-1.1.1 (GabrielGonzalez)
08:16:45 * hackage language-docker 8.1.1 - Dockerfile parser, pretty-printer and embedded DSL  https://hackage.haskell.org/package/language-docker-8.1.1 (lorenzo)
08:53:15 * hackage haskellish 0.2.2 - For parsing Haskell-ish languages  https://hackage.haskell.org/package/haskellish-0.2.2 (dktr0)
08:53:23 <maerwald> tdammers: there's an upside to the microservice madness... it causes companies, who have in fact no interest in that, to solve problems related to microservice architecture/operations (devops, debugging, logging, ...). So in case you *actually* need it at some point, the tooling is surprisingly good :P
09:01:15 * hackage hsx2hs 0.14.1.8 - HSX (Haskell Source with XML) allows literal XML syntax in Haskell source code.  https://hackage.haskell.org/package/hsx2hs-0.14.1.8 (JeremyShaw)
10:25:18 <Sathiana> Hi guys, I remember reading somewhere that one could run a .hs file in "script mode" under cabal, without first compiling. Is that posible ?
10:26:35 <ChaiTRex> Sathiana: I don't know about Cabal, but runghc does that.
10:26:47 <maerwald> sethetter: https://www.haskell.org/cabal/users-guide/nix-local-build.html#cabal-v2-run
10:27:00 <maerwald> Sathiana: ^
10:27:19 <maerwald> that is not without compiling though
10:27:27 <maerwald> it just doesn't require a full project setup
10:27:40 <maerwald> it creates a temporary fake-package
10:31:40 <merijn> Sathiana: What's the reason for wanting that? (might be better alternatives, depending on why)
10:32:02 <maerwald> stack does this better, in fact :P
10:32:12 <maerwald> it just runs such scripts faster
10:32:13 <Sathiana> ChaiTRex: yes that was it! 
10:33:32 <Sathiana> merijn: was just curious, thought it was an option in Cabal and was wondering why I wasnt finding  
10:34:18 <merijn> Sathiana: Ah. For development you can also create a tiny shell script invoking v2-run, which works quite well for dog-fooding executables you're working on
10:35:04 <maerwald> merijn: v2-run leaks memory. I always use v2-exec to find the binaries and then invoke them directly
10:36:57 <Sathiana> merijn: Going through Get Programming in H.. both Ghci/runghc will do for now
10:37:03 <merijn> maerwald: Leaks memory how?
10:37:23 <maerwald> merijn: I do not know. All I know is that I extensively tested this with ghcup.
10:39:35 <maerwald> Maybe there's something odd going on with stdout in cabal and it re-buffers and doesn't clear it? But even that wouldn't explain several hundred megs of difference
10:43:06 <frdg> I'm getting an error that cabal is missing dependencies when I run `cabal repl`. The dependency that is missing is `checkers`. I ran cabal update succesfully. I have `checkers` in my build depends, formatted properly. I also have `containers` in my build depends which cabal is not complaining about.
10:43:58 <maerwald> better show the project
10:44:12 <merijn> frdg: Which version of cabal-install?
10:44:42 <frdg> version 2.4.0.1
10:44:43 <merijn> I'm going out on a limb and betting 2.4 or earlier ;)
10:45:06 <merijn> frdg: Right, in 2.4 "build" is still the old build style which does *not* automatically install dependencies
10:45:16 <merijn> frdg: Try "cabal v2-build"
10:45:26 <frdg> ok one moment
10:45:32 <merijn> Which uses the new build style that's default in 3.0 and later
10:45:42 <merijn> (and does automatically install any necessary dependencies)
10:49:17 <frdg> the `cabal v2-build` command ran perfect and I even saw checkers in the list but I am getting the exact same error. I ran `cabal update` again but no luck.
10:49:47 <solonarv> you do have to also run 'cabal v2-repl' instead of 'cabal v2-build'
10:50:10 <solonarv> er, instead of 'cabal repl'
10:51:14 <frdg> It worked!
10:51:19 <frdg> Thanks guys
10:51:52 <merijn> frdg: You probably want to always use the v2- commands (or switch to cabal 3.0+ which has those as default)
10:52:18 <frdg> ok good to know
11:14:15 * hackage clckwrks 0.26.0 - A secure, reliable content management system (CMS) and blogging platform  https://hackage.haskell.org/package/clckwrks-0.26.0 (JeremyShaw)
11:14:35 <frdg> I just installed cabal 3.2. I used the command `cabal install Cabal cabal-install`. I am still unable to run `cabal repl` without it complaining about checkers. At the end of the install i was given this message: https://pastebin.com/Tqdhz0P9 . When I run `cabal --version` I still says 2.4.0.1
11:14:59 <Rembane> frdg: What does the command: which -a cabal give you? 
11:15:04 <merijn> frdg: cabal installs into ~/.cabal/bin, so possibly that directory is not on your path?
11:15:52 <solonarv> merijn: look at the error message
11:16:50 <frdg> Rembane: /usr/bin/cabal   `newline`     /usr/bin/cabal
11:17:13 <maerwald> cabal install --install-method=copy --overwrite-policy=always cabal-install
11:17:16 <frdg> oops. Second line is `/bin/cabal`
11:17:31 <merijn> solonarv: pfft, reading is hard
11:17:50 <frdg> ok maerwald im gonna send it
11:18:16 <Rembane> frdg: Got it, add ~/.cabal/bin/ to $PATH in .bashrc.
11:18:51 <frdg> Maerwald: didnt work.
11:18:58 <frdg> Rembane: ok ill try that
11:19:08 <maerwald> it did work :)
11:19:15 * hackage rounded 0.3 - Correctly-rounded arbitrary-precision floating-point arithmetic  https://hackage.haskell.org/package/rounded-0.3 (ClaudeHeilandAllen)
11:20:15 * hackage rounded 1.1 - Correctly-rounded arbitrary-precision floating-point arithmetic  https://hackage.haskell.org/package/rounded-1.1 (ClaudeHeilandAllen)
11:22:18 <frdg> Rembane: I'm not able to find `$PATH` in my `.bashrc`
11:24:50 <maerwald> frdg: https://www.baeldung.com/linux/path-variable
11:25:13 <frdg> thanks
11:29:46 * hackage xrefcheck 0.1.1.2 -   https://hackage.haskell.org/package/xrefcheck-0.1.1.2 (gromak)
11:35:05 <WinchellsM> How to go from `[Just 1, Nothing, Just 2]` to `[1, 2]` ?
11:35:19 <xerox_> :t catMaybes
11:35:20 <lambdabot> [Maybe a] -> [a]
11:35:35 <WinchellsM> Thanks :]
11:35:43 <xerox_> :t \xs -> [ x | Just x <- xs ]
11:35:44 <lambdabot> [Maybe a] -> [a]
11:50:46 * hackage aeson-deriving 0.1.0.0 - data types for compositional, type-directed serialization  https://hackage.haskell.org/package/aeson-deriving-0.1.0.0 (Cliff_Harvey)
11:51:07 <frdg> Ok...so I believe that I have successfully created my new path as now when I run `cabal --version` from my home directory, it says 3.2. Unfortunately though I am still unable to run `cabal repl`, from my existing project. My project was created with `stack new project simple`. I tried creating a new project with the same command and it still does
11:51:07 <frdg> not work and still says I have cabal version 2.4.0.1
11:56:07 <frdg> ohh I ran cabal install from my project directory and it worked! Thanks everyone for the help and patience
12:05:45 * hackage postgrest 7.0.1 - REST API for any Postgres database  https://hackage.haskell.org/package/postgrest-7.0.1 (steve_chavez)
12:22:38 <dsal> WinchellsM: How did you get the [Maybe a]?  You might also be able to avoid that in the first place.
12:36:00 <typetetris> There is simple Sum Type in a library I would like to have an FromJSON ToJSON instance for. Do I need to use an orphan instance or is there some other way?
12:37:35 <koz_> typetetris: Newtype wrap.
12:40:43 <timCF> Hi guys! In Haskell, is it possible to define somehow type class restriction where type should *not* implement class, something like `not Bounded a => ...` which means type `a` not implements `Bounded` type class
12:40:49 <timCF> ?
12:42:12 <EvanR> ah avoiding orphans by using a dumb newtype wrapper... interesting
12:46:37 <dmwit> timCF: no
12:47:59 <dmwit> typetetris: You can also just define an aeson parser/pretty-printer for the type without naming them fromJSON/toJSON.
12:52:13 <solonarv> timCF: when GHC searches for a typeclass instance, there are three possible outcomes:
12:52:23 <typetetris> dmwit: It is used in another type I want to derive `FromJSON` and `ToJSON` for. Does that still work?
12:52:24 <solonarv> 1) success! instance found, everything works
12:52:47 <Cale> timCF: Part of the design is that you never know for certain that there won't be an instance later, so if you were to decide anything on the non-existence of an instance, your decision might be rendered incorrect by future code.
12:52:52 <solonarv> 2) no instance found, but there might be one somewhere else
12:53:09 <solonarv> and finally 3) instance found, but the instance's constraints couldn't be satisfied
12:54:13 <solonarv> so, I smell an XY problem. what is you actually want to do?
12:54:34 <dmwit> typetetris: I don't see why not.
12:54:45 <dmwit> typetetris: Oh, sorry, missed the "derive" there. Then no.
12:59:17 <Cale> timCF: Perhaps an Unbounded type class which constructively showed a type was unbounded would be more useful anyway?
13:01:52 <Cale> Something like  class Ord a => Unbounded a where above :: a -> a; below :: a -> a -- laws: for all x, x < above x and below x < x
13:03:52 <Cale> (perhaps that ought to be two classes, one for above and one for below)
13:04:05 <Cale> (but then, so perhaps should be Bounded)
13:30:45 * hackage mmsyn7l 0.5.0.0 - Modifies the amplitudes of the Ukrainian sounds representations created by mmsyn7ukr package.  https://hackage.haskell.org/package/mmsyn7l-0.5.0.0 (OleksandrZhabenko)
13:31:20 <maerwald> This guy is really dedicated to ukrainian sounds
13:42:44 * hackage dobutokO2 0.40.0.0 - Helps to create experimental music from a file (or its part) and a Ukrainian text.  https://hackage.haskell.org/package/dobutokO2-0.40.0.0 (OleksandrZhabenko)
13:44:45 * hackage morley 1.3.0 - Developer tools for the Michelson Language  https://hackage.haskell.org/package/morley-1.3.0 (gromak)
13:45:45 * hackage lorentz 0.3.0 - EDSL for the Michelson Language  https://hackage.haskell.org/package/lorentz-0.3.0 (gromak)
13:54:15 * hackage tomland 1.3.0.0 - Bidirectional TOML serialization  https://hackage.haskell.org/package/tomland-1.3.0.0 (vrom911)
13:55:02 <koz_> Is there some map-like structure that's keyed by _types_? So basically, to do a lookup, you hand it a Proxy and it gives you back a Maybe if there's a mapping to the type being Proxied.
13:55:09 <koz_> (or uses TypeApplications, whichever)
13:56:08 <merijn> koz_: That sounds like it's be simple enough to implement with liberal use of Typeable?
13:56:25 <xerox_> https://hackage.haskell.org/package/type-map
13:56:35 <koz_> merijn: So like, key by typeRep or something?
13:56:38 <merijn> koz_: Use TypeRep as index into a map storing Dynamic values and use cast upon lookup?
13:56:44 <merijn> koz_: Along those lines, yeah
13:57:02 <koz_> xerox_: Thanks, will check that out too.
13:57:17 <merijn> Also, questionable thing to want, to proceed at your own risk :p
13:57:27 <koz_> merijn: It _is_ questionable, but I'm kinda forced into it.
13:57:39 <koz_> (I have _deeply_ considered alternatives as I best understand them)
13:57:47 <koz_> (perhaps doing this might convince me otherwise)
13:57:51 <koz_> (or help me see a better way)
13:57:54 <koz_> (usually what happens)
13:58:07 <xerox_> I guess another way is having a class with an associated type?
13:58:35 <merijn> Assoicated types are just syntactic sugar for type families
13:58:52 <merijn> The class is entirely unnecessary if you only care about the type
13:59:08 <xerox_> ah I'm unfamiliar, never used those yet
13:59:35 <merijn> xerox_: Type families are, effectively, type level functions. Mapping input types to output types
13:59:51 <merijn> I have some gist (ab)using them
14:00:23 <merijn> Using them to implement a "not equal" constraint on polymorphic types: https://gist.github.com/merijn/6130082
14:01:04 <merijn> Or using them to handle applying functions to heterogenous lists: https://gist.github.com/merijn/dc00bc7cebd6df012c5e
14:01:34 <nshepperd> koz_: dependent-map can do this too. 'DMap TypeRep Identity' gives you a map from 'type' to 'a value of that type'
14:01:45 <merijn> There the Fun type family takes a type level list of types as input and maps it to a function type of the correct arguments
14:02:02 <koz_> nshepperd: Interesting, will check that out too.
14:03:12 <nshepperd> koz_: Identity can be replaced with any one-parameter datatype to customize the storage, so it's nice and flexible
14:03:44 <koz_> nshepperd: Will _definitely_ check it out then.
14:14:59 <ddellacosta> so, I'm trying to show some nonbelievers the value of Maybe vs. null/nil. One thing I'm trying to do is show them how nice it is to work with, and so I'm wondering if folks have any suggestions on links or the like? So far I've found this: https://www.parsonsmatt.org/2016/11/18/clean_alternatives_with_maybet.html
14:16:24 <wavemode> well, null values are generally not checked by the compiler and can blow up at runtime
14:17:38 <ddellacosta> wavemode: I'm looking more for ways to show them how useful Maybe in particularly is, as they are convinced it leads to a ton of boilerplate
14:18:06 <ddellacosta> I mean, I recognize the fundamental value you're highlighting, don't get me wrong
14:18:26 <dolio> Writing null tests on all your functions so they don't blow up is boilerplate.
14:19:33 <ddellacosta> dolio: yep, absolutely agree
14:19:53 <ddellacosta> I'm trying to show folks how Maybe helps you avoid that, because they aren't seeing it
14:21:50 <maerwald> If you chain Maybe a lot, you'll forget what caused the Nothing :)
14:21:58 <TMA> the nice thing is you cannot just treat a Maybe a as an a without the compiler yelling at you
14:22:15 <ddellacosta> maerwald: lol
14:22:55 <maerwald> ddellacosta: wasn't joking
14:23:04 <dolio> I don't think talking about `MaybeT` is likely to be the right approach.
14:23:24 <ddellacosta> yeah I guess it's more that, they think every time you use Maybe you have to work with it via pattern matching or if/case/etc. and don't see how having these things be Functor, Applicative, etc. adds to the picture
14:23:31 <ddellacosta> maerwald: I didn't think you were!
14:23:43 <ddellacosta> dolio: I won't talk about MaybeT, but there's a lot in that piece before that bit
14:24:11 <dolio> I think, probably, your friends don't understand that most of their code is broken (as a guess). Like, maybe they don't test for null everywhere, and don't experience that boilerplate.
14:24:14 <ddellacosta> anyways, I have some other lens tricks that I think will impress them, was just curious what folks thought
14:24:35 <dsal> @pl . undo  do { b <- bar a; pure (show b) }
14:24:35 <lambdabot> (line 1, column 1):
14:24:35 <lambdabot> unexpected "."
14:24:35 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
14:24:39 <maerwald> ddellacosta: I don't mind languages with nil. I just think of everything as an implicit maybe. However, it gets weird when the language in addition as Maybe (like Java).
14:24:39 <wavemode> if they just don't care about safety, fromJust exists
14:24:45 <dsal> @. pl undo  do { b <- bar a; pure (show b) }
14:24:45 <lambdabot> pure . show =<< bar a
14:24:51 <dolio> However, if they're not testing for null, then that means the code only works when the value is not null, so a language with explicit Maybe is the right type for those functions.
14:25:00 <dolio> And you do not even have to talk about Maybe in most places.
14:25:07 <maerwald> So you have a Maybe, and inside might be a value, or nil...
14:25:17 <ddellacosta> maerwald: that's an interesting perspective for a Haskeller! I've found it frustrating to work with personally
14:25:24 <dsal> I'd'e gone with `show <$> bar a`
14:25:27 <ddellacosta> but some folks insist it works for them
14:25:49 <dolio> The advantage of Maybe is not that you can abstract null-checking boilerplate, it is that you can handle the null immediately and write most code with provably no nulls.
14:25:51 <maerwald> ddellacosta: and Java has Optional/Maybe type for streaming purposes afaik. The problem now is, you still have to deal with nil. It is counter-intuitive and error prone
14:26:03 <maerwald> So my point is: you can't implement a meaningful Maybe, when the language has nil.
14:26:38 <ddellacosta> dolio: I'm not arguing that isn't the primary value, I'm trying to assert that it's not extra laborious as well. But maybe you don't agree
14:26:56 <ddellacosta> although I do think there are advantages above and beyond simply exposing possible nulls at compile-time
14:27:14 <ddellacosta> maerwald: that makes sense
14:27:17 <wavemode> the Maybe monad does allow chaining computations without repetitive pattern matching, but most code examples of that sort are rather contrived... and you still have to check the result *somewhere*
14:28:18 <dolio> ddellacosta: I just almost never need MaybeT. In situations where something needs a 'null' result, I just almost never want to postpone checking it.
14:28:22 <dsal> I don't think I've ever used MaybeT.  I used EitherT once.
14:28:33 <ddellacosta> wavemode: I don't think you're wrong, and maerwald made a similar point above, but I think there are counter-examples
14:28:40 <dsal> I use the regular Maybe monad sometimes.
14:29:14 <ddellacosta> dolio, dsal sorry let me be clear I'm not that interested in the MaybeT bits of that piece but I think there are compelling examples before that which are much more widely applicable
14:30:07 <ddellacosta> I think the MaybeT bits are somewhat contrived (although the way he uses Alternative is nice)
14:30:09 <maerwald> ddellacosta: also, a nil value isn't lazy
14:31:03 <maerwald> IMO, the advantages are not so much about "it doesn't crash", they are elsewhere. We have plenty of stuff that crashes
14:31:08 <dolio> Okay. I guess I just don't understand your friends, then. :)
14:31:18 <ddellacosta> dolio: fair enough haha. Sorry to be cryptic
14:31:19 <dsal> I do this kind of thing sometimes as well:
14:31:20 <dsal> % let m = Just "Hello" in   traverse_ putStrLn m
14:31:20 <yahb> dsal: Hello
14:31:34 <dolio> I don't understand thinking like, 'most functions might want null arguments/results.' That is just false in my experience.
14:31:39 <ddellacosta> maerwald: yeah, I agree with that 
14:32:57 <dolio> So, it's way more boilerplate to handle everything being possibly null than to have the few things necessary explicitly null.
14:33:05 <ddellacosta> dolio: I think the gap is that especially for folks who have only used a dynamically typed language it can seem like there is inevitably going to be far more boilerplate by introducing an abstraction like Maybe, because it would probably be that way in a dynamically-typed language
14:33:09 <koz_> dolio: This is definitely the kind of thinking Java warps your brain into, because in Java, basically anything user-defined can be null, and people seem to think this is normal.
14:33:40 <ddellacosta> so that's what I'm trying to argue against, show counter-examples against
14:33:52 <maerwald> in good nil languages... you don't care much about whether it's nil, because it doesn't really crash (clojurescript, lol)
14:34:03 <maerwald> (this was an extreme sarcastic joke)
14:34:17 <ddellacosta> yeah no comment lol
14:34:22 <dsal> go almost got that right -- calling methods on nil values is fine, except they have half-nil interfaces.
14:35:35 <dolio> Dynamic typing is kind of a species of the same problem. It's less boilerplate to only have to write functions on values that make sense than to guard against all the values that don't everywhere.
14:36:10 <dsal> The way to sell something like Maybe is to point to a production outage with NPEs flying all over the place and say, "That code wouldn't compile in Haskell."
14:36:15 * hackage clckwrks-cli 0.3.0.3 - a command-line interface for adminstrating some aspects of clckwrks  https://hackage.haskell.org/package/clckwrks-cli-0.3.0.3 (JeremyShaw)
14:36:28 <maerwald> in your django app, you also don't care about nil, you just get back a 500 :)
14:36:46 <koz_> It's also much more explicit to say 'hey, this could be missing' than have the default be 'anything can be missing rofl'.
14:37:05 <koz_> Implicit stuff flying around everywhere is great for correctness, as we know. :P
14:37:17 <maerwald> koz_: in practice, it isn't such a big problem at first. Only when you start refactoring.
14:37:27 <dolio> I think practically no one really guards all their dynamically typed code against unexpected values, though. It probably mostly crashes.
14:37:31 <maerwald> Because in such languages you program way more interactive anyway
14:37:44 <dolio> And there is an implicit type discipline expected.
14:37:46 <koz_> maerwald: Speaking as someone who taught people in recent memory - no, it starts immediately because nobody considers edge cases ever.
14:37:52 <koz_> Or tests ever.
14:38:04 <wavemode> most dynamically-typed code is held together by the two-ply duct-tape of testing and documentation
14:38:04 <Cheery> oh that's something you don't notice
14:38:12 <ddellacosta> dolio: hell no. It's gambling, and then you add null checks when shit breaks in tests, and then again when it breaks in production
14:38:14 <Cheery> so it doesn't hurt, until.. well. :D
14:38:22 * nil isn't lazy
14:38:22 <koz_> wavemode: Displaying a lot of optimism in both, clearly.
14:38:27 <maerwald> koz_: I think about edge cases a lot :)
14:38:47 <maerwald> and I can handle python ok... but only as long as I don't have to refactor anything
14:39:02 <ddellacosta> yeah refactoring is where it gets you for real
14:39:03 <koz_> My experience, both personally and professionally, the common approach people have is 'lol, tests are not needed' and 'lol, documentation too hard'.
14:39:04 <maerwald> then the intellectual complexity of figuring out edge cases explodes
14:39:18 <koz_> I practically want to punch bears every time I encounter this, and it's usually _multiple times a day_.
14:39:33 <koz_> s/My/In my/
14:39:34 <ddellacosta> lol sorry I think I pissed everyone off haha
14:39:51 <maerwald> you gained 2 points for the dark side
14:40:14 * ddellacosta breathes heavily through his ventilator
14:40:14 <maerwald> nil: sorry about that
14:40:37 <dolio> ddellacosta: Anyhow, that seems like a more fundamental problem. If you're in the mindset of just not checking that anything will actually work, it's more work to have a check that makes sure it works. However, it's generally mistaken to think it's a lot more work.
14:41:23 <maerwald> koz_: I think this applies to junior devs. All the senior python devs I know are extremely disciplined people, because you cannot survive otherwise
14:41:25 <ddellacosta> dolio: yeah, I'm trying to tread the line I guess. Show both it's value simultaneously while showing how it's really not terrible to work with, and has some advantages in some cases
14:41:38 <ddellacosta> *its value, damn English
14:41:42 <maerwald> koz_: when it comes to haskell, I am not surrr :)
14:41:47 <nil> maerwald: don't be
14:41:49 <koz_> maerwald: I can only speak from my own experience.
14:42:04 <ddellacosta> maerwald: yeah noticed that in other language communities as well
14:42:06 <maerwald> in haskell, I sometimes think junior devs have more discipline =)
14:42:26 <maerwald> because they mistrust their intuition more, maybe
14:42:34 <wavemode> a Java developer will think "this function should do A, unless you pass in this optional parameter, in which case it does B instead." A functional programmer thinks instead "I'll just create two separate functions. They don't cost money, after all."
14:44:21 <maerwald> the problem is, when the abstractions are too thick, you need intuition at some point, because reasoning becomes too costly
14:47:05 <nshepperd> i would rather think of implicit nil as bottom ⊥ but people ruin that by intentionally using nil to carry information instead of using Maybe for that 
14:48:20 <nil> iirc in some lisps you can't test whether a list contains nil because a "nil" response could either mean "i haven't found anything" or "i have found a nil"
14:49:11 <nshepperd> heh
14:49:14 <wavemode> in common lisp there is no type "nil". nil is just the empty list, () ^_^
14:50:44 <koz_> Type punning is so helpful.
14:51:01 <koz_> nil: Common Lisp is what you're thinking of.
14:51:09 <koz_> Scheme distinguishes () from false IIRC.
14:53:03 <maerwald> that reminds me of figuring out whether a value in mongodb "exists". It could be nil, [] or something like [[], nil]
14:53:40 <koz_> maerwald: Sounds like PHP levels of design.
14:53:44 <nil> that looks like some weird set-theoretical encoding
14:54:04 <maerwald> koz_: what if I told you someone runs this code in their online webshop :)
14:54:10 <koz_> nil: No set theory I am aware of conflates 'emptyset' with '{emptyset}'.
14:54:18 <koz_> maerwald: Probably more than a single someone.
14:54:44 * ski . o O ( "Option types, optional parameters" by Riastradh in 2006-02-03 at <https://mumble.net/~campbell/blag.txt>,(RSS) <http://vrici.lojban.org/~cowan/blag.xml> )
14:56:08 <maerwald> koz_: my first experience with angular, nodejs, async callbacks and a fully-fledged mongodb. No wonder I ended up with haskell.
14:56:19 <maerwald> It was a lesson
14:56:20 <koz_> maerwald: I am so, _so_ sorry.
14:57:35 <Cheery> nshepperd: bottom would be a value that crashes if you access it or end up producing it.
14:57:52 <Cheery> including, trying to identify it
14:58:08 <Cheery> nil is identifiable though.
14:59:57 <Cheery> I think that you also kind of mix up things. a value in abstract machine is a bit different from the type.
15:01:08 <Cheery> 1 + a doesn't necessarily mean values from set: {nil, just X}
15:01:17 <heatsink> lua is weird about values too because it pretends that 'nil' is the absence of a value
15:01:45 <heatsink> To delete a dict entry, you assign nil to it
15:02:37 <Cheery> if you got 1 + (x*y*z) and they're all finite types, it'd make sense to encode it as one large record, rather than break it into tons of little structure.
15:02:59 <maerwald> heatsink: maybe that follows from it being a C glue language?
15:03:28 <Cheery> well that depends on usage pattern too, but basically there's space to move and that's an important thing to notice.
15:03:30 <heatsink> My impression is that it came out of their sense of minimalism
15:04:05 <Cheery> abstract machine with types is still an abstract machine. :)
15:04:35 <heatsink> Lua does not have distinct list, array, or object types.  Instead, dict transparently behaves like an array if you populate keys in a certain way
15:04:53 <heatsink> Its use of nil feels like the same thing
15:05:07 <heatsink> We don't need to invent more things, we can just overload nil to do it!
15:05:15 <nshepperd> Cheery: you can catch undefined in haskell, but it's deliberately difficult and error prone to do so. the problem is it's easy in, say, java ('== null') so people end up using it to carry nonerror information
15:05:41 <Cheery> nshepperd: how to catch partial functions in haskell?
15:05:55 <koz_> heatsink: Yeah, Lua is basically an exercise in creative overloading.
15:06:00 <koz_> One data structure for everything.
15:06:08 <koz_> Want something else? Write C.
15:06:27 <koz_> (I'm only slightly exaggerating)
15:06:42 <maerwald> Cheery: I think it is just ErrorCall?
15:06:56 <maerwald> (the exception type)
15:07:37 <nshepperd> Cheery: import Control.Exception, then rethink your life because it's a terrible idea :p
15:08:28 <nshepperd> 'instance Exception Void' interesting
15:09:27 <maerwald> > handle (\(e :: ErrorCall) -> pure []) (error "foo") :: IO [Int]
15:09:30 <lambdabot>  <IO [Int]>
15:10:15 <Cheery> well that looks nice.
15:11:25 <Cheery> of course 'undefined' should be treated as "unused" or "unreachable", basically.
15:14:17 <Cheery> but makes you wonder how much better javascript would be if it actually did not let you identify undefined.
15:15:11 <Cheery> every time you look into JS, they got some new thing that's extension of "not thinking through" the original semantics.
15:16:05 <Cheery> https://developer.mozilla.org/en-US/docs/Glossary/Symbol
15:16:17 <dolio> It wouldn't be better, really.
15:17:14 <dolio> The problem with undefined is you get it from accessing something that isn't there, but it contains no information about where the problem is.
15:17:39 <dolio> So unless you fix that, it's just as bad.
15:18:17 <maerwald> undefined is just: error ""
15:18:19 <maerwald> :P
15:18:30 <maerwald> so the information is there, it's just empty!
15:18:34 <maerwald> (not nil)
15:20:16 <dolio> It's not like `error ""`, because that actually tells you the source location now. It's like 'head of empty list', which tells you somewhere in your program you had an unexpected empty list.
15:20:54 <maerwald> dolio: yes, you get the source location
15:20:59 <dolio> undefined at least tells you where you 'forced' the error, but that isn't great.
15:25:19 <carlos56> I am learning Hashkell, is there anyone here who speaks Spanish?
15:26:01 <hpc> #haskell.es 
15:26:09 <Cheery> bt. did somebody figure how to write haskell programs that translate to JS neatly yet?
15:26:23 <hpc> not sure how populated it is, but it's on https://wiki.haskell.org/IRC_channel#Language.2FCountry_specific
15:27:02 <koz_> Cheery: Does PureScript count?
15:27:23 <carlos56> thanks hpc
15:31:12 <Cheery> koz_: it depends, how does it relate to haskell?
15:31:27 <Cheery> https://github.com/purescript/documentation/blob/master/language/Differences-from-Haskell.md
15:31:47 <Cheery> strict eval.. that's ok.
15:34:00 <Cheery> well I guess it's doable with that thing.
15:37:15 * hackage with-utf8 1.0.2.1 - Get your IO right on the first try  https://hackage.haskell.org/package/with-utf8-1.0.2.1 (kirelagin)
15:41:52 <koz_> Cheery: If you want 'Haskell that targets JS', PureScript seems like a pretty good choice.
15:42:08 <koz_> It's not _exactly_ the same, but it's similar enough.
15:56:59 <Axman6> Cheery: ghcjs also exists
16:01:12 <jmegaffin> Hi!  Can anyone explain or point me to an explanation of why (++) implemented with just build and foldr (no augment) is unable to guarantee fusion of its second argument?  To me, it seems obvious that build f ++ build g should be rewritten to build (\c n -> f c (g c n)).
16:23:04 <dolio> jmegaffin: l ++ r = foldr (:) r (build f) = f (:) r = f (:) (build g)
16:23:05 <dolio> Now what?
16:28:48 <dolio> Actually, that's probably not a complete argument.
16:29:08 <dolio> Here's another problem. Suppose you write:
16:29:40 <dolio> l ++ r = build (\c n -> foldr c (foldr c n r) l)
16:30:23 <dolio> Now `++` rebuilds its right hand side unless you detect that it shouldn't.
16:32:45 * hackage web-rep 0.4.0 - representations of a web page  https://hackage.haskell.org/package/web-rep-0.4.0 (tonyday567)
16:38:15 * hackage clckwrks-plugin-page 0.4.3.21 - support for CMS/Blogging in clckwrks  https://hackage.haskell.org/package/clckwrks-plugin-page-0.4.3.21 (JeremyShaw)
16:40:10 <jmegaffin> dolio: Okay, so the problem is that foldr c n r is evaluated to foldr (:) [] r before r is evaluated to build g?
16:41:23 <dolio> No, that was a mistake. That's how it works if you don't define it with build. However, when you do define it with build, you necessarily rebuild the right hand side, and then have to undo that somehow.
16:43:05 <dolio> What you end up in that case is: build (\c n -> f c (foldr c n r))
16:45:01 <dolio> Er, `build (\c n -> f c (g c n))`.
16:47:44 <dolio> Sorry. I'm confusing myself. If they're both `build`, then you get `f c (g c n)` which is good.
16:48:01 <dolio> But if the RHS is _not_ a build, then you don't want to rebuild it.
16:49:35 <jmegaffin> Okay, yes, I see now.  [1, 2, 3] ++ build g performs as expected, but build f ++ [1, 2, 3] is suboptimal.
16:49:44 <dolio> So then you'd need `build` to inline and then look for `foldr (:) [] r` to turn into `r`. I'm not sure why that wouldn't work exactly, but maybe there's some problem.
16:52:19 <pirulito> Hi!
16:52:44 <jmegaffin> I think there was a bit of a chicken-and-egg problem in my head.  GHC docs say (++) is only a good consumer in its first argument, but that's because it's implemented with augment in order to avoid the issues when its second argument is not a build.
16:52:45 <pirulito> Hi!
16:53:08 <dolio> Also, there are rules for rewriting `augment` back into `++` in case it doesn't fuse, but it's probably hard to do that if you only have `build`.
16:53:10 <jmegaffin> If it's implemented with build, then it is a good consumer in both arguments.
16:54:03 <dolio> So, it's not just about fusing things that can be fused, you want to use better code for cases that can't be fused. And you're matching symbolically on function names.
16:55:33 <jmegaffin> Thanks, this has been very illuminating!
16:57:02 <jmegaffin> I imagine `foldr (:) [] r` isn't rewritten into `r` because they don't have the same semantics.
16:57:18 <pirulito> Hi!
17:02:29 <pirulito> Hi!
17:02:45 * hackage zeolite-lang 0.7.0.0 - Zeolite is a statically-typed, general-purpose programming language.  https://hackage.haskell.org/package/zeolite-lang-0.7.0.0 (ta0kira)
17:05:34 <piasdsdsad> Hi!
17:05:38 <piasdsdsad> Hi!
17:06:51 <MarcelineVQ> I miss piasdsdsad
17:07:11 <Axman6> uch a great conversationalist
17:07:15 <Axman6> such*
17:09:04 <MarcelineVQ> eck, a great conversationalist
17:10:16 * hackage chart-svg 0.0.2 - See readme.md  https://hackage.haskell.org/package/chart-svg-0.0.2 (tonyday567)
17:16:38 <dmj`> digested so many functors today
17:16:47 <dmj`> functor indigestion
17:26:13 <Axman6> woiuld you like an Elixir to help with that?
17:26:27 <Axman6> MAybe something without functors, like vitamin C?
17:27:20 <Axman6> Or a hot cup of Java?
17:28:28 <piasdsdsad> Hi!
17:28:37 <Axman6> Hello!
17:29:02 <Axman6> MarcelineVQmissed your delightful banter piasdsdsad
17:30:32 <piasasdd> Hi!
17:30:35 <piasasdd> Hi!
17:30:51 <Axman6> Who hello
17:30:55 <Axman6> why even
17:32:13 <MarcelineVQ> My heart can't take this
17:33:27 <Axman6> @where ops
17:33:28 <lambdabot> byorgey Cale conal copumpkin dcoutts dibblego dolio edwardk geekosaur glguy jmcarthur johnw mniip monochrom quicksilver shachaf shapr ski
17:33:55 <MarcelineVQ> your trigger finger slipped
17:34:03 <dibblego> gone
17:34:16 <Axman6> They'll be back
17:34:30 * Axman6 sets a ban on pia*
17:35:12 --- mode: ChanServ set +o glguy
17:35:12 --- mode: glguy set +q-o *!*@89.153.92.135 glguy
17:35:19 <Axman6> <3
17:36:59 <aviD> is the cabal field other-modules ever meaning full outside of exe sections
17:37:41 <aviD> and I suppose bench sections
17:38:59 <dmj`> aviD: suppose you don't want to export everything from library, you still need to list in other-modules or you'll hear about it from the linker
17:40:21 <aviD> Can the other-module ever be outside of the sections hs-source-dirs
17:40:38 <aviD> The docs have a todo for other-modules
17:50:04 <aviD> Also what is the deal with Paths_$PKG_NAME?
17:55:03 <monochrom> What deal? Works for me.
17:56:05 <aviD> What does it do?
17:56:41 <monochrom> paths derived from --prefix
17:56:55 <aviD> Ah
18:04:54 <dmj`> aviD: you can have multiple hs-source-dirs
18:05:11 <dmj`> aviD: be explicit about your modules, other and exposed
18:05:22 <dmj`> aviD: and you shall be rewarded
18:06:16 <aviD> I'm not not writing a cabal file I'm generating the correct hie.yaml for arbitrary cabal files
19:09:02 <molossus_spondee> Is there a name for the opposite of a closure? I need a construct sort of like that for thunks in an interpreter I'm writing
19:10:14 <molossus_spondee> When you apply a thunk of function type to arguments you need to capture those args and then later apply the arguments to the thunk
19:20:58 <suzu_> that's a closure i think
19:21:28 <topos> 3 more of them and they'd have a foreclosure
19:21:35 <topos> I'll show myself out
19:24:44 <koz_> topos: Ba-doom-psh.
19:30:45 * hackage implicit-hie 0.1.0.0 - Auto generate hie-bios cradles & hie.yaml  https://hackage.haskell.org/package/implicit-hie-0.1.0.0 (Avi_Dessauer)
19:36:24 <sheepfleece> Is there a general lookahead function in attoparsec to which I can pass any other parser? 
19:37:00 <sheepfleece> I need to just validate part of the input and then hash it.
19:38:02 <sheepfleece> There is peekChar, but that's not what I need (or at least I think so)
19:38:22 <wavemode> there is a function called lookAhead in Data.Attoparsec.Combinator
19:41:42 <sheepfleece> Thank you! Exactly what I need.
19:45:41 <ezzieyguywuf> http://dpaste.com/0Z9RWZM, I try to run this in ghci but get an error "Expected type: SpecWith()", "Actual type: SpecWith (Arg Property"
19:45:56 <ezzieyguywuf> I pulled this example straight from the documentation: https://hspec.github.io/quickcheck.html
19:46:00 <ezzieyguywuf> am I doing smoething wrong?
19:58:07 <ski> molossus_spondee : in when / in which situation would this opposite be needed ?
19:58:45 <molossus_spondee>  When you are applying a thunk to a list of arguments
19:59:58 <ski> you want another name for "thunk" here ?
20:00:19 <ski> (also, i'm wondering why you're calling it a thunk)
21:02:40 <brailsmt> is there a channel specifically for hdevtools?  i'm having install issues and don't really know where to go for help
21:04:38 <brailsmt> i checked haskell.org/irc and didn't see anything
21:06:45 <brailsmt> here is the error when i try 'stack install hdevtools':  https://gist.github.com/brailsmt/f1511785d112dd31113114778c016ec2
21:08:10 <c_wraith> brailsmt: that error suggests that hdevtools is has a back cabal file - it allows base 4.*, which is too lenient.
21:08:18 <c_wraith> *bad* cabal file
21:09:29 <c_wraith> Looks like it's designed for an older version of ghc than 8.8
21:10:46 <brailsmt> c_wraith: thx, i'll log an issue to the project and see if i can't come up with a solution
21:21:15 * hackage conferer 0.4.1.0 - Configuration management library  https://hackage.haskell.org/package/conferer-0.4.1.0 (ludat)
22:28:01 <typetetris> Can I silence ghc missing top-level signature warning for a single function without writing down the signature (servant ...) ?
22:30:16 <Axman6> Not for a single function, as far as I know
22:30:45 * hackage digraph 0.2 - Directed Graphs  https://hackage.haskell.org/package/digraph-0.2 (larsk)
22:32:39 <wavemode> you can silence it for a single module with {-# OPTIONS_GHC -fno-warn-missing-signatures #-}
22:33:22 <Axman6> is it the type sig for a handler function?
22:34:06 <Axman6> if so, :kind Server <endpoint type> m should give you the right thing (that might not be the type family but yuou can find it easily enough)
22:38:47 <typetetris> Axman6: the whole server acutally
22:39:04 <typetetris> Axman6: using polysemy and all the Constraint blow it up
22:39:15 * hackage hoauth2 1.13.0 - Haskell OAuth2 authentication client  https://hackage.haskell.org/package/hoauth2-1.13.0 (HaishengWu)
22:42:45 <Sathiana> I have this function from a book:
22:42:51 <Sathiana> toPart recipient = "Dear " ++ recipient ++ ",\n"
22:43:39 <Sathiana> but whenever I try to provide toPart with an argument, it says: "Variable not in
22:43:41 <Sathiana> scope: argument :: [Char] . I can't figure out why 
22:44:07 <wavemode> what exactly are you typing
22:44:53 <Sathiana> toPart name
22:45:37 <Axman6> is name defined somewhere?
22:46:58 <Sathiana> shouldn't recipient be the parameter part to the function (toPart)
22:47:18 <Axman6> recipient is the name of the argument to toPart
22:47:30 <Axman6> foo x = x+x 
22:47:56 <Axman6> so, you can run toPart "John" and get back "Dear John,\n"
22:48:14 <Sathiana> isn't recipient just a place holder
22:48:19 <Sathiana> aha I see
22:48:25 <Sathiana> I missed the quotes
22:49:23 <Axman6> yes, you're passing in a string, it needs to be in quotes
22:51:33 <Sathiana> somehow I thought it would interpret John as [Char]
22:51:38 <Sathiana> lesson learned
22:53:26 <Axman6> that would make programming quite confusing :)
22:54:41 <dsal> I think perl did that for a while.
22:56:16 <Axman6> and most shell scripting languages
22:57:44 <yushyin> dsal: it does even now, if you don't say use strict;
22:58:07 <dsal> I've not interacted with perl in a long time.
23:00:45 <yushyin> and in some cases barewords are even allowed with 'use strict;' like for hash keys which are strings e.g. $hash{this_is_a_bareword}
23:01:22 <Axman6> Just think of all the useful stuff you could know if you didn't remember all that :P
23:27:45 * hackage numhask-space 0.4.0 - numerical spaces  https://hackage.haskell.org/package/numhask-space-0.4.0 (tonyday567)
23:44:15 * hackage numhask 0.5.0 - numeric classes  https://hackage.haskell.org/package/numhask-0.5.0 (tonyday567)
23:45:15 * hackage numhask-prelude 0.4.0 - A numeric prelude  https://hackage.haskell.org/package/numhask-prelude-0.4.0 (tonyday567)
