00:34:48 <koz_> Is Hackage OK or is it just me?
00:45:27 <p0a> works for me
00:45:32 <p0a> this one right? https://hackage.haskell.org/ 
00:50:49 <MarcelineVQ> koz_: This is a trick question isn't it
00:51:17 <sshine> ha
00:51:29 <koz_> Yeah, I was having some kind of serious lag for a while.
00:52:23 <c_wraith> it was phrased like a trick question
00:54:03 <koz_> c_wraith: Not my intent, sorry.
00:54:17 <MarcelineVQ> It works for me, something's not right here...
00:59:56 <koz_> On GHC 8.10.1, using finitary-2.0.0.0, if I create a newtype around something with a Finitary instance, then try a newtype derive of Finitary on said newtype, GHC yells at me about redundant constraints.
01:00:02 <koz_> What's the deal with that?
01:04:14 <MarcelineVQ> It's probably impossible to know
01:04:55 <MarcelineVQ> But if someone did know they'd still wanna see what you tried :>
01:06:36 <koz_> MarcelineVQ: I can paste.
01:06:59 <koz_> (I doubt it's impossible, I just suspect there's something about the newtype deriving strategy I'm missing here)
01:12:36 <koz_> MarcelineVQ: https://gist.github.com/kozross/f92ac701c746d341d113ef754c629efc
01:17:50 <koz_> (or anyone else who might know what's happening)
01:20:32 <pgiarrusso> koz_: luckily s/yells at me/gives warnings/ so ignoring or reporting them _might_ be an option
01:21:13 <koz_> pgiarrusso: Ignoring warnings isn't a habit I plan to get into. There has to be a reason for this, and given that finitary is _my_ library, it vexes me even more.
01:21:27 <koz_> If I at least knew why this was happening, I might be able to rewrite this issue away.
01:22:14 <pgiarrusso> the next step seems to be trying `-ddump-deriv` and understanding _if_ there’s something wrong with the generated code or with the warning.
01:23:21 <koz_> pgiarrusso: How do I get -ddump-deriv and inspect the contents? I'm building with Cabal.
01:23:30 <koz_> s/Cabal/cabal-install/
01:24:27 <pgiarrusso> hm, does that option work in an `{-# OPTIONS_GHC` pragma?
01:25:01 <MarcelineVQ> might, you'lll want -ddump-to-file too tho
01:25:33 <MarcelineVQ> another option is to do the deriving in ghci, not sure how short it'll be though
01:25:34 <int-e> koz_: Well `begin` and `end` have a `1 <= Cardinality a` constraint but the cardinality of Set a is 2^Cardinality a, which satisfies that constraint for free.
01:25:44 <koz_> int-e: ... Rofl.
01:25:51 <int-e> koz_: So the constraint ends up being redundant, as the warning says.
01:26:05 <int-e> koz_: That's my guess at least :P
01:26:15 <koz_> Well, I'd say it's a good one.
01:26:17 <int-e> (being unfamiliar with basically all of that)
01:26:39 <koz_> I think those plugins are doing some heavy lifting I'm not seeing.
01:27:02 <koz_> Makes me wonder if I should make start and end functions rather than methods, and then SPECIALIZE the ones for simple types.
01:27:42 <int-e> (The newtype deriving of course preserves the constraint when coercing the methods on Vector to those on Set... because in general you'll have to do that.)
01:28:08 <koz_> int-e: DerivingVia also.
01:28:09 <int-e> (It seems hard to anticipate that it will turn out to be redundant.)
01:30:03 <int-e> koz_: So... report it (it's questionable how useful the warning is when the constraint was put there by the compiler, not the programmer) and ignore the warning for now?
01:31:14 <koz_> int-e: It might be out of scope for GHC, since this won't even compile without those two plugins.
01:31:25 <koz_> (since I guess GHC is where I need to report this to?)
01:31:37 <pgiarrusso> the constraint was put there by http://hackage.haskell.org/package/finitary-1.0.0.1/docs/src/Data.Finitary.html#start, so it seems koz_’s idea might be good?
01:31:42 <pgiarrusso> 10:26 AM <koz_> Makes me wonder if I should make start and end functions rather than methods, and then SPECIALIZE the ones for simple types.
01:32:08 <koz_> pgiarrusso: Is it possible to write SPECIALIZEd versions for functions from a library?
01:32:24 <koz_> (as in, one you don't control)
01:32:27 <pgiarrusso> yeah was about to write that I’m not sure on the second part
01:32:59 <pgiarrusso> but does SPECIALIZE let you supply a new body? I didn’t think so in Haskell, only C++ ?
01:33:41 <pgiarrusso> let me know if I should shut up as it’s been a while, but I thought SPECIALIZE asked the _compiler_ to generate an optimized monomorphic version.
01:34:08 <koz_> I might be confusing stuff as well.
01:34:16 <pgiarrusso> I wonder if rewrite rules would be relevant here?
01:34:45 <pgiarrusso> if GHC lets you rewrite `foo @Bar` to `fooBar`, you’d be set.
01:35:14 <koz_> Oh yeah, rewrite rules are what I need.
01:35:22 <pgiarrusso> (*you’re)
01:35:36 <koz_> I was thinking of the obsolete SPECIALIZE syntax, which lets you provide a replacement function.
01:36:20 <pgiarrusso> well, I stand corrected then :-)
01:36:39 <koz_> I guess for rewrite rules, those can be done anywhere for anything?
01:37:56 <pgiarrusso> probably, but “orphan” rewrite rules seem easy to not import?
01:38:41 <pgiarrusso> like, if you define Finitary X in a module Foo and its rewrite rules in module Bar, it’s too easy to import Foo without Bar.
01:39:36 <pgiarrusso> meanwhile, your proposal is a breaking change for at least Data.Finitary, so while you do it you can also add the rewrite rules
01:40:10 <int-e> koz_: I guess you have a point... the warning likely originates in the KnownNat solver.
01:40:28 <pgiarrusso> to be sure, I haven’t investigated all that in detail...
01:41:24 <koz_> pgiarrusso: Me neither. Since I'm th author of finitary, I'm just thinking if that would be a better API or not.
01:41:29 <pgiarrusso> int-e: by your explanation, the warning is caused by GHC expanding deriving as specified — the plugin only computes (correctly) that the constraint is redundant, no?
01:41:49 <koz_> pgiarrusso, int-e: Would it help if I gave a -ddump of what it derives?
01:42:32 <int-e> pgiarrusso: Uh what is GHC supposed to do instead though? I was thinking the most viable route out of this is to suppress the warning if the constraint was put there by the compiler.
01:43:23 <koz_> int-e: Do you think having start and end as functions with rewrite rules is a better design choice than having them be methods?
01:43:29 <pgiarrusso> int-e: exactly, so it’s not clear that’s a bug.
01:43:36 <koz_> I'm not familiar with rewrite rules, so I have no idea.
01:44:03 <pgiarrusso> I now wonder if having instances define the constraints might work.
01:44:21 <pgiarrusso> with ConstraintKinds and associated types, you can write that.
01:44:28 <int-e> pgiarrusso: Oh I didn't intend to suggest that it's a bug.
01:44:51 <pgiarrusso> okay, we agree then.
01:44:59 <p0a> I am trying to write a Tree that contains the subsets (sublists) of a list and traverse them breadth-first
01:45:03 <koz_> pgiarrusso: What would that look like?
01:45:28 <p0a> Is that solved anywhere? I tried some things but I've stumbled upon issues
01:45:50 <int-e> pgiarrusso: But in an ideal world, that warning would not be emitted... and there's the question of whose responsibility it is to supress it.
01:46:28 <int-e> err, suppress. And that's not clear when type checking plugins are involved.
01:47:11 <pgiarrusso> boz_  add to the typeclass`type MyConstraint :: Constraint = 1 <= Cardinality a` then `start, end :: MyConstraint => ...`
01:48:52 <int-e> p0a: not sure what you mean, can you give an example, maybe for a 2-element list?
01:49:38 <koz_> int-e: Under ordinary circumstances, that code won't compile at all. So therefore, GHC can't be held responsible.
01:50:02 <pgiarrusso> and then set `type MyConstraint = ()` in the instance giving the warning..., boz_. The problem is that that’s a derived instance, so you’d need to customize derivation (maybe possible with DerivingVia or such? dunno). So that doesn’t sound too good...
01:50:03 <koz_> The only thing that makes this work are those plugins, which then allow it to get to he point of going 'oh, actually, it's fine, we don't need that constraint'.
01:50:28 <int-e> koz_: But it may still turn out to be a case of missing API (for informing plugins of generated constraints).
01:50:48 <koz_> int-e: Good point. Report it I shall.
01:50:55 <pgiarrusso> koz_: I expect the same problem can apply to other typeclasses without those plugins.
01:51:08 <int-e> I mean, maybe report it to the plugin in question first.
01:51:19 <koz_> int-e: Yeah, that's a good idea. Will do that.
01:51:25 <pgiarrusso> indeed, it’s not about the plugins, koz_.
01:51:40 <pgiarrusso> koz_: you have a typeclass on a where some methods add constraints to a.
01:51:42 <int-e> (Because hopefully the plugin author can figure out whether GHC provides the necessary functionality or not.)
01:52:03 <pgiarrusso> Thus, derived instances where a satisfy the constraints _will_ cause such warnings.
01:52:07 <pgiarrusso> No plugins needed.
01:52:19 <koz_> pgiarrusso: Is there a 'smoke test' I can do to demonstrate this?
01:52:50 <koz_> int-e: I gotta report a thing to GHC anyway, unrelated to this (KnownNat and QuantifiedConstraints don't play nice together).
01:52:51 <pgiarrusso> what about `class Foo a where { bar :: Num a => a }; instance Foo Int` ?
01:53:02 <koz_> pgiarrusso: Alrighty, let me give it a whirl.
01:53:24 <pgiarrusso> maybe add a default implementation to bar
01:53:30 <pgiarrusso> `bar x = x + x` will do
01:54:22 <pgiarrusso> if that is the problem, GHC might answer "GHC is correct, change the design of the class".
01:55:48 <int-e> koz_: FWIW, my attempt at creating a similar warning with just GHC failed: http://paste.debian.net/1145275/ (and that's despite the constraints ending up in the derived instance.)
01:55:57 <pgiarrusso> it's been too long, but can you move those methods to a `class (Finitary a, Cardinality a >= 1) => NEFinitary a where`
01:56:29 <pgiarrusso> int-e: is the warning -Wredundant-constraint indeed enabled?
01:56:32 <p0a> int-e: toList (subsetsOf [1,2]) ===> [[], [1], [2], [1,2]]
01:57:32 <p0a> for example `subsequences' of Data.List returns them in a different order.
01:57:39 <int-e> pgiarrusso: Oh, no it wasn't.
01:57:59 <int-e> (Not implied by -Wall, hmpf.)
01:58:54 <int-e> p0a: Ah, so there's no tree in the result you want?
01:59:04 <koz_> Reproduced.
01:59:23 <p0a> int-e: well I'm exploring my options
01:59:39 <koz_> https://gist.github.com/kozross/782d9f7af613d6cf69a2a8516711b63b
01:59:42 <p0a> int-e: I have a monotone predicate so p xs ==> p xs' if xs is a subset of xs'
01:59:54 <koz_> This triggers redundant constraint warnings.
02:00:26 <p0a> int-e: I want to find subsets such that p xs is True; the first (smallest in length) subset `xs' that (p xs) is True is good enough
02:00:49 <p0a> int-e: If I had the above list I'd just do `find p myList'
02:00:55 <int-e> koz_: Yeah my mistake was to assume that -Wall would be sufficient to get a warning... now the code is needlessly complicated.
02:01:16 <int-e> (though it could be worse)
02:01:37 <koz_> So, is this reportable?
02:03:50 <int-e> koz_: Personally, yes I think so, based on the idea that warnings should be actionable, and (I think) there's no way to silence this warning without giving up on GND.
02:04:16 <koz_> int-e: OK, then I'll report.
02:04:28 <koz_> You don't even need GND.
02:04:32 <koz_> DerivingVia will trigger too.
02:04:59 <int-e> That's basically the same thing, isn't it?
02:05:16 <koz_> int-e: Yeah, just that DerivingVia lets you choose what you coerce through.
02:05:16 <int-e> (Take an existing instance, coerce the methods to get a new one.)
02:05:26 <int-e> Sure.
02:05:33 <koz_> But yeah, I'll report right now.
02:05:58 <int-e> But it's unsurprising that it should have the same flaws as GND. I imagine the two share a lot of the code.
02:06:51 <koz_> They basically both lean on coerce with some TypeApplications, right?
02:07:05 <koz_> It's just giving GHC a gentle push towards the irght dictionaries. :P
02:07:25 <int-e> Just type signatures, I believe.
02:07:43 <int-e> Ah, the coerce gets type applications.
02:08:59 <int-e> (You can see for yourself: -ddump-deriv prints the generated code.)
02:09:52 <tobiasBora> Hello,
02:13:07 <koz_> OK, and opened!
02:13:24 <tobiasBora> I'd like to program an application that could run in two modes: either a fast mode, or a log mode. In the log mode, I want basically to count the calls to some specific functions (I don't think that compiling with "perf" is a solution here for some reasons). I was thinking to use a WriterT monad, but I'm quite new to this, so I have few questions. My main question is, can I use the same code for both modes,
02:13:26 <tobiasBora> and just instantiate the type of the log to be empty, and reach exactly the same efficiency as without using any WriterT?
02:21:38 <p0a> int-e: I did away with the tree structure I just wrote what I needed as a recursive list function
02:22:40 <p0a> well actually idk. I suppose there's still an issue of removing elements from a list that makes it inefficient
02:22:49 <p0a> I just can't figure out the right approach
02:25:44 <int-e> p0a: http://paste.debian.net/1145278/ <-- doodling, maybe some of this is useful to you
02:25:50 <rain1> hello!
02:26:42 <p0a> int-e: oh that's it! thank yuo
02:27:27 <int-e> The  y : ys <- tails xs  pattern is a favorite of mine. :)
02:27:44 <p0a> Right that is what I was just noticing 
02:27:50 <p0a> that is definitely a trick I did not think of
02:32:51 <p0a> well I was missing a lot of tricks apparently
02:34:08 <higherorder> Hi! What's the name of the haskell construct of which `[sql| ...]` is an example? I forgot
02:35:09 <mniip> quasiquoters
02:35:14 <higherorder> thank you!
02:37:52 <int-e> p0a: here's another cute one: http://paste.debian.net/1145281/
02:39:21 <int-e> p0a: I have no clue which version to prefer. :)
02:42:01 <jacks2> > uncurry (++) $ partition isJust $ sort [Nothing, Just 3, Nothing, Just 1, Nothing, Just 2]
02:42:03 <lambdabot>  [Just 1,Just 2,Just 3,Nothing,Nothing,Nothing]
02:42:09 <jacks2> any nicer/more concise way of doing the same?
02:45:21 <p0a> int-e: oh that last one is raelly nice
02:49:37 <Phlogistique> > sortOn (\x -> (isJust x, x)) [Nothing, Just 3, Nothing, Just 1, Nothing, Just 2]
02:49:39 <lambdabot>  [Nothing,Nothing,Nothing,Just 1,Just 2,Just 3]
02:49:55 <Phlogistique> > sortOn (\x -> (not $ isJust x, x)) [Nothing, Just 3, Nothing, Just 1, Nothing, Just 2]
02:49:58 <lambdabot>  [Just 1,Just 2,Just 3,Nothing,Nothing,Nothing]
02:50:06 <Phlogistique> jacks2: ^
02:51:50 * hackage zipper-extra 0.1.0.0 - Zipper utils that weren't in Control.Comonad.Store.Zipper  https://hackage.haskell.org/package/zipper-extra-0.1.0.0 (locallycompact)
02:53:17 <fog> % :t \(_ :: Proxy s) f v -> (f <$> V.freeze @(ST s) v >>= V.thaw @(ST s))
02:53:17 <yahb> fog: Proxy s -> (V.Vector a1 -> V.Vector a2) -> V.MVector s a1 -> ST s (V.MVector s a2)
02:53:32 <fog> % :t \(_ :: Proxy s) f v -> runST (f <$> V.freeze @(ST s) v >>= V.thaw @(ST s))
02:53:32 <yahb> fog: ; <interactive>:1:31: error:; * Couldn't match type `s1' with `s'; `s1' is a rigid type variable bound by; a type expected by the context:; forall s1. ST s1 (V.MVector s a1); at <interactive>:1:30-74; `s' is a rigid type variable bound by; the inferred type of it :: Proxy s -> (V.Vector a -> V.Vector a1) -> V.MVector s a -> V.MVector s a1; at <inter
02:53:36 <fog> !?
02:54:02 <fog> % :t runST
02:54:02 <yahb> fog: (forall s. ST s a) -> a
02:54:16 <fog> there is a pesky forall s. there which is messing this up
02:54:36 <merijn> fog: That "pesky forall s" is to prevent you from doing things which are broken
02:55:36 <fog> why shouldnt it be able to retrieve the MVector from ST s ?
02:55:42 <merijn> fog: You can't leak ST variables/operation outside of runST
02:56:11 <merijn> fog: Because if you could do that you could get a reference to a mutable vector in a pure context, which violates purity
02:56:18 <int-e> right, this is by design
02:56:20 <fog> so if I go "via" immutable, I have to stay within St s ?
02:56:30 <merijn> fog: Until you're done mutating, yes
02:56:55 <merijn> You can return immutable vectors from ST, but not mutable ones
02:57:01 <jacks2> Phlogistique, nice
02:57:01 <fog> ah that kind of makes sense
02:57:03 <fog> thanks
02:57:34 <merijn> fog: (Well, technically you *can* return mutable vectors from ST, but then you can't actually read or write to them in any other ST context, so it's pointless :p)
02:57:59 <steshaw> @Phlogistique if you want to sort that way a lot, why not make a newtype and an instance for Ord?
02:58:00 <lambdabot> Unknown command, try @list
02:58:05 <merijn> fog: The "Lazy Functional State Threads" paper explains how, exactly, this trick works or what it enforces
02:58:16 <int-e> merijn: Oh, wrap them in an existential, you mean?
02:58:35 <Phlogistique> steshaw: that's a remark for jacks2, not for me
02:58:38 <merijn> int-e: Yeah
02:58:56 <int-e> that's... yeah, possible and useless :)
02:59:10 <MarcelineVQ> jacks2  Phlogistique   sortBy (comparing (not . isJust) <> compare)  is neato too
02:59:17 <merijn> > sort [Nothing, Just 3, Nothing, Just 1, Nothing, Just 2]
02:59:19 <lambdabot>  [Nothing,Nothing,Nothing,Just 1,Just 2,Just 3]
02:59:24 <merijn> Or, you know, just sort :p
02:59:31 <MarcelineVQ> sort of like using (,) but you can keep on adding
02:59:40 <jacks2> merijn, not the same result
02:59:42 <MarcelineVQ> merijn: they wanted Nothing's at the end :>
02:59:51 <merijn> > sortOn Down [Nothing, Just 3, Nothing, Just 1, Nothing, Just 2]
02:59:53 <lambdabot>  [Just 3,Just 2,Just 1,Nothing,Nothing,Nothing]
02:59:57 <merijn> boom
03:00:03 <jacks2> the same
03:00:12 <steshaw> Phlogistique i see
03:00:22 <jacks2> > sortOn (\x -> (not $ isJust x, x)) [Nothing, Just 3, Nothing, Just 1, Nothing, Just 2]
03:00:26 <lambdabot>  [Just 1,Just 2,Just 3,Nothing,Nothing,Nothing]
03:00:42 <merijn> > sortOn (Down . fmap Down) [Nothing, Just 3, Nothing, Just 1, Nothing, Just 2]
03:00:44 <lambdabot>  [Just 1,Just 2,Just 3,Nothing,Nothing,Nothing]
03:00:56 <merijn> Monoid is the best typeclass, change my mind
03:01:19 <int-e> merijn: Semigroup?
03:01:20 <jacks2> :t Down
03:01:21 <lambdabot> a -> Down a
03:01:38 <merijn> jacks2: "newtype Down a = Down a" has Ord reversed :)
03:01:50 <merijn> > 2 < 3
03:01:52 <lambdabot>  True
03:01:55 <merijn> > Down 2 < Down 3
03:01:57 <lambdabot>  False
03:06:06 <gentauro> Oh, I just noticed that `Haskell docs` on `Hackage` just got a UI-facelift :) (not it reminds the content page) -> https://hackage.haskell.org/package/base-4.14.0.0/docs/Text-ParserCombinators-ReadP.html#v:count
03:06:11 <gentauro> (looking good)
03:06:12 <gentauro> :)
03:06:33 <int-e> > sortOn (maybe (Right ()) Left) [Nothing, Just 3, Just 1, Nothing, Just 2] -- or use another sum type
03:06:35 <lambdabot>  [Just 1,Just 2,Just 3,Nothing,Nothing]
03:07:05 <MarcelineVQ> You've taken it too far, a team has been dispatched.
03:07:26 <int-e> MarcelineVQ: did you send it left or right though...
03:07:45 <int-e> (or down?)
03:08:20 * hackage unjson 0.15.3 - Bidirectional JSON parsing and generation.  https://hackage.haskell.org/package/unjson-0.15.3 (arybczak)
03:08:46 <opqdonut> > sortOn show [Nothing, Just 3, Just 1, Nothing, Just 2] -- why use complex code when simple code do trick
03:08:48 <lambdabot>  [Just 1,Just 2,Just 3,Nothing,Nothing]
03:09:07 <int-e> opqdonut: OUCH
03:09:25 <MarcelineVQ> int-e: I gave it a comparison function, they're already  log n  steps away
03:09:26 <Phlogistique> This is why Haskellers never achieve anything :-O
03:09:32 <int-e> > sortOn show [Just 2, Just 10, Just 33]
03:09:35 <lambdabot>  [Just 10,Just 2,Just 33]
03:10:05 <int-e> MarcelineVQ: Wait till they find the NaN.
03:10:07 <opqdonut> int-e: yeah it doesn't generalize unfortunately :P
03:10:11 <merijn> gentauro: That's just the new haddock release switching to the new style
03:10:37 <MarcelineVQ> I don't like the newstyle, change is scary
03:10:47 <MarcelineVQ> I do like the new src view though
03:10:56 <merijn> MarcelineVQ: I think I'll get used to it, but I'd like a thicker font weight!
03:11:04 <merijn> int-e: Don't remind me :(
03:11:14 <merijn> int-e: I had a lot of data corruption due to NaN :(
03:11:32 <MarcelineVQ> make sense, only numbers are data
03:11:53 <MarcelineVQ> Like two, or S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S ( ...
03:12:22 <[exa]> oh wow, numbers in logic!
03:12:27 <[exa]> > sortOn (show . fmap (flip replicate 'a')) [Just 33, Just 10, Just 2]
03:12:30 <lambdabot>  [Just 2,Just 10,Just 33]
03:13:12 <merijn> I think jacks2 is now cowering from the horrors he's unleashed :p
03:13:20 <MarcelineVQ> and it's only wednesday
03:13:31 <merijn> Feels like monday >.>
03:13:33 <int-e> [exa]: enter negative numbers, then non-integers, then non-number types
03:13:58 <[exa]> int-e: there are no negative numbers. Instead it knows a trick:
03:14:07 <[exa]> > sortOn (show . fmap (flip replicate ' ')) [Just 33, Just 10, Just 2] -- reverse sort
03:14:09 <lambdabot>  [Just 33,Just 10,Just 2]
03:15:08 <int-e> > [' '..'"']
03:15:11 <lambdabot>  " !\""
03:15:25 <MarcelineVQ> what a surprise
03:15:53 <jacks2> merijn :)
03:16:17 <mniip> cubical haskell when
03:16:19 <MarcelineVQ> really though the simplest way is probably best   sorted _ = [Just 1,Just 2,Just 3,Nothing,Nothing,Nothing]
03:17:17 <int-e> MarcelineVQ: you must be an expert at passing unit tests
03:17:37 <merijn> int-e: Easy-peasy, just don't write tests
03:17:45 <MarcelineVQ> When it comes to testing I'm the squirrel's #23norg
03:18:59 <phadej> mniip: probably never.
03:19:02 <phadej> or most likely
03:19:16 <mniip> that was not a serious question
03:19:43 <mniip> sort xs = [minBound..maxBound] >>= \x -> filter (== x) xs
03:20:00 <gentauro> 12:09 < merijn> gentauro: That's just the new haddock release switching to the new style
03:20:03 <gentauro> ME GUSTA !!!
03:20:12 <int-e> mniip: what does that "cubical" refer to?
03:20:22 <fuzzy_id> I have a parsec parser `pIssue` which does what I want, namely detecting issue numbers and extracting them. Now, I want to extract issue numbers from free style text. Any suggestions how this can be solved elegantly?
03:20:26 <mniip> int-e, computable univalent homotopy type theory
03:20:40 <int-e> o-kay. sorry I asked :)
03:20:44 <fuzzy_id> Currently I have something like `P.many (P.many1 pIssue P.<|> (P.anyChar *> pure []))`
03:20:55 <fuzzy_id> (with P being Text.Parsec)
03:21:17 <fuzzy_id> this does the job but gives results like `Right [[],[],[],[],[CR 71]] 
03:21:26 <gentauro> btw, Athas just passed me the following link -> http://chalmersfp.org/ There are upcoming talks from SPJ, Pierce (<3 the TAPL book) and Wadler
03:21:27 <fuzzy_id> which feels clumsy
03:21:59 <mniip> catMaybes <$> many ((Just <$> pIssue) <|> (Nothing <$ anyChar))
03:22:36 <merijn> That's going to be slow as fuck, though :p
03:22:56 <fuzzy_id> yeah, i'm currently not optimizing 
03:23:37 <mniip> fix $ \p -> (liftA2 (:) pIssue p) <|> (anyChar <* p)
03:23:45 <merijn> mniip: I only just saw your sort, I'm notifying the UN for crimes against humanity
03:23:58 <gentauro> merijn: xD
03:24:29 <mniip> oops
03:24:32 <mniip> anyChar *> p
03:25:25 <mniip> should probably also <|> pure []
03:25:33 <mniip> the text has to terminate somewhere
03:26:03 <merijn> mniip: Are you practicing for the international obfuscated Haskell contest? >.>
03:26:13 <mniip> is that a thing
03:26:26 <mniip> but also is it that obfuscated
03:26:26 <merijn> mniip: Not yet, I think?
03:26:40 <fuzzy_id> mniip: I liked your first suggestion. :)
03:26:46 <int-e> merijn: all sorts are equal
03:26:55 <mniip> it should be
03:26:55 <merijn> int-e: Obviously false
03:26:58 <mniip> I have a feq entries
03:27:01 <mniip> few
03:27:01 <merijn> merge sort is best sort
03:27:15 <int-e> merijn: that's discrimination
03:27:21 <mniip> int-e, did you just assume functional extensionality
03:27:23 <ski> MarcelineVQ's just exercising a sound laziness
03:27:34 <merijn> mniip: Someone submitted a minimal Haskell-like compiler to IOCCC last year :p
03:27:40 <mniip> I saw
03:27:56 <int-e> mniip: I was viewing things through a pure lens.
03:28:02 <merijn> I think an underhanded Haskell contest would be more fun :p
03:28:29 * ski . o O ( "Résumé" by Maria Kovalyova,Roman Cheplyaka in 2010-12-12 at <https://ro-che.info/ccc/11> )
03:28:32 <mniip> one of my highest rated answers on PPCG was `main = return (removeDirectoryRecursive "/")`
03:28:37 <int-e> (I challenge you to come up with a worse pun.)
03:28:54 <mniip> int-e, pure is not a lens
03:29:41 <int-e> mniip: That "pure" was an adjective :P
03:30:06 <gentauro> merijn: isn't (`sort xs = [minBound..maxBound] >>= \x -> filter (== x) xs`) ideal for sorting `bytes` (Word8)? :P
03:30:12 <int-e> (Just don't ask me what an impure lens would be.)
03:30:20 <mniip> gentauro, no not quite
03:30:41 <mniip> int-e, replace the (->) profunctor with Kleisli m
03:31:18 <gentauro> mniip: how would the `desugared` version look like? I have some `issues` trying to graps the logic :D
03:31:35 <mniip> desugared version of?
03:32:03 <Athas> merijn: you have a weird way of spelling "radix sort".
03:32:17 <mniip> a proper radix sort will go over `xs` once
03:32:20 <merijn> Athas: Radix sort is nice, but not best :)
03:32:30 <mniip> not 256 times one per each possible output value
03:33:19 <mniip> ok here's a better version
03:33:26 <mniip> sort xs = nub xs >>= \x -> filter (== x) xs
03:33:56 <ski> > nub "mississippi"
03:33:58 <lambdabot>  "misp"
03:33:59 <mniip> wait
03:34:00 <opqdonut> nub doesn't sort tho
03:34:01 <mniip> that doesn't sort
03:34:03 <mniip> rip
03:34:12 <gentauro> mniip where is `nub` defined?
03:34:13 <opqdonut> maybe Set.fromList ?-)
03:34:16 <mniip> Data.List
03:34:18 <opqdonut> @src nub
03:34:18 <lambdabot> nub = nubBy (==)
03:34:18 <lambdabot> --OR
03:34:18 <lambdabot> nub l = go l []
03:34:18 <lambdabot>   where go []     _       = []
03:34:18 <lambdabot>         go (x:xs) ls
03:34:20 <lambdabot>             | x `elem` ls = go xs ls
03:34:22 <lambdabot>             | otherwise   = x : go xs (x:ls)
03:34:23 <mniip> opqdonut, nah that's too fast
03:34:40 <timCF> Hi! Is there some safe version of `fromIntegral` which will check type boundaries? Something like `safeFromIntegral :: (Integral a, Num b) => a -> Maybe b`
03:37:04 * ski idly wonders which algebraic structure `Integral' wants to be
03:37:24 <mniip> partial magmoid
03:39:50 <int-e> % :i nub
03:39:51 <yahb> int-e: nub :: Eq a => [a] -> [a] -- Defined in `base-4.14.0.0:Data.OldList'
03:40:25 <int-e> :t S.toList . S.fromList
03:40:27 <lambdabot> Ord a => [a] -> [a]
03:40:34 <merijn> timCF: Sadly, I don't think so?
03:40:56 <ski> @type divMod
03:40:57 <lambdabot> Integral a => a -> a -> (a, a)
03:40:59 <ski> @type divMod'
03:41:00 <lambdabot> (Integral b, Real a) => a -> a -> (b, a)
03:41:10 <int-e> Usually the better choice... unless you know the list has very few distinct elements, or for some inexplicable reason you have Eq but not Ord.
03:41:19 * hackage haskoin-core 0.13.0 - Bitcoin & Bitcoin Cash library for Haskell  https://hackage.haskell.org/package/haskoin-core-0.13.0 (jprupp)
03:41:25 <ski> hm, is there a reason why the latter doesn't use `Num' in place of `Integral' ?
03:42:22 <int-e> :t truncate
03:42:23 <lambdabot> (RealFrac a, Integral b) => a -> b
03:42:36 <ski> that too, i guess, yes
03:44:28 <int-e> Maybe with the idea that the type is a partial specification.
03:44:46 <ski> @type genericTake
03:44:48 <lambdabot> Integral i => i -> [a] -> [a]
03:44:50 <ski> @type genericLength
03:44:51 <lambdabot> Num i => [a] -> i
03:45:19 <int-e> Well, those are much newer.
03:45:54 <int-e> (Note that I'm comparing to truncate. I don't know about divMod'...)
03:50:10 <ski> hm, well if you're generalizing from producing an `Integer', you could generalize to producing an `i', where `Num i', since that has `fromInteger'
03:50:39 <ski> while, if you're consuming an `Integer', `toInteger' is in `Integral'
03:51:34 <int-e> Yeah I knew what you were getting at.
03:51:50 * hackage lowlin 0.2.0.1 - Low dimensional linear algebra  https://hackage.haskell.org/package/lowlin-0.2.0.1 (jodak)
03:52:34 <ski> (hm, and `Num' looks like it wants to be a type class of rings (sortof), and `Integer' is the initial ring)
03:53:24 <ski> (although, of course, `abs' and `signum' are muddling that image up)
03:53:39 <timCF> Any ideas how I can fix it? This function is supposed to do safe conversion from unbounded `Integer` to other bounded integral types like `Word8` https://gist.github.com/tim2CF/9aa20cbfc54a05e295b7d83f7e13e2b5
03:53:45 <int-e> . o O ( just put abs _ = 1 and signum x = x. )
03:54:14 <int-e> well, abs 0 = 0 would be good. But it's almost law-abiding :P
03:55:32 * ski got side-tracked a bit, thinking of `Integer' being the free group on one generator, useful as a generic pointing object
03:55:44 <merijn> timCF: Honestly, that looks a lot like the code I have in some conversion in base :p
03:55:44 <int-e> Num (rings, with a tiny wart) and Fractional (fields) are nice classes. Real is where things get truly murky.
03:57:44 <timCF> merijn seems like it should work, but compiler don't like `maxBound :: a` for some reason
03:58:06 <merijn> oh!
03:58:29 <merijn> timCF: That's because the scope of type variables is limited to the actual type signature
03:58:36 <ski> timCF : add `forall a.', and `ScopedTypeVariables'
03:58:45 <merijn> timCF: You can use asTypeOf or ScopedTypeVariables
03:59:05 <merijn> > maxBound `asTypeOf` (1 :: Int)
03:59:08 <lambdabot>  9223372036854775807
03:59:24 <merijn> Ah wait, no, you can't use asTypeOf here
03:59:32 <merijn> SCTV then
04:00:11 <timCF> merijn thanks a lot!!! `forall a.` fixed it, that's a miracle))
04:00:18 <fog> ok, hows about this;
04:00:20 <fog> :t \(_ :: Proxy s) f g -> (\h xs -> V.thaw xs >>= \v -> h v >> V.freeze v) (\x -> f x >> (\h v -> V.freeze v >>= h >>= V.thaw) g x)
04:00:21 <lambdabot> error:
04:00:22 <lambdabot>     Not in scope: ‘V.thaw’
04:00:23 <lambdabot>     No module named ‘V’ is imported.
04:00:26 <fog> % :t \(_ :: Proxy s) f g -> (\h xs -> V.thaw xs >>= \v -> h v >> V.freeze v) (\x -> f x >> (\h v -> V.freeze v >>= h >>= V.thaw) g x)
04:00:26 <yahb> fog: forall k (m :: * -> *) (s :: k) a1 a2 a3. Control.Monad.Primitive.PrimMonad m => Proxy s -> (V.MVector (Control.Monad.Primitive.PrimState m) a1 -> m a2) -> (V.Vector a1 -> m (V.Vector a3)) -> V.Vector a1 -> m (V.Vector a1)
04:00:37 <fog> but;
04:01:45 <ski> `s' is singleton
04:04:26 <ski> why the beta-redices ?
04:06:32 <ski> (and why are you throwing away the monadic result of the second `thaw' ?)
04:07:12 * ski sighs
04:07:50 * hackage shake-plus 0.0.2.0 - Re-export of Shake using well-typed paths and ReaderT.  https://hackage.haskell.org/package/shake-plus-0.0.2.0 (locallycompact)
04:22:38 <day> ghc has build issues on ARM?
04:24:46 <day> I had the ghc package installed but it didnt work properly so i thought i deinstall/reinstall it but turns out it no longer is in the repo :/
04:35:56 <merijn> ARM is a tier 2 platform, I think?
04:36:10 <Uniaika> yes, ARM is not of the most supported platforms
04:36:21 <merijn> day: https://gitlab.haskell.org/ghc/ghc/-/wikis/platforms
04:36:25 <Axman6> watching 3Blue1Brown's video on logarithms, and I learnt a property of logs I hadn't known: log_a(b) * log_b(c) = log_a(c) - this feels very categorical, is there some kind of category here or is it just a coincidence?
04:36:32 <davve> I hope that will change now that the new macbooks will be using ARM !
04:36:52 <merijn> davve: They wil?
04:37:15 <davve> yes
04:37:22 <Axman6> says who?
04:37:36 <Axman6> that's arumour that's been going around for the best part of the last decade
04:37:49 <davve> https://www.macrumors.com/2020/02/24/mac-apple-designed-processor-2021/
04:38:47 <davve> yeah, but 2020 is said to be the year, we'll see :) https://www.macworld.com/article/3509471/the-mac-in-2020-new-keyboards-arm-macs-and-an-imac-reboot.html
04:39:07 <merijn> Anyway, ARM support pretty much relies on people caring about ARM contributing :p
04:40:49 <Uniaika> merijn: this or a company with enough haskellers on macs to care about funding the port :P
04:41:35 <davve> merijn: that usually goes hand in hand with people using the architecture
04:41:41 <davve>  / software
04:47:27 <dmj`> How can I pattern match on a function of arbitrary arity and lift it into a higher-kinded type? (e.g. (a -> b -> ... -> k -> l) becomes (Monad m => a -> b -> ... -> k -> m l))
04:47:51 <dmj`> not afraid to use Data.Dynamic, looking for any solution
04:50:19 <dmj`> where is Oleg kiselyov when you need him
04:51:18 <phadej> http://okmij.org/ftp/Haskell/polyvariadic.html#polyvartype-fn
04:59:48 <dmj`> two Oleg's for the price of one
05:00:16 <phadej> have you ever seen two olegs in the same room?
05:02:42 * Ariakenom taps finger on nose
05:03:29 <dmj`> phadej: I've never seen you and Oleg Kiselyov in the same room :) 
05:03:40 * ski idly ponders nilpotent Olegs
05:04:11 <dmj`> therefore, you must be the same person
05:05:54 <dmj`> phadej: so who is Satoshi Nakamoto then?
05:07:20 <MarcelineVQ> keyser soze
05:09:44 <int-e> dmj`: Would that be the person who you've never seen in a room at all?
05:10:12 <Ariakenom> <.<  >.>
05:10:56 <davve> anonymous
05:13:02 <dmj`> int-e: as far as I know, yes
05:15:16 <ski> hm, in epistemic modal logic, one can reify what everyone knows as an agent, the fool. ("even the fool knows that ..")
05:16:05 * ski . o O ( drinker's paradox )
05:23:11 <dmj`> phadej: there's gotta be an easier way to do this. 
05:24:05 <dmj`> something like, class Unroll b where unroll :: a -> b;  instance Unroll b => Unroll (a -> b) where
05:24:24 <dmj`> maybe with an associated type family if necessary
05:26:25 <ski> clearly it's ambiguous
05:27:25 <ski> e.g. should `a -> b -> c' become `a -> b -> m c' or `a -> m (b -> c)' ?
05:28:02 <ski> (also, it's possible for these two types to be equal .. but the generated code would have different behaviour)
05:29:04 <ski> (also, i dunno why you call it "a higher-kinded type" ..)
05:30:51 <dmj`> m has kind * -> *
05:31:02 <ski> which is not a higher-order kind
05:31:55 <Harry47> Hi all -- sorry for the noob question. Running Mac OSX Mojave. Just used ghcup to install GHC, but when I try and use ghc / cabal commands in my Terminal, it just says 'command not found'. It has installed the files to my user folder/.ghcup. Any help would be much appreciated! Thanks. 
05:35:22 <phadej> Harry47: https://unix.stackexchange.com/questions/26047/how-to-correctly-add-a-path-to-path
05:35:42 <Harry47> Thank you!
05:36:06 <dmj`> ski: I always called any type with kind greater than '*' higher-kinded.
05:37:14 <merijn> dmj`: higher-kinded are kind that take kinds higher than * as argument
05:37:23 <merijn> dmj`: So (* -> *) -> *, for example
05:38:46 <ski> @kind forall a b c m. Monad m => a -> b -> m c
05:38:47 <lambdabot> *
05:39:11 <dmj`> @kind Monad
05:39:12 <lambdabot> (* -> *) -> Constraint
05:39:25 <dmj`> So this qualifies? despite the fact it produces Constraint
05:40:27 <ski> i'm also unsure whether people mean something else by "higher-kinded type" than "higher-order type"
05:41:06 <ski> (what is a "higher-typed value" ?)
05:42:19 <dmj`> I think higher-kinded just means greater than *, higher-order kind would be like the type-level analog of higher-order function (function that takes a function). higher-order kind makes me think of a kind that takes a higher-kinded type as an argument.
05:43:16 <ski> a kind taking a type as argument ?
05:44:43 * ski 's confused
05:45:03 <dmj`> a higher-kinded type's kind
05:52:28 <dmj`> so Maybe is higher-kinded and StateT would be bother higher-kinded and a higher-order kind
05:52:46 <dmj`> both** lol
05:52:57 <merijn> dmj`: Maybe isn't higher-kinded in any usage I've seen before
05:53:14 <merijn> dmj`: See, for example, the discussion of when Rust and Swift will get higher-kinded types
05:53:20 <ski> i suppose i would say "non-concrete"
05:53:23 <merijn> dmj`: Both Rust and Swift have no problem with Maybe
05:53:43 * ski braces
05:54:32 <dmj`> so higher-kinded and higher-order kind are synonymous ?
05:54:49 <ski> i suppose the issue there is (a) allowing being polymorphic in a non-concrete type variable; and (b) allowing parameterizing data types over non-concrete type variables ?
05:55:44 <ski> personally, i'd prefer if people would stop using the term "higher-kinded", unless there's some legitimate need that it fills
05:56:26 * ski also grumbles about `PolyKinds'
05:56:49 * hackage Gleam 0.1.1.0 - HTML Canvas graphics, animations and simulations.  https://hackage.haskell.org/package/Gleam-0.1.1.0 (EbinBenny)
05:57:01 <dmj`> merijn: sure, the problem with those languages is the inability to generalize Maybe into something like Monad, and Monad would be considered a higher-kinded type
05:58:10 * hpc starts saying "kind of polymorphic" instead
05:58:20 * ski grins
06:12:20 <reactormonk> Wasn't there a library to work with records like data Foo f = { bar :: f String, baz :: f Int } ?
06:16:55 <jophish> reactormonk: https://hackage.haskell.org/package/barbies
06:17:05 <reactormonk> jophish, right, thanks!
06:17:10 <jophish> np
06:21:11 <timCF> I'm using this function as safe equivalent of `fromIntegral` where are handled overflows. What do you think, is it done well, or it might be more efficient somehow? https://gist.github.com/tim2CF/9aa20cbfc54a05e295b7d83f7e13e2b5
06:37:25 <Tuplanolla> I have a simple question. Is it possible to make Hakyll routes depend on the contents of other compiled items?
06:38:20 <Tuplanolla> I'm trying to find the home page based on its contents and choose the route based on that.
06:38:47 <srid[m]> Can you give an example of that use case?
06:38:49 <Ariakenom> timCF: LGTM
06:45:04 <Tuplanolla> I wrote these for one of my projects, timCF. I find conversion functions of the form `(C a, D b) => a -> b` to usually be too general.
06:45:04 <Tuplanolla> http://users.jyu.fi/~sapekiis/tmp/SafeIntegral.hs
06:45:50 * hackage autoapply 0.3 - Template Haskell to automatically pass values to functions  https://hackage.haskell.org/package/autoapply-0.3 (jophish)
06:50:24 <deech_> sm: Thanks for fielding fltkhs questions yesterday. I'll incorporate the feedback.
06:51:22 <timCF> Tuplanolla what's wrong with generic functions if they are doing the same things?
06:52:28 <Tuplanolla> Inconvenience with type defaulting, mostly.
06:53:11 <jacks2> @hoogle sortOn
06:53:12 <lambdabot> Data.List sortOn :: Ord b => (a -> b) -> [a] -> [a]
06:53:12 <lambdabot> GHC.OldList sortOn :: Ord b => (a -> b) -> [a] -> [a]
06:53:12 <lambdabot> Data.Sequence sortOn :: Ord b => (a -> b) -> Seq a -> Seq a
06:54:28 <jacks2> :t sortOn fst
06:54:30 <lambdabot> Ord b1 => [(b1, b2)] -> [(b1, b2)]
06:54:44 <jacks2> :t sortBy (comparing fst)
06:54:45 <lambdabot> Ord a => [(a, b)] -> [(a, b)]
06:54:53 <jacks2> not sure why we need both?
06:55:55 <merijn> jacks2: Did you read the docs of sortOn? It explains in the first line
06:56:16 <mniip> % :doc sortOn
06:56:17 <yahb> mniip:  Sort a list by comparing the results of a key function applied to each; element. @sortOn f@ is equivalent to @sortBy (comparing f)@, but has the; performance advantage of only evaluating @f@ once for each element in the; input list. This is called the decorate-sort-undecorate paradigm, or; Schwartzian transform.; Elements are arranged from from lowest to highest, keeping duplicates in; the ord
06:56:27 <Ariakenom> Tuplanolla: is safeFromInteger safe for Integers greater than maxBound::Int?
06:57:25 <Tuplanolla> Apparently not.
06:57:47 <sm[m]> np deech
06:58:10 <Tuplanolla> Should've actually just copied the previous definition.
06:58:30 <Tuplanolla> Good point.
07:02:03 <jacks2> so the reason for having both is that it is slightly more performant? while there's still no Ord variant of quadratic nub
07:11:40 <Tuplanolla> That's actually quite tricky, since you cannot necessarily convert `Bounded` things directly into `Integer`s.
07:16:03 <merijn> jacks2: There is, though, it's called "Set.toList . Set.fromList" :p
07:26:19 * hackage par-dual 0.1.0.0 - ParDual class for Parallel <-> Sequential  https://hackage.haskell.org/package/par-dual-0.1.0.0 (gvolpe)
07:52:42 <gentauro> can this -> `(Parser cs1) <*> (Parser cs2) = Parser $ \s -> [(f a, s2) | (f, s1) <- cs1 s, (a, s2) <- cs2 s1]` be written without `list comprehensions`? If yes, I would like a `hint` :)
07:53:04 <gentauro> I'm guessing it would be something like: `… <$> … <*> …` right?
07:53:27 <merijn> gentauro: I'm lazy, what's it doing? :p
07:54:12 <gentauro> merijn: it's the implementation of the Applicatives `<*>` operator for my `newtype Parser s a = Parser { parse :: s -> [ (a, s) ] }` :)
07:54:14 <merijn> cartesian product of functions and values?
07:54:42 <gentauro> merijn: at the moment, I have been able to refactor it with `case … of` (twice)
07:54:54 <gentauro> but I guess it could be done better?
07:55:22 <merijn> hmm
07:58:23 <gentauro> merijn: Remark: I'm avoiding the usage of `>>=`. Only `<$>` and `<*>` should be allowed :)
08:04:49 * hackage autoapply 0.4 - Template Haskell to automatically pass values to functions  https://hackage.haskell.org/package/autoapply-0.4 (jophish)
08:05:10 <gentauro> merijn: only with `concat ((\ (g, ys) -> (\(a, zs) -> (g a, zs)) <$> p2 j ys) <$> p1 n bs)` ... not pleasing to the eyes right?
08:05:22 <gentauro> s/only with/only with `<$>`/
08:05:56 <gentauro> s/`concat ((\ (g, ys) -> (\(a, zs) -> (g a, zs)) <$> p2 j ys) <$> p1 n bs)`/`concat ((\ (g, ys) -> (\(a, zs) -> (g a, zs)) <$> p2 ys) <$> p1 bs)`/
08:09:32 <ski> gentauro : it uses dynamic sequencing
08:11:23 <ski> (also .. `(Parser cs1) <*> (Parser cs2)' could just be `Parser cs1 <*> Parser cs2')
08:16:20 * hackage haskoin-core 0.13.1 - Bitcoin & Bitcoin Cash library for Haskell  https://hackage.haskell.org/package/haskoin-core-0.13.1 (jprupp)
08:18:23 <Uniaika> validation-selective looks so interesting omg
08:18:26 <gentauro> ski: like removing the parenthesis?
08:18:48 <ski> yes
08:19:24 * ski doesn't really understand why people insist on wrapping such patterns in brackets
08:20:20 <gentauro> ski: sometimes I write it like: `(<*>) (P p1) (P p2) = …` and then it's needed
08:20:22 <ski> (i've often also seen `case ... of [] -> ...; (x:xs) -> ..x..xs..'. i think sometimes even like `case ... of Nothing -> ...; (Just x) -> ..x..')
08:21:20 * hackage shortcut-links 0.5.1.0 - Link shortcuts for use in text markup  https://hackage.haskell.org/package/shortcut-links-0.5.1.0 (vrom911)
08:30:20 * hackage within 0.0.1.1 - A path within another path.  https://hackage.haskell.org/package/within-0.0.1.1 (locallycompact)
08:32:50 * hackage zipper-extra 0.1.0.1 - Zipper utils that weren't in Control.Comonad.Store.Zipper  https://hackage.haskell.org/package/zipper-extra-0.1.0.1 (locallycompact)
08:36:49 <c_wraith> ski: in function definitions you need to put them in parens.  Some people would rather use one consistent set of rules that works everywhere than remember when to use different sets.
08:38:10 <ski> but i guess those people still write `x + y * z' and (i hope) `n + length xs' (rather than `x + (y * z)' and `n + (length xs)')
08:38:39 <ski> the rule is that it's the same old precedence as usual ..
08:40:21 <dmwit> gentauro: There are completely mechanical rules outlined in the Report for eliminating list comprehensions.
08:40:38 <dmwit> So the answer to "can X be written without list comprehensions" is definitely "yes", provided X can be written at all.
08:41:23 <dmwit> gentauro: Anyway, you may like to look at (and/or implement yourself...) `concatMap`.
08:43:49 * hackage shake-plus 0.0.2.1 - Re-export of Shake using well-typed paths and ReaderT.  https://hackage.haskell.org/package/shake-plus-0.0.2.1 (locallycompact)
08:55:53 <asheshambasta> How does one write MINIMAL (funcA OR funcB) AND funcC?
08:58:32 <asheshambasta> I've tried ```
08:58:33 <asheshambasta>   {-# MINIMAL (performOn | (>-->)), enumActions #-} ``` but this issues warnings still
09:00:01 <Tuplanolla> Supposedly you minimize it to disjunctive normal form by hand, asheshambasta.
09:00:31 <dmwit> What is the warning?
09:01:06 <opqdonut> Tuplanolla: the manual says mindef ::= name |  '(' mindef ')' |  mindef '|' mindef |  mindef ',' mindef
09:01:14 <dmwit> That exact syntax works for me, provided I actually provide default declarations that match that claim.
09:01:16 <opqdonut> so asheshambasta's version should be legal
09:01:26 <Tuplanolla> Oh, that's nice.
09:01:56 <asheshambasta> ah, it was actually my bad: the warning was https://gist.github.com/asheshambasta/df38cbb2ada9d7732729e6da0a028f66 but performOn didn't have a default implementation in terms of (>-->)
09:02:26 <dmwit> ghc++
09:02:37 <dmwit> Caught a bug before it was a problem!
09:02:38 <dmwit> yay
09:03:33 <asheshambasta> how I re-read the warning is: your minimal pragma doesn't state performOn as a required (instead of an altrnative to (>-->)), but it has no default impl.
09:26:30 <tobiasBora> Hello, Is there any process that could let me kill an haskell program if it does not terminate in a given amount of time/memory? I'm asking because in my benchmarks haskells tends to freeze my system sometimes and then it's quite hard for me to kill the process as nothing responds anymore...
09:35:11 <Boarders_> @tobiasBora: what about this: https://hackage.haskell.org/package/base-4.14.0.0/docs/System-Timeout.html#v:timeout
09:35:11 <lambdabot> Unknown command, try @list
09:38:27 <maerwald> tobiasBora: use earlyoom
09:38:40 <maerwald> https://github.com/rfjakob/earlyoom/
09:38:45 <maerwald> must have when developing in haskell too
09:41:17 <tobiasBora> Boarders_: maerwald thanks a lot, I'll try and compare!
09:46:32 <Tuplanolla> How would you QuickCheck that a rational function is continuous? Writing the Weierstrass definition feels weird.
09:48:38 <solonarv> a rational function as in, a quotient of polynomials?
09:50:13 <Tuplanolla> Piecewise, it happens to be, but I really meant rational-valued.
09:52:37 <sm[m]> tobiasBora/maerwald: or ulimit/cgroups ?
09:59:33 <solonarv> ah hm. I guess if you have a finite number of potential discontinuities you can just check them one by one
09:59:57 <solonarv> I can't think of a good way to translate any of the usual definitions of continuity into quickcheck, unfortunately
10:00:09 <mniip> because that is not a decidable property?
10:01:18 <solonarv> well, quickcheck just tries 100 (or however many) random possibilities
10:01:34 <solonarv> so you are always at risk of false positives/negatives
10:02:05 <mniip> so we're looking for a continuity *test* with no false positives
10:02:06 <mniip> er
10:02:09 <mniip> false negatives rather
10:06:26 <mniip> I'm pretty sure for any sort of test that consults only finitely many points (even if parameterized by a seed from a countably infinite set)
10:06:31 <mniip> there's gonna be continuous functions that fail it
10:07:18 <mniip> but this is a fairly intricate analysis question
10:09:13 <Tuplanolla> Heuristic root finding algorithms exist and work well for many applications. Doing this shouldn't be too different.
10:09:55 <Tuplanolla> The goal is to rule out the dumbest discontinuities.
10:09:57 <monochrom> The difficulty is the "exists" quantifier.  You don't know what value to guess for it.
10:10:01 <mniip> you want no false negatives
10:10:13 <mniip> root finding is different
10:10:16 <monochrom> quickcheck was designed with forall in mind.
10:10:43 <solonarv> I guess you can use not . forall . not = exists
10:10:50 <solonarv> but this does not seem like it would work very well
10:11:31 <mniip> yeah and quickcheck checks whether a "forall" statement is definitely False by counterexample
10:12:00 <mniip> so it would check whether an "exists" = "not . forall . not" statement is definitely True by providing the guess
10:12:39 <mniip> but also consider the fact that you have a nested forall-exists-forall
10:12:43 <mniip> so you don't even have that
10:13:07 <monochrom> Yeah, possibly that's the real problem.
10:13:20 <solonarv> yeah, it's pretty terrible.
10:13:55 <monochrom> Suppose I have "f :: Bool -> Integer -> Bool", and I claim "forall b. exists i. f b i = 4".  How do you even begin?
10:13:55 <solonarv> you can certainly write down something that works under the assumption "quickcheck always finds the counterexample if it exists"
10:14:12 <monochrom> Err!  f b i = True
10:14:24 <Tuplanolla> Clearly the sane solution is to defunctionalize the functions, check that the piecewise boundaries match and only then turn them into proper functions.
10:14:26 <solonarv> but this is a rather far-fetches assumption
10:16:02 <solonarv> certainly not true when your not-foralls are really exists-not, because then there are probably not so many counterexamples
10:17:00 <ystael> it's a little easier than that because you can give part of a heuristic for finding the counterexample. a discontinuity of f is a point p where the oscillation of f at p is positive (limit as r -> 0 of sup f - inf f over (p-r..p+r)). so if you can compute maxima and minima of f over intervals, and you are willing to give bounds for the size of discontinuity you fail to detect, you can make an approximate 
10:17:06 <ystael> test
10:18:21 <monochrom> Skolemization could help. When applied to continuity, it means you can't test "is it continuous?", but you can provide extra information and test "is it continuous within epsilon=0.01?" for example.
10:18:38 <monochrom> which is what ystael just said :)
10:19:17 <aveltras> using TH, is it possible to concatenate a list of expressions ? with spaces or is type checking preventing this ? right now i have the following
10:19:34 <aveltras> https://www.irccloud.com/pastebin/oTWBRdBA/
10:20:07 <solonarv> "with spaces"? no, you are thinking at the wrong level for that.
10:20:13 <aveltras> with "[fromPathPiece arg0, (<*>), fromPathPiece arg1]" being a ListE, i'd like "BlogR <$> fromPathPiece arg0 <*> fromPathPiece arg1"
10:20:58 <solonarv> back up a bit. what is the type of 'decode' supposed to be?
10:21:20 <solonarv> also, what is 'fromPathPiece' (at least its type)
10:21:21 <aveltras> decode :: [Text] -> Maybe route
10:21:35 <aveltras> im trying to reimplement yesod routing th basically here
10:21:47 <mniip> % :t AppE
10:21:48 <yahb> mniip: *** Parser [source]:; !!! Parser [source]: finished in 0.11 milliseconds, allocated 0.019 megabytes; <interactive>:1:1: error: Data constructor not in scope: AppE
10:21:54 <aveltras> fromPathPiece :: Text -> Maybe s
10:22:06 <aveltras> s being route
10:22:09 <mniip> % :t AppE
10:22:10 <yahb> mniip: Exp -> Exp -> Exp
10:22:23 <ski> @hoogle exists
10:22:23 <lambdabot> Test.SmallCheck exists :: Testable m a => a -> Property m
10:22:23 <lambdabot> Database.Redis exists :: RedisCtx m f => ByteString -> m (f Bool)
10:22:23 <lambdabot> Database.Esqueleto exists :: SqlQuery () -> SqlExpr (Value Bool)
10:22:36 * solonarv is still confused
10:22:46 <mniip> you can do `foldr1 AppE`
10:22:57 <mniip> but that will not do operator precedence "correctly"
10:23:03 <mniip> or binary operators at all
10:23:24 <solonarv> you say you want to do something with TH, but I don't see any splices, or quasiquotes, or any types/functions from Language.Haskell.TH being mentioned
10:23:25 <mniip> but that is fine because presumably you're the one inserting the <*>'s?
10:23:42 <mniip> I see a mention of ListE
10:23:47 <monochrom> This is why I now teach students about tokenization when I teach programming language syntax topics.
10:24:03 <solonarv> yes, true, but not in the code sample provided.
10:24:23 <mniip> monochrom, heh, I recently wrote a compiler for a simple language in assembly, and even that had a tokenizer
10:24:26 <monochrom> Without knowing tokenization, people just assume that function application is space in Haskell.
10:25:16 <merijn> monochrom: "the space operator" wut?
10:25:22 <monochrom> which is silly actually, because here is a lot of function applications and no space:
10:25:33 <aveltras> right now, i have the following horrible thing if you wanna know the context
10:25:37 <monochrom> > zip[1,2,3]"abc"
10:25:38 <aveltras> https://www.irccloud.com/pastebin/FxZXEhvX/
10:25:39 <lambdabot>  [(1,'a'),(2,'b'),(3,'c')]
10:26:35 <monochrom> No, space has nothing to do with function application.  It is tokenization, and after that, juxtaposition of certain expressions that get parsed to function application.
10:26:36 <aveltras> the part im stuck on is the body function of decodeImpl
10:29:13 <monochrom> even this (I am half surprised and half anticipating):
10:29:21 <monochrom> > zip"abc""def"
10:29:24 <lambdabot>  [('a','d'),('b','e'),('c','f')]
10:31:41 <mniip> get rid of  foldr1 AppE . L.intersperse (<*>)
10:32:02 <mniip> replace with foldl1 (\x y -> (<*>) `AppE` x `AppE` y)
10:32:41 <mniip> I probably have code that looks exactly like this somewhere
10:36:05 <solonarv> mniip: that doesn't typecheck though
10:36:13 <solonarv> (<*>) does not have type Exp
10:36:22 <mniip> sure
10:36:32 <mniip> [|(<*>)|]
10:36:39 <mniip> now that's ExpQ
10:36:41 <solonarv> ah, now we're stuck in Q
10:36:44 <mniip> but that's fine cause you can use apPE
10:36:46 <mniip> appE
10:37:00 <solonarv> ...but then you can just write [| x <*> y |]
10:37:26 <solonarv> er, well, that's not as amenable to folding, but in this example no folding is required
10:37:48 <solonarv> since aveltras just wants to output a specific expression anyway
10:37:54 <mniip> there's a list of exps
10:38:09 <mniip> alternatively (VarE '(<*>))
10:38:12 <mniip> as was already in the code
10:38:19 <aveltras> maybe ive gone the wrong path here by constructing that list in the first place
10:38:27 <solonarv> the list of exps appears to be XY-problemed into existence, yes
10:40:32 <monochrom> TH sticks you inside Q already.
10:41:55 <monochrom> Err I guess that's not true.
10:42:39 <monochrom> But you have to clear your mind on whether you are calling (<*>) or you are generating code that contains (<*>).
10:43:00 <aveltras> that's definitly not clear atm :)
10:44:50 <monochrom> The blessing and curse of metaprogramming in which the meta language and the target language are "the same".
10:45:12 <monochrom> Using English to explain English and to instruct other people to write in English.
10:45:30 <mniip> yup found it https://gist.github.com/mniip/8995c78104dc648f327180d50d365ffc
10:45:53 <wavemode__> homoiconicity
10:46:22 <monochrom> What is this '(<*>) magic??!!!
10:46:26 * monochrom cringes
10:46:56 <mniip> it's just a really long character constant
10:46:57 <mniip> :P
10:47:54 <monochrom> It reminds me that in spreadsheets if you want to enter 123 as a string not as a number you write '123
10:49:16 * enthropy prefers  foldl (\e t -> [| $e <*> $t |] )
10:49:35 <enthropy> or I guess it's $(mkFld t)
10:49:37 <solonarv> enthropy: oh yes, that looks nice
10:49:40 <monochrom> Yeah I would do that on pragmatic days.
10:51:04 <monochrom> Ha ExpQ = Q Exp you are stuck in Q afterall.
10:52:30 <monochrom> Ah I forgot that '(<*>) is part of TH syntax.
10:53:05 <mniip> I hate nesting [||] and $()
10:53:19 <monochrom> What if you turn on both TemplateHaskell and DataKinds?!
10:54:10 <monochrom> Yes this is why only on pragmatic days. On elegant ideal days I would do it "properly". :)
10:54:37 <mniip> a th name will never appear in a type
10:54:41 <mniip> so we're safe
10:54:55 <solonarv> conversely, a promoted constructor will only ever appear in a type
10:55:12 <solonarv> so we really are safe (but we need to rely on the type/expression distinction to disambiguate)
10:55:13 <mniip> except when you want to do ''X in TH
10:55:22 <mniip> (do you do '''X for the promoted tc?)
10:55:34 <mniip> (no you don't, it's PromotedT)
10:58:41 <monochrom> On next April 1st, TH will use ‘ instead of ' to reduce confusion (yeah right). >:)
11:00:49 <shapr> «Template Haskell Here»
11:04:35 <monochrom> I have a feeling they prefer ⟦⟧
11:04:52 <dmwit> Tuplanolla: Easy, upgrade from rationals to computable reals.
11:04:57 <mniip> 「splice」
11:05:07 <shapr> ooh so pretty
11:05:08 <dmwit> Tuplanolla: All functions expressible in a programming language on computable reals are continuous.
11:05:13 <mniip> monochrom, nah that's banana brackets
11:05:31 <dmwit> Of course, making any observation about the result is kinda hard...
11:07:50 <aveltras> not sure i should have understood how from your previous input but i now have the following
11:07:55 <aveltras> https://www.irccloud.com/pastebin/HTE9GsAM/
11:08:14 <aveltras> is there a way to change the way parentheses are set ?
11:09:43 <monochrom> mniip: The thing is since they chose [| |] they must have ⟦⟧ in mind!
11:10:55 <mniip> aveltras, parentheses where
11:11:25 <aveltras> decode ("blog" : (arg0 : (arg1 : []))) = (BlogR <$> ((<*>) (fromPathPiece arg0)) (fromPathPiece arg1))
11:11:34 <aveltras> for the BlogR construction here
11:11:51 <mniip> you need to put BlogR into the zero case for foldl
11:11:54 <mniip> instead of using foldl1
11:13:36 <aveltras> but how will this apply (<$>) first since the folding function is (<*>) ?
11:13:48 <mniip> pure BlogR
11:14:09 <mniip> if you really want <$> here you need something more intricate
11:15:45 <aveltras> is there some other construction to accomplish this ? since basically here the thing is : BlogR <$> Maybe Int <*> Maybe String
11:16:10 <mniip> well
11:16:21 <mniip> on the haskell side that is the same as (pure BlogR <*> ... <*> ...)
11:16:40 <aveltras> oh ok i ll try your change then
11:16:46 <mniip> but if you insist
11:18:01 <mniip> f [] = AppE (VarE 'pure) (ConE 'BlogR); f (x:xs) = foldl (\a b -> AppE (AppE '(<*>)) a) b) (AppE (AppE (VarE '(<$>)) (ConE 'BlogR)) x) xs
11:18:13 <mniip> also sidenote, you can probably use InfixE here
11:32:02 <aveltras> mniip: got it working ! thanks for your help here
11:38:02 <tom__> Where are effects systems in the Gartner hype cycle?
11:44:20 * hackage shake-plus 0.0.2.2 - Re-export of Shake using well-typed paths and ReaderT.  https://hackage.haskell.org/package/shake-plus-0.0.2.2 (locallycompact)
11:44:22 <dmwit> I reject the implicit assumption that effects systems' trajectory matches the Gartner hype cycle in a reasonable way.
11:44:32 <dmwit> Anyway I doubt it's the actual question you care about in the first place.
11:47:27 <tom__> Ok it was a half joke
11:47:59 <tom__> I dont actually really understand the motivation behind using alternatives to monad transformers
11:49:00 <maerwald> tom__: because they kinda suck? :>
11:49:06 <maerwald> I mean they work
11:49:12 <maerwald> but it's not really declarative, nor elegant
11:49:31 <koz_> tom__: Not even behind, say, mtl?
11:50:59 <tom__> koz_: Correct :D
11:51:01 <maerwald> But, from what I've seen, effects systems leak implementation details even worse
11:51:02 <tom__> The shame
11:51:12 <tom__> I am in the stone age
11:51:46 <koz_> tom__: Try writing a library that requires some effect in a user-visible way.
11:51:53 <koz_> Transformers make it _very_ rigid.
11:52:20 <koz_> Like, you write something that gives back StateT s Identity a, and then someone needs to use it in a stack like ExceptT e (StateT s Identity) a.
11:52:30 <koz_> Oh look, they can't use your library, oh damn.
11:53:12 <koz_> (well, they can, but very awkwardly)
11:53:30 <koz_> (if they're in StateTs (Except e) a, then they're in a real problem)
11:54:18 <merijn> koz_: tbh, I think mtl is a lot uglier/less useful than transformers
11:54:43 <merijn> Also, if your code can *see* what stack you're using "you're doing it wrong"
11:55:42 <maerwald> transformers just don't compose
11:56:01 <maerwald> and mtl defers the problem of effect orders to the interpreter
11:56:19 <merijn> maerwald: I disagree that that's an issue :p
11:56:23 <merijn> (not composing)
11:56:24 <maerwald> so you're sometimes guessing what the code really does
11:56:43 <maerwald> with effects systems, you might be guessing even more
11:57:08 <maerwald> you have your abstract semantics maybe you can rely on
11:57:13 <maerwald> but not sure I'm cool with that
11:57:56 <maerwald> imagine copyFile is an effect... now there's no interpreter... someone else writes the interpreter and runs your code
11:58:50 <maerwald> MonadLogger for example is a reasonable use case for "dunno how it's interpreted yet"
11:58:59 <merijn> "Don't Do That Then" ;)
11:59:01 <maerwald> But what will people use this stuff for?
12:00:19 <maerwald> On the other hand, imagine streaming to be an abstract effect and you're not bound to conduit, streamly or whatever anymore, but can freely choose.
12:00:43 <maerwald> So libraries would stop imposing choices on you
12:01:06 <maerwald> or was that supposed to be solved by backpack?
12:01:09 <maerwald> I forgot
12:05:19 <monochrom> For mock testing it is super-important that "copyFile" may have a fake effect instead of real effect.
12:05:52 <merijn> monochrom: Solution: Don't do mocks! :D
12:06:02 <monochrom> Heresy!
12:06:18 <maerwald> monochrom: why?
12:06:25 <maerwald> I want to run the real code not half of it
12:06:43 <maerwald> I don't believe in mocking either
12:06:58 <maerwald> I do a lot of IO unit testing.
12:07:08 <monochrom> I guess this rationalizes "devop"?  You require a dev to go out of their way set up a sandboxing virtual machine to test effects, ergo sysop.
12:07:20 <maerwald> I get paid better then, yes
12:07:23 <maerwald> :D
12:08:10 <merijn> monochrom: Well, what's the purpose of, say, mocking copyFile? You wouldn't be testing copyFile, you'd be testing "some mock of copyFile"
12:08:38 <monochrom> copyFile is an example that benefits less from mock testing.
12:09:11 <maerwald> if you need mocking, I'd argue the boundaries of your functions are already poorly chosen
12:09:12 <merijn> I mean the usual argument is "I can test this code in isolation of my other code" to which I say: Sounds like not mocking doubles my tests! :p
12:09:20 <monochrom> However, many EDSLs benefit a lot from alternative-interpretation mock testing.  Maybe most.  Maybe even all.
12:09:34 <maerwald> maybe
12:09:55 <maerwald> that was one of the major use cases of effects systems anyway
12:10:02 <monochrom> Err no no no, I have mixed up two levels.
12:10:30 <monochrom> I am not mock-testing copyFile itself.  I am mock-testing an algorithm that calls copyFile several times.
12:11:06 <tom__> Has anyone hit their head against n^2 instances problem MTL supposedly has?
12:11:10 <merijn> monochrom: If copyFile is broken you'd still like to know that :p
12:11:31 <monochrom> Carrying this to all EDSLs, I am not mock-testing the EDSL, I am mock-testing my algorithm which happens to be written using the EDSL.
12:11:31 <merijn> tom__: No, just newtype you're stack and don't expose the mtl classes at all, problem solved :p
12:11:54 <monochrom> Oh I have no quarrel with testing the real copyFile itself.
12:12:31 <monochrom> But look at all the newbie questions here that reflects that the newbie blames it on what they call when the real error is PEBKAC.
12:12:41 <monochrom> mock testing is for PEBKAC
12:13:58 <monochrom> If my algorithm (which calls the real copyFile several times) seems to break, is it my algorithm or is it copyFile?  You need some kind of disintegration to collect scientific evidence.
12:14:30 <maerwald> monochrom: nah
12:14:35 <maerwald> I don't believe this
12:14:47 <maerwald> your code can always break in different ways in a single function and you are off to debugging
12:15:02 <monochrom> The alternative is acting like a childish newbie and going to #copyFile and pointing fingers.
12:15:12 <maerwald> Exponentially increasing testing complexity just so you save a little debugging time...
12:15:55 <maerwald> the solution is to write tests for copyFile, not MOCK copyFile :P
12:18:08 <maerwald> It'll be interesting when copyFile throws different errors on different platforms though... oh wait: https://git.io/JfZjS
12:19:45 <maerwald> I wish people would test their IO exceptions more consistently. I don't trust just documentation.
12:20:59 <monochrom> Mock testing can help with this!  Have one interpreter throwing one error, another interpreter throwing another...  Now ghcup can be tested on both without booting two OSes...  OK this is cheesy, I know, I'll stop.
12:21:19 <maerwald> monochrom: I'm already booting all OSes to build releases :P
12:22:02 <day> how do i fix this  typeclass? http://dpaste.com/3P1QVH5.txt
12:22:22 <monochrom> Yes, often I try to reproduce the claimed IO exceptions.  Some authors really believe that docs should be kept outdated and wrong.
12:22:31 <maerwald> I've yet to see a more declarative approach to heavy IO-based unit tests... e.g. pre and post conditions (existence of files, their filemode, maybe what errors are allowed etc)
12:22:36 <day> im not really understanding the error im getting with it. *Couldn't match expected type ‘t0 a0’ with actual type ‘a’*
12:22:51 <wavemode> day: x is of type a, not [a]. you can't call length on it
12:22:52 <monochrom> Yeah it's a mess.
12:23:32 <wavemode> day: (x:xs) means you're taking x to be the first element of the list and xs is the rest of the list
12:23:46 <day> ah. length has [a]
12:24:14 <day> welp. is this still fixable with a restriction somehow?
12:24:37 <day> ala (Eq a) => [a] -> [a]
12:24:37 <wavemode> what is the function supposed to do?
12:24:52 <day> removing 'length 0' elements from the list
12:25:32 <day> ["asdf","","jkl"] -> ["asdf","jkl"]
12:26:38 <monochrom> What's wrong with your original [String]->[String]?
12:26:53 <day> but i also want to use it on lists of lists, which is why i dont want [String] -> [String]
12:27:12 <day> e.g. [["asdf","","jkl"],[]]
12:27:12 <monochrom> "lists of lists" means [[a]] not [a]
12:27:28 <wavemode> day: length operates on Foldable types, so your signature should really be `rmEmpty :: Foldable t => [t a] -> [t a]`
12:27:35 <day> i thought a could be a list as well :|
12:27:51 <merijn> monochrom: I think we should just get rid of unchecked exceptions entirely, so I'll get right on that, as soon as someone is willing to pay for me to work on proper checked exceptions in Haskell :p
12:28:09 <monochrom> That logic would lead to a->a, even a->b.  Therefore that logic is absurd.
12:28:54 <monochrom> "Have you finished your thesis?" >:)
12:29:18 <monochrom> (I have had someone stabbing that to me.  Now I have the honour of paying it forward!)
12:30:03 <monochrom> Finish your thesis!  So that you can join the club of telling other people to finish their theses!
12:30:04 <day> wavemode: nice that works \o/ i knew it was possible 
12:30:21 <merijn> monochrom: Finishing my thesis won't get someone to pay me to work on checked exceptions in Haskell! :p
12:30:45 <day> wavemode: now that you gave it to me i noticed that :type length already gave me that answer :|
12:30:58 <wavemode> it often does :)
12:31:13 <koz_> Following the types gets you surprisingly far.
12:31:53 <monochrom> You should use null.  For most types, length is stupid for what null can do.
12:33:25 <day> nice that removes some code
12:35:54 <wavemode> if you want to get real fancy, you could just do `rmEmpty = filter (not . null)`
12:36:24 <oats> :t null
12:36:25 <lambdabot> Foldable t => t a -> Bool
12:36:29 <oats> ah foldable, nice
12:38:02 <day> although why cant the typeclass be (Foldable a) => [a] -> [a]
12:38:20 <koz_> If I have a record type Foo with fields bar and baz, if I export it like (Foo, bar, baz), does this allow modification of Foo via bar and baz, or only lookups?
12:38:44 <iqubic> koz_: Unfortunately that also allows modification
12:38:50 <oats> https://hackage.haskell.org/package/base-4.14.0.0/docs/Data-Foldable.html
12:38:55 <oats> sweet, newest docs use the pretty theme
12:38:55 <koz_> iqubic: Argh.
12:39:00 <koz_> Welp, optics it is!
12:39:58 <monochrom> merijn: I think, if any thing, it is getting paid to convince people to agree to checked exceptions in Haskell, and agree to a standard. The reason is that solutions are already lying around, hell many of them are, the problem is people just don't adopt any and don't do anything.
12:40:33 <monochrom> People are the root cause of people's problems.
12:41:56 <dmwit> koz_: ...how do optics help?
12:42:01 <monochrom> day: Foldable is not defined that way.
12:42:45 <monochrom> Start with: Look at how length is not (Foldable a) => a -> Int
12:43:11 <monochrom> and not either (Foldable (t a)) => t a -> Int
12:43:13 <day> given the context i see that i cant do it
12:43:31 <day> i was just curious why it isnt defined this way
12:44:02 <merijn> monochrom: I'm not away of any solutions. "ExceptT" and "Either" are not solutions
12:44:03 <day> but i think i need to spend more time learning all the typeclass syntax
12:44:44 <monochrom> It generalizes from [] Foo, Maybe Foo, Set Foo, etc., to t Foo.
12:44:53 <dmwit> day: Foldable is a constraint that applies to containers, not to types. For example, [] is Foldable, Maybe is Foldable, Proxy is Foldable; but [Int] is not Foldable, Maybe Char is not Foldable, Proxy (Bool, String) is not Foldable.
12:44:59 <merijn> monochrom: "div 5 0" throws an exception and I'm not willing to accept "div :: Int -> Int -> Maybe Int", nor am I willing to except no way to track that div can throw
12:45:16 <merijn> monochrom: And I'm pretty sure it can be done
12:45:43 <monochrom> merijn: Enjoy a millioleg of olegness :)  https://mail.haskell.org/pipermail/haskell/2004-June/014271.html
12:46:08 <merijn> monochrom: I'm also not willing to accept such madness
12:46:12 <koz_> dmwit: Derp, early morning.
12:46:18 <dmwit> day: This is nice for a couple reasons. One is that if I know Foldable f, I know f is a container that can contain elements of any type. Another is that it gives me a handle for referring to the element types; e.g. in `head :: Foldable f => f a -> a`, having a separate name for the container (`f`) and the element type (`a`) lets me refer to elements in the return type.
12:46:27 <koz_> Just gonna write some accessor functions.
12:46:50 <dmwit> day: Imagine trying to write that if `Foldable` was a constraint that only applied to actual types in the way you're proposing! You couldn't any more.
12:46:55 <merijn> monochrom: A few years ago I wrote a position paper to a PL workshop that argues that the main problem with approach to do everything in the type system in Haskell is the madness of only having one type system
12:47:37 <merijn> monochrom: Why do we not have "functional" (what type of values does this take/return) signatures that are separate and (at least partially) independent of, for example, which exceptions can be thrown?
12:47:57 <merijn> Sure, you need to do some work to specify how such things interact, but I think there's a lot to gain there
12:48:17 <monochrom> I think maerwald agrees.
12:48:26 <monochrom> Me, I don't mind either way.
12:49:08 <monochrom> Mainly because I don't count the number of axioms or the number of systems carefully.
12:50:31 <monochrom> No, I think I am leaning more to your side!
12:51:02 <monochrom> I am one of those few who shout "don't shoehorn dependent types into haskell types and make a mess of an encoding".
12:51:59 <monochrom> likewise I'm more likely to support "don't shoehorn exception types into haskell types".
12:52:19 <monochrom> "and make a mess of an encoding".
12:52:22 <monochrom> I hate encodings.
12:52:28 <dmwit> day: It might also be interesting to ask about a similar question at the computation level rather than the type level. Suppose I write `doItTwice f x = f (f x)`.
12:52:36 <monochrom> Encodings means you have lost.
12:53:14 <dmwit> day: For example, `doItTwice (\y -> 3 + y)` adds six to a number; `doItTwice (2*)` multiplies a number by 4; `doItTwice ("hello "++)` makes an even more enthusiastic greeting function.
12:53:20 * hackage record-dot-preprocessor 0.2.5 - Preprocessor to allow record.field syntax  https://hackage.haskell.org/package/record-dot-preprocessor-0.2.5 (NeilMitchell)
12:53:46 <merijn> monochrom: I'd like to just write a separate "div :: Int -> Int -> Int" and "div :: s -> t -> {s U t U DivByZero}" or something along those lines
12:53:46 <dmwit> day: Then the analog of your question is, like: why do I always have to pass `doItTwice` a thing that's a function? Why can't I call, like, `doItTwice 6`?
12:53:59 <dmwit> day: And the answer is: well... because how do you do `6` twice?
12:54:33 <merijn> monochrom: In most cases you can just infer the exceptions and in specific cases where you care you could explicitly annotate what it does/does not throw and get it enforced in the type system
12:55:02 <dmwit> day: A similar answer applies at the type level. `Foldable` applies to types of kind `Type -> Type`, not to types of kind `Type`. Trying to construct `Foldable Int`, say, as a constraint just doesn't make very much sense, because `Int` is not a container.
12:56:51 <day> i see... a little :)
12:56:58 <oats> https://hackage.haskell.org/package/base-4.14.0.0/docs/src/Data.Foldable.html#Foldable
12:57:17 <monochrom> day, it will take a while.
12:57:34 <monochrom> This is something most people haven't thought of.
12:57:36 <oats> looking at the definition of Foldable, it applies a type 'm' to whatever type you're trying to make Foldable 't'
12:57:44 <day> i always end up just writing code. but it doesnt really work with haskell :<
12:57:53 <oats> so you can't make a Foldable instance of a type, that you can't then apply another type to
12:58:18 <day> i mean my programs run, but im only using/ understanding a small fraction of the haskell universe
12:58:20 <oats> it has to be a type that accepts another type to give you a "fully resolved type"
12:58:27 <monochrom> By the late 20th century, most people have accepted that you can generalize from LinkedList<Int> to LinkedList<a> for arbitrary a.
12:59:04 <monochrom> But they haven't realize that how about from LinkedList<Int> to f<Int> for arbitrary f.
12:59:24 <oats> mmmmm, <> syntax
12:59:28 <oats> too bad haskell doesn't have that
12:59:30 <merijn> monochrom: Crazy!
12:59:33 <oats> we should use it for functions too
12:59:44 <monochrom> Once you accept that there is nothing wrong with that, you'll be OK.  But it takes forever to accept that.
13:09:50 <day> if cabal installs fail with 'build fails' can i assume it's on my side or is this a frequent issue?
13:10:13 <day> in this case it's 'cabal install encoding'
13:10:15 <monochrom> It is more likely on your side, bayesianly.
13:10:48 <maerwald> encoding is a difficult package
13:10:59 <maerwald> takes long time to compile and has been updated recently afair
13:11:24 <day> well it is quite fast in my case :p
13:12:51 <day> is there another easy way to encode a string in cp850?
13:13:14 <rain1> is there a function to factor a number into primes
13:13:51 <maerwald> day: why does the build fail?
13:14:35 <day> well mostly it seems to be 'Overlapping instances for ....' cases
13:15:16 <day> http://dpaste.com/1JNNS71
13:16:26 <monochrom> rain1: arithmoi may help
13:20:30 <maerwald> day: which ghc version
13:20:48 <day> 8.6.5
13:21:06 <day> ah now that you mention it. i didnt install it through the packagemanager so it's not updating
13:22:45 <maerwald> I can't build it with 8.8.3 anyway
13:23:00 <day> good ^_^
13:24:49 * hackage shakebook 0.2.2.0 - Shake-based technical documentation generator; HTML & PDF  https://hackage.haskell.org/package/shakebook-0.2.2.0 (locallycompact)
13:25:17 <day> i think i installed it via ghcup. can i simply rerun the script to update?
13:25:43 <maerwald> day: what do you want to do?
13:26:01 <day> just update my ghc environment
13:26:22 <maerwald> to which version
13:26:28 <maerwald> run: ghcup list
13:26:33 <day> w/e they have. mine is a year old 
13:26:38 <day> can only get better
13:26:58 <maerwald> ghcup install recommended && ghcup set recommended
13:28:09 <day> i just ran the curl command from haskell.org now. 8.8.3 it is~
13:29:10 <merijn> I'm still mostly using 8.6.5, so :p
13:29:45 <maerwald> day: you don't need that
13:30:44 <day> is there any downside to it? didnt exactly take long and it seems to run fine
13:31:14 <maerwald> day: no downside, just not how it's meant to be used. 'ghcup' is its own binary
13:31:32 <day> encoding still doesnt compile as expected, but at least the build process looks much cleaner now
13:31:50 <maerwald> build for me with 8.6.5
13:32:03 <maerwald> and took 12 minutes
13:32:47 <day> i think i will just make a lookup table, it's just 256 values anyways and i only need the encoding
13:34:30 <jacks2> what is sortOn equivalent of this?
13:34:57 <ChaiTRex> @src sortOn
13:34:57 <lambdabot> Source not found. Do you think like you type?
13:35:07 <ChaiTRex> @src Data.List.sortOn
13:35:07 <lambdabot> Source not found. You untyped fool!
13:35:10 <jacks2> > sortBy (comparing length <> comparing (map toLower)) (words "aa AA b B ccc CCC")
13:35:12 <lambdabot>  ["b","B","aa","AA","ccc","CCC"]
13:35:25 <jacks2> :t sortOn
13:35:28 <lambdabot> Ord b => (a -> b) -> [a] -> [a]
13:35:35 <jacks2> :t sortBy
13:35:36 <lambdabot> (a -> a -> Ordering) -> [a] -> [a]
13:36:49 <jacks2> > sortOn (\x -> (length x, map toLower x)) (words "aa AA b B ccc CCC")
13:36:50 <ChaiTRex> Did someone really need to make literally all code in the source code view in Hackage into hyperlinks so that I can't copy the text on my mobile device anymore?
13:36:51 <lambdabot>  ["b","B","aa","AA","ccc","CCC"]
13:37:26 <jacks2> > sortOn (length &&& map toLower) (words "aa AA b B ccc CCC")
13:37:28 <lambdabot>  ["b","B","aa","AA","ccc","CCC"]
13:44:45 <jacks2> I didn't know about sortOn until today, it seems more concise for many common idioms
13:46:20 * hackage plzwrk 0.0.0.4 - A front-end framework  https://hackage.haskell.org/package/plzwrk-0.0.0.4 (mikesol)
13:47:36 <oats> :t (length &&& map toLower)
13:47:37 <lambdabot> [Char] -> (Int, [Char])
13:47:55 <oats> :t comparing length <> comparing (map toLower)
13:47:57 <lambdabot> [Char] -> [Char] -> Ordering
13:48:02 <oats> huh
13:49:01 <oats> Is that using the 'Semigroup b => Semigroup (a -> b)' instance?
13:50:03 <[exa]> very likely
13:50:16 <[exa]> :t comparing length
13:50:17 <lambdabot> Foldable t => t a -> t a -> Ordering
13:51:08 <[exa]> even 2 different versions of that instance :]
13:51:28 <jacks2> oats, yes
13:52:34 <[exa]> > let rot = drop <> take
13:52:37 <lambdabot>  <no location info>: error:
13:52:37 <lambdabot>      not an expression: ‘let rot = drop <> take’
13:52:53 <[exa]> oh noes
13:53:17 <[exa]> > let rot=drop<>take in rot 2 "hello
13:53:20 <lambdabot>  <hint>:1:35: error:
13:53:20 <lambdabot>      lexical error in string/character literal at end of input
13:54:00 <jacks2> > (drop 2 <> take 2) [1..5]
13:54:03 <lambdabot>  [3,4,5,1,2]
13:54:08 <[exa]> ok I feel bad now for not being able to finish the line :]
14:14:04 <eyenx[m]> .
14:20:24 <gentauro> how should I combine `sepBy` and `get` in order to `chunk` my input stream? (https://hackage.haskell.org/package/base-4.14.0.0/docs/Text-ParserCombinators-ReadP.html#v:sepBy and https://hackage.haskell.org/package/base-4.14.0.0/docs/Text-ParserCombinators-ReadP.html#v:get)
14:21:12 <gentauro> example: "4142032094823094|832098409218401|823409128409814C30982094|82094821093841092841083" I want to split by `|` (Remark: I write numbers for better readability, but it can be any `char`)
14:21:59 <gentauro> expected result:  ["4142032094823094", "832098409218401", "823409128409814C30982094", "82094821093841092841083"]
14:23:37 <gentauro> my guess is that `get` will always consume the entire stream ("Consumes and returns the next character. Fails if there is no input left.")
14:24:36 <solonarv> why is that your guess? it says that it only consumes one character.
14:24:40 <[exa]> gentauro: perhaps something like ` munch (/= '|') ` ?
14:25:23 <solonarv> yeah, 'munch' looks like what you want
14:26:25 <gentauro> solonarv: you are right, I'm already using `many get` ...
14:27:38 <gentauro> [exa]: but it looks like `munch` is the way to go
14:27:38 <gentauro> thx
14:31:14 <gentauro> or maybe not, `munch` signature is `munch :: (Char -> Bool) -> ReadP String`, I'm guessing that `chunked` strings should be: `? :: (Char -> Bool) -> ReadP [String]`
14:31:55 <gentauro> maybe combining with some `sequenceA`
14:32:04 <[exa]> gentauro: combine that with sepBy :]
14:32:50 <[exa]> the separator parser is ` char '|' `
14:34:02 <[exa]> and you may want to use `sepBy` infix between these two, it will read better. :]
14:38:29 <[exa]> gentauro: btw, if you don't necessarily need ReadP, you might want to look at Data.List.split
14:38:38 <gentauro> [exa]: that worked !!! `readP_to_S ((munch (/= '|') `sepBy` (char '|') )) "123|2|12312"` => [(["123","2","12312"],"")]
14:39:38 <[exa]> o nice
14:40:07 <gentauro> [exa]: I never heard of `munch` before. I guess I learned something new today :)
14:43:12 <fog> so
14:43:34 <fog> why are polymorphic kinds not supported in the kinds of parameters to gadts?
14:43:58 <[exa]> gentauro: parser combinators usually have a lot of useful functions in manual, suggest just skimming the list to see if there's something more useful
14:44:06 <fog> i can have a type level list as a parameter and cons to it no problem
14:44:32 <fog> but if i have a phantom length parametrised version of list, it does not work!
14:44:50 <fog> consing to it changes its length, and so changes the *kind* 
14:44:55 <fog> of the parameter to the gadt
14:45:01 <fog> which breaks it completely
14:45:16 <[exa]> fog: may we have a bit of code sample for that?
14:45:29 <fog> exa: could be quite long...
14:45:41 <fog> ill try
14:46:30 <[exa]> anyway by "it doesn't work", what exactly is the compiler complaining about?
14:46:46 <gentauro> [exa]: I tend to read the docs at `Hackage` (normally searched via `Hoogle`) but sometimes it's still not clear ;) (that's why #haskell is pretty cool) 
14:48:57 <fog> exa: well, if one GADT constructor, eg, of something like an empty case for the gadt, has a corresponding empty list of types for the phantom parameter to the GADT
14:49:19 <fog> and if the other GADT constructor would try and return that this parameter be of a different length
14:49:27 <fog> it complains that they are not the same length
14:49:37 <fog> it says it cant do a type equality between them
14:49:45 <[exa]> uuuuuuh so
14:50:50 <[exa]> well afaik it needs to construct the actual datatype description, which may get complicated this way
14:51:52 <fog> here is the paste; https://pastebin.com/w5R7k2Hf
14:52:12 <fog> https://pastebin.com/raw/w5R7k2Hf
14:53:49 <fog> sorry, this is better; https://pastebin.com/raw/LrUC3XDY
14:56:56 <[exa]> fog: just to be sure, the Columns should be "square" or "diagonal" ?
14:57:16 <fog> its recording the length of each column so the can be different lengths
14:58:00 <fog> same error slightly shorter; https://pastebin.com/raw/0Z2qV713
14:59:44 <fog> i guess i could just use a list...
15:00:07 <fog> since I can take the length anyway
15:00:55 <fog> but, this means that other kinds of accumulated data recorded in phantom types by construction could be limited
15:01:32 <fog> i was starting to build algorithms into the constructors this way, and it was much less complex than trying to do it "backwards" on deconstruction
15:02:02 <fog> i can record changing types, like incramenting Nats
15:02:11 <fog> but not change the actual kinds
15:02:50 <fog> like, the nat param recording the length of the list of types
15:03:33 <fog> i can cons to a type level list, because it still has the same kind; [k]
15:04:11 <fog> but with this example, cons changes the kind from `List k a` to `List (Succ k) a`
15:04:36 <fog> and the GADT seems to want to have the kind of its type parameters fixed
15:05:00 <fog> which kind of seems reasonable...
15:05:13 <fog> but I was wondering if there was a workaround with data families or something
15:06:00 <fog> normally this is where I would use classes, when doing tail recursion, requiring the class constraint on the tail aswell
15:06:12 <fog> allowing type families to get round a similar difficulty
15:06:17 <[exa]> hm, this should work perfectly in fact
15:06:40 <fog> but I cant put my GADT data constructors in classes!
15:07:05 <fog> can I?
15:07:15 <[exa]> no, I mean the whole example
15:07:27 <[exa]> not only with classes :]
15:07:56 <fog> im not sure how..
15:08:11 <fog> its very much not working...
15:08:58 <fog> "associated data families" ?
15:09:12 <dsal> `{-# LANGUAGE * #-}`
15:11:40 <monochrom> Be careful with that.  Don't get people's hope up.  Soon enough they would be also expecting {-# LANGUAGE * but not TypeApplications, IncoherentInstances #-}
15:12:55 <[exa]> fog: ok getting to the problem, the same in fact happens with EmptyColumns
15:13:43 <MarcelineVQ> tbf that's nearly a thing anyway    {-# optionsghc  -X*  -XNoTypeApplications -XNoIncoherentInstances #-}
15:14:47 <fog> right, the constructors return different lengthed lists of types, which as these lists have a lengh type parameter, ends up changing at kind level 
15:16:28 <ddellacosta>  uk
15:16:53 <raehik> Hi, Megaparsec question. Using provided Char lexers for consuming spaces, but it's not forcing spaces *between* tokens so eg. "tokentoken" might as [Token, Token] instead of failing
15:17:19 <raehik> how can I write my parsers to allow "token token", "token     token" but not "tokentoken"
15:19:09 <fog> omg, does that actually work!? https://pastebin.com/raw/JTA0v2Qz
15:19:26 <fog> it compiles!
15:19:32 <[exa]> fog: yeah that should work
15:19:39 <fog> epic!
15:20:06 <fog> now im going to just use a regular list for the parameter, because this seems mad
15:20:25 <[exa]> still kindof puzzled about the GADT thing, it should in fact work very roughly the same way
15:20:27 <TheCPPanda> Hey guys can anyone explain to me how Data.Function "on" function works ? I've often seen it used in conjunction with sortBy but i can't really wrap my head around what it exactly does
15:20:29 <fog> nice new technique though! (new to me at least)
15:21:14 <fog> exa: yeah, i always get confused about when type families similarly require being made associated for recursive things
15:21:23 <shachaf> TheCPPanda: It isn't a magic function. You can look at the definition and substitute it in to see what it does.
15:21:48 <[exa]> fog: it's getting late->early here so I need to AFK but I'll check tomorrow to see if the lists will work, it's certainly extra cool
15:22:00 <fog> :D
15:23:03 <koz_> > 12 `divMod` 10
15:23:06 <lambdabot>  (1,2)
15:25:11 <TheCPPanda> Just as a reminder how infix operators work:
15:26:20 <TheCPPanda> Using something like compare `on` length would partially apply the two functions right  ?
15:28:59 <monochrom> compare `on` length = on compare length
15:29:10 <monochrom> (I don't understand the question.)
15:29:29 <monochrom> on compare length x y z = (compare `on` length) x y z
15:30:03 <monochrom> A formula is worth a thousand pictures.
15:30:14 <TheCPPanda> Yeah thats what i mean compare `on` length = on compare length
15:30:46 <MarcelineVQ> best to refer to the definition of  on
15:34:06 <monochrom> although I think that the issue is more on the semantics behind the make-shift infix syntax.
15:34:40 <dsal> @src on
15:34:40 <lambdabot> (*) `on` f = \x y -> f x * f y
15:34:50 * hackage haskoin-node 0.12.0 - Haskoin Node P2P library for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-node-0.12.0 (jprupp)
15:35:31 <TheCPPanda> So if i understand it right (compare `on` length) [0..3] [0..5] = compare (length [0..3]) (length [0..5])
15:36:08 <monochrom> I think yes.
15:36:16 <monochrom> But you can test it :)
15:36:43 <TheCPPanda> > (compare `on` length) [0..3] [0..5] == compare (length [0..3]) (length [0..5])
15:36:43 <dsal> > (compare `on` f) [0..3] [0..5]
15:36:45 <lambdabot>  True
15:36:45 <lambdabot>  error:
15:36:45 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘compare’
15:36:45 <lambdabot>        prevents the constraint ‘(Ord a0)’ from being solved.
15:37:21 <TheCPPanda> I sometimes forget that i'm able to compare such expression in haskell ^^
15:37:29 <dsal> == is misleading there, though.
15:37:54 <TheCPPanda> Since it compares the result rather than the functions ?
15:37:58 <dsal> Yeh.
15:38:03 * dsal has a broken a key
15:38:10 <monochrom> Even without doing ==, you could test the two expressions separately and observe a lot.
15:39:13 <dsal> @check \x y ->  (compare `on` length) x y == compare (length x) (length y)
15:39:15 <lambdabot>  +++ OK, passed 100 tests.
15:39:24 <dsal> That's basically a formal proof.
15:39:54 <MarcelineVQ> We might use a different formal definition of basically :>
15:39:58 <monochrom> @type \x y ->  (compare `on` length) x y == compare (length x) (length y)
15:39:59 <lambdabot> Foldable t => t a -> t a -> Bool
15:40:14 <monochrom> what do you think what @check has chosen for t and for a? >:)
15:40:41 <dsal> [] and () ?
15:40:45 <monochrom> OK perhaps nothing to worry about a.
15:40:48 <TheCPPanda> Some that derives from Ord i suppose ?
15:42:36 <dsal> () has weird instances.  I was just thinking it's strange to have Ord, but I rely on that in some code.  Enum seems weird, though.
15:42:59 <dsal> Though, it's a bounded enum.
15:43:07 <dsal> > [minValue .. ] :: [[]]
15:43:10 <lambdabot>  error:
15:43:10 <lambdabot>      • Expecting one more argument to ‘[]’
15:43:10 <lambdabot>        Expected a type, but ‘[]’ has kind ‘* -> *’
15:43:17 <dsal> > [minValue .. ] :: [()]
15:43:20 <lambdabot>  error: Variable not in scope: minValue :: ()
15:43:25 <dsal> This computer won't make it...
15:43:29 <monochrom> Is it also Ix?  So that I can use it for a singleton array type?  >:)
15:43:32 <dsal> Wait, what?
15:43:39 <jacks2> > [minBound..] :: [()]
15:43:41 <lambdabot>  [()]
15:43:50 <dsal> Oh, I was close.  heh
15:44:17 <dsal> instance Ix () -- Defined in ‘GHC.Arr’
15:44:22 <monochrom> \∩/
15:44:53 <dsal> It seems dumb until that one time where it's useful.
15:46:25 <monochrom> I support Enum () for the same reason I support "let in 4".  Though these are degenerate cases, they harm no one, and they make the math complete.
15:46:57 <dsal> I refuse to let 4 in.
15:47:02 <maerwald> oh man
15:47:09 <maerwald> can you stop this sorcery
15:47:16 <ChaiTRex> let in 4 is a sign the programmer made a mistake.
15:47:47 <maerwald> see, what did strong types give us when the syntax is broken?!
15:47:47 <dsal> I needed Ord () because I'm using a caching library that wants me to make keys for my cache, but I've only got one thing I need to cache.
15:48:32 <monochrom> Note that "harm no one" is important too.  For example, I do opine that "instance Foldable ((,) a)" is bordering on being a trap, despite how it makes the math complete.
15:49:28 <monochrom> No, let in 4 is a sign that someone has a metaprogramming system that generates Haskell code.
15:49:46 <maerwald> this isn't ruby man
15:50:06 <monochrom> The metaprogramming system takes an input of length n, n>=0, and outputs Haskell code with n definitions between "let" and "in".
15:50:10 <dsal> > foldr (+) 0 (1,2)
15:50:12 <lambdabot>  2
15:50:55 <monochrom> If you insist them to do things non-uniforming between n=0 and n>0 just because you are ideologically opposed to "let {} in", you are a mean person.
15:51:24 <monochrom> s/non-uniforming/non-uniformly/   # I am hungry, therefore I have typos
15:51:42 <maerwald> this shall not be forgiven
15:52:20 <maerwald> dsal: yeah, that foldable instance is really... questionable
15:52:24 <monochrom> And your ideology BS.
15:52:26 <maerwald> but it follows the functor one I guess
15:53:10 <dsal> > foldrOf each (+) 0 (1,2)
15:53:12 <lambdabot>  3
15:57:02 <monochrom> Count your blessing that ((,,) a b) is not made Foldable :)
15:57:14 <monochrom> > length ('x', False, 3)
15:57:16 <lambdabot>  error:
15:57:16 <lambdabot>      • No instance for (Foldable ((,,) Char Bool))
15:57:16 <lambdabot>          arising from a use of ‘length’
15:57:19 <maerwald> > foldr (+) 0 . biList $ (1,2)
15:57:21 <lambdabot>  error:
15:57:22 <lambdabot>      • Variable not in scope: biList :: (Integer, Integer) -> [c]
15:57:22 <lambdabot>      • Perhaps you meant one of these:
16:00:25 <dsal> > lengthOf each (1,2)
16:00:30 <lambdabot>  2
16:00:31 <dsal> This stuff looks weird in isolation.
16:01:53 <dsal> Oh, I just realized what that length thing was...
16:02:01 <dsal> > length ("obviously", "two")
16:02:04 <lambdabot>  1
16:02:46 <maerwald> I call this a naming issue.
16:02:51 <monochrom> :)
16:03:01 <monochrom> What would you rename it to?
16:03:15 <dsal> One of things that gives an obvious answer and you totally know why it should give that answer, but coming from the other direction, it can be quite confusing.
16:03:16 <maerwald> lengthThatMakesOnlySenseSometimes
16:03:20 <dsal> hahaha
16:03:37 <maerwald> there's only so much you can "encode" in a name
16:03:58 <monochrom> Are you OK with this other stance? The name "length" is fine, but get rid of Foldable ((,) a).
16:03:59 <dsal> Like, what's the length of a string?
16:04:07 <maerwald> Alternatives are Java or going full CT where no one knows what anything is
16:04:41 <maerwald> yes, let's purge ungodly instances
16:04:47 <maerwald> need to be cleansed
16:05:25 <dsal> So why is that tuple instance foldable?
16:05:45 <maerwald> Because you can write a lawful instance
16:06:04 <dsal> Ah.  We should do everything we can.
16:06:19 <maerwald> > fmap (+1) (1,2)
16:06:21 <lambdabot>  (1,3)
16:06:38 <maerwald> and there's no other way to write it
16:06:42 <dsal> That's functor, though.  That somewhat makes sense.
16:07:09 <maerwald> yeah, somewhat. And I'm thinking someone thought... if functor makes somewhat sense, then based on that somewhat sense, Foldable makes somewhat sense
16:07:27 <maerwald> So it turned into lesswhat
16:07:35 <maerwald> somewhat.
16:15:28 <jacks2> what's the closest to M.mapM :: (a -> b -> IO ()) -> Map a b -> IO () that we have?
16:15:45 <jacks2> @hoogle (a -> b -> IO ()) -> Map a b -> IO ()
16:15:46 <lambdabot> Dhall.Map traverseWithKey_ :: Ord k => Applicative f => (k -> a -> f ()) -> Map k a -> f ()
16:15:46 <lambdabot> Dhall.Map unorderedTraverseWithKey_ :: Ord k => Applicative f => (k -> a -> f ()) -> Map k a -> f ()
16:16:42 <jacks2> preferably something in Data.Map or other modules that ship with platform
16:19:56 <ChaiTRex> jacks2: https://hackage.haskell.org/package/containers-0.6.2.1/docs/Data-Map-Lazy.html#v:traverseWithKey
16:20:18 <ChaiTRex> No, that's not quite right.
16:20:24 <monochrom> But it incurs the cost of building a new dictionary that no one uses.
16:20:57 <shachaf> Not if you use Const, probably.
16:21:20 <shachaf> There is also foldMapWithKey.
16:21:49 <shachaf> lens has the exact function you want as itraverse_ ("indexed traverse"). But I don't think it's in containers.
16:22:20 <maerwald> :t \f s0 -> fmap (GHC.Exts.fromListN (size s0)) . Prelude.traverse f . Data.Map.Strict.toList $ s0
16:22:21 <lambdabot> error:
16:22:21 <lambdabot>     • Variable not in scope: size :: M.Map k a -> Int
16:22:21 <lambdabot>     • Perhaps you meant one of these:
16:22:24 <maerwald> something like that
16:22:43 <monochrom> Maybe you won't mind one of:  1. toList then use list's mapM_.  2. foldlWithKey'
16:22:46 <maerwald> and it fuses well, with set at least
16:22:56 <maerwald> https://github.com/haskell/containers/pull/592/files#diff-4df0df67f040d8966d42092e63d4af61R967
16:23:36 <jacks2> yeah I think I'll use toList
16:24:23 <monochrom> Err foldlWithKey is better than foldlWithKey' for this case
16:29:00 <dmj`> So, I'm doing some things with GHC.Generics. In this case I have the Generic Rep tree that holds Haskell functions of arbitrary arity in the leaf nodes (K1 nodes). I'd like to "pattern match" on these functions somehow and alter the return type (lift it). How can I do this? What options do I have?
16:31:27 <koz_> > ['1' .. '9']
16:31:29 <lambdabot>  "123456789"
16:32:04 <jacks2> any reason [space efficiency or similar] to make it more complex than this?
16:32:05 <jacks2> :t \f -> mapM_ f . M.toList
16:32:07 <lambdabot> Monad m => ((k, a) -> m b) -> M.Map k a -> m ()
16:33:24 <shachaf> Well, that's going to allocate a list and then fold it immediately.
16:38:01 <dmj`> This isn't a case for contravariant functors either
16:41:01 <johnw> dmj`: hi!
16:41:08 <dmj`> johnw: hello! :) 
16:41:59 <johnw> veryltns
16:42:13 <dmj`> johnw: good to hear from you :)
16:42:14 <johnw> and hi shachaf too!
16:42:17 * dmwit . o O ( coerce (traverseWithKey :: (k -> a -> Compose IO (Const ()) b) -> Map k a -> _) )
16:42:31 <johnw> covid means not seeing edward's kitties until they are very big...
16:49:10 * dmj` tries dmwit's coerce
16:50:02 <dmwit> dmj`: Uh, well. You're certainly welcome to it. But it was aimed at jacks2, not you.
16:50:36 <dmwit> I don't understand your question well enough to comment on it usefully.
16:55:10 <dmj`> dmwit: I'll make a small example that demonstrates clearly the problem
17:25:11 <dmj`> https://gist.github.com/0dc2a0f424938a97764f9c5a79ad2f48
17:25:42 <dmj`> dmwit: starts on line 22. Trying to get 'idToLifted = to . gToLifted . from' to typecheck
17:26:28 <dmj`> I want to swap out the implementation of fields for a record by altering the types of the fields, and their values, into the new type
17:28:01 <dmwit> Is any of this needed?
17:28:13 <dmj`> for me :) 
17:28:22 <dmwit> Why not do the simple thing of `data Thing f = Thing { aThing :: String -> f Int, bThing :: String -> f Double }`?
17:28:33 <dmwit> Thing Id -> Thing Maybe is easily done then
17:28:44 <dmwit> Thing Identity, I mean
17:30:03 <dmj`> dmwit: that seems like it would work. But the type family being applied to the entire function is from another package that I don't think I could easily change
17:30:03 <Axman6> dmwit: not seeing people's kitties is the biggest cost from this epidemic
17:30:07 <Axman6> uh, johnw
17:30:19 <dmj`> dmwit: but I guess I could put two type families in the record
17:30:59 <dmj`> data Thing convert f = Thing { aThing :: convert :- String -> f Int, bThing :: convert :- String -> f Double }
17:31:42 <dmwit> :- is the problem here in the first place
17:31:49 <dmwit> Because you can't go "backwards" through a type family.
17:32:19 <dmwit> Just because you've got a K1 x (String -> Int) doesn't mean that you definitely started with a `Id :- String -> Int`.
17:32:55 <dmwit> Well. I think that's the problem, anyway.
17:33:27 <bebe> hello
17:34:35 <bebe> how do I convert Maybe a into a?
17:34:40 <dmwit> can't
17:34:43 <dmwit> Make a different plan.
17:34:51 <Axman6> @djinn Maybe a -> a
17:34:52 <lambdabot> -- f cannot be realized.
17:35:02 <dmj`> @src fromMaybe
17:35:02 <lambdabot> fromMaybe d Nothing  = d
17:35:02 <lambdabot> fromMaybe _ (Just v) = v
17:35:13 <dmwit> For example: if you plan to pass that `a` to another function, consider teaching that function how to handle a `Maybe a` input instead using `fmap` or `(>>=)`.
17:35:17 <EvanR> you have to figure out what to do about Nothing
17:35:48 <EvanR> fromMaybe lets you specify a fallback `a' value
17:36:06 <bebe> Say if I've got a->[Maybe a] -> [a], and I want to convert [Maybe a] values into a values ?
17:36:20 <siraben> What's the cost to call Haskell from C?
17:36:26 <dmwit> What do you want the conversion to do?
17:36:30 <EvanR> @djinn a -> [Maybe a] -> [a]
17:36:30 <lambdabot> Error: Undefined type []
17:36:40 <EvanR> lousy
17:36:49 <siraben> @djinn forall a. a -> [Maybe a] -> [a]
17:36:50 <lambdabot> Error: Undefined type []
17:37:16 <wavemode_> Data.Maybe.catMaybes
17:37:29 <Axman6> siraben: the cost is having to head with C
17:37:31 <EvanR> > map (fromMaybe '?') [Just 'a', Nothing, Just 'c', Just 'd']
17:37:34 <lambdabot>  "a?cd"
17:37:43 <dmwit> Like, okay, sure, `Just x` maps to `x`. I'm sure that's part of the behavior you want for your conversion. But what do you want to happen when there are `Nothing`s?
17:38:02 <Axman6> :t map . fromMaybe
17:38:03 <lambdabot> b -> [Maybe b] -> [b]
17:38:03 <bebe> blank I guess
17:38:09 <dmwit> What is "blank"?
17:38:25 <EvanR> blank. So Nothing. You want Maybe a -> Maybe a
17:38:43 <bebe> Okay, so I want the type to be 
17:38:53 <dmwit> (I know it sounds like I'm trying to be difficult. But I promise I'm not. I'm trying to help you think carefully about what you're asking for.)
17:39:23 <bebe> a -> [Maybe a] -> [a] , which converts all Maybe a values in the second parameter list into a values, using the first parameter as the default value
17:39:32 <dmwit> Ah!
17:39:36 <dmwit> Okay, then `fromMaybe` will do fine.
17:39:55 <dmwit> ?src fromMaybe
17:39:55 <lambdabot> fromMaybe d Nothing  = d
17:39:55 <lambdabot> fromMaybe _ (Just v) = v
17:40:02 <dmwit> dmj`++
17:40:52 <dmwit> dmj`: Anyway, can you make separate `GToLifted` instances for functions, Ints, and Doubles?
17:41:23 <dmwit> I'm not 100% familiar with how Generic works. Maybe one of `x` or `r` is that?
17:42:48 <bebe> With fromMaybe, I'm getting the issue
17:42:49 <bebe> Couldn't match expected type `[Maybe a]'
17:43:01 <bebe> in pattern Just v
17:44:25 <bebe> Did anyone say anyhting? I ended up getting disconnected?
17:44:31 <dmwit> bebe: We'd be happy to help with that, but you have to show us the code that's causing the error. Use a pastebin and send us a link.
17:45:24 <bebe> https://pastebin.com/bdnQALve
17:45:53 <dmwit> :t fromMaybe
17:45:54 <lambdabot> a -> Maybe a -> a
17:46:06 <dmwit> We are suggesting that you use the (already-existing) fromMaybe to implement the thing you actually care about.
17:46:14 <dmwit> Not that fromMaybe *is* already the thing you care about.
17:46:22 <dmwit> ?index fromMaybe
17:46:22 <lambdabot> Data.Maybe
17:46:27 <dmwit> import it from there ^
17:46:46 <dmwit> You can define it yourself if you really want, as you did there, but you have to give it the right type. =)
17:46:46 <wavemode_> bebe: in your best guess, what is the problem with your code?
17:48:13 <bebe> Ahh, Ok I think i've figured it out. 
17:48:38 <bebe> the problem was the [] right? didn't have them with the nothing = d or the just = v
17:50:17 <bebe> actually i don't know. 
17:50:34 <koz_> :t truncate
17:50:36 <lambdabot> (RealFrac a, Integral b) => a -> b
17:55:38 <wavemode_> bebe: right, you're supposed to be processing a list. so you need a way to apply a function to each value of a list. aka, map
17:55:42 <wavemode_> :t map
17:55:44 <lambdabot> (a -> b) -> [a] -> [b]
18:24:19 * hackage calamity 0.1.5.1 - A library for writing discord bots  https://hackage.haskell.org/package/calamity-0.1.5.1 (nitros12)
18:44:16 <Welkin> Has anything changed much in the Haskell web ecosystem in the last year or so? I haven't kept up. Last time I checked, there was a lot of activity around SQL libraries
18:57:34 <Welkin> what happened to distributed haskell? https://github.com/haskell-distributed/distributed-process
18:57:49 <Welkin> no releases for almost 2 years
18:58:23 <Axman6> I don't thin kit ever gained much traction, though the distributed-dataset project puts parts of it to good use
19:00:41 <Welkin> why not? Look at erlang, elixir, akka, orleans
19:01:11 <Welkin> there is a definite and growing demand for distributed systems
19:01:59 <EvanR> distributed systems was also a hype fest
19:02:03 <Welkin> it's sad to see this project just suddenly stop
19:02:35 <Welkin> most organization s are using kubernetes to do a lot of this, with microservices
19:02:48 <Welkin> which is *very* heavy
19:03:24 <wavemode_> even microservices is losing hype, frankly. people are starting to see the drawbacks as well as the advantages
19:04:05 <EvanR> the coolness keeps bouncing back and forth between distributed and centralized
19:05:20 <Welkin> there are different advantages and disadvantages in a large organization
19:05:44 <Welkin> compared to a small one, too
19:05:49 <remexre> is there any way to detect a circular value that's faster than trying to deepseq it and timing out after 10min?
19:06:04 <Welkin> my org is fully on board with microservices, going for something similar to an amazon model
19:06:23 <Welkin> it's sorely needed as we feel the pain every day of our monolith, especially for shipping anything
19:07:26 <EvanR> remexre: in IO there is the stable names thing
19:07:28 <Welkin> hundreds of engineers working on the same codebase doesn't scale, especially when a change in one unrelated area can having cascading effects to another part
19:08:13 <EvanR> you can evaluate the constituents and stop if you encounter something you saw before
19:08:15 <remexre> EvanR: hm, do you know of anything built on top of this that's like, Generic a => a -> IO Bool ?
19:08:25 <EvanR> however an infinite non cyclic structure will freeze you
19:08:53 <EvanR> no I don't and i would be surprised if anyone tried this for a good purposes
19:09:30 <remexre> I mean if I write it it's going under Debug.* :P
19:09:46 <EvanR> oh debug... well there's tools to inspect heap objectts
19:10:19 <EvanR> ghci's debugger, ghc-vis
19:11:21 <remexre> yoooo I've been looking for something like ghc-vis for years now
19:11:24 <remexre> for a class I TA
19:12:00 <EvanR> yeah pictures are worth 1000 something
19:12:54 <remexre> yeah, it's an "intro to fp" kinda course, and one of the most "this seems like avoidable work" parts of TAing it is always the call-by-name vs call-by-value vs lazy eval unit
19:13:14 <remexre> where the students try learning it on strings, and only like 15% of them realize that they should understand it in terms of trees
19:13:33 <remexre> ok, 15% is perhaps pessimistic; 15% of frequent office hour attendees
19:13:57 <remexre> but every year, every TA ends up filling up a bunch of white boards drawing these same diagrams
19:14:09 <EvanR> graph of heap objects may not be the best way to relate haskell semantics
19:14:15 <EvanR> but it's good for debugging
19:15:03 <EvanR> but a proxy for heap graph is a particular form of expressions with recursive let's standing for cycles
19:16:34 <remexre> ah, rip, max base version of 4.10
19:18:34 <remexre> yeah, we usually have them write things like `(a + a) where a = 3 + 4`; it's an OCaml class, so we can be a bit loose w/ the semantics of lazy eval
19:19:12 <EvanR> ghc vis is sound less and less appropriate!
19:19:15 <remexre> (plus, we make them implement it as type 'a lazy = [`Forced of 'a | `Thunk of unit -> 'a] ref)
19:19:16 <EvanR> sounding
19:20:02 <remexre> yeah, more likely I'll try to scoop out whatever it's using for AST drawing
19:21:06 <remexre> I already ended up writing my own ML-like lang to generate practice problems; convincing graphviz to produce non-ugly pictures is basically where I got stuck
19:21:40 <remexre> oh, it's using graphviz, hm
19:22:22 <EvanR> graphviz is whisperable, afaict
19:22:40 <Welkin> the whisper protocol?
19:23:00 <EvanR> i don't dare ask what that is
19:23:20 <Welkin> the old name for Signal
19:23:30 <remexre> whisperable?
19:23:46 <Welkin> whippersnapper
19:23:54 <EvanR> like, you can coerce it to behave
19:24:08 <EvanR> if you don't like the default arrangements
19:24:23 <remexre> oh, yeah; I usually end up switching to TikZ or pencil+camera rather than fight its heuristics, tho
19:24:50 <EvanR> pencil + camera is underrated
19:25:15 <winny> tbh been using a wacom tablet + xournal for some diagramming, oddly usable
19:26:00 <Welkin> what is this for?
19:26:02 <remexre> yeah, one of my best ideas was attaching webcam -> ruler -> clipboard to get a homemade document camera; super-useful for calls where I need to draw pictures halfway thru
19:26:17 <Welkin> you are creating software to draw diagrams like a digital whiteboard?
19:26:36 <Welkin> there are a ton of apps already for that
19:26:52 <Welkin> using a browser canvas over a websocket is good enough too
19:27:09 <dmwit> pencil + camera loses in the controlling-pencil-over-IP department
19:27:42 <remexre> imo (as someone who doesn't own a wacom tablet), it wins in the "showing a diagram over IP" dept tho
19:27:44 <Welkin> I think lucidchart is also multiplayer
19:28:04 <EvanR> coming from internet D&D i have not found an internet whiteboard that doesn't suck yet. And this is wildly offtopic now
19:28:39 <Axman6> What's the deal with actual whiteboards anyway? </seinfeld>
19:28:43 <Welkin> I may be building one soon as part of my tabletop games application
19:28:59 <EvanR> i wish you luck
19:29:02 <Welkin> the difficult part is designing the UI
19:29:07 <Welkin> the data sync is easy
19:29:16 <Axman6> surely there's a CRDT you can use for this
19:29:26 <Welkin> you don't need one
19:29:28 <Axman6> for synchronisation
19:29:37 <Welkin> it could even be an XMPP node that tyou publish data to
19:29:44 <EvanR> yeah the hard part of designing tools is... design
19:29:48 <Welkin> the lucky thing is that mosto f the time no one is modifying the same thing
19:31:15 <Welkin> this is a fun story https://www.figma.com/blog/how-figmas-multiplayer-technology-works/
19:31:39 <Welkin> last time I used couchdb <-> pouchdb with automatic sync. I just ignored conflicts though.
19:32:05 <Axman6> YOLOCAP
19:32:15 <Welkin> what?
19:32:34 <Axman6> RIP CAP theorum, you don't get to ignore consistency usually
19:32:58 <Welkin> I will need to implement 3 different kinds of synchronization
19:33:34 <Welkin> I'll have unstructured data in the form of a canvas/board, structured data (forms) and unstructured rich text (which probably requires OT)
19:33:41 <EvanR> consistency is overrated --google, facebook, amazon, twitter
19:33:50 <Welkin> etherpad looks good for the rich text
19:44:39 <Welkin> I'm looking at embeddable rich text editors for the browser. It's funny to see some of them list crap like this: `Lightweight: ~136.16kB gzipped.`
19:45:02 <Welkin> my entire _Application_ is only 30 kb gzipped
19:51:53 <dsal> > Just 3 > Nothing
19:51:55 <lambdabot>  True
19:51:58 <dsal> Well.  It's better than nothing, I guess.
19:55:25 <Welkin> > fix error
19:55:28 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
19:55:31 <Welkin> :D
19:55:47 <Welkin> haskell has the best jokes
19:58:24 <dsal> I think it's kind of rude to mock java so openly like that.
20:00:38 <Welkin> I know it's cool to hate java, but I was misled for many years. I use it at work dialy now and it's really not that bad. There are so many worse languages out there
20:01:08 <Welkin> at least it has a type system and sane semantics (not including the seemingly infinite decorators that various libraries provide)
20:01:27 <Welkin> streams and lambdas are pretty decent
20:01:40 <dsal> It probably can be done well.  At work, most of our lava is written by magicians.
20:02:01 <dsal> i.e., it's just a collection of dumb tricks where they use indirection to keep you from seeing what's really happening.
20:03:23 <dsal> My most popular project on github is no longer written in java, at least.  :)
20:03:58 <monochrom> No it is not cool to hate Java.  In particular Java checked exception system has won.
20:04:14 <dsal> What did it win?
20:04:22 <dsal> And does that imply the rest of us lost?
20:04:51 <monochrom> won my respect, for starters
20:04:54 <Feldmaus> dsal: What project was that?
20:06:27 <Welkin> Phil Wadler worked on the Java type system
20:06:40 <dsal> Feldmaus: I wrote a reasonbly popular memcached client back in the day.  Lots of fancy nio nd protocol junk.
20:06:46 <Welkin> Java is getting pattern matching in 14 or 15
20:06:58 <Welkin> it is becoming more functional with every release
20:08:21 <wavemode_> and immutable records. amazing
20:08:36 <monochrom> And we guys in haskell have really lost.  All those who work heavily with IO are experiencing it.  The mud bath of hoping that a lib's doc tells you what IO exceptions it throws, and failing that, hoping that all cases are empirically discoverable by just a few tests.
20:10:39 <dsal> Yeah, I don't know.  I spent years in java and eventually found checked exceptions to just be bad in practice.  I assume they've made some degree of improvements since then.  Working with languages with unchecked exceptions is slightly frustrating, but it doesn't get in my way that much.
20:11:14 <dsal> While it's super great to know what exceptions are thrown, most of the time, I don't care at all.
20:11:24 <Welkin> your web server library should handle that for you, so it shouldn't be a huge problem in many use cases
20:11:42 <Welkin> it's isolated to the http layer and the database connection layer
20:12:08 <Welkin> The only non-browser software I write is web servers
20:12:10 <dsal> If I'm writing a web thing, sure, but if I'm just a passthrough function that calls a library function that throws some exceptions, I need to know all those exceptions and declare them.
20:12:37 <wavemode_> eh, at the end of the day you can't be safe from everything. that's why we test
20:12:39 <koz_> Hoogle's 502ing me.
20:12:42 <dsal> Most of the time, I just want bracket.  Even knowing what exceptions might be thrown is a distraction.
20:12:45 <monochrom> Oh, that's just Java's lack of inference.
20:13:09 <dsal> Yeah, I don't think I'd mind checked exceptions as much with inference.
20:13:39 <wavemode_> yeah, hoogle's down :/
20:13:48 <koz_> % :info Predicate
20:13:48 <Welkin> try hayoo
20:13:49 <yahb> koz_: ; <interactive>:1:1: error: Not in scope: `Predicate'
20:13:51 <dsal> @hoogle isDown
20:13:51 <lambdabot> Diagrams.TwoD.Path.Turtle isDown :: Monad m => TurtleT n m Bool
20:13:52 <lambdabot> Network.AWS.DirectConnect ISDown :: InterconnectState
20:13:52 <lambdabot> Network.AWS.DirectConnect.Types ISDown :: InterconnectState
20:13:59 <Welkin> or install local hoogle
20:14:42 <Welkin> I haven't actually written any haskell is well over a year
20:15:05 <Welkin> it's been mostly typescript, elm, java, and a little python. also playing with elixir
20:15:33 <wavemode_> how have you liked elm
20:15:34 <Welkin> lotso f other random languages thrown in there from last summer, like julia and lua
20:15:50 <Welkin> I have been using Elm since 2016 and have probably wirtten more lines of Elm than any other language
20:16:03 <dsal> I kind of like elm.  It feels much better than javascript.
20:16:07 <Welkin> it is amazing. The best language I have used. Easiest development experience
20:16:38 <Welkin> it is like a refined, minimalist haskell for the browser
20:16:57 <wavemode_> dsal: i mean, bathing in shards of broken glass feels better than javascript
20:16:59 <Welkin> extensible records are so powerful, you won't miss type classes
20:18:02 <monochrom> I will miss type classes.
20:18:24 <monochrom> Functor cannot be done by an extensible record.
20:18:24 <dsal> The lack of typeclasses is an annoyance.
20:18:29 <Welkin> I only had one case where I thought I wanted them. Then I realized my design was too complicated and there was a simpler way to do it
20:19:10 <Welkin> functor is overrated. List.map, Dict.map, Html.map, etc.
20:19:55 <dsal> I wanted a Set of of my type.  Or a map keyed off my type.  Something like that that seemed sensible enough without creating a new type that kind of looked like Dict, but worked with my type.
20:20:29 <Welkin> there are some built-in "typeclasses" like `comparable` that are defined for primitives like Int or String
20:20:47 <dsal> Yeah.  But you can't make an instance of those.
20:20:51 <Welkin> there is work being done to add some limited ability to define your own comparable types
20:21:02 <dsal> Oh good.  That's what I needed.  :)
20:21:04 <Welkin> in the meantime, use anydict, which converts your type to a string
20:21:20 <dsal> Oh, Show is another example of "omg, I'd like this, please"
20:21:37 <dsal> I don't fully understand why that's missing.
20:21:56 <Welkin> in html, not really. I have no issue defining my own toString functions for my sum types
20:22:05 <Welkin> often the defaults in haskell would not be what I want anyway
20:22:53 <Welkin> there are things missing on purpose, because they were removed by design
20:22:55 <dsal> In many cases, I just copy and paste the definition and have emacs do the work.  But it seems like something the programming language could do.
20:23:23 <wavemode_> removed by design makes me feel icky
20:23:28 <Welkin> different design approach than haskell
20:23:35 <wavemode_> though I understand the philosophy
20:23:49 <Welkin> it works extremely well in practice, regardless of dissenters (who never actually use it, but like to complain)
20:24:05 <wavemode_> guilty :P
20:24:38 <dsal> I have a couple things like:  `type MediaType = Burst | Photo | TimeLapse | TimeLapseVideo | Video | Unknown`  which are followed by 15 lines of "deriving (Show, Read)"
20:27:07 <dsal> Primarily because they're constants that get round-tripped through JSON:  `|> required "type" (Decode.map strMediaType string)`  -- It's possible the generated values wouldn't be right for me in some situations, but it's a bit boiler-platey.
20:32:04 <dsal> Meanwhile, I've been staring at this same line of code for half an hour or so because I don't actually know what I want to do. 
20:32:41 <dsal> Maybe I'll try not to do everything atomically.
21:00:50 <dmj`> dsal: doesn't look like haskell to me
21:01:13 <dsal> I went back to my regularly scheduled programming.
21:01:32 <dmj`> dsal: alright good, was beginning to get worried for your sanity
21:16:11 <dmj`> M1 i c f p
21:18:41 <siraben> Hi everyone, how can I improve performance of this function? https://github.com/sbond75/OpenGLTesting/blob/master/OpenGLTesting_C/macOS/Picture.hs#L184-L192
21:18:48 <siraben> I'm filling a C array with RGB pixel values.
21:19:43 <siraben> Currently it's about 600 ms per frame.
21:20:39 <Axman6> can you compute the x and y coordinated directly instead of using quotRem?
21:21:52 <monochrom> "M1 i c f p" strikes fear into the heart of those who have tried to learn GHC.Generics :)
21:23:40 <siraben> Axman6:  Yeah, just unfold the definition of quotRem?
21:25:13 <siraben> Axman6:  http://ix.io/2l6z
21:25:16 <Axman6> just use a list comprehension to generate all the coords
21:25:18 <siraben> Still around 600 ms
21:25:24 <Axman6> and zip it with the ids or something
21:31:36 <chew2> siraben: are you compiling with -O2? I don't see it in your makefile
21:32:14 <dsal> I spent so long trying to track down a performance problem once that ended up being that ^
21:32:16 <siraben> chew2:  Ah, I just added that.
21:32:42 <siraben> With -O2 it's a little better
21:32:46 <chew2> haha I didn't want to state the obvious but sometimes people forget
21:32:46 <siraben> 570 ms roughly
21:32:58 <siraben> I'll need to generate the list with a comprehension
21:35:41 <wavemode_> every time you make a list or a tuple is several heap allocations. every time you make a Color is a heap allocation. Just at a glace (I don't know for sure) it's concerning that you're doing both of those things for each pixel, which is millions of times per frame
21:36:03 <siraben> Hm I can't seem to make the right list comprehension, any suggestions?
21:36:10 <siraben> f i = let (y,x) = i `quotRem` screenWidth in (x,y)
21:36:10 <siraben> l2 = (f <$> [0..screenWidth*screenHeight-1])
21:36:28 <siraben> l1 = [(x,y) | y <- [0..screenWidth-1], x <- [0..screenHeight-1]] isn't the same
21:37:15 <siraben> wavemode_:  Yeah, this comes from the semantic model of functional images. I could make color a type alias instead
21:37:40 <Feldmaus> siraben: y corresponds to the height, x to the width
21:38:42 <siraben> Oh so
21:38:42 <siraben> l1 = [(x,y) | y <- [0..screenHeight-1], x <- [0..screenWidth-1]]
21:38:43 <siraben> works
21:39:57 <siraben> With the list comprehension, still seeing 580 ms
21:40:19 <Axman6> time to profile and see where the time is going
21:40:25 <siraben> Could I calculate the rows in parallel?
21:40:26 <siraben> Ok
21:40:35 <dmj`> there is parallel list comps
21:41:10 <Axman6> they don't calculate in parallel though
21:41:18 <Axman6> the do zipWith basically
21:41:21 <dmj`> yea, it's false advertising
21:41:27 <siraben> Ah profiling is tricker, I can't run the program directly since it's linked to C
21:41:54 <dmj`> you could just write some C for this
21:41:57 <Axman6> eh?
21:42:05 <Axman6> is it being called form C?
21:42:14 <Axman6> or is main in Haskell?
21:42:19 <siraben> Main is in C
21:42:30 <siraben> I used to calculate the RGB values individually and use C to fill the buffer
21:42:42 <siraben> Now I calculate the color value and use Haskell to fill it
21:42:49 <Axman6> I assume you're not doing something silly like initialising the RTS on every frame?
21:42:53 <siraben> What I could do perhaps is return a struct to C?
21:43:01 <siraben> Nope, hs_init() is once.
21:43:02 <siraben> Let me check
21:43:20 <siraben> Yeah it's called at the beginning of main.c
21:43:51 <siraben> Here's the call
21:43:53 <siraben> https://github.com/sbond75/OpenGLTesting/blob/d136ec16fc646a491e7e85f13c09fdbb75d60e1a/OpenGLTesting_C/macOS/main.c#L80
21:43:54 <Axman6> you should be able to profile I thhink, hs_init should process command line args for the RTS still I think?
21:45:00 <Axman6> so in theory you should be able to compile the haskell with profilling, and then run your program with +RTS --help to see which flags to add
21:45:14 <Axman6> not sure what happens at the end of program execution
21:45:43 <Axman6> hopefully hs_exit() will write the profiling info?
21:45:57 <siraben> Ok I'll need to exit the loop then
21:47:56 <siraben> Oh
21:48:02 <siraben> It seems I had to make clean before this
21:48:03 <siraben> Huh
21:48:12 <siraben> I'm getting 120 ms per frame now
21:48:20 <dmj`> foreign import ccall unsafe "fillPixelBuffer" fillPixelBuffer :: Ptr Int -> Int -> IO ()
21:48:28 <siraben> The 120 ms is the optimization kicking in
21:48:46 <siraben> Doesn't -fforce-recomp recompile?
21:49:16 <Axman6> it should...
21:50:01 <Axman6> how are you getting the frame time?
21:50:23 <siraben> FpsLimiter_end(&fpsLimiter);
21:50:25 <siraben> SDL call
21:50:41 <Axman6> does it print the fps/frame time?
21:51:38 <siraben> Yes
21:51:55 <siraben> http://ix.io/2l6G
21:52:03 <siraben> With a bit of C plumbing
21:52:11 <Axman6> cool
21:53:18 <siraben> It'd be better to get it to around 50 ms, hm.
21:53:39 <Axman6> anyway, have you tried to make profiling work yet :)
22:09:13 <siraben> Axman6:  I get a linker error
22:09:14 <siraben> http://ix.io/2l6L
22:10:41 <Axman6> hmm, getting well beyond my experience - maybe ask in #ghc if this is something that should be possible?
22:12:16 <Axman6> also, I assume you're compiling the haskell with optimisations?
22:12:23 <Axman6> maybe also try LLVM?
22:14:07 <siraben> Ok sure
22:24:06 <Axman6> I wonder how well repa would work for you too
22:24:20 * hackage plzwrk 0.0.0.5 - A front-end framework  https://hackage.haskell.org/package/plzwrk-0.0.0.5 (mikesol)
22:29:43 <siraben> Axman6:  repa?
22:30:38 <Axman6> !hackage repa
22:30:38 <solrize> hmm i notice all the source links for https://downloads.haskell.org/ghc/latest/docs/html/libraries/ghc-prim-0.6.1/GHC-Prim.html are broken
22:36:46 <Axman6> most of the definition's in there have their source as gtChar# = gtChar#
22:36:52 <Axman6> IIRC
22:38:26 <siraben> Axman6:  In lieu of being able to enable profiling, what else should I optimize?
22:43:47 <solrize> @hoogle I#
22:43:47 <lambdabot> GHC.Exts I# :: Int# -> Int
22:43:47 <lambdabot> GHC.Types I# :: Int# -> Int
22:43:47 <lambdabot> GHC.Exts andI# :: Int# -> Int# -> Int#
22:49:23 <Axman6> siraben: can you make a Haskell program which calls fillPixelBuffer a lot and enable profiling and see how long that takes?
22:50:33 <_Cactus_> Lens question from a relative Lens noob: I'd like to combine two Traversals s.t. the composition has read access to the middle layer
22:50:36 <_Cactus_> I'm thinking something of this type:
22:50:46 <_Cactus_> Traversal' s a -> Traversal' a b -> IndexedTraversal' a s b
22:51:04 <_Cactus_> 1. Would this really mean what I think it does? 2. How would I go on implementing such a thing?
22:53:43 <_Cactus_> I guess this could be simpliifed to the problem of 'remember :: Traversal' s a -> IndexedTraversal s s a'?  
22:53:45 <siraben> Axman6:  If I just make the buffer replicate screenSize 255, then it takes 20 ms per frame, as fast as C
22:54:14 <Axman6> death to tuples, would be my first place to start
22:54:31 <Axman6> and lists, but that's probably not as much of a problem
22:54:35 <siraben> So curry my functios?
22:54:37 <siraben> functions
22:54:50 <Axman6> but really these re just stabs in the dark, you need to profile
22:56:15 <_Cactus_> Hmmm so I can already see that Traversal' s a and IndexedTraversal i a b doesn't compose; neither does IndexedTraversal' i s a and Traversal' a b
22:56:32 <_Cactus_> so maybe I am misunderstanding IndexedTraversal in the first place
22:57:03 <Axman6> does asIndex get you anywhere?
22:57:28 <Axman6> or withIndex
22:57:56 <siraben> Axman6: Interestingly, if I make the image static, the loop is 9 ms
22:58:24 <_Cactus_> Axman6: I don't know, do they?
22:59:16 <Axman6> you tell me :)
22:59:33 <Axman6> there's also itraverseBy and itraverseByOf which look like that might do... something :)
23:00:10 <_Cactus_> Axman6: my problem is not consuming the traversal, it's creating it...
23:01:45 <mniip> one day I'll figure out indexed lenses
23:01:54 <Axman6> :t to (\x -> (x,x))
23:01:55 <lambdabot> (Profunctor p, Contravariant f) => Optic' p f b (b, b)
23:02:04 <Axman6> :t to (\x -> (x,x)) . withIndex
23:02:05 <lambdabot> (Contravariant f, Indexable i p, Functor f) => p (i, (b, b)) (f (j, (b, b))) -> Indexed i b (f b)
23:02:40 <Axman6> :t withIndex . to (\x -> (x,x))
23:02:41 <lambdabot> (Indexable j p, Contravariant f, Functor f) => p ((j, t), (j, t)) (f ((j, t), (j, t))) -> Indexed j t (f t)
23:02:45 <Axman6> nope
23:02:53 <Axman6> I dunno, you're on your own
23:15:31 <_Cactus_> https://stackoverflow.com/q/61651067/477476
23:15:35 <_Cactus_> Axman6: ^
23:42:02 <Axman6> Cactus_: you might also try asking in #haskell-lens
23:43:52 <Cactus_> Oh I wasn't aware of that channel
23:43:59 <Cactus_> I should have gone there first instead of spamming here :)
