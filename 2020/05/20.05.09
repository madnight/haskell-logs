00:06:07 <pie_> apparently you can do wildcard type applications like:
00:06:09 <pie_> :t ((\tu filter -> (flip undefined) ((cursorDescendantsF @_ ). filter) $ translationUnitCursor tu))
00:06:10 <lambdabot> error:
00:06:10 <lambdabot>     Pattern syntax in expression context: cursorDescendantsF@_
00:06:10 <lambdabot>     Did you mean to enable TypeApplications?
00:06:41 <pie_> but that still doesnt help, the problem is i think that id need to set kind0 at the top level, but no idea how to do that
00:06:52 <pie_> set / forall it or something
00:09:00 <pie_> hm which is probably because of the shape of undefined in flip
00:11:07 <pgiarrusso> pie_: wasn’t there sth like a TypedHole extension ? Write an underscore in place of an expression, get its type printed
00:12:07 <pgiarrusso> Ah, people asked already
00:12:11 <pgiarrusso> 8:15 AM <pie_> I want to get something like the output of :t
00:12:25 <pgiarrusso> I... think that output is there in the error?
00:20:28 <pie_> pgiarrusso: yeah im kind of all over the place with this right now but PartialTypeSignatures seems to get one most of the way
00:20:36 <pie_> > x = 1
00:20:40 <lambdabot>  <hint>:1:3: error:
00:20:40 <lambdabot>      parse error on input ‘=’
00:20:40 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
00:21:32 <pie_> > @let cursorDescendantsF :: HasChildren kind => Fold (CursorK kind) Cursor
00:21:34 <lambdabot>  <hint>:1:1: error: parse error on input ‘@’
00:22:33 <pie_> @let cursorDescendantsF :: HasChildren kind => Fold (CursorK kind) Cursor
00:22:34 <lambdabot>  .L.hs:191:1: error:
00:22:34 <lambdabot>      The type signature for ‘cursorDescendantsF’
00:22:34 <lambdabot>        lacks an accompanying binding
00:22:54 <pie_> @let cursorDescendantsF :: HasChildren kind => Fold (CursorK kind) Cursor ; cursorDescendantsF = undefined
00:22:55 <lambdabot>  .L.hs:192:22: error:
00:22:56 <lambdabot>      Not in scope: type constructor or class ‘HasChildren’
00:22:56 <lambdabot>      |
00:23:19 <pie_> @let cursorDescendantsF :: Num kind => Fold (CursorK kind) Cursor ; cursorDescendantsF = undefined
00:23:21 <lambdabot>  .L.hs:191:41: error:
00:23:21 <lambdabot>      Not in scope: type constructor or class ‘CursorK’
00:23:21 <lambdabot>      |
00:23:25 <pie_> egh
00:41:21 <pie_> ok well this is enough to get the constraint deduction error; :t undefined $ cursorDescendantsF
00:42:21 <pie_> ok actually in that case its "ambiguous"
00:48:19 * hackage earcut 0.1.0.2 - Binding to C++ earcut library.  https://hackage.haskell.org/package/earcut-0.1.0.2 (DavidHimmelstrup)
01:39:19 * hackage calamity 0.1.6.0 - A library for writing discord bots  https://hackage.haskell.org/package/calamity-0.1.6.0 (nitros12)
01:47:09 <siraben> I want to use Haskell and C, but my C file already has a main module, how can I fix GHC's linker errors?
01:47:28 <siraben> I want to use C's main, but Haskell is foreign importing and exporting functions
01:49:00 <[exa]> siraben: can you rename the C's main and call it from Hs main?
01:50:10 <siraben> [exa]: I renamed it to cMain and imported to Haskell
01:50:16 <siraben> Although I have a linker error:
01:52:02 <siraben> http://ix.io/2lmm
01:52:10 <siraben> main.h consists of extern int cMain ();
01:54:11 <[exa]> what's the _ZC before? (sounds a bit like C++ mangling)
01:54:49 <[exa]> maybe ⌜extern "C" int cMain();⌝
01:55:07 <siraben> http://ix.io/2lmo
01:55:12 <siraben> There's no C++ here
01:55:39 <siraben> Also, do I still have to init haskell's RTS in the c main?
01:55:53 <Arahael> I think thta's regular main, but on macos.
01:56:19 * hackage utf8-conversions 0.1.0.0 - A conversion library that assumes utf8  https://hackage.haskell.org/package/utf8-conversions-0.1.0.0 (chemirea)
01:56:23 <[exa]> siraben: RTS should get initialized by the haskell main
01:56:55 <siraben> Ok.
01:57:39 <[exa]> interesting though, this should be rather straightfoward
01:57:56 <[exa]> do you have the intermediate main.o available?
01:59:02 <siraben> Yeah there's a main.o
01:59:21 <[exa]> try `nm` on that (or `objdump -S`) to see how the symbols look like
01:59:32 <[exa]> same for the .o's from haskell
02:00:04 <[exa]> that should point to the cause of the linking problem
02:00:11 * [exa] needs to afk for a moment
02:00:18 <siraben> Ok. What am I looking for?
02:36:52 <siraben> [exa]: I'm getting a different set of errors now
02:36:53 <siraben> http://ix.io/2lmx
02:37:20 <siraben> So it can't find the SDL symbols, should I tell GHC to link them?
02:37:56 <siraben> Ok, just did that, looks like it's working.
02:39:33 <[exa]> yeah it needs -l
02:40:00 <[exa]> btw what was the original problem?
02:41:19 * hackage moto 0.0.4 - General purpose migrations library  https://hackage.haskell.org/package/moto-0.0.4 (RenzoCarbonara)
02:42:19 * hackage moto-postgresql 0.0.2 - PostgreSQL-based migrations registry for moto.  https://hackage.haskell.org/package/moto-postgresql-0.0.2 (RenzoCarbonara)
02:45:55 <siraben> [exa]:  Not sure exactly, I just had to clear out the .hi and .o files and check my C includes
02:45:58 <siraben> Thanks for the help
02:53:50 <[exa]> solarus: ok, great it works
02:55:06 <[exa]> siraben: anyway the `nm` and other tools from binutils should show what the symbols are exported&expected by the .o files and ELF executables, which usually helps to see what's broken
02:55:33 <[exa]> (oops mis-highlight, sorry)
02:55:34 <siraben> Yeah, that helped, turns out it wasn't recompiling so the symbols stayed the same
02:55:54 <[exa]> :]
02:59:57 <siraben> Switching to GHC means this should compile on Linux now as well, phew.
03:01:51 <merijn> Also, this looks like the right time to stop using ghc directly and use cabal to build stuff instead ;)
03:02:09 <siraben> Oh, even better. How would I do that?
03:02:29 <merijn> siraben: "cabal init --interactive"
03:02:45 <merijn> siraben: That should detect your source files and create a minimal cabal file
03:03:06 <merijn> siraben: https://cabal.readthedocs.io/en/latest/concepts-and-development.html for more details :)
03:03:16 <siraben> Right, I know cabal normally. But what about making it use the C programs too?
03:03:18 <siraben> Ah, thanks.
03:04:46 <[exa]> siraben: it has support for config like `includes` or `extra-libraries` that should cover your usecase
03:05:49 <siraben> I see.
03:07:04 <merijn> I would recommend *not* using extra-libraries (that only works if they're in your system path) you can tell cabal to use pkg-config to find your C dependencies
03:07:21 <merijn> https://cabal.readthedocs.io/en/latest/cabal-package.html?highlight=pkgconfig#pkg-field-pkgconfig-depends
03:08:19 <maerwald> if you're using debian, be careful about pkg-config, as they sometimes add pkg-config files downstream, breaking compilation on other distros
03:08:39 <maerwald> so make sure the pkg-config files are in the upstream tarball
03:09:54 <merijn> maerwald: That's not really relevant, though? It's the packager/builder's job to ensure any C dependencies and/or pkg-config files
03:10:32 <merijn> pkg-config is just a more configurable method of telling cabal where to find stuff.
03:11:24 <maerwald> merijn: of course it is relevant
03:11:51 <maerwald> pkg-config files must only be added by upstream
03:11:55 <merijn> Why?
03:12:01 <maerwald> if they are added downstream, then your package will only work on that distro
03:12:22 <maerwald> debian maintainers usually don't care, so they regularly break builds on other distros
03:12:29 <merijn> maerwald: My point is "where the pkg-config files come from" is not your problem. That's the problem of "whomever wants to build"
03:12:44 <maerwald> merijn: I disagree
03:12:51 <merijn> maerwald: What alternative would you propose "if upstream doesn't provide pkg-config files"?
03:12:59 <maerwald> that's like telling users to write their own configure script
03:13:05 <merijn> maerwald: Hard code library paths? That's even more broken
03:13:18 <maerwald> merijn: use whatever method upstream suggests for building
03:13:23 <merijn> maerwald: If there is no pkg-config for a library, then cabal has no reasonable way to find it
03:13:30 <maerwald> then cabal is broken
03:13:39 <maerwald> and you have to write a proper Setup.hs
03:13:39 <jackdk> cabal can call a configure script
03:13:53 <merijn> maerwald: You are assuming you're shipping sources inline
03:14:03 <merijn> maerwald: In which case you don't need pkg-config at all
03:14:06 <maerwald> pkg-config cannot be assumed and even if that file exists, you may only use it if it's provided by upstream
03:14:23 <maerwald> otherwise it's just going to cause problems
03:14:37 <maerwald> jackdk: yes
03:14:42 <merijn> maerwald: Feel free to tell me an alternative way of resolving libraries on a system that can be configured by the user
03:15:29 <maerwald> pkg-config is not a standard, you cannot assume C libraries have it. A build tool (such as cabal or cargo) cannot rely on it. They can only *support* it
03:15:31 <merijn> maerwald: "that's like telling users to write their own configure script" <- no, it's like telling *packagers* to write their own configure script
03:15:56 <maerwald> there are many other ways of finding libraries
03:15:57 <merijn> maerwald: There is no standard for C libraries, so you're hosed anyway
03:16:16 <maerwald> e.g. SDL and other tools have foo-config --libs etc
03:16:19 <merijn> maerwald: Like I said: Feel free to point out how to portably find C libraries from a cabal file
03:16:27 <maerwald> you cannot
03:16:35 <maerwald> and pkg-config isn't portable either
03:16:36 <merijn> maerwald: Now you're assuming those tools are in your path, etc.
03:16:50 <maerwald> No, I'm just saying it takes work :)
03:16:51 <merijn> maerwald: I didn't say it's portable, but it's the most portable thing around
03:17:11 <maerwald> yes, when it exists upstream
03:17:41 <merijn> That's irrelevant, because if it's added downstream your code now works on more systems than it did before
03:18:08 <merijn> If the choice is "nothing" or "pkg-config-depends", the latter is strictly better
03:18:28 <maerwald> I disagree. That's a lazy choice. You should make it build with the upstream tarball only, because then it'll work on all linux distros likely
03:18:38 <merijn> Because simply writing "libraries: foo" will only find things in /usr/lib etc.
03:18:55 <merijn> maerwald: You're fighting a strawman
03:19:02 <maerwald> /usr/lib is a good bet, it's defined in FHS
03:19:15 <maerwald> if a distro doesn't follow FHS, then it's on the distro
03:19:19 <maerwald> FHS is a standard.
03:19:31 <merijn> I said "pkg-config-depends" is better than "libraries" and now you're arguing "pkg-config-depends" isn't perfect
03:19:42 <merijn> But that's irrelevant to my point
03:19:54 <maerwald> merijn: no, pkg-config is the best choice, when there is a pkg-config file upstream :)
03:20:08 <maerwald> and it's NOT packagers jobs to add such files
03:20:12 <maerwald> And proper distros refuse to do so
03:20:17 <merijn> maerwald: Why keep bringing up "best"? I said "better"
03:20:25 <jackdk> suppose I want to send a sequence of individual json-encoded objects over a network. is there a way to have aeson return leftovers after decoding? I looked at the docs but may have missed something
03:20:34 <merijn> You haven't in any way made a point that makes "libraries" better or equal
03:20:41 <maerwald> Proper distros provide upstream pull requests to add such files and only incorporate them, when this has been accepted.
03:21:00 <maerwald> It causes all sorts of problems doing this downstream
03:21:24 <merijn> maerwald: I know *you're* obsessed with linux, but it's not the "end all, be all" of unix, and /usr/lib is far from portable
03:21:47 <maerwald> I'm just tired of debian breaking other distros.
03:22:00 <merijn> Blindly assuming "/usr/lib" is undeniably worse than "using pkg-config-depends"
03:22:04 <maerwald> And as such, users should be made aware that it matters where the pkg-config files come from
03:22:15 <merijn> maerwald: That's a problem to bring up with the #debian people and not really relevant here
03:22:22 <maerwald> merijn: it absolutely is
03:22:35 <maerwald> And it has been brought up with debian maintainers 
03:22:40 <maerwald> They ignore it
03:23:14 <merijn> maerwald: No, because you haven't made a single argument against my claim "pkg-config-depends" is better than "libraries", so you're just arguing your pet point/peeve, in a manner unrelated to the original discussion
03:23:31 <maerwald> merijn: I haven't disagreed with you
03:23:49 <maerwald> I said you should not use pkg-config-depends, when the pkg-config files was added downstream. That's all.
03:25:03 <maerwald> there should be a way in cabal to make this optional
03:25:08 <maerwald> it may likely require you to write a Setup.hs
03:34:04 <fog> why would a module not export its functions?
03:35:08 <fog> could it be something to do with instances with associated type families calling across modules?  
03:37:55 <fog> when i do :browse on the module, it just returns the datatypes and type families...
03:39:19 * hackage deriving-aeson 0.2.5 - Type driven generic aeson instance customisation  https://hackage.haskell.org/package/deriving-aeson-0.2.5 (FumiakiKinoshita)
03:44:20 * hackage barbies-th 0.1.2 - Create strippable HKD via TH  https://hackage.haskell.org/package/barbies-th-0.1.2 (FumiakiKinoshita)
03:52:35 <fen> i was working on stencil convolutions a while back, and there were some questions about why bother to create zippers over graphs
03:53:10 <fen> the argument was basically that as hardware is optimised for random access, that direct memory addresses would always be faster
03:53:58 <fen> than the navigational operations required to relocate the cursor over the nodes of the graph to have more direct access to neighbours 
03:54:23 <fen> this argument relies on the existence of shared memory 
03:55:26 <fen> for massive parallelisation, different parts of a datatype can be placed on different machines, or cores  
03:55:55 <fen> then, without shared memory, there can still be utility for fast structured access
03:56:36 <fen> this is a stronger argument than the idea of developing structured access optimised hardware as emulated on FPGA's
03:57:06 <fen> since the latency saving of having memory physically close on a chip is not too significant 
03:57:58 <fen> but large latency is introduced by communication between distributed processes, through hardware junctioning
03:59:20 <fen> then it can be advantageous to use stencil convolutions on graphs using multidimensional zippers 
03:59:39 <fen> as opposed to simply using memory addresses 
04:00:51 <fen> since the structure inferred can lead to an allocation procedure for distributing the datatype over several cores for local stencil update
04:29:19 * hackage digestive-functors 0.8.4.2 - A practical formlet library  https://hackage.haskell.org/package/digestive-functors-0.8.4.2 (JasperVanDerJeugt)
04:34:19 * hackage digestive-functors-happstack 0.6.1.3 - Happstack backend for the digestive-functors library  https://hackage.haskell.org/package/digestive-functors-happstack-0.6.1.3 (JasperVanDerJeugt)
04:45:16 <kderme> I'm trying to understand why this code doesn't build https://gist.github.com/kderme/116c8c8070b4b1aa01d1802e1d9c6225. (Related to data families)
04:47:44 <kderme> https://gist.github.com/kderme/116c8c8070b4b1aa01d1802e1d9c6225
04:51:06 <gallais> !t
04:52:14 <siraben> Trying to edit my cabal file to include C files, what's wrong? http://ix.io/2lnd
04:52:33 <siraben> pkgconfig-depends is correct
04:55:20 <maerwald> siraben: you haven't showed any error
04:55:53 <siraben> maerwald:  http://ix.io/2lne
04:57:29 <maerwald> do you have the sources somewhere?
05:07:49 * hackage rbst 0.0.0.0 - Randomized Binary Search Trees  https://hackage.haskell.org/package/rbst-0.0.0.0 (ArnauAbella)
05:18:07 <siraben> maerwald:  Yeah, they're in the same folder
05:18:24 <maerwald> siraben: I can't see them.
05:18:47 <siraben> maerwald:  https://github.com/sbond75/OpenGLTesting/tree/master/haskellSDL
05:18:52 <siraben> The cabal files aren't pushed yet
05:28:11 <f-a> I am `cabal repl` (after cabal init and writing some code) and getting: Saved package config file header is missing. Re-run the 'configure' command.
05:28:47 <f-a> searching online didn't help much, cabal configure does not fix it, nor rm -rf dist-newstyle/
05:33:21 <slack1256> f-a: does running `cabal v2-repl` output the same? 
05:33:53 <f-a> yes slack1256 . I should have specified my cabal-install version: cabal-install version 3.0.0.0
05:35:18 <f-a> oh, apparently an accented character in «name:» was what was blocking it
05:35:37 <f-a> ('à')
05:37:15 <slack1256> f-a: An accented name?, cabal error are cryptic sometimes.
05:37:48 <f-a> yup, I'll report in #hackage and see if it was an already-known quirk
06:20:15 <mlugg> Just a little question out of curiosity; what's the progress on a Haskell 202x report? Afaict from Google, there was a committee for Haskell 2020, but that's all but dead by this point, and nothing's really happening anymore. Are there any efforts to work on this, or has it entirely stalled?
06:26:35 <slack1256> TIL: https://downloads.haskell.org/ghc/latest/docs has a tar.xz for the hierarchical libraries and user guide documentation.
06:38:21 <p0a> Hello 
06:38:43 <p0a> I want to have a text database, that the user can search (maybe using regex?) how should I go about that?
06:39:16 <Rembane> p0a: Use SQLite, their text based search isn't too bad for a first prototype.
06:39:57 <p0a> thank you 
06:40:05 <slack1256> Also, storing on a file and shelling out for grep is acceptable.
06:40:14 <xerox_> sqlite is a very good suggestion
06:40:38 <p0a> yeah except
06:40:49 <p0a> I think I could just do that in C++ too
06:41:05 <Rembane> Yes, almost regardless of language you can use SQLite, that's the beauty of it. 
06:42:20 <p0a> It's going to be a small database manually curated
06:42:48 <p0a> well nevermind I'll figure it out :P \
06:43:46 <xerox_> p0a: I was reminded of this, from minute 4 to 11, just lovely https://youtu.be/RqubKSF3wig?t=240
06:43:56 <slack1256> p0a: If it gonna be a small database of primarely text, you can interface with recutils https://www.gnu.org/software/recutils/ .
06:44:46 <p0a> slack1256: that's what I use actually
06:44:56 <p0a> with my bash scripts. afaik recutils does not have a library 
06:45:23 <slack1256> From the page itself: "C library: librec"
06:45:24 <p0a> no wait there is one
06:45:25 <p0a> yeah
06:46:10 <slack1256> But yeah, there are no bindings to haskell. SQLite has sqlite-simple on haskell.
06:48:42 <p0a> it claims to have a librec but I don't see it anywher 
06:48:44 <p0a> well anyway
06:49:12 <lep-delete> i found ghc's ffi to be rather useable
07:06:49 * hackage utf8-conversions 0.1.0.1 - A string conversion library that assumes utf8  https://hackage.haskell.org/package/utf8-conversions-0.1.0.1 (chemirea)
07:14:26 <aveltras> any idea how i could get the following to work ? i'd like to find all sub apis in a servant generic api using TH, i don't know how to pattern match in findSubApi'
07:14:30 <aveltras> https://www.irccloud.com/pastebin/xpr0PGzx/
07:17:12 <siraben> Anyone know what I need my cabal file to be to build the same as
07:17:15 <siraben> `ghc -O main.hs Picture.hs render.c Timing.c -lSDL2 && ./main`?
07:17:25 <siraben> (the first part of &&)
07:18:23 <siraben> There's C calling Haskell and Haskell calling C
07:21:42 <maerwald> siraben: we can't test your code because there is no cabal file
07:22:09 <siraben> maerwald:  I pushed
07:22:40 <maerwald> You have binaries in the repo
07:22:53 <maerwald> I don't know how much it will download, I'm on mobile
07:23:46 <siraben> maerwald:  Ok, I'll remove the images
07:24:38 <siraben> maerwald:  done
07:27:34 <maerwald> main.hs /= Main.hs
07:27:59 <maerwald> Also, the c code doesn't compile, it has errors
07:28:13 <maerwald> http://dpaste.com/39MT22Q
07:28:30 <siraben> Hm, it compiles on my machine
07:29:05 <siraben> What compiler are you using?
07:29:13 <siraben> Removing static might fix it.
07:30:08 <siraben> Oops, not static, perhaps a malloc call
07:31:49 <maerwald> where is fillPixelBuffer supposed to come from?
07:32:10 <siraben> Haskell
07:32:20 <maerwald> You call it in C
07:32:38 <siraben> Yeah, it's exported by Picture.hs
07:32:39 <lyxia> aveltras: ''ToServant
07:33:04 <maerwald> so you are calling haskell code from C code and then import that code into haskell again?
07:33:15 <aveltras> lyxia: i ended up doing the following in fact
07:33:17 <aveltras> https://www.irccloud.com/pastebin/ZD2EcORd/
07:33:26 <aveltras> ''ToServant gives a parse error here
07:33:48 <siraben> Yeah
07:34:14 <maerwald> How is cabal supposed to know how to do that?
07:34:22 <maerwald> I have never done that
07:34:33 <maerwald> but it is unrelated to pkg-config or sdl
07:35:08 <maerwald> you have circular dependencies between a C and a haskell source files
07:35:10 <siraben> Right. I think pkg-config is done correctly.
07:35:38 <lyxia> aveltras: you can't use a definition in a pattern like that, this binds a fresh variable instead.
07:37:39 <aveltras> lyxia: i have ScopedTypeVariables enabled, does it change anything ? in the end it gives me the api name im looking for here
07:38:10 <aveltras> i end up with "Main.SubAPI"
07:38:39 <lyxia> well if it works, you can drop the definition
07:39:23 <aveltras> what do you mean by "drop the definition" ?
07:41:59 <siraben> maerwald:  So what would be a potential solution?
07:42:30 <maerwald> I'm not sure that's even something supported at all.
07:42:45 <lyxia> aveltras: remove line 1 of your last paste because line 3 does not use it
07:44:38 <aveltras> lyxia: oh you're right yes, thanks
07:45:02 <aveltras> hope that's the only way t get two ConT in an AppT with servant
07:53:49 * hackage dice-entropy-conduit 1.0.0.3 - Cryptographically secure n-sided dice via rejection sampling  https://hackage.haskell.org/package/dice-entropy-conduit-1.0.0.3 (PeterRobinson)
08:01:51 <maerwald> merijn: there https://git.io/JfCQm
08:02:19 <siraben> For some reason, when I call randomRIO (0,1) :: Float in the repl, it gives me different numbers, but when I run it in my compiled binary, the numbers are the same.
08:02:32 <siraben> Perhaps it may be something to do with the fact that this function gets called via C
08:03:50 * hackage burrito 1.1.0.0 - Parse and render URI templates.  https://hackage.haskell.org/package/burrito-1.1.0.0 (fozworth)
08:07:23 <siraben> Ah, d'oh I was using rand() in C which updates every second
08:10:37 <hpc> one random number per second should be enough for anyone
08:12:40 <siraben> Perlin noise :P
08:16:39 <wavemode__> sometimes you only need one random number in total: https://xkcd.com/221/
08:24:20 * hackage secret-sharing 1.0.1.1 - Information-theoretic secure secret sharing  https://hackage.haskell.org/package/secret-sharing-1.0.1.1 (PeterRobinson)
08:34:04 <merijn> rand() doesn't update every second
08:34:08 <merijn> It updates every call
08:36:15 <wavemode_> but you still have to seed it with srand(time()), generally
08:48:55 <pie_> is this anything fancy? newtype Task  c k v = Task (forall f. c f => (k -> f v) -> f v)
08:49:04 <pie_> i cant tell if this would be an instance of QuantifiedConstraints
08:49:14 <pie_> because its just a newtype not a class instance?
08:50:17 <hpc> pretty sure it's something when c = Functor
08:51:04 <sm[m]> johnw: maerwald said fully static binaries on mac aren't possible I think
09:02:49 * hackage neuron 0.4.0.0 - Haskell meets Zettelkasten, for your plain-text delight.  https://hackage.haskell.org/package/neuron-0.4.0.0 (sridca)
09:09:16 <merijn> sm[m]: That sounds odd. Why not?
09:09:36 <merijn> sm[m]: They're not possible on linux due to glibc's insanity, but I don't know why they wouldn't be on macOS?
09:47:29 <olavx200> What does this code let (Just action) = expr do?
09:48:02 <Rembane> olavx200: It pattern matches on a Maybe and will fail horribly if expr is Nothing. 
09:48:59 <pie_> is there any way to get GHCi to expand type synonyms?
09:49:44 <olavx200> Okay. So it assigns expr to action and fails if expr is nothing
09:50:13 <wavemode_> olavx200: if `expr` is (Just 5) then it binds `action` to be 5. if `expr` is Nothing then it throws an exception
09:52:39 <ski> olavx200 : fwiw, those brackets are redundant
09:55:22 <olavx200> Alright. I think I understand. Thanks for helping me.
10:00:16 <monochrom> The surprise is "x@(Just _) = Nothing" then x is bottom. :)
10:01:58 <ski> > let x@Nothing = Just () in x
10:01:59 <lambdabot>  *Exception: <interactive>:3:5-23: Non-exhaustive patterns in x@Nothing
10:02:01 <ski> > let x@ ~Nothing = Just () in x
10:02:03 <lambdabot>  Just ()
10:07:06 <maerwald> sm[m]: correct
10:08:21 <maerwald> see https://stackoverflow.com/questions/5259249/creating-static-mac-os-x-c-build
10:08:29 <maerwald> "Static linking of user binaries is not supported on Mac OS X."
10:09:25 <maerwald> merijn: ^
10:09:57 <monochrom> "think of the children" :)
10:11:12 <maerwald> don't have children (at least not knowingly)
10:11:31 <maerwald> mac is really the worst platform for toolchain :)
10:11:43 <maerwald> should never have been more than a desktop OS
10:12:26 <maerwald> brew completes the mess of linking
10:13:30 <maerwald> And then: https://github.com/haskell-hvr/lzma/issues/21
10:13:33 <monochrom> I almost bought a macbook.
10:13:58 <maerwald> monochrom: well, the hardware is nice. Just install some linux on it.
10:14:20 <monochrom> heh
10:14:30 <maerwald> (wonder if that is legal, though)
10:15:56 <monochrom> But I was going for macos x, not the hardware.
10:16:24 <maerwald> well, GHC works better on mac than on FreeBSD, at least
10:17:17 <maerwald> Almost rage-quitted linux 2 weeks ago and was about to go for FreeBSD again, but then I remembered the pain...
10:17:24 <monochrom> I had colleagues (a prof and some fellow grad students) reporting to be very happy with macos x, so I thought "one day when I become rich I'll go that way too, for now I settle with ubuntu".
10:17:59 <monochrom> Then I met Haskell and came here and saw you guys suffered macos x, so the plan was slashed. :)
10:18:27 <maerwald> http://gregorkopf.de/blog/posts/ghc_ino64.html there
10:18:43 <monochrom> But I do like the touchbar, despite all the hate from other people.
10:18:45 <hpc> all i needed to be pushed away from osx was to try and use it for 5 minutes
10:19:08 <maerwald> tldr: there's zero portability between FreeBSD releases and your code may do the wrong thing.
10:20:17 <berndl> monochrom: What do you like about the touchbar?
10:20:47 <monochrom> It's programmable context-switching keys.
10:21:10 <monochrom> Possibly in other words every reason people hate it is exactly why I like it.
10:21:24 <sm[m]> maerwald: https://github.com/hasufell/hsfm is yours ? That's cool, I did not know you did gui apps
10:22:15 <monochrom> It is also context-switching key labels.  Thinking of F1-F10 but actually meaningful DSL names.
10:22:42 <maerwald> sm[m]: I do, also in rust
10:22:58 <maerwald> I wanted to rewrite it in gtk-gio or so
10:23:04 <maerwald> because I use the deprecated gtk bindings
10:23:05 <berndl> I wish the all the keys on the keyboard had context-switching labels. That would rock.
10:23:11 <sm[m]> monochrom: I use a mac, and would recommend it.. there's toolchain hassles everywhere
10:23:42 <maerwald> sm[m]: but these days I have more interest in terminal filemanagers (I dislike all of them)
10:24:35 <monochrom> haha is this ironic recommendation hour :)
10:25:11 <maerwald> IMO, the primary thing of a filemanager should be: fast navigation. *operations* I do in terminal anyway. There's no filemanager that has instant type-filter behavior etc.
10:25:19 <monochrom> "I recommend mac, its toolchain is an uphill battle"  "terminal filemanagers are fascinating, they all suck"
10:25:26 <maerwald> lol
10:25:54 <maerwald> you know something is good when you complain about it...
10:26:40 <sm[m]> I didn't say mac toolchain is a battle.. it's "fine", really. More hassle than linux, less than other unix/architectures, much less than windows, I'd say
10:27:18 <sm[m]> you can do nix, or brew, or macports, or that netbsd pkg tool that's cross platform, or...
10:27:29 <maerwald> sm[m]: nix isn't that much fun on mac anymore :)
10:27:47 <berndl> Anybody use nixos?
10:27:56 <maerwald> Can't say I didn't chuckle reading the /nix not writable on Catalina issue.
10:27:56 <sm[m]> fun is not a word I would never have used :)
10:28:27 <sm[m]> but I did get /nix working on Catalina, it's actually easy, the hard part was just digging through the dozen scary recommendations
10:30:03 <sm[m]> monochrom: and if you include gui tools in "toolchain".. these are very rich on mac
10:30:22 * sm[m] just discovered pixelmator pro for graphics
10:31:57 <sm[m]> maerwald: so you're not an emacs user ? emacs dired has been my main file manager for a long time I guess.. I don't even notice it
10:32:21 <maerwald> sm[m]: I tried spacemacs once and then got the plague. You hit a key and don't know what it does 80% of the time.
10:32:30 <sm[m]> yes
10:32:37 <maerwald> with vim I don't know what a key does ~30% of the time
10:32:39 <maerwald> which is a little less
10:36:35 * sm[m] does C-h k or C-h l to find out
10:37:13 <kuribas> is there a semigroup newtype into which I can lift a function?
10:37:19 <maerwald> sm[m]: I wanted to write a plugin that monitors your key presses over time and starts disabling key bindings you don't use
10:37:23 <kuribas> so mappend becomes the function?
10:45:38 <lyxia> kuribas: are you looking for Endo
10:46:14 <kuribas> not really... I think it doesn't work what I wanted...
10:51:49 * hackage utf8-conversions 0.1.0.2 - A string conversion library that assumes utf8  https://hackage.haskell.org/package/utf8-conversions-0.1.0.2 (chemirea)
10:51:59 <kuribas> I better make a newtype with the mappend that I want
10:52:18 <dsal> kuribas: can you give an example of the code you wish worked?
10:52:55 <kuribas> like [Just x, Just y] => Just (f x y)
10:53:03 <kuribas> [Just x, Nothing] = > Just x
10:54:09 <kuribas> But I can make a Semigroup newtype which has (<>) = f
10:56:46 <dsal> It does seem like a reasonable thing to exist.
10:57:04 <wavemode> It looks dependently typed
10:57:34 <kuribas> no, because the f would be different between values
10:57:58 <kuribas> the only way to fix the f between values is to make a newtype with semigroup instance.
10:59:35 <solonarv> note that mconcat [Just x, Just y] = Just (x <> y) already
11:00:05 <solonarv> so yes, if you just make a Semigroup instance with (<>) = f that'll work
11:01:50 * hackage rbst 0.0.0.1 - Randomized Binary Search Trees  https://hackage.haskell.org/package/rbst-0.0.0.1 (ArnauAbella)
11:04:21 <fresheyeball> so I am getting ready to publish to hackage
11:04:26 <fresheyeball> and I get this in `cabal check`
11:04:31 <fresheyeball> Warning: Hackage would reject this package.
11:04:37 <fresheyeball> but not why
11:04:42 <fresheyeball> I have no errors
11:04:53 <fresheyeball> I also get this suspicous warning
11:04:55 <fresheyeball> Warning: The following errors will cause portability problems on other
11:04:58 <fresheyeball> environments:
11:05:04 <c_wraith> you can always do a test upload to hackage and see what it reports
11:08:16 <fresheyeball> Shpadoinkle-0.0.0.1/Shpadoinkle.cabal:41:0: [v2.0] 'then' branch of 'if' is empty
11:08:24 <fresheyeball> invalid package
11:08:29 <fresheyeball> atleast that error is helpful
11:10:17 <maerwald> fresheyeball: cabal should tell you the reason it would reject
11:10:24 <maerwald> can you show the full output in a pastebin?
11:11:12 <fresheyeball> maerwald: it gave warnings
11:11:20 <fresheyeball> but not the one I saw on hackage when uploading the candidate
11:11:35 <maerwald> show it then
11:13:26 <fresheyeball> https://gitlab.com/snippets/1975195
11:13:30 <fresheyeball> maerwald: ^^
11:14:33 <maerwald> did you try removing Werror?
11:14:48 <fresheyeball> maerwald: yes
11:15:06 <fresheyeball> now if I run cabal check I get
11:15:06 <maerwald> and?
11:15:09 <fresheyeball> No errors or warnings could be found in the package.
11:15:15 <maerwald> and can you upload that?
11:15:18 <fresheyeball> but uploading to hackage gets
11:15:26 <maerwald> did you rerun "cabal sdist"?
11:15:29 <fresheyeball> Shpadoinkle-0.0.0.1/Shpadoinkle.cabal:41:0: [v2.0] 'then' branch of 'if' is empty
11:15:32 <fresheyeball> yes
11:16:02 <maerwald> maybe fix that then
11:16:09 <fresheyeball> I just did and it worked
11:16:15 <djanatyn> i've been using GDB to poke at memory addresses of super mario 64, and i wanted an application to display certain memory locations from an attached process continuously. what's a good library to do that? (i was looking at hgdbmi
11:16:21 <fresheyeball> but still, I think cabal check should have caught that
11:16:29 <djanatyn> is there a general purpose library for attaching to a process and inspecting the memory live?
11:17:26 <maerwald> fresheyeball: maybe hackage runs cabal check with a different cabal version?
11:17:34 <fresheyeball> that would make sense
11:17:56 <fresheyeball> still this was very confusing
11:18:12 <fresheyeball> and I still don't know what the error mentioning probabilities was about
11:22:02 <fresheyeball> grr howcome it no haddock
11:50:20 * hackage Shpadoinkle 0.0.0.1 - A programming model for declarative, high performance, user interface.  https://hackage.haskell.org/package/Shpadoinkle-0.0.0.1 (fresheyeball)
11:57:16 <hpc> what a package name
11:58:07 <koz_> hpc: Well, it's not that different to some of the stuff I see.
11:58:23 <koz_> It's like, there's some kind of unwritten rule that Haskell packages must involve wordplay or something.
11:58:29 <koz_> Or some kind of reference.
11:58:33 <koz_> The more obscure the better.
11:59:00 <maerwald> @hackage barbies
11:59:00 <lambdabot> http://hackage.haskell.org/package/barbies
11:59:15 <amf> (using megaparsec), if i have something like `x { s1 \n s2 \n s3 }` and i wanted to allow s{1,2,3} to be in any order what would be the best approach. each s will really be a `unique_key=value`. try and <|> don't see ideal
12:00:46 <koz_> amf: Will you always have exactly 3?
12:01:52 <amf> yeah. my data type is `data S = S Int Int Int` but the right number must go in the right "slot"
12:02:30 <amf> i naively thought it would work with applicative, but if i reorder: `s2 \n s1 \n` megaparsec obviously complains
12:03:36 <koz_> amf: So like, replicateM won't fit your needs?
12:03:38 <koz_> :t replicateM
12:03:40 <lambdabot> Applicative m => Int -> m a -> m [a]
12:05:18 <amf> yeah i dont think so, the real data is something like s1=v s2=1 s3=3.5. it looks like a config file where order doesn't matter inside the {} blocks
12:11:09 <Cale> amf: I think the solution will be to parse (field-name, value) pairs, accumulate them in a Data.Map or something until you have them all, and then see if you have everything you need at the end as you build the S x y z by looking up the appropriate keys
12:12:05 <amf> yep. doi. that sounds a lot simpler
12:12:19 * hackage hie-bios 0.5.0 - Set up a GHC API session  https://hackage.haskell.org/package/hie-bios-0.5.0 (fendor)
12:12:20 * hackage reflex-vty 0.1.4.0, reflex 0.7.1.0 (3noch): https://qbin.io/buy-merit-lkpz
12:12:21 * hackage xml-conduit-stylist 2.2.0.0, stylist 2.2.0.0 (alcinnz): https://qbin.io/chi-chip-dmrb
12:12:21 * hackage postgresql-syntax 0.2.0.1 - PostgreSQL AST parsing and rendering  https://hackage.haskell.org/package/postgresql-syntax-0.2.0.1 (NikitaVolkov)
12:12:21 * hackage plzwrk 0.0.0.8, plzwrk 0.0.0.7, plzwrk 0.0.0.6 (mikesol)
12:12:23 * hackage calamity 0.1.6.0 - A library for writing discord bots  https://hackage.haskell.org/package/calamity-0.1.6.0 (nitros12)
12:12:25 * hackage digestive-functors-happstack 0.6.1.3, digestive-functors 0.8.4.2 (JasperVanDerJeugt): https://qbin.io/nc-ac-wnx9
12:12:27 * hackage Shpadoinkle 0.0.0.1 - A programming model for declarative, high performance user interface.  https://hackage.haskell.org/package/Shpadoinkle-0.0.0.1 (fresheyeball)
12:12:29 * hackage hw-balancedparens 0.4.1.0 - Balanced parentheses  https://hackage.haskell.org/package/hw-balancedparens-0.4.1.0 (haskellworks)
12:12:30 * hackage earcut 0.1.0.2, earcut 0.1.0.1 (DavidHimmelstrup): https://qbin.io/atom-munich-3ed4
12:12:32 * hackage knit 0.1.0.0 - Ties the knot on data structures that reference each other by unique keys.  https://hackage.haskell.org/package/knit-0.1.0.0 (pkamenarsky)
12:12:33 * hackage neuron 0.4.0.0, rib 0.10.0.0 (sridca): https://qbin.io/butt-rhode-2bnk
12:12:35 * hackage dhall 1.32.0, dhall-nix 1.1.14, dhall-bash 1.0.30, dhall-yaml 1.1.0, dhall-json 1.6.4, dhall-lsp-server 1.0.7 (GabrielGonzalez)
12:12:37 * hackage bv-sized 1.0.0 - a bitvector datatype that is parameterized by the vector width  https://hackage.haskell.org/package/bv-sized-1.0.0 (benselfridge)
12:12:39 * hackage log-base 0.8.0.1, log-postgres 0.7.1.3 (arybczak): https://qbin.io/eagle-forest-j7wx
12:12:41 * hackage servant-docs-simple 0.2.0.1 - Generate endpoints overview for Servant API  https://hackage.haskell.org/package/servant-docs-simple-0.2.0.1 (HolmuskTechTeam)
12:12:42 * hackage burrito 1.1.0.0 - Parse and render URI templates.  https://hackage.haskell.org/package/burrito-1.1.0.0 (fozworth)
12:12:44 * hackage retrie 0.1.1.0 - A powerful, easy-to-use codemodding tool for Haskell.  https://hackage.haskell.org/package/retrie-0.1.1.0 (AndrewFarmer)
12:12:46 * hackage tokyocabinet-haskell 0.0.6 - Haskell binding of Tokyo Cabinet  https://hackage.haskell.org/package/tokyocabinet-haskell-0.0.6 (StephenWeber)
12:12:48 * hackage barbies-th 0.1.2, deriving-aeson 0.2.5 (FumiakiKinoshita): https://qbin.io/oxford-rom-ll1e
12:12:50 * hackage json-api-lib 0.2.1.0 - Utilities for generating JSON-API payloads  https://hackage.haskell.org/package/json-api-lib-0.2.1.0 (shirren)
12:12:51 * hackage hlint 3.1 - Source code suggestions  https://hackage.haskell.org/package/hlint-3.1 (NeilMitchell)
12:12:53 * hackage bz2 1.0.0.3 - Bindings to libbz2  https://hackage.haskell.org/package/bz2-1.0.0.3 (vmchale)
12:12:54 * hackage massiv 0.5.2.0 - Massiv (Массив) is an Array Library.  https://hackage.haskell.org/package/massiv-0.5.2.0 (lehins)
12:12:56 * hackage hpath-io 0.13.2, hpath-directory 0.13.4, streamly-posix 0.1.0.1 (maerwald)
12:12:57 * hackage secret-sharing 1.0.1.1, dice-entropy-conduit 1.0.0.3 (PeterRobinson): https://qbin.io/firm-logan-zr4n
12:12:59 * hackage headroom 0.2.2.1 - License Header Manager  https://hackage.haskell.org/package/headroom-0.2.2.1 (xwinus)
12:13:00 * hackage capnp 0.6.0.0 - Cap'n Proto for Haskell  https://hackage.haskell.org/package/capnp-0.6.0.0 (isd)
12:13:01 * hackage moto-postgresql 0.0.2, moto 0.0.4, libsodium 1.0.18.0 (RenzoCarbonara)
12:13:03 * hackage ref-extras 0.1.0, little-rio 0.1.1, aeson-via 0.1.0, infernal 0.5.0, little-logger 0.1.0, little-rio 0.1.0, infernal 0.4.0 (ejconlon)
12:13:05 * hackage rbst 0.0.0.1, rbst 0.0.0.0 (ArnauAbella): https://qbin.io/remain-smell-xova
12:13:07 <mmaruseacph2> is the bot broken?
12:13:07 * hackage haskoin-store 0.26.0, haskoin-store-data 0.26.0, haskoin-store 0.25.4, haskoin-store-data 0.25.4, haskoin-store 0.25.3, haskoin-store-data 0.25.3, haskoin-store 0.25.2, haskoin-store-data 0.25.2, haskoin-store 0.25.1, haskoin-store-data 0.25.1, haskoin-store-data 0.25.0, haskoin-node 0.13.0, haskoin-core 0.13.3, haskoin-core 0.13.2 (jprupp)
12:13:08 * hackage dobutokO2 0.39.0.1, dobutokO2 0.39.0.0 (OleksandrZhabenko): https://qbin.io/stays-lift-lqdm
12:13:10 * hackage yamlparse-applicative 0.1.0.0 - Declaritive configuration parsing with free docs  https://hackage.haskell.org/package/yamlparse-applicative-0.1.0.0 (Norfair)
12:13:12 * hackage faktory 1.0.1.2 - Faktory Worker for Haskell  https://hackage.haskell.org/package/faktory-1.0.1.2 (PatrickBrisbin)
12:13:14 * hackage addy 0.1.0.0 - A full-featured library for parsing, validating, and rendering email addresses  https://hackage.haskell.org/package/addy-0.1.0.0 (PeterJones)
12:13:15 * hackage utf8-conversions 0.1.0.2, utf8-conversions 0.1.0.1, utf8-conversions 0.1.0.0 (chemirea)
12:14:09 <dsal> Anyone have any updates on all of hackage?
12:17:39 <amf> Cale: yep that was easy, thanks for the nudge!!
12:20:10 <Cale> amf: great!
12:25:41 <sm[m]> paging mniip ^
12:26:12 <sm[m]> djanatyn: ekg
12:44:49 * hackage plzwrk 0.0.0.9 - A front-end framework  https://hackage.haskell.org/package/plzwrk-0.0.0.9 (mikesol)
12:49:14 <fresheyeball> can I make haddock comments in TH?
13:04:19 * hackage Shpadoinkle-html 0.0.0.1 - A typed, template generated Html DSL, and helpers.  https://hackage.haskell.org/package/Shpadoinkle-html-0.0.0.1 (fresheyeball)
13:11:50 * hackage skylighting-core 0.8.4 - syntax highlighting library  https://hackage.haskell.org/package/skylighting-core-0.8.4 (JohnMacFarlane)
13:12:49 * hackage skylighting 0.8.4 - syntax highlighting library  https://hackage.haskell.org/package/skylighting-0.8.4 (JohnMacFarlane)
13:28:45 <dsal> Is there a lens magic for filtering things based on a prism?  e.g.   [A 1, B 2, C 3] ^.. {something}    -->  [A 1,  C 3]
13:29:12 <fgaz> Which is faster, String or ShortText if my strings are up to 1000 chars but 99% of the time just 10 chars and they are consumed just after being created?
13:29:17 <dsal> It's easy to, e.g.      l ^.. folded . _B   to get [2]
13:29:28 <dsal> fgaz: criterion
13:31:05 <fgaz> dsal: Well yes but I guessed I'd ask before writing benchmarks. Sounds like a thing someone here may have tried already
13:31:10 <dsal> I'm currently doing      l & properties %~ functionThatMatchesAgainstOneThing
13:31:22 <dsal> fgaz: It's going to matter a good deal on what you're doing and how you're doing it.
13:34:46 <fgaz> Makes sense... oh well it shouldn't be a bottleneck for now so as long as the difference isn't enormous I guess I'll stick with the most consistent one
13:37:19 * hackage Shpadoinkle-backend-static 0.0.0.1 - A backend for rendering Shpadoinkle as Text.  https://hackage.haskell.org/package/Shpadoinkle-backend-static-0.0.0.1 (fresheyeball)
13:47:35 <phadej> fgaz: really depends on how they are constructed and consumed
13:47:42 <phadej> conversions are costly
13:48:11 <phadej> but then also replace '-' with '_' is of different complexity for both
13:49:20 <phadej> My gut feeling is that ShortText is faster for "immutable" text (like identifiers) because the memory pressure is less
13:49:54 <phadej> even the strings are consumed soon after they are created, generating less garbage is beneficial
13:51:20 <phadej> https://github.com/haskell/cabal/pull/6367 has some benchmarks
13:54:28 <phadej> it's bad benchmark as the change also made "return gpd1" -> "gpd1 `deepseq` return gpd1" change
13:54:51 <phadej> (and the (:) constructors in the after results are probably from FilePath)
13:55:15 <phadej> but the heap profiles become lower - and thus narrower
14:00:33 <fgaz> phadej: thanks
14:10:15 <Uniaika> mpickering: very nice article, thank you very much!!
14:11:06 <mpickering> It wasn't me but Luke!
14:11:32 <mpickering> I just made the website
14:11:48 <ski> (article ?)
14:11:52 <mpickering> thanks for reading it
14:13:47 <slack1256> Has somebody done a turtle script that integrates with fzf?
14:15:08 <Uniaika> ski: https://mpickering.github.io/ide/posts/2020-05-08-state-of-haskell-ide.html
14:16:49 * hackage Shpadoinkle-backend-pardiff 0.0.0.1 - A Virtual Dom in pure Haskell, based on Html as an Alignable Functor.  https://hackage.haskell.org/package/Shpadoinkle-backend-pardiff-0.0.0.1 (fresheyeball)
14:36:47 <ski> Uniaika : ty
14:37:19 <Uniaika> np
14:42:20 * hackage haskoin-store-data 0.26.1 - Data for Haskoin Store  https://hackage.haskell.org/package/haskoin-store-data-0.26.1 (jprupp)
14:43:20 * hackage haskoin-store 0.26.1 - Storage and index for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-store-0.26.1 (jprupp)
14:43:43 <thebat> hi
14:44:45 <dsal> Oh man, I was just getting to like thebat
14:45:34 <Uniaika> :(
14:45:37 <Uniaika> he left us too soon
14:45:58 <ski> > superT == thebat
14:45:59 <lambdabot>  True
14:46:45 <dsal> I started writing  mqtt v5 broker from scratch this week.  It's super close to feature complete.  Might be nice to replace all my mosquitto instances.
14:46:49 * hackage Shpadoinkle-widgets 0.0.0.1 - A collection of common reusable types and components.  https://hackage.haskell.org/package/Shpadoinkle-widgets-0.0.0.1 (fresheyeball)
14:46:52 <dsal> thebat has returned!
14:46:52 <ski> hello thebat
14:46:57 <mniip> hmm
14:47:43 <thebat> hello dsal
14:47:52 <wavemode> the first thing I do in any irc client is disable join/part messages. so I never know what you guys are talking about :p
14:47:56 <mniip> I'm gonna implement a radical solution to the bot issue
14:48:10 <ski> then how can you know time is passing, wavemode ?
14:48:38 <wavemode> circadian rhythm
14:49:02 <dsal> Is there a lensier way to write   `%~ fmap (const x)`     ?  That seems dumb.
14:49:13 <ski> thebat : have any question ?
14:50:00 <dsal> > [Right 1, Right 2, Left 3, Right 4] & partsOf (traversed . _Left) %~ fmap (const 9)
14:50:03 <lambdabot>  [Right 1,Right 2,Left 9,Right 4]
14:53:11 <ski> > [Right 1, Right 2, Left 3, Right 4] & partsOf (traversed . _Left) . mapped .~ 9
14:53:13 <lambdabot>  [Right 1,Right 2,Left 9,Right 4]
14:53:24 <dsal> Ah.  That makes sense.  Thanks.
14:54:20 * hackage typed-encoding 0.2.1.0 - Type safe string transformations  https://hackage.haskell.org/package/typed-encoding-0.2.1.0 (rpeszek)
14:55:57 <ski> > [Right 1, Right 2, Left 3, Right 4] & traversed . _Left .~ 9
14:55:59 <lambdabot>  [Right 1,Right 2,Left 9,Right 4]
14:56:18 <dsal> Wait.  Clearly I don't know what I'm doing.
14:56:54 <mniip> aha
14:56:57 <mniip> this was a different problem
14:57:12 <ski> hackage ?
14:57:16 <mniip> yeah
14:57:20 <mniip> the RSS didn't return valid XML?
14:57:59 <mniip> and it failed to parse until the problematic package was rotated out of the "recent" list, at which point the entire list was "new"
15:10:45 <mniip> shoulda added more logging
15:10:49 <mniip> I have no idea what the failure was
15:13:42 <mniip> ah I'm not sure if this is something I can log
15:15:12 <shafox> What is the preferred way to install ghc/cabal in  archlinux ? 
15:15:27 <dsal> AFAICT, rm -rf /
15:17:55 <hpc> shafox: ghcup, probably?
15:18:06 <yushyin> shafox: ghcup
15:23:09 <solonarv> ghcup, and emphatically *not* the system packages
15:23:14 <solonarv> @where ghcup
15:23:14 <lambdabot> https://www.haskell.org/ghcup/
15:24:02 <iqubic> You're only allowed to use the system packages if your system is Nix.
15:24:20 <iqubic> Otherwise you will be getting highly outdated versions of packages.
15:24:24 <solonarv> heh
15:24:41 <solonarv> you can also use hvr's PPA if you want
15:25:27 <iqubic> I don't use any debian based systems, so I didn't know that existed.
15:25:55 <solonarv> I do but I still use ghcup
15:26:22 <iqubic> I'm on nixos, and I've got my own system that I like using.
15:32:14 <mniip> let's see if this works
15:39:31 <p0a> siraben: you don't get 1 number per second
15:39:53 <p0a> siraben: what happens is that the binary seeds with time
15:44:39 <shafox> iqubic, is nix a solution to install and work on haskell projects ? 
15:55:32 <solonarv> it's not haskell-specific, but it can be used that way
16:01:36 <maerwald> shafox: for local development? I'd say no. For deployment, yeah, if you need reproducible config.
16:03:38 <shafox> maerwald, for local development. kind of confused on how to setup my system. just want to go with one that works as in with my emacs and also doesnt let me stop working. 
16:04:12 <maerwald> nix is big investment, not a quick solution
16:04:18 <sm[m]> mniip: I found that transient malformed feed content is pretty common. It’s hard to ensure the bot never gives wrong output no matter what
16:04:41 <mniip> do you know what causes it?
16:04:54 <shafox> maerwald, yeah. i was looking at the documentation it is not straightforward to setup an env and start working. 
16:04:57 <mniip> some package having wacky stuff in description/synopsis?
16:05:08 <mniip> if so that sounds like a bug that can be reported to hackage-server
16:05:20 <sm[m]> For hackage ? No, it’s just something to expect of all feeds I think
16:05:25 <maerwald> shafox: documentation is mostly non-existent, except for the basics 
16:05:51 <sm[m]> you can never assume valid stable correct feed content on every poll
16:06:15 <shafox> maerwald, my options are ghcup (which sets up ghc and then install cabal-install) or go with stack. 
16:06:47 <maerwald> stack confines you to a package set (stackage), which can be desirable if you have such requirements
16:06:52 <maerwald> otherwise, I wouldn't go with it
16:07:01 <sm[m]> (And yes, certainly worth reporting/investigating upstream if you have the data logged)
16:07:32 <sm[m]> It doesn’t, maerwald
16:07:41 <maerwald> sm[m]: they removed stackage?
16:08:33 <sm[m]> you’re not confined. It’s just a default for the install planner
16:08:48 <maerwald> sm[m]: installing packages outside of the set usually causes a lot of trouble
16:08:58 <sm[m]> I pull in stuff from hackage all the time
16:09:29 <maerwald> you're an advanced user anyway
16:09:58 <maerwald> I would say I expect easy access to all packages, as a new user, without concepts of "curated package sets"
16:10:05 <sm[m]> no special trouble, of course it’s less tested than if in stackage
16:10:18 <maerwald> Now you have to learn how to pull in non-stackage packages
16:11:59 <sm[m]> write the version on the command line, or add it to extra-deps; easy
16:12:18 <shafox> i am installing ghcup. will try this. 
16:12:37 <maerwald> sm[m]: yes, you add it to extra-deps and then it tells you "oh, more things missing" :)
16:13:44 <sm[m]> sure, which makes sense
16:13:58 <maerwald> and isn't very user-friendly when all you care about is installing a dependency
16:15:06 <wavemode> depends on the user. maybe a new programmer would be slightly confused I guess. but nobody with experience with build systems should find stack all that confusing
16:15:11 <fresheyeball> https://packdeps.haskellers.com/reverse/Shpadoinkle
16:15:23 <fresheyeball> why the heck does the badge say "out of date"
16:15:31 <fresheyeball> the UI here shows nothing is out dated
16:16:02 <sm[m]> stack and cabal are optimized for different needs, but I wouldnt want us to teach newcomers that stack only lets them use stackage packages
16:16:08 <maerwald> wavemode: I've had programmers (only new to haskell) be very confused by it
16:16:32 <maerwald> sm[m]: that is the default configuration at least and stack is optimised for that use case
16:16:39 <maerwald> if you do something else, you're on your own
16:17:35 <sm[m]> I think you exaggerate the difficulty, but lets just disagree
16:18:55 <mniip> what is a suitable generalization of fibered F-algebras beyond functors that are literal polynomials
16:24:25 <mniip> for a literal polynomial F(X) = X^n + X^k + ..., a fibered algebra over h:FX->X, is a family P:X->Set together with a family of maps P(a_1) x ... x P(a_n) -> P(in_1(a_1, ..., a_n)) for every component in the sum
16:25:01 <mniip> oop
16:25:12 <mniip> -> P(h(in_1(a_1, ... a_n)))
16:28:58 <ski> `X' is some object in some category ?
16:32:00 <mniip> yeah
16:32:08 <mniip> presumably with points (1 -> X)
16:32:11 <ski> `in_k : X^k >---> F X' ?
16:32:19 <mniip> yup
16:32:24 <mniip> well not X^k
16:32:39 <ski> i guess `a_k', for `k' in `{0,..,n}' is the points
16:32:47 <mniip> rather yup
16:32:51 <mniip> yup
16:33:06 <mniip> F(X) = sum_i X^d_i
16:33:16 <mniip> in_i = X^d_i -> FX
16:33:18 <mniip> :
16:33:37 <ski> i'm wondering whether `h' or `P' should be tupled with `X'
16:34:02 <mniip> (X, h) is a regular F-algebra
16:34:25 <ski> ok
16:34:29 <mniip> (P, family of morphisms) is the fibered F-algebra over (X, H)
16:35:21 <ski> `d_i' ?
16:37:00 <remexre> is GHC aarch64 support only via llvm?
16:37:02 <mniip> "dimension" of the ith component of the sum
16:37:36 <ski> oh
16:37:52 <ski> "arity" of the `i'th operation, i suppose
16:37:57 <mniip> yeah
16:38:27 <mniip> consider F(X) = 1 + X, a
16:38:39 <mniip> an algebra is h:1+X -> X
16:38:43 <ski> (for some reason, i thought you were going `sum_{k = 0}^n X^k', initially .. although for some reason, without coefficients)
16:38:49 <mniip> ah no
16:38:52 <ski> yes
16:39:02 <ski> (was thrown off, by thinking about polynomials)
16:39:31 <mniip> so uh we have P:X->Set, and we're looking for two maps: 1 -> P(h(inl(*))) and P(x) -> P(h(inr(x)))
16:41:37 <mniip> we could form a "hom-set" of homomorphisms from (X, h) to (P, ...)
16:42:28 * ski . o O ( `data NatS :: Nat -> * where ZeroS :: NatS Zero; SuccS :: forall (n :: Nat). NatS n -> NatS (Succ n)' )
16:44:27 <mniip> ugh this is tough to formulate without dependent types
16:44:28 <ski> not a normal `Hom', right ?
16:44:42 <mniip> no, it's not a category
16:46:14 <ski> i don't really have a good grasp of the fibered stuff, but i think it was related to one representation of dependent stuff, yes ?
16:46:34 <mniip> yeah
16:46:52 <mniip> really we're trying to represent dependent and non-dependent eliminators for inductive types
16:47:09 <mniip> and with non-dependent eliminators the story is clear
16:47:20 <mniip> it's the universal morphism from the initial algebra in the category of algebras
16:47:46 <mniip> dependent stuff is tricky though
16:47:48 <ski> yes
16:48:30 <mniip> this paper, definitions 19-27: http://reports-archive.adm.cs.cmu.edu/anon/2016/CMU-CS-16-125.pdf
16:48:32 <ski> i'm wondering whether there's any sensible way to have the argument type depend on the return continuation ..
16:49:29 <mniip> W is "the" class of suitably general functors that are "literally" polynomials
16:49:54 <mniip> there's an A-sized family of cardinalities B(a)
16:50:08 <mniip> and you take  FX = sum_(a in A) X^B(a)
16:52:48 <ski> hm, not sets `B(a)' ?
16:52:58 <mniip> well, types, really
16:53:11 <ski> i figured those were ordered, not unordered, tuples
16:53:21 <mniip> ordered yes
16:53:53 <mniip> this paper is written in some HoTT-lite/MLTT theory
16:54:53 <mniip> hmm
16:55:19 <mniip> does FX=Hom(Hom(X,2),2) have an initial algebra in Set
16:55:30 <ski> (hm, i suppose if you raise a set (or type) to a cardinality, you'd get a set/type of unordered tuples .. does that make sense ?)
16:55:53 <mniip> (yeah I didn't mean a cardinality in that sense)
16:56:44 <mniip> it violates strict positivity condition, and this particular example can derive a contradiction in MLTT iirc
16:57:35 <ski> hm, for some reason i'm reminded of bar induction
17:01:25 <ski> if we imagine `data X = Mk ((X -> Bool) -> Bool)', we could form `Mk (\_ -> False)',`Mk (\_ -> True)',`Mk (\k -> k (Mk (\_ -> False)))',`Mk (\k -> not (k (Mk (\_ -> False))))',...
17:07:51 <ski> `(Nat -> Bool) -> Bool' could be thought of as a tree `data T = Const Bool | Branch T T', with the additional law `Branch x x = x'
17:08:09 <ski> but it seems harder to imagine this (`X' above) as a kind of tree
17:13:50 <mniip> ski, because it isn't
17:13:53 <mniip> it's not a well founded tree
17:14:26 <ski> can't be formulated as one, even with something like bar induction ?
17:16:18 <mniip> I think the initial algebra doesn't exist in Set
17:16:33 <mniip> its existence contradicts standard axioms of ZF
17:16:52 <mniip> you do use LEM and function extensionality though
17:17:54 <ski> hm. ah. i suppose it would contradict Cantor
17:19:11 <mniip> something like that
17:19:15 <mniip> there is a certain diagonalization argument
17:20:28 <ski> i'm reminded of <http://math.andrej.com/2009/10/12/constructive-gem-double-exponentials/>
17:20:36 <nowhere_man> I have a code that would benefit from do-notation but the the type is not parameterized by another type, so I'm not sure how I could make it a Monad… I tried reading Hspec's source code to see how they do it but that's beyond me ATM
17:25:11 <Cale> nowhere_man: Perhaps you only have a monoid?
17:25:35 <Cale> nowhere_man: You might be able to make use of a writer monad
17:25:57 <mniip> ski, yeah that comes to mind
17:26:07 <mniip> effective topos vs topos of sets
17:26:38 <topos> porque no los dos
17:26:44 <Cale> But sometimes artificially introducing that isn't always the best thing. If you can't really take advantage of the ability to return results from subcomputations, I would say keep it simple, and use a monoid or something, and a function which concatenates a list of elements.
17:26:51 <Cale> :t mconcat
17:26:53 <lambdabot> Monoid a => [a] -> a
17:37:07 <wavemode> nowhere_man: it's unclear exactly what you mean. maybe put a code example in a gist
17:43:11 <mniip> ski, here's a coq proof
17:43:31 <mniip> https://gist.github.com/mniip/c608b33bbb04b4280bf5b5195e8d0df7
17:45:11 <mniip> this is basically saying that any type D with a function mkD : PPD -> D that admits a retract (unD) is impossible
17:46:42 <mniip> i.e. the category of algebras of PP has no initial object
17:47:45 <ski> mm
17:51:39 <mniip> this proof is directly transcribed from the HoTT book btw
17:51:46 <mniip> names of variables and all
17:53:45 * hackage utf8-conversions 0.1.0.3 - A string conversion library that assumes utf8  https://hackage.haskell.org/package/utf8-conversions-0.1.0.3 (chemirea)
18:04:42 <siraben> mniip:  Which part of the HoTT book?
18:04:52 <nowhere_man> wavemode: I basically have functions that return a type Result = Success | Errors[Result] | Error1 | Error2
18:04:58 <mniip> siraben, section 5.6
18:05:40 <nowhere_man> Success combined with anything is the latter, and errors get accumulated if there are several
18:06:18 <nowhere_man> Cale: I didn't think of using the writer monad, but it should do what I want, yes
18:07:51 <mniip> nowhere_man, what about Errors [Success]
18:08:05 <mniip> (sounds like you need 2 different datatypes here)
18:08:38 <mniip> also what about Errors []
18:08:55 <mniip> also Success | Errors (NonEmpty Err) is just [Err]
18:09:03 <mniip> which coincidentally has the correct monoid instance alerady
18:28:44 <ironhaven> Is there a dedup function like the posix uniq is the standard library?
18:29:21 <solonarv> do you want to remove *all* duplicates, or only adjacent duplicates?
18:29:32 <ironhaven> just adjacent ones
18:29:40 <ironhaven> there is nub
18:30:01 <ironhaven> but O(n^2) is a little overkill
18:30:25 <solonarv> 'map head . group' works
18:30:35 <solonarv> @let uniq = map head . group
18:30:37 <lambdabot>  Defined.
18:30:38 <solonarv> :t niq
18:30:39 <lambdabot> error:
18:30:40 <lambdabot>     • Variable not in scope: niq
18:30:40 <lambdabot>     • Perhaps you meant ‘uniq’ (line 157)
18:30:41 <solonarv> :t uniq
18:30:42 <lambdabot> Eq b => [b] -> [b]
18:30:51 <ironhaven> cool
18:30:51 <solonarv> > uniq [1, 2,2, 3,3,3 ]
18:30:53 <lambdabot>  [1,2,3]
18:32:05 <wavemode> > uniq [1, 2,2, 1,1, 3,3,3]
18:32:08 <lambdabot>  [1,2,1,3]
18:32:31 <ironhaven> before i came hear i was trying to write my own uniq
18:34:03 <ironhaven> while doing that i wonder if there was a ziplongst that would fill in with a default value or give a maybe if a list was too short
18:34:37 <ironhaven> i tried looking in hoogle but could quite find the right thing
18:34:43 <ironhaven> not
18:37:24 <solonarv> @hackage semialign
18:37:24 <lambdabot> http://hackage.haskell.org/package/semialign
18:37:44 <solonarv> this package has what you probably meant with the "give a maybe if a list was too short" phrase
18:38:18 <solonarv> padZipWith *actually* gives you 'Maybe's
18:39:50 <ironhaven> so did you just remeber that package or how did you search for it?
18:40:27 <Cale> Probably just remembered it
18:40:51 <Cale> I wonder why that stuff got separated from 'these'
18:40:55 <wavemode> though it is the first result if you search "zip pad" on hackage
18:41:39 <ironhaven> I am new so i don't know where to search yet
18:42:19 <solonarv> I remembered it, but searched first to confirm that I was remembering right
18:43:28 <Uniaika> hello there
18:44:00 <ironhaven> One last question for now. Is there some "null" type that nothing is equal to but is compareable?
18:44:00 <Uniaika> ironhaven: fun fact, I can *never* remember the name "nub"
18:44:02 <MarcelineVQ> probably just that  these  is useful enough on its own
18:44:10 <Uniaika> so yeah 6 months I'm googling "uniq in haskell"
18:44:30 <Uniaika> *so yeah, every 6 months
18:44:40 <Uniaika> (better with all the words)
18:45:13 <toni37> hello
18:45:23 <Uniaika> ironhaven: there is no "null" type that are devoid of association to types
18:45:38 <Uniaika> like, you can't fall in the null trap
18:46:04 <ironhaven> I guess i am askting for a type named "HaHa try to comapre to me but i will allways say no"
18:46:04 <Uniaika> it has to be part of a bigger type that the compiler will tell you about
18:46:25 <Uniaika> ironhaven: oh well, IEEE754 NaN works :D
18:46:26 <ironhaven> I don't need a null
18:46:33 <wavemode> ironhaven: the haskell equivalent to something that can be null or not-null is Maybe (Just or Nothing)
18:46:41 <monochrom> You cannot compare values from two different types.
18:46:45 <toni37> i'm looking for some examples of cpu formal verification and i noticed that some fellows implemented RISC-V in F# and they say that they formally prove the correctness of the cpu just by implementing into some functional language
18:46:53 <monochrom> Well, not with the standard ==
18:47:46 <toni37> now i'm looking into isabelle example and it looks just like haskell, so if i want to build a formal specification of a cpu, what should i do?
18:47:47 <wavemode> > Just 5 == Just 5
18:47:50 <lambdabot>  True
18:47:53 <monochrom> You can define your own type class to support comparing values from two types, but I doubt anyone would care.
18:47:53 <wavemode> > Just 5 == Just 10
18:47:56 <lambdabot>  False
18:48:00 <wavemode> > Just 10 == Nothing
18:48:02 <lambdabot>  False
18:48:25 <ironhaven> I guess that was right infront of me
18:50:25 <dmj`> Is there a way to translate the type level representation of a  any Sum type to a value that is a Product type, where the fields in the product have the same value as the each Sum type constructor. So for example, data Foo = Bar | Baz Int becomes data Result = Result { bar :: Foo, baz :: Int -> Foo } with inhabitant valueResult = Result Foo Baz
18:54:35 <dmwit> toni37: well
18:54:49 <dmwit> toni37: That's a pretty big project, so you should have some plan for what you want to do with that formal specification.
18:56:18 <dmwit> toni37: Like, if your plan is to fab one, probably you should use something like bluespec, not isabelle.
19:00:32 <lyxia> dmj`: that certainly looks feasible
19:05:11 <dmj`> lyxia: yea, but it has to expand into an inductively defined tuple, or some other already-defined product type whose fields align with the sum types
19:05:32 <dmj`> lyxia: and it should be done with GHC.Generics
19:06:15 <mniip> dmj`, I had a similar problem recently
19:06:20 <mniip> albeit more cimplicated
19:06:35 <mniip> ah!
19:07:26 <mniip> yours is like Result = Foo -> Foo
19:08:43 <dmj`> mniip: yea, I'm trying to take a sum type that represents a web route and put it into a record
19:09:23 <mniip> so you're trying to encode (A + B) -> X as (A -> X) x (B -> X)
19:09:34 <dmj`> yes, exactly
19:09:52 <mniip> Sounds like something Generic can do
19:10:05 <mniip> (regrettably)
19:13:49 <toni37> dmwit: let's move to private
19:20:13 <dmj`> mniip: I need to make F, R, per this gist. https://gist.github.com/dmjio/483e42ab3bea9b9ba832549871952452
19:24:30 <dmj`> mniip: the rewrite rules should be D1 -> D1 C1, C1 U1 -> S1 (Rec0 F), C1 (S1 (Rec0 a)) -> S1 (Rec0 a), (:+:) -> (:*:)
19:24:31 <dmwit> toni37: Let's not. I can't promise high availability; so having our discussion publically makes it more likely that other knowledgable people can help you when I must inevitably leave.
19:29:16 <toni37> dmwit: ok, so i have to build an RISC-V core, and in order to do that, i must have a way to test my implementation
19:30:14 <toni37> for every combinational module it's fine, i can go with simulation, but when the sequential modules takes place, the states space can be huge, and so i must have another way to test my implementation
19:30:28 <toni37> and the best way i found until now is formally proven cpu
19:30:37 <toni37> but for that, i must chose a theory
19:30:45 <toni37> what are your recomandations?
19:30:47 <ironhaven> have you tried just hopeing?
19:31:03 <toni37> nope, and i don't go with hope
19:31:19 <mac10688> freeman42x[m]1: you there?
19:31:50 <toni37> this is not some piece of software you can fix after a few days, it's a cpu, it should work as intended, it's no place for mistakes here
19:33:11 <toni37> what do you think of isabelle/hol?
19:34:44 <Welkin> I think she is secretly controlling Tom Nook
19:36:07 <toni37> Welkin: too much weed
19:38:45 <lyxia> dmj`: https://gist.github.com/Lysxia/daf961e8e3717ef13d7e64e660ff6946
19:41:14 <quiet_laika[m]> anyone done indentation sensitive parsing with megaparsec? im trying to figure out how to parse an indented block that can start with an optional multiline docstring that has to be indented (almost exactly the syntax python uses), but it seems like the `indentBlock` method really only words for a homogenous list of of items. i thought about using `indentGuard`, but i dont think i can arbitrarily get the whitespace
19:41:14 <quiet_laika[m]> indent level of the current line, id have to use the `indentLevel` parser ahead of time which feels pretty unmodular. has anyone tried to do something similar?
19:41:51 <wavemode_> https://github.com/mrkkrp/megaparsec-site/blob/master/tutorials/indentation-sensitive-parsing.md
19:44:42 <quiet_laika[m]> hmmmm, i have read that but maybe there's a way i can use `lineFold` to this end
19:54:45 <wavemode_> what you'd want is two calls to indentBlock, the first one being the optional one which parses the docstring
19:58:24 <Welkin> what is better for emacs: dante or ghcide?
19:58:28 <dmj`> lyxia: wow
19:58:41 * dmj` applauds
20:01:44 <jackdk> Welkin: I have been really happy with ghcid but need to use .dir-locals.el to tell it which cabal target to use
20:01:55 <jackdk> (it is great that I can do this at all - I have had trouble with this in the past)
20:02:12 <jackdk> Aeson question: is there a way to parse an object from a bytestring and return unparsed leftovers?
20:03:16 <dmj`> can I ask you another question :) 
20:03:18 <dmj`> lyxia: 
20:03:51 <dmj`> lyxia: if I had a function of abritrary arity (e.g. a -> b -> c) can I lift it (e.g. a -> b -> f c), and how to do so for any arity
20:23:35 <quiet_laika[m]> wavemode_: hmm but i dont think i can specify that i want exactly one indented item with `indentBlock`
20:33:19 <quiet_laika[m]> i think i got it with a linefold
20:37:48 <quiet_laika[m]> errm no i did not
20:53:37 <jackdk> The answer to my aeson question: aeson exposes its attoparsec parsers; use attoparsec's tools to parse and look for leftovers
21:02:48 <quiet_laika[m]> aha, i think i did get it with a linefold now
21:05:31 <lyxia> dmj`: you can write "(fmap . fmap . .... . fmap) pure f", using one "fmap" for every (->) in the type of f.
21:10:16 * hackage secret-sharing 1.0.1.2 - Information-theoretic secure secret sharing  https://hackage.haskell.org/package/secret-sharing-1.0.1.2 (PeterRobinson)
21:17:19 <quiet_laika[m]> now im having a similar problem where i want to parse something at the END of an indented block (an expression after a set of bindings)
21:28:54 <quiet_laika[m]> seems like i might be better off not using `indentBlock` at all and just trying to use `indentGuard` everywhere
21:30:53 <freeman42x[m]1> mac10688: now I am
21:36:33 <dmj`> lyxia: I can't take credit for this solution, but this construction will let you lift any arbitrary functions return type into IO (or Maybe)
21:36:35 <dmj`> lyxia: https://gist.github.com/dmjio/ddb17345716c4baf18506ad7a16789d8
21:37:16 <dmj`> k :: (a -> a) -> (a -> IO a)
21:37:17 <dmj`> k = lift
21:37:24 <dmj`> works for any arity
21:38:24 <MarcelineVQ> (pure .) ?
21:38:42 <dmj`> MarcelineVQ: no need, the above typechecks
21:59:27 <hololeap> Hello, #haskell. Can you define relational algebra used by SQL using Haskell's type system? Asking for theoretical understanding, not for anything practical.
22:00:11 <monochrom> I think GADTs helps.
22:01:15 * hackage utf8-conversions 0.1.0.4 - A string conversion library that assumes utf8  https://hackage.haskell.org/package/utf8-conversions-0.1.0.4 (chemirea)
22:02:36 <Nolrai> OKay so I think I am breaking IntMap somehow.
22:03:58 <Nolrai> Like I call keys and get a list with values repeated upto 8 times?
22:04:06 <hololeap> Would it be as simple as `Foo A B` `Bar C D` `FooBar Foo Bar` for a many-to-many relationship? You could think of every instance of Foo or Bar as an entry in their respective table...
22:04:43 <hololeap> (And expand from there to the algebra)
22:07:18 <hololeap> Nolrai: what are you asking?
22:08:09 <Nolrai> I just don't know how to even start investigating whats wrong?
22:08:55 <hololeap> What's the type? IntMap ???
22:09:16 <Nolrai> IntMap MyEnum
22:09:36 <hololeap> Does MyEnum have a broken Show instance?
22:09:56 <hololeap> (Just guessing)
22:10:07 <Nolrai> I mean that shouldn't matter if I am just printing the keys, right?
22:10:59 <hololeap> Oh, so you're saying you do `IM.keys intMap` and the result is a list with some numbers that appear more than once?
22:11:07 <Nolrai> Yep!
22:11:19 <hololeap> Can you paste an example?
22:11:19 <Nolrai> So like I am pretty sure that shouldn't happen.
22:11:35 <Nolrai> Of a result?
22:11:37 <hololeap> yeah, that definitely shouldn't happen
22:12:04 <hololeap> are you in IRB?
22:12:08 <hololeap> lol
22:12:09 <hololeap> ghci
22:12:41 <hololeap> Sorry, I've been working on some Rails projects
22:14:43 <hololeap> Nolrai: or are you compiling the code with GHC and running it?
22:14:49 <Nolrai> The second.
22:15:17 <Nolrai> I mean I could run it with GHCi, its not too terrible nonsense.
22:15:46 <quiet_laika[m]> all of a sudden im a bit confused how the indentation parsing code works for complex stuff at all: since the indentation level is based on the leading indentation of the reference token, it seems like youd have to parse `x = match y:` as a single item rather than keeping the indentation sensitivity tied to only the keyword that introduces the "block"
22:16:00 <hololeap> Nolrai: can you share a pastebin of the actual code?
22:16:16 <Nolrai> Its just its not happening in my tests, only when I run the full cycle.
22:18:58 <hololeap> Nolrai: it's hard to get a sense of what is going on with what you've shared so far. There should only be one of each key at most. That's how hash maps work
22:19:31 <Nolrai> Okay so I mostly wanted to confirm that was how things are supposed to work.
22:19:34 <hololeap> But you could be doing something funky in the list monad, for instance
22:20:06 <Nolrai> My code to print them is pretty straight forward.
22:21:11 <hololeap> What exactly is MyEnum?
22:23:31 <Nolrai> `data NodeType = Input | Output | Hidden deriving stock (Show, Read, Enum, Eq, Ord, Generic)`
22:23:57 <Nolrai> So I mean.. I don't think thats the issue.
22:24:12 <Nolrai> Though its worth confirming.
22:24:37 <Nolrai> Sorry about not putting up my code, I just have about 300 lines I would like to narrow down a bit.
22:24:43 <Nolrai> But..
22:25:27 <hololeap> Yeah that probably isn't the issue. 
22:26:40 <Nolrai> hmm. Maybe its some weird interaction with Lens?
22:27:04 <hololeap> Just paste the line(s) where it gets printed
22:28:56 <hololeap> Where is this output getting generated? How is it getting to your console?
22:29:48 <hololeap> Because it seems very unlikely you have such a broken installation that it thinks you have multiple of the same key for an IntMap
22:36:55 <hololeap> Nolrai: skimming through ~300 lines of code isn't too bad if you're willing to just pastebin it
22:41:37 <Nolrai> Sorry about that. Hung my computer somehow.
22:44:53 <Nolrai> Does this link work for you? https://github.com/Nolrai/neat/blob/testing/app/Main.hs
22:45:47 <Nolrai> Its the testPop function that prints out each genotype's nodes' keys to a file.
22:45:54 <Nolrai> 0.log looks fine.
22:47:54 <Nolrai> but 1.log is awful: https://pastebin.com/vqbvLgsq
22:53:24 <MarcelineVQ> dafuk
22:54:05 <MarcelineVQ> just to check, what package is your IntMap from?
22:59:14 <yubrshen> @help
22:59:14 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
22:59:32 <yubrshen> list
22:59:38 <yubrshen> @list
22:59:38 <lambdabot> What module?  Try @listmodules for some ideas.
22:59:49 <yubrshen> @listmodules
22:59:49 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime metar more oeis offlineRC pl pointful poll pretty quote search
22:59:49 <lambdabot> slap source spell system tell ticker todo topic type undo unlambda unmtl version where
23:01:52 <Nolrai> containers I am pretty dang sure.
23:02:44 <Nolrai> I mean it sure seems like its this one: http://hackage.haskell.org/package/containers-0.6.2.1/docs/Data-IntMap-Strict.html
23:02:44 <MarcelineVQ> does the output look different if you don't sort the keys?   keys  are supposed to come out sorted already
23:03:58 <Nolrai> I think it comes out striped. Let me re-run to double check.
23:05:38 <hololeap> Nolrai: the `sort` in `testPop` isn't necessary (the keys will be sorted by default), but I don't see how that could produce the output you're describing
23:06:20 <Nolrai> Hense my confusion.
23:06:43 <Nolrai> I was earliear getting failures on key look up, but that doesn't seem to happen anymore?
23:06:48 <Nolrai> Its very weird.
23:09:09 <hololeap> Nolrai: can you paste the relevant output?
23:10:29 <hololeap> maybe replace `(show . sort . IM.keys $ nodeMap)` with `("testPop: " <> (show . sort . IM.keys $ nodeMap))` just to be sure
23:10:34 <MarcelineVQ> the only thing I'm aware of that can break IM's invariants far enough as to make duplicate keys, are the functions at http://hackage.haskell.org/package/containers-0.6.2.1/docs/Data-IntMap-Lazy.html#g:4 and mapKeysMonotonic
23:12:09 <Nolrai> ooo, I am using those in three places..that would make sense.
23:13:07 <MarcelineVQ> reccomend you avoid functions have the words 'not checked' in the docs since they require you to be mildly omniscient
23:13:37 <Nolrai> Yeah, feels like an obvious thing now.
23:14:50 <hololeap> MarcelineVQ: can `mapKeysMonotonic` actually produce duplicate keys?
23:16:21 <MarcelineVQ> absolutely   mapKeysMonotonic (const 1)
23:16:39 <MarcelineVQ> > IM.mapKeysMonotonic (const 1) $ IM.fromList [(1,'a'),(2,'a')]
23:16:41 <lambdabot>  fromList [(1,'a'),(1,'a')]
23:17:10 <MarcelineVQ> though it'd be rare to have an issue be that obvious
23:17:51 <MarcelineVQ> better yet
23:17:58 <MarcelineVQ> > IM.keys $ IM.mapKeysMonotonic (const 1) $ IM.fromList [(1,'a'),(2,'a')]
23:18:00 <lambdabot>  [1,1]
23:18:02 <MarcelineVQ> there we go
23:18:28 <Nolrai> I am going to have to see why I thought I could get away with using fromAscList.
23:18:38 <MarcelineVQ> now we can't say "but if I type fromList [(1,'a'),(1,'a')] into ghci it's just  fromList [(1,'a')] "
23:19:25 <MarcelineVQ> since that may be true but  keys  shows that before we did that there were duplicate keys
23:20:18 <MarcelineVQ> poor Show
23:20:31 <MarcelineVQ> once again you've been made to lie
23:20:32 <Nolrai> I wonder if I need a new harddrive. :(
