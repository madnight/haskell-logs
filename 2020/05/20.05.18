00:04:15 <liiae> then how to reverse it
00:04:42 <liiae> "WECRLTEERDSOEEFEAOCAIVDEN" to "WEAREDISCOVEREDFLEEATONCE"
00:06:44 <liiae> if the rails number is 3, the tag sequence should be 1111122222233333
00:37:05 <viluon> hi, is this a good place to ask a question about category theory? I'm trying to comprehend the initial F-algebra in Set on the functor F(S) = 1 + S
01:31:53 <mniip> viluon, what part seems confusing
01:32:45 <viluon> mniip: thanks for replying. I understand that the initial algebra is based on natural numbers, 1 + N -> N, where the morphism is 0 for the left case of 1 + N and succ for the right case
01:33:23 <viluon> I struggle to understand what the catamorphism is actually doing
01:34:12 <viluon> I'm following MIT lectures (freely available on the Topos channel on YouTube) from this January (this appears at the beginning of the tenth lecture). They say that the initial algebra encodes induction
01:34:13 <mniip> so suppose you have some other algebra with a structure map X -> 1 + X
01:34:27 <mniip> that is, there is a point z : 1 -> X and a morphism s : X -> X
01:34:35 <viluon> Whoops, accidentally mentioned someone, sorry!
01:35:18 <mniip> the initiality property says that there's a map N -> X such that the commutative square 1+N -> N -> X <- 1+X <- 1+N commutes
01:35:29 <viluon> yeah
01:35:44 <mniip> splitting the coproducts, we have two separate commutation relations
01:35:54 <mniip> that 0 : 1 -> N commutes with z : 1 -> X
01:36:01 <mniip> and S : N -> N commutes with s : X -> X
01:36:45 <mniip> i.e. h(0) = z, forall n, h(n+1) = s(h(n))
01:37:15 <mniip> this amounts to defining a sequence by a recurrence relation and an initial condition
01:37:43 <mniip> h(n) = s^n(z)
01:39:28 <mniip> viluon, does that make sense?
01:39:46 * hackage musicScroll 0.2.3.3 - Supply your tunes info without leaving your music player.  https://hackage.haskell.org/package/musicScroll-0.2.3.3 (RubenAstudillo)
01:40:14 <slack1256> I connect just to see the hackage message :'-)
01:40:45 <viluon> yeah the initial condition is fine but I'm still not 100% sure about how the inductive step works
01:41:22 <mniip> well, it's recursive, not inductive
01:41:29 <viluon> I guess I just don't see why should an arbitrary F-algebra exhibit the same recursive structure
01:41:52 <mniip> X doesn't necessarily exhibit the same recursive structure
01:42:17 <mniip> for example, I could set X=Bool, z=True, s=not
01:42:18 <viluon> it doesn't have to be surjective, right?
01:42:37 <mniip> then h(n) = not^n(True) = "is n even?"
01:43:16 <mniip> it doesn't need to be surjective, nor injective
01:43:31 <viluon> wait, not even injective?
01:43:48 <mniip> an algebra is just an object X with a morphism f : FX -> X
01:43:53 <mniip> no additional properties
01:43:58 <viluon> in the talk, David Spivak says that you pass the catamorphism a natural n and it applies the right case morphism of the algebra to the z point n times
01:44:15 <viluon> well F also has to be an endofunctor
01:44:25 <mniip> well yea but that's fixed in our context
01:44:29 <viluon> right
01:44:45 * hackage path 0.7.1 - Support for well-typed paths  https://hackage.haskell.org/package/path-0.7.1 (ChrisDone)
01:44:49 <viluon> but how can you "iterate" the morphism on the z point if it maps to values outside of its own domain??
01:45:27 <mniip> you iterate the morphism s : X -> X
01:46:13 <mniip> s need not be surjective or injective
01:46:14 <viluon> what if s: N -> N maps 1 to 4 and that's it
01:46:24 <mniip> that's not a morphism then
01:46:27 <viluon> it's neither injective nor surjective
01:46:35 <viluon> how is it not a morphism?
01:46:59 <mniip> "f : X -> Y in Set" means that f is a function from X to Y
01:47:09 <mniip> "maps 1 to 4 and that's it" is not a function from N to N
01:47:36 <viluon> it's a function from {1} to {4}, both the domain and the codomain are subsets of N
01:47:39 <mniip> it can be seen as a function from {1} to some set S that includes 4
01:47:56 <mniip> so?
01:48:10 <viluon> but a function that's not injective doesn't have to define mappings for all points in its domain, does it?
01:48:19 <mniip> that's not what injective means no
01:48:21 <viluon> wait
01:48:24 <viluon> oops
01:48:26 <viluon> haha
01:48:30 <mniip> a function always defines mappings for all elements of the domain
01:48:33 <viluon> sorry you're right
01:48:41 <viluon> injectivity is the isomorphism thing <facepalm>
01:48:44 <viluon> alright
01:48:57 <mniip> injectivity means you don't map distinct elements to the same element
01:49:00 <viluon> yeah
01:49:08 <viluon> one of the two conditions for an isomorphism
01:49:09 <viluon> right?
01:49:16 <mniip> for a bijection, sure
01:49:59 <viluon> alright so 1 + X -> X accepts all possible X's, so it can always be iterated
01:51:13 <viluon> what does this F(S) = 1 + S functor do to morphisms? They don't say that in the lecture
01:51:47 <viluon> I guess <id, f>?
01:51:55 <mniip> I'm not sure what you mean by that
01:52:10 <mniip> it maps Left () to Left (), and Right x to Right (f x)
01:52:17 <viluon> yeah
01:53:39 <viluon> so cata(2) = f(f(z)
01:53:46 <viluon> * f f z
01:54:17 <mniip> f(f z)
01:54:25 <viluon> oh, right
01:55:03 <shachaf> Are you talking about a specific initial algebra here?
01:55:28 <shachaf> I should read more logs, I guess.
01:55:28 <viluon> the initial algebra of F(S) = 1 + S in Set
01:56:00 <viluon> mniip thanks a lot for your explanations!
01:56:33 <mniip> shachaf, yo did you know that the uniqeness condition of initiality gives you dependent eliminiation?
01:57:07 <shachaf> mniip: Not sure! Can you expand on that?
01:58:29 <shachaf> I guess the question here is resolved.
01:58:32 <shachaf> Initial algebras and terminal coalgebras are neato.
02:00:20 <mniip> shachaf, you have non-dependent elimination, i.e. forall X, forall (f : F X -> X), exists (h : I -> X)
02:04:28 <mniip> hrm
02:04:40 <mniip> the type of the dependent eliminator is evading me
02:05:51 <mniip> but you know the one I'm talking about
02:06:34 <shachaf> I'm not sure I do.
02:06:39 <shachaf> But what's the next step?
02:07:41 <shachaf> It's "there exists a unique F-algebra morphism I", right?
02:07:43 <mniip> forall (X : I -> Type), forall (f : forall (C_i : X^k -> X) (is : X^k), all is X -> X (C_i is)), exists (h : forall (i : I), X i)
02:08:21 <shachaf> I.e. forall X, forall (f : F X -> X), exists (h : I -> X), h . i = f . Fh , I think?
02:08:21 <mniip> recursion vs induction
02:08:59 <mniip> right, that's the non-dependent eliminator
02:09:45 * hackage sixel 0.1.1.1 - Sixel library to show images in a terminal emulator  https://hackage.haskell.org/package/sixel-0.1.1.1 (junjihashimoto)
02:10:49 <shachaf> OK, I see, you're parameterizing X on I. I'm not quite sure what that would look like in a category.
02:10:59 <mniip> right
02:11:10 <mniip> it makes sense if F is a polynomial functor
02:11:15 <mniip> but how to generalize further?
02:11:21 <viluon> the algebra finally clicked, thanks again mniip
02:12:22 <shachaf> What is "all is X"?
02:12:30 <shachaf> Other than a Baba Is You rule.
02:12:41 <mniip> all X is, I guess
02:12:49 <shachaf> What's all?
02:12:52 <mniip> you have (X : I -> Type) and (is : X^k)
02:12:59 <mniip> you take the k-ary product
02:26:42 <shachaf> How does uniqueness do that?
02:51:07 <Uniaika> TIL https://www.haskelltutorials.com/odd-jobs/
03:15:15 * hackage discord-haskell 1.6.0 - Write bots for Discord in Haskell  https://hackage.haskell.org/package/discord-haskell-1.6.0 (Aquarial)
04:49:50 <kuribas> I am sure I am at least twice as productive in haskell as in a dynamic language.  I wonder when there will be studies that can confirm the benifits of static typing.
04:50:08 <merijn> kuribas: Proper study design is near impossible
04:50:28 <merijn> As evidenced by the huge number of *horrifically* flawed studies trying to answer this :p
04:50:31 <kuribas> merijn: the benifits for me personally are huge...  Doesn't that mean it's just a personal thing?
04:51:06 <merijn> kuribas: I suspect it's not personal, but it may not be universal. But it's basically impossible to prove
04:51:32 <kuribas> couldn't you make a study where the subjects have to make changes to a big codebase.
04:51:40 <kuribas> One is typed, the other dynamic.
04:52:32 <kuribas> The flaw is that these projects start from scratch
04:53:44 <kuribas> I can write decent code in a dynamic language, and be able to refactor it.  The problem is when I get back to it months from now.
04:54:34 <kuribas> I'll be still more productive in haskell even for a quick throwaway project
04:59:53 <xerox_> what do you produce with your increase productivity
05:00:03 <merijn> kuribas: Right, now we just need to create two, equal quality, equal size complex codebases in both a dynamic and a statically typed language!
05:00:25 <kuribas> xerox_: bugs of course :)
05:00:29 <xerox_> yikes!
05:00:30 <merijn> kuribas: And find a sample size of equally skilled test persons willing to invest the time to make non-trivial changes for free for science!
05:01:19 <kuribas> xerox_: erm, I mean features!
05:28:08 <nil> under what circumstances (if any) does GHC optimise `f x = ..f x..` as `f x = go where go = ..go..` and where can i read about this?
05:29:22 <merijn> nil: Might wanna ask in #ghc?
05:29:43 <nil> true
05:32:31 <dm9> How do I correctly use a `cabal.project.freeze` file? I created one using `cabal v2-freeze --allow-newer` but `cabal v2-build` does not use it
05:35:55 <Orbstheorem> Hello, why does record member binding does not work on monadic style? (ex https://paste.gnugen.ch/raw/kkH0)
05:36:34 <Orbstheorem> Oh, wrong casing, nevermind :(
06:08:36 <tdammers> kuribas: there are many many problems with studying this
06:09:32 <tdammers> you can't really achieve "the same" conditions for many variables in this, e.g. "same team", "same problem", "same program"
06:09:53 <tdammers> same developers working on the same problem twice is not the same thing, because they will apply things learned in the first attempt to the second attempt
06:11:04 <tdammers> then there's the fact that mastering a programming paradigm to the point where you can perform at your maximum potential takes years, so just taking random developers and assigning them random languages they haven't yet mastered doesn't say much about how a language would perform with sufficient up-front learning
06:11:07 <tdammers> etc. etc. etc.
06:11:16 <tdammers> not to mention that you can't do "double-blind" studies
06:18:46 <maerwald> I'm starting to care less about types, but about errors. I want them to be first-class.
06:18:57 <phadej> funny thing about rewrites: they either succeed because of proper tech choice or fail due managerial problems!
06:19:45 <maerwald> dm9: why do you think it doesn't use it?
06:21:13 <tdammers> phadej: you mean as far as blog authors are concerned?
06:21:19 <phadej> tdammers: yes :)
06:21:43 <tdammers> phadej: also, no matter whether the rewrite succeeded or failed, there's always a positive spin: if it succeeded, then "here's how we did it", if it failed, then "here's what we learned"
06:21:59 <phadej> fwiw, I'm quite sure my "maximum potential" using Haskell is way higher than using JavaScript. And I'm quite good (or was, I guess) at JavaScript.
06:22:10 <maerwald> most people don't work long enough on the same project to realise the bad choices they made :P
06:22:11 <tdammers> same for me and PHP
06:22:34 <maerwald> Maybe this is even worse in consulting, where you are "forced" to leave a project after you fixed stuff up?
06:22:37 <tdammers> I'm really very good at writing PHP. Better than most. But I'm not gonna touch that with a 10-foot pole ever again if I can help it.
06:23:17 <tdammers> maerwald: I have seen consultants literally forced to leave a project after they messed it up in very expensive ways
06:23:20 <maerwald> I mean, will your clients bother to write you an email in 5 years and give you a huge list about things that didn't work out quite so well?
06:23:57 <phadej> some consultants work with clients for that kind of time spans, or a lot lnger
06:23:58 <maerwald> tdammers: I'm more thinking about decisions where you can't immediately tell... let's say "we'll redo everything in microservices"
06:24:11 <phadej> maerwald: "redo" <- fail.
06:24:12 <maerwald> it might take a couple of years to realise whether this was good or not
06:24:15 <tdammers> "redo everything" means it will fail
06:24:18 <phadej> :)
06:24:28 <DarkAdi> Duplicating your pro choices in some side projects you will be maintaining for years can be a great way
06:24:31 <maerwald> tdammers: nah, if it's a project that has to be redone anyway :)
06:25:22 <maerwald> Or choices like "let's do event sourcing for this problem"... it'll surely work out in the beginning
06:25:23 <tdammers> maerwald: projects that truly need to be redone from scratch and stand a chance of succeeding are generally small libraries or simple single-purpose tools
06:25:29 <maerwald> The cost you'll see in a few years down the line
06:25:48 <tdammers> large systems, I'm pretty convinced that almost always, the answer is gradual improvement rather than a complete redesign
06:26:04 <DarkAdi> Not sure about that
06:26:24 <maerwald> tdammers: well, I've worked in a project where the number of people who understood the 60k LOC legacy codebase was 0
06:26:27 <DarkAdi> We often overestimate the cost of a complete redesign
06:26:34 <phadej> 60kLOC is not large
06:26:52 <maerwald> yes, so complete rewrite was feasable
06:27:09 <maerwald> they went for microservices, and ~1 year into the rewrite realised... oops
06:27:26 <phadej> "don't trust the hype" ?-)
06:27:33 <phadej> at least blindly
06:27:42 <maerwald> Right, but the lead engineer who started all that already left :)
06:27:49 <phadej> good for them
06:28:00 <maerwald> I love industry
06:28:31 <phadej> yet, if it takes ~1 year to rewrite 60kLOC thing and you need _microservices_
06:28:37 <phadej> there's a lot of not right stuff
06:28:51 <maerwald> phadej: backend 60k LOC :P
06:29:21 <tdammers> the classic fallacy: confusing an implementation detail for structural improvement
06:29:27 <maerwald> yeah
06:29:45 <maerwald> Or thinking microservices is an architecture pattern to fix spagehtti code
06:29:48 <tdammers> if you need your system to be more decoupled, more modular, then make it more modular, instead of "adding microservices" and assuming that the problem will go away by itself
06:30:00 <tdammers> same for security, really.
06:30:15 <maerwald> microservices are an optimisation strategy imo, that makes sense if you have scaling issues or whatever
06:30:20 <maerwald> Not an architecture pattern
06:30:37 <tdammers> you don't need *micro*-services for scalability, just services
06:30:39 <maerwald> But, you can still build anything with it... and it will kinda work
06:30:52 <maerwald> So people go "look, we managed it with microservices" -> success story
06:31:09 <tdammers> the "micro" part is useful when you need fine-grained redundancy and resilience, and independent development at this level
06:31:21 <tdammers> but in most cases you don't need that
06:31:46 <tdammers> just maybe half a dozen or so relatively fat services will do amazing things for scalability already
06:32:34 <phadej> from the stories I watched / read the "one team <-> one service" works well.
06:32:36 <maerwald> Maybe we're lucky that haskell doesn't have too much of a microservice ecosystem yet :P
06:32:46 <phadej> "one team <-> dozesn of (micro) services" doesn't
06:32:59 <tdammers> I like "one team, one library"
06:33:08 <tdammers> or "one team, a small handful of libraries"
06:33:21 <dansho> is there a language pragma to swap :: and : ?
06:33:35 <phadej> dansho: no
06:33:47 <dansho> :'(
06:33:55 <phadej> yet the worse case is "many teams <-> on service"
06:34:08 <phadej> or "many teams <-> many services"
06:34:21 <tdammers> yeah, but arguably those teams aren't really separate teams anymore then, but rather just one large, badly organized team
06:34:25 <dm9> maerwald: because `cabal v2-build` fails (`cabal v2-build --allow-newer` works)
06:34:48 <maerwald> dm9: hard to judge without seeing the code
06:35:01 <phadej> tdammers: yes, the organisation structure and technical architecture don't match => a lot of tension
06:35:41 <maerwald> ah right, there is this idea that code in a company resembles the communication structure in the company
06:36:30 <phadej> or "budget structure" :)
06:42:19 <utkarshm1> Hello All. I want to write a 2 versions of split functions - to understand how to output resulting string as either String or [String]. I am getting confused between which syntax is which - of the many forms x:y, x++y, (x:y), [x:y], [x, y].
06:42:41 <utkarshm1> I am struggling with the syntax here.
06:42:54 <utkarshm1> Code: https://gist.github.com/jh01gcs/da10cd77ab6bc1c0611f82a1cd7e75ee
06:43:12 <utkarshm1> Can you please shed some light?
06:54:01 <dm9> maerwald: a simple `cabal init` demonstrates the problem: set the upper bound on `base` to something older than your current GHC version and then `cabal v2-freeze --allow-newer && cabal v2-build` fails while `cabal v2-build --allow-newer` works
06:58:13 <kuribas> tdammers: I wonder if microservices aren't just popular because the languages don't support clean separation on API level.
06:58:17 <solonarv> utkarshm1: the basic building blocks for lists are '[]' and ':', everything else is syntax sugar ('[x, y, z]') or functions.
06:58:20 <kuribas> tdammers: like python, javascript
06:59:32 <solonarv> [e] is syntax sugar for (e : []). similarly, [x, y] is syntax sugar for (x : (y : [])), or without redundant parentheses: (x : y : [])
07:01:15 * hackage libsodium 1.0.18.1 - Low-level bindings to the libsodium C library  https://hackage.haskell.org/package/libsodium-1.0.18.1 (RenzoCarbonara)
07:22:52 <tdammers> kuribas: no idea, really. what I've witnessed is that the usual chain of events is: 1) developers learn about microservices 2) idea seems elegant and sexy to them, 3) they pitch it with management, citing success stories from elsewhere, 4) management hears "success stories" and "silver bullet" and "the future", and OK's a rewrite, 5) developers go an make an abomination, but by the time they notice it's too
07:22:55 <tdammers> late
07:23:14 <kuribas> tdammers: lol
07:23:26 <kuribas> tdammers: you forgot "blockchain"
07:25:21 <kuribas> tdammers: the problem with "we can scale like netflix", is that you don't have the resources to scale to netflix.
07:25:26 <tdammers> of course. that is even more the future than microservices. microservices were the future 5 years ago.
07:25:59 <tdammers> yeah. you can scale like netflix, but scaling like netflix isn't what you need, because you aren't netflix
07:26:26 <tdammers> but I guess there's something comforting in thinking that you *could* scale by six orders of magnitude on a whim
07:26:38 <merijn> It's dumb as shit
07:26:49 <tdammers> even though you actually can't, and also never will get to put it to the test
07:26:50 <merijn> Most companies aren't even utilising a single machine well
07:27:02 <merijn> What makes them think they're able to utilise 100s well >.>
07:27:03 <kuribas> I would start by not using python/nodejs/php
07:27:31 <kuribas> that already scales by a factor of 50!
07:27:32 <tdammers> merijn: yeah. I like to say, "a single postgresql instance on a reasonably beefy server can probably deliver 100x more performance than your business will ever need"
07:28:01 <tdammers> kuribas: no it doesn't. typically, it scales by a factor of 1, because the programming language interpreter is rarely the bottleneck
07:28:26 <tdammers> kuribas: and also because it's a linear overhead, it won't create any exponential performance blowups
07:28:46 <merijn> My favourite ever paper in graph processing is a few guys beating 100+ machine distributed frameworks by...putting some SSDs in a single machine and not having a dumb design
07:28:57 <merijn> Like, beating by like an order of magnitude or two as well
07:29:00 <kuribas> tdammers: funny, because for the problems they use Python (numerical computing), using an actual compiler does make a difference.
07:29:03 <tdammers> a better reason to avoid these languages is because they are notoriously un-refactorable, which is a huge limiting factor when it comes to adjusting your code to the demands
07:29:49 <tdammers> kuribas: yes, but numerical computing isn't the kind of scenario where some dumbfuck manager would typically go "I know, let's use microservices to make it more scalable"
07:30:12 <kuribas> tdammers: well, our companies data scientists use microservices
07:32:13 <kuribas> but it's their own decision, not the managers
07:33:16 <Sathiana> New to Haskell, was wondering why in Function composition, when you have: 
07:33:22 <Sathiana> f :: A -> B
07:33:28 <Sathiana> g :: B -> C
07:33:39 <Sathiana> h :: C -> D
07:33:45 <Sathiana> Composing them you do: h . (g . f) == (h . g) . f == h . g . f
07:33:51 <Sathiana> Why isn't it f . (g . h) == (f .g) . f == f . g . h instead?
07:34:24 <kuribas> Sathiana: because (.) runs the first function first
07:35:15 <kuribas> Sathiana: you have an x :: A, f x gives you B, g (f x) gives you a C, h (g (f x)) gives you a D
07:36:58 <kuribas> Sathiana: by definition of (.)   g . f = \x -> g (f x)
07:37:19 <kuribas> Sathiana: the way you describe it, it would be (f . g)
07:38:23 <kuribas> I pronounce it "after", so g . f == run g after f
07:38:47 <Sathiana> kuribas: now it starting to make sense  
07:39:25 <Sathiana> like in category theory g after f
07:40:21 <kuribas> yeah . is also in Control.Category: (.) :: Category cat => cat b c -> cat a b -> cat a c 
07:41:56 <Sathiana> the "f == run g after f" made it easier to "visualize"
07:42:36 <kuribas> it's the opposite of OO languages
07:43:00 <kuribas> where you compose from left to right
07:43:01 <merijn> Sathiana: Not really like category theory, more like "regular" math
07:43:23 <kuribas> f ° g
07:43:43 <kuribas> > ((+1) ° (*2)) 4
07:43:45 <lambdabot>  error:
07:43:45 <lambdabot>      Variable not in scope:
07:43:45 <lambdabot>        (°) :: (Integer -> Integer) -> (Integer -> Integer) -> Integer -> t
07:43:45 <merijn> kuribas: Function composition is also a thing in pre-CT math :p
07:43:52 <kuribas> merijn: yeah true
07:45:59 <nil> implying there's a pre-CT math
07:46:02 <Sathiana> gonna do some intro CT studying to really appreciate/understand haskell
07:46:04 <nil> /s
07:46:09 <merijn> Sathiana: Won't help, tbh
07:47:07 <merijn> "Haskell is based on Category Theory" seems to be an accepted fact in the "non-haskell" parts of the internet
07:47:11 <merijn> But it's basically bogus
07:47:56 <merijn> The usefulness of studying CT to understand/learn Haskell is, imo, 0
07:48:33 <nil> well that's a nuanced stance
07:49:11 <Sathiana> merijn: I thought it would help me understand why things a made "that way" in haskell
07:49:12 <kuribas> better learn lambda calculus and logic
07:49:13 <nil> i think being able to think of a monad as a particular kind of monoid is definitely helpful
07:49:16 <merijn> nil: CT only becomes useful at a level that's *well* beyond intermediate experience in Haskell
07:49:23 <nil> maybe not for writing basic IO programs, but for more advanced things
07:49:38 <nil> merijn: right, i'm talking about advanced levels
07:49:39 <merijn> nil: That's only helpful if you have already internalised abstractions like monoid
07:49:57 <nil> which you should have, as a prerequisite to studying CT, imo
07:50:24 <merijn> nil: Right, so my statement that it's useless for Haskell beginners stands ;)
07:50:35 <merijn> Sathiana: honestly, not really
07:51:02 <nil> merijn: ok, i guess i agree with your claim if you take "understand/" away
07:51:53 <merijn> Sathiana: I mean things like "Why is 'f . g' equal to '\x -> f (g x)' instead of '\x -> g (f x)'" is just "because that's what mathematicians used for decades (centuries?)
07:52:31 <merijn> Sathiana: So the answer is simply "a dead guy arbitrarily decided that ages ago"
07:52:43 <merijn> Which doesn't really require CT at all ;)
07:53:06 <Sathiana> I see 
07:53:26 <nil> you could also say that it preserves the order of f and g in the expression, and then the question becomes "why is function application written that way?"
07:55:37 <merijn> I mean, there was probably a reason why he decided on that order, but that reason is, tbh, mostly irrelevant. "That's just how we defined it"
08:09:30 <jmcarthur> Even at advanced levels, it's not like CT is in some way ingrained into the fabric of Haskell. It's really just that folks are applying CT to their designs, and Haskell happens to be a bit more amenable to it in a direct way than many other languages are.
08:12:06 <jmcarthur> I regret my use of the word "happens" there. It's not entirely a coincidence.
08:13:56 <tdammers> off the top of my head, the only person I can think of who directly benefits from extensive knowledge of CT in writing Haskell code is Edward Kmett
08:14:34 <Cale> jmcarthur: At least, not any more than it was already ingrained into the fabric of ML
08:15:05 <tdammers> case in point, haskell does borrow a few terms from CT
08:15:06 <Cale> (and perhaps slightly less, when it comes to Haskell not having the formally correct product)
08:28:45 * hackage yaya 0.3.1.2 - Total recursion schemes.  https://hackage.haskell.org/package/yaya-0.3.1.2 (sellout)
08:35:45 * hackage hadoop-streaming 0.2.0.3 - A simple Hadoop streaming library  https://hackage.haskell.org/package/hadoop-streaming-0.2.0.3 (zliu41)
08:44:16 * hackage web-routes-th 0.22.6.6 - Support for deriving PathInfo using Template Haskell  https://hackage.haskell.org/package/web-routes-th-0.22.6.6 (JeremyShaw)
08:45:09 <statusfailed> with Lens, Is there a way to read multiple (prism) fields in the same way you can with lenses? e.g., with lenses I can do runGetter $ (,) <$> Getter field1 <*> Getter field2
08:51:03 <sushi1234> hello, i have this Writer snippet from Learn you haskell https://pastebin.com/6sCFw62G
08:51:18 <sushi1234> i can't wrap my head around how does `return (a*b)` preserve the two logs
08:51:47 <xerox_> sushi1234: do you have a definition of return?
08:51:49 <sushi1234> i tried to rewrite it to monadic syntax `logNumber 3 >>= (\x -> logNumber (5) >>= (\y -> logNumber (x * y)))` but that's something else
08:52:02 <xerox_> you're close
08:52:12 <solonarv> keep in mind that 'return' isn't a keyword, it's just a plain old library function. and it doesn't do any control flow either.
08:52:29 <xerox_> @undo do { a <- logNumber 3; b <- logNumber 5; return (a*b) }
08:52:29 <lambdabot> logNumber 3 >>= \ a -> logNumber 5 >>= \ b -> return (a * b)
08:52:30 <sushi1234> is in the book `return x = Writer (x, mempty)`
08:53:00 <xerox_> that's the correct translation, you overwrote the return call with another logNumber call
08:54:15 * hackage userid 0.1.3.5 - The UserId type and useful instances for web development  https://hackage.haskell.org/package/userid-0.1.3.5 (JeremyShaw)
08:54:20 <xerox_> mempty is the same as [] in there, so logNumber is   Writer (x,["the string"])   and return is   Writer (x,[])
08:54:21 <sushi1234> xerox_: oh, i wasn't that far from the correct one, thanks a lot!
08:54:21 <sushi1234> is there a way to have this undo utilit from bot in my terminal?
08:54:32 <xerox_> you can /query lambdabot and use it in private
08:55:35 <solonarv> you can also in theory run it locally, although I don't know how exactly
08:58:37 <sushi1234> hmm, i queried the bot but he is not answering
08:58:47 <xerox_> what did you write?
08:59:12 <sushi1234> i tried simple '1 + 1'
08:59:23 <sushi1234> do i have to send him a command?
08:59:34 <xerox_> there's a syntax to that, for evaluation you have to prepend with "> " like a little prompt
08:59:52 <xerox_> > "sushi" ++ show 1234
08:59:54 <lambdabot>  "sushi1234"
09:00:13 <sushi1234> ah, thanks!
09:00:32 <xerox_> :t (>>=) -- this is for types
09:00:34 <lambdabot> Monad m => m a -> (a -> m b) -> m b
09:40:46 * hackage happstack-server 7.6.1 - Web related tools and services.  https://hackage.haskell.org/package/happstack-server-7.6.1 (JeremyShaw)
09:56:15 * hackage ghc-lib-parser 8.10.1.20200518 - The GHC API, decoupled from GHC versions  https://hackage.haskell.org/package/ghc-lib-parser-8.10.1.20200518 (shayne_fletcher)
09:57:15 * hackage ghc-lib 8.10.1.20200518 - The GHC API, decoupled from GHC versions  https://hackage.haskell.org/package/ghc-lib-8.10.1.20200518 (shayne_fletcher)
09:58:16 * hackage syb-with-class 0.6.1.13 - Scrap Your Boilerplate With Class  https://hackage.haskell.org/package/syb-with-class-0.6.1.13 (JeremyShaw)
10:01:49 <xcmw> Does anyone know how the query system works in diagrams?
10:03:33 <matthewma> xcmw Does anyone know how the query system works in diagrams?
10:05:45 <xcmw> I see how to annotate a Diagram with Any. https://github.com/cocreature/diagrams-miso/blob/master/example/src/Colors.hs#L58 But how can I annotate an already annotated diagram?
10:08:55 <matthewma> I have no idea 
10:28:28 <xerox_> ,bang
10:28:38 <xerox_> oops wrong window
10:41:02 <lep-delete> no ducks for you
10:45:15 * hackage ghc-lib-parser-ex 8.10.0.10 - Algorithms on GHC parse trees  https://hackage.haskell.org/package/ghc-lib-parser-ex-8.10.0.10 (shayne_fletcher)
11:01:23 <dmwit> We have `module Foo where blah`, but what about `let blah in module Foo`??
11:02:31 <Uniaika> dmwit: :(
11:04:40 <monochrom> let x=1 in module Foo where y=2  :)
11:05:54 * MarcelineVQ fan-spins
11:15:37 <EvanR> let blah be module Foo
11:16:32 <koz_> EvanR: Is it 1980 and proglangs have to look like human languages?
11:17:52 <ski> how about `let import Foo in ...' ?
11:19:25 <maerwald> Maybe at some point we'll stop doing programming in terms of letters, but will have something that resembles more of a conversation.
11:19:41 <EvanR> let x in y sets up bindings x to be active in y. whatever where x sets up bindings x to be used in whatever. so dmwit's suggestion doesn't make sense
11:20:33 <dolio> Sure it does.
11:20:49 <EvanR> let import Foo = blah in whatever for a local module
11:21:01 <dolio> It's just not very nice for the name of a module to go at the bottom of a file.
11:21:20 <maerwald> Instead of telling the computer what to do, we should have a conversation with them and convince them about our intentions.
11:21:38 <EvanR> we see how well that works with captain kirk
11:21:42 <maerwald> Programmers will be diplomats, not mathematicians then
11:23:39 <maerwald> Computer Diplomat sounds way more proper than Software Engineer anyway
11:24:15 * hackage hsx2hs 0.14.1.7 - HSX (Haskell Source with XML) allows literal XML syntax in Haskell source code.  https://hackage.haskell.org/package/hsx2hs-0.14.1.7 (JeremyShaw)
11:24:31 * ski . o O ( "AI psychologist" )
11:25:02 <maerwald> Human: "Hey, I have this idea, you might wanna run..." ; Computer: "Why should I listen to you?"
11:25:59 <monochrom> We have been pretty successful dog diplomats. :)
11:26:11 <dmwit> EvanR: Wait, I didn't understand your argument about why my suggestion didn't make sense.
11:26:56 <dmwit> EvanR: You say "whatever where x" sets up bindings x to be used in whatever. So module Foo where blah sets up bindings blah to be used in module Foo.
11:27:20 <dmwit> EvanR: You say "let x in y sets up bindings x to be active in y". So let blah in module Foo sets up bindings blah to be active in module Foo.
11:27:58 <koz_> maerwald: Category diplomacy.
11:28:15 <monochrom> It is also possible that the programmer-computer consversations will be very much like thesis-supervisor-thesis-grad-student conversations.
11:28:58 <monochrom> Then only PhDs are capable of programming. Not only that, but also: even among the PhDs, only the tenured professors are capable of programming. >:)
11:29:13 <EvanR> dmwit: no you're right
11:30:10 <maerwald> monochrom: a touch of that, but also a touch of philosophical romance, where the computer goes "ah, cmon, it would never terminate anyway, what's the point", leading to heated nightly discussions about life, death and convincing them that there is a meaning to everything, after all.
11:30:28 <monochrom> Another possibility is what I alluded to.  It will be like between humans and dogs.
11:31:00 <monochrom> I think thesis supervisors and thesis grad students do that too :)
11:31:05 <maerwald> lolo
11:31:17 <monochrom> Not very often but I certainly had my share!
11:32:48 <maerwald> But, I mean... people don't even take programming with pictures seriously, how would we get to the stage of diplomacy and conversations
11:32:59 <maerwald> Although pictures rock
11:34:27 <monochrom> If you look at the users of 3D modeling software... I think they qualify as programmers in a DSL. It's just that our arrogance and conceit refuse to recognize them as programmers.
11:36:39 <maerwald> We think our words are precise, but when they hit the CPU, no one know what they're really doing. It is merely a prayer we send to the CPU.
11:36:58 <maerwald> So maybe we are prophets
11:37:48 <koz_> maerwald: So... category theology then?
11:37:51 <wavemode> The compiler is our priest. We have to hope he understood us properly
11:37:57 <dmwit> koz_++
11:38:23 <koz_> inb4 'writing your Haskell in Comic Sans makes it more likely to compile and run correctly'.
11:39:15 * hackage th-test-utils 1.0.2 - Utility functions for testing Template Haskell code  https://hackage.haskell.org/package/th-test-utils-1.0.2 (leapyear)
11:42:33 * ski . o O ( "Das ist nicht Mathematik, das ist Theologie." )
11:43:53 <monochrom> The same can be said---even more so---of flipping a switch to turn on/off a light, heating a steak to make it smell good, talking to someone else in hope of communication, and ultimately, exerting your will to your leg in hope that your leg actually moves as you will.
11:43:53 <koz_> ski: What is that a reference to?
11:46:27 <ski> apparently, Paul Gordon had constructively proved a theorem in invariant theorm, when David Hilbert came along, and gave a "purely existential" (that is, non-constructive) proof
11:47:01 <monochrom> Hilbert's PhD thesis consists of an existential theorem proved by "if not exist, then false".  Kant didn't like it, and said "that's not math, that's theology".
11:47:31 <koz_> monochrom: Kant?
11:47:38 <ski> Immanuel Kant
11:47:44 <ski> famous philosopher
11:47:48 <koz_> Wait, they were contemporaries?
11:48:08 <koz_> I clearly don't know history _or_ philosophy as well as I thought.
11:48:49 <ski> Kant was in the 1700s, as i thought
11:49:35 <koz_> LEM is, indeed, a hell of a drug.
11:49:36 <ski> perhaps this was a different Kant, then ?
11:50:30 <monochrom> Hrm, then maybe not Kant.
11:50:37 <koz_> It was Gordan who said it.
11:50:43 <monochrom> Ah OK.
11:50:47 <koz_> https://en.wikipedia.org/wiki/David_Hilbert#Hilbert_solves_Gordan's_Problem
11:50:59 <ski> there would have been multiple people, saying something similar ?
11:51:07 <koz_> If only the reviewer comments _I_ got were half this pithy.
11:53:21 <koz_> ski: In our setting, perhaps "Das ist nicht Informatik, das ist Theologie." works better?
11:54:00 <ski> perhaps (although categories were mentioned)
11:54:34 <ski> i suppose i like the term "Informatik" better than "Computing Science", anyway
11:54:44 <koz_> You and me both.
11:55:30 <koz_> I think Sussman put it best: "Computer science isn't really a science - it's either art or engineering, depending on who you ask - and it is as much about computers as physics is about particle accelerators."
11:55:40 <ski> (here they call it "Datavetenskap" which translates as "Data Wissenschaft", where "Wissenschaft" is sortof, but not quite, the german word corresponding to "Science")
11:55:59 <ski> yes
11:56:03 <koz_> ski: What language is "Datavetenskap"?
11:56:09 <opqdonut> swedish?
11:56:10 <ski> (hence i say "Computing", not "Computer")
11:56:11 <ski> yes
11:56:15 <koz_> Ah, I see.
11:56:17 <monochrom> Data Witchcraft :)
11:56:29 <opqdonut> in Finnish it's tietojenkäsittelytiede, quite a mouthful
11:56:30 <ski> sometimes, it seems that would be more appropriate :)
11:56:35 <opqdonut> literally information processing science
11:56:35 <koz_> monochrom: This is 100% what I engage in.
11:56:53 <koz_> ... making me a data warlock I guess?
11:57:08 <koz_> If I ever get to choose my job title, THIS IS IT.
11:57:24 <MarcelineVQ> then I'll take infomancer
11:57:34 <koz_> MarcelineVQ: Well played.
11:57:42 <monochrom> haha
11:58:11 <koz_> 'Informancer' implies you're in the Hermetic tradition, so you like, study things. Data warlocks just call up spirits.
11:58:28 <ski> it's interesting that "computer", in swedish, is "dator". also it's "dators" in latvian
11:58:51 <wavemode> I believe data alchemist is a real job title
11:58:51 <koz_> ... so is using a computer 'dating'?
11:58:57 <koz_> How very 2020.
11:59:20 <koz_> wavemode: So what, they're trying to turn garbage into gold?
11:59:28 <wavemode> basically
11:59:33 <koz_> Accurate.
12:00:39 <ski> iirc, the use of this word is due to Arne Beurling. he's also known for figuring out how the german Geheimschreiber cryptographic machine worked, during the second world war
12:01:18 <ridcully_> data astrology
12:01:31 <ski> hm, so instead of searching for the silver bullet, we're really supposed to turn things into gold ? or find the philosopher's stone ?
12:01:57 <opqdonut> I call the thing data science consultants do data scientology
12:02:23 <opqdonut> (as a joke and not to their faces :D)
12:02:31 <ski> opqdonut : hm, ok. and does the word corresponding to "science" there encompass more than the sciences in the english-speaking world ?
12:02:49 <opqdonut> ski: no, I think it's just science
12:02:59 <int-e> ski: that (gold, philosopher's stone) is bit alchemy
12:03:24 <int-e> or maybe terabit alchemy
12:03:33 <wavemode> the word "computer" used to refer to people, not machines
12:04:22 * ski . o O ( iatrochemistry )
12:04:24 <koz_> wavemode: Spelled 'computor' if I'm not mistaken?
12:04:32 <koz_> ski: 'iatro' means what?
12:04:42 <koz_> My Greek and Latin derivation-fu is weak since I left private schools. :P
12:05:37 <ski> "ιατρός (iatrós) was the Greek word for physician or medicine"
12:05:46 <koz_> ski: Thanks!
12:05:47 <monochrom> It was really spelled computer.
12:05:56 <koz_> monochrom: Oh, really? Huh, TIL.
12:06:42 <ski> koz_ : e.g. in "psychiatry"
12:06:58 <koz_> Oh, yeah, I see. 
12:07:08 <koz_> #haskell is #linguistics today
12:07:33 <monochrom> In the movie Hidden Figures, and probably even in the book, you'll see the convention back then of not including the computers among the authors of a report.
12:08:16 * hackage birch-beer 0.2.5.0 - Plot a colorful tree.  https://hackage.haskell.org/package/birch-beer-0.2.5.0 (GregorySchwartz)
12:09:24 <ski> monochrom : well, Doron Zeilberger has taken the bold move of reversing that
12:09:59 <ski> he often lists his computer, Shalosh B. Ekhad, as a coauthor of his papers
12:10:24 * koz_ is no longer a weirdo for naming his computers.
12:11:57 <Heffalump> We name all our computers so we can identify them easily
12:12:44 <monochrom> Yeah but do you include your computer as a coauthor of your paper?
12:13:00 <monochrom> I think someone actually did. The electronic kind.
12:15:45 <opqdonut> didn't somebody submit math papers with a computer as the only author
12:16:03 <opqdonut> searching for shorter proofs of known theorems
12:16:50 <opqdonut> https://sites.math.rutgers.edu/~zeilberg/ekhad.html
12:17:30 <opqdonut> hmm it seems only as a coauhtor
12:17:58 <ski> <https://sites.math.rutgers.edu/~zeilberg/pj.html> lists some as only author
12:20:30 <koz_> monochrom: Perhaps I should?
12:21:45 * hackage yesod-markdown 0.12.6.3 - Tools for using markdown in a yesod application  https://hackage.haskell.org/package/yesod-markdown-0.12.6.3 (PatrickBrisbin)
12:21:55 <nshepperd> "special thanks to computer-san for all its (at times annoying) feedback"
12:23:22 * ski . o O ( "Scsh Reference Manual - Acknowledgements" by Olin Shivers in 1994-09-04 at <https://scsh.net/docu/html/man.html> )
12:26:15 <koz_> nshepperd: Not 'computer-niisan'?
12:26:59 <koz_> ski: Is that a reference to something?
12:29:34 <MarcelineVQ> nshepperd: or as the hippest kids of this generation say  domo arigato mr roboto
12:31:21 <ski> koz_ : i was just reminded of it
12:32:49 <koz_> ski: It is pretty hilarious, I must admit.
12:36:08 <MarcelineVQ> "<koz_> nshepperd: Not 'computer-niisan'?"  c-computer onii-chan, daisuki da yo
12:36:41 <koz_> MarcelineVQ: It probably exists.
12:38:05 <MarcelineVQ> more likely computer onee-sama,  ara ara
12:38:20 <koz_> MarcelineVQ: It depends what audience it's being aimed at.
12:38:40 <koz_> 'computer-kun' or 'computer-chan' or 'computer-dono' are all possibilities.
12:38:45 * hackage tree-sitter-rust 0.1.0.0 - Tree-sitter grammar/parser for Rust  https://hackage.haskell.org/package/tree-sitter-rust-0.1.0.0 (joshvera)
12:39:03 <MarcelineVQ> computer dono? I refuse to bow to the coming platinum gods
12:39:28 <MarcelineVQ> They'll have to recycle me with the rest of the undesirables that can't be converted to servitors
12:39:48 <koz_> MarcelineVQ: Rofl.
12:40:30 <koz_> In all seriousness, I've named my desktop (and primary work) computer 'Sebastian', after _that_ Sebastian.
12:40:59 <MarcelineVQ> haha gross
12:43:33 <koz_> My laptop is named 'Emi', so double gross. :P
12:58:55 <ski> hm, which Sebastian ?
13:00:46 * hackage harp 0.4.3.4 - HaRP allows pattern-matching with regular expressions  https://hackage.haskell.org/package/harp-0.4.3.4 (JeremyShaw)
13:22:21 <koz_> ski: Sebastian Mikhaelis, from Kuroshitsuji.
13:23:34 <ski> never heard of him, of that (film ? book ? something else ?=
13:23:44 <koz_> ski: Anime (originally manga)
13:23:53 <ski> ok, ty
13:24:04 <koz_> If you decide to check it out, pretend Season 2 never happened.
13:27:03 <ski> mhm
13:27:15 * hackage medea 1.0.0 - A schema language for JSON.  https://hackage.haskell.org/package/medea-1.0.0 (koz_ross)
13:34:14 <koz_> Also, how do you get the folks behind Haskell Weekly to notice you, senpai?
13:39:59 <[exa]> koz_: you must become too good to not be noticed
13:40:06 <koz_> [exa]: Got it.
13:40:21 <koz_> Haskell-Weekly-senpai is tough to please.
13:41:15 * hackage rss-conduit 0.5.1.1 - Streaming parser/renderer for the RSS standard.  https://hackage.haskell.org/package/rss-conduit-0.5.1.1 (koral)
13:42:14 <[exa]> also, cool packages&blogposts help
13:42:30 <[exa]> koz_: if you have some prime material you might want to just send them a message about that
13:42:38 <koz_> [exa]: Who's 'them'?
13:43:44 <phadej> there's github repo at least
13:44:04 <koz_> phadej: Oh, really? OK, that's a start, thanks.
13:44:21 <phadej> https://github.com/haskellweekly/haskellweekly
13:44:49 <koz_> phadej: Thanks!
13:44:49 <[exa]> koz_: there's a literal sentence about contributing on the main site
13:45:01 <[exa]> either github, or info@haskellweekly dot something
13:45:01 <koz_> [exa]: Shows how good my reading comprehensions is, lol.
13:45:15 <maerwald> koz_: programming messes with your reading ability
13:45:16 <zeta_0> how would you recommend fixing this type error on this mean function? https://dpaste.org/z1RD
13:45:22 <maerwald> I can barely read linearly anymore
13:45:22 <[exa]> koz_: their typesetting could be better tbh. :]
13:46:00 <zeta_0> i'm writing the sum, length, and mean function from scratch
13:46:01 <[exa]> zeta_0: the paste does not display the type error?
13:46:12 <solonarv> zeta_0: 'fromIntegral :: (Integral a, Num b) => a -> b' can specialize to 'fromIntegral :: Int -> Double'
13:46:23 <koz_> zeta_0: Is the function bullying you?
13:46:29 <[exa]> zeta_0: anyway the slash (/) doesn't work for Ints, you need to convert it as ^ solonarv said
13:46:58 <zeta_0> error: couldn't mach expected type Double with actual type Int
13:47:17 <solonarv> also, the type of your sum' is pointlessly narrow; it could just as well be sum' :: Num a => [a] -> a
13:47:39 <koz_> Or even (Num a, Foldable t) => t a -> a
13:48:02 <solonarv> that needs a different implementation, though
13:48:05 <[exa]> zeta_0: also, saying that 0/0=0 is....rude. :]
13:48:35 <zeta_0> ok, i've never used fromIntegral before, so i'm going to have to learn that 1st
13:49:07 <[exa]> zeta_0: takes anything integer-ish and returns whatever numeric type is needed
13:53:16 <zeta_0> ok, one second, i'll show the pastebin of the fixes in a bit
13:54:46 <tamramsyBash> hmm
13:54:51 <tamramsy> this is me
13:54:59 <tamramsyBash> this is me on a bash client!
13:55:00 <merijn> @quote monochrom who.do.you.call
13:55:00 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
13:55:06 --- mode: ChanServ set +o monochrom
13:55:11 --- mode: monochrom set +b *!*@174-086-205-109.res.spectrum.com
13:55:11 --- kick: tamramsyBash was kicked by monochrom (tamramsyBash)
13:55:33 --- kick: tamramsy was kicked by monochrom (tamramsy)
13:56:09 <monochrom> err wait, was it wrong to kickban them?
13:56:24 <maerwald> :D
13:56:25 <koz_> According to the PVP, what kind of version bump is needed if I change the version bounds on a dep?
13:56:32 --- mode: monochrom set -b *!*@174-086-205-109.res.spectrum.com
13:56:34 <merijn> monochrom: Depends, are you into moral relativism? :p
13:56:44 <monochrom> hahaha
13:56:49 --- mode: monochrom set -o monochrom
13:56:53 <merijn> koz_: The PVP page has a flowchart
13:57:01 <merijn> koz_: https://pvp.haskell.org/
13:57:11 <maerwald> koz_: that should be a minor one afair
13:57:13 <phadej> koz_: patch
13:57:15 <koz_> merijn: Awesome, thanks!
13:57:26 <maerwald> so increment anything except A or B
13:57:34 <phadej> and if you relax, then no bound at all; make a revision
13:57:36 <okcool> what the heck
13:57:54 <okcool> why was i banned
13:57:54 <phadej> no version change*
13:58:04 <koz_> phadej: Yeah, it's a relaxation.
13:58:10 <okcool> go die
13:58:11 <phadej> koz_: than make a revision
13:58:14 <okcool> all og you
13:58:18 <maerwald> revisions don't make it into freeze files
13:58:25 <koz_> phadej: OK, thanks.
13:58:37 <okcool> /
13:58:45 <okcool> /nick bruh
13:58:49 <phadej> maerwald: so what?
13:58:52 <okcool> wait shit
13:58:59 <okcool> bash client cant use cmds
13:59:01 <maerwald> phadej: if it's a tightening, it can break freeze files
13:59:10 <phadej> maerwald: as I said, if it's relaxation
13:59:14 <okcool> whores
13:59:15 <phadej> maerwald: please read.
13:59:19 <maerwald> phadej: I did
13:59:27 <monochrom> OK, here is what happened in my brain. I saw (but carelessly) an @ command (didn't check which command) followed by lambdabot mentioning my nick (didn't check the content). So I assumed it was @ops, so I took a look what seemed to be recent bad behaviour, so I kickbanned.
13:59:28 <maerwald> I wasn't commenting on you
13:59:33 <okcool> maerwald
13:59:38 <okcool> wow tags work
14:00:15 <merijn> monochrom: Looks like you got a post hoc justification anyway :p
14:00:33 <okcool> what
14:00:40 <monochrom> oh well
14:00:45 <okcool> monochrom
14:00:50 <merijn> maerwald: otoh, a new version won't end up in the freeze file either :p
14:01:05 --- mode: ChanServ set +o monochrom
14:01:06 --- mode: ChanServ set +o monochrom
14:01:11 <maerwald> merijn: yes and it cannot break them
14:01:16 --- mode: monochrom set +b *!*@174-086-205-109.res.spectrum.com
14:01:28 <phadej> fwiw, freeze files in cabal-install-3.4 will include index-state
14:01:30 --- kick: okcool was kicked by monochrom (okcool)
14:01:34 <maerwald> phadej: oh 
14:01:43 <phadej> so I I don't care.
14:02:31 <phadej> but good we talked about. In fact they should mention active-repositories (a new configuration field in cabal-install-3.4)
14:02:55 <phadej> so your friends overlays won't mess with freeze files either
14:03:07 <maerwald> phadej: what was always confusing to me is the behavior of 'cabal freeze' when there already is a freeze file
14:03:45 <phadej> I have no idea what it does
14:03:53 <phadej> then
14:04:01 * ski makes mental note to quote monochrom, next time there's a spammer
14:04:12 <maerwald> it uses the current freeze file to build the plan and then does nothing afair
14:04:32 <maerwald> always had to delete the freeze file first
14:04:45 * hackage ginger 0.10.0.0 - An implementation of the Jinja2 template language in Haskell  https://hackage.haskell.org/package/ginger-0.10.0.0 (TobiasDammers)
14:04:46 <phadej> that's not unreasonable requirement?
14:04:52 <zeta_0> ok here's my solution, time to test it out(not sure if it's safe though, i'm guessing dividing by 0 will cause a crash): https://dpaste.org/buFg
14:05:01 <maerwald> I'm not sure what most users would expect, but it confused me always
14:05:13 <maerwald> why would you run it if it does nothing?
14:05:28 <dsal> I was dreading making this custom type for my mqttd subscription store.  I finally just typed it up last night and it's like, half a page of code.  A bit more now that I've added some features and made it a Functor, Foldable, Traversable, and Monoid.
14:05:36 <phadej> I guess it could say "there is freeze file, I won't do nothing"
14:05:40 <maerwald> it could do something when you change flags, that is true
14:05:46 <dsal> Now I just need to figure out that whole At/Ixed stuff.
14:06:18 <merijn> maerwald: Makes it convenient to use in a script/makefile without needing logic to check if one exists
14:06:24 <maerwald> which also made me wonder how to include multiple dep-graphs in one freeze file (e.g. flag X on and flag X off)
14:07:17 <phadej> maerwald: that's not a freeze file than?
14:07:20 <dsal> zeta_0: length and sum are both part of Foldable.
14:07:44 <maerwald> phadej: yeah, minus the constraint, it would be more like "stackage" I guess
14:07:49 <dsal> But you could do the same thing without explicitly walking the list twice.
14:08:28 <maerwald> the index-state pinning might already satisfy that...
14:08:42 <maerwald> but I'm not 100% sure that it does
14:09:04 <zeta_0> dsal: yes, there's the built-in functions, but i'm trying to write them from scratch to see how they work
14:14:30 <dsal> zeta_0: makes sense.
14:15:51 <dsal> > let safeDiv _ 0 = Nothing; safeDiv a b = Just (fromIntegral a / fromIntegral b) in   liftA2 safeDiv sum length  [1..100] -- zeta_0 safe division can't return a value, so you can maybe, and applicative can do the rest for you.
14:15:53 <lambdabot>  Just 50.5
14:17:41 <dsal> > liftA2 (/) sum (fromIntegral . length)  [1..100] 
14:17:43 <lambdabot>  50.5
14:17:51 <dsal> > liftA2 (/) sum (fromIntegral . length)  [] 
14:17:53 <lambdabot>  NaN
14:18:04 <dsal> Actually, yeah, that just NaNs on /0
14:19:48 <zeta_0> dsal: thanks, i'll try to implement that in the mean function to get a safe division by 0 error
14:21:13 <dsal> Well, NaN isn't unsafe.
14:21:40 <fweht> just out of interest, i like to use haskell for discrete math problems as equality most of the times means the same thing as in math, so e.g. counting some set of maps, substrings, subsets, etc. is pretty much straightforward.  is haskell the only language which makes this so easy?
14:22:55 <phadej> there are languages with value semantics, but if you ask here, Haskell is the best among them :)
14:23:06 <fweht> great :)
14:23:16 * ski . o O ( signalling `NaN's )
14:26:11 <zeta_0> dsal: i tested out the mean' prime function, and i'm not getting any crashes from a division by 0 error, so i think it's correct: https://dpaste.org/3KdV
14:26:29 <merijn> dsal: Beg to differ
14:26:43 <merijn> Value NaN is the great ruiner of everything nice in the universe
14:27:14 <dsal> Yeah, it won't crash your program, but it's probably not what you want.
14:27:22 <dsal> zeta_0: You don't need quite so many parens.  :)
14:28:13 <dsal> zeta_0: You're also overspecifying a bit -- why does your length function only work with lists of Ints?
14:28:58 <dsal> And your sum should be able to work with any Num
14:29:42 <dsal> But instead of returning an arbitrary value for the average of nothing, why not return Nothing?
14:35:59 <zeta_0> ok, i tried to make it as generic as possible, length' needs to return an Int, so it's causing a type error on the mean' function that i need to fix: https://dpaste.org/oyU9
14:37:55 <dsal> Why does your length only work on lists of numbers?
14:38:05 <solonarv> why does length' have a Num a constraint?
14:38:17 <solonarv> jinx!
14:38:40 <dsal> :t (/)
14:38:41 <lambdabot> Fractional a => a -> a -> a
14:39:07 <dsal> / wants a Fractional, so you'll need to do that conversion.  You can require the sum to be Fractional, or you can convert it, but you'll have to convert the length.
14:40:09 <dsal> zeta_0: Also, `(x:xs) = ( + 1) (length' xs)` would be clearer as `(x:xs) = 1 + length' xs` or `(x:xs) = length' xs + 1`
14:54:04 --- mode: monochrom set -o monochrom
14:54:34 <dsal> zeta_0: If you're wanting to know how things work, try making your own list from scratch.  Then it'll both make a little more sense as to why you're reinventing stuff, but also, you can make it Functor, Applicative, Monad, Foldable, Traversable, etc... instances
14:54:59 <dsal> Oh, and Monoid.  Then suddenly, other than the syntax, your list can do all of the things without writing much code.
14:58:47 <dsal> A Mean semigroup would be pretty neat.
14:59:21 <dsal> I guess it could be a monoid as well, then you could fold into it.
15:00:41 <phadej> https://github.com/futurice/haskell-futurice-prelude/blob/8267200596ca7e5cb08fae9ca3cfd95a3394e321/src/Futurice/Monoid.hs
15:01:28 <ski> binary mean is not associative, though
15:04:29 <fog> I'm trying to write a vector to the disk in binary format
15:04:40 <fog> there seems to be several options
15:04:55 <fog> involving deriving generic and binary instances
15:05:02 <dsal> ski: Why do you (sigh) mean?
15:05:04 <dsal> > getMean $ foldMap (flip Mean 1) [1..100]
15:05:06 <lambdabot>  Just 50.5
15:05:25 <fog> and also Put and Get based things from the cereal library - encoding to Bytestring
15:05:39 <dsal> I have a Mean monoid that's just a sum and a count.
15:05:48 <phadej> fog: if you use `binary`, there's https://hackage.haskell.org/package/binary-instances
15:06:06 <phadej> otherwise i'd probably use `serialise` / `cborg`
15:06:15 <fog> best documnetation ever; https://hackage.haskell.org/package/binary-instances-1.0.0.1/docs/Data-Binary-Instances-Vector.html
15:06:47 <ski> @check let mean a b = (a + b) / 2 in \x y z -> mean (mean x y) z == mean x (mean y z)
15:06:48 <phadej> fog: it re-exports https://hackage.haskell.org/package/vector-binary-instances
15:06:49 <lambdabot>  *** Failed! Falsifiable (after 2 tests and 5 shrinks):
15:06:49 <lambdabot>  0.2983386127273475 2.275239282011174e-2 0.2508477691722533
15:06:52 <phadej> maybe I should say that :)
15:07:42 <monochrom> ski: But they were not doing (a+b)/2.
15:07:59 <monochrom> They were doing the product monoid of length x sum
15:08:02 <dsal> Oh.  I didn't do the average of averages but just a type that collects the as and bs and does the thing as a monoid.
15:08:06 <fog> phadej: hmm, another implementation of Put and Get from Data.Binary
15:08:19 <fog> I cant see any cborg for Vector
15:08:50 <phadej> fog: serialise uses cborg and provides machinery
15:08:53 <phadej> (and instances)
15:09:03 <fog> oh ok
15:09:21 <fog> https://hackage.haskell.org/package/cereal-vector-0.2.0.1/docs/Data-Vector-Serialize.html
15:09:32 <fog> ah, yeah, thats the cerial version of Put and Get
15:10:10 <fog> i guess then I just read and write to disk using Data.Bystring.Strict
15:10:37 <fog> any chance there is code which does this?
15:10:59 <ski> oh. i was wondering about that
15:11:44 <fog> ski: yeah, averages are not really addative
15:11:50 <dsal> @check \a b c -> (Mean a 1 <> Mean b 1) <> Mean c 1   ==  Mean a 1 <> (Mean b 1 <> Mean c 1) -- floating point still messes with me
15:11:52 <lambdabot>  <hint>:1:147: error:
15:11:52 <lambdabot>  parse error (possibly incorrect indentation or mismatched brackets)
15:12:21 <dsal> @check \a b c -> getMean  ((Mean a 1 <> Mean b 1) <> Mean c 1)   == getMean (Mean a 1 <> (Mean b 1 <> Mean c 1))
15:12:24 <lambdabot>  *** Failed! Falsifiable (after 8 tests and 5 shrinks):
15:12:24 <lambdabot>  -0.21579021849932925 -0.9765297894778532 1.1830508633128438
15:12:33 <fog> well, unless you retain the length averaged over along with the returned average 
15:12:45 <monochrom> Perhaps use Rational :)
15:12:56 <dsal> You listening, lambdabot?
15:13:16 <dsal> Though I guess my type being defined that way would be kind of nice.
15:13:17 <ski> @check let mean a b = (a + b) / 2 in \x y z -> mean (mean x y) z == mean x (mean y z :: Rational)
15:13:19 <lambdabot>  *** Failed! Falsifiable (after 2 tests and 35 shrinks):
15:13:20 <lambdabot>  (-145168474655) % 166689747538 (-616435687312) % 5231205909319 (-26489356530...
15:13:39 <fog> monochrom: oh, you mean like just storing the sum and the length?
15:14:01 <ski> (someone should tell `@check' to use the appropriate precedence level)
15:14:09 <fog> like, not actually deviding my the length to get the average, so then you dont need to invert that when adding them together
15:14:37 <fog> or does Rational kind of do some rewrite rule when multiplied by the divisor?
15:15:02 <fog> still wouldnt be a zero cost inverse though because it would have to check for equality
15:15:59 <fog> better just to have a pair of length and sum, and just distribute Sum monoid over the pair
15:16:19 * ski imagines that's what `Mean' does
15:17:04 <fog> oh, I got confused by your lowercase use of mean in the checks above
15:17:45 * hackage aws-cloudfront-signed-cookies 0.2.0.6 - Generate signed cookies for AWS CloudFront  https://hackage.haskell.org/package/aws-cloudfront-signed-cookies-0.2.0.6 (chris_martin)
15:18:21 <matthewma> hey, do you guys red haskell programming from first principles by Chris Allen? Because I am starting learning haskell and I was wondering if you have any opinions
15:19:40 <dsal> :t Mean
15:19:42 <lambdabot> a -> Int -> Mean a
15:19:57 <dsal> I just made the dumbest thing I could think of and type into lambdabot
15:20:10 <dsal> matthewma: I enjoyed that book
15:20:46 <matthewma> I was wondering because it has around 2000 pages
15:21:04 <dsal> You can combine it with other books to get more pages.  I did that.
15:21:46 <matthewma> I was worrying about opposite, isn't it like maybe to detailed or streched out?
15:22:29 <dsal> IME, the fastest way to learn is to take the slower path.  Shortcuts rarely save me time.
15:23:01 <EvanR> take the slow path at full speed
15:23:20 <dsal> Even lately, I waste huge amounts of time trying to shortcut.
15:23:49 <matthewma> Well okay, I hope they don't fire me in the mean time lol
15:24:01 <dsal> I implemented Foldable for my fancy subscription data structure thing and wanted to test it with checkers.  I wasted a bunch of time guessing because this looked too hard to read:
15:24:03 <dsal> `foldable :: forall t a b m n o. (Foldable t, CoArbitrary a, CoArbitrary b, Arbitrary a, Arbitrary b, Arbitrary m, Arbitrary o, Arbitrary (t a), Arbitrary (t m), Arbitrary (t n), Arbitrary (t o), Monoid m, Num n, Ord o, EqProp m, EqProp n, EqProp b, EqProp o, EqProp a, Show (t m), Show (t n), Show (t o), Show b, Show (t a), Show o) => t (a, b, m, n, o) -> TestBatch`
15:24:05 <fog> remove all words occuring less than 3 times
15:24:16 <fog> and that are shorter than 4 letters
15:24:26 <fog> then you can read scientific papers much faster
15:24:50 <dsal> Once I stopped looking for shortcuts and just looked at what that thing said, my tests passed and I was on my way.
15:25:27 <dsal> (of course, writing a tiny bit of documentation there would've also been helpful)
15:26:05 <fog> you could do topic classification to prune away all the "this subject has received increasing attention in recent years" 
15:26:34 <dsal> Is more research on the topic needed?
15:26:56 <monochrom> What topic?
15:27:06 <fog> the topic of boring sentences 
15:27:12 <dsal> I thought we were just summarizing scientific papers.
15:27:31 <dsal> Abstract:  Preliminary results are interesting, but more research is needed.
15:27:46 <monochrom> I thought we were commenting on HFPP. What the hell is with scientific research papers?
15:28:15 <fog> no thats really difficult, you cant expect it to understand the specialist stuff and re-explain it for you, thats what your brain is for - but the word processor can at least make it more concise 
15:28:20 <dsal> monochrom: Do you think HFFP is too long, or too short?
15:28:47 <EvanR> expert clippy
15:29:15 <monochrom> I think it is too long for smarter people, just right for the rest.
15:29:32 <dsal> I think it could've been longer, if that helps you calibrate.
15:29:42 <fog> nub is pretty aggressive... the article cant reuse words, by the time you get to the conclusion its almost with no content 
15:30:24 <monochrom> Yeah I think part of the length and more time is really fillers waiting for you to just accept the math angle.
15:30:34 --- mode: ChanServ set +o monochrom
15:30:45 <monochrom> fog: Are you done with this drivel?
15:31:10 <monochrom> "almost no content" is exactly right though.
15:31:32 <fog> Uploaded file: https://uploads.kiwiirc.com/files/96347beb0e25e00984ab9a92e7dc2120/pasted.txt
15:31:40 <fog> yeah im done, sorry
15:31:59 --- mode: monochrom set -o monochrom
15:32:48 <zeta_0> dsal: thanks, and apologies, i was gone for a while
15:33:41 <dsal> zeta_0: NP.  Just throwing out ideas.
15:35:25 <matthewma> do you guys use haskell in work?
15:36:10 <dsal> Not as much as I'd like.  I did some fairly complicated stuff in haskell a bit back because most things I do are easier in haskell than any other language.
15:36:33 <monochrom> yes
15:37:13 <matthewma> Because I was looking haskell jobs, and there are almost none of them (for software developers), and I was wondering if you should serach for haskell jobs maybe in some other way?
15:37:38 <Uniaika> I do Haskell for a living
15:37:51 <matthewma> How do you guys found job in haskell? 
15:37:54 <matthewma> Was it long time ago?
15:38:01 <monochrom> Mine is a teaching job. I wrote an automarking system in Haskell.
15:38:02 <maerwald> matthewma: without experience, not so easy
15:38:34 <maerwald> It's the experience paradox. Industry wants only experienced devs, but won't hire devs to give them experience.
15:38:47 <Adeon> I sometimes use haskell for small tools and scripts at my work
15:38:54 <Uniaika> hmm, 2 years ago~ish
15:38:58 <Adeon> but it's not a haskell company so I cannot write anything complicated that's supposed to maintained by other people in haskell
15:39:43 <matthewma> Well I have to use in my current job a haskell (but just for one library that we are using and expanding), and I was wondering if it is worth for going that deep into a haskell, because there is almost no jobs on the market.
15:40:11 <Uniaika> matthewma: it's not about the jobs, it's about thinking on how to program
15:40:55 <Uniaika> sure, you can settle for a soulless job in a consulting company, but you can also find opportunities that would make you use your brain, and Haskell can give you tools to program differently
15:41:02 <Uniaika> and sometimes, in a better way ;)
15:41:03 <matthewma> Yea I get it that functional way of programming is different from OOP, but can't you learn it from other languages than haskell, like what's the benefit here?
15:41:05 <Adeon> I think my attitude is that should not learn haskell with the idea that it'll give you a nice job
15:41:09 <Adeon> I got into haskell because I think haskell is fun
15:41:18 <Adeon> of course your desires may be different
15:41:29 <matthewma> But you can find fun job in clojure for example
15:41:41 <Uniaika> you can learn it from OCaml
15:41:42 <matthewma> or like do ai/ml in python
15:41:50 <Uniaika> you can learn it from Lisp languages, like Clojure
15:41:58 <Uniaika> but more importantly, you can learn
15:42:01 <Uniaika> for the sake of learning
15:42:20 <matthewma> Yea, so that's the point, I was wondering if it is worth to dive deep into haskell instead of for example clojure?
15:42:24 <Uniaika> if everything you do is conditionned to the promise of a future job, just stop now because you're going to get burned out
15:42:26 <matthewma> I mean not instead
15:42:30 <matthewma> additionally 
15:42:34 <matthewma> like haskell + clojure
15:42:43 <matthewma> or just only clojure
15:43:02 <Uniaika> I mean, you can't dive "deep" into Haskell because the language is at the intersection of multiple fields of computer science
15:43:44 <Uniaika> so, earn a PhD in each of those fields, advance the state of the art in Haskell, and then consider you did dive "deep"
15:43:49 <Uniaika> just chill with the learning
15:44:00 <Uniaika> I'm working with Haskell at work and I'm a junior, and it's fine
15:44:10 <Uniaika> (both in programming and in Haskell)
15:44:32 <matthewma> The job market was just a reference point, because it will be nice to use what you learned
15:44:48 <dsal> matthewma: If you try to learn all the things at the same time, you'll learn none of the things over a long period of time.
15:45:02 <matthewma> Well I kind of have to
15:45:10 <Uniaika> matthewma: I learned Erlang, after being self-taught in systems administration
15:45:13 <matthewma> because I have tasks to do at work
15:45:35 <Uniaika> and from that point I learned Elixir, which landed me my first job, and in parallel, Haskell, which landed me this current job
15:48:46 <justsomeguy> One thing that Haskell has given me an appreciation for is the distinction between pure functional programming and impure functional programming.
15:49:24 <dsal> matthewma: you can do FP stuff in most languages, but haskell has basic feature that make it easy to make fairly complex things that are hard to use wrong.
15:49:37 <justsomeguy> Not being able to rebind names within a scope has some really far-reaching consequences.
15:49:54 <maerwald> justsomeguy: you can't?
15:50:03 <matthewma> Yea, I see that haskell makes you program in functional way, when other languages makes it more optional
15:50:16 <EvanR> you can rebind names (shadowing)
15:50:17 <dsal> e.g., I keep seeing STM showing up in various languages, but you have to work hard to use them correctly because they can't stop you from doing dumb things.
15:50:40 <justsomeguy> EvanR: I said within a scope. Shadowing introduces a new scope.
15:50:49 <fog> Im not sure of any language as expressive as haskell
15:50:55 <Uniaika> matthewma: I'd say, if you want to apply the teachines of Haskell outside of it, just start by separating the pure code from the adapters to the outside world (DB, API, etc)
15:50:56 <maerwald> EvanR: I also love those scoping erros x vs x' ...both same type, one in the inner "go" and you just messed up a little :)
15:51:01 <EvanR> you can say the same thing about assignment in other languages
15:51:05 <Uniaika> fog: Idris would like to talk to you
15:51:21 <EvanR> each line introduces a new scope, single assignment form
15:51:25 <fog> there are programs you can write in haskell that it would be impossible to write in other languages - regarding type checking 
15:51:57 <EvanR> yeah x and x' are easy to mess up
15:51:59 <fog> Uniaika: isnt Idris to Haskell as Haskell is to C? 
15:52:03 <justsomeguy> maerwald: I'm not sure, but it seems that way. I've only been learning haskell these last few months, but I've also been learning about the lambda calculus, and there is a huge resemblance in how the evaluation model works. I haven't touched monads, yet, though.
15:52:17 <matthewma> But I mean like, what kind of project would you do in haskell and how will it benefit you going with it than other language?
15:52:21 <maerwald> fog: you're saying F# is not expressive enough?
15:52:32 <dsal> matthewma: I do almost everything in haskell.
15:52:41 <matthewma> but I don't know what you do :D
15:52:54 <matthewma> like do you build websites?
15:52:57 <dsal> Right now, I'm writing an mqtt server.  The popular ones out there are written in C or Java.  Getting tired of bugs.
15:53:00 <matthewma> do you create some specialized software?
15:53:06 <dsal> matthewma: I did this recently:  http://dustin.sallings.org/2020/04/29/gopro-plus.html
15:53:10 <dsal> I do a bunch of different things.
15:53:18 <Uniaika> fog: uuh I wouldn't say that, no
15:53:23 <fog> im not sure how you could get to Idris without going via Haskell, though this could change in the future, but I think atm, unless the erlang people have some similar dependently typed language project, that Haskell has the best maintained compiler and language development team of almost any modern language
15:53:32 <dsal> My mqtt server is pretty great.   Doing stuff like this without STM is awful.
15:53:38 <dsal> Or the async lib.
15:53:46 <maerwald> fog: GHC has no full time developer
15:53:53 <matthewma> What is mqtt server?
15:53:59 <EvanR> justsomeguy: in languages where variables themselves are not first class, assignment is very similar to shadowing. Which is how assemblers work by pretending every variable is a register and is assigned exactly once (even if it has the same name)
15:54:04 <dsal> matthewma: IoT pubsub stuff.
15:54:09 <matthewma> oh okay
15:54:09 <fog> maerwald: i never saw much F#, can is it turing complete at type level?
15:54:10 <Uniaika> maerwald: couldn't Ben be considered as one?
15:54:33 <EvanR> s/assemblers/high level language compilers/
15:54:35 <fog> maerwald: i think SPJ at MSR would count as one
15:54:49 <maerwald> fog: no, SPJ is not full time GHC dev
15:55:07 <fog> a labour of love...
15:55:10 <matthewma> @dsal But would you use haskell as a backend for website?
15:55:10 <lambdabot> Maybe you meant: keal eval
15:55:22 <maerwald> fog: so "best maintained compiler" is a bit far fetched
15:55:25 <maerwald> we have a maintenance problem
15:55:37 <fog> yeesk, that doesnt sound good
15:56:02 * Uniaika waves a flad with "plz contribute to the docs 🙏" written on it
15:56:09 <fog> I applied for well typed but then there was lockdown, they do some stuff vended by microsoft for GHC dev 
15:56:19 <solonarv> matheus23: I would. "website backend" is one of the primary "industry" uses for haskell.
15:56:19 <maerwald> Uniaika: afaik he works on it depending on client needs
15:56:22 <dsal> matthewma: I use haskell as my first choice for just about anything.  The GoPro thing I linked you to has a web interface (including feeding my logger to the browser via websockets).
15:57:00 <solonarv> you can even do client-side web programming in haskell, but that's a bit more complicated and still sort of experimental
15:57:07 <Uniaika> maerwald: oh so he could be dispatched on something radically different one day?? :o
15:57:33 <maerwald> I don't know, am not his boss :P
15:58:02 <maerwald> Cale seems to work on GHC too, but said it also depends on client needs
15:58:15 <matthewma> I think the case with other languages they have a lot of libraries/ready tools
15:58:17 <fog> maerwald: if not best maintained compiler, I meant more like, supported by theory which has a strong tradition. even if the people translating research into language extensions are few and far between, the fact the language is built on research in many departments gives a very strong foundation
15:58:17 <matthewma> for doing things
15:58:21 <matthewma> Does that apply to haskell?
15:58:49 <matthewma> Because when you use Clojure or ClojureScript you can use java/javascript libraries, what is a big pool of tools
15:58:58 <matthewma> and do your job quick
15:59:04 <matthewma> in a still functional way
15:59:15 <maerwald> fog: well, the haskell language hasn't evolved in a long time, the last report is 10 years old
15:59:26 <solonarv> I mean, you can use C libraries, but it won't exactly be idiomatic haskell
15:59:47 <fog> I guess because haskell was designed by committee it has a more maintainable trajectory, as opposed to languages which are more of a hodge podge of evolving traditions 
15:59:50 <solonarv> (you can put a nice haskell-y wrapper on top of them, but that's a bit more effort, obviously)
15:59:56 <xcmw> Does any one know how to use the query system in diagrams? I can make it work when all annotations are top level. But how do I handle annotating a Diagram with that all ready has annotations. A B C works but A [1, 2] where 1 and 2 are part of A does not.
16:00:32 <maerwald> fog: well, in a way, that's what GHC is, isn't it? I doubt you could build most of your projects without GHC extensions by now. It's evolution
16:00:38 <mniip> 1589842496 [01:54:56] <matthewma> @dsal But would you use haskell as a backend for website?
16:00:48 <mniip> we use haskell as a backend for a website at work
16:01:11 <fog> Im waiting for first clas type families extension!
16:01:32 <matthewma> @mniip and why you went with haskell?
16:01:33 <lambdabot> Unknown command, try @list
16:01:33 <maerwald> fog: I would argue compiler and language maintenance is sufficient, but not really above average when compared to highly industry backed languages like Java.
16:01:41 <monochrom> GHC extensions are still design-by-committee.
16:02:05 <mniip> well it started from having a certain application that needed to be 100% correct
16:02:06 <monochrom> But our committees are better.
16:02:10 <mniip> so it was written in haskell
16:02:15 * hackage medea 1.1.0 - A schema language for JSON.  https://hackage.haskell.org/package/medea-1.1.0 (koz_ross)
16:02:16 <mniip> and thn everything else was kinda built around it
16:02:23 <dsal> matthewma: I've never bought into the arguments for "look at all the libraries!"  There weren't libraries I needed.  I had to write my own gopro video metadata stream parser.
16:02:24 <mniip> and everyone liked it
16:03:16 <dsal> matthewma: You're going to be on the wrong end of the blub paradox for a while.  I program in a lot of languages, but haskell is the easiest to get my programs up and running.
16:03:32 <fog> yeah, your right, I'm getting to enthused by the support from Microsoft and FB. industrial backers provide the nesacary funds, but if its not used in aviation or engineering applications its going to be way behind in terms of funding. 
16:04:14 <matthewma> dsal well, why spending few months on doing something that is already implemented, and is just part that is not essential for your software?
16:04:16 <maerwald> The last big client of "GHC" afair was Standard Chartered, which initiated the new GC, didn't they?
16:04:18 <fog> iv been pushing towards fininte difference schemes and linear algebra methods for a while as an essential part of the haskell ecosystem for this reason
16:05:22 <dsal> matthewma: I wrote a complete parser for GPMF in like, a day or two.  It was about 10% the size of GoPro's C reference implementation and gives me useful data out of more video streams than theirs does.
16:05:28 <fog> yeah, finance is big too... theres OCaml at Jane Street too. which is kind of a massive success story for functional programming for imbedded systems 
16:05:48 <maerwald> right, but it's so hard to get excited about OCaml
16:06:02 <fog> its the kind of argument thats made where haskell by any guess *should* be better, and they have actually managed to leverage those gains
16:06:12 <Rembane> mniip: I like that story. I was waiting for an evil witch, but it makes me happy that she never materialized.
16:06:41 <fog> OCaml was chosen IIRC because it had exhaustive pattern warnings, which we just got recently in haskell
16:06:59 <matthewma> dsal okaaay, if you are saying that you can write every tool that exists when you need it in few days than okay I guess
16:07:01 <dsal> matthewma: I hardly ever spend "a few months" on any project to get something working.   The GoPro stuff was about two months before I wrote the blog post, but I had to reverse engineer all of the GoPro APIs (they have no published API and nobody had documented them), learned a new language (elm) for the frontend, and created variety of commandline and web tools.
16:07:28 <dsal> This was when I wasn't doing my actual job and then a good chunk of the time was even trying to decide what I wanted to do.
16:07:41 <fog> the curse of FOSS
16:07:59 <fog> nationalise haskell!
16:08:43 <maerwald> fog: ime, writing correct haskell code that is IO heavy, is harder than doing the same in rust. So I'm actually always on the fence for what to use for personal project X
16:09:06 <maerwald> rust is so verbose, I get tired, then I go back to haskell and get annoyed by the exception handling
16:09:25 <Uniaika> (I found the light with MonadError, personally)
16:09:33 <fog> the choice seems simple, if you dont learn languages other than haskell... 
16:09:36 <dsal> matthewma: I started this mqtt broker a couple weeks ago.  Lots of learning along the way.  But it already has features from the spec that I couldn't find any mainstream implementations of.
16:09:37 <Uniaika> (well, this, and I don't have to rely much on exceptions)
16:09:44 <nil> when are `f x = ...` and `f = \x -> ...` different? i think i've read about some edge case before
16:10:00 <maerwald> Uniaika: when you call lots of unix functions, everything is an exception and half of it isn't documented
16:10:02 <Uniaika> nil: yes I remember this. 
16:10:11 <Uniaika> maerwald: hear hear…
16:10:18 <nil> obviously where bindings would behave differently, but i think it was something else
16:10:32 <maerwald> whatever you use in your own library, you painfully build yourself
16:10:34 <ski> nil : multiple equations, DMR, matching failure
16:10:51 <nil> ski: DMR?
16:11:09 <ski> Dreaded Monomorphism Restriction
16:11:15 <Uniaika> ski: tell us more!
16:11:16 <nil> ah yes
16:11:20 <nil> that was the thing
16:11:45 <fog> is Monomorphism like monotypes vs polytypes?
16:11:51 <ski> no
16:11:55 <solonarv> nil: also inlining
16:12:07 <nil> how does inlining differ?
16:12:26 <fog> damn, I thought now that I understood higher rank types that it would be the same
16:12:32 <solonarv> ghc decides a function's arity based on how many arguments are to the left of the =
16:12:46 <solonarv> and will inline only when that many arguments are supplied at the call site
16:12:52 <nil> ugh
16:13:30 <koz_> solonarv: So pointfree = maximum inlinage?
16:13:51 <solonarv> yes but there are other downsides to that
16:13:52 <fog> also if you have several function implementations matching on different cases, they all have to have the same number of args on the lhs, so in that case you couldnt commute them over the - into a lambda on the rhs
16:14:12 <nil> yeah, i'm aware of that
16:14:12 <fog> over the = *
16:15:27 <fog> can you bind types using scoped type valraibles in lambdas to the same effect as at function arguments?
16:16:19 <fog> % let f = \(x :: Proxy a) -> (undefined :: a)
16:16:19 <yahb> fog: 
16:16:23 <fog> hmm..
16:16:39 <ski> > (\False () -> ()) True `seq` ()
16:16:41 <lambdabot>  ()
16:16:41 <ski> > (\False -> \() -> ()) True `seq` ()
16:16:43 <lambdabot>  *Exception: <interactive>:3:2-20: Non-exhaustive patterns in lambda
16:17:20 <fog> !?
16:17:33 <nil> splendid
16:20:24 <fog> oh i get it
16:20:49 <fog> if it only matches on one argument it returns a function, and can be forced to evaluate against True
16:21:07 <fog> but the pattern matching wont happen when it expects two args, and is only given one
16:21:33 <ski> yes
16:22:51 <ski> Uniaika : fog already covered the "multiple equations" thing
16:23:00 <fog> in both cases seq forces the return of a function, but unless the lambda is used, it is either a partially applied function of two arguments, or a fully applied function of one argument returning another one arg function
16:23:15 <freeman42x[m]1> having following: `type Stack = [Int];  data StackM a = SM (Stack -> Maybe (a, Stack))` how could I construct a `StackM a` ?
16:25:14 <solonarv> do you have an 'a' ?
16:25:16 <dsal> SM (const Nothing)   ?
16:25:53 <ski> freeman42x[m]1 : would you like it to express some particular computation ?
16:26:30 <freeman42x[m]1> solonarv: would `StackM Int` mean it is a Stack of Integers ?
16:26:55 <ski> no
16:27:29 <ski> it means it's a computation that transforms an input stack of `Int's to a corresponding output one, while also computing a result of type `Int'
16:27:52 <fog> its some kind of "measure" and "modify" state function...
16:27:53 <ski> well, it could also fail to produce any output (stack or result)
16:28:37 <fog> you could have a ~ Int, and get the length of the stack, and filter it to remove values equal to the length 
16:28:42 <freeman42x[m]1> to give more context, `Stack a` in this case is: a monad which maintains a stack as state and may also fail (combination of the State and Maybe monads)
16:29:05 <fog> then unfolding it would give the list of successive lengths as [a]
16:29:36 <ski> freeman42x[m]1 : no. that's `StackM a', not `Stack a'
16:29:52 <freeman42x[m]1> so, how would I construct a meaningful stack? let's say a stack containing values 1 1 1
16:30:03 <freeman42x[m]1> ski: correct, that was a typo
16:30:06 <ski> > [1,1,1]
16:30:09 <lambdabot>  [1,1,1]
16:30:14 <ski> would that do ?
16:30:32 <fog> % type Stack = [Int];  data StackM a = SM (Stack -> Maybe (a, Stack))
16:30:32 <yahb> fog: 
16:30:53 <fog> % [1,1,1] :: Stack 
16:30:53 <yahb> fog: [1,1,1]
16:31:01 <ski> % meaningfulStack :: Stack; meaningfulStack = [1,1,1]
16:31:01 <yahb> ski: 
16:31:45 <freeman42x[m]1> sorry, fixing my typo: how would I construct a meaningful `StackM a`? let's say one containing values 1 1 1
16:31:58 <dsal> That looks like it's happening in yahb 
16:32:51 <ski> freeman42x[m]1 : a value of type `StackM a' doesn't really contain any stack values
16:33:25 <freeman42x[m]1> ski: where are the values stored then?
16:33:28 <ski> it's a computation that, if given an input stack, will compute stuff, either failing, or generating an output stack, and an `a' result
16:33:57 <fog> % let stackF = SM (\(xs::Stack) -> if null xs then Nothing else let l = length xs in Just (l,filter (not.(l==)) xs))
16:33:57 <yahb> fog: 
16:33:58 <ski> well, e.g. in the input stack that you hand to it, when you run/perform/execute that stack-transformer action
16:34:11 <ski> % :t stackF
16:34:11 <yahb> ski: StackM Int
16:34:50 <ski> % case stackF of SM f -> f [1,3,2]
16:34:50 <yahb> ski: Just (3,[1,2])
16:34:52 <freeman42x[m]1> oh, because this is combining State and Maybe monads it is a monad transformer?
16:34:57 <ski> no
16:35:07 <ski> it transforms stacks, not monads
16:35:29 <freeman42x[m]1> so not all combinations of monads are monad transformers?
16:35:32 <ski> fog defined an example action that transforms stacks
16:35:55 <ski> monad transformers are used to build monads, not the other way around
16:36:34 <freeman42x[m]1> I have the feeling there is some word play game here...
16:36:43 <fog> % let runStack (f :: StackM a) (xs :: Stack) = case f of SM f -> f xs
16:36:43 <yahb> fog: 
16:36:52 <ski> `StateT Stack' is a monad transformer. applying it to the monad `Maybe' yields the monad `StateT Stack Maybe'. which is basically what your `StackM' is
16:36:55 <fog> % runStack stackF [1,2,3]
16:36:55 <yahb> fog: Just (3,[1,2])
16:37:01 <fog> % :t runStack
16:37:01 <yahb> fog: StackM a -> Stack -> Maybe (a, Stack)
16:37:10 <fog> :t unfoldr
16:37:11 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
16:37:16 <ski> freeman42x[m]1 : just in case this isn't clear, monads are not values that are passed around at run-time
16:37:57 <fog> % unfoldr (runStack stackF) [1,2,3]
16:37:57 <yahb> fog: [3,2,1]
16:38:02 <ski> freeman42x[m]1 : e.g. `getLine', of type `IO String', is not a monad. it's a monadic action. specifically an `IO'-action
16:38:15 <fog> % unfoldr (runStack stackF) [1,2,3,2,1,2,3,4,5]
16:38:15 <freeman42x[m]1> ski: oh, time for me to re-read the entire Haskell from first principles book. Or better, a short tutorial that explains only this
16:38:21 <yahb> fog: [9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9
16:38:22 <ski> freeman42x[m]1 : likewise, the `stackF' that fog defined is a `StackM'-action
16:38:24 <fog> !?
16:39:00 <freeman42x[m]1> oh yeah, I get this part: `getLine', of type `IO String', is not a monad. it's a monadic action.
16:39:12 <fog> ah, its longer than the largest int... ok nvm
16:39:43 <ski> freeman42x[m]1 : for some reason, it seems beginners often have trouble with that distinction. i'm not able to say whether you had or not, though
16:39:47 <fog> could mod by lenght, but i best actually do something useful with my life
16:39:53 <fog> ciao!
16:40:03 <freeman42x[m]1> quite hard for me to follow all this inline run Haskell code here :(
16:40:48 <ski> freeman42x[m]1 : yea, i think some simpler actions would help
16:41:24 <ski> freeman42x[m]1 : e.g., can you imagine an action that pulls off the top element from the input stack ?
16:41:31 <freeman42x[m]1> I will read more the Haskell code I have and see what I can understand from it based on what you guys taught me
16:42:03 <freeman42x[m]1> ski: depends what you mean by imagine. You are talking about `pop`
16:42:27 <ski> yes
16:42:36 <ski> do you think you could define it ?
16:42:47 <ski> as a `StackM'-action ?
16:43:02 <koz_> Is there a way to make 'cabal new-haddock' error out when there's missing docs for some publically-visible stuff?
16:43:14 <sm[m]> matthewma: how did you like the fast book I showed ? (HTAC)
16:45:14 <Lycurgus> has the death of Eddie Haskell been noted?
16:45:22 * ski prefers the name `pull' to `pop', though
16:45:39 <ski> hm, is that his son, Lycurgus ?
16:45:48 <monochrom> pushouts and popbacks? :)
16:45:56 <ski> well, that too
16:46:16 <Lycurgus> no he's not Eddie Curry
16:46:54 <Lycurgus> the actors real name is Ken Osmond
16:47:21 <freeman42x[m]1> ski: I do not know how I would define `pop` as a `StackM a` action since it is not clear to me how `StackM a` is supposed to work and what I can change about it
16:54:49 <freeman42x[m]1> @ski: how would I implement `pop`? where would I start from?
16:54:49 <lambdabot> Unknown command, try @list
16:58:02 <ski> freeman42x[m]1 : hm, sorry, was looking up something
16:58:34 <freeman42x[m]1> ski: why are you apologizing? you are he one teaching me stuff for free lel :D
16:58:35 <ski> freeman42x[m]1 : start by defining a function that takes a stack, and maybe outputs a stack, and a result
16:58:48 * ski apologizes for apologizing
17:02:30 <freeman42x[m]1> ski: you can't apologize for apologizing! that is illegal, it violates monad laws or something
17:02:53 <ski> i'm sorry :(
17:07:51 <Axman6> I'm offended by this whole conversation and demand an apology
17:08:25 * ski apologizes for not being able to offer an apology
17:09:07 <freeman42x[m]1> is ApologyM a monad?
17:14:43 <d34df00d> Can you just join apologies?
17:16:28 <dsal> Monad?  I don't think apologies are even applicative here.
17:16:56 <koz_> Are they even functors? If you have a -> b, can you turn an Apology for a into an Apology for b?
17:17:11 <mniip> anything can be twisted into anything else
17:17:21 <koz_> mniip: Get your unsafeCoerce# out of here! :P
17:17:32 <mniip> the RealWorld is not safe
17:17:49 <d34df00d> I think that's actually a cofunctor.
17:17:50 <dsal> accuse <$> apology  = I'm sorry you're too dumb to understand.
17:18:00 <d34df00d> Or what's the right term meh.
17:18:15 <d34df00d> If you have a function a -> b, you can turn an Apology for b into an Apology for a.
17:18:16 <koz_> d34df00d: Are you thinking of a contravariant functor perhaps?
17:18:20 <d34df00d> Yea yea .
17:18:20 <koz_> Yep, you are.
17:18:25 <ski> no such thing as "cofunctor"
17:18:27 <mniip> The real world is deeply magical... It is primitive, but not unlifted (hence ptrArg)
17:18:46 <koz_> 'not unlifted' feels like it should be 'lifted'. :P
17:18:58 <d34df00d> koz_: that's axiom of excluded middle.
17:19:02 <d34df00d> Heavily frowned upon.
17:19:10 <koz_> d34df00d: Yeah, it's non-constructive.
17:19:27 <mniip> % :doc RealWorld
17:19:28 <yahb> mniip:  @RealWorld@ is deeply magical. It is /primitive/, but it is not; /unlifted/ (hence @ptrArg@). We never manipulate values of type; @RealWorld@; it's only used in the type system, to parameterise @State\#@. 
17:19:45 <dsal> I think contravariant functor is when you add unnecessary conditions to your apology.   "If that makes you feel bad, I'm sorry."
17:20:19 <d34df00d> That can be parsed ambiguously btw.
17:20:26 <d34df00d> And the other parse tree is for jerks.
17:20:26 <dsal> :t contramap
17:20:29 <lambdabot> Contravariant f => (a -> b) -> f b -> f a
17:21:15 * hackage base64 0.4.2 - Fast RFC 4648-compliant Base64 encoding  https://hackage.haskell.org/package/base64-0.4.2 (topos)
17:23:26 <MarcelineVQ> Why is https://hackage.haskell.org/package/bytestring-0.10.10.0/docs/Data-ByteString.html#v:intersperse  O(n) ?  is it because it visits every element of the argument ByteString?
17:25:19 <dsal> How else would you do that?
17:25:51 <MarcelineVQ> I'm not sure, but it's 2n-1 steps to create the result so why is that not the measure?
17:26:42 <Axman6> that's not how big-O notation works
17:26:54 <Axman6> 2n-1 is O(n)
17:31:08 <EvanR> 2n-1 and n are always within a multiplicative constant from each other, which you can ignore. Sometimes to comedic effect depending on the constant
17:31:21 <monochrom> Similarly binary-search-tree delete is considered O(lg n) because, not despite, there are 2 * lg n + change steps.
17:31:45 <monochrom> However!  If you write O(2 * lg n + change) you're still right :)
17:33:02 <monochrom> You will feel better when you realize that "step" is vauge. :)
17:33:13 <EvanR> linear search through ram is O(1). binary search is O(log n)
17:33:43 <MarcelineVQ> baffling. I've seen people worry about n^2 though, n^2 is different? yet if I have 10n and n = 10 then I have n^2 don't I? so why is the constant so discountable?
17:34:18 <EvanR> n^2 exceeds n by any fixed constant
17:34:23 <EvanR> eventually
17:34:33 <d34df00d> Binary search is O(n²).
17:34:35 <d34df00d> Change my mind.
17:35:44 <MarcelineVQ> I see how I'm being silly on that last one
17:36:35 <d34df00d> I don't understand why they don't write \Theta(n) on that intersperse method, there's a precise bound there.
17:39:15 * ski . o O ( "The Myth of RAM, part I" by Emil Ernerfeldt in 2014-04-21 at <http://www.ilikebigbits.com/2014_04_21_myth_of_ram_1.html> )
17:41:07 <ski> MarcelineVQ : it's not about the value of particular expressions, but about functions. perhaps one ought to write ⌜O(n ↦ n²)⌝
17:44:23 <koz_> d34df00d: Because everyone habitually puts Big-O bounds where Big-Theta bounds should go.
17:45:03 <koz_> It is a pet peeve of mine also.
17:46:46 * hackage medea 1.1.1 - A schema language for JSON.  https://hackage.haskell.org/package/medea-1.1.1 (koz_ross)
17:47:53 <Axman6> is that you koz_?
17:48:03 <mniip> a pet peeve of mine is that O(f) should be called big-omicron
17:48:04 <koz_> Axman6: The very same.
17:48:16 <koz_> I am some variant of 'Koz Ross' everywhere.
17:48:19 <mniip> to pair with big-omega
17:48:34 <koz_> mniip: And Big-Theta!
17:52:12 <d34df00d> I'm getting stupid towards the evening. What symbols should I throw at the compiler to combine `f :: A -> B -> m C`, `a1 :: m A` and `a2 :: m B` to get `m C`?
17:52:27 <d34df00d> a2 >>= (a1 >>= f) seems kinda backwards, plus an extra pair of parens, meh...
17:52:40 <MarcelineVQ> Thanks for the responses. https://en.wikipedia.org/wiki/Analysis_of_algorithms#Run-time_analysis is providing some insight about how O is used which is clarifying
17:53:05 <MarcelineVQ> ski: which came from your link
17:54:32 <d34df00d> I know some folks who can give pretty tight bounds on divide and conquer or dynamic programming sort of algorithms by using integrals or something (typically obtaining logn where I would get a mere n or worse). That sorcery is way beyond my level.
17:54:45 <MarcelineVQ> :t ((join .) .) . liftA2
17:54:47 <lambdabot> Monad m => (a1 -> b -> m a2) -> m a1 -> m b -> m a2
17:55:08 <d34df00d> MarcelineVQ: haha, thanks!
17:55:24 <d34df00d> But I'm not sure it's worth putting it as I intend somebody else to be able to read this.
17:55:36 <MarcelineVQ> well you'd use points, I just didn't feel like writing another lambda today
17:56:24 <MarcelineVQ> but in case it's unclear: \f x y -> join (liftA2 f x y)
17:56:29 <d34df00d> Well, I can maybe write something with the do notation, giving proper names to the intermediate bindings and so on. Not sure if that's haskellic though.
17:56:58 <MarcelineVQ> Don't be shy about do notation if your type is already a Monad
17:57:38 <d34df00d> Yep, it very much is.
17:58:04 <ski> MarcelineVQ : also <https://en.wikipedia.org/wiki/Landau_notation>
18:00:38 <ski> d34df00d : `join (liftA3 f a0 a1 a2)' (changing it to three parameters), or, if you define `infixl 4 <*>>; (mamb <*>> ma) = join (mamb <*> ma)' you can say `f <$> a0 <*> a1 <*>> a2'
18:01:19 <ski> MarcelineVQ : but the notation is typically used confusingly ..
18:07:05 <d34df00d> Hmm, maybe that <*>> should go to Control.Monad.Extra from the extra package or something.
18:07:11 <d34df00d> Looks useful!
18:09:16 <ski> i've found it useful, some times ..
18:15:44 <koz_> @pl \f x y -> join (liftA2 f x y)
18:15:44 <lambdabot> ((join .) .) . liftA2
18:15:53 <koz_> d34df00d: There ya go, best solution.
18:20:48 <d34df00d> Well, I decided to go with the more explicit approach :)
18:21:07 <d34df00d> Thanks for the replies! That's fun I completely forgot about join here.
18:21:15 <topos> @pl liftJoin2
18:21:15 <lambdabot> liftJoin2
18:21:20 <topos> ^ optimal solution
18:21:24 <topos> :D
18:21:38 <topos> :t liftJoin2
18:21:40 <lambdabot> error: Variable not in scope: liftJoin2
18:21:42 <topos> damn
18:22:09 <d34df00d> Hah, cool!
18:22:16 <d34df00d> Yeah, found it in utility-ht.
18:22:55 <topos> it's the shape of `\f x y -> do a <- x; b <- y; f a b`
18:23:26 <topos> or "merge two parallel computations" if you can manage the middle bits in parallel
18:23:46 * hackage medea 1.1.2 - A schema language for JSON.  https://hackage.haskell.org/package/medea-1.1.2 (koz_ross)
18:24:06 <topos> which is what this guy does: https://hackage.haskell.org/package/monad-parallel-0.7.2.3/docs/src/Control-Monad-Parallel.html#MonadParallel
18:24:08 <liiae> there's a number sequence like [1, 5, 9, 13, 2, 4, 6, 8, 10, 12, 3, 7, 11], what's the secret in it?
18:24:20 <liiae> how to get a function to get that list?
18:24:47 <koz_> liiae: const [1, 5, 9, 13, 2, 4, 6, 8, 10, 12, 3, 7, 11]
18:24:49 <koz_> :P
18:24:52 <topos> LOL
18:24:54 <topos> nice
18:24:59 <koz_> A function was requested.
18:25:02 <koz_> A function I provided.
18:25:06 <liiae> koz_: it's a inifite list...
18:25:21 <koz_> liiae: cycle [1, 5, 9, 13, 2, 4, 6, 8, 10, 12, 3, 7, 11]
18:26:02 <koz_> Actually wait, not a function. const (cycle [1, 5, 9, 13, 2, 4, 6, 8, 10, 12, 3, 7, 11])
18:27:37 <mniip> > ap (zipWith subtract) tail [0,1,6,15,28,30,34,40,48,58,70,73,80,91]
18:27:39 <lambdabot>  [1,5,9,13,2,4,6,8,10,12,3,7,11]
18:28:06 <topos> > take 12 $ [ x + 1 | x <- [0,4..] ]
18:28:08 <lambdabot>  [1,5,9,13,17,21,25,29,33,37,41,45]
18:28:23 <topos> oh no i totally only read the first 4 numbers ahaha
18:28:39 <bravech> hey, working my way through LYAFGG. Is "import Something as Something" valid? or should I split it into two separate imports
18:28:42 <koz_> topos: So, the software development approach? :P
18:28:54 <koz_> 'It fulfils 33% of the spec, good enough to ship right?'
18:28:57 <topos> koz_ ma heart
18:29:10 <mniip> bravech, it is valid, but what do you expect it to do?
18:29:18 <liiae> [1,5,9,13,17,2,4,6,8,10,12,14,16,3,7,11,15]
18:29:46 <bravech> import as much as it can into the global namespace and if there's a conflict import the conflict as a qualified statement
18:30:21 <mniip> that's not how conflicts work
18:30:23 <koz_> bravech: I am not aware of _any_ language in which imports can be defined this way.
18:30:31 <bravech> ok ok
18:30:38 <mniip> it doesn't actually "populate" some global namespace
18:30:42 <koz_> topos: :D
18:30:52 <mniip> rather when you use an identifier, it looks into imported modules
18:31:14 <mniip> and if it sees several imports that provide that identifier it's a conflict
18:31:23 <mniip> whether unqualified or qualified with the same name
18:31:42 <bravech> what namespace are builtin functions in? 
18:31:57 <mniip> the same
18:32:06 <mniip> it's as if your file began with `import Prelued`
18:32:06 <topos> koz_ nice looking Tyler Perry lib btw
18:32:08 <mniip> Prelude*
18:32:18 <mniip> but also note that imports do not have any sort of ordering to them
18:32:56 <ski> @where LYAFGG
18:32:57 <lambdabot> I know nothing about lyafgg.
18:33:01 <ski> bravech : what's that ?
18:33:07 <mniip> (with a certain quirk regarding rebindable syntax)
18:33:17 <bravech> I forgot a letter
18:33:22 <bravech> learn you a haskell for great good
18:33:24 <d34df00d> Learn you an APL
18:33:28 <ski> oh
18:33:31 <ski> @where LYAH
18:33:32 <lambdabot> http://www.learnyouahaskell.com/
18:33:35 <koz_> topos: Tyler Perry?
18:33:41 <koz_> I am unaware of the reference you are making.
18:34:06 <bravech> it's what ski linked
18:34:06 <topos> https://en.wikipedia.org/wiki/Madea
18:34:07 <topos> :P
18:34:07 <mniip> `do { x <- k; f x }` will always use Prelude.>>= even if you have other imported things named >>= or if you hide >>= from Prelude's import list
18:34:08 <MarcelineVQ> madea: makes a haskell lib
18:34:14 <mniip> unless you enable an extension
18:34:20 <koz_> topos: ROFL
18:34:24 <koz_> Not the reference we were after.
18:34:29 <topos> XD
18:34:29 <koz_> But sure, why not?
18:34:32 <topos> YOU DIDN'T KNOW 
18:34:36 <koz_> NO I DID NOT
18:34:53 <koz_> WHAT IS THIS 'POPULAR CULTURE' YOU KEEP REFERRING TO
18:34:55 <bravech> so what does import Something as Something do specifically
18:34:59 <topos> ahahahha
18:35:02 <bravech> compared to import qualified Something as Something
18:35:17 <mniip> import qualfied doesn't make the identifiers available unqualified
18:35:33 <bravech> and import without qualified does?
18:35:46 <mniip> yes
18:35:56 <bravech> oh ok and ghc notices if there's a conflict 
18:35:57 <bravech> nice
18:36:13 <mniip> suppose `module M ( x )`, then `import M as X` lets you use both `x` and `X.x`
18:36:38 <mniip> `import M` only lets you use `x`, `import qualified M as X` only lets you use `X.x`
18:36:53 <mniip> `import qualified M` stands for `import qualified M as M`
18:37:16 <bravech> oh so it's the same as doing both 
18:38:14 <bravech> alright, thanks for your help
18:38:23 <mniip> certain modules are designed to be imported qualified and it is a common idiom to import them twice: unqualified import of the necessary *types*, and qualified import of the functions
18:38:37 <mniip> import Data.Text (Text); import qualified Data.Text as T
18:39:06 <Axman6> Quite a few editors have a macro for that which I added (usually as impq<tab>)
18:43:20 <liiae> is there a easy to get a reverse function?
18:43:36 <liiae> f(1)=3, f'(3)=1
18:49:48 <Axman6> no
18:50:26 <mniip> if f is computable and surjective then yes
18:52:11 <dsal> hash mypassword = x;   hash' x == profit
18:52:56 <mniip> @let rev f y = head [x | x <- [(0 :: Natural)..], f x == y]
18:52:57 <lambdabot>  Defined.
18:53:00 <mniip> :t rev
18:53:01 <lambdabot> Eq a => (Natural -> a) -> a -> Natural
18:53:21 <mniip> > rev (+3) 10
18:53:23 <lambdabot>  7
18:53:46 <mniip> it will not be fast, but you didn't specify
18:54:49 <liiae> mniip: wow
18:57:28 <liiae> what if it's like `f "abcd" = "bcde"`, can we get `f' "bcde" = "abcd"`?
18:58:39 <dsal> Did you read what mniip wrote?
18:59:14 <liiae> I did, but I don't understand
18:59:19 <dsal> Heh, start there.
18:59:43 <mniip> hmm
18:59:50 <mniip> with some tricks I suppose that's possible
19:00:00 <mniip> but that code is too large to fit on this IRC margin
19:00:18 <dsal> > let f = reverse . take 5 . reverse  in   f  "How would you reverse this?"
19:00:20 <lambdabot>  "this?"
19:00:37 <dsal> liiae: ^ consider
19:00:54 <liiae> > let s n = [1..n]; g n = (tail . reverse $ s n) <> (tail $ s n) ; f n = (s n) <> cycle (g n) in f 5
19:00:56 <lambdabot>  [1,2,3,4,5,4,3,2,1,2,3,4,5,4,3,2,1,2,3,4,5,4,3,2,1,2,3,4,5,4,3,2,1,2,3,4,5,4...
19:01:01 <liiae> I need to get the f'
19:01:40 <dsal> You just want the local maximum?
19:02:17 <liiae> no, I want f' [1,2,3,4,5,4,3,2,1.... = n
19:02:36 <dsal> What's the difference between that and the local maximum?
19:02:37 <liiae> n is [1...n]
19:03:09 <dsal> The parameter to f there is 5.
19:03:21 <dsal> If you want to feed it that infinite list and get 5 back, that's the local maximum.
19:03:25 <mniip> actually that one is impossible
19:03:27 <dsal> For this particular sequence.
19:03:42 <mniip> non-strict data is computation, and we cannot denumerate computations internally in the language
19:04:16 <mniip> liiae, what are you actually trying to do
19:04:19 <mniip> I should've asked sooner
19:04:45 <liiae> mniip: decode Rail Fence Cipher
19:05:06 <liiae> mniip: that f above is the encoding
19:05:30 <mniip> yeah nah that's not gonna work
19:05:31 <liiae> I found decode is more harder than encode
19:05:58 <liiae> but that work on encode
19:06:50 <liiae> mniip: https://paste.ubuntu.com/p/vNndYPfpPQ/
19:07:42 <liiae> mniip: the origin question https://www.codewars.com/kata/58c5577d61aefcf3ff000081
19:08:09 <dsal> liiae: What do you expect f' to return in that case if not 5?
19:09:01 <mniip> so the hardest bit is doing some modular arithmetic to find out how many letters are on each rail
19:09:22 <liiae> dsal: that 5 should be given at first
19:09:27 <mniip> then you just split your input list into rails by length and slurp characters from the rails one by one
19:10:13 <mniip> the simplest way to achieve this would be to take the length of the input and count manually
19:10:20 <dsal> liiae: You're not making much sense.  The example you showed is `f 5 = [1,2,3,4,5,4,3,2,1,2,3,4,5,4,3,2,1,...]` and you want to know what `f' [1,2,3,4,5,4,3,2,1,2,3,4,5,4,3,2,1,..]` is.  What do you expect?
19:11:03 <liiae> dsal: sorry, it should be f' n (f n) = [1..n]
19:12:51 <dsal> Well, if `f n = [1..n]` then `f' n` must be `const id` or something like that.
19:18:14 <dsal> > let findMax f (x:xs) = go xs x where go [] r = r; go (x':xs') r | f x' < f r = r | otherwise = go xs' x' in     findMax [1..5]
19:18:16 <lambdabot>  error:
19:18:16 <lambdabot>      • Couldn't match expected type ‘t -> ()’
19:18:16 <lambdabot>                    with actual type ‘[Integer]’
19:18:28 <dsal> > let findMax f (x:xs) = go xs x where go [] r = r; go (x':xs') r | f x' < f r = r | otherwise = go xs' x' in     findMax id [1..5]
19:18:31 <lambdabot>  5
19:18:51 <dsal> > let findMax f (x:xs) = go xs x where go [] r = r; go (x':xs') r | f x' < f r = r | otherwise = go xs' x' in     findMax id (cycle $ [1..5] <> [4..2])
19:18:54 <lambdabot>  5
19:19:20 <dsal> > let localMax (x:xs) = go xs x where go [] r = r; go (x':xs') r | x' < r = r | otherwise = go xs' x' in     localMax (cycle $ [1..5] <> [4..2])
19:19:22 <lambdabot>  5
19:19:36 <dsal> *sigh*  I thought I was in a pm.  Sorry about that.
19:22:09 <liiae> mniip: actually, when the list length is 25 and rails number is 2, let's call it position1 and postion2 for that two rows, that position1 length is 13 and postion2 length is 12, when rails is 3, it's [7,12,6], when it's 4, it's [5,8,8,4] ...
19:22:45 <dsal> Oh.  That's quite different from what you were describing.
19:23:26 <liiae> if I can get the rows length, like for rails is 3, it's [7,12,6], it means [1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3]
19:23:40 <liiae> dsal: it's the same
19:23:46 <liiae> decode rails fence cipher
19:24:33 <dsal> The function you showed above did something considerably different.
19:24:33 <liiae> dsal: we can get 
19:24:37 <liiae> > let s n = [1..n]; g n = (tail . reverse $ s n) <> (tail $ s n) ; f n = (s n) <> cycle (g n) in f 3
19:24:39 <lambdabot>  [1,2,3,2,1,2,3,2,1,2,3,2,1,2,3,2,1,2,3,2,1,2,3,2,1,2,3,2,1,2,3,2,1,2,3,2,1,2...
19:24:56 <dsal> Right.  That's pretty easy to reverse.
19:25:16 <dsal> > let localMax (x:xs) = go xs x where go [] r = r; go (x':xs') r | x' < r = r | otherwise = go xs' x' in     localMax [1,2,3,2,1,2,3,2,1,2,3,2,1,2,3,2,1,2,3,2,1,2,3,2,1,2,3,2,1]
19:25:18 <lambdabot>  3
19:25:28 <dsal> That's the 3 in `f 3` above.
19:29:25 <liiae> mniip: the length is 25, rails is 3, the three rows length is[7,12,6], so the first 7 number is in position 1, and after that, the next 12 numbers in postion 2, and the last 6 number are in position 3
20:13:45 * hackage acid-state 0.16.0.1 - Add ACID guarantees to any serializable Haskell data structure.  https://hackage.haskell.org/package/acid-state-0.16.0.1 (JeremyShaw)
20:44:49 <dsal> Huh.  I was making my thing a functor and traversable and turns out GHC can do that for me.   Would've saved me some refactoring time.
21:03:25 <remexre> any suggestions for a faster edit-compile-test cycle w/ cabal-v2? counting one-missisippi, two-missisippi, etc. got me to 12s between running cabal v2-run test-suite:tests and the tests actually starting to execute
21:13:32 <liiae> https://www.codewars.com/kata/5c2fcbcba305ad2c4a91122d
21:13:44 <liiae> how to prove that with haskell?
21:14:11 <liiae> can we use program to prove math?
21:16:56 <Axman6> it's pretty simple to prove is you use peano arithmetic, dsata Nat = Zero | Succ Nat. plus Zero x = x, plus (Succ x) y = Succ (plus x y). then prove that forall xs and ys, plus xs ys = plus ys xs (IIRC it's not super trivial to prove this)
21:18:05 <dmwit> (associativity, not commutativity)
21:18:39 <liiae> Axman6: dmwit python or js can do this?
21:19:24 <Axman6> literally any language can do this
21:20:10 <liiae> what is Nat
21:20:27 <Axman6> a natural number. it is exactly what its definition above says it is
21:20:28 <dmwit> I guess you have to say what you consider a proof to be in Python or JS first.
21:20:49 <dmwit> Axman6: I think you might want to click on the link. The things you are saying don't appear to line up with the kata statement.
21:20:54 <dmwit> (the link inside the link)
21:21:28 <Axman6> oh, I just skimmed the text... why isn't the problem in the text :\
21:21:57 <dmwit> For the same reason we have modules that we can just import in Haskell?
21:22:06 <dmwit> DRY
21:22:24 <Axman6> banner blindness is a thing
21:23:24 <dmwit> liiae: Anyway. I think you should probably try to write down the type of the function that acts as the proof first. Propose it in here and we'll agree or disagree, and give some slight pushes towards the correct answer if you're struggling.
21:24:01 <{abby}> that's in the kata too
21:24:29 <dmwit> Hm. I don't see it.
21:24:35 <wavemode> look like they want you to use dependent types. if your solution typechecks then it's proved
21:24:50 <dmwit> The kata in the kata has a type for a different proof, but the kata he's linked to doesn't.
21:25:01 <{abby}> plusAssoc :: Natural a -> Natural b -> Natural c -> Equal (a :+: (b :+: c)) ((a :+: b) :+: c)
21:25:28 <{abby}> I don't like that equality predicate they're using, would much rather use base's :~:
21:25:35 <dmwit> The text "plusAssoc" doesn't appear in either of the pages I'm looking at.
21:25:43 <dmwit> Weird.
21:25:43 <{abby}> click train
21:26:00 <dmwit> aha
21:27:52 <freeman42x[m]1> a Haskell hackathon will be held this weekend: https://twitter.com/razvan_panda/status/1262492098542084104
21:28:15 * hackage pipes-lzma 0.2.0.0 - LZMA compressors and decompressors for the Pipes package  https://hackage.haskell.org/package/pipes-lzma-0.2.0.0 (BenGamari)
21:44:07 <wavemode> remexre: um I know ghcid can run a function on every file change. it can be your test suite
21:44:23 <wavemode> remexre: https://www.parsonsmatt.org/2018/05/19/ghcid_for_the_win.html
22:29:46 <hololeap> Is there any effort to get purescript working with RoR as well as coffeescript?
22:33:21 <wavemode> RoR as in ruby on rails? how would it work with that?
22:36:34 <hankmobley> exit
22:48:46 <hololeap> wavemode: Yeah, I assume they have a coffeescript compiler bundled, and I was hoping there was a hook to use other "javascript compilers"... Thought someone in here might know :?
22:51:15 * hackage dataflower 0.2.0.0 - A Pure-Haskell Timely Dataflow System  https://hackage.haskell.org/package/dataflower-0.2.0.0 (jessekempf)
23:12:45 * hackage birds-of-paradise 0.1.0.0 - Birds of Paradise  https://hackage.haskell.org/package/birds-of-paradise-0.1.0.0 (KatsutoshiItoh)
23:47:14 * hackage birds-of-paradise 0.1.1.0 - Birds of Paradise  https://hackage.haskell.org/package/birds-of-paradise-0.1.1.0 (KatsutoshiItoh)
