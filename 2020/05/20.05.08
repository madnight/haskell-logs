00:44:19 * hackage postgresql-syntax 0.2.0.1 - PostgreSQL AST parsing and rendering  https://hackage.haskell.org/package/postgresql-syntax-0.2.0.1 (NikitaVolkov)
01:25:15 <gentauro> is there a way to write the following logic without the usage of `do notation / >>=` and only with `<$>` + `<*>`? -> https://pastebin.com/CsP12Szz
01:27:50 * hackage haskoin-core 0.13.2 - Bitcoin & Bitcoin Cash library for Haskell  https://hackage.haskell.org/package/haskoin-core-0.13.2 (jprupp)
01:28:00 <Axman6> team i <$> hextetP <*> boolP <*> many getP?
01:29:18 <gentauro> Axman6: well thaT would work
01:29:39 <Axman6> ¯\_(ツ)_/¯
01:30:21 <gentauro> the problem is that as I write in the comments, the value of `boolP` needs to be reused for others parser combinators. An example: `team i <$> hextetP <*> boolP <*> … <*> fooP flag <*> many getP`
01:30:43 <Axman6> then it must be monadic
01:30:49 <gentauro> Axman6: no way around?
01:30:51 <gentauro> :(
01:30:53 <Axman6> no
01:31:19 <Axman6> you're making an execution decision based on the result of an action, only monads can do that
01:32:04 <gentauro> Axman6: what about Marlows `Selective Applicative Functors`?
01:32:11 <Axman6> this is the fundamental difference between Applicative and Monad, Monads can change their control flow based on values computed
01:32:39 <merijn> gentauro: Selective functors are new and no parser combinator library I know off supports them
01:33:21 <merijn> Axman6: Except Selective functors muck that distinction up ;)
01:33:37 <gentauro> Axman6: and merijn thx for feedback. I guess it's monads then
01:34:11 <merijn> Also, this seems rather irrelavant? Most parser combinators are already monads, so why limit yourself to Applicative?
01:35:01 <gentauro> merijn: as a challenge :)
01:49:19 * hackage haskoin-core 0.13.3 - Bitcoin & Bitcoin Cash library for Haskell  https://hackage.haskell.org/package/haskoin-core-0.13.3 (jprupp)
01:52:30 <kuribas> > let revInits = scanl (flip (:)) [] [1, 2, 3] in revInits [1..5]
01:52:32 <lambdabot>  error:
01:52:32 <lambdabot>      • Couldn't match expected type ‘[Integer] -> t’
01:52:32 <lambdabot>                    with actual type ‘[[Integer]]’
01:52:44 <kuribas> > let revInits = scanl (flip (:)) [] in revInits [1..5]
01:52:46 <lambdabot>  [[],[1],[2,1],[3,2,1],[4,3,2,1],[5,4,3,2,1]]
01:52:54 <kuribas> Does this function exist?
01:53:37 <merijn> Yes. Proof by construction: See above.
01:53:40 <merijn> ;)
01:53:59 <kuribas> lol, I meant in prelude...
01:54:15 <merijn> Doubt its, seems weirdly specific
01:54:15 <kuribas> or some standard library
01:55:27 <Axman6> > reverse . fmap reverse . inits $ [1..5]
01:55:30 <lambdabot>  [[5,4,3,2,1],[4,3,2,1],[3,2,1],[2,1],[1],[]]
01:55:38 <Axman6> > fmap reverse . inits $ [1..5]
01:55:41 <lambdabot>  [[],[1],[2,1],[3,2,1],[4,3,2,1],[5,4,3,2,1]]
01:55:49 <Axman6> >_>
01:55:54 <kuribas> Axman6: has much worse complexity
01:56:00 <Axman6> yes :)
01:56:10 <Axman6> I like yours, it's cute
01:56:18 <MarcelineVQ> > tails . reverse $ [1..5]
01:56:21 <lambdabot>  [[5,4,3,2,1],[4,3,2,1],[3,2,1],[2,1],[1],[]]
01:56:23 <kuribas> why doesn't common lisp have scanl...
01:56:40 <kuribas> > reverse . tails . reverse $ [1..5]
01:56:42 <lambdabot>  [[],[1],[2,1],[3,2,1],[4,3,2,1],[5,4,3,2,1]]
02:02:16 <kuribas> can you implement scanl in terms of foldl?
02:02:19 <kuribas> or foldr
02:04:49 <merijn> "Yes"
02:04:49 <kuribas> I suppose not since you need state
02:04:49 * hackage plzwrk 0.0.0.8 - A front-end framework  https://hackage.haskell.org/package/plzwrk-0.0.0.8 (mikesol)
02:05:03 <merijn> Because you can implement almost any recursive function in terms of fold :p
02:05:06 <mniip> you can implement any function [A] -> B int terms of foldr
02:05:21 <mniip> because foldr is the recursor for lists
02:05:35 <merijn> mniip: No, more generally
02:05:50 * hackage stylist 2.2.0.0 - Apply CSS styles to a document tree.  https://hackage.haskell.org/package/stylist-2.2.0.0 (alcinnz)
02:06:50 * hackage haskoin-node 0.13.0 - Haskoin Node P2P library for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-node-0.13.0 (jprupp)
02:10:12 <koz_> There was a whole writeup about foldr's universality in TMR 8 I think.
02:11:22 <merijn> koz_: https://www.cs.nott.ac.uk/~pszgmh/fold.pdf
02:11:26 <merijn> koz_: Even better :p
02:12:01 <koz_> merijn: Oh yeah, that's pretty awesome.
02:12:25 <koz_> That TMR overall had a lot of winning things.
02:36:49 * hackage xml-conduit-stylist 2.2.0.0 - Bridge between xml-conduit/html-conduit and stylist  https://hackage.haskell.org/package/xml-conduit-stylist-2.2.0.0 (alcinnz)
02:41:49 * hackage aeson-via 0.1.0 - Wrappers to derive-via Aeson ToJSON/FromJSON typeclasses  https://hackage.haskell.org/package/aeson-via-0.1.0 (ejconlon)
03:33:28 <maerwald> https://github.com/higherkindness/mu-haskell neat
03:46:45 <random_> hey guys
03:46:56 <random_> can anybody help with some DataKinds (I think) problem?
03:47:13 <random_> https://pastebin.com/PjSx9B9N
03:47:19 <random_> is such (or similar) thing possible
03:52:04 <Heffalump> random_: you want to do that because you want the strings close to the constructors in the source code?
03:52:14 <Heffalump> Otherwise you could do it trivially with a type class.
03:52:24 <Heffalump> (or just write asText directly)
03:53:59 <random_> hmm, it's more about that I'm wondering whether it's possible without
03:54:07 <random_> too much headache
03:54:21 <random_> but yeah, it'd also be nice to have them close to the source code
03:56:17 <Heffalump> there is {-# ANN but I don't know of a clean way of getting hold of that
03:57:16 <Unhammer> with optparse-applicative, can I get the full --help to show on parse errors? (I'm using hsubparser, and when I mistype a COMMAND I just get "Usage: myprog CONFIG COMMAND" instead of a list of the possible COMMAND's)
03:57:52 <random_> Heffalump: hm, never heard of ANN
03:57:57 <random_> Heffalump: I'll read up on it, thanks!
03:59:29 <Heffalump> random_: it seems like attributes in other languages like .NET, but there's no runtime API for getting them short of using the GHC API, that I know of
03:59:54 <random_> Heffalump: so most likely you won't be able to get the actual textual representation?
04:00:08 <random_> Heffalump: I was kind of hoping to be able to do it with Generic
04:00:14 <Heffalump> random_: right, unless you link against that API, or unless I've missed something
04:05:49 <random_> Heffalump: I think it may actually work for this case
04:06:03 <random_> Heffalump: but it's just so much uglier there's no benefit over doing it with a typeclass as you said
04:11:21 <maerwald> Unhammer: should
04:12:08 <maerwald> customExecParser (prefs showHelpOnError) ...
04:12:26 <maerwald> example: https://git.io/Jfcaq
04:13:18 <Heffalump> dmwit: (sorry for belated followup) - cabal exec runghc doesn't pass things like -X for the cabal file language pragmas, at least as far as I can tell
04:13:57 <Heffalump> random_: Linking against the GHC API is such a large hammer that you'd need some really big benefits to go with it :-)
04:14:22 <random_> Heffalump: yeah I was just hoping to make this pretty and learn a thing or two about DataKinds lol
04:16:24 <Unhammer> ooh, thanks maerwald !
04:18:14 <Unhammer> a bit weird that it lists required arguments under "Available options", but that's acceptable I guess
04:21:24 <maerwald> Well, "available" doesn't say anything about mandatory or not
04:21:45 <maerwald> But it could split into "required" and "optional"
04:22:02 <maerwald> But required options are weird anyway, imo
04:22:09 <maerwald> those should be commands
04:24:54 <Unhammer> required argument, not required option 
04:25:03 <Unhammer> (I used strArgument)
04:55:27 <olle___> did linear types get merged?
04:56:23 <yushyin> the proposal? yes.
04:56:51 <olle___> yushyin: the implementation?
04:57:38 <yushyin> this I do not know (but I doubt)
04:58:08 <olle___> still too controversial?
04:59:26 <yushyin> it is just a lot of work, I guess. you can see the progress at https://github.com/tweag/ghc/tree/linear-types
04:59:40 <olle___> kk, thanks!
05:00:22 <yushyin> yw
05:01:40 <juri_> hey, i did an unholy thing in some code, and i'd like advice in how to clean it up. I implemented a zipper, and i'm passing it along a foldl', but i do not need the second argument tho foldl' is adding.
05:02:24 <juri_> see: https://github.com/julialongtin/hslice/blob/WIP/programs/extcuraengine.hs#L227, https://github.com/julialongtin/hslice/blob/WIP/programs/extcuraengine.hs#L255, and https://github.com/julialongtin/hslice/blob/WIP/programs/extcuraengine.hs#L267.
05:03:16 <juri_> what do i do to get a fold that takes a number of times to fold, rather than an unused list?
05:09:22 <olle___> juri_: what's your end result?
05:09:26 <olle___> a list or a value?
05:09:48 * hackage dobutokO2 0.39.0.1 - Helps to create experimental music from a file (or its part) and a Ukrainian text.  https://hackage.haskell.org/package/dobutokO2-0.39.0.1 (OleksandrZhabenko)
05:10:14 <juri_> olle___: a list.
05:11:36 <juri_> I couldn't use a fold, because computation for the current item requires looking at the next, and former item..
05:12:00 <juri_> so i rigged a zipper, with read-around the ends.
05:12:59 <juri_> (note: not the result of next / former, but the input values)
05:13:11 <olle___> juri_: use map?
05:13:23 <olle___> or wait
05:13:46 <olle___> yeah, if you need to look on previous and next items, just make your own recursive function that pattern matches on three items in the list
05:14:18 <juri_> but i need the inputs, not the outputs.
05:14:26 <juri_> so, recursion won't work.
05:14:55 <juri_> (or, at the least, is unnecessary)
05:16:22 <juri_> I do like using a tuple as input.. but how do i get a function called, with the item at / before / after?
05:17:09 <olle___> your zipper needs the previous modified value?
05:17:56 <juri_> no, it needs the previous unmodified value. for each point in my list, to calculate a result, i need access to the unmodified last, current, and previous entry.
05:18:21 <juri_> er. and next entry, rather.
05:19:10 <olle___> yes, that's what your recursive function does?
05:19:19 <olle___> you make your own fold function
05:23:29 <juri_> hmm. maybe this is a multi-argument map?
05:25:33 <juri_> thanks. i'm still a bit confused, but you've been helpful.
05:26:52 <olle___> juri_: not sure if haskell has imap, map with index
05:27:05 <olle___> then you can get previous and next item in the list, if present
05:27:20 <olle___> thought that's a lot of traversing
05:28:22 <tdammers> a trick I use sometimes is to zip a list with its own tail
05:28:44 <tdammers> (or zip3 with its tail and its tail's tail)
05:28:53 <merijn> Or just ZipList!
05:29:00 <tdammers> but at that point, you might as well recurse explicitly
05:29:19 <tdammers> the "map-with-index" thing is absolutely terrible
05:29:24 <juri_> I think converting it to a three argument map makes sense.
05:30:19 <juri_> f <$> (list-off-by-one) <*> (list) <*> (list-off-by-one-the-other-way)
05:30:23 <tdammers> also note that "for each element in the list I need the last, current and next unmodified entry" isn't possible. There is no last element for the first element in the list, and there is no next element for the last element in the list
05:30:42 <tdammers> if you spell out the recursion, this becomes immediately obvious
05:31:12 <tdammers> fold3 f (x:y:xs) = f x y (fold3 $ y:xs); fold3 _ = []
05:31:15 <tdammers> something like that
05:31:19 * hackage haskoin-store-data 0.25.0 - Data for Haskoin Store  https://hackage.haskell.org/package/haskoin-store-data-0.25.0 (jprupp)
05:31:30 <tdammers> oof that's actually wrong
05:31:47 <tdammers> fold3 f (x:y:z:xs) = f x y z : (fold3 $ y:z:xs); fold3 _ = []
05:32:34 <int-e> fold3 f xs = [f x y z | x:y:z:_ <- tails xs]
05:32:45 <gentauro> is there a way to `flip` the first argument to the last? Example: `f x y z -> …` -> expected result: `f y z x -> …`. I know `flip` does it like this `f y x z -> …`
05:33:32 <tdammers> gentauro: you could trivially implement that yourself, but I believe it's not generic enough to be in base
05:33:49 * hackage haskoin-store-data 0.25.1 - Data for Haskoin Store  https://hackage.haskell.org/package/haskoin-store-data-0.25.1 (jprupp)
05:33:58 <tdammers> flip13 f x y z = f z y x
05:34:03 <olle___> tdammers: map with index is terrible?
05:34:04 <gentauro> tdammers: oh
05:34:11 <tdammers> olle___: yes.
05:34:15 <merijn> olle___: On lists, yes
05:34:20 <olle___> why?
05:34:22 <tdammers> olle___: especially if you then use it to index into the list again
05:34:26 <tdammers> first of all, performance
05:34:32 <gentauro> I'm guessing that I forgot to state that the amount of variables aren't static
05:34:33 <tdammers> list indexing is O(n)
05:34:34 <int-e> @pl \x y z -> f z y x
05:34:34 <lambdabot> flip (flip . flip f)
05:34:35 <merijn> tdammers: map with index is fine for vectors and Map, tbh
05:34:46 <gentauro> so `f a b c d e -> …` 
05:34:49 <int-e> (that turned out to be less terrible than expected)
05:34:49 * hackage haskoin-store 0.25.1 - Storage and index for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-store-0.25.1 (jprupp)
05:34:58 <olle___> hackage: shut up
05:35:06 <tdammers> merijn: you still have to deal with the fact that lookups are partial, and perform error handling ceremonies for errors that cannot happen
05:35:13 <int-e> olle___: you can ignore it, it's a bot
05:35:14 <gentauro> olle___: you know you can ignore `hackage` right?
05:35:22 <olle___> gentauro: just did, yeah, thanks
05:35:30 <olle___> tdammers: second?
05:35:42 <merijn> tdammers: map with index on vector/map exist so you don't have to deal with partial lookups
05:36:12 <tdammers> merijn: yes, but if you then proceed to use the index to look up the previous and next elements in the original list, you're back to partial lookups
05:36:37 <tdammers> merijn: I agree that it's fine for when you just want to know the index, but don't care about using it for another lookup
05:36:50 <olle___> so performance is the only reason, then?
05:37:09 <merijn> olle___: Going from O(n) to (On^2) is a pretty big downside :p
05:37:16 <tdammers> olle___: second reason is, as I just explained, that when you use that index to look up neighbors, you have to cater for the fact that indexed list lookups are partial, i.e., they can go out of bounds
05:37:35 <tdammers> so you have to add some awkward logic to deal with that
05:37:49 <olle___> check list length is not that awkward, I think.
05:38:05 <merijn> olle___: That adds another layer of O(n), though
05:38:14 <olle___> nah, just calculate it before
05:38:19 <tdammers> checking list length is probably the worst solution
05:38:33 <tdammers> lookup already gives you a Maybe, so you just have to check for Nothing
05:38:36 <tdammers> but even that is awkward
05:38:53 <olle___> why?
05:39:11 <olle___> or maybe, agree to disagree. fold3 is of course better, not arguing with that.
05:41:20 * hackage haskoin-store-data 0.25.2 - Data for Haskoin Store  https://hackage.haskell.org/package/haskoin-store-data-0.25.2 (jprupp)
05:41:33 <dfin> hi. 
05:41:38 <tdammers> olle___: https://paste.debian.net/1145713/
05:41:38 <jess[m]1> is anyone familiar with get functions and how to make grids using haskell 
05:41:45 <dfin> Stupid question: How do I instantiate a Word32?
05:41:54 <tdammers> completely untested and all that, but this is the most elegant code I can come up with for either scenario
05:42:19 * hackage haskoin-store 0.25.2 - Storage and index for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-store-0.25.2 (jprupp)
05:42:28 <tdammers> note the use of the Monad instance for Maybe in the second one, that already goes a long way, but it's still awkward IMO
05:42:29 <jess[m]1> get :: Grid c -> GridCoord -> Maybe c
05:43:31 <juri_> yuuck. i wish there was a way to remove the recursion in that, as this function is technically not recursive.
05:43:32 <merijn> JesseL: Grid in what sense?
05:43:38 <merijn> dfin: You mean in your source code?
05:43:46 <juri_> (and HIGH cpu usage. and running on a 32 core machine)
05:43:54 <merijn> s/JesseL/jess[m]1
05:44:24 <dfin> merijn: yes. :-) 
05:44:37 <merijn> dfin: Word32 is a Num instance, so you just write a number :p
05:44:41 <merijn> > 15 :: Word32
05:44:43 <lambdabot>  15
05:45:19 <matric[m]> Im trying to create the game of life on Haskell and as a beginner I'm unsure on how to get started
05:45:41 <merijn> matric[m]: There's the array package :)
05:45:45 <matric[m]> Ive set up a few helper functions but I'm struggling on the grid functions 
05:45:52 <merijn> matric[m]: That provides arbitrary dimensional arrays
05:46:20 <merijn> @hackage array
05:46:20 <lambdabot> http://hackage.haskell.org/package/array
05:46:24 <olle___> tdammers: yeah, explicit recursion was my first suggestion too
05:47:01 <tdammers> olle___: I like an obvious workflow: write the explicit code, then wrap it in obvious abstractions as needed
05:47:08 <merijn> matric[m]: A two dimensional one would just use a tuple as indices
05:48:05 <merijn> matric[m]: Alternatively "Map (Int, Int) Bool" (which I suppose is just "Set (Int, Int)"?) works
05:48:23 <dfin> So, I can force a num into a specific representation.
05:48:44 <matric[m]> I have the data type (Int, Int) set up 
05:49:21 <merijn> dfin: It's not so much "numbers can be forced into a specific representation" as much as it is "numeric literals are explicitly polymorphic and can be used to instantiate any type that has a Num instance"
05:49:26 <merijn> :t 15
05:49:28 <lambdabot> Num p => p
05:50:09 <merijn> dfin: So 15 has "any type, as long as that type is an instance of Num" (which Word32 is)
05:52:00 <dfin> merijn: ok, thanks!
05:55:19 <matric[m]> merijn:  I'm reading this guide currently and I'm not sure how to set up the code in VSCodium 
05:55:20 * matric[m] uploaded an image: Screen Shot 2020-05-08 at 10.52.32 pm.png (49KB) < https://matrix.org/_matrix/media/r0/download/matrix.org/ZXxzMdeNRAeDQKOGOpAOBfSX >
05:55:25 <matric[m]> when the type is data Conway = Alive | Dead deriving Eq
06:00:50 * hackage libsodium 1.0.18.0 - Low-level bindings to the libsodium C library  https://hackage.haskell.org/package/libsodium-1.0.18.0 (RenzoCarbonara)
06:19:50 * hackage haskoin-store-data 0.25.3 - Data for Haskoin Store  https://hackage.haskell.org/package/haskoin-store-data-0.25.3 (jprupp)
06:20:49 * hackage haskoin-store 0.25.3 - Storage and index for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-store-0.25.3 (jprupp)
06:43:42 <Moritz58> Hi, is there a command in Haskell which returns nothing? (I want to return all odd numbers from a list)
06:44:04 <Moritz58> I have "map (\x -> if x `mod` 2==0 then return () else x) [1,2,3]"
06:44:16 <maerwald> simple answer: no :)
06:44:33 <maerwald> What you can do is wrap it in Maybe
06:44:38 <maerwald> and then filter out Nothing values
06:44:40 <Uniaika> Moritz58: return the digit in a list ([1]), and return the empty list ([]) if it's not odd, then concat the list. :)
06:45:01 <olle___> don't use map, use filter
06:45:01 <Uniaika> or indeed you can use Maybe, which is semantically clearer I'd say
06:45:20 <Moritz58> OK I'll try it. Thank you
06:45:25 <olle___> Moritz58: filter!
06:47:19 * hackage hie-bios 0.5.0 - Set up a GHC API session  https://hackage.haskell.org/package/hie-bios-0.5.0 (fendor)
06:47:39 <ski> > [x | x <- [1,2,3],x `mod` 2 == 0]  -- Moritz58, another way, using a "list comprehension"
06:47:42 <lambdabot>  [2]
06:47:55 <ski> oh, right, you wanted odds
06:48:03 <ski> > [x | x <- [1,2,3],x `mod` 2 /= 0]
06:48:05 <lambdabot>  [1,3]
06:49:15 <ski> this is "the list of all `x's, with `x' drawn from the list `[1,2,3]', satisfying  x `mod` 2 /= 0"
06:49:49 * hackage log-postgres 0.7.1.3 - Structured logging solution (PostgreSQL back end)  https://hackage.haskell.org/package/log-postgres-0.7.1.3 (arybczak)
06:50:00 <Moritz58> Thank you very much ski
06:50:48 <olle___> ot, but isn't there a faster way to decide if an integer is even or odd? like bit shift?
06:50:49 * hackage log-base 0.8.0.1 - Structured logging solution (base package)  https://hackage.haskell.org/package/log-base-0.8.0.1 (arybczak)
06:51:08 <olle___> or first bit 0 or 1?
06:51:21 <olle___> hm no
06:51:34 <olle___> or?
06:51:42 <olle___> does haskell offer bit access?
06:52:13 <ski> Moritz58 : but you should learn to use `filter',`concat',`concatMap' as well
06:52:18 <enikar> yes, in Data.Bits
06:52:36 <ski> @src even
06:52:36 <lambdabot> even n = n `rem` 2 == 0
06:52:53 <enikar> but bot for Integer.
06:53:45 <ski> > [n `testBit` 0 | n <- [0 .. 7]]
06:53:47 <lambdabot>  [False,True,False,True,False,True,False,True]
06:53:47 <enikar> euh… s/bot/not/
06:53:51 <ski> > [n `testBit` 1 | n <- [0 .. 7]]
06:53:53 <lambdabot>  [False,False,True,True,False,False,True,True]
06:54:02 <ski> @type testBit
06:54:03 <lambdabot> Bits a => a -> Int -> Bool
06:54:34 <ski> (-1 :: Integer) `testBit` 0
06:54:36 <ski> > (-1 :: Integer) `testBit` 0
06:54:38 <lambdabot>  True
07:00:10 <tdammers> Moritz58: you may also want to revisit your mental model of what "return" means in Haskell. It's not the same as in your average imperative programming language, and the naming is a bit unfortunate.
07:01:12 <maerwald> +1 for monad of no return
07:01:20 <maerwald> (and not re-adding return as top-level function)
07:01:22 <maerwald> >:)
07:01:56 * ski idly remembers defining `done = return ()'
07:02:44 <solonarv> yes, 'done' is a better name :)
07:03:10 <olle___> ski: testBit?
07:03:11 <olle___> hm
07:03:30 <olle___> must be very much faster than mod
07:03:47 <merijn> olle___: For powers of two, sure :)
07:03:56 <olle___> ah right
07:04:54 <enikar> I would prefer yield in place of return…
07:05:55 <olle___> just build a microservice which contains all integers together with a boolean value for even/odd
07:06:10 <ski> i've defined `yield' in a cooperative concurrency monad
07:06:38 <ski> why `Bool'ean ?
07:07:00 <olle___> why not?
07:07:04 <enikar> ski: anyway, it's too late to rename return.
07:07:17 <yushyin> @hoogle Monad m => m ()
07:07:17 <lambdabot> Control.Monad.Extra skip :: Monad m => m ()
07:07:18 <lambdabot> Data.Swagger.Build.Api end :: Monad m => m ()
07:07:18 <lambdabot> Data.Swagger.Build.Authorisation end :: Monad m => m ()
07:07:27 <yushyin> @hoogle yield
07:07:28 <lambdabot> Control.Concurrent yield :: IO ()
07:07:28 <lambdabot> GHC.Conc yield :: IO ()
07:07:28 <lambdabot> GHC.Conc.Sync yield :: IO ()
07:07:33 <yushyin> mmh ok
07:08:10 <dmwit> Heffalump: I know this doesn't help you immediately, but I'd consider filing a cabal bug about that.
07:08:51 <dmwit> Heffalump: cabal does have the internal mechanisms to get that right; runghc just needs to be added to its "database".
07:09:07 <solonarv> 'yield' is also what all the conduit/streaming/etc libraries use for "produce a value to be consumed downstream"
07:09:44 <ski> @where boolean-blindness
07:09:44 <lambdabot> http://existentialtype.wordpress.com/2011/03/15/boolean-blindness/
07:09:55 <ski> olle___ : ^ might (or might not) be relevant
07:10:15 <olle___> sigh, you gonna make me read an article?
07:13:13 <Tuplanolla> Reading is good for you.
07:14:20 <enikar> this blog is excellent, as well
07:27:50 * hackage headroom 0.2.2.1 - License Header Manager  https://hackage.haskell.org/package/headroom-0.2.2.1 (xwinus)
07:34:45 <olle___> x & 1) == 0
07:34:51 <olle___> (x & 1) == 0
07:34:56 <olle___> even ^ ?
07:36:02 <yushyin> (&) is reverse function application
07:36:47 <olle___> that's C
07:36:55 <olle___> bit AND operator, no?
07:41:18 <olle___> https://stackoverflow.com/questions/160930/how-do-i-check-if-an-integer-is-even-or-odd
07:41:39 <olle___> this guy checked the assembler generated by gcc when checking even/odd, it compiles to bitshift and
07:41:42 <enikar> olle___: there is a bit And function in Data.Bits
07:42:14 <olle___> enikar: cool
07:44:28 <yushyin> olle___: just use rem? like the stackoverflow post says it is not guaranteed to work with any number representation
07:44:48 <olle___> yushyin: question is if haskell will compile it to & when guaranteed to work?
07:45:43 <enikar> olle___: also, is there a good reason to optimize your code this way ?
07:46:03 <olle___> enikar: fun?
07:46:23 <enikar> beacause, functions on bits don't work on Integer.
07:46:45 <olle___> ah, no hardware int type, eh?
07:46:52 <merijn> enikar: Yeah they do
07:47:02 <enikar> hmmm…
07:47:13 <enikar> on Int yes not on Integer…
07:47:24 <merijn> "instance Bits Integer" since base 2.1
07:47:27 <olle___> assumed to be Int64?
07:47:42 <st8less> I have seen a lot of interest in FP, and adoption of tools/techniques via language changes/packages.  My bread and butter is Python, and I see this as a strong influence lately.  My question is that it feels like a square peg in a round hole.  Python's dynamic nature makes typed programming nightmare-sauce (mypy is a dumpster fire).  I am on a very small team, and I'm wondering at what point does
07:47:45 <st8less> it make sense to go all-in on a functional language.  Or is it better to stay the course?
07:47:53 <enikar> or Int32 on 32 bits processor.
07:47:56 <merijn> > (5 :: Integer) `testBit` 1
07:47:59 <lambdabot>  False
07:48:02 <merijn> > (5 :: Integer) `testBit` 0
07:48:05 <lambdabot>  True
07:48:38 <enikar> well, I was wrong…
07:48:41 <olle___> st8less: use fp when its echo system supports your domain
07:48:51 <merijn> st8less: IMO the things usually described as "functional" in the python/JS/etc. world are usually the least important things of functional programming :)
07:49:33 <olle___> in the age of Lisp, "functional" meant "lambdas", these days it means "powerful type-systems"
07:50:18 <olle> test
07:51:13 <st8less> I work with network automation stuff mostly.  Lots and lots of text-mangling and data-model from a->b sort of stuff.  I think FP could really alleviate some of the thorny problems I've been having.
07:51:22 <Cale> st8less: Where I work, we've been using Haskell to build web and mobile applications (both the frontends and backends), and I think it's actually giving us quite a lot of benefit.
07:52:57 <olle> st8less: which thorny problems did you guys have?
07:53:19 <st8less> yes  :)
07:53:50 <Cale> A large fraction of the benefit in this domain comes from the fact that the types that we use to have the frontend and backend communicate are shared between them, eliminating cases where they can't talk to one another, and also serving as a natural place to begin most new features in an application.
07:54:02 <st8less> I got a bunch of comments on a PR yesterday because my teammate didn't know the type that a function was using.  And in Python, yeah, it *could* be anything, it's really loose.
07:54:35 <Cale> It's so much easier to be productive and keep the code clean when there's a typechecker making sure that you're not screwing things up
07:54:37 <maerwald> Cale: the type sharing isn't that much of an argument imo. I can generate TypeScript types from haskell json too :)
07:54:53 <maerwald> And that works very well
07:54:53 <st8less> And I think things like the Either monad could be a lifesaver in some of our tools that do a ton of IO and we're catching/passing exceptions all over creation.
07:56:03 <olle> well, I spent 8h the other day debugging a js function that failed silently because it wanted an array instead of an object
07:56:08 <Cale> That's fair enough. I suppose the common language is also good in that *every* developer on all our projects is both a frontend and backend developer. Tickets are complete features.
07:56:49 * hackage dhall-lsp-server 1.0.7 - Language Server Protocol (LSP) server for Dhall  https://hackage.haskell.org/package/dhall-lsp-server-1.0.7 (GabrielGonzalez)
07:57:05 <Cale> At some point, you just think of the whole thing as a single program. It's easy to move large portions of code between the frontend and backend, depending on where it ought to be running and what tradeoff you want to make.
07:57:18 <olle> but wanting static types is not the same thing as wanting fp
07:57:27 <olle> java, c#, etc
07:57:34 <maerwald> olle: use typescript then
07:57:58 <olle> maerwald: I wish we could use reasonml, but we'll probably go with ts, yes
07:58:02 <maerwald> Coding haskell takes time. I personally am not convinced I want to use it as a frontend language.
07:58:14 <maerwald> TS is great as frontend language
07:58:28 <Cale> Well, Haskell's type system can certainly say a lot more than the type systems in Java and C# -- and I'm not even talking about fancy things like GADTs
07:58:35 <olle> maerwald: it sure takes the script out of javascript ;)
07:58:41 <Cale> Just boring things like, "not all functions are allowed to have arbitrary effects"
07:58:58 <Heffalump> dmwit: makes sense, thanks
07:59:01 <maerwald> F# also has open effects, doesn't it?
07:59:13 <olle> Cale: but it's not really common or idiomatic to define effects more precisely in haskell than IO, right?
07:59:28 <wavemode> depends on who you ask :p
07:59:29 <olle> what was the name of that pattern...
07:59:30 <maerwald> every discussions ends with polysemy 
07:59:35 * maerwald waits another 10 minutes
07:59:40 <olle> what's that?
07:59:42 <Cale> This one's going to end with FRP instead :D
07:59:45 <maerwald> haha
08:00:05 <olle> st8less: take one of your scripts, convert it to  haskell, see how it looks
08:00:08 <Cale> So we use an interesting system for managing things which change over time on our frontends
08:00:09 <olle> review it with your colleagues
08:00:34 <Cale> An implementation of functional reactive programming called reflex, and a library for controlling the contents of the DOM with that, called reflex-dom
08:00:49 <Cale> In reflex-dom, when you make a button, it gives you a value of type Event t ()
08:01:07 <Cale> which is a representation of the entire sequence of all the clicks which will ever happen to that button
08:01:44 <st8less> olle: Will do thanks!  I've been kicking the tires with conduit and one of the API's we use.
08:01:45 <Cale> and reflex gives you a whole bunch of ways to combine various bits of data which represent pure values throughout time to obtain more such values
08:01:56 <Cale> and ensures that everything stays up to date automatically
08:02:28 <Cale> so we can have a bunch of data streaming in over a websocket and it automatically flows down to all the displays of data in our application
08:02:53 <Cale> Everything is live-updating by default, and the less-obvious way of doing things is to freeze it (which is easy, but unnecessary most of the time)
08:03:19 <Cale> This relies heavily on controlling effects, or it would be a complete and utter nightmare to use
08:04:02 <maerwald> so it does rely on polysemy :D
08:04:07 <Cale> haha
08:04:08 <Cale> no
08:04:19 <Cale> We just use boring old monad transformers to build it up :P
08:04:31 <Cale> and module boundaries to hide the sins
08:04:52 <jonathan__> I have an anonymous type in my function signature that I want to reuse in the body. I think I remember some language extensions related to explicitforall that helps with this.
08:05:05 <jonathan__> Currnetly stuck on "can't match 'a' with 'a1'
08:05:33 <jonathan__> Anyone know the extension I'm thinking about?
08:05:37 <Tuplanolla> Use `ScopedTypeVariables` and quantify the variable on the highest level, jonathan__.
08:06:45 <jonathan__> Tuplanolla: Thanks a bunch
08:06:59 <ski> jonathan__ : itym "type variable", not "anonymous type" ?
08:07:16 <maerwald> I like anonymous type better
08:07:20 * hackage knit 0.1.0.0 - Ties the knot on data structures that reference each other by unique keys.  https://hackage.haskell.org/package/knit-0.1.0.0 (pkamenarsky)
08:07:34 <Tuplanolla> It's not anonymous if you can refer to it by a name.
08:07:42 <ski> but it is a local name
08:08:25 <maerwald> Tuplanolla: might be a fake name though
08:08:28 <maerwald> :D
08:09:10 <ski> (although, often, as a name, it's quite contentless, sure, apart from being distinct from other names of the same sort, in scope)
08:09:22 <jonathan__> My mental model was that "anonymous types" are any polymorphic variable. I guess it's not really anonymous if it can be referred to though, I'll update my thinking accordingly
08:09:57 <ski> in `reverse :: [a] -> [a]', `a' is not a polymorphic variable
08:10:09 <ski> (`reverse' is polymorphic, though)
08:10:39 <jonathan__> ski: okay, is there a term for the kind of type that a has there? :)
08:11:05 <ski> `a' is a type variable (often, "tyvar", for short)
08:11:19 <jonathan__> fair enough
08:11:19 * hackage dhall-json 1.6.4 - Convert between Dhall and JSON or YAML  https://hackage.haskell.org/package/dhall-json-1.6.4 (GabrielGonzalez)
08:11:20 <olle> but is it strong or weak polymorphic_
08:11:21 <olle> ?
08:11:24 <ski> you can say that `reverse' is polymorphic in `a'
08:11:37 <ski> what do you mean by that distinction, olle ?
08:11:47 <olle> sorry, maybe only relevant in OCaml
08:11:50 <jonathan__> does it lift?
08:12:04 <jonathan__> ;)
08:12:17 <ski> olle : ah. well, there's no "weak tyvars" in Haskell (because of `IO')
08:12:28 <ski> how do you mean, jonathan__ ?
08:12:28 <olle> OCaml unifies 'a' to something, and it might be confused if you try to use 'a' differently later in the program, unless you explicitly tell it to REALLY be polymorphic
08:12:54 <jonathan__> ski: bad joke.
08:13:12 <ski> i'd call that a "metavariable" or "placeholder (name)", i guess
08:15:09 <ski> (hm, i tend to find SML/NJ's and OCaml's treatment of such tyvars which can't be generalized upon nicer, than the `Any' in GHC)
08:15:19 * hackage dhall-yaml 1.1.0 - Convert between Dhall and YAML  https://hackage.haskell.org/package/dhall-yaml-1.1.0 (GabrielGonzalez)
08:17:09 <c_wraith> olle: it's possible the documentation for https://hackage.haskell.org/package/base-4.14.0.0/docs/System-IO-Unsafe.html#v:unsafePerformIO might answer some of that.
08:17:48 <ski> olle : anyway, that's only the case, when the value restriction kicks in
08:19:49 * hackage dhall-bash 1.0.30 - Compile Dhall to Bash  https://hackage.haskell.org/package/dhall-bash-1.0.30 (GabrielGonzalez)
08:20:27 <c_wraith> in general, forcing mutable references to be used in scopes that are all typed together (because of >>=) makes the difference irrelevant.
08:20:49 * hackage dhall-nix 1.1.14 - Dhall to Nix compiler  https://hackage.haskell.org/package/dhall-nix-1.1.14 (GabrielGonzalez)
08:21:30 <c_wraith> But use of backdoors like unsafePerformIO can break things by separating contexts.
08:21:49 * hackage dhall 1.32.0 - A configuration language guaranteed to terminate  https://hackage.haskell.org/package/dhall-1.32.0 (GabrielGonzalez)
08:26:20 <jchia_> Question about quickcheck: Where can I go to find out the statistical properties of Arbitrary instance of lists? I want to know the distribution of the number of elements. I don't know whether to find the source code for that.
08:26:57 <solonarv> jchia_: when browsing Haddock documentation, you can see instances for a type / typeclass
08:27:05 <solonarv> next to each instance there is a "Source" link
08:28:04 <c_wraith> It's not very useful in this case, though
08:28:06 <jchia_> solonarv: The haddock is very sparse and doesn't give details. The source link doesn't work.https://www.stackage.org/haddock/lts-15.11/QuickCheck-2.13.2/Test-QuickCheck-Arbitrary.html
08:28:23 <c_wraith> "doesn't work"?
08:28:28 <jchia_> i think there's only text and no link
08:28:35 <solonarv> jchia_: works for me
08:28:41 <c_wraith> It's not useful, but it works
08:28:52 <solonarv> it took me here: https://www.stackage.org/haddock/lts-15.11/QuickCheck-2.13.2/src/Test.QuickCheck.Arbitrary.html#line-453
08:29:09 <solonarv> but you will have to do a bunch of follow-the-pointers to actually figure out what's going on
08:30:53 <c_wraith> ugh, it depends on sized.  the details go all throught the guts of quickcheck
08:31:02 <jchia_> OK, I see it now. The page is very wide and my browser wouldn't show 'Source' as a link until I scrolled right
08:33:57 <dmwit> olle: I believe GHC does not do any strength reduction, including optimizing mod/rem of powers-of-two to bit-operations.
08:34:02 <dmwit> Currently.
08:34:45 <olle> dmwit: kk
08:35:01 <dmwit> olle: If you compile with LLVM, and the stars align, the llvm tools may do some of that. But I probably wouldn't count on it if I really needed it for a tight inner loop.
08:35:18 <olle> i didn't even know haskell has an llvm backend :)
08:35:26 <dmwit> -fllvm
08:35:41 <kuribas> llvm is a bit better with numerical calculations
08:35:57 <kuribas> it can completely eliminate a loop
08:36:14 <dmwit> LLVM is good with numerical calculations, but GHC has to have specialized to a specific Num instance before LLVM has any hope of being good.
08:36:24 <olle> kuribas: well, anyone can do that ;)
08:36:26 <dmwit> Sometimes this is easy, sometimes not.
08:36:44 <olle> rm -rf /
08:36:45 <kuribas> olle: keeping the semantics?
08:36:46 <olle> tada!
08:36:57 <merijn> LLVM backend is likely to be better for highly numerical computational code. For average Haskell code the native backend is still better, afaik
08:37:16 <merijn> The LLVM doesn't really support GHC's calling conventions very well
08:37:26 <olle> kuribas: I guess you're talking about automatic vectorization and SIMD chips?
08:37:37 <kuribas> olle: not even, but that also
08:38:47 <c_wraith> hmm, can you through -fllvm into an OPTIONS_GHC pragma so that it only is applied to particular files during a full build?
08:38:55 <c_wraith> *throw
08:39:01 <dmwit> olle: He's talking about LLVM noticing that you're doing the for(i=0; i<10000; i++) sum += i microbenchmark and turning it into sum=50005000.
08:39:06 <Uniaika> merijn: does LLVM handle TCO? Or do we get rid of that with while loops once we arrive at the LLVM IR level?
08:39:25 <merijn> Uniaika: Mu
08:39:36 <dmwit> olle: It is actually capable of noticing you're doing the `foo 0 = 0; foo i = i + foo (i-1)` microbenchmark in the same way.
08:39:43 <kuribas> I think ghc converts everything to CPS (continuation passing style).
08:39:49 * hackage haskoin-store-data 0.25.4 - Data for Haskoin Store  https://hackage.haskell.org/package/haskoin-store-data-0.25.4 (jprupp)
08:39:54 <Uniaika> merijn: μ ?
08:39:54 <merijn> Uniaika: The problem is that GHC doesn't even generate assembly calls, therefore the question of tail calls is meaningless
08:40:03 <Uniaika> merijn: ok!
08:40:05 <merijn> Uniaika: Mu is the zen "non answer" :)
08:40:16 <Uniaika> ah, :)
08:40:25 <merijn> Uniaika: Which is why LLVM doesn't really support GHC's calling convention
08:40:29 <dmwit> "mu" means roughly, "the question doesn't make sense, because it is predicated on an incorrect assumption".
08:40:45 <Uniaika> dmwit: thank you :)
08:40:49 * hackage haskoin-store 0.25.4 - Storage and index for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-store-0.25.4 (jprupp)
08:40:55 <merijn> Uniaika: The native backend doesn't generate CALL instructions at all, it just generates jumps
08:41:11 <Uniaika> merijn: is that a good thing…?
08:41:17 <merijn> Uniaika: Since the IR is all CPS as kuribas points out you never return
08:41:23 <Uniaika> I have absolutely no practice of ASM
08:41:30 <olle> dmwit: sure, with constants
08:41:38 * ski . o O ( <http://www.catb.org/jargon/html/M/mu.html> )
08:41:44 <merijn> Uniaika: Well, the reason why TCO is a thing is to avoid consuming stack space on every function call, right?
08:41:46 <dmwit> olle: Hey, I *said* it was a microbenchmark.
08:41:47 <solonarv> kuribas: no, GHC does not use CPS as an intermediate stage.
08:41:56 <Uniaika> merijn: yes
08:42:02 <olle> :)
08:42:04 <dmwit> olle: I put all the scorn I could into the text!
08:42:15 <kuribas> solonarv: I don't mean core...
08:42:17 <merijn> Uniaika: But GHC's compilation model doesn't have a function call stack to begin with
08:42:27 <solonarv> at least I don't recall seeing it anywhere in the compilation pipeline
08:42:30 <merijn> solonarv: STG is basically CPS if you squint
08:42:50 * hackage yamlparse-applicative 0.1.0.0 - Declaritive configuration parsing with free docs  https://hackage.haskell.org/package/yamlparse-applicative-0.1.0.0 (Norfair)
08:42:50 <merijn> solonarv: You can't see explicit CPS in the GHC pipeline for the same reason fish can't see water :p
08:43:04 <solonarv> ah, squinting, the most powerful transformation :p
08:43:07 <solonarv> I suppose that makes sense
08:44:15 <merijn> Uniaika: You've read the STG paper?
08:48:08 <Uniaika> merijn: no. What is the (real) required level to read it?
08:48:36 <merijn> Uniaika: Honestly, super basic Haskell knowledge. A little bit of C/asm knowledge helps
08:49:00 <merijn> Uniaika: The STG language it discusses only has lambda, function application, case and bindings
08:49:03 <merijn> @where stg
08:49:03 <lambdabot> http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.53.3729
08:49:06 <Uniaika> no master's in FP / Implementation of FP required? SPJ's paper is not a pre-requisite?
08:49:24 <merijn> That is SPJ's paper, iirc :p
08:50:26 <Uniaika> sorry, s/paper/book/ -> https://www.microsoft.com/en-us/research/publication/the-implementation-of-functional-programming-languages/
08:50:47 <merijn> I've not read the book, so :p
08:50:53 <Uniaika> okay great, gonna read this
08:51:00 <Uniaika> oof 87 pages.
08:51:04 <Uniaika> it's a little book :P
08:51:19 <merijn> ;)
08:51:39 <Uniaika> but I've got a three days-long weekend so :P
08:52:30 <Cale> I like the way that SPJ's papers are always sorted by level of detail, so you can always get something from them by reading some prefix of the paper, even if eventually the details become tricky or beyond your current attention span.
08:52:58 <enthropy> haddock still doesn't show associated type instances?
08:53:37 <merijn> Cale: The title of the STG paper is...needlessly intimidating, though :p
08:53:40 <Uniaika> enthropy: like a reverse lookup? Who is imlementing my typeclass?
08:53:49 * hackage retrie 0.1.1.0 - A powerful, easy-to-use codemodding tool for Haskell.  https://hackage.haskell.org/package/retrie-0.1.1.0 (AndrewFarmer)
08:56:43 <enthropy> Uniaika, I didn't see the [+] to expand but inside is not helpful (same as https://github.com/haskell/haddock/issues/664 )
08:56:51 <remexre> should vector-sized be able to support a fixed-point on Data.Vector.Sized.Vector, or am I doing it wrong? vmap f = let v = imap f v in v is nonterminating for f=(\_ _ -> False)
08:56:56 <remexre> er, vfix*
09:00:09 <lyxia> imap needs to be strict in the vector to know how long the result is.
09:00:21 <solonarv> should be possible, perhaps... yeah
09:00:38 <remexre> lyxia: that's already in the type
09:01:02 <solonarv> that doesn't mean imap actually manages to be lazy in the vector
09:01:44 <remexre> eh, fair
09:02:09 <solonarv> what's the type of this thing supposed to be?
09:02:26 <solonarv> something like '(Int -> a -> a) -> Vector n a' ?
09:02:53 <remexre> I was just trying for (Finite n -> a -> a) -> Vector n a for now
09:03:02 <solonarv> ah, so basically what I said
09:03:23 <remexre> but probably I'd pass the vector to the function later, tho that'd hopefully be trivial
09:03:25 <remexre> ya
09:03:33 <solonarv> then I'd just use \f -> generate (fix . f)
09:04:02 <solonarv> has the right type and everything
09:04:35 <solonarv> also this reveals that "there is a vector involved" doesn't actually add anything special
09:04:56 <lyxia> remexre: it's "n" in the type but that's erased, you would need to add a KnownNat constraint which is extra runtime information to keep and pass around.
09:05:11 <solonarv> if you wanted something like '(Int -> Vector n a -> a) -> Vector n a' that might be a bit more challenging
09:05:30 <solonarv> gah, s/Int/Finite n/
09:05:47 <remexre> I guess I'm trying to build up to KnownNat n => (forall m. (KnownNat m, m <= n) => Vector m a -> a) -> Vector n a
09:05:55 <remexre> where you get the "tail" of the vector to depend on
09:06:11 <remexre> though wait, that doesn't need a fixpoint maybe
09:06:55 <solonarv> actually you can have the entire vector, even
09:07:08 <remexre> er and the <= should be a <
09:07:39 <remexre> with generate, I can?
09:07:45 <solonarv> \f -> let v = generate (f v) in v
09:08:06 <solonarv> that should work, the type is: KnownNat n => (Vector n a -> Finite n -> a) -> Vector n a
09:08:38 * ski . o O ( strong / course-of-values induction/recursion )
09:27:30 <kaol> Is there a discussion group of some sort for polysemy somewhere?
09:32:07 <lyxia> kaol: what kind of discussion are you looking for? there's a lot of activity on github and the author and collaborators are pretty responsive on zulip and slack (functionalprogramming)
09:37:16 <kaol> Opening a github issue doesn't feel like the right thing to do to ask for some help to get my types to match.
09:42:27 <kaol> I'll try my luck with Zulip.
09:43:34 <sm[m]> zulip++
09:44:29 <Eugleo> How can I specify that cabal should use a local patched version of a library rather than the one available on hackage?
09:45:01 <dcoutts_> Eugleo: stick the patched version somewhere locally, and add that dir to your cabal.project file
09:45:46 <Eugleo> I used `cabal get` for the first part, so now to the second. I'll look up cabal.project
09:46:38 <merijn> Eugleo: https://cabal.readthedocs.io/en/latest/nix-local-build-overview.html
09:46:41 <dcoutts_> e.g. "packages: .  ./vendored/*"
09:48:12 <sm[m]> so I guess there's haskell-lang.slack.com and functionalprogramming.slack.com
09:48:48 <Uniaika> sm[m]: don't forget the FP Discord *and* the Haskell Memes Discord that isn't just about memes
09:49:05 <sm[m]> and how do you get access to functionalprogramming.slack.com ? rather unclear
09:49:19 <sm[m]> "Contact the workspace administrator"
09:49:44 <sm[m]> Uniaika: I guess we need a haskell chats page
09:49:47 <Uniaika> sm[m]: Slack workspaces work on invites. You look it up on Google and hope to find a link to register
09:49:52 <Uniaika> sm[m]: do we? :P
09:50:17 <Uniaika> I mean, as long as it is actively maintained, sure
09:50:37 <sm[m]> sure. Just opining aloud, not asking you to do it :)
09:51:10 <aveltras> does anyone have an example of a yesod-core only project that reloads widget/layout files ?
09:51:59 <wavemode> sm[m]: https://fpchat-invite.herokuapp.com/
09:52:47 <sm[m]> thanks wavemode. Not so good for growth this policy, eh ?
09:53:11 <sm[m]> though 13k users have made it in..
09:53:13 <Eugleo> dcoutts_: Thanks. So, if I have my project in /hs/project, I should clone the library into /hs/library and place the cabal.project into /hs?
09:53:20 <kuribas> is it possible to create literate haskell with hyperlinks?
09:53:22 <wavemode> it's trivially found with a google search. though I got that link from a blog post I read recently
09:53:45 <kuribas> Such that you can just click on variables to see its definition?
09:53:54 <kuribas> and ideally type?
09:54:24 <Eugleo> merijn: Thanks. So, if I have my project in /hs/project, I should clone the library into /hs/library and place the cabal.project into /hs?
09:54:47 <sm[m]> fpchat's google captcha is also rather difficult. Here goes fourth attempt...
09:55:19 <wavemode> are you sure you're human? :p
09:55:21 <dsal> kuribas: literate haskell is just a generic concept of inverting code and comments.  There are different literate systems, but they don't generally manipulate the code.
09:55:35 <kuribas> dsal: haddock does
09:55:57 <kuribas> I mean, in haddock code, hyperlinks work
09:55:57 <sm[m]> wavemode: was starting to think I was shadow-banned. I resent these unpaid google AI training jobs
09:56:26 <dsal> It's not that it's impossible, it's just that you're asking about different things.  haddock does a different thing.
09:56:42 <merijn> Eugleo: cabal.project can (technically) go anywhere, the library you cloned doesn't have to be in a subdirectory
09:56:55 <lyxia> literate programming is a generic concept, literate haskell is a concrete language.
09:57:08 <kuribas> dsal: I guess my question is if such a tool exists
09:57:10 <dsal> I've used markdown-unlit, which just puts the code in regular code blocks so that the code is just completely valid markdown.  markdown doesn't know how to hyperlink haskell code.
09:57:47 <sm[m]> wavemode: here I go again, since I didn't get the promised email. Carefully this time. I am definitely doing it right, but it still makes me go through it multiple times
09:58:19 <wavemode> kuribas: I'm not quite understanding - what specific functionality do you need that haddock doesn't offer?
09:58:26 <dsal> There's still a larger question of what would that tool do?  It wouldn't be literate haskell exactly, because you'd want a secondary output from your file.  Right now, it's just the file in its plain form (which could be valid markdown, or bird style or whatever) or you compile it.  What it sounds like you want is a markdown processor that understand how to link haskell code.
09:58:44 <kuribas> wavemode: haddock is not literate programming, it's more a documentation tool
09:59:00 <kuribas> wavemode: not really meant for mixing text and code
09:59:19 <dsal> haddock and your binary are both output of processing the source code.  Literate haskell is just another way of typing in the code.
09:59:20 * hackage massiv 0.5.2.0 - Massiv (Массив) is an Array Library.  https://hackage.haskell.org/package/massiv-0.5.2.0 (lehins)
09:59:23 <merijn> kuribas: Oh, my colleague is working on a literate programming tool (written in Haskell)
09:59:33 <kuribas> merijn: cool :)
09:59:42 <wavemode> but haddock does support .lhs (literate haskell) files
09:59:57 <merijn> kuribas: Does really cool things too, like, if you fix a bug in the "weaved" code it will propagate it back to the literate input
10:00:15 <kuribas> merijn: which language?
10:00:17 <merijn> dsal: There's "literate haskell" the format and "literate haskell" as in writing code in the literate programming style
10:00:43 <merijn> kuribas: Not language specific, I think he has demos in Elm, C++ and some others
10:00:48 <dsal> I don't think I quite know the later.  I've used lhs and .markdown with two different processing tools.
10:00:53 <merijn> kuribas: https://entangled.github.io/entangled/
10:01:19 <kuribas> merijn: currently our indicators are coded in lisp, with the computations all over the place.  I was trying to simplify it in haskell, and just wondering if it could become a literate document with hyperlinks.
10:01:23 <merijn> dsal: The lhs file format still has code determining writing structure, which is antithetical to literate programming
10:02:07 <kuribas> merijn: actually, parsing just the types may not be that hard.
10:03:03 <kuribas> merijn: actually, that would be really cool, that you could edit the indicators online, and it would typecheck and allow you to merge back changes :)
10:03:04 <dsal> merijn: I'll try this thing out to see if I can become enlightened by the difference.  :)
10:06:12 * sm[m] learns that haskell slack community is 4x bigger than IRC now
10:07:44 <Uniaika> sm[m]: in activity or idling? :P
10:08:14 <dsal> I don't know how people can manage to many chat fractals + actually do anything.
10:08:18 <sm[m]> that I don't know.. just going by room member counts
10:10:48 <maerwald> the problem with slack it... it sucks :>
10:11:02 <maerwald> it leaks memory, no matter whether I use the browser or the "desktop app"
10:12:01 <fog> if i have an MVector of MVectors, when i access an element it will return an MVector, and i can access the elements of this - or alternatively, I could just have a really long MVector, and calculate the position corresponding to a pair of Ints, as just an Int
10:12:46 <Uniaika> fog: what is things trying to solve?
10:12:48 <fog> I'm just not sure about how it brings the inner MVector into being, does it do so inexpensively, or does it wake a whole section of memory, or something...
10:12:57 <kuribas> fog: or use matrices? https://hackage.haskell.org/package/matrices
10:13:16 <wavemode> fog: does it have to be an MVector of MVectors? are they different lengths? I ask because, if they're all the same length you could just model it as a single MVector
10:13:19 <fog> Uniaika: fast mutable update of a multidimensional MVector thing
10:13:26 <fog> kuribas: they are not square
10:13:30 <wavemode> ah
10:13:49 <fog> i could still join them down to a long MVector though...
10:14:11 <fog> but maybe there would be no need, if accessing the inner MVectors is no bother
10:15:13 <fog> im just doing the type level stuff atm, so i can do the unsafe update version with the bounds checking being done at type level
10:15:19 <wavemode> if they can all be the same length, it makes sense to just make one long vector where the element (x, y) is in position (x + width*y)
10:15:51 <fog> yeah, otherwise, with them having different shapes you have to traverse the whole preceeding list of lengths to find the index, which is costly
10:16:31 <fog> but then, this could be cheaper than resolving the entire inner MVector 
10:16:47 <fog> idk how that works so i cant really understand
10:17:27 <fog> the hope would be that accessing the inner MVector would be basically costless, and that things only happen when this is modified, which is cheap 
10:17:59 <fog> but I have no reason to suspect thats how it works, as I dont really understand how its implemented
10:18:52 <monochrom> Perhaps the young generation have not been exposed to "write-protecting a floppy disk" and it's why they don't understand unsafeFreeze and unsafeThaw.
10:19:17 <Uniaika> monochrom: never had to handle a floppy disk :P
10:19:26 <solonarv> I have, but just barely
10:19:28 <fog> are you saying an immutable Vector is just a write protected MVector?
10:19:35 <fog> i thought it had cons...
10:20:09 <Uniaika> fog: it has "cons" but it produces another vector ;)
10:20:45 <fog> right, but that makes it seem like its more like its been elevated from just being memory addresses into something more like tail references or copies
10:21:01 <monochrom> Existence of API does not imply cheap cost.  Now this is a mistake you can't make if you actually learned CS.
10:21:28 <fog> sim city 2000 took several floppy disks
10:21:38 <wavemode> MVectors aren't like C++ vectors
10:22:24 <fog> right, but thats the only intuition I have of anything like editing memory adresses, which I think is how MVectors are O(1) update
10:22:51 <monochrom> Actually how is MVector not like C++ vector?
10:23:30 <wavemode> a C++ vector dynamically resizes so that appending elements is amortized O(1)
10:23:34 <fog> like, if accessing the inner vector basically just resolves the bounds on the memory addresses, then it would be cheap - much more so than calculating the index of a flattened version
10:23:39 <monochrom> Oh, that.
10:24:09 <solonarv> additionally, Data.Vector.Mutable.MVector contains a bunch of pointers itself
10:24:13 <monochrom> But cons is still expensive for shifting everyone to the right, even when resizing is cheap.
10:24:23 <fog> i guess it is basically just converting the Int accesor into a physical address 
10:24:24 <solonarv> (rather than directly containing the data)
10:24:44 <wavemode> if you want the same asymptotics in haskell you'd typically use Data.Seq
10:24:55 <monochrom> BTW this is also how you find out that python "list" is more likely array.  You benchmark prepending.
10:25:17 <fog> and that when the inner MVector is mutated, all thats resolved is the machinery to do this Int -> Adress conversion, ie, just the bounds
10:26:42 <fog> but then, if I had a deep binary partition tree, maybe this would end up being more costly than repeatedly mod 2 to produce the Index of the flattened version
10:27:44 <fog> solonarv: what your saying seems to confirm that accessing the inner MVector shouldnt be costly, so that flattening would be unlikely to be faster
10:29:48 <fog> whats annoying is having to permute the lengths through the nesting
10:30:01 <fog> otherwise it would need a hetrogenous MVector
10:31:18 <fog> then you do the bounds checking on the tuple of indexes before unwrapping the phantom length annotated nesting of un-length-annotated MVectors 
10:32:11 <fog> probably with an insane version of join...
10:33:00 <fog> might just avoid flattening for this reason - regardless of performance 
10:38:18 <fog> im not sue, but being able to do these index calculations for bounds checking at type level at compile time could end up with code that runs faster than the equivalent c code?
10:43:19 * hackage hw-balancedparens 0.4.1.0 - Balanced parentheses  https://hackage.haskell.org/package/hw-balancedparens-0.4.1.0 (haskellworks)
11:05:49 * hackage little-rio 0.1.1 - When you need just the RIO monad  https://hackage.haskell.org/package/little-rio-0.1.1 (ejconlon)
11:08:32 <Eugleo> Is it possible with cabal to hide `id` from prelude project-wide?
11:12:12 <monochrom> No.
11:12:16 <yushyin> custom project-wide Prelude + mixins (to hide the default prelude and rename your custom prelude to Prelude) might work?
11:14:25 <fog> rrg, this kind of error keeps happening, im not sure if its a bug, can anyone see whats going wrong?
11:14:26 <fog> https://pastebin.com/raw/0wuXKhmh
11:14:28 <merijn> monochrom: Sure it is, just specify NoImplicitPrelude in your cabal file? :p
11:14:51 <merijn> Also, don't do that if you don't want to be lynched by future programmers
11:14:52 <yushyin> Eugleo: but that's a very roundabout way :D
11:14:54 <fog> something that evaluates using :kind! in ghci isnt being resolved in the source file
11:15:26 <monochrom> I don't say that "hide id" is an XY problem.  However, every solution will be an XY solution.
11:16:05 <monochrom> For example, if you go NoImplicitPrelude, now you have to go out of your way to import Prelude for things you still want.
11:17:09 <monochrom> Think of it as a game in which you move first but your adversary has a winning strategy.
11:18:04 <dsal> Heh.  Why would you want to hide `id`?
11:18:47 <merijn> monochrom: I interpret these questions as if I'm a DM and someone is casting "wish" ;)
11:19:56 <monochrom> Yes, we all need to do that more.
11:21:32 <dmwit> fog: I would guess something doesn't have the kind you expect. You might want to turn on -fprint-explicit-foralls and... the other one (can't remember off the top of my head) that prints kind annotations in all foralls, and see if anything looks amiss in the new, longer error message.
11:22:05 <fog> but if it works from ghci, how could that be?
11:22:09 <dmwit> dsal: Presumably because they want Control.Category.id instead or something.
11:22:48 <dmwit> fog: ghci has (well, can have) different extensions turned on than the modules it loaded.
11:23:06 <dmwit> This can affect the outcome of type and kind queries.
11:25:20 * hackage ref-extras 0.1.0 - Extra stuff for mutable references  https://hackage.haskell.org/package/ref-extras-0.1.0 (ejconlon)
11:28:05 <WzC_> does anyone know if a function like 'foldr1with' as I've defined here https://gist.github.com/noinia/3bffd20f5023696db42148d348d0728b exists somewhere? 
11:28:40 <WzC_> i.e. it is basically foldr1, but instead of directly using the rightmost element as the basecase of the recursion, you can supply a function 'b' that transforms it first
11:31:49 <fog> https://pastebin.com/raw/Bq70TCk6
11:31:55 <fog> same error, better code
11:32:25 <fog> ah, you think a language extension could be breaking things, interesting
11:39:37 <berndl> WzC_: I don't know of any similar funtion. It looks like the fold for a nonempty list type with singleton and cons constructors.
11:44:46 <fog> nope
11:45:08 <fog> even with all the same language extensions enabled in ghci, it still resolves the kind
11:45:25 <fog> i cant see why it wouldnt be able to do so in the code...
11:48:53 <fog> hmm, if i put the code which fails into a new module which imports the previous code it works...
11:49:50 <fog> again, even with the same language extension
11:50:00 <fog> so - its not a problem with language extensions
11:50:10 <fog> maybe the typechecker does one module at a time
11:50:30 <fog> and there is some kind of ambiguity it cant resolve untill it has checked the whole module
11:50:47 <fog> really weird error...
11:50:49 * hackage bz2 1.0.0.3 - Bindings to libbz2  https://hackage.haskell.org/package/bz2-1.0.0.3 (vmchale)
11:51:59 <fog> so the reason it works in ghci is because it completes the compilation of the module
11:52:24 <fog> so that subsequent imports can resolve the evaluation of the type families
11:52:58 <fog> probably should get it into a shorter error producing code for reproducibility / to understand when this happens
11:53:43 <fog> could be something to do with associated type families
11:54:34 <fog> and when the classes need to be factored into two to avoid the "no use of type associated families in the class that defines them - recursive subclasses" error 
11:57:54 <dfin> I want to implement toJSON for PortNumber. How can I turn a PortNumber back into an Int?
12:01:40 <srk> dfin: toInteger
12:02:48 <srk> and then fromIntegral
12:03:41 <dfin> srk: thanks!
12:03:54 <srk> yw!
12:11:58 <tomjaguarpaw> Does anyone know if xmonad has "escape key" functionality?  Currently Alt-. is bound to "Fewer master windows".  But Alt-. is also a keybinding in Emacs for me.  Is there any "escape prefix" I can configure for xmonad that will allow me to pass Alt-. through to the focused window?
12:12:23 <Uniaika> tomjaguarpaw: ask on #xmonad
12:13:08 <tomjaguarpaw> Will do
12:20:20 * hackage reflex-vty 0.1.4.0 - Reflex FRP host and widgets for vty applications  https://hackage.haskell.org/package/reflex-vty-0.1.4.0 (3noch)
12:22:42 <dfin> Can someone help with this? What is wrong here?
12:22:43 <dfin> instance FromJSON PortNumber where
12:22:43 <dfin>     parseJSON = \s -> withScientific s f
12:22:43 <dfin>         where
12:22:43 <dfin>             f s = pure $ toInteger s
12:23:37 <Uniaika> dfin: wait, what are you trying to do?
12:23:50 <dfin> implementing FromJSON for PortNumber? :-)
12:24:10 <Uniaika> is PortNumber a record? a newtype?
12:24:30 <dfin> https://hackage.haskell.org/package/network-3.1.1.1/docs/Network-Socket.html#t:PortNumber
12:26:39 <koz_> dfin: What's the error?
12:27:33 <dfin> https://pastebin.com/xUHmpQvQ
12:28:01 <koz_> Yeah, because parseJSON doesn't have a function type.
12:28:07 <koz_> It's of type Parser PortNumber.
12:28:15 <koz_> So \s -> ... is definitely off.
12:28:26 <koz_> The with* helper functions take two arguments.
12:28:45 <koz_> One is a Text, describing what the error messages should refer to the thing you're trying to parse as.
12:28:55 <koz_> The other is a function, which will be passed an appropriate value.
12:28:55 <dfin> oh, ... stupid me. 
12:29:04 <koz_> (also, I don't think you wanna be parsing via that route)
12:29:14 <dfin> how else? ;-) 
12:29:27 <koz_> (unless you want to have your _JSON decoding_ throw issues regarding being unable to convert 0.034 to a port number)
12:29:31 <koz_> Convert from Text.
12:29:36 <koz_> (and to Text)
12:30:15 <dfin> But the field needs to be of the form: port: 123
12:30:37 <koz_> dfin: Everything is Text at first when decoding JSON.
12:30:51 <koz_> Just because something _happens coincidentally to look_ like a number does not make it one.
12:30:59 <koz_> Also, are you using this toInteger? https://hackage.haskell.org/package/base-4.14.0.0/docs/Prelude.html#v:toInteger
12:31:23 <koz_> Cause that won't work on a Scientific.
12:31:32 <koz_> Since Scientifics can represent decimals of arbitrary precision.
12:31:52 <koz_> So you're gonna have to either painstakingly disassemble your Scientific, or just go via Text to begin with.
12:32:13 <dfin> ok
12:32:19 <koz_> Says right here in the Scientific docs: A scientific number with coefficient c and base10Exponent e corresponds to the Fractional number: fromInteger c * 10 ^^ e.
12:32:56 <koz_> What you're taking is not that.
12:33:14 <koz_> Actually wait, you might have to do that disassembly anyway.
12:33:20 <koz_> Because Aeson is too smart for its own good.
12:33:28 <koz_> It won't interpret that kind of field as text, argh.
12:33:29 <koz_> So yeah.
12:33:36 <koz_> Enjoy tearing apart Scientifics for fun and profit.
12:34:16 * koz_ doesn't even know how you'd do that.
12:34:43 <veverak> hi folks
12:34:57 <veverak> I installed lambdabot and maybe you can help me ... I have installed .deb package of it
12:35:06 <koz_> dfin: This may help: http://hackage.haskell.org/package/scientific-0.3.6.2/docs/Data-Scientific.html#v:floatingOrInteger
12:35:18 <veverak> can I somehow disable some modules at runtime?
12:35:51 <dfin> koz_: Maybe I just use an Int in my struct. ;-) 
12:36:19 <koz_> dfin: You could, but I wouldn't advise that either.
12:36:39 <koz_> You basically have the choice of making _parsing_ the translation boundary, or making _everything else_ the translation boundary.
12:36:46 <koz_> And translation boundaries are where bad things can happen.
12:37:02 <koz_> So would you rather complexity and bad things in _one_ place? Or _N_ places?
12:39:29 <dfin> ... you mean the shotgun parser approach. ;-)
12:41:05 <dfin> So, I guess I have to do something like parseJSON Number s = ... ; parseJSON _ = exception 
12:47:56 <koz_> dfin: No, not really.
12:48:03 <koz_> You still wanna use withScientific.
12:48:20 <koz_> Then, with the Scientific you get inside the function argument, you wanna use the thing I linked.
12:48:24 <koz_> Then case on the Either.
12:48:38 <koz_> If it comes back as something that's not got decimal places, continue.
12:48:42 <koz_> If it does, fail out.
12:49:15 <koz_> (what you're suggesting won't work - the type of parseJSON is Parser PortNumber)
12:49:27 <koz_> (no arguments there)
12:49:41 <dmwit> I think I would not use floatingOrInteger here.
12:50:08 <dmwit> I would guard on `base10Exponent v = 0`.
12:50:29 <dmwit> It would be weird to see `port: 5e10`, and you should probably issue an error if somebody tries that.
12:50:42 <dfin> this seems to work: 
12:50:46 <dfin> instance FromJSON PortNumber where
12:50:46 <dfin>     parseJSON (Number s) = toI $ floatingOrInteger s
12:50:46 <dfin>         where
12:50:46 <dfin>             toI (Left r) = fail "float is not int"
12:50:46 <dfin>             toI (Right i) = pure (i::PortNumber)
12:50:48 <dfin>     parseJSON _ = fail "must be int"
12:50:53 <koz_> dmwit: I didn't suggest it as the _only_ refinement step.
12:51:01 <koz_> But your idea is likely better, yeah.
12:51:29 <dmwit> But I'm saying I wouldn't use it as a refinement step as all.
12:51:37 <dmwit> Just use `base10Exponent` and `coefficient` directly.
12:51:39 <koz_> dmwit: Yeah, upon further examination, you're right.
12:52:06 <dfin> ok. Thanks a lot!
12:52:11 <dmwit> dfin: You might also like typeError in place of fail.
12:52:21 <dfin> typeError ... ?
12:52:38 <dmwit> Sorry, typeMismatch
12:52:49 <dmwit> http://hackage.haskell.org/package/aeson-1.4.7.1/docs/Data-Aeson-Types.html#v:typeMismatch
12:54:00 <dmwit> And the reason I'd avoid floatingOrInteger: you will have a weird DOS when somebody writes `port: 1e99999999999999999999999999999999`.
12:54:37 <dfin> this is not publicly exposed.
12:54:38 <dmwit> Checking `base10Exponent s = 0` instead completely avoids this. Then the DOS involves sending such a longer JSON text than you can store in memory, which seems hard.
12:56:19 <koz_> Welp, TIL.
12:56:50 <day> what is haskells equivalent to 'sprintf'?
12:56:54 <dmwit> printf
12:57:09 <dfin> dmwit, koz_: Thanks a lot!
12:57:14 <dfin> This was really helpful!
12:57:25 <dmwit> ...but usually we use a better pretty-printing library than printf.
12:57:25 <day> ah i assumed printf would be IO()
12:57:28 <dmwit> e.g.
12:57:31 <day> m/b
12:57:33 <dmwit> It is. It is also String
12:57:40 <dmwit> Return-type polymorphism is great!
12:57:41 <day> yeah just saw that it is overloaded
12:57:44 <dmwit> ?hackage prettyprinters
12:57:45 <lambdabot> http://hackage.haskell.org/package/prettyprinters
12:57:49 <dmwit> ?hackage prettyprinter
12:57:49 <lambdabot> http://hackage.haskell.org/package/prettyprinter
12:57:58 <dmwit> (sorry about that first one)
13:07:06 <oats> printf is black damn magic
13:09:22 <oats> a ~ () => PrintfType (IO a)
13:09:29 <oats> what does this mean?
13:09:39 <oats> can you not just implement 'PrintfType (IO ())'
13:09:59 <solonarv> sure, that would also work. but type inference wouldn't work as well.
13:10:52 <solonarv> when GHC looks for an instance to match a constraint, it looks only at the instance head - the part to the right of the => in 'instance Cxt ... => Class ... where'
13:11:47 <solonarv> with 'instance PrintfType (IO ())', GHC will only pick that instance if it already knows that we're looking for 'PrintfType (IO ())', because that's the only way for that instance head to match a constraint
13:12:44 <Cale> (which means that it'll have to already have determined that the result of the IO action is (), which it can't if you're writing a single printf in the middle of a do-block and not binding the result
13:12:44 <dsal> :t printf
13:12:45 <lambdabot> PrintfType r => String -> r
13:12:48 <Cale> )
13:12:54 <solonarv> with 'instance a ~ () => PrintfType (IO a)', the instance head is 'PrintfType (IO a)', which matches as soon as we know we need a 'PrintfType (IO something)' constraint
13:13:16 <Cale> yeah, and then, after the instance matches, we *learn* that a needs to be ()
13:13:25 <Cale> which actually helps it infer the types required
13:13:33 <solonarv> so GHC will pick that instance - setting 'a ~ something' - and then try to satisfy the instance's constraints (in this case, 'a ~ ()')
13:13:41 <solonarv> this way GHC learns that 'something' must be '()'
13:13:53 <solonarv> progress!
13:14:50 * hackage faktory 1.0.1.2 - Faktory Worker for Haskell  https://hackage.haskell.org/package/faktory-1.0.1.2 (PatrickBrisbin)
13:28:20 * hackage haskoin-store-data 0.26.0 - Data for Haskoin Store  https://hackage.haskell.org/package/haskoin-store-data-0.26.0 (jprupp)
13:29:20 * hackage haskoin-store 0.26.0 - Storage and index for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-store-0.26.0 (jprupp)
13:52:20 * hackage rib 0.10.0.0 - Static site generator based on Shake  https://hackage.haskell.org/package/rib-0.10.0.0 (sridca)
14:02:07 <mbucc> howdy
14:02:20 <Uniaika> heya mbucc 
14:02:36 <mbucc> i'm trying to  install haskell on osx following the ghcup but am getting the following cabal error:
14:02:56 <mbucc> cabal: unrecognised command: new-update
14:03:26 <maerwald> mbucc: cabal --version && which cabal
14:04:09 <mbucc> Marks-MBP-3:~ mark$ which cabalMarks-MBP-3:~ mark$ .cabal/bin/cabal --versioncabal-install version 1.22.6.0using version 1.22.4.0 of the Cabal library Marks-MBP-3:~ mark$ 
14:04:29 <maerwald> mbucc: remove ~/.cabal/bin/cabal
14:04:56 <maerwald> it is intentional that ~/.cabal/bin overrides the ghcup cabal, because it should take precedence when you install cabal from source
14:05:35 <maerwald> and we're not messing with user installed binaries
14:05:36 <mbucc> Downloading the latest package list from hackage.haskell.org
14:05:38 <mbucc> :)
14:05:39 <mbucc> thx.
14:51:27 <gambpang> Hey everyone.  I've got a project folder on my macos workstation that I'm sharing into a vm using vagrant.  If I cabal build on my workstation, I get errors on the vm trying to build there.  Cabal cannot find the object files for world packages.  Any advice on what to do?
14:52:08 <gambpang> I can clone my project folder and dedicate one to the mac environment and one to the vm, but it would be nice to operate out of a single repo.
15:05:49 * hackage addy 0.1.0.0 - A full-featured library for parsing, validating, and rendering email addresses  https://hackage.haskell.org/package/addy-0.1.0.0 (PeterJones)
15:34:20 * hackage streamly-posix 0.1.0.1 - Posix related streaming APIs  https://hackage.haskell.org/package/streamly-posix-0.1.0.1 (maerwald)
16:08:50 * hackage bv-sized 1.0.0 - a BitVector datatype that is parameterized by the vector width  https://hackage.haskell.org/package/bv-sized-1.0.0 (benselfridge)
16:13:19 * hackage hpath-directory 0.13.4 - Alternative to 'directory' package with ByteString based filepaths  https://hackage.haskell.org/package/hpath-directory-0.13.4 (maerwald)
16:14:19 * hackage hpath-io 0.13.2 - High-level IO operations on files/directories  https://hackage.haskell.org/package/hpath-io-0.13.2 (maerwald)
16:28:47 <Uniaika> maerwald: thanks for hpath btw :)
16:29:51 <dsal> I'm disappointed that http://hpath.io/ isn't a microservice I can use to walk my filesystem.
16:30:42 <int-e> why would I want a microservice to walk my filesystem
16:31:11 <Uniaika> WebFS API
16:31:16 <dsal> Um, because we're modern software engineers.
16:31:25 <int-e> speak for yourself
16:31:29 <dsal> `easyDelete :: Path b -> IO ()`  -- proposal:   `easierDelete :: IO ()`
16:31:33 <int-e> (I suppose you did)
16:32:01 <int-e> findMyFiles :: IO Void
16:32:05 <wavemode__> `easiestDelete = unsafePerformIO easierDelete`
16:32:07 <dsal> haha
16:32:10 <Uniaika> int-e: hahaha
16:33:09 <dsal> This looks pretty good for making haskell "shell scripts" though.
16:33:52 <wavemode__> Turtle is the best lib for a shell script
16:51:40 <monochrom> What does "recreate symlink" mean?
16:53:20 <monochrom> But yeah finally a filepath type that conal would not disapprove :)
16:56:01 <dsal> I read that as `ln -sf`
17:04:57 <johnw> has anyone succeeded at producing fully static Haskell binaries on macOS?
17:05:48 <Uniaika> johnw: it's complicated™
17:05:58 <johnw> so my last two days have taught me
17:06:01 <Uniaika> (generally, not only on macOS)
17:06:14 <fog> https://github.com/fog-hs/Frost
17:06:17 <johnw> I've got it down to only dynamic dependencies on libffi, gmp and libiconv
17:06:31 <Uniaika> I remember someone on this channel was sweating blood doing this, some years ago
17:06:33 <fog> does this work on anyones machine? i fear mine is malfunctioning 
17:06:33 <johnw> I'm using Nix, if it helps
17:09:25 <Uniaika> johnw: I don't think you'll be able to do it today
17:09:57 <Uniaika> I don't even know if anyone has ever managed to do that although it might be possible but that's still very much tribal knowledge
17:10:23 <fog> currently it seems to be able to import a module successfully into some, but not other modules...
17:10:52 <fog> i think I could have installed GHC badly, but i would need to reinstall windows (or nuke it form orbit) to be sure
17:11:29 <fog> would really appriciate if anyone could check to see if it works - if it doesnt, then its not my machine being broken.
17:26:27 <fog> oh yeah, vms exist... sry
17:48:00 <jackdk> johnw: I haven't done much in this space for a while, but since you're on nix let me point you at https://github.com/nh2/static-haskell-nix . targeting linux not macos but perhaps there are tricks you can use
18:25:02 <jchia_> I pure code calls error, and I want to catch it, which instance of Exception should I catch?
18:25:27 <jackdk> http://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Exception-Base.html#t:ErrorCall
18:26:26 <jchia_> thanks
18:26:49 <jackdk> np
20:04:12 <pie_> what do the banks and such that use haskell do for gui stuff?
20:10:56 <wavemode__> I think production haskell is most often run on servers, with no gui
20:11:28 <wavemode__> still, options exist. https://wiki.haskell.org/Applications_and_libraries/GUI_libraries
20:11:55 <dsal> @hoogle tn3270
20:11:55 <lambdabot> No results found
20:37:05 <jchia_> Should I use IOError or IOException given that they are synonymous?
20:38:56 <EvanR> what do you mean by use
20:39:18 <jchia_> EvanR: For example, when I catch
20:40:41 <jchia_> Prelude has "type IOError = IOException", and Control.Exception has an IOException.
20:41:36 <jchia_> When I catch, I'll be using some type signature to indicate what type of exception I want to catch, so I need to specify IOError or IOException.
20:42:12 <EvanR> either will work
20:44:12 <EvanR> Why there are two names for this type I do not know. They both appear, as synonyms (and as a constructor name!) in the paper https://simonmar.github.io/bib/papers/ext-exceptions.pdf
20:45:38 <jchia_> I'm just wondering why there are two.
20:45:47 <jchia_> So confusing to read
20:45:53 <EvanR> yep 
20:45:57 <jchia_> just one more piece of haskell trivia to remember
20:47:28 <EvanR> IOException matches the form of ArithException and SomeException which are instances of Exception so maybe it is more natural
20:48:00 <EvanR> but IOError is referenced in many tutorials
20:48:57 <jchia_> I should change my code to consistently use one of them.
20:49:56 <EvanR> the paper kind of explains that IOError was the name of an old abstract type in the very early days of haskell exceptions
20:50:30 <EvanR> it must have been reimplemented as IOException at some point and kept for compatibility
20:50:49 <jchia_> Yeah, so I'll try to consistently use IOException instead of IOError.
20:51:10 <jchia_> There's a library with a pure function that calls error (https://hackage.haskell.org/package/bz2-1.0.0.3/docs/Codec-Compression-BZip.html#v:decompress). I personally think it should be throwing an IOException instead, so when I use it, in my own function, I make a wrapper function that uses MonadIO and converts the ErrorCall into an IOException. This is similar in spirit to wrapping "head :: [a] -> a" into headM :: MonadIO m => [a] -> m
20:51:10 <jchia_>  a".  Is this a good approach? Is there a better way?
20:51:36 <EvanR> a pure function throwing IOException? 
20:51:45 <jchia_> no, it calls error
20:51:52 <jchia_> i'm trying to wrap it in a MonadIO
20:52:03 <jchia_> I think one can call it a partial function
20:52:16 <jchia_> decompress :: ByteString -> ByteString
20:52:26 <EvanR> yeah error is messy if it's at all possible to happen
20:53:12 <EvanR> decompress seems like it could fail. The braindead way is to return a Maybe or Either DecompressionProblem
20:53:38 <jchia_> it calls error when an error is detected in the input
20:54:16 <EvanR> is there a way to validate the format before decompressing
20:54:40 <EvanR> i guess not
20:54:49 <jchia_> The bz2 package uses a C library that does the real work. Whatever validation needs to be done is also the job of the C library.
20:55:13 <EvanR> well you're in a bad position of catching an error call
20:55:42 <EvanR> unless you can update the library binding
20:56:23 <jchia_> Without changing the bz2 library, can wrap decompress in my own "decompressM :: MonadIO m => ByteString -> m ByteString"
20:56:30 <EvanR> using error in the case of ... a legitimate error from the C lib is lazy AF
20:57:15 <EvanR> does it really need IO ?
20:57:16 <jchia_> i agree, just wondering whether i should make an issue to ask for the interface to change or for a more well-typed function to do decompression
20:57:27 <jchia_> it could do with Maybe or Either
20:57:48 <wavemode__> ah I see, she changed the logic but didn't want to change the interface. since it used to infinite loop on certain malformed input
20:58:59 <jchia_> there was a package update yesterday to deal with erroneous input, but the function type remained the same
22:32:36 <pie_> can I get ghci to tell me the type of substituting an argument for something?
22:32:44 <pie_> oh duh i just figured it out 5 minutes ago nevermind
22:32:49 <pie_> (use `undefined`)
22:34:09 <pie_> well mmy prolem might not be that simple but basically im trying to use ghci to figure out some types with holes...
22:34:27 <pie_> and its problematic because ghc considers _ as errors
22:34:34 <pie_> and hten it doesnt load any of my definitions
22:34:42 <EvanR> map `asAppliedTo` chr
22:34:45 <EvanR> :t map `asAppliedTo` chr
22:34:46 <lambdabot> (Int -> Char) -> [Int] -> [Char]
22:34:53 <EvanR> @src asAppliedTo
22:34:53 <lambdabot> f `asAppliedTo` a = f where _ = f a
22:34:53 <lambdabot> infixl 0 `asAppliedTo`
22:35:31 <iqubic> How does that even work?
22:35:40 <EvanR> exercise for the reader
22:36:40 <wavemode__> oh that's clever
22:36:43 <iqubic> (map `asAppliedTo` [1...]) (+1) [1,2,3]
22:36:56 <iqubic> > (map `asAppliedTo` [1...]) (+1) [1,2,3]
22:36:58 <lambdabot>  error:
22:36:58 <lambdabot>      A section must be enclosed in parentheses thus: (1 ...)
22:37:10 <iqubic> > (map `asAppliedTo` [1..]) (+1) [1,2,3]
22:37:12 <lambdabot>  error:
22:37:12 <lambdabot>      • Couldn't match expected type ‘b -> b’
22:37:12 <lambdabot>                    with actual type ‘[Integer]’
22:37:16 <iqubic> What?!?
22:37:30 <wavemode__> map's first argument is a function, not a list
22:37:47 <iqubic> Ah.
22:38:05 <MarcelineVQ> interesting definition, I usually see it as const
22:38:11 <iqubic> > (map `asAppliedTo` head) (+1) [1,2,3]
22:38:13 <lambdabot>  error:
22:38:13 <lambdabot>      • Occurs check: cannot construct the infinite type: b ~ [b]
22:38:13 <lambdabot>        Expected type: [b] -> b
22:38:23 <MarcelineVQ> *of asAppliedTo
22:38:29 <EvanR> @src const
22:38:29 <lambdabot> const x _ = x
22:38:43 <iqubic> > (map `asAppliedTo` chr) (+1) [1,2,3]
22:38:44 <lambdabot>  error:
22:38:45 <lambdabot>      • Couldn't match type ‘Int’ with ‘Char’
22:38:45 <lambdabot>        Expected type: Int -> Char
22:38:51 <iqubic> What is going on here???
22:38:52 <EvanR> :t (\x _ -> x) map chr
22:38:54 <lambdabot> (a -> b) -> [a] -> [b]
22:39:14 <EvanR> :t let f x _ = x in map `f` chr
22:39:16 <lambdabot> (a -> b) -> [a] -> [b]
22:39:24 <iqubic> > (map `asAppliedTo` (*1)) (+1) [1,2,3]
22:39:27 <EvanR> doesn't specialize
22:39:27 <lambdabot>  [2,3,4]
22:39:32 <iqubic> Ah, I see.
22:39:37 <iqubic> That's so weird.
22:40:08 <iqubic> It's a non-specialized map.
22:40:48 <wavemode__> iqubic: asAppliedTo doesn't do anything except constrain the type
22:40:52 <wavemode__> :t map
22:40:53 <lambdabot> (a -> b) -> [a] -> [b]
22:40:56 <iqubic> How does it work?
22:41:04 <wavemode__> :t (map `asAppliedTo` (+1))
22:41:05 <lambdabot> Num b => (b -> b) -> [b] -> [b]
22:41:34 <EvanR> it coerces map into specializing
22:42:15 <EvanR> maybe not a great word given the context... uh... compels
22:42:46 <wavemode__> @src asAppliedTo
22:42:47 <lambdabot> f `asAppliedTo` a = f where _ = f a
22:42:47 <lambdabot> infixl 0 `asAppliedTo`
22:42:53 <wavemode__> the definition pretty much explains it
22:46:16 <MarcelineVQ> "f can be applied to a, thus the type of f's argument must unify with a's type"
22:48:06 <pie_> so, Im trying to use type synonyms to make figuring stuff out easier, 
22:48:08 <pie_> type X a r0 k0 = a -> CursorK k0 -> Const r0 k0
22:49:04 <pie_> but then this happens https://bpaste.net/LQGA
22:51:03 <MarcelineVQ> doesnt that have an xtra CursorK at the end compared to type X
22:51:43 <wavemode__> what is CursorK?
22:53:47 <pie_> MarcelineVQ: oh yeah, I guess I cant read
22:53:55 * pie_ pokes some more
22:54:31 <pie_> MarcelineVQ: much better
23:10:23 <pie_> how can I make this output the inferred type instead of erroring? https://bpaste.net/66OA
23:12:38 <MarcelineVQ> hmm undefined in a function position isn't likely to give you useful info in the first place
23:12:56 <MarcelineVQ> :t undefined (1+1)
23:12:57 <lambdabot> t
23:13:33 <wavemode__> unless the expression has an expected type
23:13:47 <MarcelineVQ> ah maybe, fair enough :>
23:14:41 <pie_> yeah sure but id still like it to tell me what it /was/ able to figure out
23:14:54 <pie_> also how do I "expand" something like :
23:14:56 <pie_>  :t forall kind. Getting Cursor (CursorK kind)
23:15:04 <wavemode__> what does it say if the undefineds are holes instead?
23:15:25 <pie_> well it says stuff but id like to do it without "error"s
23:15:51 <wavemode__> what do you mean
23:16:18 <pie_> I want to get something like the output of :t
23:17:27 <pie_> ok i think this is what i wanted for the other question:
23:17:27 <pie_> :kind! forall kind. Getting Cursor (CursorK kind)
23:17:28 <pie_> forall kind. Getting Cursor (CursorK kind) :: * -> *
23:17:28 <pie_> = Getting Cursor (CursorK kind)
23:17:46 <pie_> it doesnt exctly help but its progress
23:20:01 <pie_> the manual says its supposed to expand type synonyms but its not expanding Getting :/
23:20:16 <pie_> type Getting r s a = (a -> Const r a) -> s -> Const r s -- Defined in ‘Lens.Micro.Type’
23:20:36 <pie_> > :kind! forall r0. forall kind. Getting r0 (Cursor) (CursorK kind)
23:20:36 <pie_> forall r0. forall kind. Getting r0 (Cursor) (CursorK kind) :: * = Getting r0 Cursor (CursorK kind)
23:20:39 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
23:26:30 <pie_> basically im trying to poke at type level stuff to see what things should look like and its being really problematic
23:27:22 <pie_> meanwhile I found PartialTypeSignatures, but this is complaining about constraints https://bpaste.net/53WQ
23:28:16 <pie_> and Im not sure how to add the constraint to the signature here
23:28:32 <pie_> I tried :: _ => _ but that does nothing to the error
23:29:40 <pie_> hm maybe id need an undefined that accepts constrants
23:34:16 <MarcelineVQ> you can try the TypeApplications extension as a more direct way to supply that kind of stuff, though I'm not sure where it's appropriate to add in that sig
23:34:27 <pie_> and then pie_ realized he could just get ghci to infer the thing he wanted in the first place
23:34:45 <MarcelineVQ> % :t map @(Maybe Int)
23:34:45 <yahb> MarcelineVQ: (Maybe Int -> b) -> [Maybe Int] -> [b]
23:35:04 <pie_> all this was becuase I was trying to kludge out what the type of filter is in something like `:t \tu filter -> cursorDescendantsF . filter $ translationUnitCursor tu`
23:35:06 <MarcelineVQ> % :t fmap @Maybe
23:35:06 <yahb> MarcelineVQ: (a -> b) -> Maybe a -> Maybe b
23:35:12 <MarcelineVQ> ^ is what I meant to write
23:35:24 <pie_> yeah im familiar with the applications but the point would be for ghci to tell me instead of me guessing
23:36:12 <pie_> :t \tu filter -> cursorDescendantsF . filter $ translationUnitCursor tu
23:36:12 <pie_>  (HasChildren kind, Contravariant f, Applicative f) => TranslationUnit -> (CursorK 'TranslationUnit -> Cursor -> f Cursor) -> CursorK kind -> f (CursorK kind)
23:36:13 <lambdabot> error:
23:36:13 <lambdabot>     Variable not in scope: cursorDescendantsF :: b -> c
23:36:13 <lambdabot> error:
23:43:35 <pie_> right so i think this is what im actually trying to solve but it runs into the constraint problem again
23:43:36 <pie_>  :t \tu filter -> (flip (undefined :: _ => _)) (cursorDescendantsF . filter) $ translationUnitCursor tu
