00:00:00 <iqubic> This is starting to sound like an XY problem. Before proceeding, I think you should answer dmwit's question.
00:00:53 <Nolrai> Trying to do neuro network stuff where nodes are labled by hashes.
00:01:18 <Nolrai> With spase connections.
00:01:34 <dmwit> "Sparse" I understand. "Unknown size" I do not yet understand.
00:02:23 <Nolrai> Well I mean this is happening because I am trying to run the empty net.
00:03:56 <dmwit> Again: "no connections" I understand. "Unknown size" I do not yet understand.
00:04:15 <dmwit> I can tell you how to make a sparse matrix that represents no connections, but of a fixed size. That is easy.
00:05:01 <dmwit> But surely even for your net with no connections, you know how many nodes there are that aren't connected...??
00:06:35 <Nolrai> I know how many nodes, but now I am worried that I don't have "sparse vectors" to work with.
00:07:03 <Nolrai> Sorry I am sort of thinking outloud here.
00:07:51 <dmwit> Well, if you want to represent the empty net that connects m nodes to n nodes, you can use `mkSparse [((m-1, n-1), 0)]`.
00:08:10 <Nolrai> That makes sense, thanks!
00:09:37 <Nolrai> Anyway I need to check if what I am doing makes sense. Thanks for the help!
00:19:45 * hackage character-cases 0.1.0.5 - Exposes subspecies types of Char. And naming cases.  https://hackage.haskell.org/package/character-cases-0.1.0.5 (aiya000)
01:03:19 <Welkin> are there any good document databases that do not use json? Json is a terrible persistence format, being tied to the limitations of javascript, too.
01:04:28 <Welkin> I've run into no end of trouble trying to serialize my native types into "correct json" that the database will accept. The db is a broken piece of crap, though
01:04:57 <Welkin> I don't give two shits how the data is stored, just that it comes out in the same way I put it in.
01:05:33 <Welkin> https://msgpack.org/ looks promising, but I have no idea if I can use that natively with any database
01:05:42 <Welkin> of course, I could shove a string into any database
01:06:00 <Welkin> in the case of msgpack, a bytestring
02:52:50 <tt> How do you guys debug within a do block for ghci? 
02:54:48 <tt> For example, `foo :: Maybe String  foo = do      x <- Just 3      y <- Just "!"      Just (show x ++ y)`
02:55:20 <Nolrai> You can put breakpoints on individual lines.
02:55:24 <tt> if you want to see what value x holds. You would type x<- return $ Just 3 and log x
02:55:44 <tt> oh wow you can?
02:57:05 <merijn> tt: honestly, same way I do in C, lots of printing :p
02:57:08 <Nolrai> https://downloads.haskell.org/~ghc/7.6.3/docs/html/users_guide/ghci-debugger.html#setting-breakpoints
02:57:40 <tt> merijn can you give an example of how youd print .... Does it work for all types etc
02:57:55 <merijn> :t Debug.Trace.trace
02:57:57 <lambdabot> String -> a -> a
02:58:02 <merijn> @quote refreshing.desert
02:58:02 <lambdabot> chromatic says: My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency.
02:58:41 <Nolrai> But if your in IO 'print' works wonders.
02:58:44 <merijn> tt: The Debug.Trace module has a bunch of functions for, well, debug tracing :)
02:59:39 <merijn> tt: Basically wrappers around various print functions using unsafePerformIO, so, uh, don't rely on them for production code, but perfectly fine for debugging
03:01:01 <timCF> Hello! In GHC.Generics for which reason do we have `V1` type which represents void types without constructors? This value will never be created because it's impossible to create value without constructors anyway
03:01:39 <Nolrai> tt: Remember though that because of lazyness adding a trace can dramatically change when what happens.
03:02:53 <tt> Ahhh great. Thanks guys. merijn Nolrai. Will try it out. 
03:20:45 * hackage gamgee 1.2.1 - Tool for generating TOTP MFA tokens.  https://hackage.haskell.org/package/gamgee-1.2.1 (rkaippully)
03:38:41 <tomjaguarpaw> 'cabal v2-test' worked for me the first time I ran it.  Now I've just run it again (with no changes, AFAIK) and it says "Cannot test the package opaleye-0.6.7004.2 because none of the
03:38:50 <tomjaguarpaw> components are available to build:"  Anyone got any ideas what's gone wrong?
03:39:51 <tomjaguarpaw> [Taking its advice about cabal.project.local does indeed work, but I'm wondering why it did in the first place.  Perhaps because I've cabal v2-update'd since] 
03:40:49 <merijn> tomjaguarpaw: Can you try passing --enable-tests of adding "tests: True" in cabal.project?
03:41:18 <tomjaguarpaw> --enable-tests to what?  One used to do that to configure, but v2-configure doesn't do anything, does it?
03:42:10 <merijn> tomjaguarpaw: To "cabal v2-test"
03:42:27 <merijn> I have a hypothesis (TM)
03:42:50 <Welkin> apotheosis?
03:44:24 <tomjaguarpaw> merijn: Yes, that works
03:44:44 <tomjaguarpaw> --enable-tests seems like it ought to be a reduntant flag to v2-test!
03:45:09 <merijn> tomjaguarpaw: Yes and no, there's a reason for this behaviour, but the UX is a bit bad atm
03:45:29 <merijn> tomjaguarpaw: The problem is that the dependencies of tests might affect the dependencies of the main library
03:45:55 <merijn> tomjaguarpaw: So whether tests are enabled can (and sometimes does) result in different build plans, which in turn results in the library needing to be rebuild
03:46:14 * hackage smuggler2 0.3.2.2 - GHC Source Plugin that helps to minimise imports and generate explicit exports  https://hackage.haskell.org/package/smuggler2-0.3.2.2 (jrp)
03:46:22 <merijn> So then alternating between v2-build and v2-test ends up rebuilding everything each time you switch
03:46:23 <tomjaguarpaw> Oh, because the test may have more specific requriements than the labrary?
03:46:50 <merijn> tomjaguarpaw: To avoid this they default to "just use the previous plan", but then things don't work as expected when the previous plan didn't have tests enabled
03:46:55 <merijn> tomjaguarpaw: Yeah
03:47:36 <tomjaguarpaw> So to avoid rebuilding one could pass --enable-tests to both v2-build and v2-test (and it probably suffices to pass it just to the first one that you run)?
03:47:41 <merijn> tomjaguarpaw: If you include "tests: True" in cabal.project (or pass --enable-tests each time you call v2-build, but that's annoying) you always build with the test plan, even when not running tests. But then things just work
03:47:46 <merijn> tomjaguarpaw: Right
03:50:14 <merijn> tomjaguarpaw: This is a known "wart", but it's unclear what the best solution (or even just the best way to warn about it) is
03:51:18 <tomjaguarpaw> An error message that explains what you've just explained would be a good start!  I would also appreciate it if they mentioned the --enable-tests option because I have an aversion to persistent configuration
03:51:35 <merijn> tomjaguarpaw: Sure, but that requires having logic to detect the issue
03:52:05 <merijn> Which is not as easy as it sounds
03:52:09 <tomjaguarpaw> The issue was already detected.  I got an error message about adding "tests: True" to my cabal.config.
03:52:26 <tomjaguarpaw> I suggests they explain why that's necessary and also suggest --enable-tests
03:52:26 <merijn> Oh? Maybe that improved in newer versions
03:53:31 <merijn> tomjaguarpaw: Incidentally, v2-configure does to something
03:53:37 <MarcelineVQ> feel like that kind of flag belongs in cabal.project.local rather than a global config
03:53:53 <merijn> tomjaguarpaw: It creates a cabal.project.local file with the settings you passed to cabal v2-configure
03:54:08 <merijn> MarcelineVQ: I'd put it in cabal.project, but yeah, the global config is a weird place for it
03:54:58 <merijn> tomjaguarpaw: So "cabal v2-configure -w path/to/ghc --enable-tests" will create a cabal.project.local storing those settings
03:55:27 <maerwald> also note that all these things with cabal.project are unlikely to work when you do 'cabal v2-install'
03:57:52 <tomjaguarpaw> Sorry, I meant cabal.project.local, not cabal.config!
04:00:18 <tomjaguarpaw> merijn: Thanks for being my cabal oracle again!
04:03:34 <merijn> phadej: Is that data visible somewhere other than tiny twitter pictures? :)
04:04:30 <phadej> https://gist.github.com/phadej/4793535796a8801b0c95f1c85ebab43e
04:04:34 <phadej> DIY
04:04:44 * hackage gi-ibus 1.5.1 - IBus bindings  https://hackage.haskell.org/package/gi-ibus-1.5.1 (inaki)
04:05:33 <merijn> phadej: And that just running against a dump of all Hackage packages?
04:18:35 <polyphem> how can i prevent cabal from recompiling all dependencies again each time i switch between  normal and prof build ? 
04:18:45 * hackage depq 0.4.1.0 - Double-ended priority queues  https://hackage.haskell.org/package/depq-0.4.1.0 (ocramz)
04:19:20 <merijn> polyphem: It should only rebuild the local packages each time (i.e. the package(s) you're working on)
04:19:27 <polyphem> cant it keep two sets of compiled dependencies at the same time ? if so how to acticate ?
04:19:32 <merijn> polyphem: Or are you using git repo dependencies
04:19:46 <polyphem> nope
04:19:57 <merijn> polyphem: Which version of cabal-install?
04:20:02 <polyphem> 3.2
04:20:19 <merijn> Weird, it shouldn't do that (and doesn't here)
04:20:39 <polyphem> shall i paste my .cabal ?
04:20:56 <merijn> sure, the output of "cabal build" is probably useful too
04:22:14 <merijn> I've been regularly switching between profiled and non-profiled and given that I've somewhere upwards of 100 dependencies I'm pretty sure I would've noticed that :p
04:27:00 <timCF> Is this class exactly how `Show` deriving is working in Haskell? http://hackage.haskell.org/package/generic-deriving-1.13.1/docs/Generics-Deriving-Show.html
04:27:28 <merijn> Define "exactly" and "is"?
04:28:53 <timCF> I mean when I write `newtype Foo = Foo Int deriving (Show)` is this class used internally as show implementation for `Foo`?
04:29:48 <polyphem> merijn: here is my .cabal : https://pastebin.com/8ASLidhb
04:31:24 <polyphem> merijn: maybe because i changed profiling : from True to False in cabal.project.lokal ?
04:31:38 <polyphem> s/lokal/local/
04:33:34 <freeman42x[m]1> will running `cabal install hscolour` not make it available? eg. accessible as other packages in `ghc-pkg list`
04:33:39 <polyphem> and here is my cabal.project.local : https://pastebin.com/59KiTgv1
04:33:49 <merijn> polyphem: Was this only the first time you build profiling?
04:34:09 <polyphem> the rebuild ?
04:34:20 <merijn> yeah
04:35:05 <tomjaguarpaw> Does anyone here know how to get dante to deal with files in test suites correctly?  It only loads the packages that are defined for the main package I believe
04:35:27 <merijn> tomjaguarpaw: dante uses ghci, right?
04:35:58 <polyphem> i did normal first , then when i added profiling , it rebuild , even rebuilds if i do cabal new-run instead of cabal new-build , now i want to switch back to normal , nd it rebuilds normal
04:36:33 <merijn> rebuilds what, exactly? You initially said "all dependencies"
04:36:51 <polyphem> all dependencies , takes ~ 20 min :(
04:37:27 <merijn> That's weird. Can you show the output of running cabal build?
04:37:53 <polyphem> its running now , dont wanna stop it
04:39:16 <merijn> polyphem: It should only rebuild the dependencies twice (once for regular build and once for profiling) after that it shouldn't rebuild unless they change. The only exception is local dependencies (i.e. git repos or packages listed in cabal.project)
04:42:45 * hackage smoothie 0.4.2.11 - Smooth curves via several interpolation modes  https://hackage.haskell.org/package/smoothie-0.4.2.11 (DimitriSabadie)
04:50:24 <tomjaguarpaw> merijn: Yes, in the guise of cabal v2-repl, typically
04:50:52 <merijn> tomjaguarpaw: Then the answer is probably "you can't"
04:51:12 <merijn> tomjaguarpaw: One of the big editor tooling problems is that ghci doesn't support loading multiple components at the same time
04:51:27 <merijn> tomjaguarpaw: There's a Google Summer of Code project to work on that this year, though!
04:52:22 <tomjaguarpaw> Ah nice
04:52:56 <merijn> tomjaguarpaw: See also the summary of stuff going on here: https://mpickering.github.io/ide/posts/2020-05-08-state-of-haskell-ide.html
04:54:50 <tomjaguarpaw> Yes, I may hold my current dante usage patterns until ghcide is sufficiently compelling.
05:10:15 * hackage byte-count-reader 0.10.0.1 - Read strings describing a number of bytes like 2Kb and 0.5 MiB  https://hackage.haskell.org/package/byte-count-reader-0.10.0.1 (danielrolls)
05:33:21 <kuribas> In order to do type inference, you need to do kind inference as well right?
05:33:33 <kuribas> Does this mean you need to have kind variables?
05:35:07 <Cheery> Haskell just has * and (->) right?
05:35:15 <Maxdamantus> kuribas: if you're inferring "types", you're already inferring kinds.
05:35:49 <kuribas> Cheery: and DataKinds
05:35:57 <Maxdamantus> (I put "types" in scare quotes because it's really inference of type-level things, including `Maybe` which is not a type)
05:36:21 <kuribas> Maxdamantus: you mean that when you infer a type, you allready know the kinds?
05:36:57 <kuribas> What about (f x), it could have kind * or kind * -> *
05:37:07 <Maxdamantus> kuribas: yes. The kind of `Int` is `*` (aka `Type`). The kind of `Maybe` is `*` (aka `* -> *`). So by inferring the former, you know the latter.
05:37:21 <Maxdamantus> Any value term will have kind `*`.
05:37:39 <Maxdamantus> rather, will have a type-level thing of kind `*` (it is of a type).
05:37:56 <Maxdamantus> `f x` can never "be of type `Maybe`"
05:38:21 <Maxdamantus> > let f x = undefined :: Maybe in 4
05:38:23 <lambdabot>  error:
05:38:23 <lambdabot>      • Expecting one more argument to ‘Maybe’
05:38:23 <lambdabot>        Expected a type, but ‘Maybe’ has kind ‘* -> *’
05:38:37 <Maxdamantus> "expected a type"
05:38:54 <kuribas> ok, so then "data MyData f x = MyData (f x)" implies "(f x) :: *"
05:39:54 <Maxdamantus> Ah, that's not a value term.
05:40:33 <kuribas> however, what is f?
05:40:58 <kuribas> f is k -> * for some kind variable k?
05:41:37 <Maxdamantus> Actually, `f x :: *` is indeed required in that case.
05:42:12 <kuribas> but not f :: * -> *
05:42:13 <Maxdamantus> since the data constructor definition (`MyData (f x)`) requires the argument to be a type.
05:42:41 <Maxdamantus> Right. In theory `f` could be of some other kind, or even a polymorphic kind.
05:42:46 <phadej> kuribas: depends on your type-system whether you need kind-inferene
05:42:49 <kuribas> however if f and x are phantom types, then they kan be any kind right?
05:42:56 <phadej> e.g. in STLC there is only kind star
05:43:00 <Maxdamantus> but I think Haskell just decides that it should be `* -> *` by default because that's simplest or something.
05:43:24 <kuribas> phadej: and haskell?
05:44:07 <phadej> in Haskell98 you need to do kind inference, but it's very simple as "kind language" is akin to STLC, and you don't have anonymous "type level functions"
05:44:45 <Maxdamantus> 00:36:45 < Maxdamantus> kuribas: yes. The kind of `Int` is `*` (aka `Type`). The kind of `Maybe` is `*` (aka `* -> *`). So by inferring the former, you know the latter.
05:44:48 <Maxdamantus> Correction to my statement: meant to say "The kind of `Maybe` is `* -> *` (aka `Type -> Type`)"
05:44:52 <phadej> e.g. given a type signature :: (a -> b) -> f a -> f b  it's easy to deduce that a, b :: Type, and f :: Type -> Type
05:45:20 <kuribas> indeed
05:46:33 <phadej> in fact, given an expression `fmap g x`, you'll elaborate that into `fmap @f @a @b g x` but you'll now that `f :: Type -> Type`
05:46:38 <kuribas> phadej: but if theres a phantom type, it has unknown kind?
05:46:47 <phadej> in Haskell98? It's defaulted to Type
05:47:00 <kuribas> ah right
05:47:22 <kuribas> so other types, like DataKinds or kind variables have to be given explicitly?
05:47:33 <phadej> sso IIRC you only need to do any kind of kind inference only in data and type-class declarations
05:47:45 <kuribas> ah, indeed
05:48:19 <kuribas> I am not even sure my language will have data...  Maybe only newtypes...
05:48:21 <phadej> PolyKinds etc. makes it all complicated, but Richard have written recently a paper on it
05:48:53 <phadej> https://dl.acm.org/doi/pdf/10.1145/3371121?download=true
05:49:09 <kuribas> Richard is many?
05:49:42 <kuribas> ah Richard Eisenberg and others...
05:50:21 <kuribas> phadej: btw, I think I found a way to combine unbound-generics and unification-fd.
05:50:48 <kuribas> it required writing my data type using lots of type variables, and having transformations between different representation.
05:52:16 <phadej> yeah, types are always in your way :(
05:52:24 <kuribas> In particular abstracting Bind from unbound into a type variable b.
05:55:41 <kuribas> It makes me wonder if having a language without data would work.
05:56:02 <kuribas> where you create a new type just by adding a constraint on the type level.
05:56:12 <kuribas> then extending types would be easier.
05:58:11 <phadej> "structural type system", yes. See e.g. Dhall
05:58:29 <phadej> it doesn't have `data`, you just give names to anonymous records and variants
05:59:31 <phadej> whether it's good idea long term, I don't know
06:04:22 <timCF> As far as I understood, standard `Show` class is working with inefficient `String` type mostly because of historical reasons. Does it make sense to re-implement it in separate class which will have something like `newtype Renderer = Renderer (Text -> Text)` instead of `type ShowS = String -> String`?
06:05:59 <timCF> If I just replace `String` with `Text`, `++` with `<>` and will do similar adjustments - will it work better/faster/more memory efficient?
06:09:29 <justsomeguy> What do you guys think of something like darcs or pijul as opposed to git? Is it easier to create a clean history? Just curious.
06:12:06 <phadej> timCF: https://hackage.haskell.org/package/text-show-3.8.5/docs/TextShow.html, whether it's more performant, maybe.
06:12:22 <phadej> really depends whether you'll be able to notice
06:12:56 <phadej> (word of warning, don't use Show for anything externally visible)
06:13:22 <merijn> phadej: It's not
06:13:53 <merijn> I was looking into faster showing of data and one of the faster packages explicitly noted text-show is slower than even regular show
06:14:19 <phadej> using manually written or TH derived instances?
06:14:31 <merijn> Ah, that I didn't dive into further
06:14:59 <MarcelineVQ> @seen jyp
06:14:59 <lambdabot> jyp
06:14:59 <phadej> (Generics derived instances are for sure slower than `deriving (Show`))
06:15:04 <MarcelineVQ> ..
06:15:11 <MarcelineVQ> @botsnack
06:15:11 <lambdabot> :)
06:15:14 <merijn> MarcelineVQ: There is no @seen command
06:15:25 <MarcelineVQ> only zule
06:15:39 <merijn> mauke's bot used to have it, but I dunno what happened to mauke or his bot
06:15:46 <timCF> merijn and did you found something interesting which is faster than standard Show?
06:16:11 <merijn> Manually building Text using Builder :p
06:16:44 <phadej> well, that's the interface text-show gives you...
06:17:05 <phadej> showbPrec :: Int -> a -> Builder
06:20:04 <merijn> phadej: Yeah, but it goes via the existing Show instances, I think?
06:20:14 <phadej> no
06:20:26 <phadej> that won't make any sense
06:20:34 <merijn> ok, maybe I'm thinking of a different package then
07:02:14 * hackage language-tl 0.1.0 -   https://hackage.haskell.org/package/language-tl-0.1.0 (Poscat)
07:37:57 <Johnhs> :-*
07:49:36 <fog> I have a transfer matrix for a state update process, and I want to store it approximately 
07:50:14 <fog> I was thinking that truncating the ordered eigenvalues of the diagonal matrix of a LDU decomposition would work
07:51:11 <fog> what avenues for linear algebra do we have in haskell? are there ways that avoid using the fortran or c bindings for blas
07:52:05 <xerox_> fog: if you search linear algebra on hackage you find plenty, blas and lapack as well
07:52:28 <fog> but those are ffi?
07:53:18 <fog> i need to get at the implementation to switch the datatype it uses for a representation of tensors im building
07:54:16 <fog> repa and HMatrix versions could be workable, except some of the high performance techniques sometimes obscure the algorithm 
07:57:02 <fog> ah, i think what i need is reffered to as the "compact svd", in the section of the wiki before the contents; https://en.wikipedia.org/wiki/Singular_value_decomposition
07:57:19 <fog> but where the smallest eigenvalues have been set to 0
07:58:53 <fog> basically it get the input matrix, and factorises it into 3, where the middle matrix is diagonal and small
07:59:22 <fog> im not sure if this would take less storage space, since its 3 matricies instead of 1
07:59:50 <fog> m*m -> (m*r) + (r*r) + (r*m)
08:01:21 <fog> > (\ m r -> (m*m , (m*r) + (r*r) + (r*m))) 3 2
08:01:23 <lambdabot>  (9,16)
08:01:28 <fog> > (\ m r -> (m*m , (m*r) + (r*r) + (r*m))) 10 2
08:01:30 <lambdabot>  (100,44)
08:01:44 <fog> so for matricies large enough, this is a good compression scheme
08:02:17 <fog> (\ m r -> (m*m , (m*r) + (r*r) + (r*m))) 10 4
08:02:22 <fog> > (\ m r -> (m*m , (m*r) + (r*r) + (r*m))) 10 4
08:02:25 <lambdabot>  (100,96)
08:03:07 <fog> actually requires quite a heavy compression though, setting discarding 6/10 of the eigenvalues is pretty extreme 
08:03:14 <[exa]> fog: 2020 solution: train a neural network that approximates the matrix and send the network! :]
08:03:35 <fog> yeah, but also, do the SVD
08:03:49 <fog> these matricies are supposed to be compressing the neural update functions
08:04:03 <[exa]> oh okay
08:04:21 <fog> if your not truncating eigenvalues, then your network has no math power!
08:04:41 <fog> basically the SVD is an autoencoder
08:04:58 <fog> and the small diagonal central matrix is like the bottleneck where the "features" are
08:05:18 <[exa]> yeah I understand that
08:05:39 <[exa]> by 'update matrix' you mean some fresh data for training, or actual neuron weights?
08:05:51 <fog> well, there are a bunch of places
08:05:59 <fog> anywhere anything is unfolded
08:06:15 * hackage language-puppet 1.4.6.4 - Tools to parse and evaluate the Puppet DSL.  https://hackage.haskell.org/package/language-puppet-1.4.6.4 (SimonMarechal)
08:06:15 <fog> my network is a deep hidden markov model
08:06:28 <fog> so each layer down has an evolving internal state
08:06:51 <fog> these states themselves are being measured to return the inputs to the next layers up transfer matrix
08:07:36 <fog> if the states are networks, then the state update process is learning, and the deeper layers are hyperparameter evolutions
08:08:03 <[exa]> btw what about doing some kind of jpeg trick for a bit less intensive solution? DFT/DCTing small patches is fast, and you will just receive another "approximate compression"
08:08:29 <fog> well, normally you would go gabor on that
08:08:44 <fog> you mean the short time fourier transform, its a primative wavelet
08:08:52 <fog> so for that, its dictionary learning
08:09:09 <fog> you have atoms, which are eg. gausina windowed fourier segments
08:09:30 <fog> (btw, you need the gausian window to avoid edge effects on your short patches of dft)
08:09:51 <fog> then you could get a chirplet frame for the dictionary by hving linearly varing frequencies
08:10:05 <[exa]> or you just randomly mix the data to obfuscate the edges?
08:10:10 <catern> hmm if you were going to teach new programmers, and you wanted to teach them richly typed pure higher-order programming right off the bat, and you didn't care about being weird or using mainstream stuff... is there a simple language that has that rich typing? something like simple lisp, but typed. haskell has lots of stuff in it... 
08:10:52 <fog> [exa] the point is that we seek a sparse projection onto basis vectors still
08:11:19 <fog> even when doing what you described, it still fits into the model of compressed sensing
08:11:47 <fog> instead of setting the eigenvalues of the diagonal matrix to 0, your setting most of the huge frame of atoms to 0
08:12:05 <fog> at any time you might only need like a few 100 of these windowed fourier sections
08:12:07 <[exa]> catern: "simple lisp but typed" might match some of the *ML languages
08:12:52 <[exa]> fog: ok well your problem seems a bit too convolved for a quick advice :]
08:12:54 <cocreature> catern: SML but be prepared to have your students respond with “why am I learning this if nobody is using it”
08:13:07 <fog> aaand, each of these can be "recorded onto a tape" and "played back" as a state evolution process!
08:13:20 <catern> [exa]: cocreature: that's funny, I was thinking SML already
08:13:22 <cocreature> you will still get that for Haskell but if you go even less “mainstream” it starts to become more and more prevalent
08:13:24 <catern> i guess CMU was right :)
08:14:00 <fog> basically, the learning ends up with a bunch of recorded tapes, which are learned, and are the best linear basis decomposition
08:14:11 <[exa]> catern: still I'd go for Haskell and pretend that it's intuitive and basic
08:14:20 <fog> i have a deep net to do this in a way like a covnet, building up "larger feartures" 
08:14:31 <cocreature> I think it’s the right choice if you do want to go for the simplest option. Whether going for the simplest option over something that has significantly more of an ecosystem and real world usage is a separate question
08:14:49 <fog> so to be able to do blind source separation based on the statistics of the separate processes 
08:15:28 <fog> the different states at each node are called the fenoneme decomposition
08:18:54 <fog> https://core.ac.uk/download/pdf/22876656.pdf
08:21:54 <fog> thats "senones", which is one symbol per "state" of the hidden model. i think its a nice idea, just to confirm this notion fitting in with the state evolution framework
08:22:34 <fog> but, the original "fenone" to which it refers totally similar, and by Robert Mercer @ IBM, so seems much more legit 
08:23:40 <fog> the problem is that these are probabilistic representations
08:24:15 <fog> if we want a deterministic transfer matrix, such as to be learned as a net, then there is a different setup;
08:25:53 <fog> https://www.researchgate.net/profile/Richard_Povinelli/publication/4014994_Speech_recognition_using_reconstructed_phase_space_features/links/56ddacf608aed4e2a99c5842.pdf
08:26:14 <fog> there is a nice diagram there of a chaotic attractor, which is the phonetic trajectory
08:26:23 <fog> its obtained via svd
08:27:54 <fog> nope, wrong paper, svd is here;
08:27:55 <fog> http://povinelli.eece.mu.edu/publications/papers/icassp2003b.pdf
08:28:08 <fog> PERFORMANCE OF NONLINEAR SPEECH ENHANCEMENT USING PHASE SPACE RECONSTRUCTION 
08:28:28 <fog> basically, they truncate the "noise" eigenvalues away
08:31:03 <shapr> Has anyone seen a servant webapp with hint ? I'm looking to add a django style repl to my servant app.
08:32:02 <fog> oh wow, thats really wierd, they dont truncate the transfer matrix, they just take a convolutional buffer which makes a matrix after n timesteps, and they SVD that!! ok idk anymore
08:34:58 <Cheery> "Preparing to install GHC to an isolated location."
08:35:24 <Cheery> stack keeps doing that and downolads ghc-8.83 over again when I start something
08:35:51 <Cheery> no way to tell it "hey it's here, don't download it again"
08:38:31 <Cheery> https://stackoverflow.com/questions/53385640/how-to-prevent-stack-from-downloading-ghc-for-every-new-project
08:39:24 <shapr> Cheery: is ghcup an option for you?
08:39:24 <fog> i guess the attractor for a component vowel sound becomes chaotic upon forcing by the hidden layer, and that the original would be periodic
08:39:48 <shapr> fog: would you like to monologue in #haskell-overflow ?
08:40:27 <fog> which means the "tapes" of theses hidden states would be circular, but that there is an underlying state evolution transfer process to be learned
08:40:35 <fog> shapr: sorry, i go now
08:40:47 <shapr> it really was a polite request
08:40:58 <shapr> just sayin like, this channel is more for interactive question and answer
08:44:57 <Cheery> shapr: seems like it downloads more ghc. dunno.
08:45:43 <shapr> Cheery: I've not had ghcup download a version more than once
08:51:25 <c_wraith> ghcup doesn't prevent stack from downloading more ghcs.  You have to also *not use stack*
09:06:54 <monochrom> :)
09:08:29 <Cheery> all the frustration experienced in other languages seem to pack into cabal
09:09:58 <c_wraith> a lot of people complain about problems cabal fixed 10 years ago
09:12:16 <monochrom> haha a stack question on stackoverflow
09:29:08 <fresheyeball> asking about hie in the haskell-ide-engine channel
09:34:15 <Cheery> wow.. I'm actually using somebody else's libraries now.
09:34:43 <Cheery> installed direct-sqlite and fltkhs
09:38:45 * hackage reflex-test-host 0.1.2.0 - reflex host methods for testing without external events  https://hackage.haskell.org/package/reflex-test-host-0.1.2.0 (pdlla)
09:39:54 <dsal> sqlite-simple is pretty nice
09:40:08 <xerox_> dsal: yes?
09:40:40 <dsal> Cheery just mentioned direct-sqlite.  sqlite-simple is built on it and provides a good interface.
09:41:45 * hackage reflex-test-host 0.1.2.1 - reflex host methods for testing without external events  https://hackage.haskell.org/package/reflex-test-host-0.1.2.1 (pdlla)
09:44:14 <ezzieyguywuf> I'm relying pretty heavily on Learn You a Haskell For Great Good - it's my go-to reference. Are there any glaring misconceptions or blindspots that I should be aware of in using this as a reference?
09:45:41 <infinity0> is `f $> error "unreachable"` acceptable style for fmapping something to Void ?
09:45:45 <dsal> ezzieyguywuf: I only ever hear bad things about it.
09:45:47 <infinity0> obv i can't pass an instance of Void itself
09:46:06 <dsal> :t absurd
09:46:08 <lambdabot> Void -> a
09:46:15 <ezzieyguywuf> dang
09:46:20 <c_wraith> as a reference, not really.  I think the sections on functor/applicative/monad are a bit weak, but they're certainly not wrong.  I think the only real problems with it are when you try to use it as a primary resource - it lacks any kind of exercises, which lets people forget everything as fast as they read it.
09:46:25 <ezzieyguywuf> dsal: can you suggest any oter reference?
09:46:48 <ezzieyguywuf> well, as far as excercises, I'm just trying to write a library in haskell
09:46:49 <dsal> ezzieyguywuf: personally, I like haskellbook.com, but there are others I've not read that get good reviews.
09:47:00 <infinity0> ah right, <$> absurd, great thanks
09:47:01 <ezzieyguywuf> I'v read through LYAH and a good part of real world askell
09:47:40 <dsal> haskellbook.com walks you through a world where only basic stuff exists and you get to discover/build functors, applicatives, monads, foldable, traversable, etc... yourself.
09:47:59 <ezzieyguywuf> dsal: that sounds real nice. but I don't want to pay $60 for it :-P
09:48:29 <dsal> I don't buy a lot of books, but when I do, they're usually worth it.  :)
09:48:56 <c_wraith> LYAH isn't going to guide you the wrong direction.  the complaints about it are all of the form "When I finished it, I discovered I didn't remember any of it"
09:49:40 <ezzieyguywuf> c_wraith: well that's a relief
09:49:43 <ezzieyguywuf> I felt that way too
09:49:52 <ezzieyguywuf> but I keep going back and re-reading bits and pieces and picking up more and more
09:50:07 <ezzieyguywuf> and as I step away from reading into doing, I find when I come back things make more sense
09:50:40 <c_wraith> in that case, it's fine for you.  Just remember that haddocks exist too. :)
09:50:57 <shapr> what's the most popular CI for haskell github projects? I've heard of travis, circle, and jenkins
09:51:22 <dsal> The approach HPFFP takes leads you to a point where you're like, "Man, I really wish I had a way to do..." and then you realize it's called applicative and you don't have to like, try to understand it, but you already wanted it.
09:51:24 <dsal> shapr: I just use github
09:51:39 <shapr> dsal: so, github actions?
09:51:45 <dsal> Yeah: https://github.com/dustin/mqttd/actions
09:51:55 <ezzieyguywuf> i use gitlab
09:52:04 <infinity0> ah, absurd doesn't work for me, because i have a `f notVoid` to create *into* a `f Void`, i'm doing something like \case BranchToVoid -> something else; x -> absurd <$> x, but this fails to type check because it doesn't realise i've gone past the "BranchToVoid" part...
09:52:07 <dsal> Though I do wish for an AARCH64 builder.
09:54:14 <scasc> anyone using taskell?
09:54:25 <infinity0> i suppose wha
09:54:28 <dsal> ezzieyguywuf: I'm github user #1779. heh
09:54:35 <infinity0> ..t i need is something like `f a -> Either a (f Void)`
09:55:23 <dsal> :t vacuous -- that's a hard word to spell
09:55:25 <lambdabot> Functor f => f Void -> f a
09:55:36 <dsal> They're all going the other direction.
09:55:59 <infinity0> yeah :(
09:56:12 <dsal> It looks like you're trying to have a Void, but you can't.
09:56:41 <infinity0> i'm not trying to have a void, i'm saying if my functor contains a value, produce it, or type-safely convert it into a functor of Void
09:56:50 <infinity0> like, [] :: [Void] is fine
09:57:15 <infinity0> i can write this my hand but it's tedious when your ADT has lots of branches
09:57:29 <infinity0> i suppose DeriveFunctor doesn't derive enough utils to implement this automatically..
09:58:13 <dsal> What does it mean to not have a value/
09:59:29 <infinity0> the empty list doesn't have a value
09:59:41 <infinity0> it's fairly straightforward no?
09:59:45 * hackage imm 1.10.0.0 - Execute arbitrary callbacks for each element of RSS/Atom feeds  https://hackage.haskell.org/package/imm-1.10.0.0 (koral)
10:01:09 <infinity0> `if null f then Right (f $> error "unreachable") else Left $ head $ toList f` will do what i want in a general way, and it's totally safe, but the use of partial functions "looks" unsafe
10:04:10 <monochrom> haha, the term level "this container is empty" vs the semantic level "this type is empty"
10:04:29 <monochrom> Vanity of vanity, all is vanity.
10:08:27 <solonarv> infinity0: is your type also a Contravariant? (it should be) - if yes, 'contramap absurd'
10:09:45 <solonarv> well, "it should be" if you want to be able to rely on the typechecker's help against bottoms
10:10:19 <infinity0> hm, my type is just a dumb ADT, similar to a list. i don't see an instance of contravariant for [a] either
10:10:54 <solonarv> essentially a type that's both Functor and Contravariant is "always empty", i.e. can't actually mention any values of its type parameter
10:11:08 <solonarv> I was scrolle dup when I typed that so I didn't see the details you've now given
10:18:22 <kuribas> phadej: these libraries seem quite hard to use.  For example, how could zipMatch unify "forall a. a -> a" and "int -> int"?
10:18:49 <kuribas> phadej: I'd need to create fresh variable bindings for the a, but the zipMatch type doesn't allow for it.
10:19:22 <mrus> what's the ^ used for in Haskell?
10:19:29 <phadej> kuribas: you cannot. And neither does GHC
10:19:39 <phadej> unification variables are always mono-types
10:19:54 <kuribas> phadej: so it removes the foralls before checking?
10:20:22 <solonarv> mrus: just exponentiation, nothing else that I can think of (currently)
10:20:29 <solonarv> > 3 ^ 4
10:20:29 <phadej> yes, i suggest looking into https://www.youtube.com/watch?v=ZuNMo136QqI
10:20:31 <lambdabot>  81
10:20:34 <phadej> it explains how GHC does stuff
10:21:01 <mrus> solonarv: just browings some sources and stumbled upon things like: let lastmsg_ = chan^.ccContents.cdMessages.to reverseMessages.to lastMsg
10:21:14 <phadej> if you have polymorphic types then unifiying types is not enough, you have to elaborate type applications
10:21:25 <phadej> which is something I cannot explain on IRC
10:21:57 <phadej> mrus: 
10:21:59 <phadej> :t (^.)
10:22:00 <lambdabot> s -> Getting a s a -> a
10:22:14 <phadej> welcome to lens-land.
10:22:45 <solonarv> mrus: ah, don't get confused. there is no ^ there, there's a ^. which is a completely different identifier
10:22:53 <solonarv> much like 'f' and 'foo' are completely unrelated variable names.
10:23:02 <wikiemol> Hello all! I am using a "nondeterministic state" monad (essentially StateT a []) which iterates on a (basically each iteration sends a -> [a]). I want to parallelize this process. I would like some way to, "every once in a while" (where "every once in a while" is as of yet undefined) put the next batch of computations on separate threads. Since the
10:23:03 <wikiemol> branches of this ND compuation will often be created and deleted, I would like to be able to use a threadpool to reduce the spawning of new threads. Is there an easy way to do this in Haskell? 
10:23:13 <mrus> ah! thanks
10:23:22 <mrus> then I'll look that up now :)
10:23:51 <kuribas> phadej: heh, and here I though adding forall wasn't hard...
10:23:58 <kuribas> seems I was wrong
10:24:12 <phadej> kuribas: HM-forall is simple, if you don't generalize lets
10:24:22 <phadej> i.e. never infer polymorphic types
10:24:30 <kuribas> I don't...
10:24:53 <dolio> If you don't generalize lets, it's not Hindley-Milner.
10:25:23 <phadej> then when you are traversing AST and see an application node (App f x), and lookup the type of `f`, if it has polytype, you generate new type variable sthere (i.e. make it f @a @b @c... x)
10:25:35 <phadej> if you don't know (i.e. the type is itself a metavariable), you do nothing
10:25:44 <kuribas> > let id x = x in (id 3, id "3") --dolio
10:25:46 <lambdabot>  (3,"3")
10:25:53 <kuribas> hmm
10:25:56 <phadej> that generalize let
10:26:00 <kuribas> indeed
10:26:11 <phadej> you either should give a type signature, or accept that *it's hard to make*
10:26:17 <phadej> there's paper by SPJ about that too
10:26:25 <phadej> https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/tldi10-vytiniotis.pdf
10:26:46 <phadej> especially when you start to extend the type-system (as you do), it will start to hurt
10:27:52 <kuribas> phadej: I have no problem with requiring an explicit type signature for generalized lets
10:28:16 <phadej> then, let id :: forall a. a -> a in (id 3, id "3") -- would work
10:28:29 <phadej> with ; id x = x in between 
10:29:42 <kuribas> right.
10:29:56 <kuribas> And I can do the forall elimination before passing it to the unifier
10:30:08 <phadej> (becuase when you are looking at AT node of (id 3) or (id "3") you know to generate a fresh metavariable for each
10:30:46 <phadej> yes, unifier would unify only mono-types
10:31:21 <phadej> or rather, metavariables will contain only mono-types
10:31:28 <phadej> unifier might still need to work with poly-types
10:31:37 <phadej> so you can unify `forall a. a -> a` with `forall b. b -> b`
10:31:53 <phadej> but all instantiations are already made
10:32:48 <kuribas> phadej: what if you stage typechecking, so that lets are inferred first?
10:32:49 <phadej> but with HM-like language I don't think you will
10:33:18 <phadej> kuribas: doesn't work. If `let` expression is closed, then you can infer and generalise it (that what GHC does, read the paper!)
10:33:23 <phadej> but in general, you cannot.
10:33:43 <phadej> foo x = let f y = x + y in f x x
10:33:53 <phadej> :t \x -> let f y = x + y in f x x
10:33:54 <lambdabot> error:
10:33:54 <lambdabot>     • Occurs check: cannot construct the infinite type: t ~ t -> t1
10:33:54 <lambdabot>     • In the second argument of ‘f’, namely ‘x’
10:33:58 <phadej> :t \x -> let f y = x + y in f x
10:34:00 <lambdabot> Num a => a -> a
10:34:12 <phadej> think what's the type of `f` there
10:35:08 <phadej> : \x -> let f y = x ++ show y in (f "foo", f True)
10:35:13 <phadej> :t \x -> let f y = x ++ show y in (f "foo", f True)
10:35:14 <lambdabot> error:
10:35:14 <lambdabot>     • Couldn't match expected type ‘[Char]’ with actual type ‘Bool’
10:35:14 <lambdabot>     • In the first argument of ‘f’, namely ‘True’
10:35:34 <phadej> :t \x -> let f :: Show a => a -> String; f y = x ++ show y in (f "foo", f True)
10:35:35 <lambdabot> [Char] -> (String, String)
10:36:08 <phadej> looks like MonoLocalBinds is enabled in lambdabot :)
10:37:34 <phadej> (fwit, "read the paper" means that read through first sections, you'll get the idea - if needed you can look at the rest later)
10:37:48 <phadej> i.e. don't need to read or understand them in full.
10:38:06 <kuribas> okay
10:38:30 <kuribas> I think it will be easiest to require signatures for polymophic lets in my language
10:40:11 <kuribas> phadej: wait, but lets are generic in haskell still?
10:40:54 <phadej> generic?
10:41:10 <phadej> you mean whether they are generalized?
10:41:23 <phadej> depends. By default yes, if you enable e.g. GADTs which imply MonoLocalBinds than no
10:41:51 <kuribas> ah right
11:00:45 * hackage calamity 0.1.11.1 - A library for writing discord bots  https://hackage.haskell.org/package/calamity-0.1.11.1 (nitros12)
11:07:50 <berndl> Is there a "best practice" way of defining global mutable variables?
11:08:15 <xerox_> berndl: "don't"
11:08:30 <berndl> I would, but I need one.
11:08:47 <maerwald> IORef with NOINLINE
11:09:09 <berndl> Yeah, I've seen IORef used for that purpose. But is it thread safe?
11:10:57 <solonarv> yes if you unsafePerformIO
11:11:06 <solonarv> uh, let me clarify
11:11:15 <solonarv> there are two possible meanings of "thread safe" here
11:11:21 <maerwald> unsafePerformIO $ newTVarIO foo -- should work two
11:11:29 <solonarv> yep
11:11:50 <xerox_> «IO version of newTVar. This is useful for creating top-level TVars using unsafePerformIO, because using atomically inside unsafePerformIO isn't possible.»
11:11:54 <xerox_> the more you know!
11:12:04 <solonarv> generally speaking if you have a top-level 'foo = unsafePerformIO act; {-# NOINLINE foo #-}' then 'act' will indeed only get run once
11:12:47 <berndl> What happens without the NOINLINE?
11:12:53 <maerwald> dragons
11:13:13 <xerox_> 🐉
11:13:16 <solonarv> then 'foo' might get inlined (and probably will), so you end up creating new IORefs all the time
11:13:23 <solonarv> rather than sharing a global one like you intended
11:13:58 <maerwald> I've been told the archmage of Eval-city has an erratic character
11:21:51 <berndl> In case you're wondering why I need a global mutable variable, I'm implementing a PRNG.
11:22:52 <berndl> By the way, theStdGen from System.Random doesn't use NOINLINE
11:23:38 <merijn> berndl: It's also a shit stdgen so I doubt that'll have noticeable effect :p
11:24:44 <berndl> Indeed. But I think it's the one almost everybody uses,  no?
11:25:14 <merijn> mwc-random is more common for people who actually care about things like "quality of randomness"
11:25:36 <merijn> Or even FFI-ing to PCG, which is what I'm doing right now :p
11:27:18 <berndl> I've been doing some research on this and it seems that in most langauges, the PRNGs that come with them not that good.
11:27:24 <berndl> I wonder why that is.
11:30:52 <xerox_> berndl: in which languages did you find this to be the case?
11:31:36 <berndl> Haskell, C, C++, PHP, Java, C#, MatLab
11:31:48 <berndl> Python's another one.
11:32:35 <merijn> berndl: C++'s is fine-ish
11:32:41 <merijn> Mersenne Twister isn't that bad
11:32:42 <xerox_> I don't want to stray the discussion too far from Haskell for long but how does the C++ ones fail? I thought you get mersenne twister and maybe even others
11:33:18 <merijn> Straying far from Haskell is a time honoured #haskell tradition!
11:33:37 <xerox_> ^_^
11:35:46 <berndl> xerox_: If I remember correctly, problems occur when doing concurrent/parallel program. For example, say you spawn 10k threads and each of them needs to generate random numbers.
11:36:32 <berndl> If it's a state-based generator, it's going to block on every thread that needs a random number.
11:37:45 * hackage ghc-lib-parser-ex 8.10.0.12 - Algorithms on GHC parse trees  https://hackage.haskell.org/package/ghc-lib-parser-ex-8.10.0.12 (shayne_fletcher)
11:38:35 <xerox_> is 10k meant to mean it's infeasible to give each a thread-local generator?
11:41:47 <berndl> Actually, the problem is not the generator, but rather seeding the generator. You typically don't have access to 10k sources of entropy for each thread.
11:42:07 <wavemode_> C++ has a variety of PRNG engines in <random> (introduced in C++11) with different characteristics depending on what you need. if you're just using rand() from <cstdlib> though, it tends to be shit
11:44:42 <merijn> berndl: You create a generator object explicitly and then use different random operations on that
11:45:26 <berndl> wavemode_: This one seems to be pretty good: https://en.wikipedia.org/wiki/Xoroshiro128%2B
11:45:30 <merijn> berndl: So if you have 10k threads using the same PRNG you're already hosed anyway. Not to mention that anything beyond ~100 threads is doomed in C++ anyway due to lack of greenthreading
11:48:55 <kuribas> phadej: then how are top-level functions resolved?
11:49:42 <kuribas> phadej: isn't that like a big let?
11:50:45 * hackage language-puppet 1.4.6.5 - Tools to parse and evaluate the Puppet DSL.  https://hackage.haskell.org/package/language-puppet-1.4.6.5 (SimonMarechal)
11:58:17 <ezzieyguywuf> how do you read the <*> operator? "applicate"?
11:58:45 * hackage ghc-lib-parser-ex 8.10.0.12.1 - Algorithms on GHC parse trees  https://hackage.haskell.org/package/ghc-lib-parser-ex-8.10.0.12.1 (shayne_fletcher)
11:58:58 <kuribas> applyNext?
11:59:06 <kuribas> I never thought about it
11:59:38 <ezzieyguywuf> hah, "applyNext" sounds more right than "applicate"
11:59:42 <ezzieyguywuf> but "applicate" is fun ^_^
11:59:42 <xerox_> berndl: https://www.pcg-random.org/posts/xoshiro-repeat-flaws.html
12:00:03 <Cheery> > (,) <$> [1,2] <*> [3,4]
12:00:04 <lambdabot>  [(1,3),(1,4),(2,3),(2,4)]
12:00:22 <Cheery> it's like 'apply' but inside monad.
12:00:44 <kuribas> inside *applicative*
12:01:16 <ezzieyguywuf> yikes, I'm still learning applicative and monad, and I got confused by cheery's comment
12:01:19 <merijn> ezzieyguywuf: Honestly, I just don't read it
12:01:26 <ezzieyguywuf> although, a monad is (supposed to be) an applicative right?
12:01:48 <ezzieyguywuf> merijn: you must read it somehow when you come across it, right? like, in your brain, it turns into something
12:02:07 <merijn> ezzieyguywuf: Applicative gives you a subset of the functionality that Monad does, so everything that is a Monad is also an Applicative
12:02:38 <ezzieyguywuf> I'm getting confused by this: "This becomes even more handy and apparent if we consider the fact that pure f <*> x equals fmap f x"
12:02:39 <merijn> ezzieyguywuf: "f <$> foo <*> bar" is just "f foo bar" "with some sort of applicative context"
12:03:04 <ezzieyguywuf> that does make sense
12:03:49 <merijn> fmap is a "structure preserving map" so it can't affect the 'f' part of the functor (this is implied by the "fmap id x == x" law)
12:04:31 <merijn> ezzieyguywuf: What that comment is saying is that "pure" doesn't introduce any additional "structure".
12:04:54 <ezzieyguywuf> `pure f` takes the function `f` and puts it in a 'context', let's say `c`. so `pure f = c f`. fmap takes a function and applies it to a context....well here's where I'm stumbling
12:04:57 <ezzieyguywuf> the x is tripping me up
12:05:38 <ezzieyguywuf> ahhhh
12:05:40 <ezzieyguywuf> you know what
12:05:41 <berndl> xerox_: Interesting.
12:05:44 <merijn> ezzieyguywuf: Let's say "f :: Int -> Bool"
12:05:46 <ezzieyguywuf> i crossed my eyes a littel, I get it now
12:05:58 <merijn> ezzieyguywuf: Then "pure f :: Applicative f => f (Int -> Bool)"
12:06:11 <ezzieyguywuf> merijn: yes I follow
12:06:13 <merijn> ezzieyguywuf: While "fmap" already applies the function to something
12:07:33 <ezzieyguywuf> merijn: are 'f' to the left and right of :: different things? I'm pretty sure they are, but thought I'd check....
12:07:39 <merijn> Yes
12:07:43 <ezzieyguywuf> huzzah!
12:07:52 <merijn> Consider the case of Maybe
12:07:57 <ezzieyguywuf> "pure f :: Applicative g => g (Int -> Bool)" is the same, yea?
12:08:05 <merijn> "fmap :: (a -> b) -> Maybe a -> Maybe b"
12:08:11 <merijn> "pure :: a -> Maybe a"
12:08:25 <merijn> "(<*>) :: Maybe (a -> b) -> Maybe a -> Maybe b"
12:08:31 <merijn> ezzieyguywuf: Yeah
12:10:07 <ezzieyguywuf> "fmap (+ 1) Maybe Int :: May int", "pure (+1) <*> Maybe Int :: ....Maybe Int"
12:10:11 <ezzieyguywuf> yea, I think I'm starting to get it
12:11:46 <merijn> ezzieyguywuf: Which is also why you quickly just not read <$> and <*> (and why it's nice that they're operators). The *really* important thing is "applying a 'f' to some arguments" you're trying to sort "gloss over" the extra boilerplatey stuff. So in case of Maybe you mostly care about applying the function and "handling Nothing" is the boring boiler plate you don't wanna think about (but still need)
12:12:25 <ezzieyguywuf> hrm hrm hrm, very interesting
12:13:17 <ezzieyguywuf> I was pondering monads over breakfast and found myself wanting to draw a comparison to a class in OOP, i.e. because `return` (or pure, w/e) is like a constructor and >>= is like a method. but then I realized that was probably pretty dumb.
12:14:06 <berndl> Isn't there an abstraction for "applying an 'f' to some arguments" of which $, <$>, <*>, etc. are instances?
12:15:14 <merijn> ezzieyguywuf: The "problem" with math-y abstractions is that the definitions (and laws) are "all there is". The Monad interface is convenient because it pops up in tons of places, but there's no real "true monad abstraction" too learn. You just got learn each implementation independently and overtime you learn to gloss over and see how they embody the same interface in different ways
12:15:50 <merijn> ezzieyguywuf: Incidentally, Wadler's paper introducing monads for functional programming is a very readable paper and I wish people would skip it less
12:16:09 <ezzieyguywuf> merijn: this is the third time I've come across the name wadler is, like, 4 hours
12:16:16 <ezzieyguywuf> I should probably check him/that paper out
12:16:23 <ezzieyguywuf> s/is,/in,/
12:16:32 <merijn> Because it basically shows 4 different things, then shows how the same pattern accross all four and then shows how Monad lets you reuse it
12:16:40 <merijn> ezzieyguywuf: https://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf
12:19:42 <ezzieyguywuf> merijn: I'm two paragraps in, seems very approachable
12:19:54 <ezzieyguywuf> I tend to avoid pdf's because I assume they're dense and hard to understand :-P
12:20:54 <ezzieyguywuf> except now my son is awake, so I must tear myself away
12:20:56 <merijn> ezzieyguywuf: Everyone assumes that, often unnecessarily so :)
12:21:07 <merijn> (Sometimes rightfully too... :p)
12:21:09 <koz_> ezzieyguywuf: Yeah, we have several people in Haskell-land who write _very_ approachable papers.
12:21:14 <hpc> mostly i avoid pdfs because of the two column layout
12:21:18 <koz_> (SPJ is the one that comes to my mind)
12:21:43 <merijn> koz_: You do realise the conference/journal dictates the layout, not the author?
12:21:55 <koz_> merijn: What's that got to do with my comments, rofl?
12:21:59 <hpc> i could be reading the most heinous abstract nonsense ever put to a hard drive, and if it's in a single column i am more likely to be able to follow it than if they had better editing
12:22:13 <merijn> koz_: Oh, wait that was hpc
12:22:17 <merijn> koz_: Reading is hard!
12:22:22 <koz_> I KNOW RIGHT :P
12:22:24 <hpc> merijn: i know
12:22:41 <hpc> it's pretty much unavoidable, two columns is such an entrenched standard
12:22:54 <hpc> a hundred years old, at least
12:24:28 <merijn> Also best standard, because I get more space to write!
12:24:41 <merijn> LLNCS is the *worst* format ever :(
12:27:02 <berndl> The two-column format has never bothered me. What really bothers me is the type-setting of the code.
12:27:49 <koz_> berndl: You mean the standard literate Haskell one?
12:27:53 <koz_> Yeah, it's... a little not good.
12:28:15 <berndl> Most paper either use Courier (which makes my eyes bleed) or italic math (which looks terrible).
12:28:16 <hpc> if i could get a program that takes a pdf, cuts the pages in half, and rearranges them, that would be ideal for me
12:33:37 <Cheery> I'm looking at a paper that says data Sequence a = End a | Next (Sequence a) is a monad
12:33:48 <Cheery> but what's the applicative instance for this?
12:34:23 <koz_> Cheery: This is basically (Natural, a).
12:35:08 <Cheery> Is <*> multiplication?
12:35:37 <koz_> If we assume pure = End? I don't think that'd work.
12:35:53 <Cheery> Well is it addition then?
12:36:03 <koz_> Try putting that definition through the laws and see.
12:36:53 <koz_> Also, which paper?
12:37:03 <Cheery> Hakutulokset
12:37:04 <Cheery> Tulokset internetistä
12:37:06 <monochrom> If you don't mind a paper on free monad, your Sequence is a free monad, and the base functor is the identity functor.
12:37:06 <Cheery> Comonads for user interfaces - Arthur Xavier
12:37:19 <Cheery> I'm sorry about that.
12:37:29 <koz_> monochrom: Ah, interesting.
12:42:45 * hackage ghc-lib-parser-ex 8.10.0.13 - Algorithms on GHC parse trees  https://hackage.haskell.org/package/ghc-lib-parser-ex-8.10.0.13 (shayne_fletcher)
12:46:43 <Cheery> so is it addition? I tried the rules out and I'm a bit lazy, but it'd seem to roughly work.
12:48:46 <monochrom> yes
12:52:15 <dsal> SockAddr has two forms that contain IP addresses.  I just want to log an IP address.  The IP address is just a tuple of Word32.  The Show instance of SockAddr is complicated and involves unsafePerformIO, so I'm just going to log something ugly.
12:54:39 <freeman42x[m]1> can anyone tell what is wrong with the code I written here? it runs fine in the REPL: https://gist.github.com/razvan-flavius-panda/6e52ccbab37888571d6584cb0a96d56f
12:58:26 <berndl> freeman42x[m]1: It's using Data.Text.concat
12:59:02 <berndl> It works in the REPL since it's using concat from the Prelude
13:01:32 <freeman42x[m]1> @karma+ berndl thank you very much, that was it
13:01:32 <lambdabot> berndl's karma raised to 1.
13:03:45 * hackage assert-failure 0.1.2.3 - Syntactic sugar improving 'assert' and 'error'  https://hackage.haskell.org/package/assert-failure-0.1.2.3 (MikolajKonarski)
13:12:12 <dsal> :t concat
13:12:13 <lambdabot> Foldable t => t [a] -> [a]
13:12:29 <dsal> :t mconcat
13:12:30 <lambdabot> Monoid a => [a] -> a
13:12:41 <dsal> :t Data.Text.concat
13:12:42 <lambdabot> [Data.Text.Internal.Text] -> Data.Text.Internal.Text
13:12:47 <dsal> Man.  Too many things.
13:12:58 <freeman42x[m]1> hahaha
13:24:45 * hackage binary-io 0.2.0 - Read and write values of types that implement Binary  https://hackage.haskell.org/package/binary-io-0.2.0 (vapourismo)
13:27:45 * hackage worldturtle 0.2.0.0 - Turtle graphics.  https://hackage.haskell.org/package/worldturtle-0.2.0.0 (FortOyer)
13:37:14 * hackage enummapset 0.6.0.3 - IntMap and IntSet with Enum keys/elements.  https://hackage.haskell.org/package/enummapset-0.6.0.3 (MikolajKonarski)
13:57:03 <dmj`> dsal: just use (<>)
13:57:48 <dsal> :t fold
13:57:49 <lambdabot> (Foldable t, Monoid m) => t m -> m
13:58:20 <dsal> I forgot about that one.   `fold` is a more generalized `mconcat` which is a differently generalized `concat`
14:02:25 <frdg> I could use some further explanation on this sentence: "The functor of functions is function composition. The applicative and monad of functions chain the argument forward in addition to the composition."
14:03:03 <frdg> I'm mostly unsure about what "chaining the argument forward" means/
14:15:15 * hackage typed-encoding 0.4.1.0 - Type safe string transformations  https://hackage.haskell.org/package/typed-encoding-0.4.1.0 (rpeszek)
14:17:05 <jle`> frdg: f >>= g = \x -> g x (f x)
14:17:11 <jle`> er sorry
14:17:22 <jle`> f >>= g = \x -> g (f x) x
14:17:35 <jle`> f <*> g = \x -> f x (g x)
14:18:11 <jle`> i don't exactly understand what the english description you mentioned is trying to say
14:18:31 <frdg> jle' : Is the significance here that x is being applied twice? 
14:19:38 <jle`> that might be what they mean
14:20:15 <jle`> the way i sort of see it is that the x is needed to 'activate' the thing. this is my mental model though, maybe it's only useful once you already understand it :)
14:20:27 <jle`> f <*> g means apply the 'activated f' to the 'activated g'
14:20:40 <jle`> so f <*> g = \x -> (f x) (g x)
14:21:01 <dmj`> frdg: "chaining the argument forward" is probably a convoluted way of saying it
14:21:35 <jle`> f >>= g = \x -> g (f x) x    -- active f, give it to g, then activate that
14:24:20 <frdg> jle`: I think I see what your saying. X activates f and g , because they are `a -> b -> c` but they need an argument to be applied to become kind `* -> *` ?
14:50:07 <jle`> frdg: f, g, x, etc. have types of kind *
14:50:50 <jle`> frdg: for (<*>), f :: (R -> a -> b), g :: (R -> a), x :: R
14:51:18 <jle`> frdg: for (>>=), f :: (R -> a), g :: (a -> (R -> b)), x :: R
15:12:12 <maralorn> By the way. Why do people have backticks in there nicks? It's like your breaking markdown parsers on purpose.^^
15:14:28 <sm[m]> troublemakers
15:15:15 <sm[m]> it's IRC looking for a variant nickname that still looks visually similar
16:11:36 <yushyin> what markdown parsers?
16:11:43 <yushyin> this is irc
16:32:26 <fog> im having trouble combining the states for an infinite stream and a finite list
16:33:08 <fog> the combination is neither a stream, as it contains a list which could run out
16:33:22 <fog> nor a list, since it can always return a new state
16:34:30 <fog> the state type for list is (s -> Maybe (a,s)), and the type state for stream is (s -> (a,s))
16:35:22 <fog> for a combination of both i have ((s1,s2) -> ? ((a1,a2),(s1,s2)))
16:35:55 <fog> any ideas?
16:37:13 <fog> perhaps (m s1 s2 -> f a1 a2 s1 s2) is easier to work with, what are `m' and `f' supposed to be?
16:56:47 <hrnz> why would anyone expect irc logs to be valid markdown? The better quetion is why people have foldmarkers ({{{) in their nicks
16:59:26 <ezzieyguywuf> from wadler: "The above is analagous to the expression...let a = m in n."
16:59:33 <ezzieyguywuf> I'm confused - where did the a go?
17:01:47 <ezzieyguywuf> I guess it's "inside" n
17:01:55 <ezzieyguywuf> i.e. it's in the context of n (he says that)
17:02:43 <fog> context!?
17:02:58 <koz_> If I have a newtype over a TypeRepMap Maybe, how do I spell its (standalone) newtype-strategy Eq derivation?
17:03:08 <koz_> I know I need a quantified constraint in there someplace, but I am unsure how to spell it.
17:03:57 <koz_> So far, I have 'deriving newtype instance Eq Foo' where 'newtype Foo = Foo (TypeRepMap Maybe)'.
17:04:35 <ezzieyguywuf> sorry, the actualy quote "with the scope of the bound variable /a/ being expression /n/"
17:04:40 <ezzieyguywuf> I was being thick it makes sense now.
17:04:59 <ezzieyguywuf> although the period after n was confusing me. I think it's just a period though
17:05:55 <koz_> The closest I can come up with is 'deriving newtype instance (forall a . Eq a) => Eq Options', but that feels off.
17:05:55 <fog> koz_ idk about that extension much, i was confused I thought you meant deriving Via
17:06:14 <fog> why is the syntax different from if it were a datatype?
17:06:21 <koz_> fog: It's a quantified constraints question - I specified the strategy for clarity.
17:06:40 <koz_> The syntax is just the syntax of standalone derivations with explicit derivation strategies.
17:06:47 <koz_> I don't know how datatypes factor into this at all.
17:07:08 <fragamus_> i need to use ghcjs and stack does not support it any more. I need to get an older version but I don't know which one and I don't know how to install specified version
17:07:16 <fog> ah, so thats legit syntax, i thought you meant "how do i write newtype deriving instances", so ill take your example as how its done!
17:07:44 <koz_> fog: Yeah... that combo isn't super-well documented.
17:08:09 <koz_> It goes 'deriving [strategy] instance [superclass constraints =>] [typeclass] [thing]
17:08:11 <koz_> '
17:08:24 <fog> can you phrase the question without using TypeRepMap, i cant tell if thats confusing things
17:08:35 <koz_> TypeRepMap is _highly_ germane to this.
17:08:40 <fog> idk how you could have an Eq instance for anything like that
17:08:40 <koz_> Its Eq instance is
17:08:42 <wavemode> fragamus_, https://github.com/commercialhaskell/stack/tags
17:08:44 <wavemode> idk which version though
17:08:55 <koz_> (forall (a :: k) . Typeable a => Eq (f a)) => Eq (TypeRepMap f)
17:08:59 <koz_> In my case, f ~ Maybe.
17:09:04 <fragamus_> this helps thanks
17:09:16 <koz_> And Foo is a newtype, so I can borrow that instance quite comfortably.
17:09:27 <koz_> However, Maybe a is an Eq instance only when a is.
17:09:31 <koz_> So I gotta state that somehow.
17:09:31 <fog> eh!?
17:09:48 <koz_> fog: If you're not sure how quantified constraints work, it's fine - you don't _have_ to respond. :P
17:10:10 <fog> i get how they work, i just never found a use case for them
17:10:25 <koz_> Ryan Scott wrote a good explanation of one.
17:10:35 <koz_> hedgehog-classes is also a good demonstration of their usefulness.
17:11:01 <fog> wait, how can you have an eq instance on something without any kind * parameter?
17:12:06 <koz_> fog: I don't understand - are you unclear on that example I just posted for TypeRepMap?
17:12:17 <koz_> TypeRepMap is of kind (Type -> Type) -> Type.
17:12:29 <koz_> Well, actually, I'm lying.,
17:12:36 <koz_> It's (k -> Type) -> Type.
17:12:41 <fog> ah, ok, i think i get this, so if Eq a, and Eq (f a), then this type rep mapping is just f -> g, and you want Eq (g a)
17:13:17 <fog> and you need the uantified constraint because its forall unspecified Eq a
17:13:27 <solonarv> koz_: I don't think it's possible to write that Eq instance
17:13:59 <koz_> solonarv: The compiler accepts it when I spell it as 'deriving newtype instance (forall a . Eq a) => Eq Foo', but I suspect it doesn't say what I think it says.
17:14:14 <solonarv> right, that instance itself is valid
17:14:15 <koz_> (it does request UndecidableInstances though, which makes me a bit wary)
17:14:31 <solonarv> it's just that its context , '(forall a. Eq a)', is impossible to satisfy
17:14:36 <koz_> Ah, yeah.
17:14:53 <koz_> So does this mean I can't write this at all? Or just as a newtype-strategy derivation?
17:14:53 <solonarv> think about what that is saying: "for every type 'a', there is an 'Eq a' instance"
17:15:16 <solonarv> I guess you could write an overly-generous Eq instance that just checks whether the maps have the same set of keys
17:15:25 <solonarv> but if you actually want values to be compared, then no
17:15:26 <fog> you want to be saying something like "as long as some given `a' has an Eq instance ..."
17:16:15 <koz_> solonarv: Well, TypeRepMap can have an Eq instance.
17:16:21 <koz_> I guess I could try writing it out long-form and see what I get.
17:16:29 <fog> what about something like (forall a. Eq a => Eq (f a)) =>
17:16:59 <solonarv> you're welcome to try, but I am confident in my statement.
17:17:08 <fog> "everything that has an Eq instance if its contents do"
17:17:08 <solonarv> (that it is impossible)
17:17:31 <koz_> solonarv: Spelling it out by hand works.
17:17:39 <solonarv> what did you write?
17:18:00 <koz_> I gotta write 'instance (forall a . Typeable a => Eq (Maybe a)) => Eq Foo where Foo x == Foo y = x == y'.
17:18:16 <koz_> I basically copied the constraints on TypeRepMap's Eq instance, setting f ~ Maybe.
17:18:42 <solonarv> aha. once again you've fallen into the same trap: that constraint is impossible
17:19:01 <fog> so it would only complain when you try and use it
17:19:09 <koz_> OK, can I then say something like (forall a . (Eq a, Typeable a) => Eq (Maybe a)) => Eq Foo?
17:19:37 <koz_> Does this mean TypeRepMap's Eq instance is also unusable?
17:19:47 <fog> idk about that syntax, ski used it, i might have remembered wrong
17:19:54 <solonarv> no, now the constraint is satisfiable but it's too weak for TypeReoMap's Eq instance
17:20:40 <koz_> Yep, confirmed.
17:21:04 <fog> that was; (forall (a :: k) . Typeable a => Eq (f a)) => Eq (TypeRepMap f)
17:21:04 <koz_> So basically, I can't get what I want, argh.
17:21:23 <solonarv> yeah, you'd need something other than Maybe
17:21:38 <koz_> I can't imagine what would work other than like, Identity.
17:21:51 <solonarv> Identity would have the same problem
17:22:00 <koz_> So what would work?
17:22:33 <solonarv> you would need some sort of GADT such that 'Foo a' either doesn't contain any 'a's at all (so you don't need an 'Eq a' instance), or also contains an 'Eq a' dictionary
17:22:35 <fog> why is it using Typeable instead of Eq?
17:22:52 <koz_> fog: That's what drives TypeRepMap - it uses SomeTypeRep as keys.
17:23:19 <fog> (forall (a :: k) . Typeable a => Eq (f a)) => 
17:23:20 <fog> not
17:23:22 <fog> (forall (a :: k) . Eq a => Eq (f a)) =>
17:23:39 <koz_> fog: The values are f a for some a.
17:23:47 <koz_> The SomeTypeReps are inherently Eq-able.
17:24:23 <fog> so cant you write your instance instead of having (Eq a => Eq (f a)) to use (Typable a => Eq (f a))
17:25:10 <fog> like, arent you somehow working from; instance Eq a => Eq (Maybe a)
17:25:58 <koz_> This, in my case, would be (forall a . Typeable a => Eq (Maybe a)).
17:26:01 <fog> koz_ your saying; (forall a. Typeable a => Eq a) ~ ()
17:26:08 <koz_> Which solonarv correctly points out is unsatisfiable.
17:26:42 <koz_> A rather different question - is something of the form [http://][USER:PASSWORD@]HOST[:PORT] a URI?
17:26:45 <koz_> Or is that something else?
17:27:06 <fog> looks more like an shh
17:27:50 <fog> i dont get why its unsatisfiable anyway
17:27:56 <koz_> solonarv can explain.
17:28:10 <fog> well, i get why your quantified costraint was unsatisfiable
17:28:15 <fog> as solonarv explained
17:28:19 <koz_> I believe the crux of the argument is that 'the Typeability of a in no way reflects on whether Maybe a is Equatable).
17:28:23 <fog> but i dont get why you cant write your instance
17:28:37 <koz_> I can write the instance, but if it's not gonna be usable, why bother?
17:29:11 <fog> but the Typability of a implies a is Equabale, and if its Eq, then you have the regular Eq a => Eq (Maybe a)
17:29:17 <fog> so it seems like it should work
17:29:29 <koz_> Why does the Typeability of a imply its Equatability?
17:29:44 <koz_> I don't believe there exists an instance of the form 'Typeable a => Eq a'.
17:29:49 <fog> oh i thought you said thats why they were using Typeable as a constraint instead of Eq
17:29:58 <koz_> ... that is by no means anything like what I said.
17:30:02 <fog> hmm
17:30:18 <koz_> TypeRepMap is a mapping from SomeTypeRep to f a for some specific f.
17:30:37 <koz_> SomeTypeReps can be compared to each other regardless.
17:30:40 <fog> i thought you said typeable, but you said SomeTypeReps
17:30:44 <koz_> ...
17:30:53 <koz_> Type.Reflection defines a few things.
17:31:02 <fog> ah, thats where all this is from
17:31:03 <koz_> Typeable is a type class, which says 'we can make a TypeRep of you'.
17:31:17 <koz_> Now, normally, TypeRep has a phantom type parameter to indicate what it's repping.
17:31:24 <koz_> SomeTypeRep existentially erases it.
17:32:07 <fog> so why do you think the instance your trying to write should work?
17:32:28 <xcmw> What is the best way to make interactive diagrams in haskell? I saw diagrams and diagrams-miso but it was really slow even on ghc. Maybe I was using it incorrectly. I do really like the diagrams api, but I can not figure out how to make it fast.
17:32:40 <koz_> Given that f ~ Maybe is a motivating example in the docs?
17:32:49 <koz_> I mean, if it doesn't work there, I'm not really sure why bother even having an instance.
17:32:58 <fog> (forall (a :: k) . Typeable a => Eq (f a)) => Eq (TypeRepMap f)
17:33:27 <koz_> xcmw: How are you feeding diagrams its data?
17:33:33 <koz_> Like, from what are you generating said diagrams?
17:35:52 <fog> i think we are having trouble saying "given that Typeable a is satisfied"
17:35:57 <xcmw> koz_: My model is a map with nodes and a map with connections between nodes (it is a bit more complicated). I generate the diagram in the view function.
17:36:00 <solonarv> I have fog on ignore, so I don't know what they're saying (and I don't care to find out)
17:36:13 <koz_> xcmw: As in, Data.Map map?
17:36:16 <koz_> Or some other kind?
17:36:18 <xcmw> Yes
17:36:22 <solonarv> but this bit - "the Typeability of a in no way reflects on whether Maybe a is Equatable" - is basically right
17:36:39 <solonarv> in this case there is even a counterexample: 'Int -> Int' is Typeable , but is not Eq
17:36:54 <solonarv> (and the same is true of 'Maybe (Int -> Int)')
17:36:55 <koz_> solonarv: Functions are always there to remind us we can't have nice things. :P
17:37:04 <koz_> xcmw: Hmm.
17:37:11 <xcmw> In elm I used elm-collage and it was very fast.
17:37:15 <koz_> So what's the map mapping from and to?
17:37:27 <fog> im hurt
17:37:31 <xcmw> Id to node
17:37:35 <fog> here was the code for the question I asked
17:37:37 <fog> https://pastebin.com/raw/yXDBaHSy
17:38:00 <koz_> xcmw: What's Id and node in this context?
17:38:10 <koz_> I'm trying to figure out what sort of data you're grinding out.
17:38:23 <xcmw> id is just 0, 1, 2, ...
17:38:28 <koz_> So like, Int?
17:38:31 <xcmw> yes
17:38:40 <koz_> Then, pardon the bluntness, _just state that_.
17:38:54 <koz_> I can't reason about the efficiency of a data type's representation without knowing said representation. :P
17:39:46 <xcmw> koz_ I can show you the code if that would help it is 422 lines
17:39:52 <koz_> xcmw: That'd help a lot.
17:40:12 <koz_> Use like, Github Gist or something.
17:40:22 <xcmw> koz_ https://gist.github.com/michaelmesser/df39d982b4bdcc41b4a21f7b37afcfcd
17:41:06 <fog> sorry, there is a typo, it should read "scanners are built around stream-like containers"
17:41:46 <xcmw> koz_ Tables in this are just Map with auto incrementing keys
17:42:36 <fog> i think thats also wrong though. its an artefact of the fact that tapes model list-like containers
17:42:54 <fog> scanners seem to be totally different, they dont destructively consume their state
17:42:56 <xcmw> I don't think the bottleneck is the data structure. I think it is the generation of the diagram.
17:43:37 <koz_> xcmw: I'm not seeing you storing a graph in a Data.Map anywhere here. The only use of it seems to be in 'events'.
17:44:22 <xcmw> koz_ The Tables are line 92 are Data.Map with auto incrementing keys
17:44:55 <koz_> And where's Table from?
17:45:34 <xcmw> koz_ I wrote it. Basically Table a = (Int, Map Int a)
17:45:51 <koz_> xcmw: Ah, OK.
17:45:55 <xcmw> https://gist.github.com/michaelmesser/fa28ed1065aa45c706201bb4324e6c8e
17:46:22 <koz_> Hmm, OK. Then I'm not sure, but figured I'd start there.
17:46:26 <koz_> Have you tried profiling?
17:46:31 <xcmw> Yes
17:46:41 <koz_> What did that say your cost centre(s) are?
17:47:38 <xcmw> koz_ The generation of the diagram
17:48:20 <xcmw> I'll post it
17:48:33 <xcmw> https://gist.github.com/michaelmesser/7e4d1dd2e9c8f29738525fc9eaea472a
17:49:39 <xcmw> I had profile with jsaddle warp instead of jsaddle wkwebview because profiling and dynamic linking don't mix well.
17:50:06 <koz_> Hmm, that's curious. Maybe someone more knowledgeable might be able to help. Not really sure where to go from here.
17:51:17 <xcmw> koz_ okay thanks
17:53:54 <wavemode> aeson seems to be taking up most of your time and allocations. are you doing lots of aeson encoding?
17:54:36 <xcmw> wavemode jsaddle warp is
17:55:27 <wavemode> yeah it looks like that's probably your bottleneck
17:59:15 <xcmw> wavemode: How would I fix that? I don't use Aeson directly.
18:00:53 <xcmw> Would using reflex instead of miso help?
18:01:21 <wavemode> well so, you're comparing the performance of jsaddle warp, which runs in ghc and communicates across the wire with the browser, and elm, which compiles directly to javascript. I think it's understandable that it's significantly slower
18:03:20 <xcmw> wavemode ghcjs is even slower
18:04:56 <TodaysTommorrow> Hello everyone, when did you start with haskell?
18:06:02 <koz_> More than five years ago.
18:06:22 <TodaysTommorrow> I started about a decade ago, but no professional work
18:06:42 <TodaysTommorrow> Koz_ have you ever heard of projecteuler?
18:07:49 <koz_> TodaysTommorrow: Which Project Euler?
18:08:31 <TodaysTommorrow> koz_ I believe there's only one, it's just a sequence of problems that can be elegantly solved in haskell 
18:08:32 <wavemode_> xcmw: well I don't know for certain what the cause there is. though my bias is to say that ghcjs is experimental and doesn't generate efficient javascript
18:08:44 <koz_> TodaysTommorrow: Oh, right, that one. OK, yeah, have heard.
18:09:15 * hackage codeworld-api 0.6.0 - Graphics library for CodeWorld  https://hackage.haskell.org/package/codeworld-api-0.6.0 (ChrisSmith)
18:10:35 <TodaysTommorrow> what is your favorite problem koz_ ?
18:10:47 <koz_> TodaysTommorrow: I'm not really familiar enough with them to have a favourite.
18:11:07 <TodaysTommorrow> I was never able to get through them without looking for help on the internet
18:11:31 <TodaysTommorrow> I'm giving up on becoming a mathematician. I'm now a leader
18:12:02 <koz_> TodaysTommorrow: Uhh, OK.
18:12:18 <slack1256> I started learning haskell by doing project euler exercises
18:12:33 <TodaysTommorrow> me too slack1256 :-)
18:12:41 <slack1256> I did them until like the 30th problem, then I just played with haskell.
18:12:45 <TodaysTommorrow> what is your favorite?
18:12:56 <TodaysTommorrow> did you do them on your own? How old were you when you did them?
18:13:23 <slack1256> I don't remember any of them. I guess the sieves' one.
18:13:41 <TodaysTommorrow> my favorite was one about protein folding
18:14:15 * hackage typed-encoding-encoding 0.1.0.0 - Bridge between encoding and typed-encoding packages  https://hackage.haskell.org/package/typed-encoding-encoding-0.1.0.0 (rpeszek)
18:31:23 <koz_> :t concat
18:31:24 <lambdabot> Foldable t => t [a] -> [a]
18:31:37 <koz_> :t mconcat
18:31:39 <lambdabot> Monoid a => [a] -> a
18:39:32 <dsal> :t fold
18:39:33 <lambdabot> (Foldable t, Monoid m) => t m -> m
18:43:28 <liiae> higer kind can actually used to code in haskell?
18:46:27 <dsal> liiae: https://leanpub.com/thinking-with-types
18:50:57 <kamek> what's the obvious way to convert integers to Text from Data.Text ? can't find anything, must be tired
18:52:23 <monochrom> maybe Data.Text.Builder has something
19:02:49 <koz_> You can also do hacky things like pack . show I guess.
19:12:02 <ezzieyguywuf> what is the significance of () in `IO ()`? I guess the IO monad has kind * -> *, and so in this case it is an IO of "unit"?
19:12:15 <ezzieyguywuf> what's an example when you'd use an IO of something other than ()?
19:12:22 <koz_> :t readLine
19:12:24 <lambdabot> error:
19:12:24 <lambdabot>     • Variable not in scope: readLine
19:12:24 <lambdabot>     • Perhaps you meant one of these:
19:12:57 <ezzieyguywuf> :t readLn
19:12:58 <lambdabot> Read a => IO a
19:13:03 <koz_> That one.
19:13:05 <ezzieyguywuf> ah
19:13:30 <ezzieyguywuf> I see. it could be an IO of a file, a database, the internet, what have you
19:14:12 <koz_> More precisely, 'IO a' says 'I give you an a, but I also have some interaction with the outside world'.
19:14:42 <koz_> Much like 'Maybe a' says 'I give you an a, but possibly nothing at all'.
19:14:44 <ezzieyguywuf> So IO () doesn't have any data
19:14:48 <ezzieyguywuf> it just..does things
19:14:58 <koz_> Yep - basically this.
19:15:06 <koz_> :t putStrLn
19:15:07 <lambdabot> String -> IO ()
19:15:12 <koz_> ^ Perfect example
19:15:42 <ezzieyguywuf> hrm, yes I see.
19:15:54 <ezzieyguywuf> interesting
19:16:13 <koz_> The whole point here is to be honest about what effects you do or don't have.
19:16:13 <ezzieyguywuf> is __everything__ that interacts with the outside world an IO monad, or is that just a convention?
19:16:27 <ezzieyguywuf> ah hah, yep that answers my question
19:16:28 <koz_> At the _very_ bottom yes.
19:16:39 <koz_> You can have 'specialized' forms of IO that don't have its full power.
19:17:00 <koz_> For example, nothing is stopping you from writing a 'Database' thing, which only has the ability to talk to a database.
19:17:04 <koz_> So like, you'd have functions like
19:17:14 <koz_> 'executeSQL :: SQL -> Database ()'
19:17:27 <koz_> Now, underneath, you'd still need to use IO, but your users don't need to see it.
19:18:15 <ezzieyguywuf> Is tat being "honest about what affects you do or don't have"?
19:18:32 <koz_> Well, yes?
19:18:55 <koz_> Basically, anything which interacts with the database will have its result 'marked' with 'Database' like that.
19:19:05 <koz_> So you can't lie to yourself and pretend any such thing is side-effect-free.
19:19:35 <ezzieyguywuf> i see.
19:19:48 <ezzieyguywuf> so by marking it 'Database' it essentially implies 'IO'
19:19:59 <koz_> It implies a _subset_ of IO.
19:20:13 <koz_> So like, you can do databasey things, but not printing to the terminal or reading files.
19:20:30 <koz_> In reality, you'
19:20:34 <koz_> d likely write it as something like
19:20:46 <koz_> 'newtype Database a = Database { unsafeDB :: IO a }'.
19:20:57 <koz_> But you'd hide the 'unwrap' function from the users, and only give them a bunch of functions.
19:21:02 <koz_> And then you'd have something like
19:21:10 <koz_> runDatabase :: Database a -> IO a
19:21:25 <koz_> So users can 'build up' a bunch of databasey things, and then use runDatabase to execute them in main.
19:21:43 <ezzieyguywuf> ah hah! that's a very clear example thanks
19:21:45 <wavemode_> also, this may come with the ability to, rather than running Database in IO and contacting the real DB, instead running it purely and giving it dummy data, for testing purposes
19:21:48 <ezzieyguywuf> monads are making more and more sense
19:21:56 <ezzieyguywuf> i even took a peek at what a monad transformer is.
19:22:14 <koz_> Basically, the whole point is that monads happen to model 'honesty about effects'.
19:22:29 <koz_> They're a way of talking about 'I have an effect' in a general sense, without being (too) tied to what said effect is.
19:22:43 <koz_> They're not the _only_ way we can do that, but they happen to work and that's why we care about them.
19:23:04 <koz_> So we can abstract over 'effect-having' operations without having to pin down the exact effect.
19:23:33 <koz_> Related: http://dev.stephendiehl.com/hask/#whats-the-point
19:24:34 <ezzieyguywuf> speaking of which, has anyone here ever used repline? http://dev.stephendiehl.com/hask/index.html#repline
19:24:47 <ezzieyguywuf> I couldn't get the example to work from the docs, so I'm a bit weary
19:24:50 <ezzieyguywuf> leary?
19:24:52 <ezzieyguywuf> skepticle
19:25:06 <koz_> 'Wary', 'leery' and 'skeptical' respectively. :P
19:25:27 <koz_> What was the issue(s) you had?
19:26:00 <ezzieyguywuf> koz_: thanks!
19:26:01 <ezzieyguywuf> lol
19:26:22 <ezzieyguywuf> well first there was an ambiguity issue with the 'options' function
19:26:26 <ezzieyguywuf> so I renamed it 'myOptions'
19:26:34 <ezzieyguywuf> then...i can't remember I'll have to go check h/o
19:26:58 <koz_> Well, if you can give the exact thing you wrote, and the exact error message that gave you, we may be able to assist.
19:27:16 <koz_> WIWIKWLH isn't perfect, and I've found issues with it before, but this might not be it.
19:27:22 <ezzieyguywuf> hah, well ok on a related but different note, I _did_ get the example from the site I linked to work (with the same options change) but the commands (i.e. :help) didn't do anything
19:27:41 <ezzieyguywuf> http://dpaste.com/3YPEA43
19:27:49 <ezzieyguywuf> here's the code that actually executes but does not behave as expected
19:29:13 <koz_> Maybe someone who knows more about repline might be able to help.
19:29:53 <ezzieyguywuf> Here's my code from the documentation (the 'Simple' link 404'd so I had to build it up myself) http://dpaste.com/3VEDB9G, I think I'm missing some imports maybe?
19:30:26 <ezzieyguywuf> it has a total of 9024 downloads, so I'm guessing maybe it's a dud.
19:33:09 <ezzieyguywuf> hm, the repline github actually seems to be more informative, so maybe there is hope yet.
19:33:38 <RENNNN> can someone help with `do { g<- getStdGen; r <- randomRs (0, 1) g; return zip r [1..10]}`
19:33:49 <RENNNN> i'm trying to zip a non IO list with an IO list
19:33:51 <ezzieyguywuf> lol, repline is written by the What I Wish I knew guy
19:34:08 <koz_> ezzieyguywuf: Stephen isn't around much here I don't think.
19:34:36 <koz_> RENNNN: So you want to do something like [a] -> IO [b] -> IO [(a, b)]?
19:35:08 <RENNNN> yes
19:35:12 <koz_> :t pure
19:35:13 <lambdabot> Applicative f => a -> f a
19:35:21 <koz_> In your case, f ~ IO and a ~ [a]
19:35:25 <koz_> So pasting that in, we get
19:35:34 <koz_> Applicative IO => [a] -> IO [a]
19:35:40 <koz_> And since Applicative IO holds, we can ignore it.
19:35:49 <koz_> So that gives you pure :: [a] -> IO [a]
19:36:05 <koz_> So thus, you wanna use 'pure' on the non-IO list to 'lift' it into IO.
19:36:24 <ezzieyguywuf> do I need to import something for liftIO?
19:36:34 <koz_> Control.Monad.IO.Class.
19:37:21 <RENNNN> koz but don't i want the inverse?
19:37:21 <ezzieyguywuf> koz_: thanks!
19:37:31 <koz_> You can't normally _do_ the inverse.
19:37:55 <koz_> If you have two lists in IO, you can zip them together using liftA2 zip.
19:37:57 <RENNNN> then i have to use liftm2 to zipe it?
19:38:02 <koz_> Yeah, or that.
19:38:05 <RENNNN> why applicative and not monad?
19:38:25 <koz_> They're equivalent vis-a-vis 'pure' and 'lift{M,A}2'.
19:38:34 <koz_> Since you only need Applicative power to define either.
19:41:00 <ezzieyguywuf> hah, I got repline up and running
19:42:45 <wavemode_> RENNNN, okay first of all, your `r <- randomRs (0, 1) g` should just be `let r = randomRs (0, 1) g`. randomRs does not return an IO list, it's just a list
19:43:05 <RENNNN> why?
19:43:20 <RENNNN> or more like how?
19:43:21 <koz_> :t randomRs
19:43:22 <lambdabot> (Random a, RandomGen g) => (a, a) -> g -> [a]
19:43:33 <koz_> Because you only need IO to get the generator.
19:43:47 <koz_> :t randomR
19:43:48 <lambdabot> (Random a, RandomGen g) => (a, a) -> g -> (a, g)
19:43:50 <koz_> Same story.
19:44:34 <wavemode_> secondly, your `return zip ...` is trying to return the function zip itself. what you want is actually `return (zip r [1..10])`
19:44:56 <RENNNN> wavemode thanks!
19:45:17 <wavemode_> look at me, flagrantly misusing the term "return". someone lynch me
19:45:36 <koz_> wavemode_: Lol, the other kind of return should just be renamed pure and be done with.
19:46:00 <RENNNN> but the whole block will have to return an IO?
19:46:10 <koz_> RENNNN: IO is a one-way street.
19:46:15 <koz_> Once you're in it, there's no leaving.
19:46:29 <koz_> It's also contagious.
19:46:36 <RENNNN> koz_, it's like hotel california?
19:46:40 <koz_> RENNNN: I guess.
19:46:49 <koz_> It's not the second weirdest analogy I've seen regarding (monadic) IO.
19:46:50 <wavemode_> hahaha
19:47:01 <koz_> s/not/not even/
19:47:21 <RENNNN> koz_, what's the weirdest?
19:47:33 <koz_> RENNNN: There's that thing 'Bob the monadic lover' floating around.
19:47:38 <koz_> That's pretty bizarre.
19:47:40 <EvanR> being inside IO as if it was a building or a container doesn't seem to correspond to anything in real life
19:47:46 <wavemode_> IO is like the GNU public license
19:48:12 <RENNNN> haha
19:50:25 <EvanR> IO A values are simply procedural programs (potentially) yielding an A. Very mundane
19:50:35 <EvanR> and this is why you can't just take one and get an A out
19:51:15 <EvanR> you can only feed it to the interpreter for execution
19:52:24 <EvanR> or compose them in various ways
19:53:43 <RENNNN> is it bad taste to user r <- return $ ... instead of let r = ... in ... ?
19:53:52 <RENNNN> s/user/use/
19:54:36 <wavemode_> hspec will draw a big yellow squiggly under r <- return $ . because it's pointless, and very slightly inefficient
19:55:12 <RENNNN> wavemode_, but can i do something r = ... ?
19:55:19 <RENNNN> s/something/something like/
19:55:33 <wavemode_> yes, that's what let is for
19:55:38 <koz_> wavemode_: You mean HLint right?
19:55:47 <koz_> Hspec doesn't draw squiggles under anything normally. :P
19:55:47 <wavemode_> yeah, hlint. my bad
19:55:52 <RENNNN> but i need the `in` no?
19:56:09 <wavemode_> no, let is different inside a do block
19:56:20 <RENNNN> oh i didn't know
19:56:23 <RENNNN> thanks
19:56:24 <wavemode_> it's just `let x = y` . then you continue on
19:56:37 <EvanR> read the do notation translation. For one thing, that's all it is, a translation
19:57:03 <koz_> Delicious, delicious syntactic sugar.
19:57:27 <ezzieyguywuf> btw, I forgot who was recommending the wadler paper on monads earlier, but I love how his divisions example results in 42
19:57:33 <RENNNN> https://wiki.haskell.org/Monad#do-notation has nothing on it :(
20:03:46 <EvanR> well it does have an example. But yeah it would be nice to have the results clearly illustrated. Other than in the haskell report
20:22:07 <ezzieyguywuf> hm, "something is amiss...Main differs from name found in the interface file main:Main", could this be something wrong in my cabal setup?
20:22:54 <ezzieyguywuf> this is my cabal, http://dpaste.com/24FEPRM, and my src/Main.hs http://dpaste.com/0Y0NC3S
20:28:43 <ezzieyguywuf> hm, I moved my Main.hs to it's own dir and updaed cabal accordingly and the error went away...
20:40:04 <RENNNN> stack is confusing me, do i have only one version of ghc globally?
20:40:15 <RENNNN> or does it reinstall ghc for all projets?
20:40:25 <RENNNN> or do i have multiple sloted ghcs?
20:40:45 <koz_> RENNNN: It gets you a local GHC whenever needed according to its resolver.
20:40:55 <koz_> And automagically deals with that based on which resolver you request.
20:41:02 <RENNNN> koz_, but where does it store it?
20:41:20 <koz_> I believe it keeps a folder in your homedir with all your GHCs.
20:41:24 <RENNNN> haskell ide keeps telling me "unable to load package `ghc-prim-0.5.3'"
20:43:39 <RENNNN> do i have to install it for all ghc versions?
20:43:42 <RENNNN> or only for one?
20:44:22 <koz_> That I do not know.
20:45:01 <RENNNN> koz_, what do you used for writing haskell (if you don't mind me asking)
20:45:26 <koz_> Neovim with ALE and Neoformat calling out to cabal and ormolu.
20:45:32 <koz_> And I use local GHCs from ghcup.
20:49:14 * RENNNN should stop use vscode
20:49:36 * koz_ refrains from casting aspersions even though he really, _really_ wants to.
20:50:13 <RENNNN> koz_, the ram usage is killing my laptop with only 8gb of ram....
20:50:21 <koz_> RENNNN: I'm not surprised.
21:17:26 <Lycurgus> in another part of the forest, I'm running mainframe OSes from the prior century on stock pc hardware of these times, some of which have addressing limits of 16MB
22:12:35 <isovector1> can the type signature in a COMPLETE pragma have type applications?
22:12:45 <isovector1> i am getting a parse error for this: `{-# COMPLETE LVWWhite' :: LexemeVW' () Void #-}`
22:15:44 <wavemode__> what happens if you use a type synonym for it
22:16:03 <isovector1> oh nice idea
22:16:05 <isovector1> let me check
22:16:44 <isovector1> Couldn't match expected type ‘LexemeV’ with ‘LexemeVW'’
22:16:53 <isovector1> looks like it's time to file some trac tickets
