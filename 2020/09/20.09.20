00:04:19 * hackage webauthn 0 - Web Authentication API  https://hackage.haskell.org/package/webauthn-0 (FumiakiKinoshita)
00:50:41 <perdent> How would you decode this Cistercian Monk Numerals cipher from this image programtically? https://imgur.com/lWxfMHf https://www.dcode.fr/cistercian-numbers
01:00:29 <cheater> you mean with OCR?
01:02:03 <perdent> cheater: yeah, or is there an easier way?
01:02:31 <perdent> Can't ffind any on github
01:02:37 <perdent> That do this
01:02:52 <cheater> why not just enter the data by hand?
01:03:03 <cheater> do you have huge amounts of data to OCR?
01:03:50 <perdent> I could doit by hand, would be nice to have a script to do it though
01:04:13 <perdent> What did you get by hand?
01:13:57 <shad0w_> Hi. i was following up on a link i was suggested to read here yesterday. https://wiki.haskell.org/How_to_write_a_Haskell_program
01:14:29 <shad0w_> in the `program structure` section, it gives you a link for reading more about monad transformers.
01:14:36 <shad0w_> that link seems to be dead.
01:15:01 <cheater> are you new to haskell?
01:15:10 <shad0w_> sure
01:15:25 <cheater> don't read about monad transformers
01:15:37 <shad0w_> lmao
01:15:58 <cheater> just saving you a headache
01:16:08 <shad0w_> just out of curosity. why ?
01:16:31 <shad0w_> are they more complex than they are worth ? or they arent the preffered way anymore ?
01:16:38 <perdent> i solved it
01:16:49 <cheater> because it's an advanced topic you most certainly will not need for a long time, and any explanation you'll come across will likely be way over your head
01:17:11 <shad0w_> gotcha
01:17:15 <shad0w_> seems fair.
01:18:11 <perdent> HTB{m0Nks_kN3w!}
01:18:15 <perdent> is what i got
01:18:37 <cheater> perdent: ü§∑‚Äç‚ôÇÔ∏è
01:19:04 <perdent> capital M
01:26:50 <shad0w_> i had another question. is cabal sandboxing still a thing ?
01:28:17 <shad0w_> i can only find 1 command `v1-sandbox` in cabal help and its listed under `legacy commands`
01:29:37 <cheater> yes, v1-sandbox is still a thing, it's what sandbox used to be
01:29:48 <cheater> if you use v2-* commands, they work like a sandbox now
01:29:50 <int-e> shad0w_: Barely, it'll be removed in version 3.4. You can presumably get a similar effect by manipulating the store directory.
01:29:53 <cheater> but the sandboxes are global
01:29:56 <cheater> ish
01:30:01 <cheater> it's not really like that
01:30:13 <cheater> but for what you want, using v2-* commands is what you want if you were using sandboxes before
01:30:27 <cheater> int-e's suggestion of manipulating the store dir isn't necessary
01:30:50 <int-e> cheater: I *wanted* to keep local build artefacts.
01:31:50 <cheater> int-e: shad0w_ is just a person new to haskell doing some basic projects. shad0w_ doesn't need to do any of that crazy stuff.
01:31:50 <shad0w_> so, if hypothetically, i am writing a new project, doing cabal init will sandbox it to the very folder ?
01:32:06 <shad0w_> cheater: +1
01:32:11 <cheater> shad0w_: not really, no. it will be global. but it will be done so that you don't get cabal hell
01:32:49 <shad0w_> now suppose if 2 of my projects depend on the  same dep but different version ?
01:33:09 <shad0w_> for eg:- say hlint.
01:33:19 <shad0w_> i just updated to 3.2 recently
01:33:21 <cheater> you used to get cabal hell due to conflicting library versions. you don't get that anymore. every combination of versions is kept separate, so to speak. so two projects using the same exact lib versions will use the same build artefacts. but two projects using different lib versions will use separate lib artefacts and won't know about each other.
01:33:56 <shad0w_> and globals can only be 1 copy right ?
01:34:08 <shad0w_> like hlint is installed in .cabal/bin/hlint
01:34:19 <shad0w_> it seems to be a symlink to a store folder
01:36:08 <cheater> i forgot how that works
01:36:14 <cheater> i just know you can set it up to work
01:36:31 <shad0w_> cool
01:36:51 <shad0w_> tl;dr, sandboxing isn't necessary now ?
01:37:10 <cheater> yes
01:37:11 <int-e> cheater: fair enough, I should've asked why they want sandboxes first.
01:37:13 <cheater> use v2-*
01:37:19 <cheater> int-e: it's okay :)
01:37:29 <shad0w_> thanks @cheater
01:37:31 <cheater> int-e: you were trying to help, that's what matters :)
01:37:33 <cheater> yw shad0w_ 
01:38:12 <shad0w_> one more thing
01:38:20 <shad0w_> there are v2- commands like you said.
01:38:33 <shad0w_> there also happens to be some `new-` commands
01:38:49 <shad0w_> do they succeed `v2-` commands ?
01:39:20 <shad0w_> thanks @int-e too : )
01:40:12 <int-e> shad0w_: no, the new- command are the v2- commands
01:41:07 <cheater> new-* is the current new stuff. once we have v3, new will refer to v3 and not v2 any more.
01:41:11 <cheater> v2 is forever v2.
01:41:14 <cheater> until it gets removed.
01:41:14 <int-e> For historical reasons, the old commands were there, then the 'new-' commands were added. Then somebody realized that this will make the switch awkward, and the 'v1-' aliases for the old commands and the 'v2-' aliases for the new commands were added.
01:41:31 <int-e> By now the 'v2-' commands are the default, and the 'new-' prefix is confusing.
01:42:00 <shad0w_> so the new- seems like a pointer to the newest stuff, which just happens to be v2- in this case ?
01:42:14 <shad0w_> while v2- is always hard v2-
01:42:25 <cheater> yes
01:42:31 <shad0w_> got it. 
01:42:42 <shad0w_> damn you guys are helpful.
01:42:46 <shad0w_> : )
01:43:09 <shad0w_> happy weekend guys.
01:43:20 <int-e> cheater: please tell me there are no current plans for a v3 set of cabal commands.
01:43:31 <cheater> int-e: not that i know of
01:43:41 <cheater> int-e: but that's what i was told some time ago
01:43:47 <cheater> you too shad0w_ 
02:00:59 <kicov> Hi, was just wondering how to approach doing things with State monad and liquid haskell. Let's say our state is int, and we'd like a check for a function `successor` that checks whether the current int is mod 2. If it is, then we return state+1, if it isn't, boom.
02:25:22 <ski> kicov : sounds like you want to encode precondition and postcondition on the state, that is some kind of Hoare triple ?
02:48:27 <dminuoso> kicov: What is "boom"?
02:55:59 <kicov> dminuoso: failed constraint
03:00:00 <ski> kicov : so, what does "checks whether the current int is mod 2" mean ?
03:00:56 <kicov> ski: Never heard of them, but that would be possible. Maybe continuation passing style could have a similiar problem
03:01:39 <kicov> ski: i (the state) `mod` 2 == 0
03:02:00 <kicov> sorry, should be more clear
03:02:04 <dminuoso> kicov: So what you're proposing is `successor :: State Int ()` with a matching LH signature that suggests that the *input* state is always even?
03:02:12 <ski> kicov : <https://en.wikipedia.org/wiki/Hoare_logic>
03:02:19 <dminuoso> kicov: Did I get that right?
03:02:44 <kicov> dminuoso : yep!
03:02:49 <ski> presumably also that the output state is always odd, i'd gather
03:03:25 <dminuoso> Mmm, I wonder, is there some `liftState :: a -> a -> StateT a ()` function perhaps?
03:03:26 <ski> (or maybe even that it's just the successor of the input)
03:03:40 <dminuoso> Oh, State rather
03:03:46 <ski> what would it do ?
03:04:26 <dminuoso> Oh hah, that's just modify I guess
03:04:41 <ski> oh .. i was beginning to wonder if it was missing some brackets
03:05:29 <dminuoso> Ah indeed, weird.
03:29:12 <siraben> What a good alternative to the monad-gen package?
03:48:14 <random> hey guys, am I not getting this right or there is no phone parser library for Haskell
03:48:20 <random> besides the one that requires libphonenumber?
03:49:08 <Rembane> random: Is that US phone numbers?
03:49:18 <random> I need for european ones
03:49:38 <random> but there doesn't seem to be anything for US phones as well
03:49:45 <random> thought this was quite a common usecase
03:50:04 <Rembane> random: Got it. Maybe it is too simple to write a parser using Megaparsec that everyone does that instead?
03:50:31 <Rembane> siraben: I have used this: https://hackage.haskell.org/package/quickcheck-transformer What is good for you?
03:50:53 <random> Rembane: I guess not too simple but I'll be doing it as well lol...
03:51:21 <random> the country code numbers are quite variable
03:52:45 <Rembane> random: Yeah. :) 
03:53:01 <Rembane> random: Just out of curiosity, do you have some examples of country code numbers?
03:53:14 <random> https://countrycode.org/
03:55:31 <cheater> random: phone numbers are a very difficult thing to parse, like time zone data and time strings, if there's going to be a competent library there's only going to be one
03:55:50 <random> cheater: yeah but it relies on a C dep
03:55:56 <random> we're in AWS Lambda so that hurts
03:56:03 <random> I'll fix it of course, just found it weird
03:56:04 <Rembane> random: Dashes! Why?! <- rhetorical question
03:56:07 <cheater> that's pretty tough
03:56:08 <cheater> sorry
03:56:42 <random> alright, putting on my devops gloves
03:56:47 <random> wish me luck guys *cries*
03:59:02 <Rembane> random: GL HF!
04:00:40 <edwardk> Forgive me, father, for I have sinned. It has been 33 years since my last confession. I used an overlapping instance, and looked lustfully upon another man's type system. What is my penance?
04:14:30 <phadej> recite "why functional programming matters" ten times, and contribute to GHC.
04:16:16 <edwardk> tough but fair
04:22:56 <gpvs> Hello. I can't make this compile:
04:22:56 <gpvs> Class (Show type_self, AWord type_word) => Animal type_self where
04:22:57 <gpvs>   say :: type_self -> [type_word]
04:22:57 <gpvs> I tried:
04:22:57 <gpvs> Class Show type_self => Animal type_self where
04:22:57 <gpvs>   say :: AWord type_word => type_self -> [type_word]
04:22:58 <gpvs> and it compiled, but then
04:22:58 <gpvs> instance Animal AnimalSpecific where
04:22:58 <gpvs>   say (AnimalSpecific arrayOfInstancesOfAWord) = arrayOfInstanceOfAWord
04:24:09 --- mode: ChanServ set +o ski
04:24:15 <Cale> oops
04:24:37 <gpvs> Hello. How do I paste multiline here not getting banned?
04:24:47 <Rembane> gpvs: What error message do you get? Can you put it in a pastebin? See topic for information.
04:24:54 <Rembane> gpvs: You can access topic by running the command /topic 
04:24:54 <Cale> try https://dpaste.com/
04:25:00 <niko> ski: already lifted
04:25:11 --- mode: ChanServ set -o ski
04:25:14 <ski> ok
04:25:33 <Rembane> edwardk: Was it 33 years since you used an overlapping instance last time?! :O 
04:25:51 <edwardk> pretty close
04:25:58 <edwardk> i used one other really
04:26:24 <int-e> Overlapping instances is the devil's way of leading you towards incoherent instances.
04:26:24 <edwardk> but i was granted an indulgence by one of the simons, so that sin never existed to be forgiven
04:27:01 <phadej> I think that my overlapped instance count is negative
04:27:22 <edwardk> here i'm trying to hack around the fact that 1 + isn't injective for Nat.
04:27:26 <edwardk> So I've had to get creative
04:27:29 <Rembane> edwardk: Seems legit
04:27:59 <edwardk> There appears to be a pattern synonym I _can't_ write without injectivity on succ, despite the fact that the GADT version typechecks, i can't emulate the GADT right.
04:28:27 <Rembane> I'm probably extremely dense here, but I cannot see why 1 + isn't injective. What have I missed?
04:28:41 <phadej> nobody told GHC
04:28:58 <Rembane> Oh
04:29:06 <edwardk> in theory if i can get the type information at just the right point so that names are in scopes maybe i can unsafeCoerce a :~~: to make the proof i need
04:29:24 <edwardk> Rembane: the builtin Nat kind is crippled
04:29:41 <edwardk> + only computes will fully grounded numbers
04:30:05 <Cale> At the term level, you have infinity = Succ infinity, which also messes up the injectivity of 1+
04:30:10 <Rembane> edwardk: How terrible is it to uncripple it?
04:30:13 <edwardk> so i wind up in situations where i need to know 0 and 1+x are disjoint, or that 1+x = 1 + y => x + y
04:30:19 <Cale> er, nevermind
04:30:25 <Cale> It's just a fixed point
04:30:53 <phadej> I think though that GHC knows some weak version of injectivity for (+) though, as otherwise one would get a lot more ambiguous type erros
04:30:58 <edwardk> Rembane: that is a ghc hq thing. nats have been terrible for several years, so i'm not holding my breath.
04:31:20 <ski> gpvs : do you understand the problem you're getting ? perhaps you want to make `Animal' a MPTC, parameterized by both `type_self' and `type_word' ? do you really need to make a type class at all ?
04:31:27 <Rembane> edwardk: Got it. Then I assume that it isn't "just" to e-mail a patch and hope for the best. 
04:31:35 <edwardk> phadej: oh? afaict all it does it leave it dangling there as a stuck type family
04:32:05 <edwardk> unless the args are fully grounded out by previous applications of the magic rule for the type family
04:33:40 <gpvs> ski: wait a second please, forming dpaste from another PC
04:34:16 <phadej> edwardk: if you write foo :: Proxy (x + y) -> Proxy x -> (); foo _ _ = () -- it is accepted
04:34:42 <phadej> clearly means that (+ y) is injective.
04:34:52 <phadej> "clearly"
04:36:11 <edwardk> hrmm
04:37:53 <edwardk> the (+) type family is weird
04:38:00 <phadej> git grep -i "interaction with inerts" in GHC code
04:38:11 <phadej> I just know that makes that `foo` code type-checks
04:38:31 <phadej> but how, ask someone else
04:38:43 <phadej> (e.g. why it doesn't make partially applied + injective)
04:39:17 <phadej> but yes, wired-in magic type-families are weird.
04:39:26 <edwardk> the fact that + has some kind of privileged f'd up position explains a bit of how i get errors with it i can't get elsewhere
04:39:52 <phadej> re ground terms
04:40:01 <phadej> 5 + n ~ 8 does simplify to n ~ 3
04:40:11 <gpvs> I seek to explain to GHC that I want a Class. Class's requirement has a function. Function's "return" type must be instance of another specific Class. Here is what I tried and errors I got: dpaste.com/FTAG9S4MQ , dpaste.com/EG5RM5HXY
04:40:45 <edwardk> yet it can't figure out 1 + n ~ 1 + m => n ~ m
04:40:50 <phadej> no
04:40:56 <phadej> nobody told it *that* :)
04:41:03 <phadej> there isn't ring-solver in GHC
04:41:14 <phadej> (it's available as a plugin)
04:41:31 <phadej> https://hackage.haskell.org/package/ghc-typelits-natnormalise
04:41:34 <edwardk> yeah
04:41:47 <edwardk> was going to try the natnormalize plugin to see if i could use it to compile the pattern i need
04:42:19 <phadej> I guess Christiaan would appreaciate if you tell him that *it works for you* ;)
04:42:49 <ski> gpvs : so you want to associate each `type_self', that you make an instance for, with a particular `type_word'
04:43:15 <edwardk> let me add the example i'm fighting with to the repo
04:44:38 <gpvs> ski: If I got you correctly: I may, but where is no need to. AWord is good enough abstraction for Animal-s to work with, there is no need to bind particular animals to particular words
04:44:50 <kicov> Got a few cpsy + liquid haskell examples: https://dpaste.com/3YX484ND7 and https://dpaste.com/FHMQ5DZ44 - just wondering how both examples could work using single cpsy annotation.
04:45:02 <gpvs> ski: and if I must to associate it, how would I do that?
04:45:08 <edwardk> oh weeee, more regressions
04:46:03 <ski> gpvs : so you definitely don't want the `class Show type_self => Animal type_self where say :: AWord type_word => type_self -> [type_word]' version, since it means that if you pass a `AnimalSpecific' to `say', then `say' will have to be able to compute a list of `type_word's for any instance of `AWord' `type_word', that the caller wants, not just for the `AWordDog' instance
04:46:08 <edwardk> phadej: https://github.com/ekmett/haskell/tree/master/types is the project in question
04:46:31 <edwardk> if i compile with -f-injectiveSucc then examples/Vec.hs goes to hell
04:47:14 <ski> gpvs : so, it seems you either want an existential (but i suspect you don't actually want that here), or else you want to make `type_word' an additional parameter of `Animal' (possibly with a Functional Dependency)
04:47:26 <gpvs> ski: oh, now I got it. Any reason first approach should not work?
04:47:26 <edwardk> you may need to disable the construction of the SingI instances in Data.Type.Internal.TH as well here https://github.com/ekmett/haskell/blob/master/types/src/Data/Type/Internal/TH.hs#L122
04:47:36 <ski> gpvs : hmm
04:48:07 <edwardk> but if i write a manual data type that does it rather than emulate a GADT with my pattern synonym i can make it work *headdesk*
04:48:41 <ski> gpvs : "AWord is good enough abstraction for Animal-s to work with, there is no need to bind particular animals to particular words" -- but you just tried to associate `AnimalSpecific', not to arbitrary instances of `AWord', but specifically to `AWordDog'
04:48:46 <edwardk> but i can't have the actual data type because i need a homogeneous representation for my singletons or i lose a huge performance tax.
04:49:12 <ski> gpvs : that is, your implementation of `say' tried to do that
04:49:22 <phadej> edwardk: I only understood "right and slow vs. doesn't work fast"
04:49:30 <gpvs> ski: what's existential? could you provide a link or googling term please? I'm truing two avoid making type_word a parameter to Animal not to bind them
04:49:42 <edwardk> the cost is linear vs O(1)
04:49:51 <edwardk> i have hacked around every other obstacle in the way
04:50:00 <edwardk> this is the last farking leg
04:50:33 <ski> gpvs : do you want to require `say' to return a list of `type_word's, for some `type_word' that's an instance of `AWord' (but each `say' implementation should be allowed to pick which such `type_word' it wants) ?
04:51:05 <edwardk> in the process i dragged the Nat kind and hacked it to work like Natural as a type (which will just work when ghc does it for real), hacked Type to look like TypeRep, hacked Symbol to look like String, used stuck data families to get me ways to use Int and Char meaningfully as kinds.
04:51:21 <edwardk> and came up with a way to get constant time singletons
04:51:34 <edwardk> which works for everything except when my singleton gets fancy enough
04:51:39 <edwardk> and Nat is involved
04:51:41 <edwardk> because Nat is awful
04:51:51 <gpvs> ski: exactly. Any Animal's 'say' may return *any* value which is instance of AWord
04:52:01 <gpvs> ski: * a list
04:52:41 <ski> gpvs : could different elements of the list be of different types `type_word', provided all are instances of `AWord' ? or should all elements in the list be of the same type `type_word' ?
04:53:31 <gpvs> ski: I don't have requirement for/against it at the moment. could you please provide both verions?
04:53:40 <edwardk> phadej: that said, i really like using Type as Typeable.TypeRep. and then Type.Reflection.TypeRep becomes its singleton
04:54:01 <edwardk> very pretty code results
04:55:24 <ski> gpvs : hm, let's consider alternatives, and what they would mean
04:55:56 <Cale> I'm pretty sure from the looks of the code that made it into the channel that gpvs wants a fundep
04:56:08 <Cale> But maybe I missed something
04:56:25 <ski> gpvs : `class Show type_self => Animal type_self where say :: AWord type_word => type_self -> [type_word]' means that the caller of `say' will decide which `type_word' to pick, can pick any, as long as its an instance of `AWord'. and you said you don't want that
04:57:03 <Cale> gpvs: The type of the result should depend on the type of the input, right?
04:57:58 <edwardk> looks like ghc-typelits-natnormalise isn't able to help solve the 1 + n ~ 1 + m    ==> n ~ m problem
04:58:18 <edwardk> i get the same issue with the plugin enabled
04:58:49 <gpvs> ski: I don't want the rigid return type to be defined at type instantiation moment. I'm interesting in both version where return type is define on call or by implementation itself
04:59:01 <Cale> edwardk: Can you use unsafeCoerce to get yourself out of that?
04:59:03 <edwardk> the problem is that i'm neck deep in a pattern synonym at the time it happens and can't. really get both n and m in type in scope to unsafeCoerce my way to glory
04:59:04 <ski> gpvs : `class (Show type_self, AWord type_word) => Animal type_self where say :: type_self -> [type_word]' means that you have associations between particular `type_self's and particular `type_word'. so, for a particular `type_self', you don't need to have all possible instances `type_word' of `AWord' to consider. you could just have some of them, if you'd like to. also, you could enforce it to be at most one `type_word', if you'd want to
04:59:16 <Cale> ahh
04:59:20 <edwardk> i've been trying ever more esoteric dances to make that work
04:59:46 <Cale> Pattern synonyms are jankier than I ever imagined they might be
04:59:53 <gpvs> Cale: optionaly, but I don't want to bind Animal instances to particular AWord-s instances
05:00:20 <edwardk> https://github.com/ekmett/haskell/blob/master/types/example/Vec.hs#L49 the issue is it can't figure out ys is well typed there.
05:00:45 <Cale> gpvs: Maybe the solution is just a simple two parameter type class then
05:00:59 <edwardk> there is another issue involving the SingI instance but i can hack around that by moving the type synonym around
05:01:11 <Cale> gpvs: Though, that won't be terribly *convenient* since you'll probably have to annotate the type of the result a lot, given that it can't be determined by the type of the input
05:01:19 <edwardk> Cale: i'm doing evil things in there
05:01:48 <ski> gpvs : the last option is existentials, which here would be either `class Show type_self => Animal type_self where say :: type_self -> exists type_word. AWord type_word *> [type_word]' or `class Show type_self => Animal type_self where say :: type_self -> [exists type_word. AWord type_word *> type_word]'. both of these will allow the choice of `type_word' to depend on the run-time input to `say' (if you don't want that, that could be corrected)
05:01:48 <edwardk> Cale: in particular i'm emulating GADTs on a non GADT using pattern synonyms and another GADT as a helper to sort of scaffold all the equalities i need
05:02:01 <gpvs> Cale: resulting types will bind particula Animals to particular Words then, wouldn't they?
05:02:05 <ski> (er, possibly cut off part was "(if you don't want that, that could be corrected)")
05:02:05 <edwardk> the scaffolding GADT is just unsafeCoerced to offer what i need
05:02:49 <gpvs> Cale: I've just read what fundeps are and I believe it's not what I want
05:04:01 <edwardk> pattern SVCons :: forall k (n :: Nat) (r :: Vec k (1 + n)). () => forall (x :: k) (xs :: Vec k n). r ~ 'VCons x xs => Sing x -> Sing xs -> Sing r; pattern SVCons y ys <- ( upSVec -> SVCons' y ys) where SVCons (Sing y) (Sing ys) = UnsafeSing (VCons y ys); should basically faithfully emulate the GADT constructor that it delegates down to for proof
05:04:08 <Cale> gpvs: It would mean that, say, given that you have a list of Cats as input, then the type of words that Cats produce would be determined by the fact that they are Cats
05:04:21 <Cale> For example, maybe Cats produce Text
05:04:24 <edwardk> upSVec casts from Sing x -> SVec' x
05:04:28 <gpvs> ski: "means that the caller of `say' will decide which `type_word' to pick, can pick any" how do I express it in Haskell from the callers perspective?
05:04:36 <edwardk> but the constructor for SVec' is well typed and happy
05:04:50 <edwardk> i just can't figure out the right way to pass through the lesson from SVec' to Sing
05:04:57 <Cale> gpvs: That's just the two-parameter class with no functional dependencies
05:05:04 <edwardk> when it matches it learns a heterogeneous type equality
05:05:28 <Cale> gpvs: and you can write type annotations like (say cats :: [Text]) to determine the type of result then
05:05:46 <Cale> (or if it's determined by how the result is used, that's also fine
05:05:48 <Cale> )
05:05:48 <ski> gpvs : that option was already expressed in Haskell. i dunno what you mean by "from the callers perspective" (i was already talking there about it being the caller who got to pick `type_word' there)
05:05:48 <edwardk> that the output type is carrying an argument of kind Vec k (S n) relative to Vec k n for the inside argument to the vector.
05:08:08 <edwardk> -- just works (S n = 1 + n as a type synonym, Z = 0) -- so now what i want is a pattern synonym as a next step that just basically wraps SVCons0  https://www.irccloud.com/pastebin/j3dAUDko/svec0
05:08:19 * hackage binaryen 0.0.4.0 - Haskell bindings to binaryen  https://hackage.haskell.org/package/binaryen-0.0.4.0 (terrorjack)
05:08:39 <edwardk> if that data type didn't type check this wouldn't be so infuriating
05:08:45 <edwardk> because i'd know it was impossible
05:08:48 <gpvs> ski: `class Show type_self => Animal type_self where say :: AWord type_word => type_self -> [type_word]' I got error trying to compile it. It's in https://dpaste.com/EG5RM5HXY . Did I missed some required extensions?
05:08:50 <edwardk> but that is just hunky dory
05:09:06 <Cale> edwardk: hmm, think I'll have to fire up ghci here... :)
05:10:37 <gpvs> ski: this `class (Show type_self, AWord type_word) => Animal type_self where say :: type_self -> [type_word]' got me compile error too. https://dpaste.com/FTAG9S4MQ
05:10:38 <ski> gpvs : no, your `say' implementation doesn't satisfy that type signature
05:10:55 <ski> (the `say :: AWord type_word => type_self -> [type_word]' one, i mean)
05:11:25 <Cale> gpvs: You need another parameter on the class there
05:11:50 <Cale> gpvs: class (Show s, AWord w) => Animal s w where say :: [s] -> [w]
05:11:51 <ski> gpvs : oh, sorry. the middle alternative should have been `class (Show type_self, AWord type_word) => Animal type_self type_word where say :: type_self -> [type_word]' .. iow MPTC
05:12:06 <ski> Cale : no list input
05:12:29 <Cale> oh
05:12:31 <Cale> okay
05:12:38 <Cale> yeah, just s -> [w] in that case
05:13:49 <ski> gpvs : anyway, perhaps we should first try to determine what you want, before diving into the how ?
05:14:02 <edwardk> Cale: i have it boiled down to one file now
05:14:29 <edwardk> https://www.irccloud.com/pastebin/KHWDco0s/BrokenVec.hs
05:14:45 <edwardk> that is standalone and doesn't need the types library i'm writing
05:15:06 <Cale> ah, cool
05:15:53 <gpvs> Cale, ski: ok, as far as I can see to get a uniform list of instances I *must* bind types like with multiparam class. What about getting a non-uniform list? Like when Cat can say [WordType0, WordType2].
05:16:19 <Cale> gpvs: Well, what do those word types have in common? What are you going to do with the resulting list?
05:16:40 <ski> gpvs : you could do that, too, with existentials
05:16:44 <gpvs> ski: I want something like returning an array of objects confirming to interface in OO-kind stuff
05:16:48 <Cale> gpvs: You can think of a type as representing permissions to use the corresponding values in particular ways. If you don't know what type something is, it becomes impossible to observe
05:16:57 <ski> gpvs : yea, that sounds like existentials
05:17:10 <gpvs> Cale: those word types all are instances of AWord class
05:17:14 <ski> gpvs : however, often this is not a good idea / overkill. but you can do it
05:17:14 <PropositionJoe> Why do I have to write "`div`" instead of just div?
05:17:25 <Cale> Yeah, existentials give you one way to discard information about what type of thing you have
05:17:32 <ski> > div 18 7  -- PropositionJoe
05:17:35 <lambdabot>  2
05:17:36 <edwardk> > div 4 3
05:17:38 <lambdabot>  1
05:17:39 <edwardk> works for me
05:17:52 <PropositionJoe> so div is prefix "`div`" is infix?
05:17:55 <ski> yep
05:17:57 <Cale> data SomeWord where MkSomeWord :: AWord w => w -> SomeWord
05:18:02 <PropositionJoe> thanks ski
05:18:09 <edwardk> putting backticks on makes anything infix
05:18:11 <ski> PropositionJoe : works for any identifier
05:18:12 <Cale> (that uses the GADTs extension)
05:20:03 <ski> gpvs : `AWord' class currently has no methods (and no superclasses). so `exists type_word. AWord type_word *> ..type_word..' is kind of pointless, you can't get any information out. but perhaps your shown `AWord' was a mockup, and you'll actually have useful methods or superclasses ?
05:21:24 <Cale> gpvs: In my example, applying the MkSomeWord data constructor to a value whose type w is an instance of AWord will result in forgetting everything about which type w was, except that it had an instance of AWord, and then the only things you'll be allowed to do with the value when you get it out will be things you could do with any unknown instance of AWord
05:21:29 <ski> gpvs : "I want something like returning an array of objects confirming to interface in OO-kind stuff" -- do you actually need that ? how are you going to use the result of calls to `say' ? (Cale's question)
05:21:59 <gpvs> Cale, ski: looks like downcasting to me. Seems like I getting closer. I understand it doesn't make a lot sense in Haskell, just trying of how far it can extend. Yes, AWord is a mockup
05:22:05 <Cale> If you want to be more like OO, it might be more sensible just to make object types which correspond to whatever your classes would have been
05:22:23 <ski> gpvs : there is no downcasting in Haskell, really
05:22:26 <Cale> Don't try to use Haskell classes as OO classes, they're not the same thing
05:22:51 <Cale> Instances of OO classes are values, instances of Haskell classes are types.
05:22:51 <gpvs> ski: yes, I sayed that making a parallel to what it would be for me in OO
05:22:54 <ski> gpvs : and how would you use downcasting, anyway ? test for particular types ? why not use a sum type ?
05:23:26 <Cale> Haskell classes are a good bit like interfaces though
05:23:39 <Cale> But usually it makes more sense not to start from there
05:24:02 <Cale> What methods were you going to put in the AWord class?
05:24:02 <ski> gpvs : if `AWord' is beefy enough for you to be able to do something sensible with values of an unknown type `type_word' that's an instance of `AWord', then existentials start to make more sense
05:24:12 <gpvs> ski, Cale: "data SomeWord where MkSomeWord :: AWord w => w -> SomeWord" ok, maybe 'downcasting' is not the best term. Let me call it 'specialization' then.
05:25:03 <gpvs> ski: yes, AWord in dpaste is a mockup
05:25:11 <ski> yea, i got that
05:25:49 <ski> gpvs : by "downcasting" i meant being able to do e.g. `toAWordDog :: AWord w => w -> Maybe AWordDog'
05:26:09 <gpvs> Cale: I will not try to do OO with Haskell, pinkie-promise! :) Just looking at cases while learning.
05:26:15 <ski> gpvs : that is the kind of thing you had in mind, yes ?
05:27:18 <gpvs> ski: nodes of graph of different types and constructs which can reference each other regardless, relying on fact that all of them confirm to the basic interface
05:27:46 <ski> gpvs : which question is that an answer to ?
05:28:20 <ski> (it doesn't seem to obviously be about how to use downcasts, e.g.)
05:29:17 <Cale> gpvs: Well, I think doing OO with Haskell can be quite good in some cases. The encoding, if you do it right, is indistinguishable from ordinary functional programming. You have first class functions and you have record types. Put those together, and you can make records of methods which can be defined differently for each value you construct.
05:29:27 <ski> Cale : although you call interface methods on an object :)
05:29:35 <Cale> gpvs: i.e. you don't need subclasses to override method implementations
05:29:46 <Cale> (which is good, since you don't have subclasses)
05:30:16 <gpvs> ski: I misread 'that' as 'what', sorry. It seems like that. Have to research existentials and try in ghc.
05:30:37 <Cale> I would honestly avoid existentials initially
05:30:47 <Cale> Most of the time, you won't really need them
05:30:58 <ski> @where existential-antipattern
05:30:59 <lambdabot> "Haskell Antipattern: Existential Typeclass" by Luke Palmer at <http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/>
05:31:57 <gpvs> ski, Cale: thank you for your help! Will research existentials and try them for my case, just to know it's there. If you wondering, the original idea was "nodes of graph of different types and constructs which can reference each other regardless, relying on fact that all of them confirm to the basic interface"
05:31:58 <Cale> gpvs: The important question to think about first is "what am I allowed to do with these things?" -- if you can figure out all the things you're allowed to do with a thing, then one of the ways of defining its type is just as a collection of the results of those operations
05:32:00 <ski> gpvs : if we saw the actual `AWord' class, or if you told how you were going to use the results of `say', or both, we might be able to give better advice
05:33:03 <ski> gpvs : that's a pretty vague, non-committal description
05:33:22 <gpvs> lamdabot: thanks for the link
05:34:26 <ski> gpvs : (a) often you don't want/need OO-style things; (b) if you do, ordinary lexical scoping with records commonly suffice; (c) sometimes existentials may be required
05:34:51 <bicho_rastrero> I'm learning haskell and I saw this syntax in a function "merge list1@(x: xs) list2@(y : ys)", what is the name of the @ operator there? How is that structure named?
05:34:57 <ski> gpvs : you should probably not reach for existentials, unless you really need them
05:35:46 <ski> bicho_rastrero : "as-patterns"
05:35:52 <gpvs> ski: part I stumbled on is the last part of description. Any type of class node should be able to return a list of nodes it's connected to, these nodes might be of different types, but of the same base class.
05:36:09 <bicho_rastrero> Thank you, ski 
05:36:38 <ski> bicho_rastrero : it's both giving a name to the whole input, and simultaneously matching it with a pattern, so that you can check its shape, and name parts
05:37:21 <bicho_rastrero> Yeah, that was my understanding, but I wanted to read an proper explanation with more examples. Thanks.
05:37:25 <ski> gpvs : yea, it sounds like you could possibly do that with just (b)
05:37:38 <ski> (depending on the specifics of what you want to do with them)
05:37:52 <ski> gpvs : iow the record-of-operations that Cale mentioned
05:44:49 <Cale> edwardk: Ah, so annoying to try to get these n1 and n2 in scope...
05:44:56 <edwardk> exactly!
05:45:27 <Cale> It's not even syntactically permitted to write something like pattern SVCons y (ys :: ...)
05:47:06 <edwardk> i fought with writing (\x -> case upSNat x of ... -> (sometypeequality,y,ys) ) -> (Refl,y,ys))
05:47:14 <edwardk> for the viewpattern
05:47:21 <edwardk> but that didn't move the needle much
05:47:47 <edwardk> if S is replaced with data family S :: Nat -> k -- this just works
05:48:06 <edwardk> but then i'm adding exotic types to kind Nat
05:48:08 <Cale> I wrote this thing: onePlusInj :: forall n m r. ((1+n) ~ (1+m)) => (n ~ m => r) -> r  but of course, I need to disambiguate which types I want to use it with
05:48:17 <edwardk> yeah
05:48:20 <edwardk> did the same
05:48:24 <Cale> The idea being that maybe we can stick it in using a view pattern
05:48:38 <edwardk> thats the sort of thing the scenario above tried to use
05:48:46 <Cale> yeah, I see
05:48:48 <Cale> hmm
05:48:48 <edwardk> the someTypeEquality thing there can be a refl built
05:49:02 <edwardk> and in there i can see x and the types of y and ys
05:49:15 <edwardk> before i return them out to the surrounding context 
05:52:03 <kicov> Hi, one more question about liquid haskell : are annotation such as `function :: f:(Int -> Int) -> {ret : Int | f ret == 0}` possible, or is something similiar also possible ?
05:52:17 <Cale> btw, I love the super janky required () => in the type of the pattern synonym
05:52:30 <Cale> It inspires so much confidence in GHC
05:53:09 <edwardk> i also run into problems when i go to write the SingI instance. morally its instance (SingI a, SingI b) => SingI ('VCons a b) -- but the argumentthere has a type synonym in it!
05:53:40 <edwardk> which prevents me from hanging the instance
05:53:41 <Cale> I wonder... can we bind (kind/type) variables in the pattern's type signature? Does that work?
05:53:54 <edwardk> oh let me give you a longer worked version
05:54:07 <edwardk> yes
05:54:40 <edwardk> forall variables. (context needed to call the pattern) => forall more variables (stuff you learn by binding the pattern) => pattern args -> pattern result
05:54:51 <edwardk> the two context thing is deliberate
05:54:54 <edwardk> it was the chosen syntax
05:55:00 <edwardk> by ghc ghc
05:55:03 <edwardk> er ghc hq
05:55:18 * hackage inline-c 0.9.1.1 - Write Haskell source files including C code inline. No FFI required.  https://hackage.haskell.org/package/inline-c-0.9.1.1 (FrancescoMazzoli)
05:55:38 <edwardk> to disambiguate between what you need to call the pattern (like fromjson, tojson, etc.) and what you learn by matching. (like GADT existential args)
05:58:46 <gpvs> lambdabot: <https://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/> yeah, this actually made sense for me once I recalled there is currying
05:59:01 <gpvs> ski, Cale, lamdabot: thank you for your help!
06:04:56 * ski suspects gpvs meant "partial application"
06:08:49 <Cale> edwardk: I got... something... to compile
06:09:04 <Cale> I'm not sure if it's not just completely fucked, one sec :D
06:09:05 <edwardk> i have a few versions that compile, but none that learn when they match
06:10:14 <edwardk> pattern SVCons :: forall (k::Type) (x::k) (n::Nat) (xs :: Vec k n). () => () => Sing x -> Sing xs -> Sing ('VCons x xs :: Vec k (S n)); pattern SVCons a b <- (upSVec -> (SVCons' a b :: SVec' ('VCons a b))) where SVCons (Sing y) (Sing ys) = UnsafeSing (VCons y ys)   
06:10:57 <Cale> Yeah, that looks pretty similar
06:11:56 <edwardk> all of this is to hack around the injectivity of succ, if it was there i could just use literally the same code i generate via template haskell for everything else
06:12:18 <Cale> oh wait, what if we just need r ~ 'VCons x xs twice?
06:12:27 <edwardk> but if i get gimped by any attempt to use kind nat, which perforce infects Int and other numeric types i lift i get screwed up
06:12:29 <edwardk> ?
06:13:07 <edwardk> oh, the ~ there is probably going to be a ~~
06:13:25 <edwardk> the starting Vec k n needs to learn it is Vec k n' but that is the kind for the argument type
06:13:37 <edwardk> so you need to learn both the kind and the type
06:13:41 <edwardk> which is ~~'s job
06:13:54 <Cale> Do you have an example usage handy?
06:14:08 <Cale> (of using the pattern synonym to learn the equality)
06:15:05 <edwardk> https://github.com/ekmett/haskell/blob/master/types/src/Data/Type/Internal.hs#L435
06:15:19 <edwardk> each of the patterns in there and all the ones generated by TH learn the result type
06:15:29 <edwardk> but the result argument's kind doesn't change unlike here
06:17:45 <edwardk> when working with a S that is injective, (e.g. using the data family hack) you can just write
06:17:48 <edwardk> pattern SVCons :: () => (r ~ 'VCons a b) => Sing a -> Sing b -> Sing r; pattern SVCons a b <- (upSVec -> SVCons' a b) where SVCons (Sing y) (Sing ys) = UnsafeSing (VCons y ys)
06:17:52 <edwardk> like every other instance
06:18:01 <edwardk> and my TH would have a hope in hell of autogenerating it
06:33:25 <edwardk> the main concern about dumping an S into kind Nat like that though is that you get two types that produce the same value, and i can't create a custom KnownNat instance for instance KnownNat n => KnownNat (S n) -- so i can only make an overlapping instance of SingI (S n)
06:33:34 <edwardk> and overlapping makes me sad
06:40:22 <edwardk> Cale: https://github.com/TimWSpence/stitch/blob/master/src/Language/Stitch/Exp.hs#L158
06:40:53 <edwardk> SVec ~ Sing here
06:41:30 <edwardk> TypeRep a there is Sing (a :: Type) here
06:42:03 <edwardk> exprType :: Sing ctx -> Exp ctx ty -> Sing ty
06:42:40 <edwardk> comes about from the types library mashing everything into one rep
06:49:19 <Cale> On the one hand, this is all kind of cool, on the other hand, it's definitely crossing the line into dependently-typed stuff that I think Haskell just plain isn't good at yet. I think if you actually need explicit singletons, that's a pretty good indication of "oops, Haskell is going to suck at this". I wonder how long until we can realistically have a working pi.
06:51:48 * hackage inline-c 0.9.1.2 - Write Haskell source files including C code inline. No FFI required.  https://hackage.haskell.org/package/inline-c-0.9.1.2 (FrancescoMazzoli)
06:56:09 <edwardk> well, i have been building a little dependent type checker in haskell, and every time i move more stuff into my types i catch more bugs =)
06:56:30 <edwardk> so i'm just trying to push a few more things into them
06:56:39 <edwardk> which is what prompted the singleton push
06:56:58 <edwardk> getting the singleton stuff to be super fast and more homogeneous made me happy, til Nat made me sad
07:08:57 <edwardk> i suppose what i could do is build a type data Unnat = Add Int# Nat -- relying on the fact that Int# doesn't promote so we don't have to worry about any 'native' terms in kind Unnat. use my data family trick to inject a S constructor, and one for, so that it morally models data Unnat = S Unnat | N Nat -- so i can distinguish between the base number type i got from type Nat and the number of times i called S on it
07:09:17 <edwardk> that way i don't need to worry about S 1 ~ 2 causing the universe to collapse or something
07:11:09 <edwardk> another another option is to just do what I do now which is use an hlist and carry a witness of the length around rather than use Vec a N
07:11:38 <Cale> Also, I haven't really thought very hard about how this suggestion might help, but generally I think if you're going to use overlapping instances in order to compute things, everything is okay in the case that you can manage to avoid exporting the class.
07:11:59 <edwardk> the class here is a very public offering
07:12:03 <Cale> yeah
07:12:27 <edwardk> i was hoping to split this out and ran into this issue while writing up examples
07:13:05 <edwardk> i had started looking for 'all the instances i can add to base' when i ran afoul of this
07:13:09 <Cale> I don't know if there's a way to make a private analogue and get anything related to what you want (like, make a public instance for that class that depends on an instance of the class that nobody's allowed to see, maybe)
07:13:10 <edwardk> er from base
07:14:07 <edwardk> i'm inclined to just yolo the data family S thing
07:14:12 <edwardk> and go on with my day
07:14:18 <edwardk> and if it bites anyone say 'don't do that'
07:15:25 <edwardk> data family S' :: Nat -> k; type S :: Nat -> Nat; type S = S' -- just works .. til you need to feed it to + and want + to actually compute, because they closed the type family for +
07:15:39 <edwardk> but i could offer my own + and have it delegate to the main + once i changed out the S's
07:16:09 <edwardk> but then the benefit of working with base Nat is fleeing fast
07:19:59 <edwardk> i want a way to export a thing only at the type level without having to infect it with a type like Type that doesn't exist as a term.
07:20:13 <edwardk> where i can have constructors in it, without using my data families
07:21:13 <edwardk> leaning towards exporting my own Nat type, ignoring the TypeNats Nat and going on my way.
07:22:08 <edwardk> since Natural currently doesn't promote i _could_ use the data family hack to put Z and S in it as a kind.
07:22:37 <edwardk> then you could use linear time slow SingI instances if you had to
07:23:38 <edwardk> and i'd have both Nat and Natural, with the former working for when i want a large literal and the latter when i want induction for things like environments that'll usually get built from 0, til... next ghc release or so when they merge Nat and Natural
07:24:22 <edwardk> to make the linear time thing less awful, i could emulate a better basis, like binary nats, or zeroless binary or something.
07:25:31 <edwardk> that'd get me log time literals, and Z and S become type families acting on the type, but they require more type information about the rest of the nat to know what to do at some points
07:26:04 <edwardk> where peano can succ without forcing or matching on anything
07:27:26 <Cale> Yeah, how does merging Nat and Natural work with type families wanting to compute anything?
07:27:39 <Cale> I mean, in the future GHC case
07:29:17 <Cale> I guess they just have wired in type families anyway
07:29:54 <kicov> Hi, just one more question - did someone try to use liquid haskell on lens? Got any tips how to write these annotations? `fn :: Int -> Lens' State a` doesn't work well
07:31:21 <Cale> Is liquid haskell getting to the point where it can be used on nontrivial programs?
07:31:41 <kicov> Just for reference: https://dpaste.com/H877D9HQU
07:34:40 <Cheery> Haskell's still using STG in the runtime right?
07:35:38 <lechner> Hi, will findFiles from System.Directory descend into subdirectories?
07:36:39 <Cale> Cheery: In name more than anything
07:38:38 <edwardk> well, i suppose what i can do is this. i'll make Z and S hacks that can inhabit kind Natural for now. and when they merge I'll just take the name Nat and move them over there =)
07:39:02 <Cheery> Cale: the 1992 paper describes the design space and abstract machine with denotational and operational semantics. Is this still the same?
07:39:30 <edwardk> Cheery: the STG has gotten a few upgrades since then, dynamic pointer tagging, etc.
07:39:41 <edwardk> but the general flavor is there
07:39:44 <Cale> Understanding the original STG will still give a decent understanding of what exists today, even though it's no longer always spineless and usually no longer tagless
07:40:35 <Cale> http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.19.411&rep=rep1&type=pdf -- "Putting the Spine back in the Spineless Tagless G-Machine"
07:41:04 <Cale> https://simonmar.github.io/bib/papers/ptr-tagging.pdf -- "Faster laziness using dynamic pointer tagging"
07:44:14 <Cheery> I thought I do one last thing with RPython. Exploring eval/apply interpreters and STG. I'll see if there's something to propose in place of Javascript so that there's less room for people to replace it with crap.
07:44:34 <Cheery> a nice FP runtime. :)
07:45:41 <Cheery> Also would love for an efficient logic programming runtime slipped in, but I'll try to not scope creep much.
08:03:08 <Orbstheorem> If building a derivation is a linear process, why doesn't nix cache intemediate build steps ? (e.g.  git@`buildPhase::c1kj2h31...`)
08:08:47 <Orbstheorem> Oh, my bad, wrong buffer ><"
08:18:11 <sm[m]> hi lechner, doesn't it's doc say ?
09:09:40 <lechner> sm[m]: I am not sure. I can only see the "given list of directories"---which is elaborated on but not otherwise expanded to recursive behavior in the reference to findFilesWith here:  https://hackage.haskell.org/package/directory-1.3.6.1/docs/System-Directory.html#v:findFiles
09:22:45 <thir> #bitsnbugs
09:31:49 * hackage uniqueness-periods-vector-examples 0.5.3.0 - Examples of usage for the uniqueness-periods-vector series of packages  https://hackage.haskell.org/package/uniqueness-periods-vector-examples-0.5.3.0 (OleksandrZhabenko)
09:48:23 <sm[m]> lechner: you're right, it's not crystal clear, but yes I'm 99% sure it descends. Probably you tested it by now
09:54:04 <nshepperd2> whoa i just converted this dynamic programming-based tokenization thing from a laziness based pure Vector implementation to a mutable unboxed vector in ST, and it got like 100 times faster
09:55:01 <ski> top-down to bottom-up ?
09:56:14 <nshepperd2> I'm not quite sure what those terms mean, but yes I think so
09:57:37 <nshepperd2> the lazy one was let table = V.generate (n+1) go; go = ...; in table!n
09:58:06 <nshepperd2> the fast one was to make a mutable unboxed vector and fill it out in order from 0 to n
09:58:10 <ski> where `go' referred to `table'
09:58:16 <nshepperd2> yeah
09:58:38 <sshine> >_<
09:58:45 <ski> hm, what kind of access pattern ?
09:59:47 <nshepperd2> 'go i' would reference some or all cells between i-5 and i-1
09:59:55 <hekkaidekapus> sm[m]: The 1% wins again :p It does not descend. At its core, the function calls doesFileExist to the supplied dirs.
10:00:41 <hekkaidekapus> doesFileExist (dir </> file)
10:00:45 <ski> "bottom-up" means that you fill in the "lower cells", before the higher ones, "prematurely" so to speak. "top-down" that you start demanding higher ones, which in turn demands lower ones (which are cached)
10:01:00 <dolio> There's a lot of overhead in the top-down lazy approach.
10:01:15 <dolio> If you're working with integers.
10:02:09 <nshepperd2> ski: then yeah, that's exactly what i did
10:02:20 <ski> nshepperd2 : i suppose you could even use a five-tuple, or a vector of size five, then
10:03:58 <dolio> Yeah, like computing fibonacci with an accumulator pair.
10:04:32 <ski> (you'd use `mod i 5')
10:05:31 <ski> i suppose the computation of the next cell isn't a linear function of the previous five ones ..
10:07:42 <ski> nshepperd2 : probably the lazy approach would work better, in case there's many cells which aren't needed to compute the result
10:08:32 <dolio> Yeah, there are a lot of factors making it sub-optimal for this case.
10:10:58 <sshine> I have a data type, data Foo a = X a | Y a | Z a | P | Q | R; and I'd like to make a type NumFoo = forall n. Num n => Foo n, but it seems that I can't do that. what are my alternatives? I was thinking of a data type with a type class constraint.
10:11:21 <sshine> I think I can use GADTs, but that would require me to alter 'Foo', too, right?
10:12:16 <nshepperd2> ski: yeah in this case pretty much all cells are eventually needed
10:13:51 <ski> sshine : why can't you ?
10:13:55 <hyperisco> sshine, what is the idea of this type? I don't understand
10:14:48 <ski> a value of type `NumFoo' possibly contains a number of any numeric type the user wants to get
10:23:15 <zebrag> I believe `cons :: a -> List l a -> List (Succ l) a` cannot be done with plain GADT? (The following ref, might suggest it could be done?? https://www.cis.upenn.edu/~sweirich/talks/GADT.pdf, page 9)
10:24:07 <hyperisco> zebrag, is there a compiler error you're seeing?
10:24:39 <zebrag> At least if you consider `Succ` is a data constructor
10:25:00 <zebrag> hyperisco: no I'm just reading the slides above
10:26:21 <hyperisco> all I don't understand is how that is an example of dependent types
10:26:42 <hyperisco> what is your objection?
10:29:30 <Cale> sshine: Just replace "type NumFoo = ..." with "data NumFoo = ..." and what you wrote is valid code, if a little bit useless. Forgetting everything about the type of number except that it was a type of number will mean that you can't really do a whole lot with it (in particular, you won't know that it's the same type as any other type of number, so the arithmetic you can perform is very limited)
10:30:34 <Cale> sshine: Or did you really want to define a type synonym for the universal type?
10:31:30 <c_wraith> Cale: it's a bit worse than that since Show is no longer a superclass of Num.  Num doesn't give you any eliminator to see the value.
10:31:39 <Cale> Right
10:31:49 <Cale> and Eq is gone too
10:32:10 <c_wraith> Eq would be pretty useless, though, unless you wanted to test for lack of reflexivity or something
10:32:38 <Cale> You could test out arithmetical identities involving your one value of the given type :)
10:33:03 <c_wraith> hah.  is x + x == x ?  :)
10:33:07 <Cale> yeah
10:33:30 <hyperisco> no
10:34:05 <Cale> (that's essentially the same as checking if x == 0, if the instance is lawful)
10:34:10 <c_wraith> I suppose the Num instance would let you throw in literals too, so you could ask if x * 0 == x
10:34:42 <c_wraith> That's not true in a modular ring
10:35:02 <c_wraith> Oh, I guess it is.  nevermind me!
10:35:11 <phadej> x * 0 = 0, not x ?
10:35:35 <Cale> That was another equation that would only be satisfied when x == 0
10:35:48 <c_wraith> Anyway.  The real point is that a value of an unknown type with a Num instance is very low.
10:35:49 <Cale> (again, a fun thing to check holds in any ring)
10:35:59 <hyperisco> I guess you can use this to dynamically determine which laws might hold
10:36:17 <c_wraith> If you add in Eq, you can do that
10:36:28 <c_wraith> but with *just* Num, you've got basically nothing.
10:36:46 <hyperisco> I feel like Num without Ord is amiss
10:37:13 <c_wraith> so...  not a fan of complex numbers?
10:37:44 <hyperisco> you telling me they can't be ordered or are you telling me Ord is too strong
10:38:00 <merijn> hyperisco: There's two separate and equally valid orderings for them
10:38:04 <geekosaur> they can't be ordered
10:38:07 <merijn> Well, technically probably more
10:38:16 <geekosaur> or, what merijn said.
10:38:17 <merijn> But they can't be ordered in a arithmetically meaningful way
10:38:28 <merijn> hyperisco: Consider this
10:38:43 <merijn> hyperisco: Is "1 + 0i" > than "0 + 1i" or not?
10:39:16 <geekosaur> basically "Ord" only makes sense if they can be squashed down to a line without data loss. complex numbers, quaternions, etc. have infinitely many such squashings, none of which has any claim to being primary
10:39:27 <hyperisco> so you're telling me Ord is too strong
10:39:44 <merijn> You could argue Num should be Eq
10:39:51 <merijn> Which, in fact, the Haskell Report does
10:39:58 <merijn> GHC ignores that, however
10:40:05 <hyperisco> what about the cherished function instance though
10:40:11 <merijn> The report also mandates a Show instance as superclass of Num
10:40:20 <merijn> hyperisco: Those aren't legal per the report
10:40:29 <merijn> Since they can't have Eq or Show
10:40:36 <hyperisco> well the report can stuff itself in regards to Num
10:40:51 <merijn> hyperisco: Well, you wanted Ord
10:40:55 <merijn> hyperisco: Which requires Eq :p
10:40:56 <hyperisco> it started this mess
10:41:06 <merijn> hyperisco: So insisting on Ord for Num kills that instance too :p
10:41:22 <merijn> It's easy
10:41:23 <monochrom> "forall n. Num n => n" is very likely the same as "Integer".
10:41:35 <hyperisco> if you think I'm giving one consistent position here, I'm not
10:41:41 <merijn> Num is perfectly adequate if you just give up on any notion of "math" definitions of arithmetic
10:42:00 <merijn> hyperisco: There've been 50 different Num hierarchies "better" than the current one proposed
10:42:18 <merijn> But no one uses them, because they're all a pain for anything anyone actually cares about doing
10:42:18 <phadej> Num is an unsuccessful attempt to unify operations on `Integer` and `Double`
10:42:27 <monochrom> But you can't squash down those 50 alternatives down to a line. :)
10:42:37 <hyperisco> I doubt it
10:42:42 <merijn> Turns out the current Num hierarchy does passably well at "stuff people actually care about"
10:42:55 <phadej> right now I think that exact and inexact math should just had different operator set :)
10:42:56 <Cale> I think Num is pretty okay at the moment. The main things which always bothered me before were the Show and Eq constraints, and those are gone.
10:42:57 <merijn> hyperisco: Well, feel free to work out and propose alternative 51 :)
10:43:01 <hyperisco> no
10:43:04 <merijn> Maybe this time someone will get it right :)
10:43:25 <hyperisco> PureScript has a different hierarchy and soils it with invalid instances
10:43:37 <Cale> signum/abs being there is a little weird perhaps, but those are always definable in some fashion
10:43:37 <monochrom> I am somewhat bothered by the opposite, Cale. For example allowing X->Integer to be a Num instance.
10:43:43 <hyperisco> but other than that, I've personally found ample utility in it
10:44:05 <merijn> I have no clue about purescript's hierarchy
10:44:20 <hyperisco> it is more disciplined than a bag called Num
10:44:28 <phadej> I think PureScript makes the same mistake, by having e.g. Double as part of "the only numeric hierarchy"
10:44:43 <hyperisco> but then it goes and gives the usual Double instance and pretends Int is Integer
10:45:05 <monochrom> Then again I'm bothered by signum and abs, too.
10:45:07 <merijn> hyperisco: Well, what's the alternative?
10:45:20 <merijn> Do an Ocaml and use a different + for Int and Double?
10:45:29 <monochrom> Yes.
10:45:33 <hyperisco> I recommended that
10:45:46 <merijn> That's one of the worst things in ocaml >.<
10:45:53 <monochrom> It is why I came over to Haskell. :)
10:45:58 <hyperisco> though the issue starts at division, not +, for Int
10:46:20 <hyperisco> so long as we're willing to accept the reality that Int is a modular ring
10:46:31 <merijn> hyperisco: Well, how is your hypothetical hierarchy going to unify + for Int and Double and not get this "wrong instance" for Double you're complaining about
10:46:36 <hyperisco> a hard thing for programmers to do, seems
10:46:52 <hyperisco> well that's easy
10:46:59 <hyperisco> you just cast Double out of the hierarchy altogether
10:47:05 <merijn> Right
10:47:20 <merijn> So then + doesn't work on Double, but you just said the division start at division
10:47:27 <hyperisco> and then you do the harder thing of figuring out truthful axioms for Double
10:47:46 <hyperisco> for Int it does
10:48:10 <hyperisco> for Double the problem started at the beginning
10:48:16 <dolio> Maybe you could accept that not every type class needs to be a grand mathematical design, and sometimes people just want to overload stuff.
10:48:45 <hyperisco> frankly that isn't why I use these languages
10:49:37 <hyperisco> and I find it bemusing how concerned people get about overloading syntax
10:50:13 <hyperisco> how do we get on if + cannot be used for both Int and Double in the same module
10:53:39 <maralorn> I wanna design a small library and am uncertain about the design. I want to specify A) a data type representing certain dialog interactions with a user (like a menu, a text input, a yes/no question) and B) multiple implementations of IO actions that execute that dialog. So far so easy. But now I wonder how I can make the type of possible dialogs composable and giving the handlers an option to specify which types of dialogs
10:53:39 <maralorn> they support. And I wonder if that's worth it. Because for my use case I could probably just have one data type for "dialogs" and extend it whenever I need to.
10:54:39 <hyperisco> merijn, oh sorry I think the division is fine, though there are different ways to do it, but the problem starts at Euclidean rings because Int is not an integral domain
10:55:03 <maralorn> On the other hand specifying possible dialog variants in a type level list will probably multiple my development time and lower the ease of use.
10:56:29 <hyperisco> merijn, no scratch that, EuclideanRing defines division. :P clumsily remembering the hierarchy
10:56:54 * ski looks at sshine
10:57:13 * MarcelineVQ looks at rcloud
10:57:16 <hyperisco> there is DivisionRing which defines multiplicative inverses but that can't be closed on Int
10:58:34 <hyperisco> but for example, I can count with semirings, and that has been helpful (technically could with a group, but for whatever reason groups are omitted from the hierarchy, painfully)
10:59:59 <Cale> hyperisco: Well, Euclidean domains usually are required to be integral domains, but practically speaking, I'm not sure how much trouble you run into with the generalisation...
11:00:38 <hyperisco> both instances given in the Prelude for PS are invalid, so I guess you run into trouble on all counts :P
11:00:49 <Cale> for PS?
11:00:54 <hyperisco> PureScript
11:01:49 * Lycurgus just reviewed from herstein the group/ring distinction
11:03:06 <hyperisco> I am guessing there are semirings and rings I could avail myself of but I am not instinctively inclined to see things that way yet
11:03:31 <Cale> What's wrong with it apart from Int not being an integral domain?
11:03:49 <Cale> (I'm not very familiar with purescript)
11:05:03 <hyperisco> I stopped investigating at that point, I don't know if anything else is wrong
11:05:46 * maralorn thinks, that trying to closely match any detailed mathematical hierarchy is to rigid. I guess Num is okayish. But I think I would go for more finegrained classes if someone forced me to think of a "correct" definition. Like have one for addition, another one for subtraction, one for multiplication, one or I guess two for division ...
11:06:17 <hyperisco> I was doing something or other with Euclidean spaces I think and it became relevant to have actual an actual Euclidean ring
11:06:36 <hyperisco> even the approximation of Double is more palatable than Int
11:07:11 <hyperisco> but literally the all-powerful overloaded syntax argument was wheeled out to defend it
11:07:39 <hyperisco> and if you're going to do that, I say Num was better
11:07:57 <hyperisco> lawless, no one ought to care that much about it, just a bag of overloaded names
11:08:38 <hyperisco> problem is, people aren't viewing this right, and I know it
11:09:39 <hyperisco> if you started caring about, say, a Euclidean ring generically, ie the only thing important is the Euclidean ring itself, not any particular instances
11:10:01 <Cale> Wait, Double isn't a useful approximation of a Euclidean domain... except in a trivial way
11:10:06 <hyperisco> then you'd be upset that after going through that work it could be instantiated with potentially program-crashing instances
11:10:44 <Cale> Fields are technically Euclidean domains, they're not very interesting ones though.
11:13:26 <hyperisco> all I am saying is that I prefer the problems of Double to the problems of Int
11:13:40 <Cale> ah
11:14:22 * merijn just embraced anarchy and lawlessness
11:14:36 <merijn> Seems better for my blood pressure :p
11:17:14 <hyperisco> I appreciate how rarified the atmosphere is to be arguing with Haskellers over their precision
11:18:15 <Cale> I just think I'd rather save a proper Ring class hierarchy for when we get dependent types, and even then, it probably doesn't need to be in the Prelude.
11:18:55 <hyperisco> what can we gain from dts here?
11:19:11 <Cale> Then you can add the actual laws as methods
11:19:32 <hyperisco> oh well I feel like that is a broader discussion about how class laws are treated
11:20:41 <hyperisco> Idris chose to have lawful and lawless versions of each class, and that seems odd
11:21:38 <Cale> I think it makes sense if you try to use the lawful ones and don't enjoy wasting your time convincing the computer :P
11:21:51 <MarcelineVQ> that's because idris isn't a proof assistant, it's a gp programming language, and a gp language should endeavor to be useable
11:22:23 <hyperisco> that is fine but why is that the chosen escape hatch
11:22:33 <hyperisco> because another option is to just leave the proofs as TODOs
11:22:37 <MarcelineVQ> There's other escape hatches, what problem are we escaping?
11:23:27 <geekosaur> carrying around proofs that your typeclass instances are law-abiding
11:23:43 <Cale> The proposition might actually be untrue, but you might know that the extent to which it's untrue doesn't matter to you
11:23:56 <Cale> (like in the case of most uses of Double for arithmetic)
11:24:14 <hyperisco> I'd expect in Haskell, if we had such lawful classes, we could write in  error "TODO"  or some such instead of a proof
11:24:18 <MarcelineVQ> The issue with providing an instance that claims to enforce laws and then not enforcing them is that you have users, and users and surprises are a bad combination
11:25:07 <hyperisco> I don't feel like that tracks with the pragmatism argument though
11:25:27 <MarcelineVQ> As a user I pragmatically don't like surprises :X
11:25:56 <hyperisco> if I make a library do I require you to give me lawful or lawless instances?
11:26:06 <phadej> Cale: it's fun (when you think about it) that there's plenty of research how to make computing with IEEE754 less-imprecise / numerically stable / ...
11:26:09 <hyperisco> I'm deciding what work you need to do for me, at that point
11:26:37 <phadej> Cale: and all of that is thrown away when you try to fit into (just) + and * of Ring class (for example)
11:26:53 <phadej> repeating what I said, it is a wrong abstraction
11:27:31 <hyperisco> on the flip, you give me a lawful instance and it is not truly law-abiding, I'll be upset, true
11:27:35 <phadej> something as 'basic' as FMA
11:28:13 <phadej> https://gitlab.haskell.org/ghc/ghc/-/issues/10364 :(
11:28:13 <Cale> In what way do we throw out numerical stability analysis?
11:28:35 <phadej> e.g. not offering fma, for example
11:28:49 <Cale> Oh, I see, you just want more operations
11:28:57 <Cale> I don't think that requires removing + and *
11:29:30 <hyperisco> Cale, it is just that if Double actually works then probably the algebraic structure never mattered
11:29:37 <MarcelineVQ> "<hyperisco> I'm deciding what work you need to do for me, at that point" Indeed, that's an issue with laws at api boundries, it's also why I so far advocate to not let dependent types into your api's.
11:29:52 <hyperisco> the issue of perspective I am seeing is that people argue from a specific instance, rather than arguing from the algebraic structure
11:29:54 <Cale> hyperisco: It *approximately* matters :)
11:29:59 <hyperisco> and that is how we get syntax arguments
11:30:41 <Cale> The algebraic laws are stated as equations, while what the application probably needed was only inequalities which bounded those things to be true within some interval of error
11:31:11 <Cale> and only for values in a particular range
11:32:25 <hyperisco> fine, but still did the generalisation of that structure, realised as a type class, ever matter
11:32:55 <hyperisco> and I'm not saying you're making this argument
11:35:06 <Cale> Not all that much, but it allowed for overloading, and possibly some reuse of functions defined in terms of Num which aren't part of it
11:36:45 <Cale> phadej: I think to start with, we should have all the operations like fma but not in a class.
11:36:58 <Cale> (maybe in their own class)
11:37:24 <phadej> Cale: I'd argue that Double shouldn't be Num (or whatever Ring) to begin with
11:37:25 <Cale> Presumably that could be done as a library, though perhaps it's worth wiring the operations into GHC...
11:37:58 <Cale> Meh, it's got operations which roughly correspond to the operations of Num to the point that the meanings of things are predictable.
11:37:58 <phadej> if you really want, then there could be a newtype wrapping IEEE754 type and pretending it's a Num (or Ring)
11:38:57 <Cale> I don't think there's all that much value in making it any less convenient to add and multiply Double values
11:39:22 <Cale> Or interpret integer literals as Double values, for that matter
11:39:36 <hyperisco> biased way to put it but sure, I'd prefer not to lose that
11:40:49 <Cale> It's hard to see how kicking Double out of Num is going to result in the same level of convenience even -- at the very least, you're going to have to choose new, slightly more awkward names for the operations -- we're basically out of single-character infix operators
11:41:48 <Cale> and then you lose all the things which were written to work with an arbitrary instance of Num, many of which still make sense for Double
11:42:43 <hyperisco> I sometimes hate our editing tools too
11:43:13 <Cale> Our keyboards need more keys
11:43:58 <hyperisco> one idea is to decouple the notion of overloading
11:44:54 <Cale> Add a subclass of Num called Ring, with no additional operations, but more laws
11:45:00 <hyperisco> basically what Num does now, at least the report version
11:45:20 <Cale> and then things which truly care that they have a proper Ring can demand it
11:46:09 <phadej> Ring is wrong for Natural
11:46:37 <phadej> even without thinking about Double :)
11:46:54 <hyperisco> a trouble being that Num defines a lot of syntax, more than say a semiring would want
11:47:24 <hyperisco> I guess this is the Idris lawful/lawless duality all over again
11:47:52 <hyperisco> one is just syntax, the other adds semantics
11:48:18 <hyperisco> maybe just a different mechanism is warranted, than type classes
11:48:31 <hyperisco> C++ has macros, by preprocessor or template
11:48:37 <hyperisco> it isn't a shining example but it is more truthful
11:49:23 <phadej> I also don't know how much Ocaml people hate the difference between + and .+
11:50:01 <phadej> whether the dotted operators are driving people crazy and into Haskell
11:50:14 <hyperisco> I suspect the best way to solve this is with the editor / code viewer
11:50:15 <[exa]> is there a squiggly variant of + in utf8 that could mark the approximate + on doubles etc ?
11:50:35 <[exa]> because this is really just ascii problem
11:50:36 <hyperisco> but that upends probably the most entrenched aspect of programming
11:51:28 <hyperisco> I already use compose sequences to type things like ‚Üí
11:51:29 <ski>   ‚ç≠
11:51:31 <ski> maybe ?
11:51:53 <[exa]> looks too precise
11:52:48 <ski>   ‚®§
11:52:54 <hyperisco> if the same symbol was used in two ways then all I'd ask is there be some subtle indication of overloading, be it by colour or an extra mark (especially for the colourblind)
11:53:03 <hyperisco> and the editor affords a way to unmask the overload
11:53:23 <[exa]> ski: that's a strong candidate!
11:53:39 <hyperisco> so then we don't have to play the unicode game either
11:54:18 <ski> (there's ‚åú‚®¶‚åù, too)
11:54:25 <hyperisco> in other words, there is a difference of syntax representation in a way somewhat similar to the compose sequences I use
11:54:45 <hyperisco> I have multiple ways to type ‚Üí say, but they present the same
11:55:27 <hyperisco> and all I'd want to know is that 1) ‚Üí represents more than one sequence and 2) which sequence it represents, but I only need to know (2) by explicitly asking
11:55:52 <hyperisco> so then we can have + and .+ and whatever, and these present both as +
11:56:17 <hyperisco> plus some signal it is overloaded
11:57:13 <hyperisco> and all this without having to go off the deep end of projectional editing
12:01:41 <sm[m]> I don't suppose there's any easy way to tell GHCI to use the extensions configured for a particular module ?
12:02:54 <adamwespiser> On load, you should be able to load a specific module, if I recall correctly, and in that module can be your extensions
12:03:16 <geekosaur> but that doesn't set them for interactive use
12:03:29 <sm[m]> right
12:03:39 <geekosaur> nor does having multiple modules loaded and switching between them
12:03:53 <sm[m]> I'm always being thwarted by mismatches between the module and ghci
12:04:32 <geekosaur> (and this is often a feature, consider ExtendedDefaultRules which you probably don't want turned off by loading a module)
12:04:38 <sm[m]> I guess I can make some shorter aliases to turn them on/off
12:05:53 <ddellacosta> kind of a nix question, but can anyone tell me (or point me at docs for) how to override a dependency in a nix Haskell project with a local version of that package which I've compiled myself? Basically I just want to install my copy of the library just for that Haskell project
12:06:56 <sm[m]> on another note, if anyone here has experience with sdl2, I have questions. Eg, why does destroyWindow not get rid of the window when running in GHCI. And, why does kill -TERM not kill a sdl app, it must be kill -KILL
12:19:05 <koz_> Is there a good way to generate a Text randomly which _is_ valid UTF-8, but _not_ valid Latin-1?
12:19:45 <geekosaur> I don't think there's an invalid Latin-1
12:20:14 <geekosaur> unless you mean embedded control codes or similar, but that would also apply to UTF-8
12:20:16 <koz_> I think I'm being imprecise, sorry. I want to generate Text which contains at least one grapheme requiring a multi-byte encoding in UTF-8.
12:20:26 <koz_> What's a good way to do this?
12:20:49 <phadej> arbitrary ++ [multibytechar] ++ arbitrary
12:21:12 <adamwespiser> If you have a bytestring, I might use Data.Text.Encoding for that task
12:21:15 <geekosaur> include at least one grapheme with a codepoint > 255
12:21:26 <phadej> geekosaur: >=128
12:21:38 <phadej> but >255 would work too
12:21:45 <geekosaur> no, because 128..255 are valid Latin-1
12:21:57 <phadej> at least one grapheme requiring a multi-byte encoding in UTF-8.
12:22:00 <koz_> phadej: Yeah, that's a good point.
12:22:05 <koz_> Thanks!
12:22:14 <phadej> codepoint 128 is encoded as two bytes
12:22:25 <phadej> up to koz_ to refine the specification
12:22:40 <koz_> phadej: The basic idea works well though.
12:22:49 <koz_> Thanks for the suggestion.
12:25:19 * hackage stm-queue 0.1.2.0 - An implementation of a real-time concurrent queue  https://hackage.haskell.org/package/stm-queue-0.1.2.0 (sgschlesinger)
12:30:49 * hackage Win32 2.10.0.0 - A binding to Windows Win32 API.  https://hackage.haskell.org/package/Win32-2.10.0.0 (TamarChristina)
13:17:10 <kindaro> Is there a nice library for logging messages in IO to standard output/error?
13:17:40 <kindaro> Like a fancy `putStrLn`, yes.
13:18:02 <merijn> @hackage monad-logger
13:18:03 <lambdabot> https://hackage.haskell.org/package/monad-logger
13:18:08 <Uniaika> co-log exists too
13:18:09 <merijn> And a billion others :p
13:18:11 <[exa]> logging?
13:18:19 <[exa]> ^^ actual package name
13:18:43 <kindaro> No, these are not in IO, they have their own transformer or something.
13:18:59 <merijn> What I like about monad-logger is that you can start out lazy just using LoggingT and then you can easily later replace it and implement your own stuff
13:19:02 <merijn> eh
13:19:10 <merijn> Well, then "hPutStrLn"? :p
13:19:34 <[exa]> kindaro: https://hackage.haskell.org/package/logging even says "in IO"
13:19:35 <ddellacosta> kindaro: logging that [exa] mentioned is just in IO I thought
13:19:43 <ddellacosta> lol jinx
13:19:51 <[exa]> :]
13:19:52 <kindaro> I see `logging` has `log :: Text -> IO ()` ‚Äî that I like.
13:25:39 <kindaro> By the way, I see `logging` is using the idiom of `logLevel = unsafePerformIO $ newIORef LevelDebug` for initializing an implicit global state.‚ÄÇI know that `random` recently removed a similar feature.‚ÄÇHas there been research that shows definitely that such use of `unsafePerformIO` is either safe or unsafe?
13:27:20 <kindaro> Particularly, see this explanation: https://github.com/haskell/random/issues/57#issuecomment-649473745
13:27:41 <kindaro> I am divided on this technique since then ‚Äî should I like or dislike it?
13:29:33 <[exa]> kindaro: unsafePerformIO is often quite practical, like for tracing
13:30:08 <Cale> I dislike it just because it means that only one usage is possible. It's fine to use mutable stuff, but it would make more sense to have a little bundle of mutable state containing a handle for where the log message was going, together with the current log level perhaps
13:30:28 <kindaro> Not sure I follow.
13:30:42 <Cale> I guess the assumption here is that the log is only going to stderr
13:30:59 <Cale> But say multiple libraries decide to use this log library
13:31:14 <Cale> Then they might interfere with each other when it comes to setting their log level
13:31:39 <Cale> One library can't have a different log level than the other, even if it might appear that way, because some initialisation function takes a log level
13:31:44 <Cale> (and sets it)
13:32:09 <Cale> Just because they accidentally both used logging
13:32:29 <c_wraith> I'd probably argue libraries should never set the log level anyway, but that's beside the point a bit.  With the point being that there are ways to design it that don't involve unsafePerformIO
13:33:43 <Cale> Well, they might set the log level according to what the user of the library requests
13:34:03 <Cale> But yeah, I suppose if you're using 'logging', you don't really do that
13:34:27 <Cale> because it doesn't make sense, as you can't really have a distinct logging level from any other library which is using it
13:37:03 <jonatanb> \nick jobo
13:52:19 * hackage Rasterific 0.7.5.3 - A pure haskell drawing engine.  https://hackage.haskell.org/package/Rasterific-0.7.5.3 (VincentBerthoux)
14:02:03 <lechner> sm[m]: not sure what you are doing with sdl2, but maybe this helps  https://discourse.libsdl.org/t/mac-os-x-avoid-the-sdl-to-catch-sigterm-and-sigint-signals/27357
14:05:00 <orion> Hi. Does anyone know how to make this typecheck?: https://gist.github.com/centromere/b1f795418d00dff28e2cfcaefd727751
14:05:22 <orion> (The package is acid-state)
14:05:55 <orion> I realize that the "event" expressed by the type signature is general, whereas I am trying to use it with a more specific type, leading to the error.
14:06:06 <orion> I am not sure how to approach the issue though.
14:16:48 <tomsmeding> orion: EventState is a type family; what does 'EventState AppState' resolve to?
14:17:19 * hackage termbox 0.3.0 - termbox bindings  https://hackage.haskell.org/package/termbox-0.3.0 (mitchellwrosen)
14:24:03 <sm[m]> lechner: that looks highly relevant, thanks!
14:25:21 <sm[m]> I'm wanting to kill & restart my sdl app on rebuild with entr, which sends SIGTERM
14:27:04 <sm[m]> though if I could destroy the window from ghci, I would rather run it with ghcid
14:56:32 <hyiltiz> What's the design choice of not sugaring `$ do` into something else (like $$ or whatev) in HSpec? I think it is because both $ and do is basic stuff and simply composing them as a basic HSpec operation is also nice, besides it is not too long to type
14:56:55 <hyiltiz> Also, sometimes the do is not needed
14:57:29 <hyiltiz> So sugaring it to $$ could lead to confusion
14:57:44 <edwardk> hyiltiz: ? do is builtin syntax
14:57:59 <edwardk> you can use BlockArguments to drop the $ though
14:58:45 <hyiltiz> I c it is builtin syntax. I am just wondering why not wrap the EDSL into something less verbose
14:58:57 <ski> (`$' is a library operation, though)
14:59:33 <hyiltiz> oh wait that $ is overloaded? I thought it was the one from haskell?
15:00:29 <edwardk> not sure how you get lighter weight than do, it acts like parentheses you don't have to close
15:00:48 <edwardk> given HSpec doesn't hide prelude's $, it is just the one from Prelude
15:01:28 <edwardk> anyways do takes exactly as many characters as ()'s would and self closes when you outdent
15:01:59 <edwardk> but using BlockArguments does clean up the 'noise' in an HSpec file
15:02:48 <edwardk> BlockArguments https://www.irccloud.com/pastebin/R8v4pxNs/BlockSpec.hs
15:03:09 <edwardk> you can swap each of those do's for a $ except the one on the line with describe
15:03:44 <edwardk> BlockArguments lets you kill the $ before the lambda for property there as well
15:03:57 <edwardk> > 2 * do 3 + 4
15:04:00 <lambdabot>  14
15:04:26 <opticblast> > :t do ()
15:04:28 <lambdabot>  <hint>:1:1: error: <hint>:1:1: error: parse error on input ‚Äò:‚Äô
15:04:29 <ski> hyiltiz : no, it's the usual `$' in the library
15:04:44 <opticblast> @type do ()
15:04:46 <lambdabot> ()
15:04:50 <opticblast> well, that's confusing
15:04:56 <opticblast> I thought it would be something like Identity ()
15:05:28 <edwardk> do doesn't change the types, it just desugars into >>= uses when there is ;  -- and maybe does some applicative stuff if applicative do is on
15:05:46 <edwardk> when there is only one expression there you want it passed through
15:05:54 <ski> a `do'-expression has the same type as its last command (which in this case was `()')
15:06:02 <edwardk> otherwise in your model do () and do (pure ()) -- would be ambiguous what to do
15:06:14 <edwardk> or 'do x' where x happens to be pure y
15:06:21 <edwardk> so it _can't_ do the thing you want opticblast
15:06:33 <opticblast> ah, makes sense
15:07:03 <edwardk> now, back in the day it used to be that do would guide inference to figure out that the type there was the application of some m to some a, but we got them to stop doing that a looong time ago
15:12:30 <hyiltiz> edwardk: thx! BlockArguments seems to really clean up the verbose notation
15:12:44 <hyiltiz> and I am sure it works not just work HSpec as well
15:12:54 <hyiltiz> Reminds me of Ruby's blocks
15:15:07 <edwardk> i use it more and more these days mostly because when some library messily needs to take a argument that will be very long right before some other empty list argument or something i can break things up by lines and then just use the do to self delimit _that_ argument, without having to figure out how to put the closing paren, or get all lispy with closing parens dangling on the far right of my screen
15:15:48 * hackage termbox-banana 0.3.0 - reactive-banana + termbox  https://hackage.haskell.org/package/termbox-banana-0.3.0 (mitchellwrosen)
15:16:05 <yushyin> 6
15:16:11 <yushyin> ups, sorry
15:18:17 <edwardk> it amazes me that nobody has written an ncurses variant that knows how many lines worth of text it has scrolled in and gives you control over just that portion of the screen space, so it doesn't have to flip to the alt screen and works well for repls.
15:18:52 <edwardk> everything that works like this is some bespoke readline like monstrosity
15:30:17 <dolio> I think block arguments are a good idea (mostly), but characterising two extra characters as 'verbose' seems a little silly.
15:33:44 <edwardk> i mean i grumble about the extra : in :: all the time
15:34:02 <edwardk> so who am i to begrudge someone a complaint about twice as many characters
15:35:07 <yushyin> unfortunate hysterical reasons with the : vs. :: matter
15:36:05 <Rembane> We need a Haskell dialect where the : and :: are swapped.
15:36:17 <koz_> Rembane: So, Idris? :P
15:37:09 <edwardk> then the laziness gets ya
15:40:28 <Rembane> koz_: Yeah, why not? :)
15:40:43 <dolio> I don't think the extra typing hurts as much as being different from the settled notation.
15:40:50 <yushyin> Rembane: https://github.com/ghc-proposals/ghc-proposals/pull/118
15:41:28 * ski . o O ( ‚åú‚à∑‚åù )
15:41:41 <Axman6> Rembane: DAML?
15:44:12 <Rembane> yushyin: Wow. Nice. 
15:44:29 <Rembane> Axman6: Dots Are More LOL?
15:48:04 <koz_> Rembane: Dots Are More Leet.
15:48:17 <dolio> Regardless, it's never going to be worth changing in its own right.
15:49:08 <Rembane> koz_: Of course! I'm way too tired to get that on the first try.
15:55:00 <Axman6> @google DAML
15:55:01 <lambdabot> No Result Found.
15:55:06 <Axman6> uwot
15:55:31 <MarcelineVQ> don't all mutts leak?
15:56:17 <Axman6> https://daml.com - a dialect of Haskell for smart contracts, its compiler GHC with some desugaring on the front end (including : <-> ::, ples a lot of other nice extensions which make using the language day to day really nice)
15:57:14 <koz_> MarcelineVQ: Don't All Marsupials Lie?
15:57:39 <MarcelineVQ> Driven Antelopes Must Leap
15:57:51 <Guest39453> uh?
15:58:03 <Axman6> this is the secret code, you are now authenticated
15:59:32 <Guest39453> @help
15:59:33 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
15:59:47 <Axman6> plus*
15:59:50 * ski looks at Guest39453
16:00:22 <Guest39453> just seeing if lambdabot is real
16:01:10 <koz_> Lambdabot is indeed a figment of your imagination.
16:01:14 <Axman6> are bits real?
16:01:17 <MarcelineVQ> how can lambdabot be real if our toes aren't real
16:03:27 <Axman6> deep
16:03:38 <Axman6> but not like learning, like the ocean
16:06:37 <orion> tomsmeding: Is a type familiy the same as a type synonym?: https://github.com/acid-state/acid-state/blob/bf1fa2466e749f91d2e3152ced15331f062e8d10/src/Data/Acid/Common.hs#L54
16:07:20 <Axman6> no
16:18:11 <orion> Oh, tomsmeding was talking about MethodState.
16:30:36 <orion> tomsmeding: type instance MethodState UpdateNow = AppState
16:49:59 <orion> tomsmeding: I got it! All I had to do was change the type signature to this: update :: (UpdateEvent event, MethodState event ~ AppState, MonadIO m, MonadTime m)
16:50:29 <orion> Thank you for your assistance.
17:00:53 <cipherchess> In cabal, what is the difference between v2- and new-? Which one should I use?
17:01:21 <dolio> The only difference is the name.
17:02:04 <dolio> If your cabal-install is 3 or newer (I think), those are the default, as well.
17:02:55 <cipherchess> Oh nice, thank you.
17:03:12 <edwardk> Cale: i figured a way to make everything work. i just had to give up on Nat.
17:03:14 <edwardk> =)
17:04:16 <edwardk> now it "just works" https://github.com/ekmett/haskell/blob/master/types/example/Vec.hs -- and you can even swap out Natural there for Int, Word, etc. to get things with smaller singletons.
17:06:02 <Cale> Well, that's definitely simpler
17:06:36 <edwardk> basically i gave in and made fully general Z' and S' data families and used them to make Word, Word16, Natural ... all inhabitable as kinds. then made 'safe' aliases for Z and S that delegate to 0 and 1+ for the nat case but otherwise use those Z' and S' hacked constructors 
17:07:53 <edwardk> to be fully safe the Z and S I export should have an enumerated set of types for which they work, but the proof of concept is nice
17:08:18 <edwardk> you can't use Nat in there or you get the lack of injection issue we had before, but everything else works as expected and Nat is no longer my bottleneck
17:08:48 <Cale> The definition of the S type family is amusing
17:09:46 <edwardk> what i'll do is switch it to an open type family that way i can enumerate exactly which types it works on and users can extend that set by importing Data.Type.Unsafe and adding a type instance
17:13:34 <edwardk> oh, i have an even better hack, one sec
17:17:03 <edwardk> there
17:17:19 <edwardk> now you need to instantiate Nice in order to unstick the evaluation of Z and S for your type
17:17:27 <edwardk> making them safer to export from Data.Type
17:17:38 <edwardk> they'll eval for naturals and any Nice type
17:18:05 * sm[m] thinks why can't we have a SwapColons extension
17:20:19 <edwardk> its not currently as safe as i'd like, because you can just claim 'Nice' for any type you want. a safer version would export the Nice, but not include the defaults i guess
17:20:48 <edwardk> that way if you have your own injective zero and succ you can instantiate the class, or you can delegate to mine through Unsafe
17:20:55 <edwardk> ok, going back and writing longer instances
17:22:43 <ddellacosta> Baader-Meinhof is a funny thing. This morning I was checking out haskellweekly.news and clicked on a blog post about contravariant functors, as I haven't built up much of an intuition for them yet, so was interested. I skimmed it enough to note that it talked about composing predicate functions. Later, I jumped back into a side project debugging some FFI code, and searched for items on this
17:22:45 <ddellacosta> topic--found another blog post, which...talked about using contravariant functors in the context of debugging. Finally I took a break and looked up a logging library someone had mentioned earlier today here, co-log...yeah, more contravariant functors. I haven't read all of these in depth yet, but I guess the universe/my unconscious is telling me I need to stop slacking off
17:23:41 <koz_> ddellacosta: Contravariant functors are indeed cool.
17:23:57 <ddellacosta> they seem kind of mindblowing honestly
17:24:23 <koz_> ddellacosta: They can do some really cool things - discrimination sorting, for example.
17:24:39 <ddellacosta> damnit, now I have another thing to go read about lol
17:24:53 <koz_> ddellacosta: Do you know how radix sorting works?
17:25:17 <ddellacosta> unfortunately no
17:25:26 <koz_> Read that first.
17:25:42 <koz_> It'll help a lot to understand what's happening and why it has the asymptotics it claims.
17:26:10 * ddellacosta pulls out the CLRS
17:39:53 <ddellacosta> koz_ thank you, that was super interesting. As far as discrimination sorting, is there a better source than this? https://hackage.haskell.org/package/discrimination Everything else that comes up is for like, young child education
17:40:09 <Cale> ddellacosta: For the most part, a decent intuition for practically all the examples relevant to programming is just that when F is a contravariant functor, then a value of type F a is something which consumes values of type a
17:40:23 <koz_> ddellacosta: That's the source, plus its links.
17:40:41 <koz_> I'd read the papers it links - if you're used to algorithm literature, it's pretty readable.
17:40:52 <ddellacosta> Cale: thank you, that is helpful!
17:41:03 <ddellacosta> koz_: ah okay, I didn't see any linked papers but will look again
17:41:22 <ddellacosta> d'oh right at the top, nevermind
17:41:24 <ddellacosta> thanks koz_ !
17:41:33 <koz_> No worries! Happy reading.
17:44:53 <ski> ddellacosta : one example which can be made into a contravariant functor is the write end of a concurrent communication channel (also a write view on a mutable cell)
17:46:17 * ddellacosta thinks about it
17:46:48 <ski> ("can be made", in this case, means that you allow attaching an arbitrary preprocessing step (function), that you apply before you write to the channel/cell)
17:47:16 <ddellacosta> ski: okay that's helpful, one thing I read earlier today was that the order of processing is conceptually "reversed" when compared to a covariant functor
17:47:26 <ddellacosta> I mean wrt contramap
17:47:53 <ski> yes
17:48:51 <ddellacosta> now I'm trying to understand how that connects to what Cale said
17:49:36 <ski> well, the write end/view of the channel/cell consumes values, in that you feed a value to it, when writing
17:50:39 <ski> (and read end/view will produce values, when reading. so that can be made into a covariant functor (by allowing attaching an arbitrary post-processing step (function), after reading))
17:51:52 <ddellacosta> okay thank you ski , I think I need to think about that for a bit
17:52:27 <ddellacosta> like intuitively it makes sense, but the deeper structure of it all is eluding me still
17:52:49 <ski> (if you want to, you could try to wrap `Chan' or `IORef' into such read and write ends/views. and then see if you can, possibly with some modification, make the read ones covariant functors, and the write ones contravariant functors)
17:53:18 <ddellacosta> okay interesting
17:53:37 <ski> (also providing some relevant operations on the new data types (which are to be exported abstractly))
17:54:01 <Cale> newtype WriteEnd a = MkWriteEnd { writeTo :: a -> IO () }
17:54:33 <ski> it might perhaps sometimes be nice to have a callback that you want to pass a channel to, but you only want it to write to the channel, not read, so you only pass it the write end
17:54:47 <ski> Cale : hah :)
17:55:01 <Cale> ddellacosta: Try writing the instance for that :)
17:55:15 <ddellacosta> Cale: okay cool
17:55:22 <ddellacosta> and ski the last thing you just said clicked, thank you
17:55:53 <ddellacosta> and I can actually kind of see how that's like a predicate now in the general sense
17:56:47 <Cale> Yeah, there will be basically no difference in what the instance looks like
18:00:32 <ski> ddellacosta : btw, for the read end, you can try to make a version of `getChanContents' as well
18:01:17 <ddellacosta> okay
18:08:49 <ski> hm, pondering `dupChan'
18:09:48 <ski> at first sight, it would seen one would do `WriteChan a -> IO (ReadChan a)' ..
18:09:55 <koz_> Anime has ruined concurrency for me - every time I see any variant of 'chan' I'm amused.
18:10:29 <ski> .. however, this isn't compatible with having `WriteChan' a contravariant functor
18:11:27 <ski> `Chan a -> IO (ReadChan a)' would be possible, of course (just `dupChan' and convert to `ReadChan')
18:16:08 <ski> however, it seems that if one had a difunctor, `RWChan a b' being contravariant in `a' (write end type) and covariant in `b' (read end type), then one could do `RWChan a b -> IO (ReadChan b)' (obviously also `RWChan a b -> IO (RWChan a b)' would work)
18:18:37 <ski> hm. although if one takes advantage if the fact that `Chan', which `ReadChan' is presumably implemented in terms of, also contains the write end, one could have `ReadChan a -> IO (ReadChan a)' .. although this feels like cheating a bit, since a direct reimplementation, separating the read and write ends, rather than just hiding one or the other, couldn't do this
18:37:00 <zebrag> I'm trying to understand what is "existential" in "existential types". Is it related to quantifiers? In what way?
18:37:59 <ski> yes
18:38:34 <ski> do you understand what's universal about polymorphism ?
18:39:34 <MarcelineVQ> Cale: what's that  comparing <>  example you use all the time?
18:39:44 <ski> @where monoids
18:39:44 <lambdabot> comment on "Monoids? In my programming language?" by Cale in 2008 (or 2009 ?) at <http://www.reddit.com/r/programming/comments/7cf4r/monoids_in_my_programming_language/c06adnx> about a use of `
18:39:44 <lambdabot> instance Monoid a => Monoid (rho -> a)'
18:39:55 <MarcelineVQ> :D
18:40:35 <zebrag> ski: I believe I understand what's universal about polymorphism
18:41:05 <ski> zebrag : and you understand rank-2 ?
18:41:53 <zebrag> ski: do you mean about the rho being in a negative position?
18:42:24 <ski> `rho' ?
18:43:02 <zebrag> wasn't meant for me, instance Monoid a => Monoid (rho -> a)'
18:43:18 <zebrag> so no I don't quite undestand rank-2
18:43:19 <ski> nah, that was answering another question
18:43:48 <ski> well, let me try to fast-forward over `forall'
18:44:28 <zebrag>  should read that: https://wiki.haskell.org/Rank-N_types
18:44:48 <ski> in Haskell, it happens that many uses of `forall' are implicit. but that doesn't mean that they're not there. in another language, they could be required to be explicit, always
18:44:48 <zebrag> back in a jif
18:45:32 <ski> so if you see e.g.
18:45:41 <ski>   length :: [a] -> Int
18:45:42 <ski> or
18:45:52 <ski>   take :: Int -> [a] -> [a]
18:45:53 <ski> or
18:46:02 <ski>   sort :: Ord a => [a] -> [a]
18:46:11 <ski> then these really mean
18:46:20 <ski>   length :: forall a. [a] -> Int
18:46:25 <ski>   take :: forall a. Int -> [a] -> [a]
18:46:29 <ski>   sort :: forall a. Ord a => [a] -> [a]
18:47:07 <zebrag> ok
18:47:23 <ski> however : this does not mean that e.g. `[a] -> [a]' "really means" `forall a. [a] -> [a]' !
18:48:05 <ski> since, in that case, `foo :: ([a] -> [a]) -> ([a] -> [a])' could be argued to "really mean" `foo :: (forall a. [a] -> [a]) -> (forall a. [a] -> [a])', which is incorrect
18:48:38 <ski> similarly, `data Foo a = MkFoo ([a] -> [a])' does not mean `data Foo a = MkFoo (forall a. [a] -> [a])'
18:49:01 <ski> the implicit `forall' is only inserted, right after the `::', in a type signature
18:50:04 <ski> and even then, there are a few exceptions, which boil down to the type variable(s) in question already being in scope. e.g. in `data Foo a = MkFoo {unFoo :: [a] -> [a]}', `a' is already in scope, bound by the `data Foo a =' "head" part
18:50:44 <ski> also, in `class Eq a where (==) :: a -> a -> Bool', `a' is already in scope, when we reach the type signature. so, this does not mean `class Eq a where (==) :: forall a. a -> a -> Bool'
18:50:58 <ski> (`(==)' is a monomorphic class method)
18:51:28 <ski> (i mention this, because these seems to be common confusions about where implicit `forall's are inserted)
18:52:01 <ski> anyway, `length :: forall a. [a] -> Int' means that : for every type `a', `length' can be used as having type `[a] -> Int'
18:52:21 <ski> strictly speaking, `length' is not a function, but a "polymorphic value"
18:53:38 <ski> however, when going from `length :: forall a. [a] -> Int' to say `length :: [String] -> Int', specializing the polymorphic value, to a function in this case, we don't actually write anything more than `length'
18:54:22 <ski> (well, there is now an extension that allows one to explicitly write the specialization as `length @String', meaning that we pick `a' to be `String', so that this whole thing has type `[String] -> Int')
19:01:06 <inkbottle> ski: zebrag -> inkbottle; I'm still reading https://wiki.haskell.org/Rank-N_types, I think it was a very good suggestion
19:02:13 <ski> ah, ok
19:04:44 <ski> inkbottle : did the above explanation make sense, so far ?
19:11:06 <inkbottle> ski: yes, they did
19:13:08 <ski> ok
19:13:27 <ski> so, if you have
19:13:44 <ski>   blah :: (forall a. [a] -> [a]) -> [String] -> [String]
19:13:57 <ski>   blah f ss = map f (f ss)
19:14:37 <ski> what this means is that `blah' itself is not polymorphic. rather, it requires its first argument (a callback function), to be polymorphic
19:15:53 <ski> so, you can e.g. call `blah id ["foo","bar"]', but you can't call `blah (map toUpper) ["foo","bar"]', since `map toUpper' has type `String -> String' (that is, `[Char] -> [Char]'), so is not polymorphic
19:16:45 <ski> and, in this case, `blah' uses the fact that `f' is polymorphic, by picking two different types to use for `a', at the two different uses of `f' in the body
19:17:12 <ski> (can you see if you can figure out which type `a' will be, in each of those two cases ?)
19:17:59 <ski> (btw, in case, it's not totally obvious, the signature `blah :: forall a. ([a] -> [a]) -> [String] -> [String]' would not work at all, for this implementation of `blah')
19:19:23 <ski> if you see `foo :: forall a. ..a..', then that means that the caller/user/consumer of `foo' will get to pick a type for `a'. while the callee/implementor/producer/definer of `foo', which is the definition/body for it, will have to make sure to work for any choice that could be made. may not assuming anything about `a'
19:19:27 <inkbottle> hang on...
19:20:00 <inkbottle> still reading what you wrote
19:20:16 <ski> to the body of `foo', `a' acts like an unknown/forgotten/hidden/opaque/abstract/"skolem"/rigid type, that it may assume nothing about
19:21:00 <ski> in the case of `sort :: forall a. Ord a => [a] -> [a]', the implementation of `sort' may assume that `a' is an instance of `Ord', and so can use the methods of `Ord' on values of type `a'. but can assume nothing else about `a'
19:21:35 <ski> `foo' can't "look inside" values of type `a'. neither can `sort', apart from via the methods of `Ord'
19:22:44 <ski> if you have say `foo :: forall a. (a -> Bool) -> ..a..', then `foo' can pass a value of type `a' to its callback argument (which is allowed to know what type `a' is, since it's provided by the caller, who picks `a'), and so is able to extract a `Bool' of info from the `a' value, using that
19:23:17 <inkbottle> ok
19:23:52 <ski> however, in the case of the rank-two `blah', the caller of the polymorphic `f' is `blah' itself
19:24:26 <ski> so, while the caller of the polymorphic `foo' was to choose `a', and the callee/implementation couldn't assume anything about `a'
19:25:41 <ski> in the case of the rank-two `blah', these two r√¥les are reversed : the callee/implementation of `blah' is the one that can pick and choose types for `a', while the caller of `blah' can't assume anything about `a' (and hence must pass a polymorphic callback, that assumes nothing about `a')
19:27:31 <ski> this reversal of r√¥les between caller/user/consumer and callee/implementor/producer/definer, as pertains to who may pick and choose the actual type to use for the type variable `a', and who has to make do with the choice that's being made, is due to, in the rank-two `blah', having `forall' "to the left (inside)" of a function arrow `->'
19:27:49 * hackage containers 0.6.4.1 - Assorted concrete container types  https://hackage.haskell.org/package/containers-0.6.4.1 (dfeuer)
19:27:59 <ski> if you have `foo :: forall a. (..a.. -> ..a..)', then the caller picks `a'
19:28:26 <ski> if you have `foo :: ... -> (forall a. ..a..)', then the caller still picks `a' (but the first argument isn't allowed to mention `a')
19:28:51 <ski> (note that e.g. `take :: forall a. Int -> [a] -> [a]' is basically the same thing as `take :: Int -> forall a. [a] -> [a]')
19:29:22 <ski> but if you have `foo :: (forall a. ..a..) -> ...', the rank-two case, then the callee will get to pick `a'
19:31:06 <ski> if we had `foo :: ((forall a. ..a..) -> ...) -> ...', this would be rank-three (having a `forall' "inside, to the left of", two function arrows `->'), then the r√¥les are reversed again, so that the caller again picks `a' (by selecting a rank-two callback to pass, which will pick an `a' (or several), to use with its polymorphic callback)
19:31:14 <ski> and so on, for higher ranks ..
19:32:39 <ski> (if there's several `forall's in a type, then we say the overall rank is the maximum of the individual ranks of the `forall's in it. ordinary polymorphic operations are rank-one. monomorphic operations could be said to be rank-zero, i suppose ..)
19:32:47 <ski> inkbottle : is this making sense ?
19:34:26 <inkbottle> I'm not done reading, I've been interrupted
19:35:21 <ski> take your time. if anything is unclear, if you want further elaboration, or you have questions or comments, please do tell
19:36:23 <ski> here's one other example of a rank-two (and in this case also polymorphic) operation :
19:36:34 <ski>   runST :: forall a. (forall s. ST s a) -> a
19:38:44 <inkbottle> The explanation in terms of "who pick 'a" is very interesting
19:38:58 <ski> for "running" (executing/performing) an `ST s'-action (`ST s' expressing a kind of state effects, where one can dynamically allocate mutable reference cells (and arrays), and read from and write to them. implemented in terms of actual update-in-place, unlike say `State s' (which has a single global state `s', no dynamic allocation))
19:39:47 <ski> yea, that's the main thing that happens, as we pass to higher ranks, we alternate between caller and callee picking
19:40:25 <ski> the usual reason for wanting to define a rank-two operation is that you actually want to use a callback with multiple choices for your type variable(s)
19:40:42 <ski> (as in my `blah' example a bit up)
19:41:40 <ski> another reason is to want to hide some implementation detail of the function, from its caller. that is, hide which (possiby single) type that the implementation uses
19:42:38 <ski> here's some kind of example of that. consider
19:42:49 * hackage monad-memo 0.5.2 - Memoization monad transformer  https://hackage.haskell.org/package/monad-memo-0.5.2 (EduardSergeev)
19:43:07 <ski>   newtype StateT s m a = MkStateT (s -> m (a,s))
19:43:35 <ski> there is a function
19:43:37 <ski> @type mapStateT
19:43:39 <lambdabot> (m (a, s) -> n (b, s)) -> StateT s m a -> StateT s n b
19:44:21 <ski> that can be used to change the `m' in `StateT s m a' to another monad, `n' (also here swapping `a' out for `b')
19:45:08 <ski> however, in the callback, we can see that we're handed an action of type `m (a,s)', that will produce a pair. and we're to give back a new action of type `n (b,s)', that will also produce a pair
19:45:22 <ski> one might consider this as "implementation detail leaking"
19:45:30 <ski> so, one could make a variant
19:46:09 <ski>   mapStateT' :: (forall h. m h -> n h) -> StateT s m a -> StateT s n a
19:47:08 <ski> where `h' here hides the pair type from the caller of the function. in some cases, this can be useful to prevent the callback that the caller provides, from messing around with the internal implementation (the values of the "hidden" type `h')
19:48:28 <ski> inkbottle : is that reasonably clear ?
19:50:20 <ski> (there are probably more suggestive examples of this "information hiding" capability of rank-two .. but i can't think offhand of one that would be quick to showcase)
20:13:18 <ski> inkbottle : anyway .. if you want to, perhaps we could continue this conversation later (getting to existentials, hopefully), as it's quite late here
20:45:49 * hackage stm-actor 0.1.0.0 - See the README  https://hackage.haskell.org/package/stm-actor-0.1.0.0 (sgschlesinger)
21:23:49 * hackage stm-actor 0.1.1.0 - See the README  https://hackage.haskell.org/package/stm-actor-0.1.1.0 (sgschlesinger)
21:27:19 * hackage stm-actor 0.1.1.1 - A simplistic actor model based on STM  https://hackage.haskell.org/package/stm-actor-0.1.1.1 (sgschlesinger)
21:32:19 * hackage wai-extra 3.0.32 - Provides some basic WAI handlers and middleware.  https://hackage.haskell.org/package/wai-extra-3.0.32 (MichaelSnoyman)
22:45:19 * hackage monad-memo 0.5.3 - Memoization monad transformer  https://hackage.haskell.org/package/monad-memo-0.5.3 (EduardSergeev)
23:45:39 <shad0w_> morning people. just droppin in to say Hi : )
23:46:03 <Axman6> Hello!
