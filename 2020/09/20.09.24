00:09:42 <petersen> Is there a patch to make hgrep work with CPP? (I am not sure if it stopped working?)
00:30:26 <dminuoso> petersen: Judging from a quick look, it should have CPP support already.
00:30:48 <dminuoso> https://github.com/thumphries/hgrep/issues/39
00:31:20 <dminuoso> You just need to figure out what the magical location of that settings file. ;)
00:50:18 * hackage dawg-ord 0.5.1.1 - Directed acyclic word graphs  https://hackage.haskell.org/package/dawg-ord-0.5.1.1 (JakubWaszczuk)
00:53:48 * hackage Z-Data 0.1.3.0 - Array, vector and text  https://hackage.haskell.org/package/Z-Data-0.1.3.0 (winterland)
01:18:20 * hackage dawg-ord 0.5.1.2 - Directed acyclic word graphs  https://hackage.haskell.org/package/dawg-ord-0.5.1.2 (JakubWaszczuk)
01:21:31 <idnar> reading http://h2.jaguarpaw.co.uk/posts/using-brain-less-refactoring-yahtzee/ and I think the parametricity argument is flawed because of the Eq superclass
01:22:29 <phadej> idnar: Num doesn't have Eq type-class
01:22:40 <phadej> (anymore)
01:22:58 <phadej> https://hackage.haskell.org/package/base-4.14.0.0/docs/Prelude.html#t:Num
01:23:23 <idnar> huh, when was it changed?
01:24:08 <phadej> https://hackage.haskell.org/package/base-4.5.0.0/docs/Prelude.html#t:Num is the first without
01:24:15 <phadej> i.e. GHC-7.4
01:24:25 <phadej> 8 years ago ;)
01:24:33 <idnar> wow
01:25:14 <idnar> I think that's older than any ghc version I've even used
01:25:54 <idnar> must have read it in the H98 report or something
01:26:48 * hackage hanabi-dealer 0.10.2.0 - Hanabi card game  https://hackage.haskell.org/package/hanabi-dealer-0.10.2.0 (SusumuKatayama)
01:32:52 <merijn> idnar: GHC user guide has a section on deviations from the report
01:34:13 <shad0w_> hi. i wanna see info on the Functor typeclass in ghci
01:34:30 <shad0w_> :i (Functor) or permutations doesn't seem to work ?
01:35:40 <phadej> try :i Functor
01:35:44 <phadej> without paranthesis
01:36:01 <shad0w_> lmao. i am an idot.
01:36:07 <shad0w_> thenks.
01:55:52 <AWizzArd> Yesterday I was looking for something bind-like for Monoids. `Config` is a Semigroup/Monoid.  setA, setB, ... setX, setY, setZ  are functions of type  :: x -> Config -> Config  (or instead of x it can be the letter after "set", so a/b/.../y/z).
01:56:06 <AWizzArd> If I continue like this then the nesting would become very deep: let conf = setX myX (setY myY defaultConfig)
01:56:41 <merijn> AWizzArd: oh, lemme tell you a cool trick :p
01:56:47 <merijn> Config is a Monoid, yeah?
01:57:38 <merijn> You can simply do "setX myX <> setY myY" (or, if you've got a lot of them: "mconcat [setX myX, setY myY, ... ]")
02:01:08 <AWizzArd> merijn: I am surprised.
02:01:19 <merijn> Why?
02:01:21 <AWizzArd> (<>) :: Semigroup a => a -> a -> a
02:01:55 <AWizzArd> So you are not using the Semigroup implementation of Config here?
02:02:02 <merijn> AWizzArd: "instance Semigroup a => Semigroup (r -> a) where f <> g = \x -> f x <> g x"
02:02:19 <merijn> It's the best Monoid/Semigroup instance!
02:02:20 <AWizzArd> Aha, so you are using the fact that Functions are a Semigroup
02:02:34 <merijn> Yeah
02:02:38 <AWizzArd> merijn: this was essentially what I was looking for. I saw this, dunno, a year ago.
02:02:53 <AWizzArd> But I remembered that Config was the SG constraint I was looking for.
02:02:58 <hekkaidekapus> AWizzArd: Seconding merijn, you could go further and use any other Foldable than [] and write `flip (appEndo . foldMap Endo) defaultConfig`.
02:03:00 <AWizzArd> And it didn’t play well with <>
02:03:49 <AWizzArd> Well, yesterday we came up with   foldr ($) defaultConfig [setX myX, setY myY, ...]
02:04:00 <AWizzArd> But this wasn’t using the Semigroupnissity here.
02:11:38 <AWizzArd> Another thing that surprised me:   main = putStrLn ("Hallo" :: Text)    <-- GHC complained about ambiguity. I would have expected that this explicit `:: Text` would help. GHC would understand that I didn’t accidentally hit the wrong key because a pencil fell on my keyboard and this happened to write exactly this char combination.
02:12:38 <merijn> AWizzArd: Would help how? What was the ambiguity?
02:13:13 <hekkaidekapus> @type putStrLn -- AWizzArd
02:13:15 <lambdabot> String -> IO ()
02:13:48 <AWizzArd> hekkaidekapus: I was using the one from Data.Text.IO (putStrLn)
02:14:00 <AWizzArd> So both functions were in scope.
02:14:14 <hekkaidekapus> So, qualify the usage.
02:14:34 <hekkaidekapus> Prelude. or Data.Text.
02:14:36 <AWizzArd> hekkaidekapus: yes of course, the fix was easy. But why didn’t the explicit type sig not help?
02:14:39 <hekkaidekapus> Prelude. or Data.Text.IO
02:14:52 <AWizzArd> -not
02:16:10 <lortabac> AWizzArd: for name overloading you need a type class
02:16:11 <hekkaidekapus> Because ("Hallo" :: Text) is its own thing and does not influence how putStrLn works.
02:21:12 <merijn> AWizzArd: GHC doesn't do type directed resolution, so adding a type annotation does nothing
02:21:14 <edwardk> idnar: removing the Eq and Show superclasses of Num was done to allow things like instance Num a => Num (x -> a) to not have to lie to users any more if brought in as an orphan. It isn't in scope by default, but it is a thing that was popular with the community at the time.
02:21:26 <edwardk> it was one of the first major breaks with the published report in GHC.
02:29:03 <shad0w_> `Any Haskeller worth their salt would reject this code as a gruesome abomination. `
02:29:15 <shad0w_>  - as read on typeclassopedia
02:29:18 <shad0w_> LMAO
02:30:11 <AWizzArd> shad0w_: (-:
02:31:50 <shad0w_> AWizzArd: lmao, what is that, Schrödinger's smiley ?
02:32:11 <MarcelineVQ> sometimes you gotta dodge left
02:32:22 <AWizzArd> MarcelineVQ: hahaha
02:33:42 <AWizzArd> MarcelineVQ: I just tried it, and we would have to do it like a chicken, i.e. keeping our head in the position it was before. That way the head will fall on its right side, and the truth of (-: becomes visible.
02:36:14 <MarcelineVQ> after all, why did the chicken cross the road
02:39:41 <tdammers> yeah, that was stupid. don't mess with the road, it'll send its goons to kidnap your children and kill them just to teach you to mind your own fucking business
02:39:59 <tdammers> anyway
02:44:32 <pjb> tdammers: yep: https://www.marcelhuijserphotography.com/blog/2014/12/road-ecology-blog-why-did-the-chicken-cross-the-road
02:45:13 <MarcelineVQ> all part of the unwritten book a da road
03:24:49 * hackage libsystemd-journal 1.4.5 - Haskell bindings to libsystemd-journal  https://hackage.haskell.org/package/libsystemd-journal-1.4.5 (OliverCharles)
03:42:41 <wjwh> Quick question: If I have a data structure with a single field like `data ShortText = { contents ::  {-# UNPACK #-} !ShortByteString }` , is it always better to make it a `newtype` ? I may want to expand it later with cached character counts etc
03:43:57 <Uniaika> wjwh: newtypes are more appropriate when there is a single field
03:44:19 <Uniaika> otherwise, just use `data`
03:44:47 <Uniaika> wjwh: now, to answer your question: you can use `newtype` at first and then convert to `data`
03:44:58 <Uniaika> it's not going to cost you much
03:44:59 <wjwh> Fair enough, that might be simpler
03:45:57 <wjwh> I'm confusing myself mightily with all this `deriving` stuff, probably more than is necessary
03:45:58 <wjwh> :)
03:51:12 <wjwh> Just tested, `UNPACK` won't work with `newtype` but I suppose that's less important for a newtype anyway 
03:53:04 <Uniaika> wjwh: https://kowainik.github.io/posts/deriving
03:53:07 <Uniaika> read.
03:53:12 <Uniaika> it's good content.
03:53:14 <wjwh> I already had it open :)
03:54:27 <wjwh> But the confusion comes not from the deriving syntax but from that I want some of the instances to differ from the underlying type but not all. :)
03:55:01 <wjwh> Ie `Functor` on ShortText should iterate over the utf8 codepoints, not over the bytes in the underlying ShortByteString
03:55:02 <wjwh> etc
03:56:17 <merijn> wjwh: ShortText can't be a functor
03:56:24 <merijn> The kind doesn't match
03:57:19 <wjwh> Fair enough. The Show instance then :)
04:01:11 <Uniaika> wjwh: I'm interested in how you're going to pull this off. :P Meanwhile, when I'm feeling nostalgic of proper string types, I read this https://hexdocs.pm/elixir/String.html
04:05:13 <wjwh> Uniaika FastString is already 80% of what we need, being an UTF-8 encoded ShortByteString with some extra fluff like hash consing. I'm going to reuse most of that, including the String -> ShortByteString UTF8 parsing from GHC.Util.Encoding. I looked at https://gitlab.haskell.org/ghc/ghc/-/merge_requests/4103 to see which functions I need to start
04:05:13 <wjwh> off with for package database reading and it's very manageable. I think the only thing we really need that is not already in FastString is a `Binary` instance
04:32:48 * hackage Z-Data 0.1.3.1 - Array, vector and text  https://hackage.haskell.org/package/Z-Data-0.1.3.1 (winterland)
04:48:27 <kuribas> > 1 `quot` 0
04:48:30 <lambdabot>  *Exception: divide by zero
05:12:19 * hackage sized 0.7.0.0 - Sized sequence data-types  https://hackage.haskell.org/package/sized-0.7.0.0 (HiromiIshii)
05:20:30 <dminuoso> `wjwh | [10:54:39] Ie `Functor` on ShortText should iterate over the utf8 codepoints, not over the bytes in the underlying ShortByteString`
05:20:38 <dminuoso> Ignoring merijn's point, why the codepoints?
05:21:17 <dminuoso> Once you get into textual data, there's lots of different and conflicting notions of what the "unit of reference is"
05:22:37 <phadej> I feel that wjwh made a mistake to ask about text stuff on this channel
05:23:00 <wjwh> :)
05:25:46 <merijn> Dealing with text is a mistake :p
05:26:56 <pjb> there's no such thing as utf8 codepoint.
05:27:04 <pjb> unicode codepoints are 21-bit.
05:27:15 <pjb> utf8 is a way to encode those 21-bit in a sequence of 8-bit bytes.
05:28:01 <dminuoso> Heh, I was debating whether to nitpick about that as well.
05:28:04 <opqdonut> surely there's an option to expand to at least 32 bits?
05:28:30 <tdammers> of course. trivially by padding with zeroes, or more involvedly using utf32 encoding
05:28:56 <dminuoso> opqdonut: Sure, but at the end a codepoint is the identifier of a character in the unicode tables. So there's no "utf8 codepoints" but "unicode codepoints"
05:28:57 <opqdonut> looks like utf-8 supports 31 bits, utf-16 doesn't
05:29:12 <opqdonut> dminuoso: yes, I just got surprised by the 21 bits
05:29:24 <merijn> opqdonut: Why?
05:29:37 <merijn> opqdonut: That's how many unicode codepoints there are
05:29:56 <merijn> More might be added in the future, sure, but we're not in the future :)
05:29:59 <dminuoso> 17 planes with 2^16 codepoints each.
05:30:05 <opqdonut> and not all planes are in use
05:30:24 <opqdonut> TIL
05:32:51 <dminuoso> Question... I have a servant app that runs with monad-logger for a custom server monad. I extract the logger with `askLoggerIO`, and build a wai middleware logger with it, and at the end I just run with runStdoutLoggingT which just uses `Data.ByteString.Char8.hPutStr stdout`
05:33:28 <dminuoso> This thing runs inside a docker container, and for reasons that beyond me, the log calls from inside the servant handlers do not produce visible output, while the wai middleware logger does
05:33:46 <dminuoso> The moment I set buffering mode to NoBuffering, the logging from the monad handler re-appears
05:37:02 <phadej> are you sure that your hoistServer sets up the logger properly?
05:37:15 <arianvp> phadej: is there any documentation of the haskell-ci config format?
05:37:24 <phadej> i.e. that the askLoggerIO you get isn't some $ \_ -> ()
05:37:34 <arianvp> (fixing up the CI for servant to support ghc-8.10 =) )
05:39:19 <phadej> adding tested-with: GHC ... || == 8.10.2 should do the trick
05:40:22 <phadej> haskell-ci --help lists the options, which can be used in cabal.haskell-ci 
05:41:11 <phadej> there's also `haskell-ci dump-config` which dumps default config (with comments) if you want to see what knobs are there
05:42:41 <dminuoso> phadej: Ah. Thanks for the question, so Im confident Im hoisting correctly https://gist.github.com/dminuoso/92c698fe5505711092ee6ecc93b021cc
05:43:07 <dminuoso> However, since you made me look, my assumption was wrong. Seems like I switched the wai middleware logger to not use my askLoggerIO provided logger after all.
05:43:59 <phadej> yes, askLoggerIO yet withStdoutLogger doesn't look right
05:44:14 <dminuoso> Should that matter though? I mean if they both just write chunks to stdout
05:44:23 <dminuoso> The fact I see output at all suggests stdout gets flushed at some points
05:44:51 <phadej> dunno.
05:53:05 <arianvp> phadej: thanks. I was mostly confused about what these "constraint-set"s are
05:53:07 <arianvp> e.g. https://github.com/haskell-servant/servant-swagger/blob/master/cabal.haskell-ci
06:10:49 * hackage uusi 0.0.0.0 - A program removing all version constraints of dependencies in .cabal file  https://hackage.haskell.org/package/uusi-0.0.0.0 (berberman)
06:31:31 <B3d14mit3> HI
06:31:40 <B3d14mit3> Hello world!
06:33:00 <B3d14mit3> Hello again!
06:37:46 <Xnuk> bye
06:53:40 <shad0w_> hi all.
06:53:59 <shad0w_> i am currently learning about Functors on my haskell quest
06:54:18 <shad0w_> as an exercise, i need to write the Functor for the data type
06:54:22 <shad0w_> `data ITree a = Leaf (Int -> a) | Node [ITree a]`
06:55:12 <shad0w_> what i came up with was
06:55:15 <shad0w_> `
06:55:18 <shad0w_> instance Functor ITree where
06:55:18 <shad0w_>   fmap g (Leaf f) = Leaf (g . f)
06:55:18 <shad0w_>   fmap _ (Node []) = Node []
06:55:18 <shad0w_>   fmap g (Node (x:xs)) = Node ([(fmap g x)] ++ [fmap g (Node xs)])
06:55:19 <shad0w_> `
06:55:19 <[exa]> shad0w_: please pastebin :]
06:55:46 <shad0w_> alright
06:56:18 <[exa]> anyway when it's already here, it looks pretty much okay, the question is why would you create a new Node for fmapping again if you already have stripped the "wrap" once?
06:57:23 <[exa]> (hint: recursing manually is sometimes just confusing, if you want to do the same action all over some kind of list, just use `map`)
06:57:24 <shad0w_> https://paste.ofcode.org/dxSxd9D9zkSqj86AvE6uXF
06:57:56 <shad0w_> it wouldn't pass the typechecker any other way i tried.
06:58:23 <shad0w_> this passed the type check but had me a little confused if it does what i think it does
06:58:28 <[exa]> shad0w_: (about pastebins -- pasting more than ~2-3 lines to IRC is widely frowned upon, people here generally don't mind a lot but pastebinning is safer)
06:59:11 <shad0w_> [exa]: i'll be mindfull of that, thanks. im new here. so my IRC ettiquites are a little (non-existant) lol
06:59:58 <[exa]> shad0w_: anyway, try giving the compiler this line (instd of both your variants for Node:
07:00:12 <[exa]> fmap g (Node a) = Node $ map _ a
07:00:46 <[exa]> the _ should produce a "nice" error that tells you what type you need to smash in there
07:02:28 <shad0w_> [exa]: it says found a hole: _ :: ITree a -> ITree b
07:02:49 * hackage signable-haskell-protoc 0.2 - Deterministic serialisation and signatures with proto-lens support  https://hackage.haskell.org/package/signable-haskell-protoc-0.2 (coingaming)
07:02:56 <shad0w_> that should just be an (fmap g)
07:04:18 * hackage signable 0.2 - Deterministic serialisation and signatures with proto-lens support  https://hackage.haskell.org/package/signable-0.2 (coingaming)
07:04:43 <shad0w_> byorgey: that was a nice exercise. i needed to grind my brain gears on that one.
07:06:47 <[exa]> shad0w_: yeah, that should work :]
07:07:26 <shad0w_> [exa]: Thanks for the help : )
07:07:47 <[exa]> shad0w_: anyway, you can look at the whole construction now as "getting through layers" -- you strip and re-do the Leaf and Node "tags", then you use whatever is needed to get into/modify the inner type
07:08:25 <[exa]> onion approach works quite well for this kind of exercises, and when you don't know, just leave a _ .
07:09:16 <shad0w_> getting fimiliar with the type signatures is what really helps me in the end
07:09:36 <shad0w_> okay i need to go from here -> here via this and this and then that
07:09:54 <[exa]> yeah there's a general approach to "just follow the types"
07:10:13 <shad0w_> but when a types get a little nested
07:10:26 <shad0w_> it gets hard to keep it in my brain all at once
07:10:32 <shad0w_> for now.
07:10:44 <tdammers> the great thing about typed languages is that you don't have to
07:10:48 <shad0w_> i think it's something you get the hang of as you progress ?
07:10:51 <tdammers> (keep it all in your brain at once, that is)
07:11:09 <tdammers> this is the real reason why people spell out types all the time even when the compiler could infer them
07:11:14 <tdammers> it's just easier on the brain
07:11:21 <shad0w_> i did a lot js in a previous life
07:11:25 <shad0w_> don't i know that lol
07:11:27 <tdammers> dump that information in the code so that the compiler can keep track for you
07:11:36 <[exa]> helps a lot eg with writing monad instances and lenses for whatever
07:11:52 <shad0w_> i am yet to get to those
07:12:34 <[exa]> the second best thing on explicit types written everywhere is that the type errors don't escape
07:12:44 <tdammers> yup
07:12:49 <[exa]> but you need a larger program to truly appreciate that
07:13:24 <tdammers> yeah, if your code is still within the size limits of the average programmer brain, the benefit is marginal, but once you get past that point, it's super helpful
07:13:26 <shad0w_> tdammers: i did a exercism exercise in nim. the mentor reponse was, remove the conrete type from the function signature. the compiler can infer it anyway
07:13:36 <shad0w_> i was like:- no can do's ville, baby doll.
07:13:41 <tdammers> a bit like asserts on pre- and post-conditions in imperative code, just way more accurate
07:14:15 <tdammers> well, I'm not familiar with nim, so I can't tell whether its type system is useful in the same way as Haskell's
07:14:53 <shad0w_> it has a type checker and infer-ness. but i don't think it's hinley milner or the likes
07:15:33 <tdammers> I mean, are the types expressive enough to add the kind of value that you can get out of Haskell's types
07:15:49 <shad0w_> no context on that lol
07:15:50 <tdammers> or is it more like int, bool, string, float, object, done?
07:15:52 <shad0w_> newbie in both
07:15:56 <tdammers> ah, fair enough
07:17:18 <shad0w_> it has macros too
07:17:31 <shad0w_> so i think you can do a fair bit of untyped stuff as well
07:17:40 <shad0w_> just never got around to doing that lol
07:17:46 <tdammers> macros don't have to bypass the type system
07:17:59 <shad0w_> haskell on the other hand. will probably wont let you do untyped stuff
07:18:01 <tdammers> Haskell has an untyped macro language (Template Haskell), but its output is stilly typed
07:18:37 <shad0w_> does haskell's FFI also have to be typed ?
07:18:45 <shad0w_> like if i interface a C lib
07:19:01 <[exa]> tdammers: you imply that average programmer brain has 25 lines? :D
07:19:16 <tdammers> [exa]: now that would be generous. it's really more like 7.
07:19:34 <[exa]> goooood
07:20:16 <davve> i struggle with 1 line sometimes
07:20:26 <tdammers> shad0w_: then you are responsible for declaring appropriate types on the Haskell side. the compiler will slap you when the types are grossly incompatible, but things like whether a C procedure has side effects (and should thus be declared to return IO something on the Haskell side), that's up to you
07:20:26 <davve> (horrible metric)
07:20:30 <[exa]> shad0w_: for FFI you need to provide some information on basically how to convert haskell types to C and back; some C types are mapped to normal haskell ones. Otherwise it just works (TM)
07:20:42 <[exa]> davve: how wide is your editor tho?
07:21:10 <davve> it automatically breaks at 120 I think
07:21:14 <davve> characters
07:21:25 <shad0w_> i see.
07:21:27 <tdammers> [exa]: if you have to ask what the maximum line length in vim is, then you're in trouble
07:23:08 <shad0w_> uhm. one more thing guys
07:23:10 <[exa]> let's measure code in tweets instead, that's a metric you can rely on
07:23:19 <tdammers> not at all
07:23:28 <shad0w_> there seem to be 2 laws for Functors
07:23:52 <shad0w_> and you can basically write code that typechecks but still violates the laws
07:23:54 <[exa]> tdammers: except for the SI-breaking 320character change ofc.
07:24:08 <tdammers> well, that, but also images, videos, etc
07:24:29 <shad0w_> so my Q is, whenever writing a Functor instance. do we also have to explicitly check that it's satisfying those 2 laws everytime ?
07:24:30 <tdammers> you can also encode a lot of information in diacritics
07:24:57 <[exa]> shad0w_: the laws are "standardized" so that you know what to expect from other people's functors. If you work with unlawful functors, stuff is likely to not work in unexpected weird ways
07:25:24 <[exa]> shad0w_: the usual problem with that is that the laws cannot be easily typechecked though
07:25:50 <tdammers> shad0w_: we don't *have* to; the compiler won't check your code for lawfulness, that's why they're laws, rather than typeclass methods. but it's very much recommended to obey those laws, because if your functor doesn't, then unexpected things can happen, such as things not being equal that should be
07:25:52 <geekosaur> there are languages where you must provide proofs of the laws; haskell is not one of them, because it's not powerful enough to test many of them
07:26:33 <shad0w_> [exa]: if i work with unlawful functors, stuff is likely to not work in unexpected weird ways? should'nt it be the opposite. like they will kindda glitch ?
07:27:29 <geekosaur> huh? it's on you to provide lawful functors, other things will assume lawfulness and may break if yours isn't
07:28:13 <tdammers> it probably helps to look at some concrete unlawful functors
07:28:17 <shad0w_> geekosaur: i see. so ensure lawfulness if you can everytime ? got it.
07:28:34 <tdammers> ensure lawfulness; if you can't, don't write that functor instance
07:28:34 <geekosaur> yes.
07:28:36 <shad0w_> tdammers: i did. does weird stuff that will glitch at runtime
07:29:20 <shad0w_> gotch'a guys. thanks much.
07:29:49 <tdammers> once you have a good intuition for the functor concept, judging the lawfulness of a functor instance becomes a lot easier
07:30:11 <Cale> All you have to check in Haskell is that fmap id = id
07:30:22 <Cale> Everything else gets enforced by parametricity
07:31:10 <shad0w_> Cale: so if the id works. the second one (function composition) should also work ?
07:31:52 <phadej> gadts...
07:33:20 <phadej> deriving (Functor) is the simplest
07:33:22 <Orbstheorem> Hello o/ I'm trying to write an lhs file in markdown, but GHC seems to try to interpret section headings somehow :/
07:33:45 <Orbstheorem> (i.g. `r"^#+.*"`)
07:34:24 <phadej> lhs files are latex by default
07:35:36 <geekosaur> or "bird tracks" (lines starting with "> " are documentation)
07:35:46 <Orbstheorem> I wrote my file using bird tracks.
07:35:53 <Orbstheorem> Oh: https://gitlab.haskell.org/ghc/ghc/-/wikis/literate-markdown
07:36:06 <phadej> geekosaur: other way around
07:36:14 <phadej> bird tracks are code
07:37:59 <Cale> shad0w_: yes
07:38:20 <Cale> @free (a -> b) -> f a -> f b
07:38:21 <lambdabot> Try `free <ident>` or `free <ident> :: <type>`
07:38:46 <Cale> @free putativeFmap :: (a -> b) -> f a -> f b
07:38:47 <lambdabot> Extra stuff at end of line
07:39:01 <Cale> hmm, I forget how to use this thing, lol
07:39:04 <Cale> @free fmap
07:39:06 <lambdabot> Extra stuff at end of line in retrieved type "Functor f => (a -> b) -> f a -> f b"
07:39:10 <Cale> weird
07:40:56 <sm[m]> "haskell's not relatively unpopular because it was late to add things like linear types. It's relatively unpopular because it doesn't care much about user experience. Consider: it's getting linear types before an efficient string type in `base`."
07:41:32 <maerwald>  true
07:41:37 <dolio> I think you might need quantifiers.
07:42:14 <maerwald> sm[m]: we tend to add esoteric stuff, but not care too much about technical deb
07:42:16 <maerwald> t
07:42:38 <dminuoso> sm[m]: I dont think it's the right characterization. I find it unlikely that the main thing that people drives away from Haskell is "String is inefficient".
07:42:59 <int-e> but why does it have to be in base... base is too big already
07:43:34 <Cale> The thing that prevents Haskell from being popular is that it is very much unlike most other programming languages
07:43:44 <geekosaur> I thought @free didn't support typeclasses or something like that
07:43:48 <sm[m]> here's the full comment for context: https://news.ycombinator.com/item?id=24570095 
07:44:00 <Cale> geekosaur: ah, perhaps!
07:44:00 <dolio> It supports some now.
07:44:02 <Cale> @free map
07:44:04 <lambdabot> g . h = k . f => $map g . map h = map k . $map f
07:44:11 <Cale> Yeah, there we go
07:44:20 <dolio> But it wouldn't support functor, I think.
07:44:33 <dolio> Oh wait, I think I'm thinking of djinn.
07:46:35 <AWizzArd> How efficiently can ghc compile this?   setA a <> setB b <> ... <> setZ z $ defaultConfig
07:46:59 <AWizzArd> The end result will be   setA a defaultConfig <> setB b defaultConfig <> ... <> setZ z defaultConfig
07:47:12 <dminuoso> AWizzArd: Hard to say in general.
07:47:29 <AWizzArd> ok
07:47:41 <dolio> It might figure it all out, but it seems like it's just asking for trouble.
07:47:43 <dmwit> How inefficient is it possible to get with something so simple?
07:48:04 <int-e> ghc inlines heavily so this can easily reduce to a single constructor application.
07:49:06 <dminuoso> AWizzArd: Also, for that concrete part, compile with -O2 and look at the core?
07:49:16 <dminuoso> Then you know exactly how GHC will compile it. ;)
07:49:25 <dmwit> The worst thing I can imagine the compiler doing has the same asymptotics as the best thing I can imagine it doing.
07:50:40 <int-e> Constructing a configuration... seems unlikely to be a hotspot in the code.
07:51:20 <int-e> If it were a hotspot... constant factors matter.
07:51:59 <int-e> (And we care. List fusion mostly does not affect asymptotics, but it makes a huge difference for constant factors.)
07:53:03 <int-e> (List fusion, ironically, also means that our inefficient String type can carry a lot of stuff efficiently enough... as long as strings are generated and consumed on the fly, not stored.)
07:54:10 <dolio> Does text do fusion?
07:54:26 <Taneb> Yes, sometimes
08:25:25 <AWizzArd> Is there a way to register some kind of onSuccessfulServerStart hook that will allow me to print "Service started!" somewhere?
08:31:52 <phadej> using what? warp?
08:32:24 <phadej> there is e.g. https://hackage.haskell.org/package/warp-3.3.13/docs/Network-Wai-Handler-Warp.html#v:setBeforeMainLoop
08:33:28 <AWizzArd> phadej: looks good
08:45:14 <nihilazo> hi, I'd like to compile some haskell software (and also maybe ghc itself, but that might be harder) for my aarch64 linux tablet. It doesn't have a native version of ghc currently available, is there a way to cross-compile haskell software/the compiler itself for aarch64?
08:46:09 <glguy> nihilazo: I don't know, but you might try #ghc as well
08:47:24 <phadej> there are ready bindists
08:51:28 <nihilazo> ready bindlists?
08:52:05 <phadej> already compiled BINary DISTibutions
08:52:10 <phadej> https://downloads.haskell.org/ghc/8.10.2/ has ghc-8.10.2-aarch64-deb10-linux.tar.xz  
08:52:15 <phadej> e.g.
08:52:44 <nihilazo> ah, I guess the binaries are just not available as packages in my distro
08:52:47 <nihilazo> thanks
08:53:30 <phadej> where deb10 tells which versions of system packages its compiled against (e.g. ncurses/libtinfo/...)
08:54:04 <nihilazo> ok, I'm on arch linux arm (I know that haskell people seem to hate arch, but it is the best of the distros available for my device)
08:54:22 <nihilazo> I'll try the bindists
08:57:18 <dolio> People used to recommend arch as the best for Haskell, but then arch did something that causes a huge amount of problems with the system packages.
08:57:46 <maerwald> when did ppl do that
08:57:59 <dolio> Several years ago.
09:00:13 <perdent> Anyone here a cryptographer or good with cryptography/maths?
09:01:04 <phadej> perdent: would you trust me if I say yes?
09:01:50 <perdent> phadej: don't need trust when i can test you :)
09:02:39 <phadej> are you looking for a person to employ?
09:02:59 <phadej> I don't feel like having tests now ->
09:03:45 <noctux> hmm, wasn't that shipping dynamic systems libraries for haskell exclusively?
09:04:45 <dolio> Not always.
09:04:58 <dolio> GHC didn't always have dynamic linking for Haskell libraries.
09:18:42 <AWizzArd> I just wanted to ask if anyone here has experience with using Gitlab as build server (ci/cd) and then realized that GHC itself is using it. This should hopefuly mean that less complex projects than GHC will also run fine with it.
09:20:39 <maerwald> AWizzArd: maintaining gitlab isn't fun
10:14:34 <AWizzArd> maerwald: your alternative?
10:15:01 <maerwald> AWizzArd: gitea, but I don't do CI there
10:15:10 <maerwald> it has some integration, but I don't know how good
10:15:47 <AWizzArd> maerwald: I am using gitea right now. Plus Jenkins.
10:16:12 <AWizzArd> I miss commenting commits and would like to have integrated ci.
10:23:52 <maerwald> I miss Software not pissing me off
10:24:33 <geekosaur> that happened at some point?
10:25:26 <maerwald> you missed it...
10:26:15 <sm[m]> That is a feature more software should prioritise
10:26:19 * hackage rpmbuild-order 0.4.3.1 - Order RPM packages by dependencies  https://hackage.haskell.org/package/rpmbuild-order-0.4.3.1 (JensPetersen)
10:30:34 <maerwald> sm[m]: I believe it was better 20 years ago. It just had less features
10:36:21 <sm[m]> I remember a lot of swearing at broken joysticks and unreliable tape drives. Strangely the software doesn't stand out, maybe you're right
10:36:43 <sm[m]> limited well defined scope
10:37:28 <sm[m]> and very simple dependencies at all times
10:37:50 <geekosaur> I kept running into software that didn't do what it was supposed to, starting with a crashing bug in my first computer (granting it was an uncommon machine)
10:38:04 <geekosaur> guess I always had the wrong software/hardware
10:38:41 <sm[m]> I'm sure you're more on the mark, I've just forgotten
10:39:53 <sm[m]> Sinclair computers used to crash when you wobbled the ram pack
10:39:53 <davean> I remember a lot of limits, but rarely anger inducing things. One bug stands out strongly, and that was with RPM package management ...
10:57:13 <AWizzArd> How can I see with cabal the exact version of my dependencies?
10:59:36 <sclv> AWizzArd: `cabal freeze` will generate a freeze file with exact versions
10:59:58 <sclv> you can then delete the file or move it to prevent it from "locking in" those deps to future runs
11:01:14 <AWizzArd> sclv: that looks good. The output file that you expect is named `cabal.config` yes?
11:04:59 <sclv> with recent cabal the file is cabal.project.freeze
11:05:11 <sclv> with cabal version 2 its something else
11:07:47 <AWizzArd> sclv: thx!
11:12:50 <p0a> Hello what is wrong with "fmap (-3) (Just 2)" ?
11:12:56 <p0a> I was expecting Just -1
11:13:32 <geekosaur> haskell oddity with negative numbers
11:14:09 <p0a> Oh whoops, thank you I just realized it
11:14:36 <geekosaur> the Prelude offers "subtract" as a workaround: fmap (subtract 3) (Just 2)
11:14:53 <p0a> What is the other way to write fmap?
11:15:14 <p0a> I wanted to negate, so I'll just negate :) 
11:15:42 <p0a> but in fact negate is not defined so I'll use (-1)* for matrices 
11:24:27 <monochrom> I think "fmap ((-1) *)" does it?
11:25:23 <monochrom> "the other way to write fmap" maybe you have infix <$> in mind?
11:25:29 <nshepperd> why isn't negate defined for you matrices
11:25:57 <merijn> Presumably they're not Num instances?
11:26:10 <p0a> nshepperd: I'm using hmatrix and it doesn't have it 
11:26:26 <p0a> but I can use ((-1)*) yeah. Thanks, <$> was what I had in mind 
11:27:36 <nshepperd> you sure? the source code on hackage seems to have negate = liftMatrix negate which is pretty much what you'd expect
11:29:49 <p0a> You may be right nshepperd I can't locate it myself, under which name?
11:32:37 <nshepperd> http://hackage.haskell.org/package/hmatrix-0.20.0.0/docs/src/Numeric.Matrix.html#line-48
11:34:07 <p0a> I can't get it to work 
11:35:16 <p0a> When I try `negate (2><2)[1,2,3,4]' I get the error No instance for (Num ([Double] -> Matrix Double)) arising from use of 'it'
11:36:35 <nshepperd> that's because it's parsing it like '(negate (2><2)) [1,2,3,4]'
11:37:20 <p0a> oooh thank you 
12:07:49 * hackage stm-actor 0.2.2.0 - A simplistic actor model based on STM  https://hackage.haskell.org/package/stm-actor-0.2.2.0 (sgschlesinger)
12:15:01 <Cheery> Can someone look in a bit and tell me if Ihave understood push/enter model correct? https://gist.github.com/cheery/685e28e2cd969451b0bde42ce801d269
12:17:36 <Cheery> The another thing I'd like to understand is the thunk update in STG. I wonder if they could be represented here through ST or IORefs.
12:23:48 <koz_> Cheery: Push-enter essentially behaves like Forth I think?
12:31:06 <dolio> I don't know if that representation is going to be able to really illustrate the difference between push/enter and eval/apply.
12:37:46 <dminuoso> Cheery: Did you read `How to make a fast curry: push/enter vs eval/apply` maybe? The introduction alone gives a very succint and accurate description.
12:39:51 <koz_> dminuoso: Is that the paper that basically says 'don't use push/enter'?
12:40:54 <Cheery> I'm a bit confused because I thought STG is still doing push/enter ?
12:53:44 <Cheery> koz_: I did scan the paper through.. It's saying the choice there is distraction for a compiler, but doesn't say anything about interpreters.
12:54:18 <Cheery> hm.. Maybe I should look into the rpython stg implementation and see if it's correctly built.
12:54:37 <Cheery> https://github.com/cgswords/laurens
13:00:25 <Cheery> but that's harder to look through though. I think the hard thing is the thunk updates.
13:02:26 <Cheery> It can be I overlook something.. The only place where a thunk is 'entered' is when it's dereferenced.
13:04:46 <dminuoso> Cheery: The STG stack contains arguments and continuations.
13:04:58 <dminuoso> On GHC's implementation, anyhow.
13:05:49 * hackage Z-IO 0.1.1.0 - Simple and high performance IO toolkit for Haskell  https://hackage.haskell.org/package/Z-IO-0.1.1.0 (winterland)
13:06:15 <dminuoso> For a better comparison, you can dive into ministg which provides both evaluation models
13:06:28 <dminuoso> https://hackage.haskell.org/package/ministg
13:08:54 <Cheery> oh so it doesn't change the STG, but there are two sets of operational semantics.
13:09:18 <Cheery> sets of rules*
13:09:19 <dolio> It doesn't change it much.
13:09:45 <dolio> And it has a lot more influence on levels below STG.
13:19:49 * hackage Z-IO 0.1.1.1 - Simple and high performance IO toolkit for Haskell  https://hackage.haskell.org/package/Z-IO-0.1.1.1 (winterland)
13:39:48 <koz_> Cheery: For interpreters, yeah, question is trickier.
13:39:55 <koz_> I'd have to re-read the paper to be sure.
13:42:18 <dolio> You don't have to.
13:42:28 <dolio> You should do what they did in the paper, build both and test which is better.
13:42:48 <koz_> dolio: I'd at least like to remind myself of their conclusions and why.
13:43:06 <koz_> Not saying it's equivalent to testing and measuring, but I'm curious what they found was holding push/enter back.
13:43:09 <koz_> (since I can't remember)
13:46:06 <dolio> The paper says it's impossible to tell which is better just by thinking about it. You need to actually test which is better.
13:46:57 <Cheery> yeah. I  think pypy community might have done this to you already.
13:47:01 <koz_> dolio: Thanks for the reminder.
13:51:43 <dolio> I'm not sure it's really going to make a lot of sense to implement push/enter in an interpreter in the way it actually shows up in that paper, though.
13:52:14 <dolio> Where each function has its own separate generated code that examines the stack for arguments.
13:53:30 <Cheery> yay.. I found a paper.
13:53:33 <Cheery> Trace-based just-in-time compiler for Haskell with RPython
13:54:17 <Cheery> it says they weren't able to beat GHC with that though.
13:56:39 <Cheery> about hundred times slower than ghc with -O2
13:56:54 <koz_> Cheery: Link to said paper?
13:57:01 <Cheery> https://ntnuopen.ntnu.no/ntnu-xmlui/bitstream/handle/11250/253137/618488_FULLTEXT01.pdf?sequence=1
13:57:24 <dolio> There's at least one sub-optimal case if you really implement some of what it says. Like, applying a PAp might dump all its stored arguments to the stack, then just copy them back to build a new PAp if it's still under-applied.
13:57:39 <dolio> But I'm not sure how much that case matters.
14:09:40 <Rembane> cabal install has two groups of commands that seem awfully similar too each other, are the v2-* and new-* aliases to each other?
14:09:54 <dolio> Yes.
14:10:05 <Rembane> Good. And confusing.
14:10:10 <Rembane> Thank you.
14:11:18 <merijn> Rembane: new- is from when they where in development and not actually intended to be used by anyone but brave souls
14:14:11 <Rembane> merijn: Got it. Those were the days... or something...
14:24:39 <merijn> Rembane: It worked well enough for me to switch :p
14:53:19 * hackage th-test-utils 1.1.0 - Utility functions for testing Template Haskell code  https://hackage.haskell.org/package/th-test-utils-1.1.0 (leapyear)
17:03:19 * hackage ttc 0.2.3.0 - Textual Type Classes  https://hackage.haskell.org/package/ttc-0.2.3.0 (TravisCardwell)
17:33:14 <koz_> I need to go from Data.Fixed.Pico to Data.Fixed.Milli, rounding down (i.e., hacking off all the digits I'm not interested in). How do I spell that?
17:35:06 <Axman6> coerce . (`div` 1000)
17:35:07 <Axman6> >_>
17:35:19 <koz_> Axman6: Wait seriously.
17:35:21 <Axman6> that's almost definitely wrong
17:35:28 <koz_> Yeah, I thought so.
17:35:39 <koz_> Since I don't think Fixed coerces like that.
17:35:40 <Axman6> I think
17:36:34 <Axman6> but, picoToMilli is probably something like picoToMilli (Fixed n) = Fixed (n `div` 1000000) -- I can't remember what the right factor is
17:37:44 <koz_> Well, Pico is Fixed E12, while Milli is Fixed E3, so I guess nine zeroes?
17:38:34 <c_wraith> I'm surprised there isn't a conversion function that uses a class to get those right.
17:38:52 <koz_> c_wraith: Me neither.
17:38:59 <koz_> s/neither/too/
17:39:02 <koz_> Argh.
17:39:07 <Axman6> would be nice if these days Fixed used Nat instead of unrelated data types
17:39:25 <Axman6> argh indeed, the queen would be ashamed commonwealth bro
17:39:26 <c_wraith> still, I think you should be able to use realToFrac ?
17:41:24 <koz_> c_wraith: Like, directly?
17:41:27 <koz_> :t 1e9
17:41:29 <lambdabot> Fractional p => p
17:41:33 <koz_> > 1e9
17:41:36 <lambdabot>  1.0e9
17:42:10 <c_wraith> yeah, Fixed has all the right instances
17:44:32 <koz_> Nice.
18:07:23 <wwwww> What is your toughts about realtime programs with haskell?
18:07:32 <koz_> wwwww: Define 'realtime'.
18:07:55 <wwwww> koz_: multiplayer game server
18:08:21 <koz_> wwwww: Like, for running a multiplayer FPS game?
18:08:29 <koz_> (for instance)
18:09:53 <wwwww> Not the game itself but the server, koz_
18:13:28 <c_wraith> so very soft realtime
18:14:25 <c_wraith> you can do that fine with GHC-compiled Haskell, though it might require some additional discipline to keep GC latency lower than you'd care about in many applications.
18:14:37 <Axman6> ir probably depends on how complicated the server is going to get - if it's something simple enough that there won't be much garbase, garbage collection shouldn't be such an issue. the new GC should help with latency too
18:14:57 <koz_> Axman6: Is new GC already landed, or is it landing in 9?
18:15:33 <Axman6> pretty sure it's in 8.10? I could be wrong
18:16:00 <c_wraith> there are also things you can do technically like using compact regions to massively reduce pointer chasing on retained memory.
18:16:20 <Axman6> yeah large, infrequently changing state should be in a compact region
18:17:18 <c_wraith> those are things that often don't matter, but might be really important for a soft realtime application.
18:17:34 <c_wraith> So...  the tools are available, but some of them require manual work.
18:20:19 <Axman6> As with most software, make it work, then make it fast
18:20:46 <koz_> Or alternatively, make it work, check if fast enough, make fast if not.
18:21:17 <Axman6> nah, just always make it fast
18:21:28 <wwwww> That's what i'm trying to do these days, threadscope was useful tool
18:21:31 <Axman6> save some penguins by using fewer cycles
18:29:23 <wwwww> I have 80% productivity according to profile but that 20% is GC 
18:29:29 <sm[m]> my first time using optparse-applicative in years (via optparse-simple).. could someone explain what I'm doing wrong here ? why won't it parse "2" to Just 2 ? https://paste.tomsmeding.com/6tXUenQu
18:31:55 <sm[m]> incidentally https://github.com/tomsmeding/pastebin-haskell deserves more stars
18:37:48 * hackage http-date 0.0.9 - HTTP Date parser/formatter  https://hackage.haskell.org/package/http-date-0.0.9 (KazuYamamoto)
18:38:59 <sm[m]> hmm, also why does optparse complain if I add +RTS ... or -- +RTS ... ? That doesn't happen with cmdargs
18:54:20 <Axman6> sm[m]: I think you're actually asking for a Maybe (Maybe Int) by using option
18:55:16 <Axman6> I'm surprised you'd have problems with +RTS ... -RTS, those args should never get to your app. are you closing them with -RTS?
18:56:31 <Axman6> sm[m]: basicazlly, I think what you need to do to fix the Maybe thing is not use value Nothing, just remove that and wrap the parser for that arg in optional (there's probably a better way, looking now)
18:56:50 <sm[m]> Axman6: thanks, you are helping
18:56:57 <Axman6> using value means that parser will never fail
18:58:11 <Axman6> uh, that isn't true, it'll ail is it can't parse the type you want
18:59:48 <Axman6> sm[m]: https://github.com/data61/Mirza/blob/07ac1dc96d158e316cde0d7195718599095bebc9/projects/trails/src/Mirza/Trails/Main.hs#L212 shows how to parse Maybe FilePAth
19:00:38 <Axman6> which is a FilePath with a Boston accent
19:04:02 <sm[m]> thanks! optional was the trick, https://paste.tomsmeding.com/OEBwVvKS#file-3
19:04:33 <Axman6> there's still more going on there than needed, one sec
19:05:01 <sm[m]> years later, optparse still makes me feel stupid 
19:05:26 <sm[m]> could better docs help ? I'm not sure
19:05:28 <Axman6> https://github.com/data61/Mirza/blob/07ac1dc96d158e316cde0d7195718599095bebc9/projects/trails/src/Mirza/Trails/Main.hs#L186 parses an Int using Read, so I thinkyou want optional (option auto (...))
19:06:01 <sm[m]> ah much better
19:06:14 <Axman6> no need for the readMay stuff
19:09:52 <sm[m]> and I see +RTS works fine when compiled, but GHCI messes up command line parsing causing optparse to see it
19:12:40 <Axman6> yeah you can't pass RTS args like that, since the RTS is already running, it's GHC's RTS
19:12:45 <Axman6> GHCi's*
19:13:15 <Axman6> if you need specific RTS args, then you'll need to start GHCi using them (probably)
19:22:19 <sm[m]> oh, aha, is that it. Thanks again!
19:34:19 * hackage aeson-schemas 1.3.0 - Easily consume JSON data on-demand with type-safety  https://hackage.haskell.org/package/aeson-schemas-1.3.0 (leapyear)
20:24:23 <z1> I'm trying to figure out why the runtime of this function is theta(km + n(m^2)). Is the (n(m^2)) term due to having to copy the (ws ++x) term each iteration?
20:24:25 <z1> f xss = g [] xss
20:24:27 <z1> g ws [] = ws
20:24:29 <z1> g ws (x:xs) = g (ws ++ x) xs
20:26:04 <dolio> Yes, `ws ++ x` has to rebuild `ws`.
20:26:09 <z1> @dolio awesome thanks!
20:26:09 <lambdabot> Unknown command, try @list
20:26:52 <ski> better use direct recursion version here, rather than an accumulator
20:28:54 <ski> in general, avoid left-nesting calls to `++', like `((([] ++ x0) ++ x1) ++ x2) ++ x3', which is what happens with the accumulator, in your definition
20:29:56 <ski> `x2' will there be traversed once, `x1' twice, `x0' thrice .. hence this ends up quadratic, rather than the expected linear
20:31:22 <ski> (also, if you'd like to, read about the "Schlemiel the Painter" algorithm, by Joel Spolsky, at <https://www.joelonsoftware.com/2001/12/11/back-to-basics/>)
21:37:18 * hackage antlr-haskell 0.1.0.1 - A Haskell implementation of the ANTLR top-down parser generator  https://hackage.haskell.org/package/antlr-haskell-0.1.0.1 (KarlCronburg)
22:08:19 * hackage graphql-client 1.1.0 - A client for Haskell programs to query a GraphQL API  https://hackage.haskell.org/package/graphql-client-1.1.0 (leapyear)
23:03:26 <MarcelineVQ> What would you call patterns like  Just{}  ?
23:04:32 <opqdonut> constructor-only patterns?
23:05:26 <MarcelineVQ> exactly, is that what you'd call them?
23:08:50 <opqdonut> yeah
23:46:49 * hackage hablog 0.7.0 - A blog system  https://hackage.haskell.org/package/hablog-0.7.0 (gilmi)
23:55:18 <dminuoso> MarcelineVQ: The Haskell report formally calls them labeled patterns in the general case.
