00:53:05 --- topic: 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: https://gist.github.com/ | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org'
00:53:05 --- topic: set by glguy on [Sat Jan 05 07:21:52 2019]
00:53:05 --- names: list (clog merijn denisse kritzefitz cur8or Unhammer danvet_ olle andreas303 borne raichoo ReneSecurestakin andyo John20 cfricke mariatsji ggole tonsofpcs1 jonathanx daenth oish coot danvet dhouthoo noecho maier xff0x_ graf_blutwurst Jesin salumu __Joker alp isovector1 p8m nshepperd dyeplexer DataComputist eldritch caubert Lord_of_Life voidcontext xts connrs_ beaky takuan Rudd0 day finkata- _vaibhavingale_ koh mnrmnaugh MarcelineVQ alexelcu quaestor hiroaki eyenx)
00:53:05 --- names: list (proofofkeags olligobber {abby} carldd1 bobey8 drewolson cheater C0__ DTZUZU_ xerox_ theDon spatchkaa a3f sooch Lycurgus lagothrix digia Flonk nineonine rypervenche dddddd perrier-jouet dexterlb DirefulSalt gxt__ plutoniix justanotheruser worc3131 inkbottle ryjm ryjm_matrix jedws untseac Jnitz10 gestone gehmehgeh aplainzetakind vk3wtf conal ambiso Codaraxis_ tomboy64 troydm rprije sw1nn notzmv ech spoonm sagax FledRebel hekkaidekapus Wamanuz Turmfalke tromp_)
00:53:05 --- names: list (klardotsh Thra11 jchia_ evanjs jchia__ cole-h DavidEichmann liff dmiles noctux unlink2 Guest27370 phaul drewr ystael munksgaard s00pcan nitrix pingiun hazard-pointer tanuki wavemode zaquest Kaivo lorozic shutdown_-h_now zgrep jzl jb55 riuga murphy_ m0rphism Kaiepi proteusguy wz1000 Foritus raoulb pfurla SupaYoshi iqubic jared-w benwr__ wpcarro davetapley liquorice AndreasK_ sdx23 bgamari dopplerg- CindyLinz sajith gentauro d0liver gareth__ natim87_ SrPx sveit)
00:53:05 --- names: list (ReinH_ gluegadget fii duckonomy_ Cthalupa rednaZ2 e2 urdh motherfsck Raito_Bezarius aidecoe revprez_stg quinn reallymemorable hongminhee _ashbreeze_ seanparsons stiell Lowl3v3l rembo10 amosbird ChaiTRex marble_visions lemmih zariuq nkly ttc cmcma20 jchia mrbuck jakalx atk gcoakes[m] nullheroes wangoe[m] _Tristan_ bennofs__ koz_ tms_ Unode Niamkik puffnfresh_ PtxDK qz lkurusa sm sud0 PyroLagus krjst dxld yushyin m-renaud kaychaks_riot Poscat[m] sajith[m])
00:53:05 --- names: list (jabruen[m] alexfmpe iphy Orbstheorem Axman6 Maxdamantus Eduard_Munteanu Benett ericsagnes mimi_vx cp- kyagrd__ ggVGc jophish Bigcheese shailangsa immae s4msung Gerula Alleria_ noctuks DavSanchez[m] zzz mozzarella nibbling hpc vqrs blase orion maerwald GyroW kav RusAlex Graypup_ leah2 werneta wagle Jonno_FTW Katarushisu nurupo Kneiva efertone justache Moyst bendo ft jlv itai33[m] Noughtmare[m] joshua[m]2 brnzhg[m] robin[m]1 Hatsue[m] dyniec[m] elorm[m] jiribenes)
00:53:05 --- names: list (jkaye[m] SlackIntegration macerbi[m] maralorn dominicusin[m] PotatoHatsue Ericson2314 siraben reed[m] iffsid betrion[m] Fernando-Basso[m kbse[m] domenkozar[m] sm[m] iinuwa michaelpj io_r_us[m] mikr[m] slycelote[m] chreekat[m] unclechu hnOsmium0001[m] rednaZ[m] hawnzug[m] johnnyboy[m] vaibhavsagar lambdaclan drozdziak1 theduke kadoban kaushikc psydruid lnxw37d4 stites[m] fgaz srid sureyeaah boistordu avocado camlriot42 hsiktas[m] themsay[m] Bergle_1 ephemeron)
00:53:05 --- names: list (gienah ishutin ridcully datajerk pounce enikar ephemera_ poljar tsrt^ thaumavorio cyphase eruditass L29Ah PragCypher dme2 tabemann sphalerite cemerick thecoffemaker thonkpod gawen seliopou vnz aizen_s echoreply Guest86335 recon_- eacameron whataday thunderrd wayne irclogger_com cohn luigy joehillen nckx a3Dman kini fr33domlover Profpatsch asm89 johnstein tasuki sea-gull Nik05 barrucadu infty Guest2620 Entroacceptor cjay bcoppens thebnq mikolaj_ comboy eedgit2)
00:53:05 --- names: list (sdrodge aldum rotaerk Benzi-Junior jluttine lucky dave_uy rdivyanshu_ Cir0X joshmeredith ebutleriv bradparker alanz_ systemfault zabracks fiadliel totbwf lally cvlad- banjiewen aristid pacak monochrom Randy xelxebar dolio furnost rom1504 mniip saurik lowryder verement bjobjo xintron stux|RC-only lassulus freeside orcus swater nisstyre DustyDingo cjh` coddinkn c-rog mupf ichimaru WzC jrqc towel wraithm landonf devalot glguy MagBo sim642 mp___313 balbirs yahb)
00:53:05 --- names: list (jameekim1 niko jathan [exa] tumdedum kipras`away petersen aweinstock absence kori zopsi brettgilio lambdabot AWizzArd acertain samebchase- reactormonk Tourist jle` kjak topos ap5 Hijiri_ mantovani_ leothrix simplegauss codedmart jamestmartin Papa tdammers entel _flow_ suppi dmj` alexknvl dani- thi tiru metadave tomsmeding darthThorik hodapp nekomune adamse juri_ davean cbarrett jackdk taktoa[c] drbrule pent Firedancer kozowu gregberns_ peel milessabin)
00:53:05 --- names: list (DigitalKiwi moobar beka abuss qzo dequbed alehander92 glowcoil mawk jtcs ViCi amiri mpickering byorgey polux2001 Cheery tessier sethetter__ nh2 hamishmack rizary idnar FMJz____ conjunctive NemesisD grfn ^[_ Adeon feepo mankyKitty lexi-lambda dsal chessai PatrickRobotham_ affinespaces Boarders cstrahan stylewarning verlet64_ dgpratt pasukon jetpack_joe rodlogic_ Nascha dsturnbull mudri newhoggy nick_h billstclair xyggos mcfilib jvsg bitonic heyj Uniaika bob)
00:53:05 --- names: list (teqwve Logio lockshaw connrs mrusme mmaruseacph2 averell pierrot dcoutts_ arahael jrm elcaro LittleFox graingert benschza noexcept ocharles terrorjack ghuntley riatre HiRE_ Reiser wspthr forell whiteline_ hvr gabiruh mstruebing bsima dibblego hyiltiz jjhoo dan64 xlei cgfbee glamas obfusk nyaomi Philonous rzmt TMA noteness tomku zfnmxt madnight texasmynsted NieDzejkob daGrevis Xnuk earthy theorbtwo hive-mind Tritlo rann adius sgraf martin02 pieguy128 heredoc)
00:53:05 --- names: list (benl23 PoliticsII___ simony kristjansson rslima____ typetetris J_Arcane otulp oldsk00l runawayfive twk- marek avp Uma chosenone i7c nerdypepper farn__ megaTherion Takumo atomi noCheese rawles milkii glowpelt uwap laxask bananagram dixie cow-orker ski Velpoman nh opqdonut Forkk Shun131 tensorpudding elvishjerricco johs caasih runeks parsnip angerman nek0 bjs andi- kkd hyiltiz-M amatecha__ higherorder liszt ullbeking jbetz miklcct chirpsalot Chobbes remexre p3n)
00:53:05 --- names: list (Remy robogoat iomonad fre SquidDev buggymcbugfix russruss8 jlpeters edwardk ProofTechnique betawaffle pepeiborra jonrh ibloom koankeeper wildsebastian e geal TommyC jol micro bind blackdog cantstanya magicman arw acowley zmagii jonatan @Sigyn srhb agander_m teehemkay veverak `slikts bonz060 jassob ArsenArsen hc lyxia canta adamCS APic lortabac grumble cods shapr d3lxa NGravity Guest60204 sshine morbeus dustinm- tv Ferdirand _xor debugloop wowi42 dpl greymalkin)
00:53:05 --- names: list (tstat infinisil avn Cale meck coeus mac10688 dftxbs3e Nikotiini javran int-e ezzieyguywuf ps-auxw Jajik yumh Inoperable ptrcmd valdyn strangeglyph atraii Madars mort vimto1 Eliel reyu djanatyn deni oleks pie_ anderson electrocat w1gz piele Zemyla hwabyong_ amx gilbertw1_ dminuoso msgctl malthe haskell_enthusia statusbot cyberlard Squarism bollu samebchase add^_ dh jhuizy quintasan anoe Dykam Jello_Raptor jdt raoul Patternmaster jinblack- shachaf hyperfekt srk)
00:53:05 --- names: list (Cathy Firedancer_ loc edwtjo kqr xarian BIG_JIMMY_D Ranhir xsarnik0 Arguggi eagleflo PlasmaStar joeyh jtobin ixian Athas RoguePointer doconthe1ocks stefan-_ sis7 PHO_ noan dqd albethere obiwahn sujeet LambdaDuck quicksilver xwvvvvwx Igloo incognito9999 MasseR chindy mflux jmsx dhananjay Taneb ben_m scav wallacer3 incertia Clint fredcy zymurgy zyeri lucianp JSharp myme epta m4lvin raid EvanR dmwit bandali dale Someguy123 dumptruckman niklasb_ infinity0 TimWolla)
00:53:05 --- names: list (auri_ aurieeeh haasn Tene haveo nshepperd2 ent janne alunduil sclv enemeth79 ajmcmiddlin yogani madog ekleog duairc m1dnight_ phaazon mr_yogurt sqrt2 HoolaBoola bastelfreak cross Ekho Rembane pong styledash Vq tabaqui tnks chpatrick parseval mceier feuerbach ByronJohnson jackhill wei PotatoGim gaze__ carter kip ornxka nlofaro ring0` chrpape atle_ spamlessj deu hexo Adluc Jon komasa relrod cheers sarahzrf aib Klumben saidinwot1 Faye DwarfMaster crtschin bwe nopf)
00:53:05 --- names: list (esotericalgo lieven Tspoon supki gargawel heath cynick lemald jvanbure bobbytables Deewiant fiddlerwoaroof jkarni exferenceBot mikolaj Sparadox uberj phadej xe4 tureba esg joeytwiddle lpsmith davl esph gekh12 dredozubov kloeri fiQ2 jfredett_ abrar lnx ahf Drezil oats fliife850 MindlessDrone electrostat CitizenS- arianvp energizer tristanC suzu_ ego drdo dexterfoo @ChanServ rdivacky sim590 sayak1 NinjaTrappeur Cerise M2tias pharaun stvc Geekingfrog peutri)
00:53:05 --- names: list (michalrus kaol agrif koala_man so hackage Techcable davve Khisanth dysfigured tinwood Majiir c_wraith catern kosmikus Blkt Chousuke Ankhers IceMichael vodkaInferno bcmiller jonge cpape integral lightandlight acro t36s_ SegFaultAX xacktm mjuad hexagoxel vjoki grol nemesit|znc andjjj23 bob_twinkles pdxleif dilinger rprosper- ashnur shadowdaemon idupree2 tolt bspar magog nikola2 ManiacTwister mingc SolarAquarion mursu edmundnoble bgavran copypasteque_)
00:53:05 --- names: list (interruptinuse lukelau cocreature solarus nshepperd1 operand xcin xnyhps PigDude tomjaguarpaw jorj hiredman arkeet vancz statusfailed rodgzilla nf divVerent turq [df] gothos ammar2 newsham gambpang carbolymer)
01:07:19 * hackage free-algebras 0.1.0.0 - Free algebras  https://hackage.haskell.org/package/free-algebras-0.1.0.0 (coot)
01:13:51 <typetetris> Any advice for generating clients with servant for nested apis? Like  `(AuthProtect "blub" :> (a :<|> b :<|> ...)` ? 
01:14:29 <typetetris> Maybe unnest the api, but then I have to repeat `AuthProtect` for all the nested endpoints.
01:17:04 <domenkozar[m]> is there a way to convert any product into a tuple via generics?
01:24:32 <dminuoso> typetetris: https://gist.github.com/dminuoso/15ed9589b0611072e39024eee8cd7d14
01:25:24 <dminuoso> There's an equivalent way with generics
01:26:15 <dminuoso> https://docs.servant.dev/en/stable/cookbook/generic/Generic.html#api
01:26:48 <typetetris> dminuoso: Thank you very much!
01:26:58 <domenkozar[m]> typetetris: https://github.com/cachix/cachix/blob/master/cachix/src/Cachix/Client/Servant.hs#L41
01:27:17 <domenkozar[m]> that's with generics
01:29:17 * Lycurgus fascinating
01:36:48 <typetetris> Is it intentional, that `createNar` doesn't have `CachixAuth` but all the over record members have it?
01:39:21 <kuribas> dminuoso: hi
01:39:33 <phadej> #lambda 
01:39:35 <phadej> eh
01:39:36 <kuribas> dminuoso: I checked the source for pcre-builtin, but there is nothing weird in there.
01:40:00 <kuribas> dminuoso: It calls an unsafe FFI function that returns an allocated regex.
01:40:12 <kuribas> and wraps it in a foreignPtr
01:40:32 <kuribas> I don't see why -threaded would make it fail.
01:40:35 <kuribas> maybe a ghc bug?
01:40:57 <dminuoso> kuribas: Because the invariant the C library expects is violated.
01:41:13 <kuribas> dminuoso: I don't see that
01:41:50 <dminuoso> kuribas: Does the code ensure that pcre_malloc, pcre_free, pcre_stack_malloc, and pcre_stack_free, and thecallout  and  stack-checking  functions  pointed to by pcre_callout and pcre_stack_guard all run in the same bound OS thread?
01:41:55 <dminuoso> s/bound//
01:42:04 <dminuoso> Err, that they are shared.
01:42:06 <kuribas> dminuoso: also, -threaded but with one thread still triggers the bug
01:42:33 <kuribas> dminuoso: it doesn't even use those functions
01:43:08 <kuribas> https://github.com/audreyt/regex-pcre-builtin/blob/master/src/Text/Regex/PCRE/Wrap.hsc
01:44:11 <kuribas> it does use alloca for temporary pointers
02:02:38 <kuribas> why does an "unsafe" function halt all other threads?
02:05:43 <kuribas> because it messes up the stack?
02:07:07 <lemmih> It could get in the way of cooperative multithreading. If the "unsafe" function blocks or never returns then all other Haskell threads in the execution context will be stuck.
02:08:19 <phadej> read the manual, but TL;DR when calling unsafe functions RTS make sure that no (also unpinned) objects are moved
02:08:26 <phadej> i.e. essentially prevents GC
02:08:55 <phadej> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ffi-chap.html#guaranteed-call-safety
02:09:17 <phadej> > However, since version 8.4 this is no longer the case: GHC guarantees that garbage collection will never occur during an unsafe call, even in the bytecode interpreter, and further guarantees that unsafe calls will be performed in the calling thread.
02:09:19 <lambdabot>  <hint>:1:8: error: <hint>:1:8: error: parse error on input ‘,’
02:10:03 <phadej> unsafe ffi calls is "I have no idea what that C function does"
02:13:40 <kuribas> phadej: should pcre use safe then?
02:14:04 <phadej> you have to read the pcre docs/code to know whether it can be safe or not. I don't know.
02:14:08 <kuribas> phadej: it only uses foreignPtr
02:14:16 <kuribas> which will not be moved right?
02:14:58 <dminuoso> kuribas: How does it expose haskell world data to the library?
02:15:05 <dminuoso> Are they copied into a pinned buffer?
02:15:22 <kuribas> https://github.com/audreyt/regex-pcre-builtin/blob/master/src/Text/Regex/PCRE/Wrap.hsc#L346
02:35:26 <kuribas> It does use CString
02:58:19 * hackage uniqueness-periods-vector-properties 0.3.0.0 - Metrices for the maximum element for the uniqueness-periods-vector packages family.  https://hackage.haskell.org/package/uniqueness-periods-vector-properties-0.3.0.0 (OleksandrZhabenko)
03:09:49 * hackage uniqueness-periods-vector-general 0.2.0.2 - Generalization of the functionality of the dobutokO-poetry-general-languages package  https://hackage.haskell.org/package/uniqueness-periods-vector-general-0.2.0.2 (OleksandrZhabenko)
03:42:49 * hackage aeson-value-parser 0.19.1 - API for parsing "aeson" JSON tree into Haskell types  https://hackage.haskell.org/package/aeson-value-parser-0.19.1 (NikitaVolkov)
03:52:50 * hackage aeson-value-parser 0.19.2 - API for parsing "aeson" JSON tree into Haskell types  https://hackage.haskell.org/package/aeson-value-parser-0.19.2 (NikitaVolkov)
04:13:19 * hackage bitstream 0.3.0.1 - Fast, packed, strict and lazy bit streams with stream fusion  https://hackage.haskell.org/package/bitstream-0.3.0.1 (MasatakeDaimon)
04:23:19 <Philonous> There's no way to make GHC treat incomplete pattern matches as errors without -Werror, is there? 
04:23:43 <tdammers> why do you need another way?
04:24:08 <phadej> you an say-Werror=warning-name to make only specific warnings into errors
04:25:48 <Philonous> phadej, Oh, that's amazing, thanks!
04:26:05 <Philonous> tdammers, Only because I didn't realize -Werror could be used for individual warnings.
04:26:31 <phadej> read the manual...
04:28:15 <Philonous> I did. -Werror=<warning> has it's own entry and I missed it. Still, my bad. 
05:13:19 * hackage uniqueness-periods-vector-general 0.2.1.0 - Generalization of the functionality of the dobutokO-poetry-general-languages package  https://hackage.haskell.org/package/uniqueness-periods-vector-general-0.2.1.0 (OleksandrZhabenko)
05:53:43 <kuribas> I am now getting the same pcre errors in my non-threaded built
05:54:04 <lemmih> kuribas: What errors?
05:54:06 <kuribas> and they change randomly depending on where I put traces.
05:54:20 <kuribas> lemmih: user error (Text.Regex.PCRE.Text died: (35,"missing )"))
05:54:47 <kuribas> and if I change something independent (like put a trace somewhere), the error message changes.
05:54:49 <merijn> kuribas: Eh, that looks like, well, user error caused by a missing ')'? :p
05:55:15 <kuribas> merijn: then why would it run well sometimes, gives different errors, without changing the patterns?
05:55:34 <lemmih> kuribas: Maybe because you're forcing different lazy expressions.
05:55:34 <kuribas> merijn: depending on random stuff, adding threading to the executable, putting traces somewhere, etc...
05:56:14 <kuribas> lemmih: changing a compiler flag changes the evaluation order?
05:56:20 <lemmih> kuribas: Yes.
05:56:36 <kuribas> lemmih: and sometimes it runs without errors?
05:56:45 <merijn> The evaluation order isn't guaranteed to be deterministic regardless :p
05:57:01 <kuribas> but the program is deterministic
05:57:07 <lemmih> kuribas: Yes. You can even write a 'areOptimizationsEnabled :: Bool' function. And throw an error if -O is on. :)
05:57:33 <kuribas> lemmih: that's not useful for my case
05:58:12 <kuribas> I am guessing either a compiler bug, or a bug in the library.
05:58:36 <merijn> I would guess the latter :p
05:58:44 <lemmih> I would be very surprised if it was a compiler bug.
05:59:02 <lemmih> My money is on user error or mis-feature in the library.
05:59:10 <sshine> kuribas, why do you use pcre?
06:02:19 <sshine> FFI suddenly seems more complicated than I previously thought. :)
06:03:52 <merijn> sshine: How so?
06:04:11 <merijn> lemmih: Technically areOptimizationsEnabled isn't a function ;)
06:05:56 <sshine> maybe not a Haskell function, but surely a function of something. :-D
06:06:04 <dumptruckman> So, does someone know how to set up vscode to run haskell stuff on windows?
06:06:13 <lemmih> Well, the source code changes over time so clearly its true signature is 'Time -> Bool'. :P
06:06:14 <dumptruckman> I've got the haskell extension installed and ghc 8.10.2
06:06:39 <dumptruckman> it does syntax highlighting and shows documentation on hover
06:06:42 <merijn> dumptruckman: Presumably *someone* does, but locating that someone may be tricky ;)
06:06:49 <lemmih> dumptruckman: Neat. That sounds like it works.
06:06:52 <dumptruckman> i don't see how i'm suppose to actually run anything
06:07:14 <lemmih> dumptruckman: Well, I don't think VS Code runs things for you.
06:07:30 <lemmih> dumptruckman: Open a powershell and run things from there.
06:07:38 <sshine> dumptruckman, you can still do that in the console. but vscode has options for building projects by hitting shortcuts.
06:08:15 <dumptruckman> Well, the haskell extension says: "Code evaluation (Haskell Language Server)"
06:08:16 <sshine> dumptruckman, for some reason I think you'll find many here tab into the console when they build things...
06:08:23 <dumptruckman> and has a gif that shows code being evaluated inline
06:09:18 <sshine> hmm yeah, I haven't made it evaluate code in my vscode on Mac either. it seemed like a neat feature, but not really necessary so I didn't investigate further.
06:09:49 <lemmih> dumptruckman: You don't see anything when you write '-- >>> length "Hello world"' ?
06:09:53 <dumptruckman> here's the gif https://camo.githubusercontent.com/c51d8a4aa1087a9f3a4a0032847ded632ec677ab/68747470733a2f2f692e696d6775722e636f6d2f626839393273542e676966
06:10:03 <sshine> I would like if it showed realtime type errors like it was possible with ghcide.
06:10:23 <dumptruckman> lemih: why yes!
06:10:49 * hackage uniqueness-periods-vector-common 0.2.0.0 - Generalization of the dobutokO-poetry-general package functionality  https://hackage.haskell.org/package/uniqueness-periods-vector-common-0.2.0.0 (OleksandrZhabenko)
06:11:34 <dumptruckman> lemmih: thank you!!
06:11:50 <dumptruckman> i did not realize that comment was what it was evaluating lol
06:11:53 <lemmih> dumptruckman: You're welcome. I'm glad it works on Windows.
06:12:23 <sshine> vscode seems like a pretty homogenous experience across all platforms.
06:13:09 <dumptruckman> without cabal/stack installing a library would just be putting the files in a referenceable directory, right?
06:13:34 <sshine> dumptruckman, or by referencing github repositories.
06:13:48 <dumptruckman> oh
06:13:52 <dumptruckman> how do you do that?
06:14:49 * hackage uniqueness-periods-vector-general 0.2.2.0 - Generalization of the functionality of the dobutokO-poetry-general-languages package  https://hackage.haskell.org/package/uniqueness-periods-vector-general-0.2.2.0 (OleksandrZhabenko)
06:14:59 <sshine> dumptruckman, here's an example with stack: https://docs.haskellstack.org/en/stable/yaml_configuration/#extra-deps
06:15:12 <dumptruckman> i said without stack or cabal
06:15:41 <dumptruckman> I want to avoid using either for now because everytime I try I just get fed up and never actually do anything with haskell
06:16:06 <sshine> dumptruckman, oh, I thought you meant without hackage or stackage.
06:16:56 <sshine> dumptruckman, sounds like scope creep. start out with a simple logical problem, get hold of a template project to stick your .hs files in, and run 'stack build' or 'cabal build' and don't touch the config files too much? :)
06:17:25 <dumptruckman> is it okay to have ghc installed separately from stack?
06:17:42 <lemmih> dumptruckman: Sure.
06:22:14 <kuribas> sshine: to have \d
06:26:12 <merijn> kuribas: Isn't tha just [0-9] ?
06:26:24 <kuribas> merijn: yes
06:41:06 <kuribas> merijn, lemmih: changing Text to ByteString seemed to solve the issue.
06:41:19 <kuribas> but that's the wrong datatype for Text
06:42:55 <lemmih> kuribas: Do you have a minimal example of the errors you're seeing?
06:43:18 <kuribas> lemmih: not now, I can make one later...
07:32:49 * hackage weeder 2.1.1 - Detect dead code  https://hackage.haskell.org/package/weeder-2.1.1 (OliverCharles)
07:33:31 <ziman> hello, I have (conceptually) `class C (t :: Bool)` and two instances `C True` an `C False` so I know the instance coverage is total. Can I somehow get rid of having `f :: (C b) => ...` in every function that uses it? More generally, I have runtime code that should depend on a compile-time index (which i currently model as a method chosen by typeclass resolution), and I provide code for every
07:33:33 <ziman> possible index value. Is there a better way than (ab)using typeclasses for this?
07:36:39 <ziman> In a dependently typed language, i'd just define a total function on the index but in haskell i can't because the index lives at the type level and is inferred. So i don't want to add extra singleton arguments because I'd lose inference and it would be ugly boilerplate, too.
07:38:19 * hackage uniqueness-periods-vector 0.3.0.0 - Generalization of the uniqueness-periods and uniqueness-periods-general packages functionality.  https://hackage.haskell.org/package/uniqueness-periods-vector-0.3.0.0 (OleksandrZhabenko)
07:40:48 <kuribas> lemmih, merijn, dminuoso I think I see what's happening.  It's not checking if the string is null terminated.
07:40:49 * hackage uniqueness-periods-vector-properties 0.3.1.0 - Metrices for the maximum element for the uniqueness-periods-vector packages family.  https://hackage.haskell.org/package/uniqueness-periods-vector-properties-0.3.1.0 (OleksandrZhabenko)
07:41:34 <kuribas> merijn, lemmih, dminuoso: that would account for the changing error messages, as the trailing garbage would change everytime.
07:43:35 <sm[m]> ha.. TIL that regex-pcre-builtin's maintainer is also Taiwan's digital minister
07:45:11 <ystael> whoa, Audrey Tang is a cabinet minister?!
07:45:20 <sm[m]> better than the usual FOSS maintainer excuse: https://github.com/audreyt/regex-pcre-builtin/issues/14#issuecomment-629821599 
07:47:24 <sm[m]> I was going to joke that this explains why Taiwan was so efficient but covid, but maybe it's true.. https://www.wired.com/story/how-taiwans-unlikely-digital-minister-hacked-the-pandemic
07:47:29 <sm[m]> s/but/with/
08:00:11 <Cale> ziman: Just use CPP to define stuff differently?
08:01:18 <ziman> audrey talks about that here: https://www.youtube.com/watch?v=h8CDYGNUC8I
08:02:54 <ziman> Cale: could you give a small illustration of what you mean? (assuming you mean the preprocessor?)
08:05:52 <kuribas> is it correct that an "unsafe" FFI call cannot run concurrently?
08:06:01 <kuribas> unless you use forkOS or so?
08:07:21 <kuribas> so "unsafe" if faster, but you lose concurrency?
08:07:56 <Cale> ziman: I mean, if you're just trying to change behaviour based on a compile-time constant, you can #ifdef whatever definitions would initially be affected
08:08:22 <Cale> and then do something like set up a flag in cabal with  cpp-options: -DMYFLAG
08:08:49 <Cale> But maybe I don't quite understand what's going on with this class
08:09:16 <int-e> kuribas: unsafe calls happen directly in the Haskell worker thread... other threads also continue to run.
08:09:35 <merijn> kuribas: Are you referring to unsafe foreign imports?
08:09:40 <kuribas> merijn: yeah
08:09:48 <kuribas> int-e: in another OS thread?
08:09:55 <merijn> kuribas: unsafe foreign imports are basically "jump right to the foreign C code"
08:10:08 <int-e> kuribas: However, GC cannot take place while an unsafe foreign call is taking place.
08:10:17 <merijn> kuribas: This means the capability running said C code will be ignoring things like GC until the foreign call completes
08:10:41 <merijn> kuribas: safe foreign imports will first "release" the capability before doing the foreign call
08:10:52 <merijn> This introduces some overhead, but avoids getting GC stuck
08:10:53 <kuribas> merijn: ah right, so you can still have concurrency as long as you have multie OS threads?
08:11:26 <merijn> kuribas: http://blog.ezyang.com/2014/12/unintended-consequences-bound-threads-and-unsafe-ffi-calls/
08:11:29 <int-e> (Hmm, not sure I have this correct... I believe even minor GCs need to briefly sync all threads to collect roots?)
08:11:52 <merijn> kuribas: The problem with unsafe imports is that you can end up blocking GC (and therefore other Haskell threads) arbitrarily long
08:12:01 <merijn> Which is generally considered "A Bad Thing (TM)"
08:12:17 <merijn> int-e: Nursery can be collected independently, afaik
08:13:11 <merijn> kuribas: The best heuristic is "never use unsafe unless you're super-duper sure you know enough about GHC and how things work to be sure that it's fine"
08:13:26 <kuribas> merijn: all ffi calls for pcre are unsafe
08:13:49 * hackage weeder 2.1.2 - Detect dead code  https://hackage.haskell.org/package/weeder-2.1.2 (OliverCharles)
08:13:52 <kuribas> merijn: while I was hoping for cheap paralellism
08:14:16 <merijn> kuribas: Are you processing multiple files independently?
08:14:30 <merijn> i.e. is the problem really trivially parallelisable
08:14:35 <kuribas> merijn: no, I have one big CSV with 200000 lines
08:14:51 <merijn> then you can't meaningfully parallelise anyway
08:14:56 <merijn> What would you parallelise?
08:15:06 <kuribas> merijn: it's running the same regexes on each line
08:15:27 <merijn> kuribas: Sure, but you need to sequentially walk through the file to figure out where lines are
08:15:48 <kuribas> merijn: yeah, but I assume running the regexes takes much longer than loading the lines
08:16:42 <merijn> Maybe
08:16:46 <merijn> I'm not sure, though
08:16:50 <merijn> Depends on the regex
08:17:20 <phadej> merijn: one can mmap the whole file. opportunistically divide it in say 8 segments, and run thing on "lines starting in the segment"
08:17:24 <kuribas> merijn: I am sure the 7 seconds are not spend on reading the file.
08:17:31 <phadej> it won't be equal division of work, but good enough
08:17:55 <phadej> but if one want small memory usage, then it indeed becomes tricky
08:17:56 <merijn> phadej: Sure, but that amounts to "rearchitecture your whole code"
08:18:05 <kuribas> phadej: I don't care about memory
08:18:11 <kuribas> phadej: this will not run on a server
08:18:14 <merijn> phadej: I was under the implicit assumption that that was implicitly a non-goal :p
08:18:27 <ziman> Cale: right, the actual thing is that I have `data Check = AsciiOnly | ShorterThan Nat | (:&&:)`, plus `class IsCheck (c :: Check) where check :: Proxy c -> Text -> Bool`. I'd like to define `checkText :: forall (c :: Check). Text -> Maybe (CheckedText c)` without having to include `IsCheck c => ...` in the type signature of `checkText` because I know that `IsCheck` is total on `Check`.
08:19:00 <ziman> maybe I should have presented it in this more concrete form from the start :)
08:19:02 <phadej> then I'd do that. CSV is nice as you can find the separators (newline characters) easily. No need to walk sequentially
08:19:12 <kuribas> merijn: but as I understand it now, with the pcre "unsafe" calls, I cannot paralellize?
08:19:27 <kuribas> merijn: unless I run it in IO and use forkOS?
08:19:29 <phadej> you can, just don't create garbage
08:19:38 <merijn> kuribas: I'm not sure which part of my explanation led you to conclude that
08:19:53 <phadej> pcre is thread safe
08:20:02 <kuribas> merijn: the one where garbage collecting will halt all threads?
08:20:17 <phadej>  The compiled form of a regular expression is not altered during  match-
08:20:17 <phadej>    ing, so the same compiled pattern can safely be used by several threads
08:20:17 <phadej>    at once.
08:20:21 <merijn> kuribas: That's always the case
08:20:31 <kuribas> merijn: and the "unsafe" call will block the garbage collection?
08:20:39 <merijn> kuribas: The problem is that long running unsafe calls will block for the entire durection of the unsafe call
08:20:50 <merijn> kuribas: So whether that's an issue depends on how long the average unsafe call is
08:21:17 <phadej> (and the amount of garbage created)
08:21:45 <phadej> fwiw, making own bindings to libpcre is not that hard
08:21:53 <phadej> and regex interface is just awful anyway
08:22:09 <int-e> But if it's a long call then you should not have to worry about the overhead of making a safe call.
08:22:34 <merijn> int-e: Sure
08:22:54 <merijn> int-e: But I've had people make PRs to my code making everything "unsafe" because "it's more efficient" >.>
08:23:48 <int-e> merijn: That... is terrible.
08:23:56 <kuribas> merijn: if I assume most of the time is spend in the unsafe regex call, can it run several in parallel?
08:24:05 <phadej> there should be "safe" variant which is "cheap", as doesn't have "C code can call into Haskell code" setup done.
08:24:40 <Cale> ziman: hmm, okay.
08:26:15 <int-e> "unsafe" is a promise that the underlying function is *always* quick to finish, and furthermore, that it doesn't care about which OS thread it's run from.
08:26:47 <merijn> int-e: Worse
08:26:56 <kuribas> int-e: running regexes is not necessarily "quick"
08:26:58 <merijn> int-e: They were marking syscalls unsafe :)
08:27:04 <kuribas> int-e: it depends on the regex
08:27:09 <kuribas> and the matched string
08:27:23 <kuribas> I should benchmark with "unsafe" and with "safe"
08:28:22 <int-e> merijn: gettimeofday may be okay :)
08:29:04 <phadej> bytestring uses `import unsafe "stdring.h memcpy"`
08:29:11 <phadej> and I have no idea whether it's bad or not
08:29:17 <phadej> e.g. can it be safe
08:29:19 <merijn> int-e: Sadly it wasn't :)
08:29:26 <phadej> GHC docs are not conclusive :(
08:29:30 <merijn> phadej: Depends on the size of your bytestrings ;)
08:30:06 <int-e> phadej: The Haskell equivalent would probably be a (slower, presumably) non-allocating loop that can't be interrupted either.
08:30:23 <int-e> (hmm, not quite true anymore)
08:30:24 <merijn> phadej: Anyway, unsafe imports shouldn't affect the actual (type/IO) safety
08:30:32 <sm[m]> ziman: thanks!
08:30:39 <phadej> merijn: they don't?
08:30:52 <merijn> phadej: No, why would they?
08:31:59 <merijn> phadej: unsafe foreign imports are unsafe in the sense that "importing the wrong thing unsafe might cause your Haskell code to hang for unboundedly long times"
08:32:24 <merijn> phadej: Say, you do something stupid like unsafe import C code that blocks on a socket/pipe
08:32:30 <int-e> (AIUI, there's -fno-omit-yields to ensure that even such loops can be interrupted. I don't want to know how much slower the code would become.)
08:32:32 <phadej> yes, I find safe/unsafe are very bad names
08:32:53 <merijn> phadej: Then your code (and thus any Haskell code that needs to do GC) will block until that C function returns
08:32:59 <phadej> but they are from report, so cannot be changed
08:33:15 <int-e> (more importantly, they're heavily used)
08:33:32 <dmwit> Yes, bad. Elsewhere in Haskell, writing "unsafe" means you have a proof obligation. Here writing "safe" means you have a proof obligation.
08:33:45 <merijn> phadej: Note that you can "safe" import C code without IO in the type just fine (implicitly using unsafePerformIO)
08:33:48 <merijn> dmwit: What?
08:33:56 <phadej> merijn: I wasn't talking about that
08:34:04 <merijn> dmwit: The proof obligation is on "unsafe", not "safe"
08:34:07 <ski> yea, they're not giving clear enough a suggestion about what must be checked by the programmer
08:34:15 <phadej> maybe I should just stop, it feels I'm constantly misunderstood
08:34:35 <merijn> phadej: I was just distinguishing that there's two axis of "unsafe" for foreign imports
08:34:52 <phadej> merijn: the proof obligation on "safe" is that it doesn't read from ByteArray Addr or something like that, as it can be moved
08:35:17 <merijn> ah, hmm
08:36:10 <dmwit> merijn: I don't think so. "safe" tells the compiler to wrap the call to the imported function with some stuff that makes it slower, but ensures the runtime is in a good state.
08:36:29 <dmwit> merijn: "unsafe" does not wrap, and so there is a proof obligation on the person writing it that the thing they import has certain nice properties.
08:36:35 <int-e> I'm sure Addr# (or any direct access of the Haskell heap by foreign code) wasn't a consideration when those terms were chosen.
08:36:41 <merijn> dmwit: Right, so the obligation is on you as a programmer that it's fine to "unsafe" import something
08:37:02 <dmwit> Apologies, yes, you are correct.
08:37:22 <merijn> dmwit: So that means it follows the consistent scheme of "if you write unsafe, it's on you"
08:37:42 <dmwit> I forgot my real complaint, which is: other places in Haskell, "unsafe" puts a burden on the user of the thing marked unsafe. In this place, "unsafe" puts a burden on the creator of the thing marked unsafe.
08:37:47 <merijn> Could be a better name still, but at least there's some consistency :)
08:37:49 <phadej> int-e: Optionally, an import declaration can specify, after the calling convention, the safety level that should be used when invoking an external entity. A safe call is less efficient, but guarantees to leave the Haskell system in a state that allows callbacks from the external code. In contrast, an unsafe call, while carrying less overhead, must not trigger a callback into the Haskell system. 
08:38:07 <int-e> But it's an excellent point that under some circumstances, 'safe' is the unsafe choice for a foreign import.
08:38:35 <phadej> https://www.haskell.org/onlinereport/haskell2010/haskellch8.html#x15-1490008
08:38:45 <int-e> phadej: Nobody expected foreign code to access the Haskell heap.
08:38:54 <dmwit> merijn: I still had cached "unsafe means something different than usual here, and I can complain about that" but unwisely guessed at what the unusual thing was. Now I've cached it back in. Apologies for the misinformation.
08:39:00 <int-e> phadej: I'm pretty sure that's true for the whole FFI addendum.
08:39:05 <phadej> int-e: in 2010, don't be ridiculous
08:39:26 <phadej> bytestring is older than that
08:39:30 <int-e> The FFI addendum isn't from 2010.
08:39:41 <merijn> THe FFI addendum predates Haskell98, iirc
08:39:53 <merijn> You know, back before the GHC mono-culture ;)
08:39:55 <phadej> hmm
08:40:06 <int-e> The fact that it's part of the Haskell report itself is what happened in 2010. I bet it was only lightly edited.
08:40:06 <merijn> So addressing special cases of GHC internals was probably not a high priority
08:40:27 <phadej> ok, 2003
08:40:43 <ski> it existed before 2010. i don't recall if it predated H98. my guess would be that it didn't
08:41:40 <phadej> addendum has StablePtr
08:41:57 <phadej> so yes, they were thinking into calling into back somehow
08:42:28 <int-e> That's still very different from direct heap access.
08:42:53 <Cale> ziman: The tricky thing with absolving yourself of that constraint is that you still need *some* way to distinguish at runtime which c you have.
08:44:41 <phadej> int-e: yes, maybe it was thought that these things are just `malloc`d and that's it.
08:46:16 <ziman> Cale: hmmm, i see, good point
08:46:39 <Cale> ziman: Consider trying to write a function of type  forall c. (IsCheck c => r) -> r  -- we need a 'c' to case on to decide what dictionary to pass along, but we don't necessarily have one
08:47:02 <Cale> Or we need *something* which will determine c...
08:47:07 <ziman> yep, you can't have runtime information in an implicit argument in haskell
08:47:18 <dmwit> Cale++ I've had trouble explaining in the past why this isn't possible, and that explanation is quite generally applicable to variants of this problem and very easy to understand.
08:48:22 <dmwit> My best explanation in the past was "well we have type-level undefined", but it's not really very satisfying, because it seems like this problem would exist even without type families.
08:48:26 <Cale> If you had an additional GADT, then perhaps you could case on that
08:48:28 <dmwit> This one is much better.
08:49:25 <dolio> Haskell quantifiers are parametric in all kinds, not just for 'the universe' or something.
08:50:16 <dmwit> Mmm. What does that mean? There's definitely a kind-checker that forbids instantiation of a type variable of one kind with a type of another kind.
08:50:42 <Cale> dmwit: in each kind :)
08:50:56 <dolio> It means that a term with type `forall c. ...` must be implemented uniformly with respect to choice of `c`.
08:51:06 <dolio> And the fact that c :: Bool is irrelevant.
08:51:24 <dmwit> Okay. That I can get behind.
08:52:17 <dmwit> I see. You mean, for each kind, Haskell quantifiers are parametric. I parsed it as claiming that each quantifier was parametric over all kinds at once. My mistake.
08:53:19 <dolio> In dependent type theories you usually have that pi types have a similar property with respect to the universe, because there is no way to do cases on values of the universe. But they don't act that way for other types.
08:56:18 <dolio> Also specifying what it means to be parametric in those types rigorously is kind of under-studied.
08:56:44 <dolio> But there is at least the original intuitive idea behind it.
08:57:34 <ziman> i think this makes it quite clear that i can't get away without passing the information into the function _somehow_, and since my choices are either a class constraint or an explicit argument (is there anything else?), there's not much else i can do
09:03:32 <dmwit> Those are the two basic choices, yep.
09:04:08 <dmwit> There's also implicit parameters. They are almost exactly the same thing as a typeclass, with slightly different syntax and scoping rules.
09:04:10 <ziman> thanks everyone :)
09:04:17 <ziman> oh, right
09:18:50 * hackage uniqueness-periods-vector-general 0.2.3.0 - Generalization of the functionality of the dobutokO-poetry-general-languages package  https://hackage.haskell.org/package/uniqueness-periods-vector-general-0.2.3.0 (OleksandrZhabenko)
09:21:49 <timCF> Hello! I have a question about TH. Can it splice expressions sequentially? Something like macro 1 creating some quoted expression which contains splice expression of macro 2? Here is simple example of possible use case https://github.com/coingaming/signable/blob/c3dd86cfd69a2b3e38bdda6fbae92776026cf1d5/haskell/test/TestOrphan.hs#L24 Here I have to
09:21:50 <timCF> splice macro just in place where in used, but I would like to compose them in different way through simple wrapper which will create this expression instead of writing it by hand
09:24:59 <dmwit> timCF: I don't think so. But, like... the one chunk of TH can just call the other, no?
09:26:29 <dmwit> like $(mkSignable (mkProxy "" ""))
09:27:54 <dmwit> Possibly $(mkProxy "" "" >>= mkSignable), idk. I haven't used TH much so the types of things aren't top of mind.
09:28:03 <timCF> Will it work? In this particular example `mkProxy` splices into tuple which includes `Proxy a` - some type-level information which `mkSignable` accepts as an argument https://github.com/coingaming/signable/blob/c3dd86cfd69a2b3e38bdda6fbae92776026cf1d5/haskell/src/Data/Signable/TH.hs#L21
09:29:04 <timCF> It feels like compiler needs to do additional pass to dynamically create typed term
09:29:14 <dmwit> I don't know if it will work as-is. But it looks like you have control of the TH, so it should be possible to put them together.
09:30:00 <dmwit> Yes, you will probably need to concatenate the two chunks of declarations that get produced by the two calls.
09:30:09 <dmwit> I forgot about that. But it shouldn't need two compiler passes.
09:32:15 <dmwit> Are you using mkProxy elsewhere?
09:32:17 <timCF> hmm, not sure how it can work, because `mkProxy` real output is `Q Exp`, not `(String, String, Proxy a)` which `mkSignable` wants as input. Seems like compiler needs to compile this `Q Exp` to transform it into needed typed term
09:33:43 <timCF> No, not really. In this particular case it's not big issue to splice just in place like in example, but if I want to parse big file and create `Signable` instances automatically for N amount of types, then it's issue
09:35:50 <timCF> Or maybe I'm doing something completely wrong from the beginning (using TH for automated class derivation hahah)
09:37:43 <dmwit> Looks like the only thing you're using the Proxy a for is class resolution of Message, right?
09:38:09 <dmwit> If so, I'm pretty sure TH has a way to do class resolution.
09:38:21 <dmwit> mmm
09:38:56 <dmwit> Well, maybe. I guess this is doing class resolution using the classes available in the TH-defining module, not using the classes available in the TH-using module.
09:39:01 <timCF> Yes, it's protobuf message reflection API
09:39:19 * hackage phonetic-languages-ukrainian 0.2.0.0 - Prepares Ukrainian text to be used as a phonetic language text  https://hackage.haskell.org/package/phonetic-languages-ukrainian-0.2.0.0 (OleksandrZhabenko)
09:39:36 <monochrom> I could be wrong for the 2nd time, but TH doesn't let you see expressions written by someone else.
09:40:12 <dmwit> Okay. I think I've determined that I'm not expert enough to help.
09:40:58 <timCF> thanks!
09:43:28 <dmwit> Okay, new proposal: x = $(mkProxy "" ""); $(mkSignable x)
09:43:32 <monochrom> Haha close call. I'm right this time. "At present, this value is always Nothing: returning the RHS has not yet been implemented because of lack of interest."
09:50:33 <timCF> dmwit it's equivalent to already used `$(mkSignable $(mkProxy "Proto.Basic" "UMoney"))` it will work, but it have the same problems - it don't scale, can't be automated this way for derivation of 1000 types
09:52:47 <timCF> Basically if I could escape `$()` expression in TH, something like `$$()` to say - splice it not to actual code, but to TH code which will be spliced later
09:53:08 <timCF> Then probably it can be solved
10:19:49 * hackage uniqueness-periods-vector-examples 0.1.0.0 - Examples of usage for the uniqueness-periods-vector series of packages  https://hackage.haskell.org/package/uniqueness-periods-vector-examples-0.1.0.0 (OleksandrZhabenko)
10:25:49 * hackage quickcheck-classes-base 0.6.1.0 - QuickCheck common typeclasses from `base`  https://hackage.haskell.org/package/quickcheck-classes-base-0.6.1.0 (andrewthad)
10:46:50 * hackage data-validation 0.1.0.2 - A library for creating type safe validations.  https://hackage.haskell.org/package/data-validation-0.1.0.2 (DevinLyons)
11:05:25 <electricityZZZZ> merijn: are you around?
11:18:58 <merijn> electricityZZZZ: For some definitions of around :p
11:46:30 <giaco> hello! I'm installing haskell for the first time, as I want to use it as my playground to learn functional programming. I just want to say hello, and that my apt get in ubuntu resulted in an oddly satisfying "After this operation, 1,000 MB of additional disk space will be used."
11:48:05 <tomjaguarpaw> That's a very round number. Welcome to Haskell! I hope you enjoy it.
11:49:46 <maerwald> giaco: which ghc version?
11:54:22 <maerwald> also, my ghc takes 2GB, so sounds right
11:57:42 <giaco> maerwald: version 8.6.5
11:58:48 <giaco> I've read on the official webside the versions tend to lag behind and that there's an official repository for debian based distro, but I yet have to find out if I really need it now at my infant stage
11:59:28 <maerwald> giaco: for ubuntu there is https://launchpad.net/~hvr/+archive/ubuntu/ghc and https://www.haskell.org/ghcup/
12:00:15 <MarcelineVQ> I use ghcup to keep my ghc and cabal reasonably recent without my system package manager having a chance to gump up anything
12:01:49 <geekosaur> enh. 8.6.x is good enough except on windows where it has some code gen issues iirc
12:02:22 <geekosaur> unless you're hanging out at the bleeding edge but a haskell newcomer won't be
12:03:39 <giaco> let's go for it. "After this operation, 1,000 MB disk space will be freed."
12:04:09 <monochrom> In exchange for using even more disk space for a newer version? :)
12:04:31 <monochrom> "1000MB can be saved by using 2000MB" or something.
12:05:04 <geekosaur> it'll be more complete, I don't think installing the ghc package includes the full bootlibs, various utilities, etc.
12:05:08 <monochrom> Yeah 8.8.4 looks like 2GB
12:05:45 <monochrom> Actually 8.6.5 looks like 1.7G, so ubuntu's package was not including something.
12:06:19 <monochrom> True, fewer surprises down the road when talking on #haskell.
12:07:43 <monochrom> Probably the built-for-profiling versions of libraries.
12:08:10 <hyperisco> every time someone downloads ghc for the first time, an angel gets its wings
12:10:36 <isovector1> can i use SYB to find the immediate parent of something that would have been targeted by a query?
12:10:55 <isovector1> without knowing what that parent might look like
12:12:08 <giaco> lot of versions in ppa:hvr/ghc repo. Should I pick manually the last one listed (ghc-8.8.4) or is there any lts or last version package?
12:17:43 <yushyin> 8.8.4 is fine
12:18:17 <geekosaur> there's no "latest" because people often install multiple versions
12:18:24 <geekosaur> for CI, etc.
12:18:32 <giaco> thanks
12:20:03 <giaco> 86.7MB compressed, 1,004 MB. What is haskell made with, aerogel?
12:20:09 <giaco> *uncompressed
12:21:23 <dolio> Text, probably.
12:22:19 <monochrom> 200MB compressed I got.
12:28:36 <giaco> confused by cabal-install packages in ppa:hvr/ghc. cabal-install-head is 3.3, but there's also cabal-install-3.4 from same repository. Manual also suggests to upgrade cabal in palce with "cabal install Cabal cabal-install"
12:31:07 <c_wraith> you probably should be using ghcup instead of that ppa these days
12:32:01 <giaco> "apt search ghcup" returns nothing
12:32:10 <zeta_0> geekosaur: hello there, i wonder if you could help me with an xmonad issue that i'm having, i can go to the #xmonad channel if you want to chat there ?
12:32:23 <geekosaur> preferred, yes
12:32:51 <zeta_0> geekosaur: thanks, i'll go to #xmonad now, one second !
12:32:53 <giaco> c_wraith: wait, my fault, I misread it
12:33:47 <maerwald> giaco: soo the link I posted above
12:34:04 <maerwald> giaco: https://www.haskell.org/ghcup/
12:38:40 <giaco> maerwald: yes, but I prefer ppa. Btw I've removed ppa and testing ghcup now. Surprisingly, it is downloading "downloading: https://downloads.haskell.org/~ghc/8.8.4/ghc-8.8.4-x86_64-fedora27-linux.tar.xz" on my ubuntu machine
12:39:46 <geekosaur> the 'fedora' part actually has more to do with the abi, there's no separate binary for debian because it's not needed
12:40:33 <maerwald> giaco: yes, you can also install 8.10.2 afterwards
12:41:16 <giaco> good to know. Btw ghc 8.8.4 successfulyl installed with ghcup. Thanks for all the hints
12:54:39 <dumptruckman> So... I'm going to attempt to give a talk tomorrow to my coworkers about why Haskell's type signatures can help reason through a problem (in any language but in particular Java since that's mostly what we use). Being that I'm fairly inexperienced with Haskell, does anyone have any advice?
12:55:28 <dumptruckman> I'm thinking that this probably only applies to FP related problems but maybe someone has some evidence otherwise?
12:56:07 <monochrom> https://www.rea-group.com/blog/the-abject-failure-of-weak-typing/
12:56:57 <dumptruckman> Nice, thanks
13:01:05 <dumptruckman> Ahh, what a great take: "Types are a powerful tool for clarifying thoughts, and designing correct software, arguably far more so than popular test-driven methodologies."
13:02:37 <maerwald> I'm starting to actually disagree that types are what makes me clarify my thoughts. It's data. That's not terribly the same as types.
13:03:11 <maerwald> Data I can write down on a paper. Whether those will become strong haskell types in the end or not... idc.
13:03:49 <maerwald> Types are more about sleeping well at night
13:04:57 <monochrom> "data type" is the reconcilation that says that you are not disagreeing, you are violently agreeing.
13:05:03 <hyperisco> is there actual studies to point to to substantiate claims about type systems?
13:05:12 <maerwald> (data can be expressed in many ways, including just functions, SQL tables or something entirely differen)
13:05:40 <zacts> hello
13:05:42 <maerwald> monochrom: no, because if it ends up as a *data type* isn't relevant and it may in fact not
13:05:47 <hyperisco> I remember in Peopleware (iirc) that automatic memory management was shown to increase productivity by about 10%
13:06:59 <niez> maerwald, have you looked at TLA+? it's untyped, but quite powerful
13:07:25 <monochrom> OK, as long as you agree that your data is better not simply "string" or "natural number", you are in agreement.
13:07:29 <hyperisco> a study that shows there are actually less bugs would be helpful
13:07:38 <zacts> what is the difference between haskell and say racket?
13:07:41 <zacts> is it the type system?
13:07:48 <maerwald> monochrom: even structural typing like in TypeScript is a little different from our understanding of *data type*, but it allows me perfectly fine to define data and structures
13:08:33 <hyperisco> once you have all this data though how do you compute
13:08:40 <maerwald> monochrom: and the data may just be on "paper" as an idea, but never have a corresponding type in the implementation. That's also fine
13:10:24 <maerwald> data is more universal than types
13:10:34 <hyperisco> are you saying your thinking is like, I have a list like  [(a,x),(b,y),(c,z)]  and I want a list like  [a,b,c]  so how do I get there?
13:11:06 <maerwald> in the same way as you can express the same data in X different types
13:11:15 <maerwald> or none at all
13:12:46 <zincy_> What was it Cale once said, the types are there whether you think about them or not?
13:12:46 <maerwald> a parser is a description of data... even if it produces the same output as the input (e.g. string in, string out), there's no data type
13:13:26 <hyperisco> what is "data"
13:14:08 <hyperisco> it sounds like you'd say a function is data, maybe because you can list the IO pairs
13:15:22 <monochrom> I am the dual of you. When the language doesn't let me express my types, I still express my types on paper.
13:15:32 <zincy_> Is the cosine function data?
13:16:28 <dumptruckman> zincy_: that's my take as well.
13:16:37 <maerwald> zincy_: you could say so
13:16:41 <dumptruckman> I don't really think you can reason about typeless data
13:16:47 <dumptruckman> your data has a type whether you like it or not
13:16:49 <zincy_> Maybe if the cardinality of inputs and outputs is countably infinite :P
13:17:01 <maerwald> dumptruckman: no, it can have a bazillion types
13:17:12 <maerwald> that's what type algebra tells us
13:17:17 <zincy_> If not then given an infinite amount of time we couldn't write the lookup table
13:17:31 <maerwald> that means there's something more general about data
13:17:37 <maerwald> it's more abstract
13:18:03 <dumptruckman> but when do you think about "just data" without any intent to do _anything_ with it
13:18:20 <maerwald> when you try to understand business logic
13:18:24 <hyperisco> maerwald, am I on your ignore list?
13:18:29 <dumptruckman> once you intend to do something with it, your options are limited by the type of the data
13:18:31 <maerwald> hyperisco: I don't have one
13:18:50 <hyperisco> okay just being ghosted then :P np
13:18:55 <zincy_> What about Chaitin's constant is that data. Are uncomputable numbers data?
13:19:05 <maerwald> hyperisco: I'm in deep philosophical statis. I'm still thinking about your question
13:19:39 <zincy_> Chaitins constant represents the probability that a randomly constructed program will halt. So we can provably never know what it's actual value is..
13:19:44 <maerwald> isn't it the same problem with Plato and what is an "idea"?
13:20:03 <zincy_> We are a practical bunch aren't we
13:20:58 <maerwald> hyperisco: structure -> data -> type
13:21:07 <hyperisco> well if your concept of data is so broad as to encompass all that exists, I guess we can talk about Plato here
13:21:17 <maerwald> one structure can have many data, data can have many type representations
13:21:50 <MarcelineVQ> data is a crazy hamburger
13:22:00 <niez> maerwald, if you replace 'data' with 'information', then it makes sense
13:22:06 <hyperisco> so your ontology starts at structures
13:22:12 <maerwald> I think so
13:23:05 <maerwald> Maybe, because that's the sharpest concept in my mind. Types aren't.
13:23:22 <maerwald> I feel they're more fluid
13:23:31 <maerwald> less sharp, if that makes sense
13:23:57 <zincy_> If data is the same thing as information, then that is incredibly general.
13:24:27 <maerwald> zincy_: I think Information stands above structure and is really too general
13:24:45 <maerwald> data is something that can be grouped by structure
13:25:29 <hyperisco> how does a structure differ from a type?
13:25:49 <dumptruckman> That's what I want to know too
13:26:04 <maerwald> hyperisco: it may not, but it also may
13:26:06 <zincy_> Right so imagine the universe is a program. pi and e are just constants. Where do those inputs constants fit in your ontology?
13:26:56 <maerwald> zincy_: you lost me at "the universe is a program" :p
13:27:13 <maerwald> I'll respond to that in a few weeks, maybe
13:28:16 <hyperisco> in a practical sense, I don't think exclusively in a particular type system, or even in a collection of type systems… I don't think anyone does
13:28:19 <niez> maerwald, can you give an example of data that can have many types?
13:29:22 <niez> maerwald, or, more precisely, that can be implemented with many types?
13:31:15 <hyperisco> nominal typing affords that trivially
13:31:26 <maerwald> niez: Bool
13:32:20 <niez> ok, it looks like i've missed couple levels of abstraction here
13:32:23 <maerwald> can be expressed by anything that has cardinality 2
13:32:39 <hyperisco> you can be reductionist and say there are finite types (Fin) and infinite types (Nat)
13:33:02 <niez> isn't that just monomorphic types?
13:33:17 <maerwald> You could say that cardinality maybe is a way of talking about structure
13:33:31 <zincy_> hyperisco: Does infinite types include uncountable infinities?
13:33:32 <maerwald> very loosely
13:33:35 <monochrom> Clearly, everyone already pays ample attention to data. If you don't process data, aren't even programming. People won't talk about "do you have data or not?" because the answer is everyone already does.
13:33:50 <hyperisco> zincy_, not in a type theory I am familiar with but maybe :)
13:33:59 <zincy_> :)
13:34:10 <monochrom> But some people don't have types. So people talk about "do you have types or not? what system of types?"
13:34:40 <dumptruckman> To me everything fundamentally
13:34:47 <dumptruckman> Wow, enter too soon
13:35:11 <dumptruckman> Types are fundamental to thinking. What is a thing that is not a thing?
13:35:26 <dumptruckman> Philosophically, nothing is a thing
13:35:53 <hyperisco> everything can be itself
13:36:00 <zincy_> cothing
13:36:04 <maerwald> dumptruckman: I don't think about types when I think on how to solve a problem
13:36:09 <hyperisco> if that counts, then it seems vacuous to say
13:36:22 <hyperisco> unless we have some law of identity deniers
13:36:27 <maerwald> It's more that... when I have a clear picture about what I want to do, I think about how to represent that in types
13:36:42 <maerwald> and if I'm lazy, I might use Strings and Ints
13:37:17 <dumptruckman> I don't know that we must include "everything is itself"
13:37:28 <hyperisco> well, that's singletons library :P
13:37:53 <dumptruckman> I think it is more that the "is a" relationship gives the fundamental notion of types
13:37:58 <niez> dumptruckman, yeah, like: everything in this universe is or isn't a cucumber
13:38:09 <maerwald> niez: that's deep
13:38:17 <dumptruckman> :D
13:38:30 <maerwald> the universal cucumber theorem
13:38:48 <dolio> There are semantic models based on partial equivalence relations which are not reflextive.
13:38:48 <hyperisco> I feel uncomfortable with that assertion
13:39:09 <dolio> So those obviously don't model the "law of identity" thing that people like to go on about.
13:40:04 <hyperisco> I asked about this a few days ago on -offtopic… which models?
13:40:07 <dumptruckman> I think I understand you now maerwald. I guess I'm not trying to say otherwise. Just that when you already have that idea it will be expressed with types
13:40:31 <maerwald> dumptruckman: yes, this might be a trivial distinction, but I think it's an important one
13:40:36 <dolio> The effective topos is (in one sense) based on partial equivalence relations on (something like) Turing machines.
13:40:55 <hyperisco> well, I was particularly looking for an irreflexive theory
13:41:09 <dumptruckman> I think understanding the types involve help to solidify the idea
13:41:20 <hyperisco> merely so I could slyly proclaim "nothing is as it seems"
13:42:12 <maerwald> dumptruckman: let's say... there might be X types, that will let your mind identify the same concept. And you will have the same intuition for all of them.
13:42:26 <hyperisco> dumptruckman, when you say it is fundamental to thinking, my retort was to point out there is a trivial typing of things whereby each thing is a unique inhabitant of its own type
13:43:00 <maerwald> dumptruckman: But in the end, you don't use Bool for every "switch" type in your program
13:43:33 <Guest35> Hey! I'm female 23 and I'm so horny right now. Wanna trade pics with cute man. Add me here >> http://NUDY.FUN << :
13:43:39 --- mode: ChanServ set +o monochrom
13:43:41 <dolio> Well, PERs aren't irreflextive.
13:43:43 <hyperisco> dumptruckman, and if you come back to say different type theories have different utility in thinking, then I'll say then that the type theory doesn't seem to be fundamental then… rather it is the selection of type theory :P
13:43:43 --- mode: monochrom set +b *!*@gateway/web/cgi-irc/kiwiirc.com/ip.91.217.246.19
13:43:43 --- kick: Guest35 was kicked by monochrom (Guest35)
13:43:55 <dolio> Except the empty one, I guess.
13:45:31 <zeta_0> could you guys take a look, i'm not sure what's wrong with this haskell code: https://dpaste.org/O7SF
13:46:10 <monochrom> Do people in #xmonad know?
13:46:25 <hyperisco> zeta_0, please include any error messages as well as what you're expecting vs what you're getting
13:46:33 <maerwald> this seems like a configuration problem, not a haskell problem :p
13:48:49 <monochrom> In my ideal world, every programmer, nay, every computer user, must first pass an exam that is surviving being a tech support worker behind phone-in tech support.
13:49:12 <zeta_0> ok, here's the error message: https://dpaste.org/tObV
13:49:16 <monochrom> People must know how it is like to be on the receiving end of "it just doesn't work, I won't tell you particulars".
13:49:36 <niez> dumptruckman, it's tricky to build an ontologu based purely on types, for example a cow, if you kill it, is it still a cow? if you cut a head, is it sill a cow? if you continue cutting and produce a steak is it a cow? very tricky
13:49:51 <zeta_0> to bad geekasaur left !
13:49:54 <maerwald> monochrom: I'd like you to stop thinking in exams. Think in responsibilities. It's much worse.
13:49:56 <hyperisco> zeta_0, you need to close the list that starts on line 15
13:50:36 <maerwald> and a far better teacher than exams
13:50:59 <monochrom> OK, can you convert my exam into a responsibility?
13:52:01 <monochrom> Oh, perhaps this is a simple syntax error.
13:52:20 <maerwald> monochrom: give the guy commit access to xmonad and say they're the last hope on earth to maintain this project.
13:52:26 <zeta_0> and apologies i haven't had the chance to get ghcide up and running yet with my xmonad.hs config, that would really help !
13:53:27 <maerwald> monochrom: but everything is readily available... only fools really write software from scratch anymore
13:53:31 <monochrom> zeta_0: It looks like you start a list around line 15, the open [, and then... where is the corresponding close ] ?
13:54:21 <monochrom> But hyperisco already said it.
13:54:22 <maerwald> monochrom: so... make it a project, not an exam and make sure one group will be using that project for the rest of the next semester
13:54:38 <hyperisco> it is that SO practice so I get all the points
13:54:50 <maerwald> the other group will get a lot of support requests
13:56:44 <zeta_0> ok i fixed it, time for another rebuild try: https://dpaste.org/X8oJ
13:56:56 <maerwald> and I don't think you'll need any incentive... giving support for your own work is something programmers cannot get away from
13:57:22 <maerwald> because of emotional attachment... it's easier to facilitate than fear (exams)
13:57:37 <monochrom> Now you're talking about your ideal world, in terms of "programmers cannot get away from".
13:57:46 <monochrom> Programmers always find ways to get away from things.
13:58:09 <monochrom> even s/ways/rationalizations/
13:58:37 <sm[m]> zeta_0: it's no good pasting just the code, include the error message with it. https://paste.tomsmeding.com is nice, you can attach both at once
13:58:52 <monochrom> Even on github, authors deal out "wontfix" to issue reports fairly often.
13:59:01 <monochrom> Even you have seen a few, IIRC.
13:59:35 <hyperisco> I learned that github projects are actually political parties
13:59:39 <monochrom> In an ideal world, we shouldn't need exams in the first place, so you're right in the context of ideal world.
14:00:17 <monochrom> I am cynical, it's why my ideal world still has exams. Strange I know.
14:00:43 <maerwald> If you can't rule without fear, better not rule at all.
14:01:14 <maerwald> I'm maybe more cynical and would kick out all students that need exams :)
14:01:16 <monochrom> But no, my exams are not about ruling with fear.
14:01:17 <hyperisco> the issuance of "wontfix" is sometimes "compromised as intended"
14:01:50 <monochrom> My ideal has two different kinds of exams. But neither is for fear.
14:03:08 <maerwald> hyperisco: reminds me of the i3 author neglecting memory-usage feature in i3bar, because there's no way on linux to *precisely* get the actual free memory.
14:03:21 <monochrom> One kind has my tech support exam as an example. It is not fearsome because candidates will pass easily, even tautologically. The purpose is just to have you have experienced being receiving end of something. Then you're good to go.
14:03:25 <maerwald> Tickets were closed as won'tfix and "buy more ram" :D
14:03:56 <monochrom> The other kind is just for perks and bonuses. Nothing wrong if you don't pass, or don't even care to take, this other kind of exams.
14:04:41 <zeta_0> ok, it threw another error: https://dpaste.org/7AD5 https://dpaste.org/mVXc
14:04:56 <maerwald> everyone can pass exams... few can pass a non-group project of reasonable size
14:05:31 <zeta_0> and is className supposed to be `VirtualBox` or `Virtualbox` ? i'm guessing the 1st one.
14:05:59 <monochrom> "Variable not in scope: fullscreeenStartup :: X ()"  I would pay attention to that.
14:07:13 <zeta_0> monochrom: maybe i'm missing an import or something.
14:10:05 <dumptruckman> hyperisco: unique inhabitant of its type is also inhabitant of other types. Even if it were only the one type (which I think is not possible) you could still do something with it because you know it is that type.
14:11:03 <dumptruckman> niez: it sounds to me like you've applied a function to the thing of type cow and it has become another type
14:11:04 <zeta_0> i'm looking through the documentation now to see where i messed up: https://hackage.haskell.org/package/xmonad-contrib-0.16/docs/XMonad-Hooks-EwmhDesktops.html
14:11:43 <dumptruckman> Become a thing of another type*
14:11:55 <dumptruckman> Say, headless cow
14:12:44 <dumptruckman> I feel like you're trying to apply the Theseus's ship argument to the wrong situation, maybe
14:13:18 <zeta_0> any tips on how to fix this? https://dpaste.org/yzKq
14:13:25 <monochrom> I don't understand how the unique inhabitant, or any inhabitant, of a type is also an inhabitant of other types, unless you have subtyping or union typing.
14:14:02 <dolio> Right, there are theories where that doesn't make any sense.
14:14:08 <dolio> And theories where it does.
14:14:31 <monochrom> I don't use xmonad, so I don't know wth is fullscreenStartup and how to obtain it or write it myself.
14:15:02 <monochrom> If this began as someone else's code that you copied from, well then only the author knows.
14:16:00 <maerwald> that's why code as configuration doesn't work well
14:16:20 <zeta_0> monochrom: geekosaur was helping me add some extra stuff to my xmonad.hs config, so that virtualbox will work in xmonad, but he left irc.
14:16:27 <dumptruckman> Again, I am thinking of types in the sense of the "is a" relationship
14:16:30 <maerwald> zeta_0: I suggest to switch to i3
14:16:33 <sm[m]> damn that geekosaur 
14:17:00 <dumptruckman> An apple is an apple and is a fruit and is a good, etc
14:17:02 <monochrom> On composite number days I agree with that sentiment about programmable config files being more trouble than worth.
14:17:10 <sm[m]> you probably need to remove an e from "fullscreeenStartup"
14:17:14 <dumptruckman> Food*
14:17:25 <zeta_0> i left a message in #xmonad, hopefull someone responds.
14:17:35 <monochrom> On prime number days I disagree a bit, on the ground of "compared to what?".
14:17:51 <monochrom> Like, do you really have a viable alternative? For xmonad?
14:18:19 <dumptruckman> If your definition of type does line up with that then yeah, I guess maybe we're talking about different type systems
14:18:29 <giaco> niez: if everything is the universe is or isn't a cucumber, what's this? https://en.wikipedia.org/wiki/Bohadschia_argus
14:18:44 <monochrom> For "is-a" relationships, set theory is a much better way.
14:18:44 <zeta_0> maerwald: my xmonad.hs config works fine, it's just i hit an edge case where it does not work well with xmonad, so that's why i'm trying to get this code working.
14:19:08 <zeta_0> typo, does not work well with virtualbox.
14:19:17 <sm[m]> you probably need to remove an e from "fullscreeenStartup"
14:19:34 <monochrom> Oh haha is that it?
14:20:23 <zeta_0> sm[m]: thanks, i did not even notice that !
14:20:55 <dumptruckman> I guess set theory makes sense. Is there some other type system used in programming that does not adhere to set theory?
14:21:15 <monochrom> Every type system stays away from set theory, no?
14:21:39 <dolio> There isn't even one set theory.
14:22:01 <sm[m]> zeta_0: we all fall for those sometimes, the general tip for next time is: always read (the important part of) the error message very carefully and try to understand the reason for it
14:22:11 <dolio> There are set theories where it makes no sense for a thing to be elements of multiple sets.
14:22:11 <dumptruckman> Then I probably don't know nearly enough about set theory to make any assertions about it
14:22:20 <dolio> And set theories where it does.
14:22:21 <dumptruckman> I see
14:25:30 <zeta_0> sm[m]: ok, i did another rebuild, but i'm still getting that same variable not in scope error.
14:25:57 <giaco> I'm reading learnyouhaskell.com. It says that lists are compared in lexicographical order, but how that [3,4,2] > [3,4] returns True?
14:26:25 <monochrom> Lexicographical. Exactly that.
14:26:40 <monochrom> As another example that you easily accept, "mono" > "mon"
14:27:47 <monochrom> lexicographical order = alphabetical order but with another element type rather than letters
14:28:28 <zeta_0> what does it mean by: `Variable not in scope: fullscreenStartup :: X ()` ?
14:29:05 <monochrom> fullscreenStartup is not defined or imported or introduced properly some way or ...
14:29:12 <zeta_0> in: `, startupHook = setWMName "LG3D" >> fullscreenStartup`
14:30:11 <zeta_0> monochrom: ok, i'll double check the imports !
14:30:52 <giaco> monochrom: thanks for the answer, but 2 is compared to what, exactly?
14:31:22 <monochrom> OK, I'll use a better example. "abcd" > "abc".  d is compared to what?
14:31:36 <sm[m]> @where paste, zeta_0
14:31:36 <lambdabot> I know nothing about paste,.
14:31:44 <sm[m]> @where paste 
14:31:44 <lambdabot> please paste full code, input, and output at https://paste.tomsmeding.com
14:31:48 <monochrom> Or is it the whole point, d doesn't have any counterpart to compare to, therefore it wins?
14:32:25 <monochrom> "If you can sort alphabetically, you can sort lexicographically"
14:32:48 <zeta_0> sm[m]: i already pastebinned earlier but i can pastebin again.
14:33:11 <sm[m]> do, it's too confusing otherwise
14:33:53 <sm[m]> it may seem repetitive to you but it helps reduce work for folks to help you
14:34:32 <sm[m]> we'll answer based on an old paste and find you've moved on to a new error, etc.
14:34:36 <zeta_0> fullscreenEvent is not including in ewmh, so i need to find the correct module to import, dammit: https://hackage.haskell.org/package/xmonad-contrib-0.16/docs/XMonad-Hooks-EwmhDesktops.html
14:34:55 <zeta_0> that's why the function is not being detected.
14:35:23 <sm[m]> hoogle is a good place to find those: https://hoogle.haskell.org/?hoogle=fullscreenEvent&scope=set%3Astackage
14:36:54 <zeta_0> sm[m]: thanks, i'll pastebin again in a bit, one second ! 
14:37:54 <zeta_0> https://dpaste.org/mSnD https://dpaste.org/cGbf
14:37:57 <zeta_0> sm[m]: ^
14:38:28 <zeta_0> i think that i'm missing this module: `xmonad-contrib XMonad.Layout.Fullscreen`
14:38:34 <sm[m]> again with the triple e :)
14:38:43 <giaco> exactly, when lexicographical comparison ends in a tie but one list still have elements, it compares lengths instead (from what I'm experimenting)
14:38:45 <sm[m]> did you show the right paste ?
14:39:22 --- mode: monochrom set -o monochrom
14:40:00 <monochrom> "Did you save?"
14:40:58 <zeta_0> https://dpaste.org/AqXx https://dpaste.org/20ME
14:46:44 <zeta_0> its throwing another dam error: https://dpaste.org/EMyT https://dpaste.org/gT7K
14:47:03 <zeta_0> sm[m] monochrom ^
14:48:10 <sm[m]> zeta_0: as you can see, hoogle show no hits for fullscreenStartup meaning it's not in current packages. It might be in an older version of xmonad-contrib - google search for "fullscreenStartup xmonad" hints at this - but I don't see it
14:48:45 <monochrom> Why is nix cutting out part of the error message?!
14:48:58 <sm[m]> zeta_0: so it looks like you added import XMonad.Layout.Fullscreen and that fixed the fullscreenStartup error ?
14:49:38 <sm[m]> now we need to know what version of xmonad-contrib you're using, I think
14:49:39 <monochrom> This is an ambiguity error because the two modules cited both export "fullscreenEventHook" and the compiler has reasons to believe that they are different and it can't tell which one you want.
14:49:46 <zeta_0> sm[m]: nope that did not fix the error.
14:50:17 <sm[m]> zeta_0: from your pastes, it caused the error to change, which usually means it fixed the first error
14:50:36 <sm[m]> which is usually a sign of progress
14:52:59 <zeta_0> now it rebuilds without any error, what the hell: https://dpaste.org/wzpt
14:56:27 <zeta_0> now when i rebuild again the same error gets thrown again, that's never happened before, how strange !
14:56:53 <zeta_0> monochrom: i think this import fixes the amiguity though: https://dpaste.org/WMRp
14:59:28 <zeta_0> https://dpaste.org/nWjq
14:59:52 <sm[m]> zeta_0: I found fullscreenStartup in xmonad-contrib master: https://github.com/xmonad/xmonad-contrib/blob/master/XMonad/Hooks/EwmhDesktops.hs#L26 . It's not in the latest release, xmonad-contrib-0.16. That's why I asked what xmonad-contrib version you're using
15:01:10 <sm[m]> you asked for tips, here's another: when troubleshooting missing names, make all of your imports explicit, it will help narrow it down
15:01:47 <zeta_0> sm[m]: oh, i see, i guess i'm going to have to upgrade xmonad, time to go ask the people in #nixos for help.
15:02:13 <zeta_0> sm[m]: geekosaur told something similar earlier, but i forgot !
15:02:59 <sm[m]> it's definitely more of an #xmonad topic. But I hope you got some general troubleshooting tips
15:04:15 <zeta_0> sm[m]: thanks for the tips, and no one in #xmonad has responded, note: i have xmonad installed with nix, so i need to upgrade it with nix !
15:04:46 <sm[m]> perhaps
15:05:22 <zeta_0> i'll be back in this channel in a bit, one second !
15:05:47 * sm[m] to lunch.. good luck
15:06:17 <zeta_0> sm[m]: sounds good, thanks again for the help !
15:11:02 <giaco> is x**y always equal to x^^y ?
15:11:50 <monochrom> I think it depends on why you ask.
15:12:44 <dolio> Can those both be well typed?
15:13:49 * hackage exotic-list-monads 1.0.0 - Non-standard monads on lists and non-empty lists  https://hackage.haskell.org/package/exotic-list-monads-1.0.0 (maciejpirog)
15:13:55 <dolio> I suppose it is possible, but not for the usual types.
15:14:01 <cheater> i typed them in ... i did it well
15:14:20 <ski> (replace the first `y' by `fromIntegral y' ?)
15:18:42 <dolio> I wouldn't be surprised if there's some examples with Doubles where they don't agree.
15:19:37 <koala_man> > 0.1^^4 == 0.1**4
15:19:39 <lambdabot>  False
15:20:28 <dolio> Wow, I didn't think it'd be that easy.
15:23:15 <ski> floating-points are inexact ..
15:28:36 <davean> not quite true, floating point calculations are exactly specified, they're just not all possible numbers or matching with base 10 representations
15:29:53 <dolio> Yes, but that's only part of this example.
15:30:37 <dolio> The other part is that (^^) uses multiple operations that round in between them, whereas (**) is probably directly computed.
15:31:22 <dolio> I guess maybe the 'all possible numbers' covers that.
16:07:30 <zeta_0> sm[m]: you here now ?
16:11:16 * ski blinks
16:48:00 <zeta_0> ok i finish upgrading xmonad to the latest git revision, now back to fixing my xmonad.hs config.
16:48:09 <zeta_0> sm[m]: ^
16:48:51 <zeta_0> sm[m]: are you still here ?
16:50:01 <sm[m]> what's up zeta_0 
16:54:41 <zeta_0> sm[m]: now that i've finally upgraded xmonad to the latest git revision, i'm ready to start fixing my xmonad.hs config again, i'm still getting damn errors !
16:55:09 <infinisil> > property (\x y -> x ^^ y == x ** y)
16:55:11 <lambdabot>  error:
16:55:12 <lambdabot>      Variable not in scope: property :: (a0 -> a0 -> Bool) -> t
16:57:12 <zeta_0> infinisil: was that meant for me ?
16:57:28 <infinisil> No
16:58:07 <zeta_0> infinisil: oh my bad, i got a similar error to that earlier in my xmonad.hs config.
16:58:38 <zeta_0> sm[m]: anyways, i'll be in #xmonad, if you'd like to help me, thanks !
16:59:01 <Axman6> @check \x y -> x ^^ y == x ** (fromIntegral y)
16:59:04 <lambdabot>  *** Failed! Falsifiable (after 10 tests and 10 shrinks):
16:59:04 <lambdabot>  6.8698324593667115 -9
16:59:28 <ski> @check \x n -> (x ** fromIntegral n - x ^^ n) < 1
16:59:30 <lambdabot>  *** Failed! Falsifiable (after 19 tests and 2 shrinks):
16:59:31 <lambdabot>  -9.581534216123083 18
17:00:12 <infinisil> Ah @check, nice
17:00:49 <ski> @help check
17:00:50 <lambdabot> check <expr>
17:00:50 <lambdabot> You have QuickCheck and 3 seconds. Prove something.
17:01:02 <ski> should probably say "Falsify something." ?
17:01:45 <Axman6> @check these definitely not fraudulant documents
17:01:48 <lambdabot>  error:
17:01:48 <lambdabot>  Variable not in scope: these :: t0 -> (Bool -> Bool) -> t1 -> t2 -> prop0err...
17:05:44 <infinisil> @check \n -> n ^ 17 + 9 == (n + 1) ^ 17 + 9
17:05:46 <lambdabot>  *** Failed! Falsifiable (after 1 test):
17:05:46 <lambdabot>  0
17:06:27 <infinisil> @check \n -> gcd (n ^ 17 + 9) ((n + 1) ^ 17 + 9) == 1
17:06:29 <lambdabot>  +++ OK, passed 100 tests.
17:07:43 <Axman6> is the + 9 needed?
17:10:13 <infinisil> Note that this equality is actually false, but the first n it fails for has 51 digits :)
17:10:53 <infinisil> For more info: https://www.youtube.com/watch?v=L4ArlAfKTLA
17:11:37 <infinisil> (I usually don't like linking to videos, but that one's really good and short)
17:22:43 <Axman6> > let n = 8424432925592889329288197322308900672459420460792433 in gcd (n^17+9) ((n+1)^17 + 9)
17:22:45 <lambdabot>  8936582237915716659950962253358945635793453256935559
17:23:24 <Axman6> I actually watched that video the other day, pretty mindblowing
17:24:57 <Axman6> "You are looking for a prime (p) such that n^17 = -9 (mod p) and (n + 1) ^ 17 = -9 (mod p).  So p - 1 must be divisible by 34 (for obvious reasons)." who does that, honestly
18:07:10 <int-e> oh wow, the resultant is prime...
18:27:43 <int-e> Axman6: http://paste.debian.net/1163241/
18:41:23 <int-e> > let n = 2122263984480907878402371291014865454226364055524338306147539613848310493107739273709186352233761725231457680972006354646894860855123328837553 in gcd (n^29+15) ((n+1)^29+15)
18:41:25 <lambdabot>  2929999453992318448049740613368324838537208860708425375808722564474768978034...
19:24:52 <int-e> More of the same... https://paste.debian.net/1163243/
19:34:21 <Axman6> I have no idea what's going on
19:36:15 <int-e> It's okay, it's really number theory, not Haskell :)
19:36:23 <Axman6> int-e: I'm amazed you can get those answers so quickly
19:39:18 <int-e> Axman6: Well, factoring polynomials modulo primes is really fast even for large prime. (But I wouldn't want to implement that... fortunately there are tools like the pari/gp calculator that do that.)
19:40:01 <int-e> So once you have a suitable p, solving x^n + m = (x+1)^n + m (mod p) is fast.
19:41:12 <int-e> And you can find such p by factoring the resultant of those two polynomials (for any prime factor, the resultant will be 0 modulo that prime, ensuring a common root) ... or (since factoring is slow), just testing whether the resultant is prime.
19:41:40 <int-e> And primality testing is fast as well. :)
19:42:34 <int-e> The amazing bit (to me) is still that so many of those resultants are actually prime.
20:26:12 <moet> it seems Data.Vector.Generic doesn't include methods for modifying mutable vectors.. do you have to import and use the corresponding mutable vector module to do mutations? is there a generic interface?
20:30:10 <koz_> moet: Data.Vector.Generic.Mutable
20:30:22 <Axman6> http://hackage.haskell.org/package/vector-0.12.1.2/docs/Data-Vector-Generic-Mutable.html
20:33:21 <moet> Axman6: oops, i missed that.. thank you
23:56:15 <Xnuk> Why `x where x = 1` isn't a expression?
23:56:41 <opqdonut> where can only be used in equations (definitions)
23:56:50 <opqdonut> if you want an expression use `let x = 1 in x`
23:57:20 <Xnuk> Can I put definitions at later?
23:58:01 <Axman6> I don't understand what you mean
23:58:18 <lemmih> > let x = x where x = 10 in x -- Perfect solution!
23:58:20 <lambdabot>  10
23:58:38 <Xnuk> oh that's cool
23:58:41 * Axman6 glares
23:59:07 <xpika> is there a more advance alternative to drift (https://hackage.haskell.org/package/DrIFT) ?
23:59:16 <xpika> advanced*
