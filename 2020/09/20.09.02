00:04:48 * hackage stripe-core 2.6.0 - Stripe API for Haskell - Pure Core  https://hackage.haskell.org/package/stripe-core-2.6.0 (DavidJohnson)
00:05:48 * hackage stripe-tests 2.6.0, stripe-http-client 2.6.0, stripe-haskell 2.6.0 (DavidJohnson)
00:22:49 * hackage stripe-core 2.6.1 - Stripe API for Haskell - Pure Core  https://hackage.haskell.org/package/stripe-core-2.6.1 (DavidJohnson)
00:23:48 * hackage stripe-tests 2.6.1, stripe-http-client 2.6.1, stripe-haskell 2.6.1 (DavidJohnson)
00:28:30 <ph88> i'm trying to use the ginger package and have a heterogenious hashmap or list with the GVal data type. I get some type errors, i'm not sure what to do https://bpa.st/HVYA https://hackage.haskell.org/package/ginger-0.10.1.0
00:46:49 * hackage stripe-core 2.6.2 - Stripe API for Haskell - Pure Core  https://hackage.haskell.org/package/stripe-core-2.6.2 (DavidJohnson)
00:47:49 * hackage stripe-tests 2.6.2, stripe-http-client 2.6.2, stripe-haskell 2.6.2 (DavidJohnson)
00:51:19 * hackage psql-utils 0.2.0.0 - PostgreSQL Simple util tools.  https://hackage.haskell.org/package/psql-utils-0.2.0.0 (Lupino)
01:07:15 <int-e> ph88: Well it works if you provide some more type information, https://paste.debian.net/1162258/
01:08:16 <ph88> oh thanks int-e !
01:08:18 <int-e> ph88: And I don't think ghc can infer any of those, unfortunately. The problem is, it has to guess m for using a  ToGVal (GVal m) m  instance.
01:08:31 <ph88> that type looks quite complicated though ... there is not much in the manual about that
01:08:43 <int-e> It might work if that instance was  m1 ~ m2 => ToGVal (GVal m1) m2  instead? I don't know.
01:09:07 <ph88> shall i try  m1 ~ m2 => ToGVal (GVal m1) m2   ??
01:10:49 * hackage scotty-utils 0.1.0.0 - Scotty utils library  https://hackage.haskell.org/package/scotty-utils-0.1.0.0 (Lupino)
01:11:02 <ph88> int-e, https://bpa.st/E7BA 
01:13:56 <int-e> ph88: ToGVal is a type class so that doesn't make sense.
01:19:02 <int-e> ph88: What I said requires patching the ginger library, but it would help: https://paste.debian.net/1162261/
01:23:33 <int-e> ph88: It's probably possible to accomplish this locally through your own newtype wrapper around GVal, but it seems easier to provide the full type instead.
01:29:34 <int-e> ph88: But just for reference, it would look like this: https://paste.debian.net/1162265/
01:30:45 <ph88> int-e, do you mind if i use your code to open a ticket with ginger ?
01:30:59 <int-e> ph88: not at all, go ahead
01:31:14 <ph88> thank you :)
01:44:06 <ph88> int-e, i tried your fix (this one https://paste.debian.net/1162258/ ) it doesn't type check on my side https://bpa.st/VVDA
01:45:52 <ph88> int-e, should i put your name in the ticket or just keep you anonymous ?
02:01:48 * hackage lrucaching-haxl 0.1.0.0 - Combine lrucaching and haxl.  https://hackage.haskell.org/package/lrucaching-haxl-0.1.0.0 (Lupino)
02:02:49 * hackage scotty-haxl 0.1.0.0, rediscaching-haxl 0.1.0.0 (Lupino): https://qbin.io/woods-meets-olrm
03:37:28 <aiowej> Hi there. Is there a no-nonsense simple (as in few moving parts) build & dependency mgmt system for Haskell? Even following many beginners guides, you end up with having to set `allow-newer` in Stack, which feels very dirty. I love writing compilers and interpreters and other one-file programs in Hs, but writing something with libraries and producing a binary to ship to a server, seems like black magic. I'd love to just have one single
03:37:28 <aiowej> project manifest, and some way other than allow-newer to be able to build something with more than a couple dependencies. 
03:39:26 <opqdonut> why would you need allow-newer? I've been happy with picking a stack lts resolver and just rolling with it
03:40:06 <opqdonut> or alternatively you can just use cabal and specify exact versions for your deps in your cabal file, and probably new-build to sandbox things
03:40:16 <opqdonut> but TBH I'm not that up to date with the most modern things
03:41:59 <merijn> aiowej: A single project manifest. So...a cabal file and cabal-install?
03:43:16 <aiowej> merijn: is that more simple? What I read online is that Cabal is the old complicated way, and Stack is the new simple way. If you recommend it, I'll check out using only that
03:43:35 <merijn> aiowej: Yeah...that is the overeager stack PR brigade
03:43:59 <merijn> aiowej: The reality is that stack vs cabal is probably more of a 50-50 split
03:44:07 <merijn> aiowej: See also: https://gist.github.com/merijn/8152d561fb8b011f9313c48d876ceb07
03:44:52 <merijn> aiowej: And https://cabal.readthedocs.io/en/latest/developing-packages.html
03:54:38 <sshine> in Hedgehog, what's a good alternative to QuickCheck's Gen.vectorOf?
03:57:26 <sshine> ah, Gen.list
04:09:41 <ixlun> Is it possible to pattern match on an array of one elemnt or more than one element?
04:10:17 <phadej> on a list? (it is not possible to pattern match on array - you can pretend though)
04:10:39 <ixlun> sorry, I meant a list
04:10:53 <phadej> case xs of x : _ -> ...
04:12:00 <ixlun> I was thinking something like: [x] and [x,_] respectively ?
04:12:50 <phadej> [x,_] matches list of length 2
04:12:59 <phadej> _ : _ -> matches on a list of length at least 1
04:16:14 <ixlun> Yup, got it. Thanks phadej 
04:30:22 <maerwald> merijn: 50-50 only since ghcup :p
04:31:00 <maerwald> the convenience of stack installing ghc isn't negligible
04:31:02 <aiowej> Does anyone have another favourite typed pure lang that you've used to write a simple web server/SQL-client in? 
04:58:51 <olle> aiowej: are there others?
05:09:52 <merijn> maerwald: I think you overestimate the popularity of stack based on the amount of social media hubbub it generates
05:10:39 <dminuoso> aiowej: Dont know about favourite, but Ive done one in Elixir.
05:10:45 <dminuoso> It was a somewhat painful experience
05:10:46 <maerwald> merijn: I'd not say that I base this on social media
05:11:10 <maerwald> more tho popularity in industry
05:11:30 <maerwald> there, I'd say, cabal is even less popular than nix
05:23:18 <phadej> really? I would disagree
05:23:27 <phadej> but what I know anything about
05:26:59 <maerwald> maybe depends on industry? I don't know
05:31:34 <jkaye[m]> Maybe we should make a third one, "stacabal". That'll really get the flame wars going
05:40:20 <phadej> you mean using bazel to build haskell projects_
05:40:23 <phadej> ?
05:41:48 <ski> dumptruckman : any luck ?
05:48:06 <codedmart> I am trying to copy a file on S3 using `copyObject` from amazonka-s3. Seems to be working fine for most, but here is a file path on s3 currently of `bucket/files/回复：-回复：回复：-回复-：-回复：Laminated-Pouch-RFQ-asdf2234fwsdf.pdf` that fails with `"The specified key does not exist."`. The file and path exist.
05:49:36 <arw> sounds like a unicode normalisation problem
05:49:59 <codedmart> arw I figured something along those lines. Not sure how to go about resolving though.
05:51:08 <arw> codedmart: no idea how to solve it either. depends on your local filesystem, whatever S3 does and all the software in between
05:58:19 <dumptruckman> ski: https://repl.it/repls/VigorousScrawnyBinary
06:01:06 <dumptruckman> dmwit gave me liftA2 (.) as the solution for how to compose them but I still haven't quite figured out how this translates to java
06:01:28 <codedmart> arw url encoding seems to work.
06:01:36 <dumptruckman> I'm guessing I need to write an applicative functor type class
06:01:47 <dumptruckman> (similar to java's Optional) that does the predicate's job
06:06:23 <dibblego> you cannot write applicative in java
06:06:31 <dumptruckman> i disagree
06:06:50 <dibblego> nobody has ever written applicative in java, many of us have tried
06:08:54 <dumptruckman> can you explain how Optional isn't an applicative functor then?
06:09:18 <dibblego> well, that Optional is broken for many reasons, but I didn't say it's not an applicative functor
06:09:26 <dibblego> you cannot write the applicative abstraction in java
06:09:42 <dumptruckman> ok, i guess i don't know the difference then
06:09:43 <dumptruckman> but
06:09:58 <dumptruckman> i did say i needed to write an applicative functor
06:10:28 <dumptruckman> so why bother telling me i cannot write applicative in java if it's not what i said?
06:10:47 <dibblego> "I need to write an applicative functor type class [in java]" — this is not a thing
06:11:05 <dibblego> https://github.com/functionaljava/functionaljava/blob/series/5.x/core/src/main/java/fj/data/Option.java
06:11:18 <dumptruckman> not a "type class"
06:11:26 <dumptruckman> type as in like
06:11:33 <dibblego> you cannot write it as a data type either
06:11:53 <dibblego> you will require higher-kinds to do that, and java cannot do that
06:13:30 <dumptruckman> ok well w/e you say. i'm still able to perform the composition of the two functions and I can almost certainly write a class similar in style to Optional to act as a computational context for this composition
06:14:45 <dibblego> yes you can write Option<F<A, C>> compose(Option<F<B, C>>, Option<F<A, B>>)
06:15:28 <dibblego> https://github.com/functionaljava/functionaljava/blob/series/5.x/core/src/main/java/fj/data/Option.java#L841
06:24:48 * hackage pandoc-crossref 0.3.8.0 - Pandoc filter for cross-references  https://hackage.haskell.org/package/pandoc-crossref-0.3.8.0 (lierdakil)
06:26:14 <ski> dumptruckman : hm, that gives me a blank page
06:27:23 <dumptruckman> ski: maybe try this? https://repl.it/repls/CornyFabulousMarkuplanguage
06:28:16 <ski> all are blank. i guess because they require ECMAscript
06:28:23 <dumptruckman> ahh, probably so
06:30:25 <sshine> I'm rewriting some QuickCheck generators into Hedgehog. in particular I've got an 'if-then-else' generator which, in QuickCheck, is an explicitly sized generator (Int -> Gen ...).
06:32:12 <ski> btw, i'm not seeing how `Option' or `Optional' relates to your predicate/flag
06:32:15 <sshine> with Hedgehog I get the luxury of Gen.recursive, but since the size parameter is implicit and the 'if-then-else' generator is shared between two top-level generators, 'ifThenElseGen someExprGen = IfThenElse <$> boolExprGen <*> someExprGen <*> someExprGen' looks a bit dangerous to me: naturally, I'm just calling it in two places that both use Gen.recursive which halves the implicit size. but the definition 
06:32:21 <sshine> itself isn't that safe...
06:33:09 <sm[m]> jkaye: I proposed staball :)
06:33:53 <cr0ssw1nd> hello
06:34:14 <cr0ssw1nd> is there something modern what I can use to generate static call-graph of a program?
06:34:25 <cr0ssw1nd> in order to analyze control flow
06:34:55 <cr0ssw1nd> quick scan on hackage gave me several old packages (not newer than 2015)
06:35:23 <cr0ssw1nd> I guess such a tool would use output of haddock
06:35:28 <cr0ssw1nd> these days
06:37:45 <sshine> I don't know that there is a good general-purpose library. I suspect the combination of making such a library abstract enough to cover multiple instruction sets and concrete enough to handle obfuscated jumps in particular instruction sets is slightly heroic...
06:38:47 <sshine> cr0ssw1nd, sorry, do you mean a static call-graph of a Haskell program?
06:40:43 <sm[m]> cr0ssw1nd: I'm guessing https://kowainik.github.io/projects/stan doesn't do it but it links to weeder which might
06:42:02 <ski> dumptruckman : anyway, i think dibblego was objecting to being able to write something like `Applicative' (a Haskell type class) in Java, not to writing particular instances of it, like `Maybe',`Reader r',`State s',&c., in Java
06:44:20 <dumptruckman> right
06:44:23 <ski> dumptruckman : and, presumably, you'd (at most) need the latter. if even that. you could just expand `liftA2 (.)' to `\f g r x -> f r (g r) x', side-stepping / inlining `instance Applicative (r ->)'
06:44:33 <cr0ssw1nd> sshine, yeah, from Haskell source, not from binary
06:45:00 <cr0ssw1nd> just to see when functions from certain modules are called
06:45:19 <ski> > liftA2 (.) (f :: Expr -> Expr -> Expr) g r x
06:45:21 <lambdabot>  f r (g r x)
06:46:08 <cr0ssw1nd> sm[m], stan looks interesting and also pretty new, thanks
06:49:54 <cr0ssw1nd> it doesn't provide with particularly call graph though
07:00:05 <sm[m]> as I thought but what about weeder
07:33:08 <cr0ssw1nd> sm[m], oh, I missed the link to "weeder"
07:34:46 <dminuoso> ski: Recently we had a discussion, fantasizing about how a permutation of characters in a functions binder would permute the argument order, e.g. `gf` would be the flipped version of `fg`. This lead to some interesting ideas how an anagram would only work for commutative functions.
07:35:05 <dminuoso> Do you happen to know of programming languages that allow lexical manipulations with meaning?
07:35:14 <dminuoso> (If anyone does, it would be you)
07:37:14 <kuribas> dminuoso: TeX does
07:37:23 <dminuoso> kuribas: Mmm. In what sense?
07:37:48 <kuribas> dminuoso: it assigns meaning to lexical elements
07:37:56 <dminuoso> Can you explain?
07:38:00 <dminuoso> Im not very familiar with TeX
07:38:35 <dminuoso> In particular Im referring to a language, in which lexical manipulation changes a programs meaning. Similar to how natural languages use inflection to do the same.
07:38:47 <sshine> hmm... I'm doing a property test that says 'parse' and 'pretty' are mostly inverses. I have one problem with my AST generator that generates an AST corresponding to "0 * (0 * 0)" for a left-associative '*'. then the very smart pretty-printer sees that the parenthesis is redundant (parent node in tree has same precedence and associativity) and omits it, which then gets parsed as "(0 * 0) * 0"...
07:38:50 <kuribas> dminuoso: well you can change any lexical character to mean something else, for example you can make '(' mean '+', or the characters 'a' and 'b' mean '(' and ')'
07:39:06 <dminuoso> kuribas: Oh, no. That's not what I had in mind.
07:39:11 <kuribas> dminuoso: ah right :)
07:39:20 <sshine> so I'm thinking that my property should probably be a little more sophisticated.
07:39:30 <kuribas> dminuoso: also 'meaning' doesn't really exist in TeX, because this even changes already defined macros.
07:40:06 <dminuoso> kuribas: As another example, consider a language where `f :: Int`, and `fs :: Stream Int` without needing a binding. So inflecting `x` to `xs` to indicate a plural would do that.
07:40:29 <dminuoso> Im not looking for these examples in particular, just curious whether research has gone into this style
07:41:04 <kuribas> dminuoso: you probably can do that in Tex :)
07:41:19 <kuribas> dminuoso: it has prefix, infix, and postfix macros
07:41:23 <dminuoso> kuribas: Sure, but only because that's a macro system
07:41:29 <kuribas> yeah
07:41:35 <kuribas> a very sofisticated one
07:42:23 <dminuoso> Well, we could do the same with TemplateHaskell.
07:42:59 <kuribas> I wouldn't consider TeX language a good example of anything.
08:07:15 <ski> dminuoso : "a permutation of characters in a functions binder" ? also not sure how being an anagram of something would imply commutativity
08:08:28 <ski> dminuoso : fwiw, the plural thing reminds me of "Lingua::Romana::Perligata -- Perl for the XXI-imum Century" by Damian Conway at <http://users.monash.edu/~damian/papers/HTML/Perligata.html>
08:17:32 <dmwit> sshine: If * is left-associative, then you cannot omit parentheses from 0 * (0 * 0).
08:17:44 <dmwit> sshine: So to me it looks like property-based testing has uncovered a real bug in your pretty-printer.
08:20:33 <dmwit> ski: Perhaps the sentence should be read "words that are anagrams of themselves" -- i.e. words with repeated letters. Then it makes sense to demand that if you pick such a name, it must be commutative in the repeated bits.
08:22:00 <ski> aren't all words anagrams of themselves ?
08:22:42 <ski> (trivially)
08:23:23 <dumptruckman> ski: if i'm not mistaken that's basically what i already have... BiFunction<S, Predicate<R>, S> andThen(BiFunction<S, Predicate<R>, S> after) { return (S s, Predicate<R> p) -> after.apply(apply(s, p), p); }
08:23:57 <dumptruckman> well, this is reverse composition, i guess?
08:24:22 <ski> dumptruckman : is that a static method ?
08:24:26 <dumptruckman> no
08:24:39 <dumptruckman> it's part of an interface that extends BiFunction<S, Predicate<R>, S>
08:24:43 <ski> in which class/interface does it occur, then ?
08:24:46 <ski> mhm
08:25:36 <ski> dumptruckman : do you need `Predicate<R>', or would `boolean' work as well ?
08:25:53 <dumptruckman> presumably Boolean would work as well
08:26:16 <dumptruckman> it is Predicate<R> here as it is expecting a lambda function
08:26:26 <dumptruckman> a "precompiled boolean"
08:26:39 <dumptruckman> R is actually this type
08:26:42 <dumptruckman> in this case
08:27:20 <dumptruckman> but it doesn't have to be, the predicate is passed into the apply function
08:27:48 * hackage heapsize 0.1 - Determine the size of runtime data structures  https://hackage.haskell.org/package/heapsize-0.1 (mpardalos)
08:29:23 <dumptruckman> the apply function implementation i'm using is String apply(String s, Predicate<TagReplacer> filter) { return filter.test(this) ? s.replace(tag, replacement) : s; }
08:29:36 <dumptruckman> where tag and replacement are instance variables
08:30:03 <dumptruckman> so the caller provides a predicate that tests against the thing they're calling on
08:30:18 <dumptruckman> to examine it's properties, basically
08:30:56 <dumptruckman> so this all already works it just doesn't use standard function composition which is what i was hoping to achieve
08:34:56 <ski> dumptruckman : hm, and in which class is that `apply' ?
08:35:24 <dumptruckman> TagReplacer which implements BiFunction<S, Predicate<R>, S>
08:35:50 <dumptruckman> TagReplacer implements BiFunction<String, Predicate<TagReplacer>, String>
08:36:08 <ski> mhm
08:37:37 <ski> "it's part of an interface that extends BiFunction<S, Predicate<R>, S>" -- what interface is that ?
08:37:40 <dumptruckman> but I wonder if I could some how get away with a TagReplacer implements UnaryOperator<String> and have the filter predicate thing but some other (or an applicative functor i'm guessing?) that essentially wraps it and allows standard function composition
08:38:28 <dumptruckman> ok well, that was a work in progress... the working example is that the custom andThen function appears in the TagReplacer class
08:38:44 <dumptruckman> But it could presumably live somewhere more abstract
08:38:54 <dumptruckman> in an interface I named PredicatedOperator
08:39:06 <ski> i'm wondering about whether you need/want to pass `this' to `filter'
08:39:09 <dumptruckman> PredicatedOperator extends BiFunction<S, Predicate<R>, S>
08:40:12 <ski> (`this' being of type `TagReplacer')
08:40:19 <dumptruckman> right so
08:40:33 <ski> what information, if any, could `filter' extract from a `TagReplacer' ?
08:41:43 <ski> i'm wondering whether it would be enough with `Boolean flag', or `F0<Boolean> flag', in place of `Predicate<TagReplacer> filter'
08:41:56 <Xcalibur> Hi, I recently started learning Haskell with the eBook "Learn you a Haskell" and I really enjoy it so far. I'm currently at chapter 8 and I'm trying to create some module containing functions and a binary tree type declaration.
08:42:10 <Xcalibur> I'm having now issues with imports
08:42:20 <ski> what kind of issues, Xcalibur ?
08:43:09 <Xcalibur> I created a folder named BinaryTree with two files in it: Tree.hs and Traversal.hs. Im trying to import Tree.hs in Traversal.hs. 
08:43:13 <dumptruckman> There's a subclass of TagReplacer that adds a contextual property to (it assigns it to a "person"). Given a composed TagReplacer function, I want to set the context by saying, I'm apply this function for this person. Therefore it should only apply the replacers that are appropriate for that context, if one of the composed function isn't appropriate
08:43:13 <dumptruckman>  for that context it just applies the identity function.
08:43:51 <dumptruckman> just applies the identity for that particular replacer function
08:44:01 <ski> Xcalibur : you may have to name the modules (not the files) `BinaryTree.Tree' and `BinaryTree.Traversal'
08:44:05 <dumptruckman> the rest in the "chain" will still apply normally, assuming the context is appropriate
08:44:30 <Xcalibur> I named the module in Tree.hs BinaryTree.Tree and the module in Traversal.hs BinaryTree.Traversal. When I'm trying to import BinaryTree.Tree in Traversal.hs with import BinaryTree.Tree the module cannot be found somehow 
08:45:10 <ski> Xcalibur : are you trying to access them from inside the directory `BinaryTree', or from the parent director ?
08:45:38 <Xcalibur> ski Both modules are on the same directory level
08:45:43 <ski> yes, i know
08:46:10 <ski> i'm asking whether you're starting GHCi (or calling GHC, or whatever), from inside that directory, or from the parent one
08:46:12 <Xcalibur> I see what you mean. I tried loading up both modules in ghci
08:46:35 <Xcalibur> while starting ghci from the same folder
08:47:04 <ski> dumptruckman : mhm, okay
08:47:58 <ski> Xcalibur : try starting it from the parent folder, then use `:l BinaryTree.Tree BinaryTree.Traversal' e.g.
08:49:11 <Xcalibur> ski yay :)  That worked
08:49:19 <Xcalibur> Thank you
08:49:40 <ski> dumptruckman : hm, so what is `filter', when you call `apply' or `andThen' ? is it `cond' or `always', or something else ?
08:49:46 <ski> np, Xcalibur :)
08:50:02 <dumptruckman> basically it's cond or always, yep
08:50:06 <dumptruckman> well
08:50:21 <dumptruckman> except in the Java impl it's just the Bool
08:50:44 <Xcalibur> Why isn't it working though when trying to load the files in ghci with ghci started from the same directory?
08:51:16 <dumptruckman> i wonder if i model this as an applicative functor if it would provide more inside
08:51:17 <dumptruckman> insight*
08:51:31 <ski> dumptruckman : so, correct me if i'm wrong, but `always' never inspects the `TagReplacer' it gets, yes ? how about `cond' ?
08:52:09 <dumptruckman> well, in the haskell impl, the cond and always just take the Bool so the "inspection" has already occurred
08:52:25 <dumptruckman> i'm assuming you got the repl.it working?
08:52:38 <ski> Xcalibur : a module named `BinaryTree.Tree' is, by GHC, searched for in the file `BinaryTree.Tree.hs', or in the file `Tree.hs' in the subdirectory `BinaryTree'
08:53:05 <dumptruckman> `always' just ignores the result of the inspection
08:54:01 <Xcalibur> ski Ah I see. Thanks for your help!
08:55:23 <ski> Xcalibur : so, if you're inside `BinaryTree', and it looks in `Tree.hs', but doesn't find a module named `Tree' (instead finds one named `BinaryTree.Tree'), it's going to be confused
08:56:41 <dumptruckman> i think the whole needing to inspect the context of the function is the real catch here
08:56:56 <fresheyeball> anyone know a good way of exploring a Haskell data type in the browser?
08:57:07 <dumptruckman> and the haskell implementation i made obviously cannot do that
08:57:34 <fresheyeball> with nice interactive expand-o-collapse kind of things
08:58:08 <dumptruckman> i basically need to apply metadata to the replacer function
08:58:23 <dumptruckman> and the Bool part becomes Metadata -> Bool
08:58:30 <dumptruckman> or something like that
08:59:19 * hackage stratosphere 0.58.0 - EDSL for AWS CloudFormation  https://hackage.haskell.org/package/stratosphere-0.58.0 (jdreaver)
09:07:23 <sm[m]> old-style cabal install failure with new-style cabal.. (well, cabal 2.4 new-build): https://groups.google.com/g/hledger/c/J9APCI0ddso/m/5F3xfAFnAQAJ
09:08:14 <sm[m]> is it expected that cabal 2.4 new-build would fail to find install plans that 3.2 finds routinely ?
09:08:58 <Patternmaster>  
09:09:20 <feuerbach> huh, apparently Google no longer allows browsing Google Groups without logging in
09:10:03 <sm[m]> really
09:10:53 * sm[m] contemplates starting a usenet group
09:11:11 <tomjaguarpaw> Yeah I noticed that recently when trying to view the Seattle Haskell Users Group
09:12:36 <sm[m]> I used to be able to link to gmane.io, but it's NNTP only now
09:13:41 <ski> dumptruckman : hm. in Haskell, you could replace `a -> Bool -> a' by `(s,a -> (s -> Bool) -> a)', i suppose, `s' being the type of the information the predicate needs to make its decision
09:15:47 <maerwald> sm[m]: what are you doing?
09:16:01 <maerwald> 2.4 is a shaky release
09:16:14 <sm[m]> not me, a user
09:16:27 <maerwald> tell them to use 3.2 or even 3.4-rc1
09:16:41 <sm[m]> I'm just curious
09:16:47 <maerwald> don't be :p
09:17:46 <sm[m]> until now I thought cabal 2.4 was "old but we used to rely on it, so probably will get it installed", wondering if I need to require cabal 3.2 or later
09:17:59 <sm[m]> which I don't do casually since I want install to be as low friction as I can contrive
09:18:52 <maerwald> what?
09:19:00 <sshine> dmwit, okay, so how about if I remove the parenthesis-removal from prettyprinter and move it into a normalize function. then my inverse property can go through, and i can test normalize separately, and maybe I can think of a neat property for the combination of prettyprint and normalize if I want the composed effect. this seems to me as 'more testable' and 'functions do one thing'...
09:19:21 <sm[m]> I try not to force people to upgrade their haskell build tools to install hledger, if it's not needed
09:19:22 <maerwald> sm[m]: 3.2 isn't harder to install than 2.4
09:19:38 <maerwald> you should tell them to upgrade
09:19:48 <maerwald> they can also have many cabals in parallel
09:20:01 <maerwald> (if they use ghcup at least)
09:20:06 <monochrom> sm[m]: In the following, GHC is 8.8.4 throughout.
09:21:42 <monochrom> If I try "cabal-2.4 v2-install --dry-run hledger hledger-web", the first issue I notice is not about persistance or persistence-template (it's present alright), the first issue I notice is "Warning: Unknown/unsupported 'ghc' version detected (Cabal 2.4.1.0 supports 'ghc' version < 8.7): /usr/local/ghcup/bin/ghc is version 8.8.4"
09:22:28 <monochrom> If Thielmann is hardcoding "with-compiler: ghc-8.8.4" in his cabal.project, he's hiding that warning from you.
09:22:39 <monochrom> Now here is what I don't understand.
09:23:19 <monochrom> If I try "cabal-3.2 install --dry-run  hledger hledger-web", the build plan does not mention yesod or persistent or persistent-template at all.
09:24:19 <sm[m]> monochrom: thanks for testing! that sounds odd, maybe they're already installed ?
09:24:19 <maerwald> less dependencies is always good, take it or leave it opportunity
09:24:35 <monochrom> I have not already installed.
09:25:03 <monochrom> The 2.4 failure and the 3.2 build plan are on my computer.
09:25:29 <dmwit> sshine: Sounds sensible to me.
09:25:48 <monochrom> Also, "cabal-3.2 install --dry-run --constraint='aeson < 1.5' hledger hledger-web" produces a build plan too, and still does not involve yesod or persistent-*
09:25:53 <maerwald> you could write a thesis about the differences in bugs between cabal versions I believe... I'd just focus on the latest bugs :)
09:26:30 <dmwit> cmcma20: For what it's worth, for heap profiling, I have pretty much only used the tools that come bundled with GHC.
09:26:32 <sm[m]> monochrom: don't know how that works
09:26:34 <sm[m]> what I don't understand is why cabal 2.4 has fixate on the latest 1.0 version of dlist, causing it to fail. Maybe it's just a normal failure of the solver (in 2.4) that can happen "randomly".
09:26:35 <monochrom> But I would pay much more attention to "why are you using cabal-2.4 and ghc-8.8 together in the first place".
09:27:36 <sm[m]> Henning wanted to stick with 2.4 to avoid rebuilding all his deps. We needn't care about that too much, I'm just curious about cabal's behaviour generally for future incidents
09:28:19 <monochrom> Then he should also stayed at ghc 8.6.  To avoid rebuilding all deps, too.
09:28:33 <maerwald> yeah, that's an odd argument
09:28:37 <dmwit> ski: I don't know, depends how you define anagram, I guess. I would want "anagram" to mean "there is a nontrivial permutation that converts one to the other", in which case words with no repeated letters are not anagrams of themselves.
09:28:57 <sm[m]> agreed
09:29:24 <sm[m]> maybe he has been using 2.4 and 8.8.4 for a while
09:29:48 <monochrom> Also, I don't observe fixating on any dlist.  The rejections don't even get to that.  I'll post the rejection log.
09:29:57 <dmwit> ski: Hm. Actually, now that I've said it out loud, I'm not sure I even agree with myself here. Maybe that's not the definition of anagram I want. ¯\_(ツ)_/¯
09:29:59 <ski> dmwit : i guess i'd call that "nontrivial anagram"
09:30:13 <dmwit> ski: That sounds like a good idea.
09:30:13 <sm[m]> monochrom: I'm talking about henning's last log in the mail thread
09:30:26 <monochrom> https://paste.tomsmeding.com/bu1PSUdC
09:30:42 <sm[m]> nice! tomsmeding pastebin at work!
09:30:59 <ski> (well, let's say a permutation that doesn't act as the identity, on the family of letters in question)
09:31:30 <dmwit> Yeah, seems like there's at least three sensible choices.
09:31:37 <monochrom> In other words, "what dlist???".  cabal-2.4 has only got far enough to try hledger-web -> yesod-form -> yesod-persistent -> persistent-template -> persistent.  What dlist?  I see no dlist involved.
09:31:42 <dmwit> Any permutation, any nontrivial permutation, any permutation that actually changes something.
09:32:41 <dmwit> Perhaps we can introduce the danger of confusion by using "nontrivial" for one and "strict" for the other.
09:32:53 <ski> (i tend to often prefer inclusive definitions, including more trivial or "dummy"/"null" cases, unless there's any clear reason/advantage not to. e.g. a square is a rectangle. i'm my own sibling (and cousin))
09:33:09 <sm[m]> monochrom: yes, it has failed differently for you. Nothing unusual there, cabal install failures are lovely unique snowflakes :)
09:33:29 <monochrom> OK point taken
09:34:29 <monochrom> OK dlist is brought up if --constraint='aeson < 1.5'.  But normally we don't impose that.
09:35:02 <sm[m]> I see, yours has fallen afoul of https://github.com/yesodweb/persistent/issues/1120 , which we dealt with earlier in the mail thread. Yes that's the constraint I recommended to him, but his fails even with that
09:36:45 <ski> dmwit : "strict" being the one that actually changes at least one position ?
09:36:47 <sm[m]> now you're seeing the same failure mode, it sounds like. I wondered if --max-backjumps helped at all. But don't let me sidetrack you too much with this
09:38:28 <monochrom> OK here is an extension of what I don't understand. So now I inflict "-w ghc-8.6". There is no error either. There is also no involvement of yesod.
09:39:23 <sm[m]> I think either cabal *build hledger-web --dry-run must show it, or ghc-pkg list must show it
09:39:25 <dmwit> ski: right
09:39:37 <sm[m]> if you're running the right ghc-pkg / in the right context
09:40:38 <sm[m]> biab
09:41:30 <maerwald> sm[m]: you have public S3 buckets? Then you could provide a hledger cabal cache
09:41:35 <monochrom> https://paste.tomsmeding.com/D0nllwfz is my result of cabal-2.4 -w ghc-8.6, two versions: aeson unconstrained, aeson < 1.5
09:42:02 <monochrom> I think I wouldn't support what cabal and ghc wouldn't support: combination of 2.4 and 8.8.
09:44:24 <monochrom> Well, I was unfair. Here is the logical thing I don't understand though.
09:46:43 <monochrom> Nevermind. yesod is probably involved in the library section, I would need to add --lib to see it.
09:53:06 <maralorn> Where is the Code for hackage being hosted? Does it accept contribution? And would it structurally be possible to add a Reverse Dependencies listing?
09:53:30 <sshine> dmwit, thanks!
09:53:42 <maralorn> i.e. I fear this would be hard, if the package page only get's recreated when a version of that package get's uploaded.
09:55:21 <cohn> I'm running the Haskell platform on a Mac. How do I completely uninstall it so I can replace it with ghcup?
09:55:53 <geekosaur> there should be an uninstall-hs script in its install directory
09:56:12 <cohn> geekosaur: yep, found it! thanks
09:59:00 <sm[m]> maralorn: https://packdeps.haskellers.com/ is the reverse deps everyone uses. I'm sure there's an old WIP issue for building the feature into hackager-server though
09:59:11 <sm[m]> http://hackage.haskell.org/package/hackage-server
09:59:20 <geekosaur> maralorn, it might be easier to link to packdeps.haskellers.com/reverse/$PACKAGE, but note that dependencies can change by package version and I don't think packdeps tracks that
09:59:31 <geekosaur> wheee, I'm slow
09:59:56 <sm[m]> https://github.com/haskell/hackage-server/pull/723
10:00:05 <geekosaur> I was also looking for hackage-server but hackage is still loading here...
10:00:10 * sm[m] is on fire
10:03:48 * hackage ghcide 0.3.0 - The core of an IDE  https://hackage.haskell.org/package/ghcide-0.3.0 (PepeIborra)
10:05:25 <sm[m]> in my github mac CI workflow, I see a recurring failure like "hledger-lib> /Users/runner/.stack/setup-exe-cache/x86_64-osx/Cabal-simple_mPHDZzAJ_2.4.0.1_ghc-8.6.5: /Users/runner/.stack/setup-exe-cache/x86_64-osx/Cabal-simple_mPHDZzAJ_2.4.0.1_ghc-8.6.5: cannot execute binary file". It keeps coming back even when I invalidate the cache. Has anyone else seen it ?
10:05:59 <sm[m]> doesn't happen for similar workflows on linux and windows
10:07:35 <geekosaur> this si going to be the 10.9+ binary security thing, which I don't think anything deals with currently. stack downloads and installs its own ghc, but os x won't let it be run directly
10:07:46 <ixlun> Say I have: data Foo = A | B | C and I want a mapping for *all* Foos to Bools: {A:True,B:True,C:True}, what data type should I use?
10:08:14 <dmwit> Foo -> Bool, I guess
10:08:41 <sm[m]> geekosaur: that sounds interesting. But if I force it to redownload everything, all works fine. This happens later (perhaps the first time it uses cached files)
10:08:43 <dmwit> You could also look at http://hackage.haskell.org/package/total-map
10:09:19 <sm[m]> plus, this never happens on a local mac
10:11:43 <ixlun> Sorry, I suppose I should have said data structure rather than data type 
10:12:26 <sm[m]> https://github.com/haskell/cabal/issues/1076 is the only thing that looks related
10:12:58 <ixlun> I was thinking of using Data.Set, and the presenance of a Foo indicates a truth-y value, false otherwise.
10:13:43 <ixlun> dmwit: Why would I use a total-map instead of a Map?  Does it allow me to ensure that it always has keys for all Foos?
10:15:05 <maerwald> sm[m]: sometimes I don't understand how anything works at all :)
10:15:16 <maerwald> It's a miracle, after all
10:15:25 <sm[m]> maerwald: right you are!
10:18:14 <dmwit> ixlun: Yes, that is exactly what it ensures.
10:19:14 <dmwit> Set ties you to Bool as the output, but otherwise also seems like a fine choice.
10:19:49 <dmwit> You may want (Set Bool, Bool) to allow negation, similarly to the way total-map is (Map k v, v).
10:20:32 <dmwit> i.e. the extra Bool tells whether to interpret members of the Set as returning True (and non-members False) or to interpret members of the Set as returning False (and non-members True).
10:21:07 <dmwit> Sorry, (Set Foo, Bool), of course.
10:21:20 <dmwit> For Foo specifically it doesn't matter, but e.g. think about (Set Integer, Bool).
10:25:35 <cohn> anyone know if there are any plans to add Stack to the tools managed by ghcup?
10:26:07 <solonarv> stack manages itself and it's my impression it wants to stay that way
10:26:09 <maerwald> cohn: that would be easy, but stack has its own way of upgrading
10:26:17 <maerwald> I think that'll cause confusion for users
10:26:26 <cohn> oh
10:26:42 <sm[m]> solonarv: stack wouldn't mind a bit
10:27:05 <sshine> cohn, with stack you'd wanna install GHC via Stack.
10:27:49 <cohn> so ghcup is not the right way to install GHC for building projects with Stack?
10:27:52 <sshine> cohn, so unless ghcup installs GHC to the same location as Stack, you might end up with duplicate instances of the same version of GHC, I think?
10:27:54 <sm[m]> what if ghcup became able to detect stack installations and manage stack's ghcs too ? 
10:28:12 <cohn> sshine: that wouldn't be fun
10:28:22 <maerwald> You can already tell stack to use system GHC
10:28:28 <cohn> oh good
10:28:29 <sm[m]> unholy mess or user-friendly haskell setup swiss army penknife ?
10:28:30 <maerwald> Then you manage your GHCs with  ghcup
10:28:33 <maerwald> easy
10:28:38 <sshine> sm[m], I think that in order for managing software to manage other managers, it has to think of itself as superior. so Nix.
10:28:38 <cohn> whew
10:29:02 <cohn> sshine: I've heard about Nix. what exactly is it?
10:29:09 <sm[m]> sshine: ok what if.. ghcup made it possible for mortals to manage nix ? :)
10:29:14 <maerwald> cohn: a religion
10:29:18 <cohn> haha
10:29:25 <sshine> cohn, it's a package manager.
10:29:33 <sshine> sm[m], that'd be great.
10:29:38 <runeks> Can anyone tell me what the tuple argument to https://hackage.haskell.org/package/array-0.5.4.0/docs/Data-Array-MArray.html#v:newArray is supposed to contain?
10:29:55 <runeks> low/high index? low index/size?
10:30:00 <cohn> that's mildly confusing then. I thought ghcup was the package manager
10:30:05 <cohn> or at least the installer
10:30:16 <sshine> sm[m], I have yet to use Nix in one of my projects. :) I recently had to push something to two projects that use Nix, but unfortunately I couldn't make it work and deferred to stack and cabal respectively.
10:30:33 <maerwald> cohn: https://docs.haskellstack.org/en/stable/yaml_configuration/#system-ghc
10:30:41 <cohn> maerwald: thanks
10:30:53 <sshine> cohn, ghcup is an installer.
10:31:15 <sshine> cohn, this is what everyone used on Windows 95 before Linux invented package managers. :-D
10:31:49 <monochrom> Wait, where can I get a version of ghcup that works on Windows 95? :)
10:32:01 <sshine> cohn, and apparently the easiest to get started with when we're in the middle of a package manager war... the operating system has one package manager, your preferred programming has one, and your build system has one that ties them together.
10:32:14 <maerwald> sshine: ghcup is a package manager too
10:32:25 <cohn> yikes
10:32:30 <sshine> curl --proto '=https' --tlsv1.2 -sSf https://get-ghcup.haskell.org/GHCUP95.EXE | sh
10:32:32 <monochrom> Naw, the build system has one that ignores them altogether.
10:32:33 <maerwald> the definition of package manager is very broad
10:32:57 <monochrom> But yeah, all confusions are due to over-simplified assumptions.
10:33:10 <monochrom> People have made a mess of the world out there. Remember that.
10:33:26 <monochrom> People are not going to organize things the way you feel natural.
10:33:40 <sshine> I remember when I started out with Haskell and thought that Arch Linux'es re-packaging of popular Haskell libraries was super smart...
10:34:38 <monochrom> sshine, I'm wonder if "| sh" should be "| command.com"
10:34:40 * runeks waves to sshine
10:34:48 * ski . o O ( "5. The solution depends on the problem. The answer depends on the question." )
10:34:50 <sshine> monochrom, ah yes. I was being lazy.
10:34:54 <monochrom> hehe
10:35:01 <sshine> hej runeks :)
10:35:07 <runeks> :D
10:35:32 <maerwald> ski: what does the question depend on? :)
10:35:54 <runeks> sshine are you able to summon people who are knowledgeable about the MArray class?
10:36:12 <ski> maerwald : probably a previous answer
10:36:21 <maerwald> that sounds like a blockchain
10:37:25 <ski> runeks : fwiw, you might be interested in #haskell.scandinavian (and maybe #haskell.no .. not sure whether there's any danish one)
10:37:34 <monochrom> maerwald, you may also enjoy this to cut the chain.  3. Not all constraints can be satisfied. Not all problems are meant to be solved.
10:37:48 <monochrom> These are from my http://www.vex.net/~trebla/humour/tautologies.html
10:38:03 <runeks> thank you ski 
10:38:43 <ski> (there's also #haskell.se .. but i suppose you're not in .se)
10:39:34 <ski> monochrom : maybe an addition is warranted ?
10:40:07 <monochrom> I don't think all questions come from previous answers.
10:40:30 <monochrom> "some questions come from previous answer" is tautological but not funny enough
10:40:44 <monochrom> Most questions come from wishful thinkng, really.
10:41:00 <natpd> how can i change the parsed lexeme in the original String using module Text.Megaparsec?
10:41:05 <maerwald> I think questions come from your current mood
10:41:11 <ski> i meant something relating to "All confusions are due to over-simplified assumptions."
10:41:18 <monochrom> Yeah, mood is even better.
10:41:22 <ski> maybe not tautologous enough, though
10:41:58 <monochrom> That one is tautological alright. But it overlaps with the one about inexplicable problems. I'll have to think about it.
10:42:25 <monochrom> The watertight one is s/over-simplified/wrong/
10:49:49 * hackage lingo 0.5.0.1 - File extension based programming language detection  https://hackage.haskell.org/package/lingo-0.5.0.1 (rewinfrey)
11:02:29 <tomsmeding> monochrom: "11. A piece of writing is clear to its writer."
11:02:31 <tomsmeding> I object to that one
11:23:38 <tchouri> runeks: Did you get an answer by other means?
11:24:13 <hekkaidekapus> runeks: Sorry, tchouri ≣ this nick
11:25:34 <hekkaidekapus> If not, check out this ghci example: https://paste.tomsmeding.com/C2O9aNES -- runeks
11:30:52 <dminuoso> ski: Oh sorry I missed a part. The initial idea was to take something like `foo`, where spelling it backwards as `oof` would give you a flipped version of that function
11:31:35 <dminuoso> Further, int he idea that `fob` and `fbo` would be permuted argument order, then truly you could not distinguish between `fof` and `fof`
11:31:41 <dminuoso> There by implying a sort of commutativity
11:32:27 <runeks> hekkaidekapus, yes, thank you. It's low/high index. I've submitted a merge request to the "array" package to make this clearer.
11:33:10 <L29Ah> i have "let foo bar = baz", how do i attach a type annotation to foo?
11:33:20 <hekkaidekapus> Oh, thank you for your contributiom, runeks.
11:33:49 <sshine> L29Ah, let (foo :: t) bar = baz, but perhaps you want to use 'where' and a stand-alone type signature?
11:34:44 <L29Ah> % let (foo :: Int -> Int) bar = bar
11:34:44 <yahb> L29Ah: ; <interactive>:214:5: error: Parse error in pattern: (foo :: Int -> Int)
11:35:01 <L29Ah> perhaps not as i'm in a do block
11:35:19 <L29Ah> and want to make a closure
11:36:17 <xsperry> L29Ah, let foo :: a -> b\nfoo bar = baz
11:36:18 <sshine> I'd say if you need the type signature, it is probably worth pulling out. :)
11:36:26 <sshine> xsperry, ah, nice.
11:36:40 <L29Ah> sshine: then it would need a shitload of arguments
11:36:58 <L29Ah> and then typing them all out a few times at the points of use
11:38:52 <L29Ah> xsperry: error: parse error on input ‘=’
11:39:31 <L29Ah> oh it needs to be indented under let, not only \n
11:39:58 <L29Ah> thanks
11:41:50 <hekkaidekapus> L29Ah: Yes. Or if you want a oneliner: `let f :: Int -> Int; f x = x + 1`
11:47:19 * hackage hledger-flow 0.14.1.0 - An hledger workflow focusing on automated statement import and classification.  https://hackage.haskell.org/package/hledger-flow-0.14.1.0 (apauley)
11:49:32 <electricityZZZZ> so i say stack ghci in my terminal and i get this error:
11:49:36 <electricityZZZZ> "/home/username/.stack/build-plan/lts-16.12.yaml" (Response {responseStatus = Status {statusCode = 404, statusMessage = "Not Found"}, responseVersion = HTTP/1.1, responseHeaders = [("Connection","keep-alive"),("Content-Length","14"),("Content-Security-Policy","default-src 'none'; style-src 'unsafe-inline'; sandbox"),("Strict-Transport-Security","max-age=31536000"),("X-Content-Type-Options","nosniff"),("X-Frame-O
11:49:37 <electricityZZZZ> ptions","deny"),("X-XSS-Protection","1; mode=block"),("Content-Type","text/plain; charset=utf-8"),("Via","1.1 varnish (Varnish/6.0)"),("X-GitHub-Request-Id","C1A6:69BF:1CFF84:261BEF:5F4FE887"),("Accept-Ranges","bytes"),("Date","Wed, 02 Sep 2020 18:46:31 GMT"),("Via","1.1 varnish"),("X-Served-By","cache-pao17436-PAO"),("X-Cache","HFM, MISS"),("X-Cache-Hits","0, 0"),("X-Timer","S1599072391.097357,VS0,VE154"),("Var
11:49:37 <electricityZZZZ> y","Authorization,Accept-Encoding"),("Access-Control-Allow-Origin","*"),("X-Fastly-Request-ID","402b2cd2b4c717fb982dfc63b0e3f1a47fe08b39"),("Expires","Wed, 02 Sep 2020 18:51:31 GMT"),("Source-Age","0")], responseBody = (), responseCookieJar = CJ {expose = []}, responseClose' = ResponseClose})
11:49:43 <electricityZZZZ> oops sorry for the multiline
11:49:54 <maerwald> thank you for using a pastebin
11:50:38 <electricityZZZZ> https://pastebin.com/2UivRFzw 
11:50:53 <geekosaur> it's failing to find an lts version to install a ghc for, for some reason
11:51:17 <maerwald> I think this is a common issue with some amazon routing? Not the first time I see this
11:51:24 <sm[m]> electricityZZZZ: network trouble ? I installed that lts recently
11:51:26 <electricityZZZZ> i'm just on an up to date install of ubuntu 20.04, with stack installed with apt,... should be pretty ordinary/work
11:51:33 <electricityZZZZ> i can run some kind of test if you want
11:52:22 * tomsmeding hasn't seen that build-plan folder before, but perhaps I don't know how stack works then
11:53:06 <electricityZZZZ> i also tried stack new foo and got the same error
11:53:33 <sm[m]> what's stack --version ?
11:54:51 <sm[m]> I think the download locations changed in 2.3.1. "stack upgrade" would install the latest
11:56:10 <geekosaur> but will install it off of $PATH
11:58:11 <tomsmeding> depending on where stack is currently located :)
11:58:47 <geekosaur> they said they're using the one installed by ubuntu, so /usr/bin
12:00:03 <tomsmeding> ah yes
12:05:28 <tomsmeding> there is no way to add a guard to a pattern synonym, is there?
12:06:14 <tomsmeding> like `pattern Pat value <- x | x + 1 == 10` for example
12:06:15 <electricityZZZZ> https://pastebin.com/NQAMz368
12:06:38 <tomsmeding> eh, better example: `pattern Pat value <- x | x + 1 == value`
12:06:46 <electricityZZZZ> it gives me a warning saying that it's an unsupported build (??) ... should i follow their advice and do a forced stack upgrade?
12:06:59 <glguy> tomsmeding: You can achieve the result using ViewPatterns alongside
12:08:01 <tomsmeding> electricityZZZZ: I think a normal, unforced upgrade (`stack upgrade`) will work fine, though it will put the new version in ~/.local/bin/stack
12:08:03 <glguy> let test f x = if f x then Just x else Nothing 
12:08:06 <glguy> pattern Even x <- (test even -> Just x)
12:08:22 <tomsmeding> right
12:16:57 <tomsmeding> ah so what I _really_ wanted is OverloadedStrings, because I wanted to match ByteStrings with literal strings; I didn't know that OverloadedStrings does that: "If used in a pattern the literal will be replaced by an equality test, in the same way as an integer literal is."
12:18:46 <electricityZZZZ> ok the upgrade worked
12:19:01 <tomsmeding> nice! does it work now?
12:21:25 <electricityZZZZ> the upgrade worked (albeit with sudo, which made me a bit uncomfortable) and now the ghci interpreter works when i run stack ghci (after it performs an installation)
12:21:48 <tomsmeding> what did you need sudo for?
12:21:51 <tomsmeding> to replace the old stack?
12:22:12 <tomsmeding> I thought 'stack upgrade' didn't need sudo by itself
12:22:47 <electricityZZZZ> yeah to replace the old stack
12:23:45 <tomsmeding> you don't need to replace the old stack in /usr/bin -- in fact, perhaps you shouldn't, because now your new stack can be overwritten by apt when it feels like it :)
12:24:07 <tomsmeding> generally a better option is to put ~/.local/bin, where it puts the new version I believe, in your PATH
12:27:06 <electricityZZZZ> i shouldn't have to manage these concerns
12:27:21 <tomsmeding> indeed, ubuntu should install recent packages ;)
12:27:30 <tomsmeding> but I agree that this should be easier
12:28:23 * geekosaur thinks stack handles this poorly, and not only because it vomited up a chunk of json instead of saying "can't download LTS"
12:28:23 <tomsmeding> people are so used to haskell tooling being difficult that "only having to modify your PATH" is considered trivial
12:28:35 <tomsmeding> heh I agree geekosaur 
12:29:27 <tomsmeding> my point stands though, people are so used to bad tooling that stack looks beautiful and rosy, except when a general user tries it ^ happens
12:29:28 <geekosaur> but the $PATH thing, well, it can't overwrite the system-installed version, that belongs to ubuntu
12:30:05 <tomsmeding> of course this is also partially ubuntu's fault; ubuntu's (and debian's) old packages have tripped me up so often that I'm on arch
12:30:37 <geekosaur> arch has its own haskell issues, though
12:30:42 <tomsmeding> ghcup doesn't :)
12:30:46 <dolio> Why is having the standard home directory install location in your path ugly?
12:30:54 <tomsmeding> it isn't
12:31:00 <tomsmeding> but it isn't a one-click install
12:31:06 <xsperry> IMO haskell isn't any worse than average tools, regardless of the language, for programming in *nix environment
12:31:35 <tomsmeding> well generally 'apt install $languagething' works, but apparently here it didn't
12:31:58 <tomsmeding> of course because ubuntu versions, which is not really haskell's fault
12:32:14 <xsperry> editor + CLI, or editor in CLI, seems to be how most people do programming in *nix. there's something like VS around, completely integrated, for most languages
12:32:24 <xsperry> there isn't*
12:33:08 <tomsmeding> perhaps it would be nice for stack to issue a minor version upgrade to the series that ubuntu is on, to use the new LTS url's?
12:33:17 <tomsmeding> I don't know if "fixing" it would be that easy
12:34:12 <tomsmeding> electricityZZZZ: same as I said before, but formulated differently: "I agree that you shouldn't have to manage these concerns, but the reality is that you have to"
12:35:52 <electricityZZZZ> i hate to compare haskell to rust but the only (small) issues i have encountered with rust tooling/cargo have been missing C/C++ dependencies
12:36:47 <electricityZZZZ> and nearly always that has been merely the dependency not being installed or a missing path/env var
12:37:09 <maerwald> Rust community is also less scattered 
12:37:26 <geekosaur> stack is not actually standard haskell tooling comparable to cargo, though
12:37:53 <geekosaur> it's a third party thing, and they changed things incompatibly at some point and broke older versions
12:40:18 <electricityZZZZ> i would be really happy if the haskell community developed a new haskell-based language designed to pair with rust in the same way that people often use python and C++ together
12:44:22 <phadej> "hold my bear"
12:44:24 <phadej> beer
12:45:01 <MarcelineVQ> who's gonna hold the bear then?
12:45:16 <monochrom> I cannot interpret that "haskell-based" in any other way than "merely haskell-like syntax".
12:45:20 <phadej> bears are self sufficient :)
12:45:25 <hekkaidekapus> Bear with the beer.
12:45:39 <monochrom> The disagreement between Haskell and Rust is fundamentally semantic.
12:45:42 <phadej> there's beer brand in finland, which name is "bear"
12:46:03 <monochrom> I know because I made the mistake of "let me learn Rust by implementing immutable cons lists and binary trees!"
12:46:15 <phadej> monochrom: there could be RustFFI
12:46:20 <monochrom> Ownership got into the way.
12:46:27 <dminuoso> I thought Rust had an unstable ABI
12:46:28 <phadej> but I don't know if it would make any sense
12:47:30 <electricityZZZZ> haha lists yeah,... so the magical haskell++ language i want would really, profoundly de-emphasize lists
12:47:50 <monochrom> No, list is just an example.
12:47:52 <phadej> dminuoso: https://internals.rust-lang.org/t/a-stable-modular-abi-for-rust/12347 seems so
12:48:04 <phadej> why people are so keen in changing language X to be like Y
12:48:07 <monochrom> It's the same problem with binary trees.  Are you also going to de-emphasize binary trees?
12:48:07 <phadej> why not just use Y
12:48:11 <dolio> How would that be an improvement?
12:48:23 <monochrom> If you do that, I'm just going to think up another ADT you haven't thought of.
12:48:43 <monochrom> Are you going to de-emphasize all ADT then?
12:48:56 <electricityZZZZ> monochrom: wait really? whats wrong with binary trees? should they be n-ary...?
12:49:03 <dminuoso> But indeed, trying to copy idiomatic-in-language-a to language-b, when starting language-b is usually a mistake.
12:49:06 <monochrom> Because when that happens, there is no point doing FFI between Haskell and Rust.
12:49:21 <monochrom> <monochrom> Ownership got into the way.
12:50:09 <dolio> I would think that the FFI wouldn't just unify ADTs in the two languages. That's way too much to hope for.
12:50:13 <monochrom> There are two ways you can understand what I am saying.
12:50:19 <dminuoso> electricityZZZZ: Curious though, why would you want to de-emphasize lists?
12:50:36 <dminuoso> What issue do you have with them?
12:50:51 <monochrom> One is you walk my path. Hand-code linked list or binary tree or any 2nd-year CS pointer-heavy data structure in Rust.
12:51:33 <monochrom> Another way is read the Rust standard library source code for how it implements those, and discover that it has to cheat, use backdoors to get around ownership.
12:51:35 <electricityZZZZ> you can find some discussion of the fact (i think snoyman writes about this somewhere?) that lists are nearly never useful or necessary
12:51:56 <monochrom> Yes we have heard snoyman's strawman argument.
12:52:14 <dminuoso> electricityZZZZ: Do you have a link handy?
12:52:18 <dminuoso> Because I do not know that article.
12:52:25 <monochrom> He's criticizing list as a data structure. We already know that list is a terrible data structure.
12:52:29 <geekosaur> lists are often (not always) not useful as a data structure. what they are, are functional loops.
12:53:05 <monochrom> We use list as a control flow structure. (what geekosaur said.)  That one is fine, and snoyman's argument is irrelevant to our use case.
12:53:06 <electricityZZZZ> diminuso: one discussion can be found in the Public Service Announcement section here https://rust-unofficial.github.io/too-many-lists/
12:53:23 <geekosaur> this has buried in it why mixing haskell and rust won't work very well.
12:53:27 <monochrom> Beginners use list as a data structure, even assuming random access. snoyman can talk to them.
12:53:45 <dolio> I don't know. I still use lists as a data structure a lot.
12:54:04 <monochrom> Well yeah me too when the length is like merely 300.
12:54:08 <dminuoso> electricityZZZZ: Hold on. Are you trying to make an argument about Haskell using some Rust book?
12:54:13 <dminuoso> That seems.. weird.
12:54:54 <geekosaur> they said something about wanting a haskell dialect that played well with rust
12:54:55 <dolio> Like, I want effectively a stack of things a lot.
12:55:03 <electricityZZZZ> hey i am an amateur programmer so if lists are really important and frequently necessary/useful then please correct my viewpoint
12:55:05 <dminuoso> Speaking of list, maybe things would be profoundly better if base used backpack, so you could switch out [] with Vector and String with Text...
12:55:14 <dolio> And using Seq for that or something is just a pessimization.
12:56:03 <electricityZZZZ> dminuso: being generic over list/Vector would be interesting/nice
12:56:06 <dolio> I want Vector much less often.
12:56:23 <dminuoso> Well, since I propose backpack, you could pick whatever underlying type you wanted!
12:56:35 <dminuoso> As long as you can match the signature
12:56:38 <dolio> I already do, and don't need backpack.
12:56:43 <dminuoso> I meant for base
12:58:10 <dminuoso> electricityZZZZ: Anyhow. Lists are a pretty good control flow structure in Haskell. Im confident any criticism you may have heard of singly linked lists are more about using them for data storage.
12:59:10 <monochrom> Python list comprehension is from Haskell.
12:59:22 <dolio> Parameterizing over choice of list vs. vector is going to work out pretty badly in a lot of cases, for the reasons monochrom mentioned.
12:59:28 <electricityZZZZ> diminuso: mind showing a simple example of what you mean by a control flow structure?
12:59:53 <monochrom> And Python later made sure list comprehension is as lazy as possible, that's also from Haskell.  List is a loop control flow structure here.
12:59:58 <dminuoso> % traverse_ putrStr [1..] -- electricityZZZZ 
12:59:58 <yahb> dminuoso: ; <interactive>:215:11: error:; * Variable not in scope: putrStr :: a0 -> f b0; * Perhaps you meant one of these: `BSL.putStr' (imported from Data.ByteString.Lazy), `BS.putStr' (imported from Data.ByteString), `putStr' (imported from Prelude)
13:00:09 <chreekat[m]> Probably part of the problem is that as a new programmer in any language, pretty much the first structure you learn after int is the list. They even have similar syntax, which is really anchoring. But `[1,2,3]` is something completely different between Haskell and C. 
13:00:19 <dolio> The good operations are different on each, so you need to implement things according to which choice is made to have good performance.
13:00:23 <dminuoso> % traverse_ (putStr . show) [1..] -- electricityZZZZ
13:00:29 <yahb> dminuoso: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691
13:00:46 <dminuoso> electricityZZZZ: In some sense, lists give us loops as a simple first class value.
13:01:06 <monochrom> So if someone attacks Haskell lists, lets hear them attack Python list comprehension and generators first, see if the argument holds any water.
13:01:20 <electricityZZZZ> dminuso: okay that is interesting, a loop as a first class value
13:04:44 <geekosaur> now you're getting at the essence of functional programming
13:17:45 <hekkaidekapus> Now that the lists are covered, let’s go back to bears or any other vertebrates :P There is a thread going on over ghc-devs about whether GHC should have a totem inspired by cats, turtles, octopuses, … The list discussion above fit in with turtles…
13:21:47 <ystael> hekkaidekapus: a lambda looks more like a perching passerine bird than any of those, no?
13:22:42 <hekkaidekapus> The argument for a turtle was very compelling.
13:23:11 <hekkaidekapus> ystael: https://mail.haskell.org/pipermail/ghc-devs/2020-September/019212.html
13:24:39 <jollygood2> > show [1..]
13:24:42 <lambdabot>  "[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
13:30:29 <merijn> Also, linked lists in C and C++ are still fairly common and even Java has a linkedlist in the library, so the idea that linked lists are all bad is just dumb anyway
13:31:01 <merijn> They're a very specific datatype with some very specific uses that just happen to be doubly good in a lazy setting where they can be infinite
13:31:30 <merijn> chreekat[m]: for one [1,2,3] is a syntax error in C ;)
13:32:10 <dminuoso> I think in part what makes lists so enjoyable in Haskell, is because of lazyness and the semantics of the language, it's very comfortable to *generate* them.
13:32:18 <merijn> honestly, Python/JS are the only languages that muddy things by calling things lists that are different from what is classically called lists
13:32:47 <chreekat[m]> merijn: I guess it's been too long for me :)
13:37:25 <dolio> I'm not sure 'list' always meant linked list specifically in most contexts.
13:37:45 <dolio> If you don't specify the 'linked' part.
13:37:45 <chreekat[m]> Wikipedia claims that a list represents a countable number of ordered values; i.e. it is a more abstract concept without a given implementation. I don't know I'd die on that hill, but I do suspect it isn't so clear cut
13:38:57 <hseg> Is it possible to define a default instance for a data family and have a followup instance refine it? e.g. my toy unit group example: given data Loc a m = a :% m, newtype instance (Unit a m) = ULoc (Unit a, m, m), can I define newtype instance (Unit a (Sum Int)) = (Unit a, Sum Int) ?
13:39:10 <merijn> dolio: I'm not saying it *always* is
13:39:27 <merijn> dolio: I'm just saying it very commonly is
13:39:57 <electricityZZZZ> "still fairly common" does not imply that it is not the case that linked lists are not bad...
13:40:00 <merijn> dolio: Java also has ArrayList, for one, but the fact that both exists shows that having linked lists isn't some "weird"/"stupid" functional haskell thing
13:40:11 <hseg> (idea being that for any abelian monoid, we can define the free abelian group containing it, but sometimes that group has a more compact representation which we want to take advantage of)
13:40:41 <merijn> electricityZZZZ: They aren't bad. They're a tool in the toolbox. And like every tool they're good for some things and bad for others
13:40:44 <dolio> Linked lists aren't bad.
13:40:44 <electricityZZZZ> anyway, i am an amateur and maybe i chose a bad job by suggesting that haskell++ de-emphasize list as a data type,
13:40:59 <hseg> ... so basically i'm asking to be able to write newtype instance Gp m = Groth (m, m); newtype instance Gp (Sum a) = IdSum (Sum a)
13:41:43 <electricityZZZZ> however i think the point remains that a high level language designed for rust interop would be really profoundly nice
13:42:19 <merijn> electricityZZZZ: What would rust interop look like?
13:43:31 <electricityZZZZ> my understanding of haskell is superficial to the point of nearly being nonexistent, so i only understand superficial things,... that being said, using the Ok and Err nomenclature (rather than left and right) for Result return types,
13:43:40 <electricityZZZZ> probably using cargo as the package manager
13:44:06 <merijn> electricityZZZZ: The thing is that, generally there's only one mode of interoperability between languages. The C ABI
13:44:18 <electricityZZZZ> sharing the same stdlib as rust to the greatest extent possible, within reason
13:44:22 <merijn> I don't think Rust defines a stable/portable ABI, so it'd be incredibly hard to do anything else
13:44:43 <merijn> Not to mention that if you wanna include ownership you're basically just forced to reimplement rust
13:45:11 <dminuoso> Rust FFI would probably be lack luster since ownership couldn't sensibly make sense across an FFI barrier.
13:45:11 <electricityZZZZ> by include ownership do you mean "talk to rust regarding the ownership of variables"?
13:45:52 <merijn> Well, if you don't track ownership than your, essentially, limited to the C ABI anyway
13:45:56 <hseg> :( "Conflicting family instance declarations" etc
13:46:03 <electricityZZZZ> i dont even know, ownership is managed at compile time right? is there a runtime aspect?
13:46:29 <merijn> electricityZZZZ: Yeah, but the compiler of the language talking to RUst needs to reimplement ownership
13:46:40 <merijn> electricityZZZZ: How else could you call any rust function that tracks ownership?
13:47:00 <electricityZZZZ> that's fine, so it might need to be part of the rust compiler or something
13:47:17 <dminuoso> So what you're saying is..
13:47:25 <dminuoso> you want to ffi from rust to rust?
13:47:29 <electricityZZZZ> lol
13:47:44 <merijn> electricityZZZZ: But Haskell doesn't have ownership
13:47:54 <merijn> electricityZZZZ: So there is no ownership for the rust compiler to know about haskell
13:47:59 <merijn> Unless you first implement it
13:48:12 <merijn> This is the problem with everyone's idea of "we should make a high level FFI to X!"
13:48:16 <dminuoso> And even if it had, to make sense of ownership, the implementation would have to understand the semantics of both languages to implement a cross-ffi burrow checker.
13:48:31 <merijn> You either end up extending Y to the point of containing a full X implementation, or you get the C ABI
13:48:56 <dminuoso> *or JVM compatibility if you're in Java lands.
13:50:00 <hseg> :((( and DerivingVia doesn't work for data families
13:52:58 <electricityZZZZ> hm well i came across this (don't expect me to understand more than the title) http://web.engr.oregonstate.edu/~walkiner/student-theses/mcgirr-18-ms-project.pdf
13:54:00 <hseg> to illustrate what I'm after: http://ix.io/2vZm
13:54:31 <electricityZZZZ> hseq: lol the site icon is mr rickroll
13:54:41 <monochrom> Ship of Theseus of programming languages.
13:55:20 <Cale> electricityZZZZ: While I sort of agree that lists were used a little more than they ought to have been in Haskell's earlier history, it's also important to understand that lists are popular in a lazy pure functional setting for the exact same reasons that loops are popular in general.
13:55:45 <hseg> (in particular, idea is that given a monoid action known to act invertibly, we can extend it to a group action)
13:56:06 <Cale> A loop either doesn't occur, or consists of an iteration followed by another loop, just as a list either is empty or consists of a single element followed by another list.
13:56:10 <electricityZZZZ> another angle on this is that i saw that linear haskell has arrived, and i was thinking gosh how long will it take for the standard library to be "practically fully linearized"
13:56:21 <Cale> So lists are like the data structure equivalent of loops
13:56:30 <merijn> electricityZZZZ: Hopefully forever, tbh
13:56:40 <dolio> Why would the whole standard library be linearized?
13:56:43 <Cale> I hope Linear Haskell just withers away and is eventually removed from GHC
13:56:47 <merijn> electricityZZZZ: I would not be overly optimistic about the usability of linear types, tbh
13:57:03 <electricityZZZZ> wow, interesting, why the negative sentiment? anything a noob can understand?
13:57:09 <merijn> Linear types are great, but retrofitting them into Haskell...not so much
13:57:21 <Cale> It's a complicated extension that isn't especially practical.
13:57:28 <electricityZZZZ> merijn: right! that's why i'm saying that it's interesting to consider a new language
13:57:35 <merijn> electricityZZZZ: Because haskell wasn't designed around linear types, so it will be incompatible with everything and introduce complications in lots of stuff where it's not needed
13:57:50 <electricityZZZZ> haskell works so people are satisfied enough that they won't rebuild core components
13:58:06 <merijn> electricityZZZZ: It's not about "won't rebuild core components"
13:58:20 <merijn> electricityZZZZ: You can drop a super complex type extension in the middle without affecting *everything*
13:58:23 <electricityZZZZ> merijn: i am more interested in whether fundamental design choices are good rather than what is backwards compatible or has inertia etc
13:58:32 <electricityZZZZ> merijn: yeah, that's why it's called haskell++ :)
13:58:47 <merijn> electricityZZZZ: There's tons of "Haskell++" developments
13:58:50 <monochrom> Multiple good design choices are in conflict.
13:59:28 <monochrom> If you resolve the conflict one way, someone will wish to resolve it the other way.
13:59:43 <monochrom> They will speak like "I want a language like yours but..."
13:59:43 <dolio> Why is "haskell++" an utterly different language with almost no similarity to Haskell?
13:59:56 <monochrom> There is no end to this. But you can choose to stop this or start this.
14:00:17 <Cale> Basically the examples people have given thus far for how linear haskell might be useful have all fallen into two categories: moderately cutesy stuff which basically does what we could already do with the ST monad, but with lambda-ish syntax, and stuff which uses linear types to ensure the deallocation of resources in an imperative-like setting, at the cost of no longer being able to handle exceptions.
14:00:39 <dminuoso> electricityZZZZ: So in my opinion, it's easy. If you have some great ideas how to change haskell as a modification, make a GHC proposal. If you want to create a new language, go ahead and create it!
14:00:41 <Cale> and the stuff in the first category involves using unsafePerformIO a bunch in its implementation
14:01:35 <dminuoso> However, an armchair discussion about some very vague ideas of how to change the language, when you barely even know the language, does not seem very useful.
14:02:17 <Cale> I'm personally worried that linear Haskell will lead to a bunch of libraries getting cluttered with linearised versions of things so that people playing around with Linear Haskell can use them, while nobody has yet come up with any really convincing examples of how to use the thing practically.
14:03:58 <electricityZZZZ> dminuso: i've learned a couple of useful things from this discussion (1) lists should be a first class citizen in programming languages as a way of managing control flow, and (2) linear haskell is potentially/probably overhyped
14:04:28 <dminuoso> electricityZZZZ: Careful, I dont think anyone proposed that lists *should* be a first class citizen.
14:04:38 <Cale> It's a really good way to create traps for new players as well. For example, in the paper introducing Linear Haskell, there's an example of a socket library which uses linear types to make sure that sockets get closed appropriately. That's great, but if that library were on hackage and someone actually tried to use it, they might get pissed off when they found out that (a) they can no longer make their server 
14:04:39 <Cale> concurrent and (b) they can no longer handle exceptions without closing all the sockets
14:05:06 <electricityZZZZ> basically i want the haskell and rust community to have a baby
14:05:17 <dminuoso> electricityZZZZ: I just made the case that they are useful in Haskell. Whether or not other languages should adopt this style is another discussion. From experience, trying to port single ideas from language into another is often complicated and not helpful.
14:05:22 <Cale> and the worst part is that it wouldn't be obvious to a beginner that these things were impossible (it apparently wasn't obvious to the authors of the paper)
14:05:33 <dolio> (Linked) lists are useful in almost every language.
14:05:42 <dolio> They're just not the only useful thing.
14:06:00 <dolio> Or useful for everything.
14:06:04 <monochrom> dminuoso: I think you did. The exact wording was "In some sense, lists give us loops as a simple first class value."
14:06:23 <dminuoso> monochrom: That's not the same as saying "every language should adopt this"
14:06:26 <monochrom> Oh, other languages, OK yeah they have different priorities.
14:06:31 <Cale> and so they might fight with the typechecker a bunch, and find out that actually, it's the features of the language and libraries themselves that are in their way, not just their own misunderstanding of how to use it
14:07:29 <Cale> Generally, Haskell has been a language that's difficult for beginners only because it's conceptually different from most others. Typically once you're through the confusion, it becomes an excellent tool.
14:07:35 <dminuoso> Cale: Couldn't that line of reasoning be applied to any non-Haskell 2010 package? I mean the second you flip on extensions, you're gonna create friction with newcomers.
14:07:41 <monochrom> Anyway I thought this discussion would logically stop once the proposer understood the logical consequence of "I'm an amateur".
14:07:49 <dminuoso> Some extensions have less of an impact, but others are quite a battering ram.
14:08:01 <Cale> dminuoso: Most of the extensions actually serve practical purposes other than making it impossible to write any useful program
14:08:07 <electricityZZZZ> for me, so far, quitting when i encounter a wart has been the largest barrier
14:08:10 <dminuoso> (Im thinking of servant, where using it requires you to flip on a dozen extensions just to get started)
14:08:18 <Cale> dminuoso: (see my example with the socket library)
14:08:47 <Cale> Like, it takes work to understand GADTs, but there are actually cool things you can do with GADTs
14:09:10 <Cale> that would be challenging or impossible to accomplish otherwise
14:11:00 <electricityZZZZ> wow okay, here is a wart right now which is tempting me to quit. i'm working my way through brendan fong's textbook, and it has the simple example of defining a function by let de-space = concat . words
14:11:28 <monochrom> What wart.
14:11:33 <Cale> de-space isn't a valid name
14:11:41 <electricityZZZZ> ghci allows me to define de-space like that, but then when i try to call it it seems to think that the minus symbol is not part of the name
14:11:42 <Cale> So you're defining (-) there if you write that
14:11:52 <merijn> electricityZZZZ: No
14:12:00 <merijn> electricityZZZZ: You're defining a binary function - there
14:12:07 <Cale> (-) is the name of the thing being defined and de and space are its parameters
14:12:16 <monochrom> Never heard of Brendan Fong anyway.
14:12:16 <electricityZZZZ> http://brendanfong.com/programmingcats_files/cats4progs-DRAFT.pdf you can see it on page 2    lol what is an mit class doing screwing up a function name definition
14:12:32 <Cale> I dunno, it is a draft :P
14:12:39 <Cale> But that is a pretty silly mistake
14:13:32 <monochrom> On page 2 I only see "let countwords = length . words"
14:13:54 * dminuoso idly ponders about why a newcomer to Haskell is starting with programming with categories.
14:13:57 <electricityZZZZ> page 14 labeled as page 2
14:14:24 <Cale> Examples of categories?
14:14:51 <monochrom> You know what I text-searched for "de-space" there is none.
14:15:22 <electricityZZZZ> it's on the second page of chapter 1 at the top, i swear
14:15:34 <Cale> electricityZZZZ: I don't see de-space being defined there
14:15:42 <Cale> Are we looking at the same PDF?
14:15:48 <electricityZZZZ> http://brendanfong.com/programmingcats_files/cats4progs-DRAFT.pdf
14:15:52 <monochrom> I text-searched for "concat . words" and there is only one, "Prelude> (concat . words) "Hello world!"
14:16:03 <Cale> yeah, that's what I've got there
14:16:29 <boxscape> hm could you post a screenshot electricityZZZZ ?
14:16:41 <electricityZZZZ> you can search for this text:      define new functions by composing existing functions
14:16:55 <monochrom> Prelude> let countwords = length . words
14:17:03 <monochrom> what de-space?
14:17:19 <electricityZZZZ> i will reload the PDF maybe he changed it in the past hour
14:17:23 <monochrom> This means I already got the correct page the 1st time.
14:17:34 <electricityZZZZ> lol yeah he changed it :)
14:18:21 <Cale> Maybe he's a scheme programmer, they like to use hyphens in their names, and scheme is popular at MIT
14:19:03 <electricityZZZZ> why category theory? tbh i have no idea i just wanted to write a little bit of haskell which did interesting things with abstraction and was hoping this would get me there quickly
14:19:25 <Cale> Honestly, category theory is not required in any way to be a competent Haskell programmer
14:19:28 <merijn> electricityZZZZ: category theory is the super slow and confusing way of getting there
14:20:09 <electricityZZZZ> i don't carry the misconception that category theory is a dependency for haskell
14:20:32 <Cale> But if you're interested in not only Haskell and computer science, but a bunch of other branches of mathematics as well, category theory eventually saves you effort, and gives you a toolbox of generalised definitions and ways of thinking which can be applied to start getting traction in new areas of study.
14:21:31 <Cale> It's a valuable thing, and Haskell's design owes a lot to it, but as a route to learning directly, it's quite circuitous.
14:21:31 <merijn> electricityZZZZ: It's not just that it's not a dependency, it's also that it's not particularly helpful until you're already at expert level Haskell anyway :)
14:22:01 <electricityZZZZ> yeah so maybe i will run into trouble in a chapter and then bail
14:23:29 <monochrom> You should have not started with this book in the first place, unless you yourself are interested in both haskell and category theory.
14:23:39 <electricityZZZZ> so i already have a useful question (i think) which is motivated by what i've seen:
14:23:42 <monochrom> There are like a ton of better starting points for Haskell.
14:23:52 <electricityZZZZ> is the entirety of a haskell program a collection of type definitions and function definitions?
14:24:16 <Cale> electricityZZZZ: and definitions of other sorts of values, type classes, instances of classes, ...
14:24:22 <electricityZZZZ> (excluding weird stuff like maybe some C dependency)
14:24:47 <merijn> electricityZZZZ: Yes, no, maybe? Define "entirety"?
14:24:47 <Cale> But... sure, mostly it's definitions of data types and definitions of functions and other values
14:24:56 <electricityZZZZ> right a typeclass would be a constraint on a type, which i would put in the type category
14:25:18 <electricityZZZZ> "other sorts of value" -- care to clarify, and "instance of class" -- by this you just mean a type definition which implements a typeclass right?
14:25:25 <Cale> Well, not all values are functions
14:25:43 <monochrom> I think I want to know: Is it important to know right now, as opposed to later?
14:25:43 <Cale> For example, your program pretty much has to contain a definition of main, which isn't a function
14:25:51 <Cale> (it's an IO action)
14:26:11 <Cale> Functions are values of type A -> B for various types A and B
14:26:25 <Cale> But there are plenty of things whose types don't fit that description
14:26:48 <electricityZZZZ> ok so we have types, type constraints, functions, and then functions which interact with IO?
14:27:03 <Cale> Functions must have a parameter
14:27:05 <dmwit> There are many types which are not functions.
14:27:06 <merijn> electricityZZZZ: Well, we also have... Int? Bool?
14:27:08 <dmwit> Int, for example
14:27:16 <merijn> dmwit: Too slow!
14:27:24 <dmwit> And you, the programmer, get to define new ones any time you like.
14:27:26 <Cale> There are things like parsers
14:27:38 <Cale> You can define your own new data types and define constants of those types
14:27:51 <dmwit> x :: Card; x = Ten `Of` Hearts -- x is not a function and not IO and not Int
14:28:00 <electricityZZZZ> okay so when i say functions there, i am including the function signature definition, but i guess you might consider that a type, or maybe something else entirely...?
14:28:39 <Cale> Not all values are functions
14:28:49 <Cale> You can define values which are not functions as well
14:29:10 <electricityZZZZ> "constants of those types" -- this sounds like a constraint on the values the type can take on?
14:29:12 <Cale> twentyFive = 25
14:29:19 <Cale> This is a valid definition
14:29:32 <Cale> We can give it a type signature like
14:29:37 <Cale> twentyFive :: Integer
14:29:45 <Cale> to make it clearer that we're not defining a function
14:29:55 <dmwit> There are the following kinds of declarations: module declarations, imports, data (and newtype) declarations, type alias declarations, class declarations, instance declarations, type signatures, definitions.
14:30:28 <Cale> There are also default declarations, and fixity declarations, but those see rarer use.
14:30:32 <electricityZZZZ> "definitions" means function definition?
14:30:37 <dmwit> Cale: Yes, thank you!
14:30:55 <dmwit> electricityZZZZ: It includes function definitions. It also includes the definitions of values that are not functions.
14:31:03 <Cale> definitions break down into function bindings and pattern bindings
14:31:14 <dmwit> electricityZZZZ: You keep making this mistake. If I write `x = 3`, that is not a function definition.
14:31:23 <Cale> Function bindings are those things which involve arguments explicitly, like
14:31:26 <Cale> f x y = ...
14:31:36 <electricityZZZZ> dmwit: yeah i'm calling that a "value constraint"
14:31:39 <Cale> Pattern bindings don't have parameters:
14:31:40 <Cale> foo = ...
14:31:48 <merijn> electricityZZZZ: wut
14:31:49 <Cale> and they may match a pattern:
14:31:51 <Cale> (x,y) = ...
14:31:54 <merijn> electricityZZZZ: You probably wanna read: http://conal.net/blog/posts/everything-is-a-function-in-haskell
14:32:28 <Cale> (this last one defines both x and y, by pattern matching on the right hand side)
14:33:07 <dmwit> electricityZZZZ: As far as I can tell, nobody has used the phrase "value constraint" in this channel since 2019.
14:33:19 <dmwit> (...and it wasn't you, even then.)
14:33:43 <boxscape> dmwit do you have a way to quickly search through #haskell logs?
14:33:56 <dmwit> grep, vim
14:33:57 <merijn> boxscape: grep :p
14:34:07 <dmwit> merijn: Too slow!
14:34:10 <boxscape> hm that makes sense
14:34:20 <Cale> There used to be ircbrowse
14:34:23 <Cale> but that went down
14:34:29 <electricityZZZZ> so this IO action thing is "not a function" or am i opening a can of worms
14:34:34 <Cale> Correct
14:34:52 <electricityZZZZ> are there other non-IO things which are "not a function" but a noob like me might consider to be a function?
14:34:57 <jollygood2> String -> IO String is a function. IO String is not
14:35:22 <Cale> electricityZZZZ: I'm not sure if you presently consider strings to be functions, but most people wouldn't.
14:35:31 <Cale> (or integers, or boolean values, etc.)
14:35:45 <lucky> electricityZZZZ: in practical terms, the way state-like things are handled in monads is like that 
14:35:55 <dmwit> How about motes from other monads, say, State actions or Reader actions?
14:35:57 <Cale> A value of type IO t is a description of some actions which could be taken, which if they complete, would have a result of type t
14:36:10 <Cale> and those actions are allowed to do any I/O that your computer can do
14:36:17 <Cale> There's no parameter here, so it's not a function
14:36:22 <dmwit> ST actions, etc.
14:36:29 <Cale> It's just a description of some stuff which can be done.
14:37:43 <Cale> The difference between a value of type IO String and a value of type String is like the difference between "/bin/ls" and a listing of the files in your home directory (except I suppose that /bin/ls can take arguments, haha)
14:38:00 <electricityZZZZ> lucky: thanks for that :) so an action is a function-like thing which manipulates a state-like thing?
14:38:10 <Cale> Well, IO actions are allowed to look at the command line arguments the program was run with anyway ;)
14:38:10 <dolio> No.
14:38:22 <dolio> It is not specified how IO is implemented.
14:38:35 <electricityZZZZ> lol ok
14:38:40 <Cale> I could give you an example of how IO might be implemented as a data structure if you like
14:38:51 <Cale> If you understand data declarations already
14:39:13 <Cale> The *actual* implementation in GHC uses low-level hackery
14:39:31 <Cale> But this low-level hackery is possible to avoid
14:39:59 <Cale> (it's just convenient for GHC's implementation to be able to optimise IO actions the same way as other code)
14:40:51 <electricityZZZZ> forgive me if this is too basic a question... i think of a function in a mathematical sense as any deterministic mapping,... is a function which manipulates IO *itself* nondeterministic (rather than the underlying input io values or io outputs)?
14:41:12 <Cale> Functions which produce IO actions generally are entirely deterministic
14:41:22 <Cale> For example, putStrLn :: String -> IO ()
14:41:23 <electricityZZZZ> so then why not call them functions
14:41:32 <jollygood2> Cale, I'd be interested in seeing that, I had a link to something similar, implementing a subset of IO as a data type, allowing just interacting with stdin/stdout, but I lost it
14:41:32 <Cale> if you give it the same string, it will give you the same action each time
14:41:44 <hpc> electricityZZZZ: the functions are functions, the actions produced are not functions :P
14:41:56 <Cale> But the IO actions themselves, may do something different each time they are executed
14:41:57 <hpc> putStrLn is a function, getLine is not
14:42:23 <Cale> Evaluating putStrLn "hello" causes your computer to warm up a little bit and not much else
14:42:26 <dminuoso> electricityZZZZ: Much of the confusion relating to "functions and actions" is that other languages have twisted the meaning of the word "function" to mean something else. In Haskell we use the term function in the mathematical sense.
14:42:38 <Cale> Executing the result of that evaluation is what prints "hello" on the screen
14:42:38 <dminuoso> In C it is a routine, a sequence of actions.
14:43:08 <Cale> So, let's define a data type for terminal IO
14:43:28 <dolio> C has plenty of things that aren't functions as well.
14:43:38 <dolio> Like many of the examples given above.
14:43:44 <Cale> data TermIO a = Done a | PutLine String (TermIO a) | GetLine (String -> TermIO a)
14:43:55 <Cale> Here, we have a type with three data constructors
14:44:13 <Cale> Done v is the action which does nothing, and produces v as its result
14:44:39 <Cale> PutLine s x is the action which starts by printing s to the terminal, and continues by doing whatever the action x says to do
14:44:59 <dminuoso> electricityZZZZ: So really, when Haskellers use the term function, they mean something different from what your average pythonista might mean when they say the word.
14:45:15 <Cale> GetLine f is the action which reads a line of text from the user, and then applies the function f to that string in order to determine what action should be performed next
14:45:56 <Cale> Of course, nothing gives them this interepretation in the code yet -- all we've done is define an inert data structure
14:46:33 <Cale> In order to give the values of this type their interpretation, we can write a function which translates a value of type TermIO a into a value of type IO a
14:46:43 <Cale> execute :: TermIO a -> IO a
14:46:49 <Cale> execute (Done v) = return v
14:47:05 <Cale> execute (PutLine s x) = do putStrLn s; execute x
14:47:21 <Cale> execute (GetLine f) = do s <- getLine; execute (f s)
14:48:52 <electricityZZZZ> okay but in all of this functions are deterministic mappings,...
14:48:53 <Cale> You can imagine that something structurally similar to this procedure, but which executes IO actions, exists as part of the low level Haskell runtime system -- pattern matching on IO actions, and carrying out the instructions they describe. That's not how it actually works, but it's a possible implementation and a reasonable mental model.
14:49:00 <Cale> yes
14:49:22 <Cale> All the actual functions, the things of type A -> B, produce the same value of type B whenever you give them the same value of type A
14:49:32 <Cale> and they do nothing else
14:50:02 <Cale> At *some* level, we need a thing which takes IO actions, and *actually* carries out the steps they describe
14:50:08 <Cale> and that won't really be a function
14:50:17 <Cale> but some lower-level procedure
14:51:00 <Cale> But it'll have a similar structure to this function which interprets TermIO actions into IO actions, in that it will pattern match on IO actions, and decide what steps to take from there
14:52:03 <electricityZZZZ> is an action nondeterministic? it can be right?
14:52:09 <dminuoso> electricityZZZZ: Some `int f(double)` in C is not a function in the same sense. The reason is, it doesn't just compute a response, it can interact with the world. It can manipulate memory, make syscalls, etc. So we capture what C calls functions as IO in Haskell. What we call functions doesn't exist in C.
14:52:20 <Cale> In the sense that it will have a different result each time it's executed, yes
14:52:33 <Cale> Not so much in the sense that it will have multiple results at the same moment
14:52:45 <Cale> (there are other monads which exhibit that kind of nondeterminism though)
14:53:09 <Cale> For example, the list monad:
14:53:17 <Cale> > do x <- [1,2,3]; y <- [4,5]; return (x,y)
14:53:19 <lambdabot>  [(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]
14:53:33 <Cale> This constructs the list of all ways of picking x from [1,2,3] and y from [4,5]
14:53:48 <Cale> So it's like x takes all the values of the list [1,2,3] at once
14:54:43 <Cale> (or each in turn, if you prefer)
14:55:16 <Cale> getLine :: IO String is an action whose result will be the line of text that the user types at the terminal, and that's fairly unpredictable
14:55:34 <Cale> There are IO actions which obtain random numbers
14:55:42 <Cale> There are IO actions which read from the network, or disk
14:55:49 <Cale> (or write to them)
14:56:02 <Cale> Basically, IO actions can do anything your computer can do
14:56:12 <electricityZZZZ> right, it's the interface to the physical world
14:56:17 <Cale> yeah
14:56:21 <electricityZZZZ> and arguably you need the physical world for random numbers
14:56:59 <Cale> Yeah, there are pure pseudorandom number generators, but you need to pass the PRNG state around by hand if you use those
14:57:02 <electricityZZZZ> but something being an "action" ,... i guess an "action" is something which is evaluated to produce a value which is not a function?
14:57:19 <dminuoso> electricityZZZZ: Not evaluated, rather executed.
14:57:23 <Cale> I want to make a distinction here between evaluation and execution
14:57:26 <electricityZZZZ> ok, executed
14:57:53 <Cale> Evaluation refers to turning expressions into values (mostly for the purposes of determining which pattern the result matches)
14:57:59 <dminuoso> electricityZZZZ: Think of `data Recipe = Recipe [CookingInstruction]` - evaluating a given recipe and executing it are very different things
14:58:12 <Cale> Execution is the process of carrying out the steps that IO actions describe
14:58:48 <Cale> Yeah, evaluating an IO action just kind of internally figures out which action it is -- puts it into a form where it's ready to be executed
14:59:42 <Cale> since IO is an abstract type, it's hard to visualise this, but for TermIO, it means applying the definitions in the program to an expression until you reach something which looks like Done v or GetLine f or PutLine s x
15:00:36 <electricityZZZZ> oh--are you saying that something introduces recursive evaluation?
15:00:41 * dminuoso likes explaining IO as "list of assembly instructions"
15:00:49 <dminuoso> It's a good first approximation
15:01:11 <Cale> electricityZZZZ: At some level, evaluation occurs because case expressions want to pattern match on things
15:01:20 * hackage stripe-signature 1.0.0.6 - Verification of Stripe webhook signatures  https://hackage.haskell.org/package/stripe-signature-1.0.0.6 (chris_martin)
15:01:25 <Cale> But there are a lot of other things which turn into case expressions before that point :)
15:01:37 <electricityZZZZ> (btw not having complete pattern matching = haskell design wart)
15:02:15 <Cale> Well, you can turn on warnings and you can turn those warnings into errors, but some of the fancy extensions make it hard to decide if a pattern match is complete
15:02:57 <electricityZZZZ> i thought that was some kind of fundamental issue about nonstrict eval by default
15:03:02 <Cale> I think I can mostly recommend using -Wall -- there are some things it warns about which sometimes I think are a bit much
15:03:19 <merijn> Calling something a design wart is easy if you don't have to be the one solving the unsolvable problem
15:03:34 <Cale> It's not about nonstrict evaluation.
15:03:35 <merijn> electricityZZZZ: This has nothing to do with nonstrict, tbh
15:03:45 <merijn> electricityZZZZ: It's basically impossible in a strict language too
15:04:06 <Cale> In the cases where things get hard, it's about the undecidability of whether there are more values of a given type at all
15:04:10 <electricityZZZZ> basically impossible? why? i thought that if you know the type you can just list out what it can be
15:04:10 <dminuoso> Checking for complete pattern matches is this thing that originally looked simple, and turned out to be hard. Then after some grand realizations, it started looking hard.
15:04:19 <John20> Hi, has anyone had any luck with Vscode and the Haskell extension on windows? I've installed it and when I try to use the 'go to definition' command it always says that it can't find it
15:04:23 <merijn> electricityZZZZ: Except you can mix patterns and guards
15:04:31 <merijn> electricityZZZZ: And then you have pattern guards too
15:04:41 <merijn> electricityZZZZ: -Wall already catches everything you can do
15:04:48 <Cale> Oh, yeah, there's also guards, and completeness for those is entirely intractable obviously :D
15:04:50 <electricityZZZZ> interesting ok
15:04:58 <John20> Are there any additional installation steps that I might need to do? My project is stack based, and I've got stack on my path
15:05:02 <Cale> guards are arbitrary boolean conditions on your pattern match
15:05:09 <dminuoso> There's a new approach being designed that will actually give us a fairly good complete pattern match detection.
15:05:18 <Cale> So it's easy to see why it's hard to tell if a set of guards covers everything
15:05:46 <Cale> But yeah, you can sidestep that by always having an "otherwise" guard, or a fall-through pattern match.
15:06:21 <Cale> Sometimes I don't *want* to do the fall-through case though, because I want the warning that the pattern match is incomplete when I add new constructors.
15:11:24 <electricityZZZZ> so actions are "rare" and "typically part of stdlib"?
15:11:46 <electricityZZZZ> i should say, they might be used frequently but they are defined very infrequently?
15:11:57 <glguy> Are you asking about IO actions?
15:12:22 <Cale> Well, a good chunk of a real world program will consist of definitions of new IO actions in terms of simpler ones
15:12:55 <Cale> (ultimately coming together to form the definition of 'main')
15:13:15 <Cale> But how much IO and how much non-IO code there is depends on the program
15:13:58 <Cale> and it's also possible to make pure abstractions which are ultimately transformed into IO actions (The TermIO thing I defined above is sort of an example of this)
15:15:07 <Cale> Where I work, we do a lot of functional reactive programming, which lets you get hold of values that represent things which change over time, or which occur at given moments in time, and then at some level, keeping things up to date gets handled by IO actions, but you don't write very much IO code directly.
15:16:01 <hseg> Is GHC smart enough to replace nested tuples by one big tuple? e.g. ((((a,Int),Int),Int),Int)~(a,Int,Int,Int,Int)
15:16:08 <Cale> no, it won't do that
15:16:12 <hseg> :(
15:16:19 <Cale> Also because the semantics are different
15:16:20 <davean> hseg: thats not about smarts - those are different
15:16:42 <hseg> what if they're unboxed tuples?
15:17:01 <Cale> One could imagine it then, but, I doubt that's a thing it actually does
15:17:11 <davean> Hum, I think tjey
15:17:18 <hseg> am trying to justify to myself that i'm overengineering things and ghc will take care of it for me anyway
15:17:24 <davean> re about the same in memory then ... 
15:17:27 <Cale> GHC does very little to fiddle with the representations of data types when optimising in general
15:17:31 <hseg> ah
15:17:35 <Cale> I think that's one of its biggest weaknesses
15:18:23 <hseg> basically, am trying to implement the "localization of a ring at a submonoid of elements"
15:18:51 <hseg> (i.e. formal fractions where numerator is a ring element and denominator is element of submonoid)
15:19:15 <hseg> which i'm emulating by (Semiring r, Action m r, Monoid m) => ...
15:19:22 <Cale> haha, are you running into the same problem as Kevin Buzzard?
15:19:23 <dansho> how can i turn a Maybe (IO ()) into an IO () that does 'return ()' if Nothing?
15:19:33 <hseg> what's his problem?
15:19:47 <Cale> Where he wanted R[1/p][1/q] to be the same as R[1/(pq)] in Lean :D
15:19:54 <hseg> hah
15:19:54 <xsperry> fromMaybe (return ()) may
15:19:59 <hseg> pretty much
15:20:28 <dolio> Haskell is the wrong language for this anyway.
15:20:37 <hseg> i'm trying to tell myself any practical usecase is going to be iso to R[1/p_i]=R[1/p_1][1/p_2]...
15:20:49 <hseg> dolio: Oh? Why?
15:21:12 <dolio> Because it isn't Lean/Agda/Coq.
15:21:29 <hseg> dolio: I mean, if you statically know your denominators will only be powers of certain primes, it gives you exponential savings to store logs of the denominators instead
15:21:45 <hseg> i'm not setting out to *prove* R[1/p][1/q]=R[1/pq]
15:21:56 <Cale> hseg: The type level shenanigans are going to be annoying in Haskell... though you could imagine making a type whose elements are all the elements of every possible localisation
15:22:15 <Cale> and that wouldn't be too inconvenient to work with
15:22:30 <dansho> ty
15:22:37 <hseg> "elements are all the elements of every possible localization"?
15:22:54 <Cale> I mean, that's basically the field of fractions :P
15:22:58 <hseg> yup
15:23:29 <Cale> But yeah, the problem is, to refer to other localisations at the type level, you want a value of your ring occurring in the type of the localisation
15:23:36 <hseg> so you're basically picking a field of fractions and working in subrings
15:23:39 <Cale> So that implies you're doing something dependently typed
15:23:55 <jollygood2> what is an "action"? object of type that is an instance of Monad?
15:24:06 <hseg> yeah... well, reflection at least works for integers
15:25:03 <hseg> indeed, iiuc i can demand it works for any ring for which i want to localize at an element
15:26:18 <hseg> ie have Loc r (AwayFrom e) where Reifies e r
15:26:19 <Cale> jollygood2: In our previous discussion, yeah
15:26:30 <jollygood2> in general
15:26:55 <Cale> jollygood2: I only qualify that because hseg used the word "Action" in a different sense in some code just above
15:26:56 <monochrom> "getLine is a function" has a problem, so we needed a different word. We chose "action".
15:27:22 <Cale> But usually "action" or "m-action" is used to refer to the elements of types created by various monads, yeah
15:29:24 <hseg> Cale: anyway, so basically wanted arbitrary localization, realized practical cases involve (co)finitely generated submonoids, cofinite cases useless afaict, finite cases replaceable by iterating localization away from generator
15:29:59 <hseg> Cale: which basically means moving from (a, Vector n Int) to ((((a, Int),...)
15:30:30 <hseg> which if davean is right is basically the same, so no loss
15:32:45 <electricityZZZZ> so we have that a haskell program H = action definitions, function definitions, type definitions, type constraints (typeclass definitions and their instances as types), and then "code" (modules/imports)
15:33:23 <John20> It's working now. Problem was that I had multiple executables defined in my package.yaml. Paring them down to just 1 seems to have solved the issue
15:50:57 <dolio> getLine is a generic effect.
16:00:08 <Cale> electricityZZZZ: Well, action definitions can be lumped in with definitions of other values
16:01:14 <Cale> The formal syntactic distinction is between "pattern bindings", which bind the variables in a pattern on the left hand side of an = sign, and "function bindings" which define a function with formal parameters occurring on the left hand side of an = sign
16:01:35 <electricityZZZZ> a haskell program H = value definitions (actions which are assembly snippets focusing on io or other physical world interactions, constants, constraints on values),  function definitions, type definitions, type constraints (typeclass definitions and their instances as types), and then "code" (modules/imports)
16:01:37 <Cale> Definitions like x = 5 count as pattern bindings, with a simple variable pattern
16:02:20 <Cale> https://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-620004
16:03:01 <Cale> (might be of interest)
16:10:25 <ezzieyguywuf> can I pattern match somehow on the output of `<-`?
16:11:11 <monochrom> In do-notation?
16:11:16 <monochrom> If so, yes.
16:11:24 <monochrom> In list comprehension? Also yes.
16:11:28 <electricityZZZZ> so roughly speaking (not precisely speaking!) a category is some sets and functions which map between them in a manner which composes, and likewise a haskell program H is essentially the same thing, H is (roughly, approximately) a category
16:11:51 <monochrom> do { (x,y) <- foo; ... }  and [ x+y | (x,y) <- zip xs ys ]
16:12:21 <ezzieyguywuf> monochrom: yes in do-notation
16:12:36 <ezzieyguywuf> hrm, I think I meant whatever the thingy is called with |
16:13:07 <monochrom> pattern guard?
16:13:07 <Cale> electricityZZZZ: That's a fair way of thinking of a lot of examples of categories, but a category in general is something even more abstract: the objects needn't be sets, and the arrows needn't be functions -- the objects only serve to tell us which arrows we're allowed to compose, and we only need to know how the arrows compose to define the category, we don't need to know that they have any structure beyond that.
16:13:16 <ezzieyguywuf> something like do { val | A a <- foo ; | B b}
16:13:18 <ezzieyguywuf> monochrom: yea that
16:13:41 <monochrom> I know of no | in do-notation.
16:14:19 <electricityZZZZ> so a category is some kind of constraint on arrow composition
16:14:30 <ezzieyguywuf> guess I could just define the function with the pattern matching and then use >>= instead
16:15:07 <electricityZZZZ> Cale: is the relation to H valid?
16:15:40 <Cale> Haskell programs I usually wouldn't think of as categories, but there's a category whose objects are Haskell types, and whose arrows are Haskell functions.
16:16:13 <electricityZZZZ> right but if i write a haskell program, i am basically defining what can compose (and then also how to perform those compositions)
16:16:34 <Cale> That is, all the possible (monomorphic) Haskell types and definable Haskell functions between them.
16:16:37 <monochrom> Do you simply want do { A a <- foo ; ... } ?
16:17:10 <Cale> Yeah, you could say that when you write Haskell functions, you're picking arrows from that category.
16:17:11 <monochrom> I'll show an example.
16:17:30 <monochrom> > do { (x,y) <- Just (1,2); Just (y, x) }
16:17:32 <lambdabot>  Just (2,1)
16:17:41 <monochrom> so x=1, y=2 there
16:18:14 <electricityZZZZ> ...so a haskell program is not a category, it is something lesser than a category
16:18:17 <koz_> :t truncate
16:18:18 <lambdabot> (RealFrac a, Integral b) => a -> b
16:18:36 <Cale> yeah
16:20:40 <Cale> electricityZZZZ: But you can imagine defining a category from a Haskell program which takes only those types that the Haskell program uses as its objects, and then takes all the possible compositions of functions defined in the program, throws in identity arrows as needed...
16:20:55 <koz_> How does toIntegralSized handle conversions between Integral types where one is signed, and the other not?
16:21:07 <Cale> But then, it's not entirely clear from that category what the original program was
16:22:17 <Cale> electricityZZZZ: and you'd probably want to also *create* some functions in the category in order to deal with the things which are not Haskell functions, but nevertheless are part of the program, like 'main' especially.
16:32:44 <electricityZZZZ> those would be "actions" or "assembly snippets" and soforth
18:27:19 * hackage timezone-detect 0.3.0.0 - Haskell bindings for the zone-detect C library; plus tz-aware utils.  https://hackage.haskell.org/package/timezone-detect-0.3.0.0 (lfborjas)
19:24:01 <Patrick31> I was looking at the recursion-schemes package and I'm confused about the type signature of the hoist function: hoist :: (forall a. Base s a -> Base t a) -> s -> t
19:24:18 <Patrick31> I would expect the type of hoist to instead be Base s t -> Base t t -> s -> t because when I look at how hoist is implemented (hoist n = cata (embed . n)), embed is applied to the result of n.
19:24:38 <Patrick31> Because embed :: Base t t -> t, wouldn't that mean that n would have to have the type Base s t -> Base t t and so hoist would have the type (Base s t -> Base t t) -> s -> t
19:28:14 <Patrick31> ?
19:36:42 <Cale> Patrick31: So that'll be just fine because we're given a polymorphic function n of type forall a. Base s a -> Base t a
19:36:53 <Cale> so, we'll be able to use that at type a ~ t
19:37:38 <Cale> Patrick31: The forall in the argument there means that hoist gets to pick a
19:40:30 <Patrick31> But how would the function work is a ~ t was not true. Wouldn't embed not work then because you can only embed a Base t a if t ~ a ?
19:41:23 <dolio> Which function?
19:41:40 <Cale> Patrick31: It will always be true
19:41:45 <dolio> The function passed to hoist must work uniformly for every choice of a.
19:42:27 <dolio> If it were just `Base s t -> Base t t` it could try to do weird stuff by inspecting the `t`.
19:43:19 <Patrick31> Oh I think I get it now. I was misunderstanding the meaning of the rank-2 polymorphic type.
19:44:45 <Patrick31> Thanks for the help! :)
20:09:47 <brettgilio> https://www.youtube.com/playlist?list=PLhgq-BqyZ7i7MTGhUROZy3BOICnVixETS
20:30:03 <ezzieyguywuf> isn't there an idiom that `const . pure` is the same as fmap or something?
20:30:57 <jchia1> How can I get a NaN Double value? I could only find isNan to check whether a value is NaN.
20:31:45 <MarcelineVQ> jchia1: 0/0
20:31:55 <jchia1> MarcelineVQ: Thanks
20:34:13 <nshepperd2> ezzieyguywuf: there's a law that ap . pure is the same as fmap
20:34:31 <MarcelineVQ> ezzieyguywuf: doesn't sound likely.  though  pure = const  for the (r ->)  Applicative, and one law with const here https://hackage.haskell.org/package/base-4.14.0.0/docs/Prelude.html#t:Applicative
20:34:49 <MarcelineVQ> oh not even law, just a default definition
20:34:50 <nshepperd2> :t ap .pure
20:34:51 <lambdabot> Monad m => (a -> b) -> m a -> m b
20:44:15 <ezzieyguywuf> what is ap?
20:44:36 <ezzieyguywuf> :info ap
20:44:58 <olligobber> :t ap
20:44:59 <lambdabot> Monad m => m (a -> b) -> m a -> m b
20:45:11 <olligobber> it's <*> but for monads
20:46:00 <ezzieyguywuf> interesting, first I've heard of it.
21:36:55 <Jesin> :t (<$>) (<*>) pure
21:36:57 <lambdabot> Applicative f => (a -> b) -> f a -> f b
21:37:02 <Jesin> :t (<$>)
21:37:04 <lambdabot> Functor f => (a -> b) -> f a -> f b
21:38:27 <Jesin> the @pl and @unpl commands are bizarrely entertaining
21:39:10 <Jesin> though @pl understands the ((->) r) monad much better than @unpl does
21:51:19 <Jesin> :t fix (ap (ap . (. succ) . if' . (<= 0)) . ap (ap . (.)(.) . (. pred)) ((ap (flip if' 1 . (<= 0)) .) . flip flip pred . (.)(.)))
21:51:21 <lambdabot> error:
21:51:21 <lambdabot>     • Variable not in scope: if' :: Bool -> b -> b1 -> b1
21:51:21 <lambdabot>     • Perhaps you meant ‘f'’ (imported from Debug.SimpleReflect)
21:52:06 <Jesin> :t fix (ap (ap . (. succ) . if' . (<= 0)) . ap (ap . (.)(.) . (. pred)) ((ap (flip if' 1 . (<= 0)) .) . flip flip pred . (.)(.))) where if' a b c = if a then b else c
21:52:07 <lambdabot> error: parse error on input ‘where’
21:52:36 <Jesin> :t (fix (ap (ap . (. succ) . if' . (<= 0)) . ap (ap . (.)(.) . (. pred)) ((ap (flip if' 1 . (<= 0)) .) . flip flip pred . (.)(.)))) where if' a b c = if a then b else c
21:52:37 <lambdabot> error: parse error on input ‘where’
21:53:02 <Jesin> :t let if' a b c = if a then b else c in fix (ap (ap . (. succ) . if' . (<= 0)) . ap (ap . (.)(.) . (. pred)) ((ap (flip if' 1 . (<= 0)) .) . flip flip pred . (.)(.)))
21:53:03 <lambdabot> (Enum a1, Enum a2, Num a2, Num a1, Ord a2, Ord a1) => a2 -> a1 -> a1
22:09:26 <glguy> Jesin: stick to private messages to lambdabot while you're experimenting please
22:43:41 <p0a> Hello
22:43:47 <p0a> I would like to try to write some note-taking software in Haskell
22:44:17 <p0a> I'd like to start simple, with a blank screen where I can draw
22:44:30 <p0a> Which modules should I use?
22:45:00 <lucky> p0a: Are you only going to draw, or would you probably like GUI-like features too/eventually? 
22:47:26 <p0a> lucky: GUI-like features would be nice, but not necessary. I suppose keybindings could replace GUI features 
23:10:08 <p0a> lucky: any suggestions?
23:11:20 <dminuoso> p0a: Brick comes to mind if you want it terminal based.
23:12:40 <p0a> dminuoso: so what would that look like, a TUI and another window with the 'a4 paper' to drawn on?
23:12:55 <lucky> p0a: oh, sorry!  a popular suggestion to the beginner end would be threepenny-gui https://hackage.haskell.org/package/threepenny-gui 
23:14:08 <lucky> people seem to like it for small things, it looked simple and clean but I haven't used it myself
23:14:44 <p0a> I would rather avoid anything that has to do with a web browser though 
23:15:26 <p0a> to be fair I can just search `gui' on hackage
23:16:18 <lucky> http://gloss.ouroborus.net/ maybe ? 
23:16:26 <p0a> reactive-banana looks interesting, what do you think about that?
23:16:29 <lucky> it's vector 
23:16:34 <p0a> what is?
23:16:38 <lucky> the one I linked
23:17:03 <p0a> got it. Oh, we're discussing /drawing/. Sorry I was a bit confused because I thought we were talking about the gui
23:17:14 <p0a> right. Drawing comes first :P 
23:17:16 <lucky> you said you wanted to start there 
23:17:43 <lucky> threepenny-gui has html5 canvas access in a nice data type
23:17:53 <lucky> so you'd just plot points and draw lines 
23:17:57 <lucky> tho it is in the browser 
23:18:11 <p0a> right, but I absolutely do not want anything with browsers or javascript
23:18:52 <lucky> reactive-banana can do that too, FRP is a specific paradigm but it's a very appropriate one for this kind of app
23:19:14 <p0a> lucky: do I need to combine gloss and reactive-banana or can I just use reactive-banana?
23:19:22 <p0a> sorry for the ignorant question I am not sure which I should start trying to leanr 
23:19:24 <Axman6> % let a --- b = "Not a comment" in 1 --- 2
23:19:24 <p0a> learn* 
23:19:25 <yahb> Axman6: ; <interactive>:1:41: error: parse error (possibly incorrect indentation or mismatched brackets)
23:19:48 <Axman6> % let a --$ b = "Not a comment" in 1 --$ 2
23:19:48 <yahb> Axman6: "Not a comment"
23:20:28 <lucky> p0a: I am unfamiliar with reactive-banana really, sorry
23:20:49 <p0a> lucky: thanks for the pointers. I'll explore what's there :) 
23:20:51 <lucky> p0a: you want a library which has some sort of canvas or bitmap, either vector or bitmap (or supporting both), which you can plot and draw on
23:21:05 <lucky> most full GUI libraries will have this, as do SDL bindings and wrappers
23:22:51 <p0a> lucky: by bitmap you mean a 2D array of RGBA pixels right?
23:23:02 <lucky> p0a: yes, if that's how you want to approach the problem 
23:23:04 <p0a> lucky: but what is a 'canvas'? is it the vector equivalent? 
23:23:10 <lucky> yeah
23:23:25 <p0a> what would be a modern solution? canvas?
23:23:48 <p0a> seems there is gloss-banana, so both modules (reactive-banana and gloss) should be good to learn I think 
23:23:55 <lucky> both approaches have merits and drawbacks 
23:24:14 <lucky> do you want to manipulate the things you draw as objects?  then it becomes vector
23:24:31 <lucky> much easier than with a RGBA array that flattens everything 
23:24:50 <p0a> manipulate as in, have a bezier curve and change its control points?
23:25:00 <lucky> if that's what you want to do 
23:25:12 <p0a> I want to write note-taking software for math
23:25:15 <lucky> SVG vs BMP approach 
23:25:44 <p0a> I'll try gloss and reactive-banana 
23:25:59 <lucky> vector stuff would be a wonderful place for types to shine :) 
23:26:28 <lucky> good luck, hopefully someone who knows what they're talking about can chime in
23:27:17 <p0a> No I think I need to learn some things before I can even present myself here again talking about this topic :P 
23:27:28 <p0a> Thank you for the help. I will part now but hopefully be back sometime with more questions
