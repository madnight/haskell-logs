00:35:31 <edwardk> siraben: i had not
00:35:41 <edwardk> siraben: but its pretty much the same kinda thing as dolio's upts code
00:35:54 <siraben> lam a = Lam . abstract1 a What does the a mean?
00:35:56 <siraben> lam :: Eq a => a -> Expr a -> Expr a
00:36:06 <edwardk> both of those lack a thing that i think andras gets right in his elaboration zoo, which is he starts with a surface language and compiles down to a core
00:36:19 <siraben> I'm putting a number there but not sure what abstract1 does
00:36:21 <edwardk> lam "x" $ some expression which uses Var "x"
00:36:24 <edwardk> think String
00:36:28 <siraben> Oh I see
00:36:37 <edwardk> its whatever names you have before you start binding things up
00:37:37 <edwardk> heck, when working with meta variables the 'a' in my expressions is often something like an newtype Meta = Meta (IORef (Maybe (Term Meta)))
00:38:24 <edwardk> so i start out with Expr String, because its easy to work with in the parser, finish closing my terms, because i traverse over them with traverse (const Nothing) -- which tells me Nothing if the term is not closed, or Just (Expr a) for any a i want if it is closed
00:38:53 <edwardk> then I can start using it as Expr Void for a while, maybe switching to Expr Meta when doing unification
00:39:09 <edwardk> s/Term/Expr/ in the definition of meta to use that though
00:40:03 <edwardk> abstract1 looks for all occurrences of that name in Term a and converts them to the () in Scope () Term a
00:40:28 <edwardk> abstract is more general and can be used to grab several names at once, say for a pattern or a recursive let binding
00:40:58 <siraben> That makes sense
00:41:01 <edwardk> instantiate1 is how you substitute a term for the bound () in Scope () Term a
00:41:22 <siraben> hasType (lam 0 $ Var 0) (pi 0 (Var 0) (Var 0)) seems to fail, but hasType (lam 0 $ Var 0) (pi 0 (Var 1) (Var 1)) succeeds
00:41:38 <siraben> It seemed to try to equate Var 0 and Var 1, hm.
00:42:34 <siraben> I'm trying to do a simple, (\x → x) : Π (x : Star). x → x
00:42:37 <edwardk> (\x. x)  :: Pi(x :: y). y -- is what the second one says
00:43:30 <edwardk> the former says (\x.x) :: Pi(x:some_unbound_variable_named_0).x. no?
00:43:47 <siraben> Ah, hm.
00:43:58 <edwardk> er i don't know your pi constructor there
00:44:01 <edwardk> let me read the code
00:44:23 <edwardk> but it should be something along those lines. pi should only be binding the variable name in the result type not the arg type
00:44:29 <siraben> http://ix.io/2y5J
00:44:42 <siraben> it's the same as the one in the lambda-pi repo, but with error messages
00:46:46 <edwardk> i'd expect your hasType thing to be like
00:47:41 <siraben> Ah before it would return a Bool, heh.
00:47:52 <edwardk> hasType (lam "x" $ Var "x") (pi "y" Star (Var "y"))
00:48:47 <siraben> Translating that I have, hasType (lam 0 $ Var 0) (pi 1 Star (Var 1)) which gets Left "Failed to unify Var 1 with Star"
00:49:15 <edwardk> where you may have to traverse (const Nothing) -- over  both of those to close them and match whatever types hasType expects or generalize hasType to Expr a and Val a with Eq
00:51:02 <siraben> Why would traverse (const Nothing) close them?
00:51:28 <phadej> :t foldMap (const Nothing) []
00:51:30 <lambdabot> Semigroup a => Maybe a
00:51:37 <phadej> :t traverse (const Nothing) []
00:51:39 <lambdabot> Maybe [b]
00:51:44 <phadej> :t traverse (const Nothing) "foobar"
00:51:46 <lambdabot> Maybe [b]
00:51:49 <phadej> traverse (const Nothing) "foobar"
00:51:53 <phadej> > traverse (const Nothing) "foobar"
00:51:55 <lambdabot>  Nothing
00:51:57 <phadej> > traverse (const Nothing) []
00:51:59 <lambdabot>  Just []
00:52:12 <phadej> "there is no 'a'"
00:52:48 <phadej> recall, that in `bound` 'a' is a type of free variables
00:53:01 <phadej> if there is no 'a', there is no free variables -> expression is closed
00:53:30 <phadej> ('a' in 'Expr a')
00:54:51 <siraben> traverse (const Nothing) (lam 0 $ Var 0) :: Maybe (Expr b)
00:54:52 <siraben> for me
00:54:57 <siraben> Result is Just (Lam (Scope (Var (B ()))))
00:55:13 <edwardk> yes
00:55:15 <edwardk> that is a closed term
00:55:15 <phadej> yes, \x.x is closed
00:55:24 <edwardk> try it with lam 0 $ Var 1
00:55:27 <edwardk> and it'll bail with Nothing
00:55:51 <siraben> Ah I see
00:55:55 <edwardk> but if it succeeds, because the term is closed, you can use it as Expr a for any a you like
00:56:08 <edwardk> that way you can work 'conveniently' with strings while parsing
00:56:11 <edwardk> and then switch to integers
00:56:22 <edwardk> or just passing around types during typechecking
00:57:41 <siraben> Hm, maybe this implementation of lambda pi is bugged? It was written in 2014
00:57:46 <edwardk> i think so
00:57:54 <siraben> I can't seem to get \x → x to have the polymorphic type
00:57:57 <edwardk> i don't have Control.Monad.Gen in scope, what is that from?
00:58:06 <siraben> monad-gen
00:58:30 <edwardk> well, to make a polymorphic if you'd have to pass the argument first
00:59:01 <edwardk> id :: Pi(A:*). A -> A
00:59:40 <edwardk> so you need two Pis and two lambdas, this language lacks implicit vs. explicit lambdas/pis.
01:00:29 <siraben> Well, time to read elaboration-zoo then. hm.
01:00:32 <edwardk> id = \_ a. a -- needs to ignore its first arg
01:00:48 <siraben> What if I want fully explicit lambdas and pis?
01:00:57 <siraben> What would that look like?
01:01:10 <edwardk> id :: pi (a : star). pi (_ : a). a
01:01:21 <edwardk> id = \_. \a. a
01:01:26 <siraben> ((A :: *) (x :: A). x) :: Pi (A :: *). a
01:01:35 <siraben> oops, ((A :: *) (x :: A). x) :: Pi (A :: *). a
01:01:38 <siraben> backslash
01:01:57 <edwardk> (A::*).(_::A).A
01:02:07 <edwardk> however you notate that pi in your syntax
01:03:02 <edwardk> Pi(A::*).      is like forall a. in haskell  then the next bit Pi(_::A). A is not using the variable bound so it is like a -> a in haskell 
01:03:03 <siraben> (lam 0 (lam 0 (Var 0))) for term, I think.
01:03:27 <siraben> I'm not sure how the lam smart constructor is supposed to work
01:03:27 <edwardk> lam "A" $ lam "a" $ var "a"
01:03:45 <phadej> fwiw, when using bound, I never really think about de bruijn indices
01:03:55 <phadej> I just truste that `abstract` makes it right
01:04:01 <edwardk> those numbers aren't levels, they are variable "names"
01:04:04 <edwardk> you just chose to use numbers
01:04:08 <siraben> Oh I see
01:04:13 <edwardk> you could use strings, or text
01:04:21 <siraben> The problem is that it typechecks to Expr [Char], when I need Expr Int
01:04:33 <edwardk> and traverse (const Nothing) -- will get you Expr Int
01:04:45 <siraben> Ah, it's clear now. Ok I'll try
01:05:23 <edwardk> i even export it from bound as 'closed'
01:05:51 <edwardk> fromJust . closed = 'trust me i'm closed'
01:07:10 <edwardk> so you should be checking lam "A" $ lam "a" $ var "a".      against type Pi "A" Star $ Pi "_" (Var "A") $ Var "A"
01:07:29 <edwardk> er using lowercase Pi's there
01:07:42 <dansho> cant figure out this overlapping problem, its ok with the first OVERLAPS (Bar) but error only on the second (Baz) https://hastebin.com/azojuvehes.hs
01:07:48 <dansho> neither Bar nor Baz are Distributions
01:08:00 <edwardk> man i forgot how much of a PITA template-haskell is to write
01:08:02 <siraben> Oh, two levels of Pi, I missed that
01:08:06 <edwardk> its gorgeous once it is written
01:08:11 <edwardk> but its frustrating to write
01:08:23 <edwardk> well, not very gorgeous once written, because then someone has to maintain it
01:08:31 <siraben> Yay it works
01:08:34 <edwardk> ok, so its a shit show all around, but its still convenient
01:08:35 <siraben> hasType' (lam "A" (lam "a" (Var "a"))) (pi "A" Star (pi "_" (Var "A") (Var "A")))
01:08:45 <siraben> Ok so I think the typechecking is correct here then
01:08:45 <edwardk> yay!
01:08:54 <siraben> I get, Just (Right ())
01:08:57 <siraben> it's just right.
01:09:00 <edwardk> =)
01:09:28 <siraben> And that's why we want implicit args, heh
01:09:37 <dansho> like why would ghc even consider the Distribution instance if the type is not an instance?
01:09:48 <edwardk> i'm writing more unsafeCoerce's per line right now than I have in years. this is obviously going to work first time, right?
01:10:03 <siraben> Why are you writing unsafeCoerce?
01:10:23 <phadej> because edward is smarter than GHC ;)
01:10:26 <edwardk> https://github.com/ekmett/haskell/blob/master/types/src/Data/Type/Internal.hs
01:11:30 <edwardk> that code makes Int, Char usable as a kind and Type,Nat,Symbol usable as terms, and provides one general form of singleton lifting story that is O(1) rather than O(n) like in the singletons library
01:11:45 <edwardk> but it does so by using evil
01:11:53 <edwardk> and then unsafeCoercing that evil to make it more evil
01:12:24 <edwardk> so since the code towards the bottom is super formulaic i want to let template haskell generate it all for the user
01:16:19 <edwardk> the code there can be pretty hard to follow because you need to know what cheats it uses
01:17:14 <edwardk> newtype Sing (a :: k) = UnsafeSing { fromSing :: k } -- is the first weird to read bit
01:18:05 <edwardk> it takes a phantom type argument a of kind k, then uses k at the term level as well. So you might have UnsafeSing True :: Sing 'True
01:18:27 <edwardk> of course its just a phantom so nothing overtly keeps you from saying UnsafeSing False :: Sing 'True
01:18:30 <edwardk> that is what the rest is for
01:19:23 <edwardk> the goal is to use Sing (a :: k) as a way to represent terms of type k as a type, with each term getting a different type
01:19:29 <siraben> I see
01:19:40 <siraben> I mostly use dependent types for theorem proving, haven't had a use for them in Haskell yet
01:19:46 <edwardk> the direct way of doing this would be to do this once for each type
01:19:56 <edwardk> e.g.
01:20:21 <edwardk> data Nat = Z | S Nat; data SNat (n :: Nat); SZ :: SNat 'Z; SS :: SNat n -> SNat ('S n)
01:20:33 <edwardk> SNat n and Sing n play the same role here
01:21:06 <edwardk> i emulate SNat n off of patterns and GADTs and lots of unsafeCoerce below
01:21:58 <siraben> Weird that lifting singletons takes O(n), didn't know that was the case
01:22:03 <siraben> In the singletons library
01:22:52 <edwardk> well its O(1) for each part you touch, but there is a translation cost, because you have to put on and take off the conversions eleemnt by element in say a [a] reflected to a singleton list
01:23:34 <edwardk> but my goal was to be able to get a singleton Int represented as a machine Int
01:23:42 <edwardk> rather than some peano monstrosity
01:23:51 <edwardk> and my singleton list internally to be a list
01:23:55 <siraben> Since GHC doesn't know about dependent types, how can it perform erasure?
01:24:49 <edwardk> types are still erased
01:25:09 <Agiza> Hi! Can someone help me with a simple function? I just started learning and can't understand why one function won't work
01:26:17 <siraben> oh they left lol
01:26:41 <siraben> Agiza: just ask, don't ask to ask
01:27:11 <Agiza> I don't understand what I did wrong here: boomBangs xs = [if x < 10 then "BOOM!" else "BANG!" | x <- xs, odd x ]
01:27:49 <[exa]> Agiza: what's that supposed to do?
01:28:16 <[exa]> currently it prints one boom for each odd number below 10 and one bang for all other odd numbers in xs
01:28:21 <siraben> Agiza:  that seems well-typed to me
01:28:48 <Agiza> It's from a tutorial: "Let's say we want a comprehension that replaces each odd number greater than 10 with "BANG!" and each odd number that's less than 10 with "BOOM!". If a number isn't odd, we throw it out of our list." but I only get an error
01:29:08 <Agiza> The error is: <interactive>:35:11: error:    • No instance for (Num [Integer]) arising from the literal ‘23’    • In the first argument of ‘boomBangs’, namely ‘23’      In the expression: boomBangs 23      In an equation for ‘it’: it = boomBangs 23
01:29:27 <siraben> Agiza:  that's because boomBangs takes a list of numbers
01:29:29 <[exa]> Agiza: you must give it a list, like in: boomBangs [23]
01:29:30 <siraben> Type :t boomBangs in the repl
01:29:41 <siraben> or try, boomBangs [1..100]
01:30:01 <dansho> whew ok figured out the correct overlap pragmas: OVERLAPPABLE on the first, nothing on the second, and OVERLAPPING on the third
01:30:03 <Agiza> Ooooh now I understand! I was writing boomBangs 23
01:30:25 <Agiza> Thank you for the help!
01:31:34 <siraben> Agiza:  FYI, "No instance for (Num [Integer]) arising from the literal ‘23’ " means that GHC is trying to interpret 23 as a list of numbers.
01:32:25 <[exa]> Agiza: btw this might be a nice exercise for catMaybes/map; try constructing `oneBoomBang :: Int -> Maybe String` for converting a single integer, and only then expand it to work with lists
01:32:30 <edwardk> siraben: anyways the idea is Nat only exists as a kind in ghc, Type only exists as a kind, Symbol is only a kind, and Int is only a type, Char is only a type. I want to be able to use Int as a kind, and lift term level ints into it, same with term level chars as types inhabiting the Char kind, and i want to go the other way. i want a Nat type that has Z and S as terms in it, same with Symbol holding strings and values for types letting 
01:32:30 <edwardk> me check type equality
01:33:34 <edwardk> siraben: and then Sing a can be written once and for all for all of these and let me lift terms in a type to types in a kind of singletons, such that each of those singleton types only has one inhabitant
01:34:04 <edwardk> the api is sort of the bastard child of the singletons library and my reflection library
01:37:01 <Agiza> [exa] What would that look like? I am too new to this (started yesterday) so it's very confusing
01:37:17 <Agiza> siraben Thank you!
01:38:37 <siraben> I see.
01:38:57 <siraben> In a dependently typed language, this would not be necessary at all, correct?
01:51:49 * hackage uniqueness-periods-vector-filters 0.2.0.0 - A library allows to change the structure of the 'RealFrac' function output.  https://hackage.haskell.org/package/uniqueness-periods-vector-filters-0.2.0.0 (OleksandrZhabenko)
02:02:49 * hackage Z-Data 0.1.2.0 - Array, vector and text  https://hackage.haskell.org/package/Z-Data-0.1.2.0 (winterland)
02:04:51 <[exa]> Agiza: oh so. Basically, make a simple function that converts eg. 23 to `Just "BANG"` and 8 to `Nothing`, and try using some higher order functions to expand this functionality to lists without actually touching the lists plumbing manually; in particular try `map` and `catMaybes`
02:13:03 <Agiza> [exa] Oh okay! That sounds honestly too complicated for me right now so I will skip it but thank you for the advice
02:13:25 <Agiza> @[exa] 
02:13:25 <lambdabot> Unknown command, try @list
02:13:49 * hackage futhark 0.17.1 - An optimising compiler for a functional, array-oriented language.  https://hackage.haskell.org/package/futhark-0.17.1 (TroelsHenriksen)
02:40:19 * hackage composite-aeson-writeonly 0.1.0.0 - WriteOnly indicators for composite-aeson.  https://hackage.haskell.org/package/composite-aeson-writeonly-0.1.0.0 (locallycompact)
02:52:18 * hackage composite-aeson-cofree-list 0.1.0.0 - Print a Cofree [] as a JSON value.  https://hackage.haskell.org/package/composite-aeson-cofree-list-0.1.0.0 (locallycompact)
03:19:19 * hackage futhark 0.17.2 - An optimising compiler for a functional, array-oriented language.  https://hackage.haskell.org/package/futhark-0.17.2 (TroelsHenriksen)
03:21:19 * hackage lti13 0.1.2.2 - Core functionality for LTI 1.3.  https://hackage.haskell.org/package/lti13-0.1.2.2 (jade)
03:22:19 * hackage yesod-auth-lti13 0.1.2.2 - A yesod-auth plugin for LTI 1.3  https://hackage.haskell.org/package/yesod-auth-lti13-0.1.2.2 (jade)
03:30:18 * hackage cabal-cache 1.0.1.9 - CI Assistant for Haskell projects  https://hackage.haskell.org/package/cabal-cache-1.0.1.9 (haskellworks)
04:29:19 * hackage Z-IO 0.1.0.0 - A simple and high performance IO toolkit for Haskell  https://hackage.haskell.org/package/Z-IO-0.1.0.0 (winterland)
05:26:06 <wasm> hi
05:50:49 * hackage blank-canvas 0.7.2 - HTML5 Canvas Graphics Library  https://hackage.haskell.org/package/blank-canvas-0.7.2 (ryanglscott)
06:06:19 * hackage pandoc-plot 0.9.3.0 - A Pandoc filter to include figures generated from code blocks using your plotting toolkit of choice.  https://hackage.haskell.org/package/pandoc-plot-0.9.3.0 (LaurentRDC)
06:25:24 <ti4a4a> Hello CHILD PORN HD Videos, Open in Tor Browser Links gg.gg/m7dgu
06:32:47 <tomsmeding> wasm: welcome :)
07:15:39 <MrBe> hai
07:15:50 <MrBe> hi all
07:15:57 <MrBe> anybody there
07:16:33 <MrBe> hiiii 
07:16:36 <MrBe> yo
07:17:13 <Uniaika> nah we're all sleeping
07:17:44 <merijn> Not true, some of us are playing videogames ;)
07:17:54 * bicho_rastrero imagines the cute faces of the people in the channel sleeping.
07:18:08 <Uniaika> haha
07:18:24 <MrBe> yess i am cant sleep at this time
07:19:38 <MrBe> so quite at this channel
07:19:40 --- mode: ChanServ set +o dmwit
07:19:42 --- mode: dmwit set +b *!*@77.111.247.184
07:19:55 --- mode: dmwit set -o dmwit
07:20:31 <MrBe> ....
07:21:21 <MrBe> nobody online
07:21:53 <dmwit> You're going to get a lot better response if you start talking about Haskell. That's sort of the reason folks are here.
07:22:07 <dmwit> If you'd like some pointers to tutorials, there are more than any one person could ever handle listed here:
07:22:11 <dmwit> ?wiki tutorials
07:22:11 <lambdabot> https://wiki.haskell.org/tutorials
07:24:35 <Eduard_Munteanu> Who needs Tor when you have Netflix? :P
07:25:36 <MrBe> hi maozedong
07:25:37 <MaoZeDong_> > 1 + 2
07:25:40 <lambdabot>  3
07:25:46 <MaoZeDong_> hi
07:26:03 <MaoZeDong_> > take 5 [1..]
07:26:06 <lambdabot>  [1,2,3,4,5]
07:26:13 <MaoZeDong_> > take 10 [1..]
07:26:16 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
07:26:20 <int-e> MaoZeDong_: you can chat with lambdabot privately
07:26:28 <MaoZeDong_> how?
07:26:33 <Eduard_Munteanu> /query lambdabot
07:26:37 <z0> MaoZeDong_: /q lambdabot
07:28:00 <MaoZeDong_> thanks
07:28:02 <MaoZeDong_> sorry
07:28:09 <MrBe> quit
07:28:36 <z0> MaoZeDong_: you can also install lambdabot on your machine, or just use ghci
07:29:03 <MaoZeDong_> i came here to try some monad transformers features
07:29:43 <dmwit> \bot is a nice way to do that, assuming you don't want to transform IO. ^_^
07:29:56 <dmwit> (And yahb has got your back if you do, though it may require a bit more import'ing first.)
07:31:52 <edwardk> ok, it looks like my fast singleton types package is almost usable, modulo one ghc bug, and reliance on another
07:38:19 * hackage uniqueness-periods-vector-stats 0.1.0.0 - A very basic descriptive statistics.  https://hackage.haskell.org/package/uniqueness-periods-vector-stats-0.1.0.0 (OleksandrZhabenko)
07:49:49 * hackage joint 0.1.7 - Trying to compose non-composable  https://hackage.haskell.org/package/joint-0.1.7 (iokasimovmt)
09:56:20 * hackage pandoc-types 1.22 - Types for representing a structured document  https://hackage.haskell.org/package/pandoc-types-1.22 (JohnMacFarlane)
10:16:17 <lechner> Hi, how do I compute and print the SHA-512 of the file indicated by the first command-line argument, please? I am having some type confusion. Thanks!
10:17:00 <sm[m]> what have you got so far lechner ? 
10:17:00 <sm[m]> @where paste
10:17:01 <lambdabot> please paste full code, input, and output at https://paste.tomsmeding.com
10:18:37 <sm[m]> @where+ paste Help us help you: please paste full code, input and/or output at eg https://paste.tomsmeding.com
10:18:38 <lambdabot> I will remember.
10:19:22 <glguy> lechner: http://hackage.haskell.org/package/cryptohash-sha512-0.11.100.1/docs/Crypto-Hash-SHA512.html#v:hash 
10:19:23 <lechner> sm[m]: well, this just tries to print the contents but i have the IO monad problem  https://paste.tomsmeding.com/9NWmmMxb
10:20:18 <davean> =<<, feed the result
10:20:26 <sm[m]> good start. Right, those types in the last line don't line up
10:20:41 <lechner> it's my first dip into haskell
10:20:41 <davean> putStr =<< (readFile (head args))
10:20:59 <dmwit> do { args <- getArgs; contents <- readFile (head args); putStr contents }
10:21:15 <dmwit> You might also like The IO Monad for People Who Simply Don't Care.
10:21:24 <dmwit> http://blog.sigfpe.com/2007/11/io-monad-for-people-who-simply-dont.html
10:22:15 <lechner> in an earlier experiment, the assignment   args <- getArgs  seemed to make  a difference. is that possible?
10:22:26 <lechner> instead of using getArgs straight
10:22:53 <dmwit> Take a look at my link and you will have a framework for understanding why that made a difference.
10:23:08 <dmwit> (Yes, it is possible.)
10:23:49 * hackage uniqueness-periods-vector-stats 0.1.1.0 - A very basic descriptive statistics.  https://hackage.haskell.org/package/uniqueness-periods-vector-stats-0.1.1.0 (OleksandrZhabenko)
10:25:11 <sm[m]> https://paste.tomsmeding.com/PZbIiTyi is the simplest fix, as dmwit said
10:26:25 <lechner> i am reading and will be back with more shortly. thanks for being so friendly. don't know why people say haskellers are complicated folks :)
10:28:05 <sm[m]> I know! We are all simple folk here
10:28:26 <sm[m]> tomsmeding: should Edit this paste be Clone this paste ? (Also, links between such pastes could be nifty)
10:28:56 <tomsmeding> it should
10:29:09 <tomsmeding> in fact I have a todo for that
10:29:13 <lechner> hi, when reading files, is it better to use strict or lazy variants, please?
10:29:30 <tomsmeding> I like "Clone", too
10:29:34 <davean> lechner: depends on what you want to accomplish.
10:29:47 <dmwit> lechner: Lazy IO is to be avoided in real code. For quick experiments while learning, it is fine.
10:29:49 <merijn> The answer is: use strict or use conduit :p
10:29:58 <merijn> (or some other streaming library)
10:30:00 <lechner> thank you
10:30:16 <lechner> why is lazy I/O a bad idea?
10:30:24 <merijn> lechner: It's hard to control cleanup
10:30:40 <lechner> space leaks?
10:30:43 <davean> lechner: consider if you're reading lazily while writing to it.
10:30:45 <merijn> lechner: File descriptors (aka handles) are a limited resource and lazy IO makes it hard to control if/when they are freed
10:30:46 <davean> lechner: what do you get?
10:30:49 <dmwit> lechner: https://stackoverflow.com/a/6669453/791604 describes why lazy IO is a bad idea
10:31:07 <dolio> I think lazy I/O is a good idea. :þ
10:31:21 <Uniaika> dolio: I curse you to hell and back
10:31:52 <davean> lechner: the idea of spaceleaks with laziness is a bit weird, since strict has to use all the space, lazy only might use all the space.
10:31:58 <glguy> If your goal is to write a program that opens a file, computes the SHA-512 hash, and prints that; then the lazy IO version will work the same as the strict IO version but probably use less ram
10:32:22 <lechner> it's the first line in a bigger project
10:32:23 <merijn> glguy: But then it'd be very little work to use conduit or some such and be sure of that fact ;)
10:32:41 <merijn> Not to mention that learning 1 or more streaming libraries is worthwhile anyway since they're amazing
10:32:43 <dmwit> davean: Sure. But lazy encourages a style of programming that would, in a strict semantics, use much more memory than the idiomatic approach from a strict language.
10:32:56 <merijn> Beat the shit out of nearly anything I've encountered in any other language for such problems
10:33:36 <dolio> Streaming libraries are exactly the overcomplicated solution for simple intro examples.
10:33:49 <dmwit> ^
10:33:53 <merijn> Sure
10:33:54 <dolio> And are probably an example of why people think Haskell people are complicated.
10:34:18 <lechner> actually, i think it's because of category theory
10:34:33 <davean> dmwit: I mean that sounds a lot like the tautology of "if you used more memory, you'd use more memory".
10:34:48 <geekosaur> you need zero category theory to use Haskell
10:34:50 <merijn> lechner: Category theory has basically zero relevance to haskell projects (or even Haskell)
10:35:13 <merijn> lechner: I dunno where that meme got started on the internet, but it's 100% nonsense
10:35:37 <dolio> Also note that one of the negatives about lazy I/O brought up (what if you read and write to a file concurrently) also applies to streaming libraries, but no one blames the streaming libraries for it for some reason.
10:36:10 <merijn> lechner: I've been doing Haskell for, like, a decade now. Very productively even, and I still got lost about 2-3 chapters into any book on category theory :p
10:36:18 <davean> dolio: uh, doesn't happen when I use 'machines' for example, I can can control the reading and writing so I can know what happens exactly.
10:36:28 <merijn> dolio: Files are shit, let's replace everything with SQLite databases :D
10:36:32 <davean> dolio: infact I use 'machines' specificly for reading and writing to a file at the same time.
10:36:49 * hackage texmath 0.12.0.3 - Conversion between formats used to represent mathematics.  https://hackage.haskell.org/package/texmath-0.12.0.3 (JohnMacFarlane)
10:37:18 <lechner> is there a kindred spririt between haskell and the declarative nature of SQL?
10:37:44 <merijn> Kinda, maybe?
10:38:08 <davean> dolio: yah, I'm not sure why you think the concurrency would be an issue with a streaming library.
10:38:10 <merijn> SQL (at least, the non-write statements) is purely functional, after all :)
10:38:18 <ddellacosta> merijn: re: category theory in Haskell, I think the unfortunate truth is that as soon as people see words like "Functor" they assume that Haskell is a morass of abstract nonsense and stop thinking there
10:38:44 <sm[m]> conduit is awesome but a bit too much for someone writing their first haskell program
10:38:56 <merijn> Well, that wasn't really specified :p
10:39:09 <sm[m]> twas, twas
10:39:13 <merijn> The question was "lazy or strict" :p
10:39:15 <dolio> davean: Because streaming libraries don't solve having to not be naive about interleaving your reading and writing to a single file, which is what people blame lazy I/O for.
10:39:35 <merijn> dolio: Nobody claimed streaming libraries solved "all problems ever" so that seems a bit of a strawman
10:39:36 <davean> dolio: they can dothat.
10:39:37 <geekosaur> that's only one of the problems with lazy I/O
10:39:54 <davean> dolio: for example, only executing the writes to already read parts.
10:40:13 <davean> and delaying the ones to pending reads.
10:40:19 <merijn> Also, I don't think anyone thinks "simultaneous read and writes" is the problem with lazy IO, considering none of the streaming libraries even talk about that in any motivation
10:40:48 <dolio> merijn: Then they should stop using it as an example of lazy I/O being a problem.
10:41:09 <merijn> dolio: I've literally never seen that brought up as a lazy IO problem except just now on IRC
10:41:23 <dolio> Well I've seen it multiple times in the past on IRC.
10:42:30 <davean> dolio: to be clear I brought it up about lazy vs. strict io, not streaming. Streaming systems can't solve problems without you deciding what you want.
10:42:32 <sm[m]> lechner, please ask less controversial questions in future (j/k :)
10:42:39 <merijn> Yes
10:42:48 <merijn> Like "how do I get 'a' out of 'IO a'?" ;)
10:43:11 <davean> merijn: well, you just pattern match on (# RealWorld, ... #) ...
10:43:42 <merijn> ;)
10:43:56 <davean> Or use the Comonad instance of IO
10:44:25 <davean> which is easy to write with unsafePerformIO
10:44:29 <davean> laws aside
10:44:38 <tomsmeding> :D
10:44:52 <monochrom> http://www.vex.net/~trebla/photo/unorganized/IO-String.png
10:45:07 <dolio> davean: Yeah, I know. It's more in the past I've seen people not really being coherent about this stuff.
10:45:45 <davean> dolio: I know 'machines' can solve the ordering issues easily (thats what I use seekable-machines for half the time), and I suspect you could with 'pipes' though I never have.
10:46:13 <geekosaur> well, now you have the answer to why people talk about haskellers not being simple, at least :)
10:46:19 * hackage uniqueness-periods-vector-examples 0.5.0.0 - Examples of usage for the uniqueness-periods-vector series of packages  https://hackage.haskell.org/package/uniqueness-periods-vector-examples-0.5.0.0 (OleksandrZhabenko)
10:46:21 <davean> dolio: you can pretty easily impliment an ARES machine :)
10:46:28 * monochrom perpetuates the myth that you need to understand category theory jokes to learn haskell
10:46:28 <davean> I mean as easy as ARES is!
10:46:57 <monochrom> Sorry, what's ARES?
10:47:02 <dolio> I imagine you _can_ solve them with most libraries, but I don't expect 'oops, I wrote naive interleaved input/output processing and used it on a single file' to automatically work in most of them.
10:47:55 <dolio> Like, passed the same file name twice.
10:48:27 <davean> monochrom: sorry ARIES
10:48:59 <monochrom> Thanks, but I don't know ARIES either.
10:49:11 <davean> Oh http://db.csail.mit.edu/madden/html/aries.pdf
10:49:16 <davean> Its the thing DBs do
10:49:16 <monochrom> thanks
10:49:48 <monochrom> hahaha "exploiting semantics"
10:55:00 <monochrom> OK, so "ACID" was already a thing in 1992, not a web bubble invention. I feel better now.
10:55:19 <davean> Yes, I take it you know nothing about DBs at all?
10:55:30 <monochrom> I know nothing about DBs.
10:55:40 <c_wraith> I expect ACID would date back to the 70s
10:55:47 <davean> The web bubble *got rid of* ACID
10:55:51 <davean> c_wraith: yah, it does
10:56:01 <davean> ACID is one of the basic concepts of ... well computing really
10:56:13 <davean> It does come from the DB world though.
10:57:10 <davean> as an acronym
10:57:18 <davean> OS people had it too, but not as well codified
10:57:23 <merijn> monochrom: I'm surprised ACID is as recent as 1992, I would've expected much older
10:57:33 <davean> merijn: it is much older
10:57:44 <davean> it predates non-heirarchical DBs
11:00:22 <davean> I've read papers from <1975 that specified that set of requirements
11:00:36 <davean> I think the actual term is circa 1980 though since people got tired of writing out the laws eventually ;)
11:02:23 <davean> databases, filesystems, transactional memory, concurrency, all sorta the same problem.
11:02:58 <davean> Not distributed systems though, thats its own f-ed up mess
11:03:49 * hackage uniqueness-periods-vector-stats 0.1.2.0 - A very basic descriptive statistics.  https://hackage.haskell.org/package/uniqueness-periods-vector-stats-0.1.2.0 (OleksandrZhabenko)
11:12:08 <dolio> You mean, a lot of seemingly different topics lead to people coming up with the same sort of idea, and it might be useful to abstract those ideas in a common way so that ideas from one topic might be applicable to others?
11:13:19 * hackage uniqueness-periods-vector-examples 0.5.1.0 - Examples of usage for the uniqueness-periods-vector series of packages  https://hackage.haskell.org/package/uniqueness-periods-vector-examples-0.5.1.0 (OleksandrZhabenko)
11:13:25 <davean> dolio: they just are applicable. The optimal solutions for the different domains vary by the constraints but the problems are the same.
11:15:00 <davean> ARIES is stronger than STM needs, but its solving the same thing in a similar way and the problem setups are the same other than some of the tools they have to solve it with.
11:15:04 <davean> for example
11:15:19 * hackage commonmark-pandoc 0.2.0.1 - Bridge between commonmark and pandoc AST.  https://hackage.haskell.org/package/commonmark-pandoc-0.2.0.1 (JohnMacFarlane)
11:15:24 <davean> and filesystems are even closer, though they don't deal with the out-of-space issue as much because they know their transaction sizes.
11:15:46 <dolio> Yeah, those domains are probably too obviously similar.
11:15:56 <davean> And all that is a constrained case of concurrency
11:16:29 <davean> Mind you basicly every filesystem has had a bug releated to the parts it strips out of ARIES
11:19:06 <davean> Most of computer science is boring because its the same problem solved 10 times.
11:19:18 <davean> if you just learn the base problem you can solve a bunch of them on demand. :(
11:19:34 <Uniaika> like multiplying matrices very fast
11:19:48 <Uniaika> a bunch of modern machine learning and stuff are based on multiplying matrices
11:20:34 <davean> Uniaika: which brings me to the fact that Data.Ix.Ix lacks "rangePos :: (a, a) -> Int -> a" which makes doing suck with 'array' difficult!
11:20:47 <davean> s/suck/such/
11:22:19 <Uniaika> davean: it's only one MR away from reality
11:22:25 <davean> Uniaika: incorrect.
11:22:31 <Uniaika> okay maybe two.
11:22:34 <Uniaika> :P
11:22:38 <davean> Uniaika: No. Its a core library.
11:22:47 <davean> and a Haskell Report type class. 
11:22:56 <davean> In theory we *should* get a new report to change it.
11:23:07 <davean> in practice we'd still have the "we changed something in base" fight.
11:23:37 <davean> Data.Ix isn't a 3rd party library :/
11:25:10 <Uniaika> yeah that's right
11:25:23 <davean> If I could just submit a MR I'd have already done it.
11:25:27 <davean> this is core infastructure
11:25:45 <davean> It has a trivial default implimentation from what the type class already provides.
11:26:18 <davean> I wish people were more accepting of changes to 'base'
11:26:29 <davean> Theres a lot to improve
11:28:04 <davean> Haskell needs to accept more changes to 'base' IMO, yes people feel a tiny bit of pain in the short term but its mostly a shared burden thats not actually that much time to update all of hackage to, and then we've got something better forever. 
11:28:10 <Uniaika> we should make secession from the standard
11:28:20 <Uniaika> or make it evolve with the current times
11:28:24 <davean> Uniaika: its not the standard that's really the problem
11:28:31 <davean> Uniaika: There was supposes to be a Haskell2020
11:28:46 <Uniaika> CSS3 had it right I think, by having mutiple standards that can evolve and stuff
11:28:54 <davean> Uniaika: Theres a report committee. Its not like the report can't change. I'd say the screaming about changes is the real problem.
11:29:01 <Uniaika> davean: Haskell2020 failed us :P
11:29:16 <davean> It failed us because no one wanted changes people could get behind :-p
11:29:24 <Uniaika> :)
11:29:44 <davean> Uniaika: were you not here for AMP and F/T?
11:30:29 <davean> Haskell2020 can get unjammed if people get behind changes.
11:32:05 <Uniaika> AMP was in 2014
11:32:36 <davean> yes, yes, I know. Some people are only returning to Haskell now because they were so driven off by the screaming of people resisting such a basic change.
11:32:55 <davean> Thats my point
11:33:10 <davean> if people aren't over AMP 6 years later we can't have nice things.
11:33:19 * hackage uniqueness-periods-vector-examples 0.5.2.0 - Examples of usage for the uniqueness-periods-vector series of packages  https://hackage.haskell.org/package/uniqueness-periods-vector-examples-0.5.2.0 (OleksandrZhabenko)
11:33:37 <Uniaika> yeah sorry, so I was not in Haskell-land at that time
11:33:53 <davean> It was rediculous.
11:34:47 <Uniaika> I can imagine
11:35:00 <Uniaika> and look where we are now! A complete wasteland!
11:35:06 <Uniaika> Haskell is dead because of that!
11:35:08 <Uniaika> (/s)
11:35:20 <MarcelineVQ> meet the new boss, same as the old boss
11:35:22 <dolio> Because of which direction? :)
11:35:44 <monochrom> The other wasteland is not greener. >:)
11:36:12 <davean> Uniaika: it sapped a lot of the people pushing new things I was here for because it was so hard to get and they needed more to move further.
11:36:17 <davean> Uniaika: so uh, it kinda is?
11:36:24 <davean> I mean as a language its fine
11:36:30 <davean> but we've not moved forward much.
11:36:39 <davean> So ...
11:36:44 <MarcelineVQ> What is the metric for that?
11:37:04 <Uniaika> looks like we need to get our skin harder for the next feces slinging
11:37:09 <davean> MarcelineVQ: enabling me to do new things that make solving problems better :-p
11:37:41 <Uniaika> :)
11:37:47 <merijn> The problem with Haskell2020 is that the "fun stuff" people wanna do is not the blocker
11:38:04 <merijn> The blocker is the need to specify the semantics of a bunch of things beyond just 'what GHC does"
11:38:13 <davean> merijn: For a larger report, yes
11:38:35 <lechner> dmwit: thanks for the link earlier. i read it twice, and it was very helpful!
11:38:51 <davean> merijn: theres various potential scopes.
11:38:55 <merijn> Everyone says stuff "we should add existentials to the report!", but actually going through the work to specify how they should work is an annoyance no one wants :p
11:39:18 <Uniaika> (would they even be useful??)
11:39:32 <Uniaika> (no wait, scratch that, it's just ignorance talking)
11:39:40 <merijn> What?
11:39:45 <dolio> Can we get DeriveFunctor?
11:39:50 <merijn> Existenials are plenty useful
11:39:52 <davean> Can we get ScopedTypeVariables :-p
11:40:00 <davean> I want to be able to write type signatures :-p
11:40:06 <merijn> I'm not convinced about SCTV by default
11:40:18 <merijn> Unless it includes the explicit forall to use
11:40:19 <dolio> Does 2010 let you write quantified types?
11:40:54 <ski> (having the explicit `forall' was a mistake, imho)
11:40:58 <Uniaika> davean: existentially or universally? :P
11:41:04 <Uniaika> ski: are you speaking of PureScript?
11:41:08 <dolio> If not, seems like you could add it the way GHC does it.
11:41:11 <davean> Uniaika: I don't think you're talking to me.
11:41:13 <ski> no, `ScopedTypeVariables'
11:41:16 <Uniaika> err, I meant dolio
11:41:21 <Uniaika> ski: ok
11:41:30 <Uniaika> davean: yeah sorry :)
11:41:49 <tomsmeding> sm[m]: any new edits to pastes made from now on will be tracked like in this one: https://paste.tomsmeding.com/Lo6fyJsD
11:42:03 <monochrom> Ah, even Haskell 2010 itself is extremely sketchy on both type checking ("oh it's just folklore HM with folklore type classes") and dynamic semantics ("oh it's just folklore non-strict lambda calculus").
11:42:25 <ski> Uniaika : imho, it's backwards. with `ScopedTypeVariables' enabled, the free variables in the signature ought to be in scope in the definition, unless they're explicitly quantified by `forall' :)
11:42:33 <dolio> Uniaika: I'm not sure Haskell 2010 lets you write explicit 'foralls' I mean.
11:42:41 <merijn> It doesn't
11:42:45 <monochrom> There is no way (or no need? heh heh heh) you can specify ScopedTypeVariable at that rate.
11:42:46 <davean> ski: I agree
11:42:55 <Uniaika> I see :)
11:43:42 <davean> monochrom: You just do it. if its compiled Haskell2020, its ScopedTypeVariable without forall. Set language Haskel2010 in your cabal file if you haven't updated your code, oh you already have to set that so do nothing.
11:43:42 <tomsmeding> ski: yes please
11:43:43 <dolio> ski: Are foralls required on top-level signatures?
11:43:52 <ski> nope
11:44:39 <monochrom> No, I mean specifying what ScopedTypedVariable means.
11:45:00 <monochrom> IOW merijn's sense of "specify".
11:45:14 <davean> monochrom: ooh, I mean you can specify it as well as Haskell's types are specified :)
11:45:42 <dolio> Maybe they're already compatible with Haskell 2010. :P
11:46:10 <monochrom> To a large extent every GHC extension paper is of much higher quality than Haskell 2010 quality.
11:46:40 <monochrom> Every such paper painstakingly writes down typing rules. There is none in the Haskell Reports.
11:46:48 <sm[m]> nice tomsmeding 
11:47:18 <davean> It would be nice if one could clean-room impliment Haskell from the report without other knowlege than how to read it and anything explicitely referenced. We don't have that.
11:47:26 <tomsmeding> (formatting is debatable)
11:47:28 <davean> Requiring that is a weird standard to update other parts of the report.
11:47:42 <monochrom> At this rate, adding most GHC extensions to the next Haskell Report is trivial, just write down the syntax, there is no need to write down the typing rules or the dynamic semantics, thus "no need", har har har.
11:48:40 <geekosaur> monochrom, the downside is that the typing rules often assume ghc's internal type system, which I'm not sure anyone wants to take as the basis for a Haskell standard
11:49:19 <maerwald> tomsmeding: how do you download a paste?
11:49:28 <geekosaur> and nobody wants to do the work to specify a minimal type system for the Report
11:49:43 <tomsmeding> maerwald: there's the [raw] link for the first file
11:49:53 <maerwald> tomsmeding: I mean all files
11:49:58 <davean> geekosaur: right.
11:50:03 <tomsmeding> you don't, currently :p
11:50:13 <tomsmeding> how would you expect that to work, zip file?
11:50:20 <dmwit> ski: Counterpoint: the obvious alternative is for forall to take the variable out of scope. But foralls are overloaded now to also be part of the TypeApplications API.
11:50:24 <tomsmeding> also how often do you really need that
11:50:35 <lechner> Hi, why do I have to use the <- assignment operator on the result from getArgs, but not on the result from readFile, please? I see that the readLine result is not 'tainted' by the IO monad, but I do not otherwise see a distinction between these commands vs expressions. 
11:50:39 <dmwit> ski: So that seems like it would be sort of a bad conflict in what you're able to express.
11:51:02 <dmwit> lechner: You *do* have to use <- on the result from readFile. Why do you believe you don't?
11:51:10 <wwwww> Let's say i would like to run something with forkIO, in OSX only single thread spawns but in linux there are many of them, why? 
11:51:17 <Uniaika> < geekosaur> and nobody wants to do the work to specify a minimal type system for the Report // yeah, it takes time, effort and coordination, and I feel like we're too much in maintenance mode for that kind of thing to happen
11:51:18 <dmwit> lechner: Also, I challenge your claim that readLine is not 'tainted'.
11:51:50 <lechner> never mind, i thought i passed the result directly to putStr when i fact I placed a =<< in between
11:51:51 <dolio> wwwww: No threaded runtime maybe?
11:51:55 <dmwit> wwwww: Perhaps the compiler you're using on Linux has defaulted to the threaded runtime, but the one on OSX hasn't?
11:52:08 <maerwald> tomsmeding: tar.gz
11:52:11 <davean> wwwww: forkIO is not forkOS
11:52:27 <wwwww> I know they are different but i get same result
11:52:30 <maerwald> zip is trash
11:52:39 <lechner> does <- force an evaluation, in some sense ?
11:53:04 <tomsmeding> maerwald: fair :p
11:53:10 <dmwit> lechner: No, it forces an execution.
11:53:17 <tomsmeding> how many times have you wanted such functionality already
11:53:24 <maerwald> all the time man
11:53:31 <ski> dmwit : hm, point. however, if we get `foo @a ... = ..a..', then that could be combined with `foo :: forall a. ..a..'
11:53:33 <davean> wwwww: forkIO is a greenthread.  Why would it produce a new OS thread generally? Thats a RTS decision.
11:53:41 <lechner> dmwit: in the world of haskell, that's not the same thing?
11:53:51 <dmwit> lechner: "evaluation" is the process of reducing expressions to other expressions. "execution" is the process of submitting terms to the runtime system to request that effects be performed.
11:53:57 <davean> lechner: not at all the same.
11:54:19 <dmwit> ski: Neat idea!
11:54:32 <tomsmeding> maerwald: personally I'd barely ever use it, only on the wildest pastes with >3 files, but I guess other people work differently :p
11:54:42 <monochrom> Well, beginners from imperative backgrounds do not already know that, or why, we need two separate "eval" and "exec" notions.
11:54:45 <dolio> lechner: It's kind of jargon invented here.
11:54:59 <ski> dmwit : i dunno whether it will happen, but i can still complain about it ;)
11:55:01 <dolio> People tend to use it before explaining it for some reason. :)
11:55:04 <dmwit> ski: Hm, I'm not sure I understand that, though. How is the order of variables determined from `foo @a ... = ...`?
11:55:11 <merijn> davean: eh, note that forkOS doesn't spawn an OS thread either
11:55:12 <geekosaur> I've used the gist.github.com equivalent a few times. Not often, but I also haven't encountered that many multi-file pastes
11:55:18 <lechner> dmwit: doesn't an execution necessitate an evaluation?
11:55:20 <monochrom> So you need to be gentle in the sense that you can't just paint it as "everyone else already knows" truth.  Every else doesn't already know.
11:55:21 <dmwit> ski: Are you suggesting that the `a` in `@a` must have the same name as in the type signature?
11:55:26 <ski> dmwit : `foo :: forall a. forall b. ..a..b..; foo @a @b ... = ...'
11:55:27 <dmwit> lechner: Very often, yes. But not always.
11:55:30 <ski> dmwit : no
11:55:36 <davean> merijn: yes, I was getting there.
11:55:59 <dmwit> ski: Then I don't understand how it helps clear up the conflict I proposed.
11:56:01 <davean> merijn: threading is hard
11:56:02 <monochrom> The next surprising divergence will be how, and why, parsing is different from eval order.
11:56:02 <wwwww> I tried forkOS/forkIO and as result still i have single thread in OSX davean
11:56:11 * tomsmeding notes that the people coming here complaining that the channel is quiet should probably return during US waking times
11:56:17 <dmwit> ski: If forall is used both for variable hiding and variable order, how to I express the order of unhidden variables?
11:56:25 <davean> wwwww: sure, but my point is theres no reason to tihnk either of them would create a thread in particular.
11:56:29 <lechner> i guess commands can perhaps expect an expression, too
11:56:31 <davean> wwwww: How many threads is an RTS decision
11:56:32 <merijn> wwwww: What are you trying to do?
11:56:32 <geekosaur> what are you using to determine threads? they look different in OS X vs. Linux
11:56:39 <davean> which is what the RTS options are about.
11:56:45 <monochrom> Europe waking time is also pretty active here.
11:56:46 <ski> dmwit : `zip :: forall a. forall b. [a] -> [b] -> [(a,b)]; zip @u @v (xs :: [u]) (ys :: [v]) = ..u..v..xs..ys.' should be fine
11:56:50 <davean> geekosaur: yes, process vs. not
11:56:54 <geekosaur> in particular, on linux they show up in ps becuase of how linux implements threads
11:57:15 <ski> dmwit : each defining equation could name the type parameters differently, if it wanted to
11:57:15 <wwwww> merijn: i'm building server for my game
11:57:19 <dmwit> ski: Ahhh, so the foralls give the order, and the @ patterns give what's hidden?
11:57:25 <dmwit> (well, what's not hidden)
11:57:25 <ski> yes
11:57:34 <dmwit> Got it! Very sensible.
11:57:35 <davean> ski: I like that.
11:57:40 <davean> ski: Please give!
11:57:44 <tomsmeding> monochrom: apparently the Europeans are active in the evening then :)
11:57:44 <ski> give ?
11:57:49 <merijn> wwwww: "I need to concurrently handle many connections" (that's what forkIO is for) and "I need multiple OS threads" are orthogonal issues
11:58:03 <davean> ski: please give me that as how I get to do it :)
11:58:04 <dmwit> ski: I think he's asking you to implement it and send him a patch. ^_^
11:58:17 <merijn> wwwww: You can spawn many threads handling independent conncections using a single OS thread, using multiple OS threads is optional
11:58:57 <ski> dmwit : alternatively, you should be able to say `zip :: [a] -> [b] -> [(a,b)]; zip (xs :: [a]) (ys :: [b]) = ..a..b..xs..ys..', of course. but then the order of the type parameters isn't clear (as is already the case with implicit `forall')
12:00:39 <ski> hm .. i suppose, if this would have any chance of being accepted, it would probably be a differently named language extension than `ScopedTypedVariables'
12:00:59 <dolio> ski: Yeah, that's the problem.
12:01:06 <maerwald> south-east asia time is pretty silent
12:01:06 <dolio> Too late to fix the design.
12:01:13 <davean> NonGrungyScoping
12:01:25 <ski> yea. i remember i complained about this, when i first learned of `ScopedTypedVariables'
12:01:44 <davean> yah, ScopedTypeVariables is exactly the opposite of what makes sense.
12:01:54 <davean> its one of the reasons it has to be a report thing to clean it up.
12:02:09 <davean> Things have rotted because of it being an extension.
12:02:13 <monochrom> BoundTypeVariables
12:02:13 <ski> also .. i'm missing `PatternSignatures' ..
12:02:31 <dolio> The only way it makes 'sense' is that it doesn't change the meaning of any Haskell 98 programs.
12:02:47 <davean> dolio: which is exactly what we have a report to do!
12:03:12 <dmwit> But there are other extensions which change the meaning of Haskell 98 programs.
12:03:30 <davean> Yah but I think they're all much newer?
12:03:35 <dolio> Yeah. GHC tries to avoid it a lot, though.
12:03:36 <dmwit> MonoLocalBinds or whatever that one's called, ExtendedDefaulting, etc.
12:03:38 <ski> first, sometimes i want to write stuff like `zip (xs :: [a]) (ys :: [b]) :: [(a,b)] = ..a..b..xs..ys..', annotating the return type directly (not after the body)
12:04:08 <dolio> Almost everything is designed to be a sort of conservative extension.
12:04:17 <ski> second, i'm not sure this would have to be mixed in with the explicit `forall's, and explicit type applications, extensions
12:04:55 <monochrom> There was a time Haskell Reports made good-bye-to-the-past changes. (I refuse to say "breaking changes".)
12:04:55 <ski> (also, i suppose, existential arguments)
12:05:18 <dolio> If only people had decided change was bad in 1.4. :)
12:05:39 <monochrom> In particular especially transitioning from the [Response]->[Request] I/O system to today's IO I/O system.
12:05:40 * ski . o O ( `map',`(++)',monad comprehensions,`Eval' )
12:05:52 <monochrom> Yeah that one.
12:06:17 <monochrom> Look at how there was not even a bridging library offered.
12:07:08 <monochrom> The types Response and Request simply vanished in a puff of logic. Old code simply couldn't be re-compiled.
12:07:12 <wwwww> But still it doesn't explain why my program runs with more threads in linux rather than osx which only spawns single thread, i'm using stack so there should be no compiler or any configuration difference except stack version, merijn 
12:07:21 <monochrom> We need that bravity again today.
12:07:55 * geekosaur asks again: how are you determining how many OS threads are used?
12:08:23 <ski> dmwit : btw, in case it wasn't clear, i was suggesting both styles of defining (in the example) `zip' above should be possible. both with explicit `forall' (not scoping over defining equations), possibly combined with type application patterns, and implicit `forall', tyvars scoping over definition
12:08:58 <monochrom> Yeah I only get one thread in Linux, unless I go out of my way to use non-default settings.
12:09:07 <dolio> I wonder how many people were using [Response] -> [Request]. There was also the continuation-based wrappers, which were basically monadic IO with different types.
12:10:09 <ski> not sure, but i'd suspect more were using the CPS, since it was easier to get compositional
12:10:24 <geekosaur> +RTS -N, which I think requires building with --rts-options
12:10:35 <dolio> Yeah, it seems like the CPS stuff would be obviously superior.
12:10:35 <ski> (and also to not get out-of-synch, or premature-forcing, bugs)
12:10:45 <geekosaur> (but I'd expect more than one thread anyway due to the I/O manager using several internally)
12:11:26 <monochrom> But multiple OS threads requires firstly someone explicitly saying "-threaded" at link time.
12:11:51 <dmwit> wwwww: Didn't my very first response from ages ago propose an explanation for that? I feel as though dolio and I have been ignored this whole time.
12:11:58 <ski> hm, i thought i saw a dialogue-based I/O implemented on top of `IO' (using lazy I/O), some time ?
12:12:16 <merijn> You can just set the number of threads from the code, though
12:12:24 <dmwit> Only if you have the right runtime.
12:12:27 <monochrom> OK I'm out of that threading question because geekosaur's question nails it.
12:12:29 <merijn> true
12:12:42 <lechner> If anyone is using Debian: In which -dev package can i find one of the apparently many SHA-512 cryptographic primitives available in Haskell, please?
12:12:44 <ski> (but then there's the extensibility problem over the raw response-to-request mapping, especially wrt FFI)
12:14:37 <monochrom> ski: Do you have "interact" in mind? Or is it one of those free monads?
12:14:41 <sm[m]> lechner: why do you want a debian -dev package, did the haskell package give a build error ? If so you could paste that
12:15:16 <ski> monochrom : something along the lines of it, but more involved, to deal with the richer `Request' and `Response' types
12:15:41 <geekosaur> we tend to prefer getting packages from hackage or stackage over using OS packages, because the latter are often old
12:15:58 <geekosaur> and stack will usually ignore them anyway
12:16:53 <sm[m]> oh, I wasn't sure if they are looking for a debian c package or a debian haskell package
12:16:53 <wwwww> dmwit: Forgive me, you gave me good point for further research about this kind of thing, but one of the reason i use stack instead of just ghc is avoid this kind of situations, i provide my compiler version in one of those .yml files and program should behave same in every platform, at least thats what i expect
12:17:16 <lechner> sm[m]: i'll use stackage. i am just trying to figure out how 
12:17:35 <dmwit> Well, that just seems naive.
12:18:00 <dmwit> I'm not even sure what "behave same" even means, TBH.
12:18:06 <sm[m]> wwwww: did you answer the question about how you're counting threads ? 
12:18:58 <dmwit> You need some theory of observations that accounts for the differences between OS's, and then some relation describing "same" observations on the two. Seems complicated to set that all up carefully.
12:19:29 <wwwww> sm[m]: i'm watching the htop and i hope it is the right way to count them
12:19:35 <dmwit> e.g. look at Wine, an attempt to formalize the connection between Windows observations and Linux observations. It is many hundreds of megabytes of description to get that right.
12:20:32 <monochrom> I wouldn't say it's hundreds of megabytes. I would follow Shannon's advice and gzip it. Then that's a better measure. >:)
12:20:53 <davean> wwwww: except also the platform isn't the same and you're asking a platform thing.
12:21:07 <dmwit> It's certainly more than what you would comfortably transmit into an IRC channel full of people...
12:21:53 <davean> monochrom: several thens of megabytes then :-p
12:21:59 <sm[m]> wwwww: cool. You know about htop's setting for showing just processes or all threads, I guess
12:22:02 <monochrom> Yeah!
12:22:05 <iqubic> What packages do people recommend for writing Haskell code in Emacs on NixOS?
12:22:25 <lechner> on the subject of stackage, is the advice given from here usually sounds?  https://www.fpcomplete.com
12:22:29 <maerwald> iqubic: packages?
12:22:36 <maerwald> emacs packages?
12:22:53 <iqubic> yeah. I want to know which Emacs Packages people recommend.
12:23:11 <sm[m]> lechner: certainly, that's the home of stack
12:23:13 <davean> monochrom: I'm sorry, its split between a bunch of pieces but its at least 50MiB compressed. Can we round?
12:23:32 <davean> monochrom: I'm tired of addig up package sizes at 50MiB :-p
12:23:33 <lechner> iqubic: https://wiki.haskell.org/Emacs ?
12:23:36 <monochrom> Yes, no need to be very precise.
12:23:47 <dolio> davean: The slackware download is like 67MB.
12:23:59 <davean> dolio: Ok, maybe I almost got to the end.
12:24:21 <iqubic> Is lsp-haskell still under development?
12:24:47 <dolio> Thank goodness slackware still apparently exists.
12:24:57 <sm[m]> iqubic: I think it's called haskell-language-server (or hls) now, unless that's something else. And it's under very active development in #haskell-ide-engine
12:25:09 <iqubic> Is it ready for personal use?
12:25:11 <monochrom> Well if COBOL still lives, why not slackware too. :)
12:25:26 <merijn> iqubic: Define ready :p
12:25:28 <davean> monochrom: I don't know people being paid $500/hour to use slackware.
12:25:38 <sm[m]> iqubic: actually yes, I would say it is, using VS Code and hls 0.4 release
12:25:48 <iqubic> Is it better than https://github.com/jyp/dante?
12:25:50 <monochrom> And WinFax for that matter.
12:25:58 <sm[m]> yes, it's better than everything so far
12:26:05 <iqubic> sm[m]: I'm planning on trying to use it with emacs and nix.
12:26:12 <davean> monochrom: If people were being paid $500/hour to use slackware I'd be pretty confident in its continued existance.
12:26:27 <sm[m]> iqubic: I'm not going to say that's ready, that's a whole nother ball game :)
12:27:21 <wwwww> sm[m]: i didn't know that setting
12:27:25 <monochrom> davean, there is something wrong with using only the job market as the only indicator, but I can't articulate why.
12:27:33 <iqubic> So, hls is only really ready for use with VS Code, and not really ready for use wiemacs?
12:27:35 <merijn> Ready is a matter of how much pain you're willing to put up with :p
12:27:55 <merijn> iqubic: I mean ghcide (which hls is built on) works fine for me in vim
12:28:21 <iqubic> I don't want to put up with much pain. I want a tiny little bit of pain only.
12:28:22 <merijn> iqubic: Is it ready in the sense of "I wanna press a single button with 100% success rate of everything working"? Probably not.
12:28:34 <davean> monochrom: Its a touch different than that, people getting paid $500/hour to use a thing tend to make sure said thing keeps existing.
12:28:34 <rednaZ[m]> iqubic: If you want to be on the safe side, use `haskell-mode` and `eglot` with ghcide (https://github.com/haskell/ghcide#eglot)
12:28:58 <iqubic> I think I'll just stick with Dante. It seems to work well enough for me.
12:29:27 <merijn> davean: If I got paid 500/hour to do C I'd still wipe it off the planet if I could ;)
12:29:47 * geekosaur doesn't think that worked for Solaris
12:30:06 <merijn> s/Solaris/Illumos :p
12:30:13 <wwwww> sm[m]: for a moment i tought i was counting wrong but no
12:30:20 <davean> geekosaur: you only wish Solaris was gone.
12:30:30 <sm[m]> wwwww: yes, the H and K keys. Though for whatever reason, on mac it seems to alway show the threads, unlike on linux
12:30:38 <merijn> Solaris is better than Linux in tons of ways >.>
12:31:03 <davean> merijn: All POSIX systems are crap.
12:31:33 <davean> But at least Solaris didn't come last and then make mistakes that every predicesor made sure to avoid.
12:31:33 <merijn> Sure
12:31:39 <merijn> But some are more crap than others :p
12:31:49 <davean> *cough*epoll*cough*
12:31:53 <merijn> davean: Ah, I see you too hate epoll
12:31:54 <merijn> Hah
12:31:55 <sm[m]> wwwww: if you want to get to the bottom of it, you should probably create a minimal reproducible example, and show screenshots/pastes of your build/run commands and the results on both platforms as well
12:32:05 <merijn> davean: God, epoll is such an embarassment
12:32:24 <merijn> davean: Imagine if linux had just implemented kqueue and we could've used that portably acorss linux, macOS, and BSD :(
12:32:51 <davean> merijn: oh, oh, you want to only put epoll into the "braindead things linux did that litterly no one else was stupid to do, and was conciously aware would be a bad idea"?
12:32:58 <davean> merijn: because I have a whole list ...
12:33:28 <merijn> davean: Naah, but it's the one that springs to mind most easily :)
12:33:45 <wwwww> sm[m]: probably thats how i will endup but i don't really care about osx, it's nothing but very advanced dvd player
12:33:48 <monochrom> Sorry, why is epoll a bad idea?
12:33:51 <MarcelineVQ> What is the correct solution to the problem epoll tries to solve?
12:33:58 <davean> (I really don't know how Linux devs manage to make so many actively bad decisions that why and how they're bad are so well established when they copy other people's work)
12:34:06 <davean> MarcelineVQ: because it can never be used corretly.
12:34:12 <davean> er, monochrom 
12:34:15 <sm[m]> iqubic: what merijn said. Recently I found researching & debugging the emacs packages & setup at the same time as hls to be just too much. The VS Code setup is waay more polished and easier, removing lots of failure modes.
12:34:24 <merijn> monochrom, MarcelineVQ: https://idea.popcount.org/2017-02-20-epoll-is-fundamentally-broken-12/
12:34:33 <merijn> davean: Well, it can now
12:34:44 <merijn> If you know about the pitfall and use the right magic flag combination!
12:34:51 <iqubic> I see. I'm going to keep using Dante for the time being.
12:34:54 <davean> merijn: uh ... last I knew there were a few issues still.
12:35:19 <merijn> Oh, possibly, but the the oneshot/exclusive flags fix the most glaring problems
12:35:48 <davean> Yah but thats hardly the extent of it
12:37:56 <merijn> monochrom: The damning thing is that Solaris ran into this issue, BSD then designed kqueue to not have the same problems, Windows' IO Completion Ports also work correctly and then after there had been 2 designs that correctly handle all the issues linux decides to, instead of adopting kqueue or the IOCP design, design their own system call that is gratuitously incompatible with kqueue *and* has the issues 
12:38:02 <merijn> that kqueue and IOCP were designed to not have
12:39:23 <davean> Can we mention inotify here?
12:39:36 <davean> Because thats also fundimentally broken in a way you can never use it correctly.
12:39:41 <geekosaur> must we?
12:39:46 <davean> in a way everyone else also got right before it came into existance.
12:40:13 <davean> Fun fact: I have haskell packages that pass on all systems except linux because they detect the bugs in Linux.
12:40:20 <davean> (their test cases)
12:42:31 <sm[m]> I'm learning a lot of bad things in #haskell today.. is there no hope for linux to get fixed, then ?
12:42:39 <davean> sm[m]: no
12:42:41 <merijn> Not really
12:42:52 <merijn> It'd break kernel API which is deathly sin according to Linus
12:43:02 <davean> merijn: well they could add kqueue
12:43:08 <davean> and kqueue covers inotify
12:43:11 <davean> unlike epoll
12:43:21 <merijn> sm[m]: You're simply learning that, despite the internet memes about Linux' "superior engineering" it is a rather shoddily engineered OS, tbh
12:43:47 <davean> merijn: Yah, its the lowest code quality of any POSIX I know of.
12:44:07 <davean> Its like they let just anyone submit code.
12:44:21 <MarcelineVQ> time for plan9 to come to dominance
12:44:32 <cohn> I prefer FreeBSD personally, but Linux gets the job done when I need it to.
12:44:35 <davean> POSIX is fundimentally flawed but Linux goes out of its way to be worse
12:44:57 <merijn> anyway, we drifted slightly offtopic :p
12:44:58 <davean> cohn: yah, I have a few things on FreeBSD for the reason of Linux's issues and it just working better :)
12:45:09 <cohn> davean: woot!
12:45:48 <cohn> yea, if I could get Docker working reliably on FreeBSD, I'd have zero use for Linux
12:45:54 <sm[m]> surely this toy linux thing will never go anywhere
12:47:18 <sm[m]> also can I just say it's refreshing to see linux bashed in comparison to windows for once 
12:47:34 <davean> sm[m]: hey, windows is pretty bad too.
12:48:00 <merijn> Windows has better engineering than Linux, handsdown
12:48:14 <davean> merijn: yes, but by someone who hates Window's users
12:48:16 <merijn> Doesn't mean they don't make bad decisions, but overall better
12:48:37 <merijn> Anyway, maybe a discussion for -offtopic :p
12:48:40 <geekosaur> but windows went through a significant clean-up between 7 and 8; linux could stand to do the same,but never will (or would get worse as a result)
12:51:52 <maerwald> yes, lets switch all to windows... and then lets talk again
12:52:20 <maerwald> (some thing are only true when you think about it, not when you do it)
12:52:41 <davean> maerwald: no, I'd prefer to be abused via negligence than malice, thanks.
12:53:02 <davean> Microsoft is compitent enough its hard to avoid their abuse.
12:56:25 <energizer> in pattern matching, if i forget to handle a possible case, it wont compile, right?
12:56:31 <lechner> Hi, I saw STACK_ROOT for downloaded packages. How can I redirect 'stack update' to a place other than ~/.local/bin?
12:56:33 <davean> incorrect
12:56:45 <energizer> davean: what happens instead?
12:56:51 <merijn> energizer: It will, but if you use -Wall (and you should) you'll get a warning
12:56:54 <davean> energizer: you can enable -Wall to get warnings about missing cases (or a more specific flag), and -Werror would prevent the compile.
12:57:05 <energizer> what will happen at runtime?
12:57:09 <merijn> energizer: It'll crash
12:57:19 <davean> well, it'll throw an exception
12:57:25 <merijn> (well, throw an exception, but close enough)
12:57:25 <davean> That might not crash it if you handle the exceptions.
12:57:46 <shad0w_> hi all. whats a good second book for haskell ?
12:57:56 <davean> shad0w_: tell me what a good first book is first.
12:58:02 <merijn> Depends, what was the first one and what do you wanna learn
12:58:28 <shad0w_> i am 3/4rths through the graham hutton book. programming in haskell (2nd ed.)
12:59:22 <sm[m]> lechner: stack install is the command that writes there. Have a look at stack install --help
13:00:01 <merijn> shad0w_: And what do you hope to get from this 2nd book that you're not getting from this one?
13:00:13 <sm[m]> lechner: actually it's in stack --help. --local-bin-dir.
13:00:21 <shad0w_> it was quite alright, a little low on details and real world projects though.
13:00:53 <sm[m]> that's my cue!
13:00:53 <sm[m]> @where htac is nice
13:00:53 <lambdabot> "Haskell Tutorial and Cookbook" by Mark Watson in 2017-09-04 at <https://leanpub.com/haskell-cookbook>
13:00:56 <merijn> shad0w_: What sorta details? Like "how this does compile"?
13:00:59 <energizer> thanks
13:02:11 <MarcelineVQ> Best to make something for yourself after reading a book, no book's gonna teach you how to do that truly, you'll only learn how to assemble their specific exercises :>
13:02:56 <merijn> Yeah, I'd say the best way to learn is "just start"
13:03:09 <shad0w_> merijn: not quite. i touched quite a few concepts and the write up for them was not very detailed. i'd be left feeling. hmm. there should be more on this in here, this cant all be it. 
13:03:11 <lechner> sm[m]: stack upgrade also wrote there when I ran it on the outdated 1.71 version from stock debian. it seems an environment variable might be safer than just --local-bin-dir per invocation
13:03:14 <merijn> There's whole bunches of reading for specific topics/things, but best to discover them "as is"
13:03:25 <shad0w_> mostly on the haskell parts that are different from other langs
13:03:33 <shad0w_> like typeclasses and more
13:03:52 <davean> I've only ever got compitent by reading before doing, not really by doing personally. Doing leads to me pattern matching, reading leads to me thinking and understanding.
13:03:52 <merijn> shad0w_: Incidentally, often overlooked/underrated document is just the Haskell 2010 report which should be read by more people than it is :p
13:04:01 <ski> @where report
13:04:02 <lambdabot> http://www.haskell.org/onlinereport/haskell2010/ (more: http://www.haskell.org/haskellwiki/Definition)
13:04:06 <davean> Only when I produce something novel does doing help.
13:04:23 <sm[m]> +1 re Haskell report, also the GHC User Guide and typeclassopaedia
13:04:31 <sm[m]> and base haddock
13:04:37 <merijn> davean: Right, but if you just finish reading a programming book, you should probably try and put it into practice before grabbing a 2nd book :)
13:04:59 <ski> @where Typeclassopedia
13:05:00 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
13:05:03 <shad0w_> MarcelineVQ: i tend to agree
13:05:06 <merijn> You can keep reading until the heat death of the universe, but at some point you gotta do something :)
13:05:30 <shad0w_> just dont really feel im still comfortable with the language enough yet though.
13:05:44 <shad0w_> but then again, that happens by using it more.
13:05:52 <sm[m]> lechner: you're right, stack upgrade writes there too. Maybe there's an env var mentioned in the user guide
13:06:05 <bicho_rastrero> The videos of Erik Meijer from Channel 9 are a good intro. 
13:06:23 <davean> merijn: your experience and mine probably differ.
13:07:06 <shad0w_> my experience tend to lean more towards @davean side aswell.
13:07:14 <shad0w_> tends*
13:07:38 <monochrom> Speaking of which, due to quirks in human minds, the 2nd (and even the 3rd) book doesn't have to be different.
13:07:38 <merijn> shad0w_: Yeah, but "doing stuff and getting stuck" will let you know exactly *what* you don't get yet and then people can point to more specific resources
13:07:53 <shad0w_> so far, i've written down the cookbook, haskell 2010 report and typeclassopedia ?
13:08:01 <davean> typeclassopedia is great
13:08:05 <merijn> @where rwh
13:08:05 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
13:08:11 <merijn> Oh, that's still the old one
13:08:14 <monochrom> In a math channel someone made the great observation that "the 3rd calculus textbook you read is the best".
13:08:23 <merijn> https://github.com/tssm/up-to-date-real-world-haskell
13:08:37 <monochrom> This is only because some people really need the same thing repeated 3 times.
13:08:46 <shad0w_> +1
13:09:08 <merijn> shad0w_: RWH skimps over many language details, but it does have a bunch of real world examples (although the original version's code might have bitrotted due to newer library versions)
13:09:26 <merijn> The high level ideas of "how to write a Haskell application" and the high level library designs remains relevant, though
13:09:33 <shad0w_> i can glue around those, i think ?
13:11:48 <sm[m]> shad0w_: GHC User Guide (and cabal's & stack's, really) and the base package's haddock docs are also worth knowing at least in outline
13:12:42 <sm[m]> maybe it was mentioned, but you also will learn fast by looking at successful FOSS projects and maybe asking for guidance in their IRC rooms
13:13:00 <cohn> ok, silly question time. Combinators are kind of the opposite of Functors, right?
13:13:49 <sm[m]> shad0w_: still more.. doing exercises will build some fluency, project euler did it for me
13:14:14 <shad0w_> okay, these links should keep me busy.
13:14:35 <shad0w_> thanks, you guys are helpful : )
13:14:39 <sm[m]> then there's videos. Really there's too much :)
13:14:42 <lechner> okay, now i have the latest stack and ghc. which SHA512 should i get and how, please?
13:14:58 <shad0w_> you guys hang around here often ?
13:16:09 <shad0w_> sm[m]: i mostly do exercism, but its getting a little repetitive for me. i think i'll give project euler a look too.
13:16:16 <sm[m]> lechner: hoogle can help find some candidate packages: https://hoogle.haskell.org/?hoogle=sha512&scope=set%3Astackage
13:16:54 <drupol> Hello,
13:17:15 <drupol> How can I do "import Data.List.Ordered" in my code ? It doesn't work locally.
13:17:22 <drupol> Could not find module ‘Data.List.Ordered’
13:17:52 <ddellacosta> drupol: how are you building your project?
13:18:13 <drupol> I'm just a beginner, I'm trying to do this example: https://wiki.haskell.org/Prime_numbers#Sieve_of_Eratosthenes
13:18:27 <drupol> I'm building my project in ghci I do: :load Main.hs
13:18:43 <ddellacosta> drupol: are you using cabal, or stack?
13:18:48 <drupol> Stack
13:20:17 <ddellacosta> drupol: so, I'm less familiar with stack, but I think you need to add the data-ordlist dependency to your stack.yaml somehow. Have you done this?
13:21:24 <sm[m]> add it to the .cabal or package.yaml file, rather
13:21:31 <drupol> No, I never had to deal with that stuff yet
13:21:39 <ddellacosta> sm[m]: thanks, I was hoping someone would correct me if I screwed that up...
13:21:55 <sm[m]> if it weren't in stackage, then you'd be right
13:21:58 <drupol> How to create a basic package.yaml file?
13:22:13 <ddellacosta> drupol: so basically what you're trying to use is a package that is not included by default (which is not very clear from the example you're working from, so don't feel like you missed anything)
13:22:18 <sm[m]> drupol, if you don't have one don't bother, use the .cabal file
13:22:47 <ddellacosta> drupol: follow sm[m] 's advice on stack here on out please :-D
13:22:57 <sm[m]> but I guess you don't have a .cabal file either eh
13:23:07 <drupol> No I don't have any of those files indeed.
13:23:11 * sm[m] tag-teams with ddellacosta
13:23:12 <drupol> It's pretty new for me.
13:23:21 <ddellacosta> sm[m]: thanks!
13:24:32 <bicho_rastrero> merijn: The source for "How to write a Haskell application" is https://wiki.haskell.org/How_to_write_a_Haskell_program or did you mean another one? The title is too generic.
13:24:57 <sm[m]> drupol, there are a few ways to get the extra package needed to make that import work. If this is just a one-time experiment, I personally would install it "globally" (stack install data-ordlist) and then use the -package data-ordlist option with ghc & ghci
13:25:15 <drupol> Okay, thanks :-)
13:26:09 <frdg> How can I upgrade from stack 2.3.3 to stack 2.4?
13:26:28 <bicho_rastrero> Dammit.
13:27:12 <drupol> @sm[m] GHCi, version 8.8.4: https://www.haskell.org/ghc/  :? for help
13:27:12 <drupol> <command line>: cannot satisfy -package data-ordlist
13:27:12 <drupol>     (use -v for more information)
13:27:12 <lambdabot> Unknown command, try @list
13:28:08 <sm[m]> drupol: my mistake. stack install data-ordlist && stack exec -- ghci -package data-ordlist Main.hs    ?
13:28:19 <drupol> Trying it out
13:29:24 <drupol> sm[m]: Works flawlessly. Is there a way to automatize this when I run ghc or ghci ?
13:31:04 <sm[m]> several ways. Usually the way is to make a "project" directory with stack init or cabal init. You put Main.hs in there and you add data-ordlist to the list of dependencies in the .cabal file
13:31:26 <sm[m]> and then inside that project dir you can just do stack ghci, stack build etc
13:31:30 <drupol> Going to try the Stack init.
13:32:23 <wwwww> c
13:32:28 <drupol> Ok I have stack.yaml file now :-)
13:33:14 <wwwww> wrong chat
13:34:12 <frdg> here is my problem: I have a server that I ssh into. I would like to run a stack program from this server. How can I transfer the project as a whole instead of having to compile from source? Or should I just install from source?
13:34:12 <frdg> So far I have run into issues trying to re-compile.
13:34:44 <sm[m]> drupol: fair warning, we can advise how to do basic stuff but you will probably get confused and have a horrible time unless you read some of the stack and maybe the cabal user guides
13:35:10 <drupol> extra-deps:
13:35:11 <drupol>   - data-ordlist-0.4.7.0
13:35:15 <drupol> Sure I understand
13:35:19 <drupol> But that is working :-)
13:35:31 <drupol> Thanks!
13:35:48 <sm[m]> np
13:40:15 <sm[m]> frdg: if you can arrange for your build machine and server to be the same architecture and similar os version, you can copy the binary
13:40:50 <sm[m]> if not, you could build inside a vm that's configured like the server
13:41:16 <frdg`> both are x86_64. OS's are the same
13:41:19 <sm[m]> I think people also use "docker" for this, but I don't understand how that all works
13:41:32 <sm[m]> that sounds good then
13:42:04 <frdg`> I ended up getting linux on that macbook :)
13:42:14 <sm[m]> ha, nice
13:42:29 <sm[m]> the binary will depend on some c libs , which should be present on both machines
13:43:02 <frdg`> ok
13:48:23 <ddellacosta> yeah I was going to say nix-copy-clojure or some other form of nix magic, or docker
13:48:41 <ddellacosta> but nix is a big ask if you aren't already familiar
13:48:59 <ddellacosta> I mean, docker is too I guess, but a bit easier to get started with
13:49:58 <ddellacosta> lol nix-copy-closure I mean
13:49:58 <frdg`> how do I create the binaries? Is this done with stack?
13:50:02 <ddellacosta> guess what my day job is
14:09:01 <sm[m]> frdg`: yes, stack build (or stack install which copies them to a more convenient place)
14:10:02 <tomsmeding> maerwald: what tar package would you suggest I use for creating tar files?
14:10:15 <tomsmeding> preferably one that doesn't limit the file name length
14:10:18 <tomsmeding> :p
14:10:23 <walla> ok. I will be able to figure it out from here. I have to figure out how to get the database working and all that first. Thanks for the help as always.
14:11:09 <walla> haha it is fridge from my other computer by accident :)
14:11:11 <walla> frdg
14:22:35 <manjaroi3> How can I generate haddock docs for the Prelude? Or even just for a single module, e.g. Control.Monad
14:24:21 <tomsmeding> is there a tool for generating a dependency tree of hackage packages, by any chance?
14:43:19 * hackage shake-plus-extended 0.4.1.0 - Experimental extensions to shake-plus  https://hackage.haskell.org/package/shake-plus-extended-0.4.1.0 (locallycompact)
14:45:18 <jamestmartin> tomsmeding: if you mean a visualization and not a data structure, then `stack dot`
14:45:41 <tomsmeding> well a data structure is also fine, but visualisation is better :p
14:46:09 <tomsmeding> pity that only works on stack projects
15:03:19 * hackage gi-poppler 0.18.24 - Poppler bindings  https://hackage.haskell.org/package/gi-poppler-0.18.24 (inaki)
15:43:49 * hackage lsp-test 0.11.0.6 - Functional test framework for LSP servers.  https://hackage.haskell.org/package/lsp-test-0.11.0.6 (luke_)
17:04:50 * hackage string-interpolate 0.3.0.1 - Haskell string/text/bytestring interpolation that just works  https://hackage.haskell.org/package/string-interpolate-0.3.0.1 (williamyaoh)
17:59:48 <MrZe> hi
18:01:01 <MrZe> anybody online ?
18:01:10 <MrZe> 2
18:01:30 <yushyin> maybe
18:02:50 <yushyin> over 1000 users are online
18:04:50 <sim590> I have this function http://sprunge.us/3by4Qf which maps a function on some field of a type LBSNode in order to increment it. I'm getting "Pattern match(es) are non-exhaustive" error with "Patterns not matched: (LBSInternalNode _ _)". Why am I getting this error even though I did write `incIndex _` on the next line to cover every other cases?
18:05:47 <root_> exit
18:05:53 <root_> exit
18:06:46 <sim590> Seems like this https://gitlab.haskell.org/ghc/ghc/-/issues/5728 is related?
18:06:52 <MarcelineVQ> sim590: is mapML perhaps not exhaustive?
18:07:38 <lechner> Hi, what's a good way to print a string without double quotes, please? Thanks!
18:08:04 <MarcelineVQ> putStr or putStrLn
18:09:01 <sim590> MarcelineVQ: I don't think so: http://sprunge.us/TKoZBk. And here's mapL: http://sprunge.us/9NIrK4. If you need to go deeper, here's http://sprunge.us/jUAklr.
18:09:06 <lechner> Sorry, it's actually a Data.ByteString.Char8.ByteString
18:09:21 <jumper149> lechner: `print` is the same as `putStrLn . show` https://hackage.haskell.org/package/base-4.14.0.0/docs/src/System.IO.html#print
18:09:38 <lechner> jumper149: yes, but that adds the quotes
18:09:58 <lechner> i currently use putStrLn show 
18:10:04 <jumper149> Was just making sure you understand what each part does!
18:10:23 <lechner> i think the show is not pretty
18:10:45 <sim590> MarcelineVQ: also this: `type LBSTree a = BSTree (LBSNode a)` should clarify things. There's LBSTree, but also BSTree which is the base for the former. But the message is just warning also. It's not an error, but I don't like that.
18:11:17 <jumper149> How about BS.putStr https://hackage.haskell.org/package/bytestring-0.10.12.0/docs/Data-ByteString-Char8.html#v:putStr
18:11:48 <lechner> i am concatenating with ++ so i have to convert first
18:12:26 <jumper149> Also if you use functions on String like Prelude.print and ++ you will lose some of the benefits from ByteString.
18:12:45 <jumper149> I guess you just want it to work and only use bytestring because a library gives it to you?
18:13:02 <MarcelineVQ> sim590: What's the full warning?
18:13:47 <yushyin> lechner: with String use prelude's putStr with Bytestring use Bytestring's putStr
18:14:16 <lechner> I would like to concatenate. last line here:  https://dpaste.com/7RQPNTE63
18:14:42 <sim590> MarcelineVQ: http://sprunge.us/NW5U6N. I'm getting it on two different calls. The first that I pasted and another one lower.
18:15:37 <sim590> MarcelineVQ: here's the whole file if that helps: http://sprunge.us/PxW93j
18:16:36 <sim590> MarcelineVQ: I just tried RecordWildCards but it didn't help me fix it.
18:17:18 <MarcelineVQ> sim590: that's not about the left side pattern that error is pointing at the right side, ghc isn't super smart here so it's being conservative: it's telling you that  "return $ l {index = i+amount}"  could be dangerous because l might be  LBSInternalNode  instead of   LBSLeaf  which doesn't have an 'index' field
18:17:24 <jumper149> lechner: For conversion functions there is pack and unpack in the ByteString library
18:17:31 <jumper149> They will convert from and to String
18:17:42 <jumper149> so for you it would be C.unpack
18:17:48 <divVerent> 135 one seems a false positive as you asserted on the ViewPattern before
18:17:48 <MarcelineVQ> Now, we know better, but it doesn't it looks like
18:18:35 <MarcelineVQ> fyi using record syntax on sum types like this is avoided for that reason, if you forget to make sure what constructor you have your field accesor could crash your program since it might try to get 'index' from LBSNode which doesn't have one
18:18:55 <divVerent> same in the second one
18:19:21 <divVerent> yes, but here technically the compiler should already know which record case is taken
18:19:54 <OmegaDoug> Is there a way in to tell stack where to write the executable when running "stack build"? I'd like to put in the root of the "stack-work" folder.
18:20:05 <sim590> MarcelineVQ: OK, but on line 120, I'm using the "same technique" but it doesn't complain. Am I not?
18:20:24 <sim590> Oh I'm sorry. You said the right side, so it's not the same thing
18:20:37 <lechner> jumper149: thanks!
18:20:49 <sim590> But isn't the type of the right side determined by the left side since l is just the name of the pattern matched?
18:21:29 <lechner> what is the difference between the <- and the =<< operator, please?
18:22:11 <MarcelineVQ> sim590: afaict the issue is that you're updating `l` and `l` might not always have `index` as a field, appearantly pattern matching it didn't inform ghc that `l` is LBSLeaf and thus safe. I think this is weird but is the only explanation I can think of
18:22:12 <ski> lechner : `=<<' is an ordinary operator, defined in a library. `<-' is special syntax, like `=' or `::'
18:22:16 <jumper149> lechner: First of all <- is a keyword and part of the do-nation and =<< is a function
18:22:37 <ski> @type (=<<)
18:22:39 <lambdabot> Monad m => (a -> m b) -> m a -> m b
18:23:47 <ski>   f =<< act = do x <- act
18:23:50 <ski>                  f x
18:24:00 <ski> is how it could be defined
18:24:17 <ski> (the actual definition is probably something like
18:24:20 <ski> @src =<<
18:24:20 <lambdabot> f =<< x = x >>= f
18:24:21 <lechner> ski: thanks, that's what I thought!
18:24:35 <MarcelineVQ> sim590: I'm could be wrong though, something about that warning is bugging me
18:24:45 <ski>  where the `do'-notation syntactic sugar expands to calls to `>>=' (and `>>'))
18:25:31 <ski> `<-' is part of `do'-notation (the same symbol `<-' is also used in list comprehensions)
18:25:54 <sim590> MarcelineVQ: Yeah... I find that weird also. It really seems to be related to https://gitlab.haskell.org/ghc/ghc/-/issues/5728, but this issue is quite old and since they flagged it as a duplicate of some issue that they claim having fixed, I'm a bit confused.
18:26:46 <MarcelineVQ> the answer is likely in the haskell report or ghc manual since it's related to record update syntax
18:29:24 <MarcelineVQ> sim590: really though the answer you're gonna get mostly is do not use record syntax for sum types like Trees :>
18:30:48 <sim590> MarcelineVQ: but I'm really just updating a Node inside a Tree, not the Tree itself!
18:31:06 <sim590> I mean that I have a complex type that is a the Node here. It's LBSNode.
18:31:48 <ski> > Node {rootLabel = (),subForest = []}
18:31:51 <lambdabot>  Node {rootLabel = (), subForest = []}
18:31:52 <ski> > (Node) {rootLabel = (),subForest = []}
18:31:55 <lambdabot>  error:
18:31:55 <lambdabot>      • Couldn't match expected type ‘Tree a1’
18:31:55 <lambdabot>                    with actual type ‘a0 -> Forest a0 -> Tree a0’
18:33:39 <MarcelineVQ> But you are updating a tree, `index` takes a tree not a leaf, it just only works if the tree was a leaf right?
18:33:58 <MarcelineVQ> this is the most relevant report section I can find https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-490003.15
18:34:41 <MarcelineVQ> starting with "data T = T1 { y :: Int } | T2 { y :: Bool }  -- BAD" :>
18:35:54 <sim590> MarcelineVQ: no. Look at the full file: http://sprunge.us/PxW93j. The type of `index`  is `LBSNode a -> Int`. A LBSNode has a LBSLeaf as constructor.
18:37:07 <MarcelineVQ> alright then, a sum datatype still
18:37:27 <MarcelineVQ> All that aside what I'd try, if I wanted to keep the labels, is probably   incIndex LBSLeaf{index = i, leafContent = c} = return $ LBSLeaf {index = i+amount, leafContent = c}
18:37:57 <MarcelineVQ> so that we're not updating `l` but making a LBSLeaf
18:38:08 <MarcelineVQ> and you can probably use RecordWildcards or punning to shorten that if you want
18:38:53 <MarcelineVQ> idk if that's the exact right syntax for record construction since I've never really needed to do it, hopefully the idea comes across
18:39:21 <ski> it is
18:39:43 <sim590> Hmmm. Yeah. I guess I can do that in order to avoid the warning. But definitely, GHC should not display a warning in principle. May be I can file a bug.
18:39:45 <ski> (also that `$' is redundant)
18:39:59 <MarcelineVQ> Really ghc should be satisfied that you matched on LBSLeaf but it's being a bit of a penis
18:40:39 <MarcelineVQ> satisfied as in: should understand that `l` has to be LBSLeaf
18:44:25 <sim590> Yeah. So, this is a bug. May be it's already reported.. Ahhh. 4,060 bugs to look through. Mehhhh. ;).
18:45:44 <sim590> Is there a performance difference between both ways of writing it? What I mean is Between record-update and Construction of the same type with the same values. Will GHC be able use some properties of persistent data structure in order to avoid copying things? Does update-record even do that?
18:47:49 * hackage regex-pcre-builtin 0.95.1.1.8.44 - PCRE Backend for "Text.Regex" (regex-base)  https://hackage.haskell.org/package/regex-pcre-builtin-0.95.1.1.8.44 (AudreyTang)
18:48:49 * hackage source-constraints 0.0.2 - Source constraints GHC plugin  https://hackage.haskell.org/package/source-constraints-0.0.2 (mbj)
18:48:52 <MarcelineVQ> Pretty much the same steps are taken regardless.
18:49:15 <MarcelineVQ> check out the translation table in section  3.15.3
18:50:07 <MarcelineVQ> Either you case and build a record or update syntax is gonna case and build a record
18:50:40 <MarcelineVQ> Which is surely also our source for the unmatched pattern warning
18:52:00 <ski> (hm, in Mercury, if it can prove the old reference is unique, it will do an update-in-place, iirc)
18:52:56 <MarcelineVQ> ski: ghc is probably smarter than the report here, but just based on this it's not something to be too concerned about
18:53:36 <MarcelineVQ> sim590: it you're worried about it it could be an interesting benchmark to do
18:58:10 <sim590> Well. It's not very worrying. I was mainly wondering in order to know for other use cases.
18:59:01 <sim590> But then since I have to use the constructor, I can go back to the following syntax `incIndex (LBSLeaf i c) = return $ LBSLeaf (i+amount) c` which is the default I normally use.
18:59:39 <sim590> The main point of using the record syntax is to update things, but since I cannot do that here without creating a warning, then it's not worth writing the fields in the record syntax.
19:06:49 * hackage stm-queue 0.1.0.0 - An implementation of a real-time concurrent queue  https://hackage.haskell.org/package/stm-queue-0.1.0.0 (sgschlesinger)
19:08:45 <dolio> sim590: You could turn off -Wincomplete-record-updates if it's not smart enough to figure it out.
19:10:30 <sim590> dolio: Yes, but what if I make some other mistakes that it could find for me and I have disabled it?
19:39:24 <lechner> Hi, in a new standard stack setup, are the files stack.yaml.lock and *.cabal generated? I would like to add them to .gitignore. Thanks!
19:43:24 <glguy> The .cabal is generated if you have a package.yaml, but these days it's better to stick with deleting the package.yaml and maintaining the .cabal file
19:47:01 <lechner> glguy: thanks!
20:32:19 * hackage stm-queue 0.1.1.0 - An implementation of a real-time concurrent queue  https://hackage.haskell.org/package/stm-queue-0.1.1.0 (sgschlesinger)
20:55:30 <sepi> Hello guys, why doesn't this return false after running out of elements in a list?
20:55:45 <sepi> memb x [] = Falsememb x (y:ys) | x `elem` y:ys = True              | otherwise = memb x (y:ys)
20:58:04 <dolio> Because it can't run out.
20:58:29 <ski> it's an infinite loop, in case the element isn't there
20:59:24 <ski> > let memb x [] = False; memb x (y:ys) | x `elem` y:ys = True | otherwise = memb x (y:ys) in memb 3 []
20:59:26 <lambdabot>  False
20:59:35 <ski> > let memb x [] = False; memb x (y:ys) | x `elem` y:ys = True | otherwise = memb x (y:ys) in memb 3 [0,2,3,1]
20:59:39 <lambdabot>  True
20:59:42 <ski> > let memb x [] = False; memb x (y:ys) | x `elem` y:ys = True | otherwise = memb x (y:ys) in memb 3 [0,2,1]
20:59:48 <lambdabot>  mueval-core: Time limit exceeded
21:00:23 <ski> sepi : do you see why it loops ?
21:01:07 <lechner> Hi, I would like to abstract the calls to the three hash calculations in this code and get the warnings below it. Can I not include 'do' in the function?  https://dpaste.com/4ZCGYR975
21:01:46 <sepi> Yeah it checks if its in there, if its not it'll keep calling itself. I suppose I want to know how to stop if it reaches the end of the list
21:02:00 <ski>   compute :: (Char8.ByteString -> Char8.ByteString) -> String -> Char8.ByteString
21:02:03 <ski> should be
21:02:05 <ski>   compute :: (Char8.ByteString -> Char8.ByteString) -> String -> IO Char8.ByteString
21:02:36 <lechner> ski: i thought the <- drops the IO?
21:02:38 <ski> sepi : make sure you take a step forward, rather than walking in place, standing still
21:02:44 <ski> no, lechner
21:03:01 <ski> the whole `do'-expression will still have type `IO T', for some type `T'
21:03:08 <ski> (you can't escape)
21:04:12 <ski> btw, probably it's better to give a name to `Char8.pack contents', in order to not recompute it ?
21:04:20 <ski> (in `main', i mean)
21:05:23 <ski> sepi : also .. if you care to tell, what is `memb' supposed to compute ?
21:05:36 <lechner> i thought perhaps the compiler would be smart enough not to, although I thought that the 'effect' from readFile may force it.
21:06:14 <ski> lechner : anyway, if you move the `readFile' out of `compute', you can probably avoid the `IO' in its return type
21:06:43 <lechner> i will, but bear with me for a minute please. i changed the code the way you said, but now the code below fails even though i did not change it.
21:06:47 <sepi> like if x = ["abc", "def"].    memb says is ["def"] in x?
21:06:55 <sepi> True
21:07:13 <lechner> https://dpaste.com/553FLPZG5
21:07:16 <ski> lechner : smart enough not to do what ? recompute the calls to `Char8.pack' ? or reread the file ?
21:07:39 <ski> sepi : now try `memb "ghij" x'
21:08:08 <lechner> ski: i thought the effectful action of readFile might retrigger the remaining computation, but without that the compiler should not repack
21:08:37 <ski> GHC only does limited CSE
21:09:43 <ski> lechner : anyway, the second error message is because you still have a mistake in `compute'. but perhaps you want to keep the `IO' out of it ?
21:09:44 <sepi> It'll just sit there and I have to suspend it rather than being false
21:10:15 <ski> (in that case, it would be better to fix that first. although, if you want to, you could fix the other error)
21:10:23 <ski> sepi : and why's that ?
21:10:39 <lechner> ski: i see. sorry i misread the error message. it's my first day with Haskell
21:10:55 <ski> it's okay
21:11:17 <ski> it's not that uncommon that fixing an error in one place will trigger an error to be flagged in another location
21:11:50 <ski> sometimes it can be hard to know whether one will get out of the "tunnel(s) of error", fixing one after the other
21:12:01 <ski> with more experience, you should be able to tell this, quicker
21:12:47 <lechner> ski: How do I add the IO to the result?
21:13:24 <sepi> its going to keep looking for the match because recursion, because I suppose there isn't a "if it reaches end, false" statement 
21:13:39 <lechner> and why is the expected type now without the IO even though I just added it up top?
21:14:17 <ski> (this effect can also be noticed, when refactoring, changing the type signature. this can often trigger an error in other places, and fixing those can trigger further errors, like a ripple effect. this is normally a good thing, the implementation telling you all places you must fix, after having changed one place, in order to not encounter problems when running the code)
21:15:13 <lechner> but why did it not accept the actual type without the IO in the first place. just because of the 'do'?
21:15:37 <ski> sepi : there is a "if it reaches end, false" case, that's `memb x [] = False'. the problem is that you never take a step closer to it, you're moving your legs up and down, standing still
21:16:25 <ski> lechner : "but why did it not accept the actual type without the IO in the first place. just because of the 'do'?" -- no, because of the `readFile'
21:16:53 <ski> "How do I add the IO to the result?" -- result of what ? `compute' ?
21:17:11 <lechner> hashMethod $ Char8.pack contents
21:17:28 <ski> "and why is the expected type now without the IO even though I just added it up top?" -- what do you mean ? in <https://dpaste.com/553FLPZG5>, the expected type does have an `IO'
21:17:41 <ski> lechner : `return :: a -> IO a'
21:17:47 <lechner> yes, but only because I added it up top
21:18:27 <lechner> thanks. where do I place this return statement, please? and do I retain the name 'a'?
21:18:34 <ski> it's complaining that `hashMethod :: Char8.ByteString -> Char8.ByteString', while you're attempting to use it as if it was `hashMethod :: Char8.ByteString -> IO Char8.ByteString'
21:18:45 <lechner> right
21:19:05 <ski> `a' is a type variable. in your case, `a' would become `Char8.ByteString'
21:19:22 <ski> (so that you get `return :: Char8.ByteString -> IO Char8.ByteString' ..)
21:20:46 <ski> (another way to fix the type mismatch for `hashMethod' would be to change the signature of `compute' so that the specified callback (that's `hashMethod'), actually had type `Char8.ByteString -> IO Char8.ByteString' .. but i'm not convinced you actually want to do this)
21:21:30 <lechner> I will eventually remove the IO out of that function. right now, I am just learning. Where does that return statement go, please?
21:21:50 <lechner> and is this thing still called a function?
21:22:13 <ski> (usually, especially as a beginner, one should think twice, before putting `IO' inside argument types. it's not that it's dangerous, but rather that it adds extra power, with possibility for extra confusion, that one relatively rarely needs)
21:22:23 <ski> `compute' ? sure
21:22:33 <ski> `hashMethod' as well
21:22:33 <lechner> i agree with that
21:22:55 <lechner> i thought perhaps the 'do' would turn compute into a monad
21:22:59 <ski> no
21:23:17 <ski> monads are not values that you deal with, at run-time
21:23:19 * hackage reanimate 1.0.0.0 - Animation library based on SVGs.  https://hackage.haskell.org/package/reanimate-1.0.0.0 (DavidHimmelstrup)
21:23:27 <ski> take e.g. `getLine :: IO String'
21:23:36 <ski> `getLine' is not a monad. `IO' is the monad
21:23:44 <lechner> i see. that's not a monad either
21:23:49 <lechner> or is it?
21:23:49 <ski> `getLine' is a monadic action, or just action, for short
21:23:57 <ski> if you have
21:24:00 <ski>   compute :: (Char8.ByteString -> Char8.ByteString) -> String -> IO Char8.ByteString
21:24:04 <lechner> the IO is the monad?
21:24:18 <ski> then `compute hashMethod fileName' will also be an action. an `IO'-action (since `IO' is the monad here)
21:24:21 <ski> yes
21:24:53 <ski> the type `IO' (together with its instance of the `Monad' type class) is the monad
21:25:29 <lechner> okay, sorry to be persistent. in which line do i stick that return statement, please?
21:25:38 <ski> so .. `compute' is a function that computes/returns an action
21:26:02 <sepi> I know I would want  (y:ys) to be where y gets thrown out, next in ys becomes y. Now I'm trying to figure out how to translate that over
21:26:11 <ski> the line in which you currently need `IO Blah', while you actually only have something of type `Blah' in
21:26:33 <ski> sepi : perhaps try throwing out `y', then
21:26:34 <lechner> so it goes before, which makes it kind of ling
21:26:40 <lechner> long
21:27:13 <ski> you mean the line of code ?
21:27:37 <lechner> i am sticking in before the last line of compute
21:28:27 <lechner> something is wrong
21:30:15 <ski> sepi : btw, you didn't say what `memb' is supposed to compute
21:31:52 * ski idly wonders what lechner is trying
21:32:36 <sepi> its supposed to compute true or false, saying true"abc" is in there, or false it isn't in there 
21:32:41 <lechner> i feel so dumb. i can't put this line in the right place:  return :: Char8.ByteString -> IO Char8.ByteString
21:32:43 <sepi> I think I got it though 
21:33:21 <sepi> Thanks I was here for a few hours to get to this point, appreciate your push in the right direction 
21:33:24 <ski> sepi : what is `memb x ys' supposed to compute, for an arbitrary `x' and list `ys' ?
21:34:30 <ski> lechner : oh, i should clarify that i only intended you to use `return'. the `:: Char8.ByteString -> IO Char8.ByteString' was only a clarification, to tell you what type it would have, in your case
21:34:49 <ski> sepi : show the code ?
21:35:58 <ski> (if you really want to, you could type in `return :: Char8.ByteString -> IO Char8.ByteString' .. but you'd have to bracket it like `(return :: Char8.ByteString -> IO Char8.ByteString)')
21:37:54 <lechner> i was just missing some parentheses (or perhaps a dollar sign). return is a function!
21:38:00 <ski> yes, of course
21:38:06 <ski> it has a `->' in its type
21:38:30 <ski> all values whose types are of the general shape `... -> ...' are functions
21:38:31 <lechner> doesn't everything in Haskell? :)
21:38:35 <ski> (and only those are functions)
21:38:40 <lechner> just kidding
21:39:07 <ski> yea .. "Everything is a function" does not hold in the Functional Programming paradigm
21:39:20 <lechner> it was a bad joke
21:40:17 <ski> see <http://conal.net/blog/posts/everything-is-a-function-in-haskell> :)
21:41:22 <ski> lechner : so .. how does your `compute' look, now ?
21:41:37 <sepi> memb x [] = Falsememb x (y:ys) | x `elem` y:ys = True              | otherwise = mMemb              where mMemb = memb x (ys)
21:42:17 <ski> that's better
21:42:38 <lechner> ski: it's working. https://dpaste.com/CBE8R6EU2
21:42:41 <ski> sepi : although that code not had redundant functionality
21:42:43 <ski> er
21:42:46 <ski> sepi : although that code now had redundant functionality
21:42:53 <lechner> ski: I am just getting the hang of it. thanks so much for your help.
21:43:30 <lechner> ski: i'll be back. my first day with haskell is ending, and it's time to call it a night.
21:43:30 <sepi> the extra where part?
21:43:31 <ski> lechner : yea. btw, i would probably write that last line as `return (hashMethod (Char8.pack contents))'
21:43:48 <lechner> that's what I had. why is that superior, please?
21:43:55 <ski> sepi : no, not that
21:44:34 <ski> sepi : can you tell me, in words, what `memb x ys' is supposed to compute/check ?
21:44:46 <ski> lechner : it uses less `$'s :)
21:45:08 <ski> `$' rarely improve code, imho
21:45:20 <sepi> the x = y:ys ?
21:45:48 <ski> sepi : that question was not about your code, but about what behaviour your code is supposed to have
21:46:24 <lechner> thanks again for all your help! unfortunately, i have to go but thanks to you my experience in this channel was super
21:46:28 <sepi> Its supposed to check if what's given in x is in the ys list
21:46:56 <ski> lechner : in general, it's probably better to replace `f $ g $ h $ x' with `f . g . h $ x' or (i prefer) `(f . g . h) x' .. or just `f (g (h x))' (brackets are nothing to be afraid of)
21:47:43 <ski> lechner : the `f . g . h' "chain"/"pipeline" is better, since you can break out and factor away any part of it, giving it a new name. not so with the repeated `$'s
21:48:19 <ski> lechner : have fun, and good luck with your continued learning
21:48:29 <ski> sepi : yes, thank you
21:49:00 <ski> sepi : now, what is  x `elem` ys  supposed to compute/check ?
21:53:49 * hackage tagstew 0 - Black magic tagsoup  https://hackage.haskell.org/package/tagstew-0 (FumiakiKinoshita)
21:58:03 <sepi> I see that is my redundant part 😅
21:59:30 <sepi> I'm not sure without my = true, my | becomes a parse error input
22:00:02 <ski> how do you mean ?
22:02:36 <sepi> does it need a true or false claim before using otherwise?
22:02:53 <ski> a guard, introduced by the 
22:03:17 <ski> `|' symbol, expects an expresion evaluating to `True' or `False', after it, yes
22:06:19 <sepi> memb x (y:ys) | x == y = True              | otherwise = mMemb
22:06:43 <sepi> that gets rid of redundancy correct
22:06:43 <ski> yay :)
22:06:50 <ski> yes
22:07:32 <sepi> 💀💀 thank you
22:07:37 <ski> now, do you know how to express this using, say, `if'-`then'-`else', instead of guards ?
22:07:46 <ski> (or any other way ?)
22:07:49 * hackage typesafe-precure 0.7.9.1 - Type-safe transformations and purifications of PreCures (Japanese Battle Heroine)  https://hackage.haskell.org/package/typesafe-precure-0.7.9.1 (igrep)
22:16:53 <sepi> I know how I'd want to do it conceptually but I'm not too sure on the syntax
22:23:22 <sepi> If you could show an example or reference that's similar to my function that'd be cool. I'll be heading to bed for the night soon
22:27:40 <c_wraith> sepi: it's easier than you might think.    memb x (y:ys) = if ... then ... else ...
