00:55:34 <maerwald> why is there no way to generate an arbitrary instance from a parser?
00:56:03 <lemmih> A parser?
00:56:16 <maerwald> yes
00:57:34 <maerwald> the logic seem similar for text-like instances (url, path, ...)
00:58:16 <maerwald> so, if you have a url parser, you can infer the arbitrary instance manually
00:59:06 <lemmih> By parsing an arbitrary string?
00:59:26 <maerwald> by looking at the code
01:01:24 <merijn> Because there is no consistent/universal interface to "parsers"?
01:01:49 <merijn> There's some papers on reversible parsing, etc. but I don't think anyone uses that
01:05:30 <lortabac> in Prolog it is definitely possible :)
01:17:03 <int-e> There are a couple of hackage packages, cassette, syntax, and invertible-syntax. (I feel I missed the one that I actually played with and ultimately decided against... mainly because it's hard to carve out the prettiest version that should be printed from all the mess that parsers usually accept.)
01:17:20 <int-e> (For reversible/invertible parsing.)
01:21:15 <phadej> maerwald: https://www.well-typed.com/blog/2020/06/fix-ing-regular-expressions/ - so in theory generating Arbitrary from parser is possible, and we use it in Cabal
01:21:32 <phadej> but having efficient parser from the same definition is tricky
01:58:39 <aldessa> Hello, suppose I have some settings data type. Is there a way to generate a config file parser automatically? I think with Template Haskell?
01:59:12 <merijn> Is there a way to do it? Probably. Should you? No.
01:59:21 <merijn> Repeat with me the age-old adage
01:59:34 <merijn> "I shall never auto-generate parsers for my code from data structures."
02:00:51 <merijn> 1) this ends up encoding arbitrary data structure decisions in your format, 2) any data structure change now breaks your parser/input format, 3) any desirable input/format change also breaks your parser
02:01:36 <aldessa> oh
02:01:41 <aldessa> it makes it less modular
02:02:00 <merijn> The one constant lesson (I keep needing to relearn, because I'm dumb and keep ignoring it) is that not having decoupling of "external" and "internal" formats is always bad and explicit parsers are always good in the long run
02:02:16 <aldessa> I shall never auto-generate parsers for my code from data structures.
02:02:40 <aldessa> can you recommend any parser generators for a config file? say Yaml or JSON?
02:03:04 <merijn> aldessa: The past 6 years I've gotten myself into a lot of pain 3 times when I (inevitably) needed to change either my internal format or external format, so I'm not great at following my own advise either ;)
02:03:38 <merijn> aldessa: Allow me to shill Dhall (which also has great Haskell support!) https://dhall-lang.org/ :p
02:03:55 <lemmih> aldessa: Just derive FromJSON and ToJSON and call it a day. :) Future pain is future aldessa's problem.
02:03:57 <merijn> For JSON you probably want aeson
02:04:19 <merijn> Although aeson's typeclassy nature does encourage the mistake I just warned against :p
02:04:48 <aldessa> I just want something very nice to use, not JSON in particular
02:05:24 <merijn> Dhall is certainly nicer than JSON, imo :p
02:05:39 <aldessa> currently all my configuration is done via environment variables
02:05:46 <merijn> "What if JSON, but the designer had read a book on languages before inventing a format?"
02:06:34 <aldessa> It kind of looks like something between Haskell and OCaml
02:07:22 <fendor> I always wanted to give waargonaut a try. It encourages writing your own parsers/serialisers
02:07:26 <merijn> Far less general though, you can't do arbitrary recursion (or really anything Turing complete)
02:07:45 <merijn> fendor: I've looked at the waargonaut docs once and noped out of there within 2 seconds :p
02:07:45 <aldessa> that's definitely a good thing
02:08:29 <fendor> merijn, indeed, the docs look complex to me. It feels like they do not start out with the most basic examples
02:08:49 <merijn> aldessa: The design goal of Dhall is basically: We want JSON, but with types, abstraction, and import, but it's still a config file, so no Turing-completeness or arbitrary code
02:09:05 <fendor> well, actually they do. Then it just looks complicated
02:09:21 <merijn> fendor: It's like those beam SQL libs
02:09:35 <fendor> we should copy the elm libs! 
02:09:36 <merijn> Life is too short for types like that (and the corresponding type errors)
02:09:42 <aldessa> maybe this is just my experience but a lot of Haskell libraries have really advanced examples
02:09:48 <merijn> If I wanted errors like that I'd still be writing C++
02:10:19 <merijn> aldessa: Probably, but there are some libraries that really go out of their way to be more complicated than they have to be
02:11:39 <merijn> aldessa: I mean, look at this type: https://hackage.haskell.org/package/beam-core-0.8.0.0/docs/Database-Beam-Query.html#v:leftJoin_ >.>
02:11:50 <aldessa> I'm scared.
02:13:44 <fendor> that looks lovely
02:13:54 <fendor> just as nice as the swagger-ui types
02:14:30 <fendor> And to think I still struggle with this: `Tasty.Traversal (Functor.Compose (Reader.ReaderT [String] (State.StateT IntMap.Key IO)) (Const Summary))`
02:14:36 <merijn> aldessa: Healthy reaction ;)
02:14:55 <merijn> fendor: Needs more newtypes hiding details
02:18:38 <aldessa> Writing a bot, it incrementally asks for the info it wants. What would be a good way to store this? My kind of idea is data X = CX Int Text, then data Asking = HasNothing Int -> Text -> X | HasAge Text -> X.
02:19:16 <merijn> aldessa: So like forms?
02:19:35 <aldessa> kind of but it is a chat bot, so you have to ask for each bit individually with feedback rather than doing all at once
02:20:00 <aldessa> wondering if i should store my intermediate state as curried functions
02:20:15 <merijn> That works, sure
02:21:42 <aldessa> Okay cool, thank you.
02:21:44 <merijn> The answer is basically kinda "It Depends"
02:22:47 <merijn> aldessa: What's supposed to happen on error/wrong input?
02:23:51 <aldessa> Send a message back to the user, saying the id number is too short/long or something.
02:24:27 <aldessa> There is no serialisation needed, because I really don't want to store people's information.
02:24:47 <merijn> aldessa: You can write like a "getPrompt" that loops until you get an acceptable answer
02:25:31 <aldessa> I don't want to loop, then my bot can't handle other events at the same time
02:25:41 <aldessa> Like I couldn't do 2 people easily
02:25:42 <merijn> Why not?
02:25:57 <merijn> Why can't you handle those people independently?
02:26:57 <Cale> merijn: I think the real problem with that type of leftJoin isn't the complexity of the type so much as it is that you click on the things in the type and they're undocumented and somewhat inscrutable
02:27:42 <aldessa> i'm reacting a created message event in particular, I thought I should lookup in a map from the username to some intermediate state then pattern match on that intermediate state
02:27:45 <Cale> (but also, sure, one would hope to obtain a simpler type than that for leftJoin... though it's not exactly something I'd expect to be completely trivial)
02:27:52 <aldessa> where the intermediate state is the progress on the form
02:37:45 <kiwi_45> can someone show me how to use this function practically or even describe ? https://hackage.haskell.org/package/base-4.14.0.0/docs/Data-Data.html#v:gmapQ
02:45:44 <kiwi_45> ??
03:00:43 <lemmih> > gmapQ cast (1,(),2) :: [Maybe Integer]
03:00:46 <lambdabot>  [Just 1,Nothing,Just 2]
03:04:21 <Cale> > gmapQ cast (1,[2,3],4) :: [Maybe Integer]
03:04:24 <lambdabot>  [Just 1,Nothing,Just 4]
03:14:47 <ptrcmd> @src qmapQ
03:14:47 <lambdabot> Source not found. My mind is going. I can feel it.
03:15:03 <ptrcmd> :t qmapQ
03:15:04 <lambdabot> error:
03:15:04 <lambdabot>     • Variable not in scope: qmapQ
03:15:04 <lambdabot>     • Perhaps you meant ‘gmapQ’ (imported from Data.Data)
03:15:10 <ptrcmd> @src gmapQ
03:15:10 <lambdabot> Source not found. I feel much better now.
03:15:53 <Philonous> merijn, I'd really like to give Dhall a try, but I'm mystified by the decision to allow imports from URL 
03:17:22 <phadej> your interpreter can disallow that
03:17:53 <phadej> (or have an allow-list for some imports+hashes)
03:20:02 <hekkaidekapus> Philonous: Did you give <https://docs.dhall-lang.org/discussions/Safety-guarantees.html> a read?
03:21:03 <phadej> I mean, there is things to not like in Dhall, but imports is not in my list :)
03:26:11 <Philonous> hekkaidekapus, Oh, I haven't seen that before. Seems like they put some thought into this. 
03:27:39 <hekkaidekapus> Philonous: I would say so. Grosso modo, if you are happy with importing from the disk, you should not worry about importing from the www.
03:29:14 <Philonous> hekkaidekapus, I still have some nit-picks after reading this, but I'm much less concerned
03:29:32 <hekkaidekapus> Such as what?
03:30:14 <Philonous> E.g. dhall --annotate should return the hash, so that you know you're actually freezing the import you reviewed
03:30:58 <hekkaidekapus> You can get the hash from the REPL.
03:31:23 <Philonous> OK, fair, but that's not the workflow mentioned in the document
03:32:17 <hekkaidekapus> Oh, I see. There are many ways of doing some common things.
03:34:04 <hekkaidekapus> And once you import with an explicit `sha256`, you basically freeze all intermediate expressions. Further invocations will just look up into ~/.cache/dhall
03:34:42 <Philonous> Also, I know I'm going to either forget or be too lazy^Wbusy to hash-guard imports. Would be preferable if un-guarded imports would be rejected by default 
03:34:53 <Philonous> But as I said, these are just nit-picks 
03:35:22 <hekkaidekapus> Yeah, nit-picks are fine. Have go at it :d
03:38:03 <phadej> when your program consumes dhall it can do checks differently from `dhall` the executable.
03:38:19 <phadej> Compare how program parses JSON vs what `jq` does
03:38:56 <phadej> (in the usecase where dhall is used as a configuration language)
03:39:44 <hekkaidekapus> phadej: What kind of checks are you referring to?
03:40:19 <phadej> hekkaidekapus: e.g. that there are no 3rd party imports, that final expression is of right type
03:40:40 <phadej> whatever you care about
03:41:16 <phadej> e.g. for configuration it might be quite important that it doesn't need network access to be interpreted :)
03:41:24 <Philonous> Unrelated: I'm struggling to come up with a good way to deciding how to divide data retrieval code between Haskell and SQL. I'm always tempted to stick as much into the SQL query as possible, but that ends up being uncomposable, harder to maintain and harder to work with since SQL isn't checked during compile time. Is there a good guideline how to structure this kind of code? 
03:41:42 <hekkaidekapus> Ah ok, you are replying to Philonous. I thought it was another nit-pick.
03:41:48 <merijn> Philonous: I've just stuck everything into SQL :p
03:42:38 <phadej> i think there was some libraries to "type-check" raw SQL
03:42:43 <phadej> I have no experience with them though
03:42:51 <Philonous> merijn, That's what I'm doing. But I end up hand-writing a lot of SQL that's full of duplications that are hard to factor out and hard to review
03:43:22 <phadej> you might write or find a DSL for SQL writing
03:43:48 <phadej> but I wouldn't process data in Haskell, if it's "naturally" (whatever that means) processed by DB
03:44:08 <Philonous> I'm using esqueleto. It helps much less with composability than you'd think, and it doesn't guarantee working SQL code. 
03:44:36 <phadej> I'm not claiming that any existing Haskell lib is good for you
03:44:53 <phadej> note "you might write" in "you might write or find a DSL for SQL writing"
03:45:18 <Philonous> I wasn't trying to contradict your statement, just giving context
03:46:15 <phadej> sometimes I think that type-less DSL with run-time checks (which can be done by TH to become compile-time) is better than type-level magic libs
03:46:19 <merijn> Philonous: Any attempts to solve this issue seem to turn into beam monstrosities, so...
03:46:26 <phadej> but the other day I'm using beam :)
03:47:24 <Philonous> I agree that some thins are "natural" to do in SQL (joins, simple filters), some complex things are impossible to do in SQL. Those are the easy cases, but that leaves a lot of grey area 
03:50:33 <Philonous> I've been tinkering with a library that picks up Haxl's idea (automatically accumulating requests to avoid n+1 queries), but interacts directly with persistent's entity definitions. It at least seems to compose better than Esqueleto. But I'm not sure yet if it's actually a good idea
03:51:01 <phadej> RDBMS are designed to perform well "heavy queries"
03:51:20 <phadej> you might like a document database solution for "batched dummy fetches"
03:54:27 <Philonous> I haven't tried it "at scale", but I don't think Postgres has problems being used as a document database 
03:56:05 <phadej> no, and probably it is quite good at that. I.e. better than many more recent products
03:56:34 <phadej> but using it *just* as doc-db feels like underusing it :)
03:57:14 <Philonous> In any case, the idea is that you can switch between the two as needed, automatic batching were it's possible and convenient, and then hand-written (or generated) SQL were you need something more
04:00:14 <phadej> if you domain is such that half of your queries is "AND x IN (a,b,c,...)", then why not.
04:00:58 <phadej> but then you do joins in "userland"
04:02:54 <phadej> getting consistent views becomes harder with multiple queries. Whether that is a problem for your case depends
04:03:25 <phadej> (thus I like "get all at once, if only possible", and let the DB engine to worry about consistency)
04:05:25 <maerwald> any ideas on how to make hspec-golden-aeson not fail on 32bit? https://gitlab.haskell.org/haskell/ghcup-hs/-/jobs/441218#L1670
04:05:42 <maerwald> It can't read the seed value of hspec :)
04:06:20 <phadej> not use hspec :)
04:07:22 <Philonous> phadej, The consistency point is a good one
04:09:10 <phadej> maerwald: I'd say that hspec should bump lower bump of QuickCheck  to the one using splitmix, and use Word64 as the seed value
04:09:14 <phadej> then stuff will just work
04:10:19 <maerwald> I want to start a rant about Int on the mailing list, but it wouldn't be a productive thread
04:10:50 <merijn> GHC needs constraints to statically validate sizes of integer types, yeah
04:14:40 <phadej> rants are not constructive, if they don't offer a solution
04:15:34 <phadej> maerwald: fwiw, pre splitmix QuickCheck weren't deterministic in seed anyway
04:16:03 <phadej> or maybe it was. tf-random probably gives the same sequence on 32bit and 64bit
04:16:09 <phadej> (random-1.1 didn't)
04:17:04 <phadej> but mkStdGen in random-1.2 is still :: Int -> StdGen :)
04:17:53 <phadej> maerwald: you can also use smaller int as a seed  :)
04:17:59 <phadej> (which fits into 32bits)
04:18:58 <maerwald> phadej: it picks its own seed I think
04:19:24 <maerwald> I can't seem to overwrite it
04:22:58 <maerwald> https://hackage.haskell.org/package/hspec-golden-aeson-0.7.0.0/docs/src/Test.Aeson.Internal.GoldenSpecs.html#createGoldenfile
04:23:07 <maerwald> rSeed <- randomIO
04:24:44 <phadej> oh, yeah, i guess if you change the seed in golden file you have to change the rest as well
04:24:57 <phadej> "just regenerate until you get one which fits into 32bit"
04:25:03 <maerwald> :D
04:25:04 <phadej> (or generate one on 32bit machine ;)
04:41:18 <etalecohomology> may I ask a question about haddock?
04:41:29 <phadej> don't ask to ask. just ask :)
04:41:33 <phadej> (yes)
04:41:39 <etalecohomology> I have packages A, B build from a common git repo, B depends on A
04:42:25 <etalecohomology> I use  "cabal v2-haddock --builddir=docs --haddock-for-hackage --enable-doc"
04:43:05 <etalecohomology> but package B fails to find a type defined in "A", i.e. haddock always writes: "Warning: GI.Cairo.Render.Connector: could not find link destinations for:
04:43:39 <etalecohomology> is this a bug, as I build them _together_ ...?
04:44:19 <phadej> no, they are still build independently
04:44:28 <phadej> I think, safe to ignore
04:44:39 <etalecohomology> no, I want the links correctly set
04:44:45 <etalecohomology> before I upload to hackage
04:44:50 <phadej> as haddock-for-hackage tells haddock to generate links so if all pieces are in places, they will point to each othere
04:45:00 <phadej> you can reupload haddocks
04:45:00 <etalecohomology> how to teach B where to find documentation for A
04:45:25 <merijn> etalecohomology: --enable-doc is redundant for v2-haddock, I think?
04:45:41 <etalecohomology> i just followed the documentation on the upload page
04:45:46 <phadej> where "--haddock-for-hackage tells haddock" meaning "just generate the links, assuming they will be there"
04:45:48 <merijn> I always just do "cabal v2-haddock --haddock-for-hackage"
04:45:57 <phadej> after all the links are relative as on hackage.haskell.org
04:45:58 <phadej> not locally
04:46:21 <etalecohomology> But in the html the links for the missing type are not generated at all
04:46:27 <etalecohomology> no hyperlink, just text
04:46:45 <merijn> haddock should be generating a tarball, though?
04:46:51 <etalecohomology> yep
04:47:59 <phadej> hmm
04:48:48 <sshine> I have a question about hedgehog and tasty-discover. is there a way to configure the global default for how many units each hprop_ is subjected to? since all my hprop_ values are prefixed with 'property $ do', I could make a variant that uses 'withTests N' where N is derived from a global environment, but I wonder if there's a standard way to do it?
04:49:43 <phadej> etalecohomology: I see
04:49:47 <phadej> that looks like a bug
04:50:04 <phadej> because if A weren't local, the links would be generated.
04:50:25 <etalecohomology> yes
04:50:40 <etalecohomology> I even uploaded the docs of A to hackage already
04:50:52 <etalecohomology> I hoped it would find it
04:50:57 <etalecohomology> open a bug on cabal?
04:51:00 <etalecohomology> or haddock?
04:52:22 <etalecohomology> I uploaded now B to hackage, too and the link is missing, as expected
04:52:22 <phadej> most likely cabal
04:52:31 <phadej> no-one really cares about haddockcabal support
04:53:07 <phadej> (aka I don't know anyone who knows anything about `v2-haddock`)
04:53:19 <etalecohomology> wow, cabal has 1.3k of issues on github
04:53:23 <phadej> yes
04:53:29 <phadej> some of them are decade old :)
04:53:35 <etalecohomology> then it makes no sense to open a bug, right?
04:53:38 <maerwald> haha
04:53:52 <maerwald> a patch makes more sense, if you mean that :D
04:54:26 <etalecohomology> they have also 65 pull requests
04:54:39 <etalecohomology> :-)
04:54:42 <phadej> well, there's a point to open an issue, someone might champion haddock issues at some point
04:55:04 <phadej> fwiw, "they" is "me"
04:55:12 <phadej> as sad as it is.
04:55:35 <etalecohomology> you need some help, definively ;-)
04:56:00 <maerwald> etalecohomology: if you've looked at cabal-install codebase, you'll know why... basically you can't do it without funding :p
04:56:04 <phadej> normal in OSS that critical pieces of infrastructure is maintained by a person or two.
04:56:47 <phadej> https://xkcd.com/2347/
04:56:47 <merijn> What happened to hvr? I haven't seen him ages
04:57:14 <phadej> he is alive :)
04:57:17 <maerwald> merijn: he responded on the fromInteger thread with a proper rant though
04:57:30 <maerwald> which is a few weeks old
04:57:45 <merijn> I know he's alive, because I saw him join a channel at some point, but I haven't really seen him talk in months
04:57:57 <maerwald> but I don't think he's opening his github notifications anymore
04:58:28 <merijn> The best way to get cabal bugs fixed is to fix them :p
04:58:42 <etalecohomology> in any case, having 1000 tickets is _very_ bad
04:58:47 <maerwald> merijn: without introducing another bug :)
04:58:53 <merijn> Unfortunately that can feel like playing Arkham Horror/Mansions of Madness
04:59:01 <Athas> Cabal is much better than it has ever been before, so I have only nice things to say to hvr!
04:59:03 <merijn> etalecohomology: It depends, there's also tons of super niche tickets
04:59:30 <etalecohomology> perhaps you should close them all and start from scratch
04:59:32 <sshine> phadej, the caption mentions ImageMagick, but OpenSSL comes to mind.
04:59:47 <merijn> etalecohomology: Sure, it'd be better if they were all solved. But ticket issues get handled on a "as contributors care" basis
05:00:02 <Athas> There is the notion of "issue bankruptcy" that I find appealing, partially because of the cool name.
05:00:21 <Athas> It basically means to close all issues and start over.
05:00:26 <merijn> etalecohomology: If you want an easy way to contribute, start going through tickets and figure out which are still relevant and which can be closed because they're obsolete ;)
05:00:31 <Athas> Well, not "basically".  That's what it is.
05:00:39 <merijn> Athas: Lots of tickets have considerable (useful) discussion, though
05:00:42 <merijn> You'd lose that too
05:00:48 <Athas> merijn: they aren't deleted.
05:00:50 <phadej> etalecohomology: have you looked how many issues open GHC has ;)
05:00:59 <merijn> Athas: Lose in the "can't find" sense :p
05:01:23 <maerwald> just consider 80% ot the issues as documentation, and the rest actual tickets
05:01:58 <etalecohomology> just 4k tickets
05:02:04 <phadej> "just" :)
05:02:11 <merijn> Hell, even "serious" projects with actual funding have tons of issues
05:02:24 <merijn> I just checked, just the C component of gcc has 1k open tickets too :p
05:02:58 <etalecohomology> at my company I get inqueries from my manager if I have more than 5 tickets on my name for more than 1 week
05:03:02 <merijn> C++ part has 3.3k, so I think it's not so bad ;)
05:03:11 <merijn> etalecohomology: Oh, that's easy
05:03:16 <merijn> just don't assign tickets to people!
05:03:27 <etalecohomology> *lol*
05:03:57 <sshine> Athas, one way to avoid issue bankruptcy is to consider issues an infinite backlog of which reported issues are just the iceberg we're conscious of. I tried to go over Exercism's 500+ issues a year ago, and I think I did reduce the issues by about 100-150 by creating categories in my mind like "deprecated support ticket", "duplicate feature request", "clearly wontfix" (requires some knowledge about the 
05:04:03 <sshine> direction of the project).
05:04:12 <merijn> phadej: Somewhere in the universe there's a spot in OSS maintainer's heaven for you ;)
05:04:55 <maerwald> OSS is great... you do a lot of work for free and at the end of the day you get yelled at :p
05:05:10 <sshine> Athas, but inevitably I stranded on some pretty round number in the hundreds of tickets with mainly completely sensible feature requests that the project either didn't have resources for or wasn't prioritizing. those could just as well be moved somewhere else or get tagged and closed as "if we ever feel like brainstorming, some guys did it for us".
05:05:16 <phadej> merijn: I'm quite fine. I don't have manager sending me inquiries why cabal issues count is increasing even I work on the project quite a lot
05:05:22 <merijn> maerwald: Oh, I don't put up with that and scold others for it
05:05:46 <merijn> phadej: Issue counts correlate with active users, so that just means you're doing well ;)
05:05:50 <maerwald> phadej: cabal clearly lacks a manager then
05:05:59 <etalecohomology> yes, I could rent you mine
05:06:02 <phadej> merijn: fwiw, I have 131 open issues reported to Cabal
05:06:06 <phadej> which is 10% :)
05:06:17 <sshine> I'm more frustrated about highly depended-upon packages that have stale PRs that go years back.
05:06:27 <merijn> phadej: Is it all in your own time or also work?
05:06:54 <phadej> merijn: for 2020 I haven't used any of my own time on Cabal
05:06:56 <sshine> pretty much anytime I push something or email something to someone who maintains a package, they offer co-maintainership... I think this level of trust is a luxury other language ecosystems don't have.
05:07:10 <sshine> (this is for low-stake packages, of course, haha.)
05:07:19 <merijn> phadej: \o/
05:07:49 <merijn> phadej: I'm trying to sneak in time to fix things, but so far there's some Haskell resistance, so it's "too hard for scientists" supposedly >.>
05:08:06 <merijn> sshine: pfft
05:08:11 <phadej> merijn: yes, that is nice. But somewhat lonely.
05:08:27 <merijn> sshine: Do you consider lens low-stakes? Because edward will give you push rights at the drop of a hat
05:08:36 <etalecohomology> ok, thanks ... I will help myself and at sometime I will look at the cabal backlog and fix a bug if I can :)
05:08:53 <phadej> merijn: push rights /= maintainership on Hackage
05:08:58 <merijn> that's true
05:09:00 <etalecohomology> but I guess its hard stuff
05:09:09 <sshine> merijn, no :) I just didn't have an example of someone willing to do that. I've pushed a few haddock fixes to hedgehog and I notice they're pretty strict on PRs. so cultures vary.
05:10:45 <etalecohomology> generating the docs out of tree worked for me now, thanks phadej
05:11:57 <etalecohomology> I mean "copying" the source of the subpackage somewhere else and invoking haddock there
05:14:48 <phadej> .. and that's one of reasons stuff doesn't get fixed, there are workarounds :)
05:15:58 <sshine> what's the closest we have to dependabot for haskell? I see there's http://hackage.haskell.org/package/cabal-bounds
05:16:35 <merijn> sshine: For package bounds?
05:16:54 <merijn> haskellers.com runs an RSS feed that will tell you when a new package outside your bounds gets released
05:18:19 <merijn> https://packdeps.haskellers.com/feed?needle=broadcast-chan
05:20:26 <etalecohomology> i opened https://github.com/haskell/cabal/issues/7068 anyhow
05:24:01 <Athas> Rust has so many open issues that GitHub cannot count them.
05:24:16 <etalecohomology> can someone explain me, why there is all this v2- prefixes in cabal ... why not just delete the "v1-" and make v2 default
05:24:27 <Athas> etalecohomology: it is!
05:25:16 <Athas> But ten years from now, when the default is a set of new Cabal On The IoT Blockchain commands, the v2-prefix will still unambiguously do what it does now.
05:25:36 <merijn> etalecohomology: In cabal-isntall 3.0 and later it is the default
05:25:58 <etalecohomology> ok, I always feared to call it without v2
05:26:10 <etalecohomology> I remembered that hell breaks loose, when I was doing that
05:26:15 <merijn> etalecohomology: But there's also tons of people who would like to be able to write shell scripts that work correctly without complicated checks which version of cabal-install is installed
05:26:47 <etalecohomology> yes, but sometimes is better to make a clear cut 
05:26:49 <merijn> so v1- and v2- are unambiguous and version independent. The unprefixed commands are specific to which version is installed
05:27:06 <etalecohomology> it's user complexity vs. cabal complexity
05:27:17 <etalecohomology> why care for users ? ;-)
05:27:23 <Athas> The next version of cabal will remove the v1-commands, won't it?
05:27:27 <Athas> Or is it just sandboxes that go away?
05:27:33 <Athas> I remember reading that something will be cut...
05:27:37 <merijn> Athas: Just sandboxes, afaik?
05:28:22 <merijn> etalecohomology: If you use a new-ish version (we're already at 3.4, so...) version of cabal-install the prefix is redundant, so that's not really user complexity anymore ;)
05:28:45 <Athas> Incidentally, I'd like to mention that v2-build has led to much simpler Haskell packages in Homebrew.  You can really tell the difference between the first Haskell packages and the newest ones.
05:29:02 <Athas> If projects would only use cabal.project with an index-state, then all would be well...
05:29:27 <merijn> Athas: index-state will be part of freeze files automatically now, so!
05:29:51 <Athas> merijn: great, but freeze files are not fully appropriate here, since Homebrew prefers to keep the GHC version floating.
05:30:04 <Athas> Although I suspect that's not a good policy for Haskell packages.  It's basically random whether it'll work.
05:30:13 <merijn> Athas: What does index-state with an unfixed GHC?
05:30:29 <merijn> +solve
05:30:35 <Athas> merijn: Homebrew uses index-state with an unfixed GHC (for those packages that use index-state at all, otherwise it's all unfixed).
05:31:02 <Athas> Well, I guess Homebrew *does* fix GHC for each package, but they like to bump it to the newest version whenever one comes out.
05:49:18 <sshine> merijn, nice.
05:52:07 <merijn> sshine: Super underrated and low-effort in terms of keeping up with your dependencies :)
06:04:48 * hackage rebase 1.7.2 - A more progressive alternative to the "base" package  https://hackage.haskell.org/package/rebase-1.7.2 (NikitaVolkov)
06:07:19 * hackage rerebase 1.7.2 - Reexports from "base" with a bunch of other standard libraries  https://hackage.haskell.org/package/rerebase-1.7.2 (NikitaVolkov)
06:25:19 * hackage roboservant 0.1.0.2 - Automatic session-aware servant testing  https://hackage.haskell.org/package/roboservant-0.1.0.2 (MarkWotton)
06:54:50 * hackage taskell 1.10.1 - A command-line kanban board/task manager  https://hackage.haskell.org/package/taskell-1.10.1 (smallhadroncollider)
07:08:23 <halogenandtoast> Axman6: btw from your example, I don't think you can call coerce like this, because the Coercible constrait can't be applied to that x
07:12:17 <halogenandtoast> I figured out how to add the constraint
07:16:33 <halogenandtoast> But I had to use All2, I can't figure out how to it with FirstFieldIs
07:25:25 <htmnc> why doesn't 1 ` (+) ` 1 work but let add = (+); 1 `add` 1 does?
07:25:59 <dolio> Backquotes only apply to names.
07:26:00 <htmnc> semicolon is because I'm onelining it, feel free to read it as \n, though I could've just said \n
07:26:03 <htmnc> ah
07:26:14 <merijn> You can backquote expressions either
07:26:28 <htmnc> can or can't
07:27:29 <ski> can't
07:27:35 <merijn> eh, can't
07:27:38 <merijn> typing is hard
07:32:25 <tdammers> backquotes aren't operators ;)
07:36:44 <polyphem> you also can't backquoute partialy applied functions, like :  a `ternery blah` b 
07:37:46 <dolio> Right, it's just a different name that can be used infix, and refers to the same thing as the unquoted name. Although you can put spaces inside the quotes.
07:41:26 <ski> polyphem : yea, that would be a (nontrivial) expression, attempted to be backquoted
07:46:08 <polyphem> ski: yeah, i found out a month ago or so , asking in here . its probably not that good anyway , readability-wise .
07:47:20 <yushyin> the spaces before the punctuation marks drive me crazy :D
07:48:03 <polyphem> sorry. :)
07:50:14 <ski> yushyin : before ? or inside ?
07:50:45 <AWizzArd> The wife calls her husband (a software developer) and asks him: "Would you please get a bread from the market? And if they have eggs please get six".
07:50:48 <AWizzArd> The man came home and put six breads on the table. The wife was shocked and asked: "Why why did you bring six breads?"
07:50:52 <AWizzArd> Her husband replied: "Because they had eggs."
07:50:52 <polyphem> ^ its phrase composition, not record field accessor :)
07:54:20 * hackage Z-Data 0.1.0.0 - array, vector and text  https://hackage.haskell.org/package/Z-Data-0.1.0.0 (winterland)
08:02:05 <tdammers> AWizzArd: "while you're outside, buy some milk" - dude comes home with sixty gallons of milk, because he kept buying milk for the entire duration of his trip
08:05:49 <AWizzArd> tdammers: actually I found this amusing, thx :-)
08:08:37 <tdammers> while (amOutside) { buyMilk(); } // Oh no, infinite loop!
08:17:48 <AWizzArd> tdammers: so literal (:
08:19:16 <tdammers> anything for infinite dairy
08:19:47 <dminuoso> tdammers: Once you start functional programming, you never return.
08:20:01 <AWizzArd> hr hr hr
08:20:13 <AWizzArd> dminuoso: sometimes you pure though.
08:20:29 <dminuoso> Well, I was rather going to make a remark about ContT, but sure.
08:21:57 <tdammers> whileM_ amOutside buyMilk -- imperative Haskell at its finest
08:22:44 <dminuoso> It's quite surprising how I've managed nearly 2 years of haskell without whileM_
08:23:27 <dminuoso> But I suppose, you frequently (ab)use what you have to get around. Now while it's legit to think of lists as first class loops, in a way we just use them that way in the absence of loops as a feature in Haskell.
08:23:29 <dolio> I don't think it's that surprising. :)
08:24:45 <dminuoso> Why do you say that?
08:24:57 <dolio> Because I've also never used it, I think.
08:25:09 <dolio> And I've been writing Haskell for much longer.
08:26:02 <dminuoso> Well I just find it surprising, because of how much code is structured on whileM_ equivalents in traditional imperative languages.
08:26:32 <dolio> Also, it's pretty rare that that interface would be useful, I think.
08:26:59 <dolio> It's designed for situations where your termination condition is squirreled away in some kind of mutable state.
08:27:30 <dolio> But that's usually more annoying than using a decreasing argument or something.
08:28:17 <dminuoso> I think a more fitting explanation is that `while` is actually a goto in disguise. The exit condition is secondary to it.
08:28:20 <tdammers> the majority of loops in imperative programming are really just folds, mappings, or some kind of data traversal
08:28:44 <veverak> yes
08:29:04 <dolio> You kind of have to go out of your way to make things work like a loop in Haskell. Put extra stuff in references that don't really need to be there.
08:29:06 <tdammers> truly imperative loops, where you need to keep repeating parametric effects until some effectful condition is met are fairly rare even in imperative programs
08:29:29 <tdammers> those traversals just tend to be implemented as loops because that's all you have
08:30:54 <dolio> By the time you write it as a loop eligible for whileM_, it's probably longer than just doing tail recursion, and less like what you're used to writing elsewhere.
08:30:56 <dminuoso> I still believe the main attration to `while` is not even the repeated effect on an exit condition, but rather the `goto` on both the loop and the exit. In a lot of ways, a local jump is the simplest way to "get out of trouble" at the cost of assuming responsibility of state machine management with you
08:31:28 <monochrom> Function application is a better goto.
08:32:52 <monochrom> https://dspace.mit.edu/handle/1721.1/5753 :)
08:41:30 <ski> tdammers : "parametric effects" ?
08:41:35 <tdammers> yeah
08:41:44 <tdammers> effects that depend on some parameter
08:41:52 <tdammers> fancy way of saying "procedures that take arguments"
08:41:59 <ski> mhm
08:42:15 <ski> monochrom : itym "tail call" ?
08:42:33 <tdammers> frankly, I didn't actually give it much thought
08:43:05 <monochrom> Yeah tail call is brought up. But I think the paper has other, juicier points.
08:43:48 * ski idly ponders head recursion
08:44:12 <monochrom> Oh, State.Lazy supports head recursion. :)
08:44:21 <ski> (or is that "left recursion" ?)
08:45:04 <ski> hm. now i vaguely recall some of your lpastes there (which are now unfortunately lost)
08:45:06 <monochrom> You say "left, right" in the context of CFGs. In all other contexts, you say "head, tail".
08:46:10 <monochrom> The simplest one is "m = do { xs <- m; return (0 : xs) }"
08:47:12 <monochrom> There is a bigger one that actually uses the state and ends up giving you [0..]
08:48:30 <ski> mm. i was vaguely recalling something along those lines
08:49:33 <monochrom> Also consider Tardis :)
08:53:19 * hackage hlint 3.2 - Source code suggestions  https://hackage.haskell.org/package/hlint-3.2 (NeilMitchell)
08:56:17 <ski> > let calkinWilf = 1%1 : [y | x <- calkinWilf,y <- [recip (1 + recip x),1 + x]] in calkinWilf
08:56:20 <lambdabot>  [1 % 1,1 % 2,2 % 1,1 % 3,3 % 2,2 % 3,3 % 1,1 % 4,4 % 3,3 % 5,5 % 2,2 % 5,5 %...
08:56:55 <ski> (Tardis is some kind of time-travelling thing ?)
08:58:44 <dolio> It's backwards state, I think.
09:00:02 <ski> oh
09:02:16 <dolio> Someone needed to coin a less descriptive name for it.
09:07:42 <c_wraith> It's forward+backward state
09:08:50 * hackage propellor 5.12 - property-based host configuration management in haskell  https://hackage.haskell.org/package/propellor-5.12 (JoeyHess)
09:12:06 <sshine> is there a way to apply a ViewPattern on multiple arguments?
09:12:18 <sshine> I've got: readOp (readDUP -> Just dup) _ = Just dup
09:12:49 <sshine> but I've also got: readOp (readPUSH -> f) (f -> Just push) = Just push
09:13:07 <sshine> I'm beginning to think that either I'm doing this wrong, or ViewPatterns are not ideal here. :)
09:22:07 <ski> hm, that looks fun
09:23:18 <sshine> also, excellent advice during childbirth.
09:25:50 <cohn> o_0
09:28:35 <ski> sshine : how about `readOp x (readPUSH x -> Just push) = Just push' ?
09:32:29 <dolio> It seems like view patterns just being inappropriate might be the answer.
09:33:32 <dolio> Like, if it's always matching on Just and then yielding Just, it could be like `readDUP x <|> readPUSH x y <|> ...`
09:33:35 <dolio> Or similar.
09:33:38 <sshine> ski, thanks.
09:34:36 <sshine> dolio, that's probably a better way.
10:10:51 <ezzieyguywuf> hrm, so I'm using Martin Fowler's fgl library for its Graph data type. However, I find myself jumping through some hoops to make things work the way I want. Specifically, I have three different types of Node (I distinguish them by giving them a different Label). Depending on the Node type, it may be allowed a minimum/maximum number of adjacencies. Would I be better off forgetting altogether about 
10:10:57 <ezzieyguywuf> fgl, and just defining a data type for each node type and joining them up using a Map or something?
10:11:34 <ezzieyguywuf> I'm hesitant to "reinvent the wheel", especially because I don't actually know a whole lot about graph's and graph theory. Specifically, I care about adjacency information between nodes, which seems exactly what a graph is good for
10:25:16 <aldessa> Hi I have `a :: Sem r ()` where r has members (State Int) and (Output Bool). I'd like to run it and don't need the final state value, how would I pop (State Int) off the effect list to get a Sem r ()?
10:25:17 <aldessa> https://paste.debian.net/1163793/
10:26:33 <aldessa> i can get just the state without output to work by doing `run . execState (something)` but I'm not sure how to have it as a `Sem r ()`
10:27:19 * hackage skylighting-core 0.10.0.1 - syntax highlighting library  https://hackage.haskell.org/package/skylighting-core-0.10.0.1 (JohnMacFarlane)
10:28:19 <aldessa> i've tried doing execState 5 a >> (embed ()) but not really sure what i'm doing
10:28:19 * hackage skylighting 0.10.0.1 - syntax highlighting library  https://hackage.haskell.org/package/skylighting-0.10.0.1 (JohnMacFarlane)
10:42:50 * hackage rebase 1.7.3 - A more progressive alternative to the "base" package  https://hackage.haskell.org/package/rebase-1.7.3 (NikitaVolkov)
10:44:19 * hackage rerebase 1.7.3 - Reexports from "base" with a bunch of other standard libraries  https://hackage.haskell.org/package/rerebase-1.7.3 (NikitaVolkov)
10:45:15 <monochrom> "From the makers of Rebase... comes Rerebase" :)
10:51:06 <maerwald> sir Volkov strikes again
10:56:33 <aldessa> ^^ nvm all solved literally just <$
11:05:49 * hackage skylighting-core 0.10.0.2 - syntax highlighting library  https://hackage.haskell.org/package/skylighting-core-0.10.0.2 (JohnMacFarlane)
11:06:49 * hackage skylighting 0.10.0.2 - syntax highlighting library  https://hackage.haskell.org/package/skylighting-0.10.0.2 (JohnMacFarlane)
11:15:13 <ski> aldessa : hm, what's the context of this ? (and what was the fix ?)
11:17:01 <aldessa> ski : just some type tetris, learning polysemy right now; I was really confused how to use the state effect.
11:21:41 <ski> aldessa : hm, i see
11:55:36 <Enrico63> Hello there :D
11:59:13 <ski> hello Enrico63
12:00:53 <Enrico63> I started to follow Bartosz Milewski's classes on category theory which are on youtube
12:01:16 <Enrico63> Because I'm really enjoying haskell, and it's making me miss math books too :P
12:02:01 <Enrico63> So I was wandering, what if I wanted some _math_ book on category theory? Something 100% formal.
12:02:37 <Enrico63> There are several questions like this on math.stackexchange and other stackexchange sites, but... 
12:04:31 <geekosaur> @google categories for the working mathematician
12:04:34 <lambdabot> No Result Found.
12:04:53 <geekosaur> bah
12:04:59 <geekosaur> https://www.maths.ed.ac.uk/~v1ranick/papers/maclanecat.pdf
12:07:15 <MarcelineVQ> it does not fit your exact requirements but I've heard only praise for https://arxiv.org/abs/1803.05316  The reason I mention it is that a person can 'zone out' in pure maths pretty easily imo so something with some grounding can be worthwhile
12:08:27 <ski> Enrico63 : "Conceptual Mathematics: A first introduction to categories" by Lawvere & Schanuel
12:10:30 <ski> Enrico63 : perhaps you could also check out "Category Theory for Programmers" by Bartosz Milewski at <https://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/>. i haven't looked at it
12:11:01 <Enrico63> Category theory for programmers is available for free
12:11:11 <Enrico63> and I have indeed downloaded it
12:11:35 <Enrico63> but I was thinking about a pure category theory book, not related to programming.
12:12:17 <ski> Enrico63 : then the Lawvere & Schanuel book may be appropriate
12:16:26 <Enrico63> ski, thanks, I'll check that out
12:16:54 <ski> i liked it
12:17:14 <ski> also, it doesn't assume that much math background knowledge
12:17:42 <Enrico63> geekosaur, is that the "famous" Mac Lane's book?
12:17:54 <geekosaur> yes
12:17:55 <ski> (otoh, "Categories for the Working Mathematician" by Saunders Mac Lane does assume lots of background)
12:17:58 <ski> yes
12:19:41 <Enrico63> Wow, it was downloadable from that link!
12:31:49 * hackage pretty-simple 4.0.0.0 - pretty printer for data types with a 'Show' instance.  https://hackage.haskell.org/package/pretty-simple-4.0.0.0 (GeorgeThomas)
12:49:21 <juri_> hmm. for a given line in normal form (ax+by+c=0), how do i find a point or a line that is a given distance away?
12:49:48 <juri_> gah. sorry. wrong channel.
12:49:59 <juri_> (trying to do it in haskell, tho! :)
12:52:49 <cohn> ok, silly question, but how do I search for packages in stack?
12:53:03 <solonarv> juri_: are you looking for "distance between (ax+by+c=0) and a given point"?
12:53:10 <cohn> or is that what https://hackage.haskell.org/ is for?
12:53:42 <solonarv> cohn: not in stack, you can search on hackage (which you linked) or on https://stackage.org
12:53:52 <cohn> solonarv: ok thanks
12:54:20 <solonarv> the latter is maintained by the same people that maintain stack and also shows you the snapshot metadata (which package versions are in which snapshot)
12:54:52 <solonarv> this is helpful if you're using stack, because the way you configure it is that you pick a snapshot for it to use and stack will use exactly the package versions specified in that snapshot
12:56:33 <juri_> solonarv: no, i'm looking for "i want to translate a line a give distance away from itsself".
12:56:48 <cohn> solonarv: seems like a reasonable way to avoid dependency hell
13:00:49 <cohn> solonarv: is there a way to show what's installed locally when using a global stack install?
13:03:33 <merijn> cohn: Depends on what purpose you wanna know for :p
13:03:55 <merijn> There should be a package database that can interact with ghc-pkg somewhere, plus the install directory for the libraries
13:04:17 <merijn> But neither of those are super useful to know about, though
13:04:22 <cohn> ah
13:05:36 <merijn> Because the setup of both cabal-install and stack is to basically eschew the notion of a global package environment you'd find in something like python/ruby. Meaning that by design "what's in them" is fairly unimportant to know
13:06:53 <merijn> I mean, there *is* a global environment of where all the files are located, but it's not required to be consistent, i.e. you can have many conflicting versions of the same packages installed (the exact how differs between stack/cabal)
13:08:45 <cohn> yea, I noticed that. Kind of odd coming from a Python environment
13:09:03 <cohn> it kind of reminds me of Python's virtual environments
13:10:01 <merijn> except, transparently :p
13:10:10 <cohn> haha, yep
13:13:02 <merijn> cohn: Basically, Cabal (the library underlying both stack and cabal-install) and GHC both are perfectly fine with arbitrarily many conflicting versions being installed in parallel. Then when you build thing cabal-install or stack will (in different ways) select a subset of those packages that match your projects constraints and only make those packages visible (and install any that are missing). Which 
13:13:09 <merijn> means that "which packages are installed" is really only relevant to answer questions like "how much diskspace is being wasted?" to which the pragmatic option most people use is "meh, we just nuke the package folder once or twice a year if it gets too bad"
13:14:24 <solonarv> juri_: oops, stopped looking at irc for a moment. is there a specific direction in which you're translating the line?
13:15:25 <solonarv> (also we should perhaps move to #haskell-offtopic? I guess?)
13:17:09 <cohn> merijn: makes sense. probably makes more sense in a CI/CD environment than manual experimentation though.
13:17:19 * hackage exiftool 0.1.0.0 - Haskell bindings to ExifTool  https://hackage.haskell.org/package/exiftool-0.1.0.0 (MartinHoppenheit)
13:17:26 <boxscape> ...if `case 4 of {;;;;;4 -> 5;;;;;}` compiles, and `case 4 of {}` compiles, shouldn't `case 4 of {;;;;;;;}` also compile?
13:17:56 <boxscape> not being able to do this prevents me from writing readable production code :(
13:18:58 <merijn> cohn: Yeah, the only workflow that's currently a bit awkward is "playing with things in ghci without creating a project first", I usually just copy&paste an old cabal file and add whatever library I want as dependency if I wanna do that. There's room for improvement, but it's "good enough" that it's low on everyone's priority list
13:21:57 <cohn> gotcha.
13:28:48 <hekkaidekapus> > case 4 of {} -- boxscape: Your premisse is flawed, so…
13:28:51 <lambdabot>  *Exception: <interactive>:3:1-12: Non-exhaustive patterns in case
13:29:04 <boxscape> hekkaidekapus it compiled
13:29:25 <boxscape> that's a run-time error
13:29:27 <monochrom> That is a runtime error.
13:30:02 <monochrom> "case foo of {}" is allowed to go well with "data X".
13:30:14 <hekkaidekapus> Granted! How do you want to parse {;;;;}?
13:30:37 <boxscape> considering {;;;;4 -> 5;;;;} is the same as {4 -> 5}, I would expect {;;;;;;} to be the same as {}
13:31:17 <monochrom> I think it's just an oversight at Haskell 2010 time.
13:31:33 <boxscape> I think case foo of {} also isn't part of Haskell 2010?
13:31:39 <hekkaidekapus> {} requires an extension to begin with.
13:31:47 <boxscape> so I guess an oversight on the extensions part
13:31:57 <monochrom> Hrm, yeah OK!
13:31:59 <int-e> monochrom: Haskell2010 doesn't have empty cases
13:33:32 <int-e> Hmm, the empty case is a separate production in GHC's grammar. (And indeed doesn't allow semicolons.)
13:34:26 <int-e> And https://gitlab.haskell.org/ghc/ghc/-/issues/2431 looks like that aspect was never considered.
13:38:23 <monochrom> annabelle dollhouses  >_<
13:39:06 <monochrom> Wanna buy an empty dollhouse to go with your empty doll type? >:)
13:39:24 <hekkaidekapus> lol! Which is fitting, given empty case is kind of a toy!
13:59:58 <koz_> {;;;;;} -- Cthulhu?
14:01:39 <monochrom> haha
14:02:05 <monochrom> {-# LANGUAGE CthulhuEmptyCase #-}
14:12:57 <sm[m]> cohn: to see which library packages are installed, in a global or project context, cd ~ or to the project and use stack exec -- ghc-pkg list (or cabal exec, presumably)
14:13:25 <sm[m]> to see which executables have been installed, look at ~/.local/bin or ~/.cabal/bin
14:19:08 <matthew_> Hi all, does anyone know of a way to add a Int8 to a Word8?
14:19:57 <boxscape> % (4 :: Word8) + fromIntegral (8 :: Int8)
14:19:57 <yahb> boxscape: 12
14:20:04 <hpc> convert one or both of them to your desired type
14:20:25 <sm[m]> warning, fromIntegral hides wrapping errors. Maybe toInteger can help ?
14:21:00 <hyiltiz> https://groups.google.com/forum/?oi=1&oi=1&oi=1#!forum/fa.haskell seems awfully in need of admins
14:21:11 <hyiltiz> Any idea if the admin is here?
14:22:06 <merijn> DOes, it really need one?
14:22:15 <merijn> The last spam post seems to be from 2014
14:22:20 <merijn> eh
14:22:23 <merijn> non-spam
14:23:27 <cohn> sm[m]: thanks!
14:23:28 <ski> (2016)
14:26:21 <matthew_>  % (4 :: Word8) + fromIntegral ((-2) :: Int8)
14:26:53 <matthew_> % (4 :: Word8) + fromIntegral ((-2) :: Int8)
14:26:53 <yahb> matthew_: 2
14:27:30 <matthew_> Ah, so it will still negate after the fromIntegral?
14:27:38 <tomsmeding> it won't, but:
14:27:44 <tomsmeding> % (255 :: Word8) + 1
14:27:44 <yahb> tomsmeding: 0
14:27:51 <tomsmeding> ;)
14:28:16 <boxscape> % fromIntegral ((-2) :: Int8) :: Word8
14:28:16 <yahb> boxscape: 254
14:28:17 <tomsmeding> -2 becomes 254 as a Word8, which functions as -2
14:28:35 <matthew_> Ahhhh, clever! :-)
14:29:35 <tomsmeding> semi-related: a reason why 2's-complement is a popular signed integer representation in processors nowadays is that it allows you to have mostly the same arithmetic circuitry for unsigned and signed integers
14:30:06 <tomsmeding> in particular, for addition and subtraction, you don't need to care whether you have signed or unsigned integers if you have the signed integers in 2's-complement representation
14:30:09 <koz_> Yep, it's pretty cool that way.
14:30:18 <koz_> You don't even need to have separate adders and subtractors.
14:30:25 <tomsmeding> jinx
14:33:19 * hackage composite-tuple 0.1.1.0 - Tuple functions for composite records.  https://hackage.haskell.org/package/composite-tuple-0.1.1.0 (locallycompact)
14:35:48 <hpc> multiplication seems to be the same too
14:36:55 <koz_> hpc: For integers, I think dividers and multipliers are still different. Compilers can convert one into the other for constants though.
14:37:41 <hpc> > (254 * 254 :: Word8, fromIntegral (-2 :: Int8) :: Word8)
14:37:44 <lambdabot>  (4,254)
14:38:10 <hpc> too lazy to figure out a good quickcheck for this ;)
14:40:40 <hpc> never mind, negative * positive is very different
14:40:55 <hpc> never never mind, that was a warning not an error
14:40:58 <hpc> come on, ghci
14:41:49 * hackage ixset-typed-conversions 0.1.2.0 - Conversions from ixset-typed to other containers.  https://hackage.haskell.org/package/ixset-typed-conversions-0.1.2.0 (locallycompact)
14:44:07 <hpc> > all (\(x, y) -> (x * y) == (fromIntegral (fromIntegral x * fromIntegral y :: Int8) :: Word8)) ((,) <$> [0..255] <*> [0..255])
14:44:10 <lambdabot>  True
14:44:16 <hpc> multiplication is the same :D
14:44:57 <koz_> hpc: Oh yeah, that I agree.
14:47:31 <hpc> and yeah, division is different
14:47:45 <koz_> Trickiest of the four arithmetic ops.
14:47:56 <koz_> I _still_ don't fully get how dividers work.
14:48:04 <koz_> (adders and multipliers at least I get)
14:49:19 <hpc> oof, yeah
16:47:47 <manta97> I'm trying to install the ghcid plugin for emacs but I'm getting an error saying "Symbol's value as variable is void: compilation-error-regexp-alist-alist" after adding the path of ghcid.el to my .emacs file, how can I fix this?
16:49:25 <Lycurgus> #emacs query
16:50:29 <manta97> cheers
17:18:18 * hackage language-dickinson 1.3.0.3 - A language for generative literature  https://hackage.haskell.org/package/language-dickinson-1.3.0.3 (vmchale)
17:52:20 <rustisafungus> i've been thinking it would be interesting to think about keeping data in cache compressed, if it is possible to do such a thing, in order to (possibly) increase the effective cache size and bandwidth
18:06:39 <Axman6> which cache?
18:08:24 <rustisafungus> maybe L3, but this mode of thinking might apply at a number of contexts,... basically trying to focus on always computing on compressed data as much as is practical
18:08:49 <rustisafungus> in order to address the realities of the memory hierarchy
18:08:50 <Axman6> There's definitely several ways to compress Haskell data, ranging from putting it in a Compact region and compressing the raw in memory format of the data (and making sure you don't hold onto any references to the uncompressed data), serialising it using the many serialisation libraries (serialise is the one I'd pick)
18:14:25 <Lycurgus> L3 means processor cache?
18:15:21 * Lycurgus presumes not
18:15:30 <Axman6> macOS' memory manager compressesd old pages IIRC, I'd be surprised if other OS's don't too
18:15:39 <edwardk> rustisafungus: so, like an old school ram doubler?
18:16:02 <Axman6> those flat out just didn't work right?
18:16:22 <Axman6> the 8-bit guy had a good video on how they were a complete scam
18:16:46 <edwardk> compression is a real thing. it isn't exactly double but its not bad
18:16:51 * Lycurgus : raised eyebrows at the idea if not done in hardware (and processor cache was meant)
18:16:57 <edwardk> they lost out mostly to ram coming way down in pric
18:16:59 <edwardk> er price
18:17:10 <Axman6> sounds painful :)
18:17:57 <edwardk> it really is workload dependent if it was ever a good idea
18:18:10 <edwardk> but disk is _slow_ by comparison, which buys a ton of time for compression.
18:18:18 <Axman6> need more hardware acceleration for LZ4
18:18:23 <edwardk> ram a little less so, but still slow by l1,2,3 standards
18:18:49 <Axman6> yeah I'd be very surprised if there was much to be gained by storing data in CPU caches compressed
18:19:35 <edwardk> re 8bit guy, there is an implementation of a decent streaming compressor built into the X16, so if he is saying it is pointless he's a little cynical ;)
18:19:37 <davean> Its basicly compressed swap in memory
18:19:49 <edwardk> er built into the x16 rom
18:19:52 <edwardk> its software
18:20:32 <Axman6> I think we was walking about software like dtat doubler for Mac OS, which IIRC just lied to the user and did nothing at all
18:21:44 <edwardk> stacker, ram doubler, all at least did compression
18:22:19 <dolio> Just like in Johnny Mnemonic.
18:22:23 <Axman6> hmm, maybe it wasn't him either, must've been someone else
18:23:50 <edwardk> Axman6: https://www.lifewire.com/understanding-compressed-memory-os-x-2260327 apparently it is back and mainstream in osx 10.9
18:24:00 <edwardk> so it just got absorbed into the borg
18:24:12 <Axman6> yeah, I mentioned that above
18:24:34 <edwardk> sorry
18:24:35 <edwardk> tuned in late
18:25:12 <Axman6> All good, such as life on IRC. I think https://www.youtube.com/watch?v=rxEoZEphs9g is the video I was thinking about
18:31:09 <edwardk> ah softram 95
18:31:12 <edwardk> forgot that one
18:33:06 <davean> I think RAM compression is one of those techniques that works better the less you need it.
18:33:23 <edwardk> i remember when i by somewhat circuitous means managed to get 64 megs(!) of ram at a time when 4 megs was the norm. (i still had a 40 meg hard drive at the time!)  i then loaded everything into a huge ram disk for playing games, and all of a sudden level loading times went to 0. That was a magical day.
18:34:18 <ddellacosta> that must have cost a bundle at that time
18:34:37 <edwardk> it would have, yes.
18:34:55 <edwardk> the circuitous means in question removed the cost to me
18:35:02 <ddellacosta> haha gotcha
18:35:27 <edwardk> i was somewhat less ethical at the time
18:36:36 * ddellacosta imagines edwardk purchasing black market ram off the back of a truck
18:37:00 <edwardk> not far off =P
18:39:32 <edwardk> now, i did wind up with a big old AT&T unix box as a kid because my did literally did that. (he was there when a couple of guys were unloading it off said truck into a facility and it fell, he took it home as scrap as a favor)
18:48:47 * Lycurgus .o( e did e? )
19:17:51 <hololeap> let's say you have a data type: data Foo a = Foo a | Bar Int a | Baz a
19:19:00 <hololeap> this could also be written as: data FooType = FooT | BarT Int | BazT ; newtype Foo a = Foo (FooType, a)
19:19:21 <hololeap> what are the pros and cons of each version?
19:20:28 <hololeap> i know that one pro for the latter version is that you can use GeneralizedNewtypeDeriving for (,)
19:22:56 <lyxia> the main point for the first is that it is easily extensible if you are going to break the invariant that there is only one a in the future.
19:23:44 <MarcelineVQ> it's also all in one spot so brain cache-locality is preserved
19:27:22 <Cale> hololeap: Also, no reason to make that second thing a newtype -- data Foo a = Foo FooType a  will be just as good
19:28:28 <Cale> oh, apart from your remark about GND of course
19:29:37 <Cale> If you wanted to use record syntax for Foo, the second is better.
19:29:46 <Cale> (since record syntax for sums sucks)
19:31:18 <hololeap> let's assume the invariant that there is only one `a' per constructor isn't going to be broken
19:31:44 <hololeap> MarcelineVQ makes a good point
19:32:37 <hololeap> i suppose that GND would be the only good selling point for the latter
19:33:07 <Cale> Sometimes making that transformation is good just because the two things really have a lot less to do with one another than the Foo type would suggest
19:33:15 <Cale> and so factoring them apart is the right thing
19:33:49 <Cale> and sometimes the opposite can be true
19:34:56 <hololeap> the actual type is: data Item a = ItemReady a | ItemWaiting Int a | ItemExecuting a
19:34:56 <Cale> Sometimes that extra tag is crucial to being able to interpret the value of type 'a' correctly (whatever it may be)
19:35:46 <hololeap> so i'm not sure where this would fall in terms of the item's state vs. the item's value
19:36:19 * hackage rio 0.1.19.0 - A standard library for Haskell  https://hackage.haskell.org/package/rio-0.1.19.0 (MichaelSnoyman)
19:36:26 <hololeap> i was considering rewriting it to be the latter option in my original question, but i thought i would ask here first
19:53:49 * hackage swiss-ephemeris 1.2.0.0 - Haskell bindings for the Swiss Ephemeris C library  https://hackage.haskell.org/package/swiss-ephemeris-1.2.0.0 (lfborjas)
20:09:54 <hololeap> % import Control.Monad.Trans.Accum
20:09:54 <yahb> hololeap: 
20:10:03 <hololeap> % :t accum
20:10:03 <yahb> hololeap: ; <interactive>:1:1: error:; Ambiguous occurrence `accum'; It could refer to; either `Control.Monad.Trans.Accum.accum', imported from `Control.Monad.Trans.Accum'; or `Data.Array.accum', imported from `Data.Array' (and originally defined in `GHC.Arr')
20:10:23 <hololeap> % import qualified Control.Monad.Trans.Accum as Accum
20:10:23 <yahb> hololeap: 
20:10:30 <hololeap> % :t Accum.accum
20:10:30 <yahb> hololeap: Monad m => (w -> (a, w)) -> AccumT w m a
20:10:57 <hololeap> % :t writer
20:10:57 <yahb> hololeap: MonadWriter w m => (a, w) -> m a
20:11:08 <hololeap> % :t state
20:11:08 <yahb> hololeap: MonadState s m => (s -> (a, s)) -> m a
20:12:07 <hololeap> what is the reason for having the functorial value `a' as the first value in the tuple in these monads?
20:13:19 <hololeap> % :t fmap :: (a -> b) -> (x,a) -> (x,b)
20:13:19 <yahb> hololeap: (a -> b) -> (x, a) -> (x, b)
20:13:21 <MarcelineVQ> just to mess with you
20:14:02 <hololeap> MarcelineVQ: best answer so far :)
20:15:40 <hololeap> it doesn't matter too much because of the API, but it seems odd
20:16:51 <MarcelineVQ> yep
20:17:23 <hololeap> for historical/sadistic reasons
20:36:15 <dolio> It is the natural way for arbitrary monoidal categories.
20:42:26 <Axman6> It's definitely a wart hololeap and I don't think it's one we can fix because so much code will be relying on it. It's definitely the wrong choice
20:51:51 <MarcelineVQ> What's the immediate advantage of (s,a) ?
20:52:46 <Axman6> deriving Functor via Compose ((->) w) ((,) w)
20:53:25 <glguy> The advantage is that we could rewrite the instance that's already written with derivingvia?
20:55:19 <Axman6> it's certainly less surprising if the instance is consistent with what you would expect from the composition of the two functors it's made up of
20:55:43 <MarcelineVQ> Put another way, what makes (a,s) a wart in practice?
20:55:46 <glguy> I don't remember that last Functor instance that was surprising
20:56:12 <davean> glguy: I don't recall off the top of my head, but I remember every time I use StateT that I wish it was the other way because it would take less code :)
20:56:38 <Axman6> exactly
20:56:50 <davean> I end up with "swap" a lot
20:56:52 <MarcelineVQ> Any particular examples? first instead of fmap doesn't seem like a lot more, for the basic case
20:57:32 <Axman6> it's an extra import and needing to remember "Oh yeah, this isn't consistent" every time 
21:00:24 <davean> I mean I also think "runState"'s arguments are in the pesimal order too
21:02:02 <MarcelineVQ> davean: s should come first in runState? I agree
21:02:54 <MarcelineVQ> That at least has a reason I follow :>
21:03:06 <Axman6> yeah, but that's the expected result for the record declaration. unfortunate though
21:04:37 <davean> i want to run it, not use its record declaration ;)
21:06:29 <Axman6> it's an unfortunate convention that we decided record syntax should be used for accessing the inner type for monad transformers
21:06:43 <davean> I don't follow it for mine
21:06:48 <Axman6> good
21:08:28 <hololeap> if nothing else, having it be consistant would reduce irc traffic :p
21:09:15 <Axman6> After Netflix, ISP's most hated form of traffic
21:10:20 <davean> I don't know, Netflix isn't banned in a lot of ToSs, IRC is
21:10:32 <hololeap> Axman6: what would be the alternative regarding record syntax unpacking monad transformers
21:10:57 <Axman6> just defining a function with the more useful order of arguments
21:10:57 <davean> StateT { runStateT' :: ...}
21:11:06 <davean> runStateT = ...
21:11:17 <Axman6> I've witten too many flip runState initialState's for one lifetime
21:11:39 <davean> (`runState` initialState)
21:11:41 <davean> but yah
21:11:43 <hololeap> that is true
21:11:44 <davean> LITTERED EVERYWHERE
21:12:26 <hololeap> although that issue with the order of arguments is a constant battle
21:12:33 <hololeap> for any function
21:12:50 <davean> Yah, I can see how in some coding styles this order makes sense
21:12:56 <davean> I've never really done that style, but I get it.
21:13:03 <davean> but thats why I have both
21:14:10 <hololeap> what do you mean you have both?
21:14:15 <davean> see above
21:14:27 <davean> like 10 lines up
21:14:35 <hololeap> oh, you mean runMonadT' vs runMonadT
21:14:38 <davean> yes
21:14:52 <davean> Not that I ever use the ' variants, but someone might
21:16:31 <hololeap> i agree that `flip runMonadT` should be the less-common use case
21:16:41 <glguy> davean: IRC is banned in lots of ToS?
21:17:39 <davean> glguy: absolutely. Rather a holdover from the late-90s generally, modern places don't bother. But ISPs banned it in their ToS 20 years ago and never removed it. Particularly datacenter ISPs, but consumer ones too.
21:18:06 <Axman6> davean: Netflix isn;'t banned because they do a lot of work getting their equipment into ISPs POPs to reduce the ISP'
21:18:13 <Axman6> ISP's costs*
21:18:58 <glguy> davean: Any chance you have a reference on that? I'd be curious to read an example or any other details :)
21:19:15 <davean> glguy: Oh mostly it was the file tradeing
21:19:19 <davean> and the DoSs
21:19:48 <davean> and generally it was specificly running IRC servers, not connecting out. But some just banned IRC specificly.
21:20:20 <hololeap> the ip addresses or the ports?
21:20:30 <hololeap> i haven't run into this
21:20:36 <davean> hololeap: neither, its a ToS they ban the protocol
21:20:42 <davean> its a legal document
21:20:55 <davean> hololeap: how many ISP ToS have you read closely? :)
21:21:01 <davean> particularly 10 years ago
21:21:13 <hololeap> none, but i would notice if they blocked irc traffic
21:21:20 <davean> I never said block
21:21:23 <davean> I said ban
21:21:28 <davean> its a legal document, thats what a ToS is
21:21:46 <hololeap> oh, so i'm potentially breaking ToS by connecting
21:22:09 <hololeap> hilarious considering they have the ability to physically block it
21:22:27 <davean> Uh thats expensive.
21:22:33 <davean> Also IRC was on a LOT of ports
21:23:12 <davean> glguy: I ahppen to remember https://web.archive.org/web/20110225094020/http://www.voxel.net/aup off the top of my head.
21:23:21 <davean> But thats pretty standard language about IRC
21:23:24 <glguy> I found a forum post about this topic from 2003 saying that it didn't matter because IRC was "too antiquated"
21:23:28 <davean> Pretty sure it was in softlayer's too
21:23:32 <davean> and comcast's at one point
21:23:54 <hololeap> but what about <name some chat protocol>
21:23:55 <glguy> ha
21:23:57 <davean> I know my college network had a policy about it too but I forget the wording.
21:25:06 <hololeap> like how do they define irc, do they cite the RFC document?
21:25:07 <davean> In general no one reads or abides by ToS though so ...
21:25:15 <davean> hololeap: its a legal document ...
21:25:24 <hololeap> that really means nothing to me
21:25:24 <davean> hololeap: I'm getting the feeling you don't know how the legal system works?
21:25:47 <hololeap> that feels like a trick question
21:26:03 <glguy> since no one does, there's probably a safe answer :)
21:26:04 <davean> You don't have to define it, you have to be able to argue it in court.
21:26:10 <Axman6> in common law countries that probably comes down to "what a reasonable person would understand to be IRC"
21:26:17 <davean> Axman6: exactly.
21:26:26 <davean> Does the court think its IRC?
21:26:31 <davean> Yes? You better not have done it.
21:27:06 <Axman6> when I was a patent examiner there was a lot of "A person skilled in the art" when it comes to someone being able to understand the disclosure of a patent - they don't need to be understandable to every layperson, but they do need to be understandable to someone who works in the field
21:27:50 <Axman6> that was a job that was equal parts fascinating and tedious
21:29:10 <hololeap> so, in other words, vague laws are used to selectively persecute individuals based on reasons decided by the people operating the system?]
21:29:25 <Axman6> no, not at all
21:30:29 <davean> No, this is a "Just because you cover your eyes doesn't mean we can't see you" case. They said IRC. We can all figure out what IRC is.
21:30:51 <glguy> Is that true? You can still see me when I close my eyes?
21:31:04 * glguy tests this
21:31:33 <hololeap> you would have to define "we"... just a minute ago "we" meant "a reasonable person" which itself is vague
21:32:06 <davean> hololeap: yes, and the court really isn't really interested in your "we can't know anything, theory of knowlege is bullshit" game.
21:32:12 <Axman6> glguy: prove it
21:32:36 * MarcelineVQ stops existing
21:32:46 <Axman6> oops
21:32:48 <glguy> Who said anything about proof? I said testing
21:33:39 <hololeap> davean: that's a bit of a leap in logic there, to assume that's my game
21:34:58 * MarcelineVQ fades back in but is missing one of the 3 primary colors, which one depends on the person looking.
21:44:12 * hololeap gathers a group of test samples to determine MarcelineVQ's true color palette
21:53:54 <glguy> Have you played The Witness?
21:54:09 <hololeap> a bit
21:55:07 <glguy> There's a series of puzzles where you figure out something's true colors is all :)
21:56:13 <hololeap> yeah, that was one that i did reach, although i ended up getting frustrated by "having" to look up answers for some of the more esoteric puzzles
21:57:26 <hololeap> where it would give you a pattern that was somewhat difficult to figure out and then change it toward the end of the puzzle
21:59:53 <hololeap> i suppose it would have been more satisfying if i had been more patient
22:02:33 <hololeap> or if i knew that curveballs were part of the game
22:28:02 <fernando__> hu
22:28:48 <hyiltiz> IRC, ToS, DoS, FRC, ISP, LOT... So many acronyms for this topic I am now sure I am a nerd to follow it
22:34:06 <fernando_> hi
22:50:39 <hyiltiz> tomsmeding the paste site has already reached past 50 commits; beyond the quick and dirty small hobby side project. Decided to maintain it for a while?
23:48:02 <tomsmeding> hyiltiz: I'm fine with maintaining it for a while :)
23:48:25 <tomsmeding> I won't disappear in a flash if I can help it
23:48:40 * tomsmeding . o O ( that's what they all say )
23:55:43 <glguy> I used to run hpaste; hang in there while you can ^_^
