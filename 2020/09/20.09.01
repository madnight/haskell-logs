00:01:40 <tomsmeding> hyiltiz: all JS exquisitely handcrafted
00:02:29 <tomsmeding> Also yes the text still needed to be put in bullet list form; your example looks great to me!
00:06:27 <sim590> I'm writing a library that is going to be equipped with logging capability. The user may have to provide configuration on how to enable/disable logging or various options. I'm wondering how to handle those concerns. I thought that I could provide an answer by making a warpper around IO with Reader or State capability, so may be rather a wrapper around StateT s IO and make all of the libraries' API
00:06:28 <sim590> functions live in the monad. Is that a sensible design? Otherwise, maybe I could provide IO functions that could handle logging for the user, but make my main API functions live in a wrapper around the Chronicle monad so that it returns messages through that monad and that the user could choose to handle it with utility IO functions or use his own. Any ideas to guide me?
00:07:58 <sim590> Going to sleep right now, so I'll read messages later. Thanks.
00:28:04 <tdammers> sim590: I would go with either: a) taking a function :: LogMessage -> IO () from the caller, and having the entire API live in a monad that can be bootstrapped from IO (i.e., have a function runAPI :: API a -> IO a or sth); or b) expose a typeclass MonadLogging m where log :: LogMessage -> m (); add that typeclass as a constraint to all your exposed API functions, and leave implementation up to the caller
00:28:06 <tdammers> (but provide an instance for Identity that doesn't log at all, and maybe also one for IO that logs to stdout)
00:42:45 <hyiltiz> tomsmeding: didnt know your brain is js compatible
00:43:56 <tomsmeding> hyiltiz: even now I would still venture that I know c++ better than haskell
00:44:49 * hackage conduit 1.3.2.1 - Streaming data processing library.  https://hackage.haskell.org/package/conduit-1.3.2.1 (MichaelSnoyman)
00:45:07 <[exa]> tomsmeding: the 1800 pages of the standard would disagree... :]
00:45:35 <tomsmeding> fair point
00:46:21 <tomsmeding> though I haven't read the haskell report either, nor the proposals the the ghc extensions I'm using :p
00:47:23 <dminuoso> The haskell report is so readable, that it could easily serve as a basis for learning Haskell for some. :p
00:48:02 <tomsmeding> something that cannot be said about the c++ standard
00:48:15 <tomsmeding> is that thing even freely available? I recall the C standard is only available in draft form
00:48:32 <dminuoso> You can get the final drafts of both.
00:49:00 <[exa]> yeah.. I actually like the c++ standard too, but seriously after reading some fundamenatal parts you are still left with the question like 'will the code actually do anything' and 'does the computer really exist'
00:49:21 <dminuoso> [exa]: The C++ standard is so complicated, the C++ committee regularly has debates about what parts of it mean.
00:49:39 <dminuoso> If they don't even know or can't agree..
00:49:54 <dminuoso> (Most of the confusion relates to templates)
00:50:50 <tomsmeding> re:templates: unsurprisingly
00:50:58 <dminuoso> [exa]: As a random fun fact: Through subtle and arcane template instantiation rules, one can conjure up a constexpr that evaluates to two different values in two occurences of its expression.
00:51:04 <dminuoso> And it's standard conform!
00:51:14 <tomsmeding> hyiltiz: with our text https://tomsmeding.com/f/pastebin-restyle-nonworking.html
00:51:37 <tomsmeding> dminuoso: rust can do the same thing, but there it's intended
00:51:48 <tomsmeding> (replacing "template" with "macro")
00:52:42 <hyiltiz> tomsmeding ++
00:52:55 <tomsmeding> hyiltiz: oh what the heck it's live https://paste.tomsmeding.com/
00:52:58 <dminuoso> tomsmeding: well in case of C++constexpr
00:53:01 <hyiltiz> Seems good 'nuff to roll out that "beta" into live
00:53:02 <dminuoso> It's definitely not intended.
00:53:13 <tomsmeding> dminuoso: sweet
00:53:17 <hyiltiz> oh nice it IS live
00:53:34 <tomsmeding> though the read page is still old :p
00:57:42 <[exa]> what's wrong about templates? the whole thing is straightforward
00:58:03 <[exa]> tomsmeding: btw I store a copy here http://e-x-a.org/mff/w/std.pdf
00:58:29 <tomsmeding> which, indeed, is the draft :p
00:58:49 <dminuoso> [exa]: You get no free theorems because of specialization.
00:59:53 <tomsmeding> I am continually surprised why the full standard is >180 eur
01:01:12 <timCF> Hello! Do you guys know any useful library for secp256r1 cryptography? Basic things like managing keys, signing, verifying, DER encoding?
01:01:14 <dminuoso> tomsmeding: ISO has that up in a FAQ somewhere
01:01:31 <dminuoso> timCF: openssl?
01:01:32 <[exa]> dminuoso: yeah, no one wanted that in an assembly macrolanguage :D
01:01:59 <timCF> dminuoso I mean in Haskell 😀
01:02:05 <dminuoso> timCF: openssl.
01:02:13 <tomsmeding> dminuoso: if you mean this one, it doesn't really tell me much :p https://isocpp.org/std/the-standard
01:02:26 <dminuoso> If cryptography is important to you at all, please ffi into a well tested peer reviewed cryptography library
01:02:52 <dminuoso> tomsmeding: Mmm. I meant this https://www.ansi.org/help/charge_standards
01:03:02 <timCF> Ok, thanks!
01:03:03 <tomsmeding> ah that's more text
01:03:04 <dminuoso> (The reasons are the same)
01:03:22 <dminuoso> Note Im not defending charging for standards, just citing what reasons they bring up.
01:04:28 <tomsmeding> I guess it makes sense?
01:04:39 <tomsmeding> though first paragraph under "Supporting the standards users" is total BS
01:05:01 <tomsmeding> "users need to know it is available for their use" how many people who work with c++ need to be told the standard is available for their user
01:05:05 <tomsmeding> s/.$//
01:05:08 <dminuoso> Well in part it's just justifying what one might consider as ransom.
01:06:02 <dminuoso> In part some of the reasons might apply to engineering standards rather than CS standards.
01:14:26 <tomsmeding> oh fair, this is a generic page. makes more sense
01:14:35 <hyiltiz> Reads like a beauricracy of text generated to justify a beauricratic practice by beaurocrats. 
01:15:58 <hyiltiz> Maintenance fee for a standard? Now they need to ask for the fee for informing us about the maintenance fee as well. Corecurse henceforth
01:16:09 <dminuoso> For what its worth, for most uses the freely available draft suffices.
01:16:55 <maerwald> https://bsd.to/mRS7/raw who knows how to fix this? The stack issue tells me to put my folder higher in the hierarchy. That didn't help.
01:16:59 <hyiltiz> I think it even suffices for even compiler wtiters
01:17:16 <hyiltiz> Not all compilers are perfectly compatible anyways
01:18:20 <hyiltiz> Paste responsibly. Information submitted here should not be considered private.
01:18:36 <dminuoso> hyiltiz: In case of C++ it's very difficult to write a standard conform compiler. :(
01:18:45 <hyiltiz> tomsmeding: do you think the site needs some disclaimer like that?
01:19:15 <maerwald> hyiltiz: paste responsibly?
01:19:30 <tomsmeding> hyiltiz: pastebin.com doesn't seem to have it?
01:19:36 <dminuoso> hyiltiz: Ultimately, once a cash cow is identified, you do everything to milk it.
01:19:37 <hyiltiz> Then spending 300Eur is just wasting Corp or taxpayer money for a unreasonable cause
01:19:59 <dminuoso> It's why Apple is charging 30% for all app store transaction. It's not because it's necessary, it's just protection money.
01:21:00 <dminuoso> Papers tend to be buried behind paywalls for similar reasons. :)
01:21:08 <dminuoso> Luckily we have scihub though.
01:21:35 <dminuoso> (There was an amusing publication recently showing that a paper gets more citations if it's available on scihub)
01:21:49 <hyiltiz> I think a disclaimer has to be both brief enough (less than 5-20 words) AND legally protective of the webadmin from anyone abusers 
01:22:37 <tomsmeding> hyiltiz: right so this is mean to protect the hoster (me) from people uploading illegal stuff?
01:22:47 <hyiltiz> If such a disclaimer doesn't exist we may as well go without it so the de dacto laws kick in
01:22:53 <tomsmeding> does such a disclaimer help even?
01:23:07 <tomsmeding> yes I think so
01:23:16 <tomsmeding> I mean, `shred pastes.db` is easy enough
01:23:19 <hyiltiz> it usually clarifies vague things 
01:23:38 <hyiltiz> Life you don't support whatever they say in your hosted site etc.
01:23:54 <hyiltiz> You are just hosting a site and people can say whatever
01:23:56 <tomsmeding> yes that may be useful on the read page
01:24:35 <hyiltiz> It doesn't even have to be normal text size
01:25:25 <hyiltiz> To make matters worse disclaimers that is good one country's law may not be so for another...
01:25:30 <hyiltiz> Can of worms
01:25:50 <hyiltiz> I wish disclaimers are templated like licences 
01:26:09 <hyiltiz> You just say GNU Disclaimer v1 and be done
01:27:03 <tomsmeding> would be nice, wouldn't it? :p
01:27:03 <maerwald> unless it's that version X or later nonsense, which is questionable legally
01:27:31 <tomsmeding> downside of having disclaimer templates like that is that noone ever reads them anymore
01:27:41 <hyiltiz> Again we may be overthinking here on premature optimization tho you don't wanna lazy evaluate law...
01:28:51 <hyiltiz> I think a paste sitd should be fine in most counties that respect freedom of speech
01:29:06 <tomsmeding> I guess?
01:29:21 <tomsmeding> though factor why I'm still going to add a minimal one is that it's currently under tomsmeding.com :p
01:29:38 <hyiltiz> Worst case scenario you'll get permanently banned to visit some Orwellian state 
01:29:46 <tomsmeding> fair
01:30:05 <tomsmeding> which would not be such a bad thing anyhow :p
01:30:08 <hyiltiz> You are probably better off not going there in the first place 😜
01:31:39 <hyiltiz> "Content uploaded by users are not endorsed by this website."
01:32:41 <hyiltiz> Something like that should be fine as a start I think?
01:32:41 <tomsmeding> is that the same 'are' as 'the police are'?
01:33:09 <hyiltiz> I was thinking about that as well lol
01:35:26 <tomsmeding> eh? it looks kinda cheesy on the read page but I guess that can be fixed by applying a similar redesign as was done to index.html
01:35:29 <hyiltiz> May as well just copy a law speak that says something like that from another site
01:35:51 <hyiltiz> They probably invited a lawyer to write it
01:35:54 <maerwald> where is the .cabal directory on windows?
01:36:47 <tomsmeding> hyiltiz: disclaimers are live on https://paste.tomsmeding.com
01:37:17 <hyiltiz> Oh are spiders denied access?
01:37:53 <tomsmeding> no, is that an issue?
01:38:14 <tomsmeding> right
01:38:32 <hyiltiz> First time opened the site on phone, looks awesome
01:38:43 <tomsmeding> it might make sense to have a robots.txt, conflicted
01:38:51 <tomsmeding> yes it looks surprisingly fine on mobile :)
01:39:04 <hyiltiz> It could be; suppose someone starts a revolution as your paste bin as the hub for communication
01:39:23 <hyiltiz> (I just watched the Animal Farm animation tonight)
01:39:50 <tomsmeding> pastebin.com doesn't seem to have such a robots.txt https://www.google.com/search?hl=en&q=site%3Apastebin.com
01:39:56 <tomsmeding> also interesting results
01:39:58 <tomsmeding> okay good point
01:40:00 <hyiltiz> Yeah a robots.txt is good idea
01:40:32 <koz_> What is a robots.txt?
01:41:23 <tomsmeding> koz_: well-meaning web crawlers read that file to see what sections of a web site they're allowed to crawl/index
01:41:34 <tomsmeding> https://www.google.com/robots.txt
01:41:36 <koz_> tomsmeding: Ah.
01:42:08 <koz_> Good to know.
01:42:43 <hyiltiz> Can't believe we are discussing these things while it took you 2h to build the thing lol
01:43:17 <tomsmeding> :')
01:43:34 <tomsmeding> do you know by any chance if it's possible to have robots index / but not anything under /
01:44:48 <hyiltiz> Huh? I think you started a paradox
01:44:54 <hyiltiz> Or type error
01:45:01 <hyiltiz> stated
01:45:17 <koz_> hyiltiz: Type :: Type
01:45:24 <tomsmeding> no I literally mean: only index /, not /abc nor /def
01:45:28 <koz_> There's your inconsistency. :P
01:45:49 <koz_> (don't ask me to prove why)
01:45:53 <tomsmeding> so this is one of the reasons I'm hesitant to put pastes directly under the root :p
01:46:06 <hyiltiz> Hmm allow /* disallow /*/*? 
01:46:17 <tomsmeding> had it still been /paste/*, I could've written Allow: /; Disallow: /paste/
01:46:23 <hyiltiz> Something like that? I don't know but there should be
01:46:24 <[exa]> tomsmeding: users whining sounds: could we have monospace in the paste textbox, and a sticky footer as in https://paste.tomsmeding.com/Y8Yor4gB ? :]
01:46:44 <hyiltiz> But not all robots are well meaning so...
01:46:56 <tomsmeding> hyiltiz: google's bot is well-meaning enough
01:47:07 <tomsmeding> for this
01:47:14 <hyiltiz> wget -m scapes everything
01:47:49 <tomsmeding> [exa]: interesting, lemme look
01:48:51 <hyiltiz> I was thinking about having monospace for textbox
01:49:02 <[exa]> tomsmeding: I'm on ffox 80, the footer strip goes right through the middle of the page on 1080p, and well monospace just helps with code... Hopefully it's not my ff broken. :]
01:49:06 <hyiltiz> We may go so the way and use hasklig...
01:49:15 <hyiltiz> Not that makes the site heavier
01:49:31 <tomsmeding> [exa]: for me it doesn't go through the middle of the page :')
01:49:34 <tomsmeding> but if I zoom out yes
01:50:13 <hyiltiz> On phone the footer now is centered on screen
01:50:19 <[exa]> tomsmeding: like, the priority is 0 :]
01:50:32 <tomsmeding> hyiltiz: :D
01:52:22 <tomsmeding> [exa]: the margin-bottom on body should've been padding-bottom
01:52:40 <[exa]> really?
01:53:11 <tomsmeding> [exa]: https://paste.tomsmeding.com better now?
01:53:21 <[exa]> (I copied this from a site that was literally named somehow like sticky-footed-done-right.org so I just trusted it :] )
01:53:31 <[exa]> lovely <3
01:53:38 <tomsmeding> oh crap monospace textarea
01:54:20 <[exa]> oh yeah it has font-family:inherit for some reason
01:55:04 <tomsmeding> ah purecss did that
01:55:29 <tomsmeding> oh well, fixed
01:58:52 <[exa]> ok last thing perhaps, consider adding width:100% !important; to the `form textarea` so that the textarea doesn't resize over/under the width of the wrapper
01:59:18 * [exa] silences the rest of user whining
01:59:24 <tomsmeding> user whining is good!
01:59:32 <tomsmeding> but I fail to see this one
01:59:35 <tomsmeding> what happens exactly?
01:59:53 <[exa]> can you grab the lower right corner of the text area and shrink/expand its width?
02:00:04 <[exa]> (I can)
02:00:15 <tomsmeding> ah yes
02:00:20 <[exa]> cool
02:00:22 <tomsmeding> lol
02:00:50 <tomsmeding> why the hell does !important fix that
02:13:20 <gentauro> why is this possible? `import Data.Char (ord,)` or `import Data.Char (,)`? Why does that code even parse/compile with GHC? Can anybody explain?
02:14:24 <[exa]> is `import Data.Char ()` weird too?
02:15:04 <gentauro> [exa]: nope, that's the syntas to import `instances` but not module values
02:15:19 <dminuoso> % import Data.Char (,)
02:15:20 <yahb> dminuoso: 
02:15:41 <gentauro> but a `dangling` comma? Why not 4 or 7?
02:15:49 <gentauro> or an emojii?
02:15:51 <gentauro> :|
02:16:01 <dminuoso> gentauro: The Haskell report knows why
02:16:21 <tomsmeding> I guess it's to consistently allow the dangling comma in all haskell comma-separated list-things
02:16:24 <dminuoso> impdecl →  import [qualified] modid [asmodid] [impspec]
02:16:28 <tomsmeding> > [1, 2, 3,]
02:16:30 <lambdabot>  <hint>:1:10: error: <hint>:1:10: error: parse error on input ‘]’
02:16:32 <tomsmeding> oh
02:16:34 <dminuoso> impspec → (import1, ..., importn [,] ) (n≥0)
02:16:36 <tomsmeding> :D
02:16:42 <gentauro> luckily with `stylish-haskell` `on-save` hook,  it removes the trailing commas
02:16:43 <dminuoso> So, a trailing comma is allowed it seems.
02:17:32 <dminuoso> And (,) is just an odd case of that trailing comma in an empty import list
02:18:14 <gentauro> dminuoso: :'(
02:18:21 <tomsmeding> [exa]: hyiltiz: how's this for a read page redesign https://paste.tomsmeding.com/Y8Yor4gB
02:18:28 <dminuoso> Curious though. If I read the grammar specification, it seems like an empty implspec is not valid syntax.
02:18:45 <dminuoso> (The text in the report mentions it though)
02:19:03 <tomsmeding> dminuoso: doesn't it say n≥0 ?
02:19:18 <dminuoso> Mmm, I guess yeah
02:21:10 <[exa]> tomsmeding: looks cool. finally (more user whining)-- "edit this in a new paste" button :]
02:21:19 <tomsmeding> but
02:21:24 <tomsmeding> that actually involves coding
02:21:49 * hackage print-info 0.1.0.0 - Can be used to coordinate the printing output.  https://hackage.haskell.org/package/print-info-0.1.0.0 (OleksandrZhabenko)
02:22:35 <[exa]> well worry not, everyone can copypaste
02:33:53 <tomsmeding> [exa]: will go on the todo list, let me first work a bit on my thesis today :p
02:34:19 * hackage print-info 0.1.1.0 - Can be used to coordinate the printing output.  https://hackage.haskell.org/package/print-info-0.1.1.0 (OleksandrZhabenko)
02:34:38 <[exa]> oh theses
02:37:57 <tomsmeding> https://paste.tomsmeding.com/robots.txt also online now
02:39:19 * dminuoso wonders what tomsmeding's thesis is about
02:39:29 <dminuoso> And what kind of thesis is this?
02:39:34 <tomsmeding> master's thesis
02:39:41 <tomsmeding> implementing reverse-mode automatic differentiation in Accelerate
02:39:56 <tomsmeding> with some absolutely lovely advisors
02:41:05 <tomsmeding> far from a working implementation still :)
02:44:18 <merijn> tomsmeding: Where? :)
02:44:20 <dminuoso> tomsmeding: Is that automatic differentiatoin of accelerate programs?
02:44:33 <dminuoso> (Or fragments, rather)
02:50:16 <tomsmeding> dminuoso: yep
02:50:26 <tomsmeding> merijn: https://tomsmeding.com
02:50:55 <tomsmeding> my advisor is the original author of Accelerate, so that's nice :)
02:51:22 <dminuoso> What's the use case for such tool?
02:51:32 <dminuoso> I dont meddle much with graphics, so it's not obvious to me :)
02:51:46 <tomsmeding> it isn't as much for graphics
02:51:59 <tomsmeding> the use case is either machine learning or a backend for probabilistic programming languages
02:52:32 <tomsmeding> I have a sort of second advisor who works on Stan, who has an interest in this work
02:52:42 <tomsmeding> where Stan is https://mc-stan.org/
02:54:20 <Athas> tomsmeding: what made you not go with Conal's approach?
02:55:44 <tomsmeding> I honestly expected it to be quite a bit of work to map the Accelerate language to something that would be amenable to be processed using Conal's approach, and I had this thought that the "obvious" simple approach might just work fine
02:55:44 <merijn> tomsmeding: No, I meant where as in, which uni :p
02:55:52 <tomsmeding> merijn: utrecht :)
02:56:49 <tomsmeding> Athas: now in the meantime, I understand the ideas of Conal's approach a bit better, and think that could've worked too
02:57:10 <tomsmeding> so, no good answer :p
02:57:19 <merijn> Well, that gives you like 3 months to prepare an NL-FP presentation ;) (Well...assuming we're still/again allowed to have people get together :p)
02:57:31 <tomsmeding> ._.
02:59:22 <typetetris> I would like to do integrations tests with haskell, where I for example set up a temporary database per test case / test case group where I can preserve the database in case of failure. Trying to do this with HSpec, but struggling to place the ressource allocation/deallocation (db creation, start, stop, destruction) at the correct level. Are there best practices for such kind of thing? Where could I read up about 
02:59:22 <typetetris> them?
03:00:41 <tomsmeding> merijn: when would it be? sites.google.com is blocking me for sending automated queries (?)
03:00:42 <srk> typetetris: https://hspec.github.io/writing-specs.html#using-hooks
03:03:42 <typetetris> srk: I did look at that, I remember now. One thing, I couldn't quite handle: In some test groups, I wanted multiple `it` to work against the same database without it being destroyed, recreated between `it`s. So I probably need two withDatabaseConnection* functions.
03:04:25 <srk> no idea how would you do 'preserve database in case of failure' part. sounds like some external tooling would be required to do the setup/teardown based on test result
03:05:07 <merijn> tomsmeding: Unknown yet :p
03:05:16 <merijn> tomsmeding: Generally it's the 1st or 2nd friday of January
03:05:54 <tomsmeding> that's around the same time I'm supposed to defend though :p
03:06:13 <merijn> tomsmeding: There's a (super quiet) nl-fp mailing list that gets announcements, I think it's run by Utrecht, so presumably your supervisor will know
03:06:17 <tomsmeding> if all goes through as planned
03:06:23 <tomsmeding> I'll ask, thanks!
03:06:27 <kuribas> I found an interesting pattern I didn't see elsewhere.  Instead of my helper functions all being polymorphic in effects, like "(MonadError err m, MonadIO m) => Int -> m ()", etc... I write using concrete functions: "Int -> ExceptT (IO ())"
03:06:29 <boxscape> % ()
03:06:35 <boxscape> did yahb break?
03:06:39 <typetetris> srk: Test failures in hspec are just exceptions thrown, If I recall correctly, so just preserve the database in case of exceptions. Something like `bracket openConnection closeConnection . flip handle  (\e -> ...)`.
03:06:49 <merijn> tomsmeding: Also, I'm 100% sure most of the faculty at Utrecht is aware of nl-fp, so :p
03:07:34 <srk> typetetris: looks like there's also beforeAll / afterAll 
03:07:44 <kuribas> Then I have for my App monad translation functions:  exceptToApp :: Monad m => (e -> m a) -> (m a -> AppM a) -> ExceptT e m a -> AppM a
03:08:01 <kuribas> Which work for different effects.
03:08:09 <typetetris> srk: Yeah, probably I should simply turn the tests, which need the database multiple times, into their own test suites .. sounds way easier now :)
03:08:39 <kuribas> So I can easily match different transformer stacks.
03:08:42 <boxscape> wasn't there a command to kill yahb and reboot it for when it breaks? I always forget what that is...
03:08:50 <kuribas> I might even put this in a library, if anyone is interested...
03:08:57 <boxscape> actually yahb timed out so never mind
03:11:05 <ski> kuribas : how about `exceptToApp :: Monad m => (a -> m b) -> (e -> m b) -> (m b -> AppM b) -> ExceptT e m a -> AppM b' ?
03:13:30 <kuribas> ski: the real type I have is: exceptToSQA :: (e -> SQAMonad a) -> (forall b. m b -> SQAMonad b) -> ExceptT e m a -> SQAMonad a
03:13:44 <kuribas> ski: the forall isn't strictly necessary, but makes the signature cleaner
03:13:52 <ski> mm, yes. i was thinking about the `forall' in there
03:14:35 <boxscape> @let class Test t where testing :: t f => p t -> f Char -> f Char
03:14:36 <ski> rank two can be used for information hiding
03:14:37 <lambdabot>  .L.hs:202:1: error:
03:14:37 <lambdabot>      Multiple declarations of ‘Test’
03:14:37 <lambdabot>      Declared at: .L.hs:196:1
03:14:40 <boxscape> whoops
03:14:44 <boxscape> @let class Test1 t where testing :: t f => p t -> f Char -> f Char
03:14:45 <lambdabot>  .L.hs:203:9: error:
03:14:45 <lambdabot>      Multiple declarations of ‘testing’
03:14:45 <lambdabot>      Declared at: .L.hs:197:9
03:14:49 <kuribas> ski: otherwise it would something like: (m (Either e b) -> SQAMonad (Either e b))
03:14:55 * ski nods
03:15:39 <boxscape> @let class Test1 t where testing1 :: t f => f Char -> f Char
03:15:40 <lambdabot>  .L.hs:203:9: error:
03:15:41 <lambdabot>      • Could not deduce: t0 f
03:15:41 <lambdabot>        from the context: (Test1 t, t f)
03:15:43 * ski would probably still consider separate success and failure continuations
03:15:47 <boxscape> dammit
03:15:56 <boxscape> my point is, I had no idea classes could operate on classes
03:16:27 <kuribas> ski: that's possible
03:16:29 <ski> boxscape : `ConstraintKinds'
03:16:58 <boxscape> hm yeah I guess it makes sense that that makes it work...
03:17:03 <ski> a class just becomes a type with return kind `Constraint'
03:17:08 <boxscape> I see
03:17:49 <boxscape> I wouldn't have been surprised if there was some rule that all parameters to a class must have return kind *
03:18:06 <merijn> boxscape: ConstraintKind abuse! \o/ https://gist.github.com/merijn/6130082
03:18:52 <boxscape> hm, interesting
03:20:05 <ski> boxscape : see e.g. <https://hackage.haskell.org/package/constraints-0.12/docs/Data-Constraint.html> and <https://hackage.haskell.org/package/constraints-0.12/docs/Data-Constraint-Forall.html> for some examples
03:20:14 <boxscape> okay
03:21:27 <ski> hm, sneaky, merijn
03:21:44 <remexre> hm, do race :: IO a -> IO b -> IO (Either a b) and timeout :: Int -> IO a -> IO (Maybe a) lose events?
03:22:14 <remexre> er, from async and base, respectively
03:22:25 <dminuoso> "events"?
03:22:38 <dminuoso> What is an event?
03:22:42 <remexre> "things" in a vague sense :P
03:22:46 <remexre> like, values read from a chan
03:22:46 <dminuoso> "things"?
03:22:52 <remexre> recv'd from a socket, etc
03:22:54 <dminuoso> Your question is too vague.
03:22:57 <dminuoso> What does "losing" mean?
03:23:12 <remexre> on both sides of the race, a (let's say) socket read completes at ~ the same time
03:23:24 <remexre> one of those values isn't returned
03:24:23 <ski> if both sides read from the same socket, then something read by one won't be read by the other, i'm pretty sure
03:24:31 <remexre> different sockets
03:24:39 <dminuoso> remexre: I still dont understand what you are asking about.
03:24:57 <remexre> so, race spawns 2 threads, right
03:25:07 <remexre> each thread tries to read from their own socket
03:25:27 <dminuoso> So far so good.
03:25:29 <remexre> both succeed at the same time
03:25:30 <merijn> remexre: The losing thread may/may not get interrupted and it's value is definitely ignored
03:26:07 <dminuoso> remexre: The important thing to understand, is that threads are killed off with async exceptions.
03:26:18 <merijn> remexre: You're just trying to poll multiple sockets?
03:26:20 <dminuoso> By the time the exception is delivered, the other thread might already be completed.
03:26:46 <merijn> remexre: You probably want to build something on top of: https://hackage.haskell.org/package/base-4.14.0.0/docs/Control-Concurrent.html#v:threadWaitReadSTM
03:26:57 <dminuoso> I dont think we've heard enough just yet.
03:27:09 <dminuoso> remexre: So both succeed at the same time. Now what?
03:27:15 <remexre> the real application is blocking on a few Chans and a socket
03:27:19 * hackage servant-conduit 0.15.1 - Servant Stream support for conduit.  https://hackage.haskell.org/package/servant-conduit-0.15.1 (MatthiasFischmann)
03:27:21 <remexre> uh, I'm processing events from each in a loop
03:27:58 <remexre> at any point I might have to pass off the socket to something else, where it would be really convenient if I didn't have anything read from the socket outside the kernel's buffer
03:28:08 <remexre> er, at any point == in response to an event from either
03:28:23 <remexre> so I don't really wanna feed both into a single chan, which was my initial thought
03:28:47 <merijn> remexre: If you wanna pick "the first value that arrives from two options" and don't wanna lose values, you need STM
03:29:42 <remexre> okay, I'll go with that; thanks
03:29:57 <merijn> There's a billion STM channels already
03:30:11 <merijn> If you need to also mix in sockets then use threadWaitReadSTM I mentioned above
03:33:19 * hackage print-info 0.1.2.0 - Can be used to coordinate the printing output.  https://hackage.haskell.org/package/print-info-0.1.2.0 (OleksandrZhabenko)
04:35:53 <kuribas> ski: it can be rewritten generically as exceptToM :: Monad n => (e -> n a) -> (forall b. m b -> n b) -> ExceptT e m a -> n a
04:35:53 <kuribas>  
04:46:10 <ski> kuribas : hm. could be done as `exceptToM :: Monad n => (e -> n a) -> ExceptT e n a -> n a', together with `hoist' or `mapExceptT'
04:47:46 * ski probably still prefer `Monad n => (a -> n b) -> (e -> n b) -> ExceptT e n a -> n b', though
04:49:01 <sim642> If I have ghc and cabal installed via the Ubuntu PPA, how am I supposed to install a package system-wide?
04:51:32 <kuribas> ski: how would you extract the inner monad?
04:52:07 <merijn> sim642: What do you expect a "system-wide" package to do?
04:52:26 <merijn> sim642: i.e. what's the goal?
04:52:30 <kuribas> ski: ah wait, but you only have a single monad.
04:52:38 <kuribas> ski: my goal is to translate from a different monad stack
04:53:03 <sim642> merijn, I expect it to be importable with the system-wide ghc that the PPA installs
04:53:47 <ski> oh, there's a <https://hackage.haskell.org/package/errors-2.3.0/docs/Control-Error-Util.html#v:exceptT>
04:54:30 <ski> kuribas : yea, not saying it would be more convenient to use the rank-1 version. just noting that it could be done
04:54:48 <merijn> sim642: That's not specific enough. What does "importable" mean? You mean when using GHC directly? Do you mean when using GHC via cabal-install? Or..
04:55:24 <ski>   hoist :: (MFunctor f,Monad m) => (forall a. m a -> n a) -> (forall a. t m a -> t n a)
04:56:22 <ski>   mapExceptT :: (MFunctor f,Monad m) => (m (Either e0 a) -> n (Either e1 a)) -> (ExceptT e0 m a -> ExceptT e1 n a)
04:56:44 <merijn> sim642: GHC looks for packages in 'a' package database, but afaik there's no real restriction to having just one. With v2-build there's a global store which has a database with "everything" in it, and then cabal-install selectively makes things visible to GHC as needed
04:56:52 <sim642> merijn, "importable" meaning if I use /opt/ghc/bin/ghc to compile a .hs file, the module would be found. I'm trying to straight up use the ubuntu PPA
04:57:09 <merijn> sim642: *can* you do that? Sure.
04:57:20 <merijn> sim642: Is there any documentation and help on doing so? No.
04:58:19 <merijn> Because there has been a continuous movement *away* from that sort of mode of operation for over a decade now, because it's kinda unworkable for the common usecases
04:59:22 <merijn> You could probably hack it together manually using v1-install, but it'll be a massive pain
05:00:49 * hackage template-haskell-compat-v0208 0.1.5 - A backwards compatibility layer for Template Haskell newer than 2.8  https://hackage.haskell.org/package/template-haskell-compat-v0208-0.1.5 (NikitaVolkov)
05:01:51 <sim642> merijn, I'm confused why it's such a pain though. This machine has some older ghc through haskell platform I think and there packages have been installed via cabal globally just fine
05:02:38 <sim642> Like where does "cabal install --global --lib HUnit" install things? It says "Up to date" but "ghc-pkg list" doesn't have it
05:03:29 <merijn> sim642: Which version of cabal-install?
05:04:21 <sim642> 3.2.0.0 from the PPA
05:04:37 <merijn> then you want to use v1-install to get the old behaviour
05:04:57 <merijn> 3.0 and later default to the v2-build commands, including install.
05:05:29 <remexre> merijn: wait, there's no STM race though? (wrt pick the first value that arrives)
05:05:45 <merijn> remexre: There is, it's called "Alternative" :p
05:05:49 <merijn> :t (<|>)
05:05:51 <lambdabot> Alternative f => f a -> f a -> f a
05:06:36 <remexre> does that block until it can read? that's not the behavior of IO's (<|>), is it?
05:06:45 <merijn> remexre: <|> for STM tries the left-most version, if that throws an exception or retries (due to blocking) it will try the right hand side, if that one fails too it will retry the entire thing
05:07:18 <remexre> does the runtime do something smart to make that not-busy-waiting?
05:07:30 <merijn> yes
05:07:38 <remexre> hm, okay
05:07:41 <remexre> will try that then
05:07:50 <merijn> remexre: I can highly recommend the STM paper linked in the Control.Concurrent.STM docs
05:08:50 <remexre> okay, I've read it once upon a time, but definitely don't remember it now lol
05:08:55 <merijn> remexre: Basically, the only "changable data" in a transaction comes from TVars. So when a transaction runs it marks all TVar's it read
05:09:06 <merijn> remexre: If it fails it won't retry until at least 1 of those has changed
05:09:07 <remexre> does it detail how the runtime is avoiding the busy-waiting?
05:09:13 <remexre> ah
05:09:22 <merijn> remexre: (since purity guarantees that unchanged TVars will just produce the same failure)
05:09:37 <remexre> okay, so the runtime has an epoll() or select() or whatever that writes the "reading is now possible" to a TVar, then?
05:10:03 <merijn> remexre: Stuff like threadWaitReadSTM ties into the runtimes underlying loop to fire the STM notification
05:10:30 <merijn> remexre: I'm not sure of the exact details, but sorta like that, yes
05:11:14 <remexre> okay sweet
05:11:17 <remexre> thx
05:11:59 <merijn> remexre: (one implementation would be to have "blocked" transactions removed from the run queue and listed with each TVar, then if the TVar changes adding them back to the run queue or something)
05:12:16 <merijn> But I don't know if that's what's done or something else
05:12:18 * hackage hspec-core 2.7.4 - A Testing Framework for Haskell  https://hackage.haskell.org/package/hspec-core-2.7.4 (SimonHengel)
05:13:18 * hackage hspec 2.7.4, hspec-discover 2.7.4 (SimonHengel): https://qbin.io/herbal-shapes-f1nu
05:13:59 <sim642> merijn, wow thanks, that seems to have done what I needed. Although where was the newer install command supposedly installing things then?
05:14:38 <merijn> sim642: That puts everything into the global store, but you need to manually select packages from that store to use at compile time via package-env and package flags.
05:14:57 <merijn> sim642: Or rather, the idea is to let cabal do that for you, because that's tedious as shit
05:15:03 <urea> cabal install --lib sets up a package environment file in ~/.ghc that ghc loads at startup
05:15:36 <urea> v2-install
05:15:48 * hackage print-info 0.1.3.0 - Can be used to coordinate the printing output.  https://hackage.haskell.org/package/print-info-0.1.3.0 (OleksandrZhabenko)
05:16:36 <merijn> sim642: The advantage of the global store is that you can have multiple conflicting versions (or even the same version with different dependencies/configs) installed simultaneously, where is v1-install restricts you to one version
05:16:51 <merijn> sim642: Which is annoying when you work on projects with conflicting constraints
05:18:17 <sim642> Right, another home dir based thing that wouldn't have worked in my weird use case
05:18:48 <sim642> I totally get the need for package version management on a more fine-grained level, just didn't think it'd take me this long to get a package installed totally globally
05:22:17 <urea> you can also pass in the file manually to ghc with -package-env <file>, it just loads the one called "default" (without quotes) from $HOME/.ghc/arch-os-version/environments/  automatically
05:27:19 * hackage servant-docs 0.11.6 - generate API docs for your servant webservice  https://hackage.haskell.org/package/servant-docs-0.11.6 (MatthiasFischmann)
05:28:19 * hackage servant-pipes 0.15.2, servant-machines 0.15.1, servant-foreign 0.15.2 (MatthiasFischmann)
05:29:22 <merijn> sim642: It's not necessarily homedir based
05:29:41 <merijn> sim642: You can put it whereever if you edit ~/.cabal/config
05:30:24 <merijn> sim642: Like I said "globally installing packages" is widely considered a terrible idea and therefore, pretty much a non-goal
05:59:58 <cohn> how do you destructure an input list in do-notation using a "<-" operator?
06:04:33 <hc> what do you mean by "destructure"?
06:05:12 <cohn> hc: so if I have a list like [x,y] and I want to get the x and y out
06:05:20 <cohn> similar to a tuple
06:05:53 <cohn> hmm. maybe it'd make more sense to pass a list with tuples in it
06:06:36 <hc> cohn: you can write a:b:[] = [x,y] if you are sure the list has two elements
06:06:41 <hc> otherwise, a:b:cx = [x,y,...]
06:07:02 <hc> but yeah, might be better to change your datastructure
06:07:08 <cohn> hc: that's exactly what I was looking for. thanks!
06:07:21 <dminuoso> cohn: [... | [x,y] <- ... ]
06:08:03 <dminuoso> If the list is not exactly 2 long, the element will be skipped (because a pattern match there invokes fail, which for [] produces an empty list)
06:08:28 <cohn> dminuoso: gotcha. I never knew about that
06:09:27 <cohn> thanks!
06:18:38 <ezzieyguywuf> https://dpaste.com/F3SWYHRA2 can anyone help me figure out the problem here? here's the full code - https://dpaste.com/C6HB3ZA93
06:19:38 <dminuoso> ezzieyguywuf: What is TopoState?
06:19:59 <dminuoso> You cant declare an instance with a type synonym.
06:20:13 <ezzieyguywuf> dminuoso: `type TopoState a = State Topology a`
06:20:20 <ezzieyguywuf> ah
06:20:43 <dminuoso> And the first diagnostic is likely just because GHC was able to keep on going. :p
06:20:51 <ezzieyguywuf> no I either need to newtype my TopoState or something else.
06:20:56 <dminuoso> You should.
06:20:57 <ezzieyguywuf> dminuoso: I figured that.
06:21:07 <ezzieyguywuf> dminuoso: 👍 thanks for the help.
06:21:16 <dminuoso> ezzieyguywuf: To be fair, the GHC diagnostic was quite explicit and verbose...
06:21:33 <dminuoso> (All instance types must be of the form (T t1 ...  tn) where T is not a synonym.
06:22:14 <ezzieyguywuf> dminuoso: yes, it was explicit and verbose, I just couldn't /quite/ decipher it. Specifically the (T t1 ...tn) part
06:22:18 <ezzieyguywuf> but now I get it
06:29:30 <ski> @undo [f x y z | [x,y] <- xys,z <- g x y]  -- cohn
06:29:30 <lambdabot> concatMap (\ a -> case a of { [x, y] -> concatMap (\ z -> [f x y z]) (g x y); _ -> []}) xys
06:30:08 <ski> @undo do [x,y] <- xys; z <- g x y; f x y z
06:30:08 <lambdabot> xys >>= \ a -> case a of { [x, y] -> g x y >>= \ z -> f x y z; _ -> fail ""}
06:31:28 <dminuoso> Oh, undo works for list-comprehensions
06:31:33 <dminuoso> Neat, didn't know that. :)
06:34:23 <ezzieyguywuf> hrm, still can't get it. Here's the updated code https://dpaste.com/7EHU5MEUR and the latest error https://dpaste.com/5NVHFNA4N
06:36:58 <dminuoso> ezzieyguywuf: Consider your instance.
06:37:40 <hololeap> i just saw AccumT for the first time, and it seems like it is basically WriterT but with the ability to inspect the current state of the monoid. is this pretty accurate?
06:38:02 <dminuoso> ezzieyguywuf: You likely have to do a standalone instance
06:38:08 <dminuoso> With an appropriate constraint
06:38:20 <dminuoso> Ah no
06:38:25 <dminuoso> TopoState needs a Show instance. But GHC is telling you this.
06:38:32 <ezzieyguywuf> dminuoso: I tried something like `deriving instance Show a => Show (State Topology a)` but got i different error
06:38:38 <ezzieyguywuf> or actually the same error I think...
06:39:00 <dminuoso> Is TopoState a newtype as well?
06:39:00 <ezzieyguywuf> dminuoso: but topostate is a type synonym, so I can't give it a Show instance
06:39:02 <dminuoso> Or a type alias?
06:39:10 <ezzieyguywuf> yea it's a type alias
06:39:24 <dminuoso> Right, so this is where the fun stops
06:39:29 <ezzieyguywuf> lol, huh?
06:39:36 <dminuoso> State is a function beneath
06:39:42 <dminuoso> How are you going to Show that? :)
06:40:01 <dminuoso> You need to either write your own Show instance by hand, or not at all.
06:41:31 <ezzieyguywuf> `instance Show (State Topology (Vertex, Edge, NES.NESet Edge)`?
06:41:47 <dminuoso> No.
06:41:58 <ezzieyguywuf> actually I think that hspec has an allowance somewhere for things without a Show instance
06:42:01 <ezzieyguywuf> maybe that's the path...
06:42:05 <dminuoso> I mean yeah, you could do that, but really the question is whether you should have a Show instance for TestMakeWireState at all
06:42:27 <ezzieyguywuf> dminuoso: I could make an argument that it _does_ need a Show instance.
06:42:48 * hackage vector-fftw 0.1.4.0 - A binding to the fftw library for one-dimensional vectors.  https://hackage.haskell.org/package/vector-fftw-0.1.4.0 (BenGamari)
06:42:51 <ezzieyguywuf> but to-date, I've yet to really see the benefit of Show in hspec since I use it in conjunction with QuickCheck
06:42:59 <ezzieyguywuf> (or maybe that's wrong...)
06:43:24 <dminuoso> ezzieyguywuf: well shouldBe needs to display what values violate your proposition
06:43:46 <ezzieyguywuf> right...
06:43:54 <ezzieyguywuf> yea, that's right.
06:44:37 <ezzieyguywuf> maybe I just need to refactor this whole TestMakeWireState deal altogether (which itself is a refactor)
06:45:06 <dminuoso> ezzieyguywuf: So what I'd do, is make an orphan show instance
06:45:10 <dminuoso> Just to please hunit
06:45:35 <dminuoso> Just make sure this orphan lives somewhere in the local test package
06:45:45 <ezzieyguywuf> dminuoso: what is an "orphan" instance?
06:46:09 <dminuoso> Mmm, actually this is already a newtype local to the test package
06:46:12 <dminuoso> Ignore the orphan bit.
06:46:16 <merijn> ezzieyguywuf: an instance that's in a module other than the datatype or class
06:46:17 <dminuoso> Write out a manual Show instance. :)
06:46:47 <ezzieyguywuf> ah, yea I'm using the newtypes with the "Test" prefix to avoid "orphan instance" errors :-P
06:46:59 <dminuoso> Im not quite sure whether you want to really this at all
06:47:02 <dminuoso> because if you want shouldBe
06:47:08 <dminuoso> you will have the next problem which is Eq.
06:47:24 <ezzieyguywuf> hrm
06:47:38 <dminuoso> So lets start at the beginning. Why do you want this TestMakeWireState at all?
06:47:43 <ezzieyguywuf> yea, like I said, perhaps I need to rethink my approach.
06:47:47 <ezzieyguywuf> dminuoso: I'll show you, jsut a sec
06:48:07 <dminuoso> Also note, writing orphan instances in tests is a common practice. Just make sure the instances are written in the *test* package.
06:48:19 * hackage tabular 0.2.2.8 - Two-dimensional data tables with rendering functions  https://hackage.haskell.org/package/tabular-0.2.2.8 (BenGamari)
06:49:36 <ezzieyguywuf> dminuoso: good to know - in my first pass, I was writing instances in the actual module itself, but eventually realized that was dumb.
06:51:29 <ezzieyguywuf> So, here is why I want TestMakeWireState: https://dpaste.com/3YRZMLMUF notice the function `prop_CreateOpenWire`. It takes two random positive Integers, and (1) Create's a chain of Vertex→Edge pairs, and (2) picks a random pair to execute the test upon. I want to now write `prop_createClosedWire`, which is almost exactly the same code, except after line 121, I would close the loop by calling 
06:51:35 <ezzieyguywuf> `addEdge` one time. 
06:51:45 <ezzieyguywuf> the intent of TestMakeWireState was to avoid the majority of the code duplication between these two functions
06:52:44 <ezzieyguywuf> thus, you'll here the Arbitrary instance of TestMakeWireState that includes the bulk of what's in prop_CreateOpenWire right now. https://dpaste.com/7HA7EZVCV
07:13:19 * hackage uniqueness-periods-vector-general 0.2.0.0 - Generalization of the functionality of the dobutokO-poetry-general-languages package  https://hackage.haskell.org/package/uniqueness-periods-vector-general-0.2.0.0 (OleksandrZhabenko)
07:20:23 <ezzieyguywuf> I guess an easier way is to just keep the call signature the same for both prop_CreateOpenWire and prop_CreateClosedWire and pass along the random n1 and n2 to something like `prepMakeWire :: Int -> Int -> (Vertex, Edge, NES.NESet Edge)`
07:27:23 <codehaskell> Hi eveyone, actually I was facing issue while  
07:27:26 <codehaskell> Back Lists: Lists where elements are added to the back ("snoc" == rev "cons")
07:27:37 <codehaskell>  For example, the list [1,2,3] is represented as Snoc (Snoc (Snoc Nil 1) 2) 3
07:28:18 * hackage ghc-lib-parser 0.20200901 - The GHC API, decoupled from GHC versions  https://hackage.haskell.org/package/ghc-lib-parser-0.20200901 (shayne_fletcher)
07:29:18 * hackage ghc-lib 0.20200901 - The GHC API, decoupled from GHC versions  https://hackage.haskell.org/package/ghc-lib-0.20200901 (shayne_fletcher)
07:29:56 <merijn> codehaskell: That's just a regular list with the arguments reverse, though ;)
07:29:59 <dminuoso> codehaskell: That are just lists.
07:31:03 <codehaskell> Now I want to add a number to it in the beginning with using cons ? How will I define it?
07:31:42 <merijn> codehaskell: What exactly is the goal? You wanna append at the end, but do you wanna recurse from the "fron"?
07:32:10 <merijn> Because then your definition won't work (I mean, I guess it would, but every recursion would start with traversing the entire thing
07:32:16 <codehaskell> A backward list data structure -- Back Lists: Lists where elements are added to the back ("snoc" == rev "cons")-- For example, the list [1,2,3] is represented as Snoc (Snoc (Snoc Nil 1) 2) 3data BList a = Nil | Snoc (BList a) a deriving Show-- Add an element to the beginning of a BList, like (:) doescons :: a -> BList a -> BList acons = undefined
07:32:39 <codehaskell> This is the question
07:33:17 <codehaskell> wait i post it in a proper way...!! It got merged
07:33:32 <codehaskell>  A backward list data structure
07:33:39 <dminuoso> codehaskell: a backward list is a list.
07:33:40 <codehaskell> Back Lists: Lists where elements are added to the back ("snoc" == rev "cons")
07:33:51 <codehaskell> For example, the list [1,2,3] is represented as Snoc (Snoc (Snoc Nil 1) 2) 3
07:33:59 <codehaskell> data BList a = Nil | Snoc (BList a) a deriving Show
07:34:00 <dminuoso> codehaskell: consider this:
07:34:06 <dminuoso> 1:2:3:[]
07:34:08 <dminuoso> Is 1 the first element?
07:34:10 <dminuoso> Or the last?
07:34:13 <dminuoso> Depends on how you interpret the list.
07:34:30 <cohn> wouldn't that only matter if the list was infinite?
07:34:30 <dminuoso> "first" and "last" are just our human interpretations of this
07:34:43 <codehaskell> ok
07:34:48 <dminuoso> 16:33:38     codehaskell | data BList a = Nil | Snoc (BList a) a deriving Show
07:35:04 <dminuoso> This *is* just data [a] = [] | a:[a] 
07:35:13 <merijn> I suspect the answer here is "consult your teacher/lab assistant and ask what exactly they want"
07:35:14 <dminuoso> You just renamed the data constructors :)
07:35:29 <codehaskell> can you explain this senario to me dminuoso.
07:36:59 <codehaskell> OK I will clear it with my teacher and will exactly know what is needed?
07:40:19 * hackage cryptol 2.9.1 - Cryptol: The Language of Cryptography  https://hackage.haskell.org/package/cryptol-2.9.1 (AaronTomb)
07:41:04 <tomsmeding> "The" language of cryptography
07:41:32 <[exa]> :]
07:43:17 <raehik> Hi all, I want to convert a Text to a ByteString with a different (non-Unicode) encoding. text-icu pkg is looking like the one, but it appears that I need to mix in IO to get a Converter :(
07:44:04 <raehik> is that the state of the Haskell ICU lib? figured it should be a pure function, I'm assuming it outsources to some C
07:44:35 <maerwald> raehik: did you try https://hackage.haskell.org/package/encoding
07:44:49 * hackage HsOpenSSL 0.11.4.19 - Partial OpenSSL binding for Haskell  https://hackage.haskell.org/package/HsOpenSSL-0.11.4.19 (VladimirShabanov)
07:45:47 <maerwald> but text-icu is solid
07:46:22 <raehik> maerwald: oooohh! that looks great, I couldn't find that on Hoogle
07:46:51 <maerwald> I'd use text-icu over anything else any day, because it's bindings, that are battle-tested and I know it's performant
07:47:09 <maerwald> 'encoding' takes very long to compile
07:48:37 <raehik> roger that, I can use IO I was kinda curious why it was the case
07:50:26 <raehik> thanks for that lib, need to think about my data because text-icu doesn't seem to handle char-based errors the same way 
08:01:49 * hackage json5hs 0.1.3.1 - Serialising to and from JSON5  https://hackage.haskell.org/package/json5hs-0.1.3.1 (sakamitz)
08:37:19 * hackage ghc-lib-parser-ex 0.20200901 - Algorithms on GHC parse trees  https://hackage.haskell.org/package/ghc-lib-parser-ex-0.20200901 (shayne_fletcher)
08:39:50 <glguy> When did we start getting Typeable for free?
08:39:58 <c_wraith> 7.10, maybe?
08:44:17 * glguy confirms things are good on travis-ci
08:44:45 <glguy> I've got about one library that I actively try to keep working back as far as I can so I get out of practice on some old version changes
08:45:17 <asheshambasta> Is there a way to make cabal put build artefacts in a directory other than dist-newstyle? I'm using a cabal.project and I'm writing a shell script using inotify to restart ghcid depending on changes in subdirs; but it seems like multiple ghcid instances running (and restarting at the same time) results in conflicts in dist-newstyle (I get errors like package.conf.inplace already exists) etc
08:45:46 <asheshambasta> In this case, I'd manage to easily solve this if I can give cabal a new path per ghcid instance.
08:46:00 <asheshambasta> (cabal --help and man cabal do not help)
08:46:44 <monochrom> perhaps --build-dir is it
08:46:48 <monochrom> err, --builddir
08:47:20 <monochrom> I looked at "cabal configure --help"
08:48:22 <monochrom> I haven't tried. But looks like the only possibility left.
08:49:11 <merijn> Yes, but you can't control builddir via cabal.project
08:50:08 <asheshambasta> okay; it seems like it is --builddir indeed. 
09:04:29 <cpressey> Hello. Using <|> from Control.Applicative I wrote the following function: "f `orElse` g = \x -> (f x) <|> (g x)".
09:04:38 <cpressey> But it strikes me that I wouldn't need to define `orElse` if I could just make "Alternative f => (a -> f b)" an instance of "Alternative".
09:05:11 <cpressey> But can I do that?
09:07:28 <cpressey> I've tried "instance Alternative f => Alternative (a -> f b) where ..." but I'm clearly confused about what's needed here ("Expected kind ‘* -> *’, but ‘a -> f b’ has kind ‘*’")
09:08:12 <dolio> No, you can't.
09:08:30 <cpressey> I suspected I might not.
09:11:58 <triteraflops> this article: http://fun.cs.tufts.edu/stream-fusion.pdf dates to 2007
09:12:08 <triteraflops> surely it would have been mainlined by now
09:18:48 <triteraflops> MarcelineVQ: ^^
09:22:37 <triteraflops> MarcelineVQ: https://gitlab.haskell.org/ghc/ghc/-/issues/915#note_63943
09:33:58 <fog> i think there should be a typeclass for modifiable functions
09:35:12 <fog> i can have an implementation with (s,s -> a -> (s,a))
09:35:57 <fog> or (s,s -> a -> (o,s))
09:36:18 <davean> What is a "modifiable function"? 
09:36:23 <davean> I think you missunderstand something
09:36:37 <fog> thats like a modifiable function from `a' to `o' that returns the new modifiable function `s'
09:36:49 <davean> only it isn't
09:36:55 <davean> it basicly a state monadic action
09:37:01 <davean> but in no way is *it* modifiable
09:37:15 <fog> oh, well, it returns a new state
09:37:19 <davean> yes
09:37:22 <davean> It is MonadState
09:37:25 <davean> but it is not modifiable
09:37:41 <fog> and if thought of as the whole thing giving (a -> o) depending on s, and returning a new updated s
09:37:59 <davean> Yep, thats a State Monad
09:38:06 <fog> if you changed the `s' you would be "modifying" the function on (a -> o)
09:38:27 <fog> just by changing the input s, over which this function is parametric
09:39:11 <davean> I mean you've basicly discovered currying? Only you're trying to make it a state monad (and succeding)
09:39:43 <fog> i guess you have to wrap the output `s' with the function aswell.. and that stays constant, only the `s' being modified
09:39:58 <fog> davean: i have others too
09:40:07 <fog> state encoding is just an instance
09:40:52 <fog> then i have something like a state encoding with the modifiable function instead of the state action function being paired with the state itself
09:42:02 <fog> then i make state-like things, with any modifiable function, such as a regular state encoding - as the implementation of modifiable functions
09:43:11 <ski> fog : `data SSP a o = Step (a -> (o,SSP a o))'
09:43:20 <triteraflops> so, build g = g (:) []
09:43:33 <fog> um, not paired with the state itself, its a trivial function which *applies* the modifiable function, the function gets pushed inside the state
09:43:36 <ski> ("Synchronous State Processor")
09:44:24 <ski> `exists s. (s,s -> a -> (o,s))' is iso to `nu s. a -> (o,s)', which is what that `SSP a o' expresses
09:44:44 <triteraflops> this means that the function g would generate a list. So, maybe in instances where you might use build, the object you really want isn't a list, it's the function g itself.
09:45:52 <monochrom> I have trouble with "g would generate a list". Is that a typo? Is that really what you think? Because it's wrong. "build g" generates a list.
09:46:10 <monochrom> Or rather, "g (;) []" generates a list, if anything.
09:46:17 <triteraflops> build plays a very minimal role in the list generator
09:46:22 <triteraflops> *generation
09:46:26 <fog> think about it, if instead of having the state function paired with the state, you just have the state as the state function and the state, and the state function for this is trivial application of that inner state function
09:46:41 <fog> now i can generalise that to any modifiable function
09:46:42 <monochrom> g itself, it's more like an instantiation of foldr
09:48:05 <ski> fog : something like `a -> ST s o', then ? or perhaps even `a -> State s o' ?
09:48:59 <monochrom> Suppose I can a list in mind, it's [1,2,3].
09:49:05 <fog> (s::s,f::s -> a -> (o,s)) becomes (\(s,f) -> a -> fmap (\s' -> (s',f))$ f s a)
09:49:35 <fog> , something...
09:49:39 <monochrom> But I won't give you the list itself. I give an indirect roundabout representation, in hope that it enables optimizatins when you actually use it.
09:49:57 <monochrom> I give you g = \cons nil -> cons 1 (cons 2 (cons 3 nil))
09:50:02 <fog> ski: how?
09:50:24 <triteraflops> monochrom: that's already interesting to me to look at
09:50:26 <monochrom> If you really want the concrete list form, you can always evaluate "g (:) []". But normally you won't.
09:50:47 <ski> the list is ephemeral
09:51:21 <monochrom> Normally you want to sum up my list. So you go "g (+) 0" instead.  Now you have saved creating heap data that only live for a second and become garbage immediately. We have cut out the middleman.
09:51:40 <triteraflops> yes, that's really cool
09:51:56 <triteraflops> but that suggests to me that we should (almost) always do that
09:52:16 <triteraflops> so what lists /wouldn't/ we want to represent in generator form?
09:52:17 <monochrom> Yes, Data.List tries very hard to do that as much as possible.
09:52:17 <ski> fog : if you want something like a "modifiable function" (modifying it, when running it), then it seems some kind of state monad could be what you want. or the stream processor thing i suggested (which is an arrow), which enables local state
09:52:38 <monochrom> When you want to sort a list. :)
09:52:58 <monochrom> Compute permutations, powersets, ...
09:53:02 <ski> triteraflops : when they're more long-lived, and especially if there's more than one consumer
09:53:35 <triteraflops> so g does work in computing the values of elements
09:53:35 <ski> (iow, persistent, vs. ephemeral)
09:53:42 <ski> yes
09:53:47 <triteraflops> and you don't want to run g twice
09:53:53 <fog> (s::s , f::s -> a -> (o,s)) becomes; let g (s,f) a =fmap (\s' -> (s',f)) (f s a) in (g,(s,f)) 
09:53:59 <ski> yea, normally you want to avoid that, triteraflops
09:54:08 <monochrom> The definition "build g = g (:) []" seldom makes it into compiled code. Rather, there are rewrite rules that eliminate it.
09:54:20 <fog> ski: i want an abstraction over that
09:54:39 <fog> a state encoding is just one instance of a modifiable function
09:54:44 <monochrom> But it's there in case the code says that a concrete list is demanded, now you really have to build it.
09:54:59 <triteraflops> monochrom: I figured it would make it into compiled code all the time, however often sorting etc happens to a concat.
09:55:06 <ski> fog : your `(s,f)' is an OO-style object, of type `exists s. (s,s -> a -> (o,s))'. see what i said about that, above
09:55:08 <monochrom> or s/the code says that/the optimizer fails to eliminate build/
09:55:24 <fog> and i get the more general one by saying, just as i can put the state function in the state of a state encoding, i can put a modifiable function there in a modifiable function, and then trivially run it
09:55:37 <monochrom> Sorting re-orders items. foldr and build etc don't.
09:55:42 <fog> so i can make modifiable functions by nesting, like how i can make nested state encoding above
09:55:55 <ski> fog : do you have any other example of what you intend by "a modifiable function" ?
09:56:11 <monochrom> A consequence of re-ordering is what ski said. Now part of the list is longer-lived.
09:56:15 <triteraflops> what if you're doing ten different foldrs to the same build g?
09:56:29 <triteraflops> might you not save work by rendering the build g?
09:56:55 <fog> fog : `data SSP a o = Step (a -> (o,SSP a o))'
09:56:58 <fog> yeah that looks ok
09:56:59 <triteraflops> and can ghc figure that one out
09:57:13 <fog> ski: yes, i have a cycle of scanners
09:57:31 <ski> fog : make sure you understand how to convert between `SSP a o' and `exists s. (s,s -> a -> (o,s))'
09:57:34 <monochrom> I don't know for sure, but looks like the concrete list is built in most of those cases.
09:57:58 <fog> https://pastebin.com/raw/1VMR5g3e
09:59:10 <triteraflops> but then if you merge the ten foldrs into a single foldr, which you could do, it would use fusion and it would use less memory than building the list
09:59:26 <fog> the cycle has as many internal memory states as it has scanners beeing run in a loop
10:00:05 <fog> and for each of these memory states i want modifiable functions, that also do the scanning action of each stage
10:00:57 <fog> so then i can use any modificable function, and having these two, i can have a nesting of cycles with leafs as state encodings, as both of these act as modificable functions
10:01:39 <triteraflops> In the case or sorting, or other out-of-order operations, I would want to use an array for that instead
10:02:20 <fog> the cycle acts as a modifiable function because it acts on an input and has updated memory on doing so
10:02:26 <monochrom> If you have a mutable array, that's best for sorting.
10:02:37 <monochrom> Failing that, immutable array is worse than immutable list.
10:02:38 <ski> <http://squing.blogspot.com/2008/11/beautiful-folding.html>,<https://hackage.haskell.org/package/folds>
10:02:38 <fog> the memory usints can themselves be cyces, or other modifiable functions, like state encodings
10:02:50 <fog> and this should be the same for all modifiable functions
10:03:03 <fog> i can use them as their own modifiable memory
10:03:10 <fog> thats whats good about them being modifiable
10:03:19 <geekosaur> but arrays have their own issues in Haskell (gc is more expensive, for one)
10:03:22 <triteraflops> does haskell know when to treat immutable arrays as mutable, or is linear haskell required for that?
10:04:06 <monochrom> No and no.
10:04:13 <fog> ie, i can use them as a state because they can be updated
10:04:55 <triteraflops> without invoking the IO monad?
10:05:02 <fog> so, because modifiable functions make good states, and can do the state action, i can build states with them
10:05:30 <fog> and other more complicated modifiable functions built similarly to how state can be used for deeper nestings
10:05:37 <triteraflops> What's the current haskell interface for mutable arrays?
10:05:53 <monochrom> Linear Haskell is not going to enable any optimization any time soon. For now it is a safety feature only.
10:06:01 <fog> modifiable functions as the states in state encodings 
10:06:05 <fog> there, clear
10:06:11 <geekosaur> IOArray or STArray
10:06:21 <geekosaur> (or unboxed versions thereof)
10:06:29 <monochrom> vector package's Data.Vector.*.Mutable.  So inside IO or ST.
10:06:35 <triteraflops> and presumably, IOArray is in the IO monad
10:06:54 <triteraflops> and ST is some other monad I guess
10:07:16 <geekosaur> I think Data Parallel Haskell was supposed to support that kind of thing (mutation under the covers when safe), but it as only partially implemented and unmaintained, so was removed some ghc versions ago
10:07:43 <geekosaur> ST's kinda a safe where you can do mutation without it leaking outside
10:08:09 <fog> so i just need a class function that returns from `s' the function `a -> (o,s)'
10:08:20 <fog> is that what your encoding was ski?
10:08:54 <ski> fog : try formulating that paste using `SSP'
10:08:57 <triteraflops> so you could eventually freeze an STArray into an Array when you'd done fiddling with it?
10:09:15 <monochrom> Yes, that's one outcome.
10:09:47 <monochrom> Another outcome is I need the mutable array only temporarily.
10:10:18 <monochrom> "use sieving to find a prime between 1e10 and 1e10 + 1000"
10:10:35 <ski> fog : i don't follow what you're suggesting
10:11:45 <ski> triteraflops : yes. there's `runST :: (forall s. ST s a) -> a', so you can hide your update-in-place mutation, behind a non-monadic interface
10:12:37 <fog> ski: that instead of SSP i just need that to be there as an instance, and that is of the class ModifiableFunction
10:12:39 <ski> (e.g., to sort a list, you could copy its elements over to a mutable array, sort it in-place, then read off the elements to a list again, which is your output)
10:13:18 <fog> i think the state encoding and the SSP then both instantiate this, as does the cycles themselves
10:13:46 <ski> i dunno why you think you want a class, fog. i don't think you gave any other example of what you meant by "modifiable function", apart from ones of type `exists s. (s,s -> a -> (o,s))'
10:13:56 <fog> i did! the cycles
10:14:07 <fog> thats how they end up nested
10:14:31 <fog> they need state like memory units at each scanner in the cycle
10:14:59 <fog> so they are modifiable and the modified version is returned when it is input over to output something
10:15:20 <ski>   cycle2 :: (a -> s0 -> (b,s0),s0) -> (b -> s1 -> (a,s1),s1) -> a -> [(a,b)]
10:15:32 <fog> it just uses the state at the front of the cycle, and outputs it new state to the back of the cycle
10:15:39 <ski>   cycle2 :: (forall s. (a -> s -> (b,s),s)) -> (forall s. (b -> s -> (a,s),s)) -> a -> [(a,b)]
10:15:42 <ski> define
10:16:12 <fog> right, that version just flips it backwards
10:16:12 <ski>   type SSP' a b = exists s. (a -> s -> (b,s),s)
10:16:20 <ski> er, sorry, i meant
10:16:24 <Guest_63> Hello, I am having touble running the ghci command in terminal after successfully downloading:  curl --proto '=https' --tlsv1.2 -sSf https://get-ghcup.haskell.org | sh
10:16:30 <ski>   cycle2 :: (exists s. (a -> s -> (b,s),s)) -> (exists s. (b -> s -> (a,s),s)) -> a -> [(a,b)]
10:16:33 <ski> so
10:16:36 <fog> the cyclic version has to have b ~ a 
10:16:44 <ski>   cycle2 :: SSP' a b -> SSP' b a -> a -> [(a,b)]
10:17:21 <ski> so, this is just `exists s. (a -> s -> (b,s),s)' again, it's not a different instance of "modifiable function"
10:19:45 <ski> (also note that `[exists s. (a -> s -> (b,s),s)]' is more general than `exists s. [(a -> s -> (b,s),s)]' .. the latter (in your paste) insists on the same state type `s' for all the "scanners" in your list. the former allows each one to have a different `s')
10:20:32 <ski> (and yes, `cycle :: SSP' a a -> a -> [a]')
10:20:41 <fog> at the moment the `a' is uniform in type, as it is carried between the scanners that take and output it
10:20:59 <ski> yes
10:21:11 <ski> i still see no other instance of "modifiable function"
10:21:13 <fog> linking together hetrogenous `N' would be type crazy
10:21:23 <ezzieyguywuf> is there something like conduit in python?
10:21:31 <ski> just put the `exists' inside the list type
10:22:03 <ski>   cycleN :: [(a -> s -> (a,s),s)] -> a -> [a]
10:22:04 <ski> is
10:22:13 <ski>   cycleN :: (exists s. [(a -> s -> (a,s),s)]) -> a -> [a]
10:22:14 <ski> but
10:22:23 <ski>   cycleN :: [exists s. (a -> s -> (a,s),s)] -> a -> [a]
10:22:25 <ski> is more general
10:22:56 <ski> each "scanner" has its own `s' type, can be different from the other ones
10:22:58 <fog> i dont see how the s can be different in the list
10:23:30 <fog> i need to zip it with type annotations surely 
10:24:29 <fog> oh right your SSP doesnt have an S at all...
10:24:39 <fog> s/S/s
10:25:11 <ski>   [(\ss b -> (show b:ss,not b),False),(\ss n -> (show n:ss,succ n),0)] :: [exists s. ([String] -> s -> ([String],s),s)]
10:25:14 <ski> we have
10:25:29 <fog> hmm, so the datatype wrapper hides type of the internal state with some continuations magic 
10:25:40 <ski>   (\ss b -> (show b:ss,not b),False) :: ([String] -> Bool -> ([String],Bool),Bool)
10:25:43 <ski> therefore
10:25:55 <ski>   (\ss b -> (show b:ss,not b),False) :: exists s. ([String] -> s -> ([String],s),s)
10:25:58 <ski> we also have
10:26:19 <ski>   (\ss n -> (show n:ss,succ n),0) :: ([String] -> Integer -> ([String],Integer),Integer)
10:26:22 <ski> therefore
10:26:33 <ski>   (\ss n -> (show n:ss,succ n),0) :: exists s. ([String] -> s -> ([String],s),s)
10:26:52 <ski> so, both scanners have the same type, `exists s. ([String] -> s -> ([String],s),s)', so we can put then in a list, together
10:26:59 <ski>   [(\ss b -> (show b:ss,not b),False),(\ss n -> (show n:ss,succ n),0)] :: [exists s. ([String] -> s -> ([String],s),s)]
10:27:03 <fog> i dont see how your getting this type hetroginaity  so cheaply by using a continuation
10:27:14 <ski> nothing to do with continuations
10:27:19 <ski> this is just existentials
10:27:24 <fog> SSP hid the `s'
10:27:55 <ski> (also, to actually do this in Haskell, you need to encode the existential, in some way. since `exists' isn't even an extension, at least not in GHC ..)
10:28:27 <fog> when i had a class function, i would still need to retrive the applyable function (a -> (o,s)) from eg (s,s -> a -> (o,s))
10:28:46 <ski> `SSP a b' used the "state encoding", of a coinductive datatype, in reverse
10:28:51 <fog> ie, i would act on the `s' . not hide it...
10:29:03 <ski> (iow, translated back from state encoding, to coinductive)
10:29:41 <ski> fog : is there any reason or point to that ?
10:30:23 <fog> yes, because by that class its a modifiable function
10:30:38 <fog> your saying instead i can just package them into these things that hide the s
10:30:59 <ski> "oh right your SSP doesnt have an s at all..." -- `SSP a b' itself could be seen as corresponding to the `s'
10:31:03 <fog> ie anything that makes an SSP is a modifiable function when its wrapped in SSP
10:31:26 <fog> by hiding the `s' you also hide this class
10:31:45 <ski> if you had something like `(a -> s -> (b,s),s) -> ..s..', then you could have a point. but i didn't really see you using `s' anywhere else (like in the return type)
10:31:46 <fog> instead of making instances of modifiable functions, you let the user make values of SSP
10:32:01 <ski> one exception to this is
10:32:04 <ski>   scanning :: (Scanning s a o,a) -> (o,Scanning s a o)
10:32:06 <ski> which is
10:32:13 <ski>   scanning :: forall s. ((Scanning s a o,a) -> (o,Scanning s a o))
10:32:25 <ski> but from this we can get the (admittably weaker)
10:32:29 <fog> ssp (Step f,a) = f a
10:32:40 <ski>   scanning :: (exists s. Scanning s a o,a) -> (o,exists s. Scanning s a o)
10:32:41 <fog> ssp :: (SSP a o,a) -> (o,SSP a o)
10:33:27 <ski> yes
10:33:44 <ski> `SSP a o' hides the `s', inside
10:34:12 <fog> so why not accept that you should use HList for the hetrogenous state cycle, name the `s' specifically, and then you get the modifiable function class
10:34:38 <fog> it seems naturally dual to this SSP thing
10:34:48 <ski> i thought the point was that the state should be local to its scanner, not being meddled by, by someone else
10:35:14 <ski> by using `exists s.', you enforce that it's not meddled by someone else
10:35:20 <fog> that of a modifiable function only modifiable on producing its output
10:35:36 <fog> ok sure
10:35:47 <fog> but my instance of modifiable function just had eval
10:35:54 <geekosaur> just as a general rule, if you can avoid HList, do so. it's painful.
10:35:58 <fog> no abstract function for modifying the `s' on its own
10:36:01 <ski> dunno what you mean by "eval", here
10:36:11 * ski nods to geekosaur
10:36:28 <fog> geekosaur: i need the type level shape. it might just be a cycle of N, but soon its suposed to become a graph
10:36:50 <fog> ski: to use the internal function
10:37:03 <ski> do you mean like `ssp' just above ?
10:37:56 <fog> for the state encoding, which is suposed to be an instance; eval (f,s) a = let (o,st) = f s a in (o,(f,st))
10:38:51 <ski>   eval :: (exists s. (s -> a -> (o,s),s) -> a -> (o,exists s. (s -> a -> (o,s),s))
10:38:54 <ski> yes ?
10:39:16 <ski>   eval :: SSP' a o -> a -> (o,SSP' a o)
10:39:55 <fog> no, its a class function, its taking (f,s) as the "state encoding" (s -> a -> (o,s),s)
10:40:07 <fog> ie its an instance over that
10:40:11 <ski> compare with `f :: s -> a -> (o,s)', in `(f,s) :: SSP' a o'
10:40:40 <ski> "state encoding" ought to have an `exists s.'
10:40:51 <fog> instance ModifiableFunction (s -> a -> (o,s),s) where eval (f,s) a = let (o,st) = f s a in (o,(f,st))
10:41:11 <ski> what's the type of this `eval' ?
10:41:13 <triteraflops> SPJ's presentation on linear haskell strongly suggested it was already being used to jam safe mutation into pure code
10:41:20 <triteraflops> for reasons of efficiency
10:41:30 <fog> if (s -> a -> (o,s),s) cant be called a "state encoding" because it doesnt have an exists, then what should i call it?
10:42:37 <fog> class ModifiableFunction x a o where eval :: x -> a -> (o,x)
10:42:48 <triteraflops> but I can see the FAQ of the site that led me to the presentation says otherwise
10:43:26 <ski> @type cata
10:43:28 <lambdabot> Functor f => (f a -> a) -> Mu f -> a
10:43:31 <ski> @type flip cata
10:43:32 <lambdabot> Functor f => Mu f -> (f c -> c) -> c
10:43:52 <ski>   flip cata :: Functor f => Mu f -> (forall r. (f r -> r) -> r)
10:44:16 <ski> `forall r. (f r -> r) -> r' is "Church encoding" of `Mu f', aka `mu r. f r'
10:45:38 <ski> e.g. Church encoding of `[a]', being `mu r. Maybe (a,r)' is `forall r. (Maybe (a,r) -> r) -> r', iow `forall r. r -> ((a,r) -> r) -> r', iow `forall r. r -> (a -> r -> r) -> r'
10:45:46 <ski> @type foldr
10:45:47 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
10:46:21 <ski> % :t foldr @[]
10:46:21 <yahb> ski: (a -> b -> b) -> b -> [a] -> b
10:46:22 <ski> % :t flip (flip . foldr @[])
10:46:23 <yahb> ski: [a] -> (a -> c -> c) -> c -> c
10:46:50 <ski> similarly, we have
10:47:12 <ski>   ana :: Functor f => (s -> f s) -> s -> Nu f
10:47:31 <ski>   uncurry (flip ana) :: Functor f => (s,s -> f s) -> Nu f
10:47:40 <ski>   uncurry (flip ana) :: Functor f => (exists s. (s,s -> f s)) -> Nu f
10:48:00 <ski> where `exists s. (s,s -> f s)' is "State encoding" of `Nu f', aka `nu s. f s'
10:48:14 <L29Ah> how do i find a memory leak of pinned memory?
10:48:27 <L29Ah> https://gitlab.haskell.org/ghc/ghc/-/issues/7275 suggests that life sucks, but are there other options?
10:48:33 <fog> but whats wrong with just (s,s -> a -> (o,s)) ?
10:48:42 <dolio> Look for bytestring use.
10:49:00 <L29Ah> dolio: sure i have lots of bytestring use, and i want to figure which one is leaky
10:49:05 <ski> fog : it exposes the internal state, so that it's not equivalent to what it's supposed to be an encoding of
10:49:16 <ski> perhaps that's what you want
10:49:29 <ski> but it's not "State encoding" of `nu s. ..s..', then
10:51:07 <ski> fog : anyway, why should there be a special, singled out, value of type `x -> a -> (o,x)', for particular triples of `x',`a',`o' ?
10:51:16 <dolio> I'm not aware of any way to narrow it down.
10:51:58 <fog> because then x is a modifiable function over a and o
10:52:14 <fog> this can be used as the state function
10:52:17 <ski> should `x' determine `a' and `o', then, using FDs ?
10:52:20 <fog> in the not state encoding
10:52:48 <ski> also, i still want to see two different instances of `ModifiableFunction'
10:52:50 <fog> can a modifiable function be polymorphic? yes
10:53:02 <fog> no fundeps
10:53:19 <ski> mhm
10:53:22 <fog> not uniquely specifying the input and output types, eg i could make a pair or a list from the inputs
10:53:49 <dolio> L29Ah: Maybe there are specific things you could look for depending on what you do. For instance, if you're taking small substrings of a larger bytestring, I think you'll retain a reference to the entire original byte array.
10:54:08 <fog> anying that can go in your SSP is an instance
10:54:11 <dolio> So if you're reading in something big and chopping small pieces of it out, that's something to look for.
10:54:14 <fog> and SSP is an instance itself
10:54:18 <L29Ah> yes i understand that but i don't think that's the case
10:54:22 <fog> so thats more than one instance
10:54:30 <L29Ah> most likely my problem is bytestring lingering far longer than they should
10:54:34 <ski> fog : anyway, perhaps you could join #haskell-overflow, if you want to discuss this further ?
11:04:49 * hackage servant-swagger 1.1.10 - Generate a Swagger/OpenAPI/OAS 2.0 specification for your servant API.  https://hackage.haskell.org/package/servant-swagger-1.1.10 (MatthiasFischmann)
11:07:25 <L29Ah> i've triple-checked the place where the bytestrings are spawned and i don't see any reason for them to linger though; https://github.com/l29ah/hyborg/blob/master/Main.hs#L100
11:08:49 <L29Ah> i feed 5GB of data to this thing and it consumes 6GB of ram at the end of its job
11:09:44 <galrond> why does haskell need an enum type?
11:10:26 <fog> Enum is a constraint
11:11:22 <L29Ah> galrond: it doesn't
11:11:49 <jumper149> :t (Enum a)
11:11:50 <lambdabot> error:
11:11:50 <lambdabot>     • Data constructor not in scope: Enum :: Expr -> t
11:11:50 <lambdabot>     • Perhaps you meant variable ‘enum’ (imported from Control.Lens)
11:12:08 <galrond> yes that is true
11:12:09 <L29Ah> :i Enum
11:12:20 <galrond> but someone made Data.Generic.Enum
11:13:25 <jumper149> :k (Enum a)
11:13:26 <glguy> galrond: What is your question about the module?
11:13:27 <lambdabot> error: Not in scope: type variable ‘a’
11:13:34 <jumper149> :k Enum
11:13:36 <lambdabot> * -> Constraint
11:14:21 <galrond> I'm just trying to figure out why this would be wanted
11:14:28 <davean> read the package description
11:14:34 <davean> Its pretty clear in saying two things.
11:15:17 <davean> galrond: Perhaps part of your problem is thinking Enum is a type.
11:15:35 <monochrom> L29Ah: Suppose I have xs=[1..n], n large enough so that xs, if allowed to live fully, takes 1GB.  If I even do simply "print (length xs, sum xs)", that make xs live fully, and take 1GB.  I say this because I see an analogous thing, "chunkUncompressedSizes = map (fromIntegral . B.length) strictChunks" and "chunkIDs = map (coerce . encryption.hashID) strictChunks", that worries me.
11:15:42 <galrond> yes that is what I currently think
11:15:54 <davean> galrond: well Enum is not a type in 'base' or in that module./
11:16:21 <L29Ah> monochrom: but they only live inside that mapM function, so they shouldn't linger for longer than one iteration
11:16:44 <monochrom> How big is strictChunks?
11:16:46 <davean> galrond: I'd try to help more but I can't figure out why you'd think Enum was a type to try to detangle it.
11:20:32 <monochrom> I guess not very big.
11:21:58 <galrond> davean: thanks for trying, I think I got my answer from wikipedia
11:22:14 <davean> galrond: you're clear on it not being a type now?
11:23:13 <galrond> yeah
11:23:46 <davean> Great
11:25:58 <monochrom> L29Ah: My next hypothesis is that chunkUncompressedSizes or chunkIDs are kept unevaluated for a very long time, so they hold on to their bytestring sources.
11:28:02 <sshine> question on prettyprinter library: the hackage docs suggest a module name of 'Prettyprinter.Render.Text', but for some reason I have to 'import Data.Text.Prettyprint.Doc.Render.Text'. why is that? https://hackage.haskell.org/package/prettyprinter-1.7.0/docs/Prettyprinter-Render-Text.html
11:30:02 <monochrom> Simply version mismatch?
11:30:08 <tomsmeding> sshine: "I have to" -- what forces you to?
11:30:32 <monochrom> The joy of docs on the Internet.
11:31:06 <tomsmeding> ah perhaps version mismatch, see the docs for the module you're importing: https://hackage.haskell.org/package/prettyprinter-1.7.0/docs/Data-Text-Prettyprint-Doc-Render-Text.html
11:31:46 <tomsmeding> in fact, 1.7.0 is the first (and currently) last version that has the new module tree with Prettyprinter.Render.Text
11:32:32 <monochrom> We need a catchy name for this phenomenon.  Version phishing.
11:35:28 <L29Ah> monochrom: 208MB
11:35:49 <L29Ah> 21:25:37]<monochrom> L29Ah: My next hypothesis is that chunkUncompressedSizes or chunkIDs are kept unevaluated for a very long time, so they hold on to their bytestring sources.
11:35:50 <L29Ah> that's impossible as they're needed at `cachedPut`
11:36:18 <L29Ah> that shoves them at a fd
11:36:42 <sshine> monochrom, I believe I'm running 1.7.0 and am reading 1.7.0 docs... :)
11:37:30 <sshine> monochrom, tomsmeding: thanks. I was using 1.6.2 ;)
11:37:55 <sshine> apparently 1.6.2 is latest in lts-16.11.
11:42:58 <tomsmeding> luckily there is now lts-16.12!
11:43:56 <tomsmeding> oh even in lts-16.12 it's still 1.6.2 :p
11:44:00 <sshine> yup.
11:50:16 <davean> tomsmeding: I mean, I don't know the LTS system well but doesn't that have to be the case by what the LTS system is?
11:50:36 <tomsmeding> why would it?
11:51:16 <davean> tomsmeding: because upgrading the module would break its interface, thus making code for that LTS not run with it?
11:51:38 <tomsmeding> sure, but I'm talking about a new LTS version -- if you don't want breakages, you shouldn't change lts version :)
11:51:47 <tomsmeding> if you stay on lts-16.11, you only get compatible upgrades
11:52:21 <tomsmeding> if you change to lts-16.12, anything can happen
11:52:23 <monochrom> It comes down to what semantics and expectations are behind an LTS version bump from 16.11 to 16.12.
11:52:46 <monochrom> especially as opposed to 16.* to 17.*
11:53:06 <tomsmeding> oh right, I indeed sprouted nonsense
11:53:14 <glguy> How many years was the support on an lts?
11:53:20 <maerwald> wait... if you're on 16.11 you get updates??
11:53:23 <tomsmeding> minor lts version upgrades should be compatible c.f. https://github.com/commercialhaskell/lts-haskell#readme
11:53:34 * geekosaur expects "api same, abi different" because it's ghc underneath
11:53:42 <tomsmeding> but then, 1.7.0 should be compatible with 1.6.2; marking modules deprecated doesn't remove them
11:53:45 <monochrom> Nah. If you migrate from 16.11 to 16.12, you get updates.
11:54:25 <monochrom> No, if prettyprinter is following PVP, 1.6.* -> 1.7.* means some things are deleted.
11:54:38 <monochrom> or some type sigs are changed. etc.
11:54:43 <davean> tomsmeding: And indeed if you flip back and forth, many things are
11:55:14 <monochrom> 1.6.n -> 1.6.(n+1) is the one that says "additon only, backward compatible if users are conservative about imports"
11:55:18 <tomsmeding> monochrom is more knowledgeable as usual https://hackage.haskell.org/package/prettyprinter-1.7.0/changelog
11:56:48 <davean> "Fix build with GHC 7.4." Holy shit, 7.4?!
11:57:00 <maerwald> that's some dedication
11:57:09 <monochrom> hehe
11:57:11 <davean> I thought 8.4 was no longer relivent
11:57:12 <maerwald> OCD is hard to treat :)
11:57:24 <monochrom> Yeah when will ghcup support GHC 7.4?!!
11:57:38 <geekosaur> you missed a recent discussion about what ghc versions are still in use in various places
11:57:44 <maerwald> oh
11:57:53 <geekosaur> on one of the mailing lists
11:58:02 <maerwald> monochrom: 7.10 already barfs out on most platform, even if you manago to install it
11:58:04 <geekosaur> some people indeed are sticking to even 7.1 iirc
11:58:07 <monochrom> Could someone also port ghcup to Apple II ProDOS please?  (OK, I'll stop.)
11:58:24 <maerwald> I think it was due to -fPIC something
11:58:36 <maerwald> so without cabal config change, it doesn't work
11:58:44 <geekosaur> there are insructions floating around for what to do to the settings file to fix that
11:58:49 <maerwald> I imagine 7.4 must be worse
11:59:17 <monochrom> -fPIC would not cause an issue on Apple II
11:59:28 <geekosaur> code size would :p
11:59:43 <monochrom> Use Hugs and use Apple II, and everything will be fine.
12:00:04 <davean> I think ajhc can build for that little RAM
12:00:06 <maerwald> geekosaur: what were the reasons? Do old GHCs produce faster code?
12:00:09 <monochrom> (OK I'll really stop. Sorry!)
12:00:27 <davean> monochrom: IME they build much slower code
12:00:51 <L29Ah> ghc-7.10 is the last one that works for winxp afair
12:01:12 <geekosaur> IIRC some newer extensions were incompatible with existing code
12:01:31 <monochrom> By -fPIC you probably had -fpie in mind. Many linux distros changed to "randomly relocate your exe to help with security, so your exe had better be compiled for that".
12:01:42 <geekosaur> like (I don't recall if this was one of them or even can be) TypeApplications steals some syntax
12:02:03 <L29Ah> TypeApplications is opt-in
12:02:10 <geekosaur> only partially so
12:02:43 <geekosaur> ghc likes to implement such extensions as "parse them and then barf on use" wich screws anyone using the syntax the old way
12:03:02 <davean> I've gone through and pushed patches for hundreds of packages on hackage for more than one major GHC update. Updating to new GHCs is not a problem.
12:03:24 <geekosaur> mostly because it's really painful to switch betwen (say) @ as infix vs. prefix in the parser
12:03:44 <maerwald> if the codebase is that big AND they don't have the resources to update to a new GHC... I feel something is off
12:03:57 <davean> a few were mildly annoying because they used extensions that had changed I never had even heard of
12:04:08 <davean> even those didn't make the entire process take more then 2 weeks of spare time.
12:04:41 * geekosaur was reminded the other day that ghc still supports -XPatternSignatures but barfs if you use it, also
12:04:58 <maerwald> you mean still parses?
12:05:00 <geekosaur> it's not always as sane as one could wish about language changes
12:05:31 <geekosaur> if it sees you eable the extension, it outputs an error abut how it's not supported any more
12:05:49 <geekosaur> (the syntax still parses, because it's part of ScopedTypeVariables these days)
12:07:21 <geekosaur> also keep in mind that chage goes back to 6.0 (!)
12:07:33 <geekosaur> who knows why it never got removed
12:07:44 <davean> no one had a reason to?
12:07:56 <monochrom> Haha neat. "data T = A Int Int" is different from "data T = Int `A` Int" in deriving Show. deriving Generic also differ in whether A is prefix or infix.
12:08:34 <geekosaur> iirc the Report specifies that for Show
12:09:32 <monochrom> nice
12:10:39 <monochrom> aww this imposes restrictions on Read too.
12:10:49 <geekosaur> yes it does
12:10:58 <monochrom> Not that I have a stake.
12:12:17 <davean> monochrom: Most of us lack stakes, thats how these undead extensions persist
12:12:47 <monochrom> Oh I'm just referring to deriving Read wanting you to write infix vs prefix.
12:13:31 <monochrom> Actually if you say: you know, you just want to relate the two issues...
12:13:39 <geekosaur> there's nothing stopping there being an extension, possibly even enabed by default, that accepts either form — except perhaps overhead in read
12:13:48 <monochrom> I would really much prefer all of you to have no stake in answering fog.
12:14:01 <monochrom> Because then I have much more legitimacy in banning.
12:14:59 <monochrom> Nah, too many extensions already.
12:14:59 <davean> I do feel they're spouting nonsense and not answering challenges.
12:15:11 <monochrom> Also, very unhealthy to encourage people to use Read.
12:17:10 <geekosaur> sadly, if it's there then people will use it. or challenge that there should be a way to derive <their favorite parser> for arbitrary types
12:18:17 * glguy tries to figure out what's being discussed about Read exactly
12:18:54 <dolio> `data T = Int `A` Int` derives Read so that "5 `A` 5" works but "A 5 5" doesn't.
12:19:06 <monochrom> glguy: "data T = A Int Int" vs "data T = Int `A` Int", what does deriving (Show, Read) give you.
12:19:21 <glguy> Isn't the important thing just that it matches Show?
12:19:29 <monochrom> Yes
12:19:36 <glguy> and works as Haskell source
12:19:42 <monochrom> Yes
12:20:02 <geekosaur> and both match the data declaration, so you can't e.g. declare it in infix form and then read it in prefix form
12:48:00 <dminuoso> The report is quite explicit about this in fact
12:48:12 <dminuoso> "If the constructor is defined to be an infix operator, then the derived Read instance will parse only infix applications of the constructor (not the prefix form)"
13:02:49 * hackage uniqueness-periods-vector-properties 0.1.0.0 - Metrics for the maximum element for the uniqueness-periods-vector packages family.  https://hackage.haskell.org/package/uniqueness-periods-vector-properties-0.1.0.0 (OleksandrZhabenko)
13:12:12 <gentauro> % :i (data T = Int `A` Int)
13:12:13 <yahb> gentauro: ; <interactive>:1:2: error: parse error on input `data'
13:12:38 <gentauro> dolio: what is `A`?
13:12:44 <gentauro> I have never seen that before :o
13:13:45 <glguy> Identifiers can become operators when surrounded by `
13:14:02 <glguy> > 10 ` div ` 5
13:14:05 <lambdabot>  2
13:14:48 * hackage compact-sequences 0.2.0.0 - Stacks, queues, and deques with compact representations.  https://hackage.haskell.org/package/compact-sequences-0.2.0.0 (dfeuer)
13:25:47 <dmwit> % data T = Int `A` Int
13:25:47 <yahb> dmwit: 
13:25:49 <dmwit> % :i A
13:25:49 <yahb> dmwit: type T :: *; data T = Int `A` Int; -- Defined at <interactive>:189:10; type A :: *; newtype A = Ghci65.A Int; -- Defined at <interactive>:153:1
13:32:11 <dminuoso> % data List a = Nil | a `Cons` List a deriving Show; infixr 9 `Cons`
13:32:11 <yahb> dminuoso: 
13:32:22 <dminuoso> % 1 `Cons` 2 `Cons` Nil -- gentauro 
13:32:22 <yahb> dminuoso: 1 `Cons` (2 `Cons` Nil)
13:32:49 * hackage uniqueness-periods-vector-properties 0.1.1.0 - Metrics for the maximum element for the uniqueness-periods-vector packages family.  https://hackage.haskell.org/package/uniqueness-periods-vector-properties-0.1.1.0 (OleksandrZhabenko)
13:44:39 <gentauro> dminuoso: that's is smart
13:44:43 * gentauro to some extend
13:47:57 * gentauro but interesting to ensure that constructors are used a binary operators
13:48:12 <gentauro> `data Op = Word `Add` Word` hmmm
13:48:19 * hackage uniqueness-periods-vector-properties 0.1.1.1 - Metrics for the maximum element for the uniqueness-periods-vector packages family.  https://hackage.haskell.org/package/uniqueness-periods-vector-properties-0.1.1.1 (OleksandrZhabenko)
13:48:31 <dminuoso> gentauro: You can also use operators as constructors, as long as they start with a colon.
13:48:41 <dminuoso> % data Op = Word8 :+: Word8
13:48:41 <yahb> dminuoso: 
13:48:51 <phadej> mnemonic, :
13:49:03 <phadej> as in `x : xs`
13:49:34 <dminuoso> This holds true for type constructors too, by the way.
13:49:55 <dminuoso> % data l :*: r = l :*: r
13:49:55 <yahb> dminuoso: 
13:50:16 <dminuoso> Equivalently, you can define a named type constructor in infix position
13:50:34 <dminuoso> % data l `MyEither` r = L l | R r
13:50:34 <yahb> dminuoso: 
13:51:13 <glguy> operator-symbols used at the type-level don't have the : requirement, however
13:51:33 <gentauro> `data Op = Word8 := Word8` <- wasn't there a lot of trouble wiht that operator in the Python Community? 
13:51:36 <gentauro> xD
13:51:43 <glguy> % data T = (:-)
13:51:43 <yahb> glguy: 
13:52:30 <glguy> % data l ** r = C
13:52:30 <yahb> glguy: 
13:53:08 <dminuoso> Presumably the : just allows differentiating data constructors in things like patterns?
13:53:28 <glguy> : differentiates constructors from variables
13:53:33 <glguy> at the value level
13:54:00 <dminuoso> I guess that's what I meant yeah
13:54:16 <phadej> someone wanted to be able to write 1 + 1  on type level, instead of Plus 1 1 or 1 :+ 1
13:54:18 <gentauro> glguy: how can you define a type with lowercase?
13:54:25 <gentauro> shouldn't it be capital?
13:54:30 <phadej> so now we cannot have operator named variables on type levels :(
13:54:30 <gentauro> or is it just for constructors?
13:54:41 <dminuoso> phadej: Wasnt that possible a long time ago?
13:54:46 <dminuoso> I recall ski complaining about this from time to time
13:54:53 <phadej> dminuoso: somewhere in 7 series
13:54:54 <dminuoso> For things like profunctors this would be golden
13:54:56 <glguy> gentauro: in: (Int, a, Bool) -- a is a type and is lowercase
13:55:09 <dminuoso> phadej: 7 series?
13:55:21 <dminuoso> Oh you mean GHC 7.*?
13:55:24 <phadej> yes
13:55:25 <gentauro> glguy: I'm refering to this -> `data l ** r = C`
13:55:36 <glguy> gentauro: That's defining the (**) type
13:55:56 <glguy> % :t C
13:55:56 <yahb> glguy: l ** r
13:56:03 <gentauro> glguy: I copy/pasta, my `ghci` says: "Computer says no"
13:56:12 <dminuoso> Mmm. Maybe Tagged is actually a good case where an operator type might make more sense.
13:56:26 <glguy> gentauro: No, it says a longer message
13:56:31 <dminuoso> Say `1 :> Int` rather than `Tagged 1 Int`
13:56:44 <gentauro> «Illegal declaration of a type or class operator ‘**’. Use TypeOperators to declare operators in type and declarations»
13:56:49 <glguy> gentauro: Yup, read that
13:57:24 <phadej> the l ** r thing doesn't work in GHC-7.0 for example
13:57:44 <gentauro> phadej: «GHCi, version 8.6.5: http://www.haskell.org/ghc/  :? for help»
13:57:45 <phadej> GHC-7.6.3
13:57:52 <gentauro> do I need to turn on any PRAGMAS?
13:57:58 <phadej> there the TypeOperators was changed
13:58:05 <dminuoso> phadej: Ohh. I see the connection. ** back then would implicitly be understood as quantified variables
13:58:07 <phadej> or rather 7.6 probably
13:58:08 <glguy> gentauro: You have to use TypeOperators
13:58:22 <glguy> gentauro: :set -XTypeOperators
13:58:34 <phadej> https://downloads.haskell.org/~ghc/7.6.1/docs/html/users_guide/release-7-6-1.html
13:58:36 <dminuoso> so the choice to disallow type operators as type variable serves as the basis for TypeOperators?
13:58:41 <phadej> The behavior of the TypeOperator extension has changed: previously, only type operators starting with ":" were considered type constructors, and other operators were treated as type variables. Now type operators are always constructors.
13:58:49 <phadej> I think that was bad choice :(
13:59:01 <glguy> I'd prefer it was consistent with the value namespace, too
13:59:02 <gentauro> glguy: https://typeclasses.com/ghc/type-operators
13:59:14 <dminuoso> What was the motivation behind that?
13:59:21 <phadej> dminuoso: 1 + 1
13:59:26 <phadej> kind of stuff
13:59:27 <glguy> gentauro: Yeah, that looks like a good starting point
13:59:49 <gentauro> but does anybody actually write code like this?
13:59:56 <dminuoso> phadej: Couldn't one just writ 1 :+ 1 instead? 
14:00:06 <gentauro> or is it old-school `perl` people that want to obfuscate while they are coding?
14:00:09 <phadej> dminuoso: I haven't been around in 7.6 times :)
14:00:11 <glguy> phadej: If we didn't pretend that type aliases and type families introduced new type *constructors* it wouldn't have been an issue
14:00:15 <dminuoso> Fair enough
14:00:46 <glguy> then the type family + could have stayed as + without newtype and data introduced things losing the : prefix
14:01:25 <phadej> glguy: true, they are not really type-constructors nor "neutral variables"
14:03:18 * hackage accelerate-kullback-liebler 0.1.2.1 - Kullback-Liebler divergence  https://hackage.haskell.org/package/accelerate-kullback-liebler-0.1.2.1 (vmchale)
14:08:53 <cohn> dminuoso: ok, so little light bulb just went off for do-notation
14:09:06 <cohn> so if I have a function with signature: testFunc :: [Int] -> [Int] -> [Int]
14:10:08 <phadej> glguy: UnsaturatedTypeFamilies would make that story nicer
14:10:12 <cohn> I can then use something like: testFunc vals1 vals2 = do; v1 <- vals1; v2 <- vals2. v1 and v2 are treated as single values from the input lists
14:10:24 <cohn> hooray!
14:11:12 <cohn> I can make it even more powerful by supporting all Monads in the signature:  testFunc :: Monad m => m Double -> m Double -> m Double
14:16:30 <dminuoso> cohn: Indeed. :)
14:18:00 <cohn> :)
14:26:19 * hackage recursion 2.2.4.2 - A recursion schemes library for Haskell.  https://hackage.haskell.org/package/recursion-2.2.4.2 (vmchale)
14:38:43 <kolibri_user> wow KolibriOS even has an IRC client in it ...
14:40:20 <hyiltiz> that was me trying out kolibri
15:01:39 <Guest20902> For GHC, what's the memory use of sum types like? If I have `data OneOrTwo a = One a | Two a a`, is a `One` value 1 word for the tag and 2 for the pointers (in `Two`), or 1 word for the tag and 1 for the pointer?
15:08:47 <Guest20902> Or should I ask on #GHC?
15:09:09 <dminuoso> Guest20902: This is the right place.
15:09:22 <dminuoso> #ghc is just focused around development of ghc itself.
15:09:45 <monochrom> The case "One x" takes 2 words: 1 word for One, 1 word for pointer to x.
15:09:55 <monochrom> The case "Two x y" takes 3 words, likewise.
15:10:54 <monochrom> Memory is not uniformly allocated for "the biggest case so it can fit every case". Memory is allocated for one specific case, no more no less.
15:10:56 <Guest20902> @monochrom Thanks! I was thinking that it might be implemented as a tagged union. Good to know that the extra space isn't used.
15:10:57 <lambdabot> Unknown command, try @list
15:12:01 <monochrom> This is a treasure trove for these things: https://github.com/takenobu-hs/haskell-ghc-illustrated
15:13:18 <Guest20902> Oh wow, can't believe I've gotten by this long without knowing about that.
16:16:49 * hackage lingo 0.5.0.0 - File extension based programming language detection  https://hackage.haskell.org/package/lingo-0.5.0.0 (rewinfrey)
16:20:15 <cohn> wow, Comic Sans all over the place
16:26:53 <davean> Comic Sans *is* the official Haskell type face
16:38:40 <Aliexpguy> HI, check Aliexpress for great deals, coupons,  50%-90 off.. https://a.aliexpress.com/_mt36w6T get 20USD 
16:39:09 --- mode: ChanServ set +o monochrom
16:39:24 --- mode: monochrom set -o monochrom
16:39:35 <hyiltiz> The only place on could forgive comic sans is in a highly technical setting to "lighten up" the mood in all the holes that surround it.
16:40:52 <hyiltiz> Well another case of that since almost no serious person uses it seriously for serious matters, if you are the only one in the field using Comic Sans in your field it acts as a watermark for your contents.
16:41:19 <hyiltiz> s/holes/jokes/
16:41:53 <hyiltiz> s/case of/case is/
16:42:13 <monochrom> Maybe I should use kidnapper-style randomized cut and paste "iNtErsTiNg". That would be a watermark alright.
16:45:57 <hpc> monochrom: you also have to carefully plan the length of your identifiers so the capitalization stays alternating even when you use data constructors
16:47:16 <monochrom> aww, k-lining is always faster than me
16:47:37 <fog> ski: i did that thing; https://gist.github.com/fog-hs/4520617016e5345a0400e417bd6f23e0
16:48:55 <fog> now the scanners can hetrogenous types using SSP 
17:02:13 <fog> i have updated the gist - it now shows a hetrogenous list of scanners being turned into a list of SSP
17:05:02 <fog> the next stage would be to extend them from having uniform type `a' being passed around the loop of scanners
17:05:43 <fog> but matching the input output types end to end would require special type annotated GADT - hetrogenous compatible functions 
17:06:31 <fog> and from that hetrogenous linear cycle, to graphs with the types being exchanged on the edges
17:07:23 <fog> im doing the linear cycle by just looping after consing the scanner just used onto the last, so they cycle round. but for a graph idk what to do!
17:07:40 <fog> snocing*
17:07:45 <davean> fog: so how is this different than ArrowLoop?
17:07:56 <fog> oh i didnt see that!
17:08:57 <fog> loop :: a (b, d) (c, d) -> a b c
17:09:01 <davean> Hum, maybe I missed you moving state around'
17:09:23 <fog> oh yeah, thats loop1
17:09:25 <fog> i have N
17:09:53 <fog> wait that looks more like loop2
17:10:31 <fog> it would be a mess to try and store the (a b) (b c) (c d) ...
17:11:06 <fog> so it sets them all to s
17:11:51 <fog> still not really sure what that Arrow version is doing...
17:14:08 <davean> fog: basicly MonadFix only transforming a value also.
17:14:08 <fog> yeah its functionality seems to be entierly specified by a complicated collection of laws, i cant understand it
17:14:50 <fog> mfix :: (a -> m a) -> m a
17:15:03 <fog> i dont see how
17:15:08 <davean> Dpn
17:15:14 <davean> Don't see how its like MonadFix?
17:15:31 <fog> no
17:16:39 <fog> i understand how neither MonadFix or ArrowLoop are like this
17:17:29 <fog> i have a list of modifiable functions. i use one on the input and place it at the back of the list and continue this process
17:17:48 <fog> the head one*
17:18:35 <fog> ski gave me a way of hiding the s so that they can have different state types for how they are modifiable 
17:19:09 <fog> then i can use modifiable functions, because they are modifiable, as the things that get updated during the state modification 
17:19:25 <fog> ie, using modifiable functions as the memory units of other modifiable functions
17:20:11 <fog> then, as eg the loop of N modifiable functions opperating on the same carry type, is a modifiable function on this type
17:20:27 <fog> so i can have these loops as the memory units of other modifiable functions
17:20:48 <fog> each of the functions in the loop can then have a loop of functions as its internal state
17:21:11 <fog> or with leafs as simple "elementary" modifiable functions 
17:21:23 <fog> like Free loops
17:21:40 <fog> ...
17:21:46 <fog> its probably a universal approximator
17:22:21 <fog> and it might make a nice programming framework with how abstracted the types can be above s ~ a ~ Double
17:22:48 <fog> but really i need branching to get cyclic graph instead of just loops
17:23:20 <dumptruckman> i'm trying to wrap my head around a predicated function
17:23:33 <dumptruckman> or a predicated unary operator, specifically
17:23:37 <dumptruckman> is that a thing
17:24:08 <fog> which are then scanner nets as neurons in "function nets as implementations" with memory
17:24:44 <dumptruckman> like, can i compose functions in such a way that: if predicate is true apply unary operator, otherwise apply identity operator
17:24:53 <fog> dumptruckman: what do you mean by predicated and unary? 
17:25:36 <fog> or are your arguments supposed to also have a Bool flag?
17:25:40 <dumptruckman> a function that has a predicate in front of it
17:25:47 <fog> then you would just pattern match 
17:25:59 <dumptruckman> i'm thinking about this more abstractly
17:26:09 <fog> f :: Bool -> rest of args; f True _ = ...; f False _ ...
17:26:09 <dumptruckman> lambda calculus, even
17:26:40 <fog> "in front of it" you just mean as a second argument?
17:27:57 <fog> you could have that as an SBool and get your functions annotated by a type level Bool
17:27:57 <dumptruckman> yeah... so essentially it's a two argument function where one of the arguments is a predicate function
17:27:57 <fog> value
17:27:57 <fog> like true or false
17:27:57 <dumptruckman> but i'm trying to consider how you might compose such a function to reuse the same predicate across the chain of composition
17:28:43 <dumptruckman> so i was trying to think if there was a way to break this down into lambda calculus to really consider the functional aspects of it
17:28:43 <fog> well your "annotated" intermidiate types just are paired with a bool
17:29:14 <fog> i guess you could use Either
17:29:27 <fog> why not just store a function over each of the types?
17:29:32 <dumptruckman> this isn't for a haskell project
17:29:53 <fog> what were you thinking?
17:29:53 <dumptruckman> but i came here cause it's the community I thought of that might understand this problem best
17:30:04 <fog> you should ask again
17:31:07 <dumptruckman> ok so like
17:31:15 <fog> its a bit vague to ask how to embed this flag to choose which function to use when applying it to an argument of a different type depending on if that satisfies a predicate
17:31:49 <dumptruckman> right... that's why i referred to it as a unary operator
17:31:49 <dumptruckman> cause I was thinking it can't just be a function
17:31:50 <fog> what was that again? 
17:31:50 <dumptruckman> the function has to take and return the same type
17:31:56 <dumptruckman> unary operator is like ++
17:32:02 <fog> ah ok
17:32:20 <dumptruckman> just a function that returns the same type it takes
17:32:46 <dumptruckman> and to make this weird
17:32:46 <fog> so your thinking of id as a basecase for when a type is not supported?
17:33:11 <dumptruckman> the predicate function can take in some other type and return bool
17:33:25 <dumptruckman> in the case of this problem anyway
17:33:27 <fog> at type or value level?
17:33:40 <dumptruckman> so like
17:33:41 <dumptruckman> my unary operator is a -> a
17:33:46 <dumptruckman> but the predicate is b -> bool
17:34:10 <fog> what do you want to examine to make the choice of internal function to use?
17:34:11 <dumptruckman> apologies but my haskell is *very* rusty at this point
17:34:21 <dumptruckman> and it was never good in the first place
17:35:00 <fog> you have two choices, you can examine a value or a type
17:35:27 <dumptruckman> the predicate examines a value, i guess
17:35:30 <fog> if your type satisfies the predicate then you can match on instances
17:35:47 <dumptruckman> nah, it's not a type
17:35:53 <dumptruckman> definitely value
17:36:07 <fog> and say something like "String -> String is supported, because we have one of these to choose from"
17:36:13 <Cale> dumptruckman: It has to be something like (a -> Bool) -> (a -> a) -> a -> a
17:36:22 <ski> dumptruckman : you can define `cond :: (a -> Bool) -> (a -> b) -> (a -> b) -> (a -> b)', e.g.
17:36:41 <Cale> conditionalApply p f x = if p x then f x else x
17:36:51 <fog> wouldnt it be more difficult to satisfy that at runtime, than picking using a type annotation at compile time?
17:36:52 <dumptruckman> can you remind me how the parens work in the type sig?
17:37:01 <ski> grouping, as usual
17:37:12 <dumptruckman> oh ok
17:37:27 <ski> `cond' takes a predicate, and two "unary" functions, makes a new one
17:37:27 <Cale> dumptruckman: So we're taking a function of type (a -> Bool) and a function of type (a -> a), and a value of type a, and producing a result of typ ea
17:37:29 <Cale> oops
17:37:29 <dumptruckman> right ok
17:37:30 <Cale> type a
17:38:07 <Cale> and we apply the function a -> Bool, and if the result is True, we apply the given function a -> a to the given value of type a, and if not, we don't apply it
17:38:10 <ski>   collatz = cond even (`div` 2) ((1 +) . (3 *))
17:38:17 <dumptruckman> so i'm thinking more like cond :: (a -> Bool) -> (b -> b) -> b
17:38:30 <fog> why not (a -> (b -> b))
17:38:32 <ski> where does `a' come from ?
17:38:33 <dumptruckman> and then
17:39:01 <fog> (b,a)
17:39:06 <dumptruckman> does it matter? the idea is that you're giving the function _some_ predicate
17:39:20 <fog> yeah, you need to provide one of those
17:39:25 <Cale> Need two functions if you want the type to change, because if your starting value has type a, and the a -> b function changes its type, what do you do in the case that the predicate fails?
17:39:41 <Cale> You can't produce the same value of type a, because that doesn't match b
17:39:42 <fog> oh, something for the predicate to act on
17:39:53 <dumptruckman> Cale: that's what i was thinking
17:40:08 <fog> if it just used type information you wouldnt have that problem
17:40:09 <Cale> and yeah, the predicate has to act on something... if it acts on the value you started with, that's a value of type a here
17:40:11 <dumptruckman> because the function you try to compose into won't take that predicate
17:40:23 <dumptruckman> right, but it's acting on some other value in this case
17:40:27 <fog> and instead of paring with the thing that the predicate acts on, you can use a phantom annotation
17:40:30 <ski> which value ?
17:40:32 <Cale> how do we get the other value?
17:40:43 <dumptruckman> it's given as an initial argument
17:40:48 <Cale> Or do you just want to take a Bool?
17:40:50 <Cale> maybe?
17:41:14 <dumptruckman> yeah, i'm wondering if i just should do that
17:41:14 <fog> that `a' somehow has a `b' inside it?
17:41:15 <ski>   cond :: a -> (a -> Bool) -> (b -> b) -> (b -> b)  -- ?
17:41:17 <dumptruckman> the a does not have a b
17:41:24 <dumptruckman> the predicate evaluates itself
17:41:31 <ski> `a' and `b' are unrelated ?
17:41:35 <dumptruckman> determines if the a is true or false
17:41:36 <dumptruckman> yes
17:41:43 <fog> oh sorry, that the `b' contains the predicates argument `a;
17:41:50 <Cale> Yeah, ski's type might make sense
17:42:14 <Cale> But of course, if all that cond is going to do is apply the given function to the given additional value of type a...
17:42:16 <ski>   cond :: Bool -> (b -> b) -> (b -> b)  -- simplifies to this, as Cale said
17:42:20 <dumptruckman> well like
17:42:22 <Cale> Why not just take the result of that?
17:42:26 <dumptruckman> i want the predicate to be like
17:42:33 <ski>   cond :: (() -> Bool) -> (b -> b) -> (b -> b)  -- or, in a strict setting, possibly ?
17:42:38 <dumptruckman> actually way
17:42:39 <dumptruckman> wait
17:42:46 <dumptruckman> the predicate doesn't take an arg
17:42:47 <dumptruckman> derp
17:42:55 <Cale> That makes it the same thing as a Bool
17:42:57 <dumptruckman> right
17:42:59 <ski> but if there's no side-effects, why not compute the `Bool' upfront ?
17:43:06 <fog> so your just pattern matching 
17:43:11 <fog> on the bool
17:43:22 <dumptruckman> the predicate is just provided as a lambda function and it returns a bool
17:43:45 <dumptruckman> so yeah, we can just treat it as Bool, I think
17:43:45 <fog> why can it decide which function to use all on its own with no input?
17:43:53 <ski> so it's really just a flag, not a predicate, then
17:43:58 <dumptruckman> eh
17:43:59 <dumptruckman> like
17:44:21 <dumptruckman> wait no.. it does have an arg haha
17:44:31 <ski> where does it come from ?
17:44:33 <fog> what does the predicate act on?
17:44:55 <dumptruckman> yeah.... that's kinda where this breaks down
17:45:11 <fog> thats why it ended up having something paried with the input
17:45:20 <fog> something other than the input that it could act on 
17:45:31 <dumptruckman> ultimately the use case entails a stateful comparison
17:45:39 <fog> otherwise you could decide by acting on the input itself to decide which secondary computation to use
17:46:00 <fog> but if you want to match on the input, then different types and instances work well 
17:46:20 <dumptruckman> but no
17:46:20 <fog> matching on its type
17:46:37 <fog> do you want the choice to occur at runtime or compiletime
17:46:53 <ski> run-time, presumably
17:47:04 <Cale> dumptruckman: Maybe it would help to have more context
17:47:15 <fog> i dont see why that should be presumed, normally i decide which instance to use based on a functions types at compile time
17:47:26 <dumptruckman> ok
17:47:36 <dumptruckman> the context is that i'm trying to write something crazy functional in java
17:48:03 <dumptruckman> what i end up with is this....
17:48:27 <Axman6> cocreature: Congrats on https://github.com/haskell/ghcide! Thanks for the work you and all the others have put into it - having come to rely on DAML Studio, I know this will continue to be super useful to the Haskell community
17:49:47 <ski> > drop 3 (inits "ghcide")
17:49:47 <lambdabot>  ["ghc","ghci","ghcid","ghcide"]
17:49:47 <Cale> haha
17:50:04 <dumptruckman> the composition function i have currently has a type like this (s -> (p -> Bool) -> s) -> (s -> (p -> Bool) -> s) -> (s -> (p -> Bool) -> s)
17:50:08 <fog> hey ski did you see the example i made?
17:50:12 <ski> is "ghcidea" next ?
17:50:12 <Cale> I... can't follow all the different ghcide/hie/etc. stuff, is this the new collaboration point?
17:50:32 <ski> (and then "ghcideal" ?)
17:50:33 <fog> ski: this one; https://gist.github.com/fog-hs/4520617016e5345a0400e417bd6f23e0
17:50:46 <dumptruckman> but it's non standard composition
17:50:49 <ski> yes
17:50:59 <fog> it does that thing you were saying
17:51:09 <ski> i don't see the point of `Has'
17:51:10 <Axman6> soon we'll need it running as a system wide daemon, called ghcided
17:51:46 <fog> ski: it says that modifiable functions can be cast to wither SSP or (s -> (a -> (o,s)),s) style
17:52:19 <fog> its used to convert the hetrogenous scanners to SSP
17:52:23 <ski> dumptruckman : that can't dynamically choose between the two first arguments
17:52:25 <dumptruckman> so i'm wondering if there's a way I can compose the predicate (p -> Bool) onto the unary operator (s -> s) to create some kind of new function that can then be composed in a standard way
17:52:32 <dumptruckman> it doesn't choose
17:53:07 <ski> fog : why a class `Has', why not just two functions ?
17:53:17 <dumptruckman> i should reiterate: if the predicate tests true, the function applies, otherwise the indentity function is applied
17:53:25 <ski> fog : where are you going to use `Has', in a polymorphic constrained operation ?
17:54:00 <fog> i use it everytime i need to witness an isomorphism, or the one directional version of that
17:54:10 <ski> dumptruckman : which function ?
17:54:19 <dumptruckman> thing :: s -> (p -> Bool) -> s
17:54:20 <fog> to give a unique way of turning something into something else
17:54:32 <fog> if theres only one sensible way to do that use a Has instance
17:54:42 <ski> dumptruckman : say `frob :: (s -> (p -> Bool) -> s) -> (s -> (p -> Bool) -> s) -> (s -> (p -> Bool) -> s); frob f g = h where h s p = ...'
17:55:25 <fog> where is this `p' coming from!?
17:55:51 <ski> fog : you haven't show any useful operation with signature like `foo :: Has a b => ..a..b..'
17:56:03 <ski> fog : from inside `f' and `g', obviously
17:56:06 <dumptruckman> ski: i don't really ge tit
17:56:22 <ski> dumptruckman : so your `thing' could be `f' or `g'
17:56:36 <ski> (or `h')
17:56:48 <dumptruckman> nah
17:57:08 <dumptruckman> i want frob to be a function that applies both functions
17:57:21 <ski> dumptruckman : "if the predicate tests true, the function applies, otherwise the indentity function is applied" -- which function ? are you talking about `thing'/`f'/`g'/`h' ? or `frob' ?
17:57:24 <dumptruckman> f o g
17:57:45 <ski> `frob' is a type of sequential composition ?
17:57:49 <monochrom> Wait a second! "data X = ... deriving Typeable" is no longer necessary?! GHC always does it for me?!
17:57:51 <dumptruckman> hng on
17:59:17 * monochrom notices it by omitting DeriveDataTypeable just for the kick, then notices no error, then hops over to see the GHC user's guide on this.
17:59:33 <ski> dumptruckman : do you have `h s p = f (g s p) p' ?
17:59:47 <ski> iirc yes, monochrom
17:59:49 <dumptruckman> ok, i think i'm just bad as haskell and getting the types wrong
17:59:55 <dumptruckman> cause i think it probably is just Bool
17:59:55 <int-e> monochrom: only since ghc 7.10
17:59:57 <ski> (i don't recall when this was changed)
17:59:58 <Axman6> monochrom: I did not agree to this unrequested reflection!
18:00:01 <dumptruckman> and not p -> Bool
18:00:23 <ski> dumptruckman : could be `() -> Bool'
18:00:40 <ski> (unclear whether there's any point to that, though)
18:00:40 <dumptruckman> the idea is to pass an anonymous function
18:00:48 <dumptruckman> that has an input
18:00:53 <dumptruckman> but that input is prefilled
18:00:57 <ski> and the input comes from ?
18:01:00 <ski> yea, so a closure
18:01:03 <dumptruckman> yes
18:01:30 <ski> why not precompute the `Bool' ?
18:01:37 <monochrom> Axman6: The safety is in, if you use typeOf or typeRep etc., your term incurs a Typeable constraint. You can opt out by having a polymorphic function type e.g. "f :: a -> ()" that one disallows using Typeable so it's OK.
18:02:06 <dumptruckman> i mean, i guess it is in this case?
18:02:09 <dumptruckman> i don't know
18:02:13 <dumptruckman> yeah, i guess it is
18:02:15 <ski> @type let foo x = (typeOf x,x) in foo
18:02:16 <lambdabot> Typeable b => b -> (TypeRep, b)
18:02:22 <Axman6> my types did not concent to revealing their identity to any ol' function
18:02:39 <monochrom> The funny sentence though is "and they may be reported as an error in a later version of the compiler" referring to writing "deriving Typeable"
18:02:47 <monochrom> Oh! OK heh
18:02:51 <ski> you still need to put explicit `Typeable' constraints on tyvars
18:03:25 <Axman6> other people's functions are not the police, they can't just ask MY types for their identity!
18:03:33 <monochrom> Well if your function type is "f :: Int -> May", we all know they're Int and May, no secret identity.
18:03:55 <ski> hm, i suppose, Axman6
18:04:08 <monochrom> If you call my function and my function is "g :: a -> ()", you know I respect your privacy.
18:04:35 <ski> if `g :: Typeable a => a -> ()', then possibly not
18:04:47 <monochrom> If I have another function "h :: Typeable a => a -> ()", then it's because, like on Steam, I need your credit card...
18:05:14 * ski . o O ( "Trust me." )
18:05:25 <Axman6> monochrom: I do, and I appreciate you for that
18:05:42 <monochrom> steam :: Typeable a => a -> STM ()   -- I need your credit card to complete the transaction
18:06:03 <ski> dumptruckman : so `cond' will distribute `p' to `f' and `g' ?
18:06:06 <monochrom> Oh hey STM = STeaM haha
18:06:19 <ski> dumptruckman : or `f' and `g' could know about `p' themselves, to begin with, maybe ?
18:06:28 <dumptruckman> hang on
18:06:33 <dumptruckman> i have the fundamental type all wrong
18:07:58 <dumptruckman> ok
18:07:59 <dumptruckman> woopy :: a -> (a -> a) -> Bool -> a
18:08:09 <dumptruckman> this is the correct type
18:08:41 <dumptruckman> and the call would look like this woopy 5 (\x -> x + 1) ((\x -> True) 123151413)
18:08:53 <dumptruckman> in this case, the predicate doesn't care what the arg is
18:08:58 <ski> fog : both `loop' and `loopN' has `x' occur only contravariantly (disregarding the constraint). do you have any (useful) example, where `x' is also covariant ? .. or a "binary method" case ?
18:09:07 <dumptruckman> but for the purposes of this function, we don't even care that it is a predicate function
18:09:45 <ski> dumptruckman : did you mean `woopy :: a -> (a -> a) -> (a -> Bool) -> a' ?
18:09:54 <ski> hm
18:09:59 <ski> @type until
18:10:01 <lambdabot> (a -> Bool) -> (a -> a) -> a -> a
18:10:01 <dumptruckman> woopy is defined as woopy s m p | p = m s | otherwise = s
18:10:07 <dumptruckman> nope
18:10:09 <ski> yea, i guess you didn't want to loop
18:10:10 <dumptruckman> the type is correct
18:11:09 <ski> so `woopy s m p = cond (const p) m id s', given my `cond :: (a -> Bool) -> (a -> b) -> (a -> b) -> (a -> b)'
18:12:10 <dumptruckman> i guess but the predicate function here really doesn't want the same type
18:12:33 <dumptruckman> well
18:12:42 <dumptruckman> i guess i just don't know why you'd complicate it like that
18:13:01 <ski> why not check `p' directly in the caller, and select between `m' and `id' ?
18:13:13 <dumptruckman> i mean, that's what i'm doing effectively
18:13:16 <ski> what code is simplified, or made nicer, by having `woopy' ?
18:13:48 <dumptruckman> this is what i'm calling a "predicated unary operator" ok?
18:13:53 <monochrom> Anyway this is my latest sick idea: https://dpaste.com/DEYFB43CJ
18:13:55 <dumptruckman> idfk
18:13:59 <ski> for my `cond', you can express things pointlessly
18:14:07 <ski> which might occasionally be a win
18:14:20 <monochrom> Hrm where have the comments gone?!
18:14:40 <monochrom> Oh I guess user erro.
18:15:31 <dumptruckman> the actual use case if i have a string replacer function that is stored (it has some state) it takes a string and a predicate, if the predicate is true, it performs the replacement, otherwise it just returns the input string
18:15:44 <monochrom> OK, corrected: https://dpaste.com/6NRNFYKED
18:16:21 <dumptruckman> but i want to combine multiple of these replacers together to have 1 replacer function that does all the replacements, if the same predicate is tests true
18:16:27 <dumptruckman> otherwise none of the replacements happen
18:16:37 <dumptruckman> *except* some of the functions might ignore the predicate
18:16:46 <dumptruckman> and do the replacement even if it tests false
18:17:20 <dumptruckman> the stored function just knows what string to replace and with what to replace it with
18:17:28 <ski> monochrom : needs a precedence argument :)
18:17:57 <monochrom> No, I think precedence is in vain.
18:18:16 <monochrom> deriving Generic always gives you outer sum, inner product.
18:18:27 <ski> well, i guess, if you're just having a single sum-of-product layer
18:19:08 <monochrom> Then when you hit Rec0 aka K1 R, you get a vanilla type, all you can do is ask "show . typeOf/Rep" for a string.
18:19:39 <monochrom> Now that string may be "[Int]" or may be "M -> N" but it's an unstructured string, you are toasted.
18:20:03 <ski> dumptruckman : ok, so you're distributing an environment/config (the `Bool')
18:20:17 <dumptruckman> yess
18:20:32 <ski> dumptruckman : does the replacer depend on (or modify) some state ?
18:20:52 <monochrom> This is just a toy fooling around with "what if I use GHC.Generics but I don't have any value I just look at the type level information?"
18:21:14 <dumptruckman> it definitely doesn't modify state
18:21:32 <ski> monochrom : we need `typeOfPrec' ?
18:21:34 <dumptruckman> it's just a "stored function" for lack of a better word
18:21:57 <ski> er, the `show' is in your instance
18:22:02 <dumptruckman> i can probably model it in haskell hang on
18:22:06 <monochrom> I think TypeRep has useful strutural information.
18:22:18 <monochrom> yeah I'm too lazy.
18:25:13 <dumptruckman> i'm finding that writing this out myself in Haskell is immediately giving me a deeper understanding of the problem :D
18:26:19 * ski . o O ( "We will encourage you to develop the three great virtues of a programmer: laziness, impatience, and hubris." -- Larry Wall,Randal L. Schwartz ; "The Swine Before Pearl" (talk/presentation) by Shriram Krishnamurthi in 2001-11 at <http://www.ai.mit.edu/projects/dynlangs/ll1/shriram-talk.pdf>,<https://cs.brown.edu/~sk/Publications/Talks/SwineBeforePerl/audio.mp3>,<https://cs.brown.edu/~sk/Publications/Talks/SwineBeforePerl/> )
18:26:53 <ski> hehe, dumptruckman :)
18:30:29 <int-e> . o O ( Have you tried explaining it to the computer? >>> Have you tried explaining it to the rubber duck? )
18:35:46 <ski> how about a computerized rubber duck (obviously with its own IP address, &c.) -- best of both worlds ?
18:38:05 <jackdk> Does anyone here know of a library that provides hedgehog generators for unicode characters that belong to certain classes (e.g., "letter")? My google-fu is failing; best I've found is functions that _classify_ characters, which would be a very inefficient way of generating
18:48:53 <koz_> Does anyone know what Hugs' intermediate representation is? Namely, did it actually interpret Haskell directly, or did it translate Haskell to something else, then interpret _that_?
18:50:25 <ski> koz_ : iirc, it interpreted an intermediate representation
18:50:53 <koz_> ski: Is there any description anywhere of said IR?
18:58:22 <ski> i dunno where
18:59:13 <Axman6> jackdk: I assume there's a way to generate values from lists? just define alphas = filter isAlpha universe; hangul = filter isHangul universe
19:17:37 <jackdk> Axman6: yeah if I want to run across all of unicode one for each class I'm interested in each time I run the tests. This is in the "annoying but don't have time to solve properly" bucket so I'll just ascii it for now =/
19:26:00 <Turmfalke> What is the Parsec function to fold a list of parsers with (<|>)?
19:28:37 <jackdk> Turmfalke: `Data.Foldable.asum`?
19:28:47 <jackdk> dunno if there's a specific one in parsec or not
19:30:28 <Turmfalke> jackdk: Thanks, asum works
19:32:41 <VF> I'm bashing my head against this for two days now...
19:32:41 <koz_> :t pure <*> pure
19:32:43 <lambdabot> error:
19:32:43 <lambdabot>     • Ambiguous type variable ‘f0’ arising from a use of ‘pure’
19:32:43 <lambdabot>       prevents the constraint ‘(Applicative f0)’ from being solved.
19:32:51 <VF> Is there a way to link against a specific library statically whilst keeping the rest of the libs dynamic? I'm using cabal as my build tool.I'm using a FFI to the C lib that I have compiled and installed in the system folders (as a Nix derivation). The thing is - this library is built only as (*.a) files, no (*.so) in sight. 
19:32:57 <VF> GHC linking of the main executable fails with "error: undefined reference to <symbol>". I can see using nm -C <lib.a> that this symbol does exist in the provided (.a) lib files.I've tried adding 'extra-lib-dirs' and 'extra-libraries' to the cabal file to no avail.
19:35:30 <VF> If I specify -static in 'ghc-options' it fails in even worse way (more symbols not found)
19:35:37 <glguy> % length <$> M.fromListWith (++) [(cat, [c]) | c <- ['\0'..], let cat = generalCategory c, cat /= NotAssigned]
19:35:38 <yahb> glguy: fromList [(UppercaseLetter,1788),(LowercaseLetter,2151),(TitlecaseLetter,31),(ModifierLetter,258),(OtherLetter,121416),(NonSpacingMark,1826),(SpacingCombiningMark,429),(EnclosingMark,13),(DecimalNumber,630),(LetterNumber,236),(OtherNumber,888),(ConnectorPunctuation,10),(DashPunctuation,24),(OpenPunctuation,75),(ClosePunctuation,73),(InitialQuote,12),(FinalQuote,10),(OtherPunctuation,588),(MathSymb
19:40:22 <koz_> This here: https://hackage.haskell.org/package/scanner says that you can _always_ implement a parser which uses backtracking as one which doesn't. What's the basis of this claim?
19:41:37 <glguy> I imagine either there isn't a basis for the claim or the basis is listed in the package
19:41:46 <koz_> glguy: I see nothing listed in the package.
19:42:00 <koz_> (the claim is its readme)
19:50:23 <dumptruckman> by george i've done it
19:50:26 <dumptruckman> (finally)
19:50:27 <dumptruckman> https://repl.it/repls/BreakableWindingTitle
19:50:49 <dumptruckman> ski still around? ^
19:53:06 <dumptruckman> So... how do I compose fooReplacer and barReplacer into a single function that could just be a drop in replacement in the main function
19:53:54 <dumptruckman> i.e. foobarReplacer "[A][B]" True
19:54:26 <dolio> koz_: My guess would be that it is some kind of uninteresting technicality about what counts as 'backtracking'.
19:55:33 <koz_> dolio: Yeah, well, that wouldn't surprise me. I was just curious. The best I could find was an argument of the form 'applicative, non-backtracking parser combinators can parse any LL(k), and that's Should Be Enough For Anyone'.
19:55:38 <koz_> But that seems like a _much_ weaker claim.
19:56:43 <dolio> Yeah, there are definitely grammar classifications that don't need backtracking.
19:57:01 <glguy> I did a version of ReadP but where <++ doesn't backtrack (and +++ already didn't backtrack)
19:57:33 <glguy> I'm not saying that satisfies the claim, just on the topic of "backtracking"
19:59:52 <glguy> When we say a parser uses "backtracking" does that mean that it potentially has to hold on to earlier inputs in memory while looking at later inputs?
19:59:56 <dumptruckman> I guess it works to change the signature for tagReplacer to tagReplacer :: Eq a => [a] -> [a] -> (([a] -> [a]) -> [a] -> Bool -> [a]) -> [a] -> Bool -> [a]
20:00:46 <dumptruckman> but more generally
20:00:55 <koz_> glguy: When I mean 'backtracking', I mean it in the sense of 'try' from *parsec.
20:01:34 <dumptruckman> I want a composition function like (a -> Bool -> a) -> (a -> Bool -> a) -> (a -> Bool -> a)
20:02:12 <koz_> dumptruckman: How do you propose this composition works?
20:02:21 <dumptruckman> well
20:02:26 <dmwit> :t liftA2 (.)
20:02:27 <lambdabot> Applicative f => f (b -> c) -> f (a -> b) -> f (a -> c)
20:02:45 <dmwit> :t liftA2 (.) :: (Bool -> a -> a) -> (Bool -> a -> a) -> (Bool -> a -> a)
20:02:47 <lambdabot> (Bool -> a -> a) -> (Bool -> a -> a) -> Bool -> a -> a
20:02:51 <dumptruckman> the a out of the first function goes into the a in of the second function and is ultimately the a out of the combined function
20:03:19 <dumptruckman> but what i am trying to determine is like
20:03:37 <dumptruckman> can i compose this with functions more like (a -> b)
20:03:47 <dumptruckman> where the Bool part is composed into the mix
20:04:51 <Andre> when I pattern match on a GADT constructor and my rhs is refined via a type equality constraint involving newly introduced type variables, how can I reference those type variables for usage in things like TypeApplications?
20:05:01 <dumptruckman> thing is, for the Bool part to work, these have to be unary operator functions
20:05:11 <dmwit> > liftA2 (.) (f :: Expr -> Expr -> Expr) g x y
20:05:13 <lambdabot>  f x (g x y)
20:05:13 <dumptruckman> so really it's composing functions that are (a -> a)
20:05:50 <dmwit> Andre: I believe there's a GHC proposal about allowing that, but it is not yet implemented/released.
20:06:18 <Andre> do you have a link? or know hat its called?
20:06:25 <Andre> what*
20:06:37 <koz_> dmwit: Can you not give an explicit type signature to the left of -> in the case match?
20:06:59 <dmwit> https://github.com/ghc-proposals/ghc-proposals/blob/type-applications-in-patterns/proposals/type-applications-in-patterns.rst
20:07:13 <dmwit> https://github.com/ghc-proposals/ghc-proposals/pull/126 for the discussion
20:07:42 <Andre> tyvm
20:08:41 <dmwit> koz_: Sometimes?
20:08:50 <dumptruckman> so i guess I need something like Bool -> (a -> a) -> (a -> Bool -> a)  and (a -> Bool -> a) -> (a -> a) -> (a -> Bool -> a)
20:09:32 <Andre> @dmwit hmm this proposql implies that
20:09:32 <lambdabot> Unknown command, try @list
20:10:23 <dmwit> dumptruckman: What don't you like about my proposed solution?
20:10:23 <Andre> foo (MkFoo (x :: ty)) = … lets you give a name to a type variable introduced by a pattern match
20:10:31 <dumptruckman> I have no idea what it means dmwit
20:10:35 <dumptruckman> didn't know you were even talking to me
20:11:01 <dmwit> dumptruckman: 
20:11:09 <dmwit> :t liftA2 (.) :: (Bool -> a -> a) -> (Bool -> a -> a) -> (Bool -> a -> a)
20:11:10 <lambdabot> (Bool -> a -> a) -> (Bool -> a -> a) -> Bool -> a -> a
20:11:24 <dumptruckman> i do not understand what liftA2 is doing
20:11:36 <dumptruckman> or what :t liftA2 (.) :: is
20:12:08 <dmwit> Okay. You could check out the All About Monads section on the reader monad family, or you could play around with it in ghci a bit and see if you can experimentally determine what it does.
20:12:34 <dumptruckman> well
20:12:36 <dmwit> Or you could check out the other messages I posted that use liftA2, and see if you can use them to understand a bit more.
20:12:47 <dumptruckman> i'm guessing :t has something to do with lambdabot and not monads
20:13:16 <dumptruckman> but you're also using type signatures in a way i'm not familiar with
20:13:31 <dumptruckman> liftA2 (.) ::
20:13:39 <dumptruckman> i get liftA2 ::
20:13:44 <dumptruckman> but what is the (.) doing in there
20:13:54 <dmwit> You can give a type signature to any expression, to ask the compiler to double-check that the given expression has the given type (and possibly make the type more monomorphic).
20:14:03 <dmwit> (.) is the normal function composition.
20:14:04 <dmwit> :t (.)
20:14:05 <lambdabot> (b -> c) -> (a -> b) -> a -> c
20:14:11 <dmwit> ?src (.)
20:14:11 <lambdabot> (f . g) x = f (g x)
20:14:28 <dumptruckman> ohh
20:14:34 <dmwit> Some examples of such type annotations:
20:14:37 <dumptruckman> :t liftA2 (.)
20:14:37 <dmwit> > 3 :: Int
20:14:38 <lambdabot> Applicative f => f (b -> c) -> f (a -> b) -> f (a -> c)
20:14:39 <lambdabot>  3
20:14:42 <dmwit> > 3 :: Double
20:14:44 <lambdabot>  3.0
20:14:52 <dmwit> > (3 :: Int, 3 :: Double)
20:14:54 <lambdabot>  (3,3.0)
20:15:27 <dumptruckman> :t liftA2
20:15:29 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
20:15:35 <dumptruckman> hmm
20:15:37 <dumptruckman> ok, thanks
20:21:24 <dmwit> ?let fun1 True x = 10*x+1; fun1 False x = 10*x+2; fun2 True x = 100*x+3; fun2 False x = 100*x+4
20:21:26 <lambdabot>  Defined.
20:21:37 <dmwit> > liftA2 (.) fun1 fun2 True 5
20:21:39 <lambdabot>  5031
20:21:52 <dmwit> > liftA2 (.) fun1 fun2 False 5
20:21:54 <lambdabot>  5042
20:21:59 <olligobber> I misread "defined" as "denied" and thought the bot rejected you
20:22:46 <dmwit> dumptruckman: Perhaps working out why these answers are the ones you get would help you know what liftA2 (.) does.
20:24:43 <dmwit> I guess using 100 instead of 10 in fun2 wasn't really necessary for clarity in the way I thought it was. But whatever.
20:26:10 <dumptruckman> well
20:26:17 <dumptruckman> yeah, this obviously does what i'm looking for
20:26:47 <dumptruckman> but yeah i'll have to understand it fully so i can port it over to java :D
20:27:31 <dumptruckman> it's nice to know that there is a way
20:32:11 <glguy> I've been adding variables and file inclusion to my configuration language (as an optional post-processing pass). Figuring out how I want file inclusion to work with relative paths is fussier than I'd realized it would be.
20:32:12 <glguy> https://glguy.net/share/config-value/Config-Macro.html
20:33:46 <fog> woop woop Free looping scanners work!
20:34:48 <fog> https://gist.github.com/fog-hs/2ca6c4769ab41480b2cf3f7eab7c4c0c
20:37:29 <koz_> glguy: That's really neat.
20:37:47 <koz_> (I also love that you have a schema language for your format, like a good human being)
20:40:34 <fog> cant tell what they do though...
20:40:47 <glguy> koz_: example fragment https://gist.github.com/glguy/6553a10e9dc8f18687376dffdb25fdf0
20:41:19 * hackage hledger-lib 1.19 - A reusable library providing the core functionality of hledger  https://hackage.haskell.org/package/hledger-lib-1.19 (SimonMichael)
20:41:20 <koz_> glguy: Looks damn good.
20:42:19 * hackage hledger-web 1.19, hledger-ui 1.19, hledger 1.19 (SimonMichael): https://qbin.io/act-wayne-xadg
20:42:25 <fog> the modifiable functions have as their modifiable memory, loops of similarly defined modifiable functions
20:42:43 <fog> now i need graphs!
20:42:54 <fog> instead of loops...
20:47:04 <fog> so i guess i need mimo scanners
20:47:38 <fog> which can use linear types!
20:48:53 <dmwit> glguy: Yes, relative paths are very interesting. Especially you probably want to be careful about .. in most situations.
20:50:35 <dmwit> (As a default. Some applications may want to allow unrestricted .. use, I guess, but in a lot of settings having an error when you try to "escape" the configuration directory is the right behavior.)
20:51:03 <glguy> I punted on the problem and make the behavior a parameter in the library :)
20:51:10 <glguy> but that didn't save me when it came to using it in my client
20:51:56 <glguy> I kicked the can down the road to myself
20:53:04 <dmwit> hehe, yeah
20:53:28 <glguy> Options in mind included: having a search path, always relative to cwd, relative to the original config file, relative to the current (sub-)config file, not allowing any directories at all
20:55:41 <dmwit> Phew, "always relative to cwd" seems like a rare wish. But the others all seem completely plausible.
20:56:44 * glguy wonders if the people using this at work know about the vim syntax highlighting support: https://imgur.com/a/X0j2IJ2
20:57:01 * dmwit didn't
20:57:13 <glguy> I agree that that's not super desirable; but it's what you get if you don't think very hard when you implement it :)
20:58:33 <glguy> dmwit: If you're one of those: https://github.com/glguy/config-value/blob/master/config-value.vim
20:58:34 <dmwit> Anyway I think the thing I'm trying to convince you to think about is orthogonal to deciding where to root relative paths.
20:58:52 <glguy> sandboxing
20:59:01 <dmwit> Yeah, akin to that.
21:00:00 <glguy> I think what I probably need to do is generalize this: https://github.com/glguy/config-value/blob/master/src/Config/Macro.hs#L245
21:00:17 <glguy> so that you can 1) do IO to implement a search path 2) fail if you don't like the arguments
21:00:19 <dmwit> Nice, I'll grab that highlighter.
21:00:48 <glguy> dmwit: Toss that vim comment at the bottom of your files to turn it on (since I never did figure out a good file extension)
21:01:00 <glguy> -- vim: filetype=config-value
21:02:04 <dmwit> I'll probably just :set ft by hand. Putting editor-specific stuff in editor-agnostic files feels icky to me for some reason I can't quite nail down.
21:02:25 <dmwit> (And toss something quick in a .yard file if I have to do that a lot.)
21:02:46 <glguy> What's .yard?
21:03:31 <dmwit> I wrote an extension that does roughly what modelines do. It isn't restricted to vim's sandbox, but still has a security story about preventing attackers from running arbitrary vimscript in a .yard file.
21:03:37 <dmwit> https://github.com/dmwit/vim-yard
21:04:48 <glguy> if I put a .yard file in my git repo do you have anything to notice?
21:05:02 <dmwit> Yes, I describe the security story in the README.
21:05:10 <glguy> OK, you want me to keep reading then
21:05:10 <dmwit> You can't make me run things I'm not okay with running.
21:05:58 <dmwit> In short: there are two configuration files. One lists full-file hashes, the other lists individual lines. A .yard file is loaded only if its full-file hash matches one in the whitelist, or all its lines match one of the ones in the line whitelist.
21:06:39 <glguy> OK, so what I'd need to do is find one of your existing yard files from a place you trust and move that to my repo?
21:06:54 <dmwit> Yep, if you did that, then I'd run your script.
21:07:13 <dmwit> Presumably I'm okay with that.
21:07:44 <glguy> Well that's neat. Did you do it because you got bit, or because you think ahead?
21:08:09 <dmwit> I did not get bitten.
21:08:24 <dmwit> Also I run arbitrary code from the Internet without checking it very hard quite a lot.
21:08:35 <dmwit> So my internal security monologue is not super consistent. ^_^
21:16:20 <glguy> dmwit: Maybe the right answer is https://en.wikipedia.org/wiki/Resource_fork
21:16:33 <ph88> hello :)
21:17:12 <glguy> If one is looking for a good place to put editor specific metadata like that somewhere where it won't be separated from the file but also doesn't pollute it
21:18:19 <ph88> i'm trying to use the ginger package and have a heterogenious hashmap or list with the GVal data type. I get some type errors, i'm not sure what to do https://bpa.st/HVYA https://hackage.haskell.org/package/ginger-0.10.1.0 
21:19:42 <VF> FML. This actually worked! 
21:19:44 <VF> https://stackoverflow.com/a/46946192
21:33:00 <dmwit> glguy: huh, neat!
22:57:30 <dmj`> does anybody know who maintains hdbc-postgresql
