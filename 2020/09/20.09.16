00:03:06 <dminuoso> koz_: If at least Traversable exported traverse_ :<
01:02:17 <maerwald> merijn: how were you able to build persistent with 8.10?
01:17:27 <hekkaidekapus> maerwald: But it builds fine for me‚Ñ¢. What issue are you having?
01:18:49 <hekkaidekapus> Are you using -Werror by any chance?
01:39:28 <maerwald> hekkaidekapus: several build failures... MonadFail, TH
01:39:54 <maerwald> maybe I'm on a wrong branch
01:42:02 <hekkaidekapus> Yeah, something doesn‚Äôt add up. See the logs of what I just built: https://paste.tomsmeding.com/ztaeFVBV
01:44:12 <maerwald> hekkaidekapus: https://paste.tomsmeding.com/SPedaK8y this is what I get (as part of a project)... the master branch seems to build ok though
01:45:12 <hekkaidekapus> Ah, yours is persistent-template, I did persistent. Let me try the former.
01:47:28 <hekkaidekapus> maerwald: Yep, broken!
01:48:33 <tomsmeding> hekkaidekapus: unrelated: that paste is ~82 KiB, which is ~65% of the current maximum paste size. I am now wondering whether the limit should be raised, if it can be reached by just building 'persistent'.
01:49:14 <maerwald> build logs tend to be long, sometimes several MB
01:49:16 * tomsmeding also finds it funny that only last night did someone post an issue on the pastebin repository that perhaps the paste page should show the maximum paste size
01:49:26 <maerwald> that was me
01:49:31 <tomsmeding> ah
01:49:35 <maerwald> I think 5mb is a reasonable size, imo
01:49:45 <maerwald> but I don't know if that affects spam detection
01:49:54 <hekkaidekapus> tomsmeding: I enabled lot of cruft (haddock, various warning categories), so the limit is fine, I think.
01:50:02 <maerwald> you might wanna record the size an IP has pasted within an hour
01:50:06 <tomsmeding> I did not fully appreciate the power of build logs
01:50:11 <maerwald> and limit it to 10mb or something
01:50:28 <tomsmeding> currently I only have a frequency-per-IP limit, but that limit is pretty high
01:51:14 <hekkaidekapus> tomsmeding: I think you can just punt on it until someone really breaks the limit.
01:51:49 * hackage json-bytes-builder 0.5.2.1 - Direct-to-bytes JSON Builder  https://hackage.haskell.org/package/json-bytes-builder-0.5.2.1 (NikitaVolkov)
01:55:04 <tomsmeding> hm I have a nice idea about how to this kind of spam detection in a more scalable manner, will implement later this week and then raise the paste limit
01:57:39 <maerwald> I'd give a score per paste... if the paste is not haskell, give a bad score... if an IP scores bad for 10 times, block them for 5 minutes etc
01:58:23 <maerwald> that'll also prevent from other channels abusing it for build logs, for example
01:59:03 <merijn> maerwald: eh, easily?
01:59:32 <hekkaidekapus> maerwald: persistent-template has a lower bound on persistent (>= 2.11) that is incompatible with the latest persistent release (2.10.5.2).
02:00:07 <merijn> maerwald: Which persistent are you using?
02:00:13 <maerwald> looks like they messed up
02:00:25 <maerwald> persistent-template-2.8.3.0
02:00:27 <merijn> I'm using 2.10.5
02:00:40 <maerwald> and it fails to build with the above TH error
02:01:38 <merijn> I'm using persistent-template 2.8.2
02:01:44 <merijn> Or rather
02:01:48 <hekkaidekapus> maerwald: So either build persistent locally or add a source-repository-package stanza.
02:01:53 <merijn> ^>= 2.8.2
02:03:39 <merijn> maerwald: Which persistent version?
02:04:20 <merijn> Because I second hekkaidekapus analysis that 2.8.3 isn't currently buildable
02:04:40 <merijn> So the fact that it's trying to means you're doing something else than just letting cabal-install resolve dependencies
02:05:01 <maerwald> 2.8.3.1 builds though and the lower bound 2.11 on persistent seems to be nonsense (at least they build)
02:05:34 <merijn> I would assume it's not nonsense and that the newest release isn't compatible with 2.10?
02:06:14 <maerwald> ah no, they don't
02:06:26 <maerwald> I guess I'll downgrade to 2.8 then
02:07:13 <maerwald> 2.8.2
02:23:23 <phadej> https://matrix.hackage.haskell.org/#/package/persistent
02:23:41 <phadej> the persistent-2.10.2 is broken, which probably causes problems down the road
02:24:10 <phadej> i.e. don't use persistent if you don't use stack ;)
02:24:25 <merijn> tbh
02:24:33 <merijn> just don't use persistent >.>
02:25:19 <phadej> (didn't I just said that ;)
02:25:24 <hekkaidekapus> That escalated quickly :)
02:27:11 <merijn> hekkaidekapus: I'd recommend just using SQL
02:27:41 <merijn> because you will inevitably want to and then you gotta be like me and keeping hacking persistent to make it work :)
02:28:02 <hekkaidekapus> Most of my relational stuff are SQLite, so I‚Äôm just enjoying the banter :p
02:28:26 <merijn>  hekkaidekapus: Mine's in SQLite too, which actually makes me want to use SQL specific stuff *more*
02:29:01 <hekkaidekapus> lol
02:30:02 <hekkaidekapus> Let‚Äôs not make an amalgamation :d
02:32:56 <merijn> hekkaidekapus: I use SQLite's ability to call arbitrary code from queries to efficiently aggregate results into Vector, it's great :>
02:34:11 <hekkaidekapus> merijn: Yeah, you will hear only praises from me on that angle :<
02:35:45 <hekkaidekapus> merijn: But I also know that you enjoy C, so I suspect there is more to the SQLite story for you :)
02:36:36 <kuribas> lol, merijn enjoying C...
02:37:12 <kuribas> @hoogle (Foldable t, Monoid m) => t a -> (a -> m) -> m
02:37:13 <lambdabot> Prelude foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m
02:37:13 <lambdabot> Data.Foldable foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m
02:37:13 <lambdabot> Data.Foldable foldMap' :: (Foldable t, Monoid m) => (a -> m) -> t a -> m
02:42:27 <merijn> C is terrible :p
02:43:04 <merijn> IIt's my curse, being good at stuff I hate :p
02:44:02 <hekkaidekapus> phadej: I have that Hackage‚Äôs matrix in the bookmarks, but I keep forgetting to use it instead of trying random builds. Bad citizen, carbon footprint wise.
02:47:35 <hekkaidekapus> maerwald, merijn: <https://matrix.hackage.haskell.org/#/package/persistent-template> The answer was one URL away.
02:53:24 <merijn> Does matrix have, like, an RSS feed for failures?
02:53:31 <merijn> That'd be pretty useful
02:54:33 <tomsmeding> who pays for the cpu time of that builder
02:54:54 <hekkaidekapus> merijn: I cannot see something like that. phadej, thoughts?
02:55:23 <hekkaidekapus> tomsmeding: Presumably, Hackage trustees.
02:56:02 <merijn> haskell.org probably?
02:56:06 <random> hey guys, does anyone know if you can attach custom error messages to hspec assertions?
02:56:26 <random> something like result `shouldBe` expected `withMessage` "Things aren't looking good"
02:56:53 <merijn> tomsmeding: There's a non-profit that pays for haskell.org infrastructure and there's also a bunch of stuff donated
02:57:20 <kuribas> what would be a good operator for `flip foldMap`?
02:57:32 <kuribas> to be used with Maybe
02:57:33 <merijn> like, I think the fastly CDN is donated as "in kind" charity?
02:57:51 <tomsmeding> cool :)
02:57:57 <kuribas> (&<>) = flip foldMap ?
02:59:00 <tomsmeding> `mapFold`
02:59:00 <kuribas> or (&->)
02:59:12 <kuribas> pamDlof? 
02:59:17 <tomsmeding> yes
03:00:08 * ski nods
03:00:09 <tomsmeding> wasn't there a discussion a while ago on this channel where people fantasised about a haskell variant where permuting the letters in a name of a function would permute its arguments
03:00:16 <tomsmeding> and I believe ski was in that discussion
03:00:21 <hekkaidekapus> random: There is a formatting module for hspec, see <https://hackage.haskell.org/package/hspec-core-2.7.4/docs/Test-Hspec-Core-Formatters.html>
03:00:35 <ski> i wasn't, but i was referenced in it
03:00:37 <random> hekkaidekapus: thanks! I'll check it out
03:01:06 <hekkaidekapus> np
03:23:32 <kuribas> @hoogle: Foldable t => t a -> Maybe a
03:23:32 <lambdabot> Maybe you meant: hoogle+ hoogle
03:23:39 <kuribas> @hoogle Foldable t => t a -> Maybe a
03:23:41 <lambdabot> Protolude head :: Foldable f => f a -> Maybe a
03:23:41 <lambdabot> Protolude.List head :: Foldable f => f a -> Maybe a
03:23:41 <lambdabot> HaskellWorks.Data.Foldable foldFirst :: Foldable t => t a -> Maybe a
03:24:11 <kuribas> :t foldMap Maybe
03:24:13 <lambdabot> error:
03:24:13 <lambdabot>     ‚Ä¢ Data constructor not in scope: Maybe :: a -> m
03:24:13 <lambdabot>     ‚Ä¢ Perhaps you meant variable ‚Äòmaybe‚Äô (imported from Data.Maybe)
03:24:20 <kuribas> :t foldMap Just
03:24:22 <lambdabot> (Foldable t, Semigroup a) => t a -> Maybe a
03:24:49 <kuribas> I want the first element...
03:25:19 * hackage uniqueness-periods-vector-examples 0.3.1.1 - Examples of usage for the uniqueness-periods-vector series of packages  https://hackage.haskell.org/package/uniqueness-periods-vector-examples-0.3.1.1 (OleksandrZhabenko)
03:25:42 <MarcelineVQ> first as in head or first that is Just?
03:28:14 <kuribas> MarcelineVQ: Just
03:28:23 <MarcelineVQ> asum then
03:28:47 <hekkaidekapus> > (const . Just) Nothing [1 .. 5] -- kuribas 
03:28:50 <lambdabot>  Just Nothing
03:29:00 <hekkaidekapus> > foldr (const . Just) Nothing [1 .. 5] -- kuribas 
03:29:02 <lambdabot>  Just 1
03:29:47 <kuribas> I have that...
03:29:57 <kuribas> but I was wondering if such a function doesn't exist
03:30:01 <kuribas> generalized listToMaybe
03:30:03 <kuribas> :t listToMaybe
03:30:05 <lambdabot> [a] -> Maybe a
03:30:28 <MarcelineVQ> listToMaybe  . toList   but  foldr (\x _ -> Just x) Nothing  isn't much longer
03:32:35 <kuribas> :t getFirst . foldMap First
03:32:36 <lambdabot> Foldable t => t (Maybe a) -> Maybe a
03:32:48 <kuribas> :t getFirst . foldMap (First . Just)
03:32:49 <lambdabot> Foldable t => t a -> Maybe a
03:35:01 <MarcelineVQ> I'd be writing asum over   getAlt . foldMap Alt
03:35:41 <kuribas> :t asum
03:35:43 <lambdabot> (Foldable t, Alternative f) => t (f a) -> f a
03:50:05 <olligobber> :t First
03:50:06 <lambdabot> Maybe a -> First a
03:51:24 <siraben> What happened to http://ircbrowse.net/browse/haskell?q=chrisdone ? Is there an alternative?
03:51:44 <merijn> No
03:51:45 <merijn> Sadly
03:51:49 <merijn> Or luckily
03:51:54 <merijn> My stats were depressing :p
03:52:07 <siraben> https://web.archive.org/web/20181004120200/http://ircbrowse.net/browse/haskell
03:52:10 <siraben> Internet archive seems to keep it
03:52:31 <merijn> Chris Done stopped maintaining a bunch of projects due to lack of time and RSI issues, iirc
03:55:59 <hekkaidekapus> merijn: RSI as in random strangers?
03:56:28 <merijn> ?
03:57:05 <hekkaidekapus> What is RSI?
03:57:13 <Taneb> Repetitive strain injury I presume
03:57:17 <merijn> repetitive strain injury
03:57:34 <hekkaidekapus> Thanks.
04:06:40 <hekkaidekapus> merijn: <https://mail.haskell.org/pipermail/libraries/2020-June/030625.html>
04:09:53 <merijn> hekkaidekapus: I didn't say he stopped maintaining everything. But there are some high profile projects he used to run that were shut down
04:10:01 <merijn> Most notably hpaste and ircbrowse
04:10:29 <hekkaidekapus> Yeah, I was chiming in on the RSI part.
04:15:28 <sm[m]> I guess it's a matter of time until someone revives ircbrowse, as the best/only #haskell-tailored/implemented channel log
04:16:00 <merijn> Doubt it
04:16:21 <merijn> It's been dead for what? like 2-3 years?
04:16:27 <sm[m]> I forgot about hpaste, maybe there's things for tomeding to salvage there
04:16:43 <sm[m]> so
04:17:06 <merijn> If someone was going to, why haven't they yet?
04:17:45 <sm[m]> it's not a likely event, but I think it'll probably happen eventually
04:19:09 <sm[m]> not likely in any given period but cumulatively likely
04:22:22 <sm[m]> because, MHO: ircbrowse was good, this channel is large, the project is not too large, logs are useful, irc and stats are fun, it's the only Haskell code base for this
04:26:25 * ski . o O ( "That is not dead which can eternal lie. .." )
04:27:11 <sm[m]> ski++
04:27:35 <sm[m]> maybe tomsmeding has some more cycles :)
04:30:20 <tomsmeding> what did ircbrowse offer above the log dump that is tunes.org
04:30:48 <merijn> tomsmeding: activity rankings, activity hours, search, tons of stuff really
04:31:14 * ski twitches
04:31:15 <merijn> lambdabot quotes that got stored of people
04:31:27 <merijn> The rankings being gone is probably for the best
04:31:34 <tomsmeding> the quotes are also hosted somewhere now right
04:31:36 <tomsmeding> yeah
04:31:51 <tomsmeding> "activity rankings" doesn't necessarily sound like a good idea to me :p
04:31:54 <merijn> I think me, Cale, and ski were top 5 for a consecutive year or something
04:32:12 <merijn> tomsmeding: I meant that it's good because it means no one can tell how much time I waste here :p
04:32:12 <ski> hm, i was ?
04:32:28 * ski doesn't recall looking at the rankings much
04:33:36 <Cale> I remember looking at ircbrowse's clock graph of what times I was awake, and for most people it was pretty clear when they went to sleep, and then mine was just a very slightly off-centre circle
04:33:51 <sm[m]> a nice memorable url.. per comment permalinks ?
04:34:15 <ski> hehe, Cale :)
04:34:39 <sm[m]> Evolvability, responsiveness to #haskell's needs/whims
04:35:05 <merijn> Cale: ;)
04:35:09 * ski memorized the <tunes.org> link, long ago
04:35:45 * tomsmeding notes to ski that it's in the irc topic
04:36:17 <ski> hm, might not always have been ? i don't look at it often
04:36:20 <sm[m]> linkable conversations was the big feature really. It was used a fair bit
04:36:57 <merijn> yeah, meant I didn't have to explain things, just remember that I had explained them in the past :p
04:37:33 <sm[m]> lonkable and searchable
04:37:49 <tomsmeding> I like lonking things
04:38:27 * ski tends to prefer explaining things, than linking to explanations
04:38:33 <ski> (at least for some things)
04:39:07 * hekkaidekapus admires ski‚Äôs patience when explaining things.
04:39:08 <ski> (also means i can attempt to sharpen my explanations)
04:41:34 <hekkaidekapus> ski: That foggy idea of type-level graphs that you managed to transform into programming with existentials, over extended chats and days, was epic!
04:42:01 <merijn> ski: Yeah, but after explaining it 10 times it gets boring :p
04:43:21 <ski> merijn : i guess sometimes it can be, to some extent. but different people may stumble on different things, or possibly require different ways to understand
04:43:55 <ski> hekkaidekapus : hm, atm i don't recall type-level graphs. mind reminding me what that was about ?
04:44:27 <hekkaidekapus> ski: Or was it type-level heterogenous lists?
04:44:40 <hekkaidekapus> I didn‚Äôt follow closely.
04:44:59 <hekkaidekapus> I gave it away: ‚Äúfoggish‚Äù‚Ä¶
04:45:14 <ski> oh, that
04:45:50 <hekkaidekapus> Yeah, lol! Anyone else would have lost their patience.
04:46:36 <ski> (i don't really recall it transforming into existentials, but i have a foggy memory of me mentioning existentials, at some point, going a little bit into it)
04:47:06 <ski> anyway, i'm not too fond of `HList'-style stuff
04:47:11 <hekkaidekapus> I have an even foggier memory.
04:47:42 <hekkaidekapus> I think it turned into OOP or something.
04:47:58 <ski> maybe. it's related
05:31:20 * hackage ghcide 0.4.0 - The core of an IDE  https://hackage.haskell.org/package/ghcide-0.4.0 (PepeIborra)
05:32:12 <maerwald> if you're running `forM list` and afterwards you're doing `last list`... will it traverse twice or is there a chance sharing kicks in?
05:34:34 <opqdonut> I think getting that right would need "deep" CSE, and GHC does no CSE at all AIUI
05:35:12 <merijn> GHC does do some CSE
05:35:22 <merijn> Not very aggressively, though
05:35:35 <opqdonut> I'm probably way out of date with GHC optimizations...
05:47:19 <tomsmeding> http://ircbrowse.tomsmeding.com/
05:47:37 <tomsmeding> how do I supply it with data
05:52:43 <maerwald> merijn: so I guess better not rely on it?
05:53:14 <Cale> tomsmeding: I have no idea, but I'm glad you're putting this back online :)
05:53:55 <maerwald> and I'm wondering... even if it does share... this might force the entire list into memory, while before it *might* be GCed earlier?
05:54:12 <int-e> there is http://tunes.org/~nef/logs/haskell/
05:54:26 * tomsmeding will be busy for a few hours now though, will be back later
05:54:34 <tomsmeding> yes perhaps periodically pull from tunes.org
05:55:29 <int-e> Ah, the topic does mention it... I missed it when I looked 5 minutes ago.
05:57:08 <int-e> the usual approach to this involves an IRC bot; for example, clog is responsible for collecting the tunes.org ones.
05:59:23 <faker> I need help, how do a function that counts how many digits of any number
05:59:52 <oats> faker: you could convert it to a string and take its length
06:01:49 <faker> i cannot use length xD, I need to divide successively by 10
06:03:02 <oats> it sounds like you're on the right track then!
06:03:07 <oats> is this homework?
06:05:51 <faker> yes, but i have been for a long time in this exercise
06:06:08 <oats> what have you tried so far?
06:08:57 <faker> i dont know how to divide successively by 10 in haskell
06:09:54 <hyperisco> how many times do you want to divide by 10
06:13:02 <kuribas> > 4 / 10 / 10 / 10 / 10 / 10 -- faker
06:13:04 <lambdabot>  4.0e-5
06:13:20 <faker> do a function that counts how many digits of any number
06:13:47 <hyperisco> is this homework?
06:14:00 <ski> <faker> yes, but i have been for a long time in this exercise
06:14:06 <sm[m]> https://github.com/yesodweb/persistent/issues/1101 is the persistent-template issue btw. Broken for four months
06:14:22 <hyperisco> okay, can you show us your work so far?
06:14:59 <sm[m]> (shouldn't no-ip on the matrix builder be some shade of red ?)
06:15:14 <merijn> sm[m]: Why?
06:15:40 <sm[m]> green makes it look like everything's fine. Usually an uninstallable package on hackage is not what's wanted
06:16:32 <merijn> No install plan is fine in the sense that is "specified not to work"
06:16:52 <sm[m]> of course you can say that, but is it useful ?
06:16:57 <merijn> sm[m]: Else package not supporting old GHCs get all sorts of red from not saying it
06:16:59 <ezzieyguywuf> is doing something like this atypical, or "anti-pattern" in haskell? https://dpaste.com/8B5KRWKT2
06:17:25 <merijn> sm[m]: I deliberately don't support old GHCs and make sure the bounds don't resolve for the unsupported ones
06:17:39 <hyperisco> ezzieyguywuf, what is being done? I see some data declarations
06:17:46 <merijn> So for me "no install plan" for those is a success
06:18:07 <sm[m]> I understand
06:18:35 <sm[m]> how about a non-red, non-green shade ? grey ?
06:18:45 <ezzieyguywuf> hyperisco: so MyData is "built up" by combining some of the other data types
06:18:49 <merijn> sm[m]: Marking "no install plan" as a failure implies that it's intended that people support basically every possible configuration. Whereas matrix plan is currently checking "do all the explicitly supported configurations work?"
06:19:20 <ezzieyguywuf> that's the question - is this typical, or is it cleaner to just keep defining different MyData values?
06:19:37 <merijn> ezzieyguywuf: "It Depends (TM)"
06:19:53 <faker> hyperisco: conta_digitos :: Int -> Int 
06:20:05 <hyperisco> ezzieyguywuf, a good way to understand the efficacy of data is through the operations on the data
06:20:56 <sm[m]> merijn, hence my new suggestion of a non-red colour
06:21:19 <ezzieyguywuf> hyperisco: in other words "if you can use it effectively, it's probably aight"?
06:21:52 <hyperisco> ezzieyguywuf, I think so
06:21:53 <jr> hi guys
06:22:16 <merijn> sm[m]: grey is currently already listed as "unknown failure", I suppose you could use some other colour, but that seems to have rather limited utility?
06:22:55 <sm[m]> the point is that persistent-template is broken and it looks green on matrix builder, which is poor UX.
06:23:53 <sm[m]> anyway, just throwing it out there
06:24:01 <hyperisco> faker, have you made a recursive function before?
06:25:14 <faker> hyperisco: yes xD
06:25:16 <sm[m]> (and you're right, grey is taken)
06:26:28 <hyperisco> faker, okay, then I feel like you should be able to do more work than just the type declaration
06:26:40 <ezzieyguywuf> hyperisco: thanks for the thoughts
06:27:12 <sm[m]> perhaps matrix builder should distinguish between no install plan for GHCs disallowed by bounds, or by tested-with ?
06:27:35 <sm[m]> ..and no install plan for current/supported GHCs
06:28:46 <hyperisco> I mean type signature
06:28:52 <hyperisco> just looked that up on the report xD
06:28:54 <merijn> tested-with doesn't really have any meaning, though
06:29:18 <merijn> I mean, for humans it does, but it has no associated semantics
06:29:45 <ski> faker : can you describe in words how you're planning for `conta_digitos' to work ?
06:30:29 <sm[m]> merijn: ok, what do you think about the general idea though ? Two kinds of no-install-plan failure: one for GHCs allowed by the base bound, and another for GHCs disallowed by the base bound
06:31:08 <ski> faker : or maybe you have written some code for `conta_digitos', that's a start ?
06:31:31 <merijn> I don't have a particularly strong opinion either way
06:32:47 <sm[m]> ok. You didn't shoot it down so I'll call it a not-stupid idea :)
06:35:06 <merijn> Then you'll get blamed for other packages not supporting things, though :p
06:35:54 <merijn> like, you depend on package A, which restricts GHC to <= 8.8, but you relaxed base to support 8.10, now you've got a "failing" no install plan
06:36:06 <merijn> Which is only solvable upstream
06:38:53 <sm[m]> hmm yes, but I think that would be ok. Once A lifts the restriction matrix will look happy again. If it's never going to, you can set the same bound on your package and matrix will look happy again
06:41:04 <merijn> I don't like the idea of needlessly restricting *your* bounds because a transitive dependency doesn't support them yet
06:41:24 <merijn> sm[m]: Then you're effectively back to a more labour intensive version of stack snapshots
06:41:34 <merijn> Where you only support very specific versions
06:42:13 <sm[m]> you don't have to restrict them. If you think A will update some day, you can tolerate the "wrong" shade in one cell on matrix builder
06:42:22 <sm[m]> it'll be tough, but you could do it
06:42:57 <merijn> sm[m]: The problem is not if *you* can tolerate it. The problem is: how many users will badger you about it being broken?
06:43:01 <sm[m]> and overall, the matrix info would be more useful as a result. Just MHO
06:43:16 <sm[m]> zero
06:43:22 <sm[m]> I'll drop this now :)
06:44:00 <merijn> sm[m]: I'm not convinced that's true, though and I'm tentatively against anything that encourages "user entitlement" when it comes to open source :)
06:53:27 <dminuoso> ezzieyguywuf: I find myself constantly debating how to model data. The less abstract/formal/library or more business logic you get, the harder this gets. At times, it feels like one of the more time consuming tasks surprisingly.
06:54:50 <dminuoso> ezzieyguywuf: Either way, if you have data types with just one field, chances are you want a newtype instead. :)
06:55:12 <dminuoso> (Unless you really want the boxing semantics for lazyness)
06:55:54 <ezzieyguywuf> dminuoso: yes, thought about changing that in the example.
06:56:07 <ezzieyguywuf> dminuoso: also, thansk for your thoughts, this actually helps, at least it's not just me :P
06:56:39 <dminuoso> ezzieyguywuf: In one of my projects, I have very deeply nested types - this can be fine, but it takes something like `lens` or `optics` to work with sensibly.
06:56:58 <dminuoso> Using that, you can have sort of row polymorphism
06:57:30 <dminuoso> (keyword classy lenses)
06:57:54 <ezzieyguywuf> I've been avoiding lens so far
07:05:08 <faker> ski : i write a number and i have the number of digits 
07:07:29 <ski> faker : yes, but how are you going to accomplish that ? what's your algorithm (e.g. in english words) for that ?
07:37:49 * hackage zip 1.6.0 - Operations on zip archives  https://hackage.haskell.org/package/zip-1.6.0 (mrkkrp)
08:02:50 * hackage indigo 0.2.2 - Convenient imperative eDSL over Lorentz.  https://hackage.haskell.org/package/indigo-0.2.2 (rinn7e)
08:39:26 <sm[m]> Nice reference article about helping on irc, from #python: https://news.ycombinator.com/item?id=24467731
08:43:58 <ezzieyguywuf> sm[m]: nice article. what's wrong with python pickles though?
08:44:16 <ezzieyguywuf> in fact, a lot of the things mentioned in the article are things I've found generally helpful in the professional workplace as well
08:44:29 <sm[m]> they're fragile, I expect ?
08:45:02 <ezzieyguywuf> shrug
08:45:32 <sshine> like PatternSynonyms, is there a way to get value constructor synonyms?
08:47:06 <sshine> ah, PatternSynonyms does give me that. I just didn't import the right module. d'oh. :)
08:49:22 <ezzieyguywuf> does hledger handle securities as well as (or better?!) than beancount?
08:51:17 <tomsmeding> Cale: http://ircbrowse.tomsmeding.com/browse/haskell
08:51:41 <tomsmeding> haven't imported old stuff yet, but apparently ircbrowse has built-in support for reading znc logs, and I happen to know how znc works :)
08:51:47 <sm[m]> ezzieyguywuf: I believe beancount has a few more advanced features eg for automatically reporting gains but I'm not quite sure of the actual features and their usability
08:51:52 <tomsmeding> the bot is ircbrowse_tom 
08:53:49 * hackage ghc-lib-parser 8.10.2.20200916 - The GHC API, decoupled from GHC versions  https://hackage.haskell.org/package/ghc-lib-parser-8.10.2.20200916 (shayne_fletcher)
08:54:49 * hackage ghc-lib 8.10.2.20200916 - The GHC API, decoupled from GHC versions  https://hackage.haskell.org/package/ghc-lib-8.10.2.20200916 (shayne_fletcher)
08:55:41 <sm[m]> ezzieyguywuf: I have some newer tips than what's on the website, if needed
08:56:41 <ezzieyguywuf> sm[m]: which website?! lol
08:57:11 <Cale> tomsmeding: nice! There also used to be fun stats pages as I recall, but I forget how to get to them.
08:57:19 <tomsmeding> ¬Ø\_(„ÉÑ)_/¬Ø
08:57:21 <sm[m]> sorry, speaking about hledger now
08:57:23 <tomsmeding> I just cloned it from the github page
08:57:34 <tomsmeding> perhaps there was development locally?
08:58:14 <Cale> Ah, clicking on a nick takes you to a route for that nick
08:58:18 <ezzieyguywuf> sm[m]: ah, ok. yea I haven't actually started converting my journal to hledger or anything, just an idle thought
08:58:25 <Cale> but it seems to redirect back to the top level list for some reason
09:00:10 <ezzieyguywuf> üòç I'm watching this video, I think I miht switch to xmonad from i3 https://youtu.be/3noK4GTmyMw
09:00:42 <tomsmeding> Cale: perhaps there is some reliance left on being on the old ircbrowse.net domain, I'll see if I can find anything
09:07:19 * hackage ghc-lib-parser 8.10.1.20200916 - The GHC API, decoupled from GHC versions  https://hackage.haskell.org/package/ghc-lib-parser-8.10.1.20200916 (shayne_fletcher)
09:08:19 * hackage ghc-lib 8.10.1.20200916 - The GHC API, decoupled from GHC versions  https://hackage.haskell.org/package/ghc-lib-8.10.1.20200916 (shayne_fletcher)
09:12:34 <tomsmeding> Cale: clicking on a nick now takes you somewhere
09:12:42 <tomsmeding> not sure how to update that data though
09:37:51 <Guest_88> Hello?
09:38:22 <geekosaur> hello
09:38:46 <Guest_88> is there anyone who could help me with ghc installation on macos?
09:41:37 <sm[m]> sure Guest_88, what problem are you having
09:59:52 <maerwald> well, the tension is unbearable now
10:05:10 <Guest_88> sm[m] I'm trying to install ghc8.8 on my system using brew, but for some reason i cant seem to be able to link it so i can use it in shell. ghc 8.10 is already present on the system and im currently using it
10:05:42 <sm[m]> what reason does brew give ?
10:06:43 <Guest_88> that 8.8 is keg only and i need to link it using --force
10:07:38 <sm[m]> I see.. not that you already have some files in the way ?
10:09:16 <Guest_88> Warning: ghc@8.8 is keg-only and must be linked with --forceIf you need to have this software first in your PATH instead consider running:
10:09:29 <Guest_88> and there is a command for PATH then
10:09:43 <Guest_88> but i tried running it, nothing happens
10:10:22 <sm[m]> are you doing brew install ghc@8.8 ? And you also have done brew install ghc to get 8.10 ?
10:10:48 <Guest_88> yes
10:10:51 <Guest_88> to both questions
10:11:54 <sm[m]> I think that's going to be inconvenient, brew assumes only one ghc in PATH at a time. You'd have to rename one or something. Have you considered installing versioned ghcs with stack or ghcup ?
10:12:16 <sm[m]> it's just an idea, not necessarily advice
10:12:52 <Guest_88> tried ghcup
10:14:06 <Guest_88> but it didnt install correctly for some reason
10:14:24 <maerwald> Guest_88: in what sense
10:14:29 <sm[m]> let me introduce you to my colleague maerwald :)
10:14:47 <Guest_88> when tried to check ghc --version or ghci, it said that some directories are not present
10:15:07 <maerwald> Guest_88: did you add ~/.ghcup/bin to your PATH?
10:15:29 <maerwald> you seem to have various ghcs floating around
10:15:38 <maerwald> so it's not clear which you ran
10:15:46 <Guest_88> yes, exactly
10:16:09 <Guest_88> and when i installed with brew and linked it, everything went into places, but now im stuck with 8.10
10:16:20 <maerwald> ~/.ghcup/bin/ghci should work
10:17:08 <sm[m]> and remove or unlink all the brew ghcs ?
10:17:27 <Guest_88> to the question earlier, did i add path - yes, i think so, when ghcup installation prompted me to add it, i answered Yes
10:17:36 <maerwald> that doesn't mean it worked
10:17:48 <Guest_88> oh wow
10:17:53 <Guest_88> that command worked
10:18:02 <Guest_88> im using 8.8
10:18:22 <Guest_88> but now how do i set it as default or something
10:18:31 <maerwald> Guest_88: what worked?
10:18:43 <Guest_88> ~/.ghcup/bin/ghci
10:18:51 <maerwald> what shell are you running?
10:19:33 <Guest_88> bash? is that what you are asking
10:19:45 <yushyin> echo $SHELL
10:20:03 <maerwald> add "[[ -f ~/.bashrc ]] && source ~/.bashrc" to ~/.bash_profile and "source ~/.ghcup/env" to ~/.bashrc
10:20:14 <maerwald> then open a new shell
10:21:11 <Guest_88> am i doing something wrong, or add isnt a command?
10:21:31 <maerwald> add is english language here
10:21:32 <geekosaur> add is an instruction to you,, not a shell command
10:21:41 <Guest_88> :DD
10:28:11 <monochrom> Wait, when did https://discourse.haskell.org/ happen?!
10:28:13 <Guest_88> nevermind, managed to link it with brew properly
10:28:17 <Guest_88> thank you guys 
10:28:45 <geekosaur> there was a discussion about it maybe a half a year back on -cafe, iirc
10:29:27 <geekosaur> or a year back maybe
10:31:14 <sm[m]> Guest_88: np
11:20:49 * hackage autoexporter 1.1.19 - Automatically re-export modules.  https://hackage.haskell.org/package/autoexporter-1.1.19 (fozworth)
11:31:23 <tomsmeding> merijn: sm[m]: http://ircbrowse.tomsmeding.com/browse/haskell works? kind of?
11:31:49 <tomsmeding> the codebase had some weirdness in that certain things were disabled or didn't really work; I guess the previous hoster had some uncommitted changes
11:32:04 <tomsmeding> I'm currently auto-updating the info every hour
11:32:42 <tomsmeding> if there's anything that you expect to work from past experience but that does not work now, please tell
11:34:15 <sm[m]> it lives again! great work tomsmeding 
11:34:48 <sm[m]> maybe update the source link
11:45:42 <tomsmeding> working on the footer :)
11:45:56 <tomsmeding> also there were lots of header tabs that were commented out, having a look at those
11:47:46 <tomsmeding> footer has been fixed, and the header links seem to work sm[m] 
11:48:06 * tomsmeding wonders why that stuff was commented out? was it disabled explicitly at some point?
11:51:51 <sm[m]> tomsmeding++
11:52:56 <sm[m]> woohoo, now a chance to fix some things that always bugged me, like the page size selector  :)
11:53:21 <tomsmeding> lol
11:53:28 <tomsmeding> there's literally a list of page sizes
11:53:35 <tomsmeding> so changing that is trivial
11:54:54 * sm[m] tries to decipher the timestamps
11:58:20 <sm[m]> I think the timezone is 2 or 3 hours off
12:00:08 <sm[m]> I think it used to update quite often, which could be handy when you got disconnected or didn't trust your chat client
12:06:12 <tomsmeding> ah right server is in UTC but receives stuff from the irc server in GMT+2 which is the timezone where the server is located
12:07:11 <tomsmeding> interesting that it does show shifted-correct timestamps for you, who are nowhere near europe in terms of timezones
12:07:35 <tomsmeding> does ircbrowse actively adjust timestamps according to the timezone of the client browser?
12:09:21 <tomsmeding> oh right I didn't realise it's lazy and just writes +0000
12:10:35 <geekosaur> fwiw I show 2 hours forward from my current timezone (UTC-4) which suggests UTC-2
12:10:52 <geekosaur> that is, something timestamped 14:57 locally is 16:57 in ircbrowse
12:14:32 <sm[m]> does anyone know a way to copy the current file path and/or line number in vs code ?
12:15:25 <sm[m]> tomsmeding: I'm looking at upstream/snap-app/src/Snap/App/Controller.hs:91 and wondering if that's where the default page size of 35 comes from
12:16:14 <sm[m]> and what happens if the page sizes at Controllers.hs:147 don't include that number
12:16:29 <sm[m]> I'd test, but the build plan looks too hairy right now
12:16:35 <tomsmeding> geekosaur: my brain is operating at reduced capacity; for me ircbrowse reports everything in UTC, but two hours earlier than the event actually happened; is that consistent with what you see?
12:16:48 <tomsmeding> building is actually no harder than 'stack build'
12:16:58 <tomsmeding> well, and waiting
12:17:16 <sm[m]> that's hard when it's lts-3 and you have a mac with no spare disk space :)
12:17:18 <geekosaur> it claims +0000 but 2 hours ahead of me or 2 hours behind UTC
12:18:05 <geekosaur> >> that is, something timestamped 14:57 locally is 16:57 in ircbrowse
12:18:32 <geekosaur> 14:57 being UTC-4, EDT
12:20:32 <sm[m]> tomsmeding: you and your "trivial" again :)
12:20:41 <Graypup_> hi! My yesod-auth logout route doesn't work
12:20:42 * sm[m] isn't finding it all that trivial
12:20:48 <Graypup_> like, it doesn't seem to unset the session variables at all?
12:21:35 <tomsmeding> geekosaur: yeah it sounds like my analysis was correct then
12:22:20 <tomsmeding> sm[m]: src/Ircbrowse/Controllers.hs:147
12:22:29 <geekosaur> thought you said UTC+2, not UTC-2
12:22:43 <tomsmeding> yeah but ircbrowse is double-compensating
12:22:45 <Graypup_> I googled around and it's not caused by a favicon route based on my looking at the network tab in devtools
12:22:53 <tomsmeding> it's receiving irc timestamps in gmt+2 from znc, but assuming they're utc
12:23:03 <tomsmeding> I think
12:23:30 <tomsmeding> interesting, I changed the server timezone to gmt+2 but the problem hasn't gone away
12:23:31 <Graypup_> it's still sending an entire session cookie back after logout
12:23:32 <Graypup_> which, wat
12:25:33 <tomsmeding> lol what on earth the thing is in America/Los_Angeles
12:26:01 <merijn> A timezone
12:26:39 <merijn> Specifically, the only correct way to specify a timezone for events in the future
12:27:06 <tomsmeding> I know what that is :p
12:27:06 <monochrom> The first city that aliens/monsters hits, according to Hollywood movies.
12:27:33 <merijn> monochrom: I thought that was Washington DC?
12:27:34 <tomsmeding> I was more asking myself how it can be that 1. ircbrowse is in US time, and 2. the timestamps are only 2 hours off
12:27:58 <monochrom> And it's Tokyo instead according to Japanese movies :)
12:28:06 <int-e> merijn: But LA is closer to Hollywood.
12:28:23 <monochrom> Yeah there are a couple of exceptions.
12:28:34 <int-e> Maximum elevation 93m... I guess it'll be there for a while longer.
12:29:08 <geekosaur> until the next earthquake, at least
12:29:14 <monochrom> haha
12:29:29 <int-e> But there are more future-proof timezones.
12:29:50 <merijn> I wasn't refering to the specific timezone
12:29:56 <merijn> I was refering to the timezone format
12:30:28 <monochrom> Oceania/AirStrip1
12:30:39 <int-e> merijn: that's too much context for me
12:30:59 <monochrom> Oh wait, snake case. Oceania/Air_Strip_1
12:31:37 <merijn> My pet peeve is people storing future date/times in UTC offsets or UTC
12:31:38 * monochrom suddenly realizes the real reason the 3 supernations were at perpetual war!
12:34:08 <int-e> Hmm did they each want their own 0 meridian?
12:34:51 <monochrom> Nah. It's a case war. They're fight over AirStrip1 vs Air_Strip_1 vs Air-Strip-1
12:35:03 * geekosaur figured
12:35:29 <xerox_> camel snake case
12:37:42 <tomsmeding> oh that Los_Angeles timezone was for clog parsing >.>
12:42:35 <rustisafungus> so what is a type, and is there any practical phenomenon which creates a reasonable upper bound on the number of distinct types, or which limits the "growth" of types?
12:44:19 <tomsmeding> sm[m]: geekosaur: I believe the timezone setting of ircbrowse is correct now
12:45:33 <geekosaur> looks right to me, yes
12:45:34 <Cale> rustisafungus: One way to think about them is that types are properties of programs for which the program itself can be interpreted as a proof.
12:46:14 <Cale> rustisafungus: (and checked by a machine)
12:47:36 <rustisafungus> this question will make you laugh, but is there any way to think about the question of "how many types are there?"
12:47:49 * hackage lti13 0.1.2.0 - Core functionality for LTI 1.3.  https://hackage.haskell.org/package/lti13-0.1.2.0 (jade)
12:48:01 <dolio> Infinitely many.
12:48:02 <Cale> I mean, unless the answer is 1, usually it's infinitely many.
12:48:16 <sm[m]> tomsmeding: what would you think about hiding all the connect/disconnects
12:48:21 <Cale> It obviously depends on which type system we're talking about
12:48:26 <tomsmeding> sm[m]: yes
12:48:44 <tomsmeding> will require some finicking with the pagination though
12:48:47 <Cale> It's like asking how many mathematical statements there are
12:48:47 <rustisafungus> right but that's a boring answer. for example we could say that there are infinitely many physical units, when in fact there are just a few fundamental physical units from which all physical units are derived using simple operations
12:48:49 <monochrom> "what is" questions are usually not worth answering.
12:48:49 * hackage yesod-auth-lti13 0.1.2.0 - A yesod-auth plugin for LTI 1.3  https://hackage.haskell.org/package/yesod-auth-lti13-0.1.2.0 (jade)
12:49:28 <monochrom> "how many types" is also a useless question in the first place.
12:49:54 <rustisafungus> i don't agree, because Cale's answer says that if your program has more types, then it has more proven constraints imposed/checked by the compiler
12:50:04 <monochrom> "what are the rules of making type expressions" is a much more useful question. Now it reveals structure.
12:50:10 <Cale> If the answer were not infinity and were instead 100 billion, what would you do with that information?
12:51:28 <geekosaur> rustisafungus, you can meaningfully ask how many types a given program makes use of, but less so how many types there are globally
12:51:36 <monochrom> Likewise, "how many binary trees?" "infinitely many" is useless.  "how to define/generate binary trees by structural induction" is the useful one.
12:52:38 <monochrom> We can also set up pathological type systems in which infinitely many types express no invariant at all so the counterpoint is moot.
12:52:44 <rustisafungus> so is there a small collection of laws for defining "all possible" types?
12:53:07 <Cale> In essentially any practical type system, yeah
12:53:37 <rustisafungus> right but i am thinking in the sense of the fact that there was a one page probabilistic proof of fermat's last theorem while the mathematicians took forever to produce a lengthy and incomprehensible proof,... that is to say i am fine with heuristic/empirical/semi-empirical arguments
12:53:50 <rustisafungus> Cale: so where do i find those laws?
12:54:00 <Cale> For which type theory?
12:54:14 <rustisafungus> i don't know,... i don't even know what a type theory is or what distinguishes one from another
12:55:00 <geekosaur> maybe that's the wrong angle. start with standard Haskell ADTs
12:55:24 <Cale> Yeah, I guess I should make sure you're not just asking about Haskell
12:55:45 <rustisafungus> no i am asking more broadly
12:55:46 <geekosaur> where your type theory is the one chosen by the language designer, since most users won't be that interested in that particular level of detail
12:55:56 <dolio> Algebraic types are already a schema for infinitely many acceptable definitions, though.
12:56:02 <monochrom> I'll now refer you to two big volumes, "types and programming languages" and "practical foundations for programming languages".  Pick one of them and study.  I won't answer further questions until you have finished at least one.  Your current questions and I bet the next 70 ones are all answered there.
12:56:02 <Cale> But a good book recommendation might be "Types and Programming Languages" by Benjamin Pierce
12:59:12 <Cale> https://github.com/MPRI/M2-4-2/blob/master/Types%20and%20Programming%20Languages.pdf -- apparently it's just on github now
12:59:22 <rustisafungus> yeah i was trying to find it :-P thanks
12:59:26 <Cale> (this is probably not official)
13:02:13 <monochrom> Now I'm at a moral crossroad of "should I keep a copy?"
13:02:59 <Cale> rustisafungus: There are programming languages like Coq and Agda whose types can encode all the statements of mathematics, and whose programs can literally be regarded as proofs of those statements, and where the fundamental building blocks of expressions correspond directly with logical rules.
13:04:50 <Cale> I own a paper copy, but it's nice to have the PDF :P
13:04:59 <monochrom> Yeah that's fair.
13:05:56 <Cale> Apparently it's just been sitting there for 5 years as well, and that repo is linked with Xavier Leroy's course... so maybe nobody has any issue with it
13:07:50 * hackage lti13 0.1.2.1 - Core functionality for LTI 1.3.  https://hackage.haskell.org/package/lti13-0.1.2.1 (jade)
13:08:50 * hackage yesod-auth-lti13 0.1.2.1 - A yesod-auth plugin for LTI 1.3  https://hackage.haskell.org/package/yesod-auth-lti13-0.1.2.1 (jade)
13:11:04 <lc_> bro
13:11:07 <lc_> type classes are just interfaces
13:11:31 <lc_> what's with the fancy name
13:11:40 <Graypup_> i mean kinda but you can't get `this` in them afaik
13:11:57 <monochrom> I agree. We don't need the fancy name "interface".
13:12:37 <Graypup_> trying to get my hackage docs to build on their antique ghc863
13:12:41 <monochrom> "interfaces" are just type classes.
13:13:44 <lc_> I can't believe I didnt realize this before
13:14:30 <sm[m]> aren't they also what some languages call "traits"
13:14:35 <Graypup_> ........ where's ghc883 and other versions with working `text` package? https://i.imgur.com/Iz58tKy.png
13:14:39 <Graypup_> the heck hackage
13:15:08 <Graypup_> sm[m], a trait, at least in rust, is quite different from an interface because you can implement it on someone else's type
13:15:52 <Graypup_> so you can put extensions on standard library types, containers, etc by making a trait and impl'ing it for them
13:16:21 <rustisafungus> so i read the first chapter of pierce and barely glanced at the second and third
13:16:41 <dolio> That doesn't seem like the agreement.
13:17:20 <rustisafungus> do i understand correctly that he is saying that a type system is essentially a usable *but inferior* way of proving properties of a program?
13:18:38 <hyperisco> lc_, good troll
13:19:24 <lc_> literally not trolling
13:19:29 <lc_> they're literally just interfaces
13:19:40 <Graypup_> ..... what the heck hackage https://hackage.haskell.org/upload the script here doesn't find the docs for the /other/ package it *just* built
13:20:37 <sm[m]> Graypup_: isn't that something we can also do with haskell typeclasses
13:20:49 <hyperisco> rustisafungus, don't know where you've got on this, but there are as many types as there are naturals, usually
13:21:00 <Graypup_> sm[m], yes, but not with interfaces
13:21:29 <Graypup_> also there's some higher kinded types stuff that traits in rust don't do
13:21:46 <Graypup_> you couldn't have a trait Monad I don't think but I don't know why
13:21:50 <hyperisco> rustisafungus, which is why in some type theory papers the discussion just orients around Nat
13:22:25 <tomsmeding> lc_: in Haskell, as a user of a library that defines a particular type T, you can define new class C and make T and instance of that class C
13:22:30 * sm[m] persists in the belief that typeclass/interface/trait are more or less synonyms, then
13:22:46 <rustisafungus> hyperisco: sounds nice at some fundamental level, but if i ingest code from github and apply some kind of rule which can identify "identical types" and then another rule which can identify "simple rearrangements/compositions/etc of previously encountered types" then i might see a slowing or tapering off of encountering of new types as i ingest more kilobytes of say, haskell
13:22:52 <sm[m]> uh, except interface doesn't have implementation, my bad
13:23:03 <tomsmeding> how would you do that in, e.g., Java/C++ or Go, which I think is the class of languages where "interface" means something
13:23:17 <hyperisco> rustisafungus, at what level are you looking for an answer?
13:23:38 <Graypup_> interface /can/ have implementation as of java 8 iirc
13:23:47 <Graypup_> (default implementation)
13:23:54 <rustisafungus> something a mortal amateur like me can understand
13:23:58 <Graypup_> which allows for a gross misuse of them to produce multiple inheritance lololol
13:24:00 <lc_> You define an interface with a certain set of internal methods. Then other library users define their own implemmentations of that interface by filling in the method descriptions
13:24:04 <dolio> 'As many types as there are naturals' is kind of a dubious answer.
13:24:16 <lc_> You dont need multiple inheritance or anything. Go has this. Every language has this
13:24:23 <hyperisco> lc_, I can't count how many times this discussion has occurred on this channel. They're significantly not the same, assuming we're saying "interface" as in Java or something
13:24:45 <Graypup_> interface is a distinctly OO thing for sure
13:25:10 <lc_> https://golang.org/pkg/io/#Reader
13:25:19 <lc_> ^ example of type class
13:25:31 <hyperisco> there are few languages that have type classes
13:25:45 <hyperisco> in fact I know of only 2, but there are likely more, and those would be Haskell and PureScript
13:26:04 <tomsmeding> lc_: I'm not _terribly_ familiar with Go; suppose I define a new Go interface, say CoolReader, that requires a method CoolRead()
13:26:16 <tomsmeding> and I want to implement that for some standard library type, say Stdin
13:26:20 <tomsmeding> can I do that?
13:26:27 <lc_> yes
13:27:37 <tomsmeding> so to be clear, Go's interfaces are _not_ the same thing as C++/Java interfaces
13:27:39 <hyperisco> or are you using my favourite approach where you just say something to provoke responses :P
13:28:04 <lc_> All an interface is is a description of methods an object must support to be called "interface_name". So any struct you make which has those methods w/ those types, you can use and call "interface_name", and pass it into e.g. other outside libraries, etc.
13:28:07 <ski> hyperisco : Clean,Mercury
13:28:46 <hyperisco> well now I know of 4
13:29:00 <tomsmeding> lc_: a difference between Go interfaces and Haskell type classes is that in Go, a type automatically satisfies an interface if it has the required methods, whereas in Haskell you need to explicitly make the type a member
13:29:00 <Graypup_> go interfaces are kinda like c++ concepts sorta: you don't have to say your type implements them, you implement them and then you have functions that can take things with that interface
13:29:09 <Graypup_> lol we both said the same thing
13:29:12 <tomsmeding> Graypup_: yup
13:29:24 <hyperisco> this is like saying oh, parametric polymorphism is just templates
13:29:54 <tomsmeding> well, c++ templates with c++20 concepts get somewhere in the right direction
13:30:12 <tomsmeding> though it's a more bloated and idiosyncratic version :)
13:30:17 <lc_> Hyperisco if you know something interfaces cant do that typeclasses can, tell me then
13:30:17 <ski> lc_ : the "object" part in your description isn't there, for type classes
13:30:19 <hyperisco> minus the whole "parametric" part
13:30:38 <hyperisco> lc_, an interface is a type, a type class is not a type, for one
13:31:14 <Graypup_> a type class can be used as a constraint but it is not a type
13:31:44 <tomsmeding> hyperisco: a Go interface is not a type
13:32:05 <tomsmeding> at least
13:32:08 <hyperisco> okay, I was referring to Java-like interfaces, and I don't know Go, but we can go on to other differences as soon as I know what a Go interface is
13:32:21 <tomsmeding> lc_: can you write a method that takes a particular type T that must be both Read and Write?
13:32:38 <tomsmeding> hyperisco: a Go interface is approximately a C++ concept :)
13:32:42 <Graypup_> a go interface (as a non go programmer so boulder of salt etc) is a set of methods that you are saying a type has, and you accept things that have it
13:32:50 <Graypup_> which is, yeah, ‚âà a C++ concept
13:33:14 <lc_> You can make that interface. But that reminds me of a constraint for interfaces, where you can't really "combine them", e.g. you cant say input to function f must satisfy x y and z interfaces
13:33:23 <tomsmeding> ah
13:33:30 <hyperisco> last I grazed C++, concepts were just a figment of C++14's imagination
13:33:37 <lc_> So that's a genuine constraint, and people make specialty interfaces to get around that. But they're kinda similar
13:33:39 <Graypup_> they exist as of C++20
13:33:41 <tomsmeding> whereas in haskell, I can write a function:  foo :: (Read a, Write a) => a -> Something
13:33:45 <lc_> Exactly
13:33:51 <lc_> We have to have a ReadWriter for that
13:33:56 <hyperisco> well congratulations to them
13:34:10 <hyperisco> the end of error novels?
13:34:21 <tomsmeding> hyperisco: it's c++
13:34:25 <Graypup_> lmao
13:34:34 <Graypup_> haskell also has error novels
13:34:36 <hyperisco> alright so that hype was overhype
13:34:36 <Graypup_> IME
13:34:47 <tomsmeding> though I've had haskell errors that don't fit on a screen too
13:34:50 <ski> tomsmeding : or `read :: Read a => String -> a'
13:34:58 <Graypup_> haskell errors are crap compared to rust errors
13:35:23 <rustisafungus> Graypup_: yeah i think many in the haskell community recognize that it would be worthwhile investing in developer ergonomics
13:35:30 <tomsmeding> ski: or is that really a feature of parametric polymorphism?
13:35:35 <hyperisco> okay but "error novel" is like, I hope your terminal has a large enough buffer for this
13:35:37 <lc_> I retract my statement about them being exactly the same thing. They are exactly the same thing conditional on being able to assert multiple interfaces per variable. But it is correct to call them "interfaces"
13:35:42 <maerwald> Graypup_: not so fast
13:35:43 <tomsmeding> you can't write 'read' in Go I think
13:35:54 <maerwald> borrow checker errors can be quite confusing too
13:36:03 <ski> tomsmeding : type classes depend on parametric polymorphism
13:36:28 <Graypup_> that's true but they're doing their best. haskell has too fancy of types to have good errors I suspect
13:36:53 <ski> lc_ : how would you call the method of an interface, if there's no object to call it on ?
13:37:08 <hyperisco> lc_, if "interface" is meant loosely then I don't disagree. It is just a common tripping point when someone believes type classes = OOP interfaces, or other notions of "interface"
13:37:27 <dolio> For some reason, people complain about GHC's errors, and the response seems to be to put ever more information in them. :)
13:37:32 <maerwald> Graypup_: you don't have to use that jazz
13:37:39 <tomsmeding> lc_: with ski's help, I think indeed the Read type class is a good example of something that doesn't map well to Go
13:37:45 <Graypup_> maerwald, yesod go brrr
13:37:54 <dolio> Even though it seems like the opposite would be better.
13:38:17 <maerwald> Graypup_: that's exactly why I don't use it
13:38:33 <hyperisco> GHC would have great errors probably if everyone stopped using so much inference
13:39:08 <dolio> I don't know about that.
13:39:12 <Graypup_> maerwald, well I didn't choose to get hired working on a yesod project, and honestly didn't have much of a choice anyway haha
13:39:36 <maerwald> yeah, you might as well go back to Java
13:39:48 <lc_> Anyone here got any thoughts about using golang vs. Haskell in a production environment. I come close to switching a lot, but I really don't like meme chasing
13:39:53 <tomsmeding> maerwald: that escalated quickly
13:39:53 <Graypup_> java has better errors and doesn't require a PhD to understand the type theory
13:39:59 <hyperisco> tomsmeding, looks like an interface is a type in Go
13:40:02 <Graypup_> oops a controversial statement
13:40:11 <maerwald> tomsmeding: that was sarcasm towards yesod
13:40:14 <dolio> I don't have a PhD.
13:40:33 <dolio> Neither does SPJ, I think.
13:40:37 <sm[m]> new-to-you ghc errors can suck, but ghc errors you see repeatedly in production code soon become a non-problem
13:40:40 <hyperisco> you can mail my honorary PhD to my PO box
13:40:57 <tomsmeding> Graypup_: true, but there's metric tonnes of stuff you can do in haskell that you can't in java :p
13:41:00 <tomsmeding> in terms of abstractions
13:41:32 <maerwald> lc_: if you like to live in microservice hell, Go is your first choice
13:41:51 <hyperisco> lc_, imo that depends on the project. If Go has the right libraries and ecosystem already for the job then have at it
13:41:53 <tomsmeding> dolio: SPJ has a honorary doctorate
13:42:01 <dolio> Ah, okay.
13:42:38 <Graypup_> tomsmeding, well I literally work on a webapp that has a logic checker embedded in it so...
13:42:45 <Graypup_> yeah java is a no go
13:42:47 <rustisafungus> it would be nice if there was a way to do away with the "libraries" entrechment phenomenon to promote language innovation
13:43:13 <lc_> maerwald: Completely incorrect. I work on a golang project that is almost entirely a monolith besides its dependencies on NIH apis and infra
13:43:30 <monochrom> Graypup_, I think your experience about advanced types is due to using some of the web frameworks that go crazy with advanced types, and is not representative of what other people experience, certainly not what I experience.
13:43:32 <lc_> why anyone would suggest that golang --> microservices beyond the fact that its easy to use the http libraries is beyond me
13:43:37 <maerwald> lc_: how does that make my statement incorrect
13:43:43 <tomsmeding> lc_: maerwald said microservices -> go, but go -> microservices
13:43:44 <maerwald> I didn't talk about your work project :)
13:43:45 <tomsmeding> ;)
13:43:51 <tomsmeding> s/but/not/
13:44:06 <lc_> you got me there
13:44:22 <monochrom> But I don't speak badly of Java either because Java has a better exception system.
13:44:29 <maerwald> indeed
13:44:39 <maerwald> But I still speak badly of it :)
13:44:48 <dolio> Yeah, I don't really have many problems with weird type errors. I mainly don't find the list of information about everything in scope in a where clause very useful, and such like.
13:44:49 <hyperisco> I read recently how the exception system is terrible in Java and how Haskell does it better, lol
13:45:07 <monochrom> We can all speak badly about a bad aspect, as opposed to a whole language.
13:45:10 <hyperisco> my experience with checked exceptions is checkered
13:45:14 <maerwald> hyperisco: haskell has an exception system?
13:45:25 <hyperisco> as a library sure
13:45:30 <maerwald> Ah, you mean IO... anything goes
13:45:40 <Cale> It has several...
13:45:42 <monochrom> Likewise, we can all speak badly about a semantics issue, as opposed to a whole "paradigm".
13:45:49 <lc_> I recently tried this sort of exception handling... scheme in golang. I don't know if it's insane or not
13:45:50 <hyperisco> well, the argumentation I was reading liked the unchecked ethos
13:45:53 <maerwald> And none of them work consistently :)
13:46:28 <lc_> Basically, when a function would normally return an error, I just give it two callbacks instead. One will func(err error) and the other will func(goodies Goodies)
13:46:55 <hyperisco> unchecked may as well mean unityped errors
13:47:02 <Graypup_> monochrom, the ones I've had a lot of trouble with are hardly advanced. Just like, figuring wtf they expect me to return (the short version of it), when some person who thought they were smart put the result through 14 monad transformers making the type fall off the screen
13:47:40 <maerwald> transformers aren't worth it... just use IO
13:47:47 <monochrom> Well OK, then it is due to some web frameworks going crazy with 14 levels of monad transformers.
13:47:50 <dolio> That doesn't seem like it's GHC's fault.
13:47:55 <hyperisco> my experience says there is such niche use of it that it wasn't worth my bother
13:47:57 <monochrom> But it is still not representative of the majority.
13:48:16 <hyperisco> there isn't any point to sussing out different types of errors unless you're going to do something different with them
13:48:22 <lc_> I use this scheme to cache and replace globals, too, in golang
13:48:32 <monochrom> Call me academic but I refuse to accept that web programming is representative of programming.
13:48:39 <hyperisco> and practically speaking, usually just printing a string somewhere or crashing suffices
13:48:40 <maerwald> I guess fpcomplete frameworks usually make heavy use of transformers
13:48:41 <Graypup_> dolio, I mean, not entirely? but the only way I found out e.g. about the MForm alias was reading docs and other peoples' source coded and the vanishingly few examples
13:49:02 <Graypup_> haskellers don't seem to believe in writing examples often which is very frustrating as someone trying to learn
13:49:31 <lc_> I'm a web programmer and it's awful. I wish you could make money programming compilers. Not that I know anything about compilers or compiler design, just... The idea of having a program I just run on my computer that does some computation and then outputs some computation
13:49:34 <hyperisco> I thought web framework = TH hell
13:49:45 <monochrom> I agree that some of the web frameworks I have seen get close to requiring PhD in CS.
13:49:46 <lc_> Instead of having to deal with database errors, pipelines, schema migrations, etc. etc. etc.
13:49:49 <Graypup_> oh I have debugged TH bugs in persistent also
13:49:56 <Graypup_> that was a bad day
13:50:01 <monochrom> I disagree that this is representative of Haskell programming.
13:50:02 <hyperisco> like, back in the 2000's "web framework" became inseparable from "code generation"
13:50:04 <rustisafungus> lc_: have you used elm?
13:50:21 <lc_> rustisafungus: I have not
13:50:46 <hyperisco> and all that is happening in Haskell frameworks is a somewhat more disciplined code generation
13:50:48 <rustisafungus> lc_: please take a moment and write tic tac toe or something in elm, you will be very pleasantly surprised
13:50:49 <maerwald> Theres something missing in Software Engineering... no matter what language you use, imo. It's the "Engineering".
13:51:00 <Graypup_> also the persistent folks said "oh you should read our tests to figure out how to use compound keying" when the tests were incredibly hard to follow since they were doing clever stuff to write the tests concisely at the expense of understanding the code
13:51:09 <hyperisco> be it TH or crazy daisy type classes / families
13:51:17 <Graypup_> people seem to be very allergic to writing examples
13:51:20 <lc_> I should say, back-end web developer*, not front-end. My partner handles that
13:51:38 <Graypup_> I hope that the library I maintain is an exception
13:51:42 <rustisafungus> lc_: you know, even though you are back-end, give elm a try
13:51:54 <koala_man> lc_: Facebook does a lot of compiler work. I had no idea until they released Infer, the Java/ObjC static analysis tool written in OCaml. 
13:51:54 <lc_> I just write golang stuff. I'd literally kms if I had to write javascript and css for a living, stg
13:52:10 <rustisafungus> lc_: elm was designed for a person like you
13:53:35 <Cale> I've been working on GHC lately for one of our clients, and can easily be a good deal more tedious at times than working on our full stack Haskell web/mobile applications.
13:53:43 <lc_> I am still giggling that you caught that maerwald btw
13:54:03 <lc_> I normally do that to other ppl I know
13:55:21 <qqqqqq> 6 Proof that 4Jesus worshiped one God same as muslims do: 10- Jesus identifying the commandment: "The Lord our God is One Lord" (Mark 12:29) to be the most important of all As stated in (Mark 12:29): Jesus was asked "Which commandment is the most important of all?" Jesus replied, "This is the most important: Hear O Israel, the Lord our God is One Lord"12 (Mark 12:29) as in Quran: {Say He is God the one (Allah)} [Quran chapter 112].
13:55:21 <qqqqqq> 6 so the above qoute(mark12:29) is a clear evidence that Jesus was directing us towards monothiesm belief and to consider it as the very first of all commandments; 10 also here is the firsts of the The Ten Commandments(to moses) which is similar to what he was directing us towards: [10 1 - I am the LORD your God who brought you out of the land of Egypt, out of the house of bondage. You shall have no other gods before Me.]
13:56:09 <hyperisco> maerwald, move fast and break things man
13:56:10 <sm[m]> Graypup_: maybe you're ready to give https://ihp.digitallyinduced.com/ a try ?
13:56:15 <Graypup_> is god a monad /s
13:56:20 <monochrom> Ironically, I would welcome a theology war if it replaced a language war.
13:56:30 <ski> Graypup_ : ask Leibniz ?
13:56:33 <maerwald> hyperisco: yeah, but forgot my sunglasses
13:57:13 <hyperisco> I need to figure out how to turn renouncing programming into a career
13:57:21 <hyperisco> then I can actually renounce programming
13:57:35 <hyperisco> was better as a hobby tbh
13:57:46 <Graypup_> sm[m], interesting. maybe I'll use it for my personal projects where I am swearing so hard at excel for being a garbage programming tool incapable of even making hyperlinks and want to immediately rewrite as webapps
13:57:56 <monochrom> If you like something, don't turn it into a job.
13:58:11 <lc_> THis might be my golang speaking, but it feels like 90% of programming is edge cases and it kinda sucks
13:58:19 <hyperisco> yeah but I was mistaken on the reason why
13:58:23 <monochrom> A job causes burnout. Do you want burnout from something you like?
13:58:26 <sm[m]> Graypup_: it's new but I think has legs
13:58:39 <hyperisco> I thought the reason was because you'd get burned out doing what you used to love to do
13:59:01 <sm[m]> (If you can stomach nix)
13:59:11 <maerwald> you burn out a few times and then you get input-addicted
13:59:12 <monochrom> Yeah that's the reason I know.
13:59:26 <hyperisco> and that isn't the issue, as I see it‚Ä¶ the issue is that you don't really have enough control over what you do
13:59:34 <Cale> monochrom: haha, I wonder what was going through this driveby spammer's head... "This'll blow the minds of all those polytheistic christians in the programming language and software project channels on freenode"
13:59:54 <glguy> There's not usually a lot going on in that kind of person's head
14:00:09 <maerwald> Cale: tbf... it could be a teenager.. at least I hope so
14:00:18 <hyperisco> so the result is I still say I like to program, but "not this"
14:00:20 <monochrom> Cale, I think it's the simpler "this channel size is large enough".
14:00:21 <Graypup_> sm[m], funny thing right
14:00:22 <maerwald> not sure what to think if an adult wrote that
14:00:26 <Graypup_> I learned nix before haskell
14:00:50 <Graypup_> because I had to fix my project's build system to not require a giant docker container with ghcjs because ghcjs is such a pain to compile
14:00:54 <hyperisco> because "programming" can also be hacking on JSON files to get Cloud Formation working
14:00:57 <monochrom> Please always apply Occam's razor to human motivation. You'll be more realistic and cynical.
14:00:58 <sm[m]> Graypup_: great, this should be perfect for you then
14:00:59 <Graypup_> so I can /absolutely/ stomach nix hahahaha
14:01:51 <monochrom> hyperisco: Good point, yeah.
14:02:21 <maerwald> glguy: and I was gonna debate Thomas Aquinas god proofs
14:02:29 <maerwald> but they didn't stay long enough
14:03:17 <monochrom> "beware of mathematicians, category theorists, and Haskellers" >:)
14:19:40 <aldum> I thought the complaint was that (most) haskellers are in the intersection of the former two
14:20:19 <MarcelineVQ> most haskellers just want to be Free
14:20:27 <dolio> That's not true at all, really.
14:22:19 <monochrom> It's an understandable complaint if you add weights by how vocal each Haskeller is.
14:24:39 <dolio> I don't know if it's even true then, unless your standards for being a 'category theorist' are pretty low.
14:24:46 <dolio> Or 'mathematician'.
14:25:06 <monochrom> I believe that's exactly what happens in many people's minds.
14:25:43 <monochrom> Right? Yesterday's smbc (https://www.smbc-comics.com/comic/number-hunt) is very revealing.
14:26:36 <monochrom> People fear what they haven't heard of, and that fear leads to hyperboles and exaggerations.
14:30:23 <monochrom> Or it's a psychological defense mechanism. To feel better that you have a rationalization for why the other person knows something you don't know.
14:33:30 <int-e> monochrom: you're 1 million percent wrong
14:33:44 <dolio> Wow, that's pretty wrong.
14:34:06 <monochrom> OK, what's right then?
14:34:17 <int-e> Sorry, I got stuck on the hyperbole stage.
14:34:26 <monochrom> haha OK
14:35:00 <MarcelineVQ> trancendentally wrong
14:35:59 <monochrom> A cunning fox, more cunning than the previous one, came across a lot of grapes hung pretty high. The fox really wanted the grapes, but couldn't reach them.
14:36:04 <MarcelineVQ> you're extremely wrong, but luckily figuring out how wrong you are is only  log_w you
14:36:20 <monochrom> This fox is more cunning than the previous one, so it wouldn't lie to itself "I don't want these grapes anyway".
14:36:52 <ski> oh, fable time :)
14:36:55 <monochrom> Its more cunning excuse is "these grapes are for animals with wings. But I'm proudly down-to-earth".
15:04:15 <frdg> what is a nice way to visit every element in a list and perform an IO () on every visit?
15:04:28 <monochrom> mapM_
15:04:39 <frdg> ok
15:05:07 <monochrom> Example: mapM_ putStrLn ["1st line", "2nd line"]
15:06:54 <hpc> it may also be more comfortable to do forM_ ["1st line", "2nd line"] $ do {...}
15:08:14 <monochrom> you missed a lambda.   forM_ ["1st line", "2nd line"] $ \x -> do {...}
15:10:18 <hpc> oh yeah, i did
15:12:21 <Boarders> I was getting a seg fault in my code which read from a file of size 10^9 bytes into a buffer which went away when I upgraded from ghc-8.6.5 to ghc-8.10.1. Does anyone know of any change that could have caused that? I was also using SIMD operations if that is even slightly relevant.
15:12:55 <Graypup_> Boarders, it would probably be very computationally unpleasant but you could bisect it :P
15:14:03 <monochrom> Knowing how ghc-8.8.x fares may help.
15:14:57 <Boarders> I was hoping someone familiar with gritter details of ghc dev might have some hunches for the answer
15:16:02 <sm[m]> Boarders: maybe check changelogs between the ghc versions and between the package versions
15:16:55 <Graypup_> what did my debugging book say .... "quit thinking and look"
15:19:50 * hackage orthotope 0.1.0.0 - Multidimensional arrays inspired by APL  https://hackage.haskell.org/package/orthotope-0.1.0.0 (LennartAugustsson)
17:16:59 <glguy> Hi, josh. Glad you could make it.
17:32:35 <lc_> what's up justanotheruser. How ya been?
17:43:59 <sshine> monochrom, is there a good reason to use forM_ instead of for_?
17:44:11 <monochrom> No.
17:44:27 <sshine> ok, so it was just for the mapM_ <-> forM_ correspondence.
17:44:46 <sshine> :t for_
17:44:48 <lambdabot> (Foldable t, Applicative f) => t a -> (a -> f b) -> f ()
17:45:24 <monochrom> It's simpler than that. Different people learned different names, and first impressions are always the strongest.
17:45:59 <dolio> I learned all the names before Applicative even existed, but I like the Applicative names better. :√æ
17:46:00 <ski> `Applicative' wasn't superclass of `Monad', back then
17:46:51 <monochrom> Always look for human factors and social reasons before looking for technical reasons.
17:47:07 <monochrom> Programmers are artisan humans not scientific robots.
17:47:21 <monochrom> Oh I do wish programmers were scientific robots.
17:47:59 <justanotheruser> lc_: hi whos this
17:48:32 <lc_> just a friendly guy
17:48:42 <justanotheruser> ok
17:51:02 <sshine> I consider myself better of being a bayesian inference machine.
17:51:11 <monochrom> Another good example is why Prelude has the head-tail couple, and why tail [] = undefined, and why they are neither a safeHead-safeTail couple nor a "listAnalysis z _ [] = z; listAnalysis _ f (x:xs) = f x xs" function like maybe and either.
17:51:13 <sshine> I get to defy logic in completely subjective corner cases.
17:51:23 <sshine> robots are doomed to repeat their program.
17:52:37 <monochrom> It is because when the committee formed and sat down to write Prelude, the lot of them was from Lisp backgrounds and their first instinct was to replicate Lisp's car and cdr.
17:53:22 <monochrom> And because of that background, they totally expected the head-tail couple would be very popular among users.
17:53:25 <sshine> I thought the Lisp guys branched off to form the ML cult of which Haskell is more closely related?
17:53:44 <monochrom> It is clearly technically inferior, and equally clearly socially popular.
17:53:49 <sshine> SML has hd/tl, too.
17:56:17 <monochrom> And I guess s/scientific robots/utilitarian robots/
17:59:54 <monochrom> ML taught us the valuable lesson that pattern matching trumps head-tail, and after you have pattern matching you can pretty much throw away head-tail. A committee for a new language and its new library, having their chance to start from a clean slate, if they had really learned that lesson, you would think they would reflect this new value by omitting head-tail in their clean slate new library no?
18:00:52 <monochrom> That they totally (anti-pun!) didn't do it shows that the influence of social inertia trumps the influence of technical superiority.
18:03:21 <josh> thanks, glguy. Glad to be here
18:04:13 <Plazma> apologies if this has been brought up before or beaten to death but i came across this - https://www.stephendiehl.com/posts/crypto.html and it seems to be more of a negative against the community vs the language itself.. or did i read it incorrectly
18:05:45 <sm[m]> Plazma: there's some discussion of it on /r/haskell and hacker news
18:06:03 <josh> "the influence of social inertia trumps the influence of technical superiority" is the story of my Haskell life
18:06:53 <Plazma> i didn't realize social stuff was such a key part of using/loving a language
18:06:58 <Axman6> it's negative about a view of some of the industrial uses of Haskell. I happen to work for a company which is using blockchain/DLT to build non-cryptocurrency stuff so I found the lumping of everyone with anyone who had anything to do with blockchain pretty disappointing and somewhat uninformed (though that's the same of most discussions of blockchain, everyone thinks it means cryptocurrency and boiling the oceans)
18:07:55 <Plazma> Axman6: i've not worked with blockchain but i collaborate with some blockchain folks also (i'm a quantum guy) , and it's a similar story,, they aren't all trying to necessarily start their own cryptocurrency
18:08:01 <Plazma> many are just exploring the waters
18:08:14 <MarcelineVQ> It barely mentions haskell and baffles me why it's called a haskell elephant
18:08:33 <monochrom> Hey I heard lately that Microsoft is going to be literally boiling the ocean, or at least seas, by putting data centres undersea.
18:08:34 <Axman6> Plazma: it's not, I think a lot of the community found the article pretty extreme, particularly when the targer was IOHK, possibly (IMO) one of the least bad players in the cryptocurrency market. (I don't work for IOHK, but do know several people who do)
18:08:55 <Plazma> MarcelineVQ: see that'w hat i noticed too.. like what the actual hell is he going on about haskell ? he's not..
18:09:08 <Axman6> monochrom: heating the oceans is much more efficient if we avoid the wasteful atmospheric warming step :P
18:09:34 <monochrom> The benefit is 90% reduction in failure rate.
18:09:45 <Plazma> thermal physics is a signed integer, so we just need to heat it so much it rolls over to cooling through natural means
18:10:18 <monochrom> It looks like the new failure rate is so slow, they won't bother to repair a failed unit, just submerge a new one.
18:10:30 <monochrom> s/slow/low/
18:11:35 <MarcelineVQ> "why crypto is badong" would have been a better, though less publicly shared, title
18:11:55 <Plazma> Axman6: yea i mean a source i trust sent me that basically telling me to stay away from haskell or learning it, but it makes no mention of haskell really , at all as a language .. just that some guy may have used some shit for it to do shady things
18:12:01 <MarcelineVQ> "I don't like that some effort in haskell goes towards crypto currencies" ok.  "haskell as an ecosystem and community has sold its soul to the devil" umm...
18:12:34 <Axman6> Plazma: your friend seems equally uninformed then :P
18:12:47 <Plazma> i mean malware is often written in C/win32 api stuff, someitmes C++ for ransomware, but we don't chastise C++ for that, we chastise it for every other reason
18:13:03 <Plazma> i mostly just wanted to make sure i didn't misinterpret it
18:13:12 <Plazma> Axman6: he didn't convince me at all with that article
18:13:26 <Axman6> there are definitely better technological and community reasons to avoid Haskell than some companies are using it for cryptocurrency development
18:14:05 <monochrom> We chastise C for the equal and opposite reason. That C makes it easy to write programs that are vulnerable.
18:14:45 <Plazma> monochrom: exactly.. scanf() just to name a simple/easy one
18:14:57 <monochrom> I.e., while we don't chastise C for aggressors being written in C, we do chastise C for victims being written in C.
18:15:08 <monochrom> Hey wait a second, does that count as blaming the victim? >:)
18:15:14 <Axman6> for me, a big one is we seem to really struggle to develop projects as a community, we rely on a lot of single person efforts (edwardk's bus factor is astronomical). One of the few prohjects I've seen do a decent job in Haskell as building some sort of community is Servant
18:15:40 <Plazma> monochrom: you're not on trial here :)
18:16:00 <Axman6> like I look at Rust and they seem be quite good at having projects which the community contributes to and progress is made quite quickly
18:16:08 <Plazma> ahh i see
18:16:25 <Plazma> i guess that's whewre community is kind of important.. 
18:17:12 <Axman6> we do have an incredibly supportive community though, people will fall over themselves to help you learn something
18:18:10 <MarcelineVQ> Even into a pit of spikes
18:18:26 <Axman6> We're also starting to see some decent commercial use and support
18:21:14 <Plazma> so i guess in short that article is an opinion piece and worthless for most things
18:21:49 <Axman6> that depends on your opinion I think :)
18:22:13 <Plazma> i'm new so i don't have any , but the fact they don't mention anything remotely technical it's just some dribble to me
18:22:30 <MarcelineVQ> For me there's nothing specific enough to be useful _about haskell_ in that article
18:22:31 <Plazma> no offense to the guy personaly, i'm sure he's great and accomplished
18:24:12 <Axman6> it's not like all of the sommercial use of Haskell is in cryptocurrencies either, by a long shot. there's quite a lot of use in finance., Facebook has their spam detection system written in it, GitHub are using it for their new Semantic (IIRC) project, and several sproduct and contract companies 
18:24:53 <Axman6> Plazma: Don't write off everything he's written because of that article though, his What I Wish I Knew When Learning Haskell is incredibly valuable
18:25:09 <Plazma> Axman6: yea actually i just discovered that too and was probably going to learn haskell better from it
18:25:19 <Plazma> and some of his stuff and his company seem pretty legit
18:25:29 <Plazma> he probably was just upset about that and wrote it
18:25:46 <Plazma> he's not at all saying "don't learn haskell because of this" either, so
18:25:53 <Plazma> my friend was probably just being overly opininoated
18:25:59 <Plazma> (he told me to learn nim instead)
18:29:50 <jchia> That article overgeneralizes things. Just because some 'crypto' stuff is bad doesn't mean all crypto stuff is bad. Just because some Haskell users do bad things doesn't mean the Haskell 'community' is bad. We don't do that kind of generalization for other languages. I don't understand how smart people can make this kind of overgeneralization mistakes.
18:30:47 <Plazma> jchia: yea that's my conclusion too.. doesn't really make a lot of sense to me either
18:32:02 <monochrom> Programmers seem to be more overgeneralizing than other people.
18:32:30 <Plazma> i'm going to assume he was just emotional and upset and wrote it
18:32:32 <monochrom> For example consider the "software engineer makes toaster" joke.
18:32:33 <Plazma> and it got traction
18:32:48 <Plazma> all i know is bread goes in, toast comes out... you can't explain that , man
18:33:46 <monochrom> No no, it's a joke along the line of "a physicist, an engineer, and a programmer are each asked to make a toaster".
18:34:08 <Axman6> "Programmers seem to be more overgeneralizing than other people." so meta
18:34:17 <monochrom> hahaha busted
18:34:30 <jchia> he did say 'seems'
18:34:47 <sm[m]> Axman6: there's good team work going on with ide tools lately
18:34:57 <monochrom> So the joke goes on to say something funny but pretty OK on how a physicist would make a toaster, and how an engineer would make a toaster.
18:35:19 <sm[m]> volunteer, gsoc, and company driven
18:35:23 <MarcelineVQ> I just go down to the local library and use their toaster.
18:36:24 <monochrom> The punchline is a very long sentence about how a programmer does it by going way overboard with the OOP kind of overgeneralization, plus a prophetic addition that the toast also connects to the Internet. (This joke was decades before the IoT movement.)
18:37:02 <monochrom> a long sentence basically enumerating everything one does in OOP
18:37:06 <Axman6> sm[m]: yeah that's true
18:37:27 <sm[m]> also haven't ghc, cabal, stack, hackage all involved quite a lot of cooperation
18:38:00 <Plazma> monochrom: yo dawg i heard you like OOP and python so we put abstract classes in your classes , but they're not interfaces, but they are..
18:40:34 <monochrom> Also consider that programmers have this saying "YAGNI" and other professions don't.
18:41:03 <monochrom> We have it because we're doing poorly so we need this saying to warn ourselves.
18:41:24 <monochrom> Other professions don't have it because they're already doing it right and don't need a warning.
18:41:33 <sm[m]> KISS is a common saying
18:42:13 <monochrom> Well yeah OK so everyone else has one saying, we have two, we are still worse.
18:42:38 <monochrom> Consider the possibility that KISS is not strong enough for us.
18:45:36 * MarcelineVQ learns the term yagni
18:46:12 <sm[m]> Axman6: but I would agree that things usually don't seem to evolve very fast
18:47:37 <sm[m]> that seems to be the Haskell way, often - it takes longer to build, but also lasts longer with less rework & maintenance ?
18:48:13 <sm[m]> When tooling finally matures, perhaps that will change ?
18:49:28 <monochrom> From what I saw, it doesn't take longer to build. Look at tomsmeding's paste site.
18:49:32 <sm[m]> or.. the rust army is just much much bigger ? or.. they have more of an engineering and shipping focus ?
18:50:08 <monochrom> But whenever more than one author is involved, it takes longer to reach consensus, because there are always more than one elegant way to do it, and they aren't compatible.
18:50:51 <sm[m]> So we're like Lisp ?  :-/
18:51:33 <monochrom> Yes in this aspect.
18:51:44 <monochrom> No in how many compilers to choose from.
18:52:54 <sm[m]> monochrom: maybe as our libs, architectures, patterns mature, this will improve ?
18:54:24 <monochrom> I wouldn't hold my breath.
18:55:53 <monochrom> Some convergence did happen in the past. transformers and mtl were in competition a long time ago, but one day they agreed to a partition of roles and worked together.
18:56:25 <monochrom> pipes and conduit, I predict them to stay that way forever.
18:56:34 <monochrom> cabal and stack, I predict them to stay that way forever.
18:58:35 <monochrom> Although, the pipes-conduit dichotomy is already a vast improvement compared to the long gone days of 3 choices of iteratees, 2 choices of enumeratees, and 5 choices of something in between.
19:00:42 <sm[m]> Yup
19:01:12 <sm[m]> also, higher level frameworks will continue to improve
19:02:41 <sm[m]> I think the ide tools are going to be impactful, they will attract more devs
19:04:25 <sm[m]> vs code with hls 0.4 really works and is a real step up IME
19:16:07 <sshine> yes
19:16:21 <sshine> I didn't have to manually compile a file and copy it into VSCode's directory!
19:40:23 <frdg> how can I go from `Functor f => f (g (a)) -> g a` without pattern matching ? 
19:40:38 <frdg> err and `Functor g`
19:40:57 <c_wraith> You can't just collapse them for any old pair of functors
19:41:18 <frdg> oh
19:42:16 <frdg> what about Traversables?
19:42:47 <c_wraith> :t sequenceA
19:42:48 <lambdabot> (Traversable t, Applicative f) => t (f a) -> f (t a)
19:42:56 <c_wraith> that's as close as they'll get you
19:43:13 <frdg> hmm
19:43:38 <ski> @type asum
19:43:39 <lambdabot> (Foldable t, Alternative f) => t (f a) -> f a
19:44:32 <frdg> this should work.
19:44:36 <c_wraith> Oh, yeah.  If Alternative is good enough, that works
19:47:30 <exodrifter> Does anyone happen to know if there's a Storable instance of Text floating around out there or how you'd generally represent UTF-8 in an FFI interface?
19:48:59 <c_wraith> text isn't even UTF-8
19:49:45 <exodrifter> oh, unicode and utf-8 are not the same thing?
19:49:51 <c_wraith> nope
19:49:57 <c_wraith> unicode is a character set
19:50:05 <c_wraith> utf8 is one way of encoding that character set in bytes
19:51:05 <exodrifter> ah, I see. I assumed Text was UTF8 because of decodeUtf8, but that's just what character set to use for the bytestring
19:51:17 <c_wraith> exactly
19:51:37 <c_wraith> well.  just what encoding to use for the bytestring.
19:51:57 <exodrifter> yeah. what does it mean for Text to be unicode then? is it not any particular character set until you decide to encode it?
19:52:26 <c_wraith> unicode is a character set.  How the characters are represented inside a computer is an implementation detail
19:53:19 <c_wraith> There are a bunch of ways to serialize it that are standardizes, though.  UTF-8, UTF-16, and UCS4 are the options that give you the full unicode character set.
19:53:25 <c_wraith> *standardized
19:53:38 <exodrifter> so if i wanted to, say, encode a text into a utf-8 bytestring then marshall that representation out using FFI -- that wouldn't necessarily work because the memory representation might be different?
19:53:45 <dolio> You could represent it other ways in a bytestring, too.
19:54:09 <dolio> But you'd need to be careful.
19:54:11 <c_wraith> Right.  You should go through an explicit conversion to the correct encoding you want in a ByteString, then use useAsCString for the bytestring
19:55:18 <exodrifter> well, i want to have a foreign function call the haskell code, not the other way around, so useAsCString wouldn't work for what i'm trying to do.
19:55:26 <c_wraith> Ah, ok.
19:56:06 <exodrifter> dolio: what do you mean exactly? represent it in what other ways?
19:56:43 <dolio> You could have UTF-16 in a byte string, but each byte would be half of one of the basic units of the encoding.
19:57:12 <dolio> Also it probably gives you more ways to mess up the endianness.
19:57:20 <exodrifter> Ah, okay, yeah that makes sense
19:58:44 <exodrifter> so if the way the UTF-8 is represented is an implementation detail, is there then no way to marshall a UTF-8 string without implementing a decoder in the foreign code that knows how it's represented in haskell?
19:59:54 <dolio> The foreign function is going to need to know the encoding used.
20:00:10 <dolio> If it's UTF-8, it'll need to know that.
20:02:20 <exodrifter> Hmm, okay. So if it knew the bytes were UTF-8, then it should be fine? I'm not sure if the UTF-8 standard defines how it would be represented in memory...
20:02:39 <dolio> UTF-8 is a particular way of storing unicode.
20:03:49 <exodrifter> Yes, so does that apply to in-memory? I'm aware that it would work for files, since i can usually open UTF-8 documents regardless of what computer i'm on.
20:04:19 <dolio> It can be stored that way in memory, too. But Text doesn't.
20:05:15 <exodrifter> sure. So I just need to encode the text into a UTF-8 bytestring, then figure out how to convert the bytestring into a CString, and that should work it sounds like
20:05:17 <dolio> That's one of the resons there's `decodeUtf8`
20:05:32 <dolio> Yeah, probably.
20:06:01 <dolio> Although C doesn't necessarily know anything about UTF-8. That'd be up to libraries.
20:06:41 <exodrifter> yeah, that makes sense. But, I'm assuming that if the user was using a library that had the equivalent of decodeUtf8 it should work
20:07:17 <exodrifter> It's too bad ByteString doesn't expose a function that lets you return the CString... I'm looking at the implementation of it and i suuuuure don't understand it yet
20:07:18 <dolio> And e.g. all sorts of Microsoft stuff uses UTF-16, I think.
20:07:50 <exodrifter> I think i am satisfied limiting my use case to UTF-8.
20:08:40 <dolio> Yeah, that's pretty safe.
20:10:10 <exodrifter> oh -- i guess i don't really want a CString since I don't want to be limited by ascii. I want to return something more like an array of bytes or something.
20:11:07 <exodrifter> ...wait, that is what byte is in c isn't it.
20:11:09 <dolio> I think CString is a char pointer.
20:11:20 <exodrifter> yeah, it's a char*
20:14:41 <exodrifter> okay i think I know what i need to do. Thanks dolio & c_wraith <3
20:20:20 * hackage smash-lens 0.1.0.1 - Optics for the `smash` library  https://hackage.haskell.org/package/smash-lens-0.1.0.1 (topos)
20:21:20 * hackage smash-optics 0.1.0.1 - Optics for the `smash` library using `optics-core`  https://hackage.haskell.org/package/smash-optics-0.1.0.1 (topos)
20:40:20 * hackage base16-bytestring 1.0.0.0 - RFC 4648-compliant Base16 encodings for ByteStrings  https://hackage.haskell.org/package/base16-bytestring-1.0.0.0 (topos)
20:45:12 <lemmih> topos: Woo, version 1.
20:46:00 <MarcelineVQ> the madlad
20:47:16 <topos> lemmih completely cleared out the backlog, basically rewrote the library and achieved some multipliers on performance
20:47:19 <topos> so i'm happy
20:48:21 <exodrifter> that sounds great!
20:54:11 <lateef> hi does anyone know how to use tasty-discover with the rerun ingredient. can't find any examples
21:02:50 <Axman6> topos: how many GB/s? :)
21:03:10 <koz_> Axman6: The only measure that counts. :P
21:03:12 <topos> ugh. i had that number at one point. hang on
21:03:19 <Axman6> koz_: of course
21:03:32 <koz_> topos: Over 9000. :P
21:03:34 <Axman6> though, speed for small strings is probably more important
21:21:59 <topos> Axman6 https://pastebin.com/LEs9sBTx
21:22:17 <topos> here's a bench of the old algo vs. the new algo for 1gb 
21:23:16 <topos> encode is ~1GB/s, decode ~0.5GB/s compared to ~350MB/s (old encode) and ~120MB/s (old decode)
21:23:52 <koz_> topos: So roughly threefold?
21:23:56 <koz_> That's pretty damn good.
21:23:59 <topos> yeah
21:24:10 <topos> between 3-5 depending on the length of the bytestring
21:24:23 <topos> the old algo would degrade for larger bytestrings
21:24:50 <topos> the new one is a steady ratio of encode ~ 2xdecode 
21:25:48 <topos> which makes sense because all you're doing in the encode step is reading a byte, munging it into two and writing it, where the decode case requires reading two, munging it, and then writing one
21:25:55 <topos> oo. sorry for pinging whoever that was
21:28:03 <Axman6> that's their problem :)
21:29:45 <Axman6> I really want to make this code work a word at a time...
21:31:25 <topos> Axman6 i'd like to as well. The best I can think of is to make use of SIMD instructions, because at this point we can't do any better without the benefit of being able to multiple words into a single instruction
21:31:57 <topos> but also, this code is dead. I'm not working on it anymore. It was strictly fanservice, and I'm encouraging everyone to move to https://hackage.haskell.org/package/base16
21:32:22 <topos> if you want to contribute a SIMD version or AVX2 support, be my guest 
21:32:28 <topos> it won't happen on base16-bytestring tho
21:32:43 <Axman6> you should have a ook at the PR I had on the text-utf8 repo for faster take/drop/indexing, it was roughly 100x faster than the streaming implementation and pretty much branchless
21:32:49 <topos> ooo
21:33:08 <Axman6> but I never finished it off and it was probably too unclear to be maintainable
21:33:15 <topos> https://github.com/text-utf8/text-utf8/pull/11 this guy?
21:33:26 <koz_> topos: What're the numbers on that one?
21:33:49 <topos> koz_ which one?
21:33:55 <koz_> base16
21:34:05 <koz_> For the same bench as you did for base16-bytestring.
21:34:16 <Axman6> topos: https://github.com/text-utf8/text-utf8/pull/1
21:34:16 <topos> ah i implemented the same algorithm
21:34:20 <topos> so roughly the same
21:34:30 <topos> ooo
21:35:53 <koz_> Axman6: Is text-utf8 still a live project?
21:36:02 <Axman6> I believe so...
21:36:21 <topos> koz_ the only difference is that I provide a nicer general interface and more support for different types like Text, ShortText, and SHortByteString
21:36:42 <siraben> Does MTL use strict or lazy state monad by default?
21:36:55 <siraben> Is strict just better space usage wise than lazy? 
21:37:17 <topos> Axman6 this is cool stuff :)
21:37:25 <Axman6> hasn't been touched in a while though, hvr would be the best one to answer whether it's live though
21:37:52 <topos> siraben lazy state - https://github.com/haskell/mtl/blob/master/Control/Monad/State.hs
21:37:54 <Axman6> siraben: I believe lazy is the default, but that should be easy to check in the source
21:38:15 <siraben> Ah I see. When should I use strict/lazy state? I've been using lazy all along then.
21:38:17 <koz_> I always specify Control.Monad.State.Strict just to be safe when I import.
21:38:31 <Axman6> the differences between lazy and strict is... one is lazy and one is strict, they have different semantics and there are things you can do in the lazy one which you can't do in the strict one
21:38:32 <koz_> (better be explicit, even if it's just for other folks reading)
21:38:50 <topos> but remember, Strict is better in some ways, but remember that strict state is (confusingly) not strict in its setting, so you still need to `put $! <thing>` if you need it evaluated
21:39:10 <topos> i munged sentences sorry
21:40:46 <siraben> I see.
21:40:56 <siraben> And what's the difference between Control.Monad.Error and Control.Monad.Except?
21:41:13 <sumo_r> Hi all, does anyone know what the ghcxxxx.exe file created in AppData\Local\Temp on windows by cabal repl are? M365 just flagged one of those (ghcbdbc.exe) as Wacatac malware and our admin pinged me for more details
21:41:20 <topos> siraben error is deprecated, use except
21:41:34 <topos> https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-Error.html
21:41:37 <topos> top of the haddocks
21:42:26 <siraben> Right
21:42:40 <siraben> I was surprised to see Error so high up: https://www.sciencedirect.com/science/article/pii/S0167642320301313
21:42:42 <siraben> Must be legacy
21:43:26 <siraben> Most commonly used monads are (most to least order) State, Trans, Reader, Error, Writer, RWS, Identity, Cont, List, Except
21:43:46 <topos> very interesting study thanks. I could actually use this info
21:44:36 <siraben> Turns out not many people use alternative monad transformer libraries
21:45:47 <dolio> All the stuff that used Error before it was deprecated didn't just disappear from hackage.
21:47:06 <siraben> When does it deprecated?
21:47:10 <siraben> s/does/was
21:48:33 <koz_> Also why?
21:50:42 <dolio> I'm not sure. But it probably hasn't been as long since it was deprecated as the (relevant) time before yet.
21:52:03 <siraben> Why is continuation monad second least used?
21:52:23 <topos> presumably because you have to define an additional `Error` class instance in order to use your errors, which was spurious
21:53:10 <topos> siraben because continuations are hard to get right, and also have very specific use cases that don't often intersect with industry
21:53:27 <siraben> Oops I should correct my list, the actual list is State, Reader, Trans, Error, Writer, Identity, RWS, Except, Cont, List
21:53:32 <siraben> Figure 9b
21:53:38 <siraben> topos:  I see
21:53:59 <koz_> siraben: Cont is very powerful - it can implement all the others - but that's usually overkill.
21:54:18 <siraben> Yeah, there's a great blog post on reimplementing other monads from Cont
21:55:06 <dolio> It's kind of misleading to say Cont can implement the others.
21:55:18 <koz_> dolio: In what sense is it misleading?
21:56:02 <dolio> Because the way you implement them uses different Cont monads depending on which ones you're embeding.
21:57:07 <dolio> You choose a different `r`.
21:57:09 <topos> callCC @Identity @a @‚ä• what could go wrong 
22:01:28 <davean> topos: It does exactly what it says it does, whats the problem?
22:02:28 <topos> No problem here. Constructivists be damned
22:03:29 <davean> If you want to complain so much topos, make me a way to record all your issues.
22:03:48 <siraben> Should I be creating my own monads more? I usually just use an MTL monad and be done with it.
22:04:04 <siraben> Or some combination of MTL monads
22:04:05 <davean> siraben: it varies. Generally you can make your own monad out of MTL's
22:04:06 <topos> Who's complaining davean? I accept LEM as my lord and savior
22:04:23 <siraben> GeneralizedNewtypeDeriving FTW
22:04:24 <davean> siraben: Often making your own typeclass for them is whats really valuable.
22:04:40 <davean> But not all important monads can be created via composing MTL
22:04:45 <siraben> davean: any good examples on that?
22:05:14 <siraben> That's one gap in the literature, books talk about monads and monad transformers but I haven't read material on modeling effects using custom monad typeclasses.
22:05:21 <davean> siraben: PlanT in 'machines'
22:05:48 <davean> http://hackage.haskell.org/package/machines-0.7/docs/Data-Machine-Plan.html#t:Plan
22:06:08 <davean> I was doing on to thread parallelism through too today.
22:06:23 <siraben> Huh, this looks exactly like ReqT from Oleg's work
22:06:40 <davean> Usually if you're writing your own monad though not composing MTL you're doing something "interesting" that would get reused elsewhere.
22:06:48 <davean> Not always but its a good predictor
22:07:23 <davean> siraben: I'd say usually you write your own when you care about semantics, not capabilities, but thats not well defined.
22:10:08 <davean> siraben: did that make sense?
22:10:27 <siraben> davean:  what do you mean by capabilities?
22:10:49 <davean> "Get access to Disk" "Ask about a value"
22:11:15 <siraben> Ah, I see.
22:11:27 <siraben> And semantics here as in PL semantics?
22:11:42 <davean> semantics: "Do monadic things sequentually, but applicative things on a thread pool of a given size"
22:12:33 <davean> yah, semantics are about how you do the computation
22:12:51 <davean> hence PlanT as an example
22:13:04 <davean> topos: slap me around and say something a little tighter?
22:13:41 * topos slaps davean 
22:13:45 <topos> something a little tighter
22:14:04 <davean> Cont is the exception
22:14:08 <davean> that does anything, badly.
22:15:01 <siraben> One issue I've had with effects was trying to convert my Scheme interpreter to a monadic version
22:15:03 <siraben> https://github.com/siraben/r5rs-denot/blob/fba3b49d88c6d7c4e7a2cff302589a669a4fdb88/src/SchemeEval.hs#L10
22:16:06 <siraben> I tried something like, Except over Reader over Cont over State, but the Except <> Cont interaction didn't work out
22:16:28 <siraben> In a sense I don't want Haskell's full range of continuations, just the Scheme continuations, if that makes sense
22:16:42 <davean> siraben: That sure is a scheme interpriter that reads like scheme!
22:17:09 <siraben> davean: Heh, it was converted directly from the denotational semantics of R5RS
22:17:20 <davean> I ... could have guessed
22:18:34 <siraben> Maybe it was someone here who mentioned that they were working a similar project and was planning to encapsulate primitive operations in a typeclass
22:18:56 <siraben> Like a CSEK machine.
22:18:58 <siraben> CESK*
22:20:32 <siraben> Hm, http://matt.might.net/articles/cesk-machines/
22:21:10 <topos> i mean, edwardk's been doing some of that with his livestreaming. I'm working on a machine based on matt might's abstract abstract interpreters work as well
22:21:21 <edwardk> i need to stream again
22:21:33 <siraben> edwardk: streaming on twitch?
22:22:20 <edwardk> yeah, i moved and never bothered to get set back up
22:22:38 <siraben> topos:  are you referring to http://matt.might.net/papers/might2010free.pdf ?
22:23:09 <siraben> Wow, that circular dependence in figure 1 is exactly the issue I came across
22:23:10 <topos> yeah
22:23:49 <topos> but this one http://matt.might.net/papers/vanhorn2010abstract.pdf
22:24:00 <topos> it's all gravy tho
22:24:25 <edwardk> siraben: that interpreter is nice and direct
22:25:02 <siraben> edwardk:  the r5rs-denot one?
22:25:14 <edwardk> capturing scheme continuations in a CESK machine is super simple. Capture K, restore K,.
22:25:19 <edwardk> yeah
22:25:28 <siraben> Thanks.
22:27:18 <siraben> topos:  interesting paper
22:28:59 <siraben> These techniques, do they carry over to compilation as well? I haven't looked much into abstract interpretation.
22:34:32 <edwardk> abstract interpretation can be a good first step towards compilation, as you get a sense of what cases are and aren't possible in each use site
22:35:09 <edwardk> there's another paper by van horn and might on abstract abstract machines, that i'm particularly fond of
22:35:10 <edwardk> https://arxiv.org/pdf/1007.4446.pdf
22:35:20 <edwardk> that paper is the one that made abstract interpretation finally gel for me
22:37:07 <siraben> edwardk:  Heh, the notation looks somewhat intimidating
22:37:41 <edwardk> all the greek letters and hats?
22:39:56 <edwardk> the paper starts with a CEK machine, which you can squint at a krivine machine and see, adds a store, moves continuations into the store, then starts to play with what happens if you make the store, etc. less accurate approximations.
22:40:31 <siraben> Ok, so on closer inspection it may be tractable for me.
22:41:50 <Axman6> topos: for the encode loop, have you tried the version which just does the maths to compute the hex character for the nibble?
22:44:01 <edwardk> one thing all these papers on quantitative type theory seem to sweep under the rug is how much harder it makes inference for things like what to instantiate meta variables to.
22:44:28 <edwardk> (just to mention a frustraton that is on y mind)
22:44:46 <siraben> edwardk:  what paper are you reading?
22:45:14 <edwardk> well. i've been trying to build a little "ELF" style logical framework with quantitative type theory bolted in.
22:46:01 <siraben> Quantitative type theory differs from linear type theories in what way?
22:47:20 <edwardk> the papers in question are https://personal.cis.strath.ac.uk/conor.mcbride/PlentyO-CR.pdf which came first https://bentnib.org/quantitative-type-theory.pdf which fixed it up. then abel and bernardy which gave us the formulation for linear haskell, https://wg28.mpi-sws.org/technical-presentations/files/cfdb7_uploads/1584070624-w28-qtt-zion.pdf and finally the choudhury et al paper 
22:47:20 <edwardk> https://richarde.dev/papers/2020/quantitative/quantitative.pdf
22:47:28 <edwardk> but the gist is this
22:47:30 <edwardk> take your type theory
22:47:33 <edwardk> look at the environments
22:47:48 <topos> Axman6 yeah
22:47:49 <edwardk> you have Gamma, x : T
22:47:52 <shafox> Anyone can share their ~/.cabal/config file. I want to know what I can do with all the options. 
22:48:10 <edwardk> add a member of some semiring with nice properties to the : annotating each typing judgment
22:48:27 <edwardk> e.g. you might choose the semiring to have 0 for erased, 1 for present
22:49:03 <edwardk> and then you run through all the usual rules of type theory, treating environments as semimodules (like vector spaces) over this scalar semiring
22:49:09 <edwardk> why?
22:49:15 <topos> Axman6 when i benched, computing the modulus was faster than doing yet another index look up on a different table. but i have come a long way with it and i might need to revisit
22:49:23 <edwardk> you get to use this to compute erasure for one.
22:49:57 <edwardk> but if you replace the semiring with {0,1,many} with 1+1=many, you get something like linear haskell
22:50:02 <edwardk> but you can pick all sorts of other semirings
22:50:19 <edwardk> e.g. just using the natural numbers would get you something like granule where you get exact usage counts of all variables
22:50:30 <siraben> Oh that's fascinating, so the resource usage is determined by the chosen semiring?
22:50:37 <topos> Axman6 sorry - wires crossed. i can get rid of that shift, yeah
22:50:51 <edwardk> or using {0,1,affine,relevant,unrestricted} you can get something like david walker's post in "Advanced Topics in Types and Programming Languages"
22:50:53 <edwardk> yeah
22:51:16 <edwardk> i've been using a semiring with 6 elements, rather than those 5. {0,1,affine,relevant,STRICT,unrestricted}
22:51:23 <edwardk> where strict and relevance are closely related but not the same
22:52:37 <edwardk> in my toy type theory 1, strict, relevant all act as the dividing line at which i no longer have thunks in my data types. 0 doesn't exist at all in the result, and affine/unrestricted are lazy
22:53:29 <edwardk> and 1 + 1 is relevant, but 1 + affine = strict rather than unrestricted like it'd be in the 5 point semiring above
22:53:51 <edwardk> strictness then becomes the claim that you will definitely consume at least one of the copies of the thing you passed out to a bunch of sites
22:54:01 <edwardk> where relevance is the claim you will consume ALL of them
22:55:53 <edwardk> the dividing line is something like how relevance _could_ be managed by something that basically copied each A and made two of them and passed each out. Then relevance/linear in that universe would have you delete the structure when you're done. affine would still need the gc to help to know how to deal with something that was dropped, alternately you could maybe refine the notion of affine in that semiring to have versions that both 
22:55:53 <edwardk> supported unrestricted style dropping and ones that used an explicit finalizer to free like rust
22:56:38 <edwardk> anything stuffed in a linear/relevant resource can get sort of freely added to some kind of gc root list, and you then don't even need to walk the relevant/linear stuff
22:56:54 <edwardk> because you know it'll be consumed (and hence removed from the global gc root list) eventually
22:57:12 <edwardk> this is a very resource-centric view, but one i've been playing with since i first found haskell
22:57:24 <edwardk> qtt gave me the right framework, i was missing the + for the semiring
22:58:32 <edwardk> now, this is still missing a last component, which is a notion of uniqueness, linearity says the consumer will definitely use up the thing, uniqueness says that you are being handed the only copy, and that the producer hasn't passed around any pointers to anybody else
22:59:02 <edwardk> but the quantitative type theory stuff basically doesn't prejudge too much what the semiring means
22:59:06 <edwardk> it is more of a formal tool
22:59:33 <edwardk> and your semantics then clears up what you mean, the choudhury et al paper at the end of the reading list i dumped is actually quite clear.
22:59:45 <Axman6> topos: nibbleChar :: Word8 -> Word8; nibbleChar (W8# n) = W8# (int2Word# (word2Int# n +# (48# +# ((geWord# n 10##) *# 39#))))
23:00:29 <siraben> edwardk:  that is fascinating. do you have a repository for this?
23:00:36 <edwardk> anyways my general problem is this for a _ in my toy type theory i usually drop in a meta variable.
23:00:54 <edwardk> github.com/ekmett/haskell has been where i've been scribbling thoughts, but i don't have any of the qtt stuff committed yet, it breaks the whole toy
23:01:36 <Axman6> topos: using that makes converting it to work a word at a time "trivial"
23:02:53 <edwardk> for a meta variable the way i handle it is i look around at all the locally bound variables where i created and placed the meta variable and i just build a meta variable that gets all those as arguments.  \x y z. foo M  -- where M could reference x y and z requires M to know about contexts, and is messy, so instead I make it     \x y z. foo (M x y z). Now if M instantiates to a constant valued function that ignores its arguments, the 
23:02:53 <edwardk> normalization done by my unification engine gets me the answer i want.
23:02:59 <edwardk> but here I don't know the usage data for M.
23:03:03 <siraben> edwardk:  this metavariable is not the same as a type variable?
23:03:10 <edwardk> which mucks with my ability to do type inference
23:03:34 <edwardk> meta variables here are like holes in the program. 'please put here the only thing that makes sense'
23:03:58 <siraben> Oh, nice style for a repository. I might steal that, hehe. Maintaining separate repositories is annoying for small projects.
23:04:14 <siraben> Right, I'm thinking of like Coq's metavariables then, ?A
23:04:31 <edwardk> yeah. these are little existential holes
23:04:34 <siraben> I use _ quite a lot when I want Coq to infer it
23:04:53 <siraben> rewrite (mul_assoc _ b  c)
23:04:58 <edwardk> and they come up a bunch when you just write something like id :: {A} A -> A
23:05:44 <siraben> Yes
23:05:56 <edwardk> i have an implicit argument A there. great, but it really took id : {A : _} A -> A, and then when elaboration happened it expanded _ to a meta variable, and figured out that it should be 'type'
23:06:41 <Axman6> topos: magic numbers in there are 48 = '0', 39 = 'a' - '0' - 10
23:07:15 <edwardk> the general model is something like start out with a surface language with a bunch of extra nonsense and file locations and stuff in it, convert to some internal representation used for elaboration that has all these meta variables in it, then crush them out and you get the final 'core' equivalent.
23:07:59 <edwardk> typechecking/inference produces terms in the elaboration form as witnesses that a given source term has a type
23:08:07 <edwardk> but source terms have all sorts of extra bells and whistles.
23:08:13 <edwardk> like in haskell we have where vs. let
23:08:22 <edwardk> complex patterns, top level decls...
23:10:02 <edwardk> anyways, right now i'm currently wrestling with how to get resource usage constraints on each of my meta variables right, because _normally_ i can just sprinkle them around in my terms, but now i have a problem. their usage of resources affects how many resources i have to typecheck the _rest_ of the term.
23:10:42 <edwardk> so i could try to carefully dance around and use up all the other resources and give them what is left, but i don't _really_ have a subtraction for resources (i'm in a semiring)
23:11:05 <edwardk> i could also do something like first typecheck in the boring {0,1} presence/absence semiring, use that to flesh out my metas
23:11:56 <edwardk> and then try to use backwards the fact that i have a semiring homomorphism from my final semiring to that semiring, and try to use that to 'redo' the job now that i actually have a sort of minimal bottom up chunk of resource usage data to go off
23:12:26 <siraben> Hmm, seems tricky. I have no idea how semirings work when applied in a type theoretic context yet.
23:13:32 <edwardk> if you look at https://richarde.dev/papers/2020/quantitative/quantitative.pdf in figure 1, the rule for ST-App is my bane
23:15:20 <edwardk> because you have to infer the type of (f) in (f x), then use that to get the usage information for the application rule. but if f is a meta variable then we have no usage to use to fill in
23:16:14 <edwardk> the fact that these judgments tend to be written in a style where it isn't clear how to infer rather than just check doesn't help the story
23:16:20 <siraben> These typing rules don't seem to have meta variables, you added them?
23:16:30 <Axman6> anyone know of a tool which accepts assembly and can give you how much instruction level parallelism it might have?
23:17:17 <siraben> I meant like, meta variables being part of the source language, not in the meta language used to describe the language (which does have meta variables)
23:17:19 <edwardk> correct. because i need inference and inference wants to put little holes in various places. (also that type theory in that figure is non-dependent, and mine is dependently typed)
23:17:40 <siraben> Have you thought about using bidirectional type inference?
23:17:48 <siraben> That's a technique I learned recently, very useful.
23:17:48 <edwardk> this is in a bidirectional type checker =)
23:18:10 <siraben> Where are the inferred vs. checked types then?
23:18:53 <edwardk> https://github.com/AndrasKovacs/implicit-fun-elaboration/blob/master/fcif/Elaboration.hs#L513 -- here's a version from andras kovacs
23:20:22 <edwardk> that is in the 'infer' case for app, which delegates to an infer for the function, notice how it has to manufacture a couple of meta variables
23:20:55 <edwardk> (notice there is a separate 'check' and infer and check bounce back and forth, bidirectional style
23:21:11 <siraben> Heh, going straight for the IO monad
23:21:14 <siraben> Right
23:21:49 <edwardk> yeah andras runs in strict haskell and does evil things for IO
23:22:05 <edwardk> I use slightly less evil things, but then unsafeInterleaveIO all over the same code =P
23:22:33 <edwardk> i've been basing things pretty closely on his work because he gets some pretty great type inference
23:22:48 <edwardk> e.g. he can handle the runST $ do ... stuff without any magic rule for $.
23:23:05 <edwardk> so i more or less grabbed that wholesale
23:24:21 <siraben> Wow, he has an elaboration-zoo repo as well
23:24:40 <edwardk> if you rip out all the exotic Tel, PiTel, LamTel, Rec. stuff out of his type theory he gets a pretty good baseline typechecker (modulo the usual sort of implicit reordering that agda does)
23:25:10 <edwardk> We talked quite a bit at ICFP and it served as a good forcing function for me to stop dilly-dallying with other ways to do this, and just raid his toolbox for tricks
23:26:11 <edwardk> my usecase is a bit weird
23:26:23 <edwardk> i'm currently trying to do this to build a "logical framework" like LF
23:26:36 <edwardk> but with the qtt bits sprinkled on top
23:27:10 <edwardk> LF is what you get if you take a dependent type theory, lop it off at the knees and stunt its growth. 
23:28:31 <edwardk> you remove all the bits that have to do with sigma, maybe cripple pi so you can make types that depend on terms but not use other things, force yourself to only have terms, types and kinds, and no universe tower, don't bother making traditional data types and induction principles and the like.
23:28:59 <edwardk> which seems like an awful lot of surgery to do
23:29:25 <edwardk> but once you've butcher the type system in this way, it becomes really easy to reason about HOAS.
23:30:27 <edwardk> e.g. you can define tm : type; lam : (tm -> tm) -> tm; app : tm -> tm -> tm -- and have a higher order abstract syntax for terms. and you can know that that function from tm -> tm in lam just places the argument somewhere, BECAUSE IT CANT PATTERN MATCH ON IT.
23:30:44 <edwardk> so you write your semantics in this logical framework and what have you
23:31:28 <edwardk> and then reason about meta theorems about what you wrote, and those are simplified by the fact that the language the code manipulating your terms or judging things about your terms was written in is comparatively simple
23:31:58 <edwardk> i figured i'd share because you started from 'hey i wrote down the denotational semantics of r5rs and ran them'
23:32:48 <edwardk> normally to work with syntax tree representations you have to go off and fight with debruijn indices/levels or use 'parametric hoas' or use a library like bound or unbound or nominal or name...
23:33:01 <edwardk> but each of those complicate reasoning about the program that manipulates those terms
23:33:46 <siraben> Thanks, that was insightful.
23:33:47 <edwardk> so the old-school bob harper way to handle that was to build a crippled but still usable type system that was good enough for building up those judgments
23:34:15 <siraben> Capture-avoiding substitution is a mess, I've recently using de bruijn to implement a linearly typed lambda calculus.
23:34:36 <siraben> Thinking about implementing lambda pi from https://www.andres-loeh.de/LambdaPi/LambdaPi.pdf
23:35:05 <edwardk> i've been playing with ways to extend an LF, because, say, working on a language that has linear types in LF is awful. your binding forms don't match the host LF's binding forms in how they are managed and so all of a sudden you're stuck in debruijn hell... in a crippled type theory
23:35:06 <siraben> edwardk:  do you know if tagless final can be used to implement dependently typed languages?
23:36:00 <edwardk> but if the lf itself has qtt, then it becomes pretty easy to reason about any language that uses a binding form that has constraints that look like any subsemiring of the ones offered by the host  language.
23:36:12 <edwardk> (there was some work on linear logical frameworks in the 90s)
23:36:20 <edwardk> the answer is a hard 'sorta'
23:36:33 <edwardk> so lets use the running example of an LF
23:36:37 <edwardk> because its on my brain
23:36:45 <edwardk> here we have 'dependent types' where types can depend on terms
23:37:33 <edwardk> i wrote some code the other day and posted it to twitter for how to do typed "normalization-by-evaluation"
23:37:56 <edwardk> https://gist.github.com/ekmett/6c64c3815f9949d067d8f9779e2347ef
23:38:40 <edwardk> if you look at the very bottom of that code id_, k, kid_ are id, const, and const id in the little toy 'untyped except i happen to be borrowing haskell's types' typed language.
23:38:59 <edwardk> basically Val represents terms crushed down to normal form.
23:39:06 <edwardk> and expressions allows for you to be sloppier
23:39:32 <edwardk> nf takes an expression to a val, which is internally representing something in beta normal form, and then converts the val back to an expr which happens to be in beta normal form
23:39:59 <edwardk> so what does this have to do with dependently typed languages? this is clearly an untyped language
23:40:06 <edwardk> well, haskelly-typed
23:40:31 <edwardk> well, an old paper of conal elliott's (maybe his thesis, i forget) introduced a notion of 'approximately well typed' programs
23:41:18 <edwardk> which is to say if you run through an LF and rip out all the dependent bits, turning [| Pi x : A. B |]. into [| A |] -> [| A |] ...
23:41:26 <edwardk> er B
23:41:43 <edwardk> then you get a non-dependently typed approxmation of the types in the LF
23:42:09 <edwardk> and termination of unification, etc. in the LF is sort of governed by termination of it for this crippled type
23:43:14 <edwardk> so if you were working with something in the LF corner of the lambda cube where you have limited dependent types? then you can use what host language types those types erased to and have an 'approximately well typed' scheme for working with it, implemented finally tagless style
23:43:54 <edwardk> but the finally-tagless bits? i personally tend to go for heavier tagged deep embeddings because i find they are really frustrating to work with when you want sweeter sugar
23:44:11 <edwardk> er they here being finally tagless
23:44:14 <siraben> That makes sense
23:44:40 <edwardk> http://www.cse.chalmers.se/~josefs/publications/svenningsson2015combining.pdf is a paper on how to do typed EDSLs that I rather like
23:44:53 <edwardk> iceland jack posted a link to it the other day on twitter and it reminded me of its existence
23:45:09 <edwardk> in theory a version of that that is 'approximately well typed' could work for an LF.
23:45:28 <edwardk> so that gives the 'can i get the types right' answer with a sort of strong maybe.
23:46:25 <edwardk> for working with dependent types in general i tend to stick to real syntax trees and libraries like bound.
23:46:54 <edwardk> https://hub.darcs.net/dolio/upts/browse/Language/UPTS/SyntaxTree.hs#39 is an example of a small pure type system with universe polymorphism by dolio that uses bound
23:47:00 <siraben> I haven't used the bound library before, will it handle the scoping and substitution for me?
23:47:05 <edwardk> yeah
23:47:26 <edwardk> your Term type becomes a monad, using (>>=) for substitution.
23:47:37 <edwardk> and Scope () Term becomes 'and i need an extra bound variable'
23:47:42 <MarcelineVQ> is the purpose of that 'approximately well typed' to check if something could be correct, with less work, before you check fully?
23:47:44 <edwardk> and you use >>>= to walk over that
23:47:50 <edwardk> MarcelineVQ: yeah
23:47:58 <edwardk> catch most of the stupid programmer bugs
23:48:02 <edwardk> basically a form of lint
23:48:49 <edwardk> maybe if you cps transformed everything you could get into a state where you could do reflection to create the types off terms locally that you'd need... or you could wait for richard to finish dependent hakell
23:48:50 <edwardk> er haskell
23:49:36 <edwardk> https://hub.darcs.net/dolio/upts/browse/Language/UPTS/SyntaxTree.hs#73 see how the >>>= is used for the body of the lambda?
23:50:10 <siraben> Ah
23:50:12 <edwardk> https://www.schoolofhaskell.com/user/edwardk/bound is an article i wrote on bound
23:50:37 <siraben> great, saved.
23:50:51 <edwardk> the key is that when you need a Term and have a Scope () Term you need to give me the value for the extra variable. it won't typecheck if you f up the name manipulation
23:51:30 <edwardk> abstract1 and instantiate1 give you tools for converting from Scope () m <-> m by capturing/instantiating
23:51:43 <edwardk> bound works best when you're working with a language with one type of name
23:52:00 <edwardk> we made it work for ermine by lots of hand-holding
23:52:27 <edwardk> but its quite pleasant to just walk terms, be able to >>= for substituting in your environment, use foldMap to extract free variables.
23:52:44 <edwardk> Scope is basically a 'faster' EitherT
23:53:24 <edwardk> abstract and instantiate handle the case where you want to bind multiple variables at once, (i don't have to just put on a (), maybe i'm binding 8 variables at once in a recursive let binding/where clause, etc.
23:58:45 <gnumonik> I thought I remembered some function in the lens library that returns a list of (maybe strings that represent?) the lenses/etc that exist for a datatype. Anyone know what that is or am I mistaken? 
