00:00:30 <ski> why not have empty base case for `Dots' ?
00:00:31 <fog47> the problem with this way, using SSD and Dots
00:00:47 <fog47> ski: that wouldnt work. 
00:01:00 <fog47> actually it might
00:01:03 <ski> actually, so far, that paste is more readable than the previous one
00:01:05 <fog47> no real reason then
00:01:30 <fog47> ski: yeah i just realised that it might actually be a way more informative thing to link!
00:01:50 <fog47> its truncated about halfway down before the commented out code starts 
00:02:00 <ski> `SSD' ? you mean `SSP' ?
00:02:14 <fog47> damn did i get that wrong this whole time!
00:02:18 <fog47> ok nvm
00:02:25 <fog47> ok, so the thing with these SS*P* s
00:02:32 <fog47> is that they discard the "state"
00:02:36 <fog47> i need to keep that
00:02:44 <fog47> so i made another thing which does that ok
00:02:51 <fog47> but then i needed to keep the scanners
00:02:58 <fog47> and then ther problem with the k stanrted
00:03:09 <ski> (there's also `data ASP a b = Get (a -> ASP a b) | Put b (ASP a b)'. "Asynchronous Stream Processor")
00:03:17 <fog47> argh!
00:03:28 <fog47> nonono
00:03:44 <fog47> i need to fix this bug or my code will melt into a heap of garbage 
00:03:56 <ski> but iirc, you wanted one output for each input, alternating between accepting input and producing output
00:04:16 <fog47> no..
00:04:33 <ski> (to model your "modifiable functions", that is)
00:04:35 <fog47> its just like dots!
00:04:48 <fog47> i just want plenty of them in a list and a rule to compose them together
00:04:51 <fog47> i have all that
00:04:55 <fog47> it just doesnt typecheck!
00:05:16 <ski> maybe because it's still confused, in some way ?
00:05:30 <fog47> its because the kinds hate me
00:06:19 * hackage phonetic-languages-ukrainian 0.1.0.0 - Prepares Ukrainian text to be used as a phonetic language text  https://hackage.haskell.org/package/phonetic-languages-ukrainian-0.1.0.0 (OleksandrZhabenko)
00:06:24 <ski> s/atina/atena/
00:08:11 <fog47> here, link is the composition thing; https://pastebin.com/raw/PsYCnXgj
00:08:41 <fog47> type GetDotResult sc1 sc2 s1 s2 = 'K (LinkScanner sc1 sc2 s1 s2) (LinkState sc1 sc2 s1 s2)
00:08:56 <fog47> 1 corresponds to the head being input
00:09:14 <fog47> 2 corresponds to the carried result of what dotting together all the other values in the tail 
00:09:40 <fog47> i use this result to replace the carried 2
00:09:49 <fog47> and repeat with a new head
00:10:17 <fog47> but it breaks, complaining that it cant compute this type family
00:11:19 <fog47> it cant match the result with; K k1
00:11:26 <fog47> which it seems to want for some reason
00:11:47 <fog47> it *can* see all of sc1 sc2 s1 s2
00:11:56 <fog47> so i cant see how it could be an ambiguity thing
00:13:19 <ski> `sc1',`sc2',`s1',`s2' are all singletons, in the signature for `ConsKScanners'
00:13:36 <ski> (i noted that, before reading what you said, just above)
00:14:00 <ski> hence that constraint involving them is useless
00:14:21 <fog47> FFS!!!!!!!!!!!1
00:14:26 <fog47> omg
00:15:03 <ski> did you mean to say `scanner', in place of `sc1', &c. ?
00:15:19 <fog47> ah, that doesnt change anything
00:15:31 <fog47> you can actually just delete that constraint
00:15:37 <ski> (perhaps GHC ought to have a warning for singletons ..)
00:15:42 <fog47> yeah!
00:15:52 <fog47> damn, i thought that was it...
00:16:52 <fog47> better use this one to save that confusion 
00:16:53 <fog47> https://pastebin.com/raw/3iQ0DMVY
00:18:59 <ski> oh. i guess without `AllowAmbiguousTypes', it would have complained about that
00:19:01 <fog47> could it be infering k from the tail?
00:19:20 * hackage dobutokO-poetry 0.17.0.0 - Helps to order the 7 or less Ukrainian words to obtain somewhat suitable for poetry or music text  https://hackage.haskell.org/package/dobutokO-poetry-0.17.0.0 (OleksandrZhabenko)
00:19:29 <fog47> no thats doesnt make sense
00:19:34 <fog47> im really struggling here
00:20:51 <fog47> i dont think that error is very good really
00:21:07 <fog47> i cant tell why it thinks it should be some arbitrary k and the k i want it to be
00:22:23 <ski> hm. i still don't understand what this is for, but what if you make `k' an explicit argument of `KScanners' ?
00:22:47 <fog47> ok!
00:24:33 <fog47> woop!
00:24:36 <fog47> that works
00:24:46 <fog47> damn compiler!
00:24:51 <fog47> why did it need that?
00:25:10 <fog47> its inferable from like a million places
00:25:26 <ski> seems it thought `ConsKScanners' was to be polymorphic in `k'
00:25:38 <fog47> oh yeah, it kind of is
00:26:11 <fog47> thats the kind of the state taken by the scanner of the result of dotting together them all
00:26:45 <fog47> ok! so now i have programs that are linearly composable, and modifiable!
00:27:00 <fog47> what were you saying before about having them branch in parallel?
00:27:12 <fog47> seems like i could do with more than just linear linkages 
00:27:29 <fog47> at the moment its like i can only make programs using (.)
00:27:42 <fog47> which is quite limiting... 
00:27:52 <fog47> i guess i need multiple input arguments next
00:28:13 <fog47> calling that MISO for multiple input single output
00:28:22 <fog47> then it can take a HList of arguments as input
00:28:30 <tdammers> sim590: you can trivially wrap your monadic logging API by providing a no-op dummy logger monad that is just a newtype over Identity (and has something like log _ = return ()), and a runNoLogging :: NoLogging a -> IO a
00:28:32 <fog47> and i can start to have programs in tree shapes, which is better
00:28:54 <ski> i don't recall talking about branching in parallel
00:29:21 <fog47> you presented a Lens looking thing with Get and Set that was supposed to be like SSP somehow
00:29:39 <fog47> but anyway, i ended up not being able to use the SSP thing because it discarded all the types
00:29:41 <ski> hm, you mean `ASP' ?
00:29:51 <fog47> it meant i could put the modifiable functions into the Dots container
00:30:00 <fog47> but, i could never recover their original form
00:30:22 <fog47> i didnt like how it was, upon evaluating the modifiable function, returning the modified function, in a modified form
00:30:33 <ski> i suppose `ASP' is probably not that interesting to you, in this context. i just mentioned it, to hint at what "Synchronous" in `SSP' stood for
00:30:46 <fog47> hmm
00:30:55 <fog47> i guess thats where i got the idea of parallel from
00:30:57 <ski> "discarded all the types" ?
00:31:03 <fog47> i was thinking of ZipWith
00:31:29 <fog47> like outputing them not into each other in the same list, but associating positions in 2 lists and passing the outputs like that
00:31:42 <fog47> ski: yeah, it didnt need all the states
00:31:54 <fog47> thats how it could end up just being dotted together
00:32:29 <fog47> with this even more complicated K version, i can even output a different modifiable function alltogether
00:32:46 <ski> i'm not understanding any of your last couple of statements
00:33:03 <fog47> like, i can start with a list of a mix of trees and lists and single modifiable functions, and link them all together into a tree or a list!
00:33:19 <fog47> (thats refering to k, the shape of the type level info)
00:33:44 <fog47> oh regarding zipwith. you wouldnt dot together all the functions in the list
00:33:50 <fog47> instead you would zipWith (.)
00:34:06 <fog47> then i can have basically non-interacting threads
00:34:07 <ski> @type zipWith (.)
00:34:09 <lambdabot> [b -> c] -> [a -> b] -> [a -> c]
00:34:12 <fog47> and at some point they can mix
00:34:23 <fog47> well this would be HZipWith
00:34:36 <fog47> and it would be over the hetrogenous "Dots" like container
00:34:44 <fog47> erm, no it wouldnt
00:34:46 <ski> i don't see the point of the `HList' stuff
00:35:04 <fog47> a -> b : b -> c : c -> d
00:35:13 <fog47> if its homogenous its just a -> a
00:35:19 <fog47> you have to match up the types in pairs
00:35:34 <fog47> thats what the constraint between the "carried" dotsResult thing is doing
00:35:52 <fog47> i cant just match the types
00:36:05 <fog47> because the result of link determines the "shape" of the output scanner
00:36:21 <fog47> i need to keep track of that, just as with intermediate types in the Dots list
00:36:48 <fog47> i need to say "the head must dot together with the result of dotting together the tail" 
00:37:00 <fog47> which is easy if the functions arent modifiable
00:37:13 <fog47> thats what the a b c params at the end are for
00:37:47 <fog47> man, i was looking forwards to presenting all this and i have done a terrible job
00:37:56 <fog47> might wait until i have more readable code first
00:38:09 <fog47> still, pretty exciting though
00:38:14 <fog47> functions on programs! 
00:38:47 <fog47> programs that modify themselves when modifying other programs ... !!!
00:39:06 <ski> you could use something like `data IxList f :: k -> k -> * where Nil :: IxList f i i; Cons :: f i0 i1 -> IxList f i1 i2 -> IxList f i0 i2', then `IxList (->) a d' could store one function of type `a -> b', one of type `b -> c', and one of type `c -> d'
00:39:39 <ski> i guess that's what `Dots' do .. except that you also have a list of types, as parameter
00:40:03 <fog47> right, and all these different versions have different numbers of parameters
00:40:07 <ski> (and i dunno why the data constructors of `Dots' needs `Composable' constraints)
00:40:09 <fog47> i have to put them all in a tuple
00:40:23 <fog47> ski: its all very badly done, im sorry
00:40:42 <fog47> wait, isnt composable just to say it can be dotted?
00:40:51 <fog47> its just part of category
00:40:53 <ski> hm. i guess the type list is the "internal types", in the path
00:41:18 <ski> fog47 : yes. but why does `Dots' need to care about that ?
00:41:53 <ski> why not simply add `Composable arr', whenever you're using `Dots arr xs a b', and you need that constraint ?
00:42:19 <fog47> ah, because you have (a -> b)
00:42:24 <fog47> i have (arr a b)
00:42:30 <fog47> i need that there is an instance 
00:42:47 <fog47> i dont see anything wrong with placing the constraint at the datatype constructor
00:43:04 <fog47> i dont want the contain being used to contain things that cant be dotted together, its called Dots!
00:43:28 <fog47> you Ix version above seems ok for function arrows as `arr' though
00:43:41 <fog47> what im tring to do is have "scanner" everytime there is "arr"
00:43:52 <fog47> and it takes this extra "state" param
00:44:02 <fog47> where i have this tuple of all different types
00:44:10 <fog47> some of them have lists of internal states
00:44:16 <fog47> some have lists of internal scanners
00:44:19 <fog47> some are trees
00:44:32 <fog47> i cant just keep adding extra params
00:44:53 <fog47> it needs to have the same number of params so i can always write "scanner state a b" instead of "arr a b"
00:45:21 <fog47> and i just have to make the state polykinded for storing all the different type information all the different representations of modificable functions have
00:45:45 <fog47> im saying modifiable functions when i want to be precise, im getting confused about what im calling a scanner 
00:45:58 <fog47> a scanner is certainly exactly that which is MapAccum
00:46:05 <fog47> it shouldnt really be anything else
00:46:27 <fog47> but its this state like carry that is used in scan
00:46:44 <fog47> erm, that is used in mapAccum that makes it subsume scan
00:47:10 <fog47> i just like how i have (++) and (:) for these lists of modifiable functions
00:47:16 <fog47> that are both instances of "link"
00:47:38 <fog47> so i can store lists and values and string them all together using link 
00:48:05 <fog47> this means whatever bizzare modifiable functions are contained in this list of pairwise linkable modifiable functions
00:48:33 <fog47> i can kind of flatten them down a layer by folding with link (like in Dots folding with (.))
00:49:14 <fog47> basically, i cant nescarily link two modifiable functions
00:49:22 <fog47> but if im using lists of modifiable functions
00:49:26 <fog47> as modifiable functions
00:49:33 <fog47> then i can link them, using (++)
00:49:41 <fog47> and just use the result as another modifiable function
00:49:59 <fog47> it kind of means as flat as it can ever get is into this KScanners thing
00:50:11 <fog47> but that nesting within that can give trees etc
00:50:44 <fog47> and since values, lists and trees, are all linkable modifiable functions, i can jumble them all together into a list
00:50:50 <ski> fog47 : my `IxList' didn't talk specifically about lists of composable functions. you could use another type than `(->)' (e.g. `SSP'), in place of `arr'
00:50:54 <fog47> and then flatten them down using fold with link
00:51:11 <fog47> i cant use SSP!! it discards the type info
00:51:25 <fog47> it means i can do modifiable functions using the Dots container
00:51:30 <fog47> but thats no good
00:51:44 <fog47> hence making this KScanners container, to keep that info
00:51:57 <fog47> otherwise i have to discard the states when converting to SSP
00:53:05 <fog47> you can do catinate on a Dots of SSD in te paste
00:53:36 <fog47> and if you run dots of SSD as a modifiable function, casing to it automatically i think from Modifiablefunctions
00:53:43 <fog47> then it is stuck as an SSD
00:54:07 <fog47> we want (s -> a -> (b,s)) not (s -> a -> (b,SSD .. ))
00:54:45 <fog47> if s was SSD it would be fine, but thats not really very good. it means i cant have any type information
00:55:03 <ski> "it discards the type info" -- why is that a problem ?
00:55:26 <fog47> clearly it shouldnt be or you wouldnt be asking that
00:55:37 <fog47> something to do with runtime type elimination?
00:55:45 <fog47> everything being equivalent to some typeless version
00:55:56 <fog47> i like the type info, and i think it was important somewhere
00:56:07 <fog47> but your making me think i might be mistaken for thinking so
00:56:13 <ski> do you need someone else to be meddling about with the internal states/types of your modifiable functions ?
00:56:21 <fog47> yes
00:56:26 <fog47> :-D
00:56:40 <ski> how so ?
00:56:48 <fog47> i might want to go into the dots like container, and change one of the functions
00:56:52 <fog47> i could swap an SSD
00:57:00 <fog47> but maybe i wanted it to typecheck..
00:57:27 <fog47> you cant distinguish between the internal representations of these SSP's
00:57:45 <fog47> like, i could just work with instances of ModifiableFunction
00:58:08 <fog47> and that way keep the type info, get the same functionality as being able to ignore or hide it with SSP
00:58:43 <fog47> like, i can ensure my program trees remain the same shape on actual modification
00:59:08 <fog47> i would need to see if the thing being swapped was a list or a tree or whatever
00:59:28 <fog47> i can then say, you can swap it as long as it has the same shape and size
00:59:46 <ski> hm. couldn't you use e.g. `SSP a b -> SSP (Either (SSP a b) a) b', to allow dynamically updatable behaviour ("change one of the functions","i could swap an SSD") ?
00:59:48 <fog47> and end up, via a constraint, that some shape of the program is maintained during an edit
01:00:32 <ski> @type right
01:00:35 <lambdabot> ArrowChoice a => a b c -> a (Either d b) (Either d c)
01:01:21 <fog47> i mean instead of s1 a -> (b,s1) : s2 b -> (c,s2) ...  
01:01:34 <fog47> as SSD a b : SSD b c
01:01:45 <fog47> i cant constrain on the s1 or s2
01:01:50 * ski . o O ( Fudgets )
01:02:04 <fog47> i might not want to be able to change those on update, for example
01:02:27 <fog47> im not sure what your dynamic SSP thing above was for...
01:03:20 <fog47> your just nesting them?
01:03:50 <ski> hm. i guess it would need to be slightly modified, for the synchronous case
01:03:53 <fog47> im not sure i can go on tbh. ill return when i have some code that isnt complete trash 
01:04:26 <ski> the idea was to be able to tell it to replace its current behaviour, the `SSP a b', by a new one, that is how it'll behave from that point on (until further notice)
01:04:35 <fog47> ski: i cant think of synchronous without something to do with inverted pendulums on a plain 
01:04:48 <ski> heh
01:05:08 <fog47> ah, so you can swap it for a new one
01:05:18 <fog47> i just mean to literally swap the element in the list
01:05:40 <fog47> Dots of SSP, and just replace an entry 
01:05:54 <fog47> i might want to constrain over the types of the state during that
01:05:58 <fog47> just for example
01:07:11 <fog47> thanks for the polykinded datatype thing, that bug was troubling 
01:07:15 <fog47> ciao
02:02:19 * hackage reanimate-svg 0.11.0.0 - SVG file loader and serializer  https://hackage.haskell.org/package/reanimate-svg-0.11.0.0 (DavidHimmelstrup)
02:43:20 * hackage yesod-recaptcha2 1.0.1 - yesod recaptcha2  https://hackage.haskell.org/package/yesod-recaptcha2-1.0.1 (ncaq)
02:44:50 <dminuoso> Hiya. Im using cabal v2-build in gitlab-ci. I cache the contents of dist-newstyle. On a new job, it correctly copes the dist-newstyle/ from the cache, but it appears to not be used. Rather, every job rebuilds the entire project from scratch. 
02:45:12 <dminuoso> Ran some shell commands to verify dist-newstyle/ does indeed get copied over intact
02:46:05 <dminuoso> cabal just says ` - odin-0.4.1 (lib:odin-lib) (configuration changed)`
02:46:18 <maerwald> dminuoso: you don't cache the store?
02:48:09 <dminuoso> The store persists as well
02:48:24 <dminuoso> But that's outside of gitlab-ci, since this is just a shell runner. So the store is just on the host
02:49:03 <maerwald> I don't see how you can expect consistent results when you only cache 10% of the build
02:49:21 <dminuoso> Huh?
02:49:50 <dminuoso> I have the cabal store on the host. I cache the dist-newstyle between jobs.
02:49:55 <dminuoso> How is that 10%?
02:50:01 <maerwald> ah
02:52:19 <dminuoso> The curious thing is, in principle it works. If the project is *unchanged*, then nothing is rebuilt. But the slightest change, and it always recompiles all modules.
02:52:28 <dminuoso> Even if locally it just rebuilds a handful of modules
03:11:19 * hackage log-base 0.9.0.0 - Structured logging solution (base package)  https://hackage.haskell.org/package/log-base-0.9.0.0 (arybczak)
03:12:19 * hackage log-postgres 0.7.1.4 - Structured logging solution (PostgreSQL back end)  https://hackage.haskell.org/package/log-postgres-0.7.1.4 (arybczak)
03:13:14 <maerwald> dminuoso: it's like a transplant maybe
03:14:03 <maerwald> but srsly... I dunno. cabal doesn't seem too smart about these things. E.g. if you pass --test-options to cabal test it will think configuration changed too
03:14:54 <dminuoso> Conversely, v2-exec does not pick up on modifications to my sources.
03:15:01 <dminuoso> (Not sure whether thats a bug or by design)
03:15:03 <dcoutts_> maerwald: that should be a relatively simple fix, to exclude that from the build flags
03:16:09 <maerwald> dminuoso: I think it's not supposed to? Only new-run
03:16:50 * hackage hex 0.2.0 - Convert strings into hexadecimal and back.  https://hackage.haskell.org/package/hex-0.2.0 (TaruKarttunen)
03:18:13 <dminuoso> "cabal v2-exec [FLAGS] [--] COMMAND [--] [ARGS] runs the specified command using the projectâ€™s environment. That is, passing the right flags to compiler invocations and bringing the projectâ€™s executables into scope."
03:18:25 <dminuoso> "using the project's environment"
03:18:33 <maerwald> yes, environment
03:18:36 <maerwald> e.g. PATH
03:18:52 <dminuoso> "passing the right flags to compiler invocations"
03:19:02 <dminuoso> That suggests v2-exec would invoke the compiler
03:19:10 <dminuoso> "and bringing the projectâ€™s executables into scope."
03:19:33 <dminuoso> Reading those last two bits, its hard to argue that it shouldn't rebuild
03:20:20 * hackage lorentz 0.6.1 - EDSL for the Michelson Language  https://hackage.haskell.org/package/lorentz-0.6.1 (gromak)
03:21:25 <maerwald> "passing the right flags to compiler invocations" -- why would the mean it needs to build your modules? Do your modules change the *environment*?
03:42:35 <merijn> maerwald: Yes, because the executables of your package are part of the environment as per the docs, so any module change affecting one of those executables requires a recompile of said executable
03:59:21 <Uniaika> Does someone know of a list/blog post/wiki article of some sort with tricks to optimise a program for compilation speed
03:59:44 <Uniaika> (like using plain types instead of typeclasses, stuff like that?
04:00:47 <dminuoso> Uniaika: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/sooner.html
04:01:22 <dminuoso> You can make GHC display various internals with things like -v2, -ddump-timings or -dshow-passes
04:01:28 <dminuoso> That can give you an indication where GHC spends its time
04:01:44 <maerwald> Uniaika: https://www.parsonsmatt.org/2019/11/27/keeping_compilation_fast.html
04:03:37 <Uniaika> thank you maerwald :)
05:56:49 * hackage io-streams 1.5.2.0 - Simple, composable, and easy-to-use stream I/O  https://hackage.haskell.org/package/io-streams-1.5.2.0 (GregoryCollins)
06:07:19 * hackage openssl-streams 1.2.3.0 - OpenSSL network support for io-streams.  https://hackage.haskell.org/package/openssl-streams-1.2.3.0 (GregoryCollins)
07:15:19 * hackage hashtables 1.2.4.0 - Mutable hash tables in the ST monad  https://hackage.haskell.org/package/hashtables-1.2.4.0 (GregoryCollins)
07:30:20 <maralorn> Aufter I saw yesterday something write "logBase 10 2^^53" here, I was know really confused by the log-base package.
07:30:46 <maralorn> someone even. Sorry.^^
07:30:47 <maralorn> I was now
07:31:05 <maralorn> I donâ€˜t even English â€¦
07:38:08 <tomjaguarpaw> Is it possible to make a package available to cabal repl (or ghci) after startup, or do I have to run a new process?
07:44:23 <maerwald> that would be cool, but I've never seen something like that. Especially because the new cabal kind of makes a fake package. GHCi itself has no knowledge about how cabal pulls those libraries into scope
07:52:53 <tomjaguarpaw> I don't even know if GHCi supports unhiding a package after startup. Maybe not.
08:03:20 <lortabac> tomjaguarpaw: did you try :set -package ?
08:04:44 <lortabac> the documentation says "This option causes the installed package âŸ¨pkgâŸ© to be exposed"
08:07:51 <boxscape> running that with -v also says "loading package database <ghc directory>/package.conf.d, so it seems as though even libraries installed after starting ghci might be targetable
08:09:49 * hackage io-manager 0.1.0.3 - Skeleton library around the IO monad.  https://hackage.haskell.org/package/io-manager-0.1.0.3 (MihaiMaruseac)
08:28:19 <tomjaguarpaw> lortabac: Woah, it works! That's cool.
08:40:24 <tomjaguarpaw> Thanks for that. This will make my GHCi experience much more pleasant.
09:09:10 <kuribas> is it possible to generate ghc core and jit compile it?
09:11:17 <c_wraith> in theory, sure.  The tooling isn't built for it at the moment.  In particular, core has no round-tripping serialization format.
09:13:09 <kuribas> I want to make a purely functional language, it would be nice to steal ghcs optimization fases.
09:13:16 <kuribas> like inlining, specialisation, etc...
09:13:52 <kuribas> or I could generate core, let ghc optimize it, then write a core to llvm pass?
09:14:19 <c_wraith> ghc has one of those, too
09:14:20 <geekosaur> there's still no way to feed it core from outside
09:14:23 <kuribas> I don't know how much work it is to write a functional language optimiser...
09:14:34 <kuribas> geekosaur: right :(
09:18:10 <kuribas> interesting: https://github.com/haskell/hoopl
09:18:47 <kuribas> also: https://github.com/haskell/hoopl
09:18:57 <kuribas> https://grin-compiler.github.io/
09:23:23 <tomsmeding> also somewhat related: https://www.patreon.com/posts/introducing-ghc-38173710
09:24:53 <cjsauer> Brand new to Haskell and was a bit surprised to find that `:t length` is `length :: Foldable t => t a -> Int`, specifically that an `Int` is returned, technically allowing for negative lengths. Would something like `Word` be more appropriate (or whatever the `uint` equivalent is)? 
09:25:20 <c_wraith> Nah, it's nice to be able to do useful subtraction on the result
09:26:10 <maerwald> c_wraith: you can convert
09:26:13 <geekosaur> and Word is related to Integer, not Int. and which one *is* related dependson the platform (Word32 or Word64)
09:26:27 <c_wraith> geekosaur: isn't that the same as Int?
09:26:28 <boxscape> In my mind the meaning of "Word" is that you're dealing with something close to the machine; though it could make sense to use a Natural type
09:26:52 <geekosaur> hm
09:27:09 <fendor> A Word is an unsigned integral type, with the same size as Int. https://hackage.haskell.org/package/base-4.14.0.0/docs/Prelude.html#t:Word
09:27:13 <geekosaur> I understood the implementation as being about unsigned vs. signed
09:27:34 <fendor> is there a lambdabot command to do this? 
09:27:36 <fendor> @documentation Words
09:27:37 <lambdabot> Unknown command, try @list
09:27:42 <fendor> @doc Word
09:27:43 <lambdabot> https://haskell.org/ghc/docs/latest/html/libraries/haskell98/Word.html
09:27:46 <fendor> close enough
09:27:53 <fendor> 404
09:28:06 <maerwald> > (3 :: Natural)
09:28:08 <lambdabot>  3
09:28:20 <maerwald> wasn't hard
09:28:26 <cjsauer> I figure that "length" *is* close to the machine, because you're bounded by memory. `Int` doesn't accurately represent the full range of memory due to two's complement.
09:28:56 <c_wraith> yeah, but that only really matters on 32-bit systems, and ghc has mostly abandoned th em.
09:29:00 <boxscape> but afaik length is Int rather than Integer merely for efficiency reasons, not because it's semantically close to the machine. Hence genericLength exists
09:29:32 <c_wraith> on 64-bit systems, most can only address 48 bits of memory anyway
09:29:40 <cjsauer> Ah, I didn't know that
09:29:58 <c_wraith> that'll eventually change, I'm sure
09:31:14 <cjsauer> So it sounds like it's a mix of convenience, efficiency, and possibly legacy? 
09:31:24 <c_wraith> yeah, that sounds right
09:32:15 <c_wraith> note that a list can have a length longer than will fit in memory without breaking anything...  But traversing it to calculate the length in that case would take approximately forever.
09:32:59 <maerwald> how do you disable a flag globally with stack on the command line
09:34:26 <cjsauer> As in "infinite sequences" I imagine. I haven't read that far yet, but I'm coming from Clojure and a similar idea exists there. Still, it was surprising to see length returning a data type that allowed for negatives was my main source of "wut". 
09:34:51 <kuribas> boxscape: could have been Word as well
09:35:10 <c_wraith> you don't need it to be infinite.  just created appropriately lazily.
09:35:33 <boxscape> kuribas yeah, but my point was more that it also makes sense to have a non-bounded type as result type
09:36:12 <boxscape> (so the origin of the bound shouldn't be a semantic one)
09:36:54 <c_wraith> > liftA2 (,) [1 .. maxBound] [1 .. maxBound] :: [(Int, Int)] -- cjsauer: this is far too big to fit in memory in whole, but as long as you traverse it without holding on to too much at once, you can do it.  It'll just take forever.
09:36:56 <lambdabot>  [(1,1),(1,2),(1,3),(1,4),(1,5),(1,6),(1,7),(1,8),(1,9),(1,10),(1,11),(1,12),...
09:38:14 <cjsauer> Makes sense. That definitely justifies what I'm seeing called `genericLength` online, but even that returns `Integer` which is also signed.
09:38:32 <boxscape>  % :t genericLength
09:38:40 <boxscape> :t genericLength
09:38:42 <lambdabot> Num i => [a] -> i
09:38:52 <boxscape> actually returns any number type you want, not just Integer
09:38:54 <c_wraith> The whole point of genericLenth is that it's polymorphic in the return type
09:38:55 <cjsauer> Oops, `Num`, sorry. I guess it's, well, generic lol
09:39:01 <boxscape> right :)
09:39:06 <geekosaur> Integer is because of defaulting; give it a type
09:40:15 <frdg`> Is it difficult to combine Prolog and Haskell programs? I want to query a prolog knowledge base from within my haskell modules. I need to get back bools and strings. Any advice?
09:41:52 <maerwald> frdg`: no idea, but calling prolog from C works. And calling C from haskell works too
09:43:15 <frdg``> maerwald: hmm ok. I have not used C before. I'll look into it.
09:43:23 <maerwald> ooops
09:43:35 <maerwald> embrace for impact :)
09:43:57 <dolio> Even if 64bit machines could use all 64 bits of address space, list elements take significantly more than 1 byte of space. So 1 sign bit on length isn't going to be a problem from that perspective.
09:49:10 <solonarv> in fact a list element takes at least 3 words (constructor tag, pointer to next, pointer to value) which is 24 bytes - and the value takes at least 2 words, but those may be duplicates
10:36:07 <ddellacosta> can anyone help me understand what the purpose of the ContT is in all of the alsa-seq examples (https://github.com/ddellacosta/alsa-seq/tree/master/examples)? For ex
10:36:25 <ddellacosta> For example: https://github.com/ddellacosta/alsa-seq/blob/52bde1ba92930f247c16993f60ae550a883dd318/examples/dump.hs#L14
10:37:58 <MarcelineVQ> closing the resource when the do block ends
10:38:01 <dolio> ddellacosta: ContT turns `withFoo` functions into actions where the scope ranges over the entire ContT computation.
10:38:31 <dolio> So it looks like you're just allocating something, and it's automatically freed at the end.
10:38:32 <MarcelineVQ> ddellacosta: some info about the pattern here https://hackage.haskell.org/package/managed
10:38:48 <MarcelineVQ> * https://hackage.haskell.org/package/managed-1.0.8/docs/Control-Monad-Managed.html
10:39:10 <ddellacosta> dolio, MarcelineVQ , thanks that's super helpful. And thanks for the docs MarcelineVQ
10:39:28 <ddellacosta> exactly what I was hoping for
10:40:01 <MarcelineVQ> Managed is a restricted Codensity which is a restricted ContT
10:40:26 <MarcelineVQ> restricted/specialized/more-specific
10:40:31 <ddellacosta> I've heard of Codensity before, but never looked into it (same as ContT for that matter)
10:41:13 <ddellacosta> as always, more to learn in Haskell...
10:41:59 <dolio> Yeah, there's probably no need to use ContT, because most bracketing functions will be polymorphic in the result type.
10:42:12 <c_wraith> for that use, Codensity should always suffice
10:42:38 <c_wraith> and depending on the types, managed might also work.  I haven't looked.
10:43:08 <ddellacosta> okay, going to file that away so I can come back and re-read it once I have grokked all the supporting concepts, thanks dolio and c_wraith. Time for some reading
10:48:19 <MarcelineVQ> c_wraith: managed is Codensity where m = IO and the 'runner' for it must results in (), to prevent handle leakage
10:48:43 <c_wraith> MarcelineVQ: right.  the point was I don't know what monad the alsa stuff is using.
10:48:48 <MarcelineVQ> gotcha
10:56:20 * hackage uniqueness-periods-vector 0.2.0.0 - Generalization of the uniqueness-periods and uniqueness-periods-general packages functionality.  https://hackage.haskell.org/package/uniqueness-periods-vector-0.2.0.0 (OleksandrZhabenko)
11:08:34 <L29Ah> > let (a, b) = (b, a) in seq (a, b) 666
11:08:36 <lambdabot>  666
11:11:08 <c_wraith> L29Ah: Yep.  seq evaluates only the outermost constructor.
11:12:20 * hackage uniqueness-periods-vector-properties 0.2.0.0 - Metrics for the maximum element for the uniqueness-periods-vector packages family.  https://hackage.haskell.org/package/uniqueness-periods-vector-properties-0.2.0.0 (OleksandrZhabenko)
11:14:57 <L29Ah> okay, i have a lazy list that basically pulls a huge file from the disk (that doesn't fit in RAM) and two places in my code that `map` over it; do i have to make a separate strict function that is handed to one and only one `map` to avoid the intermediate storage of the whole file, or is there a less intrusive way to force the processing of each list item before fetching the next item?
11:15:39 <c_wraith> um.
11:15:57 <c_wraith> That's exactly what map gives you.
11:16:15 <L29Ah> c_wraith: i have two `map`s
11:16:18 <c_wraith> so?
11:16:30 <c_wraith> each one processes one element at a time.
11:16:43 <L29Ah> so one is executed after the other, so the whole list is forced to linger in memory
11:16:51 <c_wraith> that's not at all how laziness works
11:17:13 <c_wraith> > map show . map (+1) $ [1..]
11:17:15 <lambdabot>  ["2","3","4","5","6","7","8","9","10","11","12","13","14","15","16","17","18...
11:17:24 <L29Ah> both map's work on [1..]
11:17:27 <c_wraith> that obviously doesn't force the whole list into memory
11:17:36 <L29Ah> well, not on [1..], but on a huge finite structure
11:18:47 <c_wraith> map processes each element of its input as its output is demanded.
11:18:59 <c_wraith> that's what you're asking for
11:19:24 <tzh> is the thing there that after the map processes the head of the list it can be forgotten about because it's no longer needed? and since that happens repeatedly you only ever have a small portion of the infinite list in memory?
11:20:19 <tzh> so if you can lazily generate the list and aren't keeping around any other references to the head of the list, then processing it piecemeal like that doesn't actually have a particularly large memory footprint?
11:20:36 <tzh> i'm not 100% on the specifics but that's my understanding of the situation
11:22:53 <tomsmeding> tzh: that sounds accurate enough
11:24:44 <ski> L29Ah : one `map' takes as input the output of the other `map' ? or both take the original list as input ?
11:37:17 <maerwald> did stack change the layout of .stack-work directory recently?
11:59:53 <L29Ah> ski: both the original
12:03:16 <ski> L29Ah : note that `(map f xs,map g xs)' is equal to `unzip (map (\x -> (f x,g x)) xs)'. possibly you can consume the list of pairs directly, instead of having to deal with the two separate lists ?
12:09:07 <tomsmeding> also, L29Ah, have you measured the memory usage of your code? :)
12:09:59 <koz_> I have a Cabal file with a flag 'foo'. I wanna write a benchmark stanza where the library is built with the flag. What do I need to put in the stanza?
12:20:27 <maerwald> koz_: you make the benchmark unbuildable when the flag is off
12:20:47 <koz_> maerwald: Ah, OK.
12:21:26 <maerwald> then you make sure your flag has the property "manual: False" and your default may be off
12:21:37 <maerwald> I think cabal should then be able to switch it on automatically
12:22:17 <maerwald> https://cabal.readthedocs.io/en/3.4/cabal-package.html#configuration-flags
12:23:13 <koz_> So I stick the benchmark inside an if-block?
12:25:27 <dolio> You can put `buildable: False` in an if, probably.
12:25:37 <maerwald> no, you make the benchmark depend on 'unbuildable < 0', when the flag is off
12:25:41 <maerwald> and that
12:25:52 <maerwald> not sure which one works better
12:30:12 <L29Ah> 22:08:46]<tomsmeding> also, L29Ah, have you measured the memory usage of your code? :)
12:30:13 <L29Ah> yeah, +RTS -M1G makes magic ;)
12:31:52 <tomsmeding> interesting
12:32:49 <L29Ah> 22:02:54]<ski> L29Ah : note that `(map f xs,map g xs)' is equal to `unzip (map (\x -> (f x,g x)) xs)'. possibly you can consume the list of pairs directly, instead of having to deal with the two separate lists ?
12:32:50 <L29Ah> sure i can reformulate the problem in such terms, my question was whether there's a way w/o having to do it
12:36:50 <electricityZZZZ> a general question about programming languages: it looks like most (all?) programming languages are constructed from expression trees. are there languages built on graphs or other potentially more complex structures? would there be any advantage of using such a structure?
12:43:14 <tomsmeding> how would you edit a program written in such a language?
12:45:05 <hpc> if you don't think just syntactically, regular expressions are equivalent to finite state machines, which can be represented as directed graphs
12:46:03 <geekosaur> they're also incomprehensible to many people :)
12:46:46 <[exa]> electricityZZZZ: you can abstract out the identifier/variable names and connect the holes with graph edges (and poof you have a graph). Advantage: explicit scope (and the graph is there anyway). Disadvantage: editors
12:47:32 <hpc> regexes are super easy, you just read them from left to right, and sometimes backwards, sometimes multiple times, and maybe skip over parts of it
12:47:36 <hpc> what could be simpler?
12:47:50 <maerwald> hpc: reminds me of haskell code :p
12:47:57 <[exa]> hpc: globs? :]
12:48:19 <dolio> Visualizing a program graph without identifiers is not trivial, either.
12:49:07 <dolio> If you really got rid of all identifiers, I doubt it'd be nice to look at.
12:49:20 <[exa]> there was a paper that unified equivalent subtrees in the code, which ended up in a DAG; that was interesting and I can't find it anymore
12:49:55 <[exa]> dolio: certainly not, perhaps even worse than de bruijn indices
12:50:04 <maerwald> hpc: monads left to right, function composition backwards and list comprehension multiple times 
12:50:06 <dolio> Almost certainly.
12:52:23 <monochrom> People look at call graphs and control flow graphs all the time. And recognize that they are emphatically cyclic graphs.
12:52:26 <Guest_56> Hello, I installed ghcup on macOS and answered YES to cabal to the path but when I run cabal, the command is not found, thanks in advance
12:52:43 <monochrom> Nonetheless, they don't remove names and labels from those graphs.
12:52:50 <maerwald> Guest_56: your shell is zsh or bash?
12:53:01 <Guest_56> Bash
12:53:04 <geekosaur> you probably need to start a new shell because it edited the shell startup file
12:53:08 <monochrom> Also data flow graphs.
12:53:20 <maerwald> Guest_56: add 'source ~/.ghcup/env' to your .bashrc
12:53:33 <Guest_56> I'll try thank you
12:53:34 <maerwald> then restart your shell
12:54:30 <Guest_56> Well the line is already there and and I restarted the sell but still `-bash: cabal: command not found`
12:54:40 <maerwald> if it doesn't work, you may need to add '[[ -f ~/.bashrc ]] && source ~/.bashrc' to ~/.bash_profile
12:54:53 <c_wraith> yeah, mac os does that silly .bash_profile thing
12:54:58 <maerwald> you might be running a login shell
12:55:13 <maerwald> c_wraith: all bashs do... it's just the contents of it suck on mac
12:55:31 <c_wraith> maerwald: I mean there's one by default.  never had debian do that.
12:55:35 <Guest_56> Perfect it worked! Thanks :)
12:55:36 <maerwald> bash upstream recommends to add that line to .bash_profile
12:56:42 <ski> L29Ah : depends on what you mean, and what you're doing with the two resulting lists. there's e.g. a package `folds' that can be used to combine multiple folds over a list into a single one, to avoid traversing the list more than once. maybe it could be useful
13:00:01 <ski> electricityZZZZ : you're aware of LabVIEW ?
13:04:41 <Kindle> :t flip
13:04:43 <lambdabot> (a -> b -> c) -> b -> a -> c
13:04:44 <electricityZZZZ> i have used labview :)
13:05:02 * ski . o O ( "Language Design Overview" by Wouter van Oortmerssen at <http://strlen.com/language-design-overview/>; <http://strlen.com/programming-languages/> )
13:05:27 <Kindle> :sprint (1, 2)
13:05:35 <Kindle> nvm
13:05:38 <ski> > (1,2)
13:05:40 <electricityZZZZ> part of my question is this: at one extreme we have assembly, then C, and then "improvements on C" which arguably haskell and other more sophisticated languages are sort of at one end of that,... and then at the other extreme we have english (or your favorite human language)
13:05:41 <lambdabot>  (1,2)
13:05:55 <ski> (lambdabot is not GHCi)
13:06:00 <ski> % :sprint (1,2)
13:06:00 <yahb> ski: *** Parser [source]:; <interactive>:1:2: error: parse error on input `1'
13:06:05 <electricityZZZZ> english is not a good language for specifying programs, but it is not necessarily the case that improvements on C are good languages for specifying programs either
13:06:11 <Kindle> I figured it might support sprint as well
13:06:35 <Kindle> for explicit values
13:06:45 <Kindle> the more you know
13:07:11 <ski> % :sprint otherwise
13:07:11 <yahb> ski: *** Parser [source]:; !!! Parser [source]: finished in 0.06 milliseconds, allocated 0.018 megabytes; otherwise = True
13:07:19 <electricityZZZZ> and i'm not saying to "eliminate variable names" or any such thing, graphs can have named edges and nodes and soforth
13:08:52 <electricityZZZZ> by mentioning graphs rather than trees, i am asking whether by relaxing practical constraints on language design we can end up with something which is better to use
13:09:28 <ski> (some of those van Oortmerssen languages seemed to experiment with graphical/visual representations of code)
13:10:06 <electricityZZZZ> i am not interested in the "graphical code representation" obsession that some people seem to have
13:10:20 <electricityZZZZ> i am invoking graphs in a mathematical sense--do we lose anything by limiting ourselves to trees
13:10:29 <ski> yes, i understand
13:11:18 <ski> hm, now i'm reminded of a graphical notation for specifying grammars (used by Wirth, iirc), being an alternative to (E)BNF
13:11:23 <dminuoso> electricityZZZZ: What makes you think we have a strict tree?
13:12:00 <dminuoso> What is a recursive or mutually recursive binding to you?
13:12:04 <electricityZZZZ> dminuso: my lack of knowledge, apparently?
13:12:16 <electricityZZZZ> okay "trees with the possibility of recursion"
13:12:28 <ski> one can think of `let'/`where' as representing "floating side nodes, which may reference each other like a possibly cyclic graph"
13:12:54 <dminuoso> electricityZZZZ: a tree with loops is.. uh.. well.. a graph.
13:13:07 <ski> i wonder whether there's any code display thing which renders them, as such
13:13:11 <ski> (maybe Vital ?)
13:13:24 <electricityZZZZ> fine, but i still don't focus on writing my code as a collection of graph objects
13:15:46 <ski> (also DrScheme^WDrRacket allows one to click on a name to see where it's bound, or on the binder to see all uses, these being indicate as arrows (which one can make sticky). iirc, something similar is also possible, for tracking "where could this value have flown from", when debugging, or when type-checking)
13:16:31 <dminuoso> electricityZZZZ: All Im saying is, what you seem to be asking for already exists in Haskell for example.
13:16:58 <dminuoso> One could think of haskell evaluation as a graph reduction.
13:17:13 * ski . o O ( "Vital is a document-centered implementation of Haskell","The Vital project (acronym: Visual Interactive Typed Applicative Language) is investigating a /document-centered/ approach to functional programming with an emphasis on the display and /direct manipulation/ of complex data structures." (cf. spreadsheets) <https://web.archive.org/web/20090529010107/http://www.cs.kent.ac.uk:80/projects/vital/> )
13:17:33 <ski> @where lazy
13:17:34 <lambdabot> "Lazy Evaluation of Haskell" by monochrom at <http://www.vex.net/~trebla/haskell/lazy.xhtml>; "The Incomplete Guide to Lazy Evaluation (in Haskell)" by apfelmus in 2015-03-07 at <https://apfelmus.
13:17:34 <lambdabot> nfshost.com/articles/lazy-eval.html>; "Laziness, strictness, guarded recursion" by bitemyapp at <https://github.com/bitemyapp/learnhaskell/blob/master/specific_topics.md#user-content-laziness-
13:17:34 <lambdabot> strictness-guarded-recursion>
13:19:17 <dminuoso> electricityZZZZ: So in that sense, a haskell binding/expression is a graph.
13:27:28 <monochrom> We don't limit ourselves to trees.
13:27:56 <electricityZZZZ> i mean okay so some nodes are shared but if i draw a graph there is a huge number of rewriting operations i can use beyond innermost and outermost evaluation
13:28:12 <electricityZZZZ> a truly arbitrary graph
13:28:29 <monochrom> AST is just one perspective, and even then a minority one.
13:28:41 <electricityZZZZ> ok?
13:28:54 <monochrom> Only compiler geeks spend a majority of time on ASTs.
13:30:11 <electricityZZZZ> heh ok, then what is the majority persoective?
13:30:11 <dolio> What does many evaluation strategies existing have to do with representing syntax as a graph?
13:30:49 <monochrom> Programmers have many intuitive perspectives. Most of them unformalizable.
13:31:14 <monochrom> But for starters, look at the wide, nay, wild, range of things in UML.
13:31:14 <electricityZZZZ> "unformalizable" -- interesting, i like this
13:32:37 <monochrom> Many people critique UML for having no formal semantics, for covering too many diverse things, for having no common theme other than the open-ended word "diagram", "picture", "scribble something".
13:32:42 <monochrom> EXACTLY THE POINT.
13:33:42 <monochrom> It means programmers already had some conscious and subconscious ideas of timing diagrams, class relations, object relations, package/module organzation... And UML simply thought up ways of drawing them out.
13:34:09 * electricityZZZZ screams in TPS report
13:34:29 <monochrom> If you have learned UML completely, then you begin to see a glimpse of the wide range of common programmer perspectives.
13:36:08 <Kindle> Could someone explain how a function like `bool x (-x) (x == 3)` can be applied to a `map` over a range, such as `[1..20]`?
13:37:07 <c_wraith> Kindle: are you familiar with lambdas?
13:38:16 <Kindle> Yes! The practice question this is an attempted solution for asks to convert a lambda `\x -> if x == 3 then -3 else x` to a map over `bool` 
13:38:33 <electricityZZZZ> map (==3) [1..20]
13:38:38 <c_wraith> Ok, but that probably still wants a lambda
13:38:45 <electricityZZZZ> nsfw warning, i guess ;-)
13:39:06 <Kindle> c_wraith what do you mean by that
13:39:27 <Kindle> electricityZZZZ don't think that solves my problem as specified here, :/
13:39:31 <dolio> Well, `bool x (-x) (x == 3)` isn't a function.
13:39:31 <c_wraith> Kindle: rewrite only the body of the lambda to use bool instead of if .. then .. else
13:39:46 <Kindle> Ah
13:39:48 <dolio> Just like `if x == 3 then -3 else x` isn't a function.
13:39:55 <Kindle> Right right
13:39:59 <Kindle> got ahead of myself here
13:40:08 <Kindle> thanks for the millionth time dolio 
13:40:12 <Kindle> you too c_wraith
14:02:27 <ddellacosta> hmm this is kind of a nix question but, I'm getting "cabal: The pkg-config package 'alsa' version ==1.0.17 || >1.0.17 is required" when trying to add the dependency alsa-seq...do I need https://github.com/bgamari/nix-pkgconfig ? Or have I just misconfigured something?
14:02:49 * hackage pusher-http-haskell 2.0.0.0 - Haskell client library for the Pusher Channels HTTP API  https://hackage.haskell.org/package/pusher-http-haskell-2.0.0.0 (willsewell)
14:03:11 <bgamari> ddellacosta, nix-pkgconfig is indeed one way to handle this
14:03:27 <bgamari> ddellacosta, presumably you aren't using the nixpkgs haskell infrastructure to build your package?
14:03:30 <ddellacosta> shoot I was just realizing I probably pinged you with that, sorry bgamari
14:03:47 <bgamari> ahh, quite alright
14:04:07 <ddellacosta> did not intend to. But yes, actually I am using nix infrastructure for my haskell project in this case, which is why I'm confused
14:04:38 <ddellacosta> hmm so also let me note that this is just a problem when I try to do cabal new-build--I can actuall do nix-build just fine
14:05:01 <ddellacosta> so I guess that makes more sense
14:05:21 <bgamari> right
14:05:33 <bgamari> so in that case you are using cabal-install, not nixpkgs, to do the build
14:05:40 <bgamari> which is indeed why you are seeing the issue you are seeing
14:05:46 <ddellacosta> yeah, so you were right in the first case, sorry
14:05:58 <bgamari> It's a bit unfortunate that there isn't a better solution here
14:06:07 <ddellacosta> okay so nevermind it's coming clear to me slowly. I'll give nix-pkgconfig a shot--thanks for writing that!
14:06:12 <bgamari> I wrote nix-pkgconfig to address this exact problem
14:06:25 <ddellacosta> yeah, I was very happy when I found that :-D
14:06:33 <bgamari> another option is to manually add extra-lib-dirs and extra-include-dirs to cabal.project.local
14:06:43 <bgamari> ddellacosta, let me know if you have any trouble with it
14:06:55 <ddellacosta> ah okay, that's good to know (the alternative). Thanks, will do!
14:20:49 <dicov> Hi, does anyone here use liquid-haskell on NixOS without a custom shell.nix ? How do you get the SMT solver to work there ?
14:22:14 <bgamari> dicov, I would add the solver to your derivation's nativeBuildDepends
14:26:26 <dicov> ok, thanks!
14:28:39 <dicov> though, if I may, is there a user-specific default derivation ? or do I need an user one ? (and where/how can I add this?)
14:30:30 <dicov> *project one
14:53:37 <electricityZZZZ> semi-noob question: in rust libraries and soforth frequently use "unsafe" to contain and hide complexity and potential violations of the common "safe" language assumptions. to what extent is there "unsafe" code in haskell?
14:54:35 <davean> Theres unsafe, but its very rare. Haskell doesn't have to break the safety often. You'll find it deep inside libraries like ByteString and Text.
14:55:33 <davean> Its implicitely hit by some functions in base sadly ...
14:55:53 <davean> (reading files) but the interface is nicer for simple things like that.
14:56:32 <davean> Then theres like unsafeThaw and such for vectors ...
14:56:37 <davean> but not muh reason to do that either.
14:57:05 <hpc> libraries that use FFI have some implicit "unsafe", in that you get to decide if the definitions you import involve IO or not
14:57:45 <davean> unsafe is not something you're very likely to have cause to do yourself unless you're writing a low level high performance lib or doing similarly with FFI. Its not a "normal" thing
14:57:49 <hpc> which is similar to most unsafe in rust anyway
14:57:52 <davean> thats the main jist of what I'm saying.
14:58:13 <davean> I probably could name every unsafe in my entire core dependency tree
14:58:20 <davean> its probably less than 100 locations.
14:58:29 <davean> and I have a fairly large dependency footprint
15:01:01 <davean> electricityZZZZ: we even have safe coercion now to reduce the unsafe operations.
15:07:37 <infinisil> I think SafeHaskell could even be used to make sure there's no unsafe
15:08:11 <davean> and Trustworthy
15:08:26 <davean> Theres controls for not allowing it at all.
15:19:49 * hackage assert-failure 0.1.2.5 - Syntactic sugar improving 'assert' and 'error'  https://hackage.haskell.org/package/assert-failure-0.1.2.5 (MikolajKonarski)
15:20:49 * hackage lucid-cdn 0.2.0.1 - Curated list of CDN imports for lucid.  https://hackage.haskell.org/package/lucid-cdn-0.2.0.1 (locallycompact)
15:36:19 * hackage servant-snap 0.9.0 - A family of combinators for defining webservices APIs and serving them  https://hackage.haskell.org/package/servant-snap-0.9.0 (imalsogreg)
15:36:24 <dexterfoo> i have an array with length n that i want to iterate over, so i use [0..(n-1)]. problem is that n is unsigned so when it is 0 i get underflow and a bug. i want the equivalent of for(i=0; i<n; i++). what's the most natural way?
15:38:13 <c_wraith> um...  why?
15:38:39 <c_wraith> Not being facetious.  that's kind of backwards from the easy way to do things.
15:38:46 <c_wraith> What do you *actually* want to do?
15:39:59 <dexterfoo> i need to call a c function with arguments 0,1,2...(n-1)
15:40:34 <c_wraith> Double-checking that you mean with Haskell?
15:40:39 <dexterfoo> yes
15:40:55 <c_wraith> so like...   mapM cFunc [0 .. n - 1 ]   
15:41:07 <c_wraith> or maybe mapM_, if you don't care about the results?
15:41:11 <dexterfoo> i'm doing:  forM [0..(n-1)] $ \i -> c_fun i
15:41:55 <dexterfoo> i finally figured out that the bug is when n=0, i get underflow and a crash
15:42:22 <c_wraith> well then replace it with the list with (take n [0..])
15:42:23 <dexterfoo> the previous line is:  n <- c_get_len
15:42:36 <c_wraith> -"it with"
15:43:34 <dexterfoo> thanks, that sounds good
15:45:33 <dexterfoo> it actually doesn't work :(  Couldn't match expected type â€˜Intâ€™ with actual type â€˜CSizeâ€™
15:45:54 <c_wraith> are you using n with two different types in different places?
15:46:04 <c_wraith> in any case, that's just a fromIntegral apart
15:46:19 <dexterfoo> no. it seems that `take` requires an `Int`: https://hackage.haskell.org/package/base-4.14.0.0/docs/Data-List.html#v:take
15:46:28 <c_wraith> ....  yes, that's what I'm saying
15:47:08 <dexterfoo> is there a natural way without using fromIntegral?
15:47:39 <davean> fromIntegral is the natural way?
15:48:02 <c_wraith> there's genericTake if you really hate fromIntegral and would rather do things the more awkward way...
15:48:17 <davean> thats rather unnatural
15:48:20 * hackage hledger-lib 1.19.1 - A reusable library providing the core functionality of hledger  https://hackage.haskell.org/package/hledger-lib-1.19.1 (SimonMichael)
15:48:57 <davean> I do wish more things used Natural though
15:49:20 * hackage hledger-web 1.19.1, hledger-ui 1.19.1, hledger 1.19.1 (SimonMichael): https://qbin.io/craig-scotia-0uo9
15:49:30 <davean> theres sized variant structures of fromIntegral
15:51:26 <xsperry> fromIntegral can cause data loss when converting from bigger integral type, which is something you may or may not care about
15:51:55 <davean> thats what the sized variants fix
15:52:33 <dexterfoo> yeah, after this silent underflow error, i am now super worried about silent integer conversion errors. but i am using take + fromIntegral and it's working. thank you all
15:52:34 <c_wraith> xsperry: that's completely irrelevant in any case when you're going to use it with take and then iterate over the resulting list.
15:52:58 <c_wraith> it would take years to iterate over a list that size.
15:53:37 <xsperry> I was talking generally, it is something to keep in mind. even worse, this can happen implicitly
15:54:01 <xsperry> > 1000000000000000000000000000000000000000 :: Int   -- we should at least be getting a mandatory warning in here
15:54:03 <lambdabot>  6873995514006732800
15:54:04 <davean> No, it can't happen implicitely
15:54:09 <xsperry> ^^ wrong
15:54:18 <davean> Thats explicite, thats 1000000000000000000000000000000000000000 as an Integer
15:54:20 <davean> er
15:54:22 <davean> as an Int
15:54:31 <davean> That is what 1000000000000000000000000000000000000000 is as an Int
15:54:37 <xsperry> I never explicitly called fromIntegral
15:54:48 <davean> No you didn't and fromIntegral was never REALLY called
15:55:18 <xsperry> what was called?
15:55:19 <davean> dexterfoo: https://hackage.haskell.org/package/int-cast-0.2.0.0/docs/Data-IntCast.html
15:55:50 <davean> xsperry: if you parse into an integer you get the same result
15:55:57 <davean> xsperry: Thats just what that value is as an integer
15:56:17 <cr0ssw1nd> hey
15:56:25 <xsperry> davean, so I take it that you don't see a problem with too large integral literals resulting in silent data loss?
15:56:34 <cr0ssw1nd> how is "[r| ... |]" syntax is called?
15:56:47 <cr0ssw1nd> I found it in some code working with Cassandra
15:57:06 <cheater> you can't really blame ghc for this happening if you convert your numbers from the ring of integers to the ring of integers modulo 9223372036854775807
15:57:15 <xsperry> what if I did func 10000000000000000000000.. with func accepting Int? still no problem?
15:57:29 <dolio> There's already a warning for it.
15:57:41 <davean> xsperry: Your confusing fromIntegral with numeric overflow, they're different
15:57:45 <xsperry> I am not getting warning with default settings. was this fixed in newer GHC?
15:57:52 <davean> if you want an overflow signaling type they exist
15:57:56 <davean> but you're talking about overflow
15:57:58 <xsperry> davean, I don't really care what is causing silent data loss
15:58:11 <cheater> it's not data loss. it's a programmer error for using the wrong data type.
15:58:14 <xsperry> it shouldn't happen, and I shouldn't have to add additional warning flags to be warned about it
15:58:34 <dexterfoo> davean: thanks, but i think it is always safe to cast from CSize to Int
15:58:34 <xsperry> cheater, you have something against compiler catching programmer errors at compile time?
15:58:39 <davean> but it should happen, thats what that means as Int, that would be different for SignalingInt
15:58:53 <davean> xsperry: but its not exactly an error - its actually a really important property of the Int type
15:59:01 <davean> that allows some math to be calculated
15:59:02 <xsperry> it can be an error
15:59:07 <davean> that would be FAR more difficult otherwise
15:59:19 <davean> I infect just did a bunch of numeric calculations based on that last night
15:59:24 <dolio> If you want the warning, turn it on. Geeze.
15:59:25 <davean> it can be an error but so can "5"
15:59:27 <cheater> i have something against the accusatory tone this is happening in or the gotcha phrasing of the question you asked me
15:59:42 <xsperry> davean a mandatory warning wouldn't stop that
15:59:50 <cheater> davean told you there are number types that signal under and overflow. use these
15:59:54 <davean> xsperry: turn on -Wall if you want it
15:59:57 <cheater> don't use tones that don't signal it if you're worried about it
16:00:05 <xsperry> davean that's optional, not mandatory
16:00:19 <davean> xsperry: yes, but why would you demand warnings on correct code?
16:00:22 <cheater> s/tones/types
16:00:37 <davean> That is the carefully specified - and for good reason - semantics of Int
16:00:39 <xsperry> davean because it would warn about potential bugs
16:00:51 <davean> But everything is a potential bug, thats not a real argument
16:01:18 <davean> You need good reason to believe its a bug for it to be a default warning
16:01:50 <xsperry> davean, it is MORE likely to be a bug than not, when written as a literal (which is what I'm concentrating on)
16:01:52 <cheater> xsperry: it's true though that integers modulo 9223372036854775807 are difficult to discover the semantics of by natural use. so maybe they should be called IntMod9223372036854775807 instead of Int.
16:02:45 <davean> xsperry: if you want the warning, turn it on, if you want it to error, turn that on, if you want Int to behave differently, use a type that does that - that type will be bad for numeric calculations of many sorts.
16:04:00 <xsperry> davean my whole ponit is that it should be a default warning for literals, instead of (potentially) silently corrupting data
16:04:03 <davean> I litterly spent 8 hours working on numerical calculations last night that deal with this specific case, I can't imagine how many more hours it would have taken me if Int wasn't defined like that.
16:04:22 <xsperry> I am talking about LITERAL VALUES
16:04:27 <davean> Yes
16:04:40 <dolio> Maybe people don't agree with you.
16:05:03 <xsperry> so why do you keep talking about Int's behavior, when I am not talking about that before? nothing would change, Int would still overflow like it does now
16:05:04 <davean> Yes consider that we've heard what you said and think you're wrong.
16:05:17 <davean> You *are* talking about Int's behavior though.
16:05:21 <xsperry> we? do you have multiple perosnality disorder?
16:05:28 <xsperry> or just like hiding behind others
16:05:34 <cheater> xsperry: i heard it too and i too think you're wrong
16:05:42 <davean> xsperry: I'm saying you're wrong, dolio is saying you're wrong, cheater is saying you're wrong
16:05:43 <cheater> davean + cheater + dolio = we
16:05:47 <cheater> i don't know what to tell you xsperry. hardware integer overflow is something that happens in all languages because it's a function that happens on the cpu. as a programmer you should know this, just like you know the ascii table and how you know the tables of boolean functions. it's covered in the first chapter in most programming books. i think it's on you for not knowing such a thing, or for having forgotten it for the time being. just get on 
16:05:48 <cheater> with it and pretend it never happened.
16:05:50 <davean> xsperry: YOu're being rather agressive here
16:05:58 <davean> xsperry: theres no need to insult other users
16:06:13 <ClaudiusMaximus> -Woverflowed-literals
16:06:41 <xsperry> davean, I never insulted you. you still haven't explained how a warning would change Int's behavior?
16:06:53 <davean> "23:04:59 xsperry we? do you have multiple perosnality disorder?"
16:06:59 <davean> Ok, you clearly insulted me there.
16:07:07 <cheater> i think you're upset that you forgot something, now you think that the software made you do something dumb or something, and you're upset at the software. by proxy you are upset at other people you talk to. i think your aggression isn't really targeted at anything, but it would be nice if you stopped insulting us.
16:07:23 <xsperry> davean, nope, it was tongue in cheek
16:07:30 <davean> Now who is hiding.
16:07:36 <davean> I'm done
16:07:40 <cheater> same
16:07:42 <cheater> bye xsperry 
16:07:43 <davean> I'm so out of this
16:08:59 <xsperry> fine with me. I'll just add this, some pretty smark folks were biten by this behavior (crypto guys), and crapped (and I can't blame them) on haskell for it.  https://github.com/haskell-crypto/cryptonite/issues/330
16:09:05 <cheater> is it though
16:09:07 <cheater> is it fine
16:09:52 <xsperry> I thought you're done?
16:09:58 <cheater> i was one of the developers of a cryptocurrency that launched to a $1B ico and i don't find it confusing
16:10:13 <cheater> so maybe you should curb your expectations
16:10:38 <davean> I would like to call out that specific library (and its author) as having specificly bad code and it not being fixed even when I provided remote exploit demonstrations
16:11:04 <davean> I would not call that library a demonstration of anything but bugs.
16:11:23 <davean> I have stopped using almost everything from that author
16:11:36 <davean> their hit library even had non-deterministic lookup failures
16:11:46 <cr0ssw1nd> guys, what is the name of "[r| ... |]" syntax?
16:11:53 <davean> and they specificly call unsafe functions without checking invariants
16:11:54 <cheater> quasiquoters
16:12:02 <davean> ones you're not even supposed to be able to access as a non-implimentor
16:12:07 <dolio> That one's Template Haskell, isn't it?
16:12:57 <dolio> Oh, perhaps it isn't.
16:13:08 <koz_> I echo davean in this - we have that in library in our work deps and hit some _really_ weird issues in the past.
16:13:18 <cr0ssw1nd> cheater, thanks
16:13:25 <cheater> yw
16:13:51 <davean> koz_: the best part is they won't fix the issues :(
16:14:01 <koz_> davean: Yup... So much fun for us.
16:15:35 <davean> I don't know of other authors being specificly banned
16:16:09 <cheater> wait, one of the authors of cryptonite got banned in here?
16:16:58 <davean> cheater: no, I know several haskell places that ban all use of vincenthz code due to past SERIOUS issues
16:17:06 <cheater> oh, right
16:17:38 <cheater> yeah, rolling your own crypto is a well known Bad Idea, and if you're not humble about bug reports, that's a 100% confirmed nope
16:18:34 <davean> I believe the issue in 'hit' specificly was copy-pasta custom buffer management code repeating stuff built into the base Handle type
16:19:02 <cheater> i don't even know what that means
16:19:09 <cheater> sounds like some cryptid
16:19:27 <davean> http://hackage.haskell.org/package/hit-0.6.3/src/Data/Git/Storage/FileReader.hs
16:19:32 <davean> That file
16:21:12 <cheater> i still don't know what it means
16:24:52 <davean> I'm not sure what to explain
16:25:02 <xsperry> even C (GCC) is safer than haskell/GHC in this regard. no flags needed to get a warning https://pastebin.com/brKWVnNv
16:25:41 <dolio> What is the point of complaining here about the default GHC warnings?
16:28:04 <xsperry> dolio, someone asking a question led to this discussion. I was expecting a less knee-jerk defense of this obvious broken behavior, but reading the link I posted (and other links posted in there) above more thoroughly, maybe I shouldn't have
16:28:13 <xsperry> obviously*
16:28:30 <dolio> The question wasn't even about a literal overflow.
16:34:23 <xsperry> silently overflowing literals is even worse
16:34:49 <dolio> Why are you continuing to complain about it here, where it will do no good?
16:35:13 <xsperry> dolio, why do you keep continuing the conversation, and then compalining that I do as well?
16:36:25 <ClaudiusMaximus> xsperry: https://pastie.iem.at/view/2b796dd4
16:37:10 <dolio> There was 25 minutes of it being over and then you brought it back up. And I'm asking you to discontinue doing so.
16:38:53 <xsperry> ClaudiusMaximus, default warnings in damn C/gcc, known to be a hell pit of potential bugs and undefined behavior, are safer than default warnings in haskell/ghc. and apparently, that's not a problem. and if you bring it up, you'll be threaten with a ban
16:39:12 <xsperry> I'm done now
16:39:38 <davean> Uh
16:40:44 <davean> Threatened with a ban?
16:41:21 <monochrom> This is really blown out of proportion.
16:42:58 <monochrom> It look like the crypto packages could use the help of the int-cast package.
16:44:12 <dolio> It's fine to disagree with something GHC does. I don't think your attitude in presenting your disagreement is beneficial to this channel.
16:45:19 <dolio> And it also doesn't change GHC.
16:47:40 <cheater> xsperry: as previously stated, you're getting a bad reaction here because of your accusatory tone and sense of entitlement
16:47:49 <cheater> cut it out and maybe on another day someone might take you seriously
16:48:57 <cheater> just noticed dolio said pretty much the same thing
16:49:02 <cheater> i was reading scrollback
16:50:56 <davean> monochrom: I mean that won't save them from reaching down into the integer implimentation and calling implimentation functions :)
19:22:09 <fog> it trying to read about fudgets
19:22:12 <fog> i fid;
19:22:15 <fog> A fudget is a process which
19:22:16 <fog> can, via message passing, communicate with other concurrently running fudgets and with
19:22:16 <fog> the outside world. A fudget is a first class value of a type that reflects what types of messages the fudget sends and receives. This makes communication type safe. A fudget may
19:22:17 <fog> have an internal state, which is not visible in the type of the fudget.
19:22:32 <fog> find*
19:23:06 <fog> i wonder if what i have is "an internal state, which *is* not visible in the type of the fudget."
19:23:28 <fog> "an internal state, which *is* visible in the type of the fudget."
19:24:08 <fog> it goes on to say;
19:24:13 <fog> Fudget programming in
19:24:13 <fog> this respect resembles object oriented programming, where state information is distributed
19:24:14 <fog> and hidden within objects rather than centralized and exposed to arbitrary use or misuse.
19:24:14 <fog> But the encapsulation of state information also makes fudgets easy to compose, like functions in functional languages.
19:24:15 <fog> Fudgets are implemented on top of stream process
19:25:00 <fog> ...
19:25:01 <fog> they are calling it "the encapsulation of state information"
19:25:14 <fog> which is apparently object oriented 
19:25:37 <fog> so what is "object oriented minus state encapsulation"!?
19:26:41 <fog> i can only find the first page of "programming with fudgets", here; https://link.springer.com/chapter/10.1007%2F3-540-59451-5_5
19:27:23 <fog> and nothing on hackage!
19:27:24 <fog> https://hackage.haskell.org/packages/search?terms=fudgets
19:27:48 <fog> im guessing they use something like SSP that ski was talking about recently 
19:28:36 <fog> it refers to stream processors here;
19:28:37 <fog> A stream processor is
19:28:38 <fog> a process that consumes an input stream and produces an output stream. Combinators for
19:28:38 <fog> serial composition, parallel composition and loops allow programs to be structured as a network of stream processors
19:28:55 <fog> ...
19:28:55 <fog> well this sounds perfect!
19:29:18 <fog> except that they hide the state information with this idea of "state encapsulation" 
19:29:56 <fog> i guess that means their nets are less unwieldy regarding type level difficulties 
19:30:15 <fog> but i dont care about those! we have a much more expressive haskell than when they did this in 98
19:30:37 <fog> so what do we have with these "unencapsulated fudgets" 
19:30:52 <fog> which is a terrible name, but its what i have been calling scanner nets
19:31:49 <fog> how does it relate to OOP, which i know absolutely nothing about, but is apparently a good point of reference for understanding fudgets
19:41:27 <frankl> Yo guys, am I translating this correctly?
19:41:41 <frankl> For every even number, there is a greater odd number
19:42:19 <frankl> and [or [ n > m | n <- u, odd n] | m <- u, even m]
19:50:26 <sim590> What's the filetype of cabal.project ? Is it yaml or cabal ?
19:53:10 <fog> .project?
19:57:19 <davean> sim590: cabal
19:58:34 <sim590> davean: aight. Thanks! Wasn't sure, because my editor didn't colour properly the line "package mypackage", but I guess it's just my editor's syntax configuration fault.
20:09:51 <fog> im guessing no-one has heard of fudgets... 
20:10:29 <fog> what about the OOP "encapsulation of internal state" idea?
20:10:58 <fog> the way that synchronous stream processors work in a typed functional language
20:12:01 <sim590> How do I import a hidden module from my package that I want to test with my test-suite. Cabal is complaining about the module to be hidden (because I don't want to expose it to the API), but I would like to access it from my test-suite...
20:12:05 <fog> basically discarding the internal type in a GADT, to hide it for ease in terms of typechecking
20:12:51 <fog> sim590: cant you wrap the access to it in another module?
20:12:59 <fog> i guess that wouldnt be hidden though...
20:13:25 <sim590> Yeah..
20:14:11 <fog> maybe you could do something like write one function in a module that can access the hidden module - and export it so that the test can see it, but not re-export that particular function from a central access module that re-exports the user API
20:14:55 <koz_> sim590: other-modules, and have its source directory in your haskell-source-dirs.
20:15:05 <fog> ie, not make it hidden, except that the user is encouraged to access the module from which it is hidden from re-export
20:15:35 <fog> ah, i didnt realise there was a special way like koz_ suggests 
20:15:55 <siraben> Hoogle is down?
20:16:09 <sim590> koz_: I don't really understand the suggestion. Can you explicit?
20:16:16 <fog> siraben: seems so
20:16:19 <davean> or a private multilib?
20:16:34 <koz_> sim590: In your test-suite, you can have an other-modules section. Put the module you wanna test there.
20:16:51 <koz_> Also in your test suite, you have a haskell-source-dirs section. Put the directory of that module there also.
20:16:57 <koz_> Then you can import it and use it as normal.
20:17:08 <sim590> Oh right. So I just have to include the files directly in there.
20:17:09 <koz_> davean's suggestion also works, depending on how self-contained said module is.
20:17:43 <sim590> It's contained in the same pacakge, so I guess that other-modules is the way to go.
20:17:51 <fog> though the term "private multilib" is somewhat not obvious as to it meaning...
20:19:25 <davean> my solution doesn't lead to it being built twice with potentially different dependencies.
20:19:36 <davean> but I don't think that really matters
20:20:00 <koz_> Yeah, that is definitely a possibility. I had a situation exactly like this, where I ended up having to rebuild the same thing over and over. Putting it in a private library solved it.
20:20:05 <koz_> (it was also one module big)
20:20:12 <sim590> So consequently, I need to list all of the dependencies of my library I'm testing also?
20:20:27 <davean> no, use common stanzas
20:20:42 <koz_> Yeah, use those in general.
20:20:46 <koz_> They are so _so_ handy.
20:20:49 <davean> its better form to always use them
20:20:57 <davean> This is all in the cabal manual BTW.
20:22:01 <sim590> What's that ?
20:22:05 <sim590> stanzas?
20:22:51 <fog> i find this mentioning encapsulation as a design requisite of stream processors; http://cth.altocumulus.org/~hallgren/Thesis/streamprocimpls.html
20:23:00 <koz_> sim590: Let me fetch you a link.
20:23:18 <koz_> https://github.com/juspay/medea/blob/master/medea.cabal#L38
20:23:21 <koz_> Common stanza.
20:23:36 <koz_> How it gets used: https://github.com/juspay/medea/blob/master/medea.cabal#L58
20:23:58 <sim590> Here's what I have now: https://paste.debian.net/1162993/ it doesn't want to build because of all the dependencies I need to include in the test-suite that are from the library.
20:24:31 <koz_> sim590: If you check my links, the solution is there.
20:24:53 <sim590> So, you simply list the common dependencies and it won't build twice?
20:25:21 <koz_> What 'won't build twice'?
20:25:23 <fog> aha! i found the original fudgets thesis; http://cth.altocumulus.org/~hallgren/Thesis/fudgets_thesis_color.pdf
20:26:30 <sim590> koz_: I thought that it was building twice if I did put the same dependencies listed in both. May be not...
20:26:31 <fog> and apparently they have put the source here instead of on hackage for some reason; http://www.altocumulus.org/Fudgets/dist.html
20:27:16 <fog> good god thats a lot of source code
20:27:18 <koz_> build-depends doesn't translate to 'build these every time'. It translates to 'build these if they're missing, cause I need them'.
20:27:33 <fog> i wonder if they would mind if i put it on github to make it easier to browse
20:33:28 <fog> argh, its some kind of X11 based graphical madness! i just want the stream processors...
20:33:40 <fog> and there are no haddocs!
20:34:05 <davean> Theres a thesis and it predates haddock?
20:34:58 <fog> i want to read the source, but most of it is defining scrollbars and buttons and stuff
20:35:33 <fog> i dont think this is a good way to learn about how it does the graph of stream processors supporting sequential and parallel and loops
20:35:54 <fog> its in there somewhere, but its almost inaccessible! 
20:36:41 <sim590> cabal 2.2 doesn't like GPL-3 identifier in "license:" ... ?
20:37:17 <sim590> I got: CabalFileParseError "hart.cabal" [PError (Position 7 27) "\nunexpected Unknown SPDX license identifier: 'GPL-3' \n\nGPL-3\n"] (Just (mkVersion [2,2])) []. The doc says that GPL-3 exists. It was working with cabal version >=1.10
20:38:19 <davean> fog: why not read the thing thats supposed to tell you about it - the thesis?
20:38:30 <fog> because it uses words
20:38:42 <fog> i just want to read the source
20:38:54 <davean> except apaprently you don't
20:39:22 <fog> well, i guess the words might actually be a less indirect access point than this absolute mess of source code
20:39:44 <fog> im used to haddocs, i didnt realise how crucial they are
20:40:19 <sim590> OK. I found the list.
20:41:13 <fog> the thing is the thesis doesnt compile, i can hardly tell from the code fragments 
20:41:30 <fog> at least i know when reading the source that everything i need is there
20:42:12 <fog> but it needs to be easy to navigate like a haddock otherwise its intractable! it contains 351 .hs files!
20:43:08 <fog> idk how to mirror this on github, or on hackage
20:43:18 <fog> idk how to generate the haddocs either
20:43:44 <fog> basically just need to hack out the innards, the compositionality of the fudgets
20:43:54 <fog> but without all the peripheral GUI stuff
20:44:29 <fog> i bet there something equivalent, but this showed so much promise taking about cyclic graphical stream processors 
20:45:26 <fog> like graphical as in on a network, as opposed to as in GUI
20:45:34 <fog> (fudgets do both apparently)
20:48:00 <fog> argh! the source code doesnt even have type signatures for most of the functions, this is ridiculous! 
20:48:07 <sim590> Thanks for help guys. fog, koz_, davean 
20:48:42 <fog> sim590: peace 
20:59:43 <fog> if only there were some way to put all this source code on an AST and automatically refactor it into almost independent parts...
21:37:18 <PropositionJoe> Partial application is pretty cool.
21:39:32 <Axman6> complete application is much better though, client pay then
21:53:41 <Axman6> I guess y'all missed father's day *hmph*
22:09:06 <nshepperd> complete application usually makes me anxious, because it has to be followed by submitted application
22:15:38 <Axman6> and submitted application leads to app store reviewed applicationand possibly rejected application
22:24:41 <mirrorbird> lol app store
22:24:56 <mirrorbird> why would you use that?
