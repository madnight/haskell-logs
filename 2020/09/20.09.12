00:04:59 <cheater> yea but you don't want to do that
00:05:04 <cheater> because it gets confusing
01:00:46 <user____> just testing
03:00:31 <maerwald> suzu_: if you maintain your code a lot, you're doing something wrong anyway, you could argue
03:15:24 <maerwald> so maybe the way forward to rescue software engineering is to get away from agile, refactoring and languages that make both easy :D
03:18:29 <maerwald> maybe dependent types will lead us there... it might cripple the ability to refactor code to the point that you just rewrite stuff from scratch (as you should)
04:43:23 <sshine> huh
04:49:17 <gentauro> 12:18 < maerwald> maybe dependent types will lead us there... it might cripple the ability to refactor code to the point that you just rewrite stuff from scratch (as you should)
04:49:50 <gentauro> maerwald: isn't that one of the reasons we have a sound type system? You refactor a bit, most copy/pasta break. Keep changing until it type-checks
04:50:37 * gentauro I copy/pasta a lot, but GHC is very pedantic so I tend to get it right all the time
04:53:19 <sshine> whenever I copy-paste, that is when I tend to get bugs that escape the type check.
05:53:35 <maerwald> gentauro: that only works if the errors don't propagate through your entire program :)
06:06:19 * hackage extra 1.7.8 - Extra functions I use.  https://hackage.haskell.org/package/extra-1.7.8 (NeilMitchell)
06:47:27 <maerwald> I have a weird idea. A way to mark identifiers in source code as important. It won't affect the output, like comments, but can be used by IDEs and syntax highlighters.
06:50:02 <int-e> foo{-important-}
06:51:25 <maerwald> that's a little intrusive for people whose editor doesn't parse that
06:51:26 <ski>   bar{-more important than foo-}
06:53:12 <maerwald> apostrophe would actually be good, if it wasn't already a valid char for identifiers
06:53:28 <Turmfalke> When is it necessary to make important identifiers in your IDE?
06:53:36 <Turmfalke> *to mark
06:54:19 <maerwald> Turmfalke: imagine a 50 LOC function that does all sorts of IO catching and other awful work... there might actually be only 2-3 interesting function calls in that code, from a logical perspective
06:54:52 <maerwald> it's just support for navigating code
06:55:49 * hackage row-types 1.0.0.0 - Open Records and Variants  https://hackage.haskell.org/package/row-types-1.0.0.0 (dwincort)
06:58:58 <int-e> maerwald: so add a comment to the important line. maybe add some lightweight markup to the comments that the IDE interprets.
06:59:28 <maerwald> int-e: what markup?
06:59:39 <int-e> I don't know. <b>IMPORTANT</b>
06:59:45 <maerwald> I don't think comments solve this 
07:00:26 <int-e> I think comments can highlight code sections well enough.
07:00:30 <maerwald> you want the identifier in a different color and be able to "clicl" on it (goto), not try to find the matching identifier after reading the comment
07:00:39 <int-e> But more importantly they are available *today*.
07:00:48 <int-e> No, *you* want that.
07:00:54 <maerwald> yes
07:01:43 <int-e> Also nothing is stopping you from having some IDE-managed special comment at the end of the file that lists important identifiers. It doesn't have to be inline.
07:01:56 <int-e> (And I think trying to do this inline is a recipe for desaster)
07:02:22 <int-e> (Given Haskell as is, with its indentation sensitivity.)
07:02:53 <int-e> disaster, I wonder where I picked up that spelling with "e".
07:05:36 <tinga> `cabal install wx --reorder-goals` is giving me "cabal: Failed to build wxcore-0.11.1.2 (which is required by wx-0.11.1.2). The failure occurred during the configure step. The build process terminated with exit code 2"
07:05:59 <tinga> .cabal/logs/ghc-8.8.3/wxcore-0.11.1.2-2ba62e9fe9945939fadb6b954ede8cd83cb192b27106f1658865036d1bea61d9.log shows: "error: Unknown option "--sysconfdir=/home/chrishaskell/.cabal/store/ghc-8.8.3/wxcore-0.11.1.2-2ba62e9fe9945939fadb6b954ede8cd83cb192b27106f1658865036d1bea61d9/etc"."
07:06:15 <tinga> What should I do :) ?
07:08:06 <maerwald> what's the cabal version?
07:08:24 <tinga> cabal-install version 3.0.0.0
07:08:27 <lemmih> tinga: You could unpack wxcore and try to build it. It should still fail but you'd be in a better stop to fix it.
07:08:55 <tinga> lemmih, but, where, with what options, is there an easy way to know that from the cabal library?
07:09:13 <tinga> (This sounds like the cabal package expects a different version of wx than it uses; how comes, I thought it downloaded the wx source code itself?)
07:09:31 <lemmih> tinga: 'cabal unpack wxcore'
07:09:45 <tinga> k
07:12:08 <tinga> `cabal build --reorder-goals --minimize-conflict-set` -> "After searching the rest of the dependency tree exhaustively, these were the goals I've had most trouble fulfilling: base, process, wxdirect, wxcore, directory"
07:12:24 <tinga> How comes it now has a dependency resolution issue when it went past that before?
07:12:31 <lemmih> tinga: Try just 'cabal v2-build'.
07:12:59 <tinga> Same result.
07:13:14 <tinga> Same also with: cabal v2-build --reorder-goals  --minimize-conflict-set
07:14:26 <tinga> Cabal hates me, literally every time I try to do something with Haskell I'm running into cabal issues.
07:14:30 <lemmih> tinga: wxcore-0.92.3.0 builds fine on my box. Do you need 0.11.1.2?
07:14:49 * hackage kmonad 0.4.1 - Advanced keyboard remapping utility  https://hackage.haskell.org/package/kmonad-0.4.1 (david_janssen)
07:14:52 <lemmih> wx-0.11.1.2 is 11 years old. I doubt it still works.
07:15:16 <tinga> I just wanted "wx", I don't mind the version; well, unless wxAsteroids requires a particular one, I tried to install that first.
07:15:33 <maerwald> tinga: did you try with cabal-3.2?
07:16:00 <tinga> This *is* wxcore-0.92.3.0 btw
07:16:00 <lemmih> Ah, wx-0.92.3.0 fails for me. I think it is too old and has bitrotted.
07:16:18 <int-e> maerwald: I think I'd probably care more about this dynamically... have the IDE highlight identifiers that I care about in a particular moment.
07:16:57 <int-e> And at that point it's 100% on the IDE side.
07:18:14 <lemmih> tinga: wx no longer builds with recent versions of GHC. You need GHC 8.4 or older to build it.
07:18:30 <maerwald> int-e: no, I'm thinking about reading code from other ppl and want to have an idea about the structure of the code without writing them an email
07:18:32 <tinga> OK, thanks.
07:18:44 <tinga> Maybe I'll just try to find another Haskell game example-
07:19:07 <maerwald> ppl write shitty documentation or none at all
07:19:33 <maerwald> whether marking identifiers as important for the logical control flow works better... I don't know
07:19:42 <maerwald> but in verbose IO code, I think it's easy to use
07:19:51 <lemmih> tinga: I can suggest a lovely Haskell library if you're interested in animations rather than games. :)
07:20:03 <int-e> ...and you'd trust them to highlight the important parts of the codefor you?
07:20:13 <maerwald> trust? Enforme
07:20:15 <tinga> lemmih, happy to give it a try!
07:20:16 <maerwald> Enforce
07:20:26 <int-e> good luck with that
07:20:38 <maerwald> int-e: that's a problem of hierarchy :)
07:21:04 <lemmih> tinga: https://github.com/reanimate/reanimate. And there are interactive examples here: https://reanimate.github.io/reanimate/playground/
07:21:27 <maerwald> int-e: and easy to solve for your own projects (and any PRs you accept)
07:21:46 <lemmih> tinga: And a few more examples here: https://reanimate.github.io/
07:22:05 <maerwald> but making ppl jump through weird hoops doesn't increase contribution frequency
07:22:26 <tinga> Thanks lemmih 
07:24:50 <maerwald> int-e: then again... maybe statical code analysis can do the same
07:27:03 <maerwald> for example, you could give all identifiers from prelude a low score, since those are generic functions mostly
07:27:46 <maerwald> "local" identifiers could then maybe scored differently (implementation size? branch numbers?)
07:28:05 <maerwald> or occurence
07:29:13 <maerwald> then you could have ~3 brightness levels for identifiers
07:29:15 <maerwald> awesome
08:03:47 <qualiaqq> Perhaps this isn't the place for this question. I was wondering if anyone could share tips / mental hacks / organizational techniques for staying focused and motivated on projects?
08:05:15 <qualiaqq> There's so many things I want to do and learn, but I feel motivation comes and goes. It really blows me away how some people really seem rich in this category. I recently started "watching" the haskell-language-server project, and really any active project this is probably the case, but it blows me away how consistently productive some people are. Maybe my issue is simpler than I'm making it out to be. Like I should exercise more and
08:05:15 <qualiaqq> get out more.
08:15:39 <lucky> qualiaqq: Routines and focus, maybe.  There are so many distractions to drown yourself in.
08:16:55 <maerwald> qualiaqq: technique one: quit IRC
08:17:00 <maerwald> try it xD
08:17:32 <maerwald> I'll let you know about technique two afterwards
08:18:37 <MarcelineVQ> idk what 2 is but 3 is turn off the internet for a week
08:18:50 <qualiaqq> I rarely get on IRC though.
08:18:55 <MarcelineVQ> I got a lot done the one time that happened
08:21:31 <sm[m]> qualiaqq: you named one of the best tools, exercise. Do it daily and first thing in the morning for more brain health and better focus
08:22:06 <maerwald> my opinion is that trying hard to focus doesn't work... if you can't focus, try to relax until you get bored
08:23:21 <sm[m]> qualiaqq: it's a big topic but I'll throw out one other tool that I think is great, the Tiny Habits book
08:23:48 <qualiaqq> sm[m]: Yea I realized at some point that I can't ignore my body like I've been doing and expect to not feel like shit all the time.
08:24:17 <sm[m]> Definitely not
08:24:35 <sm[m]> walking is a good place to start
08:24:55 <maerwald> yeah, just avoid doing sports
08:25:51 <qualiaqq> Yea I started doing that with my wife recently. Planning to go to the park today with my dog and perhaps wife and kids if they want to come.
08:28:11 <qualiaqq> One thing I'm wondering. Is there a social aspect to contributing to active open source projects? I've never sucessfully gotten involed in any most of the crap I do on Github is solo and mostly trash no one else can use. I'm wondering if there's some social aspect I'm missing that keeps each contributer motivated?
08:28:38 <maerwald> anger
08:29:03 <maerwald> something pisses you off and you want to fix it... that's how everything starts
08:29:04 <qualiaqq> lol. let the anger flow through you
08:30:31 <sm[m]> qualiaqq: it varies, but working on something enjoyable/useful with others that feel the same way is a common motivator
08:31:12 <sm[m]> for some of us it's escape from less sociable/less fulfilling work
08:31:28 <qualiaqq> I often feel programming is like grinding the ladder in Star Craft (if you ever played a game like that). And sometimes I want to be more like a mmorpg. I don't play games much anymore, but perhaps you get the anology.
08:33:24 <maerwald> open source projects often get less social the more people are contributing
08:34:46 <qualiaqq> That's interesting.
08:35:18 <sm[m]> hackathons, meetups and conferences (virtual now) are great ways to boost sociability and motivation
08:36:09 <maerwald> sm[m]: the most awkward meetup I've had was a rust meetup at Mozilla in Berlin... lots of nerd power, but ppl were anxious to talk to each other :p
08:37:13 <sm[m]> were not ? well yes they don't always work :)
08:37:21 <maerwald> the haskell meetups went better, in fact, but the group was smaller, which I think is important
08:37:47 <maerwald> there seems to be a comfortable group size for programmers... maybe 5-8 ppl
08:38:07 <qualiaqq> sm[m]: That's a great idea. I ought to get involed with something like that. I just wish I live closer where Haskell is more active.
08:38:31 <sm[m]> qualiaqq: that isn't a factor any more, everything has moved online
08:39:04 <qualiaqq> Oh true.
08:39:25 <Lycurgus> there's still people waitin to lower the on-site boom as soon as they can, if they can
08:39:31 <sm[m]> there've been some great virtual conferences lately
08:39:47 <Lycurgus> flesh hunger oder
08:39:51 <qualiaqq> That is perhaps to only thing positive thing Covid has done is make remote work more socially accepable.
08:40:21 <sm[m]> well.. it also reduced LA traffic
08:41:25 <sm[m]> and cleaned the air. But we digress. Where's the Haskell angle..
08:41:42 <Lycurgus> haskell meetups
08:42:17 <Lycurgus> *meatups
08:42:19 <sm[m]> on ghc yesterday someone asked about a weekly irc meeting
08:42:48 <sm[m]> Haskell could have a weekly something or other if someone energetic organized it
08:43:32 <sm[m]> Sharing Saturday.. or a monthly hackathon
08:45:05 <qualiaqq> Where is this kind of stuff talked about? Here on IRC? Reddit? or some other place?
08:45:21 <mmaruseacph2> there is already Monday Morning Haskell blog
08:45:28 <mmaruseacph2> and the Haskell Weekly on Thursday
08:50:53 <sm[m]> Those are good but different
08:52:07 <sm[m]> qualiaqq: mainly here, reddit, and haskell-cafe mail list. Increasingly there are active subcommunities on other chat platforms as well, eg Zulip
08:53:03 <sm[m]> Also planet haskell's feed includes a number of haskell bloggers
08:58:54 <qualiaqq> Thanks I'll check those out!
09:06:23 <hexagoxel> is there a way to make haddock print locations in its warning messages?
09:06:38 <hexagoxel> how do I pass haddock options to `cabal haddock` ?
09:11:06 <phadej> cabal haddock --help|grep haddock
09:12:26 <hexagoxel> but haddock has more options than those. Or is cabal using a haddock-library instead of a haddock executable?
09:13:37 <monochrom> There is a clause covering generally "--PROG-option=" and "--PROG-options=", these probably apply to s/PROG/haddock/ as well, give it a try.
09:16:42 <hexagoxel> I tried --haddock-options="-w", did not seem to have much of an effect. And I fail to spot how cabal calls haddock in the cabal --verbose output too.
09:17:58 <hexagoxel> it calls »haddock '@…/dist-newstyle/…/haddock-response255348-12.txt' -w -w«
09:19:32 <hexagoxel> but doing that manually gives empty output? maybe things are passed via ENV?
09:20:43 <monochrom> What is @ doing there?
09:20:51 <geekosaur> response file
09:21:07 <geekosaur> all the options should be in the specified file
09:21:20 * hackage HTTP 4000.3.15 - A library for client-side HTTP  https://hackage.haskell.org/package/HTTP-4000.3.15 (GaneshSittampalam)
09:21:40 <geekosaur> and the file might not exist at the point hexagonel is trying it manually
09:21:42 <monochrom> When "doing that manually", does that file even exist anymore?
09:22:20 <hexagoxel> nah, it does not
09:24:13 <geekosaur> I'm wondering about that -w being there twice, and if it's a toggle option (…oops…)
09:25:24 <hexagoxel> yeah that is weird. it duplicates whatever I pass. if I do »cabal haddock --haddock-options='abc'« it calls »haddock '@…response….txt' abc abc«
09:26:04 <sshine> I'm trying to make Haskell CI work with GitHub Actions. during 'cabal v2-build' I'm getting "##[error]The operation was canceled." https://github.com/sshine/evm-opcodes/runs/1106195335?check_suite_focus=true#step:7:420 -- my GitHub Actions workflow is at https://github.com/sshine/evm-opcodes/blob/master/.github/workflows/haskell.yml -- I'm not sure exactly what's wrong, since 'cabal v2-build' does work 
09:26:10 <sshine> locally. has anyone tried this?
09:31:20 <geekosaur> timeout, maybe?
09:37:26 <qualiaqq> Maybe you hit some usage limit: https://docs.github.com/en/actions/getting-started-with-github-actions/about-github-actions#usage-limits
09:39:57 <sshine> qualiaqq, oh I bet. -_-
09:40:26 <sshine> then it's probably memory, since that's what I've been coping with when building Haskell code in Docker containers.
09:41:30 <sshine> I followed this blog post; https://markkarpov.com/post/github-actions-for-haskell-ci.html -- it doesn't mention "Oh, this doesn't work for the free tier of GitHub Actions."
09:47:00 <qualiaqq> This probably won't help and is probably dated, but might give you an idea. https://mpickering.github.io/posts/2019-06-24-overkill-or-not.html
09:47:52 <qualiaqq> That's not using Github Actions. I just remember thinking it was kinda cool to use nix and cache builds with cachix.
09:49:10 <sshine> yeah :) I might end up doing that. I just thought I'd see what all the fuss was about wrt. GitHub Actions.
09:50:22 <sshine> so 'stack test' works fine, but 'cabal v2-test' complains that 'tasty-discover' isn't in my path. what's the right way to put it in my path?
09:55:11 <sshine> I don't seem to have a 'tasty-discover' binary in my project directory prior to 'cabal v2-build', which would be weird, since it's only a dependency for the 'test' target.
09:55:21 <sm[m]> sshine: I think GitHub is pretty generous, I've had no memory trouble. Try it locally and watch with top to see if it's unusually huge ?
09:55:55 <sshine> sm[m], I think actually my problem is that tasty-discover is breaking in one of 3 parallel CI builds, and that cancels out the other two with the uninformative cancellation message.
09:56:18 <sshine> https://github.com/sshine/evm-opcodes/runs/1106195324?check_suite_focus=true#step:7:441
09:56:26 <sshine> so this boils down to me being a Cabal retard.
09:56:42 <sm[m]> debugging CI is the new sport/chore...
09:56:57 <sshine> I actually can't make 'cabal v2-test' work locally, either. same problem. ;)
09:57:37 <sshine> I just figured, maybe this is MacOS-related. maybe it is. how do make cabal-3.2 compile tasty-discover and place the binary in $PATH?
09:58:12 <sshine> this apparently works seamlessly with 'stack test', but because this is a library, I'd like to make it work with both Stack and Cabal.
09:58:22 <sm[m]> I guess when the problems happen on a slow/inaccessible remote worker, they are highlighted and we are forced to confront them instead of work around and move on
09:59:42 <qualiaqq> sshine: have you see this example project setup using tasty?: https://git.coop/decentral1se/tasty-discover/-/tree/master/test
10:00:14 <qualiaqq> I found that in their readme. Perhaps you'll see something a little off in your project by comparing the two. (just guessing)
10:01:33 <sshine> qualiaqq, your name sounds greenlandic, btw. :)
10:02:01 <sshine> 'qujanaq' means 'thank you'.
10:02:37 <qualiaqq> Guess that doesn't have a cabal file in there. https://git.coop/decentral1se/tasty-discover#getting-started has an example.
10:04:32 <qualiaqq> That's interesting. I never heard that before. I just got the idea for my name from how some Chinese farmers wold name themselves in an old game called Lineage 2.
10:05:01 <qualiaqq> Some would put QQ at the end of their name because that was a popular chinese chat application at the time.
10:06:09 <qualiaqq> also sort of a pun on rage quitting a game.
10:06:56 <qualiaqq> I forget which game it was that had a short cut to quit the game that was similar to pressing qq.
10:08:43 <qualiaqq> Think it was Wascraft II.
10:09:37 <sshine> doing 'cabal v2-configure --enable-tests' I get something informative: In order, the following would be built (use -v for more details): ... tasty-discover-4.2.1 (exe:tasty-discover) (requires build) ...
10:10:16 <sshine> so clearly, cabal agrees with me, I need the executable installed before I can run it.
10:10:42 <sshine> what's the cabal command for installing that executable? I tried with 'cabal v2-install exe:tasty-discover', but that doesn't seem to hit it.
10:11:13 <qualiaqq> I guess it's a preprocessor program that needs to be installed. Maybe you can cabal install it if you want it globally.
10:11:56 <sshine> oh, 'cabal v2-install tasty-discover' will actually place this file in /Users/sshine/.cabal/bin/tasty-discover, I think.
10:12:46 <sshine> I don't really care to have it globally. I mostly use Stack for Haskell development, and I'll have to make a leap to Nix anyways to make sense of things, so using cabal-3.2 right now is mostly to please CI.
10:13:31 <sshine> does this mean that my CI script should explicitly install tasty-discover, or is there some way to instruct cabal to install its test dependencies before testing, whether these are programs in $PATH or libraries in some temporary build dir?
10:14:33 <sshine> or is cabal not responsible for the presence of tasty-discover, even thought it is capable for reporting its necessity of being there via 'cabal v2-configure --enable-tests'? I know that Stack over-extends a bit on being responsible for things, but I don't know where cabal draws the line.
10:14:48 <qualiaqq> Looks like a lot of people taht use nix include it as a test dependency in their shell/default.nix file https://github.com/search?l=Nix&&type=Code&q=tasty-discover
10:15:36 <qualiaqq> here's one example https://github.com/yurrriq/aoc19/blob/9143fb7daa96c4372519f40a0b35b5fed59592dd/default.nix#L15
10:16:12 <sshine> thanks for exploring that.
10:16:36 <sshine> my current goal is to make this library compile with stack and cabal out of the box. then I'll look at Nix.
10:17:22 <jcowan> Is there a principled reason why foldr wants f to take arguments in the order "new before old", whereas foldl wants f to take them in the opposite order, "old before new"?
10:18:24 <sshine> jcowan, I don't know, but I can tell you that Standard ML's foldl and foldr take their arguments the same way. :)
10:19:21 <jcowan> Thanks.  Perhaps I'll ask on #ml, if there is one.
10:19:22 <dolio> The order makes sense if you think about how the chained expressions would look like.
10:19:31 <geekosaur> does it help that foldr is basically replacing [] with the initial value and (:) with f in the list representation a : b : c : [] ?
10:19:42 <lyxia> > foldr (+) z [a, b, c]
10:19:44 <lambdabot>  a + (b + (c + z))
10:19:49 * hackage product-profunctors 0.11.0.1 - product-profunctors  https://hackage.haskell.org/package/product-profunctors-0.11.0.1 (tomjaguarpaw)
10:19:51 <dolio> foldl ends up like `(((z `f` x) `f` y) `f` z)`
10:19:53 <lyxia> > foldl (+) z [a, b, c]
10:19:55 <lambdabot>  z + a + b + c
10:20:02 <dolio> Ah, yeah, there you go.
10:20:50 * jcowan contemplates the above
10:22:15 <geekosaur> (((z + a) + b) + c) vs. (a + (b + (c + z)))
10:22:20 * hackage diohsc 0.1.2 - Gemini client  https://hackage.haskell.org/package/diohsc-0.1.2 (mbays)
10:24:12 <jcowan> Thanks, all!
10:24:47 <dolio> That's not the only decision you could make, but it's one.
10:27:48 <jcowan> The alternative is to pick one order and stick with it.  With eager lists, cons order (new before old) probably makes the most sense for both folds, since foldl is tail recursive in that case and foldr is not.
10:28:50 * hackage hnix 0.10.0 - Haskell implementation of the Nix language  https://hackage.haskell.org/package/hnix-0.10.0 (AntonLatukha)
10:29:38 <dolio> I'm not sure that really matters. The other argument I can think of is that you should match the `(a -> r -> r)` argument with the rest of the function like `[a] -> r -> r` so that you can compose multiple folds more readily.
10:29:42 <ski>   val foldl : ('a * 'b -> 'b) -> 'b -> 'a list -> 'b
10:29:49 <ski>   val foldr : ('a * 'b -> 'b) -> 'b -> 'a list -> 'b
10:29:54 <ski> (that's in SML)
10:30:14 <dolio> However that probably favors foldl order, because it's also nice to have the list be the last argument.
10:30:46 <sshine> I like when they have the same order.
10:31:27 <ski>   val fold_left : ('b -> 'a -> 'b) -> 'b -> 'a list -> 'b
10:31:34 <ski>   val fold_right : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
10:31:37 <ski> (that's OCaml)
10:33:00 <ski> sshine : seems to me it doesn't
10:34:01 <sshine> ski, huh?
10:34:07 <sshine> ski, you mean in Haskell?
10:34:42 <ski> jcowan : in the ordering chosed by OCaml, you can compose they with themselves (and each other), like e.g. :  fold_left o fold_left : ('b -> 'a -> 'b) -> 'b -> 'a list list -> 'b
10:34:49 <sshine> wow, OCaml's is slightly confusing because they flip the 'a and the 'b. :)
10:35:27 <ski> sshine : no, i meant the SML version
10:35:40 <jcowan> Well, that's the whole problem with the obsession with single-letter variables.  See APL, or worse yet, K, or worse yet, the C in which the K implementation is written.
10:36:09 <dolio> You don't need multiple letters to be consistent.
10:36:56 <dolio> And you can be inconsistent with multiple letters.
10:37:28 <jcowan> "Consistent" isn't the same as "what you expect."  If the type names were *names*, the difference wouldn't bother you.
10:37:58 <jcowan> "Oh, they put old before new."  Looking at a's and b's, you don't know if the difference is semantic or merely syntactic.
10:38:51 <ski> (what's this "new" and "old" ?)
10:44:26 <dolio> They didn't change the order of the arguments. They swapped the naming convention between the two functions instead of using the same one.
10:46:48 <monochrom> You like names? OK, foldr :: (john -> mary -> mary) -> mary -> [john] -> mary
10:48:39 <[exa]> monochrom: this genealogical interpretation of foldr shocks me
10:49:28 <ski> (hm, presumably the naming on those signatures comes from type inference)
10:49:35 <monochrom> Seriously you don't need longer than length-1 names if: 1. There are only two names, and 2. The function is so polymorphic, applicable to so many diverse and unrelated use cases, that any "meaningful" name is going to be overly specific to one use case and offends all of the other use cases.
10:54:02 <kindaro> What is the recommended reading on non-algebraic data types?
10:54:30 <kindaro> What I mean is abstract data types with smart constructors, such as `Set`.
10:55:02 <kindaro> There is a huge literature on mathematics of program construction, but abstract types are hardly mentioned.
10:56:19 <kindaro> For another example, it has been discovered that graphs can be represented by algebraic data types _(see `alga`)_, but edge labels are not available.
10:57:49 <kindaro> I wonder if there is any methodology for deciding whether a given mathematical construction can or cannot be represented as an algebraic data type, that says _«yes»_ to _«graph»_ and _«no»_ to _«graph with edge labels»_
11:01:20 * hackage uniqueness-periods-vector-common 0.3.0.0 - Generalization of the dobutokO-poetry-general package functionality  https://hackage.haskell.org/package/uniqueness-periods-vector-common-0.3.0.0 (OleksandrZhabenko)
11:03:06 <jcowan> ski: by new I mean the next element to be fed to f, and by old I mean the state representing all the previous elements fed to f.
11:04:00 <ski> oh. okay
11:04:30 <dolio> ski: Yeah, I think that variable ordering is what happens when you let the compiler come up with stuff for certain definitions. GHC used to have the same swapping.
11:05:20 <dolio> Although, now that I think about it, the GHC swapping is just because the 'accumulator' comes first in foldl.
11:05:35 <dolio> So ocaml must be doing something else.
11:05:40 <ski> i guess for `foldl'/`fold_left', you can think of it as combining each element of the list, from the left, with the current state/result. while for `foldr'/`fold_right', you think of it as working your way from the right (although for Haskell it's a bit subtle since `foldr' here also works for infinite lists ..)
11:06:31 <ski> OCaml does the same thing as Haskell, except that it accepts the list before the initial state/accumulator
11:07:02 <ski> it's SML that does the callback argument ordering differently. presumably they decided they wanted the same ordering for both `foldl' and `foldr'
11:07:10 <dolio> Not according to the types you wrote.
11:07:46 <ski> let me alpha-convert
11:07:53 <ski>   val fold_left : ('b -> 'a -> 'b) -> 'b -> 'a list -> 'b
11:08:03 <ski>   val fold_right : ('b -> 'a -> 'b) -> 'b -> 'a list -> 'b
11:08:16 * ski double checks
11:09:41 <jcowan> Scheme regrettably has become inconsistent: almost all folds (left and right) are new before old, but the folds for vector-like objects are old before new.  That's what happens when people copy each other but not *all* of them copy each other.
11:09:59 <ski> hm. i'm sorry. seems i managed to state the `fold_right' one wrong :/ should be :
11:10:05 <ski>   val fold_right : ('a -> 'b -> 'b) -> 'a list -> 'b -> 'b
11:10:19 <dolio> Oh, so it lets you compose them, but swaps the ordering.
11:10:23 * ski sighs
11:10:27 <ski> yes
11:10:33 <dolio> So you can't compose fold_left with fold_right easily.
11:10:37 <ski> right
11:10:42 <dolio> Seems like a bad decision.
11:13:16 <dolio> They actually do use a consistent naming convention, then.
11:13:20 * hackage uniqueness-periods-vector-general 0.4.0.0 - Generalization of the functionality of the dobutokO-poetry-general-languages package  https://hackage.haskell.org/package/uniqueness-periods-vector-general-0.4.0.0 (OleksandrZhabenko)
11:16:03 <monochrom> "old" and "new" are misleading.
11:28:49 * hackage uniqueness-periods-vector-general 0.4.1.0 - Generalization of the functionality of the dobutokO-poetry-general-languages package  https://hackage.haskell.org/package/uniqueness-periods-vector-general-0.4.1.0 (OleksandrZhabenko)
11:39:34 <fresheyeball> is there a way to constain a function to take an argument that is NOT a Monad?
11:39:36 <ollehar> You have `show` typeclass to convert a type to string. Do you also have a `query` typeclass, to convert a type to a SQL INSERT statement?
11:39:47 <fresheyeball> NotMonad m => m a
11:39:50 * hackage uniqueness-periods-vector-examples 0.1.3.0 - Examples of usage for the uniqueness-periods-vector series of packages  https://hackage.haskell.org/package/uniqueness-periods-vector-examples-0.1.3.0 (OleksandrZhabenko)
11:41:01 <ski> fresheyeball : no, because of OWA
11:41:08 <fresheyeball> OWA?
11:41:14 <ski> Open World Assumption
11:41:33 <ski> any third party can add an instance declaration for a type
11:41:43 <fresheyeball> hmm
11:43:05 <lyxia> there is no way to tell the difference between "is not a monad" and "its Monad instance is in another module that I don't see"
11:43:27 <fresheyeball> that is fine though
11:43:42 <fresheyeball> I just need to assert that >>= is not in use
11:45:05 <ski> fresheyeball : if you use e.g. `blah :: Applicative i => ..i..', then `blah' can't use `(>>=)' for `i', even if the caller of `blah' would call it with a type selected for `i' that is in fact an instance of `Monad'
11:45:20 <fresheyeball> ski
11:45:22 <fresheyeball> I know
11:45:34 <fresheyeball> but the caller might
11:45:49 <fresheyeball> I need to flip the relationship
11:45:51 <ski> well .. maybe you want to turn tables, then ?
11:45:55 <ski> use rank-2 ?
11:46:06 <fresheyeball> oh hmmm
11:46:11 <ski>   blah :: (forall i. Applicative i => ..i..) -> ...
11:46:19 <fresheyeball> oh!
11:46:21 <fresheyeball> that might do it
11:46:33 <ski> now the caller can't pass a callback that uses `(>>=)' for `i'. but `blah' itself can select an `i' that is an instance of `Monad'
11:48:17 <ski> (rank-2 is also useful for hiding the choice, in this case of `i', that the callee (`blah') picks)
11:49:06 <sshine> fresheyeball, also, a not-Monad probably doesn't have good properties.
11:50:33 <geekosaur> that's debatable
11:51:11 <geekosaur> Monad gives you some useful properties at the expense of other useful properties, otherwise we wouldn't bother with Applicative
11:52:17 <sshine> geekosaur, yes, but I'm not talking about the lack of a Monad constraint, but rather, the idea of a NotMonad constraint. so while there are lots of other things that isn't a Monad that is useful, like Applicative and Functor, NotMonad probably isn't. :)
11:52:22 * ski idly ponders how one'd define complement of a submonoid, or subgroup
11:54:43 * sshine idly wonders if NotMonad is a subclass of NotDragon.
11:54:59 <geekosaur> NotFuzzyThing
11:55:26 <fresheyeball> ski: so with the RankN approach
11:55:33 <monochrom> It would have been better to ask and answer why a not-monad notion was needed.
11:55:55 <fresheyeball> if I have foo :: (forall f. Applicative f => f Int -> Int) -> Int
11:56:05 <fresheyeball> can I pass a function there where f is a Monad?
11:56:07 <sshine> https://www.reddit.com/r/AskReddit/comments/1h1cyg/whats_the_most_intellectual_joke_you_know/capvdoh?utm_source=share&utm_medium=web2x&context=3
11:56:16 <fresheyeball> I can right? But I can't use >>= in that function
11:56:18 <fresheyeball> yes?
11:56:47 <ski> fresheyeball : no, the caller must pass a callback that works for all idioms `f'. it can not assume anything about `f', apart from it being an instance of `Applicative'
11:57:01 <sshine> fresheyeball, what are you trying to do?:
11:57:08 <ski> you can't pass a callback of type `Reader [Int] Int -> Int', e.g.
11:57:10 <fresheyeball> ski that nails it
11:57:18 <ski> fresheyeball : good, or bad ?
11:57:21 <sshine> avoiding X-Y :) http://xyproblem.info/
11:57:51 <monochrom> This one is probably not an XY problem. But it's definitely an undefined problem.
11:58:36 <sshine> sounds like the problem is "How do I limit users of my library from accessing it using (>>=)?"
11:59:19 <sshine> if that is the question, then not specifying any (>>=) instances might solve it? :)
12:01:04 <ollehar> 18:58 < ollehar> In Haskell you can split the definition of a type to multiple files, right?
12:01:17 <ollehar> If you want to add typeclasses.
12:01:30 <monochrom> No.
12:01:36 <ollehar> crap
12:01:49 <ski> ollehar : i think you can probably split mutually recursive definitions of types into multiple files, if you fiddle with recursively importing modules ..
12:02:03 <ski> but a single type definition .. alas, no
12:02:31 <fresheyeball> ski: ok no it doesn't work
12:02:50 <geekosaur> depends on wht that appendage meant, actually. the type can be in one file, the typeclass definition in another (but you'll get a warning about it being an orphan, because it can lead to spooky action at a distance)
12:02:51 <ski> (it might also be reasonable to parameterize one by the other, to avoid the cycle)
12:02:52 <ollehar> So I have an Order type and I want to add both `show` and a `query` typeclass that creates a SQL SELECT query, I must add them in the same file?
12:03:00 <ski> fresheyeball : what didn't work ?
12:03:11 <monochrom> No.
12:03:12 <fresheyeball> I was able to sneek in a Monad
12:03:37 <geekosaur> yes, you can use a Monad, you just can't use it *as* a Monad
12:04:19 <fresheyeball> can to
12:04:31 <fresheyeball> because my version it returns the rank thing
12:04:50 <fresheyeball> setMC :: (a -> b) -> (forall m. Functor m => f m a -> f m b)
12:05:04 <ski> fresheyeball : that's not rank-2
12:05:29 <ski> that's just the same as `setMC :: Functor m => (a -> b) -> f m a -> f m b'
12:05:36 <fresheyeball> right
12:06:02 <ski> what are you trying to do ?
12:06:08 <monochrom> Finally.
12:06:16 * ski smiles
12:06:26 <fresheyeball> ok
12:06:34 <fresheyeball> so I have a library I am working on
12:06:44 <fresheyeball> and there is an ergonomics problem
12:06:45 <ollehar> monochrom: no?
12:07:00 <monochrom> You can write your instances in another file.
12:07:00 <fresheyeball> this function works and is typesafe
12:07:08 <ollehar> monochrom: alright, that's good!
12:07:14 <ski> ollehar : no, instance declarations can be in another module
12:07:29 <fresheyeball> liftMC :: MC f => Functor m => (a -> b -> b) -> (b -> a) -> f m a -> f m b
12:07:52 <fresheyeball> problem is that this becomes a valid ideom 
12:08:04 <ski> ollehar : although, you quite possibly want to avoid having the instance declaration be in a different module than both the type and the type class .. but it depends
12:08:25 <fresheyeball> liftMC (\x _ -> setter x) (error "Impossible") y
12:08:45 <fresheyeball> which is perfectly typesafe so long as `m` is only a functor
12:09:05 <fresheyeball> because we never use the getter function, it doesn't get evalled
12:09:14 <fresheyeball> and so I would like to write a function to make this case nicer
12:10:05 <fresheyeball> setMC :: MC f => Functor m => (a -> b) -> f m a -> f m b
12:10:09 <fresheyeball> would do the trick
12:10:11 <ollehar> ski: I'm thinking "it should be possible to add new features without touching old code"
12:10:16 <fresheyeball> but I don't see how to write it in a type safe way
12:10:51 <fresheyeball> if it was Rank-2 I see how it could be safe
12:15:13 <ski> ollehar : have you looked into "The Expression Problem", perhaps ?
12:15:56 <ski> fresheyeball : what is the particular unsafe cases, of those `liftMC' and `setMC' ?
12:16:18 <monochrom> ollehar: Should it be possible to have a race condition on adding new features without touching old code?  Because it is a logical conclusion of being possible to add new features without touching old code.
12:16:25 <ollehar> ski: yeah, i know this :) I'm a PHP dev really, discussing a similar topic in the ##php channel on how to best separate behaviour and data, and what to give access to.
12:16:47 <ollehar> monochrom: that's unrelated, race condition is a runtime problem.
12:16:58 <fresheyeball> ski: if they use the monadic interface, then the getter will get called
12:17:10 <fresheyeball> and so (error "impossible") will fire
12:17:25 <monochrom> Here is an example of such a race condition. You create F.hs to hold "instance Show T".  I also create G.hs to hold "instance Show T".  For some other reason, the program has to link both your F.hs and G.hs together.
12:17:26 <fresheyeball> but if they don't lazy eval saves us and it's safe
12:17:56 <fresheyeball> I just tried this but no dice
12:18:12 <monochrom> And I'm extending "race condition" to race condition between two programmers during programmingtime.
12:18:21 <fresheyeball> setMC :: MC f => Functor n => (a -> b) -> (forall m. m ~ n => Functor m => f m a) -> f n b
12:18:28 <fresheyeball> but it all compiles :(
12:18:34 <monochrom> Programmingtime is the most important and most ignored time.
12:18:37 <ollehar> monochrom: that's a merge issue, not a race condition
12:18:59 <ski> fresheyeball : i don't follow
12:19:06 <monochrom> Well I tossed it out as food for thought.
12:19:11 <fresheyeball> I tried to move the forall up to be Rank2
12:19:26 <fresheyeball> but the m ~ n is needed in practice or things that should type check wont
12:19:54 <fresheyeball> and having it, ruines the Rank2 property of "this f m a cannot use m as a Monad"
12:20:00 <ollehar> monochrom: alright ^^
12:20:03 <ski> fresheyeball : yes, `forall m. m ~ n => ..m..' is equivalent to just `..n..'
12:20:25 * ollehar I should order Real World Haskell until OCaml implement their effect system...
12:20:38 <monochrom> If you hold a certain freedom as a tenet, but that freedom logically leads to conflicts, what do you do?  Do you still hold that tenet as strongly as before?  Do you accept to weaken it a little bit?
12:20:39 <ski> fresheyeball : are you trying to prohibit `setMC', or its caller, from using something as a monad ?
12:20:54 <fresheyeball> yes correct
12:21:15 <dolio> That was a 'which one' question.
12:21:17 <fresheyeball> it's type safe so long as the second argument `f m a` cannot use `m` as a Monad
12:23:38 <monochrom> GHC takes a "warn it" stance on this. If you write "instance Show T" in a file that neither defines T nor defines "class Show a", GHC warns you "this is an orphan instance".  An import is that if everyone does this too often, the conflict I described tends to happen.  Still, it is just a warning, you can still do it after a conscious decision.
12:23:59 <monochrom> (Another import is that this ruins separate compilation.)
12:24:08 <ezzieyguywuf> is there a builtin function that does something like `and (xs <$> flip (elem ys)) && length xs == length ys` ?
12:24:26 <ezzieyguywuf> i.e. check that both lists are the same length and contain the same elements (though not necessarily in the same order)
12:24:29 <monochrom> (A few more files than you expect need recompiling when you make a small change.)
12:24:48 <dolio> Also not the same number of times?
12:25:00 <ollehar> monochrom: OK, so it's not idiomatic to do this? You just continue in the same file forever with all behaviour related to T? That's nasty...
12:25:03 <ezzieyguywuf> dolio: not worried about duplicates.
12:25:49 <ezzieyguywuf> (although with the length check I think a duplicate would fail the check anyway)
12:26:10 <dolio> [0,0,1] [0,1,1]
12:26:20 <monochrom> I don't hold "add features without touching old code" as a fundamental non-negotiable tenet in the first place.
12:26:31 <ezzieyguywuf> lol, ok you beat my algorithm. but I still want to erform the check though
12:26:35 <ezzieyguywuf> maybe I should be using a Set...
12:26:44 <monochrom> "add" and "feature" are simply too vague too broad too good to be true.
12:26:46 <geekosaur> tbh this sounds like abusing a list to be a set or bag, which is unfortunate if the list is longer than a few elements
12:26:53 <dolio> Well, it's not set equality exactly.
12:26:54 <ollehar> monochrom: no, but you probably care about how data and behaviour is separated?
12:27:03 <dolio> If you care about the lengths being equal.
12:27:13 <ezzieyguywuf> geekosaur: yea, I'm thinking along these lines too (though this is the first I've heard of a bag)
12:27:21 <dolio> Because [0,0,1,1] is different from those two.
12:27:29 <ezzieyguywuf> dolio: two sets can be equal but different lengths?
12:27:37 <geekosaur> it's a set where an element can be present multiple times (as a count associated with the element)
12:27:43 <dolio> Two representations of a set as a list can have different lengths.
12:27:46 <monochrom> I think neither.  I think a lot of times my data is an implementation or even encoding of my behaviour.
12:27:59 <ezzieyguywuf> I thought "set" meant "list without duplicates"
12:28:24 <dolio> Well, it doesn't mean that, because lists are ordered.
12:28:41 <monochrom> Not all the time. But a lot of times.
12:29:10 <ezzieyguywuf> lol, I guess I don't know a whole lot about Set, i thought it too was ordered.
12:29:18 <monochrom> If I code up a complex number type...
12:29:32 <dolio> You could decide to represent a set as any list containing all and only the elements of the set.
12:29:35 <ezzieyguywuf> or perhaps I'm misunderstanding "ordered"
12:29:58 <ezzieyguywuf> !fromList [3,2,1] :: Set
12:30:09 <ezzieyguywuf> dang, that's not how that works
12:30:11 <monochrom> I choose one way to store a complex number internally. It's probably an implementation detail I won't expose to the user.  Or maybe it's so trivial I can expose it and nothing will go wrong.  I don't know.  But either way...
12:30:13 <geekosaur> well. typically there is an ordering used internally, but what ordering is used should not affect its behavior
12:30:46 <geekosaur> whereas the ordering used for a list affects its behavior
12:31:11 <monochrom> Since the way to code up cosine for complex numbers depends on the way of coding up the complex number itself, this dependency says that it's a better idea to put cosine together with the type definition.
12:31:35 <ezzieyguywuf> a Set created from [3,2,1], [2,1,3], or [1,2,3] will all be equal, right?
12:31:38 <dolio> The point is that there is an equivalence relation on lists such that lists and that equivalence relation model sets. But the equivalence relation your code was deciding is not the right equivalence relation.
12:31:44 <ezzieyguywuf> but neither of those lists are equal
12:31:47 <ollehar> monochrom: I'd say same folder, not same file. But that's me. :)
12:31:58 <dolio> Because it was treating differently sized lists as different.
12:32:16 <ollehar> Especially if you wanna add bunch of new behvaiour to bunch of old data in one pull request.
12:32:23 <monochrom> What you can argue is that if there is a complex number function I haven't forseen, we try to allow users to code it up in another file.
12:32:47 <ollehar> monochrom: This is simply always the case in long-running projects ^^ Our first commit is from 2003.
12:32:50 <monochrom> But here I use "try to" because it doesn't always make sense and it isn't always possible.
12:33:10 <dolio> Also I think it was treating [0,0,1] and [0,1,2] as the same, depending on which was xs and which was ys, so it wasn't even an equivalence relation.
12:37:38 <maerwald> is there a formatter that does minimal amount of *(re-)alignment*?
12:38:19 <monochrom> Do you accept "cat"? :)
12:38:31 <maerwald> as a formatter?
12:38:33 * monochrom discovered that "cat" is the identity of |
12:38:36 <monochrom> Yeah
12:38:46 <maerwald> it isn't really a formatter
12:38:55 <monochrom> It provably does 0 amount of realignment.
12:39:03 <maerwald> it also does nothing else
12:39:28 <geekosaur> perhaps explain what you want, since some form of alignment is usually what people want when reformatting
12:39:29 <monochrom> It outputs legal Haskell code if the input is legal Haskell code, and semantics is preserved too, so it is a formatter.
12:39:29 <dolio> Sounds like the perfect formatter. :)
12:39:51 <maerwald> ok, maybe I can be more specific: indentation is not (only in the cases where it would cause compile errors) based on identifier length ever
12:39:53 <monochrom> Hell, it preserves compile-time errors, too.
12:40:31 <geekosaur> oh, for haskell code? good question, but I'm only aware of two such formatters and they both realign in idiosyncratic ways (imo)
12:40:46 <geekosaur> then again I suppose my own preferred indentation strikes others that way too
12:40:48 <maerwald> brittany is pretty noisy in git diff
12:40:53 <qualiaqq> There's stylish-haskell
12:41:03 <maerwald> stylish-haskell is not a formatter in my opinion
12:41:37 <maerwald> the only thing it's good for, if at all, is sorting imports
12:42:08 <qualiaqq> Brittany might have some settings to reduce the amount of realigning. I haven't checked.
12:42:13 <maerwald> it already breaks down badly on formatting data types
12:42:54 <maerwald> I think it makes sense to want this property from a formatter, because you don't want your git diffs to be noisy
12:43:03 <monochrom> I agree.
12:43:13 <monochrom> I'm too lazy to write one.
12:43:24 <maerwald> let one of your students do it
12:43:40 <maerwald> if they fail, you give them shit, if they succeed, they have to name you as co-author
12:43:42 <geekosaur> ahahaha
12:43:42 <maerwald> :p
12:43:46 <monochrom> Other Haskellers, it seems to me, actually prefer formatting to depend on identifier lengths. So no luck from them either.
12:43:58 <hexagoxel> yeh I need to put a bit more time into the left-align config in brittany. I am aware of (and agree with) the less-diff-noise ideal.
12:44:26 <lortabac> maerwald: AFAIK ormolu is the one that does the least amount of realignment
12:44:28 <maerwald> monochrom: I did too... in my own codebase... when many ppl work on the same codebase, that strategy isn't feasible anymore
12:45:30 <maerwald> and with 4 spaces indentation, there's only one case where you could get a compile error for not aligning based on identifier length (let is fine)
12:45:39 <hexagoxel> maerwald: you can turn off alignment via -- brittany { lconfig_indentPolicy: IndentPolicyLeft }   and  -- brittany { lconfig_columnAlignMode: { tag: ColumnAlignModeDisabled } }
12:46:36 <maerwald> https://paste.tomsmeding.com/unTFZbxf
12:46:47 <maerwald> but I think that's rare style
12:47:10 <qualiaqq> maerwald: Why not just reformat all the code at once in one commit? Then later commits should have less format noise. Although I guess if the formatter doesn't always do the best job, then that's not a good idea.
12:47:41 <maerwald> qualiaqq: reformatting commits are pretty bad
12:47:49 <maerwald> breaks all sorts of stuff
12:47:53 <hexagoxel> (first has to do with hanging indentation, second with not-start-of-line alignment)
12:48:21 <monochrom> "the reformatting commit that ends all reformatting commits"
12:48:50 <maerwald> hexagoxel: yeah... I liked hanging indentation mostly because :: is on the same line and allows to grep for function signatures without tags 
12:48:53 <geekosaur> famous last reformat
12:49:23 <maerwald> yeah, I like git blame to not show nonsense :)
12:49:30 <maerwald> stop covering your ass :p
12:50:45 <qualiaqq> When you say it breaks stuff. Are you talking about code or things like git blame?
12:50:51 <maerwald> yes
12:51:17 <hexagoxel> maerwald: I see.. needs more fine-grained config.
12:51:38 <maerwald> hexagoxel: codex right now is broken for me, so I gave up on haskell tags
12:52:10 <yushyin> lortabac already mentioned it, but minimal diffs is one of ormolu's requirements
12:52:39 <maerwald> yushyin: famous last question... how does it handle CPP :p
12:53:19 <yushyin> afair it does not at all (by design)
12:53:34 <maerwald> so it errors out?
12:53:50 <geekosaur> you can't handle CPP sanely
12:54:28 <maerwald> there must be an insane way, I guess
12:54:39 <yushyin> it doesn't touch it and leaves it as it is, afaik.
12:55:24 <qualiaqq> Looks like the git blame issues could be worked around by doing something like this: https://akrabat.com/ignoring-revisions-with-git-blame/
12:55:35 <yushyin> but I'm really not sure right now
12:57:14 <yushyin> I'm not very fond of ormolu's formatting to tell the truth, so never used it much.
12:58:38 <maerwald> I'm on the fence for 2 vs 4 spaces indentation
12:58:48 <maerwald> I always liked 2 for haskell
12:59:24 <monochrom> I like 2 for every language.
12:59:25 <maerwald> but I guess it's gonna look weird if you stop aligning based on identifier length
13:00:08 <monochrom> But I learned a great reason from tibbe's style guide to do 2-and-4 in Haskell. Because of exceptions due to "where" and "do".
13:00:58 <monochrom> Put "where" on the next line and indent 2. Put the definitions on the next and and indent another 2 (so 4 in total)
13:01:25 <geekosaur> I do that too
13:01:27 <yushyin> that's how I'm used to do it, yes.
13:01:38 <geekosaur> (hm, that also comes up in C but the result is uglier)
13:02:02 <phadej> geekosaur: https://en.wikipedia.org/wiki/Indentation_style#GNU_style ? :)
13:02:08 <monochrom> There is also a strong reason to indent do-content by 4. I mean this: line 1 "main = do"  line 2 "    x <- getLine"
13:02:53 <monochrom> The reason is that if you want a "where" afterwards, then "  where" is visually clear about how the computer parses the whole thing.
13:03:07 <geekosaur> that would figure…
13:03:21 <monochrom> It is legal, but IMO criminal, to go like "            where". It misleads beginners.
13:03:36 <phadej> I often don't give where a new line
13:03:42 <phadej> foo x y = f x + g y where
13:03:45 <phadej>     f z = ...
13:03:48 <phadej>     g z = ...
13:03:55 <c_wraith> That's not terrible, but it does feel like a trap for the reader.
13:04:09 <phadej> there's indentation as a clue
13:04:10 <c_wraith> "why are there more definitions here?  Oh, there was a where hidden up there"
13:04:26 <phadej> it's different when the exprtession is actually long
13:04:27 <phadej> then
13:04:29 <phadej> foo x y =
13:04:32 <phadej>     f x + g y
13:04:34 <phadej>   where
13:04:35 <phadej>    f x = ...
13:04:39 <phadej>     g x = ..
13:04:43 <yushyin> maerwald: https://github.com/tweag/ormolu#current-limitations
13:04:43 <phadej> works better
13:05:19 * hackage swiss-ephemeris 1.1.0.0 - Haskell bindings for the Swiss Ephemeris C library  https://hackage.haskell.org/package/swiss-ephemeris-1.1.0.0 (lfborjas)
13:05:33 <monochrom> It is criminal because of the following.  If "where" is more indented than, or even just same level as, the "x <- getLine" etc stuff, beginners rightfully guess that it means "where" is part of the do-block.
13:05:36 <phadej> c_wraith: yet, we do write `intance Foo MyType where\n` and that is not a trap!
13:05:52 * ski doesn't
13:05:55 <phadej> I'm just being *consistent*
13:06:01 <c_wraith> phadej: at least there you have the word instance at the start to tell you a where is *mandatory*
13:06:08 <phadej> c_wraith: it is not
13:06:17 <phadej> instance NFData MyType
13:06:18 <phadej> is valid
13:06:21 <monochrom> So you're lying to the beginner, and it is not even one of those simplifying white lies.
13:06:36 * ski nods to phadej
13:06:53 <c_wraith> phadej: but that's fine, because it means the *exact same thing* as if you put a where at the end of the line
13:07:12 <c_wraith> phadej: so whether it's present or not, you can pretend it's there
13:07:12 <phadej> c_wraith: yes, so you can write `foo x y = f x + g y where` with an empty where block :)
13:07:23 <phadej> we just don't.
13:07:39 <phadej> where blocks can be everywhere
13:08:01 <dmwit> take it to the limit
13:08:03 <dmwit> module Main
13:08:06 <dmwit> and then stop
13:08:22 <phadej> dmwit: :)
13:08:24 <[exa]> let ghc infer the rest!
13:08:33 <[exa]> :]
13:08:46 <phadej> in fact, when the instance head is ridiculously long, I do half-indent where on the second line
13:09:02 <phadej> to separate where the mess ends and instance body begins
13:09:06 <phadej> instance
13:09:08 <phadej>     .....
13:09:10 <phadej>   where
13:09:14 <phadej>     member1 = ...
13:10:04 <phadej> every prolific enough programmer develops own style :)
13:11:20 <monochrom> So this is also a good reason to indent methods by 4 under "class/instance ... where"
13:11:51 <monochrom> because one day if you need to break out the "where" to its own line, you have room for an intermediate "  where"
13:12:02 <c_wraith> yeah, I'm a big fan of half-indent for lines that contain only a where.  It makes a nice visual divider
13:12:52 <dolio> Or just don't indent after such wheres.
13:13:00 <MarcelineVQ> gosh, no love for
13:13:02 <MarcelineVQ> foo x y
13:13:06 <MarcelineVQ>     = ...
13:13:19 <phadej> MarcelineVQ: I do that sometimes
13:13:32 <monochrom> I do that when there are guards.
13:13:34 <phadej> especially when the body is a string of . . . or $ $ $ 
13:13:38 <phadej> and guards, yeah
13:13:38 <MarcelineVQ> It's nice for signatures in flux, saves a lot of indentation changing
13:13:57 <monochrom> "foo x y" "    | x<y = ..."
13:13:58 <phadej> foo x y
13:14:01 <phadej>     | guard1
13:14:12 <phadej>     = veryMuch args
13:14:17 <phadej>     $ another stuff x y
13:14:30 <monochrom> Hrm that's an interesting take
13:15:06 <monochrom> Ling Ling indents by 40 spaces.
13:15:59 <ski> phadej : i always put `where' after `instance' on a separate line. except maybe if the whole `instance' declaration fits on a single line
13:16:43 <maerwald> phadej: I find it utterly confusing to have | = and $ on the same indentation :)
13:16:43 <ski> (and ditto for `class', of course. and `module', and ordinary `where's attaching to defining equations)
13:17:05 <phadej> maerwald: I know.
13:17:10 <phadej> module Foo (
13:17:12 <phadej>   name1,
13:17:15 <phadej>   name2,
13:17:16 <phadej> ) where
13:17:35 <phadej> you don't need any indentation there, tbh.
13:18:00 <phadej> and you can have trailing commas, very nice.
13:18:17 <phadej> maerwald: but indenting $ line there is just ugly
13:18:27 <phadej> especially if there two or three of them
13:18:33 <phadej> are*
13:18:36 <ski> trailing commas are not nice :(
13:19:03 <phadej> trailing commas only in export lists ;)
13:19:14 <phadej> because it's the only place where you can have last-line trailing comma
13:19:23 <ski>   module Foo
13:19:27 <ski>     ( name0
13:19:31 <ski>     , name1
13:19:35 <ski>     ) where
13:19:57 <phadej> what if you want to add a -- * haddock
13:20:02 <phadej> before name0
13:20:08 <phadej> uglyness begins...
13:20:16 <ski> perhaps it would have been better to have `;' as separator, in some places ..
13:21:47 <phadej> https://hackage.haskell.org/package/comonad-5.0.6/docs/src/Control.Comonad.html <- dropping the ( to the next line is ugly
13:21:52 <phadej> having it as it is now, also ugly
13:22:36 <phadej> considering how comments fit your indentation style is quite important
13:23:04 <ski> maerwald : sometimes i align `=' with `.'. in the case of `Show'-related stuff, there can also be one `$'
13:23:25 <maerwald> you guys are just into ascii-art
13:23:38 <phadej> maerwald: you caught me :(
13:23:48 * ski . o O ( the stars must align )
13:24:00 <phadej> you mean, Types ?
13:24:14 <ski> yes
13:24:35 <phadej> fwiw, many highlighter schemes are wrong, they highlight single = as an operator
13:24:40 <phadej> but it's more of "keyword"
13:25:18 <ski> it's a "syntactic operator", one could maybe say. or "operator keyword" or something, perhaps
13:25:25 <phadej> (haddock hyperlink code has same style for keywords and operators, so it's "fine")
13:25:38 <dolio> It's always fine.
13:25:45 <dolio> Unless you don't think it's fine, in which case it isn't.
13:26:15 <phadej> ski: yes. But when keywordoperators and operators are highlighted differently, then | = $ . soup has some visual clues
13:27:04 <phadej> I find it helpful when you look at the code using ~> between ->
13:27:36 <phadej> a ~> b -> f a ~> f b
13:28:05 <phadej> (better fonts would help too)
13:29:47 <ski> phadej : oic
13:31:54 <rain1> hey how can i build a haskell cabal projcet?
13:32:09 <rain1> cabal build failed i says marked as 'buildable: False'
13:36:36 <glguy> rain1: Look in the .cabal file to see what condition guards that buildable: False statement
13:36:51 <glguy> or put the .cabal file on a pastebin if you don't know what to look for
13:37:08 <rain1> ty
13:40:46 <rain1> 14 | import System.IO
13:40:47 <rain1> | ^^^^^^^^^^^^^^^^
13:40:50 <rain1> its giving me errors about this
13:41:08 <rain1> should I cabal install system.io?
13:41:32 <glguy> no
13:41:39 <glguy> What are you building?
13:49:49 <hpc> or even what's the rest of the error?
13:50:30 <sim590> I am implementing a binary search tree. More specifically, a binary space partition tree and I have it defined as `BSTree a = Empty | Leaf a | Branch (BSTree a) a (BSTree a)`, which is classic. I have implemented various search and traversal operations on the tree and those function shave the constraint (Ord a). Now, when it comes to appending an element to the tree, I need to bring the
13:50:31 <sim590> partitioning into play. That's when I thought to write a class Keyable that would return the key of an element of the tree, but most importantly, it would give me a key that is bounded by some maximum and minimum since there's a constraint on k with Bounded: https://paste.debian.net/1163538/. I thought I could encode like that the maximum and minimum of my key space when performing partitionning.
13:50:33 <sim590> But when I try my example with `MyInt` data type, I get `Couldn't match type ‘k’ with ‘Int’ ‘k’ is a rigid type variable`. This is unfortunate, since I thought I could implement the key space partitionning by getting the upper and lower bound and modifying the bounds from a levle to ther other during the search up until I would get to a Leaf where I would append an element and deduce
13:50:35 <sim590> the new upper and lower bound for that subtree. But now that my small example has an error, I'm wondering if I'm facing a wall here.
13:52:02 <glguy> sim590: Your definition of getKey allows the getKey caller to pick the return type
13:52:42 <sim590> glguy: yes. I thought that would be OK since I would have some constraints on them. I feel like there's a fundamental thing that I don't understand about the haskell type system.
13:53:11 <glguy> sim590: You very likely don't need a class here
13:53:19 <glguy> but it's good to understand why this won't work anyway
13:53:28 <glguy> getkey   :: (Bounded k, Num k) => a -> k
13:53:39 <glguy> means that the user of getKey gets to pick the choice of k and a
13:53:59 <glguy> so I could pick that to be a~MyInt and k~Word64
13:54:16 <glguy> but your instance isn't returning a Word64, so that doesn't work
13:54:55 <sim590> Is there a way to write it differently so that I get the same interface?
13:55:17 <glguy> What's the point of the class?
13:57:59 <sim590> For now I have this append function: https://paste.debian.net/1163539/. It only finds the place where a key should go and leaves the user the task to implement how the parent node of the two nodes will be by implementing the Monoid on the nodes. This is needed since I need to compute some values in the internal nodes. There are no "values" in my internal nodes other the result of the computation
13:58:00 <sim590> of data that I find in the leaves.
13:59:07 <sim590> For now the key management is left to the Monoid to sort out, but it cannot do that in a space partitionning tree because it's not aware of the level in the tree where it is.
13:59:26 <sim590> However, the monoid will be usefull to make other computations as I said before.
14:00:53 <sim590> So I wanted to implement the key space partitionning here in this method in an abstract way in order to ge the minimum and maximum bound of the key space and set the key of the internal node that is the parent of the two new leaves.
14:03:21 <sim590> I thought that having a class constraint on `a` as `Keyable` would let me get the maximum and minimum bound. Then I was to put a `setkey` function in the class definition in order to set the key of the new internal node.
14:03:38 <sim590> Then I would have: setkey (a0 <> a1).
14:03:53 <sim590> On the 5th line.
14:04:07 <sim590> in `Branch (Leaf $ min a0 a1) (a0 <> a1) (Leaf $ max a0 a1)`.
14:04:29 <glguy> Get the minimum and maximum bound of what?
14:05:33 <glguy> You want something like: class HasBounds a where toBounds :: a -> (a,a)   ?
14:08:28 <sim590> So I have a binary search tree that has data in the leaves, but where all internal nodes are determined by the leaves. I compose each leaf with its sibling to get the value in the internal node. Up until there are no keys involved, but I need them in order to make it a search binary tree and perform searches. Based from the data in the leaves I could easily get keys to sort elements, but the
14:08:29 <sim590> internal nodes can't have keys in a clear manner. So that' why I thought of a binary space partitionning tree: When appending, I would ask if the ID the of the leaf I want to add is smaller or greater than the mid of the space key. If it's less, then it goes left and if it's greater, it goes right.
14:09:12 <sim590> For a tree with two leaves, I would then have a root with the ID equal to the mid of the total space key.
14:09:14 <sim590> key space*
14:09:41 <sim590> But when I append another element and, say it goes to the right, then the subtree on the right is split in two parts.
14:09:59 <sim590> And the space on the right is the in interval [mid, MAX].
14:11:55 <sim590> If I append the 3rd node, then I have Branch (Leaf fstnode) (root with mid key) (Branch (Leaf 2nd element) (internal node with id of 3/4 of the initial [MIN,MAX] range as id) (Leaf 3rd element)
14:12:00 <sim590> Idon't know if that's clear...
14:15:06 <sim590> Say I have the keyspace [0, 2**32]. I would then have the final tree I mentioned above as: Branch (Leaf fsntnode) (internal with id = 2**16) (Branch (Leaf sndnode) (internal with id = 2**24) (Leaf thrdnode))
14:18:53 <sim590> glguy: here the class HasBounds is not very helpful. My type `a` will be a complex data type that would contain also an ID. I don't want to return the complex node type for doing arithmetics on it. All I need is the numeric key that is found inside the complex type `a`.
14:19:16 <sim590> The ID would be the key here.
14:33:51 <sim590> I guess I really need to decouple the complex type from the key of the tree. Like having: `BSTree k v` instead of `BSTree a`.
14:40:06 <hyiltiz> sim590: aren't your describing finger trees?
14:42:14 <sim590> hyiltiz: I don't think finger trees are binary? I'm really describing this: https://en.wikipedia.org/wiki/Binary_space_partitioning. I think
14:43:02 <sim590> Oh. So there's finger trees and finger search trees according to wikipedia. Two different things (maybe related?).
14:43:15 <sim590> hyiltiz: you were talking about the former or the latter?
14:43:42 <hyiltiz> https://en.m.wikipedia.org/wiki/Finger_search_tree
14:47:01 <sim590> Yeah, well I don't really see the fingers in my implementation. The fundamental issue is that my tree is build only from data that are placed at the leaves. Those leaves can have IDs without issue since the data stored that has valid candidates for that, but the internal nodes are really computed from the leaves, so it's not clear what keys I can give them. The only way I found to simplify
14:47:02 <sim590> everything is to have a fixed key space where every time I add an element, I split the space in half.
14:47:19 <sim590> Not the total space, but one of the parts of the parittion.
15:02:20 * hackage morpheus-graphql-core 0.15.1 - Morpheus GraphQL Core  https://hackage.haskell.org/package/morpheus-graphql-core-0.15.1 (nalchevanidze)
15:03:20 * hackage morpheus-graphql 0.15.1, morpheus-graphql-client 0.15.1 (nalchevanidze): https://qbin.io/dale-pdf-vwit
15:48:31 <sim590> I finally wrote this: https://paste.debian.net/1163551/ with this class: https://paste.debian.net/1163552/. May be what I'm looking for is more clear? For instance, `a` could be something containing `nodeID :: ByteString` that would be like the hash of some data. Then, with PartitionIndexable, I can dictate if the hash of the data belongs on the left or the right by mapping every hashes to an Int
15:48:32 <sim590> in the space (minBound, maxBound) and making the choice of left/right based on the position relative to the middle of the interval.
15:53:30 <sim590> There are issues in this code still. Sorry. I'm fixing them. Anyway. Besides the error, I think that we can understand the idea I'm going for.
16:23:20 * hackage lz4-frame-conduit 0.1.0.1 - Conduit implementing the official LZ4 frame streaming format  https://hackage.haskell.org/package/lz4-frame-conduit-0.1.0.1 (NiklasHambuechen)
16:32:15 <hyiltiz> See
16:32:35 <hyiltiz> May wanna give go a more explicit name
16:33:56 <natpd> is there a function that can insert an element to a list for every odd or even index?
16:34:32 <c_wraith> you mean (more or less) doubling the length of the list?
16:36:15 <natpd> that would resize the list to len + len/2
16:39:08 <sim590> hyiltiz: I'm sorry. Don't bother anymore. I'm realizing that I won't be able to use the binary space partitioning tree in the end due to the nature of the data and the properties the tree has to satisfy... Thanks anyway for taking the time!
16:41:28 <c_wraith> natpd: so...  inserting an element (before or after?) every odd or even entry?
16:42:46 <natpd> c_wraith after
16:43:30 <natpd> a function that inserts an element after every even entry
16:44:47 <c_wraith> there's certainly no existing function that does all of that.  If you're willing to use the split library, chunksOf is very nice for that purpose.
17:08:39 <Graypup_> hi! I am now having CI builds failing due to the extremely high memory usage of ghcjs, which is using 10GB during the linking stage of a somewhat large application. I assume this is probably due to some kind of code bloat, but does anyone have any pointers on how to diagnose where the bloat is coming from?
18:13:51 <arahael> Graypup_: I've heard of 16 GB being a recommended minimum requirement for ghcjs builds, believe it or not. :(
18:21:58 <lemmih> Graypup_: There's not much to do other than breaking the code down into smaller modules, using fewer constructors in your data types, and avoiding deriving unnecessary instances.
19:17:11 <Graypup_> lemmih, :( does that fix linking issues though? because that's what's hosing us
19:17:25 <Graypup_> the compile usage is ok, the link usage is over the limit
19:17:45 <c_wraith> yeah, linker memory use scales with the number of *things* it has to know about.
19:17:56 <c_wraith> which is what lemmih was addressing
19:18:41 <Graypup_> hm, and is "things" like functions simultaneously in scope or?
19:19:31 <c_wraith> It's everything exposed by modules in use - values exported, instances, etc
19:20:39 <Graypup_> hm, so if I have a bunch of internal stuff that's not used elsewhere in the program, could I e.g. not export it? and would that help?
19:21:53 <Graypup_> (I am also trying to get a bigger CI builder but that's going to take rewriting our Nix based CI to work with a new provider)
19:21:56 <c_wraith> it should help, though if it makes it into the unfoldings for inlining, that's still going to use up memory
19:25:10 <Graypup_> I (very) often wonder where my project stands as far as size, particularly in the open source world. we have 25k lines of haskell going into our GHCJS builds
19:26:27 <Graypup_> which ends up making a 43MB JS file with all that linking RAM
19:58:49 * hackage graphql-utils 0.1.0.0 - GraphQL Utils  https://hackage.haskell.org/package/graphql-utils-0.1.0.0 (Lupino)
20:01:23 <dumptruckman> blergh
20:01:37 <dumptruckman> i can't seem to find the motivate to actually make anything with haskell
20:01:47 <dumptruckman> everything i _want_ to make feels incredibly out of reach
20:05:01 <dumptruckman> anyone have some suggested resources for learning how to write practical haskell applications?
20:06:12 <jchia_1> dumptruckman: What's stopping you from writing a practical haskell application?
20:06:40 <dumptruckman> i'm not sure i really know
20:06:48 <dumptruckman> i think the tooling is definitely part of it though
20:06:49 <Graypup_> dumptruckman, maintain someone else's practical haskell application haha
20:07:14 <Graypup_> or at least that's how I figured out how to use the thing
20:07:15 <dumptruckman> Graypup_: i feel like that's going to require knowing a lot more haskell than I do
20:08:27 <Lycurgus> out of reach why?
20:08:31 <jchia_1> dumptruckman: Have you tried hls?
20:09:09 <dumptruckman> jchia_1: haskell language server?
20:09:11 <jchia_1> I use stack with vscode+hls
20:09:11 <jchia_1> yes
20:09:22 <Lycurgus> also there are a bunch of practical hs themed things
20:09:23 <Graypup_> I just jumped straight into working on the work yesod project after reading like a quarter of Learn You a Haskell for Greater Good
20:09:32 <Graypup_> hls is absolutely essential yeah
20:09:37 <dumptruckman> yeah, i use it
20:09:41 <Lycurgus> (many of them so named)
20:10:25 <dumptruckman> Lycurgus: example: i want to make a discord bot but i just can't grok how to get the discord api dependency and actually use it
20:10:36 * Lycurgus facepalms, lang server, and I thought would be new shiny
20:10:39 <MarcelineVQ> I think if you need to be told what to work on you're not going to get very far with it
20:10:57 <dumptruckman> yeah, i know
20:11:08 <dumptruckman> it has to be something you're interested in
20:11:10 <Lycurgus> dumptruckman, there's prolly already something in that direction, did you check hackage?
20:11:12 <jchia_1> dumptruckman: Do you find hls good enough? If you want to solve a problem (not being able to write practical apps) you need to know what causes it in order to attack the problem.
20:11:19 <MarcelineVQ> better yet something you need
20:11:50 <Graypup_> dumptruckman, yeah that's often difficult. I find that the documentation culture for most haskell libraries is very different from other languages, and often it is incredibly lacking in examples
20:11:59 <Lycurgus> in any case many elements for that already exist so it's basically an integration task, similar to the cases in for example
20:12:04 <Lycurgus> Practical Haskel
20:12:08 <Lycurgus> l
20:12:09 <Graypup_> so I end up reading source code and spending a lot of time on sourcegraph
20:12:46 <dumptruckman> honestly, i think part of it is i'm just suffering from programming block
20:12:55 <dumptruckman> programmer's block?
20:12:57 <dumptruckman> w/e
20:13:09 <dumptruckman> i can't seem to convince myself to write _anything_ outside of work lately
20:13:50 <Lycurgus> the capitalist workplace sucks the life out of everything
20:14:12 <Lycurgus> mostly from it's demands for emotional labor
20:16:02 <dumptruckman> i think i need more fundamental haskell knowledge but i just want to build something not read about fundamentals.
20:16:16 <dumptruckman> unlike java, it's much hard to simply "figure out"
20:16:20 <Lycurgus> an integration and excellent learning task, but nobody succeeds with hs without commitment unless they stumble on it from a favorable and usually naive background
20:16:46 <Lycurgus> hs is like java for math freaks
20:16:55 <dumptruckman> i do like math
20:16:59 <Lycurgus> (not my original observation)
20:17:03 <dumptruckman> but more so the applied side
20:17:39 <Lycurgus> and java is today's cobol
20:18:06 <dumptruckman> i'm not sure i know what that's suppose to mean
20:18:12 <dumptruckman> as in, it's popular?
20:18:21 <Lycurgus> the default biz lang
20:18:27 <dumptruckman> ah
20:18:57 <Lycurgus> only when cobol was big, biz and research was essentially all of IT
20:19:33 <dumptruckman> well, i definitely came up on imperative languages - my first foray into java was just to write a Swing application - I just figured it out by doing it
20:19:44 <dumptruckman> I feel like with Haskell I just have no idea how to start the doing part
20:19:56 <Lycurgus> you didn have prolog in school?
20:20:05 <dumptruckman> I think there was a class for that
20:20:09 <c_wraith> same way.  You just write some code.  Start anywhere.
20:20:10 <dumptruckman> I had Haskell in school though
20:20:14 <Lycurgus> most people have been exposed to at least 1 declarative lang
20:20:30 <dumptruckman> I've done react
20:20:34 <dumptruckman> which is pretty declarative
20:20:48 <dumptruckman> definitely a huge fan of declarative style
20:21:06 <Lycurgus> yeah 'everything' today has some impact from fp
20:21:09 <dumptruckman> i wrote a message broker for my work in python and set up a declarative api for adding message workers
20:21:31 <dumptruckman> and tried to make a strong argument for why declarative is the way to go for it
20:21:39 <Lycurgus> react/redux was always gonna because state
20:21:53 <dumptruckman> sadly one of my 2 other team mates had some very very strange views on programming and what is readable and such
20:22:06 <Lycurgus> see, emotional labor
20:22:23 <Lycurgus> you should just be able to present objective case
20:22:37 <dumptruckman> it got pretty tense and so i ended up having a talk with him
20:22:54 <dumptruckman> and he described my code as like "library code"
20:23:07 <dumptruckman> which i took as a pretty strong compliment but I guess for him that is not a compliment
20:24:54 <MarcelineVQ> I would have taken that a compliment for sure
20:24:55 <dumptruckman> We talked about some of the problems I was having with my coworkers coding styles and I ended up calling out the senior dev's use of duplicate code instead of using a function or something and he got very up in arms heh
20:25:05 <MarcelineVQ> "wow it's that good?"
20:25:10 <dumptruckman> right??
20:25:51 <dumptruckman> i mean i very intentionally strive to write clean & maintainable code - reading books about this and such
20:26:32 <dumptruckman> very tempted to buy that new algebra-driven design book
20:27:19 <MarcelineVQ> sandy's info is pretty up to date stuff, if my book budget was topped off I'd get that myself
20:28:21 <dumptruckman> this article (https://www.rea-group.com/blog/the-abject-failure-of-weak-typing/) someone linked here the other day really blew my mind in some ways
20:28:34 <dumptruckman> particularly the part about naming
20:29:02 <dumptruckman> not sure i entirely agree with all the points but it's very clear to see that well named types are significantly better than well named functions and variables
20:30:39 <MarcelineVQ> naming is by far the hardest part about coding, the other hardest part is the names
20:31:47 <MarcelineVQ> I just pretend no one's ever going to see them so I can sleep at night
20:32:28 <nitrix> I like that article too, but I don't think it should be about types. If you take a language like Prolog, you get to encode the same kind of logical propositions where the types wouldn't benefit you in any way.
20:33:12 <nitrix> I think it's more related to logic and constraints. Type systems are very specific solvers after all.
20:33:48 <dumptruckman> yeah, the arguments about exceptions are decent but the alternatives are not super great
20:34:05 <dumptruckman> and there's *still* bound to be unexpected failure
20:34:24 <dolio> There are typed versions of prolog, though.
20:36:07 <nitrix> Mercury seems to be leading that front. My understanding is that they are reaping the benefits of annotating the determinism of the predicates, more so than from the types.
20:36:13 <dolio> And you could translate at least some of the examples into prolog vs. typed prolog.
20:41:27 * ski . o O ( "TYPICAL for Annotated Prolog" <https://www.fernuni-hagen.de/wbs/typical-0.6/tap_examples/Demo/index.html> )
20:42:44 <ski> nitrix : it ties into declaration of algebraic data types, though, to check exhaustiveness of cases (for `det' and `multi' determinisms)
20:45:22 <nitrix> ski, I'll have a look (I don't think I specifically looked at TYPICAL before). You think it has a good chance to make me change my mind on the benefit of having a well-typed Prolog?
20:45:51 <nitrix> ski, I'm asking because Prolog (and other solvers) have always been the basis for a lot of my arguments against type systems.
20:46:02 <ski> i dunno. it was a long time ago i used it, and only a little
20:46:35 <nitrix> Understood. It reads well so far.
20:46:36 <ski> if you want to see a typed logic programming language, i'd suggest Mercury. but perhaps you were asking specifically about Prolog ?
20:47:13 <nitrix> Mercury I'm quite familiar with :)
20:47:26 <ski> ah, that's good, then :)
20:48:17 <ski> perhaps you could briefly summarize what those arguments were about ?
20:51:20 <nitrix> The article by dumptruckman emphasises the problems with weakly typed languages and that it's preferable to lift these concerns to the type-level, because then the type system places constraints in place to ensure you approach and work these things in a controlled manner.
20:55:00 <nitrix> It's hard to disagree with that, except that my recent experiences are telling me that isn't really a benefit of "types" , per say. Rather, what you want is a much more generic solver than just a type system limited to types.
20:57:50 <dumptruckman> Perhaps my lack of every touching a logic programming language has me wondering what the heck that even means
20:58:02 <dumptruckman> s/every/ever
20:58:12 <nitrix> Once you tasted arbitrary predicates, arbitrary constraints for whatever logic or model you desire, types just seems like optimization concern and don't help you much.
20:59:01 <dumptruckman> Can you given an example?
20:59:36 <ski> hm, years ago, i remember i was wondering about some version of Prolog where one could declare something along the lines of `append(T,[    ],Ys,   Ys ) :- list(T,Ys). append(T,[X|Xs],Ys,[X|Zs]) :- call(T,X),append(T,Xs,Ys,Zs).' ..
20:59:51 <nitrix> dumptruckman, Well, Prolog was my example.
21:00:34 <ski> .. except that these `list(T,Ys)' and `call(T,X)' should happen only at compile-time (partially deduced away), maybe after explicit annotation as being static
21:01:09 <ski> but then one could also imagine things like `same_length(Xs,Ys)' also happening at compile-time .. something that's harder to express with types
21:02:18 <dolio> It doesn't seem like logic programming has anything to do with it to me.
21:02:21 <nitrix> ski, The equivalent of constraint propagation that you get with a solver is really painful with types. It immediately gets you into dependent type territory. 
21:03:02 <nitrix> And the state of research with dependent types are... well, they're good, but it's also very complex with a lot of open questions.
21:04:40 <nitrix> I think Haskell has a few base cases, like Nat and stuff covered.
21:07:45 <nitrix> You get progressively more complex type systems and languages to model what is essentially logic. Working with a logic programming language right off saves you a lot of headaches.
21:08:18 <ski> i'm not following your point
21:08:55 <nitrix> Types become moot when you're concerned with logic.
21:09:16 <dolio> Logic is a special case of type theory.
21:09:26 <nitrix> The other way around.
21:09:28 <dolio> Wrong.
21:10:01 <nitrix> Type theory works on rules and facts, constraints and solving.
21:10:10 <nitrix> That's the discourse of logic.
21:11:45 <nitrix> dolio, What's a type class if not a constraint? How about type inference, is that not unification?
21:12:42 <nitrix> Also, why restrict yourself to types? Immediately you can see how this can be more general.
21:12:44 <dumptruckman> at the same time
21:12:58 <dumptruckman> it's hard to think about the world without types
21:13:36 <nitrix> dumptruckman, I don't know. An int16, int32 is really just an integer with a constraint on the bounds.
21:13:52 <dumptruckman> that's not quite the distinction i think matters
21:14:14 <dumptruckman> you can't just operates on "things"
21:14:39 <dumptruckman> you must have an idea as to what the things are so that you can reason about them
21:14:59 <dumptruckman> i would love to hear of a specific example that contradicts this
21:15:05 <nitrix> dumptruckman, Yes and no. As a developer, you want to work with an integer without worrying about anything else. Model the problem with your constraints. Then as a compiler implementor, you want to make use of the constraints you're given to pick the right integer size that'll match the bounds.
21:15:28 <dumptruckman> i'm sorry, you want to work with a what?
21:15:33 <dolio> Formal logic isn't even about unificatiaon, so I'm not sure how that enters into it.
21:15:38 <dumptruckman> a type of number?
21:15:46 <nitrix> Having explicit types that say int16 or int32 is a leaky abstraction, sort of.
21:15:46 <dolio> It seems like you're conflating a lot of different things.
21:16:45 <dumptruckman> the constraints i think you are making is that your "thing" is a whole number between -inf and +inf
21:17:10 <dolio> There are even prolog-like languages (sort of) that are based on type theory instead of logic.
21:17:11 <nitrix> Doesn't first-order logic has a resolution rule?
21:17:12 <dumptruckman> and really that constraint is the definition of an integer
21:17:13 <dumptruckman> which is a type
21:17:23 <dolio> Like twelf.
21:17:55 <dumptruckman> but as a developer, you know you cannot even test that constraint unless what you're working with is a number in the first place
21:17:57 <dumptruckman> yet another type
21:18:04 <dumptruckman> (of "thing")
21:19:09 <dumptruckman> i really am starting to believe it is not possible to reason about anything at all without understand something about that thing
21:19:10 <dolio> Where the computational part is a solver for type theoretic judgments instead of judgments for valid propositional formulas.
21:19:33 <dumptruckman> understanding*
21:21:51 <dumptruckman> i guess that's kind of a tautology
21:21:53 <nitrix> dumptruckman, "and really that constraint is the definition of an integer". Thank you :)
21:22:19 <nitrix> That sadly just confirms my position.
21:22:21 <dumptruckman> kind of just another way to say type = constraint
21:22:50 <dumptruckman> but again, you can't think about things without assigning types
21:22:54 <nitrix> Of course. But you could constraint many more things, not just types.
21:23:10 <dumptruckman> example?
21:23:27 <nitrix> Logic is more general. I'll argue against everyone saying types are the secret sauce to "safe/correct code".
21:23:46 <nitrix> But not here.
21:23:57 <ski> dumptruckman : if we have no required basic operations on a type of things, we could decide to represent them by zero bits
21:24:03 <nitrix> This has already devolved too much.
21:24:57 <dumptruckman> I mean
21:25:29 <ski> nitrix : are you possibly arguing for combining aspects of functional programming (proof normalization) with aspects of logic programming (proof search) ?
21:26:06 <dumptruckman> i guess when you break logical problem down into symbols you really do take types out of the equation
21:27:20 <dumptruckman> well... sort of
21:28:07 <dumptruckman> for all x, P(x) <->Q(x)
21:28:28 <dumptruckman> no types represented syntatically
21:28:44 <dumptruckman> but x is _something_
21:28:54 <dumptruckman> and you probably know what that thing is
21:29:13 <dumptruckman> otherwise you wouldn't be making logical propositions about it
21:32:12 <ski> well, there's still a sort of "metatype"
21:32:34 <dumptruckman> eh?
21:33:18 <ski> if this is a schematic formula (rather than `P' and `Q' being predicate symbols), then `P' and `Q' each represents a "formula with a hole"
21:33:54 <dumptruckman> i don't follow
21:34:05 <dumptruckman> do these symbols work here? A→B; B∴A
21:34:33 <ski> negation, conjunction, disjunction, implication, biimplication, all take formulae into formulae. but the quantifiers can be viewed as taking a formula-with-a-hole into a formula
21:34:36 <ski> yes
21:35:08 <ski> (already Frege talks about this, btw ..)
21:35:11 <dumptruckman> what is this "hole"?
21:35:36 <ski> from the POV of the meta system, we could say something like
21:35:46 <ski>   neg : form -> form
21:36:04 <ski>   conj,disj,impl,iff : form -> (form -> form)
21:36:20 <ski>   all,some : (term -> form) -> form
21:36:43 <nitrix> Negation, conjunction, so on, are all logic. (NOT x, x AND y, ...)
21:37:12 <dumptruckman> indeed, no types involved
21:37:39 <dumptruckman> but when does a problem domain not involve types i guess is what i want to know
21:37:59 <dumptruckman> i could say A→B; B∴A and of course it's true and can be proven and what not
21:38:05 <ski> then one'd express inference rules relating judgements involving these formulae and terms, e.g. to impose types on the terms
21:39:29 <dumptruckman> i don't follow
21:39:31 <ski> in Haskell one could try `data Form = Neg Form | Conj Form Form | ... | All (Term -> Form) | ...' .. however the problem here is that one cannot pattern-match on functions
21:40:25 <dumptruckman> but with A→B; B∴A, it really has no use until you give values to A and B
21:41:22 <ski> well, if you're just talking about propositional logic, then there's only one relevant type, the type of propositions
21:41:26 <dumptruckman> anyway, i'm gonna go to bed now
21:41:31 * ski nods
21:42:57 <nitrix> ski, Doesn't that seem incredibly backwards?
21:43:07 <ski> which ?
21:45:26 <nitrix> ski, http://homepages.inf.ed.ac.uk/wadler/papers/propositions-as-types/propositions-as-types.pdf
21:45:38 <nitrix> ski, Propositions AS types, not types of propositions.
21:47:12 <ski> well, can't you have both ?
21:48:16 <ski> (still not sure which of those you'd suggest was incredibly backwards)
21:51:24 <nitrix> The types are. In the article that was linked earlier, encouraging solving their problem with a strongly typed language instead of a weakly typed one, my stance was that it's not having a type system that helps, it's making propositions and modeling the constraints that does.
21:52:50 <nitrix> Logic would get you further, so much further that tackling a type system on top of it would be of no benefit (other than the solver performing well on a computer).
21:55:07 <nitrix> My view is that type systems are a specialization of logic just for hardware. And they get incredibly more complex to model the things logic already can do, while the hardware is exactly the same.
21:56:30 <nitrix> I'm saying this with the most respect for people working in that field. I've benefited a lot from FP and the various papers throughout the years. It's just a late realisation of mine.
21:57:50 <ski> which sense of types ? types of propositions ? or propositions as types ?
21:58:22 <nitrix> C'mon ski.
22:00:21 <dolio> Propositions as types is a method of encoding propositional statements into types in type theory. It's not the only way to do things, and doesn't necessarily even mean there isn't a type of propositions.
22:02:11 <ski> (.. anyway, i'm interested in better understanding your viewpoint, what you're actually claiming and suggesting. but perhaps it's not the most efficient way to do this, when i'm quite tired)
22:05:21 <nitrix> Yeah. Somewhen and somewhere else ideally.
