00:00:13 <Guest26> this is some serious code
00:00:19 * hackage tasty-wai 0.1.1.1 - Test 'wai' endpoints via Test.Tasty  https://hackage.haskell.org/package/tasty-wai-0.1.1.1 (GeorgeWilson)
00:00:19 <fraktor> Oh wait, you didn't use the Elm architecture?
00:01:16 <Guest26> dsal: i dont see where it does the visualisation 
00:01:20 * MarcelineVQ plays a violin for the readme.md
00:01:45 <fraktor> Guest26: It's not for the same kind of thing; I'm just curious about what dsal wrote lol.
00:01:56 <Guest26> ok
00:02:07 <dsal> MarcelineVQ: heh.  nobody ever uses my programs no matter how well I document them.
00:02:09 <Guest26> ah, it was about websockets
00:02:47 <dsal> This is really good software lots of people should use, though.
00:02:50 <Guest26> dsal: what is it for this gopro interface?
00:02:55 <fraktor> I want to go back to 1980 and try to explain this: `addToast toast = Toasty.addToast toastConfig ToastyMsg toast`
00:03:06 * MarcelineVQ plays Agnus Dei for the code commentary :>
00:03:39 <dsal> Guest26: it's a bunch of tools for managing data in gopro's cloud.
00:03:52 <jdgr> Okay, was going over Haskell with my girlfriend. She's "bored" so I put studying Haskell on pause and introduced her to Scratch.
00:03:59 <Guest26> extractGPMDStream filename stream = readCmd "ffmpeg" ["-y", "-i", filename, "-loglevel", "-8", "-codec", "copy", "-map", "0:" <> show stream, "-f", "rawvideo", "-"] id
00:04:02 <Guest26> horrible 
00:04:32 <jdgr> Probably a better introduction to programming because it's visual and you can immediately do interesting things.
00:04:48 <Guest26> sounds like you need a dog
00:05:29 <Guest26> https://ocharles.org.uk/img/2013-12-19-websockets.png
00:05:50 <jdgr> We need a visual IDE for Haskell that makes the language easy and fun for beginners like Scratch is
00:05:52 <dsal> Guest26: yet I've pushed a TB of video through it.  I'll take a patch, but I didn't find an mpeg library that could solve the problem that line did.
00:06:20 <dsal> It was enough that I had to write a parser for GoPro's metadata stream because all of their tools were unusable even as FFI.
00:06:57 <Guest26> oh right, its got all those funny arguments because its a command line tool
00:07:05 <fraktor> I still need to actually write a real project in Elm. Maybe I'll update my Rust/Vue project to do that
00:07:18 <Guest26> hmm, maybe thats the best way to do this plotting too... just compile something to exe
00:07:33 <dsal> This was my "I should try out elm" project.  It works.  The WS was the worst pain (which was surprising).
00:07:36 <Guest26> i can easily read the .png in by refreshing the page
00:07:56 <fraktor> Then again, I'm not really good at Haskell either. I still don't understand how to use Monad Transformers
00:08:06 <Guest26> each time the simulation produces new data i can get the thing that watches the data dir to overwrite the plot image
00:08:18 <fraktor> That's probably the easiest way
00:08:25 <fraktor> I would not recommend websockets if you don't want to dive deep
00:08:26 <Guest26> ok! that sounds like a plan. so how do i plot the timeseries data?
00:08:30 <dsal> I just write code to solve my problems.
00:08:42 <fraktor> Guest26: I don't really know. You'd need to find a Haskell library for that.
00:08:48 <jdgr> That's the whole point of programming 
00:08:52 <Guest26> ok brb 
00:08:53 <jdgr> Making your life easier
00:08:58 <fraktor> Not true! Sometimes it's for fun
00:09:06 <jdgr> That too
00:09:17 <Guest26> i soon find; https://hackage.haskell.org/package/plots
00:09:40 <fraktor> Great!
00:09:46 <dsal> This GoPro thing is... unofficial (had to reverse engineer the API and violate all the terms of service), but the service isn't usable without it.
00:10:01 <dsal> Like, I would be surprised if anyone uses their stuff at all.
00:10:04 <fraktor> I've definitely used APIs in a creative way before.
00:10:50 <dsal> They don't have a published API.  Their web UI is *impressively* bad, and doesn't even do a lot of the things you'd want done.
00:11:22 <Guest26> ah but this doesnt seem to write to a .png
00:11:27 <dsal> But most importantly, when they decide they don't want to store my TB of data for $5/mo anymore, I have a commandline that will ship it all off to S3 just about instantly.
00:13:55 <dsal> http://dustin.sallings.org/2020/04/29/gopro-plus.html  <-- I wrote about it there.  I guess I could document things since I think I've got it as stable as I want now, just in case someone somewhere has a gopro.
00:14:23 <Guest26> horay! human words
00:14:25 <dsal> I've worked around a crapload of bugs on their side as well.  I've got this cool thing where I can do bulk updates of metadata on their end using SQL queries.
00:15:57 <dsal> e.g., there's some way I can upload stuff where they just can't figure out what camera it came from, but like, I can read it directly out of the EXIF or GPMD streams, so I write a SQL query that returns the metadata that I know for all of the rows where they don't know and it translates that into mutation API calls on their end.  Fun stuff.
00:16:52 <Guest26> i guess its more of a home use tool than a lib for hackage?
00:17:22 <dsal> If you just want to use the APIs, they're here:  http://hackage.haskell.org/package/gopro-plus
00:17:27 <dsal> and gpmf and stuff.
00:17:33 <dsal> (linked in that article)
00:17:40 <Guest26> oh right, thats far less impressive 
00:17:59 <dsal> Heh, that stuff was hard to reverse engineer and write.
00:18:05 <Guest26> oh - you wrote those aswell
00:18:17 <Guest26> completely impressive 
00:18:27 <Guest26> i cant even do a line plot
00:18:33 <Guest26> :-?
00:18:34 <dsal> Like, this is the *simple* case of uploading media:  https://github.com/dustin/gopro-plus/wiki/Upload
00:19:14 <Guest26> now i want a go-pro, just to use this library....
00:19:35 <dsal> But you can do server-side concatenation of multiple files (e.g., when the camera splits, or you just took multiple videos and want them to be a single one) by defining a single multi-part video across a set of files, each of which is split into 6MB chunks and uploaded.
00:20:09 <dsal> The upload is completely resumable as well (since my connectivity goes out).  I was uploading earlier, and then stopped for some reason (^C) and then just told it to keep uploading whatever it was doing before.
00:20:10 <Guest26> but i think before too long it would become philip k dicks second variety 
00:20:29 <Guest26> do we have an interface to project gutenburg?
00:20:40 <dsal> What would that do?
00:22:45 <Guest26> idk, something like search and download? or maybe an interface to have it for use as a text corpus eg. for machine learning 
00:22:52 <Guest26> it has entries like this;
00:22:53 <Guest26> https://www.gutenberg.org/files/32032/32032-h/32032-h.htm
00:27:46 <dsal> I don't know what APIs are available, or how structured that might be.  Making APIs for stuff like that isn't typically that hard if you have some idea what you're trying to accomplish.
00:28:47 <dsal> Oh man, I just got the notification about sprinkler schedule for the day.  I guess I should kill that software since I've removed all the hardware.  :(
00:31:15 <fraktor> Does anyone have good resources on Monad Transformers? I really don't understand them that well
00:32:40 <dsal> There's really not that much.  Mostly, you just have IO and then you wrap a ReaderT around it so you can have an implicit variable passed around.  Sometimes you throw in a MonadLogger or whatever and you `lift` to the next transformer up the stack.
00:32:56 <c_wraith> :t lift
00:32:58 <lambdabot> (MonadTrans t, Monad m) => m a -> t m a
00:33:04 <c_wraith> that's really all you need to know :)
00:33:12 <dsal> The only thing that's kind of hard is starting all the runXT things and then lift.
00:33:20 <dsal> And usually you probably just need liftIO  :)
00:33:46 <c_wraith> honestly, I internalized monad transformers before monads.  They don't involve nearly as complex of topics.
00:33:50 <fraktor> ReaderT seems super useful but it's hard to understand
00:34:42 <dsal> It's hard to understand because it sounds dumb.  In practice, it just means you have a variable that's implicit.
00:35:44 <dsal> fraktor: This is a "I went too hard after a bunch of time" example, but: https://github.com/dustin/gopro/blob/master/src/GoPro/Commands.hs#L46-L61
00:37:52 <dsal> Anything in GoPro knows its API credentials, DB location, argv, etc...  So the aforementioned `fixup` command just has to do this:  https://github.com/dustin/gopro/blob/master/src/GoPro/Commands/Fixup.hs#L19
00:39:01 <dsal> Yeah, I should really have found something easier... this also pulls the whole environment to rewrap it in a database environment.   Related:  monads don't always compose well.
00:42:46 <dsal> fraktor: Just try throwing a ReaderT at something where you're passing a bunch of junk around and see if you can make things easier.
00:43:05 * dsal needs to stop trying to be awake
00:45:41 <fraktor> dsal: honestly same.  I've had too much wine and too little sleep to learn rn
00:46:17 <MarcelineVQ> while drinking wine is exactly the time to be a wizard
02:04:18 * hackage bugsnag-hs 0.2.0.1 - A Bugsnag client for Haskell.  https://hackage.haskell.org/package/bugsnag-hs-0.2.0.1 (JasperWoudenberg)
02:57:14 <dwts> hello all, I've just started playing with Haskell and following a Course. (Learning Haskell Programming from Lynda.com if that matters). I'm adding hspec in my test-suite section of my project.cabal file but when I'm running `stack test` I get an error for importing Hspec and the hspec entry in my project.cabal file is no longer there. Any ideas where I should be looking at to resolve this issue?
02:59:27 <dwts> basically the error states: "Could not find module 'Test.Hspec'
03:18:47 <tomjaguarpaw> Perhaps post your cabal file at https://paste.tomsmeding.com/
03:30:48 <random> hey guys
03:30:54 <random> does anyone know if you can derive Generic via some field
03:31:23 <random> I have a data type `data Something a = Something { blabla :: a, blablabla :: SomethingElse }`
03:31:36 <random> I want to use generic-lens on `Something a` as if I was using it on a
03:31:38 <random> is that possible?
03:43:24 <dwts> tomjaguarpaw: Hi, this is how the .cabal file looks like before running `stack test`: https://paste.tomsmeding.com/cnrUyvSC and this is how it looks after running stack test:  https://paste.tomsmeding.com/hT7eCgTj
03:54:21 <tomjaguarpaw> This file has been generated from package.yaml by hpack version 0.34.2.
03:54:32 <dwts> yes
03:54:39 <tomjaguarpaw> Did you put the hspec dependency in stack.yaml?
03:54:50 <dwts> oh...
04:01:44 <dwts> hmmm, nope something doesn't look right
04:01:49 * hackage kubernetes-client-core 0.3.0.0 - Auto-generated kubernetes-client-core API Client  https://hackage.haskell.org/package/kubernetes-client-core-0.3.0.0 (axeman)
04:01:56 <dwts> I repeated the whole process and I still end up wit hthe same files
04:02:43 <dwts> is it normal for project.cabal to be "^refreshed" to its initial state after running `stack test` ?
04:02:49 * hackage kubernetes-client 0.3.0.0 - Client library for Kubernetes  https://hackage.haskell.org/package/kubernetes-client-0.3.0.0 (axeman)
04:42:03 <tomjaguarpaw> I expect so. I'm not a stack user but I imagine that you are not supposed to write project.cabal directly. Instead you are supposed to edit stack.yaml and stack generates project.cabal for you.
04:50:49 * hackage arch-hs 0.1.0.0 - A program generating PKGBUILD for hackage packages.  https://hackage.haskell.org/package/arch-hs-0.1.0.0 (berberman)
05:14:00 <maerwald> dwts: that happens when you use package.yaml
05:14:05 <maerwald> otherwise not
05:14:49 * hackage bytestring 0.10.9.0 - Fast, compact, strict and lazy byte strings with a list interface  https://hackage.haskell.org/package/bytestring-0.10.9.0 (Bodigrim)
06:02:56 <tomjaguarpaw> maerwald: Thanks again for ghcup. I have been using it frequently!
06:03:10 <maerwald> o/
06:07:18 * hackage hablog 0.7.1 - A blog system  https://hackage.haskell.org/package/hablog-0.7.1 (gilmi)
06:41:39 <tomjaguarpaw> Is there some option I can set to convince cabal to minimize rebuilds?
06:47:38 <whataday> what's the different meaning between Reader and Cont?
06:48:16 <whataday> or effects?
06:49:02 <whataday> both related to callbacks?
06:49:27 <tomjaguarpaw> What do you mean?  Reader and Cont are completely different.
06:50:16 <whataday> I mean in function form, not the type structure form
06:50:17 <Cale> whataday: Reader just gives you access to a single immutable value. Reader r a is essentially the same thing as r -> a
06:50:57 <Cale> whataday: Cont on the other hand abstracts over the continuation of the computation, and lets you do stuff like callCC
06:51:22 <Cale> Cont r a is effectively (a -> r) -> r
06:52:02 <whataday> basically Reader give a access to a single value, and Cont can access an unary function?
06:52:38 <whataday> they're both related to function callback, right?
06:53:32 <whataday> Reader is simple, like we do function compose
06:54:10 <whataday> what's the abstract meaning of Cont?
06:54:44 <tomjaguarpaw> Hmm, not really
06:54:49 <tomjaguarpaw> Reader r a is a -> r
06:55:02 <tomjaguarpaw> *Reader r a is r -> a
06:55:04 <whataday> monad is a->
06:55:12 <tomjaguarpaw> Cont r a is (a -> r) -> r
06:55:18 <whataday> cont monad is (a->r)->
06:55:35 <tomjaguarpaw> No, cont monad is (_ -> r) -> r
06:55:43 <tomjaguarpaw> Reader monad is r -> _
06:55:56 <tomjaguarpaw> The parameter _ is in a completely different place in each case. They are nothing like each other.
06:56:21 <whataday> but monad has kind *->*?
06:56:33 <whataday> r->_ kind is?
06:57:03 <whataday> and _ is a magic stuff just in ghci?
06:57:44 <tomjaguarpaw> "_" is just the syntax I'm using to indicate the type parameter
06:58:14 <tomjaguarpaw> Reader r a is r -> a so it is "an a that has access to an r"
06:58:18 <whataday> I'm confused
06:58:19 <tomjaguarpaw> r
06:58:31 <tomjaguarpaw> Cont r a is (a -> r) -> r so it is not "an a" in any sense
07:00:18 <whataday> what's the meaning when concat Cont?
07:00:29 <whataday> I mean use >>= to bind Cont
07:00:57 <whataday> f . g = \x -> f (g x)
07:01:37 <whataday> function composing I understand
07:01:47 <whataday> what's about Cont?
07:02:53 <Cale> Well, let's look at the type first of all
07:03:04 <Cale> Cont r a -> (a -> Cont r b) -> Cont r b
07:03:40 <Cale> So that's like ((a -> r) -> r) -> (a -> ((b -> r) -> r)) -> ((b -> r) -> r)
07:04:19 <Cale> It's a bit of a puzzle figuring out how to put these pieces together, but there's not all that many ways to do it
07:04:25 <whataday> construct a new Cont, and the value is from the second parameter
07:05:43 <Cale> It's sort of a funny thing, Cont r a is like a thing which can answer r-valued questions that are presumably about a value of type a. However there might not actually be a value of type a for which the answers it gives are the right ones.
07:05:45 <whataday> use function a-> Cont r b to construct a new Cont with a from Cont r a?
07:06:33 <Cale> But yeah, the general way of things is that x >>= f is going to "run x" (whatever that means) and then apply f to its result to figure out what to run after that
07:07:35 <Cale> In the case of Cont specifically, it can be a bit tricky to think through what's going on, though we can have a machine do it for us if we like:
07:07:41 <Cale> @djinn ((a -> r) -> r) -> (a -> ((b -> r) -> r)) -> ((b -> r) -> r)
07:07:41 <lambdabot> f a b c = a (\ d -> b d c)
07:09:31 <Cale> Actually, let me rephrase this a bit so that it makes more sense...
07:10:02 <whataday> we give an unary function to Cont r a to extract a, then pass a to a-> Cont r b to construct Cont r b?
07:10:17 <Cale> Yeah, d :: a here
07:11:04 <Cale> So it's like we're making a thing which can answer questions (which djinn called c) about a value of type b
07:12:08 <Cale> and we do it by asking the Cont r a the question "if we applied this function of type (a -> Cont r b) to your value of type a, and then asked the resulting Cont r b our question, what would its answer be?"
07:14:29 <whataday> wait a sec, we extract Cont r a by passing (a->r), and a is passing to a-> Cont r b too
07:14:38 <Cale> newtype QuestionBox r a = Box { askTheBox :: (a -> r) -> r }
07:15:33 <Cale> x >>= f = Box (\question -> askTheBox x (\a -> askTheBox (f a) question))
07:15:52 <whataday> QuestionBlx r a = Box (a-> r) -> r
07:16:22 <whataday> askTheBox QuestionBox r a :: (a->r)->r
07:16:55 <Cale> askTheBox's full type here would be askTheBox :: QuestionBox r a -> (a -> r) -> r
07:17:03 <whataday> askTheBox and Box are isomorphic
07:17:26 <Cale> No, but they're isomorphisms in opposite directions between QuestionBox r a and (a -> r) -> r
07:17:52 <whataday> oh right
07:17:58 <Cale> Box :: ((a -> r) -> r) -> QuestionBox r a
07:18:10 <Cale> askTheBox :: QuestionBox r a -> ((a -> r) -> r)
07:18:30 <whataday> Box (a->r) ->r :: QuestionBox r a
07:18:58 <Cale> Or it would be more correct to say that when f :: (a -> r) -> r, then Box f :: QuestionBox r a
07:19:09 <whataday> I don't understand why haskell always wrap them?
07:19:15 <Cale> wrap what?
07:19:24 <whataday> the type the value
07:19:29 <Cale> hm?
07:19:46 <whataday> Box (a->r)->r
07:20:05 <Cale> That's mixing up things at the term and type level
07:20:16 <Cale> Box is a term, it lives on the left side of the ::
07:20:17 <whataday> why not just use function to express
07:20:22 <Cale> (a -> r) -> r is a type
07:20:28 <Cale> it lives on the right side of the ::
07:21:30 <Cale> As for why we don't just work with functions here
07:21:39 <Cale> Well, it's a few different reasons
07:21:56 <Cale> One is that we're trying to produce an abstraction, functions are just our implementation mechanism
07:22:10 <whataday> for Reader, a->r is a type, why we use Reader r a to express it?
07:22:14 <Cale> Eventually, we'll have enough pieces that perhaps we won't need to use Box explicitly so much
07:22:24 <Cale> Similarly with Reader
07:22:45 <Cale> Secondly, we can't have more than one instance of Monad for functions
07:22:57 <Cale> and the Reader-like instance is already there
07:23:30 <Cale> (and the Cont-like one wouldn't really work, since we can't isolate the appropriate type parameter in a points-free way)
07:24:21 <Cale> In order to have a monad, we need a type level function M such that our computations have types that look like M a
07:24:38 <whataday> not all languages support higher-kinded polymorphism, here we use Reader r a to express is not available in other languages
07:24:40 <Cale> So Cont r does that for us here
07:24:59 <Cale> Or Reader r
07:25:11 <Cale> instance Monad (Reader r) where ...
07:25:21 <Cale> It turns out we *can* write:
07:25:28 <Cale> instance Monad ((->) r) where ...
07:25:37 <Cale> partially-applying the function arrow
07:26:10 <whataday> r-> is the monad for Reader
07:26:12 <Cale> But (1) that's a little sneaky and might even be considered a little too surprising
07:26:17 <Cale> and (2) it doesn't work for Cont
07:26:36 <whataday> (a->r)-> ?
07:26:45 <whataday> can't be monad for cont?
07:26:52 <Cale> Yeah, we need an M for which M a = (a -> r) -> r
07:27:05 <Cale> and we can't get that by partial application of anything which already exists
07:28:19 <whataday> some people are familiar with continuation or cps in other languages, but in haskell, cont monad is hard to understand by type signature
07:28:37 <whataday> other I mean dynamic languages
07:29:29 <Cale> It's not really any worse than understanding continuations in other dynamic languages, I think. It's just that what you need to understand has been made explicit by the types
07:30:19 <Cale> Continuations are a little bit twisty and confusing in either case, but without types, you *really* have to know what you're doing
07:31:18 <whataday> just like closure in dynamic languages, easy to understand and use, but in haskell I don't understand how to
07:31:38 <Cale> Closures are just an implementation mechanism for functions
07:31:58 <whataday> in dynamic languages we can change variables in an environment, but haskell can't change
07:32:05 <Cale> In Haskell, we usually just say "function" and not "closure" unless we're really talking about the low-level implementation
07:32:50 <Cale> You can define things which capture mutable variables from their scope of definition in Haskell if you like
07:32:53 <solonarv> you absolutely can have mutable references in Haskell, and you can have functions that close over them
07:33:00 <solonarv> heh, ninja'd
07:33:17 <Cale> Make a new IORef and return a function which produces an action that writes to it, and separately an action which reads from it
07:33:45 <whataday> but IORef is not suggested
07:33:49 <Cale> ?
07:34:04 <Cale> IORefs definitely have their place
07:34:45 <Cale> They might not be the first thing you learn about, since if you're an imperative programmer, the first thing to learn is how not to be wasteful with mutable variables :)
07:34:51 <whataday> I thought people always said IO is evil
07:35:08 <Cale> It's evil in some ways, but it's also the entire point of running a program
07:35:59 <whataday> so let's save the princess a from evil IO a
07:36:36 <whataday> just kidding
07:36:42 <dwts> maerwald: hey, thanks. I used `stack new [project_name] to generate my project. This also creates a pagkage.yml. It is possible that when the course was recorded that wasn't the case or that pacakge.yml didn't cause issues
07:36:47 <Cale> If you're not, e.g. doing communication between threads, or any actual I/O, then using IORef might be ill-advised.
07:38:28 <whataday> when we need to use the twisted Cont?
07:38:42 <whataday> for which scene?
07:38:47 <dwts> maerwald: after removing package.yml I got better results
07:39:57 <Cale> whataday: Mostly we don't, but there are some cases where you run into a lot of functions which allocate/deallocate resources, and take a function which says what to do with the resource while it's available
07:40:27 <Cale> Mostly these functions have names like withSomething
07:41:07 <whataday> but that's the coroutine scene
07:41:15 <Cale> Cont and ContT can straighten out the situation where you're nesting a lot of such functions to allocate (and later deallocate) many resources
07:41:28 <Cale> and let you write code that looks like it just obtains things directly
07:41:46 <Cale> So instead of:
07:42:03 <Cale> withResource1 (\r1 -> withResource2 (\r2 -> ...))
07:42:07 <Cale> You're writing something like
07:42:22 <Cale> do r1 <- getResource1; r2 <- getResource2; ...
07:43:10 <Cale> (typically, getResource1 = ContT withResource1)
07:44:41 <Cale> Sometimes, even if you're not going to build up the whole abstraction of using Cont or ContT, it can be helpful to have something like sequence for Cont to obtain a whole list of resources at once
07:44:47 <Cale> :t runCont . sequence . map cont
07:44:48 <lambdabot> [(a -> r) -> r] -> ([a] -> r) -> r
07:45:25 <Cale> This thing takes a list of resource-acquiring functions, and then produces a function which acquires a list of the resources all at once
07:46:05 <whataday> a concret example?
07:46:19 <whataday> that above?
07:47:21 <Cale> https://downloads.haskell.org/~ghc/latest/docs/html/libraries/base-4.14.0.0/Foreign-Marshal-Array.html -- suppose you're doing FFI to some C library, and you need to allocate a bunch of arrays of various lengths, and then make sure they get deallocated afterwards
07:47:43 <Cale> allocaArray :: Storable a => Int -> (Ptr a -> IO b) -> IO b
07:48:24 <Cale> is a helpful thing to allocate an array of some length, giving the function a pointer to it, and then deallocating the array automatically once the action that the function produces has run
07:48:41 <Cale> (or if that action throws an exception...)
07:49:02 <maerwald> sm[m]: how can I ignore stderr in shelltestrunner for a certain test?
07:49:06 <Cale> So, maybe we want to allocate a handful of arrays, perhaps of lengths 5, 7, and 10
07:49:44 <Cale> We could use that function above on the list  map allocaArray [5,7,10]
07:50:00 <Cale> :t allocaArray -- wonder if we have this around...
07:50:01 <lambdabot> error: Variable not in scope: allocaArray
07:50:14 <Cale> :t Foreign.Marshal.Array.allocaArray -- qualified?
07:50:15 <lambdabot> Foreign.Storable.Storable a => Int -> (GHC.Ptr.Ptr a -> IO b) -> IO b
07:50:19 <Cale> cool
07:50:27 <Cale> :t map Foreign.Marshal.Array.allocaArray [5,7,10]
07:50:27 <whataday> ...
07:50:28 <lambdabot> Foreign.Storable.Storable a => [(GHC.Ptr.Ptr a -> IO b) -> IO b]
07:50:44 <Cale> :t runCont . sequence . map cont $ map Foreign.Marshal.Array.allocaArray [5,7,10]
07:50:45 <lambdabot> Foreign.Storable.Storable a => ([GHC.Ptr.Ptr a] -> IO b) -> IO b
07:50:59 <Cale> Now it's a thing which gives our function a list of pointers :)
07:51:13 <Cale> (to our arrays of size 5, 7, and 10)
07:51:28 <Cale> and it'll deallocate all the arrays after we're done using them
07:51:35 <Cale> (once the action completes)
07:52:27 <Cale> I'm not sure I'd take the trouble of using Cont in exactly this situation, but when you end up nesting a large number of withFoo-style functions it can end up untangling code.
07:53:10 <Cale> Mostly, we just don't use Cont though. It's a good example monad, but it's not all that practical. Usually something with less power will do the trick.
07:53:25 <whataday> yes
07:53:26 <Cale> Cont gives you callCC which is like first-class GOTO
07:53:51 <Cale> and... usually that's just a recipe for creating headaches
07:53:55 <whataday> nesting is easy to understand
07:55:01 <Cale> Yeah, though, sometimes it's awkward to write the thing which straightforwardly nests, when you don't know ahead of time which things you'll want to allocate, or there are an indefinite number of them
07:55:18 <glguy> Allocation nesting doesn't need the full Cont, at least
07:55:32 <Cale> That as well
07:56:27 <whataday> I'm glad we can do something with easy way
07:56:40 <Cale> The way I like to think about callCC is that it gives you exactly the thing that return does in C/Python/whatever
07:56:43 <glguy> https://github.com/glguy/irc-core/blob/v2/src/Client/CApi.hs#L265
07:57:02 <Cale> Except that it gives it to you *as a function which you can pass around and call from wherever*
07:57:07 <glguy> That module needs a ton of nested with- operations
07:57:18 <whataday> call/cc is easy to use and understand in scheme
07:57:39 <whataday> if we don't to think how it's implemented
07:58:05 <Cale> For some value of "easy to understand" which allows for arbitrarily-hard-to-understand interactions
07:58:23 <glguy> Easy to know you don't understand it?
08:07:03 <sm[m]> maerwald: >2 //  I think (match anything)
08:07:53 <sm[m]> also might need >=1 or >=//
08:08:30 <maerwald> I'm using format 2
08:08:49 <maerwald> >>>2 //
08:08:52 <maerwald> yes?
08:09:31 <sm[m]> Yes
08:11:42 <kuribas> tdammers: hi
08:11:44 <kuribas> tdammers: did you do work on supercompilation?
08:37:05 <ski> @hackage managed  -- whataday, perhaps this could be interesting to see, re `ContT'
08:37:06 <lambdabot> https://hackage.haskell.org/package/managed  -- whataday, perhaps this could be interesting to see, re `ContT'
08:40:55 <whataday> kan-extensions...
09:33:17 <fluturel> i have a small question regarding a small piece of code i wrote
09:33:40 <fluturel> I am trying to write a zip function
09:33:59 <fluturel> but for some reason it doesn't seem to want to work with infinite lists
09:34:17 <ski> did you use an accumulator ?
09:34:44 <fluturel> This is my version with list comprehension: zip' xs ys = [(xs !! i, ys !! i) | i <- [0..(min (length xs) (length ys))-1]]
09:35:00 <fluturel> ski: how do you mean?
09:35:28 <fluturel> my suspicion is it doesn't work becuase of the min function
09:35:34 <ski> ok. yea `length' won't terminate on infinite lists
09:35:48 <ski> > [0 .. length [0 ..] - 1]
09:35:54 <lambdabot>  mueval-core: Time limit exceeded
09:36:14 <fluturel> yeah, that makes sense and i figured that much
09:36:24 <fluturel> is there any way to check if a list is infinite?
09:36:25 <ski> so the problem is that you're using `length'
09:36:27 <ski> no
09:36:50 <ski> you can only observe finitely many elements of a list, in finite time
09:37:22 <ski> so, if you've seen a thousand elements, then you know the list has at least that many elements. might have no more, or one or ten more. or might be infinite
09:38:17 <ski> to gracefully handle infinite lists, make sure that your computation is "incremental", or productive, will produce some part(s) of the output, before having seen the end of the input list(s)
09:39:06 <ski> `length' is not incremental. it won't produce an answer, until it sees the end of the list. and since an infinite list has no end, it will never produce an answer, for such
09:39:48 <fluturel> so i iterate through the elements, form the tuples, and check if the next i is valid for both lists. If it isn't for one of them, that's all i need to know
09:40:33 <ski> yea, i suppose you could do that
09:40:58 <fluturel> what aabout the accumulator you mentioned?
09:41:05 <ski> another approach is to not bother with indices at all, just to pattern-match on the lists
09:41:47 <fluturel> i haven't learned pattern-matching yet, so i don't know the syntax or anything
09:42:16 <ski> well .. sometimes people write "loops" like this, using an accumulator. but that doesn't really work, for infinite lists. so, i was thinking that maybe you were using an accumulator, and that that was why your function didn't work on infinite lists
09:42:29 <ski> ok
09:42:54 <ski> if you can check whether an index is a valid index in a list, i think you should be able to do it that way, as well
09:43:33 <ski> (and you would have to check that, without calling `length' on the list)
09:43:44 <ski> hm
09:44:46 <ski> i think i see one way you could do it .. using a library function, from the `Prelude'
09:45:20 <ski> (alternatively, you could try diving into pattern-matching, at this point)
09:45:21 <fluturel> ok, shoot
09:45:43 <ski> consider the `!!' operator
09:45:46 <ski> @type (!!)
09:45:48 <lambdabot> [a] -> Int -> a
09:46:10 <ski> the problem here is that this assumes that the given index is already valid
09:46:21 <ski> > [2,3,5,7] !! 23
09:46:25 <lambdabot>  *Exception: Prelude.!!: index too large
09:46:36 <fluturel> yeah, exactly
09:46:50 <ski> so, you'd like to be able to detect whether an index is valid (without calling `length')
09:47:00 <ski> do you know the `Maybe' data type ?
09:47:40 <fluturel> heard about it. It's something like: maybe it's an int, maybe its Nothing
09:47:46 <ski> yes
09:47:57 <ski> it's something which you could possibly use here
09:48:18 <ski> if you could define an operator, say `!!?', with a type signature
09:48:26 <ski>   (!!?) :: [a] -> Int -> Maybe a
09:49:05 <ski> so that it looks up the value at the given index, if the index is valid, and otherwise tells the caller that there was no value to give back
09:49:16 <ski> that could be one way
09:49:35 <fluturel> but that would mean i need to catch the exception if it doesn't find anything there, right?
09:49:41 <ski> then, after calling that, it'd tell you whether it succeeded in looking up, or not
09:49:44 <ski> well
09:50:01 <ski> `!!' gives an exception, in case the index is not valid
09:50:24 <fluturel> yeah
09:50:30 <ski> however, the point here was that `!!?' would not give an exception then. but rather return an "error code", so to speak
09:50:54 <ski> so, you wouldn't need any exception catching, just to check the result whether there's an `a' element there or not
09:51:06 <fluturel> yeah, no, i understand that. I am querstioning what to do while implementing !!?
09:51:28 <ski> anyway, you'd still need to define `!!?', somehow (possibly using a `Prelude' function, as i hinted at)
09:51:48 <ski> and then, you'd need to figure out how to inspect the result of calling `!!?', in your `zip' version
09:52:27 <ski> the alternative here, would be to directly call that `Prelude' function from `zip', skipping `!!?' altogether (so, skipping having to deal with `Maybe')
09:52:42 <ski> but then you'd be dealing with more details, at the same time, perhaps
09:53:04 <fluturel> this seems like way above my paygrade for now, but i will give it a shot, although i barely learned the basics in haskell by now
09:53:13 <fluturel> I will see what i can ddo
09:54:10 <ski> to work with `Maybe' values, you could use `Nothing',`Just',`isJust',`fromJust'
09:55:04 <ski> fluturel : would you like a hint for how you could check if an index is valid ?
09:55:31 <fluturel> when declarinf functions i saw you can write something like func :: Int -> Int -> Int. Which is the return type? The last one?
09:55:41 <ski> yes, the last one
09:56:10 <fluturel> I think I will do my research on that one, i need to get familiar with the docs. If I can't, i will come back here
09:56:17 <fluturel> ok, thank you
09:56:21 * ski nods
09:56:40 <fluturel> how do you do that?
09:56:46 <ski> hm, do what ?
09:56:46 <fluturel> The nods thing
09:56:52 <ski> /me nods
09:57:09 * fluturel looks frightened at the documentation
09:57:15 <fluturel> Awesome
09:57:27 <ski> np
10:01:10 <ski> fluturel : hm, perhaps i should also mention that normally it's not a good idea to use `!!' on lists, unless they're fairly short. the point is that random-access in (singly) linked lists is not instant, it has to traverse the list from the start to the place in question
10:01:38 <ski> so, generally, one'd work with lists in other ways .. or switching to another data-structure, if one wants more efficient random-access
10:01:58 <ski> but since you're just learning the basics, it's okay to use `!!', for now
10:03:04 <c_wraith> I can think of approximately one idiom where !! stays relevant, and even it is sketchy
10:03:08 <fluturel> yeah, i heard that haskell uses linked lists and figured that !! is bad for obvious reasons, but as of now, i have no other clue how to do this little exercise i challenged myself with
10:03:26 <c_wraith> but when you're starting out, as ski says.  don't worry about it.
10:06:00 <ski> (hm, for `Maybe' values, `fromMaybe' could possibly also be nice to use. depending on how you structure your code)
10:08:43 <c_wraith> ski: did you see the person asking for style advice last night who ended up refactoring a big Maybe value into being generated by a do block?  I suggested it, and was happy it ended up working out so cleanly.
10:11:44 <Boarders> does anyone know how with hakyll what delimiters I use for inline latex?
10:11:46 <svipal> yo
10:11:59 <Boarders> for display mode I use $$ [equations] $$
10:13:46 <ski> c_wraith : hm, i didn't see it. any paste link which might still be valid ?
10:14:30 <c_wraith> it's just out of my scrollback on this computer.  I'd have to go to the other one and check my browser history :)
10:14:31 <ski> (or approx. how many hours ago was it ?)
10:14:50 <c_wraith> so it was a bit over 10 hours ago
10:16:15 <svipal> for some reason rtmidi ignores me changing the flags 
10:16:22 <svipal> in my stack.yaml
10:16:28 <svipal> is it because it has external c bits
10:17:58 <ski> c_wraith : hm, seems to be <https://paste.tomsmeding.com/7AifjNEN>,<https://paste.tomsmeding.com/dfCZuFjh>,<https://paste.tomsmeding.com/MO0geafX> ?
10:18:30 <c_wraith> yeah, those.  The function in the third one is the rewrite
10:22:28 <ski> c_wraith : ah, yes. that does look quite nice :)
10:22:43 <c_wraith> It's not often you get to do that, but I really enjoy when it works out.
10:23:23 <ski> and the OP hopefully understood the use of `do' for `Maybe' here, and was pleased
10:23:51 <c_wraith> I mean, I suggested using a do block, but they did the rewrite themselves.  Seemed plenty comfortable doing so.
10:26:01 * ski nods and smiles
10:31:49 <ski> hm, i wonder what type of board game this is, whether there can be more than one empty position
10:32:02 <ski> .. perhaps it's the "fifteen game"
10:32:44 <ski> (`applyOffset' could possibly also have use of having the result in a `Maybe')
10:44:19 * hackage Frames-streamly 0.1.0.0 - A streamly layer for Frames I/O  https://hackage.haskell.org/package/Frames-streamly-0.1.0.0 (adamCS)
10:54:13 <nineonine> hey everyone
10:54:25 <nineonine> I have a function for calculating binomial coefficient
10:54:36 <nineonine> binomCoef :: Double -> Double -> Double
10:54:36 <nineonine> binomCoef n k
10:54:36 <nineonine>   | n < 2     = 0
10:54:38 <nineonine>   | otherwise = fact n / ((fact (n-k)) * (fact k))
10:54:40 <nineonine>                 where fact m = product [1..m]
10:54:52 <nineonine> so when I play with it in ghci it works fine 
10:55:13 <nineonine> so binomCoef 21 2 => 210.0
10:55:32 <nineonine> but when it is used deep in my program it returns different result
10:55:50 <nineonine> it returns -17.46593177669282 for exact same arguments
10:55:53 <nineonine> I am puzzled
10:56:07 <nineonine> so the question is
10:56:10 <nineonine> why?
10:57:19 <nineonine> note, that the first guard in the function is specific to the problem which I am trying to solve so please ignore it
10:57:47 <nineonine> the actual calculation is in second GRHS
10:58:31 <nineonine> it works fine up to 20
10:58:39 <nineonine> after that it starts returning nonsense results
11:00:45 <monochrom> Could you post the complete code that produced -17.46... ?
11:00:48 <monochrom> @where paste
11:00:48 <lambdabot> Help us help you: please paste full code, input and/or output at eg https://paste.tomsmeding.com
11:01:18 <nineonine> here you go!
11:01:18 <nineonine> https://paste.tomsmeding.com/SDUUcLFg
11:01:21 <nineonine> thx!
11:02:04 <tomsmeding> nineonine: the inner binomCoef takes Int's
11:02:10 <tomsmeding> that product [1..m] is going to overflow
11:02:15 <nineonine> aha
11:02:32 <nineonine> how do I fix it
11:02:35 <monochrom> > product [1..21] :: Int
11:02:37 <lambdabot>  -4249290049419214848
11:02:41 <tomsmeding> possible solutions: Integer instead of Int; Double instead of Int; use a different algorithm that isn't as susceptible to overflow :)
11:02:43 <monochrom> Ah, like that.
11:02:47 <fluturel> ski: are you still here?
11:02:59 <ski> no
11:03:07 <ski> i'm over there
11:03:08 <monochrom> Yeah using factorial for binom is the worst idea.
11:03:14 <fluturel> i think i got it with pattern matching
11:03:17 <monochrom> In multiple ways, not just this one.
11:03:21 <ski> fluturel : okay ?
11:03:22 <nineonine> what would be a better solution here?
11:03:41 <tomsmeding> nineonine: e.g. https://math.stackexchange.com/a/927064/68044
11:03:43 <fluturel> ski : you know, the zip' function
11:04:07 <tomsmeding> wait no
11:04:16 <ski> fluturel : yes, i didn't forget :)
11:04:45 <ski> (i meant "okay ?", as in "well, let's hear about it ?")
11:04:57 <monochrom> > product [1..21] :: Double
11:04:59 <fluturel> zip' :: [a] -> [b] -> [(a,b)]
11:05:00 <lambdabot>  5.109094217170944e19
11:05:00 <fluturel> zip' (x:xs) (y:ys) = [(x,y)] ++ (zip' xs ys)
11:05:00 <fluturel> zip' _ [] = []
11:05:00 <fluturel> zip' [] _ = []
11:05:14 <fluturel> How do i post multiline code
11:05:35 <geekosaur> use a pastebin, ideally
11:05:48 <geekosaur> @where paste
11:05:49 <lambdabot> Help us help you: please paste full code, input and/or output at eg https://paste.tomsmeding.com
11:06:16 <dsal> fluturel: You could also use ;
11:06:34 <fluturel> ski: https://pastebin.com/JLshNdsN
11:06:46 <fluturel> dsal: already made a pastebin, but thank you
11:07:15 <dsal> ; is helpful if you want lambdabot to run the code.  :)
11:08:00 <ski> fluturel : yep, that looks fine :)
11:08:11 <tomsmeding> nineonine: https://codeforces.com/blog/entry/55311 that's the algorithm that I know, I can try functionalising it
11:08:12 <fluturel> ski: i vwas wondering if there is a better way to rewrite the last two lines. I mean,. they are the same thing, just in onecase the first list finishes its elements first
11:08:37 <ski> fluturel : you could replace them with  zip' _ _ = []
11:08:40 <fluturel> or the other way around actually
11:08:50 <ski> as long as that defining equation is after the recursive one
11:08:55 <nineonine> tomsmeding, that would be great :)
11:09:34 <ski> fluturel : btw, the brackets around the recursive call are redundant. and you could use `:' in place of `++'
11:09:56 <fluturel> ski: actually yeah, you are right. If it doesn't match with the first pattern, the second will catch it regardless and return an empty list
11:10:06 <fluturel> ski: oh, didn't know that
11:11:08 <fluturel> ski: just to clarify, which brackets? These: [(x,y)] ?
11:11:48 <ski> fluturel : one argument for not replacing them like that would be that, the way you've written the defining equations, you could actually have them in any order. and you can understand them in isolation, as true statements about your function. but if you have the patterns in the base case overlap with the patterns in the recursive case, then you can't understand the base case in isolation
11:11:57 <ski> fluturel : no, the round brackets
11:12:00 <dsal> fluturel: (zip' xs ys)
11:12:14 <ski> ("around the recursive call")
11:12:16 <dsal> hlint will tell you things like that.
11:12:47 <fluturel> is hlint for emacs a thing?
11:12:53 <dsal>  Just a cli tool
11:13:03 <dsal> But probably.
11:14:25 <ski> fluturel : .. but in some situations, one can replace a lot of extra cases, with just a single "catch-all"/"default" case, at the price of having overlapping cases
11:14:36 <fluturel> I am going to look more into defining the !!? operator and working with Maybe, as i have something to learn from there, but i think this is the more elegant solution. Not gonna lie, i feel quite proud of it :)
11:15:06 <nineonine> tomsmeding: btw, I used the solution from that SO answer and it seems to work fine. Many thanks again!
11:15:07 <ski> yes, this is the idiomatic solution
11:15:17 <nineonine> not SO, but SE
11:15:41 <ski> fluturel : i was just thinking that, doing it without explicit pattern-matching, could possibly be an interesting exercise
11:15:44 <fluturel> ski: i see what you mean, i guess for more complicated patterns, understanding them in isolation is better, but here overlapping them won't be such a burden for a reader
11:16:00 <tomsmeding> nineonine: yes it does seem to work fine indeed; I'm kind of surprised that it does though
11:16:08 <tomsmeding> also, it contains non-tail recursion, while this one doesn't: https://paste.tomsmeding.com/cj6pnnXi
11:16:12 <ski> (btw, of course `!!' itself is defined, using pattern-matching. and the function you'd call from `!!?' also would be)
11:16:14 <tomsmeding> but feel free to use the SE one :p
11:16:21 <nineonine> will do, thx :D
11:16:34 <tomsmeding> (oh not choose2 but binomCoef of course)
11:16:48 <nineonine> I don't quite understand though why isn't it included in base
11:16:56 <nineonine> it seems somewhat useful sometimes
11:17:13 <nineonine> maybe because it is extremely inefficient? dunno
11:17:42 <dsal> base is too big.  Things in base should be very useful all the time.
11:18:05 <nineonine> I agree
11:18:16 <tomsmeding> there is also not really a canonical implementation
11:18:36 <tomsmeding> the overflow problem can be solved by either going to Integer or to Double, but people won't expect that
11:18:45 <tomsmeding> since the algorithm can overflow before the correct answer would
11:18:53 <dsal> Or Scientific!
11:19:05 <fluturel> ski: is !! defined recursively with pattern matching as well? That would make sense, but i thought it would be a built-in or something, written directly in the target language in the compiler to make it faster. I may be spewing nonsense, but it is what i thought
11:19:30 <ski> fluturel : yes
11:19:34 <ski> it's not built-in
11:19:47 <ski> just a library operation, defined in Haskell
11:19:47 <dsal> @fluturel There's a source link in the doc pages.  !! is a bit fancy: https://hackage.haskell.org/package/base-4.14.0.0/docs/src/GHC.List.html#%21%21
11:19:47 <lambdabot> Unknown command, try @list
11:19:47 <dolio> I've never needed binomial coefficients in my programs in like 15 years of writing Haskell.
11:19:51 <dolio> Maybe that's why it's not in base.
11:19:53 <dsal> @src (!!)
11:19:53 <lambdabot> xs     !! n | n < 0 = undefined
11:19:54 <lambdabot> []     !! _         = undefined
11:19:54 <lambdabot> (x:_)  !! 0         = x
11:19:54 <lambdabot> (_:xs) !! n         = xs !! (n-1)
11:20:10 <dsal> lambdabot's @src will show you a simple, idealized implementation, but not necessarily what GHC will do.
11:21:19 * hackage config-value 0.8 - Simple, layout-based value language similar to YAML or JSON  https://hackage.haskell.org/package/config-value-0.8 (EricMertens)
11:21:43 <fluturel> dsal: i'm having a bit of trouble with the src there, but i get the gist
11:22:15 <dsal> foldr has a few magic bits that takes intuition a bit of time to catch up with.
11:22:39 <fluturel> i didn't get to foldr yet
11:22:43 <dsal> That's why @src shows you a trivial, functionally equivalent version.  :)
11:22:55 <ski> `| k > n = undefined' ought to be `| k > n = 0', arguably
11:23:06 <dsal> I use foldr a *lot*, but foldr + laziness means you can fold infinite lists meaningfully.
11:23:08 <fluturel> @src foldr
11:23:08 <lambdabot> foldr f z []     = z
11:23:08 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
11:23:48 <dsal> foldr is like, the default catamorphism.  If you have a bunch of stuff and you want some kind of potentially smaller transformation of it, that's foldr.
11:23:53 <oats> I forget, is foldl the one that's discouraged, or foldr
11:24:06 <dsal> The problem with *that* foldr implementation is that it works in far fewer cases than the real one.
11:24:09 <c_wraith> generally you want foldl' instead of foldl
11:24:12 <dsal> oats: foldl should basically never be used.
11:24:21 <oats> that's what I thought
11:24:22 <fluturel> dsal: why?
11:24:32 <dsal> fluturel: why which?
11:24:48 <fluturel> dsal: why should foldl nver be used?
11:24:49 * hackage config-schema 1.2.1.0 - Schema definitions for the config-value package  https://hackage.haskell.org/package/config-schema-1.2.1.0 (EricMertens)
11:25:10 <dsal> fluturel: Oh, just dumb behavior.  foldl' is what you want if you think you want foldl most of the time.  foldr is the default, though.
11:25:27 <oats> https://github.com/hasura/graphql-engine/pull/2933#discussion_r328821960
11:25:31 <dsal> foldl' is strict on the accumulator.  foldl has to build up a giangantic thunk before doing anything.
11:26:11 <oats> tldr, foldl is too lazy and leaks memory
11:26:20 <fluturel> foldr is kind of like reduce in CL?
11:26:44 <dsal> fold, foldl, foldr, etc... are all that type of catamorphism, yeah.
11:26:57 <dsal> :t foldr -- the real foldr works on a lot more than lists, though.
11:26:58 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
11:27:31 <fluturel> so anything that belongs to the Foldable typeclass
11:27:40 <dsal> "has an instance of" yeah
11:27:50 <oats> “When the accumulation function is strict, use foldl' to consume the list in constant space, since the whole list is going to have to be traversed, anyway.
11:28:00 <oats> When the accumulation function is lazy in its second argument, use foldr to do work incrementally to improve streaming and work-saving.
11:28:01 <dsal> You can make a thing, make your thing foldable, and a *lot* of functionality comes about for free.
11:28:02 <oats> ”
11:28:37 <dsal> :t sum -- e.g., you get stuff like this for free
11:28:38 <lambdabot> (Foldable t, Num a) => t a -> a
11:29:31 <fluturel> what is "t a"? Why is there no `->` inbetween?
11:29:49 * hackage hookup 0.5 - Abstraction over creating network connections with SOCKS5 and TLS  https://hackage.haskell.org/package/hookup-0.5 (EricMertens)
11:30:22 <fluturel> sorry for my very beginner questions :)
11:31:00 <{abby}> fluturel: `t a` is the type constructor `t` applied to the type `a`; if you set (for example) t = Maybe then you get `Maybe a`, for t = [] (lists) you get `[] a` (commonly spelled `[a]`), etc
11:31:53 <dsal> You can colloquially read that as a "Foldable (thing of) Num" if you're being extra lazy.
11:32:08 <fluturel> so t is a container of some sorts (or can be, for a type a)
11:32:33 <ski> fluturel : yes. `t' specifies some kind of "container", and `a' the "element type", there
11:32:42 <dsal> "Container" is often a lazy way to look at some of these things.  It doesn't need to be a container per se, just Foldable.
11:33:29 <ski> fluturel : and no worry, beginner questions are welcome in here
11:34:35 <{abby}> dsal: I'd agree if we were talking about Monad & co but I honestly don't see a problem with referring to instances of Foldable as "containers"
11:34:51 <fraktor> What is a foldable that is not also a container?
11:35:09 <dsal> I can make a dumb obligatory example, but it's kind of pointless.
11:35:10 <c_wraith> yeah...  unlike many things, Foldable must actually contain (0 or more) values of a particular type
11:35:22 <dsal> If it's Foldable, it's probably containing things.
11:35:27 <ski> (`Const c' is an "always empty" container type)
11:38:50 <ski> fluturel : in the type `[Int]', which is more uniformly spelled as `[] Int', you can read `[]' as "list of". it specifies the type of container. but you can't have e.g. `foo :: []'. `foo' can't have type "list of", it must be a list of something (some type to use as element type)
11:40:02 <ski> you could say that `[]', and other similar things, like `Maybe',`Either',`Map',`IO' are "incomplete types", requires one to specify some more type(s) after it, to get a concrete type, that you could use as the type of a value (perhaps an input value to, or an output value from, a function)
11:40:52 <ski> one could also call these "parameterized types", or "type functions" (not to be confused with "function types", which are types of the shape `.. -> ..', like e.g. `[a] -> Int' or `Int -> [a] -> [a]')
11:41:51 <ski> `[]' is like a function that consumes not values, but types (ordinary, concrete types, not type functions). so, if you pass it the type `Int', you get back the type of lists of `Int's
11:45:13 <monochrom> It is useful to first look at "Maybe Int" syntactically and break it into the Maybe-ness and the Int-ness.
11:45:41 <monochrom> And then to also find in in horror that "[] Int" is legal syntax, too. That will put things in perspectives.
11:46:42 <dsal> Why can't I use  MayIntBe ?
11:46:52 * dsal is angered by haskell's inconsistent syntax
11:46:57 <monochrom> Haskell takes seriously the idea of isolating out the Maybe-ness, the []-ness. Other languages don't, and that's where they run into a severe limitation.
11:47:34 <monochrom> Oh, for general mixfix syntax, please refer to Agda. >:)
11:48:43 <monochrom> User-definable mixfix could be a nice addition the next time the Haskell report is updated.
11:48:52 <dolio> Agda doesn't let you arbitrarily divide tokens that weren't defined that way, though.
11:49:21 <dolio> Mixfix design is a huge mess of tradeoffs, too.
11:49:23 <monochrom> Yeah, not MayIntBe per se, but perhaps ^Int$
11:49:43 <dolio> Like, you can't write `(a, b, c)` in Agda.
11:50:09 <dolio> For tuples.
11:50:35 <monochrom> Haskell 2050 will use GPT-5 to learn your favourite syntax from a corpus you provide! >:)
11:51:24 <davve> i want brainf*ck
11:51:25 <monochrom> "I'm done with manually changing the GHC grammar." -- SPJ in 2049.
11:52:42 <monochrom> "I have found a way to integrate GPT-5 into the GHC parser. Committed in HEAD." -- Simon Marlow in 2050
11:53:00 <dolio> I mean, I like Agda, but I wouldn't say its syntax is categorically better than Haskell's. It's just nice and not nice in different ways.
11:53:41 <monochrom> I am wary of mixfix, actually
11:54:06 <dolio> I think it might be bad for Haskell, actually.
11:54:31 <dolio> Because you'd get people attempting really complicated mixfix syntax hacks like they do with type programming.
11:54:45 <monochrom> haha
11:54:50 <dolio> Struggling to get them to parse unambiguously.
11:54:53 <monochrom> Yes
11:55:56 <fluturel> i wonder if there is a brainfuck channel. Brb
11:56:26 <monochrom> Hrm, they don't need to quit one channel to explore others.
11:57:15 <fluturel> there is, but no one is on it
11:57:35 <dolio> Joining any channel will create it.
11:57:39 <monochrom> "Curiosity kills the cat. Dissatisfaction brings it back!"
11:58:26 <fluturel> dolio: that's a bummer
11:58:39 * fluturel is disappointed
11:58:52 <monochrom> Maybe under another name.
11:59:12 <dolio> Yeah, did you do the double hash version? It's what they want 'non-official' channels to be named nowadays.
11:59:15 <monochrom> At least try all 4 possibilities: #brainfuck, ##brainfuck, #bf, ##bf
11:59:53 <fluturel> i did not
11:59:56 <fluturel> will do
12:02:46 <outer_passage> is it possible to have cabal show all ghc warnings for a project without recompiling the whole thing?
12:03:46 <fluturel> couldn't find anything
12:04:18 <fluturel> although #bf was kinda weird, seems like it existed already
12:04:35 <tomsmeding> fluturel: you don't have to leave one channel to join another ;)
12:05:14 <tomsmeding> evidently there is one (1) person in ##brainfuck
12:05:46 <tomsmeding> outer_passage: if with "the whole thing" you mean your project, and not the dependencies, then no
12:05:48 <fluturel> i know, but i can't be bothered to remember how to open multiple tabs and navigate through them. I haven't used irssi in a long long time
12:06:13 <tomsmeding> because ghc doesn't produce the warnings if it isn't told to do so, and if you don't turn on warning in a project, cabal will not tell ghc to produce warnings at all
12:06:39 <tomsmeding> fluturel: there are other irc clients :)
12:21:49 <ski> fluturel : "<monochrom> Hrm, they don't need to quit one channel to explore others."
12:22:43 <ski> hm, you can use `Alt-2',`Alt-3' to switch between your channels, i think
12:23:38 <geekosaur> there's also things like webchat.freenode.net where the channel tabs are graphical
12:25:42 <fluturel> ski: i remembered that as well, but those bindings are for switching between my terminal tabs, so no good. Typing /win <num> seems to work 
12:26:22 <ski> or `<esc> 2',`<esc> 3'
12:27:36 * ski also bound `Alt-p' and `Alt-n' to previous and next. possibly you can already use `Alt' with arrow keys (left and right), too
12:31:52 <dsal> Since MarcelineVQ shamed me for not writing a README, I wrote one real quick:  https://github.com/dustin/gopro
12:32:19 <davean> fluturel: how are you managing to join a channel without it automaticly creating a tab?
12:32:33 <davean> I wouldn't know how to do what you seem to be doing
12:35:35 <dsal> I realized when documenting this that a prospective user might be pretty sad when trying to bring this up and having to learn how to modify the database to point to different S3 bucket, and like, know how to use S3 and stuff.  But I'll wait for a user, I guess. heh
12:41:00 <fluturel> davean: i just did it the dumb way. Closing irssi and opening it again
12:41:15 * fluturel is stupid
12:41:44 * Lycurgus claps 'is hands
12:41:49 <davean> fluturel: I didn't even realize you could join a channel like that.
12:42:12 <ski> `/join #bf' should work, to join that channel
12:42:49 <ski> davean : how i did it, with ircII, initially
12:43:10 <fluturel> ski: it does, but i didn't know how to get back to the haskell tab
12:44:23 <fluturel> my lazyness only rivals Haskell's
12:45:18 <sm[m]> dsal++ !
12:46:49 * hackage x86-64bit 0.4.6.1 - Runtime code generation for x86 64 bit machine code  https://hackage.haskell.org/package/x86-64bit-0.4.6.1 (PeterDivianszky)
12:47:12 <fluturel> Say, if I have two generic types in a function declaration, they can be the same when i use the function, right?
12:47:48 <fluturel> sum' :: (Num a, Num b) => [a] -> b
12:47:52 <geekosaur> they can be, but you can't know what they are so you can't check for the specific case where they're the same
12:47:53 <koz_> fluturel: If you mean something like 'f :: a -> b -> a', yes, it is possible to have a and b both be the same type.
12:48:16 <koz_> The only difference that use of a different type variable makes is that the types are _allowed_ to be different.
12:48:20 <koz_> (not forced)
12:48:27 <geekosaur> and that particular signature looks like a problem to me, tbh
12:48:31 <fluturel> yeah, that's what i thought as well
12:48:48 <fluturel> but ghci complains and i can't figure out why
12:48:59 <koz_> fluturel: What exact complaint are you seeing?
12:49:00 <dsal> fluturel: what's the complaint?
12:49:07 <geekosaur> :t (+)
12:49:09 <lambdabot> Num a => a -> a -> a
12:49:10 <koz_> geekosaur is right that the signature looks suspect.
12:49:27 <fluturel> Couldn't match expected type 'b' with type 'a'
12:49:36 <monochrom> "use the function" is the opposite of "implement the function"
12:49:39 <dsal> That makes sense.  Where would b come from?
12:49:45 <fluturel> and then some more lines about 'a' and 'b' being rigid types
12:49:55 <monochrom> Everything the user can do, the implementer cannot.
12:50:11 <geekosaur> you told the compiler they *could* be different. then you presumably used (+)
12:50:13 <geekosaur> :t (+)
12:50:15 <lambdabot> Num a => a -> a -> a
12:50:30 <koz_> Which says 'the types gotta be the same, yo'.
12:50:46 <fluturel> Well, i thought that since i am summing things of type a in a list of type [a], the ghci can finfer that the output is b, but it can't
12:50:59 <koz_> fluturel: How does it do that exactly?
12:51:01 <dsal> Well, you're specifically saying it can be any type as long as it's a Num
12:51:10 <koz_> Suppose a ~ Int and b ~ some matrix type?
12:51:31 <koz_> How exactly do you go from 'an Int produced by summing other Ints' to 'some matrix type'?
12:51:45 <fluturel> well, you can't..
12:52:06 <geekosaur> but that's what you told it with that signature
12:52:06 <koz_> fluturel: But your signature says that you can.
12:52:14 <koz_> So GHC is disagreeing with the signature.
12:52:32 <fluturel> I see
12:52:39 <koz_> (I think I owe geekosaur a soda, lol)
12:55:24 <dsal> I set up github actions for all my haskell projects, and then at some point, all of them started failing.
12:55:51 <fluturel> let's say the function doesn't do a sum, but it does something else depending on the input. Let's say if it gets an empty list, it returns a double (for some reason). Then it wouldn't complain anymore, would it? Because it sees that in certain cases, b is the same as a, an int, but sometimes it isn't, so my signature would be correct
12:56:56 <geekosaur> with respect to a type signature, your implementation does not choose the types; the caller does
12:57:28 <geekosaur> so your signature tells a caller that it can request a Double result from an [Int], for example
12:57:49 <koz_> fluturel: The best way to think of a signature like that (namely, with type variables) is that the caller of the function is allowed to set those variables to be anything, provided those things are both instances of Num.
12:57:57 <geekosaur> your implementation, on the other hand, does not get to pick Double for an empty list or Int otherwise; it has to be the same type in both cases
12:58:06 <koz_> Therefore, you as the _implementer_ must, in all cases, accomodate absolutely any such choice, now and forever.
12:58:25 <koz_> Having it work _some of the time_ or for _some choices_ of arguments or types isn't sufficient.
12:58:34 <koz_> Essentially, this is a contract between you and your caller.
12:58:42 <ski> @quote freedom.is
12:58:42 <lambdabot> monochrom says: in fact, freedom is the freedom to write 2.2 = 4
12:58:45 <ski> @quote freedom.is
12:58:45 <lambdabot> monochrom says: in fact, freedom is the freedom to write 2.2 = 4
12:58:49 <ski> hm
12:58:53 <koz_> Which says 'as long as you ensure that a and b are both instances of Num, then I will have this work'.
12:59:02 <ski> @quote freedom.is.your
12:59:02 <lambdabot> monochrom says: Programming is a dialectic class struggle between the author and the user.  My freedom is your slavery. Your ignorance is my strength.
12:59:08 <sm[m]> dsal: stack casa timeouts ? this was affecting folks recently
12:59:08 <koz_> And therefore, those facts are the only things you are allowed to use.
13:00:08 <dsal> I don't even quite understand.  It's been this way for a month or so.  I got it all set up and then it all broke and I've just not gone into figuring it out.  I figured if all of them were broken, it might work itself out.
13:03:04 <int-e> oh monochrom... but what if the user is also the programmer?
13:03:13 <ski> > (2 . 2) 4
13:03:15 <lambdabot>  2
13:03:31 <int-e> that Num instance again :-(
13:03:55 <int-e> @undef
13:03:56 <lambdabot> Undefined.
13:06:27 <fluturel> koz_ : I understand what the type signature entails, i was asking more something like: can a function return different types depending on what the caller inputs?
13:06:53 <geekosaur> it cannot
13:07:07 <geekosaur> that's what I was saying earlier
13:07:19 <geekosaur> >> your implementation, on the other hand, does not get to pick Double for an empty list or Int otherwise; it has to be the same type in both cases
13:07:36 <fluturel> Then it was i who misunderstood, i am sorry
13:08:28 <fluturel> Haskell is giving me the headaches and i am tired
13:08:29 <ski> the caller can pick a different type, that's used both as input type and output type
13:08:32 <Cale> It can produce different types of result based on the type of the argument...
13:08:35 <geekosaur> (that's what the compiler meant by "rigid", by the way)
13:08:51 <Cale> but not the value of the argument
13:09:08 <ski> but you, as the implementor, can't decide to pick different output types here, depending on what input values you see (you can't even detect which types of input you're getting)
13:09:32 <fluturel> yeah, so no reflection
13:10:01 <fluturel> I can only guarantee that if it is an instance of Num, the function behaves correctly, no funny business
13:10:27 <fluturel> If it isn't, the caller gets an error
13:10:36 <dsal> You *can* write that function, but it's usually a bad idea.
13:11:28 <fluturel> by that function, you mean the one with the signature i showed earlier?
13:11:34 <dsal> yeah
13:11:45 <Cale> Which function?
13:11:54 <fluturel> at this point, i don't think i want to
13:12:47 <fluturel> Cale: sum' :: (Num a, Num b) => [a] -> b
13:13:37 <Cale> Not which doesn't ignore the elements of the input list...
13:13:41 <Uniaika> *
13:13:53 <Uniaika> evening
13:14:42 <pie_> in haskell combinator libraries does something like "many eof" hang? because it does hand in python's parsy library and i want to know if i should file a bug report of if thats reasonable behavior
13:14:47 <Cale> With Integral a, you could convert them to Integer and then to b from there
13:14:52 <dsal> Right.  You'd need more constraints to do something slightly useful, which is converting from whatever type to another type, but doing that conversion where you need it would make everything easier.
13:14:58 <pie_> the eof parser just checks if the "index" in the "stream" is >= the length...
13:15:56 <monochrom> int-e: In that case, I took a Bernard Shaw quote and brought it to a new level: "I argue with myself all the time, it adds sparks to my debates."
13:16:51 <monochrom> But really, we know what "put on your user hat" and "put on your implementer hat" mean, and how to do it.
13:16:52 <Cale> pie_: It probably depends on the library, but at least ReadP manages to parse (many eof) successfully on an empty input.
13:18:16 <Cale> (and on a nonempty input)
13:20:07 <pie_> Cale: my actual problem is that it hangs
13:20:22 <pie_> what it looks like in python: eof.many().parse("") jhangs
13:21:02 <Cale> Applying many to a parser which accepts an empty string is usually going to be dangerous
13:21:03 <pie_> and im not sure what to do about it because im trying to do something like any_line.many(), where a variant is line can be an empty at the end of the file...
13:21:05 <pie_> hm
13:21:13 <pie_> Cale: yeah
13:21:54 <pie_> so what i actually have is any_line = (not eof or newline).many() << (eof | newline)
13:22:04 <pie_> and i run into the problem when i do any_line.many()
13:22:14 <pie_> and idk how to restructure it
13:22:18 <pie_> so that it works
13:23:31 <pie_> oh hm maybe i should just (text << (newline | eof)) | (empty line << newline)
13:25:30 <pie_> (pseudocode)
13:26:24 <Turmfalke> pie_: In parsec you could use something like `manyTill (newline <|> eof)`
13:26:56 <Turmfalke> `manyTill anyChar (newline <|> eof)` actually
13:27:13 <Cale> Turmfalke: Well, but could you apply many to *that*?
13:27:19 <monochrom> This feels like a wild goose chase because first of all there is no reason to believe that python's parsy has remotely the same semantics as parsec or megaparsec.
13:27:40 <monochrom> (in particular how much backtracking happens)
13:27:48 <Turmfalke> Cale: Why not?
13:28:12 <Turmfalke> Hhm, ah...
13:28:26 <Cale> eof accepts on empty input, and many doesn't like parsers which accept on empty input
13:29:33 <pie_> cool i think it works, thanks for rubbr ducking :D
13:30:20 <pie_> monochrom: i dunno id assume most monadic parser combinators behave at least somewhat similar?
13:30:58 <Cale> They're *somewhat* similar, but there are differences when you get to subtle issues like this one
13:31:16 <pie_> hm
13:31:48 <pie_> it doenst help that i dont really understand how it works
13:31:53 <Cale> (The one I tried first is completely okay with parsing many eof, even though the list of parses it gives you is infinite)
13:32:10 <pie_> i guess laziness helps
13:32:19 <monochrom> "similar" is not enough
13:32:28 <monochrom> C and Rust are "similar".
13:32:39 <monochrom> Lisp and Agda are "similar"
13:32:42 <sm[m]> you could prototype it in both haskell and python, for extra insight & testing
13:32:51 <monochrom> Tuesday is like Monday, but different.
13:33:03 <pie_> monochrom: i accept that as fair but i assumed this would be an issue where similar is sufficient
13:33:08 <Cale> There are only a few problems you can run into though, so asking about how Haskell libraries deal with it isn't bad
13:33:12 <monochrom> http://www.vex.net/~trebla/humour/tautologies.html
13:33:45 <pie_> if it would not have been sufficient, i assumed i would probably have been told so
13:34:13 <monochrom> Different parser combinators are going to be very likely disagree on the detailed semantics of <|>. That's where "similar" fails.
13:34:21 <dolio> Seems like a lot of assumptions going on. :)
13:34:27 <pie_> and haskell is probably the community with largest overlap between parser combinators and "uh ive got some parser combinator libary in antoher language here :P"
13:34:34 <pie_> dolio: so it goes, but feedback loops
13:35:04 <pie_> dolio: i need help with a library but first i must construct the universe ;p
13:35:30 <monochrom> For example ReadP in base supports ambiguous grammars fully, <|> is perfectly ideal fair choice, all possibilities of "p <|> q" really happen.
13:36:09 <monochrom> But parsec and megaparsec beg to differ. "p <|> q" becomes simply p if p consumes at least one character/token.
13:36:17 <pie_> (i knew the problem was that the parser wasnt "consumptive" (as opposed to productive :P), but my brain didnt get from point a to point b on actually fixing it till i rubber ducked it i guess. anyway, much ado about nothing)
13:36:29 <monochrom> (overridable if you use "try p <|> q")
13:36:59 <pie_> monochrom: i see. so they "commit" it if consumes?
13:37:04 <monochrom> Yes
13:37:09 <sm[m]> megaparsec has some automatic backtracking but I always forget the details
13:37:28 <pie_> i might not mind explicit backtracking
13:37:36 <pie_> maybe implicit backtracking is half my issues
13:37:57 <pie_> at least uhh... i think the library does implicit backtracking...idek
13:38:03 <pie_> i just know i get stuck a lot :P
13:38:06 <sm[m]> you're flying blind :)
13:38:11 <monochrom> A priori I have no reason to believe parsy's <|> behaves as ReadP or as parsec or as something else.
13:38:20 <pie_> yeah
13:38:30 <dolio> Could be PEG.
13:38:53 <monochrom> A posteriori if you have being working at the level of "I think they are all similar" then I know for sure you don't know either.
13:38:53 <pie_> sm[m]: i did at one point think of rewriting it in haskell but i figured maybe i should get stuck with one thing at at a time :P
13:39:28 <sm[m]> I can understand that.. but if I couldn't get the insight on the python side I would do it, just to (probably) understand what's happening
13:39:38 <pie_> *nod*
13:39:49 <sm[m]> but surely you can introspect and get the parse state from parsy somehow ?
13:40:36 <pie_> well, idk about the graph of parser computations but the (stream, index) dumping function _has_ been helping
13:41:55 <pie_> havent had much time to work on it since yesterday, now im going to try to figure out what this adhoc human format's offsides-rule is and how to parse it...
13:42:54 <monochrom> Yeah you do have the extra uphill battle of still trying to decide what rule you want to enforce.
13:43:19 <monochrom> This is how ECMAScript happened. :)
13:43:23 <pie_> heh
13:43:48 <pie_> honestly i wish id just have a copy of the program that made it or something
13:44:24 <monochrom> Yeah that would help.
13:46:32 <carter01> Has anyone set up haskell language server with Coc here? I just get this error: Launching server "languageserver.haskell" using command haskell-language-server-wrapper failed.
13:48:05 <Uniaika> carter01: I do
13:48:10 <Uniaika> but I don't get your error
13:48:26 <carter01> sad life
13:48:32 <Uniaika> what does haskell-language-server-wrapper says if you run it in your project's directory?
13:49:32 <carter01> It doesn't say anything. Im using stack and when I run it at the top level it just doesn't do anything. It's only when I open a particular file that it starts up 
13:50:34 <carter01> Which makes sense right? I just open things using neovim, so opening a directory structure wouldnt do much with haskell language server
13:51:08 <dolio> haskell-language-server-wrapper is an executable.
13:51:17 <dolio> What happens if you just run it in a terminal?
13:51:27 <carter01> idk one sec
13:52:39 <Uniaika> yes sorry, that's what I meant
13:54:22 <carter01> oh no worries! Im just trying to locate where that wrapper is
13:54:37 <dolio> That might be the problem. :)
13:55:02 <dolio> When I was trying to set things up, it was expected to be in my path.
13:55:52 <carter01> yeah I don't have that in my path so that probably is the problem!
13:55:57 <carter01> thank you!
13:58:10 <Uniaika> carter01: I download it directly from the GH releases
13:58:20 <Uniaika> then rename it to remove the -Linux part
14:04:44 <carter01> I used ghcup to install it I think. But im not sure that added it to my path. I also used that to install ghc, but im not sure that added it to my path either
14:05:06 <carter01> I just need to figure how to correctly add the right files to my path
14:05:48 <carter01> Im also not sure if doing ghcup install hls adds the haskell-language-server or the haskell-language-server-wrapper. So I gotta figure that out lol
14:23:48 <[exa]> is there some nice idiom that would work like `map` except working specially with first and last element (including the case when first is last) ?
14:24:53 * koz_ o O O (mapEnds)
14:25:09 <MarcelineVQ> some kinda Palindrome view
14:27:18 * hackage haskell-gi 0.24.5 - Generate Haskell bindings for GObject Introspection capable libraries  https://hackage.haskell.org/package/haskell-gi-0.24.5 (inaki)
15:51:19 * hackage test-monad-laws 0.0.0.0 - Laws for mtl classes as QuickCheck properties.  https://hackage.haskell.org/package/test-monad-laws-0.0.0.0 (lyxia)
16:06:49 * hackage brick 0.56 - A declarative terminal user interface library  https://hackage.haskell.org/package/brick-0.56 (JonathanDaugherty)
16:19:49 * hackage stm-actor 0.2.3.0 - A simplistic actor model based on STM  https://hackage.haskell.org/package/stm-actor-0.2.3.0 (sgschlesinger)
16:33:33 <todaysTomorrow> Who here has any experience with the seL4 kernel?
16:40:54 <todaysTomorrow> HEllo totallynotnate
16:41:06 <todaysTomorrow> What experience do you have with haskell
16:41:35 <totallynotnate> oh not much right now really
16:41:59 <totallynotnate> i just have this channel on autojoin just in case
16:42:13 <todaysTomorrow> Would you like to learn, if you're just starting I recommend learn you a haskell for great good
16:42:53 <totallynotnate> i have that book in my possession, and yes it is a great book
16:43:16 <todaysTomorrow> What learning have you done with it?
16:43:31 <totallynotnate> not much apart from some basic practices
16:43:39 <totallynotnate> i take it you're pretty active around here?
16:44:15 <todaysTomorrow> if you want to know more about me please pm me
16:45:21 <totallynotnate> oh not really i was just asking if you're always around in this channel
16:45:24 <todaysTomorrow> I just got here after a long break
16:45:45 <todaysTomorrow> I'm a retired computer hacker
16:46:46 <todaysTomorrow> totallynotnate what projects are you doing right now?
16:47:14 <totallynotnate> not many, i'm a student and i haven't done much with haskell
16:47:28 <totallynotnate> i gotta go now cya!
16:47:37 <todaysTomorrow> Hello nbloomf what projects are you working on
16:48:12 <javran> @hoogle MonadError e m => e -> Maybe a -> m a
16:48:13 <lambdabot> Data.Either.Utils maybeToEither :: MonadError e m => e -> Maybe a -> m a
16:48:13 <lambdabot> Protolude note :: MonadError e m => e -> Maybe a -> m a
16:48:13 <lambdabot> Protolude.Exceptions note :: MonadError e m => e -> Maybe a -> m a
16:48:58 <javran> is there a function directly from Maybe to Except? I know I can do it with maybeToEither and liftEither, it's too verbose to my liking.
16:49:19 <javran> :t liftEither
16:49:21 <lambdabot> MonadError e m => Either e a -> m a
16:49:33 <todaysTomorrow> javran you sound like you are punding
16:49:44 <todaysTomorrow> why do verbosity matter?
16:50:08 <javran> when you want to do lots of Maybes inside a ExceptT
16:50:50 <todaysTomorrow> oh I see, could you teach me what ExceptT is? I haven't worked with it. Maybe then I can help you
16:51:22 <javran> it's just Either in disguist
16:51:34 <javran> http://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-Except.html
16:51:58 <todaysTomorrow> I don't remember ever using Either in my life but I have probably used it extensively before suffering from brain damage
16:52:16 <todaysTomorrow> reading your link now
16:53:25 <todaysTomorrow> "Please do not confuse ExceptT and throwError with Exception / SomeException and catch, respectively. The latter are for exceptions built into GHC, by default, and are mostly used from within the IO monad. They do not interact with the "exceptions" in this package at all. This package allows you to define a new kind of exception control mechanism
16:53:25 <todaysTomorrow> which does not necessarily need your code to be placed in the IO monad."
16:53:31 <todaysTomorrow> from javran's link
16:57:03 <javran> I'm basically just enhancing a Maybe with a bit more error message for debugging. so instead of do { a <- actionA; b <- actionB; ... }, I can do { a <- m2e "actionA failed bcs..."; b <- m2e "actionB failed bcs.."; ... }, where m2e stands for maybeToExcept
16:57:39 <javran> opss, `m2e "..." actionA` I meant
16:57:51 <todaysTomorrow> javran I have mostly used haskell as a crude alternative to octave I don't have much experience with the IO monad, would you like to teach me how to do IO in haskell with the IO monad?
16:58:17 <javran> um, ExceptT actually has nothing to do with IO
16:58:52 <todaysTomorrow> okay I see
16:59:00 <todaysTomorrow> could you give me real world examples?
16:59:12 <javran> for using ExceptT?
16:59:14 <todaysTomorrow> yes
16:59:19 <todaysTomorrow> I've never used it before
16:59:33 <koz_> todaysTomorrow: Do you understand the purpose monad transformers serve in general?
17:00:02 <xsperry> he asked this 2 minutes ago.. "would you like to teach me how to do IO in haskell with the IO monad?"
17:00:06 <xsperry> so I would guess, no
17:00:09 <todaysTomorrow> well that's actually a very complicated problem I suffer from brain damage and I may have used it in the past
17:00:20 <koz_> xsperry: I prefer to be clear.
17:00:33 <javran> I actually haven't been in this channel for a while so my lambdabot knowledge is rotten.
17:00:50 <xsperry> I can't imagine someone not knowing how to use IO monad but knowing the purpose of monad transformers
17:00:57 <todaysTomorrow> xsperry like many people I have been using the IO monad without knowing
17:01:12 <todaysTomorrow> xsperry for two reasons that doesn't apply to me
17:01:54 <todaysTomorrow> I suffer from brain damage I may suddenly remember the IO monad and monad transformers and be able to teach you a thing or two ;-)
17:03:54 <javran> well it's hard to come up with examples that can fit into a single line, let's see.. do you know Either?
17:04:49 <todaysTomorrow> I remember from a few years ago using it. Let's all pretend I don't know anything about it
17:05:34 <todaysTomorrow> how do I use hoogle?
17:06:19 <javran> @let notPositive x = if x <= 0 then Right x else Left "not positive"
17:06:21 <lambdabot>  Defined.
17:06:49 <javran> @let notNegative x = if x >= 0 then Right x else Left "not negative"
17:06:51 <lambdabot>  Defined.
17:06:59 <javran> > notPositive 1
17:07:03 <lambdabot>  Left "not positive"
17:07:08 <javran> > notPositive (-2)
17:07:10 <lambdabot>  Right (-2)
17:07:24 <todaysTomorrow> Oh yes! I remember using this. I made a tree with either a long time ago
17:07:41 <javran> just like that, it's Maybe but you can give a bit more information about what was wrong as Left
17:08:56 <todaysTomorrow> seems very useful for defining you're own data type
17:09:03 <javran> now say you want to put those two computations together to stop at first error and report what was wrong, that's Except
17:09:13 <todaysTomorrow> !
17:09:36 <javran> :t liftEither
17:09:38 <lambdabot> MonadError e m => Either e a -> m a
17:10:41 <javran> @let onlyZero x = liftEither (notPositive x) >>= (liftEither . notNegative)
17:10:43 <lambdabot>  Defined.
17:10:50 <javran> > onlyZero (-1)
17:10:52 <lambdabot>  error:
17:10:52 <lambdabot>      • Ambiguous type variable ‘m0’ arising from a use of ‘show_M877596031243...
17:10:52 <lambdabot>        prevents the constraint ‘(Show (m0 Integer))’ from being solved.
17:11:06 <javran> > onlyZero (-1) :: Except String Int
17:11:09 <lambdabot>  ExceptT (Identity (Left "not negative"))
17:11:17 <javran> > onlyZero 3 :: Except String Int
17:11:19 <lambdabot>  ExceptT (Identity (Left "not positive"))
17:11:26 <todaysTomorrow> "is there a function directly from Maybe to Except? I know I can do it with maybeToEither and liftEither, it's too verbose to my liking."
17:11:26 <javran> > onlyZero 0 :: Except String Int
17:11:28 <lambdabot>  ExceptT (Identity (Right 0))
17:12:29 <javran> if you totally ignore ExceptT and Identity, it's simple.
17:13:19 <javran> those are monad transformer machinery
17:14:00 <todaysTomorrow> http://book.realworldhaskell.org/read/monad-transformers.html
17:17:30 <todaysTomorrow> Excuse me, it seems like we're abdononing a problem that needs to be solved
17:18:11 <javran> like what
17:19:45 <javran> if you meant my original question, I ended up just defining my own m2e function, it just bothers me a bit that there isn't an utility function for doing exactly that with fewer typing.
17:20:40 <todaysTomorrow> Yes javran is your problem resolved?
17:21:41 <javran> technically it's already solved, I'm only wondering if there is a better way
17:22:14 <todaysTomorrow> How are you trying to influence the world?
17:24:02 <javran> oh actually, I'm wondering if I can just coerce that
17:24:59 <todaysTomorrow> I don't understand what you mean
17:25:58 <javran> well.. coercion is kinda advanced topic i guess
17:26:40 <todaysTomorrow> Want to know what I've been working on? javran?
17:26:54 <int-e> . o O ( unsafeBlackmail )
17:28:32 * javran was just wondering, if ExceptT is just newtype Either, that should allow me to do some safe coercion as they are representationally identical
17:30:56 <todaysTomorrow> I've been working on making a very specific form of programming using haskell elm seL4 emacs and coq to produce formally verified code
17:32:06 <MarcelineVQ> ExceptT e m a  is a newtype but not a newtype of Either, it's a newtype of   m (Either e a)
17:32:08 <todaysTomorrow> I'm more interested in writing a system for a team of programmers to use rather than actually creating an open source application
17:37:34 <javran> I did it, albeit it looks silly - at this point I'm just curious: e where
17:37:35 <javran> 3
17:37:40 <javran> https://gist.github.com/Javran/aef0895f58048e1234b883afc8623f32
17:38:14 <javran> MarcelineVQ: yes. But if the base is Identity, I think that's still doable
18:00:48 * hackage map-reduce-folds 0.1.0.5 - foldl wrappers for map-reduce  https://hackage.haskell.org/package/map-reduce-folds-0.1.0.5 (adamCS)
18:16:48 * hackage Frames-map-reduce 0.4.0.0 - Frames wrapper for map-reduce-folds and some extra folds helpers.  https://hackage.haskell.org/package/Frames-map-reduce-0.4.0.0 (adamCS)
18:51:19 * hackage tasty-mgolden 0.0.2 - Golden testing provider for tasty with muti-line diff output  https://hackage.haskell.org/package/tasty-mgolden-0.0.2 (mbj)
19:04:05 <p0a> hello in [(i,j) | i<-[1..3], j<-[1..3], i < j], am I guaranteed the order in which the tuples are ordered in the resulting list?
19:06:03 <ski> yes
19:06:44 <ski> > [(i,j) | i <- [1 .. 3],j <- [1 .. 3],i < j]
19:06:48 <lambdabot>  [(1,2),(1,3),(2,3)]
19:06:54 <ski> > [(i,j) | i <- [1 .. 3],j <- [1 .. j-1]]
19:06:56 <lambdabot>  *Exception: not an integer: j - 1
19:07:07 <ski> ah, right
19:07:16 <p0a> that's a typo 
19:07:18 <ski> > [(i,j) | i <- [1 .. 3],j <- [i+1 .. 3]]
19:07:20 <lambdabot>  [(1,2),(1,3),(2,3)]
19:07:34 <p0a> I see your point
19:07:36 <ski> > [(i,j) | i <- [1 .. j-1],j <- [1 .. 3]]
19:07:38 <lambdabot>  *Exception: not an integer: j - 1
19:07:59 <ski> hmpf, that error comes from another `j' that is in scope
19:08:06 <ski> > let j = () in [(i,j) | i <- [1 .. j-1],j <- [1 .. 3]]
19:08:08 <lambdabot>  error:
19:08:08 <lambdabot>      • Could not deduce (Num ()) arising from the literal ‘1’
19:08:08 <lambdabot>        from the context: (Num b, Enum b)
19:08:41 <ski> anyway, the `j' from `j <- [1 .. 3]' is not in scope in `i <- [1 .. j-1]', so you can't use `j' there
19:09:10 <p0a> yeah 
19:09:23 <ski> but the `i' from `i <- [1 .. 3]' is in scope in the `j <- [1 .. 3],i < j' part (and the initial `(i,j)') part, so you could replace that generator part by `j <- [i+1 .. 3]'
19:10:13 <ski> and the order you get for `[(i,j) | i <- [1 .. 3],j <- [1 .. 3]]' is still the same order. `i' is the "outer loop", `j' is the "inner loop" (whose bounds are allowed to depend on the index `i' of the outer loop)
19:11:06 <ski> or, if you think of this in terms of enumerating cells in a matrix, then `i' is row index, `j' is column index. and different rows are allowed to have different lengths
19:11:21 <p0a> yeah, right 
19:11:46 <ski> > [[(i,j) | j <- [i+1 .. 3]] | i <- [1 .. 3]]
19:11:48 <lambdabot>  [[(1,2),(1,3)],[(2,3)],[]]
19:11:54 <ski> > concat [[(i,j) | j <- [i+1 .. 3]] | i <- [1 .. 3]]
19:11:56 <lambdabot>  [(1,2),(1,3),(2,3)]
19:12:16 <ski> @undo [(i,j) | i <- [1 .. 3],j <- [i+1 .. 3]]
19:12:16 <lambdabot> concatMap (\ i -> concatMap (\ j -> [(i, j)]) [i + 1 .. 3]) [1 .. 3]
19:12:20 <p0a> So that's an implementation I guess, eh
19:12:24 <ski> @undo [(i,j) | i <- [1 .. 3],j <- [i .. 3],i < j]
19:12:25 <lambdabot> concatMap (\ i -> concatMap (\ j -> if i < j then [(i, j)] else []) [i .. 3]) [1 .. 3]
19:12:44 <p0a> okay makes sense 
19:13:46 <ski> the `[[(i,j) | j <- [i+1 .. 3]] | i <- [1 .. 3]]' shows what to do, if you wanted a list of lists (each being a row, in the above image), rather than a single list with all pairs in it (the result of `concat' on the list of lists)
19:15:03 <p0a> sure 
19:15:23 <p0a> well that's not what I want, but I see how that is superior in the sense that concatMap gives you the other one
19:15:43 <p0a> it's a forgetful functor!
19:15:46 * p0a runs
19:15:51 <ski> hm
19:16:21 <ski> anyway, earlier generators in a list comprehension vary more slowly than later generators
19:16:46 <p0a> right
19:18:03 <p0a> thank you! 
19:18:22 <p0a> One more question, it seems that variable name clashes can happen often in Haskell right?
19:18:34 <p0a> Unless everything is qualified, if an import changes in the future, it may clash
19:19:40 <monochrom> You can use explicit imports "import M(a, b, c)" to limit it.
19:20:34 <p0a> That's a good point, thank you 
19:22:20 <ski> p0a : if there's an ambiguity, it'll tell you, so you can qualify the name by the module name (or alias) that you imported the identifier from
19:24:52 <ski> (if the ambiguity is between an imported identifier, and an identifier defined at top-level in the current module, then if you import the identifier qualified, then the plain (unqualified) identifier will refer to the one defined in the current module. and i suppose you don't even need to import qualified, if the identifier is locally bound)
19:49:30 <p0a> For example I am trying to use `sum' 
19:49:45 <p0a> but it is defined in Numeric.Matrix. But that is a hidden module? 
19:50:18 * hackage mtsl 0.1.0.0 - Reified monad transformer stacks  https://hackage.haskell.org/package/mtsl-0.1.0.0 (sgschlesinger)
19:50:45 <p0a> How do I see where sum is also defined? I don't think I want either of the suggestions (one is Data.Complex and the other is GHC.Num)
19:50:55 <p0a> and of course the one I mentioned
19:51:29 <p0a> The line I have is `trace = sum . toList . takeDiag', which is supposed to give me the trace of a matrix
19:52:43 <p0a> Huh, I guess the pointfree style was confusing GHC, (or rather, confusing me). I changed it and now it works fine 
19:53:07 <p0a> Not sure why `f x = g x' and `f = g' would be so different 
20:32:48 * hackage metro 0.1.0.3 - A simple tcp and udp socket server framework  https://hackage.haskell.org/package/metro-0.1.0.3 (Lupino)
20:35:12 <orzo> I'm debuging a space leak and -hy shows me BLACKHOLE is a big cost.  I have no threads in this application.  What does this mean?
20:44:43 <hololeap> does it sound like p0a ran into the monomorphism restriction?
21:07:24 <BalterNotz> hi
21:09:55 <justsomeguy> I have a stupid theoretical question: Are data types (such as sum types and their related functions) finite state machines? (I got the idea from here... http://raganwald.com/2018/02/23/forde.html)
21:11:02 <justsomeguy> (For context, I'm new to strongly typed programming; Currently reading haskellbook; and entertaining myself tonight by pondering what a type is exactly and drinking beer.)
21:12:51 <justsomeguy> What would you say a type is?
21:13:33 <fraktor> What is a type? A miserable little pile of data.
21:14:19 * hackage errata 0.2.0.0 - Source code error pretty printing  https://hackage.haskell.org/package/errata-0.2.0.0 (comp)
21:14:49 <fraktor> I don't quite understand how a type is a finite state machine. It certainly has "finite states" (although the types associated with those states can be infinite, as in a String), but there aren't really transitions.
21:15:43 <fraktor> I see now that you included "related functions" in your definition, and I would say in FP-land, those aren't really "part" of the type.  The particular pairing of data and behavior like that is more OO IMO.
21:16:13 <justsomeguy> I guess that in my view functions that act on a data type are part of the type. In that case, the functions describe permissible state transitions. 
21:16:38 <justsomeguy> ...but only conceptually.
21:18:57 <justsomeguy> Which is pretty much what you just said, but I'd pressed enter just as your comment appeared. Otherwise I'd have left that unsaid.
21:19:34 * justsomeguy is a kind of a slow typist
21:21:53 <fraktor> Nah you're good :)
21:22:26 <fraktor> I would say that using types and associated functions to build state machines is perfectly correct, but those functions are not part of the type.
21:22:46 <justsomeguy> That sounds reasonable.
21:22:53 <dsal> A type is more like a set of possible values.  A sum type adds to of those sets together.  A product type multiplies them together.  Probably something about burritos as well.
21:22:57 <dolio> How is `data Peano = Zero | Suc Peano` a finite state machine?
21:23:39 <dsal> s/to of// -- not sure what happened there.
21:26:06 <justsomeguy> I suppose that would be an infinite type!
21:26:18 <dolio> It has infinite things in it, yeah.
21:26:41 <justsomeguy> I haven't yet figured out how to calculate the carnality of types, yet.
21:27:07 <justsomeguy> :g/ yet /d
21:27:17 <dolio> Infinitely many, even. Even in languages where the values themselves aren't infinite.
21:28:17 <solonarv> it is actually fairly simple
21:28:46 <solonarv> '|' becomes '+', constructors with multiple fields become products
21:29:26 <solonarv> e.g. 'data Foo = X Int Bool | Y Word8' becomes 'Foo = Int * Bool + Word8'
21:30:01 <solonarv> substituting in the numbers for those: 'Foo = 2^64 * 2 + 2^8', and the rest is arithmetic
21:30:21 <dsal> justsomeguy: Well, you can calculate cardinality of types at some point, but a product type of two lists is ∞*∞ whereas a sum type of two lists is just ∞+∞
21:30:37 <justsomeguy> If you have a type like “Peano = Zero | Suc Peano”, is the carnality (1 * infinity) + 1?
21:30:57 <dolio> Infinite cardinalities get kind of ill behaved in constructive settings, though.
21:31:58 <dsal> Yeah.  A more practical way to think of it is, e.g. what `Maybe t` does to `t`.  It increases the cardinality by 1.  Whereas you had all of the values of `t` before, now you have the same values + `Nothing`
21:33:49 <dsal> `Either a b` can contain any value of type `b` or any value of type `a`, so the total number of values it can contain is the sum of the cardinality of those two.
21:34:27 <dsal> A product type `t` like `t a b` can contain a value of `b` for every value of `a`
21:37:34 <justsomeguy> Oh man, this beer is so good. Blueberry maple stout -- it's like I'm drinking a blueberry pancake.
21:38:00 <justsomeguy> Agh, that sounds awful, lol.
22:12:06 <koz_> Something something I wrote a whole library for calculating the cardinality of finitary types.
22:14:02 <solonarv> justsomeguy: for a recursive type, you end up with an equation like Peano = 1 + Peano; solve it and the solution is indeed Peano = ∞
22:14:45 <justsomeguy> Interesting!
22:14:50 <koz_> solonarv: Yay for the weird and wonderful world of infinity, where ordinars and cardinals no longer line up.
22:16:39 <justsomeguy> (One question I've had is: If you have a set of 0..-Inf and a set of 1..+inf, is the superset of both of them larger than either of the member sets?)
22:16:50 <koz_> justsomeguy: What do you mean by 'larger'?
22:17:09 <justsomeguy> ...huh, I don't know. I guess the cardinality of the set.
22:17:22 <solonarv> in that case they are the same size, because there is a bijection between them
22:17:33 <koz_> Yep, that's exactly right.
22:17:51 <koz_> The only notion of 'size' sets admit is bijection.
22:18:16 <justsomeguy> Is a bijection a one-to-one correspondence?
22:18:18 <koz_> So therefore, a set which can be bijected with N (i.e. the natural numbers) has the same cardinality as any other such set.
22:18:20 <koz_> justsomeguy: Yep.
22:18:20 <solonarv> yes
22:18:30 <koz_> More precisely, a function that is both one-to-one and onto.
22:18:39 <koz_> (or 'injective and surjective' if you prefer)
22:18:41 <solonarv> if the sets have additional structure (such as an ordering) then you can talk about more fine-grained size distinctions
22:18:51 <solonarv> this is the difference between cardinals and ordinals, sort of
22:18:57 <koz_> solonarv: Technically _all_ sets have an ordering.
22:19:03 <koz_> (thanks, well-ordering theorem!)
22:19:24 <solonarv> right but you have to pick one and that affects which other ordered sets they're the same size as
22:19:43 <koz_> Yeah, then sure. That's where ordinals come in.
22:20:01 <koz_> Because while omega + 1 and omega + 2 have the same cardinality, they're different ordinals.
22:20:05 <koz_> Because infinity is weird.
22:21:52 <koz_> (I also love that technically, due to AC, all sets are well-ordered, but the ordering is not specified)
22:22:02 <koz_> (since we can only assert that it exists, not what it is)
22:22:08 <koz_> (thanks, non-constructive axioms...)
22:26:33 <dolio> Ordering isn't size, though.
22:27:58 <dolio> Like, when you consider the additional structure, it isn't affecting the size.
22:30:40 <petersen> dminuoso: right but somehow it is giving me a CPP error
22:36:35 <nshepperd> solonarv: what's an example of a notion of size that depends on ordering?
22:37:20 <solonarv> "which ordinal is this this order-isomorphic to?"
22:38:00 <solonarv> the ordinals are ordered (obviously), so this gives you a notion of size that is more fine-grained than cardinality
22:38:01 <nshepperd> is that like defining 'same size' = 'there exists a order preserving bijection'? 
22:38:09 <solonarv> hm, yes, I think so
22:39:39 <nshepperd> interesting
22:40:04 <solonarv> this is "finer-grained" in that if two ordered sets are the same size by this definition, then they are also the same size if you forget the ordering and look for any bijection
22:41:38 <nshepperd> so like the rational numbers are bigger than the natural numbers in that sense, because any two rational numbers has one between them
22:41:58 <nshepperd> the rational numebrs with the standard ordering that is
22:42:07 <dolio> The usual ordering on the rationals isn't a well-order.
22:42:51 <nshepperd> does it have to be a well order
22:43:03 <dolio> If you want it to be an ordinal.
22:44:24 <dolio> I mean, I don't think the ordinal ordering is usually considered to be "size" either. That is reserved for cardinality.
22:47:19 * hackage unboxing-vector 0.2.0.0 - A newtype-friendly variant of unboxed vectors  https://hackage.haskell.org/package/unboxing-vector-0.2.0.0 (aratamizuki)
22:49:39 <dolio> Anyhow, using the naturals or the rationals doesn't really change the ordinals you can can define, which is the point of cardinality, I guess.
22:50:08 <dolio> You can put the same well-orders on either one.
23:01:05 <nshepperd> https://en.wikipedia.org/wiki/Order_type seems to be the thing
