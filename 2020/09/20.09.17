00:02:48 <edwardk> :t universe
00:02:50 <lambdabot> Plated a => a -> [a]
00:02:55 <edwardk> er that's not it
00:03:52 <edwardk> :t contexts
00:03:54 <lambdabot> Plated a => a -> [Context a a a]
00:04:09 <edwardk> :t contextsOf
00:04:10 <lambdabot> ATraversal' a a -> a -> [Context a a a]
00:04:23 <edwardk> that gives you each of the 'one hole contexts' of a term
00:05:15 <edwardk> you give a traversal that knows how to find all the parts, and it give you back a context which has what was in that position and a function that can sew the type back up around a new value.
00:05:31 <edwardk> contexts works off the Plated data type
00:06:01 <edwardk> a context is a "lens that has been applied to an 's'"
00:06:17 <gnumonik> That should work, thanks!
00:06:36 <edwardk> if you think of a lens as s -> (a, b -> t)    Context a b t = (a, b -> t)
00:06:58 <edwardk> with some newtype and typical lens over-generality applied
00:07:08 <edwardk> :info Context
00:07:20 <edwardk> @info Context
00:07:20 <lambdabot> Context
00:07:26 <edwardk> that was helpful.
00:07:29 <edwardk> @type Context
00:07:30 <lambdabot> (b -> t) -> a -> Context a b t
00:23:39 <kenran> Is there a specific reason why Data.Vector.Storable.Vector doesn't have "the usual" instances? I'm specifically wondering about Foldable.
00:27:35 <Axman6> because you can't put a constraint on the types of the values stored in it to guarantee they are sStorablwe
00:27:40 <Axman6> Storable*
00:27:52 <dminuoso> % :t foldr
00:27:53 <yahb> dminuoso: Foldable t => (a -> b -> b) -> b -> t a -> b
00:28:02 <dminuoso> kenran: ^- See how b is unconstrained?
00:28:29 <nshepperd> it's the lack of constraint on 'a' that is the problem here 
00:28:40 <dminuoso> Oh
00:29:10 <dminuoso> nshepperd: Why does that matter?
00:30:56 <dminuoso> Ah nevermind, heh.
00:31:05 <nshepperd> because where t ~ Storable.Vector you can't get the 'a's out of that 't a' without having the Storable a instance at hand
00:31:18 <dminuoso> nshepperd: I kept thinking of Functor for some bizarre reason.
00:31:37 <dminuoso> In which case it'd be both a and b that'd need the Storable constraint
00:33:04 <kenran> ah thanks. I can't try it out right now, but couldn't one have: instance Storable a => Foldable (Storable.Vector a)?
00:33:54 <dminuoso> kenran: Correct.
00:34:03 <dminuoso> Multiple reasons
00:34:08 <dminuoso> a) Wont kind check
00:34:11 <dminuoso> % :k Foldable
00:34:11 <yahb> dminuoso: (* -> *) -> Constraint
00:34:34 <dminuoso> b) The constraint would have to on the class method (something like quantified constraints would be needed)
00:35:10 <dminuoso> And in addition c) *instance selection* does not consider any constraint on the instance declaration.
00:35:36 <kenran> ahh of course, I forgot that one doesn't do `instance Foldable (Foo a)` but `instance Foldable Foo)
00:35:48 <kenran> thanks, very interesting!
00:35:50 <nshepperd> i don't think b and c are really problems
00:39:01 <nshepperd> yeah Foldable is meant to be applied to the, uh, generic container type
00:39:44 <Unhammer> https://i.imgur.com/kyFW9B9.png duckduckgo found me an actual stack of haddocks =D
00:41:31 <dminuoso> Unhammer: It wasnt until I visited scotland and england that I understood the reference. The brits do seem to eat a lot of haddock.
00:43:32 <Unhammer> well, it's yummy :) though I've never had it stacked before
00:43:42 <Unhammer> `alias stack=smoke`
00:43:46 <Unhammer> therewego
00:44:31 <dminuoso> Oh haha I didn't get the joke until you mentioned that.
00:44:39 <dminuoso> Cheeky
00:46:28 <nshepperd> There's a different type class called MonoFoldable that you could give instances for Storable a => MonoFoldable (Vector a)
00:47:11 <nshepperd> but defining MonoFoldable and using it requires extensions (type families) and is less convenient, so i don't think it's really commonly used
01:08:56 <dminuoso> Is there a reason to use `cabal v2-test` over `cabal v2-run test:foo`?
01:09:12 <dminuoso> The latter seems universally powerful since you can pass arguments to the testsuite
01:09:26 <phadej> former runs multiple tests, changes to package directory, ...
01:09:28 <phadej> is a bit different
01:10:44 <dminuoso> Mmm, what kind of changes to the package directory?
01:10:56 <dminuoso> Oh, you mean like the cwd?
01:14:11 <dminuoso> But I see what you mean, it is different. In case of hspec, v2-run can detect the interactive terminal properly, with v2-test it seems not
01:34:58 <kuribas> How do you solve the problem of having different types for a resource in a rest API?  I came up with this solution: data Person read update extra = Person { age :: read Int , name :: update String, job :: extra String}
01:36:37 <kuribas> then type family Id where Id a = a; type family Null where Null a = Maybe Void
01:37:43 <kuribas> Then I can do type ReadPerson = Person Id Id Id
01:38:02 <kuribas> and type UpdatePerson = Person Null Id Null
01:40:37 <kuribas> or the alternative is just to define three types ReadPerson, UpdatePerson, ShortReadPerson
01:41:06 <kuribas> which uses simpler haskell, but doesn't ensure the consistency of the resource.
01:43:11 <bahamas> I'm working on making a haskell quick reference and I'm reading through the haskell report. one thing confuses me. in what way are variables and constructors expressions? https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-240003.2
01:43:28 <bahamas> is it the fact that identifiers are expressions because they "return" a value?
01:43:48 <kuribas> bahamas: haskell doesn't have the concept of return
01:44:11 <kuribas> bahamas: variables are expressions in other language as while
01:44:18 <kuribas> and Constructors in haskell or just functions
01:44:21 <kuribas> :t Just
01:44:22 <lambdabot> a -> Maybe a
01:44:59 <kuribas> s/as while/as well
01:45:04 <bahamas> kuribas: I know
01:45:16 <kuribas> then what's the confusion
01:45:19 <kuribas> ?
01:46:53 <bahamas> kuribas: well, how would you define an expression? my intuition tells me that an expression gives you a value. intuitively, function application is an expression, because the function returns a value
01:47:03 <bahamas> however, in what way is a variable an expression?
01:47:25 <kuribas> a variable gives you a value as well
01:47:39 <kuribas> > let x = 1 in x
01:47:39 <[exa]> bahamas: "represents" a value is better naming here I guess.
01:47:41 <lambdabot>  1
01:47:45 <lortabac> kuribas: alternatively, you can define three different types with the same field names and use GHC.Records.HasField or lenses to regain the ability to define generic operations over the 3 types
01:47:54 <bahamas> and a constructor? a constructor, not a constructor application
01:48:12 <[exa]> bahamas: Nothing is a value right?
01:48:18 <kuribas> bahamas: a constructor is a function
01:48:28 <bahamas> and a function is a value
01:48:44 <bahamas> what is wrong with saying that identifiers are expressions?
01:48:54 <[exa]> nothing? :]
01:49:04 <kuribas> an identifier is a syntactic construct
01:49:18 <kuribas> it depends on the context if it's a value
01:51:12 <lortabac> kuribas: in my experience having different types is in most cases less annoying than dealing with the type families
01:51:35 <kuribas> lortabac: yeah, I guess you're right
01:51:37 <bahamas> kuribas: ok. I think I know what you mean.
01:52:07 <kuribas> lortabac: I find duplicateRecordFields and recordWildcards quite handy :)
01:53:34 <kuribas> "let x = 2", the x is not an expression here, it's a variable binding.
01:53:35 <dminuoso> bahamas: There's two connected notions of an expression: a) something that can be evaluated b) a grammatical production rule - the latter gives you all syntactical trees of evaluatable fragments
01:55:11 <bahamas> dminuoso: can you give an example of the second?
01:55:49 * hackage postgresql-binary 0.12.3.1 - Encoders and decoders for the PostgreSQL's binary format  https://hackage.haskell.org/package/postgresql-binary-0.12.3.1 (NikitaVolkov)
01:56:01 <kuribas> bahamas: also you are asking how to define an expression, but that page defines an expression exactly :)  I guess you don't want a definition, but an intuition
01:56:30 <dminuoso> bahamas: exp -> infixexp :: [context =>] type | infixexp
01:56:41 <dminuoso> Is the topmost production rule for an expression in Haskell
01:56:49 * hackage wai-extra 3.0.30 - Provides some basic WAI handlers and middleware.  https://hackage.haskell.org/package/wai-extra-3.0.30 (MichaelSnoyman)
01:57:40 <dminuoso> If you follow this down a bit, you'll end up with a production rule `aexp -> qvar | gcon | literal | ( exp ) | ...`
01:59:51 <dminuoso> Roughly, you can think of Haskell evaluation as being a graph reduction machine on a haskell expression graph/tree.
02:00:35 <dminuoso> (Taking expressions to expressions)
02:12:42 <kuribas> how would you ensure a lazy language is total?
02:13:47 <kuribas> :t fix
02:13:49 <lambdabot> (a -> a) -> a
02:14:40 <phadej> fix isn't something you have to add to a language
02:14:42 <kuribas> is there a fix-like function that doesn't diverge?
02:14:44 <Lycurgus> by disregarding laziness as nothing more than a lang feature?
02:14:58 <bahamas> dminuoso: does that mean that an expression's type signature is also an expression?
02:15:10 <dminuoso> bahamas: There's an easy test:
02:15:15 <dminuoso> bahamas: Go through the production rules
02:15:31 <kuribas> bahamas: you can consider it a "type level expression"
02:15:51 <kuribas> bahamas: however it isn't a value, it's a type.
02:15:56 <dminuoso> bahamas: You'd need something like `aexp -> type | ...`
02:16:02 <dminuoso> (or possibly not aexp, but you get the idea)
02:16:17 <dminuoso> If such a production does not exist, then formally, a type is not an expression.
02:16:35 <dminuoso> However, you can see it can be *part* of expressions, namely by the production rule:
02:16:38 <dminuoso> exp -> infixexp :: [context =>] type 
02:16:55 <kuribas> Lycurgus: recursion can be total by ensuring the recursive step is smaller.  But can you do the same with lazyness?
02:17:37 <kuribas> Lycurgus: perhaps if the return of (a -> a) is smaller than the input?
02:18:56 <kuribas> hmm, no because x = tail x still diverges...
02:20:38 <bahamas> dminuoso: ok. all that recursion and the use of the name "infixexp" is confusing me a bit, but if I'm unpacking those terms, it's slowly falling into place
02:20:41 <bahamas> thanks
02:20:59 <Lycurgus> is laziness modeled as part of the active semantics of haskell? that's why I said what I did, that laziness is is between a compiler feature and the execution semantics
02:21:07 <dminuoso> bahamas: Read a production `foo -> bar` as "to make a foo, use bar"
02:21:19 <dminuoso> (It's why they are called production rules, they tell you how to *produce* the left hand side)
02:21:23 <kuribas> Lycurgus: yes it is
02:21:25 <Lycurgus> an if you only consider the latter then laziness can be disregarded
02:22:02 <kuribas> Lycurgus: because bottom is part of the semantics, and lazyness changes the result when bottom is present.
02:22:12 <Lycurgus> which is sort of cognitively consistent with a lang with the hubris or what ever to have ct as a model of computation
02:22:16 <dminuoso> bahamas: And they are exhaustive. So if there's no production rule for some `f -> g`, then g does not make an f
02:23:03 <kuribas> > foldr const 1 (1:undefined)
02:23:06 <lambdabot>  1
02:23:18 <kuribas> Lycurgus: that would be bottom in a strict language
02:23:28 <kuribas> Lycurgus: haskell ensures it's 1
02:23:48 <Lycurgus> well i gave an easy and gordian way
02:24:02 <Lycurgus> i suppose that's not the hs way tho
02:25:06 <lortabac> kuribas: Agda is an example of a lazy total language
02:25:36 <lortabac> maybe you can find some answers in the author's Phd thesis
02:28:14 <Taneb> I'm not sure the question is well defined: "lazy" is normally defined as there exist some functions such that f _|_ /= _|_. In a total language, there is no _|_  so we can't decide if the language is lazy or not
02:29:24 <lortabac> Taneb: you can still talk about the order of evaluation and sharing, can't you?
02:29:58 <someuser123> is there a conventional name for a function `m a -> a` where `m` is a monad?
02:30:42 <dminuoso> someuser123: Cokleisli Arrow
02:30:48 <dminuoso> fsvo of "conventional"
02:30:50 <merijn> someuser123: "nonexistent" :)
02:33:47 <dminuoso> Oh wait, heh. Well that only works if m was a comonad. :)
02:34:37 <maerwald> quiz question: what does `LimitTo` in persistent do if you pass 0?
02:34:38 <dminuoso> someuser123: Do you mean `m` as some *particular* monad, or just any monad?
02:36:05 <someuser123>  I'm thinking of a monad like Maybe that is used to capture computation which can fail
02:36:45 <edwardk> lortabac: laziness in a total language is the differents between 'terminates' and 'terminates in my lifetime'
02:37:16 <kuribas> someuser123: Maybe has fromJust which you shouldn't use
02:37:38 <kuribas> someuser123: use fromMaybe instead
02:37:48 <someuser123> kuribas: why not?
02:38:07 <merijn> someuser123: Because it's bad and broken and you will regret it :p
02:38:09 <kuribas> someuser123: because it will crash on Nothing
02:38:11 <maerwald> someuser123: it's fine to use in local context or where you don't mind something to crash
02:38:41 <merijn> maerwald: What local context is it fine in?
02:38:56 <maerwald> merijn: where you have local proof that it's never Nothing
02:38:59 <kuribas> it's never fine to crash without meaningful error message
02:39:02 <kuribas> or stack trace
02:39:13 <lortabac> edwardk: can you expand? I'm not sure I understand
02:39:30 <merijn> maerwald: I don't see many case where you have both such a proof and still can't skip the maybe
02:40:05 <edwardk> termination checking in a fancy total language might take until the sun explodes. its pretty easy to build tings that theoretically terminate, but won't terminate in my lifetime.
02:40:36 <edwardk> laziness lets you skip some of the evaluation of parts, so while sure those parts will terminate eventually, it might be nice to not do that work at all
02:40:49 <maerwald> merijn: I'm not sure I follow.
02:42:07 <merijn> maerwald: I can't really think of any case where I have a proof that it's not Nothing where I can't simple skip going through Maybe (and thus fromJust)
02:42:08 <maerwald> if you have a regex building function that might return Nothing, but there is no user input and you've verified it compiles at runtime, there's no point going through hoops just to satisfy the totality illusion
02:42:36 <merijn> maerwald: Then you want
02:42:41 <merijn> @hackage validated-literals ;)
02:42:42 <lambdabot> https://hackage.haskell.org/package/validated-literals ;)
02:42:49 <maerwald> I'm aware of that, this was an example
02:42:53 <lortabac> edwardk: ok I see, thanks
02:43:25 <edwardk> as an example, when writing a dependent type checker itself, i wind up having to eval terms to normal form. but those terms often carry around things like unerased type info. _eval_ doesn't care, but maybe they might appear in the final normal form
02:43:44 <edwardk> but i should lazily skip past crunching those things down in case i don't need to compute those answers
02:44:10 <edwardk> sure it'd terminate but it'd bloat the memory footprint of the proof process and significantly slow it down
02:44:20 <kuribas> maerwald: if you have many regexes, change one of those then you don't know which one blew up.
02:44:52 <maerwald> then don't use it
02:45:05 <kuribas> maerwald: and if you know which one blew, it doesn't say what's wrong with it.
02:46:48 <Unhammer> Upgraded from 8.6.5 to 8.8.4, project compile time went from 3m to 2m30s, compile after changing single (TH) file from 30s to 24s :-) and the windows binary size went from 53MB to 43MB. That's pretty nice :-) 
02:47:37 <merijn> Unhammer: You can probably drastically shrink further
02:47:47 <merijn> Unhammer: Enable split-sections
02:47:56 <maerwald> does windows support split-sections?
02:48:02 <Unhammer> on windows?
02:48:07 <merijn> hmm, not sure?
02:48:12 <merijn> Only one way to find out :p
02:48:23 <merijn> Unhammer: Also, don't forget to strip
02:48:47 <Unhammer> I think stack does that for me
02:48:50 <Unhammer> on stack install
02:49:18 <Unhammer> yeah, the one in "dist" is 64M, and the one in "install" doesn't get smaller when stripping
02:49:26 <merijn> hmmm
02:50:50 * hackage Z-Data 0.1.1.0 - array, vector and text  https://hackage.haskell.org/package/Z-Data-0.1.1.0 (winterland)
02:51:07 <Unhammer> oh I need to rebuild all deps to try split-sections … guess I'll wait, need to do some actual work instead of faffing around with compiler versions =P
02:51:46 <merijn> Unhammer: Yeah, you do
02:51:56 <merijn> Unhammer: It makes *massive* difference, though
02:52:29 <merijn> Unhammer: Like, 10x on my executables
02:54:39 <kuribas> merijn: why doesn't it do this by default?
02:55:45 <merijn> kuribas: Because it's fairly new, doesn't work on all platforms, etc.
02:55:49 <Unhammer> https://gitlab.haskell.org/ghc/ghc/-/issues/11445 
02:56:10 <merijn> hmm, older than I thought :p
02:56:36 <Unhammer> does it work to put it in global stack.yaml ?
02:56:57 <phadej> merijn: IIRC it was broken / not working somewhere somewhat
02:57:24 <merijn> It doesn't work on macOS
02:57:32 <maerwald> merijn: you don't need it there
02:57:45 <merijn> maerwald: I know, but GHC error exited when you specified it
02:57:51 <maerwald> yep
02:57:54 <merijn> (now fixed after I whined about it)
02:58:07 <merijn> Now it's just a warning on macOS
02:59:03 <phadej> a problem is that GHC doesn't tell whether it's supported
02:59:15 <phadej> there is ("Object splitting supported","YES") entry, which is about -split-objs
02:59:19 <phadej> but not for -split-sections
03:00:07 <phadej> GHC is not very uniform in how it exposes features
03:00:26 <phadej> (to allow auto-configuration, vs. hardcoding stuff about particular compiler versions into Cabal)
03:01:44 <phadej> an example
03:01:45 <phadej> it tells
03:01:46 <phadej>  ,("unlit command","/opt/ghc/8.10.1/lib/ghc-8.10.1/bin/unlit")
03:01:51 <phadej> but doesn't tell e.g. `ghc-pkg command`
03:01:59 <phadej> so Cabal have to use heuristics to find one
03:02:21 <phadej> (where I have no idea what's use case to knowing where is unlit command :P)
03:02:40 <merijn> phadej: Sounds like we need a ticket about all missing things there and add them to GHC
03:03:24 <phadej> merijn: one needs a pedantic person looking after that
03:03:53 <phadej> new features need to get to that list when they introduced, not 2-3 releases after
03:05:27 <merijn> kuribas: The short answer to why it's not the default is: Insufficient people baby sitting these sorts of tickets/fixes, tracking whether they work everywhere and flipping the switch
03:05:49 <kuribas> merijn: the flipside of avoiding success.
03:09:01 <maerwald> pedantic person? Someone called my name?
03:09:28 <merijn> maerwald: Please do :p
03:10:25 <someuser123> where can I see the precedence ranks of operators such as <*> and <$>?
03:10:43 <merijn> % :i (<$>)
03:10:44 <yahb> merijn: (<$>) :: Functor f => (a -> b) -> f a -> f b -- Defined in `Data.Functor'; infixl 4 <$>
03:10:54 <merijn> someuser123: The "infixl 4" is precedence
03:10:58 <merijn> % :i (<*>)
03:10:58 <yahb> merijn: type Applicative :: (* -> *) -> Constraint; class Functor f => Applicative f where; ...; (<*>) :: f (a -> b) -> f a -> f b; ...; -- Defined in `GHC.Base'; infixl 4 <*>
03:11:07 <merijn> So, precedence level 4, left associative
03:12:01 <someuser123> thanks
03:15:19 <adauguet> Hi everyone, is this the right place to ask beginners questions about haskell?
03:15:21 <dminuoso> Unhammer: I have added `split-sections: true` to my ~/.cabal/config and made profits ever since! :)
03:15:25 <dminuoso> adauguet: Yes.
03:15:46 <dminuoso> adauguet: You can also use #haskell-beginners if you want a more quiet/less chatty place, but we dont mind the most naive beginner questions either.
03:16:23 <adauguet> thanks, i will try on #haskell-beginners then
03:32:44 <perdent> Anyone here want to be hired to code a 'hacking' CTF challenge for money? If so PM me for further details
03:33:50 <Raito_Bezarius> perdent: what's the relation with Haskell?
03:34:49 <perdent> Raito_Bezarius: I want it to be coded in haskell
03:35:28 <perdent> Makes it more difficult for participants who are not used to functional programming
03:36:10 <[exa]> also a lot more difficult to actually C the F
03:53:32 <dminuoso> How can I extract the test-suite binary in v2-*?
04:14:22 <maerwald> dminuoso: same as any other
04:16:33 <dminuoso> Well until now it was just with `cp $(cabal v2-exec -- which foo) ..`
04:16:47 <dminuoso> So I guess you're proposing to just use cabal-plan?
04:17:55 <maerwald> I did that v2-exec with spec test as well I believe
04:19:06 <dminuoso> Ah, I did not realize the testsuite binaries are called after their testsuite name.
04:21:49 <WzC> does anyone know how to get a fully statically compiled executable using ghc these days? 
04:22:07 <maerwald> WzC: with alipne
04:22:23 <WzC> the internet claims 'ghc -static -optl-static -optl-pthread' should work, but that gives a bunch of errors 
04:22:32 <merijn> WzC: Depends on how extreme you wanna take "full static" :)
04:22:44 <maerwald> there's only full static or none at all 
04:23:16 <WzC> as in: everything (including dependent c-libs) included in the binary 
04:23:19 <merijn> WzC: Well, for one, on linux you're hosed because glibc can't be linked statically, so you need a linux (or toolchain, at least) that has a statically linkable libc
04:23:25 <maerwald> WzC: see https://github.com/actions/setup-haskell/issues/31#issuecomment-676001831
04:25:02 <WzC> hmm I'll have to read through that a bit 
04:26:36 <WzC> essentially I'm trying to set up ghc in domjudge, some system to compile student handins and test them. Somehow the system is running the compiled executables in some chroot, and hence the basic approach to avoid that would be to compile static binaries 
04:26:37 <dminuoso> WzC: If you're a nix user, there's a static haskell overlay.
04:26:45 <maerwald> which sometimes works
04:27:30 <maerwald> WzC: it's easy
04:27:31 <WzC> this is essentially what I now get with those options though: https://gist.github.com/noinia/a77769a70b833496501ffb6a6e64472f
04:33:49 * hackage niv 0.2.18 - Easy dependency management for Nix projects  https://hackage.haskell.org/package/niv-0.2.18 (nmattia)
04:36:43 <ALM49> Is it possible to qualify an infix operator?
04:37:06 <lortabac> yes
04:37:16 <opqdonut> > 1 Prelude.+ 2
04:37:19 <lambdabot>  3
04:37:23 <ALM49> ie. If I want to use `List.(++)` instead of having to `import Data.List (++)`
04:37:34 <dminuoso> ALM49: No, you have to explicitly add an import.
04:37:45 <opqdonut> but it could be a qualified import
04:37:59 <ALM49> Oh, so I just omit the parentheses?
04:38:08 <dminuoso> ALM49: Add additional parentheses.
04:38:24 <dminuoso> import Data.List ((++)), and if you want it qualified you can do `import qualified Data.List ((++))`
04:38:42 <dminuoso> And, then you can give an alias as well, like `import qualified Data.List as L ((++))`
04:40:52 <ALM49> oh, that's strange
04:41:02 <ALM49> So I'd write something like
04:41:06 <ALM49> `(List.++) "abc" "def"`
04:42:16 <ALM49> Why do I need the parens there? What could that conflict with?
04:43:35 <dminuoso> You're writing it in prefix position.
04:44:18 <dminuoso> You can write named functions in infix position by wrapping them in ``, and you can write operators in prefix position by wrapping them in parens
04:44:34 <dminuoso> The maybe confusing part is to realize that List.++ is an operator
04:44:36 <ALM49> Wow, it never occured to me that I could use a qualified operator in infix position
04:44:43 <dminuoso> Well, it *is* and remains an operator. ;)
04:45:24 <ALM49> Well, coming from OCaml, operators are basically just identifiers
04:45:52 <ALM49> I didn't realise that Haskell has a distinction between them
04:50:14 <dminuoso> ALM49: There's even more going on. We have a 2x2 matrix of [["Variable identifier", "Constructor identifier"], ["Operator identifier", "Operator constructor"]]
04:50:39 <dminuoso> A common example of operator constructors is (:) from list. :)
04:51:17 <dminuoso> https://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-180002.4 contains a very readable and concise definition
04:58:43 <ALM49> thanks dminuoso
05:03:47 <ski> kuribas : "perhaps if the return of (a -> a) is smaller than the input?" -- how about if it's larger ?
05:03:59 <ski> kuribas : "is there a fix-like function that doesn't diverge?" -- maybe some variant of `loeb' ?
05:04:20 <kuribas> ski: never heard of loeb... I'll look it up
05:04:54 <hekkaidekapus> ALM49: In ghci, you can use qualified identifiers without a prior module import.
05:05:06 <hekkaidekapus> % 4 Data.List.NonEmpty.:| [5, 6]
05:05:06 <yahb> hekkaidekapus: 4 :| [5,6]
05:06:58 <ski> kuribas : the usual Haskell combinator with that name is
05:08:08 <ski> @let loeb :: Functor f => f (f a -> a) -> f a; loeb fs = fa where fa = fmap ($ fa) ff
05:08:10 <lambdabot>  .L.hs:218:26: error:
05:08:10 <lambdabot>      • Variable not in scope: ff :: f1 (f1 b -> b)
05:08:10 <lambdabot>      • Perhaps you meant one of these:
05:08:14 <ski> @let loeb :: Functor f => f (f a -> a) -> f a; loeb fs = fa where fa = fmap ($ fa) fs
05:08:15 <lambdabot>  Defined.
05:09:25 <ski> > loeb [sum . tail,length,const 2,liftA2 (*) (!! 1) (!! 2)]
05:09:28 <lambdabot>  [14,4,2,8]
05:13:46 <kuribas> what weird magic is this?
05:14:10 <yushyin> loeb magic
05:16:52 <enikar> :t loeb
05:16:54 <lambdabot> Functor f => f (f a -> a) -> f a
05:18:06 <ski> (named after some kind of analogy with <https://en.wikipedia.org/wiki/L%C3%B6b%27s_theorem>,<https://en.wikipedia.org/wiki/L%C3%B6b's_paradox>)
05:18:11 <Uniaika> rally racing has made its way into Haskell!
05:18:20 <ski> racing ?
05:18:49 <Uniaika> https://en.wikipedia.org/wiki/S%C3%A9bastien_Loeb
05:18:50 <phadej> https://en.wikipedia.org/wiki/S%C3%A9bastien_Loeb
05:18:51 <Uniaika> :)
05:18:56 <phadej> (:
05:18:57 <Uniaika> haha, raced, phadej! 
05:19:03 <ski> hm, never heard about him
05:19:15 <Uniaika> oh don't worry, I know him because I'm french
05:19:23 <phadej> finns know rally too
05:19:54 <ski> kuribas : anyway, can you follow that example, or would you like a hint ?
05:21:55 <phadej> eh, 9 consecutive championships
05:22:04 <phadej> might been a bit boring at the end
05:22:38 <kuribas> ski: more or less... I'll study it another time
05:23:19 <phadej> "Loeb is a tarmac expert, having won all but three of the WRC rallies on that surface in which he has participated between 2005 and 2013."
05:24:34 <ski> kuribas : basically, that example works sortof like a spreadsheet. every "cell" can refer to the value of all the other "cells"
05:24:59 <kuribas> ski: a comonad?
05:25:24 <Unhammer> so split-sections on windows gives "ld.exe: blah.o: too many sections", "file is too big", when compiling blazehtml
05:25:38 <Unhammer> too bad
05:25:50 <ski> this `loeb' only requires a functor (and general recursion)
05:26:32 <Unhammer> works great on my other project that doesn't need windows though :) 30M → 9.9M
05:26:35 <ski> (if you pick `Identity', you get the usual `fix')
05:26:56 <kuribas> indeed
05:26:58 <kuribas> pretty neat
05:27:22 <ski> so, you can easily chase your own tail, with this `loeb'
05:27:53 <ski> but if you only provided access to some other cells, in some well-founded order, say ..
05:28:14 <ski> > foldr (\f as -> f as : as) [] (replicate 4 (succ . sum))
05:28:16 <lambdabot>  [8,4,2,1]
05:28:20 <ski> @type foldr (\f as -> f as : as) []
05:28:21 <lambdabot> Foldable t => t ([a] -> a) -> [a]
05:28:46 <ski> in this case, each cell only gets access to the values of the cells after it
05:29:00 <ski> and so, it's in some sense "like `fix'", but doesn't get you general recursion
05:29:39 <kuribas> ski: but you just showed it is like fix?
05:29:44 <kuribas> with Identity
05:29:52 <ski> no, that was the `loeb' i just defined, above
05:30:38 <kuribas> ah right...
05:30:41 <ski> the original Löb's theorem, can be interpreted to be about staged computation, and in that case also doesn't give you general recursion
05:30:52 <kuribas> and if instead of cell you take datatype fields... that may work
05:30:59 <ski> (also related to quines)
05:31:27 <ski> you have to avoid cycles. so you need to pick some well-founded order
05:33:27 <ski> (or if you don't, you'd need to ensure that each step is productive. that's my "larger" suggestion from above)
06:01:27 <exarkun> Anyone want to recommend a prometheus library (I guess they're "prometheus client" libraries?  for publishing metrics)?  I see a lot of options out there.
06:11:30 <exarkun> oops no there's only one in my stack resolver so I guess that's easy
06:30:48 <dminuoso> exarkun: Both prometheus and prometheus-client are great.
06:31:25 <exarkun> alright, cool.  prometheus-client is what I'm looking at now.  thanks.
06:31:27 <dminuoso> Overall Id just run with prometheus-client
06:31:49 <dminuoso> (It's what we use)
06:32:09 <dminuoso> It uses a nasty global mutable registry, but oh well.
06:32:45 <dminuoso> Just not a big fan of prometheus coming with warp, feels wrong
06:41:49 * hackage wai-extra 3.0.31 - Provides some basic WAI handlers and middleware.  https://hackage.haskell.org/package/wai-extra-3.0.31 (MichaelSnoyman)
06:48:19 * hackage uniqueness-periods-vector-filters 0.1.0.0 - A library allows to change the structure of the 'RealFrac' function output.  https://hackage.haskell.org/package/uniqueness-periods-vector-filters-0.1.0.0 (OleksandrZhabenko)
07:14:02 <ezzieyguywuf> lol, so turtle is supposed to replace bash?
07:16:47 <merijn> ezzieyguywuf: define "supposed" and "replace" :p
07:17:39 <merijn> Think of Turtle as a library/framework optimised for making it easier/simpler to write "bash-like scripts" in Haskell
07:18:12 <ezzieyguywuf> "supposed" is in "intended" and "replace" as in "use instead of all the time"
07:18:46 <merijn> Realistically *nothing* is going to replace bash in the next century
07:18:59 <merijn> It's like COBOL, ubiquitous to the point of immortality
07:19:40 <merijn> And nothing seriously aspires to replacing bash (I mean, that might be the wishful thinking marketing some shells throw about, but nobody believes that)
07:19:58 <merijn> Not to mention the fact that bash is 2 things, an interactive shell and a scripting language
07:20:00 <ezzieyguywuf> i've been using zsh
07:20:09 <ezzieyguywuf> but since I just installed gentoo on a new laptop, i'm reconsideringb
07:20:23 <ezzieyguywuf> b/c I think zsh just makes it easy to do things that you can already do in bash with a little bit of oomph
07:21:16 <maerwald> use fish
07:21:29 <ezzieyguywuf> 😂
07:21:33 <ezzieyguywuf> i tried fish for like a minute once
07:21:41 <maerwald> I switch to bash occasionally when I need to do serious things
07:21:47 <merijn> ezzieyguywuf: So at best turtle is an alternative to one of the two use cases of bash (i.e. shell scripts)
07:21:47 <yushyin> have a look at rash, an interactive shell with the power of racket :D
07:21:48 <maerwald> but the defaults aregood
07:21:49 <ezzieyguywuf> oh you were forrill
07:22:04 <yushyin> https://rash-lang.org/ ^^
07:22:28 <merijn> ezzieyguywuf: The one thing bash (and shell) excel at is easily combining different processes together (the "process" library is a bit heavy weight to work with)
07:22:50 <merijn> ezzieyguywuf: So turtle tries to make that sort of "multi-process" scripting easier/nicer to do in Haskell
07:24:59 <ezzieyguywuf> rash looks interesting
07:26:12 <sm[m]> oil shell might do it
07:26:19 * ski . o O ( F_{i}shell <http://fishell.sf.net> )
07:27:10 <maerwald> download page is sourceforge, LoL
07:27:44 <ezzieyguywuf> maerwald: lol, for rash?
07:27:59 <maerwald> fishell
07:28:16 <ezzieyguywuf> 😂
07:28:33 <ezzieyguywuf> that's weird b/c I just found a github for fish-shell
07:29:18 <ski> not the same thing
07:44:49 <z0> > 9 / (1/0)
07:44:52 <lambdabot>  0.0
07:45:20 <z0> ^ can someone explain this to me? 
07:45:43 <dolio> 1/0 is infinity, and 9/infinity = 0.
07:46:32 <z0> i get the theory, but how does Haskell do this?
07:46:43 <dolio> It's IEEE754 arithmetic.
07:48:15 <hyperisco> so obviously 0*infinity = 9
07:48:44 <merijn> z0: What do you mean by "how does Haskell do this??
07:48:53 <merijn> s/??/"?
07:49:00 <hyperisco> > 0 * (1/0)
07:49:02 <lambdabot>  NaN
07:49:29 <merijn> The answer is, most likely, "the same way C does this"
07:49:38 <hyperisco> maybe "NaN" should mean "more than one number"
07:49:46 <z0> @type (1/0)
07:49:48 <lambdabot> Fractional a => a
07:49:59 <z0> > 1/0
07:50:01 <lambdabot>  Infinity
07:50:04 <dmwit> > 9 / (1/0) :: Rational
07:50:06 <lambdabot>  *Exception: Ratio has zero denominator
07:50:07 <z0> @type Infinity
07:50:09 <lambdabot> error:
07:50:09 <lambdabot>     • Data constructor not in scope: Infinity
07:50:09 <lambdabot>     • Perhaps you meant variable ‘infinity’ (imported from Data.Number.Natural)
07:50:11 <ski> > sqrt (-1)
07:50:13 <lambdabot>  NaN
07:50:14 <merijn> z0: Ah, how does it decide the type of a polymorphic expression?
07:50:14 <ski> > log (-1)
07:50:16 <lambdabot>  NaN
07:50:26 <merijn> z0: Was that the question?
07:50:37 <z0> merijn: that's right
07:50:40 <hyperisco> MoreThanOneNumber, NotInRealPlane
07:50:58 <hyperisco> FILE_NOT_FOUND probably somewhere in the arithmetic
07:51:03 <dmwit> z0: It uses defaulting. The default default is (Integer, Double), I think.
07:51:17 <merijn> z0: Ok, so there's a bunch of rules in the report that define special cases for polymorphic types for Num/Integral and Fractional/etc.
07:51:24 * ski . o O ( `abs (0/0)' )
07:51:24 <z0> merijn: and what is Infinity treated as a value of type Fractional a => a
07:51:39 <dmwit> Infinity is not a value of type Fractional a => a.
07:51:46 <dmwit> It is a value of type Double, and a value of type Float.
07:51:47 <merijn> z0: Which basically say "if you've got a polymorphic expression that's Num or Integral, default it to Integer" and "Double" for Fractional
07:52:00 <dmwit> > (read "Infinity" :: Double, read "Infinity" :: Rational)
07:52:03 <lambdabot>  (Infinity,*Exception: Prelude.read: no parse
07:52:12 <merijn> z0: This is covered by the "defaulting rules"
07:52:16 <hyperisco> yes, the seldom talked about defaults feature
07:52:23 <merijn> z0: If you enable -Wall you should get warnings for defaulting, iirc
07:52:31 <dolio> Well, Infinity isn't a valid expression unless you define a data type with a constructor of that name.
07:52:41 <ski> (or pattern synonym)
07:52:46 <dolio> Yeah, or that.
07:52:50 <z0> dolio: i think that's what is confusing me
07:53:14 <dolio> 1/0 is an expression, and what it does depends on the type.
07:53:31 <merijn> z0: "(1/0) :: Fractional a => a" gets defaulted to type "Double" and when you compute 1/0 for Double the result is a Double (which happens to have value Infinity)
07:53:49 <ski> > 1 / 0 :: Rational
07:53:52 <lambdabot>  *Exception: Ratio has zero denominator
07:54:09 <z0> > ((1/0) :: Double, (1/0) :: Rational, Infinity :: Double, Infinity :: Rational)
07:54:11 <lambdabot>  error:
07:54:11 <lambdabot>      • Data constructor not in scope: Infinity :: Double
07:54:11 <lambdabot>      • Perhaps you meant variable ‘infinity’ (imported from Data.Number.Natur...
07:54:28 <z0> > ((1/0) :: Double, (1/0) :: Rational)
07:54:31 <lambdabot>  (Infinity,*Exception: Ratio has zero denominator
07:54:44 <z0> > (Infinity :: Double)
07:54:46 <lambdabot>  error:
07:54:46 <lambdabot>      • Data constructor not in scope: Infinity :: Double
07:54:46 <lambdabot>      • Perhaps you meant variable ‘infinity’ (imported from Data.Number.Natural)
07:54:53 <z0> hum
07:55:01 <merijn> z0: Infinity is the string representation of a Double value
07:55:10 <merijn> z0: That double value has no literal way to write it
07:55:18 <z0> ok i get it. thanks
07:55:40 <merijn> I think adding a pattern synonym for Infinity would be good, tbh
07:56:02 <z0> but I also get how it can be a bad idea
07:56:29 <dmwit> Perhaps it is not made a pattern synonym because its type is too hard.
07:56:44 <dmwit> (Should we add a new class that just has Double and Float as instances just for this?)
07:56:51 <merijn> dmwit: Just define it as Double
07:56:59 <merijn> let's face it, no one gives a crap about Float
07:57:15 <merijn> Boom!
07:57:21 <dmwit> Mmm. Machine learning folks default to Float pretty consistently.
07:57:21 <merijn> Problem solved with the power of pragmatism!
07:57:44 <merijn> dmwit: They do silly stuff like use half-floats to, so that won't work anyway
07:57:59 <merijn> dmwit: Also pretty sure machine learning people don't generally care about writing Infinity in their code :p
07:58:25 <z0> ...yet
07:59:02 <dmwit> Nobody cares about writing Infinity in their code. Boom! Problem solved without even doing any work through pragmatism.
07:59:05 <ski> % 9 / Infinity
07:59:06 <yahb> ski: 0.0
07:59:06 <merijn> z0: Anyway, I recommend enabling -Wall and avoiding defaulting :p
07:59:09 <merijn> dmwit: I do, though!
07:59:25 <dolio> Well, you can propose it, and then someone else can run off an invent some kind of IEEE class that must be made to ensure maximal generality.
07:59:54 <merijn> dolio: uh-huh, that's why we have the perfect generalised numeric typeclass hierarchy, now, right? ;)
07:59:59 <dmwit> Pfft, you do silly stuff like serialization and deserialization, so that won't work anyway
08:00:41 <hyperisco> I'll be impressed once we stop treating floats like reals
08:00:53 <merijn> hyperisco: Smart people never started :p
08:01:04 <dolio> merijn: Just hope that the requirement for the class to be perfect doesn't block your Infinity pattern getting added. :)
08:01:07 <merijn> The reals are shit numbers anyway :p
08:01:44 <merijn> Like a proper computer scientist I only care about whole numbers...and maybe rationals
08:02:03 <hyperisco> whole numbers and pairs of whole numbers
08:02:12 <maerwald> rationals escalate quickly
08:02:35 <hyperisco> π is 22/7 and that's the end of it
08:02:56 <merijn> Pi is basically 3
08:03:19 <dolio> Floating point is just bad rationals, though.
08:03:38 <dminuoso> Also, why dont we have support for transcedental numbers? :<
08:03:55 <ski> how about algebraic numbers, to start with ?
08:03:57 <merijn> dmwit: We barely know any of the numbers anyway
08:04:05 <merijn> s/dmwit/dminuoso
08:04:16 <hyperisco> I just want the imprecision of floats acknowledged by some static analysis
08:04:39 <merijn> hyperisco: There's already a whole bunch of that
08:04:45 <hyperisco> I don't want floats put into a type class with laws they don't hold
08:04:56 <merijn> like http://herbie.uwplse.org/
08:04:59 <dmwit> dminuoso: You might like the cyclotomic package.
08:05:11 <merijn> hyperisco: Which typeclass's laws do they violate?
08:05:22 <dmwit> It supports most of the transcendentals that come up in calculations, and doesn't have the observation problems that CReal does.
08:05:32 <merijn> I guess Eq, but that's solved once Carter finishes the crusade to abolish value NaN :p
08:05:42 <dmwit> ski: You, too. The cyclotomics are a superset of the algebraic numbers.
08:06:40 <hyperisco> merijn, associativity for one
08:07:01 <merijn> hyperisco: Of what?
08:07:17 <dolio> Additions and multiplication.
08:07:18 <hyperisco> addition, multiplication, but the report has no laws for Num anyways
08:08:31 <hyperisco> if we were honest up front it might not be *that bad* in the end
08:11:47 <dolio> I don't know. Doesn't that mostly matter when people use other faulty operations, like equality?
08:12:43 <merijn> dolio: Equality is fine, value NaN is bogus >.>
08:12:52 <dolio> No, it's not fine.
08:13:09 <dolio> You shouldn't be testing floats for equality, you should be testing that they're "close enough" usually.
08:13:10 <merijn> Name one thing faulty about it excluding value NaN
08:13:22 <merijn> dolio: I call bullshit
08:13:34 <merijn> I frequently need exact equality for floats
08:13:52 <merijn> Like "when checking that deterministic computations are in fact deterministic and remain identical"
08:14:27 <merijn> equality on floats is a perfectly well-defined and reasonable operation in the absense of value NaN
08:14:44 <hyperisco> dolio, equality for floats is much weaker than usual, yes… I think the error bars need to be accounted for
08:15:04 <dolio> merijn: You're missing the point.
08:15:20 <hyperisco> because if you only retain the error-free equalities then you can hardly say enough about floats
08:15:37 <merijn> dolio: Which is?
08:15:58 <ski> (it would be nice to have `forall x y. x == y == True => x = y' and `forall x y. x == y = False => x =/= y')
08:16:12 <ski> (s/== True/= True/)
08:16:23 <merijn> ski:Right, which is the case once you elimiante value NaN
08:16:43 <hyperisco> so I think probably instead you have to talk about intervals of reals, and then instead of equality you have interval relations
08:16:53 <merijn> value NaN is what torpedoes reflexivity
08:17:00 <hyperisco> (where actual equality becomes the relation of equality on intervals)
08:17:55 <hyperisco> so you can say  a < b  if the interval of  a  precedes the interval of  b
08:18:03 <dolio> Which is that expected algebraic rules hold up to 'approximate equality', so you don't just tell people "addition isn't associative," because it's not the whole story. Part of the story is that exact equality is only reliable for exact sequences of operations, and shouldn't be treated as reliable in general.
08:18:11 <hyperisco> precedes or meets
08:19:00 <hyperisco> a float calculation is exact if the interval is expressible as [x,x] for some x, etc
08:19:01 <ski> dolio : that's separate from the `NaN' point, though
08:19:09 <hyperisco> at least this is the line I would try to go down
08:19:09 <dolio> I didn't even bring up NaN.
08:19:16 <carter> merijn: did you see the final version of clamp that got merged in last week? It handles NaN in a pretty ncie way
08:19:30 <carter> Yeah, agree with dolio , it’s a stance I’ve had myself.
08:19:35 <ski> yes. iow you're (mostly) talking about different things
08:19:40 <merijn> carter: No, I've been busy learning Fortran >.>
08:19:44 <dolio> Yeah, so don't jump into what I'm saying.
08:20:09 <carter> dolio: the 1 plus or minus epsilon flavor or approximate equality?
08:20:20 <hyperisco> dolio, we can give "approximate equality" a precise meaning though, don't you think?
08:20:34 <carter> merijn: is flang the only oss / free compiler for modern FORTRAN?
08:20:35 <dolio> I don't know. I don't care enough to actually learn all the details necessary.
08:20:41 <carter> hyperisco: ues you can
08:21:11 <carter> Basically every operation has a error bound of multiplicative 1 plus or minus epsilon error
08:21:13 <dolio> It's just my impression that people who actually work with IEEE heavily espouse this view.
08:21:25 <merijn> carter: I dunno? We use gfortran and I am not sure what "modern Fortran" really entails, but I've become really sure that all documentation on Fortran sucks balls :)
08:21:46 <carter> merijn: apparently you can kinda write sane stuff with new enough FORTRAN
08:21:58 <hyperisco> carter, so I suspect my interval analysis is effective
08:22:23 <carter> hyperisco: not quite. Interval analysis will always over estimate error
08:22:42 <carter> Though it’s still useful.
08:23:10 <hyperisco> how can we be more exact?
08:23:35 <dolio> carter: I think people usually would have some defined epislon that their results need. Not necessarily the smallest possible epsilon.
08:23:55 <carter> Absolutely
08:23:56 <dolio> Oh, I guess that's what you meant.
08:24:06 <carter> But for the computation itself
08:24:33 <carter> 333333hyperisco: there’s these pretty powerful but soemtimes annoying  ideas called forwards and backwards stability
08:24:59 <carter> So one flavor is that your result is a perturbation of the correct answer to the exact input.
08:25:24 <carter> The other is that your output is an exact answer to some input that’s a nearby perturbation of your input
08:26:04 <dmwit> > 0 == -0
08:26:07 <lambdabot>  True
08:26:10 <dmwit> > 0 == (-0 :: Double)
08:26:13 <lambdabot>  True
08:26:22 <dmwit> merijn: ^
08:26:28 <carter> That’s so you can handle directional limits
08:26:32 <dmwit> Torpedoing NaN isn't enough to get ski's property.
08:26:47 <carter> What property does he want
08:26:58 <dmwit> (==) being Leibniz equality, basically.
08:27:08 <ski> when it terminates
08:27:12 <dmwit> right
08:27:38 <carter> I mean, the signed zero thing is so you can talk about left or right limits
08:27:49 <carter> Afaik.
08:28:00 <dmwit> I think everybody agrees that every decision made in IEEE754 has a justification behind it.
08:28:06 <carter> Yeah
08:28:10 <dolio> Hahaha.
08:28:18 <dmwit> That doesn't mean that at the end of justifying all those decisions you get something with nice properties.
08:28:51 <carter> Oh did you read how idris2 proved false because it’s model of equalities for float were wrong?
08:29:01 <carter> Apparently same happened to agda before
08:29:10 <hyperisco> I figured it was as simple as it is a possible bitfield
08:29:12 <dolio> Not surprised.
08:29:27 <carter> hyperisco: sign in floats?
08:29:28 <hyperisco> like with 1's complement
08:29:29 <dolio> Agda's is still wrong, I think, but someone is working on it.
08:29:30 <hyperisco> yes
08:29:34 <hyperisco> well -0 specifically
08:29:47 <dolio> I don't know if you can prove false from it, though. It just doesn't make sense.
08:30:23 <dolio> Like, I think the ordering is just the induced ordering from Double -> Word64.
08:30:39 <hyperisco> their other option is to leave that particular bitfield undefined?
08:30:57 <carter> dolio: as bit rep ? Or other. I think that’s how the ieee tots order is defined
08:31:15 <carter> hyperisco: or make it a quotiented type!
08:31:31 <carter> Ideas from hott but for numerical computing formal methods
08:31:40 <dolio> carter: Yeah, the bit representation. But it's not correct because Word64 is unsigned.
08:32:08 <carter> I thought it was leading bit is sign. Then magnitude. The mantissa ?
08:32:10 <dolio> So negative numbers are larger than positive numbers.
08:32:16 <carter> Ok fuck that
08:32:19 <carter> That’s bad
08:32:56 <carter> I’ve actually been thinking a lot about how quotient types a la hott or whatever might be amazing for generic programming
08:35:11 <dolio> Yeah, hopefully that bears some fruit. There are aspects to the HoTT approach to quotients that make it quite different than previous attempts.
08:35:40 <dolio> And it seems like it could be capturing useful aspects of computation on quotients.
08:35:46 <ski> we're already simulating factor/quotient types (and subset types), via abstract data types
08:37:19 <ski> carter : why/how for generic programming ?
08:37:59 <carter> Ski: so an example I’ve been thinking about is sets as data structures.
08:38:26 <ski> yes
08:38:29 <carter> In general you need element equality and kinda brute force finding the right permutation exists or not for set sequalith
08:38:56 <carter> So the weakest eq proof calc is equality modulo explicit permutation
08:39:00 <ski> what kind of implementation/representation do you have in mind there ? some kind of balanced trees ?
08:39:41 <carter> If the elements themselves have a total order or a well behaved binary serialization you can skip permutation discovery
08:39:44 <ski> or starting from an arbitrary list, considering permutations and elision/introduction of duplicates ?
08:39:47 <carter> And keep them sorting
08:39:59 <carter> Sorted
08:40:12 <carter> These are different proof / computation strategies for sets
08:40:16 <carter> Is my point
08:40:24 <ski> yep
08:40:32 <ski> it would be nice if they could coexist, perhaps
08:40:50 <carter> So they could all be kinda constrained proof constructors for equality sortah
08:41:19 <carter> In hott land, the equality type is sortah like an open data family. Sortah?   Dolio sclv am I wrong?
08:41:33 <ski> something like that
08:41:43 <carter> So you could conceivably annotate the extra proof terms with a priority weight
08:41:53 <carter> Or so something like a sibling to deriving via
08:42:00 <dolio> Kind of. It's complex. :)
08:42:01 <carter> With some preference ordering
08:42:32 <carter> In some ways it veers into wanting relational programming In your functional programming
08:42:40 <ski> you mean priorities for eq-via-permutation and eq-via-sorting, e.g. ?
08:42:58 <carter> Yeah
08:43:06 <carter> It’s still a fuzzy idea of mine
08:43:27 <ski> heh, i've recently been thinking about how to construct isomorphisms between types .. and that (in my mind) ties a bit into relational/logic programming
08:43:33 <dolio> The interesting thing about quotients in HoTT to me is that the equalities between equal quotient values are computationally relevant.
08:44:05 <ski> yes
08:44:11 <carter> Ski I’ve been way overdue to write down some of my ideas in this space.
08:44:46 <carter> Plague time plus forcing myself to look into new jobs for a change of pace have eaten into bandwidth.  Current job is great. But kinda want a change of pace
08:44:56 <dolio> So you can possibly do 'different' things for 'equal' values, but those things are still able to be mediated between by some other computation.
08:45:01 <ski> (my "reflective syntax" idea, that i introduced for effectful computations, also seems to fit nicely, with some modifications, to equality proofs, and to computing with such HITs)
08:45:23 <carter> Ski how’d you get your logic programming thoughts
08:47:24 <ski> well. if you e.g. express an isomorphism between `Nat' and `Fin n * Nat', you're expressing a bidirectional translation. that's like a binary predicate (except that you enforce it being functional, in both directions). so the "body" of your definition will effectively come after something corresponding to `:-' in Prolog
08:47:49 <carter> i'm not super literate at prolog
08:47:56 <carter> more strict relational plus datalog
08:48:24 <ski> `:-' is converse implication `<=', basically. or maybe converse entailment `-|', if you prefer
08:48:35 <dolio> Which in some ways makes it "easier" to write functions from quotients. You don't need to decide some canonical representative of each equivalence class and produce an identical result. You just need to show how to mediate between the results when someone presents you with how two values are 'equal'.
08:49:06 <carter> dolio:  which referent?
08:50:47 <dolio> Eh?
08:51:20 <ski> carter : i still have to consider more how computations with these isomorphism / type-equality definitions will actually work. but it seems to naturally want to express itself in logic programming terms, to me, when i'm following the way i'm trying to express things
08:53:04 <carter> dolio:  couldn't figure you which thing you were referrring to ;) 
08:53:08 <carter> ski:  i can totally see that
08:53:15 <carter> full linear logic seems relevant to me
08:53:23 <carter> cause its a really nice way to think about certain relations
08:53:32 <dolio> I've just been rambling, so it's referring to stuff I've said, probably.
08:54:13 <carter> Fun rambles
08:55:11 <dolio> It's kind of interesting, really. If you think about the details, it's tying up 'propositions as types' in a really satisfying way.
08:55:43 <ski> carter : .. including also sometimes wanting to be able to use disjunction (not just conjunction), in the body of a rule
08:55:53 <carter> which disjunction?
08:55:53 <dolio> Because, the 'propositions as types' approach was originally like "well, A + B is used for A ∨ B, and we don't care that the former might have more than one distinct value."
08:55:54 <carter> :)
08:56:13 <carter> ski have you skimmed mike shulmans linear logic for constructive math?
08:56:23 <carter> it kinda touches on this in a really cool way
08:56:23 <ski> hm, i think i did, at some point, yes
08:56:38 <ski> in what way are you seeing connections to linear logic ?
08:56:39 <carter> its a weird paper , but for a conceputal flavor for full linear lgoic
08:57:01 <carter> well, the duality structure for *full* linear logic is really good for functional programming / duality / logic programming
08:57:01 <dolio> And most attempts to fix that latter part kind of try to make it _not_ have more than one value.
08:57:02 <carter> idk
08:57:10 <carter> err
08:57:21 <carter> poke me about this in a few days, i need to mull how to explain this better
08:57:45 * ski nods to dolio re functions from quotients
08:57:47 <dolio> But the HoTT approach is kind of the opposite. It has more than one value, but there are mediating values between them that make it sort of equivalent to having only one value.
08:58:13 <ski> (carter : at least if it's the slides i think it is. link ?)
08:58:22 <dolio> More than one value in a strict sense, but not 'up to paths'.
08:58:35 <carter> https://arxiv.org/abs/1805.07518 ?
08:59:25 <ski> hm, i think i didn't see this paper (maybe i saw slides of a presentation of it, not sure)
08:59:28 <ski> ty
09:02:44 <ski> carter : "which disjunction?" -- well .. in this case, additive, i suppose you'd say
09:03:00 <carter> is that the usual one?
09:03:09 <ski> carter : but i've sometimes been pondering how one could program with multiplicative disjunction, as well
09:03:10 <carter> the thing is ... the other one is also really nice
09:03:14 <ski> the usual constructive one, yes
09:03:47 <carter> ski:  i have a tiny model of all 4 in haskell code  https://github.com/cartazio/symmetric-monoidal/blob/master/src/Control/Monoidal.hs
09:04:00 <carter> they are sortah matching pair eliminiators
09:04:00 <ski> i have been pondering a pet example, converse of induction on naturals
09:04:19 <carter> wait, PAR is the multiplicative one
09:04:20 <carter> ddrr
09:04:26 <carter> & is the mult product
09:04:31 <carter> PAr is the XOR of proofs
09:04:52 <ski> XOR ?
09:05:02 <carter> yes
09:05:08 <carter> multiplicative disjunction is constructive xor
09:05:09 <ski> in which sense ?
09:05:24 <carter> like a real number is zero XOR some signed nonzero distance from zero
09:05:32 <carter> proving one rules out the other
09:05:37 <carter> or disproving one implies the other
09:05:53 <carter> lets you be more explicit about mutally exclusive facts
09:06:00 <carter> which IS COOL
09:06:06 <ski> how about `x >= 0 \/ x =< 0', disproving one gives you information for proving the other ?
09:06:09 <dumptruckman> Is it normal to have a data type with only a single value constructor or is there some better construct for this?
09:06:20 <carter> ski:  :P
09:06:23 <ski> or `p | a*b => p | a \/ p | b', `p' a prime
09:06:40 <ski> (the usual proof starts with "Assume not `p | a'.")
09:07:02 <carter> ski   i think your  example isn't quite sound unless you have a != zero assumption
09:07:03 <dumptruckman> Once again trying to use Haskell to better understand a problem in Java. However, I'm attempting to learn more about the type system this time.
09:07:11 <monochrom> But x>=0 together with x >= 0 \/ x =< 0 does not give you any information about x=<0
09:07:37 <carter> though x > 0 | x <=0 does thave the onely one is true at the same time
09:07:48 <carter> ski:  you need to have something where the XOR of the propreties is true
09:07:55 <carter> Never the ANd
09:08:03 <carter> monochrom:  how're you?
09:08:05 <monochrom> dumptruckman: It is normal.
09:08:17 <ski> dumptruckman : sometimes `newtype' is preferable
09:08:44 <ski> carter : i don't see why
09:08:58 <ski> carter : `a != zero', for the prime example ?
09:09:28 <carter> ski:  your lack of parens confused me
09:09:30 <ski> monochrom : the idea was that refuting one would give you information about the other
09:09:41 <carter> *proves the other*
09:10:01 <carter> so par is actually a really good model for bijections
09:10:14 <carter> because negation could just be producer/consumer polarity
09:10:22 <carter> in certain models of the logic
09:11:29 <carter> (gcd(a,b)==1, AND    `p' a prime  AND p | a*b ) => (p | a) xor   (p | b'),
09:11:38 <carter> ski: tweaks it
09:11:47 <carter> *fixed it
09:11:55 <carter> that would you be the property using par
09:12:01 <dolio> I think the `A ∨ B` version would probably not be linear.
09:12:18 <dolio> You can only do that argument linearly with par.
09:12:29 <carter> dolio:  yeah, the formal modelling this way is still useful sans linearity
09:12:41 <carter> linearity is just how you derive the logic and dualities first
09:12:46 <carter> or at least thats my perspective
09:12:47 <carter> idk
09:12:48 <dolio> Because for additive disjunction you'd be dropping a proof in the case you don't need it.
09:12:52 <carter> yup
09:13:00 <carter> dolio:  sum?
09:13:04 <dolio> Right.
09:13:29 <carter> yeah, 
09:13:39 <dolio> Also `P \par Q` has aspects where they "can't both be true".
09:13:46 <carter> dolio:  oh?
09:13:53 <carter> i mean, yes
09:13:55 <carter> err
09:14:00 <carter> dolio:  example / explaborate?
09:14:09 <carter> have i been wrong for years, AGAIN :) 
09:14:50 <carter> either way i'm happy to continue chatting about this with folks
09:14:51 <dolio> Well, that's what you'd expect from xor.
09:14:55 <carter> oh yeah
09:15:04 <ski> carter : yea .. except that one wants to be able to refer to primality, often, without having to make sure / know that the two factors are coprime
09:15:06 <carter> if both are true or both are false, xor is fal
09:15:24 <carter> ski:  absolutely, i'm just showing 
09:16:09 <carter> dolio:  you mean that/
09:16:17 <dolio> carter: I don't have examples because I'm still not good at thinking about par.
09:16:22 <carter> dolio:  i was presupposing you have a proof of a xor b 
09:16:33 <carter> dolio:  you can def prove a xor b false
09:16:38 <ski> carter : anyway, i'm not convinced it should model `xor' in some sense. (and i didn't follow the "so par is actually a really good model for bijections" bit, either)
09:16:54 <carter> ski:  depends on your model of it
09:16:55 <dolio> Yeah, proving both would be a way to prove a xor b false.
09:17:01 <carter> yup
09:17:03 <carter> exactly
09:17:11 <carter> or disproving both 
09:17:20 <carter> ski:  i'm aboslutely happy to help explain more
09:17:20 <ski> usually, with boolean logic, biimplication would be `xnor', not `xor'
09:17:38 <ski> (maybe that's not what you meant by "bijections", though)
09:17:45 <carter> ski:  for the relational model, negation could just be the direction that info flows
09:17:52 <carter> *for bijections
09:17:58 <carter> not a consumes an a
09:18:03 <carter> a produces an a
09:18:25 <carter> i think of  A `par` B as ====  (not a -> b) & (not b -> a)
09:18:46 <ski> yes, but that image would admit overlap
09:18:46 <carter> & === multiplicative conj where you *choose which* field you get
09:19:02 <carter> all the session type falvored stuff dropps the symmetries
09:19:06 <ski> that would be additive conj.
09:19:19 <carter> i get add and mult confused
09:19:25 <carter> sum, pair, & and par
09:19:45 <carter> i dont really see the metaphor for the additive vs mult binary operators perspective
09:19:45 <ski> hm. when i read Wadler's paper on session types and linear logic, i was thinking all connectives were the opposite of what i expected
09:20:08 <carter> and i alwasy forget which things are additives vs mult
09:20:19 <ski> (iow, replaced by duals, everywhere. or possibly it was just for one of the subsystems described)
09:20:42 <carter> i dont like a lott of / most expositions i've seen
09:21:06 <dolio> ski: Might depend on how they were being used, I guess.
09:21:07 <ski> consider `a * (b + c) = (a * b) + (a * c)'
09:21:15 <ski> `*' is multiplicative, `+' is additive
09:21:17 <dolio> Inputs vs outputs.
09:21:18 <ski> that's how i remember it
09:22:06 <ski> dolio : yes, presumably, but it still seemed simpler to me, to just flip all the connectives, then. not upset people's expectations, for what seemed to be no reason
09:23:31 <ski> carter : fwiw, i don't like the usual notation for (some of) the connectives ..
09:23:45 <dolio> Which one? :)
09:23:46 <ski> .. so, in personal notes, i'm using my own convention :)
09:23:52 <ski> yea, there's several
09:24:00 <ski> i had Girard's one in mind
09:24:20 <dolio> I think both are wrong categorically.
09:24:48 <ski> (i reconstructed it from memory, after getting exposed to the ideas. then, after a bit, i noticed my reconstructed version was not the same as in the papers i read)
09:25:03 <carter> dolio:  which are wrong how?
09:25:25 <dolio> carter: Additives are (co)product, but I think neither notation uses * for additve conjunction.
09:26:29 <dolio> That would suggest + for additive disjunction, too, but maybe Girard doesn't do that, either.
09:26:38 <dolio> It's a circled +?
09:27:02 <dolio> I've heard Girard's notation is supposed to remind you of distributive laws.
09:27:40 <carter> lol
09:28:07 <dolio> But I'm not sure that's worth it.
09:30:06 <ezzieyguywuf> so pretty much always just use ghcup rather thn whatever my OS's package manager has, right?
09:30:55 <maerwald> ezzieyguywuf: if your OS PM gets it right... then that's also nice
09:31:08 <ski> clearly ⌜+⌝ ought to be coproduct ("either","internal choice"), ⌜×⌝ be product ("with","external choice"), ⌜0⌝ be initial object ("void"), ⌜1⌝ be terminal object ("erase"), i thought. that leaves ⌜⊕⌝ for multiplicative disjunction ("par"), ⌜⊗⌝ for multiplicative conjunction, and then i took ⌜⊥⌝ ("bot") and ⌜⊤⌝ ("top","unit") as the respective neutral elements for those
09:31:08 <dumptruckman> So... If I wanted to model a game state a Monad would be sensible for this, right?
09:31:22 <maerwald> ezzieyguywuf: but ghcup is faster with adding new versions, most likely
09:31:39 <dolio> Oh yeah, the units are all mixed up, too.
09:31:50 <ezzieyguywuf> maerwald: they did the ghc nicely, they just pulled the binary from upstream, but the cabal install is a mess - I end up having to jump through all these hoops to get the cabal dependencies installed in the PM
09:32:18 <ezzieyguywuf> I was planning to just install ghc and cabal from the OS, then cabal install to grab things I need for dev and install the locally
09:33:19 * hackage uniqueness-periods-vector-filters 0.1.1.0 - A library allows to change the structure of the 'RealFrac' function output.  https://hackage.haskell.org/package/uniqueness-periods-vector-filters-0.1.1.0 (OleksandrZhabenko)
09:33:38 <ski> yes, Girard uses : ⌜⊕⌝,⌜&⌝,⌜0⌝,⌜⊤⌝ for the additives, and ⌜⅋⌝,⌜⊗⌝,⌜⊥⌝,⌜1⌝ for the multiplicatives
09:34:48 <ski> dumptruckman : monads can be nice for keeping track of state, yes
09:36:01 <ski> (oh, forgot to say that mult. conj. is "(both) .. and .."/"tensor")
09:41:51 <Uniaika> phadej: do you think if SqlQQ can be safely extracted from postgresql-simple? I'd like to use it for sqlite too but I'm not familiar with postgresql-simple's internals
09:43:30 <ezzieyguywuf> k so really...no definitive answer on OS vs ghcup
09:43:30 <ski> dumptruckman : some alternative might perhaps be to try to keep local state, maybe via some kind of stream processors or something (FRP ?)
09:43:38 <dumptruckman> mmk
09:43:58 <ezzieyguywuf> any gentoo users in here?
09:44:06 <dumptruckman> How would I lift the list out of this to be able to use intersect on an instance of Shares? `data Shares = Shares [Sharable]`
09:44:08 <maerwald> ezzieyguywuf: why
09:44:22 <maerwald> also: gentoo is not the distro that does get GHC right
09:44:34 <ski> dumptruckman : pattern-matching
09:44:41 <dumptruckman> what would that look like
09:44:50 * hackage pusher-http-haskell 2.0.0.1 - Haskell client library for the Pusher Channels HTTP API  https://hackage.haskell.org/package/pusher-http-haskell-2.0.0.1 (willsewell)
09:44:57 <dumptruckman> do i need to define `intersect :: Shares -> Shares -> Shares`?
09:44:59 <ski>   intersectShares :: Shares -> Shares -> Shares
09:45:01 <dumptruckman> ok
09:45:07 <monochrom> "OS vs ghcup" depends on the OS. However, for 90% of OSes, go with ghcup.
09:45:13 <dumptruckman> oh, i have to name it differently?
09:45:25 <ski>   instersectShares (Shares ss0) (Shares ss1) = Shares (intersect ss0 ss1)
09:45:37 <ski> depends on whether you import `intersect' qualified
09:45:59 <dumptruckman> hmm ok
09:47:08 <dumptruckman> is it silly to use the & operator for this?
09:47:14 <dumptruckman> is that even possible?
09:47:20 <monochrom> You can.
09:47:21 <ezzieyguywuf> maerwald: there's been changes in gentoo rather recently, the haskell situation is lots better
09:47:41 <ezzieyguywuf> but I still think I'm going to stick to ghcup - I don't want to have, like, mtl and stuff installed at the system level
09:48:12 <maerwald> ezzieyguywuf: I'd be surprised, because the gentoo PM cannot handle installing the same package mulitple times
09:48:22 <maerwald> which you need for haskell packages
09:49:12 <maerwald> The proper way to packages haskell is: only package GHC and cabal and *nothing* else (no haskell packages)
09:49:39 <ski> (dumptruckman : btw, in Haskell terminology, you wouldn't talk about "an instance of Shares", but rather about values of (type) `Shares')
09:49:41 <maerwald> everything else ends up showing limitations of the package manager with the only exception being nix
09:49:53 <maerwald> but then... you know... you'd have to use nix, ugh
09:50:40 <ezzieyguywuf> maerwald: it can, it's called "slots"
09:51:11 <ezzieyguywuf> maerwald: that's what I wanted to do, but in the current setup, I have separate packages for cabal's dependencies, i.e. mtl, fail, etc.
09:51:25 <maerwald> ezzieyguywuf: no, I'm talking about the same version
09:51:31 <maerwald> slots don't do that
09:51:40 <ezzieyguywuf> also, on a different note - I accidentally ran `ghcup` in `/root` as `myUser`, and it gave me a permission error when it tried to do `cabal new-update`
09:51:42 <phadej> Uniaika: https://hackage.haskell.org/package/postgresql-simple-0.6.2/docs/src/Database.PostgreSQL.Simple.SqlQQ.html#sql just copy it
09:51:49 <phadej> it doesn't really do anything smart
09:51:51 <dumptruckman> ski: thanks, i wasn't sure about that
09:51:52 <ezzieyguywuf> shouldn't it always dereference my ~ variable, no matter what the current directory is?
09:52:15 <phadej> (cliking source on hackage docs pages is the trick, often enough ;)
09:52:16 <ezzieyguywuf> maerwald: so there's a need for the same version of the same package to be installed multiple times?
09:52:27 <maerwald> ezzieyguywuf: You cannot install filepath-1.2.0.0 for multiple GHC slots on gentoo
09:52:42 <maerwald> that's a fact, slots don't solve this
09:52:43 <maerwald> nix does
09:53:00 <ski> dumptruckman : it's fine, got what you meant. just pointing it out, for more efficient future communication
09:53:24 <ezzieyguywuf> neat! is ghcup tui using the boxes thing?
09:53:29 <ezzieyguywuf> urm, bricks
09:53:38 <maerwald> yes
09:53:48 <ezzieyguywuf> 😍 ery cool
09:54:26 <ezzieyguywuf> so I want to try using just cabal install of stack. If I want to install xmonad do I just do cabal install xmonad?
09:54:47 <ezzieyguywuf> is there a different install command if I want/need to install a package in a 'sandbox' for a particular project?
09:55:00 <maerwald> ezzieyguywuf: sandboxes are removed
09:55:14 <ezzieyguywuf> so things..."just work"?
09:55:38 <maerwald> you can point it to a different store dir to emulate that, but that's more like something you'd do in CI, not on your local machine
09:55:57 <maerwald> ezzieyguywuf: https://cabal.readthedocs.io/en/3.4/nix-local-build-overview.html
09:56:27 <sclv> xmonad is the one tricky thing because it doesn't work out of the box with new-build stuff in terms of its auto-reload on config chang estuff
09:56:40 <sclv> there's some writeups of different techniques around the web
09:56:59 <ezzieyguywuf> aw man
09:57:01 <sclv> but that's now a cabal/new-build problem, its a "xmonad hasn't been updated to deal with new functionality well" problem
09:57:19 <ezzieyguywuf> s/now/not/ I assume
09:57:21 <sclv> i don't know offhand the "canonical" way to make it work, but i do know there are solutions
09:57:25 <sclv> yes, typo
09:58:23 <ezzieyguywuf> maerwald: thanks for the link reading now
09:58:23 <carter> Ski dolio what makes them multiplicative vs additive?
09:58:43 <ski> carter : i'd say, the distributive law(s)
09:59:04 <dolio> Multiplicatives are tuple-like, and additives are choice-like.
09:59:13 <ski> the replicated connective is multiplicative. the connective it's replicating over is additive
09:59:15 <sclv> ezzieyguywuf: here's one xmonad ticket with some discussion on the issue -- using a build-script seems like the right approach but idk https://github.com/xmonad/xmonad/issues/199
10:00:03 <zebrag> If `m` is an applicative, there really are `Int` in `m Int`. And it really puzzles me that it is always so. If it were only a functor it wouldn't be so. I'm wondering where, on the way from functor to applicative, is this property added.
10:00:06 <dolio> Multiplicative conjunction values are like pairs of values. Multiplicative disjunction continuations are like pairs of continuations.
10:00:19 <ski> yes, additives have to do with choice (internal or external). or information/exformation, if you want. while multiplicatives have to do with aggregation and communication/composition
10:00:23 <carter> dolio:  ok that makes more sense to me
10:00:31 <maerwald> there are two kinds of oss projects: 1. unmaintained, 2. pedantic dictatorship maintained
10:00:47 <carter> maerwald:  reductive but not false?
10:00:53 <carter> well, depends on what maintained means
10:00:54 <maerwald> I chose 2. and went with i3
10:01:01 <ski> zebrag : "If `m` is an applicative, there really are `Int` in `m Int`." -- nope
10:01:29 <carter> ski:  dolio  ... but does this flavor of additive vs multiplicative have  a formal meaning?
10:01:36 <Uniaika> phadej: glorious, thank you!
10:01:55 <zebrag> ski: What makes me thing that is that ocaml has some sort of do-notation for applicatives
10:02:05 <amf> I'm using sortBy, but I need to order by 2 fields in a specific order, what is the technique? and would this be called a compound sort? (wasnt sure what to google)
10:02:05 <ski> carter : .. dunno ?
10:02:20 <zebrag> ski: can you give me an example
10:02:23 <zebrag> ?
10:02:35 <ezzieyguywuf> what about installing, say, hoogle or ghcid
10:02:36 <ski> zebrag : okay ? iirc, OCaml also has GADTs, no ?
10:02:39 <ezzieyguywuf> just cabal install ghcid?
10:02:49 <ski> zebrag : well, `IO' is a canonical example, in Haskell
10:03:00 <qqqqqq> 6 To be happy and lifted from hell and misery, Islam is your Jewel of the seas. Say no God except one(Allah)~ 4 To get blessings thru monotheism, He is the Only creator of heaven & earth. 6 He Designed the Universe 4 with Superb ingenuity. 6Lets praise Allah; 3he is our God, thee one; he is the god of Moses; Noah; Jesus & Mohammed; he sent us our Book 7 Quran, 10Monotheism is cleared by all prophets ~ 6 We get heaven by praying to the one god 6& by Sa
10:03:10 <ski> zebrag : there is no `String' inside `getLine :: IO String'
10:03:16 <geekosaur> amf, combine the comparison operations with <>
10:04:09 <amf> geekosaur: doh! yep, that was it, thanks!!
10:04:41 <zebrag> ski: getLine >>= \x -> f? (isn't x substituted for a string along the way?)
10:05:27 <carter> Oh I see.  Cause cause additive zero is void
10:05:39 <monochrom> maerwald: What is i3?
10:05:47 <ski> zebrag : yes, but `getLine' itself does not contain that `String'
10:05:48 <ezzieyguywuf> monochrom: I window manager like xmonad
10:06:00 <carter> And that zeros out multiplicative things
10:06:02 <maerwald> monochrom: a tiling wm built by a german
10:06:10 <maerwald> without window icons
10:06:16 <dolio> carter: I'm not sure either. There are differences in the formal stuff, but I'm not sure that qualifies, and I mostly have informal explanations of them.
10:06:26 <ezzieyguywuf> maerwald: I don' understand your statement about (1) vs (2) though - you're saying xmonad is unmaintained?
10:06:29 <monochrom> I understand now. Was not reading it in context.
10:06:38 <maerwald> ezzieyguywuf: yeah :p
10:06:46 <ezzieyguywuf> i like i3 and have been using it for years, just considering xmonad b/c i love haskell, lol
10:06:48 <monochrom> I went with ghcup for the same reason teeheehee!
10:06:53 <dolio> Like, multiplicative stuff involves concatenating contexts, and additive involves sharing them.
10:06:55 <carter> Dolio: i think that’s the reason why the distributive law only works that way?
10:06:57 <maerwald> well, it's a slim core, so there's not much to maintain?
10:07:02 <ezzieyguywuf> monochrom: lol.
10:07:07 <carter> Hrmm
10:07:14 <carter> I guess that worms
10:07:16 <ski> carter : only works which way ?
10:07:16 <dolio> That's 'formal', but it doesn't say much.
10:07:17 <carter> Works
10:08:01 <carter> Hrmm
10:08:08 <ezzieyguywuf> worms, lol
10:08:19 <carter> I’ll explain after lunch ski
10:08:41 <geekosaur> there's plenty of changes to xmonad-contrib, we just don't release very often unless there's a breaking change in ghc (or even more rarely an external library)
10:08:42 <dolio> Another informal description is, I think, that additive stuff involves one thing happening among many, while multiplicative stuff involves all things happening.
10:08:45 <ezzieyguywuf> btw, `cabal install xmonad` worked once I made sure I had all the non-haskell dependencies avaliable
10:09:20 <geekosaur> and yes, the core is kept very minimal and basically never changes except when a new ghc breaks something
10:09:23 <dolio> So, like A \par B is a branching construct where all the branches happen, unlike A + B where only one branch happens.
10:09:31 <carter> That’s true
10:09:34 <carter> Ish
10:09:59 <ski> yes
10:09:59 <carter> Fork io is kinda a value of type par
10:10:08 <carter> If you think In CPS
10:10:12 <ski> yes
10:10:39 <zebrag> ski: But if, instead of `IO String`, which is a monad, we would have only a functor, then that property of being able to substitute something for a string along the way wouldn't be granted (like if the functor is some constant functor sending every type on the same constant type)
10:10:41 <sclv> as a general gripe, i'm tired of people thinking "infrequently updated" means "unmaintained" as opposed to the cases when it can mean "stable, and working, so not being actively worked on"
10:11:05 <ski> (but `par :: a -> b -> b' is not, i think)
10:11:50 <dolio> carter, ski: That kind of explains why it's related to functions, too. You have two branches: the code in the function, and the code that uses the function's results, and they both happen.
10:12:03 <ski> zebrag : (nitpick, `IO' is the monad. not `IO String', and not `getLine') .. we could still substitute something for all zero occurances of `String's
10:13:22 <ski> dolio : yes. also explains the `A -> B' being equivalent to `not A (+) B' thing
10:13:37 <dolio> Yeah.
10:16:06 <ski> (reminds me of a language (MPD,cf. SR) where, conceptually at least, every function call spawned a thread. depending on how you spawned it, and interacted with it, it could die after delivering back a result message, or persist to receive more messaged along the channel (the name of the function))
10:16:30 <zebrag> ski: (yes, I'm ok with the nitpick, it was only an abuse of language)
10:17:11 <geekosaur> sounds like Icon coroutines
10:20:23 <ski> well, i guess in Icon the thread wouldn't continue executing semi-independently, preemptive concurrence
10:21:01 <ski> zebrag : but yes, you couldn't "substitute" in the manner that `>>=' does it, if that was what you had in mind
10:21:09 <geekosaur> not as normally implemented. I don't know offhand if there's a concurrent Icon
10:24:15 * ski nods
10:24:33 <ski> (i probably should look into Icon, sometime)
10:25:17 <dolio> It doesn't need to be concurrent either, of course. Laziness is a particular choice of which order to process the 'branches that all must happen' in, and call-by-value is another.
10:27:57 * ski nods
10:35:21 <zebrag> ski: yes, it is what I had in mind
10:36:46 <geekosaur> lazy won't work in the case of icon coroutines because you yield a value to the coroutine (think of it as being connected with a pair of MVars, and yield is putMVar on one followed by takeMVar on the other)
10:37:16 <ski> zebrag : you could still do `fmap even (Const "hello" :: Const String Integer)', though
10:38:09 <geekosaur> although there's the degenerate case where what's yielded to the coroutine is the equivalent of Nothing… but then Icon isn't pure so laziness has potential problems
10:38:21 <ski> geekosaur : hmm .. i remember i figured out how to make `zipWith' a "good consumer" of both its list parameters, by thinking of it in terms of coroutines
10:38:46 <dolio> geekosaur: It won't? The general point is that until one of them blocks, nothing forces an ordering.
10:39:07 <dolio> So you can eagerly execute the one that will put, or you can execute the one that will take until it blocks on the take.
10:40:32 <dolio> And it doesn't necessarily matter as long as when something blocks you can go do other stuff to unblock it.
10:40:47 <monochrom> I don't want to perpetuate "c :: F Int menas c contains an Int", because it is not always true, and sometimes it is not even wrong. (In what sense does stf :: S -> (S, Int) contains an Int?) But "pure" is one of the big differences between Functor and Applicative.
10:42:48 <monochrom> To understand how "pure" is special, I take inspiration from how Moggi uses monads. For his use case, he wants to rule out boring examples like Const, so he adds an extra law that's so strong it implies that "pure" is injective. (Now OK, in his time, there was no applicative, only monad, he would be saying "unit" or "eta" or "mu", I forgot which.)
10:43:15 <monochrom> For most useful Applicative instances, pure is indeed injective.
10:44:40 <monochrom> Now if pure is injective, if "pure 4" has to be somehow distinguishable from "pure 5", it does mean that your F Int type has to have at least as much information as Int, internally.
10:45:05 <monochrom> In Shannon's sense of information.
10:47:44 <monochrom> If you further throw in "pure is a natural transformation from Identity to F", then not just as much information, but also as much structure, i.e., the information is not even all that scrambled up badly.
10:48:03 <monochrom> s/throw in/recall/
10:51:59 <dolio> Category theorists might say that whether a value of `Identity Int` contains a value of Int is a nonsense question.
10:52:41 <dolio> Or, more accurately, it is an evil question.
10:52:46 <monochrom> Yeah, at the objects-and-morphisms level, there is not supposed to be "elements".
10:53:37 <dolio> Well, you would know it is a functor on sets, or types.
10:53:50 <dolio> Which have elements/values.
10:54:57 <dolio> But of course, it is also evil to distinguish between Int and other types/sets isomorphic to it.
10:55:49 <monochrom> heh
10:56:46 <monochrom> Then my joke yesterday about "mathematicians, category theorists, Haskellers" was wrong.
10:56:48 * glguy hopes dolio doesn't start passing around a collection plate
10:57:37 <monochrom> Category theorists should be put on the other side. The joke should go like: Category theorists say: "beware of mathematicians and Haskeller's, they're evil"
10:58:20 <monochrom> St. Augustine was the first category theorist! Change my mind.
10:58:39 <dolio> Category theorists aren't so great about not being evil either, really.
10:58:48 <monochrom> OK!
10:58:52 <ski> "wants to rule out boring examples" :(
10:59:23 <ski> ("mu" is for `join'. probably "eta", i'd guess. when / from where did "unit" come to be used ?)
10:59:58 <phadej> eta is unit
11:00:08 <dumptruckman> Can I make a typeclass that pulls the first parameter of a value where it's type may have other parameters?
11:00:26 <phadej> though I forget which way counit/unit in adjunctions are named
11:00:30 <phadej> eta/eps there
11:00:39 <phadej> need more distinct greek letters
11:00:57 <dolio> Unit goes way back to terms from abstract algebra, I imagine.
11:01:01 <ski> phadej : the way that makes the monad one the unit
11:01:45 <ski> dumptruckman : sorry, i didn't understand that, can you elaborate ?
11:01:57 <dumptruckman> like... `class Named a` with a associated function like name ::  a -> String
11:02:18 <dumptruckman> and it's expected that instances of that type have a String as the first parameter of their values
11:02:24 <phadej> ski: makes sense
11:02:27 <dolio> Unit being another name for identity element.
11:02:36 <ski> what does "the first parameter of their values" mean ?
11:02:47 <dumptruckman> data Something = Something String a deriving (Named)
11:03:12 <dumptruckman> and so the name function pulls the string out
11:03:15 <ski> dolio : hm, yea. it makes sense, with the monoid connections
11:03:46 <monochrom> dumptruckman: No.
11:04:16 <ski> dumptruckman : if you really want such a type class, you could make it. however, are you going to define any functions that are polymorphic over types that are instances of this type class ? are you going to have more than one instance of the type class
11:04:48 <dumptruckman> yes
11:05:07 <ski> what's some example of such polymorphic operations ?
11:05:10 <dumptruckman> so I guess each instance would have to define implement name itself?
11:05:19 <dumptruckman> s/define/
11:05:20 <ski> yes, that's how instances work
11:05:27 <dumptruckman> well yeah..
11:05:29 <tomsmeding> well, like, there's generics
11:05:53 <dumptruckman> but like, i don't have to implement anything to use Show for most stuff
11:06:04 <tomsmeding> because Show is hard-wired :)
11:06:04 <dumptruckman> so it has some kind of default implementation that "just works"?
11:06:05 <ski> because `Show' can be derived
11:06:17 <tomsmeding> you can use generics to do what you want, I think
11:06:24 <ski> (and, usually, should be derived)
11:06:24 <tomsmeding> but it's not very pretty
11:06:26 <geekosaur> but you must derive it for it to be there
11:06:35 <dumptruckman> right
11:06:50 <dumptruckman> so i guess it's not an instance of the typeclass if i simply derive that typeclass
11:07:16 <dumptruckman> so i suppose i'm wondering if there's a way to do this without making my data types an instance of it
11:07:26 <monochrom> Rather, "deriving" is not for arbitrary classes of your own design.
11:07:47 <tomsmeding> except for obscure ghc extensions mumble mumble
11:08:15 <tomsmeding> but, yes, in vanilla haskell, "deriving" is only for built-in things
11:09:03 <tomsmeding> dumptruckman: alternative track: what if you define a type 'data CachedShow a = CachedShow String a'
11:09:06 <dumptruckman> ahh
11:09:39 <tomsmeding> and then define 'data Something a = Something (CachedShow a)'
11:09:41 <dumptruckman> ahhh
11:09:44 <dumptruckman> that's a good idea
11:09:46 <tomsmeding> where that 'a' is whatever you want of course
11:09:52 <sm[m]> I got an SDL app working in GHCI by using -fno-ghci-sandbox per https://stackoverflow.com/questions/61842338/creating-an-sdl2-window-inside-ghci . But I'm having trouble getting rid of the window when the app exits. destroyWindow having no effect. Has anyone got this working ?
11:10:10 <tomsmeding> then if you say 'instance Show (CachedShow a) where show (CachedShow s _) = s'
11:10:19 <tomsmeding> and just use 'deriving (Show)' on Something
11:10:36 <tomsmeding> then you get 'Something [whatever that string has]', which is not exactly what you asked, but it's close
11:10:53 <tomsmeding> downside is that now there's a CachedShow constructor in between the Something constructor and the contained data
11:11:02 <dumptruckman> or i could simply do: `data Name = Name String` `name :: Name -> String` ` name (Name s) = s` `data Something = Something name a b c`
11:11:04 <dumptruckman> i think
11:11:05 <tomsmeding> but if you're okay with that, this is a very vanilla way of sort-of getting that :)
11:11:30 <tomsmeding> well 'Something Name a b c', not 'Something name a b c', but yes
11:11:39 <dumptruckman> yes
11:11:41 <dumptruckman> that's what i meant
11:11:43 <tomsmeding> but then you still need to implement Show for Something yourself
11:11:44 <dumptruckman> oh but wait
11:11:50 <tomsmeding> so you haven't won anything
11:11:53 <dumptruckman> and i'd still have to implement name
11:12:01 <dumptruckman> name :: Show -> String
11:12:09 <dumptruckman> er, name :: Something -> String
11:12:10 <ski> tomsmeding : that would be bad, imho :)
11:12:22 <tomsmeding> the point of my solution, with wrapping the rest of the Something contents _inside_ that Name, you can just 'deriving (Show)' and it works
11:12:39 <tomsmeding> ski: yes you haven't won anything and you've made it more complicated :p
11:12:46 <tomsmeding> or are you referring to my CachedShow thing
11:12:47 <ski> (imho, that `Show' instance is incorrect)
11:12:49 <ski> yes
11:12:54 <tomsmeding> sure
11:13:05 <tomsmeding> was just trying to satisfy dumptruckman's wishes :p
11:13:15 <tomsmeding> but I guess yes, perhaps this shouldn't be Show, dumptruckman 
11:13:17 <ski> well .. they didn't seem to ask for `name' to be related to `show'
11:13:24 <tomsmeding> OW
11:13:31 <tomsmeding> my bad
11:13:48 <tomsmeding> okay fair point gimme 1min
11:15:09 <dumptruckman> yeah, i just have a bunch of different data types that all have a name
11:15:18 <dumptruckman> and instead of having a separate name function for each i'd like to just use name
11:15:59 <tomsmeding> okay so am I allowed to cheat and use GeneralizedNewtypeDeriving
11:16:07 <monochrom> Do you really have an algorithm that cannot be written if every type has a separate name function?
11:16:15 <dumptruckman> no
11:16:21 <dumptruckman> it's more of a clarity thing i guess
11:16:22 <monochrom> Then YAGNI
11:16:49 <monochrom> "clarity by overloading names" is in perpetual controversy.
11:16:54 <dumptruckman> so i don't have to do `worldName world` `playerName player` `sharableName sharable` etc
11:17:15 <dumptruckman> it maybe be a case of YAGNI but at the same time, i'd love to learn how to do this
11:17:30 <tomsmeding> dumptruckman: implementation of my wacked idea: https://paste.tomsmeding.com/bSSsxieh
11:17:42 <tomsmeding> 1. the newtype is crucial, 2. you need that HasName in between
11:17:57 <tomsmeding> if you don't want the HasName, you need to use generics
11:18:05 <tomsmeding> or not do this at all :)
11:18:07 <geekosaur> this sounds like the kind of record field problem lens packages are designed for
11:18:19 <ski> dumptruckman : "i just have a bunch of different data types that all have a name","and instead of having a separate name function for each i'd like to just use name" -- that's what i figured possibly was the case :)
11:18:45 <dumptruckman> sorry, i should've just said that but it wasn't immediately obvious to myself
11:18:58 <dumptruckman> tomsmeding: only thing is the tuple feels weird
11:19:01 <monochrom> For learning purpose, just handwrite every instance. You said it, "learning".
11:19:10 <tomsmeding> yeah the tuple is "whatever data you want there"
11:19:20 <tomsmeding> had to put something :)
11:19:21 <ski> dumptruckman : so .. since it seems you don't want to write overloaded polymorphic operations wrt this type class, i'd suggest that it's probably better to not make such a type class
11:19:27 <tomsmeding> RT monochrom 
11:19:34 <monochrom> For thinking purpose, http://www.cs.utoronto.ca/~trebla/CSCC24-2020-Summer/05-haskell-types-2.html#why
11:19:49 <dumptruckman> i'd still like to be able to use the format like `Player { playerName :: String }`
11:20:10 <dumptruckman> i tried to do it where each type was like `Player { name :: String }` but it yelled at me
11:20:45 <dumptruckman> monochrom: haha nice
11:21:53 <ski> monochrom : the law thing is a good point to bring up. perhaps you'd want to add the "have overloaded polymorphic operations defined in terms of methods" point to that, as well ?
11:22:15 <monochrom> That's "can be used to build useful general algorithms"
11:22:19 <ski> tomsmeding : "RT" ?
11:22:23 <tomsmeding> retweet
11:22:29 <ski> mhm
11:22:34 <dolio> I don't see what's wrong with using type classes to overload something like this.
11:22:35 <tomsmeding> except I don't actually use twitter
11:22:39 <ski> (so, i guess, "seconded")
11:22:39 <dolio> I've done it.
11:22:42 <tomsmeding> yes
11:23:51 * ski . o O ( `Default' )
11:24:55 <frdg> I am trying to install a package with stack: https://dpaste.org/6kxx , how do I know what base versions different ghc's have?
11:25:09 <monochrom> You can still set the bar lower or higher regarding how much expectation you expect out of your type class.
11:25:57 <monochrom> For example for a field-name type class like HasName, you still have some expectation, even though it's not as high as Ord's.
11:27:35 <monochrom> In this case the expectation being "the method X -> String behaves like field projection".
11:28:30 <monochrom> You can keep it informal like that, or you can go further formalize it.
11:29:00 <monochrom> You reckon that it doesn't lead to very powerful algorithms.
11:29:36 <geekosaur> (…and then you discover lens)
11:30:30 <monochrom> But lens's potential for powerful algorithms doesn't come from classes like HasName.
11:30:50 <monochrom> It comes from being able to pass a lens as a parameter.
11:31:44 <monochrom> Regarding HasName it's the other way round. The power of lens leads to HasName. HasName leads to not much (apart from what I said), really.
11:33:32 <monochrom> In the case of Default, you have to set the bar pretty low, but it is still not dead zero.
11:34:04 <sm[m]> frdg: memorise https://wiki.haskell.org/Base_package#Versions or https://www.fosskers.ca/en/blog/base in your browser
11:34:23 <monochrom> An expectation is "it's a legal value of your type X, and in a very strong sense: it's also a legal value for all of your functions that take X parameters"
11:34:33 <dolio> Just having things like `HasName` is very useful.
11:34:57 <monochrom> In some cases you also get to expect the default value is also the identity element of a suitable monoid.
11:35:47 <dolio> They're more useful when they're lens type stuff than just `X -> String`, but not necessarily because you can pass them as parameters.
11:36:37 <dolio> Or, well, they're useful because lenses are more useful than projection functions.
11:36:58 <dumptruckman> well how about this... can you explain why `data Player = Player { name :: String }` and `data World = World { name :: String }` can't coexist?
11:37:18 <geekosaur> becuase "name" is defined automatcially as a function
11:37:19 <monochrom> "name" doubles as a function name.
11:37:38 <geekosaur> and it can't simultaneously have type Player -> String and World -> String
11:37:44 <sm[m]> frdg: looks like you should use a newer resolver
11:38:11 <dumptruckman> geekosaur: why not? can't the compiler know which is being called?
11:38:28 <dolio> Not in general.
11:38:40 <geekosaur> there are arguments about type-directed name resolution on the wiki iirc
11:39:00 <geekosaur> it comes up every time this is discussed
11:39:04 <frdg> thanks sm[m]
11:39:06 <monochrom> The compiler knows if you make it a class method.
11:39:08 <tomsmeding> dumptruckman: automatically deriving Named using Generics; please do not do this! :) https://paste.tomsmeding.com/XkbAiiRJ
11:39:13 <geekosaur> and the solution is, basically, lens packages which do HasField
11:39:15 <tomsmeding> wanted to flex my Generics muscles
11:39:41 <dolio> The problem is that TDNR makes very little sense, because type classes are the sensible type for type-directed name resolution, if you ignore the gatekeeping people have been trying to force on you.
11:40:00 <geekosaur> (I recommend fclabels or microlens if you do want to play with that; beware of https://ro-che.info/ccc/23)
11:42:12 <dolio> You don't need any lens packages to just overload 'name' to apply to a bunch of different types.
11:42:28 <dolio> If that's really what you want to do.
11:42:57 <dumptruckman> neat
11:43:05 <dumptruckman> I'll have to read about generics cause that looks crazy
11:43:12 <tomsmeding> again, this is killing a musquito with a bazooka :)
11:43:15 <monochrom> I am not against having HasName. I am against having HasName and ending up not actually using it.
11:43:16 <dumptruckman> particularly all the "junk"
11:43:46 <monochrom> If you don't have an algorithm of type "HasName t => ... t ..." then you don't need HasName.
11:44:25 <dolio> Why? I have overloaded stuff that I don't use generically like that.
11:44:41 <dolio> Because I want to write `peek ustk` and `peek bstk`.
11:44:43 <frdg> it is not clear to me what a resolver is, and which different one I should choose with stack.
11:44:48 <dolio> Where those are different types of stacks.
11:44:55 <monochrom> OK, well, even when I'm against it, it is not 100% against, there are exceptions.
11:45:30 <dolio> I mean, by definition, if you have the class, you have at least one thing like that.
11:45:43 <monochrom> It then comes down to whether overloading the method name improves or impairs clarity.
11:46:23 <dumptruckman> I guess I look at SNR with this
11:47:03 <dumptruckman> in Java I would have an interface Person with method getPersonName and World with getWorldName, i'd have Person with getName and World with getName because it is less noise
11:47:10 <monochrom> No there is no noise here. What you are really looking at is redundancy.
11:47:19 <dumptruckman> s/would/wouldn't
11:47:30 <dumptruckman> how is that not noise
11:47:47 <monochrom> how is that noise instead of redundancy
11:47:50 <dumptruckman> redundancy that doesn't aid with readability, impo
11:47:52 <dumptruckman> imo*
11:48:10 <dumptruckman> it impairs readability by becoming eye strain
11:48:37 <dumptruckman> also it may lead you to wonder if they represent similar things
11:48:44 <dumptruckman> or if WorldName is something different than PersonNAme
11:49:55 <exodrifter> I think "eye strain" is a weak argument? You could install a different color scheme like Solarized. A stronger argument might be "I want to get the name of this entity, and i don't really care what kind of entity it is."
11:50:09 <tomsmeding> what if you define this Named class, giving a 'name' function, but then concede that Generics is too big a gun, and just hand-implement 'name' for each type you want it for
11:50:27 <tomsmeding> 1. you get your noise-less name function, 2. no weird overengineering
11:50:45 <tomsmeding> downside is a little boilerplate when you define the type, but IMO that's minor
11:50:59 <exodrifter> you'd have to do that in java anyway if you implemented an interface
11:51:18 <tomsmeding> indeed :)
11:51:30 <geekosaur> you still need some boilerplate even with Generics
11:51:38 <tomsmeding> true, but less
11:52:24 <monochrom> Like I said, I'm not 100% against it, it depends, there are case-by-case ad hoc judgments to be made.
11:52:42 <monochrom> If you rule that the redundancy helps, keep it. If you rule that the redundancy hurts, remove it.
11:53:19 <monochrom> If you're the sole author and audience, you rule on your own. If you are collaborating with people, you get a consensus.
11:54:36 <dumptruckman> Yeah. Good points. I think individual implementations is probably what I'll go with. It's definitely simple and there's only like 3 types
11:54:37 <monochrom> But me, having learned how people write explicit types even when types are inferred, how people write pointful code even when it could be pointfree, and most importantly how in both cases the more redundant ways actually help,
11:54:54 <monochrom> I decided that in general I keep the redundancy.
11:55:10 <frdg> I am having trouble figuring out how to just say `stack install --with_ghc=8.6.5 somepackage`
11:56:24 <geekosaur> frdg, in general you don't. you say: stack install --with-resolver=<some resolver based on ghc-8.6.5> <somepackage>
11:57:15 <geekosaur> a resolver combines a ghc version with a collection of libraries with versions known to work with each other and that ghc version
11:57:51 <frdg> ok. This must be a big difference from cabal?
11:59:50 <tomsmeding> in my limited experience with stack, it is _the_ most important difference from cabal
12:00:29 <tomsmeding> shoving stuff like "it's a yaml file, not a cabal file (or also a cabal file)" under the ru
12:00:30 <tomsmeding> g
12:01:23 <Boarders> does anyone know if it is possible with earley to easily have "1 + 2 * 3" parse into all possible disambiguations/bracketings?
12:01:55 <phadej> doesn't it give you all parsing by default if you specify ambiguous grammar
12:02:09 <Boarders> I thought so yes, I haven't used it before
12:02:21 <monochrom> I don't know earley, but I know that if a parser supports ambiguous grammars, then "E ::= E + E | E * E | Literal" ought to do.
12:02:43 <Boarders> monochrom: not helpful
12:02:55 <monochrom> Fine
12:03:17 <monochrom> I'm done with askers playing adjudicators and playing GOd.
12:03:35 <Boarders> sounds good
12:04:01 <phadej> using Earley is not much more different than parsec. https://github.com/ollef/Earley/blob/master/examples/Expr.hs
12:04:10 <phadej> not hard to find examples either.
12:04:31 <phadej> (that example is in README, fwiw)
12:05:05 <Boarders> yeah, I don't know how that example can be made ambiguous
12:08:29 <sm[m]> frdg: https://www.stackage.org shows which resolvers to pick for desired ghc versions
12:08:35 <dolio> What happens if you make it into one binding, like `x <- rule $ Add <$> x <* namedToken "+" <*> x <|> Mul <$> x ...`?
12:10:55 <frdg> sm[m]: I struggle with stack. I know that I want to use the lts-14.27 resolver. I cannot say `stack install --with-resolver=lts-14.27 somepackage`
12:11:46 <sm[m]> it's stack install --resolver=lts-14.27 somepackage[-VERSION]
12:12:06 <sm[m]> if somepackage is not in lts-14.27 but only in hackage, then you need to add -VERSION
12:12:36 <frdg> thank you
12:12:55 <sm[m]> (because stack's raison d'etre is reproducible builds, so one way or another all versions must be specified)
12:14:20 <sm[m]> also, if not only somepackage but some of its deps are not in the stackage snapshot, specify those on the command line too (if there's not too many)
12:18:16 <frdg> after installing about 140 packages, right at the end I get this error: https://dpaste.org/rkw3
12:19:17 <sm[m]> that looks like a keter bug then, it probably doesn't have correct bounds
12:19:44 <sm[m]> stack guarantees a valid build plan with all bounds satisfied, but it doesn't guarantee all the packages compile
12:20:39 <frdg> ill try a different resolver
12:20:40 <sm[m]> a typical next move is to check keter's issue tracker or maybe search for the error 
12:20:55 <phadej> thy find a snapshot which has keter
12:21:03 <phadej> it's one of the sad packages
12:21:12 <phadej> https://matrix.hackage.haskell.org/#/package/keter
12:21:42 <sm[m]> https://github.com/snoyberg/keter/issues/207
12:23:06 <frdg> hmm. To be honest I dont understand stack at all. 
12:23:38 <frdg> Ill try cabal
12:24:10 <phadej> you'll get similar-ish failure :)
12:24:41 <frdg> is all lost with keter?
12:24:51 <sm[m]> if you have a look around the issue tracker you'll see lots of such issues. https://github.com/snoyberg/keter/issues/201 has some folks that might help, and maybe a newer branch
12:25:07 <frdg> ok thanks for the help
12:25:55 <dolio> Boarders: https://paste.tomsmeding.com/eFARmyei
12:26:06 <phadej> you need process <1.6
12:26:39 <phadej> which means using GHC-8.0
12:26:47 <phadej> OR downgrading process library
12:26:56 <phadej> which is probably not a good idea
12:27:15 <phadej> but might work too
12:27:34 <phadej> cabal install keter --constraint='process<1.6'
12:28:12 <frdg> Do any other libraries do what keter does?
12:29:15 <phadej> I guess what keter does is handled by modern infrastructure for you
12:31:47 <frdg> I have a Yesod web-app that I am ready to deploy. 
12:33:20 <frdg> I am just going by the yesod documentation which reccomends using keter, but it seems that there are other options. I do not know the tradeoffs.
12:35:30 <sm[m]> frdg: IIRC keter helps minimise downtime and dropped requests while upgrading. If you're fine with just installing the new binary and restarting your app, you don't need keter
12:36:13 <frdg> sm[m]: Yes I am fine with that.
12:36:20 <sm[m]> where are you deploying ? if it has systemd, that's a way to keep your app running
12:36:49 <sm[m]> or you can just run it yourself in a shell session made persistent by dtach or screen
12:36:49 <frdg> I would like to run it from my laptop running opensuse
12:36:53 * geekosaur considers that if it hasn't been updated since ghc-8.0 then it must not be used very much
12:37:35 <sm[m]> frdg: so.. just run it then ? Am I missing something
12:38:22 <frdg> well that is what I have been doing...but that only runs on localhost. 
12:38:45 <sm[m]> for others to access it, you'll run it on a server, like a VPS, right ?
12:39:07 <frdg> oh I have to use a vps?
12:39:15 <frdg> I wanted to just use my computer.
12:40:10 <sm[m]> are you wanting other people to access it ?
12:40:13 <frdg> yes
12:40:45 <sm[m]> while it's running on your laptop, and while your laptop is connected ? that's possible, but not easy and not usual
12:41:28 <frdg> oh really
12:41:44 <koz_> If statistical profiling gives me a lot of variance due to outliers, how do I deal with it?
12:41:49 <sm[m]> "hey frdg, open your laptop so I can access the app!"
12:42:33 <frdg> so usually people use a vps.
12:42:42 <frdg> Only ones I have seen are paid.
12:42:45 <geekosaur> not only that but you won't have a fixed address others could use to access it (I just got booted by my local address changing, for an example)
12:43:38 <geekosaur> names yes, but you'r unlikely to have a name either and if you do it'll be based on the address
12:45:12 <sm[m]> frdg: sometimes people run their own physical server, eg a raspberry pi in a cupboard connected 24/7
12:45:23 <koz_> sm[m]: Or, in my case, an old Eee-PC.
12:45:27 <sm[m]> but yes a vps is by far the easiest
12:45:38 <sm[m]> aha, koz_ knows how
12:45:50 <koz_> I've been on the self-hosting train for a while, lol.
12:46:01 <koz_> Best thing for a starting self-hoster is actually an old laptop IMHO.
12:46:02 <geekosaur> eee pc re-users represent!
12:46:24 <koz_> They're easy to set up, easy to fix if stuff breaks, and have a built-in UPS.
12:46:34 <frdg> I have an old macbook
12:47:21 <koz_> frdg: An old Macbook would work.
12:47:24 <sm[m]> koz_: what's the way to ensure a fixed ip address ? use an ISP that will provide that ?
12:47:41 <nineonine> hey all, I am trying to use hi all, I am trying to use https://hackage.haskell.org/package/process-1.6.10.0/docs/src/System.Process.html#withCreateProcess and sometimes no cleanup is happening
12:47:44 <nineonine> is this expected?
12:47:50 <koz_> sm[m]: That's what I do - mine charges me 10 bucks a month.
12:47:54 <sm[m]> or is a fixed dns name good enough ?
12:48:06 <frdg> koz_: Do I just need to get linux on it?
12:48:08 <koz_> DNS name needs an IP address to aim at.
12:48:12 <koz_> frdg: Yeah, any Linux will do.
12:48:43 <sm[m]> koz_: well there's the dynamic ones where the machine runs a client to update the record on boot
12:48:46 <frdg> ok this may fall perfectly into place.
12:48:56 <koz_> sm[m]: Perhaps, but I've never needed it.
12:49:16 <glguy> My ISP has kept my "dynamic" IP address the same on the scale of years
12:49:24 <nineonine> the process is not getting killed for some reason
12:50:01 <koz_> glguy: Mine flipped my supposedly static one on me once.
12:50:05 <koz_> (that was _real_ fun)
12:50:24 <koz_> (both to diagnose and to subsequently inform customer service in _no uncertain terms_ that this was not good enough)
12:50:29 <nineonine> ok I see this comment in code
12:50:32 <nineonine> terminateProcess does not guarantee that it terminates the process.
12:50:37 <geekosaur> right
12:50:39 <nineonine> which answers my  question
12:50:50 <koz_> terminateProcessMaybe :P
12:51:07 <sm[m]> discourageProcess
12:51:09 <geekosaur> was just about to point out it does terminateProcess and then forkIO-s the following waitForProcess, so in fact it's not cleaned up synchronously at all 
12:51:25 <koz_> sm[m]: 
12:51:33 <koz_> kindlySuggestProcessDie
12:51:35 <nineonine> this is quite deceiving
12:51:54 <koz_> nineonine: Not much we can do about it. Unkillable processes are possible, and Haskell can't really save you.
12:52:04 <koz_> (I had this happen many times due to dodgy drivers)
12:52:10 <geekosaur> ^
12:52:14 <koz_> (ended up with a process even the _OS_ couldn't kill)
12:52:19 <nineonine> makes sense, my hopes were too high!
12:52:44 <davean> well, what OS - a processing being killable or not is an OS thing and some OSes do guarrentee they can
12:52:49 <nineonine> so I guess this is an OS quirk
12:52:53 <davean> its specificly POSIXy systems that usually have an issue with it.
12:52:56 <Boarders> dolio: thanks for your help!
12:53:46 <geekosaur> there's also a harder kill than SIGTERM, not that it's guaranteed either — but some processes do ignore SIGTERM for no good reason
12:53:46 <sm[m]> btw there's no reason frdg has to install linux on their macbook megaserver I assume
12:53:50 <koz_> davean: Well, it was a Linux thing, so yeah. Who guarantees process death?
12:54:04 <koz_> sm[m]: No _specific_ reason, no.
12:54:14 <koz_> I'd say it's easier for me to self-host on a Linux, but YMMV.
12:54:50 <monochrom> I think it's easiest if the OS used for compiling is the same OS used for running.
12:55:20 <monochrom> For example totally don't go "I dev on Windows, deploy on MacOS", that's insanity.
12:56:12 <monochrom> You really don't need one more gratuitous variable in your journey.
12:57:31 <sm[m]> frdg has an old working macbook and is a bit over their head already, personally for me installing linux on a mac would be a nightmare
12:58:08 <koz_> monochrom: Yeah, you're right. I'm merely speaking from my own experience here, and I'm Linux through-and-through.
12:58:14 <koz_> (both personally and for work)
12:58:35 <sm[m]> getting offtopic here, but I think the real challenge here will be the connectivity (getting through firewalls, setting up dns or static ip)
12:58:48 <nineonine> so any idea how can I ensure the process is being killed?
12:58:53 <davean> koz_: well its a permissions issue on some OSs (suposibly windows), and others lack the IO hole POSIX systems tend to have (embeded OSs)
12:59:04 <nineonine> can I do something nasty like grep by process name and kill it?
12:59:09 <nineonine> using shell
12:59:17 <koz_> nineonine: That might not necessarily work either.
12:59:18 <nineonine> (just in case)
12:59:21 <nineonine> doh!
12:59:23 <frdg> in the end Ill figure something out. All I want is to avoid pain. 
12:59:29 <koz_> As I said - I've managed to get an unkillable process even at the OS level.
12:59:35 <koz_> (due to bad driver)
12:59:36 <nineonine> this is horrible
12:59:37 <monochrom> I think it's useful to first find out why the process is not terminating.
12:59:46 <sm[m]> nineonine: pgrep & pkill are your friends!
12:59:52 <davean> nineonine: is that the *kernel* can't kill it
12:59:58 <davean> often
12:59:58 <sm[m]> oh sorry.. carry on
13:00:15 <davean> for example Linux can't kill a process blocked on IO (This is basicly the POSIX OS issue in general)
13:00:18 <nineonine> it is pretty hard to reproduce
13:00:55 <sm[m]> frdg: what's more painful, $5/mo or 5-50 hours of system administration :)
13:01:12 <monochrom> I don't know if you already know, but if Unix, terminateProcess is just SIGTERM.
13:01:16 <davean> nineonine: if you want to generate an unkillable process on POSIX its generally pretty easy using NFS and just removing the server ;)
13:02:17 <nineonine> right, that makes sense. the fact that there is no guarantee about terminating the process is quite surprising to me :D
13:02:25 <monochrom> Haha NFS brings fond memory.
13:02:33 <davean> nineonine: really its the "worse is better" issue
13:02:53 <davean> Infact the only OS family I know that has this issue *is* POSIX
13:03:01 <davean> I don't know of this being able to happen anywhere else.
13:04:18 <monochrom> Old school lab used to be like, every last day of semester, reliably, NFS crashed by overloading, all processes blocked and unkillable, you couldn't even log out. (Because, like, logging out requires checking your home directory for .logout but it's through NFS but NFS is not responding...)
13:05:46 <sm[m]> there is a way to guarantee termination, and that's to reboot the machine
13:06:06 <glguy> cut power; I've had reboots fail :)
13:06:08 <sm[m]> right ? or is even that impossible, without a hardware switch ?
13:06:33 <sm[m]> ack
13:07:36 <monochrom> We students didn't bother to power cycle for many reasons. In this case, turning off would be OK, but turn on would be pointless.
13:07:54 <glguy> It would be pretty nifty if having a process stalled on an NFS mount make it so that not even cutting power was enough to kill the process.
13:08:07 <glguy> you just were left with a permanently on computer!
13:08:25 <monochrom> That's like defy the 2nd law of thermodynamics.
13:08:36 <davean> sm[m]: you can't guarrentee a reboot :(
13:08:38 <glguy> sure, but we're talking about NFS
13:08:48 <monochrom> hahaha OK fine just cause!
13:09:06 <monochrom> "NFS solves the halting problem!"
13:09:07 <davean> You know they use to write persistent OSs?
13:09:19 <davean> you removed power, you plugged it back in, and it would be exactly where you left it
13:09:23 <davean> that was a thing in the 70s
13:09:33 <davean> The entire OS was transactional.
13:09:52 <davean> There were a few of them, I forget which at this point though
13:10:15 * sm[m] gets itchy for new OSs
13:10:47 <monochrom> Well yeah, more seriously you could say "turn off" means use a bit of reserve battery to save state and then turn off.
13:11:25 <monochrom> Or even you always have autosave so it's close enough.
13:11:54 * monochrom thanks AoE2 DE for having frequent autosave, like only 2 minutes lost in the worst case
13:12:06 <davean> Yah no the processes couldn't tell
13:12:11 <davean> The memory came back the same.
13:12:19 * hackage uniqueness-periods-vector-examples 0.4.0.0 - Examples of usage for the uniqueness-periods-vector series of packages  https://hackage.haskell.org/package/uniqueness-periods-vector-examples-0.4.0.0 (OleksandrZhabenko)
13:12:25 <davean> well the same as the last consistent state, which you couldn't have observed past
13:35:50 * hackage stratosphere 0.59.1 - EDSL for AWS CloudFormation  https://hackage.haskell.org/package/stratosphere-0.59.1 (jdreaver)
13:53:50 * hackage esqueleto 3.3.4.0 - Type-safe EDSL for SQL queries on persistent backends.  https://hackage.haskell.org/package/esqueleto-3.3.4.0 (parsonsmatt)
13:54:49 * hackage RtMidi 0.4.0.0 - Haskell wrapper for RtMidi, the lightweight, cross-platform MIDI I/O library.  https://hackage.haskell.org/package/RtMidi-0.4.0.0 (ejconlon)
14:08:16 <dumptruckman> what is happening... getting this: `name' is not a (visible) method of class `NamedEntity'
14:08:38 <dumptruckman> class NamedEntity a where name :: a -> String
14:08:50 <dumptruckman> instance NamedEntity Sharable where name (Sharable s) = s
14:08:59 <ski> you only exported the type class, not its method
14:09:04 <dumptruckman> ohh
14:09:25 <ski> use `module Blah (....,NamedEntity (name)) where
14:09:28 <ski> '
14:09:45 <dumptruckman> sweet, thanks
14:09:57 <exodrifter> (or wherever you imported it `import Blah (NamedEntity (name))`)
14:10:17 <ski> (that too, if you have an explicit import list)
14:10:41 <exodrifter> right, if you have an implicit import like `import Blah`, should be fine.
15:22:01 <Guest_79> Hi all
15:22:29 <Guest_79> got an issue with installing haskell on Debian 10
15:22:45 <Guest_79> [ ghc-configure ] checking for gsed... sed
15:22:46 <Guest_79> with NonZeroExit 1 "./configure" ["--prefix=/home/user/.ghcup/ghc/8.8.4"]
16:04:50 * hackage aeson-injector 1.1.4.0 - Injecting fields into aeson values  https://hackage.haskell.org/package/aeson-injector-1.1.4.0 (NCrashed)
16:26:29 <sshine> that point in the night when you realize DeriveFunctor will not give you (>>=).
16:37:28 <koz_> sshine: DeriveMonad is, AFAIK, not a thing. :P
16:37:38 <davean> sshine: really a failing of the extension and a critique of Haskell as a language.
16:37:54 <davean> koz_: why would you need it with the other deriving stuff we have now? :)
16:38:03 <koz_> davean: Lol.
16:38:04 <davean> also why would you use DerivingFunctor now that we have the nice tools?
16:38:10 <davean> we cleaned that mess up
16:38:18 <koz_> You can derive Traversable, what else do you possibly need? After all, traverse does everything. :P
16:53:29 <monochrom> DeriveWhatIMean = DWIM :)
16:55:04 <koz_> DeriveAllOfTheThings
17:50:35 <josh> anyone know if there is a Stack equivalent of "cabal install --lib"? I need to build a shared library, but building with Stack gets me out of dependency hell
17:56:33 <sclv> josh: not really. the dependencies are precisely what you need to worry about with shared stuff
17:56:51 <sclv> if you're in trouble with them, you can always clean your env file and start fresh with a new one that you simultaneously install all the libs into you want
17:56:56 <sclv> or use one of the env management tools
17:57:11 <sclv> why does it need to be shared anyway?
17:57:30 <josh> so I can call it via JNI
17:57:54 <sclv> oh, yeah fair dos!
17:58:07 <josh> yes, for now I have had success just deleting ~/.cabal between builds, but was thinking there must be a better way
17:58:22 <sclv> you don't need to delete the whole ~/.cabal thing
17:58:28 <sclv> just locate and clean out the ghc environment file
17:58:45 <sclv> also you can specify any old env file you want, instead of the main one
18:00:19 <josh> ~/.cabal/store/ghc-xxx?
18:01:10 <sclv> josh: https://ghc.gitlab.haskell.org/ghc/doc/users_guide/packages.html#the-ghc-package-path-environment-variable
18:01:54 <sclv> usually $HOME/.ghc/arch-os-version/environments/[name]
18:01:56 <josh> reading/learning; thanks
18:01:59 <sclv> where [name] by default is `default`
18:02:17 <sclv> installing the with --lib puts the package into the store and _also_ modifies that env file
18:02:27 <sclv> you can tell cabal to use a different env file and tell ghc to use that
18:02:32 <sclv> or just clean that env file regularly
18:03:46 <josh> ah, great. That seems like a good way to keep my JNI build and "ordinary" build separate
20:10:50 <beka> is there a way to parse haskell-style types with expression parsers?
20:11:46 <perdent> Anyone here wanting to code a perl CGI vulnerability for a 'hacking' CTF, I will pay money, Query me with more info if interested
20:14:21 <perdent> code a haskell vulnerability*
21:08:14 <jchia> aeson/lens question: How can I make sure a Value that is an Object contains an empty Object "a.b.c", a la "mkdir -p"? E.g. if the input is {"x": 1}, the output should be {"a": {"b": {"c": {}}}, "x": 1}.
21:08:36 <jchia> I'm working entire with Value and not with any of my own types.
21:09:25 <jchia> if an Object a.b.c already exists then output is the same as input.
21:10:35 <jchia> If an Object a.b already exists but it has no c, then c gets added to a.b. If it has a c that is not an Object, then it's an error (I can make the function produce a Maybe Value to allow for errors).
