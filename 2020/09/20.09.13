02:36:50 * hackage hascard 0.4.0.0 - A TUI for reviewing notes using 'flashcards' written with markdown-like syntax.  https://hackage.haskell.org/package/hascard-0.4.0.0 (Yvee1)
02:42:35 <sshine> does Hedgehog have something alike 'suchThat'?
02:53:53 <sshine> I just love property testing.
02:54:10 <sshine> it is *so* often that my property tests tell me I'm totally forgetting a corner case.
02:54:37 <sshine> but this time I actually had to increase the test count. -_- so there is some navigation, too.
03:46:29 <rain1> $ cabal install
03:46:30 <rain1> cabal: MainBoth.hsMainSDL.hsMainCurses.hsMainBoth.hs doesn't exist
03:46:32 <rain1> How do i fix this?
03:46:36 <rain1> im on arch linux
03:47:14 <lemmih> rain1: What are you trying to do?
03:47:36 <rain1> i downloaded a folder of haskell code and i want to run it, it uses sdl
03:48:24 <lemmih> Do you have a link to the code?
03:48:49 <rain1> https://mbays.freeshell.org/intricacy/
03:50:55 <lemmih> rain1: Run 'cabal build'
03:51:40 <rain1> i got a lot of errors with cabal build
03:52:00 <lemmih> Do the errors say that you don't have SDL installed?
03:52:22 <rain1>     Could not find module ‘Prelude’
03:52:24 <rain1> is the first one
03:52:53 <lemmih> That's kinda weird. Try 'cabal v2-build'.
03:52:54 <rain1> i think i do have SDL
03:53:10 <rain1> I seem to get the same errors with v2-build
03:58:51 <[exa]> rain1: perhaps pastebin the full error message?
03:59:26 <lemmih> rain1: The game builds fine for me with 8.8.4
03:59:34 <maerwald> the package is buggy (the flags are)
04:00:20 <rain1> https://bpa.st/4UAA
04:00:31 <rain1> The Glorious Glasgow Haskell Compilation System, version 8.10.2
04:00:34 <rain1> cabal-install version 3.2.0.0
04:00:37 <rain1> these are my versions
04:01:33 <lemmih> Your GHC installation might be broken.
04:01:42 <lemmih> Try running 'ghc-pkg check'
04:01:47 <maerwald> rain1: distro?
04:01:50 <maerwald> how did you install
04:02:09 <rain1> arch linux
04:02:13 <rain1> pacman -S ghc cabal-install
04:02:26 <maerwald> arch linux is broken crap
04:02:28 <rain1> Warning: haddock-interfaces: /usr/share/doc/haskell-zlib/html/zlib.haddock doesn't exist or isn't a file
04:02:33 <rain1> i got a lot of errors like this
04:02:41 <maerwald> that's because ghc in arch is broken
04:02:43 <maerwald> delete it
04:03:22 <maerwald> must be the 9000th time arch users come in here with that problem... please tell your maintainers to remove all haskell stuff 
04:03:38 <[exa]> rain1: highly suggest using ghcup instead, see https://gitlab.haskell.org/haskell/ghcup-hs
04:04:13 <rain1> but they don't listen to me they just insult me when i tell them they package languages wrong
04:04:20 <rain1> we have the same problem with python ruby node etc.
04:04:20 <maerwald> switch distro
04:04:24 <maerwald> srsly
04:04:39 <rain1> maybe..
04:04:40 <[exa]> rain1: anyway the errors are most likely arising from arch packaging of haskell + libraries, which is targeting something completely different than developers
04:05:11 <[exa]> other distros are better (sometimes) but not at all completely fine; I guess that just about everyone uses some variant of local non-system ghc now
04:05:47 <[exa]> rain1: arch is otherwise a comparably good distro but this _is_ broken. :]
04:06:12 <maerwald> it isn't a good distro :)
04:06:26 <[exa]> I never used it but lots of people around love it, and it has a good wiki
04:06:38 <[exa]> and I'm always getting gentoo vibes from the wiki, "really teaches you to fix your stuff"
04:06:40 <rain1> can you recommend others, if i get a new hard disk i might try another distro
04:06:41 <[exa]> that kind of good. :D
04:06:44 <maerwald> I've used it long enough and packaged for it. It's bad
04:07:05 <phadej> I prefer distros where stuff works, and I don't need to read wikis to how fix shuff :P
04:07:08 <maerwald> rain1: fedora if you don't care about configuring every single piece
04:07:16 <[exa]> rain1: I'm running debian testing, as soon as you get used to the debian attitude to packaging, everything is great
04:07:56 <Chousuke> arch feels like sort of a build-your-own-thing with precompiled packages than an actual distro.
04:08:10 <maerwald> phadej: arch wiki isn't even a knowledge database, it's mostly a "how do I fix X as quickly as possible without understanding anything" compendium
04:08:14 <[exa]> yeah, kinda gentoo vibes
04:08:42 <[exa]> rain1: despite of all this, just go for ghcup now :D
04:09:07 <maerwald> anyway, fedora/opensuse are amongst the distros with the most competent packagers and strict policies
04:09:55 <phadej> maerwald: to be fair, I remember reading arch wiki to figure out why my ubuntu stuff is broken
04:10:09 <Chousuke> Fedora gets a vote from me too. Especially if you actually like using Gnome :P
04:10:17 <maerwald> phadej: that's an easy read: because it's ubuntu :p
04:10:39 <phadej> maerwald: ok.
04:11:05 <rain1> thanks
04:11:14 <phadej> this distro war seems to be even more divine than editor one.
04:11:31 <maerwald> phadej: nah, I'm joking... ubuntu is fine-ish
04:11:42 <maerwald> the only thing I look at wrt distros is packaging quality
04:11:53 <maerwald> debian isn't the highest there, but not bad
04:12:38 <maerwald> they have a few policies that are too lax
04:12:45 <[exa]> maerwald: you didn't see the wonderful debhelper yet, did you? :]
04:12:50 <maerwald> (e.g. about downstream patching)
04:13:01 <[exa]> also lintian
04:13:56 <maerwald> also, the world will never forget how debian broke ssl
04:14:28 <[exa]> yeah that was fun
04:14:36 <merijn> I think most of the world already forgot :p
04:15:00 <maerwald> the bad thing about it isn't the incompetence of the maintainer
04:15:07 <maerwald> but the fact that it slipped through
04:15:15 <maerwald> which means workflow is bad
04:15:46 <phadej> fedora never had any major failures?
04:15:57 <phadej> I guess quite a pressure on their maintainers now. "must not make mistakes"
04:16:12 <maerwald> I think no distro had an error as bad as that one :p ...at least I don't recall
04:16:26 <maerwald> Gentoo broke ffmpeg once, completely, with a downstream patch
04:16:29 <maerwald> but that's about it
04:16:49 <phadej> ok. Maybe debian people have learned their lesson too. I dunno.
04:16:59 <maerwald> most distros take security relevant packages seriously
04:17:16 <maerwald> there's a chance libressl patches are wrong in many distros though
04:17:26 <maerwald> because you need lots of downstream patches for it
04:17:35 <phadej> who cares, https://hackage.haskell.org/package/tls (note: plenty of sarcasm here)
04:17:42 <maerwald> phadej: haha
04:18:18 <maerwald> rust tls got audited
04:18:34 <phadej> is it continuous audit, on every change?
04:18:39 <maerwald> not sure how much those audits really give you though
04:18:39 <phadej> (or regularly)
04:18:49 <maerwald> yeah, probably once
04:19:31 <maerwald> I'm just hoping project everest stops being an expensive research project and turns out to be something practical at some point
04:20:26 <maerwald> With all the engineering power in the world, I'm confused why it doesn't get more attention. Seem ppl already forgort heartbleed
04:20:45 <phadej> C-libraries are nice, as I'd expect that researches use them (more often) as "let's see if our tool can find bugs"
04:21:31 <phadej> sadly, many academic tools aren't really up to quality to be run continuously
04:22:26 <merijn> phadej: Did you read the article about taking Coverity from research project to "industry"? It's interesting :)
04:22:46 <phadej> not familiar
04:23:17 <maerwald> we need more measlantkering projects... maybe a space station to guard us from aliens... that would probably make ppl care about correct software :p
04:23:22 <merijn> phadej: Coverity is basically static analysis for C/C++ (and I think Java?), they wrote an CACM article about the experience of moving out of academia: https://cacm.acm.org/magazines/2010/2/69354-a-few-billion-lines-of-code-later/fulltext
04:23:33 <rain1> what is project everest?
04:23:47 <maerwald> https://project-everest.github.io/
04:23:49 <[exa]> maerwald: 'measlantkering' is english?
04:23:56 <merijn> maerwald: s/ea/ae :p
04:24:08 <merijn> [exa]: It's (part of) the Deltaworks
04:24:25 <merijn> There's actually a fascinating pragmatic paper on the usefulness of formal methods in its design
04:24:31 <maerwald> yep
04:24:41 <merijn> [exa]: Specifically, it's the part the controls the stormsurge barrier to the port of Rotterdam
04:24:53 <rain1> wow that sounds amazing
04:24:55 <maerwald> they went full spec language on it (Z I think) and then emitted C++ code
04:25:01 <[exa]> oh cool
04:25:03 <maerwald> with minimal post-generation changes
04:25:09 <merijn> [exa]: Since the port is (one of?) the biggest in the world, leaving closure to human intervention was deemed to dangerous
04:25:33 <merijn> [exa]: Because unnecessary closure costs billions, but also avoiding closure due to economics jeapordises the entire area
04:26:30 <[exa]> is the language spec somewhere? (btw the approach seems right, make tools to make tools)
04:26:47 <maerwald> but it isn't your average agile project... requirements were pretty clear, so you can model the domain inside out and formally describe it without your boss coming in tomorrow and demanding the opposite
04:26:48 <merijn> No clue, tbh
04:27:46 <merijn> maerwald: Well, the main take away from the engineers was that they didn't think the formal verification actually caught many errors, *but* the act of designing things so they could be formally verified and thinking about that *did*
04:28:15 <maerwald> merijn: they also argued it actually would have taken more time to do it without a long spec-period
04:28:51 <maerwald> ppl in industry, even automotive, seem to think formal methods will make the project go slower
04:29:00 <maerwald> which might be false
04:31:38 <[exa]> +1
04:32:07 <[exa]> what's that called... testing the specification?
05:33:51 <ggole> model checking?
05:50:36 <Uniaika> ./9
06:15:17 <ollehar> are orphan instances the only way to split a module into several files?
06:17:10 <lemmih> ollehar: If you don't want the instances in the same module as the data-types, yeah.
06:20:29 <ollehar> lemmih: ok
06:20:52 <ollehar> lemmih: what if some types are abstract in that module? then instances have to be in the same file?
06:21:15 <ollehar> or, maybe I want the instance in the same module but not the same file?
06:22:06 <lemmih> ollehar: I'm not sure what you're trying to do.
06:32:19 <ollehar> lemmih: not putting everything in one file :D
06:32:32 <ollehar> mostly investigating different languages' ability to split modules.
06:32:46 <ollehar> this one-file-one-module/class is maybe not such a good dea.
06:33:05 <dmwit> ollehar: They can be in the same file as the class declaration and not be orphans.
06:33:31 <dmwit> precision: same *module* as the class declaration
06:34:22 <ollehar> dmwit: yes, but not one module in two files?
06:34:55 <dmwit> GHC does not support splitting modules across files. There is in principle no reason that it cannot; the Report doesn't say anything about how modules should be stored.
06:34:58 <lemmih> ollehar: One module cannot be defined in two files.
06:35:13 <dmwit> You could put them all in a database as far as the spec is concerned.
06:35:22 <ollehar> hm ok
06:35:28 <ollehar> just praxis, then.
06:35:31 <lemmih> And the spec doesn't matter as far as users are concerned. :)
06:35:39 <ollehar> hehe
06:36:12 <ski> ollehar : you could define the type in one module, have the instance declaration(s) in another module (importing the first), and then have a third module which (re)exports the type abstractly
06:36:17 <lemmih> Most Haskell compilers support recursive modules without boot files (as allowed by the spec). GHC does not. GHC wins.
06:39:37 <giaco> Hello! I'm learning haskell via learnyouahaskell.com. In "Typeclasses 101" it says that what "read" function does, but it seems to work different on my ghci 8.8.4
06:40:21 <ski> in what way ?
06:41:02 <giaco> ski: read "4" returns *** Exception: Prelude.read: no parse
06:41:21 <ski> > read "4" :: Integer
06:41:24 <lambdabot>  4
06:41:29 <ski> > read "4" :: Bool
06:41:31 <lambdabot>  *Exception: Prelude.read: no parse
06:41:32 <[exa]> giaco: if cannot guess what type you attempt to parse from this context, so you need to put that information there manually
06:42:15 <giaco> [exa]: I understand that (it's the chapter topic), but here http://learnyouahaskell.com/types-and-typeclasses you can see that read "4" returns a different error
06:42:22 <ski> try ascribing the type you intend, with `::', when you test in the interactor, and the rest of your query doesn't already tell the system what type it is meant to try to read as
06:43:10 <giaco> I mean "Ambiguous type variable `a' in the constraint: ..."
06:43:30 <ski> i think GHCi adds another default that makes it try `read "4" :: ()', if it doesn't know another type to try
06:43:34 <[exa]> giaco: oh, you can do that too, if you turn off type defaulting. ghc attempts to resolve ambiguities by putting in the most probable types, sadly here it's ()
06:44:01 <[exa]> s/probable/default
06:44:11 <ski> giaco : try `read "()"', and see whether that gives an error or not
06:44:41 <giaco> read "()" returns (), no error
06:44:54 <ski> right, because it defaults to the type `()'
06:45:00 <[exa]> anyway this is usually not an issue, try:
06:45:05 <[exa]> > read "3" + read "5"
06:45:07 <lambdabot>  8
06:45:13 <giaco> how do I know which is the default type?
06:45:47 <giaco> I understand that an expression may lead to ambiguous type, I'm just playing around this condition to don't get stuck later on
06:46:06 <[exa]> ^ from (+) it sees that the type needs to be numeric, and the most default type with Num is Integer, so it uses that
06:46:11 <[exa]> hm there's a list somewhere
06:47:29 <dmwit> giaco: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html#extension-ExtendedDefaultRules has the details of how ghci differs from standard Haskell
06:47:58 <dmwit> (It also points at the section of the Report that describes what standard Haskell does.)
06:48:24 <ollehar> ski: ok, I guess.
06:48:27 <dmwit> Together they should be a complete answer to "how do I know which is the default type".
06:49:45 <ollehar> OCaml does it (one module per file), Java does it (one class per file). What's the deal with putting everything in one file???
06:50:04 <giaco> thanks for the link. Quite a lot of in depth information there, I need some time to get to the list
06:50:16 <ollehar> Why not have a folder as basis for a module/class instead?
06:51:04 <lemmih> ollehar: Why not use smaller modules?
06:51:26 <dmwit> One file per module seems like a very natural choice. So I think your question is backwards. The thing that must be defended is the unnatural choice, not the natural one.
06:51:49 <lemmih> ollehar: It's common to have many small modules that are re-exported by a parent module.
06:51:51 <ollehar> lemmih: I'm thinking composition violages encapsulation.
06:51:51 <dmwit> One directory per module is not super unnatural, so it doesn't require much defense, mind.
06:52:07 <ski> sometimes i've wanted local modules
06:52:11 <ollehar> lemmih: re-exported? and then the super-module becomes the lib?
06:53:17 <ski> (although i guess with a proper `local'-`in', there'd be less call for that)
06:53:27 <giaco> I have a complete different question. While learning haskell it would be helpful to use one of such IDE that gives plenty of static anaysis/autocompletion/help and stuff like that. Which one would you suggest? I tend to use vim daily, but for haskell I'd be happy to move to something completely different if that would teach me better and faster
06:53:46 <lemmih> ollehar: I don't understand what you mean. I think we have different terminology.
06:55:43 <ski> giaco : hm. i'm not too sure it would be helpful
06:56:23 <lemmih> giaco: VS Code is quite good. It highlights your errors, can insert type signatures, and can evaluate Haskell snippets.
06:57:06 <giaco> lemmih: thanks, I was hoping that. VS Code is my best second choice
06:57:09 <Rembane> giaco: If you have setup LSP in vim there is a language server for Haskell 
06:57:43 <[exa]> giaco: btw the 'vim approach' would be to run hlint on your code and observe what it thinks about it. It was pretty useful for the beginning.
06:58:57 <ski> giaco : i'd probably suggest just playing around a lot in the interactor
06:59:03 <giaco> [exa]: I think I already have it running as I use "ale" linting engine and probabily it picked it up automatically when I installed ghc
06:59:33 <giaco> ski: sure, that's what I am doing now. lernyouaahaskell.com on the left, interactor on the right
07:00:47 <dyeplexer> > 1 --test
07:00:49 <lambdabot>  1
07:01:15 <[exa]> giaco: that also works for normal development btw, there's :load and `cabal repl`
07:01:55 <ski> giaco : also an editor, for saving all but the most trivial testing definitions
07:02:47 <giaco> again another different question (hopefully not asking what would be covered on the book later on). Is it possible to get the typeclasses of a variable?
07:03:15 <dmwit> > 1 --* bullet point in your comment
07:03:17 <giaco> eg, if I do :t 'B' it returns Char, but I want to get eg. Enum, read
07:03:18 <lambdabot>  <hint>:1:20: error: <hint>:1:20: error: parse error on input ‘in’
07:03:31 <ski> giaco : you can do `:i Char'
07:03:44 <giaco> cool! Thanks :)
07:04:50 <ski> (you can also use `:i' on defined value names, like `length',`max',&c.)
07:09:59 <giaco> here https://en.wikipedia.org/wiki/Haskell_(programming_language)#/media/File:Base-classes.svg I see a tree of the base (type)classes. Is it possible, to get the :i in tree form?
07:11:29 <giaco> I mean, when I do :i Float, I get a list of typeclasses apparently unordered, or maybe ordered according to this parent-child relationship that seems not obvious to me
07:13:18 <ski> afaik, no
07:13:49 <giaco> k thanks
07:14:37 <giaco> on the other hand, is there a resource where I can get all the functions that each typeclass provides?
07:15:27 <lemmih> giaco: Like ':i Num' ?
07:16:10 <giaco> lemmih: sorry, apparently I've been always placing types instead of typeclasses after :i so far :D my fault. Thanks
07:17:41 <ski> `:i' is `:info', gives you information about a name. could be a name of a value, a type, a data constructor, a type class
07:18:38 <ski> while `:t' (or `:type') infers the type of an expression (could be complicated, doesn't have to be just a name, or a constant literal)
07:18:49 * hackage plugins 1.6.1 - Dynamic linking for Haskell and C objects  https://hackage.haskell.org/package/plugins-1.6.1 (JeremyShaw)
07:19:30 <lemmih> giaco: ':i' is quite versatile. Back when we partnered with the NSA, it could also give you personal info about people. We had to disable that feature, though.
07:32:07 <giaco> haha
07:38:27 <giaco> > :i fromIntegral
07:38:30 <lambdabot>  <hint>:1:1: error: <hint>:1:1: error: parse error on input ‘:’
07:38:53 <giaco> oh, sorry bot. At least I tried
07:39:14 <dyeplexer> :i fromIntegral
07:39:53 <dyeplexer> oops
07:39:59 <dyeplexer> does haskell resolve recurrence relations into iterative solutions or is its system built around the efficient execution of these recurrence relations?
07:40:13 <dyeplexer> I assume the latter
07:41:20 <wasm> hi
07:41:39 <wasm> what do people use to colorize ghci?
07:42:23 <lemmih> dyeplexer: The difference between a loop and a recursive function really isn't that great.
07:43:01 <dmwit> dyeplexer: I think you probably mean "recursive function" rather than "recurrence relation". GHC is built around the efficient execution of recursive functions.
07:43:46 <Rembane> A thought just struck me. Can you get a stack overflow in GHC's Haskell because of too much recursion? 
07:44:13 <dmwit> (It's possible that "recurrence relation" is also technically correct, but most people use "recurrence relation" specifically for those recursive equations that come up in complexity analysis.)
07:44:36 <[exa]> Rembane: there's no actual stack, so generally not
07:44:39 <dmwit> Rembane: You used to be able to. Now it's much harder, because the stack is put on the heap and therefore can grow up to the amount of memory you have.
07:44:56 <dyeplexer> For example, a loop that counts to 10 in C will require 10 records in the function stack. Haskell, I think manages this more efficiently than that.
07:44:58 <dyeplexer> Okay
07:45:23 <dmwit> Well, the amount of memory you have - the amount of memory you're using for other stuff than the stack, obviously. Anyway usually the stack is too small to hit that limit.
07:45:31 <Rembane> [exa]: Is that really so? I have seen the stack somewhere, but I can't remember where, and your statement contradicts dmwit's statement which makes me even more cofused. 
07:45:54 <dmwit> dyeplexer: There isn't really a function stack in the same way in Haskell.
07:46:06 <dmwit> dyeplexer: There's an excellent paper about it if you're interested in learning those nitty-gritty details.
07:46:09 <dyeplexer> Yes, that was what I was thinking
07:46:11 <lemmih> Rembane: It becomes easier if you limit to stack size to, say, 16 bytes. :)
07:46:23 <Rembane> lemmih: ^^
07:47:06 <lemmih> If you actually wanna do it: +RTS -K16 -RTS
07:47:07 <giaco> I'm getting quite confuse about what can I do with ghci and what not. For example typing "factorial :: (Integral a) => a -> a" returns "Variable not in scope: factorial :: a1 -> a1", but that would work inside an hs file
07:47:13 <[exa]> Rembane: the "stack" is basically something like a linked list of closures now... there was a way to overflow the actual underlying C stack of the RTS by evaluating "thunk in thunk in thunk in thunk in ..." but that was fixed somehow
07:47:25 <dmwit> giaco: For multiline things, you must start multiline mode with :{
07:47:35 <dmwit> giaco: When you have finished the multiline thing, end multiline mode with :}
07:47:51 <giaco> dmwit: sad face, smiley face. Got it, thanks
07:47:57 <Rembane> [exa]: Thank you, this makes me much less confused. That's kinda funny, that if there is a thing called stack in the GHC RTS, it isn't a stack anymore. 
07:48:04 <dmwit> giaco: (Indeed, it would also be the case that if you *only* put that into a file, you would get that error.)
07:48:58 <giaco> dmwit: I do get the logic, but I didn't know about the multiline mode yet
07:49:00 <dmwit> giaco: You can think of it a bit like the {} of explicit block syntax, but with a : to let you know it's ghci-specific. =)
07:50:04 <dmwit> There's also an "automatic multiline" setting, which sometimes does the Python thing of allowing you to enter multiline mode based on the syntax it sees, and waiting for a blank line to exit. But it wouldn't trigger in this case.
07:50:22 <giaco> now I also understand why doing "factorial n = n * factorial (n - 1)" and then "factorial 5" returned "*** Exception: stack overflow"
07:50:26 <dmwit> It triggers only on block heralds, so things like `where`, `case`, `let`. Maybe also for unclosed parentheses, I'm not sure.
07:50:27 <dyeplexer> dmwit: do you mind giving me the name of that paper?
07:51:12 <dmwit> dyeplexer: Implementing lazy functional languages on stock hardware: the Spineless Tagless G-machine
07:51:20 <dyeplexer> Thanks
07:51:27 <dmwit> http://twister.43foldrs.com/spineless-tagless-gmachine.pdf
07:52:24 <dmwit> giaco: right!
07:53:39 <dmwit> I never noticed before how weird the capitalization is in that title.
07:53:41 <ski> giaco : you can also enter `let factorial :: (Integral a) => a -> a; factorian n = ..n..'
07:54:24 <ski> (i guess, in your case, you'd probably have two defining equations, separated by `;')
08:00:57 <giaco> just a curiosity. Using "_" to indicate non-used values, is an actual placeholder for the compiler, or is just what people like to see?
08:01:40 <lemmih> giaco: It's part of the Haskell language.
08:02:09 <giaco> thanks
08:03:02 <giaco> no ":i _"? poor _
08:03:49 <geekosaur> it's syntactic, not just an unnamed variable
08:04:18 <geekosaur> it'll make more sense when you learn more about patterns, I suspect
08:05:09 <ddellacosta> anyone here done any midi programming with the alsa-seq package? I'm having a heck of a time figuring out what string I need to pass to specify a non-default midi device (variations on hw:2,0 aren't working)
08:08:50 <giaco> geekosaur: k
08:09:40 <[exa]> ddellacosta: what does `aplaymidi -l` say?
08:11:28 <ddellacosta> [exa]: https://gist.github.com/ddellacosta/20c97ef720b05ab6c490c98e02beb0f7 I'm trying to connect to the launchpad device (first one I guess?)
08:12:19 * hackage hnix 0.10.1 - Haskell implementation of the Nix language  https://hackage.haskell.org/package/hnix-0.10.1 (AntonLatukha)
08:13:20 <ddellacosta> [exa]: updated the gist with more commands' output
08:18:02 <[exa]> ddellacosta: it should be the same string as passed to snd_seq_open(3)
08:19:29 <thanhtrdang> @help
08:19:30 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
08:19:30 <ddellacosta> [exa]: yeah, do you know where I can read more about that format? The C API docs aren't super helpful, and I feel like I'm just going around in circles on the alsa wiki. About to open up the C library code but wish it was more obvious what I needed here
08:19:36 <thanhtrdang> list
08:19:38 <[exa]> not that ALSA documentation would be more verbose but github search says that "hw" should work too
08:19:49 <ddellacosta> that doesn't work, tried it :-/
08:19:54 <[exa]> thanhtrdang: please try the lambdabot commands in a private chat (use /query lambdabot)
08:20:44 <[exa]> ddellacosta: okay that's bad... if you have any other software that can open the midi correctly, you should be able to use some kind of strace/ltrace to get the exact parameters it's using
08:21:01 <ddellacosta> [exa]: okay, I'll give that a shot...thanks for the help and sanity check!
08:25:32 <[exa]> ddellacosta: certainly try watching what happens with strace
08:26:05 <ddellacosta> it's a great idea...will report back what I figure out
08:35:10 <maerwald> I have no luck with generic-arbitrary... I'm running out of memory when doing json roundtrip O.o
08:38:48 <maerwald> it seem to go completely overboard with the list/map size
08:39:09 <giaco> what are good exercises to learn haskell? I'm trying to overcome my imperative programming habit, but inventing a functional problem to solve takes me back to the imperative ones
08:39:12 <maerwald> I already regret doing quickcheck (I usually avoid it)
08:39:43 <Rembane> maerwald: Does generic-arbitrary use sized or do the generated data structures become infintely large?
08:39:53 <ddellacosta> giaco: I've found doing exercises on codewars.com to be a fun way to practice basic techniques, they have some good haskell problems
08:39:56 <maerwald> I don't know
08:41:02 <phadej> it doesn't.
08:41:07 <phadej> don't use on recursive types :)
08:41:12 <giaco> ddellacosta: thanks
08:42:20 <frdg> are some haskell parsing libraries inspired by prolog? The backtracking nature of prolog seems in line with how I have parsed with haskell.
08:42:32 <ddellacosta> giaco: sure thing
08:45:28 <Rembane> phadej: "This JSON generation is done by professionals. Don't try this at home kids. Especially not with recursive types."
08:46:04 <phadej> I have a draft post about "how to write Gen's for recursive types"
08:46:11 <phadej> but I need a day or two to finish it
08:46:28 <dolio> Write something that solves the n-queens problem.
08:46:42 <dolio> That's one thing I did when I was learning Haskell.
08:46:43 <phadej> I think that have been done :)
08:48:21 <sm[m]> giaco: project euler
08:49:59 <untseac> hello. I need an opinion. I want to read a map (or list of pairs) from a given file, perhaps in a configuration. Is it better to use native haskell syntax or use JSON/YAML?
08:50:32 <untseac> it's for a configuration. Like ./myexec config < input
08:50:59 <Rembane> untseac: I would use ini syntax. 
08:51:01 <untseac> the app itself is supposed to convert lines into CSV given pairs of (column-name, column-size)
08:51:13 <untseac> Rembane, yeah does work
08:51:30 <untseac> like Java properties or so
08:51:38 <Rembane> untseac: Are people going to edit those files?
08:51:41 <untseac> yes
08:51:55 <Rembane> Okay, then I wouldn't use JSON neither YAML. 
08:52:15 <untseac> ok. it's simple enough of a config file to not use JSON or YAML.
08:52:24 <ski> frdg : you mean with non-committing choice ?
08:52:34 <untseac> and complex enough to not supply on command file
08:52:37 <untseac> and complex enough to not supply on command line
08:53:05 <untseac> alright, ini style it is. thanks Rembane 
08:53:35 <frdg> ski: yes that's what I mean.
08:53:49 <Rembane> untseac: No worries. Good luck! 
08:53:55 <ski> maybe something like `Parsek'
08:56:02 <frdg> ski: thanks. I also am trying to understand how difference lists could applied in Haskell. 
08:56:13 <frdg> I see there is a library for it.
09:01:04 <ski> frdg : they don't work quite the same
09:01:55 <ski> in Prolog you can match on a difference list. not so in Haskell, since they're modelled as functions here
09:02:25 <dolio> Yeah, they shouldn't have been called difference lists.
09:03:08 <ski> they're still meant to express the difference between a list and its suffix
09:03:20 <ski> but it's not the same thing
09:03:57 <dolio> It's probably better to point out that it's related to Cayley's theorem (a.k.a. the Yoneda lemma) for monoids.
09:04:14 <frdg> ok thats good to know. I need to look into mercury I think. That language may answer some questions I have.
09:04:55 <ski> there is a #mercury channel (in addition to ##prolog)
09:05:30 <ski> (iirc, there's some support for programming with difference lists, in Mercury)
09:05:46 <frdg> thanks
09:12:16 <dyeplexer> > 1 = 2
09:12:18 <lambdabot>  <hint>:1:3: error: <hint>:1:3: error: parse error on input ‘=’
09:12:52 <dyeplexer> Weird. My ghci doesn't seem to produce this error.
09:13:11 <dyeplexer> or any error at all
09:13:30 <dyeplexer> (for this statement)
09:13:42 <geekosaur> lambdabot is not ghci
09:14:11 <geekosaur> as for ghci, it's an unused pattern match so it never gets a chance to fail
09:14:13 <maerwald> phadej: it isn't really a recursive type, it's a nested type
09:14:20 <dyeplexer> okay
09:14:24 <maerwald> map of map of map ...
09:23:21 <phadej> maerwald: are you coming up with terms? E.g. https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/nested-types says nested type is `class Foo { class Bar { ... } }`, Bar is nested in Foo.
09:23:36 <phadej> data Value = ... | Object (HashMap Text Value) -- seems quite recursive to me.
09:24:57 <maerwald> so [[a]] is recursive?
09:25:28 <phadej> no, why would it be.
09:26:11 <phadej> "lists of lists of a" is not in the form of "value is ... or a map from text to value"
09:26:23 <maerwald> type Doh = Map String (Map Text Foo) -- is this recursive?
09:27:34 <phadej> no. `type` cannot be recursive.
09:27:36 <phadej> % type Foo = [Foo]
09:27:36 <yahb> phadej: ; <interactive>:33:1: error: Cycle in type synonym declarations: <interactive>:33:1-16: type Foo = [Foo]
09:27:44 <maerwald> then my type is not recursive, but nested
09:28:28 <phadej> ok. You could have said simply that you don't generate `Data.Aeson.Value`
09:28:36 <phadej> but `Value` is recursive.
09:29:15 <phadej> (fwiw, generating [[[Int]]] is bad idea in QuickCheck, it will be huge value too)
09:29:36 <phadej> as in `arbitrary :: Gen [[[Int]]]`. Finite, but still huge.
09:29:39 <maerwald> that might be the issue
09:32:04 <phadej> (at its final size is of order of size*size*size, where size = 100 by default)
09:33:56 <maerwald> doesn't web scale
10:16:01 <fendor> are there any tips on realising that version constraint need to be tightened? 
10:17:17 <ddellacosta> anyone know what I need to tweak in my emacs setup to stop haskell-mode (I guess?) from asking me if I want to add extension X to the top of my file every time I reload?
10:21:00 <phadej> fendor: knowing the dependencies helps
10:21:11 <phadej> going through them and checking which changed recently
10:21:16 <phadej> (if the breakage is recent)
10:21:45 <monochrom> I work in the other direction. I start tight. Then I loosen when necessary.
10:24:58 <monochrom> ddellacosta: There is a customizable variable for that.
10:25:19 <ddellacosta> monochrom: I believe you
10:25:19 * hackage dl-fedora 0.7.5 - Fedora image download tool  https://hackage.haskell.org/package/dl-fedora-0.7.5 (JensPetersen)
10:26:16 <monochrom> I assume you use interactive-haskell-mode.
10:27:01 <ddellacosta> monochrom: yeah. Sorry I'm just avoiding looking it up because it always turns into a rabbit-hole dive with emacs, figured I'd ask if anyone knows off the top of their head--don't mean to take up folks time with this though. I'll put the yak-shaving off until later
10:27:19 <fendor> uff, so I'd have to go through all of my dependencies whenever someone makes a PR and a type does not look familiar to me?
10:28:05 <fendor> monochrom, the problem comes with time, you loosen constraints, and then there is some feature that allows only newer versions...
10:28:15 <monochrom> If you use the emacs Customize interface, the group is "Haskell Interactive", the variable is "Haskell Process Suggest Language Pragmas"
10:28:23 <ddellacosta> monochrom: thanks!! I'll check that out
10:28:36 <Cheery> I see that somebody did a careful analysis on Haskell's module system in 1993, is there a written report?
10:29:10 <monochrom> The lisp name of the variable is haskell-process-suggest-language-pragmas
10:29:35 <ddellacosta> monochrom: more than I'd hoped for. Thanks again.
10:38:43 <ddellacosta> [exa]: turns out I had the right device all along, I just don't understand how clients and ports work. :-| Thanks again for your help earlier 
10:42:17 <bobajett> what does the # hash sign do in the Data.List.findIndicies definition ... let go x r k | p x = I# k `c` r (k +# 1#) ...
10:43:26 <geekosaur> unlifted operations and values
10:43:38 <geekosaur> @src Int
10:43:39 <lambdabot> data Int = I# Int#
10:43:58 <bobajett> Thanks!
10:55:57 <[exa]> ddellacosta: btw what was the solution?
10:56:46 <ddellacosta> [exa]: lol I'm still figuring that out, I've just proven that I do see the item I want to use when I dump out all the clients from the default device
10:57:30 <ddellacosta> so now I'm just trying to understand how to actually specify a client/ports in alsa-seq, which seems extremely non-obvious, but I'm hoping it will be pretty simple in the end
10:58:55 <ddellacosta> after all, what's a weekend without some kind of yak-shaving?
11:02:40 <Uniaika> alanz_: heya! Is WhatsApp using Haskell internally?
11:03:41 <phadej> it was erlang in 2015...
11:04:07 <phadej> Oct 24, 2018 - At WhatsApp, we use Erlang for pretty much everything. We're essentially running on Erlang. Most of our server code is written in Erlang. I
11:04:14 <phadej> https://www.erlang-solutions.com/blog/20-years-of-open-source-erlang-openerlang-interview-with-anton-lavrik-from-whatsapp.html
11:08:27 <Uniaika> phadej: oh yeah I'm a member of the Erlang (and Elixir) community, I know that :)
11:08:57 <Uniaika> but Alan is so proficient in Haskell I was wondering if WhatsApp paid him to do Haskell for them
11:09:08 <Uniaika> (unless I'm mistaken about his current employment)
11:10:19 * hackage roboservant 0.1.0.0 - Automatic session-aware servant testing  https://hackage.haskell.org/package/roboservant-0.1.0.0 (MarkWotton)
11:11:38 <phadej> looking at github "erlang-ls/erlang_ls" as one of contributions...
11:12:17 <phadej> ls = language server
11:31:56 <fendor> Uniaika, no, they do not
11:32:11 <Uniaika> thanks fendor :)
11:37:37 <omg_3> Hi all, how does one define a function with guards inside of a where clause? I've been running into an infinite type construction and can't see where I've made the error. Relevant paste: https://pastebin.com/NcSi3LD9
11:38:37 <[exa]> omg_3: you're likely missing a few parentheses in there
11:39:08 <[exa]> omg_3: ie. the second case is parsed as (go steps) + (1 n) / 2
11:39:25 <omg_3> Alright, I've amended that
11:39:55 <[exa]> finally, you are returning Integer, but not Maybe Integer
11:40:31 <[exa]> more precisely, you can stuff in "Just" before steps in the 1st case
11:40:53 <[exa]> (Maybe is not the same as "nullable")
11:41:35 <omg_3> I got this problem from Exercism- what's the reasoning behind throwing in a Maybe Integer into the signature?
11:42:56 <[exa]> omg_3: possibly they would want you to return Nothing in case you find a number that disproves the conjecture
11:43:20 <[exa]> which is problematic because to verify that, you'd need to at least reach a cycle, which no one achieved so far
11:43:39 <[exa]> in effect, collatz conjecture says that the function will always return Just somethign
11:43:53 <Cale> Or well, everyone reaches a cycle all the time, it just tends to be the same one ;)
11:44:25 <[exa]> uh yes. :D
11:44:28 <omg_3> Yea I really doubt that me trying to apply my Haskell readings is going to yield proof that the conjecture doesn't check out
11:44:43 <omg_3> That'd be awful
11:44:46 <[exa]> yeah, that would be one heap of beginner luck
11:45:03 <[exa]> :]
11:46:50 <Cheery> > foldr f [x,y,z]
11:46:52 <lambdabot>  error:
11:46:52 <lambdabot>      • Could not deduce (FromExpr [Expr]) arising from a use of ‘f’
11:46:52 <lambdabot>        from the context: (Foldable t, Show a)
11:47:16 <Cheery> > foldr f z [x,y]
11:47:18 <lambdabot>  f x (f y z)
11:53:39 <Cheery> is it really that higher-order function is also a function that returns a function as a result?
11:54:44 <ddellacosta> it can be
12:19:42 <giaco> do you know any good example of well written, well designed, well documented haskell program? I keep finding minimal examples on one end and design patterns / domain architecture on the other end
12:20:38 <Cheery> I got some ideas, but I haven't seen a program like this.
12:21:06 <geekosaur> xmonad, git-annex, pandoc in (rapidly) ascending order of complexity
12:22:18 <Cheery> Haskell programs get a lot back in accurate type information, in regards to how tolerable they're to use with little or bad documentation..
12:22:33 <glguy> giaco: my IRC client has a bunch of comments and a reasonable structure https://GitHub.com/glguy/irc-core
12:22:35 <remexre> if you want something smaller, self-plug: https://git.sr.ht/~remexre/lemonbot
12:24:10 <Cheery> Though, I'm not ready to say that there wouldn't be a well-documented haskell program. Worthwhile to mention as you get examples and I haven't looked into them.
12:24:50 <giaco> thank you for all the feedbacks
12:25:17 <Cheery> I definitely like the glirc readme for instance.
12:25:27 <Cheery> and looking at it for the first time.
12:26:37 <Cheery> Ok.. But I see that it doesn't implement the ideas I have.
12:30:05 <Cheery> I think, irrespective of a language, a good program would have technical documentation that is written in sync with code and references the code.
12:30:14 <Cheery> bit like a literate program, but aside the code.
12:30:52 <Cheery> then from that technical documentation, other documentation would be derived, including guides for working with the library.
12:32:02 <Cheery> It creates a kind of a chain, that can be used to verify the documentation remains in sync.
12:33:22 <Cheery> Also allows the person reading the documentation to progress. When he figures out he needs to know something advanced, he has the documentation "in middle"
12:34:19 <Cheery> I experimented with this in https://leverlanguage.com/
12:38:20 <Enrico63> tomsmeding, I think I'm kind of on the right way for that snake game :D
12:39:31 <Enrico63> I haven't had much time to work on it, but I've just got the input working. If you want to give a look at it, it's here: https://codereview.stackexchange.com/questions/249322/keep-reading-user-keyboard-input-if-available-while-echoing-back-the-latest-ava and
12:39:31 <Enrico63> https://stackoverflow.com/questions/63874453/keep-reading-user-keyboard-input-if-available-while-echoing-back-the-latest-ava/
12:43:19 <fendor> @type ((>>) .) . (>>)
12:43:21 <lambdabot> Monad m => m a1 -> m a2 -> m b -> m b
12:43:42 <fendor> @type (((>>) .) . (>>) <$>)
12:43:44 <lambdabot> (Monad m, Functor f) => f (m a1) -> f (m a2 -> m b -> m b)
12:47:49 * hackage uniqueness-periods-vector-general 0.4.2.0 - Generalization of the functionality of the dobutokO-poetry-general-languages package  https://hackage.haskell.org/package/uniqueness-periods-vector-general-0.4.2.0 (OleksandrZhabenko)
12:53:00 <giaco> > foldl (+) [1..10]
12:53:02 <lambdabot>  error:
12:53:02 <lambdabot>      • No instance for (Num [Integer]) arising from a use of ‘e_1110’
12:53:02 <lambdabot>      • In the expression: e_1110
12:53:22 <giaco> how can I fix this in ghci? Been trying different ::<type> without success
12:55:02 <fendor> giaco, you are missing a starting value
12:55:05 <fendor> @type foldl
12:55:07 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
12:55:13 <ddellacosta> > foldl (+) 0 [1..10]
12:55:16 <lambdabot>  55
12:55:21 <rand> Hello! I'm trying haskell for the first time. I want to flatten a list of list and then get the even elements from sublists. [[1,2,3]. [4,5,6]] -> 2,4,6. 
12:55:23 <fendor> > foldl (+) 50 [1..10]
12:55:28 <lambdabot>  105
12:55:31 <rand> I'm doing this: removeOdd c = [f | even f | f <- x | x <- c]
12:56:26 <rand> It shows <interactive>:30:20: error:    Unexpected parallel statement in a list comprehension    Use ParallelListComp . Can anyone please tell me what's wrong? (Sorry about posting in snippets, didn't know it doesn't enter a new line)
12:56:48 <giaco> fendor: oh, my fault, sorry. Thanks
12:56:58 <giaco> ddellacosta: thanks, too
12:57:08 <ddellacosta> np
12:58:55 <fendor> rand, the syntax you are using is incorrect. Maybe this helps: https://wiki.haskell.org/List_comprehension
13:00:50 <alanz_> Uniaika: I am on Anton Lavrik's team
13:01:37 <Uniaika> alanz_: I will humbly say that I have no idea who this person is
13:03:57 <giaco> how can I pattern match a list of length 1 and return the only element?
13:04:21 <alanz_> Uniaika: https://news.ycombinator.com/item?id=24443128
13:06:15 <geekosaur> [x], or (x:[])
13:10:29 <giaco> thanks
13:10:51 <Uniaika> alanz_: thank you very much. :) Honestly a bit surprised that you didn't team with EMQX and their Hamler platform, but I guess competition is also important ;)
13:11:40 <giaco> geekosaur: but a function signature of myfunc :: [x] -> [x] does it mean that it takes a list of 1 element in input and gives a 1 element list as output?
13:12:43 <alanz_> Uniaika: they announced way after us, but even so, our primary goal is an idiomatic extension to current erlang. So that large legacy code bases can migrate.
13:13:40 <geekosaur> that's a type, not a pattern
13:14:18 <geekosaur> [x] as a type is a list of some type x. as a pattern, it matches a single-item list. as a value, it's a list with a single value
13:14:57 <Uniaika> alanz_: oh wow, I must get my glasses changed then because I'm one of the biggest lurkers of the Erlang subreddit. :) Thanks for the timeline correction! 
13:15:10 <Uniaika> and yes, it would seem the goals and means are different
13:15:43 <giaco> geekosaur: thanks for the clarification
13:17:18 <giaco> is it better to write a function using multiple guards or pattern-matching?
13:19:03 <dolio> Depends.
13:26:58 <Uniaika> giaco: I prefer pattern-matching on the function head when I don't have to put any logic
13:33:20 * hackage uniqueness-periods-vector-examples 0.2.0.0 - Examples of usage for the uniqueness-periods-vector series of packages  https://hackage.haskell.org/package/uniqueness-periods-vector-examples-0.2.0.0 (OleksandrZhabenko)
13:45:33 <cr0ssw1nd> hey
13:45:58 <cr0ssw1nd> I am refreshing my memory of Typeclassopedia
13:46:38 <cr0ssw1nd> and it looks more or less clear, but probably somebody could recommend pragmatical resources about use-cases for Applicatives and Traversables?
13:46:52 <cr0ssw1nd> sort of cookbook would be perfect
13:48:22 <Rembane> You can write your programs in applicative style instead of using do-notation. 
13:49:22 <cr0ssw1nd> Rembane, would it be better?
13:49:30 <cr0ssw1nd> if yes, in which cases?
13:49:43 <Rembane> traverse looks quite a lot like mapM... hm... I dunno why it exists, there's probably someone else here that does though.
13:49:46 <Uniaika> cr0ssw1nd: https://www.reddit.com/r/haskell/comments/gayexc/environment_variables_parsing_for_free/
13:49:59 <Rembane> cr0ssw1nd: Nah, just different. 
13:53:41 <cr0ssw1nd> Uniaika thanks
13:54:58 <dolio> You can design your whole programming methodology around traversals with lens.
13:55:14 <dolio> Which of course also uses various applicatives.
13:58:09 <[exa]> Rembane: traverse is more general (works on applicatives), mapM is just traverse specialized to monads only
13:59:43 <maerwald> great, my json roundtrip fails on 32bit, because it cannot parse Int
13:59:44 <cr0ssw1nd> dolio, would you say that traversables are more powerful than monads? 
13:59:45 <Rembane> [exa]: That's a good point. Thank you. 
13:59:53 <dolio> No.
14:00:38 <maerwald> I'm not sure if I'm more annoyed at QuickCheck or machine-dependent integers
14:01:27 <cr0ssw1nd> but are traversals easier to work with than monad transformers? in a big project
14:01:56 <dolio> They are not comparable tools.
14:02:20 <giaco> For an exercise, I'm writing a function that given an Integral returns a list of its digits. It works for any Integral, except for 0, but I use 0 to as recursion limit. How would you solve this? http://ix.io/2xsm 
14:03:13 <giaco> i want "toDigitsList 0" to return [0], but also I have to close the recursion somehow for all other cases
14:05:02 <dolio> What you can do with traversals is organize all your data structure manipulatiaon around them.
14:06:24 <dolio> You may or may not find that you like the results, but you can do it.
14:10:40 <maerwald> omg... it's the hspec seed it cannot parse
14:11:49 * hackage implicit-hie-cradle 0.2.0.0 - Auto generate hie-bios cradles  https://hackage.haskell.org/package/implicit-hie-cradle-0.2.0.0 (Avi_Dessauer)
14:37:36 <giaco> show 0123 returns "123". Is it possible to get "0123" or [0,1,2,3]?
14:39:46 <dibblego> not as a number
14:41:16 <giaco> k
14:58:49 * hackage gi-cairo-render 0.1.0 - GI friendly Binding to the Cairo library.  https://hackage.haskell.org/package/gi-cairo-render-0.1.0 (cohomology)
14:59:49 * hackage gi-cairo-connector 0.1.0 - GI friendly Binding to the Cairo library.  https://hackage.haskell.org/package/gi-cairo-connector-0.1.0 (cohomology)
15:52:41 <hexagoxel> hmm, my haddock doc on this function just repeats what the type signature says in a much less precise manner.
15:53:03 <hexagoxel> -- | Just read the type signature. Too lazy to come up with a fancy example, sorry.
16:00:56 <sshine> hexagoxel, I don't feel the most inspired to write good haddock messages when I'm coding.
16:01:22 <sshine> hexagoxel, then I either end up repeating something very obviously derivable from the type signature or the name of the function. ;-)
16:09:22 <monochrom> You can use -- ^ to write blurbs on the parameters and the return value.
16:14:06 <sm[m]> what is the purpose of the function, for users
16:32:55 <MarcelineVQ> don't be afriad to repeat yourself in commentary. it's code you keep dry
16:49:40 <hexagoxel> good points. I went an approach explaining based on a specific type, where the function is generic. The next best thing would be a full (and somewhat longer) example.
17:04:37 <sm[m]> If it's hard to explain, that can be a good signal to refine it
17:13:34 <Axman6> > 0123
17:13:36 <lambdabot>  123
17:13:43 <Axman6> > 0129
17:13:46 <lambdabot>  129
17:14:07 <Axman6> hmm, I thought we had octal
17:14:59 <Axman6> > 0o123
17:15:02 <lambdabot>  83
17:21:26 <koz_> Is there something like sconcatMap?
17:25:50 * hackage ats-pkg 3.5.0.2 - A build tool for ATS  https://hackage.haskell.org/package/ats-pkg-3.5.0.2 (vmchale)
17:27:27 <dolio> foldMap1?
17:29:19 * hackage RtMidi 0.3.0.0 - Haskell wrapper for RtMidi, the lightweight, cross-platform MIDI I/O library.  https://hackage.haskell.org/package/RtMidi-0.3.0.0 (ejconlon)
17:42:20 * hackage roboservant 0.1.0.1 - Automatic session-aware servant testing  https://hackage.haskell.org/package/roboservant-0.1.0.1 (MarkWotton)
17:49:49 * hackage ocap-io 0.1.1.0 - Object capability based IO  https://hackage.haskell.org/package/ocap-io-0.1.1.0 (isd)
18:31:56 <halogenandtoast> This is probably a really dumb question, but if I have a ADT with a bunch of constructors is there any way to pattern match the first argument out of any constructor (with Generics or otherwise)?
18:33:03 <halogenandtoast> i.e. data F = A Int | B Int, could I somehow pattern match out the Int from an F (assume F actually has a ton of constructors so it's annoying to pattern match them all).
18:33:19 <Axman6> you might be able to do it with something like generic-lens, but if all your constructors have the same first argument, you should refactor it so you have a product type with the common field and and a sum type with the different fields
18:33:50 <halogenandtoast> Axman6: yeah it's complicated, I'd like to not change the structure
18:34:23 <halogenandtoast> Actually my question is incorrect now that I think about it
18:34:53 <halogenandtoast> what I really have is this: data F = A X | B Y where X and Y are different newtype wrappers around Int and I want to get that Int back out
18:35:20 <halogenandtoast> what I do right now is pattern match like this: A x -> coerce x
18:35:28 <halogenandtoast> B y -> coerce y
18:35:30 <Axman6> using lens, that'd be (_A . _Unwrapped <> _B . _Unwrapped)
18:36:04 <halogenandtoast> But I'd still need to specificy all the constructors that way right?
18:36:10 <Axman6> yes
18:36:41 <halogenandtoast> Yeah this one type has 52 constructors and I use this pattern for a bunch of types with a similar number of constructors
18:36:43 <Axman6> I think you'll find learning how to use your editor to write those code quickly will be more fruitful than trying to find a generic solution :)
18:37:04 <Axman6> multiple cursors make writing this sort of tedious code much less tedious
18:37:42 <halogenandtoast> The issue is I will iteratively be added hundreds more constructors over time, one by one
18:37:53 <halogenandtoast> *adding
18:38:18 * hackage psql-utils 0.2.0.1 - PostgreSQL Simple util tools.  https://hackage.haskell.org/package/psql-utils-0.2.0.1 (Lupino)
18:38:19 <Axman6> good thing you have a type system which will tell you where things just broke when you do that!
18:39:04 <halogenandtoast> I'm not disagreeing with you, but your statement is a bit... blasé
18:39:24 <dmwit> It sounds like you're creating a big system. Big systems require a lot of code.
18:39:25 <halogenandtoast> I know this, you know this, it's a solution, but not what I was asking about.
18:39:36 <Axman6> hundreds of constructors sounds like not a lot of fun to begin with
18:39:43 <halogenandtoast> I'm fine with the answer being, no that is not something you can do.
18:39:59 <halogenandtoast> Axman6: It's a card game, every card has unique behavior
18:39:59 <dolio> Are you?
18:40:01 <Axman6> it's almost certainly something you _can_ do, but it might be more work
18:40:24 <Axman6> something like generics-sop might make it not too horrible
18:40:40 <halogenandtoast> Not only does it have unique behavior but there are no discernable patterns amongst behavior and that behavior can effect any part of the system in extremely nuanced ways.
18:40:51 <dmwit> To me, what you're asking for sounds like trouble. Eventually the first Int field is going to have different semantics than for the other constructors, and you're going to have a bug.
18:41:29 <dmwit> So grab that hair shirt and write down what you mean.
18:41:51 * halogenandtoast shrug
18:42:38 <dmwit> Anyway the answer is almost certainly yes that's possible.
18:43:00 <dmwit> You might have to accept Maybe Int instead of Int.
18:43:20 <Axman6> I can definitely see it being possible using generics-sop without a huge amount of pain
18:44:04 <halogenandtoast> Axman6: I'll read up on that. I haven't used it before so it will be new territory
18:44:13 <Axman6> since you can say things like "assuming all the first fields in each constructor are coercible to Int, then get the first field and coerce it"
18:44:37 <halogenandtoast> I managed to use Generics in a few other parts and it managed to remove about 1000 lines of code so that was nice
18:45:16 <halogenandtoast> The program is big so any sort of refactoring like this will have a large impact over time.
18:45:30 <halogenandtoast> and by big I mean 22k lines big.
18:46:18 <Axman6> class (Coercible a Int) => IsInt a; instance (Coercible a Int) => IsInt a; trhen you need a class to apply a type constraint to the first field of each list in the list of constructor element types
18:48:01 <Axman6> so type family FirstFieldIs (c :: Type -> Constraint) (xss :: [[Type]]) where FirstFieldIs c '[] = (); FirstFieldIs c ((x ': xs) ': xss) = (c x, FirstFieldIs x xxs)
19:05:52 <Axman6> actually you'd want FirstFieldIs c '[x ': xs] = c x
19:06:08 <Axman6> so you can't accept an empty type
19:13:41 <halogenandtoast> type families are currently outside my wheelhouse so I'm going to need to read up and come back to this.
19:14:19 <halogenandtoast> But thank you Axman6 for the info, I doubt my capabilities to make something out of this, but it's interesting to see nonetheless
19:16:05 <Axman6> I think you might find this is simpler than you expect, what I gave above is very close to getting you what you want. you just need a function which can then iterate over the NS type and then pull the first field out of the NP type the NS contained
19:16:36 <Axman6> NS = n-ary sum, NP = n-ary product
19:20:39 <Axman6> so... let's see if I can just write this: getFirstInt :: FirstFieldIs IsInt (Rep a) => a -> Int; getFirstInt a = go (unSOP $ from a) where go (S next) = go next; go (Z  (I x :* _) = coerce x
19:20:51 <Axman6> uh, Rep a should be Code a
19:38:34 <PropositionJoe> Array always contains tuples? (index, val)?
19:42:37 <c_wraith> Well, in some sense.
19:43:02 <c_wraith> every value *is* associated with an index.  That index is how you find the value.  But it's not like it's storing a pair.
19:43:49 <PropositionJoe> Suppose I want to loop over an array, how do I get next index?
19:44:32 <PropositionJoe> If index is integer it is trivial, but what if it is Char or some other type?
19:44:34 <c_wraith> Do you actually need it, or do you only care about the values in sequence?
19:45:40 <PropositionJoe> Actually need it, linear search algorithm that returns index.
19:46:14 <c_wraith> https://hackage.haskell.org/package/array-0.5.4.0/docs/Data-Array.html#v:assocs
19:47:59 <PropositionJoe> c_wraith, can you explain? These docs are not very beginner friendly imo.
19:48:31 <c_wraith> It takes an array and returns a list of (index, value) pairs.
19:50:15 <PropositionJoe> Ok, thanks, but seems like a strange way to do it.
19:50:17 <c_wraith> thanks to laziness, lists and iteration are roughly the same thing in Haskell.
19:50:55 <dmwit> There is also `range` to return only the indices.
20:36:50 * hackage monad-supply 0.9 - Stateful supply monad  https://hackage.haskell.org/package/monad-supply-0.9 (GeoffHulette)
21:08:33 <hololeap> what is the best way to get a list in reverse order from a Seq?
21:09:20 <lemmih_> hololeap: toList . reverse ?
21:09:36 <hololeap> Sequence.reverse is O(n), but will folding over this as a list act lazily?
21:11:49 <hololeap> in other words, can i get the O(1) right-hand access that comes with Seq using this, or does it reverse the entire Seq before passing it to toList
21:14:15 <hololeap> @src Data.Sequence.findIndexR
21:14:15 <lambdabot> Source not found. You type like i drive.
21:15:00 <lemmih_> hololeap: 'reverse' for sequences is lazy. That is, 'viewl (reverse s)' is O(1).
21:15:31 <hololeap> lemmih: thank you, that's what i wanted to know
21:32:13 <hololeap>  (Alternative f, Applicative g) => Alternative (Compose f g)
21:33:25 <hololeap> how would this behave when f is Maybe?
21:35:39 <hololeap> what i'm looking for is a monad transformer that is like MaybeT but continues on Nothing and aborts on the first Just
21:38:31 <hololeap> something like `EitherT e m ()`, but with e as the functorial value
21:38:58 <hololeap> *ExceptT
21:50:19 <koz_> hololeap: Check how that Alternative instances is defined, then sub in Maybe whenever f shows up.
21:57:08 <hololeap> i think what i'm looking for is a fold using `Applicative f => Ap f (Alt Maybe a)`
21:58:19 <hololeap> which should terminate at the first Just inside f, if i understand correctly
22:01:36 <hololeap> % :t (\f -> fmap getAlt . getAp . foldMap f) :: (Applicative f, Foldable t) => (x -> Ap f (Alt Maybe a)) -> t x -> f (Maybe a)
22:01:36 <yahb> hololeap: (Applicative f, Foldable t) => (x -> Ap f (Alt Maybe a)) -> t x -> f (Maybe a)
22:10:58 <hololeap> % foo = (\f -> fmap getAlt . getAp . foldMap f) :: (Applicative f, Foldable t) => (x -> Ap f (Alt Maybe a)) -> t x -> f (Maybe a)
22:10:58 <yahb> hololeap: 
22:11:32 <hololeap> % foo (\i -> if i == 5 then pure $ Alt (Just i) else pure $ Alt Nothing) [1..10]
22:11:32 <yahb> hololeap: Just 5
22:11:40 <hololeap> seems to work...
22:13:21 <hololeap> % foo (\i -> if i == 5 then pure $ Alt (Just i) else Ap Nothing) [1..10]
22:13:22 <yahb> hololeap: Nothing
22:13:38 <hololeap> % foo (\i -> if i == 5 then pure $ Alt (Just i) else Ap (Left True)) [1..10]
22:13:38 <yahb> hololeap: Left True
22:14:32 <hololeap> yeah that's the behavior i want
23:10:49 <hololeap> % :i Accum
23:10:49 <yahb> hololeap: ; <interactive>:1:1: error: Not in scope: `Accum'
23:11:05 <hololeap> % import Control.Monad.Trans.Accum
23:11:06 <yahb> hololeap: 
