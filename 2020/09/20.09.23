00:06:39 <ixlun> If I have `data (Ord a) => Foo a = Foo Bar a', how can I make all `Foo's Ord by a?
00:07:41 <kenran> phadej: Ahh too bad. Maybe I can write a nix derivation for pulling the binaries and using those instead of using nixpkgs's cabal-install :thinking:
00:09:20 <kenran> thanks for pointing me to it!
00:11:28 <Axman6> ixlun: youy almost certainly do not want to add that constraint to the data definition. just do data Foo a = Foo Bar a; instance Ord a => Ord (Foo a) where compare (Foo _ x) (Foo _ y) = compare x y
00:11:47 <phadej> kenran: hmm, dunno if pulling the binaries is very good idea. I'll make a note to make a nix derivation which would allow you to build them from source
00:12:03 <phadej> (thus it would work on macOS too e.g.)
00:13:47 <kenran> phadej: wow, that would be awesome, thanks. cabal-install itself is probably also a cabal project I guess? :)
00:14:07 <phadej> yes
00:14:54 <phadej> but I wouldn't want to use nixpkgs dependencies, as perfectly it shouldn't require you to change/upgrade anything else
00:16:27 <ixlun> Axman6: Thanks for the answer.  Looks as though I've also got to implement Eq in a similar way too: 'Could not deduce (Eq (Foo a))'
00:16:58 <Axman6> you can just add deriving (Eq) if that's the behaviour you want
00:17:35 <ixlun> But, would Bar matter in that case?
00:17:42 <Axman6> yes
00:18:05 <ixlun> Which I would then presume would affect the ordering?
00:18:05 <Axman6> if you want something that's not the default derived behaviour, you'll need to write the code
00:18:15 <Axman6> no
00:19:07 <ixlun> Why not though?
00:19:11 <Axman6> the ordering would be dependent only on the definition of Ord (Foo a), but you probably want to make sure that if x == y then compare x y == EQ, and if x /= y then compare x y /= EQ
00:22:01 <ixlun> I'm guessing that this should be the case as I'm going to prob
00:22:20 <ixlun> probably make `a' a Double.
00:57:20 <dminuoso> phadej: Is cabal going to assimilate the entirety of cabal-plan, or just the list-bin part of it?
01:09:32 <phadej> dminuoso: just list-bin part for now
01:10:23 <dminuoso> Fair enough, that's a really welcome addition. :)
01:10:46 <dminuoso> (Although the `cabal -v0 exec -- which ...` trick worked well enough, list-bin feels a bit more robust)
01:11:14 <dminuoso> And I was always slightly annoyed to have cabal-plan as a dependency on my build runners. :)
01:12:18 <phadej> -v0 exec -- which doesn't work on Windows ;)
01:13:49 <phadej> and i'm trying to remember to do bindists for cabal-plan too, e.g. https://github.com/haskell-hvr/cabal-plan/releases/tag/v0.6.2.0
01:14:10 <phadej> (e.g. cabal's own CI is using that...)
01:39:25 <fendor> can haddock highlight json correctly?
01:39:47 <phadej> why would it :)
01:40:00 <phadej> it doesn't even highlight Haskell
01:41:48 <fendor> phadej, mainly because I think it would be neat in the documentation
01:41:59 <fendor> but I guess, I also want it to highlight haskell :P
01:42:03 <fendor> at least in code-mode
01:42:23 <AWizzArd> Do we have someone here who is using Emacs with the Haskell Language Server?
01:43:32 <fendor> AWizzArd, probably, (not me though). You can also ask in #haskell-ide-engine
01:44:13 <AWizzArd> fendor: good, I just wanted to ask if there might be some HLS channel
01:45:05 <fendor> AWizzArd, yep, that is the one. All hls/ghcide/hie stuff is discussed in there
01:45:44 <AWizzArd> \o/
01:48:29 <fendor> phadej, is there a practical/philosophical reason haddock cannot to this?
01:48:44 <fendor> or just, no one bothered yet
01:48:59 <phadej> fendor: what is the code block is not Haskell, or some pseudohaskell
01:49:10 <phadej> how to track all the new extensions GHC acquires
01:49:43 <phadej> IMO no highlighting is better than broken one
01:51:32 <fendor> It would already be nice to have some basic highlighting, such as function definitions, types, literals, keywords... I mean, I guess extensions can add new keywords
01:52:15 <phadej> have you looked at e.g. LinearTypes syntax changes
01:52:30 <phadej> tracking thing like that is just :S
01:53:17 <phadej> technically haddock could use ghc-lib to parser the code-snippets to highlight them
01:53:30 <phadej> but how to tell what extensions should be enabled (and again, which codeblocks are not Haskell)
01:53:49 * hackage rebase 1.8 - A more progressive alternative to the "base" package  https://hackage.haskell.org/package/rebase-1.8 (NikitaVolkov)
01:54:08 <phadej> it's not impossible, but that is harder than you would first think
01:54:51 <phadej> and then there's the bikeshedding about what styles to use ;P
01:54:58 <phadej> literally picking the colors
01:55:16 <phadej> I guess sane people just stay away from that kind of issues ;)
01:56:18 * hackage rerebase 1.8 - Reexports from "base" with a bunch of other standard libraries  https://hackage.haskell.org/package/rerebase-1.8 (NikitaVolkov)
02:04:10 <fendor> I did not look at LinearTypes changes so far. I can see the point, it still feels unsatisfying to me, though.
02:15:19 * hackage rebase 1.9 - A more progressive alternative to the "base" package  https://hackage.haskell.org/package/rebase-1.9 (NikitaVolkov)
02:16:49 * hackage rerebase 1.9 - Reexports from "base" with a bunch of other standard libraries  https://hackage.haskell.org/package/rerebase-1.9 (NikitaVolkov)
02:37:34 <phadej> hmm. two major version in less than half an hour. rapid development.
02:40:46 <maralorn1> Or rather unstable API.^^
02:41:20 <maralorn1> But there is no Changelog, so I don‘t know.
02:49:17 <dminuoso> Seems like the only change was https://github.com/nikita-volkov/rebase/commit/8c273eede30de7caefa06f9833170ab6ac09ff43
02:54:51 <MrZee> wait
02:55:18 <MrZee> hi
02:56:06 <MrZee> how to private chat in there ?
02:56:43 <dminuoso> MrZee: That depends on your IRC client. Most clients have the convention of `/query somename` opening a private message window to another user.
02:57:35 <MrZee> for example ?
02:59:55 <MrZee> i am quit
03:12:16 <MarcelineVQ> I wish I was quit
03:18:55 <edwardk> siraben: fromScope/toScope are useful for that
03:19:25 <edwardk> siraben see one of the million examples of nf implemented in bound for that
03:43:33 <dminuoso> Is there a common class representing a sort almost isomorphism with some `to :: C a => a -> Text; from :: (C a, MonadFail m) => Text -> m a`? Im battling with a bulk of boilerplate when carving out ToJSON, ToSchema, ToRow instances for JSON, Swagger and PostgreSQL.
03:45:11 <dminuoso> It'd be so much easier if all those libraries presented a flexible interface similar to makeLensesFor, where you can just specify a mapping of field to some name.
03:45:24 <phadej> ToSchema takes Proxy a and produces something something Sceham, ToJSON has toJSON and toEncoding, ToRow is ... -> [Action]
03:45:48 <phadej> there's really not much in common to try to abstract further
03:46:05 <dminuoso> Mmm, well FromRow at least.
03:47:48 <dminuoso> I mean, there's at least a very close correspondence between FromJSON/ToJSON and FromField/ToField.
03:48:57 <dminuoso> The common solution to both is to just use generics, but if I follow that path, I end up with a "database specific" data type, an "external specific data type", and then boilerplaty conversion functions.
03:48:58 <phadej> suppose there were some `To tag a` type-class. What kind of function you would write which would have `To tag a => a -> ...`  type
03:49:15 <phadej> dminuoso: yes, that is right
03:49:27 <phadej> database is one (external) interface, JSON API is another
03:49:43 <phadej> the fact that you may have same type for both only means that your program is dummy proxy
03:50:04 <phadej> (which is not wrong, if that is what it is)
03:50:27 <dminuoso> Right, this is the case right now. The point is to remain flexible in the future if the data types ever change, so I dont have much work.
03:51:13 <dminuoso> So I can change any three of the representations if need be, without leaking it to the other two
03:51:23 <phadej> then, don't use generics :)
03:51:30 <phadej> if you don't want have separate types
03:52:44 <dminuoso> Perhaps, what I really want is some TH helper for writing isomorphisms where I can just say `makeIso [('fFieldA, 'gFieldA), ('fFieldB', 'gfieldB')]`
03:55:08 <dminuoso> Then I could rely on generic instances whenever I want, keep the representations isolated from each other, and have less boilerplate when converting between the representations (since right *now* its just a mechanical coerce)
04:34:07 <sshine> hi siraben :)
04:46:26 <siraben> edwardk:  thanks, i'll look into fromScope/toScope
04:46:35 <siraben> hi sshine , what are you working on?
04:52:44 <AlexM84> greetings, a noob haskell question here. Doing some haskell learning for fun (cis194 course), building a binary search tree that is somewhat balanced and it turns out that it appears slower than not balanced one (which becomes a linked list really) when I'm trying to get an element by index. Obviously for balanced tree it is O(logN) and for not
04:52:44 <AlexM84> balanced it's O(n) but because haskell rebuilds the tree every time the index function is applied it appears to be slower, cause building of that balanced tree is slower. Can someone explain how to force haskell not to rebuild a data structure every time it is accessed or maybe I'm doing something wrong here? 
04:53:11 <dminuoso> AlexM84: It's best to share your code for starters.
04:53:42 <AlexM84> (+++) :: (Sized m, Monoid m) => JoinList m a -> JoinList m a -> JoinList m a(+++) Empty x = x(+++) x Empty = x (+++) l@(Single _ _) r@(Single _ _) = Append (tag l <> tag r) l r(+++) l r@Append{} = r +++ l(+++) l@(Append s xs ys) r    | isPowerOf2 . getSize . size $ s = Append (tag l <> tag r) l r  | otherwise = Append (tag xs <> tag subAppend) xs
04:53:42 <AlexM84> subAppend        where subAppend = ys +++ r 
04:53:53 <dminuoso> Can you share it on a pasting website perhaps like gist?
04:54:06 <dminuoso> Also, be sure to share your data definitions
04:54:06 <AlexM84> oops, sure, sorry folks, give me a sec
04:54:10 <AlexM84> yep
04:59:26 <AlexM84> here you go https://gist.github.com/alexmilshtein/9618faa55821a1beb46498b92d3b1c29
05:01:43 <AlexM84> if I create a list like so: let lst = L.foldl (+++) Empty $ map (Single (Size 1)) $ [1..100000] and let lstu = L.foldl (++++) Empty $ map (Single (Size 1)) $ [1..100000]
05:02:04 <AlexM84> the second one is a lot faster when indexJ function is applied
05:03:41 <AlexM84> update the gist with Sized module
05:20:29 <lyxia> if you apply indexJ just once that makes sense since the first one does a lot of work to rebalance the tree. It only pays off once you use indexing a lot
05:21:19 <lyxia> so you should also share your benchmarking code to make it clear whether that's what you're doing
05:28:50 <frdg> From Database.Persist: `update :: PersistEntity val => Key val -> [Update val] -> m ()` I am having trouble understanding the syntax for the `[Update val]` field. 
05:31:09 <AlexM84> thanks lyxia, it does makes sense. I don't have benchmarking code written for it, it's just that I was doing it in ghci with +s set, but I guess ghci is not really effective way of doing this as it is just an interpreter. Compiling the code and applying indexJ for the second time gives an instant result, though
05:31:31 <frdg> the function is described as `Update individual fields on a specific record.` But I do not understand how the val from Key val and Update val could be the same type.
05:35:01 <jackdk> They aren't. What is Key, and what is Update?
05:38:15 <frdg> key and update are the types
05:39:12 <frdg> but wouldn't the val in `Key val` and `Update val` be the same val?
05:41:56 <lyxia> AlexM84: even if you're writing it by hand in ghci it's code you write to measure the performance of something, that's benchmarking code, and it's always worth sharing!
05:42:59 <frdg> jackdk: I figured it out.
05:43:11 <jackdk> frdg: cool
05:44:07 <dminuoso> AlexM84: Indeed, measuring performance with optimizations disabled can tell you a lot. Sometimes GHC is able to compensate for badly written code, but that should never be relied on. :)
05:44:25 <dminuoso> Algorithmic complexity should in general not depend on optimizations
05:48:07 <AlexM84> lyxia, dminuoso: thanks for suggestions, I've added the line of code I used in ghci to test this out into the gist I shared earlier
05:49:03 <AlexM84> I wonder if it's possible to force ghci not to rebuild the tree if it's accessed subsequently for indexing
05:49:59 <ahri> I have a stack project and I want to start using GHCJS, I've got a (probably) working binary via some nix magic (that I don't really understand and don't want to jump into that rabbit hole just now) - so now I want to build my project with stack/cabal and tell them to use the (global) GHCJS binary as the compiler - I have tried to read the docs and
05:49:59 <ahri> search around but it's really not clear to me how I can achieve this last step - any help?
06:03:40 <sshine> ahri, for Stack it seems you want 'system-ghc: true' in case your GHCJS is the system GHC. https://stackoverflow.com/questions/44460120/haskell-stack-doesnt-use-system-ghc
06:04:37 <sshine> ahri, but my guess is you'll run into deeper problems here because of this comment: Note that stack can only use a system GHC installation if its version is compatible with the configuration of the current project, particularly the resolver setting.
06:04:54 <sshine> and I'm guessing GHCJS doesn't have a valid Stackage resolver :)
06:05:10 <sshine> but I could be wrong... I don't think Stack + GHCJS is a common combo.
06:05:39 <ahri> no I was wondering about that, I can give it a resolver for the corresponding GHC version this GHCJS is based on, but I have no idea whether that will work
06:06:03 <sshine> ahri, did you try with cabal yet? since cabal doesn't try to manage GHC, it should gladly pick whatever GHC you've got.
06:06:26 <ahri> not yet, I'm not sure how to tell it to to use my GHCJS binary
06:06:31 <sshine> probably not gonna work well... isn't GHCJS a very old GHC?
06:06:49 <sshine> what happens if you just run cabal? it uses the wrong GHC?
06:07:24 <sshine> ahri, have you considered looking for a template for your GHCJS project? some of this configuration could come for free.
06:07:37 <ahri> the ghcjs binary is called "ghcjs" so I don't know how it would even look for that
06:07:41 <sshine> OK.
06:07:52 <ahri> as for its age, I have ghcjs based on ghc 8.6.2 so it's not bad
06:08:24 <phadej> cabal build takes --ghcjs and --with-compiler flags
06:08:49 <ahri> a template might be useful, I'll have a look
06:08:53 <sshine> oh wow, I thought GHCJS was still on 7.x :)
06:08:59 <ahri> phadej: oh cool, thanks
06:09:35 <ahri> yeah so my current project is actually based on Haste, which is stuck on 7.x, this is why I want to try out ghcjs!
06:13:38 <frdg> I have lists List1 and List2. I would like to compare the head of List1 with every element of List2, then I would like to do the same with List1's tail.  What is a nice way to do this?
06:17:42 <frdg> this is like a nested loop in other languages now that I think about it.
06:19:01 <phadej> :t \xs ys m -> Data.Foldable.for_ xs $ \x -> Data.Foldable.for_ ys $ \y -> m x y
06:19:03 <lambdabot> (Applicative f, Foldable t1, Foldable t2) => t1 t3 -> t2 t4 -> (t3 -> t4 -> f b) -> f ()
06:25:59 <pjb> frdg:  compareHeadWithElements list1 list2 = map (\e -> (head list1) < e) list2   compareHeadWithElements [3, 2, 1] [1, 2, 3, 4, 5] => [False,False,False,True,True]
06:26:35 <hololeap> frdg: what type signature do you want it to have? it isn't clear (to me) what you want to do
06:27:37 <pjb> frdg: how do you compare elements of list2 with an element of list1 and also with a tail of list1?
06:27:49 * hackage primal 0.2.0.0 - Primeval world of Haskell.  https://hackage.haskell.org/package/primal-0.2.0.0 (lehins)
06:27:54 <hololeap> do you want to have a growing list of every comparison, or do you want to stop when a comparison has a certain result?
06:28:28 <pjb> do you want to compare all the elements of list1 with all the elements of list2? That would seem more logical.
06:29:37 <hololeap> % liftA2 compare [1,2,3] [2,3,4]
06:29:38 <yahb> hololeap: [LT,LT,LT,EQ,LT,LT,GT,EQ,LT]
06:30:14 <pjb> compareLists list1 list2 = map (\e1 -> map (\e2 -> e1 < e2) list2) list1  ; compareLists [3, 2, 1] [1, 2, 3, 4, 5] ==> [[False,False,False,True,True],[False,False,True,True,True],[False,True,True,True,True]]
06:35:49 * hackage primal-memory 0.2.0.0 - Unified interface for memory managemenet.  https://hackage.haskell.org/package/primal-memory-0.2.0.0 (lehins)
06:57:58 <shad0w_> https://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/
06:58:38 <shad0w_> did ^that start the entire monads are like burritos thing ?
07:08:46 <dminuoso> shad0w_: No
07:10:32 <merijn> No, a blogpost going "monads are like burritos" started that
07:10:36 <merijn> Which is objectively stupid
07:10:43 <merijn> Because monads aren't like burritos
07:10:52 <merijn> *co*monads are like burritos
07:10:53 <AWizzArd> merijn: do you use Emacs and the Haskell Language Server?
07:11:00 <merijn> "it's hard to keep things inside"
07:11:06 <merijn> AWizzArd: No and no :p
07:11:06 <AWizzArd> hah :)
07:11:16 <AWizzArd> merijn: omg, vi?
07:11:42 <merijn> vim and some crazy version of ghcide which works so I refuse to touch it :p
07:12:16 <pjb> wise programmer!
07:14:45 <shad0w_> AWizzArd: lmao not that you asked but, yes and yes ; )
07:15:53 <AWizzArd> shad0w_: excellent, just one question: how do I know that my installation is working correctly? How can I trigger something special that shows me "yup, this thing IS working"?
07:15:53 <shad0w_> merijn: DONT TOUCH THAT. i was on version that worked. worked goood for months. then i updated without looking like a moron.
07:16:19 <shad0w_> AWizzArd: you open a haskell file. look at the mode-line bellow
07:16:45 <shad0w_> if lsp-mode and lsp-haskell are installed and lsp-mode is hooked to haskell-mode
07:16:45 <sshine> AWizzArd, I experienced that Haskell's LSP + Emacs LSP = really ugly.
07:16:52 <merijn> shad0w_: I've been working on this codebase for like 4 years without ghcide, so I'll be fine. But the fact that after opening it suddenly worked after updating is nice :)
07:17:14 <sshine> AWizzArd, maybe I'm an Emacs retard, but the "popups" would basically just flood the buffer in unwanted ways. it was not nice to look at yet. and it seemed somewhat easy to fix, but I couldn't bother.
07:17:36 <sshine> AWizzArd, this was a year ago. maybe something great happened here. the LSP part has surely matured. :)
07:17:48 <AWizzArd> sshine: so far I am used to Intero, which seems to offer the best Haskell experience yet.
07:18:02 <sshine> AWizzArd, ah ok. did you try VSCode yet?
07:18:13 <shad0w_> AWizzArd: first you'd see LSP[lsp-haskell:123456] in the modline
07:18:35 <sshine> AWizzArd, I did try Intero. it was good.
07:18:40 <shad0w_> second there'd be all kinds of popups as you start typing. autocomplete. type informations. really hard to miss
07:18:57 <sshine> yeah, it really kinda floods your screen. e.g. if your cursor rests on an identifier, it provides a type hint.
07:19:25 <frdg> hololeap , pjb: sorry for late response. Here is a better explanation of what I would like to do. I have a predicate `p :: a -> b -> Bool`. I would like to apply `p` to with each comparison of the head of List1 with the elements of List2. If the predicate holds I would like to perform `IO ()` and run the function again with the tail of List1.
07:19:49 * sshine will move back to Emacs once he has a day to pull out of his calendar. ;-)
07:19:52 <AWizzArd> shad0w_: okay, I’ll be looking for those popups and autocompletions.
07:20:12 <AWizzArd> sshine: very good. Emacs is the one and only (:
07:20:13 <frdg> the function should terminate if and only if  List1 is empty
07:20:29 <sshine> AWizzArd, VSCode is pretty neat. but I miss my shortcuts.
07:21:03 <AWizzArd> sshine: I gave vscode a few tries. Not bad at all.
07:21:38 <shad0w_> make sure you turn on interactive-haskell-mode too
07:21:43 <shad0w_> AWizzArd: ^
07:21:53 <sshine> frdg, so... for_ xs (\x -> for_ ys (\y -> when (p x y) m))
07:21:57 <shad0w_> i found mine doesn't really work if i dont do that
07:22:23 <Guest58863> vs code is really good
07:22:36 <sshine> frdg, where those are Data.Foldable.for_ and Control.Monad.when
07:22:46 <shad0w_> i installed vs code today to see what all the buzz is about
07:22:54 <shad0w_> nope'd in 15 minutes : /
07:22:58 <frdg> sshine: I did not think of using when. What is `m` in the expression?
07:23:12 <AWizzArd> frdg: in your type signature you promise that you will deliver a pure value, a Bool. So you won’t be able to run IO action, as you didn’t promise it in the sig.
07:23:57 <sshine> shad0w_, sure, I get it. but what I'm amazed about is: did you notice that it just downloaded and compiled the necessary LSP stuff? the user experience, beyond your unfortunate opinions about what a good editor is, is really great. :) (unfortunately I have too many opinions, too, which is why I have to run a combination of nvim, emacs and vscode.)
07:25:01 <shad0w_> sshine: i already had all the lsp-stuff installed on my system so it didn't do anything
07:25:02 <pjb> frdg: the problem is that with list :: [a]  head list :: a  and tail list :: [a]  therefore you cannot use the sane p to compare head list and tail list with the elements of list2.
07:25:04 <AWizzArd> shad0w_: is there a way to get the signature of a part of an expression?
07:25:21 <shad0w_> AWizzArd: the wut?
07:25:39 <shad0w_> sshine: but what it did was work right away.
07:25:41 <AWizzArd> shad0w_: I have:   foo a b c    And I want to know what type   `foo a b` has.
07:26:04 <shad0w_> in emacs? sure
07:26:10 <AWizzArd> In Intero I can simply mark `foo a b` and will see its signature. The sig of the marked expression.
07:26:43 <justsomeguy> What's a good rule of thumb for when to use tuples rather than record types or a data structure like Map?
07:27:58 <shad0w_> AWizzArd: the way i do it is turn on the interactive-haskell-mode
07:28:10 <shad0w_> go C-c C-l
07:28:13 <justsomeguy> (Tuples seem strange to me, so I'd like to only use them when appropriate. “length (1,2)” or ``fmap (+3) (1,2)” don't do what I'd expect, for example.)
07:28:22 <shad0w_> i'll load the entire file in a ghci buffer for you
07:28:30 <shad0w_> you could just do 
07:28:33 <shad0w_> :t foo a b
07:28:35 <lambdabot> error:
07:28:35 <lambdabot>     • Variable not in scope: foo :: Expr -> Expr -> t
07:28:36 <lambdabot>     • Perhaps you meant ‘for’ (imported from Data.Traversable)
07:28:38 <shad0w_> like you do in ghc
07:29:08 <pjb> frdg: what does the "predicate holds" mean when comparing head list1 to each element of list2 gives a list of booleans? (also you have to check for the end of the list1).
07:29:27 <shad0w_> it might seem like an overkill, but what i like about it is consistency : )
07:29:28 <pjb> frdg: do you want to do a OR or an AND or some other reduction of the results? (majority vote? something?)
07:29:33 <Cale> justsomeguy: With respect to the Functor/Traversable/Foldable instances, you should think of pairs as being containers that hold a single element (the last component) with an additional "label" (the first component)
07:30:00 <frdg> pjb: predicate holds just means it returns true. This should be an OR reduction I believe
07:30:52 <Cale> justsomeguy: They're good as abstract things, but often you will want to transition to defining a proper data type once you have good names for the fields and especially if there are more than two of them
07:32:38 <frdg> Though I know that there exists exactly one element in List2 such that `p (Head List1) ` will hold.
07:33:20 <frdg> for all elements in List1.
07:33:29 <AWizzArd> any :: Foldable t => (a -> Bool) -> t a -> Bool
07:34:08 <AWizzArd> shad0w_: ah okay, so it comes with a repl
07:34:37 <justsomeguy> Cale: Would you say it's a good idea to use tuples mostly to facilitate passing around small collections of short-lived things using pattern matching?
07:34:42 <shad0w_> AWizzArd: how cool is that?
07:34:49 <shad0w_> you can do all kinds of stuff
07:35:01 <AWizzArd> shad0w_: yet still, I can’t see the signature easily. Even a repl won’t help me, because I won’t be "inside" the right context.
07:35:05 <shad0w_> it's a haskell-mode thing. nothing to do with lsp though
07:35:23 <AWizzArd> shad0w_: yes cool, but it is also required. repl is a must.
07:35:31 <shad0w_> lsp would show you the type of the entire thing.
07:35:54 <AWizzArd> shad0w_: okay, I will then have to see how to get it showing the sig of marked expressions
07:35:56 <shad0w_> there would probably some way to see partial types, but i am not aware of the lsp way to do it yet.
07:36:09 <AWizzArd> Yeah, maybe they don’t have it yet.
07:36:09 <Cale> justsomeguy: I guess, though the same thing could be said of almost any user defined data type as well, so I don't know
07:36:24 <shad0w_> AWizzArd: dante and intero were good with this simple stuff
07:36:53 <AWizzArd> shad0w_: totally!
07:37:11 <shad0w_> maybe you could still use them alongside lsp ?
07:38:46 <justsomeguy> I guess I'll just have to get a feel for it through experience. Your tip about Functor/Traversable/Foldable helps. Thanks Cale :)
07:38:47 <shad0w_> AWizzArd: just checked. you sure can
07:38:52 <sshine> justsomeguy, I might use a record if I'm passing a value past a boundary that is somewhat a public API... when to name things is probably not specific to Haskell, or even FP.
07:39:16 <shad0w_> not sure if they'll interfere with each other in complex cases tho
07:39:26 <Cale> justsomeguy: Yeah, if you think of (k,v) as being a "key/value" pair, it might make more sense how e.g. fmap acts on the value, but not the key
07:39:50 <sshine> justsomeguy, if you can resolve your tupling in the same line as you introduce them, that's excellent. :)
07:39:57 <shad0w_> i just did `dante-mode` in a lsp-haskell enabled buffer and asked for type info. no problems.
07:40:07 <Cale> justsomeguy: But also, it works the way that it does because that is literally the only legal thing it could do -- if you try writing the instance, you'll see, the type system enforces it.
07:40:07 <sshine> shad0w_, nice.
07:40:19 <sshine> shad0w_, makes me want to try it soon again.
07:40:30 <shad0w_> they're all minor mode after-all
07:40:52 <shad0w_> lsps goto definition and instance highlighting are dope
07:41:00 <shad0w_> dante for type stuff.
07:41:11 <shad0w_> sweet win.
07:41:14 <shad0w_> or so it seems lol
07:42:21 <sshine> didn't try dante-mode before.
07:46:44 <pjb> frdg: and once we've compared the tail what do we do? Do you want to reduce also with each elements of list1?
07:46:44 <pjb>  
07:52:02 <frdg> pjb: Here is the code I am talking about. I need to do some more work to be able to tell if it is behaving correctly. All credit to sshine here. https://dpaste.org/9Zyd
08:24:14 <Guest58863> https://oleg.fi/gists/posts/2020-08-04-git-badc0de.html is another very nice post from phadej
08:27:23 <Guest58863> the GC statistics look pretty awesome, it would be interesting to see the original unoptimised stats
08:39:34 <phadej> Guest58863: they looked bad.
08:46:59 <Guest58863> also interesting: Haskell's Children, https://news.ycombinator.com/item?id=24565019
09:11:08 <slack1256> Has anyone done "sed scripts" but with the pipes-ecosystem and a parser combinator library?
09:11:47 <maerwald> slack1256: that is planned for streamly, but I don't think they're there yet
09:13:14 <slack1256> Mmm well any streaming library works. The thing is how to operate over each line of text, so example to substitute strings or having more flexibility.
09:13:27 <slack1256> I can always yield the lines where I don't do anything.
09:17:06 <theopcoder> hello
09:23:29 <AWizzArd> For a serious app I’m using servant with many routes. Now I want to build a tiny (dockerized) service. Still servant? Maybe snap? Directly warp? I just want a minimalistic setup.
09:25:02 <maerwald> why do you use servant?
09:26:17 <maerwald> last time I touched servant, I had to edit 8 files in total to add a handler
09:27:17 <maerwald> scotty and snap are both simpler
09:28:06 <Guest58863> slack1256: I think one or two such tools are on hackage, but I don't remember their names
09:28:28 <Guest58863> is there any hoogle instance that covers all of hackage ?
09:28:33 <maerwald> Snap may be the thing with the best simplicity-feature balance
09:28:59 <maerwald> I wouldn't mind using it for both toy and serious projects
09:29:22 <Guest58863> slack1256: http://hackage.haskell.org/package/haskell-awk I guess but it may not be streaming in that sense
09:29:30 <AWizzArd> maerwald: okay, will try snap. I want to use it programatically and not use the snap exe as shown in the quick tutorial.
09:29:37 <maerwald> if you don't have a real consumer of your servant types... then there's no point
09:30:38 <AWizzArd> maerwald: we liked the idea in servant that the handlers are described in types. I only need to edit in some cases one single file to change/add a route to servant.
09:31:08 <maerwald> the point of having it as types is to have consumers of those types... otherwise there's no point
09:31:35 <maerwald> (consumers being a haskell client or something that generates clients based on them)
09:31:48 <AWizzArd> maerwald: I see what you mean.
09:33:01 <cr0ssw1nd> hey
09:34:54 <cr0ssw1nd> curious, why ByteString is a "String" and not "Array" ?
09:35:12 <AWizzArd> maerwald: what package do I need to use if I just want to use snap programatically? snap-server? snap-core?
09:36:06 <geekosaur> it's an array underneath. but it exports a String interface, not an Array (those already exist elsewhere, see Vector and Array)
09:36:17 <maerwald> AWizzArd: usually both
09:36:27 <maerwald> AWizzArd: https://github.com/tomsmeding/pastebin-haskell is a simple example
09:36:42 <geekosaur> basically, you use types in part to say how you want to make use of the data
09:37:13 <maerwald> cr0ssw1nd: it's an unfortunate name overall too
09:37:41 <cr0ssw1nd> geekosaur, so it is usually assumed that ByteString is a piece of text?
09:38:10 <geekosaur> ByteString treats it more like a string than an array, including that you typically stream it instead of cutting it into individual characters (although as a string it misses some things like encoding support, so you don't want to treat it *too* much like a string)
09:38:42 <geekosaur> and no, unless you mean raw "text" as transmitted over the internet
09:38:45 <cr0ssw1nd> got it, kinds semi-string semi-bytes
09:38:59 <maerwald> geekosaur: it's the other way around :p String loses encoding info, ByteString doesn't. But you have to carry it around or programmatically figure it out
09:39:09 <geekosaur> but even then you want to distinguish between the raw octet form that's transmitted and characters in some useful encoding
09:39:13 <cr0ssw1nd> I'm trying to implement conversion of any type (String) into UUID
09:39:46 <cr0ssw1nd> the idea was to convert to ByteString, take 2 halves, hash them into Int, total I have 128 bit, then I can convert to UUID
09:40:07 <cr0ssw1nd> but what I found that UUId is being parsed from ByteString assuming that there are - characters
09:40:11 <cr0ssw1nd> '-'
09:40:42 <cr0ssw1nd> (conversion from String to ByteString in the beginning actually makes no sens, I can hash halves of just String)
09:41:33 <cr0ssw1nd> https://github.com/wireapp/wire-server/blob/develop/libs/types-common/src/Data/Id.hs#L146
09:41:57 <geekosaur> that's pretty unfortunate, I'd expect the direct encoding myself given what ByteString is. but someone apparently used it as a textual type. (as maerwald said, ByteString is somewhat unfortunately named)
09:42:41 <maerwald> what about ByteStream
09:42:46 <geekosaur> that said,many network standards talk about octet strings and I'd again argue they're not really that string-like
09:42:51 <geekosaur> that'd be better, yes
09:43:13 <geekosaur> some standards talk about octet sequences which would also be better, but that's uncommon iirc
09:47:48 <dolio> "String" is a synonym for array or list in English.
09:48:20 <cr0ssw1nd> hmm
09:48:21 <dolio> And mathematicians sometimes refer to values of free monoids/groups as "words".
09:48:36 <cr0ssw1nd> makes sense actually
09:48:46 <geekosaur> I'm not sure I'd drag English into the discussion. Consider "sort"
09:49:13 <cr0ssw1nd> but if list and string are the same, then there is even more confusion
09:49:28 <maerwald> :t sort of
09:49:29 <lambdabot> error: parse error on input ‘of’
09:49:58 <dolio> The jargon you're talking about is borrowed from English.
09:50:28 <geekosaur> also it turns out that the basic String type is a list
09:50:37 <maerwald> I have a bytestring theory
09:50:43 <yushyin> in class we often called a list of bits a bitstring, for me bytestring is just bitstring in eightfold!
09:53:08 <cr0ssw1nd> technically all maths are deeply connected to texts :)
09:53:33 <cr0ssw1nd> would be difficult to do it without text symbols
09:53:45 <cr0ssw1nd> at least in the form it developed
09:54:24 <dolio> Anyhow, it's the same as "list" not necessarily meaning "linked list" to all people, even though in a specifically Haskell context, that's what people usually mean it to refer to.
09:57:47 <cr0ssw1nd> what is the quicker way to do this?
09:57:48 <cr0ssw1nd> Int -> (Word16, Word16, Word16, Word16)
09:57:55 <cr0ssw1nd> *quickest
09:58:46 <cr0ssw1nd> hmm, I see "foundation" package
09:58:51 <cr0ssw1nd> but not sure that I should try it
09:58:55 <yushyin> better name would be CharString instead of String :P
09:59:10 <davean> cr0ssw1nd: You can but Data.Bits for example.
09:59:27 <davean> cr0ssw1nd: sadly (Word16, Word16, Word16, Word16) doesn't share a representation with Int.
09:59:42 <cr0ssw1nd> wait
09:59:53 <cr0ssw1nd> Int isn't 64 bit?
09:59:55 <davean> so its just shifts and ands
10:00:08 <geekosaur> the problem is, so is Word16
10:00:17 <davean> Might not be, but if it was it definately wouldn't share a representation
10:00:22 <davean> Int64 is 64bits
10:00:24 <dolio> There's a whole module for Word8-based stuff on each bytestring type.
10:00:25 <davean> Int is whatever you get
10:00:36 <davean> Word16 is platform word size also
10:00:38 <davean> plus () boxes
10:00:42 <davean> so thats actually 4 pointers
10:00:45 <dolio> And the character ones are the ones that specifically mention characters.
10:00:47 <geekosaur> ghc doesn't like to deal with things smaller than a machine word
10:00:53 <cr0ssw1nd> [-2^29 .. 2^29-1]
10:00:57 <cr0ssw1nd> so 2^30 total
10:01:02 <cr0ssw1nd> why so?
10:01:13 <cr0ssw1nd> why not 2^32
10:01:15 <davean> cr0ssw1nd: Marking bits.
10:01:20 <geekosaur> the standard mandates that as a minimum size, leaving room for tag bits
10:01:27 <davean> cr0ssw1nd: but, you generally do get 64bits on 64bit platforms
10:01:31 <geekosaur> ghc happens to ignore the standard there
10:01:35 <davean> theres just not guarrentee
10:01:44 <davean> but if you demand Int64, use Int64
10:01:49 <davean> Don't guess at what a thing means
10:01:55 * monochrom frowns. That's not "ingore", that's "exceed".
10:02:08 <cr0ssw1nd> but what metadata needed from integer?
10:02:28 <cr0ssw1nd> Int is used by Hashable..
10:02:28 <davean> cr0ssw1nd: things like GC tags
10:02:30 <geekosaur> whether the garbage collector has seen that particular value yet or not
10:02:39 <cr0ssw1nd> davean, ooh, ok
10:02:43 <cr0ssw1nd> now I get it
10:02:49 <geekosaur> which isn't relevant to ghc's garbage collector but is to some others
10:03:07 <davean> cr0ssw1nd: It allows a less overhead for Int in some prepresentations (runtime systems)
10:03:17 <davean> cr0ssw1nd: which if you wanted a really small Haskell program for example ...
10:03:28 <davean> it COULD be useful, GHC doesn't use it, but also Int would be 32 bits on 32 bit platforms
10:03:39 <davean> so really, why not say what you want?
10:03:43 <davean> And yes 'hashab'e
10:03:51 <davean> but hashable doesn't even hash
10:04:16 <davean> http://hackage.haskell.org/package/hashable-1.3.0.0/docs/src/Data.Hashable.Class.html#line-312
10:04:21 <AWizzArd> maerwald: oki thanks, i got it working with a basic route and believe I can make it do something meaningful from here.
10:05:04 <davean> (You may just want to use something that depends on hashable mind you)
10:05:16 <cr0ssw1nd> wait.. doesn't hash?
10:05:17 <davean> (but its somewhat important to know that hashable is a lie)
10:05:21 <davean> cr0ssw1nd: look at that code
10:05:23 <davean> it does not hash
10:05:31 <davean> hash = id
10:05:53 <davean> Like seriously the package should have that in big blinding letters.
10:06:01 <cr0ssw1nd> for Int
10:06:20 <cr0ssw1nd> but other instances are different
10:06:25 <davean> For many things, 'Hashable' doesn't mean you get any independency
10:06:31 <davean> cr0ssw1nd: some of them
10:06:52 <davean> 'Hashable' isn't even pairwise independent though.
10:06:58 <davean> or anything.
10:06:59 <cr0ssw1nd> I guess I should take some lib then
10:07:08 <davean> it depends on what you're doing
10:07:11 <monochrom> id is as pairwise independent as you can get
10:07:17 <davean> That may or may not be fine, but you need to know it
10:08:02 <davean> monochrom: I'd have to double check, I remember this ruining a lot of things because of its predicability.
10:08:28 <monochrom> Do you have hash tables in mind?
10:08:40 <davean> No, mostly it was sketches
10:08:45 <monochrom> Or do you have cryptography in minad?
10:08:59 <davean> No, cryptography requires cryptographicly secure hashes
10:08:59 <monochrom> Because hashable is for hash tables only.
10:09:14 <davean> I'm talking hashtable based datastructures
10:09:15 <dolio> Is there a better name for what hashable does? Seems like there should be.
10:10:17 <dolio> id isn't really even a good hash for hashtables, no? Although they're not really used for hashtables.
10:10:35 <davean> dolio: no, its really not :/
10:10:59 <cr0ssw1nd> davean, I just want to get deterministically random `UUID`s from `String`s
10:11:01 <dolio> It's probably nice in whatever trie sort of thing unordered containers uses.
10:11:10 <cr0ssw1nd> I see the answer at SO though
10:11:22 <cr0ssw1nd> no hashtables
10:11:26 <cr0ssw1nd> no cryptography
10:11:27 <davean> cr0ssw1nd: use http://hackage.haskell.org/package/uuid then - what you're doing WOULD NOT GENERATE A VALID UUID
10:11:50 <davean> UUIDs have standards
10:11:52 <davean> its in the RFC
10:11:59 <davean> 'uuid' generates them via said standard
10:12:08 <cr0ssw1nd> I have to get value of this interface actually https://github.com/wireapp/wire-server/blob/develop/libs/types-common/src/Data/Id.hs#L146
10:12:17 <cr0ssw1nd> yeah but bits are bits, no?
10:12:18 <davean> you want version 3 or 5
10:12:22 <davean> cr0ssw1nd: No
10:12:31 <davean> UUIDs have structure
10:12:31 <cr0ssw1nd> so it is not true 128 bits?
10:12:47 <cr0ssw1nd> it's just size of it but not amount of information there?
10:12:49 <davean> UUIDs have structure and guarrentees
10:13:08 <cr0ssw1nd> but look at the code by link
10:13:15 <cr0ssw1nd> so it is not conventional UUID?
10:13:23 <cr0ssw1nd> just hexdigits
10:13:26 <dolio> WordTrieKeyable
10:13:28 <cr0ssw1nd> with dashes
10:13:41 <davean> cr0ssw1nd: thats how you read one, not what the data means.
10:13:49 <davean> Theres dashes where there are for a reason.
10:13:57 <cr0ssw1nd> damn
10:14:06 <davean> 'uuid' will generate them as you want
10:14:31 <davean> V1 are based off the mac address of the computer they're generated, a random generation number, and the time
10:14:47 <davean> thats how they know its unique for example, because MAC addresses were not for reuse (sadly VMs ignored that)
10:14:55 <davean> V3 is based off MD5ing the data
10:15:02 <davean> V5 is based off SHAing the data
10:15:11 <geekosaur> actually they claimed not to want the dashes earlier
10:15:14 <davean> V4 is all but the tagging bits random.
10:15:16 <cr0ssw1nd> probably I should just hardcode UUIDs then
10:15:24 <cr0ssw1nd> it's just a migration lol
10:15:28 <davean> cr0ssw1nd: why not generate them with the V5?
10:15:43 <davean> generateNamed :: UUID -> [Word8] -> UUID
10:15:55 <cr0ssw1nd> I have `randomId` method already
10:15:57 <davean> you generate a UUID as your namespace, you serialize the data into it, and you get a UUID
10:16:40 <davean> If you just want random ones, go V4
10:17:02 <davean> nextRandom :: IO UUID
10:18:15 <cr0ssw1nd> https://github.com/wireapp/wire-server/blob/develop/libs/types-common/src/Data/Id.hs#L168
10:18:34 <cr0ssw1nd> the thing is that I use the same collection of usernames in 2 binaries
10:18:40 <cr0ssw1nd> so different UUIDs are generated
10:18:44 <davean> Thats what V5 is for
10:19:01 <davean> V3 and V5 generate consistent UUIDs for a given piece of data.
10:19:26 <cr0ssw1nd> but I don't want to generate UUID and then convert it to their (Id a)
10:19:36 <cr0ssw1nd> they already have FromByteString
10:20:01 <cr0ssw1nd> I think it becomes just impragmatic
10:20:13 <davean> ?
10:20:14 <cr0ssw1nd> for migration
10:20:19 <cr0ssw1nd> it is just test data
10:20:32 <cr0ssw1nd> I will hardcode it
10:20:46 <davean> Also why did you write your own UUID deserializer?
10:21:13 <cr0ssw1nd> I didn't, I wanted to convert user names into hashes and then to UUID
10:21:26 <cr0ssw1nd> but yeah
10:21:27 <davean> FromByteString (Id a)
10:21:31 <davean> That code
10:21:31 <cr0ssw1nd> I forgot about structure of UUID
10:21:37 <cr0ssw1nd> it's not my code
10:21:41 <davean> Ah
10:21:43 <cr0ssw1nd> I am working on fork of it
10:22:16 <davean> Thats already in uuid and such
10:22:26 <cr0ssw1nd> just hashing would be a bit better, would automatically scale if I create more test data
10:23:11 <cr0ssw1nd> davean, it looks for me there is a lot of stuff written from scratch :)
10:23:21 <davean> cr0ssw1nd: yah, very confusing to me
10:24:42 <davean> I'd say the 'uuid'/'uuid-types' deserializers of them are much better.
10:25:03 <davean> well at least faster.
10:25:09 <davean> and equally as correct
10:25:49 * hackage futhask 0.1.0 - Generate Haskell wrappers for Futhark libraries  https://hackage.haskell.org/package/futhask-0.1.0 (GustenIsfeldt)
10:48:49 <AWizzArd> I started a Snap server via `quickHttpServe` and see logs appearing that say:  Can't open log file "log/error.log". Exception: log/error.log: openFile: does not exist (No such file or directory)
10:49:06 <AWizzArd> Those messages appear in my ghci session.
10:49:28 <AWizzArd> What does this mean? Does Snap expect that those files already exist when starting the server?
10:49:57 <AWizzArd> Can I let Snap know that I am happy with it logging to Stdout (because AWS CloudWatch will grab everything there and save it away nicely for me)?
10:50:02 <geekosaur> Id start by making sure the log directory exists
10:50:43 <AWizzArd> geekosaur: good, that removed the message. There was indeed no log/ folder yet.
10:51:02 <AWizzArd> geekosaur: I still would love to convince Snap to log everything to Stdout instead.
10:51:10 <geekosaur> as fr th other, almost certainly possible but I don't know snap
10:51:20 <AWizzArd> Okies, I will find that out later :)
10:51:40 <geekosaur> and it might not be part of quickHttpServe but some more involved interface
10:52:30 <AWizzArd> Yes, I see it’s using FastLogger, which I happen to know from another project. I’ll see how I can configure that guy.
11:25:32 <AWizzArd> In Snap a Config is a Monoid. It exports  `setXYZ val Config`  to change certain aspects of the defaultConfig.  I want to change two settings. Is there a "trick" to do this in a more clever way?  let conf = setX myX (setY myY defaultConfig)
11:26:56 <AWizzArd> If I want to add Z and also A, B and C then this nesting will get pretty deep.
11:29:31 <AWizzArd> I thought about something like bind     defaultConfig >*> setX myX >*> setY myY ...
11:41:44 <maralorn> AWizzArd: Is it a Monoid in the sense of the type class?
11:43:03 <AWizzArd> maralorn: yes
11:43:21 <maralorn> AWizzArd: Then you want either fold [defaultConfig, setX myX, setY myY] or defaultConfig <> setXmyX <> setY myY.
11:45:12 <AWizzArd> maralorn: I thought exactly about that second variant, with (<>).
11:47:09 <AWizzArd> maralorn: I just didn’t see that the "second parameter" would be filled in via <>.
11:47:47 <AWizzArd> (<>) :: Semigroup a => a -> a -> a
11:48:06 <AWizzArd> The  defaultConfig :: Config    so a = Config
11:48:42 <AWizzArd> Now setX :: X -> Config -> Config
11:49:09 <AWizzArd> So I thought that    setX X would have the type   Config -> Config
11:49:48 <maralorn> Ah, yeah. It does.^^
11:50:15 <AWizzArd> It is extremly close to what I want, which is "bind for monoids".
11:53:27 <maralorn> AWizzard: The question is this. What exactly does setX do? Can't you just do defaultConfig <> myX
11:53:40 <maralorn> Ah, okay
11:53:51 <maralorn> I see that's probably a dumb question.
11:55:19 <maralorn> But of course what you really want there is function composition. So setX myX $ setY myY $ defaultConfig would just work fine. Although that is boring because it doesn‘t use the Monoid instance.
11:56:39 <AWizzArd> maralorn: also a very good idea, I was just wondering if I could indeed gain anything from it being a Semigroup/Monoid.
11:58:32 <maralorn> AWizzArd: You can do it: defaultConfig <> foldMap (\f -> f emptyConfig) [setX myX, setY myY]
11:58:36 <maralorn> But not sure if that's worth it.^^
11:58:45 <AWizzArd> Hehe yes :)
11:58:59 <AWizzArd> In the end it must be doable by folding.
11:59:30 <maralorn> Of course, but that would again not use the Monoid instance
12:00:24 <maralorn> foldr ($) defaultConfig [setX myX, setY myY]
12:01:16 <AWizzArd> exactly
12:01:20 <maralorn> And so I can spend an evening on all possible rewrites of a single line of Haskell.
12:01:41 <AWizzArd> Well, for now I will just live with the nested settings.
12:01:46 <AWizzArd> maralorn: but it was fun :)
12:56:19 * hackage pantry 0.5.1.3 - Content addressable Haskell package management  https://hackage.haskell.org/package/pantry-0.5.1.3 (MichaelSnoyman)
13:21:18 * hackage lio 0.11.7.1 - Labeled IO Information Flow Control Library  https://hackage.haskell.org/package/lio-0.11.7.1 (DeianStefan)
13:58:48 * hackage rng-utils 0.3.1 - RNG within an IORef for convenient concurrent use  https://hackage.haskell.org/package/rng-utils-0.3.1 (MichaelXavier)
14:19:15 <monochrom> Suppose I have an ADT "data T = C1 | C2 Int | C3 Char Double".  Do you say: There are 3 variants? 3 cases? 3 summands? Or any wording I haven't named but you already use.
14:19:55 <monochrom> I understand that it can be "3 constructors", but for a technical reason I want to avoid that until the last resort.
14:20:16 <dolio> I'd say cases if not constructors, probably.
14:20:43 <dolio> Although normally I'd probably only say that if talking about matching.
14:22:26 <dolio> You could say 'tags' too, maybe. 'Summand' (or similar words) is probably the worst.
14:23:12 <monochrom> Heh.
14:23:48 <MarcelineVQ> monochrom: I'd be more likely to say cases but 'choices' is an option too
14:24:04 <MarcelineVQ> options, etc
14:24:19 <monochrom> I included "summand" as a candidate because the whole sentence goes like "the sum structure, if there are 2 or more summands, is represented by the :+: type"
14:24:20 <MarcelineVQ> Depends on the sentences preceding the use of the word
14:24:54 <monochrom> (For the larger context, I'm writing a tutorial or study notes for GHC.Generics!)
14:28:05 <MarcelineVQ> "a value of T can take 3 distinct forms" is something I'd be likely to say too, especially if I didn't want to look up the word summand
14:35:16 <hekkaidekapus> monochrom: In “Software Foundations”, `Inductive day : Type := | monday : day | tuesday : day`, monday, tuesday, etc are called members of `day`.
14:44:49 <phadej> but they are nullary constructors
14:44:52 <phadej> so member makes sense
14:45:39 <phadej> but in "data Nat = Z | S Nat", Z is member of Nat, but S isn't, when n is member of Nat, then `S n` (applied!) is member of Nat
14:46:28 <phadej> i.e. I think "is member of" is another way to say "is value of type"
14:46:37 <EvanR> in everyday language you imagine something can be members of more than one club at the same time, but types don't allow that
14:46:43 <hekkaidekapus> The “member” naming lasts for a one paragraph, then “constructor” takes over.
14:46:59 <EvanR> unless it's one of those off the wall subtyping theories
14:47:05 <phadej> EvanR: yeah, member has very set-theoretical ring to it :)
14:47:17 <phadej> one thing can be member of many sets
14:48:07 <EvanR> think of types as sets, until you don't 
14:48:11 <dolio> Not all set theories allow elements to be in more than one set.
14:48:38 <EvanR> true, ETCS
14:48:40 <monochrom> Everyday language also uses very-flexible subtyping, union typing, intersection typing, and stereotyping. :)
14:49:05 <dolio> They can only be in multiple subsets of a given set, but subsets and sets might not be the same thing.
14:49:10 <EvanR> when will GHC support stereotyping?
14:49:41 <phadej> I'd say that "constructor" is the word to use
14:49:49 <phadej> but if one cannot, than it is ones' problem
14:50:14 <EvanR> when in rome
14:50:53 <monochrom> The singletons library (and its design pattern) is based on stereo typing. >:)
14:51:09 <dolio> monochrom: nlab says they're called coprojections.
14:52:34 <monochrom> For example, you have both "Nat(Z, S)" and "SingNat(SingZ, SingS)" at the same level, and they are in bijection. That's a majectic stereo pair of the same type --- stereo typing. >:)
14:53:45 <monochrom> Haha wish me luck if I write a GHC.Generics tutorial and keep saying "coprojections" instead of "data constructors".
14:53:57 <glguy> We need some distingushed base types so we can get 2.1 stereo types...
14:54:04 <monochrom> or even "injections"
14:54:11 <dolio> It says you're also allowed to call them injections or inclusions.
14:54:20 <dolio> Injection could be misleading, though.
14:54:58 <EvanR> if constructors are functions, then they are surely inject. ... right
14:55:05 <EvanR> injective
14:55:23 <monochrom> Nat(Z, S) is also lifted by DataKinds, that's your subwoofer. Also it's "higher" not "lower", so I guess tweezer?
14:55:35 <dolio> Constructors of existential types aren't injective necessarily.
14:55:52 <EvanR> how so
14:56:14 <EvanR> monochrom you mean tweeter?
14:56:34 <dolio> Well, `data E where MkE :: a -> E` only has one value, according to parametricity.
14:56:51 <dolio> So it can't be injective.
14:57:02 <EvanR> 'the count according to parametricity' always tripped me up
14:58:20 <EvanR> if you specialize E so a is Bool, MkE True = MkE False ?
14:58:30 <dolio> Yes.
14:58:33 <phadej> no
14:58:40 <EvanR> round 1 fight
14:58:40 <monochrom> Yeah tweeters.
14:59:03 <phadej> Haskell just doesnt' allow us to extract types of existentials (sigma types)
14:59:10 <int-e> monochrom: Not "twits"?
14:59:15 <phadej> but Sigma Bool True /= Sigma Bool False
14:59:15 <dolio> That's why they're the same.
14:59:22 <dolio> Existential types aren't sigma types.
14:59:26 <EvanR> "the same" ...
14:59:41 <monochrom> A loudspeaker specialized for high pitches.
14:59:56 <EvanR> i think this is where the convo sinks below the surface of the sand trap
15:00:07 <monochrom> The opposite of subwoofer (loudspeaker specialized for low bass).
15:00:08 <int-e> Oh.
15:00:24 <phadej> ok sorry, indeed existential is `Sigma Type id`
15:00:36 <ixlun> Hi all, I'm trying to bootstrap cabal-install and I'm getting this error: http://ix.io/2yyb
15:00:45 <ixlun> Just wondered if anyone has any ideas?
15:01:39 <monochrom> Are you sure you must bootstrap cabal-install?
15:01:57 <parsnip> lazy question: Couldn't match type ‘JsonResponse a0’ with ‘Value’
15:02:25 <parsnip> expected Req Value, actual Req (JsonResponse a0)
15:02:27 <monochrom> ghc-9.1 release candidate?!
15:02:27 <dolio> They are extensionally equal.
15:02:30 <EvanR> you basically claimed that the existential above effectively loses information
15:02:45 <dolio> Yes, hiding information is the purpose of existential types.
15:02:54 <EvanR> but if you add another method to recover hidden info from an extistentially typed value, how could it be lost
15:02:59 <ixlun> monochrom: Yep, I don
15:03:18 <ixlun> don't have any haskell packages on this system
15:03:21 <EvanR> i think we need stephen hawking for this one
15:03:34 <ixlun> so I've built GHC and I'm trying to build cabal to get up and running
15:04:43 <phadej> https://gist.github.com/phadej/828a8e8daf3ec4d90f694f5bafa79356 <- existentials as sigma types
15:04:51 <phadej> and in agda you can tell them appart easilty
15:04:59 <phadej> so MkE True /= MkE False
15:05:01 <dolio> Haskell isn't Agda.
15:05:09 <monochrom> I don't know whether this is an incompatibility betweeh GHC 9.1.0-RC and cabal-install-3.2, or it is a deeper problem.
15:05:13 <phadej> dolio: soon it will be
15:05:23 <EvanR> in Haskell you could include a way of recovering hidden info as part of your API
15:05:31 <int-e> ixlun: "hecking installed packages for ghc-9.1.0.20200923"... probably not a good idea to use an unrelease ghc, but if you do you probably need a development version of Cabal/cabal-install as well.
15:06:37 <parsnip> would you recommend http-client or req library?
15:06:41 <phadej> dolio: have you better argumented explanation how Haskell's existential types are different from that Agda encoding. sans that just hasn't internal power to reason about them
15:06:42 <monochrom> I am also skeptical about the inference "no haskell package, therefore must build from source", but I guess I don't know your system.
15:06:46 <int-e> ixlun: if you built ghc from source (as you said) you can look under libraries/Cabal for sources of those
15:07:33 <ixlun> Yeah, that's what confuses me, GHC's version of cabal was fine
15:07:44 <ixlun> As you say, I probably need a dev version of cabal-install.
15:07:58 <monochrom> Must you use 9.1?
15:08:43 <int-e> ixlun: But it's saner to just use ghc-8.10.2 for now.
15:08:54 <EvanR> extensional equality is apparently relative to a world of things you're allowed to try and check for a difference
15:09:24 <monochrom> Eqaulity itself already is.
15:10:25 <EvanR> extensional equality being a subequality of "equality itself" ... xD
15:10:35 <monochrom> Leibniz law "if x equals y then for all f, f x equals f y". The devil of the detail is what kind of f's you are allowed.
15:10:53 <EvanR> ok, leibniz equality
15:11:29 <glguy> reasoning starts to get hard when you admit things because they are true in other languages, or when you pull aside the runtime-abstractions the language attempts to provide and look into the RTS
15:11:35 <monochrom> "I have not observed any unobservable inequality."  http://www.vex.net/~trebla/humour/tautologies.html #9 :)
15:12:06 <EvanR> nothing unreal exists
15:12:36 <ixlun> int-e: I'd prefer that, but I can't get an aarch64 version of ghc-8.10.2 built
15:12:46 <ixlun> there must have been a fix post then for aarch64
15:12:58 <monochrom> In a nutshell, Leibniz equality is a way to say that inequality has to be observable inequality, you must have an f that tells the difference.
15:13:16 <monochrom> Think of f as an accessor.
15:13:26 <EvanR> doesn't that make it a negatively defined notion
15:13:35 <phadej> glguy: with dataToTag# I can differ `Exists True` and `Exists False` quite easily
15:13:46 <EvanR> equality = no method here to see any difference
15:13:47 <phadej> and I wouldn't even feel dirty
15:14:15 <glguy> phadej: then you're just not reasoning at the level of the language, you're doing something else
15:16:08 <EvanR> nvm
15:16:11 <phadej> yes, I can agree that we (I and dolio) disagree on the "what means equal". I look at those from outside, and they are different to me. It's true that without using any tricks, data Exists where Exists :: a -> Exists is essentially a ()
15:16:30 <phadej> ... from inside Haskell
15:17:19 <EvanR> no way to tell a difference from inside haskell, because the example included no way to. Though it could have
15:17:42 <glguy> EvanR: No point in finding differences in the things we aren't looking at
15:17:43 <EvanR> then you'd have an example of an existential that lost less info
15:19:56 <EvanR> anyway, if you can't tell anyway, does that really mean injectivity is violated?
15:21:01 <EvanR> like is there an observable violation
15:22:04 <monochrom> This is why people have disagreements over what referential transparency means. Because they have disagreements over equality in the first place.
15:22:09 <dolio> EvanR: Injectivity says `Exists False = Exists True -> False = True`.
15:23:38 <phadej> I don't see how `Exists False = Exists True`, is there non handwavy reference on this difference to "more powerful type-systems"
15:23:40 <monochrom> However, I am more reminded of unbelievable compression schemes such as "send it to /dev/null" if you don't expect to recover the information you sent.
15:24:28 <monochrom> Also the Chinese idiom "a safe, the key of which is lost".
15:25:13 <monochrom> That aptly describes the unrecoverable existential type.
15:25:24 <dolio> I think Bob Harper has written about ML modules, abstract types, existential types, and how dependent sigma types are inadequate to correctly model abstract types.
15:25:31 <monochrom> You save some information in it. Then you can't retrieve it.
15:25:31 <EvanR> yeah it's mathemtically not injective but how would it manifest as a bug
15:25:50 <dolio> It is not "more powerful" to be unable to correctly abstract.
15:26:44 <phadej> if we promote, they are not the same: https://gist.github.com/phadej/539de5929c6acad3b8e2fa60fbf68f14
15:26:47 <dolio> Also your position on existential types makes all the equational reasoning people do based on parametricity invalid for Haskell.
15:27:15 <phadej> how so?
15:27:47 <dolio> Or, for whatever you want to call not even thinking about the abstractions Haskell is supposed to have, just the underlying implementation of them on particular computers.
15:28:08 <monochrom> Hrm, you can promote a GADT?! TIL
15:28:33 <phadej> monochrom: somewhere in GHC-8 series we got that
15:28:42 <monochrom> Ah.
15:29:32 <phadej> comparing `MkExists True` and `MkExists False`  is not the same as trying to say something about to arbitrary `x :: Exists` and `y :: Exists`
15:30:29 <EvanR> whatever you concluded about arbitrary Exists ought to apply to these examples or
15:30:39 <EvanR> somethings up
15:32:50 <monochrom> I guess parametricity doesn't apply to the type-kind level?
15:32:50 <EvanR> also since i was asking about constructors it's not necessary to consider arbitrary Exists
15:33:37 <EvanR> really? what about polykinds
15:34:16 <phadej> forall a. a -> a  still has only one non-bottom inhabitant
15:34:21 <phadej> nothing what I said violate that
15:35:44 <phadej> there are work even on internal parametricity in dependent type theories
15:36:00 <EvanR> more polymorphic "counting" shenanigans :'(
15:37:21 <LestatCapulet> Wasabi!
15:37:33 --- mode: ChanServ set +o monochrom
15:37:38 <EvanR> for any given a there are any number of different functions implementing id. But they are extensionally equal. How do you also "consolidate" all the versions across all types too
15:38:00 <EvanR> in what sense are they all the same
15:38:55 <dolio> They're not all the same. I can use some unsound GHC primop to notice they aren't. Q.E.D.
15:39:07 <EvanR> not an answer
15:39:21 <dolio> It's exactly the answer I was met with above.
15:40:08 <phadej> I argue that you cannot differentiate values of type `forall a. a -> a`
15:40:10 * EvanR puts on "I'm with dolio" shirt for clarification
15:40:26 <phadej> you cannot "fix a" and then try to tell them apart
15:41:08 <EvanR> well, you can't differentiate them. I'm asking how you identify them. Or is that the point?
15:41:44 <phadej> parametricity tells that they are all equal.
15:41:54 <EvanR> equal in what sense
15:42:02 <phadej> extensional
15:42:34 <phadej> it doesn't mean that internally you can get that result, and do anything with it
15:43:46 <EvanR> ok I think I got it
15:44:40 <phadej> none of these equalities are decidable, "given values of type X you can tell whether they are equal or not"
15:44:48 <phadej> but in some corner case you may be able
15:46:20 <phadej> e.g. forall a. a -> a -> a, has two values, you can tell if two values are different, but you cannot really tell (without parametricity) that they are the same
15:46:49 <EvanR> i was just trying to think of that example. How do you know if they're different?
15:47:06 <EvanR> but looking an example for a particular a ?
15:47:07 <phadej> f @Bool True False /= f @Bool True False
15:47:09 <phadej> yes
15:47:19 <phadej> err, False True on the other side
15:47:43 <phadej> one example is enough to show they are different
15:48:13 <phadej> if you happen to find one
15:48:59 <phadej> parametricity gives you a hint which examples to try though
15:49:22 <phadej> f @Bool True False /= g @Bool True False -- correct one
15:49:28 <EvanR> an example is enough to establish a new island in the a -> a -> a universe, i guess, but then you need some sort of universal proof to show the next contestant is extentially equal to one of the two 
15:49:42 <phadej> yes, that you cannot do
15:49:50 <phadej> without using parametricity
15:50:20 <phadej> because we cannot try all possible Types
15:50:20 <LestatCapulet> Magic Disney Tatertott Power 4TehWin!
15:51:02 <LestatCapulet> Lets play sum Tetris AAmodafackerz!
15:51:15 --- mode: monochrom set +b *!*@192.95.191.129
15:51:15 --- kick: LestatCapulet was kicked by monochrom (LestatCapulet)
15:51:38 <EvanR> we cannot do what?
15:52:40 <EvanR> (seems to be a netsplit) phadej: we cannot do what exactly?
15:53:15 <glguy> "netsplit" / irccloud instability
15:53:36 <Clint> reboot the internet
15:54:16 <EvanR> I thought it was irccloud.com then i saw edwardk ping timeout too
15:54:52 <glguy> EvanR: what did you conclude from seeing that?
15:55:23 <monochrom> Perhaps edwardk is on irccloud.com too.
15:55:25 <EvanR> there's a conspiracy from irccloud to take down edk's client
15:55:30 <EvanR> or that
15:55:45 <monochrom> I support conspiracy theories.
15:55:50 <EvanR> but he's the only one with a mask? crazy
15:56:21 <glguy> gateway cloaks (like irccloud users have) override unaffiliated cloaks
15:57:05 <dolio> If you want to understand part of why sigma and exists don't line up, you can actually read some of the work on parametricity in dependent type theories. Like Cavallo and Harper on parametricity in cubical type theory. There they point out that 'bridges' (relations, on which parametricity is based) and 'paths' (on which 'equality' is based) disagree for the universe. And the path type for a Σ type corresponds to paths for its components. So a path f
15:57:05 <dolio> or a (Σ U) type is going to be talking about *paths* between types, rather than relations between types. However, the point of a parametric existential type is for values to be equal based on a relational criterion.
15:59:57 <jamestmartin> is it possible to export a function which uses an instance of a typeclass without exporting the instance itself?
16:00:51 <jamestmartin> while also exporting the typeclass, just not the instance
16:02:13 <EvanR> well that helps, parametricity is based on relations
16:02:32 <EvanR> is there a readable paper on that
16:02:57 <glguy> jamestmartin: No, you can't avoid exporting an instance
16:03:09 <jamestmartin> alright then
16:03:20 <dolio> Wadler's Theorems for Free, maybe. I forget.
16:03:37 <jamestmartin> well, with linear types coming soon, that won't be necessary anyhow
16:03:42 <jamestmartin> I was just curious
16:06:26 <jamestmartin> man, I'm hyped for linear types though. that's gonna be useful in so many ways.
16:08:49 <EvanR> linear types coming soon?
16:09:41 <jamestmartin> linear types are going to be in ghc 8.12 from what I've heard
16:10:28 <EvanR> damn that's sexy
16:13:35 <MarcelineVQ> linear types should be pretty useful, they're the perfect way to shift people from complaining about IO being infections to complain about linearity being infectious
16:15:17 <int-e> . o O ( Can we make it so that only one person can complain at a time? )
16:16:25 <MarcelineVQ> :D
16:16:49 * hackage bytestring 0.11.0.0 - Fast, compact, strict and lazy byte strings with a list interface  https://hackage.haskell.org/package/bytestring-0.11.0.0 (Bodigrim)
16:17:16 <MarcelineVQ> If a complain is registered we promise it will be looked at exactly once.
16:28:14 <hpc> in rust, you promise it will be looked at, at most once :D
16:29:11 <MarcelineVQ> the trick is just not to look, or if you look, put it back when you're done
16:32:39 <LestatC95> Chaos theory reigns Supreme....Lysanders in!
16:34:37 * MarcelineVQ drips drinking water on a paleobotanist's hand in a pervy way during a jostling cross-country car trip
16:51:36 <koz_> I'm getting some DerivingStrategies weirdness: https://gist.github.com/kozross/e8dbf3587ec59738e3e3cd06067cdd28
16:51:56 <koz_> I kinda get why this is happening, but I am unsure how to resolve it.
16:52:16 <glguy> koz_: I got to here: https://gist.github.com/kozross/e8dbf3587ec59738e3e3cd06067cdd28#file-ll1-hs-L15-L18 ; the applicative instance doesn't satisfy the laws
16:52:44 <koz_> Yep, that's a good catch.
16:52:56 <koz_> This is what happens when you try and transpose academic papers rofl.
16:54:22 <koz_> glguy: Updated, nice catch.
16:55:47 <koz_> DerivingVia still explodes with the same error.
16:56:07 <koz_> How would I go about remedying this? In theory, (Alt f, Alt g) => Alt (Product f g) holds.
16:57:56 <solonarv> what happens if you replace line 35 with 'deriving newtype (Alt)' ?
16:58:09 <koz_> solonarv: Same error. That was the first thing I tried.
17:05:58 <int-e> koz_: coercing  Applicative (Product (Empty e t) (First e t)) =>  to  Applicative (EmFirst e t) =>  can't really work, can it? The former instance can exist without the latter existing... and even if you add an Applicative instance for EmFirst using newtype deriving, the type checker can't really know how it's derived... so it can't really be expected to reuse the representation.
17:06:23 <koz_> int-e: Yeah, that's a good point.
17:06:32 <int-e> (in light of this, `some` and `many` should really have their own typeclass instead)
17:06:52 <koz_> I believe there's a note about refactoring them out once some unspecified issues with MonadPlus are resolved.
17:07:03 <koz_> It's a bit of a bummer, but I guess it's not that hard to spell by hand.
17:09:26 <int-e> koz_: oh wow, Data.Functor.Alt is littered with unsafeCoerce... for the same reason.
17:09:31 <koz_> int-e: Rofl.
17:09:55 <koz_> TIL how Alt sausage gets made.
17:10:12 <int-e> (well, "littered" may be an exaggeration... but 4 occurrences is 4 more than I expected.)
17:10:30 <koz_> 4 can be a lot.
17:10:43 <koz_> When referring to things ranging from 'wedding cakes at one event' to 'unsafeCoerce uses'.
17:25:22 <z0> > let p = [0,1,2] in (,) <$> p <*> p
17:25:27 <lambdabot>  [(0,0),(0,1),(0,2),(1,0),(1,1),(1,2),(2,0),(2,1),(2,2)]
17:26:36 <z0> how would i go about doing this but avoiding "duplicates" considering that (1,0) and (0,1) are duplicates?
17:27:28 <koz_> z0: Filter it through a HashSet.
17:31:21 <Cale> > [(x,y) | (x:ys) <- tails [0,1,2], y <- ys]
17:31:25 <lambdabot>  [(0,1),(0,2),(1,2)]
17:31:39 <Cale> > [(x,y) | (x:ys) <- tails [0,1,2], y <- (x:ys)]
17:31:41 <lambdabot>  [(0,0),(0,1),(0,2),(1,1),(1,2),(2,2)]
17:32:01 <Cale> z0: ^^
17:32:10 <z0> thats it! thanks
17:43:44 <AWizzArd> Ambiguous occurrence ‘putStrLn’    for this use:    main = putStrLn ("Hallo" :: Text)
17:44:03 <koz_> Is there some non-obvious reason why we have (Functor m, Monad m) => Applicative (StateT s m)?
17:44:10 <koz_> Other than hysterical ones?
17:44:17 <AWizzArd> I wonder why GHC can’t figure out if   String -> IO ()  should be used or better  Text -> IO ()
17:46:43 <Axman6> because the only type based dispatch Haskell has is via type classes
17:47:23 <Axman6> import qualified Data.Text.IO as TIO
18:13:37 <AWizzArd> Axman6: yes, a qualified import works perfectly, I just thought it could infer the function it needs to use via the :: Text sig. But now with what you said I understand it, thx.
19:05:29 <koz_> Is there an already-existing thing which is equivalent to Identity :+: Env e?
19:09:58 <koz_> Well, I guess that's Env (Maybe e)?
19:12:26 <koz_> > Nothing <> Just "a"
19:12:28 <lambdabot>  Just "a"
19:12:42 <koz_> > Just "a" <> Just "b"
19:12:45 <lambdabot>  Just "ab"
19:13:10 <c_wraith> that doesn't look right at all
19:13:20 <Axman6> Jesus, scala's documentations keeps getting better, insisting on using ⇒ instead of => in the docs for functions when they're arguments ot methods
19:16:55 <dolio> Axman6: Have you found the variable captures in the docs yet? :)
19:17:37 <ddellacosta> is Scala any good, for someone who enjoys Haskell?
19:18:06 <Axman6> no, not at all, it's a dumpster fire </personalOpinion>
19:18:08 <dolio> I don't think programming it like it's Haskell is very enjoyable.
19:18:31 <Axman6> I'm shocked by hpw crazy it is every day I try to do anything with it
19:18:37 <ddellacosta> thank you both
19:20:52 <Axman6> I knew before using it there were things that I wouldn't like about it, but it is just _so_ complex, it's the worst of Java's and Haskell's type systems in one, which seem to fight to remove all the niceties of both
19:25:25 <Axman6> dolio: re your question, I don't know, there's so much that makes no sense to me in the docs. even just little things like "where is the string I need to copy to import this module
19:25:44 <dolio> Heh.
19:29:49 <dolio> Well, I don't know if they've fixed it recently, but it used to be that there were e.g. Maps that are a subtype of Collection, and the latter has one parameter `B`. Map has two, though, `K,A`, and `B = (K,A)`. But some methods are parametric over another `B`, for like `A => B` mapping, say. But then it also mentions the B from collection, and it can be difficult to tell which is referring to which.
19:30:24 <dolio> You can tell because it will say something like `Map[B]` in some of those cases instead of `Map[K,A]`.
19:30:33 <dolio> Anyhow, be aware of that.
19:31:09 <dolio> Because it's easy to get confused for a while if you're not.
19:31:10 <Axman6> :'(
19:52:17 <dibblego> scala is pretty broken
19:52:53 <Axman6> Don't oversell it
19:54:10 <dibblego> scala programmers do a great job of that already
19:57:20 <arahael> I tried to learn scala many years ago.  The syntax was...  Insane.  I gave up before I even decided to install the tools, and just learnt haskell instead.
19:57:59 <Axman6> Neo level bullet dodging
20:04:33 <arahael> Yep. My general strategy is to use my overly-inflated sense of personal competence: "If I can't understand it, what chance would most people on the team have?"
20:19:43 <edwardk> arahael: i did it the hard way. actually learned the syntax, tried to use it, then finally stopped apologizing for it and decided 'never again' and moved on.
20:20:25 <arahael> :)
20:59:49 * hackage lens-core 0.2 - A placeholder for a future lens core package.  https://hackage.haskell.org/package/lens-core-0.2 (EdwardKmett)
21:07:37 <edwardk> ^ this is not a real package
21:08:02 <edwardk> it is mostly to avoid the confusion that was being caused by the old package under the name lens-core
21:08:12 <dmwit> Why are there so many versions lmao
21:08:39 <edwardk> because someone else was using the name
21:10:37 <dmwit> Oh, this was a MatthewFarkasDyck package. Okay I completely understand now.
21:10:38 <glguy> Spot the nonexistent package: lens-lite; lens-light; microlens; lens-simple
21:11:43 <glguy> lens-from-scratch; not-another-lens; you-could-have-invented-lens; optics
21:12:39 <Lycurgus> lenscrafters
21:12:45 <davean> glguy: Trick question?
21:12:49 <glguy> I think my next lens package would be: yall (yet another lens library)
21:13:18 <koz_> lens-2-electric-boogaloo
21:13:18 <glguy> but that one is taken; it's also a lens library
21:13:23 <MarcelineVQ> and it's support pakcage  y'all      yet' another lens library
21:13:39 <glguy> davean: One of those first 4 didn't exist (on Hackage) yet
21:14:27 <edwardk> i really want to break lens internally into multiple public sublibraries using cabal 3.4, but i can't yet.
21:14:48 <davean> I can't wait either
21:14:49 <edwardk> but once i can? then you'd be able to depend on smaller pieces of it if you know what you're doing
21:14:57 <davean> I've got a lot of code moving to do once that works well
21:15:08 <edwardk> of course, i think there is still a stack issue on multiple component support
21:15:14 <dmwit> How does back-compat work for that? What does cabal-3.3 do if you ask it to install a 3.4 package?
21:15:19 <davean> Its one of the most exciting features in a while.
21:15:22 <edwardk> it won't
21:15:25 <davean> dmwit: who cares?
21:15:37 <davean> dmwit: theres not any reason to care at all about old cabals.
21:15:39 <dmwit> "It won't" seems like a pretty sane answer.
21:16:03 <davean> No one should be held back on cabal.
21:16:13 <edwardk> in theory i might be able to make the whole shebang work with cabal 3.0 and you only get to access the sub-components with 3.4
21:16:18 <edwardk> but i'm not holding my breath
21:16:23 <edwardk> and that is a LOT of compatibility testing
21:16:44 <glguy> That's good, because most people can't hold their breath quite as long as that is likely to take
21:17:04 <edwardk> i'd code like my life depended on it, for sure
21:17:14 <edwardk> but that might be beyond me
21:17:24 <glguy> Maybe a new Twitch series?
21:17:32 <glguy> How much can edward program on a single breath
21:17:32 <edwardk> i should start twitching again
21:17:59 <dolio> I don't know. That sounds bad.
21:18:02 * dibblego twitches
21:18:02 <glguy> It would be a shorter series than your usual stuff, but possible a good format ;)
21:23:01 <fresheyeball> map :: (forall a. f a -> g a) -> h f b -> h g b
21:23:05 <fresheyeball> what would you call this?
21:23:41 <dolio> Is that what people call 'hoist'?
21:24:32 <fresheyeball> oh nice, yes
21:26:30 <fresheyeball> dolio: do you think it's worth depending on mmorph for it?
21:26:39 <dolio> Not really.
22:23:01 <Axman6> @hoogle hoist
22:23:02 <lambdabot> Pipes hoist :: (MFunctor t, Monad m) => (forall a . () => m a -> n a) -> t m b -> t n b
22:23:02 <lambdabot> Control.Monad.Morph hoist :: (MFunctor t, Monad m) => (forall a . m a -> n a) -> t m b -> t n b
22:23:02 <lambdabot> Streaming hoist :: (MFunctor t, Monad m) => (forall a . () => m a -> n a) -> t m b -> t n b
23:07:25 <newhoggy> Does anyone know if there is any way to get a `ResourceT` to discard all the registered cleanup actions?
23:16:01 <newhoggy> Or even better move all the cleanup actions into an `IO ()` or something like that and then not do any cleanup.
