00:00:52 <MarcelineVQ> While I've forgotten what it's like to be a child I do remember that recursion was tough. In particular cementing the concept that we could refer now to later answers. e.g. the definition of span
00:01:00 <Axman6> > filterM (const [False,True]) "abcde"
00:01:03 <lambdabot>  ["","e","d","de","c","ce","cd","cde","b","be","bd","bde","bc","bce","bcd","b...
00:01:18 <Axman6> > filterM (const [False,True]) "01"
00:01:21 <lambdabot>  ["","1","0","01"]
00:01:22 <kuribas> MarcelineVQ: I learned recursion in scheme, so I already knew it when learning haskell.
00:05:13 <kuribas> MarcelineVQ: it's funny how hard concepts look easy in the beginning, like side effects and loops.
00:05:25 <kuribas> they aren't so easy to do right
00:05:32 <kuribas> I find recursion easier to do right
00:07:53 <kuribas> :t \pred -> catMaybes . traverse (\x -> pred x >>= guard; pure x)
00:07:55 <lambdabot> error: parse error on input ‘;’
00:08:03 <kuribas> :t \pred -> catMaybes . traverse (\x -> do pred x >>= guard; pure x)
00:08:05 <lambdabot> (a -> [Bool]) -> Maybe a -> [a]
00:08:17 <kuribas> hmm...
00:08:32 <kuribas> :t \pred -> fmap catMaybes . traverse (\x -> do pred x >>= guard; pure x)
00:08:34 <lambdabot> (Monad f, Alternative f) => (Maybe a -> f Bool) -> [Maybe a] -> f [a]
00:08:45 <kuribas> I give up...
01:25:17 <kuribas> :t bool
01:25:18 <lambdabot> a -> a -> Bool -> a
01:27:44 <kuribas> :t \pred -> getAp . foldMap (\x -> Ap (bool [] [x] <$> pred x))
01:27:46 <lambdabot> (Foldable t1, Applicative f) => (t2 -> f Bool) -> t1 t2 -> f [t2]
01:28:41 <kuribas> MarcelineVQ: like this?
01:30:42 <kuribas> :t \pred -> getAp . foldMap (Ap . fmap (bool [] [x]) . pred)
01:30:44 <lambdabot> (Foldable t, Applicative f) => (a -> f Bool) -> t a -> f [Expr]
01:34:18 <Cheery> I'd like to know about haskell's module system and things that were already learned, so that they are not repeated.
01:35:05 <Cheery> lol.. that came out well. But you still get the idea.
01:35:29 <[exa]> lol
01:37:48 <Cheery> tried to search out a bit, but I think I'm missing the right search terms.
01:38:57 <Cheery> "haskell module system" https://www.google.com/search?q=haskell+module+system
01:40:03 <Cheery> unless it's the formal spec and wikibook entry that I am looking for, that's a dud.
01:40:47 <kuribas> Cheery: this? http://learnyouahaskell.com/modules
01:41:33 <bob_twinkles> Is there a way to get http-conduit to use Ubuntu's /etc/ca-certificates.conf? I can do it semi-manual by specifying the path to my custom certificate directory, but that's not a super nice solution
01:42:08 <Cheery> kuribas: yup, well.. I guess I'll skim them through and see if there's stuff I'm interested about.
01:43:04 <dminuoso> bob_twinkles: I believe that transitively uses x509-store, so you have to cater to its interface.
01:43:11 <Cheery> I think that I'm not sure about even what kind of a problem the module system is solving, why it's structured the way it is, and so on.
01:50:32 <bob_twinkles> thanks for the pointer dminuoso, it seems like the "right" fix here would be to extend x509-system's  getSystemPaths to parse /etc/ca-certificates.conf if present
01:50:51 <bob_twinkles> that might be a bit out of scope for me tonight though =)
01:51:15 <dminuoso> bob_twinkles: You can use SYSTEM_CERTIFICATE_PATH
01:51:23 <dminuoso> https://github.com/vincenthz/hs-certificate/blob/master/x509-system/System/X509/Unix.hs#L37
01:51:30 <bob_twinkles> right, that's what I'm using now
01:51:54 <dminuoso> Even on ubuntu, the right certificate directory is /etc/ssl/certs/
01:52:21 <dminuoso> bob_twinkles: Did you perhaps forget to run update-ca-certificates?
01:52:55 <bob_twinkles> no, curl can connect without SSL warnings and the certificates are present in /etc/ssl/certs
01:56:04 <bob_twinkles> huh, x509-system should be picking them up them
01:56:32 <dminuoso> Perhaps the permissions are off, or they are invalid
01:56:56 <dminuoso> Ah, you said curl can connect
01:58:32 <bob_twinkles> certs should be readable, but it's possible they're in an obscure-ish format that openssl supports and x509 doesnt?
01:59:17 <dminuoso> Perhaps
01:59:20 * hackage winery 1.3 - A compact, well-typed seralisation format for Haskell values  https://hackage.haskell.org/package/winery-1.3 (FumiakiKinoshita)
02:01:07 <bob_twinkles> hmm, there's actually some stuff in the output of openssl x509  -in cert.cer -text which looks like garbage
02:02:10 <kuribas> Axman6: what do you think is more confusing?
02:05:50 <Cheery> I continued the module system discussion there: https://www.reddit.com/r/ProgrammingLanguages/comments/iqn0xq/module_systems_with_many_usersauthors/
02:05:59 <Cheery> it's not haskell-specific after all.
02:39:39 <merijn> Cheery: The problem it solves is "not having literally everything in a single namespace, because then it becomes increasingly hard to invent good names"
02:39:50 <natpd> how do i create a function that implements this? `f :: M.Map String A -> A`
02:39:58 <kuribas> merijn: so emacs lisp
02:40:07 <merijn> natpd: Do you have a sensible default value?
02:40:34 <natpd> merijn not really
02:40:51 <merijn> natpd: Then what should happen if the key is missing?
02:41:15 <natpd> merijn just an error i guess
02:41:38 <kuribas> natpd: foldr const undefined
02:42:05 <merijn> That's like the worst way to produce an error from that >.>
02:42:21 <merijn> Also that makes a lot of assumptations about what was intended by that type
02:42:45 <natpd> we can just ignore the case that a key is missing for now
02:42:58 <natpd> kuribas whats that?
02:43:10 <merijn> Well, you can't because all the sensible lookup functions for map return "Maybe A"
02:43:19 <kuribas> natpd: a function with that type
02:43:55 <kuribas> also (snd . findMin) and (snd . findMax)
02:43:55 <merijn> I mean, we can skip a bunch of steps and just say "undefined" as a function with that type if we don't have further specification :p
02:44:21 <kuribas> merijn: not a total one
02:44:31 <natpd> cant we lookup the String?
02:44:33 <merijn> kuribas: You literally can't get a total one for that type
02:44:40 <merijn> kuribas: All of yours are partial too
02:44:44 <kuribas> natpd: as merijn says, you don't want this
02:44:50 <kuribas> merijn: indeed they are
02:45:17 <natpd> kuribas how else can i do it? ive stuck on it for some time
02:45:22 <natpd> ive been*
02:45:39 <kuribas> natpd: sounds like an XY problem
02:46:37 <kuribas> natpd: tell us the real problem you have
02:46:41 <merijn> natpd: You have given is a function type whose desirability it questionable without context about what you actually wanna do and people are (fortunately, in the long run) not handing you foot-guns
02:47:49 <natpd> I wanted to get the value of type `A` from `M.Map String A`
02:48:05 <kuribas> natpd: what's "the value"
02:48:15 <merijn> natpd: To do what? What kinda strings are in there? when will they be missing?
02:48:16 <kuribas> natpd: a map has many values, or none
02:48:27 <kuribas> natpd: "the value" is undefined
02:49:11 <kuribas> natpd: I want "the animal" in a zoo
02:49:20 <lortabac> natpd: maybe you are looking for this https://downloads.haskell.org/~ghc/latest/docs/html/libraries/containers-0.6.2.1/Data-Map-Lazy.html#v:-33-
02:49:42 <kuribas> natpd: do you go to a restaurant, and ask for "the meal"? ;-)
02:50:12 <merijn> lortabac: And I just complimented people for not handing out foot-guns...
02:51:33 <lortabac> merijn: they said explicitly that they want an error when the key is missing
02:52:14 <kuribas> lortabac: in that case it's still a mistake
02:52:16 <merijn> lortabac: What people say they want and what they need are not always the same. Not to mention !'s errors being wildly unhelpful
02:52:37 <merijn> lortabac: If that's the case you should still explicitly throw one that tells you what failed, where, and why
02:52:47 <kuribas> lortabac: then you should use fromMaybe (error "custom error") $ lookup key map
02:53:08 <merijn> kuribas: That's just "findWithDefault" with extra steps ;)
02:53:11 <lortabac> kuribas: fair point
02:53:16 <kuribas> merijn: erm, right :)
02:54:19 <natpd> kuribas the value is the key in the map
02:54:37 <natpd> merijn theres 10 letter strings and they wont be missing
02:55:09 <kuribas> natpd: in that case: findWithDefault (error "impossible") key map
02:56:40 <kuribas> natpd: also put in the source function in the error.  If you break your invariant later, you know directly what's wrong.
03:05:50 * hackage rebase 1.7.1 - A more progressive alternative to the "base" package  https://hackage.haskell.org/package/rebase-1.7.1 (NikitaVolkov)
03:11:49 * hackage rebase 1.7.1.1 - A more progressive alternative to the "base" package  https://hackage.haskell.org/package/rebase-1.7.1.1 (NikitaVolkov)
03:15:19 * hackage rerebase 1.7.1.1 - Reexports from "base" with a bunch of other standard libraries  https://hackage.haskell.org/package/rerebase-1.7.1.1 (NikitaVolkov)
04:10:19 * hackage nothunks 0.1.0.0 - Examine values for unexpected thunks  https://hackage.haskell.org/package/nothunks-0.1.0.0 (EdskoDeVries)
04:20:20 * hackage essence-of-live-coding 0.2.4 - General purpose live coding framework  https://hackage.haskell.org/package/essence-of-live-coding-0.2.4 (turion)
04:21:20 * hackage essence-of-live-coding-warp 0.2.4, essence-of-live-coding-quickcheck 0.2.4, essence-of-live-coding-pulse-example 0.2.4, essence-of-live-coding-pulse 0.2.4, essence-of-live-coding-gloss-example 0.2.4, essence-of-live-coding-gloss 0.2.4 (turion)
04:30:16 <cr0ssw1nd> heyo
04:32:36 <cr0ssw1nd> > sum [1..10]
04:32:38 <lambdabot>  55
04:32:57 <cr0ssw1nd> > :t augment
04:33:00 <lambdabot>  <hint>:1:1: error: <hint>:1:1: error: parse error on input ‘:’
04:35:01 <cr0ssw1nd> > augment (\f -> \y -> y) [1,2,3]
04:35:03 <lambdabot>  error:
04:35:03 <lambdabot>      • Variable not in scope: augment :: (p0 -> p1 -> p1) -> [a0] -> t
04:35:04 <lambdabot>      • Perhaps you meant ‘argument’ (imported from Control.Lens)
04:35:20 <cr0ssw1nd> > import GHC.Base
04:35:23 <lambdabot>  <hint>:1:1: error: <hint>:1:1: error: parse error on input ‘import’
04:35:29 <cr0ssw1nd> > GHC.Base.augment (\f -> \y -> y) [1,2,3]
04:35:32 <lambdabot>  error:
04:35:32 <lambdabot>      Not in scope: ‘GHC.Base.augment’
04:35:32 <lambdabot>      No module named ‘GHC.Base’ is imported.
04:35:48 <cr0ssw1nd> anyway
04:35:50 <ski> % :t GHC.Base.augment
04:35:50 <yahb> ski: (forall b. (a -> b -> b) -> b -> b) -> [a] -> [a]
04:36:03 <cr0ssw1nd> ooh
04:36:07 <ski> % GHC.Base.augment (\f y -> y) [0,1,2]
04:36:07 <yahb> ski: [0,1,2]
04:36:11 <cr0ssw1nd> but what is this function for?
04:36:21 <cr0ssw1nd> I don't get how function arg is used
04:36:39 <dminuoso> % :t GHC.Base.augment
04:36:39 <yahb> dminuoso: (forall b. (a -> b -> b) -> b -> b) -> [a] -> [a]
04:37:00 <ski> % GHC.Base.augment (\f y -> f 2 (f 3 y)) [0,1,2]
04:37:00 <yahb> ski: [2,3,0,1,2]
04:37:08 <cr0ssw1nd> hmm
04:37:18 <dminuoso> huh
04:37:21 <dminuoso> is this not build?
04:37:25 <ski> % :t GHC.Base.build
04:37:25 <yahb> ski: (forall b. (a -> b -> b) -> b -> b) -> [a]
04:37:26 <ski> nope
04:37:27 <cr0ssw1nd> so it accumulates arg passed to it
04:38:15 <cr0ssw1nd> but why
04:38:16 <ski> i guess `augment fold xs = fold (:) xs', rather than `build fold = fold (:) []'
04:38:22 <cr0ssw1nd> is it so common operation?
04:38:42 <ski> probably used together with `foldr'-`build' fusion ?
04:39:58 <dminuoso> ski: huh. how does that even type check?
04:40:21 <dminuoso> What is that magic (:) in the middle?
04:40:25 * dminuoso is a bit baffled
04:40:40 <dminuoso> Ohh
04:40:44 <dminuoso> Nevermind, all good.
04:41:10 <ski> it's just rank-2, hiding the type picked for `b'
04:41:59 <ski>   {-# RULES "fold/build"  forall k z (g :: forall b. (a -> b -> b) -> b -> b). foldr k z (build g) = g k z #-}
04:42:31 <ski> is the rewrite rule cited at <https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#rules-pragma>
04:44:29 <ski> cr0ssw1nd : the point of this is that if you can express a function computing a list as a "good producer", using `build', and you then pass the result to a "good consumer", that's using `foldr' on its list input, then this rule may fire, and in that case the intermediate list data structure will get eliminated, fusing the producing `g' directly to the `k' and `z' in the consumer
04:45:55 <ski> and i imagine `augment' is used in similar cases to `build', except that instead of the producer producing the list from scratch, they'll produce some initial prefix of it, then deferring to some other list producer to produce the suffix after that
04:48:52 <ski> (to clarify, this rewrite rule, `foldr k z (build g) = g k z', will attempt to match expressions `foldr (..) (..) (build (..))', at compile-time (possibly after other inlining and "refactoring" steps done by the implementation), and in case of a match, rewrite that site according to the rule .. so that neither `foldr' nor `build' gets called)
04:50:18 <ski>   {-# RULES "fold/augment"  forall k z (g :: forall b. (a -> b -> b) -> b -> b) (xs :: [a]). foldr k z (augment g xs) = g k (foldr k z xs) #-}
04:51:56 <ski> .. i'd guess that's the corresponding rewrite rule for `augment' (and `build'), doing the same sort of fusion as the previous one, except that it keeps a `foldr' call for the suffix list `xs' that we "`augment'ed" onto. in case `xs' is also constructed using a "good producer" (say `build' or `augment'), then a further rule may fire here, &c.
04:54:16 <ski> cr0ssw1nd : long story short, `augment' is (most probably) used for optimization, eliminating intermediate data structures (a kind of deforestation, in this case for lists)
05:29:50 * hackage opaleye 0.7.1.0 - An SQL-generating DSL targeting PostgreSQL  https://hackage.haskell.org/package/opaleye-0.7.1.0 (tomjaguarpaw)
05:37:49 <exarkun> is there some helper/function/pattern that would improve on this code?  https://github.com/PrivateStorageio/PaymentServer/pull/67/files#diff-f7e5f06edce94c721e3922d1bf38870fR344-R355
05:39:29 <tomjaguarpaw> How do I tell cabal "yes I really want to use the .cabal file that's in this directory, even though there's a cabal.project at a higher level"?
05:41:04 <merijn> exarkun: Using where instead of let? ;)
05:42:03 <exarkun> :)
05:42:18 <maerwald> tomjaguarpaw: create a new cabal.project
05:42:19 <exarkun> I was thinking more about the way the exception is handled, sorry I didn't mention that.
05:42:33 <merijn> exarkun: I got that, but it looks mostly fine?
05:43:03 <merijn> exarkun: You might wanna change it into a bracket-like pattern instead, but other than that
05:43:10 <exarkun> okay, great :)  It doesn't seem that bad to me but I thought I might be missing some other function that does the "cleanup and propagate" thing.
05:43:22 <merijn> :t bracket
05:43:23 <lambdabot> IO a -> (a -> IO b) -> (a -> IO c) -> IO c
05:43:59 <merijn> exarkun: first argument is allocation, second is cleanup, third is "what to do in between"
05:44:24 <exarkun> The code that uses this function uses bracket but it's not quite clear to me how I might apply that logic here (because the resource is the return value of the function)
05:44:53 <exarkun> I have a vague idea about a larger restructuring that involves changing the caller too ... but I haven't quite worked out what that looks like in detail yet
05:45:30 <ski> maybe `Managed'. but i dunno if it's worth it ..
05:45:37 <exarkun> The caller is like `bracket sqlite Sqlite.close someFunctionOnConn`
05:46:04 <merijn> exarkun: bracketOnError? :)
05:46:19 <exarkun> merijn: ah haaaaa
05:46:20 <merijn> exarkun: That only runs the cleanup when an exception is thrown, but not otherwise
05:47:22 <exarkun> oh, maybe.  maybe not.  mumble mumble exception propagation.
05:47:27 * exarkun looks at Managed
05:48:10 <merijn> bracket and bracketOnError both propagate the exception
05:49:34 <exarkun> Huh I probably should have known that.
05:50:19 <merijn> they just make sure to run the cleanup before they do :)
05:50:38 <merijn> they're like "try finally" in other languages :p
05:54:17 <exarkun> Okay I guess my `connect` can become `bracketOnError (Sqlite.open (unpack path)) Sqlite.close initialize` (with slight tweak to `initialize`, and `cleanup` goes away) which is indeed nicer
05:58:11 <exarkun> ski, merijn: thanks
06:16:19 * hackage PyF 0.9.0.2 - Quasiquotations for a python like interpolated string formater  https://hackage.haskell.org/package/PyF-0.9.0.2 (guibou)
06:25:25 * ski initially read that as "Quasiquaternions"
06:30:23 <Taneb> The thing with mulitplication of quasiquaternions is that it's not even quasicommutative
06:36:49 <ezzieyguywuf> ski: now I can't read it any other way
06:48:49 * hackage cassava-megaparsec 2.0.2 - Megaparsec parser of CSV files that plays nicely with Cassava  https://hackage.haskell.org/package/cassava-megaparsec-2.0.2 (stackbuilders)
06:49:49 * hackage inflections 0.4.0.6 - Inflections library for Haskell  https://hackage.haskell.org/package/inflections-0.4.0.6 (stackbuilders)
06:51:17 <ski> ezzieyguywuf : you're welcome
07:09:19 * hackage dotenv 0.8.0.7 - Loads environment variables from dotenv files  https://hackage.haskell.org/package/dotenv-0.8.0.7 (stackbuilders)
07:10:31 <mysterybear> (\c -> isPrint c && c /= '"')    -- is there a nicer way to write this just with function composition, without lambda?
07:11:58 <mysterybear> I guess I could fold over [Char -> Bool]
07:15:22 <ski>   liftA2 (&&) isPrint (/= '"')
07:16:02 <merijn> mysterybear: oh, you can do much nicer
07:16:19 <merijn> mysterybear: Step one: The All newtype from Data.Monoid
07:16:29 <merijn> > All True <> All False
07:16:31 <lambdabot>  All {getAll = False}
07:16:35 <merijn> > All True <> All True
07:16:37 <lambdabot>  All {getAll = True}
07:16:50 <merijn> mysterybear: Which is basically a newtype to get a Monoid for Bool with &&
07:17:31 <merijn> mysterybear: Next step, realising that we have "instance Monoid m => Monoid (r -> m)" (i.e. any function that returns a monoid is an instance too!)
07:17:51 <merijn> :t foldMap (All .)
07:17:53 <lambdabot> Foldable t => t (a -> Bool) -> a -> All
07:18:02 <ski> (heh .. i was wondering whether to bother with `All' :)
07:18:15 <merijn> :t foldMap (All .) [isPrint, (/= '"')]
07:18:17 <lambdabot> Char -> All
07:18:31 <merijn> :t getAll $ foldMap (All .) [isPrint, (/= '"')] 'c'
07:18:33 <lambdabot> Bool
07:18:37 <merijn> > getAll $ foldMap (All .) [isPrint, (/= '"')] 'c'
07:18:39 <lambdabot>  True
07:19:05 <merijn> For 2 it's probably not worth it, but if you need more complex/longer predicate lists it's nice
07:20:31 <mysterybear> cheers :D
07:20:53 <merijn> mysterybear: There's actually a ton of useful newtypes in Data.Monoid that can be used like this
07:21:04 <merijn> (and even stacked)
07:50:59 <kuribas> foldMap is like a swiss army knife
07:51:56 <merijn> foldMap is a swiss army chainsaw :p
07:52:27 * [exa] imagines an attached chainsaw bottle opener
08:19:34 <ezzieyguywuf> 😮 just locked in a 2.75% mortgage interest rate
08:19:44 <ezzieyguywuf> much better than the 4.25% I was paying before!
08:19:47 <ezzieyguywuf> lol whoops wrong chan
08:22:22 <merijn> ezzieyguywuf: :p
08:22:30 <merijn> That seems high, though :p
08:23:50 <ezzieyguywuf> merijn: 2.75% seems high?
08:23:56 <ezzieyguywuf> for 30-year fixed-rate?
08:29:07 <tomjaguarpaw> For 30-year seems decent, but also depends on the currency.  In RUB it would be excellent :D
08:34:32 <ezzieyguywuf> lol
08:34:33 <ezzieyguywuf> pesos
08:35:01 <ezzieyguywuf> nah, I'm actually completely flummoxed that these guys can give me 2.75%, when everyone else is offering 2.995%ish
08:35:21 <ezzieyguywuf> I mean, I guess it helps that they're actually a lender, rather than a broker, so I'm saving like $2K in broker fees
08:35:44 <Cheery> this is still the haskell channel, and everybody might not be interested reading about interest rates in here.
08:36:07 <adaj> Cherry +1
08:36:20 <ezzieyguywuf> oh snap
08:36:30 <ezzieyguywuf> I was in #-offtopic but then I accidentally responded in here
08:36:40 <Cheery> np.
08:49:31 <sm[m]> Just give it a haskell angle and you're fine :)
08:49:53 <Cheery> just put some lambdas on it.
08:49:58 <sm[m]> I like to learn things from outside the Haskell bubble
08:50:12 <Cheery> and call it haskell.
08:55:13 <ezzieyguywuf> \apr -> principal * (1 + apr / 12) ^ (30 / 12)
08:55:17 <ezzieyguywuf> *shrug*
08:55:49 <Cheery> :t \principal apr -> principal * (1 + apr / 12) ^ (30 / 12)
08:55:51 <lambdabot> error:
08:55:51 <lambdabot>     • Could not deduce (Integral b0) arising from a use of ‘^’
08:55:51 <lambdabot>       from the context: Fractional a
08:56:24 <Cheery> heh. no need to fix. :) didn't intend to show that.
09:25:10 <boxscape> can `case (a, b) of..` always be replaced with `case (# a, b #) of...` (And corresponding changes in the patterns)? Or are there situations where differing strictness leads to different outcomes
09:27:11 <geekosaur> there's an argument going on currently on ghc-dev over that; the second one desugars to a variant of the first, which changes the strictness
09:27:28 <boxscape> huh, okay
09:27:32 <boxscape> I'll take a look at that mailing list
09:27:47 <geekosaur> (because let is expected to be lazy in its matching)
09:28:59 <dolio> That's about let, not case.
09:29:09 <geekosaur> hm, right
09:29:34 <dolio> However, there's no reason to change `case (a, b) of` to `case (# a, b #) of`.
09:29:57 <boxscape> I thought that maybe it could have minor efficiency benefits but I guess not then?
09:30:03 <dolio> At least, presuming you're doing it to simultaneously match, so your patterns will look like `(p, q) -> ...`.
09:30:03 <geekosaur> I just ran myself off a cliff realizing that. case,, hm. I think it might be worth exploring just because the let version is different; one would expect case to be the same since it's strict by default, but…
09:30:25 <dolio> Because GHC can figure out that optimization.
09:30:28 <boxscape> ah, I see
09:30:53 <geekosaur> that is, I'm not sure from the behavior in the one case that the other necessarily does what one would naïvely expect
09:32:08 <dolio> case isn't necessarily strict. If you did something like `case (# a, b #) of ~(# x, y #) -> ...` you probably have the same problem, but I don't know why you'd do that.
09:33:21 <dolio> Although maybe GHC is smarter about that, because the case version can't be recursive, and I think that might enter into the weird let behavior.
09:34:05 <dolio> Like, recursion is the only excuse I can think of for the let explanation on the ticket you're talking about.
09:34:32 <boxscape> % case 4 of {~6 -> True; 4 -> False} -- speaking of, why does this not fail? It seems like it should try to irrefutably match ~6 and say that the pattern doesn't match, but I assume I'm just misunderstanding what "irrefutable pattern" means
09:34:32 <yahb> boxscape: ; <interactive>:27:24: warning: [-Woverlapping-patterns]; Pattern match is redundant; In a case alternative: 4 -> ...; True
09:34:39 <boxscape> oh wait
09:34:40 <boxscape> I guess it
09:34:48 <dolio> > let 6 = 4 in True
09:34:49 <boxscape> it doesn't bother matching because no variable of the pattern is used
09:34:50 <lambdabot>  True
09:35:03 <boxscape> well my terminology may be imprecise
09:35:14 <boxscape> s/guess/get
09:35:27 <geekosaur> there's also that numbers desugar to applications of (==) which may change how the pattern is interpreted
09:35:32 <boxscape> oh, right
09:35:38 <dolio> ~p always matches, and failures with respect to p show up in variables bound by p, but 6 binds no variables.
09:35:43 <boxscape> ok
09:36:43 <geekosaur> but in this case, there's no variable to be tested later for matching,, it's a straight "constructor" (numbers pretending to be constructors, at least) comparison which fails through to the next alternative
09:38:52 <boxscape> Is there a word for what happens when matching on a pattern of which a variable is used, as opposed to when it's not? "Deconstruction", maybe?
09:39:07 <boxscape> (since "matching" isn't it)
09:41:08 <geekosaur> it's more complicated than that since you can also have things like (Just (Left a)) which combine binding and constructor matches, since patterns can be multi-level
09:42:26 <boxscape> hm, okay
09:43:23 <boxscape> % case (Just (Left 4), Nothing) of ~(Just (Left a), Just (Left b)) -> a
09:43:23 <yahb> boxscape: *** Exception: <interactive>:28:1-69: Non-exhaustive patterns in (Just (Left a), Just (Left b))
09:43:26 <boxscape> kind of interesting that that doesn't work
09:43:39 <boxscape> i.e. all variables need to be bindable even if only some are used
09:44:25 <geekosaur> you didn't provide an alternate case for when that pattern didn't match, hence non-exhaustive patterns message
09:44:38 <boxscape> right, but
09:44:39 <boxscape> % case (Just (Left 4), Nothing) of ~(Just (Left a), Just (Left b)) -> a
09:44:40 <yahb> boxscape: *** Exception: <interactive>:29:1-69: Non-exhaustive patterns in (Just (Left a), Just (Left b))
09:44:41 <boxscape> works
09:44:44 <boxscape> wait
09:44:44 <boxscape> lol
09:45:00 <boxscape> I copy-pasted wrong
09:45:10 <boxscape> % case (Just (Left 4), Nothing) of ~(Just (Left a), Just (Left b)) -> 4
09:45:10 <yahb> boxscape: 4
09:45:12 <boxscape> works
09:45:35 <boxscape> so even though b isn't used on the rhs in both of them, only one of them works
09:46:13 <boxscape> it's not hugely surprising I guess but I could imagine a world in which the pattern needs to only match as far as necessary to bind all the variables that are used
09:47:44 <geekosaur> part of the problem here is type inference, I think; I hit that one thinking about how to fix the "non-exhaustive patterns" message
09:48:00 <boxscape> ah, yeah that sounds reasonable
09:48:35 <geekosaur> that said, ~ only forces one level, which is the tuple itself and not its contents
09:48:44 <boxscape> ah, ok
09:48:59 <geekosaur> similarly ! strictifies only the immediate constructor it's applied to, not its contents
09:49:45 <boxscape> to be honest I can't really think of a situation where it would make a difference how many levels ~ forces
09:50:18 <geekosaur> they exist but then uses where ~ matters at all are somewhat rare
09:50:27 <boxscape> okay
09:50:29 <geekosaur> I think there's only one or two in base?
09:50:36 <geekosaur> or Prelude at least
09:53:52 <dolio> > case (Just 5, Just 6) of ~(Just x, Nothing) -> x
09:53:54 <lambdabot>  *Exception: <interactive>:3:1-48: Non-exhaustive patterns in (Just x, Nothing)
09:56:31 <boxscape> > case (Just 5, Just 6) of ~(Just x, ~Nothing) -> x
09:56:33 <lambdabot>  5
09:56:43 <geekosaur> yeh, that's what I expect
09:58:13 <dolio> That is an example to test if you understand what the patterns mean. :)
09:59:45 <boxscape>  I do think I understand it now
10:03:09 <daself> Hello, can someone tell me if System.Process's callProcess (described as blocking until the process terminates) does block all threads or only the thread it is running on?
10:11:51 <geekosaur> daself, only the running thread. *but* combining threads and processes is begging for odd behavior
10:12:19 * hackage webgear-server 0.2.0 - Composable, type-safe library to build HTTP API servers  https://hackage.haskell.org/package/webgear-server-0.2.0 (rkaippully)
10:13:20 <geekosaur> (true even in C but especially true in Haskell because there's no way to ensure there are no resource leaks or inconsistent data because fork() doesn't copy all running threads)
10:14:59 <daself> geekosaur, my use-case is a worker-thread calling an external program in a forkIO
10:15:09 <dolio> Isn't callProcess just executing another program?
10:15:28 <dolio> Not forking the current program into a process.
10:15:43 <daself> Well the callProcess happens in a forkIO
10:15:54 <daself> I do not want to have my "main" thread blocking though
10:16:12 <geekosaur> it's still doing a fork() and there are odd corner cases (buffer flush at the wrong time, for example) where things can be inconsistent
10:16:19 <dolio> Right. I meant the weird C stuff is when the program itself forks into multiple processes.
10:16:32 <geekosaur> but that happens internally with callProcess
10:16:33 <davean> dolio: how do you impliment that without fork? ;)
10:16:38 <geekosaur> it does a fork+exec
10:16:52 <geekosaur> davean, theoretically spawn()
10:16:55 <daself> @geekosaur, any suggestions how to better handle it?
10:16:56 <lambdabot> Unknown command, try @list
10:16:57 <davean> yah, POSIX's concept of executing another program *is* fork based
10:17:03 <geekosaur> but I think many systems implement that as fork+exec
10:17:31 <geekosaur> that said spawn() exists in part because of this issue, which there is no other fix for
10:18:10 <daself> geekosaur, would it be better to make it non-blocking with spawnProcess instead?
10:18:17 <daself> i.e. prevent possible odd behavior?
10:18:47 <daself> I do not *really* need to have it block, it is just more convenient for implementation
10:19:09 <davean> daself: none of this changes that there is a fork actually happening.
10:19:40 <geekosaur> well, it's not the blocking part that is the problem. it's any code executed between the fork() and exec() in the child process which might access mutable state somewhere (such as the state of a Handle being flushed)
10:19:50 <davean> daself: I mean on a POSIX system. What system are you on? You're partially asking about your OS
10:19:59 <daself> Archlinux
10:20:10 <daself> geekosaur, I see
10:20:53 <davean> geekosaur: this shouldn't be an issue on that OS and that use case though.
10:20:55 <geekosaur> it's a fairly complex issue but I think for callProcess you're probably safe
10:21:38 <daself> At least the files touched by the forkIO worker thread are quite separate from the rest of my application
10:24:20 <geekosaur> depending on what you're up to I can see another possible issue if somehow multiple instances of this external command are running at the same time. might want to fork a worker thread and send it messages via a TChan or whatever to kick off the subprocess
10:24:49 * hackage patat 0.8.6.0 - Terminal-based presentations using Pandoc  https://hackage.haskell.org/package/patat-0.8.6.0 (JasperVanDerJeugt)
10:24:51 <daself> The program im callProcess'ing is in fact zip
10:25:06 <daself> I ran into issues with multiple instances already
10:26:06 <daself> That's why I was looking at the blocking callProcess. I only have a single worker though, so that should not cause problems
10:27:09 <geekosaur> right, but if you forkIO it you could possibly fork a second one while the first is still running,depending on what your trigger condition is
10:28:19 <daself> Application startup creates the worker thread
10:32:34 <daself> geekosaur, thanks for your input
10:36:28 <dolio> davean: Mainly, if the Haskell function is just intended for calling out to a separate program, I would expect that it would be possible for GHC folks to implement something where you don't need to worry about inheriting threads/resources.
10:37:56 <geekosaur> the problem is that the I/O manager may be updating something in a Handle via one of its threads at the time the forkProcess happens, which leaves inconsistent data in the child process that will never be finalized
10:38:30 <davean> dolio: thats not REALLY true given how file descripters work on POSIX.
10:38:50 <geekosaur> there was an actual bug where this happened, and we concluded there was no viable fix
10:39:04 <davean> Yah, its not a theoretically sound part of POSIX 
10:39:28 <dolio> Ah, so it's actually impossible to abstract correctly? Great.
10:39:37 <geekosaur> right
10:40:08 <davean> dolio: you can't even get it QUITE right in C when you write the entire program.
10:40:15 <davean> though you can get it very close.
10:40:16 <geekosaur> if there were critical regions then one could simply wrap such updates in one and then it couldn't be interrupted by e.g. forking and the thread going away
10:40:31 <davean> POSIX is worse-is-better and it has fundimental flaws
10:40:38 <davean> There *was no design*
10:41:21 <geekosaur> well, it inherits this from unix. posix itself has other flaws, mostly from being a marketing standard instead of a technical standard
10:41:35 <davean> mmm
10:41:46 <exarkun> Any Haskell bindings for posix_spawn yet
10:42:18 <davean> Linux is particularly bad in that its extra APIs have even less thought than the origional UNIX ones sometimes and introduce problems that were known and avoided for decades before the Linux API came along (*cough*epoll*cough*)
10:42:35 <geekosaur> not that I'm aware of, but at least on linux it just wraps fork() and execve() and whatever other intermediate functionality is requested via flags (setscheduler, etc.)
10:43:45 <geekosaur> nobody even thought about making it a syscall on linux to avoid this fundamental issue
10:44:26 <geekosaur> and it still leaves the general case unsolved where you use both fork() (without exec()) and pthread_create() in the same process and get the potential for data corruption
10:44:27 <exarkun> presumably at some point in the future someone could correct that oversight and then all of the application that were carefully written using posix_spawn instead of fork+exec would magically become less incorrect!
10:45:04 <geekosaur> …again, even in C although you can with some care minimize the windows
10:46:40 <geekosaur> and if you raise the issue you get told that programs should use one or the other, not both
10:47:19 <davean> The closest to a sane way is you start by forking, and then you use threads, and the forked process sits around to serve your exec and fork requests
10:47:46 <davean> which is about what every program I've ever seen that tried to not break did
10:47:55 <davean> just instantly started up a service process
10:48:02 <davean> and even some of THOSE got broken by library BS
10:50:11 <maralorn> I have a #if MIN_VERSION_Cabal(3,0,0) in a package that I want to compile. I am pretty sure there is no Cabal 2.x around but nevertheless the error message looks like this if is evaluating to false.
10:50:12 <maralorn> Any ideas how that can happen?
10:50:13 <geekosaur> (maybe we should return to our regularly scheduled Haskell discussion now)
10:54:33 <geekosaur> forget -XCPP? it'll compile both in that case, although it probably ought to choke on the #if
10:54:53 <geekosaur> (or {-# LANGUAGE CPP #-} )
10:55:53 <maralorn> Wait, is that supposed to be true for Cabal <= 3.0.0 or Cabal >= 3.0.0?
10:56:18 <geekosaur> "if Cabal is at least version 3.0.0"
10:56:56 <maralorn> hm
10:57:58 <geekosaur> also remember the difference between cabal the command and Cabal the library, which can be confusing
10:58:18 <exarkun> I'm trying to test that a function throws <https://hackage.haskell.org/package/sqlite-simple-0.4.18.0/docs/Database-SQLite-Simple.html#t:Error> with Test.Hspec.Expectations.shouldThrow and (== ErrorBusy) as the selector.  But this is a type error because ... `Error` has no Exception instance?  I'm confused.
10:59:24 <rapskalian> Is there a way to search Hackage for "official" or "base" packages only? I was looking for a Set implementation and failed to realize I was looking for `Data.Set` (which I found via SO). Searching "set" on Hackage doesn't even show `Data.Set` in the first page of results...perhaps there is no distinction between what is considered the standard library, and what is a "package". 
10:59:25 <davean> exarkun: Correct, Error is not a throwable exception it seems.
10:59:40 <exarkun> I wonder how it is being thrown at me :(
11:00:01 <davean> exarkun: llook right above it
11:00:04 <davean> SQLError
11:00:14 <davean> It isn't being thrown at you, something wrapping it is.
11:00:27 <exarkun> huh.
11:00:50 <exarkun> right, ok. thanks.
11:00:56 <geekosaur> rapskalian, there isn't much difference
11:01:07 <davean> rapskalian: there are core libraries
11:01:43 <geekosaur> well, there's boot libraries but that's not quite the same thing
11:01:48 <Cale> https://wiki.haskell.org/Core_Libraries_Committee#Current_Core_Libraries
11:01:59 <davean> No, theres the core library commitee
11:02:17 <geekosaur> although containers should be both
11:02:36 <Cale> Also, doesn't help in this case, because containers isn't listed there...
11:03:04 <davean> Right container's isn't officially core. But it is listed. 
11:03:07 <Cale> text, bytestring, containers, and time probably ought to be
11:03:32 <geekosaur> huuuh. it's listed above that in the bootlibs as shipping with ghc but not considered core
11:03:40 <davean> geekosaur: right
11:03:54 <davean> geekosaur: GHC doesn't make things official.
11:06:27 <rapskalian> "There are libraries that ship with GHC, but are not considered core." k...
11:06:48 <davean> rapskalian: Right? They might not even compile on your Haskell.
11:08:01 <davean> Define core
11:08:18 <rapskalian> "Libraries that ship with the compiler" lol
11:08:32 <davean> rapskalian: At best that would be core to GHC, not Haskell
11:09:50 <geekosaur> but several of them are exposed by various compiler APIs.. granting that some of that is ghc-lib which is not itself widely used, but I think TH leaks some of containers API still?
11:11:06 <davean> http://hackage.haskell.org/package/template-haskell probably not?
11:11:37 <davean> rapskalian: Most compilers ship with at least one self-implimentation library thats not at all intended for anyone to use
11:12:36 <davean> ghc-prim, probably not a core library. Also see GCC and ICC for example - plus most of the things they ship aren't related to the C language at all, but to them
11:12:53 <rapskalian> I think maybe what I'm looking for then is the "standard library of haskell", but I might be bringing other lang baggage
11:13:59 <dolio> The only standard library is part of base, I think.
11:14:07 <geekosaur> the closest thing to a standard library is the Prelude, which is minimal
11:14:13 <Uniaika> rapskalian: you want `base` :))
11:14:15 <davean> dolio: I'd say all the Haskell report ones are "standard"
11:14:25 <davean> They're litterly defined in the report.
11:14:29 <dolio> Right, which is only a subset of base.
11:14:32 <Uniaika> geekosaur: nah, Prelude is just the default imports in the scope. the standard library is base
11:14:40 <davean> dolio: no, base doesn't include them all
11:14:46 <dolio> Oh, it doesn't anymore?
11:14:53 <Uniaika> 1/
11:14:59 <davean> dolio: 'array' for example? Many others?
11:15:18 <Cale> https://downloads.haskell.org/~ghc/latest/docs/html/libraries/index.html -- the stuff that's documented here is a pretty good start
11:15:23 <rapskalian> Gotcha. Is it listed on hackage? Searching "base" and then sorting by downloads doesn't seem to find it...
11:15:28 <dolio> Oh okay.
11:15:49 <Cale> If you want a practical bunch of libraries which are reasonably blessed
11:15:51 <davean> dolio: it fluxuates
11:15:54 <geekosaur> sort by downloads won't work because it's wired into ghc
11:16:16 <geekosaur> you can't really install it separately, it's only on hackage for its documentation
11:16:54 <davean> This is less obvious than it could be rapskalian 
11:16:54 <dolio> I'm not seeing a lot else besides array. Unless the foreign stuff isn't in there.
11:17:06 <rapskalian> I'm getting the sense that I should be searching through google...the hackage search doesn't seem to work too well
11:17:15 <rapskalian> Ah found it: https://hackage.haskell.org/package/base
11:17:58 <davean> rapskalian: That is litterly the base package, but while its what you want, its not what you want for Set - it doesn't concern its self with things like Set, it concerns its self with shared language mostly.
11:18:11 <davean> rapskalian: You SHOULD know that package well mind you
11:18:24 <davean> its is litterly the core package everything gets its language from
11:18:53 <davean> Its *mostly* about defining concepts though.
11:19:18 <davean> long story short, for set you want containers or unordered-containers.
11:19:42 <rapskalian> Yea makes sense. And so the modules nested under GHC are the ones you were talking about being specific to the compiler? 
11:20:05 <geekosaur> specific to the implementation, at least
11:20:08 <davean> rapskalian: anything with "ghc-" as a prefix is VERY compiler specific, not even really shared between compiler versions
11:20:21 <davean> ignore it if you aren't SPECIFICLY buidling something new and low level.
11:20:29 <rapskalian> I also see a lot of "Data.*" modules in here. Is that a reserved namespace at all? I suppose not since `Data.Set` was able to use that name. 
11:20:37 <rapskalian> Okay makes sense about ghc
11:20:39 <geekosaur> but there are packages like process, time, containers that are used widely by other things
11:20:43 <davean> rapskalian: no namespaces are reserved.
11:21:02 <rapskalian> I see, so it's more a convention
11:21:04 <davean> rapskalian: you can write your own "Prelude" module if you want.
11:21:05 <dolio> There's a lot of stuff that used to be in base that has been split out, too.
11:21:16 <davean> rapskalian: there is a recomended naming convention, its a little fuzzy though
11:21:22 <dolio> But that was a long time ago.
11:21:26 <Cale> Data.* and Control.* are two completely meaningless prefixes that got added to a bunch of modules in a period of overexcitement following hierarchical modules becoming possible :P
11:21:48 <davean> https://wiki.haskell.org/Hierarchical_module_names
11:22:25 <davean> Control vs. Data are the most egregious "what were we thinking?"
11:23:12 <rapskalian> Ah okay. "If you upload a package to Hackage it will check whether your modules at least use common names for module directories at the top level." and then do what? 
11:23:15 <Cale> (but the idea is that Data.* is for data structures, and Control.* is for control-structure-like stuff... it's just that the lines are quite blurry, and a lot of libraries in one could just as well be in the other)
11:23:23 <davean> rapskalian: warn you.
11:23:42 <rapskalian> ahh okay, so there is a little bit of standardization there, albeit gentle
11:23:53 <geekosaur> this being a functional language, the lines are very blury
11:23:54 <davean> rapskalian: Yes, and I've not seen anyone really fight it.
11:24:03 <davean> I know of no egrgious violations of decency
11:24:11 <davean> and even if there WERE you could avoid the problem with a package import
11:24:25 <davean> you CAN say what exact package you're importing a module from
11:24:28 <monochrom> Control.Lens and Data.Machine are the most striking examples of irony-in-hindsight classifications, and from the same author too.
11:24:34 <davean> and a particular package can only ever have one of sometyhing
11:24:37 <monochrom> err Data.Machines
11:24:42 <davean> so in practie if someone WAS a problem you could always fix it.
11:24:57 <monochrom> You would think that they should be Data.Lens and Control.Machines, no?
11:25:04 <rapskalian> Yea makes sense. I'm less worried about bad actors and more just orienting myself :)
11:25:52 <davean> rapskalian: pay more attention to packages than modules.
11:26:14 <davean> modules are just a book keeping messure.
11:26:17 <davean> packages are distribution units.
11:27:30 <Cale> monochrom: I believe Control.Lens is where it is because Data.Lens was already occupied... but in hindsight that probably shouldn't have mattered
11:27:56 <davean> monochrom: its a machine for processing data :)
11:28:00 <rapskalian> ok cool. So then backing up to my Set search, do most haskellers just use google to find things of interest? Something so primitive I think next time I would look directly on that core wiki page that Cale shared. 
11:28:14 <Cale> rapskalian: Did you see my other link?
11:28:22 <Cale> https://downloads.haskell.org/~ghc/latest/docs/html/libraries/index.html
11:28:25 <davean> rapskalian: Uh ... I just look at http://hackage.haskell.org/packages/
11:29:00 <Cale> The set of libraries documented at there are reasonably basic and you should probably know about them.
11:29:08 <rapskalian> Ah that link is excellent
11:29:12 <rapskalian> Exactly what I was after
11:29:19 <davean> YEs, I concure that you should know everything in Cale's link that isn't "ghc-" prefixed
11:29:26 <davean> But it only covers the basics.
11:30:07 <rapskalian> What exactly is this tho? The subdomain seems odd. Put another way, how did you find this? 
11:30:18 <davean> rapskalian: Thats the GHC manual
11:30:39 <davean> rapskalian: you'd find it from https://www.haskell.org/ghc/
11:30:54 <davean> The "Documentation" link on the left
11:31:17 <davean> downloads.haskell.org is where artifacts are permenently entombed
11:31:46 <Cale> Or rather the "libraries" link toward the end of the "What is GHC" section
11:32:05 <davean> That is one less click
11:32:21 <rapskalian> Oh there it is, thank you
11:32:43 <rapskalian> The "what is GHC" section has some great links
11:32:43 <davean> GHC is the primary Haskell compiler and definately the one you're using. Thus a good place to look.
11:32:45 <rapskalian> That's a good source
11:32:59 <Cale> I think it's at least two less clicks, but I'm not sure how to get there from the top of the User's Guide page
11:32:59 * ski 's got <https://www.haskell.org/ghc/docs/latest/html/libraries/index.html> (and <https://www.haskell.org/ghc/docs/latest/html/users_guide/index.html>) memorized ..
11:33:17 <rapskalian> *bookmarks all the links*
11:33:45 <Cale> If you went to the documentation link for a particular version of GHC though, you'd get a page with three links, one of which would be to the User's Guide and another to the Libraries documentation.
11:33:58 <davean> Haha I forgot about libiserv
11:34:14 <Cale> e.g. starting from here, and going to "Documentation" in the Contents section: https://www.haskell.org/ghc/download_ghc_8_10_2.html
11:34:21 <davean> Ok, ghc-prim SOMEONE has a reason to depend on, I'm pretty sure no user code should though libiserv
11:36:50 <rapskalian> As someone completely ignorant of compiler inner workings, what exactly is the "GHC API", or a compiler API in general? 
11:37:14 <rapskalian> Is that something I'd use if I wanted to build a profiler or other dev-like tools? 
11:37:40 <Cale> It's the internals of GHC, exposed as a library
11:37:50 <Cale> Yeah, you could do stuff like that with it
11:37:53 <boxscape> I think the paragraph on top of https://hackage.haskell.org/package/ghc is a pretty good explanation
11:37:58 <Cale> (though GHC does include a profiler)
11:43:41 <rapskalian> Ahh okay makes perfect sense. You could build an analyzer with it, or some kind of interpreter. That's really cool. 
11:44:10 <omg_3> Could some explain why `foldl (flip const) 'z' [1..5]` fails to evaluate if `(flip const) 'z' 1` evaluates to 1 as expected
11:45:34 <Cale> What would foldl (flip const) 'z' [] evaluate to?
11:49:08 <omg_3> Hmm
11:49:10 <omg_3> Just 'z'
11:49:42 <Cale> So what's the type of  foldl (flip const) 'z' xs  if xs is a list of Integers?
11:49:58 <Cale> (which may or may not be empty)
11:50:40 <omg_3> I think I'm a little hung up on the fold
11:51:07 <omg_3> doesn't that expression evaluate the 2nd argument of 'z' and []
11:51:14 <omg_3> How come it's spitting out 'z'?
11:51:20 <Cale> @src foldl
11:51:20 <lambdabot> foldl f z []     = z
11:51:20 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
11:51:31 <Cale> foldl f z [] = z
11:51:47 <monochrom> omg_3, Cale is bring your attention to an inconsistency in types.
11:52:59 <Cale> Yeah, the problem here is that if we were to ignore the type system altogether and just evaluate the foldl according to its definition, in one case, it would have to produce 'z' and in another, it would have to produce 1
11:53:37 <omg_3> But doesn't  flipped const disregard the first argument passed to it, and only return the second
11:53:42 <Cale> This can only make sense if there's some way to intepret 1 as a Char value (since 'z' is definitely a Char), but there's no instance of Num Char, usually.
11:53:59 <Cale> yes
11:54:26 <omg_3> So where exactly is Num Char being called
11:54:47 <monochrom> You are running into a basic tenet of static typing.
11:55:09 <monochrom> That your code is gibberish, no meaning, if it doesn't pass type-checking.
11:55:23 <omg_3> Right
11:55:31 <omg_3> :t (flip const)
11:55:33 <lambdabot> b -> c -> c
11:55:33 <monochrom> You don't get to discuss what flip const do if there is a type error.
11:55:52 <Cale> :t foldl
11:55:54 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
11:55:54 <omg_3> Wait, I'm not sure I understand where the type checking is failing
11:56:10 <Cale> So look at the type of foldl and the type of flip const
11:56:36 <omg_3> b -> a -> a vs b -> a -> b?
11:56:38 <Cale> the 'b' in the type of flip const has to match the 'b' in the type of foldl given there
11:56:48 <omg_3> And since that's not checking out, we don't proceed?
11:56:54 <Cale> and the 'c' in the type of flip const has to match the 'a' in the type of foldl
11:57:12 <Cale> but then also the 'c' in the type of flip const has to match the 'b' in the type of foldl
11:57:24 <Cale> So a and b have to be the same type
11:57:37 <Cale> The rest is okay, so long as they are
11:57:50 <Cale> > foldl (flip const) 'z' "hello"
11:57:52 <lambdabot>  'o'
11:58:04 <omg_3> Right I see
11:58:10 <omg_3> so "c" and "a" have to match
11:58:14 <omg_3> same as "c" and "b"
11:58:30 <omg_3> so with some arguments, this would actually go over smoothly
11:58:34 <omg_3> because the types check out
11:58:42 <omg_3> But in our case, they didn't
11:58:55 <Cale> Yeah, they didn't just because of the type of the list
11:59:07 <Cale> The "t a" in that type signature for foldl
11:59:25 <omg_3> And because there's no Num Char conversion* (is that the right word? maybe set of behaviour is more correct)
11:59:35 <omg_3> That's the error being spit out by GHC
11:59:43 <Cale> Yeah, we discovered that the list has to be a list of Char values
11:59:57 <omg_3> I see
12:00:15 <Cale> and we provided something like [1,2,3,4] which since numeric literals are polymorphic, *could* in some cases be interpreted as a list of Char values, but only if there's an instance of the type class Num for Char
12:00:25 <Cale> but then there wasn't one
12:01:09 <omg_3> Does reasoning in types come intuitively over time? I have no issue with reading through smaller typesigs, but in this case, the immediate connection between the function component of fold's typesig and (flip const)'s typesig was not immediately clear to me
12:01:16 <Cale> I think so
12:01:35 <omg_3> Sort of how working with arithmetic is essentially automatic for (what I would assume are) most of us
12:02:00 <omg_3> I'm frankly not sure if I'm not groking haskell or if this is just part of the process
12:02:01 <Cale> There will always be cases that require thought, but it basically just amounts to setting the things side by side and saying "this part has to match this part" over and over, discovering which types have to be equal to which other types
12:02:19 <omg_3> Right
12:02:34 <omg_3> Visualizing them has proven to be a little difficult
12:02:48 <Cale> It gets faster, and you could also spot the type error here by thinking about what the code would compute if the compiler let the type error go
12:03:25 <Cale> foldl (flip const) 'z' (xs :: [Integer]) will sometimes be a Char and sometimes be an Integer depending on the contents of xs
12:03:41 <Cale> (which obviously isn't good)
12:04:23 <exodrifter> I don't really explicitly think of the types all that much *most* of the time. Like, I have a general idea of what foldl does and what the parameters mean --  from that I can say "well, this part of the function doesn't make any sense"
12:04:47 <exodrifter> but I would agree in the general sense that just knowing how to "math" the types out, that gets easier over time
12:04:53 <Cale> But sometimes you can't think that way, and have to actually know the type of something in order to know what the program *is* in the first place -- that's what type classes let you do.
12:05:13 <Cale> (decide which program to use based on the type of something)
12:05:59 <merijn> omg_3: It comes with practice
12:06:13 <merijn> omg_3: Practicing with pen and paper and doing substitutions manually can help a lot
12:07:10 <merijn> In fact, my number one recommendations for learning haskell (both the type and the value parts) would be "work it out on paper more often than you do now" :p
12:07:20 <omg_3> merijn: that's what I was thinking. I've started doing it like that to reaosn through the steps taken
12:07:31 <omg_3> Back to grade school methods :)
12:07:44 <merijn> 90% of Haskell's semantics can be captured by just substitution and rewriting. That's not what actually happens, but it accurately mimics the results
12:08:11 <monochrom> It's what actually happens.
12:08:24 <merijn> omg_3: It's like basic arithmetic, at first you count on your fingers, with paper, etc. eventually you get the simple arithmetic memorised and casually sum things that that grade schoolers can't imagine
12:08:38 <merijn> monochrom: For some value of "it", "what", "actually" and "happens" :)
12:08:41 <monochrom> Err, no, you're right, the substitution part doesn't quite happen.
12:09:08 <merijn> omg_3: At first it took a fair bit of concentration to do stuff like unification, but now it's second nature
12:09:21 <omg_3> good to hear
12:09:42 <omg_3> I heard that Haskell was difficult to learn
12:09:50 <omg_3> It's living up to the reputation
12:10:15 <merijn> omg_3: I agree and disagree simultaneously ;)
12:10:52 <geekosaur> it's different. it's not harder, it's just not what you're used to or expect
12:10:59 <merijn> I mean, it's difficult for most people sure. Just not because Haskell itself is that difficult. You are forced to confront lots of gaps and assumptions many people manage to get away with glossing over when learning other languages
12:11:08 <exodrifter> personally, I did not have much trouble learning Haskell even though it was my first functional language. I would say that some things are harder in haskell but other things are easier too.
12:11:19 <monochrom> It is harder to learn.
12:11:19 * hackage read-bounded 0.1.1.3 - Class for reading bounded values  https://hackage.haskell.org/package/read-bounded-0.1.1.3 (ThomasEding)
12:11:31 <davean> I mean you'd have had to confront the above issue in any language.
12:11:49 <davean> Haskell just told you about it before you tried to run it the first time instead of stumbling on it later and having to figure it out.
12:11:59 <omg_3> That's true
12:12:12 <omg_3> And it's much better than unexpected snags in something like Python
12:12:13 <omg_3> imo
12:12:21 <davean> So it was more up front, was it actually *harder* thought? You were more aware of the process.
12:12:31 <monochrom> Comparing an untyped language and a typed language, the typed language is harder to learn, simply because there is one more thing to learn (types).
12:12:49 <monochrom> But this is not a statement about which one I prefer to use.
12:12:58 <davean> Certainly being aware of the process is more intimidating.
12:13:01 <exodrifter> but on the other hand, you get to trade away an entire class of potential runtime exceptions that you no longer have to worry about, among other benefits.
12:13:41 <monochrom> Comparing a language without our IO type and a language with our IO type, the latter is harder to learn, simply because there is one more thing to learn (the IO type).
12:13:44 <merijn> @quote everything.is.difficult
12:13:44 <lambdabot> No quotes match. Listen, broccoli brains, I don't have time to listen to this trash.
12:13:44 <monochrom> But this is not a statement about which one I prefer to use.
12:13:46 <merijn> aww
12:14:14 <merijn> @quote everything.is.hard.in.haskell
12:14:14 <lambdabot> #haskell says: Writing good code is hard in any language. Writing bad code is hard in Haskell, therefore, everything is hard in Haskell
12:14:24 <monochrom> In both cases the latter are easier to use, simply because they are easier to use correctly.
12:14:45 <merijn> I've always liked that quote
12:15:00 <exodrifter> it's pretty funny
12:16:16 <monochrom> Or perhaps my rhetoric is better re-cast as harder? to learn but for how long? term.
12:16:54 <monochrom> For short term gains, to get your hello world to run, untyped without IO languages are easier to learn.
12:16:55 <merijn> There's also the FreeBSD motto for why some things are harder to learn
12:17:16 <monochrom> For long term learn-until-you-write-correct-code, typed with IO languages are easier to learn.
12:17:23 <merijn> Which is "you'll be a beginner for a while, but an expert forever, therefore it's more to accommodate convenience of experts than ease for beginners"
12:17:56 <davean> Haha I like the idea of being an expert forever
12:18:00 <davean> thats hilarious
12:18:09 <monochrom> That one doesn't work out.
12:18:18 <monochrom> Most people aren't experts, ever.
12:18:18 <davean> Not even a little
12:18:27 <davean> and experts stop being experts quickly.
12:19:00 <geekosaur> especially when the language moves as fast as ghc does
12:19:11 <merijn> Not for Haskell specifically
12:19:19 <davean> I still prefer to optimize for experts
12:19:27 <monochrom> It worked in the good old days when people (that I ran into) were all interested in learning, figuring out, understanding; and all capable of.
12:19:29 <davean> but that statement is hillariously false. Even outside of Haskell
12:19:30 <merijn> But the untyped stuff optimises for the first few weeks of programming
12:19:34 <exodrifter> the idea of "being an expert forever" is funny to me, as I don't think even the people at the top of their craft ever think they have nothing left to learn
12:19:41 <monochrom> As opposed to today "just Google for answers"
12:19:50 * hackage funspection 1.0.0.1 - Type-level function utilities  https://hackage.haskell.org/package/funspection-1.0.0.1 (ThomasEding)
12:19:52 <merijn> exodrifter: Mind you, this is in the context of system administration
12:20:01 <davean> exodrifter: Its not even that, an expert rots quickly when they move to focusing on something else.
12:20:06 <merijn> exodrifter: Figuring out how to first something up is a tiny part compared to "keeping it running"
12:20:50 <merijn> "expert" is maybe overstated. But "long term use" and "short term convenience" are different goals with differing results
12:20:57 <davean> The real experts i know explicitely repeat the areas they've been experts in to keep it active because they're well aware of their weaknesses
12:21:08 <exodrifter> merjin: if it's about maintainability, it seems a little strange to phrase that concern in the context of beginners and experts
12:21:54 <merijn> Ok, so clearly the lesson here is don't paraphrase aphorisms from a decade ago late on friday evenings
12:22:21 <davean> merijn: no, no, please do. I haven't had a lauph that good in days.
12:23:05 <exodrifter> yeah I thought it was funny too
12:23:22 <merijn> If you want schadenfreude I can just as easily tell you about spending my entire day on figuring out how to do trivial things in Fortran because all the documentation is shite >.>
12:23:52 <exodrifter> I would probably enjoy being regaled with such a tale
12:24:09 <monochrom> Now you're an expert in Fortran.
12:24:20 <exodrifter> PFFT
12:24:53 <davean> merijn: Not as funny, but schadenfreude is good entertainment
12:25:19 * hackage lambda-options 1.1.0.1 - Declarative command-line parser with type-driven pattern matching.  https://hackage.haskell.org/package/lambda-options-1.1.0.1 (ThomasEding)
12:26:55 <merijn> exodrifter: It mostly consists of lots of google and finding out there's two options: 1) the spec, which is about as readable as the C spec, or 2) 20 different slide decks "teaching" Fortran to scientists, all of them wildly out of date, skipping the most important details and saying nothing useful >.>
12:27:37 <ski> @quote hard.things.are.possible
12:27:37 <lambdabot> autrijus says: Perl: "Easy things are easy, hard things are possible" <autrijus> Haskell: "Hard things are easy, the impossible just happened"
12:27:47 <monochrom> Yeah I think eventually it's more worthwhile to decipher the spec.
12:28:33 <exodrifter> merjin: hahaha, that's really great. I'm not familiar with the C spec, but I'll take your word for it.
12:29:19 <merijn> exodrifter: You should try and read it once if only to realise that C is a clusterfuck of a language and literally no one on this planet actually knows what C programs are "supposed to do"
12:29:36 <davean> exodrifter: One of 3 main definitions should work, but not sure which one, everything else is undefined.
12:30:02 <monochrom> haha
12:30:26 <exodrifter> merjin: I mean, where do I even go for "the C spec"? like the first result for "C API" for me is the Python/C API reference manual
12:30:39 <davean> Also, pointers *might* be LISP machine closures with a specific one allocated as NULL
12:31:02 <davean> exodrifter: C API and spec are entirely different
12:31:04 <merijn> exodrifter: You buy it from the ISO standard body (or, more likely, like me you download a copy of the last public draft before finalisation for free)
12:31:29 <exarkun> Has anyone experienced https://hackage.haskell.org/package/wai-cors-0.2.7/docs/Network-Wai-Middleware-Cors.html failing to return CORS headers for error responses (with Servant in particular, maybe)?
12:32:00 <exodrifter> well then, where do I find the "C Spec"? because that brings up a welding company for me
12:32:11 <davean> "The C Language Standard" should get it
12:32:14 <merijn> exodrifter: http://files.inconsistent.nl/isoc11.pdf
12:32:17 <davean> or C99
12:32:19 <davean> or ...
12:32:34 <merijn> davean: :p
12:32:49 * hackage uniqueness-periods-vector-general 0.3.0.0 - Generalization of the functionality of the dobutokO-poetry-general-languages package  https://hackage.haskell.org/package/uniqueness-periods-vector-general-0.3.0.0 (OleksandrZhabenko)
12:32:51 <merijn> I mostly keep it around so I can cite chapter and verse when telling people they're wrong about C
12:32:56 <davean> I once had C99 memorized. All that did was make me sure my programs would never work.
12:33:05 <merijn> Which is fairly frequently, because boy do people not know C
12:33:17 <merijn> davean: That's fine, no one ever implemented C99 correctly!
12:33:20 <davean> merijn: the details around pointer arithmetic are amazing!
12:33:25 <davean> merijn: I know :(
12:33:32 <davean> and then they removed features for the next standard
12:33:35 <merijn> davean: I would've liked dependently typed arrays
12:33:37 <davean> because no one actually ever implimented them
12:33:50 * hackage up 1.0.0.6 - Command-line tool to generate paths for moving upward in a file system  https://hackage.haskell.org/package/up-1.0.0.6 (ThomasEding)
12:34:00 <merijn> To be fair, dependently typed arrays were just made optional, not removed!
12:34:05 <exodrifter> i mean -- yeah, i was gonna say, this is just the spec, it's not like people necessarily implement it the same way everywhere
12:34:19 <davean> exodrifter: Oh but the spec covers that!
12:34:23 <merijn> exodrifter: Well, that's the point of having a spec, though!
12:34:26 <davean> exodrifter: See, they forsaw that
12:34:37 <exodrifter> oh, so they fixed the web browser problem?
12:34:38 <merijn> davean: oh, lemme show you my favourite popquiz to show people who claim to know C
12:34:53 <merijn> davean: https://gist.github.com/merijn/0392ae239b9a091986ae
12:35:04 <davean> ugh
12:35:14 <davean> Oh shit
12:35:23 <merijn> davean: The question is simple: Is this standard defined, implementation defined, or undefined behaviour? And what does it do?
12:35:38 <[exa]> merijn: that's lame :]
12:35:49 <[exa]> merijn: I expected at least UB
12:35:57 <monochrom> tee hee hee
12:35:59 <merijn> exodrifter: Well, if it doesn't follow the spec it's by definition not C ;)
12:36:16 <merijn> At best it's "C-like" :p
12:36:17 <maerwald> merijn: standard defined
12:36:26 <merijn> maerwald: sssh, no spoilers!
12:36:30 <maerwald> oops
12:36:38 <monochrom> Yeah, watch out how to parse this. I got tripped too.
12:36:46 <monochrom> Sorry!
12:36:54 <merijn> monochrom: Well, that's kinda the point I try to make with it ;)
12:37:03 <merijn> People don't even know how to read/parse C :p
12:37:06 <davean> msgctl: merijn Thats a tricky trick there :)
12:37:09 <monochrom> No but last time merijn also gave me the hint "standard defined" pretty soon.
12:37:36 <monochrom> Fortunately I know how to parse, I just forgot to actually use my knowledge.
12:38:00 <msgctl> o/ :)))
12:39:03 <exodrifter> merijn: oh god, I haven't heard the phrase "c-like" in forever and i haaaaaaaate it
12:39:24 <monochrom> I prefer "algol-like"
12:39:31 <monochrom> C is algol-like. There!
12:39:37 <merijn> monochrom: Hardly
12:39:41 <davean> Well I use Haskell-like languages
12:39:45 <merijn> Algol was good :p
12:39:56 <merijn> Or, at least, had defensible suckiness :p
12:42:49 * hackage uniqueness-periods-vector-examples 0.1.2.0 - Examples of usage for the uniqueness-periods-vector series of packages  https://hackage.haskell.org/package/uniqueness-periods-vector-examples-0.1.2.0 (OleksandrZhabenko)
12:46:23 <exodrifter> what is the ***hackage thing that keeps popping up in the chat? Is it triggered by something? I can't tell.
12:46:46 <[exa]> exodrifter: a notification bot about new packages
12:46:56 <davean> exodrifter: Its a feed of package uploads.
12:46:58 <sm[m]> hackagebot, operated by mniip
12:47:02 <exodrifter> ohhhh, _new_ packages
12:47:25 <exodrifter> thanks everyone <3
12:47:29 <geekosaur> or new versions of packages
12:47:29 <davean> people write code, they share it with the community, we get spammed about it :)
12:47:32 <[exa]> exodrifter: and the ***hackage effect is /me command, as in `/me does it too`
12:48:50 <koz_> Yeah, C is brain-melting and nobody understands it.
12:49:09 <koz_> _Teaching_ first-year programmers C was one of the most painful experiences of my life.
12:49:40 <koz_> Because everyone (rightly) asks something equivalent to 'Why the hell would anyone design [insert language feature X] this way?'.
12:50:00 <koz_> And the only answer you can give amounts to 'it was before I was born, things were different then'.
12:50:26 <davean> koz_: no, no, at least one of them is "the language designers were idiots"
12:50:36 <koz_> (it wasn't helped by also being on Windows, and led by a long-time gamedev, which basically meant that he didn't know 'C', he knew 'C as understood by a Windows monoculture game programmer')
12:50:42 <koz_> davean: Lol.
12:50:44 <[exa]> koz_: I taught them assembly with call conventions and they kinda figured out that there are many choices
12:51:03 <koz_> [exa]: One thing I am glad never having needed to teach was assembly.
12:51:15 <geekosaur> design, what is this "design" I keep hearing about? :)
12:51:20 <exodrifter> [exa]: Yes! thank you
12:52:27 <[exa]> koz_: I found it fun tbh, also kinda helpful because it explained the students like 50% of the intuition they needed for systems engineering state exams :D
12:52:45 <koz_> [exa]: We clearly have _very_ different ideas of what 'fun' means.
12:52:47 <Cheery> goddamn.. I'm getting too difficult challenges. How do I point out to somebody that just allowing package to co-exist in same program doesn't solve the dll-hell problem?
12:52:51 <koz_> (and likely very different students)
12:53:05 <Cheery> without being an ass about it.
12:53:14 <koz_> Cheery: Isn't DLL hell more about finding things at runtime?
12:53:40 <koz_> Allowing packages to co-exist in the same program makes absolutely zero difference to 'does your user have wtf.dll in the expected place(s)'.
12:53:49 <geekosaur> is this multiple versions of the same package?
12:54:03 <Cheery> yes, I guess haskell ppl have had that problem.
12:54:42 <monochrom> It has a problem and it doesn't have to have that problem.
12:55:10 <[exa]> koz_: it needed some moderation (and example code to copypaste from) :]
12:55:34 <koz_> monochrom: In the 'it puts the lotion on its skin or it gets the hose again' sense?
12:55:39 <[exa]> but nothing weird, certainly less scary than teaching lenses
12:55:55 <monochrom> I have a function f, it uses package p version 1. p version 1 defines "data T = T Int".
12:56:12 <monochrom> I have a function g, it uses package p version 2. p version 2 defines "data T = MkT Word".
12:56:27 <Cheery> monochrom: can you explain? This could be valuable for me, even if I'm not sure I can figure a nice way to explain that nope, RequireJS might not have that right even if it seems to work so fine.
12:57:08 <monochrom> If f and g do not have to exchange values of type T, they can co-exists. In other words "uses" is "uses internally as implementation detail that no one can observe and tell the difference from the outside"
12:57:12 <davean> koz_: I really like assembly ...
12:57:25 <koz_> davean: I _like_ many things. It doesn't mean I enjoy teaching them.
12:57:26 <monochrom> If f and g exchange T values, now you have an inconsistency problem.
12:57:36 <geekosaur> do I want to know what JS has to do with DLLs?
12:57:41 <monochrom> cabal plays safe and simply disallows it in build plans.
12:57:53 <davean> koz_: I just don't enjoy the students that make it hard. ;)
12:58:02 <geekosaur> aside from "$user doesn't understand the difference there"
12:58:38 <monochrom> GHC allows co-existence and avoids inconsistency by tagging T as "T of p-1" vs "T of p-2".
12:58:42 <koz_> Yeah, I too am curious how we ended up with 'DLL hell' and 'JS' in the same question.
12:59:09 <[exa]> npm isn't hell?
12:59:41 <koz_> [exa]: It _is_, but not specifically DLL hell as I understand it.
13:00:17 <monochrom> Anyway, as usual, the answer contains "it's complicated" and "it depends".
13:00:30 <davean> koz_: well with npm you defiantely can get two versions of one package, that don't work with each other in your app.
13:00:48 <exodrifter> what is DLL Hell?
13:01:02 <davean> exodrifter: a feeling really.
13:01:05 <monochrom> You cannot hope to explain this to someone impatient, someone who insists "this is a simple [sic] question, therefore there must be a simple [sic] answer" (where they mean s/simple/short/)
13:01:15 <koz_> davean: I guess I misunderstand what people mean by DLL hell then, because I always thought it meant 'there's no good way to guarantee that your program's users have wtf.dll in a findable place'.
13:01:24 <Cheery> https://www.reddit.com/r/ProgrammingLanguages/comments/iqn0xq/module_systems_with_many_usersauthors/g4u73uj?utm_source=share&utm_medium=web2x&context=3
13:01:25 <monochrom> My recommendation is walk away.
13:01:39 <geekosaur> what you get with windows when you need two differnt versions of foo.dll in the same program or group of programs
13:02:00 <koz_> geekosaur: Ah, so it's an ABI problem, not 'where the hell is wtf.dll' problem?
13:02:11 <geekosaur> yes
13:02:20 <exodrifter> ah okay, thanks.
13:02:21 <koz_> geekosaur: Huh, TIL then. I always thought it was the other thing.
13:02:28 <davean> koz_: right, more the feeling of trying to stack those cards so it works enough
13:02:49 <geekosaur> it's less common these days because you have bigger than 8.3 names so you can put version numbers in the dll name
13:02:54 <merijn> davean: One of my favourite things is you call something about C dumb and the response is "but K&R were master programmers and language designers, so clearly it must be flawless"
13:03:11 <davean> merijn: uh huh
13:03:13 <koz_> monochrom: Reminds me of a joke: "A maths professor asked a question in class, and a student responded that the proof was simple. The professor left the room, came back a week later, and replied that indeed, the proof was simple."
13:03:15 <davean> merijn: read their books.
13:03:21 <geekosaur> plus there's less of a "just throw all DLLs under \WINDOWS\SYSTEM" thing left over from the old days
13:03:36 <monochrom> I think that joke used "obvious" rather than "simple".
13:03:38 <merijn> I mean, they were clearly decent hackers, but absolutely amateur language designers >.>
13:03:53 <koz_> monochrom: I believe the version I read used 'simple' (to contrast with 'trivial')
13:04:29 <koz_> merijn: And now we're stuck with it. :(
13:04:47 <merijn> koz_: Defeatist attitude!
13:04:53 <davean> Simple and obvious in math means theres a direct way to derive it an you don't need any unlikely inuitive leaps, right?
13:05:01 <davean> it doesn't really matter if it takes 100 years to do that.
13:05:22 <geekosaur> C is the English of programming languages. Discuss
13:05:23 <koz_> merijn: Maybe so.
13:05:27 <koz_> geekosaur: ROFL
13:05:37 <koz_> Considering I've taught _both_ ESL and C...
13:05:44 <monochrom> COBOL
13:06:06 <monochrom> OK, I guess COBOL is the programming languages of English instead.
13:06:08 <Cheery> monochrom: goddamn, that GHC approach to it is very cool
13:06:15 <davean> monochrom: no, COBOL is the Galic of programming languages. 
13:07:00 <davean> You really thought it was almost dead, but its shockingly alive and more things are done in it than you thought. YOu never knew $x knews it but apparently they do ...
13:07:44 <monochrom> Yeah I know
13:10:17 <davean> I know several people who made a lot of money in HS/College by doing COBOL contracting.
13:13:08 <Cheery> 22:54 < monochrom> It has a problem and it doesn't have to have that problem.
13:13:48 <Cheery> is there more behind this? I mean, the solution you presented solves the cross-reference issue and the version disrepancy is no longer so dangerous.
13:14:34 <Cheery> but is there more to this problem already figured out?
13:35:49 * hackage up 2.0.0.0 - Command-line tool to generate paths for moving upward in a file system  https://hackage.haskell.org/package/up-2.0.0.0 (ThomasEding)
14:16:49 * hackage aur 7.0.4 - Access metadata from the Arch Linux User Repository.  https://hackage.haskell.org/package/aur-7.0.4 (fosskers)
14:29:52 <Boarders> does anyone know how an efficient method to get a list of all the bits set in an Int?
14:30:29 <merijn> Data.Bits + finiteBitSize + a fold :p
14:31:12 <Boarders> just countLeadingZeros then set that bit to zero and recurse?
14:32:16 <merijn> :t \w -> map (testBit w) [0 .. finiteBitSize w]
14:32:18 <lambdabot> FiniteBits b => b -> [Bool]
14:32:41 <Cheery> it can look nice if you countLeadingZeros, then mask the bit out and repeat.
14:32:46 <merijn> > (\w -> map (testBit w) [0 .. finiteBitSize w]) (15 :: Word8)
14:32:48 <lambdabot>  [True,True,True,True,False,False,False,False,False]
14:33:01 <merijn> Mine is much easier :p
14:33:20 <Cheery> well it works if your bits are finite
14:33:33 <merijn> Cheery: He said Int, so ha! ;)
14:33:41 <merijn> > (\w -> map (testBit w) [0 .. finiteBitSize w]) (15 :: Int)
14:33:44 <lambdabot>  [True,True,True,True,False,False,False,False,False,False,False,False,False,F...
14:34:08 <merijn> Boarders: ^^
14:34:25 <Cheery> but.. countLeadingZeros requires finite bits as well.
14:34:58 <Boarders> it is ok I am only doing it for Word8 in fact
14:35:08 <typetetris> How does cabal tell me the state of my download of the index? So I can put that into cabal.project?
14:35:18 <Boarders> though I don't know if the testBit approach is more inefficient than it needs to be
14:35:37 <merijn> Boarders: Certainly better than the leading zeros + update one :p
14:35:46 <MarcelineVQ> what does it mean to get a list of set bits? is this True/False list what you're after?
14:36:29 <Boarders> merijn: huh really?
14:36:47 <merijn> Boarders: testBit is about as efficient as you can be for checking if a bit is set
14:36:56 <monochrom> I'm going to misinterpret the question and imagine "replicate (popCount x) True"
14:36:56 <Boarders> I am after that if i = 2^7 + 2^2 I get back [7,2]
14:37:20 <merijn> typetetris: I think the latest version includes the index state when you freeze
14:37:30 <MarcelineVQ> monochrom: that's kind of where I was going, just the popCount part though
14:37:31 <Boarders> or maybe that shifted 
14:37:33 <merijn> typetetris: And you should probably use a freeze file for the index-state :)
14:38:03 <typetetris> merijn: so just `cabal freeze` and check the file in? Gotcha.
14:38:10 <merijn> > (\w -> concatMap (\n -> if testBit w n then [n] else []) [0 .. finiteBitSize w]) (15 :: Int)
14:38:12 <lambdabot>  [0,1,2,3]
14:38:35 <merijn> typetetris: I'm not 100% sure, though and might depend if your cabal is new enough
14:39:07 <merijn> typetetris: But the freeze file is intended to contain, well, frozen dependencies anyway so might as well use that over putting the index-state in cabal.project :p
14:44:50 * hackage hls-plugin-api 0.4.0.0 - Haskell Language Server API for plugin communication  https://hackage.haskell.org/package/hls-plugin-api-0.4.0.0 (AlanZimmerman)
14:49:34 <nshepperd> > let tobits = foldr (\i k v -> case v of { 0 -> []; v | testBit v i -> i : k (clearBit v i); v -> k v}) undefined [0..] in tobits (17 :: Integer)
14:49:36 <lambdabot>  [0,4]
14:50:19 <nshepperd> if you give it a negative Integer you get an infinite list. lovely
14:51:25 <monochrom> 2-adic numbers are lovely, yes.
14:57:10 <Imogen> Hi! Anyone here wants to help me with some really dumb beginner questions?^^
14:57:42 <rom1504> we may never know
14:57:50 <sm[m]> yes!
14:59:02 <rom1504> ok now we know
14:59:37 <sm[m]> the end.
15:00:48 <Imogen> awesome. I'm trying to use VS code to work on a haskell project, but I don't really get how I can install libraries in a way that will make the Haskell vscode extension recognise them
15:01:38 <sm[m]> Imogen: this is fairly new tech and most of the experts hang out in #haskell-ide-engine
15:01:48 <Imogen> oh ok
15:02:33 <Imogen> What is the old way of making a workable dev environment for Haskell? Just using a different ide?
15:02:59 <sm[m]> using ghcid (a tool that runs in the console)
15:03:15 <MarcelineVQ> I use the text editor I'm more comfortable with + an open ghci session + ghcid
15:03:26 <sm[m]> and your editor of choice. There have been loads of other things but none really to rely on
15:05:02 <sm[m]> so eg if you have VS Code working, just open a terminal pane and run ghcid there in your project directory, then edit. This is not state of the art UI but it will avoid a whole lot of bleeding edge/configuration hassles
15:05:38 <monochrom> I use emacs and its haskell-mode (70% of "IDE" features for 1% of the price), plus building docs locally and using web browser to read them.
15:05:54 <Imogen> oh ok, so stuff like syntax highlighting or the hover over a name to see info about it stuff aren't really a thing for haskell?
15:06:18 <monochrom> Mine is very workable for me, but clearly "workable" is subjective, some people are more anal than others.
15:06:33 <sm[m]> syntax highlighting is easy, your vscode plugin should be doing that. hover over a name is WIP, the vscode plugin is supposed to be the easiest way. #haskell-ide-engine knows more
15:06:37 <monochrom> Oh syntax highlighting is trivial, everyone has it.
15:06:46 <monochrom> I don't require hover.
15:07:12 <monochrom> I just require myself to go to the repl and enter ":type x" or ":info x"
15:07:24 <merijn> monochrom: That doesn't quite work, though
15:07:25 <Imogen> alright, guess I'm too used to shiny new stuff from other languages and should learn how to work with ghci more^^
15:07:38 <merijn> monochrom: When 'x' is in the middle of a complicated expression without accessible binding
15:07:45 <merijn> monochrom: hdev
15:07:46 <monochrom> For local vars, haskell-mode does have a command for "show type of the thing at cursor"
15:08:01 <merijn> hdevtools used to have that and it was super useful
15:08:10 <sm[m]> changing x to _x with ghcid running can help
15:08:11 <merijn> monochrom: Right, that's what people usually want for hover :p
15:08:12 <monochrom> ghci has it now
15:08:22 <monochrom> haskell-mode calls ghci for it
15:08:25 * ski . o O ( "semantics highlighting" )
15:08:33 <merijn> sm[m]: Well, not really
15:08:39 <sm[m]> no ?
15:08:48 <merijn> that tells me the type inferred by the surroundings, not the actual type of the thing in question
15:08:49 <sm[m]> I thought it shows the type of x
15:08:54 <monochrom> But most people don't know because by default setting, haskell-mode doesn't already have a key binding for this feature.
15:08:59 <merijn> So now I just know 'x' unifies with whatever is reported for _x
15:09:17 <sm[m]> ah well.. this'd be beyond my needs as a beginner I think
15:09:46 <monochrom> Oh I also turn on -fdefer-type-errors, yeah.
15:09:55 <monochrom> So I don't have to write _x
15:10:30 <monochrom> ghci has "type of expression from line 3 column 5 to line 4 column 10"
15:10:41 <sm[m]> Imogen: in case it wasn't clear, ghc, ghci, ghcid, ghcide are all different (and useful) tools, not typos
15:10:47 <monochrom> it is unusable manually, but haskell-mode and dante use it.
15:11:24 <monochrom> But really, statistically speaking, whenever I say a positive thing about these low-tech solutions of haskell-mode and ghci, no one notices.
15:11:46 <Imogen> sm[m]: yeah, I've used most of them before, but I thought they got superceded by the vscode extension and I was just not getting how to set it up properly
15:11:48 <dolio> I notice.
15:11:50 <monochrom> But when I briefly mention a limitation, everyone suddenly see it very clearly.
15:11:58 <glguy> I notice that no one notices :nod:
15:13:28 <dolio> I haven't even worked up the energy to set up the low tech things, though.
15:14:09 <glguy> You haven't set up ghci?
15:14:32 <sm[m]> Imogen: ok good
15:14:34 <dolio> I have that. That's even lower tech than the low tech things being discussed.
15:14:45 <Imogen> oh also, I was trying to use stack for my project and I read that in order to use an external library I need to put it into the package.yaml file. When I then ran the build command stack gave me an error saying that I needed to add a bunch of version specifications to the stack.yaml file for it and all its depedencies. Is that really the best way
15:14:45 <Imogen> or is there a way to tell it to just use whatever the newest version is?
15:15:19 <glguy> the benefit of stack is that you get to manually set all the versions
15:15:40 <sm[m]> Imogen: set the resolver in your stack.yaml to a newer one, eg the newest LTS or newest nightly mentioned on stackage.org
15:16:01 <Imogen> I set it to ghc-8.10.1, is that not a good idea?
15:16:10 <sm[m]> no it's not
15:16:30 <sm[m]> that's a limited resolver with a small set of packages, I believe
15:17:03 <Imogen> alright
15:17:27 <sm[m]> resolver: lts-16.3 is a good choice
15:18:02 <Imogen> ok, using that then
15:18:19 <Imogen> thanks
15:24:58 <sm[m]> oops.. lts-16.13
15:28:34 <redmp> where is it documented what the meanings of the various arguments for haskell-modules/generic-build.nix are? for example: there's around 26 different arguments which are lists of dependencies (eg. testDepends, testHaskellDepends, executableHaskellDepends, executableFrameworkDepends ..etc)
15:32:00 <sm[m]> redmp: in the nixpkgs code, seems to be the usual answer
15:33:59 <redmp> sm[m]: yeah, i've trawled through it a bit.. the lists get passed around and translated into the inputs for the underlying builder.. but it's all pretty unclear and doesn't fit my model for the different kinds of dependencies you can declare in a cabalfile.. clearly the authors had more expansive intentions, (eg. you can specify system dependencies in nix), but those aren't documented or clear from the code
15:34:38 <redmp> that is, i'm not trying to critique it, but i've been squinting at it for months and wondering if there's a reference out there
15:34:40 <sm[m]> the maintainer is here sometimes but I forgot the nick. You can find them with git blame
15:37:55 <redmp> sm[m]: thanks. i'll keep squinting at the source until then
15:39:06 <sm[m]> redmp: np. If you aren't already familiar with Cabal packages, reading about those would probably make things clearer
15:41:00 <redmp> sm[m]: thanks, no, i was mainly confused by the aparrently larger featureset supported by the generic-builder
15:41:18 <sm[m]> nod
16:41:20 * hackage aura 3.1.9 - A secure package manager for Arch Linux and the AUR.  https://hackage.haskell.org/package/aura-3.1.9 (fosskers)
17:28:19 * hackage spherical 0.1.3.0 - Geometry on a sphere  https://hackage.haskell.org/package/spherical-0.1.3.0 (vmchale)
17:58:49 * hackage morpheus-graphql-core 0.15.0 - Morpheus GraphQL Core  https://hackage.haskell.org/package/morpheus-graphql-core-0.15.0 (nalchevanidze)
17:59:50 * hackage morpheus-graphql 0.15.0, morpheus-graphql-client 0.15.0 (nalchevanidze): https://qbin.io/valium-sas-ea5b
18:03:50 * hackage calamity 0.1.20.1 - A library for writing discord bots in haskell  https://hackage.haskell.org/package/calamity-0.1.20.1 (nitros12)
18:28:31 <emmanuel_erc> hello there everyone
18:29:38 * ski blinks slowly
18:30:07 <emmanuel_erc> so I had a coworker recently tell me that the json parsing (in terms of the amount of code one has to write to generate json for your data types) is inferior in Haskell compared to Java, but Haskell can't easily figure out how to encode/decode JSON from your datatypes just by simply typing something akin to "encode @SomeType"
18:30:20 <emmanuel_erc> apparently you can do something like this in Java.
18:33:20 <lemmih> Java isn't all bad but I'd never pick Java over Haskell no matter how easy it is to encode JSON objects.
18:34:30 <emmanuel_erc> My coworker's main gripe was that you had to write something like "instance FromJSON SomeType" (provided you had a Generic instance for your type)
18:34:43 <emmanuel_erc> Apparently having to write that line of code makes Haskell inferior.
18:41:37 <yushyin> With DeriveAnyClass you can do data Foo = ... deriving (Generic, FromJSON, ToJSON)
18:47:48 <koz_> emmanuel_erc: If that's the level of thinking this person engages in, nothing they think matters.
18:48:07 <Cale> emmanuel_erc: What do they do in Java when the default way of producing JSON for a type isn't the appropriate one?
18:48:22 <lyxia> yeah that's a pretty ridiculous argument
18:48:26 <Cale> emmanuel_erc: How do you say "I accept the default, vs. I want something different"?
18:51:29 <monochrom> It's rationalization.
18:54:31 <koz_> monochrom: I didn't know that's how you spelled 'total lack of self-awareness'. :P
18:55:51 <monochrom> It is the spelling of many fallacies. :)
18:59:01 <emmanuel_erc> @Cale I hadn't thought of those counterpoints when the guy made his comments towards me
18:59:01 <lambdabot> Unknown command, try @list
18:59:03 <emmanuel_erc> wish I had
18:59:31 <monochrom> Please don't argue with that person at all.
19:00:01 <emmanuel_erc> This guy is not a fellow dev. He's just a PM. I have meetings with him, so I have to deal with him.
19:00:18 <monochrom> If someone brings up that Java's exception system is excellent and even we Haskellers envy it, that's a person worth your time discussing with.
19:01:05 <koz_> emmanuel_erc: In that case, I feel sorry for you.
19:01:17 <monochrom> But a tiny o(1) thing like <3 tokens here> vs <5 tokens here>? That's a waste of time.
19:06:40 <emmanuel_erc> I think the major problem with this guy (the PM) is that he is a product manager trying to flex his muscles as his software developer.
19:06:51 <emmanuel_erc> Even though, he practically does little of the latter.
19:07:15 <monochrom> Looks like an inferiority complex.
19:07:39 <emmanuel_erc> Unfortuntaly, I pretty much yelled at the guy today because I've slowly but surely lost patience with his constant need to denigrate Haskell.
19:07:53 <monochrom> He knows secretly he's inferior. So he has to pick fights to project a superior image.
19:09:18 <monochrom> When his supervisor is around, and he's still doing this, your stab at him will be "did the company hire you to be a product manager or language critic?"
19:10:09 <monochrom> But you only say this when his supervisor is around. It is for the supervisor to hear.
19:10:52 <emmanuel_erc> his supervisor is only around during meetings that involve everyone and we generally don't discuss anything Haskell related during these meetings.
19:11:07 <emmanuel_erc> But I'll give it a go if I get the chance.
19:11:40 <dmwit> Is it important that he not believe that Haskell is inferior for some reason?
19:11:46 <dmwit> What if you just let him be wrong?
19:13:03 <glguy> For throw-away programming the automatic behavior can be desirable. Maybe they're making one-off stuff and not code that needs to be maintained
19:14:00 <monochrom> Yeah that reminds me.
19:14:25 <emmanuel_erc> dmwit: No, I suppose not. But, the problem is not so much the Haskell bashing. It is the fact that he is toxic. He is generally unpleasant to work around because he always has to seem like the "biggest" guy in the room.
19:14:33 <monochrom> Java has had automatic code generation for serialization for a long long time. You just say the equivalent of "deriving Serialization" or something.
19:15:01 <monochrom> And for the same long long time, professionals and experts have sworn by avoiding it.
19:16:01 <emmanuel_erc> monochrom: That is depressing.
19:16:12 <monochrom> The best practice is to hand-write serialization and version it because you expect, over the next 5 years, your class/object fields are going to change, and you still need to be able to deserialize older versions.
19:22:45 <nshepperd> (Unison seems to use the automatic serialization provided by ocaml, and this is very inconvenient and annoying because it means the client/server protocol is incompatible with versions of Unison *compiled with a different version of the compiler*. Which is a big pain when they're different platforms)
19:57:54 <edwardk> nshepperd: ouch
20:30:48 <nshepperd> yup
20:36:12 <emmanuel_erc> monochrom: I think I figured out something I could tell my coworker to do in case he opens his mouth again. I will tell him I will only have arguments/discussions about Haskell with him only if writes a JSON parser (no concerns about performance) for me in Haskell.
20:48:43 <hyiltiz>  /j #python
20:48:54 <hyiltiz> ooops, embarsassing
20:49:31 <hyiltiz> May as well ask here; can u bind the lambda keyword in python to \ for a proper lambda syntax?
20:49:35 <MarcelineVQ> shunnn
20:49:46 <suzu_> i think you can't
20:49:54 <suzu_> keywords aren't functions
20:50:11 <hyiltiz> not even wrap the keyword in a dark magic way?
20:50:29 <hyiltiz> not even sure if u can bind functions to backslash \ in python tho
20:50:54 <hyiltiz> cuz it doesn't parse (without dark magic)
20:50:59 <hyiltiz> and i have no dark magic in python
20:51:02 <suzu_> yeah think you can't
20:51:04 <suzu_> good thinking though
20:51:32 <suzu_> anyone know how i can get a yesod starter template on a compiler that's newer than 8.8.4?
20:51:35 <hyiltiz> hmm such a bad language :(
20:51:36 <suzu_> with stack
20:51:46 <suzu_> hyiltiz: python has a lot haskell doesn't
20:52:01 <hyiltiz> more > less?
20:52:01 <suzu_> a big ecosystem, a lot of productivity
20:52:04 <suzu_> you can get going with so much stuff so quickly
20:52:11 <suzu_> but when it comes time to maintain your 1M lines of python
20:52:16 <suzu_> you'll start ripping your hair out then
20:52:18 <suzu_> lol
21:00:39 <suzu_> is there a haskell stack channel?
21:13:10 <sm[m]> suzu_: stack --resolver nightly new nameofyesodtemplate?
21:13:34 <suzu_> that chooses a bunch of stuff that makes me go into a rabbit-hole on extra-deps
21:13:36 <sm[m]> Yes, #haskell-stack but it's pretty quiet
21:14:24 <suzu_> i think yesod-core isnt in the nightly or something
21:15:33 <sm[m]> suzu_: nightly is ghc 8.10 which I would expect is supported by most of the ecosystem by now.. but I have noticed that yesod got knocked out of stackage about a month ago, I think it will be readded on tonight's snapshot which should
21:15:33 <sm[m]> help
21:15:43 <suzu_> ah great
21:15:49 <suzu_> do you know why it got kicked?
21:16:34 <sm[m]> yes, a bad release of persistent-template about four months ago (depends on a nonexistent persistent version)
21:16:55 <suzu_> ah ok
22:07:23 <arianvp> just installed haskell language server plugin for vscode but nothing is happening
22:07:30 <arianvp> is there any way to view its logs or something?
22:07:37 <arianvp> only option I have in the menu is "Restart language server"
22:10:13 <arianvp> ah found it
22:10:18 <arianvp> dont have high enoug hvscode version
23:10:50 <ixlun> Is it possible to do something like: data A = Foo | Bar; data B = Baz | A ?
23:11:11 <ixlun> so then B has three value constructors?
23:12:29 <ixlun> I guess it's ambiguous though.  What is the type of `Foo'?
23:30:21 <glguy> No
23:44:45 <cheater> ixlun: no, but you can do data B = Baz | MyA A
23:45:27 <koz_> Or even 'data B = Baz | A A'
