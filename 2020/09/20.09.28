00:06:02 <Axman6> ADG1089: that's a very general and very specific question by the way - is there something that already does both those things? Almost certainly not, but are there things which can do both and be easily joined together, most definitely
00:06:23 <ADG1089> i'm mostly concerned about the api part
00:06:30 <ADG1089> sorry,  i was not specific enough
00:07:02 <ADG1089> otherwise the database operations and excel file processing can be done without any framework.
00:07:17 <ADG1089> minimal sql-client atleast
00:07:23 <siraben> MarcelineVQ: which libraries are good for benchmarking haskell programs?
00:07:33 <Axman6> siraben: criterion
00:07:52 <Axman6> ADG1089: what do you actually want to do?
00:07:53 <siraben> Axman6:  ok, will take a look
00:09:58 <ADG1089> Axman6: I want to take in as input doctor & medicine data excel and process it (nothing complicated) and then insert it into database. This will be served using an API
00:10:18 <Axman6> does it have to be excel?
00:30:46 <ADG1089> Axman6: yeag
00:30:48 <ADG1089> *yeah
00:49:25 <Guest_68> Hello. how should I add ghcup to PATH?
00:49:56 <maerwald> Guest_68: which os
00:50:01 <Guest_68> mac
00:50:31 <maerwald> add this to ~/.bashrc: source ~/.ghcup/env
00:50:51 <maerwald> add this to ~/.bash_profile: [[ -f ~/.bashrc ]] && source ~/.bashrc
00:52:56 <Guest_68> maerwald: ok. how do i open this bashrc file on mac?
00:53:40 <maerwald> Guest_68: http://letmegooglethat.com/?q=how+do+I+open+a+file+on+mac
00:54:35 <Guest_68> funny.
00:54:44 <yushyin> I've a deja-vu
00:54:53 <Guest_68> i can't find this file
00:57:06 <Guest_68> I'm not comfortable working and editing in a terminal
00:57:25 <yushyin> first things first, make sure which shell you use. Afaik mac os x switched to zsh
00:58:29 <Guest_68> i don't know much about theese things. it's bash i guess
00:59:47 <Guest_68> i want to update ghc but it says "-bash: ghcup: command not found"
01:00:24 <yushyin> if the files do not exists just create them
01:00:35 <Guest_68> how?
01:02:08 <maerwald> Guest_68: run the install script again and answer with YES at the end again
01:02:09 <yushyin> open a text editor, fill it with content (like the suggested lines), save it at the desired location
01:02:46 <yushyin> would be one possibility
01:06:19 <Guest_68> ok thanks. solved. used something called "nano" and then "source"
01:06:31 <Guest_68> don't know what these are. just worked.
01:10:04 <c_wraith> nano is a very minimal text editor
01:10:20 <yushyin> 'and then "source"' I don't know what that is supposed to mean :D
01:10:23 <johnnyboy[m]> is call-by-name evaluation the same thing as leftmost-outermost evaluation strategy? How about normal order evaluation strategy?
01:10:30 <c_wraith> source loads a file into the current bash environment.  Which lets you pick up changes to a config file without restarting the terminal
01:10:52 <Guest_68> yushyin :D
01:11:21 <Guest_68> c_wraith thanks
01:13:31 <Guest_68> I just watched a video about haskell and liked those "type" stuff written before functions. It was interesting that these stuff are just comments in other programming languages, but in haskell they aare something you can work with.
01:18:40 <Ferdiran1> Guest_68: your sample of programming languages might be somewhat biased
01:19:00 <c_wraith> Other languages have useful types too.  But Haskell definitely is on the powerful side, if not at the far end.
01:21:00 <Guest_68> my sample is empty! I've been learning programming with python and a little java just for 3 months. I just feelt like Haskell is "clean" and elegant and decided to learn it.
01:23:40 <Guest_68> BTW, how can i have a username for myself here?
01:25:33 <perdent> Does anyone here have MAGMA Algebraic installed on their PC? As I need to run a script I wrote and because the complexity is more than 120s (web version only allows that). I just need to see what the outputs are for my problem, it would be much appreciated if someone could help me out?
01:25:37 <yushyin> Guest_68: /nick <username>
01:25:45 <yushyin> Guest_68: see also https://freenode.net/kb/answer/registration
01:27:02 <Guest_68> yushyin thanks
01:31:33 <johnnyboy[m]> Does Haskell satisfy some confluence (Church-Rosser) property?
01:31:46 --- mode: ChanServ set +o Sigyn
01:31:51 <johnnyboy[m]> I.e. is it true that terminating evaluations always yield the same result for the same expression?
01:35:53 <phadej> that's not meaningful, in some reduction order evaluation could diverge, in one not.
01:35:57 <Cheery> johnnyboy[m]: it's possible to violate that in Haskell, but technically you'd like that to hold.
01:36:48 <phadej> but yes, we like (sometimes) to think that Haskell is well-behaved rewrite system.
01:39:05 <johnnyboy[m]> it's slightly confusing to see different terminology for what appears to be the same things in Haskell and lambda-calculus
01:39:18 <johnnyboy[m]> evaluation vs. reduction/contraction
01:39:50 <johnnyboy[m]> call-by-name vs. normal order reduction (I'm not sure if these are the same)
01:40:24 <johnnyboy[m]> on the other hand, things often tend to have different names in different contexts
01:41:16 <johnnyboy[m]> after learning some category theory, regular math starts to look like as if it's constantly reinventing the same wheel under different names
01:41:34 <c_wraith> Haskell isn't confluent in the sense that every expression reduces.
01:41:50 <johnnyboy[m]> yes, I know that part
01:42:01 <johnnyboy[m]> but it could be weakly normalising
01:42:20 <Cheery> System.IO.Unsafe
01:42:37 <Cheery> you get unsafePerformIO :: IO a -> a
01:43:18 <c_wraith> But people do say that every expression that converges under *some* evaluation order should converge in Haskell. I haven't gone digging through the spec to verify that it's actually in there.
01:44:44 <johnnyboy[m]> I think there's this theorem in lambda-calculus saying that  the leftmost outermost strategy always finds the normal form if it exitsts
01:45:14 <c_wraith> and obviously that falls apart when you start doing things with unsafePerformIO like reading from an IORef and doing different things based on the result.
01:46:14 <johnnyboy[m]> I was considering the pure part of Haskell
01:46:26 <johnnyboy[m]> I probably should have mentioned that
01:46:28 <c_wraith> But in the subset of haskell that bans execution, yeah
01:47:24 <ggVGc> the best part about unsafePerformIO is that in the worst case you're just doing JS :D
01:47:30 <cpressey> The pure part of Haskell should be confluent, in the sense that term is used in term rewriting. If there are exceptions, I'd like to know about them,
01:47:35 <Uniaika> ggVGc: hahaha
01:47:58 <ggVGc> I mean, it's not entirely true...
01:48:01 <cpressey> *I'd sure like to know about them!
01:48:03 <ggVGc> worst case you're doing C++ I guess
01:48:16 <ggVGc> which to be fair is pretty bad
01:48:28 <c_wraith> nah.  the worst case with unsafePerformIO is really worse than that, as GHC is free to optimize pretending it doesn't exist.
01:48:34 <johnnyboy[m]> do you get runtime linkage errors in Haskell?
01:48:40 <ggVGc> oh well
01:48:40 <johnnyboy[m]> if not, that's not C++ :P
01:49:21 <c_wraith> cpressey: I think you have to consider all bottoms equivalent, otherwise imprecise exceptions bite you
01:49:44 <cpressey> Oh right, exceptions
01:50:12 <johnnyboy[m]> in lambda-calculus, not all non-normalising terms can be considered as bottoms
01:50:21 <johnnyboy[m]> otherwise, the system becomes inconsistent
01:51:25 <c_wraith> Haskell is already an inconsistent logic. (Turns out programming is way easier as a practical matter when your type system is an inconsistent logic)
01:51:57 <johnnyboy[m]> I wonder if there are paraconsistent programming languages...
02:10:14 <dminuoso> Im adding some "audit logging" to a servant api, where interaction with resources cause audit trails that can be read from though `/foo/:id/audit`. Ive started to have this type `data LogEntry = LogEntry { logSlug :: LogSlug, logMessage :: Text, logTimestamp :: UTCTime }`, where LogSlug is this huge coproduct type of nullary constructors with `data LogSlug = FooHappened | BarHappened |
02:10:15 <dminuoso> StuffChanged | ...` 
02:10:27 <dminuoso> Is this idea of having a large coproduct type sensible for this usecase?
02:15:28 <gentauro> dminuoso: what about `data LogSlug = LogCode Word`?
02:16:12 <gentauro> that way you can still pattern match, but reducing the amount of `tags` in your `sum type`
02:17:14 <dminuoso> gentauro: Isn't that just the same though? Except now I write `LogCode 10`, where it's not obvious what 10 is, whether 10 is correct, etc. And on the other side I pattern match against a number.
02:19:24 <gentauro> dminuoso: I guess. I have been working with M$ systems that had more that to many `error codes`. I would never create these as a `sum type`: https://docs.microsoft.com/en-us/powerapps/developer/common-data-service/org-service/web-service-error-codes
02:19:39 <gentauro> I would rather just have a numbe and then look it up on that page to be honest
02:19:41 <cpressey> dminuoso: What kinds of things are you logging?
02:20:03 <gentauro> s/numbe/number/
02:21:17 <dminuoso> cpressey: Essentially modifications to resources, sort of a "changelog" if you want.
02:22:31 <cpressey> dminuoso: My feeling is that you should try to capture the structure of the changes in the type.  There isn't much sense data-modelling a "log line" because it's not a domain object, it's more like an artefact.
02:22:34 <gentauro> dminuoso: and I also realized that Haskell (GHC) is not happe with really big `sum types` :) http://blog.stermon.com/articles/2020/03/30/haskell-data-octet-safe-idiomatic-and-big.html and http://blog.stermon.com/articles/2020/04/06/haskell-data-octet-nand-smaller-but-slower.html
02:23:18 <cpressey> e.g. data LogEntry = ThingFieldChange ThingId FieldId UTCTime | OtherChange ... 
02:23:19 <gentauro> s/happe/happy
02:35:30 <jgt> is there a nicer way to make something like this work? `or [ isJust $ Just 1, isJust $ Just "foo" ]`
02:36:48 <jgt> something with `any isJust` won't work, because then the list would be heterogenous
02:43:22 <cpressey> jgt: It's very unclear to me what you want to accomplish. Is it important that the values be in a list?
02:44:39 <EvanR> yeah you can't even create the list you're talking about because everything in it must be the same type
02:44:57 <jgt> cpressey: No, I have a bunch of heterogenous values, and I want to check if any of them are a Just
02:45:40 <cpressey> jgt: case (x,y,z) of (Nothing, Nothing, Nothing) -> none are Just; _ -> yes at least one it
02:45:48 <cpressey> s/it/is/
02:46:58 <jgt> is there another way that avoids a tuple? The tuple would work, but it's a little unergonomic for larger collections of values
02:47:36 <EvanR> what form does this collection actually take
02:48:53 <EvanR> genuinely curious
02:49:15 <jgt> it's actually in a record, so my function is pulling out specific fields from a record and checking if any of them are a Just
02:50:43 <EvanR> can you make a polymorphic function that takes a record, a field, and returns a Bool
02:51:10 <EvanR> i.e. generic record lib
02:51:24 <jgt> yeah, I think that might be the way to do it
02:51:45 <jgt> or maybe the original approach is totally fine; might be silly to over-engineer it
02:51:50 <jgt> just looks a bit noisy
02:52:41 <EvanR> since you don't care about the payload i would think you want to put a zillion "hasField foo bar" instead of isJust
02:56:05 <dminuoso> jgt: Perhaps it might be easier to see the context of the code.
02:56:27 <dminuoso> Maybe, you're too deep in XY land.
02:56:48 * hackage replace-megaparsec 1.4.3.0 - Find, replace, and split string patterns with Megaparsec parsers (instead of regex)  https://hackage.haskell.org/package/replace-megaparsec-1.4.3.0 (JamesBrock)
03:00:48 <jackdk> Anyone here familiar with amazonka-dynamodb? I'm trying to write a conditional PUT that succeeds only if the timestamp of the item is greater than the timestamp of the item in the table. I'm currently stuck trying to create a value of type Network.AWS.DynamoDB.Types.AttributeValue that stands for an expressionAttributeValue `:foo`.
03:00:59 <jackdk> Axman6: I know you've dabbled in this space
03:27:06 <Guest_50> im trying to download on mac but having issues, could anyone help?
03:29:22 <miguel_clean> eh, I let my programm run over the weekend with +RTS -p but the resulting .prof file only reports a total time of ~120seconds... while the programm was taking up around 100-200% cores for all the time.. what am I missing?
03:29:33 <yushyin> Guest_50: what are you trying exactly?
03:43:28 <dminuoso> gentauro: Well this is definitely not a CPU intensive code path.
03:44:59 <dminuoso> cpressey: Mmm, well the UTCTime I would still float out since that's common to *every* log occurence anyway,.
03:45:08 <dminuoso> But I see what you mean.
03:53:31 <maerwald> yushyin: some course must have started 
03:53:46 <yushyin> seems so :D
03:54:15 <MarcelineVQ> maerwald: must be rough, hang in there
04:11:54 <yushyin> maybe just add a faq entry, 'macOS common gotchas'
04:13:09 <MarcelineVQ> From what I've seen the most common gotcha is not reading the terminal output, and not pasting it into google to find out what it means if you do
04:13:21 <MarcelineVQ> In that particular case a faq would go unread as well, imo
04:13:24 <fendor> wasn't this mainly "I dont know about PATH"? 
04:13:37 <maerwald> MarcelineVQ: well, I just added https://gitlab.haskell.org/haskell/ghcup-hs/-/commit/3e429945dcd90bf65ed49dc36683c3d6ed37aa28
04:13:40 <fendor> hard to write an FAQ about that
04:13:43 <ph88> I have a typeclass with getStart and getStop Is there syntax that i automatically get getDuration for any instance that implements this typeclass ??
04:13:54 <maerwald> which I think isn't really such a good idea, but it might decrease the noise here
04:14:04 <fendor> maerwald, :+1:
04:15:52 <ph88> i think i found my answer here https://downloads.haskell.org/ghc/latest/docs/html/users_guide/glasgow_exts.html#default-method-signatures 
04:16:22 <MarcelineVQ> ph88: Oh ok I was gonna ask if getDuration was also part of the class
04:17:42 <MarcelineVQ> mind that it doesn't need to be a class method, for the most part all you can do with a start and an end to get a duration is subtract, so there's not a huge point to having it be its own method as opposed to just a function you export that uses the class's methods
04:17:47 <lortabac> ph88: including getDuration in the class makes sense if there is a possibility to provide a more efficient implementation for some instances
04:18:06 <lortabac> otherwise a normal function is a better idea
04:19:48 <ph88> lortabac, why would you say a normal function is better ?
04:20:52 <lortabac> ph88: if the implementation is always the same, why should it be a class method?
04:20:54 <MarcelineVQ> Because most defintions will just be   getstart, dothing, get end, end - start
04:49:19 * hackage acc 0.1 - Sequence optimized for monoidal construction and folding  https://hackage.haskell.org/package/acc-0.1 (NikitaVolkov)
05:14:20 <svipal> Yo
05:14:39 <svipal> Contexts not working for some reason in my projects that use inline-c
05:15:08 <svipal> I have literally the same code as my old projects but somehow not working ? what is this black magic
05:15:30 <svipal> ah
05:15:31 <svipal> AH
05:15:32 <svipal> nvm
05:15:36 <merijn> New compiler? New version? New...?
05:15:43 <svipal> No I'm just dumb
05:15:44 <merijn> Copy paste fuck up? :p
05:15:50 <svipal> W o r s e
05:15:59 <merijn> You forgot to hit save!
05:16:33 <svipal> No I just switched which of the two names in the type table I was supposed to quote in the C code zzzzzzz
05:36:08 <svipal> with stack/cabal can I specify where to install a foreign lib once it's built ?
05:39:05 <Xnuk> Is it worth for trying cabal v2+ over stack?
05:41:43 <svipal> No idea
05:41:55 <svipal> Honestly I'm just using stack because it works for me
05:46:58 <[exa]> Xnuk: does your setup explicitly require stack? (if not, you can avoid a lot of cruft)
05:48:36 <hc> I'm getting the impression that stack is not entirely popular in the larger haskell community?
05:49:33 <dminuoso> Xnuk: Try it and see whether you like it?
05:49:38 <dminuoso> It's, mostly, a drop in solution
05:49:48 <yushyin> hc: more of a 50:50 split
05:49:49 <dminuoso> Just run hpack once, then you can try cabal directly with your project
05:50:01 <dminuoso> In most cases it will just work, but you might have to adapt version bounds.
05:50:14 <Uniaika> hc: you can't have absolutes in a 30-year old community :)
05:50:25 <dminuoso> But really, stack and cabal are not the same thing, they have different mentalities.
05:51:00 <hc> By the way, are there any plans to allow multiple versions of the same package in the same binary?
05:51:14 <dminuoso> hc: No.
05:51:21 <dminuoso> Or rather, this presents really big challenges
05:51:27 <dminuoso> If you allowed that, you could not have interop between them
05:51:50 <hc> I never looked into the implications; I just know that rust does it and it seems to work around certain issues for them pretty well
05:51:55 <Xnuk> Is there no more butterfly version resolving in cabal?
05:52:46 <dminuoso> Say if you got `t :: T` from libraryT 1.1, can you pass that to `f :: T -> A` from libraryT 1.2?
05:52:59 <dminuoso> How can we know whether this is safe?
05:53:13 <Uniaika> you'd have to encode that somehow in the interface file
05:53:57 <hc> hmm, two packages of the same version would never need to "interact" directly
05:53:57 <yushyin> oh this reminds me of JS and npm, and I'm getting nightmares
05:53:58 <dminuoso> And this might be obvious if you're the immediate user of those two, but through transitive versions, this can lead to highly incoherent code.
05:54:14 <dminuoso> Things become just much simpler if you demand coherency
05:54:17 <Uniaika> Xnuk: I think not? The last mention of it was from 2011 but I don't know anybody who does that in real-life
05:54:18 <hc> I wonder what rust did to make this work?
05:54:47 <dminuoso> hc: Are you sure you are not conflating things?
05:55:01 <dminuoso> Are you sure rust allows multiple versions of the same crate in a binary?
05:55:10 <hc> dminuoso: positive
05:55:13 <dminuoso> Fair enough
05:55:19 <hc> but only 99% sure
05:55:21 <hc> ;p
05:55:48 <dminuoso> hc: I see, so Ive looked at what Rust does, and it does the only reasonable thing
05:55:53 <dminuoso> It provides *no* interop between them
05:56:02 <dminuoso> So `T` from libraryT 1.1 and 1.2 are different types.
05:56:15 <dminuoso> And the symbols are hashed, so that they cant link
05:56:29 <Uniaika> > Cargo can indeed link multiple versions of some crate, but only one of those versions can be a direct dependency. The others are indirect references.
05:56:31 <lambdabot>  <hint>:1:41: error: <hint>:1:41: error: parse error on input ‘of’
05:56:33 <dminuoso> (that is, they are prefixed with a version hash, so that you cant resolve a mix-match)
05:56:37 <idnar> dminuoso: I thought ghc did allow this the same way
05:56:41 <Uniaika> from two years ago, dminuoso https://stackoverflow.com/questions/51714866/is-it-documented-that-cargo-can-download-and-bundle-multiple-versions-of-the-sam
05:57:25 <dminuoso> idnar: Possibly if you manually link?
05:57:35 <dminuoso> At least, with cabal you cant since it attempts to generate a coherent build plan
05:57:47 <dminuoso> So if you have two conflicting version constraints, cabal will error out
05:59:54 <dminuoso> I think this is rather an artifact of cabal old-style
06:38:43 <amf> is there a limit on the number of constructors a sum type can have?
06:40:41 <dminuoso> amf: Do a quick attempt with TH to find out? ;)
06:40:54 <dminuoso> The language itself poses no restriction here.
06:41:28 <dminuoso> There likely is some implementation limitation, maybe something along the lines of 2^32-1 constructors?
06:41:32 <dminuoso> On GHC anyway
06:42:38 <amf> yeah i could try TH, but was hoping for it documented somewhere, ghc isn't complaining, but im only at 255
06:42:50 <dminuoso> amf: Fun fact: https://hackage.haskell.org/package/ghc-prim-0.6.1/docs/src/GHC.Tuple.html#%28%2C%2C%2C%2C%2C%2C%2C%2C%2C%2C%2C%2C%2C%2C%2C%2C%2C%2C%2C%2C%2C%2C%2C%2C%2C%2C%2C%2C%2C%2C%2C%2C%2C%2C%2C%2C%2C%2C%2C%2C%2C%2C%2C%2C%2C%2C%2C%2C%2C%2C%2C%2C%2C%2C%2C%2C%2C%2C%2C%2C%2C%29
06:42:54 <dminuoso> (See the comment below)
06:43:04 <dminuoso> I tried to nail this down a while ago, the issue was never found.
06:44:18 <int-e> Oh, commas.
06:50:51 <amf> now i'm wondering what kind of ascii art one could make with data declarations
06:50:52 <dminuoso> amf: So the GHC doesnt complain with at least 100,000 constructors.
06:51:30 <dminuoso> Keep in mind that, performance wise, GHC really doesn't fare well with many constructors. :p
06:51:48 * hackage replace-attoparsec 1.4.2.0 - Find, replace, and split string patterns with Attoparsec parsers (instead of regex)  https://hackage.haskell.org/package/replace-attoparsec-1.4.2.0 (JamesBrock)
06:52:51 <amf> far more than i thought, that should cover my needs. i cant imagine the ieft adding a lot more to the icmpv6 types/codes
07:11:39 <dminuoso> amf: I tried with 1G constructors, but there appears to be something exponential in terms of memory usage..
07:11:46 <dminuoso> Sorry, *1million
07:12:19 <dminuoso> Or rather, that started swapping GHC memory.
07:12:35 <dminuoso> At that point, I aborted after 15 minutes. :p
07:14:01 <tomsmeding> to be honest I'm not surprised that ghc gets all flustered when you give it a 1M-constructor sum type
07:17:44 <MarcelineVQ> not at all, especiall if you're going to derive anything
07:18:19 <dminuoso> Imagine doing generics with that :>
07:18:38 <dminuoso> https://xkcd.com/303/
07:19:25 <MarcelineVQ> now that would be: waiting for CI logs to update
07:22:28 <ph88> lortabac, why would you say a normal function is better ?
07:22:37 <ph88> lortabac, sorry wrong window :P
07:44:35 <tomsmeding> that generics Rep type would be the hugest thing ever
07:44:48 * hackage acc 0.1.0.1 - Sequence optimized for monoidal construction and folding  https://hackage.haskell.org/package/acc-0.1.0.1 (NikitaVolkov)
07:56:45 <ph88> how come runReaderT takes 3 arguments like in    runReaderT (modify (+ 2)) var    at https://www.fpcomplete.com/blog/2017/06/readert-design-pattern/     but it's type signature has just one argument    runReaderT :: r -> m a   
07:56:50 <ph88> 2 *
08:00:30 <ski> @type runReaderT
08:00:32 <lambdabot> ReaderT r m a -> r -> m a
08:02:00 <ski> you're bitten by mixing up the type of the field `runReaderT' with the type of the field selection/projection function, which (unfortunately, imho), also happen to be spelled in the same way
08:02:14 <ski> ph88 ^
08:03:18 <ph88> thanks ski 
08:04:25 <ph88> strange .. i also can't find the right runReaderT !
08:07:56 <ph88> Is it possible to use Maybe Monad when also IO actions are needed ?  https://bpa.st/FKYA  
08:08:09 <ski> "the right runReaderT" ?
08:08:34 <ski> maybe you want to use `MaybeT IO' ?
08:09:12 <ski> (or `MaybeT m' where `MonadIO m', possibly)
08:12:19 * hackage path-utils 0.1.1.0 - Handful of simple utility functions for the path library.  https://hackage.haskell.org/package/path-utils-0.1.1.0 (locallycompact)
08:23:41 <ph88> ski, i meant when you say there are two different runReaderT and the second being "type of the field selection/projection function"
08:34:43 <ski> ph88 : well, if you define `data Frob = MkFrob { foo :: Int,bar :: Maybe String,baz :: Int -> IO Bool }', then this declares `Frob' (or rather `MkFrob') to use record syntax, with the fields `foo',`bar',`baz' having the indicated types
08:36:02 <ski> so if you write `MkFrob { bar = ...,foo = ...,baz = ... }', the types of these expressions `...' will have to be the listed types above. and similarly if you use record update syntax, like `myFrob { foo = newFoo }'
08:36:48 <ski> but if you just use the field names, in other contexts, they actually work as field extraction functions, of types `foo :: Frob -> Int',`bar :: Frob -> Maybe String',`baz :: Frob -> Int -> IO Bool'
08:37:56 <ski> imho, it would have been better if there'd been so additional piece of syntax, marking the field extraction functions. like maybe `#baz :: Frob -> Int -> IO Bool', prefixing a `#' to indicate the extraction function (SML does this)
08:40:49 * hackage path-dhall-instance 0.1.0.0 - ToDhall and FromDhall instances for Path.  https://hackage.haskell.org/package/path-dhall-instance-0.1.0.0 (locallycompact)
08:51:48 * hackage vulkan-utils 0.1.2 - Utils for the vulkan package  https://hackage.haskell.org/package/vulkan-utils-0.1.2 (jophish)
09:23:35 <AWizzArd> Using Cabal 2.4.1.0 I specified version 0.1.0 in .cabal and got    Warning: foo.abal:0:0: Version digit with leading zero. Use cabal-version: 2.0 or later to write such versions.
09:23:44 <AWizzArd> abal => cabal
09:25:35 <c_wraith> what cabal-version value do you have in the .cabal file?
09:25:48 <AWizzArd> c_wraith: I left that out. Will try it with.
09:26:05 <c_wraith> I mean, the message is explicitly telling you to set it to 2.0 or higher...
09:26:13 <AWizzArd> c_wraith:   It seems I can do this   `cabal-version: >= 2`   – is that okay?
09:26:26 <AWizzArd> c_wraith: I tried to set 2.4 but it complained that this wouldn’t be possible.
09:26:30 <AWizzArd> >= 2.4
09:26:32 <c_wraith> unless you explicitly need features from a newer version, yes
09:53:49 * hackage bytestring-tree-builder 0.2.7.4 - A very efficient ByteString builder implementation based on the binary tree  https://hackage.haskell.org/package/bytestring-tree-builder-0.2.7.4 (NikitaVolkov)
10:21:19 * hackage passman 0.2.1 - a simple password manager  https://hackage.haskell.org/package/passman-0.2.1 (jlamothe)
10:30:19 * hackage zettelkast 0.2.0.0 - Command-line utility for working with zettelkast files  https://hackage.haskell.org/package/zettelkast-0.2.0.0 (MasseR)
10:41:28 <AWizzArd> In Emacs (trying to use the Haskell Language Server) I run a shell in which I run `cabal new-repl`. When loading a file in there I see      These modules are needed for compilation but not listed in your .cabal file's other-modules
10:41:38 <AWizzArd> Yet I do have those modules listed.
10:42:50 <AWizzArd> It probably has nothing to do with the HLS. It’s just my interaction with Cabal I guess.
10:43:57 <AWizzArd> How can I convince Cabal 2.4.1.0 to stop printing this warning inside a `cabal new-repl` when trying to `:l Foo`? It tells me that Foo is not listed in other-modules, but my .cabal file has Foo as an entry there, in that section.
10:52:03 <AWizzArd> I only have an Executable section defined, and multiple .hs files. Is that a correct setup for Cabal?
10:52:21 <AWizzArd> Or should I have only my Main.hs under `Executable` and move everything else into a `Library`?
10:53:09 <sm[m]> AWizzArd: either is fine
10:53:32 <sm[m]> re that warning, I think that's a known cabal bug, you'll find it in the issue tracker
10:54:15 <AWizzArd> sm[m]: so even with this setup of having three .hs files, all under src/ and only having an `executable` section – this should allow me to use the repl without the `missing-home-modules` warning?
10:54:21 <sm[m]> at least, there is a situation in which it gives a similar warning, not sure if it's the same
10:55:12 <sm[m]> heh I put my foot in it
10:56:39 <sm[m]> @where pastecabalstack perhaps, AWizzArd 
10:56:39 <lambdabot> Help us help you: at https://paste.tomsmeding.com, https://gist.github.com or https://termbin.com, please paste your failing command, full output, and .cabal, package.yaml and/or stack.yaml files
10:58:12 <monochrom> AWizzArd: "other-modules:"
10:58:18 <AWizzArd> sm[m]: https://dpaste.com/F4DZ7J7J5
10:58:34 <AWizzArd> Interestingly:  cabal new-build   accepts my other-modules.
10:59:05 <AWizzArd> I can temporarily remove one of my other-module entries and  `cabal new-build`  will complain. But when both are present then there are zero warnings.
10:59:13 <AWizzArd> Only `cabal new-repl` seems to not find them.
10:59:24 <monochrom> Ah I didn't read the whole question. I don't know.
11:02:27 <sm[m]> AWizzArd: does cabal new-repl -v  give any clues ?
11:03:11 <sm[m]> my other-modules does not have commas, maybe that's breaking it ?
11:04:46 <sm[m]> it looks like commas are optional in other-modules (though not in build-depends)
11:06:18 <AWizzArd> The -v doesn’t show anything meaningful. And with or without comma also doesn’t make the warning go away. Strange.
11:06:52 <AWizzArd> I also just tried `cabal repl`. It behaves the same was as `cabal new-repl`.
11:07:14 <sm[m]> perhaps a bug report
11:08:16 <dolio> If you're using the current cabal-install, then `cabal repl` is the same as `cabal new-repl`.
11:09:18 <AWizzArd> dolio: I am using a  cabal-install  in a pinned Nix version, where it gives me Cabal 2.4.1.0
11:09:33 <dolio> Ah, okay.
11:10:16 <AWizzArd> Maybe in some other project I will be using a newer version of Cabal and possibly that behaviour is no longer there.
11:10:47 <maerwald> why is stack so slow at cloning repos?
11:11:43 <maerwald> and: it seems to clone the same repe multiple times if you use subidrs (cabal doesn't)
11:14:29 <dolio> Well, it'd probably be good to check before bothering with filing a bug, because filing one against old versions of cabal probably won't do much.
11:20:12 <AWizzArd> dolio: Yes. It also seems to be working, and it’s just this warning that keeps appearing.
11:22:46 <CaptainFox[m]> Is this channel active?
11:22:50 <pjb> Yes.
11:22:56 <CaptainFox[m]> Awesome!
11:34:05 <sm[m]> AWizzArd: what dolio said.. I didn't know your cabal was old
11:35:46 <ddellacosta> Is there a good resource for learning about Haskell/GHC and type system properties like soundness, totality, completeness, (or lack thereof, why certain choices were made) etc.?
11:37:29 <ddellacosta> I'm not finding much in the Haskell 2010 report so far, but may be looking in the wrong place
11:38:11 <dolio> Types and Programming Languages?
11:38:35 <Rembane> +1
11:40:12 <ddellacosta> okay, I didn't think that was about Haskell in particular, but I'll take a look. I guess some of this is knowing that e.g. because it uses Hindley Milner it has specific properties? I was just hoping to find something that discusses this stuff in the context of Haskell specifically
11:40:27 <dolio> It's not about Haskell.
11:42:23 <Rembane> It has a Haskell appendix though, but the things it discusses are true for Haskell too
11:45:35 <dolio> If you want to know about choices made for GHC, there are lots of papers about the ways the type system has changed. But it likely requires background to read them.
11:45:54 <ddellacosta> okay, fair enough. Thanks dolio and Rembane 
11:46:15 <dolio> And the background required is more general than just Haskell/GHC.
11:46:21 <Rembane> ddellacosta: No worries, good luck! 
11:53:46 <AWizzArd> sm[m]: I think the "solution" for this current project is    ghc-options: -fno-warn-missing-home-modules
11:54:12 <AWizzArd> ghci seems to care about that one :)
12:05:09 <Enrico63> Hello, I've installed `haskell-language-server` and set things up in Vim for having completions. However I'm not sure how to take advantage of that. Maybe the language server is simply not meant to be useful for completion? Please, give a look at this short screencast: https://asciinema.org/a/Hce9ZH3iRdOUg1wDkuicMNLqy
12:21:31 <sm[m]> great!
12:28:34 <zrythm159> www.indocron.net
12:39:13 <argent0> Hi, can somebody explaime what this code does? https://bpa.st/75QWALMVSHDRTW6SR2ASAHI53E. In particular, is line 4 a guard? Seems to match the case level == 1 but what about the `variant == PlainText` part. What about line 8, 19 and 21. Is the ViewPatterns extions at work here?
12:40:35 <cohn> is there a version of Data.Map that doesn't return a Maybe?
12:40:39 <Rembane> argent0: Yes, it's a case expression with guards, quite neat. It's defined for Haskell 98, let me find the relevant section of the report for you.
12:40:52 <Rembane> cohn: Which operations do you want to have no Maybe for?
12:41:31 <cohn> Rembane: I'm creating an enumeration of the characters of the alphabet and need to look up a character and get the Integer associated
12:41:51 <cohn> so, e.g. `lookup 'a' -> 1`, etc...
12:42:14 <Rembane> argent0: I didn't find any name, but it's in 3.13: https://www.haskell.org/onlinereport/exps.html
12:42:26 <argent0> Rembane: ok, thanks
12:42:43 <Rembane> argent0: No worries. 
12:43:07 <Rembane> cohn: So, if I do a lookup 'A', how will you handle that?
12:43:47 <cohn> convert to lowercase since it's case-insensitive
12:43:47 <argent0> cohn: may want to try Array Char Int
12:44:47 <cohn> good point since I don't need lazy evaluation
12:44:55 <cohn> :q
12:44:56 <cohn> bah
12:45:04 <Rembane> cohn: ord in Data.Char might be useful too
12:45:35 <cohn> Rembane: true, thanks!
12:45:37 <archaephyrryx> if I have a list of strict bytestrings and I want to join them and also apply a word8->word8 map over the result, is it better to apply the transformation over the list elements and join, or to join and then transform?
12:46:23 <Guest18> Can anybody help me with a little problem i have regarding an implementation of the filter function?
12:46:34 <Rembane> Guest18: Shoot! 
12:46:34 <archaephyrryx> Guest18: over which type?
12:46:44 <Guest18> Any type, I guess
12:46:57 <archaephyrryx> I am assuming lists
12:47:20 <Guest18> So my thinking was, i use pattern-matching to split into head and tails
12:47:23 <Guest18> yes, lists
12:48:44 <Guest18> then i check to see if the head satisfies the predicate. If it does, keep it to the list and filter the tail, otherwise just filter the tail
12:49:18 <Guest18> the tutorial i am following added a little thing though
12:49:22 <Enrico63> (I'm pasting my own message from 1h ago, maybe that was not the right time of the day...) Hello, I've installed `haskell-language-server` and set things up in Vim for having completions. However I'm not sure how to take advantage of that. Maybe the language server is simply not meant to be useful for completion? Please, give a look at this short
12:49:23 <Enrico63> screencast: https://asciinema.org/a/Hce9ZH3iRdOUg1wDkuicMNLqy
12:50:12 <Guest18> archaephyrryx:  he added a case in which it gets an empty list, as an edge case, and returns an empty list
12:50:28 <Guest18> so the recursion ends 
12:50:47 <Guest18> but as far as i can tell, my version behaves okay without that case
12:50:59 <ski> show your code ?
12:51:08 <Guest18> and i am wondering if it's necesarry and my function will break at some point
12:51:10 <archaephyrryx> Guest18: the pattern match is irrefutable if you don't have a case that isn't matched by (x:xs)
12:51:33 <Guest18> filter' :: (a -> Bool) -> [a] -> [a]
12:51:33 <Guest18> filter' f (x:xs)
12:51:34 <Guest18>   | f x == False = filter' f xs
12:51:34 <Guest18>   | otherwise = x : filter' f xs -- my code
12:51:50 <archaephyrryx> Guest18: unless you are working with infinite lists your code will run into a [] and fail
12:51:51 <Guest18> his code added this: filter _ [] = []
12:52:11 <ski> > let filter' :: (a -> Bool) -> [a] -> [a]; filter' f (x:xs) | f x == False = filter' f xs | otherwise = x : filter' f xs in filter' even [0,1,2,3,4,5,6,7]
12:52:13 <lambdabot>  [0,2,4,6*Exception: <interactive>:3:43-119: Non-exhaustive patterns in funct...
12:52:51 <Guest18> so it's not an edge case?
12:53:03 <ski> it's a termination case, when to stop looping
12:53:07 <yushyin> Enrico63: https://paste.xinu.at/2EnyX1/ looks like this to me with vim-lsp + set omnifunc=lsp#complete the rendering of the popup-preview sucks.will have to fix that but no time yet.
12:53:09 <ski> > let filter' :: (a -> Bool) -> [a] -> [a]; filter' f (x:xs) | f x == False = filter' f xs | otherwise = x : filter' f xs in filter' even []
12:53:10 <ph88> hey guys, what's the best way to use stack with private packages ??
12:53:12 <archaephyrryx> Guest18: as a side note you don't actually need the '== False' bit, you just need to swap the guard RHS
12:53:12 <lambdabot>  *Exception: <interactive>:3:43-119: Non-exhaustive patterns in function filter'
12:53:36 <lyxia> ph88: use the extra-deps field of stack.yaml?
12:53:45 <ski> yes, it's more idiomatic to say `not (...)' rather than `... == False'. but here you can just flip the order
12:54:08 <ph88> lyxia, then pointing to what ?
12:54:33 <ski> Guest18 : you could say it's an edge case, if you want to. but it's a necessary case, to have a complete definition, that will work as expected for any input
12:54:36 <glguy> ski: not ... == True? :nod: ;)
12:54:47 * ski smirks
12:56:05 <Guest18> archaephyrryx: can you clarify what 'swapping the guard' means? Still a beginner, took up haskell a week ago
12:56:42 <archaephyrryx> 'filter f (x:xs) | f x = x : filter xs | otherwise = filter xs'
12:56:47 <ski> Guest18 : changing the order of the two cases (don't keep element / keep element), and adjusting the guard conditions accordingly
12:57:33 <archaephyrryx> you would still keep the 'f _ [] = []' though to make the pattern match complete
12:57:37 <Enrico63> yushyin, sorry for the dumb question, but is `vim-lsp` an alternative to youcompleteme (if you know it) or something that can be leveraged by it?
12:57:46 <archaephyrryx> sorry, 'filter _ [] = []' (not f)
12:58:53 <Guest18> ah, so i remove the False because f is already a predicate and returns Bool
12:58:59 <archaephyrryx> exactly
12:59:13 <archaephyrryx> and you would just adjust the logic accordingly
12:59:56 <yushyin> Enrico63: just minimal vim-script only LSP client for vim. more of an alternative to YCM
13:00:08 <Guest18> yes, because now it will return true and it needs to keep the element
13:00:38 <Guest18> i mean, if it returns true
13:00:46 <Guest18> i got it, thanks!
13:01:22 <ski> generally, you don't need to compare things with `False' or `True'
13:01:37 <ski> either use the condition directly, or negate it
13:02:11 <Guest18> bad habit from imperative programming i guess
13:02:26 <ski> it's also considered bad style, in imperative programming :)
13:02:50 <archaephyrryx> i was about to say, booleans are booleans are booleans
13:03:03 <archaephyrryx> even when they aren't strictly typed
13:03:18 <ski> anyway, if you have some argument function, that returns a `Bool'ean, then it's quite common to call it `p' (for "predicate" or "property") instead of `f'
13:03:19 * hackage persistent-template 2.9 - Type-safe, non-relational, multi-backend persistence.  https://hackage.haskell.org/package/persistent-template-2.9 (MaxGabriel)
13:03:39 <Guest18> depends who you ask, i find it a little more readable i guess, especially when negating. I would much rather see 'if (condition == false)' than 'if (!condition)'
13:03:59 <ski> i'd rather see the latter
13:04:10 <Guest18> to each their own :)
13:04:37 <Guest18> i sometimes miss the little ! and it becomes infuriating
13:04:52 <Guest18> maybe i need to change the font 
13:05:14 <archaephyrryx> in C where non-zero values are true-ish and zero is false-ish, it would be awkward to explicitly test equality
13:05:34 <archaephyrryx> "!(!x) = 1" just looks bad
13:05:45 <ski> (also, please don't use `if' where one branch is `False' or `True'. use logical operations like `&&' and `||' instead (possibly with `not', if required). also applies for guards)
13:06:04 <koz_> Where can I find some information on the structure of a cabal.project file?
13:06:05 <archaephyrryx> "!(!x) == 1" is what I meant, i did the bad thing
13:06:22 <ski> archaephyrryx : could be Java or C# or something
13:06:50 <Guest18> archaephyrryx: i rarely program in C nowadays, mostly C# now
13:07:02 <yushyin> koz_: https://cabal.readthedocs.io/en/3.4/cabal-projectindex.html#cap-cabal.project%20fields
13:07:11 <koz_> yushyin: Thanks!
13:07:39 <Guest18> anyhoo. i am off! thanks for the help
13:07:42 <Guest18> :q
13:07:44 <ski> yw
13:08:10 <yushyin> (this is not vim :P)
13:08:15 <lyxia> ph88: pointing to the directory containing a package
13:08:43 <koz_> Also, phadej: does cabal-fmt handle cabal.project files as well?
13:10:20 <archaephyrryx> returning the the question I asked a while ago, does the order of intercalate and map on [ByteString] (strict) affect performance meaningfully
13:10:24 <maerwald> koz_: all this trouble, just because someone didn't pick a common format, such as toml...
13:10:37 <monochrom> Clearly, guards are better than both "if condition then else" and "if not condition then else".
13:10:40 <koz_> Also, for the subdir field of source-repository-package, can I have multiple things, or can it only be one?
13:11:53 <monochrom> guards are the closest to what David Parnas promotes for "explicitly enumerate all cases and what to do respectively"
13:12:23 <monochrom> (for example in his SCR)
13:12:34 <koz_> monochrom: SCR?
13:15:18 <yushyin> maerwald: yeah or XML!
13:15:35 <maerwald> loo
13:16:19 <maerwald> <comment>I used openbox window manager once, which has XML config format </comment>
13:17:07 <yushyin> wrong syntax for comments!
13:26:04 <jtojnar> is it possible to have a function `Applicative f => f (a -> b -> c) -> f (a, b) -> f c`?
13:26:17 <jtojnar> I can only come up with a definition using Monad
13:26:19 <dolio> Yes.
13:30:20 <jtojnar> oh, fmap uncurry
13:45:48 * hackage uniqueness-periods-vector-common 0.4.0.0 - Generalization of the dobutokO-poetry-general package functionality  https://hackage.haskell.org/package/uniqueness-periods-vector-common-0.4.0.0 (OleksandrZhabenko)
13:48:56 <ski> jtojnar : not `fmap'
13:51:23 <hekkaidekapus> @type (<*>) -- jtojnar
13:51:25 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
13:55:49 <jtojnar> @type (<*>) . (fmap uncurry) -- I meant this, ski
13:55:51 <lambdabot> Applicative f => f (a -> b1 -> b2) -> f (a, b1) -> f b2
13:56:05 <ski> @type liftA2 uncurry
13:56:06 <lambdabot> Applicative f => f (a -> b -> c) -> f (a, b) -> f c
14:00:03 <jtojnar> oh, that is even nicer, thanks. I misread liftA2 signature and prematurely discarded it
14:00:24 <hekkaidekapus> @src liftA2
14:00:24 <lambdabot> liftA2 f a b = f <$> a <*> b
14:00:41 <ski> @src (<$>)
14:00:42 <lambdabot> f <$> a = fmap f a
14:01:31 <hekkaidekapus> jtojnar: As you see, you can define (<*>) using liftA2 and vice versa.
14:03:06 <hekkaidekapus> That’s what `:info Applicative` is telling you when you see `{-# MINIMAL pure, ((<*>) | liftA2) #-}`.
14:03:18 <ddellacosta> this is still "state of the art" wrt Haskell's type system currently, right? I mean, leaving aside how extensions may affect it
14:03:20 <ddellacosta> https://stackoverflow.com/a/25255551
14:04:04 <jtojnar> yeah, I literally wrote the definition of liftA2 before transforming it to pointfree form
14:06:17 <jtojnar> I love how rich the libraries are
14:06:19 <ddellacosta> this is a nice pattern
14:06:21 <ddellacosta> > (\a b -> if (a > b) then a else b) <$> Just 2 <*> Just 1
14:06:24 <lambdabot>  Just 2
14:06:58 <ddellacosta> stupid example but you get the drift
14:07:18 * hackage uniqueness-periods-vector-general 0.4.4.0 - Some kind of the optimization approach to data inner structure.  https://hackage.haskell.org/package/uniqueness-periods-vector-general-0.4.4.0 (OleksandrZhabenko)
14:16:19 * hackage uniqueness-periods-vector-examples 0.7.0.0 - Usage examples for the uniqueness-periods-vector series of packages  https://hackage.haskell.org/package/uniqueness-periods-vector-examples-0.7.0.0 (OleksandrZhabenko)
14:31:19 * hackage uniqueness-periods-vector-examples 0.7.1.0 - Usage examples for the uniqueness-periods-vector series of packages  https://hackage.haskell.org/package/uniqueness-periods-vector-examples-0.7.1.0 (OleksandrZhabenko)
14:37:19 * hackage network-types-icmp 1.0.0.0 - Types for representing ICMP and ICMPv6 messages.  https://hackage.haskell.org/package/network-types-icmp-1.0.0.0 (adamflott)
14:37:25 <cohn> is there a function to get the fractional part of a double?
14:37:35 <cohn> so, e.g. 4.47 -> 0.47
14:37:48 <dolio> > mod' 4.47 1.0
14:37:50 <lambdabot>  0.46999999999999975
14:38:17 <cohn> dolio: thanks
14:38:59 <cohn> dolio: where does `mod'` live? It doesn't appear to be in Prelude
14:39:36 <dolio> I forget exactly. Maybe Data.Fixed.
14:39:44 <ddellacosta> yeah ^
14:39:44 <cohn> dolio: yea, that's what Hoogle says
14:39:52 <monochrom> I think properFraction is the more common way.
14:39:56 <dolio> Even though it operates on floating point numbers.
14:40:00 <monochrom> > properFraction 4.47
14:40:02 <lambdabot>  (4,0.46999999999999975)
14:40:28 <dolio> Oh, yeah, that's probably better.
14:41:25 <dolio> mod' is probably using properFraction with additional arithmetic or something.
14:42:13 <monochrom> But mod' is very useful and general when it is like "the remainder after taking out integral chunks of pi" :)
14:42:58 <dolio> I guess it isn't, but it looks like mod' is more complicated.
14:45:06 <monochrom> In retrospect with hindsight, mod' would be provided in Prelude along with all the other common arithmetic operations. Because even common floating point hardware has an instruction for it.
14:45:58 <dolio> Yeah, that'd be nice. It looks like mod' isn't actually using that, unless there are some rewrite rules.
14:47:43 <monochrom> Ah, I cited hardware just for some kind of evidence for "it is a frequently wished-for thing".
15:05:24 <dansho> what do i need to install on linus mint to run ghcup?
15:05:43 <dansho> im getting libtinfo cant load shared library, but its installed
15:05:57 <Uniaika> ah, maybe conflicting libraries?
15:06:11 <hpc> a particular version it's expecting?
15:06:12 <Uniaika> dansho: here, ghcup is a statically-linked executable
15:06:25 <Uniaika> dansho: what is the result of `ldd /path/to/ghcup` ?
15:07:13 <amf> anyone have an example of using hpack's conditionals to support multiple ghc versions? getting my feet wet with travis/github actions
15:07:32 <Uniaika> amf: yes, 2sec
15:07:52 <dansho> Uniaika, there is no executable, i run `curl --proto '=https' --tlsv1.2 -sSf https://get-ghcup.haskell.org | sh`
15:07:58 <Uniaika> amf: https://github.com/Kleidukos/irssi-hs/blob/master/package.yaml#L64
15:08:08 <Uniaika> ah so you don't have an executable *yet*
15:08:15 <Uniaika> dansho: may we have a full log of the operation?
15:10:00 <maerwald> dansho: which mint version?
15:10:51 <int-e> dansho: AIUI, that'll download a ghcup executable and put it into ~/.ghcup/bin
15:11:14 <amf> Uniaika: thanks! it looks like you cant do anything too fancy though, for instance i wanted to support 3 ghc versions, but i would likely have to list out all ghc flags
15:11:19 <dansho> Uniaika, here's the last bit, https://hastebin.com/yicicosagu
15:11:44 <maerwald> dansho: try this: ~/.ghcup/bin/ghcup install ghc -u https://downloads.haskell.org/~ghc/8.8.4/ghc-8.8.4-x86_64-fedora27-linux.tar.xz 8.8.4
15:11:56 <Uniaika> amf: my stance on complicated YAML is that it can be easily generated from Dhall :P
15:12:10 <dansho> maerwald, Linux Mint 20
15:12:21 <amf> Uniaika: yeah I just saw the GH actions in dhall. Going to steal that when I get a chance
15:12:23 <Uniaika> but don't be shy to use Cabal + Nix with stack!
15:12:30 <Uniaika> :3
15:13:44 <amf> baby steps. scars still healing from cabal hell.. but nice to see v1 commands getting an RFC to be dropped
15:14:12 <dansho> `ldd .ghcup/bin/ghcup` "not a dynamic executable"
15:14:25 <maerwald> dansho: did you run the above command?
15:17:51 <dansho> maerwald, it seems to have worked, i dont have ghc on path though
15:17:55 <dansho> do i need to add .ghcup/bin?
15:18:08 <maerwald> dansho: now rerun the original curl command
15:20:31 <dansho> maerwald, works now, ty =)
15:21:19 <Uniaika> < amf> baby steps. scars still healing from cabal hell.. // oh yeah but stack would still be in charge
15:21:32 <Uniaika> in the end, hpack only generates a cabal file for you
15:23:50 <maerwald> dansho: can you try to install 8.10.2 via: ghcup install ghc 8.10.2
15:23:54 <maerwald> I wanna now if that works now
15:26:18 * hackage network-types-icmp 1.0.0.1 - Types for representing ICMP and ICMPv6 messages.  https://hackage.haskell.org/package/network-types-icmp-1.0.0.1 (adamflott)
15:35:43 <sm[m]> @where+ haskell-via-sokoban https://haskell-via-sokoban.nomeata.de
15:35:43 <lambdabot> Done.
15:35:53 <sm[m]> @where+ haskell-for-readers http://haskell-for-readers.nomeata.de
15:35:53 <lambdabot> Good to know.
15:42:19 * hackage cpkg 0.2.5.7 - Build tool for C  https://hackage.haskell.org/package/cpkg-0.2.5.7 (vmchale)
15:54:49 * hackage ordinal 0.1.0.0 - Convert numbers to words in different languages.  https://hackage.haskell.org/package/ordinal-0.1.0.0 (wvanonsem90)
15:55:07 <Guest26> hello. i am interested in trying to implement, or use some implementation of an "actors" model within haskell
15:55:30 <Guest26> i have done some research and found something called "spores". has anyone heard of this or understand how it works?
15:56:40 <Guest26> i find reference to it here; https://www.google.com/url?sa=t&rct=j&q=&esrc=s&source=web&cd=&ved=2ahUKEwiOusSB-YzsAhUDmeAKHQrMBFgQFjACegQIAxAB&url=https%3A%2F%2Finfoscience.epfl.ch%2Frecord%2F191239%2Ffiles%2Fspores_1.pdf%3B&usg=AOvVaw31y2yhZIcvKUnAiBeqIPQN
15:57:16 <Guest26> thats the pdf. the permalink to the abstract is here; https://link.springer.com/chapter/10.1007/978-3-662-44202-9_13
15:58:33 <Guest26> as i understand it, its not available within haskell since it constitutes an extended type system
15:58:56 <Guest26> are there options available to the haskell community that provide something similar?
15:59:20 <Guest26> how far towards polymorphic actors can we achieve within the existing type system?
15:59:37 <Guest26> how limited are existing actors model libraries in haskell?
16:01:37 <Guest26> im not sure if this is similar, but google suggests it in relation to spores; https://www.microsoft.com/en-us/research/wp-content/uploads/2016/07/remote.pdf
16:03:00 <Guest26> i can find; https://hackage.haskell.org/package/simple-actors-0.4.0/docs/Control-Concurrent-Actors.html
16:03:34 <Guest26> but it is unclear how far towards the "closures" idea that spores seems to be centred on 
16:04:03 <Guest26> it seems like it has some functionality such as adding actors as if it were adding "edges"
16:04:17 <Guest26> is it wrong to think of actors models as being graph based?
16:26:49 <koz_> I need to use attoparsec to parse the equivalent of 'one of N possibilities, possibly followed by one of M possibilities'.
16:27:16 <koz_> Is there a way I can spell a parser like that, assuming they all parse to the same thing?
16:27:45 <koz_> (or rather, the same type of thing)
16:29:38 <glguy> liftA2 (,) (asum xsN) (optional (asum ysM)) ?
16:30:00 <koz_> glguy: xsN is like, a list of Parsers?
16:40:18 * hackage ordinal 0.1.1.0 - Convert numbers to words in different languages.  https://hackage.haskell.org/package/ordinal-0.1.1.0 (wvanonsem90)
16:45:41 <dansho> maerwald: `ghcup install ghc 8.10.2` said it was successful, but ghc --version still shows 8.8.4
16:46:51 <koz_> :t ($>)
16:46:53 <lambdabot> error:
16:46:53 <lambdabot>     • Variable not in scope: $>
16:46:53 <lambdabot>     • Perhaps you meant one of these:
16:47:02 <koz_> dansho: I think you gotta switch up your environment.
16:47:13 <koz_> Or manually specify with -w ghc-8.10.2.
16:47:34 <monochrom> That one you can use "ghcup set 8.10.2" or something to set.
16:47:44 <ski> @hoogle ($>)
16:47:45 <lambdabot> Data.Functor ($>) :: Functor f => f a -> b -> f b
16:47:45 <lambdabot> Data.Functor.Compat ($>) :: Functor f => f a -> b -> f b
16:47:45 <lambdabot> Data.Functor.Apply ($>) :: Functor f => f a -> b -> f b
16:48:08 <monochrom> Generally take a look at "ghcup --help" for what it can do for you.
16:48:22 <monochrom> Along the way, discover that "ghcup tui" is really handy.
17:22:38 <sepi> Can I have a helper function used and defined within 'if' bounds? 
17:22:43 <sepi> |
17:23:04 <Axman6> wut
17:23:51 <ski> with `let', yes
17:24:14 <ski> but perhaps you mean guards, not `if' ?
17:25:21 <sepi> ah yes guards
17:26:03 <ski> you can put a `where' after the guards, and things defined inside the `where' will be in scope in the guard conditions, as well as the branches
17:33:42 <sepi> Besides possibly the d case, am I in the right area for doing this? https://dpaste.org/DbEh
17:36:16 <Axman6> well, you can't define equality on functions, so that d `elem` q is never going to work
17:36:33 <Axman6> and sigma is a list, so you can't apply it to x and xs
17:36:57 <Axman6> it also looks like this function can never do anything but return true
17:37:17 <monochrom> "my heart is always true" :)
17:37:31 <Axman6> "or I will never return"
17:39:03 <sepi> I had the thought that because of elem, if s is never in qs then it'd come out false
17:39:56 <Axman6> I have no idea what's going on with this code, it's quite a long way from being syntactically valid
17:41:42 <Axman6> you might ant to look at functions like all, and, or, any, intersect. you might also find writing a function isSubsetOf :: Eq a => [a] -> [a] -> Bool is very useful
17:42:29 <Axman6> isSubSetOf [] [1,2,3] -> True, isSubsetOf [4] [1,2,3] -> False, isSubSetOf [1,2] [1,2,3] -> True
17:42:58 <xsperry> > isSubsetOf [1,3] [1,2,3]
17:43:00 <lambdabot>  error:
17:43:01 <lambdabot>      • Variable not in scope: isSubsetOf :: [a0] -> [a1] -> t
17:43:01 <lambdabot>      • Perhaps you meant one of these:
17:43:11 <xsperry> huh, nm
17:43:24 <Axman6> Data.List happens to already have isSubsequenceOf, which would work if your states were ordered
17:44:52 <Axman6> > isSubsequenceOf "GHC" "The Glorious Haskell Compiler"
17:44:55 <lambdabot>  True
17:46:44 <Axman6> sepi: what is let d xs ys =  q <> (sigma (x)) : d q (sigma xs) supposed to be doing?
17:48:49 * hackage cabal-auto-expose 0.1.0.1 - Build time library that autodetects exposed modules  https://hackage.haskell.org/package/cabal-auto-expose-0.1.0.1 (deech)
17:49:33 <sepi> was it at least a good idea to do q:s and f:fs for those variables. Supposedly can't use any modules 
17:51:47 <Axman6> I don';t understand the question
17:53:32 <Axman6> I think you're trying to do too much at once - I would split the checks you need to do out in a where clause and check each thing individually
17:55:11 <Axman6> like I said, start by defining a function which checks if all elements of one list are contained in another, then checks (2) and (3) are trivial
17:57:15 <ski> the `let' is shadowing the `d' input with another locally defined function called `d'
17:59:39 <ski> it also seems to me like this is better written without guards
17:59:52 <Axman6> absolutely
18:00:14 <sepi> where x /= xs, test ( next elements in xs, s, fs, d) ? 
18:00:16 <ski> (but if you really want to, i guess you could use them .. but it'd be unidiomatic)
18:00:56 <ski> sepi : what is that supposed to check ?
18:02:03 <sepi> I want to check if the states in xs are all unique 
18:02:26 <ski> how about defining a separate function for checking that ?
18:02:57 <ski> it seems you're trying to do too many things at the same time, in `checkFSM', and confusing them up with each other
18:03:32 <sepi> checkFSM call all the functions or functions would be defined inside?
18:03:52 <ski> "wishful thinking" can be useful, when programming. imagine you had a function that could check whether a list had no duplicates. then you could use that function to check one of your conditions for `checkFSM'
18:04:42 <ski> you could either put off defining that function for later (after writing a bit of `checkFSM', perhaps all). or you could start by defining this helper function, and then come back to `checkFSM', to use it there
18:05:20 <ski> you could either define such a helper function, inside a `where'-clause for `checkFSM'. or define it separately, in your module
18:05:39 <ski> (with the latter option, you could test it out on its own, in the interactor)
18:07:03 <ski> anyway, if you'd like to try this, you'd then have to do one of the harder things in programming .. namely invent some suitable name, for this helper function
18:08:17 <Axman6> I already did some of that work, with isSubsetOf above
18:19:21 <sepi> https://dpaste.org/taJt#L1,3
18:19:26 <sepi> my mind still goes elem
18:19:50 <sepi> except I should've put notelem
18:20:30 <ski> what is the intent of `go' ?
18:23:02 <sepi> use that to check my first case to see if qs has no duplicates is what I was thinking
18:23:43 <ski> that doesn't explain specifically what behaviour `go' is intended to have
18:25:04 <ski> perhaps if you'd have a suggestion for how you'd want to call `go' from `checkFSM', that might clarify it a bit ?
18:25:53 <Axman6> ski: go only checks if a single element is contained in another list, it is _exactly_ the same as elem
18:25:58 <Axman6> uh, sepi
18:26:13 <ski> (or else, if you prefer, you could tell what `go' is supposed to check/compute, given inputs, without referring to how you might then use that in `checkFSM')
18:27:14 * ski isn't bothering with the (current) implementation of `go', so far, at most taking the type signature of it into account
18:29:36 <Axman6> sepi: I've said a few times now you should try to write a function with the following type: Eq a => [a] -> [a] -> Bool, which returns true if all the elements in the first list are contained in the second list. what do you think the base case of this function should be?
18:36:14 <Axman6> sepi: do you understand that f ... | x = True | otherwise = False is the same as just f ... = x? "If x is true return true, otherwise x must be false so return false"
18:37:57 <sepi> I suppose the base case would be if it were comparing list1to list2 which is empty it'd return false?
18:38:26 <Axman6> why false?
18:38:48 <Axman6> the empty set is a subset of all sets isn't it?
18:39:07 <Axman6> are all the elements of [] in [1,2,3]?
18:40:37 <sepi> ah yes I was already thinking of it backwards are all elements of [1,2,3] in []
18:42:17 <sepi> for the guards I was using them because it was the only way I thought of going through all the cases at once. But I doing if, elif, elif instead it looks like
18:43:56 <Axman6> sepi: have you tried to write the function I suggested?
18:45:04 <sepi> could it work like, checkFSM (qs, [], [], []) = define func.....([], s, [], []) = define function
18:45:07 <sepi> for seperation
18:45:16 <sepi> I'll do the one you were talking about now
18:45:38 <Axman6> sepi: look, if you want help, you need to listen to the help we give. if you're going to ignore it, then I'll go and do something else, it's not worth my time
18:47:10 <Axman6> we're trying to steer you in the right direction, but you keep getting distracted. no, I don't think that will work, this isn;t something that makes sense to do by traversing the lists all at the same time. break the problem down into smaller problems like we've said, and then combine the results
18:48:53 <Axman6> your final function will probably look something like: checkFSM (qs, s, fs d) = uniqueStates && startIsValid && finalsAreValid && transitionsAreValid where uniqueStates = ...; startsAreValid = ...
18:50:55 <ski> sepi : have you used `&&' before ? do you know what it means ?
18:59:08 <sepi> Haskell doesn't speak to me too well which is why I take forever my bad
18:59:35 <sepi> Yes it would mean statement one and statement two both have to meet the condition
19:01:07 <ski> yes, `&&' expresses a logical "and". `foo && bar' means that both `foo' and `bar' have to be `True', in order for the result of the whole `foo && bar' to be `True'. if either (or both) of them are `False', then the whole will be `False'
19:03:19 <ski> sepi : .. i'm still wondering what you wanted `go' to express
19:03:55 <ski> or if you got any further, with the function that Axman6 suggested you could define
19:14:45 <sepi> Its looking like are elements in list a, are in the full set of b 
19:15:12 <ski> what is `a' and `b' there ?
19:16:44 <sepi> https://dpaste.org/gje6#L1,3
19:17:08 <sepi> https://learnstack.in/assets/ppt/ppt_img/python-subset.jpg 
19:17:25 <ski> what is `test a b' supposed to compute/test/check ?
19:17:27 <sepi> that function is doing this which is checking if a is in a subset b
19:18:00 <sepi> *if 'a' is a subset of 'b'
19:18:21 <ski> the name `test' (nor the name `go') doesn't give much hint about what it's supposed to be testing
19:18:27 <ski> ok
19:19:12 <ski> maybe you could invent some more descriptive name, for this function, giving some more hint about what it's supposed to do ?
19:19:41 <Axman6> > all (const False) []
19:19:43 <lambdabot>  True
19:20:27 <Axman6> sepi: Did you write that function yourself? can you explain to us how it works?
19:22:31 <Axman6> I'm asking because if I were your lecturer or tutor, and I saw checkFSM and test in the same file, I would be very suspicious that test was copied from somewhere because it shows a much better understanding of Haskell than checkFSM does
19:25:31 * ski idly wonders whether sepi has tested `test [1,2,3] []'
19:27:35 <sepi> it is now called isSubsetOf, with 'all' it'll return true if all items in list meet the condition. so its taking the condition (elem b) and applying it to the 'a' list
19:29:28 <ski> and what about `isSubsetOf [1,2,3] []' ?
19:30:31 <sepi> I suppose it should be isSubsetOf [] b = True for first condition
19:31:54 <Axman6> is [1,2,3] a subset of [] though?
19:33:20 <sepi> no because nothing is in [], but [] is a subset of [1,2,3] because empty is in [1,2,3]
19:33:39 <ski> what will  all (`elem` b) []  evaluate to ?
19:33:44 <Axman6> does your function agree with that?
19:33:55 <sshine> if empty is in [1,2,3], what is empty?
19:34:01 <Axman6> ski: I think this does actually work btw
19:34:35 <ski> Axman6 : mm, i was on cleaning up
19:34:46 <Axman6> > let isSubsetOf xs ys = all (`elem` ys) xs in isSubsetOf [1,2,3] []
19:34:48 <lambdabot>  False
19:34:59 <Axman6> > let isSubsetOf xs ys = all (`elem` ys) xs in isSubsetOf [] [1,2,3]
19:35:01 <lambdabot>  True
19:35:04 <Axman6> > let isSubsetOf xs ys = all (`elem` ys) xs in isSubsetOf [4] [1,2,3]
19:35:07 <lambdabot>  False
19:37:41 <Axman6> > let isSubsetOf xs ys = all (`elem` ys) xs in isSubsetOf [3,2] [1,2,3] -- probably the more important test
19:37:43 <lambdabot>  True
19:42:00 <ski> > let isSubsetOf xs ys = all (`elem` ys) xs in isSubsetOf [3,2,3] [1,2,3,2]
19:42:02 <lambdabot>  True
20:03:47 <BalterNotz> hi everyone, do you know about haskell language 2020 report release date?
20:03:59 <ornxka> some time in 2020
20:08:25 <monochrom> Nothing
20:14:19 <sepi> I made a function that checks for uniqueness within a list, 2 and 3 could be checked by isSubsetOf, for transition function I think I need to take all the possible outputs of d with q <- qs and c <- sigma and then make sure all these outputs are a valid state
20:15:45 <ski> sepi : sounds like a plan
20:15:55 <ski> (show current code ?)
20:31:11 <sepi> I'm not even sure that's correct explanation for transition, conceptually I think I could write out a chart but still need to learn more to apply it to Haskell. https://dpaste.org/FQog
20:34:36 <monochrom> You have a syntax problem. You should write "isSubsetOf fs qs", not "isSubsetOf (fs qs)".
20:35:10 <monochrom> You also have a type problem. You should write "isSubsetOf [s] qs", not "isSubsetOf s qs".
20:35:35 <Axman6> sepi: why do you have the isSubsetOf a [] = True case? you're saying that all lists are a subset of the empty list, which seems wrong to me
20:36:05 <monochrom> haha I didn't catch that. Semantic problems are the best problems.
20:36:20 <ski> we already pointed that one out, before
20:36:45 <Axman6> yeah I only just realised that's what you were referring to, since the code changed when I went to look at it again
20:37:01 <ski> sepi : instead of using `if', could you reexpress that condition, using logical operators ?
20:37:04 <monochrom> Transition validty is a matter of: for all elements q of qs, for all element c of sigma, is "d q c" is an element of qs?
20:37:31 <monochrom> Since you have learned the "all" function, transition validity is a one-liner.
20:38:05 <Axman6> Everything's a one-liner if you're brave enough
20:38:17 <monochrom> Nah.
20:39:18 <monochrom> Everything is a one-liner if there are enough support functions, which in turn are one-liners in their own right, recursively down to the built-ins.
20:39:35 <monochrom> Therefore, we have the very wise and deep tautology:
20:39:48 <monochrom> Everything is a one-liner if everything is a one-liner. :)
20:41:09 <hololeap> everything is a "do" block
20:41:52 <hololeap> in the IO monad
20:42:03 <Axman6> Nah
21:09:05 <sepi> tValid :: Int -> Char -> Int -> BooltValid d q c =  all (`elem` q) qs && all (`elem` c) sigma 
21:09:20 <sepi> monochrom would this be a decent start?
21:09:58 <sepi> ski you mean other than guards correct? for the if statement
21:27:09 <benet8> on
21:27:46 <sepi> My bad got disconnected didn't realize. thanks for the assistance Haskell is a little clearer than when I woke this morning 
21:32:46 <benet8> q
21:32:50 <sim590> Is it possible to force building the package of my cabal project without downloading anythihng. I'm writing some CI script and I don't want any downloading since everything is being installed in my Docker image.
21:38:49 * hackage hls-plugin-api 0.4.1.0 - Haskell Language Server API for plugin communication  https://hackage.haskell.org/package/hls-plugin-api-0.4.1.0 (jneira)
21:39:54 <sim590> new-build --offline just doesn't work. I still see "Downloading" lines.
22:22:24 <hololeap> what's a good way to combine functions that pattern match on a sum type, so that if the first function fails to match, it moves on to the next?
22:24:08 <hololeap> i think this could be made into a monoid somehow, where mempty is a function that never matches
22:24:27 <glguy> Have the function return a Maybe result
22:24:35 <glguy> Nothing for no match, Just result for a match
22:25:18 <glguy> then you can take the first result that was a Just
22:25:22 <hololeap> ah, or a Maybe (First a), which would fufill my monoid wishes
22:25:46 <glguy> Instead of Monoid you can use Alternative
22:26:05 <glguy> If you want to use First, just use First; you don't need the extra Maybe in that case
22:27:01 <hololeap> what would i do if the entire thing returned a Nothing? ideally it would pass through the normal error about failing a pattern match
22:27:40 <glguy> There's no failing pattern matches
22:28:06 <glguy> You'll have all complete patterns; some will return Nothing
22:28:49 <hololeap> in this case, the Maybe has to be discarded before it is passed along
22:29:36 <hololeap> i'm looking at appHandleEvent from Brick.Main
22:30:51 <hololeap> i would like to have a "default" where certain BrickEvent possibilities are handled, but the ability to pass in custom handlers which can handle more possibilites
22:32:04 <hololeap> oh, i think i see the correct solution here
22:33:43 <hololeap> if the inner function returns a Nothing, then it will pass through the original state
23:13:17 <fog> do we have something like go in haskell?
23:14:29 <fog> i was watching a pretty cool talk about how it made its way into "kotlin" https://www.youtube.com/watch?v=Mj5P47F6nJg
23:15:20 <fog> erm, not the whole of go obviously, just the async await stuff
23:15:27 <fog> seemed pretty state of the art
23:15:32 <gnumonik> Is there any way to use Control.Lens to update an element of a Data.Vector vector if it's present, and insert some other element if it's not? Or is that impossible because vectors aren't sufficiently maplike for a Control.Lens.At At instance? 
23:16:31 <fog> what do you mean "if its present" - and "sufficently maplike" ?
23:17:41 <fog> im guessing you mean like Data.Map has a lookup key which is used by At
23:17:59 <fog> so you want to lens to a specific position in the vector
23:18:19 <fog> but then, what would it mean to have this "not be there"?
23:18:26 <fog> arent vectors "full"?
23:18:51 <gnumonik> er sorry, i meant an element at a given index in the vector. really i only care about the case where it's an empty vector 
23:19:44 <fog> hmm, i cant remember if vectors have fixed length... let me check the docs
23:20:42 <fog> ah, no, they are specifcally supposed to support slicing, so i guess the empty vector is like the empty list, instead of like, a fixed length vector full of undefineds or something
23:20:57 <fog> so im still not sure this "if its present" fits well with this
23:21:06 <fog> do you just mean an out of bounds accessor?
23:21:37 <fog> but then, i guess you couldnt have it "insert" at this position - basically thinking of it being listlike - so you would need all the values inbetween aswell
23:21:59 <fog> basically, no, its not suffciently maplike to insert at an arbitrary out of bounds position
23:23:38 <fog> i think you could be confusing it with something like memory addresses, where you would kind of malloc off a block, like the mutability of mvector
23:24:06 <fog> then you could have these presumably not containing any actual values. thats not how vectors work
23:24:42 <fog> is it?
23:26:40 <gnumonik> I just meant "empty" in the Data.Vector.empty sense I think? I dunno if those are empty in some deeper sense than V.null (V.empty) = True 
23:27:11 <fog> % null []
23:27:12 <yahb> fog: True
23:27:26 <fog> maybe you want https://hackage.haskell.org/package/array-0.5.4.0/docs/Data-Array.html
23:28:52 <Xnuk> what is %
23:29:11 <fog> > null []
23:29:13 <lambdabot>  True
23:29:29 <fog> see how its either lambdabot or yahb that responds
23:29:39 <fog> % is for messaging yahb
23:29:40 <yahb> fog: ; <interactive>:133:1: error:; * Variable not in scope: is :: (t2 a0 -> (a0 -> f0 b0) -> f0 (t2 b0)) -> t0 -> t1 -> t; * Perhaps you meant one of these: `C.id' (imported from Control.Category), `id' (imported from Prelude), `iso' (imported from Control.Lens); <interactive>:133:8: error: Variable not in scope: messaging; <interactive>:133:18: error: Variable not in scope: yahb
23:29:44 <fog> ...
23:29:47 <Xnuk> awesome
23:29:58 <Xnuk> > is for messaging lambdabot
23:30:01 <lambdabot>  error:
23:30:01 <lambdabot>      • Variable not in scope:
23:30:01 <lambdabot>          is :: (t2 a0 -> (a0 -> f0 b0) -> f0 (t2 b0)) -> t0 -> t1 -> t
23:30:06 <fog> yes
23:30:28 <fog> yahb is sometimes better for supporting module imports and language extensions
23:30:40 <fog> never quite sure when lambdabot is going to complain
23:32:55 <fog> gnumonik: see; https://hackage.haskell.org/package/array-0.5.4.0/docs/Data-Array-MArray.html#g:3
23:33:29 <fog> im guessing nobody online can answer about go or kotlin - ill return in a while
23:33:58 <gnumonik> I'll check it out, thanks. That might be overkill though. I read that "never use lists" article and converted a bunch of lists that will never hold more than a dozen elements into vectors because... I dunno
23:35:55 <Xnuk> https://hackage.haskell.org/package/async
23:42:51 <hc> ah, the beautiful async package. :) multithreaded programming is one of the most enjoyable things to do in haskell imho
23:51:09 <fog> hc: do you know how this compares to the "job" and "structured concurrency" notions from kotlin (discussed in the talk linked)
23:51:49 <hc> fog: kotlin in based on the java vm, so I guess they'll be using some async/await concept?
23:51:58 <fog> they have a fancy "launch" thing that somehow captures all of the scopes nicely and does error propagation in a way that is somehow good 
23:52:13 <hc> lemme check it
23:52:17 <fog> hc: argh, i cant really summarise the talk very well...
23:53:08 <fog> it was something to do with branching concurent substructures all being contained in the same kind of overall thread
23:53:30 <fog> so that errors could not "leak from the context" or something...
23:53:34 <hc> could you give me a link to the talk? i cannot find it in the backlog
23:53:46 <fog> https://www.youtube.com/watch?v=Mj5P47F6nJg
23:54:00 <hc> thx
23:54:06 <fog> "Roman Elizarov — Structured concurrency"
23:54:43 <fog> i think it was something to do with "go considered harmful" 
23:54:47 <hc> having a look at it now
23:54:50 <fog> ok
23:55:38 <hc> ah. "inspired by async/await". 2nd slide. so it cannot be good ;p
23:59:54 <fog> basically, the way im doing it atm is to just launch an exe per function - and to have these all just communicate with each other using stdio
