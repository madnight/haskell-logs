00:00:59 <fog> the problem with the idea of "structured concurrency" in this approach, is that if any of the processes are long lived, and are killed unexpectedly by some rogue sentinal process (which seems to be the case at least on the free tier of AWS)
00:01:22 <fog> where its actually really difficult to get a persistent process
00:01:42 <fog> so then, the functions have to kind of watch the threads of each other to see if one gets killed
00:02:00 <fog> and have the ability to restart the thing that watches over them if *it* gets killed
00:02:33 <fog> so the idea of having these all under one parent process is totally counterproductive, since it would result in all the processes getting killed
00:02:49 * hackage fakedata 0.8.0 - Library for producing fake data  https://hackage.haskell.org/package/fakedata-0.8.0 (psibi)
00:03:14 <fog> the real problem is that these are all done using linux threads, and i have some crude way of interfacing with top to get the thread numbers, its all a total hack
00:03:36 <fog> and that really what i want, is for some kind of haskell based representation of a graph to keep track of all of these threads
00:03:55 <fog> but then i cant reconcile the "distributed" thing, of having each of the functions running on its own exe
00:04:36 <fog> and the way of handling all of the communication structure from within one haskell program, so i can use nice representations of graphs for the function net
00:21:31 <hc> fog: ah, you were gone shortly when I said about the talk: "ah. "inspired by async/await". 2nd slide. so it cannot be good ;p"
00:21:46 <fog> hmm
00:21:58 <hc> imho the async/await is justified in some niche programming areas, but the way it's accepted as a generic paradigm is a bit scary
00:22:11 <hc> i don't consider it a feature of a high level language
00:22:12 <fog> can you elaborate?
00:22:24 <hc> you clutter your code with implementation details that should be left to the runtime
00:23:04 <fog> i guess thats why he was using kotlin - the resulting implementation managed to capture the hierarchical concurrency really neatly
00:23:20 <hc> ok, i'll have to continue with the talk :)
00:23:48 <fog> basically it ended up with it being like a tree structure with all the branching lower forked processes being under the same top node
00:24:01 <fog> which allowed for errors to be gathered 
00:24:17 <fog> and that no strange effects could escape the encapsulation 
00:24:30 <fog> but this was kind of the exact opposite of my use case
00:24:40 <fog> i cant see how that would ever work in a distributed setting
00:24:55 <fog> it seems like its just an approach to "green threads" managment - within the program itself
00:25:24 <fog> instead of as a way of scheduling genuinely parallel computations, running in different exes possibly on different machines
00:26:02 <fog> if you try and encapsulate all your threads in one runtime, then how can you ever hope to have distributed concurrency... 
00:34:16 <hc> sigh, that talk is too verbose... i need to find a PDF or something
00:36:23 <fog> hc: its not like the question actually requires an understanding of the concept of structured concurrency 
00:36:43 <fog> i dont want you to have to watch a whole talk just to get what i mean...
00:38:13 <hc> fog: i gave up anyway; I'd rather read a paper or article about the concepts
00:38:21 <fog> supposing i dont care about distributing the processes and i can just have everything in one program
00:39:06 <fog> then i can use things like the async library - and im mostly concerned with comunication "channels" and shared memory like in STM - or mutable state per "node" like in an actors model
00:40:29 <fog> hc: i dont really want to start linking a bunch of kotlin stuff here, but the author showed some blog posts he had made during the talk, so i guess you can just search his name
00:41:25 <fog> he said it was mostly inspired by this post;
00:41:26 <fog> https://vorpus.org/blog/notes-on-structured-concurrency-or-go-statement-considered-harmful/
00:41:48 <fog> or rather, thats where the phrase "structured concurrency" was taken from
00:42:23 <fog> do you know of any abstractions that capture these concepts?
00:42:33 <fog> like, STM, vs Actors etc
00:42:57 <hc> tbh, the article already makes me a bit biased by starting with a sentence like 'Every concurrency API needs a way to run code concurrently.'
00:42:57 <fog> i cant think what functions a class would have to provide to capture both of these concurrency paradigms 
00:43:31 <fog> biased?
00:44:19 * hackage orbits 0.4 - Types and functions for Kepler orbits.  https://hackage.haskell.org/package/orbits-0.4 (jophish)
00:44:26 <fog> im just concerned that while we have at least one implementation of Actors, (i havent looked into STM yet, as i dont think i need shared mutable memory)
00:44:42 <fog> that they dont satisfy an overall interface
00:44:57 <fog> im not quite sure what that would be
00:45:22 <fog> the talk basically was along the lines of "dont make a list of concurrent processes" 
00:45:59 <fog> and instead advocated them being treelike to capture ancestry in order to propagate failure and errors.  
00:46:04 <hc> wait, he has to explain to me his new control structure by starting with a history of goto? sorry, haven't got the time for that right now
00:46:45 <fog> right, dont bother with the talk, sorry - i was just trying to get the part that was important
00:47:14 <hc> i mean the article. that's just as confusing and verbose
00:47:34 <fog> there was basically some magical way the kotlin language managed to render all of the handling of this tree processes as syntax where it could wrangle the contexts
00:48:01 <nshepperd1> what concurrency API doesn't need a way to run code concurrently
00:48:12 <fog> hc: seriously, its so simple - its just a tree as opposed to a list of concurrent processes. 
00:49:18 <fog> anyway, i cant understand how to structure an API for an actors model. apparently i dont want a "node list" and so presumably i dont want an edge list either
00:49:33 <fog> i guess the idea is just to capture all that into a syntax tree
00:49:52 <fog> and that kotlin gives some fancy way to write syntax like functions or something
00:50:13 <fog> so that he could write things like keywords like "launch" or "run"
00:51:09 <fog> but basically the whole idea of "structured concurrency" was just something like having a ADT for the connectivity between calling processes 
00:52:03 <fog> ah, im confusing "comunications chanels" as edges, and this "calling processes" as parents, as branches in the syntax tree
00:52:18 <fog> i guess i should read more about mailboxes
00:59:57 <fog30> ok, so from what i can understand, it needs something like an erlang "scheduler" 
01:00:39 <fog30> otherwise its going to be a wasteful thread, just rereading an empty mailbox over and over until it receives a "message" which is some input argument to the function 
01:01:40 <fog30> im not sure how it works to do with the mailbox being listlike, so that the receipt of messages can be raced upon, and the control of which inputs to accept is then passed to the actor
01:02:27 <fog30> like it can say, "i take types of Either Int Bool, where the Ints are from this actor, and im going to process them before any of the Bools im recieving from this other actor"
01:02:33 <fog30> by "reading its mailbox"
01:02:52 <fog30> and in this way, somehow converting between being a pushed or pulled process..
01:03:09 <fog30> not sure what the termanology is - something to do with state vs costate
01:03:17 <fog30> producer vs consumer
01:03:54 <fog30> that by reading its mailbox, it decides when to respond, as opposed to being forced to respond by the thing sending messages
01:05:02 <fog30> so you dont like, supply an argument to a function, you just put it in the mailbox, and the function can decide when to operate on it - i guess essentially becoming blocking in the process
01:05:22 <fog30> but, then, there is nothing that should be waiting on it, it only ever sends messages to other mailboxes
01:05:44 <fog30> which then somehow serve like input arguments in function application syntax
01:06:00 <fog30> sounds totally mental
01:06:38 <fog30> let bound variables passed as inputs to functions would be replaced with emited messages stored in the actors mailbox  
01:07:24 <fog30> i cant see how that would work at all really! the let bound variable might not have had a value written to it yet
01:07:47 <fog30> hmm, i guess that would be the empty list, as a mailbox
01:08:01 <fog30> so it seems like all values end up being replaced by lists
01:08:28 <fog30> wierd paradigm. pretty sure thats not how the actors models we have as libraries work...
01:08:53 <fog30> seems like the kind of thing that would work really well with linear types. 
01:09:07 <fog30> then we can have messages that are like "burn after reading" 
01:09:23 <fog30> so they dont need to be garbage collected
01:15:18 * hackage nothunks 0.1.1.0 - Examine values for unexpected thunks  https://hackage.haskell.org/package/nothunks-0.1.1.0 (EdskoDeVries)
01:45:14 <fog> hmm, i have found several resources
01:45:14 <fog> https://mail.haskell.org/pipermail/haskell-cafe/2014-March/113341.html
01:45:27 <fog> this is a pretty decent thread discussing actors models
01:45:45 <fog> not really sure about erlang vs cloud haskell
01:45:55 <fog> but i like the references to different implementations of channels 
01:46:36 <fog> and different ways of scheduling, which i guess kind of makes actors basically an incomplete theory, if im not misunderstanding something 
01:46:44 <fog> seems non-deterministic at least
01:47:18 <fog> whereas you would normally want a "functions net" style implmentation with mutable state per function to be reproducable from the same initial conditions
01:47:36 <fog> basically then we end up with the same considerations about things like LVars for the channels
01:47:49 <AWizzArd> In Servant I describe my route and parameters, or the type of a json body. Now in Snap: is the way to go to fetch what is in the request and call Aeson’s `decode` manually on it?
01:47:53 <fog> and a lattice computation for the sheduling
01:48:49 <fog> but then, how would you do that sheduling? is it just a race? wouldnt it be better to have a way to demand that certain actors downstream of a let bound value can be demanded to be evaluated, or does that always result in blocking?
01:49:10 <fog> like, is this racing actors a way to avoid blocking at the expense of determinism?
01:49:42 <fog> that doesnt sound like a good idea from the tradition of pure functional programing where we require reproducibility of programs 
01:50:40 <fog> then you would need some way for this lattice of actors to have like a sat solver or something to guarantee it is free from blockages 
01:51:24 <fog> that seems like it could somehow be encoded at type level as the topology, but that would require some kind of guarantees about the functions ability to return
01:51:45 <fog> like basically, you would have it in ST or pure, so that it wasnt doing any blocking IO
01:52:33 <fog> then these "pure actors" could have network topological guaranties basically as "the shape of the program" at type level to be non-blocking by construction
01:53:22 <fog> i guess that also then gives rise to a determinable evaluation order inferred by the topology
01:54:09 <fog> but then, actors are supposed to be able to spawn new actors - so how would you have these runtime guaranties at type level
01:55:04 <fog> i guess there is proabably some deep result there about how actors, by having runtime variable topoligies, *have* to have the racing and mailboxes in order to then not require this typechecking 
01:55:47 <fog> then it seems like the fundamental problem is the reconciliation of runtime variable determinism guarantees in concurrent pure programming 
01:56:08 <fog> which sounds kind of above my pay grade 
01:56:52 <fog> maybe if i had a working actors model, i could get some simulated elves to do it...
01:57:17 <fog> all talking elvish 
02:00:57 <dminuoso> AWizzArd: getPostParam?
02:01:33 <dminuoso> Oh wait, this is something else
02:02:18 <dminuoso> snap is weird
02:02:33 <hc> why would you switch from servant to snap?
02:02:33 <AWizzArd> dminuoso: Yeah, I can fetch contents of the Request and then do with it whatever I want.
02:02:44 <hc> (just curious)
02:02:49 <AWizzArd> hc: experimentation, seeing different styles.
02:03:00 <AWizzArd> Our main service is using Servant.
02:03:08 <AWizzArd> Now for a small email service I’m trying Snap.
02:03:39 <AWizzArd> I think in Snap I need to do things a tiny bit more manually.
02:04:22 <dminuoso> AWizzArd: https://hackage.haskell.org/package/snap-core-1.0.4.2/docs/Snap-Internal-Core.html#v:getRequest
02:04:34 <dminuoso> There you can extract the body from.
02:05:19 <AWizzArd> dminuoso: Right, and it works. I guess my main question is if I need to do this manually. Or if there is a Servant-like mechanism that lets me declaritively describe an expected request, and have Snap deliver me automatically args.
02:05:36 <AWizzArd> The „YOU can extract the body” part (:
02:05:41 <dminuoso> So you're looking for servant? ;)
02:06:07 <dminuoso> But really, you can relatively trivially write your own combinator
02:07:03 <AWizzArd> dminuoso: Another thing I am looking for: what if I want to use a ReaderT Context where I can place some nice TVars? How would I serve a site using my own reader?
02:07:34 <AWizzArd> The httpServe function wants a `Snap ()` value.
02:07:43 <dminuoso> getJSONRequest :: (FromJson t, MonadSnap m) => m t; getJSONRequest = do <- body <- rqBody <$> getRequest; buf <- ...; decode buf `note` ParseError ...
02:08:15 <dminuoso> Some badly written pseudo, but i hope it conveys my thoughts
02:08:38 <dminuoso> AWizzArd: Write your own MonadSnap instance.
02:09:07 <dminuoso> In case of ReaderT, you can trivially unwrap it no? ;)
02:09:11 <AWizzArd> dminuoso: yes, the   route :: MonadSnap m => [(ByteString, m a)] -> m a    looks good. There also already IS a ReaderT instance for MonadSnap.
02:09:44 <dminuoso> say, you have `data App a = App { runApp :: ReaderT Env (Snap a) } deriving (Functor, Applicative, Monad, MonadSnap, MonadReader Env)`
02:10:02 <AWizzArd> dminuoso: shouldn’t there me some    foo :: (MonadSnap m) => m -> Snap ()    ?
02:10:02 <dminuoso> Then you can just say `httpServce . runReaderT someEnv . runApp $ someApp`
02:10:13 <dminuoso> AWizzArd: ^- that.
02:10:41 <dminuoso> Think of ReaderT as being just a function, then getting the Snap out of it is just a matter of providing the argument.
02:10:57 <AWizzArd> Yes, that makes sense.
02:11:02 <dminuoso> Oh, I think the argument was flipped around.
02:11:21 <dminuoso> so `httpSevce . flip runReaderT someEnv . runApp $ someApp`
02:12:08 <dminuoso> (So if we squint a bit, runReaderT is just ($))
02:18:42 <AWizzArd> dminuoso: yes, that makes sense. The runReaderT is that function that returns the `Snap ()`.
02:19:37 <dminuoso> This is no different than servant btw
02:21:11 <dminuoso> Abstractly, in both snap and servant you need a natural transformation `T ~> Snap` and respectively `T ~> Handler`. In servant you provide that in hoistServer, and in snap it's a bit more direct.
02:21:20 <dminuoso> (Where T is your custom monad)
02:30:18 * hackage cabal-cache 1.0.2.0 - CI Assistant for Haskell projects  https://hackage.haskell.org/package/cabal-cache-1.0.2.0 (haskellworks)
02:34:16 <AWizzArd> dminuoso: in Servant I had to do this, yes, and wrap the result of runReader in a Handler:   Handler $ runReaderT (runApp appt) context
02:34:43 <AWizzArd> dminuoso: but the game was not over yet: I also had to `hoistServer` it.
02:38:34 <maerwald>  lol
02:39:02 <maerwald> runSomeThing . unwrapSomething . hoistMe . unliftMe . liftOther
02:39:04 <maerwald> such functional
02:39:47 <maerwald> justMakeTheDamnThingTypecheck
02:40:05 <AWizzArd> maerwald: yeah.
02:40:27 <AWizzArd> maerwald: so Snap is more "manual". That’s one difference.
02:41:36 <AWizzArd> maerwald: in Servant I say that I get a json body and I want Servant to parse it into a SendEmailRequest value. Not much to do, it now is a parameter, I won’t have to call Aeson or read anything from a request.
02:43:27 <AWizzArd> maerwald:   also I start my handler with     myHandler = readRequestBody (1024*30) >>= (\body -> ...)
02:43:47 <hc> actually, you never tell servant what you want it to do. you just declare what you are expecting to handle ;-)
02:43:48 <AWizzArd> maerwald: is that the typical strategy? Or is there some "readAll"?
02:43:55 <AWizzArd> hc: si
02:44:35 <AWizzArd> hc: I find Servant also useful when I NOT want to generate JS clients from the API. This declarative nature is nice.
02:45:16 <hc> true :)
02:45:19 <AWizzArd> hc: but then again Servant gives me parameters as Maybes. Is there a way to specify: „Hey, call this handler only in case that *all* of them are Justified”?
02:45:31 <AWizzArd> Justified = non-Nothing
02:45:57 <AWizzArd> (If you wrap something in a Just then you just Justified it)
02:46:13 <maerwald> AWizzArd: I personally find all that little gain for the increased cognitive noise
02:46:52 <AWizzArd> maerwald: I will be using Snap in that service now. It seems to be a bit simpler, yet more manual.
02:47:49 <AWizzArd> maerwald: So how do you work with a Post request that contains a json  body?   body <- readRequestBody (1024*30);   case eitherDecode body of ...     ?  Like that?
02:48:21 <maerwald> I don't recall :D
02:49:10 <AWizzArd> Btw: Aeson – what is the difference between  a) eitherDecode   and b) eitherDecode'  ?
02:50:03 <hc> hmm, strict vs nonstrict? lemme check the docs
02:50:30 <hc> ah no, one fails and the other returns an error on parse problems
02:50:33 <dminuoso> strictness in conversion checking
02:50:45 <hc> ah true
02:50:46 <dminuoso> decode' strictly performs conversion, decode is lazy
02:51:06 <hc> no wait! yes, it is about lazy/strictness after all :)
02:51:13 <dminuoso> See https://hackage.haskell.org/package/aeson-1.5.4.0/docs/Data-Aeson.html#v:json
02:51:16 <dminuoso> (And below)
02:51:47 <hc> ah cool. both functions parse immediately so cannot lazily fail later
02:51:50 <AWizzArd> And then  eitherDecodeStrict  vs  eitherDecodeStrict'
02:52:21 <AWizzArd> dminuoso: seems that’s it,  json vs json'
03:32:19 * hackage th-abstraction 0.4.0.0 - Nicer interface for reified information about data types  https://hackage.haskell.org/package/th-abstraction-0.4.0.0 (ryanglscott)
04:45:20 <arahael> Do the videos on the haskell.org website have any captions or transcripts?
05:03:49 * hackage cabal-cache 1.0.2.1 - CI Assistant for Haskell projects  https://hackage.haskell.org/package/cabal-cache-1.0.2.1 (haskellworks)
05:26:48 * hackage th-compat 0.1 - Backward- (and forward-)compatible Quote and Code types  https://hackage.haskell.org/package/th-compat-0.1 (ryanglscott)
05:31:31 <maralorn> "justMakeTheDamnThingTypecheck :: foral a b. a -> b" ?
05:32:20 <dminuoso> Let's see if it exists
05:32:23 <dminuoso> % :t justMakeTheDamnThingTypecheck
05:32:24 <yahb> dminuoso: a -> b
05:32:30 <dminuoso> Oh, who'd have guessed.
05:33:21 <maralorn> Wait what?^^
05:33:39 <merijn> I'll take "What is unsafeCoerce?" for 500, Alex.
05:33:43 <maralorn> You have been secretely querying yahb, haven't you?
05:33:44 <merijn> :t unsafeCoerce
05:33:45 <lambdabot> error: Variable not in scope: unsafeCoerce
05:33:50 <merijn> % :t unsafeCoerce
05:33:51 <yahb> merijn: a -> b
05:34:08 <dminuoso> maralorn: I'd never do that for effect.
05:34:09 <merijn> maralorn: Enjoy your one way ticket to segfault city ;)
05:34:19 <dminuoso> ;)
05:34:51 <maralorn> ^^
05:34:59 <dminuoso> merijn: Oh I have a valid and safe use case of unsafeCoerce.
05:35:03 <maralorn> "I'd never do that for effect." -> unsafePerformIO
05:36:04 <dminuoso> So I have a particular take on a hererogenous, type safe, map.. which is implemented as `Map Integer Any` under the hood..
05:36:37 <dminuoso> So upon accessing, I unsafeCoerce things into the right thing, but I prove the correctness of it all in the type system.
05:37:12 <dminuoso> maralorn: unsafePerformIO is boring. I prefer accursedUnutterablePerformIO.
05:37:26 <dminuoso> Eliding internal mutable buffers saves memory.
05:37:34 <dminuoso> It's very efficient.
05:46:23 <Guest_71> Im having trouble downloading haskell for mac
05:46:28 <Guest_71> can some1 help me
05:46:34 <maerwald> yes
05:47:11 <Guest_71> it says cannot install the software because it is not currently avaliable from the software update server
05:47:19 <maerwald> what software
05:47:25 <Guest_71> curl --proto '=https' --tlsv1.2 -sSf https://get-ghcup.haskell.org | sh
05:47:30 <Guest_71> this crap
05:47:35 <Guest_71> GHC
05:49:32 <maerwald> that's an excellent question
05:52:16 <Guest_71> any ideas?
05:52:30 <yushyin> you must be right about that course, maerwald.
05:53:19 <maerwald> I don't have a mac, but the script requires certain tools that the system must install (such as curl, tar, ...). Afaik mac tries to pull these from somewhere
05:53:33 <maerwald> It seems to fail doing so
05:54:39 <merijn> maerwald: curl and tar are always installed, afaik
05:54:40 <dminuoso> This seems like an Xcode error.
05:55:00 <merijn> xcode errors shouldn't kick in until you try to compile/link, though
05:55:00 <dminuoso> Since that's the error you'd get from `xcode-select --install` in some situations.
05:55:23 <dminuoso> Does ghcup invoke xcode-select?
05:55:35 <maerwald> dminuoso: no, but I think that happens implicitly
05:55:42 <maerwald> that's what ppl told me
05:55:47 <dminuoso> Implicitly when?
05:55:57 <maerwald> Good question
05:56:00 <merijn> so far I don't see an error message, so it's impossible to say
05:56:26 <dminuoso> Guest_71: Can you share the full terminal output since you ran that command in a gist/pastie/snippet?
05:56:58 <dminuoso> merijn: He mentioend the error message above. And that's most definitely an error message from xcode-select :)
05:58:18 <Guest_71> it didn't appear in the console it was a pop up box
05:58:22 <Guest_71> if that helps
05:58:39 <dminuoso> Ah, still share the output.
05:59:18 <Guest_71> his script will download and install the following binaries:  * ghcup - The Haskell toolchain installer            (for managing GHC/cabal versions)  * ghc   - The Glasgow Haskell Compiler  * cabal - The Cabal build toolghcup installs only into the following directory,which can be removed anytime:  /Users/MacBook-Pro/.ghcupPress ENTER to proceed or
05:59:19 <Guest_71> ctrl-c to abort.Note that this script can be re-run at any given time.  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current                                 Dload  Upload   Total   Spent    Left  Speed100 8345k  100 8345k    0     0  7880k      0  0:00:01  0:00:01 --:--:-- 7880k[ Info  ] Upgrading GHCup...[ Info  ]
05:59:19 <Guest_71> downloading: https://downloads.haskell.org/~ghcup/0.1.11/x86_64-apple-darwin-ghcup-0.1.11  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current                                 Dload  Upload   Total   Spent    Left  Speed 40 8501k   40 3430k    0     0  7177k      0  0:00:01 --:--:--  0:00:01 7177k100 8501k  100 8501k    0
05:59:20 <Guest_71> 0  9487k      0 --:--:-- --:--:-- --:--:-- 9487k[ Info  ] verifying digest of: ghcup[ Info  ] Successfully upgraded GHCup to version 0.1.11System requirements   Note: On OS X, in the course of running ghcup you will be given a dialog box to install the command line tools. Accept and the requirements will be installed for you. You will then need to
05:59:20 <Guest_71> run the command again.Press ENTER to proceed or ctrl-c to abort.Installation may take a while.[ Info  ] verifying digest of: ghc-8.8.4-x86_64-apple-darwin.tar.xz[ Info  ] Unpacking: ghc-8.8.4-x86_64-apple-darwin.tar.xz to /var/folders/98/8p2q1z693kgd515zsjklyg5c0000gn/T/ghcup-6LMxdn[ Info  ] Installing GHC (this may take a while)[ ghc-configure ]
05:59:21 <Guest_71> not found (too old?)[ ghc-configure ] checking for gcc... gcc[ ghc-configure ] checking whether the C compiler works... no[ ghc-configure ] configure: error: in `/private/var/folders/98/8p2q1z693kgd515zsjklyg5c0000gn/T/ghcup-6LMxdn/ghc-8.8.4':[ ghc-configure ] configure: error: C compiler cannot create executables[ ghc-configure ] See `config.log'
05:59:21 <Guest_71> for more details[ Error ] Build failed with NonZeroExit 77 "./configure" ["--prefix=/Users/MacBook-Pro/.ghcup/ghc/8.8.4"]    Check the logs at "/Users/MacBook-Pro/.ghcup/logs" and the build directory "/var/folders/98/8p2q1z693kgd515zsjklyg5c0000gn/T/ghcup-6LMxdn" for more clues.    Make sure to clean up
05:59:31 --- mode: ChanServ set +o ski
05:59:35 <maerwald> for some reason, I know this would happen
05:59:40 <yushyin> me too
05:59:54 --- mode: ChanServ set -o ski
06:00:10 <dminuoso> Doesn't help for their Haskell experience. :<
06:00:25 <guest12> okay im that same person it just kicked me
06:00:30 <maerwald> :D
06:00:35 <ski> please don't paste lots of lines into the channel
06:00:36 <dminuoso> guest12: Yeah, use a website to paste content, dont flood the channel. :)
06:00:46 <dminuoso> You can use https://paste.tomsmeding.com/
06:00:53 <guest12> okay thanks xD
06:01:02 <Cheery> gist github is also good if you happen to have github account.
06:01:16 <dminuoso> Always good to donate your data to Microsoft.
06:01:55 <guest12> https://paste.tomsmeding.com/iIICrGHx
06:02:52 <gehmehgeh> guest12: what does "cc --version" say?
06:03:10 <merijn> ok, yeah, that's missing xcode
06:03:11 <gehmehgeh> (on the command line)
06:03:15 <dminuoso> guest12: Did you ever get a dialog box to install the command line tools?
06:03:39 <guest12> yes I did and thats where I got the error
06:04:08 <gehmehgeh> guest12: can you type "cc --version", please?
06:05:03 <gehmehgeh> guest12: also "gcc --version"
06:05:09 <gehmehgeh>  cc should be Clang
06:05:10 <gehmehgeh> I guess
06:05:12 <guest12> https://paste.tomsmeding.com/Esfn48xS
06:05:13 <gehmehgeh> (on MacOS)
06:05:18 <guest12> then I get that with a dialog box
06:05:49 <guest12> same with gcc
06:06:14 <dminuoso> guest12: Out of curiosity, which macOS version are you on?
06:06:29 <gehmehgeh> guest12: type "uname -a"
06:06:30 <guest12> catalina
06:06:58 <dminuoso> Brave thing, to be running on most recent macOS. :>
06:07:55 <dminuoso> Perhaps the apple repos are bugged at the moment
06:08:09 <dminuoso> Do you have an icloud account?
06:08:11 <gehmehgeh> guest12: I typed it into a search engine, and apparently, MacOS will install the necessary development tools after asking you
06:08:13 <merijn> Try running "xcode-select --install"
06:08:26 <gehmehgeh> guest12: yes, waht merijn said for example
06:08:33 <gehmehgeh> guest12: or just type "make" or "gcc" or whatever
06:09:03 <guest12> same thing happens in the middle of the finding software bar it comes up with that message
06:09:11 <dminuoso> guest12: Alright, then install it manually from https://developer.apple.com/download/more/?=command%20line%20tools
06:09:19 <dminuoso> You're tripping into Apple issues.
06:10:17 <dminuoso> (Note you will need an iCloud account to reach that)
06:10:28 <dminuoso> Or rather, an Apple Id.
06:10:30 <guest12> yeye which do i download
06:10:37 <dminuoso> Dunno, what do you see there?
06:11:20 <guest12> A lot of stuff xcode 12, command line tools for xcode lots and lots of stuff
06:11:20 <dminuoso> Ah the top one
06:11:26 <Squarism> Does there exist some type description language (think protocol buffers/openapi/xml-schema/thrift) that has sum/product types and type functions (atleast paramterized types)? Something that handles the basics of haskell type system.
06:11:28 <dminuoso> Command Line Tools for XCode 12 
06:11:29 <dminuoso> should be fine
06:11:35 <guest12> okay
06:11:44 <dminuoso> Squarism: servant?
06:11:56 <dminuoso> or, are you thinking something else?
06:12:23 <dminuoso> (you can encode anonymous sum/product types up to isomorphism with Either and (,), or using custom data types)
06:12:51 <Squarism> dminuoso, I meant a textual representation that was at least aimed to be language agnostic.
06:13:06 <dminuoso> What would that language describe?
06:13:41 <Squarism> data structures (or types in haskell terms)
06:13:54 <Squarism> possibly functions
06:15:19 * hackage th-lift 0.8.2 - Derive Template Haskell's Lift class for datatypes.  https://hackage.haskell.org/package/th-lift-0.8.2 (ryanglscott)
06:15:20 <Cheery> there is a project that explores that.
06:17:18 <Cheery> lol you need to remember the url to find it
06:17:23 <Cheery> https://typedefs.com/
06:17:27 <lortabac> Squarism: you can achieve something similar with GraphQL, but it's a little cumbersome
06:18:04 <guest12> Its fixed thanks guys
06:18:17 <lortabac> also, you can encode sum types in OpenAPI IIRC
06:24:14 <alp> thrift too IIRC
06:41:06 <kw> Anyone know why hlint suggests writing `[x]` instead of `x : []`?
06:41:24 <dminuoso> kw: because its more idiomatic to use the [...] notation than :
06:41:27 <merijn> kw: Because hlint is super opinionated
06:41:45 <merijn> kw: And it's opinions reflect those of the author, not necessarily the wider community
06:42:15 <kw> That makes sense.
06:42:17 <dminuoso> I personally prefer `singleton x` in some code paths, where `singleton x = pure x`
06:42:51 <kw> Just always confuses me when constructor syntax like `x : xs` is mixed with literal syntax.
06:43:11 <kw> But obviously you can't use literal syntax to deconstruct an arbitrary list.
06:43:29 <merijn> kw: You can
06:43:41 <kw> Wait, how?
06:43:53 <kw> Do you mean with comprehensions?
06:43:55 <merijn> > case [1,2] of [x,y] -> "yay!"; _ -> "nay!"
06:43:57 <lambdabot>  "yay!"
06:44:00 <merijn> > case [1,2,3] of [x,y] -> "yay!"; _ -> "nay!"
06:44:03 <lambdabot>  "nay!"
06:44:08 <dminuoso> I think by "arbitrary" they mean it in the sense of `f ([x,y,z]:_) = ...`
06:44:15 <dminuoso> (Which doesn't make sense, of course)
06:44:16 <kw> OK, fair enough if I don't need the tail...
06:44:26 <int-e> but it's odd when your cases are [], [x], [x,y] and then x:y:z:xs
06:44:29 <dminuoso> kw: no, this is an exact list match
06:44:35 <dminuoso> it doesnt throw the tail away, it just doesnt match
06:44:41 <merijn> kw: No, "[x,y]" is equivalent to matching "x : (y : [])"
06:44:51 <dminuoso> So if you want something like `f (x:y:z:_) = ..` you cant use the [] syntax for that
06:44:53 <merijn> Note that the 2nd example returned "nay"
06:45:24 <dminuoso> kw: Anyhow. If you find the `x:[]` to work better, maybe for symmetry reasons wrt to the pattern matching on the left side, that's perfectly fine. :)
06:45:31 <kw> Sorry, I wasn't very clear. I've got a function that has special cases for lists of length 0, 1, 2, and 3, and has a recursive case for lists of length greater than 3.
06:46:01 <merijn> kw: writing out those fixed cases with literal syntax works fine\
06:46:10 <dminuoso> `f [] = ...; f [x] = ...; f [x,y] = ...; f [x,y,z] = ...; f xs = ...`
06:48:57 <dminuoso> `t :: IO [Pg.Only T]` how do I efficiently turn that into `IO [T]`? 
06:49:15 <dminuoso> (Only is just a newtype)
06:49:27 <kw> I guess it really does come down to opinion. For me `case xs of { [] -> z; [x] -> f x; [x1, x2] -> g x1 x2; x1 : x2 : x3 : xs -> h x1 x2 x3 (loop xs)}` seemed really odd. But it does make the recursive case stand out. 
06:49:31 <dminuoso> `newtype Only a = Only { fromOnly :: a }`
06:49:35 <merijn> dminuoso: "fmap (fmap getOnly)" :p
06:49:35 <[exa]> dminuoso: fromOnly?
06:49:46 <merijn> Or just "coerce"
06:50:01 <dminuoso> merijn: Will double fmap not cause it to walk over the list unnecessarily?
06:50:29 <dminuoso> % coerce [Produt 5, Product 6] :: [Integer]
06:50:29 <yahb> dminuoso: ; <interactive>:137:9: error:; * Data constructor not in scope: Produt :: t0 -> Product a0; * Perhaps you meant one of these: `Product' (imported from Control.Monad.RWS), variable `product' (imported from Prelude)
06:50:35 <dminuoso> % coerce [Product 5, Product 6] :: [Integer]
06:50:35 <yahb> dminuoso: [5,6]
06:50:39 <dminuoso> Ah. Mmm.
06:51:29 <dminuoso> % coerce (pure [Product 5, Product 6] :: IO [Product Integer]) :: IO [Integer]
06:51:29 <yahb> dminuoso: [5,6]
06:51:40 <dminuoso> merijn: I see. Somehow I didnt realize I could coerce through IO. :)
06:52:03 <kw> Is there any efficiency advantage in GHC to using list literal syntax?
06:52:20 <merijn> No
06:52:27 <dminuoso> kw: list literals are just syntax sugar around :
06:53:19 <kw> That's a relief. I remember reading somewhere that GHC would compile literal lists to arrays.
06:53:50 <int-e> There's some special treatment of string literals.
06:54:50 <kw> Oh, maybe that was it. I'm not using strings, so I guess it doesn't matter.
06:55:34 <kw> Thanks everyone.
06:56:01 <merijn> kw: IF ghc did that, there's no reason why it couldn't to the exact same thing for lists written using :, though
06:57:08 <kw> I know, I shouldn't doubt GHC's intelligence. Was just imagining that it might be something special that applies only to the sugar.
07:00:18 * hackage jose 0.8.4 - Javascript Object Signing and Encryption and JSON Web Token library  https://hackage.haskell.org/package/jose-0.8.4 (frasertweedale)
07:18:52 <z0> im doing advent of code 2019 and I think I found a typo in the last example @ day 5 part 2. has anyone done it and wants to verify?
07:20:03 <merijn> Seems unlikely, since I'm pretty sure I completed that just fine :p
07:21:06 <z0> i also completed, but i tested all examples given and this is the only one failing
07:21:16 <tdammers> yeah, AoC tends to be reviewed insanely well, which is kind of prudent considering the audience
07:23:05 <z0> well... i'm very suspicious because you can see the list ends in "4,20,1105,1,46,98,99" and I get the correct results BUT the next code is not 99 (halt)
07:23:43 <z0> 4 (the output instruction) has 2 parameters and if you move the pointer you go to 1105 and not 99
07:24:53 <tdammers> I can't remember the details, but I think I initially misread something in the spec that made this example fail
07:25:08 <tdammers> meaning that it's probably not the example, but your brain that's wrong
07:25:11 <dminuoso> z0: hold on, why does 4 have 2 parameters?
07:25:23 <dminuoso> It has only one.
07:26:03 <z0> sorry, i meant 1
07:26:18 <z0> the pointer moves 2 addresse
07:27:02 <z0> which puts it in the 1105 instruction. if i let it run it will eventually halt with the output 0
07:28:33 <dminuoso> z0: I dont quite understand what confusion you have.,
07:29:21 <z0> as i understood, as soon as the output is /= 0, the next instruction HAS to be 99, right?
07:30:43 <z0> in this case, the output i get from that last 4 is the right output for all 3 cases (< 9, ==9, > 9)
07:30:49 * hackage cli-extras 0.1.0.0 - Miscellaneous utilities for building and working with command line interfaces  https://hackage.haskell.org/package/cli-extras-0.1.0.0 (RyanTrinkle)
07:30:50 <z0> but the next instruction is not 99
07:31:14 <z0> *(<8,==8,>8)
07:31:49 * hackage nix-thunk 0.1.0.0, cli-nix 0.1.0.0, cli-git 0.1.0.0 (RyanTrinkle)
07:33:22 <dminuoso> 16:29:00          z0 | as i understood, as soon as the output is /= 0, the next instruction HAS to be 99, right?
07:33:28 <dminuoso> The way I read it, that sounds wrong.
07:34:58 <dminuoso> Consider the context of it all
07:36:09 <dminuoso> This is diagnostic routines. A diagnostic is finished by writing some output, and it outputs 0 if it was successful, and a number if there was a deviation from the expected value
07:36:27 <dminuoso> There's nothing to suggest a failed diagnostic must halt the program.
07:39:28 <turion> Is there a standard solution for building QuickCheck/SmallCheck/etc. generators for datatypes with constructors with existential types?
07:40:21 <dminuoso> turion: Mmm, how is that different from any other datatype?
07:40:44 <turion> E.g. I have a free category type 
07:40:44 <turion> data FreeCat c where
07:40:44 <turion>   Id :: FreeCat c a a
07:40:44 <turion>   Seq :: FreeCat cat a b -> FreeCat cat b c
07:40:44 <turion>   Free :: cat a b -> FreeCat cat a b
07:41:08 <turion> When I want to generate a Seq, I need to choose a _type_ b
07:41:25 <ski> signature of `Seq' looks incomplete
07:41:27 <turion> Of course I could always choose the same one, but that would be boring
07:41:46 <turion> Whoops right, thanks.
07:41:46 <turion> Seq :: FreeCat cat a b -> FreeCat cat b c -> FreeCat cat a c
07:42:15 <int-e> z0: you're reading too much inbto "immediately followed by"... 1105,1,n is an unconditional jump to offset n; here n=46 and the operation there is the 99 you want.
07:42:40 <ski> if you could have generation for `cat a b' pick an `a' or a `b' for you, given the other, then that could be useful, probably
07:43:21 <turion> ski: What would be the type of such a generator?
07:45:37 <ski> hm, to a zeroth approximation, something like `Gen (exists b. cat a b)', but then one'd like to keep using that `b' onwards .. 
07:49:47 <turion> ski: Yes. I guess there is a way to do this with an existential type somehow. Or maybe continuations...? But I'm wondering whether something like this has been studied systematically, because it must show up every time someone wants to write a generator for a GADT or existential type
07:51:54 <ski> if we imagine `class SomeArbitrary f where someArbitrary :: Gen (..f..)', one could have `instance SomeArbitrary (cat a) => SomeArbitrary (FreeCat cat a) where ..' with `someArbitrary :: Gen (exists b. SomeArbitrary (cat b) *> FreeCat cat a b)', maybe ?
07:52:43 <ski> perhaps the constraint here could be an associated type
07:53:01 <z0> dminuoso: "For each test, it will run an output instruction indicating how far the result of the test was from the expected value, where 0 means the test was successful. Non-zero outputs mean that a function is not working correctly; check the instructions that were run before the output instruction to see which one failed."
07:53:19 <z0> but ignoring this, it now works as supposed
07:53:20 <z0> thanks
07:54:24 <turion> ski: I'm not sure how exactly the generator case for Seq typechecks
07:54:26 <Cale> I can imagine writing a generator something like  (Arbitrary b, CoArbitrary a) => FreeCat (->) a b
07:54:53 <Cale> which generated Seq terms by picking from a finite list of types that are known to have Arbitrary and CoArbitrary instances
07:55:07 <z0> int-e: maybe i read too much into the sentence I pasted above
07:55:16 <Cale> oops
07:55:26 <Cale> I meant Gen (FreeCat (->) a b) obviously
07:55:34 <ski> Cale : imagine `cat' is a basic GADT ?
07:55:59 <turion> Cale: Yes, I guess that can work. Is there a framework that does this?
07:56:27 <turion> Imagine we'd go on and do free arrows, and we want to reuse this list of types, how to abstract it
07:57:30 <dminuoso> z0: Still, where does it say it has to halt?
07:58:32 <Cale> I was thinking cat is a category
07:58:32 <Cale> No, you'd have to write the thing yourself, and it will include too many details of this structure to be really generalisable
07:58:32 <Cale> Or maybe I just lack the imagination to figure out how to generalise it
07:58:33 <Cale> But it won't be a difficult thing to write
07:58:48 <dminuoso> z0: `Finally, the program will output a diagnostic code and immediately halt. ` means it will halt *after* the final diagnostic code.
07:59:28 <Cale> Oh, well, if you take a function of type (forall a b. (CoArbitrary a, Arbitrary b) => cat a b), that's the only real missing piece
07:59:57 <Cale> Or you could just insist on an instance Arbitrary (cat a b)
08:00:34 <turion> Cale, let's assume we have (forall a b. (CoArbitrary a, Arbitrary b) => cat a b) already
08:00:53 <Cale> It's the Free case which is more challenging than the Seq case. The Seq case just amounts to making a random decision about which type to factor through, and making acceptable choices for it
08:01:22 <turion> Cale: It's this random decision of a type that I want to abstract
08:01:45 <Cale> oneof :: [Gen a] -> Gen a
08:01:57 <Cale> ^^ use that :)
08:02:01 <z0> dminuoso: well, you are not wrong :/
08:02:03 <ski> for some applications, it seems it would be eaiser to pick the value first, and let the choice of that decide the type
08:02:35 <Cale> You can imagine writing the generator which generates a random Seq term by always factoring through Integer
08:02:42 <Cale> Or String or some such
08:02:46 <Cale> right?
08:02:49 <turion> We can also represent the free category differently:
08:02:49 <turion> data FreeCat cat a b where
08:02:49 <turion>   Id :: FreeCat cat a a
08:02:49 <turion>   Comp :: cat a b -> FreeCat cat b c -> FreeCat cat a c
08:02:56 <Cale> So you can combine those together with oneof
08:03:14 <turion> ski: Yes, maybe there is a generator for cat a b that knows what the output type should be
08:03:31 <turion> Cale: Yes, that part I know how to do. It's more that I'd like to abstract it
08:03:40 <turion> Or rather to see whether someone has already done that
08:03:49 <Cale> If you're writing the general instance, it'll just amount to pretty much  Seq arbitrary arbitrary  a bunch of times, but with type signatures on the arbitrary terms
08:04:03 <Cale> er, Seq <$> arbitrary <*> arbitrary rather
08:04:09 <turion> Because it seems like an ubiquitous problem
08:04:17 <ski> e.g. perhaps you have `data Fun :: * -> * -> * where Not :: Fun Bool Bool; Chr :: Fun Int Char; Ord :: Fun Char Int; Succ :: Fun Int Int; IsSpace :: Fun Char Bool', or something like that
08:04:19 <Cale> hmm
08:04:21 <z0> dminuoso: teaches me to keep no assumptions
08:04:32 <ski> and then you want to generate `FreeCat Fun'
08:05:11 <ski> turion : i don't think that representation makes a huge difference to the problem here
08:05:20 <turion> ski: That's a good example
08:05:24 <Cale> Oh, also, Id will be interesting, actually
08:05:32 <Cale> hmm
08:05:43 <Cale> Unless you demand Typeable a, Typeable b in your instance head
08:05:59 <Cale> So that you know when you're allowed to attempt to produce Id terms
08:06:00 <turion> ski: No the representation isn't that important, I agree. (That was kind of the point. I wanted to draw the attention away from the difference between Seq and Free)
08:07:32 <ski> Cale : hm, point
08:07:39 <ski> well
08:07:58 <ski> Cale : i guess you could allow `Id' for any `a' of the right kind
08:08:23 <turion> Assume I have an interpreter for this Fun type and I want to quickcheck that it preserves composition from FreeCat Fun to its semantic domain. But in a very general setting, where I don't have to fix the input and output types
08:09:33 <Cale> ski: Well, if you're writing an instance (...) => Arbitrary (FreeCat cat a b), you need to know whether a ~ b so that you know whether it's valid to generate Id at all.
08:09:55 <Cale> If a and b are not the same type, you can't generate Id terms, but you can still generate Comp/Free terms
08:10:08 <ski> yea. but i'm more considering `Arbitrary (exists b. FreeCat cat a b)' :)
08:10:17 <Cale> hmmm
08:10:24 <Cale> fair enough :)
08:10:37 <ski> (since we need something like that, for the composition)
08:11:08 <ski> (or else, i guess, randomly generating `b0' and `b1', which are `Typeable', and then comparing that they're the same ..)
08:11:17 <ski> (.. but that's not that nice)
08:11:49 <turion> Maybe at the end we need to build an Arbitrary (exists a b . FreeCat cat a b)
08:12:16 <turion> (possibly with Typeable, Arbitrary, Coarbitrary etc. thrown in
08:12:49 * hackage th-orphans 0.13.11 - Orphan instances for TH datatypes  https://hackage.haskell.org/package/th-orphans-0.13.11 (ryanglscott)
08:14:14 <ski> turion : the `Arbitrary' and `Coarbitrary' would be if `cat' say had constructors taking functions
08:18:43 <turion> ski: Yes
08:19:12 <turion> For your example it's not needed, right
08:19:19 <ski> right
08:19:33 <turion> I was implicitly thinking about my use case, which is a kind of free arrow
08:22:04 <turion> This kind of problem sounds like something that someone has written a functional pearl about 10 years ago
08:25:23 <Cale> Ah, writing the instance, you end up wanting to know not only that there are instances of Arbitrary for (cat a String) and (cat String a) for example, but also for (cat String String) and all combinations of intermediate types you plan to use
08:27:22 <Cale> So the instance head has O(n^2) constraints on it if you want n intermediate types :)
08:27:54 <ski> yes, hence i wanted `someArbitrary :: Gen (exists b. SomeArbitrary (cat b) *> FreeCat cat a b)', for `instance SomeArbitrary (cat a) => SomeArbitrary (FreeCat cat a)'
08:28:35 <Cale> tsk, wildcards not allowed in instance declarations
08:28:38 <Cale> annoying
08:28:54 <ski> so, when it's picking a new type for you, it should also give you an instance for how you could continue from that type
08:29:04 <ski> (this is very specific to `FreeCat', obviously)
08:29:22 <Cale> yeah
08:29:36 <Cale> You could also just demand everything you'll end up needing
08:29:57 <Cale> It's also probably sufficient just to have a single intermediate type, in practice. :P
08:30:19 <ski> you mean for other cases than `FreeCat' ?
08:30:28 <Cale> No
08:30:40 <Squarism> Cheery, thanks for the link. Thats exactly what I'm after
08:31:59 <ski> hm, sorry. for some reason, i misread you as saying "insufficient", rather than "sufficient"
08:32:43 <Cale> https://dpaste.com/5DUQARMCK -- anyway, something like this works
08:34:28 <Cale> Probably () would be a more useful choice than either Integer or String as a second type. Pick something with lots of values and something with few values :)
08:34:38 <Cale> Maybe throw in Void
08:35:25 <z0>  /quit
08:36:01 <monochrom> Nice, GHC 9.0.1 alpha1 was released yesterday
08:37:28 <monochrom> onoes, the GHC user's guide will use the readthedocs format :)
08:39:50 <turion> Ideally, have lots of different types, and ideally tweak the intermediate types depending over what we want the free category
08:40:58 <turion> E.g. in FreeCat (->) a b we basically want everything we can think of that has (CoArbitrary a, Arbitrary b). In ski's example, we want just the types that occur in Fun
08:44:11 <ski> turion : could also allow other types to be used, with `Id'
08:45:08 <Cale> With newer GHCs, you could use QuantifiedConstraints to get the thing you want in the (->) case
08:45:45 <Cale> It's also probably possible to construct a type family that lets you turn a list of types into a list of all the needed Arbitrary constraints between them
08:45:58 <turion> ski: Hmm true. So maybe we always want as many types as possible. But sometimes we'll have to restrict to the ones that are specified in a constructor
08:46:03 <Cale> (rather, into the combination of those constraints directly
08:46:04 <Cale> )
08:47:18 <ski> turion : perhaps there could be some way to "inject" which types one'd like it to consider for existentials .. not sure how one'd want that to work, though
08:47:38 <turion> ski: Like a list of proxies hidden in an existential type
08:47:47 <Cale> Also, note that you don't have to stick to a single Arbitrary instance.
08:48:25 <turion> Cale: What do you mean?
08:48:50 <Cale> You can write a bunch of these Gen values for various circumstances, and use them via QuickCheck's forAll
08:48:56 <Cale> forAll :: (Show a, Testable prop) => Gen a -> (a -> prop) -> Property
08:49:10 <turion> Ah yes :) that will sometimes make it easier
08:49:13 <monochrom> Yikes, new extension LexicalNegation. If you turn it on, then "x -y" means "x (negate y)", and "(- b)" means the section "subtract b".
08:50:58 <dolio> Oh, it turns off unary minus with spaces?
08:51:00 <Cale> monochrom: I hate the direction that GHC's been going lately
08:51:24 <ski> Cale : syntactically ?
08:51:28 <monochrom> I have a conspiracy theory! LinearTypes was a smoke screen to distract people from noticing the really breaking changes like LexicalNegation and simplified subsumption. :)
08:51:39 <Cale> ski: Syntactically, semantically...
08:51:57 <monochrom> Yeah dolio, basically that.
08:52:46 <Cale> LinearTypes is a disaster unfolding in slow motion, then there's all these little stupid syntactic extensions that everyone's going to have to deal with.
08:52:57 <dolio> Simplified subsumption I can kind of get behind, if it's what I'm thinking of.
08:53:04 <monochrom> Well, also, "x -y" meaning "x (negate y)" is turning on unary minus with absence of spaces. :)
08:53:46 <monochrom> "\x -> sin x == sin -x" is now a valid property for quickcheck :)
08:54:01 <monochrom> err, s/sin/cos/
08:54:19 <dolio> Right. I just thought it was adding the rule about -x, not taking away - x.
08:54:48 <Cale> I feel like RecordDotSyntax was the kind of thing that newbies would always ask for like a decade ago, but there were always good reasons not to do it. Now we've just gone ahead and ignored all those good reasons, and implemented something which makes it easy to write terms that nobody knows how to parse
08:55:32 <Cale> (there's a rule for disambiguation, but it's not obvious)
08:55:58 <monochrom> (basically using spaces again, yeah)
08:56:20 <maerwald> magical spaces
08:56:28 <Cale> It honestly makes me want to fork the entire language
08:56:53 <maerwald> reminds me of the `return foo;` vs `foo` syntax in rust, which is nonsense imo
08:57:01 <dolio> Taking away spaced unary minus might actually be good in that situation, I guess, because it's one less complication.
08:57:12 <Cale> GHC doesn't need new language extensions, it needs to be simpler and produce better code in less time
08:57:14 <dolio> Like "-x `mod` y" vs "- x `mod` y".
08:57:30 <Cale> The GHC API needs to be more usable
08:58:24 <monochrom> As usual, LinearTypes earns paper credits, improving GHC API doesn't.
08:59:09 <maerwald> monochrom: dunno, by now there should be enough companies caring about these mundane things... I'm not sure what's going on
08:59:13 <dolio> It's a little odd that - binds tighter than function application, though.
08:59:27 <Cale> dolio: Yeah, that's happening with dot now too
08:59:40 <dolio> Well, I'm not surprised by that.
08:59:41 <Cale> It's disgusting
09:00:14 <dolio> I expect "we need to import syntax from JavaScript" to be nonsense.
09:00:16 <Cale> The *one* rule about precedence that we used to be able to rely on
09:00:25 <monochrom> Ahhh I see now, two-for-one deal, if you can use spacing to change precedence, you may as well do it to both - and . and nail two popular demands.
09:01:25 <dolio> Anyhow, this is why "avoid (success at all costs)" is the wrong reading. :)
09:08:57 <zincy_> Cale: I agree, newbies at my last workplace were all over RecordDotSyntax
09:10:44 <zincy_> Why is linear types going to be a disaster?
09:12:16 <Cale> Because it's not very useful, and yet in order to attempt to use it in various circumstances, people are going to want linear-generalised versions of various higher order things from every package in the known universe.
09:12:23 <quicksilver> I was always afraid this would happen with record syntax
09:12:36 <Cale> This will clutter the world, and yet serve very little purpose
09:14:47 <zincy_> Cale: Yeah it seems like a lot of work for a solution to a very niche set of problems
09:14:57 <Cale> A lot of the downsides of attempting to use linear types are not particularly obvious at first sight. For example, the paper which introduced them includes as one of its examples, a socket library which could only be used if you never want to do any I/O in your server that could potentially throw an exception you might want to catch without taking down the entire server.
09:15:38 <zincy_> haha
09:15:52 <Cale> This is the kind of thing that beginners will hang themselves on, and blame Haskell's type system for being frustrating and incomprehensible, and the annoying thing is that in this case, they will be right.
09:16:37 <zincy_> Cale: Do you feel that there are too many obscure extensions on the market?
09:16:42 <Cale> yes
09:17:20 <zincy_> They feel a bit like pokemon.
09:17:26 <Cale> I think it's long past time to stop making new extensions at least until people have better ideas
09:17:39 <zincy_> In the old days you had ones you loved and new ones keep coming out and you dont care anymore
09:18:30 <quicksilver> I don't mind a plethora of experimental extensions as long as they don't become a new default
09:18:40 <quicksilver> I suppose that's hard to control/predict
09:19:06 <Cale> The thing is, the language people have to learn is basically the union of all the extensions that exist
09:19:17 <int-e> quicksilver: the problem with those extensions is somebody will use them :-/
09:19:18 <Cale> because once it's in GHC, someone's going to use it
09:19:21 <zincy_> I thought Haskell would be great at "taming" bad programmers. But it is amazing the ingenuity Haskell can give you to create bad code.
09:19:43 <Cale> Yeah, I've seen some remarkably terrible things done with singletons
09:20:13 <zincy_> Shudder
09:20:14 <Cale> People using the type system to guarantee properties that nobody ever actually cared about, and which turn programming into a bureaucratic nightmate
09:20:19 <Cale> nightmare*
09:20:30 <zincy_> Haha this is so true
09:20:53 <Cale> As much as I love dependent types, I also fear what bad programmers will do with them
09:21:02 <int-e> I want dependable types.
09:21:19 <monochrom> @quote int-e I want dependable types.
09:21:19 <lambdabot> No quotes match. Take a stress pill and think things over.
09:21:23 <monochrom> err heh
09:21:29 <monochrom> @remember int-e I want dependable types.
09:21:30 <lambdabot> Nice!
09:21:30 <zincy_> Maybe there should be a dependent types certification like a driving licence
09:21:34 <zincy_> or an oath to do no harm
09:21:37 <Cale> Even good programmers have a hard time finding the right way to define things in a dependently typed setting to guarantee the properties that are desired and still maintaining usability
09:22:22 <dolio> Right. That is publishable research.
09:22:28 <zincy_> What people do with custom typeclasses can be painful
09:23:26 <monochrom> I disbelieve that dependent typing and/or exploiting curry-howard is a good way to express general invariants. I disbelieve the argument "I don't need to learn a different language for specifications".
09:23:45 <Cale> There are places to use all the fancy new stuff in GHC, and I've been genuinely quite happy with some of the practical things I've been able to do with GADTs and DMap for example
09:24:16 <Cale> But using the fancy things has to be a last resort
09:24:26 <monochrom> Re-using the type language for general invariants is worse, not better, because it is not re-using, it is shoe-horning.
09:24:33 <Cale> Plain old Haskell 98 is pretty damn good 99% of the time
09:24:45 <zincy_> Yeah
09:27:52 <Cale> Well, when I say "all the new stuff", I'm still actually excluding a fair amount... there are a fair number of extensions that we just don't even begin to use, like all the weird record overloading shenanigans
09:28:31 <merijn> Cale: Also, GADTs and fancy things are like spices
09:28:35 <merijn> A little goes a long way
09:28:36 <Cale> I guess I'm referring to the stuff that's more in the direction of dependent types, like GADTs and type families and QuantifiedConstraints and such
09:28:43 <Cale> yeah
09:29:01 <Cale> There's a lot that I could do if I could write just *one* type level lambda :)
09:29:24 <dolio> Is there an extension where record syntax doesn't generate the accessor?
09:29:29 <zincy_> monochrom: What would you recommend as a first dip of the toe into proving properties about programs?
09:30:01 <zincy_> monochrom: Operational/Denotational semantics, was thinking software foundations but Isabelle looks fun too
09:30:01 <merijn> dolio: Yes
09:30:04 <dolio> Seems like that would be one of the most useful extensions.
09:30:07 <merijn> dolio: Not sure if it's in yet
09:30:15 <merijn> dolio: But the GHC proposal was approved
09:30:39 <dolio> Then you can declare record types and generate overloaded lenses instead of monomorphic accessors.
09:30:42 <merijn> dolio: https://github.com/ghc-proposals/ghc-proposals/pull/160
09:30:45 <monochrom> I'm biased, I'll just point you to my favourite: my thesis supervisor's textbook :)  http://www.cs.toronto.edu/~hehner/aPToP/
09:30:57 <ski> it would be useful, yes 
09:31:09 <dolio> Which gives you a much better record system than a bunch of ad-hoc nonsense.
09:31:15 <merijn> dolio: Looks like it'll be 9.2: https://gitlab.haskell.org/ghc/ghc/-/merge_requests/4017
09:31:39 <dolio> Ah, okay.
09:31:50 <zincy_> monochrom: Thanks, I learned to prove things by studying Analysis so looking for the next step really that will tie in with programming :)
09:31:55 <dolio> And you no longer have to name your field _foo.
09:33:33 <Guest18> Does anybody know how is Maybe implemented?
09:33:49 <dolio> To be honest, I blame a bit of the record stuff on the 'rigorous typeclasses' culture that has developed.
09:33:58 <maerwald> @src Maybe
09:33:58 <lambdabot> data Maybe a = Nothing | Just a
09:34:12 <Guest18> @src Nothing
09:34:13 <lambdabot> Source not found. My brain just exploded
09:34:19 <maerwald> That's a constructor
09:34:40 <[exa]> Guest18: Nothing is defined by that definition of Maybe
09:34:52 <geekosaur> as is Just
09:34:55 <maerwald> I'm wondering which university started this haskell course :p
09:35:14 <dolio> Type classes are obviously the correct way to overload records, but any suggestion for using it would get hammered by the "there are no LAWS" crowd. So instead people need to invent a less thought out version of type classes that you're allowed to use how you want.
09:35:27 <Guest18> [exa] so they don't have implementations? They are just symbols of sorts?
09:35:48 <[exa]> Guest18: yeah, perfectly arbitrary "labels". Just like False and True
09:36:07 <merijn> Guest18: Define "implementations"
09:36:16 <merijn> Guest18: That *is* the implementation
09:36:19 <monochrom> dolio, the good news is you have convinced me. :)  Next time I teach my course, I'll be relaxing on traits of good type classes.
09:36:29 <ski> Guest18 : they don't have implementations in Haskell, beyond that `data' type definition
09:36:46 <Guest18> that's a bit confusing, i might say
09:37:00 <ski> whyso ?
09:37:43 <ski> you know (or will know) how to work with them, practically. why do you care about "what they really are" ?
09:38:25 <monochrom> But even my previous version was open-ended. I had "useful expectations", this included social expectations, so overloaded field name would be fine. Also, I only intend a spectrum, not a boolean.
09:38:48 <Guest18> Regarding what [exa] said about True and False: if they are just arbitrary labels, why can i put a guard, a condition after and it automatically knows it should execute that only if the condition == True
09:39:06 <Guest18> ski: Just curios, Nothing else ;)
09:39:06 <maerwald> I'd favor a version of the haskell language without type classes :p ...just wondering how we'd implement functors etc
09:39:07 <ski> you know you can construct `Maybe' values, with `Nothing', and with `Just'. and you know you can detect which way a `Maybe' value was constructed, by using pattern-matching, on the `Nothing' and `Just' cases (getting the "contents" as well, in the latter case)
09:39:12 <ski> what more do you need ?
09:39:17 <[exa]> Guest18: because the "label" for True is shared between `guard` and your program, and they know it's the same thing
09:40:29 <maerwald> Guest18: there are also pattern guards: | (Just m) <- foo = bar
09:40:29 <ski> Guest18 : well, guard syntax (and `if', and list comprehensions) knows about `Bool' in particular
09:40:39 <geekosaur> booleans are partially wired into the compiler because of guards, among other things (but this is just an optimization). Maybe isn't, because there's no equivalent usage inside the compiler for it
09:40:59 <monochrom> Lately I've been writing a GHC.Generics tutorial, and also realize that it is very difficult to uphold "has laws" for the homebrew type classes you have to define in order to have a place for your generic algorithm to live in.
09:40:59 <maerwald> lets drown them in information :p
09:41:07 <ski> you could define your own version of `if' (as an ordinary function), though. `if ... then ... else ...' is just a handy syntactic sugar
09:41:37 <ski> maerwald : it's an old established tradition :)
09:41:44 <Guest18> ski: just curiosity to see how complicated it is on the inside. I mean, I always assume whatever i get from the standard library is going to have some weird implementation that I can't understand. Wanted to see what the deal was with Maybe
09:42:14 <maerwald> Those are reasonable expectations from a standard library
09:42:47 <Guest18> i get it now, i experimented with Maybe for a bit already and get how to use it, and now wanted to see how it works
09:43:22 <ski> what's the difference between "how to use it" and "how it works" ?
09:43:39 <maerwald> > join (+) 4 -- hey Guest18, look at this :p
09:43:41 <lambdabot>  8
09:43:53 <maerwald> :t join
09:43:54 <lambdabot> Monad m => m (m a) -> m a
09:44:19 <geekosaur> there's nothing to know, really. either it's Nothing or it's Just some value. there are some typeclass instances that make it more convenient to use in various cases, but those aren't wired in to the compiler either
09:44:39 <Guest18> ski: i can drive a car, or 'use' it, but i don't know all the internals and how it functions
09:45:12 <ski> it could "work" then in different ways, depending on which implementation of the language you're using
09:45:22 <Guest18> maerwald: I haven't gotten into Monads, that's uncharted territory to me
09:45:23 <monochrom> There are English native speakers, I think even the majority, who use "how does it work" to mean, seriously, how to use.
09:45:26 <[exa]> Guest18: on the inside there's a very rough reminiscent of a tagged union (something like enum with extra struct members, if you like C)
09:45:27 <ski> (but then we're not talking about Haskell, but implementations of Haskell)
09:45:59 <[exa]> but yeah that depends a lot on the actual implementation.
09:46:01 <dolio> monochrom: Yeah, the important thing is to judge the value in context, and not over-generalize some rigid rule set. Like, mathematical structures are a good way to figure out nice type classes. But they're not the only way.
09:46:08 <maerwald> monochrom: isn't that a rather american thing?
09:46:41 <maerwald> where "work" is overloaded to all sorts of meanings
09:46:43 <Guest18> ski: yeah, you are right here. I should have asked: what's a probable implementation of Maybe?
09:46:58 <monochrom> I don't know. But I'm afraid more people speak American English than British English. I deplore it, but I admit defeat. And it's spelled colour, not color!
09:46:59 <ski> Guest18 : what [exa] said
09:47:07 <Guest18> [exa]: I see, thank you so much
09:47:14 <dolio> And with generics that's just a completely different application, basically.
09:47:22 <ski> Guest18 : have you seen C ?
09:47:48 <Guest18> what lambdabot said does remind me of an enum of sorts
09:48:12 <Guest18> ski: if i have seen it? what do you mean?
09:49:07 <Guest18> you mean if i've ever seen C code? Sure i have
09:49:12 <Guest18> Quite a lot
09:49:26 <[exa]> you might like the ghc RTS then. :]
09:49:45 <ski> Guest18 : very roughly, you could imagine something like `struct maybe_int { enum {NOTHING,JUST} tag; union { struct {} n; struct { int n; } j; } u; };'
09:49:48 <maerwald> I think this might be the only student passing the exam :)
09:50:07 <maerwald> (the others left after they figured out how to install GHC)
09:50:21 <ski> (but this ignores lots of things, is just meant to get a general idea for how you could simulate something a bit akin to `Maybe Int', in C)
09:51:00 <monochrom> With great trouble.
09:51:02 <dolio> EvanR: Oh, by the way, I thought of some other 'not correct' stuff that probably makes sense in SDG. All those weird differential operators that get used in e.g. Maxwell's equations, where in classical math you have to explain it as 'just a notation' probably actually make sense. Like the gradient is actually a vector-like thing, and you can use the dot product to get the divergence, and it all makes sense. At least, I think that's the kind of thing 
09:51:03 <dolio> you get out of it (I have very little understanding of SDG).
09:51:05 <[exa]> ( ...did I miss a surge of new questions about haskell language server? )
09:51:37 <ski> [exa] : recently there's been a bit of people having basic trouble with how to install GHC
09:51:56 <[exa]> good
09:52:03 <[exa]> I'm going to contribute a few tomorrow. :]
09:52:25 <maerwald> I already have PATH-burnout
09:52:33 <ski> Guest18 : does that help ?
09:52:48 <[exa]> oh this.
09:53:02 <monochrom> ski and Guest18: Could I talk you into replacing C by Rust as your reference point? Because Rust matches so much better to Haskell in this regard.
09:53:15 <[exa]> I should put this to slides explicitly
09:53:44 <ski> mm, the other day, we helped someone to add stuff to `.bashrc' and `.bash_profile' (after telling how to create the first one, which was non-existant)
09:53:45 <Guest18> ski: it does. Do you recommend going into the RTS to see some of this in action? I am quite curious
09:54:10 <ski> monochrom : i'd love to, but less people tend to be familiar with it :)
09:54:22 <monochrom> maerwald: There is an alternative. If you don't support Mac... >:)
09:54:31 <[exa]> monochrom: doesn't it kinda lead to question "how's that implemented in rust?"
09:54:49 <Guest18> monochrom: i for one can read simple rust, but never programmed with it
09:54:53 <monochrom> Yes for some people, no for some people.
09:55:01 <Guest18> and i think many people have the same problem
09:55:05 <[exa]> anyway thanks for pointing out the install problem, I just realized that my slides don't match reality anymore, at all
09:55:07 <maerwald> monochrom: I hope the next haskell survey will give better insights about the user distribution of ghcup
09:56:23 <monochrom> Notice how, for example, most javascript programmers never ask how are javascript features implemented, how are web browsers implemented in the first place.
09:56:53 <zincy_> monochrom: Yes!
09:57:05 <[exa]> monochrom: they learnt to fear the browser!
09:57:23 <dolio> JavaScript is the fundamental language of the universe.
09:57:33 <[exa]> ("learnt" isn't english, is it...)
09:57:43 <ski> [exa] : if you look for "xcode" in scroll-back, you should see one such conversation, a few hours ago
09:57:46 <geekosaur> british english
09:57:48 <monochrom> It is. Both learnt and learned are legal.
09:58:06 <Guest18> monochrom: the problem with those is that they chose the easy route, it's all about making a living, but beyond that, i don't think they care if it doesn't affect them
09:58:06 <[exa]> o nice
09:58:12 <[exa]> ski: thanks!
09:58:14 <Cheery> I just wrote a lazy lambda calculus interpreter in RPython.
09:58:22 <monochrom> Recommendation: Every time, toss a coin to decide whether you use learnt or learned :)
09:59:11 <ski> [exa] : and there was someone that we helped with `.bashrc' and `.bash_profile' (on Mac), maybe yesterday, or the day before (you could check the TUNES logs, if it's fallen off the far end of your buffer)
09:59:39 <ski> monochrom : ooh, is that what the learnt ones do ?
09:59:48 <monochrom> haha
09:59:50 <[exa]> I see it in the backlog (it's nicely marked by a flood of ghcup install logs :D )
10:00:07 <monochrom> Nah, learnt people don't troll like that.
10:00:45 <Guest18> [exa] Do you do any embedded by any chance?
10:00:47 <maerwald> [exa]: yeah, we saw it coming a mile away
10:00:53 <zincy_> And then you have those lovely people who take javascript out of the browser and write their servers in it!
10:01:15 <zincy_> Keep the monster in the box
10:01:26 <ski> Guest18 : iirc, there's some STG paper that people seems to be suggesting. but i think it's probably more useful to first get a bit more comfortable with the language
10:01:43 <[exa]> Guest18: embedded? as in programming for embedded platforms?
10:01:53 <Guest18> Any chance we could convert js devs to OCaml?
10:01:56 <Guest18> [exa]: yes
10:02:10 <zincy_> Guest18: They tried that with Reasonml
10:02:21 <zincy_> But it was too hard to learn of course
10:02:24 <zincy_> Because. Types.
10:02:37 <monochrom> I am against converting people.
10:02:49 <zincy_> haha
10:03:00 <[exa]> Guest18: I'm also teaching C/C++ and generally work towards the "restricted&efficient" systems but usually not for the small-platform-ish reasons
10:03:24 <dolio> It's too hard to get your variable scoping errors at compile time.
10:03:49 <Guest18> Oh, cool, I taught C++ as well. As in, not anymore
10:04:02 <[exa]> some of the JS people kindof don't believe the mistake until it really happens
10:04:12 <zincy_> dolio: And scary!
10:04:23 <zincy_> Imagine seeing all those problems at once
10:04:32 <Guest18> Although, probably in this group, that's not much of an achievement
10:08:56 <maerwald> you can conver js devs to elm
10:09:31 <[exa]> "but does it run react?"
10:10:38 <maerwald> I'm already happy TypeScript exists, although the type system isn't entirely sound
10:11:30 <aldum> you know, compared to what ; next JS it's splendid
10:11:48 <monochrom> Hey maerwald, I'm wondering if https://downloads.haskell.org/ghc/9.0.1-alpha1/docs/html/users_guide/9.0.1-notes.html#base-library  solves your ByteString space troubles.
10:12:11 <monochrom> This is on GHC 9.0.1 alpha1
10:12:36 <maerwald> aldum: https://github.com/microsoft/TypeScript/issues/18770
10:13:38 <maerwald> const array1: (number | string)[] = []; const array2: number[] = array1; array1.push("gotcha");
10:13:40 <maerwald> heh
10:13:51 <maerwald> boom
10:13:56 <maerwald> (it works)
10:15:40 <ski> contravariance of mutable container ?
10:20:33 <maerwald> monochrom: you mean this? https://github.com/haskell/tar/issues/57
10:20:47 <monochrom> Yeah
10:20:49 <maerwald> I think it might actually be related to ByteString, but I have to check
10:21:22 <maerwald> or it might get worse
10:21:34 <monochrom> Ah then, maybe 9.0.1 doesn't help.
10:21:45 <maerwald> they made bytestring faster... but no one knows if that increased the memory footprint I think
10:21:52 <geekosaur> bytestring still needs to be updatd to use the new mechanism
10:21:56 <monochrom> 9.0.1's change is for OverloadedString bytestrings, if I read correctly
10:22:17 <maerwald> I usually don't put 200mb string literals in my code
10:22:20 <monochrom> And what geekosaur said.
10:22:35 <geekosaur> and in any case there are multiple ways that ByteStrings fragment and possibly leak memory, as I understand it, and this helps only one of them
10:23:22 <maerwald> the streamly maintainer wants to completely replace it with a Stream of Word8
10:23:46 <maerwald> maybe that solves all our problems
10:26:29 <aldum> is OverloadedStrings default now, or am I misunderstanding you?
10:26:59 <geekosaur> no, it's not the default
10:27:44 <geekosaur> but OverloadedStrings means you have a string literal somewhere that in this case gets converted to a ByteString, which means the string ow exists twice unless there's some trickery to share the representation
10:27:55 <geekosaur> this is said trickery
10:28:42 <geekosaur> (it can't be a normal FroeignPr like with most ByteStrings because it would then be freeable, but it's not in the heap because it was compiled in)
10:38:19 <geekosaur> hm, actually I wonder how much of that I have correct, since I thought string literals were encoded with a variant of UTF8 which would then require decoding to recover the "original" ByteString
10:39:49 * hackage acc 0.1.0.2 - Sequence optimized for monoidal construction and folding  https://hackage.haskell.org/package/acc-0.1.0.2 (NikitaVolkov)
10:40:17 <geekosaur> in other news, there's some odd attrition going on here
10:46:41 <Turmfalke> That's what the IRCCloud version of a netsplit looks like
10:47:42 <geekosaur> cute
10:54:00 <Dashboard> !help
10:54:15 <yushyin> hello Dashboard
10:54:20 <Dashboard> hi
10:55:35 <Dashboard> !id
11:05:48 * hackage asciichart 1.0.2 - Line charts in terminal  https://hackage.haskell.org/package/asciichart-1.0.2 (madnight)
11:36:55 <zincy_> Should you use floating point to store monetary values?
11:37:02 <dolio> No.
11:37:11 <zincy_> I thought not but now I am reading stuff which questions this 
11:38:27 <koz_> zincy_: As someone having to deal with the fallout of this: no, you should never, under any circumstances, ever.
11:38:43 <zincy_> haha
11:38:51 <monochrom> "should" is ambiguous. For example, more socially acceptable? Technically better? More moral?
11:38:52 <zincy_> I am trying to question my understanding of this ... so here goes
11:39:05 <koz_> You have _no idea_ what kind of absurd contortions I have been putting codebases through for several months to get around this _horrific_ decision.
11:39:14 <monochrom> For example, to be more socially acceptable among bankers, use fixed point, it's what they do.
11:39:20 <koz_> (made a long time by someone who isn't me)
11:39:26 <monochrom> in fact use decimal fixed point.
11:40:01 <monochrom> But binary is technically better than decimal in terms of minimizing errors, as shown by Knuth.
11:40:10 <zincy_> You cannot use floating point to accurately store monetary values because expansions of rational numbers that are recurring cannot be stored within a finite amount of memory
11:40:32 <zincy_> Is that right?
11:41:04 <koz_> zincy_: That isn't even the _tenth_ reason.
11:41:07 <zincy_> monochrom: What does better mean in terms of error distribution?
11:41:15 <monochrom> Yes, rational numbers is even better than binary floating point, technically.
11:41:18 <koz_> Firstly, there are some integer values that cannot be represented as floats as such.
11:41:33 <monochrom> smaller errors if you have to round
11:41:41 <koz_> Secondly, you cannot guarantee (for example) associativity of addition where floats are involved.
11:42:01 <monochrom> As for distribution, round to even is better than "round up when half". As shown by Knuth, same paper.
11:42:22 <koz_> (I'm not even mentioning the fact that some _non_-integer values cannot be represented)
11:42:36 <koz_> The fact that you truncate recurring decimals is a drop in the goddamned ocean.
11:42:37 <monochrom> However, rational number is even less socially acceptable than binary floating point.
11:43:03 <zincy_> Yes rational numbers are seen as idealistic
11:43:35 <zincy_> Im not comfortable with how changing the base results in less errors 
11:43:52 <monochrom> Bankers have made the decision of decimal fixed point, and have built very anal rounding rules around it. If you use rational numbers, you stand to be more correct than them, but that also means from their POV you're wrong.
11:43:55 <zincy_> What are examples of values that cannot be represented
11:44:02 <tomsmeding> zincy_: 1/10
11:44:13 <monochrom> This is the very reason Intel floating point has BCD.
11:44:20 <tomsmeding> > sum (replicate 10 0.1)
11:44:23 <lambdabot>  0.9999999999999999
11:44:30 <monochrom> Note: BCD is still floating point, just decimal.
11:44:40 <dolio> I mean, that's the real reason. If you want your program to be used for anything, you need to comply with all the rules.
11:44:47 <dolio> And you, some random tech dude, aren't going to change the rules.
11:45:08 <monochrom> Hell, Knuth is not random, and still can't change the rules.
11:45:34 <zincy_> Why can't you just represent 1/10 as 10^-1 ?
11:45:42 <zincy_> Isnt floating point essentially scientific notation
11:45:44 <tomsmeding> zincy_: then you're using base 10 :)
11:46:03 <monochrom> 1/3 can be represented in floating point if base 3.
11:46:04 <zincy_> So is floating point generally base 2
11:46:15 <tomsmeding> IEEE floating points use base 2, which means all numbers are represented as <integer> * 2^<integer>
11:46:16 <geekosaur> yes
11:46:28 <tomsmeding> not just generally; most programmers will answer you "always"
11:46:41 <tomsmeding> for the normal definition of the term "floating point", which is IEEE floating points
11:46:42 <dolio> You can define floating point for any base, but the ones implemented in hardware are base 2.
11:46:54 <monochrom> OK you need to read this: https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html
11:47:08 <tomsmeding> long though
11:47:38 <monochrom> long compared to what? compared to replicating the same length in #haskell?
11:47:42 <tomsmeding> :D
11:48:12 <zincy_> Understanding the limitations of floating point actually goes quite deep
11:48:24 <monochrom> Seriously by the time one asks "why is 1/10 not representable" it's time to actually learn it.
11:48:53 <monochrom> Or else, finish the 2nd year "computer organization" course in the standard CS curriculum.
11:49:20 <zincy_> Yeah i Have done zero architecture or low level stuff
11:49:55 <Noughtmare[m]> It is also very important for geometric algorithms and numeric analysis.
11:50:22 <zincy_> I guess I should do that computer organization course
11:50:24 <geekosaur> you have reached the point here you need to know it and its limitations and how to work around them
11:50:30 <geekosaur> *where you
11:50:40 <zincy_> Yeah
11:51:04 <zincy_> I am past the point where I can just memorise the answer without understanding why 
11:51:29 <zincy_> That is get away with it rather than *should*
11:51:32 <ski> @where floating-point
11:51:32 <lambdabot> "What Every Programmer Should Know About Floating-Point Arithmetic" at <http://floating-point-gui.de/> and "What Every Computer Scientist Should Know About Floating-Point Arithmetic" by David
11:51:32 <lambdabot> Goldberg in 1991 at <http://docs.sun.com/source/806-3568/ncg_goldberg.html> and <http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.102.244>
11:53:17 <zincy_> Thanks I have some reading to do :)
11:59:35 <dolio> I guess one thing to consider is that the market capitalization of Apple is (as far as bankers might be concerned) a number requiring almost 53 bits of precision, just on its own. So Double just gets by, and it's immediately going to be rounding stuff according to the non-banker specification.
12:01:06 <dolio> 53 might actually not be enough, even.
12:02:05 <Noughtmare[m]> There was also this blog post: https://cs-syd.eu/posts/2020-07-28-how-to-deal-with-money-in-software
12:02:33 <Noughtmare[m]> Might be an easier read and more related to Haskell and money.
12:19:59 <koz_> Noughtmare[m]: Thanks. That's really good.
12:28:43 <dolio> I guess a counterpoint is that a lot of this advice is about accounting. If you're doing something else, it might be more acceptable to use doubles.
12:29:03 <dolio> Like, some kind of statistical analysis of things involving money.
12:29:07 <geekosaur> might be acceptable but there's still a lot to know about how to work around their issues
12:29:27 <geekosaur> which includes doing different things depending on what magnitudes are involved
12:29:51 <dolio> Sure.
12:32:09 <dolio> It's more that accounting has rules that make IEEE floating point impossible to use, whereas other scenarios it might be possible, but still difficult. :)
12:35:50 <monochrom> There is an unhealthy dose of scaremongering against floating point.
12:37:00 <monochrom> The outcry is "it has errors!" but the blindspot is: compared to what? For the same number of bits, base-2 floating point is the least errorneous among all ways of using those bits.
12:38:39 <monochrom> The real subtext is "it doesn't do intuitive decimal".
12:39:11 <monochrom> as if decimal were the holy grail of accuracy.
12:39:24 <Noughtmare[m]> The main point of the blog post is also that the errors should be explicit.
12:39:37 <Noughtmare[m]> You can't just create or destroy money.
12:39:47 <monochrom> That's a social construct.
12:40:13 <Cheery> https://github.com/cheery/lijp
12:40:17 <geekosaur> so is money
12:40:28 <monochrom> Yeah :)
12:40:55 <monochrom> More seriously, I respect the accounting requirement of conservation of money.
12:41:28 <monochrom> I disrepect "floating point has errors" as if the accounting requirement didn't have even worse errors.
12:42:00 <dolio> I don't know. The thing about IEEE is that it has ways of dealing with the errors, but my understanding is that if you don't learn the right way, you probably won't accidentally write code that has good behavior with respect to error accumulation.
12:42:40 <dolio> So either the errors are completely irrelevant for whatever you're doing, or you still have to study non-trivial stuff.
12:43:34 <dolio> A lot of people probably write code in the 'irrelevant' part, though.
12:45:06 <Chousuke> The "inexactitude" of floating point is only a problem because it can be used by people who don't know better. If you use it and your application can deal with the potentially accumulated errors, then it's not wrong, and not a problem.
12:46:07 <Chousuke> but lots of people will try to use a screwdriver as a hammer, and often it works, too :/
12:50:32 <sm[m]> anecdote: hledger started with Double, for simplicity and speed. It wasn't a problem for normal accounting; it took years until somebody encountered a tiny rounding error.
13:06:49 * hackage curl-runnings 0.15.0 - A framework for declaratively writing curl based API tests  https://hackage.haskell.org/package/curl-runnings-0.15.0 (aviaviavi)
13:07:33 <koz_> If I do [minBound .. maxBound] :: [Char], will this effectively produce a string made of every Unicode code point?
13:08:08 <ski> > filter isSpace [minBound .. maxBound]
13:08:11 <lambdabot>  "\t\n\v\f\r \160\5760\8192\8193\8194\8195\8196\8197\8198\8199\8200\8201\8202...
13:08:20 <sarahzrf> > filter (not . isSpace) [minBound .. maxBound]
13:08:24 <lambdabot>  "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\SYN\ETB\CAN\...
13:08:48 <koz_> Uhh, so, 'yes'?
13:08:52 <sarahzrf> hehe
13:09:06 <koz_> > length ([minBound .. maxBound] :: String)
13:09:09 <lambdabot>  1114112
13:09:14 <sarahzrf> > filter isAlpha [minBound .. maxBound]
13:09:16 <lambdabot>  "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\170\181\186\192\193\19...
13:09:21 <ski> > ord maxBound
13:09:23 <sarahzrf> > text (filter isAlpha [minBound .. maxBound])
13:09:28 <lambdabot>  mueval-core: Time limit exceeded
13:09:29 <lambdabot>  ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyzªµºÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔ...
13:09:52 <sarahzrf> > ord (maxBound :: Char) -- ski
13:09:56 <lambdabot>  1114111
13:10:12 <ski> > ord maxBound
13:10:14 <lambdabot>  1114111
13:10:17 <sarahzrf> huh
13:10:25 <ski> temporary fluke
13:10:25 <sarahzrf> oh right, ord is monomorphic
13:11:10 <ski> koz_ : i guess it might be extended, later
13:11:20 <koz_> ski: Possibly.
13:15:51 <koz_> Where can I find a function of type Int -> [a] -> [[a]]? This should chop the argument list into chunks of length specified by the Int argument.
13:16:21 <hyperisco> koz_, chunksOf
13:16:25 <ski> @hoogle Int -> [a] -> [[a]]
13:16:26 <lambdabot> Data.List.Split chunksOf :: Int -> [e] -> [[e]]
13:16:26 <lambdabot> Data.List.Split.Internals chunksOf :: Int -> [e] -> [[e]]
13:16:26 <lambdabot> Hedgehog.Internal.Shrink removes :: Int -> [a] -> [[a]]
13:17:00 <ski> @hackage split
13:17:01 <lambdabot> https://hackage.haskell.org/package/split
13:17:07 <koz_> Thanks!
13:17:36 <ski> > chunksOf 3 [0 .. 7]
13:17:39 <lambdabot>  [[0,1,2],[3,4,5],[6,7]]
13:17:48 <koz_> Delicious chunky list.
13:27:00 <monochrom> koz_: Some of the numbers / "characters" in that range are not legal unicode codepoints, so be careful.
13:27:18 <koz_> monochrom: How do I make sure I only have ones which are?
13:27:36 <koz_> Is there some kind of 'I am a real boy^WUnicode codepoint' check?
13:27:41 <monochrom> Let me check if Data.Char has some helpers
13:27:53 <koz_> Thanks!
13:27:54 <dolio> Isn't that system-dependent?
13:28:23 <EvanR> there's various flavors of "not a valid character"
13:28:36 <EvanR> very fun stuff
13:28:58 <monochrom> Perhaps generalCategory, and if you get NotAssigned it's a bad sign. Sometimes PrivateUse too, depending on what you want.
13:29:15 <koz_> OK, thanks.
13:30:11 <monochrom> NotAssigned would be "illegal today but maybe in 2025 it is a newly assigned emoji"
13:30:37 <monochrom> To be sure, my wording "illegal" is lax.
13:30:47 <EvanR> there's literally "not a character" like \uffff
13:31:04 <EvanR> "FFFE and FFFF are not unassigned in the usual sense, but guaranteed not to be Unicode characters at all."
13:31:31 <monochrom> But you don't go around sending unassigned codepoints to people :)
13:31:35 <dolio> What is the purpose of that?
13:31:38 <dolio> Terminating your strings?
13:31:54 <monochrom> Ah, FFFE and FFFF would be Surrogate. You want to watch out for them especially.
13:31:54 <EvanR> FFFE is used for detecting byte order in utf-16
13:32:02 <EvanR> FFFF not sure
13:32:05 <dolio> Ah.
13:32:32 <monochrom> Actually I am only sure that FFFE is surrogate. haven't checked FFFF, could be NotAssigned
13:32:59 <koz_> @pl \i x -> foo (bar i) x
13:32:59 <lambdabot> foo . bar
13:34:39 <monochrom> Generally the whole surrogate block, from today's POV, is a relic of backward compatibility to utf-16.
13:34:46 <EvanR> FEFF is a byte order mark
13:35:43 <EvanR> so it's possible to see FFFE in utf-16 encoded bytes, so it can't be used as a character too
13:36:57 <EvanR> surrogates are for doing stuff beyond FFFF
13:38:40 <monochrom> oops, FFFE is NotAssigned
13:39:10 <EvanR> NotAssignInFactNeverWillBeAssignedDueToReasons
13:39:19 <monochrom> Yeah
13:39:35 <koz_> Won'tAssign
13:40:19 <monochrom> Surrogates are the D8xx block and the DCxx block.
13:43:01 <monochrom> Ah, even that is inaccurate. (The two blocks are each much larger.) I'll shut up now.
13:43:12 <EvanR> the byte reversed surrogates are "non characters"
13:43:25 <EvanR> according to this http://www.unicode.org/faq/private_use.html there are 66 non-characters
13:45:25 <monochrom> fun stuff
13:45:47 <monochrom> Math is so much easier. :)
13:45:49 <koz_> Conclusion: Writing is hard, we should go back to being illiterate.
13:45:58 <monochrom> I think we did?
13:46:16 <monochrom> The whole reason why GUI and icons as opposed to CLI.
13:47:24 <monochrom> It's like we decided that the Phoenician way (alphabet) is too hard, let's go back to the Egyptian way (icons).
13:47:56 <EvanR> normal fractions are too hard, go back to egyptian fractions
13:48:16 <koz_> Normal construction is too hard, go back to Egyptian construction.
13:48:26 <koz_> [insert the Ancient Aliens meme]
13:48:59 <koz_> https://i.imgflip.com/4gq65v.jpg
13:49:14 <EvanR> hey man, if i can learn some chinese after the age of 3 maybe there's hope for us all
13:49:34 <monochrom> Good for you.
13:50:16 <monochrom> But don't mistake your special gift for universal human trait.
13:50:22 <EvanR> that's what i'm saying
13:51:14 <EvanR> somehow people can look at random squiggles and it means something
14:28:47 * hololeap will build a colossal truncated dodecahedron out of peat moss
14:29:11 <pjb> That's a plan.
14:34:19 * hackage http-client-websockets 0.1.0.0 - Glue code for http-client and websockets  https://hackage.haskell.org/package/http-client-websockets-0.1.0.0 (amesgen)
15:17:49 * hackage free-categories 0.2.0.1 - free categories  https://hackage.haskell.org/package/free-categories-0.2.0.1 (echatav)
15:47:33 <somek> hello
15:49:14 <ski> hello
15:49:53 <koz_> hello
15:51:58 * ski looks at somek
15:58:03 * koz_ looks at somek
16:13:07 <carter01> Hello! Does anyone use Coc with the haskell language server? I can get codelenses to appear but I don't know how to apply them. Does anyone know how? Is there another vim setting that allows this?
16:24:49 * hackage free-categories 0.2.0.2 - free categories  https://hackage.haskell.org/package/free-categories-0.2.0.2 (echatav)
17:03:19 * hackage aeson-schemas 1.3.2 - Easily consume JSON data on-demand with type-safety  https://hackage.haskell.org/package/aeson-schemas-1.3.2 (leapyear)
17:43:27 <fog> hc: i was thinking about what you said about the presentation of structured concurrency starting from the dijkstra "goto considered harmful" and the corresponding "go statement considered harmful" and the parallels between the development of imperative programing and the corresponding containerised threading 
17:44:15 <fog> it seems like the progression was away from the turing tape style of jumping around within programs, to top down imperative style - and then to OOP and finally to functional programming
17:45:03 <fog> basically the key part is not from "goto style" programing with explicit line numberings like "basic" to imperative, but from imperative to OOP and functional 
17:45:59 <fog> basically, this gives the "syntax tree" order of evaluation, where referencing functions or methods replaces imperative or goto style for calling different sub-parts of a piece of code / program 
17:47:20 <fog> then, "structured concurrency" is similar to this - that instead of parallel threads, in the shape of a list of lists, with order of evaluation in imperative style - from top to bottom in code - that instead, the "subprocess tree" is built into syntax referencing trees
17:48:26 <fog> it seems then that lambda calculus, as an alternative way of ordering subcomponents of a program - has a duality with "structure concurrency" when supported by a similar syntax tree organising and referencing 
17:49:30 <fog> the presentation of structured concurrency then seems natural to occur within kotlin, where they have power over the syntax of the language as part of the language (arguably the key component of kotlin) 
17:50:27 <fog> and the natural question to ask then, is what support do we have for structured concurrency - or the syntax tree of concurrent subthreading - do we have in haskell
17:51:26 <fog> and similarly, what relation does structured concurrency have to lambda calculus - wrt to syntax trees, and how can this fit into the study of formal languages, particularly regarding type systems 
18:37:07 <woxip0> leave
18:37:39 <woxip0> quit
18:38:10 <Axman6> Thanks for coming to woxip0's demotivational talk for today
18:45:48 * hackage servant-client-js 0.1.0.0 - A servant client for frontend JavaScript  https://hackage.haskell.org/package/servant-client-js-0.1.0.0 (morganthomas)
18:48:49 * hackage serverless-haskell 0.12.3 - Deploying Haskell code onto AWS Lambda using Serverless  https://hackage.haskell.org/package/serverless-haskell-0.12.3 (AlexeyKotlyarov)
18:50:14 <monochrom> Merch at https://despair.com/ :)
19:09:47 <halogenandtoast> I feel like I am just tired, but does there already exist a function that does this? https://gist.github.com/halogenandtoast/bf48c58903b22b1720c297f0ca246484
19:10:06 <halogenandtoast> I feel like using a fold has to be overkill here.
19:12:46 <dolio> halogenandtoast: You could use First.
19:13:04 <dolio> It's not going to be a lot different, though.
19:14:09 <halogenandtoast> Yeah I considered using First here, but didn't, for that reason.
19:16:27 <Axman6> halogenandtoast: xs ?^ each . _BaseSkillOf
19:16:55 <dolio> Yeah, if you have some better building blocks it will help.
19:17:51 <halogenandtoast> Axman6: where is that lens coming from :p
19:17:57 <halogenandtoast> I surely did not write it
19:18:45 <vivekramaswamy> Hello All, I came here as there is no one in the haskell beginners channel, i really have a simple question. the type constructor for a list is defined as data [] a = [] | a
19:19:39 <vivekramaswamy> Hello All, I came here as there is no one in the haskell beginners channel, i really have a simple question. the type constructor for a list is defined as data [] a = [] | a:[a]  how can I construct a list with a single element using these data constructor for the list
19:19:43 <ski> there are people in there. however, there was just a netsplit, so perhaps that's why it didn't seem like way
19:19:53 <glguy> vivekramaswamy: this channel is fine for beginner questions
19:20:09 <ski> add an element to the empty list
19:20:13 <halogenandtoast> vivekramaswamy: a:[] ?
19:20:39 <vivekramaswamy> yeah but we dont have a data constructor like a:[]
19:20:57 <ski> so use multiple data constructors, when making a singleton list
19:21:17 <halogenandtoast> vivekramaswamy: you are misreading how that constructor is working there. It's recursive (if implemented correctly)
19:21:24 <glguy> vivekramaswamy: (:) and [] are the two data constructors for list
19:21:29 <vivekramaswamy> But this is a sum type, I can only use one of the constructors right
19:21:43 <ski> `[]' is the empty list. if `x' is an element, and `xs' is a list, then `x:xs' is the list that starts with the element `x', and continues with all the elements (possibly zero of them) in the list `xs'
19:22:02 <ski> why would you think that, vivekramaswamy ?
19:22:31 <halogenandtoast> vivekramaswamy: you are using one of the constructors, the constructor on the right just happens to be recursive.
19:23:04 <vivekramaswamy> where I am getting confused is this is a:[] == a:[a]
19:23:13 <halogenandtoast> One is a value, one is a type
19:23:24 <halogenandtoast> *data constructor
19:23:48 <ski> vivekramaswamy : `a:[a]' in `data [a] = [] | a:[a]' is a "template". it means that if you have `x' of type `a', and `xs' of type `[a]', then `x:xs' has type `[a]'
19:24:27 <ski> in place of actual values (left and right operand to the infix operator `:'), you have the expected types of those operands, in the `data' type declaration
19:24:37 <vivekramaswamy> to construct a list with a single element I will have to use one of the data constructors right. I can't use [], also the second constructors presumes a value already in the list a:[]
19:24:45 <ski> when actually using the data constructors, you'd use actual values of those two types
19:25:09 <ski> vivekramaswamy : the second one adds an element in front of an existing list
19:26:37 <vivekramaswamy> correct , an already existing list a:[a], but for a list with only one element it will cons to a:[] adding element to the empty list, where is that covered in the data constructors
19:26:39 <halogenandtoast> vivekramaswamy: you have to start with the premise that you are reading those constructors incorrectly which is why you don't see the solution yet.
19:26:40 <glguy> vivekramaswamy: Would it be less confusing if we used this definition:
19:26:41 <glguy> % data List a = Empty | Prepend a (List a)
19:26:46 <yahb> glguy: 
19:27:22 <glguy> That's the same thing with different names avoiding symbols and ambiguity between the type and value levels
19:27:22 <ski> % deriving instance Show a => Show (List a)
19:27:25 <yahb> ski: 
19:29:06 <Axman6> vivekramaswamy: the way that list is defined is quitre confusing to beginners, a better definition using GADT syntax is: data [] a where [] :: [a]; (:) :: a -> [a] -> [a] -- a list is EITHER: an empty list [] which has type [a] OR a (:) (pronounced "cons") with has a value of type a and a value of type [a]
19:29:10 <glguy> % Prepend "singleton" Empty
19:29:11 <yahb> glguy: Prepend "singleton" Empty
19:29:46 <Axman6> :t (:)
19:29:47 <lambdabot> a -> [a] -> [a]
19:29:50 <halogenandtoast> Axman6: beginners and GADT in the same sentence, what world is this?
19:30:03 <ski> that declaration means that `Empty' has type `List a' (for any type `a'); and also that `Prepend x xs' has type `List a' (for any type `a'), provided that `x' has (that) type `a', and `xs' has type `List a'
19:30:16 <ski> halogenandtoast : `GADTSyntax', not `GADT'
19:30:33 <Axman6> halogenandtoast: GDTS syntax is oftewn much easier for beginners to understand, as it;s much more consistent than the normal sum type syntax, which mixes constructors and the types they hold
19:30:52 <ski> vivekramaswamy : is glguy's alternative list type definition making any more sense to you, atm ?
19:31:33 <Axman6> > 1 : []
19:31:36 <lambdabot>  [1]
19:31:40 <Axman6> > (:) 1 []
19:31:42 <lambdabot>  [1]
19:31:57 <vivekramaswamy> Thank you very much for the help, but I am still very confused about this. Let me re -read all the messages again and try and make sense of them
19:32:11 <Axman6> :t []
19:32:12 <lambdabot> [a]
19:32:14 <Axman6> : (:)
19:32:18 <Axman6> :t (:)
19:32:19 <lambdabot> a -> [a] -> [a]
19:33:17 <vivekramaswamy> I get this 1:[], but where is this one covered in the 2 data constructors defines [] | a:[a]
19:33:31 <ski> vivekramaswamy : it uses both of the data constructors
19:33:35 <Axman6> those are the two main facts you need to understand vivekramaswamy. the syntax in data [] a = [] | a : [a] is confusing because it mixed types and constructors and doesn't make it clear that the [a] in that definition is _a type_ not a value
19:33:45 <vivekramaswamy> 2:[3] makes sense to me as it is covered by the data constructor
19:34:01 <Axman6> 2:[3] is _really_: 2:3:[]
19:34:29 <Axman6> [3] is special syntax, is it not how lists are actually defined
19:34:36 <ski> vivekramaswamy : first, `[]' is the empty list. then, you can use `:' to prepend an element `1' in from of that list (the empty list `[]', getting `1 : []'. that singleton list has syntactic sugar `[1]' which is what is shown, when evaluated, for convenience sake
19:34:39 <Axman6> > 1:2:3:[]
19:34:41 <lambdabot>  [1,2,3]
19:34:47 <Axman6> > 1:2:[3]
19:34:50 <lambdabot>  [1,2,3]
19:34:52 <Axman6> > 1:[2,3]
19:34:55 <lambdabot>  [1,2,3]
19:35:34 <ski> `[1,2,3]' means `1:[2,3]' means `1:(2:[3])' means `1:(2:(3:[]))'. we can omit the brackets (since `:' is specified to "associate to the right"), giving just `1:2:3:[]'
19:35:37 <vivekramaswamy> yeap I get that just as for many characters we define [Char] so [a] means [a,a, as many elements of type a]
19:36:19 <Axman6> strings are yet another special syntax
19:36:21 <vivekramaswamy> a:[a] means consing a to a list of type a which is fine.
19:36:44 <ski> `1:(2:(3:[]))' or `1:2:3:[]' is the "real list of three elements". `[1,2,3]' is just a convenient way ("syntactic sugar") to write it, in a form that's more appealing to humans
19:36:46 <Axman6> > 'a':['b','c']
19:36:46 <glguy> vivekramaswamy: [a] as a value is a special shortcut you should forget about until you udnerstand what's happening without it
19:36:49 <lambdabot>  "abc"
19:37:03 <ski> vivekramaswamy : `x:xs' means consing/prepending `x' in front of the list `xs'
19:37:51 <ski> > let xs = []; ys = 0 : xs; zs = 1 : ys in (xs,ys,zs)
19:37:53 <vivekramaswamy> "abc" is actually 'a':'b':'c':[]  I get that 
19:37:54 <lambdabot>  ([],[0],[1,0])
19:38:26 <ski> vivekramaswamy : is there anything remaining, that's unclear ?
19:38:58 <Axman6> halogenandtoast: coming back to your question, some template haskell defined that prism for you ;)
19:39:11 <vivekramaswamy> Nope, I think I get it now, thanks a ton to all of you
19:39:18 <ski> np
19:40:18 <Axman6> vivekramaswamy: I can't actually see you asking that question in #haskell-beginners btw, when did you ask it?>
19:40:41 <ski> Axman6 : perhaps during the netsplit
19:41:30 <ski> (there was one, just before they asked in here)
19:43:07 <ski> (or, possibly they thought noone was paying any attention to that channel, since there was no current discussion in there. .. who knows ?)
19:54:16 <vivekramaswamy> I did not, as fount the channel empty
19:54:23 <vivekramaswamy> found
19:55:06 <Axman6> the channel definitely isn't empty
19:55:56 <ski> if you'd tried asking saying in there, then not that unlikely some people would have noticed, and possibly some have responded
19:57:32 <MarcelineVQ> no matter, asking here is fine too :>
19:57:38 <ski> (although, if you'd tried during the netsplit (which just happened to take place just before you started talking in here), when perhaps not as many would have been in there, on your server side of the netsplit, the chance would presumably have been lowered)
19:57:43 <ski> yes
20:29:49 * hackage text-conversions 0.3.1 - Safe conversions between textual types  https://hackage.haskell.org/package/text-conversions-0.3.1 (lexi_lambda)
20:45:40 <sim590> How can I download a package with cabal globally, build it globally and then build my project that uses the same library without building it again?
20:46:06 <sim590> and I mean all of that before switching to the directory containing my project.
20:47:36 <sim590> I don't want to download and build the library more than once.
20:49:03 <Axman6> I think that happens with the new style builds, identical builds should be shared between projects AFAIUI
20:50:35 <Guest_91> Hello after you install Haskell on OS X how do you start running it
20:50:50 <Axman6> what do you want to start? ghci?
20:50:56 <sim590> OK. I'm building a docker image. I'm trying this: https://paste.debian.net/1165214/. It's essentially copying my cabal file and building the project libraries there.
20:51:04 <Axman6> most of what is installed is a compiler
20:51:49 <sim590> Shouldn't this make it so that if I run a build of the same project inside the resuting image, I should be able to build my project without downloading/building all of the dependencies?
20:52:40 <Guest_91> yes ghci
20:52:49 <Axman6> run ghci in the termina;
20:52:52 <Axman6> l*
20:53:26 <Guest_91> I tried that and it gives command not found
20:53:50 <Axman6> open a new terminal and try again, your PATH won't be updated in an already open terminal
20:54:01 <Axman6> how did you install things?
20:55:35 <sim590> Shouldn't this: https://i.imgur.com/GtUn39G.png work? One of my dependencies is Colog.
20:56:13 <Guest_91> thanks! it was the opening of new term window
20:56:27 <Axman6> have you loaded the Colog module? :m +Colog.Monad
20:57:04 <Axman6>  :l(oad) is for local modules, :m(odule) loads modules visible to GHC
20:57:26 <Axman6> (that's a really poor explanantion, but basically any library would be loaded with :m)
21:00:49 <sim590> it doesn't work: https://i.imgur.com/BkeFbYY.png
21:00:59 <sim590> Normally, it would say to load the package first or something, no?
21:01:03 <sim590> Anyway, it doesn't load.
21:05:31 <sim590> That's the output when I'm building the docker image: https://i.imgur.com/74FKwjQ.png
21:06:11 <Axman6> without knowing more about what you've done there's no way to know how to help.
21:06:29 <sim590> What I did is in the docker image.
21:09:26 <sim590> I've published my latest attempt at docker.io/sim590/hart
21:10:12 <Axman6> "Ahoy, it looks like you are in uncharted waters"
21:10:54 <sim590> Yeah the URL is https://hub.docker.com/repository/docker/sim590/hart, but the image is named sim590/hart. Tag can be :latest, so sim590/hart:latest.
21:11:36 <sim590> You could inspect it with `docker run -it sim590/hart:latest bash` if you could then tell me what's wrong.
21:13:03 <sim590> I do have 891M  of stuff inside /root/.cabal.
21:13:39 <Axman6> I'm not going to run untrusted docer images on my machine, sorry. what does running a shell in it and running ghc-pkg list show?
21:15:30 <sim590> When looking inside ~/.cabal for co-log with docker run -it sim590/hart:latest find /root/.cabal -name \*co-log\*, I get this: https://paste.debian.net/1165215/
21:16:13 <sim590> ghc-pkg list shows: https://paste.debian.net/1165216/.
21:16:16 <Axman6> and if you run ghci -package co-log?
21:17:46 <Axman6> and what happens if instead of using ghci directly, you use cabal new-repl?
21:18:05 <Axman6> (I think that's a thing, I haven't used cabal directly for a long time)
21:18:23 <sim590> ghci -package co-log: https://paste.debian.net/1165217/
21:19:37 <sim590> So the last command I did, I did move from /opt/hart to do this because I wanted to move from it to see if package was globally there.
21:20:33 <sim590> now after doing `cabal new-repl̀ from inside the /opt/hart directory, it's building stuff like https://paste.debian.net/1165218/
21:21:05 <sim590> But I thought it would have built already.
21:21:52 <sim590> But it won't be able to build `hart` since the code is not inside the image.
21:22:05 <Axman6> how are docker so bad a things. can;t even get the docker hub page to load again
21:22:05 <sim590> I just pushed my cabal file.
21:22:24 <sim590> The URL I gave you?
21:22:37 <Axman6> can you paste your docker file in dpaste? I can't load docker hub any more
21:23:51 <sim590> ␒The docker file is:https://paste.debian.net/1165214/
21:30:29 <sim590> OK. I just tried to do a new-install --only-dependencies after doing a new-build --only-dependencies and I think that it is wokring. Not sure, but I can now load the package inside ghci with -package co-log
21:31:11 <sim590> I did new-install --lib --only-dependencies -j4 actually
21:33:05 <sim590> I'm trying to rebuild the image now https://paste.debian.net/1165220/ and see if it fixes it.
21:34:37 <bobajett> how can I write the function p where p [0,0,1,2,0,0,3,0] == [[1,2], [3]] ? (Noobie question)
21:35:06 <glguy> > let f [0,0,1,2,0,0,3,0] = [[1,2], [3]] in f [0,0,1,2,0,0,3,0]
21:35:09 <lambdabot>  [[1,2],[3]]
21:35:18 * hackage homura-stopwatch 0.2.0 -   https://hackage.haskell.org/package/homura-stopwatch-0.2.0 (ncaq)
21:35:20 <bobajett> :-)
21:35:31 <Axman6> nailed it
21:35:35 <Axman6> NEXT!
21:36:20 <sim590> bobajett: It seems like you want subwords that don't contain a 0.
21:37:18 <bobajett> yes please, I've been trying to use span and dropWhile and I just can't come up with some recursive function to solve it.
21:37:54 <Axman6> :t groupBy
21:37:56 <lambdabot> (a -> a -> Bool) -> [a] -> [[a]]
21:38:05 <MarcelineVQ> span is a pretty good choice tho
21:38:23 <Axman6> might be useful - but there are also likely to be simpler solutions
21:45:11 <MarcelineVQ> looking at the definition of span could be instructive, there's a really neat trick that recursion allows you to do that it uses
21:47:27 <MarcelineVQ> Which is that we can use the result of our own function in its definition, see how span is used in span?
21:47:30 <MarcelineVQ> @src span
21:47:30 <lambdabot> span _ xs@[]                  = (xs, xs)
21:47:30 <lambdabot> span p xs@(x:xs') | p x       = let (ys,zs) = span p xs' in (x:ys,zs)
21:47:31 <lambdabot>                   | otherwise = ([],xs)
21:57:24 <sim590> > filter (all (/=0)) $ groupBy (\ a b -> a*b /= 0) [0,0,1,2,0,0,3,0]
21:57:27 <lambdabot>  [[1,2],[3]]
21:58:31 <p0a> Hello I was just reading the release notes for GHC 9.0.1
21:59:02 <p0a> I noticed that the LinearTypes extension is now included. I read a bit about it and I think I sort of get the basic idea behind it
21:59:43 <p0a> there's something in the motivation (on github/ghc-proposals) I don't understand: they mention that the type system itself can not discriminate between open-close and close-open file operations
22:00:00 <p0a> i.e. you can open a file and then close it, but you shouldn't be able to close a file and then operate on it
22:00:20 <p0a> I don't understand how LinearTypes solves this problem. Can someone explain? Thanky ou 
22:00:34 <c_wraith> It doesn't.
22:00:46 <p0a> okay. :) 
22:00:55 <c_wraith> uniqueness types would, but linearity is insufficient.
22:01:31 <p0a> https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0111-linear-types.rst#motivation reads weird then
22:01:38 <dolio> I don't think uniqueness types would solve that case.
22:02:02 <c_wraith> *maybe* you could do an entire CPS-transformed IO system such that linearity would matter, but... ugh.
22:02:41 <c_wraith> I really don't want to do IO with explicit continuations.
22:03:07 <dolio> Anyhow, the way you'd solve it with linearity is something like: change all file operations to operate on linear handles, and return a new handle as a result if appropriate. Closing consumes a handle but doesn't give you a new one.
22:03:23 <c_wraith> and I'm not feeling charitable towards using OverloadedSyntax to make do notation work around CPS
22:03:44 <p0a> dolio: I don't see how linearity is involved in this scheme 
22:03:59 <c_wraith> dolio: linear haskell only adds linear functions, not values.
22:04:18 <davean> The whole LinearTypes GHC proposal baffles me
22:04:36 <p0a> we've been had
22:04:47 <dolio> The handle arguments are linear.
22:05:46 <dolio> p0a: You are only allowed to use any handle once (and must use it once). Each operation consumes a handle and produces a new handle as a result, except close which just consumes the handle.
22:06:22 <c_wraith> dolio: but how is that enforced?  Are you assuming a world where (>>=) has linear annotations?
22:06:25 <p0a> dolio: so the part where linearity kicks in is ensuring that the interface does not allow you to mix and match the operations in such a way that you operate in a closed handle
22:06:42 <p0a> dolio: because it'd require you to operate twice in the same handle
22:06:58 <dolio> c_wraith: Yeah. They have some kind of linear monad notion, too.
22:07:07 <dolio> I'm not really familiar with the details.
22:07:24 <c_wraith> I really don't think that works, in the end...
22:07:37 <c_wraith> If for no other reason, it destroys the ability to abstract over monads.
22:07:40 <dolio> p0a: Right.
22:07:55 <c_wraith> Because you want IO to be linear, but [] can't be linear...
22:08:27 <dolio> Linear monads are a separate type class. And IO isn't linear, I think, but there's a LIO maybe. Like I said, I don't know the details.
22:08:44 <dolio> They use some kind of do overloading for linear monads.
22:08:44 <c_wraith> I just don't see it actually improving anything.
22:09:08 <dolio> Well, I'm not saying it'll be good. I'm just saying what it would be. :)
22:09:11 <p0a> It sounds good to me c_wraith 
22:09:54 <dolio> How good it is remains to be seen.
22:10:06 <p0a> I wonder what happens with concurrency and that idea though
22:11:25 <p0a> Maybe that is not an issue. I actually have not written any concurrent programs so I wouldn't know 
22:12:15 <sim590> Axman6: it's great. It works now with my build + install instruction.
22:14:33 <Axman6> great
22:14:46 <MarcelineVQ> p0a: fwiw linear arrows restrict how you use arguments not results.    foo :: a -* (a, b)  says that if `foo` is used I promise to use the argument `a` exactly once, it does not say anyting at all about what we're allowed to do with the (a,b)
22:15:24 <MarcelineVQ> To that end   boop : a -* (a,Int); boop x = (x,0)   is entirely valid, and what dolio is probably referring to when he says return a new handle
22:17:17 <p0a> MarcelineVQ: I don't think returning a new handle is important (it could be the same handle, we wouldn't know anyway), other than to have something to continue operating on
22:17:28 <p0a> I.e. I don't know if being 'new' is important. Could be the same 
22:18:04 <p0a> a simple interface would be f :: Int %1 -> Int and g :: Int -> Bool where f x = x + 1 and g x = x == 0. 
22:18:16 <p0a> (Sorry, I should've written g :: Int %1 -> Bool)
22:19:06 <p0a> so you can't do \x -> (f x, g x)
22:19:38 <dolio> The important part is how the API forces the user to work, not the implementation of the API.
22:20:00 <p0a> That's true I just wrote the implementation of f and g as an example. The types were what mattered
22:20:20 <p0a> f would be 'operate on file' and g would be 'close the file'
22:20:31 <dolio> If the result of a linear function arrow is unrestricted, I'm not exactly sure how it'd be accomplished. I guess CPS.
22:21:37 <xxasiaj> hi , does anyone knows how to setup haskell in arch ? and also GHCi
22:22:03 <MarcelineVQ> xxasiaj: ghcup is the method I'd reccomend
22:22:04 <koz_> xxasiaj: I would suggest using ghcup.
22:22:07 <koz_> MarcelineVQ: Jinx?
22:22:14 <yushyin> ghcup it is!
22:22:29 <MarcelineVQ> You can get it from the AUR
22:22:41 <xxasiaj> thanks
22:23:02 <xxasiaj> from AUR i could only get GHC not GHCi
22:23:12 <Axman6> ghci is ghc
22:23:15 <MarcelineVQ> ghci comes with ghc which ghcup will get you :>
22:23:30 <MarcelineVQ> Yes, technically it's just a wrapper for  ghc --interactive
22:24:04 <xxasiaj> oh that's great then . thanks
22:24:36 <MarcelineVQ> I'd also remove any haskell things you have installed from pacman already before you use ghcup
22:25:04 <xxasiaj> how to do that
22:25:25 <xxasiaj> i think i also installed stack
22:25:36 <Axman6> did Arch unbreak all the Haskell stuff they broke a few years ago? It went from being one of the OSs of choice to being seemingly unusable overnight
22:25:51 <yushyin> xxasiaj: pacman -Rsuc ghc ghc-lib stack # is my guess
22:26:19 <p0a> Axman6: isn't the issue with dynamic linking being enforced?
22:26:54 <Axman6> I don't remember the details but that sounds samilliar
22:27:00 <Axman6> familiar*
22:27:31 <MarcelineVQ> I'm not actually sure! I'd check pacman -Qs haskell  first and see what pops up
22:28:12 <yushyin> Axman6: p0a: yes, dynamic linking is still the default for arch's haskell packages, but at least it does provide a ghc-static if wanted
22:29:43 <xxasiaj> MarcelineVQ : this is what appeared : pacman -Qs haskelllocal/ghc-libs 8.10.2-1    The Glasgow Haskell Compiler - Dynamic Librarieslocal/haskell-async 2.2.2-23    Run IO operations asynchronously and wait for their resultslocal/haskell-base16-bytestring 0.1.1.7-3    Fast base16 (hex) encoding and decoding for
22:29:43 <xxasiaj> ByteStringslocal/haskell-base64-bytestring 1.2.0.0-6    Fast base64 encoding and decoding for ByteStringslocal/haskell-cryptohash-sha256 0.11.101.0-17    Fast, pure and practical SHA-256 implementation....
22:30:57 <p0a> Axman6: It seems that the issues are fixed
22:32:12 <yushyin> xxasiaj: if you really want to remove it just do pacman -Rsuc ghc-libs but you can just use ghcup anyways
22:32:14 <p0a> Axman6: the experience will be different from other distros, but you are not left in a state where you don't know what to do, or can't do what you want; the wiki has details
22:34:44 <Axman6> The Arch wiki always has details, it's the best thing about Arch :)
22:58:49 * hackage flink-statefulfun 0.3.0.0 - Flink stateful functions SDK  https://hackage.haskell.org/package/flink-statefulfun-0.3.0.0 (tdbgamer)
23:57:52 <sim590> How can I create a wrapper around integers that can be instanciated just with an Integer (without needing to write teh constructor). Like Integer and Int can both instanciate with the same digit glyphs.
