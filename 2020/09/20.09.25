00:01:23 <glguy> > isJust Just{}
00:01:25 <lambdabot>  True
00:01:36 <glguy> > isJust Nothing {}
00:01:38 <lambdabot>  False
00:02:17 <glguy> Not really pattern-specific. It's record notation
00:06:10 <dminuoso> Mmm, this does seem a bit inconsistent. Usually a pattern matches values constructed in the same fashion
00:06:20 <dminuoso> But Just{} does *not* match values exactly constructed by Just{}
00:12:35 <solonarv> this is already not true for record patterns
00:13:04 <solonarv> @let data Two = Two { two1 :: Int, two2 :: Int } deriving (Show, Eq, Ord)
00:13:07 <lambdabot>  Defined.
00:13:32 <solonarv> > case Two { two1 = 1, two2 = 2 } of Two {two1 = 1} -> "ok"
00:13:34 <lambdabot>  "ok"
00:22:16 <Axman6> > let x = x { two1 = 1 } in case x of Two{two1 = 1} -> "ok"
00:22:19 <lambdabot>  "*Exception: <<loop>>
00:31:59 <solonarv> interesting, I sort of expected x = Two 1 _|_ here
00:41:19 * hackage sized 0.8.0.0 - Sized sequence data-types  https://hackage.haskell.org/package/sized-0.8.0.0 (HiromiIshii)
00:43:49 * hackage mmsyn6ukr 0.8.1.0 - A musical instrument synthesizer or a tool for Ukrainian language listening  https://hackage.haskell.org/package/mmsyn6ukr-0.8.1.0 (OleksandrZhabenko)
00:59:18 * hackage phonetic-languages-ukrainian 0.2.1.0 - Prepares Ukrainian text to be used as a phonetic language text  https://hackage.haskell.org/package/phonetic-languages-ukrainian-0.2.1.0 (OleksandrZhabenko)
01:25:49 * hackage uniqueness-periods-vector-examples 0.6.0.0 - Examples of usage for the uniqueness-periods-vector series of packages  https://hackage.haskell.org/package/uniqueness-periods-vector-examples-0.6.0.0 (OleksandrZhabenko)
02:34:30 <justsomeguy> Is there a function like (!!) that also works for negative indices?
02:37:45 <Rembane> justsomeguy: When you do let xs = [1,2,3,4] in xs !! (-2), what result do you expect?
02:37:56 <justsomeguy> 3
02:38:39 <solonarv> ah, indexing from the other end like python does?
02:39:11 <Rembane> justsomeguy: You can do let f i xs = xs !! (length xs + i)
02:39:17 <Rembane> justsomeguy: But it's incredibly expensive.
02:39:20 <Jajik> then reverse it and use (!!) . abs, but the list is not the best structure for that
02:39:49 <justsomeguy> Should I be using Data.Array, instead? (...and does it support negative indices?)
02:40:17 <justsomeguy> solonarv: Exactly. I had pythons subscript notation in mind.
02:40:17 <solonarv> if you want to index to arbitrary positions (especially near the end), you probably shouldn't be using lists, yes
02:40:27 <MarcelineVQ> if you need arbitrary indexing vector or array will serve you better, on a list of 4 items I wouldn't sweat the small stuff
02:40:32 <Rembane> justsomeguy: Use Data.Vector, it has a nicer API 
02:40:54 <solonarv> array or vector have efficient indexing (I recommend vector due to the nicer API, especially if you only care about Int indexes)
02:41:13 <solonarv> it doesn't have this "wraparound" indexing but you can easily build it
02:42:18 <solonarv> xs !* n | n < 0 = xs ! (n + length xs) ; otherwise = xs ! n
02:51:15 <phadej> what [1,2,3,4] !! -10 would do?
02:51:49 <phadej> generally, I consider !! a smell in Haskell.
02:54:45 <MarcelineVQ> that's the entire definition, modulo modulo
03:10:39 <maerwald> there's no forkFinally equivalent in async?
03:21:48 * hackage Z-IO 0.1.1.2 - Simple and high performance IO toolkit for Haskell  https://hackage.haskell.org/package/Z-IO-0.1.1.2 (winterland)
03:55:29 <maralorn> That reminds me of the horrible time I worked with a custom language for evaluating measurements of certain measurement devices written by the vendor. In there arrays where the primary data structure for stuff like time series of an oscilloscope.
03:56:24 <maralorn> I lost at least on day to debugging, before I learnad that their indexing operator gave you the last element of an array when you gave it an out-of-bounds index (silently without any error message).
03:57:22 <maralorn> I don‘t want to know how many published experimental results are secretly wrong because of that crazy language design decision. /o\
04:16:56 <dminuoso> Mmm, I wish more code would be written MonadIO polymorphic. :(
04:17:21 <dminuoso> The amount of liftIO sprinkling is getting somewhat annoying
04:18:54 <kenran> dminuoso: I second that... 
04:46:30 <maerwald> don't use transformers
04:46:33 <maerwald> :p
04:47:08 <[exa]> isn't this "solved" in some of the alternative preludes? (rererebase?)
04:50:52 <maerwald> transformers look like an effects DLS, but they feel like an OOP pattern
04:51:22 <dminuoso> maerwald: This has nothing to do with transformers.
04:51:48 <maerwald> how so?
04:52:10 <dminuoso> [exa]: an alternative prelude would give you huge transitive dependency footprints if this is done widely
04:52:17 <dminuoso> My beef is not just with base, but packages in general.
04:52:31 <maerwald> why are you using liftIO if you don't have any transformers in your code
04:52:41 <fendor> can I derive Monoid and Semigroup for a datatype where all fields are an instance of semigroup and monoid?
04:53:52 <dminuoso> maerwald: You can write monads yourself too.
04:54:10 <phadej> fendor: yes, look at semigroups Data.Semigroup.Generic
04:54:32 <fendor> phadej, thanks! 
04:54:36 <dminuoso> fendor: generic-deriving has the facilities
04:54:48 <[exa]> dminuoso: i said it's "solved" :]
04:54:55 <maerwald> dminuoso: yes, you can write transformers yourself
04:54:56 <dminuoso> heh fair
04:55:37 <maerwald> but you don't seem to want to disclose what you're doing, so I'm not gonna pull it out of your nose :p
04:55:49 <dminuoso> maerwald: A transformer is a higher order utility to transform monads into monads. If I just create a data type myself, Im not using any transformer, am IO?
04:56:15 <dminuoso> Oh hah. That muscle memory tricked me into writing IO.
04:58:19 <maerwald> dminuoso: you're writing an instance of MonadIO? Then you have a transformer
04:59:38 <dminuoso> maerwald: `ReaderT e` is a transformer. Neither the type `ReaderT Env IO`, nor a type isomorphic to `ReaderT Env IO` is a transformer.
05:00:05 <maerwald> "Instances should satisfy the following laws, which state that liftIO is a transformer of monads"
05:01:45 <dminuoso> Is that not rather a monad homomorphism?
05:02:24 <dminuoso> The documentation seems just a bit off
05:15:37 <AWizzArd> I am using the nix-shell to produce a development environment. But it’s only a thin layer, I still rely on my OS offering tools. So my shell is not --pure and I expect that for example Emacs is available.
05:15:41 <AWizzArd> At some point though I want to use Nix (not necessarily its shell) to produce a Docker image for me.
05:15:44 <AWizzArd> Now I want to use SSL and will need cacerts in the resulting docker images. In an Ubuntu-based Dockerfile I would apt install ca-certificates.
05:15:48 <AWizzArd> So I will have to teach Nix that the standard certs are a dependency for my app. Doesn’t that mean that those certs will *also* be available in my nix-shell?
05:29:13 <kuribas> how do I add a package in a ghci session?
05:29:46 <hekkaidekapus> :set -package
05:30:40 <maerwald> AWizzArd: there's a nixos channel
05:31:07 <AWizzArd> maerwald: and this is where I just repeated/reframed this question :)
05:31:57 <AWizzArd> maerwald: tho I also would like to hear/read inputs of other Haskellers about how they work with Nix. Is that style "correct"? Do you specify the deps you need, run a nix-shell and from IT then start your ide?
05:31:59 <kuribas> hekkaidekapus: thanks, that works :)
05:32:15 <hekkaidekapus> o/
05:48:18 * hackage phonetic-languages-ukrainian 0.2.2.0 - Prepares Ukrainian text to be used as a phonetic language text  https://hackage.haskell.org/package/phonetic-languages-ukrainian-0.2.2.0 (OleksandrZhabenko)
05:54:54 <Unhammer> anyone using IHP here? I don't understand how to do a nested Include/fetchRelated
05:56:25 <Unhammer> say, in the First Project guide you wanted to add post categories, but show comments on the category index page – can one do something like `Include "comments" (Include "posts" Category)` ? 
06:00:49 * hackage uniqueness-periods-vector-examples 0.6.1.0 - Examples of usage for the uniqueness-periods-vector series of packages  https://hackage.haskell.org/package/uniqueness-periods-vector-examples-0.6.1.0 (OleksandrZhabenko)
06:10:33 <maerwald> is there an easy way to programmatically figure out if a package is on hackage? (preferably via the local index)
06:12:30 <Unhammer> hm, was easier to just define my own view type, e.g. a single category page is
06:12:32 <Unhammer>  data ShowView = ShowView { posts :: [Include "comments" Post], title :: Text }
06:12:34 <Unhammer> and manually make that in ShowCategoryAction
06:13:59 <fendor> maerwald, there is hackage-index https://github.com/haskell-hvr/hackage-index, I *think* that used a local index.
06:15:17 <maerwald> fendor: that package isn't on hackage :(
06:15:33 <int-e> fendor: yeah looks like it maintains its own local sqlite database
06:16:47 <int-e> maerwald: At a glance, the cabal-install package index format seems to be buried in the client code (Distribution.Solver.Types.PackageIndex) so it's not readily available as a library :-/
06:17:12 <int-e> (Unless somebody took it upon themselves to strip that part out and maintain it as a library.)
06:17:32 <maerwald> there's a lot of stuff in cabal-install that should be exposed imo, but well
06:19:05 <phadej> maerwald: yes, see cabal-install-parsers
06:19:13 <fendor> indeed. I wish I could parse cabal specification without a Cabal dependency.
06:19:23 <phadej> fendor: good luck :)
06:20:03 <phadej> (my gut feeling is that over half of code lines in Cabal is related to parsing cabal specification)
06:20:57 <fendor> I know :/
06:21:19 <fendor> (regarding the "good luck wish")
06:23:09 <maerwald> https://hackage.haskell.org/package/cabal-install-parsers-0.3.0.1/docs/Cabal-Index.html#v:cachedHackageMetadata cool
06:35:20 <maerwald> phadej: when is 3.4 coming out?
06:37:51 <kuribas> is there a pretty runClientM for the REPL?
06:38:24 <oats> it's fun reading "low level" code in, eg, bytestring internals
06:38:40 <oats> nice to remember that you can still do black magic with pointers if you really want to :P
06:39:14 <kuribas> oats: indeed, what's nice in haskell is that it hides the uglyness
06:39:35 <kuribas> but you can still write ugly code underneat
06:40:21 <oats> indeed
06:40:41 <oats> maybe I should get my hands dirty and put my C skills to use here sometime :P
06:41:32 <kuribas> it's also often used to interface with a low level C library
06:49:42 <kuribas> otherwise I rarely find a need to write low level code in haskell
06:50:05 <sooch> How would one go about representing an Identifier that can be either a single id, or multiple id's combined to form an id
06:51:26 <sooch> Ex:  S = { ident = 1}; S2 = {ident = 2}; => S <> S2 = { ident (2 3)};
06:53:40 <hekkaidekapus> sooch: Something like `f {ident = x} {ident = y} = {ident = x <> y}`?
06:54:06 <kuribas> sooch: data Ident = Ident (NonEmpty Int) ?
06:55:25 <sooch> The identity can be anything, and is unique. I guess I want a way more like: Ident a = Single a | Multi a (Single a
06:55:31 <sooch> but that seems wrong
06:56:07 <kuribas> data Ident a = Ident (NonEmpty a)
06:56:13 <phadej> maerwald: i dont know. around ghc-9
06:57:40 <sooch> kuribas: I misinterpreted what NonEmpty was at first, that looks promising. Thanks.
07:20:49 <AWizzArd> maerwald: about Servant again: I didn’t try it out yet, but it seems to be able to automatically generate the exact documentation of my API, so the docs will always be relevant and stay up-to-date.
07:21:33 <hc> it can even export an up-to-date swagger specification using servant-swagger :)
07:22:10 <maerwald> AWizzArd: you mean swagger?
07:22:25 <maerwald> I think about a million backends have support for that?
07:22:53 <AWizzArd> maerwald: do you have a link at hand for Snap?
07:23:02 <maerwald> not right now
07:26:29 <AWizzArd> hc: what is good about a swagger spec? (never used that tool, but knowing its name)
07:27:07 <hc> AWizzArd: anyone(TM) will know how to use your API
07:27:40 <hc> you could say it is a transformation of the servant API type declaration into a json representation of it that many tools can understand
07:28:24 <hc> AWizzArd: have a look at https://editor.swagger.io/ ; I find that a pretty handy tool for looking at swagger specs
07:28:42 <AWizzArd> hc: is this tool mostly for web apis? Or completly generic for any api that I may want to design?
07:28:51 <hc> it's for REST APIs only afaik
07:29:03 <hc> which arguably aren't tied to the web
07:29:29 <hc> but it's not as generic as i.e. apache thrift or the likes
07:31:13 <dolio> oats: You probably don't want to copy the pointer stuff in bytestring, though. The array stuff in primitive is generally better.
07:31:34 <dolio> Bytestrings are prone to memory fragmentation.
07:32:30 <oats> hmmm, thanks for the tip
07:33:21 <dolio> Also vector builds on primitive in various ways.
07:56:19 * hackage lapack 0.3.2 - Numerical Linear Algebra using LAPACK  https://hackage.haskell.org/package/lapack-0.3.2 (HenningThielemann)
07:57:10 <miguel_clean> Hello
07:57:55 <miguel_clean> I am playing with the "+RTS -p" flag and wonder if I have to wait for my programm to exit or can have it updated in some intervalls as well?
07:58:18 <geekosaur> you have to wait for normal program exit
07:59:19 <shad0w_> hi fam
07:59:39 <shad0w_> i learned about Aplicatives today
07:59:43 <shad0w_> and i have a question
08:00:26 <shad0w_> they seem similar to Functors with the addtinal container type with the f (a -> b) for the first argument
08:00:45 <shad0w_> i was wondering, why do they exist ?
08:01:06 <shad0w_> we can probably do all of that stuff with fmap
08:02:32 <dolio> Try implementing (<*>) with just fmap.
08:02:38 <dolio> Or pure.
08:07:40 <sm[m]> live output from +RTS -p would be great
08:08:37 <geekosaur> I think you can do something similar with the eventlog?
08:08:47 <sm[m]> hstop myprog
08:09:21 <sm[m]> I need to learn about this stuff
08:11:35 <geekosaur> one problem with live profiling is laziness, stuff can be waiting to be evaluated and will be lost even though in some sense it's been seen
08:11:58 <shad0w_> dolio: isn't fmap g x = pure g <*> x ?
08:12:17 <geekosaur> and only show up later in the run when forced, possibly at the end
08:12:29 <hololeap> shad0w_: if you think of a Functor f as carrying with it some kind of "context" or "other information", then Applicative gives a way to lift a value into a "default context" (pure) and combine two of these contexts (<*>)
08:13:10 <geekosaur> shad0w, yes, but that means you can recover fmap from pure and <*>, not that you can recover either pure or <*> from fmap
08:13:54 <shad0w_> geekosaur: i could just use fmap without ever using pure or <*> can't i?
08:13:56 <geekosaur> so Functor is not sufficient to replace Applicative. in fact it's a prerequisite for Applicative, but not enough by itself
08:14:47 <geekosaur> Applicative can do things fmap can't, otherwise we wouldn't have it
08:15:00 <geekosaur> for example, you can parse with an Applicative but not with a Functor
08:15:15 <shad0w_> that's what i am trying to understand. why does this even exists /
08:15:42 <dolio> How do you implement `(a -> b -> c) -> f a -> f b -> f c` with just fmap?
08:16:30 <shad0w_> you probably can't since fmap :: (a -> b) -> f a -> f b
08:16:36 <dolio> Right.
08:16:49 <shad0w_> can b  == (b -> c ) ?
08:16:57 <sm[m]> in the example stats at https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/runtime_control.html#rts-options-to-produce-runtime-statistics, max_bytes_used is 1065272 and peak_megabytes_allocated is 3. How/are those related ?
08:16:58 <dolio> It can.
08:17:04 <shad0w_> ^ sorry if that sounds stupid 
08:17:07 <dolio> Then your result is `f (b -> c)`.
08:17:12 <geekosaur> but that doesn't help because ... that
08:17:35 <int-e> :t (<*>)
08:17:37 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
08:17:54 <geekosaur> and now you need Applicative to go any further
08:18:01 <int-e> that's the type you need to continue from f (b -> c)
08:18:52 <shad0w_> so, it becomes usefull if your first argument is (a -> b -> c ) ?
08:19:33 <dolio> It becomes useful if you have any number other than 1 of your `f` things that you want to do something with.
08:19:59 <dolio> pure lets you build an `f` thing if you have 0.
08:20:01 <shad0w_> so you could g <$> x1 <*> x2 ?
08:20:15 <dolio> And (<*>) lets you combine two `f` things into one.
08:21:19 <shad0w_> dolio: say i want to add Just 6 and Just 7 
08:21:27 <shad0w_> then that's an applicative job ?
08:22:12 <int-e> :t liftA2 (+)
08:22:13 <lambdabot> (Applicative f, Num c) => f c -> f c -> f c
08:22:41 <hololeap> shad0w_: that's correct
08:22:54 <int-e> @src liftA2
08:22:55 <lambdabot> liftA2 f a b = f <$> a <*> b
08:23:28 <hololeap> > (+) <$> Just 6 <*> Just 7
08:23:31 <lambdabot>  Just 13
08:23:31 <kuribas> how do you experiment in ghci with new-style builds?  It doesn't let me import libraries (like pretty-simple)
08:23:42 <hololeap> > (+) <$> Nothing <*> Just 7
08:23:45 <lambdabot>  Nothing
08:24:28 <kuribas> is there a way to configure an interactive test environment in the cabal file?
08:24:40 <shad0w_> > (\x y z -> x + y +z) <$> Just 1 <*> Just 2 <*> Just 3
08:24:43 <lambdabot>  Just 6
08:24:54 <shad0w_> ^Thanks bot
08:25:05 <sm[m]> isn't new-style a confusing term at this point
08:25:06 <shad0w_> i kindda get it now.
08:25:16 <shad0w_> thanks guys : D
08:25:18 <sm[m]> kuribas: cabal repl doesn't work ?
08:25:36 <kuribas> sm[m]: it doesn't let me import packages outside of the project
08:25:46 <hololeap> shad0w_: look up and read typeclassopedia for more details
08:26:00 <shad0w_> i am reading that
08:26:00 <hololeap> when you're ready
08:26:06 <kuribas> sm[m]: well in ghci it works...
08:26:13 <sm[m]> kuribas: ah, that's normal. Perhaps you can bring in more by using a -package option
08:26:51 <kuribas> sm[m]: I just want to make a temporary test.hs file for quick testing and reloading into ghci
08:26:59 <sm[m]> if cabal doesn't have that option itself, then maybe cabal repl --ghc-options='-package A -package B'
08:27:20 <kuribas> sm[m]: so I don't need to retype some commands every reload
08:28:05 <sm[m]> right, I did that the other day. I think I used stack --package A exec -- ghci test.hs  or something
08:28:32 <sm[m]> so maybe cabal exec is the way, since test.hs isn't a component of the projec
08:28:33 <sm[m]> t
08:28:33 <kuribas> hmm, I'll try that
08:29:38 <kuribas> can I do :r with that?
08:33:50 <sm[m]> kuribas: how do you mean ?
08:34:16 <kuribas> reload
08:34:19 <kuribas> in ghci
08:38:08 <fendor_> kuribas, `cabal repl -b A -b B` should work. 
08:38:56 <kuribas> cabal new-repl -b /tmp/test.hs => couldn't parse dependency: /tmp/test.hs
08:39:21 <fendor_> kuribas, A is the dependency
08:39:39 <fendor_> such as aeson or pretty-simple
08:39:46 <kuribas> right...
08:39:58 <kuribas> how do I load a /file
08:40:34 <fendor_> ":l /path/to/file"
08:40:48 <fendor_> within ghci?
08:42:22 <kuribas> right :)
08:42:59 <kuribas> now only convincing emacs to pass these arguments to cabal repl...
08:45:00 <sm[m]> this nothunks lib from the cardano team sounds fantastic
08:53:49 <sm[m]> speaking of which, another q. I have a program where +RTS -S prints out unchanging numbers. I think this means it's running with constant heap ?
08:55:32 <sm[m]> and the overall statistics printed at the end look reasonable. Meanwhile, I can see it's Memory steadily increasing without limit in macos Activity Monitor. Does that mean it is leaking thunks and the stack is growing ? and the RTS stats don't show that ?
08:57:08 <sm[m]> and this program uses SDL, in case it's relevant
08:57:30 <sm[m]> maybe I'm leaking foreign C memory, not haskell memory ?
09:56:41 <cohn> can anyone recommend a good command line argument processing library?
09:57:58 <frdg> how can I use stack to compile binaries? 
09:58:30 <dsal> frdg: stack build
09:59:02 <dsal> cohn: I usually just use optparse-applicative, but depending on what your needs are, there are easier or fancier things.
09:59:26 <cohn> dsal: easy is always good. I'll take a look, thanks!
10:00:28 <dsal> cohn: There's this thing, but I've not used it because I always end up doing something a little weird: https://hackage.haskell.org/package/optparse-generic-1.4.3/docs/Options-Generic.html
10:01:53 <frdg> dsal: ok that is what I thought. I have been running stack build but only get this ouput: https://dpaste.org/YDpW. Where do the binaries go?
10:03:59 <dsal> stack path --local-install-root
10:04:02 <dsal> Or you can just 'stack install'
10:04:32 <dsal> That warning is kind of interesting, though.  It implies you've modified a generated .cabal and you've probably got some confusion there.
10:11:03 <frdg> dsal: stack install worked. No idea how I have managed to mess the cabal file up.
10:11:39 <dsal> The instructions suggest you could just delete it.  If you have package.yaml and the .cabal, that's going to be confusing.
10:12:17 <fluturel> hello?
10:12:32 <yushyin> hello fluturel
10:13:24 <fluturel> so i just learning haskell a few minutes ago. Don't have any questions yet, just wanted to see if the channel is still active
10:15:04 <yushyin> actually it is one of the more active channels on freenode
10:15:18 * hackage prolude 0.0.0.0 - ITProTV's custom prelude  https://hackage.haskell.org/package/prolude-0.0.0.0 (fozworth)
10:16:01 <fluturel> is my understanding correct that i can execute little haskell programs right here in the chat?
10:16:13 <dsal> No, but there are a couple of bots that can evaluate expressions.
10:16:38 <fluturel> how would one go about doing that?
10:16:43 <dsal> You can speak to those bots privately if you want to try to use them as a repl, but ghci will be a lot better.
10:17:15 <dsal> > length . words $  "this is lambdabot"
10:17:19 <lambdabot>  3
10:17:29 <dsal> % length . words $  "this is yahb"
10:17:29 <yahb> dsal: 3
10:18:01 <fluturel> ooh, that's interesting
10:18:03 <dsal> They're different, but helpful for demonstrating basic ideas.
10:18:04 <fluturel> thank you
10:18:33 <dsal> Both will be terribly frustrating if you try to use them as ghci.  ghci will be terribly frustrating if you try to use it as a scratch pad.
10:19:05 <fluturel> i will certainly come back here, should i need help (i most certainly will). Coming from 
10:19:27 <fluturel> Coming from C++ and the like, i heards it can be pretty brutal
10:19:51 <dsal> Haskell is pretty easy.  Haskell with a brain conditioned on C++ might be hard.
10:20:38 <fluturel> I do have some experience with Common LISP, but I dont know if that is considered functional nowadays
10:21:32 <dsal> It's not even so much the "functional" bits.  It's just a different language with different conventions (including calling conventions), culture, etc...
10:22:32 <dsal> Things that might be important for optimizing or organizing C++ code could be hugely detrimental to your Haskell experience and lead down dark paths.
10:22:36 <ski> fluturel : just lurking in here can also be pretty useful, when learning
10:22:40 <dsal> fluturel: How are you going about learning haskell?
10:23:04 <dsal> Yeah, one neat thing about lurking is that you'll get exposed to a lot of things you hadn't considered.
10:23:21 <fluturel> like using guards as ifs and such?
10:23:49 <dsal> Just general structure (though I almost never use 'if' in any of my code).
10:24:47 <fluturel> well, i got a book that has most of the language features. It's more like a doc than anything else. And also, some tutorials that I found. I am starting with learnyouahaskell.com
10:24:52 <ski> fluturel : you will learn to use recursion for looping, pattern-matching for destructuring and branching, learn to program (mostly/usually) without mutable variables, get access to a nice, flexible, powerful, static type system
10:25:23 <ski> fluturel : oh, and higher-order programming, with lexical scope
10:26:04 <ski> @where CIS194
10:26:04 <lambdabot> https://www.seas.upenn.edu/~cis194/spring13/lectures.html
10:26:23 <fluturel> ski : i know what most of the things you said are. No idea about pattern-matching, sounds like you are talking about regex
10:26:26 <ski> fluturel : that ^ has exercises, if you want some to chew on (LYAH doesn't have any)
10:26:50 <fluturel> Oh, thank you so much, just bookmarked it!
10:27:25 <ski> fluturel : have you used `destructuring-bind', in CL ?
10:27:37 <fluturel> Yes
10:28:01 <fluturel> So it's like that
10:28:03 <ski> well, pattern-matching is like that, "only more so", also incorporates branching on the possible shapes a piece of datum may assume
10:28:42 <dsal> You can define different expressions for functions based on the value of their arguments, for example.
10:28:53 <ski> @src length
10:28:53 <lambdabot> Source not found. Where did you learn to type?
10:29:02 <ski> hmpf
10:29:09 <ski>   length :: [a] -> Int
10:29:14 <ski>   length [    ] = 0
10:29:21 <ski>   length (x:xs) = 1 + length xs
10:29:45 <ski> is the traditional way to define the length of a (single-linked) list
10:30:09 <ski> `x:xs' there is like a "dotted pair/cons", in the Lisp world. and `[]' is the empty list
10:30:42 <fluturel> ah, i see, so it's recursion
10:30:45 <ski> so, `length' is defined via "two definitions" (two defining equations), each handling one of the two possible cases (empty vs. non-empty list)
10:30:53 <ski> yes
10:30:56 <dsal> recursion isn't the interesting part of that example, though.
10:30:59 <fluturel> xs is the remainder of the list and evaluates till xs is empty list
10:31:13 <fluturel> yeah, no, i got that
10:31:28 <monochrom> The point is we don't write like "length list = if null list then 0 else 1 + tail list"
10:31:35 <ski> but you can use this style of definition as well, for your own, user-defined, data types
10:31:43 <fluturel> And what you said about destructuring-bind being close to this, it does make a lot of sense
10:31:46 <dsal> > let isThree 3 = True; isThree _ = False in   map isThree [1..5]
10:31:49 <lambdabot>  [False,False,True,False,False]
10:32:05 <ski> s/tail list/length (tail list)/
10:32:11 <dsal> I have two different definitions of isThree that do different things depending on the value of the argument.
10:32:17 <albestro[m]> fluturel: I'm studying in parallel both CIS194 2013 and LYAH...for CIS194 I found useful from time to time to compare my solution with the one from the students who attended the course. you can find few of them on github
10:33:19 <fluturel> albestro[m]: thank you for the suggestion
10:33:52 <fluturel> albestro[m]: how long have you been studying for?
10:34:37 <albestro[m]> fluturel: I started during holidays (1 week of spare time) and in the last weeks I had few time to dedicate...but let's say 1 month on the calendar
10:34:55 <cohn> albestro[m]: beware, some of LYAH is out of date. For example no coverage of Semigroups
10:35:03 <cohn> other than that, great resource
10:35:23 <albestro[m]> cohn: thanks! it's absolutely worth knowing.
10:36:08 <albestro[m]> also about CIS194, I preferred the 2013 version because it feels like it is more dedicated to the "low-level'
10:36:34 <albestro[m]> compared to the newer one that it seems like they are trying to be "more interesting" with visual things
10:36:47 * cohn shrugs
10:37:04 <cohn> I don't know enough to have an opinion either way.  : )
10:37:26 <sm[m]> fluturel, also good:
10:37:26 <sm[m]> @where HTAC
10:37:27 <lambdabot> "Haskell Tutorial and Cookbook" by Mark Watson in 2017-09-04 at <https://leanpub.com/haskell-cookbook>
10:37:33 * ski grins
10:38:04 <sm[m]> ski, you saw that coming ? :)
10:38:16 <ski> was briefly thinking about it
10:38:31 <fluturel> sm[m]: i found it during my searches, but thank you, will be in my priority list
10:38:58 <ski> fluturel : at some point, you may find yourself wanting a textbook
10:39:16 <fluturel> i should have taken haskell up while in lockdown..
10:39:41 <sm[m]> that guy is not paying me, I promise. I just think it's among the best for many folk, and still mysteriously unknown, so I am duty bound to mention it
10:41:15 <dsal> fluturel: Everything I've ever learned felt like I learned it too late.
10:42:23 <fluturel> dsal: I know exactly what you mean. If only i learned more when i had loads of free time..
10:43:50 <sm[m]> no time like the present
10:44:48 <fluturel> i have another question: what can you do with haskell these days? Is it just a niche programming language?
10:45:04 <dsal> fluturel: Here's a project I did recently:  http://dustin.sallings.org/2020/04/29/gopro-plus.html
10:45:11 <dsal> I fail to write up most of the things I do.  *sigh*
10:45:14 <sm[m]> ha, leading question there
10:46:45 <fluturel> sm[m]: sorry if it is, should have phrased it a little bit differently
10:46:57 <dsal> I sat down to do some "hard" work on that project a couple of nights ago -- resuming partial uploads that failed exactly at the wrong moment where all the bits have been updated but the media wasn't marked completed on GoPro's side.  Turns out, it was just a couple lines of code to cover that case.  :(
10:47:16 <monochrom> It would be easier to enumerate just the handful of things Haskell is impractical for.
10:47:35 <dsal> fluturel: Nah, Haskell has a reputation of being a weird experimental language for academics.  In practice, it's the easiest language I use and the first thing I reach for when I'm doing general computering.
10:47:37 <sm[m]> fluturel: anything that doesn't require zero GC pauses, or cheap developers, or running on mobile 
10:48:19 <dsal> "running on mobile" is a little unfortunate.  Some of my programs are running on tiny ARM computers.
10:48:44 <sm[m]> cool, I should say "running on phones" maybe
10:48:47 <nshepperd> haskell is a programming language so easy, even academics can use it!
10:48:50 <monochrom> And even those divide into fundamentally impractical vs for-now impractical.
10:50:09 <dsal> Yeah, it's more about outward requirements.  If something has to be written using particular APIs that aren't accessible, then it's not exactly a "Haskell" problem as much as "you're not using the exact language allowed to work with this platform" problem.
10:50:27 <fluturel> i thought i read something a few years ago about a company that was making games in haskell for mobile. Can't remember the name though
10:50:37 <sm[m]> Keera, they stopped
10:51:06 <sm[m]> as far as I know, at least
10:51:46 <sm[m]> so yes it is possible to run haskell somehow on phones, but I'd say it's impractical except for the very highly motivated
10:51:55 <sm[m]> for now
10:52:22 <dsal> fluturel: A better way to think about this is to think about the types of programs you're interested in writing and whether it'll help you with that.
10:52:43 <geekosaur> and it's not so much that Haskell doesn't work well, as GHC doesn't work well — but for now at least GHC is the only real option
10:52:50 <geekosaur> (I miss jhc still)
10:52:57 <fluturel> i was thinking about trying to do a back-end or something in haskell
10:53:18 <dsal> Most of my programs are IoT or general commandline utilities or monitoring, stats, etc...  And my GoPro junk.  And various data processing things.  All of that stuff is easy.
10:53:46 <dolio> I don't know. Nothing ever worked as well as GHC anyway for most stuff.
10:54:09 <dsal> Damn you GHC.  Stop making everything else look bad.
10:54:40 <monochrom> @quote monochrom downloaded.GHC
10:54:41 <lambdabot> monochrom says: I was trying to design a sensible language... then I downloaded ghc.
10:54:46 <geekosaur> hugs worked pretty well back in the day. but ghc has been alone for so long that other implementations now have to catch up to it as well as implementing standard Haskell :(
10:54:59 <sm[m]> but of course GHC makes a lot of other stuff look really good
10:55:00 <dsal> The GHC language is kind of big.
10:55:18 <dsal> Heh, yeah.  I didn't mean to imply GHC is great at all the things.  It's a frustrating part of some of mydays.
10:55:19 <dolio> Hugs worked, but the stuff people used it for wasn't building applications that GHC is unsuitable for.
10:55:25 <dolio> To my knowledge.
10:55:42 <monochrom> Actually I think I started with hugs back then, and added GHC later.
10:56:05 <geekosaur> people have at least tried to resuscitate it for use on limited memory platforms iirc
10:56:53 <nshepperd> i wish for a ghc which can produce platform independent STG
10:57:15 <nshepperd> so i can just write an STG interpreter in java to make things run on phones :>
10:57:33 <fluturel> IoT with haskell actually sounds really interesting
10:58:32 <davean> Theres the ghci bytecode? I don't know a ton about it. Bytecode isn't really enough - you need the RTS.
10:58:53 <monochrom> "just write an STG interpreter" is also easier said than done.
10:59:26 <davean> And why you'd do all that to run Haskell on a phone I don't know
10:59:31 <davean> You CAN compile to target a phone
10:59:40 <davean> a lot of the hard part is the PDK component
11:00:02 <monochrom> which is also what davean said and I had in mind. Interpeter or compiler, you need an RTS or equivalent that does all the amazing multi-green-threading and I/O multiplexing and...
11:00:20 <dolio> What happened to the GHC fork that ran on JVM?
11:00:39 <davean> dolio: which one? eta?
11:00:43 <davean> There were a few
11:01:02 <dolio> Were there? I was thinking of eta, I think.
11:01:19 * hackage polysemy-test 0.3.0.0 - Polysemy effects for testing  https://hackage.haskell.org/package/polysemy-test-0.3.0.0 (tek)
11:01:40 <dolio> Running STG on JVM seems non-trivial anyway, because of the 'fixing space leaks in a garbage collector' thing that the JVM's garbage collector won't be doing.
11:01:53 <monochrom> But consider translating hugs from C to Java. :)
11:02:09 <nshepperd> dolio: what's that
11:02:49 <dolio> nshepperd: It's the title of a paper by Wadler, I think.
11:02:57 <monochrom> <bad pun time> eta has an ETA of "indefinite" </bad pun time> :)
11:05:09 <phadej> nshepperd: TL;DR when GC find a value which is fst (a, b); i.e. selector applied to already evaluated constructor, it evaluates it
11:05:26 <phadej> thus `b` could be possibly freed
11:09:19 * hackage polysemy-test 0.3.0.1 - Polysemy effects for testing  https://hackage.haskell.org/package/polysemy-test-0.3.0.1 (tek)
11:11:02 <phadej> I *guess* if JVM had native notion of thunks, its GCs would do that optimization
11:12:47 <nshepperd> interesting
11:14:56 <dsal> Is polysemy still a thing?
11:14:56 <davean> the 'eta' idea was to use the RTTI/Debugging support to do that optimization, right?
11:16:36 <phadej> davean: I don't know
11:19:13 <pie_> man  I dont know if parser combinators are hard to debug or just parsy as a python parser combinator library...
11:19:23 <pie_> i make prgress and get stuck on some self induced bug for hours
11:23:49 * hackage wai-session-postgresql 0.2.1.3 - PostgreSQL backed Wai session store  https://hackage.haskell.org/package/wai-session-postgresql-0.2.1.3 (hc)
11:26:46 <nshepperd> was your problem too much backtracking or not enough backtracking
11:27:08 <monochrom> I think parser combinators are harder to debug (than ordinary recursive functions). I tried to add Debug.Trace messages, and quickly realized I couldn't design useful debugging messages.
11:36:46 <sm[m]> I have a dbgparse function that I stick into megaparsec parsers. megaparsec itself provides a dbg, also. Such things are definitely needed at times
12:03:21 <glguy> parser combinators turn you into the parser compiler. using them for more than simple parsers generates debugging challenges and makes it hard to know what the grammar you actually support is
12:13:59 <pie_> the problem i run into a lot is i dont know which piece of code is causing the error
12:14:06 <pie_> i also have no idea when backtracking triggers :P
12:14:42 <pie_> though my code so far afaik doesnt have any deliberate backtracking, so if backtracking happens its probably by mistake
12:17:05 * Lycurgus had to look at the log, backtracking in hs sounded funny
12:17:18 <hyperisco> combinators are supposed to be syntactically relatable to grammar notation like BNF
12:17:31 <hyperisco> so you are supposed to be able to understand the grammar that way
12:17:56 <ski> (some familiarity with Prolog, and perhaps in particular DCG, might help)
12:18:25 <hyperisco> the complication is to watch out for restricted grammar classes (most combinators do not support all CFG)
12:19:20 <hyperisco> I'd just use combinators that do support all CFG if confusion is the main problem
12:23:09 <pie_> im parsing some text file generated by some government land office program
12:23:19 <pie_> its not exactly parsing friendly but i havent seen any specs either so
12:23:55 * Lycurgus guesses that most hs parser things are ll or lr without backtracking
12:23:56 <pie_> but yeah its not like i have some grammar to code against
12:35:17 <sm[m]> pie_: you need one of those debug functions I mentioned
12:35:39 <sm[m]> glguy that's an interesting observation
12:35:48 <hyperisco> pie_, if you suspect it is realisable as a CFG then I
12:35:53 <hyperisco> 'd start there on paper
12:36:05 <hyperisco> and only after succeeding with that worry about the program
12:37:13 <hyperisco> some combinators instance Monad and can parse some grammars outside CFG
12:37:37 <hyperisco> I think best to know the nature of what you're dealing with first
12:39:32 <sm[m]> pie_: maybe those functions won't work for you but it's worth building one, along the lines of https://hackage.haskell.org/package/hledger-lib-1.19.1/docs/Hledger-Utils-Debug.html#v:traceParse
12:40:17 <sm[m]> hyperisco: very true
12:41:10 <frdg> how does stack decide which version of ghc to use? I use ghcup. I would like the default ghc to be 8.8.3.
12:41:29 <frdg> ghc --version returns a different ghc than 8.8.3
12:41:39 <glguy> stack and ghcup are different things
12:42:31 <frdg> so different stack versions use different ghc's ?
12:42:33 <geekosaur> stack installs its own ghc based on the selected/current resolver, and by default ignores any ghc from a different source
12:42:44 <sm[m]> By the resolver in the nearest stack.yaml
12:43:18 * hackage bugsnag-hs 0.2.0.0 - A Bugsnag client for Haskell.  https://hackage.haskell.org/package/bugsnag-hs-0.2.0.0 (JasperWoudenberg)
12:43:32 <geekosaur> a differet stack release will probably default to a different resolver, but this can be configured by editing a stack.yaml somewhere (either in the current project, or a global default one)
12:44:04 <frdg> oh ok. Now to my next question. How can I change my stack version from 2.3.3 to 2.4?
12:44:48 <sm[m]> after that is released, stack upgrade (is one way)
12:45:55 <phadej> weird, I just noticed that stack-2.5 prerelease was tagged 
12:46:03 <phadej> I wonder what happened to 2.4 (well, not really)
12:46:12 <phadej> https://github.com/commercialhaskell/stack/releases/tag/v2.5.0.1
12:46:23 <frdg> really? I have two machines. On one machine stack --version returns 2.4? When I run stack upgrade both machines say it is the most recent version.
12:47:20 <phadej> or hmm. does stack use odd-even numbering (and oddly, with even numbers being development ones)
12:47:37 <phadej> i.e. stack-2.4 is some development version?
12:49:56 <sm[m]> phadej: strange.. they haven't used that numbering
12:50:45 <sm[m]> but I'm glad of the 5125 fix, that will speed up CI builds
12:51:07 <sm[m]> frdg: stranger still
12:51:24 <phadej> sm[m]: there weren't 2.2 either
12:52:12 <sm[m]> they only release unstable versions ? :)
12:52:40 <frdg> `Version 2.4.0, Git revision 1b1bed5b84b3aed76cf27b02cadd46d09efc611f PRE-RELEASE x86_64 hpack-0.33.0` It does say pre-release I guess?
12:53:05 <frdg> everything is working regardless though so I am pretty happy.
12:53:31 <sm[m]> ah, well that makes more sense. They must have changed their mind
12:54:01 <sm[m]> or it's a dev version numbering scheme like phade  said
12:54:40 <sm[m]> a wrong one
12:55:39 <sm[m]> though .0 releases are usually unstable so I suppose it's fair..
12:56:35 <int-e> If 2.0 is a stable release then what version number do you use for the development release leadung up to it? I've seen things like 1.99 and it's ugly.
12:57:08 <sm[m]> Ha that's my scheme. It's find it ok
12:57:14 <sm[m]> I find it
12:57:40 <sm[m]> It's forced on me by cabal
12:57:48 <int-e> Anyway, that's a reason for using odd numbers for stable releases.
13:01:49 * pie_ looks at sm[m]'s link
13:02:26 <int-e> You could also skip over 2.0, I guess...
13:02:41 <int-e> Or paint a bikeshed.
13:03:07 <pie_> i think i kind of have somethign like that
13:03:37 <sm[m]> pie_: and here's the other, maybe it's better ? https://hackage.haskell.org/package/megaparsec-9.0.0/docs/Text-Megaparsec-Debug.html
13:03:40 <pie_> re: the problem is most of the time i dont know which piece of my code is causing the error (and then i bisect or whatever and still dont get why its breaking where its breaking xD)
13:04:07 <pie_> maybe i just dont understand the library well enough
13:04:09 <pie_> :I
13:04:17 <sm[m]> that's why you have to sprinkle loads of these, with different labels
13:04:23 <pie_> guess i should learn a different style of parser writing
13:05:31 <sm[m]> if you look at hledger parsers you'll see lots of these, perhaps commented out.. and if debugging I'll often add more
13:05:39 <pie_> *nid*
13:05:42 <pie_> *nod*
13:05:59 <pie_> there has got to be a better way of doing this
13:06:53 <sm[m]> I'm not sure what it is, other than use a parser generator
13:07:24 <sm[m]> extensive fine grained tests are also helpful, and tedious
13:08:01 <pie_> *nod*
13:09:20 <sm[m]> Interactive testing in ghci, too
13:11:35 <sm[m]> and I suppose being disciplined and consistent, eg in how you handle whitespace, reducing the number of ways to screw up. A lexing phase should help with that but adds complexity too
13:12:16 <pie_> do people have to do this for other parser styles?
13:12:43 <sm[m]> but when it's just..not..working you must have a technique to drill in and get visibility on what's happening
13:13:01 * sm[m] doesn't know
13:13:03 <pie_> dont get me wrong i like combinators on some level, and they seem intuitive, except its not going well xD
13:13:16 <archaephyrryx> what parser library is this?
13:13:28 <pie_> parsy in python, its quite decent
13:13:33 <pie_> one could even say good
13:13:39 <pie_> but i dont have anything to compare agaisnt really
13:14:32 <archaephyrryx> i joined mid-conversation, but I have a bit of experience using (and even writing to a limited extent) parser combinators in Haskell
13:14:37 <archaephyrryx> what is the issue?
13:15:13 <pie_> it works and then i hit a snag and get stuck for hurs
13:15:16 <pie_> hours
13:15:20 <archaephyrryx> what does?
13:15:21 <pie_> generally hard to debug 
13:15:27 <sm[m]> can you see the log, archaephyrryx?
13:15:44 <pie_> writing parser combinators is hard to debug (for me)
13:16:14 <pie_> also tbh i shouldnt have to write print statements everywhere, it shuld be possible to point to something and figure out wtf is going on there
13:16:23 <pie_> but im not sure what kind of tooling would need to be in the library for that
13:16:25 <archaephyrryx> have you looked into HasCallStack
13:17:03 <pie_> i havent had much luck with making sense of whats going on using the pycharm debugger, though maybe i didnt try hard enough
13:17:12 <archaephyrryx> don't have much experience using it personally but it seems useful for tracing bugs in deeply nested calls
13:17:18 <sm[m]> pie_: it's actually fine, I may have overstated. Often putting the trace in one likely place will give you the insight to fix it
13:17:35 <sm[m]> and it's quick to do via ghci
13:18:21 <pie_> sm[m]: i can do something like .map(debug) in a parser chain where debug is def debug(x): print(x); return x
13:18:38 <pie_> its helped but i have to turn it off and on (which you mentioned) and doesnt fix everything
13:18:47 <sm[m]> but.. I'm slowly realizing that you're adking for help with something quite different from what I'm talking about
13:18:47 <pie_> hm i guess i should add showing parser state to that somehow
13:19:25 <pie_> i mean, theres libary specifics but there should be general approaches amenable to the design of monadic combinators in general i think
13:20:17 <archaephyrryx> can't figure out how to view the log sm[m]
13:20:44 <sm[m]> Yes; that was the point of my first reply to you. You need a specialized trace helper that prints the parser state - what text it's looking at etc.
13:20:57 <pie_> *nod*
13:21:25 <sm[m]> ircbrowse.tomsmeding.com archaephyrryx
13:21:26 <pie_> so, do you think theres a way to integrate the tracer so you dont have to manually add calls if you need them?
13:21:52 <sm[m]> certainly, in the parser engine, why not
13:21:53 <pie_> well i guess that comes down to wrapping every function
13:22:17 <sm[m]> The challenge is not being so verbose that you can't read it
13:22:22 <pie_> i guess parser combinators dont really have an engine? isnt it just a style of signatures?
13:22:27 <pie_> yeah
13:23:02 <sm[m]> I have assigned priorities to trace statements so I could filter by level
13:23:53 <pie_> maybe something you could to is tell it to trace between sections of the text
13:23:58 <pie_> so from char x to char y
13:24:04 <sm[m]> I don't know about your python lib. Haskell parser combinators run via a parser engine
13:24:18 <pie_> ok
13:24:18 <sm[m]> sounds good
13:24:30 <sm[m]> There is a lot of room for better tooling here
13:24:55 <pie_> ive googled stuff like "debuggign parser combinators" in the past but i never really saw anything relevan
13:24:56 <pie_> t
13:25:12 <pie_> doesnt mean it doesnt exist but i didnt find the right people or material...
13:25:25 <pie_> people dont seem to design for introspectability much
13:25:44 <pie_> i feel like im the idiot though, idk
13:26:04 <sm[m]> I have built some complex parsers with combinators but perhaps it's a thing people don't do much
13:26:18 <pie_> you seem to have managed
13:26:35 <archaephyrryx> have you tried copying the source code and running it yourself with modifications to enhance debuggability
13:26:57 <pie_> the parser im building doesnt seem horribly complex. ok maybe its not simple, im not sure, what i need to do is decompose it into small iterative steps so i can manage it
13:27:03 <sm[m]> yes, by making debug tools.. and still with a lot of labour. Otherwise, it was impossible
13:27:37 <phadej> running your parser on smaller inputs and verifying that things which you think should be accepted are actualyl accepted
13:27:43 <pie_> the part i started making progress was when i finally figured out how to use bind in the library xD and decompose the large text into some major sections
13:27:55 <phadej> I see often that person writes 1000 lines of code, *and* then tries to run it for the first time
13:27:58 <phadej> don't be that person
13:27:58 <pie_> yeah
13:28:12 <pie_> i still do that sometimes despite knowing better - not to that extent though
13:28:18 <pie_> it helps to have automated tests
13:28:21 <sm[m]> right.. fine grained tests of smaller pieces as mentioned. All of the techniques are needed and complementary
13:28:25 <pie_> but for a while i didnt even know what to test
13:29:01 <pie_> actually, the zeroth big step to actually making progress was writing code to test my parser on the corpus i have instead of f***ing with testing on soem files manually
13:29:13 <pie_> i should learn how to use some python test framework...
13:29:41 <pie_> the reason i havent written unit tests was id have to figure out what sections of the corpus to even be copy pasting into separate test cases...
13:29:50 <pie_> its kind of a back and forth thing with too many iterations
13:29:53 <sm[m]> Fuzz/property tests should be quite useful too but I haven't done it
13:30:22 <archaephyrryx> *slowly realizing we are talking about python and not haskell* ...I can't really contribute as much as I thought I could
13:30:39 <pie_> archaephyrryx: :P as ive been saying several times i think, but thats a technicality
13:30:55 <pie_> ok i should go try to write soem more code and see if i can say anything more
13:32:16 <archaephyrryx> on an unrelated note, I was wondering whether anyone had any opinions about a particular stylistic choice in writing haskell
13:32:26 <sm[m]> if all else fails, ship it to users and accept pull requests ?
13:32:40 <sm[m]> Just kidding
13:32:59 <pie_> haha
13:33:29 <archaephyrryx> when writing a function whose LHS has one fewer variable binding than it is ever called with (f :: a -> b -> c; f x = ...)
13:33:31 <sm[m]> archaephyrryx: nope. Opinions on style ? Never seen that
13:34:34 <archaephyrryx> is it appropriate to write the RHS using `$` to obviate nested parentheses when the implicit missing argument would necessitate parentheticals
13:35:01 <pie_> Wow I completely forgot I ran into this issue before... https://github.com/python-parsy/parsy/issues/34 :/
13:35:10 <sm[m]> I lied. There's a dozen dueling haskell formatting tools and style guides
13:35:59 <archaephyrryx> e.g.: f x {- implicit y -} = g $ h $ x 
13:36:21 <archaephyrryx> rather than
13:36:37 <archaephyrryx> f x {- implicit y -} = g (h x) {- implicit y -}
13:36:55 <archaephyrryx> any thoughts?
13:37:12 <sm[m]> f = g . h is often seen
13:37:14 <dolio> I would probably never write `g $ h $ x`.
13:37:27 <archaephyrryx> i am not writing the actual code
13:37:35 <archaephyrryx> this is a contrived abstraction
13:38:12 <archaephyrryx> it really looks more like
13:38:48 * hackage cryptocompare 0.1.2 - Haskell wrapper for the cryptocompare API  https://hackage.haskell.org/package/cryptocompare-0.1.2 (aviaviavi)
13:38:50 <archaephyrryx> func1 arg1 = doWork $ func2 $ func3 arg1
13:39:29 <archaephyrryx> where there is an extra implicit argument that lacks a binding in the actual definition
13:40:07 <dolio> That's also `doWork . func2 . func3`.
13:40:39 <archaephyrryx> the first binding has a strictness annotation (!) so that isn't viable
13:41:17 <glguy> too late, you left that out of your simplified problem code, so you don't get to use it
13:41:47 <archaephyrryx> but the invisible dragon *is* flour-permeable, I swear it always was
13:42:31 <dolio> I still don't repeat $ usually, I use .
13:43:56 <dolio> But what I do depends on the actual code, and may be different from simplifications, because I don't follow rules by rote.
13:46:43 <archaephyrryx> I typically opt for point-free style and don't use `$` very often but I am collaborating with someone with a completely opposite style and so have been subconsciously splitting the difference for this project
13:48:55 <monochrom> dragon and flour?! If the dragon breathes fire, and the flour is aerosoled, that's a fuel-air bomb waiting to happen >_<
13:49:27 <archaephyrryx> was that reference too obscure? I don't know how common it is
13:49:45 * [exa] votes for obscure
13:49:49 <monochrom> All references are too obscure. :)
13:50:47 <monochrom> Every cultural reference is well-known to 100% of the community consisting of the solely the speaker.
13:51:12 <archaephyrryx> it was an example about irrational claims involving shifting goalposts to thwart potential experimental counter-evidence
13:51:56 <monochrom> Please don't worry about me. I was just spotting a huge fire/explosion hazard. :)
13:52:11 <archaephyrryx> posed by Carl Sagan
13:52:26 <archaephyrryx> https://en.wikipedia.org/wiki/The_Demon-Haunted_World#Dragon_in_my_garage
13:53:13 <monochrom> A very bad flour explosion accident happened some years ago in Taiwan, in a party or festive celebration or something featuring flour in the air.
13:54:03 <monochrom> Yikes, the Carl Sagan dragon does breathe fire.
13:55:07 <monochrom> And now my turn to give an obscure reference.
13:55:55 <monochrom> Imagine that, replying to "the fire-breathing dragon is invisible and floating", you say "so how about we spread flour in the air and see if we survive"
13:56:48 <monochrom> This will lead to a "no-dead-body problem".
13:56:57 <[exa]> re 'The inability to invalidate the hypotesis is not at all the same thing as proving it true'....well here we've got undecidability&complexity reductions. :D
13:58:32 <monochrom> This is an obscure reference to a criticism of claims of cold fusion back then. If cold fusion happened, it should generate more than enough neutrons to kill everyone around. But everyone around was living just fine. This was the "no-dead-body question", or perhaps the "dead-body question".
13:59:03 <monochrom> or s/question/problem/ or something
14:00:44 <monochrom> Thanks for the link. It's a good read. <3 Sagan
14:01:07 * monochrom hops over to amazon
14:01:43 <archaephyrryx> There is another version where the suggestion to throw flour in the air to outline the shape of the dragon was countered with "the dragon is permeable to flour"
14:02:00 <archaephyrryx> which is what I was referencing originally
14:02:06 <monochrom> Ah yeah.
14:02:33 <monochrom> But I play my "why are we still alive?" card. :)
14:02:47 <archaephyrryx> anthropic principle to the rescue
14:02:51 <archaephyrryx> just like qunatum-bogosort
14:06:16 <dmwit> It says very clearly in the link that the dragon's fire is heatless.
14:06:26 <dmwit> So of course throwing flour in the air doesn't kill us.
14:06:49 <monochrom> Oops.
14:07:06 <monochrom> Does that still count as fire? heh
14:07:21 <dmwit> Yeah, that's... sort of Sagan's conclusion, too.
14:07:32 <dmwit> Does this even count as a dragon if there's no way to observe it being a dragon?
14:07:52 <monochrom> It's like Tigger but s/tiger/dragon/
14:08:42 <monochrom> http://www.vex.net/~trebla/photo/unorganized/dragon.jpg
14:09:21 <dsal> Lazy IO is the best!  My programs all run instantly!  Sometimes takes a while to print the output, though.
14:09:52 <monochrom> Um that's not lazy I/O. That's just output buffering.
14:10:05 <monochrom> OK you were joking. Haha.
14:10:21 <cheater> monochrom: it's not output buffering, his dot matrix printer is just a bit slow
14:10:31 <monochrom> I do have students confused by output buffering. And it's a C course.
14:10:41 <monochrom> hahaha
14:11:14 <cheater> monochrom: if it's a C course, make sure to get the shellfish
14:11:25 <monochrom> hahahaha
14:11:59 <monochrom> The course is a unix course too, there is shell. I'll have to think how to turn shell into shellfish.
14:14:41 <dmwit> Oh, hell. I'm a professional programmer that does programming stuff for... well, not quite 8 hours a day ;-)... and I still occasionally get flummoxed by output buffering.
14:15:36 <MarcelineVQ> The trick is to put a couple people between you and the problem.
14:16:11 <c_wraith> so...  input buffering?
14:16:18 <dmwit> Ahhh, problem buffering! Why didn't I think of that?
14:21:06 <dsal> monochrom: Oh sorry, I was going for the one where I do all this awesome parallelism and the parallel functions compute the IO actions immediately, and then they all happen sequentially when the output is needed.
14:22:02 <monochrom> Ah.
14:22:18 * hackage aeson-schemas 1.3.1 - Easily consume JSON data on-demand with type-safety  https://hackage.haskell.org/package/aeson-schemas-1.3.1 (leapyear)
14:32:17 <cheater> monochrom: just use the C shell
14:32:29 <monochrom> Ah, neato
14:32:55 <monochrom> Hey, I now recall that "fish shell" exists, too.
14:42:17 <maerwald> it's nice
14:42:54 <maerwald> finally someone figured out that shell is about ergonmics, not features
14:43:08 <maerwald> (when I need features, I switch to bash temporarily)
14:49:23 <monochrom> It's probably a programmer trait to prefer features to ergonomics, syntax to semantics.
14:50:04 <monochrom> or generally a human trait to prefer superficial to careful
14:51:45 <Cale> In the words of Bob the Angry Flower: "I can't drink *possible* beers, I need *actual* beers! Damn you, quantum physics!"
14:51:52 <pie_> sm[m]: well, if you have any suggestions: <_aD> It's fascinating to see how different people's idea of "big" is in computing, and how they handle it.
14:51:53 <pie_> whoops
14:52:03 <pie_> sm[m]: https://github.com/python-parsy/parsy/issues/48
14:57:21 <ddellacosta> omg I forgot about Bob the Angry Flower, thank you Cale
15:02:11 <dsal> I used to use tcsh a lot way back in the day and people mocked me for various scripting things you couldn't do in tcsh.  I'm like... I write my scripts in bourne shell, but I don't hang out there.
15:02:41 <dsal> A friend had me try nushell which is... an idea.  But it's a bit ununixy and a big uphill battle.
15:13:31 <ski> @where thwap
15:13:32 <lambdabot> "Bob the Angry Flower's Quick Guide to" : "the apostrophe" in 2010-02 at <http://eloquentscience.com/wp-content/uploads/2010/02/bobsqu.gif>,"its and it's" in 2010-03 at <http://eloquentscience.com/
15:13:32 <lambdabot> wp-content/uploads/2010/03/angry-flower-guide-to-its.gif> )
15:13:42 <ski> ddellacosta,Cale ^
15:13:48 <dolio> Wow, nushell has like 3 corporate buzzwords phrases in the first two sentences describing it.
15:16:37 <ski> monochrom : don't forget Fᵢ-shell <http://fishell.sf.net> :)
15:17:15 <ski> (partially inspired by logic programming)
15:30:29 <ddellacosta> ski: :-D
16:02:37 <maerwald> can you tell ormolu the indent size?
16:03:09 <monochrom> No, tell formolu instead.
16:04:06 <maerwald> https://github.com/tweag/ormolu/issues/637
16:04:07 <maerwald> lol
16:06:17 <maerwald> consistency across projects that are alien to one another is big nonsense imo
16:07:58 <dsal> ormolu is really awful.  I know some people like the elm-inspired style, but it's actively bad.
16:11:43 <maerwald> uh... the way it breaks down long function signatures is odd
16:11:48 <maerwald> -> is at the end of the line
16:12:21 <maerwald> the end of a line is naturally what your eyes skip with a 50% chance
16:13:04 <justsomeguy> dsal: If you like shells, I found this awesome page of weird unix shells ... https://github.com/oilshell/oil/wiki/ExternalResources
16:13:16 <ski> maerwald : yea ..
16:13:17 <dsal> Some people have weird style preferences and very strong views that everyone should use them.  (I say "weird" in the sense that it's just different from all the code I read when I was learning stuff, and a major disruption from stylish-haskell as I've been using it).
16:13:39 <dsal> justsomeguy: I just kind of live in shells.  I eventually gave up on trying to build a perfect environment.
16:15:03 <dsal> I eventually started using bash so I wouldn't be That Weird Guy, and then recently OS X told me I need to move out of bash because it's not shiny enough.
16:15:17 <yushyin> monochrom: afaik the fork is fourmolu (minor typo)
16:15:41 <dsal> Wait, is it really just ormolu with s/2/4/g ?
16:15:44 <justsomeguy> dsal: I've pretty much standardized on bash, too, but I do enjoy experimenting with other things.
16:15:55 <ski> dsal : back to tcsh, or what ?
16:15:57 <dsal> justsomeguy: nushell was neat, but I did break it pretty quickly. heh.  joys of nix, though.
16:16:05 <dsal> ski: OS X is moving folks to zsh
16:16:10 <ski> mhm
16:16:15 <dsal> But yeah, that's a good point.  OS X was tcsh when I started using it.
16:16:29 * ski 's still using TCsh ..
16:59:51 <kirill> hi all, I was looking at some docs and saw this definition "class Monad m => Blah k v m | m -> k, m -> v where [...]". what does the "| m -> k, m -> v" mean in this context?
17:02:53 <Turmfalke> It's called functional dependencies. m -> k states that k can be uniquely determined from m
17:03:38 <kirill> "functional dependencies" -- thanks! I'll read up on these
17:06:55 <monochrom> maerwald: There is one school of thought of coding style that wants: line n "1st long thing +", line n+1 "2nd long thing". I think ormulo putting "->" just before line break is following that.
17:08:13 <monochrom> And there is an opposite school of thought that wants: line n "   1st long thing", line n+1 "+ 2nd long thing". For example the Python official coding style promotes this. I like it too.
17:08:59 <monochrom> Err actually the Python coding style promotes line n "1st long thing" without leading spaces for aligning with the 2nd long thing, heh.
17:09:57 <monochrom> It says it's inspired by math formula formatting style. But of course, math formatting style adds leading space to align, and then the Python guide decides to give a reason to change that.
17:11:27 <monochrom> I think one reason is when "+ 2nd long thing" is added or removed, no change to line n, reducing "code commit that changes spacing".
17:11:34 <monochrom> s/reducing/avoiding/
17:12:35 <monochrom> Plain-text-file programming is really aging and showing its cracks.
17:33:44 <dolio> Arguments about changing extra lines seems a lot like one of those 'programmers optimizing what doesn't actually matter' things.
17:36:35 <monochrom> I know right?
17:37:11 <yushyin> but the diffs must be as small as possible!!1
17:37:42 <monochrom> As I think through this again, I am now more inclined to adding the extra space before "1st long thing" because that gap is visual cue to alert you "expect a connecting infix operator to happen next line"
17:38:17 <monochrom> But deep down in my heart, I like Leslie Lamport's way the best.
17:39:12 <dolio> I'm not sure any math references are legitimate, either.
17:39:22 <monochrom> Let me describe it by first referring to common math formatting.  You have 3 long things added together, so you go "  1st long thing", "+ 2nd long thing", "+ 3rd long thing", right?
17:39:55 <monochrom> Lamport was like "why not make the + play the double role of being the bullet in your list of bullet points!"
17:40:19 <monochrom> So his style goes "+ 1st long thing", "+ 2nd long thing", "+ 3rd long thing".
17:40:58 <monochrom> This is the best of both worlds of visually cuing you to a connecting infix operator and avoiding spacing changes when you add or remove an operand.
17:42:03 <monochrom> Hrm let me check again about the math reference.
17:42:39 <dolio> Well, I just don't believe 99.99% of programmers when they talk about math. :)
17:42:41 <monochrom> It is possible that I misremembered, that more correctly the Python guide is referring to specifically one textbook.
17:44:07 <dolio> Also math notation is all over the place, and isn't always very good.
17:45:12 <monochrom> The Python style guide is at https://www.python.org/dev/peps/pep-0008/#should-a-line-break-before-or-after-a-binary-operator , it refers to Donald Knuth
17:45:57 <monochrom> But it does claim "mathematicians and their publishers" before citing Donald Knuth, heh.
17:46:34 <dolio> Haskell should ditch lambda expressions and switch to calculus notation for variable binding.
17:46:48 <dolio> fmap (x + 1 dx) [1,2,3]
17:47:10 <monochrom> haha
17:47:27 <monochrom> f x = x + 2*y dy
17:48:43 <monochrom> I like Lamport's the best. It has the most symmetry.
17:49:56 <monochrom> But don't worry, I don't have a strong conviction in this. I'm OK with the other two styles.
17:51:52 <monochrom> You know that the calculus dx notation takes on a life of its own, right? Actually two or even more lives.
17:52:12 <monochrom> One is infinitestimal non-standard analysis.
17:52:14 <dolio> Yes.
17:52:35 <dolio> You can actually make sense of all the 'wrong' stuff that physicists do using something like synthetic differential geometry, I think.
17:52:37 <monochrom> Another is those 1-forms, 2-forms, etc., wedge products, tensor thingies in differential geometry.
17:52:52 <EvanR> "all" the wrong stuff? 
17:52:54 <monochrom> Yeah that.
17:52:58 <dolio> Actually, probably weirder stuff that physicists even come up with, I've heard.
17:53:03 <dolio> Than, even.
17:53:36 <monochrom> Well, I am sympathetic because Dirac's delta function is useful, even though it's a headache to give semantics to.
17:53:38 <dolio> EvanR: The stuff that mathematicians tell you is wrong, but actually works, at least.
17:54:16 <dolio> Because the mathematicians lie about studying the basis for what the physicists are doing.
17:55:33 <monochrom> I'm sympathetic to that too, because I believe that the mathematicians don't intend to lie, they just get sidetracked.
17:55:58 <EvanR> i've come to see calculus notations as being part of a type system
17:56:22 <EvanR> 5 and 5 dx aren't two different values, they not even the same type
17:56:34 <monochrom> They started out really wanting to explain what the physicists are doing. Then there is a side discovery that led them down a tangent to a new hobby.
17:56:47 <dolio> Yeah.
17:59:22 <dolio> That doesn't make them correct to say that the physicists need to follow the rules of their tangent hobby, though.
17:59:58 <EvanR> prescriptive vs descriptive math ?
18:00:47 <monochrom> tangential vs secantial :)
18:00:50 <glguy> What're criticizing exactly?
18:01:08 <glguy> We*
18:01:25 <monochrom> We are not criticizing. OK, I am not.
18:01:38 <glguy> Well that doesn't help me
18:02:04 <monochrom> If you like, maybe it all started with criticizing coding styles?
18:02:23 <dolio> I don't have a good specific example. But if you watch physics lectures, eventually you'll see a professor do something that doesn't make sense from a classical analysis perspective, and someone in some comments will say, "as a mathematician, what you did there was invalid."
18:02:35 <monochrom> Like, if you have "1st long thing + 2nd long thing" to be split into two lines, where do you split and format the two lines?
18:03:00 <dolio> Like, cancelling numerators/denominators in derivative stuff or something is a simple example.
18:03:19 <EvanR> i kind of hope this characterization of "mathematicians" is only a stereotype
18:03:23 <dolio> But there are mathematical systems where stuff like that is complately justified.
18:04:19 <monochrom> We have similarly anal, narrow-minded programmers as well.
18:05:01 <monochrom> You write a C program that's tuned to your compiler and OS and hardware, and you know why it is correct in your context.
18:05:29 <dolio> This probably isn't a description of a lot of good mathematicians, but there are a alot of not good ones commenting on things.
18:05:32 <monochrom> Someone is going to come and say "this line is UB" ignoring how you only intend your code for only one context.
18:06:54 <dolio> Same phenomenon on interesting engineering principle videos I see that rack up comments about using PSI instead of metric, or pronouncing aluminum wrong.
18:07:02 <EvanR> someone on the business end of dunning kruger
18:07:33 <dolio> Can't focus on the interesting content instead of the veneer of units and stuff.
18:08:48 <dolio> I didn't watch your video because you pronounced solder differently than I do.
18:11:54 <EvanR> well, there being an isomorphism between physics in meters and physics in feet, or j^2 = -1 not i^2 seems different from stepping completely outside normal math rules
18:12:28 <EvanR> esp without warning
18:12:28 <dolio> I saw a video a few days back where the professor mentioned that the speed of light is pretty close to 1 foot/ns.
18:14:17 <glguy> That's convenient for me as I use gigafeet a lot
18:15:57 <dolio> Why are the normal math rules the ones that don't correctly describe what works in physics and stuff, then?
18:17:23 <EvanR> maybe math courses have a hard time distinguishing between,  all our practices are consistent across subjects because they form part of a holy pyramid, or are like that for technical convenience
18:18:22 <dolio> Yeah, I mean, there's definitely the 'Platonist' "everything is applied (classical) math" angle pushed heavily.
18:19:15 <ezzieyguywuf> if I'm doing `pure . Left "some error"` to put a Left into a State, isn't there a way to use fmap or something to do this more succinctly?
18:20:46 <dolio> I'm not sure how you could get much shorter than that.
18:23:37 <monochrom> Wait a second, do you mean "pure (Left "some error")"? Or equivalently "(pure . Left) "some error""?
18:23:53 <dolio> That was my assumption.
18:24:14 <monochrom> But yeah it's as short as you can get.
18:25:21 <dolio> fmap is as long as pure, so I'm not sure how you could anticipate making something shorter with it. Left isn't a very long word, either.
18:26:17 <dolio> In some larger context maybe you could shorten things.
18:30:46 <ezzieyguywuf> dolio: monochrom: yes.
18:31:13 <ezzieyguywuf> I thought that fmap could replace both pure and Left, but maybe I'm getting things confused.
18:33:50 <monochrom> fmap can replace it but you have to also replace a larger context.
18:34:20 <monochrom> `cmd >>= pure . Left` is replaceable by `fmap Left cmd`
18:34:36 <ski> monochrom : oh, so i should refer to Lamport, when using indentation to avoid multiple-line-spanning parentheses ?
18:35:08 <monochrom> If you go `fmap Left (pure "some error")`, that's legal, but also dorky. :)
18:35:16 <ezzieyguywuf> monochrom: that's what I was thinking of
18:35:34 <ezzieyguywuf> monochrom: i.e. cmd >> pure . Left
18:36:12 <monochrom> ski: I think I don't know what Lamport does to indentation vs multiple-line-spanning parentheses.
18:36:37 <dolio> ezzieyguywuf: Well, if you mean >>=, that is `fmap Left`.
18:36:56 <ski> mhm, ok
18:37:00 <dolio> If you mean `cmd >> pure (Left x)` that is `Left x <$ cmd`.
18:44:03 <ezzieyguywuf> nah, I meant >>=
20:58:49 * hackage hspec-wai-json 0.11.0 - Testing JSON APIs with hspec-wai  https://hackage.haskell.org/package/hspec-wai-json-0.11.0 (SimonHengel)
21:14:48 * hackage hspec-wai 0.11.0 - Experimental Hspec support for testing WAI applications  https://hackage.haskell.org/package/hspec-wai-0.11.0 (SimonHengel)
21:23:26 <fraktor> Is there an equivalent in `base` to the Map datatype? I need it for a project that will run in an environment I don't control.
21:25:12 <dsal> Equivalent in what way?  List is there.
21:25:36 <dsal> But if you want something that behaves like Data.Map.Strict, then you'll want Data.Map.Strict.  It shouldn't be very hard to argue that as a dependency.  :)
21:26:00 <fraktor> True. I am running into an issue where I would like to "update" a map from coordinates to values, and doing that with associative lists is a little tricky.
21:27:26 <dsal> That's basically map.
21:28:03 <fraktor> Admission time: this is for homework that will run on a remote system.
21:28:21 <dsal> You could make it average more efficient with a custom update function that wouldn't be that hard.
21:30:12 <fraktor> Yeah, I just wrote one actually.  I'm going to assume I can't use Map and then worry about it later.
21:46:14 <dolio> It doesn't make a lot of sense to not be allowed to use Data.Map, because it's part of the core libraries. It was just split out of base long ago so that it could be updated independently.
21:50:54 <fraktor> dolio: Wait, is it part of the regular GHC distribution?
21:51:04 <fraktor> It's not that I'm not allowed to use it, but rather that I cannot install packages at all.
21:51:31 <dolio> It normally ships with GHC, yeah.
21:52:46 <dolio> Although it's entirely possible that someone could choose not to install all the things GHC ships with in e.g. a Linux package manager.
21:53:08 <dolio> It wouldn't be very nice of your professor, th ough.
21:54:06 <Faker> How to turn a lowercase string to uppercase ?
21:54:58 <fraktor> dolio: I think that it's running on Debian? With GHC installed from a package manager.
21:55:37 <c_wraith> wow.  debian's package manager breaks ghc in lots of fun ways!
21:55:49 <c_wraith> hope you never need to profile anything!
21:56:20 <dolio> Well, hopefully they at least install the core libraries.
22:00:22 <c_wraith> yep, looks like it does.
22:07:54 <fraktor> Even though it's a homework problem, is it okay if I post my code here to get some help with readability? I find it hard to understand but don't really know how to improve that.
22:10:32 <dsal> Faker: map all the chars to a function that upper cases each char
22:11:39 <dsal> fraktor: "worry about it later" is a great skill
22:11:57 <c_wraith> @where paste
22:11:58 <lambdabot> Help us help you: please paste full code, input and/or output at eg https://paste.tomsmeding.com
22:12:48 <perdent> Anyone here good with ECC/ECDLP crypto?
22:12:50 <c_wraith> fraktor: if you want style advice, put the code there and then give us the link and ask for the kind of advice you'd like
22:13:25 <fraktor> https://paste.tomsmeding.com/7AifjNEN
22:13:32 <fraktor> Mostly it's style advice.
22:13:58 <c_wraith> on a first glance, the overall appearance is fine.
22:14:10 <c_wraith> that's roughly what Haskell code should look like
22:14:11 <dsal> You named (Int, Int), use the name  :)
22:14:50 <fraktor> Whoops
22:15:25 <c_wraith> oh. I'd rework encodeBoard.  that second lambda is too much.
22:15:27 <dsal> `EQ == compare y1 y2` is `y1 == y2`
22:16:04 <dsal> groupOn would be nice
22:16:06 <c_wraith> (and the first lambda happens to be identical to a function you probably already know)
22:16:07 <fraktor> dsal: Hmm. Interesting
22:16:14 <dsal> @src groupOn
22:16:14 <lambdabot> Source not found.
22:17:00 <dsal> :t groupOn
22:17:02 <lambdabot> error:
22:17:02 <lambdabot>     • Variable not in scope: groupOn
22:17:02 <lambdabot>     • Perhaps you meant one of these:
22:17:05 <dsal> boo
22:17:37 <dsal> :t groupBy
22:17:39 <lambdabot> (a -> a -> Bool) -> [a] -> [[a]]
22:18:46 <fraktor> :t comparing
22:18:48 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
22:18:59 <fraktor> Kind of? But not really.
22:19:15 <dsal> groupOn kind of rhymes with that
22:20:00 <dsal> It's easy to write with groupBy and it makes that really readable.
22:20:30 <fraktor> :t groupWith
22:20:32 <lambdabot> error:
22:20:32 <lambdabot>     • Variable not in scope: groupWith
22:20:32 <lambdabot>     • Perhaps you meant one of these:
22:21:26 <fraktor> Interesting. Hackage shows that existing.
22:22:36 <fraktor> Ah, it's in GHC.Exts. I think that's acceptable.
22:23:58 <fraktor> c_wraith: Is this better? https://paste.tomsmeding.com/dfCZuFjh
22:24:22 <c_wraith> that is a *lot* better, yes.  :)
22:25:28 <fraktor> applyMove also makes me sad
22:27:30 <c_wraith> that's one of those cases where a do block might actually read better.
22:27:46 <c_wraith> fromMaybe board $ do ...
22:29:08 <fraktor> Hmm. Let's see
22:30:06 <dsal> liftM looks weird to me.  Is that fmap?
22:30:11 <c_wraith> yes
22:32:32 <fraktor> Yeah I should use fmap.
22:32:41 <dsal> I'd probably write    `emptyIndex board = fst <$> Map.lookupMin . Map.filter (== 0) board`
22:32:59 <c_wraith> yeah, I ran through it...  applyMove gets a lot cleaner if you make most of it a do block
22:33:04 <dsal> Though my brain compiler is rejecting that.
22:33:19 <fraktor> That is so much better
22:33:21 <c_wraith> since you get to drop a lot of stuff going on to maintain Maybe values
22:33:38 <fraktor> https://paste.tomsmeding.com/MO0geafX
22:34:17 <c_wraith> Yep.  I think that's an improvement
22:34:29 <fraktor> I'm happy with that function now. It's relatively easy to understand
22:36:42 <dsal> I don't like return, but it's not incorrect.  :)
22:37:02 <Faker> dsal: How ?
22:37:12 <dsal> Faker: what do you have?
22:37:54 <fraktor> I'm guessing `Just`?
22:38:00 <c_wraith> nah, pure
22:38:07 <dsal> I'm a `pure`ist
22:38:09 <c_wraith> but I don't think the difference matters
22:38:14 <dsal> It doesn't.
22:38:44 <fraktor> By the way, I just wrote `groupOn` so I wouldn't have to import a GHC extension
22:39:07 <fraktor> `groupOn f = groupBy (\a b -> f a == f b)`
22:39:23 <Faker> receives a word and returns the original word in tuple and uppercase
22:39:42 <fraktor> Faker: What do you mean the "original word in tuple"?
22:39:50 <Guest26> hello, I have a question about using Haskell to exchange data with a web page
22:39:51 <Faker> the same word
22:40:01 <fraktor> Oh I see. So it would be (original, uppercase)?
22:40:13 <dsal> fraktor: yeah, it's not an important detail, but little things make big differences.
22:40:18 <Faker> Exactly!
22:40:48 <Guest26> there are several options for using Haskell for the web page also, but my question is about the interface
22:40:48 <fraktor> http://hackage.haskell.org/package/base-4.14.0.0/docs/Data-Char.html This might have what you need, Faker
22:40:57 <Faker> i dont know how to use uppercase yet
22:41:15 <Faker> fraktor i will see
22:41:31 <Guest26> most online tutorials suggest something like SQL - but there are also here several options that just use Haskell
22:41:46 <dsal> Faker: You gave a really imprecise description of your goal.  What code do you have?  What signature?
22:41:56 <dsal> Returning your input isn't usually very useful.  Anyone who calls a function with input already has the input.
22:42:17 <Faker> The input will be a string
22:42:32 <dsal> Guest26: haskell and SQL aren't the same genus.  It's not clear what you're trying to do.
22:43:02 <fraktor> Faker: I'm also confused why you would want to return a tuple when the caller can just do `(str, myFunc str)`
22:43:33 <Guest26> for a test case, i would like to visualise some data sent through a database. in the browser i would like to use some libraries or js to make the visualisation nicer 
22:43:57 <dsal> Guest26: Sounds like a plan.  I do that sometimes.
22:44:08 <Guest26> dsal: i thought SQL could be a good way to send data between languages
22:44:27 <dsal> SQL isn't a transport or interchange of any sort.
22:44:36 <dsal> It's just some kind of structured query language.
22:44:43 <Guest26> but since the language im sending it from is Haskell, i thought maybe a haskell replacement for SQL would work 
22:45:03 <fraktor> Guest26: what do you mean "a Haskell replacement for SQL"? They do fundamentally different things
22:45:11 <Guest26> dsal: just because both languages normally would be able to interface with an SQL server
22:45:14 <fraktor> What is the flow of data/queries that you're envisioning?
22:46:11 <Guest26> something like, a server writing the number of users online, and the webpage displaying this as a graph that can be updated by refreshing the page
22:46:45 <fraktor> I see. So you're thinking of using a Haskell backend to mediate between a SQL server that has that information, and a web frontend?
22:47:07 <Guest26> im not sure. it seems like haskell could even replace the web frontend aswell
22:47:14 <fraktor> What? how?
22:47:32 <Guest26> and then, it might not need SQL at all, because its not "communication between languages"
22:47:41 <Guest26> which i thought i would need to send it to HTML
22:47:44 <fraktor> That's... that's not what SQL does.
22:47:44 <dsal> Whatever you mean by "send SQL" is almost certainly wrong.
22:48:12 <fraktor> SQL is a way of communicating with a database specifically. It's not a serialization format like JSON or XML. It describes queries, not data.
22:48:44 <Faker> Fraktor how to use toUpper :: Char -> Char ?
22:48:51 <dsal> > toUpper 'x'
22:48:54 <lambdabot>  'X'
22:49:18 <dsal> It takes a Char.  It returns a Char.
22:49:35 <Faker> Variable not in scope: toUpper :: Char -> t
22:49:41 <Faker> Give me this error
22:49:49 <Guest26> fraktor: yes, i mean there would be an SQL database, and both the HTML page, and the haskell program that needs to send data, could use the SQL database as a gobetween
22:49:49 <fraktor> What code are you running on it?
22:50:14 <fraktor> Guest26: Oh! You mean that the Haskell application is writing to the database, and the HTML page is reading from it?
22:50:20 <Guest26> yes!
22:50:23 <dsal> Faker: Sounds like you didn't import it.  Are you trying to learn Haskell by trial and error?
22:50:28 <fraktor> Okay.  I think I understand now.
22:50:58 <fraktor> Are you talking specifically about monitoring users though?  More generally, is the data that you're using all metric-based?
22:51:05 <Guest26> this seems like it might not be needed however, since if the haskell is also doing the webpage, then there might be an easier way to send the data
22:51:35 <fraktor> Guest26: If the Haskell program is hosting the web page and acting as the backend, then you can send information through a serialization format. JSON is really easy to use in this use case.
22:51:46 <Faker> dsal the import will be import Data.Char ?
22:51:48 <Guest26> fraktor: i think most generally i would be sending json serializable data - but for the sake of example could just be a vector of doubles
22:52:08 <Guest26> or, just a double, as thats easy to make a time dependent graph of
22:52:50 <fraktor> Guest26: If you haven't, I would look into Prometheus.  It's a tool specifically used for general metrics collection and querying, and is super widely used. It might not be to your use case, but I'd at least consider not reinventing the wheel.
22:52:54 <Guest26> im not sure what you meant metric-based, does that answer the question?
22:53:30 <Guest26> suppose i want to send a random number and visualise that in a time dependant graph
22:53:52 <Guest26> im not sure if it being a user count is confusing things
22:53:54 <fraktor> I should have said "time-series metrics." So for example, the total number of requests served, the number of active connections, percentiles for response times for your server, and so on.
22:54:04 <dsal> I use influxdb from Haskell quite a bit.  My coworkers like prometheus, but I don't respond to their peer pressure.
22:54:28 <Guest26> hmm, yes, certainly it is not supposed to be doing this, metrics thing
22:54:41 <fraktor> Prometheus is not really great as a time-series database generally, but if you're doing metrics, then it's absolutely the tool (or a very good tool anyway) for the job.
22:54:59 <Guest26> im not
22:55:12 <Guest26> it was just a simple example of a time varying value
22:55:25 <fraktor> Okay.  In that case, a time-series database with a Haskell backend is a good choice. I haven't used influxdb but I've heard good things.
22:55:30 <Guest26> but a random number based on time of day is a better example
22:55:34 <fraktor> If you don't mind me asking, what is the data that you're sending?
22:56:24 <Guest26> like i say, generally any json serializable, or perhaps binary serializable data. so generally any type that supports a generic instance. 
22:56:50 <fraktor> Is it all time-series data?
22:56:56 <EvanR> a single random number based on the current time of day can be pretty bad
22:57:04 <dsal> Even 4?
22:57:14 <EvanR> 4 is one of the worst
22:57:14 <Guest26> but if it has to go to an SQL database so it can be read by the HTML page, then maybe this limits the type
22:57:30 <fraktor> I don't mean to pry but, what is the problem you're trying to solve?
22:57:51 <Guest26> fraktor: its not time series data persay, refreshing the webpage should just visualise the current database  
22:58:08 <Guest26> it would be time series data if the database update were just simple addition of a new value
22:58:09 <dsal> What is "the current database" ?
22:58:38 <Guest26> thats quite arbitrary - but for the sake of argument its a list of (time of day,double)
22:59:02 <fraktor> You can absolutely use Haskell as a backend for some kind of frontend, and that would solve that problem, but what on earth are you doing with it?
22:59:04 <Guest26> at least then i can imagine a simple HTML based visualisation thats just an xy graph 
22:59:10 <fraktor> Like, what is the software you're writing trying to solve?
22:59:16 <dsal> Is a database even helpful?  If your goal is to put all the data in a web page, then what does the database do here?
22:59:40 <fraktor> dsal: I think that they were saying they didn't want to use the database if possible
22:59:40 <Guest26> the database was for when i was thinking to visualise the data using R
23:00:00 <Guest26> the R tutorial here used an SQL server; https://www.r-bloggers.com/2018/07/real-time-data-visualization-using-r-and-data-extracting-from-sql-server/
23:00:04 <dsal> I've never used R with a database.
23:00:23 <Guest26> but if i dont use R, but a haskell powered webpage instead, maybe i dont need SQL
23:01:01 <fraktor> What is this data? I'm really trying to understand what kind of data would have the properties you're describing.
23:01:02 <Guest26> the most important feature is to be able to somehow have the webpage read some data written to disk by the other haskell program producing the data
23:01:05 <dsal> You're just using words in places where they don't fit and that's a bit confusing.
23:01:28 <dsal> Web servers are pretty good at reading data from disk and serving it to web browsers.
23:01:42 <Guest26> % utc
23:01:42 <yahb> Guest26: ; <interactive>:111:1: error: Variable not in scope: utc
23:02:08 <Guest26> % getCurrentTime
23:02:08 <yahb> Guest26: ; <interactive>:112:1: error:; * Variable not in scope: getCurrentTime; * Perhaps you meant `getCurrentCCS#' (imported from GHC.Prim)
23:02:19 <Guest26> hmm, thats from Data.Time
23:02:50 <Guest26> [(UTCTime,Double)]
23:03:18 <fraktor> I understand that's the format of the data.
23:03:24 <dsal> % getCurrentTime 
23:03:24 <yahb> dsal: 2020-09-26 06:03:02.989582121 UTC
23:03:27 <fraktor> But like, what are you trying to accomplish with this software?
23:03:42 <Guest26> maybe i could write each data entry to its own file, but that seems bad. thats where i thought an SQL database that could be simultaniously updated by one process, and read by another process, would be good
23:03:44 <fraktor> I'm asking because a solution might already exist for what you're doing.
23:04:19 <Guest26> certainly not, the data is being calculated by another program, its impossible this would already exist
23:04:27 <dsal> Do you have a problem you're trying to solve?  It just sounds like you have a few parts y ou want to be part of a solution, but you don't have a problem that will use all those parts.
23:04:35 <Guest26> you could think of it as a mass spring system for example 
23:04:45 <fraktor> Oh, so you're running simulations?
23:05:00 <Guest26> its just calculated data, that is output infrequently 
23:05:21 <Guest26> and i want to have the time on the x axis of the plot in the html page
23:05:34 <fraktor> I see. So you do want a time-series database, but Prometheus is kinda the wrong tool.
23:05:43 <Guest26> so that the most up to data version is displayed on refreshing the page
23:06:20 <dsal> If you serve a file from a web server, it will serve the latest version of that file when requested.
23:06:30 <fraktor> May I suggest Grafana? It's an open-source visualization tool that can use whatever as a backend, I think including static files
23:06:33 <Guest26> the components i need are something equivalent to an SQL database for storing the data to, and something like a HTML page, that can do the visualization 
23:06:48 <dsal> Yeah, I'm using grafana with influxdb.  It's pretty great.
23:07:03 <dsal> I liked not having to write that part.  heh
23:07:25 <fraktor> In case you can't tell I've done DevOps stuff before, so Prometheus and Grafana are my go-to tools for system monitoring lol
23:07:30 <dsal> I've got a bunch of bits of haskell that read and write influxdb and a bunch of that stuff ends up in grafana.
23:07:53 <dsal> I've managed to never use prometheus.   At this point, I'll just keep not using it .heh
23:08:00 <Guest26> this? http://hackage.haskell.org/package/grafana-0.2 https://en.wikipedia.org/wiki/Grafana
23:08:03 <Guest26> looks good
23:08:46 <dsal> It's very unlikely you want a grafana haskell lib.
23:08:50 <fraktor> I'd recommend using an intermediary DB now that I understand a little better, since that means you can run arbitrary queries on it.
23:08:58 <Guest26> and this https://hackage.haskell.org/package/influxdb https://en.wikipedia.org/wiki/InfluxDB 
23:09:19 <fraktor> The Grafana haskell library is for when you want to write a custom interface with grafana, and using an intermediary database is simpler and more powerful.
23:09:22 <Guest26> ah, yeah, i thought SQL seemed better than trying to write to the disk
23:09:30 <Guest26> so is that where influxdb is advised?
23:09:31 <fraktor> Yep. InfluxDB and Grafana are a good pair from what I've heard
23:09:44 <Guest26> dsal: any chance of a demo?
23:10:08 <dsal> "sql" and "write to the disk" aren't different things.
23:10:12 <dsal> I use sql to write to the disk.
23:10:19 <dsal> Let me see if I can find a good one.
23:10:45 <Guest26> https://hackage.haskell.org/package/prometheus https://prometheus.io/ 
23:10:51 <Guest26> im not sure about that...
23:11:00 <Guest26> i dont think metrics is the right idea here
23:11:12 <fraktor> Yeah, Prometheus is the wrong tool here
23:11:14 <dsal> You've made it really hard to have any idea what you're doing.
23:11:48 <Guest26> sorry
23:11:56 <dsal> Most of my stuff is readings I pick up via mqtt and write to influxdb (using github.com/dustin/influxer )
23:12:10 <dsal> If my network wakes up, I'll try to pull up a dashboard.
23:13:30 <dsal> Here's a small dashboard of my car from a recent drive:  https://snapshot.raintank.io/dashboard/snapshot/biEthNTKdEOHlOrgIpnrcUFjQljRrQTF
23:14:00 <fraktor> Yo I gotta ask, why
23:14:06 <Guest26> im not quite sure what im looking at here
23:14:24 <Guest26> either the github or the graphana dashboard 
23:14:40 <dsal> This is one of my haskell MQTT servers:  https://snapshot.raintank.io/dashboard/snapshot/nvP6u1KXnbrd0fY9RFz2qCYvBe4YHUsy
23:14:40 <fraktor> This is a dashboard for the various metrics that were collected from dsal's car
23:15:13 <Guest26> it seems like this is very powerful visualisation. it could be perfect - the bit im not sure about now is the databasing 
23:15:14 <dsal> fraktor: people mock my Car monad, but the Car monad serves me well.
23:15:32 <Guest26> what does its join instance do!?
23:15:34 <dsal> This is backed by nifluxdb.  My programs just dump stuff into influxdb.
23:15:47 <dsal> Crashes cars!
23:16:22 <Guest26> makes a train?
23:16:24 <alexm_> @pl score c = Score . fromMaybe 0 $ lookup c score
23:16:25 <lambdabot> score = fix (((Score . fromMaybe 0) .) . flip lookup)
23:16:29 <fraktor> The way that Grafana works is that you create graphs that are associated with queries, and then the results of those queries are used in the visualization. So you can have the same underlying data and change the query to visualize the same data in a different way without modfying your program.
23:16:33 <dsal> It mainly just holds the state and pushes stuff through.  e.g. https://dustin.github.io/tesla/Tesla-Car-Command-Alerts.html
23:17:06 <dsal> heh, if pl gives you fix, you should win a prize.
23:17:18 <Guest26> hmm, it seems like i would have to learn graphana before i could get this up and running
23:17:31 <dsal> What would you prefer to learn?
23:17:33 <fraktor> It's very easy to get started with, especially compared to writing your own visualization
23:17:39 <fraktor> @pl
23:17:39 <lambdabot> (line 1, column 1):
23:17:39 <lambdabot> unexpected end of input
23:17:39 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
23:17:46 <fraktor> What is @pl?
23:17:57 <Guest26> i was hoping there might be a path of less resistance - i just needed a very simple plot - and if it can be haskell that would be better  
23:18:05 <Guest26> i kind of wanted haskell html
23:18:11 <dsal> fraktor: pl is a pointfree converter.
23:18:20 <dsal> @pl f x = a x
23:18:20 <lambdabot> f = a
23:18:22 <fraktor> Guest26: Well, you'd need to write that yourself then, afaik.
23:18:33 <Guest26> thats what i was asking about
23:18:50 <Guest26> but yes, a very much more simple version of this is kind of what i was after
23:18:54 <Guest26> but written in haskell
23:19:27 <dsal> At some point, you have to make things a browser understands.
23:20:58 <fraktor> Also, I think that setting up a grafana dashboard would still be easier than writing a haskell program, even if a library for client-side visualization already existed?
23:21:03 <Guest26> perhaps it could be as simple as just displaying a jpg, but then i would need to use something like an external ploting program to produce this from input data
23:21:29 <Guest26> oh, and then it wouldnt refresh properly
23:21:46 <Guest26> fraktor: im not sure that it would
23:21:51 <fraktor> Grafana is probably the most robust solution
23:21:52 <dsal> jpg is the worst format for displaying data
23:21:57 <fraktor> At least use PNG
23:22:03 <Guest26> sorry...
23:22:13 <fraktor> No, it's okay! We're just thinking about what would annoy us as users
23:22:17 <dsal> heh
23:22:25 <Guest26> oh! it wasnt for an actual webpage
23:22:27 <dsal> dumb peeves
23:22:36 <Guest26> i mean, not for comercial use
23:22:45 <fraktor> Even as an internal user I would be annoyed
23:22:53 <Guest26> i just wanted to be able to quickly refresh the graph of some data i was generating
23:23:09 <dsal> this problem has been solved so many ways, it's weird to even talk about it.
23:23:13 <Guest26> there is something nice about the low latency of the html solution
23:23:25 <fraktor> Also dsal, I don't know what to ask about first: the fact that you have a dashboard of metrics for your Tesla, or the fact that it's called "Muad'Dib." Do you have a spice-powered car?
23:23:29 <dsal> what's low latency about htlm?
23:23:43 <fraktor> Guest26: I mean, Grafana automatically refreshes stuff, and you don't have to refresh the whole page
23:23:43 <dsal> fraktor: haha.  I was reading Dune when I got it.
23:24:07 <dsal> fraktor: I like collecting data, though.
23:24:16 <Guest26> hmm, i think i should probably insist on the approach that doesnt use the third party tool
23:24:30 <fraktor> You do you
23:24:35 <Guest26> im specifically trying to write a webpage with a very simple graph
23:24:42 <Guest26> and my main concern is the database
23:25:01 <Guest26> im not sure if inflixdb is best - maybe thats just good for graphana
23:25:10 <fraktor> Do you want to keep old data around for a while? Or can it be discarded?
23:25:46 <dsal> I wrote a tool called 'influxer' that writes stuff from mqtt to influxdb, and a tool called outfluxer that runs influxdb queries and spits out mqtt topics.
23:26:07 <dsal> Lets me make easy dashboards on my phone that tell me current things like how much energy I've generated today so far.
23:26:28 <Guest26> the database should persist in memory - but i can write these to special .dat files, and then just have another program mirroring these on to the database, that shouldnt be too hard, the main point is having it as something that can be easily queried by the HTML page
23:26:36 <Guest26> i dont want to be writing fancy HTML
23:27:07 <fraktor> You're going to have to write something to do the plot?
23:27:14 <Guest26> yes
23:27:32 <Guest26> but i was hoping there would be html or js solutions
23:27:49 <Guest26> not sure how difficult it would be to use them with a haskell webpage though 
23:28:00 <dsal> fraktor: For a good time, you can see my influxer confs.  Gets a few fun things  I can plot in grafana, but the tool also stores the whole captured state periodically:  https://gist.github.com/dustin/3015d0dee2b5cee3ce8b2d1895aee144
23:28:37 <dsal> I realized looking at this that one of my mqtt servers isn't storing its stats.  :(
23:29:25 <fraktor> Guest26: There are Javascript libraries that do graphs and so on
23:29:33 <Guest26> this is what i used to get a html thing working; https://ocharles.org.uk/posts/2013-12-19-websockets.html
23:29:37 <fraktor> But if you want a pre-built solution in HTML/JS that can do visualizations... Grafana
23:29:52 <Guest26> but thats not a haskell program
23:29:56 <dsal> Now you're getting into websockets?
23:30:13 <Guest26> that was just a simple web example
23:30:16 <fraktor> ...Why does it have to be a Haskell program? So that you don't need the database?
23:30:25 <Guest26> i guess i could use yesod instead 
23:30:33 <dsal> My mqtt client and server both support websockets.  That's about all I know about WS.  heh
23:31:45 <Guest26> it doesnt have to be a haskell program - it just has to be simple enough code for me to understand, and haskell is a huge advantage in that
23:32:13 <Guest26> the html used in o'charles blog post is very very simple, simple enough to understand even
23:32:24 <Guest26> graphana however...
23:32:39 <fraktor> I've never read HTML I couldn't understand. It's just markup
23:33:00 <Guest26> well, anything except haskell is difficult for me to read
23:33:24 <fraktor> Can you use WebSockets in HTML without Javascript?
23:33:29 <fraktor> I haven't heard of that before
23:33:36 <dsal> You can't use websockets in html at all.
23:34:08 <dsal> There's a javascript mechanism.
23:34:19 <Guest26> whatever is the least sufficient way to convert it to haskell development, like a thin wrapper in HTML or something, thats fine, as long as it does not require any actual proficiency in the second language to maintain - thats why i cant do android  
23:34:36 <dsal> My GoPro interface was written in elm and I figured writing a websockets client would be easy there.  It was silly hard.
23:34:59 <fraktor> I mean, ports?
23:35:01 <dsal> Having the haskell code write to WS via MonadLogger was tiny and boring.
23:35:21 <Guest26> here is the code from that blog post example above if you want to see the HTML https://github.com/ocharles/blog/blob/master/code/2013-12-19-client.html
23:35:26 <dsal> Guest26: You have no path that doesn't require learning.
23:35:53 <Guest26> least sufficient HTML is preferred to graphana  
23:36:36 <Guest26> its more transferable. if i learn how to do graphs with html and js and haskell, im sure thats a better approach 
23:36:37 <dsal> Do you even have a theoretical way to display a timeseries chart in HTML?
23:36:48 <Guest26> arguably industry might prefer i use graphana. 
23:37:09 <fraktor> dsal: Why was the Elm client silly hard?
23:37:24 <Guest26> dsal: no, but thats the perfect question
23:37:44 <Guest26> i wonder if there is anything written using scotty that does that
23:38:15 <dsal> fraktor: there's just no way to do websockets.  Required lots of weird stuff in a third party library and javascript bridgy stuff to get working at all.
23:39:56 <fraktor> Oh yeah. You need ports and message conversion and stuff
23:40:00 <Guest26> i suppose i could just send all the data through the websocket and not bother with the db
23:40:22 <fraktor> It's better now though https://github.com/elm-lang/websocket
23:40:25 <Guest26> but thats not really "language independent" 
23:40:50 <Guest26> if i wrote it to SQL, then that R visualisation approach would work too... 
23:41:31 <Guest26> i guess with that design consideration im back considering SQL proper vs haskelly alternatives
23:41:49 <Guest26> im not sure if they are as easy to query from some arbitrary endpoint language
23:42:25 <Guest26> i can find this though; https://github.com/dleutnant/influxdbr
23:42:31 <dsal> fraktor: hmm...  That might be better.
23:42:50 <Guest26> "R interface to InfluxDB"
23:43:03 <Guest26> and then i guess i would want this in html aswell
23:43:44 <dsal> I had to use some PortFunnel thing and a bunch of other junk.
23:44:25 <fraktor> https://github.com/elm-community/js-integration-examples/tree/master/websockets
23:44:32 <fraktor> This is apparently the preferred solution nowadays
23:44:38 <Guest26> i might want to add a button or something, i dont know if i could do that with graphana
23:44:49 * hackage commandert 0.1.0.0 - A monad for commanders  https://hackage.haskell.org/package/commandert-0.1.0.0 (sgschlesinger)
23:44:57 <Guest26> and i might not want to be working in r if i want to start making it more complicated
23:45:19 <Guest26> so i think a haskell html thing is really what i want, for the reason of customisability 
23:45:47 <Guest26> i might want to restart the simulation from different random initialisation for example
23:45:56 <dsal> You want a thing you don't know anything at all about because it does all the things you can imagine.  heh
23:46:18 <dsal> fraktor: I guess I should update this gross stuff.
23:46:19 <Guest26> well, thats why i want to have it written mostly in haskell 
23:46:53 <Guest26> so far it seems like databasing is only good for interfacing with R or graphana or such
23:47:21 <Guest26> and that what i should really be asking is more to do with writing a simple graph in yesod or something 
23:47:29 <dsal> I gave a kid a 3D  printer a few days ago.  He was asking me whether he could make each of a long list of things.  He just saw a tool come in that can make physical things, so he thinks of every physical thing and asks if it can make that thing.
23:48:08 <Guest26> im justifying, with a good reason, why graphana isnt right for what i want to do
23:48:39 <fraktor> You don't have to justify it to us
23:48:43 <Guest26> while motivating why the approach i would prefer, is better
23:48:53 <Guest26> ok, well i just thought id explain
23:48:56 <dsal> Your reason is "I don't know anything about how web UIs work, but I can write something better than what everyone else uses once I learn it all."
23:49:05 <Guest26> dsal: im happy for the kid that got the 3d printer 
23:49:30 <EvanR> didn't you just explain 99.9% of where web UIs came from
23:49:41 <EvanR> seems to work
23:49:42 <Guest26> i dont need it to be "better" i just need it to support a graph, and a button
23:50:00 <dsal> Heh, that's fair, EvanR 
23:50:03 <Guest26> and anything else i need to think of to mean graphana isnt going to do it!
23:50:18 * hackage commander-cli 0.8.0.0 - A command line argument/option parser library  https://hackage.haskell.org/package/commander-cli-0.8.0.0 (sgschlesinger)
23:50:23 <dsal> Guest26: but you don't have a working theory of what "a graph and a button" in haskell might look like.
23:50:36 <dsal> Because you can't just throw haskell at a web browser and get that result.
23:50:57 <dsal> You have to feed the browser a language it understands, or use an intermediary that someone has built for you.
23:51:01 <Guest26> this is the question - and the graphana is a distraction from that ultimate goal
23:51:09 <EvanR> a graph and a button is really easy with some javascript
23:51:16 <dsal> e.g., ghcjs will *run* in a browser, but it won't magically make a functional UI.
23:51:55 <Guest26> well then it seems like "no haskell for the web interface" is advocated
23:52:17 <EvanR> if the goal is to use haskell that's another story
23:52:36 <Guest26> it would be better if as much of it as possible was in the language i can actually write in
23:53:18 * hackage commander-cli 0.9.0.0 - A command line argument/option parser library  https://hackage.haskell.org/package/commander-cli-0.9.0.0 (sgschlesinger)
23:53:25 <Guest26> then the html could be as simple as just refreshing an image, and the haskell file then just has to write the graph to a .png
23:53:49 <Guest26> and the button with simple websockets is basically all then covered by that o'charles blogpost
23:53:55 <fraktor> dsal: Regarding PortFunnel, it looks like you wanted to take different kinds of websocket messages and turn them into different elm messages. Which I think you can do with a case statement in subscriptions?
23:54:00 <dsal> Why websockets?
23:54:16 <Guest26> to send the data from the button to the running haskell program
23:54:33 <dsal> fraktor: I spent a while trying to figure it out when I wrote that.  A better answer would be great.  This one also seems a little unreliable.
23:55:16 <Guest26> but then the problem is still, producing a png from the haskell data
23:55:31 <Guest26> and then im back trying to send it through R
23:55:39 <dsal> Guest26: why does the button have data?  It's unclear what webockets does other than make the problem a lot harder.
23:56:03 <dsal> I'm using websockets to stream MonadLogger messages to my web app as stuff happens.
23:57:17 <Guest26> this is all because i couldnt get sdl-diagrams to work...
23:57:19 <fraktor> dsal: Is this project open-source? I can maybe take a look
23:58:23 <Guest26> dsal: the data it could send could be interpreted by the haskell program, so it could be eg a command such as "restart simulation" or "convert boundaries to reflective/periodic" 
23:58:51 <dsal> fraktor: Alright, but I don't use standard elm layout because I wrote all this code before anyone told me about it and I thought it was ugly.  heh  github.com/dustin/gopro  -- static is the, uh, static content.  ui is the elm source.
23:59:22 <dsal> socketHandler handlers sockets.
