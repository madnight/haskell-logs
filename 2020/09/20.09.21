00:15:03 <dminuoso> Is there something equivalent to Chronicle's condemn for hspec Spec? I have a series of specs that rely on preconditions of earlier specs succeeding.
00:41:50 <shad0w_> yo, anyone around 
00:42:04 <shad0w_> woops. wrong channel
00:42:49 * hackage jord 2.0.0.0 - Geographical Position Calculations  https://hackage.haskell.org/package/jord-2.0.0.0 (CedricLiegeois)
00:44:10 <dansho> are io actions not ordered? i don't understand why this doesn't measure time elapsed https://hatebin.com/zwvzuzpfih
00:44:26 <dansho> it returns something like 0.00015 seconds
00:47:36 <dansho> oh i guess its not measuring wall time, or something
00:48:27 <dminuoso> "Computation getCPUTime returns the number of picoseconds CPU time used by the current program"
00:48:52 <dminuoso> The sleep is not busy sleep
00:59:07 * edwardk does a little dance.
00:59:38 <Axman6> Don't hold back Ed
01:00:08 <edwardk> i just managed to get my 'types' library to let me use Constraint one of the many kinds i managed to lower to the term level
01:00:10 * siraben sends a request to the current effect handler to do a little dance
01:00:14 <edwardk> this means Sing p subsumes Dict p
01:00:42 <Axman6> :o
01:00:44 <edwardk> and (:-) becomes able to move around any singleton through SingI instances, so it becomes a way to pass arbitrary functions between singleton types
01:00:51 <edwardk> So now
01:01:01 <edwardk> Sing (a :: Type) -- is TypeRep a
01:01:07 <edwardk> Sing (a :: Constraint) -- is Dict a
01:01:38 <edwardk> Sing (a :: String) -- is a type level string that you can actually cons on, take/drop from and otherwise manipulate unlike Symbol.
01:01:57 <edwardk> etc.
01:02:37 <Taneb> Ooh, that's pretty neat
01:03:23 <edwardk> but the idea of a polykinded (:-) makes me super happy
01:03:34 <edwardk> (:--) i guess to go with what :~~: does for HRefl
01:04:00 <edwardk> would be any function from Sing a -> Sing b -- and can be lifted into Constraint!
01:04:13 <edwardk> or maybe
01:04:15 <Axman6> that last oe is excellent - do you have to construct the strings a char at a time?
01:04:40 <edwardk> yeah they get built up out of nil and cons. because String is defined as [Char]
01:04:42 <edwardk> and i can lift Char
01:04:45 <edwardk> and I can lift []!
01:04:57 <edwardk> i can give a little TH love to generating them
01:05:58 <edwardk> oh, and i was able to overload things so that all the numeric types, injective or crappy like Nat can share a S and Z pattern
01:06:37 <edwardk> er S and Z type family
01:09:05 <edwardk> > sing :: Sing '(1,Eq Int,Just (Z :: Int))  ==> Sing @(Nat,Constraint,(Maybe Int)) (1,Constraint Dict,Just 0)
01:09:08 <lambdabot>  <hint>:1:52: error: <hint>:1:52: error: parse error on input ‚Äò@‚Äô
01:09:49 <edwardk> er didn't mean to > that
01:13:50 <Taneb> Is Z a pattern synonym there?
01:14:12 <edwardk> Z there is actually a type family i have that expands to 0 in Nat and to various other things in other kinds
01:14:39 <Taneb> Right
01:14:49 <edwardk> i hack Int to have a pair of injective type constructors for Z# and S# and it delegates to those for that kind
01:15:51 <edwardk> testEquality (sing :: Sing Int) (sing :: Sing Int)   ==> Just Refl
01:16:29 <edwardk> i had to get fancy with S and Z because the lack of injectivity in Nat's (1+) approach to define Succ meant when you start building singletons on things like a Vec type that is indexed by a Nat you start breaking
01:16:47 <edwardk> but if you use the fact that Natural now has Z and S which are injective for all kinds other than Nat it works fine
01:20:03 <edwardk> oh yeah, i forgot it is taken by the repl. i guess i need a better name
01:20:06 <edwardk> er 'it'
01:20:39 <edwardk> I and 'me' would be cute but the former too short. maybe You and you.
01:21:02 <edwardk> no good ungendered singular pronouns
01:23:38 <edwardk> ok, going with Me and me
01:23:49 <edwardk> that way the template haskell function for building it is makeMe
01:24:45 <edwardk> between that and makeNice this is becoming punnier than expected
01:31:46 <edwardk> and bugger
01:32:45 <edwardk> there appears to be a bug where when i go to try to validate that i can't subvert things by using Sing on constraint, it yells about overlapping instances for StrictEq Constraint -- when there is no instance?
01:32:50 <edwardk> i have one on Type
01:33:00 <edwardk> but Constraint and Type are different types to the surface language
01:33:08 <edwardk> but even so i only have the one instance
01:35:37 <Axman6> time for a GHC bug report "Ed broke it again: Overlapping instances for StrictEq Constraint"
01:38:50 <edwardk> ok, fixed it
01:38:57 <edwardk> just crappy error reporting. whew
01:44:17 <merijn> edwardk: You need to step up your GHC breaking, at least Iceland_Jack has got an error explicitly calling them out, why don't you? ;)
01:45:23 <edwardk> merijn: i have a clip of simon shouting from the back of the room during a talk that he would change the compiler to make it stop allowing me to do something
01:45:58 <merijn> :D
01:51:18 * hackage hlatex 0.3.2 - A library to build valid LaTeX files  https://hackage.haskell.org/package/hlatex-0.3.2 (NicolasPouillard)
02:05:34 <cpressey> Hi, I recently upgraded cabal from 1.24 (the version that ships with Ubuntu 18 LTS) to 3.0.2 and I'm seeing unusual behaviour: cabal build works, but doesn't detect when I've edited a source file, and cabal install tries to build and fails because it can't find my source files. I can post a minimal example in a gist if it helps.
02:06:56 <[exa]> cpressey: do you have all modules listed in the cabal file? (otherwise, a MWE would certainly help)
02:07:29 <maerwald> 3.0.2?
02:07:48 <maerwald> that version doesn't exist
02:08:06 <[exa]> probably meant 3.2.0.0?
02:08:22 <cpressey> maerwald: "cabal-install version 3.0.0.0\ncompiled using version 3.0.2.0 of the Cabal library"
02:08:32 <maerwald> upgrade to 3.2.0.0
02:08:55 <cpressey> [exa]: In fact I don't, that could easily be the problem.
02:10:11 <[exa]> debian says it has 3.0.0.0-3 which might be the same... You may just use the binary distribution of cabal from their website, or get one using ghcpu
02:10:16 <[exa]> *ghcup
02:10:54 <[exa]> a common observation here is that ghc/cabal versions from $distro's package manager usually suck
02:11:20 <maerwald> there's also https://launchpad.net/~hvr/+archive/ubuntu/ghc but it lacks ghc-8.10
02:11:24 <cpressey> maerwald: This is the version it gave me when I did "cabal install cabal-install" on (I think) Friday.  I'll try upgrading again and see if it goes all the way to 3.2 this time.
02:11:48 <maerwald> ah no, it has 8.10
02:12:01 <maerwald> cpressey: cabal install cabal-install doesn't work very well
02:12:02 <int-e> cpressey: the newer cabal-install should pick up the most recent cabal-install ;-)
02:12:32 <merijn> You might need to "cabal update" first :p
02:12:34 <maerwald> int-e: that depends on your GHC version, not cabal-install
02:12:35 <int-e> maerwald: it turns out that cabal-install 3.2 cannot be built with cabal-install<2.2
02:12:49 <maerwald> well, then both
02:12:57 <cpressey> [exa]: Is it absolutely required to list all modules in the cabalfile? In development, I sometimes add/remove modules, and it would be nice to not have to remember to update the cabalfile too
02:13:31 <maerwald> cpressey: you can use cabal-fmt to auto-expand modules https://oleg.fi/gists/posts/2019-08-11-cabal-fmt.html
02:13:36 <merijn>  cpressey: Also, why did you still have 1.24? :o THat's ancient
02:14:07 <phadej> merijn: some people use distributions' package managers, and their repositories ;)
02:14:08 <cpressey> merijn: because I'm running Ubuntu 18.04 LTS and was still using the version in their package repository.
02:14:20 <phadej> but does 18.04 has that old cabal-install
02:14:21 <merijn> cpressey: Short answer: Yes. Long answer: Yes, because the cabal file is supposed to *define* what goes into a source distribution and doing that sorta thing implicitly is...a bad idea
02:14:28 <int-e> phadej: yes
02:14:30 <phadej> that's wiked
02:14:31 <merijn> cpressey: Wow, that's depressing
02:14:48 <int-e> phadej: 18.04 was released very shortly after cabal-install 2.0.0.0
02:14:59 <int-e> phadej: presumably it was frozen then.
02:15:00 <merijn> cpressey: 1.24 is probably at least 4-6 years out of date by now :o
02:15:12 <[exa]> cpressey: well it sometimes picks the unlisted modules correctly for me, but I have no idea about the precise reason why it works
02:15:21 <merijn> [exa]: It doesn't
02:15:24 <maerwald> merijn: that's what LTS means
02:15:26 <maerwald> lol
02:15:34 <merijn> [exa]: However, GHC looks for imports independent of cabal
02:15:36 <cpressey> Well, not listing the modules in the cabalfile probably explains my problem, anyway. Thanks all.
02:15:51 <merijn> [exa]: So, even if files aren't listed, GHC may find them
02:16:28 <[exa]> o good
02:16:33 <int-e> phadej: Or hmm. Am I off by a year? Anyway, 1.24 wasn't ancient yet then :P
02:16:34 <[exa]> makes sense, thanks
02:17:07 <int-e> phadej: and your 4-6 years are definitely closer to 3.
02:17:14 <merijn> int-e: That was mine
02:17:29 <merijn> Although, admittedly I may have been using the source version
02:17:32 <int-e> ah. oops I did it again...
02:17:56 <merijn> I just recall switching to new-build early on in the Haskell part of my phd codebase and I moved on from 1.24 really shortly after that :p
02:18:07 <phadej> 20.04 is using 2.4.0.0
02:18:13 <phadej> though there definitely was 3.0 and 3.2
02:18:22 <boxscape> was curious how the constraints package implements Gcd so I took a look and... https://hackage.haskell.org/package/constraints-0.12/docs/src/Data.Constraint.Nat.html#Gcd
02:18:23 <boxscape>  that doesn't look right? Am I missing something or is it just not fully implemented?
02:18:27 <merijn> int-e: Perhaps it's just academic trauma induced time dilation that makes feel like it was 6 years :p
02:18:28 <phadej> and **worse**, they have ghc-8.8
02:18:34 <phadej> which cabal-install-2.4 doesn't support
02:18:39 <phadej> they = Ubuntu
02:18:51 <merijn> lol
02:18:56 <int-e> merijn: FWIW, I was surprised as well... it feels longer.
02:18:59 <merijn> Linux packaging, yay!
02:19:02 <phadej> or now
02:19:09 <phadej> s/now/no
02:19:16 <phadej> it's 8.8.1+dfsg1+is+8.6.5
02:19:23 <phadej> which is :)(:
02:19:40 <int-e> phadej: still usable for bootstrapping a real ghc.
02:19:59 <phadej> feels like it's common that distribution packages don't really are up to date with where HAskell goes
02:20:05 <phadej> int-e: to bootstrap 9.0 you need 8.8.1
02:20:08 <phadej> that one is really 8.6.5
02:20:11 <phadej> so no luck.
02:20:20 <tomsmeding> boxscape: not to speak about Lcm, Div and Mod
02:20:24 <int-e> phadej: 9.0 isn't released
02:20:34 <phadej> int-e: I hope it's matter of weeks now.
02:20:36 <boxscape> tomsmeding right
02:21:07 <maerwald> int-e: 9.0.1-alpha1 is
02:21:09 <tomsmeding> boxscape: does it actually _work_, somehow in a way that we don't understand? or is it actually unimplemented
02:21:19 <tomsmeding> work as in "test it"
02:21:27 <boxscape> I haven't actually tried to be honest but I guess I should, and I will right now
02:21:29 <phadej> ghc "support" windows are too short for ubuntu :(
02:22:15 <maerwald> boxscape: try to be honest next time
02:22:38 <boxscape> but I was honest this time too :(
02:22:55 <boxscape> it doesn't work, by the way - Gcd 4 2 is not reduced
02:23:01 <tomsmeding> heh
02:23:02 <phadej> maerwald: there is no 9.0.1-alpha1, is there?
02:23:16 <maerwald> https://downloads.haskell.org/~ghc/9.0.1-alpha1/
02:23:36 <tomsmeding> boxscape: file a bug report :)
02:24:09 <boxscape> I suppose I will, or maybe a PR if I can figure out how it should work
02:25:31 <merijn> hah
02:25:53 <merijn> Next thing you know you'll be handed commit access and responsible for maintaining it ;)
02:25:59 <boxscape>  oh boy
02:26:05 <int-e> phadej: hmm if you release 2 major versions per year and you support the 2 latest major versions for bootstrapping...
02:26:09 <boxscape> I am not at all qualified to handle the constraints package :)
02:26:09 <tomsmeding> unlikely for this particular package I think
02:26:17 <phadej> maerwald: there isn't tag in repository
02:26:24 <int-e> ...that's not a very generous time frame
02:26:26 <phadej> maerwald: so I have no idea what that directory is about
02:26:45 <phadej> maerwald: also it wasn't announced, and according to ben, if something weren't announced it doesn't exist.
02:26:50 <maerwald> phadej: I don't know either, but it works fine :p
02:27:00 <phadej> maerwald: specifically, I'd ask you to not add that to ghcup
02:27:05 <phadej> to not confuse shit out of users
02:27:21 <maerwald> what's confusing about it?
02:27:53 <phadej> if there would be an bug report "GHC-9.0.1-alpha1 regresses ..." 
02:27:56 <maerwald> phadej: also, ben uploaded that and signed it with his key
02:28:06 <cheater> hi
02:28:24 <cheater> is vty still the best thing for creating simple curses style UIs or is there something else you would suggest
02:28:36 <merijn> vty is low level
02:28:45 <merijn> For something higher level, probably you want brick
02:29:14 <merijn> cheater: vty deals with terminal emulation, brick deals with "using vty to draw widgets and stuff"
02:29:39 <cheater> i want to create a very simple text editor
02:29:46 <cheater> vim style
02:30:05 <[exa]> you really want brick
02:30:19 <merijn> Prepare to be surprised how comlex text editing is :p
02:30:29 <maerwald> merijn: yeah, I looked into yi... whew
02:30:49 <cheater> all it'll do is move lines up and down. that's all.
02:30:56 <merijn> Was it Atom that took like 5 years before it could open files ? 5 MB
02:30:57 <cheater> maybe edit them and add new ones or remove some.
02:31:13 <merijn> cheater: Yeah...that's harder than you think :p
02:31:14 <cheater> file size limited to 100k.
02:31:22 <cheater> merijn: oookay
02:31:39 <maerwald> 100k is a very precise unit
02:31:43 <cheater> brick says "This package deprecates vty-ui." ahh i've been using vty-ui
02:31:43 <merijn> I have a 30 page paper on "data structure for text editing" :p
02:31:49 <cheater> wow can y'all stop lol
02:32:02 <merijn> cheater: yeah, brick is the successor of vty-ui
02:32:02 <[exa]> cheater: isn't that motivating? :]
02:32:06 <maerwald> we're trying to encourage you
02:32:10 <cheater> no, it's boring
02:32:16 <cheater> i have enough problems as it is
02:32:18 <maerwald> it's so hard, you must do it
02:32:31 <Cheery> there was a library in haskell for rendering text
02:32:35 <tomsmeding> cheater: I've written a terminal text editor in c++ without using any terminal library at all
02:32:35 <boxscape> wait... Div and Mod seem to work, even though Gcd and Lcm don't
02:32:35 <maerwald> (isn't that what motivates haskellers?)
02:32:43 <tomsmeding> if I can do that you can do it with the niceties that haskell gives you
02:32:46 <cheater> tomsmeding: nice
02:33:03 <cheater> yeah i'm just writing a small manual decompiling helper
02:33:11 <tomsmeding> (before you actually go and look at that c++ code beware it's ugly and bad)
02:33:16 <cheater> like, be able to move lines around without violating semantics
02:33:18 <cheater> that's all really
02:33:21 <boxscape> oh but that's because I'm using Div and Mod from a different package, never mind
02:33:25 <[exa]> cheater: o nice, decompiling what precisely?
02:33:27 <tomsmeding> boxscape: :D
02:33:28 <boxscape> (base)
02:33:35 <cheater> shader assembly
02:33:49 <tomsmeding> boxscape: perhaps their implementation in base can suggest how to implement Gcd in constraints
02:33:54 <boxscape> yeah, good point
02:34:07 <boxscape> wait
02:34:10 <boxscape> they're built in
02:34:12 <[exa]> cheater: very cool
02:34:14 <cheater> i decompiled it by hand already but i introduced a bug and it's going to be impossible to track down, so i'm gonna do this now
02:34:25 <cheater> i commuted some lines that i shouldn't have
02:34:26 <cheater> i think
02:34:29 <merijn> ah, rats
02:34:35 <tomsmeding> cheater: https://xkcd.com/1205/
02:34:39 <merijn> I can't find a copy of the PDF i was talking about now
02:34:44 <cheater> i'm not clicking any xkcd links
02:35:18 <tomsmeding> merijn: pity
02:36:45 <tomsmeding> merijn: it's not this one by any chance? https://www.cs.unm.edu/~crowley/papers/sds.pdf
02:37:04 <merijn> Ooh, looks like it
02:37:10 <merijn> cheater: ^^ that one :)
02:37:28 <gnumonik> Hello. I'm trying to generate parsers for records automatically using TH. Have a function that gives me a 'Q (Parser a)', but I can't figure out how to turn that into an exp so it's unusable. Is there some way to do that or is it impossible? 
02:37:35 <gnumonik> Am new to TH 
02:37:52 <merijn> gnumonik: You need to unquote it via $()
02:38:07 <cheater> merijn: what is it?
02:38:27 <merijn> If "foo :: Q (Parser a)" then 'bar $(foo)' is "splice the AST of 'foo' in the code here"
02:38:40 <cheater> oh yea no idc i'll just put everything in a list
02:39:13 <cheater> just so you understand where i'm at
02:40:06 <merijn> hmm, I forget how to specify ghc-options for only local packages in cabal.project (i.e. as opposed to for all transitive dependencies)
02:40:58 <gnumonik> I've tried splicing it but it doesn't work. I think it's because I have a Q Parser and not a Q exp. 
02:41:35 <cheater> does Vty work on windows btw?
02:41:38 <cheater> it works, right?
02:41:59 <merijn> gnumonik: oh, wait, yeah
02:42:07 <cheater> hmm i'm not seeing any mention of windows
02:42:17 <merijn> gnumonik: Can you pastebin/gist the code?
02:42:34 <merijn> cheater: It supports windows for users who have/use a proper terminal emulator
02:42:41 <merijn> cheater: So..."maybe"
02:42:42 <cheater> how do i do that
02:42:46 <cheater> is powershell proper
02:42:51 <merijn> No clue
02:43:19 <merijn> That's a messy swamp of complicated questions and ridiculously archaic technology your asking questions about :p
02:44:27 <gnumonik> It's pretty long and I need a sec to unbreak it, I was trying something and I ran out of undo space in VSCode 
02:44:40 <cheater> hmm i need to get git on this machine as well
02:44:44 <gnumonik> But yeah. It just seems like there's no way to get the Parser into an Exp :-( 
02:44:55 <cheater> what's the least painful way to have git on windows? sorry for OT
02:45:33 <mirrorbird> installing linux probably
02:45:38 <[exa]> cheater: the linux subsystem kinda works, msysgit/tortoisegit also work, but the least painful way is likely to...yeah ^^
02:45:51 <cheater> mirrorbird: no
02:46:33 <mirrorbird> how do you know?
02:46:57 <merijn> gitbash
02:47:16 <merijn> gnumonik: You can, but you're mixing levels
02:47:41 <[exa]> cheater: consider https://www.reddit.com/r/haskell/comments/7tutxa/vty_needs_your_help_supporting_windows/
02:47:42 <merijn> gnumonik: You're creating a parser in your quotation, while what you *want* is "the Exp resembling a parser"
02:47:49 <[exa]> cheater: generally, windows does _not_ have a terminal
02:47:50 <cheater> this is how i know mirrorbird and why you've been put on ignore https://twitter.com/PLT_cheater/status/1306114709905694722 
02:48:20 <cheater> [exa]: thanks, looking!
02:48:44 <mirrorbird> cheater, yeah i hate that too
02:48:46 <merijn> cheater: gitbash is what my girlfriend uses on windows for git, seems the most workable solution
02:48:59 <cheater> merijn: thank you
02:49:10 <cheater> merijn: does she know how it compares to WSL1 or WSL2?
02:49:53 <merijn> WSL1/2 are linux emulation layers fully running linux code. gitbash is just a lightweight terminal emulator that runs bash, git and some other commandline tools
02:50:07 <cheater> right
02:50:21 <dminuoso> gnumonik: Of course there is! :)
02:50:23 <merijn> Incidentally, all of GNU coreutils already support windows anyway. I used to use grep/bash/etc. in windows' Command.exe
02:50:28 <cheater> if I need a terminal to run Vty, then maybe this will be a good way to get Vty running
02:50:30 <merijn> No clue how to get git in there, though
02:50:42 <merijn> And git-bash seems to have the most convenient story for installing stuff
02:50:49 <cheater> mhm
02:51:12 <gentauro> I once saw a .cabal file that had, besides several `executable` (`executable foobar` and `executable bazqux`) it also had another `library` besides the main/default. I just don't remember the syntax to add this ad-hoc library. Anybody can help? Thx
02:52:00 <gentauro> is it `library identifier` or how is it done?
02:52:19 <gentauro> I'm using `cabal 2.2`
02:52:26 * gentauro that's the header of the file
02:52:45 <phadej> gentauro: https://cabal.readthedocs.io/en/3.4/cabal-package.html#library scroll down to internal library
02:53:28 <gnumonik> I'm not sure how to get an exp that resembles a parser though :-( And I tried building the AST by hand but i reach a point where I need a way to lift a 'Parser' to get it into the syntax tree and I'm lost
02:53:49 * hackage floskell 0.10.5 - A flexible Haskell source code pretty printer  https://hackage.haskell.org/package/floskell-0.10.5 (ecramer)
02:56:08 <gentauro> phadej: thx. Just what I needed :)
02:58:36 <gnumonik> The only thing I can think of is rewriting a bunch of Parsec (that's what I'm using) by hand in the Haskell AST, so everything's an exp. Actually it'd probably be easier to just write some haskell to generate the text of the source code for the parsers than do that 
03:02:27 <merijn> gnumonik: You want [| |] for lifting stuff into Exp
03:03:12 <merijn> gnumonik: "[| foo 1 >>= bar |]" says "take the code "foo 1 >>= bar" and give me the Exp of that AST
03:05:29 <gnumonik> https://gist.github.com/gnumonik/77554f3a7817495030c16dd46739fa79 is what I have (I think that's all the important stuff, hastily reconstructed, probably quite ugly) 
03:05:35 <boxscape> looks like the Gcm etc. thing in constraints is intentional https://github.com/ekmett/constraints/issues/53
03:08:03 <boxscape> ( tomsmeding, in case you're interested)
03:09:25 <tomsmeding> boxscape: I'm not sure whether that issue still applies, given that Min does seem to have a suitable implementation now
03:09:42 <boxscape> oh, huh, true
03:10:40 <gnumonik> I know how the quotation brackets work. I wish I knew more so I could explain this well. The problem, I think, is that I'm trapped in the Q monad. My function that generates parsers spits out 'Q Parser a's, so when I quote it, I *think* that it's giving me the AST for an expression that spits out the Q stuff. 
03:12:11 <dminuoso> gnumonik: Try generating a `Q Exp` instead. 
03:13:26 <dminuoso> gnumonik: You can either use [| ... |] like merijn suggested, or you build up that construction yourself
03:14:11 <boxscape> s/Gcm/Gcd, whoops
03:15:04 <cheater> has anyone got experience compiling medium large Haskell projects on Windows using WSL1 vs WSL2 if the data must be stored on the Windows file system?
03:18:32 <gnumonik> I tried to do that and I couldn't make it work :-( If I make a parser in the Q monad I can't get it out. I can use the oxford brackets to transform any other function (or w/e) into an exp but whenever I try to quote the parser I generates I get a "No lift instance" 
03:18:54 <gentauro> phadej: I like this feature with `sub-libs`. That way I can keep my main library `Safe` while all the nasty stuff needed by some of the `executables` I can move to these `sub-libs` :-)
03:19:15 * gentauro what's not to like :)
03:26:19 <gnumonik> https://gist.github.com/gnumonik/51b29cb694a8e19052f3613b8cc3fcfa that's problem I think. I can quote *other* parsers in the oxford brackets but for some reason that I don't understand the compiler never lets me quote the one that I made inside the Q monad. So I have to return a 'Q Parser'. Which is kinda useless. 
03:37:55 <cheater> glguy: hi, do you know if there is any way yet to sensibly run Vty on Windows?
03:41:32 <tomsmeding> cheater: what kind of trouble are you hitting?
03:42:10 <cheater> tomsmeding: Vty is said to require an ansi terminal, which windows didn't have until recently, so I don't know if Vty has been updated at all to take advantage of any of that
03:42:28 <tomsmeding> have you tried it? it might just magically work
03:42:46 <cheater> no, it takes a bunch of time to try it. i'd rather ask some people I know have used it.
03:42:59 <tomsmeding> sure :)
03:44:36 <dminuoso> What is the reason `cabal build foo:test:bar` requires --enable-tests (sometimes?). Why is there some mutable state requiring me to switch between enabling and disabling tests?
03:45:00 <merijn> dminuoso: It's because it affects the build plan
03:45:26 <merijn> dminuoso: tests might require different build plans for the main library and having them automatically rebuild and switch plans each time is...suboptimal
03:45:46 <merijn> Because then your code recompiles every time you switch between tests or not
03:45:49 * hackage wai-extra 3.1.0 - Provides some basic WAI handlers and middleware.  https://hackage.haskell.org/package/wai-extra-3.1.0 (MichaelSnoyman)
03:46:02 <dminuoso> merijn: And that is bad why?
03:46:09 <merijn> dminuoso: Just enable tests in cabal.project(.local) so they're always in the build plan
03:46:16 <dminuoso> Mm
03:46:28 <merijn> dminuoso: Because if you alternate running tests and executables you don't want your library to recompile each switch?
03:46:49 <merijn> But not recompiling isn't safe if the build plan changes
03:47:05 <merijn> So just enable tests so the build plan always accommodates them, problem solved
03:49:12 <tomsmeding> cheater: I _think_ that because vty will indirectly use the terminfo library, which I _think_ is not present on windows, it will not work out of the box
03:49:17 <tomsmeding> but I haven't tested it either :)
03:49:32 <cheater> OK
03:49:35 <dminuoso> Fair enough. So --enable-tests essentially mixes in the build-depends from the test-suite, causing a new build plan to be generated that includes the (transitive) version bounds of the test-suite?
03:49:45 <dminuoso> And --disable-tests turns that off again?
03:50:21 <tomsmeding> cheater: I have written a library on somewhat the same level of abstraction as vty at some point, that does work on windows (https://git.tomsmeding.com/terminal-io-hs/tree/); however, it's not on hackage, and has been used for exactly one university project at some point :p
03:50:36 <tomsmeding> so I don't necessarily recommend using it, but wanted to post it for completeness regardless
03:51:07 <cheater> tomsmeding: thanks, that's pretty cool. how does it work on windows?
03:52:27 <merijn> dminuoso: Right
03:52:55 <merijn> dminuoso: And there's no real design (yet?) for how to properly handle switching between executable and test targets
03:53:09 <merijn> dminuoso: (recompiling each time is obviously not ideal)
03:53:11 <dminuoso> merijn: But wouldnt `cabal v2-test` have to enable-tests at the very least?
03:53:22 <merijn> Yes, no, maybe?
03:53:59 <merijn> dminuoso: If you have a coherent design for how all the bits should work I'm sure it'll be welcome ;) And probably there's at least 1 or 2 issues discussing it on github :p
03:54:28 <dminuoso> Im quite confident that this is very non-trivial.
03:54:38 <dminuoso> Build systems always are.
03:54:38 <merijn> :)
03:55:14 <dminuoso> Hooray, I just managed to completely screw up dist-newstyle/ to the point of having to delete it.
03:55:16 <boxscape> Is there a way to access functions in ghci that aren't exported?
03:55:43 <cheater> using :m
03:55:48 <boxscape> oh
03:55:49 <boxscape> thankss
03:55:53 <cheater> yw
03:56:58 <boxscape> hmm though actually that seems to have the same behavior as importing it
03:57:33 <cheater> you can use :m +Foo or something i think
03:57:49 <cheater> not sure
03:58:29 <boxscape> I can use that, but it doesn't seem to bring into scope identifiers in Foo that aren't exported by Foo, unfortunately
04:00:01 <solonarv> :m + *Foo works
04:00:15 <solonarv> has to be an interpreted module
04:00:48 <boxscape> oh, interesting, thanks
04:07:47 <dminuoso> I recall there was a super dirty and unsafe package that let gain access to non-exported identifiers from other package..
04:08:41 <merijn> @hackage true-name -- this one? :p
04:08:41 <lambdabot> https://hackage.haskell.org/package/true-name -- this one? :p
04:09:21 <boxscape> hm, neat
04:09:27 <dminuoso> Yes, thats it :)
04:09:57 <merijn> hmm, I forget how to specify ghc-options for only local packages in cabal.project (i.e. as opposed to for all transitive dependencies)
04:10:08 <merijn> anyone know?
04:11:30 <hekkaidekapus> merijn: package foo
04:11:57 <hekkaidekapus> And `ghc-options:` under that stanza.
04:12:06 <tomjaguarpaw> package opaleye ghc-options: -iDoc/Tutorial -iTest -fprint-potential-instances
04:12:16 <tomjaguarpaw> Hmm, bad formatting
04:12:18 <tomjaguarpaw> package opaleye
04:12:21 <tomjaguarpaw>  ghc-options: -iDoc/Tutorial -iTest -fprint-potential-instances
04:14:36 <tomsmeding> cheater: it assumes you have a sort-of xterm-compliant terminal, which windows has nowadays
04:14:49 <int-e> merijn: is it too much to hope that  cabal v2-configure --ghc-options  would drop the flags into cabal.project.local where it will be picked up by other cabal invocations?
04:15:07 <int-e> merijn: Oh.
04:15:14 <tomsmeding> vty does the full thing by actually consulting the terminfo database to find out what escape sequences are appropriate for your terminal; that works great on linux but fails on windows (at least, that's my hypothesis)
04:15:20 <int-e> merijn: never mind, I missed the "only local" part
04:15:21 <cheater> tomsmeding: does it work in ps, or in cmd only?
04:15:27 <tomsmeding> my library doesn't bother, which makes it work :p
04:15:37 <tomsmeding> my windows-using friend used it in cmd at the time
04:15:47 <tomsmeding> does PS support ansi escape sequences?
04:15:52 <cheater> i don't know
04:15:56 <cheater> at some point it didn't
04:16:01 <cheater> not sure what it's like now
04:16:05 <tomsmeding> printf "\x1B[1mbold text!\x1B[0m"
04:16:55 <tomsmeding> where \x1B is byte 27; manage to print that to PS (possibly using putStrLn ;) ), if that shows bold text, then yes, else no
04:19:12 <int-e> merijn: https://github.com/haskell/cabal/issues/3883 suggests you can't :-/
04:21:41 <int-e> merijn: (The suggested workaround is to specify ghc-options for each package of interest in one of the cabal.project files... manually?)
04:21:59 <merijn> hekkaidekapus: But then I need to explicitly do that for each of the local package :\
04:22:26 <hekkaidekapus> Yeah, int-e has been expanding on that.
04:22:28 <int-e> So... yeah what hekkaidekapus suggested.
04:23:43 <tomjaguarpaw> If only a cabal file was a datastructure in some programming language. Then you could just write code to do it.
04:24:25 <Putonlalla> What is Nix?
04:25:26 <Cheery> it's a package manager where the specialty is referential transparency extended to package-level.
04:26:39 <merijn> Putonlalla: Oh, oh, is the answer "a terribly ill-specified programming language that's hard to use unless you have a fulltime expert to tell you how to fix things so they work"? :)
04:26:48 <Putonlalla> I was just trying to play Jeopardy with tomjaguarpaw.
04:27:28 <tomjaguarpaw> Ah nice
04:28:00 <tomjaguarpaw> But also just having this property for our language-specific build system would be nice (some would say essential)
04:29:17 <merijn> tomjaguarpaw: Well, it is one, but the API is rather unstable :p
04:30:02 <tomjaguarpaw> Yeah I've been considering extracting a stable subset, but I incrementally learn the internals of cabal slowly :)
04:30:18 <tomjaguarpaw> hekkaidekapus: Does your name mean 16-legged?
04:31:07 <hekkaidekapus> tomjaguarpaw: hehehehe‚Ä¶ Yeah, it‚Äôs about arithmetic branched off octopuses‚Ä¶
04:31:27 <merijn> tomjaguarpaw: Godspeed
04:31:48 <merijn> tomjaguarpaw: Cabal's internals are...hairy :p
04:32:15 <tomjaguarpaw> I've also been wondering whether it's possible to reduce Cabal's line count by 80%
04:32:28 <tomjaguarpaw> I suspect it would be, at the expense of not supporting Hugs and other little-used things
04:35:29 <merijn> tomjaguarpaw: Well, not so much about not supporting Hugs as "dropping the established API/design that accommodates any compiler"
04:35:55 <merijn> Sure, if we just threw our hands in the air and said "fuck it, cabal only supports GHC" a significant portion of the code could be eliminated
04:36:13 <merijn> But I don't like the idea of tying crucial tooling *that* tightly to GHC
04:38:58 <hekkaidekapus> tomjaguarpaw: The full quote: ‚ÄúOctopus‚Ä¶ Enapus‚Ä¶ pentekaidekapus hekkaidekapus heptakaidekapus OKTOKAIDEKAPUS enneakaidekapus eikosapus‚Äù courtesy of Helen Dewitt <http://helendewitt.com/>
04:39:17 <tomjaguarpaw> merijn: Agreed, but it would be an interesting experiment to see just how small and simple one could get.
04:39:54 <tomjaguarpaw> hekkaidekapus: What's the connection to arithmetic?
04:41:20 <hekkaidekapus> Learning new languages, for instance starting by counting in Greek, all of that to sustain some learning philosophy due to John S. Mill.
04:42:55 <hekkaidekapus> H. Dewitt claims many teaching systems are broken and she goes on to teach Japanese, Greek, poker, bridge, maths‚Ä¶ to an imaginary kid in her novel.
04:45:35 <tomjaguarpaw> Oh, The Last Samurai?
04:45:42 <hekkaidekapus> Yep!
04:45:43 <tomjaguarpaw> Interesting
04:47:01 <hekkaidekapus> It‚Äôs a masterpiece, but let‚Äôs not go too far in the off-topic.
04:47:57 <hekkaidekapus> (Though I should add: wathc the movie ‚Äî7 Samurai‚Äî before reading the novel)
04:48:34 <tomjaguarpaw> Yes, I'm a big fan of Kurosawa, which is why I found the synopsis of this book interesting. I will keep it in mind, thanks!
04:48:47 <hekkaidekapus> yw
04:49:36 <tomjaguarpaw> It's strange.  When I first saw "hekkaidekapus" I assumed it was Japanese.  When I looked more closely I saw it was Greek.  Now we're back to Japanese again!
04:49:49 <hekkaidekapus> lol
04:50:24 <Putonlalla> We do have #haskell-offtopic, where you can just derail and go.
04:50:41 * hekkaidekapus is already faded.
04:51:23 <tomjaguarpaw> A brief flash of communication which may change a life ... or may not.  And now back to your regularly scheduled Haskell programming.
04:51:53 <nitrix> edwardk, How much have you explored ray marching signed-distance functions and do you remember much from it? I'm exploring the field and ran into a couple answers online by you and would have questions of my own.
04:53:53 <Cale> nitrix: From what I recall, Ed has made some really cool demos involving them.
04:56:58 <nitrix> Like many others, I've successfully rendered a cute little scene. I now want to make an editor to build 3d models using these SDFs primitives... the problem is that suddenly makes the scene dynamic.
04:58:45 <nitrix> I sort of have an interpreter in the shader now, reading "instructions" to draw various primitives from a UBO (uniform buffer). The performance is pretty bad beyond a handful of SDFs.
04:59:40 <nitrix> So that's one question for edward, then second one would be if I should drop the full-screen quad approach and invest time into compute shaders.
05:00:12 <nitrix> Not very Haskell-related but pretty math-y :D
05:09:31 <tomjaguarpaw> nitrix: What's the best introduction to SDFs for that kind of thing?
05:11:46 <nitrix> tomjaguarpaw, Probably this video/channel "The Art of Code": https://www.youtube.com/watch?v=PGtv-dBi2wE
05:12:34 <nitrix> tomjaguarpaw, Otherwise, this guy Inigo Quilez (aka IQ) is one of the leading pioneer: https://iquilezles.org/www/articles/distfunctions/distfunctions.htm
05:12:48 <davve> ah nitrix beat me to linking inigos
05:13:00 <davve> love those geometry functions
05:13:01 <nitrix> tomjaguarpaw, He's the creator of ShaderToy (https://www.shadertoy.com/) which is junk full of that technique.
05:16:49 <nitrix> tomjaguarpaw, Oh, and here's a video that can sell you on the technique for doing constructive solid geometry: https://www.youtube.com/watch?v=Cp5WWtMoeKg
05:27:04 <davve> nitrix: shaders are a nice way of using them
05:27:16 <davve> and with glsl you get all the math functions you might need
05:27:39 <davve> only they can be difficult to debug
05:27:49 <davve> painful but fun
05:30:17 <dminuoso> aroundWith :: (ActionWith a -> ActionWith b) -> SpecWith a -> SpecWith b; type ActionWith a = a -> IO (); after action = aroundWith $ \e x -> e x `finally` action x
05:30:23 <dminuoso> My head is spinning. How is this even type checking?
05:31:00 <dminuoso> How can aroundWith take a 2-argument function with that type signature?
05:31:26 <{abby}> ((a- > IO ()) -> b -> IO ()) -> SpecWith a -> SpecWith b
05:31:34 <{abby}> modulo paren errors, if any
05:31:36 <Cale> e :: ActionWith a, x :: a
05:32:07 <dminuoso> Oh.
05:32:31 <dminuoso> My head kept thinking of this type alias as a newtype for so long, after 15 minutes in disbelief it didn't click.
05:32:33 <dminuoso> Thanks.
05:32:35 <ski> what's `SpecWith' ?
05:32:50 <dminuoso> type SpecWith a = SpecM a ()
05:33:09 <Cale> (It doesn't matter for this question, it turns out)
05:33:26 <ski> (yea, i know. just wondering)
05:33:49 <dminuoso> This I think is a good example of why type aliases can be annoying.
05:34:02 <Cale> Yeah, pretty much
05:34:17 <Cale> It would be clearer without the synonym
05:35:16 <ski>   aroundWith . flip . (runContT .) :: (b -> ContT () IO a) -> (SpecWith a -> SpecWith b)  -- then
05:40:49 * hackage signable-haskell-protoc 0.1 - Signable instances protoc compiler plugin.  https://hackage.haskell.org/package/signable-haskell-protoc-0.1 (coingaming)
05:52:40 <siraben> What should I do when stack fails to find a version of GHC that works?
05:52:51 <siraben> Why wouldn't it have found a version that worked in the past?
05:56:49 <merijn> siraben: It doesn't look for a GHC version, the snapshot specifies the GHC version
05:57:30 <merijn> So if you stack setup uses lts 11.8 (or whatever, I don't use stack) that defines which GHC you get and if that one doesn't work, well, fix your project >.>
05:57:34 <siraben> Running stack init in a repository like https://github.com/jozefg/pcf/ seems to fail
05:58:02 <siraben> log: http://ix.io/2yhR
05:58:34 <merijn> I'm assuming "stack init" just picks the latest LTS snapshot or something
05:59:02 <merijn> I doubt it does anything smart
05:59:35 <siraben> Is that log not showing it going through older LTS snapshots to find one that has all the deps?
05:59:45 <merijn> ok, something smarter than I expected, but still doomed to fail
05:59:55 <siraben> How should I fix it?
05:59:59 <merijn> siraben: Eh, why would you assume a snapshot that has all the dependencies exists?
06:00:23 <siraben> merijn:  presumably this project built at some moment in time
06:00:28 <merijn> That seems...naively optimistic, especially given the lat change to that package predates the existence of stack
06:00:53 <siraben> Ok, I see why, because it predates stack.
06:00:58 <merijn> oh, wait, no, there's more recent changes
06:01:08 <merijn> Still, I'd assume the author uses cabal-install
06:01:30 <siraben> Well, cabal build doesn't work either.
06:01:40 <siraben> After searching the rest of the dependency tree exhaustively, these were the goals I've had most trouble fulfilling: base, language-c, c-dsl, pcf
06:01:50 <merijn> What's the rest of the error, though?
06:02:09 <siraben> http://ix.io/2yhU
06:02:30 <merijn> Right
06:02:37 <siraben> stack wasn't around in 2015?
06:03:07 <siraben> Ok, so building projects older than stack seems to be slightly more involved.
06:03:09 <merijn> siraben: That error is pointing out that it (transitively) depends on language-c==0.4.*
06:03:24 <merijn> siraben: Which requires (conflict: language-c
06:03:25 <merijn> +/-separatesyb +/-splitbase => base<4.11)
06:03:38 <merijn> So your GHC is to new
06:03:59 <merijn> You could (optimistically) try "cabal build --allow-newer" which may work
06:04:03 <siraben> Ok, so should I use a nix-shell with an older version of GHC then?
06:04:58 <merijn> siraben: base 4.11 is GHC 8.4 it seems: https://wiki.haskell.org/Base_package
06:07:47 <siraben> merijn: Running cabal build --allow-newer now
06:08:26 <cheater> what's a word for an exercise that's very repetitive, and you learn by doing a lot of it? like when you have a full page of stuff like 1x5 = __, 7x4 = __, and so on
06:09:02 <siraben> cheater:  rote
06:09:10 <siraben> rote learning, that is
06:10:34 <cheater> someone else suggested that too. rote learning is the method with which you learn from this. but what about the problem itself that's on the problem sheet?
06:11:51 <int-e> boring, trite, routine
06:12:53 <int-e> (and wrong channel)
06:15:58 <siraben> merijn: with allow-never it seems to get all the dependencies, however how it's complaining about Pcf.hs which is the source file
06:16:04 <siraben> newer*
06:16:31 <siraben> http://ix.io/2yhY
06:16:57 <siraben> Could I use nix to go back to GHC 8.4 with the packages there?
06:17:07 <merijn> Probably a change in the dependencies or something
06:19:19 <siraben> Hm, what's the easiest way to get it to build then?
06:19:25 <siraben> These are not libraries I'm very familiar with.
06:19:45 <Cheery> A question.. Lets say you had de-bruijn syntax, eg. ŒªŒª1, how would you represent let-expressions?
06:19:58 <Cheery> and letrec syntax?
06:20:23 <Cheery> let x = ... in, if we dropped the variable here, how would you adjust the syntax? How about the case expression?
06:21:57 <ggole> Indices require rewriting of the scope of a binding when you remove that binding
06:22:33 <ggole> Wait, did you mean removing the name and using an index?
06:23:17 <merijn> siraben: The package is lacking proper bounds, so the answer is "you manually have to patch the package description to have the correct bounds"
06:23:28 <Cheery> yup. I mean, if it had a textual representation where you use de-bruijn indices, how would you form let-expressions?
06:23:29 <edwardk> nitrix: i did. though i admit my brain is currently a bit of goo on the floor from my current project
06:23:36 <merijn> siraben: "What are the correct bounds?" 'you have to figure that out the hard way'
06:23:50 <siraben> Ugh, if only there was an automated tool to do that!
06:24:04 <Cheery> You could use (Œªx) y to represent let = y in x
06:24:15 <merijn> There can't be, because "it compiles" isn't sufficient to identify "correct" bounds
06:24:23 <edwardk> Cale: if you thought `constraints` was fun. wait until you meet it's polykinded cousin https://github.com/ekmett/haskell/blob/master/types/src/Data/Type/Constraint.hs
06:24:27 <ggole> Just let term in body seems ok
06:25:29 <cheater> tomsmeding: so i was wondering, does cmd.exe accept the EXACT same terminal escape codes as VT100 (just possibly less of them)? what if for windows, I told Vty to not query terminfo, but instead give it a specific finite amount of supported escape codes instead?
06:25:47 <cheater> tomsmeding: basically making it not use terminfo, but instead hard coded stuff
06:27:25 <edwardk> Cheery: i tend to bolt lets in as an extra form in most of my type checkers. why? mainly because inference can be a bit better and you can make an ever so slightly faster evaluator that just recurses in with the arg in hand in debruijn terms you just wind up with let expression body where the body is counted as having one more expression bound in it, 'let expression' counts like a lambda in terms of var count.
06:29:11 <edwardk> this whole 'plumbing around every part of every expression' feels very grothendieck construction-like to me.
06:29:34 <edwardk> it is weird treating "Left" as a functor. and '(:) as a bifunctor
06:31:17 <siraben> edwardk: error raised at compile time by the bound library; Exception when trying to run compile-time code: This is bad: AppT (ConT Language.Pcf.Clos) (VarT a_6989586621679111736) False, what could be causing it?
06:32:05 <edwardk> wat?
06:32:41 <siraben> edwardk: why doesn't this work? http://ix.io/2yi5
06:32:49 <siraben> you're the author of bound right?
06:33:15 <siraben> makeBound ''ExpC seems to be the culprit
06:33:19 * hackage signable 0.1 - Deterministic serialisation and signatures with proto-lens support  https://hackage.haskell.org/package/signable-0.1 (coingaming)
06:33:37 <merijn> siraben: The problem is that --allow-newer probably picks bound 2.x
06:33:59 <merijn> siraben: And pcf uses bound 1.x
06:34:02 <siraben> merijn:  I've decided to remove the bounds completely and update the project to the newest libraries
06:34:16 <siraben> So I've commented everything out and starting from top dow
06:34:17 <siraben> down
06:34:20 <edwardk> can you try expanding the type synonym for Clos in it?
06:34:23 <merijn> siraben: Then I'd recommend consulting the changelog of dependencies and read what changed? :)
06:34:31 <edwardk> it probably isn't seeing through that
06:34:36 <siraben> merijn:  Ok
06:34:51 <siraben> edwardk:  Ah, now it works
06:34:59 <siraben> Interesting, didn't know type synonym expansion matters
06:35:11 <edwardk> well, we have to walk through that syntax tree manually in TH
06:35:24 <edwardk> and i guess we never had anybody try to hide expressions from us behind type synonyms before
06:35:43 <edwardk> otherwise we have to figure out how to look them up instantiate them and keep walking somehow
06:35:51 <edwardk> sounds like lots fo templatehaskell
06:36:34 <siraben> edwardk:  is there a problem with mutually recursive data?
06:36:51 <siraben> I have, data A = .<B>., data B = ...<A> ... and makebound ''A; makeBound ''B
06:36:54 <siraben> Seems to fail as well
06:37:11 <edwardk> there is a 'trick' to working with bound
06:37:27 <edwardk> you make one monad, and a bunch of left-modules over monads that carefully don't mention it
06:37:30 <edwardk> then get parameterized on it
06:38:02 <siraben> Left module over a monad is left distributivity over bind, right?
06:38:05 <edwardk> https://github.com/ekmett/bound/blob/master/examples/Deriving.hs
06:38:42 <edwardk> shows an example with patterns
06:38:47 <edwardk> the patterns are in a separate data type
06:38:57 <siraben> Ah, I'll take a look, thanks.
06:38:59 <edwardk> that data type has an instance of the Bound class
06:39:15 <edwardk> but note Pat carries the 'f' as a parameter and later we just instantiate that to Exp
06:39:15 <hekkaidekapus> siraben: (In the shell) `printf '%s\n%s' 'packages: .' 'allow-newer: *:all' > cabal.project` in the pcf directory. Then build. You will have to make local patches to fix <https://paste.tomsmeding.com/84uGbbWh>.
06:39:20 <edwardk> Pat isn't itself a monad
06:39:25 <edwardk> it is just an instance of Bound
06:40:04 <edwardk> Some times you dont' want to do this, so i then recommend writing the instances by hand, and making your own class for the (>>>=) equivalent operation, which is that left-module thing
06:41:51 <edwardk> siraben: https://github.com/ekmett/bound/tree/master/examples has a few examples, the overkill one shows what happens if you go all the way down the manual rabbit hole
06:41:55 <siraben> I see
06:42:01 <edwardk> deriving is closer to where you are now
06:43:10 <IT92> Hi guys! I'm qurious how do I declare binary dependencies for my haskell package? Here is example, my library needs secp256k1 library, but Hackage CI machine obviously don't have it https://hackage.haskell.org/package/signable-0.1/reports/1
06:43:18 <siraben> At least writing that somewhat boilerplatey monad instance is better than having to deal with manual substitution, heh.
06:43:49 <merijn> IT92: Short answer: You don't
06:44:03 <merijn> IT92: Are you using cabal-install?
06:44:17 <IT92> merijn I'm using stack and nix
06:44:51 <merijn> You can build/upload docs locally to get working docs in the absence of succesful hackage build, but not sure how to do that with stack
06:45:17 <merijn> "cabal haddock --haddock-for-hackage" works, I assume stack has something similar
06:45:30 <IT92> merijn thanks!
06:47:01 <hekkaidekapus> siraben: hmm‚Ä¶ Scrolling down, I see you already got the errors in <http://ix.io/2yhY>. Cheers.
06:47:50 <siraben> Alright, so the only part that seems to have problems is the one that uses the c-dsl package, hm.
06:48:15 <siraben> c-dsl has dependenices base (==4.), language-c (==0.4.)
06:56:49 <siraben> Heh, relaxing that restriction on base seems to do the job.
06:59:03 <siraben> merijn:  is there a way to put --allow-newer in the cabal file?
07:04:01 <siraben> cabal is complaining about multiple main libraries http://ix.io/2yil
07:04:34 <siraben> Oh if I write library c-dsl instead of library, it works.
07:06:11 <siraben> I wonder if I could do a dependency override in cabal like in nix
07:13:52 <edwardk> siraben: that is what cabal.project files are for
07:14:17 <edwardk> siraben: https://github.com/ekmett/codex/blob/master/cabal.project#L57
07:14:20 <edwardk> is an example
07:15:23 <siraben> edwardk: Oh, do I have to use another tool or does it work with cabal?
07:15:35 <edwardk> cabal.project is part of cabak
07:15:37 <edwardk> er cabal
07:15:48 <siraben> Ok, I'll try that
07:16:24 <edwardk> you put one at the top of your project dir, it can tell cabal where to go find libraries when they are branches in git repos, tell it to override version bounds in various ways, specify flags, etc.
07:17:00 <edwardk> you can share one across multiple libraries when working on a multi-library project, etc.
07:17:49 <siraben> edwardk: I already have pcf.cabal, so I add cabal.project as well?
07:17:55 <edwardk> yes
07:18:10 <edwardk> cabal.project is used to locate cabal files and specify things like overrides
07:19:16 <edwardk> that is the only actual required line
07:19:51 <edwardk> after that you can skim through that file i linked, and at the bottom there are some examples of specifying local project bounds on things, or allowing newer versions of different libraries for either specific targets or all
07:20:04 <edwardk> the cabal docs have a bunch to say on cabal.project files
07:20:53 <siraben> Ah, I see
07:21:25 <merijn> .cabal files specify packages, cabal.project files specify "build setups"
07:21:50 <merijn> One is for distributing packages, the other helps specify setups when developing packages
07:22:44 <IT78> Hi guys! Can cabal package use dependencies from github like stack do? I just need a bit different version of package, but don't want to push changes and propose pull request to contributor of the package
07:23:32 <siraben> edwardk: great, it works, thanks!
07:23:59 <merijn> IT78: Depending on circumstances "not really" or "sorta"
07:24:37 <merijn> IT78: You can use cabal.project files to point to a git repo to fetch a dependency from, which is useful for "in-flight" patches/changes
07:24:52 <merijn> But it's probably a bad idea for long-term
07:25:04 <IT78> merijn why?
07:25:14 <tomsmeding> cheater: I believe that cmd.exe attempts to act like an xterm, which is kind of the modern (but ugly, according to some?) de-facto derivative/extension of vt100
07:25:22 <merijn> Well, for one, such a package can't be (usefully) distributed via Hackage
07:25:34 <cheater> tomsmeding: i thought it was trying to act like vt100
07:25:37 <tomsmeding> so yes, if you manage to make vty not query terminfo and just blindly assume it runs in an xterm, then yes
07:25:38 <merijn> Also, git repos tend to be more volatile in terms of lifecycle
07:25:42 <cheater> tomsmeding: what do you think of my plan?
07:25:42 <cheater> ok
07:26:02 <cheater> have you ever looked inside vty? to see if/how it figures out what escape sequences to use when?
07:26:06 <tomsmeding> cheater: https://github.com/microsoft/terminal/issues/6045#issuecomment-631743728
07:26:48 <IT78> merijn so how usually such issues are solved with cabal? Just create new hackage repo with new code which you can change?
07:27:03 <merijn> IT78: Depends what you're working on
07:27:18 <merijn> IT78: Like, if you don't ever plan to put it on hackage then the problem is moot
07:27:26 <mastarija> Is it possible to read from Control.Concurrent.Chan without blocking. Or rather, is it possible to return Nothing in case there is no value in the Chan at the moment?
07:27:53 <tomsmeding> cheater: as for looking inside vty, well, I just did earlier today in response to your question, and found https://hackage.haskell.org/package/vty-5.30/docs/src/Graphics.Vty.Output.html#outputForConfig which, directly or indirectly, calls https://hackage.haskell.org/package/vty-5.30/docs/src/Graphics.Vty.Output.TerminfoBased.html#reserveTerminal
07:28:08 <dminuoso> IT78: You could also run a local package repository (does not have to be hackage). cabal is able to use multiple repositories
07:28:14 <dminuoso> Look at skete
07:28:19 <merijn> mastarija: I was gonna say yes, but apparently not
07:28:25 <mastarija> From what I understand, if I attempt to read from Chan when there's nothing in it, that operation will block until a new value arrives
07:28:51 <merijn> mastarija: However, I've got a package that's basically a more featureful implementation of Chan which does support that ;)
07:28:54 <merijn> mastarija: https://hackage.haskell.org/package/broadcast-chan
07:28:56 <IT78> dminuoso thanks!
07:29:08 <tomsmeding> cheater: Terminfo, there, is System.Console.TermInfo from https://hackage.haskell.org/package/terminfo , which does foreign calls to a C library; I didn't look further, but I assume that's going to fail on windows
07:30:07 <tomsmeding> mastarija: any reason you're not able to use a TChan from Control.Concurrent.STM ? That does support polling
07:30:13 <merijn> Wait, no
07:30:15 <merijn> I lied
07:30:19 <merijn> I should add that!
07:30:24 <tomsmeding> :D
07:30:29 <merijn> The Maybe is for when it's closed >.>
07:30:42 <mastarija> tomsmeding, well, I kind of used Chan and am to lazy to switch now
07:30:52 <mastarija> :D
07:30:53 <tomsmeding> that's a reason :p
07:31:17 <tomsmeding> mastarija: also, I haven't tried it, but perhaps https://hackage.haskell.org/package/base-4.14.0.0/docs/System-Timeout.html#v:timeout works
07:31:41 <mastarija> tomsmeding, that was going to be my next question :D
07:32:39 <tomsmeding> even if it works, it's dangerous, though, because you might get Nothing then even if there is data on the Chan
07:32:52 <mastarija> tomsmeding, although I could use MVar or something like that and a separate thread to push changes form Chan into it
07:33:04 <mastarija> and then read values from that MVar
07:33:04 <tomsmeding> in case the read just takes abnormally long (which I guess can happen) and that happens to be longer than the (short) timeout you specified
07:33:39 <Eduard_Munteanu> mastarija, or TMVar
07:33:49 <mastarija> tomsmeding, do you think my TMVar approach could work?
07:34:07 <mastarija> Eduard_Munteanu, I kind of need speed in this case
07:34:07 <tomsmeding> what even is a TMVar
07:34:13 <Eduard_Munteanu> mastarija, the nice thing about STM primitives is you can do something like select()
07:34:18 <merijn> tomsmeding: STM version of MVar
07:34:31 <tomsmeding> isn't that TVar?
07:34:33 <merijn> mastarija: What's the actual problem, though?
07:34:35 <merijn> tomsmeding: No
07:34:40 <merijn> tomsmeding: TVar can't be empty
07:34:42 <tomsmeding> ah
07:34:46 <mastarija> merijn, game loop for multiplayer game
07:34:55 <mastarija> and I need to receive data form the server
07:35:03 <merijn> mastarija: Eh, more detailed then that :p Why do you need to poll for data?
07:35:04 <mastarija> so I can't have my loop block
07:35:29 <merijn> You can do something super dumb
07:35:44 <merijn> Like, use and MVar and have one thread "read from Chan, write to MVar"
07:35:54 <merijn> and then your main loop can do "tryTakeMVar"
07:35:59 <mastarija> merijn, that's what I suggested earlier
07:36:05 <mastarija> I think I'll go with that :D
07:36:05 <tomsmeding> that could work :p
07:36:17 <tomsmeding> it won't even be that slow perhaps
07:36:17 <merijn> It probably wouldn't even be that inefficient, tbh
07:36:22 <tomsmeding> lol
07:36:39 <merijn> sleeping on Chan/MVar is pretty cheap
07:36:46 <mastarija> Ok, thanks for the brainstorm peeps!
07:36:50 <Eduard_Munteanu> One other reason to refactor is to use a bounded channel instead of Chan to avoid leaks.
07:37:12 <mastarija> Meh, I'll accept spaceleaks for now XD
07:37:13 <John20> Hi all, Does anyone have any examples of LanguageExtensions that have made it into the haskell language 'proper'? 
07:37:38 <mastarija> Eduard_Munteanu, But yes, I will have to fix that eventually
07:37:52 <merijn> John20: PatternGuards extension was added to the report in Haskell2010
07:38:04 <merijn> as was EmptyDataDecls?
07:38:32 <Eduard_Munteanu> John20, https://www.haskell.org/onlinereport/haskell2010/haskellli2.html#x3-5000
07:39:35 <Eduard_Munteanu> I'd count a few more as de facto into the language, such as FlexibleInstances, MPTCs...
07:41:20 <Eduard_Munteanu> It's hard to imagine Haskell without some of those even if not in the report.
07:42:46 <John20> Thanks, that's really useful. I'm writing a blog post about some of the things that are surprising about Haskell for someone coming from a more mainstream language (Java in my case). 
07:44:27 <merijn> John20: The main problem is that "properly specifying" these extensions is tricky and that's what any new Haskell Report would have to do to include them. Which is why the past 2 (3?) attempts to produce a new report have stranded
07:44:49 * hackage flink-statefulfun 0.1.0.0 - Flink stateful functions SDK  https://hackage.haskell.org/package/flink-statefulfun-0.1.0.0 (tdbgamer)
07:44:53 <cpressey> Hi. I have a list of Word8 and I'd like to render it as hexdigit pairs (e.g. "03 a9 1e" etc). I have written a function to do this, but it uses Text.Printf, which produces a String, but the consumer of my function now expects a Data.Text.Text. I could just DT.pack the string, but... any suggestions for something more elegant?
07:44:59 <merijn> Everyone wants to include "the most common/important stuff into the report", but actually specifying them is hard and people give up
07:45:27 <merijn> cpressey: fyi, the Numeric module has functions for doing that too
07:45:37 <John20> Language Extensions certainly fit that bill. to my mind, they feel like an incubator for new language features however, they rarely seem to actually make it into the core language. Does anyone know why that is? Is my understanding roughly correct?
07:45:40 <merijn> And those are less...questionable then printf :p
07:45:53 <merijn> John20: See my above 2 comments ;)
07:46:09 <merijn> > showHex 152 ""
07:46:12 <lambdabot>  "98"
07:46:21 <merijn> > showHex 252 ""
07:46:25 <lambdabot>  "fc"
07:46:28 <John20> thanks merijn. Missed them while typing out my response!
07:47:07 <merijn> cpressey: So I'd probably go with '\n -> DT.pack . showHex n ""' or something
07:47:37 <merijn> cpressey: Alternatively, you can go via text's Builder: https://hackage.haskell.org/package/text-1.2.4.0/docs/Data-Text-Lazy-Builder-Int.html#v:hexadecimal
07:48:10 <merijn> John20: The other factor is that, since GHC is really the only widely used compiler, there's less incentive to go through the hardwork to produce a new report
07:48:27 <merijn> John20: There's like 2.5 actively maintained Haskell2010 compilers
07:48:36 <merijn> And GHC has 99% market share
07:48:58 <merijn> If there was a competitor to GHC there'd be more motivation to produce a new report to standardise the various compilers
07:49:34 <glguy> cheater: what changed on windows recently that makes you ask? I haven't heard any vty/Windows news myself.
07:49:37 <mmaruseacph2> what's the timeframe?
07:49:44 <mmaruseacph2> bad window, sorry
07:49:54 <tdammers> problem with coming up with a competitor is the economics of it
07:50:16 <tdammers> in order to compete, the other compiler would have to be able to do most of what GHC can do, and keep up with GHC, and then deliver some additional benefits
07:50:34 <tdammers> but at this point, with GHC being a thing and open-source, it is cheaper and more efficient for most people to just contribute to GHC instead
07:50:41 <merijn> tomsmeding: I hope csaba's work and massively overambitious plan to separate out the Core backend would allow alternate Haskell implementation that compile to Core and share code gen with GHC
07:50:48 <merijn> eh
07:50:54 <merijn> s/tomsmeding/tdammers
07:50:55 <tdammers> maybe what we need to do is make the GHC proposals procedure more difficult and cumbersome
07:51:16 <tdammers> hmm, that does sound like a good plan
07:51:40 <tdammers> massively ambitious indeed, and also subject to problems with Core itself not being properly version-managed
07:51:42 <dolio> There were multiple compilers for many years without new reports, though.
07:51:46 <cpressey> merijn: Thanks. I think I picked printf over showHex originally to get leading 0's. I guess my deeper question is, is there actually much gain performance-wise in switching from Strings to DT.Texts, if I need to call DT.pack in lots of places? Is it still justifiable to use DT.Text over String in the name of simply "being modern"?
07:51:47 <merijn> tdammers: https://www.patreon.com/posts/introducing-ghc-38173710
07:52:06 <merijn> cpressey: "it depends"
07:52:18 <merijn> cpressey: Like, what are you outputting and when and how much
07:52:31 <cpressey> I guess another way to say it is, do people laugh derisively when they see String in your code these day? :)
07:52:37 <merijn> cpressey: If you're just visualising a few 100 Word8 for users it probably doesn't matter much
07:52:38 <dolio> And the one new report didn't really incorporate much.
07:53:09 <merijn> cpressey: plenty of stuff is still String based, depends what you use it for
07:55:07 <oats> for anyone who knows java/oopystuffs, is an AbstractVisitor just a shittier Traverse?
07:55:13 <cpressey> merijn: Makes sense, thanks. This is definitely not very performance-sensitive, I'm more wondering about norms and "nice" ways to write it. I'll probably just leave it as is.
07:56:03 <merijn> cpressey: You could write a small wrapper that goes straight to Text which can be convenient when you need to combine with lots of other Text
07:58:23 <dolio> oats: I think a visitor is the function you pass to e.g. traverse.
07:59:30 <dolio> `T -> ()` basically.
07:59:43 <oats> right, thanks
07:59:48 <dolio> Or `T -> M ()`, since the former is useless.
08:00:08 <oats> trying to read some java that's making me want to never venture near java ever again
08:00:28 <dolio> There are multiple patterns that could just be functions, I think.
08:09:07 <siraben> Which version of GHC will have -XLinearTypes ?
08:11:24 <phadej> 9.0 will have an experimental support
08:14:19 <siraben> When will that be released? This month?
08:14:45 <phadej> no-one knows
08:14:58 <dolio> When was the last one?
08:15:19 <phadej> I mean, there weren't any updates on its release schedule
08:15:27 <dolio> I guess it's been 6 months.
08:15:37 <phadej> (it was supposed to be released this month, but it doesn't seem likely)
08:16:38 <dolio> I guess with the major stuff, a delay isn't super surprising.
08:16:43 <phadej> https://gitlab.haskell.org/ghc/ghc/-/wikis/status/ghc-9.0.1
08:19:10 <phadej> looks like we should have beta release in three days!
08:19:20 <siraben> so linear types will be good for safe mutable in-place updates? and allow us to make safe API abstractions?
08:20:39 <siraben> Well, the first part is what Wadler claims in his 1990 paper, Linear Types can Change the World!
08:21:02 <phadej> maybe
08:21:35 <phadej> ST s allows to do safe mutable in-place updates too
08:23:05 <phadej> I suggest to think about LinearHaskell as an academic experiment (of they would fit into Haskell).
08:23:17 <phadej> at least for a year or two.
08:23:24 <merijn> Or 5 :p
08:23:27 <merijn> Or forever :p
08:23:47 <merijn> siraben: We can already do safe mutable in-place updates with a pure API
08:23:53 <merijn> siraben: It's called ST :)
08:24:09 <phadej> phadej ST s allows to do safe mutable in-place updates too -- few lines above.
08:24:19 <siraben> merijn:  yes, but without needing to use a monad
08:24:40 <merijn> siraben: Using linear functions is going to be *hella* more invasive on your code then ST will
08:24:58 <merijn> siraben: Like "rewrite/update many dependencies" intensive
08:24:59 <siraben> merijn: Right, because now everything has to preserve the linearity
08:25:06 <phadej> time will show.
08:25:16 <siraben> Perhaps with linear-base it won't be that bad, perhaps?
08:25:17 <merijn> Whereas you can stick ST pretty much anywhere without much effort
08:25:30 <phadej> linear update "eats" the old value.
08:25:39 <phadej> so you will end up writing something like ssa
08:26:01 <siraben> merijn:  why doesn't ST act like the state monad? is there a state monad that is efficient?
08:26:09 <siraben> As in, I want modify, get, put, etc.
08:26:11 <phadej> (static single assignment form)
08:26:12 <dolio> I think a lot of languages experimenting with linearity for mutability stuff found that it wasn't very nice to use at the level of individual values.
08:26:34 <phadej> at which point one might need some kind of syntactic sugar as well
08:26:35 <siraben> Rust uses an affine type system to manage memory, to great effect.
08:26:50 <merijn> siraben: Not sure what you mean?
08:27:01 <phadej> siraben: GHC is very good at compiling state passing code
08:27:16 <siraben> merijn:  ST is a lot like using IORef, right?
08:27:31 <int-e> ST is a lot like IO
08:27:32 <merijn> siraben: Sorta? I guess?
08:27:56 <siraben> phadej:  oh it is?
08:27:58 <merijn> siraben: I mean, you can easily define a version of State that uses ST for the value and has get/put/modify work on that
08:28:03 <siraben> mine to learn core I guess, never dove into it
08:28:05 <merijn> But ST is much more general
08:28:07 <int-e> IIRC the "ST" is for "state thread"... a thread that can have mutable state.
08:28:18 <dolio> And then people were looking into 'linear regions' or something instead of individual linear values.
08:29:09 <int-e> There's really not much of a connection to the state monad, except as an implementation detail.
08:29:18 <merijn> siraben: "StateT (STRef s a) (ST s) b" with "modify :: (a -> a) -> StateT (STRef s a) (ST s) ()" is kinda the interface you're refering too
08:29:24 <phadej> dolio: I understood that Rust does have that. YOu can pass ownership of just a part of array of values (e.g. part to one thread, another part to another thread)
08:29:27 <siraben> https://old.reddit.com/r/haskell/comments/1rcc8t/performance_of_the_st_monad_over_the_state_monad/ ooh
08:29:32 <siraben> merijn:  I see
08:30:01 <phadej> merijn: you'd be fine with just ReaderT, details...
08:30:07 <merijn> siraben: The basic logic of ST is that "single threaded mutable references" are still perfectly deterministic in a purely function language
08:30:14 <siraben> Wadler also mentions that there should be a mechanism for getting a read-only reference to a linear value whose deference can be nonlinear
08:30:27 <merijn> siraben: Because the order of changes and what you change is perfectly deterministic in that setting
08:30:33 <siraben> Right
08:30:50 <merijn> siraben: So ST gives you arbitrary many independent mutable variables, whereas State's interface has just one
08:30:51 <dolio> phadej: Oh, I guess that's one possible meaning of 'region'. It wasn't the one I was thinking of, but maybe it's the right one.
08:31:08 <merijn> siraben: So the State API is just the trivial case of "I have one STRef" :p
08:31:13 <siraben> merijn: right
08:31:19 <siraben> Well, I haven't used STRef yet, might come in useful.
08:31:55 <phadej> yet, Rust is ownership and LinearHaskell are very different things
08:32:09 <merijn> siraben: I'd say that STRef itself has limited usefulness
08:32:13 <phadej> it's tricky to represent ownership with linear types
08:32:16 <siraben> What do people use STRef here for? Translating imperative code?
08:32:20 <merijn> siraben: The most useful ST application imo is Vector
08:32:26 <phadej> you can emulate that, but whether it's convenient: again, time will whow.
08:32:29 <dolio> Yeah, actually, that makes a lot more sense for how it would solve the problem.
08:32:31 <siraben> phadej:  right, the ownership system in its glory is a lot like linear regions
08:32:52 <merijn> siraben: Vector has ST based mutable vectors, which are very useful for obvious reasons of "mutable arrays are useful" ;)
08:33:06 <siraben> Memory management aside, what about linearity as an alternative to Haskell's bracket pattern?
08:33:17 <phadej> siraben: they are complementary
08:33:20 <siraben> Also, making sure files are closed, sesion types etc
08:33:25 <phadej> LinearTypes and exceptions is not solved problem
08:33:32 <siraben> phadej:  Bracket pattern is like RAII in C++ and Rust?
08:33:36 <merijn> siraben: I like the idea of that, but I'm not sure about the reality :p
08:33:40 <phadej> (in fact explicitly unsolved, IIRC)
08:33:50 <merijn> siraben: IndexedMonads might be a better solution for a "better bracket", tbh
08:33:59 <siraben> phadej:  How do they interact? I know that Rust does not have exceptions but I wonder if it's do to the theoretical limitations.
08:34:07 <merijn> But I don't see Haskell en masse adopting indexed monads :p
08:34:08 <siraben> IndexedMonads is a language extension?
08:34:17 <merijn> siraben: that's a missing space ;)
08:34:27 <phadej> I think someone have to do a bit of homework at this point ;)
08:35:19 <phadej> I don't know what mechanism Rust uses to report division by zero errors
08:35:21 <phadej> e.g.
08:35:26 <siraben> Oh, it's like the LockM monad in https://www.cs.tufts.edu/comp/150FP/archive/simon-peyton-jones/typefun.pdf
08:35:27 <siraben> indexed monads, that is
08:35:28 <phadej> so I cannot comment further
08:35:53 <siraben> phadej: it panics
08:35:56 <siraben> so, stack unwind
08:36:00 <merijn> siraben: indexed monads would be "(>>>=) :: IxMonad m => m i j a -> (a -> m j k b) -> m i k b"
08:36:23 <merijn> siraben: And then you can use i/j/k etc. to encode "file descript is open" file descriptor is closed, etc.
08:36:29 <phadej> siraben: can you recover from panics?
08:36:38 <siraben> phadej: no
08:36:42 <siraben> merijn:  right
08:36:51 <siraben> panics are like error in Haskell, I suppose
08:36:57 <phadej> you can catch `error` in Haskell
08:37:17 <phadej> or just let the thread die (but not the whole program)
08:38:16 <phadej> :t error
08:38:18 <lambdabot> [Char] -> a
08:38:19 <siraben> heh, well technically you can catch panics in Rust, but it's definitely not recommended https://doc.rust-lang.org/beta/std/panic/fn.catch_unwind.html
08:38:30 <phadej> :t throwIO . userError
08:38:32 <lambdabot> String -> IO a
08:38:40 <phadej> :t throw . userError
08:38:41 <lambdabot> String -> c
08:38:51 <phadej> error = throw . userError
08:38:58 <phadej> you can try to catch them in IO then
08:39:32 <phadej> which is e.g. useful when you write a web-server framework, so you can log how users' buggy handlers failed
08:39:53 <siraben> https://users.cs.northwestern.edu/~jesse/pubs/substructural-control/CtlURAL.pdf comes up when I search for linear types and exceptions
08:40:01 <siraben> "In short, exceptions and linear types refuse to get along, because linear types make promises that exceptions do not let them keep."
08:40:10 <siraben> But in an affine system apparently this is alright, just drop the variables.
08:40:49 <phadej> yes.
08:41:05 <phadej> this is why I said that LinearHaskell + exceptions is unsolved problem
08:41:46 <phadej> one can be optimistic and think "we need an implementation to see how things fit (or not fit) together, so we can develop LinearHaskell further"
08:42:00 <phadej> or you can be pessimistic and just declare upfront "it won't work"
08:42:01 <phadej> :)
08:42:43 <siraben> Hehe
08:42:46 <phadej> IMHO anyone who says *now* that LinearHaskell will solve any problem is just selling you a hype.
08:42:59 <phadej> yeah, it might solve a problem, but give you dozen new ones.
08:43:02 <siraben> Why emphasis on now?
08:43:05 <siraben> Ah, right.
08:43:06 <Taneb> It might solve the problem of "I would like another thing to mess around with"
08:43:32 <siraben> I'm not expecting it to solve problems immediately, but linear types are interesting and I'd like to mess around with them, heh.
08:43:44 <phadej> Taneb: that can be fun :)
08:43:45 <siraben> AffineHaskell, anyone?
08:51:17 <phadej> GHC-9.2 will change the syntax for linear arrows, so at least that should make it clear that LinearHaskell is very experimental feature ;)
08:52:15 <dolio> Presumably the emphasis is due to, right now, no one having any significant experience actually designing things with LinearHaskell, so any claims about what it will solve are just speculation.
08:52:28 <phadej> yes
08:52:56 <phadej> obviously authors claim it will solve all problems ;)
08:53:24 <dolio> Even the authors mostly have toy examples from research papers and blog posts.
08:54:31 <phadej> the implicit claim? is that you examples generalise
08:54:36 <phadej> s/you/toy/
08:54:52 <phadej> but in this case it is not obvious
08:57:17 <qwerty93> I want to write a function `mycatch :: a -> Either String a` which returns its argument if no error was thrown and otherwise the error message. For example, `mycatch ((error "asd")::Int)` should return `Left "asd"`. How can this be done with `unsafePerformIO`?
08:57:49 <dminuoso> qwerty93: That is not possible in standard haskell/
08:57:57 <dminuoso> You have to do this in IO
08:58:08 <edwardk> pretty happy that my bytestring patch is finally going in. i'd practically forgotten about in the last year, other than using it in some cabal.project.local's
08:58:21 <dminuoso> % :t Control.Exception.evaluate -- qwerty93 
08:58:21 <yahb> dminuoso: a -> IO a
08:58:38 <dminuoso> Note, you might be tempted to use unsafePerformIO with this, but there's good reasons not to.
08:59:05 <dolio> I think you should eliminate your desire to write such a function. :)
09:00:20 <qwerty93> I have seen the example `catchPure h v = unsafePerformIO $ evaluate v `catch` (pure . h)` but this can only return some sort of default value for a if an error is thrown
09:00:53 <davean> qwerty93: you think thats what it does at least.
09:00:57 <davean> qwerty93: this is a very bad idea.
09:01:12 <edwardk> qwerty93: the problem is it isn't monotone
09:01:40 <davean> And thats why it doesn't do what you think it does.
09:02:44 <edwardk> in haskell pure code you enjoy the benefits of the fact that if you make your inputs more defined all that can happen is that at worst your output becomes more defined. in a world with catchPure that is no longer the case
09:03:00 <edwardk> that is a pretty high price of admission
09:04:44 <qwerty93> I just want to use it for a special debugging mode, the final code would not use it anymore. So, is this not possible at all or just highly advised against?
09:05:49 <davean> qwerty93: It can make your debugging harder for the reason above.
09:06:52 <davean> as for if its possible, that depends on what "it" is, and I don't think you understand what it is and thats the problem.
09:08:02 <qwerty93> davean: you mean it affects the semantics in the sense that is forces evaluation which could cause problems if laziness is expected? the code I'm interested in is not affected by eager evaluation. or is there more?
09:08:23 <davean> qwerty93: Theres more, see edwardk's comment.
09:09:11 <davean> qwerty93: Its value can change based on how you look at it now.
09:09:14 <edwardk> qwerty93: no monotonicity police will be dispatched to your location, just saying the nature of the issue
09:10:02 <davean> qwerty93: If it throws an exception, an exception is throw, how does this new function help you in your mind?
09:11:26 <davean> Tahts the sort of function I use debugging to fix, not the sort of function I use to debug.
09:17:33 <cheater> glguy: cmd.exe supports xterm escape sequences now
10:04:19 * hackage tomland 1.3.1.0 - Bidirectional TOML serialization  https://hackage.haskell.org/package/tomland-1.3.1.0 (vrom911)
10:17:49 * hackage stm-actor 0.1.2.1 - A simplistic actor model based on STM  https://hackage.haskell.org/package/stm-actor-0.1.2.1 (sgschlesinger)
10:53:24 <monochrom> https://jscoq.github.io/node_modules/jscoq/examples/scratchpad.html
10:58:42 <NieDzejkob> is there a better alternative to (const x <$>) <$> xs for replacing all elements of [[a]] by x?
11:01:36 <phadej> :t \xs y -> set (mapped.mapped) y xs
11:01:38 <lambdabot> (Functor f1, Functor f2) => f1 (f2 a) -> b -> f1 (f2 b)
11:01:38 <monochrom> I think prefix notation is better.  fmap (fmap (const x)) xs
11:04:58 <NieDzejkob> I'm just starting to discover lens today, I assume that's where mapped comes from :D
11:05:24 <monochrom> also "set"
11:05:34 <NieDzejkob> if I defined, say, foo a b = ... where bar c = a + c, how can I access bar in ghci?
11:05:51 <monochrom> Cannot.
11:07:05 <NieDzejkob> even if I provide a specific value of a and b? How can I debug these definitions, then?
11:07:25 <dolio> fmap (const x) = (x <$)
11:08:12 <monochrom> If you're OK with outputting debugging messages, look into Debug.Trace
11:08:41 <monochrom> My Debug.Trace tutorial: http://www.cs.utoronto.ca/~trebla/CSCC24-2020-Summer/tracing.html
11:09:54 <Cale> NieDzejkob: You can of course, edit the definition and lift it out of the definition of foo, but you'd need to add a as a parameter then.
11:10:49 <NieDzejkob> that's particularily inconvenient as the definition in question is recursive
11:11:25 <Cale> Of course, addition (and other functions), work the same everywhere, so if you know a and c, you can just add them directly in ghci. (Similarly, you could use the definition of whatever local thing you were looking at to reconstruct what it would be)
11:11:45 <senri> 10
11:11:51 <senri> whoops
11:11:56 <Cale> What's the actual definition you're trying to figure out?
11:14:26 <NieDzejkob> oh hold on, I added some more type annotations and figured out what's going on :D
11:14:40 <NieDzejkob> anyway, this is what the code in question looks like: https://gist.github.com/NieDzejkob/ea6e75ee00951fb8a82e51beafa7d7c4
11:15:27 <NieDzejkob> (I'm investigating bijections f such that g(x) = x + f(x) is also bijective)
11:16:47 <orion> Hi. Are there technical reasons why GHC does not support the Power ISA?
11:16:59 <ski> composition of bijections yields a bijection
11:17:24 <NieDzejkob> not sure how that helps here?
11:17:29 <orion> Sorry, I should probably direct this to #ghc.
11:17:40 <ski> hm, i guess it doesn't. sorry
11:17:43 <geekosaur> orion, generally if ghc doesn't support some arch it's because nobody has time or access to it
11:17:53 <NieDzejkob> ski: I mean, g isn't a composition of bijections
11:18:17 <NieDzejkob> but composition of bijections does indeed yield a bijection
11:18:23 <orion> geekosaur: How many hours of labor do you estimate would be involved in porting GHC to another architecture?
11:19:03 <geekosaur> depends on what tools you can use. it'll be much faster if you can take advantage of the llvm backend instead of going unregisterised, for example
11:21:04 --- mode: ChanServ set +o Sigyn
11:48:39 <hyperisco> since we have  flip :: (a -> b -> c) -> (b -> a -> c)  I think it makes a lot of sense to add  flop :: (b -> a -> c) -> (a -> b -> c)  in case you want to go back
11:49:24 <monochrom> haha
11:49:56 <Rembane> Cunning! 
11:51:03 <monochrom> We also need one for reverse.
11:52:05 <tomjaguarpaw> rovorse
11:53:19 * hackage libjwt-typed 0.2 - A Haskell implementation of JSON Web Token (JWT)  https://hackage.haskell.org/package/libjwt-typed-0.2 (rzeznik)
12:11:30 <koz_> I'm a bit confused how to write an Hspec 'SpecWith a' with 'beforeAll'. Where do I get the value of type 'a' from?
12:12:01 <koz_> I'm only familiar with the 'describe "foo" . it "bars" $ x `shouldBe` y' style of incantation.
12:12:15 <koz_> And the docs aren't very clear about how to use 'before' and 'beforeAll'.
12:21:18 * hackage sequence-formats 1.5.1.2 - A package with basic parsing utilities for several Bioinformatic data formats.  https://hackage.haskell.org/package/sequence-formats-1.5.1.2 (stephan_schiffels)
14:05:49 * hackage ormolu 0.1.3.0 - A formatter for Haskell source code  https://hackage.haskell.org/package/ormolu-0.1.3.0 (mrkkrp)
14:10:08 <Bill--Door> How come the example in Control-Concurrent-STM-TChan doesn't type check? I don't quite understand how TChan works:
14:10:34 <merijn> Which example?
14:11:13 <Bill--Door> From what I've gathered in the docs, I want to use `newBroadcastTChanIO` and duplicate that for reads, but there's no `*IO` variant of `dupTChan`..
14:11:16 <glguy> http://hackage.haskell.org/package/stm-2.5.0.0/docs/Control-Concurrent-STM-TChan.html#v:newBroadcastTChan
14:11:33 <glguy> Use 'atomically' to turn STM into IO
14:11:35 <Bill--Door> Yeah, that one.
14:11:49 <merijn> oh, hah
14:11:52 <glguy> You'll rarely use the IO variants; they exist for some special cases 
14:11:56 <Bill--Door> But then I always get `thread blocked indefinitely in an STM transaction`, tried that too
14:12:00 <merijn> someone fucked up and missed an "atomically" in the example
14:12:11 <merijn> Bill--Door: That means there's someone reading but no one can ever write
14:12:18 <Bill--Door> So, I am doing it right oof
14:12:18 <merijn> (or vice versa)
14:13:00 <Bill--Door> Wait, will the reader not be blocked & wait until the write happens?
14:13:27 <glguy> The example exists as a demonstration of what *not* to do 
14:13:39 <glguy> a little less surprising that they didn't actually try to use it
14:14:01 <merijn> Bill--Door: "thread blocked indefinitely" means "a thread blocked trying to read from a channel, but no thread can ever write to it because there are no other references"
14:14:21 <merijn> i.e., "you wrote deadlocking code, but luckily we detected it"
14:14:36 <Bill--Door> I'm not sure this is dead-locking: pastebin.com/fYq4B8XW
14:15:42 <Bill--Door> Everyone has a neighbour and writes there, reads what they got and so on. Somehow it deadlocks, it should work?
14:17:44 <merijn> Bill--Door: Eh, you never store 'c' and thus can't ever write to it
14:18:01 <glguy> merijn: The c's are stored in chans
14:18:01 <merijn> oh wait, the net does
14:18:04 <glguy> which get put into net
14:18:29 <glguy> though I still don't see why broadcast chans are being used at all yet
14:18:53 <glguy> any chance this is related to AoC?
14:19:02 <Bill--Door> I do the `inbound <- atomically $ dupTChan c` and use `inbound` instead, like that example does
14:19:11 <merijn> Where are they read, though?
14:19:13 <glguy> Bill--Door: The example is showing you what not to do
14:19:47 <Bill--Door> But even when I change to using `c` and `newTChanIO` which apparently leads to memory-leaks, it doesn't change
14:19:53 <glguy> if you have one reader and one writer you don't need a broadcast chan
14:20:05 <glguy> I mean:
14:20:14 <Bill--Door> There might be multiple writers but single readers
14:20:16 <glguy> if you have one reader (doesn't matter how many writters)
14:20:24 <glguy> then you don't need a broadcast chan
14:20:41 <merijn> glguy: If you never have 0 readers you don't need a broadcast chan
14:20:47 <merijn> That's the real thing
14:20:59 <glguy> the code never actually forks off all the listeners
14:22:03 <Bill--Door> Oh, so I just use `c` from `newTChanIO`, but it still locks: pastebin.com/T2CBXMaM
14:22:29 <glguy> You'll need to fork a thread per participant
14:23:12 <Bill--Door> Oooh, crap
14:23:28 <Bill--Door> I've been staring at this for way too long... thanks so much!
14:25:16 <glguy> Bill--Door: Is this homework? online challenge problem? something you're just making up?
14:26:25 <Bill--Door> Just making sth. up, why?
14:26:49 <Bill--Door> It does work (not deadlock that is) now, but I have some issues w/ logging.
14:27:09 <glguy> 1) why not? 2) helps to see the actual problem description 3) reminds me of something else
14:27:12 <Bill--Door> I'd like to implement some simulations of multi-party protocols we looked at in uni
14:28:27 <Bill--Door> In such a case my approach with `TChan` isn't completely flawed, or is it?
14:30:59 <Bill--Door> btw. what does this remind you of?
14:31:22 <glguy> Some problems from Advent of Code 2019
14:32:11 <glguy> making bunch of TChans for different threads to communicate like this is fine. If you have only a single reader TQueue is a little more efficient than TChan, but it doesn't really matter for a toy
14:33:11 <Bill--Door> Didn't know about advent of code, looks pretty cool. I used to do some Project Euler, but I don't think I ever used Haskell there
14:33:39 <glguy> aoc is more programming focused than pe
14:35:16 <Bill--Door> Yeah, PE is solely maths. Plus maybe some clever algorithms but still it got too hard at some point, maybe I should go back one day
14:45:58 <glguy> Bill--Door: For example: https://adventofcode.com/2019/day/23
15:10:12 <Bill--Door> That's a cool puzzle, and indeed more CS-y than a lot of PE ones
16:11:43 <remexre> is it possible to depend on pandoc as a library at the moment? I'm getting https://github.com/haskell-infra/hackage-trustees/issues/280, I think, but this is fixed, if I understand the comments
16:23:23 <dolio> The hackage page for text-conversions has bounds on base16-bytestring now, yes.
16:27:21 <yushyin> Good
16:33:15 <remexre> oh wait, I probably need to `cabal update`, I'm guessing
16:33:18 <dolio> You can assist the solver with command line flags in situations like that before it's fixed, too. --constraint='...' or something like that.
16:33:34 <dolio> Yeah, you need to update the cached information.
16:36:04 <remexre> ok looks like that worked (well, got past text-conversions at least; not finished building)
17:41:05 <Axman6> bloody hell, people give GHC crap for its error messages, but Scala's are just amazingly awful. I feel like I need a monitor 6 feet wide to read the,
17:41:07 <Axman6> m*
18:04:57 <pacak> Axman6: somethnig-something C++
18:07:56 <koz_> pacak: Yes, the platinum standard for incomprehensible error drivel.
18:08:22 <pacak> File contents: "#include __FILE\np;", ~20k lines of error messages when compiled with g++.
18:08:36 <pacak> ghc error messages can be cryptic when you don't know what is it trying to tell you.
18:12:21 <Guest3651> Hey all. Just started to learn Haskell a few months ago, and its been great. I have a shallow understanding of monad transformers, and am looking to get a deeper one. What are some good tutorials/articles/books that I can read to learn more about monad transformers? Thanks!
18:13:39 <pacak> Do you understand monads and type classes?
18:13:45 <Guest3651> Yep.
18:14:21 <pacak> I'd try to implement some boring monad transformers then.
18:14:28 <pacak> Like ReaderT
18:14:46 <pacak> :t lift
18:14:48 <lambdabot> (MonadTrans t, Monad m) => m a -> t m a
18:14:55 <pacak> ^ it's all here
18:15:07 <Guest3651> ?
18:15:35 <pacak> There's not much magic in monad transformers. It's just a typeclass with some instances.
18:17:20 <Guest3651> Ok... I'll try implementing ReaderT. Thanks (y) 
18:17:59 <koz_> Also, Guest3651 - read the Typeclassopedia, because I think it has a good entry on monad transformers.
18:18:11 <Guest3651> Okay
18:18:35 <sm[m]> Guest3651: also you might enjoy http://jxv.io/blog/2018-02-28-A-Game-in-Haskell.html which includes a little practical discussion
18:19:51 <Guest3651> I'll take a look at it
18:30:46 <Xnuk> Are there some practical cases using Reader(T) / Writer(T) over State(T)?
18:32:00 <pacak> Reader(T) is better at at showing intent that whatever you are passing is not going to change.
18:32:05 <pacak> Like passing configuration
18:32:44 <Axman6> I don't think I've ever written an app that made use of StateT. ReaderT all the time though
18:33:18 <pacak> % git grep StateT | wc -l
18:33:19 <pacak> 26
18:33:19 <yahb> pacak: ; <interactive>:105:24: error: parse error (possibly incorrect indentation or mismatched brackets)
18:42:26 <Xnuk> Is it quite different between `ReaderT Config IO a` and `Config -> IO a` ?
18:42:34 <Xnuk> I guess yes
18:45:07 <Xnuk> But the restriction unable to edit `Config` makes me feel useless for me
18:45:30 <pacak> There is. In one case you have to pass Config manually all over the place and it can be changed, in case of reader - it gets passed automatically and is immutable.
18:46:23 <pacak> What kind of editing do you have in mind?
18:47:39 <Xnuk> the editing means like `modify :: (s -> s) -> StateT s m ()`
18:49:43 <pacak> Right. What kind of changes?
18:51:07 <Axman6> Xnuk: what config would need changing? config is gatherted at startup. things that change over time are application state
18:52:36 <Axman6> and state is usually a bad thing :) particularly if you are working with a multithreaded app, which is more often then case for me.
18:56:54 <Xnuk> yeah an application config is very static, actually I feel that fits for `Config -> m a` more imo.
18:58:32 <Xnuk> Using `ReaderT` more than `StateT` is suprising for me btw
18:59:45 <Xnuk> for example, can I write parser (ex. JSON parser) with ReaderT?
19:00:41 <Xnuk> I usually write parser/scrapper in haskell
19:05:55 <pacak> You can use ReaderT part to pass some configuration parts to your parser. I was using it to pass a big ass lookup table.
19:35:49 * hackage flink-statefulfun 0.1.0.1 - Flink stateful functions SDK  https://hackage.haskell.org/package/flink-statefulfun-0.1.0.1 (tdbgamer)
21:00:53 <edwardk> i now have managed to figure out how to take the library of singleton types i have, build a category of arrows that take Sing a -> Sing b  , show that is really SingI a => Sing b   and has composition, where the kinds act as a sort of fiber over the terms in the language.     Then I can build a category -># of the fibers, basically indexed by the kinds of the arguments in the polykinded category of functions between singletons (which 
21:00:53 <edwardk> acts like the constraints package on steroids) and get all haskell functions
21:02:00 <edwardk> now I want to clean up the presentation to make it clearer that the latter category of finers where arrows from i -> j are (forall (a::i). (Sing a -> Some (Sing @j))    are themselves describable
21:02:05 <edwardk> er fibers
21:02:46 <edwardk> which then recovers richard's work in the singletons library, but with my own weird spin
21:03:19 * hackage flink-statefulfun 0.2.0.0 - Flink stateful functions SDK  https://hackage.haskell.org/package/flink-statefulfun-0.2.0.0 (tdbgamer)
21:06:13 <edwardk> i guess what i really need is singletons for 'Some f'
21:06:44 <MarcelineVQ> Sounds like you're having fun
21:06:56 <edwardk> generally, yes =)
21:07:30 <edwardk> i have one bottleneck with my current approach
21:08:08 <edwardk> i'd like to take types of kind (i -> j) and treat them at the value level as i do types of kind Type, which is as typereps for Type, here i'd want them to be typereps for types of kind (i -> j)
21:09:05 <edwardk> but my reflection does 'on the nose' translations from types to terms, and that would mean that fromSing :: Sing (Maybe :: Type -> Type) -> Type -> Type
21:09:12 <edwardk> hrmm, maybe that checks out
21:09:47 <edwardk> except now i need to figure out what higher order functions look like
21:11:01 <sepi> https://dpaste.org/AbtT currently trying to move onto the next element if there is no "match", [] is a placeholder, a little stuck, Any tips?
21:12:27 <edwardk> But I need to be able to represent singletons for kind (i -> Type) at the least to make headway on talking about Some f in general, or Some (Sing @k) -- in particular
21:12:53 <edwardk> i have two existing types that look like Some x for different choices of x now. Constraint looks like Some Dict, and Type looks like Some TypeRep
21:14:01 <edwardk> so this does seem to indicate what a singleton looks like here
21:14:15 <edwardk> Sing (a :: Type) ~ TypeRep (a :: Type)
21:14:28 <edwardk> Sing (a :: Constraint) ~ Dict (a :: Constraint)
21:15:54 <edwardk> but i want to be able to talk about Sing (Eq :: Type -> Constraint) or Sing (Maybe :: Type -> Type)
21:19:10 <MarcelineVQ> Any particular goal with being able to have constraints there?
21:19:15 * Axman6 stocks up on non-perishable food and supplies in case edwardk unlocks something truly disasterous for the planet
21:19:25 <edwardk> ok, so the problem with the type rep story is i can compare TypeRep (a :: Type -> Type) for equality with another TypeRep (a :: Type -> Type) -- but i can't do that with the Type -> Type encoding
21:19:28 <edwardk> yes!
21:19:35 <edwardk> this makes Sing become Dict
21:19:45 <Axman6> see, he's a madman
21:19:55 <edwardk> just like TypeRep for Type makes Sing become TypeRep
21:20:16 <edwardk> and making Nat ~ Natural lets me not have to change types between types/terms and can make round tripping through singletons O(1) not O(n)
21:20:27 <edwardk> each one of these extends the space of operations i can do in constant time
21:20:42 <edwardk> but since constraints are thin, they go into Sing
21:20:46 <edwardk> so does p :- q
21:20:49 <edwardk> that has a singleton type
21:21:15 <edwardk> so the arrows between singletons _also_ has a singleton type, because you can view them as SingI p :- SingI q
21:21:34 <edwardk> so any function that acts on some singleton to build another passes the test
21:21:54 <edwardk> so we get one category that generalizes Constraint, but which can also be used to tear apart terms 
21:22:03 <edwardk> and then i can look at all the fibers over it at kind Type, and we recover Hask
21:22:34 <edwardk> and the way that => works, because we can view the left hand side of => and just Sing.. using the same vocabulary we do
21:22:47 <edwardk> which motivates core treating constraints as thin, but still using them like types
21:22:59 <edwardk> its just missing a layer of singleton type conversions to keep it sound
21:23:59 <edwardk> but i can only get away with my sort of 'homoiconic' Sing representation that has no overhead so long as all my types hold on the nose
21:24:17 <edwardk> it works great right up til this need to lower terms of kind (i -> j)
21:24:42 <edwardk> but I could get away there with a Demoted typeclass
21:24:47 <edwardk> er
21:24:49 <edwardk> type family
21:24:55 <edwardk> just like is used in singletons
21:25:05 <edwardk> but then it'll infect everything else i write
21:25:55 <MarcelineVQ> What does thin used here mean? without inhabitants?
21:25:55 <edwardk> basically type inference for the whole types lib goes to hell
21:26:08 <edwardk> a thin category is one where between any two objects there is at most one arrow
21:26:23 <edwardk> the category of constraints is thin (ignoring ImplicitParam fuckery)
21:26:32 <edwardk> any partial order is thin viewed as -> = (<=)
21:27:24 <edwardk> here i'm building functions that take singletons to singletons. all it can do is sort of case on the input singleton of which there is only one, and produce a result, also in a singleton of which there is only one
21:27:56 <edwardk> so such functions are just a recipe of oh, uncons this part and plumb the head here and tail there, and here is the result
21:28:07 <edwardk> these are done for individual singletons
21:28:47 <edwardk> and in Meta I can work with singletons that are types, natural numbers, arbitrary integers, anything with structural equality so i can promote it once and forall
21:29:09 <edwardk> and i can build a category of such boring (Sing i -> Sing j) functions
21:29:21 <edwardk> and then look at bundles. i and j there can have different kinds
21:29:37 <edwardk> so if we quantify away i universally and j existentially but leave the kinds... we're left with hask
21:30:18 <edwardk> basically its all the functions that look at parts of their inputs (remember it has to work forall (i::a)    and returns some (j::b) now, which is just what a function is
21:30:34 <edwardk> in category theory this notion of sort of exploding your objects is something called the grothendieck construction
21:30:57 <edwardk> well there are many grothendieck constructions, but this is the one that folks talk about when talking about categories
21:31:41 <edwardk> so it was pretty cool to me that i could build this super-laborious category, build functors for it, etc. manipulate the guts of basically anything made out of types, constraints, numbers, inductive data types, etc.
21:31:44 <edwardk> then reassemble the result
21:31:55 <edwardk> and get an Arrow that internally does way more weird stuff than you'd expect
21:32:17 <edwardk> and it has all the power of normal functions (it is ArrowApply, etc)
21:32:35 <edwardk> so i could view this as a sort of 'ultimate form' for something like compiling to categories
21:33:00 <edwardk> if i want said compilation to categories to handle dictionaries, representations of types, etc. correctly
21:35:34 <edwardk> not sure how coherent that is
21:35:38 <edwardk> but that is sort of the thought
21:55:36 <edwardk> anyways MarcelineVQ the other major need for constraints to live in Sing is that i may want to take singleton types over ADTs. i can singleton ~ constraints, but i need to be able to singleton up whatever dictionaries they may package up in their constructors
21:55:45 <edwardk> that covers the existential fragment
21:56:11 <edwardk> and i need to be able to take limits over things to handle the (forall x. whatever x) kinda fragments as well that pop up in ADTs a lot
21:56:23 <edwardk> otherwise my ability to introspect on singletons is quite limited
21:56:48 <edwardk> the goal is to "fully" allow promotion of all haskell data types, not just the convenient ones like in byorgey's paper
21:57:34 <edwardk> er data constructors
21:57:36 <edwardk> not data types
21:57:39 <edwardk> the types promote fine
21:57:43 <edwardk> they just lack most of the stuff in them
22:01:45 <siraben> What do people use here for proving correctness of programs in Haskell? Is liquid haskell still a good choice?
22:01:56 <siraben> Also, introspection testing, and so on.
22:02:07 <edwardk> liquid haskell works well if all your constraints are easy things to feed a sat solver involving numbers
22:02:20 <edwardk> otherwise there are a couple of haskell to coq toolchains and something for isabelle, etc.
22:21:18 <shafox> I use ghcup to install ghc and cabal and use it in my project. However there are other tools that needs to be installed such as ghcid, hoogle, language-server etc which are bound by the ghc version to play well with the project. So I have started to look for a solution which can integrate all the tools that is needed for development env (for now), stumbled across on nix, however I am not sure whether nix can install all the dependency for a particular 
22:21:18 <shafox> ghc and I can use that in the project. Is there any blog posts or gist/github links where a env with developement tools are being used so that I can steal the config ?
22:23:06 <Axman6> I don't know how it works, but at work we have something which will activate an environment, including nix stuff, when you cd into the project directory so everything Just Works
22:23:40 <shafox> Axman6, please share more about it. 
22:24:04 <Axman6> I can't share much, but I'll see if I can find names of things
22:24:25 <shafox> Alright. 
22:25:40 <Axman6> looks like it uses something called direnv
22:27:29 <shafox> Axman6, yes. direnv doesnt actually solve what I have stated. 
22:28:34 <Axman6> well, time for you to go and learn nix
22:28:52 <Axman6> it can solve the problems you have, and there's plenty of examples of people doing it on the net
22:34:30 <shafox> Axman6, Alright. Thank you though. 
22:43:56 <edwardk> MarcelineVQ: another benefit of the encoding using singletons in the types library is that Sing a is a newtype around the constraint, where Dict is a data type
22:44:07 <edwardk> so it should kill a bunch of wrapping overhead
22:44:17 <jdgr> Can we get a Haskell book for children?
22:44:43 <jdgr> One that introduces all the theory in an easy to remember, easy to digest form?
22:48:44 <Axman6> the NICTA/Data61/system-f course teaches 90% of haskell in the first 20 minutes or so, but it's definitely best taken in person (ping dibblego)
22:49:39 <Axman6> the rest is learning how to think in Haskell
22:50:50 <dibblego> LYAH is good for children
22:51:19 * hackage witness 0.5 - values that witness types  https://hackage.haskell.org/package/witness-0.5 (AshleyYakeley)
22:51:58 <olligobber> LYAH is good
22:52:19 * hackage open-witness 0.5 - open witnesses  https://hackage.haskell.org/package/open-witness-0.5 (AshleyYakeley)
22:53:01 <olligobber> hmm, seems since christmas my laptop lost the modular-arithmetic package, now I have to figure out how to install packages again
22:56:28 <olligobber> hmm, `ghc-pkg check' is giving me a lot of warnings...
22:56:55 <olligobber> is that bad?
23:00:48 <dibblego> system-f/fp-course is good for children with in-person guidance
23:01:10 <MarcelineVQ> edwardk: neat stuff, what I could follow (ncatlab just kept linking me to more and more pages), and glad you're so excited :>
23:02:27 <MarcelineVQ> full promotion is definitely neat
23:02:56 <edwardk> right now what i'm trying to do is get the template-haskell magic to be smart enough to properly promote p :- q
23:03:04 <edwardk> i have manually translated Dict
23:03:16 <edwardk> now i have a case where i have (p => Dict q) -- though
23:03:38 <edwardk> i tried flipping newtype p :- q = Sub (p => Dict q) -- to something more like
23:04:06 <edwardk> data p :- q where SubDict :: (p => q) -> p :- q
23:04:08 <edwardk> er
23:04:11 <edwardk> data p :- q where SubDict :: (p => q) => p :- q
23:04:24 <edwardk> but that actually is less easily used than the other
23:04:42 <edwardk> because we often open Sub to bring into scope the obligation we need a p, and then build q
23:04:53 <edwardk> so trying to roundtrip those representations runs into a snag
23:05:01 <edwardk> i have to use an unsafeCoerce trick to go one way
23:05:05 <edwardk> which always makes me nervous
23:05:52 <edwardk> if i can use the latter encoding then i can just reuse the machinery i wrote for fixing Dict
23:06:12 <edwardk> er for handling singletons of Dict
23:07:26 <edwardk> it also gets in the way in subtle ways, like ghc is willing to talk about Dict (p => q) when i have constraint kinds enabled. but despite the fact that Sing @Constraint is basically the same it complains about Sing @Constraint (p => q) -- in particular that q should live in Type, not Constraint
23:07:39 <edwardk> so the hacks we have that make => work in constraints are a bit wobbly around this sort of stuff
23:07:48 <edwardk> not that impredicative types in haskell is terribly well supported
23:08:09 <edwardk> er Dict (p => q) requires impredicative types, not just constraint kinds
23:08:52 <edwardk> i can of course make my own class (p => q) => p |- q; instance (p => q) => p |- q -- but that alias isn't something i can coerce into a function, unlike p => q -- which is internally knowable to be a function
23:09:08 <edwardk> so i can kinda cast it around to Sing p -> Sing q
23:09:33 <edwardk> 'oh the nose' taking advantage of the fact Sing is a newtype unlike Data
23:09:48 <edwardk> er unlike Dict
23:12:32 <MarcelineVQ> why is Dict there impredicative? aren't p and q affixed in  data p :- q ?
23:13:16 <MarcelineVQ> *affixed by
23:17:18 <MarcelineVQ> That is to say I don't see where the extra rank is coming from
