00:18:47 <jackdk> Does anyone here have moderately-complex example of pulling data out of an XML file? I am trying to write a podcast backup tool and am becoming frustrated with the lack of examples beyond "hello-world"-tier. I have no preference re: toolkit. Currently I'm using xml-conduit's cursor interface, and I can select every <item> in the feed, but can't work out how to return content inside <title> and <link> for each as a tuple
00:25:55 <c_wraith> any particular reason to choose xml-conduit?
00:27:18 <jackdk> no
00:29:01 <tomsmeding> ph88: I'm using mustache with pleasure in my pastebin thing, not sure what your requirements are
00:29:48 * hackage tasty-expected-failure 0.12.1 - Mark tasty tests as failure expected  https://hackage.haskell.org/package/tasty-expected-failure-0.12.1 (JoachimBreitner)
00:47:04 <ph88> tomsmeding, mustache seemed complicated when for example you want to loop over a dictionary key and value
00:47:25 <tomsmeding> indeed it doesn't allow you to loop over the keys in a dict
00:48:05 <tomsmeding> though you can loop over a list, and perhaps a dictionary that you loop over really shouldn't be a dictionary? :)
00:48:20 <tomsmeding> though that's making assumptions about your code
00:55:27 <ph88> dunno, in most languages you can iterate over dictionary
01:26:43 <John20> Hi All, I'd like to create a newtype that wraps an existing type and is an instance of all of the classes of the wrapped type except 1 that I will create a new instance for. Is there a nice way of doing this?
01:35:32 <maerwald> John20: https://downloads.haskell.org/~ghc/8.10.2/docs/html/users_guide/glasgow_exts.html?highlight=newtype#extension-GeneralisedNewtypeDeriving
01:36:22 <John20> Thanks maerwald
01:48:27 <dminuoso> Why is GeneralizedNewtypeDeriving cunning?
01:48:37 <dminuoso> Both the documentation as well as the diagnostics use the word "cunning".
01:48:43 <dminuoso> Is that just a cute joke?
01:49:09 <maerwald> sounds much more epic, doesn't it?
02:02:51 <ph88> Could someone help me? my groupBy is not working as i expect and i don't know why https://bpa.st/R73A 
02:03:28 <ph88> things that were supposed to end up in the same group are placed in different groups
02:05:10 <Rembane> ph88: You need to sort the items first. Use sortBy and the same function.
02:06:30 <ph88> wow i never knew that about groupBy, how did you figure that out Rembane ?
02:07:04 <sshine> ph88, that groupBy doesn't sort?
02:07:30 <ph88> that groupBy doesn't group by the grouping criteria on an unsorted list
02:07:40 <Rembane> ph88: It works like that in Python, but you are correct in that the docs aren't super clear about this. 
02:08:47 <sshine> ph88, yeah, I guess you have to know that group/groupBy doesn't sort. that would make it more useful in some cases, but also more expensive in situations where elements are already sorted.
02:11:13 <ph88> thanks guys, i made a note to see about making a change request on the documentation in base later
02:12:11 <Rembane> ph88: No worries, if your list becomes really long you can use a Map from Data.Map to group your items. 
02:12:45 <ph88> what about Data.Map ? does it also work together with groupBy ?
02:14:42 <Rembane> ph88: Create a function that creates a key and then use it when inserting. Like this: \element m -> M.insertWith (++) (pure $ keyFunction element) element m
02:15:13 <ph88> Rembane, the sortBy function has Bool as result and groupBy has Ordering as result .. how did you mean i could use the same function for both ?
02:15:32 <ph88> Maybe if i make an inbetween function when Ordering is equal then True ?
02:17:04 <Rembane> ph88: sortOn was the function I meant instead of sortBy, I have a tendency to mix them up and not noticing. :)
02:17:16 <ph88> :P
02:17:18 <ph88> thanks !
02:17:50 <ph88> groupBy :: (a -> a -> Bool) -> [a] -> [[a]] 
02:17:56 <ph88> sortOn :: Ord b => (a -> b) -> [a] -> [a] 
02:18:06 <ph88> i don't think i can plug the function here 1 on 1 actually
02:18:08 <cheater> hi
02:18:13 <ph88> hi cheater 
02:18:30 <cheater> hi ph88
02:18:54 <ph88> Rembane, i think i need a mapping function from Ordering to Bool and use sortBy ... don't know what you meant with sortOn
02:19:57 <Rembane> ph88: That's a good point, my confusion know no bounds. 
02:20:04 <ph88> lol
02:20:31 <Rembane> ph88: (== Eq) should turn Ordering into Bool. 
02:20:56 <tomsmeding> s/Eq/EQ/
02:22:14 <Rembane> ph88: ((.) . (.)) (== EQ) week -- if you are into pointless style 
02:22:15 <tomsmeding> sidenote: in case your first argument to groupBy is a projection, e.g. '(==) `on` fst', then you can pass 'comparing fst' to sortBy
02:22:52 <Rembane> tomsmeding: Thank you for pointing out my typo
02:23:12 <ph88> Rembane, that's a bit too crazy for me this pointless style :P
02:23:39 <Rembane> ph88: Good, it has a tendency to grow on you. :)
02:24:26 <tomsmeding> ph88: result = groupBy ((==) `on` utcTimeRoundDownWeek) . sortBy (comparing utcTimeRoundDownWeek) $ blocks
02:24:46 <tomsmeding> (on from Data.Function, comparing from Data.Ord)
02:25:22 <tomsmeding> I correctly predicted that you were projecting :p
02:25:56 <sshine> ph88, perhaps you could argue that because groupBy has no Ord constraint, making it able to group unsorted elements would be O(n^2).
02:26:44 <tomsmeding> can also use 'sortOn utcTimeRoundDownWeek' instead of the sortBy call, which will only evaluate utcTimeRoundDownWeek O(n) times instead of O(n log n) times, but at the cost of storing the rounded-down result for each list element before doing the actual sorting
02:26:47 <merijn> Well, also it's explicitly documented and intended to group adjacent elements
02:26:53 <merijn> Which is a useful operation
02:27:26 <tomsmeding> given that utcTimeRoundDownWeek looks relatively expensive, it may be worth using sortOn
02:27:30 <ph88> where is that explicitly documented merijn  ?
02:27:33 <tomsmeding> but I dunno given the code :p
02:27:58 <merijn> ph88: https://hackage.haskell.org/package/base-4.14.0.0/docs/Data-List.html#v:group
02:28:04 <merijn> ph88: There's even an example :)
02:28:07 <tomsmeding> >> The group function takes a list and returns a list of lists such that the concatenation of the result is equal to the argument.
02:28:11 <sshine> ph88, re. sortBy vs. sortOn: https://ro-che.info/articles/2016-04-02-descending-sort-haskell
02:28:14 <tomsmeding> implies there's no sorting
02:30:23 <merijn> tomsmeding: Well, the example also explicitly shows an example with duplicate elements spread out :0
02:30:32 <tomsmeding> fair :p
02:34:27 <ph88> nice article sshine :)
02:50:04 <ph88> tomsmeding, i tried this but i get a lot of duplicates in groups  result = groupBy ((==) `on` utcTimeRoundDownWeek) . sortBy (comparing utcTimeRoundDownWeek) $ blocks 
02:50:37 <tomsmeding> oh crap
02:51:09 <tomsmeding> s/utcTimeRoundDownWeek/(utcTimeRoundDownWeek . eventStart . blockItem)/g
02:51:18 <tomsmeding> though it wouldn't have compiled otherwise I think
02:52:31 <ph88> i already added about getting eventStart ...
02:52:33 <tomsmeding> what do you mean by duplicates? you end up with a total of more items than you started with? that sounds very strange
02:52:44 <ph88> looks like it ye
02:53:35 <tomsmeding> sortBy cannot increase the number of items, nor can groupBy, so perhaps check whether your input is what you expect it to be?
02:53:46 <tomsmeding> or do you mean you get more groups than you expect?
02:54:36 <ph88> i will check it .. in the moment my code is not in a state that i can give you an immediate answer
03:16:15 <ph88> tomsmeding, seems legit :))
03:33:55 <tomsmeding> ph88: it does work?
03:38:06 <ph88> tomsmeding, yes :D
03:38:30 <tomsmeding> good, then that threat to my understanding of haskell has fortunately been taken away :p
03:49:18 * hackage megaparsec 9.0.0 - Monadic parser combinators  https://hackage.haskell.org/package/megaparsec-9.0.0 (mrkkrp)
03:59:19 <cpressey> Would it make sense for there to be an operator like >=> that doesn't require the same kind of monad on both sides?
03:59:25 <cpressey> So with a type like (Monad m, Monad n) => (a -> m b) -> (b -> n c) -> a -> n c
03:59:32 <dminuoso> cpressey: What would that even do?
03:59:34 <dminuoso> cpressey: Try implementing it.
04:00:31 <dminuoso> Also, consider if we set `m ~ IO` and `n ~ Maybe`
04:03:48 <cpressey> OK. I like Haskell, I've programmed in it for a long time, but building intuitions for monads seems to be very difficult for me.
04:04:18 * hackage hspec-megaparsec 2.2.0 - Utility functions for testing Megaparsec parsers with Hspec  https://hackage.haskell.org/package/hspec-megaparsec-2.2.0 (mrkkrp)
04:05:03 <merijn> cpressey: The Wadler paper is, honestly, pretty good: https://www.cs.yale.edu/flint/trifonov/cs629/WadlerMonadsForFP.pdf
04:05:03 <sshine> hm
04:05:26 <cheater> cpressey: no need for intuitions. just use them.
04:06:27 <maerwald> merijn: that's 30 pages :>
04:06:51 <merijn> maerwald: I said it was good, I didn't say it was short
04:07:29 <merijn> It's 30 pages because it showcases a whole bunch of examples of "stuff you might wanna do" and how there is a monad abstraction hiding in it
04:08:00 <merijn> You can get it short if you write just maths and laws, but then it'd be useless for seeing what's going on unless you already know how to think about abstractions like that
04:08:06 <maerwald> wish there was an epub
04:08:17 <maerwald> pdf is pesky to read on ebook readers
04:08:44 <merijn> It's fine on my 10 inch kindle, but it's get old and rotten battery and they only make small readers now :(
04:11:01 <maerwald> I have a pocketbook inkpad 3, 7.8 inch. Fine for epub with code, but pdf no wag
04:11:34 <maerwald> Would have to use my tablet, but not for 30 pages
04:11:56 <cpressey> Maybe I could rephrase? Are there cases where two monads m and n are similar enough that it's possible to write an operator like >=> that takes either m or n on either side?
04:12:10 <dminuoso> cpressey: There's something similar
04:12:23 <dminuoso> The package mmorph implements the idea that you can sometimes turn one into the other
04:12:25 <merijn> cpressey: You can for some *specific* types, but not in general
04:12:55 <dminuoso> cpressey: But really, if you have trouble even understanding monads, none of this is helpful.
04:13:03 <dminuoso> I'd worry more about using specific instances. That's easy
04:13:06 <dminuoso> Every beginner can do that
04:13:28 <dminuoso> After a while, you'll grow your own intuition about what monads mean automatically, without effort.
04:14:11 <merijn> cpressey: The problem is that there's no general way to "unwrap" something using the Monad class/interface. So you can't write a generic function that converts a monad 'm' into a monad 'n', because if all you know is "'m' is a Monad" then that's not enough to unwrap
04:15:11 <merijn> cpressey: Now, if you have a *specific* type that you can unwrap (maybe you have "Maybe" and some sensible default value, for example) then you can convert into some arbitrary other monad via 'pure'/'return'
04:15:42 <maerwald> I don't think there's much to understand about Monads, except that there's an "effect" flow and a "value" flow (that's most easy to imagine with parsers and IO, but generalises to all monads in one way or another). The special thing about monads is really that the next effect depends on the "current" value: http://neilmitchell.blogspot.com/2019/10/monads-as-graphs.html
04:15:48 * hackage megaparsec-tests 9.0.0 - Test utilities and the test suite of Megaparsec  https://hackage.haskell.org/package/megaparsec-tests-9.0.0 (mrkkrp)
04:16:34 <maerwald> that has some implications for analysis of the effect graph
04:21:37 <cpressey> merijn: What you say makes sense, thanks. It's stuff I already know, or already should know, but it never sticks.
04:24:22 <cpressey> Can I ask another stupid question, or have I reached my quota for today?
04:24:56 <maerwald> you may :p
04:24:56 <Dolly> Hey, is there anyone here I can dm for a rather quick question (which is very elementary, I am just very new to this)
04:27:23 <cpressey> The "free monadic interpreter" pattern, as I understand it, is: define an ADT, derive a functor from it, define a free monad from that functor, then write an interpreter that interprets such a free monad. Since it's entirely possible to just interpret an ADT, my question is, what exactly do you lose if you cut out the "make it into a free monad" step?
04:28:25 <sshine> cpressey, then I presume you need an interpreter for each individual monad?
04:28:50 <sshine> (I only read about free monads, I didn't use them yet.)
04:29:54 <tomsmeding> Dolly: many elementary questions are asked here each day, so you can just ask it here in the channel :)
04:30:00 <cpressey> sshine: Yes, but that seems to be part of the pattern, at least as I've seen some people advocate it: each language is
04:30:15 <lortabac> cpressey: http://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html
04:30:17 <Dolly> Fair enough
04:30:40 <lortabac> cpressey: if I remember correctly, this post answers that question at some point
04:31:01 <cpressey> lortabac: Thanks, I'll read it.
04:31:41 <merijn> cpressey: The idea between the "free monad" step is that you it's abstraction where it's easier to project out different interpretations of the core language
04:32:20 <merijn> cpressey: That said, free monads area, imo, one of those "top of the haskell pyramid on social media" things :)
04:32:54 <merijn> cpressey: (see https://patrickmn.com/software/the-haskell-pyramid/)
04:33:43 <Dolly> Ok, so I am supposed to show how the meaning of the pattern matching definition && can be formalised using two nested conditional expressions: True && True = True , _ && _ = False. I am just not aware of how this should work
04:34:17 <lortabac> merijn: that doesn't answer cpressey's question though, which is why does it have to be a monad
04:34:25 <cpressey> lortabac: Oh actually I read that yesterday (didn't recognize it as the title differs from the URL)
04:34:33 <Dolly> I am aware this should be intuitive, I just cannot seem to understand it
04:35:26 <merijn> lortabac: The free monad part is hwat makes the projection into other interpretations easy
04:35:31 <tomsmeding> Dolly: does that mean, rewrite the pattern matching as if-else expressions?
04:36:15 <merijn> I mean, nothing "has to be" a Monad >.>
04:36:27 <cpressey> I guess I'm going from Alexander Granin's position that the free monad interpreters should be self-contained and hierarchical. If that's the case, then any individual interpreter doesn't need to understand more than one of them, so they don't really need to be composed
04:36:35 <Dolly> Yeah, I am meant to write a nested conditional expression which captures the meaning of the pattern matching expression
04:37:21 <tomsmeding> Dolly: so basically, 'a && b = if ...'
04:37:31 <tomsmeding> where do you get stuck writing that if-expression?
04:38:28 <tomsmeding> also, how do you imagine pattern matching to work internally
04:38:35 <tomsmeding> that might give you some clues
04:42:00 <lortabac> cpressey: is your question why don't we just define data 'Toy b = Output b Toy | Bell Toy | Done' and avoid the free monad part?
04:42:05 <Dolly> og x y = if x==True then Trueelse if y==True then Trueelse False
04:42:17 <Dolly> I mean, I reckon it should be something close to that
04:42:19 <cpressey> lortabac: Basically yes.
04:42:49 <lortabac> cpressey: I guess it's simply because that would force b to be the same for all commands
04:43:32 <tomsmeding> Dolly: what does 'og True False' evaluate to? Is this what it should be?
04:43:38 <merijn> cpressey: Without free you have to manually write out all traversals
04:43:52 <merijn> cpressey: What free gives you is traversals/recursions for, well, free
04:44:19 <merijn> cpressey: So, suppose you write an interpreter X, you only need to write a single function that maps each constructor of your Functor to a new result
04:44:50 <merijn> cpressey: So if you write 10 different interpreter you just write 10 different mapping functions and you can share all the traversal logics for all of them
04:44:59 <cpressey> You can compose interpreters for free monads, in a way you can't compose interpreters for plain ADTs, is that it?
04:45:25 <merijn> cpressey: For a plain ADT you have to reimplement the recursion for each interpreter
04:45:47 <maerwald> (that's what many languages do)
04:46:08 <maerwald> downside of free is that it's not good for memory
04:46:16 <merijn> cpressey: Note that the Free monad approach does *not* have any recursive constructors
04:47:51 <cpressey> OK. Thanks for the explanation.
04:49:23 <merijn> tbh, I'm not sold on the usefulness of Free yet
04:50:35 <lortabac> its usefulness is certainly rarer than its popularity
04:51:16 <maerwald> yes, because it's slow, that's why it has been abandoned for effects systems too
04:51:30 <merijn> Not even, tbh
04:51:37 <merijn> It has a lot of syntactic overhead
04:51:50 <merijn> (pattern synonyms can solve that now, but that's recent)
04:52:23 <merijn> And the problem it solves is just not that painful (i.e. writing the recursion over your AST is usually not the hardest part of writing an interpreter)
04:52:52 <cpressey> Well, it seems you could also make your ADT an instance of Monad, without going through Free, and still be able to write a monadic interpreter for it; so Free seems kind of like a minor convenience rather than the real power of the pattern
04:53:33 <merijn> cpressey: Well, free lets you turn things into Monads even if they aren't Monads :)
04:54:11 <maerwald> merijn: but we can expand your argument to Monads in general... that's why rust didn't bother with proper monads and have "and_then" methods on Result type etc
04:54:27 <maerwald> it isn't hard to reimplement either
04:54:46 <merijn> maerwald: Except monads aren't actually hard to work with and you can write useful generic code
04:54:59 <lortabac> maerwald: but you have plenty of functions acting generically on monads
04:55:07 <maerwald> I agree
04:55:30 <maerwald> but when I code rust I don't often find myself missing that abstraction... I certainly notice it here and there
04:55:41 <maerwald> but you can still get away with it
04:58:35 <maerwald> but that's an imperative lang... I think it's more annoying to not have it in a functional lang
05:20:19 * hackage indigo 0.2.1 - Convenient imperative eDSL over Lorentz.  https://hackage.haskell.org/package/indigo-0.2.1 (gromak)
05:40:48 * hackage HPDF 1.5.1 - Generation of PDF documents  https://hackage.haskell.org/package/HPDF-1.5.1 (SylvainHenry)
06:37:33 <cpressey> https://gist.github.com/cpressey/eb1c0872e81c80ecfce56ec94f34086e is the pipeline framework that I eventually worked out. I'm not convinced of the wisdom of re-exporting & with a different precedence, and exporting a <!> that is only "morally equivalent" to Data.Functor.Alt's <!>, but the possibility of making up entirely new operators for those feels slightly worse.
06:43:18 * hackage elynx-markov 0.4.0 - Simulate molecular sequences along trees  https://hackage.haskell.org/package/elynx-markov-0.4.0 (dschrempf)
06:44:19 * hackage elynx 0.4.0, tlynx 0.4.0, slynx 0.4.0, elynx-tree 0.4.0, elynx-tools 0.4.0, elynx-seq 0.4.0, elynx-nexus 0.4.0 (dschrempf)
07:25:56 <bbear> hello, I would like to found a project of code navigation for haskell (kind of like an IDE plugin). How could I start that ? With which editor should I integrate this ?
07:27:19 * hackage neat-interpolation 0.5.1.2 - A quasiquoter for neat and simple multiline text interpolation  https://hackage.haskell.org/package/neat-interpolation-0.5.1.2 (NikitaVolkov)
07:30:48 * hackage headed-megaparsec 0.2 - More informative parser  https://hackage.haskell.org/package/headed-megaparsec-0.2 (NikitaVolkov)
07:31:43 <merijn> bbear: You should probably figure out how to integrate with haskell-language-server?
07:31:56 <merijn> bbear: See https://mpickering.github.io/ide/posts/2020-05-08-state-of-haskell-ide.html
07:31:59 <bbear> what is haskell-language-server ?
07:32:49 * hackage language-c 0.9 - Analysis and generation of C code  https://hackage.haskell.org/package/language-c-0.9 (jophish)
07:35:48 * hackage postgresql-syntax 0.3.0.3 - PostgreSQL AST parsing and rendering  https://hackage.haskell.org/package/postgresql-syntax-0.3.0.3 (NikitaVolkov)
07:42:53 <sm[m]> bbear easiest right now is apparently VS Code + its haskell plugin
07:44:06 <lucky> i found it pretty simple to get running, yes.  
07:46:24 <merijn> pretty sure that one is based on ghcide and thus sorta haskell-language-server :p
07:46:44 <merijn> sm[m]: afaict he was asking about easiest way to *develop* such a plugin, no?
07:47:24 <merijn> For which I'd say the answer is that any new plugin for that sorta thing should probably aim at hls, since that has the most momentum and people paid to work on it
07:47:29 <sm[m]> oops, right you are. I'd probably still point there
07:48:08 <sm[m]> actually I'd tell bbearto join #haskell-ide-engine
07:48:46 <merijn> sm[m]: HIE is merging with hls, though :p
07:49:07 <sm[m]> I know. It's just the channel for hls and all other IDE development
07:49:14 <sm[m]> and vscode has the current smoothest integration of hls
07:49:36 <sm[m]> channel needs a rename, I agree!
07:50:07 <sm[m]> #haskell-ide, alanz_ ?
07:50:27 * sm[m] had too much coffee.. back to work
08:10:48 * hackage provenience 0.1.1.0 - Computations that automatically track data dependencies  https://hackage.haskell.org/package/provenience-0.1.1.0 (olf)
09:34:11 <boxscape> % case 4 of id -> x -> x
09:34:11 <yahb> boxscape: ; <interactive>:13:19: error: parse error on input `->'
09:34:14 <boxscape> sad
09:34:24 <boxscape> imagine how much amazingly unreadable code you could write if you could chain viewpatterns without parens
09:34:45 <boxscape> % case 4 of (id -> x) -> x
09:34:46 <yahb> boxscape: 4
09:36:11 <int-e> > case 4 of (id -> x) | x <- x -> x
09:36:13 <lambdabot>  4
09:37:06 <int-e> (which side does the x go?)
09:37:17 <boxscape> > case 4 of (id -> x) | let x = x -> x
09:37:20 <lambdabot>  *Exception: <<loop>>
09:37:24 <boxscape> at first glance those look like the same thing
09:47:18 <monochrom> Too many arrows.
09:47:34 <monochrom> Too many x's too I guess.
09:50:04 <pera> Does anyone knows how to reach haskell.org's mailing list admin? (I have tried with haskell-admin@ and mailman@ but without luck)
10:05:37 <sureyeaah> I am importing a data type (that uses a lot of other internal data types) from a library and I want to add a Hashable instance to it. I'm guessing it can be done with Generic? Can someone point out what I'm supposed to do exactly?
10:09:25 <monochrom> If you are using hashable-1.3.0.0:
10:09:45 <monochrom> Allow me to name your type T.
10:10:49 <monochrom> You must derive Generic for T. Since T is from someone else, you may need standalone deriving. Standalone deriving comes with its own requirements, but perhaps you can just try and let the error message tell you.
10:11:14 <monochrom> If that is successful, you add one line "instance Hashable T" and that's it.
10:14:19 * sureyeaah sent a long message:  < https://matrix.org/_matrix/media/r0/download/matrix.org/UaDxRdvTjZaJwgcddJiYMACH/message.txt >
10:14:33 <sureyeaah> s/T/Tree
10:15:00 <sureyeaah> The generic instance derived successfully.
10:16:17 <monochrom> Perhaps further add "instance Hashable a => Hashable (Group a)".  or "instance Hashable (Group Tree)". I don't know which one is better.
10:17:28 <monochrom> may also need deriving instance Generic (Group a) or (Group Tree)
10:19:06 <monochrom> "If you see your father, derive Generic your father and instance Hashable your father. If you see Buddha, derive Generic Buddha and instance Hashable Budha"
10:21:06 <sureyeaah> Yep makes sense. Is there anyway I can avoid writing instances for all the types that Tree depends on? There must be at least 50 of them.
10:21:47 <monochrom> No. But at least you write no implementation at all, just requests.
10:22:29 <sureyeaah> Not even via TH?
10:22:57 <monochrom> Imagine what would be the minimum handwriting you need with TH.
10:23:12 <monochrom> For example, can you avoid handwriting 50 type names?
10:24:57 <sureyeaah> fair enough. I would have thought this is a not so rare tedious task that people might have automated it already.
10:28:41 <monochrom> It is rare to have 50 tightly interacting types.
10:29:21 <monochrom> It is common to have 5 tightly interacting types. But then it doesn't feel like tedious when there are only 5.
10:48:13 <dmwit> monochrom: I think you can avoid handwriting 50 type names.
10:49:08 <dmwit> It shouldn't be that hard to write a DFS or so on the fields of a type to discover all the reachable type constructors.
10:49:29 <dmwit> ...but I don't think anybody has done that, and writing a DFS may be more work than writing 50 type names. ^_^
10:54:39 <monochrom> IIRC TH does not have reflective ability to find out the structure of someone else's type.
10:56:12 <monochrom> Generics has that reflective ability. But there is a bootstrapping problem. You have to hand-write a "deriving Generic" for T in order to get Generics to take a look at T. And even then it stops at a shallow level, i.e., it unfolds only once.
10:57:19 <monochrom> Suppose you have "data T = Ctor T2".  Generics knows to expand T to "Ctor" and "T2". It doesn't expand T2, until you say so.
10:57:57 <monochrom> So if you plan to handwrite "OK expand T2 too", you have defeated the point.
10:58:43 <monochrom> But perhaps you can say: feed the result of expanding T to TH, TH issues the "OK expand T2" command.
10:59:41 <monochrom> Well OK this sounds like if the chain is n steps long then you're looking at n-stages of metaprogramming, but TH is only 1.
11:01:30 <geekosaur> that's what I was thinking, you can't splice into a splice much less make a "splice tree"
11:02:17 <koz_> geekosaur: Yo dawg, we heard you like metaprogramming...
11:03:30 <c_wraith> metaML exists!
11:04:44 <monochrom> Your next concession is: But TH is in IO, maybe TH issues the bigger command "generate the next *.hs file to hold the 'OK expand T2' command, then run ghc on that file".
11:06:20 <monochrom> At that point I think it's more profitable to go back to square 1.
11:07:03 <monochrom> Run haskell-src or haskell-src-ext on source code to extract data declarations. Run DFS in that context.
11:11:25 <monochrom> Maybe I should take a look at metaML. Does it do like n-stage metaprogramming? (That would break my mind, but OK!)
11:12:07 <phadej> you can do n-stage metaprogramming in haskell too
11:12:15 <phadej> have TH generate expression of TH
11:12:36 <phadej> fwiw, there is typed TH, which is quite close to metaML
11:12:43 <phadej> (i.e is typed)
11:26:16 <phibs> Anyone know how to fix this?  I am a haskell noob trying to build a git-annex pkg: https://p.bsd-unix.net/view/08a58f78 
11:29:00 <maerwald> phibs: I think your GHC is too old
11:29:02 <maerwald> which version
11:29:26 <phibs> The Glorious Glasgow Haskell Compilation System, version 7.10.3
11:29:39 <maerwald> yes, too old and it seems cabal is too old as well
11:29:44 <phibs> ouch
11:30:03 <phibs> yeah trying to build git-annex on Ubuntu 16 (hard requirement), any ideas?
11:30:05 <maerwald> try ghc-8.8.4 or 8.10.2
11:32:29 <koz_> Base 4.8 is _ooooold_.
11:32:36 <koz_> That's like, GHC 7.something?
11:32:58 <phibs> yeah, Ubuntu 16 :(
11:33:08 <phibs> sadly this process I am going through is for our Ubuntu 20 fleet upgrade ;0
11:33:27 <maerwald> phibs: use https://www.haskell.org/ghcup/ or https://launchpad.net/~hvr/+archive/ubuntu/ghc to upgrade
11:33:29 <koz_> phibs: Use ghcup to install a local GHC.
11:33:41 <koz_> Basically, don't use distro GHCs unless you _absolutely_ must.
11:33:42 <phibs> ok i'll try that thanks!
11:35:08 <phibs> looks like nothing haskell is required for runtime of git-annex so that's good
11:36:53 <c_wraith> that's the default way ghc builds stuff, unless you're using arch for some reason
11:37:07 <phibs> awesome
11:38:21 <Clint> phibs: the git-annex package not new enough for you?
11:38:57 <phibs> in U16 it is v5, we need v8 ;0
11:39:07 <phibs> (it doesn't work with newer git that we use)
11:39:19 * hackage sbv 8.8 - SMT Based Verification: Symbolic Haskell theorem prover using SMT solving.  https://hackage.haskell.org/package/sbv-8.8 (LeventErkok)
11:40:38 <Clint> oh, i thought you said you were going to ubuntu 20
11:42:47 <phibs> yeah our apt repo infra uses git-annex (not my choice), hence the need to upgrade it ;0
11:50:13 <theeHaskeller> hello
11:50:23 <theeHaskeller> is anyone online?
11:51:07 <theeHaskeller> can anyone please recommend a good resource to learn haskell for a newbie
11:51:23 <theeHaskeller> I know python and c++
11:51:32 <juliusdeane> "learn you a haskell for great good" is pretty good
11:51:33 <juliusdeane> http://learnyouahaskell.com/
11:52:14 <juliusdeane> "programming in haskell" is also quite useful, but it's a little more theoretical []
11:52:17 <juliusdeane> http://www.cs.nott.ac.uk/~pszgmh/pih.html
11:52:33 <theeHaskeller> I have heard that I need to know category theory as well in order to learn haskell?
11:52:38 <juliusdeane> not really
11:52:39 <c_wraith> definitely false
11:52:50 <dminuoso> theeHaskeller: CIS 194 is a freely available high quality course with good examples.
11:52:51 <theeHaskeller> oh
11:53:13 <ezzieyguywuf> juliusdeane: I learned haskell and i don't know category theory.
11:53:28 <monochrom> wrong person
11:53:31 <juliusdeane> haha
11:53:49 <ezzieyguywuf> uhrm, theeHaskeller ^^
11:53:57 <theeHaskeller> ok so category theory is not a requirement for just starting out
11:54:07 <c_wraith> It's not a requirement for being an expert.
11:54:28 <c_wraith> It's just the source of several abstractions.  But if you don't care where they came from, they're perfectly fine to just use.
11:54:37 <theeHaskeller> oh
11:54:41 <theeHaskeller> I see
11:54:41 <dminuoso> Category theory is also of relatively low value, compared to other things.
11:54:50 <ezzieyguywuf> it's like, do you understand all the inner workings of c++?
11:54:56 <ezzieyguywuf> b/c I don't lol.
11:54:58 <dminuoso> For instance, learning basic rudimentary algebra takes much less time and has more value in programming.
11:55:26 <theeHaskeller> so CIS 194 vs learnyouahaskell which one should I prefer?
11:55:37 <dminuoso> While category theory is indeed value for a select few people, it takes an extraordinary amount of time to learn, and I think it's value increases if you happen to have a high expertise in multiple mathematical domains.
11:55:40 <monochrom> Both.
11:55:57 <juliusdeane> theeHaskeller: try both, and see what suits you best (and both might be good for you, who knows)
11:56:13 <juliusdeane> I've got an interesting question about recursive ASTs
11:56:17 <dminuoso> theeHaskeller: Regarding "do I need to learn category theory", this diagram might be useful: https://patrickmn.com/software/the-haskell-pyramid/
11:56:33 <theeHaskeller> cool I'll try both
11:56:39 <juliusdeane> so if I have an AST for terms in my language called `TermF a` which is also a functor
11:57:05 <juliusdeane> and I create a type synonym `Term = Fix TermF`
11:57:30 <theeHaskeller> thanks for the source dminuoso
11:57:40 <juliusdeane> and I have another type `ATerm a` which is a `TermF` with annotations of type `a` on each node
11:58:10 <c_wraith> juliusdeane: this would probably be a lot easier to keep track of if you threw enough of it to be useful into a pastebin
11:58:27 <monochrom> @where paste
11:58:28 <lambdabot> Help us help you: please paste full code, input, and output at https://hastebin.com or https://paste.tomsmeding.com
11:58:36 <juliusdeane> c_wraith: true, thanks for the tip
11:58:42 <monochrom> That last one is our new favourite pastebin
11:58:57 <monochrom> Maybe we don't need the hastebin.com one anymore
11:59:01 * tomsmeding smiles
11:59:11 <monochrom> Hell I'll do it.
11:59:29 <monochrom> @where+ paste please paste full code, input, and output at https://paste.tomsmeding.com
11:59:29 <lambdabot> Good to know.
11:59:49 <dminuoso> This will be our favourite pasting service until tomsmeding's master thesis is done.
11:59:58 <dminuoso> Then he suddenly has no more time, and the service will randomly disappear.
11:59:58 <tomsmeding> after which? :p
12:00:00 <dminuoso> :p
12:00:02 <tomsmeding> oh :'
12:00:04 <tomsmeding> * :')
12:00:06 <monochrom> hastebin used to be the lesser evil compared with pastebin.com. that was the only reason I suggested it.
12:00:29 <monochrom> Well go on for a PhD. Problem solved.
12:00:55 <tomsmeding> I might just
12:01:04 <monochrom> I tell you a secret. It's my greatest cunning plan.
12:01:05 <ezzieyguywuf> does it work with wgetpaste?
12:01:31 <ezzieyguywuf> it does not
12:02:07 <tomsmeding> ezzieyguywuf: can I make it work with wgetpaste?
12:02:08 <dminuoso> Mmm, is a field that hasn't received any academic attention previously possible for a PhD thesis? Or do PhDs commonly focus on more refining/going deeper into existing research?
12:02:19 <monochrom> My department had an undergrad student who made a great TA. We didn't want to lose him, i.e., when he would graduate, he would no longer be our TA. We wanted to delay that, tongue in cheek.
12:02:39 <monochrom> My colleague said "yeah we need an excuse to not let him graduate".
12:02:57 <ezzieyguywuf> tomsmeding: probably, but I doubt you want to. I think wgetpaste is  pretty gentoo-specific script for general pastebinning
12:03:14 <ezzieyguywuf> tomsmeding: your thing seems to be pretty specifically for #haskell
12:03:22 <c_wraith> dminuoso: either one can work.  The latter is easier.  The former requires finding a professor willing to work on it.
12:03:26 <monochrom> I was like "that's the wrong and ineffective and uphill-battle way of doing it. It's very hard to prevent an undergrad from graduating.  Here is the right and easy way: get him into grad school."
12:04:04 <ezzieyguywuf> I've always thought about getting a phd
12:04:08 <ezzieyguywuf> so that I could mke my wife call be doctor
12:04:12 <ezzieyguywuf> ðŸ˜‚
12:04:15 <dminuoso> c_wraith: Mmm. So if we as a company want a new field explored, it might be easier to find someone who starts off doing the groundwork in his M.Sc, and perhaps continue his work later?
12:04:24 <monochrom> "After he becomes a grad student, with any luck, he won't even get out ever, without you doing anything"
12:04:54 <dminuoso> Im exploring funding options on our end, just want to get an idea about what I can reasonably expect to propose to a professor should I find one. :)
12:04:55 <c_wraith> dminuoso: or do it yourself.  :P
12:05:36 <tomsmeding> ezzieyguywuf: would "making it work" mean changes on my end, or changes to wgetpaste?
12:05:47 <rig0rmortis> I've wanted to get  PhD, but I'm almost 30 now and have already forgot all the math from my undergrad :p
12:05:47 <dumptruckman> any suggestions on which cocolatey package I should use for haskell?
12:06:06 <rig0rmortis> get a* forgotten all*
12:06:15 <monochrom> Isn't there only one?
12:06:23 <dminuoso> c_wraith: Hehe. The type of field Im thinking of probably is better explored with an experienced professor behind it. And with the ability to spend full time on it.
12:06:25 <dumptruckman> I also considered PhD partly because then I could be Dr. Wood. Then I'd build myself a wood workshop and become a carpenter
12:06:47 <dminuoso> Roughly, it'd be about something similar as Clash, but for domain specific circuitry.
12:06:53 <rig0rmortis> dumptruckman: that sounds like destiny
12:06:58 <tomsmeding> dumptruckman: you can call your wod workshop that anyway
12:07:01 <tomsmeding> *wood
12:07:44 <dumptruckman> I could never decide what I wanted to focus in though
12:07:45 <ezzieyguywuf> tomsmeding: I'm guessing changes to wgetpaste
12:07:54 <dumptruckman> and by the time I finished my undergrad I was soooo ready to be done with school
12:08:31 <dumptruckman> and I also realized I kind of hate academic research
12:08:37 <ezzieyguywuf> rig0rmortis: 1 + 1 = 2. build from there.
12:08:46 <ezzieyguywuf> yea academic research blows
12:09:05 <dumptruckman> any idea if i choco install ghc if i should not ghc install haskell-stack?
12:09:10 <dminuoso> dumptruckman: For me, it was the lack of fitting universities nearby that sealed the deal.
12:09:15 <tomsmeding> it looks like a config file can be written for wgetpaste to have it support new paste services
12:09:24 <ezzieyguywuf> ðŸ˜®
12:09:28 <ezzieyguywuf> tomsmeding: you're my hero
12:09:44 <tomsmeding> at least, https://wgetpaste.zlin.dk/zlin.conf seems to suggest that
12:10:04 <tomsmeding> I have to say that website is pretty bare-bones :p
12:10:06 <dumptruckman> dminuoso: a big part of it for me was also that paired with having a 2 year old child that would make moving very difficult
12:10:07 <tomsmeding> even my website has more css
12:11:12 <dminuoso> dumptruckman: Yeah, having a kid of my own reduces my flexibility. Plus, Id had to jump start from a B.Sc, while I could probably rush that in a year - I'd have to spend another 2-3 on the M.Sc before things get even interesting. Gotta question the value of that all.
12:11:22 <ezzieyguywuf> tomsmeding: lol. you're right
12:11:36 <dumptruckman> right
12:11:42 <Saten-san> I'm trying to write a recursive function, but Haskell doesn't seem to acknowledge the existence of it inside the function itself. Can someone take a look at my code?
12:11:43 <Saten-san> https://dpaste.com/C9GB94Y7B
12:11:50 <ezzieyguywuf> tomsmeding: ah hah, but wgetpaste --help has info
12:11:51 <Saten-san> Sorry for the ugly indentation by the way.
12:12:00 <dminuoso> Saten-san: Check the compiler error.
12:12:07 <dminuoso> If I read this right, it should be accurate.
12:12:11 <ezzieyguywuf> https://dpaste.com/2S6XJVSLX
12:12:25 <dumptruckman> Saten-san: pretty sure you're missing some parens
12:12:43 <Saten-san> dumptruckman: I will try a where binding
12:12:49 <tomsmeding> ezzieyguywuf: I _think_ you're using an old version of wgetpaste
12:12:56 <dumptruckman> i don't think you need that
12:13:11 <dumptruckman> i think you want elem x (tail y)
12:13:24 <Saten-san> Ambiguous occurrence â€˜elemâ€™
12:13:37 <ezzieyguywuf> 2.29-r1
12:13:43 <Saten-san> Nope. Not the solution.
12:13:43 <monochrom> "elem" is a name clash with what's already in Prelude
12:13:50 <dumptruckman> ahh
12:13:52 <tomsmeding> ezzieyguywuf: https://wgetpaste.zlin.dk/
12:13:53 <monochrom> Choose a different name.
12:13:58 <Saten-san> Oh, my bad :P
12:14:02 <geekosaur> so you need to qualify with the module name, since you have another "elem" imported. has nothing to do with recursion, you'd get that on any use
12:14:09 <geekosaur> or rename it, yeh
12:14:13 <monochrom> You will run into other problems.
12:14:13 <Saten-san> I'm not that familiar with the Haskell STL yet.
12:14:19 <Saten-san> I mean Prelude.
12:14:22 <monochrom> You have multiple problems.
12:15:12 <suzu_> is snap not available on any GHC beyond 8.2.2?
12:15:13 <suzu_> :(
12:15:25 <ezzieyguywuf> 'you have multiple problems', lol
12:15:34 <geekosaur> don't we all
12:15:34 <tomsmeding> suzu_: https://paste.tomsmeding.com/ is happily using snap-server with ghc 8.8.4
12:15:44 <suzu_> oh neat
12:15:56 <suzu_> hmm, snap isn't in any stackage LTS beyond GHC8.2.2 though
12:16:07 <suzu_> the `snap` package itself, that is. `snap-server` is in more recent versions
12:16:09 <monochrom> Yeah beginners just assume there is only one problem so if you only suggest a fix of one problem, beginner concludes "nope, that's not the solution".
12:16:22 <geekosaur> that suggests to me the package got split up for later versions
12:16:27 <Saten-san> It still got some logical errors but I'm pretty proud that I managed to make a recursive function :)
12:16:30 <monochrom> Instead of accepting that it is an improvement, they decide to throw it away.
12:16:55 <dminuoso> tomsmeding: Why is syntax highlighting disabled by default?
12:17:05 <ezzieyguywuf> what dminuoso said.
12:17:13 <dumptruckman> Any idea which of these I want? https://chocolatey.org/packages?q=haskell
12:17:19 <ezzieyguywuf> also, though, I stopped using syntax highlighting recently....
12:17:30 <dumptruckman> i'm guessing haskell-stack is gonna be the easiest but i'm not really sure
12:17:39 <tomsmeding> dminuoso: /shrug/
12:17:50 <tomsmeding> I believe monochrom was not particular excited about syntax highlighting
12:17:59 <suzu_> tomsmeding: do i need the `snap` package?
12:18:03 <mantecon> hey
12:18:13 <tomsmeding> turning it on by default would be trivial though, would that be okay?
12:18:23 <geekosaur> snap looks to be a metapackage these days
12:18:25 <monochrom> Yeah I was more excited about the prospect of getting spammed, heh.
12:18:25 <tomsmeding> suzu_: I'm using snap-server and snap-core, but then I'm not using the entire snap suite, only the core server
12:18:39 <geekosaur> stackage wouldn't care about it as such, only about the pckages it pulls in as dependencies
12:18:49 <mantecon> sorry to bother, whats the best way to start learning haskell
12:18:56 <dminuoso> mantecon: Depends on you.
12:19:12 <suzu_> hmm, so then perhaps i don't need it
12:19:17 <dminuoso> mantecon: Pick a good learning resource and/or a book, study, and most importantly *practice* writing Haskell.
12:19:32 <dminuoso> That's the recipe to learn anything.
12:19:34 <mantecon> any recommendation?
12:19:34 <monochrom> Oh, if it's trivial to enable, I don't object. I only object doing a lot of work for little gain.
12:19:38 <suzu_> i'll get started with the core and the server then, thanks tomsmeding 
12:19:43 <dminuoso> monochrom: CIS 194 is a good starting place.
12:19:47 <dminuoso> Err mantecon ^-
12:20:13 <tomsmeding> monochrom: syntax highlighting already exists behind the 'toggle' button in the top-right corner; the only change this incurs is changing a default 'false' to 'true'
12:20:14 <mantecon> thanks a lot, I'll be going through that
12:20:18 <tomsmeding> it already remembers your choice in localStorage
12:20:39 <monochrom> Yeah OK please take the opinion of other people then!
12:21:06 <dminuoso> Can someone look at my trivial hsc2hs code, and tell me if there's some subtle mistake Im making? This is just 2 fields, and Im starting to become insane.
12:21:13 <juliusdeane> I've got a question about types and stuff: https://paste.tomsmeding.com/bineKL8i
12:21:51 <monochrom> juliusdeane, you need to show actual definitions.
12:22:29 <dminuoso> https://paste.tomsmeding.com/Tk7DGjEA <- this is the code in question, together with the struct
12:22:30 <albestro> I'm in too late in the conversation, but I've started learning haskell in the last week (in my spare time), and I confirm that learnyouahaskell.com/ is a very nice resource
12:22:37 <tomsmeding> ezzieyguywuf: wgetpaste has zero (0) documentation, so if you can figure out how that format works, I'll write the conf file :p
12:22:48 <ezzieyguywuf> tomsmeding: lol I know!!!!!
12:22:58 <ezzieyguywuf> tomsmeding: you're a gentleperson and a scholar.
12:23:13 <albestro> I would suggest to start with the first chapters of that, to start getting used to the very basic of the language, and then giving a look to CIS194 (already metntioned)
12:23:37 <monochrom> dminuoso: Do you get an error message? Or is it no error message but funny behaviour?
12:23:50 <dminuoso> monochrom: No error message and funny behavior.
12:23:52 <albestro> for CIS194 some students also put on github repos their solution
12:24:07 <dminuoso> It's either this, or there's something really funky going on that interrupts my ffi call.
12:24:26 <albestro> and, if IMHO, CIS194 from Spring'13 is the best one
12:24:28 <dminuoso> monochrom: That may have read wrong. No error message _but_ funny behavior. ;)
12:25:08 <monochrom> It looks right. I can't find anything wrong here.
12:25:12 <sm[m]> dumptruckman: yes, stack is one of the easiest ways to get started on windows
12:25:12 <geekosaur> ffi calls are not supposed ot block, and in articular will get SIGALRM intended for the RTS if they do
12:25:40 <monochrom> Unless __u32 is not uint_32
12:25:42 * geekosaur has diagnosed a number of those
12:27:02 <tomsmeding> paste.tomsmeding.com now has syntax highlighting on by default if you've never visited the site before
12:27:02 <sm[m]> dumptruckman: actually, the easiest way. https://marketplace.visualstudio.com/items?itemName=haskell.haskell might be something to consider later
12:27:20 <tomsmeding> dminuoso: ezzieyguywuf: ^
12:27:30 <dumptruckman> sm[m]: i installed that via chocolatey it seems
12:28:06 <dminuoso> So let me explain what's happening. Im calling ioctl which causes the NIC to blink, the Value is embedded in the ioctl request and the data specifies the length.
12:28:09 <sm[m]> lovely tomsmeding. By the way I saw cmd-enter working on mac yesterday, but on ipad today it opens a new tab and shows an error
12:28:22 <dminuoso> This works in principle, except the LED flashes only for a few milliseconds and goes off.
12:28:34 <dminuoso> With ethtool, which uses the exact same ioctl everything works.
12:29:02 <tomsmeding> sm[m]: :')
12:29:03 <tomsmeding> what
12:29:04 <dminuoso> If this was an endianness bug, I'd have the LED flashing for a very very long time (I tried specifing 0 which means infinite, or 10 which means 10 seconds)
12:29:10 <monochrom> Do you also have your own 5-line C program that calls the same ioctl?
12:29:25 <dminuoso> monochrom: Well ethtool, the code path is roughly 20ish lines, so enough to vet it.
12:29:35 <monochrom> I mean just to be sure it's a simple ioctl, no other things needed.
12:29:40 <dminuoso> Yes, it's just a simple ioctl.
12:29:47 <monochrom> Ah OK, 20 lines is fair.
12:29:48 <tomsmeding> sm[m]: perhaps cmd-enter on ipad is hard-coded to do something specific, like open a thing in a new tab or something?
12:29:59 <geekosaur> dminuoso, did you see what I said about SIGALRM? it sounds like this ioctl is blocking
12:30:13 <dminuoso> geekosaur: Yeah, Im still trying to process what you meant by it exactly
12:30:17 <dminuoso> And the ioctl is indeed blocking
12:30:32 <phibs> looks like U16 jus won't cut it: https://img.ethernet.cards/screenshots/user1/615B0Fe7e.png
12:30:38 <geekosaur> then after a few millisecondss it gets interrupted by SIGALRM and quits
12:30:52 <sm[m]> tomsmeding: it's only in safari.. cmd-enter opens https://paste.tomsmeding.com/paste in a new tab. In brave it works
12:31:17 <sm[m]> also I see no effect from tapping "toggle highlighting" in either browser
12:31:29 <dminuoso> geekosaur: So what are my options?
12:31:46 <geekosaur> basically, the RTS is woken up by SIGALRM every couple hundred milliseconds (see +RTS -Vn) to check for GC, profiler ticks, etc.
12:31:56 <tomsmeding> sm[m]: yeah I bound cmd-enter to submit the form, and the form is set up to submit with a POST to /paste; so I think cmd-enter is overrided by safari to do *something* in a new tab? I'm not sure exactly what happens
12:32:04 <geekosaur> but there's no way to send it only to the RTS, it goes to the whole process.
12:32:45 <geekosaur> I don't recall how you deal with blocking calls off the top of my head, it's been too long
12:32:53 <geekosaur> oh, check safe vs. unsafe
12:32:54 <sm[m]> tomsmeding: me either. It's fine in safari on a mac
12:33:13 <monochrom> But "safe" is already the default.
12:33:14 <sm[m]> (and toggle highlighting works on the mac)
12:33:57 * tomsmeding thought toggle highlighting should work everywhere, is there a place where it doesn't?
12:35:21 <monochrom> Some kind of standard practice is "check return value, if -1, then further check errno, if EINTR, then make the syscall again"
12:35:59 <geekosaur> but then you need some indication of how long to make the repeat, and it'll result in rapid flickering in this case
12:36:18 <dminuoso> geekosaur, monochrom: Well Im already marking the ffi function as unsafe (this is in principle fine, since this ioctl will never call back into haskell), but to no avail.
12:36:21 <monochrom> Why does this one block?
12:36:29 <geekosaur> what really needs to be done is blocking SIGALRM, but then the RTS may malfunction since it's not expecting to be blocked
12:36:51 <geekosaur> dminuoso, actually that's the problem then
12:36:54 <dminuoso> monochrom: Well this one because it blocks until the blinking is done. Another subcommand may take several hundred milliseconds to copmlete, because it dumps an EEPROM over really slow connections.
12:37:28 <geekosaur> this is not well documented, but "unsafe" also means "doesn't block" and sme other things related to threading iirc
12:37:41 <geekosaur> carefully read the part of the ghc manual about FFI
12:38:03 <monochrom> "unsafe" is intended for when you know the ffi call returns very quickly and so you judge that the overhead of "safe" and its nice safety is unnecessary, e.g., sin().
12:38:36 <dminuoso> geekosaur: Argh! I realized what went wrong then!
12:38:39 <tomsmeding> sm[m]: also: how are you managing to hit the command key on an ipad? do you use a custom keyboard, or an external keyboard perhaps?
12:38:43 <dminuoso> I need it safe *and* the threaded runtime.
12:38:51 <dminuoso> That combination did the trick.
12:38:52 <geekosaur> yes
12:38:56 <monochrom> Ah OK.
12:39:04 <dminuoso> geekosaur: Thanks, the manual is really confusingly phrased in the FFI sections. :)
12:39:13 <monochrom> http://www.vex.net/~trebla/haskell/ghc-conc-ffi.xhtml
12:39:16 <geekosaur> ghc hq doesn't actually support non-threaded runtime, it turns out
12:39:34 <monochrom> Mine is very clear. :)
12:40:05 <geekosaur> or perhaps I should say they don't like it much, and it has various badly documented shortcomings as a result
12:40:27 <monochrom> Ah but if you intend "I only have one thread anyway" it is not clear that you still want -threaded
12:40:41 <dminuoso> geekosaur: Presumably with threaded, the blocking code runs in a some thread, and the SIGALRM is handled by some other thread?
12:40:51 <dminuoso> (Such that the blocking code will not get interrupted)
12:41:03 <geekosaur> you still do, but you need to read carefuly about the I/O manager in that case because it still uses threads even without -threaded
12:41:43 <dminuoso> Okay, where should I go look for details on all of this? I feel the GHC user guide has left alone.
12:42:06 <geekosaur> but the rest of the code won't deal properly in that case with exceptions in I/O threads, whereas a "safe" FFI call gets handed off to one of the I/O manager threads
12:42:06 <juliusdeane> a question (revised to show definitions): https://paste.tomsmeding.com/LquiEztR
12:42:52 <geekosaur> (this is all on unix; windows only has the start of an I/O manager in 9.1 I think)
12:43:41 <geekosaur> but ask someone with ghc on windows experience in that case, I'm on very shaky ground there
12:43:53 <geekosaur> still, ioctl suggests unix :)
12:45:32 <dminuoso> This is all linux only
12:46:08 <geekosaur> if I ever manage to get myself situated reasonably (and in particular if I can manage to get a haskell jobâ€¦) I want to start documenting some of this stuff better, since right now it's a pain to track all this stuff down
12:47:45 <geekosaur> also for your earlier question I don't recall how it deals with the signal; you unfortunately can't block a signal only in one thread on unix/POSIX, and the OS delivers the signal by picking a running thread and sending it there or otherwise waking up a quasi-random thread
12:48:14 <geekosaur> signals and multithreaded really don't go together well on posix
12:48:47 <dminuoso> That suggests Im playing roulette here.
12:49:38 <geekosaur> it does something to get it right, I just don't know what off the top of my head and it's been years since I went through the relevant part of the I/O manager
12:49:39 <dminuoso> Oh haha, it's even better! POSIX specifies the thread selection is arbitrary.
12:49:44 <dminuoso> This is mad
12:49:51 <monochrom> Ah, every thread can has its own sigmask
12:50:10 <geekosaur> it has to do something, since otherwise it'd have to block the whole process â€¦ that, I guess
12:50:56 <geekosaur> also explains why it only works with -threaded
12:51:15 <tomsmeding> sm[m]: I have no idea what the ipad is doing, sorry :p
12:51:44 <tomsmeding> also fear it's something the webpage can't easily control, though I may be wrong
12:53:43 <sm[m]> tomsmeding: yes I'm using apple's keyboard attachment
12:54:01 <monochrom> It sounds like if your thread masks a signal, the kernel won't choose your thread.
12:55:58 <tomjaguarpaw> c
12:57:04 <dminuoso> geekosaur: So something worries me. If an unsafe call marks a call to be non-interruptible by the RTS, how can code function if a SIGALRM fires right in the middle of an unsafe FFI call?
12:57:59 <geekosaur> the handler returns instead of aborting, and the OS resumes whatever was happening
12:58:13 <dminuoso> Why wont that happen with the ioctl though?
12:58:27 <geekosaur> (this differs for I/O-related syscalls; take a look at the documentation for poll() and friends)
12:59:03 <geekosaur> actually for all syscalls they abort with EINTR, and you have to be ready to resume them
12:59:20 <geekosaur> userspace code just gets resumed, so something like sin() will Just Work
13:00:13 <geekosaur> EINTR behavior actually depends on the OS, what I described is for Linux but FreeBSD auto-resumes some syscalls and some other unixlikes do other things.
13:00:58 <dminuoso> Well in case of a long blocking syscall this is a pointless excercise, when there's a SIGALRM on a timer. Say my task takes a second to complete, but I get signaled every 100ms, I can retry as often as I want, Ill never finish
13:01:01 <geekosaur> there's some limited ability to control this on some of them, with system-specific system calls or syscall options (special sigaction() flags on linux and freebsd, etc.)
13:01:07 <dminuoso> Mmmm
13:01:32 <sm[m]> @where+ FDAA Functional Design and Architecture, https://leanpub.com/functional-design-and-architecture
13:01:32 <lambdabot> I will remember.
13:01:56 <geekosaur> right, so in this case you just use sigmask() to bloick SIGALRM in the thread and unblock after making the ioctl call
13:02:12 <geekosaur> see sigmask and sigprocmask
13:02:26 <dminuoso> Ahh I see. 
13:02:51 <dminuoso> So this is equivalent to mask/unmask in haskell, where async exceptions correspond to signals.
13:03:04 <geekosaur> sorry, you just want sigprocmask
13:03:31 <geekosaur> yes, but yu can control each signal independently (except SIGSTOP and SIGKILL, per usual for POSIX)
13:03:49 <dminuoso> I suppose, I want the sigprocmask *either* way, whether I use threaded or not runtime, since I dont appear to have any assurance my thread doesn't get the signal
13:03:59 <geekosaur> whereasmask/unmask is all or nothing
13:04:04 <dminuoso> Right
13:04:53 <monochrom> sigprocmask? Shouldn't it be better pthread_sigmask?
13:05:05 <geekosaur> right, but do you want the whole program to block while the ioctl is running? then again if it's not threaded I guess you don't care. not sure how the RTS will respond to having been blocked for 10 seconds especially if it had other I/O going on in a different I/O manager thread
13:05:10 <geekosaur> probably
13:06:05 <geekosaur> (don't profile your program though, it will malfunction if the timer is blocked for 10s in the non-threaded runtime)
13:06:55 <dminuoso> I guess Ill make the library code parametrizable, such that the user can decide whether or not calls will be wrapped in say pthread_sigmask, EINTR retry logic, or.. nothing I guess?
13:07:26 <dminuoso> It's interesting because it's the first time I've seen this consideration.
13:08:38 <juliusdeane> I've got a kinda complicated question; the code for everything is in this paste: https://paste.tomsmeding.com/LquiEztR
13:08:51 <dminuoso> And of course, using pthread_sigmask requires bound threads
13:09:20 <geekosaur> that's fine, the I/O manager threads should be bound specifically for this reason
13:09:54 <geekosaur> and to allow FFI code to use TLS etc.
13:11:12 <geekosaur> basically they're dedicated OS threads, which is what is intended by "bound" for Haskell threads
13:12:22 <dminuoso> "All foreign exported functions are run in a bound thread (bound to the OS thread that called the function)"
13:12:36 <dminuoso> Ah but that wont help me I guess.
13:12:51 <dminuoso> geekosaur: I cant find documentation hinting that the IO manager is a bound thread though.
13:13:18 <geekosaur> it's implicit, because the I/O manager isn't really running Haskell as such
13:14:02 <geekosaur> so they're best thought of as raw OS threads instead of as Haskell threads to which "bound" applies
13:14:22 <dminuoso> Fair enough
13:15:22 <geekosaur> stil there should be a discussion of TLS with respect to FFI somewhere in the manual, I think. (at least I hope it's not a ghc commentary Note...)
13:15:26 <dminuoso> https://mail.haskell.org/pipermail/glasgow-haskell-users/2010-September/019147.html
13:16:51 <dminuoso> geekosaur: By the way, regarding IO manager, does forkOS create a separate IO manager in a newly bound thread?
13:17:45 <geekosaur> no, everything uses the same I/O mnager. But I think forkOS gets you a new thread in the I/O manager dedicated to any FFI calls it makes, so TLS works
13:18:27 <geekosaur> (er, perhaps I should specify since the acronym is overloaded: thread local storage in pthreads)
13:19:07 <mmaruseacph2> question: if I forgot my Hackage password and the reset form does not work, whom should I contact?
13:19:17 <dminuoso> Heh, I was scratching my head quite hard about that one, what IO manager and bound threads had to do with transport layer security.
13:20:32 <geekosaur> it does if you're using an FFI binding to e.g. openssl, since the calls could block :)
13:20:58 <dminuoso> Indeed
13:21:38 <dminuoso> The one thing I dont quite understand in this, is what the IO manager has to do with anything. Let's say I call into pthread_sigmask in some IO action. What actual thread will that get executed in?
13:22:26 <dminuoso> Presumably, this pthread_sigmask will not be executed from the IO manager, but whatever thread Im in
13:22:28 <geekosaur> the way the I/O manager matters here is that, when you make a "safe" FFI call, a dedicated I/O manager thread is used to run the FFI call
13:22:34 <dminuoso> Ah.
13:23:29 <geekosaur> and each bound thread (the main thread is implicitly "bound") has its own dedicated thread so things like this and thread local storage work as expected
13:25:23 <dminuoso> From what I gather, I should have something like `runInBoundThread (maskSigAlrm (ioctl ...))`
13:25:56 <dminuoso> where maskSigAlrm = bracket_ ...
13:26:26 <dminuoso> Is this summary correct?
13:26:32 <geekosaur> hm, you're just wrapping ioctl as is? I tend not to do that because ioctl() takes weird parameters in general, but I guess for a one-off it's not a problem
13:27:18 <dminuoso> Yeah. Well, my library is split into two halves. One maps all sub commands exposed by a single ioctl fairly directly, and then the other half provides a simple abstraction ontop of it.
13:27:34 <dminuoso> The first half is done
13:27:37 <geekosaur> I don't think bracket_ helps much here since the signal wouldn't be converted to an exception
13:28:05 <dminuoso> geekosaur: Oh no, I meant `maskSigAlrm = bracket_ (pthread_sigmask ...) (pthread_sigmask ...)`
13:28:08 <dminuoso> If that makes sense
13:28:28 <geekosaur> oh, that should work, yes
13:29:02 <dminuoso> And the runInBoundThread seems relevant
13:29:17 <dminuoso> Because otherwise I wouldn't have the guarantee of running in the same actual posix thread
13:29:31 <dminuoso> (Though this is just guessing and handwaving)
13:29:33 <geekosaur> I'd feel safer doing it all in one chunk of C, but that's just me since I don't know what happens with even a little bit of Haskell code running, no SIGALRM, and -V0 not in effect
13:29:53 <geekosaur> you should have that guarantee if you're not otherwise threaded, remember the main thread is bound already
13:30:07 * geekosaur is going to have to go soon, sadly
13:30:20 <dminuoso> Thank you very much, geekosaur. You have been incredibly helpful with your wealth of knowledge.
13:30:30 <geekosaur> but if this is to be a library for general use by others then yes, you probably want a bound thread for it
13:30:37 <dminuoso> If you ever make your way into the lands of Hannover, let me know. My fridge filled with craft beer is at your disposal.
13:31:23 <sm[m]> tomsmeding: I was wrong, toggle highlighting works fine in ipad-safari. Probably I had network trouble, I didn't expect it to round-trip
13:31:54 <tomsmeding> oh right, turning off highlighting reloads the page due to an excessive amount of laziness from my side
13:32:24 <tomsmeding> essentially, to turn off highlighting without reloading means I need to store the un-highlighted text somewhere in memory, and I don't do so
13:32:36 <tomsmeding> so highlighting is irreversible, which is why I reload to turn off highlighting :p
13:32:53 <tomsmeding> I didn't care because I expect toggling to be such an infrequent operation that it doesn't really matter
13:33:18 <sm[m]> yeah, why can you even do that
13:33:33 <tomsmeding> why can I even do what?
13:33:37 <tomsmeding> toggling
13:33:38 <tomsmeding> ?
13:33:40 <sm[m]> toggle highlighting
13:33:48 <tomsmeding> because I gathered that some people like their pastes without highlighting
13:33:58 <tomsmeding> just like there are people that program without syntax highlighting
13:34:17 <monochrom> Nah, I think everyone here is OK with highlighting.
13:35:09 <tomsmeding> I guess I can remove the code for toggling, but it's literally about 25 lines of client JS code
13:35:13 <sm[m]> I do like a 100% raw view on pastebins, but toggling highlighting on and off on the pretty page I haven't felt a need for. Was curious if there was one
13:35:30 <tomsmeding> right, having a /raw might be a useful feature
13:35:54 <tomsmeding> though I'm not sure how to design that with multiple files
13:36:07 * sm[m] finds a workaround for keyboard entry in ipad safari: shift-tab to the filename field, hit enter
13:36:26 <sm[m]> tomsmeding: oh true, you'd have to concatenate them with a separator or something
13:37:05 <tomsmeding> that enter in the filename field triggers regular form submit behaviour in the browser, I think
13:37:15 <sm[m]> yup
13:37:18 <tomsmeding> or have a raw link per file
13:37:25 <tomsmeding> and/or
13:37:38 <sm[m]> tomsmeding: I just had a look at the source, it's quite refreshing to see only one directory :)
13:37:42 <maerwald> Nah, raw takes an int, which is file index sorted. If omitted, it's the first file
13:37:57 <tomsmeding> I like my simple source trees :)
13:38:01 <sm[m]> easy to contribute
13:38:02 <tomsmeding> maerwald: that's what I was thinking
13:47:14 <tomsmeding> sm[m]: # update is online https://paste.tomsmeding.com/zscQ2h6N
13:48:40 <sm[m]> thanks! of course now I'm thinking of alternatives
13:50:31 <sm[m]> with one unnamed file, don't show any filename; with multiple files, show the file number as filename where needed
13:51:50 <sm[m]> mustache seems nice
13:52:11 <tomsmeding> I think it's still useful to show the filename in case of a single file, if only because it gives me a spot to put the [raw] link (i.e. right-aligned on the same line) :p
13:52:37 <tomsmeding> is the file number useful?
13:53:42 <sm[m]> maybe not
13:54:32 <sm[m]> maybe
13:57:18 * hackage yesod-auth-oauth2 0.6.1.4 - OAuth 2.0 authentication plugins  https://hackage.haskell.org/package/yesod-auth-oauth2-0.6.1.4 (PatrickBrisbin)
13:57:51 <maerwald>  what about server-side highlighting
13:59:48 * hackage yesod-auth-oauth2 0.6.1.5 - OAuth 2.0 authentication plugins  https://hackage.haskell.org/package/yesod-auth-oauth2-0.6.1.5 (PatrickBrisbin)
14:00:48 * hackage little-rio 0.2.0 - When you need just the RIO monad  https://hackage.haskell.org/package/little-rio-0.2.0 (ejconlon)
14:01:56 <tomsmeding> maerwald: that would remove the need for JS to view pastes with highlighting, true
14:03:34 <maerwald> Can I paste via curl?
14:04:45 <tomsmeding> you can, kind of
14:05:09 <sm[m]> I like termbin's method
14:05:19 <tomsmeding> warning untested: curl -d "code1=$(cat file.hs)" https://paste.tomsmeding.com/paste
14:05:34 <tomsmeding> eh that's going to fail horribly
14:05:37 <tomsmeding> don't do that
14:05:43 * dminuoso does that
14:05:50 <tomsmeding> answer no because you need to url encode the file :p
14:05:54 <maerwald> Compare with http://sprunge.us/
14:05:56 <monochrom> The temptation... :)
14:06:02 <tomsmeding> I don't support multipart forms yet
14:06:09 <dminuoso> Indeed, who knows what will break on tomsmeding's side.
14:06:20 <tomsmeding> well, you can, but depending on how many & and = the file contains, some stuff will go wrong
14:06:26 <tomsmeding> the _server_ should not break though
14:06:34 <monochrom> Is "=<-" a curl syntax?
14:06:39 <tomsmeding> so feel free to test if you wish :p
14:06:46 <tomsmeding> um, no, why?
14:07:28 <sm[m]> this is the only active haskell pastebin I think, so better make it bulletproof before Hacker New arrives
14:07:39 <ang_> hello, is a binary search tree a functor?
14:08:03 <monochrom> Ah, curl man page explains the < syntax.
14:08:10 <Rembane> ang_: It could definitely be an instance of functor. 
14:09:06 <monochrom> If you also ignore the "search" part.
14:09:15 <tomsmeding> right so technically, curl -d "name1=&code1=$(imaginary-urlencoder <file.hs)" https://paste.tomsmeding.com/paste should work
14:09:47 <tomsmeding> sm[m]: the server should not break (feel free to test!), but command-line pasting is less than ergonomic
14:09:54 <tomsmeding> which is orthogonal to "bulletproof" IMO
14:10:10 <maerwald>  make it simpler
14:10:16 <sm[m]> certainly, I just meant can the server keep serving no matter what
14:10:39 <sm[m]> needs erlang OTP supervision tree
14:11:03 <sm[m]> must be web scale by end of day :)
14:11:17 <monochrom> Yeah, microservice...
14:11:34 <monochrom> also, cat pics
14:11:43 <ang_> if i can map over a bst and produce an invalid bst, that has something to do in be a functor?
14:11:55 <monochrom> Yes.
14:11:59 <tomsmeding> http://www.mongodb-is-web-scale.com/
14:12:10 <maerwald> Pastebin is such a nice task to get some backend knowledge and try out stuff
14:12:14 <dminuoso> ang_: To test validity of functor in Haskell its easy:
14:12:15 <monochrom> Note the oxymoron in "invalid bst".
14:12:19 <tomsmeding> maerwald: what do you suggest for "simpler"?
14:12:23 <dminuoso> ang_: does `fmap id` change the tree?
14:12:29 <ang_> no
14:12:35 <dminuoso> Then it's a valid functor.
14:12:44 <maerwald> I dunno, see the link I posted
14:12:50 <dminuoso> The other functor law comes as a free theorem.
14:12:57 <dminuoso> Prove one get two for free!
14:13:06 <ang_> so the thing that i can map and produce an invalid bst has nothing to do to be a functor right?
14:13:27 <monochrom> Gosh. I give up.
14:17:03 <tomsmeding> TIL -F in curl, curl has too many features
14:17:44 <tomsmeding> so yes the =<- is syntax for curl, kind of, except that it's -F specfic and the < means "read from file" and the - is stdin
14:20:06 <tomsmeding> okay so basically if I support multipart form data, there are plenty of options using curl
14:21:35 <tomsmeding> oh you can already do it now!
14:22:07 <tomsmeding> $ curl -v -d 'name1=display-filename.txt' --data-urlencode 'code1@file-with-data.hs' https://paste.tomsmeding.com/paste
14:22:26 <tomsmeding> set name1 to empty for no filename, and repeat with name2/data2 etc for multiple files
14:22:46 <sm[m]> I quite like this script, https://paste.tomsmeding.com/pYmRAwgJ
14:23:05 <tomsmeding> only missing feature is the server giving the paste URL in the redirection response, which makes the -v unnecessary
14:23:46 <tomsmeding> sm[m]: directly writing to a socket is also a way :p
14:26:12 <sm[m]> basically being able to pipe into a command and clip the url is great. Example workflow: select region in emacs, M-| pastebin, switch to irc window, CMD-v
14:27:57 <sm[m]> of course, if haskell-pastebin auto-announced here it's even easier
14:28:42 <tomsmeding> sm[m]: how about: $ curl -v -d 'name1=' --data-urlencode 'code1@/dev/stdin' https://paste.tomsmeding.com/paste
14:28:45 <tomsmeding> that reads data from stdin :)
14:29:21 <tomsmeding> it just doesn't output the url (you have to read it from the Location: header currently), but I'm working to fix that
14:29:25 <tomsmeding> though snap is not cooperative
14:34:05 <dolio> ang_: If your type is supposed to be the type of BSTs, but fmap can produce something that isn't a BST, then fmap is unsound.
14:35:50 <tomsmeding> sm[m]: there are now raw links on paste read pages, and you can paste from the terminal with the following command:
14:35:59 <tomsmeding> $ curl -d 'name1=' --data-urlencode 'code1@/dev/stdin' https://paste.tomsmeding.com/paste
14:36:08 <tomsmeding> it will output the URL to the paste on stdout
14:40:48 <tomsmeding> signing off for today, see you later :)
14:42:01 <thorn__> howdy, im getting an error about duplicate instance declarations between beam-postgres tests and Hedgehog.Internal.Property when I try to compile, and im not sure how to go about resolving this, any ideas?
14:44:44 <c_wraith> sounds like a bad version bound, assuming one of them depends on the other
14:45:06 <ang_> thx dolio
14:48:27 <thorn__> its failing when i use a cabal file with only beam-postgres in it, on NixOS with beam-postgres 0.4.0.0
14:58:56 <c_wraith> that definitely makes it sound like a bad version bound.
14:59:21 <c_wraith> Either something is too permissive, or something added an instance without updating its version correctly
15:09:48 * hackage little-rio 0.2.1 - When you need just the RIO monad  https://hackage.haskell.org/package/little-rio-0.2.1 (ejconlon)
15:21:49 * hackage configurator-pg 0.2.4 - Reduced parser for configurator-ng config files  https://hackage.haskell.org/package/configurator-pg-0.2.4 (vollmert)
15:23:47 <kiwi81> If I have rem1 :: Eq a => [a] -> a -> [a] ; rem1 [] y = [] ; rem1 (x:xs) y = if x == y then xs else x : rem1 xs y, how would this be altered if I were to instead use rem1 :: Eq a => [a] -> [a] -> [a]?
15:26:34 <dmwit> That depends a lot on what you want it to do.
15:27:05 <dmwit> ?src (\\)
15:27:06 <lambdabot> (\\) = foldl (flip delete)
15:27:21 <dmwit> That would be one choice for how to alter it.
15:27:57 <thorn__> im getting really frustrated trying to use stack, feels like such a block towards trying to build anything, is there something that can eli5 how to add a dependency? im stuck in a constant loop of `stack build` and then spending 30 minutes copying out the reccomended actions to the yaml file, only for it to happen again and then complain at me when i need to change base to a lower version
15:28:28 <thorn__> im sure im doing something wrong i just dont know what
15:28:41 <kiwi81> more or less the same, if I insert "abab" 'a' into the first string it'll remove the first a, I want to insert "abab" "ab" = "ab" 
15:28:56 <kiwi81> Tried using the aforementioned code earlier, didn't seem to work
15:29:24 <dmwit> What if you pass the arguments "aa" "aa"? Should you get back "a" or ""?
15:29:49 <dmwit> What if you pass the arguments "ab" "ba"? Should you get back "a" or ""?
15:31:16 <kiwi81> "abcd" "ba" == "cd", "abba" "ab" == "ba" and soforth
15:32:47 <dmwit> Oh, I have even another variant: What if you pass the arguments "acbab" "ab"? Should you get back "acb" or "cab"?
15:34:03 <kiwi81> if you called the first element as and the second bs, so as = "abcd" and bs = "ba", it should remove the first bs from as, if that makes it any clearer
15:34:54 <kiwi81> so basically, the first a and the first b should be removed if it says "ba" in bs
15:35:34 <kiwi81> "abcd" "ba"  thus becomes "cd"
15:36:40 <kiwi81> so in your variant, it should be "cab"
15:36:43 <dmwit> It doesn't make it clearer, no. I asked very specific questions. (I also gave you an answer that is almost certainly for the variant you are thinking of, just in case.)
15:37:28 <dmwit> Okay, thanks. That answers questions 1 and 3, I believe. What about question 2, "ab" "ba"?
15:38:30 <kiwi81> oh shit, didn't see that sorry
15:38:53 <kiwi81> It should become "" in that case
15:39:04 <dmwit> Okay. Then (\\) is what you want.
15:39:19 <kiwi81> Okey, cheers mate 
16:24:49 <dmwit> I wonder if the free theorem for that type + those input examples are enough to make (\\) the only possible implementation.
16:25:35 <dmwit> Oh, of course not, it could do plenty of other things, say, when the input lists are both longer than 10.
16:44:18 * hackage org-mode-lucid 1.5.0 - Lucid integration for org-mode.  https://hackage.haskell.org/package/org-mode-lucid-1.5.0 (fosskers)
17:44:19 <sm[m]> is writeFile strict ? in the sense that a readFile immediately following it will always see the new content ?
17:53:03 <c_wraith> should be
19:15:49 <srid> Does anyone have the link to the haskell discord channel ? Cale ?
20:10:21 <thorn__> whats the correct way to add a depedency to a stack project? im getting a lot of conflicting information, and the user guide isnt working for my package i want to add
20:20:18 * hackage shake-futhark 0.1.0.2 - Dependency tracking for Futhark  https://hackage.haskell.org/package/shake-futhark-0.1.0.2 (vmchale)
20:26:36 <thorn__> i got it to build and now its failing due to not being able to find pg_config, although pg_config is in my (non-sudo) path
20:42:11 <Cale> srid: which Haskell discord are you looking for a link to?
20:43:32 <srid> Cale: the one you are writing to ðŸ˜€ 
20:44:15 <Cale> srid: I mostly use discord for chatting about music theory
20:44:40 <Cale> But I'll send you an invite link to Emily's discord
21:04:19 * hackage shh 0.7.1.0 - Simple shell scripting from Haskell  https://hackage.haskell.org/package/shh-0.7.1.0 (lukec)
21:55:49 * hackage swiss-ephemeris 0.3.0.0 - Haskell bindings for the Swiss Ephemeris C library  https://hackage.haskell.org/package/swiss-ephemeris-0.3.0.0 (lfborjas)
22:40:48 * hackage ref-extras 0.2.0 - Extra stuff for mutable references  https://hackage.haskell.org/package/ref-extras-0.2.0 (ejconlon)
23:59:16 <Saten-san> https://dpaste.com/AR9WGA5TQ
23:59:45 <Saten-san> Why does this not work? I want to take a list of pair tuples followed by two integers as input.
