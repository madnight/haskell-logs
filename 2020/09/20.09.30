00:03:59 <opqdonut> :t 3
00:04:01 <lambdabot> Num p => p
00:04:01 <Axman6> make an instance of Num
00:04:09 <sim590> Oh that's all :o
00:04:14 <opqdonut> especially the fromInteger method
00:04:30 <Axman6> "3" means "fromIntegral (3 :: Integer)"
00:05:48 <sim590> d:t fromIntegral
00:05:53 <sim590> :t fromIntegral
00:05:55 <lambdabot> (Integral a, Num b) => a -> b
00:06:15 <kritzefitz> Isn't it fromInteger?
00:06:23 <Axman6> probably
00:51:24 <kindaro> Suppose `main = interact (show @Int âˆ˜ read)`.â€‚How can I extend this program to operate on any of a variety of types, type name being given by user on command line?â€‚My aim is to write an echo server for use in automated checking of parsing and serialization, client being written in another language.
00:52:12 <opqdonut> haskell types disappear at runtime, so there's no direct way
00:52:36 <opqdonut> but you can do something like write an Enum for the supported types
00:52:59 <opqdonut> or something even fancier with singletons or some other type-level trickery
00:55:38 <lortabac> probably the simplest way is to pattern-match on the user-provided string
00:56:05 <lortabac> it doesn't require any advanced feature
00:56:50 <kindaro> Imagine I have a 50 types large variety.â€‚Some case expression!
00:56:53 <lortabac> or to parse to an enum, and pattern-match on it
00:58:03 <tomsmeding> kindaro: would you want to allow the user to enter any haskell type? What about "IO ()"? :)
00:59:24 <kindaro> No, only those in a specified variety.â€‚If a type is not supported, I should respectfully decline.
01:00:57 <tomsmeding> then I guess if you're already making a list of the supported ones, well, you already have to write the list :)
01:01:27 <tomsmeding> doing it with Enum/Read/Show can help reducing the number of times you have to write that list, I guess
01:03:40 <lortabac> kindaro: maybe you can try to generate a big GADT with TemplateHaskell and a mechanical rule for parsing, but at some point you necessarily need to list all the types at least once
01:04:42 <lortabac> something like data CliType :: * -> * where Int :: CliType Int; Char :: CliType Char...
01:05:38 <kindaro> Suppose I want to support all types that are instances of `Show` that are in scope at the time of compilation.
01:05:58 <kindaro> I then need to get a list of such types and build a case expression.
01:07:11 <tomsmeding> "all types that are instances of `Show`" sounds nice but is not something that Haskell lets you query easily
01:07:54 <tomsmeding> not even sure if TemplateHaskell will get you that
01:09:00 <tomsmeding> oh it does
01:09:15 <tomsmeding> ooooooh that is decidedly ugly
01:09:43 <kindaro> Can you give me some links?
01:13:19 <tomsmeding> just checking myself if it will work at all, but https://hackage.haskell.org/package/template-haskell-2.16.0.0/docs/Language-Haskell-TH.html#v:reifyInstances
01:13:58 <lortabac> kindaro: there are a couple of ugly solutions for that, though I would never use them for real
01:14:10 <lortabac> @hackage constraints-emerge
01:14:10 <lambdabot> https://hackage.haskell.org/package/constraints-emerge
01:14:50 <kindaro> Oh, this is cute!
01:14:52 <lortabac> https://github.com/rampion/constraint-unions
01:16:48 <kindaro> I recall passing explicit dictionaries is being considered for GHC: https://github.com/ghc-proposals/ghc-proposals/pull/324
01:18:50 <tomsmeding> kindaro: import Language.Haskell.TH ; import Language.Haskell.TH.Ppr ; putStrLn $( LitE . StringL . pprint <$> reifyInstances ''Show [ VarT (mkName "a") ] )
01:18:55 <tomsmeding> that prints stuff :p
01:19:15 <tomsmeding> presumably if you know a bit more about templatehaskell you can make that work somehow?
01:33:53 <kuribas> what is wrong with clojure guys absolutely having to bash haskell to show their language?  https://lispcast.com/user-wizard-scenario/
01:34:13 <merijn> kuribas: Insecurity
01:34:46 <merijn> Nothing illustrates your point as well as a strawman the size of the wicker man...
01:35:04 <kuribas> merijn: if they are happy with their language, why not just use it?
01:35:33 <merijn> kuribas: Because they feel insecure about using it and need to justify the superiority :p
01:35:48 <merijn> That's like 90% of all "language X sucks, look at language Y" advocacy
01:35:54 <kuribas> it's not like haskell is perfect
01:35:59 <merijn> Unless is C or C++, then it's just truth
01:36:05 <kuribas> lol
01:36:10 <merijn> s/Unless/Unless X/
01:36:11 * tomsmeding X doubt
01:36:51 <kuribas> I am perfectly fine with bashing haskell, but their criticism makes no sense.
01:37:11 <merijn> kuribas: Of course, because they don't know haskell enough to make a coherent criticism
01:37:28 <merijn> Just look at their silly 8 alternatives for partial validation
01:37:38 <kuribas> I don't see other lisp guys do this, like common lisp or scheme.
01:37:46 <kuribas> merijn: you mean spec?
01:37:51 <merijn> There's much more elegant approaches using higher kinded types
01:38:03 <merijn> kuribas: Now, the literaly example in your link
01:38:51 <merijn> kuribas: https://paste.tomsmeding.com/yy3PqZUb
01:38:56 <tomsmeding> kuribas: that article is hilarious
01:39:01 <merijn> As if any self-respecting Haskell programmer would write that
01:39:10 <kuribas> yeah :)
01:39:16 <merijn> That shit is begging for a digestive-functor/applicative validation so badly
01:39:31 <tomsmeding> it's basically saying: clojure is cool because it doesn't have the tools to give you type safety
01:39:36 <tomsmeding> I mean, you can get the exact same in haskell
01:39:39 <tomsmeding> they even did that in the article!
01:39:41 <merijn> Like, Validation obsoletes their entire argument
01:39:52 <tomsmeding> it's literally not an argument against haskell or for clojure
01:40:09 <tomsmeding> only argument being made is that haskell is more flexible, apparently? (I don't know clojure so can't confirm/deny)
01:40:20 <merijn> kuribas: Lisp/scheme programmers don't feel compelled to "prove" themselves because they've got history/legacy
01:40:42 <tomsmeding> merijn: yes that example cracked me up too
01:41:05 <merijn> kuribas: Clojure is "the new kid" of lisps and so they feel compelled to justify it being better than Scheme/Lisp by picking silly fights like thise
01:41:41 <kuribas> merijn: or just a record with Maybes?
01:42:10 <tomsmeding> well they discarded that because it wasn't flexible enough for the frontenders, right?
01:42:24 <merijn> kuribas: Really just anything but what they actually did
01:42:33 <kuribas> tomsmeding: yeah, most stuff with hashmaps can be done in haskell with records.  Except for merging, but that's dodge anyway.
01:43:00 <tomsmeding> except adding new fields at runtime
01:43:04 <tomsmeding> which they wanted apparently
01:43:32 <merijn> which is a dumb thing to want anyway :p
01:43:47 <kuribas> https://gist.github.com/kuribas/8afd49cf87fe5b1c32b1009ab59c4b1d
01:43:56 <tomsmeding> article makes the case that it isn't, but that isn't even the problem
01:45:15 <kuribas> tomsmeding: this does exactly what they want, you can add fields easily, and change the order of processing.
01:45:23 <kuribas> just swap the guards
01:45:31 <tomsmeding> not as easily as they want, right?
01:45:45 <kuribas> what do they want then?
01:45:50 <tomsmeding> they didn't want to change the backend code to add fields, or didn't I read the article closely enough (likely)
01:46:21 <tomsmeding> > "We [backend team] required a description of the field and its type, and it would be deployed in the next release after we got to it. The front-end team needed to cycle faster than that."
01:46:23 <lambdabot>  "We [backend team] required a description of the field and its type, and it ...
01:46:33 <tomsmeding> lambdabot: you're not wrong
01:46:57 <kuribas> tomsmeding: that sounds like a social problem
01:47:09 <tomsmeding> which, also, isn't even the point
01:47:12 <tomsmeding> perhaps it is!
01:47:17 <kuribas> tomsmeding: but even then, with a proper pipeline, such a change and recompiling takes 5 minutes in haskell.
01:47:24 <tomsmeding> true
01:47:38 <tomsmeding> but, like, perhaps their organisation makes that they don't want that
01:47:50 <tomsmeding> maybe they have a mandatory QA process for every backend upgrade or something
01:48:02 <tomsmeding> but if they want to iterate without the backend changing, then, well, design your backend on that :p
01:48:08 <tomsmeding> haskell gives you the flexibility
01:48:25 <tomsmeding> anyhow the point is argued perfectly by the article itself so perhaps I should stop ranting :p
01:48:47 <AWizzArd> I am writing an app and use Nix as build system. I would like to specify four things: what Haskell-Dependencies do I want to be in my release? What Haskell-Deps do I want to have during development time (i.e. benchmarking, tests, ...). And then I want to specify what OS-Deps I want during development in my nix-shell (ls, cd, cat, tree, ...) and what OS-Deps I want to be in my release (which can go into a tar.gz for dockerization).
01:48:48 <cpressey> Doing data modelling like FirstAndLastNames, FirstNameAndEmail, LastNameAndEmail, ... is ridiculous *in any language*. I want to say "obviously ridiculous" but the very existence of the article makes me wonder about that.
01:48:54 <merijn> It's just one of the classic blunders
01:49:09 <merijn> "Tying your external representation directly to your internal representation"
01:49:10 <AWizzArd> I see https://github.com/NixOS/nixpkgs/blob/master/pkgs/development/haskell-modules/generic-builder.nix and there are tons of "Depends" attributes listed
01:49:17 <kuribas> tomsmeding: in that case I would have a personFields field which is just a Aeson Value.
01:49:32 <merijn> That's just as bad as "starting a land war in China" or "going against a Sicilian when death is on the line"
01:49:51 <AWizzArd> What is the meaning of buildDepends, libraryHaskellDepends, executableHaskellDepends, libraryToolDepends, executableToolDepends, testToolDepends, benchmarkToolDepends, librarySystemDepends, executableSystemDepends, libraryFrameworkDepends, executableFrameworkDepends, testDepends, and the 50 others?
01:50:20 <merijn> Sounds like a Nix question?
01:52:25 <kuribas> merijn: in our app it's not only tied to the API, but also to the database.
01:52:51 <kuribas> merijn: hashmaps just pass through everything, with only a light layer of transformation between.
01:53:21 <merijn> kuribas: Every single time I've done that I've lived to regret it :p
01:53:35 <AWizzArd> merijn: a Nix question that is very Haskell related. As in: what flags can I pass to "ghc", which happens to be a Linux tool, but which is essentially not a #Linux question.
01:53:56 <merijn> I've learned to accept that the "boilerplate' of separate external and internal representations is worth it and inevitable
01:53:56 <maerwald> AWizzArd: imo still better to ask in the nix channel
01:54:11 <kuribas> merijn: however it's convenient in servant to write your records like the json objects.
01:55:12 <kuribas> merijn: or I would need two types, ExternalResource, and Resource
01:55:21 <merijn> kuribas: Yes
01:55:36 <lortabac> I think it is a good idea to have two types anyway
01:56:19 <merijn> kuribas: Eventually you'll come around to my and lortabac's way of thinking, after you've made yourself suffer enough :)
01:56:44 <kuribas> possibly
01:56:57 <kuribas> I adapt my code as the needs change
01:57:13 <kuribas> but clojure is a big bottleneck
01:58:08 <kuribas> with its inability to model the business domain, provide safe abstractions, and giving zero consistency garantees.
02:07:21 <kuribas> merijn: actually I already have more types for one resource.  Like a type for getting and setting information, a type with less fields, etc...
02:08:27 <kuribas> merijn: a clojurist would probably now grin in satisfaction, look at all that complexity!
02:08:34 <kuribas> merijn: but IMO it's worth it.
02:21:01 <sm[m]> there was no criticism or bashing in that article.. it's well written and interesting I think
02:21:38 <kuribas> sm[m]: the haskell code is pretty bad
02:22:38 <sm[m]> that's a silly thing to say, since they're just walking through a series of what ifs (pretty realistic thought process for someone figuring this stuff out)
02:24:03 <sm[m]> I think it shows haskell provides a lot of freedom to model your typing  needs
02:24:53 <kuribas> no, it fits perfectly in the clojure narative that types are too heavy and unnecessary.
02:26:05 <sm[m]> perhaps, but that doesn't make it it criticism or bashing, and I think you weaken your argument by saying so
02:26:47 <sm[m]> Just MHO
02:28:30 <kuribas> sm[m]: perhaps it was written in good faith, but the code is still bad.
02:28:45 <sm[m]> thanks for the link, I will watch for the HN discussion
02:29:22 <kuribas> sm[m]: btw, I don't believe in show the bad way first
02:30:24 <kuribas> You learn the best by looking at good examples.
02:30:58 <kuribas> Taking best ideas from everywhere and assimilating them into your own style.
02:31:04 <maerwald> kuribas: I agree, I had a prof who used to show every single pitfall of a language, when teaching a language and thought that would give ppl an intuition. All it did was confuse them
02:31:18 <kuribas> maerwald: right :)
02:31:29 <maerwald> the C++ course was...
02:31:40 <sm[m]> the article says that sometimes you want a more static model. So the first is not bad. Its just an engineering choice depending on the need.
02:32:41 <sm[m]> the article lays out some of the options nicely. You could just As easily read it in reverse, describing a refactoring of over dynamic code to more statically checked.
02:33:09 <kuribas> sm[m]: https://paste.tomsmeding.com/yy3PqZUb
02:33:15 <kuribas> sm[m]: that's not bad?
02:33:17 <merijn> sm[m]: The problem I have with it is that the static code is just a badly written strawman. You could easily have a static verbose that's both less verbose and more flexible
02:33:20 <sm[m]> afk, sorry
02:33:40 <merijn> sm[m]: And then using that bad code to justify the more dynamic approach
02:34:14 <kuribas> sm[m]: I am pretty sure he wouldn't write this kind of code in clojure.
02:34:32 <kuribas> sm[m]: I guess he is thinking about partial hashmaps.
02:34:34 <sm[m]> (maybe write a follow up showing more possibilities ? I'd read it!)
02:36:36 <kuribas> probably he was thinking about a clojure workflow, then putting haskell types on it.
02:36:42 <sm[m]> (Ps and yes that particular variant seemed bad for most needs Incan imagine, and I think they said so)
02:36:45 <kuribas> then concluding haskell types are way to heavy.
02:37:36 <sm[m]> gone
02:39:41 <ph88> hey guys .. i have this code    runReaderT (bla options) conf    when i put  flip in front  of it i get a bunch of type errors ... maybe i need another function then ??
02:40:46 <maerwald> (flip runReaderT) ...?
02:40:50 <[exa]> ph88: what does it look like with the flip in the front?
02:42:14 <kuribas> ph88: runReaderT conf $ bla options ?
02:42:26 <kuribas> ph88: erm flip runReaderT conf $ bla options ?
02:42:35 <kuribas> that should work
02:47:25 <[exa]> are there any operators around? ($ may break it)
03:16:25 <hc> [exa]: check #freenode for operators? ;p
03:17:30 <[exa]> hc: it was more like...any operators around that haskell expression :D
03:18:02 <hc> I know, just a silly joke :)
03:18:20 <[exa]> :]
03:24:17 <ph88> [exa], kuribas thank you  .. i see what i did wrong now ... i put   flip $ 
04:02:43 <p0a> Hello I have a type that has some fields, say data Foo = Foo { a,b,c :: Int }. Now I want a MaybeFoo that is like Foo except all fields are Maybe Int
04:03:11 <p0a> The idea is that I can search for Foo values in a list, equality == is only tested on the Just values
04:16:41 <merijn> p0a: You can just define Foo as "Foo f = Foo { a, b, c :: f Int }" and then use "Foo Identity" as the "default" and "Foo Maybe" for the second case?
04:18:51 <p0a> merijn: ah that's really nice, thank you 
04:19:00 <p0a> do you think 'f' is a good choice for that?
04:19:27 <p0a> This is probably irrelevant but I'm curious if there's a better suggestoin
04:20:26 <merijn> p0a: 'f' is just a variable (usually associated with Functors, hence the choice here)
04:20:42 <p0a> Got it, thank you 
04:21:30 <merijn> p0a: Here's a nice blogpost that involves slightly more complicated type machinery for an even fancier version of that: https://reasonablypolymorphic.com/blog/higher-kinded-data/
04:22:03 <merijn> p0a: In fact, they literally use a "Person" "MaybePerson" example :p
04:22:26 <p0a> Heh!
04:22:30 <p0a> That's awesome, thanks. I will read it 
04:25:02 <merijn> p0a: I'd personally probably skip the whole Generic boilerplate, because it's kinda complicated, but the first part is certainly very useful
04:25:37 <p0a> As I glanced over it 
04:25:41 <p0a> it got kinda scary towards the end 
04:25:58 <p0a> but if it is interesting I will read it
04:26:11 <merijn> p0a: You can simply not use the scary part :)
04:26:29 <merijn> p0a: The scary part is basically "using GHC Generics to avoid even writing the validate implementation"
04:26:49 <p0a> I see. I may not even need a validate myself
04:26:51 <merijn> p0a: You can just use the datatype with a manual written validation/whatever and it'll "Just Work"
04:26:54 <p0a> but we'll see, it depends on what the author is talking about 
04:27:06 <p0a> whoops, low battery... gotta go. Thank you again 
04:33:13 <kuribas> merijn: I prefer generics over higher kinded stuff
04:33:44 <kuribas> or better, eot, when you don't need the heavy stuff that comes with generics: https://hackage.haskell.org/package/generics-eot-0.4.0.1/docs/Generics-Eot.html
04:34:14 <merijn> kuribas: Those two don't even have the same usecase(s) so that seems like a weird comment
04:34:36 <merijn> Especially given the context of a blogpost using both for very different things
04:41:28 <maerwald> Is there a way to discover whether a thread is currently blocked?
04:49:28 <kuribas> merijn: yeah, the two aren't really related :)
04:50:04 <kuribas> merijn: I dislike the HKD approach, because it is rather messy, and usually not that hard to avoid.
05:08:48 * hackage hakyll 4.13.4.1 - A static website compiler library  https://hackage.haskell.org/package/hakyll-4.13.4.1 (JasperVanDerJeugt)
05:58:19 * hackage servant-serf 0.0.1 - Generates a servant API module  https://hackage.haskell.org/package/servant-serf-0.0.1 (goolord)
06:41:37 <motte> hi, i'm new to haskell and i would like to create a simple web server with basic access authentication. which library would best suit my needs?
06:41:56 <Uniaika> not Servant, whatever you might be told
06:42:04 <Uniaika> try Scotty and/or Yesod
06:42:22 <motte> huh, that's what i was looking at currently. what's wrong with it?
06:42:26 <Taneb> For this case I'd go scotty
06:42:27 <Uniaika> ah, if you want to *create* a web *server*, you might have to go at a lower level with Warp/WAI
06:42:48 <Taneb> servant is great if you want to have a large REST API. On the small, it's kind of got a lot of wasted power
06:42:53 <Uniaika> motte: you don't have the level/understanding of type-level programming to understand what you'll need to do in order to use it
06:42:58 <opqdonut> for a simple web server / backend, I'd just go with WAI & Warp directly
06:43:03 <Uniaika> just don't hurt yourself with Servant yet
06:43:26 <motte> the library should be as simple/minimal as possible, scalability isn't important etc.
06:43:41 <Uniaika> go with WAI and Warp then
06:43:44 <Uniaika> Godspeed!
06:43:58 <motte> alright, will check it out, thankss
06:44:09 <hc> lol, you don't need to understand any more type theory for servant than you do for getting along with warp/wai
06:44:42 <hc> I mean, servant is already implemented; there are good howtos on how to use it
06:45:12 <motte> oh, also, i plan to keep the credentials in a /etc/shadow -like text file. anything for that?
06:45:36 <Uniaika> hc: I did not mention type theory, I mentionned type-level programming - which is widely different
06:45:50 <Uniaika> at least type theory doesn't bring type error messages that are scary as shit
06:46:14 <Uniaika> motte: why don't you hash+salt them in a SQL row?
06:48:45 <motte> Uniaika: it's a pretty simple application, i don't think i need a database. just 1 configuration file for authorization and something for authentication
06:49:08 <Uniaika> well you can use a SQLite database if you don't want to bother with a DBMS :)
06:49:24 <Uniaika> I don't know if the /etc/shadow algorithm has an implementation in Haskell
06:49:25 <motte> i pretty much already have the whole thing implemented using mqtt, but then i realized i sometimes need to send responses as well
06:49:32 <Uniaika> that being said, it can be a fantastic side-project :P
06:50:01 <motte> in mqtt's case i let the broker deal with authentication
07:06:09 <kuribas> merijn: I was thinking to make a library to pre (post-) process aeson data before (after) parsing/generating.
07:06:24 <kuribas> merijn: to move around fields.
07:06:47 <kuribas> merijn: in the best case in a typesafe way (using generics).
07:06:48 <Uniaika> kuribas: aren't there already hooks to do that?
07:07:10 <kuribas> Uniaika: you mean a handwritten parser?
07:07:21 <Uniaika> no, hooks in Aeson
07:07:23 <Uniaika> wait a sec
07:09:28 <Uniaika> kuribas: https://hackage.haskell.org/package/aeson-1.4.6.0/docs/Data-Aeson.html#g:16
07:09:33 <Uniaika> option fields
07:09:54 <kuribas> Uniaika: they only change the strings
07:10:02 <kuribas> Uniaika: I want to reorder the JSON
07:10:12 <Uniaika> wait, re-order it?
07:11:10 <Uniaika> kuribas: that's tricky because objects are unordered while arrays are
07:11:20 <kuribas> yeah, like {"subfield": {"x": 1, "y": 2}} => {"subfield_x": 1, "subfield_y": 2}
07:11:40 <Uniaika> ah that's different
07:11:47 <Uniaika> p. sure you can operate on the AST
07:12:00 <Uniaika> although, to be fair, I would just use DTOs for that
07:12:19 <kuribas> Uniaika: of course I can do Value -> Value, but I want something more principled, composable, and bidirectional.
07:12:30 <Uniaika> and an explicit translation from the first (direct mapping of the object) to the second (better for my business logic)
07:12:46 <lortabac> kuribas: lens-aeson ?
07:13:11 <kuribas> lortabac: hmm, maybe an isomorphism?
07:13:46 <lortabac> oh, if you don't want Value -> Value then lens-aeson is probably not the right tool
07:16:54 <kuribas> well, maybe just Endo Value
08:05:05 <zincy_> Is there a name for this? You have a N x N matrix and have a set of instructions to update elements in the grid
08:05:29 <zincy_> startCol, endCol, startRow, endRow 
08:06:08 <zincy_> And a function to update each element
08:06:41 <zincy_> So you can compose transformations on given coordinates in the grid by sequencing instructions
08:09:36 <merijn> zincy_: Array comprehensions? :p
08:10:29 <zincy_> hehe
08:11:19 <merijn> zincy_: Kinda serious
08:11:21 <merijn> zincy_: http://www.sac-home.org/lib/exe/fetch.php?media=docs:tutorial.pdf
08:11:41 <merijn> See chapter 4 on with loops
08:12:51 <merijn> "tensor comprehensions" are also somewhat related
08:13:43 <zincy_> thanks!
08:14:30 <merijn> zincy_: The various SaC papers should also talk a bit about fusing stuff like that together
08:17:30 <[exa]> anyone on windows with working vscode integration?
08:23:28 <sm[m]> I'm on mac with working vscode & haskell exts..
08:31:23 <[exa]> well I'm searching for "something that works without much effort" for 3-4 windows students, and don't have any windows handy to play with it
08:33:36 <sm[m]> Stack + Vscode + haskell extension seems very likely the winner there
08:39:33 <maerwald> stack?
08:39:35 <maerwald> on windows?
08:39:43 <maerwald> it has outdated msys2
08:40:28 <maerwald> installing system dependencies requires dealing with pacman
08:40:48 * hackage polysemy-video 0.1.0.0 -   https://hackage.haskell.org/package/polysemy-video-0.1.0.0 (locallycompact)
08:41:38 <zincy_> merijn: SaC is cool, never heard of it before
08:42:58 <sm[m]> [exa] might let us know
08:46:09 <[exa]> yeah that's why I'm asking, they gave up on stack
08:46:20 <[exa]> b/c installing it failed for like 3 times
08:48:30 <lordcirth_> [exa], Win10? Wouldn't WSL be the best?
08:50:27 <[exa]> does that work with VS Code?
08:53:26 <lordcirth_> Probably?
08:56:31 <[exa]> hm okay :]
09:00:18 * hackage aeson-value-parser 0.19.3 - API for parsing "aeson" JSON tree into Haskell types  https://hackage.haskell.org/package/aeson-value-parser-0.19.3 (NikitaVolkov)
09:08:49 * hackage path-dhall-instance 0.1.0.1 - ToDhall and FromDhall instances for Path.  https://hackage.haskell.org/package/path-dhall-instance-0.1.0.1 (locallycompact)
09:10:19 * hackage polysemy-video 0.1.0.1 -   https://hackage.haskell.org/package/polysemy-video-0.1.0.1 (locallycompact)
09:13:18 * hackage path-dhall-instance 0.1.1.0 - ToDhall and FromDhall instances for Path.  https://hackage.haskell.org/package/path-dhall-instance-0.1.1.0 (locallycompact)
09:24:18 * hackage refinery 0.2.0.0 - Toolkit for building proof automation systems  https://hackage.haskell.org/package/refinery-0.2.0.0 (ReedMullanix)
09:50:20 <AWizzArd> Is there a study/statistics about unqualified imports? Such as `import Data.Text` without explicitly listing the FNs or Types we want.
09:50:49 <AWizzArd> Maybe somebody has analyzed/counted this on Hackage.
09:51:52 <AWizzArd> Also, how to import all constructors?   a) import Foo (Bar(..))   or  b) import Foo (Bar (..))      b has a space after `Bar`.
09:53:08 * ski 'd go for the space
09:54:03 <AWizzArd> ski: I also like b) with the space more.
09:59:45 <monochrom> I use (a)
10:00:19 <monochrom> Thank you for having a space after Foo though :)
10:01:34 <monochrom> It is not important at all but I like the consistently-having-a-space over both "import M (f)" and "import M hiding (f)", i.e., I wouldn't "import M hiding(f)".
10:12:13 <sm[m]> [exa]: hard to say more without details, but stack was having some net failures recently
10:39:18 * hackage base-compat 0.11.2 - A compatibility layer for base  https://hackage.haskell.org/package/base-compat-0.11.2 (ryanglscott)
10:40:18 * hackage base-compat-batteries 0.11.2 - base-compat with extra batteries  https://hackage.haskell.org/package/base-compat-batteries-0.11.2 (ryanglscott)
10:41:18 * hackage wordn 0.1.0.0 - arbitrary bit size Words  https://hackage.haskell.org/package/wordn-0.1.0.0 (goolord)
10:43:47 <maerwald> sm[m]: haha
10:43:56 <maerwald> I had that too and gave up
10:44:18 * hackage scotty-form 0.3.0.0 - Html form validation using `ditto`  https://hackage.haskell.org/package/scotty-form-0.3.0.0 (goolord)
10:44:58 <maerwald> but that's rather an amazon problem I think
10:46:49 * hackage base-orphans 0.8.3 - Backwards-compatible orphan instances for base  https://hackage.haskell.org/package/base-orphans-0.8.3 (ryanglscott)
10:48:16 <maerwald> the only time when I was on windows and thought "stack might be better here" I was disappointed
10:51:00 <glguy> Because it was or wasn't? :)
10:51:23 <maerwald> it wasn't and I ended up using chocolatey, which was broken with 8.10.2 though or something
10:55:20 <sm[m]> it was just a transient net failure, they fixed it both on the server and released a stack upgrade to make it less net dependent
10:59:16 <sm[m]> detail: https://github.com/commercialhaskell/stack/issues/5387#issuecomment-697159635
11:00:32 <maerwald> I'm still looking for the stack issue that explains why it re-clones the same repo multiple times if there are multiple subdirectories
11:01:44 <maerwald> example: https://git.io/JUyU8
11:02:01 <maerwald> this takes 30 minutes to clone, because it keeps cloning the same repos over and over again
11:13:18 * hackage Z-Data 0.1.4.1 - Array, vector and text  https://hackage.haskell.org/package/Z-Data-0.1.4.1 (winterland)
11:14:43 <glguy> I know this is oddly specific, but I'm wondering if it might ring any bells. I'm finding that if I run my IRC client on Ubuntu (rather than macOS), using GHC 8.6.5 (rather than 8.10.2), connecting to ZNC (rather than directly to freenode) that I stop being able to send messages out to the server (I still receive them). If I change any of those three variables things work fine. I'm happy to just not support old GHC, but I'm just wondering if
11:14:43 <glguy>  anyone knows about a funny interaction with networking in older GHC that might be relevant
11:16:13 <sm[m]> maerwald: sounds annoying.. report it I guess
11:22:19 * hackage generic-deriving 1.14 - Generic programming library for generalised deriving.  https://hackage.haskell.org/package/generic-deriving-1.14 (ryanglscott)
11:23:00 <koz_> glguy: That has to be one of the most specific errors I have ever heard.
11:29:15 <sm[m]> glguy: compare the versions and changelogs of likely libs (network, ...) ?
11:31:05 <maerwald> yeah, you can compare plan.json
11:32:45 <glguy> In my case the library versions are all visible through the --full-version flag :)
11:34:04 <glguy> if I could only remember which VM I was using...
11:34:12 <sm[m]> of the executable ? nice one
11:34:43 <glguy> ?paste
11:34:43 <lambdabot> A pastebin: https://paste.debian.net/
11:35:08 <glguy> https://paste.tomsmeding.com/4wA71uVU
11:36:44 <texasmynsted> I am trying to determine what hlint thinks I have done wrong with my code. I have tried the same code a few different ways but the result is the same. 
11:37:02 <[exa]> texasmynsted: pls pastebin an example
11:37:15 <texasmynsted> https://gist.github.com/mmynsted/0465fbc9f253231d7a04b1370b7e946f
11:37:40 <texasmynsted> [exa] There is the code in a gist
11:38:52 <texasmynsted> Says parse error.
11:39:12 <glguy> you forgot to put the error in the past
11:39:18 <glguy> paste*
11:39:39 <texasmynsted> overloaded strings is the only extension active OverloadedStrings
11:39:46 <texasmynsted> I updated
11:39:56 <texasmynsted> "parse error"
11:40:01 <glguy> did you truncate the rror?
11:40:16 <glguy> (I truncated error on purpose there...)
11:40:22 <geekosaur> which line is 183?
11:40:29 <tbreslein> which line is that in your example?
11:40:37 <glguy> Because when I run hlint on that code I get a more useful error
11:41:07 <texasmynsted> oh. Hey. I would like to get more useful errors.
11:41:18 <glguy> The whole error is: /Users/emertens/Temp.hs:4:41-47: Error: Parse error: on input `pattern'
11:41:27 <glguy> It doesn't like you using the identifier pattern
11:41:42 <glguy> probably because of its role in PatternSynonyms
11:41:54 <texasmynsted> How do you get better error messages?
11:42:03 <glguy> upgrade your hlint I guess
11:42:08 <texasmynsted> verbose does not change the messages for me
11:42:25 <glguy> cabal install hlint
11:42:25 <geekosaur> which would be a bug in hlint, if that extension isn't present then it's not a reserved identifier AIUI
11:42:27 <texasmynsted> I am using HLint v2.2.3, (C) Neil Mitchell 2006-2019
11:42:33 <glguy> texasmynsted: 3.2 is out
11:42:46 <texasmynsted> Hmm.
11:43:09 <glguy> hlint is pretty much "best effort" when it comes to parsing
11:43:11 <texasmynsted> I think I did cabal update and tried re-install yesterday.
11:43:17 <texasmynsted> How do I upgrade it correctly?
11:43:30 <glguy> you can try: cabal install hlint-3.2 # and see what complaints you get
11:43:39 <texasmynsted> Will do
11:43:52 <geekosaur> that said, it could be $PATH
11:44:17 <geekosaur> that is, it installed but the old one's earlier in $PATH so gets found first
11:44:19 * hackage servant-serf 0.0.2 - Generates a servant API module  https://hackage.haskell.org/package/servant-serf-0.0.2 (goolord)
11:44:34 <glguy> great point ^
11:44:46 <texasmynsted> It is finding the one from $HOME/.cabal/bin/hlint
11:45:03 <sm[m]> number one cause of haskell trouble...
11:45:10 <glguy> hlint? :)
11:45:20 <sm[m]> PATH :)
11:45:39 <texasmynsted> Well it seems it is finding the correct hlint
11:47:37 <aldessa> when you specify a license in package.yaml e.g. BSD3 does it automatically check if my license is compatible with all my dependencies
11:47:49 <texasmynsted> Attempting the upgrade. Maybe then I will get a different message.
11:48:44 <sm[m]> aldessa: no
11:49:39 <sm[m]> That would be nice
11:49:58 <glguy> cabal-plan as a license report command that can help
11:50:16 <Squarism> Ouch. I've been out of the Nix loop long enough to forget easy things. I try to build my old project, that I remember was working last I checked. And get this error: 
11:50:17 <Squarism> ghc: can't find a package database at /home/myuser/.cabal/store/ghc-8.6.5/package.db
11:50:22 <texasmynsted> I guess I need to add hlint comments to get it to avoid that section.
11:50:31 <Squarism> ...but there is a bunch of stuff there
11:50:59 <glguy> In my IRC client I have my Setup.hs abort if you attempt to build against something GPL, etc
11:53:03 <sm[m]> glguy: slick.. any friction caused by having a custom Setup.hs ?
11:53:19 <glguy> Not that I've experienced
11:54:07 <aldessa> is gplV3 the most compatible license? am I right in guessing I can use MIT/BSD dependencies in GPL programs?
11:54:19 <texasmynsted> wow building the ghc-lib-parser and no messages for a while now 
11:54:43 <glguy> It's part of the process of assembling the full-version output
11:56:14 <texasmynsted> okay back to progress
11:56:22 <glguy> aldessa: depends if you're making a library or executable
11:56:50 <glguy> If you're making a library most of the Haskell ecosystem won't be able to use your library if it's gpl
11:57:25 <Clint> "won't"
11:58:20 <aldessa> i'm making an executable but it would be nice if someone needed the code that they code reuse it
11:58:30 <aldessa> could*
11:59:16 <texasmynsted> Okay I get the better error message now about how there is: "Parse error: on input `pattern'"
12:00:03 <texasmynsted> I guess this is a bug? I do now see what would be wrong with that input.
12:00:51 <solonarv> perhaps you forgot to enable a language extension? (the relevant one would be PatternSynonyms)
12:01:19 <p0a> Hello how can I compile GHC from source?
12:01:20 <geekosaur> no, the point is it's disabled and "pattern" should not be a keyword, but hlint thinks it is
12:01:49 * hackage servant-serf 0.0.3 - Generates a servant API module  https://hackage.haskell.org/package/servant-serf-0.0.3 (goolord)
12:02:00 <texasmynsted> oh
12:03:00 <fendor> p0a, https://gitlab.haskell.org/ghc/ghc and https://gitlab.haskell.org/ghc/ghc/-/wikis/building
12:03:06 <texasmynsted> Okay yes. I change the name and it works 
12:03:26 <texasmynsted> So how did you know that it thought that `pattern` was a reserved word?
12:03:34 <texasmynsted> I did not get that from the error message
12:04:17 <geekosaur> just from the fact that it errored on "pattern" and I know about the PatternSynonyms extension. same way glguy figured it out a couple pages of text back :)
12:04:58 <glguy> You just have to memorize all the ghc language extensions and have in mind where they overlap
12:05:06 <glguy> <_< easy
12:05:11 <p0a> fendor: thank you
12:05:27 <geekosaur> luckily few of them introduce new keywords
12:05:29 <texasmynsted> Pfffft. grrreat 
12:05:34 <texasmynsted> lol. Thank you!
12:22:45 <p0a> Hello, I have this code: https://paste.tomsmeding.com/Y6afnL1R
12:23:12 <p0a> The error is that you can't have Eq, Show, Read be derived for File', I believe due to HKD. What can I do?
12:23:48 * hackage poly 0.5.0.0 - Polynomials  https://hackage.haskell.org/package/poly-0.5.0.0 (Bodigrim)
12:25:36 <p0a> I think I have to somehow use `deriving' with specific instances but I don't know how to do that
12:25:56 <tomsmeding> p0a: the issue is that to derive e.g. Eq for File' f, it is required that Eq (KHD f FilePath), etc. also holds
12:26:25 <tomsmeding> for simple cases ghc can automatically generate the necessary contexts in the generated instance, but apparently in this case it can't
12:26:41 <p0a> How can I provide the instances for File? That's the one I want
12:27:32 <p0a> if I add `deriving' after `type File = File' Identity' I get a parsing error
12:27:54 <tomsmeding> indeed, adding 'deriving' after a tye synonym declaration is invalid syntax
12:28:00 <tomsmeding> however, you can do it like this:
12:28:36 <tomsmeding> https://paste.tomsmeding.com/okCA6gS4
12:28:53 <tomsmeding> StandaloneDeriving is to allow writing those, well, stand-alone 'deriving' statements
12:29:19 <tomsmeding> FlexibleInstances and TypeSynonymInstances is to be allowed to write an instance for a type synonym (i.e. File, as opposed to File') in the first place
12:29:42 <p0a> heh thank you
12:29:48 <p0a> that was tricky
12:30:10 <tomsmeding> (well really that's only TypeSynonymInstances; FlexibleInstances is then required because when expanding the File type synonym, the instance becomes Eq (File' Identity), and because that Identity is not a type variable, FlexibleInstances is needed)
12:30:43 <tomsmeding> generally when you want to derive instances that GHC doesn't do automatically, I try it as a standalone deriving statement
12:30:58 <tomsmeding> usually that will also not work (though sometimes it will), but then GHC tends to give better error messages
12:31:25 <p0a> hahah got it 
12:31:27 <tomsmeding> in this case, if you just add StandaloneDeriving and write those stand-alone instances, it will correctly ask you to add the other two extensions
12:31:33 <p0a> you sort of have to squeeze it out of ghc 
12:31:36 <tomsmeding> :p
12:32:15 <p0a> I am afraid I am not understanding the extensions very well but I will continue writing code for now 
12:32:28 <tomsmeding> which one?
12:32:28 <p0a> that is, I do not understand their purpose
12:32:44 <p0a> well let's start with TypeSynonymInstances 
12:32:56 <tomsmeding> without any extensions, haskell only allows you to write an instance for a type of the form T a b c d
12:33:01 <p0a> Oh wait, that one you explained
12:33:06 <tomsmeding> where T is a type name, and a b c d ... are type variables
12:33:08 <p0a> I think the cryptic one is FlexibleInstnaces 
12:33:20 <tomsmeding> yeah
12:33:41 <tomsmeding> if T is a type synonym, it doesn't match the recipe so you need TypeSynonymInstances (which resolves the name first)
12:34:00 <tomsmeding> if a b c d, etc, are not type variables but explicitly instantiated to a particular type, then you need FlexibleInstances
12:34:19 <tomsmeding> for example, you can't write 'instance Show [MyCustomType]' directly
12:34:34 <tomsmeding> because that's, of course, really 'Show ([] MyCustomType)', and MyCustomType is not a type variable
12:34:44 <p0a> What is it instead?
12:34:49 <tomsmeding> well, a type :p
12:34:50 <tomsmeding> not a variable
12:34:52 <p0a> right, okay
12:35:00 <tomsmeding> you _can_ write 'instance Show [a]' because that is 'Show ([] a)' and 'a' _is_ a type variable
12:35:13 <geekosaur> except it'll overlap
12:35:19 <tomsmeding> basically, normally you can only create instances for _all_ polymorphic versions of a type
12:35:30 <tomsmeding> geekosaur: okay yes in this case for Show ([] ...) it will overlap
12:35:33 <p0a> I see, FlexibleInstances let's you exercise an incision
12:35:38 <tomsmeding> because there is already Show a => Show [a]
12:35:49 <tomsmeding> substitute some random other class for Show :p
12:35:56 <tomsmeding> p0a: kinda :)
12:36:22 <tomsmeding> once instance contexts start to get complex you might also need UndecidableInstances at some point
12:36:23 <p0a> Very nice, thank you :) that's an extension I commonly see
12:36:41 <tomsmeding> though I don't know the precise rules for that one :)
12:36:50 <p0a> don't worry it's not on the menu right now 
12:36:52 <geekosaur> "avoid"
12:36:56 <p0a> lol
12:37:13 <tomsmeding> well yeah, avoid most things that say "undecidable"
12:41:05 <p0a> If I want (Just 3) == 3 and Nothing == 3 to be True, how can I implement this? Say I have a :: Maybe Int and b :: Int, and wish to have the above comparisons
12:41:30 <p0a> I'm going to look into Control.Monad.Maybe
12:41:32 <tomsmeding> :t (==)
12:41:34 <lambdabot> Eq a => a -> a -> Bool
12:41:36 <p0a> Or Maybe Data.Maybe 
12:41:44 <tomsmeding> Maybe Int does not unify with Int
12:42:03 <p0a> Sure, it doesn't have to be with == , I'm just curious of neat source code to do that
12:42:10 <{abby}> > maybe 3 id (Just 3)
12:42:11 <p0a> my code would have if elses
12:42:12 <lambdabot>  3
12:42:18 <{abby}> > maybe 3 id Nothing
12:42:21 <lambdabot>  3
12:42:39 <tomsmeding> > (fromMaybe 3 (Just 5), fromMaybe 3 Nothing)
12:42:41 <lambdabot>  (5,3)
12:42:43 <{abby}> maybe default id = fromMaybe default, but I'm not sure if fromMaybe is in scope (import it from Data.Maybe)
12:42:48 <tomsmeding> that's what fromMaybe is for
12:43:05 <tomsmeding> ah yes
12:43:31 <tomsmeding> p0a: surely it would be a case expression on the Maybe value, though, not an actual if-then-else?
12:43:50 <p0a> Right tomsmeding , but you can also use isJust and isNothing
12:43:51 <{abby}> tomsmeding: better safe than sorry :p I'm never sure what's in lambdabot's scope
12:44:01 <tomsmeding> {abby}: fair :p
12:44:12 <kindaro> In Template Haskell, how can I convert an `Exp` to a `Pat`?â€‚I have a `Type` and I want to pattern match on its literal name as given by `Type.Reflection.tyConName`.
12:44:22 <tomsmeding> p0a: isJust and fromJust? while there are legitimate use cases for fromJust, think thrice when using it
12:44:33 <p0a> (x == \x -> fromMaybe x y) is then what I'd do I think 
12:44:40 <p0a> thank you 
12:44:42 <tomsmeding> because usually you're better off with a case expression or an existing combinator
12:44:44 <kindaro> So, I can construct an `Exp` with a quasi quote, but it seems I cannot construct a `Pat`.
12:44:53 <tomsmeding> less partiality more better
12:45:02 <p0a> right, that is true 
12:45:34 <kindaro> For example, this would not work: `getTypeNameLiteral subject = (tyConName âˆ˜ typeRepTyCon) (typeRep @ $(return subject))`
12:46:15 <kindaro> This compiles but gives me a `Q Exp`: `getTypeNameLiteral subject = [|(tyConName âˆ˜ typeRepTyCon) (typeRep @ $(return subject))|]`
12:46:48 <kindaro> This does not compile: `getTypeNameLiteral subject = [p|(tyConName âˆ˜ typeRepTyCon) (typeRep @ $(return subject))|]`
12:46:58 <tomsmeding> what kind of pattern would you want it to be
12:47:08 <tomsmeding> string? data constructor?
12:47:19 <tomsmeding> can't you create the Pat value yourself
12:47:22 <tomsmeding> https://hackage.haskell.org/package/template-haskell-2.16.0.0/docs/Language-Haskell-TH.html
12:48:04 <kindaro> For `Type` = `(ConT GHC.Types.Int)`, I would like `"Int"`, and so on.
12:48:40 <kindaro> I cannot create a `Pat` value because I have no idea what string `tyConName` would produce.
12:48:53 <kindaro> I have to first run `tyConName` somehow.
12:49:25 <tomsmeding> oh your problem is to get the TyCon to pass to tyConName?
12:49:31 <tomsmeding> from what do you want to get it
12:49:40 <tomsmeding> a value of that type?
12:49:40 <kindaro> From `Type`.
12:50:11 <kindaro> This `Type`: https://hackage.haskell.org/package/template-haskell-2.16.0.0/docs/Language-Haskell-TH.html#t:Type
12:50:37 <kindaro> So, I first have to convert this `Type` to an actual expression, at which point it becomes incompatible with `Pat`.
12:50:46 <tomsmeding> but, a type can have many constructors, right?
12:50:53 <tomsmeding> data A = A | B
12:51:00 <kindaro> It has one type constructor.
12:51:03 <tomsmeding> if the Type is A, do you want the TyCon for A or for B?
12:51:04 <tomsmeding> ah
12:51:04 <kindaro> In your case `A`.
12:51:22 <tomsmeding> can't you use generics
12:51:39 <kindaro> Like how?
12:52:18 <kindaro> As you may remember, my problem can be put as constructing a large case expression.
12:52:27 <tomsmeding> right
12:52:34 <kindaro> The way to do that is via Template Haskell.
12:52:37 <aldessa> by the way for my earlier problem, the solution was 'stack ls --dependencies --no-include-base --license' to see all the licenses
12:52:48 * hackage deriving-compat 0.5.10 - Backports of GHC deriving extensions  https://hackage.haskell.org/package/deriving-compat-0.5.10 (ryanglscott)
12:53:10 <kindaro> I made some progress, but it is unclear how I can associate a literal pattern with a `Type`.
12:53:12 <nobody239419341> hello can someone help me understand this function signrature `palindrome = reverse >>= (==)` I'm beginner to haskell
12:54:06 <Cheery> :t reverse >>= (==)
12:54:06 <sm[m]> aldessa: stack ls dependencies --no-include-base --license   ... very cool, thanks
12:54:07 <lambdabot> Eq a => [a] -> Bool
12:54:11 <tomsmeding> kindaro: I know how to write a function 'magic :: Generic a => String' that produces the name of the first type constructor of 'a'; would that be sufficient for you?
12:54:14 <monochrom> It is not for beginners. Please don't worry about that one. Please learn and play with basic examples first.
12:54:30 <p0a> nobody239419341: I believe that is not a signature. I think signatures refer to the types after :: 
12:54:34 <monochrom> Whoever showed you "reverse >>= (==)" did not respect that you are a beginner.
12:54:34 <tomsmeding> kindaro: I'm not familiar enough with TH to know whether generics play nicely with it
12:55:05 <nobody239419341> I was self learning from https://wiki.haskell.org/99_questions/Solutions/6 here and would like to understand that solution
12:55:07 <kindaro> I expect that they do not.
12:55:15 <nobody239419341> I wrote first solution myself without looking to the solutions page
12:56:25 <nobody239419341> I know how would I look to the function signatures by ` :t ` in ghci
12:56:27 <Cheery> :t (>>=) reverse
12:56:29 <lambdabot> ([a] -> [a] -> b) -> [a] -> b
12:56:35 <Cheery> :t (==)
12:56:37 <lambdabot> Eq a => a -> a -> Bool
12:57:19 <tomsmeding> kindaro: 'tyConName (typeRepTyCon (typeRep @T))' is of type String
12:57:22 * sm[m] discovers a few weirdo packages using BSD-2 (megaparsec & text)
12:57:30 <tomsmeding> not sure where Exp comes into the discussion
12:57:53 <tomsmeding> also I now realise that you're talking about the _type_ constructor, not a _data_ constructor :p
12:59:13 * tomsmeding is surprised about the amount of reflection that ghc gives you with Type.Reflection, Data.Typeable and templatehaskell
12:59:35 <kindaro> nobody239419341 â€‚This is some advanced Haskell, I have been doing it for some years but it took me effort to understand how your function works.â€‚You may wish to consult the Monad instance for functions.â€‚https://hackage.haskell.org/package/base-4.14.0.0/docs/src/GHC.Base.html#line-979
12:59:37 <Cheery> tomsmeding: any short introduction to Type Reflection you'd recommend?
12:59:49 <Cheery> or data typeable, those sound interesting.
13:00:51 <tomsmeding> Cheery: I learned about the existence of Type.Reflection when kindaro mentioned it
13:00:58 <tomsmeding> I'm afraid I'm not the right person to ask :p
13:01:00 <Cheery> nobody239419341: that implementation for checking palindrome is vicious.
13:01:02 <nobody239419341> kindaro thank you I will look to it
13:01:05 <kindaro> nobody239419341 â€‚As you may see, it does exactly what you need it to do.â€‚_Â«WhyÂ»_ is another question.â€‚It is fair to say that I never ever used the monad instance for functions.
13:01:22 <p0a> Oh so that's what it is using. Wow, tricky
13:01:58 <Cheery> functions make a valid monad with their last argument.. it's a bit difficult to understand but it's valid.
13:01:59 <kindaro> Seeing that `Reader` is really a function, this may give some intuition.
13:02:06 <sm[m]> ...and one weirdo using ISC (glguy :). Interesting, I didn't know about ISC
13:02:19 * hackage linear 1.21.2 - Linear Algebra  https://hackage.haskell.org/package/linear-1.21.2 (ryanglscott)
13:02:30 <sm[m]> https://www.gnu.org/licenses/license-list.en.html#ISC
13:02:40 <Cheery> nobody239419341: [a] -> [a] is the type signature for reverse.
13:02:51 <p0a> Cheery: I think this explains some of it? https://mjoldfield.com/atelier/2014/07/monads-fn.html
13:02:54 <nobody239419341> yes
13:02:55 <p0a> Or am I wrong? 
13:03:13 <tomsmeding> sm[m]: what about https://hackage.haskell.org/package/dependent-map
13:03:28 <Cheery> nobody239419341: now imagine that's something like F [a] where F x = [a] -> x
13:04:11 <nobody239419341> what does it mean to apply the infix operator `->` for function definition
13:04:48 <kindaro> tomsmeding, so the story goes: I get the list of `Type` values by examining `reifyInstances`.â€‚Now I must use `tyConName` on the corresponding types.â€‚But this correspondence is not trivial to establish.
13:04:49 <nobody239419341> This is new to me, only seen it on signatures and case expressions, and reverse form on do blocks
13:05:04 <sm[m]> tomsmeding: they seem to be on top of things.. nice precision
13:05:41 <sm[m]> oh, well "I have no idea which, if any, of the following licenses apply, so I've copied them all.", maybe precision is not the word :)
13:05:58 <sm[m]> nice transparency
13:06:58 <kindaro> tomsmeding, so I may transform `Type` to an `Exp` that contains the corresponding type constructor, and then I can use it to obtain an expression for its `tyConName`.
13:07:16 <kindaro> tomsmeding â€‚Does this explanation make things clearer?
13:07:30 <Cheery> nobody239419341: Well I can tell you it's hard, and my explanation may go over, if that's the case, I'll try to elaborate so you understand it enough.
13:07:47 <tomsmeding> kindaro: if the type in question is data A = B | C, do you want, "A", "B" or "C"?
13:07:56 <kindaro> `A`.
13:08:00 <tomsmeding> okay
13:08:08 <Cheery> nobody239419341: but the important part now is, you need to look at the function type like that.
13:08:09 <nobody239419341> i can't even say if I know precisely what's a typeclass and type and data and whatever things in haskell
13:08:19 <kindaro> tomsmeding â€‚I cannot really obtain anything else from `reifyInstancesÂ°.
13:08:20 <Cheery> :t (>>=)
13:08:22 <tomsmeding> is it hard to give a piece of code that contains one `_` hole where you don't know what function to insert?
13:08:22 <lambdabot> Monad m => m a -> (a -> m b) -> m b
13:08:44 <Cheery> nobody239419341: you see how that type signature goes, now you can expand here.. You had..
13:09:06 <Cheery> nobody239419341: m [a] -> ([a] -> m b) -> m b
13:09:20 <nobody239419341> yeah It's just I think about an Num when I see Monad so I imagine like Its like Num m => Num a (a -> .... etc
13:09:40 <Cheery> so if you do (>>=) reverse, we got this..
13:09:44 <Cheery> :t (>>=) reverse
13:09:45 <lambdabot> ([a] -> [a] -> b) -> [a] -> b
13:10:10 <Cheery> the next parameter is a function, and now it has expanded like that.. so the first parameter is the result of 'reverse', what else could it be?
13:10:22 <nobody239419341> okay go on, I have one question to ask at the end or now, if you like
13:10:25 <Cheery> the second parameter is the argument passed to reverse.
13:10:30 <kindaro> tomsmeding â€‚`getTypeNameLiteral subject = _ [|(tyConName âˆ˜ typeRepTyCon) (typeRep @ $(return subject))|] âˆ· Q Pat`
13:11:55 <Cheery> nobody239419341: so if you take [1,2] == [2,1] it's bit like checking whether [1,2] is a palindrome?
13:12:06 <nobody239419341> yes
13:12:22 <nobody239419341> :t (>>=)
13:12:23 <lambdabot> Monad m => m a -> (a -> m b) -> m b
13:12:26 <Cheery> nobody239419341: so if you put it there, like this: (>>=) reverse (==)
13:12:44 <Cheery> you get this kind of composition of reverse with that function of checking equality of two lists.
13:13:13 <Cheery> :t (>>=) reverse (==)
13:13:15 <lambdabot> Eq a => [a] -> Bool
13:13:39 <ski> @type (>>=) `asTypeIn` \(>>=) -> (>>=) reverse (==)
13:13:41 <lambdabot> Eq a => ([a] -> [a]) -> ([a] -> [a] -> Bool) -> [a] -> Bool
13:14:22 <Cheery> cool.
13:15:23 <ski> > (>>=) f (g :: Expr -> Expr -> Expr) x
13:15:26 <lambdabot>  g (f x) x
13:16:24 <nobody239419341> thank you Cheery. It helped a bit
13:17:26 <Cheery> nobody239419341: Also check out ski's explanation, but the idea is that functions are valid monads and that thing kind of treats reverse as a monad, then binds the equality to it.
13:18:33 <Cheery> it probably helps if you consider how functions are valid functors, or then it doesn't.
13:19:49 <Cheery> @type fmap `asTypeIn` \fmap -> (fmap f g :: a -> b)
13:19:50 <lambdabot> error:
13:19:51 <lambdabot>     â€¢ Couldn't match type â€˜fâ€™ with â€˜(->) a1â€™
13:19:51 <lambdabot>         because type variable â€˜a1â€™ would escape its scope
13:20:05 <ski> (not functions. functions are values, monads are not values. you mean the (partially applied function) type `([a] ->)', being a monad. so e.g. `(>>=) :: Monad m => m b -> (b -> m c) -> m c' then becomes `([a] -> b) -> (b -> [a] -> c) -> [a] -> c')
13:20:33 <nobody239419341> wait this could be important information for me to understand
13:20:37 <nobody239419341> so is all functions are types?
13:21:11 <p0a> yeah nobody239419341 
13:21:31 <ski> @type fmap `asTypeIn` \fmap -> fmap ?f ?g
13:21:33 <lambdabot> (Functor f, ?f::a -> b, ?g::f a) => (a -> b) -> f a -> f b
13:21:53 <ski> nobody239419341 : functions are not types
13:22:04 <Cheery> (a -> b) -> (c -> a) -> (c -> b)
13:22:09 <ski> "function types" means the types of functions
13:23:02 <nobody239419341> so how do you pass the reverse function as an argument to the (>>=) ?
13:23:42 <Cheery> nobody239419341: There's an instance Monad (a ->)
13:23:52 <Cheery> it is matched when you do os.
13:24:01 <p0a> nobody239419341: what is happening is a bit different than that. There's a lot of stuff going on involving definitions you probably are not even aware of
13:24:18 <p0a> nobody239419341: to just compose two functions you do something like (f . g)
13:24:45 <monochrom> >>= is an infix operator, so just write "reverse >>= ..."?
13:25:26 <Cheery> https://hackage.haskell.org/package/base-4.14.0.0/docs/src/GHC.Base.html#line-979
13:25:28 <p0a> The trick with your palindrome implementation is that it uses a well-known feature of the language (monads), but also a less commonly used monad (the function monad). That's how I understand it. To understand the better known parts of monads, is already a task in itself nobody239419341 
13:27:38 <nobody239419341> uh why nobody can explain like just an example -> it takes the reverse function and puts it on the right side of the (==) and whenever a list is called on it, list will put on left side of the (==) and reverse will be applied and put it on the right side
13:28:18 * hackage transformers-compat 0.6.6 - A small compatibility shim for the transformers library  https://hackage.haskell.org/package/transformers-compat-0.6.6 (ryanglscott)
13:28:22 <nobody239419341> Damn monads
13:28:33 <monochrom> Huh? That explanation is BS.
13:28:36 <Cheery> nobody239419341: it's lot of details that go into it becoming (==) (reverse x) x
13:28:50 <p0a> monochrom: mine? Whoops, sorry 
13:28:58 <nobody239419341> I can imagine
13:29:03 <Cheery> or reverse x == x
13:29:07 <monochrom> No, nobody239419341's explanation.
13:29:31 <Cheery> btw.. on functors of.. not functions but partially applied functions.
13:29:51 <Cheery> djinn finds a value for a type.
13:29:58 <Cheery> @djinn (a -> b) -> (c -> a) -> (c -> b)
13:29:58 <lambdabot> f a b c = a (b c)
13:30:25 <monochrom> See, in the first place, I am against tackling >>= at a beginner stage in the first stage, especially for a palindrome exercise that can be done in 10 different elementary ways already.
13:30:44 <Cheery> yup. but he asked for it. :)
13:30:57 <monochrom> I have no idea why you people decided to entertain this request and get into such a rabbit hole.
13:30:59 <Cheery> and I guess this is helpful to see.. how this comes up together.
13:31:16 <p0a> I think it's a show-off really, to write a palindrome like that 
13:31:31 <nobody239419341> I'm just stuck in a loop for creating recursive functions and exercises for two months
13:31:41 <monochrom> It takes like 2-4 weeks of preparations before >>= makes sense for this exercise. Not 2 hours.
13:31:44 <nobody239419341> I can't get progress without having eaten some parts of the FP
13:32:14 <p0a> nobody239419341: In my opinion it's better to start with `Maybe' and `IO'
13:32:20 <Cheery> :t (.)
13:32:21 <lambdabot> (b -> c) -> (a -> b) -> a -> c
13:32:37 <p0a> Write programs that do simple tasks but require some checking of values. You'll have to be using Maybe and IO for that 
13:32:43 <nobody239419341> I see maybe as like a box
13:32:56 <Cheery> https://hackage.haskell.org/package/base-4.14.0.0/docs/src/GHC.Base.html#line-969
13:33:03 <Cheery> there reads.. fmap = (.)
13:33:19 * hackage error-or 0.1.0.0 - Composable, hierarchical errors.  https://hackage.haskell.org/package/error-or-0.1.0.0 (luntain)
13:33:29 <xsperry> cheers fmap is (.) for function functor
13:33:35 <xsperry> Cheery*
13:33:42 <p0a> nobody239419341: Write a program that keeps an address book and looks up a name in it, allows you to modify a record and save/load records from a file
13:33:53 <monochrom> Well, I stuck my students in a loop for creating recursive functions and exercises for two months. And only then they are ready for >>=
13:34:26 <monochrom> People really don't realize the effect and benefits of "repetitive" immersion.
13:34:49 <xsperry> Cheery, for list (for example), it is just map
13:36:17 <tomsmeding> @tell kindaro here is something: https://paste.tomsmeding.com/WWaRcppB
13:36:17 <lambdabot> Consider it noted.
13:36:56 <nobody239419341> okay guys thank you all for the suggestions. I'll keep doing exercises and try out that address book application 
13:37:28 <Cheery> nobody239419341: np. I hope it helped. It's just a fancy trick and nothing wrong with those, but it involves understanding this kind of things.
13:38:19 <Cheery> at some context the idea of (->) a as a monad, does make sense.
13:39:42 <monochrom> Well first thing you have to embrace that "X->Y" is "((->) X) Y" and the shock that the "(->) X" part can be isolated out as a standalone thing.
13:39:59 <monochrom> That alone probably takes a week to absorb already.
13:40:11 <p0a> Why is X->Y parsed like that?
13:40:18 <p0a> is 1 + 2 also the same?
13:40:21 <Cheery> for instance, a program requires an additional parameter, but it's not used too often, you might supply it as last parameter and form a monad around it.
13:40:22 <monochrom> Yes.
13:40:36 <monochrom> See? So much prerequisites.
13:40:57 <Rembane> > (+) 1 2 
13:41:00 <lambdabot>  3
13:41:09 <monochrom> But you're confusing the term level and the type level.
13:41:22 <p0a> Right, okay. Because I was thinking of - now
13:41:47 <p0a> I'm just confused, ignore me
13:42:49 <p0a> I'm impressed at how quickly I was able to whip together a simple file database program that helps me keep track of my books and notes
13:43:03 <p0a> took me 2 days of maybe 30 minutes each (well thanks to this channel as well)
13:44:34 <sm[m]> p0a: nice!
13:47:33 <Cheery> about that.. I'm thinking of a little project.. I start looking what kind of html/tagsoup functionality my blog driver would require to be written in haskell
13:48:12 <p0a> sm[m]: thank you :) I agree 
13:48:21 <p0a> I'll share it here once it's looking good
13:54:50 <Cheery> aside just going to google each function, is there a page dedicated to giving haskell equivalents for os.walk, os.path.join, etc... ?
13:54:54 <sm[m]> I think there's a lot of speed-of-development and power in haskell & libs, just waiting for a bit more refinement/curation/tooling to come together
13:55:23 <sm[m]> not yet tapped, I mean
13:55:28 <Rembane> Cheery: System.Directory, System.Environment, hm... and more! :D
13:55:59 <Rembane> Cheery: If you happen to know the C stdlib, the functions are named almost the same in Haskell, but they are slightly more sane.
13:56:21 <Cheery> I'd also like about a function that gives current date, and some datetime handling.
13:56:35 <aldessa> I'd like to learn numerical methods. I hear Haskell is a bad language to do it in, is this true if I'm using unboxed mutable arrays in the ST monad?
13:56:52 <Rembane> Cheery: That's trickier 
13:57:15 <Rembane> aldessa: It depends, if you can work with slow numerical methods it's alright
13:58:08 <aldessa> why is it slow Rembane? i thought Haskell was slower because of garbage collection; does the ST monad not avoid that?
13:59:21 <Rembane> aldessa: Laziness has a tendency to bite if not properly contained and Haskell is slower than Fortran for such things. 
13:59:41 <Rembane> Cheery: I used thyme for that, but I think it's needlessly complicated. 
14:01:37 <monochrom> unboxed mutable array likely kills most of the laziness.
14:02:40 <xsperry> Cheery, also System.FilePath, and for dates there's time package
14:03:07 <monochrom> But it still stands to reason to re-use existing C-bound numerical libraries like LAPACK because they are both well-tuned and well-tested over the years.
14:03:08 <Cale> Slow is relative -- people do all kinds of numerical stuff in Python, so no doubt Haskell is an option for a lot of applications.
14:03:32 <monochrom> and well-understood
14:03:32 <Cale> and yeah, typically you're going to use bindings to stuff that was optimised at a lower level
14:04:15 <monochrom> It is possible to replicate the same expertise in Haskell if you prepare to spend the same amount of person-years.
14:04:30 <monochrom> But don't expect to take merely days.
14:05:17 <aldessa> i'd be writing my own numerical methods because i'm doing a course in them;
14:05:29 <monochrom> Ah OK then just cause.
14:06:26 <monochrom> If you aren't aware of how Haskell is compiled to machine code and how laziness is done this way, then expect to suffer inefficiency.
14:07:04 <monochrom> In fact not only constant-multiplier inefficiency. You could be spending linear space where constant space should be enough.
14:07:15 <dolio> Blaming it all on laziness is naive.
14:07:27 <monochrom> I know.
14:07:40 <dolio> If you want efficiency, you need to understand many things about how the compiler works.
14:07:42 <monochrom> But for most numerical algorithms, eagerness is the better default.
14:07:50 <aldessa> i was mostly concerned about memory management
14:07:50 <monochrom> Yes that.
14:08:08 <Cale> Laziness will also be the thing that trips up beginners a bunch, even if there are cases where it can be put to excellent use
14:08:34 <monochrom> Especially if you're transcribing imperative numerical algorithms such as from most textbooks to Haskell. They were written for eager evaluation.
14:08:36 <dolio> monochrom: I know you know that. :)
14:08:39 <p0a> It suffices to say that if you do numerical optimizatio in Haskell you'll be learning two (at least) things at once
14:08:41 <monochrom> OK!
14:09:10 <aldessa> i don't know any languages other than Haskell so I'd like to avoid learning another one
14:09:15 <aldessa> anyhow
14:09:27 <aldessa> is foreign ptr meant to only be used for foreign bindings? it seems to be that way
14:09:28 <sm[m]> quite right
14:09:52 <monochrom> Of course if you follow John Hughes's paper and turn your Newton's method into a "generate infinite list of iterates" and a "consume until convergence" then laziness is required.
14:10:06 <monochrom> (But how many numerical method students are going to do that?)
14:10:47 <dolio> I just wanted to make sure it's clear in this conversation. People automatically jump to blame laziness, but the truth is you need to know what you're doing in almost any language, and laziness is often used as a scapegoat.
14:10:52 <p0a> consume until convergence sounds scary 
14:11:13 <p0a> You could get caught in infinite loops with Newton's method I think :P
14:11:26 <monochrom> p0a: Like this: http://www.cs.utoronto.ca/~trebla/CSCC24-2020-Summer/03-haskell-evaluation.html#lazygood
14:11:48 <monochrom> Oh, every textbook pseudocode for Newton's method has the same problem.
14:11:51 <p0a> ah with x^3 - b = 0 it won't happen
14:12:16 <monochrom> But I stole this idea from John Hughes's "why FP matters"
14:12:39 <p0a> very nice
14:12:54 <monochrom> In hindsight, a lot of us agree that it's really "why FP with laziness matters"
14:14:03 <Cheery> subprocess.call(['rsync', '-r', '--delete', src, dst])
14:14:10 <p0a> I'm going to read your link soon. I have a few todo reads on my list, just ticked off higher-kinded data; I want to learn a bit about FFI next and also your link
14:14:21 <Cheery> google says System.Process gives equivalent.
14:14:41 <monochrom> dolio is right, the criterion for performance is "you understand the compiler". And this is true of Fortran and C, too.
14:15:16 <monochrom> And LAPACK is successful because the authors do understand Fortran compilers.
14:15:35 <xsperry> Cheery, there's also this (several examples on that page): https://hackage.haskell.org/package/typed-process
14:15:51 <monochrom> For example they know that "invariant code motion" is a thing.
14:16:54 <motte> anyone have experience with WAI? how can i access the basic auth username in my Application code? should i try to extract it from the request headers or use a middleware with Vault or something?
14:17:13 <Cheery> Is there monoid for html/xml?
14:18:26 <Cheery> well I miscommunicated, but some agreed upon way to construct html is what I'm looking for
14:18:50 <Cheery> eg. (Tag "item" attrs body)
14:18:53 <aldessa> monochrom, that's pretty true. I used SPJ's book to make a broken G machine implementation and you really see how hard it is to do strictness analysis and other stuff.
14:19:02 <Cheery> then forming <item ...>stuff</item>
14:19:35 <aldessa> i read this paper http://www.leafpetersen.com/leaf/publications/ifl2013/haskell-gap.pdf a while ago; how does GHC compare to the intell haskell research compiler?
14:20:21 <monochrom> Hrm! I thought Intel only had a research C compiler.
14:20:41 <phadej> icc is not a research compiler
14:20:53 <Rembane> Cheery: I'm quite fond of lucid: https://hackage.haskell.org/package/lucid
14:21:13 <motte> nvm got it, there is a function just for that
14:21:16 <aldessa> they wrote a whole program optimising compiler for Haskell
14:22:49 * hackage ordinal 0.1.2.0 - Convert numbers to words in different languages.  https://hackage.haskell.org/package/ordinal-0.1.2.0 (wvanonsem90)
14:23:37 <aldessa> thanks everyone for the caution but because i'm a student the speed really doesn't matter that much
14:23:41 <aldessa> i'm going to go with GHC primitives if i can
14:42:20 <justsomeguy> (Sorry about the away messages; I was having keyboard problems.)
14:42:30 <heebo> has haskell performance significantly improved in ghc 8?
14:42:39 <heebo> ive been away from the scene for a while
14:43:29 <heebo> im also interested in finding out about hls , just installed it with ghcup , but unsure how to configure emacs to use it
14:43:52 <maerwald> heebo: https://github.com/haskell/haskell-language-server#using-haskell-language-server-with-emacs
14:44:29 <heebo> oh thanks!!! just what the doctor ordered!
14:46:17 <sm[m]> improved since when heebo ?
14:46:32 <maerwald> since 8
14:47:54 <heebo> yeah since early 8
14:48:08 <heebo> ghc moves so fast , its really hard to keep up
14:48:30 <sm[m]> I would guess the answer is: not that you'd notice
14:48:35 <maerwald> if you mean compilation speed, code generation quality etc... I'm actually not sure
14:48:45 <heebo> spend a little time studying rust , cat theory or machine learning - and come back to a changed haskell world
14:48:47 <maerwald> But new GHC extensions for sure
14:48:54 <heebo> lol
14:49:32 <heebo> i havent got my head around all of the extensions from 8
14:49:37 <sm[m]> I believe some libs have had some significant speedups lately, like bytestring
14:49:56 <maerwald> heebo: debugging got a little better maybe
14:50:18 <sm[m]> some pathologically slow cases will have been fixed
14:50:46 <heebo> oh nice ill tuck in and find out whats clever , thanks all 
14:51:41 <maerwald> you might also have noticed the exciting tool wars... I think all that hadn't begun yet prior to 8
14:52:23 <heebo> as in hls vs hie?
14:52:41 <maerwald> that's not a war, just confusion and rebranding :p
14:52:52 <maerwald> rather cabal vs stack
14:53:04 <maerwald> and then nix came along too
14:53:23 <heebo> cabal fought back?
14:53:26 <maerwald> yeah
14:53:48 <heebo> how?
14:53:49 <maerwald> went into training and increased its power level
14:53:52 <heebo> lol
14:53:59 <heebo> over 9k?
14:54:03 <maerwald> for sure
14:54:45 <heebo> i need to forgive cabal , i abandoned her a while ago
14:54:58 <heebo> actually me and stack just used her behind the scenes
14:55:08 <Cheery> Rembane: Why HTML builder should be a monad?
14:55:28 <Rembane> Cheery: Mostly to get a nice syntax to work with
14:55:57 <maerwald> heebo: also, sandboxes are gone
14:56:00 <heebo> so you can combine builders ?
14:56:23 <heebo> maerwald: what?! so.... do i need to buy and external harddrive?
14:56:48 <sm[m]> no they're not.. phadej is trying to get rid of them..
14:57:04 <maerwald> sm[m]: they are
14:57:22 <heebo> Cheery: presumably so you can combine builders in an ordered way?
14:57:26 <sm[m]> are not! :-p
14:57:35 <maerwald> sm[m]: sandboxes are removed
14:57:40 <maerwald> try it
14:57:48 <monochrom> which version?
14:58:08 <sm[m]> ok, I must be confused. I guess we still have only non-sandbox v1 ? I forgot they were different
14:58:24 <maerwald> yes, that's different
14:58:42 <sm[m]> but I'm still right because users will still show up here with cabal 2.4 (thx monochrom !)
14:58:56 <maerwald> 2.4 isn't recommended
14:59:21 <sm[m]> ha ha they laugh at our non-recommendations
14:59:25 <monochrom> "cabal v1-sandbox init" still does things, 3.2.0.0
14:59:36 <sm[m]> there you go
14:59:42 <heebo> ok so without sandboxes dont you just end up clobbering your workspace with irrellevant libraries?
14:59:44 <monochrom> If my test is a bad test, let me know.
15:00:11 <sm[m]> heebo: cabal by default now uses "v2" commands which share libs nicely
15:00:13 <maerwald> monochrom: they are removed in 3.4.0.0-rc3
15:00:14 <monochrom> No heebo, "nix-style", so like what stack does
15:00:31 <monochrom> See? "which version?" was actually important.
15:00:53 <monochrom> But rc3 and alpha27 don't count.
15:01:12 <maerwald> 3.4.0.0-rc3 is gonna be out with ghc 9 most likely
15:01:21 <monochrom> You still can't go around and say "GHC has LinearTypes now" just because 9.0.1-alpha1 has it.
15:01:38 <monochrom> Well yes but we're still months before that.
15:01:44 <maerwald> there is no 9.0.1-alpha1 (it's not valid PVP, haha)
15:02:02 <monochrom> https://downloads.haskell.org/ghc/9.0.1-alpha1/
15:02:22 <maerwald> monochrom: it reports something different if you do `ghc --numeric-version` :p
15:02:46 <monochrom> https://mail.haskell.org/pipermail/haskell/2020-September/026044.html
15:03:29 <heebo> well is there any reason to use stack anymore?
15:04:07 <Cheery> Hey.. I think I have isolated my usage patterns of beautiful soup module.
15:04:15 <monochrom> Yes if you outsource GHC installation to stack so you don't think about it.
15:04:22 <monochrom> Yes if you like stackage's vision.
15:05:07 <Cheery> The obvious one is that I fetch stuff.
15:05:27 <maerwald> monochrom: https://gitlab.haskell.org/ghc/ghc/-/issues/2496
15:05:28 <Cheery> the next one is that I replace stuff with something else.
15:06:12 <monochrom> heebo: The new cabal semantics is at https://cabal.readthedocs.io/en/3.4/nix-local-build-overview.html
15:06:31 <Cheery> so for example, my code might be locating title and body of the document.
15:06:47 <Cheery> then it may do stuff to it, and reconstruct the document.
15:06:49 <monochrom> maerwald: Oh, that. Bug, like I thought.
15:07:13 <monochrom> Err wait, nevermind, 12 years ago? Haha.
15:07:26 <maerwald> It's still in deprecation phase
15:07:53 <sm[m]> heebo: stack vs cabal is still at least as big a division as before. stack still is better at some things but cabal is now also better at some things
15:08:04 <sm[m]> so you're fine using the one you prefer
15:08:47 <maerwald> stack has the worse philosophy, cabal the worse codebase. Now, I could have phrased that positively somehow...
15:09:28 <Guest56> I'm so h0rny now. Wanna trade. Add me here >> https://bit.ly/3iiA2Ef <<
15:09:36 <maerwald> nah, we're good
15:09:47 <monochrom> Well I'm OK with phrasing negatively such as "my course has the least difficult monad tutorial" because it is not goiing to be easy.
15:09:57 <sm[m]> heebo: there are.. partisans
15:10:09 --- mode: ChanServ set +o monochrom
15:10:13 --- mode: monochrom set +b *!*@gateway/web/cgi-irc/kiwiirc.com/ip.147.135.116.81
15:10:13 --- kick: Guest56 was kicked by monochrom (Guest56)
15:10:22 <maerwald> sm[m]: :D
15:10:32 <Rembane> maerwald: I guess cabal has too few coders, stack has too few philosophers and you have too few positivelers. I think this might be one of my worst puns.
15:10:33 <fresheyeball> hey out there
15:10:42 <fresheyeball> I am not a stack user and I have an issue
15:10:53 <fresheyeball> I need to get regex-pcre to build
15:11:02 <fresheyeball> https://gitlab.com/fresheyeball/Shpadoinkle-snowman/-/jobs/766428404#L1684
15:11:18 <fresheyeball> anyone know how to debug this?
15:11:20 <maerwald> fresheyeball: on windows?
15:11:27 <fresheyeball> linux
15:11:40 <heebo> i really dont care what the code base is like , i just want the tool that is easiest to use and most reliable
15:11:52 <heebo> i guess that makes me a phillistine
15:11:54 <sm[m]> fresheyeball: * Missing (or bad) C library: pcre
15:12:17 <sm[m]> it's a hard to pick out the signal from these build logs
15:12:31 <fresheyeball> how. did. you. see that?
15:12:48 <sm[m]> searched from the top for pcre
15:13:11 <hololeap> `Profunctor p => (b -> a) -> (a -> b) -> p a a -> p b b`
15:13:15 <hololeap> is there a name for this?
15:13:24 <sm[m]> if someone could make those errors more apparent, they would make a lot of haskell users happy
15:13:59 <maerwald> Rembane: hm well... the thing is... improving on philosophy is usually something that never happens. Improving on code... every few decades it happens
15:14:06 <dolio> dimap
15:14:28 <Rembane> maerwald: Yeah, I think that was my point, I didn't really tell it to anyone though
15:14:38 <hololeap> dolio: yeah, i know that one
15:14:47 <hololeap> also, are Arrows and Profunctors isomorphic to each other?
15:15:15 <dolio> No.
15:16:05 <hololeap> what is a good counter-example?
15:16:22 <Cheery> ok.. so now I think I start understanding what I want here.. First of all I got a document, then I got queries that selects portions of that document.
15:16:44 <EvanR> heh, if they were isomorphic, what nonsense could you cause
15:16:50 <Cheery> then when it's time to fetch, I would like to combine queries and run a "fold" on the document.
15:16:52 <EvanR> weird direction to go at it from
15:17:15 <Cheery> Another case is that I want to rewrite or replace contents in that document and reconstruct it.
15:17:37 <Cheery> is it possible that I should look into profunctor optics or lenses with this thing?
15:18:19 <Cheery> or is there some other notion of combining queries, then fetching with a query.
15:18:32 <Cheery> or well, combining fetches, then applying them in one fold.
15:18:37 <hololeap> well, there is the WrapArrow newtype, which seems to signify that any Arrow can become a Profunctor rather trivially
15:18:49 * hackage pointed 5.0.2 - Pointed and copointed data  https://hackage.haskell.org/package/pointed-5.0.2 (ryanglscott)
15:18:50 <dolio> Arrows are profunctors, but not vice versa.
15:20:01 <hololeap> i'm having a hard time imagining a counter-example
15:20:58 <fresheyeball> sm[m]: any idea how I can provide pcre to stack?
15:21:03 <fresheyeball> It is on the system
15:21:23 <hololeap> or maybe i don't understand the two concepts well enough
15:22:10 <EvanR> demonstrating "not isomorphic" would mean if you had a hypothetical isomorphism you could use it to make true = false or similar
15:22:11 <dolio> Well, it's probably relatively easy to produce a counter example with some sort of 'free profunctor on T :: * -> * -> *'.
15:22:53 <heebo> Cheery: it seems all of the above , you should be able to decompose and reconstruct html builders within the html builder monad
15:23:38 <dolio> Where T is allowed to be a GADT that only has values for certain choices of (pairs of) types.
15:23:41 <heebo> hololeap: being able to transform one way isnt isomorphic though
15:24:07 <dolio> The 'free' part would add the ability to map each side, but not the other arrow stuff.
15:25:00 <dolio> Arrows are actually the profunctor equivalent of monads.
15:25:33 <dolio> (Slightly beyond that, really, but close.)
15:26:24 <hololeap> huh, interesting stuff
15:27:53 <dolio> Because (->) is like an identity profunctor, so `(a -> b) -> P a b` is like the monad unit, and `P a b Ã— P b c -> P a c` is like the monad join.
15:29:28 <sm[m]> fresheyeball : in some non-standard place on the system ? probably you need the --extra-include-dir and/or --extra-lib-dir options
15:32:18 <fresheyeball> sm[m]: what would be the standard place?
15:33:13 <sm[m]> fresheyeball: I think it would find them automatically in either /usr/{include,lib} or /usr/local/{include,lib}
15:38:41 <hololeap> `P a b Ã— P b c -> P a c` seems more like <*>, although not exactly
15:40:12 <dolio> Well, looks are deceiving in this case. :)
15:41:02 <dolio> The way it works is that you can consider profunctors as generalizing functors. In this case, they generalize Type â†’ Type functors because both arguments are types.
15:42:24 <dolio> And the way you compose two profunctors is `(P . Q) a b = exists e. P a e Ã— Q e b`.
15:43:12 <dolio> (->) is the identity of that composition, because you can just pull it into the other profunctor by mapping.
15:43:56 <dolio> So arrow composition is `P . P => P` in this sense.
15:44:54 <hololeap> what does `P . P => P` mean?
15:45:37 <dolio> Natural transformation. Like `join : M.M => M` for monads.
15:45:55 <hololeap> oh ok
15:46:19 * hackage vty 5.31 - A simple terminal UI library  https://hackage.haskell.org/package/vty-5.31 (JonathanDaugherty)
15:47:19 * hackage language-dickinson 1.4.0.0 - A language for generative literature  https://hackage.haskell.org/package/language-dickinson-1.4.0.0 (vmchale)
15:48:11 <dolio> There are two ways (at least) to embed functors into profunctors. F goes to either `\a b -> (a -> F b)` or `\a b -> (F a -> b)`. And I think either way you choose will respect composition.
15:48:42 <dolio> So, the embedding of `F.G` is the embedding of F profunctor-composed with the embedding of G.
15:49:11 <dolio> Because again you can pull one of the function arrows into the other.
15:51:10 <dolio> The identity functor embeds to the identity profunctor (->). And one of the embeddings takes a monad to its kleisli arrow profunctor, which is an arrow/profunctor-monad.
15:52:15 <dolio> The other embedding flips things around so it probably takes a monad to a profunctor-comonad.
16:04:19 * hackage lift-generics 0.2 - GHC.Generics-based Language.Haskell.TH.Syntax.lift implementation  https://hackage.haskell.org/package/lift-generics-0.2 (ryanglscott)
16:04:54 <orzo> When using GADTs, it seems common to have functions pattern matching every GADT constructor but then using the same polymorphic code on the right hand side for each case.  There ought to be a way to write that as a single pattern match.  Something like _ except that it stands for any of a finite number of GADT cases.
16:06:20 <orzo> maybe we could abuse the BangPattern syntax and specify it as (foo !_ = polymorphic)
16:15:48 * hackage data-reify 0.6.2 - Reify a recursive data structure into an explicit graph.  https://hackage.haskell.org/package/data-reify-0.6.2 (ryanglscott)
16:44:19 * hackage intern 0.9.3 - Efficient hash-consing for arbitrary data types  https://hackage.haskell.org/package/intern-0.9.3 (ryanglscott)
17:02:46 <somek> hello 
17:03:13 <somek> i'm not speak english
17:03:48 * hackage happstack-authenticate 2.4.1 - Happstack Authentication Library  https://hackage.haskell.org/package/happstack-authenticate-2.4.1 (JeremyShaw)
17:04:16 <somek> i need help with some functions 
17:06:35 <sshine> :t show
17:06:37 <lambdabot> Show a => a -> String
17:06:47 <sshine> like that one?
17:07:00 <sshine> oh, he went.
17:07:02 <MarcelineVQ> he left right away :X
17:07:15 * sshine 's client ignores joins/parts on freenode.
17:07:31 <MarcelineVQ> my client ignores traffic laws
17:07:46 <sshine> what are traffic laws?
17:07:52 <MarcelineVQ> right?
17:07:55 <sshine> </anarchist>
17:08:22 <sshine> in other news: https://arxiv.org/pdf/1911.03449.pdf
17:12:13 <MarcelineVQ> Once I found out what a planar graph was that abstract sounded pretty neat
17:14:59 <sshine> I think the example of a planar graph I remember from school was borders of countries. except, of course, there is somewhere in germany or the netherlands where a tiny chunk of houses is annexed by a bicycle lane of the adjacent country.
17:15:15 <sshine> sorry, math.
17:15:50 <MarcelineVQ> weird, does germany have a history of annexing?
17:16:01 <sshine> annexing is me being bad at english.
17:16:41 <sshine> I meant separated.
17:18:09 <sshine> function MULTI-FLIP-LINKABLE(u,v). why are my functions never so good sounding.
17:30:19 * hackage exception-hierarchy 0.1.0.4 - Exception type hierarchy with TemplateHaskell  https://hackage.haskell.org/package/exception-hierarchy-0.1.0.4 (YoshikuniJujo)
17:45:04 <jackdk> sshine: https://www.youtube.com/watch?v=r-aIzkvPwFo there used to be a 3-rd order enclave: A part of India surrounded by Bangladesh surrounded by India surrounded by Bangladesh
17:45:33 <koz_> > read "01" :: Int
17:45:36 <lambdabot>  1
17:51:19 * hackage squeal-postgresql 0.7.0.0 - Squeal PostgreSQL Library  https://hackage.haskell.org/package/squeal-postgresql-0.7.0.0 (echatav)
18:16:48 * hackage dir-traverse 0.2.3.0 - Simple directory traversal library  https://hackage.haskell.org/package/dir-traverse-0.2.3.0 (vmchale)
18:22:47 <sshine> jackdk, oh god.
18:22:52 <sshine> s/god/lambda man/
19:57:07 <Turmfalke> Doesn't Data.Map have a function to combine two Maps with the same key but different value types?
19:58:42 <dolio> It does.
19:58:42 <ski> @hoogle (k -> v0 -> v1 -> v2) -> Map k v0 -> Map k v1 -> Map k v2
19:58:43 <lambdabot> Data.Map.Internal intersectionWithKey :: Ord k => (k -> a -> b -> c) -> Map k a -> Map k b -> Map k c
19:58:44 <lambdabot> Data.Map.Lazy intersectionWithKey :: Ord k => (k -> a -> b -> c) -> Map k a -> Map k b -> Map k c
19:58:44 <lambdabot> Data.Map.Strict intersectionWithKey :: Ord k => (k -> a -> b -> c) -> Map k a -> Map k b -> Map k c
20:01:54 <Turmfalke> Hhm, I'd need a union version of that
20:04:05 <Turmfalke> Thinking about it, my second map is always a subset of the first, so I could just map with a lookup function
20:06:21 <ski> @type M.mergeWithKey
20:06:24 <lambdabot> Ord k => (k -> a -> b -> Maybe c) -> (M.Map k a -> M.Map k c) -> (M.Map k b -> M.Map k c) -> M.Map k a -> M.Map k b -> M.Map k c
20:11:27 <Turmfalke> Oh, there's Data.Map.Merge
20:12:20 <Turmfalke> Thanks for the pointer
20:51:33 <sim590> I'm trying to convert the type `ChronicleT c Identity a` to `ChronicleT c Maybe a`. I thought to use `hoist` and  `generalize`, but `ChronicleT c` is not a MFunctor, so it doesn't work. Any idea?
20:52:06 <sim590> :t generalize
20:52:08 <lambdabot> error:
20:52:08 <lambdabot>     â€¢ Variable not in scope: generalize
20:52:08 <lambdabot>     â€¢ Perhaps you meant â€˜generateâ€™ (imported from Lambdabot.Plugin.Haskell.Eval.Trusted)
20:53:11 <sim590> Can we import modules with this bot? Anyway, I'm talking about Control.Monad.Morph.{hoist,generalize}.
21:02:05 <jackdk> sim590: either unwrap/rewrap the ChronicleT manually (unwrapping will give you an `Identity (These c a)`), or PR `monad-chronicle` (`mmorph` has a very slim footprint, so I hope an `MFunctor` instance would not be controversial.
21:02:08 <jackdk> )
21:03:38 <jackdk> `ChronicleT . generalize . runChronicleT` (well, `generalize = pure . runIdentity`, so you don't need the `mmorph` dep at all: `ChronicleT . pure . runIdentity . runChronicleT`
21:05:15 <sim590> hmmm. OK. Yeah I see. That's less complicated that I thought.
21:07:40 <sim590> I guess that I could make a PR addressed to chronicle for an instance of MFunctor. It's simple and that'd be useful for others. I guess it's simple and one could argue that it's not worth, but I think that it's beneficial since it's standardizing the approach with mmorph and making things more concise.
21:09:53 <sim590> jackdk: thanks for your explanation!
21:18:19 * hackage ease 0.1.0.2 - Robert Penner's easing equations  https://hackage.haskell.org/package/ease-0.1.0.2 (fresheyeball)
22:07:49 * hackage optparse-generic 1.4.4 - Auto-generate a command-line parser for your datatype  https://hackage.haskell.org/package/optparse-generic-1.4.4 (GabrielGonzalez)
22:27:47 <hololeap_> i came up with this for the purpose of helping deal with partial pattern matches: https://dpaste.com/H2ALPHDZW
22:30:01 <hololeap> is there already something well-established that does something similar? this basically turns the problem into a monoid
22:30:57 <hololeap> which is a good solution (imo) but can be awkward to work with
22:33:05 <dminuoso> I love how the more advanced code becomes, the less actual value level code is written, and the more sneaky things are being done at the type level, or very implicit things like deriving-via in your case.
22:33:27 <dminuoso> There's more type signatures, import statements and language pragmas than actual code being written..
22:35:14 <tzh> are there any FRP frameworks that generate a final value that's `MonadIO m => m ...`? i've been using reactive-banana, but its constraint that it can only handle `IO` as its monad doesn't play well with `GPipe`, which generally produces values in some ContextT monad transformer that's instanced to MonadIO
22:36:09 <tzh> so all the rendering actions produce values typed like `ContextT ... ... IO a` which i can't actually use in the FRP framework
22:36:36 <hololeap> dminuoso: i like that too. or are you being sarcastic /:|
22:43:36 <hololeap> tzh: if the final value is `IO a`, then you can lift that to `MonadIO m => m a` using `liftIO`
22:44:55 <hololeap> you just have to wrap the whole thing in liftIO and you're done
22:45:31 <tzh> hololeap: oh i guess i should be more specific about the issue; it's that reactive-banana has a function `reactimate :: Event (IO ()) -> MomentIO ()` and that's the only way to actually 'run' events (by fmapping or otherwise turning an `Event a` into an `Event (IO ())`)
22:46:05 <tzh> and since it can only take IO events it can't take GPipe's more complex MonadIO-instanced types
22:46:21 <hololeap> you could try reflex, which does things differently and might sidestep the problem altogether
22:46:59 <tzh> sure, i'll check that out
22:47:35 <hololeap> but, with IO in a negative position, you can't use a `MonadIO m` there
22:47:43 <hololeap> as you've probably figured out
22:48:32 <tzh> yeah
22:51:18 <hololeap> tzh: can you give an example of the gpipe function you're trying to plug in there?
22:54:36 <hololeap> if it returns a ContextT, you could just use runContextT with IO as m to get the whole thing back in the IO monad
22:56:00 <tzh> hololeap: so gpipe wraps up basically all of its opengl actions in a big `ContextT ctx os m` wrapper, so things like https://hackage.haskell.org/package/GPipe-2.2.5/docs/Graphics-GPipe-Shader.html `compileShader` there, or https://hackage.haskell.org/package/GPipe-2.2.5/docs/Graphics-GPipe-Buffer.html `writeBuffer` there
22:56:28 <tzh> i guess i have always considered that to be some atomic type i shouldn't really touch, but i guess there's no reason why i couldn't unwrap it myself
22:57:44 <hololeap> where does it usually get unpacked?
22:58:36 <tzh> in my code i just run everything in the context and then my main is just `runContextT defaultHandleConfig $ do ...`
22:59:12 <tzh> given that it uses that unifying type variable `os` i'm not sure if i can break things up sufficiently to make it work nicely with reactive-banana though
23:00:25 <hololeap> should work fine, i would think
23:00:56 <hololeap> but you would have to run runContextT every time the event fired
23:01:12 <tzh> yeah
23:01:16 <hololeap> i'm not familiar with gpipe beyond knowing it exists and what it's for
23:01:56 <hololeap> are you using this event to refresh the screen?
23:02:02 <tzh> hah right. yeah, i'm not entirely sure if that would work but it's an avenue that i should look into that i just hadn't ever thought of
23:03:35 <tzh> i'd _like_ to be able to send in some 'render' event into the frp network 60 times a second or w/e based on some external timer, but right now since i'm not running render events in the event network itself the code is kind of a mess since i have to have a separate timing loop with some synchronizing variables
23:03:38 <tzh> and it's kind of a mess
23:04:01 <hololeap> what are you using frp for?
23:04:18 <tzh> handling inputs mostly
23:04:50 <tzh> those are getting pushed into the network and turned into updates to a game info mvar kinda type, which in turn is read by the rendering loop
23:05:04 <tzh> which is not exactly how frp is intended to be used as i understand it :V
23:11:19 <hololeap> tzh: i wouldn't have frp doing much other than controlling some kind of state using user input, and have it on its own thread apart from most of the gpipe stuff. you can use MVar, TMVar, etc. to communicate between the threads.
23:13:21 <tzh> hololeap: the problem i'm having with that is that my timesteps are getting messed up. if i poll the time outside of the event network, its values are actually 'back in time' compared to values happening 'at the same time' within the event network, presumably due to some differences between logical vs. actual time
23:14:03 <tzh> which leads to things like animations being messed up because the time given to a frame being render happens 'before' the time stored in the data structure
23:14:49 <tzh> so i'd have to, like, poll the time 60fps or something and fire that into the event network anyway, or something like that, to get a monotonic time value that's also up-to-date for each frame
23:16:52 <hololeap> yes, that is what you should do
23:17:20 <hololeap> fire the event on each frame
23:18:55 <tzh> yeah i guess that makes sense. still requires some restructuring of the game logic but probably not as much as totally rewriting the render/frp interface
23:22:37 <hololeap> maybe take a look at
23:22:38 <hololeap> https://github.com/Twey/gloss-banana/blob/master/Graphics/Gloss/Interface/FRP/ReactiveBanana.hs
23:23:03 <hololeap> it uses gloss, which simplifies the rendering quite a bit, but you might get some clues from there
23:24:22 <tzh> yeah i'll take a look
23:25:47 <tzh> it's actually been a while since i touched this part of my code so i was just idly thinking for solutions, but when i get back to digging into the rendering+timing guts this looks like it'll help
23:26:46 <tzh> it looks like gloss provides a callback for tick handling, and so this just hooks that up into sending time messages into the network?
23:28:48 <tzh> so i guess i'd just have to run my own timing loop based on some target-fps value and use that to push 'canonical' times into the event network, and then have the rendering loop render and pause, or something. although i guess that still has the timing issue, since to know how long or if the rendering loop should wait it would need to poll time from outside of the event network
23:30:22 <hololeap> i've seen how this is done with gloss. it has a playIO function which takes a (s -> IO Picture) which it internally runs every frame
23:31:33 <tzh> right, but how does it determine internally when it's time to render a new frame?
23:31:51 <tzh> or is the answer just "any time has passed"
23:33:56 <hololeap> is there some way with gpipe to create a function that calls an IO action, which produces the output, on every frame?
23:34:50 <hololeap> because this can be the `Behavior Picture` equivalent that your network produces
23:35:23 <tzh> i mean, gpipe is only a rendering library; if i want something to happen every frame i have to make that happen myself. like, i have a function that does the draw calls and swaps the buffers, that kind of thing, it's just the question of how to give that a time value that's meaningful in the context of the current game data
23:36:01 <hololeap> i see
23:38:27 <hololeap> i think you would need to set up the timer seperately, which would poll the frp network and render the frame on every tick
23:38:45 --- mode: ChanServ set +o Sigyn
23:40:22 <tzh> yeah i'll probably have to think about this more while actually working on my timing code
23:40:33 <tzh> but i have a few more ideas now at least so that's been helpful
23:41:12 <hololeap> you can also ask on #reflex-frp. they may have some general ideas even though you're using reactive-banana
23:42:19 <hololeap> and look at the gloss codebase too, since it uses gl internally
23:48:00 <tzh> yeah
23:48:14 <tzh> in the mean time, it's late so i should get to bed. ty for the help!
23:50:20 <hololeap> np
