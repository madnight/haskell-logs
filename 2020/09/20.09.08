01:08:29 <dibblego> @djinn (a -> b) -> (t -> a) -> (t -> b)
01:08:29 <lambdabot> f a b c = a (b c)
01:12:02 <[exa]> @pl \a b c -> a (b c)
01:12:03 <lambdabot> (.)
01:16:50 * hackage cabal-plan 0.7.1.0 - Library and utility for processing cabal's plan.json file  https://hackage.haskell.org/package/cabal-plan-0.7.1.0 (phadej)
01:19:26 <cheater> well
01:19:32 <cheater> at least the int debacle is over
01:33:29 <[exa]> cheater: int debacle?
01:34:14 <cheater> someone was Very Upset about Int :: maxBound
01:34:58 <maerwald> Int :: maxbound?
01:36:04 <merijn> cheater: Why?
01:36:23 <cheater> scroll up and read for yourself
01:36:32 <merijn> I can't :p
01:36:42 <cheater> it was xsperry
01:36:46 <cheater> welp
01:36:54 <cheater> too bad, i guess it's lost forever :p
01:37:33 <int-e> Oh, drama. It all went awry when they started saying that C handles this better than Haskell... probably before that, but that comment kind of stands out :)
01:38:35 <int-e> One thing is disappointing though... nobody pointed out -fwarn-overflowed-literals
01:38:40 <cheater> the highlight for me was when he started lecturing me about what is and isn't good for cryptography
01:39:06 <maerwald> Haskell for cryptography is questionable though
01:39:11 <maerwald> but not sure if for that reason
01:39:33 <int-e> ah, I'm looking for the wrong option name. <ClaudiusMaximus> -Woverflowed-literals
01:39:49 <int-e> Okay, I'm no longer disappointed. :)
01:40:11 <merijn> To be fair, fromIntegral is a fucking mess
01:40:17 <cheater> maerwald: good news! $x for cryptography is questionable forall $x
01:41:31 <int-e> merijn: wait till they discover realToFrac...
01:41:48 <int-e> > realToFrac (1/0 :: Float) :: Double
01:41:50 <lambdabot>  3.402823669209385e38
01:42:00 <cheater> wait til he discovers float literals
01:42:07 <cheater> that'll be magic
01:42:11 <merijn> Float literals are fine
01:42:24 <cheater> hahahahaha
01:42:26 <merijn> > 0.2 + 0.1 :: Deci
01:42:28 <lambdabot>  0.3
01:43:00 <merijn> > 0.971 + 0.029 :: Milli
01:43:02 <yushyin> merijn: https://paste.xinu.at/8qn/plain I can be your backlog <3
01:43:02 <lambdabot>  1.000
01:43:19 <int-e> (that realToFrac thing becomes +Inf when compiled with optimizations)
01:43:20 <merijn> cheater: Float literals != float/double in Haskell
01:43:50 <merijn> And realToFrace is also a huge mess
01:44:05 <cheater> realToFarce
01:44:10 <int-e> (And, sadly, that is *sane*; it's the default realToFrac implementation that is insane.)
01:44:13 <merijn> fromIntegral is such a mess that even GHC developers can't get it right inside the RTS >.>
01:44:42 <maerwald> cheater: nah, there are structural differences
01:45:19 <maerwald> cheater: one of the main problems is that, in cryptography, you want to know *precisely* what happens in memory (and how long it takes). In haskell, that's not easy for many reasons
01:45:24 <maerwald> Including the evaluation model
01:45:48 <merijn> maerwald: I'd argue that Haskell + Ptr makes it easier than C
01:45:51 <maerwald> There's been some research about some of those problems, but there is no crypto implementation that factors in that research
01:46:00 <merijn> The C abstract machine makes that reasoning impossible
01:46:02 <maerwald> All haskell crypto libraries are *naive*
01:46:11 <cheater> C doesn't make that reasoning possible either
01:46:14 <cheater> and neither does asm
01:46:18 <cheater> so what are we talking about
01:46:25 <cheater> it's all just pure guesses and lucky draws
01:46:26 <maerwald> cheater: that's not true
01:46:31 <merijn> asm is possible
01:46:38 <merijn> Hard, but possible
01:46:57 <arahael> asm is *fun*.
01:46:58 <c_wraith> I like that DJB created his own private language just to write crypto code without the compiler messing it up.
01:47:21 <merijn> c_wraith: That sounds right
01:47:36 <merijn> Also, see Ivory
01:49:21 <kuribas> merijn: what's wrong with fromIntegral?
01:49:26 <lordgrenville> Hi, I was asking here the other day about this program to transcribe a dna string to an rna string
01:49:51 <merijn> kuribas: It's completely impossible to reason about when it is or isn't lossless
01:50:11 <merijn> So you never know when it's safe to use
01:50:16 <maerwald> kuribas: https://mail.haskell.org/pipermail/libraries/2020-August/030671.html
01:50:17 <lordgrenville> rule is replace with correct letter and return string, but if you encounter an invalid character then just return that char
01:50:19 <cheater> maerwald: tell this to everyone who has had cryptographic bugs in their asm code
01:50:24 <maerwald> kuribas: there was a debacle :p
01:50:33 <int-e> kuribas: people can't decide which property is worse, the fact that fromIntegral truncates when going from a larger to a smaller type, or that it's not a homomorphism when going from a smaller type to a larger type ;-)
01:50:40 <lordgrenville> so here it is done correctly: https://pastebin.com/CJZKqHWX
01:50:42 <maerwald> cheater: ok
01:50:58 <cheater> anyways the obvious approach to writing crypto code in haskell is to write a code generator frontend to llvm
01:51:08 <merijn> cheater: Ivory :p
01:51:13 <lordgrenville> but I don't know miuch about mapM, so was trying to do it in a dumber way, just with pattern matching/recursion, like this https://pastebin.com/biMu2v3Q
01:51:14 <cheater> writing it in haskell doesn't necessarily mean running it on ghc
01:51:33 <lordgrenville> some people here the other day were telling me it was doable, but I'm still a bit stuck
01:51:36 <maerwald> cheater: that's all nice and well, look at the everest project
01:51:56 <arahael> cheater: llvm doesn't strike me as a neccessarily simple environment for crypto code.
01:51:57 <maerwald> that's not a small project and haskell isn't your first choice of language for that
01:52:10 <arahael> cheater: Especially when you're trying to avoid timing attacks.
01:52:13 <cheater> arahael: it's just about compilation.
01:52:23 <maerwald> https://project-everest.github.io/
01:52:24 <cheater> then use some other compiler if you'd like
01:52:47 <cheater> the approach is still valid
01:55:24 <kuribas> int-e: what do you mean?
01:55:43 <kuribas> merijn: how could it be other than lossy?
01:55:50 <kuribas> merijn: you mean throwing an error instead?
01:56:22 <merijn> kuribas: The fact that something "could be lossy" is not the same as is
01:56:47 <merijn> kuribas: Simple question: Can I safely convert Int to CInt? That's something you commonly need to do and the answer is "you have no idea"
01:56:54 <merijn> On most machines, probably
01:57:13 <merijn> But I wanna be sure at compile time that I get an error the conversion is lossy
01:57:23 <merijn> Not throw an error
01:57:37 <merijn> I want compile time guarantees about conversion and explicit functions for lossy conversion
01:58:03 <int-e> kuribas: I'm mostly joking. But it is true that fromIntegral :: Word64 -> Word32 is a ring homommorphism (but may lose information) while fromIntgral :: Word32 -> Word64 is not (but it does preserve information).
01:58:35 <kuribas> merijn: ok, so you want a multiparam typeclass which is only lossless
01:58:36 <merijn> kuribas: This specific problem caused a bug in the GHC RTS and the (code reviewed) fix, turned out to be buggy again in a different way
01:58:50 <merijn> And the fix of the fix was *again* buggy
01:58:58 <merijn> despite again code review by GHC committers
01:59:03 <kuribas> merijn: isn't that more because the RTS is low level?
01:59:08 <merijn> It took a 3rd fix before the problem was finally fixed
01:59:19 <merijn> kuribas: No, this was literally a Int to CInt conversion bug
01:59:32 <merijn> That despite 3+ people looking at it was fixed wrong *twice*
01:59:44 <merijn> That alone should be enough argument for fromIntegral being shite
01:59:56 <kuribas> or it's used wrongly?
02:00:08 <merijn> kuribas: What do you propose as alternative?
02:00:15 <merijn> There is no other conversion function
02:00:24 <kuribas> I don't know about this CInt problem though...
02:00:37 <kuribas> but you must always be careful when doing conversions.
02:01:18 <merijn> kuribas: If expert Haskell people who are also good at low level stuff can't get it right, then "being careful" isn't enough
02:01:36 <merijn> That's the same nonsense justification people use for all of C's tricky bs
02:01:47 <merijn> The Habit Language report already proposed better alternatives
02:01:55 <merijn> So we know how to design better solutions
02:02:10 <kuribas> in f* you can write provable correct low level code
02:02:22 <maerwald> F* is awesome
02:02:42 <maerwald> and a much better fit for such things than haskell
02:02:47 <merijn> kuribas: And why can't we have better tools for that in Haskell?
02:03:00 <kuribas> merijn: what would *you* propose?
02:03:05 <maerwald> merijn: we can't have any good tools for haskell :p
02:03:21 <nitrix> That'd be illegal.
02:03:23 <merijn> kuribas: Something like what the Habit Language report proposes :p
02:05:25 <kuribas> I like fromIntegral as something which is efficient, but used at your own risk.
02:06:17 <merijn> Why does safe imply inefficient?
02:06:24 <kuribas> Changing it now would break a lot of code, so it should be something additional then.
02:06:30 <merijn> All you need to know are compile time bounds of the types
02:06:36 <kuribas> merijn: idk, I haven't read the Habit report yet :)
02:07:04 <kuribas> merijn: for my db language I was thinking to add different addition types.
02:07:32 <kuribas> merijn: like provable not overflowing, wrap-around, etc...
02:07:53 <kuribas> in lisp an overflowing fixnum gets promoted to a bignum.
02:07:55 <merijn> kuribas: Habit was intended to be "systems Haskell" so they have explicit notions of "sizes" for types which means the compiler can trivially check whether two types have the same size or not
02:08:07 <kuribas> right
02:09:01 <merijn> And I don't see why we couldn't have such a check now and at least warn, even if we don't change fromIntegral
02:09:06 <PropositionJoe> It must be said, the Either/Maybe types are very annoying.
02:09:30 <merijn> PropositionJoe: Why?
02:09:40 <merijn> They're amazing
02:10:02 <PropositionJoe> I dont see how they are useful and I always fuck up using them.
02:10:22 <PropositionJoe> (I'm doing a haskell course, I'm forced to use them.)
02:10:47 <merijn> PropositionJoe: You don't see how, say, reporting whether a key in a Map has a corresponding value is useful?
02:11:10 <merijn> PropositionJoe: Like, if something produces a result or an error, how else do you propose returning that?
02:12:48 <PropositionJoe> Hm, Python just throws an error, C++ you usually return null, -1 or something√∏
02:13:04 <merijn> PropositionJoe: How is null better than Nothing?
02:13:18 <merijn> Hell, how is it different?
02:13:40 <merijn> The only difference is that you can to forget to check for null
02:13:53 <merijn> Which I'd say isn't really a benefit
02:15:20 <PropositionJoe> I was mostly joking, not in mood for battle. Rest assured that you have defended the honor of Either/Maybe.
02:20:56 <kuribas> PropositionJoe: in Python you "just throw an error", then catch it and silently swallow potential problems.
02:21:51 <kuribas> PropositionJoe: that's not just theoretical, I had this problem in Python code.
02:22:45 <kuribas> swallowing doesn't mean solving them, just propagating them so they will cause an unwanted effect somewhere else, and are much harder to find.
02:24:01 <yushyin> or you don't and just crash at runtime
02:26:16 <kuribas> the practice of using exceptions for everything in Python is disgusting
02:26:49 <merijn> When all you've got is a hammer :p
02:27:21 <olle> kuribas: OCaml uses exception for program flow in some of the std lib. It is frowned upon :D
02:27:35 <olle> They're patching it with new functions.
02:31:54 <arahael> kuribas: For everything and everything in python. It's quite insane.
02:32:25 <arahael> kuribas: Including all three or so exceptions that all mean StopIteration.
02:36:38 <dminuoso> There's nothing wrong with using exceptions-the-language-feature for program flow. Critics seem to often conflate "errors", "exceptional/unrecoverable/unexpected error conditions" and "code short circuiting"
02:38:35 <dminuoso> exceptions-the-language-feature are just non-local jumps usually, similarly to how `if-then-else` in imperative languages give you local jumps.
02:39:20 <kuribas> what's disgusting is using it for cases where you can perfectly use other constructs, like an simple if expression.  I am not advocating against exceptions.
02:39:59 <kuribas> But most of the uses I saw in Python didn't need exceptions at all.
02:40:13 <kuribas> Perhaps only to make up for the lack of expressivity in the language.
02:42:33 <dminuoso> The only reason we get to look down on that, is because we're trained to think of short circuiting as an effect we can bury in >>='s implementation.
02:43:29 <dminuoso> But at the end, it's just an implementation detail.
02:45:17 <dminuoso> I mean yeah, if a simple local if/then/else in your python code suffices, chances are exceptions-the-language-feature are a bit overkill and not needed. But I dont think they are overused in that sense much.
02:47:53 <kuribas> dminuoso: I am not just overkill, it's also preventing you from catching actual errors.
02:48:04 <dminuoso> What do you mean?
02:48:59 <kuribas> I mean, you put a catch KeyException to see if a value is missing from the map.  But that would also catch keyexceptions which aren't meant to be catched.
02:49:13 <kuribas> because they are thrown in the same scope.
02:49:39 <kuribas> But because an exception handler goes over the whole scope you don't see the origin of the error.
02:50:13 <dminuoso> kuribas: That's your own fault, rather. Yo
02:50:20 <dminuoso> Oops wow. What happened there
02:50:20 * hackage niv 0.2.17 - Easy dependency management for Nix projects  https://hackage.haskell.org/package/niv-0.2.17 (nmattia)
02:50:22 <dminuoso> kuribas: You can just use .get instead. 
02:50:33 <kuribas> dminuoso: I mean, that's what I am saying right?
02:51:02 <dminuoso> Well, its your choice to defer catching the exception. Right?
02:51:48 <dminuoso> If you did `try: x = foo[blah]; catch KeyError as e: ...` there's nothing wrong.
02:52:30 <kuribas> dminuoso: maybe...
02:52:36 <kuribas> dminuoso: only if foo is a variable
02:53:04 <kuribas> and if blah is a variable
02:53:26 <kuribas> but foo may be a function masking as an attribute for example
02:53:41 <kuribas> another crazy Python feature
02:53:51 <dminuoso> Surely the real problem here is "functions masking as an attribute" then, no?
02:54:29 <dminuoso> I mean if code isn't obvious in what it does or how it works, that's the problem. In some sense this is related to exceptions, but only in that you generally have poor documentation into what exceptions *can* be thrown
02:54:36 <dminuoso> And pythonistas have, generally, poor exception hygiene
02:54:41 <dminuoso> But truth be told, Haskell is no different in that regard.
02:55:19 <dminuoso> A huge portion of hackage is filled with undocumented IO exceptions, or packages not setting up their own exception hierarchies and just throwing IOException in your face. Without documentation
02:56:01 <kuribas> dminuoso: it's the combination of using Exceptions when it's not appropriate, and the implicit nature of Python code.
02:56:18 <dminuoso> When is it appropriate to use an exception?
02:56:25 <dminuoso> Surely always when you want shortcircuiting semantics.
02:56:42 <kuribas> dminuoso: and indeed, Exceptions are not that nice in haskell.  I think it's the one thing java did better :)
02:57:49 * hackage hanabi-dealer 0.10.1.0 - Hanabi card game  https://hackage.haskell.org/package/hanabi-dealer-0.10.1.0 (SusumuKatayama)
02:58:05 <kuribas> dminuoso: and yes, it would be ok if the language would have been clean, and the Python community well educated in Exception hygiene, but neither don't seem to be the case.  At least not the team I worked with...
02:58:41 <kuribas> dminuoso: agreed, that's when you should use them.  
03:09:02 <kuribas> dminuoso: the problem with your example is that it's so easy to violate the invariant.
03:09:19 <kuribas> dminuoso: just adding foo[blah + 1] can break it.
03:09:30 <kuribas> of foo[blah] + "abc"
03:10:38 <kuribas> dminuoso: I really wish haskell had exceptions in the type.
03:10:51 <kuribas> dminuoso: but how would that work with pure functions?
03:21:34 <fog57> http://people.eecs.berkeley.edu/~sylvia/cs268-2013/papers/spanning-tree.pdf
03:36:02 <merijn> kuribas: I have ideas!
03:36:23 <merijn> kuribas: Sadly, due to the sad state of academic funding they will likely never see the light of day :p
04:02:29 <maerwald> merijn: get funding by big companies :p
04:02:36 <maerwald> just need to sell your ideas better
04:04:38 <merijn> maerwald: The big companies want you to work in their offices and moving internationally is out of the question for me
04:05:45 <maerwald> merijn: nah, lots of remote companies now
04:08:37 <maerwald> And lots of them full of academics too. The problem aren't the jobs, but the competition :p
04:10:12 <maerwald> If you check out e.g. haskus libraries wrt open variants you can see they clearly have a need for better error handling and put quite some manpower into it.
04:10:54 <maerwald> or join one of those excellent consulting companies :p
04:11:49 <merijn> maerwald: I bet they aren't interested in backwards incompatible changes to GHC :p
04:12:40 <phadej> consulting companies are proxies for wishes of their clients
04:13:05 <dminuoso> And employees are proxies for wishes of ther employers. :p
04:13:12 <maerwald> sell wishes, then do consulting to satisfy those :p
04:13:49 <phadej> (sometimes consultancies do look for clients to pay for some work, but I guess that's not the common case)
04:14:39 <phadej> i.e. "we have this idea, and we know how to do it, but someone have to pay for it"
04:15:13 <phadej> which I guess the merijn's problem :)
04:15:21 <phadej> is*
04:15:30 <merijn> Except I'm not even sure I know how to do it ;)
04:15:41 <phadej> s/know/think we know/
04:30:39 <tdammers> it generally only really works out when the idea you had is something a client would have wanted anyway, if only they had known it could be a thing
04:31:00 <maerwald> tdammers: does well-types have sales ppl for ideas? :p
04:31:30 <maerwald> corporate visionaire
04:31:31 <tdammers> not really, no. we don't have any specialized sales people at all, just people who do all sorts of management stuff, including acquisition / sales
04:31:46 <dminuoso> tdammers: Not really. That's the art of start ups, finding investors willing to give you their money to implement that idea they dont want or need.
04:32:04 <tdammers> dminuoso: well, but that's just the same thing with a couple proxies in between
04:33:02 <tdammers> dminuoso: i.e., instead of "find someone rich who needs this right now", it's "find someone rich who can be convinced that enough people will want this at some point to become profitable eventually"
04:33:29 <dminuoso> Fair enough
04:34:05 <tdammers> and with VC, there's usually another level of indirection: "find someone rich who can be convinced that once we build this, some other rich person can be convinced that enough people will want this at some point to become profitable"
04:38:01 <merijn> I don't wanna build "stuff people want", though
04:38:11 <merijn> I want to build "stuff people *should* want"
04:38:46 <maerwald> There's no difference in sales :p
04:39:27 <merijn> there is
04:39:38 <merijn> Because people don't want what they should want
04:39:52 <merijn> Which makes the convincing step hard :p
04:40:39 <phadej> step 1. convince people that they don't want use macs for development
04:40:44 <phadej> there is no further steps.
04:41:35 <phadej> if that's is too bold, then another take "convince people to not use systems with case-insensitive file systems for development"
04:41:56 <merijn> pffft
04:42:09 <merijn> How about "let's ditch all this unix legacy garbage"
04:42:33 <phadej> what's left then, windows? :)
04:43:18 <Uniaika> ew
04:43:42 <hodapp> use Xinu
04:43:43 <opqdonut> aren't they reimplementing unix legacy garbage in windows?-)
04:43:51 <phadej> opqdonut: touche
04:43:52 <maerwald> hey, windows is batteries included (and they leak acid)
04:43:53 <Axman6> I'm going to keep using my mac thanks
05:02:10 <merijn> tbh, there's a bunch of design decisions in Windows that are a lot more sensible than unix :p
05:02:42 <davve> really?
05:03:15 <merijn> phadej: Well, the non-unix alternatives systems aren't implemented, because no one wants them :p
05:03:48 <phadej> It's hard to imagine any kind of macro-level shift in this industry
05:04:10 <merijn> davve: I really don't get this meme about windows being shit, microsoft's engineering has been pretty solid for ages. Even back when windows crashed every 5 minutes it was (for the vast majority) 3rd party drivers shitting bed and not windows
05:04:43 <merijn> davve: The main reliability improvements in windows of the past 3 decades are microsoft becoming *much* more strict about what they will allow 3rd parties to do in kernel space
05:05:13 <phadej> Windows is not bad, plenty of bad karma is because it doesn't behave (give some guarantees, etc.) like unixes
05:05:17 <merijn> The original windows design (naively) assumed that people writing kernel space code would be careful what they wrote/put in there, but that was clearly optimistic off them
05:05:32 <merijn> Right
05:06:00 <merijn> Most of the "windows is bad" complaints are just "I can't run my posix code unchanged because posix makes different assumptions"
05:06:00 <phadej> e.g. recent GHC segfaults on windows is due Windows being more strict
05:06:05 <phadej> so lazy code is not ok anymore :)
05:06:15 <phadej> lousy*
05:06:55 <phadej> the Windows "fault" is that debugging these issues are hard
05:07:16 <phadej> An example what I like about windows:
05:07:20 <merijn> davve: For all the ragging people do on windows, did you never notice how almost none of it ever included any actual technical description of these supposed "bad engineering"/"bad design"?
05:07:28 <phadej> windows actually have a filesystem API which doesn't do any desugaring
05:08:00 <phadej> afaik, all unix apis will (try to) resolve /foo/../bar filepaths
05:08:05 <merijn> Giving the filesystem an explicit encoding for paths was the obvious right solution to encoding problems and unix fucked up
05:08:24 <merijn> Defining paths as "just bytes" is and was a terrible idea
05:08:50 <merijn> You lose any ability to reliably render paths
05:09:34 <phadej> mac is nice, as it does NFKD (or some other) normalizing to paths
05:09:36 <phadej> but not always :)
05:09:59 <phadej> you might get erros "f√∂√∂ is not f√∂√∂"
05:10:01 <merijn> phadej: Except the new FS which handles it in the cocoa bindings, rather than the kernel. Which is also a stupid regression
05:10:35 <phadej> merijn: cocoa is a UI toolkit, isn't it?
05:10:57 <merijn> phadej: Well, some other toolkit then, one of those app toolkits anyway
05:11:32 <merijn> People should've just revised posix and defined all paths as utf-8 and then 99% of all code would've worked fine unchanged and we would at least have a principled and systematic solution
05:12:26 <noctux> merijn: well, windows had (and maybe still has) a pretty nice and well engineered internal kernel architecture, and ntfs was a very well developed filesystem for the time
05:13:11 <noctux> but there are several "interesting" decisions there as well, and that cruft has accumulated. font rendering in kernel space, or an http server for instance :P
05:13:20 <merijn> noctux: Like, I'm not saying windows is a flawless pinnacle of design. Just that it's on the "above average" side of the bell curve and on average generally solid engineering trade offs
05:13:41 <merijn> noctux: Sure, there's all sorts of legacy cruft too and compatibility hacks
05:14:17 <merijn> But some people seem to like to pretend that the linux kernel is somehow "superior engineering". These people have clearly never looked at the actual linux kernel >.>
05:14:59 <phadej> linux kernel engineering doesn't have to do anything with problems in posix spec though
05:15:01 <noctux> a lot of people (including me) have probably never looked at the NT-Kernel either...
05:15:21 <arw> well. upper/lowercase matching for filenames while case-preserving, but not really observing locale conventions is a pretty weird issue. especially together with unicode, where there is a lot more than just plain ascii 'toggle a bit to uppercase'...
05:15:53 <merijn> arw: "everything is just bytes on unspecified encoding" is strictly worse, though
05:15:55 <arw> and then there is the tons of layers of libraries that behaves differently from the kernel in that respect
05:16:05 <merijn> s/on/of
05:16:31 <arw> merijn: not sure. it is simpler and prevents a lot of problems as well.
05:16:51 <phadej> if and only if programs treated paths as raw bytes
05:17:00 <phadej> and didn't give them any "textual" semantics
05:17:01 <merijn> arw: That's a nice theory, except you made it literally impossible to reliably display paths to users
05:17:31 <arw> merijn: displaying always works. copy-and-paste won't.
05:17:37 <merijn> arw: No it won't
05:17:53 <phadej> you might have two filepaths which looks the same, but are different :)
05:18:17 <arw> phadej: yes, but that is always the case if you allow any kind of unicode homoglyphs anyways.
05:18:25 <merijn> arw: How do you know how to show a path encoded as UTF-16 sequence?
05:18:42 <merijn> arw: Just render it as ascii?
05:18:52 <arw> merijn: in the most extreme case, as a sequence of replacement characters or escape sequences.
05:18:52 <merijn> That's not gonna produce sensible output, since it's not ascii
05:19:02 <merijn> arw: How would you know what to replace?
05:19:10 <merijn> You have no clue what that data is
05:19:28 <phadej> arw: https://unicode.org/reports/tr15/
05:19:48 <phadej> even inside a single encoding, there are by-byte different representations of the same text
05:19:49 <merijn> arw: And now I run ls in a directory where one file is UTF-8, the other is UTF-16 and another is some obscure CJK encoding. Good luck.
05:20:16 <arw> phadej: yes, i know, normalization and stuff.
05:20:57 <merijn> arw: The current approach is to "just use whatever encoding the user locale says"
05:21:16 <maerwald> merijn: thank god posix *suggests* to only use chars from the portable character set for filenames, lol
05:21:19 <arw> phadej: but "the same text" is even more involved, because locale-sensitive comparisons encompass a lot more than just unicode normalization. e.g. german √§ == ae (often, but not always...)
05:21:22 <merijn> arw: Which is clearly a dumb solution since a single system can have many users with completely different locales making files on a single namespace
05:21:45 <maerwald> suggestions in standards have always been useful
05:22:08 <merijn> maerwald: That's some lame-ass responsibility dodging nonsense right there
05:22:24 <arw> merijn: yes. but windows paths might save the encoding per filesystem. but they don't save the users locale. which causes all kinds of problems as described, but really solves none. because comparisons for humans NEED a locale.
05:23:07 <arw> merijn: so windows is in the broken in-between between a real solution and a simple solution.
05:23:16 <merijn> arw: If you have a known encoding you can render it in any locale on-demand
05:23:32 <arw> merijn: for rendering that is correct. 
05:24:01 <arw> merijn: but only if you do not use a CJK locale.
05:24:19 <arw> merijn: otherwise you need to select a font based on whether you are currently in C, J or K :)
05:24:49 <phadej> fwiw, this discussion is an evidence why things don't change ;)
05:24:56 <phadej> for better or worse.
05:25:28 <phadej> all systems have so big userbases, that fundamental changes are near impossible
05:26:19 <phadej> who knows, maybe iran has a space agency which uses in-country developed OS where filesystem stuff is done right
05:26:34 <phadej> you know, right-to-left is completely new dimension
05:27:43 <phadej> (my brain explodes, when I try to understand how mixed language text should be rendered)
05:28:00 <davve> merijn: im not one to rag on windows, i just dont like it. i don't feel productive
05:28:34 <phadej> davve: how much of that is unfamiliarity
05:28:41 <phadej> i.e. "doesn't work like unix"
05:29:02 <phadej> "I don't like Haskell, I don't feel productive." says C-developer.
05:29:19 <davve> its better these days with linux subsystem but why not use a unixy O/S at that point?
05:29:20 <dminuoso> *unproductive?
05:29:37 <davve> yeah, if you would compare cmd.com or powershell to bash or something
05:30:03 <davve> im sure a lot of it is unfamiliarty but, why would I bother learning something I can already do (and better) on my other OS?
05:30:22 <dminuoso> How do you know that it's better on the other OS if you aren't even familiar with their style?
05:30:50 <dminuoso> If the argument is "I stick with what I know because learning something new takes time", then that's different
05:31:19 <davve> no, why would I learn something that is (in my mind) an inferior O/S? 
05:31:51 <davve> i've tried it and the available software windows has pails in comparison to what I have on linux
05:31:56 <arw> well. restart outlook thrice a week, because mail stops coming (without any indication). reboot weekly because some software wants to update. getting software installed takes ages because IT needs a .msi first and something like apt is black magic[tm]. there are reasons people don't like windows.
05:32:08 <arw> but those are higher-level than filesystem differences imho.
05:32:12 <davve> anyway, sorry to go OT here
05:32:44 <maerwald> davve: my dentist said "But then you can't be deployed everywhere, if you don't know windows" when I refused to fix his computer
05:33:25 <arw> maerwald: did you ask if he knew dermatology?
05:33:26 <dminuoso> arw: There's a difference between the operating system and the userspace application it houses.
05:33:35 <maerwald> arw: lolo
05:34:28 <dminuoso> While it's arguable that there's a lot of awful software on Windows, there's also awful software on linux. In my previous job I was involved in a large windows framework, and the Win32 API was quite enjoyable to work with.
05:35:15 <maerwald> File handling on windows... don't get me started. You need an *algorithm* to sucessfully delete a folder.
05:35:29 <arw> dminuoso: yes, of course. but comparing to linux (the kernel) is happening on a very low level by necessity, or you need to take into account a lot of applications. android is "linux" too, if you ignore "applications".
05:35:52 <dminuoso> arw: Outlook is not part of the Windows libraries.
05:36:03 <arw> agreed. yes. 
05:37:31 <phadej> desktop linux. qed.
05:37:58 <phadej> picking examples doesn't prove anything.
05:38:28 <Uniaika> allo, perrier-jouet 
06:05:29 <kuribas> I have a script which matches 200000 csv lines against 200 regexp (picks the first line which matches for each line), it runs in 7 seconds.
06:05:53 <kuribas> using pcre-builtin engine
06:06:04 <kuribas> is that an expected duration?
06:06:12 <kuribas> hmm, perhaps I could parallize it.
06:07:44 <phadej> kuribas: https://xkcd.com/1205/
06:07:48 <kuribas> is pcre paralellisable?
06:10:16 <kuribas> phadej: yeah, I guess 7 seconds is good enough :)
06:10:32 <kuribas> maybe I'll see if I can parallelise it for fun...
06:11:49 <Taneb> phadej: do you often need to link that? Maybe it would be worth setting up a system to automate it
06:12:41 <dminuoso> What makes you think he hasn't?
06:12:45 <dminuoso> ;)
06:13:43 <arw> kuribas: you could try to merge the regexes into one regex, maybe that could help reduce some call overhead or even have the regex compiler optimize a bit.
06:14:23 <kuribas> arw: I also have different expansions for each regex.
06:14:29 <phadej> obviously I remember the numbers of all "important" xkcd strips.
06:14:45 <phadej> they are inmy L2 cache. err, I'm a human.
06:18:20 <kuribas> hm, it randomly crashes with: user error (Text.Regex.PCRE.Text died: (24,"nothing to repeat"))
06:18:25 <kuribas> what does that mean?
06:21:56 <kuribas> it worked with String, but I get this error when I used Text instead.
06:22:03 <ridcully> kuribas: for comparsion, can you do a `egrep -f the-regexes the-csv` to get a ballpark for your 7s?
06:22:03 <kuribas> Maybe a bug in the pcre-builtin module?
06:25:11 <Unhammer> data X = X (Int,String); X <$> ((,) <$> pure 1 <*> pure "a") -- is there a nicer way to combine "X" with "," here? Looks kinda ugly :) 
06:26:27 <lortabac> Unhammer: why not 'X (1, "a")' ?
06:27:05 <merijn> Presumably the real code isn't using pure :p
06:28:57 <kuribas> it looks like pcre doesn't work with profiling...
06:29:45 <merijn> foreign calls currently aren't profiled (sadly)
06:29:58 <merijn> So bindings to foreign libs (like pcre) don't show up :\
06:30:27 <kuribas> merijn: it's also crashing with an error message
06:30:33 <kuribas> the non-profiling build works
06:31:24 <merijn> Nice
06:32:09 <Unhammer> lortabac heheh the real code takes inputs =P but I have to combine X and (,) on the results of two applicative things
06:32:50 * hackage morley 1.7.0 - Developer tools for the Michelson Language  https://hackage.haskell.org/package/morley-1.7.0 (gromak)
06:33:28 <lortabac> Unhammer: oh I see, maybe it looks better with ApplicativeDo
06:33:40 <kuribas> merijn: csvmatcher: user error (Text.Regex.PCRE.Text died: (24,"nothing to repeat"))
06:35:08 <lortabac> Unhammer: also, it would be probably simpler without the tuple (data X = X Int String)
06:35:53 <Unhammer> mnyeah but then other things get less consistent 
06:37:21 <lortabac> you can use curry/uncurry to convert between the two forms
06:37:42 <lortabac> but having the tuple in the data structure itself seems superfluous
06:39:06 <Unhammer> ooooh
06:39:07 <Unhammer> curry X <$> pure 1 <*> pure "a"
06:39:33 <Unhammer> I HAVE A USE FOR CURRY
06:40:03 <Unhammer> Achievement unlocked
06:40:05 <lortabac> :)
06:40:19 * hackage aeson-value-parser 0.19.0.1 - API for parsing "aeson" JSON tree into Haskell types  https://hackage.haskell.org/package/aeson-value-parser-0.19.0.1 (NikitaVolkov)
06:47:13 <int-e> But to chime in with the others,  data X = X (Int,String)  feels unidiomatic.
06:48:59 <ski> (at least use `newtype', if you want the pair)
06:51:24 <merijn> int-e: "It Depends"
06:52:01 <merijn> int-e: It's the sorta stuff I write "in progress", like "I quickly defined this using tuples, but I should probably do something better in the future, so wrap and deal with it later"
06:52:36 <maerwald> is there a way to get the inner type of a newtype (to pass to Proxy)
06:53:00 <lortabac> maerwald: coerce
06:53:19 <dminuoso> lortabac: That wont work out, I think.
06:53:39 <int-e> innerProxy :: f a -> Proxy a
06:53:55 <kuribas> how do you pass rtsopts to new-build?
06:54:01 <dminuoso> int-e: Well, if that was the case, your api shouldnt have been written over `Proxy a` but `proxy a` instead
06:54:17 <dminuoso> And if its `newtype T = T Foo`, then coerce wont work
06:54:27 <merijn> kuribas: What do you mean?
06:54:31 <int-e> dminuoso: uh, but doesn't that lose the erasure of the arguments?
06:54:37 <merijn> kuribas: "the same way as always"? >.>
06:54:39 <kuribas> merijn: I want a parallel enabled build
06:54:46 <dminuoso> int-e: Huh?
06:54:57 <kuribas> merijn: csvmatcher: the flag -N4 requires the program to be built with -threaded
06:55:11 <merijn> kuribas: I mean, you just set ghc-options in your cabal file?
06:55:15 <maerwald> dminuoso: It's because of persitent and SQL types. So there's a corresponding newtype, which is Word32, but someone passed Word8 to the PersistFieldSql 
06:55:21 <int-e> Oh wait, different proxies.
06:55:31 <maerwald> Now I change it to Word32 and it might happen again
06:55:32 <kuribas> merijn: ah right, thanks!
06:55:58 <maerwald> type alias won't help much either I think
06:56:05 <int-e> dminuoso: I guess I'm wrong, hmm.
06:56:23 <merijn> kuribas: Also, probably wanna pass -qg
06:56:31 <merijn> kuribas: (or -gq? I forget)
06:56:36 <merijn> to disable parallel GC
06:56:37 <kuribas> merijn: what does that do?
06:56:40 <kuribas> right
06:56:52 <int-e> dminuoso: But fwiw, I'm confusing Proxy and Proxy#
06:57:10 <merijn> I wonder when they'll finally get around to disabling parallel GC by default
06:57:19 * hackage Agda 2.6.1.1 - A dependently typed functional programming language and proof assistant  https://hackage.haskell.org/package/Agda-2.6.1.1 (UlfNorell)
06:58:16 <int-e> dminuoso: I'm wondering though... won't the `proxy a` business cause constant confusion between values and proxies?
06:59:03 <dminuoso> int-e: What do you mean?
06:59:28 <merijn> int-e: That's the point
06:59:56 <merijn> int-e: The point of using "proxy a" is that you can use values that you "happen to already have" without needing to construct an explicit Proxy value just to call something
07:00:29 <merijn> int-e: If I need "Proxy Int" and I happen to already ahve "Maybe Int", why do I need to do "(Proxy :: Proxy Int)"? Not to mention the likelihood of needing SCTV
07:00:54 <merijn> int-e: "proxy a" over "Proxy a" is strictly more useful
07:01:24 <dminuoso> otoh, `proxy a` allows for accidentally supplying the wrong thing more easily
07:01:25 <int-e> Well, there's a trade-off between type safety and convenience here, and I wonder which of `Proxy a` and `proxy a` strikes the better balance in practice.
07:01:49 <dminuoso> From experience, `proxy a` is more convenient.
07:02:26 <dminuoso> And if you just care about explicitness, you can still use `Proxy Int` against an api written over `proxy a`
07:02:29 <kuribas> merijn: csvmatcher: the flag -N4 requires the program to be built with -threaded
07:02:39 <dminuoso> But yeah, it's a trade off
07:02:47 <dminuoso> As with all things in a library. :)
07:02:49 <kuribas> merijn: oh nevermind
07:03:04 <merijn> kuribas: You added it to the library instead of the exe? ;)
07:03:30 <dminuoso> int-e: It's arguable, that any API that works against "as many things as possible" promotes using the wrong thing accidentally with it.
07:03:41 <int-e> That said, `proxy a` is the more common practice and there's also a cost in going against conventions.
07:03:49 <merijn> dminuoso: Clearly we should monomorphise everything always!
07:04:01 <merijn> Maybe we can use some kind of naming scheme to distinguish!
07:04:16 <merijn> We could do "listMap", "maybeMap", "tupleMap"!
07:04:50 <int-e> So pragmatically... yes, I agree it should be `proxy a`. (It wasn't my API though.)
07:04:51 <kuribas> merijn: worse, I didn't run the right exe
07:04:56 <merijn> kuribas: ;)
07:05:08 <merijn> kuribas: Lemme show you a life hack when testing new-build applications
07:05:50 <kuribas> merijn: ok, after adding parallelism, it pcre starts to throw random errors at me...
07:06:55 <kuribas> merijn: I think pcre doesn't like being parallised...
07:07:31 <merijn> kuribas: https://paste.debian.net/1163045/
07:07:40 <merijn> just replace "foo" with the name of your exe :p
07:08:13 <merijn> Then you can just use that shell script to run your exe for testing during development
07:08:23 <merijn> oh, wait
07:08:25 <kuribas> ah nice
07:08:34 <merijn> the BASEPATH thing is wrong
07:08:43 <merijn> I copied it from a slightly more elaborate script :p
07:09:20 <merijn> Probably should be BASEPATH="$(dirname "$0")"
07:09:46 <dminuoso> merijn: What does that give you? Why not just run v2-run directly?
07:09:49 <merijn> (that's just to work out the script location so you can call said script from anywhere and have it invoke the right cabal.project
07:10:07 <lordgrenville> Is there a way to use Prelude's read with a custom type?
07:10:11 <merijn> dminuoso: Because writing out "cabal run my-exe -- args" is a hassle
07:10:11 <lordgrenville> like if I have data Nucleotide = A | C | G | T deriving (Eq, Ord, Show)
07:10:21 <dminuoso> merijn: Huh, ok. 
07:10:24 <lordgrenville> read "A"::Nucleotide
07:10:39 <dminuoso> lordgrenville: Yes. Add Read to your deriving clause.
07:10:41 <merijn> dminuoso: Makes my incremental history useless
07:10:53 <lordgrenville> dminuso aaah, thank you
07:11:02 <dminuoso> lordgrenville: Now, that being said, you should probably not use `read` in your actual code if the input is not under your control.
07:11:10 <dminuoso> Use `readMaybe` in that case, rather.
07:11:16 <merijn> dminuoso: Also, I have a bunch of these on my path so I can run "in continuous development" programs that way
07:11:36 <dminuoso> merijn: Sure, I just use reverse search in zsh to quickly get the commands back.
07:11:41 <dminuoso> But I can see why you'd prefer that.
07:11:59 <merijn> dminuoso: I have a line-diff program which is just a shell script invoking cabal run on the current version so I can easily fix it
07:12:48 <merijn> dminuoso: I use the incremental search for history, so if I hit up arrow after writing "cabal" it will only cycle through history using "cabal"
07:13:18 <merijn> Having a separate "line-diff" script means that I can cycle through those commands easily with history without including all the cabal stuff
07:13:54 <dminuoso> Plus, I think this shell script wouldn't even work for me I think
07:14:10 <merijn> Why?
07:14:39 <dminuoso> I think cabal wouldn't be on path from that
07:14:46 <dminuoso> Im on nixos
07:14:59 <merijn> dminuoso: The actual version I use looks up cabal path from a makefile :p
07:15:06 <merijn> You can make it as complex as you like :p
07:15:25 <dminuoso> But yeah, I get the idea. Im sure I could tailor it work on nixos trivially, just dont have the time for it right now.
07:15:33 <merijn> kuribas: Alternatively, you can just hardcode the path to the cabal.project file in which case you can skip the BASEPATH entirely
07:15:43 <dminuoso> For my workflow, incremental search for cabal v2-run works fair enough. It's all in muscle memory, so its fairly rapid
07:16:12 <dminuoso> That is, `C-r v2-` usually has me covered :)
07:17:19 <merijn> I dunno what it is, but the C-r incremental search really doesn't fit my brain :p
07:20:04 <int-e> merijn: do you define dozens of shell aliases instead?
07:20:59 <dminuoso> merijn: My only mistake it still using zsh, Im sure if I used an emacs shell there's a more powerful variant of incremental search, one that fits nicely with ivy for narrowing.
07:21:07 <merijn> int-e: For?
07:21:10 <int-e> never mind, I see there was a paste above
07:21:19 <merijn> :)
07:22:25 <merijn> dminuoso: The added advantage of the bash script approach is that I can tell my supervisor to just download cabal and GHC and set their paths in a makefile and then she can use my executables without needing to know anything about cabal/ghc/haskell/etc.
07:24:21 <dminuoso> merijn: I would just hand my supervisors a binary.
07:24:23 <dminuoso> But that's just me.
07:25:05 <merijn> dminuoso: This gives me an extra data point in the reproducibility of my setup :p
07:25:35 <merijn> Also, now updating is just "pull the latest git version"
07:25:47 <dminuoso> merijn: Well, you can just have your github-ci product an artifact wrapped in a release..
07:25:55 <dminuoso> Then you can just point them to your repo, and they can just download the release they like.
07:25:57 <dminuoso> :p
07:26:09 <merijn> Sure
07:26:24 <merijn> As soon as github-ci gives me access to nvcc and Intel MKL
07:26:41 <merijn> With the exact versions that match our cluster
07:26:45 <dminuoso> You can run github-ci on a worker you like
07:26:54 <dminuoso> So it runs on *your* machine where you know its supported.
07:27:00 <merijn> dminuoso: And now I need to manage infrastructure :)
07:27:09 <merijn> dminuoso: My machines aren't internet accessible :p
07:27:13 <dminuoso> They dont have to be
07:27:17 <merijn> Also, not technically mine :p
07:27:18 <dminuoso> Do they have internet access?
07:27:55 <merijn> Yes
07:28:06 <dminuoso> Then technically that would work at least.
07:28:13 <merijn> But I have 0 interest in maintaining infrastructure
07:28:16 <dminuoso> But presumably you dont have a dedicated workstation, it's probably shared?
07:28:42 <merijn> dminuoso: Anything talking to github-ci wouldn't be
07:29:25 <dminuoso> merijn: Now I dont know about github-ci, but gitlab-ci at least is pull based. So it can sit behind NAT/firewall, as long as it can reach gitlab.com
07:29:38 <dminuoso> (Or your gitlab instance, rather)
07:29:52 <dminuoso> I was just thinking github-ci to be the same
07:29:52 <merijn> dminuoso: Someone would have to run all that and it's certainly not going to be me :p
07:30:25 <merijn> In fact, it working at all for anybody is just "nice to have" at this point >.>
07:31:02 <merijn> Anybody who dislikes it can go complain to some funding agency and demand funding for maintenance of scientific software :p
07:32:29 <merijn> Everyone always helpfully tries to solve the technical problems, but those don't need any help solving. The problem that requires solving is "nobody paying me to solve the technical problems" :p
07:34:59 <kuribas> why is pcre randomly throwing errors?
07:35:18 <merijn> Is it threadsafe? Is it reentrant?
07:35:29 <kuribas> I made a change to an *unrelated* part, and now it's throwing errors "(Text.Regex.PCRE.Text died: (24,"nothing to repeat"))"
07:35:37 <kuribas> is it not playing well with lazyness?
07:36:34 <dminuoso> What merijn asked.
07:36:48 <kuribas> merijn: how should I know?
07:37:06 <kuribas> merijn: ah wait, I didn't remove -threaded ...
07:37:08 <dminuoso> Consult the documentation of the implementation.
07:37:09 <merijn> You read the docs?
07:37:11 <kuribas> merijn: thanks :)
07:37:20 <kuribas> merijn: nothing about paralellism in the docs
07:37:43 <kuribas> merijn: PCRE is threadsave under some conditions, but I don't know how the extension is written....
07:38:25 <kuribas> https://stackoverflow.com/questions/38928867/pcre-pcre-exec-thread-safe
07:38:30 <dminuoso> how do you know its save under "some" conditions?
07:38:46 <kuribas> dminuoso: link I pasted
07:39:26 <dminuoso> Well there you have it. Now check whether the haskell bindings does this appropriately.
07:50:48 <sm[m]> regex-tdfa is a fairly nice pure haskell alternative
07:51:22 <merijn> "Use process and call actual grep" >.>
07:53:15 <kuribas> sm[m]: I tried that one and it took more than 20 seconds so I killed it.
07:54:05 <LambdaDuck> How do I list the available targets in a cabal file?
07:54:19 * hackage path-utils 0.1.0.0 - Handful of simple utility functions for the path library.  https://hackage.haskell.org/package/path-utils-0.1.0.0 (locallycompact)
07:56:08 <sm[m]> kuribas: to do what ?
08:15:47 <Orbstheorem> How would you convert an absolute URI from Network.URI.URI to Text.URI.URI?
08:16:24 <kuribas> sm[m]: I am matching a list of regexes on each line of a CSV
08:18:30 <sm[m]> kuribas: was it a very long list or a very large CSV ?
08:18:40 <sm[m]> or a very costly regex with lots of backtracking ?
08:18:44 <kuribas> sm[m]: 200000 lines
08:18:54 <kuribas> sm[m]: 200 regexes, but simple ones
08:19:45 <sm[m]> I feel like it could be made to go faster, but that's interesting
08:20:13 <sm[m]> depends on the machine too of course
08:21:26 <sm[m]> merijn's solution is probably going to be cheapest in terms of developer time eh
08:21:59 <kuribas> sm[m]: how is calling grep repeatedly going to be faster?
08:23:15 <kuribas> or you mean faster to write?
08:23:20 <sm[m]> obviously I don't know your app like you do, but it can probably do that search in less than 20s and without crashing ?
08:23:25 <merijn> Faster to write and likely not much slower
08:23:25 <kuribas> I don't know, I needed to do some parsing as well
08:23:27 <sm[m]> yes, cheaper in developer time
08:23:44 <merijn> Call out to ripgrep and get even faster ;)
08:24:16 <sm[m]> if you need to be portable/self contained, then of course things change again
08:24:35 <kuribas> merijn: I doubt it.  If I did it in bash, I'd spend a lot more on maintenance.
08:24:45 <merijn> kuribas: Who says bash?
08:24:49 <kuribas> yeah, it also needs to be self contained.
08:24:56 <merijn> I said "use process"
08:25:06 <kuribas> process?
08:25:11 <merijn> @hackage process
08:25:11 <lambdabot> https://hackage.haskell.org/package/process
08:25:26 <merijn> Like, just start a new grep process, feed the result into your code and then do whatever
08:26:18 <merijn> I mean, "assuming grep is on a system" is probably something you can justify for, say 95% of all problems
08:26:38 <kuribas> merijn: that's more of a hassle... I need to extract groups for the replacement text
08:26:55 <kuribas> merijn: and the replacement depends on which regexp matches
08:27:23 <merijn> pipe multiple sed's into each other? :p
08:27:35 <merijn> Hell, sed already supports multiple substitutions in a single invocation
08:27:53 <kuribas> also it's running on a windows machine...
08:28:19 <kuribas> it'll take more time for the guy to install unix utilities etc... than for me to develop the script.
08:28:48 <sm[m]> ah you need replace too. regex-tdfa doesn't have that but I do
08:28:58 <sm[m]> kuribas: did you also try the newer regex lib ?
08:29:26 <sm[m]> or.. maybe that still needs one of the existing backends
08:29:35 <kuribas> sm[m]: I used pcre-builtin
08:30:14 <sm[m]> ah
08:31:12 <sm[m]> that includes C code ? but is ok to build on windows ?
08:31:57 <ezzieyguywuf> do you all use unit tests in haskell?
08:32:02 <ezzieyguywuf> i.e. is it as needed/necessary as in (say) python, or does the strong type-system and compile-time checks sort of obviate them?
08:32:22 <merijn> ezzieyguywuf: I mean hspec I dislike anyway with it's typeclassy pseudo english DSL
08:32:43 <dolio> Still use tests.
08:33:02 <merijn> ezzieyguywuf: And generally unit tests of the form "write down explicit checks" are the least useful tests
08:33:17 <ezzieyguywuf> so what types of tests do y'all use?
08:33:23 <merijn> ezzieyguywuf: Generally people will prefer property testing like quick check
08:33:41 <sm[m]> I wonder if kuribas is doing search/replace over the whole csv  or individually on each record, streaming fashion 
08:34:00 <ezzieyguywuf> I'm used to this Test Driven Development approach, i.e. "write a failing test for MyThing.doesSomething" then implement `doesSomething` so that the test passes
08:34:08 <c_wraith> I write tests for code capable of subtle bugs.  I don't write tests for code where the type restricts it to either be correct or have only trivial bugs.
08:34:13 <sm[m]> they are less necessary but still necessary depending on what you're building
08:34:14 <ezzieyguywuf> but I'm starting to feel this is redundand/not really too useful in haskell
08:34:17 <dminuoso> ezzieyguywuf: It's sometimes useful to run parts of tests in another language, if that other language have the needed facilities.
08:34:34 <dminuoso> Also note that
08:34:44 <ezzieyguywuf> I'm actually currently using hspec + QuickCheck
08:34:44 <tdammers> ezzieyguywuf: it's useful alright, but something a lot of people don't "get" about TDD is that you need to write those red/green tests at the right level
08:34:48 <dminuoso> ezzieyguywuf: This TDD you're talking about we usually do with the compiler, say by running ghcid. :)
08:34:50 * hackage uniqueness-periods-vector-general 0.2.0.1 - Generalization of the functionality of the dobutokO-poetry-general-languages package  https://hackage.haskell.org/package/uniqueness-periods-vector-general-0.2.0.1 (OleksandrZhabenko)
08:35:13 <tdammers> TDD at the unit level is silly, because it cements implementation details into the design
08:35:14 <dminuoso> The type system is a gigantic automated test framework with (somewhat) provably correct tests.
08:35:23 <merijn> I think TDD is a mistake anyway
08:35:36 <tdammers> depends
08:35:38 <merijn> The important thing about testing is the ROI
08:35:40 <ezzieyguywuf> merijn: what do you prefer to TDD?
08:35:48 <ezzieyguywuf> dminuoso: I'm using ghcid...but with hspec + QuickCheck, lol.
08:35:57 <merijn> i.e. "effort invested in writing tests" to "bugs prevented/found"
08:36:09 <merijn> "writing unit tests for everything" has terrible ROI
08:36:09 <dminuoso> If that works for you, great. For me, ghcid alone catches the largest chunk of bugs.
08:36:18 <dminuoso> I only write tests to avoid regressions.
08:36:30 <ezzieyguywuf> here's an example of some of the TDD I've done https://gitlab.com/ezzieyguywuf/mycad/-/blob/makeFace/Topology/test/TopologySpec.hs#L28
08:36:37 <tdammers> like, when you write a compiler-like program, the TDD approach can be very useful, because your tests not only produce, well, regression tests, but also some documentation and specification
08:36:37 <dminuoso> If we consider "fixing until it compiles" as TDD, then yeah, we all do TDD.
08:36:44 <tdammers> or at least clarification of the specification
08:36:48 <merijn> smoke tests, integration tests, and regression tests all have great ROI
08:36:50 <monochrom> TDD requires writing test cases before writing implementation. What people here do are both not TDD and taking TDD to the extreme. "Test cases" taking to infinity means specification. People write specifications first.
08:36:52 <ezzieyguywuf> I went from top to bottom, so I started with "addFreeVertex" test, and then implemented the function addFreeVertex
08:36:52 <merijn> property testing too
08:37:14 <ezzieyguywuf> dminuoso: so what do you have ghcid _do_...just compile the code?
08:37:27 <merijn> ezzieyguywuf: ghcid can run tests too
08:37:56 <ezzieyguywuf> right - I use it to run tests
08:38:08 <ezzieyguywuf> but I guess I can see the argument for using ghcid to just compile, and keep going till it compiles.
08:38:15 <ezzieyguywuf> maybe I just need to find the right balance.
08:38:16 <dminuoso> ezzieyguywuf: Im just saying, that if we think of types as tests, then just starting with the type and writing code until it typechecks could be considered as TDD.
08:38:17 <merijn> ezzieyguywuf: Have you seen John Hughes "don't write tests" talk?
08:38:36 <ezzieyguywuf> merijn: I have not, but perhaps I should watch it
08:38:36 <tdammers> IME, in a language like Haskell, the type of tests that produce the best bang-for-bucks by far are 1) simulation tests (a.k.a. end-to-end tests, of the system as a whole, or substantial parts of it), and 2) property checks filling the gaps in what the type checker can cover
08:38:39 <dminuoso> ezzieyguywuf: That style of "start with the type and then implement it" is a really sweet way to write complicated code. :)
08:38:39 <merijn> ezzieyguywuf: https://www.youtube.com/watch?v=hXnS_Xjwk2Y
08:39:20 <merijn> ezzieyguywuf: He's (one of) the authors of QuickCheck and I think his talk explains a lot of how people view tests
08:39:22 <ezzieyguywuf> merijn: beat you there :-P
08:39:27 <merijn> tdammers: Don't forget liquid haskell!
08:39:31 <ezzieyguywuf> I'll definitely give it a watch
08:39:34 <merijn> tdammers: Which is now a convenient GHC plugin!
08:41:28 <lortabac> the main reason why I write unit tests is that my yearly bonus depends on test coverage
08:41:38 <ezzieyguywuf> üòÇ
08:42:06 <ezzieyguywuf> I want my project to be sound and reliable, thus why I started off with TDD and "lotso tests"
08:42:13 <sm[m]> you can't say which kind/how much testing is best without more context, such as the problem domain, cost of production failures, available tooling, schedule etc.
08:42:23 <ezzieyguywuf> but the more comfortable I get with haskell the more I'm learning that the type system itself provides many guarantees
08:42:41 <tdammers> merijn: Yes! I KNOW!
08:43:06 <tdammers> ezzieyguywuf: yeah, that's the real takeaway here. "type driven development", basically
08:43:30 <tdammers> it's not that Haskell guarantees soundness out of the box, but the type system gives you a lot of tools to improve soundness yourself
08:43:40 <tdammers> it's largely up to you how far you can take it
08:43:46 <tdammers> s/can/want to/
08:44:00 * ezzieyguywuf nods
08:44:34 <sm[m]> less is more and YAGNI are a good default to start with, but be ready to add more testing to your process as soon as it looks like it will pay off. Have some way to measure your goals for reliability etc.
08:45:24 <ezzieyguywuf> YAGNI?
08:45:31 <sm[m]> docs are more lightweight and can be even higher payoff than tests
08:46:19 <sm[m]> don't have the link handy sorry
08:46:37 <phadej> you aren't going need it
08:47:07 <merijn> ezzieyguywuf: Ya Ain't Gonna Need It
08:48:01 <ezzieyguywuf> I see.
08:48:11 <ezzieyguywuf> lol, I started reading about liquid haskell
08:48:13 <ezzieyguywuf> seems interesting.
08:50:14 <hyperisco> I find something dissatisfying about leaning on SMT solvers‚Ä¶ something like leaning on optimisations but at the type level
08:50:28 <hyperisco> maybe it solves, maybe it doesn't solve, not clear what the distinction is
08:51:25 <ezzieyguywuf> also, I do find myself doing more of the "type driver development" approach, although I get a certain sense of comfort/satisfaction by having the tests in there too
08:51:27 <merijn> It's a constructive proof, though. So if it's accepted it's always fine
08:51:40 <merijn> It might not accept things that are fine, but that's ok
08:51:40 <ezzieyguywuf> but also, the type-driven thingy has my thinking wether or not I want to get more familiar with idris
08:51:46 <phadej> for the problems of the size liquid haskell throws at SMT solver they definitely will solve it
08:51:54 <merijn> ezzieyguywuf: Yes and no
08:52:15 <merijn> ezzieyguywuf: If you wanna explore type level stuff and dependent types, Idris will be *much* easier than Haskell
08:52:38 <merijn> But I don't think Idris will be practical for "real" code anytime soon
08:52:55 <ezzieyguywuf> hrm, yea well I'm more interested in "real" code at the moment.
08:52:56 <tdammers> I was gonna write "inb4 but it's not production ready", but merijn beat me
08:53:24 <ezzieyguywuf> but, for example, the fact that at compile-time you can check whether or not a list is empty etc (I guess dependent types) seems really neat and attractive
08:53:32 <hyperisco> phadej, what does size have to do with solvability?
08:53:32 <tdammers> anyway, for at least 90% of code you'll write in the real world, Haskell's type system is more than sufficient, or at least it will get you some massive benefits
08:53:46 <tdammers> you can't express *everything*, but you can express an awful lot
08:54:19 <phadej> hyperisco: the problems thrown at SMT are decidable, so it will say either "yes" or "no". Problem is "when".
08:54:23 <ezzieyguywuf> thought that's a poor example as we have NonEmpty in haskell, but i guess in idris you could ensure a list had exactly 2 or 3 or w/e elements (though again, it's a poor example as in haskell you could just use a tuple)
08:54:43 <hyperisco> phadej, liquidhaskell has guaranteed this? I wasn't aware
08:55:11 <hyperisco> is liquidhaskell able to tell you immediately if a refinement is not in its solvable class?
08:56:30 <phadej> hyperisco: or take it differently. I don't think SMTs solvers are as fragile as optimizers, that they would fail to find a solution which they did previously.
08:56:52 <hyperisco> that isn't the analogy though
08:57:00 <phadej> they are not constrained by "have to be reasonably fast", their constraint is "have to produce results"
08:57:13 <phadej> giving up is worst choice
08:57:21 <hyperisco> I am not talking about the changing of the solver or the changing of the compiler, I am talking about the changing of the program
08:58:07 <phadej> You won't that easily escape into undecidable theories
08:58:32 <hyperisco> I'd be interested to know how LH guarantees solvability‚Ä¶ am guessing that is on a doc somewhere
08:58:36 <phadej> SMT solvers are _good_
08:58:52 <phadej> they are by factor better than ad-hoc solutions :)
08:59:11 <phadej> s/solutions/solvers/
08:59:38 <merijn> SMT solvers are several decades worth of CS engineering to be fast :p
09:00:00 <merijn> I don't think there's any tool that has as much dedicated optimisation and benchmarking going in them :p
09:00:15 <hyperisco> I could say an optimiser is _good_, you won't easily trip it up, and it doesn't really change the problem, unless we are talking so unlikely that it might happen once or twice a year
09:00:20 <merijn> hyperisco: Also, what alternative do you propose
09:00:45 <phadej> proving associativity of + for Nat's is just not a task for humans.
09:00:52 <merijn> I mean, sure, you can not use liquid haskell but how is that an upside?
09:01:02 <hyperisco> when the problem does happen it isn't clear why it happened, and so there isn't any clear recourse
09:01:11 <phadej> If SMT solver (for liquidhaskell) fails to verify, you can still help it by doing proof steps manually.
09:01:13 <merijn> hyperisco: Optimisers are super fickle and tripping them up is trivial
09:02:14 <hyperisco> phadej, but how do you know what needs to be made more clear?
09:02:33 <hyperisco> this is just a general difficulty with automation
09:02:59 <merijn> How do you know which liquid haskell properties to write down?
09:03:12 <merijn> You don't get to skip the thinking step
09:03:21 <merijn> These tools only help the *checking* step
09:03:40 <hyperisco> so you have some type and it fails to solve (which phadej said is not possible so I don't know why we're still going on this)
09:03:49 <hyperisco> you thought about the type, it is the type you like
09:04:04 <hyperisco> LH can't solve, so now what do you do?
09:04:24 <hyperisco> how does LH explain its thinking to you so that you can help it
09:04:25 <merijn> hyperisco: I mean, if you think about regular haskell types I can ask you the same question (as many beginners often do)
09:04:44 <merijn> "GHC says my type is wrong, but I know it's right!"
09:04:56 <hyperisco> yeah, and so you have to roll out the type theory
09:05:00 <hyperisco> that is the thinking
09:05:10 <hyperisco> so what do we do for LH?
09:05:16 <phadej> the same :)
09:05:24 <dolio> Roll out the SAT solver implementataion details.
09:05:26 <hyperisco> look at the SMT solver input/output?
09:05:27 <dolio> Just understand that.
09:05:31 <phadej> SMT automates the boring proofs
09:05:36 <hyperisco> dolio, :P
09:05:37 <phadej> intersting proofs you have to do by hand :P
09:06:01 <hyperisco> not saying this kills LH or anything, just saying this is a discomfort for me
09:06:57 <hyperisco> I think we've all been in the spot where once we were rolling along in bliss to suddenly hit a pot hole
09:06:57 <phadej> I have to check the new LH tooling (the ghc plugin), and what it says when you ask it to do something which trips SMT solver.
09:07:13 <hyperisco> and then our world comes crashing down as we realise we haven't the foggiest idea of how to repair a road
09:07:34 <phadej> Somehow I just know what it can solve (presburger arithmetic, e.g.) and what it cannot (arbitrary induction, I guess?)
09:07:40 <hyperisco> whereas if we were the authors of the process all along we would necessarily be equipped with that knowledge already
09:08:23 <phadej> kosmikus will talk about LH at MuniHac this weekend
09:08:31 <phadej> be curious, attend the workshop
09:08:44 <phadej> ask tricky questions ;)
09:19:38 <LambdaDuck> What is the fastest way to test if a type is an instance of a type class?
09:20:13 <monochrom> Go ahead use the methods on your type.
09:21:52 <maerwald> in terms of reflection?
09:22:03 <maerwald> I'm not sure I wanna know, actually.
09:22:22 <ski> @type () :: Eq () => ()
09:22:23 <lambdabot> ()
09:22:25 <ski> @type () :: Eq (() -> ()) => ()
09:22:27 <lambdabot> error:
09:22:27 <lambdabot>     No instance for (Eq (() -> ()))
09:22:27 <lambdabot>       arising from an expression type signature
09:23:42 <maerwald> would that be possible with Typeable?
09:23:54 <monochrom> No, Typeable doesn't have that information.
09:24:21 <monochrom> Afterall it is not called Instanceable :)
09:25:08 <maerwald> 3 weeks in, someone will have written that and there will be an esoteric reddit post
09:25:35 <monochrom> But then we say it needs compiler support.
09:26:14 <monochrom> Now it will be a 3-year project of proposal, implementation, PRs, discussions, waiting for it to be accepted, etc etc
09:26:54 <monochrom> At the end of the 3 years will be rejection in favour of something really esoteric instead.
09:27:03 <boxscape> % 4
09:27:03 <yahb> boxscape: *** Parser [source]:; !!! Parser [source]: finished in 0.10 milliseconds, allocated 0.018 megabytes; *** Desugar:; *** Simplify [expr]:; !!! Simplify [expr]: finished in 0.17 milliseconds, allocated 0.119 megabytes; *** CorePrep [expr]:; !!! CorePrep [expr]: finished in 0.06 milliseconds, allocated 0.039 megabytes; *** ByteCodeGen [Ghci23]:; !!! ByteCodeGen [Ghci23]: finished in 0.12 milliseconds, allocat
09:27:06 <boxscape> what's gotten into yahb
09:27:22 <maerwald> evolved
09:27:49 <ezzieyguywuf> lol, John Hughes is better at quickcheck than I am üòÇ
09:27:59 <monochrom> Someone probably said something along the line of % :set -fadd-every-flag
09:28:19 <boxscape> calling :q fixed it
09:28:21 <monochrom> I forgot the command for telling yahb to reset
09:28:27 <monochrom> Oh heh, thanks.
09:29:09 <monochrom> haha forgot the obvious :quit, or maybe I was to afraid to contemplate the other possible consequence.
09:29:24 <boxscape> I vaguely remembered that it was something you could do
09:29:28 <phadej> ezzieyguywuf: I doubt anyone is better than John Hughes at QuickCheck :)
09:30:00 <monochrom> Well, :quit is certainly legal, my worry would be "but is there a meta-loop that will restart it?"
09:30:15 <boxscape> right, I meant I vaguely remembered that it would reset yahb
09:30:46 <monochrom> Then again why worry, yahb was unusable anyway, so what if it couldn't come back heh.
09:31:07 <boxscape> hm
09:32:29 <ezzieyguywuf> I get the feeling I'm not using QuickCheck correctly - he has all these random "sequences of tests", where I just have "random inputs to property checks"
09:33:12 <monochrom> I think "random inputs" is our common understanding.
09:38:51 <ixlun> Suppose I have: data Baz = Foo [Int] | Bar [Int].  And I also have a recursive function: f :: Baz -> Something.  f is recursive and I want it to have different semantics depending upon whether a Foo or Bar value constructor is used. I know that I could pattern match with: Foo (x:xs) but then I always have to wrap `xs' in a Foo to get the right semantics for the recursive call.  Is there a better way to do this?
09:39:13 <dolio> I think the more shocking part of that talk is the fracton of a second where you can see Hughes' Windows desktop completely filled with icons. :√æ
09:39:26 <monochrom> haha
09:39:56 <monochrom> But it's consistent with the "disorganized mathematician" stereotype!
09:40:37 <boxscape> I just set my desktop icons to invisible and never look at the mess that must have amassed in the background
09:41:04 <geekosaur> ixlun, tbh I'd make functions g and h that take lists and do different things, then f (Foo xs) = g xs | (Bar xs) = h xs
09:41:07 <monochrom> I once created a folder "unorganized" and shoved 90% of my icons into it.
09:41:39 <geekosaur> f | (Foo xs) = ...
09:41:59 <geekosaur> bleh, I'm doing this wrong
09:42:12 * geekosaur needs more sleep
09:42:39 <geekosaur> f (Foo xs) = g xs; f (Bar xs) = h xs
09:42:48 <geekosaur> then g and h recurse as needed
09:42:56 <monochrom> Did you moonlight as a caml or ocaml programmer? Because your 1st attempt would look right in caml. :)
09:43:39 <geekosaur> I did encounter SML before Haskell‚Ä¶
09:43:47 <geekosaur> but not ocaml
09:44:02 <monochrom> me too, yeah actually that's sml syntax
09:44:21 <monochrom> or very reminimscent of
09:44:56 <geekosaur> getting my languages confuzzled, that's about par for recently
09:45:10 <ixlun> geekosaur: that sounds like the simplest solution.  I was thinking of trying someing fancy with typeclasses but I feel like it's abusing what they're really made for.
09:45:46 <geekosaur> yeh, typeclasses are etter for the opposite (you want one implementation for two distinct types)
09:45:52 <geekosaur> *better
09:47:15 <geekosaur> although that's still arguably abuse depending on what you're doing.
09:47:52 <geekosaur> for one, it should still conceptually be doing the same thing to really be a candidate for a typeclass
09:48:08 <boxscape> sometimes I feel like abusing them is what typeclasses are made for
09:48:56 <geekosaur> in some sense they are an abuse of polymorphism
09:53:07 <geekosaur> (but in another sense, they're bringing (a weaker form of) the mathematical notion of morphism into play instead of the CS one)
09:59:27 <maerwald> boxscape: weird, I feel I should never write a single type class. And I usually don't.
10:00:13 <geekosaur> I've written a few, but I use them sparingly
10:00:28 <maerwald> other ppl see them as a design pattern, I never got that
10:03:10 <monochrom> Lately my type classes are either the final tagless kind or just because GHC.Generics makes me write one.
10:03:11 <geekosaur> you can see MonadFoo for some Foo / FooT as a design pattern (for example MonadState)
10:06:27 <monochrom> The paper "data types a la carte" may help you.
10:09:06 <geekosaur> oh, I didn't say I saw them that way, just that "design pattern" is often tossed around somewhat loosely
10:11:44 <hyperisco> I think there is only one type class I made that wasn't already in a library (other than my ACME stuff)
10:14:50 <dolio> Type classes are 'just' a way to make sense of overloading in types, and ideally you use them in a way that isn't completely ad-hoc (although you can). I think people take the ceremony for what counts as not ad-hoc too seriously, though.
10:15:06 <dolio> Er, sometimes people do.
10:15:27 <hyperisco> it is a class for indexable things
10:16:02 <hyperisco> well I use them for a sort of meta programming too but I don't count that
10:16:59 <hyperisco> given a class for indexable things you can have fun with the indices
10:20:57 <hyperisco> like if indices have an additive group then you can define reverse as just subtracting from the upper bound
10:21:19 <hyperisco> slicing also comes naturally‚Ä¶ zipping‚Ä¶
10:22:10 <monochrom> Are you interested in this tautology?  Every set is the union of an indexed family of sets. :)
10:22:44 <hyperisco> is that an axiom of choice thing
10:22:51 <monochrom> No.
10:23:02 <hyperisco> okay then I am interested
10:23:11 <dolio> Index by one thing.
10:23:11 <monochrom> Let S be a set.
10:23:38 <monochrom> Use elements of S again for indexes.
10:24:07 <hyperisco> id :: S -> S  okay
10:24:12 <monochrom> Indexed family: Define t_i = {i}, using elements of S for the indexes i
10:24:18 <dolio> Yeah, that's another way.
10:25:29 <hyperisco> if this is a commentary on indexable things I was capturing a relation of three types
10:25:45 <hyperisco> Indexable a i e | a -> i e  where  a  is the container type,  i  is the index type,  e  is the element type
10:25:56 <monochrom> It's a digressional tangent, or tangential digresses.
10:28:02 <hyperisco> lets see if you had an indexable of indexables could you concatenate them‚Ä¶ Maybe
10:28:41 <hyperisco> you need enough indices, or you could define it to lop off extras
10:29:40 <hyperisco> this of this all mostly as a way to do array operations without copying arrays
10:30:42 <hyperisco> just mucking with the indexer instead
10:37:49 * hackage hashtables 1.2.4.1 - Mutable hash tables in the ST monad  https://hackage.haskell.org/package/hashtables-1.2.4.1 (GregoryCollins)
11:00:19 * hackage polysemy-http 0.2.0.2 - Polysemy effect for http-client  https://hackage.haskell.org/package/polysemy-http-0.2.0.2 (tek)
11:27:49 * hackage git-annex 8.20200908 - manage files with git, without checking their contents into git  https://hackage.haskell.org/package/git-annex-8.20200908 (JoeyHess)
11:52:34 <justsomeguy> Is there a function in base I can use to download a URL? (Surprisingly, doing a web search didn't turn up anything. Hoogle pointed me to some external libraries.)
11:52:53 <geekosaur> not in base, no
11:52:56 <Rembane> justsomeguy: No, you need an external library.
11:52:58 <monochrom> It has to be external libraries.
11:52:58 <sm[m]> don't think so
11:54:30 <justsomeguy> Thanks. I guess I'll try a few libraries out.
12:01:04 <electricityZZZZ> so i would like a simple language for my end users, think of something like a console or a shell,... but it would be nice to have some modern guarantees and benefits there, along with some simplicity (like elm). can anyone suggest something to look into? i think lua and python would be commonly used here
12:02:59 <sm[m]> must it be implemented in haskell ?
12:03:41 <hyperisco> honestly that was one of the most painful things I had to do in Haskell lol... download a URL
12:03:43 <geekosaur> or, presumably, be haskell-like in some sense
12:08:49 <sm[m]> it's perhaps a pity that not even any  the alternate preludes include simple http access
12:10:38 <justsomeguy> electricityZZZZ: I don't know anything about language design, but here's a wiki page with links to tons of experiments in shell design. Maybe you'll find some inspiration. https://github.com/oilshell/oil/wiki/ExternalResources
12:10:45 <sm[m]> nor does haskell-platform
12:11:32 <phadej> haskell-platform has HTTP
12:11:45 <phadej> not that I'd recommend using it, if you have a choice
12:12:00 <sm[m]> ah, right
12:12:56 <hyperisco> there are a lot of details in just downloading a URL, and the ethos of Haskell demands they're all thoroughly explored
12:13:30 <hyperisco> ended up with some copy paste thing from conduit oO
12:14:06 <phadej> > callProcess "curl" [url]
12:14:08 <lambdabot>  error:
12:14:08 <lambdabot>      Variable not in scope: callProcess :: [Char] -> [a0] -> terror: Variable...
12:14:20 <hyperisco> probably the better way :P
12:14:47 <justsomeguy> That seems like a good approach for the quick one-off script I'm trying to write.
12:15:33 <phadej> except that `process` works with Strings by default, and writing proper ByteString reader needs at least `async` if you want to stay sane
12:15:42 <phadej> it's like :(((((
12:15:47 <phadej> why process uses Strings
12:16:11 <phadej> (sometimes you don't care, but there's no option)
12:16:29 <phadej> s/don't care/actually want to use locale text encoding/
12:20:15 <justsomeguy> That is a yak waiting to be shaved.
12:21:05 * geekosaur somewhat regularly has to deal with web pages in some obscure windows codepage :(
12:21:09 <monochrom> I was wrong a few days ago. TH has reflection (reification?) ability, it can find out the structure of a given algebraic type.
12:24:08 <sm[m]> speaking of which.. int-e is lambdabot's @where db iso8859-1 encoded ?
12:24:22 <isovector1> does anyone know where the haskell-language-server people hang out?
12:24:33 <sm[m]> #haskell-ide-engine
12:24:51 <alanz_> obviously :)
12:25:00 <Rembane> Common typo. :)
12:25:08 <isovector1> thanks
12:25:45 <alanz_> the balance between people who already know, and dont even think about it, and new people
12:26:24 <alanz_> Maybe we should create #haskell-language-server and make a message forwarding people to the other. Except that will cause even more confusion
12:26:48 <geekosaur> you can set a forward-ban on a channel
12:26:54 <Rembane> Before you know it you have made one of those old flip-to-the-right-page adventure games, but with IRC channels instead of a book.
12:27:02 <geekosaur> (channel ops get excluded, so they can maintain it)
12:27:23 <sm[m]> alanz_: what about a more general #haskell-ide
12:27:25 <alanz_> forward-ban. Will research it. Thanks
12:27:52 <alanz_> sm[m], that makes sense
12:29:05 <monochrom> "#haskell-ide re-exports #haskell-ide-engine"
12:29:25 <sm[m]> more future proof, shorter to type and easier to guess and understand
12:29:48 <alanz_> yes
12:29:59 <alanz_> monochrom, and ghcide
12:30:02 <alanz_> and hie-bios
12:30:12 <alanz_> and ghc-exactprint
12:30:16 <alanz_> and HaRe
12:30:27 <alanz_> and all the other ones I have left out
12:30:34 <geekosaur> probably for the best given how I keep misparsing ghcide
12:31:09 <monochrom> inseticide. regicide. ghcide.
12:31:45 <geekosaur> yep
12:31:56 <alanz_> so it kills github? :)
12:32:25 <electricityZZZZ> i can refine my question as "what is the simplest console-ish language",... so basically anything even slightly complex needs to drop into a "real" language
12:33:20 <hyperisco> is it not bash
12:33:34 <Rembane> Python! 
12:33:49 <sm[m]> doesn't help narrow the field much electricityZZZZ . What are some other constraints ? Is haskell-related one ?
12:34:21 <electricityZZZZ> well, i'm asking in #haskell because i think elm might resemble what i would be looking for in ceratin respects and you guys tend to know a lot about languages and haskell-like languages
12:34:27 <electricityZZZZ> *certain
12:34:42 <hyperisco> elm as a console language?
12:34:50 <electricityZZZZ> maybe? or am i a nut?
12:35:01 <hyperisco> I thought it was an opinionated web thing
12:35:20 <electricityZZZZ> well that's what it targets but imagine replacing visual basic with something good for once
12:35:45 <hyperisco> I don't know VB‚Ä¶ how about xaml
12:35:54 <Rembane> xslt! 
12:35:58 <sm[m]> will you be shipping the software to others or running it on your own server ?
12:36:12 <geekosaur> closest thing to a haskell-like console language is the dialect ghci speaks, which has differences that somewhat regularly trip people up
12:36:19 <electricityZZZZ> probably a little of both but we can ignore the cpu use concerns to begin with if that is why you are asking
12:36:27 <electricityZZZZ> oh ghci doesn't run haskell?
12:36:35 <sm[m]> practically speaking lua is the answer I suspect
12:36:36 <electricityZZZZ> that's good to know, heh
12:37:05 <electricityZZZZ> but lua doesn't have a type system worth a damn
12:37:18 <electricityZZZZ> that's why i was saying something like elm
12:37:22 <geekosaur> electricityZZZZ, it's a dialect of haskell with some differences because (for example) it has to fix types immediately instead of waiting to see what else you type in
12:37:39 <electricityZZZZ> heh ok
12:37:51 <hyperisco> why are we using a type system for a simple-as-possible console language
12:38:10 <Rembane> Isn't everything strings in a shell?
12:38:14 <sm[m]> I found https://github.com/dbohdan/embedded-scripting-languages for you
12:38:28 <hyperisco> the char star protocol
12:38:30 <glguy> I like using Lua for scripting my Haskell program
12:38:46 <electricityZZZZ> i think that a type system could be useful for automatically suggesting completions and for limiting misuse
12:39:00 <monochrom> In a shell, everything is either a string or a tokenize list of strings, and it's hard to tell which is when.
12:39:26 <sm[m]> you also did say "simplest".. 
12:39:43 <electricityZZZZ> right but i also said elm-like :)
12:39:47 <geekosaur> you kinda lose "simple" with types, yeh.
12:39:54 <electricityZZZZ> oh?
12:40:00 <hyperisco> the problem you're going to have with a type system is that it would have to be rather sophisticated
12:40:06 <geekosaur> and the better/more specific the type information, the less simle the result
12:40:11 <hyperisco> otherwise you're going to type in reasonable commands and get a type error
12:40:22 <monochrom> STCC = simply-typed console calculus >:)
12:40:26 <hyperisco> and you don't want to have to be annotating or unsafe coercing things
12:41:15 <sm[m]> since "simplest" is negotiable, there's https://dhall-lang.org 
12:41:17 <hyperisco> and presumably the things you are invoking don't have prototypes
12:41:48 <electricityZZZZ> i will reveal a little bit more for the use case i have in mind,... which is a friend of mine uses a rather outdated statistical package
12:41:50 * hackage stratosphere 0.59.0 - EDSL for AWS CloudFormation  https://hackage.haskell.org/package/stratosphere-0.59.0 (jdreaver)
12:41:57 <electricityZZZZ> and i've used a fair bit of R myself
12:42:06 <electricityZZZZ> and i'm thinking gosh how hard would it be to beat this stuff
12:42:07 <geekosaur> you also need type information in the filesystem for most commands to be properly typeable
12:42:23 <electricityZZZZ> type information *in* the filesystem...?
12:42:45 <hyperisco> how do you call  ls  and pass it arguments
12:42:47 <geekosaur> sure. you don't necessarily want to feed HTML to a file expecting JSON
12:42:55 <geekosaur> er, to a program
12:42:57 <hyperisco> like, what is the type of  ls
12:43:05 <hyperisco> how do you know ls is a thing
12:43:48 <electricityZZZZ> well that would be part of some kind of "automatic prelude"
12:43:51 <geekosaur> but some commands are polymorphic (cp/copy) and others care only about the file itself and not its contents (ls/dir, rm/del)
12:44:46 <hyperisco> why not use ghci then
12:45:16 <Rembane> Turtle! 
12:45:25 <sm[m]> electricityZZZZ: another from from that list: https://github.com/gluon-lang/gluon
12:45:35 <Rembane> https://hackage.haskell.org/package/turtle
12:45:49 <electricityZZZZ> it's tempting but i would like to have a language where i can say that the user has "completed" learning it, and the guide to learning shouldn't be terribly long
12:45:56 <electricityZZZZ> ghci is tempting, i should say
12:46:09 <electricityZZZZ> yeah i was aware of and had already been looking at gluon
12:46:41 <sm[m]> oh, what about "just" building your own simple interpreted language then ?
12:47:18 <hyperisco> ZZZZscript
12:47:18 <electricityZZZZ> language design is best reserved for people with galactic sized brains
12:47:28 <sm[m]> oh but you want types, bells, whistles.. yes
12:47:41 <electricityZZZZ> and dhall is a good discovery here
12:48:26 <hyperisco> the billion dollar mistakes were strokes of unluckiness
12:48:40 <hyperisco> be fair, most languages die early with a whimper
12:49:26 <sm[m]> fair warning, lots of people talk about replacing R with a real language yet it vigorously fails to die
12:49:32 <electricityZZZZ> maybe one day if i ever understand corbidomorphic symplectolagrangian lattice monocategories i will consider language design
12:50:03 <electricityZZZZ> when i use R it's like a gigantic memory leak the entire time and then eventually it crashes and i frequently lose my work
12:50:12 <geekosaur> languages are easy to design. they're hard to make useful :)
12:50:18 <sm[m]> ouch.. but those domain-oriented languages tend to be highly good at their domain stuff
12:50:34 <electricityZZZZ> and i have to do these stupid interconversions of matrix and dataframe types and stuff all the time which the language should be able to figure out
12:50:47 <sm[m]> electricityZZZZ: you know about http://hackage.haskell.org/package/inline-r I suppose
12:50:59 <electricityZZZZ> i say, nuke the R ecosystem in its entirety
12:51:03 <dolio> You'll spend years before you're better than R.
12:51:27 <dolio> If you're implementing a new language from scratch.
12:51:38 <electricityZZZZ> well that's why i am looking for an existing language :)
12:52:06 <hyperisco> you're committing the nirvana fallacy on yourself
12:52:39 * electricityZZZZ just needs a sufficiently smart compiler and then an incredible number of problems will go away...
12:52:51 <hyperisco> if you have a particular vocabulary in mind then a domain-specific language is possibly a better idea
12:53:32 <hyperisco> you know what else people do? they think they're being smart by reusing an existing language and use JSON or XML
12:53:50 <electricityZZZZ> not sure i know what a vocabulary is here
12:54:04 <hyperisco> which is smart if you're describing data and not so smart if you're describing computation
12:54:41 <electricityZZZZ> in regards to R, R tries to be both what you write in the console and also how you write your program
12:55:13 <electricityZZZZ> here i would like to say, this language is not for writing programs, it is for issuing commands to a library ecosystem
12:55:52 <sm[m]> isn't that our ideal..
12:55:53 <electricityZZZZ> and if you want to do anything even slightly complicated you will need to jump into that ecosystem and the language it uses (a "real" programming language)
12:57:16 <geekosaur> until someone decides what they want to do should be considered simple and hacks it in, and shortly you have either a zillion forks or R. or both
12:58:45 <electricityZZZZ> so i guess you guys are saying that the moment you do more than invoke a process or a process with some command line arguments, and maybe some pipes, you need a programming language
12:59:18 <geekosaur> I'm pointing out that you can go simple but someone will always want more
13:00:15 <hyperisco> electricityZZZZ, if you were doing arithmetic then the vocabularly would be  0, 1, 2 ...   +, -, * ...
13:00:32 <electricityZZZZ> yeah so then they jump into haskell or rust or whatever
13:00:48 <monochrom> R can do arithmetic alright.
13:02:57 <sm[m]> why not a haskell EDSL, a wrapper over inline-r if convenient
13:04:42 <sm[m]> relatively cheap to build, can be made simple to use, can tap the full power of haskell
13:05:12 <sm[m]> gradually replace the R stuff as haskell data tools improve
13:09:00 <electricityZZZZ> because i think that nuking the R ecosystem is a good idea
13:09:22 <electricityZZZZ> i don't quite remember what i was dealing with a couple weeks ago but i had some fairly absurd problems with R dependency management
13:10:31 <sm[m]> a haskell EDSL, not using R in any way, then
13:10:53 <sm[m]> you know http://www.datahaskell.org I guess
13:10:57 <sm[m]> what do they use ?
13:13:19 <electricityZZZZ> idk it looks like a small project there :-P
13:13:42 <sm[m]> the github org seemed to have a few things
13:14:06 <sm[m]> I wondered what http://haskell.do does, but couldn't tell
13:14:58 <electricityZZZZ> it looks like it's just an easy repl/installer
13:42:33 <pjrt> Hey, what would you guys call the generalize form of `run` (run stateT, run Kleisli, etc)?
13:43:20 <pjrt> So essentially a typeclass that converts `F` to `G` given some value `S` (like run :: StateT f s a -> s -> f a)
13:47:26 <hyperisco> pjrt,  f a -> g a  is sometimes called a natural transformation, if f, g are Functor
13:48:04 <hyperisco> probably the alias  f ~> g  can be found somewhere
13:49:00 <pjrt> yeah, `run`, given the State value, gives u a natural transformation 
13:49:10 <hyperisco> yes
13:49:22 <pjrt> I was wondering what would you call that behavior (typeclass)?
13:49:46 <merijn> @hackage mmorph
13:49:46 <lambdabot> https://hackage.haskell.org/package/mmorph
13:49:56 <merijn> Sounds like you want MFunctor and monad morphisms :p
13:50:48 <hyperisco> or maybe the Category of natural transformations
13:51:21 <merijn> mmorph has natural transformations too, though :p
13:51:24 <electricityZZZZ> simple noob question: is idiomatic ordinary haskell both threadsafe? (and is it non-blocking?)
13:51:43 <electricityZZZZ> err that question needed a little bit of editing, but you get the drift, i mean each question independently :)
13:51:50 <hyperisco> Haskell blocks and instead you make a lot of app threads
13:51:55 <merijn> electricityZZZZ: Most stuff is threadsafe
13:52:02 <electricityZZZZ> oh, interesting
13:52:03 <merijn> electricityZZZZ: Non-blocking is...the wrong question
13:52:30 <electricityZZZZ> well i had imagined that the natural tendency of haskell to be lazy meant that some scheduler was handling the interleaving,...
13:52:33 <merijn> electricityZZZZ: GHC uses grean threads, so you'd normally have 1 thread per connection/whatever and just write blocking code
13:52:40 <merijn> s/grean/green
13:53:16 <merijn> electricityZZZZ: The setup is that you have N lightweight forkIO threads getting multiplex over M actual OS threads (where N can be much bigger than M)
13:53:27 <electricityZZZZ> understood,
13:53:50 <merijn> electricityZZZZ: On an average server machine 10k-100k forkIO threads would be completely reasonable/doable
13:54:04 <hyperisco> there is probably a cooperative scheduler somewhere you can use
13:54:15 <hyperisco> with coroutines and that jazz
13:55:21 <merijn> electricityZZZZ: The RTS has a core event loop built on kqueue/epoll/whatever your OS provides, so when you do a blocking call the thread just registers the call with the event loop and goes to sleep
13:55:44 <merijn> electricityZZZZ: The main event loop then dispatches wake-ups to threads as their calls complete
13:56:11 <hyperisco> but if you really want to know what's up we have to talk about lattices :P
13:56:38 <merijn> electricityZZZZ: So writing dumb blocking code with 1 thread per connection automatically turns into a traditional kqueue/epoll event loop underneath without you having to think about it
13:58:32 <electricityZZZZ> so i am probably getting ahead of myself here and i don't mean to get into the whole IO thing,
13:59:03 <electricityZZZZ> but i was thinking that something would be "pulling" the execution of thunks
13:59:51 <pjrt> merijn:unn, this doesn't look quite right. This allows me to map natural transformations into transformers. But I'm mostly looking for the general form of the `runKeisli/runState` functions :\
14:00:21 <hyperisco> electricityZZZZ, sure, just doesn't necessitate parallelism
14:00:24 <pjrt> Maybe I can derive them from that? Don't quite see it
14:00:30 <hyperisco> but there is a library that lets you parallelise with lists
14:00:45 <electricityZZZZ> i'm saying that i understand the idea of an executor having multiple threads
14:01:32 <merijn> electricityZZZZ: I feel a "but..."
14:01:43 <electricityZZZZ> well i'm nervous since i'm not sure whether i am talking complete nonsense here
14:01:58 <electricityZZZZ> so something has assigned thunks to that executor right?
14:02:51 <merijn> electricityZZZZ: So, in the GHC RTS there are "capabilities" which roughly corresponds to "an OS thread executing Haskell code". You start with just one capability running one thing (i.e. "main")
14:02:59 <electricityZZZZ> right
14:03:28 <merijn> electricityZZZZ: Then there's "forkIO :: IO a -> IO ThreadId" which basically says "start a new thread executing this 'IO a' action"
14:04:04 <merijn> electricityZZZZ: Note that the old and new thread may share a ton of references (which may or may not be thunks)
14:04:17 <merijn> electricityZZZZ: The thunks get evaluated "as needed" by either of them
14:04:57 <merijn> electricityZZZZ: And you can dive quite deep into GHC details about "blackholing", "greyholing", etc. when talking about how GHC manages who evaluates what/when
14:05:27 <electricityZZZZ> by references you mean memory references?
14:05:48 <merijn> electricityZZZZ: But (unless you messed with unsafePerformIO!) since everything is purely functional it doesn't actually matter how many times a thunk gets evaluated, since it'll compute to the same thing anyway!
14:05:53 <merijn> electricityZZZZ: Yeah
14:06:18 <electricityZZZZ> my thought was that something would say "here is the expression the executor (or capability, in this case) must execute",
14:06:32 <merijn> sorta
14:06:43 <electricityZZZZ> and then the capability as you are calling it will work through that expression, which is lazily evaluated
14:06:52 <merijn> electricityZZZZ: If you're interested in this sorta thing I'd recommend giving the STG paper a look
14:06:53 <electricityZZZZ> or nonstrictly evaluated, i should say
14:07:07 <electricityZZZZ> i tried reading the STG paper three times and it was too technical
14:07:13 <merijn> ah
14:07:14 <electricityZZZZ> not sure i'm cut out to write software but i'm trying ;)
14:07:20 <merijn> Where'd you get stuck?
14:08:03 <electricityZZZZ> i'll take another look at the paper now, but
14:08:23 <electricityZZZZ> let me just ask--so the capability is trying to execute an expression
14:08:48 <merijn> yeah
14:08:54 <electricityZZZZ> if the expression itself is lazy why does it need to be able to "spawn threads", ... spawning a thread seems like a non-fp way of thinking
14:09:26 <merijn> electricityZZZZ: Note that these are two separate notions (which many people sloppily mix up)
14:09:36 <electricityZZZZ> which and which?
14:09:42 <merijn> electricityZZZZ: Threads (in the forkIO sense) are for *concurrency*
14:10:00 <merijn> That is "actions that can happen with an arbitrary interleaving that it unknown until runtime"
14:10:22 <merijn> electricityZZZZ: We can also have parallelism (which is an implementation detail of things happening at the same time)
14:10:54 <merijn> electricityZZZZ: You can have concurrency without parallelism (think of old single core CPUs where you used preemptive scheduling to switch between processes)
14:11:02 <electricityZZZZ> yes i know
14:11:13 <merijn> Here things "seem" to happen arbitrarily but only one thing happens at a time
14:11:29 <merijn> We can have parallelism *and* concurrency (i.e. OS threads on a multi core CPU)
14:11:31 <electricityZZZZ> parallelism would be more like cutting an expression in half and dividing the halves across a couple of cpus
14:11:37 <merijn> But you can also have parallelism without concurrency
14:11:41 <electricityZZZZ> and concurrency is what most people mean when they say async
14:11:42 <sm[m]> question: how do you reliably remember which is which :)
14:11:45 <merijn> Think of things like SIMD operations
14:11:59 <merijn> Which are perfectly deterministic despite being parallel
14:12:09 <merijn> electricityZZZZ: So GHC actually has a notion of *sparks*
14:12:10 <electricityZZZZ> yes, i understand that
14:12:24 <merijn> electricityZZZZ: A spark is just "a small thunk that may be evaluated in parallel"
14:12:46 <electricityZZZZ> ok, a unit of work
14:12:47 <merijn> electricityZZZZ: So you *can* do parallelism like that in GHC. But it serves a different purpose from forkIO
14:13:26 <merijn> forkIO is more for things like "I want to wait until there's data on socket A" and "I wanna wait until there's data on socket B" and not manually juggle what order that happens in
14:13:31 <electricityZZZZ> i think what i am failing to understand is that if my code itself is defined nonstrictly why do i need to talk about threads at all to get concurrency
14:13:45 <merijn> electricityZZZZ: Because we wanna do our IO concurrently
14:14:22 <merijn> electricityZZZZ: Now, you could get rid of IO and have IO happen "on demand" as thunks get evaluated
14:14:40 <merijn> But if you try programming in a system like that you will quickly go madder than the protagonist of a Lovecraft novel :p
14:15:06 <merijn> Because, it turns out, that we generally *do* care about the order in which our IO happens
14:15:09 <electricityZZZZ> this seems like a very deep concept and i don't quite understand,
14:15:20 <electricityZZZZ> okay so the thread imposes an ordering on IO?
14:15:20 <merijn> So we have the IO monad to enforce "A happens before B"
14:15:38 <merijn> electricityZZZZ: the IO datatype imposes an ordering on IO
14:16:16 <merijn> electricityZZZZ: So if we want concurrency we know need some explicit way to "decouple" "sequence of IO actions #1" from "sequence of IO actions #2"
14:16:24 <merijn> Which is what forkIO does
14:16:57 <merijn> It takes an IO action and start evaluating it (sequentially) but separate from the original parent IO action that executed "forkIO"
14:17:07 <electricityZZZZ> but managing threads is its own horror show
14:17:23 <merijn> electricityZZZZ: Is it, though? What's the hardest thing about threads?
14:17:39 <merijn> electricityZZZZ: The answer is always "shared mutable state"
14:17:47 <merijn> But guess what we don't have a lot of in Haskell :p
14:18:02 <electricityZZZZ> i don't know, i've only managed to write very simple forms of threaded code like determinstic parallelism, and some commutative stuff
14:18:48 <merijn> electricityZZZZ: The problem with threads (in other languages) is that it's super hard to synchronise mutation in a way that does drive you crazy. But since we've eliminated like 90% of the mutation in Haskell it's actually pretty easy
14:19:47 <electricityZZZZ> and then IO here is... a timer on a device...?
14:19:55 <electricityZZZZ> like a clock on a network card or something...?
14:20:16 <merijn> network access, filesystem stuff
14:20:27 <electricityZZZZ> it's an operating system file descriptor?
14:21:13 <merijn> electricityZZZZ: IO is just an abstraction for "stuff that interacts with the external world" (well, not just, but approximately...it's a bit messy)
14:21:35 <electricityZZZZ> right but you were talking about imposing an order
14:21:52 <electricityZZZZ> on IO events, so how does anything know what order those IO events occur in in the first place
14:22:04 <electricityZZZZ> seems like if something is an IO event, it should by law have a timestamp
14:22:08 <merijn> The order is just that in "a >> b" IO guarantees "all of the IO of 'a' happens before 'b'"
14:22:40 <electricityZZZZ> right but the issue seems to be that these events don't have an associated timestamp so you need to do strange things to figure out what order they are supposed to be in
14:23:29 <merijn> I'm not sure why you would need to figure out what order they're in?
14:23:46 <merijn> The exact orders is already written down and encoded in the source code you wrote
14:24:25 <electricityZZZZ> well you were saying that laziness needs a thread in order to determine the time ordering of IO events...?
14:24:30 <merijn> "do { foo; bar; quux }" translates do "foo >> (bar >> quux)" (or maybe the parenthesis are the other way around, doesn't matter) either way the >> guarantees an order
14:25:08 <merijn> electricityZZZZ: Oh, if you do the IO lazily then you don't have an order and figuring out in what order things happen is essentially impossible, yes
14:25:15 <electricityZZZZ> right
14:25:17 <merijn> Which is why we don't do IO lazily
14:25:25 <electricityZZZZ> right, but if the IO always had a timestamp
14:25:30 <electricityZZZZ> then you would have an ordering
14:25:34 <merijn> (well, unless you do unsafeInterleaveIO, but then you've only got yourself to blame!)
14:25:41 <merijn> electricityZZZZ: That doesn't work
14:25:51 <merijn> electricityZZZZ: Because how would you come up with a timestamp
14:26:04 <electricityZZZZ> a packet arrives at a network card, network card timestamps it
14:26:27 <merijn> electricityZZZZ: But how do you know when to even run the IO to interact with the network card?
14:26:46 <merijn> You'd have to be able to predict the future of when all external events happen
14:26:58 <electricityZZZZ> oh so it has to pull?
14:27:26 <merijn> I'm not sure what that means
14:27:28 <monochrom> I have not really followed this discussion, but it sounds like an XY solution looking for an XY problem.
14:27:46 <merijn> Well, I think we've had a circular confusion
14:27:51 <merijn> s/had/hit
14:27:58 <cheater> merijn: with hardware, you often have a callback somewhere in memory that a hardware interrupt will trigger
14:28:00 <monochrom> Instead may I entice you with a little bit of knowledge I just learned today about TH?
14:28:11 <cheater> merijn: so it's a function that will be run if a specific hardware event happens
14:28:17 <cheater> monochrom: no!!!!
14:28:27 <electricityZZZZ> monochrom: go for it i dont meant to hog the airwaves
14:28:35 <merijn> cheater: Right, but you can't know when that happens, so we are back to "the order in which things happen is completely unpredictable and you go insane like the proveriable Lovecraft protagonist"
14:28:44 <electricityZZZZ> cheater: yeah thats what i am thinking, hardware triggers an event defined by my source,...
14:28:53 <merijn> electricityZZZZ: See above
14:29:07 <koz_> I'm trying to write an hspec Spec which needs to run an IO action giving an 'a', then do something with that 'a'. How do I access this 'a'? 
14:29:12 <merijn> You can do that IFF you give up on having any clue in which orders things in your code will happen
14:29:16 <electricityZZZZ> and then that event says "hey capability/executor, here's a nonstrict thunk for you to evaluate"
14:29:51 <merijn> electricityZZZZ: That thunk then happens to do some more IO and you lose all sense of causal relationship between "what you write" and "what happens at runtime"
14:30:06 <koz_> I started it with 'beforeAll myIOAction $ ...' but I don't know what goes in the ...
14:30:09 <merijn> Personally, I am very fond of being able to predict "what can happen at runtime" from "what I wrote" :)
14:30:17 <electricityZZZZ> hehe ok
14:30:23 <glguy> If you don't want to know when things are going to happen you can always use a separate thread
14:30:27 <koz_> I'm only familiar with how to write Specs where _no_ additional IO stuff has to happen.
14:30:47 <merijn> glguy: That was our starting point of discussion...
14:30:49 <electricityZZZZ> but anyway i learned a lot here: the purpose of a thread is to impose an ordering on IO
14:30:57 <merijn> electricityZZZZ: No
14:31:07 <merijn> IO already *has* an ordering
14:31:16 <merijn> Which comes from what you wrote down
14:31:23 <electricityZZZZ> okay, to associate program execution ordering with IO ordering
14:31:31 <glguy> monochrom: What'd you do with TH?
14:31:48 <merijn> The purpose of a thread is to have a second (or third, or...) *independent* sequence of IO actions
14:31:56 <koz_> This is all I have to go on, but it's not helping me much: http://hspec.github.io/writing-specs.html#using-hooks
14:32:24 <merijn> electricityZZZZ: so if I have "foo :: IO a" and "bar :: IO b" all the actions within foo have an ordering with respect to each other, the same for "bar"
14:32:30 <monochrom> So today I learned about TH's definition of "declaration group" and what a splice can see and cannot see.
14:32:54 <merijn> electricityZZZZ: Now, when I write "do { forkIO foo; forkIO bar }" both of those *still* have the original deterministic ordering of IO from the source
14:32:55 <glguy> did you learn about the hack of putting (pure []) on its own line to split up groups?
14:33:03 <monochrom> Yeah!
14:33:18 <merijn> electricityZZZZ: But the ordering/interleaving of the actions of 'foo' with respect to 'bar' is arbitrary and unknown
14:33:54 <monochrom> Because I had an expresion splice, rather than a top-level declaration splice, that wanted to read a "data T = ..." present in the source code before it.
14:34:13 <koz_> Never mind, figured it out, just bad inference.
14:34:33 <merijn> electricityZZZZ: So one thread will be doing the IO actions of "foo" in deterministic order. The other thread will be doing the IO actions of "bar" in deterministic order. But when an IO effect of 'foo' happens in relation to IO effects of 'bar' is unspecified
14:34:59 <dolio> merijn: This isn't really the whole story, I think.
14:35:04 <merijn> dolio: Sure
14:35:15 <electricityZZZZ> merijn: understood, those were useful details, but i imagined that as included in the realm of what i meant by "an ordering"
14:35:22 <merijn> dolio: But do you think more detail will *help* or *hurt* the explanation? :p
14:35:26 <electricityZZZZ> it's very much like lifetimes in rust
14:35:27 <merijn> dolio: Because I'm betting on the latter
14:36:43 <monochrom> Oh I also want to confirm with you a little knowledge I guessed from reading the "GHC execution model" slides.
14:37:41 <dolio> merijn: I don't know. I guess it wouldn't help to know that you can't even rely on 'sequencing' of things to even make sense everywhere.
14:37:42 <monochrom> Suppose the RTS decides it's time to interrupt a green thread, for example because it's time to let another green thread has a chance to run.
14:38:26 <merijn> dolio: unsafeInterleavIO ruins everything, as does pointing out that you can explicitly sequence threads via STM/MVar/etc. :p
14:38:35 <dolio> merijn: I'm not talking about unsafeInterleaveIO.
14:39:05 <monochrom> It does this sneaky thing of artificially setting the heap headroom to say "heap is full" so as soon as the targetted green thread tries to allocate, it's forced to call GC, and that's how the RTS can regain control. Is that right?
14:39:24 <merijn> monochrom: Yes
14:39:41 <merijn> monochrom: You can, in fact, hard lock the scheduler of a thread gets stuck in an infinite loop that doesn't allocate
14:39:46 <monochrom> This blows my mind but also solves a mystery I have had.
14:39:48 <merijn> s/of a/if a
14:40:04 <dolio> Like, IORef states that you can see behavior that doesn't correspond to any actual interleaving of threads, because some processors don't guarantee that.
14:40:29 <merijn> dolio: sequential consistency is even more out of scope for talking to beginners at parallelism ;)
14:40:59 <monochrom> Because I have always looked at the asm code and it really doesn't have an unconditional "yield" point, the only thing remotely close to "yield" is "if heap full then call GC" but it's under such a generous condition.
14:42:13 <merijn> (or rather, the lack of sequential consistency)
14:44:05 <isovector1> is there a kliesli endo monoid anywhere?
14:45:31 <Lycurgus> if so i bet it's with the kleisli things
14:54:28 * Lycurgus (e.g.: https://hackage.haskell.org/package/base-4.14.0.0/docs/Control-Arrow.html#g:4 )
14:57:49 * hackage cabal-auto-expose 0.1.0.0 - Build time library that autodetects exposed modules  https://hackage.haskell.org/package/cabal-auto-expose-0.1.0.0 (deech)
15:52:29 <koz_> Is there a way to automagic Ord via Generic?
15:53:59 <edwardk> koz_: yes.
15:54:18 <koz_> edwardk: What is that way?
15:54:29 <edwardk> http://hackage.haskell.org/package/contravariant-1.5.2/docs/Data-Functor-Contravariant-Generic.html
15:54:31 <edwardk> see gcompare
15:55:07 <edwardk> Deciding Ord x is a constraint for some x which is made of Generic bits of sums and products over leaf values which all satisfy Ord
15:55:28 <edwardk> the incantation i provide there shows how to use that constraint.
15:58:03 <koz_> Thanks!
17:22:34 <bearclaw> is there a web tour for haskell
17:27:53 <untseac> hello. I want to take N times to the result of a string. For example, take [2,3,1] "aabbbc" would result in ["aa", "bbb", "c"]. Is there a good way to do this?
17:28:21 <untseac> or split or whatever is best
17:29:02 <electricityZZZZ> i took another look at the STGM paper and am realizing that one reason my eyes glazed over is that this appears to focus on (?) mapping executing some kind of nonstrict language onto a von neumann architecture, it talks about stacks and soforth
17:30:28 <electricityZZZZ> i would rather know at the "best conceptual abstract level" what i need to compute using my hand and a piece of paper in order to follow what's going on
17:30:53 <electricityZZZZ> merijn: see above,... i'm not sure that you guys should be regularly recommending the STGM as a starting point for understanding what's going on
17:31:58 <sshine> untseac, before turning this into an X-Y problem, what are you really trying to do?
17:32:40 <untseac> sshine, i'm trying to split a string multiple times given a list of sizes
17:33:18 <untseac> so I could use splitAt many times
17:33:32 <untseac> and use the second part each time
17:33:35 <sshine> yeah?
17:33:56 <untseac> but I kind of want to do: magicalSplit [2,3,1] myString
17:34:51 <untseac> instead of: one = splitAt 2 (x, y); two = splitAt 3 (y, z); three = splitAt 1 (z, w)
17:35:47 <sshine> like this? https://gist.github.com/sshine/9512ee599ccb40e788321e8a4bc0b877
17:36:04 <untseac> yeah like that
17:36:12 <untseac> thanks
17:36:33 <sshine> you're welcome.
17:37:05 <sshine> how is it magical? :)
17:37:54 <untseac> it's not. it's just me forgetting simple things :p
17:39:57 <sshine> I don't like the function so much because the [Int] input might not align with the String input.
17:41:38 <untseac> true but I can figure out from here those cases
17:41:49 <ryjm> o/
17:42:10 <untseac> \o h5
18:02:09 <ezzieyguywuf> I find myself in need of `fmap . fmap`, because I have a `f :: A a -> a` and I want to apply it to the result of `g :: State [A a]` to produce a `State [a]`
18:02:22 <ezzieyguywuf> is there....some other pre-built function that accomplishes this same behaviour?
18:02:39 <dolio> Nope.
18:02:56 <Axman6> but it is often written as fmap f <$> statefulThing
18:03:21 <ezzieyguywuf> ah, I see
18:21:28 <sshine> (f <$>) `fmap` statefulThing
18:30:53 <sm[m]> bearclaw: there might be something at https://www.haskell.org/documentation/
18:31:43 <sm[m]> otherwise, maybe https://www.youtube.com/results?search_query=beginning+haskell
18:49:13 <dminuoso> ezzieyguywuf: If this starts to become a theme, lens/optics is an approach to dealing with nested types.
18:50:52 <bearclaw> sm[m]: thanks
19:43:00 <sooch> has anyone had any experience with setting up a simple GHC and Cabal install on a remote docker container you dont own?
19:44:59 <dminuoso> What do you mean by "you dont own" exactly?
19:46:07 <sooch> I am a student, and for this specific class we are allowed to use any language. The grading system is a Ubuntu18.04 container.
19:46:36 <sooch> I need to construct a makefile that will download ghc and cabal
19:47:03 <dminuoso> sooch: Use ghcup! :)
19:47:16 <dminuoso> https://www.haskell.org/ghcup/
19:47:21 <sooch> I tried that on my own system but it seems like it requires manual input?
19:48:00 <dminuoso> Well you can feed manual input
19:48:04 <dminuoso> If any
19:49:30 <suzu_> i'm trying to debug a segfault in a compiled program on osx
19:49:39 <sooch> I will see if I can get it to work. I was excited to be able to use something other than java or python for once lol.
19:50:37 <justsomeguy> (Out of curiosity, what class are you taking? That sounds fun :)
19:50:37 <suzu_> i'm building it with stack, and i added debug symbols to the build:
19:50:39 <suzu_> ghc-options:
19:50:41 <suzu_>   "$everything": -haddock -g -dcore-lint -debug
19:50:51 <suzu_> but i can't find them when i attach lldb to the executable while its running
19:53:23 <dminuoso> sooch: Note, if you're not too picky about versions, you can just install ghc and cabal via apt.
19:53:34 <sooch> justsomeguy: Theory of Computation. It seems like a good fit.
19:54:13 <sooch> dminuoso: Yeah, I may have to. Dependency hell has set in and I can't seem to get certain packages to work
19:54:45 <suzu_> sooch: can you use any image you like?
19:55:01 <dminuoso> suzu_: If you read above, the grading system is Ubuntu18.04
19:55:41 <suzu_> ah yes
19:55:44 <suzu_> install stack? :)
19:55:57 <sooch> I tried to add the hvr repo, but i kept getting apt-utils error. Which I couldn't seem to correct.
19:56:23 <sooch> The other issue is I can't see the output of any commands I run. So I'm flying blind with errors.
19:58:03 <justsomeguy> sooch: It does seem like a good fit. Reading the first chapter of haskellbook.com alone lead me down a nine level deep rabbit hole on Wikipedia that started with lambda calculus, veered into an overview of mathematical logic (decision problem), and ended in computability. I'm not sure I understand anything, but I learn a bunch of new words. :^p
20:02:23 <sooch> justsomeguy: I have a feeling I will end up spending more time reading wikipedia pages on topics I'm not qualified to read than doing actual work
20:02:44 <justsomeguy> It's a trap.
20:03:07 <justsomeguy> ...but kind of a fun one :)
20:04:58 <sooch> Anyone know how to send an enter key through a make file lol...
20:08:46 <justsomeguy> sooch: Maybe you can edit the bash file that ghciup uses to remove the prompt?
20:08:52 <justsomeguy> ghcup, rather
20:09:34 <sooch> I actually got a great error message this time. Looks like it worked on its own.
20:16:49 * hackage reanimate 0.5.0.0 - Animation library based on SVGs.  https://hackage.haskell.org/package/reanimate-0.5.0.0 (DavidHimmelstrup)
