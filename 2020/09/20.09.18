00:01:40 <dminuoso> jchia: This requires a prism afaik
00:01:48 <dminuoso> % review _Left 10
00:01:49 <yahb> dminuoso: Left 10
00:04:52 <dminuoso> Ultimately, with lens I think you cant get around saying: input & key "a" .~ object ["b" .= object [c .= object []]]
00:05:03 <dminuoso> Ah, missing some quotes around c in there
00:05:28 <dminuoso> You could, make a fold out of this presumably
00:09:06 <dminuoso> let emptyChain xs = fold (\l r -> object [l .= r]) xs [] 
00:09:31 <dminuoso> in emptyChain ["a", "b", "c"]
00:09:45 <dminuoso> oh with foldr as well. 
00:10:09 <dansho> does stack work on MSYS2? can't install cabal https://hastebin.com/muzaxovove
00:10:13 <dminuoso> So let emptyChain xs = foldr (\l r -> object [l .= r]) [] xs in emptyChain ["a", "b", "c]
00:17:40 <[exa]> dansho: that doesn't really look like msys2-specific error
00:33:11 <dansho> [exa], it's a fresh install of stack with 'curl -sSL https://get.haskellstack.org/ | sh'
00:34:10 <dansho> i don't use stack normally so i may be missing something, the installation instructions dont mention any more steps: https://docs.haskellstack.org/en/stable/install_and_upgrade/
00:34:53 <[exa]> my immediately-unhelpful opinion would be to avoid stack, but I guess that doesn't help you immediately
00:35:28 <[exa]> can you do with say just ghcup?
00:36:01 <maerwald> installing cabal-install from hackage has always been a bit shaky... better just get the binary
00:36:16 <[exa]> +1
00:36:58 <dansho> [exa], tried that: Unknown platform: MSYS_NT-10.0-19041
00:37:30 <dansho> or in a mingw64 shell: Unknown platform: MINGW64_NT-10.0-19041
00:40:26 <dansho> i guess i have access to ghc through 'stack ghc'
01:34:48 <Unhammer> Do I need more than 16G RAM to run haskell-language-server ?
01:35:41 <Unhammer> free -m says 5588, but I keep getting "libpthread.so.0: failed to map segment from shared object" or "mmap: failed. errno = 12" or (if I do ulimit -Sv unlimited) "allocatestack.c:384: advise_stack_range: Assertion `freesize < size' failed"
01:36:35 <maerwald> Unhammer: you need more than 16G ram to run GHC
01:37:32 <Unhammer> uh no?
01:37:39 <maerwald> yes
01:37:49 <Unhammer> I compile things all the time
01:37:52 <maerwald> depends on the project you're working on ofc :)
01:38:26 <maerwald> I've hit ram limit very frequently on some projects with ghc and 16g
01:38:50 <maerwald> so 32 is more reasonable and there's a chance the language server fits into it
01:39:10 <Unhammer> well, my project compiles fine in ghc with <4G free, but haskell-language-server keeps failing. Guess I'll try dante.
01:39:49 * hackage pgf2 1.2.1 - Bindings to the C version of the PGF runtime  https://hackage.haskell.org/package/pgf2-1.2.1 (JohnCamilleri)
01:46:03 <phadej> I wonder if I'm net-negative or net-positive in saved time, as I didn't ever bothered to look on anything more complicated than ghcid
01:48:39 <Unhammer> probably positive 
01:48:41 <Lycurgus> 0.0
01:48:42 <Unhammer> but I like "go to definition"
01:48:58 <phadej> hasktags works reasonably well too
01:49:43 <phadej> (given you don't reuse names too much, which OTOH ide supporters promote too ;)
01:50:04 <maerwald> I used to use codex, which uses hasktags, but it seems it's broken now
01:53:24 <dminuoso> Dependency cycle between the following components: library
01:53:24 <dminuoso> A cycle between `library`. Uh.
01:54:14 <phadej> it probably depends on itself.
01:55:11 <dminuoso> phadej: It says `In the inplace package 'freyja-api-0.2.0.0'`, but that package builds just fine.
01:57:48 <phadej> some private package? (i.e. not on Hackage?)
01:58:13 <phadej> sorry, cannot help with those.
01:58:14 <dminuoso> Oh haha. This is a subtle one, which I somewhat regularly read others do as well.
01:58:24 <dminuoso> I copy pasted a cabal file, so I had two packages with the same name
01:58:35 <dminuoso> (by name I mean the actual name field in the cabal file)
02:00:25 <dminuoso> Think edward mentioned this a few times as well
02:01:56 <Rembane> I wonder if that has been reported as a bug. I would love to have cabal scream and shout when that happens. 
02:03:04 <int-e> dminuoso: how should cabal-install know that it's not two different versions of the same package?
02:04:11 <int-e> (hmm, there was no need for that highlight)
02:04:39 <dminuoso> Is that even supported?
02:05:48 <int-e> I don't know. I thought all the "new" nix-style stuff was meant to support this as well.
02:07:20 <dminuoso> Well coexistence in the store. If this was in the same build plan, either there'd be no interop possible or you could have incoherent code
02:07:35 <dminuoso> So Im not quite sure what benefit you'd have if there was two different packages of the same version
02:07:47 <dminuoso> err, two different versions of the same package >:)
02:08:03 <int-e> But there is the diamond problem, so doing this on a project level needs a distinction between internal and externally visible dependencies and I'm not up-to-date on whether this exists or not.
02:08:32 <int-e> dminuoso: Well in a world where all your projects share a single store...
02:08:44 <int-e> ...some of which may be stable and others may be living on the edge...
02:09:02 <int-e> I think there's a benefit of having multiple versions of the same package in the store.
02:09:12 <dminuoso> well, if you have incompatible version bounds on some shared dependency, then no build plan can be generated
02:09:19 <dminuoso> this happens all the time when people forget to bump base bounds
02:09:22 <int-e> I don't like this world. I like (soon: liked) sandboxes.
02:09:31 <dminuoso> Sure, in the store!
02:09:39 <dminuoso> But not inside a package
02:10:29 <dminuoso> So Im thinking, cabal ought to just complain "there's two packages with the same name `foo`, so your dependency on `foo` is ambiguous. please fix"
02:10:44 <int-e> hmm is this some subpackage stuff?
02:10:47 <dminuoso> yeah
02:11:10 <int-e> Okay, yeah then I see no reason to support this.
02:11:22 <dminuoso> I have foo-server/ foo-api/ and foo-api-swagger/ with the obvious dependencies.
02:11:46 <dminuoso> Now, foo-api-swagger/_.cabal was copied from foo-api/_.cabal, but I forgot to change its name
02:11:52 <dminuoso> (and cabal project files tie them together)
02:12:14 <dminuoso> so actually
02:12:17 <dminuoso> this is not subpackages
02:14:29 <int-e> right.
02:14:36 <int-e> this is me lagging behind the times.
02:14:53 <int-e> (I'm still using v1 commands... will need to switch soon though.)
02:15:53 <int-e> (and my substitute for cabal projects has been sandboxes and canned add-source commands in a shell script)
02:22:14 <chreekat[m]> I use fast-tags + ghcid , and I think any improvements for me would entirely be improvements to Cabal, not to the other tools. I.e. it would be really nice to be able to repl *both* the library *and* the tests at the same time. As it is, I often have two separate windows, repl'ing the two separate components, and the test repl is further buried under `entr`...
02:22:50 <chreekat[m]> I'm not saying that fast-tags + ghcid is nirvana or anything, +1 to people making better tools all around, everywhere
03:04:21 <siraben> Should I use haskell.packages.ghc8102.ghcWithPackages in my nix-shell or install things with cabal instead?
04:14:15 <maerwald> int-e: you can emulate sandboxes with cabal --store-dir=$(pwd) build
04:14:19 <kuribas> is jhc still developped?  Why would you use it over ghc?
04:15:17 <galagora> Why isn't base 4.14.1.0 on Hackage?
04:15:27 <maerwald> aplainzetakind: I fixed the thing were ghcup cannot compile the same version as the bootstrap version
04:27:19 * hackage rpmbuild-order 0.4.3 - Order RPM packages by dependencies  https://hackage.haskell.org/package/rpmbuild-order-0.4.3 (JensPetersen)
04:38:06 <c_wraith> galagora: because you can't download it and just use it.  versions of base are tightly tied to versions of GHC.
04:39:59 <c_wraith> Hmm.  it's usually there for documentation though.  Maybe there are no doc difference between 4.14.0.0 and 4.4.14.1.0
05:05:23 <Flaapt> Silence!
05:09:47 <tomsmeding> Flaapt: https://ircbrowse.tomsmeding.com the channel is not silent, though that particular 30 seconds might have been ;)
05:10:58 <Flaapt> And here I felt all mighty and powerful
05:12:06 * ski glances nervously at Flaapt
05:14:08 <Flaapt> No worries. Im just exploring irc and voices told me this was an interesting channel
05:15:48 <ski> it can often be
05:15:49 * hackage graphql-w-persistent 0.9.1.0 - GraphQL interface middleware for SQL databases.  https://hackage.haskell.org/package/graphql-w-persistent-0.9.1.0 (jasonsychau)
05:39:49 <Flaapt> Hi
05:42:24 <ophania> HI
05:43:41 <ski> hello
06:12:19 * hackage streamly-lmdb 0.1.0 - Stream data to or from LMDB databases using the streamly library.  https://hackage.haskell.org/package/streamly-lmdb-0.1.0 (shlok)
06:31:26 <exarkun> dminuoso: What about https://github.com/dminuoso/servant-prometheus ? :)
07:20:49 * hackage polysemy-http 0.2.0.3 - Polysemy effect for http-client  https://hackage.haskell.org/package/polysemy-http-0.2.0.3 (tek)
07:24:36 <exarkun> I guess there are some build issues.
07:24:38 <galagora> Hey, any Hackage trustees willing to fix https://github.com/haskell/base16-bytestring/issues/14?
07:26:13 <Uniaika> topos: ^
07:26:19 <Uniaika> ah no, sorry
07:27:03 <Uniaika> I think hvr_ is one, though
07:28:21 <merijn> This is what you get when people say they shouldn't add upperbounds on dependencies because "updating them is too much work" >.> then they end up breaking everyone else when their dependencies update >.>
07:29:05 <maerwald> That's why distros test reverse dependencies before pushing new versions
07:30:50 <maerwald> Or just don't change your API all the time :)
07:31:08 <maerwald> Deprecation warnings are a thing too
07:32:38 <merijn> Or you follow the PVP
07:33:12 <maerwald> That's what got us into cabal hell in the first place
07:33:28 <maerwald> but I think that's a philosophical discussion
07:35:22 <maerwald> the semantic difference of ^>= isn't really used in practice, is it?
07:36:13 <merijn> maerwald: You can only relax only ^>= when building, iirc
07:37:40 <merijn> maerwald: I advertise that my packages follow the PVP, I refuse to take on additional testing responsibilities because other people write shitty bounds when they depend on my code and I think that sorta "extra unpaid labour" is toxic to open source as a whole
07:37:59 <maerwald> merijn: that's what CI is for
07:38:09 <maerwald> distros have been doing this for 20+ years
07:38:24 <merijn> maerwald: I do CI, to see if *my* stuff builds
07:38:33 <maerwald> we already have hackage CI
07:39:03 <merijn> That doesn't build candidates, afaik
07:39:08 <merijn> So that doesn't help
07:39:26 <maerwald> Yes, it needs to be extended
07:39:30 <merijn> Because it only notices breakage when you release a new version, at which point it's already the problem of "stuff depending on you"
07:40:06 <maerwald> these aren't hard problems... it's just work and infrastructure someone has to pay
07:40:11 <merijn> maerwald: And then what? Something that depends on my stuff breaks, now I have to someone annoy a maintainer of some obscure package to fix it before releasing my stuff?
07:40:25 <maerwald> yes, that's called communication :p
07:40:40 <maerwald> you publish a release candidate so to speak
07:40:55 <merijn> maerwald: Right, so we "just" need to solve the "funding open source development" problem...I'm sure that's an easy problem we'll fix in no time!
07:41:14 <maerwald> then CI picks up your release candidate, builds reverse deps with it and sends emails to maintainers 
07:41:18 <maerwald> can all be automated
07:41:28 <maerwald> none of this is difficult
07:41:42 <merijn> maerwald: I await your patches enthusiastically, then ;)
07:42:15 <maerwald> I don't believe tooling makes a healthy ecosystem. CI and communication does.
07:43:36 <merijn> I believe communicating is another dose of "extra unpaid responsibility" which is not something that can be expected from unpaid volunteers :)
07:43:55 <maerwald> well, if you don't care about anything or anyone, keep your package on github
07:43:57 <yushyin> so why can't there be upperbounds and also emails to inform maintainer to update the bounds? So I can release my stuff without breaking other stuff.
07:44:01 <yushyin> :/
07:44:30 <merijn> yushyin: Well, that's what I advocated
07:44:38 <yushyin> ok!
07:45:00 <merijn> yushyin: But there's a group of "aggressively anti-upperbounds" people
07:45:35 <maerwald> don't turn this into politics :)
07:45:46 <merijn> Who argue that you should never have those, because bumping them on release is too much work, but magically breaking build-plans when your dependencies update is not more work
07:45:54 <merijn> maerwald: *everything* is politics
07:46:04 <phadej> it is politics. There are rational arguments, but they are dismissed
07:46:49 <merijn> And "multi-billion tech corporations offloading all their maintenance work on unpaid open source volunteers" is *especially* politics
07:47:28 <maerwald> merijn: weird, when I worked on linux distros for half a decade, no one paid me and we still pulled it off
07:48:13 <maerwald> so yes, you can decide different routes and they have different problems
07:48:24 <merijn> maerwald: I'm not saying it can't be done
07:48:38 <merijn> I'm saying that building a world where that's normal is morally wrong
07:49:29 <merijn> maerwald: I'd like a world where you *wouldn't* have to do that unpaid work just to keep digital infrastructure from collapsing
07:50:05 <maerwald> merijn: I don't think it makes anything collapse, that's why you pin hackage state
07:50:58 <maerwald> But I would like a release candidate workflow that's powered by testing reverse dependencies
07:51:10 <maerwald> at least for a set of core packages, maybe
07:51:45 <maerwald> Anything outside hackage can go f...find someone else to fix :)
07:56:33 <sm[m]> chreekat: It's easy to repl multiple components at once, there's a recent reddit thread on it
07:58:57 <maerwald> merijn: an alternative approach is https://dependabot.com/rust/
07:59:39 <maerwald> the lack of such tools might be due to the complexity of Cabal
07:59:43 <maerwald> I am not sure
08:00:59 <yushyin> looks cool.
08:02:05 <sm[m]> chreekat: .... https://www.reddit.com/r/haskell/comments/it7ohv/developing_multiple_local_packages_at_once_in_repl/
08:02:28 <exarkun> Anyone want to help with this type error, it's rather beyond me.  It comes while trying to upgrade the servant-prometheus Servant dependency to 0.16 - https://gist.github.com/exarkun/ed204d9286cf11c807f14d7b1e2252f1  I assume it has something to do with (at least) https://github.com/PrivateStorageio/servant-prometheus/blob/update-lts/lib/Servant/Prometheus.hs#L129-L150
08:03:11 <merijn> sm[m]: Eh, it's not, unless you run a HEAD version of GHC >.>
08:07:23 <siraben> > zipWith ($) (cycle [toLower, toUpper]) "hello everyone i love haskell"
08:07:26 <lambdabot>  "hElLo eVeRyOnE I LoVe hAsKeLl"
08:08:35 <chreekat[m]> sm: I'm curious which of those options was "easy": the one that uses brand new unmerged gsoc contributions, or the one that requires adding on build tools and using them to create custom scripts that probably still don't do what I want, anyway :) But it does look like people are working on it, yay!
08:09:02 <merijn> chreekat[m]: Yeah, lack of multi-components support was what held back a lot of IDE like stuff too
08:09:28 <merijn> chreekat[m]: So this will improve multi-component support in ghcide and hls too \o/
08:10:37 <sm[m]> chreekat: what I posted is relatively easy, if you need it I think it's a valuable tip
08:11:19 * hackage persistent-qq 2.9.2 - Provides a quasi-quoter for raw SQL for persistent  https://hackage.haskell.org/package/persistent-qq-2.9.2 (parsonsmatt)
08:13:29 <sm[m]> "to ghci/ghcid your whole multicomponent project at once, add -iDIR options to the repl command"
08:13:59 <siraben> Is ekmett online?
08:14:13 <dolio> His handle is edwardk.
08:15:02 <dolio> Logged in here doesn't necessarily mean paying attention, though.
08:21:27 <maerwald> cabal test seems to hide test steps, even when I say --jobs=1
08:28:31 <hekkaidekapus> maerwald: Experiment: `cabal -vnormal+nowrap test`
08:29:34 <maerwald> nope, it's still just showing "Running 1 test suites" and then doesn't show anything until it errors or finishes and I can open the logs
08:30:42 <hekkaidekapus> Steps are better served with `cabal run`
08:33:43 <merijn> maerwald: Which test-suite?
08:33:51 <merijn> maerwald: tasty?
08:34:06 <maerwald> hspec
08:34:40 <merijn> So, tasty checks if it's talking to a terminal at least, so that doesn't always work with cabal's piping
08:34:53 <merijn> maerwald: Does it work if you use "cabal run" to run the test?
08:34:57 <maerwald> kinda
08:35:26 <merijn> then probably hspec is detecting a pipe and messing with buffering/output when it does?
08:54:50 <tomsmeding> any hints for how to build aeson on a machine with 1 GB of RAM? :p
08:56:28 <davean> tomsmeding: uh, passing a -M option to GHC?
08:56:40 <davean> tomsmeding: where did you find a machine like that?
08:57:10 <tomsmeding> That machine is a tiny VPS :p
08:57:36 <tomsmeding> Will try -M when I get back
08:57:58 <davean> tomsmeding: good luck?
08:58:18 * tomsmeding o/
08:59:03 <davean> could try the non-copying collectors?
08:59:20 <davean> -c
09:05:32 <monochrom> Yeah, "copying GC" means double buffering.
09:08:35 <davean> failing all that, enable swap of course
09:08:40 <davean> but the less you need that the better
09:29:31 <tomsmeding> passing +RTS -c to ghc makes it run longer, but it still doesn't get past Data.Aeson.Parser.Internal
09:35:42 <davean> tomsmeding: well, a little swap?
09:35:51 <tomsmeding> yes :p
09:35:59 <tomsmeding> ghc doesn't seem to do anything with -M
09:36:30 <davean> you have to say what the -M is
09:38:58 <sm[m]> @where lowmem
09:38:58 <lambdabot> I know nothing about lowmem.
09:40:32 <tomsmeding> I know, I first passed -M750M, then lower, finally -M200M
09:40:38 <tomsmeding> didn't help, still filled up memory :)
09:40:55 <davean> Can you show me how you passed it?
09:41:03 <tomsmeding> ooh Data.Aeson.Types.FromJSON is also a large one,
09:41:18 <geekosaur> isn't that an RTS option?
09:41:18 <tomsmeding> davean: stack build --RTS --ghc-options +RTS --ghc-options -M100M --ghc-options -c --ghc-options -RTS
09:41:26 <tomsmeding> aeson is a dependency of the project I'm building
09:42:13 <tomsmeding> without RTS flags it managed to fill up 1G of swap and then still crash :p
09:42:44 <davean> I don't know stack, but you sure thats not passing the RTS options to stack instead of GHC?
09:43:08 <davean> I note theres no quotes there.
09:43:40 <tomsmeding> note the --RTS in the beginning
09:43:50 <davean> I do note that.
09:44:01 <tomsmeding> '--ghc-options' is not an RTS option, so if stack was interpreting them, it would've thrown an error
09:44:18 <tomsmeding> and indeed, I forgot --RTS at first, and stack threw the expected error
09:49:43 <tomsmeding> aeson successfully built! peak usage: 1.3G of swap, in addition to most of the 1G of actual RAM
09:58:15 <tomsmeding> okay https://ircbrowse.tomsmeding.com/ is successfully running on ghc 8.8.4 sm[m] 
09:59:46 <sm[m]> nice tomsmeding!
10:01:12 <merijn> Wouldn't it be easier to build in a VM then ship the result to the VPS? :p
10:01:22 <merijn> Or is that big brain thinking?
10:03:56 <tomsmeding> perhaps :p
10:04:09 <tomsmeding> though hopefully I won't need to be building aeson in a while again
10:07:44 <sm[m]> for the record, that stack build
10:07:44 <sm[m]> command looks weird to me too
10:08:00 <[exa]> hm, reading Regex.TDFA... is there any reason why ⌜p_escaped = char '\\' >> anyChar >>= \c -> char_index >>= return . (`PEscape` c)⌝ would be better than the (imho) more readable applicative version?
10:09:40 <geekosaur> Regex.TDFA predates nice Applicative-supporting versions of Parsec?
10:11:13 <dolio> Shouldn't a Thompson DFA algorithm be doing something better than parsec?
10:11:14 <geekosaur> although that looks a little unfortunate even as monadic code, at least use fmap/liftM!
10:11:36 <[exa]> dolio: it's for parsing the input regexes
10:11:49 <dolio> Oh, I see.
10:12:01 <wgytfr78> My privats videos skype webcam 400gb links open in Tor Browser gg.gg/m7dgu
10:12:14 <[exa]> (anyway the T is for "tagged" in this case, there's some theory behind that)
10:12:29 <[exa]> geekosaur: ok looking at the docs date that seems quite likely, 2009 in fact
10:13:19 <dolio> Yeah, I would guess it's just old.
10:13:48 <tomsmeding> sm[m]: what would you expect it to look like instead?
10:14:04 <[exa]> technically, I expect there's no bad surprise (performance?) in rewriting it to something like ⌜flip PEscape <$> char '\\' *> anyChar <*> char_index⌝ ?
10:15:00 <sm[m]> can't check it just now, but I will
10:28:38 <dolio> [exa]: I would be surprised if that were significantly worse.
10:30:49 * hackage patat 0.8.6.1 - Terminal-based presentations using Pandoc  https://hackage.haskell.org/package/patat-0.8.6.1 (JasperVanDerJeugt)
10:31:33 <[exa]> dolio: ok thanks
10:34:19 * hackage clckwrks 0.26.1 - A secure, reliable content management system (CMS) and blogging platform  https://hackage.haskell.org/package/clckwrks-0.26.1 (JeremyShaw)
11:49:32 <hyiltiz> Is it possible to compute embed a hashstring inside its input, aha does a hash function that can satisfy the following property exist (if not, can we prove): X = hash(X++Y) where ++ is string concatanation, Y is arbitrary string, X is computed and embedded hash string.
11:50:51 <hyiltiz> s/compute//, s/aha/aka/
11:51:26 <hyiltiz> I.e. is it ever possible to embed the checksum/hash of a file inside the same file being hashed?
11:53:30 <geekosaur> it could conceivably occur there randomly, but if it's a secure hash function then one of the things it's trying to do is prevent that scenario
11:53:41 <exarkun> It's called a fixed point
11:53:46 <exarkun> most hash functions have them
11:53:50 <exarkun> many of them are known
11:54:13 <exarkun> wait no, where Y is arbitrary?  sorry didn't read very carefully
11:54:33 <geekosaur> (but at best it can only make it very unlikely)
11:56:59 <merijn> It depends on the kind of hash
11:57:12 <merijn> There's way to many implicit unstated assumption here to give any answer
11:57:56 <merijn> There are certainly hashes where "hash a <> hash b == hash (a <> b)"
11:58:11 <merijn> Probably not cryptographically secure hashes, but then, that was never stated
11:58:42 <merijn> I mean, "checksum is embedded in the file" is trivially answered via: "yes"
11:58:48 <merijn> Exhibit #1: CRC32
11:59:14 <merijn> Like, that's literally what IP packets do :)
11:59:44 <hyiltiz> merijn: what assumptions du think needs to be specified/relevant for a meaningful discussion?
11:59:58 <hyiltiz> thx for mentioning crc32 i'll look into it
12:00:53 <geekosaur> what kind of hash, for one. merijn and I both mentioned cryptographically secure hashes, which try to make a number of guarantees or near-guarantees compared to other kinds of hashes
12:00:54 <merijn> hyiltiz: Well, hash is often implicitly interpreted as "cryptographically secure" and most of the well known hashes are (or rather, were intended to be) cryptographically secure in which case what you're asking is actively designed against
12:01:17 <merijn> hyiltiz: CRC32 otoh is designed as a checksum against non-malicious tampering
12:02:01 <merijn> i.e. it detects "natural" errors and thus properties like "embedding the checksum" are kinda nice, since for example IP packets want the checksum included in the packet for things to make any sense
12:02:12 <hyiltiz> if by cryptographically secure means can only unhash with gazillion computers in gazillion years, then no, I didn't specify that and is not needed.
12:02:40 <merijn> hyiltiz: Cryptographically secure means "we don't want attackers to be able to forge unintended messages"
12:02:45 <merijn> Suppose you have an email
12:02:47 <monochrom> But CRC doesn't satisfy X = hash(X++Y).  CRC satisfies X=hash(Y) iff 0=hash(Y++X)
12:03:00 <merijn> monochrom: Nobody said it did
12:03:17 <merijn> monochrom: The follow up question was about "embedding the checksum in the file being checked"
12:03:24 <merijn> monochrom: Which is what CRC32 answered
12:03:28 <monochrom> But hyiltiz was stating  X = hash(X++Y
12:03:31 <sm[m]> tomsmeding: re your "stack build --RTS --ghc-options +RTS --ghc-options -M100M --ghc-options -c --ghc-options -RTS" command - I can easily get confused here but the --RTS flag looks weird/unknown
12:04:12 <tomsmeding> I barely ever use RTS flags, but in this case I read the documentation :)
12:04:14 <merijn> hyiltiz: Now, suppose you checksum the aforementioned email, but the checksum allows someone else to append text to your email and compute a new (valid) checksum
12:04:35 <merijn> hyiltiz: That's clearly undesirable if you plan to use checksum to guarantee data integrity in the presence of attackers
12:04:37 <tomsmeding> +RTS starts RTS flags, -RTS stops RTS flags; --RTS permanently stops RTS flags so that you can pass stuff that _looks_ like an RTS flag as normal options
12:05:07 <merijn> But if you only plan to guard against, e.g. data corruption by magnetic waves or cosmic radiation, then it's probably fine
12:05:09 <tomsmeding> if I didn't use --RTS there, stack itself would've interpreted the +RTS, tried to parse --ghc-options as an RTS flag, and failed
12:05:36 <hyiltiz> merijn: I get what u mean but that other one is gonna have a different Y and as a result (most likely) a different X 
12:05:53 <merijn> hyiltiz: So "cryptographically secure" hashes are the class of hashes that are expected to be robust in the presence of malicious/active manipulation of the data (which means the properties you asked about are actively undesirable)
12:06:17 <hyiltiz> so if I know the hash, I can look up that hash by text search and find exactly the file I am looking for
12:06:58 <monochrom> tomsmeding: Does it help to use the syntax --ghc-options=+RTS ?
12:07:11 <exarkun> hyiltiz: Why don't you just not include the hash value if you ever need to rehash the content?
12:07:16 <hyiltiz> so I guess i am not interested in cryptographically secure type of hash
12:07:19 <exarkun> hyiltiz: Why do you want to embed a hash in a document?
12:07:57 <monochrom> Yeah, usually embedded hash is of interest to hardware desginers only. Their life is easier that way.
12:08:01 <hyiltiz> exarkun: huh? u mean, hash the file, emded the hash in it and store; if file is edited, repeat?
12:08:06 <monochrom> A programmable couldn't care less either way.
12:08:14 * geekosaur would typically put the hash as metadata, possibly by (sym)linking the file by its hash as well as its name
12:08:15 <tomsmeding> monochrom: help for what, exactly?
12:08:19 <exarkun> hyiltiz: No
12:08:36 <exarkun> hyiltiz: Or, sure, do it like that if you want I suppose
12:08:37 <geekosaur> tomsmeding, presumably hiding RTS options from stack so it doesn't eat them
12:08:47 <hyiltiz> oh a table of file names and hashes alongside the actual files?
12:08:51 <exarkun> hyiltiz: Why do you need to embed the hash in the file?
12:09:02 <geekosaur> since stack's own RTS won't spot it that way
12:09:04 <monochrom> The syntax --ghc-options=+RTS does not require you to escape +RTS, i.e., stack does not swallow/interpret "+RTS" for itself.
12:09:22 <merijn> tomsmeding, geekosaur: Or, here's a crazy idea, just use --
12:09:29 <hyiltiz> then, I can look for the hash to find the file of interest (among say 10^6 files, each hashed with an embeddable hash)
12:09:32 <merijn> The RTS will ignore all +RTS options after --
12:09:44 <merijn> In the great unix tradition of not consuming flags after --
12:10:03 <hyiltiz> but application aside, I am more interested in the feasibility/solutions of the X=hash(X++Y) equation above
12:10:18 <geekosaur> but then there are possibly stack options to be passed
12:10:20 <monochrom> I have doubt about the semantics of -- in this case though.
12:10:50 <geekosaur> which is why the RTS has its own "--RTS" so it doesn't also turn off arbitrary option parsing
12:10:52 <monochrom> For simple programs the semantics of -- is accordingly simple.
12:10:57 <merijn> monochrom: I don't, because I know it works
12:11:03 <monochrom> OK!
12:11:10 <exarkun> hyiltiz: It has differing degrees of feasibility depending on the hash function you pick.  But in general I don't see the value.
12:11:16 <merijn> monochrom: I use it to pass +RTS flags when using "cabal run"
12:11:31 <monochrom> but this is "stack build", not even "stack run"
12:11:33 <tomsmeding> merijn: I want to pass options to GHC through stack
12:11:55 <tomsmeding> I am thoroughly confused now what --ghc-options expects
12:12:40 <hyiltiz> exarkun: I can't think of any function to pick from that could satisfy that equation (some kinda fixed point to bootstrapping; not sure how to describe that equation with words)
12:12:41 <geekosaur> as is typical for long options, they can take parameters which are either combined (--foo=bar) or separate (--foo bar)
12:12:44 <merijn> tomsmeding: The real answer is "--ghc-options" isn't generally used to pass RTS options to ghc and I doubt stack really supports that well
12:12:45 <sm[m]> I've always done --ghc-options='-some -ghc -options' to be safe
12:12:57 <tomsmeding> sm[m]: it splits on spaces?
12:13:01 <geekosaur> the = version can be useful in cases where the parameter looks like an option
12:13:02 <hyiltiz> monochrom pointed out that CRC isnt actually the solution to that eq.
12:13:05 <tomsmeding> what if you want to pass an option to GHC that contains spaces?
12:13:16 <merijn> tomsmeding: With cabal I'd just define a shell script that does 'ghc +RTS my options -RTS "$@"'
12:13:26 <merijn> And then point cabal at the shell script
12:13:27 <exarkun> hyiltiz: hash x = 0
12:13:36 <merijn> But that probably doesn't work with stack
12:13:36 <sm[m]> tomsmeding: dunno the details but I have the impression it works. I believe you about --RTS.. was it in the stack user guide ? I didn't find it in stack --help
12:13:50 <tomsmeding> sm[m]: ghc +RTS --help
12:14:09 <tomsmeding> it's to prevent the RTS of the 'stack' executable from interpreting them
12:14:38 <tomsmeding> I sincerely hope that to stack, '--ghc-options ABC' is the same as '--ghc-options -v' is the same as '--ghc-options +RTS', mutatis mutandis
12:14:44 <sm[m]> ah, tricksy.. so --RTS is another of those hidden flags supported by all GHC-built executables
12:14:45 <sm[m]> thanks
12:15:14 <sm[m]> stack build --ghc-options='+RTS -M500m -RTS'  <- is the kind of syntax I usually use
12:15:15 <hyiltiz> exarkun: Ok, so the hash function doesn't have to be cryptographically secure, but it should at least map slightly different Ys into vastly different Xs; so a trivial hash x = 0 isn't really an interesting solution
12:15:40 <exarkun> hyiltiz: interesting is in the eye of the beholder :)
12:15:57 <sm[m]> tomsmeding: and if in doubt I would definitely add -v to verify
12:16:08 <tomsmeding> okay the plot thickens
12:16:21 <tomsmeding> the options you give to --ghc-options are _actually_ first passed to a Setup executable somewhere
12:16:29 <tomsmeding> which then interprets those +RTS options
12:16:36 <tomsmeding> they don't even reach ghc
12:16:43 <tomsmeding> and no, --ghc-options=--RTS before it doesn't help :p
12:16:49 <hyiltiz> I just defined what "interesting" means: as a hash function, it has to a) at least map slightly different Ys into vastly different Xs most of the time; b) unhashing (Y->X) is hard.
12:17:03 <hyiltiz> but I agree; beauty beholds
12:17:07 <monochrom> This is what's wrong with 5 layers of abstractions. Every layer wants to have a say.
12:17:10 <geekosaur> so you need to embed another… wat. wonder if it's actually an executable then
12:17:31 <geekosaur> or if it's runghc-d which means still another level needed
12:17:40 <geekosaur> fuuuuuun
12:17:55 <geekosaur> (possibly 2 but I think 1)
12:18:36 <tomsmeding> $ stack build --RTS --ghc-options=--RTS --ghc-options=+RTS --ghc-options=-s --ghc-options=-RTS
12:18:41 <tomsmeding> Cabal-simple_mPHDZzAJ_3.0.1.0_ghc-8.8.4: Unrecognised build target '+RTS'.
12:18:43 <monochrom> Reminds me that in emacs regex I have to say like \\\\( for parenthesis.
12:18:44 <tomsmeding> I don't even know
12:19:05 <merijn> Here's a crazy idea
12:19:07 <tomsmeding> (-s is my test flag since it should give visible output)
12:19:17 <tomsmeding> replace $(which ghc) with a shell script?
12:19:18 <tomsmeding> yes
12:19:19 <merijn> Why do you not write this stuff inside the ghc-options field of your cabal file
12:19:43 <tomsmeding> because I want to use those flags to build a dependency of my project
12:19:47 <tomsmeding> aeson, to be specific
12:19:53 <tomsmeding> so I don't control its cabal file :)
12:20:22 <geekosaur> were this a cabal project, you could use cabal.project to do it I think
12:20:24 <monochrom> Some kind of cabal.project.local file can help you. You can add a clause for "how to build aeson".
12:20:29 <merijn> I was gonna write "so add them to cabal.project.local", but that's probably not helpful with stack
12:20:40 <merijn> geekosaur, monochrom: Hah, same mistake
12:20:41 <monochrom> For stack I don't know but I think there is a counterpart.
12:20:43 <geekosaur> yeh, sorry, cabal.project.local
12:21:02 <merijn> tomsmeding: Stack hates you :)
12:21:19 <koz_> merijn: This.
12:21:32 <tomsmeding> I figured :p
12:23:54 <tomsmeding> ah I see, with that command the Setup executable gets the following flags:
12:23:56 <tomsmeding> --ghc-options --RTS --ghc-options +RTS --ghc-options -s --ghc-options -RTS
12:24:23 <tomsmeding> the --RTS gets eaten by Setup's RTS, then the 2nd --ghc-options is a ghc option, and +RTS is taken as a build target
12:24:30 <tomsmeding> I'm not even sure whether it's possible to do this
12:25:04 <tomsmeding> oh!
12:25:12 <tomsmeding> sm[m]: you were correct of course
12:25:18 <tomsmeding> it does option splitting!
12:25:25 <tomsmeding> $ stack build --RTS --ghc-options='+RTS -s -RTS'
12:25:26 <tomsmeding> et voila
12:25:49 * hackage snap-loader-dynamic 1.0.0.2 - Snap dynamic loader  https://hackage.haskell.org/package/snap-loader-dynamic-1.0.0.2 (GregoryCollins)
12:25:50 <tomsmeding> so it's impossible to pass an option containing a space to GHC via --ghc-options
12:26:07 * geekosaur wonders if backslash would work. or the other quote
12:26:29 <sm[m]> I never use --RTS.. why's it needed again ?
12:26:33 <geekosaur> that said, an option containing a space is to say the least user-hostile
12:26:44 <tomsmeding> sm[m]: because it isn't
12:26:49 <tomsmeding> and I accidentally left it in
12:26:50 * hackage snap 1.1.3.1, snap-loader-static 1.0.0.1 (GregoryCollins): https://qbin.io/ambien-world-4ruv
12:26:55 <tomsmeding> good catch
12:26:56 <geekosaur> to keep stack's own RTS from eating the RTS flags. but in this case that shouldn't be possible any more
12:27:01 <tomsmeding> indeed
12:27:33 <tomsmeding> oh well, next time
12:27:56 <tomsmeding> I guess I was assuming too much regularity in stack's option parsing
12:28:38 <geekosaur> or overthinking things
12:28:46 <tomsmeding> that it would correctly remember the type of whatever string it was handling, whether it is shell syntax (thus spaces separating options) or a single option (thus spaces going into the command-line argument)
12:28:47 <tomsmeding> :p
12:29:05 <tomsmeding> geekosaur: that's my forté
12:29:30 <sm[m]> overthinking is kind of unavoidable when trying to pass tricky flags down through several layers of not necessarily cooperating tools :)
12:31:01 <sm[m]> I've been trying to decipher the stack build -v output. I see it runs Cabal-simple_mPHDZzAJ_3.2.0.0_ghc-8.10.2 configure, then Cabal-simple_mPHDZzAJ_3.2.0.0_ghc-8.10.2 build, and it's the configure command that gets the --ghc-options we specified, right tomsmeding 
12:32:04 <sm[m]> so eg just now I got essentially: Cabal configure --ghc-options\
12:32:05 <sm[m]>  "-fforce-recomp +RTS -M500m -RTS"; Cabal build --ghc-options ""
12:32:45 <sm[m]> I haven't used cabal configure for so long, but hopefully that does the right thing
12:33:12 <sm[m]> well actually I don't see how it would
12:34:25 <tomsmeding> :D
12:34:36 <sm[m]> no, I do see. cabal configure has --PROG-options=OPTS. If I add a deeper level of verbosity I guess I'd see the ghc command 
12:36:46 <sm[m]> yes this is more useful than -v: stack build --ghc-options='+RTS -M500m -RTS' --cabal-verbose
12:37:20 <tomsmeding> the actual ghc invocation also gets the flags
12:37:45 <tomsmeding> it invokes ghc about a bazillion times, by the way
12:38:40 <sm[m]> my ghc invocation is like: .../ghc --make -no-link ... '+RTS' -M500m -RTS -fhide-source-paths
12:39:00 <tomsmeding> same here
12:39:07 <tomsmeding> does indeed look it's working
12:39:30 <sm[m]> now, I've found that -M is more of a suggestion than a hard limit, but I think it can help
12:40:12 <tomsmeding> I think I'm going to delay testing that until I have to build aeson again
12:40:25 <tomsmeding> at least now I know how to actually properly get arguments to ghc :)
12:41:55 <geekosaur> write it down so you don't forget by then :)
12:43:33 <tomsmeding> good idea
12:46:53 <beka> anyone have experience using the indent parser tools of megaparsec?
13:03:20 <dsal> I have used it.  It wasn't my favorite experience, but I made it work.
13:44:01 <eflister> i want to IO in the WhenMatched of Map.mergeA.  is this impossible because it's only applicative?  why no mergeM?
13:46:13 <merijn> eflister: IO is an Applicative, though?
13:46:27 <merijn> eflister: All Monads are also applicatives
13:46:56 <eflister> merijn: yeah i was hoping it would work for that reason but it seems not to be.  i'll make a paste
13:49:22 <LambdaDuck> > foldr1 (+) [a,b,c,d]
13:49:26 <lambdabot>  a + (b + (c + d))
14:02:35 <tomsmeding> wait is that a special case in lambdabot?
14:02:56 <dolio> No.
14:03:08 <dolio> @type a
14:03:10 <lambdabot> Expr
14:03:12 <tomsmeding> ah
14:03:21 <tomsmeding> neat
14:04:17 <merijn> @hackage simple-reflect
14:04:18 <lambdabot> https://hackage.haskell.org/package/simple-reflect
14:37:47 <MagBo> Do we have an example of Network.WebSockets working with new Servant.Streaming?
14:38:30 <MagBo> I'd like to take the streaming cookbook from [here](https://docs.servant.dev/en/stable/cookbook/basic-streaming/Streaming.html) and make the countdown work over wss
14:45:16 <kicov> Hi, I just wanted to ask wheter it is possible to use liquid haskell to check for array# size - how are primops treated ? sizeofArray# is unbound - is there some other way to check for array size ?
14:48:53 <dolio> I think you'll probably need to introduce some higher level concept, because the arrays you want to prove things about don't exist statically.
14:50:17 <dolio> For instance, I was told once that vector-algorithms had been verified with liquid haskell, but without verifying vector. There were just assumptions defined about how the vector operations worked.
14:54:03 <beka> dsal: do you have any recommendations for making a haskell-style parser? im running into a whole slew of confusing issues that i don't understand :(
14:54:30 <kicov> dolio: Oh, okay, so we have an API, and based on the API we assume what happens on the inside. Okay... I'd need to read more - about the measures and how they are stored, and how to modify these based on API calls.
14:55:02 <[exa]> beka: the indents are a bit confusing because of the relatively high number of possibilities there
14:55:13 <[exa]> beka: by "haskell style" you mean "blocks as in python" right?
14:55:35 <dsal> beka: I normally don't do indent-based parsing because it's kind of hard.  Normal parsing with clear begin and end is a lot easier to do unambiguously.
14:58:50 <dolio> kicov: Yeah. I don't know the details myself. It's possible you can even specify how you want it to treat those primops. But I wouldn't necessarily expect it to already know how they behave.
14:59:40 <dolio> And specifying the primops might not even be the best place to start.
15:05:19 * hackage composite-tuple 0.1.2.0 - Tuple functions for composite records.  https://hackage.haskell.org/package/composite-tuple-0.1.2.0 (locallycompact)
15:09:37 <kicov> Does liquid haskell support annotations with context ? As in: 
15:10:10 <kicov> there's f, and inside f there's g which uses f's variables - can we check on these too ?
15:10:27 <kicov> (i mean g annotation making a check based on f's annotation) 
15:16:19 * hackage fused-effects-th 0.1.0.2 - Template Haskell helpers for fused-effects.  https://hackage.haskell.org/package/fused-effects-th-0.1.0.2 (patrick_thomson)
15:54:44 <lyxia> kicov: I think so, but you can also try it out for yourself on their site.
16:00:19 * hackage polysemy-http 0.2.0.4 - Polysemy effect for http-client  https://hackage.haskell.org/package/polysemy-http-0.2.0.4 (tek)
16:01:27 <DekuDekuplex> Hello.
16:02:16 <ski> hello DekuDekuplex
16:02:46 <DekuDekuplex> I seem to have a problem in adding my community to the list of Haskell communities.  Let me dig up which list now....
16:05:34 <DekuDekuplex> Ah, this page:  https://www.haskell.org/community/
16:06:50 <DekuDekuplex> Last year, I tried to add my TheTundra Haskell-Beginners community (back when "TheTundra" was known as "pashPost") to this list by adding a request on GitHub to update it, but nothing happened.
16:07:08 <DekuDekuplex> It's been over a year since last April, when I first submitted that request.
16:07:24 <DekuDekuplex> What's going on?
16:08:57 <DekuDekuplex> Ah, just looked up the term on GitHub:  pull request.  Yes, I submitted a pull request back then, but nobody responded.  I can't update that list myself.
16:09:14 <ski> hm, i dunno who to get in touch with
16:09:44 <ski> perhaps you could also try asking in #haskell-infrastructure, though i'm not sure whether that channel is relevant
16:10:00 <DekuDekuplex> If you take a look at https://github.com/haskell-infra/www.haskell.org/pulls, you can see one at the bottom by 
16:10:06 <DekuDekuplex> "DekuDekuplex."
16:10:10 <DekuDekuplex> That's mine.
16:10:34 <frdg`> what exactly is an Entity in Database.Persist? To this point I have always just thrown away the Entity but now I am instead updating data.
16:10:38 <DekuDekuplex> Ah, it's dated May 31, 2019, not last April.  Sorry.  It was last May, not last April.
16:11:37 <ski> (maybe it's related to "entity", as in Entity-Relationship (E-R) diagrams)
16:12:09 <frdg`> I have not heard of those
16:12:37 <ski> it's a modelling tool, for database schema design
16:12:40 <DekuDekuplex> However, for some reason, two other pull requests since then have responses, but not mine.  What's going on?
16:13:13 <ski> perhaps there's also some mailing list that you could try
16:13:59 <frdg`> nice thank you. 
16:14:11 <DekuDekuplex> Isn't there someone here, or someone I could write to in e-mail, who can update that list?
16:14:58 <DekuDekuplex> There used to be a HaskellWiki page that I could update, but for some reason, somehow that page was moved to GitHub, which I can't update.
16:15:09 <ski> there might be, but i have no clue who that would be
16:16:35 <ski> you could also try asking at another time, when there's more people around ..
16:17:15 <DekuDekuplex> That sounds like a good idea.  What time is it over there now?  I'm writing from Japan; it's 8:16 AM here now.
16:17:47 <frdg`> its a different time everywhere
16:18:37 <DekuDekuplex> When is a good time to ask about adding a community to https://www.haskell.org/community/ here?
16:22:52 <ski> in Europe and Africa, it's after midnight. in the Americas, it's afternoon, or possibly evening
16:22:57 <DekuDekuplex> What's really strange about the list of pull requests for https://www.haskell.org/community/ is that there are only 3 open requests, and there have been responses to the 2 other pull requests, but not mine.
16:23:01 <sm[m]> DekuDekuplex: I guess activity is highest around 1700 UTC or so
16:23:23 <DekuDekuplex> 1700 UTC.  Okay.
16:24:02 <sm[m]> you could send a Ping to your PR, possibly tagging the names of repo owner / PR mergers
16:24:10 <DekuDekuplex> Okay.  That would be 2 AM local time here in Japan.
16:24:27 <DekuDekuplex> Since I'm a night owl, that would fit my schedule.
16:25:04 <DekuDekuplex> All right, I'll try to ask again here at 2 AM or so sometime in the next few days.
16:25:37 <DekuDekuplex> I just hope that my request isn't being deliberately ignored.
16:26:31 <DekuDekuplex> Back when I tried to create my original community back on Google+, some folks asked me to delete it to merge the users into the other Google+ Haskell community, but I wanted to create one specifically for beginners.
16:27:16 <DekuDekuplex> However, Google scuttled Google+ last April, and that causes both communities to disappear.
16:27:21 <sm[m]> eg @TikhonJelvis
16:27:22 <DekuDekuplex> causes -> caused
16:28:05 <DekuDekuplex> Therefore, I re-created mine on TheTundra (then "pashPost"), and submitted a pull request to have it listed at https://www.haskell.org/community/.
16:28:28 <DekuDekuplex> However, nobody seemed to pay any attention to that pull request, and that list still has not been updated.
16:29:04 <DekuDekuplex> That makes it more difficult to attract Haskellites to my beginners-oriented Haskell community.
16:30:39 <DekuDekuplex> I did advertise it on Haskell-Cafe, Haskell-Beginners, and reddit.
16:31:44 <DekuDekuplex> There isn't anything wrong with adding a new community to https://www.haskell.org/community/, is there?
16:31:45 <sm[m]> DekuDekuplex: it's not deliberate, people are just busy and not actively checking all repos. Send an inquiry to the pr, so they'll get a new email notification
16:31:58 <DekuDekuplex> That's good to hear.
16:32:52 <DekuDekuplex> I was afraid that someone from the old Haskell community back on Google+ who had wanted me to delete my Haskell-Beginners Google+ community might have some resentment for my not deleting my community, and not want me to advertise it.
16:34:23 <sm[m]> too early to assume malice, incompetence is more likely :)
16:35:04 <DekuDekuplex> I used to be an undergraduate in one of Paul Hudak's formal semantics courses back in circa 1993, and used to audit one of his classes back in college in Haskell.
16:35:17 <sm[m]> generally the next step with an ignored pr is to follow up with a few more comments, perhaps tagging specific maintainer names
16:35:29 <DekuDekuplex> He used to give great lectures on Haskell and functional programming.
16:35:50 <sm[m]> Nice! I bet
16:35:59 <DekuDekuplex> Unfortunately, Hudak passed away a few years ago.
16:36:10 <DekuDekuplex> That was most unfortunate.
16:36:36 <sm[m]> I have his book
16:37:07 <DekuDekuplex> Actually, so do it.  It's the one on multimedia programming in Haskell.
16:37:12 <DekuDekuplex> it -> I
16:37:22 <DekuDekuplex> School of Expression.
16:37:33 <DekuDekuplex> Yes, the Haskell School of Expression.
16:38:19 <DekuDekuplex> He used to play in a jazz band back in New Haven.  I actually once attended one of his performances.
16:39:37 <DekuDekuplex> Hudak was especially enthusiastic about functional programming, and about using the original functional style of writing programs, as opposed to the monadic style.
16:40:33 <sm[m]> Interesting
16:41:55 <DekuDekuplex> One of Hudak's interesting posts on Haskell-Cafe was "a regressive view of support for imperative programming in Haskell" (see https://mail.haskell.org/pipermail/haskell-cafe/2007-August/030178.html).
16:42:16 <DekuDekuplex> He didn't like the do-notation.
16:42:53 <DekuDekuplex> Instead, he wanted to use the 
16:42:53 <DekuDekuplex> cmd1 >>= \x->
16:42:53 <DekuDekuplex> cmd2 >>= \y->
16:42:53 <DekuDekuplex> ...
16:42:53 <DekuDekuplex> return e
16:43:04 <DekuDekuplex> return e
16:43:10 <DekuDekuplex> notation.
16:43:28 <DekuDekuplex> (Please ignore the last "return e" expression.)
16:45:06 <DekuDekuplex> Somebody responded to my pull request!  Apparently, it has some broken link problem or other.  Let me check now....
16:47:08 <DekuDekuplex> Ah, I see.  The original URL for my community was changed by TheTundra.  Here is the new one:  https://thetundra.com/interests/tech/groups/haskell-the-haskell-beginners-community
16:47:31 <DekuDekuplex> Let me add a comment about that to my pull request....
16:48:46 <DekuDekuplex> Comment added.
16:52:21 <DekuDekuplex> Okay; I have just additionally submitted an updated pull request with the updated URL.
16:55:44 <DekuDekuplex> At this point, I guess I'll just see what happens and try logging back in here at approximately 1700 UTC or so.
16:56:40 <DekuDekuplex> Thanks!  I'll see what happens now.  I need to log off.  See you later!
17:01:57 <ski> DekuDekuplex : interesting
18:41:40 <boxscape> % (+++) :: a -> b -> c -> a; (a +++ b) c = a
18:41:41 <yahb> boxscape: 
18:41:41 <boxscape> % (+++) :: a -> b -> a; (a +++ b) = a
18:41:42 <yahb> boxscape: ; <interactive>:101:24: error: Parse error in pattern: a +++ b
18:41:51 <boxscape> hm, seems strange that the second one doesn't work
18:41:57 <boxscape> it works without the parens of coures, but...
18:42:03 <boxscape> seems inconsintent
18:42:09 <boxscape> wow I cannot spell today
18:42:50 <monochrom> Don't use parentheses in the 2nd one. The Haskell grammar does not anticipate it.
18:43:28 <boxscape> I realize that, I'm just surprised that the Haskell grammar is designed in that way :)
18:44:16 <monochrom> Or rather:
18:44:53 <monochrom> If you intend function definition, the grammar doesn't anticipate parenthesizing such as "(f x) = x+1"
18:45:47 <boxscape> % f :: a -> b -> a; (f a) b = a
18:45:48 <yahb> boxscape: 
18:45:52 <monochrom> BUT! The other kind of definitions is "pattern = expr".  In this case, the pattern can have outermost parentheses, "(inner pattern) = expr" because all patterns allow redundant parentheses.
18:46:13 <boxscape> oh, yeah, I suppose that does make sense
18:46:22 <boxscape> thanks
18:46:23 <monochrom> This pushes the parser to look at "(a +++ b) = ..." and go "ah, you have a pattern on the LHS".
18:46:29 <boxscape> right
18:59:42 <ski> yea, i've noticed this discrepance before
19:01:50 <ski> occasionally, i've wanted to do something like `(   x +++ Foo) = ...', in order to align `x' with something on another line
19:02:15 <monochrom> That's clever
19:02:32 <monochrom> Use explicit { ; }  >:)
19:02:59 <ski> this was directly under `module', as i recall it
19:06:06 <monochrom> module M where {
19:13:08 <eflister> i need an accumulating traverse for Data.Map.
19:16:17 <ski> eflister : use `StateT' ?
19:18:40 <eflister> ski: makes sense.  any idea why it's not included in the library?  makes me suspect i'm doing something wrong :)
19:19:05 <ski> not included in which library ? 
19:19:19 * hackage arch-hs 0.0.0.0 - A program generating PKGBUILD for hackage packages.  https://hackage.haskell.org/package/arch-hs-0.0.0.0 (berberman)
19:19:20 <eflister> Data.Map :)
19:19:40 <ski> (also, you said you were going to make a paste before, but you never showed any paste link)
19:20:35 <eflister> heh, good memory - i later posted that i found a missing $ after lunch :)
19:21:09 <ski> eflister : well, it has `instance Traversable (Map k)'. what more do you need, than that, and `instance Monad m => Applicative (StateT s m)' ?
19:23:21 <ski> @type (runStateT .) . (. (id :: M.Map k v -> M.Map k v)) . traverse . (StateT .)
19:23:23 <lambdabot> Monad m => (v -> s -> m (b, s)) -> M.Map k v -> s -> m (M.Map k b, s)
19:23:31 <ski> you wanted something like that ?
19:28:15 <eflister> that does look good, but more sophisticated than i usually get.  :)  since they have mapAccum and traverse i was hoping they'd baked in the combination...
19:30:00 <booppoob> hi, do you think i should learn haskell if i have absolutely no maths background? does one need one to be able to have an easier time?
19:30:11 <booppoob> should I instead spend some time with maths before coming to it?
19:32:46 <boxscape> You do not need a maths background to learn haskell
19:33:54 <ski> eflister : just write something like `(`runState` initialAcc) (traverse (\val -> StateT (\acc -> do ...; return (newVal,newAcc))) myMap)'
19:34:42 <ski> (er, s/runState/runStateT/)
19:35:14 <ski> (`mapAccumL' is just `traverse' on `State s')
19:35:19 <booppoob> ok, my friend(s) keep telling me only maths people do it. that's reassuring to hear.
19:36:21 <boxscape> heh, it does tend to attract maths people. There are some nice relationships between some Haskell concepts and some maths concepts, but I doubt most people who have learned haskell even heard about those math concepts before.
19:36:23 <ski> @where prerequisite
19:36:23 <lambdabot> "Prerequisite for Learning Haskell" <http://www.vex.net/~trebla/haskell/prerequisite.xhtml>
19:36:27 <ski> booppoob : see ^
19:37:06 <ski> that tells you what (little) math background is useful, for learning Haskell
19:37:38 <dolio> I think people have taught Haskell to high school students. Possibly grade school.
19:38:47 <boxscape> I wasn't taught it *in* high school but I did learn it while I was attending high school
19:42:39 <boxscape> hm I feel like that prerequisites page could benefit from some LaTeX, the ASCII math makes it look more difficult than it is
19:43:21 <ski> hm, not the other way around, then ?
19:43:38 <boxscape> well, I'm not suggesting to show the LaTeX source, but the rendered result
19:44:07 <boxscape> though you may have meant that
19:44:14 <ski> yes
19:44:40 * ski looks at monochrom
19:44:58 <monochrom> All LaTeX does in this case is merely italicize.
19:45:02 <boxscape> I don't know, maybe - my impression would be that as long as you only use letters and numbers and not greek letters it shouldn't be any more menacing than ASCII math, but I could be wrong
19:45:07 <ski> monochrom : and superscripts
19:45:17 <boxscape> yeah I was thinking mostly of superscripts and asterisks
19:45:25 <boxscape> though then again
19:45:39 <boxscape> I suppose the asterisks are a deliberate choice because juxtaposition is an ASCII feature
19:47:17 <boxscape> and I admit it could be jarring once you get to the source code which presumably would be rendered without LaTeX
19:50:19 <booppoob> ok, i think i am done with the prerequisites, what would you suggest as a starting point to learn? which book should i begin with?
19:53:02 <boxscape> booppoob In terms of free resources, this seems to be a pretty good introduction https://www.seas.upenn.edu/~cis194/spring13/lectures.html In terms of paid resources, there's haskellbook.com
19:53:58 <sshine> LaTeX also provides nice combined glyphs for "fi" and so on.
19:54:32 <sshine> and does proper kerning.
19:55:06 <sshine> I wonder how modern web browsers are doing on that.
19:56:33 <booppoob> boxscape: thanks a lot.
19:57:01 <boxscape> booppoob there's some more resources here https://github.com/bitemyapp/learnhaskell
19:57:16 <boxscape> (but it recommends starting with one of the two I linked)
19:57:28 <sshine> what's the cheapest way to get nice whitespacing behavior in text paragraphs on homepages without putting a PDF instead of my page? can't I render with javascript something generated by LaTeX, in a way that seems like when people add LaTeX equations to home pages?
19:57:45 <sshine> but for text paragraphs.
19:58:05 <boxscape> I would hate your website if you did that because it would probably make text unselectable
19:58:40 <sshine> boxscape, you'd hate my website now then. it's made from a javascript for making PowerPoint slideshows. I'm trying to turn it into a comic book viewer.
19:58:47 <boxscape> oh no
19:59:04 <sshine> boxscape, it has capacity for autoplay youtube and iframe backgrounds!
19:59:12 <boxscape> though text selection doesn't seem as important for comic book viewing
19:59:36 <sshine> it also has syntax-highlighted code that is friendly for copy-pasting.
19:59:47 <boxscape> that sounds lnice
19:59:53 <boxscape> s/lnice/nice
20:00:12 <sshine> often if I have text it's not a lot. I would hate myself if I wrote a book... so many other people are good at that. so I just try to share snippets of nice things I see.
20:00:43 <sshine> trying to publish my friends comic books to a wider audience.
20:01:17 <boxscape> I see
20:03:37 <sshine> https://simonshine.dk/insta.html -- this is just a random selection of artwork from a friend's instagram. -- this is a short comic based on a Lovecraft novel: https://simonshine.dk/udyret.html -- the writing's in Danish and the format isn't properly adjusted towards web viewing yet...
20:05:21 <sshine> I wanna cut some of those boxes into smaller ones that take the whole screen, and then put some background music on it.
20:07:15 <sshine> I just think I should auto-detect those boxes and kinda take over rendering choices from the artist who made it for paper. then old comics can get repurposed with kind of a default rendering suggestion without needing to create some complicated editor or asking people to make PNG cut-outs of 300 pages.
20:08:22 <sshine> I guess if you detect a bunch of boxes in a page, there's a natural way for the eye to go, and that can just be inferred from the layout of the page and turned into how the slideshow zooms, out and around in progressively.
22:21:23 <siraben> edwardk: Just finished reading your article on the bound library, it sounds very useful.
22:21:43 <siraben> Have you seen https://github.com/jozefg/cooked-pi/blob/master/src/LambdaPi/Bound.hs ?
22:21:56 <sim590> I have a `A a` data type with its own constructors. Now, I'm making a `newtype B b = A b`. Is it possible for me to use A's constructors to map them against variables of type `B` ? Otherwise, what's the prefered approach?
22:23:13 <siraben> sim590:  when you write `newtype B b = A b`, you're creating a constructor `A :: b → B b` by the way
22:23:28 <siraben> I think what you want is `newtype B b = B (A b)`
22:25:07 <siraben> sim590:  You're saying that you want implicit coercion from `A a` to `B a`?
22:25:44 <sim590> Here's what I want to do: http://sprunge.us/MSk4Mo. See the function `toto` which yields an error "Couldn't match expected type ‘LBSTree a’ with actual type ‘BSTree a0’".
22:27:58 <sim590> Because my LBSTree is an extension of BSTree, so I would have liked to simply use its constructors. I think that "implicit coercion" is correctly capturing what I want to do, but I'm not sure about the semantic of the word.
22:28:53 <sim590> There are functions defined for BSTree already and I would have liked to use them on LBSTree also if that's possible. But what I'm really looking for is the most standard way of achieving this extension.
22:28:59 <siraben> sim590:  Yes, the type error occurs because BEmpty has type BSTree a
22:29:31 <siraben> What you need to change is `newtype LBSTree a = BSTree (LBSNode a)` to `newtype LBSTree a = LBSTree (BSTree (LBSNode a))`
22:30:05 <siraben> Then the first case of the pattern match, `toto BEmpty = undefined` to `toto (LBSTree BEmpty) = undefined`
22:30:09 <sim590> OK, so I really need to define another constructor.
22:30:23 <siraben> If you don't want having to write the constructor `LBSTree`, I'd say write this
22:30:33 <siraben> `type LBSTree a = BSTree (LBSNode a)`
22:30:43 <siraben> s/having/to have
22:30:59 <siraben> Then you can keep the type signature of `toto`
22:31:41 <sim590> Oh. Yes! So type will just substitute LBSTree a to BSTree (LBSNode a).
22:32:08 <siraben> Using `type` in Haskell is a lot like `typedef` in C, it's a type alias. `newtype` OTOH creates a wrapper (to make things opaque), but while still having the same runtime representation
22:32:11 <siraben> Right.
22:34:16 <sim590> Does it always work in every cases? I do have other cases such as this signature: `append :: HasCallStack => LBSPComputer a -> a -> LBSTree a -> Chronicle Messages (LBSTree a)` and I'm getting an error "Occurs check: cannot construct the infinite type: a ~ LBSNode a"
22:35:14 <sim590> Oh No. I understand
22:35:27 <sim590> It's fine
22:35:30 <sim590> Thanks!
22:35:31 <siraben> How did the HasCallStack constraint appear here?
22:36:29 <siraben> No problem
22:37:11 <sim590> It's a project I'm working on. I had this BSTree module, but now I'm splitting it into BSTree and LBSTree. I already had some extensive code for things like logging with (co-log and Chronicle). I'm using GHC.Stack for keeping the trace in my functions where logging is enabled.
22:38:06 <sim590> The cause of my last problem was because I was not wrapping the `a` type in `LBSNode` after porting the code from BSTree to LBSTree.
22:38:11 <sim590> Hence the infinite type error.
22:38:40 <siraben> Ah, I see. Heh, I don't use logging myself in Haskell.
22:42:46 <sim590> ;) It's less complicated in that case. Where I don't need it, I don't use it.
22:50:19 * hackage incremental 0.3.1 - incremental update library  https://hackage.haskell.org/package/incremental-0.3.1 (FumiakiKinoshita)
23:04:49 * hackage metro 0.1.0.2 - A simple tcp and udp socket server framework  https://hackage.haskell.org/package/metro-0.1.0.2 (Lupino)
23:43:19 * hackage extensible 0.8.1 - Extensible, efficient, optics-friendly data types and effects  https://hackage.haskell.org/package/extensible-0.8.1 (FumiakiKinoshita)
