00:14:47 <tomsmeding> that's a fairly feature-rich one I see :p
00:19:59 <kuribas> does anyone know something about the GRIN compiler?
00:20:03 <kuribas> is it ready for production?
00:20:33 <Axman6> is there currently a good way to do one thing if a type is an instance of a class, and something else if it isn't? thinking about whether the constraints package and/or typeable could give you that sort of introspection (seems like it'd break paramatricity so I'm guessing no)
00:27:47 <kuribas> Axman6: no, that's not how typeclasses are supposed to work
00:27:55 <kuribas> Axman6: also likely not a good idea
00:28:49 <Axman6> While I agree, I also want it :)
00:33:40 <kuribas> why?
00:34:20 * hackage polysemy-plugin 0.2.5.1 - Disambiguate obvious uses of effects.  https://hackage.haskell.org/package/polysemy-plugin-0.2.5.1 (KingoftheHomeless)
00:34:21 <kuribas> also because of orphan instances they can be defined anywhere
00:34:38 <kuribas> so trying to statically determine if it has an instance is not useful.
00:37:06 <lortabac> Axman6: there are ways, but I would not describe any of them as "good"
01:40:17 <dminuoso> % :set -XNoMonomorphismRestriction
01:40:17 <yahb> dminuoso: 
01:40:21 <dminuoso> % f = coerce
01:40:21 <yahb> dminuoso: 
01:40:27 <dminuoso> % :set -XMonomorphismRestriction
01:40:27 <yahb> dminuoso: 
01:40:29 <dminuoso> % f = coerce
01:40:29 <yahb> dminuoso: ; <interactive>:59:5: error:; * Couldn't match representation of type `a0' with that of `b0' arising from a use of `coerce'; * In the expression: coerce; In an equation for `f': f = coerce; * Relevant bindings include f :: a0 -> b0 (bound at <interactive>:59:1)
01:40:36 <dminuoso> MMR strikes again! :)
02:00:03 <tomsmeding> it even struck someone I was helping recently who hadn't been programming haskell for more than two weeks at most
02:00:15 <tomsmeding> % f = \xs -> foldr (+) 0 xs
02:00:15 <yahb> tomsmeding: 
02:00:47 <tomsmeding> okay so apparently ghci's defaulting makes that okay, but if you write that in a file ghc will complain
02:01:12 <tomsmeding> salient sidenote is that writing 'f xs = foldr (+) 0 xs' is totally okay
02:01:35 <merijn> tomsmeding: Well, yes
02:01:53 <merijn> That's exactly how it's defined
02:04:25 <dminuoso> The beauty of the coerce example, is that it properly monomorphizes and then fails bizarrely.
02:49:38 <siraben> Is there a way to get rid of the repetitive repr? http://ix.io/2xCY
02:49:49 <siraben> I want the typeclass to look like the typing rules as much as possible
02:50:49 * hackage supernova 0.0.3 - Apache Pulsar client for Haskell  https://hackage.haskell.org/package/supernova-0.0.3 (gvolpe)
02:50:56 <dminuoso> siraben: I like how visualized your methods. :)
02:51:30 <siraben> dminuoso: thanks :)
02:52:54 <siraben> Is there any mechanism to write "Œ≥ ‚ä¢ Int" instead of "repr Œ≥ ‚ä¢ Int"
02:53:06 <siraben> This is just for aesthetic reasons.
02:55:54 <dminuoso> siraben: Yes, you could use MPTC with a fundep
02:56:06 <dminuoso> Let me
02:56:11 <siraben> dminuoso:  what would that look like
02:56:12 <siraben> Ok
02:57:57 <maerwald> https://hackage.haskell.org/package/persistent-2.10.5.2/docs/Database-Persist-Class.html#v:deleteWhere
02:57:58 <maerwald> why is `record` on the 3rd position when using type applications? I thougth when forall is omitted, it's simply the order of identifier occurence
02:59:28 <phadej> maerwald: backend m record
02:59:35 <phadej> type-class head is "first"
02:59:41 <maerwald> oh
03:00:19 <phadej> (in ghci :t deleteWhere would print the "complete" type-signature, incl. PersistQueryWrite constraint)
03:05:07 <siraben> dminuoso:  I just realized I don't need the type family, I can do type a ‚ä¢ b = a b
03:05:37 <siraben> But it still needs to be written as "repr (Œ≥,Œ±) ‚ä¢ Œ±", hm.
03:05:39 <ski> `(Œ≥,Œ±) Œ±' ?
03:05:55 <siraben> repr :: * ‚Üí * ‚Üí *
03:07:35 <siraben> dminuoso: how much has to be changed?
03:30:16 <siraben> After searching around for a bit, nothing useful turned up, can anyone help me with this?
03:45:38 <someUser123> hi
03:47:37 <maerwald> is there a generalisation of a `forM` that allows to pass arbitrary many *additional* actions based on the current index of the element?
03:47:55 <someUser123> `test`
03:48:03 <phadej> :t iforM
03:48:05 <lambdabot> (TraversableWithIndex i t, Monad m) => t a -> (i -> a -> m b) -> m (t b)
03:48:27 <justsomeguy> someUser123: Magic string detected. Missile launch initiated. 
03:48:27 <maerwald> like this https://paste.tomsmeding.com/UmIQdaQW
03:49:16 <maerwald> phadej: that would work if getting the index from any element is O(1)
03:49:45 <maerwald> (like: index of last element)
03:50:13 <phadej> last is hard
03:50:54 <someUser123> I want to write a function `show2 :: a -> Maybe String` which returns `Just (show x)` if `a` is a member of Show and otherwise Nothing for error reporting. How can this be realized?
03:51:08 <maerwald> TraversableWithReverseIndex :p
03:51:24 <phadej> maerwald: that index is container specific
03:51:30 <phadej> e.g. for Map k v it's k
03:51:36 <phadej> it's not [0..n]
03:51:45 <phadej> (but for list it is)
03:52:06 <maerwald> yeah and the problem is getting length of list isn't O(1)
03:52:57 <maerwald> I guess my manual forML_ kinda works for now
03:52:58 <phadej> I don't think there is ready-made combinator for that
03:53:08 <tomsmeding> someUser123: you can't in general; querying whether some type inhabits some type class or not isn't possible
03:53:13 <phadej> a bit too special use case
03:53:18 <maerwald> I guess
03:53:55 <phadej> I also have wanted/used a forMsep_ :: (a -> m ()) -> m sep -> t a -> m ()
03:54:28 <phadej> (which is useful in monadic writer dsls, like lucid, e.g.)
03:55:06 <lortabac> someUser123: the short answer is, you can't do it; the long answer is, there are solutions but they are quite advanced and probably not meant to be used in real code
03:55:54 <tomsmeding> % :t \f sep -> sequence_ . intersperse (void sep) . map f  -- phadej 
03:55:54 <yahb> tomsmeding: Monad m => (a1 -> m ()) -> m a2 -> [a1] -> m ()
03:56:39 <tomsmeding> @pl \f sep -> sequence_ . intersperse (void sep) . map f
03:56:40 <lambdabot> ((sequence_ .) .) . flip ((.) . intersperse . void) . map
03:57:02 <phadej> tomsmeding: yes, far beyond fairbairn treshhold :)
03:57:10 <someUser123> thanks for the answer tomsmeding and lortabac
03:57:34 <phadej> tomsmeding: aka, I know how to define it, it just don't exist in e.g. `base` (or even `extra`)
03:57:38 <phadej> maybe it is in monad-loops
03:59:59 <tomsmeding> lortabac: do those advanced solutions still work if you turn on UndecidableInstances?
04:01:35 <lortabac> tomsmeding: I have no idea, but in my memory it was pretty fragile stuff
04:02:03 <tomsmeding> it'll have to be fragile stuff, given that UndecidableInstances are undecidable :p
04:04:05 <lortabac> tomsmeding: TBH I would already be surprised if there is a solution that covers all the simple cases correctly
04:05:33 <ski> someUser123 : a polymorphic function (not constrained by type classes) is not supposed to be able to know which type(s) is (/are) being used for the type variable(s)
04:18:33 <maerwald> how do you write a manual list recursive function and be sure it doesn't break list fusion?
04:19:18 <merijn> maerwald: GHC manual has a section on "good producers" and "good consumers"
04:43:29 <dminuoso> 12:52:46      tomsmeding | someUser123: you can't in general; querying whether some type inhabits some type class or not isn't possible
04:43:46 <dminuoso> tomsmeding: Mmm. Isn't satisying a `Foo a` constraint for a given a precisely that query?
04:43:54 <tomsmeding> perhaps I was imprecise
04:44:08 <tomsmeding> I meant specifically getting a boolean, not getting a proposition of truth
04:44:11 <dminuoso> Ah.
04:44:30 <tomsmeding> sure, if it's provably true, you can get that; but _deciding_ it is another matter
04:48:11 <dminuoso> Relatedly, Ive finally started with orphan instances out of lazyness. a foo-api and foo-server package, where foo-api defines some types but foo-server needs postgresql-simple ToField/FromField instances for the types defined in foo-api.
04:49:34 <dminuoso> So foo-api exports Foo.API.Types, and foo-server then has some Foo.API.Orphan module, providing orphan instances for the former module. At the end foo-server is not used as a library, so it's a final executable only
04:49:43 <dminuoso> Is this the only way? Is there something more robust?
04:50:37 <merijn> newtypes :p
04:51:00 <dminuoso> Yeah, but newtyping just for the sake of a ToField instance is a bit harsh
04:51:11 <merijn> You asked for more robust ;)
04:52:23 <dminuoso> Is my use case of orphans actually not robust as well?
04:52:59 <dminuoso> I mean it's not a complicated large package with dozens of developers, where its possible to end up with incoherent instances. It's just about 20 modules with just 2 developers
04:54:19 * hackage smallcheck-series 0.6.1.1 - Extra SmallCheck series and utilities  https://hackage.haskell.org/package/smallcheck-series-0.6.1.1 (kindaro)
04:59:43 <vaskia> :q
05:08:19 * hackage smallcheck-series 0.7.0.0 - Extra SmallCheck series and utilities  https://hackage.haskell.org/package/smallcheck-series-0.7.0.0 (kindaro)
05:25:49 * hackage splint 1.0.1.2 - HLint as a GHC source plugin.  https://hackage.haskell.org/package/splint-1.0.1.2 (fozworth)
05:28:22 <matthew_> Does anyone know the status of GHC on aarch64?
05:28:35 <matthew_> looks like Fedora provide packages, but not supported in ghcup
05:29:02 <maerwald> matthew_: https://gitlab.haskell.org/haskell/ghcup-hs/-/issues/5
05:29:13 <maerwald> There's been some work, but nothing finalized
05:29:22 <maerwald> If someone wants to push, be my guest
05:31:09 <matthew_> I think I need to understand GHC better.  I thought it could compile down to C code which would be portable?
05:32:45 <dminuoso> matthew_: The C backend is old.
05:33:03 <dminuoso> Also, that's just the haskell portion
05:33:16 <dminuoso> You still need the RTS + primops for the target architecture
05:34:01 <matthew_> Fair enough.. looks like it could be good fun -- I've done some aarch64 stuff with GCC in the past.  Maybe I'll get my hands dirty.
05:34:22 <dminuoso> matthew_: Consider both #ghc and the respective mailing list then. :)
05:57:19 * hackage bitcoin-compact-filters 0.1.0.0 - BIP 158 compact block filters  https://hackage.haskell.org/package/bitcoin-compact-filters-0.1.0.0 (IanShipman)
05:58:20 * hackage hpqtypes 1.9.1.0 - Haskell bindings to libpqtypes  https://hackage.haskell.org/package/hpqtypes-1.9.1.0 (arybczak)
06:09:49 * hackage safe-tensor 0.2.1.0 - Dependently typed tensor algebra  https://hackage.haskell.org/package/safe-tensor-0.2.1.0 (nalex)
06:13:30 <frdg> is there a  way to disjunctively pattern match like `"foo" V "bar" = 2` ?
06:13:59 <phadej> you may google for or-patterns proposals., none is implemented
06:14:09 <phadej> (nott even accepted)
06:14:09 <ski> sadly, there's no disjunctive / OR- patterns in Haskell
06:14:48 <frdg> what is the restriction?
06:15:04 <ski> restriction ?
06:15:38 <frdg> the restriction that haskell has where it cannot implement these patterns.
06:16:51 <phadej> the corner cases are hard to specify, and no-one bothered
06:17:22 <ski> it's not that it couldn't be implemented
06:17:37 <frdg> I see. 
06:17:38 <phadej> (for example capturing variables, what is their typing rules?)
06:18:20 <ski> OCaml requires the disjuncts to bind the same variables, of the same types
06:19:48 <phadej> also GADT pattern matches...
06:20:00 <phadej> I mean, there are a lot to consider
06:20:12 <phadej> vs just writing c | c == "foo" || c == "bar"
06:20:36 <phadej> (or turning RHS into a function)
06:20:55 <phadej> there was or-pattern proposal, read through comments
06:22:23 <mcmoor> Hello. I was trying to compile this quite old code http://matt.might.net/articles/red-black-delete/code/RedBlackSetTest.hs (also need http://matt.might.net/articles/red-black-delete/code/RedBlackSet.hs) but somehow I get compile error that I don't really understand how to resolve. Is there any instantiation that I should add? So far I tried
06:22:24 <mcmoor> instance Foldable RBSet but it does nothing.
06:23:01 <dminuoso> mcmoor: What compiler error do you get?
06:24:08 <mcmoor> Could not deduce (Foldable t0) arising from a use of 'foldr' ....
06:24:15 <mcmoor> and
06:24:29 <mcmoor> Could not deduce (Arbitrary (t0 a)) arising from a use of 
06:24:40 <dminuoso> mcmoor: Can you perhaps isolate the exact code that's triggering this?
06:24:41 <mcmoor> 'arbitrary'...
06:24:51 <dminuoso> And perhaps put up the full error message?
06:25:02 <dminuoso> It contains usually helpful and important context information
06:25:13 <phadej> one need some type annotations to generate lists
06:25:48 <phadej> e.g. in liftM (Data.List.foldr insert empty) arbitrary
06:26:06 <mcmoor> The code that have error looks like this
06:26:20 <phadej> where Data.List.foldr isn't list-specific, unfortunately
06:26:23 <mcmoor>  -- Generate trees from insertions:insertedTree :: (Ord a, Arbitrary a) => Gen (RBSet a)insertedTree = liftM (Data.List.foldr insert empty) arbitraryinstance (Arbitrary a, Random a,           Bounded a, Ord a, Num a) => Arbitrary (RBSet a) where  arbitrary = oneof[ordbalnrrTree,                    liftM (Data.List.foldr insert empty) arbitrary]
06:26:39 <phadej> {-# LANGUAGE TypeApplications #-}
06:26:40 <phadej> and changeing
06:26:46 <phadej> to Data.List.foldr @[]
06:26:55 <phadej> might be the "smallest" fix
06:27:03 <phadej> but don't ask me to explain what and why
06:27:13 <ski> (perhaps it ought to be possible to reexport an identifier with a more restricted type ?)
06:27:23 <int-e> :t Data.List.foldr
06:27:25 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
06:27:42 <phadej> ski: there is "proposal" to monomorphise Data.List functions to []
06:27:49 <phadej> ski: bother your local CLC member about its status
06:28:01 <ski> "CLC" ?
06:28:05 <int-e> that used to be (a -> b -> b) -> b -> [a] -> b, so there was no `t` to guess.
06:28:07 <phadej> core-libraries-committee
06:29:34 <Taneb> :t GHC.OldList.foldr
06:29:36 <lambdabot> (a -> b -> b) -> b -> [a] -> b
06:29:43 <ski> phadej : i would want the implementation to know that they're the same as the ones in `Data.Foldable' (so i could import both modules unqualified)
06:30:41 <phadej> ski: what if you import two modules which re-export foldr with imcompatible types?
06:30:47 <phadej> ski: i.e. "Write GHC proposal"
06:30:52 * ski smiles
06:30:58 <phadej> where monomorphisation is omething which could be done 5 years ago
06:31:10 <phadej> (i.e. when FTP was introduced)
06:31:32 <int-e> phadej: the objections have not changed, have they? "too many unqualified imports of Data.List that would break"
06:32:14 <int-e> you might have better luck with a Data.List.Mono[morphic] proposal
06:32:22 <ski> probably one import would have to be the most general one, i suppose
06:33:15 <int-e> ski: this is uncomfortably close to type directed name resolution
06:33:27 <mcmoor> phadej: Thank you very much! It really compiles! I want to ask what and why.... but maybe someone else can answer?
06:34:34 <phadej> int-e: 
06:34:35 <phadej> Foo.hs:1:8: warning: [-Wcompat-unqualified-imports]
06:34:35 <phadej>     To ensure compatibility with future core libraries changes
06:34:35 <phadej>     imports to Data.List should be
06:34:35 <phadej>     either qualified or have an explicit import list.
06:34:38 <phadej>   |
06:34:40 <phadej> 1 | import Data.List
06:34:43 <phadej> in GHC-8.10
06:35:00 <phadej> unfortunately, -Wcompat is not part of -Wall
06:35:02 <ski> int-e : yea, i guess the point would be to stay away from that
06:35:07 <phadej> so you never see that warning
06:35:17 <phadej> (well, not "never")
06:36:12 <phadej> but only few people enable -Wcompat, yet the warning isthere
06:36:27 <phadej> so I guess in 9.2 or 9.4 Data.List could be monomorphised
06:36:40 <merijn> -Wcompat should probably be part of -Wall >.>
06:36:53 <phadej> but you need a GHC proposal for that too :(
06:40:48 <phadej> I see the value of formal process, but the related internet-wide discussions, thanks no.
06:43:40 <orzo> hm, i've always thought Data.List should just be in the prelude
06:47:21 <dminuoso> So the more I use postgresql-simple, the more Im annoyed by the lack of being able to succintly tie queries and data records together. Is there some extra packages providing quasiquoters that provide named arguments instead of position (?) at least?
06:49:55 <phadej> orzo: most of it is
06:49:56 <merijn> orzo: It was until Foldable/Traversable went into Prelude
06:49:58 <phadej> :t foldr
06:50:00 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
06:50:02 <phadej> merijn: 
06:50:06 <phadej> :t Data.List.foldr
06:50:08 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
06:50:10 <phadej> those are the same
06:50:20 <phadej> Data.List was generalized as well
06:50:24 <merijn> Oh, I guess the old Data.List is now OldList or something
06:50:36 <phadej> merijn: no, it might be in GHC 9.2 or 9.4
06:50:42 <phadej> (if no-one forgets to do something to it ;)
06:50:48 <phadej> or rather someone remembers*
06:51:57 <orzo> does the -Wcompat-unqualified-imports warning happen for all imports or just Data.List?
06:52:08 <phadej> orzo: it contains only Data.List
06:52:10 <phadej> atm
06:53:03 <orzo> i don't think i've ever qualified Data.List
06:53:20 <phadej> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/using-warnings.html#ghc-flag--Wcompat-unqualified-imports
06:53:24 <orzo> probably most code doesn't
06:53:53 <phadej> I like "see the mailing list for details" comment
06:53:59 <phadej> you need to be quite a detective :P
06:54:30 <phadej> orzo: unqualified imports is bad style
06:54:44 <phadej> (from not home package)
06:55:08 <phadej> https://wiki.haskell.org/Import_modules_properly
06:55:45 <orzo> no exception for Base /
06:55:56 <phadej> no
06:56:29 <phadej> I have once import Data.Ord unqualified, and then someone added getDown there
06:56:31 <phadej> my code broke
06:56:33 <orzo> well i can see the logic, but it does sound onerous
06:56:45 <phadej> because I had defined my own
06:57:07 <orzo> well even the prelude can change though
06:57:25 <orzo> and qualifying infix operators is really ugly
06:57:35 <phadej> orzo: explicit import lists are fine
06:57:44 <phadej> import Data.List (intercalate) e.g.
06:58:14 <merijn> I tend to import everything qualified or explicit, yeah
06:58:19 <frdg> While using the io monad, I would like to be able to state a fact like `1 < 2 == false`. If the statement is false I want to throw an exception. If it is true I want to ignore it and move on. What is a nice way to do this?
06:58:37 <merijn> frdg: when/unless + throwIO
06:58:38 <phadej> frdg: `unless
06:58:51 <frdg> ok thanks
06:59:21 <orzo> the problem is that my projects tend to start as one package and grow and become libraries and i shuffle things around between modules a lot
06:59:28 <orzo> and i figure i'm not the only one that does that
06:59:33 <merijn> orzo: Or rather, I have the more realistic compromise of starting my code with completely open imports and as the module starts to finalise I start making more and more explicit
06:59:34 <phadej> orzo: I said "for non-home package imports"
06:59:56 <merijn> oh, yeah, imports from the same package I (usually) do unqualified
07:00:14 <phadej> also having package-specific (internal) "prelude" for most common imports saves lines
07:00:31 <merijn> phadej: I wish we had qualified re-exports
07:00:39 <phadej> merijn: you are not alone
07:00:44 <merijn> That would make that much nicer
07:01:01 <phadej> merijn: I think there was a proposal for that, I don't remember its state
07:01:26 <phadej> the module system modifications is bikeshedding-sensitive
07:01:30 <phadej> topic
07:01:32 <merijn> Yeah
07:01:47 <merijn> I'm hesitant to propose changes though
07:02:11 <merijn> There's quite a lot of room for improvement, but too many of it is just minor syntactical tweaks causing breakage
07:02:25 <phadej> I'm afraid that "iterative improvements" is not the way to go, one reason is what you mention
07:02:45 <phadej> but coming up with "grand end design" taking into accounts most people wishes, being simple, yet expressive, ...
07:02:55 <phadej> doesn't sound easy
07:03:18 <phadej> also not academically interesting, I guess, so no PhDs working on it either :)
07:03:28 <merijn> phadej: If I designed a new syntax for imports I'd also define "import qualified Data.Map (Map) as M" to do unqaulified Map and everything else qualified
07:03:54 <phadej> merijn: I recall that one constraint is that you don't want to invalidate old books
07:04:15 <phadej> so changing the syntax semantics (where they overlap) is no go
07:04:22 <phadej> and you want to have reasonable migration story
07:04:24 <merijn> I should just start work on my own Haskell++, but I don't wanna reinvent all the code generation and optimistion :p
07:04:48 <orzo> what's Data.List.singleton?
07:05:09 <merijn> I think Csaba's work on his "GHC-WPC" stuff is promising. If he succeeds in separating GHC from it's backend that would be a *major* win
07:05:18 <merijn> orzo: "pure" or (:[])
07:05:21 <phadej> merijn: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/phases.html#ghc-flag--pgmF%20%E2%9F%A8cmd%E2%9F%A9
07:05:26 <merijn> orzo: But those were deemed "to confusing"
07:05:38 <phadej> merijn: that preprocessor can be arbitrary
07:05:48 <merijn> phadej: Doesn't work
07:05:58 <phadej> for modules no, it's not local
07:06:05 <phadej> but for some other stuff it might
07:06:14 <merijn> phadej: The stuff I have in mind is far more invasive
07:06:36 <merijn> And if you're not going to be that invasive, why bother inventing a new Haskell
07:06:40 <orzo> pure is too generic and (:[]) is a bit ugly i suppose
07:06:47 <phadej> merijn: to reuse Hackage
07:06:52 <merijn> orzo: Robot monkey is fine
07:07:09 <merijn> phadej: You gotta start somewhere
07:07:50 <phadej> pgmF which used something else than CPP would be nice start
07:08:34 <merijn> phadej: There's some pretty fundamental warts in Haskell that I don't like and I don't think they can be reasonably fixed in a backwards compatible way in Haskell, so I'd rather clean start then keep piling up ugly hacks and turn it into the Haskell equivalent of C++
07:09:03 <orzo> we should have moved 'return' to Applicative and never bothered with 'pure'
07:09:05 <orzo> heh
07:09:09 <merijn> phadej: otoh, duplicating GHC's optimisation and code generation is practically infeasible and makes such things essentially non-starters
07:09:17 <Uniaika> orzo: oooh that's a weird take :P
07:09:20 <dminuoso> orzo: Historically Applicative didn't exist.
07:09:29 <maralorn> orzo: My answer for that problem is we need better tooling. Not, we need less strict code.
07:09:43 <merijn> phadej: If the GHC-WPC work succeeds in getting a workable backend that can ingest Core, that would be super interesting for experiments in lazy/pure languages
07:10:01 <dminuoso> orzo: If Applicative came at the same time Monad came, and was its superclass, we wouldn't have return at all presumably.
07:10:07 <merijn> orzo: That's historically not possible
07:10:30 <merijn> orzo: Because that would only be possible if Applicative is a superclass of Monad which it wasn't at the time
07:10:57 <orzo> it is historically possible for the Idris language whidh is haskell-like and uses 'pure' rather than 'return' to my annoyance
07:11:17 * dminuoso never uses return
07:11:55 <orzo> return reads better most of the time to me
07:12:26 <z0> i'm confused. i tested 3 versions of a 'count' function for performance and I'm hoping someone can shed some light into what I'm seeing
07:12:34 <ezzieyguywuf> is it me, or is bool backwards? shouldn't `bool x y b` evaluate to x if b is True?
07:12:35 <z0> first, the canonical way: count x = length . filter x
07:12:38 <ezzieyguywuf> *shrug*
07:13:01 <merijn> z0: How'd you test?
07:13:19 <orzo> ezzieyguywuf: it's the trial case first, like with the function `maybe` and others
07:13:23 <dminuoso> ezzieyguywuf: My guess is, it's similar to maybe
07:13:25 <orzo> trivial
07:13:32 <merijn> ezzieyguywuf: It's not backwards, because it's *not* "if"
07:13:56 <z0> second, with a helper function that avoids going through the list twice, and third the same with a strict accumulator
07:14:02 <merijn> ezzieyguywuf: It's "Bool elimination" which, like the other elimination functions ("maybe", "either", "foldr") follows the constructor order
07:14:14 <dminuoso> ezzieyguywuf: so if we, subjectively, consider the "second argument the positive case", then both maybe and bool produce the second argument in the positive case.
07:14:23 <merijn> :t maybe
07:14:23 * ezzieyguywuf nods
07:14:24 <merijn> :t either
07:14:25 <lambdabot> b -> (a -> b) -> Maybe a -> b
07:14:26 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
07:14:29 <merijn> :t foldr
07:14:31 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
07:14:31 <merijn> :t bool
07:14:33 <ezzieyguywuf> I fully expected to be deluged with why I was wrong üòÇ
07:14:33 <lambdabot> a -> a -> Bool -> a
07:14:48 <dminuoso> Also
07:15:00 <z0> merijn:  ghc --make ${file} -O2 -prof -fprof-auto -rtsopts -fforce-recomp
07:15:03 <dminuoso> Any order you pick, you'll always have someone who wants it the other way around.
07:15:05 <merijn> ezzieyguywuf: Note that "data Maybe a = Nothing | Just a", "data Either a b = Left a | Right b", etc.
07:15:15 <z0> merijn:  ./${file} +RTS -p -hc -i0.0001
07:15:16 * ezzieyguywuf nods
07:15:25 <dminuoso> % :i Bool
07:15:25 <yahb> dminuoso: type Bool :: *; data Bool = False | True; -- Defined in `GHC.Types'; instance Eq Bool -- Defined in `GHC.Classes'; instance Ord Bool -- Defined in `GHC.Classes'; instance Enum Bool -- Defined in `GHC.Enum'; instance Show Bool -- Defined in `GHC.Show'; instance Data Bool -- Defined in `Data.Data'; instance Lift Bool -- Defined in `Language.Haskell.TH.Syntax'; instance Bits Bool -- Defined in `Data.Bits'
07:15:28 <dminuoso> @src Bool
07:15:29 <lambdabot> data Bool = False | True deriving (Eq, Ord)
07:15:35 <merijn> z0: I suspect the process startup will have tons of noise there
07:15:42 <merijn> z0: Consider using criterion
07:15:48 <merijn> @hackage criterion
07:15:49 <lambdabot> https://hackage.haskell.org/package/criterion
07:17:05 <z0> merijn: thanks. just to be clear, what results should I expect?
07:17:23 <merijn> No clue
07:17:36 <z0> I would guess the helper function with the strict accumulator
07:17:54 <merijn> But as a rule of thumb I just assume literally everyone's benchmarks are wrong and doubly so if they don't involve criterion in Haskell ;)
07:18:27 <z0> I'm just trying to reason about performance
07:18:58 <merijn> oh, wait, profiling compilation too?
07:19:09 <merijn> That probably already invalidates everything
07:19:25 <merijn> Profiling can (and does) prevent some optimisations from firing
07:19:56 <ski> % :i []
07:19:57 <yahb> ski: type [] :: * -> *; data [] a = [] | a : [a]; -- Defined in `GHC.Types'; instance Alternative [] -- Defined in `GHC.Base'; instance Applicative [] -- Defined in `GHC.Base'; instance Eq a => Eq [a] -- Defined in `GHC.Classes'; instance Functor [] -- Defined in `GHC.Base'; instance Monad [] -- Defined in `GHC.Base'; instance MonadPlus [] -- Defined in `GHC.Base'; instance Monoid [a] -- Defined in `GHC.Base
07:21:58 <dminuoso> merijn: You could do CPU instrumented instrumentation, possibly?
07:22:07 <dminuoso> *instrumented profiling
07:22:56 <dminuoso> I know AMD64 at least has special support for hardware based profiling like instruction counters
07:23:34 <merijn> dminuoso: Sure, but doing that stuff right is hard :p
07:23:56 <dminuoso> Sounds like we found a new master thesis.
07:24:00 <merijn> I've spent 6 years discovering all fun ways you can fuck up benchmarks and I'm still discovering more
07:24:04 <orzo> that stuff is not really avail to userspace anymore
07:24:11 <merijn> orzo: Yes it is
07:24:40 <orzo> well last i tried to play with it, it wasn't letting  me
07:24:50 <orzo> i figured spectre mitigation
07:29:06 <sm[m]> merijn: your thesis involves a lot of benchmarking ?
07:29:13 <dminuoso> Haha
07:29:17 <dminuoso> it's all about benchmarking
07:29:21 <merijn> sm[m]: Pretty much only benchmarking :p
07:29:39 <sm[m]> cool
07:29:43 <dminuoso> merijn: Oh I see you finally found a name for your project.
07:29:47 <merijn> And then a thin veneer of pretending to be able to draw conclusions from it after spending all my time trying to figure out how to do it properly :p
07:29:51 <dminuoso> Now I wonder, what does Belewitte mean?
07:30:07 <merijn> dminuoso: I decided to go with "super obscure folklore references that are only witty with said obscure knowledge"
07:30:27 <nicolasochem> Hi, noob here. I just posted a question in #haskell-beginners
07:30:28 <merijn> dminuoso: Also, it allowed me to improve the only metric I truly care about
07:30:35 <merijn> "how many obscure references can I cite?"
07:33:43 <orzo> "singleton is more confusing than (:[])!" ... I can see their point really.
07:34:03 <z0> hum... compiling with 'ghc --make file.hs -O2' and timing with 'time ./file' tells me the fastest one is 'length . filter p' and the helper function with the strict accuulator is a close second. the one with the lazy accum is 6x slower so that makes sense. but why is the first one faster? I dont think ghc optimizes going though the list twice
07:34:26 <merijn> z0: Why would it go through the list twice?
07:34:26 <orzo> (:[]) is short and can be worked out pretty quickly without searching docs
07:35:57 <z0> merijn: once for filter and then again for length. no?
07:36:02 <merijn> z0: It's lazy
07:36:18 <merijn> z0: It doesn't start going through the list to filter until length starts going through the result
07:36:48 <merijn> z0: It's basically going through the list once with filter throwing away some elements before passing everything else to length
07:37:26 <merijn> z0: "filter p foo" doesn't actually do anything until you try to inspect the result list of filter (say to compute the length)
07:38:02 <dolio> And also, it probalby does optimize some of the work away. :)
07:38:13 <merijn> And even then you have "filter p (x:xs) | p x = x : filter p xs; |otherwise = filter p xs" which just immediately return after only one step
07:38:26 <merijn> and yeah, list fusion probably eliminates the intermediate allocation
07:38:36 <z0> huh. i was assuming that it wasnt lazy at that level
07:38:52 <merijn> *everything* is lazy unless something forces it not to be
07:39:12 <merijn> z0: (well, that's actually a bit of a lie)
07:39:29 <z0> yeah.. *everything* is a bit of a lie
07:39:44 <z0> ok so wait
07:39:55 <z0> let me throuw you another example
07:39:57 <merijn> z0: Lazy evaluation is basically "pull" evaluation. You don't bother doing anything until you have to. When do you have to? When you're doing case and have to decided which branch to take
07:40:14 <merijn> @where apfelmus
07:40:14 <lambdabot> I know nothing about apfelmus.
07:40:17 <merijn> aww
07:40:22 <merijn> @where lazy-evaluation
07:40:23 <lambdabot> I know nothing about lazy-evaluation.
07:40:25 <merijn> bah
07:40:29 <merijn> I forget where it is
07:40:47 <merijn> z0: Might wanna read this: https://apfelmus.nfshost.com/articles/lazy-eval.html
07:41:26 <z0> thanks! will do
07:41:35 <merijn> z0: (the lie bit is that Haskell is defined as "non-strict" as opposed to lazy, the distinction being that "non-strict" means "if it works with lazy evaluation it should work")
07:41:50 <merijn> The easiest way of achieving that, obviously being, "just do lazy evaluation"
07:42:24 <merijn> But by specifying non-strict it means the compiler is allowed to make things strict IFF it can prove that doesn't break the code
07:43:41 <ski> @where lazy
07:43:41 <lambdabot> "Lazy Evaluation of Haskell" by monochrom at <http://www.vex.net/~trebla/haskell/lazy.xhtml>; "The Incomplete Guide to Lazy Evaluation (in Haskell)" by apfelmus in 2015-03-07 at <https://apfelmus.
07:43:41 <lambdabot> nfshost.com/articles/lazy-eval.html>; "Laziness, strictness, guarded recursion" by bitemyapp at <https://github.com/bitemyapp/learnhaskell/blob/master/specific_topics.md#user-content-laziness-
07:43:42 <lambdabot> strictness-guarded-recursion>
07:44:08 <z0> ok so another example. what I'm trying to do here is to fine-tune my intuition
07:44:25 <z0> imagine i have a 'range' function
07:44:31 <z0> range = uncurry (-) . (maximum &&& minimum)
07:45:07 <z0> my intuition here is that it goes through the list twice
07:45:36 <carbolymer> can I print constructor name using GHC.Generics?
07:45:52 <merijn> z0: That one *probably* does, yeah
07:46:12 <z0> ok so I'm on the right track
07:46:28 <merijn> z0: Incidentally, the STG paper (despite it's intimidating name) is probably a good read after Apfelmus' guide
07:46:32 <merijn> @where stg
07:46:32 <lambdabot> http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.53.3729
07:46:55 <merijn> z0: That one talks a bit lower level about "how do you even compile lazy functional code to an x86 CPU"
07:47:23 <z0> that may be a bit out of my scope but ill give it a try
07:49:50 <z0> so this would be better, right? range = uncurry (-) . foldl' maxmin (minBound,maxBound) where maxmin (mx,mn) = max mx &&& min mn
07:51:16 <merijn> That sounds like a job for Data.Semigroup ;)
07:52:18 <merijn> :t foldMap' (Min . Just &&& Max . Just) 
07:52:19 <lambdabot> error:
07:52:19 <lambdabot>     ‚Ä¢ Data constructor not in scope: Min :: Maybe a -> c
07:52:19 <lambdabot>     ‚Ä¢ Perhaps you meant one of these:
07:52:32 <merijn> % import Data.Semigroup
07:52:32 <yahb> merijn: 
07:52:37 <merijn> % :t foldMap' (Min . Just &&& Max . Just) 
07:52:37 <yahb> merijn: (Foldable t, Ord a, Bounded (Maybe a)) => t a -> (Min (Maybe a), Max (Maybe a))
07:52:57 <merijn> Wait, where does the Bounded come from?
07:53:23 <merijn> % :t Min
07:53:23 <yahb> merijn: a -> Min a
07:53:51 <dolio> Bounded a => Monoid (Min a)
07:54:29 <dolio> (Ord a also required, of course.)
07:55:17 <ski> @type Data.Semigroup.Foldable.foldMap1
07:55:18 <lambdabot> (Foldable1 t, Semigroup m) => (a -> m) -> t a -> m
07:55:54 <merijn> dolio: hmm
07:56:06 <merijn> Last I checked it didn't have a Monoid that's what the Just was for
07:56:16 <dolio> Min/Max semigroup don't have the Maybe part.
07:56:26 <dolio> They're just Semigroups always, and Monoids if the type is bounded.
07:56:50 <merijn> ski: foldMap1 is, presumably, not strict
07:57:52 <merijn> % :t foldMap' (Just . (Min &&& Max))
07:57:52 <yahb> merijn: (Foldable t, Ord a) => t a -> Maybe (Min a, Max a)
07:57:53 <dolio> merijn: I think it got rearranged so that you use `Maybe Max` if you want to add a monoid unit.
07:58:03 <merijn> That's probably better
07:58:42 <merijn> z0: So, there you go single traversal min and max ;)
07:58:46 <dolio> Semigroup a => Monoid (Maybe a)
08:00:03 <z0> nice
08:02:56 <dolio> That actually makes the Maybe instance pretty useful, instead of, "why did that one get picked?"
08:11:15 <halogenandtoast> Any suggestions on how to make this more concise while retaining some semblance of readability? https://gist.github.com/halogenandtoast/425f874e2f010037bbea7f129ef9b3b5
08:11:51 <halogenandtoast> It just feels like there should be some way to get rid of a lot of that duplication
08:14:35 <merijn> Can't you define a name for the redundant part and then foldMap?
08:15:12 <frdg> I am trying to use unless from Control.Monad. I could use help understanding what is going with this function. https://dpaste.org/ntc1
08:15:28 <merijn> like "foldMap (\f -> map (getCount ()) . toList $ g ^. f) [enemies, locations, ...]" I suppose those fileds don't have nice types, though
08:15:59 <merijn> frdg: The last argument of unless is "IO ()"
08:16:30 <merijn> frdg: It's complaing that "unless (False == LOGIC.isHomeFormValid st ctry)" has type "Monad m => m () -> m ()"
08:16:37 <merijn> But liftIO expects "IO a"
08:16:59 <merijn> You're missing the part that says what to do when that condition is true
08:17:25 <frdg> ok
08:17:36 <frdg> I have to think about this
08:18:11 <halogenandtoast> merijn: yeah they are not monomorphic lenses
08:18:20 <halogenandtoast> getCount is necessary to make it monomorphic
08:18:59 <merijn> Then the answer is that the cure is probably worse :p
08:19:12 <merijn> You can use an existential GADT to hide the "input", I suppose
08:20:28 <halogenandtoast> sounds unpleasant
08:21:02 <merijn> halogenandtoast: It's...ok
08:21:13 <merijn> halogenandtoast: If these are the only two cases you have, probably not worth it
08:21:20 <merijn> but if you have a lot, it might be
08:21:35 <halogenandtoast> merijn: those are the same case, just trying different approaches in that gist
08:21:51 <merijn> halogenandtoast: I have a bunch of code that wants to sort various persistent entities based on different columns (which have different types)
08:22:37 <merijn> halogenandtoast: So I have like "EntityField rec v" from persistent which is a field of type 'v' from entity 'rec' and I want to combine fields with different types 'v'
08:22:47 <merijn> halogenandtoast: Which sorta matches what you have
08:23:01 <merijn> halogenandtoast: I wrap them like so: https://github.com/merijn/Belewitte/blob/master/benchmark-analysis/src/Pretty/Fields.hs#L27-L46
08:23:28 <justsomeguy> So, I want to automate typing my solutions to some exercises in haskellbook.com that use ghci to inspect types, tinker with how evaluation order works differently at the prompt, and generally play around in the repl. Is there some facility for that? Or, hey, I just found expect, maybe that will work.
08:23:30 <dyeplexer> How bad is this mean calculation function?:
08:23:31 <dyeplexer> avg xs = q / p where g = foldl (\(a, b) c -> (a + 1, b + c)) (0, 0) xs; p = fst g; q = snd g;
08:23:45 <dyeplexer> The commonly available implementation on the internet utilises "bang patterns", foldl' and casting to Fractional.
08:23:59 <dyeplexer> This one is more readable to me.
08:24:16 <merijn> halogenandtoast: Which gets used like https://github.com/merijn/Belewitte/blob/master/benchmark-analysis/src/FormattedOutput.hs#L41-L42
08:24:52 <dyeplexer> (though that is a consequence of me not knowing about a lot of the higher concepts made in the common implementation)
08:25:14 <merijn> justsomeguy: The standard solution is: use your favourite editor to work in a file, then use ":load file.hs" (or ":l file.hs") to load it and play with the definitions
08:25:46 <merijn> justsomeguy: You can use ":reload" (or ":r") to refresh the contents of the file
08:26:55 <dolio> If your editor is the type that runs in a terminal (as the configured editor), then you can load the file in ghci, and then `:e` to edit the file, and then exiting will reload the file.
08:27:04 <halogenandtoast> merijn: thanks for the example. I am probably just going to leave it as is.
08:27:21 <halogenandtoast> But if it crops up a lot more than I mgiht try something like that.
08:27:24 <justsomeguy> merijn: One obstacle is that the exercises have me use ghci commands like :info and make observations about how variables are shadowed each line after pressing enter. Can I include ghci commands in files that I :load?
08:27:27 <dolio> I guess it doesn't have to run in the terminal, just be launchable.
08:27:36 <merijn> halogenandtoast: Yeah, it depends a bit on how much duplication you have and how convenient it is to wrap things up
08:28:15 <merijn> halogenandtoast: There's a grey area where the boilerplate is enough to be annoying, but not sufficient to deal with the solution :p
08:28:32 <merijn> halogenandtoast: FWIW the existential wrapper is working out really well
08:29:18 <halogenandtoast> merijn: last time I used an existential wrapper I ended up having to rewrite the whole project
08:29:20 <halogenandtoast> :p
08:29:37 <merijn> existentials for "OO" are project wreckers, yeah
08:29:55 <merijn> But existentials for hiding "intermediate" steps in conversions works well
08:29:56 <halogenandtoast> merijn: Yeah I got pretty far and was like, hmm I need to {To,From}JSON instances now.
08:30:06 <halogenandtoast> s/to/some/
08:30:10 <dolio> I think the issue would be that you might be introducing one existential type per HasFoo, which wouldn't be any less work.
08:30:28 <dolio> Unless you make one master type that quantifies over all the HasFoo together.
08:30:47 <merijn> halogenandtoast: Because that's what you want, right, you have "Foo r" and "r -> Bar" for multiple different 'r', but that's not important to code that just needs to aggregate the final Bar values
08:31:28 <merijn> dolio: Did you see the first link? That just has a single existential for everything which I think should work for halogenandtoast's lenses too
08:31:29 <dolio> Maybe the master type is okay if all the components really share all the constraints.
08:31:44 <merijn> dolio: Oh, I'm talking existentials without constraints
08:32:05 <merijn> dolio: Like "data Foo a where Foo :: r -> (r -> a) -> Foo a"
08:32:51 <merijn> As soon as you have constraints on your existentials, then you're just doing
08:32:55 <merijn> @where existential-antipattern
08:32:56 <lambdabot> "Haskell Antipattern: Existential Typeclass" by Luke Palmer at <http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/>
08:34:27 <dolio> Does that avoid writing `FieldInfo foo` five times instead of `foo` five times?
08:35:21 <merijn> dolio: No, but what it avoids is that he can take the boilerplate conversion define a single function that does that and wraps it into FieldInfo and then work with that
08:35:57 <merijn> dolio: So it depends on how often he reuses the same conversion pipeline
08:37:09 <merijn> Whether that's useful depends
08:40:53 <dolio> I'm still not sure I understand. Is this just making the `foo` shorter when you write `foo enemies ; foo locations ; foo assets ; ...`?
08:42:24 <frdg> merijn: From before with unless. I want the IO () -> IO () function to just do nothing and continue through the monad. I am having issues coming up with that function.
08:42:59 <merijn> frdg: No, unless is the function with type "IO () -> IO ()"
08:43:10 <merijn> frdg: You want to abort when the condition is true, right?
08:43:42 <frdg> yes thats right
08:43:58 <merijn> "unless myCondition (throwIO someexception)"
08:44:10 <frdg> ok
08:44:23 <merijn> eh, wait that has the condition inversed, but yeah
08:44:36 <merijn> "when myCondition (throwIO someexception)"
08:44:53 <merijn> That runs the "throwIO someexception" bit if myCondition is true, else it does nothing
08:45:51 <frdg> ohhh I see. 
08:45:57 <frdg> I had it backwards
08:46:20 <merijn> and "unless" is just "unless p = when (not p)"
08:51:49 <kuribas> does anyone know GRIN?
08:52:28 <kuribas> I wonder if I could use it for a production project
08:53:18 <kuribas> https://github.com/grin-compiler/grin
08:55:08 <kuribas> ugh, no licence
08:59:24 <dolio> Then you can't use it. :)
09:00:12 <dolio> I mean, you can use it, but you couldn't give what you used it for to anyone else.
09:00:36 <kuribas> can you?
09:00:54 <kuribas> without copyright you cannot copy it...
09:01:01 <kuribas> only look at it on github...
09:01:12 <dolio> Copyright gets the person who distributes.
09:04:23 <kuribas> that doesn't include distributing it to my own computer?
09:04:31 <dolio> You aren't distributing it, github is.
09:04:32 <[exa]> kuribas: https://github.com/grin-compiler/grin/blob/master/grin/LICENSE
09:04:43 <[exa]> apparently they have it sub-foldered
09:04:54 <kuribas> [exa]: ah MIT, great :)
09:05:11 <kuribas> or is that BSD?
09:05:26 <[exa]> isn't MIT the same as 3-BSD?
09:06:04 <merijn> No
09:06:22 <[exa]> licenses should have featureflags
09:07:14 <maerwald> [exa]: hmm... the question is rather how well it does in court
09:07:22 <maerwald> and I don't think there's an open database for it
09:07:34 <maerwald> ask your paralegal
09:08:06 <[exa]> ok 2-clause. :]
09:08:44 <maerwald> I'd expect the WTFPL to not do very well
09:09:00 <dolio> They look different, but I think they're all functionally the same, because most of the differences aren't really doing anything legally.
09:11:05 <[exa]> dolio: except protecting you against a generic action of copyright protection entities
09:11:52 <dolio> Well, I mean, the extra clauses are like 'you don't have rights to X' when you wouldn't anyway even by the licenses without the clause.
09:15:05 <dolio> This is specifically about MIT and BSD, and maybe some others that are similar.
09:18:50 <monochrom> github has already required the uploader to agree to letting github letting everyone download
09:19:31 <monochrom> But downloaders need a separate permission to become distributors, yeah.
09:24:48 <monochrom> Feature flags won't work for licenses. Generally most of human creations and social constructs. People are really creative in thinking up exceptions upon exceptions.
09:27:30 <monochrom> To be fair, feature flags can kind of work: In each license, you can expect 90% of it to be simply feature flags. But the other 10% is full of exceptions and complications that can't be shoehorned into simpler, shorter feature flags.
09:29:09 <monochrom> http://www.vex.net/~trebla/humour/tautologies.html  #1  :)
09:35:25 <jared-w> https://tldrlegal.com/license/mit-license https://tldrlegal.com/license/bsd-3-clause-license-(revised) not feature flags, but about as good as you can get for legalese
09:37:06 <monochrom> Nice.
09:41:55 <lucky> maerwald: IANAL so don't take this as legal advice, but I'm fairly sure the Canadian courts would interpret the WTFPL as placing the work in the public domain 
09:42:19 <lucky> but the usual caveat about license proliferation applies here.  why run the risk when other licenses are clearer and more widely used, and even have some litigation history behind them?
09:49:00 <Enrico63> Hello
09:49:29 <Enrico63> Hello tomsmeding
09:51:56 <Enrico63> Concerning this terminal snake that I'm trying to write, it seems I have the basic input handling: the user can enter an input or not and the program executes according to that input or to the old input if the user doesn't provide it
09:53:15 <Enrico63> So now it is time to write the game logic, and then to print it to screen, maybe in this order. However, since the former task seems harder to me, I started searching for _haskell draw terminal_ on google, and the first result is: http://hackage.haskell.org/package/ansi-terminal-game-1.0.0.0/docs/Terminal-Game.html
09:54:09 <Enrico63> kind of, everything is already there, ahaha. But yeah, I want to practice writing haskell code, not copy and pasting the solution already written
09:54:32 <Enrico63> Hence, what I should look at, if I want to manually deal with the printing on screen?
09:55:00 <ezzieyguywuf> I don't understand Data.Set.dropWhileAtitone -> from what I gather, a function f is an antitone if f y <= f x, but in this case, f is a "predicate" that simply returnes a Bool, so how does the concept of "<=" apply?
09:55:42 <dolio> False < True
09:56:17 <ski> ezzieyguywuf : if `x =< y' implies `f y =< f x'
09:56:22 <ski> @type Data.Set.dropWhileAtitone
09:56:24 <lambdabot> error:
09:56:24 <lambdabot>     Not in scope: ‚ÄòData.Set.dropWhileAtitone‚Äô
09:56:24 <lambdabot>     Perhaps you meant one of these:
09:56:25 <ski> @type Data.Set.dropWhileAntitone
09:56:27 <lambdabot> (a -> Bool) -> S.Set a -> S.Set a
09:56:31 <Enrico63> dolio, is it intentional that the anagram of your user name is idolo? (which is idol in italian)
09:56:49 <dolio> Nope. :)
09:57:16 <sm[m]> yay, terminal snake!
09:57:26 <Enrico63> Oh, so maybe it's like d'olio, which is "of oil" in italian
09:57:31 <Enrico63> dolio
09:57:37 <Enrico63> ahhahaah, just kidding
09:58:35 <monochrom> I would pay attention to "Drop while a predicate on the elements holds" :)
09:58:42 <sm[m]> Enrico63: if you don't want to use ansi-terminal-game, the next level down is what it depends on - probably ansi-terminal
09:58:56 <sm[m]> FYI there's also #haskell-game
09:59:34 <ezzieyguywuf> dolio: ski: I'm still confused though, what is this trying to tell me " The user is responsible for ensuring that for all elements j and k in the set, j < k ==> p j >= p k"\
09:59:35 <dolio> The mono/antitone part is supposed to be that it switches values once.
09:59:47 <dolio> Starts true and then goes to false, or starts false and goes to true.
10:00:05 <ezzieyguywuf> here's what I'm trying to do: I have a Data.Set.Set, I want to drop all values that match a certain predicate
10:00:22 <monochrom> Then it's Set.filter
10:00:28 <ezzieyguywuf> so I have `MySet :: Set.Set MyData`, `MyPredicate :: MyData -> Bool`
10:00:40 <ezzieyguywuf> ah
10:00:45 <ezzieyguywuf> guess I over-complicated things :-P
10:01:19 <ski> > S.dropWhileAntitone (\x -> x < 4 || odd x) (S.fromList [0 .. 7])
10:01:24 <lambdabot>  fromList [6,7]
10:01:25 <ski> > S.dropWhileAntitone (\x -> x < 4 || odd x) (S.fromList [0 .. 8])
10:01:29 <lambdabot>  fromList [8]
10:02:09 <ezzieyguywuf> ah hah
10:02:16 <Enrico63> sm[m], I'll give a look at that channel, but concerning your suggestion, where does drawing with `putStr` and similar fit, in the lower and higher level ranking that you refer to, with respect to ansi-terminal and ansi-terminal-game?
10:02:18 <ezzieyguywuf> indeed I do want filter.
10:03:16 <monochrom> takeWhileAntitone and dropWhileAntitone are optimizations when you know your truth values aren't arbitrarily distributed.
10:03:18 <geekosaur> it makes you figure out things like colors and cursor addressing yourself instead of using routines that do them for you
10:04:29 <Enrico63> geekosaur, what is _it_ ? ansi-terminal?
10:04:38 <geekosaur> putStrLn
10:05:04 <Enrico63> Ok, and isn't that a good thing?
10:05:31 <Enrico63> I mean, this is maybe a matter of opinion, but I'd like some opinion indeed, @geekos
10:06:15 <geekosaur> most people don't want to work out when to use which cursor addressing commands, how to construct color and attribute values, etc.
10:06:21 <geekosaur> which is why ansi-terminal exists
10:07:26 <sm[m]> Enrico63: putStr and similar don't give you control of the position
10:07:55 <sm[m]> ansi-terminal is the simplest way to get that (ncurses or vty are the next more powerful & more complicated ways)
10:08:02 <Enrico63> yeah, but it would be ok to just run a clean screen command, and draw the game again, I guess
10:08:44 <geekosaur> well, they do, but you get to construct those escape sequences yourself. similarly for colors/attributes
10:08:44 <sm[m]> that's true! might be slow, but a good start
10:09:10 <sm[m]> ah true
10:09:49 <juri_> grr. ghci won't let me load parts of my library, because a library i depend on is not found.. it's trying to pull in an ANCIENT version of it, and i can't find out why.
10:09:53 <geekosaur> also suggesing ncurses to anyone who hasn't already been using it for years is probably bad
10:09:58 <juri_> meanwhile, ghc works fine.
10:10:02 <juri_> *boggles*
10:10:32 <juri_> I've nuked .cabal...
10:10:36 <geekosaur> it's far too idiosyncratic and should be left to folks who're used to working around it
10:11:02 <monochrom> I do need to know a few ansi terminal code for bash prompts. :)
10:11:07 <juri_> I've nuked .ghc...
10:11:14 <sm[m]> just laying out the terrain
10:11:23 <juri_> and the package in question isn't in my /usr.
10:11:25 <monochrom> And a few more, I guess non-ansi terminal code, for screen.
10:11:33 <juri_> wtf ghci?
10:11:36 <geekosaur> screen speaks ansi
10:11:38 <Enrico63> bash prompts is as far as I've gone concerning colors in bash
10:12:14 <juri_> this worked in 8.6, but 8.8 is being super-lame.
10:15:45 <sm[m]> @pastecabalstack, juri_ 
10:15:46 <lambdabot> Unknown command, try @list
10:15:58 <sm[m]>  * @pastecabalstack , juri_
10:16:10 <geekosaur> @where pastecabalstack
10:16:10 <lambdabot> Help us help you: at https://paste.tomsmeding.com, https://gist.github.com or https://termbin.com, please paste your failing command, full output, and .cabal, package.yaml and/or stack.yaml files
10:16:23 <maerwald> monochrom: https://paste.tomsmeding.com/3y1S4en4
10:16:25 <maerwald> try that
10:16:53 <maerwald> you just cat that file
10:16:57 <sm[m]> doh, thanks :)
10:16:59 <monochrom> I don't want to try that! What is it?!
10:17:07 <maerwald> you only find out if you try :p
10:17:27 <geekosaur> looks like it's setting colors to me
10:17:42 <MarcelineVQ> monochrom: It's a small furred animal often used to bring comfort to lonely people, but that's not important right now
10:17:56 <sm[m]> don't look! remember Snowcrash!
10:18:06 <monochrom> Actually it's interesting that you can use the most general #CB4B16 for colours.
10:18:20 <monochrom> I thought we were stuck with 256 colours.
10:18:44 <maerwald> no, we are stuck with 16
10:19:08 <monochrom> But I guess "xterm256" is more catchy than "xterm16777216"
10:19:19 <geekosaur> you're stuck with a palette of 16 or 256 colors but many terminals let you customize what colors are in the palette
10:19:31 <monochrom> ah OK
10:20:11 * monochrom sets them to 256 shades of grey!
10:20:40 <maerwald> whatever works for you :p
10:20:53 <juri_> sm[m]: https://gist.github.com/julialongtin/dc21ae22da54daf69cb8971ecb525dfd
10:21:37 <juri_> yay for "try adding this option to see whaat is going wrong"... and getting tons of verbosity, and no useful output.
10:23:03 <monochrom> https://github.com/treblacy  marvel at my 256-shades-of-grey avatar!
10:23:16 <monochrom> "such greyscale, so monochrom"
10:23:17 <sm[m]> juri_: there's a lot you haven't told us yet. Is this a cabal project ? stack project ? Maybe cabal repl or stack repl works better
10:23:50 <juri_> it's a cabal project.
10:24:24 <juri_> and when building with cabal, everything works.
10:24:47 <geekosaur> then use cabal repl instead of ghci, for starters
10:25:06 <juri_> *sigh*
10:25:54 <geekosaur> ghci can't see inside of a cabal or stack project, which will have its own packages and environment
10:28:52 <sm[m]> maybe it would be nice if it did, automatically, like ghcid (often) can
10:29:27 <monochrom> It can't be cabals all the way down. :)
10:29:35 <sm[m]> it sure would help a lot of new users if it did
10:30:10 <geekosaur> that was what .ghc-environment files were intended for, iirc. of course both cabal and stack promptly disabled their generation
10:31:32 <sm[m]> obviously (?) ghci shouldn't depend on cabal, but it could certainly run "cabal repl" if it sees .cabal in current directory
10:32:01 <geekosaur> and now you have a infinite loop :)
10:32:05 * sm[m] . o O ( a simple matter of programming what could possibly go wrong )
10:32:14 <monochrom> Naw just add a shell script.
10:32:18 <sm[m]> how so ?
10:32:45 <geekosaur> ghci -> cabal repl -> runs ghci with project environment -> runs cabal repl -> ...
10:33:16 <monochrom> This is how over-engineering begins.
10:33:31 <dolio> A lot of people didn't like it when ghci automatically acted differently in these contexts, as referenced.
10:33:32 <int-e> adding magic makes things harder to debug, not easier
10:33:43 <monochrom> Look at how the python people, the rust people, and the ruby people don't expect this nice feature.
10:34:33 <monochrom> (And they do get to brag that their packaging environments are better than us.)
10:34:36 <sm[m]> well, I'll just assert that if we wanted to provide a "ghci" command that just worked, it's possible
10:34:41 <monochrom> s/us/ours/
10:34:44 <int-e> . o O ( alias ghci='ghci -ignore-dot-ghci', GHC_ENVIRONMENT=- )
10:35:04 <int-e> I'm using both of these, keeps me happier.
10:35:57 <monochrom> "cabal" and "stack" are already the commands that just work.
10:36:16 <sm[m]> ahaha
10:36:27 <monochrom> The Rust people don't want "rustc" to play God either.
10:36:42 <sm[m]> but seriously .. a lot of new folks avoid them because they want to "start with the basics", which they reasonably perceive as ghc & ghci
10:37:09 <sm[m]> what does GHC_ENVIRONMENT=- do, int-e ?
10:37:34 <int-e> sm[m]: instructs ghc{,i} to not look for an environment.
10:38:00 <int-e> I run ghci in random directories.
10:38:09 <sm[m]> hmm, isn't that the default behaviour as juri_ just found out ?
10:38:23 <int-e> For example, I use it as a calculator.
10:38:26 <monochrom> My impression is the opposite. The majority of new folks avoid the basics.
10:38:29 <sm[m]> oh you mean .ghc-environment files ?
10:38:32 <int-e> Yes.
10:39:15 <int-e> (cabal exec  overrides GHC_ENVIRONMENT and that's fine.)
10:39:38 <int-e> (because that is what it's for)
10:39:44 <int-e> v1-exec, if that matters
10:39:47 <monochrom> The majority of beginners, either due to "dive-in project" or "IDE", do a bit of googling and run into stack or cabal, and don't even want to know that ghci exists.
10:39:51 <dolio> If they want to start with the basics, they can already use ghc(i) without anything to load a bunch of basic stuff that comes with ghc.
10:40:15 <dolio> If they're using a cabal project, they're not using the basics anymore.
10:40:51 <sm[m]> monochrom: I don't know about the majority, but running "ghci" seems rather common
10:40:55 <monochrom> I say this because in my course, I tell students to just use ghci, and they find their way to stack anywway.
10:41:18 <monochrom> and vscode and all kinds of fantastic plugins
10:41:48 <dolio> It seems like GHC comes with all the stuff that I was using while learning before cabal even existed.
10:41:54 <sm[m]> there are many ways to fail with haskell, no need to limit ourselves to just one :)
10:41:57 <dolio> Which was enough to do homework.
10:42:13 <juri_> it would be nice if ghci could tell me where it's getting it's package definition.
10:42:27 <sm[m]> juri_: ghc-pkg list is a good way
10:42:30 <juri_> because there's no reference to this package in my home directory, or /usr
10:42:31 <monochrom> It is very easy to remind them: if they need extra packages, then it's a step up and they have to go through cabal or stack; if they don't, then ghci can work.
10:42:43 <sm[m]> assuming ghc-pkg and ghci are from the same bin dir, which they usually are
10:42:44 <monochrom> There is no need to add further automation to ghci
10:44:07 <sm[m]> juri_: did "cabal repl" not solve your problem ?
10:44:08 <juri_> sm[m]: ok, that's useful.
10:46:31 <sm[m]> the "unusable" errors you showed suggest your global (user) package db is corrupted, eg some things got removed during disk cleanup
10:47:57 <geekosaur> they said they'd removed .cabal, which will leave behind a broken user package db
10:48:38 <int-e> righ, there's some .ghc stuff to clean up as well
10:49:24 <sm[m]> and maybe ./dist{,-newstyle} ?
10:49:56 <juri_> ok. it was a package cache in /usr/lib/
10:50:28 <geekosaur> /usr/lib? is this arch, by any chance?
10:50:34 <juri_> no, debian.
10:50:40 <int-e> ooph
10:51:07 <geekosaur> interesting. (arch only half-installs packages, so the package db is almost always corrupt.)
10:51:11 <ezzieyguywuf> how come when and unless can only return `m ()`? I'm in the ExceptT monad, and I want to bail out by calling "throwError" when a predicate evaluates to True
10:51:15 <juri_> aparently, i ran haskell as root a looong time ago, and it dropped a package db in the OS.
10:51:19 <ezzieyguywuf> I though `when` would be my guy, but that's not the case
10:51:25 <sm[m]> aha
10:51:56 <geekosaur> no, running it as root would be /root/.ghc
10:51:58 <juri_> I don't know why ghc 8.6.4 was ignoring it, but it came back with a vengance when updating to 8.8.3.
10:52:02 <int-e> debian also splits up stuff into too many packages though, hmm
10:52:26 <geekosaur> /usr/lib is packages that come with the compiler, if the compiler is installed under /usr as usual
10:52:30 <ezzieyguywuf> I could always do if-then-else, but then the bulk of my do-statement would be in the else-clause
10:52:38 <dolio> ezzieyguywuf: when does nothing when the condition is false.
10:52:42 <ezzieyguywuf> I guess that's not necessarilly a bad thing but it seems wonky
10:53:04 <ezzieyguywuf> dolio: that's what I want - call `throwError` when condition is True, otherwise keep chugging
10:53:09 <geekosaur> andthere's a separate package db per ghc version, so one could be corrupt and the other valid
10:54:09 <dolio> What non-unit value is supposed to be created in the false case?
10:54:18 <ezzieyguywuf> I guess I could do `if myCondition then throwError "awooga" else pure ()`, but again, this seems wonky and anti-patterney
10:54:26 <int-e> (Debian has separate {-dev,-prof,-doc} packages, it seems... not sure whether they properly deal with the case of lacking -prof part)
10:54:39 <dolio> That has the same type as `when`.
10:55:06 <ezzieyguywuf> or rather, `...else pure (Right ())`
10:55:11 <dolio> It is basically the implementation of when.
10:55:50 <someuser123> I'm looking at the package labeled-tree on hackage (https://hackage.haskell.org/package/labeled-tree-1.0.0.0/docs/src/Data-LabeledTree.html#Tree). what does the type parameter `k` stand for and what does `::>` mean ? 
10:56:23 <geekosaur> int-e, it does (rather, ghc does since it only checks for the prof library when the prof way is requested)
10:56:54 <ezzieyguywuf> I guess I'm looking for `a -> b -> Bool -> Either a b`, but really `b` is just `Right ()` b/c I don't care about the value, just that ExceptT doesn't bail out
10:57:10 <geekosaur> whereas arch splits the static and dynamic libraries (or just plain removes the static ones) and that breaks among other things ghc-pkg
10:57:15 <int-e> geekosaur: ghc-pkg check would complain though?
10:58:05 <dolio> Right () isn't a type.
10:58:31 <sm[m]> phadej: https://oleg.fi/gists/posts/2020-09-13-a-design-for-paths.html was a good read
10:59:07 <dolio> I don't understand what the problem with `when` and `unless` are. You started saying you didn't want (), but all your examples are ().
10:59:19 <geekosaur> int-e, I can't test because I have hvr's packages installed with prof, but I don't recall there being a warning in that case. but it's been some time because I almost never want debian's ancient ghc :)
10:59:32 <ezzieyguywuf> hrm, maybe `ExceptT (if myCondition then Left "error" else Right ())`
11:00:09 <geekosaur> note also that archs breakage doesn't even require ghc-pkg check, the packages are broken during ghc-pkg list as well
11:00:14 <dolio> That is `when myCondition (throw "error")`.
11:01:37 <ezzieyguywuf> dolio: that's what I thought...
11:01:46 <ezzieyguywuf> maybe there's something wrong in my syntax then
11:04:06 <ezzieyguywuf> hah, yea, syntax problem
11:04:09 <dolio> You could also use `guard`, but it doesn't let you give a message.
11:04:27 <dolio> So I assume it's not what you want.
11:04:52 <int-e> geekosaur: yeah for Arch, the distro ghc is barely good enough to bootstrap one's own.
11:05:26 <phadej> sm[m]: thanks
11:07:15 <ezzieyguywuf> dolio: thanks. when is what I wanted but i'll keep guard in mind for the future.
11:08:14 <maerwald> dolio: is there no guard-like combinator for MonadFail?
11:08:22 <int-e> geekosaur: Hmm, ghc-pkg check doesn't complain with or without profiling libs on Debian. So that worry was unjustified it appears.
11:09:16 <geekosaur> I was trying to remember if there'sa  utility that fixes up the package db; I recall there being one as part of their Haskell packaging, so presumably it's used
11:09:25 <geekosaur> debian's usually pretty good about such things
11:09:59 <int-e> And I guess the reason is that the package description doesn't have a separate field for profiling libs at all, only library-dirs and dynamic-library-dirs...
11:10:12 <int-e> So there's no fixup needed for that.
11:10:24 <geekosaur> right, it'd be ways iirc?
11:10:25 <int-e> They may do fixups for the documentation, have not tried.
11:12:25 <tomsmeding> Enrico63: too lazy to read the whole conversation, did you get a satisfactory answer? :)
11:12:28 <sm[m]> what's fixing up here, geekosaur ? I had an ancient script that cleaned out broken packages
11:12:32 <geekosaur> I don't recall if the package db lists available ways or if that just comes out of what files are available
11:13:01 <monochrom> maerwald: MonadFail has "nonexhaustivepattern <- action" in mind, not user-handwritten-combinator in mind.
11:13:03 <Enrico63> tomsmeding, yes
11:13:19 <Enrico63> and also another good suggestion on haskell-game
11:13:23 <geekosaur> sm[m], I meant a script run after package installation that edits and sanitizes the package db, but it sounds like one isn't needed for this
11:13:30 <maerwald> monochrom: yep, I abuse that with pure a lot
11:13:33 <tomsmeding> Enrico63: writing ansi codes yourself is not terribly hard; next step up is ansi-terminal which prints those for you; next step up is vty which does double-buffering for you; next step up is I guess ansi-terminal-game though I don't know that one
11:13:50 <tomsmeding> myself I'm very much a fan of the double-buffering layer
11:14:13 <tomsmeding> in the vein of which you can also use my own library :) https://git.tomsmeding.com/terminal-io-hs/tree/
11:14:14 <int-e> geekosaur: ghc-pkg describe bytestring  suggests the profiling way is implicit (available if the required .p_a etc. files are)
11:14:18 <monochrom> Yeah then write your own combinators :)
11:14:31 <geekosaur> ok
11:14:50 <int-e> Also, it works, maybe that's good enough :)
11:15:14 <sm[m]> oh that's a good distinction tomsmeding .. double buffering
11:15:48 <sm[m]> where does your terminal-io-hs fit in this landscape ? Should others use it ?
11:15:51 <tomsmeding> I've written two double-buffering terminal IO libraries already, one for C and one for Haskell, so it may be clear that I like that level of abstraction :p
11:16:13 <tomsmeding> terminal-io-hs is basically ncurses-level abstraction, which I believe is kind of the level of vty
11:16:23 <tomsmeding> but it's significantly less mature, so perhaps just use vty
11:16:45 <tomsmeding> (I didn't know about the existence of vty at the time)
11:16:56 <sm[m]> ack
11:17:16 <sm[m]> ncurses does double buffering too, I guess ? I know, don't use it.. just curious
11:17:28 <tomsmeding> ncurses does double-buffering yes
11:18:10 <tomsmeding> as does my termio library (in C), which doesn't use the termcap database and is thus less compatible, but it has a (IMO) vastly better API and is a lot smaller :)
11:18:21 <tomsmeding> though that's fairly irrevant to #haskell people
11:55:19 * hackage uniqueness-periods-vector-examples 0.3.0.0 - Examples of usage for the uniqueness-periods-vector series of packages  https://hackage.haskell.org/package/uniqueness-periods-vector-examples-0.3.0.0 (OleksandrZhabenko)
12:01:02 <juri_> and now i've run straight into https://github.com/haskell/cabal/issues/6391
12:02:04 <maerwald> "install ‚Äîlib doesn‚Äôt seem to be designed at all. Just implemented. "
12:02:06 <maerwald> xD
12:03:27 <sm[m]> I'm not a cabal expert, but have you tried starting fresh, or using stack ?
12:03:57 <maerwald> sm[m]: :p
12:03:58 <juri_> every dependency of my project is placed in .cabal/store/ghc-8.8.4/package.db two times.
12:04:17 <geekosaur> there's a .ghc_environment file left somewhere with entries for both versions in it
12:04:18 <juri_> even tho i never called cabal install. just cabal build.
12:04:28 <geekosaur> (which is what install --lib does)
12:04:38 <maerwald> it's in ~/.ghc
12:04:48 <maerwald> if you remove it, maybe the problems go away
12:04:58 <maerwald> default_environment or something
12:05:43 <juri_> sm[m]: i'm working with a fresh checkout, and removing .ghc and .cabal. :)
12:06:15 <juri_> I guess it's time to give up and use cabal repl.
12:06:16 <maerwald> sm[m] just wants to give you a different set of problem, because he knows them better :p
12:06:23 <juri_> ghci is just un-usable. :)
12:06:36 <maerwald> (which is absolutely valid)
12:06:40 <juri_> maerwald: nothing wrong with that. :)
12:06:57 <maerwald> yes, it doesn't matter what tool you use, just that you know your way around it
12:07:02 <maerwald> because they all suck
12:07:26 <sm[m]> well, then ouch. Personally I'd be trying stack in that case. Not because I want to answer questions about it, but if you don't want to troubleshoot the guts of one tool, and it's cheap to try the other, why not
12:07:45 <juri_> they should suck less. i have things to do other than fight cabal/stack bugs.
12:08:05 <maerwald> yep, I use stack too sometimes... but recently I discovered it has odd behavior wrt git repositories 
12:08:08 <geekosaur> you willhave no choice but stack ghci in that case; plain ghci will not work at all
12:08:16 <sm[m]> it's pretty sad that even with the expertise in here we're all guessing and failing. Though, mainly that's because we're in the dark
12:09:19 <juri_> sm[m]: the program i'm working on is free software. you could look at my Makefile. :)
12:09:57 <sm[m]> juri_: you could share all the relevant details, like I hinted a while back. But only if you want to make us feel less useless :)
12:10:35 <sm[m]> steps to reproduce, basically
12:10:50 <sm[m]> easier said than done, I suppose
12:11:01 <juri_> sm[m]: I'm not sure what details are relevant, however. the logs don't look useful, the .ghc and .cabal are gone, and i have a makefile i run 'make' on, and just start ghci afterward.
12:11:31 <juri_> I mean, i copied and pasted the cabal log, and it had not a useful thing in it. YOU were helpful, the tools weren't.
12:12:49 <juri_> it's clear this is aan issue in cabal itsself tho, so no pressure from me to figgure it out.
12:12:55 <maerwald> large parts of the tools are ad-hoc implementation defined behavior
12:13:22 <maerwald> especially in open source, ppl don't make grand plans about user experience
12:13:26 <maerwald> it's about features
12:13:56 <juri_> I'm just as bad as the rest of them, so.. *shrugs*
12:25:55 <chreekat[m]> Is there a way to pull the Request out of a servant-defined endpoint? That is, I'm using servant-client, and given some API, rather than making a request against a given endpoint, I want to get a hold of the Network.HTTP.Client.Request that it presumably generates for it at some point
12:29:25 <chreekat[m]> Ah, Servant.Links might be what I'm looking for
12:42:50 * hackage uniqueness-periods-vector-examples 0.3.1.0 - Examples of usage for the uniqueness-periods-vector series of packages  https://hackage.haskell.org/package/uniqueness-periods-vector-examples-0.3.1.0 (OleksandrZhabenko)
12:43:21 <monochrom> "fresh start" is easier said than done unless you know really undocumented obscure trivia. Most people don't know that they haven't done a fresh start at all.
12:43:35 <monochrom> For example if your ghc comes from debian or ubuntu:
12:43:50 * hackage uuagc-cabal 1.2.0.0 - Cabal plugin for UUAGC  https://hackage.haskell.org/package/uuagc-cabal-1.2.0.0 (JeroenBransen)
12:43:56 <monochrom> The package database is in /var/lib/ghc*, not in /usr/lib/ghc*
12:44:33 <monochrom> I haven't tried but I wouldn't be surprised if "apt remove ghc" would not erase that. "apt purge ghc" may have a better chance.
12:44:50 * hackage uuagc-diagrams 0.1.2.0 - Utility for drawing attribute grammar pictures with the diagrams package  https://hackage.haskell.org/package/uuagc-diagrams-0.1.2.0 (JeroenBransen)
12:46:19 * hackage uuagc 0.9.53 - Attribute Grammar System of Universiteit Utrecht  https://hackage.haskell.org/package/uuagc-0.9.53 (JeroenBransen)
12:56:54 <tomsmeding> is there a nicer way to write this? \f -> maybe (Just Nothing) (fmap Just . f)
12:57:26 <tomsmeding> not necessarily looking for a more point-free form (e.g. explicitly needing the Maybe argument is fine), but perhaps not using 'maybe' explicitly?
12:57:57 <tomsmeding> what it's doing, is modifying an optional field while collecting errors in the Maybe monad
12:58:57 <chreekat[m]> using two layers of Maybe makes me go cross-eyed -- try adding a fresh type
12:59:46 <Uniaika> two layers of maybe can be replaced with an Either whose Left type can be a sum type that represent the meaning of each Nothing
13:00:41 <tomsmeding> let me replace one of the two with an Either and see if I can make more intuitive sense of it that way :p
13:01:14 <ski> tomsmeding : `traverse' ?
13:01:24 <tomsmeding> that is likely the right direction
13:01:34 <tomsmeding> yes
13:01:36 <tomsmeding> thank you
13:01:38 <dolio> Yeah, is this traverse?
13:01:44 <tomsmeding> this is traverse f
13:01:50 * hackage libjwt-typed 0.1 - A Haskell implementation of JSON Web Token (JWT)  https://hackage.haskell.org/package/libjwt-typed-0.1 (rzeznik)
13:01:59 <tomsmeding> I suffer from severe under-usage of 'traverse'
13:02:16 <Rembane> sed 's/mapM/traverse/g'
13:02:22 <Rembane> ...is a good start
13:02:31 <tomsmeding> perhaps this example will inspire me to stop thinking of traverse as (sequence . map)
13:02:45 <ski> @type \f -> maybe (pure Nothing) (fmap Just . f)
13:02:47 <lambdabot> Applicative f => (a1 -> f a2) -> Maybe a1 -> f (Maybe a2)
13:03:48 <tomsmeding> ... which is precisely traverse, with Maybe as the Traversable :)
13:04:22 <ski> yes, that's how i figured it out :)
13:04:27 <tomsmeding> thanks
13:11:25 <hekkaidekapus> juri_: 1) cabal build 'hslice:lib:hslice' --write-ghc-environment-files=always
13:11:54 <hekkaidekapus> 2) ghci -package-env .ghc.environment.x86_64-linux-8.10.2
13:12:21 <hekkaidekapus> (Assuming you want ghci at all costs).
13:12:51 <merijn> ghci should pick up environment files automatically
13:13:10 <hekkaidekapus> Ooops‚Ä¶ 1) cabal build 'hslice:lib:hslice' --write-ghc-environment-files=always
13:13:10 <merijn> So all you need is "--write-ghc-environment-files=always"
13:13:24 <merijn> Which I basically just set in ~/.cabal/config
13:13:59 <hekkaidekapus> merijn: Race condition :p
13:14:14 <ezzieyguywuf> So let's say you have three co-planar vertices in the shape of a triangle. Let's say that now you add three edges, one between each set of vertices. Next, you want to turn this "loop" into a "face" ‚Üí which of these do you think is the most intuitive? (1) provide two consecutive vertices to the makeFace function, (2) provide two consecutive Edges to the makeFace function, (3) provide all Edges in 
13:14:20 <ezzieyguywuf> the Loop to the "makeFace" function
13:14:31 <ezzieyguywuf> and this is vaguely related to haskell b/c I'm writing it in Haskell :)
13:15:06 <tomsmeding> does makeFace know about the triangle already, or are these two vertices or edges all the information that it gets
13:16:49 <ezzieyguywuf> tomsmeding: makeFace knows about the three vertices and the three edges - the information it is given is used to determine _which_ ones form the face, so it's something like `makeFace :: Vertex -> Edge -> TopoState (Maybe Face)`, returning nothing if there isn't a closed-loop defined by the given arguments
13:16:49 <ski> (1) doesn't seem to determine the triangle
13:17:10 <ezzieyguywuf> ski: it is implicit based on the adjacency information that makeFace already knows about
13:17:14 <tomsmeding> a vertex and an edge don't determine a triangle
13:17:20 <tomsmeding> ah
13:17:22 <ezzieyguywuf> tomsmeding: see above.
13:17:32 <ski> what if those two vertices also belong to a different triangle ?
13:18:05 <ezzieyguywuf> ski: then makeFace returns `TopoState Nothing`, or the pre-existing Face
13:18:08 <ezzieyguywuf> (haven't decided yet)
13:18:12 <tomsmeding> I'd say provide all three vertices, but indeed it depends on what is the smallest amount of information that _certainly_ identifies the triangle
13:18:22 <ski> how about other polygonal faces ?
13:18:22 <ezzieyguywuf> well, it's not always a triangle
13:18:26 <tomsmeding> can't you have four vertices in a diamond shape that span two triangles?
13:18:32 <ezzieyguywuf> any closed loop could be turned into a Face
13:18:53 <ski> are edges and faces oriented ?
13:19:35 <ezzieyguywuf> but given any two consecutive vertices, or adjacent Edge‚ÜíVertex pair, it's possible to "trace" the loop back to he starting point. i.e. "V1 ‚Üí E1‚Üí ...VN‚ÜíEN...‚ÜíV1"
13:19:38 <ezzieyguywuf> ski: yes.
13:19:47 <ezzieyguywuf> well faces are
13:20:37 <tomsmeding> is it possible to uniquely trace back the loop? can you add v1 v2 v3 v4, edges 1-2-3-1 and 2-3-4-2, and then make two triangles out of that
13:20:58 <tomsmeding> because if you can't, then you seem to suggest that one vertex is already enough to identify the face
13:21:25 <ezzieyguywuf> tomsmeding: Edge is defined so that it can only ever have two Vertices adjacent to it, and the API enforces that there is only ever one Edge between any pair of Vertex
13:21:41 <tomsmeding> okay sure
13:22:17 <ezzieyguywuf> so in you're exampl, the only "loop" is 1-2-3-1, because the "4-2" edge is just dangling
13:22:57 <tomsmeding> my point is, can you do this :p https://tomsmeding.com/vang/97L5vr/Screenshot_20200915-222204.jpg
13:22:57 <ski> why ?
13:23:16 <tomsmeding> and if not, how are you preventing it
13:25:20 <ezzieyguywuf> tomsmeding: that's permissable, and in fact is used to ultimately define a solid
13:25:57 <tomsmeding> but if you can share vertices and edges among polygons, then you'd need _all_ vertices or _all_ edges to uniquely determine what face you're talking about, right?
13:26:09 <tomsmeding> because any strict subset may be shared over multiple potential polygons
13:27:41 * ski . o O ( <https://en.wikipedia.org/wiki/Tits_building> )
13:28:42 <tomsmeding> his name is and remains unfortunate
13:29:40 <maerwald> tomsmeding: any reason you're not building a static binary for pastebin-haskell?
13:29:56 <tomsmeding> any reason I should?
13:30:04 <ezzieyguywuf> lol, I already had that picture in my book, https://ibb.co/60jyCWf
13:30:09 <maerwald> then you don't need a docker container to run it
13:30:25 <tomsmeding> I don't need a docker container at all, that container is for future deployment
13:30:28 <ezzieyguywuf> tomsmeding: there's more info that's hidde behind the scenes, represented by the dots in my image
13:30:31 <tomsmeding> it's currently not actually running in a container
13:30:37 <maerwald> you have a build container and it spits out the static binary, you can deploy it anywhere
13:31:03 <maerwald> you're already half way, the Dockerfile doesn't need much adjustment
13:31:37 <tomsmeding> maerwald: as mentioned, I don't _need_ the dockerfile, that dockerfile is just for when I reorganise my VPS and put everything in docker :p
13:32:07 <maerwald> seems we're talking past each other :>
13:32:29 <ezzieyguywuf> tomsmeding: so using the system illustrated in the image I loaded, then you could indeed uniquely identify a single face given two vertices or one vertex and one Edge assuming they are adjacent to each other
13:32:41 <tomsmeding> the whole reason for me for creating a docker file is for isolation and security, not for anything else
13:32:48 <tomsmeding> the binary I can already run :)
13:33:11 <tomsmeding> ezzieyguywuf: because you're not _actually_ sharing vertices?
13:33:24 <ezzieyguywuf> tomsmeding: depends on your definition of "Vertex", but yes
13:33:26 <maerwald> tomsmeding: I've never looked at docker as a security feature, given the number of incidents and bugs
13:33:41 <tomsmeding> maerwald: there you do have a point
13:33:47 <maerwald> there are better tools to do proper sandboxing
13:33:52 <tomsmeding> though it's arguable that "with docker" is not less secure than "without docker"
13:33:54 <tomsmeding> such as?
13:34:23 <tomsmeding> ezzieyguywuf: well, in general my answer to your original question would be: the smallest set of information that uniquely identifies the face, preferring vertices over edges
13:34:30 <tomsmeding> though the latter part is debatable
13:34:39 <ezzieyguywuf> tomsmeding: in my image, say "V3" would be considered a vertex, with some geometry attached to it. The three dots inside V3 (L7, L8, ad the un-named L) are "links", and are used to keep track of the relationships between pieces
13:34:46 <ski> ezzieyguywuf : hm, so you're gluing together vertices, when you combine faces. do you also glue together edges, then ?
13:34:57 <ezzieyguywuf> tomsmeding: :) that does answer my original question, thank you.
13:36:05 <ezzieyguywuf> ski: the vertex is the glue to everything. In the image I uploaded, that weirdly shaped "e5" finishes the face-loop so that what's being illustrated is in fact a tetra-watchamacallit (4-sided solid where all faces are triangles)
13:36:19 <ski> ezzieyguywuf : i might go for the smallest symmetric piece of information, perhaps, if there's no single smallest choice
13:36:48 <tomsmeding> simplex?
13:36:48 <maerwald> tomsmeding: https://github.com/containers/bubblewrap
13:36:59 * tomsmeding agrees with ski
13:37:00 <ski> ezzieyguywuf : tetrahedron. also 3-simplex
13:37:02 <ezzieyguywuf> yea, I'm kind of waffling between "Vertex -> Vertex" and "Vertex -> Edge", or even something like `makeRay :: Vertex -> Edge > Maybe Ray`, and `makeFace :: Ray -> Face`
13:37:48 <tomsmeding> I'd go for Vertex/Vertex I guess
13:38:20 <tomsmeding> from the assumption that the two adjacent vertices of an edge are more easily queryable than the edges incident to a vertex
13:38:48 <ezzieyguywuf> tomsmeding: walk me through that assumption, will you? I don't exactly follow.
13:39:05 <ezzieyguywuf> ah nvm I get it
13:39:32 <tomsmeding> which is easier, constructing (vertex,vertex) from (vertex,edge) or the other way round?
13:39:47 * ski idly wonders whether ezzieyguywuf's computing pushouts
13:39:47 <tomsmeding> take the one which is the most easily constructed from the other ):
13:39:54 <ezzieyguywuf> if "V1 ‚Üí E1 ‚Üí V2 ‚Üí E2", you're saying it's (probably) easier to find V1 and V2 rather than E1 and E2
13:40:00 <tomsmeding> yes
13:40:09 <ezzieyguywuf> ski: no idea what a pushout is, so no :-P
13:40:09 <tomsmeding> though that makes assumptions about your data structures :p
13:40:45 <ezzieyguywuf> tomsmeding: actually, it's an implementation detail, but getting (vertex, vertex) from (vertex, edge) is easier.
13:40:52 <ezzieyguywuf> (I think)
13:41:00 <ezzieyguywuf> computationally they're both probably equivalent
13:41:51 * ski . o O ( ‚åúV‚ÇÄ ‚§ö{E‚ÇÄ}‚Üí V‚ÇÅ ‚§ö{E‚ÇÅ}‚Üí V‚ÇÇ ‚§ö{E‚ÇÇ}‚Üí V‚ÇÄ‚åù )
13:42:45 <tomsmeding> fancy unicode
13:42:58 <ski> ezzieyguywuf : like taking two "things", noticing a common "subthing" in both, and then "glueing them together, on those two subthings"
13:44:41 <ezzieyguywuf> ski: sounds like almost exactly what I'm doing.
13:44:53 <ezzieyguywuf> very nice unicode, I'm jealous
13:45:07 <ezzieyguywuf> ‚ÇÄ ‚ÇÅ ah, I figured out subscripts
13:45:35 <ezzieyguywuf> dunno what ‚§ö is supposed to mean though
13:46:19 <ski> tail end of arrow. like `>-'
13:46:44 <ezzieyguywuf> nice! but still, don't see what it's meant to represent with the curly braces.
13:46:57 * ski . o O ( <https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#arrow-notation> )
13:47:16 <ski> well, vertices and edges are not on an equal footing
13:47:20 <tomsmeding> ezzieyguywuf: if you didn't know about subscripts, wait until you figure about ùíÉùíêùíçùíÖ ùíäùíïùíÇùíçùíäùíÑ
13:47:36 <ezzieyguywuf> 
13:47:42 <ezzieyguywuf> bold italic
13:47:50 <ezzieyguywuf> lol, that's underline, and not unicode.
13:47:58 <tomsmeding> bold italic is irc formatting, sure
13:48:08 <tomsmeding> https://tomsmeding.com/unicode#bold%20italic
13:48:14 <ski> (edges are between vertices. vertices are not between edges. ‚åúV‚ÇÄ ‚§ö{E‚ÇÄ}‚Üí V‚ÇÅ‚åù meant just that the edge ‚åúE‚ÇÄ‚åù connects vertex ‚åúV‚ÇÄ‚åù to vertex ‚åúV‚ÇÅ‚åù)
13:48:50 <ezzieyguywuf> ski: ah hah, I see
13:49:02 <ezzieyguywuf> however it can ultimately connect the two vertices in either or both directions
13:49:41 <ezzieyguywuf> i.e. in my image, E‚ÇÄ (hehe, subscript) connects from V‚ÇÇ to V‚ÇÄ and vice-versa as well.
13:49:46 <ski> so the direction doesn't matter for you
13:50:00 <ski> (but, for some reason, orientation of faces still matter, yes ?)
13:50:19 * hackage gitlab-haskell 0.2.3 - A Haskell library for the GitLab web API  https://hackage.haskell.org/package/gitlab-haskell-0.2.3 (RobStewart)
13:50:40 <ezzieyguywuf> well, in this example, "makeFace V‚ÇÇ E‚ÇÄ" would create a different face than "makeFace V‚ÇÄ E‚ÇÄ", since they identify different loops of edges
13:52:06 <ezzieyguywuf> if you loop closely at my image (easier to see with V3), any end-point on an Edge only ever has a single "next" end-point (I call these end-points "links"). so that's how we can get all the info we need from a single vertex/edge pair, or indeed a pair of sequential vertices
13:53:25 <ski> mhm
13:53:46 <ski> could we then say that the edges are really pairs of edges, belonging to different faces, then ?
13:54:00 <ski> (just like those vertices are really triplets, in your example)
13:54:12 <tomsmeding> maerwald: I like bubblewrap, thanks
13:54:17 <ezzieyguywuf> hm, let me ponder that.
13:54:45 <ezzieyguywuf> ski: yes, I think you could say that edges are pairs of edges belonging to different faces.
13:54:52 <ski> (perhaps even pairs of edges, with opposite orientation/direction)
13:55:14 <ezzieyguywuf> ski: regarding vertices, probably not, because ultimately a Vertex may have more than 3 Links (consider the apex of a square-based pyramid)
13:55:44 <ezzieyguywuf> üòÆ lol now my head is starting to hurt.
13:55:45 <ski> (and if you'd glue together polyhedra so as to make a polychoron, would the faces that you glue together, from different polyhedra, have opposite orientation ?)
13:56:00 <ezzieyguywuf> ski: the faces you glue together would have to dissapear
13:56:08 <ezzieyguywuf> in my model - because they do not bound the solid
13:56:15 <ezzieyguywuf> i.e. Boundary Representation.
13:56:17 <ski> why don't the edges that you glue together disappear ?
13:56:35 <ezzieyguywuf> hah, this guy gets it https://pages.mtu.edu/~shene/COURSES/cs3621/NOTES/model/b-rep.html
13:56:35 <tomsmeding> presumably because a face must be a subset of a plane
13:56:41 <ski> "ultimately a Vertex may have more than 3 Links" -- of course
13:57:07 <ezzieyguywuf> ski: the Edges don't dissapear because they are used to describe the Face, as tomsmeding pointed out.
13:57:36 <ski> and the faces would be used to describe the polyhedra that make up the polychoron, no ?
13:57:47 <ezzieyguywuf> ....yes I think so.
13:58:07 * tomsmeding slips out to go to sleep
13:58:14 <ezzieyguywuf> in teh same way that a chain of Edges describe a Face, a chain of Faces describes a Solid
13:58:23 <ezzieyguywuf> yea I need to go cook - I appreciate the conversation you two!
13:58:27 <ezzieyguywuf> tomsmeding: ski: ^
13:58:36 * tomsmeding :)
13:59:04 <ezzieyguywuf> (I'm going te go with Vertex -> Edge üòÇ)
13:59:14 <ski> ezzieyguywuf : have fun :)
13:59:26 <TheMule> exit
13:59:29 <TheMule> \exi
13:59:43 <ski> (although, i think it's not necessarily best to think of it as a chain of faces)
14:00:11 <ezzieyguywuf> ski: thanks!
14:05:51 <gentauro> I guess if people keep voting I'll be part of the 1% :) https://twitter.com/taylorfausak/status/1304534936192520194
14:06:04 <gentauro> xD
14:09:02 <monochrom> heh
14:19:27 <gentauro> oh, I just realized the survery ended :(
14:19:33 <gentauro> no 1% for me :'(
14:20:14 <monochrom> Is <3% good enough? :)
14:21:02 <MarcelineVQ> error: no error
14:21:32 <gentauro> monochrom: I guess, but it would have been nice to be the 1% at lest at something :)
14:22:46 <juri_> hekkaidekapus: thanks. :)
14:22:46 <int-e> lambdabot still uses SafeHaskell, though it's also sandboxed
14:24:17 <int-e> now... if we were to count all the lambdabot users ;-)
14:24:41 <int-e> > fix error -- is this safe?
14:24:43 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
14:29:30 <hekkaidekapus> juri_: You‚Äôre welcome. Now, you‚Äôve got another issue (proper Haskell one, no tooling related) with `:load Graphics/Slicer.hs`: Control.Monad.State is visible from many modules.
14:31:22 <gentauro> int-e: but not all people using `lambdabot` knows is uses `Safe Haskell`
14:31:37 <gentauro> is like most people driving cars don't know anything about an engine
14:31:40 <int-e> gentauro: Obviously :)
14:32:21 <int-e> I wonder how fair it is to claim that SafeHaskell was invented for lambdabot.
14:33:31 <int-e> @let import System.IO.Unsafe
14:33:33 <lambdabot>  .L.hs:145:1: error:
14:33:33 <lambdabot>      System.IO.Unsafe: Can't be safely imported!
14:33:34 <lambdabot>      The module itself isn't safe.
14:35:34 <int-e> I'm really surprised about the reply that said that Safe Haskell is very important.
14:36:34 <gentauro> int-e: I'm not
14:37:09 <gentauro> but I'm also one of the crazy ones that tries to "push" Safe Haskell to a wider audience ;)
14:37:25 <gentauro> int-e: https://uniprocess.org/effects.html
14:37:44 <juri_> gentauro: i'm sold. too bad so many of the parallelization tools don't work with it.
14:37:51 <monochrom> int-e, I wonder if it's sarcasm. The message was way too short.
14:37:57 <dolio> Wasn't safe Haskell proposed by Marlow or something?
14:38:07 <gentauro> juri_: I really dislike that `Data.Text` isn't Safe
14:38:07 <dolio> Does he use lambdabot?
14:38:18 <gentauro> that means that I have to write a lot of libs on my own :(
14:38:47 <gentauro> dolio: [Safe {H}askel]: (David Terei, David Mazi√®res, Simon Marlow, Simon Peyton Jones) Haskell ‚Äô12: Proceedings of the Fifth ACM SIGPLAN Symposium on Haskell, Copenhagen, Denmark, ACM, 2012
14:38:57 <gentauro> the two Simons and the two Davids
14:39:01 <gentauro> and in CPH :)
14:39:25 <hekkaidekapus> % :show language
14:39:25 <yahb> hekkaidekapus: base language is: Haskell2010; with the following modifiers:; -XBangPatterns; -XNoCUSKs; -XConstrainedClassMethods; -XConstraintKinds; -XDataKinds; -XNoDatatypeContexts; -XDefaultSignatures; -XDeriveAnyClass; -XDeriveDataTypeable; -XDeriveFoldable; -XDeriveFunctor; -XDeriveGeneric; -XDeriveLift; -XDeriveTraversable; -XDerivingStrategies; -XDerivingVia; -XDisambiguateRecordFields; 
14:39:45 <juri_> gentauro: control.parallel.strategies is the one that gets to me.
14:40:37 <hekkaidekapus> int-e: Do you also maintain yahb?
14:41:18 <gentauro> juri_: well it gives sense -> https://hackage.haskell.org/package/parallel-3.2.2.0/docs/src/Control.Parallel.Strategies.html#runEval
14:41:21 <hekkaidekapus> Ah, mniip does. Sorry for the moot question.
14:42:28 <gentauro> juri_: if you `hide` effects under the type system, the code can never be Safe
14:42:49 * hackage lti13 0.1.1.0 - Core functionality for LTI 1.3.  https://hackage.haskell.org/package/lti13-0.1.1.0 (jade)
14:43:49 * hackage yesod-auth-lti13 0.1.1.0 - A yesod-auth plugin for LTI 1.3  https://hackage.haskell.org/package/yesod-auth-lti13-0.1.1.0 (jade)
14:43:50 <int-e> hekkaidekapus: no... but I know it allows IO and is reliant on sandboxing
14:44:35 <int-e> hekkaidekapus: mniip is responsible for that one
14:44:50 <hekkaidekapus> What is the sandbox? Containers?
14:45:30 <int-e> I don't know details.
14:45:52 <hekkaidekapus> Ok.
14:47:31 <gentauro> int-e: is lambdabot `interpreted` or `compiled`?
14:47:45 <gentauro> int-e: I have some issues with GHCi and Safe Haskell
14:48:47 <int-e> I should know this... I'm pretty sure mueval is interpreted just like ghci is.
14:49:29 <int-e> (via hint, which to a large extent mimics ghci)
14:50:15 <gentauro> int-e: roger that
14:53:52 <seanvert> is there any problem in changing the resolver ghc version when building packages from source?
14:54:34 <seanvert> I compiled xmonad, xmobar and xmonad-contrib using lts 16.13
14:56:45 <seanvert> oh I'm using stack
15:00:40 <int-e> gentauro: Which ghc version? There's an issue where ghci fails when invoked with -XSafe, which was fixed in ghc 8.8.
15:01:00 <sm[m]> seanvert: if it builds, it's probably just fine
15:02:57 <int-e> gentauro: other than that I don't really recall having any issues with ghci and SafeHaskell.
15:07:00 <gentauro> int-e: it might have to do with `stack` and my `cabal` file
15:12:03 <int-e> gentauro: good luck unwrapping the layers of that onion :P
15:38:51 <gentauro> int-e: how about no :D
16:20:49 * hackage serverless-haskell 0.12.2 - Deploying Haskell code onto AWS Lambda using Serverless  https://hackage.haskell.org/package/serverless-haskell-0.12.2 (AlexeyKotlyarov)
16:48:31 <ezzieyguywuf> ski: (you're right, a chain of faces is probbaly the wrong way to think of it, but I was just trying to draw the analogy)
17:03:49 * hackage ipfs 1.1.3.1 - Access IPFS locally and remotely  https://hackage.haskell.org/package/ipfs-1.1.3.1 (expede)
18:01:26 <ezzieyguywuf> if I have x1, x2 and a list [x], is there something similar to `compare` that will tell me if one, or the other, or both of x1 and x2 are in [x]?
18:02:32 <Axman6> > [1] `intersect` [1,3]
18:02:35 <lambdabot>  [1]
18:03:19 <Axman6> > let hasOneORThree xs = not . null $ xs `intersect` [1,3] in hasOneOrThree [2,5,6,3]
18:03:22 <lambdabot>  error:
18:03:22 <lambdabot>      ‚Ä¢ Variable not in scope: hasOneOrThree :: [a0] -> t
18:03:22 <lambdabot>      ‚Ä¢ Perhaps you meant ‚ÄòhasOneORThree‚Äô (line 1)
18:03:31 <Axman6> > let hasOneOrThree xs = not . null $ xs `intersect` [1,3] in hasOneOrThree [2,5,6,3]
18:03:34 <lambdabot>  True
18:04:01 <ezzieyguywuf> ah hah, yes I think intersect is what I want thank you.
18:13:12 <ezzieyguywuf> is `ExceptT . pure $ Right someValue` somehow redundant? I've searched through the docs for Control.Monad.Except and don't see anything that does this, i.e. `Either e a -> ExceptT e m a`
18:15:44 <MarcelineVQ> https://hackage.haskell.org/package/transformers-0.5.6.2/docs/Control-Monad-Trans-Except.html#v:except
18:16:50 <ezzieyguywuf> MarcelineVQ: ah hah!
18:17:09 <MarcelineVQ> but not really no, ExceptT is how you construct ExceptT's, so  ExceptT . pure  seems fine to me
18:17:11 <ezzieyguywuf> but you know, this confuses me, because I've imported Control.Monad.Except, and nothing from Control.Monad.Trans.Except
18:18:36 <MarcelineVQ> mtl reuses definitions from transformers
18:19:43 <ezzieyguywuf> but it doesn't re-export them?
18:20:25 <ezzieyguywuf> it's just confusing to me, I found myself `import Control.Monad.Trans.Class (lift)` for things from mtl
18:21:56 <MarcelineVQ> it does rexport the ExceptT type and some methods, but not neccesarily everything ExcepT provides. iiuc  mtl is for adding the   MonadError   MonadReader   MonadState  etc   on top of these sort of transformers
18:22:18 <ezzieyguywuf> iiuc?
18:22:42 <MarcelineVQ> if I understand correctly
18:22:51 <ezzieyguywuf> ah
18:30:07 <ezzieyguywuf> üòç I love these colors, lol. https://vimcolorschemes.com/
18:30:21 <ezzieyguywuf> whoops, https://i.imgur.com/xO0PAd0.png
18:30:40 <ezzieyguywuf> (this is vaguely haskell-related b/c the screenshot shows haskell source)
18:36:19 * hackage ipfs 1.1.4.0 - Access IPFS locally and remotely  https://hackage.haskell.org/package/ipfs-1.1.4.0 (expede)
18:58:20 * hackage cmark-gfm 0.2.2 - Fast, accurate GitHub Flavored Markdown parser and renderer  https://hackage.haskell.org/package/cmark-gfm-0.2.2 (kivikakk)
19:30:20 * hackage ipfs 1.1.5.0 - Access IPFS locally and remotely  https://hackage.haskell.org/package/ipfs-1.1.5.0 (expede)
19:57:41 <ethbrook> @search photoshop
19:57:42 <lambdabot> Unknown command, try @list
19:57:46 <ethbrook> @list
19:57:47 <lambdabot> What module?  Try @listmodules for some ideas.
19:57:58 <Axman6> you're in the wrong place ethbrook
19:58:10 <ethbrook> k, ty
20:54:37 <hololeap> is something like this possible? import Prelude hiding (module Data.Foldable)
21:01:31 <koz_> hololeap: Prelude doesn't re-export Data.Foldable.
21:01:49 * koz_ knows because he constantly has to do 'import Data.Foldable (traverse_, fold)'
21:02:42 <hololeap> i see... i knew that already, now that you mention it
21:03:31 <koz_> Although technically, I can use mapM_, but traverse does everything.
21:39:33 <edwardk> koz_: that makes me sad every time i have to do it, but its hard to add names to the prelude
