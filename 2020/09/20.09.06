00:03:58 <antaoiseach> Hello guys, interested in writing compilers. Have an honest question (no baiting) about using OCaml vs Haskell. I have written basic toy compilers in imperative style (at the prototypical maths expressions example level). I have a few weeks where I want to focus on learning the domain well, at least a strong foundation. I have a few questions about the viability of OCaml vs Haskell (vs Idris as a 
00:04:04 <antaoiseach> bonuse) for writing compilers specifically. I'm new to OCaml as well as Idris, but a beginner-low intermediate in Haskell. I think it would be more helpful if people who have experimented with both OCaml and Haskell could give a brief summary of their experiences. That may help me choose more than anything else. Any ideas?
00:05:08 <antaoiseach> Secondly, I am interested in ultimately using LLVM as a backend (to start with, at a serious level) and I've seen the OCaml tutorial on llvm.org. I also found llvm-hs as a comparable bindings library. Anyone have experiences with either or both who say something about their experiences?
00:07:25 <antaoiseach> I found the OCaml code easy to read, but am worried if I'll be losing in terms of expressive power and abstractions if I choose it over Haskell. At the same time, I've read about compilation speed differences, with the Elm parser being shown as an exception. However, that code seems (not sure) to use quite a bit of unsafe code... if so, is this necessary, ot can a performant compiler (in terms of 
00:07:31 <antaoiseach> compilation speed, of course) be written sans unsafe?
00:08:43 <antaoiseach> I'm also factoring in impact on career in terms of learning as well. Haskell's market share seems much higher than OCaml's, and while I'd maybe like to go even higher up the abstractions ladder with Idris, it's still immature, has an almost non-existent community/ecosystem and no industry presence.
00:09:38 <antaoiseach> I know I'm considering too many things at the same time, but a lot of factors are weighing in on me and I wanted to get the best ROI on my time and effort. Sorry if that confuses the main intent of the question. It's literally troubling my sleep! :D ... 
00:18:33 <dsal> How fast your compiler might be is probably not the first thing to consider at this stage.  How fast can you write a fairly correct implementation of it, and how easy is it to work on?  IME, Haskell wins for these things.
00:19:27 <dsal> I've not written any ocaml in many years, though.  Haskell feels like easy mode most of the time.
00:21:19 <antaoiseach> dsal: Thank you for the response! I agree that correctness trumps performance, at least to start with.
00:22:19 <antaoiseach> That being said, how much effort do you imagine it would be to take a base implementation and tweak it for performance. I'm sorry, I'm just a beginner-intermediate in Haskell (maybe beginner is more appropriate)
00:23:23 <antaoiseach> I apologise if that appears weird and intrusive, but I ask because I'm thinking on long-term commitment and my head's in all sorts of places right now 
00:28:19 <koz_> antaoiseach: 'Performance' is a meaningless term.
00:28:28 <koz_> In terms of what? Relative what? To what end?
00:28:37 <koz_> Until you can answer those questions, it's a totally moot point.
00:28:41 <koz_> And you're not there yet. :P
00:31:28 <antaoiseach> koz_: I mean, as an example, compiling the Idris 1 codebase (written in Haskell) too a ridiculously long time. It's anecdotal, of course, but that was a full-fledged project. As I said, I'm thinking longterm, so I was wondering if there are some examples (maybe apart from Elm) which have excellent compilation speed, and are written in Haskell?
00:31:42 <antaoiseach> Google doesn't seem very cooperative in this regard
00:31:56 <koz_> antaoiseach: Because it's an extremely vague question.
00:32:14 <koz_> You're asking 'how long does it take to compile a compiler implementation with a non-trivial feature set?'.
00:32:23 <koz_> The correct response is 'try compiling LLVM some time'.
00:32:27 <dsal> How long does it take to compile an idris codebase using a compiler written in ocaml?
00:32:33 <koz_> 'And then remind yourself that this is _only_ the backend'.
00:32:53 <koz_> The answer is 'a damn long time, because compilers are hard even _before_ you talk about ergonomics'.
00:32:58 <antaoiseach> dsal: It's not feature-complete yet, but Idris2 written in Idris seems much much faster
00:33:05 <koz_> Said ergonomics require considerable code pathways.
00:33:32 <koz_> (I speak from some experience, as I got paid to work on a compiler for a DSL, and also a schema language)
00:33:35 <antaoiseach> koz_: No, I mean, I know that C++ has a problem with compilation speeds
00:33:48 <dsal> Most of the time, I just write the program I want and then decide if it's fast enough. Most of the time, it is.  If it's not, it's super easy to refactor Haskell.
00:34:03 <koz_> It's not an issue of C++ or what have you. It certainly doesn't help, but a compiler, especially one with a lot of features and good ergonomics, will be large no matter what you write it in.
00:34:11 <koz_> And it will take time to compile, no matter what you write it in.
00:34:13 <antaoiseach> dsal: Yes, that was what I was more interested in - being able to refactor for speed.
00:34:19 <maerwald> dsal: depends. In general yes. If you need to refactor *effects*, then no
00:34:45 <maerwald> and refactoring for speed may involve redoing your effects
00:35:01 <koz_> Plus, are you asking about the speed of compiling the compiler, or using the compiler to compile programs?
00:35:08 <koz_> I'm a bit confused, because you seem to alternate between both.
00:35:25 <antaoiseach> koz_: Purely about the compilation speed
00:35:40 <koz_> antaoiseach: Compilation speed of what? The compiler's codebase, or code _using_ the compiler?
00:36:03 <dsal> Tonight's project was to make my GoPro multipart media updates resumable, which does combine a couple effects.   It's not beautiful, but it wasn't too invasive.
00:36:24 <antaoiseach> koz_: Of the source language. Suppose I write a Java compiler in Haskell, how fast would it be able to compile projects written in Java, say.
00:36:40 <koz_> antaoiseach: That depends more on the language being compiled and what analysis you do that implementation language.
00:36:52 <antaoiseach> maerwald: Ah, interesting.
00:36:54 <koz_> If you're writing a Forth compiler, it'll be _very_ fast, because you've got next-to-no analysis to do.
00:37:30 <koz_> If you're writing an _optimizing_ compiler for, say, a language with a complex type system? You're gonna spend a _lot_ of time in analysis passes, no matter what you write it in.
00:37:34 <antaoiseach> koz_: I mean, assuming almost zero optimisations, and leaving all that to LLVM
00:37:38 <dsal> Your question sounds a bit like "how long is a string?"
00:37:48 <koz_> dsal: This is the point I am trying to get to. :P
00:38:19 <maerwald> dsal: that's a reasonable question, actually
00:38:33 <antaoiseach> dsal: That makes no sense to me. I mean, D's compiler is superfast because it does very few optimisations. 
00:38:33 <maerwald> because it could mean bytes, graphemes or something else
00:38:36 <koz_> Even setting this aside (and this will be part of your compilation time anyway, so I don't see why you'd think that), analysis passes are not about optimization.
00:38:40 <koz_> Even type checking stuff is hard.
00:38:45 <dsal> It's not a complete question.
00:38:47 <koz_> Especially if you want a type system with actual features.
00:39:15 <koz_> I still believe firmly that the language semantics, and your compiler's features and ergonomics, will affect its compile times _far_ more than choice of implementation language.
00:39:27 <koz_> Especially considering Haskell's AOT compiled, assuming you're using GHC.
00:39:55 <koz_> Again - if your language is Forth, then it'll be fast, because your analysis passes amount to 'lol'.
00:39:59 <dsal> "will the program I write be fast enough?" Needs a lot of inputs to answer it.
00:40:21 <koz_> If your language is the-next-Idris or what-have-you, congratulations, all those fancy type system features require work.
00:40:36 <koz_> And that's _before_ we get to 'good error reporting is hard and takes a lot of code paths'.
00:41:20 <koz_> So basically, being concerned about this sort of thing is rather premature, because as dsal has pointed out, you're missing like, 90% of the necessary information to answer the question.
00:41:33 <koz_> Or rather, _we_ are missing 90% of the necessary information to answer the question.
00:41:34 <dsal> I just always start with the dumbest thing that solves my problem. Then I usually just move on to the next problem.
00:41:50 <koz_> dsal: And that presumes you actually know your problem already.
00:42:01 <koz_> Oftentimes, you have to revise your perception of your problem.
00:42:04 <koz_> Many times. :P
00:42:07 <antaoiseach> I mean, all this makes no sense to me. I could write a compiler in Python, and that would be orders of magnitude slower than Haskell for the same project - for actually compiling the code. That 
00:42:08 <dsal> Heh.  Sometimes I know a little about it.
00:42:12 <antaoiseach> is just what I'm asking. 
00:42:25 <antaoiseach> I don't understand all the hostility :|
00:42:33 <koz_> antaoiseach: You're comparing an interpreted dynalang to an AOT compiler with heavy amounts of optimization.
00:42:46 <antaoiseach> Sigh
00:42:51 <maerwald> performance issues (runtime) are one of the reasons haskell consultint companies exist :)
00:43:04 <maerwald> https://www.tweag.io/blog/2020-01-30-haskell-profiling/
00:43:11 <koz_> There's no (intended) hostility. It's merely that the question is too vague to answer.
00:43:12 <antaoiseach> Anyway, thank you all for your inputs. It's been an interesting conversation. Cheers
00:43:19 <antaoiseach> and thanks maerwald - genuinely
00:44:56 * koz_ shrugs.
00:46:19 <maerwald> compilation speed is a problem in haskell... I belive there was a blog post explaining where GHC wastes most time in, but I can't find it
00:46:40 <koz_> maerwald: Yeah, but that wasn't the question.
00:46:47 <koz_> (not by a country mile)
00:47:14 <maerwald> Was there any concrete question? :)
00:47:23 <koz_> maerwald: A different issue.
00:48:52 <lordgrenville> Hi, can anyone give me a hint with this (short, incorrect) code: https://pastebin.com/biMu2v3Q trying to recursively building a string while pattern matching, but the Either type is a bit confusing for me
00:49:18 <koz_> lordgrenville: What's toRNA meant to do?
00:49:18 <maerwald> hehe
00:49:45 <lordgrenville> koz_ transcrive dna string to rna, so each G becomes C, etc
00:49:51 <maerwald> :t (>>=) -- lordgrenville 
00:49:52 <lordgrenville> transcribe*
00:49:53 <lambdabot> Monad m => m a -> (a -> m b) -> m b
00:50:02 <koz_> lordgrenville: So is it just a substitution?
00:50:06 <lordgrenville> yes
00:50:11 <koz_> Why is it giving back an Either then?
00:50:17 <koz_> It seems it's just String -> String, no?
00:50:31 <lordgrenville> but if it encounters an invalid char (eg 'X', it returns just that char, instead of a string
00:50:36 <koz_> OK.
00:50:36 <lordgrenville> hence the either
00:50:56 <koz_> So let's consider what has to happen.
00:51:11 <lordgrenville> (it's from the website "exercism", one of the early haskell questions)
00:51:15 <koz_> If you see a G as the first character, you _first_ have to convert the rest, right?
00:51:19 <lordgrenville> (they define the types)
00:51:27 <koz_> After you convert the rest, there's two possibilities.
00:51:37 <koz_> Either it blew up, in which case you get back a Left.
00:51:42 <koz_> What do you do then?
00:51:53 <lordgrenville> ah, interesting
00:51:58 <lordgrenville> you want to return just the left
00:52:06 <lordgrenville> not the string you've been building
00:52:13 <koz_> And if it didn't blow up, you get a Right, with a converted string inside.
00:52:20 * hackage yaml-combinators 1.1.2 - YAML parsing combinators for improved validation and error reporting  https://hackage.haskell.org/package/yaml-combinators-1.1.2 (RomanCheplyaka)
00:52:33 <koz_> So the _first_ thing you gotta do is case-match on the result of toRNA xs.
00:52:43 <koz_> Hopefully that gives you something to go on.
00:53:11 <lordgrenville> hmm, i will think about that and tinker with it some more
00:53:14 <lordgrenville> thank you for the help!
00:53:54 <koz_> No worries - let us know if you need more help.
00:54:10 <koz_> This kind of thing comes up a lot - case match, then decide what to do next.
00:59:42 <[exa]> lordgrenville: you may want to separate the concerns a bit, like this:
00:59:54 <[exa]> > sequence [Right 'A', Right 'U']
00:59:57 <lambdabot>  Right "AU"
01:00:11 <[exa]> > sequence [Right 'A', Left 'X']
01:00:14 <lambdabot>  Left 'X'
01:02:14 <koz_> [exa]: One step at a time. Better to do it with manual pattern matching first, and then worry about that.
01:02:25 <koz_> This is quite doable just with pattern matching and recursion.
01:02:50 * hackage diohsc 0.1.1 - Gemini client  https://hackage.haskell.org/package/diohsc-0.1.1 (mbays)
01:03:09 <[exa]> koz_: still there's the patternmatch for actual bases needed
01:03:27 <koz_> Oh yeah, there's definitely multiple pattern matches needed, agreed.
01:04:22 <[exa]> at the very same time, I still believe it's better to separate concerns by default and not mix 2 different patternmatches together (suddenly 10+ possibilities instead of 5!)
01:05:24 <[exa]> so I guess that showing the middle cutting ground could help (guess that implementing some kind of `sequence` for Eithers manually can work too)
01:06:18 <koz_> [exa]: Yeah, there's better and worse ways, but sometimes, starting off with a longer method using fewer simpler techniques helps.
01:06:21 <koz_> (at least it helps me)
01:06:29 <koz_> (before I figure out that I just wanted traverse)
01:06:41 <[exa]> yeah agreed, I understand your point :]
01:06:42 <koz_> (as it usually happens)
01:06:56 <koz_> In fact, traverse would work here.
01:07:25 <[exa]> koz_: certainly...I wanted to show that the whole thing can be separated into 2 relatively easy steps
01:07:38 <[exa]> traverse does both :]
01:07:45 <koz_> traverse does everything.
01:07:54 <koz_> It is the Haskell theory-of-everything.
01:07:58 <[exa]> traversed its meaning
01:12:30 <lordgrenville> yeah I'd rather do it the dumb way first :)
01:13:48 <koz_> What're the letter translations for RNA?
01:14:12 <[exa]> lordgrenville: just wanted to point out that smashing it all into a single function may be overkill... You don't need to use the sequence from above, but doing it in steps like this (for free in Haskell b/c laziness) can help a lot: [Char] ---> [Either Char Char] ---> Either Char String
01:14:52 <[exa]> (the last one I meant to write `Either Char [Char]` for clarity but it's the same)
01:16:57 <[exa]> koz_: 'ACTG' gets changed to 'ACUG', the rest is invalid
01:17:13 <koz_> OK.
01:17:28 <[exa]> (afaik)
01:25:47 <lordgrenville> [exa] yeah that's it
01:29:08 <joyfulmantis> Does anyone know if there are any nightly binaries available for stack?
01:37:45 <Rembane> joyfulmantis: I haven't found any, what would a nightly binary solve for you? 
01:42:19 <joyfulmantis> Rembane: I live in China and need the snapshot-location-base configuration option to configure stack to use a mirror (whithout which stack is unusable here)
01:43:19 <joyfulmantis> It was merged into the main branch a month or two ago but has yet to be put into a release
01:43:30 <Rembane> joyfulmantis: Got it. Can you compile from source while you wait for it to be put into release?
01:51:17 <joyfulmantis> hmm, I probably could, but would have to compile it with cabal. I might try instead to upgrade stack to nightly on a remote server and then copy over the binaries
01:52:13 <Rembane> That sounds like a plan that could work too
02:02:01 <maerwald> who can write a Read instance without staring at the documentation for 10 minutes?
02:13:37 <tomsmeding> https://xkcd.com/1168/
02:16:47 <fendor> In a release, I forgot the bump a lower dependency version. Is it justified to use hackage revisions to correct this in post or should I rather create a new major version?
02:21:09 <arahael> tomsmeding: Ha. :)  Incidentially, 'tar -xvzf' is what I frequently use, out of habit, mind you, I probably should use 'tar -xvjf'.
02:35:59 <maerwald> that's what's wrong with unix... no consistency between commands... even --help doesn't always work
02:39:59 <siraben> Anyone know how I can recover a message if I have several 32-bit CRCs of it?
02:40:07 <siraben> For instance if I have the column of results in https://crccalc.com/
02:55:02 <tomsmeding> siraben: how long is the message? does the message contain more or less bits than all the crc's together?
02:55:13 <siraben> tomsmeding: it's 12 characters long
02:55:15 <siraben> more bits
02:55:17 <tomsmeding> brute-force :p
02:55:31 <siraben> but 36^12 = 4.73E18
02:55:39 <tomsmeding> "more bits" -> answer is no you can't recover it, there will be more messages that map to the same output
02:55:54 <siraben> yes but supposedly having many CRCs will narrow it down
02:56:20 <siraben> I found a tool to generate many hundreds of messages that have a given CRC for a specific CRC algorithm, but they don't match for the other CRCs
02:56:25 <siraben> (see the crccalc website table)
02:56:27 <tomsmeding> if the message contains 'n' more bits than all your checksums together, then on average, you'll get 2^n originals of n bits that map to the same checksums
02:56:35 <tomsmeding> oh
02:58:24 <tomsmeding> can that tool efficiently output many messages? how feasible is it to check the other CRC algorithms for all outputs from that tool run on 1 CRC algorithm?
03:01:10 <siraben> it's kind of slow, and the search space still seems very large
03:01:26 <siraben> I'm wondering if there's a mathematical way to dramatically reduce the search space
03:01:46 <tomsmeding> the lazy approach (for me) is to tell you to read https://web.archive.org/web/20110719042902/http://sar.informatik.hu-berlin.de/research/publications/SAR-PR-2006-05/SAR-PR-2006-05_.pdf
03:02:28 <siraben> oh, homomorphism property, may be useful
03:02:48 <tomsmeding> but it seems this should be quite doable
03:06:20 <tomsmeding> this (https://en.wikipedia.org/wiki/Mathematics_of_cyclic_redundancy_checks#Maths) suggests chinese remainder theorem TBH
03:09:07 <tomsmeding> using https://en.wikipedia.org/wiki/Chinese_remainder_theorem#Over_univariate_polynomial_rings_and_Euclidean_domains
03:09:19 <tomsmeding> does that help? :p
03:10:12 <tomsmeding> you'll get precisely 2^n possible input messages, where n is the number of bits that the message has more than your checksums combined
03:10:39 <tomsmeding> putting an ascii filter on that probably significantly further reduces the number of possibilities
03:13:50 * hackage composite-aeson-throw 0.1.0.0 - MonadThrow behaviour for composite-aeson.  https://hackage.haskell.org/package/composite-aeson-throw-0.1.0.0 (locallycompact)
03:14:35 <siraben> tomsmeding:  thanks, I'll take a look!
03:15:23 <tomsmeding> (still, coding that will be quite a bit of work I think)
04:21:47 <PtxDK> Is anyone here, how active is #haskell usually?
04:24:14 <TMA> PtxDK: usually somewhere between "quite" and "a lot"
04:25:33 <PtxDK> TMA: Thanks.
04:26:03 <TMA> Weekends are quieter
04:26:34 <PtxDK> makes sense, since people are not working as much in weekends.
05:20:08 <ski> maerwald : you get much of the way, with `readsPrec',`readParen',`lex' (and list comprehensions)
05:45:42 <L29Ah> https://gitlab.haskell.org/ghc/ghc/-/issues/7275#note_72738 how hard is this to do for a person who have never touched the ghc internals?
05:46:58 <L29Ah> Igloo:
05:51:26 <natpd> how do i create another instance of `Pretty Output` in a different module?
05:58:02 <maerwald> ski: maybe, but it's just bad API imo and the fact that it's such a "basic" class makes it worse
06:29:14 <tomsmeding> PtxDK: in the past 5 weeks, the average number of messages per weekday (mon ... sun) was: 1195 1068 1172 1174 955 613 722
06:29:24 <tomsmeding> that excludes lambdabot and yahb
06:58:40 <cheater> weekend is always dead here
06:58:46 <cheater> i'm surprised when it's not
07:02:11 <[exa]> btw, -std=c++20 just got approved
07:03:03 <[exa]> that might stir up some action
07:07:07 <yushyin> concepts!
07:11:43 <[exa]> hmm, what's the best way to share a mutable state between requests in scotty? In particular, a Map that will be updated by a single "worker" thread
07:16:07 <[exa]> I'd smash a TVar but I'm realizing the amount of internal requests will be bigger
07:16:47 <[exa]> s/amount/number of different types/
07:24:11 <shiraeeshi> [exa], wdym "the number of different types of internal requests will be bigger"? what will happen then?
07:25:33 <shiraeeshi> I've read "Parallel and Concurrent Programming in Haskell" recently, but I'm don't have practical experience with concurrency in haskell
07:25:56 <[exa]> I was thinking that I'd have a TVar that the thread sometimes modifies, but I actually need multiple extra assurances
07:26:30 <shiraeeshi> what kind of assurances?
07:26:43 <[exa]> like, it is going to hold N different resources, and I'd like to avoid that a resource will get destroyed when a request is served that uses it
07:27:37 <[exa]> so perhaps something like refcounting would work first
07:31:56 <shiraeeshi> afaik a TVar doesn't get destroyed when a thread that uses it terminates
07:32:29 <[exa]> yeah, the resources are not in TVars but external (need management)
08:47:37 <mlugg> I'm writing a program that uses a monad stack, and it needs to be able to do certain IO operations. Allowing unrestricted IO in my monad feels like a bit of a code smell to me; is it worth defining a custom monad based on `Free` or something which is then converted to IO by `runWhatever`? It feels logically nice but I'm not sure if it's practically
08:47:37 <mlugg> a good idea
09:07:16 <maerwald> why would that be a code smell?
09:07:52 <maerwald> you don't buy into an effects system just because you think IO smells, but because you have an actual use case
09:13:13 <mlugg> Because I don't want my stderr logging function launching missiles :p  is there any better way of doing this kind of IO type safety (i.e. contraining my error log to stdout printing & maybe getting the time)? Or should I just accept it and allow arbitrary IO?
09:14:06 <monochrom> I am against the whole notion of "code smell" altogether.
09:18:15 <[exa]> mlugg: you can wrap it in a newtype and only allow precisely regulated set of functions that are okay&checked
09:18:40 <[exa]> mlugg: OTOH just _not_ writing the liftIO is probably much better and simpler
09:19:21 <[exa]> mlugg: unless ofc the logging function is implemented by an adversary (hopefully not)
09:20:52 <mlugg> [exa], for the newtype option, do you mean not having a `MonadIO` instance for the type, but having functions (e.g. `logStderr :: Text -> MyMonad ()`) that unwrap the monad from the newtype and then liftIO the operations into that?
09:22:13 <[exa]> yeah (or alternatively just wrap the inner IO, as in `SomeT (SomeOtherT MyWrappedIO)`
09:22:38 <mlugg> Okay, that makes sense
09:22:51 <mlugg> I may do something like that
09:22:52 <[exa]> again, just forcing self to _not_ break the rules it is the best way of actually not having the code smell. :D
09:22:52 <mlugg> Thanks!
09:22:59 <mlugg> Yeah, that's fair
09:33:26 <Enrico63> Hellow theeeere
09:35:45 <dsal> Haskell is a terrible programming language.  It let me compile code that didn't do what I wanted, so my upload didn't work last night.
09:36:29 <dsal> I think I've written this same bug before.   Map.<> doesn't do what I expect, but it does a thing that made the compiler make me think it was going to.
09:37:38 <Enrico63> Anybody willing to help me with an HackerRank challenge?
09:38:03 <sshine> dsal, Data.Map has a Monoid instance??
09:38:21 <sshine> Enrico63, sure.
09:38:36 <dsal> It's a semigroup.  But it unions with such that it just throws away duplicate values.
09:38:44 <dsal> Er, values for duplicate keys.
09:39:09 <sshine> ah, Semigroup
09:39:17 <sshine> yes, it is left-biased.
09:39:34 <sshine> I didn't know that <> was defined, but I knew union was left-biased.
09:39:53 <Enrico63> Ok, but I don't really want a solution, only some feedback on my attempt
09:39:55 <sshine> I wouldn't have trusted <> for Map since there is not an unambiguous way to merge.
09:40:09 <Enrico63> The challenge is this : https://www.hackerrank.com/challenges/functional-programming-the-sums-of-powers/problem
09:40:09 <sshine> kind of like there is no <> for Num :)
09:41:02 <Enrico63> So my approach was let's first generate the firt 
09:41:11 <Enrico63> Damn. I'll rewrite
09:42:08 <Enrico63> Given X and N, I have to determine how many ways I can pick numbers from the Nth powers of the  natural numbers such that their sum is X.
09:42:35 <Enrico63> only the count, not the actual numbers to be picked
09:42:43 <sshine> I might have preferred only making Map k a Semigroup if Semigroup a.
09:43:47 <Enrico63> So my first reasoning was to compute first the list of the Nth powers that I need, which is basically `takeWhile (<= X) [i^N | i <- [1..]]`
09:44:19 <Enrico63> oh damn, let's add some space `takeWhile (<= 100 ) [i^N | i <- [1..]]`
09:44:37 <Enrico63> oh, come on: `takeWhile (<= X ) [i^N | i <- [1..]]`
09:45:01 <Enrico63> well, actually `takeWhile (<= x) [i^n | i <- [1..]]` (sorry, I'm a bit tired :P)
09:45:53 <sshine> Enrico63, could you write your thoughts in a pastebin and post them at once? :P
09:46:14 <sshine> Enrico63, pastebins are more forgiving towards going back and fixing typos.
09:46:16 <Enrico63> Yessir :P
09:46:47 <Enrico63> by pastebin you mean writing it somewhere else and then pasting here?
09:47:15 <sshine> dsal, I think maybe "Haskell is a terrible language." is a bit harsh for one design glitch in a library. :P I think there are better examples of Haskell being a terrible language, haha.
09:48:53 <maerwald> sshine: I think it's one of the more fundamental critiques though. That typeclasses are so generic, that you often don't *really* know what an instance does
09:49:28 <dsal> Heh, yeah.  I just have a slow connection and 14GB to upload.  I could've noticed this small issue last night, but my test was too small.
09:53:12 <sshine> dsal, e.g.: https://github.com/haskell-crypto/cryptonite/issues/330
09:53:42 <sshine> maerwald, as in, it is rare you can derive a meaningful, unambiguous instance for most built-in classes?
09:56:30 <sshine> dsal, you upload 14GB every time you deploy code?
09:56:33 <maerwald> sshine: Not sure. But there are cases where you can have multiple lawful instances. And even if there's only one lawful instance, sometime you just follow the types and end up with the wrong result, because you're trusting the type system too much 
09:56:52 <maerwald> (that's also a problem with lens)
09:57:07 <sshine> I don't use lenses.
09:58:54 <maerwald> Doesn't matter :p
09:59:14 <sshine> maerwald, I probably haven't written enough Haskell code. :) I've certainly had bugs that escaped the type system, but they're mostly related to typos/copy-paste-laziness, or simply me not having thought my logic through. :-P
09:59:15 <maerwald> It's an argument against abstraction. One of the very few
09:59:40 <sshine> yes, I guess your macro-processor can't be so powerful that everything is a valid expression of something.
10:00:23 <sshine> 93% of Paint Splatters are Valid Perl Programs: https://www.famicol.in/sigbovik/ ;)
10:00:42 <maerwald> I don't know. Most ppl don't encode program logic in their types.
10:00:51 <monochrom> Haha "TLDR: read the paper"
10:01:15 <Enrico63> sshine, here it is: https://gist.github.com/Aster89/986317dd8f5a53b92700be34a7e1d823
10:02:06 <maerwald> I don't write haskell, because it catches more bugs. That problem I only have in C vs haskell.
10:03:27 <dsal> sshine: I just shot a lot of video yesterday.  This is my GoPro app.  There's a special case of multi-file video that my resume code didn't support.
10:05:35 <dsal> Haskell is pretty easy, but I still sometimes tell it to do things that aren't what I want done.
10:05:50 <maerwald> that's why ppl pay you money
10:05:54 <maerwald> :p
10:06:03 <maerwald> so be thankful it isn't perfect
10:06:22 <maerwald> (any language really)
10:06:29 <dsal> Heh
10:07:35 <monochrom> I have a feeling that a perfect language, or near-perfect to be more realistic, is going to be hard to learn.
10:07:46 <maerwald> But I guess one day we may have stricter hierarchies in programming... a class of programmers creating DSLs and a class of them using those. High-level languages should be abolished
10:08:24 <maerwald> (if you think about it from an engineering perspective)
10:08:42 <monochrom> I think this has already happened.
10:08:48 <maerwald> yes, partly
10:08:57 <maerwald> daml?
10:09:45 <sshine> monochrom, so we can conclude that because Haskell is hard to learn, it must be near-perfect. ;)
10:10:04 <sshine> that's how implication works, right?
10:10:20 <monochrom> The game industry has some programmers making game engines or rendering engines, some other using those engines and write the game logic on top, some others writing Lua scripts, and ...
10:10:45 <maerwald> I'd argue that expressivity and perfection are anti-proportional
10:11:14 <maerwald> but becausue you need expressivity for various reasons, you never reach perfection
10:12:13 <monochrom> ... and graphics designers using graphics design software to make static art, animation design software to make dynamic art.  --- This requires you to open your mind and broaden your definition of DSL so that a DSL doesn't have to be textual, can be a menu system of a GUI.
10:12:23 <maerwald> one of those reasons might be: you don't even understand your domain yet (so, not even a technical reason)
10:14:12 <sshine> maerwald, arguably, why express anything if you have already experienced perfection.
10:14:29 <monochrom> sshine: My inspiration comes from this extreme: dependently typed languages allow you to express in types exactly what behaviour you expect, and there will be no surprise. And it is the hardest to learn.
10:14:33 <maerwald> but usually you don't have the time to understand your domain, because you don't even understand your customers, the market or wth you're doing at all :p
10:14:33 <sshine> "This is not the coolest language in the world. This is just a tribute."
10:14:48 <monochrom> Taking a step back, even Haskell is harder to learn than most mainstream languages.
10:15:29 <sshine> monochrom, what I find hard about dependent types is learning what is meaningful to express as types.
10:15:32 <maerwald> monochrom: yes and not just because they know imperative already (I think that argument is wrong)
10:15:41 <ph88> hey guys
10:16:02 <maerwald> sshine: yeah, the design space explodes in your face
10:16:20 <sshine> monochrom, e.g. what comes after non-empty lists in usefulness and complexity? :)
10:16:22 <ph88> i wrote this function to get me the start of the week https://bpa.st/O6HA just it's always giving me thursdays instead of mondays .. anyone know what i can do about this ??
10:16:43 <sshine> monochrom, when do value-level smart constructors come short, etc.
10:17:58 <monochrom> Clearly, declare Thursday to be the new start of a week!
10:18:13 <sshine> Thursday isn't the start of a week?
10:18:17 <monochrom> I basically did that to my course.
10:18:20 <maerwald> I think I never came up with my own typeclass in haskell. Maybe I don't understand typeclasses? I feel the main use of it is abstract concepts, not function dispatching based on types. Although it's both.
10:18:56 <davean> sshine: what is the start of the week then?
10:18:58 <maerwald> With dependent types, the design space will get more confusing
10:19:01 <davean> sshine: because people disagree :-p
10:19:02 <sshine> maerwald, I only came up with bad uses.
10:19:35 <sshine> maerwald, I think it was merijn and Athas who argued that you can have 1 type class for N thousands of lines of code by empirical study of their own codebases. :-P
10:19:40 <monochrom> My university added extra holidays so that at some point, there was a block of Monday-Wednesday holidays. So after that, "week 7" had to start from Thursday.
10:20:28 <sshine> ph88, so in one area of the world, your current code is correct!
10:20:37 <monochrom> (Reason for the holiday block: Wednesday was Canada Day, the university figured that alignment would be easier to make a block.)
10:20:41 <ph88> NICE ! where should i move sshine  ?
10:20:49 <sshine> sounds like Canada.
10:20:55 <sshine> unless they have Canada Day elsewhere.
10:21:06 <ph88> Canada ? they start weeks on thursday ??
10:21:08 <monochrom> OK enough BS from me. I'll look at the paste.
10:21:23 <monochrom> Haha "what have I done"
10:22:32 <monochrom> hrm interesting
10:22:43 <sshine> dsal, another funny page: https://github.com/NorfairKing/haskell-WAT
10:23:23 <monochrom> Does formatTime really uses the same format strings as strptime?
10:23:36 <ph88> i thought it said that in the documentation
10:23:40 <monochrom> Or I just mean do they agree on %Y %W?
10:23:44 <dsal> sshine: Man, that's just a terrible github repo. 
10:23:45 <ph88> not sure
10:24:14 <monochrom> I think you should at least see with your own eyes once the output of formatTime defaultTimeLocale format time
10:28:49 <ph88> monochrom, i see 2020 35 which is the current week when you start counting weeks from 0
10:29:46 <jack3301> Hey guys here are some statements that I believe are true in Haskell. Correct me if I'm wrong. 1> If a function's parameter has been constrained to one Typeclass, it is impossible for the parameter to be assigned another Typeclass during evaluation. Ex.: func1 :: Num a => a->a being converted to func1 :: Fractional a => a->a for some operation. 2> Every parameter of a function gets a concrete type before evaluation. 3> A parametrically polymorphic 
10:29:46 <jack3301> variable can be assigned any Typeclass depending on the operations being performed on it.
10:31:57 <jkaye[m]> 2> depends a bit on what you mean by concrete type. There are e.g. phantom types which are "concrete" in a sense, but also are not in another sense :)
10:32:19 <dolio> 2 is false, I think.
10:32:36 <jack3301> concrete types like Integer, Double, etc.
10:32:52 <jkaye[m]> Then 2 is false I believe
10:33:12 <monochrom> ph88: Might it have something to do with: January 1 1970 was a Thursday?
10:33:17 <dsal> :t id 5
10:33:18 <jkaye[m]> Also, 1 could also be false depending on what you mean, since typeclasses can have relationships to one another
10:33:19 <lambdabot> Num a => a
10:33:53 <jkaye[m]> And I'm not totally clear on what you mean by 3>
10:33:58 <dolio> 'assigned another typeclass during evaluation' doesn't make a ton of sense.
10:34:21 <dsal> typeclasses aren't "assigned" they're more limiters.  I'm having trouble understanding what you mean by that.
10:34:44 <ph88> monochrom, hmm ye interesting
10:35:13 <ph88> how do i get the monday of the same week given any UTCTime of a week ?
10:36:12 <dsal> If a function has a Num constraint on its parameter, the only thing you're allowed to know about it is that it's got a Num instance.  If you try to use it as a Fractional later, that doesn't work, because you didn't state that as a requirement.
10:37:06 <dolio> That isn't something that happens during evaluation, though. All the type checking can be done before evaluation even starts.
10:37:13 <monochrom> UTCTime has a Day field.  Data.Time.Calendar.WeekDate has useful functions between Day and year-weeknum-weekday
10:37:29 <jack3301> Let's say a function func2 x y = (x/y) + 1. When we do :t func2, we get Fractional a => a->a->a right?
10:37:52 <jack3301> because of (/) in the function
10:38:29 <dsal> That's kind of a different problem.  You normally declare your types, you don't just ask what a possible type is.
10:38:30 <Enrico63> @ssh
10:38:30 <lambdabot> Maybe you meant: src msg ask
10:39:06 <Enrico63> sshine, I came up with a solution to the HR problem, but it doesn't pass one test. I've posted it here: https://codereview.stackexchange.com/questions/249006/hackerrank-binary-tree-to-compute-the-nth-power-of-natural-numbers-that-sum-up
10:41:41 <monochrom> ph88: The source code of Data.Time.etc looks like it already parses %W to a Monday. I can't explain why you get a Thursday.
10:42:05 <ph88> me neither
10:42:14 <ph88> the most primitive function that is exposed is this
10:42:15 <ph88> buildTime defaultTimeLocale [('W', "35"), ('Y', "2020")] :: Maybe UTCTime
10:42:24 <ph88> from Data.Time.Format.Internal 
10:42:44 <ph88> for UTCTime it uses buildTime from ZonedTime which is defined here https://hackage.haskell.org/package/time-1.10/docs/src/Data.Time.Format.Parse.Instances.html#line-338 
10:42:47 <ph88> but then i get lost
10:47:50 * hackage compdoc 0.1.0.0 - Parse a Pandoc to a composite value.  https://hackage.haskell.org/package/compdoc-0.1.0.0 (locallycompact)
10:51:12 <monochrom> ph88: Just add ++ " 1" and use "%Y %W %w" :)
10:51:41 <ph88> thanks :)
10:52:11 <monochrom> I don't know why it defaults to Thursday, and I don't know why it took me so long to realize "just be explicit, tell it I want a Monday THIS IS AN ORDER"
10:58:08 <ph88> don't worry i've been staring at this for much longer and i didn't realize that as well :P
11:04:18 <davean> What was the first day of the year?
11:04:43 <monochrom> was Wednesday for 2020
11:06:45 <monochrom> "2019 01" is Thu Jan 10 2019
11:07:19 <monochrom> (Jan 1 2019 was Tue; 1st Monday of 2019 was Jan 7)
11:09:58 <ph88> how can i print out a Double with all accuracy available ?
11:10:12 <c_wraith> show?
11:10:13 <ph88> or is this already the best i can do  1.43485364736e38 
11:10:18 <ph88> oh that's it ?
11:10:35 <ph88> is that 64 bits ??
11:12:27 <hpc> there's functions somewhere that you can use to get the mantissa and exponent of a float
11:13:39 <hpc> ah, decodeFloat - https://hackage.haskell.org/package/base-4.14.0.0/docs/Prelude.html#t:RealFloat
11:13:55 <hpc> that should get you all 52 bits of precision
11:14:18 <ph88> thank you
11:16:50 * hackage req 3.6.0 - Easy-to-use, type-safe, expandable, high-level HTTP client library  https://hackage.haskell.org/package/req-3.6.0 (mrkkrp)
11:24:51 <monochrom> There is a mismatch between binary and decimal. But it's about 18 significant decimal digits.
11:35:34 <tomsmeding> > logBase 10 (2 ^ 53)
11:35:37 <lambdabot>  15.954589770191001
11:35:42 <tomsmeding> that's slightly less than 18
11:36:15 <monochrom> Ah yeah OK
11:41:15 <davean> ph88: does 'scientific' solve your problem?
11:42:09 <ph88> i got it davean thank you :)
11:42:23 <davean> ph88: Yah, jsust thought it might fit what you wanted better than doing it manually :)
11:42:25 <dmwit> ph88: show will give you enough digits to uniquely identify all 64 bits of a Double, yes.
11:42:56 <dmwit> ph88: However that sentence was quite precise. It will not print out the decimal number encoded by those 64 bits, but a rounded version of it. It ensures that the rounding doesn't lose information.
11:43:13 <dmwit> I think there's a package on Hackage to print out the actual number encoded, if that becomes interesting for some reason.
11:43:56 <dmwit> (In fact I believe show also promises that it won't show *more* decimal digits than needed to uniquely identify all 64 bits.)
12:25:00 <tomsmeding> Enrico63: https://codereview.stackexchange.com/a/249010/74406
13:59:17 <ph88> i have a function that is written to use monad reader (also with MonadIO) but i want to use it just as a normal IO function, can i run reader with no actually using reader ?
14:00:20 <Rembane> ph88: You can use runReaderT and then ignore the results from it. 
14:01:08 <ph88> runReaderT :: ReaderT r m a -> r -> m a      what shall i put as r  ?  just () ?
14:02:17 <Rembane> ph88: you can start with an underscore and see what ghc thinks is a good reader context
14:02:46 <dmwit> Presumably the function says what r has to be.
14:02:48 <ph88> https://bpa.st/JBPA
14:02:50 <tomsmeding> though if () works, that's probably a good choice :p
14:03:14 <dmwit> Yeah, () isn't going to work for any sanely-written function.
14:03:15 <ph88> ye im getting confused now .. seems that i cant use reader with different values for what to read when they are in the same do block
14:03:25 <dmwit> If it didn't actually read from the thing, it wouldn't bother putting a MonadReader constraint.
14:03:35 <dmwit> ph88: Correct.
14:04:03 <dmwit> You must have a single environment type, which is consistent through the entire do-block.
14:04:37 <ph88> thanks guys :)
14:08:20 * hackage hledger-flow 0.14.2.0 - An hledger workflow focusing on automated statement import and classification.  https://hackage.haskell.org/package/hledger-flow-0.14.2.0 (apauley)
14:12:00 <koz_> What exactly _is_ a TyCon in terms of how it's represented?
14:13:16 <dminuoso> koz_: Can you rephrase your question? Im not sure what you are asking
14:13:32 <koz_> dminuoso: What does a TyCon look like in terms of the data in it?
14:13:34 <monochrom> Is it TH's TyCon?
14:13:50 <koz_> This TyCon: https://hackage.haskell.org/package/base-4.14.0.0/docs/Data-Typeable.html#t:TyCon
14:14:12 <dminuoso> koz_: Check compiler/types/TyCon.lhs in ghc source code
14:14:36 <dminuoso> Ah wait
14:14:38 <dminuoso> no that's not it
14:15:24 <monochrom> The source code goes like "data TyCon = TyCon WORD64_TY WORD64_TY Module TrName Int# KindRep"
14:15:42 <monochrom> those word64s are "fingerprint"s
14:15:43 <dminuoso> Which source?
14:15:54 <monochrom> GHC.Types
14:16:07 <monochrom> But I merely clicked "source" and got that.
14:16:14 <dminuoso> Ah
14:16:20 <dminuoso> Weird, I didnt get a source link
14:16:41 <koz_> monochrom: Thanks!
14:16:43 <monochrom> Ah I used what comes with GHC.
14:16:58 <monochrom> <- not a fan of "online docs"
14:17:35 <monochrom> I believe TyCon is meant to be an opague type. You try to use only the functions in Data.Typeable
14:17:52 <koz_> monochrom: Oh, I know. I was curious how ti was represented, that's all.
14:19:00 <dminuoso> Btw, there appears to not be a callocaBytes, is using allocaBytes + c_memset the right way to go?
14:19:07 <monochrom> In retrospect I think the getter functions tyConPackage, tyConModule, tyConName, tyConFingerPrint are a way to say "those are the fields in TyCon"
14:21:18 <koz_> Also, does anyone know what config stuff I gotta feed to Stylish Haskell to make it lay out \case like case?
14:39:27 <gestone> hi all! i'm trying to grok my head around free monads. to my understanding, one of the benefits to free monads is the fact that we can separate the instructions from the interpreter itself. why would i want to use a free monad over something like a list to represent the instructions i'd like the interpretter to interpret?
14:40:50 <dminuoso> gestone: "instructions" is usually meant in a vague sense.
14:41:14 <dminuoso> Free monads let you separate the implementation of a monad and the shape of some computation involving it.
14:41:56 <dminuoso> If you had a "list of instructions", then your code is already tied to a particular interpreter.
14:49:15 <dminuoso> Does ghc/cabal allow me to write C code, compile and link against it?
14:49:24 <dcoutts_> yes
14:51:21 <dminuoso> dcoutts_: What keyword should I lookup in my manuals?
14:52:21 <ski> `foreign' ?
14:53:18 <dminuoso> Ah no, I realized that if dcoutts_ answered, it must have been one of his children. bytestring has the pointers. :)
14:53:30 <dminuoso> Looks like c-sources in cabal is what Im after
14:53:56 <dcoutts_> https://cabal.readthedocs.io/en/3.4/cabal-package.html#pkg-field-c-sources
14:54:00 <dcoutts_> yup
14:54:02 <gestone> dminuoso: but isn't the usage of a list vs a free monad fairly similar for an implementation of a DSL? i can see how the composition of the instructions with monadic do notation is useful, is this what it's generally used for?
14:54:13 <dminuoso> Cheers
14:54:36 <dminuoso> gestone: lists can be considered free monoids, so this is why they might look similar
14:58:42 <dminuoso> gestone: Think of free monads as a data-type equivalent of tagless final.
14:58:55 <dminuoso> Maybe that helps
14:59:25 <gestone> heh time to lookup what tagless final is
14:59:32 <dminuoso> gestone: mtl style 
15:00:06 <gestone> ah
15:01:53 <dminuoso> dcoutts_: Thanks, its working out nicely! :)
15:03:21 <dolio> What is the list implementation of a DSL?
15:04:42 <gestone> perhaps i'm not using the write terminology here, but having an interpret function that would simply pattern match on each of the ADTs contained in the DSL
15:04:51 <gestone> err sorry the list
15:05:16 <dolio> I don't know what the list is.
15:06:58 <gestone> for a concrete example, i was looking at https://docs.google.com/document/d/1sRQ4766p2dtgj76IpZMz-rMwglLixm17Y-r2D7NcdHQ/edit
15:07:07 <gestone> and i was looking at figure 3.8
15:08:41 <gestone> the author defines a type, type Hdl = [Component] and makes the argument that the exposing the details of the Hdl type implementation leads to coupling
15:09:49 <gestone> so as a solution, he turns to using a free monad as an abstraction in figure 3.11
15:10:30 <gestone> but i don't know how that exactly solves the problem because now clients are interfacing with the free monad rather than the list
15:11:43 <gestone> "The idea of the Free monad pattern is that you can chain actions of your algebra, turning them into monadic functions that are composable due to their monadic nature."
15:12:51 <dolio> I don't know. It looks like the free monad in question is going to be almost like a list, just represented differently.
15:13:05 <dolio> Not quite the same, but similar.
15:13:43 <gestone> yeah which is why i was questioning the benefits of having the abstraction in the first place
15:16:12 <sim590> tdammers: Following up on your messages: https://paste.debian.net/1162871/. I understand how the two approaches work, but I'm not sure how to tell the advantages of each. It seems like both approaches let me disable/enable logging (by providing default log/nolog functions or typeclass instances). The only difference I can see is that the first approach forces me to live in IO while the second
15:16:14 <sim590> approach can permit to live outside IO. Is that right? Can you give your point of view? 
15:18:37 <dolio> Well, I can't speak to this book's qualities, since I haven't read it.
15:18:52 <dolio> Maybe it isn't presenting the most compelling example.
15:19:31 <gestone> are there compelling examples of where the free monad abstraction yields a lot of value? 
15:19:58 <dolio> The original example is almost a free monad already.
15:22:01 <dolio> I don't really know what this language is doing, but an example of a different way of implementing it might be to instead embed it as a bunch of functions that just immediately do whatever actions a `Component` might entail in some way.
15:22:32 <dolio> And then you could ask: why might you want to represent these `Components` as the data type instead.
15:23:10 <dolio> (Presumably because you want to manipulate them before 'doing'.)
15:23:37 <gestone>  hmm
15:25:17 <dolio> If it's a 'description language' though, maybe there's not a ton of doing.
15:27:33 <dolio> You could make a DSL with commands that immediately write things to files that describe the hardware or something. :)
15:27:49 <monochrom> dminuoso: https://gitlab.haskell.org/ghc/ghc/-/wikis/commentary/rts/signals   TLDR: with -threaded, there is no SIGVTALRM at all, you have nothing to worry about (OK except maybe SIGINT). without -threaded, SIGVTALRM happens; if you anticipate that some users may refuse -threaded, you have a tougher job.
15:28:55 <dminuoso> monochrom: Oh! That's very useful to know.
15:29:09 <gestone> dolio: hmm yeah. do you know of any good non-trivial examples of usages of the free monad?
15:29:27 <monochrom> The section title "The RTS timer signal" is probably better as "The RTS timer". Because, as it explains, there is always a timer, but the timer is not always implemented by the unix signal system.
15:30:03 <monochrom> Or alternatively, "signal" doesn't always means the unix signal system heh
15:30:23 <dminuoso> monochrom: Hold on. The wiki article starts with
15:31:06 <dminuoso> `Here we discuss only the threaded version, since we expect that to become the standard version in due course.`
15:31:22 <monochrom> Yeah that's a brave bright future, isn't it? :)
15:31:42 <dminuoso> Ahh hold on
15:32:00 <dminuoso> So, the best version runs a separate scheduler thread that just sleeps
15:32:07 <monochrom> I think it eventually ends up talking about unthreaded too.
15:32:14 <dminuoso> (Rather than preempting the entire process)
15:32:24 <monochrom> Yeah, and linux's sleep is pretty unintrusive
15:33:07 <dminuoso> https://gitlab.haskell.org/ghc/ghc/blob/master/rts/posix/Itimer.c#L43-44
15:33:17 <dminuoso> Heh, the motivation was even the problem I ran into
15:33:32 <dminuoso> monochrom: Thank you, this is golden. :)
15:33:40 <monochrom> :)
15:33:57 <dminuoso> Btw, when I do something like pthread_sigmask, presumably that runs in the context of the IO manager thread right?
15:34:12 <dminuoso> (That is, the IO manager thread executing the corresponding IO action in Haskell)
15:34:36 <monochrom> Do you use FFI to call pthread_sigmask?
15:34:49 <monochrom> Hrm this gets very messy!
15:35:01 <dminuoso> Yes
15:35:08 <dminuoso> Haha, right. So it depends on whether the call is unsafe or safe now.
15:35:17 <dminuoso> Because if its safe, that spawns a new IO manager right?
15:36:15 <monochrom> OK, you have -threaded, but you don't do your own forkIO or forkOS, you just use the thread given to you for main, and you use FFI to pthread_sigmask. Are these all correct?
15:36:47 <dolio> gestone: No. But I'm not very good abut reading intro Haskell stuff for the purpose of recommending it.
15:37:07 <dminuoso> monochrom: Yes.
15:37:35 <monochrom> Then I don't think the pthread_sigmask happened in the I/O manager thread or any of the RTS's helper threads.
15:37:43 <monochrom> Here is what happens under those conditions:
15:38:46 <monochrom> The thread given to you for running main is a "bound Haskell thread".  "bound" means there is a stable OS thread associated to it, such that: every FFI call is executed in that same OS thread.
15:39:17 <monochrom> (There is no guarantee that Haskell code also runs in that same OS thread. But empirically it looks like true often.)
15:40:04 <monochrom> So suppose you FFI-call pthread_sigmask; then later you FFI-call some other function f. Then f is still run under that sigmask you set.
15:40:12 <monochrom> At least as far as my model knows.
15:40:43 <gestone> dolio: i see, i'll keep digging around then
15:43:34 <monochrom> Actually what I said also assumes "safe"
15:45:50 <monochrom> Fortunately the "GHC execution model" slides have one slide about all 4 combinations of safe/unsafe, bound/unbound
15:46:14 <monochrom> OK but how do I read these pictures haha
15:47:33 <monochrom> Ah OK looks like I don't have to assume "safe".  "unsafe" just means some Haskell threads that have no reason to be blocked can be blocked just by bad luck.
15:51:47 <monochrom> I have a feeling that you don't get multiple I/O manager threads unless you use RTS option -Nx to declare "I have x cores, please use them".
15:52:12 <dminuoso> monochrom: Which slides are you looking at?
15:52:44 <monochrom> comparing "IO manager (single core)" and "IO manager (multi core)" for my latest sentence
15:55:06 <dminuoso> monochrom: Im gonna give https://simonmar.github.io/bib/papers/conc-ffi.pdf a read now.
15:57:22 <monochrom> This is a rabbit hole. I went down once. "It's threads all the way down."
15:59:00 <dminuoso> Im chasing threads. Literally and figuratively!
16:05:45 <dminuoso> That paper is really good, and answers a lot of the questions that have popped up since yesterday.
16:40:47 <monochrom> Oh! "I/O service thread" is now I/O manager thread.
16:40:50 * hackage lsp-test 0.11.0.5 - Functional test framework for LSP servers.  https://hackage.haskell.org/package/lsp-test-0.11.0.5 (luke_)
17:20:30 <Kindle> Can someone explain/reason through why it is that `(b -> c) -> (a -> b) -> a -> c` is the same as `(b -> c) -> ((a -> b) -> (a -> c))`
17:20:53 <Kindle> Doesn't the former describe taking two functions and a value
17:21:14 <Kindle> While the latter describes taking a single function and returning a function (from a func to a func)?
17:26:27 <Rembane> Kindle: you can pick both apart in the same way by supplying two functions, the first f :: b -> c and the second g :: a -> b, and you get the same thing. 
17:27:17 <Kindle> Pardon?
17:27:25 <Kindle> I thought the 2nd only took a single argument
17:27:47 <Rembane> In both cases you get a -> c in the end 
17:28:09 <Rembane> First case: (b -> c) -> (a -> b) -> a -> c 
17:28:31 <Rembane> Supply f :: (b -> c) and we get (a -> b) -> a -> c 
17:28:47 <Rembane> Supply g :: (a -> b) and we get a -> c 
17:28:49 <dibblego> Kindle: all Haskell functions take exactly one argument
17:31:20 <Kindle> Not following on the supply g example, sorry
17:32:52 <Rembane> Ah, lets see if I can find an easier example. 
17:32:52 <dibblego> (->) is right-associative, all functions take one argument
17:33:17 <dibblego> "Doesn't the former describe taking two functions" — no, since this is taking two arguments, and functions only take one argument
17:33:20 <cheater> Kindle: the're not two separate examples. you first put in f, then g, in one single situation.
17:34:15 <cheater> better look at xyz :: x -> y -> z
17:34:28 <xsperry> Kindle, as mentioned above, all functions in haskell take a single argument. functions that appear to take twoarguments also take one, and return a function that takes the next argument
17:34:42 <cheater> if you have a value of type x, call it myx, then xyz myx is a function that needs a y and gives you a z. it's type is y -> z.
17:34:43 <xsperry> Kindle, as mentioned above, all functions in haskell take a single argument. functions that appear to take multiple arguments also take one, and return a function that takes the next argument*
17:34:53 <cheater> this means that when you gave xyz an x, you got a function of type y -> z.
17:35:00 <Kindle> Right, currying- but don't they return a function from a func to a func
17:35:02 <cheater> this means that xyz has the type x -> (y -> z)
17:35:08 <erisco> functions in all languages take a single argument fight me
17:35:48 <cheater> Kindle: read what i just said (the xyz example) and let me know if you still have any questions.
17:35:49 <dibblego> @type (++) "abc"
17:35:50 <lambdabot> [Char] -> [Char]
17:36:01 <dibblego> @type (++) "abc" "def"
17:36:02 <lambdabot> [Char]
17:36:18 <Kindle> Oh i get it
17:36:20 <Kindle> Thank you everyone
17:36:22 <cheater> there you go
17:36:23 <cheater> w
17:36:25 <cheater> yw
17:36:30 <dolio> erisco: That's incorrect. Some languages copied math notation in a naive way, rather than having tuples.
17:36:49 <dolio> Quite a lot of them, really.
17:37:04 <erisco> dolio, what if I said arguments are not values
17:37:36 <cheater> when i make an argument, it is deeply rooted in my values
17:38:31 <dolio> Then I'd say no one wants to hear your alternate definitions of words that don't correspond to how most people use them.
17:41:00 <erisco> I don't think it is remotely controversial
17:44:36 <dolio> I don't really see the relevance.
17:47:09 <dolio> Why is 'value' even coming into the question?
17:49:01 <erisco> because you'd say what about  add(3,5)  and I'd say  (3,5)  is the one argument. Then you'd reasonably object that  (3,5)  is not a value, and I'd say neither is  add
17:49:28 <dolio> No, (3,5) isn't the one argument.
17:50:51 <dolio> There are languages where (3,5) is a value, but there are also functions with multiple arguments, that are different than functions that take a single tuple argument.
17:52:15 <erisco> a different sort of tuple
17:53:32 <erisco> an "argument list"
18:01:07 <dibblego> I'd say you guys are having zero arguments
18:14:31 <erisco> it is half baked but I thought about turning the tables and explaining actually, in a sense, functions in your language do not have multiple arguments either
18:15:30 <erisco> maybe it is as helpful as explaining that, actually, C is a functional language
18:16:32 <dolio> That isn't how people actually use the term.
18:17:03 <erisco> well I'm not the curator of Webster's dictionary
18:17:23 <dolio> They say that `argc` and `argv` are the arguments of `main`.
18:19:11 <erisco> so you'd rather the route of saying that arity is a non-concept in Haskell
18:19:17 <erisco> well that's fine, I appreciate that too
18:22:17 <erisco> I like it more than saying well a -> b -> c is kind of like arity 2, or (a, b) -> c is kind of like arity 2
18:23:29 <dolio> I didn't say anything about Haskell. I said people aren't going to respect your statement about non-Haskell languages, because it doesn't match the way people actually use the words.
18:24:55 <erisco> it seems like you're arguing from a consensus or popularity on how certain words are used, like "argument"... and if we're going to do that for C then why not Haskell
18:28:50 <hololeap> i personally think of haskell functions having arity and multiple arguments. i know that haskell is expressive enough return a function from a single argument, but most languages aren't. in haskell's case, it's easy to argue that both viewpoints are correct. in other langages, not so much.
18:29:45 <hololeap> even though they are from a certain level; one that unfortunately cannot be expressed in that language
18:30:23 <hololeap> s/that/those
18:30:40 <erisco> is your definition of arity in Haskell rigorous or is it more so an intuition?
18:31:51 <hololeap> eh, i guess i could form a rigorous definition out of it, but i only use it as an intuitive thing
18:32:07 <dibblego> I have found in teaching, that if a student accidentally believes that haskell takes multiple arguments, they won't be able to solve e.g. liftA3, or they won't know why flip (foldr (:)) appends two lists
18:35:35 <hololeap> and i definitely don't treat haskell functions like they have arity. but i would be lying if i said that i don't think of haskell functions as "taking n arguments"
18:36:14 <Cale> The fun cases are things where the result is polymorphic
18:37:13 <Cale> > foldr (\x f s -> s : f (s + x)) (\s -> [s]) [1..10] 0 -- how many arguments does foldr take? :D
18:37:15 <lambdabot>  [0,1,3,6,10,15,21,28,36,45,55]
18:38:03 <hololeap> Cale: that was definitely one of my "haskell is black magic" moments when i realized you could do that
18:38:33 <dibblego> 1
18:39:38 <erisco> I think I could go as far to say  a -> b -> c  has at least arity 2
18:39:42 <hololeap> you could say it's arity 3, and that you're folding to get a function of arity 1 :)
19:13:58 <sim590> I'm working on conceptualizing the model of my library which is an E2E secure group chat protocol library. I've written core functions in a way to handle errors and error logging respectively using Chronicle and co-log, which is fine, but now I'm wondering about the API. At first, I thought that I would provide an API with enabling and disabling capability of logs, but with function signature
19:13:59 <sim590> constraints on all of my API exposed functions, basically imposing that my functions are running in a monad that may write the logs through IO (thanks to tdammers for the idea). Here is an illustration of this model with the "main" file of my library: https://paste.debian.net/1162879/. And here is an illustration of how it's used: https://paste.debian.net/1162880/. I'm now wondering if I should
19:14:01 <sim590> either go that route with the MonadLogging constraints or either provide two modules, i.e. one with MonadLogging constraints and the other without any constraints and no logging. The base of my questionning is that I feel like logging could be reserved to the developper and the end-user of the library could wish for more simple signatures that eases his development even though it incapacitates him
19:14:03 <sim590> of getting to know if the library has found an error. 
19:15:52 <sim590> For instnace, all of the libraries I use commonly don't bother me with their logging routines (Control.Chronicle, Data.These, Data.Map, etc.) I'm sure that those libraries must have good error catching tools for developers, but they don't bother the user of the lib.
19:18:05 <sim590> It's easier in most langauges to do this because you don't have to think about the return type of your functions when you're putting some logging capability on your software. With haskell, it becomes harder, in a sense, to sort everything out. I'm just really wondering about the most common approach to this as I don't want to make a franken haskell library.
19:19:17 <sim590> My point is that if most functions of my API could just literally be pure (no IO), then I don't see why I would force an API with IO functions everywhere.
19:44:21 <Axman6> sim590: just allow your functions to run in some arbitrary monad which has a WithLog constraint: encryptMessage :: HasLog m => Key -> Message -> m EncryptedMEssage (from https://hackage.haskell.org/package/co-log-0.4.0.1/docs/Colog-Monad.html).
19:49:49 <sim590> Axman6: that's basically what I'm doing with my HartMonad constraint. Thanks. I prefer using this instead of my home-made HartLogging. But my question still stands: should my exposed functions rather be pure (no monad constraint) as the main API and provide an optional module with the same signatures, but then with "WithLog" constraint there? I'm asking because I usually don't see logging
19:49:51 <sim590> constraint on most of the package I use. Is that because the default API has log hidden or because logging is not even written in those packages? For instance working with logging wouldn't be viable for a package such as Control.Lens. However, I'm sure they must have tools for finding out bugs?
19:50:12 <Axman6> monad /= not pure
19:51:00 <Axman6> the function above cannot do any IO (but some instance for m may use IO, however your function cannot take any advantage of that)
19:51:02 <sim590> Yeah I know. I should rather say less complex signatures.
19:52:13 <sim590> Axman6: Yeah, I got that. I was more bothered by the decoration of "m" in the type "m a". I feel like my functions could easily live outside logging. It's just that I feel that logging is useful, but I don't see other libs do that.
19:52:33 <sim590> Or may be I need some good notorious examples in the Haskell world?
19:54:41 <sim590> I feel like I was not very clear when I wrote "I prefer using this instead of my home-made HartLogging." I'm saying here that I prefer your suggestion to what I first did.
20:29:52 <cheater> sim590: what does a hart monad do?
20:32:53 <sim590> cheater: it's just a synonym for Identity. It's an idea of how I could present a default no logging configuration for the user of the library since Hart = Identity and that Identity is an instance of HartLogging, but now I'm looking to use HasLog (or WithLog) from the Co-Log library, which I already use, in order to write my function signatures that enable logging.
20:34:11 <cheater> why did you call it something else if it's just Identity
20:34:15 <cheater> i'm confused
20:35:42 <sim590> Just for looks. Idk. I'm experimenting.
20:41:38 <cheater> ahh, ok
21:08:33 <sim590> I'm trying to write this function signature: `users :: WithLog env Message m => ArtTree -> m [UserInfo]`, but I'm getting error "Non type-variable argument in the constraint: HasLog env Message m (Use FlexibleContexts to permit this)". Should I enable the extension or is there a way to do without? All examples of using co-log I have found for now only show `env` as implicit... I'm a bit stuck
21:08:35 <sim590> here. I don't understand how to fix this.
21:11:38 <jle`> sim590: you should enable it :)
21:12:07 <sim590> Then why is it not the default config?
21:14:15 <sim590> Why is this https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-FlexibleContexts talking about the context of class definition while I'm not in that context and this extension fixes my issue?
21:15:30 <sim590> Is it because co-log makes use of this in its module and then it propagates this error up to the user?
21:15:48 <sim590> if I don't use the extension that is
21:17:19 * hackage swiss-ephemeris 0.3.1.0 - Haskell bindings for the Swiss Ephemeris C library  https://hackage.haskell.org/package/swiss-ephemeris-0.3.1.0 (lfborjas)
21:19:59 <jle`> sim590: it's a tricky historical thing. the 'language' hasn't been changed in a long time
21:20:07 <jle`> and there isn't much consensus on officially changing it
21:20:57 <L29Ah> i have a function `f a@(b,c) = fst a`; `a` was fully evaluated by other code before calling the function; will `c` get GC'd before `f` is called, or `f` forces `a` to linger in full, forcing the expensive `c` to consume memory until `f` is called?
21:21:07 <jle`> sim590: so GHC tries its best to by default, imitate the official haskell language
21:23:30 <jle`> L29Ah: it sort of depends on the context and how f is used
21:23:34 <jle`> or not used
21:24:03 <jle`> do you have a concrete example?
21:24:26 <jle`> L29Ah: if something else is holding on to the tuple, then the tuple (and c) might persist
21:24:42 <jle`> and it is sort of implied that something else is holding on to the tuple from your question
21:26:06 <L29Ah> jle`: my example is quite complex, i'm trying to nail it down: https://github.com/l29ah/hyborg/blob/master/Main.hs#L108 some of these seem to persist for the whole runtime of my app, and i have zero clue why or how to figure it out; i'm commenting out non-essential pieces of code now but it doesn't help much
21:26:26 <L29Ah> > and it is sort of implied that something else is holding on to the tuple from your question
21:26:27 <L29Ah> no, why?
21:26:28 <lambdabot>  <hint>:1:16: error: <hint>:1:16: error: parse error on input ‘of’
21:28:14 <jle`> if f is the only consumer then f drives evaluation
21:29:02 <jle`> L29Ah: what ist he 'f' in your example?
21:29:52 <L29Ah> jle`: https://github.com/l29ah/hyborg/blob/master/Main.hs#L133 put before `let ai`
21:30:54 <jle`> cachedPut ?
21:30:56 <L29Ah> i'm misled in this example tho now that i think about it, as even if the tuple holds in full, it doesn't answer why it is not freed after the two `cachedPut`s doing their jobs
21:35:10 <jle`> what tuple is being held?
22:17:17 <jackdk> For giant enums, (>200 constructors), is there a library that provides fast read instances using a trie or other structure?
22:39:45 <PropositionJoe> I want to check that variable is certain type. E.g. (Type x) == Integer.
22:39:53 <PropositionJoe> How do you do?
22:40:06 <PropositionJoe> that*
22:42:15 <davean> It can't not be the type its specified to be.
22:42:26 <davean> Theres no checking to do.
22:43:10 <PropositionJoe> I'm using the Either construct
22:43:15 <davean> So what?
22:43:22 <davean> That doesn't change anything
22:43:41 <PropositionJoe> It does, because I dont know the type as it can be two different ones.
22:43:55 <davean> Incorrect.
22:43:56 <dolio> If `x` has type `Either a b` then it will never have type Integer.
22:44:39 <davean> Either is Either, the value contained in each of the constructor is as specified.
22:45:07 <davean> but the Either is Either.
22:45:27 <davean> x::Either a b 
22:45:38 <davean> x's type is Either a b, not a or b
22:45:40 <PropositionJoe> Suppose I have this declaration: addEithers :: Either String Int -> Either String Int -> Either String Int
22:46:59 <davean> Left v::Either a b "Left v" is Either a b, but v now we know v is a because its the Left constructor
22:47:13 <davean> and Left of Either a b holds an a
22:47:46 <davean> Haskell isn't python
22:47:58 <PropositionJoe> davean: :D
22:48:18 <dolio> There are 4 cases for addEithers.
22:48:20 <PropositionJoe> I'm very new to Haskell, this is all new to me.
22:48:32 <dolio> One is `addEithers (Right x) (Right y) = ...`
22:48:41 <dolio> Where you have two integers.
22:48:44 <koz_> dolio: Ah, an optimist, I see. :P
22:48:53 <koz_> Starting with the best case. :P
22:49:23 <PropositionJoe> dolio: ok I think I get what needs to be done now
22:50:21 <davean> dolio: Haha cases, I'd just use the Monad :)
22:50:25 * davean is lazy
22:50:40 <davean> well, Applicative here
22:50:42 <dolio> Well, I have no idea what the other cases are going to do.
22:55:23 <fog47> I have something which does not typecheck; https://pastebin.com/raw/PsYCnXgj
22:55:39 <fog47> it says it cant match an unevaluated type family to a variable
22:55:55 <fog47> why not?
22:55:57 <fog47> can i get it to typecheck with some modifications?
22:57:37 <fog47> i guess this would mean i would never be able to calculate a type within a GADT using an associated type from a constraint
22:59:43 <fog47> but i can do that;
22:59:44 <fog47> % class C a where type T a :: *
22:59:44 <yahb> fog47: 
23:00:01 <fog47> % data D a where D :: C a => T a -> D a
23:00:01 <yahb> fog47: 
23:00:32 <fog47> so i still dont see the problem...
23:03:23 <fog47> % class B a where type K a :: *
23:03:23 <yahb> fog47: 
23:03:38 <fog47> % class B a => C a where type T a :: K a
23:03:38 <yahb> fog47: 
23:03:46 <fog47> % data D a where D :: C a => D (T a)
23:03:47 <yahb> fog47: ; <interactive>:22:31: error:; * Expected kind `K a0', but `T a' has kind `K a1'; * In the first argument of `D', namely `(T a)'; In the type `D (T a)'; In the definition of data constructor `D'
23:03:50 <fog47> there we go
23:03:57 <fog47> whats that all about!?
23:04:09 <nshepperd2> this paste is incomprehensible
23:04:15 <fog47> it breaks when you try to do it with kinds
23:04:43 <fog47> nshepperd2: sorry... the yahb example above seems more legible 
23:04:58 <fog47> its just trying to dot together the scanners 
23:05:33 <fog47> you have to keep track of the result of the tail when its dotted together, thats what you dot the consed head too...
23:05:49 <nshepperd2> you might like to know that associated types are no different than other type families
23:06:03 <nshepperd2> putting it in a typeclass doesn't actually do anything
23:06:26 <fog47> i thought it might be able to kind of compute it if it knew the instance was satisfied
23:06:30 <fog47> but clearly not
23:07:10 <nshepperd2> nope
23:08:33 <fog47> hmm, at least then i get a different error
23:08:36 <fog47> % type family A a :: *
23:08:36 <yahb> fog47: 
23:08:48 <fog47> % data D a where D :: D (A a)
23:08:48 <yahb> fog47: ; <interactive>:24:16: error:; * Couldn't match type `A a0' with `A a'; Expected type: D (A a); Actual type: D (A a0); NB: `A' is a non-injective type family; The type variable `a0' is ambiguous; * In the ambiguity check for `D'; To defer the ambiguity check to use sites, enable AllowAmbiguousTypes; In the definition of data constructor `D'; In the data ty
23:09:49 <fog47> but thats not right because i have AllowAmbigousTypes on
23:10:03 <fog47> % :set -XAllowAmbiguousTypes
23:10:03 <yahb> fog47: 
23:10:06 <fog47> % data D a where D :: D (A a)
23:10:06 <yahb> fog47: 
23:10:13 <fog47> and now it works, so that cant be the error
23:10:16 <fog47> rrg
23:10:42 <fog47> wait, why can it do it with a type family and not an associated type!?
23:10:49 <fog47> you just said they were the same...
23:12:04 <nshepperd2> do you understand why it throws the ambiguity check error
23:12:15 <nshepperd2> if you don't have AllowAmbigousTypes on
23:12:30 <fog47> um, i made an error, its not a kind in the example above
23:12:48 <fog47> i dont think i can write it without classes
23:13:07 <fog47> if you could go off of the first error... (ill put it in a paste hang on)
23:13:53 <fog47> here;https://pastebin.com/raw/U6sp808G
23:14:42 <fog47> is that the same ambiguity error? i dont think so because i have all the type extensions on
23:14:50 <fog47> language extensions*
23:15:13 <fog47> Expected kind `K a0', but `T a' has kind `K a1'
23:15:27 <nshepperd2> AllowAmbigousTypes doesn't actually fix the ambiguity, it just lets you ignore it until it causes a different problem
23:15:39 <fog47> sure
23:15:44 <nshepperd2> it's the same problem though
23:15:51 <fog47> hmm...
23:16:01 <nshepperd2> data D a where D :: D (A a)
23:16:24 <fog47> data D a where D :: C a => D (T a)
23:16:25 <nshepperd2> the constructor has this type: D :: forall a. D (A a)
23:16:51 <fog47> ok
23:16:58 <nshepperd2> with the forall written out explicitly
23:17:33 <fog47> right, the user gets to specify what `a' should be when they create the GADT
23:17:34 <nshepperd2> now suppose I instantiate that with print (D :: D Int) or something
23:17:55 <fog47> then you tell it what `a' is
23:18:13 <nshepperd2> in order to type check that ghc needs to determine what 'a' is
23:18:20 <PropositionJoe> I have this short code example from an online course. Everytime I try to use it (call function) I get an error. https://pastebin.com/qE1rXMk9
23:18:38 <nshepperd2> but, 'a' could be many different things
23:18:42 <nshepperd2> there's no way to know
23:19:13 <fog47> PropositionJoe: that code looks ok
23:19:13 <ski> PropositionJoe : how're you attempting to call it ?
23:20:17 <fog47> nshepperd2: yeah i get that
23:20:33 <PropositionJoe> using stack ghci, then :load the file where this code is located
23:20:39 <ski> and then ?
23:20:40 <fog47> ok so it cant call the associated types, based on what `a' is
23:21:02 <PropositionJoe> It says "Ok, one module loaded"
23:21:11 <fog47> see, it compiles! 
23:21:19 <fog47> code is ok
23:21:26 <ski> PropositionJoe : what is it you do, that gives the error ?
23:22:22 <fog47> shepperd2: thing is, in the original paste, it should be able to determine from the types it knows for sure, what this supposedly ambiguous thing is
23:22:31 <fog47> this on; https://pastebin.com/raw/PsYCnXgj
23:22:37 <fog47> this one*
23:22:38 <PropositionJoe> "iWantAstring 4", that's it
23:22:54 <ski> PropositionJoe : `4' does not have type `Either Int String'
23:22:56 <PropositionJoe> "iWantAString 4"*
23:23:21 <fog47> you mean; iWantAString (Left 4)
23:23:24 <ski> you're attempting to give an input to `iWantAString' of a type it doesn't accept
23:23:28 <ski> probably, yea
23:23:55 <fog47> it takes type Either Int String, and you gave it an Int
23:24:51 <PropositionJoe> ok, i get it, thanks
23:24:52 <ski> PropositionJoe : btw, note that `iWantAString' is not "checking type of input". it's "checking alternative shape/form of input", checking whether input is an alternative of the `Left' form, or of the `Right' shape
23:25:27 <fog47> % class B a where type K a :: *; class B a => C a where type T a :: K a
23:25:27 <yahb> fog47: ; <interactive>:27:32: error: parse error on input `class'
23:25:38 <fog47> % class B a where type K a :: *
23:25:38 <yahb> fog47: 
23:25:41 <ski> if you had `iWantAString :: Either String String -> String', then it wouldn't be "checking whether input is `String' or `String'". it would still be checking whether input is tagged with `Left' or with `Right'
23:25:49 <fog47> % class B a => C a where type T a :: K a
23:25:49 <yahb> fog47: 
23:26:01 <fog47> % data D x where D :: C a => a -> D (T a)
23:26:01 <yahb> fog47: ; <interactive>:30:36: error:; * Expected kind `K a0', but `T a' has kind `K a'; * In the first argument of `D', namely `(T a)'; In the type `D (T a)'; In the definition of data constructor `D'
23:26:11 <nshepperd2> fog47: actually in https://pastebin.com/raw/U6sp808G you have two separate problems
23:26:15 <fog47> then it can see for certain what `a; is
23:26:19 <ski> fog47 : what's the expected kind of `T' ?
23:26:42 <fog47> thats defined in an instance
23:26:47 <nshepperd2> fog47: one is the ambiguity problem (that you can't infer a from the value of A a)
23:27:03 <nshepperd2> fog47: the other is that the kind of D is undefined
23:27:14 <fog47> oh..
23:27:21 <fog47> can it be polymorphic?
23:27:31 <fog47> do i need standalone kind signatures?
23:27:37 <fog47> does it need to be associated?
23:28:39 <fog47> rrg, that cant be the problem of the original version either
23:28:41 <nshepperd2> can it be polymorphic i dunno
23:28:48 <fog47> since it wraps up the ploykinded thing
23:28:49 * hackage swiss-ephemeris 1.0.0.0 - Haskell bindings for the Swiss Ephemeris C library  https://hackage.haskell.org/package/swiss-ephemeris-1.0.0.0 (lfborjas)
23:29:01 <fog47> thats what the datatype K is for
23:29:19 <nshepperd2> do you understand why the kind of D is undefined
23:29:19 <fog47> i think it might be best to just refer to this; https://pastebin.com/raw/PsYCnXgj
23:29:26 <fog47> i cant reproduce the error
23:29:56 <fog47> yes, because `a' appears in the data head, not wrapped in any K which would turn it to kind *
23:31:21 <nshepperd2> not really
23:32:14 <fog47> it would be better to address the actual bug though since i cant find something equivalent to it which is shorter
23:32:22 <ski> (which version of `D' are we currently considering ?)
23:32:37 <fog47> ski: see here; https://pastebin.com/raw/PsYCnXgj
23:32:49 <fog47> data KScanners c (dotResult :: K k) (sss :: (Ks, [*])) a b where
23:33:01 <fog47> its the `k' its complaining about
23:33:15 <ski> oh, you're talking about `data K k = K (k -> * -> * -> *) k' ?
23:33:24 <fog47> im trying to set it to;  GetDotResult scanner scanner' state state'
23:33:41 <fog47> yeah, thats it
23:33:48 <nshepperd2> i'm not gonna talk about the big paste. it's pointless to try and debug a very complicated thing if you don't understand how the simple cases work
23:33:52 <fog47> it takes something and the first parameter applied to it
23:34:15 <ski> % data K k = K (k -> * -> * -> *) k
23:34:15 <yahb> ski: 
23:34:20 <ski> seems to work
23:34:55 <fog47> the problem is that when its used, it tries to calculate the argument suppled to it using type families over the other inputs which should be unambiguous 
23:35:04 <fog47> but fails
23:35:38 <ski> but i agree at least several of the `D's you defined above looked confused
23:36:08 <fog47> its actually really difficult to make the question more simple, i tried and failed
23:36:18 <fog47> but a valid question still remains!
23:36:44 <nshepperd2> https://pastebin.com/raw/U6sp808G has 'data D a where D :: C a => D (T a)' which should really be written 'data D t where D :: C a => D (T a)' first, since using 'a' twice is misleading.
23:36:44 <fog47> i guess i should just lop away at the larger paste until it is succinct 
23:37:33 <fog47> nshepperd2: thats really not the issue at the mo
23:39:23 <fog47> i actually cant make that example any more simple
23:39:35 <fog47> i can remove the basecase but thats about it
23:39:38 <fog47> sorry...
23:39:46 <fog47> is it really impossible to read?
23:40:17 <nshepperd2> there, when inferring the kind of D (type constructor) ghc looks at the data constructor and unifies the kind of t with the kind of T a to decide that the argument to D is of kind K a, and hence D :: forall a. K a -> *
23:40:19 <fog47> i shouldnt have tried to describe it using the D examples, that has only confused things
23:40:42 <fog47> nshepperd2: i said i understood that before
23:41:11 <nshepperd2> this is an ambiguous kind, because K is a type family, hence you get two different 'a's in play, and hence the error about trying and failing to unify a0 and a1
23:41:41 <fog47> ok, so, understanding that simple example, whats wrong with the program?
23:41:58 <fog47> and more importantly, how to make it work!
23:42:24 <fog47> its actually a really cool idea if i could get it to typecheck 
23:42:42 <nshepperd2> heck if I know
23:42:50 <nshepperd2> too much going on
23:43:00 <nshepperd2> that definition for Ks looks extremely shady
23:43:08 <ski> i have no idea what any of the definitions in that paste are for
23:43:55 <nshepperd2> you pretty much never want existentials to begin with, and i didn't even think type promotion of GADTs was a thing
23:43:56 <ski> i guess `Ks' is basically `NonEmpty (exists k. K k)' ..
23:44:43 <fog47> um...
23:44:48 <fog47> ok
23:45:15 <nshepperd2> it would probably help to take out all the typeclass stuff
23:45:19 <nshepperd2> that's useless noise
23:45:33 <fog47> so i need ks because i cant store scanners on its own, or something like that, because it complains about not having its arguments suppled
23:46:10 <fog47> i have a scanner, and the state it accepts. these can differ in the kind of the state
23:46:25 <fog47> this is to allow for different lengthed tuples or other shaped type information
23:46:40 <fog47> i dont know how much data these scanners require or what shape it comes in
23:46:55 <fog47> some of them take lists of the intermidiate stages of a modifiable computation for example
23:47:13 <fog47> and this one is even more complicated, storing also all of the intermidiate scanners themselves"!
23:47:34 <fog47> i start from dotting together a list of functions
23:47:44 <fog47> i keep track of the intermediate types
23:47:57 <fog47> then when i move to states, instead of function arrows, things get gnarly
23:48:08 <fog47> they dont compose together half as easily
23:48:14 <fog47> hence all of this madness
23:49:04 <fog47> i should be able to dot together 2 arbitrary scanners
23:49:12 <fog47> well, state functions
23:49:53 <fog47> the scanner is the thing that scans these over a list, like a fold, updating the carry, except returning also the modified "state" input
23:50:22 <nshepperd2> this seems really ill conceived
23:50:24 <fog47> i can easily compose together two *lists* of scanners, even if i cant easily compose together normal scanners
23:50:37 <nshepperd2> what's the point of this, some kind of type level Foldable?
23:50:40 <fog47> nshepperd2: not at all
23:50:50 <fog47> its composition of state arrows
23:51:02 <fog47> well, not "arr a b"
23:51:08 <fog47> but "scanner state a b"
23:52:00 <fog47> then i can have a "scanner" that takes "state" of all the intermediate types, just to exemplify how i can have several such different things which are valid scanners
23:52:25 <fog47> i can sequence together the scanners, so i can use a list of scanners like a scanner
23:52:47 <fog47> i cant easily compose any 2 scanners, but i can concatinate 2 lists of them, and then use that as a scanner
23:53:20 <fog47> so im working with lists of scanners. now, by being able to vary which scanners are contained within the list, the hetrogenous kind of "state"
23:53:38 <fog47> then i can write "link" instances, like that they dot together
23:53:49 <fog47> i can put cons in this instance for example
23:54:08 <fog47> then in the list of scanners, i can mix lists and single scanners, and i can link them together
23:54:46 <ski> `KScanners' looks vaguely like some kind of transitive closure
23:54:50 <fog47> cons and (++) show how i have 2 valid link instances, but for different kinds
23:55:05 <ski> i dunno what you're doing (or intending to do) with these "scanners", though
23:55:57 <fog47> one of them has both of the kinds corresponding to lists, taking intermediate arguments, and for cons, the "scanner" (as opposed to arrow) is much simpler, since the head being consed doesnt need this intermidiate list of states as a type parameter
23:56:16 <fog47> ski: i can compose them together, so i shall
23:56:25 <ski> "them" being ?
23:56:29 <ski> to what end ?
23:57:01 <fog47> basically, i get an instance where any jumbled list of arbitrary things that are "modifiable functions" can be treated as thogh it is itself a modifiable function
23:57:14 <fog47> just like how i can have lists of regular functions dotted together
23:57:23 <fog47> "why dot functions together" ?
23:57:34 <fog47> im building a GADT to hold my modifiable functions
23:57:39 <ski> what do you mean by "lists of regular functions dotted together" ?
23:57:42 <fog47> this serves as a program
23:57:48 <fog47> and *it can be modified*
23:57:52 <ski> something like `foldr (.) id :: [a -> a] -> (a -> a)' ?
23:58:30 <fog47> nono, it has to be a HList
23:58:36 <fog47> with the constraint that the types match up
23:58:37 * ski sighs
23:58:50 <fog47> https://pastebin.com/raw/4nERhwse
23:59:04 <fog47> -- nonempty list of functions with types matching up for composition
23:59:04 <fog47> data Dots (arr :: * -> * -> *) (xs :: [*]) a b where
23:59:05 <fog47>  LastDot :: Composable arr => a `arr` b -> Dots arr '[] a b 
23:59:05 <fog47>  ConsDot :: Composable arr => a `arr` b -> Dots arr xs b o -> Dots arr (b ': xs) a o
23:59:24 <fog47> that paste is what a real mess looks like
23:59:34 <fog47> anyway, never mind that
