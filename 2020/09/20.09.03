01:00:48 <ADG1089> how can i write this in rust?:  f xs = map (\(a, b) -> "blabla" ++ show a ++ "blabla2" ++ show b ++ "blabla3") $ zip xs (tail xs) 
01:11:31 <[exa]> ADG1089: you can implement STG in Rust and run the haskell code lazily there :]
01:11:54 <[exa]> ADG1089: otherwise you should probably try #rust
01:12:25 <[exa]> btw, what's the problem with that thing in rust? sharing of (xs) and (tail xs)?
01:14:01 <mlugg> I'm reading about GHC's representation of heap objects (https://gitlab.haskell.org/ghc/ghc/-/wikis/commentary/rts/storage/heap-objects). For pattern matching on a constructor, how is the actual constructor checked? I can think of two ways it could work:
01:14:28 <mlugg> a) A word in the non-pointer area of the constructor specifies some ID for it
01:14:58 <mlugg> b) The info table pointer is compared, since (I believe) that'll always be the same for the same constructor
01:15:22 <mlugg> Although it may be something else entirely that I'm missing
01:18:04 <solonarv> mlugg: it's a)
01:18:52 <solonarv> that's why things like this work:
01:18:57 <solonarv> % unsafeCoerce Nothing :: Bool
01:18:57 <yahb> solonarv: False
01:19:16 <solonarv> % unsafeCoerce (Just 1) :: Bool
01:19:17 <yahb> solonarv: True
01:21:38 <mlugg> ty
01:22:19 <mlugg> I suppose also with (b) you couldn't do optimisations that I imagine are done with preventing duplicate info tables for constrs?
01:29:18 <[exa]> mlugg: you usually either know the whole info table at compile time, or are not supposed to touch the type at all because it's too generic. So no reason for info tables.
01:33:02 <mlugg> [exa]: Yeah, but I mean if I have two constructors for different types that happen to have the same layout and hence info table, you can decrease the binary size (at compile time) by just using the same info table for both (since the entry code for all constrs is basically a no-op), right?
01:33:41 <mlugg> Which wouldn't be possible if you did my second idea and used the info table addr to compare the constructor
01:50:47 <[exa]> mlugg: but we don't have info tables
01:51:14 <[exa]> (maybe I totally misunderstood it)
01:52:07 <[exa]> uh you mean the ones from STG
01:53:38 <mlugg> Wait I'm confused again
01:53:46 <mlugg> What do you mean we don't have info tables?
01:53:54 <[exa]> you mean the InfoTable struct from here, right? https://gitlab.haskell.org/ghc/ghc/-/wikis/commentary/rts/storage/heap-objects
01:54:24 <mlugg> Yup
01:55:06 <[exa]> by sharing the info table you'd likely assume that both objects with the shared table are of the same thunkiness (or forcedness) b/c of the same "closure type", right?
01:56:14 <mlugg> Yeah?
01:56:55 <ukari> why declarations of the same "apiVersion" not cause conflict in this code? shorturl.at/fquDL shorturl.at/kDJNO
01:58:20 <solonarv> ukari: please don't use url shorteners that way
01:58:45 <solonarv> next time just link the file ( https://github.com/expipiplus1/vulkan/blob/95b29e65fef6ece2a069b404d51b97e0cbaab5c5/src/Vulkan/Core10/DeviceInitialization.hs ) and say which lines you are talking about
01:59:10 <mlugg> ukari: The DuplicateRecordFields extension would allow that, maybe that's being enabled with a compiler flag or something?
01:59:32 <solonarv> yup, it's enabled in the cabal file
01:59:38 <solonarv> here: https://github.com/expipiplus1/vulkan/blob/95b29e65fef6ece2a069b404d51b97e0cbaab5c5/vulkan.cabal#L469
02:00:13 <ukari> https://github.com/expipiplus1/vulkan/blob/95b29e65fef6ece2a069b404d51b97e0cbaab5c5/src/Vulkan/Core10/DeviceInitialization.hs#L1249 and https://github.com/expipiplus1/vulkan/blob/95b29e65fef6ece2a069b404d51b97e0cbaab5c5/src/Vulkan/Core10/DeviceInitialization.hs#L1068
02:00:37 <ukari> thanks, solonarv
02:00:56 <solonarv> thanks, much better (also, keeping the https:// at the front makes the links clickable in most clients; without the https:// they often aren't)
02:05:46 <__monty__> For github git.io might be acceptable? That's guaranteed to point to something within github.
02:06:20 <solonarv> sure, I don't mind site-specific shortened URLs (e.g. youtu.be, redd.it)
02:21:58 <jchia1> How can I get rid of the "Redundant constraint" warning? https://gist.github.com/jchia/e9bb569ec0d311268b60346fe135ebb8
02:22:26 <phadej> remove redundant constraints
02:22:29 <phadej> or turn that warning off
02:22:42 <jchia1> phadej: i don't know why constraint to remove
02:22:54 <jchia1> which constraint to remove
02:22:58 <phadej> Redundant constraint: Eq (Element Prod)
02:23:01 <phadej> In an expression type signature:
02:23:04 <phadej> Eq (Element Prod) => Element Prod -> Prod -> Bool
02:23:10 <jchia1> I didn't write that constraint
02:23:24 <jchia1> maybe it's the library
02:23:38 <phadej> I'd recommend turning that warning off
02:23:43 <phadej> it's not enabled by -Wall
02:23:49 * hackage encryptable 0.1 - Typed encryption with persistent support  https://hackage.haskell.org/package/encryptable-0.1 (coingaming)
02:24:00 <phadej> except in few GHC releases (it was figured out, it was bad idea)
02:25:08 <jchia1> OK
02:35:42 <timCF> Hello! I have a question about hackage. I did a tar.gz bundle with `stack sdist` command, and uploaded in to hackage registry. I can see package itself, but there is no haddock online docs for some reason http://hackage.haskell.org/package/encryptable Am I supposed to upload documentation separately and how to do it?
02:37:25 <phadej> wait
02:37:31 <phadej> documentation is build asynchronously
02:37:41 <phadej> See Status
02:37:55 <phadej> "docs pending" "Build status unknown (no reports yet)"
02:38:41 <timCF> Thanks, phadej!
03:14:50 <cpressey> I see that Maybe is an instance of Alternative, but Either is not. I assume this is because there's no unique Either value that would sensibly serve as an identity element?
03:16:22 <cpressey> There's probably good reason for having an identity element, but, how much sense would it make to drop it, and have something that is only a semigroup over applicative functors?
03:17:25 <dibblego> quite a bit
03:17:39 <dibblego> https://hackage.haskell.org/package/semigroupoids-5.3.4/docs/Data-Functor-Alt.html
03:18:19 <cpressey> Oh interesting, thanks dibblego 
03:18:26 <Taneb> Hmm, should there be an instance Monoid e => Alternative (Either e)?
03:20:47 <maerwald> That's gonna be a mess with String :)
03:24:23 <phadej> there is Validation
03:24:34 <phadej> with various contexts
03:24:35 <Taneb> phadej: which doesn't have an Alternative instance
03:24:48 <phadej> if you use say semiring for e, that it could
03:25:01 <Taneb> Mmm
03:25:21 <maerwald> Taneb: https://hackage.haskell.org/package/either-5.0.1.1/docs/Data-Either-Validation.html#t:Validation
03:25:34 <maerwald>  (Semigroup e, Monoid e) => Alternative (Validation e)
03:25:44 <Taneb> maerwald: oh, I was looking at http://hackage.haskell.org/package/validation-1.1/docs/Data-Validation.html#t:Validation
03:26:29 <maerwald> it's a kmett package, so probably well thought through :p
03:27:08 <phadej> well, no
03:27:11 <phadej> that's a bit nonsense
03:27:24 <phadej> you get all errors
03:27:50 <phadej> not "x and y failed" or "z and w failed"
03:28:06 <phadej> if you do x <*> y <|> z <*> w
03:29:22 <tomsmeding> if I want to return a type containing existentially quantified type variables from a function, I have no other option than to define a new data type for that, have I?
03:30:34 <tomsmeding> if you do that a lot you end up in a similar situation to what you have with iterators/futures in Rust, where every function returns its own bespoke struct
03:30:53 <tomsmeding> it's not a problem per se, I was just wondering whether I'm overlooking something basic
03:31:12 <tomjaguarpaw> CPS and use forall?
03:31:53 <tomsmeding> that is actually a trick I already use somewhere, that would indeed be a valid answer to my question as stated
03:33:26 <tomjaguarpaw> Always happy to provide a valid answer to a question stated by a fellow Tom
03:33:46 <maerwald> Taneb: I just realised it isn't a monad
03:33:52 <tomsmeding> :D
03:34:20 <tomsmeding> interesting though, I hadn't yet spotted that duality, despite having used both approaches in the same codebase :)
03:34:34 <tomsmeding> thanks
03:34:44 <Taneb> maerwald: yes?
03:35:49 * hackage hledger-interest 1.6.0 - computes interest for a given account  https://hackage.haskell.org/package/hledger-interest-1.6.0 (PeterSimons)
03:43:47 <cpressey> The reason I even ask is that I've sort of stumbled across a way of writing pipelines with combinators that transform Either-producing functions and I'm trying to find out how much of this may have already been built in some other guise.
03:44:14 <cpressey> By "Either-producing function" I mean "(a -> Either e b)".
03:47:38 <cpressey> So I've learned >=> takes two Either-producing functions and sequences them like short-circuiting AND. But the equivalent of a short-circuiting OR seems not to exist as a common thing.
03:48:53 <cpressey> Even with Validation, <|> would work on two Validation values, but I would want a combinator, something that works on functions that produce those values, instead.
03:49:31 <cpressey> I can easily write this, of course, I'm just curious how much of it already exists and in what form.
03:50:25 <maerwald> short-circuiting OR?
03:51:28 <maerwald> you could only short-circuit on the Right value, which is a bit odd
03:51:50 <maerwald> for monad
03:51:52 <cpressey> I'm probably explaining this poorly
03:52:31 <cpressey> "a >=> b" evaluates b only if a returned a Right value.  "a <|> b" would evaluate b only if a returned a Left value.
03:54:13 <cpressey> Analogous to "do_this() && do_that()" and "do_this() || do_something_else()" in, say, Perl, or many other languages with short-circuiting boolean operators.
03:56:50 <maerwald> (Functor m, Monad m, Monoid e) => Alternative (ExceptT e m)
04:53:38 <phadej> https://mail.haskell.org/pipermail/cabal-devel/2020-September/010486.html cabal-install-3.4.0.0-rc2 please install and test
05:14:09 <dminuoso> 13:56:39        cpressey | [10:52:10] "a >=> b" evaluates b only if a returned a Right value.  "a <|> b" would evaluate b only if a returned a Left value.
05:14:13 <dminuoso> That sounds subtly incorrect.
05:14:19 <dminuoso> Whether or not b is evaluated is undecided.
05:14:35 <dminuoso> In both examples.
05:15:39 <dminuoso> (Or rather, there's nothing preventing GHC from always evaluating b)
05:17:06 <solonarv> you can talk about "does GHC necessarily evaluate it" or about "will GHC actually evaluate it in practice", those are separate questions
05:17:46 <dminuoso> solonarv: I think it's about something different. Im trying to hint at the fact that "evaluation" is different from "using it in some manner"
05:18:00 <solonarv> ah yes, fair enough
05:18:02 <dminuoso> I think they meant "evaluation" rather in the sense of "execution"
05:32:45 <cr0ssw1nd> hello
05:33:20 <cr0ssw1nd> what is the proper way to install profiling libraries?
05:33:21 <cr0ssw1nd> I installed haskell via stack IIRC
05:33:52 <cr0ssw1nd> when I do `stack build --profile` it fails because can't find profiling versions of base-4.12.0.0 and other packages
05:34:02 <cr0ssw1nd> not sure why it doesn't attempt to download them
05:34:21 <dminuoso> cr0ssw1nd: Which stack version are you using?
05:34:31 <dminuoso> Also, 4.12 is a bit old, isn't it? :)
05:34:34 <cr0ssw1nd> it's 2.3.3
05:34:51 <cr0ssw1nd> I dunno, that's what is used in the project, it isn't new one
05:35:05 <dminuoso> cr0ssw1nd: Well it should be as simple as just saying `stack --profile run foo --rts-options p`
05:35:37 <dminuoso> (you can also do this explicitly by first running build then exec, but really, manually running build is not necessary and will just unnecessarily require you re-specify the exact same flags to run anyhow. Might as well use run only.
05:36:19 <dminuoso> cr0ssw1nd: Is it possible you forgot to specify --profile on your exec call? Anyhow, just use `run` instead of `build and exec`. :)
05:36:52 <cr0ssw1nd> I try it with just `stack run --profile` but it reports the same
05:36:57 <cr0ssw1nd> without --profile it runs ok
05:37:10 <dminuoso> cr0ssw1nd: Can you gist/pastie the full output?
05:37:14 <cr0ssw1nd> yeah 1 sec
05:38:53 <cr0ssw1nd> dminuoso, https://pastebin.com/raw/CLgxYdNv
05:40:08 <cr0ssw1nd> this is the output of `stack run --profile`
05:40:40 <dminuoso> cr0ssw1nd: Are you on windows?
05:40:46 <cr0ssw1nd> nope, fedora
05:42:18 <dminuoso> That's curious
05:42:19 <cr0ssw1nd> can this line in ~/.stack/config.yaml affect stack behavior with profiling libs?
05:42:20 <cr0ssw1nd> system-ghc: true
05:42:39 <cr0ssw1nd> but I guess shouldn't
05:42:39 <dminuoso> cr0ssw1nd: Yes.
05:42:42 <cr0ssw1nd> hmm
05:42:50 <dminuoso> It's quite possible. If the system GHC doesnt come with profiling libraries, for whatever reason..
05:43:20 <dminuoso> How did you install the system ghc?
05:43:22 <cr0ssw1nd> ah, so it also affects which libraries are used.. 
05:43:33 <dminuoso> Yeah, the base libraries come with GHC itself.
05:43:35 <cr0ssw1nd> good question, IIRC via stack but I am checking now
05:45:15 <cr0ssw1nd> yeah, it comes from haskell-platform-2020 package actually
05:45:25 <cr0ssw1nd> I try to remove that line
05:47:35 <phadej> for system packager it makes sense to not install profiling libraries by default
05:48:00 <cr0ssw1nd> agree
05:48:11 <cr0ssw1nd> was sure that I installed haskell via stack actually
05:48:44 <dminuoso> Question, which libraries does GHC ship with? Is there a list somewhere?
05:48:50 <phadej> Package: ghc-8.10.1-prof -- Installed-Size: 616326
05:48:56 <phadej> I think that's the size in kilobyes
05:49:01 <dminuoso> Is that all the directories under libraries/ in the ghc git repo?
05:49:03 <phadej> so 616MB
05:49:13 <phadej> dminuoso: ghc-pkg list
05:49:17 <phadej> no
05:49:22 <phadej> libraries/ has more stuff
05:50:03 <dminuoso> phadej: That trick works only if Ive never used cabal v1-* commands (or manually registering packages, even) right?
05:51:53 <phadej> why would you (use cabal v1- commands). For me they don't exist.
06:03:03 <p0a> Hello, suppose I want to use f() in Haskell code, https://termbin.com/dccr , how would I accomplish this?
06:05:11 <olle> ffi?
06:05:44 <p0a> right, but what are the details?
06:09:06 <phadej> http://book.realworldhaskell.org/read/interfacing-with-c-the-ffi.html
06:10:59 <p0a> thankyou 
06:15:32 <p0a> phadej: the files referred to in this book, such as ch17/SimpleFFI.hs, are they available somewhere?
06:17:59 <phadej> I don't remember, check introductionary chapters of the book
06:18:27 <yushyin> p0a: https://downloads.haskell.org/ghc/latest/docs/html/users_guide/ffi-chap.html https://wiki.haskell.org/Foreign_Function_Interface may be also of some use
06:20:18 <phadej> ghc manual is good, but it's easier to understand when you have some idea of how FFI works
06:25:39 <p0a> it seems that newForeignPtr from Foreign.ForeignPtr is how this is done 
06:26:26 <p0a> to inform GC that the result of f() needs to be freed at some point
06:26:45 <p0a> I guess all this is happening inside haskell's f, which calls newForeignPtr and c_f, etc
06:27:31 <p0a> great, thank you! 
06:50:27 <kiwi_45> Hello All
06:51:01 <kiwi_45> a little bit complex problem to explain but I try
06:51:03 * dminuoso smells a servant question on the horizon
06:51:33 <kiwi_45> dminuosoYeah related to servant
06:52:00 <boxscape> how did you do that dminuoso
06:53:21 <dminuoso> boxscape: What can I say. Cryptographers around the world request my presence every time they want to implement their proofs involving oracles.
06:53:26 <dminuoso> Im just that good.
06:53:32 <boxscape> amazing
06:53:58 <kiwi_45> I want to implemnt a function which takes a type level list (available at compile time) and a value and I want to check whether that value is one from that type level list or not, just this!
06:55:16 <dminuoso> May I introduce you to
06:55:25 <dminuoso> https://hackage.haskell.org/package/singletons
06:55:57 <dminuoso> (It would be more helpful if you explained what your general goal is, because this smells more like a XY problem)
06:56:09 <dminuoso> Given what I know about you. :)
06:56:50 <kiwi_45> https://uploads.kiwiirc.com/files/a1bc6469aa6983a9ed1bb4997161990a/pasted.txt
06:57:11 <kiwi_45> dminuoso: to me ?
06:58:01 <dminuoso> Yes.
07:00:06 <dminuoso> This line of programming essentially leads you to dependently typed programming powered by singletons.
07:00:42 <dminuoso> Though, I have a feeling, that you're astray on the wrong path perhaps because you don't understand the servant facilities well enough.
07:00:50 <dminuoso> Hard to say without knowing why you think you need this
07:02:52 <kiwi_45> dminuoso: okay I'm ready to explain a bit
07:02:58 <kiwi_45> why I need this
07:03:26 <kiwi_45> I am defining my API like this `(Auth auths (UserAtLeast 'UManager) :> ProtectedAPI)
07:03:26 <kiwi_45>     :<|> 
07:03:27 <kiwi_45>       UnProtectedAPI`
07:03:55 <kiwi_45> I am defining my API like this `(Auth auths (UserAtLeast 'UManager) :> ProtectedAPI)
07:03:56 <kiwi_45>     :<|> 
07:03:56 <kiwi_45>       UnProtectedAPI```
07:04:09 <kiwi_45> sorry I don't know the formatting here
07:05:05 <kiwi_45> where my protectedAPI will only be accessed with authenticated users of which have userType or role / permission of Manager
07:05:13 <kiwi_45> this was working fine 
07:05:36 <kiwi_45> I had a mechanism to convert this type to term level and then compare 
07:06:53 <kiwi_45> now while this was working perfectly I needed to modify the use case that, now I want to define my API with exact auth usertypes, like --
07:07:51 <kiwi_45> (Auth auths (AuthUserTypes ['UManager, 'UAdmin], 'UGuest]) :> ProtectedAPI)
07:08:38 <kiwi_45> so I can write a check in auth check part and that endpoint will only be accessible with users of specified types 
07:09:30 <kiwi_45> dminuoso: did you got the context ?
07:10:03 <dminuoso> Im heading off.
07:10:43 <kiwi_45> dminuoso: Thank you for the support :)
07:12:54 <petersen> Is there some trick/method to generating cbits/ ?
07:16:57 <dmwit> petersen: c2hs, hsc2hs
07:17:40 <petersen> dmwit: aha, they generate them?
07:18:05 <dmwit> I don't remember exactly what they do; it's been a while. I think there's still a fair bit of manual work. But less guesswork. Or something.
07:18:19 <dmwit> Check out their documentation for details on what they can do; as I recall both have very thorough writeups.
07:18:30 <petersen> That / was very deliberate
07:18:33 <petersen> Okay
07:19:41 <dmwit> ...but I believe there is currently no tool more automatic than those.
07:33:46 <kuribas> what's a good beginners book for haskell?
07:34:14 <kuribas> I personally liked "Real world haskell", but it hasn't been updated since I read it ten years ago.
07:34:37 <wavemode> haskell programming from first principles
07:35:58 <boxscape> https://www.cis.upenn.edu/~cis194/spring13/lectures.html seemed nice to me but I already knew haskell when I found out about it
07:37:00 <kuribas> yeah, it's nice also
07:41:09 <kuribas> wavemode: that's 60$ for just an ebook?
07:43:48 <tomsmeding> I remember that cabal v1 didn't have an 'uninstall' command, but now v2 still doesn't have one. Is there a reason why cabal v2 can't have a command to remove unused packages from the global store?
07:44:18 <hyiltiz> Is there something like https://cheats.rs/ for haskell?
07:44:41 <tomsmeding> (or, if "unused" is too poorly specified, I'm fine with a command that removes all reverse dependencies of a particular package; I'll figure out myself seeing the list if I want that or not)
07:45:54 <petersen> tomsmeding: I think cab could do that - but only for global packages yeah
07:46:05 <tomsmeding> it could?
07:46:26 <petersen> Ah wait no - it can only unregister them hmm
07:46:28 <dolio> What if one of the reverse dependencies is a dependency of something else?
07:46:36 <tomsmeding> what I remember is that there was 'ghc-pkg unregister' which doesn't actually remove something, and to actually clear up disk space you'd have to just manually remove stuff and hope you don't break too much
07:46:38 <tomsmeding> that doesn't count :p
07:46:43 <petersen> NOd
07:46:46 <tomsmeding> dolio: transitive reverse dependencies :p
07:47:26 <wavemode> there is a package cabal-uninstall which does that
07:47:33 <petersen> oh
07:47:38 <dolio> Oh, actually, I was thinking backwards. However, I think it will randomly break stuff.
07:47:40 <tomsmeding> okay sure if that second option is to be the command, I also want a full dependency graph of the global store, but I guess that's not the problem anymore at that point
07:48:10 <dolio> Because there will be locations on disk that cabal has no way of knowing about that could refer to the things you're removing.
07:48:24 <petersen> Right
07:48:35 <phadej> "why cabal-install doesn't have uninstall", because it doesn't need one
07:48:35 <dolio> Probably including executables.
07:48:36 <petersen> Same story with stack too
07:48:42 <phadej> rm ~/cabal/bin/exe
07:48:43 <phadej> done.
07:49:03 <tomsmeding> phadej: that doesn't help, that only removes the executable, not the gigabytes of libraries that were used in building that executable :p
07:49:08 <petersen> right
07:49:09 <tomsmeding> which is of course the whole point why I want this in the first place
07:49:13 <wavemode> it does help discourage the risky practice of installing packages globally in the first place
07:49:44 <phadej> tomsmeding: that's an open issue https://github.com/haskell/cabal/issues/3333
07:50:03 <petersen> easy to remember
07:50:04 <tomsmeding> wavemode: does that just remove the relevant package from the store, erroring out if anything's in the store that still depends on it?
07:50:06 <phadej> if you are brave, you could use `cabal-store-gc` from https://github.com/phadej/cabal-extras
07:50:15 <phadej> but I give NO guarantees that it doesn't screw you
07:51:02 <wavemode> tomsmeding: afaik it just forcibly unregisters the package and deletes the folder. so it will break other packages if they depend on it
07:51:07 <tomsmeding> phadej: fascinating
07:51:27 <tomsmeding> wavemode: its readme says: "If cabal-uninstall is called with the parameter --force, then this parameter is passed to ghc-pkg unregister to unregister a package even if it breaks other packages."
07:53:12 <quickquestion> hi- I'm working through the book Haskell programming from 1st principles
07:53:25 <quickquestion> There's an example that looks like:
07:53:29 <quickquestion> jung :: Ord a => [a] -> a
07:53:35 <quickquestion> jung xs = head (sort xs)
07:53:47 <quickquestion> When running this in my notebook, ghci suggests using minimum
07:54:02 <dolio> Wow.
07:54:04 <quickquestion> What's the magic happening behind the scenes, in detail?
07:54:11 <wavemode> because that's what it's doing
07:54:11 <phadej> tomsmeding: removing an exe would remove the root retaining stuff in the store, and then stuff could be pruned
07:54:32 <quickquestion> I udnerstand that they're equal, what process does haskell go through to come to this conclusion?
07:54:36 <quickquestion> Because it's amazing
07:54:49 <dolio> What do you mean 'notebook'?
07:54:51 <phadej> HLint?
07:54:55 <phadej> aka hardcoded rule
07:54:58 <wavemode> ohh now I get what you're asking
07:55:03 <wavemode> yeah it's hardcoded rules
07:55:16 <tomsmeding> bummer :p
07:55:25 <tomsmeding> phadej: I'll have a look
07:55:33 <quickquestion> dolio IHaskell + jupyter for the sake of readability when working
07:55:38 <quickquestion> rather than ghci in a terminal
07:55:46 <dolio> Oh, okay.
07:56:09 <dolio> Yeah, 'Haskell' won't do that normally. :)
07:56:11 <quickquestion> @wavemode :(  so it's not being derived through signatures or some other magic math?
07:56:12 <lambdabot> Unknown command, try @list
07:56:27 <wavemode> everyone goes through the brief phase of thinking hlint is magical :p
07:56:27 <dolio> It's an extra tool probably being used by your setup.
07:57:17 <quickquestion> Darn, I was so excited
07:57:24 <quickquestion> It is in fact hlint
07:57:27 <quickquestion> Still nice
07:57:36 <quickquestion> So it's hardcoded :(
07:58:23 <quickquestion> In theory would it be possible dynamically or is signature matching not detailed enough
07:59:11 <boxscape> the signature is usually not enough to tell you exactly what a function does
07:59:40 <quickquestion> Yea that's whatI was thinking
07:59:42 <boxscape> you'd have to examine the implementation
07:59:44 <quickquestion> just the argument and return types
08:00:07 <quickquestion> Not sure if hask has introspection but I could iamgine that would get messy
08:01:34 <boxscape> hm, anyone know if the performance of head . sort is O(n) or O(n log n)?
08:01:46 <boxscape> s/performance/runtime
08:02:27 <wavemode> can sorting be done lazily? my intuition says no
08:02:39 <dolio> It's a little lazy.
08:02:58 <dolio> At least, last I checked.
08:03:09 <solonarv> lazily enough for head . sort to be O(n), last I checked
08:03:16 <boxscape> ok, nice
08:03:21 <hyiltiz> it doesn't sort first then lazily gets head; it lazily gets the head of the lazy sort; depends on the sort implementation
08:04:00 <hyiltiz> if sort implementation provides max/min without also crunching thru everything else, lazy eval should stop there
08:04:24 <dolio> Well, the point is that the implementation in GHC is a bottom-up merge sort that doesn't require the entire list to be sorted just to get the first element.
08:04:38 <dolio> Again, last I checked.
08:08:17 <thebnq> @src sort
08:08:17 <lambdabot> sort = sortBy compare
08:08:22 <thebnq> @src sortBy
08:08:23 <lambdabot> -- The actual definition used by GHC is an optimised mergesort.
08:08:23 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
08:08:31 <dolio> Hahaha.
08:09:19 <phadej> even with insert sort you get O(n) for head . sort
08:14:17 <boxscape> bubblesort losing out once more
08:14:24 <tomsmeding> phadej: indeed cabal-store-gc messed up my store :)
08:14:26 <tomsmeding> yay
08:14:39 <phadej> they you can try cabal-store-check if it finds a culprit
08:15:27 <tomsmeding> doesn't find anything broken, apparently
08:16:00 <tomsmeding> like, there wasn't much important stuff in there so I don't care much (which is why I dared to run cabal-store-gc anyway)
08:16:07 <tomsmeding> still, funny
08:16:15 <phadej> how it is broken_
08:16:56 <tomsmeding> I had assumed that cabal v2 installed packages in a form so that their dependency relations are easily introspectable, so that an uninstall-like command would be relatively easy
08:17:02 <tomsmeding> but apparently not so :)
08:17:48 <tomsmeding> phadej: I noticed it's broken because I tried to build an existing haskell project, and it failed with the following output:
08:18:03 <tomsmeding> https://paste.tomsmeding.com/ZKrdOfTp
08:18:34 <tomsmeding> I removed the dist-newstyle folder of that project before running cabal build
08:18:41 <phadej> ok
08:18:58 <phadej> try to rm -rf distributive-0.6.2-9b1f8f3e01d3b3504fbe1e6d17382e6fc2da91f87c747168a5620bdb5f845fda inside the ~/cabal/store/yourghc
08:19:04 <phadej> and run cabal-store-gc again
08:19:16 <phadej> a
08:19:19 <phadej> but before removing it
08:19:28 <phadej> can you paste the cabal-hash.txt from distributive-0.6.2-9b1f8f3e01d3b3504fbe1e6d17382e6fc2da91f87c747168a5620bdb5f845fda
08:20:11 <tomsmeding> phadej: cabal-hash.txt of that distributive-*-9b* contains https://paste.tomsmeding.com/RzQL9W3N
08:21:18 <phadej> I have an idea why some dependency of that pkg got removed, I have to improve cabal-store-check to point out those issues
08:21:34 <phadej> (which in fact is another cabal issue, to have a command to check the health of the store)
08:21:50 <phadej> there is cache, which may or may not be out of sync
08:22:24 <tomsmeding> happy that I could provide a testcase for your tool :p
08:22:31 <tomsmeding> is there more you'd like to inspect?
08:22:42 <phadej> no, remove that folder and run cabal-store-check
08:23:22 <tomsmeding> lol 1 directly broken library components, 27 transitively broken libraries, 5 broken executable components
08:23:50 <phadej> yes, then you can try to run cabal-store-check --repair
08:23:55 <phadej> (which will jsut remove then)
08:24:12 <phadej> and after that you could try to build your project again
08:24:32 <phadej> (and you might want to remove and reinstall the "5 broken executable components")
08:24:56 <phadej> if they are linked to ~/.cabal/bin
08:25:10 <tomsmeding> which runs, but outputs: https://paste.tomsmeding.com/H66ZMp7y (note the error)
08:25:32 <tomsmeding> ah yes basically everything in ~/.cabal/bin is broken now 🎉
08:25:39 <phadej> hmm
08:25:46 <phadej> what your ghc --info outputs
08:25:59 <phadej> specifically LibDir
08:26:11 <tomsmeding> LibDir is "/home/tom/.ghcup/ghc/8.8.4/lib/ghc-8.8.4"
08:26:26 <phadej> and Global Package DB is ?
08:26:33 <tomsmeding> "/home/tom/.ghcup/ghc/8.8.4/lib/ghc-8.8.4/package.conf.d"
08:26:48 <phadej> hmm
08:26:53 <phadej> weird
08:27:05 <phadej> that looks like a bug in cabal-store-check then
08:27:24 <phadej> it does /home/tom/.ghcup/ghc/8.8.4/lib/ghc-8.8.4/bin/ghc-pkg recache --package-db=/home/tom/.cabal/store/ghc-8.8.4/package.db
08:27:27 <phadej> which is correct
08:27:34 <phadej> but why ghc-pkg tries to /home/tom/.ghcup/ghc/8.8.4/lib/ghc-8.8.4/lib
08:27:40 <tomsmeding> though my other project builds again
08:27:58 <tomsmeding> yes that's also what I found strange, that path is not given to it
08:28:06 <phadej> can you check what /home/tom/.ghcup/ghc/8.8.4/lib/ghc-8.8.4/bin/ghc-pkg is
08:28:13 <phadej> is it an exe or some script
08:28:37 <tomsmeding> it's a haskell executable
08:29:01 <tomsmeding> (i.e. it starts with 'ELF' and depends on some libHS* libraries :p)
08:30:05 <phadej> what if you just run that command from your dir
08:30:05 <phadej> /home/tom/.ghcup/ghc/8.8.4/lib/ghc-8.8.4/bin/ghc-pkg recache --package-db=/home/tom/.cabal/store/ghc-8.8.4/package.db
08:30:15 <tomsmeding> "from your dir"?
08:30:18 <phadej> home dir
08:30:40 <tomsmeding> exactly the same error
08:30:59 <quickquestion> another quick q: why does vv f a = f a provide a signature of (t1 -> t2) -> t1 -> t2
08:31:06 <tomsmeding> phadej: misconfiguration somewhere?
08:31:23 <quickquestion> :t
08:31:25 <tomsmeding> quickquestion: what would you expect instead? :)
08:31:54 <tomsmeding> it takes an argument of type t1 -> t2, an argument of type t1, and produces a result of type t2
08:31:55 <quickquestion> Not sure. The functions takes a function and arg a, calls f on a
08:31:58 <phadej> tomsmeding: what if you remove --package-db=/home/tom/.cabal/store/ghc-8.8.4/package.db/package.cache 
08:32:02 <phadej> tomsmeding: what if you remove --package-db=/home/tom/.cabal/store/ghc-8.8.4/package.db/package.cache.lock
08:32:04 <quickquestion> so I imagined t1 -> t2
08:32:10 <phadej> and then try to recache
08:32:24 <quickquestion> tomsmeding: it takes an argument of type t1 -> t2
08:32:26 <phadej> if it doesn't work, you might need to
08:32:36 <quickquestion> Could you expand on why that is
08:32:42 <phadej> /home/tom/.ghcup/ghc/8.8.4/lib/ghc-8.8.4/bin/ghc-pkg init --package-db=/home/tom/.cabal/store/ghc-8.8.4/package.db
08:32:44 <quickquestion> I'm not sure I grok the syntax for (->)
08:33:03 <Chi1thangoo_> it takes a function that turns a into b (t1 -> t2), as its first argument, it takes a as its second argument (t1) and returns b (t2) quickquestion 
08:33:08 <phadej> i.e. "remove the cache, and recreate it"
08:33:12 <tomsmeding> phadej: do you mean to remove those two files, i.e. ignore "--package-db" in your messages?
08:33:20 <phadej> tomsmeding: yeah
08:33:50 <tomsmeding> phadej: FYI I'm happy to throw my entire store away and start afresh if that's easier
08:33:51 <quickquestion> Chi1thangoo_: thanks :)
08:34:02 <tomsmeding> though if you want to debug what's happening, I'm happy continuing :)
08:34:15 <phadej> tomsmeding: yeah, I want to see what might fix it
08:34:53 <tomsmeding> removing those package.cache{,.lock} files and then running the same recache command gives the same error
08:35:06 <phadej> that sounds like a GHC bug
08:35:16 <tomsmeding> I'll run your init command
08:35:22 <phadej> because I have no idea how anything could work
08:35:30 <phadej> try that
08:35:33 <tomsmeding> heh 'ghc-pkg: command-line syntax error'
08:36:05 <quickquestion> actually, Chi1thangoo_, I'm still a little confused
08:36:20 <phadej> tomsmeding: with /home/tom/.ghcup/ghc/8.8.4/lib/ghc-8.8.4/bin/ghc-pkg init --package-db=/home/tom/.cabal/store/ghc-8.8.4/package.db ?
08:36:24 <quickquestion> I understand the breakdown, but how do we read (t1 -> t2) -> t1 -> t2 logically
08:36:38 <quickquestion> or in simple English
08:36:51 <monochrom> Simple English is not ready for this.
08:36:54 <tomsmeding> phadej: https://paste.tomsmeding.com/H15A8ZWb
08:37:00 <quickquestion> Aha okay
08:37:24 <tomsmeding> quickquestion: what language do you understand better than english? :)
08:37:39 <monochrom> You have a bit of a nesting structure there in "(t1 -> t2) -> t1 -> t2".  aka "(t1 -> t2) -> (t1 -> t2)"
08:37:52 <quickquestion> tomsmeding: russian will do
08:37:54 <quickquestion> :)
08:38:00 <monochrom> https://www.smbc-comics.com/comic/language
08:38:03 <phadej> tomsmeding: ah, drop the --package-db
08:38:06 <monochrom> not simple English
08:38:08 <phadej> just ghc-pkg init <path>
08:38:25 <tomsmeding> phadej: 'ghc-pkg: cannot create: /home/tom/.cabal/store/ghc-8.8.4/package.db already exists'
08:38:29 <tomsmeding> remove that whole directory? :)
08:38:48 <phadej> well, that's kind of "remove the store"
08:38:51 <phadej> so yes
08:39:03 <phadej> I'm sorry, but I have no idea why recache doesn't work
08:39:07 <quickquestion> monochrom - can you elaborate on the nesting structure?
08:39:09 <tomsmeding> monochrom: :D
08:39:10 <monochrom> If you accept incomprehensible English, then it is: function from (function from t1 to t2) to (function from t1 to t2)
08:39:19 <phadej> because that's about the command `cabal-install` calls when installing stuff there
08:39:30 <phadej> tomsmeding: one more thing
08:39:35 <quickquestion> Hmmmm
08:39:38 <tomsmeding> interesting
08:39:40 <phadej> what's `which ghc-pkg` does
08:39:43 <phadej> says
08:39:49 <phadej> does that one point to some script
08:39:53 <quickquestion> How does that make sense exactly
08:40:01 <quickquestion> we have a function from t1 to t2
08:40:09 <quickquestion> but then we pass it a t1 yielding a t2
08:40:14 <monochrom> Another way, thinking morally that there are 2 parameters: function from (function from t1 to t2) and t1 to t2.
08:40:17 <quickquestion> or invoke it on a t1 yielding t2
08:40:51 <phadej> tomsmeding: and are you on linux or mac or ..?
08:41:05 <phadej> I suspect not mach
08:41:09 <phadej> because /home, not some /Users
08:41:18 <phadej> I'm clueless
08:41:28 <tomsmeding> phadej: /home/tom/.ghcup/bin/ghc-pkg, which is a script that executes /home/tom/.ghcup/ghc/8.8.4/lib/ghc-8.8.4/bin/ghc-pkg --global-package-db /home/tom/.ghcup/ghc/8.8.4/lib/ghc-8.8.4/package.conf.d
08:41:33 <monochrom> See if you have "x * (sqrt(y + 2x^2) + z)" you don't ask for simple English. The whole point of writing down a formula.
08:41:33 <quickquestion> to -> is a from to?
08:41:33 <tomsmeding> and also arch linux
08:41:51 <quickquestion> See I;m having difficulty reading it in my mind
08:41:54 <quickquestion> it doesn't register
08:41:57 <glguy> quickquestion: (a -> b) is the type of functions that expect an a argument and produce a b result
08:41:59 <phadej> hmm, why that ghc-pkg script has that --global-package-db thing
08:42:30 <tomsmeding> phadej: I can also just send you the entire script: https://paste.tomsmeding.com/QBnAPx4a
08:42:34 <monochrom> X->Y is the type of functions with domain X, codomain Y. "function from X to Y".
08:42:42 <phadej> ok, that's similar on my machine too
08:42:44 <tomsmeding> phadej: also interesting sidenote is the duplicate shebang
08:42:52 <phadej> blargh
08:42:56 <monochrom> Oh today it happens that X = t1->t2, y = t1->t2.
08:43:42 <tomsmeding> phadej: shall I just rm -r ~/.cabal/store? :)
08:43:55 <phadej> tomsmeding: it's enough to remove that single ghc version part
08:43:58 <monochrom> See if you have ""x * (sqrt(y + 2x^2) + z)", here are several things you can do to comprehend it.
08:43:59 <phadej> if you have others
08:44:02 <tomsmeding> fair point
08:44:06 <phadej> they are independent, so no need to remove everything
08:44:11 <phadej> or wait
08:44:11 <tomsmeding> though no I do not
08:44:23 <phadej> so we are now in the state that you don't have package.db/package.cache there
08:44:25 <monochrom> Sometimes you zoom out and say: it's x * (foo + z), foo is some complicated sqrt thing, I don't care for now.
08:44:26 <phadej> am I correct?
08:44:30 <tomsmeding> except a 'roots' directory with I guess cabal-store-gc created
08:44:33 <phadej> could you try to `cabal build` some of your package
08:44:39 <phadej> s
08:44:40 <phadej> projects
08:44:44 <monochrom> Some other times you zoom in and say: oh foo = sqrt(y + 2x^2)
08:44:46 <phadej> which would install dependencies
08:44:48 <phadej> does that still work
08:44:49 <monochrom> etc etc
08:44:56 <phadej> (and run with cabal build -v2)
08:44:59 <tomsmeding> phadej: indeed I do not have a package.db/package.cache
08:45:10 <quickquestion> I see
08:45:16 <phadej> because if cabal-install manages to install something there, then I think the store is fine
08:45:27 <phadej> tomsmeding: oh!
08:45:31 <phadej> now I know
08:45:33 <phadej> could you run
08:45:39 <phadej> the recache command
08:45:39 <tomsmeding> phadej: no building a different project doesn't work, it errors with: "ghc: there is no package.cache in /home/tom/.cabal/store/ghc-8.8.4/package.db even though package database is not empty" (as expected)
08:45:44 <phadej> but by calling ghc-pkg
08:45:54 <phadej> i.e. the wrapper script
08:46:07 <tomsmeding> "$ ghc-pkg recache --package-db=/home/tom/.cabal/store/ghc-8.8.4/package.db" ?
08:46:09 <phadej> yes
08:46:16 <tomsmeding> exit 0
08:46:20 <phadej> nice
08:46:26 <phadej> and now project builds?
08:46:45 <tomsmeding> it does!
08:46:50 <phadej> good
08:47:01 <phadej> I now know why cabal-store-check failed
08:47:05 <phadej> I'll fix that
08:47:08 <tomsmeding> yay!
08:47:15 <phadej> thank you very much for bearing with me
08:47:22 <tomsmeding> so my store is in working order again? (except missing stuff)
08:47:32 <tomsmeding> s/stuff/packages/
08:47:43 <tomsmeding> phadej: no problem :)
08:47:59 <phadej> yes, I think it's fine
08:48:07 <phadej> you can remove it later, if it turns out to not be :)
08:48:41 <tomsmeding> sure :p
08:49:14 <phadej> remember to `cabal install` stuff you had in bin
08:49:15 <phadej> sorry for that
08:49:20 <tomsmeding> doing that right now :p
08:49:45 <phadej> (I in fact have a script in my dotfiles repo, to do that, as I occasionally do)
08:50:23 <phadej> ...do mess up my Haskell setup
08:50:52 <phadej> yet now my store is 130G in size. Precisous binaries
08:51:30 <tomsmeding> 130G ö
08:52:01 <phadej> 22 haddocks, and that's just ones compiled with GHC-8.6.5
08:52:04 <phadej> err
08:52:06 <phadej> pandocs, not haddocks
08:52:14 <tomsmeding> why do you have 22 pandocs
08:52:20 <tomsmeding> maybe let's start there
08:52:30 <phadej> because I'm hackage trustee :/
08:52:40 <phadej> building stuff with different dependencies
08:52:51 <tomsmeding> right
08:54:03 <phadej> (so I'm somewhat motivated to have cabal-store-gc "working" ;) )
08:54:25 <tomsmeding> yes I can imagine :p
08:54:30 <tomsmeding> my store is tiny by comparison
08:55:36 <phadej> but cabal-store-check and cabal-store-gc are unfortunately broken for you, so please don't use until I fix https://github.com/phadej/cabal-extras/issues/31
08:56:18 * hackage managed 1.0.8 - A monad for managed values  https://hackage.haskell.org/package/managed-1.0.8 (GabrielGonzalez)
08:57:00 <tomsmeding> :)
08:57:18 <tomsmeding> phadej: unrelated: LaTeX doesn't seem to be working on your gists page https://oleg.fi/gists/posts/2019-11-07-semi-semi-semi-semi.html
08:58:03 <phadej> it works, but that particular block is screwed somehow. Let me check
08:58:23 <phadej> (you can see fancy some other math images in that post)
08:59:12 <tomsmeding> ah so indeed, there are a couple of working svg's
09:00:51 <phadej> fied
09:00:54 <phadej> fixed
09:01:28 <tomsmeding> ooh niec
09:01:31 <tomsmeding> *nice
09:02:10 <phadej> it was a markup screwup. Previously pandoc just ignored it
09:03:34 <tomsmeding> one of the 22
09:03:51 <phadej> but then I made it process unknown latex blocks too
09:04:16 <phadej> (to get even more svgs in my blog posts)
09:04:56 <phadej> (I'm crazy person, some of my blogposts are typeset in latex, though majority is in markdown)
09:05:05 * tomsmeding likes latex
09:05:23 * tomsmeding s/latex/LaTeX/
09:05:27 * tomsmeding just to be clear
09:05:28 <phadej> in fact you can tell. https://oleg.fi/gists/posts/2020-08-28-indexed-fixpoint.html has inline codehighlighting
09:05:38 <phadej> => source is .tex
09:06:14 <phadej> but markdown doesn't let you differentiate between `monospace` and `code`
09:07:05 <phadej> sadly, pandoc recognises only a very tiny subset of .tex
09:07:32 <tomsmeding> though, supporting a significant subset of TeX would mean _being_ TeX basically
09:08:27 <phadej> Actually I haven't tried how \paragraph{foo} is rendered through pandoc. And I miss \begin{definition} \end{definition} (or example) blocks
09:08:43 <phadej> definition,lemma,theorem,example,remark would be nice to have
09:08:51 <phadej> exercise
09:09:46 <phadej> I have no idea if pandoc's AST supports such constructions
09:10:26 <questions> Still working on groking type signatures, could someone try break down what's happening here?
09:10:27 <questions> arith :: Num b => (a -> b) -> Integer -> a -> barith f a b = f b + fromInteger a
09:10:33 <questions> arith :: Num b => (a -> b) -> Integer -> a -> b
09:10:35 <questions> arith f a b = f b + fromInteger a
09:10:37 <questions> there we go
09:10:56 <phadej> anyway, I have coded too much "just to be able to blog" than average person, so i'm fine :P
09:11:11 <monochrom> You can take it morally as a function that takes 3 parameters.
09:11:23 <monochrom> 1st parameter is a function from a to b
09:11:29 <monochrom> 2nd is an integer
09:11:37 <monochrom> 3rd is something of type a
09:11:44 <questions> yielding type b
09:11:45 <monochrom> The codomain is b.
09:11:45 <questions> ?
09:11:49 <monochrom> yes
09:12:00 <questions> Also what do you mean by take it morally
09:12:09 <questions> I've never heard someone use that phrase
09:12:23 <monochrom> Because formally it's (a->b) -> (Integer -> (a -> b))
09:12:46 <monochrom> formally it's X->Y again, but Y is a function type.
09:13:03 <questions> Ok I have a new question- how do you know where to group the terms
09:13:17 <questions> I'm having a lot of difficulty with visualizing it
09:13:36 <monochrom> Memorize the rule "-> associates to the right"
09:13:51 <phadej> questions: if someone writes `1 - 2 - 3` you know how to parenthesi it, don't you?
09:13:59 <phadej> similarly you learn to do that with -> as n operator
09:14:00 <monochrom> How do you know x-y-z-t means ((x-y)-z)-t?
09:14:05 <phadej> monochrom: :)
09:14:11 <questions> Right, ok
09:14:55 <monochrom> My http://www.cs.utoronto.ca/~trebla/CSCC24-2020-Summer/02-haskell-types-1.html  has the 1st half about this.
09:15:35 <questions> Is that a 2nd year course
09:15:41 <monochrom> 3rd
09:15:49 <phadej> so wrong, my cabal-install-3.4-rc2 availability announcement tweet gets less impressions than my (mediocre at best) shitposting tweets
09:16:40 <ridcully> questions: i am working through the book too (right now).  the most important mental stops for me are `::`, `=>`, and then all the `->`.  i ignore the currying thats happening and read the `->` as "it's all args and then the last one is the result"
09:17:22 <questions> I've been trying to do that
09:17:37 <phadej> sometimes it helps to pretend that Haskell has n-ary functions, sometimes it helps to remember that a -> b -> c is a -> (b -> c) i.e. a function returning function
09:17:43 <questions> But seeing how they chain to one another is quite confusing
09:18:42 <questions> phadej - it's not the other way around? i.e. (a -> b) -> c
09:18:57 <phadej> questions: think about the difference, I won't tell you
09:20:06 <phadej> (a -> b) -> c and a -> (b -> c) are different. Maybe thinking about the difference will make it click for you.
09:20:13 <ridcully> questions: if arguments (types thereof) are (... -> ...) that is passing in a function - if it's (..., ...) it's a tuple
09:21:59 <questions> Ok, so by default, Haskell is right associative
09:22:22 <phadej> no
09:22:25 <phadej> -> is right associative
09:22:28 <questions> back to square 1
09:22:43 <phadej> (in fact, oeprators by default, i.e. if not otherwise specified are left associative)
09:22:52 <questions> Ok, so in arith f a b = f b + fromInteger a
09:22:57 <phadej> % :i (+)
09:22:57 <yahb> phadej: type Num :: * -> Constraint; class Num a where; (+) :: a -> a -> a; ...; -- Defined in `GHC.Num'; infixl 6 +
09:23:08 <phadej> look, that one is infixl 6 +
09:23:11 <phadej> l is left associative
09:23:14 <phadej> % :i (-)
09:23:15 <yahb> phadej: type Num :: * -> Constraint; class Num a where; ...; (-) :: a -> a -> a; ...; -- Defined in `GHC.Num'; infixl 6 -
09:23:18 <phadej> same for -
09:23:19 <phadej> so 
09:23:26 <phadej> % 5 - 3 - 1
09:23:26 <yahb> phadej: 1
09:23:31 <phadej> works as you'd expect
09:23:37 <questions> Right, my mistake
09:23:43 <questions> so in the function I mentioned
09:23:53 <phadej> % i (->)
09:23:53 <yahb> phadej: ; <interactive>:8:4: error: parse error on input `->'
09:23:56 <questions> f a b = f b + fromInteger a is evaluated as (fb) + (fromInteger a)?
09:23:57 <phadej> % :i (->)
09:23:57 <yahb> phadej: type (->) :: * -> * -> *; data (->) a b; -- Defined in `GHC.Prim'; infixr -1 ->; instance Applicative ((->) r) -- Defined in `GHC.Base'; instance Functor ((->) r) -- Defined in `GHC.Base'; instance Monad ((->) r) -- Defined in `GHC.Base'; instance Monoid b => Monoid (a -> b) -- Defined in `GHC.Base'; instance Semigroup b => Semigroup (a -> b) -- Defined in `GHC.Base'; instance [safe] (PrintfArg a, HPrin
09:24:07 <phadej> ok, that's too long, so you don't see its infixity
09:24:22 <solonarv> no, you do
09:24:25 <solonarv> it's near the start
09:24:29 <phadej> ah, it's there
09:24:30 <phadej>  true
09:24:33 <phadej> sorry, my bad.
09:24:41 <solonarv> 'infix -1 ->' which is not something you can actually write
09:24:53 <dolio> It's true, he didn't see it. :)
09:25:13 <solonarv> questions: yes, it is parsed that way
09:25:25 <questions> Ok, cool
09:25:28 <solonarv> (well it's (f b) and not (fb), but I assume that missing space was just a typo)
09:25:41 <questions> just a typo, yep
09:25:50 <questions> So the :t gives us arith :: Num b => (a -> b) -> Integer -> a -> b
09:25:58 <phadej> yes, -> binds less tightly than anything (-1), and function application (the space between `f b`) binds tigher than anything else
09:26:30 <questions> So (a -> b) -> (Integer -> a) -> b?
09:26:43 <phadej> no
09:26:54 <phadej> (a -> b) -> Integer -> (a -> b)
09:26:57 <questions> Oops.
09:28:48 <questions> Still a little confused then
09:28:54 <questions> First, we have a function from a to b
09:29:06 <questions> then we have a function from that to Integer?
09:29:24 <questions> and then we have a function from that cluster to a function from a -> b
09:33:53 <questions> if fromInteger takes an Integer and returns a Num, why is that not being applied first?
09:34:08 <questions> before the second (a -> b) that is
09:35:29 <solonarv> what do you mean by "applied first"? what did you expect the type signature to look like?
09:36:13 <questions> (a -> b) -> (Integer -> a) -> b
09:36:42 <questions> I'm mostly just confused with no anchoring point of reasoning right now
09:37:40 <questions> I think the f b call is what confuses me the most here
09:37:52 <questions> f b gives (a -> b)? how come
09:38:33 <dmwit> You say: "First, we have a function from a to b then we have a function from that to Integer?" No: we have a function from (a function from a to b) to (a function from Integer to something else complicated).
09:39:06 <dmwit> questions: Let's start with something a little simpler.
09:39:22 <questions> Gladly
09:39:27 <dmwit> g :: Bool -> Int -> Int; g b i = if b then i+1 else 2*i
09:39:51 <dmwit> This is syntax sugar for the following thing:
09:40:06 <dmwit> g = \b -> (\i -> (if b then i+1 else 2*i))
09:40:24 <dmwit> So: g is a function which takes a Bool and returns a function.
09:40:31 <questions> Right.
09:40:31 <dmwit> The function it returns takes an Int and returns an Int.
09:40:52 <dmwit> This is the meaning of `g :: Bool -> Int -> Int`, which is the same as `g :: Bool -> (Int -> Int)`.
09:41:40 <dmwit> Are you on board so far?
09:41:47 <questions> I think so
09:42:13 <questions> So in the type signature, those are either functions or values
09:42:16 <dmwit> h :: (Bool -> Int) -> Int; h f = f True
09:42:34 <dmwit> (Again this is syntax sugar for `h = \f -> f True` but that's less important this time.)
09:42:51 <dmwit> h is a function that takes a function as an argument and returns an Int.
09:43:02 <dmwit> The function that it takes as an argument should take a Bool and return an Int.
09:43:44 <dmwit> (...and the way it works is by taking the function it's given, and applying it to True, which is a Bool, and returning the Int that the function returns.)
09:44:06 <dmwit> Are you on board with this more complicated one?
09:44:55 <questions> Not entirely, working through it slowly
09:45:02 <dmwit> Take your time.
09:45:18 <monochrom> Haha this is so sad. Phil Wadler writes in haskell-cafe on hiring tutors for his Haskell course: "In the past we've had trouble locating enough high-quality tutors. The unique situation offers us a new possibility: recruit tutors from elsewhere."
09:45:54 <ridcully> questions: may i be so bold and ask what chapter/page you are on?
09:46:07 <questions> Type Kwon do pt 2
09:46:11 <questions> not sure on the page
09:46:20 <questions> but that's the string you can search for to locate me
09:46:28 <questions> 323
09:46:50 <questions> Ok I've got it dmwit
09:47:08 <questions> The main restriction here is that f must accept a Bool, right
09:47:20 <monochrom> Haha Type Twon Do
09:47:28 <dmwit> It must accept a Bool and return an Int.
09:47:29 <monochrom> err typo but yeah
09:47:53 <questions> Oh I see
09:47:54 <dmwit> Do you want to check your understanding? If so, try explaining the type (String -> Int) -> Bool -> Int to me.
09:48:01 <questions> must return an int because of the last -> Int
09:48:03 <ridcully> spooky - that's where i was at too
09:48:14 <mananamenos> hi, when there is servant code in a final, brittany fails to format the whole file. Is there a way to ignore that part while formatting the other code?
09:48:18 <dmwit> questions: No, it must return an Int because of the *first* -> Int!
09:48:20 <questions> ridcully hopefully you're struggling a little less than I am
09:48:30 <dmwit> h :: (Bool -> Int {- this one right here -}) -> Int
09:48:54 <questions> OH
09:49:03 <dmwit> h is a function that takes a Thing and returns an Int, because its type has the shape Thing -> Int.
09:49:15 <questions> And then that is the Int that is returned at the end ->
09:49:16 <ridcully> ah no wait - i am at pt1 then - way lower page numbers.  but the examples you showed made sense with that level already
09:49:16 <questions> ?
09:49:30 <dmwit> In this case, Thing is itself a function, and that function must accept a Bool and return an Int, because in place of Thing we put `Bool -> Int`.
09:49:50 <ridcully> maybe time to backtrack?  have you crossread/skipped chapter 5?  i tend to do that when i am bored with the level of knowledge transfer
09:50:32 <dmwit> X -> Y is the type of a function that accepts an X as an argument and returns a Y.
09:50:48 <dolio> monochrom: I guess that's looking on the bright side.
09:50:50 <dmwit> questions: (Yes to your latest question.)
09:51:02 <questions> Ok, so the function accept a function going from boolean to int, and returns an int from that
09:51:12 <dmwit> right
09:51:16 <questions> hence why the function needs to accept a boolean and return an int
09:51:17 <questions> Ok
09:51:23 <questions> I think my brain caught up
09:51:47 <dmwit> We'll try this message again, since it seems like the right time to remind you of it:
09:51:48 * hackage polysemy-http 0.2.0.0 - Polysemy effect for http-client  https://hackage.haskell.org/package/polysemy-http-0.2.0.0 (tek)
09:51:54 <dmwit> Do you want to check your understanding? If so, try explaining the type (String -> Int) -> Bool -> Int to me.
09:52:48 <questions> So this is a function which takes a function that (accepts a string, returns an int), which is then compared to something (the Bool), which in turn returns an Int depending on the truthy value?
09:52:48 * hackage di-polysemy 0.2.0.0 - DI logger wrapped for Polysemy  https://hackage.haskell.org/package/di-polysemy-0.2.0.0 (nitros12)
09:53:26 <dmwit> Hm. I don't think we can infer quite that much about how the function behaves.
09:53:35 <questions> Ok, backtracking then
09:53:45 <dmwit> It isn't required to compare anything, or check on the truthiness of the Bool.
09:53:49 <questions> (String -> Int) function accepting a string, returning int
09:53:57 <dmwit> Yep, with you so far.
09:54:11 <questions> -> Bool [why does this part not imply comparison or some sort of evaluation on Bool?]
09:54:50 <dmwit> This function is required to accept a Bool as an argument. But nothing says it has to use that Bool in any particular way.
09:55:10 <xsperry> or at all
09:55:13 <dmwit> For example:
09:55:37 <dmwit> ?let notConst :: Bool -> String; notConst x = "this answer doesn't depend on x"
09:55:39 <lambdabot>  Defined.
09:55:42 <questions> Oh. Ok, that's interesting
09:55:43 <dmwit> > notConst True
09:55:46 <lambdabot>  "this answer doesn't depend on x"
09:55:47 <dmwit> > notConst False
09:55:49 <lambdabot>  "this answer doesn't depend on x"
09:55:51 <questions> Yep
09:55:55 <questions> Very clever example
09:56:40 <questions> so in that case it accepts a function that takes a string, returns an int, as well as a bool. it returns an int as its result?
09:57:26 <dmwit> Nailed it.
09:57:40 <dmwit> Want to go back to your very first question and see if you can understand it a bit better by yourself now?
09:57:44 <questions> Thank you very much. I'm starting to see the light
09:57:45 <questions> Sure
09:58:24 <questions> arith :: Num b => (a -> b) -> Integer -> a -> b
09:58:34 <questions> Constraint on b is that it's a num
09:59:14 <questions> So this function takes a function from type a to num b
09:59:21 <questions> That's the (a -> b)
09:59:28 <dmwit> (Gotta disappear. But there's lots of other folks around with enough expertise to keep helping you, so keep talking and asking questions.)
09:59:35 <questions> Thank you once again
10:01:56 <questions> And then it takes an takes a function from (a -> b), and returns an Integer result from applying the first func?
10:04:59 <xsperry> b is not necessarily an Integer, it could be any type that implements Num constraint
10:05:55 <questions> Which part of what I said are you referencing? I thought I said that when I said that "Constraint on b is that it's a num"
10:06:19 <xsperry> "returns an Integer result from applying the first func"
10:06:33 <questions> Right. So what does the Integer in the middle mean?
10:06:55 <xsperry> it takes a -> b function, an Integer, a, and returns b
10:07:24 <questions> Oh I see
10:07:42 <questions> So what were they saying earlier about the latter part actually being (a -> b)?
10:08:07 <dmwit> questions: Remember that it parenthesizes as (a -> b) -> (Integer -> a -> b). So this is a function that takes a function (`a -> b`) and returns a function (`Integer -> a -> b`).
10:08:50 <questions> how does that hold up to what xsperry said? A little confused, again :' )
10:09:10 <dmwit> (..and then `Integer -> a -> b` parenthesizes as `Integer -> (a -> b)`, so it is a function that takes an Integer and returns a function.)
10:09:41 <dmwit> questions: Remind yourself about what `Bool -> Int -> Int` meant above.
10:10:30 <dmwit> questions: It is a function that takes a Bool and returns a function. As a mental and verbal shortcut, sometimes we describe that as a two-argument function.
10:10:34 <xsperry> in haskell all functions take just one parameter (and possibly return a function that returns remaining parameters), but we sometimes think and convey that a function takes multiple parameters
10:10:44 <xsperry> that accepts remaining parameters*
10:10:49 <dmwit> Because it behaves like a two-argument function: you can apply it to two arguments, because after the application to one argument it's still a function.
10:11:03 <questions> Alright, so is my udnerstanding of currying what's leading to the confusion?
10:12:39 <questions> Because I understand the idea of functions returning functions
10:12:48 * hackage base16 0.3.0.1 - Fast RFC 4648-compliant Base16 encoding  https://hackage.haskell.org/package/base16-0.3.0.1 (topos)
10:12:54 <questions> and how a "multiple argument" function is actually n nested functions
10:13:22 <questions> But going from actual functions with 1 arg each back to the "multi argument" form in my mind is not working
10:16:20 <questions> Ah, it's clicking after some more review
10:23:47 <monochrom> Ooohhhh interesting, Most Data.Sequence operations are, although logarithmic in worst case, constant-time amortized.
10:24:00 <tomsmeding> isn't that the entire point of Data.Sequence?
10:24:29 <tomsmeding> it is fancy though
10:25:37 <questions> ridcully you may have been right
10:28:17 <monochrom> Yikes, and it uses polymorphic recursion.
10:28:18 * hackage pandoc-crossref 0.3.8.1 - Pandoc filter for cross-references  https://hackage.haskell.org/package/pandoc-crossref-0.3.8.1 (lierdakil)
10:42:49 * hackage calamity 0.1.20.0 - A library for writing discord bots in haskell  https://hackage.haskell.org/package/calamity-0.1.20.0 (nitros12)
11:03:48 * hackage polysemy-http 0.2.0.1 - Polysemy effect for http-client  https://hackage.haskell.org/package/polysemy-http-0.2.0.1 (tek)
11:07:06 <boxscape> do you guys say POlySEmy or poLYsemy
11:07:26 <wavemode> the first
11:10:03 <monochrom> I once had a prof from Singapore. He said "librarY".
11:10:17 <boxscape> huh
11:10:23 <glguy> Google is showing: puh·li·suh·mee -- (emphasis on the li if your client isn't showing that); dictionary shows päˈlisəmē
11:11:13 <monochrom> Just join the Daleks and say "polysemy" and "exterminate all humans"
11:11:19 <boxscape> IIRC I think Sandy pronounced it POlySEmy in a talk so i'm inclined to say the library is simply pronounced differently from the English word
11:13:12 <boxscape> actually update
11:13:27 <boxscape> I just checked and in the first talk I clicked on he did say poLYsemy so never mind
11:14:32 <monochrom> OK, next: algOrithm vs Algorithm :)
11:14:48 <boxscape> hm I don't think I've ever heard the first one
11:14:54 <wavemode> yeah, never
11:15:25 <monochrom> OK, how about: polymOrphism vs pOlymorphism
11:16:09 <glguy> ThInGs ArE sTaRtInG tO gEt CrAzY!
11:18:47 <wavemode> the one that really surprised me was that many people say SQL as "sequel"
11:21:45 <monochrom> In Hong Kong we all said es que el. (When I was a student in 1990. Not sure about now.)
11:23:23 <monochrom> Then I came to Canada and yeah, pretty surprised at sequel, skusi, takle tak.
11:24:12 <hyperisco> takle tak? what?
11:24:17 <monochrom> tcl/tk
11:24:23 <wavemode> ahahaha what
11:24:39 <hyperisco> oh tickle tock
11:25:14 <monochrom> Um you and your Tik Tok generation of millenials!
11:25:39 <dolio> Isn't that a better pun, though?
11:25:49 <monochrom> yes
11:26:30 <dolio> Not sure I've ever heard 'tackle' for tcl. I've heard 'tickle', though.
11:27:25 <dolio> Never occurred to me just reading it, though. Same as the others.
11:27:41 <monochrom> tackle or teckle, I can't easily tell from just hearing
11:29:23 <dolio> Teckle isn't even a word, so that'd be a pretty bad pun.
11:29:32 <monochrom> First time I heard skusi I thought it was scudsi. You know, back in 1990-1995 when the first Persian Gulf war and "Iraq launched another Scud to Israel" was in recent memory.
11:29:35 <boxscape> not everything is a pun
11:30:41 <hth> I am trying to build GHC as a cross compiler for arm64, but get error compiling rts/StgCRun.c: unknown register name %x30
11:32:42 <koz_> boxscape: Half of Hackage begs to differ.
11:32:52 <monochrom> hahaha
11:32:54 <boxscape> exactly - *half*
11:33:01 <monochrom> But yeah, only half.
11:33:38 <monochrom> This is how endian wars begin.
11:51:10 <dmwit> On the other hand, nobody says "ay ess sea eye eye".
11:52:11 <boxscape> apparently in the Martian audio book it's read "ay ess sea 2"
11:52:20 <monochrom> I said that when I was a teenager. But I was on my own, had no one to talk to about it.
11:58:36 <dminuoso> Does base/posix/unix have some tool to create named pipes with?
11:58:46 <dminuoso> Been looking around for a while in vain
11:59:10 <Uniaika> o/
12:01:38 <dminuoso> Im starting to think Ill just use System.Posix.Internals.c_mkfifo directly
12:01:53 <dminuoso> All my fear of ffi has been taken away. :>
12:02:54 <monochrom> System.Posix.Files.createNamedPipe
12:03:04 <Leonardo4581> i´m trying to learn haskell but i don´t understand nothing about it
12:03:48 <dminuoso> monochrom: Oh. Maybe I need to hoogle better
12:03:59 <dminuoso> Is there a way to insert wildcards?
12:04:27 <dminuoso> Leonardo4581: Welcome! Don't be afraid, Haskell is just so different, that learning it feels like the first time you learned a programming language. It's tough and takes a while to get used to. :)
12:04:27 <monochrom> I used exhaustive search with heuristic pruning and heuristic unpruning.
12:05:00 <dminuoso> Hehe, thought I was crazy. Seemed so unlikely this was missing
12:05:03 <dminuoso> Cheers monochrom :)
12:06:35 <monochrom> wildcards like "rm *.py"?
12:07:13 <dminuoso> Well, I was hoping to search for an identifier like *pipe*
12:07:29 <monochrom> Ah. I don't know hoogle. Very likely no.
12:15:42 <tomsmeding> [exa]: https://paste.tomsmeding.com now supports editing existing pastes through a button on the read page :)
12:17:08 <[exa]> tomsmeding: l o v e l y
12:24:15 <sm[m]> tomsmeding: if you want more UX ideas let me know
12:24:40 <tomsmeding> if you have some user-quality-of-life-improvement ideas, please yes :)
12:24:59 <tomsmeding> my time is limited, but having ideas is always good
12:26:02 <sm[m]> well, I have just two. Don't want to spam you if you don't want them. :) Ok, one is to greatly compact the intro text / ensure the paste area is most prominent, currently the text it takes half the window on a full-size screen (don't know about mobile)
12:26:26 <sm[m]> two is clickable permalinks for the individual files
12:26:29 <sm[m]> it's looking great!
12:27:09 <geekosaur> for what it's worth, I have to scroll down to see the paste area. But I'm on an ancient netbook
12:27:12 <sm[m]> oh three is keyboard shortcuts (control/cmd-enter to submit)
12:27:50 <tomsmeding> re:clickable permalinks and keyboard shortcuts: great ideas
12:28:16 <tomsmeding> re:prominence of intro text: kind of agree (the intro text is huge at the moment), but then the question is: what exactly was the purpose of this paste service
12:28:35 <tomsmeding> I can reduce the font size, shorten the text (what to remove)
12:28:48 <tomsmeding> can also put it _below_ the paste area, but that seems counterproductive
12:28:59 <sm[m]> a pastebin that's focussed on making #haskell's discussions and support more efficient
12:29:19 <sm[m]> even if you removed the line breaks from that text, maybe it would help a lot
12:29:46 <sm[m]> line breaks/bullets
12:30:02 <sm[m]> headings 
12:30:28 <sm[m]> four: focus the text area by default
12:30:29 <geekosaur> or multicolumn but that messes with phones (there's a decent amount of white space on the right on here)
12:31:56 <sm[m]> I wondered about removing the padding around pastes, so they use more of the available width
12:32:14 <sm[m]> all of it, I mean
12:33:07 <tomsmeding> so that the textarea stretches the full width of the browser window?
12:33:16 <sm[m]> yup
12:33:54 <sm[m]> well I was speaking more of the paste once it has been saved, maybe that means the textarea too for consistency
12:34:17 <tomsmeding> sm[m]: better text? https://paste.tomsmeding.com/
12:34:26 <sm[m]> when I made some pastes they looked pretty but I had a desire to zoom / click raw mode to see more
12:34:39 <tomsmeding> ah yes
12:35:04 <tomsmeding> perhaps it's less important for the input textarea, because you're not likely to compose stuff there (it's called "paste" for a reason)
12:35:08 <geekosaur> better. I'd still have the text on how to ask questions somewhere, I think
12:35:37 <tomsmeding> geekosaur: I can just put the original line below that: https://paste.tomsmeding.com/
12:35:39 <maralorn> Are we talking about the same paste? My intro text has two and a half lines.^^
12:35:48 <maralorn> Oh, wait. It got alread changed.^^
12:35:56 <tomsmeding> yes sorry I'm live-changing the instance
12:36:00 <sm[m]> what if you put all in a single paragraph, 1-3 sentences, no heading. Also I think package.yaml got dropped
12:36:11 <geekosaur> that works, yes
12:36:14 <koz_> What does the Read instance for Float do when fed a textual rep that it can't represent?
12:36:26 <tomsmeding> there never was package.yaml though, but I can add it :p
12:37:06 <sm[m]> you may know: in firefox, cmd-opt-m or equivalent shows a phone view
12:37:36 <tomsmeding> sm[m]: well this is certainly more compact now https://paste.tomsmeding.com/
12:38:17 <sm[m]> @where ?
12:38:17 <lambdabot> Some useful @where queries: ? | paste, pastecabalstack | doc, zerotohero, htac | stack, cabal, ghcup
12:38:47 <sm[m]> @where pastecabalstack
12:38:48 <lambdabot> Help us help you: at https://gist.github.com, https://paste.tomsmeding.com or https://termbin.com, please paste your failing command, full output, and .cabal, package.yaml and/or stack.yaml files
12:39:13 <sm[m]> looking good to me tomsmeding - less pretty but more efficient
12:39:19 <tomsmeding> true
12:39:39 <sm[m]> on a standard phone the text now takes only 1/3 of the screen
12:39:43 <tomsmeding> it looks slightly less inviting to read, but it's only three lines -- let's hope that people are willing to read at least that
12:40:14 <tomsmeding> takes less on my phone, but then my phone is excessively high :p
12:41:06 <koz_> What does the Read instance for Float do when fed a textual rep that it can't represent?
12:41:11 <tomsmeding> heh the firefox mobile view is quite a small screen
12:41:21 <tomsmeding> neat
12:41:32 <xerox_> > read "koz_" :: Float
12:41:35 <lambdabot>  *Exception: Prelude.read: no parse
12:41:37 <sm[m]> @where+ pastecabalstack Help us help you: at https://paste.tomsmeding.com, https://gist.github.com or https://termbin.com, please paste your failing command, full output, and .cabal, package.yaml and/or stack.yaml files
12:41:38 <lambdabot> Okay.
12:41:46 <sm[m]> tomsmeding: you can choose the size
12:41:50 <tomsmeding> > read "1e10000" :: Float -- koz_ 
12:41:53 <lambdabot>  Infinity
12:42:02 <koz_> Ah, interesting.
12:42:09 <tomsmeding> I guess it just rounds it to the nearest representable value
12:42:15 <koz_> > read "+Inf" :: Float
12:42:16 <tomsmeding> which makes sense given general float semantics
12:42:18 <lambdabot>  *Exception: Prelude.read: no parse
12:42:35 <tomsmeding> > read "NaN" :: Float
12:42:37 <lambdabot>  NaN
12:42:51 <geekosaur> huh
12:42:55 <tomsmeding> sm[m]: yay for where update
12:42:57 <koz_> tomsmeding: What would I need to feed it to get infinity-not-by-overflowing?
12:43:05 <tomsmeding> ¯\_(ツ)_/¯
12:43:09 <geekosaur> pretty sure NaN isn't valid in a program
12:43:12 <koz_> tomsmeding: Lol, well, thanks anyway.
12:43:14 <sm[m]> tomsmeding: in my text (above) I mentioned the "failing command", since that's often omitted, and I said "and/or" to try and make it a little less demanding seeming (we usually don't need both package.yaml and .cabal file, eg)
12:43:29 <dolio> > 1/0
12:43:32 <tomsmeding> though sometimes users have none of those at all sm[m] 
12:43:32 <lambdabot>  Infinity
12:43:50 <tomsmeding> > read "Infinity" :: Float -- koz_ 
12:43:53 <lambdabot>  Infinity
12:43:56 <tomsmeding> "obviously"
12:44:03 <koz_> > read "-Infinity" :: Float
12:44:05 <lambdabot>  -Infinity
12:44:10 <koz_> Huzzah, thanks!
12:44:15 <sm[m]> indeed, we want the text to be generic enough but also provide appropriate guidance 
12:44:16 <koz_> That gives me all the info I need.
12:45:05 <sm[m]> I liked "Help us help you:" for setting the right tone, YMMV
12:46:43 <tomsmeding> sm[m]: how about this https://paste.tomsmeding.com/
12:47:11 <tomsmeding> perhaps "please *also* enjoy this classic read"
12:47:35 <sm[m]> we're asking them to do extra work, so ideally the reason and the payoff will be clear. Latest looks very good to me
12:47:47 <tomsmeding> true
12:48:26 <geekosaur> I'd ahve a line break for that part, it doesn't take much extra space and somehow the current one sets off "nobody will read past this point" in the middle of the second line
12:48:55 <sm[m]> I'm not even sure that link adds much here
12:49:18 <sm[m]> vanishingly few folks we send to the pastebin will stop to read an essay
12:49:26 <tomsmeding> very true
12:49:30 <sm[m]> which isn't really to the point
12:49:50 <geekosaur> I had originally been thinking move it to the bottom, tbh
12:50:52 <tomsmeding> geekosaur: sounds good, but then the design looks off IMO
12:51:21 <tomsmeding> I mean this works https://paste.tomsmeding.com/
12:51:52 <sm[m]> +1 from me. We could add more specific tips if needed, but also less is more
12:51:54 <tomsmeding> it being at the bottom is certainly better thoug
12:52:11 <tomsmeding> we can add more specific tips when the need arises, perhaps
12:52:19 <tomsmeding> "accumulated wisdom"
12:52:49 <sm[m]> you could also put the text as placeholder in the textarea, but I suspect it'll be too "clever"
12:53:21 <tomsmeding> you can't put a link in placeholder text
12:53:44 <tomsmeding> or do you mean the header text?
12:53:45 <sm[m]> oh, I thought we dropped the link
12:53:53 <sm[m]> the help us help you text
12:53:56 <tomsmeding> the link is at the bottom at the moment, see refresh
12:54:28 <tomsmeding> I'm not sure about whether to include the link
12:54:31 <maerwald> No bot that pastes,the link?
12:54:51 <maerwald> I'm lazy
12:55:05 <geekosaur> so are spammers
12:55:31 <maerwald> Damn you internet 
12:55:35 <sm[m]> oh yeah, spam is going to be a problem at some point
12:56:14 <tomsmeding> I guess I'll find out about spam when it happens
12:56:49 <tomsmeding> I think I'll remove the essay link for now, in the interest of keeping it clean (and there being a vanishing probability of anyone actually going out to read the thing)
12:57:30 <tomsmeding> okay what I consider the final text is now up; this is also the text that you +1'd, sm[m] 
12:57:41 <sm[m]> could link to the channel's wiki page, with more links there
12:58:13 <sm[m]> https://wiki.haskell.org/IRC_channel
12:58:44 <tomsmeding> where? in the footer?
12:59:08 <sm[m]> I dunno.. probably ignore me, until there's an actual need..
12:59:25 <tomsmeding> 👍
12:59:39 <tomsmeding> well, not about ignoring you, but about not including the link until need arises
12:59:55 <geekosaur> had you considered making "#haskell" a link to that wiki page?
13:00:15 <sm[m]> oh yeah that would work
13:00:21 <tomsmeding> I have, but I quickly discarded that for aesthetic reasons
13:00:43 <tomsmeding> hm
13:01:01 <tomsmeding> header now contains link, refresh to update
13:01:10 <tomsmeding> it's not as bad as I thought it would be
13:01:40 <geekosaur> I did look at the other link before suggesting it (the link to github)
13:01:58 <geekosaur> to make sure it was reasonably readable
13:04:49 * hackage xeno 0.4.2 - A fast event-based XML parser in pure Haskell  https://hackage.haskell.org/package/xeno-0.4.2 (ocramz)
13:25:50 <c_wraith> I haven't looked at the discrimination library in a while.  It seems considerably more batteries-included than it used to...
13:42:21 <tomsmeding> shiny new version of pastebin service, thanks sm[m] and geekosaur (who's now offline): https://github.com/tomsmeding/pastebin-haskell/blob/master/ChangeLog.md (last two versions are today)
13:43:00 <tomsmeding> tldr all suggestions that I remembered are implemented :)
13:52:43 <tomsmeding> heh I just realised those dates in the changelog are dates in my timezone; it doesn't matter enough for me to care though :)
14:50:04 <ph88> does someone know a decent html template package ? the ones i found dont look so good
14:52:33 <koz_> If I have a flag in my Cabal file, can I make a CPP statement referring to it?
14:55:20 <glguy> koz_: In your cabal file you can conditionally set -D based on that flag
14:55:29 <koz_> glguy: Ah, right. OK, easy enough.
14:55:47 <glguy> if flag(safe)\n  cpp-options: -DSAFE=1
14:57:33 <zyklotomic> I was wondering if there was any deeper mathematical meaning to the following: (sum . map f) vs (length . filter f')
14:57:52 <zyklotomic> where f is an indicator function, 1 for true, 0 for false, f' is the boolean equivalentt
15:17:50 <koz_> Is there a pre-existing type equivalent to (Maybe a, b)?
15:22:14 <dminuoso> koz_: These
15:22:20 <dminuoso> Ah, not quite
15:32:17 <boxscape> time to integrate a way in hoogle to search for isomorphic types
15:34:39 <Lycurgus> based on what?
15:35:05 <Lycurgus> (other than a specific annotation)
15:36:02 <boxscape> advanced coding and algorithmss
15:36:22 <Lycurgus> i c
15:36:50 <boxscape> I guess you'd have to access the source code but you should be able to convert types into a generic Product and Coproduct form and compare them
15:37:12 <Lycurgus> using what?
15:37:20 <hekkaidekapus> boxscape: <https://github.com/ndmitchell/hoogle/issues/250>
15:37:35 <boxscape> oh, neat
15:38:10 <koz_> TIL about a new data structure!
15:38:23 <boxscape> Lycurgus I'm not quite sure what that question means - you take the definition, you convert it to a generic form, and you compare it with the search term, I'm not sure which of these steps needs to be based on something
15:39:13 <boxscape> eh, which steps need to be using something I guess I should have said
15:39:21 <boxscape> I got confused between your first and second question
15:39:52 <Lycurgus> np, will be great when do a PR
15:40:11 <Lycurgus> (to add the feature to hoogle)
15:40:15 <boxscape> yeah
15:40:20 <Lycurgus> *when you
15:40:50 <boxscape> don't know that I'll do that but I am interesting in looking more into the existing issue
15:40:51 <Lycurgus> then you will have shown me
15:40:57 <boxscape> that is true
15:58:02 <Lycurgus> ofc i was thinking of the function itself not parametric isomorphism of the arguments and value
16:01:03 <boxscape> oh, I wasn't tihnking about functions at all, just ADTs
16:02:49 <Lycurgus> ah
16:03:29 <Lycurgus> (didn look at the log, when I entered that was the default interp)
16:04:07 <boxscape> yeah I can see where you're coming from
17:10:48 * hackage errata 0.1.0.0 - Source code error pretty printing  https://hackage.haskell.org/package/errata-0.1.0.0 (comp)
17:25:19 * hackage mime-mail-ses 0.4.3 - Send mime-mail messages via Amazon SES  https://hackage.haskell.org/package/mime-mail-ses-0.4.3 (kindaro)
18:03:53 <dumptruckman> Hello all
18:04:04 <boxscape> hi
18:04:04 <dibblego> hi
18:04:12 <dumptruckman> I just wanna I saw love you all
18:04:14 <koz_> hi
18:04:16 <dumptruckman> say, too
18:04:20 <dumptruckman> wow
18:04:21 <boxscape> i love you too dumptruckman
18:04:22 <dumptruckman> i butchered that
18:04:29 <dumptruckman> :D
18:04:31 <koz_> We love you too, dumptruckman.
18:04:41 <koz_> Flowers for Valentine's Day are optional, but appreciated.
18:04:50 <dumptruckman> This is the best programming community I know of and that's not saying a little
18:05:05 <boxscape> I agree
18:05:10 <koz_> I also agree.
18:05:48 <dumptruckman> Is there an online editor or ide kind of thing that I can use to make projects with Haskell?
18:05:56 <boxscape> repl.it and ideone.com
18:05:58 <dumptruckman> Setting it up on my primary PC is a PITA cause I'm using windows
18:06:10 <dumptruckman> can you load 3rd party libs on repl.it?
18:06:14 <koz_> dumptruckman: Have you tried Chocolatey?
18:06:18 <koz_> It's pretty seamless.
18:06:18 <boxscape> hmm not that I know of :/
18:06:38 <dumptruckman> koz_: for some reason I haven't thought to try it that way.
18:06:58 <dumptruckman> But actually, I think the problem bigger problem with windows is all the good libs are for Linux
18:07:06 <dumptruckman> I cannot type tonight
18:07:14 <boxscape> you can also try setting up the windows subsystem for linux which I find works pretty well
18:07:25 <boxscape> but if you want to run graphical applications that could be difficult
18:07:27 <dumptruckman> Does it? The last time I tried I could not get it installed
18:07:30 <koz_> dumptruckman: The best situation in this case? Try using Haskell libraries, tell maintainers they don't work.
18:07:31 <boxscape> hmm
18:07:41 <koz_> I seriously don't recommend WSL.
18:07:48 <koz_> Try Chocolatey and see where it gets you.
18:07:52 <dumptruckman> ok
18:07:54 <dumptruckman> thanks
18:08:07 <dumptruckman> But also Atom is kind of a PITA to use
18:08:33 <dumptruckman> Anyone have favorite editors for windows?
18:08:43 <koz_> I think VS Code is what everyone suggests for Haskell? I cannot give editor/IDE advice, since I use vim and would _not_ recommend it on Windows.
18:09:01 <boxscape> I use vim in WSL2 but yeah VS Code seems pretty popular
18:09:04 <dumptruckman> I feel like I'm going to die never being good at vim
18:09:10 <boxscape> that's okay
18:09:11 <dumptruckman> I just can't bring myself around to committing to it
18:09:24 <koz_> dumptruckman: On Windows, I wouldn't even bother. Outside of WSL it's in an unworkable state.
18:09:30 <koz_> And you will spend hours chasing really weird issues.
18:09:36 <koz_> (speaking from experience)
18:09:43 <dumptruckman> right
18:11:04 <dumptruckman> Do you think this community is so awesome because of the language?
18:11:47 <koz_> dumptruckman: I dunno.
18:12:05 <koz_> There are some folks who think so.
18:12:13 <koz_> I think it's a chicken-and-egg situation.
18:12:26 <dumptruckman> Hmm, that's a good way to look at it
18:12:27 <koz_> Like, on the one hand, Haskell's history and choices certainly attract a certain kind of individual.
18:12:32 <boxscape> I think part of it might be that people largely use people because they are interested in it rather than because they have to use it for school or work
18:12:43 <koz_> But at the same time, those individuals are what makes the language the way it is (and keeps it that way).
18:12:54 <koz_> boxscape: At least initially, I'd say that's true.
18:12:59 <dumptruckman> boxscape: that's a good take too
18:13:05 <koz_> (speaking as someone who was a non-professional user until relatively recently)
18:13:07 <boxscape> (they don't use the people, they use haskell, whoops)
18:13:11 <koz_> (but Haskell now pays my salary)
18:15:52 <dumptruckman> I love learning new languages but I think none have enamored me more than haskell and scheme/racket
18:16:04 <koz_> I was a Scheme fan once.
18:16:08 <koz_> (and a fairly big one)
18:16:44 <dumptruckman> I'm definitely a fan of the lisp syntax
18:16:53 <boxscape> )))))
18:17:38 <dumptruckman> All I see is blonde, brunette, redhead.
18:17:55 <boxscape> Ah I'm not quite that advanced in scheme
18:18:25 <dumptruckman> Well, I wouldn't say I'm advanced but the parens don't bother me. But I feel it is absolutely critical to use the right indention patterns.
18:18:39 <boxscape> makes sense
18:54:29 <gnumonik> I'm trying to figure out generics-sop and I've been stuck for a few days on something simple: I can figure out how to get the *first* value of an NP but can't figure out how to get anything else. "go (x :* xs) = x :* Nil :: (xs ~ (b ': bs)) => NP I xs -> NP I '[b]" works for the head but I can't figure out how to write a signature that expresses that I want a value of *some* type that's a member of the type-level index list. Is 
18:54:29 <gnumonik> what I want even possible? 
19:00:49 * hackage socket-icmp 0.1.0.1 - Definitions for using ICMP with the `socket` library  https://hackage.haskell.org/package/socket-icmp-0.1.0.1 (trm)
19:04:27 <c_wraith> how bad of an idea is `map (flip (,) <*> show)' just to avoid a list comprehension?
19:04:33 <c_wraith> (I really don't like list comprehensions)
19:04:57 <c_wraith> and yes, that could also be written with &&&  but I really don't want to import it.
19:06:02 <justsomeguy> What does it do?
19:06:24 <c_wraith> actually...   map (\x -> (show x, x))  is fine, and gets rid of the confusion bits.
19:06:37 <nshepperd> it's a bad idea if someone has to ask what it does :p
19:06:40 <c_wraith> and at least it's not a list comprehension
19:06:57 <justsomeguy> Yes, that's much more readable.
19:07:28 <c_wraith> meh.  it's boring plumbing in this particular case anyway.
19:08:21 <c_wraith> (in the greater context, the type tells you everything it has to do)
19:09:33 <MarcelineVQ> :t liftA2 (,) show id -- :>
19:09:34 <lambdabot> Show a => a -> (String, a)
19:10:18 <justsomeguy> ...someday I'll get to the point that this doesn't look like alien hieroglyphics.
19:10:46 <MarcelineVQ> :t first show . join (,)
19:10:47 <lambdabot> Show a => a -> (String, a)
19:10:50 <justsomeguy> (Probably shortly after figuring out Applicative)
19:12:04 <MarcelineVQ> flip is the enemy, these at least are perfectly reasonable \devilhornscodepoint
19:12:16 <nshepperd> do x <- ...; return (show x, x)
19:12:40 * nshepperd shows herself out
19:12:48 <c_wraith> I suppose that's technically not a list comprehension
19:12:59 <c_wraith> so...  you still met the criteria!
19:16:34 <MarcelineVQ> :t (>>= (,)) show
19:16:35 <lambdabot> Show b => b -> (String, b)
19:16:43 <monochrom> Do you accept monad comprehension? >:)
19:18:54 <c_wraith> not when it's producing a list
19:20:12 <c_wraith> MarcelineVQ: that definitely wins for being awesome *and* unreadable!
19:52:39 <ph88> does someone have an example how package ginger is used in a real project ?
20:04:08 <dmwit> MarcelineVQ: Why the section, though?
20:04:11 <dmwit> :t show >>= (,)
20:04:12 <lambdabot> Show a => a -> (String, a)
20:05:16 <MarcelineVQ> it was easier to check the type of during play
20:06:34 <MarcelineVQ> iow I could remove show and :t would work without any other changes
21:03:18 * hackage swiss-ephemeris 0.2.0.0 - Haskell bindings for the Swiss Ephemeris C library  https://hackage.haskell.org/package/swiss-ephemeris-0.2.0.0 (lfborjas)
22:31:00 <Axman6> @hoogle operator
22:31:01 <lambdabot> Text.Parsec.Token operator :: GenTokenParser s u m -> ParsecT s u m String
22:31:01 <lambdabot> Text.ParserCombinators.Parsec.Token operator :: GenTokenParser s u m -> ParsecT s u m String
22:31:01 <lambdabot> Test.QuickCheck.Instances.Char operator :: Gen Char
