00:03:01 <opqdonut> Axman6: :D
00:16:09 <lortabac> xpika: isn't Ajhc dead?
00:17:41 <lortabac> xpika: with GHC you can use generic-deriving
00:17:48 <lortabac> @hackage generic-deriving
00:17:49 <lambdabot> https://hackage.haskell.org/package/generic-deriving
00:18:04 <kuribas> why would you use anything other than ghc?
00:18:37 <xpika> kuribas: ghc is bloated
00:18:45 <kuribas> xpika: for a reason
00:20:01 <dminuoso> Mmm, I feel like we should have Control.Monad.IO in base, re-exporting the module Control.Monad.IO.Class
00:20:45 <dminuoso> It feels so annoying to have Control.Monad.Logger, Control.Monad.State, Control.Monad.Writer, and then this non-uniform Control.Monad.IO.Class :<
00:23:51 <merijn> If that's your biggest problem...
00:25:40 <MarcelineVQ> it's a huge problem, and Control.Monad.Trans doesn't even have a TransT!
00:26:31 <kuribas> merijn: I patched the pcre library and did some tests on my script.  44% percent of time is spend in the matching function.  Using "safe" ffi calls slowed the script from 6 seconds to 8.5 seconds.
00:26:59 <dminuoso> MarcelineVQ: Haha, now that you mention it.
00:27:16 <Axman6> s'if TransT isn't just IdentityT
00:27:20 <kuribas> merijn: running it in parallel on 2 cores reduced it to 4 seconds.
00:27:31 <Axman6> or, IdentiT
00:28:30 <kuribas> merijn: not that much, but still something...
00:28:32 <dminuoso> MarcelineVQ: But that helps. I can just use Control.Monad.Trans instead of Control.Monad.IO.Class 
00:28:43 <ukari> Is there any better way to cast Xlib `Display` to vulkan `Display`? (my way https://plaster.tymoon.eu/view/2045) (xlib https://hackage.haskell.org/package/vulkan-3.6.6/docs/Vulkan-Extensions-VK_KHR_xlib_surface.html#t:Display) (vulkan https://hackage.haskell.org/package/X11-1.9.1/docs/Graphics-X11-Xlib-Types.html#t:Display)
00:28:44 <dminuoso> Making my imports look uniform and nice! :)
00:29:35 <Axman6> ukari: god I hope there is...
00:30:19 <lemmih> ukari: Cast the ptrs directly.
00:30:30 <dminuoso> lemmih: how?
00:30:49 <lemmih> With 'castPtr'.
00:31:12 <lemmih> X11's type is 'Ptr Window', Vulkan's is 'Ptr ()'.
00:31:16 <Axman6> XLib.Display doesn't appear to be a Ptr though
00:31:36 <Axman6> unless show does something super funky here...
00:31:41 <lemmih> This is it, right: newtype Display = Display (Ptr Display) ?
00:31:50 <dminuoso> lemmih: Is the constructor exported?
00:31:57 <dminuoso> Though, Id just unsafe coerce if not.
00:32:07 <dminuoso> This API is set in stone.
00:32:07 <lemmih> Pretty sure it is. Otherwise it wouldn't show up in the docs.
00:32:23 <dminuoso> Mmm, the haddocks are not on hackage
00:32:26 <dminuoso> What are you looking at?
00:33:00 <lemmih> I'm looking at ukari's links.
00:33:29 <dminuoso> Ah
00:33:46 <dminuoso> Dont mind me then. :)
00:33:50 * hackage ocap-io 0.1.0.0 - Object capability based IO  https://hackage.haskell.org/package/ocap-io-0.1.0.0 (isd)
00:34:33 <ukari> lemmih, thanks, it works
00:35:31 <Axman6> looks like it should just be castDisplay (Display ptr) = castPtr ptr
00:36:37 <Axman6> or, castDisplay = castPtr . coerce @Display @(Ptr Display)
00:36:52 <lemmih> And then pray that an Xlib Display is the same thing as a Vulkan Display. :)
00:36:55 <Axman6> which it turns out is just coerce . coerce
00:54:54 <dminuoso> lemmih: Im fairly confident that it will segfault left and right instantly if its not.
00:55:15 <dminuoso> Most likely crash your X server along.
01:19:26 <tomsmeding> it's a shame that 'flip' cannot (reasonably) take functions with an argument type including foralls
01:19:49 <tomsmeding> is this impredicativity, possibly fixed by the quicklook thing, or is this something else?
01:24:19 * hackage mason 0.2.3 - Fast and extensible bytestring builder  https://hackage.haskell.org/package/mason-0.2.3 (FumiakiKinoshita)
01:28:56 <timCF> Hello! Can anybody advise beginner-friendly tutorial for `haskell-src`? Tired of TH limitations and wanna try more powerful AST generation tool
01:33:16 <koz_> tomsmeding: Probably?
01:33:16 <dminuoso> tomsmeding: impredicativity
01:33:37 <tomsmeding> > Tired of TH limitations | I'd be tired of TH in general
01:33:37 <koz_> It's the same reason why (.) and runST interact... not at all. :P
01:33:38 <dminuoso> It's the same reason why ($) technically doesn't work with runST
01:33:39 <lambdabot>  <hint>:1:7: error: <hint>:1:7: error: parse error on input ‘of’
01:33:48 <tomsmeding> koz_: dminuoso: jinx'ing
01:33:49 <koz_> dminuoso: It does because of a GHC-specific hack, right?
01:33:53 <dminuoso> koz_: Right.
01:34:00 <tomsmeding> yeah $ has this levity hack with TYPE
01:34:07 <dminuoso> I dont recall the specifics, but I think ($) gets simply thrown away
01:34:11 <tomsmeding> but yes thanks
01:34:16 <dminuoso> It's a really silly and simple hack
01:34:56 <dminuoso> tomsmeding: No, it has nothing to do with levity
01:34:58 <lemmih> timCF: What limitations of TH have you run into?
01:35:05 <tomsmeding> oh
01:35:13 <tomsmeding> oh is that for unlifted types only?
01:35:28 * tomsmeding realises that that would make sense given the name "levity"
01:35:54 <koz_> tomsmeding: Levity is a separate issue.
01:36:03 <tomsmeding> right
01:36:08 <tomsmeding> ghc-specific hacks all the way
01:36:14 <dminuoso> tomsmeding: What you may think of is that: ($) ::forall (r :: RuntimeRep) a (b :: TYPE r). (a -> b) -> a -> b
01:36:21 <dminuoso> But when you ask for :t you get lied to
01:36:22 <tomsmeding> yes
01:36:23 <dminuoso> Since:
01:36:26 <dminuoso> % :t ($)
01:36:26 <yahb> dminuoso: *** Parser [source]:; !!! Parser [source]: finished in 0.12 milliseconds, allocated 0.023 megabytes; (a -> b) -> a -> b
01:36:36 <dminuoso> It hides the levity polymorphism for beginners sake
01:36:38 <merijn> The levity polymorphism is unrelated to ST, though
01:36:50 <dminuoso> So ($) has 2 specific but unrelated hacks to it.
01:36:58 <tomsmeding> I see
01:37:25 <tomsmeding> and the {-# INLINE ($) #-} pragma is not the full "ghc-specific hack"?
01:37:27 <dminuoso> one is to hide the levity polymorphism when asked for its type, and the other one does something like throw it away before the type checker even sees it I think.
01:37:40 <dminuoso> No, it's something as dirty as "the parser throws it away"
01:37:47 <tomsmeding> :')
01:37:50 <dminuoso> (I really dont reclal whether that was the acutal implementatoin of it)
01:37:50 <merijn> tomsmeding: INLINE isn't a hak, that's just a hint to the compiler
01:37:59 <koz_> A very insistent hint.
01:38:16 <tomsmeding> and gets handled by the optimiser, which comes after the typechecker
01:38:17 <dminuoso> or.. no right!
01:38:17 <merijn> tomsmeding: "You should inline this", it doesn't affect the meaning or type, though
01:38:23 <dminuoso> I think GHC forcibly inlines the definitoin of it.
01:38:25 <dminuoso> That was it
01:39:12 <dminuoso> A sort of built-in guaranteed INLINE.
01:39:12 <timCF> lemmih I'm not an expert, but seems TH splicing is happening in single compiler walk, I didn't find the way to represent TH AST as output of other TH function. I needed something like this `\$(spliceLater $(spliceNow x))`
01:39:27 <tomsmeding> so the point is that with quicklook, flip may become more generally applicable?
01:40:28 <lemmih> timCF: By 'later', do you mean at run-time?
01:40:41 <timCF> lemmih no, compile-time
01:41:06 <dminuoso> timCF: Perhaps haskell-src has a quasiquoter?
01:41:24 <dminuoso> If not, that'd be a really useful (and not too hard-to-implement) thing
01:41:40 <dminuoso> timCF: https://hackage.haskell.org/package/haskell-src-exts-qq
01:41:42 <dminuoso> There you go!
01:41:53 <dminuoso> It's for haskell-src-exts instead, but that's a useful upgrade anyway. :)
01:42:05 <lemmih> timCF: And 'spliceLater =< spliceNow x' won't do?
01:42:21 <timCF> lemmih more correct is `[d| \$(spliceLater $(spliceNow x)) |]`
01:42:43 <dminuoso> timCF: Yeah. Use haskell-src-exts-qq.
01:42:44 <timCF> dminuoso lemmih 1 sec, I have a real simple code example
01:44:26 <dminuoso> Also, haskell-src-exts lets you talk about splices as first-class primitives.
01:45:05 <dminuoso> Since you can just say [d| SpliceDecl l $(spliceNow x) ]
01:45:40 <dminuoso> And for convenience, the above quasiquoter can be used as well
01:46:56 <timCF> here are composed 2 TH functions https://github.com/coingaming/signable/blob/3404f5d8e292b61c99cd45a7bd557fa161525460/haskell/test/TestOrphan.hs#L31 where `mkProxy` creates typed information for `mkSignable` https://github.com/coingaming/signable/blob/3404f5d8e292b61c99cd45a7bd557fa161525460/haskell/src/Data/Signable/TH.hs#L21 The issue here is
01:46:56 <timCF> that kind of just-in-place composition and splicing does not scale (it's just and example, but imagine if I need to write it for 1000 types by hand)
01:51:13 <timCF> dminuoso I wonder why TH don't support `SpliceDecl` itself
01:51:54 <timCF> Or maybe it does, but I didn't found how to declare splices in TH AST terms
01:52:07 <lemmih> timCF: Does 'mkSignable' modify the code generated by the inner splice?
01:52:40 <dminuoso> timCF: For exactly the same reason it's not in haskell-src
01:52:47 <timCF> lemmih it just accepts is as arguments, and returns code
01:52:52 <dminuoso> timCF: With TH you can only generate haskell 2010 AST
01:53:02 <dminuoso> And TH is not a Haskell 2010 feature.
01:53:10 <timCF> ehh :(  
01:54:08 <dminuoso> (well you cant even generate full haskell code, as some things like pragmas or the module definition are outside the scope of TH)
01:54:56 <timCF> absence of `import` and `module` AST in TH is also painful
01:55:35 <Cheery> A question, since I'm bit of indirectly responsible for a recent drama, should I write something like "Haskell is alive and vibrant" or do you think it's throwing more wood into the stove?
01:56:00 <timCF> But it's other question, and not so critical as absence of TH AST itself
01:56:07 <[exa]> Cheery: what drama? :]
01:56:35 <lemmih> timCF: I don't see why you wouldn't just re-write your functions to work with TH.
01:57:26 <Cheery> [exa]: there's a controversy that Haskell should cater more to businesses, the ones that didn't pay to develop it in the first place.
01:58:29 <Cheery> that's true, though he wants it with the cost of loosing the grip to mathematical and theoretical side.
01:59:00 <[exa]> Cheery: do you want to hear my opinion about businesses?
01:59:54 <Cheery> well you ask before you tell it, so maybe I do would like to hear that.
02:00:03 <[exa]> well it's not positive
02:00:05 <Rembane> Cheery: In what context are you responsible for a recent drama? 
02:00:25 <Cheery> Rembane: I wrote a bit of an angry rant as a response to the earlier post.
02:00:29 <timCF> lemmih well, this particular case is just an example, but the main point there is `mkSignable` need `Proxy a` to generate code. This proxy typed data is generated by `mkProxy`. The issue with `>>=` composition here is that `mkProxy` output is `Q Exp` (not `(String, String, Proxy a)` which will be there only when `Q Exp` will be compiled)
02:00:37 <[exa]> Cheery: link?
02:02:01 <Cheery> [exa]: I didn't want to drop it to public, so gave you privmsg.
02:02:17 <timCF> lemmih so basically instead of `foo =<< bar` composition type, I need something like `foo $ compileAST bar` composition type
02:02:35 <merijn> [exa]: My opinion about business in open source can be summarised as "fuck you, pay me" :p
02:02:44 <Rembane> Cheery: Interesting, I want a link too! :)
02:03:23 <lemmih> timCF: Right, but do you actually need to modify the code generated by another splice? Usually you can write your splices to be purely additive.
02:04:24 <lemmih> timCF: For example, you might use one splice to generate data-structures and then another splice to generate instances.
02:05:04 <[exa]> merijn: that kinda coincides with businesses opinion, "let's just beat money out of this"
02:05:15 <lemmih> timCF: That way, the second splice can inspect the generated AST but isn't allowed to modify it.
02:05:32 <timCF> lemmih you mean type of composition I provided in first link? This nested sequential splicing? https://github.com/coingaming/signable/blob/3404f5d8e292b61c99cd45a7bd557fa161525460/haskell/test/TestOrphan.hs#L31
02:06:41 <merijn> [exa]: "Oh, you want my library to support a 5 version old GHC? Fuck you, pay me..."
02:07:21 <Rembane> merijn: Sounds like the text of a punchy t-shirt 
02:08:41 <Rembane> Cheery: I haven't been flame baiting in a while so... I think Haskell has a great future, remember that it is first and foremost a research language and all other uses are just bonuses. 
02:08:50 <lemmih> timCF: Yes. It would be fairly easy to re-write your code to not use nested splices. I get that it is just an example but I think you should consider if you can re-define your usecase in a way that is compatible with TH. Might be a lot less work than using haskell-src-exts.
02:10:03 <merijn> Rembane: I stole it from a graphics design talk about working with clients, which stole it from Goodfellas :p
02:10:36 <merijn> Rembane: It's a good talk if you ever somewhat considered freelancing/consulting: https://www.youtube.com/watch?v=jVkLVRt6c1U
02:11:03 <Rembane> merijn: Stealing like a pro. :)
02:11:23 <Rembane> merijn: Thank you, I have done some freelancing, and getting paid is indeed very important.
02:11:50 <merijn> (it's not just about getting paid, but lots of related things)
02:13:38 <timCF> lemmih well, in this case I need typed data `Proxy a` in compile-time to generate code. I can write it just in place where I'm splicing, or use nested splicing, that's true. But I can't see how to do it in a way to be scalable (to not write every type by hand)
02:13:53 <Rembane> merijn: I'll take a look. :)
02:28:49 * hackage aeson-value-parser 0.19.2.1 - API for parsing "aeson" JSON tree into Haskell types  https://hackage.haskell.org/package/aeson-value-parser-0.19.2.1 (NikitaVolkov)
02:53:32 <kuribas> why is there no MonadFail for (Either String)?
02:54:44 <kuribas> which is suggest by makeRegexM: https://hackage.haskell.org/package/regex-base-0.94.0.0/docs/Text-Regex-Base-RegexLike.html#v:makeRegexM
02:55:11 <merijn> kuribas: That's probably a leftover from fail being in Monad
02:55:23 <merijn> And doing a minimal patch to get it to compile
02:55:42 <dminuoso> A more important question is, why don't we have a MonadFail instance for STM.
02:55:48 <dminuoso> This would be really handy. :)
02:55:59 <merijn> Because the docs say "MonadError" and not "MonadFail"
02:56:16 <dminuoso> Huh?
02:56:25 <kuribas> merijn: the type says MonadFail
02:56:27 <merijn> dminuoso: That was for kuribas
02:56:29 <dminuoso> Ah
02:56:40 <merijn> kuribas: Right, so someone fucked up the migration to MonadFail
02:56:52 <kuribas> merijn: I can work around it with a newtype
02:57:02 <dminuoso> class RegexOptions regex compOpt execOpt => RegexMaker regex compOpt execOpt source | regex -> compOpt execOpt, compOpt -> regex execOpt, execOpt -> regex compOpt where
02:57:05 <dminuoso> What a class definition.
02:59:59 <merijn> This is why I hate every single regex package
03:02:03 <maerwald> merijn: lol... took me probably 2 hours to assemble a simple regex
03:06:36 <[exa]> dminuoso: last time I wanted to use the TDFA regex I ended up gutting the library just to avoid the Text.Regex interface
03:06:51 <[exa]> like, it's not bad, if this was java
03:07:55 <kuribas> the partial `makeRegex` shouldn't be there IMO
03:08:19 <merijn> kuribas: What should it return on a malformed regex, then?
03:08:47 <kuribas> merijn: throwError "regex error whatever"
03:09:27 <kuribas> merijn: actually, I wouldn't make it polymorphic, just "Either String Regex"
03:10:22 <maerwald> [exa]: I've discovered that too that former Java programmers heavily use haskell typeclasses
03:11:05 <kuribas> I am against the tendency to use typeclasses for everything, I think simple is better.
03:11:16 <[exa]> maerwald: INumeric!!! <3
03:11:57 <[exa]> anyway yeah, the general tendency there is to generate a very precise description of reality that does not compose
03:12:28 <[exa]> we should have a name for that.
03:14:15 <maerwald> expressivity and composition are always in a bit of a discord
03:15:07 <kuribas> nope.  composition gives you expressivity
03:16:19 <kuribas> at worst you need a small amount of plumbing
03:16:21 <maerwald> Not vertically
03:16:48 <maerwald> streaming libraries don't compose, but the non-expressive lazy bytestring does
03:23:19 <ADG1089> how can I write parseJSON for this: toJSON a = Aeson.String $ encodeHex a
03:23:39 <ADG1089> parseJSON = decodeHex . fromString ?
03:24:57 <Cheery> ADG1089: please provide types for toJSON and parseJSON here.
03:25:12 <Cheery> they will help you out. :)
03:25:45 <ADG1089> toJSON :: ByteString -> Value & fromJSON :: Value -> Parser ByteString
03:27:02 <Cheery> toJSON takes a ByteString in.. the Value is?
03:27:12 <Cheery> oh moment.. I look into the Aeson lib
03:30:57 <ADG1089> withText "bytestring" $ return . fromJust . decodeHex seems to agree with type signature
03:31:00 <ADG1089> let me test it
03:31:27 <Cheery> ADG1089: are you aware of the Aeson.encode and Aeson.decode ?
03:31:46 <merijn> eh...
03:31:49 <ADG1089> yeah, I was aiming for a custom I/O
03:31:52 <merijn> That is a terrible implementation
03:32:03 <merijn> fromJust will just crash your code when you hit a parse error
03:32:08 <ADG1089> :(
03:32:37 <Cheery> instead of fromJust, you can use... a moment I check
03:32:48 <Cheery> maybe :: b -> (a -> b) -> Maybe a -> b
03:32:54 <dminuoso> kuribas: Composition and expressivity are orthogonal themes. Expressivity is about a) how well a thing communicates its properties and b) how well you can steel those properties to your liking
03:32:56 <merijn> You probably want something like "maybe empty return"
03:32:59 <merijn> :t empty
03:33:00 <lambdabot> Alternative f => f a
03:33:14 <merijn> empty being the failing parser from Alternative
03:33:21 <typetetris> If a servant client has a cookie jar, does it update it automatically if there is a `Set-Cookie` Header in a response?
03:34:35 <Cheery> https://hackage.haskell.org/package/aeson-1.5.4.0/docs/Data-Aeson-Types.html#t:Parser
03:35:06 <Cheery> yup, Parser is alternative so merijn, your sample should work in place of return . fromJust
03:35:16 <kuribas> ah great, makeRegexM is throwing the error as a IO error
03:35:24 <kuribas> it's never passed as MonadFail
03:37:09 <maerwald> which lib
03:37:11 <ADG1089> what about `parseJSON = withText "bytestring" $ maybe mzero return . decodeHex`
03:39:54 <maerwald> kuribas: there's unsafePerformIO :>
03:40:25 <maerwald> makeRegexOptsM c e pattern = either (fail.show) return $ unsafePerformIO $ (compile c e pattern)
03:40:35 <maerwald> so there is your Monadfail :p
03:41:28 <kuribas> that looks fine
03:41:32 <maerwald> yeah
03:41:37 <maerwald> can't see where it would leak
03:42:40 <kuribas> maybe it's the C library which is throwing
03:43:23 <merijn> C can't throw because it has no notion of throwing
03:46:00 <kuribas> merijn: how do you do exception in C?  longjump?
03:46:20 * hackage haskell-gi-base 0.24.3 - Foundation for libraries generated by haskell-gi  https://hackage.haskell.org/package/haskell-gi-base-0.24.3 (inaki)
03:49:10 <merijn> You don't
03:49:30 <merijn> I mean, you could hack something using longjump, but realistically no one sane does that
03:50:08 <dminuoso> kuribas: Exceptions in C++ are usually implemented by setjmp/longjump + an unwinder library
03:50:16 <dminuoso> But that's an implementation detail that can vary
03:50:58 <dminuoso> (I think libunwind is the canonical unwinder for g++/clang)
03:51:11 <[exa]> kuribas: kill(getpid(),SIGUSR1). You can also choose one extra type of exception.
03:51:29 <kuribas> [exa]: lol
03:51:39 <dminuoso> The main takeaway is, if you want exceptions, it needs to tie into memory cleanup.
03:51:52 <dminuoso> In C++ this works because deallocators are called by the unwinder appropriately
03:51:57 <kuribas> merijn: then it's even more weird.  I have no clue where it is throwing
03:52:08 <dminuoso> In Haskell it equivalently works because of the presence of `bracket`
03:52:15 <[exa]> dminuoso: luckily there's no cleanup in C; you just restore the bp/sp, jump, and done
03:52:56 <dminuoso> Depends on what you mean by "luckily" :p
03:53:19 <dminuoso> Even local jumps usually require a practice of jumping into a cleanup label, to free any allocated memory.
03:53:34 <dminuoso> Which makes non-local jumps even more questionable, if used manually
03:58:47 <maerwald> C is for smart people only :p
04:00:33 <dminuoso> Indeed!
04:00:48 <dminuoso> You have to be incredibly talended and smart to write complex and good C code.
04:01:58 <merijn> maerwald: Naah
04:02:07 <merijn> C is for dumb people who think they're smart
04:02:13 <merijn> Smart people know better :p
04:02:17 <dminuoso> They might not.
04:02:27 <dminuoso> You can be smart but just lack knowledge of other languages.
04:02:35 <merijn> irrelevant :p
04:02:37 <dminuoso> heh
04:02:51 <merijn> Smart people who *know* C can realise its bad without knowing alternatives :p
04:02:55 <kuribas> dumb people make it difficult for themselves
04:03:01 <dminuoso> But I stand by my argument, that it takes a really good and talented programmer to write complex, robust and peformant C code.
04:03:06 <kuribas> at least in a work situation
04:03:21 <merijn> I don't know any person who's knowledgeable about C/C++ (including people doing research on C/C++ compilers) who think C is a good idea :p
04:04:57 <dminuoso> It's funny how C has a similar story to PHP. Some random person comes up with a language because no other tools exist, doesn't quite know what hes doing, but it solves their immediate task.
04:05:04 <dminuoso> A decade later that language spreads around the world.
04:05:50 <[exa]> dminuoso: are you sure that's the story of C?
04:05:50 <merijn> I think C is worse, they were working in a lab, someone around should've known better :p
04:05:57 <merijn> [exa]: Sorta
04:06:18 <TMA> I'd not consider either Denis Ritchie or Brian Kernighan a "random person" who "doesn't quite know what he's doing"
04:06:47 <merijn> TMA: When it comes to programming languages they were
04:07:23 <merijn> They weren't experts at programming languages or compiler design, they were a bunch of hackers who threw together the easiest thing for their machine to make it workable
04:07:29 <dminuoso> TMA: At the time they were just random folks, really. They didn't rise to fame until after C has become the most used language on the face of the planet.
04:07:44 <merijn> C was never designed, it was just "whatever is easy on our PDP-11"
04:08:05 <dequbed> And slightly more usable than BCPL at that
04:08:05 <maerwald> merijn: ok ok, but it also didn't *evolve*, which is good
04:08:14 <merijn> maerwald: Yes it did
04:08:22 <merijn> maerwald: Modern C doesn't look like old C at all
04:08:27 <[exa]> how many experts on programming languages AND compiler design were there around in 1972? Anyway C evolved from around 4 other languages (and the version we have now is even more evolved)
04:08:36 <maerwald> merijn: -ansi
04:08:38 <merijn> maerwald: I'm willing to bet that 95% of people have never seen the original C parameter syntax
04:08:39 <maerwald> plz
04:08:52 <merijn> [exa]: Algol and Pascal existed
04:08:59 <merijn> [exa]: Both are superior to C in many ways
04:09:06 <merijn> Possibly all ways :p
04:09:37 <merijn> [exa]: I don't *blame* them for not being experts, but people like to retro-actively pretend they were and C is "gospel from the gods"
04:09:43 <[exa]> that's true, still C won with the implementability
04:10:05 <merijn> And justify the (supposed) superiority of C on the "expertise" of K&R
04:10:15 <dminuoso> Well languages become popular not because they are good, they become popular for all kinds of irrelevant reasons
04:10:29 <[exa]> :]
04:11:14 <merijn> maerwald: Also, even after ansi it did
04:11:17 <maerwald> dminuoso: "good"?
04:11:32 <merijn> maerwald: C11 had to drop a feature from C99 because no one succeeded in implementing it :p
04:13:12 <kuribas> maerwald: I think I found it, that fail is using Prelude.fail, not MonadFail.fail
04:13:26 <merijn> kuribas: Those are the same in recent GHCs
04:13:50 <maerwald> what? How are they different in older GHCs?
04:13:52 <kuribas> merijn: 8.6.5?
04:14:04 <merijn> maerwald: fail from Monad vs fail from MonadFail
04:14:37 <maerwald> yes, but I thought they still do the same thing
04:15:41 <merijn> Yeah, but they're not *the same*
04:16:39 <maerwald> right, buth they both use failIO
04:16:52 <maerwald> for IO
04:17:13 <maerwald> failIO s = IO (raiseIO# (toException (userError s)))
04:20:01 <kuribas> maerwald: indeed, then it must be something else...
04:20:50 <maerwald> well, does your m specialise to IO or not?
04:21:49 <kuribas> ah no, I can see a difference wether I use Prelude.fail or Control.Monad.Fail.fail
04:21:56 <kuribas> though I don't understand why
04:23:01 <maerwald> https://hackage.haskell.org/package/base-4.12.0.0/docs/src/Control.Monad.Fail.html#fail
04:23:17 <maerwald> https://hackage.haskell.org/package/base-4.12.0.0/docs/src/GHC.Base.html#line-1363
04:23:37 <maerwald> both do failIO, the only difference is that one is eta reduced
04:24:54 <kuribas> maerwald: I am not in IO, I am in newtype EitherFail a = EitherFail { getEitherFail :: Either String a }
04:25:05 <kuribas> with fail = EitherFail . Left
04:26:08 <dminuoso> Where to make the case that Data.Traversable should export traverse_? libraries mailing list?
04:26:47 <maerwald> kuribas: fail s      = errorWithoutStackTrace s
04:26:52 <maerwald> that's the default implementation
04:27:00 <maerwald> so Prelude.fail probably triggers that
04:27:58 <maerwald> and Either Monad instance doesn't have overwrite that one
04:28:16 <maerwald> but you could for your newtype
04:28:19 <ski> dminuoso : oh, btw. that anagram question from the other day, i forgot to say that perhaps you could ask it in #esoteric
04:28:57 <dminuoso> ski: That's an interesting idea, indede.
04:29:02 <dminuoso> Thanks for the suggestion.
04:29:24 <kuribas> maerwald: that still looks like a bug in the library to me.
04:29:37 <maerwald> hmmm
04:29:46 <kuribas> maerwald: the type uses MonadFail, but the actual fail used is from Monad.
04:30:06 <maerwald> they probably tried to avoid ifdefs
05:33:15 <spiderman67> !ciao
05:33:23 <spiderman67> !list
05:33:23 <monochrom> spiderman67: http://okmij.org/ftp
06:20:56 <spiderman67> !list
06:20:56 <monochrom> spiderman67: https://hackage.haskell.org/
06:24:19 <dyeplexer> !list
06:24:19 <monochrom> dyeplexer: https://hackage.haskell.org/
06:27:48 <spiderman67> !help
06:28:49 <lemmih> spiderman67: You ok?
06:29:02 <ski> spiderman67 : do you have a Haskell-related question ?
06:30:07 <spiderman67> !list
06:30:07 <monochrom> spiderman67: https://hackage.haskell.org/
07:29:38 <mysterybear> hey I'm working with this https://www.cs.nott.ac.uk/~pszgmh/monparsing.pdf and trying to do the `string :: String -> Parser String` monad comprehension like: string (x:xs) = [x:xs | _ <- char x, _ <- string xs]
07:30:12 <mysterybear> the problem is that in the paper, it's just a type declaration rather than a data declaration with with Parser constructor... so my data type is like:  data Parser a = P (String -> [(a, String)])
07:30:32 <mysterybear> I can't figure out how to do the monad comprehension syntax with the P type constructor, some help please? :D
07:30:50 <dolio> You mean it doesn't have a monad instance to actually use?
07:31:39 <mysterybear> no, I've defined Functor, Applicative, Monad, Alternative ... I can paste, sec
07:32:10 <dolio> No, you don't have to. It means I didn't understand what you were asking. :)
07:33:24 <dolio> Maybe paste the error.
07:34:19 <mysterybear> wait,  are list comprehensions only for the list monad and not for other monads in Haskell?
07:34:24 <comerijn> Do you maybe need to enable the monad comprehension extension?
07:34:30 <comerijn> mysterybear: In early Haskell it was general
07:34:36 <dolio> They are unless you enable MonadComprehensions.
07:34:37 <comerijn> mysterybear: But that was changed
07:34:58 <comerijn> mysterybear: (in Haskell98 already I think)
07:35:11 <dolio> Yeah, Haskell98 is when it changed.
07:35:22 <mysterybear> aha, I'll lookat docs about MonadComprehensions and enable it! thanks
07:36:06 <comerijn> Mind you, you should be able to achieve the same using do-notation fairly easily
07:45:00 <mysterybear> dang, that also has the ill effect of making the vs-code haskell extension hang in formatting :(
07:48:33 <comerijn> mysterybear: Consider just using do notation? ;)
07:50:37 <dolio> Yeah, presumably that doesn't lock up your editor.
07:50:49 <dolio> You can get fancy with it, too.
07:50:59 <dolio> `(x:xs) <$ do char x ; string xs`
08:12:33 <mysterybear> these are not equivalent? `many p = [x:xs | x <- p, xs <- many p] ++ [[]]`  and  `many p = do { x <- p; xs <- many p; return (x:xs) }`
08:12:53 <mysterybear> how do I do the `++ [[]]` bit in the do notation?
08:14:45 <dolio> Well, the `++ [[]]` doesn't have anything to do with the comprehension notation.
08:15:17 <dolio> So the only difference might be that it won't parse without putting the do block in parentheses.
08:15:31 <alp_> that, or: many p = (++[[]]) $ do { ... }
08:15:38 <alp_> not necessarily more readable
08:22:43 <mysterybear> https://eli.thegreenplace.net/2017/deciphering-haskells-applicative-and-monadic-parsers#parser-as-a-functor this article has non-exhaustive issues :( 
08:24:00 <mysterybear> where can I find simple, canonical, proper Haskell definitions of instances like these? It's annoying that Graham Hutton's paper isn't written in actual Haskell, because I really like the paper >.<
08:27:06 <dolio> I think the differences between Gofer and Haskell that would be important to this paper got adopted by Haskell.
08:27:26 <dolio> Aside from names of things being changed.
08:27:46 <ixlun> Does anyone know how I can include a module that is built as part of an executable in a testsuite in cabal?
08:28:21 <ski> mysterybear : what's the issues with that blag ?
08:28:24 <dolio> And then MonadComprehensions got dropped, but you can turn it back on now.
08:28:46 <mysterybear> dolio: and the monad comprehensions, and the `type Parser a = String -> [(a, String)]` vs. `data Parser a = P (String -> [(a, String)]`
08:29:11 <mysterybear> these little differences are a bit thorny for a beginner
08:29:39 <mysterybear> ski: the Functor and Monad definitions are non-exhaustive
08:30:04 <dolio> I'm a little skeptical that Monad instances for type aliases worked in Gofer.
08:30:06 <ski> oh, you mean that they're basically using `[]' as if it was `Maybe' (for some reason i don't know ..)
08:30:49 <ski> iow, only handling a list of parse results that's either empty, or contains a single result
08:30:58 <ski> (no multiple alternative parse results)
08:30:59 <dolio> Oh, it even says it's not valid Gofer, and you need to use a `data` to make it valid.
08:31:03 <ski> yes
08:31:43 <dolio> mysterybear: It seems like the problem with the `++ [[]]` is that it's somehow overloading lists.
08:32:06 <dolio> Also (++) was generalized back then.
08:33:27 <dolio> So, instead of (++) it should be mplus or (<|>), depending on what you're using as equivalent of their MonadOrPlus.
08:33:46 <dolio> And instead of `[[]]` it should be `return []` or similar.
08:34:31 <monochrom> The cited reason for using [] instead of Maybe was "supports ambiguity" and probably a fascination with "turning failure into a list of successes".
08:34:51 <monochrom> But no one ever really used the ambiguity extra feature.
08:35:15 <dolio> The blog has a bunch of instances that will blow up if intermediate things are ambiguous, though.
08:35:17 <monochrom> Especially not in papers that used [] and cited that reason.
08:35:19 <ski> except that that blag doesn't actually implement the multiple results functionality, despite using `[]'
08:35:52 <monochrom> So my suspicious is that the real reason is [] is more elegant than Maybe on several counts.
08:36:05 <ski> syntactically ?
08:36:10 <monochrom> or looks more elegant. Yeah.
08:36:11 <fendor> ixlun, if it is an other-module of the executable, it is simply not possible
08:36:44 <monochrom> But even that is a head-in-sand illusion.
08:37:16 <mysterybear> dolio: so I've written the `string` combinator like this now: https://gist.github.com/mysterybear/1b9916f3953cb0a02884e72193154a5d is it okay or is there a better way to write it?
08:38:28 <mysterybear> oh I was writing the `many` combinator, not the `string` combinator, lol, I'm losing my head >.<  sec
08:38:49 <dolio> Yeah, I was going to say.
08:39:18 <monochrom> Losing your head is unsafe on an empty list.
08:39:49 <ski> the advantage of using `[]' rather than `Maybe' is that you get left distribution. the disadvantage of that is you may leak space
08:42:13 <mysterybear> so yeah this:  https://gist.github.com/mysterybear/2b85183a3fbf1fd46f83d8eed8abddff is my `many` combinator...
08:42:40 <dolio> Yes, that works.
08:42:55 <mysterybear> is it nicely written though, or is it... what's that word for not-nicely-written
08:43:04 <dolio> You might want to know about applicative notation which has since been invented.
08:43:32 <ski> one could refrain from naming the branches
08:43:41 <dolio> You could write it as: `many p = ((:) <$> p <*> many p) <|> pure []`
08:44:10 <dolio> Probably the parentheses aren't necessary, because this kind of use case is expected.
08:44:18 <ski> or `liftA2 (:) p (many p)' instead of the `((:) <$> p <*> many p)' bit, in case you prefer
08:45:03 <monochrom> One branch is better named, and taken out. And its name is "some".
08:50:04 <mysterybear> it's nice that `many` and `some` are already part of Applicative
09:15:20 * hackage rpmbuild-order 0.4.2.1 - Order RPM packages by dependencies  https://hackage.haskell.org/package/rpmbuild-order-0.4.2.1 (JensPetersen)
09:33:26 <justsomeguy> So, I'm doing some simple exercises where I fix syntax errors, and I want to test it in an automated way. What's a good way to do that?
09:33:43 <justsomeguy> ( I notice that ghc throws a parse error. Can I test for that?)
09:46:24 <monochrom> Must you restrict this mechanism to only syntax errors?
09:54:26 <justsomeguy> No, but that happens to be what I'm testing for.
09:54:54 <justsomeguy> I guess another useful thing I could test for is "will this file compile?"
09:55:49 <monochrom> I simply use  ghc MyFile.hs -e ''  and watch for non-0 exit code
09:57:20 * hackage fast-builder 0.1.2.1 - Fast ByteString Builder  https://hackage.haskell.org/package/fast-builder-0.1.2.1 (AkioTakano)
09:57:57 <justsomeguy> That makes sense.
10:05:04 <dmwit> justsomeguy: Perhaps ghcid can sit in this space for you.
10:24:07 <exarkun> What do (indiv) entries in profiler output mean?
10:24:48 <exarkun> And also why are cost centers which have clearly been executed assigned 0 in the "entries" column?
10:32:27 <sm[m]> profiler output has never been highly maintained or optimized, I think is the answer
10:33:11 <kuribas> would this be an acceptable use of lazy IO?  Let's say I have some user information in a service, and extra information which may not be needed and has to be loaded from the database.  If I put it in a lazy IO, it will be only fetched when it's actually needed.
10:33:29 <sm[m]> probably it's considered good enough to make progress, and/or the ghc wizards use newer tools
10:34:11 <dolio> kuribas: Seems okay.
10:34:30 <sm[m]> could be kuribas. I remember a game engine that does essentially that with game assets
10:35:36 <sm[m]> justsomeguy: second vote for ghcid
10:35:37 <exarkun> sm[m]: Okay.  Any idea about the (indiv) part?
10:35:59 <sm[m]> exarkun: sorry, not at this moment
10:36:03 <kuribas> sm[m]: ah neat
10:36:03 <exarkun> okay, thanks
10:36:22 <sm[m]> exarkun: anything in the ghc user guide ?
10:36:35 <exarkun> not that I've been able to find so far
10:36:39 <kuribas> sm[m]: but for game assets you'd also want unloading...
10:37:06 <dolio> I haven't done serious profiling in a while, but in the past, optimizations could sometimes make the cost center attribution kind of confusing.
10:37:26 <exarkun> my best guess is that it's an abbreviation for "individual" which seems to be the heading for the column for "spent here and not in callees".  so something kind of like "self non-function resource usage".
10:37:29 <exarkun> but just a guess
10:38:18 <sajith> "0 entries" seems to be a mystery! https://stackoverflow.com/questions/60760989/what-does-zero-entries-mean-in-ghc-profile-report
10:39:25 <sm[m]> exarkun: that sounds right
10:40:28 <sm[m]> @freenode_kuribas:matrix.org: for big games, I guess so and I don't know how you'd do that in Haskell, probably using more exotic pinned memory or ffi or such
10:40:29 <lambdabot> Unknown command, try @list
10:40:48 <dolio> exarkun: Yeah, individual is resources for code immediately in that cost center, and not in any child cost centers.
10:41:42 <dolio> As opposed to inherited which is the resources spent in the center and all its children.
10:41:53 <sm[m]> exclusive cost rather than inclusive cost, I sometimes call it
10:42:06 <dolio> Yeah, that's a good way of putting it.
10:45:37 <sm[m]> which reminds me: a profile is like a hledger account tree, I should try convert and try hledger-ui for browsing next time
10:46:53 <exarkun> huh.  or, contrariwise, a hledger account tree is like a callgraph and I should try to convert my ledgers to something kcachegrind-friendly.
10:47:18 <sm[m]> Yes indeed
10:47:43 <monochrom> Both are abstract syntax trees.  *duck*
10:51:59 <sm[m]> ghc profiles are in that awkward gap where: you rarely need them, they are tricky enough to produce that few people do, and you need them only for a short time to identify the hot spot, and wizards prefer fancier tools presumably - so there's not much incentive to improve them
10:55:34 <exarkun> Do the wizards let those fancier tools be known to us normals? :)
10:57:35 <maerwald> ghc heap profiles are like: PINNED MEMORY, go figure
11:00:38 <sm[m]> exarkun: sure, I just can't remember which ones are latest. Hackage knows perhaps
11:01:05 <sm[m]> "heapview", "flame" etc. 
11:01:52 <sm[m]> on a more mundane level, I found profiterole quite good for simplifying profiles
11:03:23 <Guest_9> I am having a really hard time installing Haskell on my mac
11:03:30 <merijn> exarkun: Have you heard about our lord and saviour: speedscope.app?
11:03:41 <maerwald> Guest_9: how
11:03:48 <exarkun> merijn: nope, thanks
11:03:56 <merijn> exarkun: https://mpickering.github.io/posts/2019-11-07-hs-speedscope.html
11:04:14 <merijn> exarkun: You need to be willing to migrate to GHC 8.10 for maximum effect, but it will make looking through profiles much better :p
11:04:29 <sm[m]> exarkun: also you can always paste a profile and crowd source interpreting it, more such discussion would be useful I think
11:04:34 <Guest_9> I download it the terminal command
11:04:35 <Guest_9> curl --proto '=https' --tlsv1.2 -sSf https://get-ghcup.haskell.org | sh
11:04:49 <Guest_9> and it seems to go smoothly.
11:04:58 <Guest_9> but ghci does nothing aftwerwards
11:05:38 <maerwald> Guest_9: source ~/.ghcup/env
11:05:42 <Guest_9> More accurately it says command not found
11:06:06 <Guest_9> Ok thank you, that did something.
11:06:23 <Guest_9> But if I close the terminal, am I going to have to do that again?
11:06:33 <maerwald> add it to your bashrc
11:06:42 <Guest_9> Yes
11:06:50 <Guest_9> just that exact line?
11:06:53 <maerwald> yes
11:08:48 <Guest_9> It didn't work
11:09:44 <Guest_9> This is really the crux of the problem for me.  I can get it running once, but I can't configure it to run on new terminals.
11:10:35 <Guest_9> Which is not the greatest problem to have, to be fair.
11:12:27 <[exa]> Guest_9: that thing installs ghcup AFAIK (which is kindof like a ghc version manager), which you still need to use to install some version of GHC an GHCi
11:12:40 <glguy> maerwald: What generates .ghcup/env?
11:12:54 <glguy> (because I don't have one)
11:13:33 <maerwald> glguy: the bootstrap script only, not ghcup itself
11:15:12 <maerwald> it's not very reliable... e.g. ghcup supports xdg dirs, then it would break
11:15:38 <maerwald> although maybe not, I don't remember
11:16:14 <Guest_9> So why are the changes to my .bashrc not doing anything?
11:16:30 <maerwald> Guest_9: what does your .bash_profile say?
11:17:08 <Guest_9> # Setting PATH for Python 3.8# The original version is saved in .bash_profile.pysavePATH="/Library/Frameworks/Python.framework/Versions/3.8/bin:${PATH}"# Trying and failing to setting PATH for HASKELL (Ghcup)# PATH="/Users/saracasey/.ghcup/env:${PATH}"export PATH
11:17:20 <Guest_9> It did not show the line breaks lol
11:17:27 <maerwald> use a pastebin
11:17:30 <maerwald> @where paste
11:17:30 <lambdabot> please paste full code, input, and output at https://paste.tomsmeding.com
11:17:51 <Guest_9> Anyway its some stuff that Python put on, and some stuff I tried to put on which is commented out.
11:18:31 <maerwald> Add this to .bash_profile: [[ -f ~/.bashrc ]] && source ~/.bashrc
11:18:57 <Guest_9> Anywhere?
11:18:58 <tomsmeding> it's a macOS thing that that line is not in .bash_profile by default
11:19:07 <tomsmeding> I guess at the top
11:19:16 <tomsmeding> because tools tend to put stuff at the bottom
11:20:07 <Guest_9> Sucess.
11:20:15 <Guest_9> Thanks a million.
11:20:51 <tomsmeding> though Guest_9: I think it's more robust to put 'export PATH="${HOME}/.ghcup/bin"' directly in your .bashrc
11:20:59 <tomsmeding> instead of a source of that env file
11:20:59 <sm[m]> so many ways for this to go wrong, alas!
11:21:16 <tomsmeding> (also that was wrong with your previous PATH attempt: it's /bin, not /env :) )
11:21:31 <maerwald> tomsmeding: why
11:21:53 <maerwald> the env file is fine
11:21:58 <tomsmeding> I guess
11:22:32 <maerwald> especially since you want .cabal/bin so overrule it
11:23:26 <tomsmeding> sure, the env file is fine, but I fail to see how wanting .cabal/bin in your path has anything to do with that :p
11:23:51 <Ashley33> s
11:23:53 <maerwald> tomsmeding: that's what the env file does, your line in fact breaks PATH
11:24:03 <Ashley33> Hey! I'm female 23 and I'm so horny right now. Wanna trade pics with cute man. Add me here >> http://NUDsY.FUN << :
11:24:08 <tomsmeding> OH
11:24:15 <tomsmeding> I mistyped :')
11:24:17 <cr0ssw1nd> heya
11:24:37 <tomsmeding> 'export PATH="${HOME}/.ghcup/bin:${PATH}"' of course :')
11:24:37 <cr0ssw1nd> is it possible to compile haskell executable binary statically?
11:25:00 <maerwald> cr0ssw1nd: yes
11:25:16 <maerwald> you need musl though
11:25:25 <maerwald> there's no partially static linking
11:25:29 <typetetris> cr0ssw1nd: building in an alpine docker container looks like the most painless route to me for static building haskell
11:25:56 <cr0ssw1nd> full static linking is ok if it will not weigh 1GB..
11:26:04 <cr0ssw1nd> but I guess it shouldn't
11:26:15 <maerwald> cabal build --ghc-options='-split-sections -optl-static'
11:26:30 <cr0ssw1nd> oh, so -optl-static is still valid
11:26:36 <maerwald> yes
11:26:45 <Guest_9> Ok, thanks again y'all.  Chances are I'll be back though.
11:26:54 <cr0ssw1nd> I just found `-static -optl-static` but that was about ghc 6.8
11:27:00 <cr0ssw1nd> -static is already not there?
11:27:09 <cr0ssw1nd> ghc --help doesn't mention static now
11:27:18 <maerwald> dunno, the above definitely works
11:27:26 <cr0ssw1nd> gotcha, thanks
11:27:29 * sm[m] grumbles about ghc --help
11:28:07 <cr0ssw1nd> wait but is musl taken automatically? if I am using stack
11:28:20 <Guest49> Hey! I'm female 23 and I'm so horny right now. Wanna trade pics with cute man. Add me here >> https://bit.ly/2FoWvlf << :
11:28:34 <maerwald> cr0ssw1nd: stack doesn't provide alpine GHCs last I tried (at leat with 8.6.5 and some other GHCs)
11:28:40 <maerwald> ghcup does though
11:29:05 <cr0ssw1nd> but stack will catch what is installed via ghcup ?
11:29:20 <maerwald> cr0ssw1nd: if you use "stack --sytem-ghc" yes
11:30:31 <maerwald> cr0ssw1nd: https://paste.tomsmeding.com/uWlml5Ux
11:30:43 <maerwald> an example
11:31:38 <cr0ssw1nd> thanks!
11:46:54 <sm[m]> nice
12:01:43 <eric___> Hi everyone, 
12:02:11 <eric___> I want to know how can I help haskell language?
12:02:48 <eric___> I mean.. ghc and compiler stuff.
12:05:18 <sm[m]> #ghc will tell you eric___ 
12:05:31 <eric___> thanks
12:05:38 <eric___> \join #ghc
12:05:53 <geekosaur> other slash
12:28:19 <cr0ssw1nd> continuing the topic of static compilation.. 
12:28:42 <cr0ssw1nd> I found another Docker image written specifically for the project I forked
12:28:55 <cr0ssw1nd> https://github.com/wireapp/wire-server/blob/develop/build/alpine/Dockerfile.builder
12:29:27 <cr0ssw1nd> but if I derive my Dockerfile from it and add trivial compilation, then it fails with error about wrong ghc version
12:29:28 <cr0ssw1nd> https://paste.tomsmeding.com/e3RD1oHv
12:30:03 <cr0ssw1nd> can't understand how is it possible if stack used to initialize the project should add correct version of ghc
12:33:47 <geekosaur> because the other Dockerfile overrides it with a specific ghc version
12:33:47 <nij> Not sure if this is the right place to ask.. but what's the point of type theory?
12:33:54 <cr0ssw1nd> probably I should adapt it like in maerwald example though..
12:33:59 <dmwit> That error says that stack doesn't know where to download a copy of GHC-8.8 from. I don't know stack, but there's probably a way to ask it to update its list of known compiler locations.
12:34:56 <geekosaur> oh, hm. stack relocated everything, you need to upgrade stack itself and then run the upgraded one
12:35:01 <cr0ssw1nd> dmwit, probably I should tweak it a bit, yeah
12:35:05 <dmwit> nij: It's an alternative axiomatization of mathematics. So... about the same point as set theory, but nicer to work with in some ways.
12:35:20 <nij> My understanding is that untyped language, while powerful, is error-prone. So humans add types into consideration. However, the simplest way of doing so takes too much power away (in typed lambda).. so people try to add its power back by augmenting the type systems.
12:35:52 <dmwit> Oh, whoops. You were asking for a completely different level of justification. Sorry. =P
12:36:21 <nij> dmwit: nah that's a legit point as well. Sadly I haven't learned what a homotopy type theory is..
12:36:26 <cr0ssw1nd> geekosaur, dmwit, I figured it out, indeed I have to do update
12:36:38 <cr0ssw1nd> I'm deriving from this image https://github.com/wireapp/wire-server/blob/develop/build/alpine/Dockerfile.builder
12:36:43 <monochrom> Reminds me that some people use "type theory" to simply refer to the study and invention of various type systems, e.g., they would describe TaPL as "type theory".
12:36:45 <dmwit> nij: I like my coworker's way of selling a type system. If a guy walked into your shop and offered to write 500 tests per day, even though he didn't really know the codebase, what would you do? You'd high-five him and put him to work right away. Doesn't even matter if the tests are super-trivial.
12:36:46 <cr0ssw1nd> but I should actually derive from base image of that one
12:37:13 <nij> to continue my naive understanding: As people add features into type theory, they want to check 1. if it really offers power and 2. how unsafe (eg undecidablility) it becomes.
12:37:28 <nij> And that's the point of type theory (? just my guess)
12:38:04 <PropositionJoe> foldr is similar to python reduce right?
12:38:10 <Rembane> Yup
12:38:37 <geekosaur> it would also be nice if it didn't require too much type system "noise" to write useful code, of course :)
12:38:39 <monochrom> "similar" is highly bendable so yes
12:38:55 <dmwit> nij: Sure. Another way to understand it is: type systems are a particularly predictable form of static analysis. So we don't *always* design new type systems to offer more power; sometimes we design them to check a new and different kind of thing.
12:39:48 <dmwit> nij: e.g. that resources are acquired and released in the right way, or that pointers are not aliased in bad ways, or that the physics you're doing has dimensions that make sense
12:41:05 <nij> dmwit: Yeah. So it seems that type theorists are trying to *carefully* strike the balance between power and error-proof-ness
12:41:19 <nij> Is that the point of type theory?
12:41:52 <nshepperd> i figure that the point of type theory is that you've gotta have theory or else you don't know if your type system makes sense
12:42:02 <dmwit> Mmm, no, I think the point is to check things you care about. The fact that doing that involves striking such a balance is a consequence of, like, the halting problem and stuff.
12:42:21 <dmwit> The point is the check. The consequence is the tricky balance.
12:42:30 <nshepperd> and you've gotta have a type system, or else you don't know if your program makes sense!
12:42:54 <monochrom> The "the" fallacy.
12:43:16 <MarcelineVQ> die bart, die
12:43:33 <geekosaur> nshepperd, plenty of folks don't particularly care of the theory makes sense (see complaints about OO and being certain what objects receive the right messages, IIRC)
12:43:41 <geekosaur> *if the theory
12:44:07 <monochrom> Also, the halting problem is only an extreme. Even when some problem is solv"able", the more important question is for how much cost and how much benefit.
12:44:17 <nij> nshepperd: you are probably meritting the benefits of "error-proof-ness", in my term, right?
12:44:32 <exarkun> Hey I bracketed all my SQLite3 use with connect/close but I still ended up leaking an open database file descriptor (or two, -wal) for every ErrorBusy SQLite3 threw at me ...
12:45:07 <dmwit> exarkun: Perhaps you'd like:
12:45:08 <dmwit> :t bracket
12:45:09 <lambdabot> IO a -> (a -> IO b) -> (a -> IO c) -> IO c
12:45:16 <dmwit> Is that the thing you meant by bracket in your question?
12:45:20 <exarkun> dmwit: no right now I hate it because that's what I meant :)
12:45:28 <dmwit> Ok!
12:45:51 <exarkun> but I wrote this code at least six months ago, maybe I should refresh my memory about why I thought it would work
12:45:59 <geekosaur> isn't there a known issue with bracket and async exceptions?
12:46:17 <monochrom> But ErrorBusy sounds like synchronous
12:46:20 <nshepperd> nij: i suppose so
12:46:46 <exarkun> I guess the standard mistake is probably for `acquire` to raise an exception and leak some resource itself
12:47:07 <nij> :t undefined
12:47:08 <lambdabot> a
12:49:05 <monochrom> If you acquire two resources, you need to break it into two.   bracket acquire1st release1st (bracket acquire2nd release2nd (...))
12:50:09 <nshepperd> a different perspective is that the point of type theory (or type systems) is to implement on computers programmer intuition about what programs are valid
12:50:43 <nshepperd> it's a labor saving device, as you no longer have to figure it out from scratch every time you read some code
12:56:34 <dolio> monochrom: Algebra is the study of algebras. It's not that unusual. :)
13:10:50 * hackage yesod-page-cursor 2.0.0.0 -   https://hackage.haskell.org/package/yesod-page-cursor-2.0.0.0 (cdparks)
13:25:29 <maerwald> sm[m]: speedscope is amazing
13:27:07 <maerwald> just I don't know how to share a view
13:28:19 <monochrom> Nice, but it's a new development, not something wizards have been using for a long time. Apart from possible conspiracy theories.
13:29:09 <monochrom> I haven't heard of any wizard tools.
13:30:14 <maerwald> yeah, this is why regular profile is hard to read... it would tell you e.g. 'handleIO' is a hot spot, but that's just at the top of the callstack
13:30:40 <monochrom> Also sounds like speedcope doesn't add data, only presents GHC profiling data. If GHC says "0 for cost centre foo" speedscope is not going to fix that.
13:33:30 <maerwald> ok, but can I have the same for memory use?
13:33:41 <monochrom> heh
13:34:02 <jle`> is there something like a `data V2 a = V2 a a` that i can assemble using things in base? i just want a two-item list with total indexing really
13:34:03 <monochrom> I think nothing is going to refine "PINNED MEMORY" into refiner grains for now.
13:34:12 <maerwald> game over
13:34:29 <jle`> (with a Functor instance)
13:35:39 <monochrom> I think no.
13:37:47 <jle`> :(
13:37:55 <jle`> (Product Identity Identity) i guess
13:38:00 <jle`> but meh
13:41:42 <sm[m]> here's a little profiling puzzle.. at https://github.com/simonmichael/hledger/issues/1350#issuecomment-690670150, I feel that stripAnsi has been pessimised. Essentially just one line has changed a little, see "1.19 stripAnsi, 1.19.1 stripAnsi". If I'm right, can you see why it's slower ?
13:43:54 <sm[m]> or more briefly, do you see why the second of these would be slower ?
13:43:54 <sm[m]> parseMaybe (many $ takeWhile1P Nothing (/='\ESC') <|> "" <$ ansi) s
13:43:54 <sm[m]> parseMaybe (many $ "" <$ try ansi <|> pure <$> anySingle) s
13:45:38 <sm[m]> more backtracking I assume
13:49:06 <dolio> Yeah, this seems like you reversed the branch prediction, basically.
13:49:14 <dolio> And to the wrong branch.
13:55:02 <dolio> Is the try actually necessary? Did you change it because there might be \ESC characters that aren't ansi sequences or something?
13:55:32 <sm[m]> it's not my change, I'm still grokking it
13:55:39 <dolio> Oh, I see.
13:56:08 <maerwald> sm[m]: stripAnsi "\ESC[31m\ESC[m" -- fails with the old function?
13:57:53 <maerwald> I think the correct change is *just* changing takeWhile1P to takeWhileP
13:58:01 <sm[m]> maerwald: you're right
13:59:17 <sm[m]> I shall try that
14:00:00 <maerwald> ah, it cannot fail
14:00:08 <maerwald> that's why it doesn't work with <|>
14:03:47 <maerwald> seems like only the second chunk is relevant
14:04:32 <sm[m]> cannot fail - as in, ... <|> try ... is always wrong ?
14:04:48 <sm[m]> that makes sense
14:04:53 <maerwald> takeWhileP -- 'The combinator never fails, although it may parse the empty chunk."
14:05:38 <maerwald> so I suspect they tried to replace both, then got bitten by it and changed the line that was already correct
14:07:10 <newtohaskell> Hey guys! So, I have a function delStrengen :: String -> [String] -- delStrengen [] = [[]] -- delStrengen (' ':xs) = [] : delStrengen xs -- delStrengen (x:xs) = let h:tl = delStrengen xs in (x:h) : tl which I want to generalise into gdelStrengen :: String -> String -> [String] in which for example gdelStrengen "abcbdecefab" "ac" ==
14:07:10 <newtohaskell> ["b","bde","ef","b"]
14:07:18 <newtohaskell> Any chance someone can help me with that?
14:07:28 <maerwald> use pastebin
14:07:31 <maerwald> @where paste
14:07:31 <lambdabot> please paste full code, input, and output at https://paste.tomsmeding.com
14:09:32 <newtohaskell> https://paste.tomsmeding.com/vWxXlalp
14:10:05 <newtohaskell> In which the last bit of code there is just an example of the input/output
14:11:11 <maerwald> where is the problem?
14:11:12 <ski> newtohaskell : do you know about guards ?
14:11:28 <newtohaskell> Yeah, i've used guards
14:11:44 <newtohaskell> The problem is that I have absolutely no clue as to how I should do that generalisation :p  
14:11:50 <xerox_> quis custodiet ipsos custodes
14:12:01 <ski> > 'b' `elem` "abc"
14:12:02 <maerwald> newtohaskell: what does the first function do?
14:12:03 <lambdabot>  True
14:13:18 <newtohaskell> delStrengen "aaa bbb c cc" ==  ["aaa","bbb","c", "cc"]
14:13:27 <newtohaskell> It is basically a words function
14:13:56 <maerwald> so it splits by ' '?
14:14:13 <newtohaskell> Yes, it splits by ' '
14:14:15 <maerwald> what does the second function do?
14:14:29 <sm[m]> it splits by any of the chars in the arg
14:14:33 <newtohaskell> The generalised one should split by whatever I insert into it
14:14:47 <maerwald> yeah, so where is the place where the first function splits by the ' '?
14:14:47 <sm[m]> a type of [Char] would be a little clearer
14:15:02 <maerwald> that's the place where you need to change something
14:15:37 <newtohaskell> gdelStrengen "aaa bbb c cc" " " == ["aaa","bbb","c","cc"] 
14:15:43 <newtohaskell> gdelStrengen "abcbdecefab" "ac" == ["b","bde","ef","b"]
14:16:02 <newtohaskell> so that it splits by whatever I insert into the second list
14:16:05 <sm[m]> like https://hackage.haskell.org/package/split-0.2.3.4/docs/Data-List-Split.html#v:splitOneOf
14:16:32 <maerwald> newtohaskell: no, in the definition of the first function, where does the split occur?
14:16:33 <ski> (presumably newtohaskell wants to do it, by hand, to better learn Haskell, rather than get a canned solution)
14:16:52 <sm[m]> sure, sure
14:17:20 <newtohaskell> That would be correct :p
14:18:07 <ski> newtohaskell : so you want to split on any of the `Char'acters in the second `String' parameter ?
14:18:22 <newtohaskell> in the first one the split occur at the spaces, doesn't it?
14:18:26 <ski> yes
14:18:47 <newtohaskell> yes, whichever one(s) I insert into the second list
14:18:55 <maerwald> then write that
14:19:14 <newtohaskell> Thought I did, sorry if I was a bit unclear
14:19:25 <monochrom> newtohaskell: ski means this: You are currently using the two patterns ' ':xs and x:xs.  Can you use guards instead of patterns to detect the space?  Once you can do that, it's obvious how to detect other characters instead of space.
14:20:06 <monochrom> Or use if-then-else.
14:21:00 <newtohaskell> Something along the lines of gdelStrengen (x:xs) ys = if x == ys then [] : gdelStrengen ... then?
14:21:40 <maerwald> also, is the 4th line intentional?
14:22:06 <maerwald> delStrengen "abc  def" == ["abc","","def"]
14:22:09 <ski> > delStrengen "Ja, vi  elsker denne   kanalen"
14:22:12 <lambdabot>  ["Ja,","vi","","elsker","denne","","","kanalen"]
14:22:15 <maerwald> yeah
14:22:35 <newtohaskell> Oh shit, yea no
14:23:10 <ski> newtohaskell : yes, could work
14:24:23 <newtohaskell> Yeah, i've been attempting to find a good continuation of that code, but simply cannot find one 
14:24:54 <sm[m]> from previous thread before I lose it - may I check my parser reading skills: takeWhile1P Nothing (/='\ESC') <|> "" <$ ansi   means "one or more non-escape chars, or an ansi sequence (and return the empty string)". And: "" <$ try ansi <|> pure <$> anySingle   means "an ansi sequence or nothing at all (and return the empty string), or any character" ?
14:26:08 <sm[m]> and the ", or any character" bit never happens. I think that's what you said maerwald 
14:27:11 <dolio> sm[m]: The latter means an ansi sequence and yield the empty string, or any character.
14:27:38 <dolio> Assuming `anySingle` means any character.
14:27:58 <sm[m]> dolio: doesn't the try mean the parser will also succeed by parsing nothing, if it's not seeing an ansi sequence
14:28:02 <dolio> sm[m]: That's probably another reason why it's slower. It's making the chunks smaller.
14:28:05 <maerwald> sm[m]: no
14:28:12 <maerwald> try means it will backtrack
14:28:14 <sm[m]> oh.. right
14:28:24 <sm[m]> it will then try the right hand side
14:28:29 <maerwald> takeWhile1P backtracks automatically
14:28:38 <sm[m]> aha
14:28:41 <maerwald> megaparsec is a bit awkward in that regard
14:28:43 <maerwald> I don't like it
14:28:51 <maerwald> you never know what backtracks
14:29:15 <dolio> Is that true? The old version was factored in such a way that no backtracking was necessary.
14:29:30 <dolio> It would fail on the first character.
14:30:05 <maerwald> yeah
14:30:12 <maerwald> so not really backtracking
14:30:51 <maerwald> but string backtracks automatically
14:31:38 <dolio> Ah. I guess they want stuff like that to be sort of 'atomic'.
14:31:57 <maerwald> just use attoparsec :p
14:32:46 <dolio> Anyhow, now that it's been pointed out, it's possible that the backtracking isn't even the issue.
14:33:02 <dolio> It's doing everything character-at-a-time and then concatenating.
14:33:59 <dolio> That is, it's hard to tell which is more of a problem.
14:34:45 <dolio> Could be both, of course.
14:38:04 <sm[m]> both the extra backtracking and the parsing in smaller chunks are starting to make sense here. Thanks, all
14:39:25 * sm[m] loves megaparsec but doesn't use it regularly enough to feel really comfortable with it
14:47:17 <sm[m]> I unfortunately call this a lot - we apply colour first and then measure everything a million times to figure out screen layout. Which requires stripping out the colour codes. Doing it in the proper order is probably going to be a big deal so I'd better make this fast
14:49:49 * hackage RtMidi 0.2.0.0 - Haskell wrapper for RtMidi, the lightweight, cross-platform MIDI I/O library.  https://hackage.haskell.org/package/RtMidi-0.2.0.0 (ejconlon)
15:15:46 <nut> Do people use ADTs such as queues and stacks in Haskell?
15:16:02 <nut> I couldn't find the library for these things
15:18:06 <dolio> [a] is a stack.
15:19:23 <hpc> and a queue, depending on how you produce and consume it ;)
15:20:17 <hpc> depending on what you need it for, there's usually other more specifically useful types
15:20:22 <nut> if so, how come in other languages there's usually a special package for ques and stacks
15:20:42 <dolio> No, it isn't a queue.
15:20:45 <hpc> like maybe Chan or TChan, depending on what sort of concurrency you're using
15:20:48 <koz_> For Data.IntCast, will intCast accept an Int8 to Word8 conversion?
15:21:36 <dolio> I'm sure edison has queues, although I don't know how well maintained it is.
15:33:15 <dolio> Oh, also, Seq from containers can be used as a queue with the right asymptotics, of course, but the constant factors aren't great.
16:41:19 * hackage postgres-websockets 0.9.0.0 - Middleware to map LISTEN/NOTIFY messages to Websockets  https://hackage.haskell.org/package/postgres-websockets-0.9.0.0 (diogob)
17:54:42 <natpd> how do i turn M.Map String a into a?
18:00:40 <sm[m]> M.lookup "key"
18:01:23 <monochrom> Now you have merely reduced the problem to "how do I turn Maybe a into a"
18:01:31 <monochrom> The power of XY problems.
18:04:27 <justsomeguy> When I write "x = 3", what is that called? A name binding? I know it's not an assignment statement.
18:04:51 <sm[m]> yup
18:06:36 <sm[m]> except at the ghci prompt, where it actually is a destructive assignment
18:06:40 <brettgilio> https://algebradriven.design/
18:06:55 <sm[m]> being shorthand for "let x = 3"
18:09:49 <monochrom> No, it's shadowing rather than destructive.
18:09:54 <justsomeguy> Are lines in ghci are like "let it = line in do { print it ; let it = nextLine in do { print it; ... }}"?
18:10:40 <monochrom> This sequence "x = 3; f a = a+x; x = 4;" still results in f a = a+3, not f a = a+4
18:11:07 <monochrom> Yes that was an original intention.
18:11:30 <monochrom> But since then it has been long lost.
18:12:01 <monochrom> You can't fit "data X = ..." in that story. You can't fit "import YYY" in that story.
18:13:40 <justsomeguy> Hmm, there are a bunch of cases I hadn't thought of. At least it seems like the right intuition, I think.
18:21:57 <sm[m]> monochrom good distinction but I think for someone operating the ghci prompt the experience is the same as destructive assignment
18:22:20 <sm[m]> I mean assignment by value, not by reference
18:26:47 <mastarija> can someone remind me what is the "official" name for the -> type constructor?
18:26:52 <mastarija> Is it function constructor?
18:37:27 <Axman6> function arrow?
18:44:50 <koz_> Oh hay, Sandy Maguire just finished his next book.
18:45:30 <Axman6> :o
18:45:54 <yushyin> mastarija: yup https://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-650004.1.2
18:59:49 * hackage bindings-portaudio 0.3 - Low-level bindings to portaudio library  https://hackage.haskell.org/package/bindings-portaudio-0.3 (FumiakiKinoshita)
19:17:19 <jmc> @pl \f g x y -> f (x ++ g x) (g y)
19:17:19 <lambdabot> join . ((flip . ((.) .)) .) . (. ap (++)) . (.)
19:17:31 <jmc> @pl \f g x y -> f (x ++ g x) (g y)
19:17:31 <lambdabot> join . ((flip . ((.) .)) .) . (. ap (++)) . (.)
19:18:54 <jmc> @pl foobar' :: [Integer] -> Integer
19:18:54 <lambdabot> (line 1, column 24):
19:18:54 <lambdabot> unexpected '>'
19:18:55 <lambdabot> expecting operator
19:19:30 <Axman6> is there anything in ghc which ensures that f . g . h becomes exactly \x -> f (g (h x)) and not \x -> f ((\y -> g (h y)) x), avoiding the extra closure?
19:20:04 <Axman6> just wondering if if have an arbitrary number of functions being composed that there will be a single closure
19:21:11 <Axman6> if I*
19:23:57 <unsolved-problem> I'm trying to compile a program using a .so in my cabal sandbox. But I can't convince GHC not to look at defaults. It says `Loaded package environment from ~/.ghc/x86_64-linux-8.6.5/environments/default`
19:23:58 <unsolved-problem> What
19:24:14 <unsolved-problem> 's the correct way of specifying a path?
19:24:39 <unsolved-problem> I tried GHC_PACKAGE_PATH env var and -package-db flags
19:25:32 <unsolved-problem> when I compile with -v it produces too must result,I
19:25:52 <unsolved-problem> 'm not sure what to grep (sorry for accidentally producing too many lines, ot)
19:28:28 <lemmih> unsolved-problem: Did you use 'extra-lib-dirs'?
19:29:56 <unsolved-problem> to cabal or ghc?
19:30:14 <lemmih> unsolved-problem: It's a field in your .cabal file.
19:30:30 <unsolved-problem> BTW the compilation step is successful, ld.gold fails
19:30:39 <lemmih> https://cabal.readthedocs.io/en/3.4/cabal-package.html#pkg-field-extra-lib-dirs
19:31:21 <unsolved-problem> But I run GHC to compile not cabal (it's automatically called by agda), does ghc read cabal config file?
19:32:43 <lemmih> unsolved-problem: Could you explain more about what you're trying to do?
19:33:28 <unsolved-problem> yeah sorry. To be more concrete, I
19:33:41 <unsolved-problem> ah sorry I keep pressing enter! I'm using a new interface
19:35:42 <unsolved-problem> I'm compiling my program with "ghc ..." which is called automatically by another binary but I can place any cmd line options to ghc or env variables. ghc says it's loading the "default" environment. But default environment contains old packages so at the linking step I get `/usr/bin/ld.gold: error: cannot find
19:35:43 <unsolved-problem> -lHSregex-base-0.94.0.0-83cf4d8eac97e9aa145a3d27ac67bed98c4e85b4079681c563b9474b72d6c8c0_p`
19:36:38 <unsolved-problem> in particular, .ghc/x86_64-linux-8.6.5/environments/default contains these packages, I want to replace this default env by my own
19:37:06 <lemmih> unsolved-problem: And you cannot use cabal?
19:38:55 <unsolved-problem> I mean I can but my program is written in agda; agda compiles it to haskell and automatically calls `ghc ...` I can't make it call `cabal install` etc. Does it make sense? Sorry I'm not super familiar with cabal, does it call ghc or...? how does it relate to ghc?
19:39:36 <lemmih> And agda generates code that uses regex-base?
19:39:44 <unsolved-problem> yes
19:40:06 <unsolved-problem> actually, let me read the document you gave me, I can just call cabal manually myself after linking fails :D  sounds hacky but maybe it'd work
19:41:12 <lemmih> You could ask in #agda. If agda generates code that uses regex-base but doesn't make sure regex-base is install then that sounds like a bug.
19:42:16 <dolio> It sounds like agda's pipeline wasn't designed to be used with sandboxes.
19:42:20 <unsolved-problem> yeah it's definitely an Ubuntu bug, I read some discussion about it, ubuntu's agda package is broken (I think?), so I compiled everything myself using cabal
19:42:33 <unsolved-problem> anyway thanks, sounds like there is no quick answer. Let me do more reading
19:42:54 <lemmih> unsolved-problem: Is Agda using cabal's sandboxes? Or is that something you configured? If so, try without a sandbox.
19:43:04 <unsolved-problem> I configured it myself
19:43:15 <unsolved-problem> I compiled agda, regex etc (all dependencies) in a cabal sandbox
19:43:16 <dolio> Did you install Agda in the sandbox only?
19:43:19 <dolio> Ah, right.
19:43:32 <unsolved-problem> but my project is in a different sandbox. Is that not supported maybe?
19:43:41 <unsolved-problem> should I install all in the same sanbox?
19:43:49 <dolio> That sounds even less likely to work, yeah.
19:44:14 <unsolved-problem> ok thanks. Sorry I'm not familiar with haskell ecosystem I just don't know what are the best practices. :D
19:45:19 <dolio> I'm not sure only using one sandbox actually will work.
19:45:30 <dolio> But it's probably more likely.
19:46:25 <unsolved-problem> what the usual practice? Say, if I have two different cabal sandboxes, how do I point it to link using .so in the other one?
19:46:42 <dolio> Most Haskell users don't write Agda programs.
19:46:53 <unsolved-problem> yeah, I'm asking for haskell
19:47:12 <unsolved-problem> what if you have two sandboxes. Is that unusual?
19:47:39 <dolio> Oh. I'm not sure you can link two sandboxes. You can have a sandbox that references other directories for dependencies, I think. I never got too fancy with sandboxes, though.
19:48:09 <lemmih> I think sandboxes went out of favour. Now nix-style builds are all the rage.
19:48:14 <unsolved-problem> I see ok, that makes sense. In my mind I thought just showing GHC the path with .so files should do the trick
19:49:02 <unsolved-problem> are nix-style builds new style cabal commands?
19:49:06 <lemmih> Yeah.
19:49:20 <unsolved-problem> ok thanks I'll read into it. I really appreciate pointers
19:49:55 <dolio> I've never built an executable with agda though. I'm not sure if it supports nix-style stuff, either.
20:03:59 <Axman6> int-e: a few months ago someone wrote some code got generating primes using mutually recursive primes/isPrime definitions, and someone had a definition which included something like scanl (+) 0 $ cycle [2,4,2,6] or something - was that you or merijn?
21:21:56 <unsolved-problem> So I solved my problem from a couple hours ago -- in case anyone wonders --, I manually `cabal install {libs} --enable-profiling` because apparently when you install without the flag it doesn't compile for profiling. And then I manually removed old library version from my .ghc/.../defaults file and Voila! My program compiles both normally and with
21:21:56 <unsolved-problem> profile enabled.
21:25:37 <dolio> unsolved-problem: You can put `library-profiling: True` in your .cabal/config to always build profiling libs.
21:27:27 <unsolved-problem> ah thanks for the tip! Cabal definitely has a learning curve. Also when I reinstalled it didn't really work I had to `--force-reinstall` regex libs one by one.
21:27:48 <unsolved-problem> Anyway, I'm happy it works now.
21:27:51 <unsolved-problem> thanks all!
21:29:42 <dolio> Yes, the old style of installing was resistant to reinstalling, because it could break dependencies. The point of sandboxes was to have local environments for different sets of installed things, because different environments might need different versions that couldn't be simultaneously installed.
21:30:23 <dolio> And the new style just lets everything be installed and narrows things down as needed.
21:31:00 <dolio> But like I said, I don't know how Agda interacts with all that.
21:31:02 <cheater> unsolved-problem: because of what dolio said, if you have an old .ghc, it's worth just deleting it all and rebuilding all your projects with v2-build
22:03:20 * hackage dhall-lsp-server 1.0.10 - Language Server Protocol (LSP) server for Dhall  https://hackage.haskell.org/package/dhall-lsp-server-1.0.10 (GabrielGonzalez)
22:04:20 * hackage dhall-json 1.7.2 - Convert between Dhall and JSON or YAML  https://hackage.haskell.org/package/dhall-json-1.7.2 (GabrielGonzalez)
22:05:21 * hackage dhall-bash 1.0.33, dhall-yaml 1.2.2 (GabrielGonzalez): https://qbin.io/amino-reply-3t9a
22:06:20 * hackage dhall-nixpkgs 1.0.1, dhall-nix 1.1.17 (GabrielGonzalez): https://qbin.io/poor-winter-bn6e
22:07:19 * hackage dhall 1.35.0 - A configuration language guaranteed to terminate  https://hackage.haskell.org/package/dhall-1.35.0 (GabrielGonzalez)
22:08:19 * hackage dhall-docs 1.0.1 - Generate HTML docs from a dhall package  https://hackage.haskell.org/package/dhall-docs-1.0.1 (GabrielGonzalez)
22:56:34 <exodrifter> Is this the right place to ask for help related to building/running Win32 DLLs, or is that more of a #haskell-beginners thing
22:56:47 <dminuoso> exodrifter: This place is fine as well, but dont get your hopes up.
22:56:52 <dminuoso> There's very few Windows users.
22:57:12 <dminuoso> Intuitively, I'd go straight to the mailing lists.
22:57:31 <exodrifter> I'm not terribly familiar with mailing lists... more familiar with IRC.
22:57:58 <dminuoso> You just sign up on our webpage, then you send a regular mail to a special address that broadcasts the mail to all subscribed.
22:58:09 <dminuoso> So it's just email
22:58:11 <lemmih> Don't even need to sign up, I think.
22:58:27 <int-e> Axman6: it wasn't me. But I can imagine doing things like  scanl (+) 1 $ cycle [6,4,2,4,2,4,6,2]  to enumerate numbers that are coprime to 30.
22:59:59 <dminuoso> exodrifter: But anyhow, feel free to ask here anyway and perhaps try the mailing list if you don't have any luck here. :)
23:00:19 <exodrifter> That sounds like a good plan. Is this the right place for the mailing list? https://mail.haskell.org/mailman/listinfo/haskell-cafe
23:01:17 <dminuoso> haskell-cafe is a good starter indeed.
23:02:57 <dminuoso> exodrifter: And as lemmih pointed out, you might try sending a mail directly. That way you won't opt into the noise of getting all unrelated traffic. :)
23:03:14 <dminuoso> Without registering that is. I wouldn't know whether it worked without it, since Im signed up anyhow.
23:03:30 <exodrifter> hmm okay. Thanks
23:04:01 <lemmih> exodrifter: Why do you want to build Win32 DLLs? Definitely doesn't sound like a beginner issue.
23:04:23 <lemmih> Or maybe being a beginner on Windows is more extreme than I imagined.
23:04:45 <exodrifter> well, the IRC page suggested that #haskell might not be a place for questions, but it did say that for the beginners chat
23:05:48 <exodrifter> My motivation is to write a compiler for a narrative scripting language I've made for video games, and I want to use it to replace the compiler I currently have written in C# for the game engine Unity3D.
23:06:00 <exodrifter> Anyway, I've somehow managed to build a native DLL with stack and I'm trying to call it from C#. The only call I make from C# is to `hs_init`, but that causes my program to crash with the message "newBoundTask: RTS is not initialized; call hs_init() first" which is very spooky.
23:07:05 <exodrifter> I don't really know what "newBoundTask" means and I was hoping someone could explain that to me, because i couldn't really find anything on what that meant on the search engine
23:07:58 <dminuoso> exodrifter: GHC has the notion of what's called a "bound thread". A "bound thread" is an execution environment, in which subsequent calls into FFI are guaranteed to come from the same native OS thread.
23:07:58 <lemmih> And if you don't call 'hs_init', you do not get that error message?
23:08:32 <exodrifter> Yes, if I don't call `hs_init`, then there's no error message. Which is what I would expect, since i'm not calling any haskell functions at that point.
23:08:41 <dminuoso> And judging from a quick skim of the RTS code, it seems newBoundTask is the entry point for creating a "task" (the GHC rts abstraction over a thread) for such a bound thread.
23:08:49 <noctux> exodrifter: do you pass argv to hs_init?
23:09:07 <dminuoso> exodrifter: So that's just a function from deep inside the GHC RTS.
23:09:32 <noctux> exodrifter: and is there anything to enable RTS there, if you've built the dll with RTS as optional?
23:10:19 <exodrifter> I see. Thanks dminuoso. @noctux: I do not, I pass I pass IntPtr.Zero for both argc and argv. I don't know what you mean by "building the DLL with RTS as optional"; is the RTS not usually included when you build using stack?
23:10:45 <noctux> https://downloads.haskell.org/~ghc/8.4.2/docs/html/users_guide/ffi-chap.html#using-your-own-main has some mentions on RTS-options
23:10:52 <exodrifter> IntPtr.Zero is... well, C# docs say it isn't a null pointer but it's a pointer with a value of zero so i don't know how that's different.
23:11:57 <noctux> well, the rts actually should be there, I was more thinking about rtsopts. But those should probably be unnecessary...
23:13:14 <exodrifter> My first impression was that IntPtr.zero might not be the right value to pass for those arguments, but this StackOverflow answer disagrees with that. https://stackoverflow.com/a/16618038
23:13:38 <noctux> exodrifter: before using C#->Hs, maybe try C->hs initially, to test whether your dll is broken, or C# does weird things? 
23:13:45 <exodrifter> and my second though was that I might be aliasing the wrong function to hs_init in my build somehow, but I'm not sure how to confirm the right function is in my DLL or not
23:14:02 <exodrifter> That's a good idea. I should probably learn how to build C code
23:26:10 <exodrifter> noctux: alright, done. Yeah, it uh... does the same thing, it throws the "newBoundTask: RTS is not initialised; call hs_init() first" error when I call hs_init
23:27:55 <exodrifter> Oh... it works if I don't pass zero for the pointers. Interesting.
23:30:35 <noctux> Well, either now use a debugger on both variants and look where they diverge
23:31:04 <noctux> or maybe pass an empty argv as opposed to a NULL
23:32:09 <exodrifter> Yeah. It works if the pointers are not null, so argc=0 and argv=[] is fine, but argc=null and argv=null doesn't.
23:42:38 <exodrifter> Well, now I get a SIGSEGV so, you know, that's progress! \o/
23:43:39 <exodrifter> Not really sure why it tries accessing address 0xffffffff but it's late as heck and i need to sleep.
23:43:53 <exodrifter> thanks so much for the help noctux!
23:45:50 <noctux> no problem, your welcome :)
23:46:02 <noctux> *you're
23:55:51 <kuribas> are monad transformers the most confusing thing for beginners?
23:57:22 <Axman6> no
23:59:37 <MarcelineVQ> I think filterM was my toughest beginner task
23:59:57 <kuribas> :t filterM
23:59:59 <lambdabot> Applicative m => (a -> m Bool) -> [a] -> m [a]
