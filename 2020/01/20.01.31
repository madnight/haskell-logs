00:05:48 <CoffeeCoder[m]> I'm trying to decide on a small little project to write to learn Haskell. I've written three little console games before.
00:07:16 <[exa]> CoffeeCoder[m]: console as 'in terminal' or 'for PS4' ?
00:08:01 <CoffeeCoder[m]> terminal.
00:08:16 <CoffeeCoder[m]> really really basic ones. number guessing, blackjack, and a fallout hacking type game
00:08:23 <CoffeeCoder[m]> i'm thinking of doing sokoban next
00:10:36 <[exa]> oh nice. If you don't insist on terminal I suggest having a look on Gloss which is a great library for learning with games
00:11:42 <[exa]> CoffeeCoder[m]: see here https://hackage.haskell.org/package/gloss-1.13.1.1/docs/Graphics-Gloss.html#v:play -- you put together a few functions for manipulating the world state, one that converts it into a displayable structure, and the library makes it move
00:12:15 <CoffeeCoder[m]> thanks friend
00:12:50 <thongpv87> Can I ask novice question on the channel?
00:12:58 <[exa]> thongpv87: yes
00:13:49 <thongpv87> I'm trying to learn haskell myself
00:13:53 <[exa]> CoffeeCoder[m]: anyway Gloss is great because it doesn't put much stress on the learning curve (which is otherwise pretty steep)
00:14:14 <thongpv87> What is different between a->b->c and a->(b->c)
00:14:14 <CoffeeCoder[m]> awesome
00:14:30 <CoffeeCoder[m]> looking at this http://andrew.gibiansky.com/blog/haskell/haskell-gloss/
00:14:35 <[exa]> thongpv87: none, it's just the default way to put the parentheses around
00:14:59 <[exa]> thongpv87: a->b->c is a type of a function that takes 'a', returns a function that can take 'b', which in turn returns 'c'
00:15:30 <[exa]> thongpv87: the other case would be (a->b)->c, which is different (takes a whole function as a single parameter, and produes 'c')
00:16:29 <thongpv87> Thank you :) 
00:26:24 <[exa]> thongpv87: it's a bit counter-intuitive because the actual application order gets parenthesized exactly in the other way, if you apply `f a b` it's in fact `(f a) b`. But I guess it can be understood intuitively by just going over the actual types once
00:44:42 <thongpv87> Thank exa.
00:46:24 * hackage clang-pure 0.2.0.6 - Pure C++ code analysis with libclang  https://hackage.haskell.org/package/clang-pure-0.2.0.6 (PatrickChilton)
01:31:26 <merijn> cocreature: I see you have a multi-component branch for ghcide, should I test that or is it nowhere near ready?
01:32:33 <cocreature> merijn: not ready
01:35:22 <dminuoso> I want to construct and work with undirected cyclic graphs. Are there any canonical libraries to look at beyond containers?
01:36:05 <merijn> dminuoso: vector :p
01:36:22 <merijn> dminuoso: Do you need to modify the graph's structure?
01:36:40 <dminuoso> merijn: No. Just the initial construction and then I need to analyze it
01:37:17 <merijn> dminuoso: Honestly, I'd skip all the fancy functional shit and use vector to construct a CSR representation
01:38:12 <Taneb> dminuoso: if you want an untraditional way to do it, maybe algebraic-graphs?
01:42:27 <merijn> cocreature: I was trying my project again, since someone commented on the TH/bytecode error ticket to ask if it was still an issue. And now that I dropped a bunch of local dependencies it seems to do a bit better, but ghcide is still getting very confused by missing libc symbols for some reason...
01:43:47 <MarcelineVQ> merijn: probably a silly question but you're not missing any modules in other-modules or anything yeah? that can cause missing symbols, though probably not for libc
01:44:20 <merijn> MarcelineVQ: That's not relevant, because ghcide doesn't use other-modules
01:44:31 <merijn> At least not with a direct cradle, afaik
01:44:44 <merijn> MarcelineVQ: And the code has been fine for years with cabal
01:47:46 <MarcelineVQ> and you're not missing any? :>
01:48:37 <merijn> I'm not, because then cabal would fail to build too
01:50:32 <MarcelineVQ> I wouldn't trust that position 100% but this probably isn't the cause anyway
01:54:39 <merijn> MarcelineVQ: The issue here is "debugging/testing whether ghcide's bytecode linker/TH support works" not "my configuration"
01:54:55 <thongpv87> What's meaning of this notation: [[·]] :: Map k v → (k → Maybe v)
01:55:23 <merijn> thongpv87: That's not legal haskell, so who knows?
01:56:01 <thongpv87> Sorry, I didn't mention the context. I'm reading this paper: http://conal.net/papers/type-class-morphisms/type-class-morphisms-long.pdf
01:56:28 <thongpv87> It's on page 2
01:58:59 <MarcelineVQ> it's a mixfix notation, in   [[·]] :: Map k v → (k → Maybe v)     [[·]]  is the name of a function of  Map k v → (k → Maybe v)   ·  (the dot) is to signify where the argument to [[·]] goes
02:00:03 <lembot> hi all
02:00:16 <lembot> is there a ghc specific channel?
02:00:31 <boxscape> hm, the line [[lookup m k]] seems odd, considering the first paramdter of [[.]] is of type Map k v but lookup m k doesn't seem like it would have that type
02:00:55 <merijn> cocreature: ok, so it looks like I have both a static and dynamic persistent-sqlite in my store, the static one is indeed missing stat64, but the dynamic library seems to have it
02:00:56 <boxscape> lembot do you have questions about using it or developing ghc itself?
02:01:47 <lembot> developing, i'm working with core and have some questions
02:02:09 <boxscape> lembot #ghc exists and is active
02:02:13 <cocreature> merijn: leave that info on the ticket, it’s definitely going to get lost here :)
02:02:23 <lembot> boxscape: thx
02:02:25 <merijn> cocreature: oh! I have a suspicion why it might fail
02:02:55 <merijn> Maybe this is all a red herring!
02:05:52 <thongpv87> @MarcelineVQ How do you read  [[·]] :: Map k v → (k → Maybe v) in English.
02:05:52 <lambdabot> Unknown command, try @list
02:08:23 <merijn> ugh..
02:08:32 <merijn> Why can't github show me issues is subscribed too...
02:08:43 <merijn> I know there was a relevant issue that had activity, but now I can't find it
02:09:49 <boxscape> merijn this seems like it should help? https://github.com/notifications/subscriptions
02:10:28 <merijn> boxscape: I still need a method of filtering that :p
02:10:39 <boxscape> hm, makes sense
02:12:27 <MarcelineVQ> I'm not sure exactly, I guess by itself that could be read as: the meaning of [[·]]  is a mapping from Map k v to (k -> Maybe v)
02:13:18 <MarcelineVQ> this is why  [[lookup m k]] = [[m]] k  is valid there, in this paper not in haskell: the meaning of lookup m k is the meaning of m applied to k
02:15:37 <thongpv87> I read it as the meaning of (data type) Map k v is function k->Maybe v :-D
02:16:05 <merijn> cocreature: I put the details here: https://github.com/digital-asset/ghcide/issues/256#issuecomment-580672579 I'm open to suggestions of what to look into...
02:16:52 <boxscape> thongpv87 presumably that's what's expressed by the line [[Map k v]] = k -> Maybe v
02:17:36 <MarcelineVQ> yes and [[.]] is giving meaning to the interface we use to work with Map k v, since it's an abstract type and that's the only way we have to work with an abstract type
02:18:03 <merijn> cocreature: I tried explicitly adding "-lc" to the cradle to see if explicitly linking libc would work, but that seems to do nothing
02:19:30 <merijn> I suspect it goes wrong because GHC just uses the system linker and this appears to (try) to use the bytecode linker
02:19:54 * hackage ghc-tcplugins-extra 0.4 - Utilities for writing GHC type-checker plugins  https://hackage.haskell.org/package/ghc-tcplugins-extra-0.4 (ChristiaanBaaij)
02:32:13 <AWizzArd> I can have DuplicateRecordFields. But can I also have duplicate constructors?   data ClientError = TokenError | ...      and   data UserError = UserAlreadyExists | TokenError | ...
02:35:47 <merijn> AWizzArd: In the same module?
02:36:33 <merijn> AWizzArd: The day that proposal ever gets implemented is the day I give up on Haskell
02:37:18 <merijn> cocreature: Can I somehow make ghcide spew out the actual linker/whatever flags it uses? Or is this more of a hie-bios thing?
02:37:33 <merijn> pwd
02:42:54 * hackage log4hs 0.8.0.0 - A python logging style log library  https://hackage.haskell.org/package/log4hs-0.8.0.0 (gqk007)
02:51:47 <AWizzArd> merijn: hr hr hr
03:05:06 <dminuoso> Taneb: algebraic-graphs is really interesting, even though the API seems rather complex.
03:06:17 <dminuoso> Complex in the sense of having really loads of tools. After doing some digging, I think edwards graphs library fits my use case better. The visitor style graph searches fits my usecase beswt.
03:19:01 <cocreature> merijn: there is nothing built in but if you add a print statement somewhere here https://github.com/digital-asset/ghcide/blob/master/exe/Main.hs#L180 it should do the trick
03:24:54 * hackage githud 3.2.0 - Heads up, and you see your GIT context  https://hackage.haskell.org/package/githud-3.2.0 (gbataille)
03:31:37 <rsoeldner> cocreature, following up on the `NIX_GHC_LIBDIR` path. Looks like my cabal packages are located under `~/.cabal/store/ghc-8.6.5/` and they are not listed by `ghc-pkg list`. Could it be possible that `ghcide` is confused by NixOS and providing just cabal-install and the ghc version and let cabal manage all deps ?
03:33:26 <cocreature> rsoeldner: the package environment file should point to the correct package db
03:38:21 <rsoeldner> cocreature, thanks, the .ghc.environment file looks good to me, is there a way to validate it manually ?
04:49:41 <gauga> hey haskell experts!
04:50:11 <__monty__> You must be talking to me.
04:50:52 <gauga> first-year comp. science student here and I have a question that I haven't been able to solve. How do you build a Huffman tree from a Table Char Int where Table is defined as Table k v = T [(k, v)] ? 
04:51:20 <gauga> hi monty :)  
04:52:54 <__monty__> gauga: Do you have a guess for the type of the tree?
04:54:34 <gauga> what do you mean monty? 
04:55:41 <__monty__> gauga: You want to write a function `toHuffman :: Table Char Int -> Tree` right? So start by defining the Tree type.
04:55:46 <gauga> I have a table of Char and Int that I produce when reading the number of occurences of each character in a string. I then need to write a function that makes a Huffman tree out of that table huffmanTree :: Table Char Int -> HuffmanTree
04:56:15 <gauga> it is a Huffman tree which I have defined like this: data HuffmanTree = Void | Leaf (Char, Int) | Fork HuffmanTree Int HuffmanTree deriving (Show) 
04:58:30 <__monty__> gauga: Ok, now start by case analysis. What does your function return if you pass it `[]`?
05:00:21 <gauga> it should return an empty Huffman tree?
05:11:21 <__monty__> Hmm, the next bit's going to be a lot easier if you sort the table in ascending order of frequency.
05:11:42 <sm[m]> g'day all. I'm rewriting a pipeline of function calls into call order, replacing $ with &. I need to conditionally apply some of them as a parenthesised group, and I'm not sure how to do that with &. Eg, how to re-order: 1 & (negate . succ) so that it's: 1 & (succ ...something... negate) ?
05:12:26 <__monty__> :t flip (.)
05:12:28 <lambdabot> (a -> b) -> (b -> c) -> a -> c
05:12:43 <__monty__> @hoogle (a -> b) -> (b -> c) -> a -> c
05:12:44 <lambdabot> Flow (.>) :: (a -> b) -> (b -> c) -> a -> c
05:12:44 <lambdabot> Flow compose :: (a -> b) -> (b -> c) -> a -> c
05:12:44 <lambdabot> Data.Function.Contravariant.Syntax (-.) :: (a -> b) -> (b -> c) -> a -> c
05:13:08 <maerwald> is there a fuzzy time parser somewhere? The ones from 'time' require me to provide a format
05:13:12 <__monty__> Couple options, or you might want to just define your own.
05:14:11 <sm[m]> __monty__: nice, thank you
05:16:53 <sm[m]> maerwald: I feel there is, but I'm not finding it. There was a fancy one from Facebook at least
05:19:23 <sm[m]> @hoogle (>>>)
05:19:23 <lambdabot> Control.Arrow (>>>) :: Category cat => cat a b -> cat b c -> cat a c
05:19:24 <lambdabot> Control.Category (>>>) :: Category cat => cat a b -> cat b c -> cat a c
05:19:24 <lambdabot> RIO.Prelude (>>>) :: Category cat => cat a b -> cat b c -> cat a c
05:20:01 <sm[m]> __monty__: >>> seems to typecheck, but scares me a little
05:20:12 <__monty__> Figures there's an arrow, my hoogle-fu isn't strong enough to get these results : )
05:20:33 <__monty__> `cat` is just a variable and matches prefix `(->)` so it's fine.
05:21:54 <sm[m]> alrighty! It has the advantage of being in base
05:23:04 <__monty__> Psst, sm[m], some of the arrow combinators are great when working with tuples for example, don't tell anyone I said so though. Most don't like the obscurity tradeoff : )
05:23:34 <sm[m]> oh yeah ? got an example ?
05:24:13 <berndl> But it's only obscure because it is unfamiliar.
05:24:39 <__monty__> sm[m]: Just `***` and `&&&`.
05:24:44 <berndl> Haskell programmers have been spoiled by do notation.
05:25:59 <__monty__> berndl: Sure, but why use obscure operators when a pattern match will probably work just as well and be clear to everyone.
05:27:19 <berndl> Pattern matching is also obscure if you're coming from a C-like language.
05:27:40 <MarcelineVQ> just &&& really
05:27:43 <__monty__> Less avoidable though.
05:28:00 <MarcelineVQ> bifunctor has a direct analogue for the other cases iirc
05:28:30 <MarcelineVQ> Where other cases means common uses, e.g. first, second, bimap
05:28:51 <sm[m]> __monty__: I meant an *example* :)
05:29:45 <__monty__> > let f = (+ 1); g 
05:29:48 <merijn> __monty__: You can just use Bifunctor now, since it's in base
05:29:48 <lambdabot>  <hint>:1:18: error:
05:29:48 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
05:29:57 <maerwald> is filter faster on lists or vectors?
05:30:08 <merijn> maerwald: "It Depends"
05:30:23 <__monty__> > let f = (+ 1); g = (* 2) in (f &&& g) (2, 3)
05:30:26 <lambdabot>  error:
05:30:26 <lambdabot>      • No instance for (Num (Integer, Integer))
05:30:26 <lambdabot>          arising from a use of ‘e_11223’
05:30:33 <merijn> maerwald: vector fusion will probably get rid of it
05:30:43 <merijn> __monty__: That's just a complicated way of writing "bimap f g"
05:31:23 <__monty__> merijn: No it's not, apparently. But yes, that's what I was going for : )
05:34:03 <maerwald> sm[m]: https://hackage.haskell.org/package/fuzzy-dates
05:34:04 <maerwald> :)
05:35:07 <MarcelineVQ> shapr: <maerwald> sm[m]: https://hackage.haskell.org/package/fuzzy-dates
05:35:38 <maerwald> echo
05:36:46 <maerwald> seems to use hourglass instead of time package though
05:54:53 <sm[m]> nice
06:04:44 <boxscape> is there a way to use makeLenses in ghci?
06:06:17 <Solonarv> you might need a dummy data declaration
06:06:30 <Solonarv> data Dummy; $(makeLenses ''MyType)
06:07:28 <boxscape> ah, yes, that works, thanks
06:09:02 <boxscape> in fact you don't need the $()
06:10:24 <absence> if "type X a b = F Int (F a b)" was at the value level, I could have written "type X a = F Int . F a". is it possible to do this for types?
06:10:56 <Solonarv> not currently, no
06:11:44 <boxscape> I think there was some proposal to make (.) syntax available at the type level
06:11:59 <boxscape> to really make it fully functional you need Unsaturated type families on top of that
06:12:31 <absence> ;_;
06:12:33 <absence> ok thanks
06:14:33 <boxscape> https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0173-dot-type-operator.rst
06:14:48 <boxscape> absence apparently dot as a type operator is available in 8.8
06:15:25 <boxscape> absence if you only need it for type constructors and not type synonyms or families you could probably define composition yourself pretty easily and use it, otherwise it's not so straightforward
06:16:08 <absence> boxscape: i'm not on 8.8 yet, but i'll keep it in mind and look into it down the line :) thanks
06:16:41 <merijn> absence: Type level compose is equivalent to type level lambda's, which is sufficient to make the type system Turing complete and means type checking is no longer strongly terminating
06:19:02 <maerwald> sm[m]: but it doesn't work very well, it can't even understand "2 weeks ago"
06:23:43 <boxscape> merijn true in general, but you can do things like "type (f . g) x = f (g x)" and then "Just [1..5] :: (Maybe . []) Int" in 8.8
06:24:12 <tdammers> what about type-level ($)?
06:24:27 <boxscape> though admittedly that still doesn't allow eta reduction like in absence's `type X a = F Int . F a` example
06:24:30 <merijn> boxscape: Does (.) allow partial application?
06:24:38 <Solonarv> not currently
06:24:49 <merijn> Right, so it's just Compose, which is fine
06:24:59 <merijn> It's partially applied types that break things
06:25:01 <Solonarv> also, IIUC the change is simply to syntactically allow . as a type operator
06:25:12 <Solonarv> it doesn't actually add any new symbols exported from anywhere
06:25:16 <boxscape> yeah it's admittedly not nearly as useful without PA
06:27:07 <boxscape> Solonarv that makes sense, considering there's different implementations one might want, one for type constructors and one for defunctionalized type fams
06:28:00 <boxscape> (...and I suppose that would have been a core libraries change rather than a proposal change)
06:30:47 <lortabac> boxscape: IIRC if the matchability polymorphism proposal is implemented, there will be no difference between the two
06:31:14 <lortabac> I might be wrong though
06:31:28 <Solonarv> you are, there will still be a difference
06:31:39 <boxscape> lortabac well, I suppose there's three possible versions, matchable, unmatchable, and matchability polymorphic?
06:31:39 <Solonarv> because 'Compose f g a' is apart from 'f (g a)'
06:32:30 <Solonarv> but '(f . g) a' is the same as 'f (g a)' if we use the "function composition" definition for .
06:32:30 <lortabac> ok
06:32:31 <maerwald> sm[m]: https://hackage.haskell.org/package/dates this one seems to work and maintained
06:33:00 <boxscape> Solonarv is Compose a newtype in that or a type synonym?
06:33:22 <Solonarv> it is the newtype exported from Data.Functor.Compose
06:33:25 <boxscape> ah, ok
06:33:54 <boxscape> I didn't even consider having a version with newtype
06:34:23 <lortabac> is the Compose newtype still needed once the proposal is implemented?
06:34:29 <Solonarv> yes
06:35:04 <Solonarv> Compose f g a being apart from f (g a) is still important and isn't going away anytime soon
06:35:35 <Solonarv> consider 'fmap k x', now if x :: Compose f g a this is 'fmap @(Compose f g) @a'
06:35:57 <Solonarv> but if 'x :: f (g a)', then it's 'fmap @f @(g a)'
06:36:06 <Solonarv> so it uses a different Functor instance
06:37:38 <boxscape> fmap @(Compose f g) @a is similar to (fmap . fmap) then?
06:38:49 <sm[m]> maerwald good to know, thanks
06:38:59 <maerwald> but it has its own date types... -.-
06:39:10 <maerwald> why do haskell libs always be incompatible
06:41:27 <berndl> boxscape: yep
06:41:32 <boxscape> okay
06:51:44 <__monty__> maerwald: Weirder still because it depends on time.
06:52:13 <maerwald> yes, I had to convert its data type to a string and use parseTimeM from date-time to turn it back to UTCTime
06:52:14 <maerwald> seriously...
06:54:46 <MarcelineVQ> :(
06:55:51 <phillscott> my prof emailed me "there are gentle introductions to category theory:  e.g. by B. Pierce at U.Penn CS Department."
06:56:07 <phillscott> does anyone have a link? all I can find is a course webapge for haskell in upenn
06:57:37 <shapr> phillscott: I've heard good things about Emily Riehl's book
06:57:53 <shapr> I've tried Schanuel et al, it wasn't bad
06:58:18 <phillscott> emily riehl...why does that name sound familiar
06:59:16 <berndl> I've read both books. The one by Pierce is much easier if you don't have a math background.
06:59:27 <shapr> berndl: which book is that?
06:59:29 <phillscott> oh because of this https://twitter.com/aliceryhl?lang=en
06:59:34 <phillscott> rhyl ~= riehl
06:59:58 <phillscott> what kind of math background is required?
07:00:05 <berndl> shapr: Basic Category Theory for Computer Scientists
07:00:10 <phillscott> i took discrete, real analysis couple of years ago
07:00:17 <shapr> phillscott: this is https://twitter.com/emilyriehl
07:00:28 <Putonlalla> There's also Conceptual Mathematics by Lawvere and Schanuel, which is very gentle.
07:00:48 <berndl> phillscott: well, you pretty much need to have a math undergrad degree to make sense of the examples in her book.
07:00:56 <shapr> phillscott: if you want motivational examples, I like conal's work on compiling to categories, and there's the famous UMAP that beat out t-SNE
07:03:17 <shapr> phillscott: what interesting things are you doing with category theory?
07:05:02 <phillscott> curiosity, mostly, but also programming
07:05:02 <lyxia> phillscott: https://www.amazon.com/exec/obidos/ASIN/0262660717/benjamcpierce
07:05:10 <MarcelineVQ> phillscott: imma just leave this here https://arxiv.org/pdf/1912.10642.pdf 
07:05:34 <phillscott> i have this feeling that imperative programming is bad for programming in general, because its a bad abstraction for it
07:05:46 <phillscott> but i dont have any other ideas to ponder about
07:08:19 <MarcelineVQ> https://arxiv.org/abs/1803.05316 is often reccomended/cited
07:12:05 <berndl> phillscott: I don't think "imperative programming" is an abstraction, let alone a bad one.
07:13:35 <sshine> I think anything our mind produces is an abstraction, but I don't think "imperative programming" is a very strong abstraction on top of the machinery.
07:14:06 <phillscott> i consider for-loop a bad construct for programming in general
07:14:31 <hyperisco> Structured programming was a big deal. Don't be too quick to poo-poo it.
07:14:32 <phillscott> in my experience, bugs in c/c++ are just dumb bugs
07:14:45 <__monty__> I've seen Algebra Chapter 0 recommended as a book for category theory without much previous math background.
07:16:13 <dminuoso> Conceptual Mathematics is also a very smooth rudimentary introduction into the basics.
07:16:30 <dminuoso> It has a very low math dependency footprint as well.
07:19:54 * hackage json-feed 1.0.8 - JSON Feed  https://hackage.haskell.org/package/json-feed-1.0.8 (fozworth)
07:20:13 <hexagoxel> is there a way to turn off an extension for a single module?
07:20:36 <lyxia> {-# LANGUAGE NoGADTs #-}  -- maybe?
07:21:10 <nshepperd> is there a ghc flag that'll make it dump its arch-os-version number, eg. x86_64-linux-8.6.5
07:21:21 <MarcelineVQ> ye, adding no/no- works for most* ghc flags
07:22:09 <dminuoso> hexagoxel: You can negate most with No
07:22:09 <dminuoso> {-# LANGUAGE NoGADTs #-}
07:23:03 <hexagoxel> thanks
07:23:33 <MarcelineVQ> nshepperd: +RTS --info  if nothing else is easy
07:23:56 <geekosaur> ghc --info | grep platform
07:24:19 <geekosaur> minus the version, I guess
07:24:22 <MarcelineVQ> that won't include ghc ver but it's all there if a person is okay with parsing
07:24:24 <MarcelineVQ> :>
07:25:18 <MarcelineVQ> wonder if there's an ENV set at any point with that info
07:26:09 <dminuoso> merijn: So priceless https://hackage.haskell.org/package/numeric-prelude-0.4.3.1/docs/Algebra-Absolute.html#t:C
07:26:17 <dminuoso>  (C a, C a, C a) => C (T a)
07:27:21 <geekosaur> gee, I wonder whose code that is…
07:29:07 <boxscape> oh at least you can discover what each C means via the tooltip
07:30:03 <dminuoso> hmatrix kind of reminded by me it, but hmatrix is more a case of total lack of documentation.
07:46:54 * hackage lz4-bytes 0.1.0.0 - Bindings to LZ4  https://hackage.haskell.org/package/lz4-bytes-0.1.0.0 (andrewthad)
07:58:22 <maerwald> brittany doesn't support type equality constraints?
08:03:48 <maerwald> seems it's a bug
08:04:21 <c_wraith> yeah, that'd be a pretty surprising lack.  they're not some obscure feature.
08:04:48 <maerwald> ro ~ 'RO -- if that is on a new line, that it doesn't parse it
08:05:11 <maerwald> but parses (foo , ro ~ 'RO) ...
08:10:24 * hackage tasty-quickcheck 0.10.1.1 - QuickCheck support for the Tasty test framework.  https://hackage.haskell.org/package/tasty-quickcheck-0.10.1.1 (RomanCheplyaka)
08:10:31 <hexagoxel> maerwald: how to reproduce?
08:10:42 <maerwald> https://github.com/lspitzner/brittany/issues/277
08:17:19 <ezzieyguywuf> 😍😍😍loving the workflow with ghcid and hspec.
08:17:32 <ExplodingPixel> Hey, is it okay to ask a sort of n00bish question about how to do something in haskell here?
08:18:41 <devalot> ExplodingPixel: Those are the best kinds of questions.  Please ask.
08:21:10 <merijn> devalot: pfft, that's clearly not the best kind of question. The best kind of question is, like, "who wants free beer?" and "who wants a $100?" ;)
08:21:30 <devalot> merijn: I stand corrected ;)
08:21:49 <ExplodingPixel> Thank you devalot. Okay, so basically, I'm trying to figure out how to to get an input from the user, in the form of a Y/N prompt, and if yes, recursively run the function again. I've tried "if getChar == 'Y'" and other thinks like using IORef, but I can't seem to get the types to match. Am I just on the wrong path?
08:22:16 <merijn> Note that getChar is 'IO Char', *not* Char
08:22:29 <merijn> @quote shachaf /bin/ls
08:22:30 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
08:23:16 <ExplodingPixel> That's what I'm running into. So should I compare the getchar to an IOChar, and if so how would I do that?
08:23:41 <devalot> ExplodingPixel: So you are trying to compare IO Char to Char, and that doesn't work.
08:23:53 <merijn> ExplodingPixel: You probably want to use do notation like this: "myAction = do { doStuff; c <- getChar; when (c == 'Y') myAction }"
08:24:19 <ExplodingPixel> Hang on, let me try this.
08:24:25 <merijn> "when b foo" is just "if b then foo else return ()"
08:24:29 <devalot> ExplodingPixel: You can thing of `c <- getChar' and extracting the Char from the IO Char.
08:24:45 <devalot> s/thing/think/
08:24:54 <ExplodingPixel> right right
08:25:47 <geekosaur> as long as it goes back into IO in the end, so you can only do this in a function whose result type is IO <something>
08:28:17 <inkbottle> What does that mean that "*** is not in general a functor"? What would that mean it being a functor in the first place? (https://www.researchgate.net/publication/277298859_Arrows_and_computation)
08:28:49 <inkbottle> A functor should take an arrow to an arrow, right?
08:29:36 <inkbottle> like "fmap"
08:30:40 <MarcelineVQ> You should provie the whole setence :>
08:30:44 <MarcelineVQ> provide
08:31:17 <MarcelineVQ> or rather the one that comes just before that: For many arrows (e.g. state transformers), the other order has a different meaning. As a consequence, ∗∗∗ is not in general a functor.
08:31:18 <ExplodingPixel> okay, so I followed merijn's suggestion, and I'm getting a syntax error and
08:31:37 <ExplodingPixel> I think it's due to the recursive function taking a parameter
08:32:07 <geekosaur> ExplodingPixel, you should show your code and error in a paste site
08:32:13 <ExplodingPixel> grand, will do
08:32:43 <MarcelineVQ> I'm not sure how accurate that is though, because the Applicative for State is valid regardless of which effect you do first afaik, it's still a functor, it just behaves another way
08:33:00 <inkbottle> MarcelineVQ: that's the sentence ;), What I don't understand is what would be a functor in that context
08:33:26 <inkbottle> What would be the signature of a functor?
08:34:02 <inkbottle> like fmap :: (a -> b) -> m a -> m b
08:34:27 <inkbottle> but *** doesn't at all look like this
08:35:35 <MarcelineVQ> it's somewhat similar, consider  (***) id
08:35:54 <inkbottle> okay
08:36:06 <ExplodingPixel> okay, here's the program and errors https://paste.rs/vTr
08:36:20 <MarcelineVQ> certainly not as general looking, to me
08:36:46 <ExplodingPixel> I'm basically rewriting this in haskell https://github.com/TheExplodingPixel/OneTrueEditor
08:37:24 <Putonlalla> It's precisely `fmap` over `(,) c`, inkbottle.
08:38:06 <inkbottle> MarcelineVQ: okay, I understand I must not take that line of the source too "strictly"
08:39:15 <inkbottle> Putonlalla: okay, got it. The 2 arrows in parallel...
08:49:32 <ski> MarcelineVQ : should get the same result, not depending on in which order you map the two "parts"
10:21:24 * hackage mmsyn4 0.1.6.0 - The "glue" between electronic tables and GraphViz  https://hackage.haskell.org/package/mmsyn4-0.1.6.0 (OleksandrZhabenko)
10:29:20 <maerwald> is there a library for formatting cli output (e.g. table-wise like ls)
10:29:59 <geekosaur> various prettyprinter libraries?
10:30:54 * hackage mmsyn6ukr 0.6.3.0 - A musical instrument synthesizer or a tool for Ukrainian language listening  https://hackage.haskell.org/package/mmsyn6ukr-0.6.3.0 (OleksandrZhabenko)
10:35:22 <maerwald> geekosaur: any specific?
10:35:35 <geekosaur> I was just looking at ansi-wl-pprint
10:35:58 <geekosaur> and noting how it could be used to do ls-like things with its combinators
10:36:21 <maerwald> I really just have two columns
10:36:24 <maerwald> not complicated
10:37:16 <maerwald> not hard to write inefficiently, but thought there is already something
10:41:24 * hackage mmsyn5 0.4.3.0 - Various additional operations on lists (some with intermediate Monads)  https://hackage.haskell.org/package/mmsyn5-0.4.3.0 (OleksandrZhabenko)
10:41:24 <geekosaur> .oO ( this is haskell, of course it's an overengineered monoid )
10:41:45 <MarcelineVQ> maerwald: https://hackage.haskell.org/package/table-layout
10:42:49 <koz_> It's all monoids, all the way down.
10:42:51 <maerwald> that looks interesting
10:43:10 <koz_> (monoids are like turtles)
10:43:27 <maerwald> slow?
10:43:39 <koz_> maerwald: Lawl.
10:43:46 <MarcelineVQ> arranged in stacks
10:44:08 <MarcelineVQ> bundles of turtles, presheeeeavesss of turtle
10:44:23 <koz_> MarcelineVQ: Wouldn't a heap be better? You can pile smaller turtles on bigger turtles then.
10:44:26 <koz_> More stable.
10:44:52 <MarcelineVQ> however you do it it's important to not lose track of stale turtles
10:45:08 <iptq> i prefer linked lists of turtles
10:45:10 <maerwald> yeah, it's sometimes hard to know whether it's still alive :>
10:45:41 <maerwald> true laziness... you don't know, unless you check!
10:46:24 <geekosaur> monoidal heisenturtles?
10:46:46 <koz_> maerwald: It's that hard shell.
10:47:05 <MarcelineVQ> It's always a hard shell when software dev is involved
10:47:16 <koz_> iptq: Like this? https://encrypted-tbn0.gstatic.com/images?q=tbn%3AANd9GcS4troASZ7V7F81W9jXscsawzS5FmeCECAj7aPO9YjVlsERMaGU
10:47:41 <koz_> MarcelineVQ: Every shell is hard in its own special way.
10:48:41 <MarcelineVQ> give dactyl
11:08:53 <tabaqui1> uh, how can I nicely desugar Arrow syntax? -ddump-ds generate a lot of lines for the simpliest ArrowLoop
11:09:20 <tabaqui1> or at least, where can I read how "rec" is desugarated inside of arrows?
11:12:51 <tabaqui1> and it seems to me, that this link contains an error: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#recursive-binding-groups
11:13:16 <tabaqui1> In the second example with (b, c) pair, do-context is written in wrong way
11:13:20 <tabaqui1> Am I right?
11:21:00 <tabaqui1> ah, okey, here are the clues https://www.haskell.org/arrows/sugar.html
11:21:36 <mniip> tabaqui1, wrong way how?
11:22:27 <tabaqui1> mniip: I expect to see different variables for the mfix argument body and returned values
11:22:45 <tabaqui1> like "mfix (\(b,c) -> do { smth; return (b', c') }"
11:23:13 <tabaqui1> I mean, it looks useless to replace recursive binding with recursive binding and mfix
11:24:11 <mniip> I see what you mean
11:24:17 <mniip> wondering if this has semantic changes
11:27:49 <ski> tabaqui1 : not replacing with recursive binding
11:28:50 <tabaqui1> ski: why not? do you mean, that the example contains name shadowing?
11:29:15 <tabaqui1> and it is "\(b, c) -> do { b1 <- f a c; c1 <- f b a; return (b1, c1)"?
11:29:45 <ski> yes
11:30:17 <pounce> Hi, I can't compile my program to a binary but it runs fine with runghc
11:30:18 <tabaqui1> hmm, it makes sense but not much obvious
11:30:29 <ski> and it should be `c1 <- f b1 a', then
11:30:38 <pounce> i'm linking to libz3 through the z3 package and the linker can't find some functions
11:30:53 <tabaqui1> ski: yeah, probably
11:31:22 <tabaqui1> pounce: are you using stack to call runghc and ghc?
11:31:26 <pounce> no
11:31:51 <tabaqui1> I guess, that ghc and runghc point on different environment
11:32:17 <MarcelineVQ> what is the errror
11:33:27 <pounce> MarcelineVQ: https://files.catbox.moe/c8hjje.png
11:36:34 <int-e> pounce: You'll need the z3 C libarary and accompanying header files. (E.g. under Debian that would be the libz3-dev distribution package.)
11:37:45 <pounce> int-e: i have it installed
11:37:49 <int-e> mmm
11:38:04 <pounce> i assume that's how it can run with runghc
11:40:40 <int-e> Oh, could it be a version problem?
11:42:25 <int-e> (It probably is, I'm running Debian unstable whjich comes with z3-4.8.3, but stable is on 4.4.1.)
11:43:10 <int-e> pounce: Can you try  cabal install z3-4.3.1  instead?
11:43:25 <pounce> ah, hm
11:43:59 <pounce> yeah my distro is way behind, im on 4.4.1 too
11:44:34 <pounce> it's still trying to link against z3 408.0... do i have to uninstall that one?
11:44:34 <int-e> (Huh, Debian unstable's z3 and libz3 are on different version. Fun.)
11:45:16 <int-e> pounce: hmm, maybe  ghc-pkg hide z3-408  is enough
11:46:21 <int-e> ('hide'/'expose' control default visibility of packages... which are relevant for runghc and ghci)
11:46:44 <pounce> ohno, it can't find Z3.monad now
11:49:07 <pounce> ghc-pkg says that it's there
11:49:16 <pounce> and i hink it says that 408.0 is hiddden?
11:49:30 <int-e> is z3-4.3.1 there and not hidden?
11:49:54 <int-e> Also it's Z3.Monad ... if that lowercase m wasn't a typo.
11:50:18 <pounce> yea
11:51:08 <pounce> int-e: https://files.catbox.moe/j063sx.png
11:51:42 <int-e> pounce: looks good to me
11:52:47 <int-e> And according to https://hackage.haskell.org/package/z3-4.3.1 that should have a Z3.Monad module ( ghc-pkg describe z3-4.3.1  is another way to find out -- look for  exposed-modules: )
11:58:58 <hyperisco> Tried to run stack install on a project that previously built fine. I've added no new dependencies… I just changed a line of code and ran stack install
11:59:05 <hyperisco> "There are files missing in the `exceptions-0.8.3' package,"
12:00:24 <hyperisco> ghc-pkg check  returns a long list of  Warning: dynamic-library-dirs: C:\Program Files\Haskell Platform\8.2.2\lib\extralibs\x86_64-windows-ghc-8.2.2 doesn't exist or isn't a directory
12:00:46 <hyperisco> And other stuff… like everything disappeared
12:01:41 <hyperisco> If everything was deleted, how can I reinstall it?
12:03:55 <geekosaur> reinstall the platform?
12:05:08 <hyperisco> They are all just warnings though, so I don't know if any of that is a problem
12:05:29 <maerwald> put sunglasses on, ignore warnings
12:05:37 <hyperisco> can I reinstall the exceptions package?
12:05:42 <geekosaur> make sure it's the same version (8.2.2); current for Windows would be 8.6.5
12:05:53 <geekosaur> "There are files missing…" isn't a warning
12:06:00 <hyperisco> that is from stack
12:06:04 <hyperisco> the warnings are from ghc-pkg
12:06:56 <hyperisco> stack is building with ghc 8.4.3
12:08:11 <geekosaur> so something's wrong with your stack setup. exceptions is a bootlib that should come with ghc, so you may need to get stack to reinstall its compiler
12:09:52 <hyperisco> okay so that is  stack setup --reinstall
12:10:04 <phadej> exceptions is not a boot lib
12:10:10 <phadej> until ghc-8.1.0
12:10:14 <phadej> 8.10
12:10:30 <hyperisco> well I am reinstall now so too late for that
12:10:32 <phadej> https://gitlab.haskell.org/ghc/ghc/wikis/commentary/libraries/version-history
12:10:44 <hyperisco> um, apparently it refuses to reinstall lol
12:10:49 <hyperisco> because it is already installed?
12:12:05 <hyperisco> how can I get exceptions to be rebuilt?
12:12:39 <hyperisco> I cannot ghc-pkg unregister it because it has dependants
12:13:12 <phadej> stack and haskell platform feels like something you shouldn't do
12:13:20 <phadej> shouldn't combine
12:13:25 <geekosaur> haskell platform has included stack for a while now
12:13:26 <phadej> (i'd honestly start over)
12:13:40 <phadej> I wouldn't use non-minimal installers of HP
12:14:54 <hyperisco> https://stackoverflow.com/questions/37236892/force-stack-to-rebuild-an-installed-package
12:15:00 <hyperisco> Apparently it is okay to unregister anyways
12:17:56 * solonarv wouldn't use installers of HP at all
12:17:57 <hyperisco> stack rebuilt the needed packages, and everything is working again
12:18:04 <solonarv> chocolatey FTW!
12:39:10 <Uniaika> good evening!
12:39:44 <solonarv> hello there!
12:44:57 * dmwit waves
12:45:40 <Uniaika> I seem to have weird expectations regarding state modifications in a monadic context
12:45:46 <Uniaika> see this Gist: https://gist.github.com/Kleidukos/2bae96470969d8bae466a728f2a72842
12:46:25 <Uniaika> but basically I thought that modifying the state of a MonadState in a sub-function would be reflected in the caller function (that also operates in said monad)
12:46:41 <Uniaika> should I manually return the new state and use it instead of calling `get`?
12:46:44 <Uniaika> 2/4
12:46:48 <Uniaika> (oops)
12:47:30 <monochrom> Use get.
12:49:16 <Uniaika> monochrom: but changes don't seem to propagate
12:50:50 <monochrom> You should be able to code up an independent simple example to prove that the problem is elsewhere.
12:51:08 <solonarv> actually I am very confused because the problem you are describing does not seem to occur.
12:51:41 <monochrom> foo = modify not;  bar = do {put True; foo; get}    the end result is False.
12:52:52 <Uniaika> I will try to simplify my code, maybe I'm on another level on confusion.
12:53:54 <solonarv> looking through your code, the following seems to happen:
12:55:05 <solonarv> triggerOutputBuffer is called { it prints the state, the fillOutputBuffer field is False. It flips that field to True. }. now the state is printed again, the fillOutputBuffer field is True.
12:56:17 <Uniaika> okay so yes indeed, I was blinded by tiredness.
12:58:24 * hackage network-uri 2.6.2.0 - URI manipulation  https://hackage.haskell.org/package/network-uri-2.6.2.0 (EzraCooper)
13:20:03 <Uniaika> alright, the lesson here was that you cannot reliably code when you're tired
13:25:35 <fragamus> hi I hate it when I have to use monad transformers
13:26:06 <fragamus> I need someone to set me straight on the ordering of state and list
13:27:03 <fragamus> I think I must use ListT here transforming State
13:27:49 <Uniaika> fragamus: tell us what you need to do in the first place :) 
13:28:05 <Uniaika> (not what you want to do in order to do it, but really the end goal)
13:28:18 <monochrom> StateT S [] A = S -> [(S, A)].  From this you can easily see whether you want it.
13:29:33 <amalloy> isn't ListT kinda like...a bad monad transformer?
13:29:59 <monochrom> No. Where did you heard that from?
13:30:12 <fragamus> I want a single state and I want to use nondeterminism in the calculation
13:30:38 <monochrom> S -> [(S, A)] looks like nondeterminism.
13:31:16 <monochrom> In fact the monadic parsing paper did it.
13:31:30 <fragamus> no I want to explore a combinatoric problem and maintain a state to tally results
13:31:53 <fragamus> I am into ListT here
13:32:42 <monochrom> Could you remind me the algebraic data type definition of ListT?
13:33:07 <koz_> Is there a better way of writing something like this (preferably without resorting to do-notation)? https://gist.github.com/kozross/d1f6638ebdfdccea693403bca5225dfb
13:33:42 <fragamus> is this the socratic method
13:33:46 <monochrom> (Because after looking at the definition you see absolutely no nondeterminism.)
13:34:06 <monochrom> halfly
13:34:32 <koz_> monochrom: So it's the 'socr' method? Or the 'atic' method?
13:34:40 <jle`> koz_: get-and-modify can be `get <* modify (+1)`, and that sounds useful enough on its own
13:34:43 <monochrom> heh
13:34:59 <jle`> koz_: it might be awkward to just tack on 'x' as an input/output of the function because it doesn't really offer any logic
13:35:05 <jle`> but x <$ (get <$ modify (+1))
13:35:13 <koz_> jle`: Woah, lol.
13:35:17 <jle`> er, (,x) <$> (get <* modify (+1))
13:35:27 <koz_> Maximum applicative.
13:35:33 <monochrom> Yeah I have always like a version of modify that tells you the old value.
13:35:35 <jle`> or getAndModify f = get <* modify f, foo x = (x,) <$> getAndModify (+1)
13:37:32 <koz_> Yeah, getAndModify definitely sounds useful on its own.
13:43:16 <fragamus> monochrom: so just to be clear, I want just one state, and I am going to traverse through some possibilites and modify that state as I go through those possibilities
13:44:09 <monochrom> Sounds like S -> (S, [A]).  You may have to define it yourself and how >>= works etc.
13:44:58 <solonarv> getAndModify = state . (id***)
13:45:17 <solonarv> or is it &&& ?
13:45:19 <solonarv> :t (***)
13:45:20 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
13:45:28 <solonarv> ah
13:45:34 <solonarv> :t state . (id&&&)
13:45:35 <lambdabot> MonadState s m => (s -> s) -> m s
13:47:24 <solonarv> that is getAndModify, you can also write it using lens
13:47:51 <solonarv> :t \f -> id <<%= f
13:47:52 <lambdabot> MonadState s m => (s -> s) -> m s
14:06:56 <pounce> int-e: you still here
14:11:51 <codedmart> I am trying to build haskell-dbus on freebsd. I am getting and error `Not in scope: type constructor or class 'HsType'\ Perhaps you meant 'Type'`?
14:20:14 <pounce> nvm got it kinda
14:30:40 <fragamus> monochrom: I dont want to end up with a list of states at the end I just want one state
14:36:09 <jle`> codedmart: how are you building it?
14:40:46 <codedmart> Just pulled from git. Then stack build.
14:41:12 <codedmart> I pulled the repo becaues I saw the same errors when trying to build something that depends on that.
14:41:26 <jle`> does the repo have a stack.yaml?
14:42:10 <codedmart> Yup
14:45:56 <codedmart> jle`: For reference that specific module `DBus.Internal.Types` builds fine on linux.
14:49:07 <jle`> ah, so it builds on some OS's but not on others
14:49:16 <codedmart> Yes
14:49:26 <codedmart> Sorry I just checked that to be sure.
15:21:16 <codedmart> What is HsType? How could I inspect it in ghci?
15:22:59 <mniip> sounds like a thing from GHC
15:24:00 <mniip> right so that looks like a type that closely corresponds to the syntax of haskell, as in its AST, as opposed to the desugared types in Core
15:37:29 <codedmart> I guess I just don't understand if it is part of GHC that I am getting an error on FreeBSD about that type constructor not in scope.
16:02:54 * hackage persistent-mysql 2.10.2.3 - Backend for the persistent library using MySQL database server.  https://hackage.haskell.org/package/persistent-mysql-2.10.2.3 (parsonsmatt)
16:04:54 * hackage persistent 2.10.5.1 - Type-safe, multi-backend data serialization.  https://hackage.haskell.org/package/persistent-2.10.5.1 (parsonsmatt)
16:58:09 <heath> anyone recall a gist on the different structures of a haskell program. IO vs Effects vs Tagless vs ReaderT vs Free... it was formatted as a table
17:34:58 <Arahael> How do I create a monad, in practice?  I have a sum type 'Foo', but I want to use it as if it were a monad, however, it seems I can't.  Do I need to define a MonadFoo wrapper type instead?
17:35:15 <Arahael> I suppose what I really should be using instead is a State monad.
17:37:32 <ChaiTRex> Arahael: Monads aren't that kind of type. That's Foo. You need a type like Foo a.
17:38:02 <Arahael> ChaiTRex: What I want, is a do-notation that lets me mutate Foo.
17:38:21 <ChaiTRex> Arahael: You can use the state monad.
17:38:55 <Arahael> Yeah, I think it's the state monad I'm after.  Not entirely sure why I can't define it in terms of Foo, directly.
17:38:58 <Arahael> I'm doing `type FooM = State Foo`
17:39:18 <solonarv> yes, that is a valid definition
17:39:54 <maerwald> I haven't figured out what you really want. First you want monads, then do-notation... but what's the actual problem :>
17:41:02 <Arahael> maerwald: I wanted do-notation, actually. I want to, given a Foo, and other details, determine a new Foo.
17:41:12 <Arahael> ie, Foo -> a -> Foo
17:41:26 <Arahael> And I wanted to chain these computations.
17:42:09 <solonarv> if you rearrange the arguments to 'a -> Foo -> Foo' you can chain them with ordinary function composition
17:42:26 <maerwald> was gonna ask what's wrong with function composition :>
17:42:39 <Arahael> Then I'd have to wrap ()'s on every line...
17:43:01 <ChaiTRex> Arahael: What do you mean by wrap ()s?
17:43:20 <ChaiTRex> Arahael: You think it would be very nested parentheses?
17:43:26 <Arahael> Yes, I think it'd end up nested.
17:43:53 <Arahael> I'll give a play with the functional composition, perhaps I reached for 'do' too early.
17:43:57 <ChaiTRex> Arahael: No, you can use things like fold to do it.
17:44:34 <ChaiTRex> Arahael: foldr f startingFoo [a, b, c, d, e, f]
17:44:37 <maerwald> always reach for the simplest solution, unless you have good evidence that it's annoying enough
17:46:30 <ChaiTRex> :t foldr
17:46:31 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
17:46:56 <ChaiTRex> :t foldl
17:46:57 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
17:49:41 <solonarv> you can also just write (f . g . h) x
17:50:00 <Arahael> solonarv: Except my f, g ,and h have their own parameters.
17:52:33 <Arahael> This is what I have - https://gist.github.com/arafangion/0add5b3016f3c8cbea26e24bed1e4da4
17:52:59 <Arahael> I'd prefer not to have to wrap the lines with () and prefix with ., as shown on lines 9-11.
17:53:39 <Arahael> Let me provide a slightly more complete example - showing the typeclass...
17:54:18 <Arahael> Updated - should be clearer now.
17:54:52 <Arahael> (So yeah, I was hoping to avoid the ()'s for lines 10 to 12)
17:55:08 <solonarv> good news, they're redundant! you can simply remove them
17:55:43 <Arahael> That's... Insane...  How? (And yes, indeed! They're redundant!)
17:55:59 <solonarv> well, (.) is just a plain old operator
17:56:02 <solonarv> % :i (.)
17:56:02 <yahb> solonarv: (.) :: (b -> c) -> (a -> b) -> a -> c -- Defined in `GHC.Base'; infixr 9 .
17:56:20 <solonarv> it is infixr 9
17:56:39 <solonarv> but function application binds tighter than any operator
17:56:57 <Arahael> Ah, I think that's what had confused me; I often used (.) with function application in other projects.
17:58:01 <Arahael> eg, `pack . show x`, forcing me to either do `(pack . show) x` or `pack $ show x`
17:58:35 * Arahael now defines pack . show instead as `tshow`, but he digresses.
18:04:43 <Arahael> Looks like I want `flip (.)`
18:05:21 <solonarv> that actually exists in base, it's called >>> and is exported from Control.Arrow
18:05:32 <solonarv> (and is more general, but that won't really matter here)
18:09:04 <maerwald> just use flip fmap
18:09:08 <maerwald> :o
18:10:07 <Arahael> I haven't implemented a Functor instance for this yet.
18:11:55 <maerwald> :t (+1) . (+1)
18:11:56 <lambdabot> Num c => c -> c
18:12:02 <maerwald> :t (+1) `fmap` (+1)
18:12:04 <lambdabot> Num b => b -> b
18:14:02 <Arahael> Which typeclass instance would that be using?
18:15:52 <maerwald>  Functor ((->) r :: Type -> Type)
18:16:43 <Arahael> There is so much I have to learn. :)
18:21:15 <carter> hey everyone: those who are feeling like it are welcome to check that my pkg candidate for the next release of vector works with their fave libs https://hackage.haskell.org/package/vector-0.12.1.0/candidate
18:21:55 <carter> cabal install https://hackage.haskell.org/package/vector-0.12.1.0/candidate # :) 
18:22:47 <carter> err
18:22:48 <carter> i mean
18:23:05 <carter> cabal install https://hackage.haskell.org/package/vector-0.12.1.0/candidate/vector-0.12.1.0.tar.gz #  :) 
18:27:05 <carter> wait, it only works with v1 install!
18:27:07 <carter> cabal v1-install https://hackage.haskell.org/package/vector-0.12.1.0/candidate/vector-0.12.1.0.tar.gz
18:42:07 <solonarv> I'm sure there's some incantation that works with v2 as well, but I am too tired to come up with it
18:47:54 * hackage vector 0.12.1.0 - Efficient Arrays  https://hackage.haskell.org/package/vector-0.12.1.0 (CarterSchonwald)
19:13:25 <pounce> what's a lens?
19:20:29 <Arahael> pounce: I'm very much a newbie, but lens are an abstraction - instead of explicitly creating a new data structure for hte given property, you cna define a set of lenses that explain how to do that for you.
19:21:17 <Arahael> pounce: Eg, suppose you have a record { header :: Text, footer :: Text }, you can define a single function "append", that can append text to either the header or the footer, using a lens parameter.
19:21:32 <Arahael> pounce: (Ie, you could say: append footer "hey")
19:22:13 <Arahael> pounce: And more importantly, they compose, which becomes very useful for nested data structures.
19:24:05 <pounce> humm
19:26:04 <Arahael> pounce: I mean, you coudl do `append theRecord footer "hey"`, and if tehRecord was a deeply nested data structure, you could do something like `append theRecord (a . b . c . d . e) "hey"` or something.
19:26:34 <Arahael> To append "hey" to property e, of property d, of property c, of property b, of property a, of theRecord.
19:26:51 <Arahael> I don't know if that syntax is valid, though, but that's the idea as I understand it.
19:32:59 <pounce> 🤔
19:36:08 <Arahael> A poor alternative is xpath, I guess, or a 'key' in swift, except they don't compose all that well.
20:17:54 * hackage vector 0.12.1.1 - Efficient Arrays  https://hackage.haskell.org/package/vector-0.12.1.1 (CarterSchonwald)
21:44:54 * hackage hoauth2 1.11.0 - Haskell OAuth2 authentication client  https://hackage.haskell.org/package/hoauth2-1.11.0 (HaishengWu)
22:31:54 * hackage numhask 0.4.0 - numeric classes  https://hackage.haskell.org/package/numhask-0.4.0 (tonyday567)
22:32:54 * hackage numhask-hedgehog 0.3.2, numhask-prelude 0.3.3 (tonyday567): https://qbin.io/daniel-dinner-tusl
23:02:54 * hackage secret-sharing 1.0.1.0 - Information-theoretic secure secret sharing  https://hackage.haskell.org/package/secret-sharing-1.0.1.0 (PeterRobinson)
